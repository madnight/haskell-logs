00:00:06 <edwardk> you probably want tip use zip on the last two lists to get them paired up
00:00:11 <edwardk> zip [1,2,3] [4,5,6]
00:00:21 <edwardk> > zip [1.2.3] [4.5.6]
00:00:22 <lambdabot>   No instances for (GHC.Num.Num (f a), GHC.Num.Num (f1 a1))
00:00:22 <lambdabot>    arising from a...
00:00:27 <edwardk> gah i can't type
00:00:34 <edwardk> > zip [1,2,3] [4,5,6]
00:00:35 <lambdabot>   [(1,4),(2,5),(3,6)]
00:00:42 <edwardk> and then you can use lookup
00:00:44 <whereIsMyMind> ok..
00:00:45 <edwardk> @type lookup
00:00:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:01:06 <Saizan> bitbucket supports darcs?
00:01:08 <edwardk> > lookup 2 (zip [1,2,3] [4,5,6])
00:01:09 <lambdabot>   Just 5
00:01:46 <whereIsMyMind> edwardk: thx
00:01:57 <edwardk> so now all you need to be able to do is find the repetitions, you know how to do that with group. so you just need to figure out how to munge those individual elements, elementwise
00:02:24 <whereIsMyMind> i will try but doudb about it..
00:02:31 <whereIsMyMind> it's too high level for me..
00:02:31 <whereIsMyMind> :)
00:02:39 <edwardk> it only gets worse if you don't figure this part out ;)
00:03:01 <whereIsMyMind> loockup is part of prelude ?
00:03:02 <whereIsMyMind> lol..
00:03:11 <whereIsMyMind> w8 to c may next exercise :D
00:03:13 <edwardk> @where lookup
00:03:13 <lambdabot> I know nothing about lookup.
00:03:20 <edwardk> @hoogle lookup
00:03:20 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
00:03:20 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
00:03:20 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
00:03:27 <edwardk> yep its in the prelude
00:08:59 <whereIsMyMind> @hoohle replace
00:08:59 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
00:08:59 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
00:08:59 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
00:16:51 <whereIsMyMind> @hoohle trip
00:16:52 <lambdabot> Control.Parallel.Strategies parTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
00:16:52 <lambdabot> Control.Parallel.Strategies seqTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
00:16:52 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
00:22:06 <edwardk> whereIsMyMind: i made it up ;)
00:31:55 <Dashkal> terminology question.  in a case expression, what's the term for the expression immediately after 'case' and before 'of'?
00:36:26 <Dashkal> Oh hell, I just introduced a need for bottom.  Partial case statement...
00:38:16 * glguy ♥ Agda. latest creation :-D http://www.galois.com/~emertens/powerlist/powerlist.html
00:38:17 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
01:06:27 <edlinde> has anyone here got any good resources to understand RECURSION?
01:06:45 <edlinde> I realize that I don't know it as well as I thought I did :)
01:06:51 <edlinde> any awesome online links?
01:09:04 <edlinde> anyone?
01:09:55 <ivanm> edlinde: we can't just pull these resources out of nowhere you know!
01:10:04 <ivanm> edlinde: here you are: http://www.google.com.au/search?hl=en&q=recursion
01:10:06 <ivanm> :p
01:10:13 <edlinde> ivanm: yeah thanks.. :)
01:10:16 <edlinde> I done that too
01:10:27 <edlinde> but I thought you functional guys must know recursion inside out :)
01:10:34 <ivanm> sure we do
01:10:43 <ivanm> and those resources pretty much cover it
01:10:54 <edlinde> I was doing a C++ project recently and I needed tree recursion and was sometimes having headaches with it :)
01:10:55 <ivanm> alternatively, look at how SICP treats it
01:13:09 <edlinde> whats SICP?
01:13:31 <ivanm> @where SICP
01:13:32 <lambdabot> http://mitpress.mit.edu/sicp/
01:13:52 <ivanm> more infor about it here: http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs
01:14:35 <shachaf> edlinde: Try _The Little Schemer_.
01:15:09 <shachaf> edlinde: It uses Scheme, but the topic is recursion, as they say in the introduction.
01:15:30 <edlinde> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1
01:15:39 <edlinde> found this on recursion there.. looks interesting
01:15:41 <Saizan> do not unfold the recursion, trust the recursive step.
01:15:49 <edlinde> shachaf: k
01:15:52 <ivanm> just don't forget the base case
01:16:02 <edlinde> ivanm: yeah as always
01:16:03 <shachaf> edlinde: It's written in an unusual format -- http://www.ccs.neu.edu/home/matthias/BTLS/ has a sample chapter, towards the end, discussing the Y combinator.
01:16:09 <Saizan> s/step/call/ actually
01:16:41 <shachaf> edlinde: (And it's actually purely-functional (although strict) Scheme, so it's not that far from Haskell. :-) )
01:16:59 <edlinde> shachaf: the little schemer is not free?
01:17:10 <shachaf> edlinde: It's a published book.
01:17:21 <edlinde> ah i c
01:17:35 <edlinde> i just wanted to read the chapter on recursion :)
01:18:02 <shachaf> edlinde: The whole book is about recursion. See http://www.ccs.neu.edu/home/matthias/BTLS/preface.html
01:18:21 <edlinde> ah awesome
01:18:30 <edlinde> shit I got to get this book from somewhere then :)
01:18:35 <ivanm> edlinde: SICP is also a published book, they just happen to have a free online version
01:18:39 <edlinde> are the examples in Scheme?
01:18:52 <edlinde> ivanm: love it free :)
01:19:06 <edlinde> poor student mate ... got no money to buy too many books 
01:19:08 <edlinde> lol
01:19:09 <ivanm> and yes, the little schemer is in scheme, as is SICP
01:19:17 <ivanm> edlinde: that's what libraries are for!
01:19:22 <shachaf> edlinde: Yes, but as I said, a purely-functional dialect.
01:19:31 <edlinde> I am not near one right now... 
01:24:09 <edlinde> shachaf: with that little schemer book, do I have to try out the examples to understand them better?
01:24:32 <edlinde> shachaf: I am trying to learn some standard ML for a course I have to do next on Functional Programming
01:33:08 <triyo> Parsec sepBy returns [a] . Is there a way to insure that sepBy list result don't have trailing whiteSpace? ... here is my code: (colon *> (many (noneOf ":\n") `sepBy` symbol "::"))
01:33:51 <triyo> my results look like this:  ["ver 6.1.13   ","yet (another) todo   ","L, 8.0  "]
01:35:08 <ivanm> I don't know if parsec has a function like this, but you want one with type Parse a  -> Parse b -> Parse a
01:35:28 <ivanm> polyparse calls this discard, and it's basicaly: pa `discard` pb = do a <- pa; pb; return pa
01:35:55 <ivanm> @. pl undo \ pa pb -> do { a <- pa; pb; return a }
01:35:55 <lambdabot> (. ((. return) . (>>))) . (>>=)
01:36:01 <ivanm> @undo \ pa pb -> do { a <- pa; pb; return a }
01:36:02 <lambdabot> \ pa pb -> pa >>= \ a -> pb >> return a
01:37:31 <triyo> I see, I'm just trying to see how that will fit into the sepBy that splits my record into a list of items.
02:04:32 <dom1_> If you have f = ... where g = ... there was a trick using implicit parameters to find the type of g at the ghci prompt
02:04:52 <dom1_> But I can't find the post where this was described
02:05:13 <dom1_> Can anyone remember the trick or point me to a post?
02:07:35 <Baughn> Saizan: I'm always up for making my code harder to read, but you could be right. Well.. if the interface is good enough, I'll upload this as soon as I've finished the TH code and documentation; I can always fix the internals later.
02:07:35 <lambdabot> Baughn: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:07:39 <Baughn> @clear
02:07:39 <lambdabot> Messages cleared.
02:18:01 <quuxman> shachaf: how goes it?
02:18:44 <quuxman> shachaf: did I tell you I finished 5000 Years BC?
02:19:53 <Saizan> Baughn: the gadt way would prevent the possibility of adding other kind of indexes for the user, the typeclass approach requires figuring out a suitable interface
02:22:20 <Baughn> Saizan: Right, and the recursion scheme isn't identical in all cases, either.. look at how Insert works
02:22:33 <Baughn> Saizan: ..I think I'm relatively happy with how it works now.
02:28:10 <Saizan> that'd be subsumed too, you'd have a method foo :: db -> k -> (Index db k, Index db k -> db) so that you are given the index for the specific key and a way to rebuild the whole db from an updated one
02:30:23 <mauke> if I paste http://mauke.ath.cx/stuff/papers/1968-gwehenberger.txt here, will google find it?
02:47:22 <chrisdone> mauke: yeah
02:49:59 <Baughn> What, already?
02:50:23 <Baughn> ..nope, not already.
02:54:24 <Maniek_M> http://www.youtube.com/watch?v=MjV-_PBrEhY
03:36:05 <mm_freak> how can i access a type variable from inside an equation?
03:36:11 <mm_freak> invertSBox :: (Bounded a, IArray UArray a, Ix a) => UArray a a -> UArray a a
03:36:11 <mm_freak> invertSBox = array (minBound :: a, maxBound :: a) . map swap . assocs
03:36:31 <mm_freak> this fails, because the 'a' in the equation is different
03:36:45 <chrisdone> i recall there is a way to do this but i can't remember it
03:37:07 <mauke> what happens if you omit the type annotations in the body?
03:37:30 <mm_freak> mauke: indeed, that makes sense
03:37:32 <mm_freak> thank you
03:37:33 <BMeph> :set -XScopedTypeVariables
03:37:35 <mm_freak> it works
03:37:49 <mm_freak> BMeph: good to know, thanks to you, too
03:38:13 <danharaj> Are lexically scoped type variables in Haskell 2010?
03:39:10 <mauke> you can usually avoid scoped type variables
03:39:17 <mauke> it can get ugly, though
03:40:06 <danharaj> We're all about aesthetics.
03:41:04 <mm_freak> btw, can i write the above code without flexible contexts?
03:42:11 <mm_freak> ah yes
03:42:16 <mm_freak> figured it out myself
03:42:36 <mm_freak> invertSBox :: (Bounded w, IArray a w, Ix w) => a w w -> a w w
03:43:30 <mauke> aww
03:43:47 <chrisdone> lol
03:46:01 <mm_freak> hehe
03:49:32 <Zolomon> I'm a C# and imperative developer. Should I go straight for Haskell if I'm interested in FP or transition over to F# and then to Haskell if I wish to learn FP?
03:52:22 <mauke> dunno
03:52:23 <mreh> Zolomon, I'm going to tell you in the only way you'll understand. Program Haskell!
03:52:28 <Eduard_Munteanu> Zolomon: as you probably know from C# (and a bit unlike C), learning a language effectively requires you to learn a fair bit of the standard library.
03:52:48 <Eduard_Munteanu> Zolomon: so if your goal is Haskell, you're probably wasting time with other languages.
03:52:59 <Zolomon> Eduard_Munteanu: Goal is FP. :)
03:53:21 <Zolomon> Eduard_Munteanu: And learn where and when to use it.
03:53:26 <mreh> FP is really broad, so just go with what you're comfortable with
03:53:35 <Saizan_> depends, with F# it'll be a less steep learning curve and you'll never quite be required to change the way you think about programs
03:53:37 <mreh> Haskell is like extreme FP
03:54:04 <Zolomon> I guess that it's a better choice then.
03:54:07 <Zolomon> Thanks. :)
03:54:08 <Eduard_Munteanu> Functional programming fits best with pure semantics IMHO, so pure languages might be a better way to go.
03:54:21 <Eduard_Munteanu> And on the other hand, you'll get the full taste of it with Haskell :)
03:54:36 <mreh> and on the other hand, Haskell
03:54:43 <mreh> and on the other hand, Haskell!
03:54:43 <Eduard_Munteanu> :)
03:55:21 <Eduard_Munteanu> I'd rather recommend Lisp than F# anyway.
03:55:38 <mreh> what is F# anyway
03:55:44 * mreh googles
03:55:52 <max_atreides> dialect of OCalm
03:56:15 <mauke> Lisp isn't fun enough
03:56:20 <Eduard_Munteanu> Well, I don't know much about it, but AFAICT it rather goes Python's way of integrating FP concepts.
03:56:33 <Eduard_Munteanu> mauke: now now... call-cc is fun enough :P
03:56:41 <mauke> Eduard_Munteanu: I don't think that's in Lisp
03:56:55 <Eduard_Munteanu> Am I confusing with Scheme?
03:56:58 <mauke> wait, if F# is anything like OCaml, it's very unpythonish
03:57:12 * Eduard_Munteanu looks it up too...
03:57:16 <companion_cube> call-cc is in scheme
03:57:51 <companion_cube> but ocaml is a good transition to FP, imho, since you can use side effects without having to handle monads
03:58:09 <mauke> companion_cube: same thing applies to Haskell
03:58:21 <mauke> want side effects? just use IO
03:59:04 <Eduard_Munteanu> Not really. I mean you'll have to dodge lots of stuff to keep your programming style in Haskell.
03:59:35 <Eduard_Munteanu> Yeah, OCaml and F# look well FP.
03:59:42 <mm_freak> well, actually F# has a lot of similarities to haskell
03:59:56 <mm_freak> but it's neither pure nor lazy
04:00:06 <companion_cube> mauke: well, "just use IO" means "just understand what a monad is", "just change your functions signatures", and so on
04:00:23 <bremner> plus F# has a really obnoxious advocate :)
04:00:38 <mm_freak> bremner: jon?
04:00:53 <Eduard_Munteanu> Haskell had a very obnoxious funding source :P
04:00:59 <bremner> heh. 
04:01:31 <bremner> F# is two for two :)
04:01:35 <mauke> companion_cube: no, it doesn't
04:01:45 <mauke> companion_cube: you can completely ignore monads and still use IO
04:01:54 <mm_freak> companion_cube: you don't need to understand monads or even the IO monad to use it
04:01:58 <mauke> you have to understand what IO is, of course
04:02:04 <mreh> when people say Lazy State monad, they mean, the state variable is not strict?
04:02:23 <mm_freak> understanding what monads are and why IO is a monad helps you program in ways, which are not available in other languages
04:02:34 <mm_freak> but that's strictly optional
04:02:51 <max_atreides> F# means that FP is starting to gain traction in the industry, which is a good thing.
04:03:17 <Eduard_Munteanu> A better example is Erlang.
04:03:18 <mm_freak> yes, F# will make it into VS 2010, if it hasn't already
04:03:46 <Eduard_Munteanu> That has been around for quite some time in the industry.
04:03:55 <mm_freak> Eduard_Munteanu: i don't think erlang is a good example for that
04:04:06 <mm_freak> only few actual erlang applications are avaibable
04:04:13 <danharaj> People use erlang?
04:04:19 <danharaj> </troll>
04:04:27 <mm_freak> people use all languages, even brainfuck =)
04:04:44 <bremner> fsvo use
04:05:02 <burp> @bf +++++++[>+++++++<-]>+++.--.
04:05:02 <lambdabot>   42
04:05:16 <Eduard_Munteanu> @bf ,.[
04:05:17 <lambdabot>   bf: Error in array index
04:05:24 <Eduard_Munteanu> @bf ,.]
04:05:24 <lambdabot>  Done.
04:05:33 <Eduard_Munteanu> @bf [,.]
04:05:34 <lambdabot>  Done.
04:05:35 <mm_freak> @bf +[]
04:05:40 <lambdabot>  Done.
04:05:41 <mm_freak> ;)
04:05:42 <Eduard_Munteanu> Don't remember much.
04:05:43 <mm_freak> huh?!
04:05:55 <mauke> @bf -.
04:05:56 <lambdabot>  Done.
04:06:01 <mm_freak> @bf [>+]
04:06:02 <lambdabot>  Done.
04:06:12 <mauke> @bf +.
04:06:12 <lambdabot>  Done.
04:06:32 <mm_freak> +[] should be an endless loop, shouldn't it?!
04:06:44 <Eduard_Munteanu> Hm, Brainfuck is probably the fastest way to write 'cat' without any arguments.
04:07:14 <Eduard_Munteanu> I think so. Perhaps lambdabot quits execution without complaining.
04:07:14 <mauke> Eduard_Munteanu: perl -pe ''  # empty program
04:07:19 <mauke> and supports real arguments
04:07:26 <shachaf> #!/usr/bin/cat
04:07:28 <Eduard_Munteanu> Wow, heh.
04:07:31 <shachaf> Er, /bin/cat.
04:08:07 <mm_freak> hmm
04:08:12 <mm_freak> main = interact id
04:08:40 <Eduard_Munteanu> Yeah, that does it too.
04:09:13 <Eduard_Munteanu> Still the C equivalent is miles long compared to that.
04:09:46 <mauke> main(c){while((c=getchar())>=0)putchar(c);}
04:11:04 <Eduard_Munteanu> Except you still need the includes :P
04:11:08 <mauke> no, I don't
04:11:43 <mauke> how about the smallest possible infinite loop?
04:12:03 <Eduard_Munteanu> Or you mean: int getchar();putchar(int c);main(c){while((c=getchar())>=0)putchar(c);}
04:12:07 <mm_freak> main = getArgs >>= mapM_ (readFile >=> putStr)
04:12:10 <mm_freak> i think that should work
04:12:18 <Eduard_Munteanu> > [1..]
04:12:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:12:25 <mauke> Eduard_Munteanu: no
04:12:29 <Eduard_Munteanu> Depends on what you mean by loop though.
04:12:49 <mauke> have you actually tried my C program?
04:13:16 <Eduard_Munteanu> mauke: no, but the effect you're describing probably relies on implementation-dependent stuff.
04:13:17 <mauke> by infinite loop I mean a program that, when run, doesn't do any I/O and doesn't terminate
04:13:23 <mauke> Eduard_Munteanu: no, actually
04:14:33 <danharaj> Is it part of the C standard that stdio.h is implicitly visible?
04:14:35 <shachaf> main = fmap fmap fmap interact fmap fix return
04:14:51 <mauke> danharaj: no
04:14:54 <shachaf> danharaj: No.
04:15:14 <danharaj> Then how does mauke's program compile
04:15:17 <companion_cube> you will have a warning, i guess, but std lib is linked
04:15:39 <mauke> the C standard doesn't specify warnings
04:16:23 <danharaj> huh. I wonder if that's true in C++, which is only what I've worked with.
04:16:48 <Eduard_Munteanu> mauke: if you're relying on that, then the compiler must actually infer prototypes.
04:16:59 <mauke> hah, "infer"
04:17:20 <Eduard_Munteanu> Yeah, sounds strange to apply that to C :)
04:17:28 <mauke> why does the compiler need a prototype?
04:17:38 <companion_cube> well, it seems to compile and work correctly !
04:17:39 <Eduard_Munteanu> mauke: it must be able to generate proper calling conventions.
04:17:53 <mauke> Eduard_Munteanu: no
04:18:14 <mauke> there is a standard calling convention, and the compiler generates code for it
04:18:59 <Eduard_Munteanu> mauke: but that standard convention might not be straightforward on non-x86.
04:19:07 <mauke> so?
04:19:26 <mauke> all the compiler needs to know is the types of the arguments used in the call, and it already has those
04:19:54 <danharaj> I don't think C99 allows this, strictly.
04:20:01 <mauke> true
04:20:02 <Eduard_Munteanu> mauke: still, it has to infer the prototype somehow.
04:20:02 <Jafet> C: type inference for the brave.
04:20:14 <mauke> Eduard_Munteanu: no, it just has to generate a call to the function
04:21:26 <Eduard_Munteanu> mauke: suppose you had a function void setfloat(float x), but didn't produce a prototype for it. Then you call it like this: main() { int x; setfloat(x); }
04:21:37 <mauke> ok
04:21:43 <Eduard_Munteanu> Similarly, what happens if that function has a return value.
04:21:51 <Eduard_Munteanu> And the calling convention returns it on stack.
04:22:14 <Eduard_Munteanu> mauke: in my previous example, the conversion won't take place.
04:22:24 <mauke> right
04:22:31 <Jafet> That's like going to russia without a passport
04:23:26 <mreh> http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/ -- can someone please explain why the first example is useful?
04:23:38 <hoknamahn> going to any country without a passport is a bad idea
04:23:50 <Eduard_Munteanu> Secondly, I'm not really sure that should be a warning according to the standard.
04:25:04 <Eduard_Munteanu> (could be, since it seems declarations without extern work almost like those with extern)
04:25:17 <mreh> maybe I'll get it if I can dry run monad code better
04:25:32 <mauke> Eduard_Munteanu: there's a difference?
04:26:27 <Eduard_Munteanu> mauke: actually yes, think about declaring something like "int x;" in a header, vs. "extern int x;"
04:26:54 <mauke> oh, I think of "int x;" as a definition
04:27:04 <mauke> and I ignore the whole "tentative definition" stuff
04:27:24 <roconnor> mreh: the first example illustartes a valaid state monad program that looks broken.
04:27:36 <Eduard_Munteanu> mauke: yeah, I mean you could run into problems when declaring stuff that should be defined somewhere else without extern
04:28:37 <mreh> roconnor: yeah, I'm dry running it now to see how it evaluates
04:28:43 <Eduard_Munteanu> Though I admit, I don't see much difference for extern vs non-extern (and at the same time non-static) prototypes.
04:29:10 <Eduard_Munteanu> From a correctness POV, you should probably always have either extern or static on prototypes.
04:29:17 <roconnor> mreh: in step one, calling pro sets the state to some thunk
04:29:31 <roconnor> mreh: in step 2, that thunk is put into s
04:29:55 <roconnor> mreh: in step 3, the state is set to True: (that thunk)
04:30:14 <Eduard_Munteanu> (unless non-static non-externs allow you to redefine stuff in the local compilation unit, but I'm not really sure)
04:30:16 <roconnor> this is the result of pro
04:30:30 <roconnor> so (that thunk) = True : (that thunk)
04:31:02 <mauke> @src State >>=
04:31:02 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:31:23 <roconnor> @src (>>=) State
04:31:23 <lambdabot> Source not found. Wrong!  You cheating scum!
04:31:29 <roconnor> @src State (>>=)
04:31:30 <lambdabot> Source not found. It can only be attributed to human error.
04:31:32 <roconnor> :(
04:32:19 <mreh> State a >>= f = State $ \s -> let (b, s') = a s in runState (f b) s'
04:32:27 <mreh> from memory
04:32:42 <mreh> that runState makes it confusing
04:33:01 <roconnor> mreh: just strip the State and runState words.  They are noops
04:33:23 <mreh> roconnor: huh?
04:33:35 <roconnor> they are just newtype wrapers and unwrappers
04:33:50 <mreh> yah, they're type system trickery
04:33:50 <roconnor> a >>= f = \s -> let (b, s') = a s in f b s'
04:33:57 <roconnor> this the the operational content
05:01:44 <mreh> why did we opt for -> instead of .
05:02:12 <mauke> looks 3x better
05:03:14 <chrisdone> at only 2x the cost!
05:03:17 <chrisdone> bargain
05:03:48 <mauke> also, what would you rename . to?
05:04:03 <mreh> o
05:04:09 <mauke> terrible!
05:04:22 <mreh>  /o\
05:04:31 <mauke> `o`
05:04:48 <shachaf> ·
05:05:06 <mreh> *
05:05:06 <mauke> ∘
05:05:09 <chrisdone> mreh: is it not to match type theory?
05:05:17 <shachaf> ⁰
05:05:17 <Saizan_> be glad that it's not "fun x => .." line in ML
05:05:21 <Saizan_> *like
05:05:34 <chrisdone> oh, in the lambda expression
05:05:40 <mauke> { x | .. }
05:05:48 <chrisdone> yeah i prefer .
05:06:05 <chrisdone> \x y.x*y, mmm
05:06:40 <mauke> \f g.f `o` g
05:07:38 <mreh> does anyone have soft symbol replacement in their text editor?
05:07:50 <chrisdone> emacs does it
05:08:10 <mauke> not really, but I could hack it in vim
05:08:31 <shachaf> chrisdone: ∀it
05:08:38 <shachaf> (Except lexical scoping!)
05:08:49 <mreh> leksah looks awesome
05:08:53 <mreh> when did this happen?!
05:09:03 <FunctorSalad> does it have vim keys by now? :)
05:09:35 <FunctorSalad> when did what happen? the candy feature is quite old
05:09:53 <mauke> shachaf: including being scriptable in scheme?
05:10:22 <shachaf> mauke: Emacs is scriptable in Scheme?
05:10:30 <mauke> I'm asking
05:10:40 <mauke> you said ∀it
05:11:29 * chrisdone facepalms
05:11:40 <shachaf> mauke: And then I qualified.
05:11:56 <shachaf> Scheme is lexically scoped as far as I know.
05:12:01 <mauke> ah, that way
05:12:13 <mauke> conclusion: vim is superior
05:12:31 <chrisdone> what a surprising conclusion from mauke
05:12:41 <mauke> I know, right
05:12:47 <chrisdone> never know what to expect in here
05:12:49 <chrisdone> :p
05:12:54 <mreh> what is a Haddock interface file
05:12:56 <shachaf> Anyway, Emacs is an OK-ish operating system that even includes a fairly-good text editor called VIPER.
05:13:07 <mauke> I don't like viper
05:13:52 <mauke> I'd like an editor that is at least as programmable as emacs, but with vim's language support instead of elisp
05:13:55 <mauke> and vim defaults
05:14:20 <chrisdone> vim's language support as in how it's scripted or how it supports editing other languages?
05:14:29 <mauke> the former
05:14:32 * shachaf wonders why he's still awake.
05:14:57 <shachaf> mauke: What, vimscript?
05:15:01 <mreh> @localtime shachaf
05:15:02 <lambdabot> Local time for shachaf is Sat Jun 26 05:14:37 2010
05:15:08 <mauke> shachaf: among other things, yes
05:15:17 <mauke> vimscript could be optional, actually
05:15:19 <shachaf> Ha, that's actually correct now?
05:15:35 <shachaf> That server used to be further east, but it seems to be in my time zone now.
05:15:39 <mauke> shachaf: you can script vim in scheme and perl
05:15:49 <chrisdone> that's nice
05:16:09 <shachaf> mauke: Ah, I see.
05:16:09 <shachaf> Right.
05:16:12 <chrisdone> if you can script scheme or perl i imagine it has some simple foreign language interface
05:16:14 <chrisdone> right?
05:16:59 <mreh> @localtime mreh
05:17:56 <mauke> @localtime
05:17:57 <chrisdone> mauke: could you do... THIS in vim? http://gist.github.com/453933
05:17:59 <lambdabot> Local time for mauke is none of your concern
05:18:03 <FunctorSalad> -> looks more separaty than . , which I think is appropriate in a lambda
05:18:23 <mauke> chrisdone: looks trivial
05:18:53 <mauke> chrisdone: wait, what is that import "foo" Bar syntax?
05:19:23 <chrisdone> -XPackageImports
05:19:40 <mauke> oh god, emacs regexp
05:19:47 <mauke> emacs--  # just for that
05:19:59 <chrisdone> :(
05:20:41 <mauke> chrisdone: why do you sometimes use " " and sometimes "[ ]"?
05:21:03 <shachaf> @karma emacs
05:21:03 <lambdabot> emacs has a karma of 6
05:21:17 <shachaf> emacs-- # For dynamic scoping
05:21:55 <chrisdone> mauke: i use the character class for */+, just out of habbit i suppose
05:21:57 <mauke> yeah, seriously. you have a programmable editor, with callbacks all over the place. of course you want lexical scoping!
05:22:06 <FunctorSalad> surely this measure is biased due to the relative obscurity of what triggers it (this=@karma)
05:22:21 <mauke> preflex: karma emacs
05:22:21 <FunctorSalad> but I wonder towards what
05:22:21 <preflex>  emacs: 20
05:22:53 <mauke> chrisdone: I have a vim script (for C) that adds any missing includes for the identifier under the cursor?
05:23:00 <mauke> s/\?$
05:23:13 <mauke> could you do that in emacs?
05:23:17 <FunctorSalad> mauke: vim's haskell-mode has that
05:23:23 <FunctorSalad> several variants
05:23:32 <mauke> lolwut
05:23:35 <chrisdone> mauke: yeah
05:23:35 <FunctorSalad> _i _im _iq and something
05:23:52 <shachaf> @sarcasm mauke
05:23:52 <lambdabot> Unknown command, try @list
05:23:59 <FunctorSalad> (import this identifier only, import whole module, import qualified, respectively)
05:24:25 * shachaf is not sure.
05:24:28 <mauke> FunctorSalad: what does it do if that module is already imported?
05:24:44 <FunctorSalad> and it fails too, btw, if you happen to have the string "import" in the first column later in the file ;) (IIRC)
05:24:58 <chrisdone> mauke: my main complaint with emacs is speed and elisp. if i could use haskell i'd be happiest (like Yi), but then i lose one of the most valuable parts of emacs which is community
05:25:02 <FunctorSalad> I actually had that with a cheap & nasty code generator
05:25:18 <FunctorSalad> (I used CPP to linebreak strings)
05:25:29 <FunctorSalad> mauke: hmm, I don't know
05:26:54 <mauke> my script tries to be smart by getting the required includes from an internal list. if that fails, it asks man(1) for the SYNOPSIS. after that, it checks if any of the required includes are already present in the file. then it only adds the rest.
05:26:54 * shachaf should go to sleep.
05:28:02 <mauke> chrisdone: (> (length a) 0) looks inefficient :-)
05:28:12 <chrisdone> mauke: lol
05:28:49 <chrisdone> most of it's inefficient
05:29:02 <chrisdone> i shouldn't be using reduce .. (map ..
05:29:12 <chrisdone> it comes natural due to haskell but without the laziness benefits :(
05:30:03 <chrisdone> one day i will be good enough at the LOOP macro to write a horrible imperative but efficient mess
05:31:43 <mreh> is there a cabal option to automatically update?
05:33:41 <byorgey> mreh: what do you mean?
05:33:53 <mreh> byorgey, run cabal update automatically
05:33:59 <aristid> chrisdone: we need a special numerical type for which genericLength l > 0 is efficient :D
05:34:03 <mreh> when i try cabal install 
05:34:04 <byorgey> oh, I see, not that I know of
05:34:11 <Zao> aristid: Aren't lazy nats suitable for that?
05:34:16 <byorgey> that would be nice
05:34:43 <aristid> Zao: not sure :)
05:34:47 <byorgey> yes, they are =)
05:34:48 <aristid> Zao: what are lazy nats?
05:34:49 <chrisdone> yeah, lazy naturals are
05:35:38 <byorgey> aristid: data Nat = Zero | Succ Nat, with all the arithmetic and comparison operations implemented lazily
05:36:06 <byorgey> so comparing to zero would only need to check whether the number is zero, or Succ of something
05:36:15 <byorgey> but the somthing would not be computed
05:36:50 <byorgey> there's at least one package implementing them on Hackage
05:36:53 <aristid> byorgey: hmm! i wonder if there is a compromise, a lazy implementation that is a bit more efficient :)
05:37:00 <chrisdone> well tha tcould work for any number right?
05:37:05 <chrisdone> just make sure your (>) is lazy
05:37:14 <chrisdone> (any number == not just zero)
05:37:18 <byorgey> aristid: great question, I don't know
05:37:31 <byorgey> chrisdone: sure, I was just talking about the specific example of genericLength l > 0
05:37:38 <shachaf> instance Num [()]
05:37:52 <Jafet> Efficiency in Haskell is not always intuitive.
05:37:57 <chrisdone> k
05:38:18 <aristid> shachaf: funny to represent the length of a list as [()]
05:38:20 <Jafet> Nat for the purposes of comparing to zero, might be maximally efficient.
05:38:37 <byorgey> actually, I could easily imagine a type of lazy binary naturals.
05:38:51 <Jafet> You would also want to make the () strict, I think
05:39:03 <shachaf> aristid: Well, instance Num [a] would do too.
05:39:36 <mreh> is () a.k.a bottom
05:39:40 <shachaf> aristid: All you'd be doing is adding fromIntegral and putting the list-comparing function in your instance.
05:39:53 <aristid> mreh: no
05:39:55 <shachaf> mreh: () a.k.a unit
05:39:56 <chrisdone> () is just unit
05:40:03 <Jafet> () is both a value of type (), and a type that has two values, () and bottom.
05:40:46 <Jafet> Does it make sense to have a type whose only value is bottom?
05:41:00 <Saizan> yeah
05:41:07 <Jafet> data Void; I guess
05:42:03 <Saizan> right, which useful either because you're djinn, or because you want to use it for some phantom parameter 
05:42:09 <byorgey> sure, and Void is actually useful sometimes
05:42:17 <Jafet> If you feel like clowning around, you could have [Void] as isomorphic to Nat
05:42:25 <byorgey> not just for phantom parameters
05:42:53 <byorgey> for example if you have   data Expr a = Var a | Lit Int | Plus (Expr a) (Expr a)
05:43:11 <byorgey> then  (Expr String) is the type of expressions with String variable names
05:43:22 <byorgey> and (Expr Void) is the type of closed expressions which do not contain variables
05:43:50 <Saizan> you could argue that once you use Void it becomes phatom :)
05:44:24 <byorgey> I suppose =)
05:45:38 <roconnor> Jafet: [()] is isomorphic to Nat
05:45:46 <roconnor> [Void] is isomorphic to ()
05:45:53 <roconnor> so um
05:46:10 <roconnor> I guess [[Void]] is isomorphic to Nat :)
05:47:33 <portnov> () has single constructor (and so, single element). data Void; has no constructors (so, no elements).
05:47:38 <portnov> so, () /= Void.
05:47:38 <shachaf> roconnor: Why is [Void] isomorphic to ()?
05:48:00 <roconnor> the only value of [Void] is []
05:48:14 <portnov> hm. yes, seems so )
05:48:22 <roconnor> [x] isn't a value of [Void] because then x would be a value of Void which is a contradiction.
05:48:39 <Zao> Can't you do [_|_, _|_] or something?
05:48:59 <roconnor> I guess I'm not counting partial values
05:49:07 <aristid> > [undefined, undefined]
05:49:08 <lambdabot>   [*Exception: Prelude.undefined
05:49:11 <aristid> Zao: yes
05:49:22 <byorgey> [Void] is isomorphic to () in a total language, but not really in Haskell if you count _|_
05:49:38 <byorgey> but I usually like to think of Haskell as if it were a total language =)
05:50:09 <aristid> byorgey: but you don't really want it to be total?
05:50:13 <shachaf> byorgey: Don't we all? :-)
05:50:25 <aristid> > fix id
05:50:28 <lambdabot>   mueval-core: Time limit exceeded
05:50:45 <shachaf> What's the shortest way to type _|_ in lambdabot, by the way?
05:50:46 <byorgey> aristid: I do rather like my general recursion...
05:50:48 <shachaf> > (compare `on` length) "fix id" "undefined"
05:50:49 <lambdabot>   LT
05:51:07 <Jafet> @src undefined
05:51:07 <lambdabot> undefined =  error "Prelude.undefined"
05:51:17 <roconnor> > "fix id"
05:51:18 <lambdabot>   "fix id"
05:51:18 <Jafet> Bottoms come in many shapes and sizes.
05:51:21 <roconnor> > fix id
05:51:24 <lambdabot>   mueval-core: Time limit exceeded
05:51:50 <shachaf> Odd, it used to do clever loop detection.
05:51:58 <shachaf> Probably that was pre-mueval.
05:53:41 <aristid> shachaf: it's bottom either way
05:54:59 <Jafet> <<loop>> means ghc solved the halting problem!
05:55:14 <shachaf> ghc++
05:55:24 <chrisdone> i think the compiled version does loop detection, interpreted not
05:55:42 <mauke> chrisdone: does that emacs script work for 'import Foo((?), bar)'?
05:56:29 <chrisdone> mauke: hmm no, looks like my regex is too liberal on the module name
05:56:41 <chrisdone> i had a look on the haskell report for a spec of module names but didn't see anything
05:56:54 <mauke> \w+(?:\.\w+)*
05:57:19 <chrisdone> what characters does \w include?
05:57:33 <tao-> alpha chars
05:57:34 <mauke> A-Za-z0-9_
05:57:46 <tao-> alphanumeric
05:57:57 <chrisdone> are those the only allowed characters in a haskell module name?
05:57:59 <mauke> and, depending on your regex engine, all alphanumeric unicode characters
05:58:21 <Jafet> Is the report unicode aware?
05:58:36 <mauke> I don't know, but I've never seen a different module name
05:58:36 <shachaf> mauke: Doesn't the first character have to be [A-Z]?
05:58:44 <mauke> shachaf: yes
05:58:51 <chrisdone> shachaf: yeah but it doesn't matter for this
05:58:59 <shachaf> chrisdone: http://www.haskell.org/onlinereport/syntax-iso.html
05:59:15 <mauke> we're just recognizing valid module imports, we're not checking for correctness
05:59:20 <chrisdone> ahh nice one, i didn't think there'd be a full syntax ref
05:59:47 <shachaf> mauke: Ah, missed the context.
05:59:49 <chrisdone> (which is a stupid thing to think)
05:59:53 <shachaf> mauke: Is ' allowed in module names?
05:59:59 <mauke> oh, good question
06:00:13 <Jafet> It'll be fun if the consortium decides to revise the lettercase tables
06:00:29 <Jafet> s/$/ significantly/
06:00:40 <mauke> shachaf: yes
06:00:42 <chrisdone> shachaf: i thouht about that too
06:00:58 <chrisdone> yeah
06:01:08 <chrisdone> modid = conid, conid 	 -> 	 large {small | large | digit | ' } 
06:01:46 <shachaf> small apparently includes _.
06:03:03 * mauke decides to just use \k
06:05:23 <mauke> haha
06:05:42 <mauke> import qualified Data.Monoid as Control.Monad
06:06:01 <aristid> :t (~>)
06:06:02 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
06:06:21 <aristid> it hasn't lost it. yay.
06:07:00 <mauke> crap, that actually works
06:07:06 <chrisdone> mauke: ??
06:07:17 <mauke> chrisdone: hmm?
06:07:26 <aristid> mauke: qualified should be limited to dotfree identifiers :)
06:07:33 <chrisdone> nooo
06:07:42 <chrisdone> I use DB.T where T is the table name in my database
06:08:01 <aristid> chrisdone: you are evil therefore
06:08:02 <chrisdone> import Project.DB.TableName as DB.TN
06:08:54 <chrisdone> aristid: says the one who doesn't even format his import statements!
06:09:05 <aristid> guilty as charged :D
06:10:35 <mauke> why would I want to format them?
06:11:10 <chrisdone> good question
06:11:13 <aristid> mauke: so that all the DB.TN are aligned
06:11:27 <aristid> import                        Foo
06:11:32 <aristid> import   qualified           Bar
06:11:35 <Zao> You people sound like the kind of people that would align members in C++/C#/Java classes too.
06:11:38 <aristid> damn off by one
06:11:47 <chrisdone> aristid: this is why you need a library to do it for you
06:11:52 <aristid> Zao: i said i DON'T do it :P
06:12:21 <Zao> std::map<std::string, std::vector<T>> huhu;
06:12:22 <Zao> int                                   lol;
06:12:27 <Jafet> Smarty Haskell!
06:12:31 <aristid> Zao: lol!
06:12:35 <aristid> that >> is not legal
06:12:39 <Zao> aristid: In 0x it is.
06:12:48 <chrisdone> people take 0x seriously?
06:12:50 <aristid> Zao: 0x is not released yet
06:13:08 <Zao> aristid: FCD is out, and all the compilers I care about for most of my projects support suitable subsets.
06:13:11 <Jafet> chrisdone, it's more complex than C++, therefore it is superior
06:13:27 <Zao> Sticking to C++03 is like sticking to H98 :D
06:13:28 <aristid> Jafet: that's why Perl is superior to Python.
06:13:51 <Jafet> It generalizes well.
06:15:12 <aristid> Jafet: and if somebody is still not convinced, we can use the Proof by Example and compare everything to brainfuck
06:15:54 <theorbtwo> Programming to a spec instead of a set of compilers is often silly.  It's trading programmer time for compatability, often with things that don't actually exist, or your program is unliekly to ever run on.
06:15:55 <Jafet> That's constructivism, dear; it's frowned upon.
06:16:58 <aristid> theorbtwo: well, it might be somewhat reasonable if the set of compilers is not known
06:17:27 <mauke> the set of compilers is never known
06:17:45 <aristid> mauke: sure. everybody uses GHC
06:18:00 <mauke> "GHC" is not a compiler
06:18:09 <aristid> yes it is
06:18:12 <mauke> no
06:18:16 <aristid> oO
06:18:17 <chrisdone> GNU's Not Unix
06:18:34 <aristid> Peace is War
06:18:37 <chrisdone> Glasgow Haskell Compiler's Not A Compiler
06:19:05 <aristid> chrisdone: so that's where the NAC in GHCNAC comes from
06:19:06 <mauke> for the purposes of programming to it, you need at least an exact compiler version + options used
06:19:15 <Jafet> Hugs all around.
06:19:37 <mauke> it gets worse, because at least in C you don't know what your "compiler" actually does
06:19:58 <Ke> look at the disasm?
06:20:00 <chrisdone> someone's got an axe to grind
06:20:49 <theorbtwo> In C, you generally know "I only care about supporting machines with 8-bit bytes", and "I only care about two's compliment machines".
06:20:55 <mauke> Ke: that tells you that gcc-4.3.1 -O2 on platform X will generate this code for this exact input
06:21:06 <mauke> Ke: it doesn't tell you what any other source code will do
06:21:20 <mauke> theorbtwo: you still have to program to a spec
06:21:23 <theorbtwo> There's lots of simplifying assumptions you can make that will be valid on 99.9% of all machines.
06:21:29 <aristid> mauke: you're getting philosophic
06:21:31 <Jafet> theorbtwo: "Mmm, I'd love to see your 'trap bits'."
06:21:41 <mauke> aristid: no, practical
06:22:11 <mauke> aristid: I've seen my share of "if I remove this debugging printf, it segfaults; but if I leave it in, it works fine"
06:22:37 <theorbtwo> mauke: Which is the point at which you pull up valgrind.
06:22:58 <Ke> valgrind --attach-db=yes
06:23:18 <Jafet> I wonder if you can accomplish that with trace.
06:23:21 <mauke> or I could enable my brain when writing the code, to make sure I stay within the bounds of standard C as much as possible
06:23:40 <Ke> mauke: no way
06:24:17 <mauke> writing random C code, compiling it, then checking whether the resulting program works: bad idea
06:24:46 <Ke> you don't need to know every detail of the spec, if you avoid doing funny things
06:24:50 <theorbtwo> mauke: Yes, to some degree.  You shouldn't do random shit, but you can almost always write thiings that are not strictly standard C without it causing an error.
06:24:57 <aristid> mauke: they say that when you write random haskell code, and it typechecks, it will always be correct
06:25:11 <mauke> theorbtwo: you should still do it consciously
06:25:30 <theorbtwo> For example, struct foo {x[1]}, malloc to the correct length, and then access x[2].  Not legal, but will still work on 99.9% of compilers.
06:26:08 <theorbtwo> There is a legal counterpart in c0x (which should be called c1x now), but it's very difficult to do legally before then.
06:26:16 <mauke> integer over/underflow: undefined behavior, but will still work 99.9% of the time
06:26:21 <mauke> until you enable -O2
06:26:24 <mauke> then it breaks your program
06:26:57 <Ke> pfft noone uses signed integers
06:27:34 <Jafet> Ke: Word.
06:27:50 <Ke> depending on overflow behaviour is one of the things I would call funny
06:27:52 <aristid> > minBound :: Word64
06:27:52 <lambdabot>   0
06:27:57 <aristid> word.
06:28:45 <theorbtwo> Depending on overflow behavior seems insane.  Depending on it not to modify memory outside of that variable, I'd be surprised if it doesn't work... but I don't write much C.
06:29:39 <mauke> http://mauke.ath.cx/stuff/c/ubfun-1.c
06:30:17 <Ke> how long would it take to read c99 spec anyways
06:30:20 <Jafet> #haskell-with-occasional-forays-into-stereotypically-inferior-impure-languages
06:30:26 <Ke> I've never even seen it
06:30:36 <Ke> Jafet: !
06:30:52 <Saizan> yeah, really, to debate the details of C there's #c i believe
06:32:33 <chrisdone> Saizan: i think #hell redirects to ##c
06:32:58 <mauke> Jafet: Haskell won't save you
06:33:08 <mauke> overflow/underflow are undefined in Haskell as well
06:33:54 <aristid> mauke: there's no such thing if you use Integer
06:34:29 <mauke> types you can't use: Int, Word, Float, Double
06:36:06 <Jafet> Overflow isn't defined for Word?
06:37:56 <mauke> oh, it is
06:38:13 <mauke> Data.Word is "safe"
06:38:49 <endojelly> safe word is "Data"
06:39:07 <mauke> > negate 1 :: Word
06:39:08 <lambdabot>   18446744073709551615
06:39:34 <aristid> negate is defined on Word? oO
06:39:50 <endojelly> why not?
06:39:56 <Jafet> Sure. Word is Z/nZ
06:39:58 <aristid> i'd expect it to be bottom
06:40:16 <Jafet> It's also an instance of Num.
06:40:38 <Jafet> Making class methods bottom is quite unrecommended
06:40:50 <Jafet> I can't believe ispell thinks unrecommended is a word
06:41:06 <aristid> Jafet: oh, so what do you do about fail in Monad? :P
06:41:16 <Jafet> Well, it's... fail.
06:41:27 <aristid> Num is too monolithic
06:41:56 <mauke> > 1 + negate 1 :: Word
06:41:57 <lambdabot>   0
06:42:03 <mauke> > negate (negate 1) :: Word
06:42:04 <lambdabot>   1
06:42:12 <mauke> all the laws hold
06:43:12 <aristid> hmm
06:43:23 <Jafet> You also need to show it's unique!
06:44:21 <aristid> > (negate 0) + (negate 1)
06:44:22 <lambdabot>   -1
06:44:43 <aristid> > (negate 0) + (negate 1) :: Word
06:44:44 <lambdabot>   18446744073709551615
06:44:57 <aristid> > (negate 1) + (negate 0) :: Word
06:44:57 <lambdabot>   18446744073709551615
06:48:50 <ivan_> ciao
06:48:57 <ivan_> !list
06:49:45 <mauke> ivan_: this isn't #firefox
06:55:44 <sm> how can I have ghc 6.10 and 6.12 both installed on a mac ?
06:56:21 <Saizan> use linux for the OS?
06:56:30 <Saizan> sorry.
06:56:55 <shachaf> sm: Virtual machine.
06:57:25 <sm> Saizan: actually, can you install two versions on linux ?
06:57:35 <sm> shachaf: thanks.. any recommendations for a free one ?
06:57:50 <Jafet> Surely even mac os can't be that broken.
06:57:54 <shachaf> sm: I meant that jokingly. But VirtualBox, maybe?
06:58:02 <zygoloid> sm: i have both 6.8 and 6.12 installed here
06:58:04 <Saizan> sm: sure, the executables are versioned, and the unversioned symlink will point to the last one installed
06:58:04 <aristid> sm: i have used VirtualBox, which is nice and free, i'm not sure if it works on OSX
06:58:06 <shachaf> I'm sure you can install more than one version at the same time on OSX.
06:58:35 <Saizan> (the directories that contain the relevant files are versioned too)
06:58:59 <sm> zygoloid: both installed manually I guess ? do they share ~/.ghc ? what about the HP ?
06:59:11 <sm> and ~/.cabal ?
06:59:38 <Saizan> ~/.cabal and ~/.ghc have versioned subdirectories for the installed packages
07:00:01 <Saizan> the source tarballs and the cabal configuration will be shared
07:00:08 <sm> aha. Maybe my issue was just that the mac HP installer erases the old version
07:00:30 <sm> I will install both without fear, and keep virtualbox in reserve
07:00:31 <zygoloid> sm: ~/.cabal/bin seems to contain the binaries for the ghc version i built with most recently
07:00:38 <zygoloid> everything else seems properly versioned
07:00:50 <sm> hmm ok
07:00:51 <dcoutts> it's possible to install versioned binaries too if you like
07:01:17 <sm> a cabal option, dcoutts ?
07:01:45 <Tomsik> okay guys
07:01:51 <Tomsik> :t (.)(.)
07:01:52 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:01:59 <Saizan> --program-suffix="-$ver" or something similar?
07:02:23 <Tomsik> Prelude> :t (.)(.)
07:02:23 <Tomsik> (.)(.) :: (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
07:02:26 <sm> --bindir perhaps
07:02:26 <Tomsik> how do I get that?
07:02:34 <sm> great, thanks all
07:02:35 <Tomsik> and what is a1, just numbered a or?
07:02:47 <Saizan> a1 is just another type variable name
07:02:52 <Saizan> it's not related to a
07:03:21 <Saizan> the type lambdabot gives you is different because (.) = fmap there
07:03:32 <Saizan> while in the Prelude (.) f g x = f (g x)
07:04:23 <Tomsik> Okay, but how do I derive the thing that prelude gives
07:05:54 <shachaf> Tomsik: Step by step.
07:06:07 <shachaf> Tomsik: Try adding variable names and working it out.
07:08:41 <Tomsik> Am I just poor type inference machine or is my prof kind of a lunatic of asking us to type things like that or "let f x = map -1 x" on an exam?
07:09:17 <Saizan> you just need a bit of practice, it's not unreasonable at all as an exercise :)
07:09:58 <max_atreides> what are the expressions of type "something@(x:xs)" called? i want to find out what they mean :)
07:10:16 <Saizan> ok, let's say  x = (.) y = (.), and we want to find out the type of "x y", now we take the types of x and y using distinct sets of variable names: x :: (b -> c) -> (a -> b) -> (a -> c), y :: (b1 -> c1) -> (a1 -> b1) -> (a1 -> c1), since y is used as argument to x, then its type has to match the type of the first argument of x
07:10:31 <Saizan> so (b -> c) = (b1 -> c1) -> (a1 -> b1) -> (a1 -> c1)
07:10:47 <Tomsik> max_atreides: they mean that something is an alias of (x:xs), you can type "something" and "(x:xs)" interchangeably
07:10:57 <Saizan> so (b -> c) = (b1 -> c1) -> ((a1 -> b1) -> (a1 -> c1)) -- making associativity explicit
07:11:14 <Saizan> so b = (b1 -> c1) and c = ((a1 -> b1) -> (a1 -> c1))
07:11:22 <max_atreides> Tomsik: I see, thanks
07:11:31 <Saizan> max_atreides: it's called as-pattern btw
07:11:45 <mauke> preflex: seen chrisdone
07:11:45 <preflex>  chrisdone was last seen on #haskell-blah 9 minutes ago, saying: but it has a lot of traffic and data that's easy to access
07:12:35 <mauke> so I wrote a vim version of the import alignment script: http://codepad.org/8EshqKtb
07:12:45 <Saizan> x y :: (a -> (b1 -> c1)) -> (a -> ((a1 -> b1) -> (a1 -> c1)))
07:13:25 <Saizan> by substituting the above equalities in the type of the result of x when applied to a single argument
07:15:11 <Tomsik> Uhh, that's horrible
07:15:49 <mauke> my script?
07:16:25 <Tomsik> Nah, that type inference
07:16:41 <Tomsik> Saizan: thanks, it's kind of messy, but seems reasonable :)
07:17:21 <Saizan> then you can forget the superflous parens and you get "(a -> b1 -> c1) -> a -> (a1 -> b1) -> a1 -> c1" which is equivalent to the type given by ghci
07:19:33 <Saizan> Tomsik: heh, running algorithms by hand is never pretty :)
07:21:54 <Tomsik> yeah...
08:08:29 <ksf> Is there a way to get the type of a TH expression that hasn't been reified?
08:09:07 <ksf> @hoogle Exp -> Info
08:09:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:09:08 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
08:09:08 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:09:12 <ksf> @hoogle Exp -> Q Info
08:09:12 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
08:09:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:09:13 <lambdabot> Control.Monad.State.Lazy evalStateT :: Monad m => StateT s m a -> s -> m a
08:09:57 <aavogt> ksf: spliced?
08:10:05 <ksf> yep
08:10:17 <aavogt> infer the type yourself?
08:10:24 <ksf> I was fearing that.
08:10:42 <aavogt> there may be conversions to pretty-print the AST somewhere
08:10:51 <aavogt> then pass that string to hint or something
08:11:14 <aavogt> hmm, that could be lossy though
08:11:29 <ksf> well, I'm not actually interested in the type, I'm just interested in whether or not it has one specific type
08:11:47 <ksf> ...I want to sift out my applicative functor and let-bind the rest of the defs to names
08:11:56 <ksf> ...not only defs, but terms
08:13:46 <ksf> hmmm wait no I'm thinkng to complicated.
08:13:59 <aavogt> as in, pretty-printing doesn't capture that you're allowed to refer to things that aren't normally in scope there
08:14:06 <ksf> I know the types of every operation of my functor, so I can look at those applications and sift by that.
08:14:51 <aavogt> so the code will either work incorrectly, or not at all
08:15:08 <aavogt> at least if you refer to such variables
08:19:51 <ksf> Data.Generics doesn't seem to have an interface that allows me to trasform+collect at the same time...
08:20:57 <ksf> that is, replace stuff with new VarE's and returning both the changed original AST and a list of (Var, Expr)
08:21:20 <aavogt> there are monadic versions of some traversals
08:21:41 <aristid> aavogt: isn't concatMap a kind of traversal?
08:22:05 <aavogt> @type everywhereM
08:22:07 <lambdabot> forall (m :: * -> *) a. (Data a, Monad m) => GenericM m -> a -> m a
08:22:18 <ksf> aavogt, well, yes, I could do WriterT...
08:22:22 <aristid> oh you're talking about generic traversal stuff
08:22:41 <aavogt> aristid: concatMap doesn't let you keep state across each value you map over
08:22:42 <ksf> which is the solution I was looking for.
08:23:07 <aristid> aavogt: if you add StateT? :D
08:23:31 <aavogt> @type concatMap
08:23:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:23:46 <aavogt> there's no sequence there
08:24:06 <aristid> hm
08:25:04 <aavogt> @type concatMap (\_ -> [return () :: State String ()])
08:25:06 <lambdabot> forall a. [a] -> [State String ()]
08:25:38 * hackagebot graph-utils 0.3.5.1 - A simple wapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.5.1 (HiromiIshii)
08:28:22 <BarryCarter> Is there a Mathematica-to-Haskell convertor?
08:29:18 <Jafet> The legality of implementing that may be questionable.
08:29:25 <BarryCarter> Or a good Haskell tutorial specifically for Mathematica users?
08:29:50 <BarryCarter> Jafet: hmmm... you think Mathematica claims a "copyright" on their input format? It's pretty basic.
08:30:02 <Jafet> Perhaps you should take a matlab for mathematica users tutorial, then a C for matlab users tutorial, then a haskell for C users tutorial
08:30:21 <BarryCarter> Jafet:  LOL :) Unlike some relations, I'm not transitive.
08:30:25 <Jafet> I was making fun of you. Pick up LYAH or RWH.
08:30:39 <BarryCarter> Those are great acronyms -- what do they mean?
08:30:45 <Jafet> @lyah
08:30:45 <lambdabot> Unknown command, try @list
08:30:51 <zygoloid> @where lyah
08:30:51 <lambdabot> http://www.learnyouahaskell.com/
08:30:55 <zygoloid> @where rwh
08:30:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:30:58 <BarryCarter> Oh, that's the one I just ofund.
08:31:00 <BarryCarter> *found
08:31:20 <BarryCarter> The first one. But I'm looking for one written for Mathematica users -- people who already understand functional and symbolic programming.
08:31:42 <Jafet> BarryCarter, implementing such a converter involves translating large bits of the Mathematica engine and library to Haskell
08:31:49 <Jafet> And as I understand, they are secret
08:32:18 <BarryCarter> Jafet: I don't think so -- Mathematica just uses functions and it even gives standard names to the functions.
08:32:37 <BarryCarter> Jafet: You just have to do the same thing that Mathematica does, not in the same way.
08:32:49 <zygoloid> BarryCarter: i think Jafet is suggesting that it's the library and not the language which would be the problem
08:32:54 <Jafet> Part of their library even lets you access their online databases.
08:33:40 <BarryCarter> Jafet:  zygoloid: OK, the library access would be going too far -- I meant like translate 90% of it so that I can take the Mathematica programs I've written and convert them to Haskell in a machine-aided way.
08:33:57 <BarryCarter> zygoloid: I assume haskell implements the same functions, yes?
08:34:11 <Jafet> How would that teach you anything? If you just want to translate, hire someone to do it for you, who can do it correctly.
08:34:24 <Jafet> Haskell is not sage.
08:34:32 <Jafet> Well, it might be sage. It's not Sage.
08:34:54 <BarryCarter> Jafet: I'm looking to learn but I also don't want to hand-translate a bunch of code.
08:35:02 <BarryCarter> Is Sage the OS version of Mathematica?
08:35:22 <Ke> nope
08:35:25 <Jafet> It wants to be. Crazy kids.
08:35:51 <BarryCarter> Someone told me that Haskell is where to go for symbolic and functional programming.
08:36:35 <Jafet> If all your experience with "symbolic and functional programming" has been with the Mathematica command language, you're in for a good ride.
08:36:41 <BarryCarter> Ouch.
08:36:45 <zygoloid> BarryCarter: i'm not sure what you mean by "haskell implements the same functions". it's possible to implement the same functions in haskell. has anyone done it? i don't know... but i doubt it, since mathematica's library seems to be huge
08:36:50 <Jafet> I suggest flying goggles.
08:37:02 <aavogt> Jafet: what of symbolic computations in haskell?
08:37:05 <Jafet> And one of the above books.
08:37:21 <aavogt> as in, have you had much success doing such?
08:37:25 <enferex> I'm trying to declare the function: but I keep getting a ghc error.  Im declaring as:  "doLoop :: [String] -> [String]" http://pastebin.com/UZbKW0HZ 
08:37:26 <aavogt> which libraries do you use?
08:37:28 <BarryCarter> zygoloid: Oh, I get it now -- you're saying that Haskell doesn't have many of Mathematica's more unusual functions and you can't use Mathematica's .m files to implement them for copyright reasons.
08:37:38 <Jafet> aavogt, what kind of computation with what kind of symbols?
08:38:02 <BarryCarter> Jafet: A trivial example: (a+b)^2 expanded.
08:38:05 <zygoloid> BarryCarter: i know nothing about .m files. and i'm not sure what you mean by what Haskell "has". do you mean built-in, or in libraries?
08:38:11 <aavogt> like solving equations, rearranging them
08:38:17 <aavogt> Jafet: standard stuff
08:38:33 <BarryCarter> zygoloid: Libraries. Much of Mathematica's functions are written in simple Mathematica functions and distributed in files ending in .m
08:38:34 <aavogt> > (a+b)^2
08:38:34 <Axman6> BarryCarter: haskell is just a language, like C or Java or Python
08:38:35 <lambdabot>   (a + b) * (a + b)
08:38:44 <Jafet> Well, I've done symbolic calculators in other languages. The principles are quite universal.
08:38:59 <BarryCarter> Axman6: So it doesn't do symbolic stuff, like Mathematica (which is technically also a language)?
08:39:05 <Jafet> To answer your question strictly, no.
08:39:06 <Axman6> you can implement absolutely anything at all that you want
08:39:27 <Axman6> BarryCarter: it can, as has been demonstrated (it's actually extremely easy to do)
08:39:31 <ksf> actually, I should be working with StateT WriterT
08:39:33 <Jafet> BarryCarter, it will once you implement it.
08:39:35 <Axman6> but that's not part of the language
08:39:41 <BarryCarter> I guess my real question is: if I'm looking for an open source version of Mathematica, should I use Haskell, Sage, or just forget it?
08:39:53 <ksf> ...keeping track of the current ast.
08:39:59 <Axman6> if that's exactly what you want, then sage it is
08:40:08 <zygoloid> enferex: doLoop is not :: [String] -> [String]; you're using the IO monad, so the result will be in the IO monad.
08:40:21 <Axman6> haskell is, imo, far more useful than Mathematica
08:40:25 <enferex> zygoloid: [IO String] didnt seem to work either
08:40:46 <zygoloid> enferex: it should be IO [String] not [IO String]
08:40:50 <BarryCarter> Axman6: I suppose it depends on what you're doing. I've found Mathematica is awesome for harder math problems.
08:40:54 <enferex> zygoloid: Ah ok!
08:41:17 <zygoloid> enferex: [IO String] is a list of IO "recipes", each of which produces a string. but you want an IO recipe which produces a list of strings, so IO [String]
08:41:20 <pikhq> Well, of course Haskell is more *useful* than Mathematica. Haskell is a general purpose programming language.
08:41:36 <BarryCarter> pikhq: So is Mathematica, actually.
08:41:43 <Axman6> not really
08:41:57 <BarryCarter> It certainly claims to be.
08:42:00 <Axman6> you wouldn't write an operating system in mathematica
08:42:01 <enferex> zygoloid: Im still haveing a bit of trouble.  IO [String] -> IO [String] didnt seem to help
08:42:02 <pikhq> Mmm, right; it's secretely an M-expression Lisp with built-in symbolic manipulation libraries. :P
08:42:09 * zygoloid doesn't understand this mathematica disrespect
08:42:26 <enferex> zygoloid: Got it!
08:42:28 <BarryCarter> Whether a programming language can write an OS isn't really a good test.
08:42:39 <zygoloid> enferex: do you understand why it's right? :)
08:42:44 <Peaker> It's a good test, depending on what you want to test :)
08:42:51 <Axman6> whether a language can write anything at all is a pretty good test, that i'd like to see ;)
08:42:52 <enferex> zygoloid: Im trying to learn, as Im sure you can tell :-)
08:43:02 <BarryCarter> LOL :) It's a good test for winning arguments, I'm sure.
08:43:03 <aavogt> zygoloid: it's the same strategy as the haskell disrespect you get from some trolls
08:43:12 <zygoloid> Axman6: /I/ wouldn't write an OS in haskell either, even though i know it's been done...
08:43:16 <BarryCarter> Axman6: what would you like to see Mathematica do?
08:43:23 <Peaker> BarryCarter, If you want a systems programming language, then a good language to write an OS in is a good test
08:43:31 <Axman6> disappear, i absolutely hated it
08:43:33 <Peaker> I don't think Haskell is too great at systems programming
08:43:35 <zygoloid> aavogt: yes, but i thought we were better than that.
08:43:41 <Axman6> matlab's not much better, though simulink is awesome
08:43:56 <BarryCarter> Peaker: I want an everyday language, not one that has deep OS roots.
08:43:58 <Axman6> possibly the worst thing about mathematica was the licencing
08:44:13 <Axman6> heh, haskell certainly does not have deep OS roots
08:44:13 <BarryCarter> Axman6: That's where I'm 100% with you and want a free alternative.
08:44:25 <Peaker> BarryCarter, IOW you don't want a systems programming language :)
08:44:54 <BarryCarter> Peaker: I guess so :) I'm thinking like Perl/Ruby/PHP style. And yes, I know they can do system stuff w certain libraries.
08:45:16 <Axman6> BarryCarter: the question that we should have asked you by now is what exactly do you want to do with a mathematica alternative?
08:45:44 <BarryCarter> Axman6: You hit the nail on the head. I dislike using commerical, closed source programs. I'd much rather use an open source version.
08:46:10 <BarryCarter> Axman6: Or are you asking me re a specific problem?
08:46:16 <Axman6> i don't have a problem with closed source programs, but the way mathematica's licencing system works annoyed me hell out of me
08:46:28 <Axman6> yes, what specific problems do you want to solve
08:46:37 <BarryCarter> Axman6: I dislike closed source programming period...
08:46:57 <Axman6> bah, damn GPL lovers ;)
08:47:16 <BarryCarter> OK, first: I've got a bunch of {x,y,z} points that map {x,y} to z. I want to create an "interpolation grid" for them so they're defined continuously not discretely.
08:47:30 <deech> Hi all, I've been looking at the type families and dependant types paper (http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf) and I am failing to see how type families offer an advantage over functional dependencies.
08:47:45 <Axman6> doesn
08:47:52 <Axman6> doesn't sound too hard in haskell
08:48:09 <zygoloid> deech: they play more nicely with GADTs
08:48:15 <BarryCarter> OK, next: I want to implement the Black-Scholes formula for option prices.
08:48:33 <zygoloid> deech: they're also more intuitive (in my opinion at least)
08:49:00 <Axman6> i don't know the formula, but i can't see why it should be hard
08:49:21 <BarryCarter> It involves the normal distribution and an "unsolvable" integral.
08:49:44 <deech> zygoloid: so type families are just syntactic sugar for dependant types?
08:50:06 <ksf> what's up with equality of TH names?
08:50:50 <zygoloid> deech: neither fundeps nor type families offer much in the way of dependent typing
08:51:05 <mauke> they are all equal, but some are more equal than others
08:51:14 <zygoloid> the type equality stuff does give you a little, but it still falls very far short
08:51:15 <ksf> ah doh.
08:52:59 <Axman6> BarryCarter: can't see why that would be hard either. if there's a well known way of approximating the integral, then it should work fine
08:53:07 <ksf> ...it's still not worknig with qualified ones, though.
08:53:36 <BarryCarter> Axman6: I'll give it a shot in Haskell, but if it's a lot more work, that's just as bad.
08:53:53 <zygoloid> BarryCarter: the first page of google results for 'haskell black scholes' links to at least three implementations
08:53:58 <ksf> ...I should quote those things and not use mkName
08:54:16 <ksf> see, those thousands of pitfalls are the bane of TH
08:54:31 <Axman6> anyway, if you're interested in programming, haskell is one of the languages i think you should know, the others being C and the ideas behind assembly
08:54:35 <Jafet> BarryCarter: yes, learning Haskell is a lot of work and no, you can't program Haskell without learning Haskell
08:54:50 <deech> zygoloid: Hmm.. I see thanks
08:55:30 <BarryCarter> zygoloid: Wow, thanks!
08:55:51 <deech> Axman6: No OO on that list? :)
08:55:56 <Axman6> no
08:55:56 <Jafet> BarryCarter: decide what your meaning in life is and whether that involves taking the elevator down the ivory tower to learn programming properly
08:56:04 <Axman6> oo is a waste of time
08:56:13 <BarryCarter> Jafet: I guess I meant: if I do learn Haskell, does it have a lot of functions "built in" or easily available so that I can start writing things that use fairly sophisticated functions?
08:56:25 <Axman6> unless you want a boring, but probably decently paying job
08:56:31 <BarryCarter> Jafet: There's nothing wrong w Mathematica programming.
08:57:05 <Axman6> yes there is
08:57:07 <deech> Axman6: Perhaps it is not optimal, but job aside, even if you want to contribute to OSS you need it.
08:57:13 <aristid> Axman6: i'm pretty sure that sometimes the best solution to a problem in haskell is quite similar to OOP
08:57:25 <BarryCarter> Axman6: Why?
08:57:32 <Jafet> deech: http://paulgraham.com/reesoo.html http://video.google.com/videoplay?docid=-2950949730059754521
08:58:08 <Tomsik> OO languages lack lots of things
08:58:12 <Axman6> because it is, it's a broken paradigm, that doesn't really work in a highly parallel and concurrent world
08:58:21 <Jafet> BarryCarter, there is something wrong with trying to code language X in language Y instead of learning to code language Y in language Y.
08:58:28 <Tomsik> C++0x might be the first to break this trend, i think
08:58:42 <Jafet> Tomsik may also be interested in the links above.
08:58:48 <pikhq> Tomsik: C++ lacks nothing. *This* is its flaw.
08:58:51 <BarryCarter> Axman6: OK, that's pretty high-level thinking. I just meant to solve basic problems.
08:59:00 <aristid> Axman6: so you never use existential records with functions as members?
08:59:08 <aristid> -existential
08:59:11 <pikhq> BarryCarter: Basic problems rapidly become complex ones.
08:59:13 <BarryCarter> Jafet, but I like Mathematica's approach conceptually and hope that Haskell follows it.
08:59:20 <Axman6> aristid: not to my knowledge, no
08:59:28 <monochrom> See http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html and http://hackage.haskell.org/packages/archive/pkg-list.html for what is already written and you can just use.
08:59:33 <BarryCarter> pikhq: But not to the point of parallel programming
08:59:48 <pikhq> Parallel programming in Haskell is easy.
08:59:49 <aristid> Axman6: i'm not saying that you always need it, but i do think that some problems might have a use for it.
08:59:56 <Jafet> BarryCarter, unfortunately, our reality does not conform to your hopes.
09:00:06 <Peaker> pikhq, C++ lacks many useful things, while being a huge beast
09:00:10 <BarryCarter> Jafet: That's what I'm starting to pick up.
09:00:13 <pikhq> foo `par` bar `pseq` baz foo bar
09:00:29 <pikhq> Bam, I calculate foo and bar in parallel and then do baz foo bar.
09:00:53 <aavogt> pikhq: you suggest that the RTS could do that
09:00:54 <aristid> pikhq: is it also necessarily efficient?
09:01:00 <Axman6> in a way i guess that haskell does somewhat allow you to use some of the main ideas in OOP, such as having data, and functions that operate only on data of certain types
09:01:02 <Jafet> pikhq, * Exception: stack overflow
09:01:08 <pikhq> aristid: Nope!
09:01:12 <Tomsik> Seriously, how much easier writing in C++ would be if you had at least minimal pattern-matching and lambda expressions
09:01:20 <Axman6> but i feel the FP/Haskell way of doing that is much much nicer
09:01:27 <pikhq> aavogt: True; it may well say "dude, I've got 1 thread; that's going sequentially".
09:01:49 <Jafet> Tomsik, it would be much harder and more confusing, since those concepts are not compatible with C++ semantics.
09:01:58 <Jafet> (Of course, that doesn't stop them from trying...)
09:02:03 <pikhq> Tomsik: Add garbage collection. That alone fixes giant chunks of it.
09:02:18 <Tomsik> Actually, garbage collection is not something I'd want in C++
09:02:24 <mauke> pikhq: garbage collection is incompatible with the C VM
09:02:33 <monochrom> pattern-matching presupposes union types
09:02:33 <Philippa> BarryCarter: you'll probably get more sensible responses if you tell people what kind of basic problems you want to solve. Haskell isn't a CAS, for example
09:02:48 <pikhq> mauke: Conservative GC works with it. *Barely*.
09:02:57 <mauke> pikhq: except when it doesn't :-)
09:02:59 <pikhq> Tomsik: Try using Boehm GC in C++. You will love it.
09:03:11 <pikhq> mauke: The places it doesn't work are undefined behavior in C. ;)
09:03:18 <mauke> pikhq: fprintf %p a pointer to a file, fscanf it back
09:03:20 <zygoloid> pikhq: until you want to manage a resource which is not memory
09:03:25 <mauke> pikhq: this is completely defined
09:03:27 <Philippa> monochrom: people doing pattern-matching in, say, Prolog might want to differ some
09:03:35 <pikhq> mauke: Oh, you're kidding.
09:03:37 <pikhq> *Oh right*.
09:03:42 <Philippa> or people doing pattern-matching in the visual recognition sense
09:03:42 <pikhq> That's undefined behavior in C++0x.
09:03:48 <pikhq> To allow for a GC'd implementation.
09:04:04 <pikhq> zygoloid: Yeah, in which case GC doesn't help you.
09:04:04 <Jafet> Pattern-matching normally presupposes flat records.
09:04:10 <Peaker> pikhq, over-conservative can harm you even without UB and I speculate having to assume "everything may be a pointer" harms performance too
09:04:10 <monochrom> of course the context is not visual recognition
09:04:15 <Jafet> Except for those crazies embracing view patterns.
09:04:20 <Wolfspaw> how can i write a function in ghci that needs more than one line? like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26575#a26575
09:04:35 <pikhq> Peaker: Yes, assuming everything may be a pointer can harm performance somewhat.
09:04:37 <mauke> Wolfspaw: no function needs more than one line
09:04:38 <Peaker> monochrom, Pattern matching is also nice syntax sugar for unpacking product types
09:04:40 <benmachine> Wolfspaw: semicolons
09:04:50 <pikhq> Not much on 64-bit, somewhat on 32-bit.
09:04:50 <Wolfspaw> hm, ok, thanks!
09:04:50 <benmachine> Wolfspaw: but usually it's easier to just edit a file
09:04:51 <Philippa> Jafet: yeah, who'da thunk it? Next you'll tell me you can do it with cond and a bunch of predicates
09:04:55 <mauke> Wolfspaw: however, the best solution is to write code in a file
09:04:59 <pikhq> It also limits your collection strategies.
09:04:59 <Jafet> Peaker, Boehm's papers on hacking garbage collection into C may interest you
09:04:59 <Axman6> Wolfspaw: let foo (x:xs) = ...; foo [] = ...
09:05:07 <pikhq> You can't do anything incremental, for one.
09:05:16 <benmachine> Wolfspaw: if you are in ghci with a module loaded from a file, :edit (or :e) allows you to quickly start an editor from ghci
09:05:37 <Jafet> pikhq, Boehm's papers may also correct your impressions
09:05:50 <mauke> pikhq: Boehm GC is also incompatible with malloc/free, isn't it?
09:05:58 <Wolfspaw> ok got it. Thanks for the tips! (i usually write to a file, but i was curious for ghci xD ). Thanks 
09:06:02 <mauke> because the GC doesn't know which chunks are alive
09:06:06 <pikhq> Jafet: I'm well aware that you can't do incremental GC on Boehm GC.
09:06:16 <pikhq> mauke: Not *incompatible*, just very tricky.
09:06:33 <danharaj> well for loose senses of "incompatible"... :p
09:06:39 <danharaj> then again, what isn't tricky in C?
09:06:50 <pikhq> You need to either ensure things on the malloc heap don't reference the Boehm heap at all, or make a point of telling Boehm about the existence of those pointers on the malloc heap.
09:07:01 <Jafet> Er, you don't "do GC".
09:07:10 <Peaker> Jafet, One thing I like about C is lack of GC :)  I think there's too little focus on that kind of niche
09:07:11 <Jafet> That sort of talk suggests fundamental misconceptions.
09:07:21 <pikhq> The latter bit is very, very, very painful.
09:07:26 <mauke> Jafet: do you "perform GC"?
09:07:35 <Jafet> No, I let the GC perform GC.
09:07:38 <danharaj> YES
09:07:40 <danharaj> everyone high five
09:07:44 <danharaj> My copy of Okasaki arrived.
09:07:57 <mauke> wow, your own personal Okasaki
09:08:06 <pikhq> Jafet: It is impossible to implement an incremental conservative garbage collector, as to be incremental, it must be able to rewrite pointers.
09:08:30 <Jafet> danharaj, in addition to deriving optimal lazy data structures, does he bake?
09:08:32 <pikhq> And being conservative, if it rewrote pointers, there's a chance it'd actually rewrite *actual data*.
09:08:34 <Jafet> That would be cool.
09:08:34 <Axman6> damn, i knew they were close, but i didn't think Okasaki would be the world's first cloned person
09:08:36 <Peaker> I am not a GC guru: Can a GC implementation not harm performance of programs that happen to have "large live heaps" for long periods of times?   In Haskell, a common perf. tip is "Make sure you don't have a large heap so you don't most of your time in GC"
09:08:43 <pikhq> Which makes my hair go white.
09:08:53 <danharaj> He was so sick of the destructive semantics of reality that he willed himself into a pure being.
09:09:01 <danharaj> And thus is copied every time he does something.
09:09:05 <kamatsu_> is there any nice way to generate C bindings from C++?
09:09:17 <pikhq> Erm.
09:09:21 <Jafet> pikhq, you can go read the literature, or you can sit around here and continue being delusional. IRC tradition I guess.
09:09:23 <pikhq> Wait, I've been saying incremental all this time?
09:09:29 <pikhq> Good God I meant generational.
09:09:31 <Zao> kamatsu_: That'd be highly dependant on how C-ish your C++ was.
09:09:34 <Philippa> Peaker: not really. It might be possible for a Sufficiently Smart system to take account of regioning and know a chunk's always live...
09:09:42 <pikhq> I'm going to get another cup of coffee.
09:09:48 <Zao> SWIG might be able to do a decent job of it.
09:09:54 <Zao> Or gcc-xml with some glue code.
09:09:56 <kamatsu> SWIG doesn't go to plain old C
09:10:02 <zygoloid> pikhq: i think you mean compacting, actually
09:10:05 <ksf> Axman6, there's more ways to sensibly use concurrency than `par`
09:10:07 <Jafet> Wow, we tricked kamatsu into thinking this was a different channel!
09:10:08 <Philippa> pikhq: actually that's not true, but you'd need to reserve a representation for a "redirect object"
09:10:12 <kamatsu> i mean, optimal is that SWIG went to haskell
09:10:14 <Philippa> re updating pointers
09:10:16 <danharaj> Isn't one of the goals of C1X to make GC more tractiable?
09:10:22 <Peaker> Philippa, That sounds really bad and makes me pessimistic about GC in general :-(
09:10:38 <pikhq> zygoloid: That's another sort of collector that needs to relocate.
09:10:41 <Peaker> I don't think you can just rule out all "large-heap" programs
09:10:42 <Philippa> Peaker: generations're an approximation to that region scheme
09:10:50 <ksf> ...although they might all be in the class "talk to a single-threaded library", "accept socket connections", or similar.
09:11:17 <pikhq> Of course, all generational ones *do* compact, so...
09:11:35 <Jafet> You can express lots of concurrent semantics using delimited continuations.
09:11:46 <ksf> but generally, concurrent objects can provide a great deal of good encapsulation
09:11:50 <Philippa> pikhq: yup, you'd just get a heap full of redirects instead otherwise
09:11:57 <Jafet> It's the schemers that mostly do that, though.
09:12:10 <zygoloid> pikhq: in practice yes, but in principle you could make a conservative generational GC with no pointer rewriting
09:12:10 <Philippa> but if you make pointers all double indirections instead, you can probably sort it out
09:12:15 <ksf> that doesn't scale to multicore, though.
09:12:20 <pikhq> zygoloid: Eeeew.
09:12:35 <Philippa> then you just need a different rep for a physical address for the times you need to pin something to one
09:13:05 <Jafet> You could invent a kernel with 16-byte pages
09:13:17 <zygoloid> Philippa: conservative GC cannot "update pointers" because it can't tell what /is/ a pointer...
09:13:43 <zygoloid> but that double indirection scheme sounds workable :)
09:16:44 <ksf> hmmm neither 'Data.Functor.<$> nor 'Data.Functor.(<$>) work
09:17:05 <Peaker> ksf, (Data.Functor.<$>) ?
09:17:06 <ksf> '(Data.Functor.<$>)
09:17:18 <Peaker> Haskell' proposes Data.Functor.(<$>) syntax
09:17:19 <ksf> SOMEONE GIVE ME LISP SYNTAX!
09:17:32 <zygoloid> Peaker: i think ksf wants a TH name quotation
09:17:34 <Axman6> Haskell' is no more
09:17:44 <ksf> haskell' still is.
09:17:46 <Peaker> Axman6, why?
09:17:49 <ksf> it's just not 2010, anymore.
09:18:01 <zygoloid> haskell' has created haskell2010 and is now working on haskell2011 aiui
09:18:18 <Axman6> i thought the idea of a new language spec was replaced by incremental language updates (hance Haskell 2010)
09:18:19 <danharaj> Why does UHC not use darcs for version control? :(
09:18:38 <aristid> danharaj: why does GHC not yet use GIT as was planned? :D
09:18:52 <danharaj> aristid: because spj's neckbeard hasn't grown in yet
09:19:20 <danharaj> but anyway
09:19:22 <zygoloid> Axman6: haskell prime is the process which produced haskell 2010
09:19:25 <danharaj> UHC uses *svn*
09:19:29 <Axman6> fair enough
09:19:29 <danharaj> which is just inexcusable.
09:19:41 <aristid> danharaj: tru
09:19:49 * Axman6 is wait for Haskellmus'
09:19:53 <Axman6> waiting*
09:20:00 <Axman6> ok, sleep time!
09:20:04 * Axman6 -> sleep
09:20:43 <Jafet> Haskell looks better as a judge dredd type character
09:20:54 <danharaj> Is there a dialect of Scheme that is completely pure? or is it really easy to avoid imperative code in it? I think I should probably learn a LISP dialect to gain hacker cred
09:21:27 <Jafet> A completely pure programming language is generally not very useful
09:21:45 <danharaj> Jafet: pure modulo IO
09:22:17 <aristid> modulo unsafePerformIO et al, haskell IS completely pure
09:22:22 <aristid> IO certainly is pure
09:22:29 <Jafet> Haskell has pure computations and impure actions
09:22:32 <Ke> why would scheme give you more street cred than haskell
09:22:33 <Peaker> Jafet, A completely pure programming language could include "Reactive" and have its "main" be of type (Inputs -> Outputs) where Inputs and Outputs are records containing various behaviors/events
09:22:42 <mauke> Jafet: except the "actions" are just values
09:22:45 <danharaj> Ke: Cred is additive.
09:22:52 <Peaker> Jafet, And it would be useful
09:23:03 <aristid> danharaj: MOAR CRED?
09:23:07 <mauke> so Haskell doesn't really have actions at all
09:23:09 <Jafet> Peaker, yes, you're describing the old haskell that has been discarded for obvious reasons
09:23:14 <danharaj> aristid: The more cred you have, the more potent your trolling :p
09:23:20 <Peaker> Jafet, it's not "old Haskell"
09:23:30 <Peaker> Jafet, I'm not talking about the [Response] -> [Request] stuff
09:23:43 <Peaker> Jafet, But about a more modern formulation (e.g: Reactive)
09:23:44 <mauke> did you mean: [Request] -> [Response]
09:23:56 <danharaj> mauke: he is doing OI
09:23:59 <Peaker> mauke, AFAIK it was [Response] -> [Request], but let me look it up
09:23:59 <mauke> no, I am
09:24:00 <danharaj> :p
09:24:00 <mauke> hmm
09:24:03 <Jafet> Oh, you're talking FRP. Not my specialty
09:24:13 <mauke> Peaker: you are right, of course
09:26:13 <Peaker> "purity" without "side effects" can still describe useful, reactive programs
09:26:33 <Peaker> Of course, the "effects" will have become simply the actual output/results of the program
09:27:27 <delusion42> Is someone willing to help figure out why I have a file handle that is closing prematurely? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26576#a26576 (in the fileCharEnumM function at the bottom of the listing)
09:28:11 <mauke> oh god, iteratees
09:28:15 <delusion42> :P
09:28:21 <delusion42> I never make it past the hIsEOF
09:29:48 <mauke> how does that even type?
09:29:57 <delusion42> ..?
09:29:58 <alexyk> delusion42: cute!  what's this iteratee movement? :)  what's it good at?
09:30:02 <mauke> ah!
09:30:14 <delusion42> alexyk: just learning about them...and a whole lot of other stuff at the same time, apparently :P
09:30:43 <alexyk> delusion42: where are they described?
09:30:45 <Peaker> I like Iteratees the concept. The implementations I looked at seemed unnecessarily hair/unmodular
09:30:50 <delusion42> alexyk: general purpose "iterators" without lazy IO
09:30:51 <mauke> delusion42: looks like you're opening a file, creating an iteratee that uses the handle, then closing the file
09:30:55 <delusion42> Peaker: Yeah, that's my impression too
09:31:02 <delusion42> mauke: hmm...
09:31:03 <mauke> delusion42: and then you're using the iteratee
09:31:06 <aristid> is there a parser  combinator library that works with iteratees? :D
09:31:35 <delusion42> mauke: hrm; the intention was obviously that that doesn't happen :P
09:31:54 <Jafet> They work with String, which is sufficient
09:31:55 <Peaker> I was surprised that it was Oleg's work because it seemed to have a bunch of low-hanging fruits for improving modularity
09:32:09 <monochrom> Some of the types in the current iteratee scares me. :)
09:32:40 <aristid> is the mythical oleg sometimes in this channel?
09:32:44 <Peaker> I think they'd be a lot less scary with better names... s/Iteratee/Consumer,  s/Enum/Producer
09:32:48 <delusion42> mauke: How would I go about fixing it?
09:32:57 <delusion42> mauke: i need to explicitly execute the iteratee inside the bracket body?
09:33:21 <monochrom> No, naming doesn't help. There is some irregularity in the types.
09:33:23 <mauke> delusion42: I don't know, I've never used iteratees
09:33:41 <mauke> aristid: AFAIK no
09:33:43 <delusion42> mauke: hrm, ok.
09:33:51 <Peaker> monochrom, What irregularity? Why do you think suggestive names wouldn't help?
09:34:41 <Peaker> delusion42, surely there are examples of file reading enumerators?
09:34:46 <delusion42> Peaker: it took me a lot of slogging through examples before i was clear that iteratee:consumer and enum:producer ;P
09:34:52 <delusion42> Peaker: Yeah, that's what this is based on
09:35:09 <Peaker> Lots of Haskell researchers are really bad at naming
09:35:12 <delusion42> the iteratee article in the monad reader issue 16 has a great example, and this is nearly copied verbatim
09:35:41 <monochrom> I have swapped out the details of my memory. The type definitions especially the type synonyms are lengthy and assymmetric. I never care about names, that one is for sure.
09:37:24 <Peaker> monochrom, I know it would save a bunch of people a lot of trouble if Producer/Consumer were used -- as it saves re-reading definitions after figuring out what stuff is all about
09:37:42 <Peaker> monochrom, The direction of data flow is something that's harder to decipher from the types than from the names
09:38:21 * edwardk waves hello.
09:38:41 <delusion42> Peaker: And then they introduce "enumeratees" :P
09:38:42 <Peaker> "fileDriver" seems really ugly -- a function that is both an enumerator-for-files and an executor of the iteratee?  :(
09:38:48 <Peaker> delusion42, what's that?
09:38:58 <delusion42> Peaker: nested stream enumerators
09:40:32 * Peaker procrastinates before the next large milestone in his project
09:41:57 <delusion42> Peaker: sorry, got disco'd. that style is how i've seen it in this tutorial
09:42:09 <delusion42> Peaker: it's just feeding one stream element at a time to the iteratee
09:43:29 <delusion42> but yeah, i'm really not seeing why the file handle is going away :(
09:44:47 <ksf> Peaker, you should see mine that does fd enumerating _and_ splicing.
09:45:04 <Peaker> Why not have a Handle enumeration
09:45:12 <Peaker> and then hook up that with the consumption
09:45:16 <Peaker> and then "run" that?
09:45:24 <delusion42> Peaker: hndlCharEnumM is the enumeator...it generates the stream...
09:45:47 <delusion42> that's how this is working: execM =<< fileCharEnumM "foo.txt" lengthM
09:45:51 <ksf> Peaker, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26577#a26577
09:45:53 <delusion42> where lengthM is the consuming iteratee
09:45:54 <orlandu63> :t ord
09:45:55 <lambdabot> Char -> Int
09:46:10 <delusion42> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26576#a26576 -- any ideas why the filehandle would go away?
09:46:13 <ksf> Peaker, whether you enumerate a Fd or Handle doesn't matter
09:46:44 <Peaker> ksf, I never said it did
09:46:47 <delusion42> ksf: wow, that looks pretty insane
09:46:51 <jp_> hi
09:47:16 <Peaker> IterateeW8?
09:47:25 <delusion42> word 8?
09:47:51 <ksf> delusion42, uhm, no idea
09:47:52 <Peaker> Why have a type synonym like that? Maybe W8=Word8, but why that?
09:48:09 <delusion42> ksf: dang. it seems sane to me =/
09:48:11 <ksf> but I'd advise to switch to Fds to eliminate a source of errors
09:48:14 <turiya> hi
09:48:18 <Peaker> I like "loop it = finished >>= cap (return it) (wait >> body it)" sounds like gangsta
09:48:24 <Peaker> Fds?
09:48:31 <delusion42> Peaker: file descriptors
09:48:35 <mauke> wait, didn't I already tell you what the problem is?
09:48:43 <Peaker> ksf, Why would switching to fd's eliminate a source of errors?
09:49:00 <ksf> because Handles are way too smart.
09:49:04 <delusion42> mauke: sorta...but it was working with a slightly different iteratee design :P
09:49:07 <ksf> noone really knows what they're doing.
09:49:24 <Peaker> ksf, heh?
09:49:32 <delusion42> mauke: and i'm trying to at least figure out something to try, that's all.
09:49:39 <Peaker> ksf, example?
09:49:54 <ksf> my paranoia needs no examples
09:50:32 <ksf> Peaker, type IterateeW8 m a = Iteratee WrappedByteString Word8 m a
09:50:34 <turiya> why does "(>>) (putStrLn "hello") (putStrLn "world")" output helloworld and not worldhello? what guarantess that the arguments are executed in this order?
09:50:46 <Peaker> ksf, What's WrappedByteString?
09:50:56 <ksf> a wrapped bytestring.
09:51:02 <mauke> turiya: (>>) does
09:51:05 <Peaker> turiya, That's what (>>) does, it chains effects left-to-right
09:51:06 <delusion42> turiya: that's equivalent to putStrLn "hello" >> putStrLn "world" ; that's how the operator works
09:51:07 <ksf> ...the container type for the W8s
09:51:07 <monochrom> IO guarantees order until you use unsafeInterleaveIO
09:51:12 <dafis> turiya: It's a prefix application of (>>)
09:52:13 <turiya> but there seems to be no rule anywhere which says that >> operates in such a way.. >> is just a function in the monad class
09:52:24 <billyrong> hi, I have "data MyType a a = MyType a a" and ghc complains "Conflicting definitions for `a'" - how do I define type with two members of same type? Thanks.
09:52:30 <dafis> > (>> putStrLn "hello") (putSt "world")
09:52:31 <lambdabot>   Not in scope: `putSt'
09:52:36 <monochrom> Some other monads have their >> not guarantee order. There is no rule.
09:52:37 <dafis> > (>> putStrLn "hello") (putStr "world")
09:52:39 <lambdabot>   <IO ()>
09:52:41 <mauke> turiya: there is no rule what any function does
09:52:47 <mauke> turiya: what's so different about (>>)?
09:52:51 <ksf> billyrong, data Foo a = Foo a a
09:53:35 <turiya> mauke: why is the "hello" action executed first?
09:53:48 <dafis> :t (>>)
09:53:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:53:53 <turiya> why not the other way around
09:53:58 <mauke> turiya: that doesn't answer my question
09:54:00 <mauke> turiya: what's so different about (>>)?
09:54:01 <ksf> turiya, behind the scenes, monads can thread data dependencies.
09:54:08 <dafis> turiya: the type forces it
09:54:14 <orlandu63> @src zip
09:54:15 <Peaker> monochrom, Which monads don't guarantee order in (>>) ?
09:54:15 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:54:15 <lambdabot> zip _      _      = []
09:54:17 <ksf> roughly speaking, the second putStrLn depends on the world the frist one returns.
09:54:18 <mauke> dafis: no, it doesn't
09:54:24 <orlandu63> i wonder why zip isn't defined in terms of zipWith
09:54:28 <dafis> mauke: yes, brainfart
09:54:38 <monochrom> Control.Monad.State.Lazy. I have an example on moonpatio but it's down.
09:54:39 <mauke> ksf: there is no world
09:54:47 <Jafet> Is there any Monad where a>>b isn't a>>=(\x->b)?
09:54:54 <turiya> mauke: the order in which the arguments are evaluated is non-deterministic
09:54:58 <conal> turiya: IO has its own operational semantics.  only a tiny part of it is determined by the Monad typeclass.
09:55:02 <ksf> @src (>>)
09:55:02 <mauke> turiya: and irrelevant
09:55:02 <lambdabot> m >> k      = m >>= \_ -> k
09:55:05 <ksf> no.
09:55:18 <zygoloid> denotationally, that would be a broken instance. operationally, there almost surely are.
09:55:19 <turiya> it matters here
09:55:19 <mauke> turiya: evaluating putStrLn "hello" has no side effects
09:55:23 <mauke> turiya: no
09:55:26 <billyrong> ksf: thank you, and I guess that means the left side of = only has unique data types, and right side has type members?
09:55:42 <turiya> otherwise we would have worldhello..no?
09:55:44 <zygoloid> Jafet: (that was to you btw)
09:55:50 <mauke> turiya: what does length [putStrLn "a", putStrLn "b", putStrLn "c"] do?
09:55:54 <ksf> the left-side hand lists the bindings, on the rhs you mention them.
09:56:04 <ksf> ...you can't say f x x = x * x, either.
09:56:05 <ksf> same reason.
09:56:12 <Jafet> zygoloid, yeah
09:56:16 <ksf> (which x to multiply?)
09:56:23 * Jafet contemplates threading @instances-importing through @check
09:56:24 <Peaker> monochrom, The order of the state effects is ignored?
09:56:29 <turiya> i might evaluate to 3
09:56:39 <turiya> it*
09:56:42 <mauke> turiya: what does it print?
09:56:58 <turiya> a\nb\nc
09:57:01 <mauke> turiya: no
09:57:05 <mauke> it prints nothing
09:57:08 <ksf> it doesn't print a thing
09:57:11 <monochrom> The order of do-statements is ignored.
09:57:11 <mauke> it does evaluate to 3, though
09:57:43 <turiya> why does it not print anything?
09:57:50 <mauke> turiya: may I interest you in http://mauke.ath.cx/stuff/haskell/how-to-io.html ?
09:57:58 <monochrom> > length [putStrLn "hi"]
09:57:59 <lambdabot>   1
09:58:05 <ksf> turiya, because those actions are never executed.
09:58:17 <ksf> you can pass them around like any other value.
09:58:22 <Jafet> This calls for a monad tutorial
09:58:33 <mauke> Jafet: wrong
09:58:46 <mauke> this calls for an explanation of IO
09:58:51 <turiya> ok..
09:58:53 <monochrom> yeah, IO-specific tutorial
09:58:54 <mauke> monads are completely besides the point
09:59:00 <conal> mauke: amen!
09:59:08 <Peaker> turiya, Values of type (IO a) are "recipes" for execution of a side-effecting program to generate a value "a".  Evaluating and generating these recipes doesn't execute them, you can pass them around, put them in lists.. unless you bind them to main itself, they will not be executed
09:59:16 <Peaker> turiya, what other programming languages do you know?
09:59:25 <Jafet> mauke your humour transponder is misaligned
09:59:26 <mreh> yeah, what, not how
10:00:02 <Peaker> turiya, If you know Python, for example, it's a bit like having:  def f(): print "Hello world"    and then passing "f" around, getting it as a result, etc, never calling f().
10:00:03 <mauke> Jafet: the hurt is too deep!
10:00:23 <turiya> Peaker: no i dont know python.. C is what i know
10:00:31 <mauke> Jafet: also, your spellerator doesn't know how to "humor"
10:00:50 <mauke> turiya: do you know system() from stdlib.h?
10:01:00 <conal> it's been a terrible mistake to tie the explanation of haskell IO to the notion of Monad.  Monad has nothing to do with how IO works in haskell.  only to how a tiny piece of the IO interface is packaged.
10:01:07 <turiya> mauke: no
10:01:08 <Jafet> I'm just a clockwork orang.
10:01:17 <Peaker> turiya, Well, if you pass around something that identifies some C function that has effects (e.g: A function pointer to it), the effect does not get executed. Similarly, IO actions only specify what the effect *should* be.  To execute the effect, unlike C, you don't "call" the action/recipe, you bind it to main
10:01:28 <mauke> turiya: ok, never mind
10:01:53 <mauke> I'd recommend you ignore this channel for a while, read my page, then come back with questions. YMMV.
10:02:29 <turiya> my original question was.. why is "hello" printed b4 "world" .. i still dont understand that..
10:03:16 <conal> turiya: the answer to your original question is in the operational semantics of IO.  you can find it described in a paper called "The Awkward Squad".
10:03:38 <conal> turiya: and that answer has nothing to do with "monad"
10:03:43 <billyrong> ksf: thank you for the help!
10:03:48 <mauke> turiya: did you read the How To IO stuff?
10:03:59 <conal> turiya: in another monad, "world" could be printed first.
10:04:10 <mauke> there you go, talking about monads
10:04:11 <mauke> bleh
10:04:33 <monochrom> Peaker: here is my example
10:04:34 <monochrom> > let p = do {p; s<-get; put (():s)} in take 10 (execState p undefined)
10:04:35 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
10:05:06 <monochrom> where execState happens to be from Control.Monad.State.Lazy in lambdabot
10:05:12 <endojelly> just a quick little question, is it possible to create a monad that applies a sequence of computations, maybe with a state, in reverse order? would that also still follow monad laws?
10:05:40 <conal> endojelly: yes.  wadler has an example.  see "reverse state monad"
10:05:48 <endojelly> conal, thanks!
10:05:53 <endojelly> was just curious
10:05:57 <conal> endojelly: :)
10:06:02 <ksf> you can do that with applicatives, too.
10:06:13 <mauke> see http://mauke.ath.cx/stuff/haskell/posi.hs - no idea if that follows the laws, though
10:06:43 <monochrom> haha positronic
10:06:54 <endojelly> ksf, that would be the more general approach, functions applied in sequence?
10:07:07 <ksf> yep
10:07:23 <endojelly> so Applicative is really a generalization of function application?
10:07:28 <Jafet> Heh, someone implemented whatever?
10:07:35 <ksf> at least that's how I understand it.
10:07:40 <endojelly> and I suppose there's an Identity Applicative monad which... well... applies? 8)
10:07:56 <endojelly> -monad
10:07:59 <endojelly> not a monad
10:08:04 <endojelly> sorry, I meant instance
10:08:17 <ksf> no you write it for every datatype
10:08:41 <turiya> mauke: i just browsed through your page.. unfortunately it is not clear why helloworld is printed
10:08:46 <ksf> in the list case, eg, [a -> b] -> [a] -> [b] applies all funtions in the first list to the elements in the second list
10:09:10 <ksf> ...the implementation that does that can of course choose in which order [b] will be.
10:09:12 <mauke> turiya: did you read it?
10:09:14 <endojelly> in the Maybe case it maybe applies a function to maybe a value? 8)
10:09:16 <mauke> turiya: did you do the exercises?
10:09:45 <turiya> i know the way things are but i dont know why they are.. :)
10:09:51 <ksf> turiya, oh, that why.
10:10:27 <conal> turiya: i don't think your answer is in mauke's "How to IO".  but it is in "The Awkward Squad".
10:10:37 <turiya> i do understand a little about what happens when >> and >>= are used but not why..
10:10:39 <ksf> there's a thousand ways to see it, one might be the one that ghc uses, but imagining >> constructing a data type that is then interpreted by the run-time system is an easy explanation.
10:10:59 <ksf> ghc actually compiles that structure down to hard code, as far as possible.
10:11:09 <turiya> conal: i will look it up
10:11:17 <mauke> turiya: because someone designed the language to work like that?
10:11:32 <ksf> ...at which point you'd have to look at the c lib, then kernel and graphic card to figure out how stuff is printed ;)
10:11:48 <turiya> mauke: ok.. so there is a rule in this language that >> has to work like that?
10:11:58 <ksf> for the IO case, yes.
10:12:06 <delusion42> I thought one of the benefits of iteratees is that one didn't have to worry about file handles disappearing from underneath you.  Is that naive?
10:12:13 <ksf> that is, IO has to behave in a certain way that as a result makes >> behave like that.
10:12:21 <mauke> turiya: not "like that"
10:12:37 <ksf> delusion42, it's more like not having to worry about running out of fds due to laziness.
10:12:59 <mauke> turiya: (>>) takes two IO actions x, y and returns an IO action that (when run) runs x and then runs y
10:13:12 <delusion42> ksf: ah, i see. i don't know how i'm supposed to use files with iteratees, then. 
10:13:16 <mauke> (>>) is a constructor
10:13:25 <delusion42> ksf: or at least not with this iteratee design from the tutorial
10:13:27 <ksf> enumerators use them.
10:13:47 <ksf> you open the file, feed the iteratee until eof or the iteratee is finished, then close the file.
10:13:55 <conal> turiya: yes, check out the Awkward paper. i don't think you'll find any functional/denotative-style answer there or anywhere, because unlike the rest of Haskell, IO is not denotative.
10:14:04 <delusion42> yeah, i have a handle enumerator that uses a handle. that works. but i have a file enumerator that brackets the invocation of the handle enumerator...and that's where things are disappearing
10:14:07 <ksf> you don't open a file in an iteratee, you call another enumerator.
10:14:32 <delusion42> ksf: right, i have a file enumerator, which calls a handle enumerator
10:14:45 <delusion42> and the iteratee is supplied outside both of thus by an 'executor' function
10:14:51 <turiya> mauke: ok..that clears my doubt.. so >> is not a "normal" function..
10:14:52 <conal> turiya: and "rest of haskell" is an overstatement.  there are a few other non-denotative pockets of haskell.
10:14:55 <ksf> but those are one enumerator, aren't they?
10:15:10 <ksf> after all, there's only one thing they enumerate
10:15:12 <delusion42> ksf: well, one enumerator, yes -- but one is implemented in terms of the other
10:15:17 <mauke> turiya: yes, it is
10:15:23 <ksf> that's what I meant.
10:15:25 <delusion42> ksf: right. but between the file enumerator and the handle enumerator, the handle is getting closed.
10:15:33 <delusion42> (I can't check EOF, for example)
10:16:15 <mauke> turiya: foo a b = [a, b]  -- foo takes two values x, y and returns a list whose first element is x and whose second element is y
10:16:18 <delusion42> something obviously isn't forcing the evaluation of the enumerator the right way or something 
10:16:21 <mauke> turiya: (>>) isn't more magic than that
10:16:28 <ksf> :t bracket
10:16:29 <lambdabot> Not in scope: `bracket'
10:16:34 <ksf> @hoogle bracket
10:16:34 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:16:34 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:16:34 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:16:52 <turiya> mauke: foo (2+3) (4+5)
10:16:53 <ksf> isn't the third argument the finally clause?
10:17:04 <ksf> that is, shouldn't hClose be the third one?
10:17:05 <delusion42> no, the third is the 'body'
10:17:19 <turiya> which of the arguments is evaluated first?
10:17:22 <ksf> oh yes, the c.
10:17:25 <mauke> turiya: you don't know which one will be computed first, but the first element of the list will still be 5
10:17:28 <delusion42> pre/post/body
10:17:30 <turiya> yes
10:17:40 <turiya> but when the same reason is applied to IO actions
10:17:48 <mauke> turiya: foo (putStrLn "a") (putStrLn "b")
10:17:50 <turiya> reasoning*
10:17:53 <mauke> yes?
10:18:01 <delusion42> so i have: \enum -> bracket (openFile fp ReadMode) (hClose) (`hndlCharEnumM` enum) basically
10:18:17 <turiya> if we dont know which argument is executed first
10:18:25 <mauke> turiya: not executed. evaluated.
10:18:31 <mauke> there is a difference
10:18:35 <turiya> yes..
10:18:36 <delusion42> i thought that'd be a reasonable way to make the file enumerator use the handle enumerator.
10:18:41 <turiya> evaluated first
10:18:51 <turiya> then we might not get what we wanted
10:18:54 <mauke> turiya: evaluating putStrLn "a" doesn't print anything
10:19:10 <ksf> delusion42, yes, there must be something else wrong there.
10:19:21 <turiya> yes.. and that was where my misunderstanding lied
10:19:23 <delusion42> ksf: hrm, ok.
10:19:34 <turiya> i thought >> was a normal function..
10:19:42 <ksf> ...with exceptinos, /me thinks.
10:19:59 <danharaj> wait, what is special about >> in IO?
10:20:02 <turiya> because obviously it does executes the actions
10:20:21 <mauke> turiya: >> does not execute anything
10:20:24 <mauke> and it is a normal function
10:20:30 <ksf> @src (>>)
10:20:30 <lambdabot> m >> k      = m >>= \_ -> k
10:21:37 <turiya> mauke: whats the difference between foo (putStr "a") (putStr "b") and (>>) (putStr "a") (putStr "b")?
10:21:53 <dafis> turiya: conceptually, nothing
10:21:54 <mauke> turiya: none, really
10:22:00 <mauke> well, they return different values
10:22:05 <monochrom> the difference between foo and >>
10:22:08 <danharaj> what is foo?
10:22:13 <monochrom> for example maybe foo is <<
10:22:16 <mauke> danharaj: \x y -> [x,y]
10:22:17 <dafis> turiya: just, at the ghci prompt, IO-actions are actually executed
10:23:13 <turiya> say i write a1 = foo (putStr "a") (putStr "b"), a2 = (>>) (putStr "a") (putStr "b") in a file, load it and then type a1 at prompt
10:23:39 <mauke> turiya: then you'll probably get an error mentioning Show (IO a)
10:23:44 <turiya> ghci should print [(),()]
10:23:47 <mauke> no
10:23:52 <dafis> turiya: then you'll get "cannot find Show instance for [IO ()]"
10:23:56 <mauke> turiya: putStrLn "a" is not ()
10:24:06 <conal> turiya: there are several papers that explain the imperative functional programming clearly & rigorously.  including http://citeseer.ist.psu.edu/peytonjones93imperative.html 
10:24:29 <turiya> ok..
10:24:34 <turiya> ghci cant show it..
10:24:48 <turiya> but would the list be [IO (), IO ()]?
10:24:51 <mauke> conal: that sounds pretty steep for someone who's just learning how to program
10:24:53 <conal> turiya: you're probably making a very basic false assumption, which isn't yet coming to light.  if you read the original papers, i think you'll get your epiphany.
10:25:05 <mauke> turiya: sort of
10:25:09 <conal> mauke: oh!  is he?
10:25:09 <danharaj> RTFJA
10:25:19 <turiya> when a2 is entered at the prompt
10:25:30 <turiya> the result would be helloworld
10:25:31 <mauke> conal: they said they only know bits of C
10:25:40 <writer> hi everyone
10:25:48 <dafis> hi writer
10:25:55 <writer> hello dafis
10:25:57 <mauke> turiya: that's because the interpreter automatically executes actions
10:26:05 <conal> mauke: ah.  hm.
10:26:27 <mauke> turiya: try 'length a1', 'a1 !! 0', and 'a1 !! 1'
10:26:30 <conal> mauke: having little programming experience might actually help here.
10:26:40 <conal> turiya: how's your math background?
10:26:50 <turiya> conal: not bad
10:27:03 <turiya> but i have trouble understanding languages
10:27:05 <mauke> how old are you?
10:27:10 <turiya> 27
10:27:17 <mauke> ok
10:27:41 <mauke> do you know what a group or a monoid is?
10:27:50 <turiya> not a monoid
10:28:00 <writer> Is there any function in haskell base library which allow me to distribute an argument, like (x ++ y) 20, where x x1 = show $ x1 * 20, y y1 = show $ y1 * 30, and result should be: "400600" 
10:28:07 <conal> turiya: the more you've used mainstream languages, the more you'll have to unlearn with haskell.  math is a great background.  and i really like your "why" questions and your dissatisfaction with answers being tossed around.
10:28:08 <mauke> good, monoids are actually simpler
10:28:35 <mauke> writer: liftM2
10:28:38 <turiya> conal: i get frustrated though..
10:29:01 <turiya> too much effort and too little gain
10:29:16 <delusion42> turiya: keep at it, it'll come. haskell is pretty brainbending =/
10:29:29 <mauke> only if your brain is already shaped
10:29:32 <monochrom> @quote monochrom unlearning
10:29:33 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
10:29:36 <delusion42> well, yeah. :P
10:29:48 <conal> turiya: yep.  maybe you've jumped in at the deep end.  how about picking either imperative or functional, rather than both at once?
10:29:54 <aavogt> > (show ++ (show . (*2)) 100
10:29:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:30:03 <aavogt> > (show ++ (show . (*2))) 100
10:30:04 <lambdabot>   "100200"
10:30:29 <conal> turiya: ie learn C/Java/C#/etc (imperative) or  haskell-without-IO (enotative/functional)
10:30:33 <aavogt> @src (++)
10:30:34 <lambdabot> []     ++ ys = ys
10:30:34 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:30:34 <lambdabot> -- OR
10:30:34 <lambdabot> xs ++ ys = foldr (:) ys xs
10:30:43 <mauke> :t (++)
10:30:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:30:48 <conal> turiya: *(denotative/functional)
10:30:50 <mauke> why hello, mappend
10:30:57 <turiya> conal: i understand haskell w/o IO a bit ..
10:30:59 <mauke> .oO( emotative )
10:31:00 <aavogt> there's no N.B. there
10:31:03 <BarryCarter> How do I get pi to 50 digits?
10:31:11 <mauke> > pi :: CReal
10:31:12 <lambdabot>   3.1415926535897932384626433832795028841972
10:31:26 <aavogt> > pi 
10:31:27 <lambdabot>   3.141592653589793
10:31:34 <writer> mauke: you mean, like this:  liftM2 (\x1 y1 -> (x x1) ++ (y y1)) (Just 20) (Just 20)
10:31:44 <mauke> wat
10:32:05 <mauke> writer: liftM2 (++) x y 20
10:32:18 <conal> turiya: no one understands IO with the kind of clarity that we understand the other pieces.
10:32:22 <BarryCarter> mauke: How did it know to stop at 50 digits?
10:32:40 <benmachine> BarryCarter: default Show instance
10:32:41 <mauke> > showCReal 50 pi
10:32:42 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
10:32:52 <benmachine> ah, it didn't
10:32:57 <BarryCarter> mauke: benmachine: Nice!
10:32:58 <conal> turiya: oh!  since you want clear answers (iiuc) and you have a math background, check out denotational semantics, and start from there.
10:33:25 <BarryCarter> OK, how do I sum the list 1/(n^2) for n=1..Infinity?
10:33:50 <mauke> do it in your head
10:33:54 <BarryCarter> LOL :)
10:34:05 <danharaj> I don't think there is a library that calculates limits.
10:34:14 <turiya> conal: ok, the awkward squad u mean?
10:34:14 <BarryCarter> Rats.
10:34:20 <conal> BarryCarter: that'd be cool.  i doubt we have a library up for such infinite sums.  though i bet it's possible.
10:34:29 <benmachine> BarryCarter: I know how to prove it is convergent (in uhm several different ways)
10:34:36 <aavogt> stuck on CReal?
10:34:38 <benmachine> maybe the integral test comes in handy
10:34:42 <aavogt> (to be even slower)
10:34:46 <BarryCarter> conal: benmachine: I know the answer, I was just using it as a test for Haskell.
10:34:51 <aavogt> benmachine: but that doesn't get you the answer
10:34:59 <BarryCarter> It's Pi*Pi/6
10:35:27 <conal> turiya: no -- the awkward squad paper completely punts on a denotative/functional answer to the question of how to understand IO 
10:35:30 <danharaj> The only rigorous proof I know is via fourier analysis.
10:35:52 <danharaj> and that's an unrealistic test for a general purpose language, maybe for Mathematica :p
10:36:00 <BarryCarter> danharaj: That's what I was testing it against :)
10:36:04 <mauke> > sum $ map (\n -> 1 / (n ^ 2)) [1 .. ]
10:36:08 <conal> turiya: that paper does, however, hint at why it's unlikely there is any such answer.
10:36:10 <lambdabot>   mueval: ExitFailure 1
10:36:12 <aavogt> danharaj: proof of convergence, or what it converges to?
10:36:13 <danharaj> That's like testing a jet engine against a submarine.
10:36:14 <wli> wikipedia has a bunch of proofs in the Basel problem entry
10:36:28 <mauke> > sum $ map (\n -> 1 / (n ^ 2)) [1 ..] :: Expr
10:36:31 <danharaj> aavogt: what it converges to
10:36:34 <lambdabot>   mueval-core: Time limit exceeded
10:36:39 <BarryCarter> Someone suggested Haskell as being better than Mathematica...
10:36:43 <BarryCarter> Pi^2/6
10:36:52 <BarryCarter> It's a well-known sum.
10:37:09 <danharaj> What was the context?
10:37:11 <writer> thanks mauke 
10:37:13 <ksf> but it's also a programming language, not a mathematical swiss knife.
10:37:32 <BarryCarter> I wanted Haskell to tell me Sum[1/n^2,{n,1,Infinity}] was Pi^2/6 as a test.
10:37:47 <BarryCarter> So "better" is qualified here.
10:37:49 <ksf> and it's turing complete so the type system might not be powerful enough to express what you want.
10:37:58 <mauke> BarryCarter: for what kind of numbers?
10:37:58 <conal> BarryCarter: provability depends on the type of n.  i expect there is a choice that allows computing a broad range of such sums exactly
10:37:59 <danharaj> Mathematica probably only has that sum memorized.
10:38:01 <ksf> but I bet you could write a cool proof for that in agda
10:38:04 <Codex_> > fix (\n -> 1/(n^2))
10:38:08 <lambdabot>   mueval-core: Time limit exceeded
10:38:28 <BarryCarter> mauke: conal: n = natural number
10:38:35 <mauke> BarryCarter: natural numbers can't 1/
10:38:41 <conal> BarryCarter: wouldn't be type-correct.
10:39:02 <BarryCarter> I meant 1/(n^2) sorry
10:39:20 <conal> BarryCarter: and the function wouldn't be inspectable.
10:39:32 <danharaj> edwardk is writing a library that does some pretty cool numerical methods
10:39:37 <BarryCarter> How does Turing complete limit a language's power?
10:39:37 <conal> BarryCarter: (for that type)
10:39:48 <ksf> it limits the analysis you can do on it.
10:39:50 <BarryCarter> conal: OK, I'm not sure what that means?
10:39:55 <ksf> ...because it's just too powerful.
10:39:57 <edwardk> danharaj: several ;)
10:40:06 <danharaj> edwardk: Fair enough :p
10:40:15 <BarryCarter> ksf: So you're saying it might be unknowable whether Haskell could solve sums like that?
10:40:31 <edwardk> danharaj: referring to the ad lib?
10:40:33 <ksf> it's surely able to implement a solver that can.
10:40:50 <danharaj> edwardk: That's the one that comes to mind, but I also remember something about Taylor models as a separate library?
10:41:09 <danharaj> You can implement Mathematica in Haskell.
10:41:12 <BarryCarter> You know, if you guys stole Mathematica's .m files, you'd really have something :)
10:41:16 <ksf> what's questionable is whether you can embed the syntax for the expressions to be solved in haskell, though.
10:41:20 <BarryCarter> danharaj: But no one's done it?
10:41:39 <aavogt> ksf: quasi-quotes?
10:41:50 <ksf> yes.
10:41:50 <BarryCarter> ksf: you're saying there are things expressible in Mathematica that aren't expressible in Haskell?
10:41:54 <danharaj> BarryCarter: Because it's pointelss. Use the right tool for the right job. Haskell and Mathematica have nothing to do with each other. Mathematica is a domain specific tool. Haskell is a general purpose programming language.
10:42:02 <aavogt> or does mathematica have forms that would confuse the parser for even those?
10:42:03 <ksf> but that's a can of worms. the more I dig into it the more spout out.
10:42:22 <BarryCarter> danharaj: So whoever told me to use Haskell instead of Mathematica was wrong?
10:42:24 <conal> BarryCarter: first, you could rewrite your sums in point-free form.  next, pick a type whose *meaning* is functions but is analyzable.
10:42:34 <ksf> mathematica is a lisp, afaiu
10:42:34 <mauke> BarryCarter: use it for what?
10:42:34 <danharaj> BarryCarter: I have no idea why they would say that.
10:42:47 <BarryCarter> To solve math problems.
10:42:48 <ksf> so it's better at snatching stuff randomly out of your code and analysing it.
10:42:56 <ksf> haskell can do that too, though.
10:43:00 <edwardk> barrycarter you can of course do summations by hand and watch them converge:
10:43:04 <edwardk> > scanl (+) 0 $ iterate (/2) 1
10:43:05 <lambdabot>   [0.0,1.0,1.5,1.75,1.875,1.9375,1.96875,1.984375,1.9921875,1.99609375,1.9980...
10:43:23 <BarryCarter> But it doesn't know that 1/n^2 sum is Pi^2/6 -- that's sort of bad in my book.
10:43:37 <mauke> BarryCarter: but it isn't the same
10:43:38 <conal> BarryCarter: and make sure all your type-class instances behave according to the principle of type-class morphisms.  (I have several blog posts & some papers on TCMs.)
10:43:44 <BarryCarter> I'm not always necessarily looking for a numeric solution.
10:44:09 <danharaj> That litmus test is useless. If you're doing numerical methods, then it is of little value. If you're evaluating limits, then you are doing proofs and Mathematica is scarcely anything more than a reference.
10:44:27 <danharaj> A textbook can tell me the value of that series, Mathematica doesn't actually derive it. It just looks it up.
10:44:30 <BarryCarter> danharaj: I can't disagree with that.
10:44:31 <Veinor> I wouldn't call Mathematica a lisp
10:44:33 <edwardk> BarryCarter: sadly we don't have much in the way of solvers for known series/sequences
10:44:48 <ksf> Veinor, lispy?
10:44:56 <Veinor> danharaj: I think mathematica applies transformations to it until it reaches a constant
10:44:57 <ksf> I haven't really worked with it.
10:44:58 <BarryCarter> danharaj: Well, sort of. You can make the series more complex and Mathematica still figures it out.
10:45:14 <ksf> ...used nothing I could'nt have implemented myself, that is.
10:45:18 <edwardk> BarryCarter: well we have some of that
10:45:20 <BarryCarter> Veinor: or until no further transformations would change it.
10:45:21 <edwardk> @oeis [5,7,11,13,17]
10:45:21 <lambdabot>  Sequence not found.
10:45:30 <edwardk> @oeis [2,4,8,16,32]
10:45:30 <lambdabot>  Sequence not found.
10:45:35 <edwardk> erm
10:45:39 <edwardk> what is with oeis today?
10:45:44 <danharaj> @oeis 5, 7, 11, 13, 17
10:45:45 <lambdabot>  The prime numbers.
10:45:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:45:47 <edwardk> ah
10:45:48 <Veinor> ksf: The I dunno if I'd call it lispy
10:45:53 <Veinor> -The
10:46:08 * ksf vaguely remembers its lispyness being mentioned somewhere
10:46:19 <ksf> as in largely untyped, quasiquoting.
10:46:40 <Veinor> well, it's untyped
10:46:51 <Veinor> what's quasiquoting?
10:47:15 <ksf> lifting syntax into the language as AST, then injecting it again.
10:47:20 <Veinor> @_@
10:47:26 <BarryCarter> OK, just for fun, let's solve a "simple" problem. If you choose 23 people at random, the likelyhood that 2 will have identical birthdays exceeds 50%. First, I want a function that takes n (like 365) and returns m (like 23), the value at which the probability of a match exceeds 50%.
10:48:20 <Zao> Just for homework? :D
10:48:24 <BarryCarter> Just for fun :)
10:48:41 <BarryCarter> Next, we'll find that as n -> Infinity, m -> c*Sqrt[n] -- I want to find 'c'.
10:48:45 <ksf> > let f x = if x == 365 then 23 else error "Heck I don't know that" in f 2
10:48:46 <lambdabot>   *Exception: Heck I don't know that
10:49:03 <Veinor> > let f x = sqrt $ 2 * x * log .5 in f 365
10:49:04 <lambdabot>   No instance for (GHC.Float.Floating (f a))
10:49:05 <lambdabot>    arising from a use of `e_1253...
10:49:14 <Veinor> > let f x = sqrt $ 2 * x * (log .5) in f 365
10:49:15 <lambdabot>   No instance for (GHC.Float.Floating (f a))
10:49:15 <lambdabot>    arising from a use of `e_1253...
10:49:18 <Veinor> wha
10:49:20 <aavogt> > .5
10:49:21 <lambdabot>   <no location info>: parse error on input `.'
10:49:25 <Veinor> ah
10:49:29 <BarryCarter> 0.5?
10:49:38 <Veinor> > let f x = sqrt $ 2 * x * log 2 in f 365
10:49:39 <lambdabot>   22.49438689559598
10:49:48 <Veinor> close enough!
10:49:51 <aavogt> > (+1) .5 5 :: Int
10:49:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:49:53 <lambdabot>         against inferred type ...
10:50:03 <aavogt> > ((+1) .5) 5 :: Int
10:50:06 <lambdabot>   6
10:50:09 <BarryCarter> Veinor: you're sort of cheating by knowing the answer ahead of time?
10:50:11 <edwardk> barrycarter: take ((n-1)/n) ^ (p*(p+1)/2) - 0.5 and solve for zero p.
10:50:28 <edwardk> er solve for zero by adjusting p
10:50:36 <BarryCarter> edwardk: Can you create a Haskell function that does that?
10:51:06 * ksf thinks zygohistomorphic prepromorphisms could help, there.
10:51:15 <Veinor> yeah, numericlly solving equations isn't that hard
10:51:37 <BarryCarter> (I think that forumula's correct) -- it's also: n*(n-1)*(n-2)*...(n-p)/n! == .5 [find p]
10:51:58 <Veinor> don't you mean /n^p
10:52:14 <BarryCarter> Veinor: yes, my bad. 
10:52:30 <BarryCarter> > gamma 5
10:52:30 <lambdabot>   Not in scope: `gamma'
10:52:39 <BarryCarter> Does Haskell know the gamma function?
10:52:44 * Dashkal discovers Text.Parsec.Language
10:52:49 <Dashkal> pretty...
10:53:07 <mauke> BarryCarter: depends on your definition of "Haskell"
10:53:09 <danharaj> BarryCarter what programming languages are you familiar with?
10:53:24 <BarryCarter> danharaj: Java, C, Ruby, Perl, PHP, Mathematica, maybe a few others.
10:53:45 <BarryCarter> mauke: So there's a library that does it, but it's not in the basic Haskell?
10:53:52 <danharaj> BarryCarter: Tell me this, does C 'know' about the gamma function?
10:53:57 <mauke> I don't know if there's a library
10:54:01 <mauke> what do you mean by "basic Haskell"?
10:54:02 <BarryCarter> danharaj: I see your point.
10:54:13 <BarryCarter> mauke: The basic install of Haskell.
10:54:26 <mauke> Haskell is a language, it's not something you can install
10:54:32 <mauke> see also: C
10:54:39 <BarryCarter> LOL :) I meant the basic Haskell interpreter.
10:54:41 <edwardk> danharaj: yes =) its in glibc ;)
10:54:50 <Veinor> let f days = f' days 1; f' days n = if  [days - n .. n] / (days ^ n) < 0.5 then n else f' days (n+1) in f 365.0
10:54:51 <mauke> BarryCarter: there is no "basic Haskell interpreter"
10:54:51 <danharaj> edwardk: Totally doesn't count.
10:54:52 <Veinor> > let f days = f' days 1; f' days n = if  [days - n .. n] / (days ^ n) < 0.5 then n else f' days (n+1) in f 365.0
10:54:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
10:54:58 <danharaj> It is not in the standard library.
10:55:00 <danharaj> er
10:55:04 <danharaj> the haskell standard library.
10:55:05 <mauke> BarryCarter: what's the basic C interpreter?
10:55:11 <danharaj> God knows why it's in the c stdlib.
10:55:16 <BarryCarter> That's what I meant... the thing I get when I do "yum install haskell"
10:55:31 <edwardk> hrmm i didn't add gamma and lngamma to numeric-extras
10:55:32 <BarryCarter> mauke: You're being philosophical-- you know what I mean.
10:55:38 <mauke> BarryCarter: no, I don't
10:55:48 <danharaj> http://www.haskell.org/haskellwiki/Gamma_and_Beta_function
10:55:50 <mauke> BarryCarter: e.g. I have no idea who packaged what for yum
10:55:57 <mauke> or why they called it "haskell"
10:56:19 <BarryCarter> mauke: The version of haskell we run in this room + the version of haskell Fedora 11 users get if using yum does not include the gamma function.
10:56:23 <edwardk> BarryCarter: i'm not quite sure what you're looking for or getting at. Haskell is a general purpose programming language, slightly more suited to some tasks than others.
10:56:37 <mauke> BarryCarter: what version of C do you run?
10:56:44 <BarryCarter> edwardk: I'm just curious if it can solve this "typical" problem.
10:56:59 <BarryCarter> mauke: I know what you mean -- there's a bajillion libraries that I have installed.
10:57:02 <mauke> or hey, what version of does everyone run in this room?
10:57:05 <mauke> +C
10:57:21 <edwardk> BarryCarter: of course it can, it is a general purpose programming language. can it do so efficiently? that is a more interesting question ;)
10:57:27 <danharaj> BarryCarter: Of course you can. That's what Turing complete means. Any algorithm can be implemented in a Turing complete language.
10:57:29 <Veinor> gah, I hate the numeric prelude
10:58:28 <BarryCarter> > log 2 CReal
10:58:30 <lambdabot>   Not in scope: data constructor `CReal'
10:58:53 <danharaj> > log 2 :: CReal
10:58:54 <lambdabot>   0.6931471805599453094172321214581765680755
10:58:58 <BarryCarter> Thanks
10:59:52 <danharaj> Are CReal's streams?
11:00:10 <ddarius> edwardk: Probably within a relatively small constant factor of any other language.
11:00:25 <edwardk> > let { gamma xx = let tmp' = (xx+5.5) - (xx+0.5)*log(xx+5.5); ser' = 1.000000000190015 + sum $ zipWith (/) [76.18009172947146,-86.50532032941677,24.01409824083091,-1.231739572450155,0.001208650973866179,-0.000005395239384953] [xx+1..] in exp (-tmp' + log(2.5066282746310005 * ser' / xx)) } in gamma 100
11:00:26 <lambdabot>   9.332621545366806e155
11:00:28 <edwardk> there, gamma ;)
11:01:00 <danharaj> gamma to what degree of precision :p
11:01:13 <edwardk> danharaj: i leave that to you to estimate ;)
11:01:30 <BarryCarter> I think I'll go annoy the sage people now...
11:01:34 <danharaj> edwardk: Do I look like a numerical analyst?
11:01:57 <BarryCarter> Apparently, there is no sage channel?
11:02:09 <edwardk> barrycarter that should tell you something about relative popularity ;)
11:02:46 <ddarius> of irc in those communities
11:03:01 <edwardk> danharaj: anyways that should be good enough as long as you're computing with doubles
11:03:09 <danharaj> hey, I think it is a reasonable assumption that irc popularity is uniform amongst neckbeard papulations.
11:03:10 <Veinor> > let f days = f' days 1; f' days n = if product [days - n + 1 .. days] * 2 <  (days ^ n) then n else f' days (n+1) in f 23
11:03:11 <lambdabot>   6
11:03:13 <Veinor> > let f days = f' days 1; f' days n = if product [days - n + 1 .. days] * 2 <  (days ^ n) then n else f' days (n+1) in f 365
11:03:14 <lambdabot>   23
11:03:30 <danharaj> populations
11:03:35 <Veinor> ta-dah
11:03:45 <ddarius> danharaj: But "neckbeard" populations aren't uniform among languages.
11:03:47 <edwardk> danharaj: internally that works with lngamma and then i exponentiate at the end to get an actual gamma, so there is some loss in the conversion step, but it was what i could scrape up on short notice ;)
11:04:23 <Veinor> there's gotta be a more haskelly way to write that
11:04:35 <danharaj> edwardk: You mean copy and pasting from haskellwiki? :D
11:04:38 <alexyk> anybody who really knows their ghc build from source routine?
11:04:42 <edwardk> danharaj: exactly =)
11:04:48 <wli> edwardk: I'd use Spouge's approximation.
11:05:10 <alexyk> I need some answers to the cafe post about it, or I can't build me a patched ghc.  OCaml rules until the ghc rises from the ashes!
11:05:24 <edwardk> danharaj: though sadly i think that post violates the terms of use of Numerical Algorithms, which has a fairly draconian license
11:05:27 <alexyk> or are all official ghc folks 9-to-5-ers?
11:06:03 <edwardk> alexyk: as in 9am to 5am? yes ;)
11:06:08 <danharaj> edwardk: It's on wikipedia, so I doubt it's in trouble.
11:06:14 <alexyk> btw Oleg implementes his lates stuff in OCaml, i.e. HANSEI probabilistic library
11:06:30 <alexyk> edwardk: 9 am to 5 pm next day :)
11:06:49 <danharaj> That BarryCarter guy went on the most bizarre line of inquiry in this channel that I have seen yet.
11:07:40 * danharaj coughblarghdarghl
11:07:56 <edwardk> alexyk: oleg is a polyglot -- he works in whatever language he feels like for any given problem ;)
11:08:05 <Veinor> > let f days = head $ dropWhile (\n -> product [days - n + 1 .. days] * 2 > 365 ^ n) [1..] in f 365
11:08:06 <lambdabot>   23
11:08:21 <Veinor> that's kind of slow because the product isn't shared :/
11:08:45 <Veinor> > let f days = head $ dropWhile (\n -> product [days - n + 1 .. days] * 2 > days ^ n) [1..] in f 365
11:08:47 <lambdabot>   23
11:08:47 <alexyk> edwardk: in fact, after painfully strictifying my problem -f-via-dafis, I can see why you'd pick ocaml for a compute-heavy stuff.  I mean, once you're done with !s, it's ocaml anyways.  :)
11:08:52 <edwardk> @pl f days = head $ dropWhile (\n -> product [days - n + 1 .. days] * 2 > 365 ^ n) [1..]
11:08:53 <lambdabot> f = head . flip dropWhile [1..] . (`ap` (365 ^)) . ((>) .) . flip flip 2 . (((*) . product) .) . (flip =<< (enumFromTo .) . flip flip 1 . ((+) .) . (-))
11:09:02 <BarryCarter> Nice!
11:09:10 <Veinor> ow!
11:09:23 <edwardk> BarryCarter: that was somewhat intended as humor ;)
11:09:26 <aristid> alexyk: does ocaml have integers with more than 31 bits these days?
11:09:34 <alexyk> zmg, what was that?  (days and ap stuff)
11:09:35 <danharaj> Obfuscated Haskell is the best obfuscated.
11:09:43 <Veinor> @pl \n -> product [days - n + 1 .. days] * 2 > 365 ^ n
11:09:43 <lambdabot> ap ((>) . (2 *) . product . flip enumFromTo days . (-) (1 + days)) (365 ^)
11:09:50 <aristid> @src ap
11:09:50 <lambdabot> ap = liftM2 id
11:09:59 <aristid> alexyk: there, that's what ap is
11:10:24 <edwardk> veinor i suppose the pl version would benefit from having an n `choose` k function
11:10:46 <alexyk> aristid: dunno, but it actually would overflow for twitter IDs.  so good point about 31 bit.
11:10:57 <Veinor> I think I could write it faster if I didn't recompute the product but just passed it around
11:11:05 <Veinor> but that's too much effort
11:11:25 <Veinor> meaning it wouldn't fit on one line any more without being annoying
11:11:42 <aristid> > [minBound,maxBound]::[Word64]
11:11:43 <lambdabot>   [0,18446744073709551615]
11:11:55 <aristid> alexyk: haskell has no problems with 64-bit :)
11:12:37 <alexyk> aristid: if only there was a switch {- LazynessOff -} :)
11:12:39 <aristid> > maxBound :: Integer
11:12:39 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:12:40 <lambdabot>    arising...
11:14:09 <alexyk> since Oleg is a pro in Haskell, and his OCaml code contains references to the originals translated from it, I suspect we needed something like strictness.  I'm gonna ask him :)
11:14:29 <ddarius> "Not that I'm complaining; personally I don't care much about the non-categorical properties of sets and neither should you."
11:14:45 <danharaj> Who said that?
11:16:40 <ddarius> Frank Atanassow
11:16:41 <danharaj> And does that mean properties that cannot be expressed in the language of category theory, or properties that are not true of all models of ZFC? :p
11:17:04 <ddarius> The former.
11:18:41 <aristid> ddarius: does your quoting it imply that you think it's true?
11:18:55 <dons> what's up, alexyk ?
11:19:14 <alexyk> heya!  I need me a ghc built and I can't.  Posted to the cafe.
11:19:34 <alexyk> basically won't relocate an .o in linking near the end of stage1
11:19:44 <dons> can you just use a nightly snapshot build?
11:20:00 <alexyk> dons: is there one for amd64?
11:20:08 <solrize> morley categoricity theorem
11:20:18 <dons> alexyk: yeah, let's see... 
11:20:18 <ddarius> aristid: My quoting implies that I think it was of interest to (parts of) this audience.
11:20:36 <dons> http://www.haskell.org/ghc/dist/current/dist/ghc-6.13.20100625-x86_64-unknown-linux.tar.bz2
11:20:39 <dons> last night's ghc head?
11:20:43 <dons> for linux/x86_64
11:21:27 <alexyk> niceee
11:22:00 <alexyk> now I see there's 6.12.3 -- wonder if my bug's fix made it in there
11:22:27 <dons> i don't think so. simon said yesterday that it would be easy to back port the patch though
11:22:28 <zygoloid> why do the sizes of ghc tarballs vary so wildly?
11:22:35 <dons> since it was just a one line change iirc.
11:23:08 <danharaj> zygoloid: ghc code is so technical, it exhibits quantum mechanical properties
11:24:13 <alexyk> dons: di dyou see my question on the cafe?  I'm wondering about the darcs branches for head vs 6.12.  Do I get 6.12 if I get head?  and how do I backport form one to another -- across repos, with darcs patch extraction as if for email?
11:25:19 <alexyk> the wiki contains two separate darcs get URLs for ghc head and 6.12, although one is under the other.  Is it related to darcs' branches, amd can it be done locally from head?
11:26:58 <alexyk> for now I'll unpack the head, but am still curious about the relationship above
11:27:28 <alexyk> is it safe enough to run the head?  do folks do that?
11:28:20 <alexyk> arrgh crap: nightly build wants libtinfo
11:29:19 <alexyk> is libtinfo a feature of a distro?  can it be brought to CentOS?
11:29:31 <edwardk> alexyk: the tricky part is that you typically don't have many libraries when running head
11:29:58 <alexyk> edwardk: I'll script some ghc-pkg reinstall with cabal
11:30:16 <alexyk> I basically want the same set of packages from hackage recompiled, not a large one
11:32:33 <edwardk> alexyk: the only issues you may run into is if anything has a hard cap on base or one of the supplied built-in packages
11:33:07 <alexyk> edwardk: capped from below?
11:33:26 * ddarius remembers building GHC HEAD many years ago.
11:33:34 <ddarius> (on Windows)
11:33:49 <danharaj> what?
11:33:56 <danharaj> You can actually *do* that?
11:34:48 <edwardk> alexyk i.e. if the library said 'random-packaged-library > 0.3 && < 0.4 and the ghc bumped it internally to 0.4 or something due to incompatible changes
11:35:01 <edwardk> er and the ghc folks
11:36:29 <ddarius> It took a while because I was running a Pentium II 200 with 64MB of RAM in -2003- and GHC included more then.
11:37:13 <danharaj> the only thing that could be worse is if you downloaded it on a 56k connection.
11:37:19 <ddarius> danharaj: I did.
11:37:30 <danharaj> :|
11:38:02 <monochrom> haha
11:38:25 <alexyk> "A little while ago NCurses was split in to two libraries, libncurses.so and libtinfo.so. Some badly written software will try and link explicitly with libtinfo.so directly rather than trying libncurses.so first." -- apparently ghc head tries that.
11:38:53 <ddarius> Hmm.  I've never paid an Internet company for Internet.
11:39:10 <benmachine> ddarius: who have you paid?
11:39:31 <ddarius> benmachine: Either no one or someone else who was paying an Internet company.
11:39:36 <benmachine> oic
11:40:18 <monochrom> One way to not pay for internet is to keep using aol free trials. :)
11:40:31 <alexyk> can I just symlink libncurses to libtinfo?...
11:40:40 <ddarius> benmachine: Right now I'm using Internet provided "for free" by the hotel I'm staying at which is paid for by the US government.
11:41:29 <monochrom> oh haha, even better plan: keep living in hotels :)
11:42:17 <monochrom> I am not sure you should symlink libncurses to libtinfo. But there is emphatically a build of ghc needing no libtinfo from you.
11:42:28 <ddarius> I just realized that I'm going to make a decent chunk of money "extra" this month
11:42:43 <monochrom> oh, ghc head, nevermind.
11:42:56 <benmachine> monochrom: do they like, work consecutively
11:43:02 <benmachine> do they not notice you're using about 8 of them
11:43:34 <monochrom> aol? well I suppose you have to lie about your personal information so they don't notice
11:44:41 <benmachine> heh
11:44:43 <benmachine> k
11:46:21 <alexyk> symlinking did make install go through.  silly dog tricks.
11:46:42 <monochrom> but will it run properly?
11:46:52 <alexyk> dunno, will see :)
11:47:05 <monochrom> I guess it will.
11:47:17 <alexyk> yep
11:48:15 <alexyk> FunctorSalad_: what was that script idea you had on reinstalling with ghc-pkg from one ghc to another?
11:49:08 <alexyk> how do we select ghc version with ghc-pkg?
11:51:40 <alexyk> Saizan: cabal --help doesn't list -w as an option for ghc selection?
11:52:16 <FunctorSalad_> alexyk: list all the pkg names with ghc-pkg, then with the new ghc version set up, do "for x in $(< packages); do cabal install $x; done"?
11:52:19 <alexyk> ah ok, cabal install -w
11:52:58 <alexyk> FunctorSalad_: how do we select ghc-pkg?  I'm afraid my old one is overwritten by the new one
11:53:05 <FunctorSalad_> alexyk: iirc you get a different ghc-pkg binary for each version
11:53:22 <alexyk> FunctorSalad_: folks said it's safe to install into the same prefix.
11:53:41 <FunctorSalad_> (you may have some older ones like ghc-pkg-6.12.2
11:53:42 <alexyk> FunctorSalad_: so I guess I'll need to select the actual library location with the current ghc-pkg...
11:53:43 <FunctorSalad_> )
11:53:51 <alexyk> lemme see
11:54:03 <alexyk> yeah
11:54:07 <FunctorSalad_> I think 'ghc-pkg' just links to ghc-pkg-blah
11:54:12 <alexyk> -6.12.1
11:55:00 <alexyk> FunctorSalad_: and we neec cabal install -w new-ghc
11:55:03 <alexyk> need
11:56:37 <dafis> alexyk: ghc-pkg is a link to the newest ghc-pkg-version
11:57:01 <dafis> you can use the older (or the new) with the explicit version
11:57:23 <portnov> @hoogle whenM
11:57:23 <lambdabot> No results found
11:58:28 <alexyk> dafis: OK!  BTW, I'm unnerved by the amount of bangs in our version, and wonder if there's a systematic way to explain why each is needed?  Is there a way to drop as many as possible?
11:58:58 <alexyk> if making performant haskell becomes a guess on bangification, it's too tricky
11:59:14 <alexyk> easier to make a Map strict in constructor
11:59:33 <alexyk> and have strict versions of all packages needed
12:00:48 <alexyk> bangalore -- a place where haskell gets bang galore
12:00:56 <alexyk> and runs fast
12:01:01 <dafis> alexyk: placing bangs is mostly a more or less educated guess
12:01:23 <alexyk> dafis: so you use the case trick to bangify tuples?
12:01:37 <alexyk> where only one case is matched always?
12:02:30 <alexyk> is there an environment variable for cabal install -w ?
12:02:32 <dafis> alexyk: depends on what you need, if you need the values of the components, you must put bangs inside the tuple
12:03:18 <dafis> if you just want to ascertain that it's a real tuple and not undefined, case alone is enough
12:03:49 <dafis> alexyk: I think cabal defaults to the unversioned ghc if there is one
12:04:37 <alexyk> dafis: right, and since ghc driver is overwritten to the latest, that should now just work into it
12:04:45 <FunctorSalad_> speaking of ugprading... maybe I should upgrade from 6.13rc to 6.13 some time ;)
12:04:58 <FunctorSalad_> The Glorious Glasgow Haskell Compilation System, version 6.12.2.20100521
12:05:00 <FunctorSalad_> that one
12:05:04 <dafis> FunctorSalad_, you mean 6.12.3?
12:05:11 <FunctorSalad_> dafis: yes
12:06:10 <dafis> FunctorSalad_, don't know whether there have been any changes
12:06:21 <dafis> but the version number is shorter :)
12:06:23 <alexyk> so I get no base in 6.13.xxx.  Did base go away?
12:06:57 <dafis> alexyk: that would surprise me
12:07:20 <alexyk> http://paste.pocoo.org/show/230349/ -- what to force?
12:08:19 <alexyk> yeah, base is 4.3 in 6.13
12:08:25 <alexyk> should I just force it?
12:11:06 <alexyk> ...and how do I force base 4 to be used?
12:12:01 <monochrom> base >= 4 ?
12:12:35 <alexyk> monochrom: even if JSONb wants base < 4?
12:13:26 <portnov> @type lift when
12:13:28 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) Bool) (m () -> m ())
12:13:29 <dafis> alexyk: try cabal unpack JSONb and edit the .cabal file, don't forget to do a minor-minor version bump
12:13:45 <dafis> alexyk: *maybe* it will compile with base 4
12:14:28 <alexyk> why would people cap with base < 4?  are they afraid of the future?
12:15:33 <portnov> @type liftM when
12:15:34 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
12:16:06 <alexyk> dafis: would I rename JSONb-1.0.0 to 1.0.1 or 1.1.0?
12:17:01 <dafis> alexyk: to 1.0.0.1, 1.0.1 is already on Hackage and 1.1.0 is likely to appear some time
12:17:05 <aristid> @type join . liftM when
12:17:06 <lambdabot> forall (m :: * -> *). (Monad m) => (m () -> Bool) -> m () -> m ()
12:17:30 <alexyk> ok; and how do I build it in the unpacked dir with Setup.hs?
12:18:00 <alexyk> ...and install?
12:18:12 <dafis> alexyk: simplest, cd to unpacked and changed dir, then "cabal install"
12:18:37 <alexyk> okok
12:20:55 <alexyk> dafis: yay, that worked for jsonb!  
12:24:08 <alexyk> I get mtl-1.1.0.2 pulled with tons of warnings like: Warning: -fallow-undecidable-instances is deprecated: use -XUndecidableInstances or pragma {-# LANGUAGE UndecidableInstances #-} instead -- is there a newer mtl for 6.13?
12:25:22 <roconnor> alexyk: monadlib is better if that is an option
12:25:48 <alexyk> roconnor: I compile an existing package, tokyocabinet-haskell, using mtl
12:25:53 <roconnor> ok
12:27:10 <alexyk> roconnor: does monadlib provide Control.Monad?
12:27:30 <c_wraith> Control.Monad is in base
12:28:00 <roconnor> monadlib isn't compatible with mtl afaik
12:28:16 <roconnor> though I suppose there could be a compatability package
12:28:25 <c_wraith> It's not compatible with mtl at all.  Which means it avoids all the transformers/mtl conflicts
12:29:51 <alexyk> okok
12:30:56 <alexyk> hmm: I get this for Data.Binary:     Could not find module `Data.Binary':
12:30:57 <alexyk>       It is a member of the hidden package `binary-0.5.0.2'.
12:30:57 <alexyk> -- ?
12:31:30 <c_wraith> you're not using cabal to build your program?
12:31:55 <alexyk> I just use ghc --make
12:31:55 <alexyk> it's all in one dir
12:32:02 <c_wraith> you should use cabal anyway
12:32:10 <c_wraith> it takes care of things for you
12:32:24 <c_wraith> and "cabal init" is pretty good.
12:32:35 <alexyk> but what does that mean for the binary?
12:32:53 <c_wraith> it means that ghc's package registry has binary-0.5.0.2 registered as hidden
12:33:12 <c_wraith> you'll either need to add "-package binary-0.5.0.2" to your command line, or start using cabal.
12:33:25 <c_wraith> or use ghc-pkg unhide, I guess
12:33:27 <alexyk> c_wraith: :)
12:33:51 <alexyk> c_wraith: why would it hide it?
12:33:57 <alexyk> they didn't test it yet?
12:34:07 <c_wraith> I don't know, and I don't care.  I use cabal. :)
12:35:03 <alexyk> c_wraith: sounds like cabal-aid :)
12:35:41 <shajen> hi all :)
12:35:54 <shajen> i have a questions about type of haskell
12:36:33 <dafis> shajen: okay, which questions
12:36:36 <c_wraith> shajen: go ahead and ask
12:36:49 <shajen> what is type of (.)(.)(.)
12:37:02 <dafis> :t (.) (.) (.)
12:37:02 <aristid> :t (.)(.)(.)
12:37:03 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:37:03 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:37:11 <aristid> except that it isn't
12:37:16 <c_wraith> using the correct . would help. :)
12:37:28 <aristid>  :t (.)(.)(.)
12:37:28 <aristid> (.)(.)(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:37:58 <c_wraith> shajen, you know ghci can answer these kinds of questions?
12:38:14 <dafis> or hugs
12:38:17 <shajen> ok, i have a type
12:38:27 <shajen> but i dont know is this type is correct ;]
12:38:45 <alexyk> wow, it all compiled under 6.13.
12:38:53 <shajen> i have an exam tomorrow i have to write type of functions without gchi
12:39:00 <dafis> alexyk: nice
12:39:02 <alexyk> when do they shoot for 6.14?
12:39:06 <ddarius> alexyk: Why wouldn't it?
12:39:18 <dafis> alexyk: probably december
12:39:42 <c_wraith> Is getting tibbe and bos's event manager in a goal for 6.14?
12:40:10 <alexyk> ddarius: hidden packages, .cabal for deps specifying base < 4, quirks of fate, earthquake on the Ontario/Quebec border
12:40:10 <alexyk> (which shook Dartmouth too)
12:40:50 <dons> alexyk: so you're running a ghc head snapshot now, with your GC fixes?
12:41:11 <dafis> shajen: get practice inferring types by hand and check with ghci while you still have a little time
12:41:15 <alexyk> dons: yessir.  Please pass along that dependence on libtinfo is considered a bad form :)
12:41:25 <dons> mmm
12:41:29 <dons> Igloo: ^^^ 
12:41:32 <dons> alexyk: passed along :)
12:41:57 <c_wraith> isn't the binary version of ghc typically packaged with and without that dependency?
12:42:00 <alexyk> any such should check for ncurses first
12:42:00 <alexyk> I symlinked libncurses to libtinfo and it worked
12:42:05 <c_wraith> when it's released, that is
12:42:08 <shajen> dafis: i know
12:42:29 <roconnor> dons: IO is still purely functional isn't it?
12:42:52 <alexyk> but now the fun begins -- it compiled, but will it run?  will it match the results of clojure and ocaml numerically?  how long will it take? we'll find out soon :)
12:43:07 <dons> roconnor: yeah, in my view, under  the 'haskell is a declarative language for describing io computations' model
12:43:34 <dons> but it needs specific support in the runtime, so i include it in a separate ring.
12:43:42 <roconnor> hmm
12:43:48 <alexyk> c_wraith: teh interwebs report it's silly as if you have ncurses you should link to it; or is it a build without ncurses at all?
12:44:09 <dons> its an alternate coding of the 'useful/unsafe' 2D graph that spj uses, i guess
12:44:15 <ddarius> IO always needs specific support from the runtime.
12:44:26 <roconnor> intersting argument.  I'm not sure I entirely believe it
12:44:33 <dons> alexyk: hope to see good numbers. we've been working hard on this system for many years :)
12:44:54 <dons> alexyk: will help later next week still be useful to you? i've got more time free to work on the benchmarks then.
12:45:09 <roconnor> but certainly the runtime provides a non-standard intepretation of IO
12:45:18 <alexyk> dons: absilutely.
12:45:28 <dons> ok. good to know!
12:45:29 <roconnor> (the standard interpretation being some sort of IO-Tree type)
12:45:53 <alexyk> this haskell needs a mighty beating
12:45:53 <alexyk> (my project that is)
12:46:17 <dons> alexyk: did you try haskell-judy yet, btw?
12:48:46 <alexyk> dons: not yet, would require a rewrite
12:48:46 <alexyk> first I'll compare with IntMap
12:48:46 <alexyk> but judy will run against ocaml's imperative Hashtbl
12:48:46 <alexyk> which lets things finish in 15 minutes in ocaml
12:48:46 <alexyk> c_wraith: is there ghc-pkg unhide?
12:49:06 <c_wraith> ghc-pkg has something to unhide stuff
12:49:11 <c_wraith> I don't remember the exact command
12:49:17 <dons> ok. 
12:49:35 <dons> alexyk: did you see the new patches to IntMap and friends that greatly improve performance?
12:49:43 <dons> a paper got published, but the patches aren't out yet.
12:49:57 <alexyk> dons: ah!  nope, not yeh
12:49:58 <dons> alexyk: http://fox.ucw.cz/papers/containers/containers.pdf so i think we need to get those to you...
12:50:06 <alexyk> surely
12:50:14 <dons> they made some big performance improvements to Map and IntMap
12:50:20 <dons> and introduce a HashSet data type as well.
12:50:35 <dons> so its a hot topic :)
12:50:43 <alexyk> dons: did you see the ocaml's fast functional maps, ternary ones, by Mauricio Fernandez?
12:51:04 <dons> a while ago. haven't heard anything recently
12:51:08 <dons> is mfp helping out?
12:51:15 <dons> he's a very good hacker!
12:52:10 <dafis> alexyk: ghc-pkg expose
12:52:36 <alexyk> dons: not yet.  Once I publish the three versions, the battle of the titans will ensue!  you're seeded as the titan #1.  :)
12:52:36 <alexyk> ok
12:52:36 <alexyk> dons: I mean these: http://eigenclass.org/R2/writings/finite-map-benchmarks
12:52:52 <alexyk> the Ternary is the fastest functional maps there.  OCaml folks recommended those for string and a Patricia tree for ints.
12:53:15 <dons> alexyk: ah very cool.
12:53:21 <dons> IntMap is a patricia tree.
12:53:27 <alexyk> good good
12:53:54 <dons> well, i hope to be able to help. i've been frustratingly busy this past two weeks
12:54:03 <dons> i just asked the intMap guy for the new patches
12:55:39 <alexyk> cool.  The shootout will be permanent, so folks could keep improving their FP langs for large data.
12:55:39 <alexyk> and even non-Fp langs if they want.
12:55:46 <alexyk> Where can I host 300 MB of the data?
12:55:52 <dons> mmm
12:55:53 <alexyk> so I don't pay for traffic
12:56:03 <alexyk> perhaps sourceforge?
12:56:03 <dons> that's a good question.
12:56:08 <dons> yes, github?
12:56:12 <dons> something like that.
12:56:21 <alexyk> I'll figure it out
12:56:37 <dons> when are you expecting to publish all the results?
12:56:42 <dons> as a paper first? 
12:58:17 <mreh> http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/ -- I'm still not sure about that first example. Is the lazy state monad's variable able to be processed individually as a thunk even when it's part of a tuple, that is when I'm using bind?
12:58:30 <alexyk> dons: simpler than that, probably next week as a blog post and three repos, and simple time results
12:58:30 <alexyk> so folks can hack
12:58:52 <alexyk> dons: given haskell works first
12:59:20 <dons> ok. nice. yes, the data set, the benchmark code in a few languages. that'll be good
13:00:08 <aristid> the first rule of haskell: every haskell blog has "monad" in the name.
13:00:16 <mauke> does anyone happen to have the pdf from http://portal.acm.org/citation.cfm?id=116845 ?
13:00:25 <solrize> alexkey what 300MB of data?  archive.org might be a good place
13:00:39 <solrize> alexyk i mean
13:00:50 <dons> mauke: yes.
13:00:59 <mreh> what's a monad?
13:01:10 <dons> mauke: send me an email.
13:01:37 <c_wraith> mreh: someone who wanders from place to place
13:02:06 <alexyk> of I specify +RTS -M60G and it wants to grow more, will it segfault, get killed, or what?
13:02:06 <alexyk> solrize: how do I upload?
13:02:09 <dons> mauke: oh, its online.
13:02:10 <dafis> mreh: the lazy state monad's bind is very lazy, so it works
13:02:11 <solrize> i wonder if it's possible to implement cache-oblivious container structures in haskell (i guess i could check @faq...)
13:02:20 <dons> alexyk: it will get killed by the rts
13:02:27 <solrize> alexyk, http://www.archive.org/create/
13:02:35 <dons> you'll get a little 'Heap exhausted' error message
13:02:46 <bos> poor exhausted heap. so tired.
13:02:49 <mreh> hehe
13:03:06 <mreh> it collapsed in a heap
13:03:06 <ddarius> solrize: It would be ugly but certainly possible.
13:03:18 <ddarius> Haskell provides little in the way of controlling memory representation.
13:03:52 <alexyk> wow haskell flies
13:03:59 <solrize> well, it could live inside of data.vector or something
13:04:01 <alexyk> still
13:04:04 <aristid> alexyk: flies?
13:04:10 <dons> mauke: http://www.egeen.ee/u/vilo/edu/2002-03/Tekstialgoritmid_I/Articles/Exact/Two-way-p650-crochemore.pdf
13:04:19 <alexyk> aristid: goes fast through my data days
13:04:22 <mauke> oh, nice
13:04:23 <mauke> thanks
13:04:25 <dons> alexyk: how fast?
13:04:33 <alexyk> it used to hit a pothole, we'll see
13:04:43 <dons> this is ghc 6.13-head, with an IntMap and -O2 ?
13:04:44 <alexyk> dons: for now very fast :)  I keep my fungers crossed
13:04:51 <alexyk> dons: yes
13:04:57 * dons holds breath
13:05:26 <dafis> dons: it won't be *that* fast, start breathing again
13:05:37 * dons *gasps*
13:06:01 <dons> we need to get those optimized IntMap patches.
13:06:06 <alexyk> I have another guys eating 16 GB of RAM and the folks who set up swap there allocated only 20 GB, so I crash it often
13:06:08 <dons> and a specializing IntMap via type families.
13:06:52 * bos grows old waiting for darcs to ... do whatever it's doing
13:06:54 <solrize> that would be awesome, maybe even a generic map that used IntMap or Map as appropriate
13:07:02 <alexyk> ok I see kswapd's approach as hungry hienas
13:07:53 <aristid> :t put
13:07:54 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:08:16 <dons> alexyk: fwd' you an email on trie benchmarking
13:08:54 <alexyk> thx
13:09:36 * dons dreams of a world with fast parallel IntMaps built on `par`
13:09:53 <dons> alexyk: you're not using multicore stuff yet, right?
13:10:01 <edwardk> dons: ooh shiny
13:10:12 <dons> easier than STM-based IntMapTVars
13:10:14 <alexyk> dons: in haskell, no.  in clojure, a bit :)
13:10:25 <dons> oh, hmm. how many cores are available?
13:10:42 <alexyk> dons: but one of the main lures of haskell vs ocaml is parallelism.   8 mighty cores
13:10:44 <edwardk> dons: how many of the algorithms on intmaps really need the parallelism though?
13:10:56 <edwardk> dons: i can see the hedge union machinery benefitting, etc.
13:11:02 <edwardk> but not the common insertions
13:11:05 <dons> edwardk: map, tree fold? 
13:11:08 <dons> hard to say
13:11:18 <edwardk> *nods*
13:11:25 <alexyk> the alg is highly parallelizable
13:11:27 <dons> parallelizing insertions though seem to need TVars (?)
13:11:34 <alexyk> you fold over each day producing the next one
13:11:35 <dons> alexyk: oh, that's exciting.
13:11:48 <alexyk> for 4 million users; those can be map/reduced
13:12:04 <dons> right. makes sense. 
13:12:25 <dons> yes, parallelism is the key thing to try, once you've got acceptable sequential performance in haskell.
13:12:40 <dons> probably `par`-style with these purely functional structures will be easiest.
13:12:48 <dons> parMap and friends.
13:13:22 <int80_h> the ghc web page recommends I install the haskell platform instead of ghc 6.12.x, and the haskell platform wants ghc 6.12. see the paradox? What do I do? 
13:13:48 <alexyk> wow!  all 34 days done; writing results now
13:13:54 <dons> int80_h: linux kernel :: linux distro.
13:14:03 <dons>  ghc :: haskell platform
13:14:13 <dons> alexyk: nice. that's about what, 10 mins
13:14:21 <edwardk> dons that reminds me, there was a paper posted to reddit by microsoft regarding some speculative programming combinators, that upon the surface look like they can be hacked up really nicely in haskell
13:14:24 <dons> and i know we can improve IntMap...
13:14:28 <alexyk> donsL 20 minutes to ocaml's 14 :)
13:14:30 <edwardk> dons: http://www.reddit.com/r/programming/comments/cbqxo/language_constructs_for_speculative_parallelism/c0rojmj
13:14:33 <dons> alexyk: doh!
13:14:40 <dons> alexyk: we can do better.
13:14:47 <alexyk> dons: but ocaml usesd imperative Hashtbl
13:14:49 <edwardk> i'm curious to see if a nice library could be made out of them
13:14:54 <int80_h> using debian lenny with  2.6.26-2-xen-amd64
13:15:00 <int80_h> dons using debian lenny with  2.6.26-2-xen-amd64
13:15:04 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ocaml :)
13:15:14 <dons> alexyk: ah, nice. so that's plausible then.
13:15:16 <bos> dons: it would be fun, and i believe important (in the motivating sense) to see us benchmark Haskell collections against those of other languages
13:15:25 <int80_h> dons not sure what you were getting at in your second line
13:15:47 <dons> int80_h: its not a paradox.
13:15:57 <dons> but its a bit badly worded.
13:16:13 <dons> bos: yes, alexyk's kind of pushing us that way.
13:16:18 <dons> and this new IntMap paper helps too.
13:16:23 <dons> bos: have you been following alexyk ?
13:16:28 <int80_h> seems to be, the haskell platform wants a version of ghc that the ghc page says to not install, and to install the haskell platform instead. Which meeds the ...
13:16:39 <dons> he's loading all of twitter or something in to a map in haskell, ocaml, clojure and comparing the result.
13:16:46 <bos> dons: i've been watching a little bit of the chat, but the channel is busy and i'm trying to work on the I/O manager
13:16:47 <dons> about 30G or so 
13:16:51 <int80_h> dons: what would you recommend I do?
13:16:53 <jbapple> There was a Stack Overflow question that showed IntSet within spitting distance of C++ Boost hash tables
13:17:04 <bos> dons: neat
13:17:10 <dons> int80_h: install the haskell platform , via a binary installer, if your distro has one
13:17:20 <edwardk> bos: great work on the new i/o manager btw
13:17:21 <dons> if it doesn't, install ghc, then the haskell platform source installer
13:17:31 <bos> edwardk: there's still more room for improvement!
13:17:36 <jbapple> Now, harrop claimed that F# hash tables were much faster, which makes me think that there's a lot to be said for constant-factor improvements
13:17:44 <dons> jbapple: and that's a) without the published IntMap improvements, and b) auto-specialization
13:17:46 <bos> harrop is a lying sack of poo.
13:17:48 <dons> so I think we can make IntMap fly.
13:17:51 <edwardk> bos: especially with spotting the blachole queuing problem
13:18:02 <jbapple> Including tuning not only IntSet, but also Haskell's IO-based hash tables
13:18:05 <bos> if he said the earth orbited the sun, i'd launch a satellite to check.
13:18:52 <Heffalump> jbapple: which question?
13:18:54 <jbapple> dons: I think the published results made IntSets about 10% faster, which would still be much slower if harrop's numbers hold up
13:18:56 <dons> the scientific method isn't his strongest point.
13:18:56 <int80_h> dons : do you recommend 6.12? or should I install 6.10?
13:19:06 <bos> int80_h: 6.12
13:19:08 <dons> int80_h: the platform requires ghc 6.12.1
13:19:20 <dons> and that's what you should use unless you know something better
13:19:35 <dons> (i.e. you're alexyk and you need a patch in some other branch, etc)
13:19:44 <jbapple> bos: Some of the things he says are transparently false. I don't know if he's lying or deluded when he says them. That said, I don't have Windows, so I can't test his hash table assertions
13:20:12 <jbapple> dons: I think you might be right. I suspect IntMaps can be made much faster
13:20:39 <Heffalump> I made a vague attempt to test them, and it seems like if you go up from 10,000,000 entries to say 11,000,000, .NET runs out of memory.
13:20:44 <jbapple> I think giving up the ordered property will help, since hashing will ensure (probabilistically) shorter maps
13:20:54 <alexyk> bos: is there an honest sack of poo?  :)
13:20:57 <jbapple> dons: I also suspect that binary tries is not enough ary :-)
13:21:02 <dons> yep
13:21:07 <Heffalump> though I suspect something more complicated was going on there.
13:21:09 <dons> i think that's true as well. 32-way etc is clever.
13:21:30 <bos> i sure wish ghc was easier to hack on.
13:21:34 <jbapple> bos: :-) Yeah, and he would say satellites are never used in industry ;-)
13:21:46 <bos> i run into build problems almost every time i pull.
13:22:13 <alexyk> but, I'm very happy with haskell guys.  It's alive for sure and self-improves very quickly as a community-based thing
13:22:31 <jbapple> Heffalump: Hm. Sounds intriguing. I'd love to see more numbers.
13:22:54 <dons> alexyk: and i think we have high standards for ourselves. we won't fail you :)
13:23:10 <jbapple> Heffalump: let me find you a link
13:23:19 <ddarius> Reasons to use Haskell in order of importance:  Number 1. Community.
13:23:37 <alexyk> dons: that's a real advantage.  650+ folks on IRC here to 200+ for scaka/clojure and 80 for ocaml.
13:23:42 <alexyk> scala
13:24:04 <alexyk> ddarius: and it's most active from all on weekends! :)
13:24:07 <companion_cube> maybe ocaml noobs need less help ? :þ
13:24:10 <lispy> dons: page 58 of the pdf.  I don't think the sample output matches the sample program
13:24:23 <dons> lispy: yikes!
13:24:45 <dons> lispy: indeed!
13:24:50 <lispy> dons: :)
13:24:53 <dons> lispy: that got published.
13:24:57 <dons> and no one spotted it
13:25:02 <jbapple> Heffalump: http://stackoverflow.com/questions/3058529/curious-about-the-hashtable-problem
13:25:06 <dons> lispy: logical page 44?
13:25:17 <lispy> dons: yup
13:25:24 <lispy> dons: wait, you already submitted it?
13:25:32 <dons> no no. that was in the hs-plugins paper originally
13:25:37 <lispy> oh
13:25:40 <dons> so its gone unnoticed for 5 years...
13:25:41 <lispy> heh, I see
13:25:53 <dons> you win an internet point.
13:25:59 <lispy> haha
13:26:21 * lispy does the abstract point gainage dance
13:26:46 <jbapple> Heffalump: http://incise.org/hash-table-benchmarks.html Is a harrop-provided link on that page comparing various imperative hash tables
13:27:03 <dons> alexyk: and you get core developers like Simon logging in to fix your stuff. :)
13:27:31 <alexyk> indeed.  And spending $26 on Amazon's EC2!
13:27:33 <alexyk> :)
13:27:40 <alexyk> I hope MSFT reimburses that
13:28:22 <Heffalump> jbapple: ah, ok, you did mean that thread. I wasn't sure because you said 'IntSet' above, but I guess you meant IntMap.
13:28:24 <edwardk> lispy++
13:28:30 <edwardk> your point has been delivered
13:28:53 <alexyk> from now on, Haskell devs should get at least 64 GB of RAM :)
13:29:14 <jbapple> Heffalump: Yes, I may have.
13:29:28 <alexyk> in ghci, how do I load a locally-compiled module in the current dir?
13:29:59 <lispy> alexyk: doesn't :l foo do that?
13:30:19 <lispy> alexyk: possibly you have to specify the extension, .o or whatever
13:30:46 <ddarius> alexyk: It will be chosen by default.
13:30:59 <Heffalump> unless ghc thinks it's not up to date
13:31:51 <alexyk> lispy: yep, loads an .hs
13:32:40 <alexyk> does ghci run loaded functions at full speed
13:32:42 <alexyk> ?
13:33:14 <dons> no, it interprets them as bytecode
13:33:21 <dafis> alexyk: for compiled code (.o) the difference to a binary is usually not too large
13:33:22 <dons> unless it is pulling them from a compiled object, like a library
13:33:38 <dons> in general, don't do benchmarking in ghci, as it isn't designed for that :)
13:34:16 <lispy> dons: I may not make it past chpt 2 before I run out of time.   Just so you know :)
13:34:27 <alexyk> yep, I'm just browsing results back from Binary
13:34:52 <dons> alexyk: yeah, you can compile to a .o file, and load in ghci. you get a different prompt (not '*' in the prompt, if it isn't bytecode)
13:35:14 <alexyk> so :l "File" loads File.hs; :m +File doesn't find the locally compiled File.o; how do I load .o?
13:35:43 <dons> Prelude> :l A.hs
13:35:43 <dons> [1 of 1] Compiling A                ( A.hs, interpreted )
13:35:43 <dons> Ok, modules loaded: A.
13:35:43 <dons> *A> 
13:35:46 <dons> ^^ bytecode, right?
13:36:02 <dons> $ ghc -O2 -c A.hs
13:36:03 <dons> $ ghci           
13:36:03 <dons> GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
13:36:03 <dons> Loading package ghc-prim ... linking ... done.
13:36:03 <dons> Loading package integer-gmp ... linking ... done.
13:36:05 <dons> Loading package base ... linking ... done.
13:36:07 <dons> Loading package ffi-1.0 ... linking ... done.
13:36:10 <dons> Prelude> :l A.hs
13:36:13 <dons> Ok, modules loaded: A.
13:36:15 <dons> Prelude A>
13:36:18 <dons> ^^ object code
13:36:24 <ryanakca> I'm trying to rewrite takeWhile with foldr. I have http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26583#a26583 , but it does not compile, "Occurs check: cannot construct the infinite type: b = [b]". What am I doing wrong?
13:36:31 <alexyk> yep
13:36:56 <dons> so compile your .o offline with $ ghc -O2 -c A.hs and then load that module in the current directory (ghci will look for its .hi file)
13:37:15 <alexyk> is there a way to :m +Data.Map so I can use Prelude.map without prefix?
13:37:40 <dons> i don't think so. no import qualfied in ghci
13:39:09 <aavogt> there is a patch for that
13:39:32 <alexyk> aavogt: which one?
13:40:01 <aavogt> http://hackage.haskell.org/trac/ghc/ticket/2362
13:40:27 <aavogt> so if you have some patience, it should end up in the next ghc
13:41:27 <lispy> dons: I've reached a point with MM and other calendaring tools where I'm thinking of drawing up some functional specs and starting a FOSS project to make one that kicks ass :)
13:41:50 <ddarius> lispy: Go for it.
13:42:08 <lispy> I bet Haskell could do this pretty well
13:42:15 <ddarius> lispy: Go for it.
13:42:44 <dafis> ryanakca, flip the parameters of acc
13:44:42 <alexyk> aavogt: is it in the head?
13:44:54 * hackagebot funsat 0.6.1 - A modern DPLL-style SAT solver  http://hackage.haskell.org/package/funsat-0.6.1 (DenisBueno)
13:45:08 <dafis> ryanakca, Oh, and remove the type signature from the definition of acc or bring the type variable a into scope via ScopedTypeVariables and an explicit forall
13:45:09 <alexyk> aavogt: patience is not what a programmer usually has :)
13:45:11 <ryanakca> dafis: Ah, that's one part. Still doesn't compile, but thanks :)
13:45:35 <ryanakca> dafis: Ah. I'll drop the type signature... I have no clue what scope / forall are, I'm only at chapter 4 of RWH
13:45:36 <dafis> ryanakca, that's probably the type signature
13:45:45 <ryanakca> Yep, thanks :)
13:46:00 <dafis> @let ftW f xs = foldr acc [] xs where acc x nac = if f x then (x: nac) else []
13:46:03 <lambdabot>  Defined.
13:46:10 <dafis> ftW (< 10) [1 .. 100]
13:46:13 <dafis> > ftW (< 10) [1 .. 100]
13:46:15 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:46:59 <ryanakca> On to groupBy with fold now :)
13:47:31 <alexyk> the lazy read from a compressed file is amazing: first fromList show up... after a while, the data
13:48:42 <aristid> :t ftW
13:48:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:49:12 <aristid> > ftw (/= 2) [1..59
13:49:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:49:16 <aristid> > ftw (/= 2) [1..5]
13:49:17 <lambdabot>   Not in scope: `ftw'
13:49:25 <aristid> > ftW (/= 2) [1..5]
13:49:26 <lambdabot>   [1]
13:50:22 <aristid> @let ftW' = dropWhile . not
13:50:22 <lambdabot>  <local>:6:19:
13:50:23 <lambdabot>      Couldn't match expected type `a -> Bool'
13:50:23 <lambdabot>             agai...
13:50:55 <dafis> @let ftW' = (dropWhile .) . not
13:50:56 <lambdabot>  <local>:6:23:
13:50:56 <lambdabot>      Couldn't match expected type `f (a -> Bool)'
13:50:56 <lambdabot>             ...
13:51:22 <aristid> @let ftW' = dropWhile . (not .)
13:51:23 <lambdabot>  Defined.
13:51:24 <dafis> @let ftW' = (dropWhile .) . (not .)
13:51:25 <lambdabot>  <local>:7:0:
13:51:25 <lambdabot>      Multiple declarations of `L.ftW''
13:51:26 <lambdabot>      Declared at: <local...
13:51:41 <dafis> @undef ftW'
13:52:22 <dafis> :t ftW'
13:52:23 <lambdabot> Not in scope: `ftW''
13:53:27 <dafis> > let ftW' = (dropWhile .) . (not .) in ftW' (== 10) [1 .. 20]
13:53:28 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:53:28 <lambdabot>         against inferred ...
13:53:56 <dafis> > let ftW' = dropWhile . (not .) in ftW' (== 10) [1 .. 20]
13:53:57 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20]
13:55:52 <aristid> oh i meant takeWhile
13:56:18 <aristid> > let ftW' = takeWhile . (not .) in ftW' (== 10) [1 .. 20]
13:56:19 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:57:58 <ryanakca> dafis: Hmmm... The order for the parameters for the function taken by foldr seems to be the opposite for foldl, or am I mistaken?
13:58:06 <dons> yes, that's right
13:58:10 <dons> so you don't mix them up :)
13:58:42 <lispy> thankfully the types can help you sort it out
13:59:05 <ryanakca> dons: Makes me more likely to mix them up :)
13:59:10 <ryanakca> Thanks
14:00:40 <alexyk> why is it, in ghc, if I :l a few files, define some values, then :m +SomeModules, I get the previous values not in scope?
14:00:44 <alexyk> in ghci
14:00:44 <lispy> dons: Does the current yi still use hs-plugins?
14:12:32 <Philonous> ghci segfaults after a few seconds when I call into gtk2hs, but the same program runs fine when compiled. Is this a know issue?
14:14:10 <dons> lispy: i'm not sure. i don't  think so. i think it  uses its own loader now.
14:14:38 <dons> Philonous: is it multi-threaded?
14:14:42 <dons> dcoutts_: ^^^
14:17:31 <Philonous> dons: How do I know whether ghci is multi-threaded?
14:18:27 <Philonous> dons: Oh, you meant the program, no, it's single-threaded
14:19:33 <nwolf> anyone nows how can i concatenate some bytes? say, [0x00,0x00,0x01,0x00] to 0x00000100
14:19:37 <nwolf> *knows
14:19:40 <nwolf> let w32 = 0x00000100 :: Word32
14:20:00 <FunctorSalad_> left shift?
14:20:07 <Zao> nwolf: shift and or.
14:20:07 <Twey> An' fold
14:20:49 <nwolf> those are in Data.Bits right?
14:20:52 <Twey> Heh… left shift and or, also known as multiply and sum
14:21:16 <Philonous> dons: In fact, even the "hello world" example from the gtk2hs site shows this behavior. It runs fine for a couple of seconds and than it crashes
14:22:41 <Lycurgus> is there yet a forked off haskell aggregation that emphasizes reliability (which I presume HP doesn't)?
14:22:50 <Twey> > flip showHex "" . sum . zipWith (*) (iterate (* 2) 1) $ reverse [0x00, 0x00, 0x01, 0x00]
14:22:52 <lambdabot>   "2"
14:23:09 <Twey> Oh, bytes, right.  Well, same idea.
14:23:28 <aristid> :t showHex
14:23:29 <lambdabot> forall a. (Integral a) => a -> String -> String
14:23:30 <Twey> > flip showHex "" . sum . zipWith (*) (iterate (* 256) 1) $ reverse [0x00, 0x00, 0x01, 0x00]
14:23:31 <lambdabot>   "100"
14:23:37 <Twey> There we go
14:23:41 <aristid> > showHex 1 "a"
14:23:42 <lambdabot>   "1a"
14:23:58 <Twey> aristid: A lot of the ‘show’ functions take a string to append as an argument
14:24:09 <Twey> To avoid doing a costly ‘++ "str"’
14:24:22 <Twey> It's a bit of a hack
14:25:13 <aristid> Twey: hmm deep lists / trees of strings might be another good solution?
14:25:49 <nwolf> Twey: actually, the result i'm expecting is
14:25:55 <nwolf> 0x00000100 :: Word32
14:25:59 <nwolf> 256 =p
14:26:43 <Twey> nwolf: That's what you got
14:26:44 <dafis> > showHex 256 ""
14:26:45 <lambdabot>   "100"
14:26:51 <nwolf> whops
14:26:53 <Twey> > sum . zipWith (*) (iterate (* 2) 1) $ reverse [0x00, 0x00, 0x01, 0x00]
14:26:54 <nwolf> my fault
14:26:55 <lambdabot>   2
14:26:57 <nwolf> lol
14:26:58 <Twey> Ack
14:27:01 <Twey> Wrong one :þ
14:27:13 <Twey> > sum . zipWith (*) (iterate (* 256) 1) $ reverse [0x00, 0x00, 0x01, 0x00]
14:27:15 <lambdabot>   256
14:27:22 <Twey> :t sum . zipWith (*) (iterate (* 256) 1) $ reverse [0x00, 0x00, 0x01, 0x00]
14:27:23 <lambdabot> forall a. (Num a) => a
14:27:29 <Twey> Word32 works for that.
14:28:00 <dafis> Twey, I'd prefer foldl' ((+) . (*256)) 0, btw
14:28:28 <dafis> > foldl' ((+) . (*256)) 0 [0x00, 0x00, 0x01, 0x00]
14:28:29 <lambdabot>   256
14:28:34 <Twey> Yeah, nicer
14:30:12 <lispy> dons: I've made it into chpt 3.  I haven't really found much to comment on (other than the thing I mentioned earlier).  Looks great!  I'm going for a run now, hopefully I'll have more later.
14:33:01 <chrisdone> Twey: you about?
14:33:51 <nwolf> Twey and dafis: thanks a lot!!
14:38:06 <nwolf> :t foldl' ((+) . (*256)) 0 [0x00, 0x00, 0x01, 0x00]
14:38:08 <lambdabot> forall a. (Num a) => a
14:41:21 <aristid> @let b n = foldl' ((+) . (*n)) 0
14:41:22 <lambdabot>  Defined.
14:41:45 <aristid> > b 256 [0,1,1,0]
14:41:46 <lambdabot>   Ambiguous occurrence `b'
14:41:46 <lambdabot>  It could refer to either `L.b', defined at <local...
14:41:47 <ddarius> lispy: What are you reading?
14:42:10 <Twey> There are only 10 kinds of people in this world: those who understand binary, those who understand trinary, those who understand quaternary, those who understand quinary…
14:42:43 <Twey> chrisdone: Yep
14:42:50 <ddarius> There is only | kind of person in this world: those who understand unary.
14:42:54 <Codex_> twey: how about 1?
14:43:09 <Twey> Hehehe.
14:43:18 <aristid> there is only () kind of person in the world: those who write Num instances for ()
14:43:20 <Codex_> singletons exists too
14:43:39 <Twey> ‘10’ is not a valid unary string :þ
14:43:49 * dafis is a solipsist, wondering why there aren't more of us
14:47:47 <Twey> Hahaha
14:52:27 <shajen> :t (.)(.)(.)(.)
14:52:28 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
14:54:32 <dafis> shajen: lambdabot has some funky extensions, ghci will give a more digestible type for that
14:54:52 <chrisdone> Twey: you say you use some program to integrate the x clipboard with emacs's kill ring?
14:55:10 <dafis>  (.) (.) (.) (.)  :: (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
14:58:42 <Twey> chrisdone: No, it comes default with ergoemacs
14:58:59 <chrisdone> ergomacs, eh
15:00:33 <b0fh_ua> Hello! Please suggest a library for working with XML-RPC enabled remote services in haskell? I found haxr a bit cumbersome, but if that's only the options - may be there are some examples of how to use it besides http://www.haskell.org/haskellwiki/HaXR#Client ?
15:01:43 <dons> there's a few others on hackage.haskell.org
15:04:13 <Lycurgus> xml-rpc specific or just XML oriented?
15:04:22 <sshc> I'm wondering how to effeciently implement a list that expands on both ends, but never shrinks.
15:05:14 * Lycurgus had to bite his tongue not to say "don't".
15:09:48 <dafis> sshc: data Deque a = D { front :: [a]; back :: [a] } ?
15:10:28 <ddarius> (), or did you want to be able to access the elements as well?
15:12:23 <sshc> ddarius: Storage types are actually pointless if you can never access the elements.
15:12:56 <dafis> sshc:but efficient!!!1111
15:13:18 <ddarius> sshc: Indeed.
15:13:31 <ddarius> sshc: Perhaps the hidden message of my statement is that you have underspecified the problem.
15:14:19 <sshc> I don't think it's necessary to state that I need to be able to access the elements.
15:14:33 <ddarius> sshc: -How- do you need to be able to access the elements?
15:14:50 <ddarius> Randomly, sequentially, sequentially from both ends, ...
15:14:54 <dafis> sshc: not that, but in which manner you want to access them is important
15:16:07 <ddarius> Incidentally, if Haskell had a more interface oriented library () would often be a handy storage type.
15:16:34 <sshc> Oh.
15:16:57 <ddarius> (In fact, the equivalent would make a handy type in many current OO libraries if only they would consider null/unit object patterns more often.)
15:17:38 <sshc> Sequentially; I need a "pointer" that points to some position in the deque, and it can be moved by one in either direction.
15:18:59 <dafis> sshc: but you add elements (only) to the front and the back?
15:21:55 <dafis> sshc: data FList a = FL { front, rev, focus, back :: [a] }, where toList fl = front fl ++ reverse (rev fl) ++ focus fl ++ reverse (back fl)
15:23:09 <dafis> when you move the focus beyond focus or rev, you have to reverse back resp front
15:27:09 <aristid> dafis: the existence of "focus" cries out comonad? (just saying, it's probably unrelated to what you're discussing about)
15:27:45 <ddarius> aristid: If the FList can be empty then it is not a comonad.
15:29:21 <dons> well, that's the list zipper, isn't it?
15:30:18 <dons> http://hackage.haskell.org/packages/archive/xmonad/0.9.1/doc/html/src/XMonad-StackSet.html#Stack
15:31:14 <aristid> ddarius: would a non-empty list type have an obvious Comonad instance?
15:31:22 <ddarius> aristid: Yes.
15:35:01 <aristid> would it be possible to create a variant of Comonad in a way that allows empty lists to be instances of that variant? i'm thinking along the lines of extract :: w a -> Maybe a
15:36:16 <andreo> What function does this: (maybe 0 (\x->x) (Just 100))?
15:36:43 <andreo> returns default value (if Nothing) or x (Just x)
15:37:03 <burp> :t maybe
15:37:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:37:11 <burp> hm, one moment ;)
15:37:32 <andreo> i need maybe with \x -> x
15:37:40 <ddarius> aristid: You can do whatever you want.  It just wouldn't be a Comonad anymore.  (Perhaps a comonad over the Maybe Kleisli category.)
15:38:37 <aristid> andreo: maybe 0 (\x->x) is the same as maybe 0 id, which is 0 for Nothing and the value x for Just x
15:38:39 <burp> :t fromMaybe
15:38:40 <lambdabot> forall a. a -> Maybe a -> a
15:38:42 <burp> that's it
15:39:26 <andreo> burp: thx!
15:39:51 <andreo> how can find haskells functions by prototype?
15:40:03 <burp> @hoogle a -> Maybe a -> a
15:40:03 <andreo> is it possible?
15:40:03 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:40:03 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:40:03 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
15:45:25 <alexyk> dafis: ping
15:47:29 <int80_h> I ran out of memory while trying to compile haddock (during a compile of ghc 6.12.3. I have 512 mb of ram. what can I adjust to make that enough ram to compile with?
15:47:36 <int80_h> or am I just screwed ?
15:53:55 <dafis> alexyk: pong
15:54:02 <siracusa> int80_h: Have you tried to compile again? GHC somethimes crashes when compiling a lot of modules at once. Maybe you can restart, get some modules compiled and after a crash, it shouldn't recompile already compiled modules again.
15:54:47 <shapr> dons' thesis is really awesome.
15:54:54 <alexyk> dafis: seems that haskell finally works.  I left all your bangs and added some more.  Can you please review them once more to see if some are not needed, before I publish it in the shootout next week?  The tag is cafe6
15:56:04 <dafis> alexyk: Okay. Does the code work with the sample data from before, or would I need to download new data to test?
15:56:09 <shapr> ddarius: or we could go to Huntsville and join in the retro gaming night at Maker's Local 256
15:56:13 <shapr> whoops, wrong channel
15:56:32 <dafis> shapr: this is NOT the wrong channel
15:56:42 <alexyk> dafis: good point, let me prepare the new samples, as I interned the SyteStrings into Ints.
15:56:46 <dafis> perhaps you sent the wrong message :)
15:57:02 <aristid> can i tell ghci to print out complex expressions a bit nicer?
15:57:11 <dafis> alexyk: estimated time of upload?
15:57:17 <shapr> dafis: Hey, this channel is about Haskell from what I've heard.
15:57:21 <shapr> dafis: Do you write Haskell?
15:57:32 <shapr> I've heard it's a cool language.
15:57:41 <dafis> shapr: it is
15:57:49 <dafis> the Koolest
15:57:58 <shapr> dafis: Have you written anything nifty in Haskell?
15:58:05 <alexyk> dafis: in 10 minutes
15:58:13 <dafis> shapr: define nifty
15:58:28 <shapr> dafis: um, really cool?
15:58:29 <dafis> alexyk: okiedokie
15:58:57 <dafis> shapr: depends on what you find really cool
15:59:19 <shapr> I like running code.
15:59:57 <dafis> shapr: can you be a bit more specific?
16:00:08 <ddarius> dafis: Just name something you've written.
16:00:12 <shapr> dafis: Anything that actually accomplishes its goals, that's code I like.
16:01:21 <shapr> I'd like to try some web development with Haskell.
16:01:29 <dafis> shapr: I've solved a lot of Project Euler problems in Haskell, some of them I find cool
16:01:38 <shapr> dafis: Oh, that's nifty.
16:01:46 <dafis> shapr: I know nothing about web development
16:01:55 <shapr> dafis: I know too much.
16:02:32 <alexyk> dafis: done, the new samples are in data/sample/{dreps,dments}100K.int.hsb.zip.  The tag is cafe6 on the branch mapfold
16:02:37 <mreh> is there a haskell "lamp-stack" yet?
16:03:19 <shapr> Well, there's Linux, HAppS, MACID and Haskell.
16:03:31 <mreh> sweet
16:03:56 <aristid> and snap
16:04:16 <shapr> happstack is the most recent incarnation of HAppS, and I think it still has the in-memory database as its primary db source.
16:04:17 <mreh> is this an American thing? "snap"
16:05:07 <shapr> MACID in HAppS transparently handles the concurrency and marshalling features of apache+mysql.
16:05:14 <ddarius> dons: Was your Monte Carlo code generation stuff ever available publically?
16:05:18 <ClaudiusMaximus> my current haskell program turns a list of appropriately named source_-_sink.mpeg files into an dvdauthor.xml file for playing the mpeg graph at pseudorandom
16:05:49 <mreh> I'd never have thought to use pseudorandom like that
16:06:00 <ddarius> ClaudiusMaximus: You were the reaction-diffusion guy, right?
16:06:00 <pastorn> ClaudiusMaximus: sounds markov chain-ish...
16:06:24 <ClaudiusMaximus> ddarius: i've done some stuff with that yes, not the only one though
16:06:42 <ClaudiusMaximus> pastorn: i guess, but there's only one level of history
16:08:25 <ddarius> shapr: I was thinking about thinking about what an EDSL for CRUD-like applications would look like.
16:09:00 <dafis> alexyk: got them, will start looking
16:09:08 <aristid> mreh: snap? http://snapframework.com
16:09:17 <aristid> mreh: i'm not american, i should add.
16:10:54 <aristid> mreh: so if i say "snap", it is not an american thing either way :P
16:11:31 <dons> ddarius: pretty sure, yes. check the paper.
16:11:35 <mauke> oh snap
16:12:01 <dons> shapr: thanks, your comments were very helpful.
16:12:04 * ddarius highly suspects that American is still a minority in the Haskell community even if we count imports.
16:12:28 <shapr> dons: yay! Anything specific I can do?
16:12:34 <aristid> ddarius: why?
16:12:48 <shapr> Your thesis did motivate me to install Yi.
16:12:51 <dons> at  this point, i just need to read the whole thing over a few more times.
16:12:55 <dons> shapr: makes me excited too :)
16:13:07 <dons> also to get a unified hs-plugins 2.0 out supporting bytecode and native code
16:13:09 <ddarius> aristid: That has been my impression and I'm quite sure was the case for at least the first few years of me being a part of the Haskell community.
16:13:10 <shapr> I'd forgotten how much Yi is awesome!
16:13:22 <dons> we built a lot of cool things in the mid decade before hackage.
16:13:30 <dons> and jyp has done awesome things with yi since then.
16:13:31 <shapr> Yeah, now we have tools to build more!
16:14:15 <shapr> dons: Would type tables be accessible to TH inside --make ?
16:14:23 <shapr> Eh, I should stop distracting you from your thesis :-)
16:14:27 <dons> hehe
16:14:34 <dons> 2 days to go. so many words to read
16:14:42 * shapr goes back to writing Python for money
16:14:48 <dons> and then i reward myself with lots of code and paper writing.
16:14:59 <shapr> Yay!
16:15:04 * ddarius is writing Java and not getting paid especially for it.
16:15:11 <shapr> You'll be DR. dons!
16:15:39 <dons> hehe
16:15:41 <ddarius> "Dr. Dons brand elixir for all your Haskell ailments"
16:16:25 <dons> including snake bite!
16:16:37 <ddarius> dons: Just what shapr needs!
16:16:49 <aristid> shapr: i saw a topic on haskell-cafe about how it's difficult to work for non-haskell jobs after having seen the light :D
16:17:13 <ddarius> aristid: Program C#.
16:17:45 <wavewave> aristid: indeed. 
16:18:05 <aristid> ddarius: NOOOO
16:18:29 <aristid> well actually i get paid for programming in C and gmake. and not well either.
16:19:04 <wavewave> and temptation to refactoring my old programs constantly.... 
16:19:25 <ddarius> aristid: If you've never programmed in C#, it's way better than you probably expect, though it could definitely be improved.  However, it seems like various improvements will actually be made sooner or later.
16:19:41 <aristid> ddarius: it's better than java?
16:19:54 <ddarius> aristid: WAY better than Java.
16:20:04 <aristid> well that's easy
16:20:13 <aristid> :D
16:20:22 <ddarius> The very first version of C# was probably only slightly better than Java, but every version afterwards has been quite a bit better and increasing the gap steadily.
16:21:01 <ddarius> aristid: The lambda notation in C# is actually slightly shorter than Haskell's.
16:21:14 <aristid> shorter than \ ->?
16:21:18 <ddarius> Yes.
16:21:22 <aristid> oO
16:21:22 <ddarius> \x -> x v. x => x
16:21:38 <aristid> is that the c# lambda notation?
16:21:41 <ddarius> Yes.
16:21:48 <ddarius> At least, the shortest form.
16:22:25 <aristid> ddarius: \x -> x is shorter?
16:22:49 <ddarius> Shorter than x => x ?
16:22:51 <mauke> aristid: no, why?
16:23:00 <aristid> oh the v. was the versus
16:23:06 <aristid> i thought it was part of the syntax
16:23:52 <ddarius> aristid: There are a few Haskell people behind C# such as Erik Meijer.
16:24:10 <aristid> ddarius: the influence of microsoft research?
16:24:30 <ddarius> Perhaps, but Erik Meijer isn't part of Microsoft Research, he is part of the product division.
16:24:37 <endeavour_> There is F# too of course :)
16:26:28 <ddarius> We'll probably see de facto guaranteed tail call optimization in C# in the not distant future and I suspect improved local type inference.
16:27:52 <aristid> ddarius: i still can't say that C# would ever be the language of choice for me.
16:28:25 <wavewave> yesterday, I watched interesting interview video of Simon PJ and Joe Amstrong on Haskell and Erlang. 
16:28:43 <drk-sd> wavewave: is this video anywhere online ?
16:28:44 <endeavour_> F# is getting pretty popular
16:29:00 <endeavour_> at least in finance
16:29:05 <ddarius> aristid: Same here, but I do think it is the nicest mainstream language currently available and is a reasonably respectable language period.
16:29:08 <wavewave> http://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell
16:29:21 <wavewave> drk-sd: the above link. 
16:29:41 <wavewave> it's quite funny. 
16:29:57 <drk-sd> thank you :)
16:30:57 <ddarius> wavewave: Yes.  A much better setup than the "radio show" thing Simon Peyton Jones was on a bit before that.
16:32:01 <wavewave> just recalled the video since Erik Meijer was mentioned here. :)
16:40:43 <bhagirath> hi there
16:40:51 <bhagirath> whats this channel about
16:41:44 <endeavour_> erm, haskell?
16:41:51 <endeavour_> clue is in the name really :)
16:43:04 <monochrom> and the topic line
16:46:34 <shapr> aristid: It's all too true.
16:46:37 <aristid> hmm spj says that haskell is mainly an ideas factory, but it really does seem to become more popular itself
16:48:56 <alexyk> what is this called in Haskell:         call_some v f = case v of Nothing -> id | Just v -> f v
16:49:06 <aristid> function
16:49:13 <alexyk> aristid: warmer
16:49:15 <ddarius> :t fromMaybe
16:49:16 <lambdabot> forall a. a -> Maybe a -> a
16:49:17 <ddarius> :t maybe
16:49:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:50:06 <alexyk> so maybe?
16:50:13 <ddarius> Maybe.
16:50:35 <ddarius> Your example strikes me as a type error, if you meant v instead of id, then it would be fromMaybe.
16:50:45 <magicman> :t \v f -> case v of {Nothing -> id; Just v -> f v}
16:50:46 <lambdabot> forall t a. Maybe t -> (t -> a -> a) -> a -> a
16:50:56 <alexyk> ddarius: it's a working example :)
16:51:06 <ddarius> call_some v f = fromMaybe id f v
16:51:14 <ddarius> :t fromMaybe id f v
16:51:14 <alexyk> it is then applied like this: x' = call_some (addMaps ins) x
16:51:15 <lambdabot>     No instance for (SimpleReflect.FromExpr (Maybe (Expr -> Expr)))
16:51:15 <lambdabot>       arising from a use of `f' at <interactive>:1:13
16:51:15 <lambdabot>     Possible fix:
16:51:23 <ddarius> :t \v f -> fromMaybe id f v
16:51:25 <lambdabot> forall a. a -> Maybe (a -> a) -> a
16:51:26 <dons> fmap
16:51:33 <magicman> Looks like "maybe" with arguments flipped around, and a function as result-type.
16:51:34 <alexyk> sorry: call_some x (addMaps ins)
16:51:51 <dons> > fmap (^2) [Just 7, Nothing, Just 4]
16:51:53 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
16:51:53 <lambdabot>    arising from a use of...
16:52:04 <dons> > map (fmap (^2)) [Just 7, Nothing, Just 4]
16:52:05 <lambdabot>   [Just 49,Nothing,Just 16]
16:52:31 <ClaudiusMaximus> the shadowing of 'v' makes it confusing
16:52:35 <dons> alexyk: is that what you're trying to do? just apply 'f' only on Justs? 'Maybe' is a Functor, so you can use fmap.
16:52:37 <alexyk> x' = call_some x (addMaps ins) -- if x is Nothing, x' = x, if Just theX, AddMaps ins theX
16:52:41 <Dashkal> Trying to wrap my head around laziness.  Context: I'm writing a simplified haskell-like language as a DSL.  Ok, when evaluating let, should I wrap the value the variable is defined in in the thunk then evaluate the in clause?  let v = 1 in v
16:53:02 <kniu> I found myself in need of the ability to pass a type into a function.
16:53:13 <alexyk> dons: it's a single argument which is a Maybe
16:53:23 <magicman> alexyk: that's fromMaybe
16:53:31 <kniu> do I really have to create a whole typeclass to do this?
16:53:38 <magicman> > (fromMaybe (+1) Nothing, fromMaybe (+1) (Just 2))
16:53:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:53:39 <lambdabot>    arising from a use of `...
16:53:41 <dons> alexyk: fmap (addMaps ins) x
16:54:07 <kniu> can't I just say something like (f :: * -> Int -> Int)?
16:54:23 <dons> there's a kind in your type
16:54:28 <kniu> aye.
16:54:31 <dons> :)
16:54:34 <alexyk> dons: thx, will check
16:54:35 <ddarius> kniu: Types are already implicitly passed to polymorphic functions.
16:54:51 <ddarius> kniu: Since there is no "typecase"  I don't know what you expect to be able to do with such a function.
16:54:53 <dons> alexyk: fmap uses a sensible notion to apply functions to all sorts of container types.
16:54:57 <magicman> Hrm, not quite fromMaybe, but not quite fmap either.
16:55:27 <kniu> it involves the Read typeclass and type annotation.
16:55:42 <monochrom> not sure why you would «let v=1 in v» but «let v=big_thing in (v,v)» for example can ensure that big_thing is done at most once.
16:55:44 <ddarius> kniu: Maybe you want lexically scoped type variables.
16:55:54 <magicman> So yeah. A fmap followed by a fromMaybe, I guess.
16:56:24 <kniu> stupidRead :: Read a => * -> String -> a
16:56:33 <ddarius> :t maybe id f
16:56:34 <kniu> stupidRead t s = read s :: t
16:56:34 <lambdabot> forall a a1. (Show a1, Show a, SimpleReflect.FromExpr a) => Maybe a1 -> a -> a
16:56:42 <ddarius> :t  maybe id
16:56:43 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
16:57:00 <aristid> kniu: stupidRead uses DT?
16:57:12 <kniu> what's DT?
16:58:00 <monochrom> implementableStupidRead :: Read a => a -> String -> a; implementableStupidRead example s = read s `asTypeOf` example
16:58:05 <monochrom> @type asTypeOf
16:58:07 <lambdabot> forall a. a -> a -> a
16:58:14 <ClaudiusMaximus> > let stupidRead t s = read s `asTypeOf` t in stupidRead (undefined::Int) "42"
16:58:15 <lambdabot>   42
16:58:39 <ddarius> monochrom: easierStupidRead = read
16:59:16 <monochrom> easiest = undefined
16:59:40 <alexyk> dons: is yours: fmap (f y) x <=> maybe y (f y) x -- ?
16:59:45 <alexyk> in this case
17:00:14 <ktzqbp> Hey guys, if I'm using a function in a "do" generator that returns a [(Char, String)] (singleton), how do I refer to the Char alone? At the moment, I have "x <- item" but that pulls the entire singleton list...
17:00:18 <kniu> hm
17:00:20 <magicman> > (fmap (+1) Nothing, fmap (+1) (Just 2))
17:00:21 <lambdabot>   (Nothing,Just 3)
17:00:24 <ddarius> alexyk: Every function that consumes a Maybe can be written in the form: maybe n j for appropriate n and j.
17:00:47 <dons> ?src Maybe fmap
17:00:48 <lambdabot> fmap _ Nothing       = Nothing
17:00:48 <lambdabot> fmap f (Just a)      = Just (f a)
17:00:49 <ddarius> alexyk: Doing that to your function produces: call_some = maybe id.
17:00:52 <Berengal> ktzqbp: [(x,_)] <- item
17:01:04 <ClaudiusMaximus> :t fmap (join . fmap (Just . (+1))) [Nothing, Just 2, Nohing]
17:01:05 <lambdabot> Not in scope: data constructor `Nohing'
17:01:09 <ddarius> Well, + flip
17:01:09 <ClaudiusMaximus> > fmap (join . fmap (Just . (+1))) [Nothing, Just 2, Nohing]
17:01:11 <lambdabot>   Not in scope: data constructor `Nohing'
17:01:22 <ClaudiusMaximus> > fmap (join . fmap (Just . (+1))) [Nothing, Just 2, Nothing]
17:01:23 <ddarius> :t flip (maybe id)
17:01:24 <lambdabot>   [Nothing,Just 3,Nothing]
17:01:24 <lambdabot> forall a a1. Maybe a1 -> (a1 -> a -> a) -> a -> a
17:02:34 <alexyk> dons: but I don't need a Maybe as a result
17:03:11 <dons> ?src fromMaybe
17:03:12 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
17:03:33 <dons> so after the fmap, apply fromMaybe (or use a catMaybes to filter out any Nothing)
17:03:34 <kniu> @hoogle asTypeOf
17:03:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
17:03:37 <dons> ?src catMaybes
17:03:38 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:03:44 <dons> catMaybes [Just 2, Nothing, Just 3]
17:03:47 <dons> >. catMaybes [Just 2, Nothing, Just 3]
17:03:49 <dons> > catMaybes [Just 2, Nothing, Just 3]
17:03:50 <lambdabot>   [2,3]
17:03:51 <ddarius> dons: His function is exactly, flip (maybe id)
17:03:59 <dons> > catMaybes . fmap (^2) $ [Just 2, Nothing, Just 3]
17:04:01 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
17:04:01 <lambdabot>    arising from a use of...
17:04:04 <dons> > catMaybes . map fmap (^2) $ [Just 2, Nothing, Just 3]
17:04:06 <lambdabot>   The section `GHC.Real.^ 2' takes one argument,
17:04:06 <lambdabot>  but its type `[a -> b]' has...
17:04:08 <dons> sigh you get it.
17:04:19 <dons> ddarius: yeah, but i really think there should be an fmap :)
17:04:25 <dons> and maybe id is odd
17:04:36 <dons> > catMaybes . map (fmap (^2)) $ [Just 2, Nothing, Just 3]
17:04:38 <ktzqbp> Berengal: hmm, now it's prompting an even stranger error (I'm going through the "Programming in Haskell" book by Graham Hutton). Could you take a look for me? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26588
17:04:38 <lambdabot>   [4,9]
17:04:40 <ddarius> dons: Well the "odd" thing is his function explicitly returns a function.
17:04:59 <dons> which seems unlikely for a high performance IntMap thingie...
17:05:05 <dons> or an interesting idea, anyway
17:05:08 <ddarius> call_some v f x = case v of Nothing -> x; Just v' -> f v' x
17:05:19 <ddarius> (although this recalculates more than his version)
17:05:39 <ktzqbp> Berengal: It's the p' function that is causing the error. p works, and I'm trying to get p' to work like p using "do".
17:06:20 <Berengal> ktzqbp: Ah, your "item" isn't a singleton list, it's a parser. You should be able to just do 'x <- item'
17:06:46 <ddarius> call_some v f x = maybe x (flip f x) v
17:07:08 <ddarius> @pl \v f x -> maybe x (flip f x) v
17:07:09 <lambdabot> flip (flip . ap maybe . flip)
17:07:12 <Berengal> ktzqbp: But use return, not return'
17:07:44 <Berengal> No, wait
17:07:50 <Berengal> Lack of newtypes is confusing me
17:07:57 <alexyk> ddarius: so flip?
17:08:13 <alexyk> call_some v f x = maybe x (flip f x) v <-- this one?
17:08:16 <ddarius> alexyk: As I have said, flip (maybe id) is exactly your original call_some.
17:08:33 <ddarius> alexyk: That version will recalculate more than you probably want.
17:08:51 <ddarius> alexyk: Your original version or the flip (maybe id) one won't.
17:08:58 <Berengal> ktzqbp: It works just fine as it is if you import Control.Monad.Reader
17:09:00 <alexyk> ok
17:09:21 <ddarius> (or will the flip do it?)
17:09:26 <Berengal> Because it needs the monad instance for ((->) a) for do-notation to work
17:09:42 <Berengal> Alternative, you could write the instance yourself
17:09:47 <ddarius> No, the flip is fine.
17:10:38 <ddarius> In general, case m of Nothing -> n; Just x -> j x <=> maybe n j m
17:10:39 <magicman> With it being about a parser, I doubt you want the ((->) a) instance, though.
17:12:11 <kniu> :t lift
17:12:12 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:13:44 <mreh> does MonadSplit mean I can do RandomMonad things in parallel nicely?
17:13:51 <ktzqbp> Berengal: OK, great, having imported Control.Monad.Reader, it's compiling now. But "parse p "abcdef"" == [(('a','c'),"def")] and "parse p' "abcdef"" == [(('a','a'),"abcdef")]... Do you know why?
17:14:28 <mreh> where's Cale when you need him?
17:14:40 <ktzqbp> Berengal: this is with the same file I put on hpaste, just the "import Control.Monad.Reader" stuck at the top
17:14:57 <Berengal> ktzqbp: Well, yes, that's because the monad instance of ((->) a) has different implementations of return and andThen than yours
17:15:06 <Berengal> Which is understandable enough
17:15:15 <ktzqbp> I guess
17:15:30 <ktzqbp> But how would I get p' to do what p does?
17:15:58 <ddarius> The monoid instance of (->) getting changed really jacked up some of my older code and confused the heck out of me.
17:16:02 <Berengal> ktzqbp: I made you a newtype: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26588#a26589
17:16:08 <ddarius> I just thought I was on crack when I wrote the older code.
17:16:19 <Berengal> ddarius: It changed? When?
17:17:00 <ddarius> Berengal: It used to be the Endo instance, then they changed it to the current instance.  Unfortunately, code using the old version will type check and very likely successfully run with the new instance.
17:17:05 <ddarius> Berengal: This was a few years ago.
17:17:27 <ddarius> I was using mconcat for concatenating ShowSs.
17:17:47 <Berengal> Ah. I like the new instance better
17:18:08 <ddarius> Berengal: I don't disagree with the change.
17:20:35 <ktzqbp> Berengal: Ah, thankyou -- that works fine for me, however I'm yet to climb the Monad mountain so I don't really understand what you've done there. I suppose I'll move on and take a second look at those changes when I'm further into the book :)
17:23:12 <Berengal> ktzqbp: All I did was make parser a new type instead of just a type synonym, then declared a Monad instance for it using the functions you already wrote. (Using the type synonym would be bad, because it would clash with the monad instance for functions)
17:39:30 <ret-2-lib> hohohoho.
17:41:50 <kamatsu> hm
17:42:04 <kamatsu> developing bindings for any large C library is really alot harder in haskell than most other languages
17:42:26 <kamatsu> i have one thing that is made up of 870 function definitions, writing bindings, even in hsc2hs, would be a nightmare
17:43:36 <ddarius> kamatsu: That's what things like c2hs are for.
17:43:52 <ddarius> and greencard
17:43:59 <alexyk> how do we check that a string ends with a given suffix?
17:44:27 <ddarius> @hoogle isSuffixOf
17:44:27 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
17:44:27 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
17:44:27 <lambdabot> Data.ByteString.Char8 isSuffixOf :: ByteString -> ByteString -> Bool
17:44:45 <ddarius> The list one will not be the most efficient thing in the world.
17:45:12 <benmachine> what is the most efficient thing in the world?
17:45:27 <dons> something other than the list one.
17:45:44 <benmachine> touché
17:45:45 <And[y]> bashing your head against a wall till you die? 8o
17:45:50 <aristid> benmachine: () is the most efficient type in the world
17:45:51 <And[y]> i call that efficiency 8o
17:46:08 <alexyk> ddarius: what about for regular String?
17:46:12 <benmachine> aristid: noted
17:46:14 <alexyk> some List one I guess?
17:46:24 <alexyk> (handling command line args)
17:46:33 <kamatsu> ddarius: I thought hsc2hs superceded c2hs?
17:46:39 <kamatsu> ddarius: or are they orthogonal projects?
17:46:57 <benmachine> alexyk: is this about getting extensions from files? because there's a whole other set of functions for that
17:47:26 <alexyk> benmachine: yessir
17:47:29 <benmachine> @hoogle splitExtension
17:47:30 <lambdabot> System.FilePath.Posix splitExtension :: FilePath -> (String, String)
17:47:30 <lambdabot> System.FilePath.Windows splitExtension :: FilePath -> (String, String)
17:47:30 <lambdabot> System.FilePath.Posix splitExtensions :: FilePath -> (FilePath, String)
17:47:44 <ret-2-lib> hmm
17:47:52 <alexyk> benmachine: except my extensions can look like ".hsb.zip"
17:47:59 <benmachine> alexyk: I recommend :browse System.FilePath
17:48:22 <benmachine> alexyk: uhm, so what?
17:48:39 <alexyk> benmachine: my prefix can contain a dot :)
17:49:00 <alexyk> i.e. I check on a hard suffix
17:49:16 <alexyk> so List.isSuffixOf will do I guess
17:49:24 <benmachine> suit yourself
17:49:44 <ret-2-lib> import Control.Monad f n|n `mod` 15 == 0 = "FizzBuzz" | n `mod` 3 == 0 = "Fizz" | n `mod` 5 == 0 = "Buzz" | overthwise = show n main = mapM_(putStrLn.f)[1 .. 100] << should've learned haskell a while ago
17:49:45 <benmachine> but note that both takeExtension and takeExtensions exist
17:49:57 <alexyk> benmachine: ah!
17:50:15 <kamatsu> hm, i might try using HaskellDirect
17:50:39 <benmachine> takeExtensions sadly doesn't give you a list
17:50:49 <alexyk> indeed
17:51:10 <alexyk> I need, from "x.y.z.zip", check that it ends with "z.zip"
17:51:38 <dmead> ?hoogle suffix
17:51:38 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
17:51:39 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
17:51:39 <lambdabot> Data.ByteString.Char8 isSuffixOf :: ByteString -> ByteString -> Bool
17:51:44 <dmead> second one
17:52:24 <alexyk> HaskellDirect sounds like telemarketing pyramid :)
17:52:42 <alexyk> "find 3 Haskell followers and sell them this monad.  You get 30%!"
17:53:11 <kamatsu> hehe
17:53:19 <kamatsu> oh, the project appears dead
17:53:23 <kamatsu> hopefully it still builds
17:53:33 <aristid> @remember alexyk "find 3 Haskell followers and sell them this monad.  You get 30%!"
17:53:33 <lambdabot> Okay.
17:53:36 <kamatsu> oh, the file is missing :(
17:53:41 <aristid> @quote sell.monad
17:53:41 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
17:53:44 <aristid> hmm
17:53:56 <aristid> how can i search with gaps?
17:54:06 <kniu> @hoogle liftIO
17:54:06 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:54:15 <benmachine> kamatsu: p.s. bindings-dsl, when I discovered it, made my FFI binding about 200 billion times easier
17:54:35 <benmachine> @quote sell.*monad
17:54:35 <lambdabot> alexyk says: "find 3 Haskell followers and sell them this monad.  You get 30%!"
17:54:56 <benmachine> good ol' regex
17:57:16 <aristid> oh it's a regex
17:57:27 <aristid> i somehow thought it was a function composition :D
18:06:34 <alexyk> how do I import module X only to refer to all names in it qualified as X.x?
18:07:15 <alexyk> if I omit the import altogether I can't refer to X.x at all
18:08:47 <c_wraith> import qualified X
18:17:27 <kamatsu> hm
18:17:46 <kamatsu> perhaps it would be a better idea to call haskell from C rather than C from haskell? how feasible is this?
18:18:10 <kamatsu> alternatively i could just write a small domain-specific library that maps to the gigantic library in C and FFI into that.
18:21:45 <alexyk> c_wraith: thx
18:29:29 <forrest> so I finally wrote a haskell program to split a large binary file, and when I run it on the real 38Gb file, it runs out of memory
18:29:41 <forrest> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26592
18:30:39 <forrest> am I doing something which is holding on to memory?
18:34:35 <c_wraith> calling L.length contents causes the entire file to be read into memory
18:34:44 <c_wraith> hence the explosion
18:34:52 <ddarius> Yes, in the if partlength >= L.length contents
18:35:34 <ddarius> forrest: Just break the parts and check if the remainder is ever empty.
18:35:59 <forrest> ddarius: ok, i'll try to make that work. thanks!
18:36:00 <dons> GHC.Int should be Data.Int, btw.
18:36:02 <arw_> or, if you want to do more planning, use the value you get from getFileStatus
18:36:14 <arw_> the system knows how big the file is anyways
18:36:26 <dons> yeah, just feed that through.
18:36:29 <arw_> (and without O(n))
18:37:07 <forrest> arw_: I thought of that, but just checking for empty sounds simpler
19:01:37 <forrest> well, I changed writeParts, and still run out of memory (although much more slowly this time)
19:02:00 <forrest> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26592#a26593
19:03:40 <forrest> wrote 2.5G of the first part before running out -- I expect each part to be close to 4G
19:04:28 <c_wraith> I don't think the answer is as simple this time.
19:04:57 <c_wraith> I think it's sadly much more complicated, and due to the nature of lazy bytestrings not *really* being appropriate for this job.
19:06:15 <dons> mmm?
19:06:29 <forrest> hmm, in the description for Data.ByteString.Lazy it says "For data larger than the available memory, or if you have tight memory constraints, this module will be the only option."
19:06:50 <dons> yes, lazy bytestrings are great for streaming chunks of data like this.
19:06:57 <dons> that's what they're designed for.
19:07:01 <ddarius> forrest: Post your current code.
19:07:08 <ryanakca> I'm rewriting groupBy with foldl. I've tried running through this by hand in ghci and it worked. However, when I stick it into a foldl, it fails. What am I doing wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26594#a26594
19:07:14 <c_wraith> This isn't *quite* a data streaming problem, the way the code is written
19:08:39 <forrest> ddarius: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26592#a26595
19:09:33 <forrest> i'm pretty sure I only changed writeParts, as I already posted, but I reposted the whole thing just in case I munged something else
19:10:03 <forrest> oh, and i'm running this with runhaskell btw -- i got a link error when trying to compile it
19:10:37 <dons> ghc -O2 --make Foo.hs
19:10:41 <dons> you forgot --make I bet.
19:11:09 <forrest> dons: you are correct
19:11:13 <dons> ghc should parse those undefined symbol errors and suggest --make
19:11:35 <forrest> didn't see that in the output, but i might have missed it
19:11:53 <c_wraith> heh, should as "should be changed to"
19:12:00 <c_wraith> Not as "should be doing it already"
19:12:00 <ddarius> forrest: Yeah, running it compiled will probably help.
19:12:17 <forrest> ok, i will try that
19:12:18 <dons> :)
19:13:03 <ddarius> The problem is probably that something (one of the contents most likely) isn't viewed as being unreferenced early enough.
19:14:33 <forrest> running the compiled version, and memory usage is increasing monotonically -- already at 55%
19:14:42 <forrest> this will not end well
19:15:43 <dons> you're retaining a reference to all the input somewhere.
19:15:58 <dons> or else, possibly, have a space leak associated with inappropriate laziness.
19:16:03 <forrest> and, it died in about the same place
19:16:06 <dons> should be trivial to fix, with ddarius' help.
19:16:12 <dons> eh ddarius ? :)
19:17:04 <c_wraith> assuming writeParts is tail-call optimized, it shouldn't be hanging on to old versions of contents.
19:17:21 <c_wraith> I think the problem is hanging on to the *current* version of contents
19:17:29 <ddarius> c_wraith: Yes.
19:17:38 <tommd> What is the URL for that page that runs GHCi with a slick javascript front?
19:17:38 <c_wraith> for the entirety of writing out the current chunk
19:18:08 <ddarius> I'm not quite sure how to tell GHC its free (the equivalent to foobar = null in Java), but I just now thought of shadowing the definition.
19:18:18 <ddarius> That still might not work.
19:18:49 <dons> tommd: tryhaskell.org
19:18:53 <c_wraith> I'm actually suspicious of L.split
19:19:04 <ddarius> c_wraith: I am too, though I suspect it is good.
19:19:32 <ddarius> Really, I'm not a fan of lazy IO for these kinds of problems, but for a first pass the code does seem like it should work.
19:19:56 <dons> well, run -prof -auto-all and do some retainer profiling.
19:21:48 <forrest> dons: are those switches to my compiled executable?
19:22:23 <c_wraith> No, those are switches to ghc
19:22:37 <dons> this program is small enough it shouldn't be necessary
19:22:48 <dons> unless you're confounded by the exectution model :)
19:24:52 <forrest> err, i'm going to have to go, guys
19:25:11 <forrest> should I be submitting a bug report somewhere?
19:26:20 <c_wraith> I don't think there's anything broken in bytestring.  I just agree with ddarius that lazy IO isn't ideal for this kind of problem.
19:28:18 <forrest> ok, I will try using Data.ByteString next
19:28:37 <forrest> got to go now, thanks for the assistance
19:37:12 <max_atreides> i hope forrest knows about 'split' unix utility
19:41:46 * hackagebot graph-utils 0.3.5.2 - A simple wrapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.5.2 (HiromiIshii)
19:47:17 <dons> huh
19:48:49 <alexyk> a shortcut for isJust x || isJust y ?
19:51:07 <dons> pattern matching is better, quite possibly
19:51:11 <dons> avoid isJust if you can.
19:51:19 <dons> f (Just n) (Just m) = ...
19:51:21 <dons> f _ _ = ...
19:51:41 <dons> case (x,y) of Just n, Just m -> ... ; _ -> ...
19:51:50 <dons> but otherwise, isJust || is fine.
19:51:52 <dons> as you did.
19:54:15 <jimmyjazz14>  have two packages which I am trying to get to work together one used mtl the other monads-fd, seem like they are not compatible for this reason
19:54:15 <monochrom> :t maybe
19:54:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:54:29 <jimmyjazz14> anyone come across this before
19:55:16 <monochrom> :t fromMaybe False (x `mplus` y >> return True)
19:55:17 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `Expr'
19:55:18 <lambdabot>     In the first argument of `mplus', namely `x'
19:55:18 <lambdabot>     In the first argument of `(>>)', namely `x `mplus` y'
19:55:22 <monochrom> :t fromMaybe
19:55:24 <lambdabot> forall a. a -> Maybe a -> a
19:55:30 <monochrom> :t \x y -> fromMaybe False (x `mplus` y >> return True)
19:55:32 <lambdabot> forall a. Maybe a -> Maybe a -> Bool
19:55:51 <monochrom> :t (\x y -> fromMaybe False (x `mplus` y >> return True)) (Just ()) (Nothing)
19:55:52 <lambdabot> Bool
19:55:55 <monochrom> > (\x y -> fromMaybe False (x `mplus` y >> return True)) (Just ()) (Nothing)
19:55:56 <lambdabot>   True
19:56:07 <monochrom> > (\x y -> fromMaybe False (x `mplus` y >> return True)) (Nothing) (Just ())
19:56:08 <lambdabot>   True
19:56:13 <monochrom> > (\x y -> fromMaybe False (x `mplus` y >> return True)) (Nothing) (Nothing)
19:56:14 <lambdabot>   False
19:58:30 <clanehin> I'm trying to figure out what the best practices are for the new Control.Par....Strategies.  Why isn't NFData just changed to be the new kind of Strategy?
19:58:41 <clanehin> Requires a code change anyway, so . . .
20:24:16 <clanehin> oh, I get it, rnf is always sequential anyway, so it doesn't affect anything.
20:29:27 <dons> rdeepseq replaces rnf in the new lib.
20:33:45 <ddarius> Incidentally, changing the let ... = splitAt to a case fixes the program.
20:34:04 <ddarius> And I'm assuming liveness in core corresponds to scoping of lets.
20:35:33 <ddarius> @tell forrest Your code can be fixed by changing the let (toWrite, theRest) = L.splitAt ... into a case L.splitAt ... of (toWrite, theRest) 
20:35:33 <lambdabot> Consider it noted.
20:36:11 <Axman6> ddarius: what's that change achieve?
20:37:48 <ddarius> Axman6: It changes a let to a case in the core which means the tuple and its contents aren't allocated to the heap.
20:38:29 <Axman6> thought so, thought i'd check though :)
20:38:34 <ddarius> The end result is a program that on my machine uses about 0.3% of memory at a constant seeming rate v. a program that steadily rises by several meg at a fairly quick rate.
20:38:50 <Axman6> is case generallt a good alternative to let if you know you'll need the value?
20:39:10 <Axman6> y*
20:39:43 <dons> laziness bites again.
20:39:53 <ddarius> I usually use where and neither case nor let.
20:40:13 <ddarius> Axman6: case is a bit more strict than let, but you should check the core.  Most lets will become cases anyway.
20:41:43 <ddarius> dons: I wouldn't say it's exactly laziness that was the problem.  Certainly writeParts being strict would very likely have led GHC to optimize that case into a let, but the real issue is the hard to determine range of liveness of variables.
20:42:13 <ddarius> switch case and let
20:45:30 <ddarius> (I likely would have responded much earlier if hitting my disk hard wasn't so crippling to my system.)
20:46:40 <dons> yes, liveness is somewhat hard to visualize.
20:47:18 <ddarius> Well, I'm not so sure I wanted to say "determine" rather than "control".  Liveness roughly corresponds to scoping.
20:47:30 <ddarius> (At least as a safe approximation.)
20:48:16 <ddarius> Unfortunately, that approximation is overly conservative in this case and it isn't completely obvious how to better scope things to make that approximation work.
20:49:05 <ddarius> (Well, liveness corresponds to scoping as long as the variable does not escape.)
20:49:27 <ddarius> (Which I guess is a -lot- more common and subtle in a lazy language.)
20:49:58 <ddarius> At any rate, we need rules of thumb and/or static tools for this.
20:51:12 <edwardk> hrmm is there a cheezy way to quickly check if a thunk is evaluated?
20:51:21 <ddarius> @hoogle isBottom
20:51:21 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
20:51:29 <ddarius> @hoogle isEvaluated
20:51:29 <lambdabot> No results found
20:51:37 <ddarius> There is some function that can be used.
20:51:43 <edwardk> hrmm
20:51:53 <ddarius> edwardk: You can also cheat and use a little trace-like unsafePerformIO if you control the thunk.
20:51:55 <edwardk> i have started writing a little library of 'speculative foldables'
20:52:01 <edwardk> nah i don't control the thunk
20:52:21 <ddarius> edwardk: Related to that C# paper on reddit (and by "related" I mean "partially inspired by")
20:52:23 <edwardk> i have a speculative apply function that takes a guess to use while it evaluates the argument, but there is no sense applying the function to the guess if the arg is evaluated
20:52:36 <edwardk> yeah that is the general idea
20:53:03 <edwardk> spec :: Eq a => a -> (a -> b) -> a -> b -- is a more haskelly version of the spec combinator in the paper. the first arg is the guess
20:53:06 <ddarius> I'm pretty sure there is a function that does what you want.  See what Hood or Vacuum use.
20:53:19 <edwardk> vacuum seq's everything
20:53:29 <ddarius> edwardk: Well Hood doesn't.
20:54:13 <edwardk> hrmm i know very little about hood
20:54:13 <ddarius> dons: Incidentally, I suspect -prof -auto-all would not have been too helpful.
20:55:17 <edwardk> hood doesn't seem to do anything of the sort really =/
20:56:38 <edwardk> there is dataToTag# but it would i presume evaluate to get the tag
20:57:05 <alexyk> you can't do: let x = blah; x = f x ..., but you can do : do x <- blah; x <- f x ... right?
20:57:52 <edwardk> yep, dataToTag# forces the thunk
20:57:57 <ddarius> alexyk: Correct, but you shouldn't.  (And by can't the former is recursive the latter isn't.)
20:58:20 <ddarius> edwardk: unpackClosure# may be what you want
20:58:53 <alexyk> yeah.  Imperative looks good with replacement
20:59:08 <alexyk> monadic, whatever :)
20:59:45 <alexyk> my proggy is finally correct in Haskell.  whew.
21:00:45 <edwardk> unpackClosure should at least get me a reference to the thunk, but my recollection from talking to mmorrow was that it blew up in spectacular ways if the thunk wasn't evaluated already
21:02:43 <ddarius> alexyk: Shadowing variables almost always ends in heartbreak.
21:03:09 <alexyk> ddarius: ko
21:03:11 <alexyk> ok
21:03:20 <Cale> edwardk: Any idea where mmorrow has gone?
21:03:27 <alexyk> sometimes you need some, you know :)
21:03:37 <alexyk> makes you human
21:03:45 <edwardk> Cale: i haven't been in touch with him for months
21:03:55 <Cale> preflex: seen mmorrow
21:03:55 <preflex>  mmorrow was last seen on #ghc 160 days, 1 hour, 6 minutes and 9 seconds ago, saying: * mmorrow is rtfm'ing
21:04:05 <ddarius> edwardk: Did he say anything last time you were in touch with him?
21:04:12 <edwardk> ddarius: nah
21:04:56 <Cale> His presence on the web has vanished since then as well
21:05:12 <Cale> Well, not like he's taken things down, but there's no new stuff
21:05:17 <alexyk> what do people name maybes?  xM?  x_?
21:05:33 <ddarius> They, they don't ...
21:05:38 <ddarius> Cale: That doesn't bode well.
21:05:40 <Cale> I'll often stick an m into the name if I need one.
21:05:45 <Jafet> alexyk, are those people hungarian?
21:05:55 <alexyk> is there any reasonable syntactic convention?
21:05:56 <ddarius> I usually prefix if anything.
21:06:03 <alexyk> ddarius: with what?
21:06:06 <Cale> mx <- foo
21:06:06 <ddarius> m
21:06:09 <Cale> case mx of
21:06:11 <alexyk> Jafet: not really
21:06:11 <Cale>   Nothing -> ...
21:06:13 <Cale>   ...
21:06:19 <ddarius> alexyk: Also I misread what you said initially.
21:06:36 <alexyk> ddarius: how so?  I meant it seems ok to redefine in <-
21:06:44 <alexyk> meaning it works
21:06:54 <alexyk> and wondered if it's kosher
21:07:14 <ddarius> alexyk: I misread "[23:03] <alexyk> what do people name maybes?  xM?  x_?" as "why" rather than "what"
21:07:24 <alexyk> ah
21:07:32 <alexyk> so redefining is still unkosher
21:07:37 <ddarius> alexyk: Yes, that works, but it's usually a bad idea no matter how good an idea it seems at the time.
21:07:48 <alexyk> ddarius: I believe you :)
21:14:02 <alexyk> is there a sprintf?
21:14:32 <ddarius> alexyk: Yes.  printf
21:14:36 <alexyk> kk
21:15:27 <ddarius> @hoogle printf
21:15:27 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
21:15:27 <lambdabot> module Text.Printf
21:15:27 <lambdabot> Text.Printf class PrintfArg a
21:15:43 <Jafet> where sprintf = printf; printf = putStr.sprintf
21:15:54 <ddarius> Jafet: No.
21:16:01 <ddarius> Where sprintf = printf and printf = printf
21:16:07 <Cale> printf is polymorphic, so you can use its result as an IO action, and it's printf, and you can use its result as a String, and it's sprintf :)
21:16:42 <Jafet> :t printf
21:16:43 <lambdabot> forall r. (PrintfType r) => String -> r
21:17:04 <Jafet> I sense magic
21:17:28 <Axman6> > printf "int: %d" 1 :: String
21:17:29 <lambdabot>   "int: 1"
21:17:32 <ddarius> It's all Haskell 98 (or at least could be Haskell 98)
21:17:38 <Axman6> > printf "int: %d" 1 :: IO ()
21:17:39 <lambdabot>   <IO ()>
21:22:25 <alexyk> why isn't there IntMap.mapKeys?
21:22:57 <alexyk> or, rather, how do I map an IntMap to an ordinary Map in keys only?
21:23:36 <dons> keysSet :: IntMap a -> IntSet.IntSet ?
21:23:49 <dons> you just want the keys of the map?
21:24:01 <dons> or 'keys' itself, which returns a list.
21:25:09 <Axman6> seems IntMap a -> IntSet would be quite handy
21:25:13 <alexyk> dons: no, I need to mapKeys: create, from IntMap a, a Map ByteString a with dictionary, disinterning the results.  Map has mapKeys, IntMap doesn't
21:25:39 <dons> ah interesting. you should add it!
21:25:45 <dons> probably a similar implementation.
21:26:14 <alexyk> dons: the thing is, IntMap only returns the IntMap results, and on Ord Map doesn't fit there?
21:27:15 <alexyk> for now I'll fold of course
21:28:39 <dons> take notes of the things you missed, and we can implement them later.
21:28:47 <dons> if you have a page of 'things i wish i could do' that would be great.
21:32:17 <edwardk> ddarius: still no luck
21:32:52 <alexyk> dons: there will be all of it on my haskell adoption blog eventually :)
21:32:57 <alexyk> after the victory is achieved
21:34:24 <dons> :)
21:34:28 <dons> excellent.
21:38:06 <ddarius> edwardk: You can probably construct something with unsafeCoerce and loose morals.
21:38:36 <alexyk> hmm: sc: internal error: get_threaded_info
21:38:36 <alexyk>     (GHC version 6.13.20100625 for x86_64_unknown_linux)
21:38:37 <alexyk>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
21:38:39 <edwardk> ddarius: i've been trying =)
21:38:47 <edwardk> oooh i think i have an idea
21:39:16 <dons> yikes!
21:39:30 <dons> alexyk: that's something interesting.
21:39:49 <alexyk> dons: same proggy, different run
21:39:54 <alexyk> near teh very end
21:40:10 <alexyk> will run again
21:40:19 <dons> yes, see if it is deterministic.
21:45:21 <alexyk> I was capping with -M50G, and it might not like it.  Was -M60G before
21:47:03 <dons> well, the -M flag should always catch this stuff.
21:47:20 <dons> so it might be minor, but still a good thing to fix.
21:47:28 * dons thinks alexyk's job is interesting.
21:47:50 <alexyk> it is
21:47:56 <dons> me, i just get to hack haskell, and write about it, all day. BORING! :}
21:48:13 <alexyk> dons: at least you have your language fixed :)
21:48:16 <dons> hehe
21:49:00 <alexyk> I'm in research where math models are kings, and the general tool is MATLAB, and the attitude is (1) I don't care how you program it, as long as there're results, or (2) my students use something
21:49:25 <dons> hehe. scientific programming ftw!
21:49:35 <dons> being comp. sci. guy in science town is fun.
21:49:40 <dons> (i did that for a while)
21:50:16 <Jafet> (It shows)
21:50:38 <alexyk> but, of course, the NLP folks appreciate languages, and generally now there's an understanding that tools make a difference...  in social media Twitter paved the way with Scala and put it on the map, and now FP is hot everywhere, so Haskell IPO is near.  :)
21:51:11 <alexyk> dons: Aussie scientists are known for their cavalry attacks on the tree of knowledge :)
21:51:19 <alexyk> using advanced hacking tools
21:51:22 <dons> hehe oh my.
21:51:24 <Jafet> We'll need a flash website before we can IPO
21:51:41 <alexyk> Jafet: you mean HTML5
21:51:48 <alexyk> to be seen on the iPhone
22:00:16 <edwardk> ddarius: i managed to concoct something
22:00:54 <ddarius> edwardk: Code?
22:01:11 <ddarius> edwardk: I'm looking at the RTS source and it looks like you can get a flag that tells you exactly what you want.
22:03:02 <edwardk> ddarius: http://gist.github.com/454651
22:04:11 <dons> wow. acm digital library found the right citation for "phantom type"
22:04:23 <edwardk> http://gist.github.com/454654 is slightly cleaner with all the debugging stuff i was using gone
22:04:41 <edwardk> ddarius if you load that with ghci Test.hs -fobject-code you can get the right answers for test1..4
22:04:57 <edwardk> if you load it without, pointer tagging isn't used and it conservatively says False for everything
22:06:18 <edwardk> i can now use that in Control.Parallel.Speculation.spec to check to see if the argument is already evaluated and so to avoid computing the speculated application
22:06:27 <dons> oh my. really?
22:06:53 <dons> oh, i guess that works. now we need an RNF bit...
22:07:13 <edwardk> dons: so i don't have to lie when given too many constructors?
22:07:28 <dons> well, to make deepseq free when it is already done.
22:07:34 <edwardk> yeah
22:07:47 <dons> making it more tempting to just sprinkle it around when debugging 100k line server apps before a demo
22:09:05 <edwardk> hrmm i suppose you could make a hacky observable RNF a type. that has its NFData instance update a private MVar that says its been reduced to normal form, and skips it if its set
22:09:53 <dons> yikes.
22:10:04 <edwardk> data RNFOnce a = RNF (MVar ()) a -- instance NFData a => NFData (RNFOnce a) where rnf = ...
22:10:06 <dons> per-value mvar for rnf'ness.
22:10:10 <dons> yup
22:10:15 <dons> tricky! :)
22:10:27 <edwardk> that should be perfectly safe and portable
22:10:57 <edwardk> just make sure to seq the rnf of its contents before the setting of the mvar
22:11:37 <dons> strict mvars ftw.
22:11:38 <Saizan> easy to get false negatives though
22:12:02 <edwardk> Saizan: thats ok, a false negative is just that you don't know. once the mvar gets tripped you'll know
22:12:55 <edwardk> yay now my speculation code can be a lot faster
22:13:19 <alexyk> so you can't bang lambda params?  \!x -> ... --?
22:13:31 <Saizan> maybe you need a space?
22:13:38 <edwardk> \! looks like an operator
22:13:43 <alexyk> ah!
22:13:48 <Axman6> \ !x?
22:13:51 <alexyk> banging always requires msome space
22:13:57 <Axman6> wtf is that, perl?
22:14:14 <alexyk> worse
22:14:19 <alexyk> perl has no monkey ops
22:14:45 <alexyk> dons: now it disrespected -M cap and went into swap
22:16:02 <Axman6> dons: do you have any idea how parallel programs in haskell perform when using hyperthreading? should i use -N4 with two HT CPU's?
22:17:54 <dons> alexyk: huh
22:18:09 <dons> Axman6: prob. -N2 ... 
22:18:22 <dons> though i can't recall specific evidence.
22:18:40 <alexyk> dons: I think -M is not working on my proggy, so I'll tell Simon about it
22:19:05 <alexyk> and he can administer it a proper English punishment
22:19:15 <alexyk> for not listening to its master
22:19:21 <Axman6> huh, ok. the OS treats them as 4 distinct cores, so i thought -N4 would be more useful. might have to do some testing
22:19:28 <edwardk> hrmm given an Ix, is there any fast way to split the range? I can't think of one. i'm trying to write a speculative foldMap over arrays, which should decompose it by splitting it into halves and guessing values for each half as it pieces it back together.
22:19:31 <dons> yes, he will be a tough task master.
22:19:48 <edwardk> i guess i can just use unsafe indexing and ignore the index
22:26:24 <dons> shapr reads fast.
22:28:34 <Dashkal> :r
22:29:05 <Axman6> Modules loaded: None
22:30:27 <Dashkal> :r
22:30:29 <Dashkal> bleh
22:31:04 <om-foxy> what size are Floats on a 32 bit machine?
22:31:57 <Axman6> should be 32 bit
22:31:59 <Jafet> Which 32-bit machine? (Ominous orchestra here)
22:33:34 <om-foxy> I have a 64 bit machine and am loading a 200MB file with data compressed to 24bits.  When I naively load the file and convert to Doubles, (size 8 bytes), the data becomes too large for my measly 1G memory.  Bleuch :(
22:33:51 <alexyk> if, in main, I want to have an if, do I have to have do on then/else branches: x <- blahl if cond then do ... else do ... -- ?
22:34:34 <Jafet> om-foxy, there's no type called Doubles
22:34:47 <om-foxy> Jafet: 'Double's
22:34:54 <Jafet> You may be better off with a strict unboxed array of Double, though
22:35:23 <om-foxy> Jafet: I'm using Data.Packed.Vector from hmatrix
22:35:31 <Saizan> alexyk: yes
22:35:36 <c_wraith> alexyk, the types need to fit together.  remember that a do block has type Monad m => m a.  But that's your only real restriction
22:35:56 <BMeph> alexyk: If your then/else clause consists of more than one expression, maybe, but it wouldn't be wrong. :)
22:36:02 <Saizan> alexyk: that is, if you want to use do-notation inside them
22:36:03 <Jafet> om-foxy, no idea then. Especially since we haven't seen code
22:36:44 <om-foxy> Jafet: :)
22:37:03 <alexyk> Saizan: I get a syntax error on else: http://paste.pocoo.org/show/230509/ -- ?
22:37:05 <Saizan> om-foxy: what do you mean by "data compressed to 24bits"? 
22:37:09 <BMeph> alexyk: Presumably, since you have "x <- blahl" then you lalready have a "do" preceeding it all, otherwise, things could get...messy. ;)
22:37:34 <Saizan> alexyk: indent it more than if
22:37:56 <Jafet> "I use that worthless WAV format"
22:38:06 <BMeph> alexyk: Your error on "else" is bexause you need to indent else farther in than the "if".
22:38:24 <alexyk> ah, ok
22:38:28 <BMeph> alexyk: Both "then" and "else" are subordinate to the "if".
22:38:34 <Saizan> http://paste.pocoo.org/show/230510/ <- i'd go with this
22:38:48 <alexyk> ok
22:40:24 <Dashkal> :r
22:40:33 <Dashkal> Must read window before reloading ghci
22:40:48 <c_wraith> who knows.  maybe some of us needed to be reloaded.
22:41:02 <BMeph> I like http://paste.pocoo.org/show/230511/ but I have bizarre taste... ;)
22:41:25 <Saizan> BMeph: heh, indeed
22:41:38 * BMeph encourages all trolls to keep trolling, while he reloads... >;)
22:41:54 <Saizan> in the "i'd prefer that too" sense 
22:43:21 <alexyk> BMeph: it was a bug, I save dcaps in then, compute and save dcaps' in else... so your unindented has different semantics -- but shows you can converge after an if in a do, horrors!  almost like Pascal!
22:43:47 <alexyk> there's no going back after an if in FP.  Even OCaml can't do that
22:44:09 <alexyk> unless I'm utterly confused and that unindent doesn't resume the flow
22:45:08 <alexyk> how to kill your box with haskell: ssh ... Operation timed out ... ssh ... Connection refused ... ssh ... uptime 5 min
22:45:12 <Saizan> alexyk: (if .. then .. else ..) >> rest
22:45:17 <c_wraith> You're not desugaring properly
22:45:24 <Jafet> It's more on-form to make misguided comparisons to C here, rather than Pascal.
22:45:29 <c_wraith> Saizan posted correct desugaring
22:45:32 <Saizan> if/then/else produces an IO action like any other expression there
22:45:41 <alexyk> Jafet: C has no then
22:45:55 <alexyk> or does it?  I forgot
22:46:12 <c_wraith> it has {, which serves the same purpose, for if blocks. :)
22:46:16 <alexyk> exactly
22:46:32 <edwardk> ddarius: a slightly simpler version: http://gist.github.com/454654
22:46:39 * alexyk did years of C and C++ before bein born agaoin as a monad
22:46:47 <c_wraith> actually, I guess ) serves the same purpose. { is only needed if there are multiple statements.
22:47:09 <alexyk> c_wraith: spirit of Kernighan and Ritchie is "then"
22:47:51 <Dashkal> That's a new one.  "Contexts differ in length" and telling me to turn on RelaxedPolyRec
22:47:56 <alexyk> a giant box takes 20 min to die and reboot each time Haskell kills it
22:48:53 <alexyk> the smart people who provisioned it decided to give a 64 GB RAM box just 20 GB of swap, as they were loath to waste expensive fast disks on swap
22:49:20 <Saizan> Dashkal: mutually recursive functions had some arbitrary restrictions in h98, RelaxedPolyRec lifts those resulting in saner compiler behaviour
22:49:21 <alexyk> I have to stop it all and make it at least 100 GB of swap I guess to play more Haskell
22:50:01 * Saizan tends to kill everything that hits swap
22:50:05 <Dashkal> Saizan: ok good.  I was trying to figure out if it was indicating design smell
22:50:12 <Saizan> but i never used machines like those :)
22:50:17 <Dashkal> I'm doing some ... interesting tricks in that code.
22:51:20 <ddarius> edwardk: If you can correctly get the info table pointer and then correctly get the offset to the type field, the fifth bit of it (mask 0x10) determines whether something is a thunk or not.
22:51:48 <edwardk> ddarius: yeah i tried that first with unpackClosure
22:51:54 <alexyk> Saizan: yeah, I guess Haskell's swap coherence is not good.  Gotta see how can I make Linux put a process out of its misery if it hits swap, selectively
22:52:24 <edwardk> but that requires a lot of fiddly bits and that looks like it'll slide around alot from ghc version to version or with different compilation options
22:52:26 <alexyk> edwardk: every time I see unpackClosure, I want to tar jxf clojure.tar.bz2
22:52:36 <edwardk> =)
22:53:22 <edwardk> trying to figure out the right type signature for a speculative foldMap
22:53:30 <edwardk> right now, what i have is a basic spec
22:53:38 <edwardk> spec :: Eq a => a -> (a -> b) -> a -> b
22:53:50 <ddarius> Well an alternative, and what I was originally aiming for, is to get some RTS function via the FFI.
22:54:12 <edwardk> which tries to run the function with its guessed argument, while the real argument is being evaluated, then runs it with the right argument if i guessed wrong.
22:54:26 <edwardk> it skips the parallel execution if the real argument has already been evaluated
22:54:43 <edwardk> then I added a Speculative class that looks like Foldable
22:55:04 <edwardk> with specFoldr, etc. where specFoldr :: (Int -> b) -> (a -> b -> b) -> b -> f a -> b
22:55:16 <edwardk> er Eq b => 
22:55:34 <edwardk> specFoldr guesses the answer to the entire tail of the foldr and then uses spec with that guess
22:56:35 <edwardk> specFoldMap should take a pair of Int, indicating the subrange of the input being requested, but sadly, that requires two passes on many data structures
22:57:13 <edwardk> specFoldMap :: (Monoid m, Eq m) => (Int -> Int -> m) -> f m -> m
22:58:12 <edwardk> another option is to make the guess a little harder to compute: specFoldMap :: (Monoid m, Eq m) => (Maybe Int -> Maybe Int -> m) -> f m -> m
23:02:36 <dmead> hi edward
23:02:43 <edwardk> heya dmead
23:02:59 <dmead> can you link me to your paper from michicigan?
23:03:05 <dmead> i just finished auditing linear alg
23:03:06 <edwardk> which paper?
23:03:15 <dmead> projective spaces i think
23:03:17 <edwardk> oh the plucker coordinate one?
23:03:28 <edwardk> http://comonad.com/thesis.pdf
23:03:32 <dmead> you walked me through some of it
23:03:33 <dmead> yea
23:04:22 <dmead> spanks
23:05:44 <dmead> i'm trying to do stereoscopic vision this year
23:05:50 <dmead> so i'll need some projective spaces 
23:05:52 <dmead> etc
23:05:59 <edwardk> fun
23:06:58 <edwardk> i keep meaning to do more research into the use of automatic differentiation in computer vision. With both jeffrey mark siskind and dan piponi playing around with that tool in that space, it says to me there is something interesting there.
23:07:27 <dmead> it's quite useful i think
23:07:45 <dmead> i'm trying to set up everything as a linear system, so i can throw it at graphics hardware and such
23:07:54 <dmead> but sometimes you just need calculus 
23:09:04 * ddarius uses calculus even when he doesn't need it.
23:15:52 <dancor> so (map head . group . sort) is faster than (sort . nub)?
23:16:32 <c_wraith> nub is necessarily O(n^2).
23:16:42 <dancor> right.
23:17:17 <c_wraith> if there was only one distinct element in the list, sort . nub is faster, though
23:17:43 <c_wraith> the worst case is better on the former, the best case is better on the latter.
23:17:43 <BMeph> With the right optimization, map head . group may even skip a cons? :)
23:18:36 <dancor> best case is the worst case to think about optimizing :)
23:18:50 <c_wraith> really, you should be looking at your expected case.
23:19:03 <c_wraith> nub is actually O( n * distinct elements)
23:19:39 <c_wraith> if you expect distinct elements to be sublinear, that's a case work considering.
23:20:12 <dancor> that's a good distinction
23:21:09 * ddarius expects it to be quite rare for the number of distinct elements to be asymptotically sublinear unless you are doing the nub "just in case."
23:21:53 <BMeph> edwardk: I faintly recall someone saying something about emulating a uniqueness type with a comonad. Does that sound familiar to you?
23:22:04 <c_wraith> I agree.  But if you're making a choice between two algorithms, it's worth examing how they work on the data set you expect, just in case it's a funny situation. :)
23:22:34 <Jafet> log n sublinear isn't very expectable
23:22:50 <c_wraith> It's a list of an enumeration type, it is. :)
23:22:59 <c_wraith> err *if* it's a list...
23:23:11 <Jafet> Well, Word64 is also an instance of Enum
23:23:20 <c_wraith> heh.  good point. :)
23:23:25 <Jafet> Next episode: attack of the constants
23:24:06 <edwardk> BMeph: not exactly. i believe what i said was that a lot of interesting properties like uniqueness are comonads, if you view their types as a category. i.e. the (!) modality in linear logic that allows unrestricted contraction and weaking is a comonad
23:24:14 <edwardk> BMeph: but it isn't a haskell comonad.
23:24:26 <edwardk> in that sense uniqueness is also comonadic
23:26:03 <ddarius> edwardk: What is the tag for an Int?
23:26:11 <ddarius> (in WHNF)
23:26:12 <edwardk> 1
23:26:18 <edwardk> it only has one constructor
23:26:19 <ddarius> Okay.  That's what I thought.
23:26:43 <BMeph> edwardk: Hmm...dang, now I can't remember if I read it from that argument, or someone else (e.g., sigfpe)...stupid wetware...
23:26:44 <edwardk> wheras Integer has two
23:27:11 <edwardk> BMeph: well, like i said, it is a comonad, just not one in Hask
23:27:30 <ddarius> BMeph: Other people have said similar things, but what you originally said doesn't make a lot of sense so I suspect it is from something like edwardk described as well.
23:27:42 <ddarius> It's come up in discussions about comonoids.
23:29:36 <edwardk> wadler talks about (!) being a comonad (in passing) in http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.4622
23:30:09 <alexyk> if something is in a patch status, when does it make it into the trunk?  e.g. http://hackage.haskell.org/trac/ghc/ticket/2362?
23:30:29 * BMeph has noticed ddarius noting "what you originally said doesn't make a lot of sense" a lot lately, and being impressed that ddarius can make _any_ sense out of him...
23:32:52 <ddarius> The typical way to add modalities to a categorical semantics is to assert that there is a comonad structure over the monoidal(ly closed) category.
23:33:50 <ddarius> There's a natural comonad structure that comes up in topos theory.  I wonder what it looks like from this perspective.
23:36:07 <BMeph> alexyk: According to the ticket, "Milestone:  	 6.14.1" 
23:36:55 <alexyk> BMeph: right; but does it make it into trunk before that?  are milestones branched off that?
23:41:50 <dancor> @pl pullMaybeFromSnd (a, Just b) = Just (a, b)
23:41:51 <lambdabot> (line 1, column 30):
23:41:51 <lambdabot> unexpected "="
23:41:51 <lambdabot> expecting variable, "(", operator or end of input
23:42:26 <ddarius> That's called strength usually.
23:42:58 <dancor> ddarius: that function is often reinvented and called (strength)?
23:43:10 <ddarius> :t \(a, m) -> fmap ((,) a) m
23:43:11 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
23:43:40 <ddarius> curry pullMaybeFromSnd = fmap . (,) 
23:46:27 <ddarius> Incidentially, (,) is the unit of the adjunction defining cartesian closedness.
23:49:19 <dancor> ok: functorFromSnd = uncurry (fmap . (,))
23:50:48 <dancor> or functionRunSnd
23:52:30 * hackagebot GeomPredicates-SSE 0.2 - Geometric predicates (Intel SSE)  http://hackage.haskell.org/package/GeomPredicates-SSE-0.2 (NealAlexander)
23:54:31 * hackagebot GeomPredicates 0.1 - Geometric predicates  http://hackage.haskell.org/package/GeomPredicates-0.1 (NealAlexander)
