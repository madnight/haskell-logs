00:00:12 <napping> just have a proper rule from hands back to a list of card ranks, and check that they match (and enforce conditions like the two pairs being distinct)
00:02:03 <kamatsu> ah
00:02:12 <kamatsu> figured out horde3d's c api, this will be tolerable
00:02:17 <kamatsu> i'll write bindings and put them on hackage
00:08:46 <dskippy> napping: Here's a problem. I can't easily have Card derive Ord because bother pieces Rank and Suit need to derive Ord. Suit should all be equal in ordering. How can I tell it this?
00:09:04 <dskippy> napping: I suppose create my own instance of Ord for Suit. No easier way?
00:09:44 <pastorn> dskippy: instance Ord Suit where compare _ _ = EQ
00:10:01 <dskippy> pastorn: That's what I have.
00:10:42 <pastorn> oh, do you have data Card = Card Rank Suit?
00:10:53 <dskippy> I do.
00:11:11 <kmc> data Card = Card { rank :: Rank, suit :: Suit }; instance Ord Card where compare = comparing rank
00:11:15 <napping> that would work, or Ord Card where compare (Card r1 _) (Card r2 _) = compare r1 r2
00:11:23 <pastorn> instance Ord Card where compare c0 c1 = (compare `on` rank) c0 c1
00:11:36 <pastorn> dskippy: rank :
00:11:44 <Axman6> comparing f = compare `on` f
00:11:46 <pastorn> dskippy: rank :: Card -> Rank
00:12:21 <kamatsu> hey, when creating foreign bindings to C
00:12:27 <kamatsu> if i have a newtype wrapper around an int
00:12:43 <kamatsu> can i just declare the foreign import to use the newtype wrapper? they're represented the same internally, right?
00:12:47 <sizzler> lets say I have a data Fruit = Fruit String, how do I use the state monad to build a [Fruit] so I can keep adding Fruit and it retails the state
00:13:00 <pastorn> kamatsu: unsafeCoerce :)
00:13:02 <kmc> kamatsu, yes
00:13:18 <kamatsu> pastorn: right, i'm asking if that's needed
00:13:31 <kmc> "The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes" -- GHC manual
00:13:36 <kamatsu> ah
00:13:37 <kamatsu> sweet :D
00:13:42 <sizzler> ~retains
00:13:44 <kmc> it cites §3.2 of the FFI addendum, but i can't find it there
00:13:58 <kamatsu> sizzler: do you need the state monad or just the writer monad?
00:14:02 <cheater99> FFI?
00:14:04 <cheater99> what is FFI?
00:14:08 <dskippy> I like "instance Ord Card where compare = compare `on` rank" This doesn't require Suit to be of type class Ord, which is just wrong.
00:14:10 <kamatsu> cheater99: Foreign Function Interface
00:14:11 <kmc> foreign function interface
00:14:17 <pastorn> @type let fruit s = s in modify (fruit "banana" :)
00:14:18 <lambdabot> forall (m :: * -> *). (MonadState [[Char]] m) => m ()
00:14:22 <cheater99> is that part of the haskell report?
00:14:28 <kmc> why not use «comparing» instead  of «(compare `on`)»
00:14:29 <kamatsu> cheater99: it's part of haskell 2010
00:14:33 <kmc> cheater99, it's an addendum
00:14:34 <cheater99> ok
00:14:36 <kmc> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:14:37 <pastorn> sizzler: that might not be showing exactly what you wanted...
00:14:37 <Cale> cheater99: Yeah, it's an addendum to the H98 report
00:14:39 <cheater99> thanks
00:14:44 <dskippy> kmc: What is this comparing stuff?
00:14:49 <kmc> @hoogle comparing
00:14:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:14:57 <pastorn> sizzler: does your state *only* consist of [Fruit]?
00:15:02 <Saizan> why use comparing when you can use compare `on` ?
00:15:04 <kmc> to learn how to use it, http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html cheater99
00:15:24 <kamatsu> ahaha, horde3d is such a portable API
00:15:29 <kamatsu> everything is an int!
00:15:50 <pastorn> kamatsu: even the floats?
00:16:03 <kamatsu> well, no
00:16:09 <cheater99> thanks, very useful
00:16:20 <dskippy> compare on and compairing seem like the same thing.
00:16:22 <kamatsu> well, technically if it's IEEE32 and you ignore C's pathetic excuse for a type system, the floats are ints.
00:16:26 <kmc> dskippy, indeed they are
00:16:27 <cheater99> is haskell 2010 just addenda on top of 98, or is it a whole new report?
00:16:36 <kmc> cheater99, it will eventually be a new report
00:16:38 <kmc> not yet written
00:16:46 <cheater99> what's the timeframe?
00:16:50 <kmc> dunno
00:16:51 <kamatsu> 2010
00:16:54 <kmc> before Haskell 2011 comes out? ;)
00:17:00 <cheater99> ok :)
00:17:03 <dskippy> kmc: I like compare `on`. I'm used to `on`
00:17:11 <kmc> dskippy, ok
00:17:24 <sizzler> paston, I might have something like data Fridge = Fridge [Fruits] [Drinks] and want to maintain state of fridge, but I guess if I know how to maintain state for [Fruit] I can then maintain a Fridge?
00:17:41 <cheater99> i have a question
00:17:44 <kmc> ok
00:17:54 <cheater99> is the glasgow compiler performance-oriented?
00:17:58 <kmc> yes
00:18:10 <kmc> quite a lot of effort goes into making GHC produce fast code
00:18:22 <kmc> and it does quite well on the shootout
00:18:26 <kmc> http://shootout.alioth.debian.org/
00:18:28 <cheater99> how do you find out if a certain function is only a provisionary implementation (new part of the standard) or if it's pretty-well-optimized?
00:18:40 <kmc> first, you profile your code to find out whether you care
00:18:58 <kmc> and what GHC supports is quite a bit more than what's in Haskell 2010
00:19:02 <kmc> and has been for a long time
00:19:07 <kmc> much longer than Haskell 2010 has existed
00:19:22 <kmc> Haskell 2010 codifies a few, very conservative extensions to Haskell 98 that have been in common use for years
00:19:31 <sizzler> pastorn does that make sense?
00:19:32 <cheater99> yeah ok
00:19:42 <cheater99> but still
00:19:45 <kmc> it doesn't go nearly as far as we really need, which is why Haskell' is an ongoing process with a new spec every year
00:19:50 <cheater99> i bet there are things in ghc that aren't optimized yet
00:19:55 <kmc> yeah
00:19:56 <kmc> plenty
00:20:02 <cheater99> how do i find out which?
00:20:07 <kmc> by profiling your code
00:20:17 <kmc> or by reading the source and documentation
00:20:28 <cheater99> yes, but what if i wouldn't like to build my application around something that's really really slow in comparison to what it should be?
00:20:55 <cheater99> say there's a function i know i'll have to use
00:21:17 <cheater99> (can't think of a certain example, pick your own if you want)
00:21:18 <kmc> then you'd read the source and documentation, and ask here / on haskell-cafe / on reddit, and make a test application and profile that
00:21:26 <Saizan> i think there's anything like that in the standard libs, unless you use the wrong data-structure for your task
00:21:29 <cheater99> aha
00:21:33 <cheater99> ok.
00:21:35 <kmc> i think this is the same as any other language
00:21:40 <Saizan> *don't think
00:21:54 <kmc> "wrong structure for the task" can be very subtle, though
00:22:06 <kmc> earlier we were discussing cases where Map beats IntMap by a factor of 2
00:22:56 <kmc> cheater99, often you can make the implementation of some performance-critical function a parameter or otherwise modular
00:23:19 <kmc> this is nice because you can start with the short idiomatic naive obviously-correct solution
00:23:23 <kmc> and profile
00:23:35 <kmc> and if it matters, replace it with something faster
00:23:45 <kmc> and use the old one as reference implementation for automated test cases
00:23:57 <kmc> this extends down into C via FFI
00:23:58 <c_wraith> I learned how to use quoting syntax today.  It's approximately one billion times less painful than using Language.Haskell.TH.Syntax and building up the AST by hand.
00:24:10 <kmc> c_wraith, kinda
00:24:13 <kmc> there's no pattern splices...
00:24:19 <kmc> they're in the paper, just not implemented
00:24:40 <kmc> every time i've tried to use TH (admittedly not many times) this has been a huge obstacle
00:24:46 <c_wraith> Eh.  I was just using it for expression splices.  And using arbitrarily complicated expressions.
00:24:52 <kmc> and has resulted in me writing lots of explicit AST no matter what
00:25:08 <kmc> i find TH code is about an order of magnitude harder to write than normal haskell code
00:25:10 <c_wraith> I've never wanted to splice in a pattern.  I guess something's wrong with me. :)
00:25:36 <c_wraith> I mostly just want to set constants at compile-time.
00:26:12 <pastorn> sizzler: hang on... i'll make a small paste...
00:26:35 <sizzler> ok pastorn
00:28:00 <cheater99> kmc: yeah
00:29:25 <kamatsu> i guess it's too much to ask for the FFI to automatically to/fromEnum enum types.. right?
00:29:59 <kmc> FFI tries to be simple and obvious
00:30:09 <kmc> there are wrapper-generator tools to automate more complex marshalling
00:30:23 <kamatsu> but, enums are enumerations in haskell too
00:30:29 <kamatsu> they're probably represented as an  int
00:30:50 <kamatsu> ah well, it's not that hard to marshall it
00:31:00 <wli> It was about time someone did something more intelligent than RPC.
00:31:21 <Kaidelong> what's wrong with RPC
00:32:18 <pastorn> sizzler: didn't test it, but it should work ;)
00:32:20 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26552#a26552
00:33:01 <wli> The data structure marshalling stuff in RPC was relatively ugly IMHO.
00:33:21 <Kaidelong> oh a specific RPC. I was thinking remote procedure calls in general
00:34:20 <wli> It's a standard? I think Sun inflicted it upon the world or something.
00:36:34 <Jafet> import CORBA;
00:36:34 <Kaidelong> wli: I just think of it more as a general idea of calling code in another program or on another machine
00:37:04 <Kaidelong> that's what I thought you were talking about, some abstraction that did what RPC did better
00:37:12 <Kaidelong> hence why it perked my excitement for a moment
00:37:14 <sizzler> pastorn, Thanks for the paste. inorder to use addFruit multiple times should I be doing something like addFruit banana >> addFruit apple. 
00:38:25 <pastorn> sizzler: mapM_ addFruit myBasket
00:40:20 <wli> Far from going on about anything doing what RPC did better, I was complaining about what RPC did wrong.
00:40:40 <sizzler> Pastor: k, how do I unpack the Fridge from of its state
00:42:31 <pastorn> sizzler: runState
00:42:39 <pastorn> or evalState or execState
00:43:11 <pastorn> but one of them might not give you back the state (unless your last function call is 'get')
00:43:49 <sizzler> k I will look up that.  thanks Pastorn for the fruity example.
00:43:53 <pastorn> sizzler: read the documentation for Control.Monad.State on hoogle. I think it explains it good.
00:43:55 <pastorn> *well
00:44:12 <pastorn> sizzler: don't take too much of that MeltedButter
00:45:24 <lpsmith> wli:  wasn't one specific RPC mechanism that became fairly popular the subject of one of the early IETF RFCs?   Before Sun existed?  (I'm thinking '77-'79 or something...)
00:46:08 <wli> lpsmith: I guess I thought Sun had something to do with it because they used it in the portmap etc. stuff in/around nfs.
00:46:55 <lpsmith> ahh yes,  RFC 707,  issued in 1976
00:46:56 <sizzler> pastorn I did try reading the docs besides other blog articles but was finding it difficult to put it together.  your example is simple and is quite understandable for me. dont worry I wont get drunk on the meltedbutter ;)
00:47:59 <lpsmith> Well,  NFS was built off of RPC,  I don't know if it was RFC 707 compatible or not.   But Sun did try to follow relevant standards
00:48:18 <lpsmith> of course, it was much less obvious back then what standards were truly relevant and which ones weren't
00:48:50 <wli> I only remember it using the same portmapper as nfs. I don't remember enough about the docs, just the weird C data structure crud in the data structure marshalling.
00:50:59 <wli> Actually it was so long ago I don't remember much specific about that, just that it was somehow messy, ugly, or otherwise that I didn't like it.
00:51:25 <lpsmith> heh, can't blame you :)
00:51:52 <wli> It was half my life ago and I'm older than the average #haskell denizen
00:53:02 <lpsmith> same here :-/   Though I wasn't doing much terribly interesting, programming wise,  half my life ago.   That's when I got distracted by objects
00:53:39 <lpsmith> Basically they placated me, temporarily,  by the fact I couldn't return complex numbers from pascal functions.
00:55:49 <wli> Pascal? wtf. I guess I wasn't doing much meaningful back then either but I at least had the wherewithal to write something where I'm so frazzled by poverty/unemployment/stress now that I can't hardly wipe my own arse forget eking out a line of code.
00:56:03 <lpsmith> wli:  so are you still playing around with Buchberger's algorithm? :)
00:56:40 <lpsmith> Well, my father believed (and still believes, to some degree) that Pascal was the one true language,  and Turbo Pascal was pretty slick
00:56:57 <lpsmith> I hate to say that my current development environment isn't as good.
00:57:02 <wli> lpsmith: ISTR I finished what I was doing but my life and everything I own has been destroyed since then, including the computers that code was on.
00:57:48 <lpsmith> :-/
00:58:25 <lpsmith> I'm sorry to hear that,  I do hope circumstances improve for you soon
01:00:19 <wli> When you're life's over, it's over.
01:04:16 <lpsmith> Well, everybody will die sooner or later.    I would hope there is still some time to put something back together before then,  no?
01:05:54 <lpsmith> I mean,  you still have a degree,  you have programming experience,  and a few decades, I hope,  ahead of you :) 
01:06:55 <lpsmith> Honestly though,  every single one of my friends who left America after they graduated did a lot better for themselves than they otherwise would have.   Maybe that's something to consider...
01:07:28 <wli> I've talked to enough people to know that people who get stuck trying to put their lives together die of old age without succeeding.
01:08:07 <wli> lpsmith: I've been extremely interested in emigrating for a very long time. It's all over now, though.
01:08:46 <lpsmith> If I may ask, do you have a terminal disease?  Why do you think that it's over?
01:10:14 <kmc> please take this to #haskell-blah
01:10:23 <lpsmith> sorry :-/
01:11:09 <lpsmith> yes,  this should have been taken to haskell-blah some time ago
01:27:02 <dv-> irc is full of tragic characters
01:42:13 <fabjan> not enough unicode chracters though :(
01:54:47 <JyZyXEL> got a .hs script, how do i execute it?
01:55:21 <jejansse> runhaskell file.hs
01:55:24 <tensorpudding> If it has a main, you can use runhaskell
01:55:53 <tensorpudding> You can also load it with ghci and interpret it, or compile it to an executable using ghc --make
01:56:15 <JyZyXEL> oh cool runhaskell works
01:56:44 <tensorpudding> runhaskell foo.hs is the closest thing to python foo.py, ruby foo.rb or perl foo.pl
01:56:54 <Ke> or even #!/usr/bin/runhaskell  with a shebang
01:57:14 <tensorpudding> or #!/usr/bin/env runhaskell if you want to be platform-independent
01:57:41 <tensorpudding> well, slighly moreso
01:57:50 <tensorpudding> won't work well on Windows ;)
02:05:19 <old_sound> hi
02:05:25 <adu> hi
02:05:26 <ManateeLazyCat> old_sound: hi :)
02:06:03 <old_sound> does anybody know of a guide or doc on how to extend pandoc to output some xml?
02:06:19 <adu> like docbook?
02:06:29 <old_sound> is a subset of docbook
02:09:52 <solrize> :t mapM
02:09:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:09:59 <solrize> :t sequence . map
02:10:00 <lambdabot>     Couldn't match expected type `[m a]'
02:10:00 <lambdabot>            against inferred type `[a1] -> [b]'
02:10:00 <lambdabot>     Probable cause: `map' is applied to too few arguments
02:10:55 <Botje> :t (sequence .) . map
02:10:56 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
02:11:17 <Itkovian> If an app I want to benchmark using criterion reads its input from stdin ... how can I pass the arguments such that the correct input gets read when the benchmark executes??
02:11:25 <solrize> botje ;)
02:11:30 <solrize> so are those the same?
02:11:34 * hackagebot cuboid 0.14 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.14 (PedroMartins)
02:12:11 <Botje> solrize: yes. replace a with b and a1 with a
02:12:25 <solrize> i mean they're the same type, but do they have the same semantics?  
02:12:26 <ManateeLazyCat> Itkovian: runInteractiveCommand ?
02:12:40 <Botje> yes. mapM is defined like that.
02:12:50 <solrize> thanks
02:13:00 <ManateeLazyCat> @src runInteractiveCommand
02:13:00 <lambdabot> Source not found. Where did you learn to type?
02:16:51 <Itkovian> hehe
02:17:03 <Itkovian> She's helpful, is she not?
02:21:27 <Itkovian> Wish there was a putContents ;-)
02:22:36 <Jafet> There are rumours of something called hPutStr
02:23:11 <ManateeLazyCat> Itkovian: If you want send some argument to running process, use hPutStr.
02:23:37 <ManateeLazyCat> Itkovian: runInteractiveCommand return [inputHandle, outputHandle, errorHandle, processHandle]
02:23:40 <Itkovian> It's not the argument, it's the contents it would normally obtain from stdin
02:24:21 <ManateeLazyCat> Itkovian: You mean get argument when program startup?
02:24:32 <ManateeLazyCat> Itkovian: If so, you need "getArgs"
02:24:39 <ManateeLazyCat> @hoogle getArgs
02:24:39 <lambdabot> System.Environment getArgs :: IO [String]
02:25:09 <Jafet> :t getContents >>= putStr
02:25:10 <lambdabot> IO ()
02:25:21 <Jafet> (A lazy cat)
02:25:23 <Saizan> suppose i have a DAG G, and a family of sets S0, S1, .. ,Sn  of nodes of G, such that for each s \in Si if n \in G has a path to s it can't have a path to any other element of Si, how do i find out if there's a bunch of nodes (s1..sn) (with si \in Si) such that if i add another node x with paths to those the condition still holds?
02:27:15 <Itkovian> As far as I understand, criterion simply calls the function that is the entrypoint to what you wish to benchmark. However, in this case, it would be existing code, and it would be the main function. There the code has getArgs and getContents. So I am wondering how to pass that along, since I want to define the arguments (i.e., the different input sets) in the call to criterion's defaultMain. 
02:28:52 <Itkovian> Changing the code to accept arguments is one option, but I am wondering if there's a way to work around that without changing any code of the original benchmark.
02:30:49 <Saizan> i don't think there's any way to mess with stdin from within the process, unless C let you do that already
02:31:30 <Jafet> You can reopen stdin to any file.
02:32:20 <Jafet> argv is also writable, although using that as a hack around System.Environment doesn't seem sound
02:53:26 <Kaidelong> http://www.cs.pomona.edu/~kim/why.pdf
02:53:38 <Kaidelong> very encouraging paper
02:54:04 <Kaidelong> those in SIGPLAN should be aware of it already
03:17:07 <dobblego> is there a Show-like type-class where the String instance has show == id?
03:20:48 <ivanm> dobblego: not by default AFAIK
03:20:57 <ivanm> but it's possible to define such a class
03:29:51 <hants> is there a way to get the type of a subExpression in TH? i would like to compile abs(x) to float_abs or int_abs - depending on x
03:30:49 <ivanm> hants: sounds like the kind of thing you'd do in a type class
03:31:00 <ivanm> hang on, isn't abs part of Num already?
03:31:04 <ivanm> @src Num
03:31:05 <lambdabot> class  (Eq a, Show a) => Num a  where
03:31:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:31:05 <lambdabot>     negate, abs, signum     :: a -> a
03:31:05 <lambdabot>     fromInteger             :: Integer -> a
03:31:08 <ivanm> yup, it is
03:31:25 <ivanm> hants: also, writing "abs(x)" isn't very Haskell-y ;-)
03:31:34 <hants> lol
03:31:42 <hants> :)
03:31:53 <madhadron> ivanm, Now, now, if someone's already gone into Template Haskell, let us give them the benefit of the doubt.
03:32:04 <madhadron> They either really need the separate functions, or their masochists.
03:32:07 <madhadron> they're
03:32:13 <ivanm> madhadron: for what? in knowing what they're doing?
03:32:41 <madhadron> ivanm, Yes, whether it be writing insane code or suffering.
03:32:47 <ivanm> heh
03:33:52 <hants> typeOf from Data.Typeable seems bugged
03:34:12 <hants> it returns (Integer->Integer) for typeOf abs
03:34:29 <ivanm> hants: defaulting
03:34:33 <ivanm> is this in ghci?
03:34:33 <madhadron> hants, I think it tries to force typeclasses to a concrete type
03:34:40 <madhadron> and Integer is what the forcing goes to
03:34:46 <ivanm> > typeOf abs
03:34:46 <hants> damn
03:34:47 <lambdabot>   Integer -> Integer
03:34:54 <ivanm> > typeOf (abs 3.0)
03:34:55 <lambdabot>   Double
03:35:00 <danharaj> does typeable handle polymorphic functions at all?
03:35:02 <ivanm> yup, seems to be defaulting
03:35:07 <danharaj> > typeOf length
03:35:08 <lambdabot>   Ambiguous type variable `a' in the constraint:
03:35:08 <lambdabot>    `Data.Typeable.Typeable a...
03:35:11 <ivanm> hants: why are you wanting this?
03:35:16 <ivanm> danharaj: heh, obviously not
03:35:21 <madhadron> hants, If you use it in a context where something else is inferred from content, then it will go to something else besides Integer.
03:35:33 <madhadron> context, not content
03:35:37 * madhadron sighs
03:35:39 <hants> thanks :)
03:35:41 <Axman6> > typeOf const
03:35:42 <lambdabot>   Ambiguous type variable `a' in the constraint:
03:35:42 <lambdabot>    `Data.Typeable.Typeable a...
03:35:48 <madhadron> Not my day with English it appears.
03:35:56 <Axman6> > typeOf (const :: Int -> Bool -> Int)
03:35:57 <lambdabot>   Int -> Bool -> Int
03:36:43 <hants> great :)
03:36:48 <danharaj> It would be cool if it worked with polymorphic types :p
03:37:03 <hants> or at least would fail with them
03:37:17 <Axman6> > show (typeOf (const :: Int -> Bool -> Int))
03:37:18 <lambdabot>   "Int -> Bool -> Int"
03:39:15 <madhadron> Such civilized concerns.  And here I am trying to encode "void (*0)(void*)" in Scheme.
03:39:49 <Axman6> o.O
03:39:50 <hants> TH just allows sick things :)
03:41:06 <madhadron> hants, And yet the code on the far end is still ugly.  It's a great mystery.
03:41:39 <hants> ever done c++-template metaprogramming? *that* is ugly
03:41:54 <madhadron> hants, I have successfully avoided C++ completely so far.
03:42:15 <madhadron> The ugliest thing I have to lay hand to is a few lines of Perl now and again.
03:42:25 <madhadron> and by few I mean <5
03:42:30 <ivanm> hants: again, why are you wanting to do?
03:42:52 <hants> im working on a compiler for th-> cuda
03:43:25 <ivanm> do I dare ask why you want to turn TH into cuda code?
03:43:31 <ivanm> rather than Haskell code itself?
03:43:58 <hants> want to run haskell code on gpu and cpu on same time
03:44:09 <hants> so i need to compile haskell code into cuda
03:44:28 <madhadron> hants, And you're trying to do it inline?
03:44:29 * hackagebot Lastik 0.6.4 - A library for compiling programs in a variety of languages  http://hackage.haskell.org/package/Lastik-0.6.4 (TonyMorris)
03:44:34 <ivanm> yes, but that isn't TH...
03:44:44 <madhadron> That is, TH takes part of your code, turns it into CUDA, and the rest is Haskell?
03:45:24 <hants> well TH gives me the ast - and the possibility to work on the ast at compile time - and i turn that into cuda
03:46:13 <hants> but the types of subexpressions are hard to find
03:46:21 <madhadron> Okay, a really legitimate use of TH, and that's why you want float_abs instead of int_abs
03:46:45 <hants> yes in c you have fabs and abs - theyre not overloaded like +
03:48:04 <hants> is TH already part of the haskell standard - or still some "exotic extension"?
03:48:21 <madhadron> beyond exotic
03:48:33 <madhadron> It's a research project that never really got polished.
03:49:03 <hants> still its nice
03:49:16 <madhadron> Google turns up a paper called "Optimising Embedded DSLs using Template Haskell" which appears to do at least part of what you're after
03:49:52 <hants> yes already was reading parts of the pape, but no useful information so far
03:50:41 <madhadron> Unfortunately, most of what you use macros for in Lisp you can do without them in Haskell, so the tools tend not to get polished for when you really do need them.
03:51:32 <madhadron> Have you considered creating a type hierarchy describing the CUDA syntax tree
03:51:47 <madhadron> and then giving it appropriate type classes to let it work almost like normal Haskell?
03:52:19 <madhadron> For arithmetic it's straightforwards, but contorl 
03:52:24 <madhadron> control flow is not as trivial
03:53:04 <hants> yes that was the first attempt 
03:53:29 <madhadron> Then god watch over you in the dark places you must tread.  Send us a telegram with the answer.
03:54:06 <hants> cant overload "if then else" - so functions on cuda-asts are no way to go
03:54:33 <danharaj> Why do you need to overload if then else.
03:54:59 <madhadron> danharaj, If you are trying to encode an AST as Haskell values, then you need to be able to do control flow
03:55:01 <hants> because i want to let the user write usual haskell code - and translate it into cuda
03:55:33 <madhadron> hants, Have you looked at HJScript to see how they do it with JavaScript?
03:55:42 <hants> no
03:55:59 <madhadron> It's on Hackage, and they may have solved at least some of your problems.
03:57:17 <danharaj> I'm not sure I entirely understand. Are you making an EDSL that you output  to CUDA code, or are you trying to take regular Haskell code and output to CUDA?
03:57:29 <madhadron> danharaj, Regular Haskell
03:57:36 <hants> dont like the hjscript approach 
03:58:32 <madhadron> hants, For this kind of thing, MetaOCaml or one of the Lisps might be an easier route.
03:58:36 <hants> thats not regular haskell code you write in hjscript but things like function, oor .+.
03:59:27 <danharaj> I agree with madhadron, if you want to play with the actual syntax, use Lisp.
03:59:35 <madhadron> There are also the guys who wrote atom, who are compiling to C for embedded systems.  Might see what they did.
03:59:40 <hants> but i like haskell more - and the only thing thats missing is the type information for subexpressions
03:59:44 <danharaj> The idiomatic Haskell way is to embed a DSL, not try to overload Haskell code.
04:00:16 <ivanm> bluespec as well
04:00:18 <hants> well most dsls overload num and the like
04:00:28 <hants> to feel like haskell
04:00:33 <ivanm> and all the crazy meta-evaluation stuff augustss and co are doing
04:00:40 <blackh> 'accelerate' is a DSL with a CUDA and LLVM back end but it isn't finished
04:00:52 <hants> no there are no backends for accelerate
04:00:54 <ivanm> hants: though to me it sounds like you want a new backend
04:01:03 <hants> accelerate is an interpreter and a dsl which overloads num
04:01:35 <hants> but does not prohibid the user from writing (if (2*2==) then ...) which leads to errors
04:01:40 <hants> at runtime
04:02:01 <blackh> There are back ends for accelerate but they're not finished
04:02:08 <hants> not published
04:02:30 <hants> just like duke nukem forever ;)
04:03:29 <hants> ivanm, whats bluespec - do you have a link?
04:03:43 <ivanm> http://en.wikipedia.org/wiki/Bluespec,_Inc.
04:03:55 <madhadron> hants, The other thing that occurs to me is that you could use TH to override if to be polymorphic in its condition, introducing a typeclass.
04:04:03 <madhadron> Or write a cond, which can be done fairly nicely in Haskell
04:05:19 <hants> well with TH its just so much easier ;)
04:05:51 <hants> my code is about 10 lines of code - and compiles already lots of haskell to c
04:06:36 * hackagebot hstatistics 0.2.0.4 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.4 (VivianMcPhail)
04:22:40 * madhadron wonders how people can understand how to use the horrible details of C FFI and not escape their SQL strings...
04:24:09 <fasta> madhadron, is there any proof that escaping solves all problems?
04:24:50 <fasta> madhadron, the right way is to make objects which allow only certain queries to be done. 
04:25:11 <madhadron> fasta, No, but righting a SQLite binding wherein there is no escaping whatsoever seems a little questionable
04:25:12 <Itkovian>     Warning: Module `GHC.Handle' is deprecated:
04:25:13 <Itkovian>                use GHC.IO.Handle.Base instead
04:25:18 <madhadron> writing
04:25:25 <Itkovian> Yet it finds it not during compilation. GHC.IO.Handle.Base I mean
04:25:25 <fasta> madhadron, that seems to be a good idea. 
04:25:40 <fasta> madhadron, the binding is just as safe as the C API, which it is not.
04:26:06 <fasta> madhadron, on top of that other inferfaces can be build. 
04:26:10 <madhadron> fasta, The C API provides sqlite3_mprintf, which does string escaping, and which is a standard tool for dropping strings in.
04:26:14 <madhadron> The binding does not bind this function.
04:26:31 <fasta> madhadron, the binding only does what the author needed probably.
04:26:45 <fasta> madhadron, and if you design it like I said, you also don't need that function.
04:26:59 <fasta> madhadron, of course, incomplete bindings are annoying.
04:27:00 <madhadron> fasta, Which means the author wasn't sanitizing his database inputs, and from other code I've seen of his, he wasn't doing any other layer either.
04:27:11 <fasta> madhadron, you don't know that.
04:27:26 <madhadron> fasta, I don't know that for certain, but from context it seems likely.
04:27:38 <fasta> madhadron, anyway, you can do things better, if you want.
04:27:49 <madhadron> fasta, I have, actually.
04:28:04 * ksf wants -XAssumeDataTypeable
04:28:09 <fasta> madhadron, I was not implying that you could not, btw. 
04:28:14 <ksf> I don't wanna roll my own functor etc. classes.
04:28:26 <madhadron> fasta, Of course.  but there's always the issue of "can" vs "has"
04:28:43 <madhadron> Many programmers "can".  How many "have"?  (And if they must, how many really could?)
04:29:00 <interferon> i'd like to learn more about compiling haskell, but i think ghc is a little too industrial-strength for learning purposes.  are there any haskell implementations that were written with this in mind (not interested in interpreters at the moment)?
04:29:12 <madhadron> Similarly, I'm having to write my own QuickCheck for PLT Scheme, since the "QuickCheck-inspired" one on their package repository appears not to resemble quickcheck at all.
04:29:26 <madhadron> interferon, York Haskell Compiler is supposed to be nice and clean
04:29:37 <dcoutts> interferon: see nhc/yhc, there's also the newer UHC
04:29:47 <madhadron> dcoutts, Oh right, forgot about uhc
04:30:03 <cozachk> whats the u stand for in u? 
04:30:05 <dcoutts> uhc was designed for modularity and teaching
04:30:07 <madhadron> Utrecht
04:30:07 <cozachk> er in uhc* 
04:30:10 <interferon> cozachk: utrecht
04:30:14 <cozachk> ahhh
04:30:22 <interferon> thanks, dcoutts and madhadron: taking a look now
04:30:35 <interferon> uhc sounds like what i'm looking for
04:31:13 <interferon> were nhc and yhc developed for learning purposes too, or are they just incidentally simpler than ghc?
04:31:32 <madhadron> interferon, I think they were meant to be cleaner, but learning is probably incidental.
04:31:39 <malcolmw> nhc/yhc was not built for learning, no
04:31:42 <madhadron> GHC is something of a monster.
04:31:52 <madhadron> so almost anything else is probably easier for learning
04:31:53 <dcoutts> interferon: see the nhc website
04:32:02 <interferon> yeah, i keep being beaten back by GHC's massiveness :)
04:32:03 <madhadron> (and I mean monster in the most friendly, fuzzy, gargantuan ogrish sense)
04:32:06 <danharaj> Funny thing is, compared to compilers for other languages, GHC is pretty sexy.
04:32:43 <dcoutts> interferon: one of the focuses for nhc was on small memory embedded systems and on profiling tools
04:33:04 <dcoutts> interferon: I think its frontend was basically designed to be as simple as possible
04:33:08 <danharaj> and Haskell itself is a lot easier to work with than, say *shiver* C++
04:33:19 <danharaj> I think Haskell already has more active compiler projects than C++.
04:34:00 <ksf> with C++ I wouldn't need to re-write the whole stdlib just to add typeable constraints.
04:34:16 <ksf> that was hard, but frankly, I'm pissed.
04:34:29 <danharaj> :p
04:34:44 <interferon> i'm grabbing all three of them
04:34:53 <danharaj> Gotta catch 'em all.
04:34:59 <ksf> ...considering that's there's not a single type that isn't Typeable.
04:35:15 <interferon> dcoutts, madhadron: i really appreciate the pointers
04:35:21 <dcoutts> np
04:35:32 <Saizan> in C++ you'd just get a 30 pages error in case some of those contraints weren't satisfied.
04:35:53 <danharaj> Saizan: To be fair Stroustrup was trying to push for a solution to that.
04:36:18 <danharaj> IIRC from a paper, Haskell's type classes were a partial inspiration to concepts.
04:37:38 <madhadron> interferon, Sure.  Helping folks in #haskell is always a great alternative to writing up mathematics.
04:37:51 <interferon> :)
04:37:54 <danharaj> madhadron: What's the difference?
04:37:56 * danharaj rimshot
04:38:03 <Saizan> i've been at a lecture on c++ concepts by Siek, which spent most of the time explaining how what they have in c++ now badly lacks a typechecker :)
04:38:22 * madhadron looks at the pile of handwritten notes detailing the calculation in question...oh, there's a difference.
04:38:35 <madhadron> Plus the target audience for the writeup is biologists
04:38:43 <danharaj> biologists are fun
04:39:21 <madhadron> danharaj, Really?  I find they are generally way less wacky and fun loving that, say, physicists.
04:39:48 <danharaj> madhadron: That's because theoretical biology is hard compared to theoretical physics :p
04:39:53 <danharaj> Aka cowboy mathematics.
04:40:11 <madhadron> danharaj, Oh, you mean theoretical biologists.  No, I was talking about straight up lab rats.
04:40:32 <madhadron> for whom the inner workings of a t-test are a black mystery
04:40:43 <danharaj> Experimental biology is probably harder than experimental physics, but I'm going out on a limb saying that.
04:40:57 <danharaj> Living things are too complicated.
04:40:58 <Saizan> there seems to be a trend on how mathematicians imposed the wrong maths on physicists forcing them into the cowboy style to be productive
04:41:08 <madhadron> danharaj, Having done both, I have to say that they're just not comparable.
04:41:16 <danharaj> madhadron: Fair enough.
04:41:23 <danharaj> I can only draw my experience from second hand sources.
04:41:27 <madhadron> Saizan, Yeah.  Physics is done in synthetic differential geometry.
04:41:27 <danharaj> which makes it not experience at all.
04:42:00 <madhadron> danharaj, Biology tends to be a small set of slow, repetitive techniques which require a great deal of focus and not much thinking, strung together in creative ways
04:42:19 <madhadron> Physics tends to be the construction of a single apparatus to do a particular thing, but then there's just one step
04:43:06 <danharaj> And particle physicists get the biggest apparatuses (ii?) of all.
04:43:13 <danharaj> Compensating for their subatomic length, presumably.
04:43:35 * madhadron starts tossing rotten tomatos.
04:43:45 <danharaj> Though those accelerators are used in dozens of fields. It's actually kind of cool seeing how an accelerator's space and time is shared.
04:43:47 <wli> I'd say that biology is a lot more complex than physics.
04:44:14 <madhadron> wli, Depends on the physics, and depends on which of the many ways you could mean complex.
04:44:16 <Taejo> danharaj: apparatuses is better, IMO, but it's be apparati, not -ii (the rule is -us => -i; the -ii appears in radii because the root is radi-)
04:44:53 <danharaj> Taejo: Fair enough. English is a cowboy language that steals words from other languages anyway. Might as well use whatever morphology we damn well please.
04:45:11 <madhadron> danharaj, Fear the hordes of Oxford trained Latinists.
04:45:25 <danharaj> Dinosaurs amongst men, like Lispers amongst Haskellers.
04:45:29 <danharaj> </set phasers to troll>
04:45:34 <madhadron> wli, A lot of the reasoning in biology is quite simple.
04:45:48 <Phyx-> I like this channel, It's exciting
04:45:48 <madhadron> wli, Though I will agree that the systems under investigation are as complicated as anything we have attempted.
04:45:57 <Taejo> Yay, I come across as having become a nitpicker at a prestigious institution (rather than the plain-ol' self-trained nitpicker that I am)
04:46:07 <madhadron> danharaj, I refer you to Typed Scheme and Lazy Scheme in the PLT languages collection.
04:46:21 <Phyx-> What if I told you, It's not the compiler than compiles the Haskell, but the Haskell that compiles the compiler
04:46:51 <madhadron> Phyx, We'd take you to the cleaners for semantic nonsense (:
04:46:53 <danharaj> Evolution is probably the most elegant theory we have devised about anything, but trying to quantify details like the role a gene plays in a complicated phenotype is a bitch.
04:47:01 <madhadron> Everyone know it's one of McCarthy's grad students who compiled the compiler
04:47:03 <danharaj> Biology is elegant in the big, and gets nastier the smaller you get.
04:47:29 <madhadron> danharaj, The word "gene" is unfortunately undefined outside the context of breeding experiments, despite the continuous use in molecular biology.
04:47:43 <madhadron> It's quite elegant in the small as well, as soon as you strip away all the crazy verbiage.
04:47:59 <wli> There are ill-behaved systems in physics but it's not because of a huge variety of different parts interacting, it's basically badly-behaved PDE's etc.
04:48:13 <madhadron> wli, Or because you're doing biophysics (:
04:48:38 <danharaj> wli: At least you can bring to bear the rich theory of PDE's to that. Mathematical biology sounds like a masochist's heaven to me.
04:48:39 <wli> Biology is really the huge variety of different parts interacting and defying modelling.
04:49:22 <roconnor_> can a biological system work reliably if it defies modeling?
04:49:39 <danharaj> I need to go brew a pot of tea, and stop offtopic spamming in #haskell /:
04:49:43 <madhadron> roconnor, By modelling he means you can't write down a set of PDEs and expect it to describe anything realistic.
04:49:46 <fasta> There are no reliable biological systems, right?
04:49:58 <madhadron> fasta, Give me an error threshold for reliable.
04:50:01 <wli> Of course my knowledge of both biology and physics are limited so huge grain of salt, but I think physics gets hard from the models behaving badly where bio is hard to even produce models for.
04:50:11 <fasta> That is animals that live over 10000s of years. 
04:50:37 <madhadron> fasta, That's true, but organisms apparently die on purpose, not from failure of the system.  We still don't really know why...
04:50:55 <fasta> madhadron, on purpose? That seems a very odd choice of words.
04:50:55 <wli> fasta: There are effectively immortal animals like hydras (I think).
04:51:08 <wli> fasta: Maybe they're more like colony organisms.
04:51:12 <madhadron> fasta, Yes, it's a terrible choice of words
04:51:38 * roconnor_ joins haskell-blah
04:51:40 <madhadron> wli, Individuals of pretty much all species do eventually die.  Even bacteria actually senesce.
04:52:10 <madhadron> fasta, What I am trying to say is that there are mechanisms in place that cause organisms to senesce and not be immortal.
04:53:01 <madhadron> though no one has any convincing reason why such things should have been selected for.
04:53:18 <madhadron> Anyway, I'm going to go get some work done.
04:53:21 <roconnor_> #haskell-blah says that if a mechanism is in place that cause organisms to die, it is only because doing so helps propogate the gene that produces the mechinism
05:02:14 <danharaj> I managed to cover up my shoddy cooking skills by using excessive amounts of butter.
05:02:29 <danharaj> I have to wonder what sort of syntactic butter I am using in my code to cover up shoddy programming skills :p
05:05:55 <Itkovian> Any idea what to change here (\inputFile -> do { myStdin <- openFile inputFile ReadMode; hDuplicateTo myStdin stdin >> putStr "hello" } ) so criterion can run this multiple times?
05:06:32 <ivanm> what are you wanting to benchmark? ІО?
05:06:49 <Itkovian> basically nobench's "anna"
05:07:00 <Itkovian> without changing it's source code if possible
05:07:04 * ivanm has no idea what anna does
05:07:05 <Itkovian> i.e., no changes to main
05:07:09 <Itkovian> does not matter
05:07:13 <Itkovian> the main is :: IO ()
05:07:18 <Itkovian> and it uses getContents
05:07:34 <whereIsMyMind> Hello... I'm a new-comer to Haskell
05:07:41 <Itkovian> getArgs gets fixed through using withArgs, but I've no idea how to repeatedly allow it to read from a file
05:07:48 <Itkovian> whereIsMyMind: hi
05:07:55 <whereIsMyMind> and would like to ask someone with a few spare minuts to helo me out with one project
05:07:57 <whereIsMyMind> hi :)
05:08:28 <Itkovian> ask your question. we'll see if we can answer
05:08:33 <blackh> whereIsMyMind: Ask away - you've come to the rihgt place
05:08:39 <whereIsMyMind> :) thx
05:08:41 <whereIsMyMind> well
05:08:44 <danharaj> The hivemind awaits.
05:08:53 <whereIsMyMind> let say i ask the user the input the number
05:09:08 <Itkovian> so the putStr would be replaced by AnnaMain.main
05:09:12 <whereIsMyMind> and his input is stired in n
05:09:23 <Itkovian> but it has to be able to call getContents repeatedly
05:09:41 <Itkovian> the entire line would read: bench "anna big.cor" $ whnfIO $ withArgs [] ((\inputFile -> do { myStdin <- openFile inputFile ReadMode; hDuplicateTo myStdin stdin >> AnnaMain.main } ) "big.cor") 
05:10:12 <whereIsMyMind> the i need to ask the user to enter values repeatedly 
05:10:21 <whereIsMyMind> smth like that : enter a0: 
05:10:26 <whereIsMyMind> enter a1
05:10:38 <whereIsMyMind> and so forth until he reaches an
05:10:44 <whereIsMyMind> enter an:
05:11:52 <whereIsMyMind> what I actully need to do is a small program which can add, substract, *, / polynoms..
05:12:42 <whereIsMyMind> and i though that I can store coefficients in a list ..
05:12:48 <whereIsMyMind> anyone ?
05:13:44 <monoidal> can you write addition of polynomials?
05:13:52 <whereIsMyMind> yes
05:14:03 <whereIsMyMind> but i have probles with I/O
05:14:17 <whereIsMyMind> don't know how exatlly to collect user's data
05:15:06 <Jafet> read!
05:15:57 <Jafet> If this is an interactive program, you could attempt to parse infix notation.
05:16:15 <blackh> whereIsMyMind: The easiest way is to make a function of type IO [Float] that uses explicit recursion to fethc each line
05:16:49 <Jafet> For example, parse inputs of the form "(x + 1)(x - 1) + 1"
05:16:51 <whereIsMyMind> well I spend 5 day reading... I tough i leard enough, but now i c it's not that east
05:16:51 <blackh> It could use getLine to read a line of input, then either exit or loop around.  It would need to pass the accumulating list as a parameter
05:17:04 <monoidal> do putStr "Enter n"; n <- getLine; startRec (read n :: Integer)
05:17:16 <monoidal> this reads integer n
05:17:28 <roconnor_> whereIsMyMind: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26554#a26554
05:17:53 <monoidal> then you have to write startRec :: Integer -> IO [Float]
05:18:11 <monoidal> for the base case, it will be return []
05:19:08 <whereIsMyMind> ok thx :) i will try it out
05:19:11 <monoidal> otherwise, startRec n = do x <- getLine; y <- startRec (n-1); return (x:y)
05:21:17 <monoidal> * (read x :: Float):y
05:21:49 <Jafet> Or you could cheat and use read :: String -> [a]
05:32:12 <whereIsMyMind> monoidal:  (read x :: Float):y this line gives me an error on :
05:32:40 <whereIsMyMind> it says that expexted type is [m Float], not [Float]
05:32:41 <whereIsMyMind> :/
05:32:55 <whereIsMyMind> i still don't get monads.. 
05:32:58 <monoidal> what about return ((read x :: Float):y)?
05:33:36 <whereIsMyMind> works ! :)
05:33:38 <whereIsMyMind> thx ..
05:34:26 <Axman6> the :: Float shouldn't be needed if your types are ok elsewhere
05:34:54 <shaagerup> Hello. Can anybody answer which OS/Version is supported best for Haskell Platform?
05:36:11 * ksf wants lisp
05:36:17 <Itkovian> shaagerup: linux, osx, I'm thinking. It's what I use anyway and it works fine.
05:36:17 <blackh> saa
05:36:26 <ksf> ...no bleeding stage restriction, there.
05:36:30 <blackh> shaagerup: I think it works pretty well everywhere now
05:36:32 <monoidal> whereIsMyMind: you have now a way to read polynomials
05:36:45 <monoidal> whereIsMyMind: now, you can call it two times, add the polynomials, and print the result
05:37:11 <whereIsMyMind> y :)
05:37:22 <whereIsMyMind> i'm sure i will have other problems ..
05:37:31 <whereIsMyMind> :)
05:37:42 <monoidal> it will be do x <- readPolynomial; y <- readPolynomial; print (addPolynomials x y)
05:37:52 <whereIsMyMind> Concept of functional programming is absolutelly new to me..
05:38:06 * hackagebot persistent 0.0.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.0.0.1 (MichaelSnoyman)
05:38:21 <monoidal> you can put the code in main, and it should work (assuming you have a function to add polynomials)
05:39:04 <ksf> ...and the whole problem arises because I want to _embed_ the dsl
05:39:48 <ksf> I would'nt have so much problems talking to the rest of the program if I quoted the whole grammar definition
05:47:14 <blackh> whereIsMyMind: Most of the people in here love talking about Haskell so much they could talk about it all day.  And some of them do just that!  So you've got all the help you could want 24/7.
05:48:29 <whereIsMyMind> thx a lot ;) Haskell is Intriguing. I lould like to learn more about it
05:48:30 <whereIsMyMind> :)
05:48:40 <whereIsMyMind> Next step would be to make a gui for this program..
05:48:41 <whereIsMyMind> :)
05:48:42 <uaca-uaca> hi,I'm getting "cabal.exe: Codec.Compression.Zlib: incorrect header check" when I try to install any package
05:48:46 <uaca-uaca> I'm on windows
05:48:56 <blackh> whereIsMyMind: Haskell never stops being intriguing.
05:48:59 <uaca-uaca> cabal install cabal-install worked
05:49:13 <uaca-uaca> but for any other package I get the above error
05:49:24 <blackh> whereIsMyMind: For a GUI you've got three choices: Gtk, Wx and Qt
05:49:39 <ksf> is there a package to transform the TH ast into something more amendable to processing?
05:50:01 <ksf> ...I don't bleeding care about infix vs. somefix.
05:50:46 <whereIsMyMind> blackh:  i'm sure of it. It's just difficult for a programmer to forget all he knows of programming and start walking like baby again
05:51:30 <whereIsMyMind> :) Qt is what i use most of the time...
05:52:25 <blackh> whereIsMyMind: I know how you feel - I came from "mainstream" languages before I got to Haskell
05:52:44 <whereIsMyMind> when I ask here for help
05:52:53 <whereIsMyMind> i was looking for a kind of a for loop
05:52:58 <ksf> :t forM
05:53:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:53:07 <whereIsMyMind> to ask the user for the imput
05:53:09 <siracusa> uaca-uaca: Have you tried to upgrade zlib and reinstall cabal-install?
05:53:10 <whereIsMyMind> :D stupid
05:53:41 <ksf> oh, you have to know the number of repetitions (that is, the list) beforehand with forM, though.
05:53:49 <ksf> just write a simple recursion
05:54:01 <uaca-uaca> siracusa: it tells me that zlib is at the latest version, and if I --reinstall I get the same error
05:54:02 <monoidal> whereIsMyMind: try: import Control.Monad
05:54:11 <blackh> whereIsMyMind: There's no standard library function to stop looping on an IO action based on a condition inside the loop; You can write your own 'while' or you can use explicit recursion.
05:54:21 <uaca-uaca> siracusa: I'll try reinstalling cabal
05:54:21 <monoidal> whereIsMyMind: forM [1,2,3] (\i -> do print i; getLine)
05:54:37 <ksf> whereIsMyMind, or, even better, just use haskellline
05:54:46 <ksf> which comes with sane command-line editing.
05:54:50 <uaca-uaca> siracusa: same error; it worked the first time :(
05:55:11 <whereIsMyMind> :)
05:55:27 <siracusa> uaca-uaca: I also had this error months ago, unfortunately I can't recall how I solved it.
05:55:46 <whereIsMyMind> well monoidal helped me out with recursion... but i said that just to show how used someone can be to smth diff
05:56:19 <uaca-uaca> siracusa: heh; thanks anyway, I'll keep looking around
05:56:59 <uaca-uaca> siracusa: is the Haskell Platform still the recommended install method? any problems with windows x64?
05:58:09 <siracusa> uaca-uaca: Yes, it is, but I'm not sure about x64
05:59:12 <shaagerup> Any experience here with debugging cabal installations? When running "sudo cabal install wxcore --global" I get the following output: http://gawis.dk/haskell/wxcore_verbose1 (or on verbose level 3: http://gawis.dk/haskell/wxcore_verbose3 )
06:00:36 <siracusa> uaca-uaca: There's a ticket for the problem http://hackage.haskell.org/trac/hackage/ticket/686, but no solution yet.
06:00:52 <uaca-uaca> siracusa: yep, I saw that too 
06:01:46 <uaca-uaca> siracusa: I was kind of hoping that was an user error or something :)
06:05:44 <siracusa> uaca-uaca: What cabal-install version are you using?
06:06:57 <uaca-uaca> siracusa: right now 0.8.1, which came with HaskellPlatform 2010.1
06:07:29 <uaca-uaca> siracusa: the strangest thing is that earlier I had installed cabal-install (cabal install cabal-install) and it worked; but now I get that error
06:09:26 <ksf> shaagerup, hard to say without being a wxhaskell developer
06:09:33 <siracusa> uaca-uaca: 0.8.0 with Cabal-1.8.0.2 and zlib-0.5.2.0 works for me on a 32-Bit Windows. Hhm, maybe I had to downgrade cabal-install to make it run.
06:10:31 * ksf wonders whether the parser is just too dumb to understand // comments
06:12:50 <ivanm> which parser is this?
06:13:00 <shaagerup> ksf: I think I figured it out.. It has at least started compiling with "sudo apt-get install libwxgtk2.8-dev" .. But better error messages would indeed be a great improvement :-)..
06:23:36 <kosmikus>  dcolish 
06:23:40 <kosmikus> sorry
06:26:28 * hackagebot hoauth 0.2.4 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.4 (DiegoSouza)
07:01:39 <Jonno_FTW> is something up with the haskellwiki site?
07:03:33 <Jafet> "up" describes it well, why?
07:03:55 <Jonno_FTW> doesn't seem to be rendering properly
07:04:29 <Jafet> It seems to have a different style now
07:04:44 <Jonno_FTW> yeah, it doesn't seem right
07:04:58 <geheimdienst> i heard that the old logo shows because of the recent meltdown. they still haven't restored it completely. the wiki is missing some css files ...
07:05:04 <geheimdienst> not sure
07:05:40 <Jafet> It's nicer now actually. Fills up the screen like webpages should.
07:09:13 * ksf thinks it should be punishable by downgrade to a 486 to advertise an eclipse plugin as a feature.
07:09:41 <geheimdienst> i agree that the text should fill the browser, but the text does look careless. and the logo is uglier than the current one.
07:14:48 <jmcarthur> we could really benefit from a "real" front page design
07:15:17 <Jafet> You mean like, increasing success?
07:15:29 <jmcarthur> i've given up on failing to succeed
07:16:37 <geheimdienst> wasn't there a thread on -cafe about some upcoming frontpage redesign? just a few weeks ago
07:16:41 <geheimdienst> i.e. before the meltdown
07:16:54 <ivanm> way back there was
07:16:59 <ivanm> not recently however
07:21:46 <geheimdienst> i meant the thing 7-8 weeks ago, "Haskell.org re-design"
07:22:07 <ivanm> eh, the topic comes and goes
07:22:52 <geheimdienst> guess it's moot anyway until the restore is complete ...
07:25:48 <tafryn> Are there any types that are instances of Ord but not instances of Eq?
07:26:20 <Lemmih> tafryn: No. That's not allowed.
07:26:46 <tafryn> I thought that made no sense.
07:26:52 <geheimdienst> @instances Ord
07:26:52 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:28:03 <Jafet> Heh, no instance for sextuples?
07:28:42 <geheimdienst> wondering about that, too
07:28:52 <geheimdienst> > (42, 37) < (1,2)
07:28:53 <lambdabot>   False
07:28:56 <geheimdienst> > (42, 37) > (1,2)
07:28:57 <lambdabot>   True
07:29:02 <geheimdienst> > (0, 37) > (1,2)
07:29:03 <lambdabot>   False
07:29:20 <Jafet> > (0,0,0,0,0,0) < (0,0,0,0,0,1)
07:29:21 <lambdabot>   True
07:29:29 <geheimdienst> > (0,0,0,0,0,0) > (1,1,1,1,1,1)
07:29:30 <lambdabot>   False
07:29:41 <Jafet> > (0,0,0,0,0,0,0,0,0,0,0,0) < (0,0,0,0,0,0,0,0,0,0,0,1)
07:29:42 <lambdabot>   True
07:29:43 <geheimdienst> > (0,0,0,0,0,0) > (1,1)
07:29:44 <lambdabot>   Couldn't match expected type `(t, t1, t2, t3, t4, t5)'
07:29:44 <lambdabot>         against infe...
07:29:59 <geheimdienst> > () < ()
07:30:00 <lambdabot>   False
07:30:03 <geheimdienst> > () > ()
07:30:04 <lambdabot>   False
07:30:18 <tafryn> > () == ()
07:30:19 <geheimdienst> yeah this is completely clear to me
07:30:20 <lambdabot>   True
07:30:54 <Jafet> > ((), (), ()) < ((), (), ())
07:30:55 <lambdabot>   False
07:30:57 <burp> hrhr
07:32:05 <geheimdienst> the ways of the lady lambdabot are impenetrable
07:33:05 <sclv> There was a program/library on hackage for giving a "pure" implementation of basic IO and concurrency semantics.
07:33:11 <sclv> Anyone remember the names?
07:33:19 <djahandarie> io-pure I think....
07:33:21 <djahandarie> Could be wrong
07:33:29 <djahandarie> Maybe not
07:34:04 <sclv> ah. IOSPec
07:34:04 <djahandarie> Ah
07:34:05 <djahandarie> IOSpec
07:34:06 <djahandarie> Damn
07:34:07 <djahandarie> lol
07:34:13 <whereIsMyMind> hi
07:34:17 <ksf> ipprint-0.4 failed while unpacking the package. The exception was:
07:34:17 <ksf> /tmp/ipprint-0.415285/ipprint-0.4/gleb@gleb.kiev.zoral.com.ua.3270:1271836339:
07:34:17 <ksf> copyFile: does not exist (No such file or directory)
07:34:21 <sclv> oddly enough, classified under Testing, which was why I missed it
07:34:24 <whereIsMyMind> how can I force haskell program to exit ?
07:34:43 <burp> use goto to jump to the end of main
07:34:46 <ksf> :t exitWith
07:34:47 <lambdabot> Not in scope: `exitWith'
07:34:52 <ksf> @hoogle exitWith
07:34:52 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
07:35:03 <Jafet> read "" :: Int
07:35:09 <whereIsMyMind> thx :)
07:35:15 <djahandarie> Also
07:35:18 <geheimdienst> burp, is that how you do it in the dialect burpskell?
07:35:19 <Jafet> hClose stdin >> getLine
07:35:20 <djahandarie> @hoogle exitSuccess
07:35:20 <lambdabot> System.Exit exitSuccess :: IO a
07:35:20 <lambdabot> System.Exit ExitSuccess :: ExitCode
07:35:28 <burp> geheimdienst: sure ;)
07:35:31 <ksf> ConT IO is another option, of couser.
07:35:39 <Jafet> head []
07:36:08 <Jafet> fromJust Nothing
07:36:38 <geheimdienst> > fromJust Nothing
07:36:39 <lambdabot>   *Exception: Maybe.fromJust: Nothing
07:37:34 <greb> hello
07:37:38 <djahandarie> I think you are forgetting "error", Jafet :P
07:38:16 <djahandarie> Hi
07:41:37 <whereIsMyMind> some exit function like exitSuccess which can work no both ghc & hugs ?
07:41:55 <whereIsMyMind> cuz hugs complains about unknow var
07:45:06 <djahandarie> whereIsMyMind, Hugs apparently only has exitWith and exitFailure
07:45:15 <djahandarie> whereIsMyMind, you can just do exitWith ExitSuccess
07:45:24 <whereIsMyMind> ok :) thx a lot
07:45:56 <djahandarie> http://cvs.haskell.org/Hugs/pages/libraries/ is the Hugs hackage docs if you need it
07:46:04 <djahandarie> Haddock* rather
07:46:19 <whereIsMyMind> :) thx.. i will need to verify some things :)
07:47:10 <ksf> also, never mind hugs.
07:47:28 <whereIsMyMind> my project requires it..
07:47:35 <whereIsMyMind> so i'm bound to hugs for now..
07:47:47 <ksf> If it was meant to be used, there'd have been new versions in the last couple of years
07:48:44 <sshc> \la
07:53:35 <ksf> which syb library is the most painless to start out with?
07:53:58 <ksf> I'm looking for straight-forward, non-cryptic and perfectly-documented.
08:30:26 <sclv> depends what you want.
08:30:58 <sclv> do you need introspection, or just to avoid rewriting the same fold.
08:31:07 <sclv> is the fold over a regular or irregular data type.
08:31:48 <ksf> ...depends on what the libaries can do
08:32:24 <ksf> I've got a single GADT right now, involving such a gem as Ap :: Foo (a -> b) -> Foo a -> Foo b
08:32:45 <sclv> ksf: the libraries can do lots of stuff.
08:32:54 <sclv> but there are tradeoffs.
08:33:06 <sclv> if you want serious introspection, syb is pretty much the only way to go
08:33:45 <sclv> if you want fast traversals of regular dat atypes, uniplate is very good.
08:33:51 <ksf> is this introspection thing the thing I need to do "hidden-polymorphic" stuff like in the ap above?
08:34:01 <ksf> speed is only of tangential concern
08:34:37 <sclv> ksf: have you seen the compos paper?
08:34:51 <sclv> GADTs make things a pain.
08:34:52 <zygoloid> hmm, won't your Ap need a Data instance for 'a'?
08:35:11 <sclv> You can't automagically derive data for a GADT.
08:35:17 <ksf> it doesn't as a plain data type.
08:35:57 <sclv> for a GADT like that, I'd just write my own compos :-)
08:36:21 <sclv> Its a single function, which is easy to derive by inspection, and it gives you a good set of generic operations.
08:36:22 <ksf> writing a gadt that has the right constructors for pure, ap and <|> is quite trivial
08:37:10 <sclv> I don't know the state of play of the generics libraries' support for GADTs, but I wouldn't necessarily be to hopeful.
08:37:12 <zygoloid> Ap alone doesn't make it a GADT though, just an existential
08:37:19 <ksf> yep
08:37:35 <zygoloid> existentials + generics seems like a pain. you'd need Ap to carry a Data instance
08:40:11 <sclv> ksf: see the compos paper (cited here) http://hackage.haskell.org/packages/archive/uniplate/1.5.1/doc/html/Data-Generics-Compos.html
08:40:56 * ksf wonders why he doesn't just forget about type safety and let TH do the checking
08:41:02 <ksf> ...after splicing stuff in, that is.
08:44:06 <zygoloid> ksf: there's a risk that TH will try to do premature typechecking and get confused :)
08:46:27 <ksf> making the pre-reify syntax typesafe is easy with said existential gadt
08:48:00 <ksf> then I need to sift my gadt out of the th mess and put the pure haskell terms into new bindings, replacing the existentials with Name
08:48:31 <ksf> ...at which point I'm dynamically typed and if the transformation is correct, the resulting splice should typecheck.
08:51:25 <ksf> ...what generics library would you recommend for the TH ast itself?
08:54:11 <sclv> for the th ast, you already have syb instances, so its probably easiest to stick to them?
08:54:51 * ksf didn't notice
08:55:18 <ksf> the interface of Data.Data doesnt' satisfy "non-cryptic", though.
08:58:21 <whereIsMyMind> is there any way to use function which doesnt return IO a in a do block ?
08:58:29 <whereIsMyMind> i guess not but... just in case
08:58:50 <ksf> let, return, fmap
08:59:01 <whereIsMyMind> thx
08:59:18 <ksf> oh, and . , but I don't think you want to wrap your head around that right now.
08:59:38 <whereIsMyMind> i'm too newbie to be true
08:59:38 <whereIsMyMind> :D
08:59:43 <ksf> ( f `fmap` x == x >>= return . f )
09:06:22 <sclv> ksf: syb is very easy if you know what you want to do.
09:07:31 <sclv> you really want Data.Generics and Data.Generics.Schemes for the straightforward stuff
09:08:29 <aristid> syb is a terrible name. "scrap your boilerplate" is almost as bad as "warm fluffy thing" :P
09:08:29 <sclv> and gmapQ and gmapM
09:09:49 <Jafet> "syb" reminds me of syd barrett
09:20:08 <ksf> ...even web.archive.org  of http://www.cs.vu.nl/boilerplate/  is broken
09:20:19 <ksf> THEY don't want me to learn anything about it.
09:21:00 <Cale> aristid: Well, it's a library for... generics, which is a pretty vague-sounding name if you don't already know what it refers to :)
09:21:25 <aristid> Cale: syb is no improvement on that.
09:22:00 <ksf> every single link under documentation on http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB (but the haddock link) is broken
09:22:53 <Cale> syb can be cool, but it doesn't seem like the real answer to how to do generics to me
09:23:14 <aristid> Cale: i mean the name :)
09:23:33 <Cale> I know, I'm just talking about the library itself now :)
09:23:38 <ksf> first off, there's too much intellectual inbreeding going on.
09:23:38 <zygoloid> Cale: no? how do you think it differs from the Real Answer? :)
09:23:54 <Cale> The primitives are too complicated.
09:24:07 <aristid> Cale: i don't feel qualified to judge syb itself, but it somehow feels wrong (the examples i've seen so far at least)
09:24:11 <zygoloid> ah, you want something with more elegance?
09:24:15 <Cale> yes
09:24:40 <Cale> Some of the other systems for doing generics are a lot prettier at a basic level.
09:25:33 <ksf> someone tell me how to write a query with syb that returns the values of all CharL's
09:25:44 <Cale> CharL?
09:25:53 <ksf> out of the TH AST
09:25:58 <ksf> data type Lit
09:26:28 * Cale grumbles about all his broken documentation bookmarks
09:26:28 <ksf>  Couldn't match expected type `d' against inferred type `Lit'
09:26:28 <ksf>       `d' is a rigid type variable bound by
09:26:28 <ksf>           the polymorphic type `forall d. (Data d) => d -> u'
09:26:35 <dreixel> ksf: which links are broken on that page?
09:26:41 <ksf> all of them
09:26:53 <ksf> even the archiv.org link
09:27:07 <ksf> *archive
09:27:16 <dreixel> we must be talking about a different webpage
09:27:20 <dreixel> all I tried work.
09:27:31 <ksf> and the paper links lead to html pages with dead pdf links.
09:27:51 <ksf> the archive.org one is sending mojibake
09:29:04 <dreixel> the archive.org link works fine for me
09:29:24 <dreixel> the papers are missing from the linked pages, indeed... though it's not so hard to find them if one wants to
09:29:32 <dreixel> I guess I'll point those links somewhere else
09:30:05 <dreixel> but seriously, if you find something wrong, please follow the link to the issue tracker (which is also not broken) and report it: http://code.google.com/p/scrapyourboilerplate/issues/list
09:30:15 <dreixel> I'll be happy to make any corrections
09:30:39 <ksf> it's... working with firefox. uzbl doesn't.
09:30:51 <zygoloid> @type let extractCharLs c@(Language.Haskell.TH.CharL _) = put [c] >> return c; extractCharLs a = return a in mkM extractCharLs
09:30:52 <lambdabot> forall (m :: * -> *) a. (MonadState [Language.Haskell.TH.Syntax.Lit] m, Typeable a) => a -> m a
09:30:58 <zygoloid> ksf: ^^ like that maybe
09:32:13 <zygoloid> umm, except i meant tell rather than put
09:32:58 * ksf can't find mkM in Data.Data.
09:33:07 <dreixel> it's not there.
09:33:16 <zygoloid> it's in Data.Generics
09:34:07 <ksf> oh. that looks way less cryptic
09:35:09 <dreixel> Data.Data contains the core only... the Data class and instances
09:35:29 <Cale> listify?
09:37:37 <Cale> listify (\x -> case x of CharL c -> True; _ -> False)
09:38:51 <zygoloid> @hoogle listify
09:38:52 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
09:38:57 <zygoloid> cool
09:40:44 <Cale> It seems that listify had a different type in 6.10.x
09:41:02 <Cale> oh, no it didn't
09:41:15 <Cale> It's just that GenericQ is a funny type synonym
09:41:32 <Cale> (one with a class constraint :)
09:41:44 <Cale> listify (\x -> case x of CharL c -> True; _ -> False) :: (Data.Data.Data a) => a -> [Lit]
09:43:52 <Cale> Is Hackage being slow for everyone, or is it that my router is being garbage again?
09:44:10 <Cale> Hmm, probably the latter
09:45:53 * hackagebot parameterized-data 0.1.5 - Parameterized data library implementing lightweight dependent  types  http://hackage.haskell.org/package/parameterized-data-0.1.5 (HoseinAttarzadeh)
09:47:10 <ksf> zomg it works
09:48:28 <Cale> ksf: So I heard you're going to be working on updating GHC iPhone?
09:48:53 <Cale> Or generalising it to Android?
09:49:12 <djahandarie> Let's make Haskell compile to Java
09:49:14 <ksf> I would possibly be doing such a similar thing, iff I had a pandora
09:49:29 <djahandarie> Actually it probably already exists
09:49:29 <Shadowcat> anyone compiled ghc before?
09:49:35 <ksf> yes
09:49:38 <Shadowcat> how long does it usually take to compile?
09:49:42 <ksf> long
09:49:43 <Cale> Shadowcat: Forever
09:49:51 <Shadowcat> how many hours?
09:49:53 <Cale> Shadowcat: and it's pointless unless you're hacking on it
09:50:06 <Cale> Shadowcat: So if you're not hacking on it, get a binary.
09:50:15 <Shadowcat> Cale: well I'm installing it via macports so
09:50:15 <Cale> (since you need ghc to compile ghc anyway)
09:50:19 <ksf> well it's faster when you don't compile with optimisations
09:50:29 <Cale> Shadowcat: Oh, don't do that.
09:50:34 <Shadowcat> could somebody just give me a number?
09:50:41 <djahandarie> 10
09:50:48 <Shadowcat> 10 hours?!
09:50:52 <djahandarie> No
09:50:58 <djahandarie> That was just a random number
09:51:01 <Shadowcat> ....
09:51:09 <Shadowcat> ok, how many hours does it usually take to compile ghc?
09:51:11 <ksf> it's longer than 6 on mine
09:51:16 <Cale> http://darcs.haskell.org/download/dist/6.12.3/GHC-6.12.3-i386.pkg
09:51:18 <Cale> ^^
09:51:25 <ksf> but then my box is 5 years old
09:51:34 <Shadowcat> this is a macbook nividia spring 2009
09:51:40 <Shadowcat> 2.13 dual core, 4gb of ram
09:52:03 <ksf> 3?
09:52:11 <Shadowcat> 3 hours?
09:52:21 <ksf> my cpu shouldn't be much slower, it's just that it's a singe core
09:52:25 <Shadowcat> it's almost been two hours
09:52:28 <Cale> Just set it up before you go to bed, and see if it's done when you wake up or not.
09:52:41 <Cale> But... don't compile ghc yourself.
09:52:54 <Shadowcat> I installed the haskell platform via macports
09:52:58 <Shadowcat> the whole shebang
09:52:59 <ksf> did you tell make to use both cores?
09:53:03 <Cale> It's silly and pointless. In order to compile GHC, you need GHC anyway.
09:53:20 <Shadowcat> ...
09:53:26 <Cale> So macports must have already installed GHC for you.
09:53:36 <ksf> unless you've got a darcs version, just don't do it.
09:54:15 <ksf> Cale, you know, bootstrapping via hugs would ease porting significantly...
09:54:20 <ksf> cross-compiling sucks.
09:55:24 <Cale> What I'd recommend instead is to install the generic binary GHC pkg, and then grab the cabal-install tarball from Hackage, and run the bootstrap.sh script from that.
09:55:24 <zygoloid> Shadowcat: https://buildd.debian.org/fetch.cgi?&pkg=ghc6&ver=6.12.1-13&arch=amd64&stamp=1271761854&file=log
09:55:27 <ksf> or compile the stage1 bootstrapper down to lisp or something
09:55:31 <zygoloid> Build needed 01:05:22, 3482816k disc space
09:55:34 <Cale> Then you can just cabal-install whatever libraries you want.
09:56:07 <zygoloid> but yeah, don't do it ;)
09:56:35 <Shadowcat> zygoloid: those numbers match up
09:56:43 <Shadowcat> apparently the mac is done building ghc now
09:56:51 <Shadowcat> it's gone on to the rest of the platform
09:57:48 <ksf> hmmm. must've watched tv or something while compiling, then.
09:58:17 <Cale> It depends quite a lot on how fast your machine is of course.
09:58:30 <djahandarie> Does GHC use any GHC extensions?
09:58:40 <Cale> djahandarie: In my understanding, yes.
09:58:53 <Cale> Only GHC compiles GHC
09:59:16 <zygoloid> it's just as well someone already has a GHC binary then :)
09:59:30 * zygoloid ponders what debian's build system actually does
09:59:32 <Jafet> Good old gcc tradition.
09:59:51 <zygoloid> gcc is compilable by all sorts of c compilers
09:59:53 <Shadowcat> zygoloid: this system that I'm talking to you from is actually a debian system
10:00:03 <Shadowcat> and I'm trying to fix this while waiting for the compile
10:00:12 <monoidal> is there monadic while in standard library?
10:00:31 <monoidal> i see whileM in monad-loops
10:00:31 <zygoloid> ahahahahah, the debian ghc6 package build-depends on ghc6
10:00:35 <djahandarie> @hoogle while
10:00:36 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
10:00:36 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
10:00:36 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
10:01:27 <djahandarie> monoidal, you can write it yourself, but otherwise no
10:01:36 <Jafet> Wait, you mean nothing bootstraps ghc?
10:01:45 <Jafet> (Except ghc?)
10:01:57 <zygoloid> Jafet: i assume there once was a version of ghc which could be compiled by something else
10:01:58 <djahandarie> It's really just a line of recursion
10:02:02 <zygoloid> or at least interpreted by
10:02:18 * zygoloid wonders if all ghcs today have hugs as an ancestor
10:02:22 <Jafet> Ken Thompson would be roundly amused.
10:02:31 <Saizan> zygoloid: hbc, i believe
10:06:40 <jasonj> hi everone
10:06:52 <jasonj> how to convert String to Int with error handling?
10:07:02 <Jafet> :t reads
10:07:03 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:07:09 <Twey> :t readIO
10:07:11 <lambdabot> forall a. (Read a) => String -> IO a
10:07:26 <Twey> reads is pure and lazy; readIO is strict and throws an IO exception on failure.
10:07:47 <Jafet> Well, that does not alleviate the error handling bit
10:08:02 <Twey> You still have to actually *handle* the error, of course ☺
10:08:11 <Twey> In fact, can't Control.Exception.catch catch the error from read?
10:08:11 <Cale> Well, it means you can use catch to handle the error in that case.
10:08:17 <Cale> yes
10:08:24 <zygoloid> > case reads "123" of [(n :: Int, [])] -> Right n; _ -> Left "That's not an integer"
10:08:25 <lambdabot>   Right 123
10:08:28 <Cale> (In fact, the Prelude catch should even be able to)
10:08:32 <Twey> :t fmap fst . listToMaybe . reads
10:08:34 <lambdabot> forall a. (Read a) => String -> Maybe a
10:08:42 <Cale> But yeah, you should just use reads
10:08:44 <jasonj> Twey, It can't since the type is not IO a
10:08:50 <Jafet> :t Prelude.catch
10:08:51 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
10:08:58 <zygoloid> > fmap fst . listToMaybe . reads "0x12345hello"
10:08:59 <lambdabot>   Couldn't match expected type `[(a, b)]'
10:09:00 <lambdabot>         against inferred type `(a1,...
10:09:02 * hackagebot ForSyDe 3.1.1 - ForSyDe's Haskell-embedded Domain Specific Language.  http://hackage.haskell.org/package/ForSyDe-3.1.1 (HoseinAttarzadeh)
10:09:06 <Twey> jasonj: Yes it can — you just have to wrap it
10:09:06 <zygoloid> > fmap fst . listToMaybe . reads $ "0x12345hello" :: Int
10:09:07 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:09:08 <lambdabot>         against inferred type ...
10:09:21 <zygoloid> > fmap fst . listToMaybe . reads $ "0x12345hello" :: Maybe Int
10:09:23 <lambdabot>   Just 74565
10:09:56 <Twey> Yeah, it'll grab the succeeding part of a partial parse
10:10:30 <zygoloid> it annoys me a little that you don't get an error for that case (in both read and in haskell)
10:10:40 <Twey> You can ‘fmap fst . listToMaybe . filter (null . snd)’ if you want, but in practice I find that ‘be strict in what you send and lenient in what you receive’ is generally the better course of action
10:10:49 <zygoloid> > let g = 0 in (+) 0x123456789abcdefg
10:10:50 <lambdabot>   81985529216486895
10:11:05 <Twey> > read "0x12345hello"
10:11:06 <lambdabot>   *Exception: Prelude.read: no parse
10:11:11 <Twey> zygoloid: That's not true
10:11:21 <zygoloid> sorry, reads ;)
10:11:44 <Twey> zygoloid: Why would you get an error?  There's a perfectly valid parse; it simply doesn't use all the input
10:11:46 <Cale> > reads "0x12345hello" :: [(Integer, String)]
10:11:47 <lambdabot>   [(74565,"hello")]
10:12:08 <Twey> The only thing to do is indicate that there may be other options, which reads does by handing back the rest of the input in the second half of the pair
10:12:08 <zygoloid> Twey: because intuitively i'd like there to be a visible token boundary
10:12:17 <Twey> I agree with you on 0xabcdefg
10:12:30 <Twey> But then I want mandatory spacing of things in general
10:12:31 <Cale> > reads "0x12345abcdefghijk" :: [(Integer, String)]
10:12:32 <lambdabot>   [(1251004370415,"ghijk")]
10:12:41 <Twey> reads does the right thing however you look at it, though.
10:12:43 <zygoloid> Twey: well, we want Read to match haskell syntax, so...
10:12:55 <zygoloid> basically the problem is that the haskell lexing rules are too generous
10:13:04 <Twey> zygoloid: And it does
10:13:06 <Jafet> Zero width space!
10:13:10 <Twey> Parsing is different
10:13:12 <zygoloid> > (+) 0o31709812
10:13:13 <lambdabot>   11468
10:13:23 <zygoloid> ^^ should that /really/ be accepted?
10:13:40 <Twey> Jafet: -.-
10:13:40 <jasonj> folks, I got overwhelemed, what's the standard way for this *standard* problem?
10:13:49 <Cale> jasonj: use reads and case
10:13:55 <Twey> jasonj: reads or readIO
10:13:59 <jasonj> ok 
10:14:37 <Cale> > case reads "47381" of (n,[]) -> ... success ...; _ -> ... failure ...
10:14:41 <lambdabot>   <no location info>: parse error on input `...'
10:14:59 <Twey> zygoloid: So long as being too accepting doesn't cause losses of power elsewhere, it's fine
10:15:03 <Cale> er, tsk
10:15:13 <Cale> case reads "47381" of [(n,[])] -> ... success ...; _ -> ... failure ...
10:15:14 <Twey> Cale: Hehe
10:15:25 <Cale> Missed a pair of brackets
10:16:24 <monoidal> what does readIO do? is it just return . read?
10:17:31 <Cale> monoidal: It's a little more. It throws a proper IO exception on parse failure.
10:17:45 <monoidal> using throw, not error?
10:17:48 <Cale> yes
10:20:10 <Twey> monoidal: Also, it evaluates it strictly, which reads doesn't necessarily do.
10:21:24 <Cale> Of course, if you immediately pattern match on the result of reads, it'll be strict too :P
10:23:22 <Jafet> > (\~[(n,[])] -> n) $ reads "47381" :: Integer
10:23:22 <lambdabot>   <no location info>: parse error on input `->'
10:24:51 <zygoloid> Twey: it's not about power, it's about rejecting obviously wrong code...
10:26:17 <Jafet> Given that it parses by hs98, it's obviously wrong to call it obviously wrong
10:30:52 <Twey> > let foo = case False of True -> 5 in 9
10:30:54 <lambdabot>   9
10:31:01 <Twey> Cale: Not necessarily ☺
10:33:36 <Cale> Twey: Well, you just didn't evaluate that expression at all.
10:33:42 <Twey> Indeed.
10:33:46 <Cale> So whether it's strict doesn't even matter
10:33:49 <Twey> Hence, lazy
10:34:03 <Twey> readIO will throw the error even if you never use the value.
10:34:27 <Jafet> readIO isn't even strict or lazy, it's IO
10:35:01 <Twey> IO is strict, no?
10:35:21 <zygoloid> > (readIO "123" :: IO Int) `seq` ()
10:35:22 <lambdabot>   ()
10:35:24 <zygoloid> readIO is lazy
10:35:40 <Twey> zygoloid: But its execution isn't
10:35:42 <zygoloid> (but >>= for IO is strict so that's ok...)
10:35:55 <Twey> (though that didn't really prove anything)
10:36:03 <zygoloid> Twey: what would strictness mean for its execution? :)
10:36:15 <Twey> > readIO undefined `seq` ()
10:36:16 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:36:17 <lambdabot>    `GHC.Read.Read a'
10:36:17 <lambdabot>      ar...
10:36:24 <Twey> > (readIO undefined :: IO ()) `seq` ()
10:36:25 <lambdabot>   ()
10:36:32 <Twey> There.  Lazy.  ☺
10:36:34 <zygoloid> heh, fair point :)
10:36:44 <zygoloid> technically, nonstrict :)
10:36:58 <Twey> I think the word ‘lazy’ has too many meanings.
10:37:07 <illissius-> @source readIO
10:37:07 <lambdabot> readIO not available
10:37:11 <illissius-> @source error
10:37:11 <lambdabot> error not available
10:37:15 <illissius-> hmm.
10:37:31 <illissius-> last time it had the source for error and iirc it was just a throw.
10:37:37 <Twey> IO is strict in that, when that point of execution is reached in the generated IO program, the expression is evaluated whether or not its result is needed.
10:37:46 <Twey> @src error
10:37:46 <lambdabot> error s = throw (ErrorCall s)
10:37:49 <Twey> @src readIO
10:37:50 <lambdabot> Source not found. Maybe you made a typo?
10:37:55 <illissius-> oh, src.
10:38:04 <Twey> Not sure what @source does.
10:38:15 <Saizan> Twey: the expression that produces the IO action, your mean?
10:38:28 <zygoloid> Twey: lambdabot autocorrects it to @doc (!)
10:38:36 <Twey> Weird
10:39:05 <Twey> Saizan: The expression that the IO action is performing on its result, I guess.
10:39:22 <Saizan> in that case you're wrong
10:39:26 <zygoloid>  @docs, rather. they do share a few letters i guess
10:40:42 <Saizan> well, depends on what you mean by "is performing"
10:40:45 <Saizan> anyhow
10:40:53 <Saizan> main = return undefined >> putStrLn "Hello" -- this will print Hello, ignoring the undefined there
10:41:38 <zygoloid> Twey: the expression isn't evaluated whether its result is needed. but its result /is/ needed since it might be 'throw an exception'
10:43:40 <Twey> zygoloid: Fair analysis
10:44:31 <Saizan> essentially IO doesn't add any strictness to the result of the action, only values needed to determine which side effects to perform get forced
10:48:18 <dons> dcoutts_: http://stackoverflow.com/questions/3119782/is-cabal-install-supposed-to-act-this-way
10:49:03 <dcoutts_> dons: a few people have been reporting that recently
10:49:18 <dcoutts_> when the same package version is installed globally and in the user package db
10:49:24 <dcoutts_> cabal gets confused
10:49:39 <dcoutts_> (specifically it's the cabal-install dependency resolver)
10:49:51 <dcoutts_> Saizan has been looking into it
10:50:21 <dcoutts_> dons: the workaround is to blow away the duplicate versions and to not use "cabal upgrade"
10:50:59 <dcoutts_> well, not using "cabal upgrade" is a way to avoid reinstalling core packages
10:54:51 * dcoutts_ wonders why people report bugs via stackoverflow
10:55:42 <markmcw> need cabal to work with HEAD version ...
10:55:47 <ksf> I think I have to outlaw custom applicative combinators for this to stay sane
10:55:52 <andreo> what does it mean?
10:55:53 <ksf> ...at least in the beginning
10:55:53 <andreo> Building cabal-install-0.8.2...
10:55:53 <andreo> <command line>: cannot satisfy -package-id containers-0.3.0.0-409fe3b8f0dda25b98e03716d26be411: 
10:55:57 <andreo>     containers-0.3.0.0-409fe3b8f0dda25b98e03716d26be411 is shadowed by package containers-0.3.0.0-339506fe3cdbf89bbfb2d85bb3085ace
10:56:00 <andreo>  
10:56:02 <markmcw> I'm working on a project that requires the HEAD version of GHC
10:56:17 <markmcw> but the Cabal I have installed from the platform GHC is incompatible
10:56:35 <markmcw> what's the best way to get a working Cabal (command line!) in this circumstance?
10:56:37 <ksf> I think syntax-compatiblity and arbitrary haskell terms to stick into the applicative cover most if not all of the use cases
10:56:48 <dcoutts_> markmcw: as far as I know the latest dev version of cabal-install works with the latest dev version of the Cabal lib that comes with ghc
10:57:52 <dcoutts_> andreo: I suggest getting rid of duplicate versions of core packages like containers
10:58:04 <dcoutts_> andreo: btw, do you use "cabal upgrade" ?
10:58:07 <markmcw> I've had trouble getting it installed; when I run 'boostrap.sh' it complains about 'filepath' missing, then I install the required version of that and it says it's missing something else, etc
10:58:29 <dcoutts_> markmcw: filepath is a core package, it comes with ghc
10:58:38 <ksf> dcoutts_, I thought cabal upgrade is disabled?
10:58:39 <zygoloid> is there a tool to generate the dependencies for a .cabal file?
10:58:43 <andreo> dcoutts_: cabal: the 'upgrade' command (when used without any package arguments) has
10:58:43 <andreo> been disabled in this release. It has been disabled because it has frequently
10:58:43 <andreo> led people to accidentally break their set of installed packages. It will be
10:58:43 <andreo> re-enabled when it is safer to use.
10:58:44 <ksf> did you fix it?
10:58:46 <andreo>  
10:59:11 <dcoutts_> ksf: it's still possible to use "cabal upgrade foo" in the released version. I've since disabled that too.
10:59:52 <markmcw> The filepath with the head version is 1.2 and the cabal-install I have it looking for filepath <1.2
11:00:09 <dcoutts_> markmcw: the bootstrap script almost certainly has not been tested with the versions of packages that come with ghc head
11:00:18 <dcoutts_> markmcw: just install it manually
11:01:17 <markmcw> ok ... I've tried that to some extent but have been combing thru missing dependencies ... I guess I'll go back to that strategy unless someone has another idea
11:01:36 <dcoutts_> markmcw: does cabal-install-0.8.x not work with ghc head? I realise it will not build, but if you've already got it built I'd expect it to still work.
11:01:43 <markmcw> I'm willing to use any version that has 'quasiquoting' on data 
11:02:32 <markmcw> I have to sign off now but will experiment when I get back in an hour. Thanks.
11:06:40 <dcoutts_> andreo: got it working?
11:28:38 <sclv> ?seen edwardk
11:28:39 <lambdabot> Unknown command, try @list
11:29:49 <c_wraith> ask preflex, instead
11:29:54 <CakeProphet> So can anyone give me some information on debugging in Haskell? I'm working on a MUD (a type online text-based game) server and I'm comparing concurrency, debugging, and development time between two different languages I'm considering: Haskell and Erlang. (I know that #haskell will obviously be biased on which I should choose ;)
11:29:55 <c_wraith> preflex, seen edwardk
11:29:55 <preflex>  edwardk was last seen on #haskell 15 hours, 21 minutes and 57 seconds ago, saying: wli: hence why i want to do everything i can to reduce that difference to a small constant factor without losing the pretty api.
11:44:19 <kmc> CakeProphet, are you doing your comparison from the perspective of a novice or an expert in these languages?
11:47:10 <Twey> CakeProphet: I'd like Erlang there, personally.
11:47:47 <Twey> Erlang's a horrible language, but its built-in concurrency and hot-swapping are handy for this sort of thing.
11:48:53 <c_wraith> Erlang is a horrible front end to a great runtime library.
11:49:19 <monoidal> haskell vs. erlang for bittorent clients: http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
11:49:56 <Twey> c_wraith: *nod*
11:50:02 <tommd> monoidal: Obviously you didn't hear him - he wants the comparison for MUD clients/servers.  Do you have that link?   ;-)
11:50:19 <c_wraith> Note that he made some terrific haskell performance improvements after writing that, but it doesn't really invalidate his main point.  If you don't know what you're doing, it's easy to end up with laziness costing you a TON, in haskell.
11:50:39 <monoidal> many points are revelant there too, i think
11:50:45 <dons> CakeProphet: debugging, we use QuickCheck and the ghci debugger, mostly.
11:50:53 <dons> for performance debugging, the profiler and threadscope
11:51:06 <tommd> dons: Have you heard of no more uses of HPC for debugging?
11:51:06 <dons> see jlouis' extensive work...
11:51:15 <dons> tommd: oh and -fhpc
11:51:27 <dons> yes, we found bugs via -fhpc, i guess i've mentioned that before.
11:51:35 <dons> great for finding where exceptions are coming from.
11:53:21 <tommd> There's also the interlude package, though I've not used it myself
11:53:29 * tommd runs to a meeting
11:54:33 <jbapple> Is it possible to get GHCi to load a module in qualified form, something like :m + qualified ModuleName as MN
11:54:46 <jbapple> ?
11:55:37 <jbapple> I do not like having to TypeOutLongModule.Names.All.The.Time.In.GHCi
11:56:51 <Twey> jbapple: Sadly no. ☹
11:57:15 <kmc> the workaround is to write a module with the qual import you want, and import it
11:57:32 <jbapple> kmc: that doesn't seem to be working for me
11:57:54 <jbapple> maybe I need to add that qualified module name to the export list
11:58:03 <kmc> ah, if you've an export list it might not work
11:58:12 <kmc> i don't think you can export a qualified module
11:58:27 <kmc> but if you've loaded this module into GHCi in the '*' mode, it should ignore the exports
11:58:56 <jbapple> Actually, it didn't work WITHOUT an export list
11:59:03 <jbapple> with an export list it seems to work fine
11:59:12 <jbapple> hm
11:59:39 <c_wraith> oh.
11:59:50 <c_wraith> don't use :m + to get your module, use :l instead
12:00:04 <c_wraith> that puts you in the namespace defined by your modules imports
12:00:13 <c_wraith> and its exports shouldn't matter in the slightest
12:00:39 <kmc> or :m + *Foo
12:00:58 <c_wraith> I thought * just meant interpret, not put you in its namespace...
12:01:04 <kmc> i thought it does both
12:01:06 <kmc> but could be wrong
12:01:12 <c_wraith> you may be right, too :)
12:01:23 <kmc> i know you can't go into the namespace of a compiled module
12:01:34 <kmc> because something not exported might end up fully inlined or eliminated entirely
12:02:17 <kmc> CakeProphet, I think a comparison of Haskell with any other language will depend a lot on how much experience/skill you assume
12:04:18 <kmc> at a beginner level Haskell will lose in every category except "cute ways to compute factorials"
12:05:07 <c_wraith> Eh.  as a language, haskell is way prettier than erlang.  I can't believe how many different, non-interchangeable function-like things erlang has.
12:06:10 <kmc> but beginners don't tend to write pretty code
12:06:31 <EvanR-work> haskell completely supports large nested if then else blocks
12:06:33 <c_wraith> that's also true of erlang :)
12:06:34 <kmc> there's a steep learning curve
12:06:42 <kmc> yep EvanR-work :)
12:07:16 <kmc> CakeProphet, anyway the first main debugging technique is just to write your code as small independent functions you can test interactively in GHCi
12:07:22 <EvanR-work> making it a great replacement for php
12:07:37 <kmc> this is more useful than most languages, because all functions are pure
12:07:53 <CakeProphet>  kmc  makes sense. I've noted that I've almost never had semantic errors in a program that compiles.
12:08:12 <kmc> it's more rare, yeah
12:08:14 <kmc> it definitely happens
12:08:37 <kmc> but logic errors usually come down to some core misunderstanding in the problem domain, rather than a typo or general sloppiness
12:08:37 <EvanR-work> its easy to have semantic errors, patterns dont have to match, you could use a function that may not complete (head)
12:08:47 <c_wraith> Once your programs get a bit bigger, it's easy to have semantic errors in code that compiles.
12:08:48 <Philonous1> And when you get tired of testing your functions by hand you can unleas quickcheck and smallcheck on them
12:09:02 <c_wraith> I find the strong type-checking most useful for making sure I get my refactoring correct.
12:09:32 <c_wraith> It's rare to introduce a semantic problem while refactoring, if your result code also typechecks.
12:09:32 <monoidal> @src readFile
12:09:33 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
12:09:42 <monoidal> it doesn't have hClose. isn't it needed?
12:09:56 <c_wraith> Not if you only open a couple files for the whole program.
12:10:14 <EvanR-work> hGetContents closes the file after its been completely read
12:10:20 <Philonous1> Are files closed when the handles are gced?
12:10:37 <CakeProphet> question: is there a tool that automatically infers type signatures and then adds them to source code?
12:11:01 <EvanR-work> it helps you to write those yourself at the top level, to sanity check your design
12:11:01 <kmc> not that i know of
12:11:08 <kmc> it could be useful, but it's best to write them yourself
12:11:09 <Philonous1> CakeProphet: With haskell mode in emacs C-u C-C C-t
12:11:22 <c_wraith> I think there's a flag to ghc that makes it spit out type signatures for everything.
12:11:24 <kmc> for example you can apply type synonyms that the inferrence engine won't
12:11:25 <Philonous1> C-u C-c C-t *
12:12:11 <BMeph> Programming in Haskell is also different, because Haskell doesn't divide units of code into "functions" and "procedures". Also, Haskell functions are much "lighter" - semantically and syntactically - than functions in other languages.
12:12:21 <dcoutts_> CakeProphet: in ghci you can ask for the inferred type of anything using :type
12:12:26 <kmc> we tend to use "type-driven design", perhaps analogous to the popular "test-driven design"
12:12:49 <kmc> write the types first, fill in partial definitions, keep refining until the typechecker is happy and you've got rid of all the "undefined"s
12:13:11 <EvanR-work> BMeph: strange, all most code appears to be in some function ;)
12:13:20 <kmc> a key part of this process is to write type signatures for your top-level values
12:13:48 <kmc> indeed, Haskell functions are lighter because they only do one thing -- functions in most languages do three things
12:14:02 <c_wraith> what's the third?
12:14:12 <kmc> argument dependence, side effects, and deferred evaluation
12:14:31 <kmc> Haskell has a separate construct for each
12:14:34 <c_wraith> ah, right.  the function with no args.
12:14:42 <Philonous1> kmc: Strangely, the type in my code tend to be significantly more complicated than the implementation. So I like to write my code and then see whether the types tell the story I wanted to convey
12:14:48 <kmc> yeah
12:15:11 <kmc> it's often the case that choosing the right types is most of the work
12:15:40 <kmc> in the ideal world, choosing the types is most of the work, and each function is an obvious transformation given its type
12:15:45 <BMeph> I wonder why more people don't complain that you can write "xs[2]" in Python (or C, C++, Java, C#, etc., etc., etc....) but you write "xs!2" in Haskell. I never hear bitching about that. "return", however... ;)
12:16:16 <kmc> yeah
12:16:19 <c_wraith> because "return" is more special than array indexing.
12:16:27 <kmc> any language without C-like syntax is doomed to failure
12:16:38 <pchiusano> Data.Traverseable seems pretty impoverished... there are a lot more functions that can be defined in terms of traverse: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Traversable.html
12:17:06 <pchiusano> anyone know of a library with a more complete set of Traverseable-derived functions?
12:18:22 <EvanR-work> BMeph: who uses arrays anyway
12:18:32 <BMeph> c_wraith: I also think it cuts right to laziness, as in, there's a distinct mental separation in Haskell between evaluation and execution, that is noticeable to Lisp(CL, Scheme, etc....) programmers, but is bewildering to "most" other programmers. :)
12:18:48 <kmc> i don't think it's that bewildering
12:18:59 <BMeph> EvanR-work: Lovers of hash tables, among others. ;)
12:19:00 <kmc> also not directly related to laziness
12:19:02 <Philonous1> BMeph: The semantics of "return" is surprising to a C programmer because it is used at the same place and often as the last statement, bearing enough resemblance to C's usage of return that you might assume it denotes the same operation
12:19:35 <kmc> «return» is also confusing syntactically because «return x + 2» is «(return x) + 2»
12:19:49 <kmc> which it isn't if return is a special form for statements, as is traditional
12:20:16 <kmc> i think the separation between evaluation and execution is not so confusing, when explained as such.  i've seen a lot of beginners here understand it right away
12:20:33 * ManateeLazyCat pasted "forkSentinel" at http://paste2.org/get/892383
12:20:33 <ManateeLazyCat> Have same function like `forkSentinel` at above? Or have better solution?
12:20:34 <kmc> it is confusing when it's wrapped up in a lot of noise about monads and burritos and laziness and other irrelevancies
12:20:43 <BMeph> Philonous1:  ...which is only possible if the person completely ignored the "this is what 'return' means" section of a Monad definition. But still a good point, especially for the "you don't need to know what Monads are to use them" advocates.
12:21:07 <kmc> ManateeLazyCat, it's like "forever", but runs in separate threads each time?
12:21:09 <EvanR-work> class Burrito a where
12:21:14 * ManateeLazyCat I guess someone has crazy by Monads. ah?
12:21:35 <ManateeLazyCat> Philonous1 : is you? 
12:22:02 <kmc> ManateeLazyCat, why fork a new thread each time?
12:22:03 * BMeph really, REALLY hates the concept of "special forms", although he recognizes that it's always needed somewhere.
12:22:05 <c_wraith> ManateeLazyCat, what's it solving?  why is it important for each execution to be in a different thread?
12:22:22 <kmc> why not «f action = forkIO (forever action) >> return ()»
12:22:33 <ManateeLazyCat> kmc: Yes, i want it runs in separate threads each time. 
12:22:39 <kmc> ok
12:22:59 <kmc> why?
12:23:13 <ManateeLazyCat> kmc: Because i build use 'dupTChan" build a broadcast channel in different threads of process.
12:23:30 <kmc> ok
12:23:41 <kmc> well this function is simple and does what you want
12:23:50 <kmc> i'd probably write it without the inner "do"
12:23:52 <kmc> using (>>) instead
12:23:55 <kmc> but that's a minor difference
12:24:05 <Philonous1> BMeph: This is - partly - haskells fault, because AFAIK do notation was introduced to appeal to C programmers and so "return" is what is called a "gotcha". As a beginner of a language you don't usually read the language specification to the last letter, especially when it's syntax is layed out in a way that suggests you can draw from your previous programming experience. 
12:24:10 <ManateeLazyCat> kmc: Then once *one* threads write something to "TChan a", any other threads will read value, after read value continue listen. :)
12:24:53 <kmc> i don't think "do" notation was added to appeal to C programmers
12:25:02 <kmc> i think it was added long before anyone wanted any part of haskell to appeal to anyone
12:25:12 <kmc> but i agree that it's a gotcha nonetheless
12:25:16 <c_wraith> well, they wanted it to appeal to themselves. :)
12:25:35 <kmc> once the std lib classes are fixed
12:25:41 <Philonous1> BMeph: And the confusion could easily be avoided by using "pure" isntead of "return" without loosing anything.
12:25:42 <kmc> we can use "pure" everywhere
12:26:00 <monoidal> how to simulate pointers in haskell (and pointers to pointers etc.)?
12:26:05 <monoidal> is ST enough?
12:26:12 <BMeph> Philonous1, kmc: Then we have to contend with the Pure programmers... ;)
12:26:13 <ManateeLazyCat> monoidal: TVar
12:26:15 <kmc> monoidal, what aspect do you want to simulate?
12:26:27 <kmc> monoidal, there's three or four different ways to interpret that question
12:26:31 <monoidal> kmc: only (de)referencing
12:26:41 <kmc> and mutable update?
12:26:44 <Ke> monoidal: perhaps http://www.haskell.org/haskellwiki/Tying_the_Knot
12:26:46 <monoidal> yes
12:26:49 <kmc> then STRef will do it yes
12:26:52 <c_wraith> ST and STRef sound fine
12:26:53 <pastorn> ok... so i want to write a program with two frontends, one ASCII and one UTF
12:26:58 <BMeph> I like "inject", myself, although then we have to contend with the CT crowd complaining that it isn't "really" what "inject" means...
12:27:22 * nealar is amazed by the fact that Writer monad isn't actually a monad 
12:27:28 <ManateeLazyCat> c_wraith: Because i want thread listen broadcast-channel message asynchronous. :) 
12:27:34 <kmc> nealar, it's not?
12:27:57 <pastorn> but i want to put all the GUI-ness in i big record-thingy
12:28:12 <kmc> monoidal, that's really just references, not pointers
12:28:27 <kmc> as in ML's ref types
12:28:33 <nealar> kmc: source code says it is Functor, and it is Monad only if parameter is Monoid
12:28:42 <kmc> yeah
12:28:48 <pastorn> bah... nevermind... i'll just do it in monadState
12:28:51 <kmc> it won't obey the monad laws unless the thing you write is a monoid
12:28:55 <c_wraith> In fact, "Writer" can't be a monad.  It has the wrong kind. :)
12:29:02 <c_wraith> :kind Writer
12:29:07 <c_wraith> @kind Writer
12:29:09 <lambdabot> * -> * -> *
12:29:14 <nealar> @kind Monad
12:29:15 <lambdabot> Class `Monad' used as a type
12:29:17 <c_wraith> @kind Maybe
12:29:18 <lambdabot> * -> *
12:29:21 <nealar> hm
12:29:33 <kmc> Writer isn't a monad.  (Writer t) is a monad iff t is a monoid
12:29:33 <c_wraith> As you can see, things that are monads, like Maybe, have the kind * -> *
12:29:34 * nealar has to think harder on the subject
12:29:49 <kmc> and that's so that the monad laws will be obeyed
12:29:56 <monoidal> can a reference "point" to itself?
12:30:14 <c_wraith> An STRef has to have fun doing that, while remaining well typed.
12:30:15 <kmc> monoidal, it would have an infinite type
12:30:23 <kmc> you'd have to wrap the infinite type
12:30:24 <kmc> @src Mu
12:30:25 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
12:30:25 <c_wraith> Mu STRef
12:30:43 <nealar> @hoogle Mu
12:30:43 <lambdabot> Text.Html multiple :: HtmlAttr
12:30:43 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
12:30:44 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
12:30:57 <monoidal> kmc: ah, so basically mfix on fmap Mu newSTRef?
12:31:08 <kmc> :t mfix (fmap Mu newSTRef)
12:31:09 <c_wraith> it's fix on the type level
12:31:09 <lambdabot> Not in scope: data constructor `Mu'
12:31:42 <kmc> :t mfix (fmap In newSTRef)
12:31:43 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
12:31:44 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `m :: * -> *'
12:31:44 <lambdabot>       Expected type: m a
12:31:58 <Philonous1> BMeph: Yes, anything, as long as it adheres to the principle of least surprise. But well, it doesn't matter much anymore as "return" is now set in stone. And "pure" or "point" doesn't solve the problem because we don't have Monad => Applicative/Pointed. 
12:34:10 * ManateeLazyCat pasted "forkSentinel" at http://paste2.org/get/892394
12:34:15 <ManateeLazyCat> kmc: Above is my example code, once thread read message from broadcast-channel, it will exit, and build new thread call it self for continue listen. That's all my idea: asynchronous *forever*. :)
12:35:20 <ManateeLazyCat> Philonous1: The best practice about Monad is *forget it and just use it* ! :)
12:35:59 <Philonous1> ManateeLazyCat: That sounds an aweful lot like "Forget about physiks and just fly" 
12:36:07 <ManateeLazyCat> Philonous1: You can pick-up again after you use Monad long time. :)
12:36:14 <kmc> :t mfix (fmap In . newSTRef)
12:36:15 <lambdabot> forall s. ST s (Mu (STRef s))
12:36:25 <monoidal> thanks
12:36:39 <ManateeLazyCat> Philonous1: It will crazy you if haven't use it long time. 
12:36:49 <kmc> kind of a bizarre thing
12:36:53 <kmc> but i did find a use for (Mu Chan)
12:36:56 <kmc> so perhaps there's a use here
12:37:16 <ManateeLazyCat> Philonous1: First *feeling* it how to work, then understand it. :)
12:37:36 <monoidal> a list of Mu (STRef s) is like a graph with every vertex having exactly one outgoing edge
12:38:01 <ManateeLazyCat> Philonous1: I think most birds can't understand physiks, but them can fly well. :)
12:38:15 <monoidal> it can be thought of a endofunction v -> v
12:38:20 <ManateeLazyCat> Philonous1: Practice, Practice, Practice.....
12:38:40 <Ke> cycle
12:38:53 <Philonous1> ManateeLazyCat: Oh, I was arguing in a matter of principle, not because I had trouble understanding monads. But when I was new to the language "return" got me once or twice
12:39:29 <ManateeLazyCat> Philonous1: Simple, *return* is don't like return in C. :)
12:39:59 <EvanR-work> :t return
12:40:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:40:03 <EvanR-work> easy!
12:40:10 <ManateeLazyCat> @src return
12:40:10 <lambdabot> Source not found. There are some things that I just don't know.
12:40:42 <Philonous1> EvanR-work: That's only half the story! Return is the unit in the monoid of Kleisli arrows
12:40:44 <EvanR-work> but the forall a (m :: * -> *). is kind of too much for a beginner
12:42:18 <Philonous1> "kind" of too much, yes. 
12:43:10 <EvanR-work> (Monad m) => a -> m a is good
12:43:28 <EvanR-work> i still dont get why forall is on everything
12:44:24 <EvanR-work> arent lower case 'any type' by default, unless theres a class constraint
12:44:31 <CakeProphet> from my understanding forall acts as a kind of scope operator. it's implicit in most type declarations.
12:44:48 <CakeProphet> but used explicitly you can get something called rank-2 polymorphism. I still don't quite understand what all that entails though. :P
12:44:59 <EvanR-work> yeah, what
12:45:44 <djahandarie> Knowing the kind can be useful even when you don't have rank-2 polymorphism
12:46:03 <djahandarie> Having the forall there all the time is a bit annoying though
12:46:08 <CakeProphet> EvanR-work:  for most purposes you don't have to worry about it. the forall is just implied and means that the variable represents "all types" (unless you have a typeclass constraint)
12:46:23 <djahandarie> :t floor
12:46:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:46:42 <djahandarie> Seems a bit verbose
12:46:45 <CakeProphet> :t Control.Monad.ST
12:46:46 <lambdabot>     Not in scope: data constructor `Control.Monad.ST'
12:46:53 <EvanR-work> CakeProphet: thats what im seeing
12:47:00 <CakeProphet> hmmm... how do I import modules?
12:47:15 <CakeProphet> :t State
12:47:16 <lambdabot> forall s a. (s -> (a, s)) -> State s a
12:47:18 <CakeProphet> ah
12:47:20 <CakeProphet> :t ST
12:47:21 <lambdabot> Not in scope: data constructor `ST'
12:47:24 <djahandarie> :t runST
12:47:25 <lambdabot> forall a. (forall s. ST s a) -> a
12:47:27 <CakeProphet> there we go
12:47:31 <ManateeLazyCat> :m Control.Monad.ST
12:47:32 <CakeProphet> rank-2 polymorphism, apparently.
12:47:46 <cads> What should I use to write a little program that can gather search engine results from a few different websites for me?
12:47:48 <monoidal> :i ST
12:48:04 <CakeProphet> :i runST
12:48:19 <monoidal> @info ST
12:48:20 <lambdabot> ST
12:48:23 <CakeProphet> ha.
12:48:23 <ManateeLazyCat> cads: Firefox extension?
12:48:27 <djahandarie> cads, are you looking for a module to help?
12:48:28 <CakeProphet> lambdabot:  o rly?
12:48:29 <monoidal> @kind ST
12:48:30 <lambdabot> * -> * -> *
12:48:44 <ManateeLazyCat> cads: You mean use Haskell write one?
12:49:06 <djahandarie> cads, you probably want Network and maybe Parsec
12:49:32 <djahandarie> There are already made parsers if you're working with XML feeds or something
12:49:32 <alar> CakeProphet: maybe preflex has your module imported?
12:49:35 <cads> I'm wondering if there is something that already does it, and whether haskell would make it easy to do if there weren't
12:50:00 <djahandarie> cads, "something that already does it" as in an application you can download? Or a library you can hook into more Haskell code?
12:50:22 <cads> I'm even thinking code from another language if it's easy enough to use
12:50:23 <CakeProphet> what is the command to run Haskell code?
12:50:31 <cads> if there's already an application out there it would be cool too
12:50:34 <alar> > 1+1
12:50:35 <lambdabot>   2
12:50:38 <cads> I'm looking around right now to see what I can find
12:50:51 <CakeProphet> > main = putStrLn "testing limitations"
12:50:52 <lambdabot>   <no location info>: parse error on input `='
12:50:53 <djahandarie> cads, I really don't know. Look at Firefox extensions.
12:51:01 <CakeProphet> ah... so only expressions.
12:51:12 <djahandarie> CakeProphet, and it won't evaluate IO
12:51:15 <CakeProphet> aw.
12:51:19 <djahandarie> > print 1
12:51:20 <lambdabot>   <IO ()>
12:51:53 <c_wraith> > let main = putStrLn "testing" in main
12:51:53 <CakeProphet> ah well. I guess it eliminates a lot of spam issues... but so does truncating output and sending MSGs for long output.
12:51:54 <lambdabot>   <IO ()>
12:52:10 <ManateeLazyCat> cads: The idea i can think is: build a feed for website (I remember Google have a service do that), then use your favourites RSS reader get those information...
12:52:15 <c_wraith> It's not just spam.  If lambdabot could do IO, it could do *any* IO.
12:52:21 <c_wraith> that would be horribly unsafe.
12:52:30 <monoidal> > fireMissiles
12:52:31 <lambdabot>   Not in scope: `fireMissiles'
12:52:34 <ManateeLazyCat> c_wraith: Ture. 
12:53:00 <CakeProphet> > (\src -> src ++ (show src)) $ "(\src -> src ++ (show src)) $ "
12:53:01 <lambdabot>   <no location info>:
12:53:01 <lambdabot>      lexical error in string/character literal at chara...
12:53:21 <djahandarie> Quine?
12:53:38 <CakeProphet> yes, but something is wrong apparently.
12:53:46 <CakeProphet> ah... the \
12:53:47 <monoidal> (\src -> src ++ (show src)) $ "(\\src -> src ++ (show src)) $ "
12:53:52 <monoidal> > (\src -> src ++ (show src)) $ "(\\src -> src ++ (show src)) $ "
12:53:53 <lambdabot>   "(\\src -> src ++ (show src)) $ \"(\\\\src -> src ++ (show src)) $ \""
12:53:55 <CakeProphet> right.
12:54:04 <djahandarie> Heh
12:54:18 <CakeProphet> works better with a where binding unfortunately.
12:54:42 <CakeProphet> main = putStrLn $ src ++ (show src) where src = ...
12:54:51 <alar> what's the difference between monoid and half-group?
12:54:54 <ManateeLazyCat> cads: If just want to *get* information, use Firefox extension, if you want to know "how to get* information, you can try my idea. :)
12:55:05 <monoidal> semigroups doesn't necessarily have identity
12:55:09 <Cale> alar: Do you mean semigroup?
12:55:15 <alar> yes
12:55:23 <djahandarie> > main = (putStr . ap (++) show) "main = (putStr . ap (++) show) "
12:55:24 <lambdabot>   <no location info>: parse error on input `='
12:55:28 <djahandarie> lol
12:55:29 <Cale> Yeah, it's only required to be associative, not to have an identity
12:55:34 <cads> ManateeLazyCat: I think I'll try playing with some search aggregators, and find one that I like and see if it has an API
12:55:38 <monoidal> monoids are in Data.Monoids, semigroups are on hackage
12:55:57 <Cale> -s
12:55:58 <djahandarie> > (putStr . ap (++) show) "(putStr . ap (++) show)"
12:55:59 <lambdabot>   <IO ()>
12:56:05 <Veinor> haha
12:56:37 <djahandarie> > (ap (++) show) "(ap (++) show)"
12:56:38 <lambdabot>   "(ap (++) show)\"(ap (++) show)\""
12:56:44 <djahandarie> > (ap (++) show) "(ap (++) show) "
12:56:45 <lambdabot>   "(ap (++) show) \"(ap (++) show) \""
12:56:46 <djahandarie> There
12:57:13 <c_wraith> > "quine"
12:57:15 <lambdabot>   "quine"
12:57:16 <aristid> djahandarie: can you add the text function?
12:57:33 <djahandarie> c_wraith, yes yes :P
12:57:33 <ManateeLazyCat> cads: I remember Google can track any website (if them allow robot scan), then build a feed for *new* information. But i'm not sure the detail, just suggestion, you can Google it. :)
12:57:40 <djahandarie> > ()
12:57:41 <lambdabot>   ()
12:57:43 <c_wraith> I know, I'm doing it wrong. :)
12:57:45 <Cale> > (text . ap (++) show)"(text . ap (++) show)"
12:57:46 <lambdabot>   (text . ap (++) show)"(text . ap (++) show)"
12:57:50 <Botje> yes, add the website to google reader
12:57:52 <djahandarie> Space at the end
12:57:58 <djahandarie> Oh wait
12:58:03 <djahandarie> Nice heh
12:58:20 <CakeProphet> oooh, ap makes a fancy quine.
12:58:22 <CakeProphet> :t ap
12:58:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:58:34 <monoidal> > unsafePerformIO (print 2)
12:58:35 <lambdabot>   Not in scope: `unsafePerformIO'
12:58:40 <cads> ManateeLazyCat: apparently search aggregators have begun using such feeds as provided by search websites to keep a streaming list of new search results relevant to a fixed search
12:59:04 <djahandarie> > text.ap(++)show$"text.ap(++)show$"
12:59:05 <lambdabot>   text.ap(++)show$"text.ap(++)show$"
12:59:10 <djahandarie> ftw
12:59:26 <CakeProphet> I think with module restriction security features you could easily mitigate a lot of security issues with lambdabot. If specific IO functions were simply restricted from being imported somehow.
13:00:23 <c_wraith> Eh.  Safer (and easier) to just forbid all execution of IO.
13:00:35 * ManateeLazyCat I just read news from RSS/Atom, i will explore new feed sometimes....
13:00:42 <HugoDaniel> is there any quick n dirty way to serialize my data types to XML ?
13:00:58 <c_wraith> Then the only things you need to block are the ones that rely on unsafePerformIO, like itself, and Debug.Trace, and a couple others.
13:00:59 <djahandarie> CakeProphet, ap in that usage is really just (\a -> a ++ show a)
13:01:11 <ManateeLazyCat> HugoDaniel: What's the solving?
13:02:50 <Twey> HugoDaniel: hxt-pickle might be what you're looking for
13:02:58 <Twey> It's ruddy ugly, though :-\
13:03:12 <CakeProphet> djahandarie:  ah okay. It uses >>= for (->) e in Control.Monad.Reader
13:03:44 <djahandarie> Huh?
13:04:06 <djahandarie> I think the instance comes from Control.Monad.Instances
13:04:11 <HugoDaniel> :(
13:04:25 <Twey> Reader is newtype'd, I think
13:04:54 * Twey likes ap/<*>
13:05:11 <CakeProphet> @src ap
13:05:11 <lambdabot> ap = liftM2 id
13:05:24 <CakeProphet> ah.
13:05:46 <pchiusano> is there a category-theory name for a functions like functor compose? like the function that takes two functors and creates a new functor which is the composition of the two?
13:06:06 <Cale> pchiusano: That's just composition
13:06:10 <Cale> pchiusano: (in Cat)
13:06:34 <roconnor> compositor
13:06:40 <lispy> Twey: ap mod <*>?
13:06:42 <pchiusano> it's composition in the category of functors?
13:06:48 <Apocalisp> yeah that's just arrow composition in the category of categories
13:06:51 <Twey> lispy: Hehe
13:06:57 <djahandarie> pchiusano, in the category of small categories
13:07:06 <Twey> CakeProphet: ap is <*> for monads.
13:07:28 <pchiusano> Cale: what is Cat ?
13:07:37 * lispy should use more applicative functors
13:07:43 <djahandarie> pchiusano, in Cat, objects are small categories and morphisms are functors between categories
13:08:12 <djahandarie> Cat itself is a large category so it isn't an object of itself
13:08:15 <pchiusano> hmm, we have exceeded my knowledge of CT... I don't know what a small category is :)
13:08:52 <Cale> pchiusano: It's just a technicality
13:08:55 <djahandarie> Yeah
13:09:00 <djahandarie> So there is no paradox
13:09:17 <djahandarie> Technically it is where ob and hom are sets and not proper classes
13:09:26 <Cale> pchiusano: A small category is one whose collection of objects is a set and where every collection of arrows between each pair of objects is a set
13:09:31 <roconnor> pchiusano: it's just a major hole in the foundations of category theory :P
13:09:36 <SyntaxNinja> @seen shapr
13:09:36 <lambdabot> Unknown command, try @list
13:09:47 <pchiusano> okay
13:10:10 <roconnor> @get-shapr
13:10:10 <lambdabot> shapr!!
13:10:39 <pchiusano> so if i were to have a module with a bunch of functions like composition of functors, traverseables, etc, what would be a good name for that module?
13:11:24 <pchiusano> maybe just Cat
13:11:46 <roconnor> category-extras
13:11:46 <pchiusano> it is basically functions for constructing new categories from existing categories
13:12:17 <pchiusano> extras????
13:12:20 <roconnor> er
13:12:22 <Cale> pchiusano: I think Conal's name was TypeCompose
13:12:23 <roconnor> nevermind
13:12:34 <Cale> http://hackage.haskell.org/package/TypeCompose
13:12:58 <pchiusano> Cale: ya, I saw that, but that is just one instance of the functions i am envisioning
13:14:28 <pchiusano> oh wait, looks like it has some other functions... maybe I should look at this a little more closely :)
13:18:02 <Apocalisp> pchiusano: edwardk's category-extras has a lot of that stuff
13:21:17 <pchiusano> cool
13:22:08 <pchiusano> no idea what most of it means of course... :) really gotta get edwardk to run a course in CT for haskell programmers
13:22:27 <pchiusano> i would totally sign up
13:30:18 <Apocalisp> pchiusano: Me too!
13:30:36 <HugoDaniel> so
13:30:54 <HugoDaniel> if i dont want a quick n dirty way, whats the "best" method to serialize my data types to XML ?
13:31:12 <Heffalump> out of interest, do you know of a quick n dirty way?
13:31:14 <Apocalisp> an XML serialization combinator library, of course
13:31:39 <HugoDaniel> is there any way to create data types based on a XML Schema ?
13:31:48 <HugoDaniel> some crazy template haskell fu, or whatever... ?
13:31:57 <Cale> You could use Template Haskell
13:32:11 <HugoDaniel> hmm
13:32:12 <Cale> But you're probably better off just defining your types the way that you really want them
13:32:13 <HugoDaniel> ok
13:32:16 <HugoDaniel> hmm ok
13:32:19 <sproingie> is there non-crazy TH? ;)
13:32:23 <HugoDaniel> :D
13:32:39 <HugoDaniel> its just that... these things fell on my lap usually right on top of schedule
13:32:45 * alar just found that my "CRC warm fuzzy thing" isn't Writer monad, 
13:32:53 <Cale> Another option is to use haskell-src-exts and generate Haskell code.
13:32:55 <HugoDaniel> and i usually dont have the time to work out a TH lib to generate data types from schemas
13:33:18 <c_wraith> alar: ST?
13:33:52 <alar> c_wraith: ST has much more power than needed
13:34:53 <alar> CRC needs only one method inside the "warm fuzzy thing": add byte to it
13:35:24 <kmc> you're computing CRC checksums?
13:35:40 <c_wraith> for efficiency, you *really* want the option to add a bunch of bytes at once.
13:36:19 <alar> kmc: yes
13:36:29 <kmc> why do you want a monadic interface?
13:36:45 <alar> kmc: to use do syntax
13:36:50 <kmc> why do you want to use do syntax?
13:37:33 <alar> to handle the notion of sequence
13:37:52 <alar> "first we add to checksum this, than we add that"
13:38:02 <roconnor> thanks to type systems, I can program while drinking and still be sure of safty.
13:38:16 <kmc> alar, it sounds like a list or a monoid to me, not a monad
13:38:25 <kmc> do you have "actions" with results that can be used to compute later actions?
13:38:33 <kmc> would you ever use "<-" within "do"?
13:38:47 <ManateeLazyCat> roconnor: Yes, type system can help me check every detail after i refactory code. :)
13:38:54 <alar> kmc: I'm trying to invent suitable mempty and mappens
13:39:10 <alar> because monad interface is too powerful
13:39:19 <HugoDaniel> is there any lib that parses xsd ?
13:40:21 * alar can't think of sensible task where he needs a checksum while caclculating checksum
13:41:20 <roconnor> alar: mempty is the checksum of the empty string
13:42:01 <alar> roconnor: then mappend isn't crc_update
13:42:08 <c_wraith> CRCs don't appear to be a monoid to me.  As the fundamental operation isn't combining two CRCs.  Rather, it's "CRC -> Word8 -> CRC"
13:42:25 <alar> yes
13:42:34 <alar> but
13:42:44 <roconnor> ah
13:42:55 <alar> (CRC->CRC) can be a monoid?
13:43:10 <roconnor> @type Endo
13:43:11 <monoidal> Endo CRC
13:43:11 <lambdabot> forall a. (a -> a) -> Endo a
13:43:17 <c_wraith> In that it's an endofunctor, sure
13:43:38 <kmc> just an endofunction for our purposes
13:44:16 <whereIsMyMind> Can some one pls help understan a chunk of code ?
13:44:27 <kmc> whereIsMyMind, yes, can you put it on hpaste.org
13:44:32 <pastorn> was there a function 'comparing f = compare `on` f' ?
13:44:37 <kmc> yes
13:44:41 * alar doesn't know what's endofunctor
13:44:42 <pastorn> if so, is it a library function, and where?
13:44:42 <whereIsMyMind> it's a single function
13:44:45 <roconnor> whereIsMyMind: does it use continuations?
13:44:45 <whereIsMyMind> one line
13:44:46 <whereIsMyMind> :)
13:44:49 <kmc> @hoogle comparing
13:44:49 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:44:55 <EvanCarroll> why is the second element in `Data.List.scanr (*) 1 [2..3]++[0]`, 3?
13:45:01 <whereIsMyMind> polyMultiplication (x:xs) y = polyAddition (map (x*) y) (0:(polyMultiplication xs y))
13:45:13 <roconnor> EvanCarroll: cause scanr is backwards
13:45:15 <alar> @hoogle Endo
13:45:15 <lambdabot> Data.Monoid newtype Endo a
13:45:15 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
13:45:15 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
13:45:28 <EvanCarroll> roconnor: not helping.
13:45:29 <alar> sounds reasonable
13:45:31 <whereIsMyMind> i don't get this part (0:(polyMultiplication xs y))
13:45:31 <pastorn> kmc: hmm... didn't find it when i did :browse :/
13:45:45 <EvanCarroll> roconnor: can you write it what calulations render each element?
13:45:48 <kmc> whereIsMyMind, you mean you don't understand the syntax?
13:45:55 <roconnor> EvanCarroll: it is backwards in the same sense that foldl is backwards
13:46:10 <kmc> > scanr (*) 1 [2..5]
13:46:10 <whereIsMyMind> no... well. :) this function mulplies 2 polinomial
13:46:11 <lambdabot>   [120,60,20,5,1]
13:46:30 <kmc> ok
13:46:33 <whereIsMyMind> and i don't get thourh how exatcly
13:46:55 <kmc> (0:(f x)) is a list where the first element is 0 and the rest of the elements are the return value from (f x)
13:47:03 <c_wraith> yeah, scanr is...  confusing to me. scanl makes so much more sense. :)
13:47:15 <kmc> > 0 : (map succ [5..8])
13:47:16 <lambdabot>   [0,6,7,8,9]
13:47:23 <roconnor> whereIsMyMind: (0:foo) is effectively multiplying the polynomial foo by x
13:47:39 <roconnor> whereIsMyMind: it introduces 0 in the constants place and shift all the coefficents up by one
13:47:42 <kmc> by shifting the coefficients up one
13:47:47 <EvanCarroll> ...
13:47:53 <EvanCarroll> I'll take it to stackoverflow
13:47:54 <EvanCarroll> nvm
13:48:19 <kmc> EvanCarroll, maybe we misunderstand your question
13:48:38 <kmc> > scanr (*) 1 [2..3] ++ [0]
13:48:40 <lambdabot>   [6,3,1,0]
13:48:41 <kmc> > scanr (*) 1 ([2..3] ++ [0])
13:48:43 <lambdabot>   [0,0,0,1]
13:49:53 <whereIsMyMind> thx..
13:50:13 <whereIsMyMind> well ... i gues I ran out of brain power today
13:50:36 <whereIsMyMind> it's almost 00:00 here and i'm writing haskell code since 10:00 am
13:50:37 <whereIsMyMind> :/
13:50:45 <whereIsMyMind> with a fre breakz
13:54:30 <alexyk> what's the unary negation function?  e.g. to map over a list of ints?
13:55:01 <Philonous1> @type negate
13:55:02 <lambdabot> forall a. (Num a) => a -> a
13:55:09 <alexyk> thx
13:55:58 <monoidal> -x is syntactic sugar for negate, if you define negate for your type (in Num) -x will work the same
14:00:53 <chrisdone> god damn i'm awesome. wrote some codes for formatting the import list, ran it, worked first time: http://i.imgur.com/72geT.png mmmm, indentationism
14:01:46 <chrisdone> how's that for a slice of fried gold?
14:03:31 <aristid> chrisdone: i don't like that style. too much horizontal space
14:04:18 <chrisdone> it only goes up to 64 columns
14:04:22 <chrisdone> how much space do you need?
14:06:55 <chrisdone> i'm going to merge the "as X" column with the explicit import symbols (X,Y) column
14:14:48 <lispy> chrisdone: you might like some of the older fortran standards
14:16:03 <pchiusano> are there any types which are Traverseable but not Applicative?
14:16:09 <pchiusano> *Traversable
14:16:14 * Baughn just wrote his first multi-line instance head
14:17:03 <Baughn> ..I believe I may be drunk on power.
14:17:21 <Twey> chrisdone: That's pretty
14:17:41 <Twey> chrisdone: But your taskbar is tiny >.>
14:20:11 <ddarius> Who needs a taskbar?
14:20:35 <aristid> chrisdone: actually i almost never do alignments
14:20:49 <aristid> chrisdone: because i hate horizontal space so much
14:22:15 <Jefskell> Hello. Would anyone be willing to answer a question of mine about Haskell?
14:22:20 <triyo> In Parsec is there an easy way to ignore white spaces without using 'spaces' or 'whiteSpace' all over the show
14:22:26 <kmc> yes Jefskell
14:23:30 <tommd> Don't ask to ask, just ask.
14:23:35 <Baughn> triyo: Depends on how ignored you want them. You could filter (not . isBlank) the String before parsing, for one.
14:23:54 <whereIsMyMind> ok a need a bit of help :)
14:23:58 <whereIsMyMind> polyIntegration []  = [0]
14:23:58 <whereIsMyMind> polyIntegration s@(x:xs) = (x / (genericLength s)):(polyIntegration xs)
14:24:09 <whereIsMyMind> i have this function
14:24:25 <kmc> triyo, write only parsers which consume all trailing whitespace after the thing they parse
14:24:25 <whereIsMyMind> but wha i do is wrong
14:24:34 <kmc> such are called "lexeme parsers" by parsec
14:24:38 <kmc> when you glue two of these together, you get another lexeme parser
14:24:42 <Jefskell> Thanks, kmc. (This is my first time using IRC, and I've only been using Haskell for a few days.) How can I create a new data type that will represent an n-dimensional vector of floating points values? I'd like to set "n" just once within my code.
14:24:46 <kmc> so you only need to think about it for the primitives
14:24:48 <ddarius> triyo: The parsers made by the TokenParser all consume whitespace.
14:25:00 <whereIsMyMind> i should use / not on the head but on the last element first, then the previus etc.
14:25:12 <kmc> Text.Parsec.Token does this for you
14:25:20 <whereIsMyMind> the problem is don't know how to do it
14:25:26 <Twey> :t reverse
14:25:28 <lambdabot> forall a. [a] -> [a]
14:25:32 <whereIsMyMind> i can make another function
14:25:36 <whereIsMyMind> yes
14:25:40 <whereIsMyMind> which does reverse
14:25:48 <alar> > reverse "1234"
14:25:49 <lambdabot>   "4321"
14:26:01 <whereIsMyMind> and then pass the reversed version to this function
14:26:09 <whereIsMyMind> but is there any other way ?
14:26:22 <Baughn> @ask Saizan "Insert the give value in the DB. If there are duplicate unique keys Nothing is returned, otherwise the updated db" - insert :: v -> db -> Maybe db. Does this make sense?
14:26:22 <lambdabot> Consider it noted.
14:26:27 <whereIsMyMind> to modify this code somehow ?
14:26:32 <monoidal> Jefskell: if n is not changing and small: data V = V Float Float Float
14:26:44 <ddarius> !Float
14:27:18 <monoidal> Jefskell: if not, I would use Vector/Array
14:27:45 <Jefskell> I might make n a command line parameter... it wouldn't change during a single program execution, but it might be different during different runs of the progrma
14:28:09 <monoidal> whereIsMyMind: rather not. You can write polyIntegrate = f . reverse where f [] = [0] etc
14:28:13 <tommd> Jefskell: Look at the 'vector' package on hackage then.
14:28:24 <triyo> here is my code snippet using applicative parsing http://gist.github.com/453468
14:28:35 <monoidal> whereIsMyMind: or, use additional parameter set initially to 0 and increase it every step
14:28:40 <tommd> You can work with types "Vector Double" or "Vector Float"
14:30:08 <whereIsMyMind> i don't want to use second param. 
14:30:09 <monoidal> whereIsMyMind: something like zipWith (/) p [1,2..]
14:30:13 <Jefskell> It seems like the 'vector' type (from hackage) includes vectors of any length. Is there a way to define a type that only includes vectors of a length set at run time?
14:30:37 <whereIsMyMind> so i gues i will just use reverse function on the input list
14:30:43 <whereIsMyMind> cuz it seams easier
14:31:33 <Baughn> > do fail "foo"; a <- Just 2; return a
14:31:34 <lambdabot>   Nothing
14:31:46 <ddarius> Jefskell: You can make an abstract data type that limits the operations only to those that preserve length and/or checks the length and errors if the length changes.
14:31:49 <monoidal> Jefskell: rather not. You can create your own type, and constructors that will check the constraint
14:32:02 <triyo> in my snippet, there is leading whitespace resulting from (anyChar `manyTill` eof) .....I kown I could change that to (whiteSpace *> anyChar `manyTill` eof) ...but is that the way to go?
14:32:04 <kmc> Jefskell, no, because types are a compile-time construct
14:32:51 <Baughn> > do a <- Just 2; Nothing <- return (Just 3); return a
14:32:52 <lambdabot>   Nothing
14:33:35 <Baughn> > (do a <- Just 2; (Just _) <- return (Just 3); return a, do a <- Just 2; (Just 4) <- return (Just 3); return a)
14:33:37 <lambdabot>   (Just 2,Nothing)
14:34:51 <aristid> Baughn: that uses fail, right?
14:35:01 <Baughn> @pl \a b c -> c
14:35:02 <lambdabot> const (const id)
14:35:14 <Baughn> aristid: Yep. The MonadError instance for Maybe is, of course, insane.
14:35:20 <Jefskell> kmc, that makes sense. How about I hard code a variable named "n" in my code to the number of dimensions? If I do that, then how can I define a data type that limits the operations only to those that perserve and/or checks the length?
14:35:26 <Baughn> ..but then, so is the notion of having fail :: String -> m a.
14:35:35 <aristid> Baughn: MonadError? fail is in Monad proper
14:35:44 <Baughn> aristid: Well, it shouldn't be. *pout*
14:35:48 <tommd> Jefskell: You're talking about making the length of the vector part of the type - this is akin to dependent typing.  Some hackery can approach this in Haskell but it isn't fun.  Other langauges, such as Habit, support this directly - but no wide spread/solid language does afaik.
14:35:50 <Baughn> aristid: That won't stop me from exploiting it, either way.
14:36:10 <aristid> Baughn: you exploiting it, is what makes sure that it will stay that way :)
14:36:33 <triyo> ddarius: "The parsers made by the TokenParser all consume whitespace." -> could you please explain? Reason I ask is that I still see whitespaces in my parsed results.
14:36:36 <Baughn> aristid: Maybe's behaviour on pattern-match failures is sane. I'm using *that*, not calling fail directly.
14:36:50 <Baughn> Just had to check it wouldn't throw a runtime error or something.
14:37:03 <aristid> Baughn: Maybe is a very useful monad.
14:37:17 <alar> tryio: they consume whitespace afterwards
14:37:37 <alar> maybe you should remove th very first whitespace by  hand
14:37:41 <Baughn> aristid: Oh, definitely. This could would be a lot more verbose without it.
14:38:15 <alar> do {whiteSpace;myParser} where myParser is built using TokenParser
14:39:00 <Jefskell> tommd: You're right, I guess "dependent typing" is what I'm trying do. If I were using lisp or Ocaml, wouldn't I be able to do this with macros? Is there anything equivalent in core Haskell?
14:39:11 <triyo> alar: oh I see what you mean. thanks
14:39:22 <tommd> Jefskell: No, macros are also compile-time constructs.
14:40:57 <Baughn> Hm
14:41:12 * Baughn has achieved a ratio of 2:1 code:instance head lines
14:41:12 * alar can't remember the name of package with Oleg's statically sized vectors
14:42:38 <Baughn> Jefskell: Use dynamically sized vectors for now, get back to the statically sized ones later.. much later, once you're familiar with multi-parameter type classes, overlapping instances and functional dependencies.
14:42:40 <sshc> Which libraries would be suggested for dynamically executing Haskell code at runtime (which is possible?) in a "sandboxed" environment?
14:42:42 <Baughn> Because you'll need 'em.
14:42:51 <Baughn> sshc: mueval
14:43:02 <Baughn> It's what \bot uses
14:43:57 <sshc> Baughn: Can mueval read code, and can I call any functions that were defined in the code?
14:44:21 <Baughn> sshc: Yes, and.. not sure.
14:44:30 <alar> hs-plugins?
14:44:30 <Baughn> sshc: You might also want to look at hs-plugins.
14:44:42 <Jefskell> Baughn, I think I'll follow your suggestion and use dynamically sized vectors for now. Thanks to all for the help.
14:45:02 <kmc> hs-plugins is old and deprecated
14:45:14 <kmc> 'hint' is a newer package with a similar role
14:45:25 <kmc> it's not focused on aggressive sandboxing though
14:45:47 <kmc> it can do what you describe
14:46:03 <kmc> you can invoke the compiler and get any Typeable value out
14:46:05 <kmc> including functions
14:46:07 <ologNation> Is linear algebra interesting? 
14:46:09 <c_wraith> I sent daniel two patches to hint yesterday...  haven't heard from him since.  I wonder if I'm annoying him. :)
14:46:16 <Ke> wouldn't it be safe if you don't run any IO
14:46:26 <kmc> mueval uses hint and so can probably do it too
14:46:30 <Baughn> sshc: IIRC, mueval does sandboxing mostly through checking the Haskell source beforehand. You may be able to graft that stage on hint, and have hint do the actual execution.
14:46:31 <Ke> or unsafePerformIO
14:46:47 <Baughn> Ke: And a few others, but yes. That's how mueval works.
14:47:00 <Baughn> Though it could still do a DoS assault - eat memory, etc.
14:47:15 <kmc> yeah, don't run any IO -- evaluate, don't execute
14:47:19 <kmc> it's safe to evaluate IO though
14:47:21 <Baughn> > last [1..] -- Mueval handles that too, but through rlimits.
14:47:25 <c_wraith> Baughn: hint already does the execution for mueval
14:47:25 <lambdabot>   mueval-core: Time limit exceeded
14:47:35 <kmc> it's not safe to import any of the evil little functions that break our evaluation/execution distinction
14:47:39 <tommd> > tails [1..]
14:47:40 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:47:42 <Baughn> > let x = [1..] in (last x, head x)
14:47:43 <tommd> funner
14:47:46 <lambdabot>   mueval-core: Time limit exceeded
14:47:53 <sshc> > fix id
14:47:57 <lambdabot>   mueval-core: Time limit exceeded
14:48:13 <Baughn> c_wraith: But in a separate process, so you can't exchange data as easily
14:48:21 <sshc> I can set a different time limit, right?
14:48:22 <c_wraith> oh, that's a good point
14:48:35 <Baughn> Though you /could/ use pipes and cereal
14:48:41 <sshc> I do need to be able to use the compiled code
14:48:52 <tommd> > fix $ id error --  Fix the cash flow and identify the error.
14:48:53 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:49:38 <c_wraith> > iterate error
14:49:39 <lambdabot>   Overlapping instances for GHC.Show.Show
14:49:39 <lambdabot>                              ([GHC....
14:49:44 <c_wraith> > iterate error "foo"
14:49:46 <lambdabot>   ["foo","*Exception: foo
14:49:55 <c_wraith> hahaha
14:53:15 * Baughn discovers a genuine use for vacuum
14:53:53 <sshc> Mueval can be used as a library, right?
14:54:30 <Baughn> sshc: Yep, but note the way it evaluator returns a string, not a haskell type.
14:55:33 <aristid> :t fix (id error)
14:55:34 <lambdabot> [Char]
14:59:13 <monoidal> > fix error
14:59:14 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:04:08 <Baughn> ..all of a sudden, this is useful.
15:04:22 <aristid> > error "Baughn"
15:04:23 <lambdabot>   *Exception: Baughn
15:04:39 <kniu> why doesn't Data.ByteString have the (++) operator?
15:05:00 <aavogt> kniu: it's expensive for strict bytestrings?
15:05:07 <Baughn> kniu: It has concat
15:05:19 <kniu> okay
15:05:39 <Baughn> It also has a Monoid instance
15:05:50 <kniu> I just defined "x ++ y = Data.ByteString.append x y"
15:06:02 <Baughn> You should use mappend.
15:06:32 <kmc> you should set (++) = mappend, and then use (++) ;)
15:06:39 <kniu> :t mappend
15:06:40 <lambdabot> forall a. (Monoid a) => a -> a -> a
15:06:46 <kniu> okay
15:07:46 <kniu> @hoogle mappend
15:07:47 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
15:09:31 <monoidal> ByteString is strict in its elements, so if it is not bottom then no elements are bottom?
15:09:49 <kmc> yeah
15:10:07 <kmc> internally it's a pointer to a raw chunk of memory
15:12:56 <TimB4> Perhaps somebody can help me with the following question:
15:13:00 <TimB4> Do the monadic laws somehow ensure that side effects like in putStrLn are done in the right order?
15:13:10 <ddarius> No.
15:13:26 <TimB4> then do you know how it is ensured?
15:13:35 <monoidal> a>>=b in IO monad ensures a is executed first
15:13:42 <ddarius> Because the IO type gives that guarantee.
15:13:54 <monoidal> then b v is executed, where v is value returned by a
15:13:54 <Baughn> @tell Saizan http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26565 <- I'm working on the supporting TH code now, but single tables are basically functional now - at least, it's got insert, delete and lookup. Tell me what you think?
15:13:55 <lambdabot> Consider it noted.
15:14:17 <ddarius> TimB4: How do you know a++b puts the as before the bs.  It's not from the monoid law.
15:14:21 <Baughn> TimB4: There are plenty of monads where that guarantee is missing. State.Lazy, for example.
15:15:12 <kmc> TimB4, there *are* no side effects
15:15:17 <kmc> putStrLn is a pure function
15:15:25 <kmc> what it returns is a "recipe" for doing IO
15:15:39 <kmc> the order of evaluation of those functions, and the order of execution of IO-recipes, are two unrelated things
15:16:20 <TimB4> the example with a++b is not good: e.g. in (bla a)++(bla b), I don't care if bla a or bla b is evaluated first
15:16:26 <kmc> TimB4, you still don't care with IO
15:16:32 <TimB4> but the advice with recipes is good
15:16:33 <kmc> because evaluation is not execution
15:16:45 <monoidal> TimB4: take seq (print 2) (print 4). It doesn't print 2
15:17:12 <ddarius> TimB4: In putStrLn "foo" >> putStrLn "bar" either putStrLn can be evaluated first.
15:17:13 <kmc> so you build values of type (IO a) just like any other data type
15:17:20 <kmc> and then you name one of them "main" and hand it off to the runtime system
15:17:25 <ddarius> TimB4: They are executed in the written order though.
15:17:28 <kmc> and it actually performs whatever instructions are contained therein
15:17:40 <sshc> Which library can I use to parse Haskell source?  I need to parse a monad definition (perhaps a do construct) and use it; whether it need be bound to name or not.
15:17:46 <kmc> haskell-src-exts
15:18:25 <TimB4> ok, i understand a bit better now
15:18:40 <TimB4> but the execution is still a mystery
15:19:00 <kmc> right, it's not exposed to the user how the execution is performed
15:19:09 <kmc> nor is it part of the standard that it must be done in a particular way
15:19:28 <TimB4> ok, then i guess i stop thinking about it the next time
15:19:37 <kmc> the implementation of IO in GHC is pretty complicated and ugly
15:19:54 <kmc> but is not at all relevant to understanding how IO works at a conceptual level
15:20:05 <sshc> kmc: How can the parsed monad be evaluated in a "sandboxed" environment?
15:20:14 <kmc> sshc, using hint or mueval
15:20:27 <kmc> you asked how to parse source, but it sounds like that's only a small part of what you want to do
15:20:49 <ddarius> kmc sounds like Clippy.
15:20:54 <kmc> :)
15:21:15 <kmc> also a do construct doesn't define a monad
15:21:26 <kmc> a monad is a type constructor which is an instance of the class named "Monad"
15:21:50 <TimB4> yes i got that - i just rewrote the List and the Maybe Monads for practice
15:21:51 <kmc> a do construct is an expression, whose type is (m a) for some monad m
15:22:00 <kmc> i was talking to sshc just now
15:22:19 <TimB4> btw i studied mathematics, so i like Haskell a lot ... but I'm still very new
15:22:25 <TimB4> ah ok
15:22:26 <kmc> :)
15:22:42 <TimB4> thanks anyway for your help :-)
15:22:50 <TimB4> bye
15:22:52 <sshc> kmc: Alright; I want to parse a monadic expression at runtime, and use it in a sandboxed environment.
15:22:58 <kmc> ok
15:23:23 <kmc> the "use" part is much harder than the "parse" part
15:23:57 <kmc> it seems that -XCPP strips /* comments */ but not // comments ??
15:24:09 <kmc> i suppose // is a common operator
15:24:18 <sshc> kmc: Is it impossible?
15:24:18 <kmc> and (/*) a valid but less common operator
15:24:33 <kmc> sshc, people have been telling you for a while how to do it
15:25:03 <ddarius> Well, // weren't (aren't?) C style comments.
15:25:13 <kmc> true, but they're accepted by most C compilers
15:25:29 <kmc> and yeah weren't, since they're in C99
15:25:44 <ddarius> I thought C99 added them, but I wasn't sure.
15:25:49 <sshc> kmc: ALright.  I'll use one of hs-plugins, mueval, or hint.
15:25:56 <whereIsMyMind> can someone help write a function for division of 2 polynomials ?
15:25:57 <EvanR-work> and were accepted long before 1999 ;)
15:26:08 <kmc> sshc, another option is to talk to the GHC API directly
15:26:19 <kmc> all of the above are supposed to be a nice wrapper on that
15:26:20 <whereIsMyMind> I'm totally out of my mind by now
15:26:43 <kmc> sshc, i recommend against using hs-plugins as i don't think it builds properly on ghc > 6.6
15:28:21 <sshc> Does the binary module validate input?
15:31:20 <EvanR-work> mmmm validation
15:34:36 <monoidal> is there a "lazy" version of liftM2? I mean, liftM2 (||) (print "A" >> return True) (print "B" >> return False) prints "AB", not "A"
15:35:07 <kmc> it would be special for booleans?
15:37:39 <mle> monoidal: I think you're better off assembling your own combinator for that
15:37:41 <orlandu63> lift
15:37:43 <orlandu63> oops
15:38:09 <monoidal> if the function is nonstrict in 2nd argument, it wouldn't be evaluated
15:38:21 <kmc> i think by "evaluated" you mean "executed"
15:38:24 <monoidal> yes
15:39:08 <monoidal> on the second thought, that combinator would perform strange for [] monad
15:39:24 <kmc> yeah, it's not a reasonable thing
15:39:28 <kmc> you could sort of kind of write it
15:39:36 <kmc> especially if you restricted yourself to particular monads
15:39:49 <kmc> but it'd still be a perversion
15:50:57 <monoidal> it's  f a b = a >>= cond (return True) b where cond :: a -> a -> Bool -> a. hard to generalize
15:56:08 * edwardk waves hello.
15:56:25 <edwardk> i just realized there is a much simpler way to get fast blas routines than the one i was working on last night
15:56:57 <Eduard_Munteanu> Hi
15:57:19 <edwardk> basically just add a bunch of rewrite rules to get 'blas fusion' locally. rewrite into the mutable intermediate rep that gets used between all the pure states anyways, and then just stay there 
15:57:45 <edwardk> then i don't have to play all sorts of crazy mvar games
15:59:28 <dons> interesting.
15:59:41 <edwardk> heya dons
16:00:27 <edwardk> i already have the basic vector/matrix types to make a shiny blas lib out of (Data.Vector didn't quite fit, because i needed arbitrary strides)
16:00:33 <monoidal> i reduced my question to: is there a lazy variant of ap, for example (return (const 6)) `ap` (print "A" >> return 1) doesn't print "A"
16:00:41 <edwardk> but this lets me avoid the whole build up a tree and interpret it step
16:00:42 <monoidal> still, it seems impossible
16:01:07 <ddarius> monoidal: ap and liftM2 are basically equivalent
16:01:17 <monoidal> oh, yes. i'm stupid
16:01:35 <ddarius> ap = liftM2 id, liftM2 f x y = return f `ap` x `ap` y
16:02:53 <orlandu63> what does 'ap' stand for?
16:02:58 <ddarius> apply
16:03:00 <edwardk> apply =)
16:03:07 <orlandu63> thought so
16:03:22 <edwardk> foo `ap` bar `ap` baz is a lot more succinct than the obvious alternative
16:03:40 <whereIsMyMind> pls can someone help me write a function for division of polynomials ?
16:03:45 <Eduard_Munteanu> :t ap
16:03:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:03:59 <whereIsMyMind> i not even near a resul :/
16:09:02 <edwardk> dons: quick question. if i have a rule like "map/map" map f (map g xs) = map (f . g) xs -- and i say something like foo = map f xs; bar = map g foo; baz = map h foo -- will the fact that the usage of the map is non-linear prevent that from firing? could the definition of foo get inlined in both places and then have it fire?
16:16:39 <edwardk> whereIsMyMind: look at the Fractional instance in http://hackage.haskell.org/packages/archive/lazysplines/0.1/doc/html/src/Numeric-LazySplines.html
16:16:55 <dons> edwardk: should be fine.
16:17:17 <dons> edwardk: ghc does various transformations to try to make these things match, -ddump-simpl-iterations will tell you what is is trying to match on
16:17:58 <edwardk> dons: what i'm trying to do is figure out if i 'unsafeFreeze' and then thaw and try to put together a rule on that combination if i may try to optimize that away with a rule, if it'll lead to multiple attempts to thaw
16:18:03 <edwardk> the same unsafe value
16:19:07 <edwardk> i think the answer is yes, so i'll need to be careful
16:59:58 <smile> which version of ghc is in hp 2010.1.0.0? http://hackage.haskell.org/platform/windows.html doesn't say
17:00:44 <smile> oh oops, it does under contents.
17:00:49 <monochrom> 6.12.1
17:02:40 <smile> also, is there a problem with the wiki? I've noticed the old haskell logo is at the top for the past week or so and the layout looks like its missing some css or so.
17:06:23 <triyo> Could someone please have a look at this http://gist.github.com/453468 and see why I'm still getting trailing spaces
17:07:04 <triyo> Its the line 14
17:10:24 <whereIsMyMind> i would be very thankfull if smbyis willing to write a polynomial division for me pls.. 
17:10:26 <whereIsMyMind> :/
17:10:55 <whereIsMyMind> i tried everything i could possibly imagine... i scream HELP now :(
17:12:29 <Riviera> whereIsMyMind: http://rosettacode.org/wiki/Polynomial_long_division#Haskell
17:13:40 <whereIsMyMind> Riviera: thx but I tried it..
17:13:50 <whereIsMyMind> i doesn't work ... :/
17:13:55 <Riviera> sorry
17:14:04 <whereIsMyMind> or I don't know how to adapt it for my code
17:14:04 <whereIsMyMind> ..
17:19:39 <Peaker> whereIsMyMind, what do you mean by poly division?
17:19:58 <Peaker> whereIsMyMind, Usually people do polynomial modulus, don't they?
17:20:06 <whereIsMyMind> well..
17:20:08 <whereIsMyMind> i mean that
17:20:29 <whereIsMyMind> if degree of the divisor <= dividor, return 0 and dividor as remainder
17:20:40 <whereIsMyMind> otherwise, divide leading coefficients
17:20:53 <whereIsMyMind> and return remainder if there is some..
17:21:07 <whereIsMyMind> but i could do and without reminder
17:22:46 <Peaker> whereIsMyMind, what problem did you get from the rosettacode thing?
17:23:17 <whereIsMyMind> don't remember
17:23:23 <whereIsMyMind> it was like 2 hours ago..
17:23:25 <whereIsMyMind> :/
17:23:36 <Peaker> try it again then :)
17:23:56 <whereIsMyMind> thx..
17:24:05 <whereIsMyMind> but i will go without it..
17:24:20 <whereIsMyMind> I guess i won't be 100% prepared for my exam ;)
17:31:03 <edwardk1> whereIsMyMind: did you try the algorithm in the lazy spline code i pasted?
17:31:40 <whereIsMyMind> edwardk1: If u pasted it here I missed it ... sorry
17:31:52 <edwardk1> http://hackage.haskell.org/packages/archive/lazysplines/0.1/doc/html/src/Numeric-LazySplines.html
17:32:01 <edwardk1> look at gershom's 'Fractional' instance in there
17:32:35 <whereIsMyMind> oh actually i did look at it
17:32:37 <whereIsMyMind> w8 a sec
17:44:29 <Eduard_Munteanu> edwardk1: do you know any resources on theory and applications regarding your stuff on category-extras?
17:45:11 <edwardk1> Eduard_Munteanu: sigfpe's blog is good
17:45:18 <edwardk1> andrej bauer's blog is also pretty good
17:45:40 <Eduard_Munteanu> edwardk1: ah, thanks. Will look there.
17:47:35 <Eduard_Munteanu> I'm going to have to pick a subject for my B/Eng thesis next year, so I'm looking for fun stuff in Haskell. Of course, they need to have some sort of real life application too.
17:49:05 <cheater99> hello
17:49:16 <pastorn>  hi
17:49:27 <edwardk1> Eduard_Munteanu: heh fair enough. you could always pick up one of my random discarded projects ;)
17:50:53 <lispy> Eduard_Munteanu: you might get ideas from here: http://donsbot.wordpress.com/2010/04/01/the-8-most-important-haskell-org-gsoc-projects/
17:50:59 <Eduard_Munteanu> edwardk1: well? Where do I find a list of them?
17:51:11 <lispy> Eduard_Munteanu: some of them are already being developed as summer of code projects but not all of them
17:51:14 <Eduard_Munteanu> lispy: thanks, I'll check it out.
17:51:30 <edwardk1> Eduard_Munteanu: hrmm, good question.
17:51:31 <Eduard_Munteanu> Ah, I'm a GSoC student too, but not for Haskell.
17:52:17 <Eduard_Munteanu> Please do remember this is a bachelor thesis, so I'm not sure 100% research stuff is appropriate.
17:52:45 * Eduard_Munteanu is currently hacking for Qemu
18:05:30 <Kenjin> hello
18:05:33 <pastorn> hi
18:06:46 <Kenjin> I'm having trouble with haskell platform in os x 10.5.8. I've read some stuff but am unsure of what I should do
18:08:02 <Kenjin> dyld: unknown required load command 0x80000022
18:09:03 <Kenjin> should I compile the haskell platform from my 10.5.8 ?
18:09:32 <Cale> Does the GHC binary pkg installer work?
18:09:37 <Cale> (It ought to)
18:10:10 <Cale> http://darcs.haskell.org/download/dist/6.12.3/GHC-6.12.3-i386.pkg
18:10:21 <Kenjin> Cale: ghci works ok
18:10:34 <Kenjin> I only get the problem with cabal
18:11:33 <Kenjin> The ghc installed from the binary was 6.12.1 and seems to be working finr
18:11:35 <Kenjin> fine
18:11:37 <Cale> Okay, so let's get the cabal-install tarball
18:11:44 <Cale> and try that
18:12:08 <Cale> Because really, if you have cabal-install, the platform doesn't matter, you can grab any package you might need.
18:12:17 <Kenjin> I see
18:13:03 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
18:13:49 <Cale> So, if you unpack that into a directory, you'll find a shell script inside called bootstrap.sh, and you can run that and hopefully all goes well and you get a working cabal
18:14:51 <Kenjin> Cale: README says I need cabal also
18:16:14 <Kenjin> Cale: I ran bootstrap.sh and says Cabal is already installed :) Its doing its thing
18:20:08 <Kenjin> Cale: thanks for the help. Everything seems to be ok now ;)
18:22:29 <Cale> great :)
18:23:47 <alexyk> how do I get the partial darcs repo with the latest ghc cherry-pick Simon's latest commits, and build ghc from that?  my darcs' a bit rusty.  what tag is 6.12.2?
18:24:01 <alexyk> I want to cherry-pick into 6.12.2
18:27:50 <Cale> alexyk: I'm not sure what the tag name is, but I think you'd darcs get --tag=whatever, and then  darcs pull --patches=something
18:28:24 <alexyk> Cale: where the tag matches commit message, right?
18:28:55 <Cale> tags are separate
18:29:03 <Cale> So probably just the version number?
18:29:16 <Cale> But it would be up to them what the convention is.
18:30:21 <alexyk> Cale: I meant patches
18:30:49 <Cale> darcs show tags will show the tags
18:32:01 <Cale> Well, supposing that they've tagged the 6.12.2 release, you could darcs get that tag from your copy of the repo into a new repository to separate out just the 6.12.2 part
18:32:11 <Cale> and then pull in the specific patches you wanted
18:33:17 <Cale> At least, that's how I'd do it, I'm not sure if there's a better way
18:33:29 <jeffno> Regarding the Haskell Report, it mentions the a Haskell Kernel, but never formally defines it. Is there some reason why? Has anybody defined one?
18:33:51 <Cale> jeffno: hmmm...
18:34:06 <Cale> one sec, I'll be right back
18:34:09 <jeffno> ok
18:35:44 <Cale> jeffno: See section 1.2
18:35:56 <Cale> Haskell has adopted many of the convenient syntactic structures that have become popular in func-
18:35:57 <Cale> tional programming. In this Report, the meaning of such syntactic sugar is given by translation into
18:35:57 <Cale> simpler constructs. If these translations are applied exhaustively, the result is a program written in a
18:35:57 <Cale> small subset of Haskell that we call the Haskell kernel.
18:35:57 <Cale> Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda
18:35:59 <Cale> calculus with a straightforward denotational semantics. The translation of each syntactic structure
18:36:01 <Cale> into the kernel is given as the syntax is introduced. This modular design facilitates reasoning about
18:36:03 <Cale> Haskell programs and provides useful guidelines for implementors of the language.
18:36:22 <jeffno> Yeah, I've read that, and it's disappointing
18:36:50 <Cale> For an earlier version of Haskell, there was a complete semantics written up.
18:37:13 <Cale> It simply hasn't been kept up to date.
18:37:50 <jeffno> Here's what SPJ says on the mailing list (circa 2001): "I'm afraid the "Haskell kernel" isn't formally defined.  The Report describes how to translate complex constructs into simpler ones, but neither specifies *exactly* what these simpler ones are, nor gives their meaning in a formal way."
18:38:38 <jeffno> As far as I know, it has *never* been defined in a single place, except in an ad hoc manner.
18:39:10 <jeffno> Even the 1.0 report says essentially the same thing as the 98 report
18:39:18 <Cale> The core as I see it is lambda calculus + algebraic datatypes/case + let.
18:39:31 <jeffno> Right, so I wanted a concise definition of the core
18:39:42 <jeffno> Not something spread out over a report
18:40:07 <Cale> http://research.microsoft.com/~simonpj/Papers/static-semantics.dvi.gz -- did you see this?
18:40:24 <jeffno> Think I missed that, let me look
18:40:32 <alexyk> I can't believe darcs branches are separate directories.  It's so 1999
18:41:23 <Cale> alexyk: What's wrong with that?
18:41:31 <alexyk> so if I get the HEAD, will I also get 6.12?  Seems it's a branch and needs it own get: darcs get --lazy http://darcs.haskell.org/ghc-6.12/ghc
18:41:31 <alexyk>  per http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?redirectedfrom=GhcDarcs
18:41:58 <alexyk> Cale: in git branches are cheap, you can have hundreds per features, per trials, create and delete at will
18:42:45 <alexyk> if I get the head with: darcs get --lazy http://darcs.haskell.org/ghc, am I also getting the 6.12 branch or not?
18:42:56 <Cale> alexyk: I would think that you would.
18:43:06 <alexyk> Cale: how can I check?
18:43:12 <Eduard_Munteanu> Um, does it appear separate even in the working tree?
18:43:13 <Cale> alexyk: darcs show tags
18:43:21 <alexyk> so: branches are tags?
18:43:25 <Eduard_Munteanu> I'd really mind having all branches checkout out in my local repo.
18:43:32 <Cale> tags are named collections of patches
18:43:50 <Cale> So, a particular state of the repository which was worth giving a name to
18:44:24 <alexyk> Cale: I'm not sure branches are tags and there's no 6.xx tags, the number of tags is small in fact
18:44:31 <Cale> okay
18:44:39 <Cale> So perhaps they're not tagging the releases then
18:44:50 <Cale> I'm not familiar with how the GHC darcs repo is managed.
18:45:21 <jeffno> Cale, I looked at the paper, and unfortunately it states that they don't use the core approach
18:46:01 <Peaker> is there a name for fromMaybe mempty?
18:46:13 <Cale> jeffno: Well, you can just take whatever language they're defining the semantics for, and take that to be the core.
18:46:34 <Cale> jeffno: Or, you ought to be able to pick an even smaller language yourself, if you want
18:46:46 <jeffno> Cale, That would defeat the purpose of looking at a small core
18:47:43 <jeffno> I'm really trying to study Haskell as a small core. And since it tries to use one in the report, it just would have been nice to see a concise description of it
18:47:52 <Cale> yeah
18:48:13 <jeffno> I'm surprised nobody has written it up
18:48:18 <Cale> Well, the most important bit is lambda calculus, case, and let.
18:48:35 <Cale> and then, I suppose, the primitive IO actions
18:49:04 <Cale> But GHC has a ton of extensions these days, and that core doesn't really work to support them all elegantly.
18:49:12 <jeffno> And the algebraic data types you mentioned earlier
18:49:23 <Cale> Well, yeah, you need those to have case
18:49:40 <Cale> I suppose newtype is different from data
18:49:48 <Cale> So you'd need both of those, but that's not hard.
18:49:51 <jeffno> I'm not so worried about the extentions. It'll be easier to understand those later once the basics are down
18:51:15 <Cale> jeffno: Are you looking to implement a Haskell-like language?
18:51:22 <Cale> (Or Haskell itself?)
18:51:39 <jeffno> No, I just want to understand Haskell from first principles (the lambda calculus)
18:52:21 <Cale> Okay
18:53:01 <Cale> In any case, http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm is an aging book, but it might help in some ways :)
18:54:32 <jeffno> Cale, Thanks, I'll take a look
18:54:32 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html -- this paper is also good for getting a sense of how things might work at a low level.
18:55:44 <Cale> That book is pre-Haskell. It uses Miranda, which is extremely similar.
18:55:56 <Cale> (Haskell's immediate parent in the family tree of languages)
18:58:06 <Cale> Another book to check out is TaPL: Types and Programming Languages by Benjamin Pierce
18:58:39 <jeffno> I've got that one, but haven't managed to read it :)
18:59:53 <jeffno> Oh cool, the book has an "encriched lambda calculus" section
19:00:05 <jeffno> (the old SPJ book)
19:00:10 <Cale> yeah
19:00:56 <cheater99> spj?
19:01:05 <Cale> Simon Peyton Jones
19:01:10 <cheater99> who's that?
19:01:40 <Cale> One of the main people, if not the main person behind Haskell :)
19:02:02 <jeffno> http://en.wikipedia.org/wiki/Simon_Peyton_Jones
19:02:16 <ddarius> He's one of the two main implementors of GHC.  He's more the compiler guy while Simon Marlow is the runtime system guy.
19:02:22 <jeffno> He gives entertaining presentations too. I highly recommend finding some videos
19:02:43 <Cale> I second that :)
19:02:46 * ddarius completely agrees with jeffno and recommends the relatively recent OSCON talk on STM.
19:03:10 <cheater99> ok, thanks :)
19:03:13 <Cale> I really like the talk about composing contracts (and puddings)
19:03:26 * ddarius hasn't watched that one.
19:03:28 <aristid> they say that SPJ likes to use Comic Sans MS
19:03:44 <jeffno> Comic Sans is a guilty pleasure of mine
19:03:57 <aristid> jeffno: guilty pleasure?
19:04:04 <Cale> It would make a good introduction to the FP way of thinking, for those new to functional programming. :)
19:04:07 <jeffno> Yeah, people deride Comic Sans
19:04:14 <tensorpudding> SPJ uses Comic Sans MS to format Haskell code?
19:04:28 <Cale> tensorpudding: Mostly just the text around it
19:04:35 <Saizan> uoh, type families have non-linear patterns, i'd never have thought that
19:04:35 <lambdabot> Saizan: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:05:07 <tensorpudding> Comic Sans has its uses
19:05:11 <jeffno> http://www.petitionspot.com/petitions/bancomicsans
19:05:31 <tensorpudding> The problem is that it is used too much
19:06:06 <heatsink> It's a display font and should not be used for body text
19:06:26 <tensorpudding> It's uncreative
19:06:50 <ddarius> Unlike Times New Roman
19:07:03 <heatsink> Linux libertine looks better than Times New Roman.
19:09:11 <aristid> oh, the growth of hackage: http://donsbot.files.wordpress.com/2010/05/hackage-june-2010.png?w=490&h=386
19:09:27 <aristid> so the whole thing really started only in 2006
19:10:49 <ddarius> Four years is longer than I thought.
19:13:14 <Peaker> I think Hackage/cabal doesn't work very well
19:13:46 <Peaker> I don't think there's much hope without decent export/import-signature support, either
19:13:53 <ddarius> That's only because your expectations are way higher than they were pre-Hackage/cabal.
19:14:19 <Peaker> I got into Haskell pretty much a couple months before cabal-install started seeing widespread use
19:14:48 <ddarius> I got into Haskell quite a bit before the "Library Infrastructure Project" that lead to Cabal and Hackage.
19:14:53 <Peaker> Today you can be almost certain that "cabal install" on even mainstream packages isn't going to work.. your installed packages will slowly accumulate version cruft and not mingle anymore
19:15:38 <Peaker> cabal-install will try to install new core packages in parallel to the globally installed ones, and then you'll get a mishmash of packages that can be compiled together but cabal does not know it
19:15:49 <Peaker> the whole version thing is just wrong
19:16:15 <aristid> cabal has seen the limits of its current model's scalability :)
19:16:47 <Peaker> Also the current global namespace of modules where any package just throws itself in is pretty bad
19:18:14 <aristid> Peaker: you mean where you have a random package adding modules to Control.Monad.*?
19:18:57 <Peaker> Yeah
19:19:54 <Peaker> Though that may be a lesser problem and related to the signature dependency specs
19:20:54 <aristid> Peaker: the biggest problem of course is the lack of Applicative => Monad :D
19:21:11 <heatsink> aristid: What about []?
19:21:44 <heatsink> I mean, the applicative functions not being the same as the monad functions for []
19:21:47 <Peaker> aristid, That's more of a Prelude/in-base problem than a hackage/cabal problem
19:21:58 <Peaker> heatsink, how are they different?
19:22:06 <aristid> heatsink: they are not different?
19:22:15 <Peaker> > [(+1), (*2)] `ap` [30, 40]
19:22:16 <lambdabot>   [31,41,60,80]
19:22:20 <Peaker> > [(+1), (*2)] <*> [30, 40]
19:22:21 <lambdabot>   [31,41,60,80]
19:22:25 <heatsink> Huh.
19:22:30 <Peaker> same ordering -- otherwise there couldn't be anything different
19:22:30 <aristid> looks pretty much the same
19:22:31 <heatsink> I thought <*> corresponded to zipWith
19:22:38 <aristid> heatsink: no
19:22:43 <Peaker> heatsink, No, that's a "newtype ZipList" around [] which does that
19:22:47 <heatsink> ah
19:22:48 <Peaker> @hoogle ZipList
19:22:48 <lambdabot> Control.Applicative newtype ZipList a
19:22:48 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
19:22:48 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
19:23:01 <Peaker> heatsink, Any type whose Applicative instance disagrees with the Monad instance is a bug :)
19:23:03 <aristid> heatsink: so Applicative [] is well-behaved
19:23:10 <Peaker> ap should always equal <*>
19:23:22 <aristid> and fmap should always equal liftM
19:23:32 <Peaker> btw: There was some talk about "cummutative monads" but it really sounds like what they want is just Applicative
19:23:46 <Peaker> and pure = return if you are anal :)
19:23:48 <edwardk1> Peaker: for the most part, yes.
19:23:58 <Peaker> edwardk1, what's the rest of it?
19:24:09 <heatsink> pure = error "not implemented"
19:24:20 <edwardk1> a commutative monad would allow the applicative side-effects to be reordered by the compiler
19:24:33 <Peaker> heatsink, at least let it take 1 arg before failing :)
19:25:01 <Peaker> edwardk1, makes more sense to say a commutative applicative would allow the ... no?
19:25:16 <Peaker> edwardk1, if it's really a Monad then you have dependencies on results of effects 
19:25:18 <edwardk1> Peaker: yeah, i rewrote my sentence to say 'applicative' mid-stream ;)
19:27:23 <Peaker> So.. I'm working on a tree editor that's supposed to evolve to an XML editor soon.. would anyone find any use for this? Or for some other notion of a tree editor?
19:27:40 <Peaker> (It's a stepping stone for a code editor I want to work on later on)
19:27:51 <Peaker> I would like to have some feedback
19:27:55 <heatsink> A GUI-based editor?
19:28:07 <ddarius> An Applicative is commutative if swap commutes with uncurry (liftA2 (,))
19:28:42 <Peaker> heatsink, It's a console-based GUI editor
19:29:28 <Peaker> ddarius, and a monad is really never commutative in its effects if the functions given to bind are strict in their arguments
19:30:01 <Peaker> (and if the results depend on the effects)
19:30:02 <aristid> :t uncurry (liftA2 (,))
19:30:02 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
19:30:34 <Peaker> heatsink, Though I intend for it to be a real GUI at some point (Just wanted to avoid messing with the details so I used Vty for now)
19:31:10 <aristid> @pl \x y -> (,) <$> x <*> y
19:31:11 <lambdabot> (((,) <$>) .) . (<*>)
19:31:21 <edwardk1> you could also get there with "if (<**>) is equivalent to flip (<*>)"
19:31:51 <aristid> @let binary = (.).(.)
19:31:52 <lambdabot>  Defined.
19:32:09 <Peaker> aristid, that's resultresult :)
19:32:20 <aristid> Peaker: i like the name binary better
19:32:28 <Peaker> aristid, why do you give that a name?
19:32:29 <aristid> :t binary (+1) (*)
19:32:30 <lambdabot> forall a. (Num a) => a -> a -> a
19:32:38 <Peaker> oh
19:32:43 <aristid> Peaker: because it's so useful
19:33:00 <Peaker> aristid, Can just go full-blown SECs from there
19:33:24 <aristid> Peaker: i like that it is like the reverse of on
19:33:28 <aristid> :t on
19:33:29 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:33:33 <aristid> :t binary
19:33:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:33:44 <aristid> aah, the joy of caleskell
19:34:14 <ddarius> aristid: You should learn J.
19:34:17 <Peaker> @let bin = (Prelude..) Prelude.. (Prelude..)
19:34:18 <lambdabot>  <local>:12:6: Not in scope: `Prelude..'
19:34:18 <lambdabot>  
19:34:18 <lambdabot>  <local>:12:18: Not in scope: `Pre...
19:34:28 <Peaker> @let bin = (P..) P.. (P..)
19:34:29 <lambdabot>  <local>:12:6: Not in scope: `P..'
19:34:29 <aristid> ddarius: why?
19:34:29 <lambdabot>  
19:34:29 <lambdabot>  <local>:12:12: Not in scope: `P..'
19:34:29 <lambdabot>  
19:34:29 <lambdabot>  <...
19:34:43 <aristid> Peaker: it hates you ;)
19:35:00 <Peaker> @let dot f g x = f (g x)
19:35:01 <lambdabot>  Defined.
19:35:06 <Peaker> @let bin = dot dot dot
19:35:07 <lambdabot>  Defined.
19:35:11 <Peaker> @type bin
19:35:12 <lambdabot> forall t1 t2 t t3. (t1 -> t2) -> (t -> t3 -> t1) -> t -> t3 -> t2
19:35:15 <Peaker> @type on
19:35:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:35:38 <aristid> Peaker: see how they are related?
19:36:30 <Peaker> aristid, on applies to both args of a binary func.  binary applies to its result
19:36:50 <aristid> :t unwrapMonad `binary` (<|>) `on` WrapMonad
19:36:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:37:07 <Peaker> The names "binargs" "binresult" may make it easier, though I'd just use SECs instead
19:37:26 <Peaker> aristid, that's cute, you could use ~> though
19:37:26 <aristid> Peaker: is there a SEC for on?
19:37:46 <Peaker> aristid, You could use ~> with the dup
19:37:50 <aristid> ~>? how?
19:38:01 <Peaker> @let (f ~> g) x = f >>> x >>> g
19:38:02 <lambdabot>  Defined.
19:38:07 <Peaker> oops
19:38:09 <Peaker> @undef
19:38:20 <Peaker> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
19:38:21 <lambdabot>  Defined.
19:38:31 <aristid> :t (unwrapMonad ~> WrapMonad) (<|>)
19:38:32 <lambdabot> forall (m :: * -> *) a. (Alternative m) => WrappedMonad m a -> WrappedMonad ((->) (m a)) (m a)
19:38:46 <aristid> oh wrong way
19:38:47 <Peaker> @type (unwrapMonad ~> unwrapMonad ~> WrapMonad) (<|>)
19:38:48 <lambdabot> forall (m :: * -> *) a. (Alternative m) => WrappedMonad m a -> WrappedMonad m a -> WrappedMonad m a
19:39:03 <Peaker> this way you apply to each arg/result just like it appears in the type
19:39:07 <aristid> :t (WrapMonad ~> unwrapMonad) (<|>)
19:39:08 <lambdabot>     Couldn't match expected type `WrappedMonad m a'
19:39:08 <lambdabot>            against inferred type `WrappedMonad m1 a1 -> WrappedMonad m1 a1'
19:39:08 <lambdabot>     In the first argument of `(WrapMonad ~> unwrapMonad)', namely
19:39:20 <Peaker> on f = f ~> f ~> id  :)
19:39:32 <Saizan> :t (WrapMonad ~> WrapMonad ~> unwrapMonad) (<|>) -- here
19:39:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:39:37 <Peaker> or that's flip on
19:39:54 <Peaker> @type on
19:39:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:40:03 <aristid> @let dup x = x ~> x
19:40:04 <lambdabot>  Defined.
19:40:18 <Peaker> aristid, that applies x to both arg and result
19:40:18 <aristid> :t (dup WrapMonad ~> unwrapMonad) (<|>)
19:40:19 <lambdabot>     Couldn't match expected type `WrappedMonad m a'
19:40:20 <lambdabot>            against inferred type `(m1 a1 -> WrappedMonad m1 a1)
19:40:20 <lambdabot>                                   -> m1 a1
19:40:24 <Peaker> aristid, ~> is right-associative
19:40:28 <aristid> Peaker: oh.
19:40:32 <Peaker> @type flip $ \f -> f ~> f ~> id
19:40:32 <aristid> Peaker: how to fix?
19:40:32 <lambdabot> forall a b b1. (b -> b -> b1) -> (a -> b) -> a -> a -> b1
19:40:48 <Saizan> :t (join (~>) WrapMonad ~> unwrapMonad) (<|>)
19:40:49 <lambdabot>     Couldn't match expected type `WrappedMonad m a'
19:40:49 <lambdabot>            against inferred type `(m1 a1 -> WrappedMonad m1 a1)
19:40:49 <lambdabot>                                   -> m1 a1
19:40:58 <Saizan> right.
19:41:23 <Peaker> Any expression that looks like (.... ~> unwrapMonad) will not work because this already means you're applying unWrapMonad on the unary result
19:41:36 <ddarius> Categorists would be amazed by the excitement about functorial mappings.
19:41:58 <edwardk1> ddarius: =)
19:42:10 <Saizan> would they like the name (~>)?
19:42:22 <Peaker> the name ~> is just going for semblance to the type operator (->)
19:42:35 <Peaker> (***) should have the same kind of similarity to (,)
19:42:39 <ddarius> Saizan: Sometimes a similar notation is used, i.e. the equivalent of (->) would be used.
19:42:50 <aristid> @let dup' x y = x ~> x ~> y
19:42:51 <lambdabot>  Defined.
19:43:06 <ddarius> Of course, the usual notation for A -> B is either Hom(A,B) or B^A.
19:43:07 <Saizan> well, yeah, Hom(f,g)
19:43:12 <aristid> :t (dup' WrapMonad unwrapMonad) (<|>)
19:43:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:43:23 <Peaker> aristid, that's nice
19:43:35 <Peaker> maybe it should be ~~>
19:43:41 <aristid> :)
19:43:42 <Peaker> WrapMonad ~~> unwrapMonad
19:43:56 <aristid> ~~ shows the binaryness
19:43:59 <Saizan> ~~> sounds like admitting defeat
19:44:01 <ddarius> Are you going to define ~~~> too?
19:44:05 <aristid> ddarius: :D
19:44:10 <Peaker> ddarius, Just like we have liftM4 :)
19:44:20 <aristid> :t liftM4
19:44:21 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
19:44:30 <aristid> Peaker: liftM4 is obsoleted by <*>!
19:45:03 <aavogt>  liftM4 is more pointfree
19:45:06 <alexyk> if I build me a ghc from 'em darcses, and previously I installed one into prefix /opt/haskell, can I give the same to ./configure or will they overwrite each other?  how do I setup for peaceful coexistence?
19:45:18 <ivanm> aristid: it's not obsoleted at all IMHO
19:45:24 <Peaker> aristid, it looks nicer without the <*> noise though
19:45:28 <ivanm> since they have different types
19:45:34 <Saizan> alexyk: if they have different version numbers they'll coexist
19:45:37 <aristid> liftM4 has a too-high number for me
19:45:47 <Peaker> ivanm, he means use <*> between args instead of "liftM.." prefix
19:45:57 <ivanm> maybe dcoutts_ should publish his multiple GHC approach somewhere for people wanting to do it
19:46:11 <alexyk> Saizan: but at least the bin/ghc driver will be overwrittem won't it?
19:46:19 <aristid> :t \f a b c d -> f <$> a <*> b <*> c <*> d
19:46:20 <lambdabot> forall a a1 a2 a3 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> a3 -> b) -> f a -> f a1 -> f a2 -> f a3 -> f b
19:46:21 <ivanm> Peaker: I realise that, but then the correct argument is that three lots of <*> is equivalent to liftM4
19:46:29 <Saizan> the multiple GHCs approach is "install multiple GHCs"
19:46:33 <ivanm> alexyk: the default symlink will, yes
19:46:40 <ivanm> Saizan: and how to manage them though
19:46:50 <Saizan> alexyk: you'll still have the versioned ones
19:47:02 <Peaker> hlint has buggy precedence rules w.r.t `infix` notations
19:47:04 <alexyk> ivanm: so then you always specify a version to ghc with option, same to ghc-pkg etc?
19:47:05 <ivanm> alexyk: at least in linux, /usr/bin/ghc is a symlink to /usr/bin/ghc-6.x.y
19:47:11 <Saizan> alexyk: and you can point cabal to them passing -w
19:47:27 <ivanm> Peaker: report a bug to ndm then!
19:47:48 <alexyk> now if anybody bothers to answer my cafe question on how to patch 6.12.2 with Simon's GC fixes from trunk...
19:47:58 <aristid> Peaker: maybe if you need liftM4, you're already doing something wrong
19:47:59 <Peaker> apparently not just `infix`, it complains about redundant $ when it isn't
19:48:08 <ivanm> aristid: I beg to differ
19:48:10 <alexyk> the trunk got me 157M in like 30 minutes, I'd really like to avoid a separate 6.12 repo
19:48:14 <Peaker> aristid, I reject such notions :) unless it's a very strong "maybe" :)
19:48:36 <alexyk> I remember you can export patches as files for e.g. email, hope I don't have to do that from trunk to infuse into 6.12?
19:48:37 <aristid> ivanm: functions with many arguments are often unelegant
19:48:44 <ivanm> aristid: arbitrary = liftM4 Foo arbitrary arbitrary arbitrary arbitrary <-- I have quite a lot of things like this
19:48:56 <ivanm> (sometimes with custom rules for different parts rather than arbitrary though)
19:49:10 <Saizan> alexyk: sit in the 6.12 repo, and darcs pull from HEAD only the patch you want
19:49:15 <ivanm> aristid: so you think all functions should have more than one argument?
19:49:16 <Peaker> aristid, inelegant :)
19:49:19 <alexyk> Saizan: thx for -w, now we have ghc and cabal covered, I hope it's about all
19:49:23 <ivanm> s/more/only/
19:49:29 <alexyk> Saizan: alas I got the HEAD first
19:49:34 <Peaker> All functions already do! :)
19:49:37 <alexyk> do I relaly have to get 6.12 too?
19:49:43 <alexyk> full-scale?
19:49:44 <ivanm> Peaker: heh
19:49:54 <aristid> ivanm: no, it's not an absolute rule
19:50:14 <ivanm> anyway, I was referring to the case of using liftM4 for the case of dealing with constructors
19:50:38 <aristid> i guess you can't use record-syntax in monads anyway
19:50:41 <alexyk> actually, why should I bother with 6.12? I guess trunk is good enough
19:50:42 <aristid> so that does make sense, yeah
19:50:52 <alexyk> it's a mongrel anyways and I have to recompile anything
19:50:56 <alexyk> and everything
19:50:57 <ivanm> but I have written functions with multiple arguments, e.g. http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz.html#v%3AclusterGraphToDot
19:51:07 <ivanm> (though I'm thinking of replacing that with a record type)
19:52:02 <aristid> ivanm: the problem with too many arguments is that i always get the order wrong
19:52:07 <aristid> :)
19:52:24 <ivanm> aristid: hence strong static typing!
19:52:25 <ivanm> duh
19:52:27 <ivanm> ;-)
19:52:41 <aristid> heh yeah, and then trial&error until it typechecks
19:52:45 <Peaker> And/or nicer keyword-args in Haskell
19:52:59 <Saizan> oleg solved that, duh
19:52:59 <Peaker> aristid, Ideally, your IDE would show you the args when you type in the name
19:53:02 <aristid> Peaker: keyword-args seem to be rather uncurried
19:53:12 <Peaker> aristid, not necessarily
19:53:18 <Peaker> Saizan, how? you mean OOHaskell?
19:53:28 <Saizan> Peaker: nah, a file in HList
19:53:43 <ddarius> One can have: circle center radius color etc. or one can have: scale radius (translate center (unitCircle `colored` red)) etc.
19:53:57 <Peaker> Saizan, how does it work?
19:54:31 <Peaker> ddarius, It works more nicely when the intermediate parameterizations have meaning
19:54:35 <Peaker> ddarius, I'm not sure they always do
19:54:57 * applicative is thinking, wow, that clusterGraphToDot is hard to take in; I'll stick to crayons
19:55:35 <Saizan> @tell Baughn what i don't like is that it duplicates the same recursion pattern over 3 typeclasses, i think we could abstract that into a single one that provides a lens-like method and write the rest as simple functions over it
19:55:35 <ddarius> Peaker: Usually the difficult part is having generally applicable functions.
19:55:35 <lambdabot> Consider it noted.
19:56:11 <orlandu63> @src ap
19:56:12 <lambdabot> ap = liftM2 id
19:56:17 <orlandu63> @type liftM2
19:56:18 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:56:20 <orlandu63> @type id
19:56:21 <lambdabot> forall a. a -> a
19:56:32 <orlandu63> how exactly does ap work?
19:56:36 <orlandu63> this makes no sense
19:56:41 <Saizan> Peaker: i don't remember, some typeclass magic
19:56:46 <Peaker> @src liftM2
19:56:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:56:55 <Peaker> orlandu63, id is just ($) in this case
19:57:00 <heatsink> It takes a monad that returns a function, a monad that returns an argument, runs both, and applies the function to the argument.
19:57:16 <heatsink> > ap (return (1+)) (return 12)
19:57:17 <lambdabot>   No instance for (GHC.Show.Show (m t))
19:57:18 <lambdabot>    arising from a use of `M5239002942...
19:57:19 <orlandu63> the type signature of id is a -> a
19:57:20 <applicative> @src (<$>)
19:57:21 <lambdabot> f <$> a = fmap f a
19:57:27 <orlandu63> and liftM2 asks for a1 -> a2 -> r
19:57:31 <heatsink> > fromJust $ ap (return (1+)) (return 12) 
19:57:32 <lambdabot>   13
19:57:43 <ddarius> orlandu63: Learn Prolog.
19:57:49 <Peaker> orlandu63, if you unify (a -> a)  with (a1 -> (a2 -> r))  you get a1 = a,   a2 -> r = a,   so a1 = a2 -> r,  so the type is (a2 -> r) -> a2 -> r
19:58:22 <aristid> orlandu63: id becomes ($)
19:58:32 <Peaker> orlandu63, Remember (a -> b -> c)  is simply (a -> (b -> c)) so it's very compatible with  (a -> a),  as the right-side "a" becomes (b -> c) simply
19:58:49 <orlandu63> ah
19:59:06 <orlandu63> i understand
19:59:49 <Peaker> you can also see that: return (f x1 x2)   if f==id, then you get:  return ((id x1) x2) == return (x1 x2)
20:00:22 <aristid> @src ($)
20:00:22 <lambdabot> f $ x = f x
20:00:31 <aristid> lambdabot: i was hoping for ($) = id
20:01:03 <Peaker> pedagogically this is simpler
20:01:05 <applicative> > fromJust $ (return (1+)) <*> (return 12)
20:01:07 <lambdabot>   13
20:02:39 <applicative> @type (<*>) id
20:02:40 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
20:02:44 <aristid> @let (f, g) ~~> h = f ~> g ~> h
20:02:45 <lambdabot>  Defined.
20:03:00 <orlandu63> it'd be more intuitive if ap = liftM2 ($) i think
20:03:07 <aristid> :t ((WrapMonad, WrapMonad) ~~> unwrapMonad) (<|>)
20:03:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:03:11 <aristid> Peaker: :)
20:03:26 <aristid> i'm sure there's a function f x = (x, x) already somewhere
20:03:37 <Peaker> aristid, why the tupling?
20:03:53 <ivanm> @pl \ x -> (x, x)
20:03:53 <lambdabot> join (,)
20:04:01 <aristid> Peaker: to be able to use helper functions
20:04:23 <aristid> @let dup x = (x, x)
20:04:24 <lambdabot>  Defined.
20:04:43 <aristid> :t (dup WrapMonad ~~> unwrapMonad) (<|>)
20:04:44 <lambdabot> Not in scope: `~~>'
20:04:55 <aristid> wtf
20:05:12 <aristid> @let (f, g) ~~> h = f ~> g ~> h
20:05:13 <lambdabot>  <local>:2:17: Not in scope: `~>'
20:05:13 <lambdabot>  
20:05:13 <lambdabot>  <local>:2:22: Not in scope: `~>'
20:05:17 <aristid> ouch
20:05:43 <aristid> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
20:05:44 <lambdabot>  Defined.
20:06:15 <aristid> @let infirx 2 ~~> ; (f, g) ~~> h = f ~> g ~> h
20:06:16 <lambdabot>   Parse error: SemiColon
20:06:23 <aristid> @let infixr 2 ~~> ; (f, g) ~~> h = f ~> g ~> h
20:06:24 <lambdabot>  Defined.
20:06:33 <aristid> :t (dup WrapMonad ~~> unwrapMonad) (<|>)
20:06:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:07:23 <applicative> what was the parse error?
20:07:51 <applicative> oh, infirx
20:08:14 <Peaker> aristid, that's too specific IMO, might as well have ~~> do the dup'ing
20:08:27 <Peaker> (not sure what other things ~~> would be useful for)
20:08:42 <Saizan> @tell Baughn to do so we'd need a typeclass or GADT to deal with Map vs. MultiMap so maybe it's not worth it
20:08:42 <lambdabot> Consider it noted.
20:08:59 <Peaker> I wish Haskell mapped a lot more of its API's to type-classes
20:09:12 <Peaker> a common vocabulary with some meaningful semantics
20:09:26 <Peaker> the ByteString API is just terrible in this regard
20:10:19 <Peaker> btw, maybe StringLike should be named "StringLiteral" and "Num" should be "IntegerLiteral" and it could free up Num to be something more meaningful?
20:10:23 <aristid> @let sec f = (id, f)
20:10:24 <lambdabot>  Defined.
20:10:44 <Peaker> aristid, Nicer to just use id ~> f ~> g  imo
20:11:11 <aristid> Peaker: yeah maybe. was trying to make up stuff
20:11:14 <heatsink> Peaker: We probably won't get any commonly-used type class names changed until some form of class aliases is implemented. 
20:12:03 <Peaker> whatever happened to avoid success? :)
20:12:18 <Peaker> Who would be broken by Monad subclassing Applicative? :)
20:13:37 <heatsink> Oh, I'm for making Applicative and Functor superckasses of Monad
20:13:38 <Saizan> let's just fork GHC and ship it with a different base lib
20:15:20 <ivanm> Saizan: how much of hackage would be broken then?
20:15:40 <aristid> ivanm: every monad without an applicative instance would be broken
20:16:02 <Saizan> aristid: that's not a very informative answer
20:16:10 <Saizan> ivanm: who knows? i bet a lot
20:16:24 <applicative> that wouldnt be to hard to repair.  
20:16:36 <Saizan> it'd be trivial
20:16:39 <applicative> its the rare user of ZipLists who will be ruined.
20:16:49 <Saizan> why?
20:17:16 <applicative> they might be using the ziplist applicative instance and the usual monad instance
20:17:30 <applicative> i guess the only possible monad instance 
20:17:46 <Saizan> i still don't see the problem
20:18:11 <ivanm> no, I meant if you ship a different base library, you would probably have to give it a different name to avoid clashing with GHC's
20:18:42 <Saizan> ZipList is a newtype with only the applicative instance, not monad, and if someone made a monad instance for it somewhere that'd be fine too
20:18:55 <Saizan> ivanm: no, i'd keep the same name
20:19:05 <applicative> I was thinking if one adds the obvious boilerplate it's wreck the applicative instance
20:19:08 <ivanm> Saizan: it would clash with GHC
20:19:25 <Saizan> ivanm: what part of "fork GHC" did you miss?:)
20:19:29 <applicative> no I meant if he used lists with the applicative instance that goes zipwise.  
20:19:53 <applicative> the reason for the newtype ZipList is to keep the clash from happening.
20:20:01 <ivanm> Saizan: the sense that we would then split the Haskell community
20:20:43 <Saizan> applicative: there's no such instance in the stdlib, there's only the cross product instance in Control.Applicative so you can't have a zippy instance for bare lists
20:20:43 * applicative is forming the Hugs-lovers union in order to split the Haskell community.
20:21:19 <applicative> Hmm, i cant say, instance Applicative [] where ... and get away with it?
20:21:39 <Saizan> no
20:22:05 <Saizan> because you can never hide the one in Control.Applicative, since you've to import that to import the class
20:22:10 <aristid> applicative: there already is an Applicative [] instance that coincides with the Monad
20:22:24 <Dashkal> Can someone suggest a haskell tutorial for implemting a language?  The scheme one linked from Learning_Haskell is currently down.  My purpose is basically to see if I'm yet able to handle that task.
20:23:08 <Saizan> do you want to learn monad transformers in the process?:)
20:23:22 <Saizan> or gadts?
20:23:26 <Dashkal> Learning to create one could be handy.  I'm already able to use them.
20:24:16 <Saizan> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.268 <- you could try this
20:24:28 <Dashkal> Danke
20:24:58 <Saizan> augustss' blog also has a few small languages implemented
20:25:32 <applicative> Aristid, yes of course there is; suddenly I'm opposing that. 
20:26:39 * Saizan severily lacks tea
20:26:52 <applicative> severely?
20:26:54 <applicative> ha
20:27:09 <Dashkal> Now if I can just get my printer to stop being stupid...
20:27:24 <applicative> Dashkal, the implementation of Basic is to wonderful to be true
20:27:45 <applicative> Dashkal, well, I suppose it isn't quite true. 
20:28:43 <Dashkal> I'm pondering trying to invent a basic-style scripting language.  Once upon a time I implemted one in java.  I'd rather not repeat that monstrosity.
20:29:04 <Dashkal> Compiled to bytecode for a vm implemented in java.
20:29:45 <applicative> Dashkal, is it just the tutorial you were looking for, there seem to be a million versions of "write yourself a scheme in 48 hours" on google. 
20:30:31 <mle> the problem I had with that tutorial is that I got distracted by the scheme standard and ended up implementing the full numeric tower
20:30:45 <mle> which taught me a LOT about scheme, but not so much haskell.
20:31:14 <applicative> isn't Haskell's Num system somewhat based on Scheme's
20:32:03 <applicative> But then mastering the Num class falls a bit short of mastering Haskell....
20:32:10 <mle> you can do the same things with it, sort of.
20:32:24 <mle> But yes, as I said, it was a distraction.
20:32:36 <Dashkal> applicative: My goal isn't very well defined.  The best explanation I can give is I'm in a learning mood and that's the next interesting puzzle on my list.
20:33:15 <Dashkal> what is it with cups and choking on whitepapers?  I can view them fine, but I try to print and it has a fit.
20:33:50 <mle> ... you use *physical* paper?
20:34:13 * applicative was under the impression that whitepapers were mostly produced by the CIA.  Should he call the ops on Dashkal?
20:34:15 <Dashkal> Dead trees are handy for reading papers while traveling to and from work on transit
20:36:59 <arw_> Dashkal: try various combinations of pdftops, acroread -toPostScript and ps2ps before printing. sometimes it helps, but its very non-deterministic.
20:37:29 <Dashkal> arw_: *nods* That was I did.  Success this time.  Theroms for free I've yet to manage.
20:37:38 <Dashkal> I think I missed a word in there...
20:37:50 <arw_> Dashkal: as a rule of thumb, everything that renders fast in 'gv' also renders fast on a printer. but current computers are so fast, one often doesn't notice the difference.
20:42:28 <Dashkal> Success!  dunno what changed but ps2pdf didn't choke on it this time.
20:42:40 <Dashkal> Thanks for the help.  reading time :)
20:49:14 <JoeyA> > subtract 1 >>= return 5
20:49:14 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> b)
20:49:15 <lambdabot>    arising from a use of `...
20:49:29 <JoeyA> My monad-foo is failing me.  How do I do this?
20:50:00 <JoeyA> I'm just looking for a clever way to use >>= to do f(g(h(x)))
20:50:09 <JoeyA> monad-fu*
20:50:37 <Cale> In the function monad, (f >>= g) x = g (f x) x
20:50:56 <JoeyA> > (subtract 1 <$> (+ 5)) 0 -- I could do this
20:50:56 <lambdabot>   4
20:51:22 <Cale> > ((+) >>= (^2)) 5
20:51:23 <lambdabot>   100
20:51:26 <JoeyA> But my goal is to illustrate applying stacked functions by listing them in "chronological order"
20:51:58 <JoeyA> g(f(x)) is backwards, in a sense.  It's the same as let f' = f(x) in g(x)
20:52:16 <JoeyA> hmm
20:52:41 <Cale> oh, hehe
20:52:52 <Cale> NumInstances :)
20:53:08 <Cale> > ((^2) >>= (+)) 5
20:53:09 <lambdabot>   30
20:53:17 <Cale> ^^ this way is more sensible :)
20:53:41 <JoeyA> Cool
20:53:57 <applicative> > (subtract 1) >>= return (subtract 2) $ 3
20:53:58 <lambdabot>   1
20:54:27 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
20:54:28 <lambdabot>   [5,7,10,25,32]
20:54:53 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
20:54:53 <lambdabot>   ("hello","olleh","HELLO")
20:57:51 <AnAdorableNick> applicative: Splitting the Haskell community generally isn't desirable.
20:58:26 <Cale> AnAdorableNick: ?
20:59:15 <AnAdorableNick> Cale: I'm responding to his comment one screen up.
20:59:51 <JoeyA> > foldl' (flip ($)) 3 [subtract 1, negate]
20:59:52 <lambdabot>   -2
21:00:09 <applicative> AnAdorableNick, I would never willingly do anything to harm the Haskell Community.  
21:00:26 <AnAdorableNick> applicative: Good to know! :)
21:00:28 <applicative> AnAdorableNick, occasionally I do sow confusion.
21:00:44 <applicative> AnAdorableNick, but I aspire to something better.
21:42:23 <Dashkal> Forgive the naieve question (my understanding is only dawning here).  Can any control structure be defined in terms of case and function application?
21:42:48 <kmc> in Haskell?
21:43:02 <Dashkal> more in theory.  I'm whiteboarding language features.
21:43:28 <kmc> all you really need is lambda and application
21:43:37 <kmc> you can encode all algebraic data as functions
21:44:04 <Dashkal> does lambda imply pattern matching?  Else I'm not quite grasping how to define 'if then else'
21:44:17 <kmc> http://en.wikipedia.org/wiki/Church_encoding
21:45:11 <Dashkal> Meh, it's probably time I learned how to read the lambda calculus.
21:47:07 <xcthulhu> Dashkal, Haskell's lambda abstraction allows for pattern matching, which doesn't conform to the textbook lambda calculus
21:47:28 <kmc> Haskell's lambda doesn't let you match several alternatives, however
21:48:29 <Dashkal> I'm trying to define the control structures of a simple language.  So I'm enumerating what's 'core' and what really comes down to syntax sugar.  I realize that if/then/else is really just case for Bool.  Trying to define if in terms of \ is currently beyond my understanding.  Time to fix that.
21:49:00 <kmc> it's not necessarily a good idea to church-encode everything
21:49:07 <kmc> but it's good to understand it
21:49:21 <pikhq> Haskell's lambda is also typed, which makes it a bit unusual compared with the untyped lambda calculus.
21:49:22 <Dashkal> That's more the idea.
21:49:32 <edwardk1> Dashkal: you can define booleans as functions. true = \x y -> x. false = \x y -> y  -- then if is just the application of the boolean as a function to its two arguments.
21:49:49 <kmc> yeah, the link i provided explains that and more
21:50:01 <xcthulhu> Dashkal, Is this for fun/pedagogy?  Or do you want to make a functional DSL?
21:50:32 <xcthulhu> I mean, Haskell has "if (...) then (...) else (...)"
21:50:59 <Dashkal> xcthulhu: The actual goal is to write a scripting language to be interpreted by a haskell program.  The language's purpose is to allow modification of game state in a controlled manner.  However, that goal is really just an excuse to get into language theory.
21:51:14 <xcthulhu> Okay.  DSL
21:51:21 <xcthulhu> Don't use church encoding
21:51:37 <Dashkal> I wasn't planning on it.  But I would like to grasp it.
21:51:45 <Dashkal> Else I'd whip out my old SKI interpreter and use that :P
21:52:14 <kmc> if you are compiling a Haskell-like language and you want to desugar to a minimal core without losing efficiency
21:52:29 <kmc> then you basically need constructors, lambda, application, let, and case
21:54:15 <Dashkal> hmm, constructors may be the worst of that.
21:54:59 <xcthulhu> Dashkal, do you have a data structure figured out for your abstract syntax trees?
21:55:06 <kmc> how so?
21:55:14 <Dashkal> xcthulhu: negative.
21:55:33 <Dashkal> kmc: more what they imply.  Defining a type system is probably too much for my current knowledge.
21:55:40 <Dashkal> solution: learn more
21:56:02 <kmc> i'm not talking about a type system
21:56:08 <xcthulhu> Dashkal, you don't really need a serious type system
21:56:18 <kmc> i'm talking about a language like STG
21:56:21 <Dashkal> in that case I misunderstood.  I was thinking of Type Constructors.
21:56:26 <kmc> i meant data constructors
21:56:34 * Dashkal facepalms
21:56:38 <Dashkal> there I go overcomplicating
21:56:47 <kmc> you might compile to STG from Haskell, but you can throw out most of the types when you do so
21:57:11 <xcthulhu> (data constructors are actually type constructors... you need not fear them)
21:57:35 <kmc> in STG, let is important because it introduces laziness
21:57:45 <kmc> in an operational semantics of STG, it's the only construct which allocates new closures
21:58:04 * hackagebot reflection 0.3.1 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.3.1 (EdwardKmett)
21:58:30 <kmc> case is important because it forces evaluation
21:59:46 <xcthulhu> kmc, he could also just specify seq in the grammar he settles on
22:00:18 <xcthulhu> Dashkal, to make your language, you are going to need to figure out the "abstract grammar" first
22:00:53 <xcthulhu> If you know lisp, the abstract grammar is going to be a specification that you are going to impose on S-expression that you will ultimately parse using a parser
22:01:05 <Dashkal> xcthulhu: *nods* I know.  The problem is this is my first realy foray into this territory.  I've never explicitly defined a grammar in this manner.
22:01:41 <xcthulhu> Dashkal, I think there are some university of washington grad classes for doing this in ocaml... I wonder if I could find them
22:01:53 <Dashkal> My last project of this form I defined a simple VM with a few basic opcodes (compare, jump-if-equal, jump-if-not-equal, call)
22:02:08 <Dashkal> And I defined a basic-like language that compiled directly into those opcodes.  no AST
22:02:32 <Dashkal> erm, missed unconditional jump
22:03:05 <xcthulhu> Dashkal, http://www.cs.washington.edu/education/courses/csep505/06sp/
22:03:26 <Dashkal> danke
22:03:48 <Dashkal> ocaml.  That's a new one for me.  I've only seen it referred to.
22:04:45 <xcthulhu> Dashkal, it's the grampa of haskell.  Basically, it's not pure (has a little state), but strongly typed, and in general has more annoying syntax than haskell
22:04:57 <Dashkal> heh, sounds like fun
22:05:09 <tommd> What?  You don't like ./ and .+?
22:05:15 <kmc> strongly and statically typed
22:05:22 <xcthulhu> Dashkal, ML was developed by uber-nerds to do computer assisted verification of mathematics...
22:05:23 <kmc> and it has some things Haskell doesn't
22:05:43 <tommd> Like strictness.
22:05:47 <tommd> as in, by default
22:06:36 <xcthulhu> And honestly, state is nice... ML was originally developed for computer assisted verification and I haven't ever really been able to figure out how to do this nicely in Haskell within a monad
22:06:41 <Dashkal> laziness is still something I struggle with from time to time.  I keep forgetting to consider that thunks don't need to be evaluated unless forced (foldr looked odd to me until I finally grasped some of that)
22:06:53 <Dashkal> simply from learned habits in strict languages
22:07:07 <xcthulhu> Dashkal, anyway, you don't have to watch all those lectures to get started
22:07:39 <xcthulhu> Those lectures will guide you to developing languages where the semantics is in ocaml
22:07:44 <xcthulhu> Or in this case, Haskell
22:08:14 <Dashkal> I probably need to define the actual use cases for my language a bit more before I settle on semantics.
22:08:39 <kmc> you can make a popular language without ever figuring out the semantics
22:08:40 <xcthulhu> You will want to come up with a little imperative language, which you'll want to specify as a data structure
22:09:29 <Dashkal> actually, imperative (as the term is often abused) is pretty much out.  I want individual scripts to run as functions.  Obtain nput, return result (which may be actions to perform).
22:09:54 <Dashkal> Otherwise actually invoking them will require I do some gymanstics.
22:10:22 <kmc> if you can return actions to perform, that sounds imperative to me
22:10:55 <Dashkal> To try to use the correct terms.  I'm aiming for no side-effects within scripts.
22:11:08 <xcthulhu> Dashkal, do you want to program expressions like "let x = pi^2/6; let y = <in> * x; return x + y" ?
22:11:09 <kulin> kmc is just a bully :)
22:11:20 <xcthulhu> erm, scripts like that?
22:11:30 <Dashkal> If a script must mutate then do something else, it should return actions to mutate and invoke the next part.
22:11:45 <kmc> so it's like imperative programming in haskell
22:11:56 <Dashkal> kmc: With very little access to IO
22:12:03 <kmc> and when you say "no side effects" you mean "function application has no side effect"?
22:12:15 <Dashkal> xcthulhu: Yes, that looks like the kind of thing that should be possible.
22:12:21 <kmc> that's usually what we mean, but it gets lost in translation
22:12:27 <Dashkal> kmc: I believe that's what I'm getting at.
22:12:51 <Dashkal> Or in other words.  Invoking a script should effectively be a -> b
22:13:20 <kulin> how is that different from haskell?
22:13:24 <Dashkal> Exactly what a and b are depend on exactly what the script is doing.
22:13:35 <xcthulhu> kulin, He wants to interpret a scripting language
22:13:53 <kulin> oh interpret
22:14:18 <Dashkal> kulin: The practical case here is I'm writing a MUD.  I don't want to have to have ghc on-hand to do area scripts :P
22:14:44 <kulin> no worries, i believed you had a good reason, i was just curious :)
22:15:02 <Dashkal> And the MUD is really just an excuse to learn interesting concepts.
22:16:13 <Dashkal> bleh, the STG page is over my head
22:17:28 <kulin> with ffi is it possible to return pointers of non-primitive types such as classes?
22:17:33 <xcthulhu> "Exactly what a and b are depend on exactly what the script is doing." <-- this is trickier than you might think
22:18:00 <kmc> kulin, yes
22:18:13 <Dashkal> xcthulhu: a -> b would be defined for any given script.  A script that is invoked in response to a player entering a room would be Room -> Player -> Action, for example.
22:18:17 <kulin> do you know what i should google for? because so far i have found no interesting examples
22:18:30 <Dashkal> xcthulhu: A script that defines an ability would be Player -> Player -> Action
22:18:52 <kmc> kulin, http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
22:19:03 <Dashkal> I don't indend to have scripts be polymorphic.
22:19:10 <kulin> great thanks
22:20:02 <Dashkal> On second thought, it might be simper to go (a, b) -> r.  a -> b -> r introduces complexity that I don't really need.
22:20:28 <Dashkal> simpler*
22:22:47 <xcthulhu> Dashkal, Well, I was thinking you'd write your parser in Haskell. which would parse expressions into a special data-type for you grammar, and you'd do this all with dynamic typing
22:23:16 <Dashkal> xcthulhu: Dynamic typing is very likely what I'm going with.
22:23:35 <Dashkal> I'm not realy to be firm on that.  I'm not sure it's any easier to implement.
22:23:49 <xcthulhu> Dashkal, then you'll want all of your scripts to ultimately be interpreted as "expr -> expr" not "a -> b"
22:24:52 <xcthulhu> Since then you could specify "expr ::= Int i | Float f | String m | ..."
22:25:40 <kulin> it seems like it would be hard to do any scripting language as a cfg
22:26:09 <xcthulhu> kulin, Abstract syntax is a CFG
22:26:28 <xcthulhu> The scripting language itself gets parsed into the CFG
22:26:55 <Dashkal> cfg?
22:27:01 <xcthulhu> context free grammar
22:28:05 <xcthulhu> Data structures in haskell can be understood as "Backus-Naur Form context free grammars"
22:29:17 <xcthulhu> Specifying a data-type you will ultimate parse your scripting language amounts to specifying the grammar you will impose on programs
22:29:39 * Dashkal nods
22:30:02 <Dashkal> and here we run into the issue I'm having.  I have no idea how to specify that.  Trying to work past that now.
22:30:18 <kulin> parsec is great for converting a cfg to haskell types
22:30:45 <edwardk1> hrmm. i'd never seen this paper before. very neat: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.9259
22:30:47 <Dashkal> I'll start with simple arithmatic.  Should at least give me a starting point.
22:30:56 <kulin> but there are other things which cfgs just cant do, like recognize that a type is declared before it is used
22:31:18 <xcthulhu> So ultimately you're going to want something like "data expr = let var expr | while expr expr | expr ; expr | ... "
22:31:25 <Saizan> parsec can do turing complete grammars
22:31:31 <kulin> oh can it?
22:31:39 <kulin> i guess it can do whatever haskell can cant it
22:31:39 <kulin> hah
22:31:44 <Saizan> right :)
22:31:58 <Saizan> though that doesn't mean you should put all your sanity checks in the parser
22:32:54 <Saizan> Dashkal: http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
22:33:27 <Dashkal> Saizan: ooo, that's pretty.
22:34:07 <Saizan> edwardk: lazyArray is something like haskell's listArray?
22:34:31 <xcthulhu> Saizan, nice
22:34:40 <xcthulhu> Dashkal, This is what I have been ranting about
22:39:32 <bos> dcoutts_: 
22:39:48 <bos> dcoutts_: any idea what causes <command line>: cannot satisfy -package Cabal-1.8.0.1
22:39:48 <bos>     (use -v for more information)
22:41:20 <edwardk> Saizan: it looks a bit lazier
22:41:23 <kulin> hah these function names are getting rediculous, setCameraNearClipDistance
22:42:15 <kulin> trying to wrap object oriented code with functional code seems to end up with me writing sentences for function names
22:46:24 <edwardk> Saizan: actually it is lazier. that trick with the buddy helper stuff in 'fi' looks a lot like how one designs a wait-free algorithm
22:49:54 <kulin> lol, so a type to a foreign class is (), awesome
22:49:59 <kulin> works for me
22:52:13 <Saizan> bos: maybe it got shadowed out earlier? what is giving you that error?
22:53:56 * Saizan wonders if it's wise to slip a k^n algorithm in Cabal's configure
22:54:16 <Saizan> k should normally be 2, and n is bound by the number of direct dependencies
22:57:00 <edwardk> i wonder if that lazier array structure can be emulated with a nice functional queue 
23:01:04 <edwardk> hah
23:01:16 <edwardk> i was half way through implementing the lazyArray stuff and found http://hackage.haskell.org/packages/archive/lazyarray/0.1.3/doc/html/src/Data-LazyArray.html
23:07:50 <Saizan> delicious unsafeness
23:08:07 <edwardk> yes
23:08:19 <edwardk> the version in the paper was manually hacking up the resulting c-- ;)
23:15:43 <Saizan> in perl?
23:16:36 <edwardk> they don't really talk about how they inserted the hack
23:19:14 <ManateeLazyCat> Can someone help me find cute Icon for Manatee? I want to use it to release my project. Thanks. 
23:20:03 <whereIsMyMind> hello
23:20:08 <whereIsMyMind> can someone give me a hint
23:20:21 <whereIsMyMind> on how to write function which transform list in this way:
23:20:52 <whereIsMyMind> "aaaBcdeFFFFghii" = aBcdeFghi"
23:20:57 <whereIsMyMind> or in other words
23:21:18 <whereIsMyMind> remove all the elemest which are in sequence and are equal :D
23:21:32 <edwardk> > (map head . group) "aaaBcdeFFFFghii"
23:21:33 <lambdabot>   "aBcdeFghi"
23:21:48 <whereIsMyMind> thx a lot
23:21:51 <edwardk> > group "aaaBcdeFFFFghii"
23:21:52 <lambdabot>   ["aaa","B","c","d","e","FFFF","g","h","ii"]
23:22:03 <edwardk> then head takes only the first element out of each sublist
23:22:16 <Jafet> @hoogle uniq
23:22:16 <lambdabot> Language.Haskell.TH.Syntax type Uniq = Int
23:22:16 <lambdabot> module Data.Unique
23:22:16 <lambdabot> Data.Unique data Unique
23:22:58 <ManateeLazyCat> http://3.bp.blogspot.com/_9pCE8JQVZbc/SdKBqLOybDI/AAAAAAAAA3Q/dgY38ctNvBI/s320/manatee.png I found one ...
23:23:06 <Saizan> edwardk: what's the point of cntr in lArrayMap ?
23:23:28 <edwardk> Saizan: IArrayMap?
23:24:29 <Saizan> it was a lowercase L not uppercase i :), i'm talking about the code here http://hackage.haskell.org/packages/archive/lazyarray/0.1.3/doc/html/src/Data-LazyArray.html
23:24:39 <edwardk> gah i keep tripping over old darcs repos to upload to upload
23:25:39 <edwardk> hrmm
23:26:09 <edwardk> nothing at first glance
23:26:26 <edwardk> i was going to say it might keep the unsfePerformIO's from being shared
23:26:36 <edwardk> but I don't think that is the case
23:28:26 <Saizan> i guess that'd make sense if GHC did some aggressive CSE
23:30:33 * hackagebot QuadEdge 0.2 - QuadEdge structure for representing triangulations  http://hackage.haskell.org/package/QuadEdge-0.2 (NealAlexander)
23:52:56 <edwardk> hrmmf. you can't clone your own repo on patch-tag. how lame ;)
23:53:11 <edwardk> er not patch-tag, github.
23:53:18 <edwardk> (and not clone, fork) =)
23:53:29 <tensorpudding> patch-tag ate my repos lately
23:53:34 <tensorpudding> so I think I'm done with patch-tag
23:53:56 <edwardk> tensorpudding: hence the recent deluge of repos i've been posting on github
23:54:15 <tensorpudding> I just left git, actually.
23:54:25 <tensorpudding> to go to mercurial and darcs
23:54:28 <edwardk> that leaves, what, mercurial and code.google?
23:54:44 <tensorpudding> or bazaar and launchpad
23:54:46 <Dashkal> xcthulhu: Took awhile, but I think I have a workable data structure: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26568#a26568
23:54:52 <tensorpudding> also there's bitbucket
23:55:01 <tensorpudding> which is about the same as github
23:55:13 <edwardk> and repo.or.cz, etc
23:55:28 <edwardk> i flipped over to github because i was collaborating with some folks who were already using it
23:56:47 <whereIsMyMind> can someone help me with this
23:57:15 <whereIsMyMind> i have a list like that: [1,1,1,3,3,2,3,3,3]
23:57:31 <whereIsMyMind> i aslo have this list: [1,2,3]
23:57:42 <whereIsMyMind> and the list [4,5,6]
23:57:46 <whereIsMyMind> what i need to do is
23:58:50 <whereIsMyMind> for every element in the very first list which is repeated 2 or more and is present in the second list i should substitute with corespondig index from the third list
23:59:02 <whereIsMyMind> e.g. 1,1,1 should become 4
23:59:35 <edwardk> now this is definitely sounding like homework ;)
23:59:42 <whereIsMyMind> it is
23:59:43 <whereIsMyMind> :)
23:59:51 <whereIsMyMind> i was missing whole second term
23:59:56 <edwardk> i'll give you couple of hints
