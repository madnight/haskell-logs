00:02:57 <ManateeLazyCat> zeiris: Of course, HList maybe more powerful, but HList need change regular-record to HList record. So nested-tuple is cheaper if you just use polytechnic-type simplely.
00:04:06 <ManateeLazyCat> s/polytechnic/polymorphism
00:07:06 <zeiris> Does GHC have some extension for replacing all "strings" with ByteStrings?
00:07:20 <ManateeLazyCat> OverloadedStrings ?
00:07:26 <zeiris> Thanks :)
00:07:38 <ManateeLazyCat> zeiris: I use it replace all "String" to "Text"
00:07:55 <ManateeLazyCat> zeiris: I haven't test ByteString, but should work.
00:08:44 <zeiris> I don't need no unicode, 8 bits was good enough for my parents it'll be good enough for me...
00:10:07 * ManateeLazyCat Unicode is right choose for international program.
00:10:31 <ManateeLazyCat> I always use unicode since i'm Chinese.
00:10:53 <ManateeLazyCat> BTW, Text is much much faster than String.
00:11:55 <Gracenotes> ALWAYS
00:12:09 <Gracenotes> (..I want to be with you, and make believe with you..)
00:12:30 <Lajla> zeiris, your parents most likely used 7, 6 or even 31 or 36 bits.
00:13:04 <wli> I think 36-bit affairs had 5 characters per word.
00:13:10 <p_l> wli: 6
00:13:39 <p_l> at least when you used packed formats that tried to fit maximum number of characters in a word
00:16:39 <wli> Yeah, they varied the format. It got ugly at times.
00:20:05 <p_l> some after-effects of that were visible quite long (like many pascal implementations inheriting limit of 10 significant case-insensitive characters for symbols)
00:22:46 <Lajla> Other affect-efects being the fact that Pascal has ever existed.
00:23:10 <p_l> heh
00:23:23 <p_l> still, 60bit word - that was an unusual size...
00:23:36 <wli> I'm not sure how Wirth ever got popular.
00:24:28 <Lajla> wli, he designed Pascall, people like to use Tuples in place of lists to hold characters to encode strings, you never noticed?
00:25:02 <Lajla> I much rather write my functions to hande ('S','t','r','i','n','g') in lieu of "String"
00:25:22 <p_l> wli: Pascal was easy and somehow standardised and supported Structured Programming.
00:25:36 <Lajla> Didn't Algol do that, p_l?
00:25:40 <p_l> Similar how C++ probably would never got far if not for popularity of OOP at that point
00:25:50 <p_l> Lajla: *which* algol?
00:26:15 <edwardk> Lajla: i hardly consider algol as 'easy' =)
00:26:18 <Lajla> Some people would chain you to a chair until you admit that C++ is not OOP, Alan Kay included if he didn't have his morning dose of coffee, but I respect diversity.
00:26:24 <Lajla> p_l, why, Algol 60 of course.
00:26:28 <Lajla> I have it in Scheme here.
00:26:38 <Lajla> I never tried it, but I've been told it works.
00:27:16 <p_l> Lajla: AFAIK there was no usable compiler of ALGOG 60 that covered everything (or it was ALGOL68?). Pascal was much simpler
00:27:36 <Lajla> p_l, what is 'everything'?
00:27:47 <wli> p_l: '60 was the complicated one. '68 was dumbed down.
00:27:50 <p_l> the same goes for PL/I, which never really agreed on single standard
00:27:57 <Lajla> Maybe it was 68, as far as I know, 60 had no I/O in its standard.
00:28:25 <p_l> wli: right. By that time, Pascal starts to show up, with existing implementation and a textbook
00:28:29 <Lajla> wli, wasn' 58 the complex one and 60 the simpler one and 68 the overly complex one that no one liked or agreed about?
00:28:55 <edwardk> If I want to program in Algol 68, I'll just program in Go. http://www.cowlark.com/2009-11-15-go/
00:29:01 <Lajla> Oh, what do you all know, obviously Pascall only got on because of the flashy name of the Turbo Pascall implementation.
00:29:20 <p_l> wli: now, do you write a compiler from scratch in assembly for a complex language, or do you take an existing implementation and start from there?
00:29:21 <Lajla> Ten cents for the first person who can write a turing complete tarpit based on Go playing rules.
00:29:34 <p_l> Lajla: Turbo Pascal arrived *much* later
00:29:46 <Lajla> p_l, I am being sarcastic towards the awkward name actually.
00:30:01 <edwardk> Lajla: you'll need to relax at least the ko rules to get turing completeness ;)
00:30:10 <Lajla> Maybe it was cool back then.
00:30:36 <Lajla> edwardk, there has to be some AI on an infinite go board that can make it turing complete.
00:30:51 <edwardk> ok, with an infinite board you can probably do something
00:31:12 <edwardk> that'll let you work around the fact that eventually ko rules would box you in to no moves remaining
00:31:17 * jesusabdullah waits for Turbo Haskell
00:31:23 <Lajla> Sure, you just get an AI that plays via some deterministic rules, and gogogo.
00:31:35 <edwardk> jesusabdullah: i've been wanting to use that as a name for a haskell compiler for so long ;)
00:32:00 <Lajla> I would call it Jazzkell and be hipper than you all.
00:32:45 <Twey> Oh yeah, introduce *more* confusion when we tell the laymen what we're using, why don't you :Ã¾
00:33:02 <jesusabdullah> edwardk: You could make an ide and name it Turbo Haskell. Could be easier!
00:33:21 <edwardk> jesusabdullah: yeah but to me the main turbopascal experience was all about the near-0 second compile times
00:33:34 * hackagebot ad 0.44.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.44.0 (EdwardKmett)
00:33:51 <Lajla> Twey, you're not implying you program functionally for another reason than to appear interesting, are you?
00:34:08 <edwardk> now with actual documentation on the main hackage page!
00:34:14 <edwardk> (and variadic grad)
00:34:22 <Lajla> People fear what they not understand, unless it tells them what they want to hear, then they love it.
00:34:53 <Lajla> 'Quantum field theory implies that women are aequal to men, maybe a little bit better!' And all feminists suddenly enjoy quantum field theory.
00:35:04 * Lajla h5's Sokall.
00:41:44 <hydo> Using Maybe and 'lookup' as examples, what would be the right way to combine two uses of lookup but be able to use the intermediate value?  ie. lookup "key" list >>= \x -> lookup x list <|> Just "Nope".
00:42:12 <hydo> kindof a bad example, I guess... I wouldn't actually write that, but I think you get the idea.
00:43:05 <ezyang> hdyo: >>= is definitely something you want to use 
00:43:22 <hydo> hrm... I think I just answered my own question. "That's not really possible."  the second lookup couldn't be a lookup.
00:43:32 <ezyang> Why not? 
00:43:34 <Cale> huh?
00:43:39 <hydo> heh
00:44:03 <hydo> What i'd like to do is say something like
00:44:36 <Cale> > let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in do x <- lookup 1 pairs; lookup x pairs
00:44:37 <lambdabot>   Just 2
00:44:45 <Cale> > let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in do x <- lookup 1 pairs; y <- lookup x pairs; return (x,y)
00:44:47 <lambdabot>   Just (5,2)
00:45:32 <hydo> I guess I was trying to avoid do.
00:45:58 <johnw> can you do that one with a list comprehension?
00:46:23 <hydo> The problem is that I have huge code smells all over my project where I case down a set of Maybe a
00:47:16 <hydo> I can kill most of them with applicative, but some require a value out of a maybe above it.
00:47:36 <hydo> refactoring code you wrote when you were really green with haskell = ugh.
00:47:51 <ezyang> hydo: Until you get good enough, then it's zanily fun. 
00:49:19 <hydo> let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in do x <- lookup 9 pairs; y <- lookup x pairs; return (x,y)
00:49:25 <hydo> oh
00:49:29 <hydo> > let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in do x <- lookup 9 pairs; y <- lookup x pairs; return (x,y)
00:49:30 <lambdabot>   Nothing
00:50:25 <hydo> Thanks, Cale, and ezyang.
00:50:30 <c_wraith> when that's the type of operation you're doing, it's worth looking at things like
00:50:34 <c_wraith> :t liftM2 (,)
00:50:35 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
00:51:19 <c_wraith> Note that liftM2 is exactly just abstracting the pattern you used there.
00:51:33 <c_wraith> @src liftM2
00:51:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:52:06 <jesusabdullah> @src foldl'
00:52:07 <lambdabot> foldl' f a []     = a
00:52:07 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:53:02 <jesusabdullah> @src foldl
00:53:03 <lambdabot> foldl f z []     = z
00:53:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:58:21 <ezyang> wow, monadic regions are pretty 
01:10:52 <edwardk> ezyang: yeah
01:10:59 <kfmfe04> testing
01:13:03 <kfmfe04> hi - I'm just starting out in Haskell - came across Clean during my search.  Anyone can share his/her experience with Clean vs Haskell?
01:14:56 <edwardk> kfmfe04: clean has uniqueness typing, which is how they duck the io/mutability question
01:15:34 <Twey> kfmfe04: Smelly, proprietary, runs only on Windows, loses flexibility thanks to uniqueness typing instead of doing it in a monad like Real Men
01:15:47 <mreh> If I'm unboxing strict fields, they get reboxed if I pass them to a lazy function? right?
01:15:56 <edwardk> haskell has in general, imho a cleaner type system and is easier to do things like partial application with, because they don't have the huge problems that uniqueness causes, this lets the haskell guys get away with adding a lot of other features to the type system that would be hard to fit in in clean
01:15:58 <Cale> kfmfe04: Clean and Haskell are quite similar in a lot of ways. The main interesting thing that Clean has are uniqueness types. You can enforce that a parameter to a function is used in only one place. Knowing that there's a single reference to a given value allows the compiler to reuse the memory associated with that value as soon as it is consumed.
01:16:00 <Twey> Oh, it's available for more platforms now, apparently, but crippled
01:16:20 <Cale> But yeah, Haskell has lots of other cool stuff that Clean doesn't. :)
01:16:39 <ski> johnw : every `do'-block in the list monad can be translated into a list comprehension (and vice versa)
01:16:42 <kfmfe04> great - thx for the input!  I will stick with Haskell then
01:16:57 <edwardk> the fox (haskell) knows many things, but the hedgehog (clean) knows one big thing.
01:17:17 <jedai> There's also a much better dynamic around Haskell now, so for things like libraries Haskell is better
01:17:38 <edwardk> i keep wanting to like clean
01:18:00 <jlouis> I've never tried Clean for real
01:19:16 <mreh> jedai: people have used the opposite excuse to not use Haskell
01:19:21 <mreh> it makes me uneasy
01:20:20 <jedai> @mreh : True, but if you want to make a comparison of Clean and Haskell for real-world applications right now, it enters the picture for sure
01:20:20 <lambdabot> Maybe you meant: free more
01:22:06 <Twey> Heh
01:22:14 <ski> > let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in [(x,y) | x <- lookup 1 pairs , y <- lookup y pairs]  -- johnw
01:22:15 <lambdabot>   Couldn't match expected type `[t]'
01:22:15 <lambdabot>         against inferred type `Data.Mayb...
01:22:16 <jedai> mreh: Not that I say that its popularity should be the first factor to try a language, just that if you have two pretty similar languages and are trying to determine which to try, it doesn't hurt to consider this factor too
01:22:22 <edwardk> heya ski
01:22:24 <Twey> I feel like HXT is an awesome library that would serve all my XML needs, if I could only comprehend itâ¦
01:22:40 <ski> er, actually, that's using `Maybe' i just realized :D
01:22:47 <edwardk> that tensors trick is now actually being used
01:23:15 <mreh> ghc -fforce-recomp --make -O2 -funbox-strict-fields -fexcess-precision -fvia-C -optc-O3 -optc-fno-float-store Main.hs -- these are my compiler options, but if I remove some strictness it gets faster!
01:23:25 <jedai> mreh: Generally people that used this excuse not to try Haskell were comparing it to completely different languages, so it didn't make much sense
01:23:26 <Twey> ski: ây <- lookup y pairsâ looks iffyâ¦
01:23:28 <ski> > let pairs = [(0,1),(1,5),(2,3),(5,2),(4,4)] in [(x,y) | x <- maybeToList (lookup 1 pairs) , y <- maybeToList (lookup x pairs)]  -- johnw
01:23:28 <lambdabot>   [(5,2)]
01:23:37 <ski> Twey : yes, typo :)
01:23:37 <mreh> so that means that it's not loosing performance to reboxing I suppose
01:23:39 <Twey> Ah, there we are
01:23:52 <mreh> jedai: well yes
01:23:59 <ski> (i assume `y :: Expr' made that slip past the unbound identifier check ..)
01:24:29 <mreh> preflex seen: dafis
01:24:51 <mreh>  preflex!!!
01:25:16 <ski> edwardk : 'iya
01:26:08 <ski> preflex: xseen dafis
01:26:08 <preflex>  dafis was last seen on freenode/#haskell 13 hours, 9 minutes and 26 seconds ago, saying: mreh: read me?
01:27:11 <mreh> @tell dafis I've doubled the filter's performance by removing some strictness. I can't explain why. You might want to see this.
01:27:11 <lambdabot> Consider it noted.
01:28:44 <edwardk> ski: with the scaffolding in place the gradients function would up being kind of ridiculously easy http://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Mode/Sparse.hs
01:28:58 <gio123_> ski:hi
01:35:52 <ezyang> It just occurred to me... are monads sort of like functor monoids? 
01:36:06 <ezyang> (i.e. monoids where the arrows are functors?0 
01:36:38 <Veinor> @quote endofunctor
01:36:39 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
01:36:46 <ski> @quote category.of.endofunctor
01:36:47 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
01:36:48 <Twey> So yes
01:36:57 <Veinor> ttants: wadler, wdaher
01:37:05 <Twey> Haskell functors are endofunctors (Hask -> Hask), IIRC
01:37:20 <ezyang> holy smoke! 
01:37:34 <ezyang> I guess that statement finally clicked. 
01:37:56 <ezyang> (I was staring at join and thinking, "that kind of looks like composition...") 
01:38:02 <ski> well, not if you define `class FunctorFunctor t where tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> t f a -> t g a', or what-have-you ..
01:38:23 <ski>   return :: id -> m
01:38:29 <ski>   join :: m . m -> m
01:38:40 <Twey> ezyang: Hehe
01:38:43 <edwardk> ezyang: they are exactly like 
01:38:48 <edwardk> "functor monoids"
01:38:54 <ski> this is an associative binary operation with a (left and right) unit
01:39:03 <ezyang> right, and they have to be endofunctors since there's only one object 
01:39:13 <ezyang> ding ding ding ding 
01:39:16 <ski> huh ?
01:39:37 <ezyang> ski: Re endofunctor comment? 
01:39:58 <edwardk> ezyang: now restate that in the form of a right kan extension and claim your cookie ;)
01:40:17 <ezyang> I, uh, need to understand what Right Kan Extensions are first. The cookie'll have to wait :-) 
01:40:43 <danharaj> category-extras should be renamed to `Maclane' :p
01:43:09 <ezyang> I wonder if we can write an instance Monoid for Monad 
01:43:11 <ski> ezyang : er .. oh, right; there only one object, *where* ?
01:44:16 <ski> ezyang : if you define `newtype All f = WrapAll (forall a. f a)', then you can probably make a `instance Monad m => Monoid (All m)' ..
01:45:33 <ezyang> Those... aren't necessarily endofunctors... 
01:45:55 <ski> which ?
01:46:00 <ezyang> f 
01:46:12 <ezyang> oh 
01:46:15 <ezyang> duh 
01:47:35 * ski stares perplexed at ezyang
01:47:48 <ezyang> You put the Monad m => constraint and I missed it. 
01:48:08 <ezyang> trying to remember why you need the existential 
01:48:17 <ski> no existential in sight ..
01:48:34 <ezyang> Oh, what's WrapAll (forall a. f a) ? 
01:48:53 <ski> (but possibly `instance Monad m => Monoid (Some m)' would work as well ?)
01:48:54 <ezyang> (I'm used to parsing forall in funny places as an existential, pardon me. 
01:48:59 * ski considers it
01:49:35 <m3ga> whats the best way to interact with a HTTPS web server from Haskell code? I need to do a POST and get some data back.
01:49:57 <Twey> Via curl, I imagine
01:50:04 <ski> actually, i suppose the `mempty' wouldn't work with the `All m' version
01:50:18 <edwardk> ski: perhaps something like data Nat m = Succ (m (Nat m)) | Zero (m ())
01:50:47 <m3ga> Twey: you mean calling the curl binary using System.Process or something?
01:50:57 <Twey> m3ga: No, there's a binding on Hackage
01:51:19 <Twey> cabal install curl
01:51:52 <m3ga> the binding doesn't actually seem to support the POST method and retrieving a response
01:52:21 <ski> edwardk : hm .. would that be some kind of freeish monoid .. ?
01:52:22 <m3ga> is has this : curlPost :: URLString -> [String] -> IO ()
01:52:32 <m3ga> which is just insanely broken
01:53:08 <edwardk> ski: no idea ;)
01:54:16 <Twey> m3ga: It does
01:55:22 <m3ga> Twey: i'm reading the docs on hackage and its not jumping out at me
01:56:36 <Twey> See Network.Curl.Easy.initialize, Network.Curl.Opts.CurlWriteFunction, Network.Curl.curlPost
01:56:42 <ski> edwardk : `Nat m' sounds almost like `FreeMonad m ()' where `data FreeMonad m a = Return a | JoinLift (m (FreeMonad m a))'
01:57:17 <ski> (more like it if you replca your `Zero (m ())' with `Zero ()' or plain `Zero')
01:57:21 <ezyang> Oh, I see the problem 
01:57:41 <edwardk> ski: yeah i was lazy with that one
01:57:47 <edwardk> Zero should be Zero ()
01:58:09 <ezyang> mempty/mappend are functions on Hask, but they actually want to be functors, which aren't just functions 
01:58:22 <ezyang> well, mappend takes functors as arguments 
01:58:45 <ezyang> So you'd need some encoding of functors as values in Hask to write an instance. 
01:59:21 * ezyang now rereads what ski wrote 
01:59:26 * edwardk is struggling to fully grok taylor models =/
01:59:48 * ski now rewrites what ezyang read
01:59:52 <ski> :P
02:00:37 * ski wonders what type system extension would be required to be able to say a monad is a monoid ..
02:01:03 <ezyang> Clearly we need upwards social mobility 
02:01:13 <ezyang> :^) 
02:01:16 <edwardk> ski: kata ? =)
02:01:37 <edwardk> it works beautifully if you just rip out the types
02:01:40 <ezyang> I think I'll sleep on this one. 
02:01:45 <Veinor> I think upward is 'ana' :P
02:01:45 <ezyang> g'night all! 
02:02:00 <edwardk> Veinor: hah
02:03:35 <ski> ezyang : been reading "Categories for Software Engineering" by José Luiz Fiadeiro ?
02:03:52 <ski> (.. apropos "social mobility")
02:04:11 <Veinor> cast off the shackles of your typeclass oppressors!
02:04:38 <ski> edwardk : well, usually i'd not call ripping out all the types a type system *extension* .. :)
02:06:51 <ski> ("The best summary of the essence of category theory that I know is from the logician Jean-Yves Girard.[1] For him, category theory characterizes objects in terms of their \"social lives\".")
02:10:53 <mreh> does darcs use vim? That was confusing
02:11:05 <FauxFaux> It probably launched EDITOR.
02:11:45 <mreh> echo $EDITOR is blank...
02:11:50 <mreh> curious
02:12:11 <mreh> and when he checked the enivronment variable, it was blank!
02:14:18 <jesusabdullah> D: D:
02:14:32 <jesusabdullah> DONT OPEN THAT TARBALL----
02:16:47 <mreh> @arr!
02:16:47 <lambdabot> Swab the deck!
02:20:30 <jlouis> mreh: VISUAL set?
02:20:30 <Twey> Is returnA always âarr idâ?
02:22:17 <ski> @src returnA
02:22:18 <lambdabot> returnA = arr id
02:22:25 <ski> (.. and it's not a class method, so ..)
02:23:28 <Twey> Aha
02:23:29 <Twey> Thanks
02:33:55 <xarch> hi 
02:34:17 <Twey> xarch: Hello
02:37:06 <xarch> I've got a problem using the LLVM binding: when I try to launch my executable, I get an user error ("user error (Interpreter has not been linked in.)"), and I've found this is caused by the use of the JIT. How can I fix that ? 
02:39:31 <ksf> I enabled UndecidableInstances without regret, but now I'm a bit afraid of OverlappingInstances
02:40:06 <ksf> that stuff is wholly unrelated, but still...
02:42:17 <byorgey> ksf: OverlappingInstances is quite a bit scarier than UndecidableInstances.
02:52:05 * ksf has a look at derive, gets scared and settles for CPP, instead
02:52:35 <ksf> ...which incidentally also gives a good opportunity to get rid of UndecidableInstances
02:57:53 <benmachine> mreh: browse env, there might be VISUAL or something
02:58:02 <benmachine> mreh: or it might be the default when all else fails
03:00:01 * ksf wonders what suffix to use for cpp includes
03:00:43 <benmachine> .includefile
03:00:48 <ksf> ouch
03:00:52 <ksf> I'd rather use .pp
03:00:55 <benmachine> :P
03:01:15 <benmachine> is there anything wrong with .h?
03:01:29 <benmachine> well I guess that's C header really
03:01:32 <ksf> it's not a c header
03:01:43 <benmachine> I've seen it used for generic header
03:01:47 <ksf> .i?
03:01:50 <benmachine> but in C projects so that's probably why
03:01:54 <benmachine> .inc
03:01:58 <ksf> yep
03:04:05 <ksf> life can be so easy with a wee bit of preprocessor hacking
03:06:38 <benmachine> I never liked cpp
03:06:48 <benmachine> I wish something like TH could do its job
03:06:55 <benmachine> but it isn't really what TH is for I guess
03:07:14 <ksf> sometimes text-based stuff is just way less of a headache
03:07:50 <chrisdone> parameterized modules seems to fix many issues cpp is used to solve
03:08:31 <ksf> can it define a data type and derive four boilerplate classes for me?
03:08:55 <chrisdone> can cpp?
03:08:59 <ksf> it can.
03:09:08 <chrisdone> balls!
03:09:27 <ksf> it's a straight-forward two-argument macro.
03:11:08 <chrisdone> ksf: can i see?
03:11:43 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26099#a26099
03:13:20 * ksf is reminded of his asm days and ponders being evil and using the same old perl script to generate stuff from linux/errno.h
03:15:50 <ksf> well, I guess as long as the evil mangler exists it's morally correct to do it.
03:16:50 <McManiaC> whats the syntax of Text.Regex for regular expressions?
03:17:04 <McManiaC> I tried "^(\\d)$" but it didnt work
03:17:05 <McManiaC> ^^
03:17:09 <ksf> you don't want to use regexen, you want to use a proper parser.
03:17:48 <ksf> ...unless you want to do an interface where the user can provide regexen, that is.
03:18:06 <McManiaC> jup that is.
03:18:07 <McManiaC> :P
03:18:21 <McManiaC> and I know about parsers...
03:18:21 <ksf> I'd recommend prce, then
03:19:22 <ksf> more than once did I try to use sed and ended up using perl, instead.
03:27:45 <m3ga> @hoogle (a, b) -> a
03:27:45 <lambdabot> Prelude fst :: (a, b) -> a
03:27:45 <lambdabot> Data.Tuple fst :: (a, b) -> a
03:27:45 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
03:29:44 <chrisdone> i like that you're so new that you don't know about fst, but are also so awesome you searched for it by type
03:30:14 <m3ga> i'm a refugee from ocaml.
03:30:21 <Twey> Haha
03:30:27 <m3ga> so types are no mystery for me
03:30:29 * exDM69 is a recovering c++ programmer
03:30:40 <Twey> exDM69: Eek
03:31:04 <m3ga> i do C++ and ocaml in my day job
03:31:15 <m3ga> much prefer ocaml
03:32:24 <exDM69> but C++ is pretty nice in many aspects. and it just got a lot better now that std::function and lambda expressions are available on mainstream compilers
03:33:20 <exDM69> the template-based type system is pretty hack-ish, but it's actually quite expressive
03:33:38 <exDM69> (and full of caveats)
03:33:39 <byorgey> Turing machines are quite expressive too.
03:34:31 <mreh> you're kidding right?
03:35:15 <byorgey> you can express anything you want with a Turing machine! =)
03:35:26 <tensorpudding> Turing machines are the little universal computer that could
03:35:27 <exDM69> mreh: me? no. you can actually build quite nice small DSL's with C++ templates.
03:35:45 <mreh> i was talking to byorgey :)
03:36:00 <tensorpudding> You can get anywhere, but only when you try really hard, and you think you can, you think you can
03:36:04 <ksf> wasn't there a cpp option that made it keep #define lines?
03:36:12 <mreh> Perlis would have your balls
03:36:56 <mreh> it's a good thing the lambda calculus is as equally as expressive
03:39:31 <chrisdone> turing tarpits
03:40:55 <chrisdone> U = Î»f.((fS)K)
03:41:32 <chrisdone> S = U(U(UU))
03:41:37 <chrisdone> K = U(UU)
03:42:04 <tensorpudding> there can only be one combinator
03:42:24 <mreh> is Y enough?
03:54:35 <ksf> c++ macros _might_ have been good if they went out to do a turing-complete, pure functional language, in the first place.
03:55:31 <ksf> it might be interesting to see what happens if you do exactly such a thing for plain olde C
03:56:06 <ksf> like, generating C from haskell :)
03:57:15 <ksf> ...and I don't think I'm going to get cpp to give me a list of defines
03:58:41 <ksf> the cpphs library can do that, but it chokes on the GNU part of the headers, so I'd have to parse <linux/errno.h> instead of <errno.h>
03:59:45 * ksf tables the topic
04:06:33 <ksf> oh, and ccphs/ghc and gcc have a strange difference wrt. interpreting ""
04:07:46 <Ke> [] :: String ?
04:08:07 <ksf> yes, why not?
04:08:17 <ksf> type String = [Char]
04:08:30 <ksf> :t []
04:08:31 <lambdabot> forall a. [a]
04:08:34 <Ke> but what's the other interpretation?
04:08:51 <ksf> [] is polymorphic in the element type.
04:09:02 <ksf> which shouldn't come too surprising, as it doesn't contain any.
04:10:01 <ksf> :t [] :: String
04:10:02 <lambdabot> String
04:10:10 <ksf> :t [] :: [Int]
04:10:10 <lambdabot> [Int]
04:10:21 <ksf> :t [] :: [a]
04:10:22 <lambdabot> forall a. [a]
04:11:28 <ksf> the type is fixed only later on, if necessary, in case the type inferencer needs to unify it with a concrete element type.
04:11:56 <ksf> that's haskell's notion of duck typing, so to speak.
04:12:55 <Ke> I know
04:13:20 <Ke> but did you mean "" is interpreted as polymorphic []
04:13:30 <ksf> :t ""
04:13:31 <lambdabot> [Char]
04:14:13 <ksf> imagine a "" :: String; "" = [] somewhere.
04:32:41 <ivanm> preflex: seen tomberek
04:32:41 <preflex>  tomberek was last seen on #haskell 6 days, 1 hour, 12 minutes and 10 seconds ago, saying: copumpkin.. what about coq?
04:37:26 <Blkt> good day everyone
04:37:33 <chrisdone> hello
04:37:47 <chrisdone> ^_^
04:38:37 <Blkt> :D
05:21:28 <mreh> are all these (++) in the list monad not at all costly, or does associativity and laziness eliminate it
05:21:54 <mreh> when you're unpeeling such a list
05:27:02 <zygoloid> mreh: concat is efficient.
05:27:47 <mreh> because of it's right associativity
05:28:18 <mreh> O(n) is not that efficient in practice
05:28:21 <zygoloid> because it's a foldr
05:28:27 <zygoloid> it's only a constant overhead
05:28:31 <Twey> @src concat
05:28:31 <lambdabot> concat = foldr (++) []
05:28:34 <zygoloid> the O(n) is building the list-of-lists in the first place
05:28:49 <zygoloid> (a constant /factor/ overhead, to be clear)
05:28:49 <interferon> what does it mean to talk about "tying the knot" in haskell?
05:29:21 <zygoloid> i mean, using concat can't make your asymptotics worse
05:29:24 <Twey> interferon: It's the title of a page about recursive data-structures.
05:30:11 <zygoloid> interferon: the basic idea is that you make a data structure generator :: a -> a, then take the fixed point, in order to allow your data structure to reference itself
05:49:12 <Gracenotes> yay for iPwn then - http://www.macrumors.com/2010/06/11/apple-eases-up-on-restrictions-on-interpreted-code-in-iphone-developer-agreement/
05:49:49 <Gracenotes> though still boooo for apple
05:50:11 <luite_> explicit approval required... :(
05:50:36 <hpc> all that article really says is Mac went from 10 to 8 on the unreasonable scale
05:50:36 <Gracenotes> booooooooooooo
05:51:25 <luite_> hpc: not really Mac (OS X) but iPad/Pod/Phone (iPhone OS / iOS)
05:51:45 <hpc> er, yeah i meant Apple
05:52:16 <hpc> i liked when they sold "Macintosh", not "Mac"
05:54:46 <Randroid> I think they should allow software written in any language, though I probably wouldn't use Haskell to write Mac/iPhone apps, as it's a bit orthogonal to their existing APIs.
05:55:49 <arw_> who cares about iphone, thats only 20% of the smartphone market and an even smaller percentage of the whole mobile phone market.
05:55:53 <blackdog> Randroid: "should" from a business perspective, or from a software freedom one?
05:56:04 <aristid> hpc: and when they didn't pretend that linux users don't exist. they say "Mac or PC" as if everybody used either mac os x or windows
05:56:17 <blackdog> they're a massive percentage of people who actually pay for apps on the phone, though.
05:56:44 <hpc> aristid: the ironic thing is, their line of thinking is what killed their market share to begin with: "oh, everyone uses windows"
05:56:45 <Randroid> blackdog: "should" from a business perspective. As a libertarian, I think they should be allowed to do anything they want with their platform.
05:57:05 <aristid> Randroid: there is somebody here who uses haskell to write iPod/iPhone games. forgot the nickname tho
05:57:17 <blackdog> blackh. i did a bit of work with him on it.
05:58:13 <aristid> hpc: well, maybe they think linux is a greater threat than windows ;)
05:58:31 <hpc> aristid: wouldn't that be nice?
05:58:55 <blackdog> i think there's a reasonable business case for keeping control of the platform. they don't need to worry so much about pissing off developers any more, and putting restrictions on cross-platform-ness means that they only get purpose-written apps (and more to the point, other platforms don't get the apps that are written for them)
05:59:06 <blackdog> i wish it were otherwise.
05:59:39 <Randroid> aristid: That's good to hear! I can imagine a game being done, and of course as a general-purpose language, one can write anything in Haskell in theory. However, I think APIs have a certain style. For instance, the Cocoa APIs are clearly designed for a dynamic OO language. I think any Haskell written against them would be pretty ugly.
06:00:36 <blackdog> a large sector of games are written against just opengl - the cocoa apis don't much come into it, except for gathering data from the net, gps, accelerometer stuff.
06:01:08 <Randroid> I'm not a gamer, so most of my apps are straight-up Cocoa. I think I play Blackjack and Texas Hold 'Em on my iPhone. That's about it.
06:02:11 * Randroid is a Mac user and Apple fan, and has also made a pretty penny off of Apple stock
06:03:13 <aristid> Randroid: games aren't usually written for the platform at all
06:03:22 <aristid> i mean, sure they run on it
06:03:27 <aristid> but mostly it's a game
06:03:33 <aristid> they don't use a lot of standard widgets
06:03:45 <blackdog> the iPwn guys should be ok there. you can get an opengl context on android just as easily.
06:04:01 <aristid> blackdog: in java?
06:04:10 <hpc> coding on the android is frustrating
06:04:11 <blackdog> probably easier, if JWZ's rant about porting his screensaver was correct
06:04:17 <Randroid> aristid: I agree. That's a case where I think Haskell would be just fine. But I'd prefer to write ObjC code if I were dealing with the standard widgets like UITableView, etc.
06:04:20 <blackdog> ah, i'd forgotten that. you don't get native access, hey.
06:04:21 <blackdog> hm
06:04:38 <blackdog> we really need to get on that jvm port:)
06:05:01 <aristid> blackdog: i think you do get native access under some conditions
06:06:03 <Randroid> I just can't do Android. My dislike of Java is too strong. I'm sure it's completely irrational and I can't justify it, but I just don't like it.
06:06:28 <aristid> Randroid: well, you could use clojure or so
06:06:48 <Randroid> I'm curious about Google's "Go" language. Now *that* might be interesting.
06:06:54 <Twey> It's not
06:07:01 <Twey> Clojure's quite nice, though.
06:07:06 <aristid> Randroid: or maybe Scala, which is a ML dialect afaik
06:07:10 <hpc> Go is basically Perl with C syntax, from what I have seen of it
06:07:24 <hpc> nicer than Perl, but not interesting
06:07:38 <mauke> I thought Perl was Perl with C syntax
06:07:47 <Twey> Randroid: http://www.cowlark.com/2009-11-15-go/
06:07:50 <aristid> maybe i should learn scala or clojure so i can use the platforms where java is mandated :D
06:07:51 <Randroid> hpc: Not interesting syntactically, perhaps, but what I meant was that it might be more interesting to write Android apps in that instead.
06:08:10 <aristid> Randroid: why not clojure/scala?
06:08:13 <hpc> ah, well Go doesn't run on android anyway, so the point is moot
06:08:37 <Randroid> Clojure would be fine, though my Lisp skills are pretty rusty.
06:08:41 <Twey> I think I'd rather use Clojure than Go.
06:09:14 <hpc> from what i understand, Clojure is one of the better dialects, due to the enormous library support of the JVM
06:09:27 <Randroid> I mean, let's face it, most mainstream languages are pretty boring syntactically. That's why I like Haskell, Factor, REBOL, and J, which are the main languages I play around with.
06:10:11 <Twey> Ick, J.
06:10:19 <Randroid> Twey: I like J a lot!
06:10:23 * Twey thinks that ASCII APL clones are rather missing the point.
06:10:37 <Randroid> Twey: What point are they missing?
06:10:41 <aristid> Twey: APL was not missing the point?
06:11:22 <Twey> APL stretched the tech of the time to bring a rich set of symbols to aid program clarity
06:11:25 <aristid> Randroid: it is possible in haskell to write hard-to-read code, but in J, it is impossible not to.
06:11:51 <aristid> Twey: so the problems of APL were due to technical limitations?
06:12:24 <Twey> The ASCII knock-offs are taking all that back in order to adhere to an obsolete character set, even though we have Unicode and all sorts of goodies nowadays that make writing *real* APL, or even a better-than-APL APL, much more pleasant
06:12:33 <Randroid> aristid: The more J I read, the better I get at it, but I'd agree that's its biggest drawback. Still, I find J extremely intellectually challenging. I use it and Haskell to solve Project Euler problems. I probably wouldn't want to write any real-world code in it.
06:13:17 <Randroid> Twey: So you're saying that the ASCII character set makes these languages harder to read than APL was?
06:13:28 <aristid> "Go is a garbage-collected Algol-descended language which compiles into real machine code."
06:13:36 <aristid> this suffices to know it's not interesting
06:13:48 <aristid> i mean, algol-descended languages are so two decades ago
06:13:54 <Twey> Randroid: Yes, as well as more verbose.
06:14:19 <bremner> aristid: plt-scheme implements algol-60, for the real thing!
06:14:44 <Randroid> Twey: I'll buy that to some extent, but the more J you read and write, the easier it gets. You start to break up things like (#~ >&2)"1 into their constituent parts in your head automatically.
06:14:46 <aristid> bremner: like i had a desire to use that :P
06:15:12 <bremner> well, you did say "derived". We could quibble about the trivial derivation :)
06:15:20 <Randroid> (By the way, (#~ >&2)"1 means the same thing as filter (>2) in Haskell.)
06:15:22 <Twey> Randroid: I'm sure you do, but one of the chief selling points of APL was its terse, semantically-rich notation
06:16:13 <aristid> Twey: i like haskell's approach of using abstraction and hofs to achieve terseness
06:16:15 <Twey> Which J throws away for compatibility with a standard even more restricted than the ancient tech APL had to build on
06:16:35 <Twey> aristid: Sure, sure, nobody's throwing Haskell into the mix here :Ã¾
06:16:57 <aristid> Twey: well, just about approaches of achieving terse code
06:17:23 <Randroid> aristid: True, I find Haskell much more readable than J, although I've seen some incredibly baffling Haskell code. I'm usually humbled by the things I see the pros do in both languages.
06:17:40 <Twey> Well, pretty much all APL variants exceed Haskell in terseness, I'm sure few people would disagree
06:18:11 <aristid> i have no clue how to decipher (#~ >&2)
06:18:14 <Randroid> Twey: That's definitely true! Just look at the Project Euler stuff. Typical Haskell solutions are extremely short, but the J ones are just unbelievable.
06:18:20 <aristid> what would be the APL equivalent? :D
06:19:14 <Randroid> aristid: Well, here's the J Vocabulary. Knock yourself out. :) http://www.jsoftware.com/help/dictionary/vocabul.htm
06:19:26 <aristid> Randroid: i have no intention of learning J.
06:19:43 <aristid> Randroid: i just want to know how to decipher the expression that you posted.
06:20:37 <Randroid> aristid: Man, I'd love to describe it, but I don't want to spam #Haskell with a lengthy explanation of J's syntax.
06:21:01 <aristid> Randroid: you need more than 3 sentences? i mean, filter (>2) doesn't take long to explain
06:22:34 <Randroid> aristid: Unfortunately I'd have to explain hooks (sequences of two verbs in a row), and the ~ adverb which causes the two sides of a dyadic verb â a verb with two arguments â to be the same. E.g., % means "divide", so 3 % 2 means 3 / 2. If I say %~ 2 it means 2 / 2. And so on.
06:23:28 <mauke> so ~ is join
06:24:12 <aristid> @src join
06:24:13 <lambdabot> join x =  x >>= id
06:24:24 <aristid> @src (->) >>=
06:24:24 <lambdabot> Source not found. Just try something else.
06:24:30 <aristid> @src (->) (>>=)
06:24:30 <lambdabot> f >>= k = \ r -> k (f r) r
06:24:53 <Randroid> mauke: I'm not familiar  with join. I'm largely a Haskell beginner.
06:25:08 <aristid> join x = \r -> (f r) r ?
06:25:11 <Twey> :t join
06:25:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:25:17 <Twey> That's join âº
06:25:26 <mauke> aristid: no, x r r
06:25:28 <Twey> aristid: A.K.A. âjoin f x = f x xâ
06:25:32 <i_am_neuron> Trying to compile this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26100#a26100 and GHC tells me "Not in scope: `h'". Isn't h intended to be visible after triple deconstruction?
06:25:42 <Twey> Ah, yeah, that too.
06:25:45 <aristid> mauke: oh, lol i fail at substitution
06:25:48 <Randroid> That does sound like J's ~
06:25:58 <aristid> Randroid: except it's more general
06:26:01 <mauke> i_am_neuron: yes, but you're trying to use it before
06:26:02 <Twey> Randroid: J has monads?
06:26:16 <aristid> Twey: ~ seems to  be on the function monad only
06:26:18 <geheimdienst> twey :-)
06:26:22 <Twey> Ah
06:26:33 <geheimdienst> i think it's just a coincidence that they call it that
06:26:45 <Twey> geheimdienst: Call what what?
06:26:46 <geheimdienst> in other languages i guess it would be called unary
06:26:49 <Randroid> Twey: No, not like Haskell's. In J terminology, a monad is a verb taking one argument, and a dyad takes two.
06:26:50 <geheimdienst> "monadic"
06:26:54 <Twey> Oh, right, yes.
06:27:00 <geheimdienst> unary operators
06:27:22 <aristid> mauke: hmm join proves to be the more fundamental operation again. if it were not for the IO monad, (>>=) would probably not have been chosen as the fundamental operation
06:27:27 <Twey> In IlÃ¡kÅ¡, the monadic is a perspective class.
06:27:38 <Twey> I punned about it once, but, unsurprisingly, nobody got it.
06:27:44 <Randroid> J verbs are always like operators. >: 2 means "add 1 to 2" and 2 * 3 is 6. >: is a monad and * a dyad.
06:27:54 <i_am_neuron> mauke: is it because it's the result of IO operation? I.e. I can't define lambda that uses value that haven't been read yet?
06:28:18 <Randroid> Twey: What's IlÃ¡kÅ¡?
06:28:37 <mauke> i_am_neuron: I am confused by your reference to "lambda"
06:28:40 <Twey> Randroid: Constructed languageâ¦ quite similar to J in some ways, in fact.
06:28:54 <Twey> http://ithkuil.net/ilaksh/Ilaksh_Intro.html
06:29:00 <Randroid> Twey: A constructed *human* language or computer language. I'm a Conlang enthusiast myself.
06:29:06 <Twey> Human
06:29:16 <mauke> i_am_neuron: the problem is that you have something like 'foo = BODY where STUFF'
06:29:25 <Randroid> Twey: That's great! Conlanging is my principal hobby!
06:29:33 <i_am_neuron> mauke: Hmmm, isn't lc = hClose h defines a lambda with hClose h inside?
06:29:33 <mauke> i_am_neuron: the definitions in STUFF are available in BODY, but not vice versa
06:29:43 <mauke> i_am_neuron: I don't see a lambda there
06:29:47 <i_am_neuron> mauke: Ohh, I see
06:30:06 <mauke> i_am_neuron: you're calling hClose on h and binding the result to lc
06:30:16 <mauke> no lambdas
06:30:30 <Randroid> Twey: I'm pretty sure I've heard of Ithkuil, your other creation.
06:30:40 <Twey> Randroid: Oh, it's not my language!
06:30:45 <Twey> Goodness no.
06:30:48 <Randroid> Twey: Oh, I must have misunderstood.
06:30:51 <i_am_neuron> mauke: I see. Thanks for that
06:30:52 <mauke> anyway, your h is a local variable that only exists in 'return $ ...'
06:31:35 <Twey> I'm working (passively ;)) on a variant, but Quijada invented the concepts, for which I occasionally worship him as a deity.
06:31:39 <Randroid> Twey: I see! IlÃ¡kÅ¡ is a reworking of Ithkuil. Interesting. I'll read it with interest.
06:32:32 <aristid> @src (->) fmap
06:32:32 <lambdabot> fmap = (.)
06:33:44 <Randroid> Twey: I've designed an API in the REBOL programming language â which is great at creating DSLs â for generating random words according to a specification written in a DSL that describes the valid phonemes and combinations thereof, etc.
06:34:01 <Randroid> Thinking of rewriting it in Haskell using the parser combinators, though.
06:36:39 <Randroid> Well, folks, it's been swell. I have to leave Starbucks and bike home before it gets too hot here this Florida morning. Also gotta watch USA beat UK today. (I don't seriously think that will happen.)
06:37:26 <Twey> I mistrust REBOL on principle
06:37:35 <Twey> Okay â feel free to drop by #ilaksh some time.  âº
06:37:57 <Randroid> Twey: Will do!
06:41:12 <aristid> rebol sounds like cobol
06:50:12 <monoidal> ghci cannot find Data.Vector, but I have vector installed and exposed. what could be the reason?
06:54:11 <alip> is there a way i can make hslogger not write log messages to stderr? i set up a log handler using setHandlers but still logs go to stderr *and* my log handler
07:08:30 <Linnk> Hey :) I just started learning Haskell yesterday by reading the excellent guide at learnyouahaskell.com
07:08:55 <Zao> Huzzah.
07:09:56 <Linnk> So, I'm playing around with this simple app where I need a function that takes a String and a map of products. I've made the Product typeclass, but I don't really know how to say "hey, this function takes a map of Product"
07:11:13 <Zao> Could you pastesite your definition of "Product", maybe?
07:12:19 <Linnk> Zao: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26103#a26103
07:12:58 <Zao> That's not a typeclass, thankfully.
07:13:21 <Linnk> Zao: hm, I'm confused then
07:13:56 <Linnk> It's just a type then?
07:14:00 <Zao> Yeah.
07:14:09 <Zao> So what do you mean by "map of products"?
07:15:13 <Linnk> Well, a user has a list of products, the product should be the key of the map, the value should be an integer
07:15:42 <interferon> is there a mailing list for discussion of ghc development?
07:16:19 <Linnk> So I've defined the User type which has an items "field" that needs to be that map
07:17:06 <Linnk> I don't know if that makes sense in the Haskell world
07:17:16 <Zao> If you're talking about an associative container, you probably mean Map.
07:17:51 <Zao> Map Int String  is a container mapping Ints to Strings.
07:17:59 <Zao> (From the Data.Map module)
07:19:07 <Zao> Now, Map requires the key to have an instance of Ord.
07:19:12 <Zao> Eq is not sufficient, I believe.
07:20:00 <Linnk> That makes sense, couldn't I make Product derive Ord?
07:20:37 <Zao> Probably.
07:21:00 <Zao> Depends on whether the fields of it are Ord-erable.
07:21:03 <Zao> Try it and see.
07:22:02 <Linnk> Zao: I will, having problems loading my code into ghci, thanks though :)
07:25:48 <Twey> Hm.  Is there any way to take a union of two record values?
07:27:16 <Twey> E.G. union R { a = 3, b = Just 5, c = Nothing, d = Just 6 } R { a = 5, b = Nothing, c = Nothing, d = Just 7 } = R { a = 5, b = Just 5, c = Nothing, d = Just 7 }
07:27:36 <Twey> Like a map, butâ¦ not a map âº
07:27:42 <Twey> Fixed keys
07:27:50 <Zao> Linnk: So how does your code look, and what errors do you get?
07:28:34 <Linnk> Zao: It looks like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26104#a26104
07:28:51 <Linnk> Zao: With this error:  Multiple declarations of `Main.name'
07:29:14 <Linnk> Apparently I can't use the same name twice?
07:29:47 <Twey> Indeed
07:29:55 <Twey> It's wisest to put separate records in separate modules
07:30:39 <Twey> Failing that, you can do the old hack: data Product = Product { productName :: String, productPrice :: Float }; data User = User { userName :: String, userItems :: ProductMap }
07:31:01 <Linnk> Hm, that doesn't make sense, why should I? Those fields belong in different types
07:32:28 <monoidal> the fields are really functions
07:32:42 <monoidal> so, productName :: Product -> String and userName :: User -> String
07:32:53 <moonlite_> userName (User n _) = n
07:32:54 <Zao> Linnk: If you have an User named u; you can say  userName u  to retrieve that field.
07:33:07 <Zao> Now, if both have a name, the accessor function would clash.
07:33:35 <Twey> Record syntax is just sugar for data Product = Product String Float; name :: Product -> String; name (Product n _) = n; price :: Product -> Float; price (Product _ p) = p
07:33:35 <Linnk> Oh, that's a function too
07:33:46 <Twey> (plus update syntax)
07:34:31 <monoidal> that's why two different fields cannot have the same name - what would be the type of the function?
07:34:35 <Linnk> Hehe, this really is completely different to what I'm used to
07:34:48 <Twey> Everybody agrees that this is a Bad Thing, but nobody really agrees on what to do about it
07:34:52 <Twey> So it remains âº
07:35:21 <Twey> I think there are nearly as many record-system proposals as monad tutorials, now
07:35:31 <Linnk> Every language has its weaknesses I guess
07:35:48 <monoidal> Linnk: if you create a type class Nameable a where name : a -> String and instances Nameable Product, Nameable User then you'll get same name for different types
07:36:29 <Twey> It's not that troublesome to put things into separate modules, though it would be nicer if we could combine several modules into one fileâ¦ there are more important flaws in the record system, like lack of first-class labels
07:36:44 <Twey> monoidal: ::
07:36:51 <monoidal> whoops, yes
07:37:01 <Twey> Too much Agda?  ;)
07:38:10 <Linnk> monoidal: Yeah, think I got it now :) Thanks
07:45:39 <ManateeLazyCat> When i do "cabal install", Setup.hs will compile/run before cabal detect it depends on some package?
07:47:47 <Saizan> have you tried?
07:49:17 <zygoloid> i'm writing a wrapper around a library which requires me to use a bound thread. is it considered good style to forkOS a thread myself, or to pass the bound-thread burden on to my caller?
07:49:37 <zygoloid> (should i be worried about the overhead of using a bound thread?)
07:50:12 <ManateeLazyCat> zygoloid: bound thread for what? gtk2hs?
07:50:18 <Saizan> bound threads are more expensive to communicate with, afaiu
07:50:27 <zygoloid> ManateeLazyCat: no, ptrace
07:50:45 <ManateeLazyCat> Saizan: bound thread is only choose for GUI toolkit, such as gtk2hs.
07:51:36 <Saizan> ManateeLazyCat: i know
07:51:52 <Philonous> Are there packages for accessing record labels besides data-accessor? Possibly with less HT-ified source?
07:52:08 <Saizan> *TH ?:)
07:52:26 <Saizan> there's fclabels too, and probably others
07:52:30 <Philonous> Saizan: No, I mean Henning Thieleman. I can't read his code. 
07:52:42 <zygoloid> if i all the threads with a reference to a Chan are blocked reading from it, will they get collected and cleaned up somehow?
07:53:44 <ManateeLazyCat> If not use bound thread, gtk+ main thread engross loop make ghc runtime-system haven't chance to schedule other threads.
07:53:56 <aristid> Philonous: lol "HT-ified"
07:54:10 <Philonous> zygoloid: I beleive they will receive a BlockedOnDeadMVar exception
07:54:41 <zygoloid> cool
07:54:54 <ManateeLazyCat> zygoloid: Can you use STM instead lock?
07:55:03 <Philonous> zygoloid: Oh, wait. That does only applay when there is no other reference to that vary MVar.
07:55:43 <Saizan> Philonous: ah right :D
07:55:43 <Philonous> very*
07:55:48 <ManateeLazyCat> I need make cabal check current package's dependent before run/compile Setup.hs, possible?
07:56:22 <zygoloid> ManateeLazyCat: use STM for what? i was going to use a Chan to pass IO () actions into a forkOS'd thread
07:57:00 <ManateeLazyCat> zygoloid: Oh, i see.
07:57:05 <zygoloid> (i wanted to just use forkOS . sequence_ . getChanContents, and let the thread be killed by GC but it sounds like i need to somehow deal with termination)
07:57:37 <aristid> (>=>) = (>>>) `on` Kleisli?
07:57:38 <Saizan> ManateeLazyCat: what do you mean exactly? if you run "cabal install foo" cabal will install the dependencies of foo before compiling foo's Setup.hs
07:57:49 <zygoloid> aristid: +unKleisli
07:58:06 <aristid> ah, sure
07:58:10 <Saizan> and a more general type.
07:58:19 <aristid> Saizan: ?
07:58:22 <aristid> :t (>=>)
07:58:23 <Saizan> ?type (>>>) `on` Kleisli
07:58:23 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:58:23 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> (b -> m b) -> Kleisli m b b
07:58:37 <zygoloid> ah :)
07:58:43 <aristid> :t fmap unKleisli . (>>>) `on` Kleisli
07:58:44 <lambdabot> Not in scope: `unKleisli'
07:58:51 <aristid> :t fmap runKleisli . (>>>) `on` Kleisli
07:58:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> (b -> m b) -> b -> m b
07:59:05 <aristid> Saizan: the type does seem to be the same?
07:59:07 <ManateeLazyCat> Saizan: In every gtk2hs-base package, has a file Gtk2HsSetup.hs, and in Gtk2HsSetup.hs has hook "gtk2hsUserHooks", we will add "main = defaultMainWithHooks gtk2hsUserHooks" in Setup.hs.
07:59:12 <zygoloid> aristid: no, it's been flattened by 'on'
07:59:17 <Saizan> aristid: look at the type variables.
07:59:24 <aristid> oh
07:59:28 <ManateeLazyCat> Saizan: Problem is, those Gtk2HsSetup.hs in every package is copy.
07:59:30 <aristid> evil on!
07:59:33 <aristid> :D
07:59:45 <ManateeLazyCat> Saizan: I want use other package expoert Gtk2HsSetup.
07:59:56 <aristid> :t \a b -> runKleisli $ (Kleisli a) >>> (Kleisli b)
07:59:57 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (a -> m b1) -> (b1 -> m b) -> a -> m b
08:00:33 <ManateeLazyCat> Saizan: So when i do "cabal install", cabal will install all dependent package before it run Setup.hs?
08:00:42 <Saizan> ManateeLazyCat: yes
08:00:56 <ManateeLazyCat> Saizan: Axel told me, it can't.
08:01:55 <ManateeLazyCat> Saizan: Ask for confirm this detail.... :)
08:03:12 <Saizan> i've just tried, and i had no problem.
08:03:51 <ManateeLazyCat> Saizan: Thanks, i will try fix this problem, make gtk2hs easier to maintain. :)
08:18:41 <edwardk> would you rather had code that occasionally let you shoot yourself in the foot by explicitly misusing the library, or which gave you a runtime error whenever you screwed up in one way, but let you typecheck too much code in another?
08:19:24 <edwardk> has anyone put together a library with newtype wrappers to control floating point rounding modes?
08:21:33 <noteed> edwardk: I want to shoot myself explicitely in the foot (if it is elsewhere, I don't want to be explicit)
08:22:51 <edwardk> noteed: the reason i ask is i have two ways i can implement variadic grad
08:23:19 <noteed> edwardk: my answer was serious (although not the part is parenthesis)
08:23:23 <ksf> why doesn't Language.Haskell.TH.Loc include the name of the surrounding binding?
08:23:25 <aristid> edwardk: are things often comonads but not seen as such?
08:23:37 <edwardk> one yields a signature like vgrad :: Grad i o a => i -> o -- which permits you access to the gory details of the AD mode you're using (should you choose to access them)
08:25:04 <edwardk> the other yields something like vgrad :: (Traversable f, Num a) => (forall s. (Mode s, Pack i (AD s a)) => i) -> f a -> f a -- but that means that even though you hoisted a variadic function, the result isn't variadic
08:25:06 <ManateeLazyCat> Saizan: I have test, works! After i push patches, "cabal install gtk" will install all gtk2hs packages, and don't need install gtk2hs-buildtools manually.
08:25:09 <edwardk> and so you can under/over apply it
08:25:46 <mreh> what am I binding with >>= in the ST monad?
08:26:01 <ksf> mreh, your actions?
08:26:13 <aristid> @src ST (>>=)
08:26:13 <lambdabot> Source not found. My pet ferret can type better than you!
08:26:15 <mreh> ksf: sorry, binding to
08:26:22 <edwardk> mreh: ST s a is just functions in the form State# s -> (a, State# s)
08:26:31 <ksf> ...in the ghc case, a thing that looks just like the plumbing of the IO monad
08:26:35 <edwardk> bind chains together then State# s's
08:26:40 <ksf> the world, so to say.
08:26:42 <edwardk> (and that is in (# #) not (,)
08:27:08 <mreh> haven't done much clean
08:28:06 <mreh> so it's like the State monad
08:28:12 <mreh> but more complex
08:28:15 <mreh> under the hood
08:28:27 <mreh> :t newArray_
08:28:28 <lambdabot> Not in scope: `newArray_'
08:28:35 <mreh> @hoogle newArray_
08:28:35 <lambdabot> Data.Array.MArray newArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)
08:29:08 <Saizan> it's actually not at all like the state monad
08:29:59 <mreh> Saizan: well it is, but the state is not something you pass to it, it's an interface to an address space
08:30:05 <noteed> It is said in the cairo documentation that gtk2hs provides an X backend. Which package provides it?
08:30:14 <mreh> right?
08:30:33 <dcoutts> noteed: the gtk package
08:31:02 <dcoutts> noteed: though really it's the gtk+ C lib that has the X backend, the Haskell binding does not know or care
08:31:41 <Saizan> mreh: from a sufficiently high level you can see it as "State Heap" but i wouldn't get too much out of this
08:31:54 <noteed> dcoutts: so it is via Graphics.UI.Gtk.Cairo ?
08:32:20 <J-roen> I'm trying to write a Read instance for the following data type, but I don't succeed. Can someone help me please? Thanks.
08:32:20 <J-roen> data Obj = forall o . (Object o) => Obj o
08:32:23 <dcoutts> noteed: that's the cairo binding, it also has an X backend
08:33:12 <aristid> J-roen: Object has a read instance?
08:33:12 <ManateeLazyCat> Saizan: I found Axel is right. Setup.hs don't check dependent.
08:33:25 <J-roen> aristid: Yes
08:33:25 <noteed> dcoutts: Graphics.UI.Gtk.Cairo is provided by the gtk package, not the cairo one
08:33:40 <Saizan> ManateeLazyCat: if you run Setup.hs directly it won't install the dependencies before running itself, of course
08:34:55 <Saizan> J-roen: Read being a superclas of Object is not enough, you've to put a tag in the serialized format to be able to pick the right Read instance when you read it back
08:35:04 <dcoutts> noteed: oh yes, you're right. That one is to make cairo surfaces from gtk windows/pixmaps
08:35:12 <ManateeLazyCat> Saizan: I have move Gtk2HsSetup.hs to gtk2hs-buildtools, but Setup.hs don't check dependent when i do "cabal install"
08:35:21 <dcoutts> noteed: it's the gt/cairo integration stuff
08:35:42 <J-roen> Saizan: Hmm... okay. Thanks. Do you know if there is a standard notation for that?
08:35:45 <ManateeLazyCat> Saizan: Of course, i can add gtk2hs-buildtools to option build-depends of glib.cabal 
08:35:57 <dcoutts> ManateeLazyCat: that's not the same
08:36:10 <noteed> dcoutts: ok. did you mean by "it also has an X backend" that it is possible to have an X backend for cairo without using gtk ?
08:36:29 <Saizan> J-roen: there's nothing built-in for it, but there might be a package on hackage
08:36:33 <noteed> dcoutts: that's the one I would interested in if it exists
08:36:45 <noteed> *I would be
08:36:46 <dcoutts> noteed: technically yes, though there is no binding for that
08:36:55 <ManateeLazyCat> dcoutts: I want move Gtk2HsSetup.hs to some library and make glib depend it.
08:37:04 <Saizan> ManateeLazyCat: can you paste the .cabal files of gtk2hs-buildtools and of glib?
08:37:17 <ManateeLazyCat> Saizan: Yes, wait one sec.
08:37:41 * ManateeLazyCat pasted "gtk2hs-buildtools.cabal" at http://paste2.org/get/874706
08:37:46 <Saizan> ManateeLazyCat: what i meant is that if you put Gtk2HsSetup in gtk2hs-buildtools' exposed-modules and gtk2hs-buildtools in glib's build-depends it'll work.
08:37:48 <noteed> dcoutts: oh, ok. But I knew I could use cairo with just X, I did it in C...
08:37:53 * ManateeLazyCat pasted "glib.cabal" at http://paste2.org/get/874707
08:38:24 <sid-`> anyone who has an example of how to use ">>=" together with readFile? i want to use the content of a file foo as an argument for a function f
08:38:36 <ManateeLazyCat> Saizan: But problem is, "cabal install" will run even i *never* add gtk2hs-buildtools in build-depends of glib.cabal. 
08:39:18 <Saizan> ManateeLazyCat: cabal-install never tried to guess the packages to put in build-depends for you
08:39:40 <dcoutts> noteed: yes, the C API has a function to make a cairo surface from an X11 window, that's what the gtk/cairo integration code's X backend is using. The cairo bindings do not bind the functions for constructing surfaces from X11, Win32 or OSX windows.
08:39:49 <monoidal> sid-`: readFile name >>= f?
08:40:14 <sid-`> that works? didn't think its that easy :)
08:40:30 <ManateeLazyCat> noteed: gtk2hs just binding code, and don't care how to work with GTK+ C code.
08:40:30 <Saizan> ManateeLazyCat: but while compiling Setup.hs it won't hide all packages like it does when compiling the library
08:41:15 <ManateeLazyCat> noteed: In technology, you just need "cabal install cairo", but for graphics cairo result, you need integrate with package *gtk* (cabal install gtk). 
08:41:19 <monoidal> sid-`: or in do notation, do contents <- readFile name; f contents
08:42:16 <sid-`> thats the way i found it in some books
08:42:36 <sid-`> and the other way is shown with >>=, but i coudnt figure out how to use it, hehe
08:42:43 <noteed> dcoutts: ok, thanks
08:43:11 <dcoutts> noteed: the reason is that it'd mean the cairo package would have to depend on the X11 package, and we didn't want to do that at the time
08:43:39 <monoidal> sid-`: do x <- m; ... is same as m >>= (\x -> ...) where ... is desugared recursively
08:43:52 <dcoutts> noteed: the appropriate solution is for the cairo package to provide an .Internal module exposing the surface, so that some other package can provide the cairo/x11 binding
08:43:54 <noteed> dcoutts: really? I though there could be just a cairo-x11 package that would create a Surface.
08:44:05 <dcoutts> noteed: yes exactly
08:44:05 <J-roen> Saizan: I found something via the cafe archives which I hope will work for me: http://gorgias.mine.nu/repos/xmobar/Runnable.hs. Thanks for your help.
08:44:51 <ManateeLazyCat> Saizan: Ok, i will hide Gtk2HsSetup in gtk2hs-buildtools, and install glib again, and figure out what happen....
08:45:59 <sid-`> how about something like this: main = map toUpper >>= readFile "foo"
08:46:02 <sid-`> ?
08:46:53 <aavogt> sid-`: do you understand how to write/read types in haskell?
08:46:55 <monoidal> the IO action is given first
08:47:17 <edwardk> aristid: re your earlier question, yes.
08:47:25 <sid-`> aavogt: i'm learning it
08:47:43 <monoidal> :t (>>=)
08:47:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:47:48 <aavogt> right, and the other argument, is supposed to be a function that produces IO action
08:48:17 <aavogt> @type map toUpper
08:48:17 <lambdabot> [Char] -> [Char]
08:48:25 <aavogt> @type readFile "foo"
08:48:26 <lambdabot> IO String
08:48:26 <noteed> dcoutts: for the well-typed position, do you plan to take a decision next week?
08:48:48 <blackdog> dcoutts: stephen blackheath made a small patch to Cabal some time ago to allow dynamic linking on Mac OS. I reapplied it locally and it seems to do the right thing - what needs to happen for it to make it into the main line? (It does rely on the -dylib-install-name option to GHC, which is in the HEAD but not in a release (unless it made it into 6.12.3, i can't see it in the release notes))
08:48:52 <edwardk> @tell byorgey i may wind up adopting your functional convex hull trick for some generalized taylor models
08:48:53 <lambdabot> Consider it noted.
08:49:13 <dcoutts> noteed: we don't have a firm time but we'll be considering applications this week
08:49:15 <blackdog> dcoutts: ticket 591
08:49:37 <dcoutts> blackdog: ta
08:50:08 <noteed> dcoutts: ok
08:52:09 <ManateeLazyCat> Saizan: I have it. Though Setup.hs don't check dependent, but add "gtk2hs-buildtools" in build-depends of glib.cabal works.
08:52:13 <ManateeLazyCat> I have test it.
08:52:14 <edwardk> dcoutts: do you know of any code that supports manipulating the floating point rounding mode in haskell or of any run time system dependencies on a particular choice of rounding mode?
08:52:41 <dcoutts> blackdog: so it is possible in principle to make relocatable osx libs is it? The -install-name does not have to be an absolute path does it?
08:52:55 <edwardk> i.e. i could go off and define somew newtype wrappers that were careful about setting it up, using it and resetting it by hand.
08:53:12 <edwardk> but then i have to be careful about getting stolen from CPU to CPU, etc.
08:53:20 <dcoutts> edwardk: there's no supported way to change it, doing so would change the behaviour of code that uses the current mode
08:53:20 <blackdog> dcoutts: to be honest, I don't know. Stephen would have a better idea.
08:53:27 <dcoutts> blackdog: 'k
08:53:34 <blackdog> as it stands, they're broken - you get embedded references to libs that don't exist
08:54:04 <edwardk> dcoutts: i'm trying to figure out if i can set up a short IO action that swaps it, performs my operation and swaps it back -- the performance implications are somewhat abhorrent to me
08:54:33 <edwardk> either that or i could just ffi out to something that does my appropriately rounded addition, and rely on ffi to treat that operation as atomic
08:54:37 <dcoutts> edwardk: it's worse than that because of lazyness
08:55:00 <edwardk> dcoutts: yes, what i mean is literally to read the mode, set the mode, perform the op, and reset the mode. so that it appears atomically
08:55:04 <edwardk> i realize i can't just write it once
08:55:17 <edwardk> because laziness will make my floating point ops happen whenever they want to
08:55:28 <dcoutts> edwardk: that might work if you're careful, and yes the performace will be horrible
08:55:36 <ManateeLazyCat> dcoutts: Any objection about "add gtk2hs-buildtools to build-depends of glib.cabal"?
08:55:45 <dcoutts> ManateeLazyCat: yes, it's not the right thing to do
08:55:52 <ManateeLazyCat> dcoutts: Why?
08:56:05 <dcoutts> ManateeLazyCat: because it's not a library dependency, it's a tools dependency
08:56:20 <edwardk> dcoutts: i'm trying to get some rigorous upper and lower bounds in various taylor models and the only way i can maintain my rigor is to use up-rounding on the upper bound and down-rounding on the lower bound
08:56:27 <ManateeLazyCat> dcoutts: Currently, we copy Gtk2HsSetup.hs to everywhere, it's hard to maintain.
08:56:40 <ManateeLazyCat> dcoutts: So i make gtk2hs-buildtools export Gtk2HsSetup.hs
08:56:55 <dcoutts> ManateeLazyCat: and you cannot move code that Setup.hs depends on into external packages
08:58:02 <ManateeLazyCat> dcoutts: I add "exposed-modules: Gtk2HsSetup" in gtk2hs-buildtools.cabal, and add "build-depends: gtk2hs-buildtools" in glib.cabal , i have test, works. 
08:58:02 <ManateeLazyCat>  
08:58:55 <dcoutts> ManateeLazyCat: it does not work if you do not have gtk2hs-buildtools registered
08:58:56 <ddarius> edwardk: A few years ago some people put effort into defining a monad or other approach to allow handling rounding modes, but ultimately they were thwarted.
08:59:13 <dcoutts> ManateeLazyCat: and it will fail with an error message that users will not understand
08:59:20 <edwardk> ddarius: i accept the fact that a monad is too weak
08:59:51 <dcoutts> ManateeLazyCat: cabal does not support Setup.hs depending on non-standard packages
09:00:12 <ddarius> edwardk: I think that overloading every operation is about the only approach that will work, but then you have the significant performance problems.
09:00:19 <edwardk> ddarius: the best i can do is to make a series of newtypes like Near, Trunc, Up, Down
09:00:30 <edwardk> and then overload each of the floating operations on those
09:00:41 <edwardk> i'm willing to accept the performance issue for correctness
09:01:06 <jmcarthur> hah, speaking of "correctness" while dealing with floating point
09:01:08 <ManateeLazyCat> dcoutts: When i do "cabal install glib", cabal will install gtk2hs-buildtools first, right? After gtk2hs-buildtools installed, "import Gtk2HsSetup ( gtk2hsUserHooks )" in Setup.hs can work even Setup.hs don't check dependent.
09:01:17 <ddarius> edwardk: Then that may work done correctly though, as you pointed out, you may still have issues with context switches.
09:01:26 <jbapple> Can purely functional data structures serve as mutable lock-free concurrent data structures by (a) building the new structure (b) CASing the pointer to the new structure with the pointer to the old structure?
09:01:42 <edwardk> ddarius: well, what i'm thinking is that the newtype would call out to the ffi to do the actual operation, keeping it atomic
09:01:46 <edwardk> that might make it suck less ;)
09:01:59 <edwardk> jbapple: yes, herlihy gives that general construction
09:02:15 <dcoutts> ManateeLazyCat: it will happen to work for users of cabal-install. Note that it will also mean that distributions will have to install gtk2hs-buildtools as a runtime dependency, even though it is not a runtime dependency.
09:02:43 <edwardk> jbapple: interestingly there is a similar result I found involving laziness and wait free that says that you can run a wait-free algorithm lazily, even in the presence of side-effects.
09:02:48 <jbapple> edwardk: but it would be slow, right, since mutable lock-free concurrent data structures try to get <1 CAS per operation?
09:03:13 <jbapple> edwardk: link?
09:03:17 <edwardk> jbapple: yes, its not ideal, but it is a general purpose mechanism to construct a lock-free algorithm
09:03:18 <ManateeLazyCat> dcoutts: We need re-install all gtk2hs-base package when user touch gtk2hs-buildtools?
09:03:26 <edwardk> for the latter? i;m not sure i ever published it online
09:03:38 <edwardk> for the former, hrmm it comes up in herlihy's book at least
09:04:23 <c_wraith> jbapple, that general strategy is what's used by atomicModifyIORef
09:04:28 <jbapple> yes, the latter. By "found", I didn't know you meant "discovered"
09:04:39 <dcoutts> ManateeLazyCat: I'm not really sure what you mean
09:04:43 <jbapple> c_wraith: Thanks for the tip, I'll look into that
09:04:51 <jbapple> I asked about this because of http://www.reddit.com/r/programming/comments/ce7cx/ask_proggit_would_there_ever_be_any_fundamentally/c0ry843
09:05:10 <c_wraith> Just be aware that atomicModifyIORef is very bad under contention.
09:05:14 <jbapple> This poster asks for a "multiple-producer, multiple-consumer lock-free queue (that doesn't require a double-width CAS)."
09:05:43 <jbapple> c_wraith: because of cache effects?
09:06:05 <jbapple> So, I was wondering if any purely functional queue is a "multiple-producer, multiple-consumer lock-free queue (that doesn't require a double-width CAS)." 
09:06:16 <edwardk> jbapple: it came to me when i was working on a bunch of lock-free structures and realized i didn't care about rate of replay at all, you wind up with a bunch of lazy algorithms that internally CAS, etc. but yield progress, they aren't pure, you have some trouble with repeatability, etc. but they are interesting in their own right.
09:06:40 <edwardk> there are plenty of non-double-cas queues.
09:06:41 <c_wraith> No, because if the pointer has been updated since the calculation of the new value was created, the whole operation restarts.  If you have several going concurrently, they step all over each other for *very* bad performance characteristics
09:06:50 <ManateeLazyCat> dcoutts: I see. Gtk2HsSetup.hs is not runtime dependency, it's just dependency for Setup.hs.
09:07:28 <dcoutts> ManateeLazyCat: right, but ghc-pkg will think that gtk2hs-buildtools is a library dependency of glib, gtk, cairo etc
09:07:28 <edwardk> my reference for him would be herlihy's book, which supplies a bunch of such parallel friendly queues.
09:07:39 <ManateeLazyCat> dcoutts: But it's painful to maintain Gtk2HsSetup.hs copy in every packages. 
09:08:00 <ManateeLazyCat> dcoutts: Now, looks Gtk2HsSetup.hs have some bug with Windows.
09:08:12 <jbapple> c_wraith: I see
09:08:12 <c_wraith> atomicModifyIORef is *not* good for lock-free structures.  It's impossible to guarantee progress with it.
09:08:24 <jbapple> c_wraith: wait, it is?
09:08:33 <dcoutts> ManateeLazyCat: I expect you can work something out, e.g. using symlinks
09:08:43 <dcoutts> or maybe hard links
09:08:45 <ManateeLazyCat> dcoutts: Windows support symlink?
09:09:17 <ManateeLazyCat> dcoutts: Unix is ok, but i'm not sure Windows or other platform support symlink well.
09:09:43 <jbapple> It seems like you could build structures that are "lock-free", but not "wait-free", in the vocabulary in http://www.cs.tau.ac.il/~shanir/concurrent-data-structures.pdf
09:10:02 <Blkt> could anyone explain me how to generate a list of randomly distributed zeros and ones with System.Random? (quickness is welcome, the connection here is very unstable)
09:10:33 <ManateeLazyCat> dcoutts: Or Cabal team have better idea to fix this problem?
09:10:34 <jbapple> c_wraith: That is, an operation in thread A may fail on CAS, but if it does, an operation in some other thread must have succeeded
09:10:43 <pastorn> Blkt: shouldn't you be looking at Data.Random?
09:10:54 <pastorn> oh wait
09:10:58 <pastorn> i liid
09:11:00 <pastorn> *lied
09:11:02 <c_wraith> jbapple: I suppose that's true
09:11:32 <Blkt> pastorn: what do you mean?
09:11:35 <pastorn> Blkt: in ghci: *Main> :i Random
09:11:42 <jbapple> edwardk: Well, I'll let you tell that poster if you want. I would tell him or her myself, but I don't want to pretend I understand concurrent data structures and then face some hard question I can
09:11:45 <jbapple> t answer
09:11:58 <pastorn> Blkt: you want to use randomRs
09:12:04 <Blkt> pastorn: I found that on web but I couldn't understand how to invoke randomRs
09:12:15 <Blkt> @type randomRs
09:12:16 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
09:12:16 <pastorn> Blkt: you can creade a 'g' (a random seed) with 'newStdGen'
09:12:36 <pastorn> > g <- newStdGen
09:12:37 <lambdabot>   not an expression: `g <- newStdGen'
09:12:39 <pastorn> :(
09:12:52 <dcoutts> ManateeLazyCat: it can be a hard link on your own box, doesn't need to be a hard link in darcs
09:13:06 <edwardk> jbapple: yes, there is a general purpose lock-free construction. making things wait-free is harder
09:13:39 <Blkt> pastorn: but I can't write something like...
09:13:43 <Blkt> > randomRs (0,1) newStdGen
09:13:44 <lambdabot>   No instance for (System.Random.RandomGen
09:13:44 <lambdabot>                     (GHC.IOBase.IO...
09:14:08 <Blkt> is there a non-imperative way to do it?
09:14:14 <gwern> Blkt: I think you can specify Bits directly
09:14:23 <Blkt> gwern: randomly?
09:14:29 <gwern> Blkt: well, pass in a seed of your choice, that's the pure way to do it...
09:15:01 <Blkt> what is a RandomGen then?
09:15:04 <Blkt> a seed?
09:15:08 <Blkt> like a number?
09:15:11 <ski> @type mkStdGen
09:15:12 <lambdabot> Int -> StdGen
09:15:21 <pastorn> Blkt: randList :: (Random a) => (a,a) -> IO [a]
09:15:23 <pastorn> randList range = do
09:15:25 <pastorn>     g <- newStdGen
09:15:27 <pastorn>     return (randomRs range g)
09:15:37 <Blkt> mmm
09:15:41 <Blkt> that should do the trick
09:16:29 <jbapple> edwardk, c_wraith: thanks for your knowledge. I've got some more reading to do. :-)
09:16:43 <ski> > randomRs (0,9) (mkStdGen 0)
09:16:43 <lambdabot>   [5,5,5,0,2,9,3,3,3,8,5,2,4,2,6,7,2,3,7,4,4,8,2,7,8,1,2,1,3,2,9,4,5,6,2,2,2,...
09:16:57 <ski> > (1,2) + 3  -- :-O ?
09:16:58 <lambdabot>   (4,5)
09:17:14 <edwardk> jbapple: between the conc-list stuff and now this, we'll turn you into a parallel programming guy yet ;)
09:17:15 <pastorn> Blkt: just put your range to (0,1 :: Int)
09:17:16 <Blkt> what's its type?
09:17:31 <gwern> Blkt: if you want the seed to vary, it's got to vary; if you want a stateful like thing, it must be stateful like. you can't have a referentially pure seed that changes arbitrarily
09:17:58 <aavogt> > 3 :: (Int,Int)
09:17:58 <lambdabot>   (3,3)
09:18:03 <gwern> 'tis a contradiction in terms
09:18:08 <Blkt> gwern: I need a stateful like thing
09:18:13 <pastorn> aavogt: yes, let's make it simple...
09:18:55 <gwern> aavogt: I think you're abusing the simplereflect stuff, because that doesn't seem to work in my ghci :)
09:19:11 <aavogt> I don't think it's from simple reflect
09:19:15 <jbapple> edwardk: All Haskell programmers are already || programmers, right? Just sprinkle in a few "[: :]"s and "par"s? ;-)
09:19:31 <gwern> the [::] is a lie!
09:19:45 <jbapple> Now I want cake :-(
09:19:59 <pastorn> jbapple: i just had some :D
09:20:02 <Blkt> ski: does randomRs (0,1) (mkStdGen) always generate the same list of zeros and ones? Is it stateful or not=
09:20:04 <Blkt> ?
09:20:04 <pastorn> it was great
09:20:06 <aavogt> > x :: (Expr,Expr)
09:20:07 <lambdabot>   Couldn't match expected type `(SimpleReflect.Expr,
09:20:07 <lambdabot>                         ...
09:20:21 * gwern thinks [::] looks like cake. you have the frosting, the 2 layers, and the crusty bottom
09:20:22 <aavogt> > f :: (Expr,Expr)
09:20:22 <lambdabot>   No instance for (SimpleReflect.FromExpr
09:20:23 <lambdabot>                     (SimpleReflect....
09:20:27 <pastorn> Blkt: it will be the same list if the argument to newStdGen is the same
09:20:50 <gwern> pastorn: so delicious and moist?
09:21:03 <pastorn> Blkt: newStdGen does fancy IO stuff to get a more "true" random value
09:21:09 <jbapple> I wish cake were wait-free
09:21:11 <pastorn> gwern: yes
09:21:29 <jbapple> Then I would be guaranteed cake in some finite amount of time
09:21:50 <aristid> edwardk: the thing about comonads is, i'm fascinated by how they can be derived from monads (flip all arrows), and i've seen there are some applications (Zipper), but they're harder to fit into a mental model than, say Applicative
09:21:54 <jbapple> instead of just knowing that someone, somewhere has had cake
09:22:26 <edwardk> aristid: to me i tend to think of comonads as taking big parallel steps where monads take small serial steps.
09:22:28 <gwern> jbapple: a non-egoist utilitarian would find the latter just as well
09:22:45 <pastorn> []cake <-- look, a guarantee of cake!
09:23:02 <pastorn> jbapple: ^^
09:23:23 <Blkt> thanks for the help guys, I think I got it at last
09:23:38 <pastorn> Blkt: :)
09:24:01 <jbapple> pastorn: ? Is that modal cake?
09:24:11 <aristid> edwardk: sounds like image manipulation would be a fit
09:24:13 <edwardk> consider extend :: Comonad w => (w a -> b) -> w a -> w b -- The 'comonadic action' has access to the entire w a to decide what to do with some individual element of the result. You run all of those, focusing on each hole and sew the answer back up in the original shape
09:24:19 <edwardk> aristid: it is a great fit =)
09:24:50 <edwardk> data Ptr i e = Ptr (Array i e) i -- is a perfectly good comonad
09:24:58 <aristid> so extend :: (Image a -> Pixel b) -> Image a  -> Image b?
09:25:04 <edwardk> you can extract from it: extract (Ptr a i) = a ! i
09:25:12 <aristid> oh wait, you need a "current pixel" i guess?
09:25:15 <edwardk> yeah
09:25:24 <edwardk> but that is what Ptr captures, i is the current pixel
09:26:00 <edwardk> blur (Ptr a i) = (a ! up i + a ! down i  + a ! left i + a ! right i) / 4
09:26:16 <pastorn> jbapple: yes
09:26:50 <pastorn> jbapple: i'm not sure, can't it also be a proof of cake?
09:26:54 <edwardk> then the comonadic action for your (Ptr i) comonad would iterate over each of the pixel positions, and glue the result into a new image.
09:27:05 <edwardk> er i mean cobind
09:27:10 <aristid> and to blur, you can do this? unptr (extend blur (ptr0 img))
09:27:21 <edwardk> aristid: exactly
09:27:32 <edwardk> congratulations, you now grok one of the key comonads
09:27:45 <jmcarthur> by "iterate over" you mean "compute in parallel" :D
09:27:52 <edwardk> jmcarthur: that too ;)
09:28:08 <edwardk> since the blur is effectively applied to the same source image everywhere all at once.
09:28:13 <aristid> @src duplicate
09:28:13 <lambdabot> Source not found. You type like i drive.
09:28:26 <edwardk> duplicate :: Comonad w => w a -> w (w a); duplicate = extend id
09:28:27 <jmcarthur> hey look at that i need to redo my texture formats code
09:29:03 <edwardk> extend :: Comonad w => (w a -> b) -> w a -> w b -- can be defined in terms of fmap and duplicate. extend f = fmap f . duplicate
09:29:08 <edwardk> but you need to define one or the other ;)
09:30:10 <aristid> so unptr . fmap blur . duplicate . ptr0 would be the same?
09:30:20 <edwardk> yeah
09:30:35 <jmcarthur> sometimes i'm not sure if something should be at the type level or the value level
09:31:28 <jmcarthur> i suppose in general putting things at the value level is more flexible since it can be constructed at runtime
09:31:44 <jmcarthur> but at the type level is faster
09:31:49 <jmcarthur> (in this case not necessarily safer)
09:31:49 <Philonous> Hah, I didn't even know that you could write types like (a ~ [Int]) => a -> a -> a
09:31:58 <jmcarthur> Philonous: o_O
09:32:01 <jmcarthur> that's disgusting :P
09:32:12 <aristid> edwardk: so when i duplicate an image, i get this? Pointer i (Pointer i Image)
09:32:22 <jmcarthur> i guess it's kind of like  let a = Int in a -> a -> a
09:32:41 <jmcarthur> *[Int]
09:32:45 <Philonous> No, it's not. "[Int] -> [Int] -> [Int] " may be ok, but suppose a is a very long type 
09:32:48 <edwardk> aristid: exactly
09:32:52 <edwardk> er
09:33:02 <jmcarthur> Philonous: right. it's like a let binding. which is still strange :P
09:33:06 <edwardk> Pointer i a becomes Pointer i (Pointer i a)
09:33:13 <edwardk> a not Image ;)
09:33:22 <edwardk> the a is the element type (i.e. your pixel type)
09:34:03 <edwardk> Philonous: yeah, amusingly sometimes you even _have_ to write them with those ~ aliases.
09:34:29 <Philonous> edwardk: Oh, really? Mind to give an example?
09:34:45 <aristid> :k (a ~ [Int]) => a -> a -> a
09:34:47 <lambdabot> *
09:35:15 <edwardk> Philonous: sclv has found a few, if you check inside of the jmacro code for ~ you'll find it
09:35:34 <Philonous> edwardk: Ok, thanks
09:35:35 <aavogt> you can get more instances in that way, right?
09:35:51 <edwardk> aavogt: that was basically what he needed it for
09:36:40 <Cadynum> im looking for some really simple parser for strict bytestrings, like Text.Read. just to parse something like "30 \"string\" 4.3". what would you recommend?
09:37:13 <aavogt> is there a lot of them?
09:37:45 <aristid> :t undefined :: (a ~ [Int]) => a -> a -> a
09:37:47 <lambdabot> [Int] -> [Int] -> [Int]
09:37:57 <aavogt> alex is quick if that's important
09:38:25 <edwardk> Cadynum: parsec 3 gets the job done, and attoparsec is the new hotness, you choose ;)
09:39:10 <aavogt> edwardk: maybe I was doing something wrong, but asymptotically alex was faster than attoparsec
09:39:33 <aavogt> though the lexer generator is a bit less convenient
09:39:49 <edwardk> aavogt: i find i can rarely use alex/happy given the kinds of grammars i work with =/
09:40:45 <Cadynum> are there some nice examples how to use parsec3? the nice thing about Text.Read is how small it is. i could almost instantly understand how it worked
09:40:58 <aavogt> you could still use Text.Read
09:41:16 <Cadynum> the documentation about parsec i found was more for parsec2, which seems a bit different than 3
09:43:57 <tweakism> "cabal: cannot configure QuickCheck-2.1.0.3. It requires ghc -any" / "There is no available version of ghc that satisfies -any" .. wth does this mean?  Note, I know mostly nothing about ghc / haskell
09:44:29 <ManateeLazyCat> TH support (\x -> read x :: Foo) ?
09:44:31 <tweakism> ghc is ver 6.12.1, cabal-install is 0.8.0, this Fedora 13 repos; I did an install of cabal-install 0.8.2 into my homedir with same results.
09:45:11 <ManateeLazyCat> tweakism: Can you paste all error message?
09:45:23 <tweakism> that essentiall is all, but sure.
09:45:45 <Philonous> edwardk: I've checked the jmacro code and replaced the only occurence of "~" in an instance declaration with it's literal substitution, and it still type checks. Will the problems occur when I try to use the code?
09:45:50 <Saizan> tweakism: also, see if "ghc-pkg check" reports any problem
09:45:53 <tweakism> http://www.fpaste.org/bjrW/
09:46:00 <tweakism> Saizan: nope.
09:47:03 <tweakism> but, ghc-pkg list does NOT show many of my distro-installed ghc modules
09:47:39 <tweakism> http://www.fpaste.org/Mvax/
09:47:42 <edwardk> Philonous: you may need to check with sclv. it may be fixed in the current ghc. but at the time you couldn't get it to compile without that ~
09:47:43 <Philonous> edwardk: Aliasing types in the instance header should defer instance selection, should'nt it? But i'm not quite sure what that will do in practice
09:48:17 <tweakism> I was about to do a full ghc install to my homedir
09:48:26 <Saizan> tweakism: and it also lacks the ghc package, i.e. there is a lib called ghc other than the executable
09:48:32 <Philonous> edwardk: Ok, thanks.
09:48:33 <tweakism> Saizan: o?
09:48:50 <ManateeLazyCat> twanvl: Do you build link for ghc?
09:48:54 <etpace> Is there a terse if (think its "?" in java) so like: iif (foo == bar) dothis elsedothis
09:49:06 <Saizan> tweakism: do you have two installations of ghc, perhaps?
09:49:23 <Saizan> anyhow:
09:49:25 <Saizan> ghc-pkg list ghc
09:49:25 <Saizan> /usr/local/lib/ghc-6.12.2/package.conf.d ghc-6.12.2
09:49:33 <tweakism> Saizan: don't think so, no; only one package installed, and I haven't installed my own yet.  but there are two cabal-install's; system and homedir
09:49:54 <tweakism> http://fpaste.org/woh2/
09:49:58 <tweakism> so yeah there's two of those...
09:50:42 <Saizan> your ghc-pkg doesn't see the ghc haskell library, assuming it's installe
09:50:45 <Saizan> *installed
09:50:48 <tweakism> ghc-haskell-platform.x86_64  <-- this is an available package for me
09:51:11 <tweakism> #
09:51:17 <tweakism> ghc-6.12.1-5.fc13.x86_64  is installed.  (sorry for mis-pasting the #)
09:51:19 <Saizan> tweakism: try with "sudo ghc-pkg recache", maybe
09:51:28 <tweakism> Saizan: tried that; doing again to be sure
09:51:32 <Saizan> ghc-6.12.1-5.fc13.x86_64 is probably just the compiler
09:51:45 <Saizan> ghc-ghc-6.12.1-5.fc13.x86_64 <- this is probably the ghc library
09:52:00 <applicative> Cadynum, you can use Parsec 2, half the things on hackage still do...  There can be delicacies about exposing and unexposing packages with `ghc-pkg`
09:52:03 <tweakism> Saizan: installing.
09:52:16 <tweakism> can I rm ~/.cabal safely?
09:52:21 <Saizan> tweakism: no.
09:52:37 <tweakism> I mean, if I want to lose all user-specific changes/setting/installed modules
09:52:39 <tweakism> Package ghc-ghc-6.12.1-5.fc13.x86_64 already installed and latest version
09:53:02 <tweakism> should I go to a fedora-specifc channel maybe?
09:53:05 <Saizan> tweakism: you need to rm ~/.ghc too, but i don't see why it woulkd help here
09:53:18 <tweakism> Saizan: it wouldn't, but if I make this work I want to start over on my homedir-specific things
09:53:32 <tweakism> I'm just OCD.
09:53:38 <tweakism> about certain things.
09:53:46 * Saizan doesn't know if there's a fedora specific channel
09:54:00 <ManateeLazyCat> OCD?
09:54:06 <tweakism> obsessive-compulsive
09:54:26 <Saizan> though i'm not sure why ghc-pkg wouldn't know about the installed packages
09:54:28 * applicative just joined #fedora-unregistered
09:55:50 * applicative refuses to register for real #fedora
09:56:31 <aristid> applicative: who cares :P
09:56:48 * Saizan sticks to the generic binary tarball and feels warm inside
09:57:10 * applicative was showing Saizan there's a fedora-specific channel, of course
09:57:44 <tweakism> heh.  well there is a #fedora-haskell.  I asked there but there are only like 6 people there so an answer, if any, will take a long time.
09:59:03 <tweakism> Non-installed packages containing the string "ghc" but not "i686": http://fpaste.org/kz56/
09:59:23 <tweakism> should I yum install haskell platform?
09:59:24 <ManateeLazyCat> tweakism: Can you google it? Maybe other fedora haskeller has fix it ....
09:59:39 <tweakism> ManateeLazyCat: I have been, haven't found anything yet
10:00:29 <Saizan> well, the haskell platform is supposed to be a working set of packages, so maybe you'd have better luck :)
10:00:39 <tweakism> I mean from the fedora repo
10:01:00 <Saizan> yeah, me too
10:01:03 <tweakism> k
10:01:29 <Saizan> or maybe you just need the -devel versions?
10:01:38 <monoidal> i've got vector-0.6.0.1 installed but cannot import Data.Vector. what's wrong?
10:01:44 <tweakism> Saizan: you think I do?
10:02:01 <tweakism> I wish yum had an "install -devel version for the following packages"
10:02:09 <Saizan> tweakism: sounds likely
10:02:13 <tweakism> Saizan: k
10:02:14 <tweakism> will try
10:02:15 <tweakism> can't hurt
10:02:16 <ManateeLazyCat> monoidal: Add in build-depends of .cabal file?
10:02:32 <monoidal> i cannot do that in ghci
10:02:54 <ManateeLazyCat> monoidal: :m Data.Vector ?
10:02:55 <Saizan> though i'm not sure what's in the non-devel packages, .so's?
10:03:06 * hackagebot hlibfam 0.1 - FFI interface to libFAM  http://hackage.haskell.org/package/hlibfam-0.1 (AycanIrican)
10:03:07 <tweakism> Saizan: if I knew more about haskell I could probably answer you
10:03:13 <monoidal> ManateeLazyCat: it says could not find module
10:03:16 <tweakism> I welcome this learning experience tho
10:03:37 <Axman6> monoidal: what does ghc-pkg list say about vector?
10:03:54 <Saizan> tweakism: well, you could paste the list of the files in the package, yum should have a command for that
10:03:58 <monoidal> Axman6: it's in ~/.ghc/i386-linux-6.12.1/package.conf.d
10:04:10 <tweakism> Saizan: k 1 sec
10:04:26 <Axman6> does does it show in red?
10:04:33 <monoidal> Axman6: in white
10:04:39 <Saizan> monoidal: did you restart ghci after installing vector?
10:04:40 <Axman6> hmm
10:04:47 <tweakism> Saizan: yes just .so's
10:04:59 <monoidal> Saizan: yes
10:05:26 <tweakism> installing -devel's
10:05:30 <Saizan> tweakism: thanks :)
10:05:49 <tweakism> Saizan: I'm sick; I'm not thinking 100% clearly today :P
10:05:51 <monoidal> i did ghc-pkg check, ghc-pkg recache, but didn't help
10:05:51 * Saizan is not used to ghc having dynamic linking support
10:06:14 <Saizan> monoidal: what error message do you get?
10:06:32 <tweakism> I automated install of relevant -devel pkgs w/ rpm -qa | grep ^ghc| sed, yay
10:06:39 <tweakism> unix ftw
10:06:44 <monoidal> Saizan: Could not find module `Data.Vector':  it is not a module in the current program, or in any known package.
10:08:25 <Saizan> monoidal: so i guess "ghc-pkg find-module Data.Vector" doesn't list any package, does "ghc-pkg describe Vector" list that module?
10:09:19 <monoidal> Saizan: find-module shows vector-0.6.0.1 in ~/.ghc/i386-linux-6.12.1/package.conf.d
10:09:50 <monoidal> Saizan: describe vector gives description from cabal
10:10:07 <Saizan> monoidal: ah, are you sure the ghci you're using matches this ghc-pkg?
10:10:08 * hackagebot hlibfam 0.2 - FFI interface to libFAM  http://hackage.haskell.org/package/hlibfam-0.2 (AycanIrican)
10:10:24 <monoidal> Saizan: no; how to check?
10:11:10 <tweakism> Saizan: Worked.  Thank you so much.  This has been an unusually helpful IRC experience.  Logs from this channel w/ you talking on google helped me too.  Thx again.
10:11:22 <ManateeLazyCat> monoidal: --version ?
10:11:54 <monoidal> it's 6.12.1 in both cases
10:11:57 <Saizan> monoidal: see if the --version of the two matches, and also if they are installed in the same directory
10:12:02 <Saizan> tweakism: no problem :)
10:12:35 <monoidal> they're in the same directory
10:12:46 <ManateeLazyCat> monoidal: I have install vector-0.6.0.1 for test, works fine. NO idea why you can't work. :)
10:14:18 <tweakism> davean: this channel is awesome.
10:14:35 <applicative> Saizan, monoidal, how can it be that the second ghc-6.12.1 installation didn't overwrite the other?
10:14:42 <Saizan> monoidal: you could also start ghci with -v, and check if the "Using binary package database" lines match the ones from ghc-pkg list
10:14:53 <applicative> if they're in the same directory, I mean.
10:15:07 <pastorn> is there some nice keyword that gives back the minimal definition for a typeclass?
10:15:19 <pastorn> :minimal ClassName or something...
10:15:42 <Saizan> applicative: that's a possibility, but it's quite unusual to not overwrite the package database too
10:16:01 <applicative> I see
10:16:15 <ManateeLazyCat> monoidal: If all can't work, maybe you need re-install ghc again. I doubt something wrong with ghc...
10:16:48 <applicative> I wonder which of the old ghc's will be overwritten by the new one....
10:17:02 <kmc> pastorn, that's not part of the language :/
10:17:05 <kmc> it's just in documentation
10:17:39 <applicative> @src Num
10:17:39 <lambdabot> class  (Eq a, Show a) => Num a  where
10:17:39 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:17:39 <lambdabot>     negate, abs, signum     :: a -> a
10:17:39 <lambdabot>     fromInteger             :: Integer -> a
10:17:53 <applicative> kmc, I think he means something like that in ghci or whatever
10:18:55 <benmachine> it depends on a level of inspection of the source which may not be possible of compiled code
10:19:27 <kmc> afaik there's no standard format for specifying that
10:19:47 <kmc> however a GHCi command that jumps you to the haddock for something would be cool
10:19:49 <kmc> and should be doable
10:20:06 <Saizan> :! hoogle --info
10:21:02 <Saizan> for the minimal definition one could do a simple dependency analysis after typechecking, and offer multiple alternatives in the case of loops
10:21:53 <monoidal> Saizan: when I run ghci -v, it says vector is unusable due to missing dependency on ghc-6.12.1
10:22:44 <monoidal> Saizan: i have that package in /usr/local/lib/ghc-6.12.1/package.conf.d, but vector is installed in ~/.ghc/i386-linux-6.12.1/package.conf.d. could that be the reason?
10:22:59 <Saizan> monoidal: no, that would be fine
10:24:10 <Saizan> monoidal: though if ghci is saying that than ghc-pkg check should report something
10:24:14 <applicative> monoidal, it sounds like your ghci thinks it is not using ghc-6.12.1 which is strange
10:24:54 <Saizan> applicative: i think it's referring to ghc the haskell package there, not the compiler itself
10:24:57 <monoidal> ghc-pkg check doesn't output anything. ghc -v gives me a long list of unusable and hidden libraries
10:25:06 <applicative> oh, i see
10:27:14 * hackagebot liboleg 2010.1.6 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.6 (DonaldStewart)
10:27:37 <applicative> I'm puzzled, I do have a ghc-6.12.1 package registered, but it's hidden. 
10:28:05 <Saizan> monoidal: did you check the database paths as i asked earlier?
10:28:14 <c_wraith> applicative, I think it's hidden by default
10:28:43 <applicative> c_wraith, but I can also load Data.Vector.
10:30:47 <Saizan> "ghc" being hidden is not a problem
10:30:50 <applicative> c_wraith, what would require that the ghc-6.12.1 package be exposed?
10:31:05 <monoidal> Saizan: ghc -v uses the same two binary database packages as ghc-pkg list
10:31:25 <Saizan> monoidal: you mean ghci?
10:31:30 <monoidal> yes
10:32:17 <Saizan> then i guess there's something broken in your packages that ghc-pkg check doesn't catch, might be worth a bug report
10:32:22 <monoidal> i get a long list of missing dependencies when running ghci -v (including vector)
10:32:37 <monoidal> but there is no error when reinstalling
10:32:50 <Saizan> btw, running both from the same user, right?
10:32:59 <monoidal> yes
10:33:16 <shajen> i have some problem with haskell
10:33:24 <Saizan> btw, vector doesn't even need ghc as a dependency.
10:33:27 <shajen> i have a list where i have more list
10:33:33 <ManateeLazyCat> monoidal: Waht's the *first* broken package?
10:33:42 <shajen> like [[1,2,3],[4,5,6],[7,8,9]]
10:33:56 <applicative> shajen, a list of lists of Ints, yes
10:34:07 <shajen> i and i what tuple (x,y,z) where x is in first list y in second and z in third
10:34:20 <monoidal> ManateeLazyCat: package Cabal-1.8.0.2-bc92fe5... is unusable due to missing or recursive dependencies on process-1.0.1.2-796f...
10:34:35 <applicative> shajen, why not a list of the three, rather than a tuple
10:34:46 <applicative> > map head  [[1,2,3],[4,5,6],[7,8,9]]
10:34:47 <lambdabot>   [1,4,7]
10:34:49 <shajen> ok list is better
10:34:54 <ManateeLazyCat> shajen: Tuple use for different type.
10:34:59 <ManateeLazyCat> shajen: list for same type.
10:35:04 <Saizan> monoidal: oh, sorry, can you paste your whole ghc-pkg list ?
10:35:28 <Saizan> > transpose [[1,2,3],[4,5,6],[7,8,9]]
10:35:29 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
10:35:30 <shajen> applicative: ok but i want all three list  not only head of list
10:36:07 <applicative> transpose, like Saizan says?
10:36:44 <applicative> transpose is like turning a matrix sideways, uh that is, like transposing a matrix
10:36:50 <Saizan> monoidal: it might just be a weird case of this http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
10:37:49 <applicative> > transpose [[1,2,3,4,5], [6,7,8,9,10]] -- shajen
10:37:50 <lambdabot>   [[1,6],[2,7],[3,8],[4,9],[5,10]]
10:38:07 <sioraiocht> huh, WGP deadline was extended
10:38:26 <ddarius> applicative: Displayed as a graphic, a transposition can't, in general, be arrived at by a rotation.
10:39:05 <ddarius> Transposition is reflecting about the diagonal.
10:39:06 <shajen> applicative: ok, but i want all permutation of elemnts not only 1 with 1 2 with 2
10:39:08 <monoidal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26105#a26105
10:39:13 <applicative> ddarius, yes, i was thinking that was no good, but it is right to say that library transpose is matrix transposition, modulo lengths
10:39:29 <dafis> > sequence [[1,2,3],[4,5,6]]
10:39:30 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
10:39:30 <lambdabot> dafis: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:42 <shajen> ok great :)
10:39:44 <dafis> shajen: like that?
10:39:58 <shajen> yes! thanks!
10:40:00 <applicative> dafis, the use of sequence is wonderful
10:42:07 <Saizan> monoidal: ok, you've Cabal-1.8.0.2 installed both in the user and global package db, you've to unregister the user one
10:42:17 <kmc> is there any particularly good reason why Chan does not have a non-blocking read operation
10:43:46 <monoidal> Saizan: just did
10:44:32 <ManateeLazyCat> monoidal: Yes, i have same problem like you. I guess you install Cabal, then you use "cabal install cabal" update new version?
10:44:48 <c_wraith> semi-related to kmc's question...  Why isn't there a version of tryTakeMVar with a timeout?
10:44:55 <ManateeLazyCat> monoidal: If so, you need unregister user one like Saizan said.
10:45:51 <svk_> Hey, Parsec question: does naturalOrFloat handle negative numbers? If not, is there something like an integerOrFloat?
10:45:54 <Saizan> kmc, c_wraith: you can make one with forkIO
10:46:14 <kmc> indeed, you could use System.Timeout
10:46:16 <c_wraith> Seems silly to require forkIO for timeouts
10:46:20 <svk_> Or does it handle negative floats but not negative integers, like I guess the name would indicate?
10:46:36 <Saizan> svk_: have you tried it?
10:46:36 <kmc> (which uses forkIO behind the scenes, and get some of the intricate exception handling stuff right)
10:46:51 <svk_> Saizan: Yeah, I have a bug in my parser related to negative numbers
10:46:54 <kmc> eh i keep hearing this "threads are too heavy-weight for my problem"
10:47:07 <svk_> I use naturalOrFloat for parsing, not sure if that is the cause
10:47:14 <kmc> i think it's mostly a carryover from lesser languages
10:47:14 <Saizan> svk_: try it in isolation.
10:47:25 <applicative>  naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
10:47:54 <kmc> but anyway it makes sense to abstract out the idea of a timeout on an IO action, and that's what System.Timeout does
10:48:53 <edwardk> hah so i went and crafted my careful c wrappers for floats and doubles so i could abstract over the floating point mode, but now i find that there seems to be no good way to convert a Double to a CDouble without destroying most of the exotic values in the process.
10:48:55 <Saizan> applicative: we don't have a Natural type, so that's not so indicative :)
10:49:31 <applicative> yeah, the documentation is clear, it doesn't work for negative.
10:49:37 <edwardk> i'm left with unsafeCoerce and hoping ;)
10:49:48 <applicative> this makes sense, one should handle '-' with the parser
10:51:13 <Saizan> edwardk: see? C is a gateway drug to unsafeCoerce
10:52:06 <monoidal> how can I fix package shadowing (same versions)?
10:52:12 <svk_> Saizan: Fair enough, it seems like the answer is it doesn't handle anything negative?
10:52:33 <svk_> Or I guess that might mean I did something wrong in my language definition?
10:52:54 <applicative> svk_ this suggests that even if it seems to work, you should write what to do with '-', namely to chuck it and  return (zero minus what naturalOrFloat) returns.
10:53:22 <Saizan> or multiply by -1
10:53:39 <c_wraith> Data.Unique makes me very sad.
10:53:44 <svk_> I was considering that, I just noted that there were other signed parsers ("integer")
10:53:47 <Saizan> svk_: i don't know myself, the name suggests that it doesn't handle negative values though
10:54:06 <svk_> Is a "float" generally positive in Haskell lingo?
10:54:13 <krey> hello, i'm trying to understand continuations, could anyone please help?
10:54:30 <krey> (they're very new to me)
10:54:32 <Saizan> svk_: no, but natural surely is
10:54:33 <c_wraith> Data.Unique is one of those uses of STM that guarantees bad performance under contention
10:54:33 <ManateeLazyCat> krey: Ask real problem. :)
10:54:49 <svk_> Saizan: Yeah, which is why the name seemed sort of weird to me
10:54:59 <krey> ManateeLazyCat: I'm just trying to get my head round them
10:55:14 <krey> ManateeLazyCat: and then move on to the continuation monad
10:55:17 <svk_> Anyway, thanks for the Socratic help :)
10:55:20 <Saizan> svk_: naturalOrPositiveFloat would be too ugly to though :)
10:55:26 <svk_> I'll write my own negations, I guess
10:55:26 <applicative> > (-3.14 :: Float)
10:55:27 <lambdabot>   -3.14
10:55:53 <monoidal> can I ghc-pkg hide a specific version, like process-1.0.1.2-a906a112c1d18cafd27ba115a510dffc?
10:56:14 <Saizan> i don't think so
10:57:03 <monoidal> i've got two process-1.0.1.2, which seems to break everything
10:57:23 <ManateeLazyCat> monoidal: ghc-pkg unregister procss-1.0.1.1 --force ?
10:58:04 <monoidal> that will probably break ghc-6.12.1 package
10:59:05 <monoidal> one version of process-1.0.1.2 is installed in /home/g/.cabal/lib/process-1.0.1.2/ghc-6.12.1, second in /usr/local/lib/ghc-6.12.1/process-1.0.1.2
10:59:40 <ManateeLazyCat> monoidal: Well, your problem is you install cabal manually that conflict ghc.
11:00:03 <ManateeLazyCat> monoidal: So, install ghc and *cabal-install* maybe the cleanest way.
11:00:52 <ManateeLazyCat> monoidal: After you re-install ghc, and use bootstrap.sh in package *cabal-install*.
11:01:23 <ManateeLazyCat> monoidal: The bootstrap.sh of "cabal-install" just install package that have found in ghc.
11:01:47 <ManateeLazyCat> install package that *have not* found in ghc.
11:01:50 <ManateeLazyCat> Sorry, typo.
11:03:46 <ManateeLazyCat> monoidal: I doubt you install *Cabal* manually after you installed ghc. 
11:04:25 <applicative> svk_ I see, the float in naturalOrFloat and indeed in float must always be positive, you're right... 
11:05:00 <svk_> Huh, in "float" as well? I wasn't using that, but that sounds confusing
11:05:02 <ManateeLazyCat> monoidal: Because ghc has include Cabal, so when you install another Cabal will register in user-space, but ghc use global one. So it's conflict with ghc when you install other package (such as vector).
11:06:28 <applicative> svk, but it's appropriate at this level, i guess, just a confusing word to use.
11:06:34 <ManateeLazyCat> monoidal: Is it?
11:07:34 <monoidal> ManateeLazyCat: I think you are right. seems I will reinstall everything
11:07:52 <ManateeLazyCat> monoidal: Step like this: 
11:07:57 <ManateeLazyCat> 1) reinstall ghc
11:08:06 <ManateeLazyCat> 2) download cabal-install from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
11:08:17 <ManateeLazyCat> 3) use bootstrap.sh in cabal-install.
11:08:34 <monoidal> ok! will try.
11:09:14 <ManateeLazyCat> monoidal: Of course, you can install "mtl, parsec, network, HTTP, zlib, cabal-install" one by one. But boostrap.sh do those automatically. :)
11:09:45 <ManateeLazyCat> monoidal: Just one thing need noticed, don't install *Cabal*, because ghc has include it.
11:12:48 <Blkt> is there a way to get rid of the "IO" part (or Monad part) in a function that returns IO [Int]?
11:12:52 <Blkt> I need [Int] only
11:13:05 <Blkt> something opposite to liftM I suppose
11:13:21 <ManateeLazyCat> Blkt: Yes, liftM
11:13:45 <ManateeLazyCat> liftM (\[Int] -> ...) (return [Int])
11:13:52 <Blkt> so if I liftM (x :: IO [Int]) -> [Int] ?
11:13:58 <Blkt> awsome, thanks
11:13:59 <monoidal> you cannot in general change IO a to a (without unsafe tricks)
11:14:14 <mauke> Blkt: no, the other way around
11:14:23 <Philonous> Blkt: No, there is not. The problem is "IO a" doesn't realy contain an a, it's just a recipe to construct an a that might include side effects.
11:14:51 <Blkt> mmm
11:15:00 <Zao> You've got to do the Nike trick to get an a out of an IO a. ``Just do it!''
11:15:03 <monoidal> IO Int is something that performs some I/O and gives int. Int is an integer, and a value cannot have side effects
11:15:20 <Philonous> Blkt: You may, however, add some pure function to the recipe. i.e. once the a has be constructed it is fed to your function. The way to do that is (>>=)
11:15:22 <Blkt> what should I do if I need that integer only?
11:15:30 <mauke> Blkt: you never need that integer only
11:15:40 <Blkt> well
11:15:54 <Philonous> :t getLine >>= length
11:15:55 <lambdabot>     Couldn't match expected type `IO b' against inferred type `Int'
11:15:56 <lambdabot>     In the second argument of `(>>=)', namely `length'
11:15:56 <lambdabot>     In the expression: getLine >>= length
11:16:03 <Philonous> :t getLine >>= return . length
11:16:04 <lambdabot> IO Int
11:16:06 <monoidal> fmap length getLine
11:18:01 <Philonous> Blkt: Well, my bad. you use "fmap" or "liftM" (which, in this case, are synonymes) to add a pure function to the recipy. But you can lift a pure value to an IO value with return. So f >>= return . g is actually just fmap g f 
11:18:59 <Saizan> monoidal: if you're reinstalling from scratch make sure to rm ~/.ghc and to use ghc-6.12.2
11:19:10 <monoidal> or maybe .3?
11:19:25 <ManateeLazyCat> monoidal: Do you use install gtk2hs? If so, don't install 6.12.2
11:19:43 <Saizan> oh, there's a .3 already? than that
11:19:50 <ManateeLazyCat> Oh, 6.12.3 is release.
11:20:07 <ManateeLazyCat> I will to test it with gtk2hs now.
11:20:13 <ManateeLazyCat> monoidal: Good to know that.
11:20:25 <Saizan> monoidal: i was suggesting 6.12.2 since 6.12.1 doesn't wipe the global package db during installation
11:21:14 <Philonous> Blkt: Once you are in IO wonderland you never get out. But that's no problem because you can pull anything you might desire into it. 
11:21:32 <ManateeLazyCat> Saizan:  6.12.2 has a bug in runtime-system that crash when Haskell calls C.
11:22:03 <ManateeLazyCat> monoidal: If you don't use gtk2hs, ignore me, use 6.12.2. Otherwise use other version.
11:23:39 * ManateeLazyCat Downloading 6.12.3 for test gtk2hs.....
11:23:51 <djahandarie> Blkt, the idea is that you're eventually going to end up with a type of IO () because of main. So once you have wrapped your function f with IO, you'll need to carry it around all the way until you are done with your program. This means that anything that calls that function f will also need to be in the IO monad (and anything that calls that will need to be also, etc).
11:23:56 <ManateeLazyCat> http://darcs.haskell.org/download/docs/6.12.3/html/users_guide/release-6-12-3.html
11:24:26 <djahandarie> *sigh*
11:28:26 <ManateeLazyCat> ghc has RSS ?
11:28:46 <ManateeLazyCat> Then it can notice me when new version released.
11:30:56 <ski> Saizan : btw, re the formula i looked at before ..
11:30:59 <dafis> ManateeLazyCat, subscribe to one of the mailing lists?
11:31:13 <ski> one can prove a, in some places double-negated, intuitionistic (actually even minimal) logic version of the classical linear logical `(b -o o) -o (a -o o) |- ((t -> ?b) -o o) -> ((t -o a) -o ?o)'
11:31:27 <ski> namely `(b -> o) -> (a -> o) |- ((t -> ~~b) -> o) -> ((t -> a) -> ~~o)'
11:31:48 <ManateeLazyCat> dafis: I just care release, i'm too lazy and don't want check mail list. :)
11:31:58 <ski> the natural deduction proof term looks like `bo_ao |-> (\tCb_o |-> (\ta |-> (\ko |-> ko (tCb_o (\t |-> (\_ |-> ko (bo_ao (\b |-> tCb_o (\_ |-> (\kb |-> kb b))) (ta t))))))))'
11:32:16 <ski> (in sequent calculus, it looks like `(\ (\b |-> o2) |-> (\a |-> o1)) |-> (\ (\ (\_ |-> (\ (\b |-> v2) |-> v2)) |-> o2) @ (\ (\t |-> (\_ |-> v1)) |-> o0) |-> (\ (\t |-> a) |-> (\ (\o1 |-> v1) @ (\o0 |-> v0) |-> v0)))' instead)
11:32:28 <ski> @type \bo_ao tCb_o ta ko -> ko (tCb_o (\t _ -> ko (bo_ao (\b -> tCb_o (\_ kb -> kb b)) (ta t))))
11:32:29 <lambdabot> forall t t1 t2 t3 t4. ((t1 -> t4) -> t2 -> t4) -> ((t -> (t1 -> t3) -> t3) -> t4) -> (t -> t2) -> (t4 -> t3) -> t3
11:32:42 <ski> @type \bo_ao tCb_o ta -> Cont $ \ko -> ko (tCb_o (\t -> Cont $ \_ -> ko (bo_ao (\b -> tCb_o (\_ -> Cont $ \kb -> kb b)) (ta t))))
11:32:42 <lambdabot> forall a t a1 r t1. ((a1 -> a) -> t1 -> a) -> ((t -> Cont r a1) -> a) -> (t -> t1) -> Cont r a
11:33:08 <ski> the `Cont r a' corresponds to `~~a', if we choose `r' to be `Void'
11:33:19 <Saizan> ?djinn ((b -> o) -> (a -> o)) -> ((t -> Not (Not b)) -> o) -> ((t -> a) -> Not (Not o))
11:33:19 <lambdabot> f a b c d =
11:33:19 <lambdabot>     void (d (b (\ e f -> void (d (a (\ g -> void (f g)) (c e))))))
11:33:23 <ski> (but we can actually prove it for any `r' as lambdabot showed)
11:33:32 <ski> @djinn ((b -> o) -> (a -> o)) -> (((t -> Cont v b) -> o) -> ((t -> a) -> Cont v o))
11:33:32 <lambdabot> f a b c =
11:33:32 <lambdabot>     MkC (\ d ->
11:33:32 <lambdabot>          d (b (\ e ->
11:33:32 <lambdabot>                MkC (\ _ ->
11:33:32 <lambdabot>                     d (b (\ _ ->
11:33:34 <lambdabot>                           MkC (\ f -> d (a (\ g -> b (\ _ -> MkC (\ _ -> f g))) (c e)))))))))
11:33:41 <shajen> is in haskell function like this : f [[1,2],[3,4]] = [1+3,2+4] = [4,6] ?
11:34:03 <monoidal> map sum
11:34:04 <ski> but for some reason, lambdabot doesn't generate the exact same proof .. it uses `d' and `b' ^ three times instead of two times
11:34:23 <ski> Saizan : hm
11:34:29 <mauke> > (map sum . transpose) [[1,2],[3,4]]
11:34:29 <lambdabot>   [4,6]
11:34:47 <shajen> great! thanks
11:34:48 <monoidal> oh, transpose
11:35:39 <applicative> > (map sum . transpose) [[0,1,2],[3,4,5]]
11:35:40 <lambdabot>   [3,5,7]
11:35:41 <ski> Saizan : actually, when you tried with `Not . Not' it gave the same proof as my proof :)
11:35:45 <ManateeLazyCat> Have exist function equal (map sum . transpose) ?
11:35:55 <ski> @djinn ((b -> o) -> (a -> o)) -> (((t -> Cont Void b) -> o) -> ((t -> a) -> Cont Void o))
11:35:55 <lambdabot> f a b c =
11:35:55 <lambdabot>     MkC (\ d ->
11:35:55 <lambdabot>          void (d (b (\ e ->
11:35:55 <lambdabot>                      MkC (\ f -> void (d (a (\ g -> void (f g)) (c e))))))))
11:36:05 <ski> (and that's the same, as well)
11:36:09 <ski> .. interesting
11:37:35 <Saizan> it's probably just an artifact of the search?
11:37:45 <ski> i suppose so
11:39:07 <ski> (though it shouldn't be able to find more proofs when `v' is not known to be `Void' than when that is known .. so presumably the instantiation of `v' to `Void' changed the order in which it tried things .. trying more instantiated things first, or something like that)
11:39:14 <monoidal> > foldr (zipWith (+)) (repeat 0) [[1,2],[3,4]]
11:39:15 <lambdabot>   [4,6]
11:39:37 <monoidal> but this doesn't handle nonrectangular arrays correctly
11:40:31 <ski> anyway, i just wanted to share that there was an simple modification of the formula by insertion of two double-negations which was intuitionistically provable
11:40:55 <Saizan> yup, i see
11:41:08 <ski> (and thinking about it in the continuation monad might give a feel for how it actually computes)
11:41:43 <mreh> 1 nil
11:41:43 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
11:41:46 <Saizan> so we'd need anti-classical axioms to prove that the plain version is impossible :)
11:41:49 <mreh> @messages
11:41:49 <lambdabot> dafis said 58m 59s ago: Sure. Where?
11:42:24 <ski> yes (since the modification was classically equivalent)
11:42:48 * ski wonders what might be appropriate anti-classical axioms for that
11:43:10 <ski> `Not (forall a. Either a (Not a))' ?
11:46:38 * ski proceeds to investigate the alternative proof suggested by lambdabot
11:54:17 <sinelaw> top
11:54:30 <sinelaw> oops, this is not a terminal. :P
11:54:34 <sinelaw> heh
11:54:55 <sinelaw> hey conal!
12:05:37 <shajen> i have again problem :)
12:05:47 <sinelaw> what
12:06:23 <shajen> is easy way to turn list like this [[1,2],[3,4]] to [[1,3],[2,4]]
12:06:52 <kaol> Like matrix transpose?
12:07:35 <shajen> yes
12:07:41 <monoidal> transpose. if you have only two lists, zip
12:08:07 <geheimdienst> > transpose [[1,2],[3,4]]
12:08:08 <lambdabot>   [[1,3],[2,4]]
12:08:17 <geheimdienst> > transpose [[1,2],[3,4],[8,9]]
12:08:18 <lambdabot>   [[1,3,8],[2,4,9]]
12:08:28 <geheimdienst> > zip [[1,2],[3,4],[8,9]]
12:08:29 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [([t], b)])
12:08:29 <lambdabot>    arising from...
12:08:34 <monoidal> > zip [1,2] [3,4]
12:08:35 <lambdabot>   [(1,3),(2,4)]
12:08:53 <geheimdienst> yeah, but that has tuples, not arrays (just wanted to check)
12:09:01 <shajen> question was stupid :) sory
12:09:03 <monoidal> > zip3 [1,2] [3,4] [8,9]
12:09:04 <lambdabot>   [(1,3,8),(2,4,9)]
12:09:07 <shajen> it easy :)
12:10:32 <hpc> it's a shame there isn't an elegant way to turn an n-tuple into an n+1-tuple in native Haskell
12:10:47 <geheimdienst> > zip17
12:10:48 <lambdabot>   Not in scope: `zip17'
12:10:49 <hpc> sans extensions
12:14:23 <smarmy> a question on existentials...
12:14:38 <smarmy> suppose i have the rather silly type: data T = forall a . Show a => T { unT :: a }
12:14:46 <smarmy> then "foo (T t) = show t" is legal
12:14:53 <smarmy> but "foo t = show . unT" isn't
12:15:10 <smarmy> the compiler tells me to use the pattern matching syntax instead of the record selector
12:15:15 <smarmy> but they seem equivalent
12:15:17 <smarmy> any reason?
12:15:50 <smarmy> and is there ever a case where unT is usable?
12:16:31 <ski> smarmy : `unT' can only be used there to update the field, not to extract the field
12:16:58 <ski> the type of the field extraction would be
12:17:11 <ski>   unT :: T -> exists a. Show a *> a
12:17:19 <ski> but that can't be expressed in haskell
12:17:30 <ski> but you can still update with it
12:17:33 <ski> if you have
12:17:39 <ski>   t :: T
12:17:43 <ski> and
12:17:55 <ski>   x :: a
12:17:56 <ski> where
12:18:00 <ski>   Show a
12:18:05 <ski> then you have
12:18:17 <ski>   t { unT = x } :: T
12:19:00 <ski> (and of course the type of the "old" value inside `t' needn't have been of type `a' (the type of `x'), it could have been any other type)
12:19:05 <aristid> ski: exists a. is valid haskell?
12:19:22 <ski> <ski> but that can't be expressed in haskell
12:19:30 <aristid> oh :D
12:19:31 <ski> so, no, it's not valid haskell
12:20:07 <ski> (even though some haskell implementations support at least some forms of it, iirc .. jhc and lhc ?)
12:20:23 <smarmy> thanks ski
12:20:27 <hpc> Large Haskell Collider?
12:20:37 <ski> L? Haskell Compiler
12:20:45 <ski> @where lhc
12:20:46 <lambdabot> http://lhc.seize.it/
12:20:54 <monoidal> how to use unT to update? (T 'a') { unT = 'b' } doesn't work
12:21:09 <ski> (and maybe ehc as well .. i don't recall)
12:22:30 <smarmy> hmmm... i get a compiler error on 6.10 telling me that record update isn't supported and to use pattern matching instead
12:22:46 <monoidal> Record update for insufficiently polymorphic field: unT :: a
12:22:48 <EvanR> + is usually called a binary operation (takes two parameters), why is ? : not called a trinary operation
12:23:09 <Liskni_si> it's called ternary
12:23:20 <EvanR> docs and pracitioners call it ternary
12:23:26 <EvanR> whats wrong with trinary
12:24:45 <ManateeLazyCat> Hmmm... Looks ghc-6.12.3 have fix bug in ghc-6.12.2, i have test it with newest gtk2hs, works fine.
12:27:27 <hpc> EvanR: for the same reason that second-degree polynomials are called "quad"ratic
12:27:32 <hpc> aka, "because they said so"
12:27:48 <EvanR> that also makes no sense
12:33:26 <jajamana> Using HUnit, is there any reason why "runTestTT (TestCase (True @=? False))" shold fail to fail. I was expecting a failure but the test seems to pass successfully!?
12:33:44 <i_am_neuron> I'm getting troubles defining a type with polymorphic function types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26106#a26107, rank-2 types are proposed by GHC. Is there are way to declare that function types without enabling rank-2 types?
12:34:46 <jajamana> If I do "runTestTT (TestCase (assertEqual "sane" True False))" it fails as expected..
12:35:09 <jajamana> I think these test should be equivalent?!
12:35:10 <ski> smarmy : ok, it turns out i recalled not exactly right
12:36:15 <ski> smarmy : i thought you could update with fields in an existential quantified record `data' type, but apparently you can only use the field name to *construct* and to *pattern-match*
12:36:54 <ski> (for fields whose typees does not mention existentially quantified variables, you can still select and update, as usual, though)
12:37:00 <ManateeLazyCat> i_am_neuron: write "data R = forall a . Protocol a => R { acceptors :: [IO a], bind :: IO a ->R ... }
12:38:28 <ski> smarmy : so instead of `t {unT = x}' you must write `case t of T {unT = y} -> T {unT = x}'
12:38:33 <i_am_neuron> ManateeLazyCat: acceptors is a heterogeneous list (i.e. a's inside could be different, and also different from 'a' in bind). I assume that type checker will infer a and "fix" it inside R. Is this correct? If yes, this is not what I need
12:39:00 <ski> (and if you don't want to use `y' in `x', you can of course omit `unT = y' in the pattern)
12:39:13 <ManateeLazyCat> i_am_neuron: You can use some Type wrap "IO a"
12:39:45 <ManateeLazyCat> i_am_neuron: data Wrap = forall . Protocol a => Wrap {IO a}
12:39:57 <ManateeLazyCat> i_am_neuron: Then make "acceptors :: [Wrap]
12:40:04 <ManateeLazyCat> i_am_neuron: Then can pass typecheck.
12:40:30 <smarmy> ski: gotcha
12:40:33 <i_am_neuron> ManateeLazyCat: Great, this sounds like exactly what I need, thanks
12:41:15 <ManateeLazyCat> i_am_neuron: For pick up "a" from Wrap, i recommand you define Protocol class like this "class Typeable a => Protocol a where"
12:41:31 <ski> i_am_neuron : do you intend for the `a' in the type of the fields `acceptors' and `bind' to be a single concrete hidden type (possibly different ofr eacch value of type `R' ?
12:41:52 <i_am_neuron> ski: Nope. acceptors is heterogeneous
12:41:57 <ski> i_am_neuron : or do you intend for the functions stores in the `acceptors' and `bind' fields to be polymorphic in `a' ?
12:42:31 <ManateeLazyCat> i_am_neuron: Because all all "Protocol a" is "Typeable a", you can use Tyepable.cast to pick "a" from Wrap. 
12:42:43 <ManateeLazyCat> i_am_neuron: For type-safe polymorphism function.
12:43:11 <ski> i_am_neuron : oh, so `acceptors' should store a list of `IO'-actions that return values of possibly different types, with the constraint that they have to be in `Protocol' ?
12:44:07 <ski> ok
12:44:39 <i_am_neuron> ski: yes, this is correct
12:44:59 <ski> i_am_neuron : note that what you actually want then is `acceptors :: [exists a. Protocol a *> IO a]' (which is completely different from what you had written)
12:45:08 * ManateeLazyCat pasted "polymorphism function with TypeClass" at http://paste2.org/get/874990
12:45:12 <ManateeLazyCat> i_am_neuron: Looks above.
12:45:26 <ski> but since haskell doesn't support existential types directly, you must encode that as ManateeLazyCat suggested with `Wrap'
12:46:15 <i_am_neuron> ski: Yeah, I'll go for it
12:46:22 <ski> (the placement of the `forall' *before* the data constructor `Wrap' in the definition of `Wrap' makes the type `Wrap' an "existentially quantified data type")
12:46:31 <ManateeLazyCat> Check pageApplyBuffer, for any common function in class "Protocol a", you can write your own function like pageApplyBuffer
12:46:32 <i_am_neuron> ManateeLazyCat: and you use cast in some other place, right?
12:46:57 <ski> i_am_neuron : btw, note that there's a possible variant : `acceptors :: [IO (exists a. Protocol a *> a)]'
12:47:04 <ManateeLazyCat> i_am_neuron: cast just when you want write some special function for Protocol instance that haven't define in Protocol class.
12:47:36 <ManateeLazyCat> i_am_neuron: Because Typeable.cast return Maybe result, so you always type-safe.
12:47:55 <ski> in this case, what type `a' each `IO'-action uses can be determined *after* each run of the `IO'-action (instead of determining it for each `IO'-action once, before running it)
12:48:20 <i_am_neuron> ski: is 'exists a.' works out of the box? Somehow I thought that existential types are not supproted in Haskell
12:48:33 <ski> possibly you don't need this extra power, but it's there if you need it (if you change the type of `Wrap' accordingly)
12:48:43 <kmc> existential types are not in the Haskell standard, but are supported by various implementations as an extension
12:48:53 <kmc> GHC has them, though not directly -- you can't use the "exists" syntax
12:48:58 <ski> <ski> but since haskell doesn't support existential types directly, you must encode that as ManateeLazyCat suggested with `Wrap'
12:49:01 <ski> i_am_neuron : ^
12:49:02 <kmc> you have to declare a new type
12:49:11 <ManateeLazyCat> i_am_neuron: I explain my code. http://paste2.org/get/874990 . For apply common function that define in Protocol class, i use (Page {pageView = (PageViewWrap x)}) pick "x" from PageViewWrap. 
12:49:18 <kmc> some other implementations do support existentials directly however
12:49:51 <ski> i_am_neuron : i was using `exists a.' to better explain what the type behaviour that you want is, but in actual current haskell, you have to encode that using a `Wrap' type
12:50:30 <ManateeLazyCat> i_am_neuron: Example, you have two instance for Protocol class : FooA, FooB, and you want write some special function just for FooA or FooB, you can pick-up "x" first, then use (Typeable.cast x :: FooA) or (Typeable.cast x :: FooB) to apply special instance function. 
12:50:54 <i_am_neuron> ski: I see. As far as I understand, inferring a from Wrap instance implies 'exists'  qualifier
12:51:00 <ski> i_am_neuron : btw, note that using `Typable' is a separate concern from existential types .. possibly you also need `Typable', possibly you don't
12:51:25 <ski> if you define
12:51:35 <i_am_neuron> ManateeLazyCat: yep, this is clear
12:51:54 <ski>   data Wrap = forall a. Protocol a => Wrap (IO a)
12:52:05 <ManateeLazyCat> i_am_neuron: If you just function that define in Protocol class, you don't need Typeable.
12:52:33 <ski> this means that for every type `a', such that `Protocol a' holds, if `x :: IO a', then `Wrap x :: Wrap'
12:52:59 <ski> i.e. `Wrap :: IO a -> Wrap', for every `a' such that `Protocol a'
12:53:11 <ski> i.e. `Wrap :: forall a. Protocol a => IO a -> Wrap'
12:53:31 <ManateeLazyCat> i_am_neuron: The key is, use Wrap *pack* polymorphism type, then *unpack* those polymorphism type after pass type-check.
12:53:55 <ski> so, if you have any type `a', and you also have that `a' in class `Protocol', then you can wrap any value of type `IO a' into a `Wrap'
12:54:14 <ski> i.e. `Wrap :: (exists a. Protocol a *> IO a) -> Wrap'  (roughly, pseudo-haskell)
12:54:43 <ski> and this is why the `forall' *before* the data constructor translates to *existentials*
12:55:14 <i_am_neuron> ski: Great, thanks for this explanation
12:55:41 <i_am_neuron> ManateeLazyCat: Thank you for your code snippet and explanation too
12:56:09 <ski> i_am_neuron : so, will the `bind' field contain a polymorphic function, in a specific value of type `R' ?
12:56:27 <ManateeLazyCat> i_am_neuron: Perhaps have other advantage tips. AFAIK, "Typeable class + forall Wrap" is cheapest one.
12:56:28 <ski> or will `bind' also only work on a single fixed `a', in each case ?
12:57:04 <i_am_neuron> ski: polymorphic of course :)
12:57:50 <ski> (i_am_neuron : btw, note that `data Wrap = Wrap (forall a. Protocol a => IO a)' would mean something entirely else, with `forall' *after* the data constructor .. in *this* case, the argument is *polymorphic* in `a', instead of only working on a specific, hidden `a')
12:58:16 <ski> i_am_neuron : ok, so say `bind :: forall a. Protocol a => IO a -> R', then :)
12:58:30 <edwardk> ye gods that was harder than it should have been. i now have a newtype wrapper for controlling rounding modes on doubles in ghc. next to add floats and package it
12:58:53 <ManateeLazyCat> ski: We flood i_am_neuron , let he think a moment. :)
12:59:53 <krey> Can anyone please tell me what fmap is for continuations?
12:59:54 * ski idly ponders what more related useful tidbits one could force down i_am_neuron's throat ;)
13:00:03 <ski> @src Cont fmap
13:00:03 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
13:00:15 <ManateeLazyCat> :)
13:00:17 <krey> ski: cheers
13:00:43 <i_am_neuron> ski: aha, the tricky thing here is that R is returned, right? But let me think, I'll digest this now
13:00:54 <ski> @djinn (a -> b) -> ((b -> o) -> o) -> ((a -> o) -> o)
13:00:54 <lambdabot> -- f cannot be realized.
13:01:01 <ski> eh
13:01:05 <ski> @djinn (a -> b) -> ((a -> o) -> o) -> ((b -> o) -> o)
13:01:05 <lambdabot> f a b c = b (\ d -> c (a d))
13:01:15 <ski> krey : ^ same thing, basically
13:01:29 <ski> @djinn (a -> b) -> (Cont o a -> Cont o b)
13:01:29 <lambdabot> f a b =
13:01:29 <lambdabot>     case b of
13:01:29 <lambdabot>     MkC c -> MkC (\ d -> c (\ e -> d (a e)))
13:01:47 <ski> i_am_neuron : the `R' from `bind' ?
13:02:03 <i_am_neuron> ski: yep
13:02:04 * hackagebot liboleg 2010.1.6.1 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.6.1 (DonaldStewart)
13:02:17 <ski> i'm not sure that should cause any problems
13:02:42 <ski> in some cases one might want some internal `a's inside that returned `R' to be the same as ones in the current `R'
13:02:49 <ski> but i don't think this is appropriate in your case
13:03:05 <dons> dolio: liboleg uses CC-delcont. thanks for packaging up Sabry's code.
13:05:52 <ski> i_am_neuron : btw, if you feel like, you could tell me how to define the `acceptors' field not with type `[exists a. Protocol a *> IO a]', but instead with type `[IO (exists a. Protocol a *> a)]' (so that the type `a' each action chooses is only determined after each run of the action) .. i.e. what type signature should `acceptors' get, and how should the corresponding `WrapProtocol' type be defined ?
13:10:11 <ManateeLazyCat> dons: Oleg's code is cool, but can you split those code with some packages? Example, liboleg-language, liboleg-system, liboleg-text. 
13:10:29 <i_am_neuron> ski: bind :: exist a . Protocol a => IO (IO a) -> R, I guess
13:11:00 <i_am_neuron> ski: You're using *> but I'm not sure what is this
13:11:47 <gwern> ManateeLazyCat: might increase the maintenance costs
13:12:29 <ManateeLazyCat> gwern: But not all code is user's need, most user just need apart of liboleg
13:12:44 <gwern> most users only need part of any library
13:12:45 <ManateeLazyCat> gwern: Nevermind, just suggestion.
13:13:50 <ManateeLazyCat> gwern: I mean little is neat since Oleg's code include different categories.
13:14:25 <dons> ManateeLazyCat: i don't really have time , due to the maintainance costs.
13:14:27 <ski> i_am_neuron : i've invented `*>' to go with `exists' in this imaginary syntax, similar to how `=>' goes with `forall'
13:14:40 <dons> basically, i can devote 1 hr / month to haddockizing his code and finding the right hierarchy
13:14:44 <dons> and resolving any deps
13:14:44 <i_am_neuron> ski: then it's exactly what I meant
13:15:16 <dons> if something in liboleg is useful it should be moved into its own package and improved (a la iteratee)
13:15:17 <ski> (i_am_neuron : it turns out that using `=>' with `exists' here would not be what you want (and not what one usually wants))
13:15:17 <ManateeLazyCat> dons: BTW, do you fix vacuum-cairo since it's failed with gtk2hs-0.11, i have send patch to you.
13:15:27 <dons> not yet. i'm very busy till july
13:15:33 <dons> but i have your patch, thank you!
13:15:38 <gwern> ManateeLazyCat: if you want to pull a section out and maintain it and improve it, thatd be good. I think his shuffle code would be good separate
13:15:50 <dons> shuffle is already in the perfectShuffle library
13:15:57 <monoidal> ski: F a *> x is like a pair (F a, x)?
13:16:01 <gwern> oh
13:16:05 <ManateeLazyCat> gwern: I will consider it.
13:16:33 <gwern> dons: then maybe define it over more datatypes? I'd guess perfectshuffle is only on lists, but there's also various arrays, Sequence, etc.
13:16:48 <ManateeLazyCat> ski: Why not just use "forall a" ? I think "forall a" is enough.
13:16:52 <pastorn> @type liftA
13:16:53 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
13:16:54 <pastorn> @type liftA2
13:16:55 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:16:58 <ski> i_am_neuron : so, to clarify, the exercise was to elaborate the pseudo-haskell field-declaration `acceptors :: [IO (exists a. Protocol a *> a)]' into actual haskell, just like ManateeLazyCat did with `acceptors :: [exists a. Protocol a *> IO a]', by saying `acceptors :: [Wrap]' and introducing a `Wrap' datatype
13:17:07 <pastorn> oh, right... Applicative, not Arrow :/
13:17:10 <ski> monoidal : exactly ;)
13:17:26 <dons> gwern: might be an interesting development effort
13:17:28 <monoidal> it looks like an adjunction between F a -> G a and (F a, G a)
13:18:00 <ski> ManateeLazyCat : imo, it can be clearer to think about the type, if you don't have to invent temporary types which factor out a sub-expression you'd rather leave in its place
13:18:00 <ManateeLazyCat> i_am_neuron: Bring new type *Wrap* to wrap your polymorphism function, unpack from Wrap after pass type-check.
13:18:34 <Hunner> so without all of these "how to understand functors/applicative/comonad" guides, how did you guys learn this in the first place?
13:19:07 <earthy> thinking through the code, trying to apply it.
13:19:26 <ski> monoidal : well, adjunction between `(C a,)' and `(C a =>)', rather
13:19:33 <monoidal> yes
13:19:54 <ManateeLazyCat> i_am_neuron: In principlely, think Wrap is *Box* to pass type-check. 
13:20:52 <ski> Hunner : hanging out here and discussing, reading blogs, reading papers, thinking
13:21:10 <pastorn> is there any real reason why i can't have a proc in a proc?
13:21:15 <ManateeLazyCat> i_am_neuron: Before type-check, *pack* your polymorphism function in Wrap. After type-check, *unpack* your polymorphism function from Wrap. That's all idea.
13:21:18 <pastorn> or am i just doing it wrong?
13:21:25 <earthy> oh, yeah, discussing with people helps, indeed, ski
13:21:39 <ski> (and obviously, an important part of those is considering actual examples, and spotting such examples in what other people claim they want)
13:21:53 <pastorn> f = proc x -> do
13:21:55 <pastorn>     returnA -< (proc y -> do returnA -< y) -< x
13:21:57 <fxr> What is the time complexity of Data.HashTable.lookup and insert ?
13:22:01 <pastorn> ^^ is this wrong?
13:22:13 <fxr> any ideas?
13:22:18 <pastorn> fxr: O(1+O(bucket)) i think
13:22:25 <pastorn> oh
13:22:33 <pastorn> O(1+bucketSize)
13:22:42 <pastorn> or log(bucketSize)
13:22:44 <ski> pastorn : afaik, that should be ok (as long as you don't use any arrow-local variables inside the inner `proc'-expression)
13:22:59 <pastorn> ski: i can't get it to work :(
13:23:05 <pastorn> could you please try it?
13:23:15 <fxr> any advice for a fast lookup table for string typed keys?
13:23:25 <pastorn> fxr: Array?
13:23:37 <gwern> man, the audio in this category-database really hurts my ears
13:23:38 <ManateeLazyCat> fxr: Use Text instead String 
13:23:40 <pastorn> fxr: how many updates are you counting on having?
13:23:42 <gwern> fxr: bytestring-trie
13:23:51 <ManateeLazyCat> fxr: Text is much much faster than String.
13:24:03 <pastorn> ManateeLazyCat: which package is this?
13:24:15 <gwern> ManateeLazyCat: for some things... wasn't there a -cafe thread recently on text being slower on somethings than string?
13:24:23 <ManateeLazyCat> pastorn: Data.Text.
13:24:42 <fxr> I'll try to implement a stat-cache for an http server and looking for your advices
13:25:02 <ski> pastorn : er
13:25:12 <fxr> a stat-cache simply caches stat() syscalls
13:25:12 <pastorn> ski: borked?
13:25:14 <ManateeLazyCat> gwern: In package dbus-core, author use Text replace String, i have test it, it's really much faster.
13:25:22 <ski> pastorn : what are you trying to do in that last `returnA -< (proc y -> do returnA -< y) -< x' actually ?
13:25:47 <dons> fxr: a) don't use String if you can use bytestring or text. b) bytestring-trie or Data.Map Text a
13:25:51 <pastorn> ski: just (arr id)
13:25:54 <dons> fxr: how many elements?
13:25:56 <pastorn> or, basically id
13:25:58 <ManateeLazyCat> gwern: I try use String instead Text for transform information through DBus message, slower explicitly.
13:26:11 <pastorn> since whatever it is should be an instance of Categore
13:26:16 <fxr> dons: I don't think it will grow above 1000
13:26:19 <pastorn> ski: fewd tiemz now... bbl
13:26:22 <dons> oh, then it doesn't matter :-)
13:26:26 <dons> Data.Map is ok.
13:26:41 <fxr> thank you
13:26:52 <ManateeLazyCat> fxr: I just use String when some FFI APIs need String.
13:26:55 <fxr> pastorn: I'll use bytestring 
13:27:00 <earthy> bytestring-trie be fast indeedy
13:27:10 <ManateeLazyCat> fxr: So, use ByteString or Text instead.
13:27:32 <ski> pastorn : you do know that in a `do' inside a `proc' each command should have (simplifying) the form `p <- a -< e', *except* the last which should have form `a -< e', here `a' is a normal haskell expression of arrow type, while `p' is a pattern binding arrow variables, and `e' is a haskell expression that may use the arrow-bound variables (the `a's may not use them) ?
13:27:57 <earthy> if you're not concerned with the actual values of the strings, do bytestring
13:28:11 <earthy> if you are interested in anything that is influenced by the encoding, use Text
13:28:27 <fxr> the parser already gives a bytestring to me, so I'll convert it to a CString when calling c_stat().
13:29:13 <ski> pastorn : i.e. `proc x -> do ...; z <- (proc y -> do ...) -< x; ...' should work fine, as well as `proc x -> do ...; (proc y -> do ...) -< x'
13:29:47 <ski> pastorn : so arrow `do' is similar to monadic `do' in that the last command can't bind new variables
13:30:36 <ski> (also note that you had `.. -< .. -< ..', while the actual syntax is `.. <- .. -< ..' for an arrow command binding variables (which can't be the last command))
13:32:09 <dons> fxr: you can convert to a CString very cheaply too (see the bytestring function for this)
13:33:13 <ManateeLazyCat> Hmmmm.... Looks have new bug in ghc-6.12.3, still in testing....
13:33:56 <fxr> dons: yeah thank you I know it
13:34:57 <fxr> first I need to benchmark the plain stat() and the cached one with criterion. then I'll implement it with hlibFAM.
13:35:24 <fxr> if I see no significant difference I'll trash this idea.
13:35:54 <dons> great
13:41:10 <ManateeLazyCat> I have test all gtk2hs demos, works fine.
13:41:32 <ManateeLazyCat> Glad to use newest ghc with gtk2hs. :)
13:41:36 <k23z__> ManateeLazyCat,   http://i.imgur.com/YcRRT.png
13:41:56 <ManateeLazyCat> k23z__: Where the manatee? :)
13:43:49 <k23z__> ManateeLazyCat, invisible manatee
13:44:27 <ManateeLazyCat> In true world, LazyCat is me, Manatee is my girl .... :)
13:46:21 <k23z__> so who's on now ?
13:46:33 <k23z__> Manatee or LazyCat ?
13:46:48 <gwern> dons: the audio on the category database talk is pretty bad - the static bursts are painful
13:47:20 <ManateeLazyCat> k23z__: LazyCat.
13:47:56 <gwern> k23z__: the pronouns give it away - 'LazyCat is me'
13:48:16 <k23z__> gwern, damn, you're smart
13:48:19 <gwern> ManateeLazyCat: were I a girl, I'm not sure I would appreciate eitehr 'LazyCat' or 'Manatee' as a nickname
13:48:55 <gwern> k23z__: all of us in #haskell have brains dripping with 7 secret spices and herbs
13:49:33 <k23z__> ManateeLazyCat, is your gf vegetarian because manatees are
13:50:27 <gwern> k23z__: manatees are carnivorous. just no human has survived to tell the tale
13:50:42 <k23z__> gwern, then LazyCat is lucky
13:51:15 <gwern> k23z__: no, manatees just have revenge-driven culinary preferences
13:52:24 * hackagebot rounding 0.0.1 - Explicit floating point rounding mode wrappers  http://hackage.haskell.org/package/rounding-0.0.1 (EdwardKmett)
13:52:31 <k23z__> http://upload.wikimedia.org/wikipedia/commons/1/1e/Manatee_at_Sea_World_Orlando_Mar_10.JPG  <-- this is awesome
13:52:39 <edwardk> finally, now i can actually write the code i wanted to write all along ;)
13:52:55 <Rikardo> s@index GLubyte
13:53:10 <Rikardo> @index GLubyte
13:53:10 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:53:31 <kmc> edwardk, i can only assume you're really working on an extremely roundabout way to calculate factorials
13:53:40 <edwardk> kmc: always )
13:54:09 <edwardk> kmc: i wanted to write some support for taylor models, which are a great application of very-high order automatic differentiation
13:54:31 <edwardk> a taylor model is basically an AD computed polynomial and an interval associated with the truncated terms
13:54:33 <Rikardo> @index PolygonSmooth
13:54:33 <lambdabot> Graphics.Rendering.OpenGL.GL.Hints, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:54:36 <ManateeLazyCat> k23z__: You maybe think my nickname is stupid, but for me, it's all my life. Not just for funny. :)
13:54:51 <edwardk> but to do interval arithmetic right you really need to control the rounding modes used on each bound
13:55:08 <kmc> right
13:55:11 <edwardk> so i need to go off and write a bunch newtype wrapper that let me control rounding modes on floating point operations
13:55:14 <edwardk> er needed
13:55:31 <edwardk> now i can go back and define newtype Interval a = I (Round Down a) (Round Up a)
13:55:35 <edwardk> er data
13:56:47 <edwardk> then the interval code needs to juggle the up and down wrappers but its pretty straightforward
13:57:00 <ManateeLazyCat> So will upgrade to 6.14 after ghc-6.12.3 ?
13:57:03 <edwardk> and i can compute taylor models to a given degree of accuracy, which avoid most of the problems with naive interval arithmetic
13:58:18 <edwardk> kmc: if that makes any sense at all =)
13:58:25 <kmc> it does :)
13:59:25 <edwardk> this should let me compute with a bunch of derivatives in a fairly ad hoc manner, and get an answer that contains a baked in exact error bound on the accumulated problems introduced by the derivatives and floating points
14:00:29 <jmcarthur> any ultimate goal in doing all this AD stuff? or is it all for its own sake?
14:00:57 <edwardk> jmcarthur: i have a few old projects that i'd like to apply it to, but really its a matter of supplying the ultimate answer to a stack overflow question ever...
14:01:05 <jmcarthur> lol
14:01:10 <edwardk> that and i'm putting together an article on the topic
14:03:01 <monoidal> is sin :: Float -> Float referentially transparent, given inaccuracy problems as in http://www.parashift.com/c++-faq-lite/newbie.html#faq-29.18?
14:03:20 <edwardk> that and i think that with a solid enough library and enough support there could be a great draw towards haskell given by such a library to a bunch of folks who are stuck using 'COSY INFINITY' and other very fortan'ish interfaces for such computations right now
14:03:41 <aristid> edwardk: you're probably _the_ expert on AD in haskell :D
14:03:41 <edwardk> monoidal: yes
14:03:53 <edwardk> monoidal: the problem is that the equality on floats isn't structural
14:04:04 <danharaj> The inaccuracies of float mainly ruin its algebraic properties.
14:04:12 <edwardk> monoidal: that and floating point arithmetic is often carried out at higher precision
14:04:45 <edwardk> aristid: i like to completely consume whatever area of research i find myself in
14:06:24 <aristid> edwardk: if that's what you crave
14:06:34 <aristid> i just love making bad jokes
14:06:50 <edwardk> aristid: it keeps me occupied ;)
14:07:15 <aristid> edwardk: do you work in academia?
14:07:28 <edwardk> aristid: nah, defense
14:07:44 <danharaj> i.e. academia with lasers
14:07:54 <edwardk> i.e. academia with money
14:08:00 <aristid> edwardk: ah, you're not the only defense guy here afaik
14:08:00 <danharaj> touche
14:08:02 <ddarius> danharaj: Non-defense academia also has lasers
14:08:16 <aristid> ddarius: wasn't you defense too?
14:08:20 <danharaj> ddarius: Their lasers aren't going pew pew pew.
14:08:41 <hpc> british defense has electromagnetic force shields :P
14:09:06 <hpc> they put a huge capacitor in a tank and they discharge it into the armor when a large shot is shot at them
14:09:19 <ddarius> aristid: I'm "in defense" in a rather different way than edwardk is "in defense."
14:10:30 <edwardk> ddarius: ddarius is enlisted, i write software that tries to help people control the cost of big govt programs. in the scrum analogy he is a pig, i'm a chicken ;)
14:10:41 <gwern> hpc: what's the point of that?
14:11:14 <aristid> ddarius: i take it you don't like my generalisation :P
14:11:23 <ddarius> edwardk: That's one way to look at it.
14:11:33 <hpc> gwern: it renders most of the armor unnecessary, as they can deflect missiles and large shells indefinitely
14:11:44 <hpc> they estimated about 2 tons could be taken off
14:11:52 <hpc> or 70%
14:11:55 <hpc> iirc
14:14:18 <alexyk> hpc: what if 50 shells hit the tank from all directions at once?
14:14:31 <kmc> then you're probably fucked no matter what
14:14:34 <ManateeLazyCat> 5:13 am here, night all. :)
14:14:37 <alexyk> or a giant mine from the bottom and a huge bomb from above?
14:14:43 <alexyk> and a torpedo from a nearby river
14:14:59 <hpc> a land mine is still unstoppable, and a tank wouldn't get torpedoed
14:15:16 <alexyk> hpc: except when fording a river on on board a ship
14:15:22 <alexyk> or
14:15:33 * hackagebot ad 0.44.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.44.1 (EdwardKmett)
14:15:51 <edwardk> alexyk: security isn't a total thing. you just need to make the cirumstances tricky enough that they don't occur in practice. beyond that its hard to justify the cost/benefit ratio.
14:16:14 <ddarius> Defense is always a "cost/benefit" ratio.
14:16:28 <edwardk> *nods*
14:16:28 <Philonous> alexyk: Then you have to cast a huge lamba into the sky and pray to oleg. Then - maybe - he invokes unsafePerfromDeflectProjectiles
14:16:58 <hpc> > unsafeTearAHoleInSpaceTime
14:16:59 <lambdabot>   Not in scope: `unsafeTearAHoleInSpaceTime'
14:17:04 <alexyk> edwardk: well the real point is, two hits, and your capacitor is not enough; two hits in a rapid succession
14:17:06 <edwardk> alexyk: i highly recommend following bruce schneier's blog. he serves as my one dose of rationality in this very paranoid world ;)
14:17:16 <aristid> i don't think defense expenditures are always determined by actual need of security
14:17:39 <ddarius> aristid: I don't think any expeditures are always determined by actual need.
14:17:41 <hpc> multiple shots in quick succession would still be stopped by a magnetized shell
14:17:56 <hpc> even if we allow such an improbable thing to happen
14:17:58 <aristid> ddarius: well, sure, and that's something to be aware of
14:18:11 <aristid> saying that it's always about cost/benefit is just a bit naive
14:18:33 <hpc> it's also about killing those terrorists before they can fluoridate our water
14:18:44 <sinelaw> the government already does that
14:18:49 <sinelaw> (flouridate the water)
14:18:54 <Linnk> yeah, and companies
14:19:11 <edwardk> going to go be sociable for a bit. i'll play with taylor models more later
14:19:13 <fxr> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26109#a26109 is it worth implementing a stat cache? I catched a difference.
14:19:24 <sinelaw> btw, there's a system that stops incoming projectiles by shooting many small metal pellets at it
14:19:45 <sinelaw> it's practical and deployed, i don't think the huge capacitor thing is practical 
14:19:51 <p_l> sinelaw: ... that's foundation of all PDSes
14:19:58 <hpc> it has been tested already
14:20:00 <Philonous> aristid: I think it's still about that, but "benefit" can be more than just actual security, like perceived security, political oportunity. That's why security theatre works for those who implement it. CYA saves your job.
14:20:05 <sinelaw> p_l, PDS?
14:20:11 <hpc> point defense
14:20:11 <p_l> Point-Defense Systems
14:20:18 <ddarius> hpc: It's not soo improbable.
14:20:28 <aristid> Philonous: yeah
14:20:39 <sinelaw> hpc, yes but is it really practical? i'm not saying no, just wondering
14:20:49 <p_l> currently fielded models include stuff like time-triggered fragmenting shells that create a cone of tungsten penetrators :)
14:21:32 <hpc> sinelaw: i don't know how much it costs to implement, but it works, and maintenance of the tank is significantly easier without the extra tonnage of armor to keep in constant repair
14:22:02 <sinelaw> can they charge the capacitor fast enough?
14:22:07 <mreh> that sounds like reactive armour
14:22:16 <hpc> the article didn't mention a charge time
14:22:22 <hpc> but it implied it can be done on the move
14:22:23 <mreh> is this #military?
14:22:28 <p_l> hpc: still some of the stuff that is in development would make it much less practical (because a light reactive armor would weigh less while giving higher protection)
14:23:18 <p_l> EM fields will be probably first (practically) used for active stealth systems like the one Russians are working on, or optical invisibility systems
14:23:27 <p_l> also airflow control
14:23:48 <wli> Not the invisibility cloaks like the Japanese are working on?
14:24:24 <p_l> wli: a different system based on plasma and EM fields
14:25:14 <sinelaw> http://www.youtube.com/watch?v=AywHHdcX9eM
14:25:21 <medfly> hi sinelaw! :-)
14:25:34 <sinelaw> hey medfly 
14:29:53 <Rikardo> @index createWindow
14:29:53 <lambdabot> Graphics.UI.GLUT.Window, Graphics.UI.GLUT, Graphics.X11.Xlib.Window, Graphics.X11.Xlib
14:32:29 <sizzler> I am looking at a type declaration so type ImpBounds t = Improving (AddBounds t) from http://hackage.haskell.org/packages/archive/reactive/0.11.4/doc/html/FRP-Reactive-Reactive.html#t%3AImpBounds. what does the parens around AddBounds signify here?
14:35:36 <monoidal> looks like normal type application
14:36:25 <sinelaw> medfly, how's univ.?
14:36:39 <monoidal> Improving and AddBounds are * -> *
14:36:42 <medfly> sinelaw, it's okay... has its problems
14:36:51 <sinelaw> problems?
14:37:09 <medfly> sure
14:37:23 <medfly> I'm unhappy, it fucks up studying
14:38:01 <sinelaw> oy vey zmir
14:38:33 <sizzler> monoidal, how can that type ImpBounds be represented given if I have a Improving and an AddBounds value
14:38:53 <Rikardo> @index putStrLn
14:38:53 <lambdabot> System.IO, Prelude
14:39:17 <monoidal> sizzler, it's like type MaybeIO a = Maybe (IO a)
14:39:49 <triyo> I built 6.12.3 from source on my Mac (x86_64, finally!!!!). I have an older version installed, 6.10.4, how do I install my new version without messing up the previous version? Do I just do normal install from my new fresh .pkg file?
14:39:53 <monoidal> sizzler: it's a synonym for composition of two type constructors
14:39:53 <medfly> sinelaw, I imagine this is a normal reaction to the exam period
14:40:12 <sinelaw> medfly, oh yes
14:40:17 <sinelaw> i have my last exam in a few weeks
14:40:19 <sinelaw> LAST
14:40:23 <medfly> wow, grats
14:40:25 <Rikardo> @index  initialDisplayMode
14:40:25 <lambdabot> Graphics.UI.GLUT.Initialization, Graphics.UI.GLUT
14:40:34 <medfly> how'd you call it, avirat sof course? :)
14:40:37 <monoidal> sizzler: so everytime you write ImpBounds t, it is converted to Improving (AddBounds t)
14:40:47 <sinelaw> medfly, yeah. unfortunately it's the worst, hardest, most insane exam ever
14:40:56 <sinelaw> by coincidence this course is really insane
14:41:04 <medfly> what is it about?
14:41:13 <sinelaw> statistical signal processing
14:41:17 <medfly> :o
14:41:18 <dons> fxr: cool. so 4x faster with the cache?
14:41:19 <hpc> eek
14:41:24 <sinelaw> medfly, #haskell-blah
14:41:50 <dons> mean: 1.073556 us -> mean: 264.6429 ns
14:41:53 <dons> science yes
14:42:10 <sizzler> monoidal, lets say I have a i1 = Imp {exact=1,compareI=orderme}
14:42:15 <sizzler> and ibound = MaxBound
14:42:31 <sizzler> how do I represnt this ImpBounds t
14:43:01 <sizzler> i1 is Improving and ibound is AddBounds type
14:43:22 <triyo_> or even better question, what is a recommended whey to install multiple ghc's coexist on a same machine?
14:43:41 <kmc> sizzler, you'll have to read the docs for Improving
14:43:42 <monoidal> you need Imp { exact :: AddBounds a, compareI :: AddBounds a -> Ordering } for some a
14:44:25 <dons> fxr: this is really nice.
14:44:33 <monoidal> sizzler, for example, Imp { exact = NoBound 1, compareI = f } where f MinBound = True; f x = orderme x; f MaxBound = False
14:44:46 <monoidal> i might have messed up True with False here
14:45:27 <Rikardo> @index  initialDisplayMode
14:45:27 <lambdabot> Graphics.UI.GLUT.Initialization, Graphics.UI.GLUT
14:45:52 <Rikardo> ?
14:46:12 <Rikardo> @index ?
14:46:13 <lambdabot> bzzt
14:46:13 <dons> earthy: so bytestring-trie is pretty fast eh?
14:46:22 <dons> anyone benchmarked against e.g. Data.Map ??
14:47:04 <sizzler> ooh as "data Improving a", all it says is "a" should be "AddBounds t" ?
14:47:10 <monoidal> yes
14:47:38 <sizzler> got it, thanks monoidal, :)
14:47:46 <jmcarthur> i've started benchmarking it, but i got distracted and never finished it. i don't think i have that project on my hard drive now
14:47:57 <sizzler> I keep tripping up parens a lot
14:48:00 * dons puts it in his july hacking wish list
14:48:22 <sizzler> it seems to mean so many diff things
14:48:40 <Rikardo> @index clear
14:48:40 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.Html
14:48:43 <jmcarthur> benchmarking bytestring-trie against data.map might be a bit more subtle than it at first seems, too. it could vary a lot depending on the nature of the test data
14:49:03 <sizzler> by the way how do you read "Improving (AddBounds t)" .. Improving "of" AddBounds t?
14:49:07 <jmcarthur> i expect the trie would do much better of a lot of the keys share common prefixes, but maybe not necessarily so if they don't
14:49:13 <dons> jmcarthur: benchmarking is hard :-)
14:49:14 <sizzler> or "on"
14:49:14 <jmcarthur> s/of/if/
14:50:21 <jmcarthur> dons: benchmarking is easy. intepreting it is hard
14:50:36 <dons> well, designing suitable test data is hard.
14:50:42 <jmcarthur> it usually not a simple matter of "A is faster than B"
14:51:07 <jmcarthur> yeah, if you are seeking to benchmark under very specific conditions you have to define what those conditions are
14:51:10 <kmc> the meaning of parens in types is the same as in expressions
14:51:15 <dons> well, each function, each style of test data
14:51:24 <Rikardo> @index ColorBuffer
14:51:24 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
14:51:49 <jmcarthur> usually even each style of test data will also have characteristics you didn't mean to introduce
14:51:53 <kmc> sizzler, you can think of type constructors as "functions" from types to types
14:52:01 <kmc> so like Maybe takes a type T and builds a new type (Maybe T)
14:52:16 <kmc> and we use juxtaposition as syntax for application, just as with expressions
14:52:32 <kmc> and likewise we use parens for grouping
14:53:07 <Rikardo> @index DepthBuffer
14:53:07 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
14:54:20 <sizzler> kmc, well when looking at ( a-> a) and Improving (AddBounds t) they both look like they should be represented differently. I am thinking about "type constructors as "functions" from types to types"
14:54:29 <Rikardo> @index DoubleBuffered
14:54:29 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.UI.GLUT.Initialization, Graphics.UI.GLUT
14:55:01 <kmc> i don't mean that type constructors are like the types of functions
14:55:09 <kmc> i mean that type constructors are like "functions" themselves
14:55:23 <kmc> Maybe takes a type and returns another type
14:55:27 <kmc> Either takes two types and returns a type
14:55:34 <monoidal> Improving (AddBounds t) is like sin (cos x)
14:55:51 <kmc> @kind ErrorT
14:55:52 <lambdabot> * -> (* -> *) -> * -> *
14:56:03 <kmc> ErrorT takes a type, and a function from types to types, and another type, and returns a type
14:56:09 <kmc> just like a -> (a -> a) -> a -> a
14:56:18 <kmc> kinds are the "types" for  type constructors
14:56:26 <Rikardo> @index Smooth 
14:56:27 <lambdabot> bzzt
14:56:34 <kmc> Rikardo, btw, you can /msg lambdabot
14:56:37 <kmc> for a private window
14:56:54 <Rikardo> @kmc yes ... sorry 
14:56:54 <lambdabot> Maybe you meant: ghc rc src
14:57:03 <kmc> i don't mind, just mentioning it
14:57:07 <kmc> also IRC is not Twitter ;)
14:57:33 <monoidal> sizzler, all "ready" types like Int, Char have kind *. Things that change a type to a type have kind * -> *, for example Maybe: given some type (Int) you get another type (Maybe Int)
14:57:41 <kmc> @kind Maybe
14:57:41 <lambdabot> * -> *
14:57:52 <kmc> * means "types that actually have values"
14:58:04 <kmc> versus being "functions" still waiting for args
14:58:15 <kmc> there are no values of type Maybe, only things like (Maybe Char) and (Maybe (Maybe Int))
14:59:03 <monoidal> type constructors can be partially defined. for example, type T a = Either Int a is the same as type T = Either Int.
14:59:23 <kmc> bbl
14:59:28 <sizzler> kmc,monoidal I am reading up slowly all you said. I havent yet read about Kinds. I jumped in after reading few bits. Reading now.
15:01:04 <monoidal> Either has kind * -> (* -> *), which means: given a type A, it returns a type constructor T that given a type B returns a type. For example, (Either Int) Char, also written as Either Int Char
15:29:04 <FunctorSalad> (partially applied)
15:29:28 <FunctorSalad> nvm, you actually meant defined, but that works just for synonyms :)
15:30:49 <FunctorSalad> (as I understand it, syns don't count as constructors)
15:31:08 <FunctorSalad> but that's all besides the point, sorry for being nitpicky
15:33:59 * fxr eats food
15:34:26 * johnw drinks coffee
15:35:05 <shajen> can i write somethink like this map (\x if x >0 then something else something) [1,2,3] ?
15:35:50 <monoidal> > map (\x -> if x > 0 then x - 2 else x + 5) [1,2,3]
15:35:52 <lambdabot>   [-1,0,1]
15:36:02 <monoidal> > map (\x -> if x > 0 then x - 2 else x + 5) [-1,2,3]
15:36:03 <lambdabot>   [4,0,1]
15:36:20 <shajen> ok, i dont know why but my ghci dont accept it
15:36:30 <napping> Did you leave out the ->
15:36:36 <monoidal> or \
15:36:43 <shajen> aaa  ok i try
15:42:38 <cjay> > ( . )( . )  (++)  "drugs" (\yeah -> ", give them to me") "baby"
15:42:40 <lambdabot>   "drugs, give them to me"
15:42:44 <cjay> :P
15:43:03 <ClaudiusMaximus> > 1024 - sqrt (768^2 - 512^2)
15:43:04 <lambdabot>   451.5665977600538
15:45:35 <Tomsik_> > let x = x in xx
15:45:36 <lambdabot>   Not in scope: `xx'
15:45:40 <Tomsik_> :(
15:45:45 <Tomsik_> > let x = x in x x
15:45:49 <lambdabot>   mueval-core: Time limit exceeded
15:46:54 <dafis> :t \x -> x x
15:46:55 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:46:55 <lambdabot>     Probable cause: `x' is applied to too many arguments
15:46:55 <lambdabot>     In the expression: x x
15:47:27 <monoidal> > data T = T (T -> T)
15:47:28 <lambdabot>   <no location info>: parse error on input `data'
15:47:36 <Tomsik_> dafis: haskell by default has some typing restrictions when it comes to lambda expressions
15:47:46 <dafis> I know
15:47:54 <monoidal> you can do \x -> x x using a wrapper
15:48:10 * hackagebot zeromq-haskell 0.3 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.3 (ToralfWittner)
15:50:39 <dafis> :t \(x :: forall a. a -> a) -> x x
15:50:40 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
15:50:44 <dafis> yup
15:54:11 <hpc> that lambda looks like a typechecking version of fix fix
15:54:31 <hpc> sort of
15:55:13 <dafis> I thought rather of id id
15:55:23 <dafis> but fix fix is way cooler
16:00:41 <benmachine> isn't it fix id?
16:00:41 <benmachine> ish
16:02:47 <mreh> bah, nothing built with the openGL binding seems to work
16:03:58 <hpc> mreh: windows or linux? windows only works with some crazy-ass hack from what i can tell
16:04:04 <mreh> leenux
16:04:07 <hpc> ah
16:05:20 <hpc> for windows, i have been considering an attempt to write a directX binding, but that would probably not go well
16:05:53 <mreh> so openGL games won't work on the biggest gaming platform!
16:06:31 <hpc> when coded in the mainstream language least-used for graphics too, no less!
16:06:45 <hpc> (actually, PHP probably holds that spot)
16:07:11 <dafis> hpc: PHP is mainstream?
16:07:22 <mreh> we have the biggest graphics library repo in the wurld!
16:07:28 <mreh> 200+
16:07:45 <hpc> oh right, graphing libraries
16:08:08 <mreh> fieldtrip examples nor do plain openGL apps work
16:08:11 <mreh> this sucks
16:08:19 <mreh> ideas?
16:08:43 <p_l> dafis: unfortunately it would count as one...
16:08:51 <p_l> though I suspect COBOL does less graphics
16:09:01 <hpc> what's the error you get?
16:09:11 <mreh> hpc: no errors, just a black window
16:09:12 <hpc> it can't link to the .so?
16:09:14 <hpc> oh
16:13:55 <XniX23> BONUS have you ever written material in slovenian language?
16:15:44 <jmillikin> Is there any way to make Cabal always use CPPHS for .cpphs files, even when compiling with GHC? I need to build with the --hashes option, which GHC's CPP does not support
16:18:26 <gwern> 'A powerful result in cache-oblivious algorithm design is that if an algorithm is efficient on two levels of cache, then it's efficient on any number of levels. Thus the study of cache-obliviousness can be simplified to two-level memory hierarchy, say the CPU cache and main memory, where the accesses to cache are instant but are orders of magnitude slower to main memory. Therefore the main question cache-oblivious algorithm analysis tries to address is ...
16:18:32 <gwern> ... how many memory transfers (MTs) does a problem of size N take. The notation used for this is MT(N). For an algorithm to be efficient, the number of memory transfers should be as small as possible.'
16:18:36 <gwern> interesting. I wonder how one proves that n-levels = 2-levels
16:24:11 <p_l> gwern: I suspect there is the difference between how big the delay difference is between various levels...
16:26:00 <napping> assuming optimal replacement probably helps
16:31:36 <napping> Oh, that's optimality with two levels of cache in front of the arbitrarily large main memory
16:32:20 <napping> so it *is* obvious after all
16:32:55 <p_l> taking into account that most modern multicore chips have 5 levels...
16:33:30 <p_l> (and that's just cache+core, no I/O to external storage)
16:38:06 <lowasser> What is the relationship between -qw and -qm?  They sound sort of contradictory.
16:44:13 <patch-tag> hey I would like a beginners example of a minilanguage (dsl) with let clauses. I will (might) be using to allow power users of a big hunk of data to write their own filters / sorts etc to power various charts
16:45:24 <patch-tag> any suggestions? I was thinking of using monad transformers step by step (which implements a calculator iirc) but I was also looking through various oleg papers... enh... where's the simplest place to start? :)
16:46:19 <edwardk> heya patch-tag
16:46:40 <edwardk> my usual approach to embed a DSL with sharing is to steal the kansas lava trick
16:46:43 <patch-tag> an example: \v -> let fear = fear_nt_a5 v; totwalwords = totw v; fear * 2 > totwords
16:47:06 <napping> Getting lets sounds like a problem of designing the language so you can use the haskell let. Any deep embedding will have too messy a syntax
16:47:28 <edwardk> patch-tag: funny i should run into you hear. i was just uploading a bunch of misc repositories to patch-tag ;)
16:47:32 <edwardk> er here
16:47:48 <patch-tag> small world :)
16:48:09 <patch-tag> I have enjoyed your blog often!
16:48:30 <edwardk> patch-tag: is there any hope of getting patch-tag to, say, autogenerate haddock like hackage?
16:48:38 <patch-tag> napping: sounds good but is it possible? 
16:48:55 <edwardk> patch-tag: that is the kansas lava sharing trick
16:48:58 <patch-tag> I would like to have a config file with "program snippets" like what I pasted above.
16:49:09 <patch-tag> all right I'll check it out
16:49:17 <patch-tag> so you and napping are talking about the same thing
16:49:19 <edwardk> patch-tag: take a look at my ad library, which recovers the sharing info from the tree
16:49:23 <FunctorSalad> . o O (sentient website?)
16:49:31 <napping> where is the lava trick?
16:50:10 <edwardk> patch-tag: http://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty/Numeric/AD/Internal/Reverse.hs check out the code for 'partials' which does the deep magic of using data-reify to extract the sharing information from what otherwise looks like a tree and turn it into a graph.
16:50:56 <patch-tag> napping: any examples (links) of what you were talking about?
16:51:06 <edwardk> patch-tag: i've done the same thing with parsers, edsls for sat solving, etc.
16:51:53 <napping> patch-tag: I'm not sure why your code wouldn't work. It gets tricky if you need to reify the structure and generate SQL or something
16:52:02 <edwardk> when writing an EDSL you can regain sharing one of three ways, you can observe the sharing in the source language using stablename trickery, you can recover sharing by recognizing common subexpressions, or you can require the end user to explicitly use some non-idiomatic style like use a monad for describing environment bindings
16:52:17 <edwardk> the latter two are the most common
16:53:10 <patch-tag> which does kansas lava / your latest link do?
16:53:26 <edwardk> http://portal.acm.org/citation.cfm?id=1596638.1596653 is the paper by gill
16:53:30 <edwardk> the first
16:53:51 <edwardk> i observe the sharing in the underlying expressions
16:54:36 <patch-tag> I kind of like the idea of using a monad, if I can give the power user do sugar
16:54:48 <edwardk> data-reify makes it fairly painless to do. the code to support extracting sharing in the link i gave above consists of the mutual definition of Reverse and Tape and the definition for MuRef
16:55:20 <edwardk> i do both. i use a monad to provide things that change the context, and the sharing to provide natural sugar for things so you can use the operators you know and love
16:55:35 <edwardk> otherwise you wind up down in liftM2 (+) foo bar -- territory pretty fast
16:56:51 <edwardk> my sat solver uses the combination to let me say things like. foo = solve (do x <- exists; forall $ \y -> (x && y) ==> z == (x && z) ==> y)
16:56:58 <patch-tag> well that link is a bit opaque to me. say I import Numeric.Ad. what simple thing can I type into ghci to understand wtf this is doing?
16:57:11 <edwardk> i use the monad for the statements like 'exists' and 'forall' and the sharing for texpressions like the boolean clause there
16:57:14 <patch-tag> or what module has test code / examples ....
16:57:28 <edwardk> diff' sin 1
16:57:29 <patch-tag> oh what you just wrote?
16:57:40 <edwardk> nah that is for another project ;)
16:57:45 <edwardk> just examples of sharing
16:58:08 <patch-tag> checking it out.....
16:58:53 <edwardk> 'diffs sin 1' gives you the tower of derivatives of the sin function for instance
17:00:15 <edwardk> > grad (\[x,y] -> x*y*y) [1,3] -- give you back the partial derivatives with respect to x and y
17:00:16 <lambdabot>   Not in scope: `grad'
17:00:55 <edwardk> if you install simple-reflect and :m + Debug.SimpleReflect
17:01:15 <edwardk> then you can say 'diff sin x' and get back 'cos x * 1' directly for symbolic (unsimplified) derivatives
17:01:46 <patch-tag> hmm, this might actually be useful in day job (financial context)
17:02:17 <edwardk> the computation of grad is particular sneaky. it computes the answer, and then builds up the tree of partial derivatives that contributed to the answer
17:02:25 <edwardk> then it transforms that into a graph using stable names
17:02:35 <edwardk> and walks the graph backwards with sharing intact
17:02:38 <patch-tag> what exactly is a stable name?
17:02:47 <patch-tag> is it described in some paper or...
17:02:48 <edwardk> to figure out what the contribution of each of the inputs are to the output
17:02:51 <edwardk> they are
17:03:12 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.htm
17:03:21 <edwardk> they come from a paper from 99 by conal and the simons
17:04:16 <edwardk> a stablename is like a 'stableptr' you get it by asking for one to be assigned to a thunk in haskell. if you ever ask for one for the same thunk you get the same stablename, if you ever get back the same name, you know you had the same thunk
17:04:30 <edwardk> they can be hashed, but are not an instance of Ord
17:05:25 <edwardk> patch-tag: as for practical use in a financial context, there are a number of such uses for AD.
17:08:26 <patch-tag> edwardk, you have in comment: For reverse mode AD we use 'System.Mem.StableName.StableName'    is that no longer true? didn't turn up on my grep
17:08:36 <Saizan> edwardk: what's the type of x in "foo = solve (do x <- exists; ..)"?
17:08:53 <edwardk> patch-tag it is true, but not direct. thd data-reify code takes care of it for me
17:09:02 <edwardk> Saizan: "Bit b"
17:09:13 <edwardk> the monad is "SAT b"
17:09:30 <edwardk> to keep you from grabbing bits from the wrong sat problem and using them in the wrong context.
17:10:11 <edwardk> the result is a 'Solution b', and you can use decode :: to take a Bit b -> Solution b -> Bool -- or decide :: Bit b -> Solution b -> Bool
17:10:40 <edwardk> decode and decide are both members of the Encoding class (which has an instance for Bit b) with type Decoded (Bit b) = Bool
17:11:48 <edwardk> so effectively the bits that you return from your monad are the sat variables you care to observe, and they can encode fairly arbitrary haskell data types
17:11:59 <edwardk> i need to finish packaging that up actually
17:12:18 <Saizan> edwardk: and how the StableName's get involved?
17:12:55 <Saizan> to implement the reference behaviour of the "Bit b"s without actually using references?
17:13:41 <edwardk> Saizan: because the Bits themselves just record how you put them together, there may be loops in their usage pattern, i use the stablenames to extract what that graph shape is, compile it down to CNF, and add it to the current problem being tracked by the monad
17:14:41 <Saizan> edwardk: sorry, got disconnected
17:15:42 <edwardk> saizan: np, 8:13:12 PM) edwardk: Saizan: because the Bits themselves just record how you put them together, there may be loops in their usage pattern, i use the stablenames to extract what that graph shape is, compile it down to CNF, and add it to the current problem being tracked by the monad
17:16:48 <edwardk> it matters for things like AD, because otherwise the moment someone said something like x^1024 you'd be done if you were just using it like a tree.
17:17:04 <patch-tag> does the ad stuff involve constraint satisfaction, or vice versa?
17:17:10 <edwardk> (that gets expanded out into ~10 multiplications involving shared terms
17:18:22 <edwardk> the ad stuff is quite simple. for each function track its partials, and use them in one of several ways to try and compute whatever shape of derivatives you need efficiently. some times that best way is to just calculate as you go, some times it is to wait until you get the answer and recover sharing by walking backwards
17:20:14 <Saizan> edwardk: at least in the SAT case it's not clear to me that you get an advantage in API vs. just having each Bit b be an STRef b Bool, or even just an Int and carrying an IntMap, though i can see why piggybacking on GHC's graph bookeeping might be more pleasant in the backend
17:20:23 <edwardk> patch-tag: http://www.pvv.ntnu.no/~berland/resources/autodiff-triallecture.pdf is a pretty good set of slides about AD
17:20:59 <edwardk> Saizan: i have one bit of IO at the end, plus the ST s version requires me to use a hellish monadic API or a bunch of unsafePerformST's
17:22:11 <edwardk> i suppose an illustration is in order. the repository here is horribly broken, but this page describes roughly the difference in feel between my approach and the monadic one:
17:22:12 <edwardk> http://patch-tag.com/r/ekmett/ersatz/wiki/
17:22:25 <edwardk> compare the code for the full adder above with the code below.
17:22:44 <edwardk> every remotely interesting action in satchmo has to be monadic
17:22:54 <edwardk> and i didn't even include the crazy code behind fun2, etc.
17:23:17 <edwardk> whereas the observable sharing piece doesn't even involve the monad until you assert the result.
17:24:04 <edwardk> patch-tag: feature request #2, the gitit wiki looks well, pretty gosh darn awful with the patch-tag css
17:24:32 <edwardk> i can't reflow the text there to try to get space between paragraphs, to be able to have any breathing room between the code and surrounding text, etc.
17:25:00 <edwardk> i was hoping to make serious use of it, but i'll admit the inability to style it, and the eyebleeding terror of what was produced out of the box stopped me cold.
17:25:47 <edwardk> Saizan: this lets me be much more declarative about the use of bits in code.
17:25:51 * hackagebot compact-string-fix 0.3.1 - Same as compact-string except with a small fix so it builds on ghc-6.12  http://hackage.haskell.org/package/compact-string-fix-0.3.1 (TonyHannan)
17:25:54 <edwardk> Saizan: otherwise the monad infects everything
17:27:05 <edwardk> (and using the Boolean class, it also lets me test outside of the monad, so i can validate the properties of my nice little composable functions in isolation)
17:27:29 <Saizan> edwardk: yeah, i wasn't thinking of sufficiently complicated "applicative" expressions to see the benefit :)
17:27:55 <edwardk> in the real world think of a few hundred lines of them =)
17:28:31 <edwardk> i have embeddings for bitvectors, adders, multipliers, etc. it was all pretty horrible to consider working in the style of satchmo through all of that
17:28:55 <edwardk> that and i wanted something that was clearly distinct, since i was avoiding the use of satchmo due to license concerns
17:29:01 <Saizan> everytime you want to share a result between among different expressions you've to go via >>= with satchmo
17:29:08 <edwardk> *nods*
17:29:27 <edwardk> whereas in ersatz you just let or where, or call a function with or...
17:29:58 <edwardk> now, nirav presented a very sexy smt solver at boston haskell the other day
17:30:06 <edwardk> i need to kick him into putting up slides somewhere
17:30:07 <Saizan> oooh
17:30:20 <Saizan> in pure haskell?
17:30:46 <edwardk> he calls out to external smt solvers, but does dome pretty nice simplifications on it (that ersatz can't do) while haskell side
17:31:01 <edwardk> and he uses template haskell to generate his "applicative stew"
17:31:43 <edwardk> but whereas i can only see the actions of having applied functions, he can see the use of a function and regain sharing that way
17:32:21 <edwardk> i have no idea you called a function 'f' with some argument, just how it connected the bits inside
17:32:36 <edwardk> whereas he can observe that
17:33:44 <Saizan> does he get more sharing that way or just more efficiently?
17:34:16 <edwardk> more sharing, he can do some higher order simplifications that i just can't see from the perspective of the individual bits
17:34:40 <edwardk> otoh, my code is prettier ;)
17:34:42 <patch-tag> edwardk: i bugzed your request http://patch-tag.com/r/tphyahoo/patchtag-public-bugs/wiki/bug/improve+gitit+wiki+formatting
17:34:50 <Saizan> heh
17:34:51 <edwardk> patch-tag: you rock =)
17:34:52 <patch-tag> was there a feature request number 1?
17:35:05 <edwardk> patch-tag: trying to remember
17:35:28 <patch-tag> do you know if this requires improving gitit, or gitit would be ok but it's the patch tag css?
17:36:13 <patch-tag> Also if you are a latex user you might try leveraging gitit's latex support. Haven't actually tried this myself 
17:36:20 <edwardk> (7:48:02 PM) edwardk: patch-tag: is there any hope of getting patch-tag to, say, autogenerate haddock like hackage?
17:36:23 <chrisdone> aw, yeah
17:36:23 <chrisdone> just solved a bug in a stateful program by separating the pure code from the stateful code. no printfs required. alright?
17:36:38 <chrisdone> >_^
17:37:06 <edwardk> patch-tag: the thing that keeps me from moving everything over is that on comonad.com i can hold onto my haddocks, etc. for unreleased code which makes it easier to reference them in discussions on irc
17:37:10 <patch-tag> It should be possible. I actually generate the haddock and served it as raw html on occasion
17:37:13 <patch-tag> but it's not auto
17:37:34 <edwardk> i'd be fine with clicking something or calling a web service or whatever
17:38:07 <patch-tag> http://patch-tag.com/r/tphyahoo/happstack-dev-doc/snapshot/current/content/raw/happstack-server/doc-index.html
17:38:08 <edwardk> but it'd give a venue for talking about code with someone who isn't invested in it enough to start pulling repos
17:38:23 <patch-tag> it's a bit ugly to get to, not automated... 
17:38:24 <edwardk> patch-tag: exactly =)
17:38:38 <patch-tag> well I'm putting in a feature request anyways :)
17:38:59 <patch-tag> Actually I remember what I thought
17:39:22 <edwardk> i'm trying hard to fight the pull of gitit ;)
17:39:25 <patch-tag> It should be easy to run hackage, and power users should be able to spin up their own hackage servers for their own stuff (public or private)
17:39:48 <patch-tag> I mean, why is there ec2 / virtualbox image for running hackage?
17:39:54 <edwardk> the problem is that i'm using this explicitly to avoid having to keep up comonad.com beyond my wordpress
17:40:21 <patch-tag> So the question I got bogged down in is do I want patch tag to be an alternate hackage
17:40:29 <patch-tag> kind of thing
17:40:36 <edwardk> *nods*
17:40:55 <patch-tag> I think just generating haddock might be a reasonable compromise
17:41:09 <edwardk> well, i don't mean to cause you an existential crisis, but its the one thing keeping me from migrating, say, category-extras
17:41:22 <patch-tag> ha ha, don't worry :)
17:41:31 <kmc> chrisdone, devil's advocate says you solved a bug by extensive refactoring instead of a straightforward search
17:42:11 <edwardk> but if you're generating haddock make sure to --hyperlink-source ;)
17:42:32 <patch-tag> What I was going to say is that it would be really useful to be able to just clone hackage and compile all public packages. For instance, if you have a ghc extension you want to test out if it breaks existing code. (Matt Brown mentioned this use case to me the other day)
17:42:50 <patch-tag> Anyway suffice to say I'm watching GSOC hackage work closely :)
17:42:59 <edwardk> yeah
17:43:10 <patch-tag> indeed.
17:43:12 <Kaidelong> A.B.p.C.D.E.q <- this would be q composed on p?
17:43:19 <chrisdone> kmc: well technically i just moved one big expression into a separate top-level function declaration, which is where it should've been in the first place, and checked it in ghci providing my own state
17:43:21 <edwardk> i'm following closely, if only because i'm mentoring that project this year ;)
17:43:28 <patch-tag> nice!
17:43:34 <chrisdone> kmc: not sure what "a straightforward search" is
17:43:54 <edwardk> Kaidelong: if A.B is a module and C.D.E is, then likely, yes.
17:44:08 <Kaidelong> edwardk: seems like a wart
17:44:25 <edwardk> Kaidelong: well, i'm not sure if the compiler is smart enough to break that apart
17:44:36 <Saizan> > [Nothing..]
17:44:37 <lambdabot>   <no location info>: parse error on input `]'
17:44:39 <Saizan> > [Nothing ..]
17:44:39 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe a))
17:44:40 <lambdabot>    arising from a use ...
17:44:56 <Saizan> ehm, wrong type.
17:44:58 <edwardk> Kaidelong: but yes, the retrofitting of . for qualified namespaces while it is already in use for other things is a bit of a wart
17:45:13 <chrisdone> > [Nothing .. ] :: [Maybe Int] -- hrm?
17:45:13 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Types.Int))
17:45:14 <lambdabot>    arising...
17:45:14 <edwardk> but less so than all the syntactic choices that remained for module namespace separators ;)
17:45:40 <Saizan> > [False ..] -- more like this, chrisdone 
17:45:41 <lambdabot>   [False,True]
17:45:45 <hpc> [Just 1 ..]
17:45:48 <Kaidelong> edwardk: seems like . is the wrong choice for composition and the F# choice of << made more sense, but they had the benefit of hindsight from haskell already having chosen .
17:45:52 <hpc> > [Just 1 ..]
17:45:52 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe t))
17:45:53 <lambdabot>    arising from a use ...
17:46:39 <edwardk> Kaidelong: i'm very fond of . for composition. it is unobtrusive and has done a lot to shape the _thinking_ about programs in terms of composition in haskell
17:46:56 <edwardk> but there is a shortage of symbols on the keyboard
17:47:02 <chrisdone> [Nothing,Just 1,Just 2,Just 3...
17:47:15 <Kaidelong> edwardk: but is p << q << r <| s so much worse than p . q . r $ s?
17:47:35 <edwardk> Kaidelong: yes. it jumps out at you . is only slightly louder than a space.
17:48:01 * hpc prefers applicative
17:48:02 <edwardk> also unlike f#, because of laziness we _can often elide the <| s.
17:48:13 <Kaidelong> hmm?
17:48:18 <Saizan> alsk
17:48:19 <Kaidelong> I use $ a lot when writing haskell
17:48:33 <edwardk> i use $ a lot as a placeholder while i refactor it away ;)
17:48:51 <Kaidelong> I'm not sure where laziness allows you to use no $ where you otherwise would have to
17:49:04 <hpc> :t (<|)
17:49:05 <lambdabot> Not in scope: `<|'
17:49:14 <Kaidelong> hpc: F#'s version of $
17:49:22 <chrisdone> i use $ pretty much for separating lambda abstractions and do notation
17:49:22 <hpc> ah, blech
17:49:43 <chrisdone> modify $ \s -> .. and modifyMVar $ \...
17:49:52 <BMeph> "." seems the most-compatible ASCII glyph to " " (function application).
17:50:00 <chrisdone> dosomething $ do ..
17:50:19 <Kaidelong> BMeph: I think in the end the problem is that we're still using ASCII and keyboards designed to work with it
17:50:25 <Saizan> chrisdone: and that's somewhat a wart in the grammar, there's already a keyword there
17:50:57 <edwardk> in haskell you can effectively always eta-reduce. however, due to strictness, it is not always safe to eta-reduce in F# or ML or the equivalent. so you sometimes wind up having to keep hold of a lambda just to defer calculation
17:51:26 <edwardk> this leads to uglier DSLs and has for the most part foisted the pipeline model on F#
17:51:49 <Kaidelong> edwardk: I actually use "pipelines" in haskell a lot too. Is that a bad thing?
17:52:08 <Kaidelong> I often write things in the form a . b . c . d $ e
17:52:18 <patch-tag> edwardk, here's the haddock feature req http://patch-tag.com/r/tphyahoo/patchtag-public-bugs/wiki/feature/haddock+generation
17:52:22 <Kaidelong> or without the last part
17:52:34 <Kaidelong> if it's just one input parameter
17:52:35 <hpc> i usually write them as a . b . c $ de
17:52:49 <hpc> er, s/de/d e/
17:52:55 <edwardk> patch-tag: rock!
17:53:17 <edwardk> Kaidelong: thats not a bad thing
17:54:09 <jmcarthur> Kaidelong: that's a good thing, IMO :)
17:54:22 <BMeph> Kaidelong: I don't find ASCII a "problem". Of course, I'm from the US, so take that as a caveat... ;)
17:54:41 <Saizan> i guess the needless "$ e" is the not so good thing
17:54:53 <jmcarthur> i also try not to use ($) when i don't have to
17:54:53 <Kaidelong> well it may not be needless if you define it with a where or let
17:59:03 <edwardk> Kaidelong: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf chapter 11.1.1 on the right hand side, where it talks about parser combinators and recursive definitions and the need for manual eta-expansion in strict languages
17:59:10 <edwardk> (p 36)
17:59:21 <edwardk> er 11.1.2
17:59:58 * hackagebot scenegraph 0.1.0.2 - Scene Graph  http://hackage.haskell.org/package/scenegraph-0.1.0.2 (MarkWassell)
18:00:20 <Kaidelong> I remember that paper!
18:00:23 <Kaidelong> I'll read it again
18:01:07 <edwardk> yay my rounding code works
18:01:41 <edwardk> Prelude Numeric.AD Numeric.Rounding> double $ runUp (diff sin 1) ==> 0.5403023058681398,  double $ runDown (diff sin 1) ==> 0.5403023058681397
18:05:16 <BMeph> Is there a way to "automate" making a class along with a type, without using TH?
18:05:28 <edwardk> TH, CPP
18:05:47 <edwardk> maybe one of the deriving packages that works like a preprocessor
18:05:49 <edwardk> but thats about it
18:05:59 <edwardk> (i.e. SHE) but i don;t know much about them
18:06:26 <chrisdone> ouch. subtle bug got me for 15 minutes
18:06:31 <chrisdone> preparedEval (":l" ++ path) vs preparedEval (":l " ++ path)
18:07:29 <BMeph> chrisdone: Ooh, that is a toughie, good job! :)
18:07:43 <chrisdone> i need to make spaces in strings have a different colour background or something ~_~
18:08:23 <Saizan> or you could start using unwords [":l", path ]
18:08:43 <chrisdone> i think that's a good idea
18:08:46 <chrisdone> i'll do that
18:08:59 * BMeph bows before Saizan's prowess
18:09:56 <chrisdone> in before someone submits a patch titled "removed pointless `unwords []' usage for clarity"
18:10:14 <shajen> how can i write a list to consoel with putstrln and foldl?
18:10:17 <BMeph> Correct me if I'm wrong, but lists are the only container type without a specified size (i.e., could potentially be infinite), right?
18:10:46 <edwardk> not the only, the only common one maybe
18:10:47 <chrisdone> BMeph: trees, etc.?
18:10:50 <Saizan> depends on what you mean by container
18:10:54 <illissius-> Hmm, I read that as preparedEvil.
18:11:10 <edwardk> branching streams, random-access-lists, all sorts of things have that property
18:11:14 <Saizan> shajen: foldl doesn't seem a very good candidate for that
18:11:21 <chrisdone> illissius-: evil is always prepared
18:11:30 <shajen> Saizan: ok so what is better?
18:11:39 <edwardk> @type forM_
18:11:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
18:11:46 <shajen> map?
18:11:50 <Saizan> shajen: "mapM_ putStrLn list" maybe? assuming it's a list of strings and you want each of them on a separate line
18:11:51 <edwardk> @type mapM_
18:11:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:11:55 <illissius-> next programming language i learn needs to have an 'evil' function
18:12:07 <chrisdone> BMeph: cool so the haskell json service now supports GHCi-style top-level binding
18:12:09 <illissius-> or maybe that would just be the same thing as eval
18:12:18 * chrisdone records the patch and pushes
18:12:47 <BMeph> edwardk: We are talking about in Haskell, not just in theory....?
18:13:01 <edwardk> BMeph: i use those structures all the time
18:14:05 <BMeph> chrisdone: ?
18:14:26 <edwardk> chrisdone is poorly named, the man will never be done ;)
18:14:27 <BMeph> edwardk: So where are these random-access lists you mentioned? :)
18:14:50 <chrisdone> edwardk: hahaha
18:15:04 <edwardk> BMeph: let me see if i have them lying around in a module somehwere
18:15:06 <chrisdone> BMeph: just reloading it on the server now http://github.com/chrisdone/haskell-json/commit/ee87544698759eadbb90a911b78343bbde8531a6
18:16:39 <BMeph> chrisdone: Are you messing up on tab-completion, perhaps? Not that I'm not interested, I just feel as if you're in the middle of a conversation already... ;)
18:16:53 <EvanR> what does #haskell think of F#
18:17:30 <BMeph> EvanR: A good walk spoiled. No, wait, that's golf... ;)
18:17:56 <hpc> it has all the power of .NET and all the awkwardness of a .NET language :P
18:18:22 <hpc> (the last half was half a joke; C# isn't half bad)
18:18:24 <edwardk> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf page 77 has some usable skew binary list code
18:18:52 <Saizan> (i wonder what answer you'd get on #ocaml)
18:19:37 <EvanR> i dont have enough experience points with #ocaml to tell
18:19:44 <EvanR> or to try
18:21:06 <shajen> it is easy way to combine subtitles?
18:22:54 <dafis> shajen, explain?
18:23:26 <shajen> i want to write on console "string1"+"string2"
18:24:42 <dafis> shajen, there are many good ways, e.g. putStrLn (unlines [string1, string2])
18:24:52 <gwern> dafis: that's nto a good way at all
18:24:53 <aavogt> > "string1"++"string2"
18:24:54 <lambdabot>   "string1string2"
18:26:11 <dafis> gwern: not in this example, but have you general objections to putStrLn . unlines ?
18:26:38 <gwern> dafis: it looks uglier than continued lines
18:27:30 <dafis> gwern: shajen asked about combining subtitles, I think they're meant to be on separate lines
18:27:33 <aavogt> hmm, compared to   mapM_ putStrLn
18:27:59 <kfmfe04> What's the difference between a "type synonym" and defining a new type via the "data" keyword?  In other words, when do you use "type" vs "data"?  Is it equivalent to a C++ typedef vs Class?
18:28:00 <Saizan> dafis: i think gwern is referring to the case where the list is a static value
18:28:33 <Saizan> kfmfe04: type just defines a transparent alias
18:28:33 <kmc> kfmfe04, broadly similar
18:28:42 <kmc> "type" is just a sort of macro on type expressions
18:28:44 <gwern> kfmfe04: 'type' lets you cheat
18:28:52 <hpc> type is #define, sort of
18:28:55 <kmc> "data" creates a new type with constructors, that is distinguished by the type checker from any component(s) it has
18:29:10 <hpc> so you have stuff like type String = [Char]
18:29:11 <kmc> that's why "data" always introduces one or more data constructors and "type" never introduces any
18:29:19 <hpc> which is similar to #define String char*
18:29:23 <kmc> (aside from the EmptyDataDecls extension, which is only used in specialized cases)
18:29:38 <kmc> then there's "newtype", which is best thought of as a variant of "data" rather than "type"
18:30:14 <aavogt> or is it more like type that doesn't let you cheat
18:30:29 <mauke> kfmfe04: yes
18:30:41 <edwardk> @hpaste
18:30:42 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:31:02 <kfmfe04> thx, kmc, hpc, gwern - that gives me a better sense of when to use type and when to use data - will check out newtype later - tyvm
18:31:12 <edwardk> BMeph: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26112#a26112
18:31:18 <gwern> aavogt: I don't think I would call it a 'type that doesn't let you cheat'
18:31:29 <edwardk> O(log n) indexing, O(1) cons/view
18:31:53 <edwardk> BMeph: took me a bit coz i didn't have a working version on this machine ;)
18:32:05 <gwern> aavogt: I mean cheat as in I can replace all my FilePaths with Strings and my a :: FilePath be a :: String; but both data and newtype would force me to add some sort of tag to distinguish between a :: FilePath and a :: String
18:32:29 <edwardk> BMeph: (the code there was half way converted between a list and a snoc-list, and i had to flip it around)
18:32:44 <aavogt> gwern: it being newtype
18:39:01 <edwardk> BMeph: one of the things i like about that structure is that it is lazy, but can provide o(log n) size, as it takes bigger and bigger strides the farther away from the start it gets
18:40:10 <BMeph> edwardk: Hmm, that sounds vaguely how SoE works. Interesting...
18:40:18 <edwardk> SoE?
18:40:22 <BMeph> (as in Sieve of Eratosthenes)
18:40:26 <edwardk> ah
18:41:02 <kfmfe04> how well does Haskell currently interface with C/C++?  I mean in terms of calling in both directions H->C and C->H?
18:41:28 <edwardk> kfmfe04: works fine, we have decent c ffi, but not much in the way of C++ machinery. you need to go through some c intermediary
18:42:16 <kfmfe04> that sounds fine - my intention was to port my C++ code over to Haskell - all extern libs are C libs so this might work - thx
18:46:06 <edwardk> hahahaha ever have that experience of opening a directory full of code, and knowing you wrote it, but having no idea what it was for?
18:46:17 <p_l> kfmfe04: interfacing with C++ from anything other than C++ is usually a chore unless big amounts of manpower are poured into it :D
18:46:42 <p_l> edwardk: sounds like something I would expect from a C++ project ;-)
18:47:14 <p_l> (though Java sometimes leads to that as well... too verbose and too many "factories" and design patterns, thank you very much...)
18:47:56 <edwardk> p_l in this case it was just a solid wall of traversable and functor instances for some very generic code fr dealing with f-branching stream fusion
18:48:06 <edwardk> i ultimately placed it but it took me a good few minutes ;)
18:48:12 <chrisdone> yay. the storm is coming this way. it's like jurrassic park
18:49:49 <kfmfe04> pl_l: funny you mention that - one of the reasons I'm looking into Haskell is to avoid the design pattern craziness - was fine way back in the beginning with GoF, but now with Dependency Injection and all these crazy new patterns, it's kind of a turn-off - run into edwardk's problem of not remembering the details about patterns I used years ago
18:51:10 <p_l> kfmfe04: heh. In the beginning, when I looked at DP "movement", I couldn't see much use outside of Singleton, then to notice that Singleton is the single most stupid pattern there ;-)
18:51:14 <edwardk> kfmfe04: heh it can take me up to a week to fully code-switch back into C++ or Java and be effective again some times.
18:51:58 <p_l> (I mean, we do have global variables and a global namespace, right? We aren't constrained to stack only...)
18:53:18 <p_l> otoh, the only languages I really touched lately were Ruby, Common Lisp and a bit of Erlang and Haskell :)
18:53:45 <kfmfe04> what did you think of Erlang?  I was choosing between Erlang and Haskell...
18:54:00 <p_l> kfmfe04: in my opinion it depends on the project
18:54:11 <Axman6> i miss types in erlang
18:54:20 <kfmfe04> that's what I thought =P
18:54:26 <edwardk> kfmfe04: i like erlang for the places where it has high power to weight ratio. if i need a lot of control over a huge number of tasks, and good out of the box tools for checking to make sure everything is running erlang is awesome
18:54:34 <p_l> If I were writing a messaging server for example, or something that has to be updated in-flight without interruption, I'd go for Erlang - its VM was built from beginning for that.
18:54:52 <p_l> Also as a glue between different systems
18:54:57 <edwardk> otoh, i find it hard to think deep thoughts in erlang since everything is very much first order
18:54:59 <p_l> (though it sounds weird)
18:55:05 <kfmfe04> so for general programming, Haskell should be a better choice?
18:55:14 <edwardk> kfmfe04: yeah
18:55:21 <kfmfe04> great
18:55:30 <p_l> kfmfe04: well, my choice would be (in order) CL, Haskell, Erlang
18:56:03 <kfmfe04> CL has lots of parens, right?  Don't you find Haskell to be more readable than CL?
18:56:48 <p_l> kfmfe04: I don't see any parens ;-)
18:57:04 <kfmfe04> hahaha
18:57:23 <p_l> CL requires an editor that supports the list data structure that happens to be denoted with parens :)
18:57:47 <p_l> compared to issues I had in Pascal, CL is easy :D
18:57:55 <kfmfe04> have you tried Scheme?  How does that compare with CL?
18:58:02 <p_l> (and let's not talk about PHP)
18:58:33 <p_l> kfmfe04: I tried several times with Scheme, but it's very fragmented world IMHO, even with SRFI (which is something that CL lacks)
18:59:18 <p_l> and I found that if I want to code in it, I end up loading stuff that makes it similar to CL anyway :)
19:00:42 <p_l> CL has warts, true, but I found it an enjoyable language. Though it took finding Haskell to learn CLOS xD
19:00:52 <kfmfe04> ic - thx for sharing your exp - love playing around with various languages, but can't find the time...
19:01:35 <gwern> I like the scheme tools though
19:01:43 <gwern> haskell doesn't have as good dev tools
19:01:54 <kfmfe04> ...been trying to move away from C++ - was going to try D at one point, but their bifurcation in standard libraries turned me off...
19:01:57 <chrisdone> scheme???
19:01:58 <gwern> one of the benefits of being interpreter-based
19:02:09 <gwern> chrisdone: sure, you ever try plt scheme? pretty nice debugger
19:02:29 <chrisdone> yeah it's pretty nice
19:02:30 <p_l> gwern: Scheme standard doesn't enforce neither interpreter nor compiler
19:02:38 <gwern> p_l: sure sure whatever
19:03:38 <p_l> gwern: well, the last Scheme I used generated C code that used stack exhaustion as part of GC ^^;
19:04:02 <gwern> haskell doesn't specify compiler or interpreter either yet what do we have?
19:04:20 <dolio> Both.
19:04:52 <gwern> dolio: a ghci in which I can't even define new types?
19:05:05 <p_l> heh. SBCL for a long time had only compiler :)
19:05:20 <dolio> We have compilers called GHC, LHC, JHC, HBC and YHC.
19:05:28 <dolio> Oh, and UHC.
19:05:37 <dolio> And interpreters named Hugs, at least.
19:05:43 <dolio> I think YHC has an interpreter, too.
19:05:50 <gwern> does yhc even compile anymore?
19:06:11 <gwern> and hugs's last release was... 2006?
19:06:23 <gwern> the less said about hbc and lhc the better :)
19:06:25 <dolio> There's NHC, too.
19:06:45 <dolio> The last release of the Haskell standard was 1998.
19:07:05 <p_l> that's not much of an issue, I'd say...
19:07:15 <kmc> what about Haskell 2010?
19:07:35 * p_l had his first contact with FP and Lisp through R2RS... somewhere near 2000
19:07:50 <dons> gwern: don't confuse the REPL with the interpreter.
19:08:05 * gwern does
19:08:18 <chrisdone> gwern: http://tryhaskell.org/
19:08:23 <chrisdone> gwern: try: x = 1
19:08:28 * gwern is cut to the quick
19:08:51 <dons> there's no reason that hbi's repl couldn't run on top of ghci's bytecode interpreter
19:08:58 <dons> ghc-api + new repl 
19:09:03 <kmc> kfmfe04, are you reading Real World Haskell?
19:09:06 <gwern> hbi?
19:09:07 <dons> since the interpreter supports all of haskell
19:09:11 <kmc> kfmfe04, it has a good chapter on FFI, the interface to C code
19:09:24 <dons> hbi is the interpreter provided by the hbc toolset, which let you enter any haskell at the command line
19:09:33 <dons> newtypes, data, instances etc.
19:09:43 <dolio> Anyhow, ML isn't interpreter based as far as I know, but you can define new types in the REPL.
19:09:56 <dolio> Of some implementations, at least.
19:09:56 <gwern> dons: beware the turing tarpit... lisp languages have historically had extremely nice development environments, and have historically be interpreter based or equivalent. I don't think that's an accident
19:09:57 <kmc> ML isn't "interpreter based", because that's a category error
19:10:01 <chrisdone> dons: how does it handle conflicts? does it re-define or error?
19:10:12 <dons> gwern: dynamic extension is easier in an interpreted environment
19:10:19 <p_l> gwern: the "interpreted" part was lost somewhere in 1970
19:10:20 <dons> its nothing to do with turing tarpits.
19:10:32 <dons> and certainly easier in an untyped setting
19:10:38 <p_l> it's just that it's easy to do that with interpreter or bytecode
19:10:51 <dons> hence rich support for debugging, reflection, metaprogramming in interprted, untyped languages.
19:10:52 <p_l> pure interpreters are rare, afaik...
19:10:58 <dons> AST interpreters?
19:11:00 <dons> yes, i hope so.
19:11:09 <p_l> dons: Ruby <1.9
19:11:21 <p_l> (not joking)
19:11:22 <dons> well, some people shouldn't be let near a compiler.
19:11:54 <kfmfe04> kmc: thx for the tip - yes, I've just started reading RWH - will look for the FFI chapter
19:11:59 <dons> ch 18 iirc
19:12:00 <dons> or 16
19:12:01 <dolio> Haskell even had the best debugger ever made (reportedly) at one point, named Buddha.
19:12:04 <dolio> It worked on top of GHC.
19:12:07 <dolio> But it's bit rotted.
19:12:25 <dons> it has several amazing declarative debuggers
19:12:30 <jbapple> It would be a great GSOC
19:12:36 <gwern> dolio: I don't remember being very impressed by buddha when I was looking at it
19:12:47 <gwern> the lisp environments, such as genera, set pretty high bars
19:12:48 <jbapple> dons: What other declarative debuggers?
19:12:51 <dons> http://haskell.org/haskellwiki/Research_papers/Testing_and_correctness#Tracing_and_debugging
19:13:00 <dons> debuggers that remove bugs not by stepping through code
19:13:06 <p_l> dons: there's also issue of exact terminology regarding types - I found that quite often when people start discussing which is better or which language is how typed, different sides use different definitions for the same words :)
19:13:16 <dons> but by e.g. asking you questions about   the code, or moving back and forth in the reductoin graph
19:13:34 <chrisdone> gwern: i was wondering how to handle type/class definition with mueval at the command-line, but it seems pretty hard
19:13:41 <dons> freja, hat, hood, buddha, "algorithmic debugging"
19:13:56 <dons> see "Declarative Debugging for Lazy Functional Languages"
19:13:57 <gwern> chrisdone: the best I can say is to use the load-file functionality
19:14:08 <jbapple> Hood is declarative?
19:14:11 <gwern> chrisdone: I'm not sure the ghc api supports any other approach
19:14:12 <chrisdone> gwern: yeah it sucks for conflicts though
19:14:13 <dons> or http://ww2.cs.mu.oz.au/~bjpop/buddha/
19:14:21 <jbapple> yeah, that's the money
19:14:25 <jbapple> but bitrotted
19:14:31 <dons> buddha "presents the evaluation of a Haskell program as a series of equivalences, rather than the more traditional stepwise presentation of debuggers for imperative languages."
19:14:46 <dons> well, last release 2006. probably revivable. i've used it in the past.
19:14:52 <kfmfe04> p_l: ya - that's what I'm struggling with right now - every new language has its own terminology - some of them are just synonyms for terms in other languages, but other times, you have the same term with different meanings - half the battle of learning is just understanding the terminology correctly
19:14:57 <dons> main issue was source-to-source transformation
19:15:01 <jbapple> It was the best debugger I have ever used
19:15:04 <dons> needs to be ported to haskell-src-exts or ghc-api
19:15:05 <jbapple> I miss it dearly
19:15:08 <dolio> I was looking to see how easy it would be to fix buddha, but it appears to be closely tied to GHC internals.
19:15:19 <ddarius> dons: Yes.  It was Haskell 98 only, but with the newer libraries that should be relatively easily fixable.
19:15:20 * chrisdone keeps forgetting 2006 isn't 2 years ago
19:15:22 <dons> some of it ended up in ghci-debugger
19:15:23 <dolio> So it might be tricky.
19:15:29 <dons> ask bernie. 
19:15:35 <dons> he's active in haskell, so might have his own plans
19:15:57 <edwardk> ok, dumb question, using something like hsc2hs what is the right way to read the value of a double-valued constant that comes from c?
19:16:04 <jbapple> bernie is also the person behind the Python interpreter in Haskell, right?
19:16:11 <ddarius> Yes.
19:16:27 <ddarius> And Baskell.
19:16:43 <dons> edwardk: double-valued ??
19:16:48 <dons> an enum?
19:16:51 <edwardk> dons: as in has a valu that is a double ;)
19:16:56 <dons> oh, peek.
19:17:13 <dons> if its in a ptr. otherwise realToFrac etc
19:17:20 <edwardk> i.e. i have: const double pi_d_l = (3373259426.0 + 273688.0 / (1<<21)) / (1<<30);  const double pi_d_u = (3373259426.0 + 273689.0 / (1<<21)) / (1<<30);
19:17:22 <dons> you want CDouble -> Double ?
19:17:29 <dons> oh, i see.
19:17:35 <dons> take the address?
19:17:43 <edwardk> i accept the fact that CDouble -> Double is just use real2Frac and pray that it gets the rule to fire
19:17:47 <dons> &pid_d_l
19:17:57 <dons> look at  the generated code to be sure.
19:18:13 <dons> i checked for the haskell-math lib. let's see...
19:18:31 <dons> see e.g. http://hackage.haskell.org/packages/archive/cmath/0.3/doc/html/src/Foreign-C-Math-Double.html#acos
19:18:46 <jbapple> For anyone else looking, here's the new Hood page: http://www.ittc.ku.edu/csdl/fpg/Tools/Hood
19:18:46 <edwardk> i'm needing a number of ever so slightly tweaked constants due to the rounding mode stuff i'm using
19:19:09 <jbapple> as far as I know, it is one of only two "debugger" options, the other being GHCi's debugger
19:19:36 <edwardk> dons: nothing there seems to actually import an actual double, just functions that manipulate them
19:20:36 <jbapple> One nice thing about buddha is that it integrated with the idea that there was a bug to find
19:21:03 <jbapple> so, it would present a function call, including arguments and result, and ask if the result was correct
19:21:15 <edwardk> dons: sorry if i'm being obtuse. i don't use ffi very often =/
19:21:49 * p_l is sometimes scared of FFI. It can make you program crazy assembler routines
19:22:02 <jbapple> If you trace this down a tree of function calls, you can locate your bug -- it's in the node with no children that have incorrect results and yet itself returns an incorrect result 
19:22:13 <jbapple> It's like playing 20 questions with your debugger
19:22:24 <jbapple> I think buddha even had "I don't know/ask me later"
19:22:46 <dons> edwardk: oh, i was just saying, realToFrac is *fine*.
19:22:50 <jbapple> It was like magic -- just answer a few yes/no questions and You Receive Enlightenment
19:22:55 <dons> edwardk: so you'll import pi_dl :: CDouble
19:23:27 <edwardk> dons: k. interestingly there doesn't appear to be an FFI sample online that actually ever imports a constant ;)
19:23:33 <kmc> yeah, it sounds like "buddha" is a tool to automate the style of debugging that most haskellers use anyway
19:23:59 <kmc> (and probably makes it a lot less painful, in the presence of things like local let/where bindings)
19:24:08 <jbapple> kmc: exactly! it did all the grunt work for you
19:24:53 <jbapple> Most debuggers you have to be nice to -- stop here, skip this function call, whatever
19:25:05 <jbapple> You could really emotionally abuse buddha
19:25:08 <jbapple> It was resilient
19:25:20 <kmc> it sounds not that hard to re-implement from scratch
19:25:25 <ddarius> There were still "filtering" issues.
19:25:26 <kmc> if the existing codebase is unusable for whatever reason
19:25:33 <gwern> jbapple: well, with a name like 'buddha'...
19:25:56 <jbapple> yeah, it required recompilation
19:26:27 <jbapple> when I'm debugging manually, I end up writing a bunch of let bindings in GHCi
19:26:51 <jbapple> only to lose them all when I :reload to see if my last change fixed the error
19:27:05 <gwern> good thing there's the history
19:27:27 <jbapple> In essence, I copy my functions line by line into ghci
19:27:57 <jbapple> gwern: It's true. If it weren't for history, I'd end up writing a bunch of throw-away code in my modules just for debugging
19:27:58 <edwardk> dons: cool. pi is now anal retentively correct ;)
19:28:02 <gwern> @wn smellfungus
19:28:03 <lambdabot> No match for "smellfungus".
19:28:08 <gwern> wordnet is so useless
19:28:18 <danharaj> When (in a category) does having a left inverse imply monic for a morphism? It is true in Set.
19:28:24 <ddarius> edwardk: pi = [pi-epsilon,pi+epsilon] ?
19:28:36 <ddarius> danharaj: It's always true.
19:28:42 <ddarius> danharaj: Such a case is called a split mono.
19:28:56 <danharaj> ah, but monic does not imply left inverse?
19:28:57 <edwardk> ddarius: pi appropriately rounded for different ieee rounding modes
19:28:58 <ddarius> (and the other side is a split epi)
19:29:01 <ddarius> danharaj: Correct.
19:29:15 <ddarius> danharaj: Monic means "left cancellable"
19:29:23 <ddarius> (for the appropriate "left")
19:29:31 <danharaj> ddarius: so, when does mono => split mono?
19:29:34 * ddarius prefers pre-/post-
19:29:40 <edwardk> ddarius: Numeric.Rounding includes a newtype wrapper that indicates the rounding mode, so i can use it in my Numeric.Interval code, so I can use THAT in my taylor model code. ;)
19:29:53 <jbapple> It looks like Hood relies on you manually mangling your code to debug it, too
19:30:00 <edwardk> ddarius: but to get that right i have to deal with all sorts of fiddly bits of correctness
19:30:02 <ddarius> edwardk: So you can use that in... ?
19:30:12 <edwardk> ddarius: i haven't gotten that far yet ;)
19:30:15 <chrisdone> jbapple: you haven't setup some emacs shortcuts?
19:30:24 <jbapple> chrisdone: for what?
19:30:25 <edwardk> once i understand them better i'll have better answers
19:30:25 <ddarius> danharaj: There is no general rule other than the definition of split mono.
19:30:41 <chrisdone> jbapple: <jbapple> In essence, I copy my functions line by line into ghci
19:30:48 <edwardk> ddarius: but i mostly would like to have a few tools for practical scientific computing in haskell
19:30:51 <danharaj> ddarius: Ah I see, I was hoping there was a "sufficiently similar to Set" sort of condition.
19:31:13 <ddarius> edwardk: Me too.  But I also want to be able to use large grids/etc.
19:31:14 <edwardk> ddarius: and taylor models are a great use of all the crazy higher derivatives i added to ad lately
19:31:16 <jbapple> chrisdone: I don't know that emacs shortcuts would help me. The copying has to munge each line
19:31:28 <ddarius> danharaj: I'm sure there are several different ones.
19:31:39 <edwardk> ddarius: since they give me actual honest to goodness hard error bounds
19:31:58 <jbapple> chrisdone: For instance, debugging "foo $ bar $ baz [1..10]"
19:32:39 <jbapple> chrisdone: especially if baz pattern matches
19:33:39 <danharaj> ddarius: thanks
19:33:55 <chrisdone> jbapple: you could just setup your own shortcut, like :remember
19:34:12 <jbapple> chrisdone: what would that shortcut do?
19:34:13 <chrisdone> jbapple: and then it would automatically insert that line each time you reload in ghci
19:35:03 <jbapple> chrisdone: it's sometimes many lines, and I have to manufacture many useless variable names
19:35:17 <jbapple> chrisdone: nm, I'm just whining
19:35:27 <jbapple> chrisdone: I appreciate the tip, I'll try it
19:35:40 <chrisdone> no you won't :p
19:35:41 <jbapple> I just miss buddha
19:35:53 <ddarius> jbapple: Reincarnate it.
19:36:05 <jbapple> I might try.
19:36:18 <jbapple> Where can I find the docs on writing my own ghci shortcuts?
19:36:28 <ddarius> The User Guide.
19:36:35 <ddarius> It's pretty straightforward.
19:37:10 <ddarius> :def <name> <Haskell code>
19:37:26 <chrisdone> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci.html
19:39:16 <jbapple> It is not clear to me that one can, in fact, write a function that will be called automatically when GHCi reloads a file
19:39:19 <edwardk> hrmm i segfault every time i try to access that double
19:39:32 <danharaj> you segfaulted?
19:39:41 <danharaj> what kind of wizzardry are you performing?
19:40:00 <edwardk> ffi ;)
19:40:09 <danharaj> there be dragons.
19:40:17 <ddarius> jbapple: You can write a command that you can use instead of :reload
19:40:25 <ddarius> You may even be able to shadow :reload.
19:40:39 <edwardk> dons: around? http://patch-tag.com/r/ekmett/rounding/snapshot/current/content/pretty/Numeric/Rounding.hsc contains the code that breaks
19:40:45 <ddarius> Probably a bad idea to do that last though.
19:41:32 * ksf ponders basing his IO library directly on syscalls
19:41:45 <ksf> libc isn't doing much of interest to me, anyway.
19:41:45 <chrisdone> a special buffer might be nice, like *ghci-declarations*, the contents of which is entered when you use emacs to load a file
19:42:09 <jbapple> ddarius: so :reloadBetter could call :reload, then :recall, which would recall something that had been :remembered, which would require some sort of persistent mutable state, right?
19:42:16 <dons> edwardk: hmm. you might need to check the FFI report wrt. accessing constants
19:42:24 <dons> edwardk: possibly you need to import the address and dereference
19:42:50 <ddarius> jbapple: You can do persistent mutable state, though I'm not sure why you mightn't use the file system for it in this case.
19:43:05 <jbapple> chrisdone: You were right, there's no way I'm stepping into this swamp
19:43:08 <dons> e.g. foreign import ccall "&pi_foo" :: Ptr CDouble ; my_pi_foo = unsafePerformIO (peek pi_foo).  -- check your friendly FFI Report.
19:43:26 <edwardk> dons: k. i'll go mine reports
19:44:27 <shajen> now i have a big problem in haskell
19:44:41 <ddarius> jbapple: ref <- newIORef foo\n:def bar <code using foo> is valid I'm pretty sure.  How exactly it interacts with :reload isn't completely clear but I think you finagle what you want.
19:44:55 <shajen> i have list [[1,2,3],[4,5,6],[7,8,9]] and i want to list like this [1,5,9]
19:45:25 <Axman6> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [1,2,3]
19:45:26 <lambdabot>   [2,6,*Exception: Prelude.(!!): index too large
19:45:32 <Axman6> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0,1,2]
19:45:32 <lambdabot>   [1,5,9]
19:45:35 <chrisdone> ddarius: yeah, the file system seems the best approach
19:45:58 <jbapple> Even amortized over easier debugging on several future haskell projects, I don't think I would get back what I put in
19:45:59 <mauke> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0 ..]
19:46:00 <lambdabot>   [1,5,9]
19:46:44 <shajen> and [[1,2,3],[4,5,6],[7,8,9]] ->  [2,6] ?
19:46:58 <dons> shajen: what are you using to determine the index space?
19:47:27 <dons> btw, haskell folks, the vector library is great with these index-based filters. very fast data parallel versions
19:47:28 <edwardk> runDown $ pi ==> 3.141592653589793, runUp $ pi => 3.1415926535897936 --- woot. that worked, thanks dons
19:47:38 <dons> nice
19:47:52 <shajen> i have a size of my square matrix
19:48:13 <edwardk> all that to fiddle with pi
19:48:22 <shajen> and i want all of his diagonal
19:49:12 <Axman6> > let f ((x:_):xss) = x : f (map (drop 1) xss); f ([]:xss) = [] in f [[1,2,3],[4,5,6],[7,8,9]]
19:49:13 <lambdabot>   [1,5,9*Exception: <interactive>:1:177-233: Non-exhaustive patterns in funct...
19:49:26 <Axman6> > let f ((x:_):xss) = x : f (map (drop 1) xss); f ([]:xss) = [] in f [[1,2,3],[4,5,6],[7,8,9]]; f [] = []
19:49:26 <lambdabot>   <no location info>: parse error on input `;'
19:49:39 <Axman6> > let f ((x:_):xss) = x : f (map (drop 1) xss); f ([]:xss) = []; f [] = [] in f [[1,2,3],[4,5,6],[7,8,9]]
19:49:40 <lambdabot>   [1,5,9]
19:49:48 <kfmfe04> I'm a little confused about Single Assignment.  If I can do:  let a = 5 and then later do let a = 9, then how is this different from regular "Multiple" Assignment?
19:49:53 <Axman6> > let f ((x:_):xss) = x : f (map (drop 1) xss); f ([]:xss) = []; f [] = [] in f (map (drop 1) [[1,2,3],[4,5,6],[7,8,9]])
19:49:53 <lambdabot>   [2,6]
19:50:20 <Axman6> kfmfe04: in general you can't do that
19:50:27 <Axman6> > let a = 4; a = 7 in a
19:50:28 <lambdabot>   Conflicting definitions for `a'
19:50:28 <lambdabot>  In the binding group for: a, a
19:50:49 <Axman6> > let a = 4 in let a = 7 in a
19:50:49 <lambdabot>   7
19:50:59 <Axman6> ere the second a shadows the first
19:51:03 <Axman6> here*
19:51:05 <Saizan> kfmfe04: it's shadowing, not mutation
19:51:16 <shajen> Axman6: you are great!
19:51:31 <Axman6> i know
19:51:47 <Saizan> kfmfe04: as a consequence everything that refers to the first a doesn't get updated with the value of the new a
19:52:07 <kfmfe04> ok, if it's really shadowing, can I make the 2nd disappear so the 1st comes back?
19:52:13 <Saizan> kfmfe04: they are completely distinct definitions
19:52:27 <Olathe> kfmfe04: Yeah, end the let block with the second a.
19:52:55 <kfmfe04> Olathe: can you show me an example (I've just started using Haskell yesterday =P )
19:53:04 <Saizan> > let a = 4; b = (a , let a = 7 in a) in (a,b)
19:53:05 <lambdabot>   (4,(4,7))
19:53:18 <Axman6> > {let a = 4 in { let a = 7 in a}}
19:53:18 <lambdabot>   <no location info>: parse error on input `{'
19:53:24 <Axman6> > let a = 4 in { let a = 7 in a}
19:53:25 <lambdabot>   <no location info>: parse error on input `{'
19:53:27 <Axman6> :(
19:53:31 <Olathe> > let a = 4 in (let a = 5 in a) + a
19:53:31 <lambdabot>   9
19:54:07 <kfmfe04> Excellent!  Thx all for explaining!
19:54:18 <Olathe> You're welcome
19:55:04 <Olathe> One thing you can't really do is a = a + 1, I think.
19:55:10 <Olathe> > let a = 4 in (let a = a + 1 in a) + a
19:55:13 <lambdabot>   mueval-core: Time limit exceeded
19:55:18 <kfmfe04> lol
19:55:29 <Olathe> So, that's another difference.
19:55:34 <ddarius> Olathe: You can, it just means something different.
19:55:34 <kfmfe04> ic
19:55:35 <Olathe> The first a totally disappears.
19:55:45 <Axman6> let a = a + 1 in a -> a
19:55:57 <Axman6> let a = a + 1 in a -> a + 1 -> (a + 1) + 1
19:56:01 <Axman6> let a = a + 1 in a -> a + 1 -> (a + 1) + 1 -> ...
19:56:22 <ddarius> > let a = 1 + a in a :: Natural
19:56:23 <lambdabot>   Not in scope: type constructor or class `Natural'
19:56:27 <ddarius> > let a = 1 + a in a :: Nat
19:56:27 <lambdabot>   Not in scope: type constructor or class `Nat'
19:56:36 * ddarius has forgotten the name.
19:56:45 <Axman6> @hoogle NAt
19:56:45 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
19:56:45 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
19:56:45 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
19:56:53 <Axman6> @more
19:56:55 <Olathe> > let a = 1:a in a
19:56:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:58:14 <Axman6> > let a = a++[1] in a
19:58:18 <lambdabot>   mueval-core: Time limit exceeded
19:58:25 <kfmfe04> The more I read about Haskell, the more I'm impressed - it seems that in Haskell, classes, types, and enumerations are all basically the same thing in Haskell!
19:58:29 <Axman6> > let a = [1]++a++[1] in a
19:58:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:58:56 <chrisdone> kfmfe04: in Haskell?
19:59:15 <Axman6> kfmfe04: not really
19:59:20 <Axman6> well, classes aren't
19:59:40 <Axman6> i guess none of them are the same, or we wouldn't have all three :)
19:59:46 <kfmfe04> hmm... ...I haven't gotten far enough yet - are classes what are called monads in Haskell?
19:59:49 <p_l> btw, anyone here noticed cases where leksah crashes X11?
20:00:17 <Axman6> kfmfe04: Monad is a class, classes aren't monads...
20:00:35 <Axman6> well, afaik anyway. they probably are
20:01:01 <Axman6> kfmfe04: classes are somewhat like interfaces in other languages like java. take the Num class:
20:01:04 <kfmfe04> ic - ok - I haven't gotten far enough yet, then - I just saw the definition for a Bool which essentially worked like an enum
20:01:04 <Axman6> @src Num
20:01:04 <lambdabot> class  (Eq a, Show a) => Num a  where
20:01:04 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:01:04 <lambdabot>     negate, abs, signum     :: a -> a
20:01:04 <lambdabot>     fromInteger             :: Integer -> a
20:01:22 <Axman6> > [False..]
20:01:23 <lambdabot>   <no location info>: parse error on input `]'
20:01:25 <gwern> well, Enum is a typeclass
20:01:35 <Axman6> @src Enum
20:01:35 <lambdabot> class  Enum a   where
20:01:35 <lambdabot>     succ                     :: a -> a
20:01:35 <lambdabot>     pred                     :: a -> a
20:01:35 <lambdabot>     toEnum                   :: Int -> a
20:01:35 <lambdabot>     fromEnum                 :: a -> Int
20:01:36 <kmc> kfmfe04, "Monad" is the name of a particular interface.  if this were java we might call it SequencableComputation
20:01:37 <lambdabot> [3 @more lines]
20:01:47 <Axman6> @more
20:01:47 <lambdabot>     enumFrom                 :: a -> [a]
20:01:47 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
20:01:47 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
20:01:50 <kfmfe04> ah... ...there's an Enum type?
20:01:53 <kmc> no
20:01:54 <Axman6> no
20:01:55 <gwern> typeclass
20:01:59 <Saizan> i think kfmfe04 is talking about what other languages call enums.
20:02:06 <kmc> it's best not to worry about monads if this is your second day with Haskell
20:02:20 <kmc> if you just want to do some IO, it's an irrelevant fact that IO is a monad
20:02:29 <Saizan> which indeed are just a special case of algebraic datatypes in haskell.
20:02:33 <kfmfe04> yes, that's what I meant (enum in other languages) - ok - back to the book - thx for whetting my appetite, I will read a lot more
20:02:43 <kmc> http://haskell.org/haskellwiki/Introduction_to_IO is a good resource in that case kfmfe04 
20:02:49 <kfmfe04> thx kmc
20:02:54 <kmc> a practical intro to IO, avoiding the M-word
20:03:06 <kmc> (IO is a poor example of a monad anyway)
20:03:17 <kfmfe04> lol - every time I see the M-word, I think it looks like gonad
20:03:21 <kmc> me too
20:03:31 <kmc> the Go language has "goroutines", why not "gonads"?
20:03:38 <kmc> btw that word "goroutine" is ridiculous
20:03:48 <dons> goroutines? :(
20:03:49 <kfmfe04> =)
20:03:55 <dons> haskellions
20:03:56 <chrisdone> gurotines
20:04:00 <Saizan> kfmfe04: the haskell Enum typeclass is related though, since it's a common interface to handle those sort of types
20:04:02 <Axman6> Horoutines
20:04:04 <dons> guillotines :)
20:04:08 <Axman6> much more bad ass
20:04:14 <dons> brutal.
20:04:21 <kfmfe04> ic - LoL Horoutines
20:04:21 <kmc> kfmfe04, when people do OOP in Haskell, sometimes an OO class becomes a Haskell type, and sometimes it becomes merely a function
20:04:33 <kmc> likewise, sometimes an OO interface becomes a Haskell typeclass, and sometimes it becomes merely a type
20:04:34 <Axman6> people do OOP in haskell?
20:04:37 <kmc> yeah
20:04:48 <kfmfe04> kmc: that's a great hint - I will watch out for that
20:04:52 <kmc> there's no special support for it, but it's reasonably straightforward
20:04:57 <gwern> Axman6: OO'Haskell?
20:05:08 <Axman6> yeah, but people actually use it?
20:05:13 <kmc> i don't mean using any fancy extension or library
20:05:25 <kmc> just records of functions/actions, possibly with type classes, and possibly with existentials
20:05:49 <kmc> kfmfe04, one thing i notice is that beginners tend to over-use typeclasses, because they're used to languages where the only way to define a new behavior is to define a new type (and declare that it conforms to an existing interface)
20:06:00 <dons> yeah
20:06:05 <Saizan> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell <- if you like articles :)
20:06:11 <kmc> well, in Haskell (and every other good language) "behaviors" (meaning functions or actions) are just values, and you can make new behaviors as easily as new Ints or Strings
20:06:28 <kmc> you don't need a new type for every String literal in your program, yet that's how Java treats functions
20:06:46 * gwern doesn't follow
20:07:07 <chrisdone> i like the phrase "value oriented programming"
20:07:50 <kmc> pssh.  if Haskell were really value-oriented, we'd have dependent types
20:08:10 <kfmfe04> kmc: just glimpsing over the RWH chapter on typeclasses, that's exactly what I would do - so in place of typeclasses, how would you accomplish the same thing in a functional/Haskell way?
20:08:25 <ddarius> "Family values oriented programming"
20:08:26 <kfmfe04> what should I look up/read up on?
20:08:30 <chrisdone> ddarius: haha
20:09:14 <gwern> now now. we can't be both a BDSM language and a family values oriented one
20:09:18 <gwern> unless we're also republican
20:09:23 <kmc> hahaha gwern
20:10:01 <danharaj> Well, one of our values is always bottom, so by ex falso quodlibet...
20:10:34 <kmc> kfmfe04, data Shape = Shape { translate :: (Int, Int) -> Shape, draw :: IO () }
20:10:39 <kmc> as a typical OOP example
20:10:56 <kmc> this defines a type Shape
20:11:08 <kmc> every value of that type is a pair of a "translate" function and a "draw" action
20:11:22 <kfmfe04> ok
20:11:38 <kmc> now we can make Â«circle :: Double -> ShapeÂ» and Â«regular_ngon :: Int -> ShapeÂ» and whatever else
20:11:42 <gwern> '   We compare our COLA implementation to a traditional B-tree.
20:11:43 <gwern> Our COLA implementation runs 790 times faster for random inser-
20:11:43 <gwern> tions, 3.1 times slower for insertions of sorted data, and 3.5 times
20:11:43 <gwern> slower for searches.
20:11:47 <kmc> they're just ordinary functions
20:11:55 <danharaj> I know that existential types can manage quite elegantly many OOP idioms, but what are their most striking defficiencies in 'faking it'?
20:11:56 <kmc> and the common interface is an ordinary type
20:12:07 <kmc> danharaj, GHC's support for existentials can be roundabout and clunky
20:12:16 <danharaj> kmc: I meant more theoretically.
20:12:26 <kmc> danharaj, my biggest annoyance doing OOP in Haskell is not related to existentials; it's related to the basic failings of the record system
20:12:27 <kulin> 790 eh
20:12:48 <adu> hi all
20:12:49 * gwern always enjoys results like that. '3.1x slower, 3.5 slower, and 790x'
20:12:59 <kfmfe04> kmc: got it - ty
20:13:03 <gwern> kulin: note the precision of their slowdowns :)
20:13:05 <kmc> kfmfe04, here's a document contrasting the two styles: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
20:13:20 <kulin> ya i was admiring
20:13:20 <kmc> @quote another.function
20:13:21 <lambdabot> LukePalmer says: ...when you use an advanced feature, you need a yet more advanced feature to abstract over it... But all you need to abstract over a function is another function.
20:13:26 <Axman6> dons: do you reckon that this could be sped up any more? I'm trying to see if there's any extra working happening that doesn't need to: http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=ghc&lang2=java
20:13:32 <kfmfe04> kmc: ty for the ref - reading it now
20:14:56 <Saizan> kmc: isn't that quote self-contradicting?
20:15:28 <dolio> Yes.
20:15:33 <kmc> how?
20:15:51 <dolio> It requires that functions are more advanced than functions.
20:16:02 <kmc> no, it requires that functions aren't an "advanced feature"
20:16:02 <c_wraith> it's only self-contradicting of functions are "advanced" features.
20:16:09 <c_wraith> err, *if.
20:16:13 <kmc> they're pretty much the most basic feature
20:16:17 <danharaj> (generalizing) is idempotent w.r.t. functions? :p
20:16:26 <kmc> danharaj, that's the general claim yes
20:16:50 <danharaj> I don't know if I can agree with it, because a large part of advanced features is making more functions typeable.
20:17:06 <kmc> hmm
20:17:17 <kmc> even in a dynamically-typed context?
20:17:31 * danharaj vomits explosively
20:17:33 <tensorpudding> How do I get rid of the base 3.x Prelude warning?
20:17:35 <danharaj> don't say the D-word.
20:17:43 <kmc> such elitists here ;P
20:17:44 <dolio> But functions that abstract over other functions clearly are advanced. Many languages lack them.
20:17:49 <tensorpudding> Do I have to import Prelude explicitly?
20:17:55 <kmc> dolio, not really
20:18:08 <danharaj> kmc: I like to reason about my programs at compile time is just all.
20:18:27 <kmc> C++ and Java are the exceptions
20:18:31 <adu> wow nice link
20:18:42 <kmc> (nearly?) every other popular general-purpose language has first-class functions
20:18:59 <kmc> C gets a free pass imo because it's a low-level systems language, and not really general
20:19:05 <kmc> and so is C++ but people don't act that way
20:19:07 <danharaj> How many popular general-purpose languages can you say there are?
20:19:19 <danharaj> I don't know that many.
20:19:34 <kulin> then java should get a pass because its c with memory managment :)
20:19:35 <kmc> i'd say that Perl, Python, PHP, Ruby, JavaScript, C# are all "popular"
20:19:37 <Saizan> to abstract over monomorphic types you get a polymorphic type, if you want to abstract over a polymorphic type you get another polymorphic type of an higher-rank, fortunately going from Rank2 to RankN is not so much of a leap as from Rank1 to Rank2, in terms of understanding
20:19:47 <ksf> hmmm I think I have a problem here
20:19:52 <kmc> not just memory management, memory safety, which is a fundamental difference
20:19:57 <ksf> binary-trees is faster on by year-old machine than on the shootout
20:20:10 <adu> those are all scripting langs
20:20:14 <kmc> haha
20:20:20 <danharaj> C# is not a scripting language.
20:20:26 <kmc> the term "scripting language" is worse than useless
20:20:31 <kmc> it is good only for starting flamewars
20:20:37 <danharaj> kmc: That is what the internet is for!
20:20:40 <kulin> well, primarily interpreted then
20:20:47 <kulin> thats what people who use scripted mean
20:20:51 <kmc> JavaScript is primarily compiled these days
20:21:02 * dafis thought the internet was for pr0n
20:21:03 <danharaj> C# is mostly JIT compiled, no?
20:21:12 <Saizan> so, functions vs. existentials is a false dichotomy
20:21:15 <danharaj> dafis: Not for intellectual types like ourselves >_>;;;;;
20:21:25 <adu> flamewars start only when ppl believe in that which is false
20:21:27 <kmc> i think "scripting language" is just a pejorative form of "dynamic language"
20:21:32 <p_l> actually, C# is mostly compiled and rarely touches interpreter or even JIT
20:21:43 <kmc> i should add Lua to the list too, it sees a ton of use in game dev
20:21:54 <p_l> (most "production" code gets AoT precompilation during installation)
20:21:55 <kulin> why is lua popular anyways?
20:22:03 <adu> i <3 lua
20:22:08 <p_l> kulin: small, easy to embed and extend
20:22:16 <p_l> nice licence
20:22:23 <kmc> yep
20:22:26 <kulin> oh
20:22:26 <adu> i ported lua to android in like 5 mins
20:22:35 <kmc> you can drop the popular lua implementation into any C project with no effort
20:22:50 <danharaj> I wish there were a lightweight Haskell variant that was easy to embed in other languages.
20:23:03 <kmc> smaller and simpler than Python, smaller implementation than CPython or any popular JavaScript implementation
20:23:08 <adu> what about helium?
20:23:55 <kmc> also there's a very fast JIT for Lua, and an LLVM-based static compiler
20:23:57 <p_l> helium?
20:23:57 <Cale> Helium is simpler, but I don't think it's particularly designed to embed.
20:24:15 <danharaj> adu: I admit I have not digged very hard for such a thing.
20:24:23 <adu> helium is haskell minus typeclasses
20:24:35 <kmc> what other languages would you embed Haskell in?
20:24:50 <kmc> since Haskell's type system is a) much of the point of using Haskell, and b) very different from most languages'
20:24:50 <kulin> haskell, for the recursiveness of it!
20:25:00 <Cale> Well, we can do that :)
20:25:09 <kmc> i would guess that you'd spent a lot of effort on data marshalling
20:25:17 <mm_freak> i think, it's reasonable to call languages, where commands are executed from top to bottom, scripting languages
20:25:23 <kmc> haha
20:25:27 <danharaj> kmc: I think a 'scripting language' ;) ;) based on Haskell would be divine.
20:25:34 <kmc> Haskell executes "main" from top to bottom omg
20:25:37 <adu> Cale: i hear you are talking to iPwn
20:25:47 <Cale> adu: I'm hired :)
20:25:52 <mm_freak> kmc: a scripting language in that sense doesn't have a "main" at all =)
20:25:59 <wli> Must be nice.
20:26:09 <kmc> mm_freak, sounds like a pretty trivial syntactic property
20:26:09 <danharaj> kmc: Modifying the language to make data marshalling more lightweight ought to be a possibility.
20:26:09 <adu> Cale i totally want to work with them too
20:26:13 <mm_freak> but of course, there are as many definitions as people using the term
20:26:39 <gwern> what is iPwn?
20:26:44 <kmc> i can make a 5-line script which wraps a file in "int main() {" and "}", and calls gcc, such that it can be used in a #! line
20:26:47 <kmc> now C is a scripting language
20:26:51 <adu> i will be 100% available in sept
20:26:56 <mm_freak> kmc: the point is that a scripting language is used for a sequence of commands as opposed to a number of definitions and relations
20:26:56 <kmc> http://ipwnstudios.com
20:26:57 <gwern> also, I thought Cale was a dead-end grad student, how can he have a job?
20:27:05 <kmc> are writing an iPhone game in Haskell
20:27:07 <Cale> gwern: A company which is writing a game in Haskell for mobile devices
20:27:11 <kmc> (soon an Andriod game)
20:27:23 <mm_freak> and yes, in that sense your "almost C" would be a scripting language
20:27:25 <gwern> didn't apple amend their policy recently?
20:27:26 <Cale> gwern: I didn't actually ever go to grad school.
20:27:26 * kmc is working on targeting GHC to Android
20:27:28 <adu> i'm very good with android
20:27:30 <gwern> Cale: !
20:27:42 <p_l> gwern: they did - Haskell apps won't get accepted into App Store
20:27:45 <kmc> gwern, yes.  the new policy is "we can reject any app for any or no reason".  the old policy was "we can reject any app for any or no reason"
20:27:58 <p_l> kmc: afaik the language rule was explicit?
20:28:04 <kmc> sure
20:28:11 <kmc> but it doesn't give them any rights they didn't have before
20:28:20 <kmc> it's only a vague statement of intent, and one they are already selectively enforcing
20:28:22 <Axman6> just a better chance
20:28:28 <kmc> they want a way to bitchslap Flash without looking blatantly anticompetetive
20:29:02 <c_wraith> has anyone here used hint for a non-trivial project?
20:29:11 <kmc> anyway the capriciousness of Apple is a major concern when making an iPhone app, i'm not sure the new rule makes it particularly more of a concern
20:29:13 <gwern> c_wraith: mueval and tryhaskell.org?
20:29:36 <adu> kmc: i wouldn't call it that i would call it donkeypunching flash
20:29:40 <c_wraith> I'm getting compile errors I don't understand from hint.
20:29:48 <kmc> > text $ map pred "j(n!opousjwjbm\""
20:29:49 <lambdabot>   i'm nontrivial!
20:30:00 <Cale> c_wraith: paste them somewhere?
20:30:29 <kmc> i found hint pretty hard to understand from haddock, but the example is good at http://code.haskell.org/hint/devel/examples/
20:30:51 <danharaj> Does GHC still have compilation to C?
20:30:55 <kmc> yes
20:31:01 <kmc> but by default the C is not portable
20:31:17 <c_wraith> kmc, it's not using hint that's difficult, it's handling compile errors in code that requires quite a few packages to be in scope... but not all packages.
20:31:19 <kmc> you can build a GHC which outputs (mostly) portable C, which is called an "unregisterised" gcc
20:31:33 <danharaj> Well maybe you could work something out on Apple's platforms to avoid their Dick Rule.
20:32:02 <kmc> afaik it still depends on machine-specific details of byte order, word size, etc., but not on GCC extension to C, or custom postprocessing of the C compiler's output
20:32:04 <adu> lloll
20:32:37 <Cale> I think the plan is to make the game work on Android and some other devices as well. But it seems like as long as you're not too noisy about it, Apple doesn't really care.
20:32:38 <kmc> which reminds me, anyone here successfully built an unregisterised GHC on Platform A which outputs .hc files for Platform B?
20:35:08 <c_wraith> what I *really* want is the ability to feed a .cabal file to something that will initialize hint state from it.
20:36:31 <Axman6> dons: you around? i think i may have been able to speed up the thread-ring benchmark
20:36:59 <dolio> danharaj: I thought they specifically ruled out compiling to one of the allowed languages from another language.
20:37:12 <gwern> c_wraith: to what? that doesn't make any sense to me
20:37:16 <Axman6> or... anyone else familliar with the thread-ring benchmark?
20:37:20 <danharaj> dolio: hell if I know. I have no interest in developing for fascist platforms :p
20:37:33 <Saizan> c_wraith: if you run configure first you can load the LocalPackageInfo via the Cabal lib and extract the relevant flags, then i hope there's a way to make hint digest them.
20:37:52 <andyjgill> hi. is there a non-GPL'd/LGPL'd version of curses? What is the current consensus about LGPL and Haskell-linked code?
20:38:26 <c_wraith> Saizan, hmm, intriguing.  That may work.
20:38:26 <Axman6> nope? no one's interested in a 10 fold speed increase for the thread-ring benchmark?
20:38:44 <danharaj> Axman6: Or one is qualified to discuss it with you :
20:38:45 <p_l> andyjgill: as long as the LGPLed code is in dynamic library, you're clear. The moment the code is incorporated into single binary, you enter murky grounds.
20:38:46 <danharaj> :p
20:38:47 <c_wraith> Axman6, does it beat the cheating C implementation?
20:39:01 <Axman6> c_wraith: not sure
20:39:06 <dolio> You made it 10x faster?
20:39:08 <danharaj> BSD3 all the way!
20:39:11 <Axman6> but yeah, last time i looked, the C implementation cheated
20:39:18 <andyjgill> p_l:  :-) hence the question!
20:39:29 <Axman6> i'm "cheating" by making all the threads run on the same core
20:39:37 <Axman6> but, there's still 503 threads
20:39:51 <c_wraith> can't you do that by just compiling without -threaded?
20:39:56 <andyjgill> p_l: but you reflect what my understanding was a couple of years ago.
20:39:57 <Axman6> dolio: i believe so
20:40:06 <Axman6> just running the current one now
20:40:15 <Saizan> c_wraith: this is veeery hacky, but getGhcLibOptions does what i described above: http://github.com/Saizan/ghci-utils/blob/master/GhciUtils.hs
20:40:52 <p_l> andyjgill: personal advice - if you aren't releasing source, avoid GPL/LGPL *haskell* code, LGPL is permissible for FFI dynamically-loaded libraries.
20:41:14 <c_wraith> Saizan, I hope you had that lying around somewhere already. :)
20:41:35 <Saizan> c_wraith: i had lying on github already :)
20:41:47 <kulin> there is no reason to not release source, just name all your variables a1 a2 a3 b1 b2 b3, etc
20:41:48 <Saizan> +that
20:41:51 <p_l> andyjgill: you can avoid the trouble with properly written license
20:41:51 * Axman6 pokes dons hard with a 10x thread-ring speed up
20:41:52 <kulin> and no one will want to deal with it
20:41:57 <andyjgill> We release everything, and everything is BSD. http://www.ittc.ku.edu/csdl/fpg/Tools
20:41:59 <kmc> my vague recollection is that LGPL haskell code would be fine, iff you dynamically link
20:42:22 <kmc> which is why IHG put effort into making GHC able to produce dynamically linked executables
20:42:47 <p_l> kmc: but only if the whole LGPL code is a dynamic lib. Start inlining or other interesting performance optimisations, and you're back in trouble :)
20:42:53 <kulin> are libraries in cabal under some common license or is it per library?
20:43:07 <Saizan> today i saw a fedora user with .so's in the haskell packages, so it should work!
20:43:13 <Saizan> kulin: per library
20:43:13 <gwern> kulin: per lib. specified in the .lib
20:43:16 <gwern> *.cabal
20:43:28 <Axman6> > 60*5+51.443/33.653
20:43:29 <lambdabot>   301.52863043413663
20:43:35 <Axman6> > (60*5+51.443)/33.653
20:43:35 <lambdabot>   10.443140284670015
20:43:44 <Axman6> yep, 10x speedup
20:43:56 <adu> wtf
20:44:19 <kmc> kulin, any license is acceptable; much of it is 3-clause BSD though
20:44:29 <dafis> Axman6, awesome
20:44:33 <kmc> it would be funny to upload something to Hackage with a license forbidding all use
20:44:39 <gwern> kmc: not allowed
20:44:42 <kmc> oh?
20:44:45 <kulin> i think ill release anything do under mit, im pretty sure all that license says is 'whatever happens isnt my fault'
20:44:55 <kmc> you can do "Public Domain" too
20:44:56 <kulin> anything i do
20:45:00 <gwern> we have a policy or guideline somewhere mandating at least OSI-approved
20:45:05 <kmc> ah
20:45:12 <gwern> notice that there are no proprietary libs up on hackage
20:45:54 <andyjgill> Not meaning to start a flamewar, just want to release something BSD that uses a curses style API.
20:46:46 <kmc> gwern, i assume nobody would upload them anyway
20:46:58 <duplode> Hi all! Could you warn me about any gross inefficiencies there might be on this function, which does matrix addition for a DiffArray of DiffArrays of Maybe Int?
20:47:03 <duplode> addData d1 d2 = d2 // zip (indices d2) [ d2 ! i // zip (indices d1) [ liftM2 (+) (d2 ! i ! j)  (d1 ! i ! j) | j <- [1..] ] | i <- [1..] ]
20:47:09 <kmc> yes, DiffArray is known to perform poorly
20:47:19 <c_wraith> ooh, there's a lot to wrap my head around for this project.  It'd be so cool if I got it to work right, though.
20:47:40 <Saizan> andyjgill: which binding are you using? or did you make your own?
20:47:41 <kmc> duplode, consider IntMap or EnumMap for a reasonably fast associative data structure with immutable update and ood sharing
20:47:43 <kmc> good*
20:48:00 <c_wraith> duplode, or if sharing isn't important, an instance of MArray
20:48:24 <kmc> or the "vector" library
20:48:51 <p_l> kmc: in many countries, MIT isn't much different from public domain
20:48:51 <gwern> kmc: not necessarilly. there are source-available proprietary licenses
20:49:06 <kmc> yeah
20:49:09 <andyjgill> Saizan: Looking at terminfo (BSD) and hscurses (GPL)
20:49:20 * p_l actually chose source-available proprietary licensing for his commercial work
20:49:22 <Cale> Why is hscurses under the GPL?
20:49:58 <Cale> er, LGPL
20:50:20 <duplode> The main issue in my case would be random access and doing whole-matrix operations without copying the whole thing; don't need full-fledged mutability (I think)  
20:50:32 <c_wraith> duplode, do you need persistence?
20:50:34 <andyjgill> The hscurses lib doc contains the quote "Sections of the quoted documentation are from the OpenBSD man pages, which are distributed under a BSD license. " :-)
20:50:42 <c_wraith> that is, do you need access to old versions of the array?
20:50:57 <shajen> Axman6i: i have some problem with function which you write for me
20:51:07 <edwardk> andyjgill: getting ever more use out of data-reify
20:51:10 <Cale> duplode: Does it seem slow? DiffArrays have a lot of overhead at present unfortunately
20:51:28 <duplode> c_wraith: wouldn't need it, but could be nice.
20:51:39 <p_l> Cale: to be annoying?
20:51:40 <shajen> it's give only diagonals above the mid-
20:51:59 <Axman6i> the functions I wrote give only the results you asked for, nothing more
20:52:00 <duplode> Cale: It doesn't seem particualrly slow - I was wondering more about whether I was doing unnecessary accesses and etc. in the code
20:52:02 <andyjgill> edwardk: Glad to hear it is useful! What u using it for? We have more graph-based ideas on the way.
20:52:21 <shajen> Axman6i: i write i want all diagonal
20:52:55 <Cale> duplode: It looks sensible enough to me
20:52:56 <kmc> "The declarative debugging algorithm assumes the existence of an Oracle. That is an entity that knows the intended meaning of every function in a particular program. The Oracle could be software, a cyborg, a platypus, a deity, even a human."
20:53:02 <Axman6i> you said nothing about diagonals to me
20:53:07 <Cale> duplode: So if it performs well enough, leave it :)
20:53:10 <edwardk> andyjgill: I'm using it (well, a higher order version) in some parser combinators, I'm using it directly in an external SAT solving monad that uses it to recover sharing from bits before inserting them into the CNF. I'm also most recently using it to perform reverse mode automatic differentiation
20:53:37 <dafis> shajen: if you want the diagonals below the main diagonla, just drop a few top rows before you use Axman6i's code
20:53:39 <andyjgill> edwardk: sounds interesting.
20:53:58 <shajen> Axman6i: [[1,2,3],[4,5,6],[7,8,9]] -> [[7],[4,8],[1,5,9],[2,6],[3]
20:54:09 <duplode> Cale: good to know :) it's not likely I am going to use massive matrices with this particular function anyway, it is just a tournament bookkeeper 
20:54:10 <edwardk> andyjgill: it lets me compute the entire gradient of a non-scalar-to-scalar function in one pass backwards from the answer basically
20:54:36 <edwardk> andyjgill: http://hackage.haskell.org/packages/archive/ad/0.44.1/doc/html/src/Numeric-AD-Internal-Reverse.html
20:54:49 <edwardk> you should spot your old friend MuRef in there ;)
20:55:38 <andyjgill> edwardk: Ah. yes I see it .
20:55:42 <edwardk> andyjgill: it is just one mode among many, but it works as the best 'starting point' for most of the higher order abstractions i use.
20:56:30 <edwardk> andyjgill: because the fastest way i have to compute higher order gradients is to compute one pass using reverse mode, and then compute a lazy tower of that is careful about how it memoizes distinct derivatives
20:56:53 <andyjgill> edwardk: I was glad to turned out to be be a sweet spot. Observable sharing can be really useful. We just need a semantics!
20:57:20 <edwardk> andyjgill: yeah, here i'm fortunate in that i _could_ compute the same answer asymptotically much much slower without sharing
20:57:43 <edwardk> (i.e. heat death of the universe time scale) so its just speeding me up (a lot!)
20:58:03 <andyjgill> edwardk: :-)
20:58:32 <andyjgill> Sent email to hscurses authors about a BSD version.
20:58:33 <edwardk> i've reinvented a higher order data-reify a few times, i should probably hackage it or submit it for inclusion
20:59:24 <duplode> thanks guys, see you later
20:59:26 <edwardk> (needed when trying to observe sharing in, say, Applicatives, with that extra argument dangling around)
21:01:05 <andyjgill> I'd be happy to look at what you've got, and/or work on improving it. We've got no HO versions in to works. We want to use Obs Sharing for term rewriting.
21:07:39 <Peaker> Today I realized it might be a good idea to run "cabal install" always with --constraint for each core package, setting it to the exact version that is already installed.. Could get some stuff installed this way that otherwise wouldn't install
21:08:24 <ksf> edwardk, pleeeeeeaaaaase!
21:08:31 <Peaker> And I also realized that this laptop cannot "ld" cabal's library in reasonable time because it is too big, so it can do "runhaskell Setup.hs" but if it tries to build Setup.hs it dies.  Not sure why, some packages build, and some just run it
21:09:12 * ksf thinks that reify should be a language primitive, btw.
21:09:33 <Saizan> Peaker: hah, yeah, you're sort of doing by hand the bottom-up pass that's lacking in the solver :)
21:10:01 <Peaker> Saizan, heh, I could easily script something to do it based on the output of ghc-pkg list --global
21:11:12 <Axman6> what exactly does reify mean?
21:11:18 <Saizan> (well, if you it for all the global packages you're also adding the heuristic that you don't want to update even those that in principle are possible to update)
21:11:25 <Peaker> I am still wondering why sometimes cabal-install compiles Setup.hs, and sometimes just runs it
21:11:34 <Peaker> Saizan, Yeah, better safe than sorry :)
21:11:48 <Peaker> Saizan, Basically, I think I don't want to update any package that has a seizable list of rev-deps
21:11:54 <Saizan> Peaker: it always compiles Setup.hs
21:12:06 <Peaker> Saizan, I am pretty sure sometimes it just runhaskell's it
21:12:22 <Saizan> Peaker: nah, it's ld that doesn't always hit your swap :)
21:12:49 <Saizan> Peaker: otoh, for build-type: simple the Setup script gets ignored completely
21:12:53 <Peaker> Saizan, But even on Setup.hs that are identical, sometimes it works, sometimes not, I think the difference is whether there's "#!... runhaskell" on top
21:13:05 <Peaker> Saizan, ah!
21:13:09 <Peaker> Saizan, so that explains it, maybe
21:14:53 <ddarius> @wn reify
21:14:55 <lambdabot> *** "reify" wn "WordNet (r) 2.0"
21:14:55 <lambdabot> reify
21:14:55 <lambdabot>      v : consider an abstract concept to be real
21:14:55 <lambdabot>      [also: {reified}]
21:17:51 <ezyang> ksf: I was thinking about the monoid instance for monads, and realized we could define something slightly incoherent on (a -> b) -> m a -> m b (i.e. fmap) 
21:20:10 <edwardk> hrmm. i'm somewhat saddened by the fact that i can't overload (^) =/
21:20:14 <edwardk> or (^^)
21:20:40 <Axman6> use ^_^
21:20:50 <edwardk> Axman6: hah not a valid operator ;)
21:20:55 <Axman6> :(
21:20:56 <edwardk> ^-^ is as close as i can get
21:20:58 <Axman6> ^-^
21:20:59 <edwardk> fairly kitty-like
21:21:13 <Axman6> ^o^
21:21:15 <edwardk> looks like a 2-chan meme
21:21:31 <ddarius> =^.^= and =-.^=
21:21:43 <Axman6> bloody hell, i'm really surprised by how much i've manages to speed up this thread-ring benchmark
21:21:44 <edwardk> ddarius: best operators ever
21:22:25 <Axman6> > (60+8.033)/26.097
21:22:26 <lambdabot>   2.606927999386903
21:22:49 <edwardk> the reason i'm kind of annoyed by the lack of overloadability of (^) is that i can prove tighter bounds for (^)'s to even powers (i.e, make things positive)
21:22:56 <Axman6> seems i wasn't actually comparing to the current fastest version, but this is still at least 250% faster
21:23:23 <edwardk> (for interval arithmetic)
21:24:09 <jmcarthur> :t (^-^)
21:24:10 <lambdabot> forall v. (AdditiveGroup v) => v -> v -> v
21:24:13 <jmcarthur> already taken :)
21:24:19 <chrisdone> :O
21:24:26 <jmcarthur> vector-space package
21:24:33 <jmcarthur> subtraction
21:25:49 <edwardk> jmcarthur: sok, none of my code uses vector-space
21:25:50 <chrisdone> edwardk: ?
21:25:58 <chrisdone> where's (^^) taken?
21:26:02 <chrisdone> :t (^^)
21:26:03 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
21:26:05 <edwardk> > 2 ^^ 4
21:26:06 <lambdabot>   16.0
21:26:56 <applicative> Axman6, awesome.  
21:27:15 <Axman6> i wish i could compile the C version, but lwp doesn't exist for OS X afaik
21:28:13 <Axman6> still won't be faster than the cheating C one though
21:28:41 <applicative> why is the C one cheating.  I didn't thing there was such a thing in C
21:28:57 <chrisdone> (^â^)
21:29:01 <Axman6> well, from what i can tell, it's not really using threading at all
21:29:03 <chrisdone> (Ë-Ë)
21:29:06 <applicative> actually, i see what you mean.   the specification of the task is kind of crazy
21:29:35 <ddarius> applicative: That's a problem with many of the tasks.
21:29:38 <applicative> one is calculating x `mod` 503 + 1   why can't they think of something that will force you to thread, if you're rational
21:30:07 <shajen> > [1,2,3] ++ [4,5,6]
21:30:08 <lambdabot>   [1,2,3,4,5,6]
21:30:33 <applicative> ddarius, yes, I hadn't looked at them before, but they're not really fair to a language that would go about the problem in a completely different way
21:30:39 <ksf> what's up with the ghc trac?
21:31:31 <ksf> ah, just had to mention it here.
21:31:38 <applicative> they specify way too much of what must actually happen, rather than just what must be returned for certain inputs. 
21:32:07 <applicative> ddarius, but I suppose such complaints must have been voiced ad naus. before.
21:34:36 <chrisdone> > (*2) â^â^â [1..10]
21:34:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:35:35 <Peaker> > (*2) . [1..10]
21:35:37 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:36:00 * applicative had hoped for something better from the (?^?^? ) operator
21:36:12 <chrisdone> :t (â^â^â) . (â^â^â)
21:36:12 <lambdabot> Not in scope: `???^???^???'
21:36:13 <lambdabot> Not in scope: `???^???^???'
21:36:22 <chrisdone> stupid lambdabot
21:36:45 <chrisdone> @slap lambdabot 
21:36:45 * lambdabot would never hurt lambdabot !
21:36:48 <Axman6> applicative: in case you're interested, this is my new faster version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26113#a26113
21:37:21 <alexyk> how, on Linux, can I limit the amount of RAM a ghc-generated executable can eat up?
21:37:26 <chrisdone> Twey: The Leisure Society do a nice cover of Cary Numan's Cars
21:40:01 <kmc> alexyk, probably with some system-level facility (ulimit etc)
21:40:05 <kmc> don't think there's a way in ghc
21:40:20 <Saizan> you can set the maximum heap size.
21:40:27 <Saizan> pass it "+RTS -m<some limit>" e.g. +RTS -m1G
21:40:38 <alexyk> aha
21:41:12 <Saizan> it works on any platform
21:41:49 <blackdog> hey, anyone know who builds the mac packages for GHC?
21:41:57 <blackdog> is it chak?
21:42:07 <alexyk> I'm using this to write a file: BL.writeFile fileName $ compress . D.encode $ graph  -- and get: hClose: illegal operation (handle is finalized) -- why?
21:42:38 <ksf> edwardk, well, then fix the typeclass system first before implementing your (^)
21:42:50 <ksf> as you might have noticed, termination of software design is undecidable.
21:43:28 * hackagebot rounding 0.1.1 - Explicit floating point rounding mode wrappers  http://hackage.haskell.org/package/rounding-0.1.1 (EdwardKmett)
21:43:31 <edwardk> ksf: i'll jump right on that grenade again ;)
21:43:35 <Axman6> applicative: any thoughts?
21:44:09 <edwardk> now with a better approach to instances that let the compiler infer their presence more oten
21:44:11 <edwardk> er often
21:44:43 <edwardk> post importantly it lets me make the code that uses them, less monomorphic
21:45:16 <Saizan> inference++
21:45:30 <ksf> things'd be so easy with a typeclass per function and typeclass synonyms
21:46:08 <edwardk> ksf: not if you can't figure out a canonical signature for each that allows inference and yet is sufficiently general
21:46:19 <ksf> that's tru
21:46:20 <ksf> e
21:46:29 <applicative> Axman6, no, I'm studying what you did.  It's much faster here, but I set -N2 of course
21:46:42 <Saizan> "a typeclass per function" makes me think of Henning Thielemann, or maybe it's the lack of sleep.
21:46:53 <edwardk> saian: no that is a typeclass per module ;)
21:46:54 <Axman6> applicative: yeah me too
21:47:08 <alexyk> so why would ghc finalize my filehandle above?  is that line correct?
21:47:51 <Saizan> alexyk: that line looks fine, does your program run other code that deals with files?
21:48:10 <applicative> but Im getting real	0m3.154s vs real	0m31.743s for 5,000,000
21:48:22 <ksf> unify gadts, modules and typeclasses?
21:48:31 <Axman6> applicative: against the current one?
21:48:52 <alexyk> Saizan: not really, I read in things and then write this, and the error is preceded with the filename being written with that line
21:49:02 <applicative> Axman6, thats what Im wondering, I was following links around, so maybe it wasn't the most advanced I ended up on.
21:49:37 <edwardk> sometimes i really miss bits and pieces of the c standard library when working in haskell, like fmod
21:49:48 <Axman6> applicative: comparingt against http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=ghc&lang2=java ?
21:49:49 <edwardk> expm1, log1p, etc.
21:49:51 <applicative> Axman6, it says it was tested Tue, 08 Jun 2010 07:57:48 GMT
21:50:07 <ddarius> edwardk: kata has those, right?
21:50:23 <edwardk> ddarius: as soon as it has an ffi ;)
21:50:58 <ksf> the shootout is quite biased against haskell
21:51:11 <Axman6> because we kept winning
21:52:02 <edwardk> At this point in time we're really just playing Calvinball ;) Trying to figure our way around the next rule change the slam us with
21:52:03 <ksf> and things like binary-tree are just silly
21:52:18 <ksf> there's nothing in there one couldn't do with a single tight loop and zero memory
21:52:20 <applicative> Axman6, yeah that's what I was using, maybe something else I have going accounts for yours being 10x faster there
21:52:35 <Peaker> ksf, you mean O(1) memory?
21:52:37 <ksf> if you want to test gc, design a benchmark that actually stresses it.
21:52:40 <ksf> yep
21:52:45 <Axman6> mine's not 10x faster than the current one on my machine
21:52:49 <ksf> building and walking the trees can be fused.
21:53:25 <Axman6> i was testing against another version i'd written in the past, which wasn't particularly fast apparently
21:53:52 <Axman6> applicative: it is nice to note that it's about as fast as the C version when compiled without -threaded
21:54:05 <ksf> I tried replacing the strictness in the leaves with an IORef that holds on to the root, and it apparently got slower.
21:54:10 <Saizan_> alexyk: well, you said you read things? from the same file where you're writing them?
21:54:36 <alexyk> Saizan_: nope, two different TokyoCabinet files
21:55:15 <dolio> What's fmod?
21:55:20 <dolio> > 5 `mod'` pi
21:55:21 <lambdabot>   1.8584073464102069
21:56:17 <ksf> did anyone try deepseq'ing a lazy tree before walking?
21:56:18 <applicative> Axman6, time ./threadring6 +RTS -N2 -RTS 50000000 292  real	1m23.249s for yours, I'm still waiting for the other one, things are getting warm.
21:56:30 <Axman6> heh
21:56:40 <Axman6> applicative: yeah those numbers look consistent with mine
21:59:04 <applicative> time ./threadring +RTS -N2 -RTS 50000000 292 real	5m27.657s
22:00:08 <Axman6> so that's the current one?
22:00:19 <applicative> Axman6, so the one that theyre using now gets closer proportionally with bigger numbers
22:00:21 <applicative> yeah
22:00:39 <Axman6> what do you mean?
22:05:57 <applicative> Axman6, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26114#a26114
22:07:06 <Axman6> applicative: what are the specs of your machine?
22:07:45 <applicative> let me see, its a pretty new macbook pro but the lowest level of them
22:08:02 <Axman6> which GHC?
22:08:41 <Axman6> because i'm using a late 2007 MBP, with 6.12.1, and i'm getting ~26s when using +RTS -N2 -RTS 50000000
22:08:54 <applicative> 6.12 , but it occurs to me it's the 32 bit one
22:09:06 <Axman6> mine too
22:09:32 <Axman6> wait, which is mine, threadring6 or threadring?
22:09:45 <applicative> youre threadring6, ]
22:09:51 <Axman6> good :)
22:09:57 <Axman6> though, yours is still very slow
22:10:00 <applicative> youre threadring6, sorry, could have done better formatting.
22:10:20 <Axman6> $ time ./threadring-ghc-7 +RTS -N2 -RTS 50000000
22:10:20 <Axman6> 292
22:10:20 <Axman6> real	0m26.489s
22:10:20 <Axman6> user	0m25.844s
22:10:22 <Axman6> sys	0m0.083s
22:12:43 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26115#a26115
22:12:48 <ksf> what do you think, is that valid?
22:12:54 <ksf> it's faster on my box
22:13:12 <applicative> man, it
22:13:32 <applicative> is hopeless doing these tests without a proper framework, I keep counting the zeros
22:13:34 <Axman6> ksf: what are the changes?
22:13:56 <ksf> the leaves are lazy now, but I'm seq'ing to hold on to the root 
22:14:34 <ksf> which should unfold the leaves lazily, but keep the gc from collecting them before they all exist.
22:15:03 <Axman6> does it allocate the the whole tree?
22:15:20 <ksf> well it has to, to calculate the result
22:15:51 <ksf> it's not allocating before starting the walk, though.
22:15:55 <applicative> Axman6, I see my mistake, for the monster 50000000, i get time ./threadring6 +RTS -N2 -RTS 50000000292 real	0m31.374s
22:16:05 <Axman6> that's more like it
22:16:31 <ksf> "this is an adaptation of a benchmark for testing GC so we are interested in the whole tree being allocated before any nodes are GC'd - which probably excludes lazy evaluation."
22:16:38 <ksf> it doesn't say anything about when to walk.
22:17:12 <ManateeLazyCat> What's your favourites function in Control.Applicative? I use <$> always, but i want know you how to use Control.Application. :)
22:17:26 <Peaker> ManateeLazyCat, liftA2
22:17:48 <applicative> Peaker, No!
22:17:50 <Peaker> I like doing: (liftA2 . liftA2 . liftA2) ...
22:17:53 <ksf> oh wait I'm not keeping that long-lived tree
22:19:02 <ManateeLazyCat> Peaker: Looks liftA2 similar with liftM2. :)
22:19:46 <Peaker> ManateeLazyCat, Yeah, but more general
22:19:50 <Peaker> (No need for "Monad")
22:20:15 <applicative> Axman6, my mistake was, I got bored waiting for the official one to finish so I started yours in another terminal.  Not quite mentally ready for shootout testing here...
22:20:17 <ManateeLazyCat> Peaker: Ok, thanks for suggestion. :)
22:20:26 <Axman6> heh :P
22:20:29 <ManateeLazyCat> I'm looking for Control.Applicative tips :)
22:20:38 <Peaker> @type liftA2 . liftA2 . liftA2 . liftA2 . liftA2 . liftA2
22:20:39 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) a b c (f5 :: * -> *). (Applicative f, Applicative f1, Applicative f2, Applicative f3, Applicative f4, Applicative f5)
22:20:39 <lambdabot> => (a -> b -> c) -> f (f1 (f2 (f3 (f4 (f5 a))))) -> f (f1 (f2 (f3 (f4 (f5 b))))) -> f (f1 (f2 (f3 (f4 (f5 c)))))
22:21:37 <m3ga> hi, i've used Curl to pull down a web page, TagSoup to parse it, but when I try to print a TagText I get 'hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)'
22:21:45 <m3ga> how do i workaround this?
22:21:57 <ManateeLazyCat> Peaker: More tips?
22:23:29 <Peaker> ManateeLazyCat, There are useful standard instances for Applicative/Monoid, Applicative/Num, etc.  e.g:  instance (Monoid a, Applicative f) => Monoid (f a) where mempty = pure mempty ; mappend = liftA2 mappend   -- though in Haskell2010 they aren't expressible because of overlapping. It's still useful boilerplate to copy for each Applicative instance you make
22:25:12 <Peaker> ManateeLazyCat, Also important to remember that (>>), sequence, mempty/mplus, have Applicative counterparts so don't require bringing the mighty Monad in
22:26:14 <Axman6> say no to Monad!
22:26:43 <ManateeLazyCat> Peaker: What's useful for <|> ?
22:26:55 <kmc> monads mo problems
22:27:09 <applicative> Axman6, so in the end the true times for Axman v. the currently posted one (at 50,000,000) are:  Axman6: 0m31.374s ; currently posted: 4m53.570s 
22:27:19 <Axman6> excellent
22:27:20 <Peaker> ManateeLazyCat, Error handling
22:27:44 <kmc> parsers
22:29:58 <ManateeLazyCat> Peaker: such as : (return True) <|> (return $ error "foo") ?
22:30:15 <Peaker> @src Alternative
22:30:16 <lambdabot> class Applicative f => Alternative f where
22:30:16 <lambdabot>     empty :: f a
22:30:16 <lambdabot>     (<|>) :: f a -> f a -> f a
22:30:32 <Peaker> > empty <|> Just 5
22:30:33 <lambdabot>   Ambiguous occurrence `empty'
22:30:33 <lambdabot>  It could refer to either `Control.Applicative...
22:30:41 <Peaker> > Control.Applicative.empty <|> Just 5
22:30:42 <lambdabot>   Just 5
22:30:45 <Peaker> > Nothing <|> Just 5
22:30:46 <lambdabot>   Just 5
22:30:51 <Peaker> > Just 8 <|> Nothing
22:30:52 <lambdabot>   Just 8
22:30:55 <Peaker> > Just 8 <|> Just 9
22:30:56 <lambdabot>   Just 8
22:31:31 <Peaker> Control.Applicative.empty or instance-specific error-creation -- then <|> to "catch" the error and choose the right-hand-arg instead
22:31:40 <Peaker> > [1,2,3] <|> [4,5,6]
22:31:41 <lambdabot>   [1,2,3,4,5,6]
22:32:14 <Peaker> Makes sense for the case of representing error as []
22:32:27 <ManateeLazyCat> Peaker: Hmmm, looks Control.Applicative not just for some monad like *Control.Monad*, it's also for pure expression, like "Nothing <|> Just 5", right?
22:32:54 <kmc> what's a "pure expression"?
22:32:59 <Peaker> ManateeLazyCat, It's similar to MonadPlus
22:33:06 <kmc> Applicative isn't
22:33:11 <kmc> Alternative is similar to MonadPlus
22:33:16 <Peaker> Yes, I was talking about Alternative
22:33:21 <kmc> Maybe is Applicative, Alternative, Monad, and MonadPlus
22:33:33 <kmc> i'm not sure whether an expression using Maybe is a "pure expression"
22:33:39 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26116#a26116
22:33:40 <kmc> i doubt the term is useful in this context
22:33:54 <ksf> anybody willing to bench that on a recent box including multicore?
22:34:08 <Peaker> Did anyone here play with the Snap web framework?
22:34:17 <ManateeLazyCat> Peaker: I'm not familiar with "*>, <$, <*", can you explain those operator one by one? Thanks. :)
22:34:29 <Peaker> I am running the tutorial example ("snap init") and it says "static" is routed to a directory browser, but it seems to generate an error
22:34:35 <Peaker> @type (*>)
22:34:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
22:35:19 <ksf> *> is sequencing returting the right, and "foo <$" is like "(const foo) <$> "
22:35:22 <Peaker> ManateeLazyCat, This one returns an "f" which is a "fusing" of the two f's (e.g: Sequencing IO effects, or cartesian combination of both lists, etc) and returns the value in the right-hand arg
22:35:30 <Peaker> @type (<$)
22:35:32 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
22:35:54 <Peaker> @type fmap . const
22:35:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
22:36:29 <Peaker> @type (<*)
22:36:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
22:36:39 <Peaker> ManateeLazyCat, So (*>) is very much like Monad's (>>)
22:36:58 <ManateeLazyCat> ksf: So (*>) is more like (>>), but more generic?
22:37:02 <Peaker> ManateeLazyCat, And (<*) is similar, except returns the left-side instead of the right
22:37:08 <ksf> yep
22:37:13 <ManateeLazyCat> I see.
22:37:15 <ksf> >> isn't actually monadic
22:37:26 <ksf> ...theoretically speaking, that is.
22:37:49 <ManateeLazyCat> It's not problem if i use (*>) replace all (>>) since i use (>>) everywhere.
22:37:51 <ManateeLazyCat> ?
22:38:05 <ksf> <* has the same evaluation direction as *>, though
22:38:13 <ksf> they only differ in the value that's thrown away.
22:38:29 <ddarius> :t liftA2 fst
22:38:30 <lambdabot> forall b b1 c (f :: * -> *). (Applicative f) => f (b1 -> c, b) -> f b1 -> f c
22:39:01 <Peaker> :t liftA2 ?fst
22:39:02 <ddarius> :t liftA2 $ uncurry fst
22:39:02 <lambdabot> forall a b c (f :: * -> *). (?fst::a -> b -> c, Applicative f) => f a -> f b -> f c
22:39:03 <lambdabot> forall b c (f :: * -> *) b1 b2. (Applicative f) => f ((b2 -> b -> c, b1), b2) -> f b -> f c
22:39:06 <ddarius> :t liftA2 $ curry fst
22:39:07 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
22:39:20 <Saizan_> :t liftA2 const
22:39:21 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
22:39:45 <Peaker> @check (liftA2 . liftA2) (==) const (curry fst)
22:39:45 * hackagebot bson 0.0.1 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.0.1 (TonyHannan)
22:39:45 <lambdabot>   "OK, passed 500 tests."
22:39:47 * hackagebot numeric-extras 0.0.1 - Useful tools from the C standard library  http://hackage.haskell.org/package/numeric-extras-0.0.1 (EdwardKmett)
22:40:07 <ddarius> edwardk: Oh man
22:40:11 <edwardk> ddarius: ?
22:40:47 <ManateeLazyCat> Looks i can use (<|>) improve much code.
22:40:50 <ddarius> You have a crazy class for this stuff too.
22:41:04 <edwardk> which stuff? RealExtras?
22:41:17 <ksf> maybe the shootout guys should accept that it's no shame to be beaten by haskell, in the same way that it's no shame to be beaten by chuck norris.
22:41:17 <ManateeLazyCat> Thanks all for help! :)
22:41:39 <edwardk> i needed something i could use to put 'fmod' in in a way that i could use it in interval arithmetic
22:41:54 <edwardk> all of this is leading up so i can write a nice definition of interval sin/cos/etc ;)
22:42:12 <Axman6> applicative: well, i've submitted it to the shootout :)
22:42:40 <edwardk> but i needed them to be polymorphic, otherwise code 3 packages away would to be screwed ;)
22:42:42 <ManateeLazyCat> Peaker: So you always use Control.Applicative function? Such as, use liftA2 replace liftM2 ?
22:42:53 <ddarius> Peaker: curry fst = const
22:44:40 <applicative> Axman6, well good work. I'll have to study up on numCapabilities .
22:44:46 * hackagebot rounding 0.3.0 - Explicit floating point rounding mode wrappers  http://hackage.haskell.org/package/rounding-0.3.0 (EdwardKmett)
22:44:58 <Axman6> applicative: numCapabilities == the n in -Nn
22:45:18 <Axman6> it's a wonder it's not IO
22:45:25 <Axman6> seems somewhat of a hack to me
22:46:05 <applicative> Oh I see, but then we have to tell the RTS again?
22:46:40 <Axman6> what do you mean?
22:46:41 <applicative> I see, basically it's appearing as an argument
22:47:17 <applicative> Sorry, not expressing myself, but I get it. 
22:48:21 <Axman6> heh
22:49:13 <c_wraith> Hmm.  I guess I was wrong.  I still can't make Typeable play nicely with higher-kinded types.
22:49:24 <c_wraith> I keep getting overlapping instance errors.
22:50:52 <ManateeLazyCat> c_wraith: Can you paste your code?
22:50:52 <edwardk> i think i killed patch-tag
22:52:55 <Axman6> > (4*60+53.570)/31.374
22:52:55 <lambdabot>   9.357110983617007
22:54:52 <Peaker> ManateeLazyCat, I use liftM2 if I already have a "Monad m" context and don't want it to become (Monad m, Applicative m) context
22:55:12 <Peaker> ManateeLazyCat, But if I don't have the Monad context I always use liftA2, yeah
22:55:20 <ManateeLazyCat> Peaker: I see, thanks.
22:55:29 <c_wraith> ManateeLazyCat, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26117#a26117  I copied all the relevant code into there, but that means the line numbers from the error message make no sense
22:56:55 <ManateeLazyCat> c_wraith: OverlappingInstances option ?
22:57:14 <c_wraith> It's already on, for the less specific instance.
22:57:15 <ManateeLazyCat> c_wraith: Add OverlappingInstances after ScopedTypeVariables and try again.
22:57:42 <c_wraith> Look at the one that says "Overlap Ok"
22:58:03 <c_wraith> I think maybe I should just use that, and change the Typeable instance to a Typeable1 instance
22:58:43 <edwardk> c_wraith: you want Typeable instances for TemplateMonad?
22:59:09 <edwardk> i have similar ones lying around one sec
22:59:57 <c_wraith> I want Typeable instances for TemplateMonad *and* TemplateState.
23:00:05 <edwardk> c_wraith: no problem
23:00:27 <c_wraith> well.  I wrote an instance that worked for TemplateMonad until I wrote an instance for TemplateState, too.  :)
23:00:40 <edwardk> *nods*
23:01:18 <edwardk> Well, the instance for TemplateMonad shouldn't care about TemplateState, but you may have some problems if you're not careful about NOINLINE, etc.
23:01:35 * ManateeLazyCat Sometimes i hate State Monad, write *lift* everywhere..... 
23:01:36 <edwardk> why are you using splitTyConApp?
23:02:01 <c_wraith> because I couldn't figure out how else to create a TyCon for the generic m
23:02:31 <edwardk> just use typeOf1 on something cast to (m a)
23:02:38 <c_wraith> oh, I see.
23:02:41 <edwardk> you first need to derive Typeable1 for TemplateMonad
23:02:53 <edwardk> instance (Typeable1 m) => Typeable1 (TemplateMonad m)
23:03:16 <edwardk> then instance (Typeable1 m, Typeable a) => Typeable (TemplateMonad m a) where typeOf = typeOfDefault
23:03:28 <ksf> no I'm not faster, ghc optimized away the seq that was holding on to the root.
23:03:37 <ksf> it still might work on multicore, though.
23:03:58 <edwardk> then you can go back and do instance Typeable1 m => Typeable (TemplateState m)
23:04:17 <adnap> I mostly finished going through this page: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html and I'm wondering why they call "unit" "return" officially.
23:04:21 <edwardk> let me dig up a nice simple higher order typeable
23:04:22 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26116#a26118
23:04:26 <ksf> can someone check that?
23:04:32 <c_wraith> edwardk, why weren't you around last time I was trying to figure this out? :)
23:04:39 <edwardk> c_wraith: check out the bottom of http://hackage.haskell.org/packages/archive/ad/0.44.1/doc/html/src/Numeric-AD-Internal-Composition.html
23:05:07 <edwardk> that defines the composition of two AD modes as typeable, even though almost everything involved is Typeable1
23:05:29 <edwardk> you just need the mkTyConApp yourTyCon [typeOf1 (...)]
23:06:01 <edwardk> and you probably want to make sure to follow that general idiom with the CAFs and NOINLINES
23:06:11 <Saizan_> won't "instance (Typeable1 m) => Typeable1 (TemplateMonad m)" then give you the Typeable instance for free via the generic (s a) one?
23:06:26 <edwardk> Saizan_: no, there is no generic s a instance
23:06:42 <edwardk> Saizan_: it is free, but not provided, because then ALL typeables would be Typeable1's
23:06:53 <c_wraith> Saizan_, I was thinking that myself
23:06:53 <edwardk> there is typeOfDefault
23:07:03 <edwardk> but you need to instantiate with it yourself
23:07:17 <c_wraith> edwardk, the instance must exist...  If it didn't, I wouldn't get that errors message
23:07:20 <edwardk> thats like saying instantiating Applicative should make you automatically a Functor
23:07:31 <Saizan_> edwardk: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Typeable.html#t%3ATypeable <- haddock is lying?
23:07:34 * ksf thinks the shootout guys should provide hand-optimized assembly code so there's a clear baseline that shows what's allowed and what's not.
23:07:54 <edwardk> Saizan_: holy hell. who put that in there
23:07:59 <c_wraith> The error message talks about "instance [overlap ok] (Typeable1 s, Typeable a) => Typeable (s a)        -- Defined in Data.Typeable"
23:08:05 <edwardk> ok, then
23:08:27 <edwardk> i guess it makes sense since this is the one case where you _couldn't_ mean anything else ;)
23:08:28 <c_wraith> Just writing the Typeable1 instance should suffice, right?
23:08:32 <edwardk> c_wraith: yeah
23:08:44 <c_wraith> ok, I'll try to do this right this time. :)
23:09:00 <Peaker> "ld" dies on this computer easily because of memory use. It has an option "--no-keep-memory" which should help here. How can I tell cabal-install/Cabal to use that option with ld?
23:09:11 <c_wraith> Oh, should I provide a fully qualified name for to mkTyCon, like you do?
23:09:40 <c_wraith> Instead of the in-module name?
23:09:43 <edwardk> c_wraith: it is recommended iirc
23:09:46 <ksf> Peaker, I think ghc is calling ld
23:09:53 <edwardk> because the end user doesn't know what module it came from
23:10:00 <ksf> so you can pass cabal an option to pass ghc an option to pass an option to ld
23:10:11 <Peaker> ksf, I think Cabal uses it without "--make"
23:10:22 <ksf> cabal uses --make
23:10:36 <Saizan_> yeah Cabal uses --make
23:10:42 <Peaker> ksf, Any idea how to tell Cabal to pass a GHC option?
23:10:55 <ksf> -ghc-option=
23:10:59 <ksf> or --
23:11:33 <Axman6> i thought cabal used --package so that it would only use the packages listed in the .cabal file?
23:11:38 <edwardk> c_wraith: at least you're safe in that it doesn't make sense to define Data for either of them
23:11:41 <Peaker> in Setup configure or in Setup build?
23:11:42 <ksf> it does
23:11:56 <ksf> and it also uses --hide-all-packages before listing them
23:12:03 <ManateeLazyCat> Peaker: If you use .cabal file, add ghc-options in .cabal file.
23:12:09 <ksf> build
23:12:13 <ksf> if in doubt, both.
23:14:09 <Peaker> thanks
23:14:13 <Saizan_> > 257-111
23:14:14 <lambdabot>   146
23:14:20 <c_wraith> edwardk: I'd be terrified of that.  And yeah, just defining a Typeable1 instance for TemplateMonad fixed the overlapping instances error.
23:14:58 <edwardk> c_wraith: its not an instance i usually run into, since i'm usually dealing with functors even for my last few arguments
23:15:05 <adnap> Why is the identity monad called return?
23:15:42 <ManateeLazyCat> Do you use ghc option "-H14m" ?
23:15:44 <Saizan_> adnap: the monad is the type constructor, not a function with a monad in its type
23:15:57 <Axman6> adnap: huh?
23:15:58 <c_wraith> edwardk, by the way, do you recommend using CAF and the no-inline pragma so that mkTyCon isn't inlined and called from multiple places?  Is it a problem if it is?
23:16:02 <BMeph> adnap: FP humor. ;)
23:16:12 <Axman6> the identity monad is the Identity monad
23:16:22 <edwardk> c_wraith: my recollection was that the module used unsafe things behind the scenes to allocate IDs
23:16:23 <Axman6> > return 1 :: Identity Int
23:16:23 <lambdabot>   No instance for (GHC.Show.Show
23:16:23 <lambdabot>                     (Control.Monad.Identity....
23:16:28 <Axman6> :(
23:16:40 <edwardk> c_wraith: if its inlined then you could get casts that fail spuriously
23:16:42 <c_wraith> edwardk, yikes.  In that case, CAF and no-inline it shall be.
23:16:43 <adnap> Sorry, I'm just learning about monads.  I made an explanation a few minutes ago.
23:16:55 <adnap> I read this tutorial: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:17:02 * hackagebot ad 0.44.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.44.2 (EdwardKmett)
23:17:17 <edwardk> c_wraith: and i patched my code in ad to no longer have the overlapping instances in question
23:17:18 <adnap> This guy introduces the concept of an "identify" function called unit, or "return" officially.
23:17:24 <edwardk> c_wraith: so i got something out of it ;)
23:17:25 <Saizan_> adnap: "return :: Monad m => a -> m a" is called so because of how often it sits at the bottom of a do-block, applied to the result of it
23:17:33 <c_wraith> edwardk, is that the release you just made? :)
23:17:37 <edwardk> c_wraith: yeah
23:17:46 <adu> adnap: monads are like fish in a barrel
23:17:48 <c_wraith> then yay, we all learned something! :)
23:17:58 <edwardk> c_wraith: how is the cheesy new template monad i gave mightbyte working out?
23:18:06 <alexyk> how can I sort a list of the form: ("a",(1,2)),("b",(1,3)),("c",(2,4)),("d",(1,5))] by (fst . snd) ?
23:18:41 <adnap> Saizan_: It seems weird since the "do" notation is just sugar.
23:18:42 <edwardk> c_wraith and was the typeable instance just for completeness?
23:18:55 <adnap> Saizan_: It doesn't describe what it does to me.
23:19:22 <c_wraith> The typeable instance is related to my attempts to get hint working for dynamically loading the action to execute on each request.
23:19:31 <adu> adnap: it doesn't do anything
23:19:46 <kmc> that's not really true
23:19:48 <edwardk> c_wraith: ah!
23:19:53 <kmc> depending on the monad, "return" could do a lot of work behind the scenes
23:20:07 <c_wraith> And so far, I've barely scratched the surface of Heist.  The new template monad appears to work just fine, from my minimal use of it. :)
23:20:07 <kmc> but what's important to you is that Â«return x >>= fÂ» is equivalent to Â«f xÂ»
23:20:28 <edwardk> kmc: well, at least a bounded amount, since the monad laws prevent you from letting it bottom out
23:20:35 <kmc> that is, Â«do { y <- return x; f y }Â» is equivalent to Â«f xÂ»
23:20:39 <kmc> hehe edwardk
23:20:46 <adnap> Can someone please check out the link I posted to see where I'm coming from?  I have very little exposure to monads, and I'm trying to rationalize things in terms of this tutorial I've read.
23:20:53 <Saizan> and that "m >>= return" is equivalent to "m"
23:20:57 <kmc> adnap, out of curiosity, how much Haskell do you know?
23:21:31 <adnap> kmc: Just about everything convered in the Gentle Intro to Haskell up to the chapter on Monads, and then a little bit of Parsec.
23:21:35 <kmc> cool
23:21:46 <kmc> "return" is a bad name, imo
23:21:50 <kmc> the similar thing in Applicative is named "pure"
23:22:02 <kmc> and once the Monad / Applicative hierarchy is rationalized, we can just use that
23:22:03 <alexyk> is there a groupBy which sorts first?
23:22:10 <adnap> kmc: That's what I think, after reading that tutorial.
23:22:14 <kmc> of course we've bikeshedded endlessly on what the name should be
23:22:24 <kmc> the name "return" makes sense at the end of a do block
23:22:33 <edwardk> kmc: i think return was largely chosen so that do .... blocks could end in return and they could pretend nothing magical was happening to newbie
23:22:35 <edwardk> er newbies
23:22:37 <adnap> kmc: Now that I've read that tutorial, I find it hard to reason about the sugar notation.
23:22:43 <kmc> and end up confusing them 5-fold ;)
23:22:48 <edwardk> kmc: hah
23:22:48 <kmc> adnap, hard how?
23:23:00 <kmc> there's little point in using "return" in a position in a do-block other than the last
23:23:23 <kmc> when you do, the result is not what most programmers expect
23:24:10 <BMeph> adnap: Seriously, "return" is FP humor. ;)
23:24:34 <adnap> kmc: It's hard to explain.  It's hard to see the binding process first of all.  When I see x >>= f, I just want to see bind f x.
23:24:42 <kmc> well
23:24:49 <kmc> let bind = flip (>>=)
23:24:49 <kmc> ;)
23:24:50 <adnap> kmc: It's hard to see how f is transformed.
23:24:53 <kmc> (>>=) is often pronounced "bind"
23:25:03 <kmc> what do you mean by "transformed"?
23:25:22 <Saizan> (f =<<)
23:25:29 <adnap> kmc: Changed into a function that can accept the result of another function.
23:25:40 <kmc> that doesn't make sense to me
23:25:49 <Saizan> kmc: that's what (=<<) does
23:26:02 <Saizan> goes from (a -> M b) to (M a -> M b)
23:26:06 <kmc> ok
23:26:07 <adnap> kmc: f takes an "a", but it needds to accept an "m a" given as the result of another function.
23:26:10 <kmc> fair enough
23:26:15 <Saizan> it's the kliesli star exposition of monads
23:26:27 <Axman6> @src Maybe (>>=)
23:26:27 <lambdabot> (Just x) >>= k      = k x
23:26:27 <lambdabot> Nothing  >>= _      = Nothing
23:26:41 <kmc> i never thought of (>>=) as particularly a transformer on its second arg
23:26:46 <kmc> i see the idea though
23:26:48 <Axman6> me either
23:26:51 <adnap> kmc: Weird
23:27:03 <Axman6> i've always seens it as a pipe
23:27:08 <Saizan> that's because (>>=) has the arguments in the wrong order to convey that intuition :)
23:27:14 <kmc> the way i think of Â«x >>= fÂ» is, you "run" some action x, and get a result, and f gets to use the result to decide the next action
23:27:19 <adnap> Saizan: I hate that!
23:27:33 <kmc> where "run" is in quotes because the meaning of that verb is totally dependent on the particular Monad instance you're working in
23:28:02 <adu> good intro
23:28:17 <edwardk> kmc: actually that is the important part of bind. once you grok that bind takes (a -> m b) -> (m a -> m b) it is clear why extend (w a -> b) -> (w a -> w b) is the corresponding dual operation for a comonad. otherwise the fact that the args are flopped around confuse the hell out of you
23:28:22 <adnap> Someone here posted a link to that tutorial a few days ago and it's the only one that has made sense so far.  I think I need to read another one to get a different perspective.  The Gentle Intro explanation sucks.
23:28:32 <kmc> hmm interesting edwardk
23:28:33 <Saizan> adnap: you'd like (>=>) more i guess
23:28:45 <Axman6> :t (>=>)
23:28:46 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:28:55 <c_wraith> One of these days, I'll remember <=< and >=> exist
23:29:01 <adu> adnap i think the catigorical introduction is the best
23:29:04 <Saizan> :t (<=<)
23:29:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:29:22 <Axman6> @src (>=>)
23:29:22 <lambdabot> Source not found.
23:29:28 <edwardk> kmc: but this point in your exposition is probably not the right time for me to segue into comonads. ;)
23:29:35 <kmc> why use (<=<), just wrap in Kleisli and use (.) ;)
23:29:39 * Saizan thinks what adnap read is a good approximation of best
23:29:39 <adnap> The thing is, I had an intuitive understanding of Parsec, but I didn't think about things in terms of binding functions.  Now when I try to reason about the behavior from the "do" notation, it's hard.
23:30:09 <adnap> What do you all read?
23:30:14 <adnap> *did
23:30:37 <edwardk> adnap: there is an adage that it is your 3rd of 4th monad tutorial that makes it all make sense.
23:30:43 <adu> yes it is hard but the more you practice with substitution the easier it gets
23:30:54 <adnap> Bring on the tutorials!
23:30:59 <Saizan> adnap: you're basically in the position where you've learned function composition before function application
23:31:05 <adnap> I want to know what you guys read.
23:31:13 <adnap> Saizan: Yikes!
23:31:15 <edwardk> adnap: by then you've let it rest long enough that some explanation finally crystalizes for you
23:31:26 <Axman6> i learnt to use monads by just using them, and then implementing them
23:31:55 <edwardk> implementing monads is a great way to learn them
23:31:57 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation , http://www.haskell.org/haskellwiki/Monads_as_containers -- if you really want more to read :)
23:31:59 <Axman6> adnap: this was the most useful thing for me understanding monads: http://blog.tmorris.net/20-intermediate-haskell-exercises/
23:32:00 <adu> adnap : i read the definition of a monad
23:32:02 <adnap> Axman6: I can't think of a good use for them yet.  I think 'cause I'm not thinking in terms of monads yet.
23:32:19 <adu> in cat theory
23:32:32 <adnap> Thanks!
23:32:36 <edwardk> adnap: one fun exercise is to take just the types, not the definitions from some stock monads and try to work out how the types have to fit together to define the monad in question
23:32:39 <edwardk> i.e. given
23:33:02 <edwardk> newtype Reader e a = Reader (e -> a) -- there is only one instance Monad (Reader e) that makes sense
23:33:08 <edwardk> er
23:34:14 <edwardk> and newtype State s a = State (s -> (a, s)) -- there happen to be two ways the types can fit together that make sense (modulo strictness) but one definitely doesn't model state the way you think state should work!
23:35:47 <adnap> edwardk: Why do you redefine the types?
23:36:22 <edwardk> adnap: well, if you go implement them yourself you learn a lot about why they were put together that way
23:37:48 <edwardk> i know i personally learn best by taking a stab at implementing something than I do from reading someone else's code. the compiler is a great sanity check that i really understand something
23:37:58 <adnap> edwardk: I understand that part.  I just mean, why the newtype declarations?
23:38:11 <adu> why not?
23:38:12 <edwardk> adnap: because otherwise you can't make the instance for State
23:38:28 <edwardk> adnap: you _can_ define an intance Monad ((->) e) where ..
23:38:39 <edwardk> but the state monad needs the wrapper
23:39:31 <edwardk> Monad expects a single type of kind * -> *. (s -> (a, s)) -- has kind *
23:40:08 <adnap> edwardk: So it has to look like Thing * *?
23:40:27 <edwardk> adnap: yeah, there has to be a place to apply the type to an extra type argument.
23:41:00 <edwardk> 'State s' has kind * -> *, meaing it has a hole expecting a single type of kind *
23:41:27 <adnap> edwardk: Wha-?
23:41:42 <edwardk> more exactly State has kind * -> * -> *. s has kind *, so State s :: * -> *, , and since a :: *, State s a :: *
23:41:58 <edwardk> read those like the 'types of types'
23:42:09 <adnap> edwardk: What is a hole?
23:43:09 <edwardk> when you talk about instance Monad Parsec where ...  or instance Monad Maybe where ... the Maybe data type expects another argument before you can actually create values that have that type
23:43:10 <BMeph> (,) a has kind * -> *. :)
23:43:19 <edwardk> (,) has kind * -> * -> * ;)
23:43:22 <edwardk> :k (,)
23:43:23 <lambdabot> * -> * -> *
23:43:27 <edwardk> :k Either
23:43:28 <lambdabot> * -> * -> *
23:43:31 <edwardk> :k Maybe
23:43:32 <lambdabot> * -> *
23:44:03 <edwardk> :k Either Int
23:44:04 <lambdabot> * -> *
23:44:08 <edwardk> :k Either Int Bool
23:44:09 <lambdabot> *
23:44:17 <edwardk> :k (->)
23:44:18 <lambdabot> ?? -> ? -> *
23:44:23 <edwardk> er that one is ugly, but
23:44:26 <adnap> Is * used to represent a hole?
23:44:28 <edwardk> :k (->) Int
23:44:29 <lambdabot> ? -> *
23:44:34 <edwardk> :k (->) Int Bool
23:44:35 <lambdabot> *
23:44:52 <edwardk> they are places types go
23:45:11 <edwardk> the word hole above wasn't anything terribly formal
23:46:09 <edwardk> you can think of them like types of types, because you can do the same thing as when you have a function that expects arguments. you feed them arguments through application
23:46:13 <edwardk> :t Just
23:46:14 <lambdabot> forall a. a -> Maybe a
23:46:21 <edwardk> :t Just 12
23:46:22 <lambdabot> forall t. (Num t) => Maybe t
23:46:41 <edwardk> :k Maybe
23:46:42 <lambdabot> * -> *
23:46:44 <edwardk> :k Maybe Int
23:46:45 <lambdabot> *
23:46:53 <adnap> I think I know what you mean.  It's just like any container type when you say type of a type, right?
23:47:01 <adnap> Like [Bool] is a type of List, right?
23:47:42 <edwardk> Bool is the result of applying the list type [] :: * -> *, to the argument Bool :: *, yielding a type [Bool] :: *
23:47:50 <edwardk> er [Bool] is the 
23:48:03 <BMeph> :k []
23:48:04 <lambdabot> * -> *
23:48:11 <BMeph> :k [Bool]
23:48:12 <lambdabot> *
23:48:44 <adnap> How am I supposed to interpret Bool :: *?  What could the * be in this case?
23:49:01 <Saizan> * is the kind of non-parametrized types
23:49:13 <edwardk> adnap: so my anal retentive streak would prefer to say [Bool] is the result of the application of the list data type to Bool, rather than the more colloquial '[Bool] is a type of list'
23:49:39 <edwardk> adnap: * is called the 'kind' of the type, it is a 'type of types'
23:49:45 <BMeph> adnap: Bool :: * is GHC's way of saying "Bool is a type". 
23:50:08 <edwardk> whereas
23:50:10 <edwardk> :k Maybe
23:50:11 <lambdabot> * -> *
23:50:25 <adnap> And in this case, the kind is the no-argument kind?
23:50:43 <edwardk> says that Maybe isn't a type that actually has any values, but if you give a type, then you might be able to have values that have that type.
23:51:16 <adnap> And 'a' is used to represent values first, right?
23:51:33 <edwardk> adnap: correct. Bool is a real honest to goodness fully fleshed out type that can have values.
23:51:35 <edwardk> :t True
23:51:36 <lambdabot> Bool
23:51:48 <Saizan> which a?
23:52:31 <edwardk> when you trip over a lower case variable in a type, its because we quantified over it. we use 'forall' a lot like lambda to create new types. thats why when you look at say
23:52:32 <edwardk> :t Just
23:52:33 <lambdabot> forall a. a -> Maybe a
23:52:42 <adnap> Bool :: * means Bool is a type of the no-argument kind?
23:52:43 <BMeph> Saizan: Shh, you! Let the newbie get comfortable, then confuse 'im. ;)
23:52:45 <edwardk> it shows the explicit forall
23:52:57 <edwardk> adnap: yes
23:53:17 <edwardk> adnap: some times you want something that still needs an argument
23:53:21 <edwardk> i.e. when defining Functor
23:53:33 <adnap> So, State is of the kind * -> (a, *)?
23:53:42 <edwardk> class Functor (f :: * -> *) where fmap :: (a -> b) -> f a -> f b
23:53:47 <c_wraith> kinds are less specific than that.
23:53:49 <edwardk> adnap: fraid not
23:53:54 <c_wraith> @kind State
23:53:55 <adnap> Or a -> (*, a)?
23:53:56 <lambdabot> * -> * -> *
23:54:30 <adnap> @kind Functor
23:54:31 <lambdabot> Class `Functor' used as a type
23:54:53 <c_wraith> @kind Maybe
23:54:54 <edwardk> s -> (a, s) is a type. tere are kinds involved, but only with regards to the fact that since that is a type, made up of type variables and type constructors, those parts have kinds and so does the overall expression.
23:54:54 <lambdabot> * -> *
23:55:01 <c_wraith> (since Maybe is an instance of Functor)
23:55:26 <edwardk> you have (->) :: * -> * -> *, s :: *, a :: *, (,) :: * -> * -> * as the constituent parts
23:55:49 <edwardk> when you apply (->) s  you get an expression of kind * -> *
23:55:51 <adnap> "a" is a kind?!
23:56:02 <c_wraith> no, a is a concrete type, with kind *
23:56:11 <adnap> Isn't "a" the argument?
23:56:16 <c_wraith> it happens to be an unspecified concrete type.
23:56:28 <edwardk> then when you apply (a, s) you get an expression of kind *, which you can feed to the (->) s
23:56:52 <edwardk> (forall a. a) has kind *
23:57:28 <adnap> To say something has kind * makes little sense to me, since many things seem to have kind *.
23:57:39 <kmc> yes
23:57:39 <edwardk> If you have something like Foo :: * -> * -- you can make a kind * out of it, by using the forall.    (forall a. Foo a) :: *
23:57:39 <adnap> We just said Bool has kind *.
23:57:48 <Saizan> adnap: many things have type Int
23:57:48 <kmc> adnap, many things have type Int
23:57:51 <kmc> 3, 7, 29, ...
23:57:53 <kmc> haha Saizan
23:57:57 <edwardk> adnap: almost everything has kind *, except things that need more arguments
23:58:01 <Saizan> heh, jinx
23:58:10 <c_wraith> everything that has values has kind *
23:58:12 <kmc> kinds are the "types of types"
23:58:35 <kmc> just as types restrict which function applications are valid
23:58:40 <adnap> * -> * is a kind of function that takes one argument and gives a value?
23:58:41 <kmc> kinds restrict which type applications are valid
23:58:49 <Saizan> adnap: kinds are a way to classify types, just like types are a way to classify values
23:58:55 <kmc> kinds don't classify values
23:58:57 <kmc> they classify types
23:59:02 <edwardk> adnap: the kind of a _type_ level function
23:59:09 <adnap> Okay
23:59:14 <kmc> * -> * is the kind of something that takes a type and produces another type, like Maybe, or (Either Char)
23:59:16 <edwardk> that takes one more type and yields a type
23:59:24 <adnap> kmc: Oh!
23:59:54 <adnap> How do you say that * and * are the same in * -> *?  The identify kind I guess...
