00:00:25 <tomberek> soupdragon,, put brown at the corners, blue in the middle
00:00:35 <tomberek> of line segments that it
00:01:15 <jaspervdj> edwardk: cool, thanks
00:02:39 <tomberek> soupdragon.. do you see the pattern (of at least the tan and blue)  corners have tan, the midpoint of segments have blue
00:02:53 <soupdragon> yeah I se it
00:03:52 <tomberek> and the original shape is the created shape
00:04:07 <tomberek> soupdragon   so some sort of fractal rule,,
00:04:15 <ski> it seems like a map from a tiling to a new tiling of the same kind, where each tile is replaced by a cluster of new tiles, whose overall "shape" is the same as the original tile
00:04:41 <tomberek> yeah, what ski said
00:09:09 <tomberek> edwardk: did you have a chance to look at what i have so far
00:10:15 <tomberek> i have a Of f m a b -> On m f a b working.. and vice versa...
00:33:15 <soupdragon> > (2^).[1..]
00:33:16 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
00:33:24 <soupdragon> > map (3*) $ (2^).[1..]
00:33:25 <lambdabot>   [6,12,24,48,96,192,384,768,1536,3072,6144,12288,24576,49152,98304,196608,39...
00:33:25 <edwardk> tomberek: sorry been hacking on other stuff
00:33:34 <soupdragon> > map (3^2*) $ (2^).[1..]
00:33:35 <lambdabot>   [18,36,72,144,288,576,1152,2304,4608,9216,18432,36864,73728,147456,294912,5...
00:33:35 <tomberek> i know   =)
00:33:37 <edwardk> tomberek: glad to hear those are working though
00:33:59 <soupdragon> there's quite a lot of numbers below 100 which have 3 or more factors
00:34:25 <mjrosenb> soupdragon: wait, how did that first one work?
00:34:48 <soupdragon> think of [a] as a function N -> a
00:35:41 <mjrosenb> soupdragon: and this is a magical extension provided by lambdabot i assume
00:36:05 <soupdragon> not exactly magic
00:36:37 <soupdragon> technique of defining a value
00:38:34 <soupdragon> @let factors 1 = [] ; factors n = let k = fromJust (find ((==0).(n`mod`)) [2..]) in k : factors (n `div` k)
00:38:35 <lambdabot>  Defined.
00:38:38 <soupdragon> > factors 360
00:38:39 <lambdabot>   [2,2,2,3,3,5]
00:38:52 <soupdragon> > filter ((>=3) . length . factors) [2..100]
00:38:53 <lambdabot>   [8,12,16,18,20,24,27,28,30,32,36,40,42,44,45,48,50,52,54,56,60,63,64,66,68,...
00:39:00 <soupdragon> > length $ filter ((>=3) . length . factors) [2..100]
00:39:00 <lambdabot>   40
00:39:23 <tomberek> soupdragon: how long does lambdabot keep your @let 's?
00:39:41 <mjrosenb> yes, but that does not rely on [2..] being interpreted as a function
00:39:44 <soupdragon> almost half of the numbers from 1 to 100 have 3 factors
00:39:52 <copumpkin> tomberek: until someone erases them
00:39:57 <soupdragon> mjrosenb, that's just intuition
00:39:59 <tomberek> not bad
00:43:26 <soupdragon> > length $ filter ((>=3) . length . factors) [2..1000]
00:43:27 <lambdabot>   532
00:43:29 <soupdragon> > length $ filter ((>=3) . length . factors) [2..10000]
00:43:33 <lambdabot>   mueval-core: Time limit exceeded
00:43:38 <soupdragon> > length $ filter ((>=3) . length . factors) [2..500]
00:43:39 <lambdabot>   251
00:43:46 <soupdragon> so it's very close to half?
00:43:52 <soupdragon> > length $ filter ((>=3) . length . factors) [2..600]
00:43:53 <lambdabot>   304
00:43:53 <mlh> > factors -1
00:43:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
00:43:54 <lambdabot>    arising from a use of...
00:44:01 <soupdragon> I wonder how that goes asymptotically
00:44:16 <soupdragon> > length $ filter ((>=3) . length . factors) [2..3000]
00:44:18 <lambdabot>   1728
00:44:21 <soupdragon> > length $ filter ((>=3) . length . factors) [2..2000]
00:44:22 <lambdabot>   1119
00:44:26 <soupdragon> ah that's starting to diverge around 3000
00:45:00 <scree> soupdragon: won't the prime number theorem give you an assymptotic?
00:45:08 <soupdragon> oh you're right
00:45:30 <mjrosenb> well the primes are distributed as x/ln x
00:45:43 <mjrosenb> then you can get 2 factors by convoluting that with itself
00:45:55 <soupdragon> oh nice!
00:45:59 <mjrosenb> and three factors by convoluting that with the prime distribution
00:53:24 <pastorn> Cale: pm
00:54:40 * hackagebot hdaemonize 0.4.1 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.1 (FrederickRoss)
01:01:43 * hackagebot hdaemonize 0.4.2 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.2 (FrederickRoss)
01:06:39 <tibbe> Is there a way to FFI import C macros that act as functions or is there some idiom to wrap them in C functions so they can be imported?
01:14:52 <ManateeLazyCat> We have a *customize* Setup file (Gtk2HsSetup.hs) that in every gtk2hs package. And those Gtk2HsSetup.hs are *copy*, i want move to Gtk2HsSetup.hs to some library to avoid *copy*. Problem is cabal will compile/run Setup.hs before it can detect that it depend on some library.
01:15:28 <ManateeLazyCat> Is any trick to fix above problem? Thanks!
01:20:19 <tomberek> arg!
01:20:52 <ManateeLazyCat> All sleeping?
01:21:18 <zenzike> Zzzz
01:21:34 <tomberek> no.. running into brick wall, repeatedly
01:21:45 <tibbe> ManateeLazyCat: I don't know unfortunately.
01:21:54 <tibbe> ManateeLazyCat: I don't think you can achieve that via Cabal
01:22:14 <tibbe> ManateeLazyCat: perhaps if you have all the repos on the same machine you could achieve this via a symlink but that's quite brittle
01:22:36 <ManateeLazyCat> tibbe: Windows support symlink?
01:22:55 <ManateeLazyCat> tibbe: Symlink perhaps broken in non-UNIX system.
01:23:27 <tibbe> ManateeLazyCat: I don't know. It's probably not a good solution.
01:23:59 <ManateeLazyCat> tibbe: We need fix in every package once Gtk2HsSetup.hs have bug (i have did it in darcs repo), too painful.
01:24:53 <ManateeLazyCat> tibbe: It's will bring confusion if other gtk2hs-dependent package forgot update Gtk2hsSetup.hs.
01:25:13 <ManateeLazyCat> tibbe: I haven't found a neat way to fix this problem in cabal.
01:26:46 <ManateeLazyCat> Maybe i need ask this question later, wait most haskeller wake up..... :)
01:29:19 <ski> mjrosenb : `(2 ^) . [1..]' working in lambdabot is a consequence of the Caleskell definition of `(.)'
01:29:22 <ski> @type (.)
01:29:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:29:24 <ski> @src (.)
01:29:25 <lambdabot> (f . g) x = f (g x)
01:29:25 <lambdabot> NB: In lambdabot,  (.) = fmap
01:29:43 <ski> > factors 0
01:29:44 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
01:30:05 <arcatan> what's Caleskell?
01:30:22 <tomberek> hey ski, perhaps you can help
01:30:26 <ski> an inofficial set of extra definitions that lambdabot has in scope
01:30:30 <copumpkin> > 1 . 4
01:30:30 <ski> arcatan : ^
01:30:31 <lambdabot>   No instance for (GHC.Show.Show (f b))
01:30:31 <lambdabot>    arising from a use of `M9149228787...
01:30:34 <copumpkin> > 1 . 4 $ 5
01:30:35 <lambdabot>   1
01:31:07 <arcatan> okay
01:31:22 <tomberek> [(a,b)] -> [(a,c)] -> [(a,(b,c)]   what's a general way of doing this? (only relying on the zipness of [], and functorness of ((,)a)   )
01:32:23 <ski> arcatan : basically `(++) = mappend; (.) = fmap; flip fab a = ($ a) . fab' .. maybe i'm forgetting something
01:33:00 <ski> tomberek : that doesn't tell how to combine the two `a's from the two arguments
01:33:24 <ski> (iow, you want some definition of zipness for `(a,)' as well, no ?)
01:33:27 <Gracenotes> > Just [1] ++ Just [2, 3]
01:33:28 <lambdabot>   Just [1,2,3]
01:34:06 <tomberek> ski, true, um... let's assume i want to throw away the second a
01:35:32 <ski> tomberek : `zipWith (\ab0 ab1 -> fmap ((,) (snd ab1)) ab0)' ?
01:35:40 <tomberek> actually, i'd be happy with zipping that too.. hm.. i'll look at that
01:36:14 <ski> > zipWith (\ab0 ab1 -> fmap ((,) (snd ab1)) ab0) [(0,'a'),(1,'b')] [(2,'c'),(3,'d')]
01:36:14 <lambdabot>   [(0,('c','a')),(1,('d','b'))]
01:36:29 <ski> hm, flip the `(,)'
01:36:57 <ski> > zipWith (\ab0 ab1 -> fmap ((,) `flip` snd ab1) ab0) [(0,'a'),(1,'b')] [(2,'c'),(3,'d')]
01:36:58 <lambdabot>   [(0,('a','c')),(1,('b','d'))]
01:37:01 <ski> of course you could `liftM2' instead of `zipWith', if you prefer
01:37:06 <ski> > liftM2 (\ab0 ab1 -> fmap ((,) `flip` snd ab1) ab0) [(0,'a'),(1,'b')] [(2,'c'),(3,'d')]
01:37:06 <lambdabot>   [(0,('a','c')),(0,('a','d')),(1,('b','c')),(1,('b','d'))]
01:38:13 <tomberek> hm
01:38:16 <ski> (and obviously you can replace `ab1' with `(_,b)' and then `snd (_,b)' with `b' .. i just used `snd' to emphasize on "let's assume i want to throw away the second a")
01:39:09 <ski> hm, let's try combining the 'a's, instead of discarding one
01:39:11 <tomberek> true
01:41:09 <tomberek> well.. what is a isn't just a.. do you have a few minutes.. here is the instance i'm working on.. instance (Functor (m a),Zip f) => Zip (Of f m a) where
01:43:02 <tomberek> ski: perhaps we need another constraint on m  ... it's going to be (,) or a similar
01:46:12 <ski> > zipWith (liftM2 (,)) [("0",'a'),("1",'b')] [("2",'c'),("3",'d')]
01:46:13 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
01:46:13 <lambdabot>    arising from a u...
01:46:42 <ski> (which doesn't work since for some reason we have no `instance Monoid w => Monad (w,)' in scope ..)
01:46:55 <ski> > zipWith (((swap . runWriter) .) . (. Writer . swap) . liftM2 (,) . Writer . swap) [("0",'a'),("1",'b')] [("2",'c'),("3",'d')]
01:46:55 <lambdabot>   [("02",('a','c')),("13",('b','d'))]
01:46:56 <tomberek> ah, what if i make one?!
01:47:27 <ski> maybe there's one in `Control.Monad.Writer.Instances' or `Control.Monad.Class' .. not just in scope in lambdabot
01:47:30 <ski> (i'm not sure)
01:47:51 <tomberek> but if i have that, it's doable?
01:48:04 <tomberek> i'll go looking
01:48:20 <ski> (yes, as the latter above demonstrates)
01:48:40 <Heffalump> ski: is that H98?
01:49:07 <tomberek> but  `instance Monoid w => Monad (w,)   is a true (categorically) Monad?
01:49:30 <tomberek> I have ( (,) a ) as a Functor?
01:50:11 <ski> > (swap . runWriter) `map` zipWith (liftM2 (,)) ((Writer . swap) `map` [("0",'a'),("1",'b')]) ((Writer . swap) `map` [("2",'c'),("3",'d')])
01:50:12 <lambdabot>   [("02",('a','c')),("13",('b','d'))]
01:51:15 <ski> ^ that makes it clearer that the central part is just `zipWith (liftM2 (,))' .. the `Writer' and `runWriter' was just to workaround not having the `instance Monoid w => Monad (w,)' alias to `instance Monoid w => Monad (Writer w)' in scope in lambdabot
01:51:39 <ski> Heffalump : i think so, yes
01:52:05 <ski> tomberek : yes, and yes
01:52:34 <ski> > (^2) `fmap` (2,3)
01:52:34 <lambdabot>   (2,9)
01:53:30 <tomberek> ski, yes,, that last one i got
01:53:32 <ski> (Heffalump : i can think of anything non-H98 above .. apart from that `(w,)' need to be written as `(,) w' in H98)
01:53:57 <tomberek> hm.. can't find it
01:53:58 <ski> (ergh, s/i can think of/i can't think of/)
01:54:04 <Heffalump> ski: hmm, ghci tends to agree
01:54:30 <ski> @type ('a',)
01:54:31 <lambdabot> parse error on input `)'
01:55:19 <Heffalump> I can never remember what you can and can't do with tuple sections.
01:55:27 <ski> iirc, tuple sections are allowed with an extension in late GHC .. imo it should be allowed for tuple types as well (when partially applied to a contiguous segment of arguments including the first one, i.e.)
01:56:26 <Heffalump> well, it does seem to be
01:56:28 <Nereid> -XTupleSections
01:56:29 <Nereid> and yeah
01:58:15 <Nereid> I wonder if there should be some convenient syntax that generalizes fst and snd
01:58:21 <Nereid> maybe call them "tuple retractions" ;-)
01:58:53 <tomberek> Nereid.. i've been looking... but I'm working on an variant of that
02:02:16 <tomberek> Nereid: interested?
02:02:19 <Nereid> sort of
02:02:32 <Nereid> like how would you write fst and snd?
02:03:12 <tomberek> check out what i have here (this is the ugly version, but it has workable examples)
02:03:20 <tomberek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
02:04:36 <Nereid> hmm
02:04:43 <Nereid> not quite what I was asking about
02:05:25 <tomberek> Nereid.. the class Product?
02:05:33 <Nereid> I was talking about some special syntax.
02:05:38 <Nereid> like tuple sections.
02:05:40 <Nereid> but the other way around
02:05:51 <tomberek> oh, i don't have syntax
02:05:53 <tomberek> nvm
02:05:55 <Nereid> heh
02:05:55 <tomberek> sorry
02:06:07 <ski> SML has those as `#1',`#2',`#3',&c.
02:06:21 <Nereid> yeah but then what's the type of #1? etc
02:06:27 <ski> (but then you have to provide enough type information so that the overloading can disambiguate)
02:06:32 <Nereid> heh
02:06:39 <tomberek> ski, the 'losing information' version.. can't that be implemented with a (flip const) or something?
02:06:53 <ski> with light-weight tuples, you'd not need that
02:07:22 <ski> tomberek : hm, i think so, if you use a `bimap' instead of the `fmap'
02:08:02 <tomberek> ya... m is bimappable if you recall.. perhaps i should add that Bifunctor m Hask Hask Hask?
02:09:05 <Nereid> I still think the name "tuple retractions" is clever :o
02:09:06 <copumpkin> oh no
02:10:03 * ski just simplified `bimap (flip const) f x y' into `fmap (\x -> f x (snd y)) x' without thinking much about it ..
02:10:27 <ski> Nereid : do they satisfy a `r . s = id'-type identity ?
02:10:33 <Nereid> yes, ski
02:10:44 <Nereid> for example, fst . (,x) = id
02:10:44 <Nereid> for any x
02:10:55 <tomberek> ski: i shall work on it,, thanks
02:11:07 <copumpkin> @free fst :: (a, b) -> a
02:11:08 <lambdabot> f . fst = fst . $map_Pair f g
02:12:07 <ski> > (,x)^-1 ('a',0)
02:12:08 <lambdabot>   <no location info>: parse error on input `x'
02:13:14 <Nereid> lol
02:13:35 <Nereid> what about like
02:13:38 <Nereid> use ' instead of ^-1
02:13:40 <Nereid> and _ instead of x
02:13:42 <Nereid> so you get (,_)'
02:13:46 <ski> > (('a',0) -> (,_))  -- ideally, this would be a consistent syntax, yes ?
02:13:46 <Nereid> hmm
02:13:46 <lambdabot>   <no location info>: parse error on input `_'
02:14:03 <Nereid> ' might break things though
02:14:03 <ski> (using the syntax for view patterns in an expression, i.e.)
02:14:25 <ski> Nereid : that will definitely break things :)
02:14:28 <Nereid> well
02:14:39 <Nereid> what if we want to extract multiple components
02:14:45 <ski> (in the sense of having to rename things)
02:14:57 <Nereid> :: (a, b, c) -> (a, b)
02:14:58 <Nereid> for instance
02:15:12 <Nereid> (,,_)'
02:15:47 <ski> actually, the above should have been
02:15:58 <ski> > ((,_) -> ('a',0))
02:15:59 <lambdabot>   <no location info>: parse error on input `_'
02:16:03 <ski> now that i think about it
02:16:15 <Nereid> what do you mean by that?
02:16:29 <ski> i mean that if you do
02:16:32 <copumpkin> @djinn (a, b, c) -> (a, b)
02:16:32 <lambdabot> f (a, b, _) = (a, b)
02:16:39 * copumpkin hugs djinn
02:16:49 <ski>   f ((,foo) -> p) = p
02:17:21 <ski> then `p' is constructed from the input by putting it in the first part of a pair, with second part being `foo'
02:17:34 <ski> but this is using `... -> ...' as a *pattern*
02:17:41 <Nereid> heh
02:17:45 <ski> conversely, using it as an expression, like in
02:18:20 <ski>   let p = ...; x = ((,_) -> p) in ..x..
02:18:37 <Nereid> I don't understand.
02:18:52 <ski> ought to deconstruct `p' as a pair, binding `x' to the first part (and matching the second part by `_', which always succeed)
02:19:07 <dolio> "f ((,_) -> p) = ..." isn't valid, though.
02:19:21 <Nereid> that sure is a long way to write fst.
02:19:36 <ski> dolio : well, with `TupleSections' it is, if you replace `_' by a valid expression
02:20:04 <ski> (i had to replace it with a pattern in the "dual" context .. and `_' seemed most appropriate)
02:20:07 <Nereid> the notation looks awfully confusing.
02:20:46 <ski> we could say that the notation `(,False) -> e' desugars to `case e of (x,False) -> x', as well, so that other patterns are allowed in the place of `_'
02:21:20 <ski> Nereid : you could say that .. but i also think the notation `e -> p' for view patterns looks confusing :)
02:21:52 <Nereid> well my point was a convenient way to write functions that extract components from tuples
02:22:02 <ski> (but there was a minimum of creativity in deriving `p -> e' as a "view" expression form .. i just followed the "signs")
02:22:04 <Nereid> just like TupleSections gives a convenient way to write functions that fill in components of tuples.
02:23:01 <ski> with this notation, we could write `(Cons _) -> e' to extract the second argument of `Cons' having matched it with `w'
02:23:04 <ski> s/w/e/
02:23:20 <Nereid> you're talking about patterns
02:23:24 <Nereid> I'm not. :c
02:23:37 <ski> i'm talking *both* about patterns and expressions
02:23:40 <ski> that's the point
02:23:42 <Nereid> I'm talking about functions.
02:23:45 <Nereid> like
02:23:57 <ski> you're talking about an expression of type `(a,b) -> a'
02:24:11 <Nereid> well, a function of that type.
02:24:26 <ski> i'm explaining one way of deriving such, by "following the patterns" and dualize
02:24:30 <Nereid> just like how (,x) is a function of type a -> (a, type of x)
02:25:07 <ski> (and i don't really think `((,_) ->)' would be that complicated notation for a function that extracts the first component of a pair)
02:25:23 <Nereid> it's long :p
02:25:42 <ski> two characters more than your suggestion
02:25:45 <Nereid> and what about multiple components?
02:25:53 <Nereid> my suggestion was (,_)'
02:26:01 <Nereid> I count 3 :P
02:26:10 <ski> (i don't count the outer brackets, since you'd in most cases you'd have to bracket anyway)
02:26:20 <Nereid> not counting spaces
02:26:21 <Nereid> but anyway
02:26:41 <ski> (sorry, i was counting spaces .. one more character, then :)
02:26:54 <Nereid> well the point of something like (,x) isn't so you can write stiff like (,x) a
02:27:04 <ski> yes
02:27:07 <Nereid> it's so you can pass (,x) to some higher-order function.
02:27:11 <ski>   map (,x)' blah
02:27:16 <ski> compares to
02:27:17 <Nereid> yeah
02:27:22 <ski> but
02:27:37 <ski> that's (probably) not correct, syntax-wise
02:27:39 <ski> so that becomes
02:27:44 <ski>   map ((,x)') blah
02:27:56 <Nereid> well it doesn't have to be '
02:27:59 <ski> (since "application binds tighter than anything"(*))
02:28:05 <ski> ((*) almost anything)
02:28:17 <ski> now compare that with
02:28:22 <ski>   map ((,x)->) blah
02:28:28 <ski> not that big difference, imo
02:28:30 <Nereid> which I argue is ugly
02:28:42 <ski> i'll not disagree with that :)
02:28:55 <Nereid> well, use some other symbol than '
02:28:56 <Nereid> but
02:28:59 <Nereid> ok, maybe ~
02:29:00 <ski> (blame the inventers of the notation for view patterns)
02:29:11 <Nereid> that might work
02:29:23 <Nereid> (,_)~ :: (a, b) -> a
02:29:46 <Nereid> and the (stuff)~ is just syntax, so
02:29:56 <Nereid> you could write someting like map (,_)~ blah
02:30:01 <ski> syntactically, it's a post-fix operator
02:30:05 <Nereid> no
02:30:11 <ski> yes
02:30:12 <Nereid> (what is it operating on?)
02:30:21 <ski> on `(,_)'
02:30:27 <dolio> No, it can't be a postfix operator, because (,_) is not an expression.
02:30:28 <Nereid> which isn't valid
02:30:31 <Nereid> exactly
02:30:37 <ski> dolio : note the "syntactically" :)
02:30:39 <Nereid> it's just special syntax.
02:30:55 <ski> just as syntactically `=' is an infix operator (and `::' and `=>' too, for that matter)
02:31:19 <Nereid> from the point of view of the parser, (...)~ is atomic
02:31:52 <ski> it is special syntax, that is an operator (converting between different syntactical classes/categories)
02:32:06 <ski> Nereid : i don't agree with that, the `...' there is not atomic
02:32:13 <Nereid> I mean aside from the ...
02:32:46 <ski> then you could just as well claim that `... + ...' is atomic (modulo the two `...'s)
02:32:55 <Nereid> but I mean
02:32:59 <Nereid> the ~ is inseparable from the parentheses
02:33:03 <Nereid> as if it were a new kind of parentheses
02:33:31 <ski> i don't like this new concrete syntax complication :)
02:33:57 <Nereid> no more complicated than (,_) ->
02:34:36 <ski> (but yes, you could do that, cf. Prolog. but you could just as well explain it in terms of "syntactic operators" (another such one being the application operator))
02:34:54 <Nereid> but I'm arguing that ( ) and ( )~ are totally different
02:35:09 <Nereid> and it's a rather pointless argument so let's stop
02:35:15 <ski> ty :)
02:35:30 <ski> <Nereid> and what about multiple components?
02:35:40 <Nereid> I'm just saying, one could write (,_)~ for fst, and (,,_,) :: (a, b, c, d) -> (a, b, d) or something.
02:35:43 <Nereid> er (,,_,)~
02:36:11 * hackagebot redis 0.7 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.7 (AlexanderBogdanov)
02:36:37 <ski> i suppose this multiple components issue would work with my proposal as well, as long as the corresponding thing works with tuple sections
02:36:41 <dolio> (,_) isn't a pattern, either, apparently.
02:37:08 <Nereid> the point being that (,,_,)~ is a left inverse to (,,x,) for any x
02:37:24 <ski> dolio : probably for the same reasons that you can't have `(_:)' or `(:_)' (say) as patterns
02:37:29 <Nereid> (hence "tuple retractions")
02:37:35 <dolio> Yeah, I suppose.
02:38:06 <Nereid> (also noting that tuple sections are, in fact, sections in the math sense)
02:38:14 <dolio> That looks dangerously like higher-order matching.
02:38:16 <ski> Nereid : yes, i think it might be a good idea to add this, possibly under the name "tuple retractions"
02:38:49 <dolio> Although it may not be hard to eliminate bad uses.
02:38:54 <ski> (Nereid : i'm just thinking it might be nicer if we could fit this into a slightly more general extension, thus borrowing ideas from view patterns)
02:39:06 <Nereid> yeah
02:39:32 <ski> dolio : that might be an issue .. hm
02:39:42 <Nereid> but we don't have any general syntax for filling in function arguments and such either, unlike for tuples
02:39:58 <Nereid> specifically constructor arguments I guess
02:40:04 <ski> Nereid : i don't think i'd like one
02:40:33 <Nereid> because you're suggesting there be a way for extractiong constructor arguments, right?
02:40:36 <dolio> I mean, obviously only '(,_) x' and the like makes sense as a pattern. '(,_)' by itself can't possibly be.
02:40:38 <Nereid> extracting.
02:40:55 <ski> tuples are special syntax, while constructor applications are (syntactically) just (iterated) applications of a constructor identifier
02:41:10 <dolio> Just like 'C x' isn't a pattern for a 2-ary C.
02:41:12 <Nereid> right
02:41:47 <Nereid> it's almost 4am.
02:41:48 <Nereid> I better go
02:42:00 <ski> Nereid : with my (or your, i suppose) syntax, one could write `(Cons _ -> e)' to match out the second argument to `Cons' from `e'
02:42:28 <ski> but one couldn't (imnsho) match out the first argument to `Cons' from `e' using this syntax
02:42:31 <Nereid> it's unclear that Cons is a two-argument constructor from that
02:42:34 <Nereid> so
02:42:40 <Nereid> and that too
02:42:52 <Nereid> I was just talking about something specific to tuples.
02:42:54 <dolio> Why not?
02:43:04 <Nereid> dolio: who?
02:43:04 <dolio> ((`Cons` _) -> e)
02:43:08 <ski> the use of `... -> e' as an expression would ensure that `...' must be a pattern "function" (of exactly one argument)
02:43:11 <Nereid> heh
02:43:23 <Nereid> dolio: what if it had more than 2 arguments then?
02:43:37 <dolio> Then you're screwed.
02:43:39 <Nereid> right
02:43:56 <Nereid> anyway, we don't have anything like constructor sections, other than for unary/binary constructors
02:43:56 <ski> dolio : yes, infix constructors would work (but that's another case than what i, syntactically, were treating above)
02:44:30 <Nereid> well, good night
02:44:34 <ski> (tuples, applications, infix applications being three disjoint cases)
02:44:40 <ski> Nereid : good night
02:45:19 <Botje> who is responsible for planet haskell?
02:45:48 <Botje> it's rather silly that all posts point to the planet website instead of the author's website :(
02:45:51 <ski> (the people whose blogs are aggregated on it (are propably responsible for the content) ?)
02:46:22 <Botje> i don't mind the content – in fact i like it :)
02:47:19 <dolio> I could use somewhat less random, non-vaguely-Haskell-related stuff occasionally.
02:47:27 <ski> dolio : i suppose one useful extension of the above would be to allow something like `((Cons _ . (,_)) -> e)' .. however, this would rely on having a standard `(.)' in scope, otherwise it might be confusing :(
02:47:57 <Starfire> Botje: I seem to remember that some posts link properly to the author's site.
02:48:04 <dolio> ski: I think that looks like madness.
02:48:22 * ski grins like a lunatic
02:48:31 <dolio> To find out what that does, I'd have to figure out where the hole in the composite function is.
02:48:32 <Botje> Starfire: yeah, but i can't access it from my rss reader
02:48:46 <Botje> have to go to the site first and then click on the author :/
02:48:49 <Botje> anyway, foodtime! :)
02:48:58 <ski> dolio : ah, but that's obvious : it desugars to `case e of Cons _ (x,_) -> x'
02:49:38 <dolio> Well, why not add some flips and whatnot, too?
02:49:47 <dolio> Then you don't have to worry about n-ary constructors anymore.
02:50:20 <ski> well, i'd say that would look more like madness, then ;)
02:50:22 <dolio> (flip . (flip Tri) . (,_)) -> e or something
02:51:00 <ski> (i suppose one basic problem is that we don't have a syntactic class for functions .. so that `\' would wrap a function into a function expression)
03:30:34 <Blkt> could anyone give me a hint about how to make a program wait in Haskell?
03:31:33 <mreh> Blkt: what is it that you are doing?
03:31:59 <Blkt> printing on screen the evolution of a territorial system game
03:32:11 <Blkt> I don't want it to print the generations too quickly
03:32:56 <Blkt> I need a wait statement in my main game loop
03:33:08 <mreh> see concurrent-extra-0.5.1
03:33:26 <Blkt> thanks
03:33:50 <mreh> just tread it like a single threaded concurrent program
03:34:14 <mreh> esp. as it doesn't take too long to display
03:40:39 <kmc> Blkt, threadDelay from Control.Concurrent
03:44:53 <Blkt> kmc: I found it, it works perfectly, thanks
03:45:19 <Blkt> am I the only one having problems with Hayoo?
04:05:23 * hackagebot arbtt 0.6 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.6 (JoachimBreitner)
04:05:56 <alip> i'm writing a tool that prints out some strings, i want the user to be able to configure this using basic templates. which library would you recommend? (I've found Text.Template on hackage, it's a bit too simple, just allows ${var} substitution and i wonder if there are more sophisticated libraries exist)
04:12:04 <osfameron> ooo, arbtt looks interesting
04:12:16 * osfameron wonders how difficult it would be to bind that to osx
04:14:53 <jd10> http://flyingfrogblog.blogspot.com/2010/05/why-is-haskell-used-so-little-in.html
04:19:01 <Heffalump> jd10: what's your point?
04:20:47 <zachk> jd10: ok so you dont like haskell :(
04:21:27 * osfameron thought it was an interesting article :-)
04:21:47 <jd10> i think: geez what a rant
04:21:52 <osfameron> though I'm aware Jon Harrop is... controversial :-)
04:22:23 <jd10> and haskell<3
04:22:51 <jd10> it would be nice, though, to hear #haskell's opinion on that post
04:23:12 <osfameron> you can probably read #haskell's opinion in the comments to the post :-)
04:23:15 <zachk> it seemed like that guy really doesnt like haskell and hates don stewart
04:24:01 <osfameron> I thought the suggestions that the Haskell-in-Industry page's claims were overstated was interesting (is he just throwing mud, or is there any truth in that?)
04:25:01 <Heffalump> well, it's a typical wiki page
04:25:11 <Heffalump> gets anything thrown in there and doesn't really get gardened properly
04:25:37 <Heffalump> I doubt anyone has deliberately faked entries
04:27:41 <Twey> zachk, jd10: Jon Harrop makes good money from publically disliking Haskell.  ☺
04:28:26 <Heffalump> I doubt that, actually; there's some overlap between F# and Haskell communities and thus a significant number of F# people actively disrecommending his stuff
04:28:45 <zachk> Twey: how does he generate revenue from that?
04:29:00 <int-e> Twey: the community should pay him for advancing our avoidance of success.
04:29:09 <zachk> oh he is F#? i looked at getting into F# but they wanted me to pay for things, im a broke college student
04:29:10 <tab> zachk: deceptively selling books for other languages
04:29:21 <Twey> zachk: He sells F# books and consulting.
04:29:36 <wli> Except nobody's buying.
04:29:40 <Twey> Yeah.
04:30:06 <Twey> Well… he seems to have sufficient revenue to be able to spend his days bashing Haskell on mailing lists, so it must be working at least somewhat.
04:30:07 <Heffalump> he claims people are buying, but it's hard to tell whether he's telling the truth or not
04:30:42 <wli> Twey: That's the day job doing something else.
04:31:07 <eevar2> i'm sure he would have sold a lot better with sane prices
04:34:16 <Twey> Heffalump: How much is Haskell *really* used at Suisse nowadays?
04:35:44 <Heffalump> not very much, mostly F# now
04:36:49 <jd10> Heffalump: any clue why?
04:37:13 <Heffalump> .NET, basically
04:37:26 <Twey> Is the DotNET library not sufficient?
04:37:44 <Heffalump> not really, no
04:37:53 <Heffalump> native .NET stuff is far preferable in that environment
04:38:36 <Twey> Aha
04:47:51 * hackagebot async 1.2 - Asynchronous Computations  http://hackage.haskell.org/package/async-1.2 (PeterSimons)
04:50:18 <mreh> skepticism is a weapon
04:50:37 <mreh> what does Harrop have to gain from Haskell's demise
04:50:50 <quicksilver> he doesn't care if haskell succeeds or fails
04:50:59 <quicksilver> he cares that people visit his blog, read his words, and buy his stuff
04:51:11 <quicksilver> it's just trolling
04:51:12 <mreh> so he's a sensationalist
04:51:24 <quicksilver> he will write whatever he thinks will get the best reaction
04:51:40 <quicksilver> under a veneer of apparently rational debate
04:52:11 <mreh> people still seem to be feeding him
04:52:16 <quicksilver> yup.
04:52:20 <quicksilver> he's very, very good.
04:52:33 <mreh> lets write an encyclopedia dramatica article
04:52:38 <mreh> :D
04:52:59 <Twey> I'm confused by -package and -hide-package.  I have a simple file, say ‘main = putStrLn "hi"’, and if I runhaskell /tmp/foo, it runs; however, if I runhaskell -hide-package mtl /tmp/foo, it dies with an error ‘Not in scope: `main'’
04:53:57 <quicksilver> I agree. That's confusing.
04:54:24 <quicksilver> perhaps it's an unintended consequence of the way runhaskell passes arguments to ghc?
04:55:36 <mreh> I don't like to say "don't engage in debates" because that's rather like shutting out someone, but if he's using up so much of everyone's time...
04:55:44 <Twey> Ooh… if I place the -hide-package *after* the module (contrary to --help) it works
04:55:50 <Twey> Oh… but it also doesn't hide the package.  Heh.
04:56:16 <byorgey> so, for small values of "works"
04:56:22 <Twey> Right :þ
04:56:48 <Twey> Works with my silly example code, but not for the code in which I actually need the package hidden.  ;)
04:59:33 <Twey> I guess if placed after the file it gets interpreted as a program argument.
04:59:34 <quicksilver> Twey: I think maybe your problem is with runhaskell, not with your understanding of -hide-package; Im' not sure
04:59:47 <Twey> Hm.
05:02:59 * mreh is eagerly waiting OCaml for housewives and clergy
05:07:05 <hants> hi - im trying to write a dsel which mimics haskells behaviour so i can compile "haskell"-expressions
05:07:33 <hants> using an algebraic datatype and overloading num - it works for arithmetic expressions very well
05:07:56 <zygoloid> Twey: according to strace, it's running: ghc -B<...> -ignore-dot-ghci -hide-package -e ":set prog \"mtl\"" -e ":main [\"tmp.hs\"]" mtl
05:08:09 <hants> but how do i "overload" *if then else* - so it can be translated into my own ast - expressions?
05:08:12 <zygoloid> Twey: so it looks like runhaskell is doing something weird with the given arguments
05:08:23 <quicksilver> but you can't overload function application, so you can't embed that, right, hants? ;)
05:08:37 <benmachine> maybe try "-hide-package mtl" in quotes?
05:08:44 <byorgey> hants: you can't.  but see the AwesomePrelude.
05:09:02 <hants> quicksilver, using something like hoas gives me function application
05:09:25 <quicksilver> yup.
05:09:29 <kmc> you can't overload if/then/else
05:09:34 <kmc> it's stupid special syntax
05:09:53 <hants> is there a trick like hoas to convert it to an ast?
05:10:05 * hackagebot probability 0.2.2.1 - Probabilistic Functional Programming  http://hackage.haskell.org/package/probability-0.2.2.1 (HenningThielemann)
05:10:15 <kmc> if you really want to grab Haskell AST inline, you can use a quasiquoter with haskell-src-exts
05:10:28 <zygoloid> benmachine: hmm, that seems to work here :)
05:10:54 <hants> but then its not pure haskell syntax anymore - and one has to quote ones functions
05:12:06 <hants> but somehow i like the quoting idea more ;)
05:12:42 <zygoloid> hants: it sounds like template haskell would be quite well-suited to your needs
05:14:29 <hants> are there examples on the web which demonstrate how to get an ast with template haskell - or haskell-src-exts?
05:16:07 <zygoloid> hants: with template haskell, just use [| some expression |] to get an AST (in the Q monad)
05:16:14 <Gracenotes> recursive monoid instances++
05:20:35 <hants> zygoloid, which modules do i need to import for [| and |] to be working?
05:22:07 <kmc> that's not a matter of modules
05:22:12 <kmc> you need to turn on the TemplateHaskell extension
05:22:47 <hants> aah
05:22:52 <hants> thx!
05:22:58 <kmc> then [| ... |] :: Q Exp
05:22:59 <hants> so its non-standard
05:23:07 <kmc> to get Q and Exp into scope, you need to import Language.Haskell.TH
05:23:11 <kmc> yes, very non-standard
05:23:24 <kmc> haskell-src-exts however is an ordinary library
05:23:28 <kmc> and you can pass in ordinary strings
05:23:40 <kmc> or use GHC's quasiquoting feature
05:24:00 <hants> haskell-src-exts takes strings - so there is no type checking at compile time?
05:24:52 <kmc> correct
05:24:58 <kmc> it is just a haskell parser as a library
05:25:21 <hants> okay thx
05:25:25 <kmc> it doesn't include a Haskell type-checker as a library
05:25:42 <kmc> you could get that from GHC API if you are willing to go very deep down the rabbit hole
05:25:45 <kmc> bbl
05:25:59 <hants> hmmm
05:36:07 <quicksilver> you need TH to do parsing and type checkign at compile time.
05:36:30 <quicksilver> or quasi quoting which is a convenient interface to some functionality of TH
05:36:49 <quicksilver> I shudder to think what the errors look like when your dsel has a type error tho
05:38:40 <MacMagnus> is the Integer type suitable for search for great prime numbers?
05:39:18 <byorgey> MacMagnus: sure.
05:39:36 <MacMagnus> :)
05:41:27 <MacMagnus> i would like to implement a program that tests if a number is a great mersenne prime number
05:46:13 <hants1> thx, quicksilver! :)
05:47:17 <Gracenotes> isMersennePrime :: Int -> Bool; isMersennePrime _ = False
05:47:31 * hackagebot twidge 1.0.2 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.0.2 (JohnGoerzen)
05:47:58 <Gracenotes> returns correct results for approximately 0.0000000018% of the domain
05:48:08 <Gracenotes> I mean, incorrect results. pretty good rate.
05:49:36 <Gracenotes> there are two conditions: if it's one less than a power of two, and if it's prime. there are algorithms for both.. but there are probably shortcuts
05:49:43 <Gracenotes> undoubtedly
05:51:38 <MacMagnus> hm :) i would like to implement the lucas-lehmer test though...
05:53:39 <Cartitza> anyone knows how I can change TTL on a router?
05:56:14 <Gracenotes> MacMagnus: makes sense. well, wikipedia has psuedocode
05:57:41 <Gracenotes> and a recursive definition works well
06:02:15 <MacMagnus> Gracenotes: yes :) Im thinking about storing the prlininary results as ByteStrings
06:04:51 <IRCSTINKS> is there analog of foldl without starting value?
06:05:15 <Cale> foldl1
06:05:28 <Cale> But note that it fails when applied to an empty list
06:16:09 <IRCSTINKS> if i read from stdin, how to fetch all remaining lines?
06:16:59 <Botje> getContents
06:17:07 <Botje> or, if you prefer, lines `liftM` getContents
06:17:24 <IRCSTINKS> thanks
06:22:53 <IRCSTINKS> how strange
06:23:20 <Botje> what do you mean?
06:28:36 <IRCSTINKS> that's difficult :(
06:30:18 <Botje> what, explaining what you mean?
06:30:36 <IRCSTINKS> i can't get "lines `liftM` getContents" working
06:31:07 <Botje> what error do you get and how are you using it?
06:31:34 <Ke> code.haskell.org is down again
06:32:45 <Axman6> IRCSTINKS: we can't help you unles we know what the problem is. showing us your code would be a great start
06:34:00 <IRCSTINKS> http://codepad.org/TyNWVb8P, but i seem to have fixed it
06:35:58 <byorgey> IRCSTINKS: you have to  'import Control.Monad'
06:36:03 <byorgey> but maybe you already figured that out
06:36:51 <IRCSTINKS> where is fold1 defined?
06:36:59 <hpc> Prelude
06:37:02 <hpc> @src foldl
06:37:02 <lambdabot> foldl f z []     = z
06:37:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:37:06 <blackh> foldl, not fold1
06:37:06 <benmachine> er
06:37:16 <byorgey> IRCSTINKS: foldl1 is defined in Data.List, if that's what you meant
06:37:55 <IRCSTINKS> i can't access it in ghci
06:38:24 <IRCSTINKS> @src fold1
06:38:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:38:40 <djahandarie> IRCSTINKS, foldl1, not fold1
06:40:23 <hpc> @src foldl1
06:40:23 <lambdabot> foldl1 f (x:xs) = foldl f x xs
06:40:24 <lambdabot> foldl1 _ []     = undefined
06:42:13 <IRCSTINKS> how to check whether all elems of list are identical?
06:42:37 <Twey> IRCSTINKS: list1 == list2
06:42:41 <Twey> > foldl f z [a, b, c, d]
06:42:42 <lambdabot>   f (f (f (f z a) b) c) d
06:42:47 <Twey> > foldr f z [a, b, c, d]
06:42:48 <lambdabot>   f a (f b (f c (f d z)))
06:43:25 <IRCSTINKS> not that.
06:43:53 <IRCSTINKS> i mean, maybe these funcs are already present: http://codepad.org/JDDoHEos
06:44:40 <benmachine> ah right
06:45:10 <Twey> I don't believe so, but there are better ways to write them
06:45:24 <IRCSTINKS> for example
06:45:27 <benmachine> okh [] = True; okh (x:xs) = all (== x) xs
06:45:39 <Twey> That, to start with
06:45:50 <benmachine> to start with? :P
06:46:02 <Twey> I feel it should be possible to integrate the [] case somehow
06:46:06 <benmachine> heh
06:46:15 <byorgey> length (nub xs) <= 1
06:46:22 <byorgey> not the most efficient, but it's shorter =)
06:46:34 <Twey> Hmm
06:46:50 <Twey> :t group
06:46:51 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
06:47:04 <benmachine> :t null . drop 1 . nub
06:47:05 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:47:10 <Twey> That's the one
06:47:14 <Twey> Or group
06:47:14 <byorgey> ah, nice
06:47:19 <benmachine> or group, indeed
06:47:20 <aristid> :t drop
06:47:21 <lambdabot> forall a. Int -> [a] -> [a]
06:47:22 <Twey> :t null . drop 1 . group
06:47:22 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:47:25 <Twey> That should give better complexity
06:47:27 <benmachine> group might even be faster, I'm not sure
06:47:30 <byorgey> group? you mean group . sort ?
06:47:32 <Twey> No
06:47:34 <Twey> Just group
06:47:40 <byorgey> oh, right, never mind =)
06:47:43 <benmachine> heh
06:47:44 <Twey> If they're all the same, what's the point in sorting them?
06:47:44 <aristid> benmachine: null . drop 1 to test whether there is at least one element?
06:47:51 <byorgey> aristid: right
06:47:51 <Twey> Hence the preference of group over nub
06:48:10 <aristid> is there a more elegant way to do that?
06:48:11 <Twey> IRCSTINKS: So yeah, to conclude, okh = null . drop 1 . group
06:48:16 <aristid> calling length is obviously stupid
06:48:27 <Twey> aristid: There's a lazy length in list-extras
06:48:31 <benmachine> aristid: genericLength with lazy Peanos
06:48:38 <aristid> lazy peanos oO
06:48:39 <benmachine> is another option
06:48:39 <Twey> Yeah
06:48:48 <Twey> Or wait for supercompilation ;)
06:48:56 <IRCSTINKS> it this right as i understand we can't write: ..... okh (x:y:xs) = x/=y && length xs>0 && okh(y:xs) ?
06:49:12 <benmachine> IRCSTINKS: you can do that but what's the point?
06:49:21 <Twey> You can write it… I wouldn't, personally…
06:49:21 <IRCSTINKS> it's shorter
06:49:34 <Twey> IRCSTINKS: okh = null . drop 1 . group
06:49:43 <Twey> Nicer, shorter, and much faster
06:50:07 <benmachine> IRCSTINKS: oh, it doesn't do what you want though
06:50:16 <benmachine> IRCSTINKS: if that's the only equation, it won't work on an empty list
06:50:37 <IRCSTINKS> well, i don't need inputs < 2
06:51:01 <Twey> IRCSTINKS: Also, if x then False else y = not x && y
06:51:24 <aristid> @pl if' x y = not x && y
06:51:24 <lambdabot> if' = (&&) . not
06:51:50 <aristid> Twey: man why didn't you say this yesterday when we struggled to find a concise point-free if-then-else?
06:51:50 <benmachine> yeah you'd want okh (x:y:xs) = x == y && (null xs || okh (y:xs))
06:51:57 <Twey> aristid: ?
06:52:08 <benmachine> aristid: because if' only exists in lambdabot's head :P
06:52:13 <Saizan> aristid: see the False.
06:52:14 <Twey> aristid: (y ?? n) p = if p then y else n
06:52:18 <Twey> Is a better function
06:52:20 <aristid> Saizan: i was blind :D
06:52:25 <Twey> But yeah, the identity I gave only applies with a constant False
06:52:48 <Twey> Same with || and no ‘not’ if it's True
06:53:22 <aristid> Twey: yeah
06:53:28 <benmachine> IRCSTINKS: if you want to check if a list is not zero-length, use "not (null xs)" rather than "length xs > 0", it's more efficient
06:53:41 <aristid> it's a bit of a shame that if-then-else is syntax and no function
06:53:51 <benmachine> aristid: so many people have said
06:53:55 <benmachine> other people like the clarity
06:54:07 <aristid> benmachine: well, in agda, it is both syntax and a function
06:54:20 <benmachine> aristid: rly? what's the function called?
06:54:21 <aristid> if_then_else_ is the function and it can be used like in haskell
06:54:31 * byorgey never uses if-then-else
06:54:31 <Twey> benmachine: More than ‘more efficient’, it terminates in places where the other needn't
06:54:34 <aristid> i guess it's mixfix or so
06:54:54 <byorgey> yeah, Agda's mixfix operators are neat
06:55:09 <Twey> I quite like that ‘if’ being syntax often allows me to save brackets
06:55:12 <benmachine> Twey: infinitely more efficient in some cases :P
06:55:14 <Twey> But I want (??) too
06:55:53 <aristid> Twey: mixfix operators would solve that:)
06:56:09 <Twey> Yeah, but at the cost of huge complexity
06:56:15 <benmachine> how do you assign precedence to mixfix operators?
06:56:15 <aristid> but i guess adding a (??) to the Prelude would be easier
06:56:37 <Twey> Frankly, I'm not entirely convinced that the move away from s-expressions is worth the resulting complexity
06:57:03 <aristid> Twey: s-expressions? do you want a haskell with lisp syntax? :P
06:57:25 * fryguybob likes the way haskell reads.
06:57:48 <aristid> fryguybob: i think it definitely is good for marketing haskell
06:57:57 <aristid> "it doesn't look like lisp" :P
06:58:34 <fryguybob> One instance that I really like is the ability to make biased operators look biased.
06:58:46 <hpc> aristid: unfortunately true
06:58:47 <geheimdienst> english is to lolcat-talk as haskell is to lisp
06:59:46 <Twey> aristid: I wouldn't mind one
06:59:50 <IRCSTINKS> in haskell wiki, ""Int" is the more common 32 or 64 bit integer. Implementations vary, although it is guaranteed to be at least 29 bits."
06:59:52 <djahandarie> That's a pretty terrible analogy.
06:59:52 <Twey> It would make TH less of a nightmare
06:59:59 <IRCSTINKS> i understand 29 bits + 1 sign bit makes = 30 bits
07:00:02 <IRCSTINKS> correct?
07:00:11 <Twey> fryguybob: I do, too, but not so much that I'd choose to sacrifice the simplicity of s-exprs for it.
07:00:27 <Twey> IRCSTINKS: Yes?
07:00:30 <hpc> 29 bits includes the sign, iirc
07:00:35 <Twey> Yeah
07:00:40 <zakwilson> I can haz conz cell?
07:01:58 <benmachine> I think TH is still young
07:02:04 <benmachine> it might well become less nightmarish by itself
07:02:08 <quicksilver> IRCSTINKS: the 29 there includes the sign, which is very unlikely to be a sign bit. It will be twos complement on all probable systems. Anyway 29 is the lower bound and in practice it is 32 or 64.
07:02:09 <fryguybob> Twey: If I spent enough time with Scheme I would probably be ok with it, but I think Haskell mirrors much of math and I have already spend a lot of time with that.
07:03:02 <benmachine> Twey: I basically learnt haskell because you said it was better than lisp :P
07:03:02 <Twey> benmachine: Maybe
07:03:13 <Twey> It's better than current Lisps
07:03:33 <Twey> But it sacrifices some good things, too, IMO
07:04:02 <benmachine> oh, everything always does
07:04:05 <Twey> Yeah
07:04:33 <benmachine> I wonder if you could make a syntax-agnostic language >_>
07:04:35 <fryguybob> Twey: Lispkell, haskell ast in s-expressions?
07:04:46 <Twey> Liskell exists… kind of…
07:04:59 <Twey> benmachine: Lisps are syntax-agnostic
07:05:23 <benmachine> hmm
07:05:26 <benmachine> hmmmm
07:05:32 * fryguybob likes a little bit of sugar in his coffee.
07:05:40 * benmachine wonders if it is time to learn a new language yet
07:05:46 <Twey> That's one of the advantages: you can represent them in anything that's capable of being unambiguously transformed to a tree
07:05:47 <wli> They're not syntax-agnostic. They insist you hammer in AST dumps.
07:05:50 <benmachine> fryguybob: metaphorically agreed
07:06:11 <fryguybob> fryguybob: but not too much.
07:06:18 <Twey> wli: Not necessarily — you can have things like M-expressions on top
07:06:56 <benmachine> benmachine: why are you talking to yourself
07:07:03 <IRCSTINKS> how to do integer divide (rounding towards zero)?
07:07:11 <fryguybob> :D
07:07:12 <benmachine> IRCSTINKS: quot
07:07:12 <Twey> IRCSTINKS: div
07:07:15 <chrisdone> > 10 div 2
07:07:15 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:07:16 <lambdabot>    `GHC.Num.Num t' arising f...
07:07:21 <chrisdone> > 10 `div` 2
07:07:22 <lambdabot>   5
07:07:28 <benmachine> > (-10) `div` 5
07:07:29 <quicksilver> Twey: lisps were supposed to be syntax agnostic, but they aren't.
07:07:29 <lambdabot>   -2
07:07:35 <benmachine> oh ok
07:07:41 <benmachine> wait
07:07:42 <benmachine> no
07:07:48 <benmachine> > (-10) `div` 4
07:07:49 <lambdabot>   -3
07:07:50 <Twey> quicksilver: How so?
07:07:53 <benmachine> > (-10) `quot` 4
07:07:53 <lambdabot>   -2
07:07:54 <quicksilver> Twey: in practice they use a primitive, limited, syntax which starts with () and then goes horribly downhil from there.
07:07:59 <benmachine> right
07:08:03 <quicksilver> Twey: M-expressions aren't really used.
07:08:18 <Twey> That's true, but not particularly relevant
07:08:29 <fryguybob> I think forth or postscript get closer to syntax agnostic as you can hijack the parser mid program.
07:08:33 <benmachine> quicksilver: lisp is syntax agnostic but lisp programmers aren't? :P
07:08:37 <Twey> It is *possible* to represent them in a wide variety of syntaxes, including non-textual ones
07:08:46 <quicksilver> that's possible for all languages.
07:08:50 <quicksilver> so it's an irrelevant remark.
07:09:05 <quicksilver> It is *possible* to represent ALGOL as an XML tree of its AST.
07:09:07 <quicksilver> people don't.
07:09:24 <quicksilver> In practice, lisp is as wedded to its concrete syntax as any other programming language.
07:09:31 <Twey> Sure, because the ALGOL AST would be hideous (more of a CST, really), much like the Haskell one we manipulate with TH
07:09:43 <quicksilver> People use () ' , ? \ and the rest.
07:09:59 <IRCSTINKS> what's wrong: http://codepad.org/9rq8MRj4
07:10:31 <Twey> IRCSTINKS: min (div x a) (div y b) is not a function
07:10:58 <yitz> @type min
07:10:59 <lambdabot> forall a. (Ord a) => a -> a -> a
07:11:09 <yitz> @type minimum
07:11:10 <lambdabot> forall a. (Ord a) => [a] -> a
07:11:24 <_minoru> hello everybody, now I have an issue with fastcgi again >< this time it's an exception handling
07:11:30 <IRCSTINKS> Twey: why is has to be a func?
07:12:03 <fryguybob> IRCSTINKS: Because it is being applied to an argument?
07:12:33 <benmachine> IRCSTINKS: I think you want max (min (div x a) (div y b)) (min (div y a) (div x b))
07:12:40 <IRCSTINKS> oh, i see
07:12:57 <aristid> @pl f x y a b = max (min (div x a) (div y b)) (min (div y a) (div x b))
07:12:58 <lambdabot> f = ap (ap . (liftM2 (liftM2 max) .) . (. div) . flip . (((.) . min) .) . div) (flip (flip . (((.) . min) .) . div) . div)
07:13:09 <benmachine> smooth
07:13:21 <Twey> *shudder*
07:13:23 <aristid> a light read.
07:13:46 <yitz> > let [x,y,a,b]=[1..4]; k=max (min (div x a) (div y b)) (min(div y a) (div x b)) in k
07:13:47 <lambdabot>   <no location info>: lexical error at character '\GS'
07:13:52 <hpc> sections of (.) are so much fun
07:13:53 <aristid> @src on
07:13:53 <lambdabot> (*) `on` f = \x y -> f x * f y
07:13:54 <scree> @unpl f = ap (ap . (liftM2 (liftM2 max) .) . (. div) . flip . (((.) . min) .) . div) (flip (flip . (((.) . min) .) . div) . div)
07:13:55 <lambdabot> f = (\ ae af ag -> af >>= \ ad -> ag >>= \ ae -> return (ae ad ae)) (\ ah -> ah) (\ ak aq -> (\ bu e -> (\ o r -> min (div ak o) (div bu r)) >>= \ b -> e >>= \ a -> return (b >>= \ g -> a >>= \ h ->
07:13:55 <lambdabot> return (max g max))) >>= \ am -> aq >>= \ al -> return (am al)) (\ bj v y ab -> min (div v y) (div bj ab))
07:13:57 <quicksilver> Twey: I think perhaps the interesting point is that lisp's syntax has a direct correspondance with lisp data, and you can use the same primitives to manipulate data to also manipulate lisp code.
07:14:05 <quicksilver> Twey: (homoiconic, do they call it?)
07:14:14 <aristid> :t div
07:14:15 <lambdabot> forall a. (Integral a) => a -> a -> a
07:14:20 <benmachine> scree: pl . unpl can't really be id because pl often generalises
07:14:21 <aristid> :t on
07:14:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:14:26 <_minoru> http://dumpz.org/19959/ - this works fine. However, this: http://dumpz.org/19959/ exits resulting 500 internal
07:14:40 <hpc> both are the same
07:14:42 <scree> benmachine: I know, I'm just trying to see how bad it can get by repeated application :)
07:14:43 <aristid> :t on max div
07:14:44 <quicksilver> Twey: although in practice I think programming in a way which expects to be able to manipulate code sexps is frowned upon?
07:14:44 <lambdabot> forall a. (Integral a) => a -> a -> a -> a
07:14:59 <scree> @pl f = (\ ae af ag -> af >>= \ ad -> ag >>= \ ae -> return (ae ad ae)) (\ ah -> ah) (\ ak aq -> (\ bu e -> (\ o r -> min (div ak o) (div bu r)) >>= \ b -> e >>= \  a -> return (b >>= \ g -> a >>= \ h ->
07:14:59 <lambdabot> (line 1, column 3):
07:14:59 <lambdabot> unexpected "="
07:14:59 <lambdabot> expecting variable, "(", operator or end of input
07:15:01 <benmachine> scree: I imagine it gets idempotent?
07:15:19 <yitz> > let [x,y,a,b]=[1..4]; k=max (min (div x a) (div y b)) (min(div y a) (div x b)) in k
07:15:20 <lambdabot>   <no location info>: lexical error at character '\FS'
07:15:23 <scree> benmachine: interesting. maybe not
07:15:28 <yitz> huh?
07:15:31 <benmachine> scree: also, the output was over two lines
07:15:41 <yitz> > let [x,y,a,b]=[1..4]; k=max (min (div x a) (div y b)) (min(div y a) (div x b)) in k
07:15:42 <lambdabot>   0
07:15:49 <scree> benmachine: yes
07:16:09 <scree> benmachine: if every function application is potentially generalized to a functor or a monad, it might go on indefiniteyl
07:16:16 <yitz> IRCSTINKS: is that ^ what you wanted?
07:16:17 <scree> s/yl/ly
07:16:39 <benmachine> scree: no because unpl will stay as general as the previous pl, so the second pl can't generalise any further
07:16:47 <benmachine> or, I dunno maybe
07:17:06 <scree> we could try a simpler example :)
07:17:07 <yitz> IRCSTINKS: btw, "null" is just a variable the way you used it in the pattern, it can match any string
07:17:22 <scree> @pl \x -> f (g x)
07:17:22 <lambdabot> f . g
07:17:28 <scree> @unpl f . g
07:17:28 <lambdabot> (\ c -> f (g c))
07:17:41 <aristid> @unpl (.)
07:17:41 <lambdabot> (\ a b c -> a (b c))
07:17:51 <scree> inconsistency!
07:18:03 <djahandarie> @. unpl pl \x -> f (g x)
07:18:03 <lambdabot> (\ c -> f (g c))
07:18:16 <benmachine> scree: huh?
07:18:22 <benmachine> also
07:18:30 <benmachine> @. unpl pl \x -> f (g x)
07:18:30 <lambdabot> (\ c -> f (g c))
07:18:39 <quicksilver> echo round here? :)
07:18:51 <benmachine> @. unpl pl \x -> f x (g x)
07:18:51 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a))
07:19:13 <benmachine> @. unpl pl (f >>= \ b -> g >>= \ a -> return (b a))
07:19:13 <lambdabot> (\ e -> g >>= ((f >>= \ b m -> return (b m)) e))
07:19:21 <benmachine> ah, it is growing
07:19:32 <benmachine> @. unpl pl (\ e -> g >>= ((f >>= \ b m -> return (b m)) e))
07:19:34 <lambdabot> (\ e -> g >>= ((f >>= \ b m -> return (b m)) e))
07:19:44 <benmachine> @pl (\ e -> g >>= ((f >>= \ b m -> return (b m)) e))
07:19:45 <lambdabot> (g >>=) . ((return .) =<< f)
07:19:51 <benmachine> but this is a fixed point
07:19:53 <chrisdone> @check \xs -> reverse xs == xs
07:19:54 <lambdabot>   "OK, passed 500 tests."
07:20:13 <chrisdone> ~o_O`/
07:20:17 <djahandarie> lol what
07:20:18 <scree> benmachine: the inconsistency is that lamdabot things (.) = fmap, but @unpl doesn't
07:20:19 <hpc> wut
07:20:27 <chrisdone> not enough tests!
07:20:29 <benmachine> scree: I don't think so
07:20:42 <scree> s/things/thinks
07:20:48 <scree> benmachine: which bit?
07:20:49 <benmachine> scree: pl doesn't think (.) = fmap afaik
07:21:16 <scree> benmachine: isn't that what I said?
07:21:24 <benmachine> scree: you said unpl doesn't
07:21:27 <kmc> hi everybody
07:21:28 <benmachine> scree: I don't think either of them do
07:21:29 <portnov> @check \x -> x == x+1
07:21:30 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
07:21:36 <scree> @type (.)
07:21:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:21:39 <benmachine> hi kmc
07:21:43 <scree> benmachine: ^^^
07:21:55 <benmachine> scree: yes but that's the type plugin, not pl
07:22:02 <kmc> @src (.)
07:22:02 <lambdabot> (f . g) x = f (g x)
07:22:02 <lambdabot> NB: In lambdabot,  (.) = fmap
07:22:03 <kmc> NB :)
07:22:17 <benmachine> scree: @pl works in mysterious ways
07:22:28 <djahandarie> It isn't like that in @pl and @unpl, as that is an entirely seperate plugin
07:22:40 <kmc> @pl \x y z -> (x,y,z)
07:22:40 <lambdabot> (,,)
07:22:46 <kmc> @pl \(x,y,z) -> x y z
07:22:46 <lambdabot> (line 1, column 6):
07:22:46 <lambdabot> unexpected ","
07:22:46 <lambdabot> expecting letter or digit, operator or ")"
07:22:46 <lambdabot> ambiguous use of a non associative operator
07:22:55 <kmc> is there a writeup somewhere of how pl works?
07:23:01 <benmachine> I doubt it :P
07:23:09 <benmachine> but you can download the source separately from lambdabot
07:23:11 <yitz> @unpl (,,)
07:23:11 <lambdabot> (,,)
07:23:50 <quicksilver> it can't really do triples because there aren't enough destructors
07:23:55 <yitz> @unpl (.)(.)
07:23:55 <lambdabot> (\ b c e f -> b c (e f))
07:23:59 <quicksilver> it would have to invent fst3 snd3 thd3
07:24:02 <yitz> @unpl (.)(.)(.)
07:24:02 <lambdabot> (\ c e f i -> c (e f i))
07:24:08 <yitz> @unpl (.)(.)(.)(.)
07:24:09 <lambdabot> (\ e f i k l -> e f i (k l))
07:24:21 <yitz> @unpl (.)(.)(.)(.)(.)
07:24:21 <lambdabot> (\ f i k l -> f (i (k l)))
07:24:24 <djahandarie> It's a pretty complex plugin
07:24:29 * benmachine wonders what's wrong with d, g, and h
07:24:34 <benmachine> and j
07:24:35 <FauxFaux> @pl a b c d e f = f e d c b a
07:24:35 <lambdabot> a = fix (flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
07:24:42 <aristid> :t (.)(.)
07:24:43 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:24:47 <portnov> @unpl (.) . (.)
07:24:47 <lambdabot> (\ i b c f -> i (b c f))
07:24:57 <aristid> :t (Prelude..)(Prelude..)
07:24:58 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
07:25:04 <yitz> @unpl (.)(.)(.)(.)(.)(.)
07:25:04 <lambdabot> (\ i k l q r -> i (k l) (q r))
07:25:15 <yitz> @unpl (.)(.)(.)(.)(.)(.)(.)
07:25:15 <lambdabot> (\ k l q r u -> k l (q r u))
07:25:19 <djahandarie> This is getting a little spammy
07:25:24 <yitz> sorry
07:25:28 <benmachine> PM :)
07:26:33 <_minoru> i mean, this: http://dumpz.org/19960/ works and this: http://dumpz.org/19960/ doesn't
07:26:47 <hpc> they are the same again...
07:26:57 <_minoru> * i mean  this: http://dumpz.org/19959/ and this: http://dumpz.org/19960/
07:27:02 <djahandarie> lol
07:27:06 <_minoru> p.s. nasty gtk buffer
07:27:42 <kmc> _minoru, "x <- return a" is a pretty strong code smell
07:27:42 <djahandarie> :t error
07:27:43 <lambdabot> forall a. [Char] -> a
07:27:54 <Cale> You should never have cause to write   x <- return y
07:27:58 <djahandarie> And yeah, you should never do that
07:28:03 <Cale> Write  let x = y   instead.
07:28:07 <kmc> not if x is a simple variable pattern, anyway
07:28:13 <Cale> Yeah.
07:28:19 <hpc> or do serve $ fromJust Nothing
07:28:31 <hpc> er, serve = output $ fromJust Nothing
07:28:34 <kmc> fromJust is also a code smell ;P
07:28:40 <Cale> serve $ fromJust Nothing  makes it more apparent another problem
07:28:51 <Cale> The problem that you're applying fromJust to Nothing
07:28:53 <hpc> for throwing errors forcibly though, it is a fine function
07:29:02 <kmc> it gives a crappy error message
07:29:07 <hpc> :t error
07:29:08 <lambdabot> forall a. [Char] -> a
07:29:11 <kmc> there are better alternatives
07:29:20 <Cale> Think of fromJust as being like saying "I guarantee that this thing will never be Nothing, and if it is, I don't mind my program dying and giving up completely."
07:29:33 <yitz> _minoru: which one works better, the error call or the fromJust Nothing?
07:29:34 <kmc> > fromMaybe (error "my more informative error message") Nothing
07:29:35 <lambdabot>   *Exception: my more informative error message
07:29:40 <kmc> > fromJust Nothing
07:29:40 <lambdabot>   *Exception: Maybe.fromJust: Nothing
07:29:42 <hpc> error works, the fromJust doesn't
07:29:55 <yitz> oh, ok.
07:29:59 <hpc> i assume this is for the same reason that you can't `catch` a divide-by-zero
07:30:03 <Cale> What is the type of  'output'
07:30:05 <Cale> ?
07:30:06 <yitz> so fastcgi catches usererror
07:30:18 <kmc> ah, the whole point of this exercise is to throw errors
07:30:20 <yitz> hpc: you can if you want to
07:30:20 <kmc> sorry, i missed that
07:30:34 <hpc> yitz: indeed, but you have to go out of your way, which it seems this doesn't
07:30:43 <_minoru> yitz, error call works fine. fromJust doesn't works.
07:30:51 <yitz> yes. what kinds of exceptions does handleError catch in fastcgi
07:31:13 <_minoru> i read the source, it seems, that it handles ErrorCall
07:31:32 <benmachine> I find it quite surprising that fromJust doesn't throw an ErrorCall
07:31:33 <yitz> _minoru: fastcgi ought to catch as wide a variety of exception types possible, true.
07:31:45 <yitz> @src fromJust
07:31:45 <lambdabot> fromJust Nothing  = undefined
07:31:45 <lambdabot> fromJust (Just x) = x
07:31:55 <yitz> oh, it's an undefined
07:32:08 <portnov> @src undefined
07:32:08 <lambdabot> undefined =  error "Prelude.undefined"
07:32:15 <yitz> _minoru: if you do serve $ handleError undefined does it do the same thing?
07:32:16 <hpc> it's an undefined to lambdabot
07:32:37 <benmachine> yitz: don't rely on @src
07:32:47 <yitz> yeah, there shouldn't be any difference. hmm.
07:32:58 <hpc> @src (.)
07:32:58 <lambdabot> (f . g) x = f (g x)
07:32:58 <lambdabot> NB: In lambdabot,  (.) = fmap
07:33:02 <yitz> benmachine: pretty sure @src is correct here though.
07:33:19 <benmachine> yitz: I reckon fromJust Nothing = error "fromJust: Nothing"
07:33:31 <benmachine> Maybe.fromJust: Nothing
07:33:32 <benmachine> rather
07:33:32 <_minoru> yitz, main = runFastCGI $ fromJust Nothing does the same thing
07:33:37 <aristid> > fromJust Nothing
07:33:38 <lambdabot>   *Exception: Maybe.fromJust: Nothing
07:33:41 <benmachine> and it does seem to be an ErrorCall
07:33:51 <yitz> benmachine: could be that too, but in any case likely also UserError. so why can't fastcgi catch it? weird.
07:33:51 <aristid> benmachine: you reckoned correctly.
07:33:54 <benmachine> so I am mystified
07:34:03 <Cale> You should basically never rely on calls to error being caught.
07:34:25 <benmachine> yitz: it is weird indeed - I'm thinking this might be the difference between undefined and return undefined, or something
07:34:29 <hpc> the best approach is to make your code exception-free
07:34:34 <yitz> _minoru: not surprising. what does it do with undefined?
07:34:39 <benmachine> how does output work?
07:34:42 <Cale> yitz: It's extremely tricky to catch them, because you have to ensure that they actually happen inside the call to catch, and aren't just returned as part of an expression from it.
07:34:49 <Cale> (and happen later, outside the catch)
07:35:07 <Cale> Control.Exception.evaluate can help sequence evaluation with IO, but it's tricky to do.
07:35:08 <yitz> Cale: right. but it's important for a cgi app. that's the whole point of handleError.
07:35:17 <benmachine> Cale: there ARE situations where you can ensure that, though
07:35:19 <_minoru> yitz, but handleErrors $ serve doesn't works...
07:35:24 <hpc> :t Control.Exception.evaluate
07:35:25 <lambdabot> forall a. a -> IO a
07:35:32 <benmachine> evaluate in combination with rnf might help
07:35:33 <Cale> If you have errors that you actually want to catch, throw proper IO exceptions.
07:35:40 <Cale> Or use Either/Maybe/etc.
07:36:02 <yitz> _minoru: sorry. i meant runFastCGI $ handleErrors undefined
07:36:11 <benmachine> Cale: mm, but if you're making a CGI handler library you might want sensible behaviour regardless of what nonsense you're given
07:36:45 <hpc> handleErrors just serves a 500 page, right?
07:36:46 <kmc> what's the tricky part about using "evaluate"?
07:36:54 <benmachine> kmc: it's shallow
07:37:00 <kmc> evaluate (x `using` rnf)
07:37:10 <yitz> Cale: the point is that when you run a cgi you can't see what happened very easily if it didn't work. so you want to wrap the calculation in something that will catch any exception and put up some kind of page that will point you in the right direction to fix it.
07:37:14 <kmc> though it's expensive to walk your data like that
07:37:18 <benmachine> that's ok except for when x is a closure of some kind that contains an undefined
07:37:33 <kmc> isn't that the whole point?
07:37:33 <benmachine> rnf can't get inside functions
07:37:36 <kmc> oh
07:37:41 <hpc> :t rnf
07:37:41 <lambdabot> forall a. (NFData a) => a -> Done
07:37:44 <yitz> Cale: the same facility exists in the cgi packages for most languages
07:37:47 <benmachine> (possibly my terminology was bad there)
07:37:51 <kmc> well that's the same as any language, isn't it?
07:38:08 <kmc> if you return a function that would throw an exception, that doesn't throw an exception
07:38:12 <benmachine> yes
07:38:13 <yitz> hpc: really? it doesn't put up a useful debugging page?
07:38:24 <benmachine> kmc: that doesn't help fix the problem though :P
07:38:34 <kmc> it would be cute to have a really-deep-seq that evaluates under lambda
07:38:59 <benmachine> yitz: normally you find out what exception was thrown because it spits something on stderr, but in a cgi app stderr doesn't go anywhere nice
07:39:06 <yitz> kmc: that would be broad-seq
07:39:07 <benmachine> apart from maybe to some obscure log
07:39:10 <kmc> heh
07:39:19 <yitz> benmachine: right
07:39:37 <kmc> hmm, can you implement that by calling the fn with an undefined arg, then catching if it's used?
07:39:38 <yitz> benmachine: even stdin doesn't do anywhere if it doesn't look like a valid http response
07:39:42 <kmc> sounds a little like lazy quickcheck
07:39:43 <yitz> *go
07:39:54 <hpc> stderr would get captured by your cgi daemon, which most likely goes to the httpd and back out to a file specified on the config
07:39:54 <Cale> yitz: I suppose what you could do is something like  evaluate (deepSeq <the entire output>), and stick that in a catch
07:39:56 <benmachine> yitz: hmm, I think I miscontexted you
07:40:15 <benmachine> well, or just put the catch at the very very top level of whatever it is you are doing
07:40:18 <yitz> benmachine: ok :) irc is fun
07:40:21 <Cale> yitz: You still have to hope that any error calls don't get evaluated before that.
07:40:27 <Cale> yitz: Another possibility: use hint
07:40:31 <Twey> IRCSTINKS: http://codepad.org/nJ70y0V8 too
07:40:34 <yitz> hint?
07:40:58 <benmachine> haskell interpreter
07:41:05 <benmachine> invokes GHC on stuff you give it at runtime
07:41:16 <Twey> quicksilver: Yes, homoiconism is what makes it syntax-agnostic
07:41:17 <benmachine> GHC-as-a-library
07:41:28 <yitz> Cale: oh. that doesn't sound too practical for cgi.
07:41:31 <Twey> quicksilver: I don't think macros are frowned upon in Lisps…
07:41:57 <kmc> it's a high level wrapper on GHC-as-a-library
07:42:24 <_minoru> yitz, why is it undefined and which peace of code are you talking about?
07:42:32 <Cale> yitz: If you compile the code to a .o using ghc beforehand, when you load it with hint, it will load the compiled and optimised code automatically
07:42:53 <hpc> can't you ghci compiled haskell too?
07:42:55 <benmachine> Cale: how does using hint help exactly
07:43:00 <benmachine> hpc: yes
07:43:21 <benmachine> hpc: ghci looks for likely .o files whenever it loads a module
07:43:36 <yitz> _minoru: i meant use the word undefined literally. it's defined in the Prelude. If you evaluate it, it causes an error. I wanted to see what handleErrors does with it.
07:43:55 <Cale> benmachine: If the program fails, you just get a value specifying the exception that occurred
07:43:56 <quicksilver> Twey: no, macros aren't frowned on per se, but writing ordinary code which relies on the ability to inspect (other) code is unusual.
07:44:13 <Cale> runInterpreter :: (MonadCatchIO  m, Functor  m) => InterpreterT  m a -> m (Either  InterpreterError  a)
07:44:26 <benmachine> oh right
07:44:26 <quicksilver> Twey: ... and, as far as my limited experience goes, most lisps have some notion of a 'compiled' function where you can't get the sexp-form even if you want it.
07:44:29 <benmachine> neat
07:44:34 <Cale> data InterpreterError = UnknownError String
07:44:34 <Cale>                       | WontCompile [GhcError]
07:44:34 <Cale>                       | NotAllowed  String
07:44:34 <Cale>                       -- | GhcExceptions from the underlying GHC API are caught
07:44:34 <Cale>                       -- and rethrown as this.
07:44:35 <Cale>                       | GhcException String
07:44:37 <Cale>                       deriving (Show, Typeable)
07:44:43 <yitz> Cale: I suppose you could use that as some kind of debugging mode. I doubt that you'd want to wrap a production program in it, but that's ok.
07:44:54 <Cale> yitz: You could, and it would run at full speed
07:44:58 <yitz> so could be that would do it if deep seq isn't good enough.
07:45:11 <benmachine> I think the problem is in a different plac
07:45:12 <benmachine> e
07:45:14 <Cale> yitz: So long as you ensured that it was compiled code that you're loading.
07:45:23 <kmc> using "hint" in a webserver has other appeal
07:45:33 <kmc> like recompiling parts of your web app without restarting the whole server
07:45:34 <benmachine> I think basically that handleErrors doesn't :P
07:45:38 <benmachine> at least not properly
07:45:40 <benmachine> and it could do
07:45:41 <kmc> (not important for vanilla cgi, of course)
07:45:55 <yitz> Cale: oh really? it just hooks into the runtime?
07:46:24 <Twey> quicksilver: Ah, run-time macros?  I don't really know; you'd have to ask a Lispnik
07:46:54 <kmc> Lisp systems often don't have a sharp distinction between "compile time" and "run time"
07:47:17 <kmc> there is a distinction between "compiled" and "interpreted", but there's a function that takes an interpreted function and compiles it
07:47:21 <kmc> and you can call this function at any time
07:47:43 <kmc> including on code you just generated and passed to eval
07:48:02 <kmc> i'd really like to see some kind of Super Mutant Template Haskell that can do this
07:48:10 <kmc> in conjunction with GHC API and maybe LLVM
07:48:27 <kmc> then again i'd like pattern splices too ;P
07:49:00 <djahandarie> Is Arrow.first similar to fmap except it works on the first branch of the structure rather than the last?
07:49:12 <kmc> :t first
07:49:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:49:24 <kmc> djahandarie, you mean similar to fmap for tuples specifically?
07:49:59 <kmc> if you try to unify the types of "first" and "fmap"
07:50:02 <kmc> then you get a = (->)
07:50:18 <djahandarie> Hm
07:50:23 <kmc> and it becomes (b -> c) -> (b, d) -> (c, d)
07:50:47 <kmc> which would be fmap on the functor /\t -> (t, d)
07:50:51 <kmc> if such type-level functions were allowed
07:51:07 <kmc> > second show (2,3)
07:51:08 <lambdabot>   (2,"3")
07:51:11 <kmc> > fmap show (2,3)
07:51:12 <lambdabot>   (2,"3")
07:51:28 <kmc> so yes, they do coincide for pairs, but that's a special case of what both are capable of
07:51:31 <hpc> is there a function to reverse a tuple?
07:51:43 <hpc> @hoogle (a, b) -> (b, a)
07:51:43 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:51:43 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
07:51:43 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
07:51:51 <bastl> @seen
07:51:52 <lambdabot> Unknown command, try @list
07:51:53 <yitz> hpc: there was a long bikeshedding thread about that recently
07:52:03 <bastl> @list
07:52:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:52:07 <kmc> :t uncurry (flip (,))
07:52:07 <lambdabot> forall b a. (a, b) -> (b, a)
07:52:16 <hpc> ah
07:52:20 <yitz> hpc: it's going to be called Data.Tuple.swap
07:52:26 <bastl> the list of commands is not helpful
07:52:37 <kmc> @nixon
07:52:37 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
07:52:50 <djahandarie> preflex: seen bastl
07:52:50 <preflex>  bastl was last seen on #haskell 24 seconds ago, saying: the list of commands is not helpful
07:52:58 <bastl> :-)
07:53:00 <bastl> tx
07:53:36 <yitz> hpc: the whole argument was about whether it should be strict or not.
07:53:51 <hpc> lazy ftw
07:54:29 <yitz> hpc: the most obvious way to define it would be swap (a,b) = (b,a) which is strict
07:55:04 <_minoru> yitz, and how can i resolve this problem?
07:55:10 <bastl> still, how can I know what commands these lambdabots understand. and what the arguments to the commands are? Is there a reference somewhere ?
07:55:29 <yitz> hpc: you could use ~(a,b), or write it as uncurry $ flip (,), to make it lazy
07:55:31 <kmc> @help nixon
07:55:31 <lambdabot> Richad Nixon's finest.
07:55:36 <kmc> @help pl
07:55:36 <lambdabot> pointless <expr>. Play with pointfree code.
07:55:40 <hpc> yitz: really? by my understanding, it would match the tuple into (a,b) but not evaluate a or b
07:55:58 <aristid> @src uncurry
07:55:58 <lambdabot> uncurry f p = f (fst p) (snd p)
07:56:00 <dmwit> ?list them, bastl!
07:56:00 <lambdabot> No module "them, bastl!" loaded
07:56:03 <dmwit> ?list
07:56:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:56:06 <bastl> preflex: @help seen
07:56:20 <bastl> preflex: @seen kmc
07:56:20 <preflex>  kmc was last seen on #haskell 44 seconds ago, saying: @help pl
07:56:21 <aristid> hmm i think you could write uncurry as uncurry f ~(a, b) = f a b ?
07:56:30 <quicksilver> bastl: the short answer to your question is "no"
07:56:40 <quicksilver> bastl: although some questions have help files, some do not.
07:56:53 <mauke> bastl: stop using @
07:56:54 <quicksilver> bastl: the only reliable reference is the source.
07:57:00 <yitz> _minoru: are you just trying to learn about what kinds of errors handleErrors can report properly, or do you have a specific program that you can't debug?
07:57:07 <bastl> a bit unsatisfying ..
07:57:15 <quicksilver> bastl: indeed.
07:57:20 <scree> hpc: lazy in the pair constructor, not the contents
07:57:33 <bastl> mauke: why?
07:58:05 <mauke> because I thought you wanted some help
07:58:19 <hpc> ah
07:58:23 <yitz> > let swap (a,b)=(b,a) in swap undefined `seq` 42
07:58:23 <lambdabot>   *Exception: Prelude.undefined
07:58:34 <bastl> sorry, i thought I have to prepend commands with 'at'
07:58:43 <yitz> > let swap = uncurry $ flip (,) in swap undefined `seq` 42
07:58:44 <lambdabot>   42
07:58:46 <mauke> bastl: why?
07:59:02 <kmc> > let swap x = let (a,b) = x in (b,a) in swap undefined `seq` 42
07:59:02 <lambdabot>   42
07:59:13 <quicksilver> bastl: lambdabot is not preflex, etc.
07:59:20 <yitz> kmc: right, let bindings are lazy
07:59:29 <bastl> seen it with @hoogle and @nixon just minutes ago.
07:59:32 <kmc> > let swap ~(a,b) = (b,a) in swap undefined `seq` 42
07:59:32 <lambdabot>   42
07:59:37 <mauke> <djahandarie> preflex: seen bastl
07:59:38 <hpc> that
07:59:46 <hpc> that's an entertaining laziness trick
07:59:59 <kmc> these ~ patterns are pretty rare in the wild afaik
08:00:04 <kmc> but they do come up
08:00:06 <bastl> quicksilver: how can I know ? perhaps some of the developers should write something down on the wiki ?
08:00:09 <kmc> it's a bad idea with any type with >1 constructor
08:00:13 <bastl> mauke: i see
08:00:27 <IRCSTINKS> http://codepad.org/vqAYMiqW: how to get rid of 'rr'?
08:00:40 <hpc> ~patterns can explode if they match and don't fit the pattern, is probably why people don't use them
08:01:03 <yitz> kmc: a ~ pattern in the definition of >>= is the whole difference between Control.Monad.State.Strict and Control.Monad.State.Lazy
08:01:22 <quicksilver> bastl: how can you know? Well if you want to know about preflex you can ask mauke, or indeed use its help command which is a bit more reliable than lambdabot's.
08:01:37 <_minoru> yitz, I have a specific program that i can't debug. The problem is that handleErrors doesn't want to catch exceptions from fromJust-s
08:02:03 <scree> IRCSTINKS: add a type annotation
08:02:14 <quicksilver> bastl: lambdabot has a wiki page which you could add stuff to. Other people might even be motivated to correct it.
08:02:51 <yitz> _minoru: as someone said before - best not to use fromJust at all. Wherever you have fromJust, replace it with fromMaybe (error "..."") with a description of where the error happened.
08:03:09 <scree> IRCSTINKS: http://codepad.org/C2vc7Ans
08:03:34 <yitz> _minoru: that way if you try to call it on a Nothing by mistake, you'll be able to see what happened.
08:04:09 <Twey> fromMaybe (error "fromJust: Nothing")
08:04:11 <Twey> ;)
08:04:25 <yitz> Twey: very funny
08:04:51 <_minoru> yitz, hm, it's a good idea
08:04:54 <yitz> fromMaybe (error "null pointer exception")
08:05:07 <IRCSTINKS> scree, thanks
08:05:13 <Twey> Hehe
08:05:23 <_minoru> fromMaybe (error "Segmentation Fault")
08:05:26 <yitz> _minoru: not the jokes we just wrote of course. really write something that tells you where the error happened.
08:05:49 <fryguybob> fromMaybe (fromJust Nothing)
08:05:54 <djahandarie> lol
08:05:55 <_minoru> yitz, I understand.)
08:06:41 <yitz> _minoru: the maybe function is also very useful - it's defined in the Prelude, you don't even have to import it
08:06:43 <yitz> @type maybe
08:06:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:06:46 <CosmicRay> I am trying to figure out what happens if someone provides a Unicode (UTF-8 presumably) parameter on the command-line to a Haskell program.  It appears that the behavior of getArgs in this case is non-obvious.
08:06:57 <CosmicRay> is it just doing a literal translation into Chars?
08:06:59 <texodus> if I cabal installed 2 packages with conflicting module names (mtl and monads-fd), is there a way to tell ghc to prefer one to teh other when compiling with ghc?
08:07:00 <hpc> @src maybe
08:07:00 <lambdabot> maybe n _ Nothing  = n
08:07:00 <lambdabot> maybe _ f (Just x) = f x
08:07:09 <yitz> CosmicRay: it's platform dependent
08:07:16 <Twey> CosmicRay: It'll be interpreted according to the locale
08:07:18 <CosmicRay> yitz: ouch.
08:07:26 <Twey> In 6.12, anyway.
08:07:32 <Saizan> texodus: yes, ghc-pkg hide one
08:07:51 <yitz> CosmicRay: on Unix it gives you a String of "unicode" that is really just the raw bytes of the arg
08:07:56 <texodus> beautiful, thanks!
08:08:20 <yitz> CosmicRay: not sure on windows, some of those kinds of things have been fixed there.
08:08:24 <CosmicRay> yitz: ah ok
08:08:25 <Twey> I'm confused
08:08:36 <Twey> Doesn't it just give the argument in a normal String?
08:08:39 * yitz is on mac, trying it with 6.12.1...
08:08:40 <EvanR-work> rng's are designed to provide statistically independent results for the lifetime of its run. but are they generally robust in the seed dimension? i.e. is [take 1 (rng 0), take 1 (rng 1), take 1 (rng 2), ...] a non broken rng?
08:08:45 <EvanR-work> i have a feeling no
08:08:50 <Twey> Decoded with 6.12, not with 6.10
08:08:56 <Twey> Same as the rest of the IO subsystem…
08:09:34 <EvanR-work> and this would make 'seed from system on bootup' a bad rng
08:10:03 <hpc> EvanR-work: only if you expose your startup time to the public
08:10:20 <Saizan> Twey: just tried on 6.12.2, no decoding
08:10:26 <EvanR-work> ignore cryptographiy, only concern at the moment with statistics
08:10:46 <EvanR-work> startup time is not random, and if it were my worry above still stands
08:10:48 <CosmicRay> Twey: the problem is that you can't provide *only* a decoded version, since then you couldn't open files that have binary names that aren't valid in unicode
08:11:10 <Twey> Ah, ick
08:11:16 <CosmicRay> unix filesystem is coding-agnostic
08:11:17 <yitz> CosmicRay: yeah it does that on mac also
08:11:37 <kmc> yitz, hmm, that's interesting
08:11:39 <hpc> what do you mean, startup time isn't random? that shouldn't matter
08:11:41 <Saizan> CosmicRay: be glad that getArgs does no decoding then :)
08:11:43 <CosmicRay> a unix filename is just a stream of bytes.  anything is valid except \0 and '/'
08:11:46 <hpc> you seed off the epoch time
08:11:50 <CosmicRay> Saizan: yes.
08:11:51 <kmc> yitz, does that mean that State.Strict doesn't force the state itself to whnf?
08:11:59 <CosmicRay> Saizan: I am, in a way ;-)
08:12:36 <yitz> CosmicRay: the problem is when an arg is a file path. on windows, FilePath is actually interpreted as Unicode, whereas on Unix it's a fake [Word8].
08:12:36 <_minoru> anyway, handleErrors doesn't works even with fromMaybe.
08:12:43 <_minoru> (2yitz)
08:13:22 <yitz> kmc: could be not
08:13:47 <CosmicRay> yitz: yep
08:13:48 <yitz> _minoru: really? when you put an error call inside? you said before that worked.
08:14:18 <EvanR-work> hpc: what you are saying is that seed is like the preimage of hash, irrelevant. as long as its different, you say the first number of the rng is random. thats what im questining
08:14:19 <CosmicRay> yitz: interesting that FP on Windows is interpreted as unicode.  didn't realize that, but it makes sense I suppose
08:14:28 <CosmicRay> yitz: and yeah, absolutely can't do that on POSIX
08:14:45 <hpc> as long as you don'
08:15:02 <hpc> as long as you don't tell people what your initial seed is, it shouldn't matter
08:15:16 <yitz> CosmicRay: so if you get an arg which is a file name, on Windows you'll need to cast it as a byte stream and decode to Unicode before using it, whereas on Unix you use it as is
08:15:52 <CosmicRay> huh.
08:16:09 <CosmicRay> so on Windows, getArgs still returns the raw UTF-8 just like on Unix?
08:16:16 <yitz> CosmicRay: mac is in the middle. the file system uses unicode for file paths. the command line is posix-like.
08:16:42 <hpc> "in the middle" reads more like "inconsistent" to me
08:17:23 <yitz> CosmicRay: in all three platforms, really funky things can happen when you have a file path expressed as non-normalized Unicode. if you normalize it, is that a new file path or another name for the original? depends on the platform.
08:17:24 <EvanR-work> hpc: my hypothesis is that if you take 1 from each reinitilized rng, you dont get a rng. and 'people' definitely could tell its wrong
08:18:00 <EvanR-work> and not a hypothesis is that if you do tell them the seeds, and the rng is working, it doesnt matter
08:18:09 <EvanR-work> it doesnt change the statistics to know the seed
08:18:34 <yitz> CosmicRay: mac and windows each have their own kind of normalization that they apply to unicode when using it as a file path. unix just uses the bytes as is.
08:18:56 <bastl> quicksilver: I rather edited page IRC_channel#Bots since page Lambdabot seems to document the software 'lambdabot' not the bot itself. I was looking for _user_ documentation. I added a table for useful commands ...
08:19:05 <yitz> CosmicRay: although that is only for the default settings in the default file system for each platform. it can vary between file systems.
08:19:56 <quicksilver> bastl: \o/
08:20:19 <bastl> lexer error ...
08:20:19 <yitz> bastl: now we just need to fix the useful command that have become broken
08:20:42 <jmcarthur> EvanR-work: isn't this problem addressed by crytographic hash algorithms?
08:21:25 <EvanR-work> jmcarthur: yes, an rng isnt a crypto system necessarily
08:21:42 <_minoru> yitz, I found, that main = runFastCGI $ handleErrors $ error "something" works fine. main = runFastCGI $ handleErrors $ output $ error "something" doesn't.
08:21:49 <EvanR-work> ive never heard that 'a good rng produces random numbers, even if you seed with sequential numbers and only take one at a time'
08:22:07 <_minoru> what's the problem with `output`?...
08:22:19 <jmcarthur> EvanR-work: but a good crypto-hash algorithm should have that property
08:22:23 <EvanR-work> yes
08:22:49 <yitz> EvanR-work: that is a good point, needs to be checked for LeCuyer
08:23:04 <EvanR-work> finally someone is listening!
08:23:09 <jmcarthur> i won't hypothesize about whether rngs create statistically independent values by simply incrementing the seed
08:23:26 <jmcarthur> but i do agree that it isn't really addressed that much
08:23:27 <EvanR-work> well if i dont figure it out, ill be hypothesizing ;)
08:23:34 <EvanR-work> because this part of the software is doing that
08:23:35 <hpc> haskell's rng seems to be random with incremented seeds
08:23:39 <hpc> *Main> take 20 incrementSeeds
08:23:41 <hpc> [-604496784,-1154341369,-1704185953,-106546976,-656391561,-1206236146,-1756080730,-158441753,-708286338,-1258130923,-1807975507,-210336530,-760181115,-1310025700,-1859870284,-262231307,-812075892,-1361920477,-1911765061,-314126084]
08:23:50 <yitz> _minoru: oh. bummer. that's a problem, yes. what happens instead?
08:23:50 <hpc> where incrementSeeds = map fst $ [random $ mkStdGen g | g <- [1..]]
08:23:51 <jmcarthur> err
08:23:57 <jmcarthur> they are all negative
08:24:02 <EvanR-work> exactly
08:24:26 <yitz> hpc: why are they all negative?
08:24:43 <bastl> Is someone online familiar with the multirec zipper http://preview.tinyurl.com/2cykuda ? How can 'on' extract the focus, when the type of the focus is hidden in an existential ?
08:24:44 <hpc> pure chance
08:24:45 <EvanR-work> haskell also produces an even number first for the first 60000 seeds
08:24:54 <hpc> if you take more, it gets more even
08:24:54 <EvanR-work> i believe
08:25:00 <Twey> o.@
08:25:02 <jmcarthur> > (1/2)**20
08:25:02 <lambdabot>   9.5367431640625e-7
08:25:07 <hpc> i didn't want to spam
08:25:11 <jmcarthur> that's a small chance
08:25:12 <yitz> hpc: 1,2,3,.. could be pure chance too, but wouldn't help us
08:25:39 <_minoru> yitz, code snippet with output exits while handling fastcgi request resulting in 500.
08:25:47 <hpc> if you start from a random seed and increment, it should be sufficiently unpredictable to be cryptographically secure
08:25:53 <jmcarthur> > (1%2)^20
08:25:53 <lambdabot>   1 % 1048576
08:25:55 <yitz> _minoru: hmph
08:26:27 <Twey> > filter ((/= 0) . (`mod 2)) . zip [1 ..] $ map mkStdGen [1 .. 60000]
08:26:28 <lambdabot>   <no location info>: parse error on input `2'
08:26:35 <jmcarthur> i'm kind of doubting this
08:26:39 <EvanR-work> jmcarthur: a php program by default resets its RNG each time the page refreshes. each time it refreshes it generally uses a small number of random numbers. so this is directly applicable. the alternative is to keep a global rng state through the page loads, but it does not do that and does not expose its state
08:26:41 <Twey> > filter ((/= 0) . (`mod` 2)) . zip [1 ..] $ map (random . mkStdGen) [1 .. 60000]
08:26:42 <lambdabot>   No instance for (GHC.Real.Integral (t, (a, System.Random.StdGen)))
08:26:42 <lambdabot>    arisi...
08:26:48 <Twey> Ack
08:26:54 <Twey> > filter ((/= 0) . (`mod` 2) . snd) . zip [1 ..] $ map (random . mkStdGen) [1 .. 60000]
08:26:55 <lambdabot>   No instance for (GHC.Real.Integral (a, System.Random.StdGen))
08:26:55 <lambdabot>    arising fr...
08:26:59 <EvanR-work> we should stop talking about cryptographically secure this is way out of scope here
08:27:08 <EvanR-work> i just want statistically not shit
08:27:09 <jmcarthur> EvanR-work: that's nasty
08:27:09 <hpc> no, my paste above had odd numbers
08:27:13 <yitz> _minoru: maybe try using rnf: runFastCGI . handleErrors . rnf . output $ error "aha!"
08:27:17 <yitz> @hoogle rnf
08:27:17 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
08:27:18 <Twey> > filter ((/= 0) . (`mod` 2) . snd) . zip [1 ..] $ map (fst . random . mkStdGen) [1 .. 60000]
08:27:19 <lambdabot>   [(4,-258552320774346181),(5,7776561651304326943),(9,7635215034817673361),(1...
08:27:27 <jmcarthur> EvanR-work: i brought up crypto-hashes precisely because they solve this exact problem
08:27:28 <Twey> EvanR-work: Odd
08:27:41 <yitz> unhelpful.
08:28:04 <EvanR-work> jmcarthur: right, so add up the characters of a cryptohash before seeding...
08:28:07 <jmcarthur> *are intended to solve
08:28:12 <EvanR-work> these rngs typically have a 32bit seed
08:28:36 <jmcarthur> if you are trying to emphasize speed then i could see your objections
08:28:54 <EvanR-work> jmcarthur: i brought down cryptography because hpc keeps emphasizing his hypotheses are cryptographically secure, while i cant verify or unverify those claims, i dont need a crypto stream
08:29:06 <EvanR-work> jmcarthur: no im not objecting
08:30:38 <EvanR-work> jmcarthur: anyway. a hash will produce a 'random' seed effectively. but im lead back to the properties of the generator
08:30:59 <EvanR-work> its possible to make a generator that is 'effectively purely random' but always starts with 5 regardless of seed
08:31:12 <EvanR-work> (which is sort of what haskell does)
08:31:35 <jmcarthur> hpc: if you use your code to generate booleans then the first element of the list that is not True has index 53667
08:31:39 * EvanR-work goes insane
08:31:39 <jmcarthur> that's... very large
08:31:39 <mdmkolbe1> In emacs literate-haskell-mode how do I comment out TeX?  ("M-x comment-region" puts haskell comments, but I need TeX comments.)
08:31:40 <yitz> _minoru: oh the type of rnf is a -> ()
08:31:49 <hpc> o.O
08:32:04 <hpc> i retract my hypothesis then
08:32:53 <_minoru> yitz, also, I can't found StrictBench in my distribution repository (Debian Lenny), and cabal doesn't want to resolve dependencies properly >< I really hate cabal
08:33:20 <_minoru> (maybe not really, but I don't like it, although)
08:33:26 <jmcarthur> EvanR-work: btw, mwc-random also suffers from this problem
08:33:29 <yitz> _minoru: oh, cabal is great. what dependency problem are you having
08:33:33 <jmcarthur> EvanR-work: although it may have been fixed by now
08:33:37 <jmcarthur> i don't know about twister
08:33:51 <jmcarthur> i discovered it about mwc several months ago
08:33:52 <yitz> _minoru: maybe try using rnf: runFastCGI . handleErrors . rdeepseq . output $ error "aha!"
08:33:56 <_minoru> Building StrictBench-0.1.1...
08:33:56 <_minoru> Test/StrictBench.hs:40:7:
08:33:56 <_minoru>     Could not find module `Control.Parallel.Strategies':
08:34:06 <EvanR-work> i truely cant surmise whether this 'problem' is being addressed in general, or if its well known, or if the world is retarded
08:34:11 <EvanR-work> and that annoys me
08:34:15 <EvanR-work> i like to know where i stand
08:34:18 <jmcarthur> that is, it may have been an implementation bug rather than theoretical
08:34:19 <byorgey> copumpkin: numeric-prelude is nice, once you figure out the way it is organized
08:34:23 <_minoru> Building parallel-2.2.0.1...
08:34:23 <_minoru> Control/Parallel/Strategies.hs:117:7:
08:34:23 <_minoru>     Could not find module `Control.DeepSeq':
08:34:27 <byorgey> copumpkin: working with the documentation is a bit of a pain though
08:34:29 <EvanR-work> jmcarthur: ill do tests on php mt_rand
08:34:44 <_minoru> of course, I can resolve them by hands... but it's a masochism
08:34:52 <byorgey> copumpkin: since Haddock doesn't show you qualified names, you just see 'C' and 'T' everywhere
08:34:58 <byorgey> copumpkin: but looking at the source isn't that bad.
08:35:22 <yitz> _minoru: sounds like some cabal files are missing dependencies. it's because of a recent change to ghc. wait, what version of ghc are you using?
08:35:37 <yitz> _minoru: are you using 6.8.2, the lenny version?
08:35:44 <_minoru> yitz, 6.12.1 from sid
08:35:51 <yitz> oh ok good
08:36:01 <_minoru> actually, i have some more packages from sid installed
08:36:03 <Saizan> _minoru: what command are you running?
08:36:07 <jmcarthur> EvanR-work: i think the "problem" isn't the rng, but how it's being used by PHP
08:36:19 <_minoru> Saizan, cabal install StrictBench
08:36:27 <yitz> _minoru: yes. for a while i was using testing, but i had every haskell package pinned to unstable
08:36:34 <EvanR-work> jmcarthur: this is true for all rngs. people are *supposed* to use them by seeding once and never reseeding, if they want random numbers
08:36:36 <jmcarthur> well, PHP's rng sucks from what i hear, too, but that is a separate issue
08:36:41 <jmcarthur> right
08:36:59 <EvanR-work> so the question is how stupid are people in ignoring this
08:37:10 <EvanR-work> most language apis do not give you the option like in haskell of restoring an rng to a previous state
08:37:26 <yitz> EvanR-work: people should be using MonadRandom
08:37:35 <Saizan> _minoru: mh, i can't reproduce that error, and deepseq appears in the dependencies of parallel, so you had to have it installed..
08:37:37 <aristid> @hoogle MonadRandom
08:37:38 <lambdabot> No results found
08:37:39 <yitz> or their own state monad, or pass around the gen.
08:37:43 <EvanR-work> yes
08:37:46 <EvanR-work> i like monad random
08:37:48 <aristid> yitz: what's MonadRandom?
08:37:55 <jmcarthur> ?hackage MonadRandom
08:37:55 <lambdabot> http://hackage.haskell.org/package/MonadRandom
08:37:58 <jmcarthur> ^^ i think
08:38:05 <yitz> @wiki MonadRandom
08:38:05 <lambdabot> http://www.haskell.org/haskellwiki/MonadRandom
08:38:07 <aristid> thx
08:38:07 <jmcarthur> it's picky about capitalization
08:38:10 <yitz> i think
08:38:16 <jmcarthur> ah but that's it
08:38:46 <jmcarthur> honestly, i think MonadRandom is lacking in helper functions and type class instances
08:38:55 <jmcarthur> iirc, it's not even an instance of Applicative :(
08:39:19 <yitz> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
08:39:27 <yitz> but the hackage package, really
08:39:50 <yitz> jmcarthur: i'm sure Cale would happily accept patches
08:40:08 <mdmkolbe1> Will a function that is constant stack space in an eager language be constant stack space in a lazy language?
08:40:38 <Cale> mdmkolbe1: It's unclear.
08:40:44 <yitz> mdmkolbe1: that's not well defined
08:40:46 <kmc> mdmkolbe1, stack space is not as important
08:40:50 <Cale> mdmkolbe1: Some lazy evaluators don't even have a stack.
08:41:00 <kmc> it may use lots of heap space building unevaluated structures
08:41:06 <kmc> also this is an implementation question, not a language question
08:41:17 <Cale> mdmkolbe1: In GHC, the stack is used to hold pattern matches which are waiting for their scrutinees to be sufficiently evaluated to match.
08:41:20 <Heffalump> you can always simulate the stack on the heap
08:41:29 <yitz> mdmkolbe1: you have to implement the function separately in each language, and its behavior will depend on the implementation
08:42:04 <EvanR-work> jmcarthur: do you know of any test suites i can pass in numbers to without too much hassle ;)
08:42:04 <Cale> mdmkolbe1: So the stack in GHC Haskell doesn't quite correspond to function calls, but case expressions.
08:42:04 <kmc> mdmkolbe1, if you want to do something in constant space in a lazy language, it's not necessary or sufficient to be tail-recursive
08:42:11 <kmc> you can be productive instead
08:42:35 <jmcarthur> EvanR-work: attempting to measure statistical independence?
08:42:39 <jmcarthur> no idea
08:42:46 <applicative> kmc, what does productive mean?
08:42:51 <aristid> @pl \f -> arr (.f)
08:42:51 <lambdabot> arr . flip (.)
08:42:51 <EvanR-work> yeah
08:42:52 <Saizan> mdmkolbe1: on a pratical note, if you take some tail recursive function from ML and naively transliterate it to haskell, you'd probably get a stack overflow, the solution is to add strictness annotations, or maybe reorganize the function to make use of laziness
08:42:59 <kmc> applicative, producing constructors that can be pattern-matched as you go
08:43:02 <EvanR-work> guess ill eyeball it as a few step
08:43:03 <kmc> > length . take 5 $ (let x = 1 : x in x)
08:43:04 <lambdabot>   5
08:43:14 <jmcarthur> eyeballing sucks
08:43:18 <yitz> mdmkolbe1: foldl1 (+) [1..1000000] implemented as a while loop in C uses constant stack space, overflows in GHC, but constant again in ghc -O2
08:43:21 <jmcarthur> we're really bad at determining randomness
08:43:27 <kmc> ^^^^ this is probably constant-space, even though x is recursive and not tail-recursive
08:43:42 <EvanR-work> well i caught haskell's True True True True... 60000 thing with eyeball ;)
08:43:44 <kmc> and indeed x would take infinite space to represent in normal form
08:43:51 <aristid> preflex: seen conal
08:43:51 <preflex>  conal was last seen on #haskell 15 hours, 1 minute and 44 seconds ago, saying: aristid: cool.  you'll get my motivation there.
08:44:08 <kmc> it's constant-space because x will produce 1's one at a time, feed them to take, which will pass them through one at a time, and feed them to length, which will  count them and throw them out
08:44:12 <jmcarthur> EvanR-work: that one was pretty "obvious" (or represented a miracle!)
08:44:16 <kmc> (by constant i mean in the number 5)
08:44:17 <EvanR-work> heh
08:44:25 <aristid> conal should come back so i can ask stupid question about secs
08:45:13 <applicative> kmc, I think I see; whats a textbook example of non productive bad definition?
08:45:39 <kmc> @src foldl
08:45:39 <lambdabot> foldl f z []     = z
08:45:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:46:03 * kmc thinks
08:46:08 * BMeph was going to type "foldl", but kmc beat him to it.
08:46:32 <kmc> consider that «map f = foldr ((:) . f) []»
08:46:49 <kmc> this passes elements through one at a time, as you'd expect
08:46:53 <kmc> because of how foldr is defined
08:46:55 <kmc> @src foldr
08:46:55 <lambdabot> foldr f z []     = z
08:46:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:46:57 <mdmkolbe1> ok, then what is the right term in a lazy language for a function that has been translated so that breaking out of it is efficient.  e.g., consider a mapM specialized to a Maybe monad that stops and returns Nothing when any of the mapped applications returns nothing.
08:47:01 <BMeph> applicative: Just as an aside, some people also refer to productive expressions as "incremental".
08:47:04 <kmc> the second case is productive, when f is a constructor
08:47:18 <EvanR-work> jmcarthur: another thing about the 'take 1' generator above, it has a pretty low max lifetime of 2^32 or so. however many seeds there are ;)
08:47:24 <applicative> kmc, here as we open up the x:xs, we add new fs till we have all of them
08:47:34 <kmc> mhm
08:47:43 <jmcarthur> EvanR-work: StdGen is Int32?
08:47:44 <kmc> with foldl you will build a big tree of f's in the accumulator position
08:47:48 <applicative> kmc, if f is something where f . f can be reduced it's not so bad i guess
08:47:50 <kmc> before yielding any of them to the caller
08:47:54 <kmc> it won't reduce though
08:47:56 <kmc> unless you ask it to
08:47:58 <kmc> which is why we have foldl'
08:47:59 <BMeph> mdmkolbe1: You should add something about stack frames in there, everyone HAS to use stack frames, amirite? ;p
08:48:00 <EvanR-work> :t mkStdGen
08:48:01 <lambdabot> Int -> StdGen
08:48:02 <kmc> @src foldl'
08:48:03 <lambdabot> foldl' f a []     = a
08:48:03 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:48:04 <EvanR-work> Int
08:48:12 <jmcarthur> well, if that's 64 bit then it's decent
08:48:17 <mdmkolbe1> I would suspect that the naive implementation of such a mapM (mapMaybe?) would be inefficient, because the after the failing Nothing, each call must return and check the Nothing value.  A better way is to use accumulator passing style, so when we see the Nothing, then we can get out quickly.
08:48:20 <EvanR-work> the generator has to be portable
08:48:27 <EvanR-work> so its probably using 32
08:48:33 <EvanR-work> bits of the Int
08:49:12 <EvanR-work> but maybe not
08:49:16 <jmcarthur> EvanR-work: data StdGen = StdGen Int32 Int32
08:49:34 * mdmkolbe1 hopes his last post didn't get clipped (It should end with "out quickly.")
08:49:35 <BMeph> @src mapM
08:49:35 <lambdabot> mapM f as = sequence (map f as)
08:49:44 <jmcarthur> EvanR-work: but according to the documentation:  "The 'StdGen' instance of 'RandomGen' has a 'genRange' of at least 30 bits."
08:49:52 <EvanR-work> jmcarthur: it has a 64bit state, but how it is seeded is critical here
08:50:14 <EvanR-work> ok not 64bit state. hrm confused
08:50:26 <BMeph> mdmkolbe1: sequence provides that "break out" functionality (where applicable) automatically.
08:50:32 <jmcarthur> EvanR-work: i think it's just that the spec is looser
08:50:35 <EvanR-work> and output range doesnt relate to state space necessarily
08:50:40 <mdmkolbe1> @src sequence
08:50:40 <lambdabot> sequence []     = return []
08:50:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:50:40 <lambdabot> --OR
08:50:40 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:50:50 <applicative> kmc, its easy to see the advantage of foldl' over foldl; still having trouble with the language of 'productiveness'.  I will think.
08:51:06 <jmcarthur> EvanR-work: you can seed it with two Int32s as well by using the Read instance
08:51:16 <fryguybob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25912#a25912
08:51:26 <kmc> applicative, if i write map using foldl, and then patternmatch on the first cell of the output list, it has to walk the whole input list and build a bunch of thunks
08:51:29 <EvanR-work> jmcarthur: check this out http://codepad.org/Rc6ZfWZY
08:51:47 <kmc> if i write map using foldr, it only looks at the first cell and then suspends its own computation
08:52:02 <EvanR-work> like half the outputs of less than 1/10 of the usual magnitude range of the output
08:52:18 * fryguybob goes to lunch...
08:52:19 <EvanR-work> (number of digits)
08:52:21 <_minoru> yitz, and how rnf, the benchmarking function, can help me?
08:52:28 <applicative> kmc, yeah,  I see it in the particular case, for sure.
08:52:44 <kmc> applicative, if you're wondering what's the precise definition of "productive" i'm not clear on it either :/
08:53:03 <_minoru> also, i've just installed StrictBench with cabal
08:53:07 <kmc> anyway this is a distinction present in a lot of languages, but usually the two kinds of thing also have different types, syntax to call, etc.
08:53:08 <EvanR-work> jmcarthur: well, its not conclusive. max is 2billion
08:53:11 <EvanR-work> :\
08:53:14 <applicative> kmc, i wasn't thinking of a definition, just an idea how i might be going wrong, but its good what you are saying
08:53:20 <kmc> e.g. generators vs. lists in Python
08:53:58 <jmcarthur> EvanR-work: doesn't look very different from http://codepad.org/KKswkrfn to my eyes
08:54:08 <byorgey> the precise definition of productive is that every recursive call is an argument to ("guarded by") a constructor.
08:54:17 <EvanR-work> jmcarthur: right
08:54:32 <byorgey> that way whnf reduction will stop at the constructor before actually evaluating the recursive call.
08:54:42 <jmcarthur> EvanR-work: not the difference in the code
08:54:44 <jmcarthur> *note
08:54:54 <EvanR-work> yes
08:54:57 <EvanR-work> no reseed
08:55:00 <kmc> mm
08:55:05 <EvanR-work> looking for a statistical test online
08:55:06 <yitz> _minoru: it forces a value to be completely calculated, not left lazy. if you make sure the error is calculated before you apply handleErrors to it, the right thing should happen.
08:55:17 <yitz> _minoru: use rdeepseq
08:55:21 <jmcarthur> yeah that would be way better than eyeballing
08:55:31 <kmc> byorgey, that's the termination condition used with codata, right?
08:55:33 <applicative> byorgey how does that apply to foldl' f a [] = a; foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:55:47 <ernst> EvanR-work: http://www.phy.duke.edu/~rgb/General/dieharder.php that one's a popular test suite afaik
08:55:54 <EvanR-work> downloading it
08:56:00 <kmc> so it's only safe to say that foldr is productive if the fold function guards its second argument by a constructor
08:56:01 <applicative> @src foldr
08:56:01 <lambdabot> foldr f z []     = z
08:56:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:56:02 <_minoru> yitz, in which package can i find it?
08:56:04 <yitz> here's what i was looking for earlier:
08:56:06 <kmc> for example, if the fold function is a constructor
08:56:32 <yitz> @unpl (.)(.)(.)(.)(.)(.)
08:56:33 <lambdabot> (\ i k l q r -> i (k l) (q r))
08:56:41 <yitz> @unpl (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
08:56:41 <lambdabot> (\ r u x z aa -> r (u x) (z aa))
08:56:47 <yitz> same function
08:56:58 <applicative> > foldr (:) 0 [1,2,3]
08:56:59 <lambdabot>   No instance for (GHC.Num.Num [a])
08:56:59 <lambdabot>    arising from a use of `e_10123' at <in...
08:57:10 <applicative> > foldr (:) [0] [1,2,3]
08:57:11 <lambdabot>   [1,2,3,0]
08:57:15 <yitz> _minoru: Control.Parallel.Strategies
08:57:57 <byorgey> kmc: indeed.
08:58:21 <k23z__> yitz, looks like a lot of tits
08:58:37 <byorgey> applicative: it doesn't.
08:58:46 <copumpkin> k23z__: not really
08:59:00 <byorgey> applicative: it applies to foldr though.
08:59:02 <byorgey> @src foldr
08:59:02 <lambdabot> foldr f z []     = z
08:59:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:59:29 <byorgey> correction, it CAN apply to foldr, if the function f introduces a constructor.
08:59:40 <alip> how can i collect the values of a monadic function into an IO List as long as another IO function (the predicate) returns IO Bool?
08:59:51 <EvanR-work> untilM
08:59:57 <jix> is it possible to detect from code if it's running in the threaded runtime or not?
08:59:58 <_minoru> yitz,     Couldn't match expected type `CGI CGIResult'
08:59:58 <_minoru>            against inferred type `Eval (m CGIResult)'
08:59:58 <_minoru>  of course
08:59:59 <byorgey> which is why you should use foldr for things like producing a list, where f involves a cons.
09:00:22 <yitz> _minoru: use pdeepseq
09:00:32 <byorgey> alip: write it yourself, or check out the IfElse library on Hackage
09:00:38 <applicative> yes, in the definition of with map f (x:xs) = f x : map f xs
09:00:46 <byorgey> applicative: exactly.
09:01:13 <byorgey> map f = foldr ((:) . f) []
09:01:21 <EvanR-work> yitz: heh. dieharder is refusing to build, tried different versions, tried AUR, tried tarballs ;)
09:01:26 <applicative> byorgey or rather map f (Cons x xs) = Cons (f x ) (map f xs)
09:01:30 <EvanR-work> its amazing because i built this before
09:01:32 <applicative> right
09:02:27 <_minoru> yitz,     Could not find module `Control.Strategies.DeepSeq' even with deepseq cabal package installed ><
09:02:41 <_minoru> also, what can be the matter with output?
09:02:55 <yitz> _minoru: no its in Control.Parallel.Strategies
09:02:58 <aristid> @djinn forall b c d. (b -> c) -> b -> d
09:02:58 <lambdabot> -- f cannot be realized.
09:03:06 <aristid> @djinn (b -> c) -> b -> d
09:03:06 <lambdabot> -- f cannot be realized.
09:03:15 <applicative> byorgey, the final result is going to be made up of Conses , a  Nil and say Ints, so with this def of map we get one step closer with each recursive step?
09:03:37 <dcoutts> _minoru: for future reference, "cabal info deepseq" will list the modules in that package
09:03:41 <_minoru> yitz, no, i can't find it there
09:03:47 <yitz> _minoru: it's not a problem with output.
09:04:10 <yitz> @hackage parallel
09:04:11 <lambdabot> http://hackage.haskell.org/package/parallel
09:04:29 <BMeph> kmc,byorgey: Is "productive" the conventional term, because I've noticed Sean Leather likes to use "incremental" - although, that may be a Dutch thing...
09:04:48 <copumpkin> yeah
09:05:00 <copumpkin> agda has a productivity checker
09:05:00 <byorgey> applicative: right.  and the point is that when evaluating, say, map (+1) [1,2,3], it evaluates to  (1+1) : map (+1) [2,3]
09:05:09 <byorgey> applicative: and now we know the top-level constructor, (:)
09:05:19 <Heffalump> byorgey: are you in Cambridge now?
09:05:24 <copumpkin> BMeph: it'll complain about something like concat (repeat [])
09:05:34 <byorgey> applicative: so the recursive call to map does not have to be evalauted until the rest of the list is actually pattern-matched against
09:06:04 <byorgey> BMeph: productive or "guarded recursion" are both fairly standard I think
09:06:23 <byorgey> I think "incremental" might be a different thing but I'm not sure, I've never heard that term used for this concept
09:06:46 <byorgey> Heffalump: no, my flight arrives at Heathrow at 9:30 tomorrow morning
09:06:53 <copumpkin> ugh heathrow
09:07:03 <BMeph> copumpkin: Is that about the "sequence" comment?
09:07:05 <applicative> byorgey.  It's obvious of course, but I think I hadn't seen it rightly; thanks.
09:07:12 <copumpkin> BMeph: the productive comment
09:07:30 <applicative> the role of the constructor I wasn't seeing
09:07:46 <Heffalump> I don't understand why everyone hates Heathrow so much. It has longish walks, but unless you have difficulty walking long distances they make a welcome change from being stuck on a plane anyway.
09:07:59 <byorgey> Heffalump: where do you live?  London?  I forget
09:08:02 * byorgey likes walking
09:08:09 <copumpkin> Heffalump: most of it is their fairly recent policy of not telling you the gate for your flight until the last minute
09:08:20 <copumpkin> Heffalump: which forces you to stay in the shopping area
09:08:24 <copumpkin> seems kind of shady, to me
09:08:37 * byorgey does not like shopping
09:08:46 <gwern> the name heathrow makes me hungry
09:09:00 <copumpkin> byorgey: I don't either, and am often sleepy and like to sleep at my gate :) but I can't find out my gate until just before the flight and then I need to walk over
09:09:06 <copumpkin> ;)
09:09:20 <yitz> Heffalump: or you just take the tube
09:09:42 * applicative wonders why its heathrow not swamprow or meadowrow, what would such things be?
09:09:44 <Saizan> copumpkin: how much is "just before"?
09:10:01 <copumpkin> Saizan: 40 minutesish? pretty much right around boarding
09:10:13 <copumpkin> they've claimed it's a security measure
09:10:21 <gwern> lies
09:10:27 <copumpkin> but it seems awfully sketchy to force people to stay around a bunch of shops
09:10:29 * BMeph is reminded of Heath Ledger when he sees/hears "Heathrow"
09:10:36 * gwern has become very cynical about security measures since 9/11
09:10:43 <gwern> BMeph: I am reminded of heath bars
09:10:51 * copumpkin has never had a heath bar
09:10:56 <Saizan> ah, then Pisa and Luton do the same (which are the only two airports where i've taken a flight)
09:11:15 <copumpkin> gatwick is much more pleasant, I think
09:11:23 <copumpkin> or stansted
09:11:52 <copumpkin> they also just have nicer atmospheres, but that's hard to quantify :P
09:11:58 <Heffalump> byorgey: about 20 miles from Cambridge
09:12:03 <BMeph> gwern: Mmmm...toffee! :)
09:12:15 <Heffalump> copumpkin: are you saying you don't have the willpower to resist shops?
09:12:39 <Heffalump> what really does annoy me is being forced to walk through a shop to get from place to place, which seems to be a relatively new innovation at airports
09:12:47 <_minoru> yitz, and with what?
09:13:10 <copumpkin> Heffalump: no, I'd just like to relax at my gate and possibly take a nap there on layovers. Which is hard when I need to keep an eye on the screen up until the last minute and then sometimes walk 20 minutes to my gate after that
09:13:36 <Heffalump> copumpkin: fair enough
09:13:36 <kmc> you should definitely get stoned before you fly
09:13:41 <copumpkin> kmc: lol
09:13:50 <kmc> not kidding
09:14:03 <Heffalump> Heathrow is never somewhere I have to layover at so that hadn't occurred to me
09:14:13 <kmc> half the people flying are either stoned or drunk or on xanax
09:14:18 <kmc> or all three
09:14:22 * applicative vows to make each step in the unpacking of a recursive definition supply something for pattern matching.
09:14:35 <kmc> and i can't imagine being drunk on an airplane is very pleasant.  never tried it.
09:14:45 <yitz> _minoru: that handleErrors sees a lazy unevaluated value. there is no exception, so it says "fine" and passes it on to runFastCGI. But then runFastCGI forces the value to be evaluated; it throws an exception, but handleErrors is already out of the picture.
09:15:34 <copumpkin> Heffalump: I often stop there to/from rome (and have spent some time there on the way to japan) and have grown to hate it :P
09:15:41 <yitz> _minoru: we want to make sure that the exception is thrown when handleErrors can still see it and catch it.
09:15:44 <copumpkin> I didn't mind it when I first started
09:15:54 <Heffalump> I guess I just don't fly enough :-)
09:15:59 <copumpkin> but then again I hate most airports
09:17:42 <yitz> a major hospital here recently built a shopping center at the entrance. now the only way in to the hospital is to walk all the way through the first level of the shopping center, up the escalator, and all the way throught the second level. so that you'll pass all of the shops. even to get to the emergency room!
09:18:11 <copumpkin> I'd hope that the actual service entrance (for ambulances) isn't that way :P
09:19:06 <quicksilver> yitz: there is no medical emergency so severe I wouldn't browse around the apple shop on the way and admire the shiny expensive things.
09:19:06 <yitz> copumpkin: yes, but *only* for ambulances. private vehicles not allowed, even if they have a doctor's referral as an emergency. not even a taxi.
09:19:12 <copumpkin> wow
09:19:20 <Saizan> quicksilver: and bleed on them.
09:19:25 <quicksilver> Saizan: they wipe clean.
09:19:30 <kmc> where is this?
09:19:33 <copumpkin> retail therapy for all non-ambulance patients!
09:19:47 <yitz> copumpkin: so if you're not sure you'll convince your health plan to pay for an ambulance - it's shopping time
09:20:11 <yitz> or use a different hospital :)
09:20:48 <BMeph> byorgey: It looks like Sean uses "incremental" explicitly with folds/algebras, so it might be the same thing, or your term may be a superset. Thanks for the info. :)
09:20:58 <yitz> the fun case is when it's, say, an ankle injury. or intense intestinal pain.
09:21:12 <yitz> e.g., appendicitis.
09:21:44 <kmc> yitz, what country is this in?
09:21:47 <yitz> israel
09:22:00 <kmc> heh
09:22:15 <kmc> i will bring this up next time someone claims that America is the only country with problems with capitalism run amok
09:22:28 <yitz> kmc: indeed
09:22:38 <EvanR-work> america is the only country with problems with capitalism run amok
09:22:44 <BMeph> kmc: One word: bazaar. Hint: it's not an American invention. ;)
09:22:48 <EvanR-work> oops
09:22:48 <kmc> hehe
09:22:52 <EvanR-work> bad timing :)
09:23:12 <yitz> bazaar is middle eastern
09:23:26 * BMeph clicks on instantrimshot.com for EvanR...
09:23:57 <BMeph> yitz: ...and Israel is Near Eastern? ;)
09:24:02 <copumpkin> kmc: surely you mean amerikkka
09:24:05 <kmc> right copumpkin
09:24:20 <copumpkin> just making sure
09:24:36 <yitz> bazaar is actually persian.
09:24:51 <Twey> I don't think it's possible for capitalism to not run amok >.>
09:24:53 <Saizan> well, unless isreal has a political and economic system very similar to US
09:25:17 <yitz> they're trying hard
09:25:19 <byorgey> BMeph: yeah, I'm not sure, I keep meaning to read Sean's stuff about incrementalization, but haven't gotten around to it yet, so I don't know exactly what he means by it yet =)
09:25:33 <tibbe> please go to #haskell-blah
09:26:23 <alip> is there any library that does natural date parsing in haskell?
09:26:38 <alip> like converting time_t to "tomorrow", "in 2 days" etc.
09:26:49 <kmc> that's the opposite of parsing
09:27:01 <alip> oh yes, sorry
09:27:03 <benmachine> I wrote something for that recently
09:27:32 <alip> benmachine: mind sharing? ;)
09:27:32 <benmachine> it's quite hard to do a general library though
09:27:46 <benmachine> because things like "how many days before you measure in weeks" are going to be personal taste
09:27:53 <benmachine> alip: sure, but no warranty :)
09:28:06 * benmachine fetches
09:29:45 * benmachine fiddles
09:30:57 <Twey> ‘I have only days to live!!’
09:31:21 <Twey> 18250 days, but hey
09:33:19 <copumpkin> we need more rome haskellers
09:33:24 <copumpkin> so we can start a rome hug
09:33:29 * benmachine hugs copumpkin 
09:33:35 <copumpkin> aw thank you
09:33:35 <benmachine> does that help
09:33:40 <copumpkin> yep
09:33:41 <copumpkin> thanks
09:33:43 <benmachine> :)
09:33:59 <benmachine> alip: do you care about timezones
09:34:12 <benmachine> alip: this code handles them badly (which is worse than not handling them at all)
09:34:19 <alip> not really
09:34:21 <benmachine> I'm going to fix it
09:34:26 <alip> cool
09:34:27 <benmachine> you can have it before or after I do so :P
09:34:35 * alip prefers after
09:34:35 <benmachine> with no guarantees on when the latter is
09:34:37 <benmachine> k
09:36:29 <gwern> Twey: you only have a few nanoseconds left and no chance to survive, make your time
09:38:24 * BMeph prefers "light-feet" to nanoseconds; it's an Imperial thing...
09:44:35 <Twey> BMeph: Haha
09:44:57 <Twey> We should have Planck-time–based units
09:46:45 <winxordie> Twey: Planck-time's always changing; it'd be a hard one to keep up with.
09:46:54 <winxordie> or so I'm told.
09:47:29 <burp> but CReal based please
09:47:42 <Twey> Really?  How does that work?
09:47:45 <burp> hm, not necessary
09:48:02 <scree> 1 kb ~ 7.839693723928516e-20 J/K
09:48:18 <copumpkin> joules per kelvin?
09:48:24 <scree> copumpkin: yes
09:48:37 <copumpkin> interesting
09:49:19 <benmachine> alip: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25913#a25913 ignores timezones altogether
09:49:29 <benmachine> I wanted to do it slightly differently with timezones
09:49:36 <benmachine> but, whatever
09:49:42 <benmachine> I have to go now so that's all you get :P
09:49:57 <Ke> scree: awesome interpretation =o)
09:50:39 <scree> (not original :| )
09:52:30 <Hunner> time is relative, but as far as it can be defined as constant, and there are no variables in the equation for plancks time, it should be constant also
10:00:43 <EvanR-work> jmcarthur: finally got 1000000 values from wonky generator into a working version of dieharder i had on my home computer. so far it passes the birthday test :\
10:01:07 <EvanR-work> 1000000 isnt really enough, but php isnt that fast
10:01:51 <EvanR-work> failed the next test because not enough data
10:01:56 <jmcarthur> ah
10:02:15 <EvanR-work> (it repeats when it gets to the end of file)
10:02:26 <jmcarthur> you are testing twister?
10:02:55 <EvanR-work> this is mt_rand, which is supposedly a form of mersenne twister, but only one number is generated at a time and the seed is incremented
10:03:03 <jmcarthur> right
10:03:08 <jmcarthur> you could try the haskell version
10:03:13 <jmcarthur> should be faster and won't time out on you
10:03:19 <EvanR-work> then im not testing php
10:03:33 <jmcarthur> but i thought you were just trying with incremented seeds
10:03:41 <jmcarthur> shouldn't be specific to php
10:04:12 <chrisdone> w'sup
10:06:05 <EvanR-work> jmcarthur: we know it doesnt work in general
10:06:12 <EvanR-work> using php at work
10:14:16 <deech> Hi all, anyone here have trouble installing the "encoding" with ghc 6.12.1?
10:14:48 <deech> I'm getting a conflict with a dependency on "filepath".
10:15:45 <Saizan> deech: which error do you get?
10:16:10 <leimy> I'm wondering how difficult people find it in experience to go from String to ByteString
10:16:22 <deech> cabal: dependencies conflict: ghc-6.12.1 requires filepath ==1.1.0.4 however
10:16:22 <deech> filepath-1.1.0.4 was excluded because ghc-6.12.1 requires filepath ==1.1.0.3
10:16:22 <deech>  
10:16:35 <Saizan> ah
10:16:53 <chrisdone> leimy: not very?
10:16:57 <Saizan> deech: you probably have two installations of the same version of the same package
10:17:17 <Saizan> deech: that confuses both cabal and ghc, you should unregister one of them
10:17:39 <deech> Saizan: which one do you recommend? Should I unregister the older version?
10:18:26 <Saizan> deech: well, if one is in the global and the other is in the user, i'd unregister the latter
10:19:17 <Saizan> deech: maybe paste your "ghc-pkg list" if you're unsure what to do
10:19:19 <leimy> chrisdone: I'm just about to try it, and wondered if there were many pitfalls :-)
10:19:23 <deech> Saizan: I tried, but I get a message saying that it will break Cabal-1.8.0.2
10:19:40 <LeonelFonseca> Hi everybody. Is there a function for this repeated pattern I'm having: (liftM concat . sequence) ?
10:20:16 <ezyang> @pl liftM concat . sequence
10:20:16 <lambdabot> fmap join . sequence
10:20:44 <deech> Saizan: I'll do that.
10:20:44 <LeonelFonseca> Thanks , ezyang
10:21:17 <ezyang> erm, that's not terribly an improvement
10:22:09 <mauke> :t liftM concat . sequence
10:22:10 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
10:22:19 <Cale> LeonelFonseca: yeah, the answer is "not really"
10:22:24 <BMeph> So, [m[a]] -> m[a]...mconcat? :)
10:22:37 <ezyang> :t mconcat
10:22:38 <lambdabot> forall a. (Monoid a) => [a] -> a
10:22:50 <ezyang> :t liftM mconcat
10:22:51 <lambdabot> forall a (m :: * -> *). (Monoid a, Monad m) => m [a] -> m a
10:23:01 <ezyang> not... really
10:23:08 <zygoloid> ezyang: msum?
10:23:15 <pastorn> @type msum
10:23:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:23:18 <zygoloid> hmm, no
10:23:25 <ezyang> Looks more plausible
10:23:26 <BMeph> Or, whatever MonadPlus' version of mconcat should be called.
10:23:27 <Cale> You'd need an appropriate monoid instance for msum
10:23:43 <Cale> Er, or mconcat :)
10:23:49 <Cale> rather
10:24:07 <pastorn> LeonelFonseca: where do you get that [m [a]] from?
10:25:40 <zygoloid> @type liftM concat . mapM id
10:25:41 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
10:26:00 <BMeph> Too bad you can't (always) go  m[a] -> [m a]
10:26:51 <LeonelFonseca> mapM monadicFunction  listOfParameters {- then I concat the results -}
10:26:55 <zygoloid> @check \xs -> mapM id xs == sequence (xs :: [Maybe [Int]])
10:26:56 <lambdabot>   "OK, passed 500 tests."
10:27:07 <zygoloid> there, saved you 1 character
10:27:54 <pastorn> zygoloid: haskell super hero
10:28:43 <rajeshsr> is it ok to install haskell in Mac with Mac ports?
10:28:44 <lambdabot> rajeshsr: You have 1 new message. '/msg lambdabot @messages' to read it.
10:29:57 <LeonelFonseca> I wasn't aware of mconcat.
10:30:12 <bluet> Why is this signature wrong? 2dto3d :: (GLfloat, GLfloat) -> (GLfloat, GLfloat, GLfloat)
10:30:54 <mauke> because 2 dto3d is not an identifier
10:30:56 <Cale> bluet: Because the name starts with a number.
10:31:11 <bluet> Oh.
10:31:18 <mauke> > let dto3d = 40 in (+) 2dto3d
10:31:18 <lambdabot>   42
10:31:24 <Cale> haha
10:31:30 <rajeshsr> Cale: great! It was good to see ur haskell implementation. Lemme check out when i get free..
10:31:39 <rajeshsr> thanks
10:31:45 <Cale> rajeshsr: Oh, the BF interpreter?
10:31:58 <rajeshsr> yep!
10:32:04 <rajeshsr> just saw ur msg..
10:32:23 <c_wraith> seriously, haskell's lexer doesn't report an error on a digit followed immediately by a letter?  That sounds like a rule chosen only to allow more confusing code. >_>
10:32:47 <rajeshsr> oh, u used lexers for this?
10:32:50 <Cale> rajeshsr: yeah, I hammered that out when we were talking about it before. It would perhaps have been prettier if I'd used ContT over a State monad rather than just passing parameters manually, but it works :)
10:32:52 <BMeph> Cale: Ooh, a BF interpreter? Did you cheat, and use a Word16 for the space?
10:32:59 <mauke> c_wraith: C gets it right!
10:33:21 <rajeshsr> BMeph: wats cheating with word16?
10:33:49 <rajeshsr> BTW, can anyone tell me the best way to hAVE HASKELL IN MAC?
10:33:53 <deech> Hi all, I make a mistake removing Cabal using ghc-pkg and now my ghc package appears as {ghc-6.12.1} and I can't install packages that require ghc. I tried to "sudo ghc-pkg expose ghc-6.12.1" but it doesn't work. Any help is appreciated.
10:33:54 <rajeshsr> oops! :)
10:34:15 <BMeph> rajeshsr: The definition "encourages" 30000 for the size, but doesn't demand it, so implementations that use a larger one, I call "cheats". :)
10:34:21 <Cale> BMeph: It was nothing special
10:34:27 <zygoloid> > please 0xfeedmecake
10:34:28 <lambdabot>   "yum"
10:34:35 <yitz> rajeshsr: i've used both macports and the native installer
10:35:00 <yitz> rajeshsr: they both work well. slight differences.
10:35:27 <rajeshsr> BMeph: haha! I would think infinite memory is the design! The have no clue as to how would they do it well with C and make it minimal. Thats the reason they came up with that stupid rule!
10:35:44 <rajeshsr> yitz: hmm, ok.
10:36:01 <rajeshsr> By native intsller you mean the one at haskell.org?
10:36:25 <yitz> rajeshsr: i'm using the HP install version now. main issue is that i haven't been able to install the readline package
10:36:32 <yitz> haskell platform, yes
10:36:34 <fryguybob> > let e1 = 1 in (+) 1e1e1
10:36:34 <lambdabot>   11.0
10:37:09 <rajeshsr> yitz: oh, ok. so better go with Mac ports, is it?
10:37:44 <zygoloid> > (+) 0o428
10:37:45 <lambdabot>   42
10:37:48 <yitz> rajeshsr: because "readline" on the mac isn't really readline, so it won't install. i also wasn't able to convince the non-macports haskell to use the macports readline.
10:38:33 <rajeshsr> yitz: oh, ok!
10:38:47 <yitz> rajeshsr: macports then means you have to compile ghc and all of its dependencies. takes a lot of time, both at the beginning and later for updates.
10:38:57 <yitz> rajeshsr: other than that, they both work great.
10:39:28 <yitz> also macports eats up quite a bit of disk space. i have an old macbook though.
10:39:32 <rajeshsr> hmm, getting from haskell platform makes it easier with n compilation step, is it?
10:39:45 <rajeshsr> i really am not ready to compile! :)
10:40:01 <yitz> rajeshsr: it's all automatic. just takes time.
10:40:05 <rajeshsr> I thought mac ports provides some package for Mac like .deb etc..
10:40:11 <rajeshsr> am new to Mac, BTW
10:40:32 <yitz> rajeshsr: that's fink. but there isn't a recent haskell package on fink, last i looked.
10:40:52 <rajeshsr> I tried compiling in my Linux PC. Took a hell of time! Definitely not ready to do it again!
10:40:57 <yitz> macports is like BSD ports. Darwin is a BSD derivative after all.
10:41:05 <rajeshsr> oh!
10:41:27 <rajeshsr> BTW why would we need Mac ports at all?!
10:41:40 <rajeshsr> we can always get the src and compile by ourselves!
10:41:43 <yitz> rajeshsr: it's faster than it used to be. leave it run for a few hours. maybe start it up before you go to sleep, usually it just goes.
10:42:17 <yitz> rajeshsr: there's a huge amount of fiddling to configure lots of different source package all to compile with each other
10:43:05 <rajeshsr> isn't that what ./configure script makes it for you?
10:43:22 <rajeshsr> it makes the Makefile right, after all..
10:43:31 <yitz> rajeshsr: an all kinds of parameters you have to learn how to set right for each and every package. etc. macports is basically just like a binary package, except it takes longer.
10:43:35 <rajeshsr> you need some tweaks in Mac?
10:43:53 <jamwt> heyall.. just getting going here on haskell.. trying to master the whole "golfing with monads" idioms..
10:44:30 <IRCSTINKS> @src group
10:44:30 <lambdabot> group = groupBy (==)
10:44:51 <jamwt> so, questino.. given `unless`, where the condition is type bool, not IO Bool, how do you avoid doing this: ioCondition >>= \x-> unless(x) ioAction
10:45:17 <jmcarthur> @pl ioCondition >>= \x-> unless(x) ioAction
10:45:17 <lambdabot> flip unless ioAction =<< ioCondition
10:45:20 <yitz> rajeshsr: except in practice it's alway ./configure --with-foo==bar, --ldflags=xyz ... different for every package. and you have to learn what the dependencies are, exactly what versions of what work with each other, etc. sometimes you need to go in and make manual patches to source code. fun to do it and learn all that stuff, but...
10:45:21 <jmcarthur> eh
10:45:23 <IRCSTINKS> why div a b is not defined when a<0 ?
10:45:32 <jmcarthur> (`unless` ioAction) =<< ioCondition
10:46:18 <jamwt> jmcarthur: ah, thanks.. I tried doing a =<< move but obviously didn't get it quite right
10:46:20 <yitz> > div (-2) 6
10:46:20 <lambdabot>   -1
10:46:23 <rajeshsr> yitz: ha, ok!
10:46:32 <yitz> > div (-6) 2
10:46:33 <lambdabot>   -3
10:46:46 <jamwt> I don't think I'd seen that before.. doing infix-prefix or whatever that trick is
10:46:56 <mauke> sections?
10:47:05 <mauke> > (* 2) 3
10:47:06 <lambdabot>   6
10:47:56 <yitz> > 0xfeedmecake
10:47:57 <lambdabot>   65261
10:48:07 <yitz> > 0xfeedmecandy
10:48:08 <lambdabot>   Not in scope: `mecandy'
10:48:32 <yitz> @type please
10:48:33 <lambdabot> forall t t1. t -> t1 -> [Char]
10:49:13 <yitz> > please "eat some" "rotten eggs"
10:49:13 <lambdabot>   "yum"
10:49:23 <mauke> :t mecake
10:49:24 <lambdabot> forall a. a
10:49:30 <tromp> > mecake
10:49:31 <lambdabot>   *Exception: Prelude.undefined
10:49:47 <yitz> secrets exposed
10:49:48 <mauke> > 1 2
10:49:49 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:49:49 <lambdabot>    `GHC.Num.Num t' arising f...
10:50:52 <chrisdone> all i ever see in my gmail is Do you think in closures?
10:51:37 <yitz> chrisdone: look in Spam
10:51:51 <BONUS> you can do: let unless m b = b >>= \b' -> when (not b') m, so that then you can do stuff like print 3 `unless` skyIsBlue
10:52:00 * chrisdone pokes BONUS
10:52:19 <BONUS> peekaboo
10:52:28 <djahandarie> Isn't unless already defined?
10:52:32 <djahandarie> :t unless
10:52:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:52:37 <djahandarie> @src unless
10:52:37 <lambdabot> unless p s = if p then return () else s
10:52:53 <yitz> BONUS meant unlessM
10:52:59 <BONUS> ah, ya
10:53:02 <BONUS> also flipped
10:53:26 <chrisdone> BONUS: i'm getting up to type classes on tryhaskell! http://tryhaskell.org/ also how's the book publishing going?
10:54:11 <yitz> somehow, "skyIsBlue `unlessM` print 3" just doesn't have that ring to it
10:54:44 <BONUS> chrisdone: oh nice! keep on rockin! book publishing is going well, still editing and such, but i think we're aiming for a fall release
10:54:53 <gwern> Cale: note that c.h.o is unusably slwo right now, and people are having issues in #xmonad
10:54:55 <kmc> "Do you think in closures? Congratulations, you understand the most fundamental programming language feature"
10:54:58 <chrisdone> nice :D
10:54:58 <gwern> Cale: as I said, weekly basis...
10:55:17 <gwern> Cale: but perhaps I should amend that to 'daily' :)
10:55:35 <djahandarie> *.haskell.org has been having problems lately
10:55:36 <chrisdone> BONUS: i'll be buying a copy on principal, handing it to my colleages
10:56:12 <yitz> gwern: i keep restarting services. the thing is really dying. we're making progress on moving - we've got to really get a move on now though
10:56:28 <Botje> BONUS: i'll buy a copy for the pictures!
10:56:45 <BONUS> chrisdone: high five! tell them that if you read it backwards you get satanic messages
10:57:33 <BONUS> Botje: haha, i wonder if little kids would like LYAH
10:57:54 <chrisdone> BONUS: I believe the first thing my colleagues will ask is if it contains satanic messages read in normal order :p
10:57:58 <chrisdone> (lispers, pfft)
10:58:06 <BONUS> chrisdone: i think it does that too
10:58:12 <BONUS> basically there are satanic palindromes
10:58:34 <chrisdone> haha
10:59:13 <yitz> read backwards, it is an introductory guide to programming in FORTH.
10:59:19 <BONUS> lol
10:59:32 <chrisdone> so that's why it's so expensive, two books in one!
11:00:04 <djahandarie> Heh http://blog.plover.com/prog/haskell/logo.html
11:00:06 <chrisdone> BONUS: i went to see Them Crooked Vultures btw. i'm waiting for another album or three
11:01:09 <BONUS> chrisdone: ooh, im jealous! were they good
11:01:57 <chrisdone> BONUS: perfect! energetic, LOUD, funny, did i mention LOUD?
11:02:05 <BONUS> awesome
11:02:15 <yitz> djahandarie: fortunately for us, amtrak changed their logo
11:02:39 <chrisdone> yitz: haha
11:03:01 <BONUS> did you know: haskell is used extensively in trains
11:03:03 <chrisdone> they feared the pointy arrows and functoring data types
11:03:15 <chrisdone> really?
11:03:26 <yitz> m-m-m-mo-nads-s-s ??
11:03:47 <chrisdone> i travelled to italy for a haskell job therefore i am a haskell nomad
11:04:18 <EvanR> Nomad
11:04:55 <chrisdone> that's what i said
11:04:59 <BONUS> chrisdone: probably not
11:05:15 <Starfire> Wow, I feel as though I've finally started to understand arrows a little bit.
11:05:28 <chrisdone> Starfire: what's the point of arrows?
11:06:20 <mauke> -->·
11:06:52 <chrisdone> teehee
11:06:58 <Starfire> I guess it's the sharp end.
11:07:09 <Kaidelong> hey, my assumption for hClose was that, to keep things deterministic, all things that are going to be working with the file will finish what they are doing
11:07:20 <Kaidelong> is this assumption wrong?
11:07:37 <chrisdone> reet i better bugger off to the cinema, ciao
11:07:49 <Kaidelong> IE is it possible to close a file before lazy operations on it are run?
11:08:00 <yitz> Kaidelong: unfortunately, yes
11:08:01 <chrisdone> no, they will error
11:08:05 <Saizan> lazy operations like hGetContents? yeah
11:08:18 <Kaidelong> ok, that's a bit troubling
11:08:24 <yitz> chrisdone means: so no, don't do that
11:08:24 <Kaidelong> so how do I force those to finish?
11:08:28 <Saizan> hClose only gets writes flushed out
11:08:32 <chrisdone> but it's best to avoid lazy io all together!
11:08:38 <Saizan> Kaidelong: you force their result
11:08:53 <yitz> @hoogle evaluate
11:08:53 <lambdabot> Control.Exception evaluate :: a -> IO a
11:08:53 <lambdabot> Control.OldException evaluate :: a -> IO a
11:08:53 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
11:09:12 <Saizan> evaluate is not really needed nor really solves the problem by itself :)
11:09:41 <monochrom> heh, unnecessary and insufficient condition
11:09:44 <yitz> yeah. it's not always easy or reliable to force a lazy IO to complete.
11:10:13 <Saizan> Kaidelong: are you sure you need to hClose explicitly? hGetContents will close it when it gets to the end of the file
11:11:28 <Kaidelong> Saizan: I did not know that
11:11:38 <Kaidelong> perhaps I don't then
11:13:15 <yitz> Kaidelong: usually it's only needed if you'll have lots of file handles open and you need to close some before opening others. in that kind of complex situation - just don't use lazy IO. Otherwise, just don't use hClose.
11:13:51 <Kaidelong> hmm
11:14:05 <Kaidelong> okay, now I need to figure out if my problem was being caused by hClose or a logic error
11:15:47 <haploid> ok so
11:16:15 <haploid> after less than a week of learning/playing with haskell, I am already getting annoyed by Java at my "day job"
11:16:24 <haploid> this is aggravating
11:16:41 <sclv> welcome to the rest of your life :-)
11:17:22 <sclv> (actually, you can incrementally push to clojure or scala where haskell idioms translate more easily)
11:18:03 <alip> benmachine: thanks
11:18:59 <_minoru> yitz, rkit from haskell@conference.jabber.ru proposed a such solution: runCGI $ handleErrors $ output $! error "something" and it works fine
11:19:44 <haploid> yeah I think I'm a long way away from truly grokking FP idioms for regular use, but I just find myself writing for/if combinations where it would be damn nice to use a list comprehension
11:20:09 <haploid> scala in production maybe next year :)
11:20:26 <yitz> _minoru: that will only work in that case where the error call is at the top level. if you are trying to debug real code and it's buried deep inside, that still might not work, unfortunately.
11:20:58 <yitz> _minoru: i think we should raise this issue with the maintainers of cgi and fastcgi.
11:50:07 <MacMagnus> is there a function that easily converts an Integer to a Double?
11:50:19 <mauke> fromInteger
11:50:27 <Zao> @hoogle Integer -> Double
11:50:28 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
11:50:28 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
11:50:28 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:50:48 <MacMagnus> thanks :D
11:51:22 <sclv> @quote fromIntegral
11:51:22 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
11:51:31 <sclv> @quote fromIntegral
11:51:31 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
11:52:59 <Cale_> MacMagnus, fromIntegral is particularly notable, because it doesn't just convert from Integer to any type of number, but from any integer-like number to any type of number. This makes it a good answer to most questions about how to convert between two sorts of numbers.
11:53:07 <sclv> @quote monochrom fromIntegral
11:53:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:53:11 <sclv> That's the one.
11:53:28 <monochrom> yes
11:53:59 <sclv> That poem will be your greatest legacy :-)
11:54:21 * EvanR-work rocks the boat and explains the use of fromEnum ;)
11:54:39 <MacMagnus> :) but the type is still Integer.... frmoIntegral 4; :type it; it :: Integer
11:55:01 <sclv> MacMagnus -- that's because of defaulting
11:55:16 <c_wraith> MacMagnus, that's because you're making ghci force it into a monomorphic type, and it defaults to integer for numbers
11:55:55 <MacMagnus> ah, so it would work out for functions like sqrt... :)
11:56:10 <mauke> > sqrt 4
11:56:10 <lambdabot>   2.0
11:57:54 <EvanR-work> jmcarthur: i tested 2097152 samples of the wonky mt gen, and it failed miserably diehard_bitstream test
11:58:38 <MacMagnus> if a and n are Integer, fromInteger a <= sqrt n doesn't work...
11:58:52 <EvanR-work> so i may have enough evidence to justify spending all morning investigating this
11:59:10 <mauke> > let a, t :: Integer; a@t = 42 in fromInteger a <= sqrt n
11:59:11 <lambdabot>   True
11:59:25 <mauke> > let a, n :: Integer; a@t = 42 in fromInteger a <= sqrt n
11:59:26 <lambdabot>   The type signature for `n' lacks an accompanying binding
11:59:26 <lambdabot>    (You cannot giv...
11:59:33 <mauke> why do I fail so much
11:59:46 <fryguybob> let a = 2 :: Int in (sqrt . fromIntegral) a
11:59:46 <fryguybob> > let a = 2 :: Int in (sqrt . fromIntegral) a
11:59:47 <mauke> > let a, n :: Integer; a@n = 42 in fromInteger a <= sqrt (fromInteger n)
11:59:47 <lambdabot>   False
11:59:47 <lambdabot>   1.4142135623730951
12:00:18 <c_wraith> I'm beginning to think <$> is the best operator in the language.
12:00:38 <c_wraith> Or at least the one I use most in code that has to deal with maybes everywhere.
12:01:00 <c_wraith> "Every single value in this construct is optional!  enjoy!"
12:07:21 <sinelaw> howdy, nats!
12:08:35 <sinelaw> don't be too active
12:10:31 <MacMagnus> > let a,n :: Int; a@n = 42 in (fromIntegral a) <= sqrt (fromIntegral n)
12:10:32 <lambdabot>   False
12:11:35 <sinelaw> let a,n :: Int; a@n = 42 in (a,n)
12:11:40 <sinelaw> > let a,n :: Int; a@n = 42 in (a,n)
12:11:41 <lambdabot>   (42,42)
12:11:58 <sinelaw> intriguing.
12:14:34 <navaati> hello
12:14:38 <sinelaw> hi
12:16:21 <navaati> I've got a problem with cabal and ghc : i can install a package with cabal-install (the one from debian), but when i want to compile a program requiring it, ghc can't find it
12:16:36 <navaati> is it supposed to work ?
12:16:56 <sinelaw> you need to tell ghc which packages to use
12:17:18 <sinelaw> don't remember how
12:17:22 <sinelaw> how are you running ghc?
12:17:38 <navaati> oh, i thought it could find it from import directives
12:17:42 <shapr> Anyone working on berp?
12:17:43 <navaati> ghc --make
12:17:48 <navaati> (or runhaskell)
12:18:04 <navaati> ok, i remember now there is something in ghc's man
12:18:35 <shapr> ghc -package foo --make Bar ?
12:18:39 <navaati> thanks for the tip, it was stupid xD
12:18:41 <shapr> for Bar.hs that is
12:18:56 <navaati> sharp, yes, it's this
12:19:04 * shapr feels sharp
12:19:25 <navaati> oops
12:19:30 * sinelaw permutes shapr
12:19:34 <monochrom> monochrom feels monochrome
12:19:46 <sinelaw> sinelaw feels sanslaw
12:20:05 <sinelaw> 8-P
12:20:56 <geheimdienst> what's the opposite of monochrome, polychrome? i mean, what's the big word for "colored"?
12:21:18 <Guest78851> hi, i need some help with type declaration
12:21:38 <sclv> polychromatic
12:21:42 <wli> polychrome / polychromatic
12:22:01 <Guest78851> is there a way to define a type in terms of list comprehension?
12:22:15 <sclv> huh?
12:23:35 <Guest78851> i need a finite type that is a subtype of Int
12:23:45 <mauke> there are no subtypes
12:24:34 <sclv> You need to enforce it yourself
12:24:42 <shapr> Guest78851: What are you trying to do? Limited Ints?
12:24:43 <sclv> newtype LimitedInt = LimitedInt Int
12:24:58 <EvanR-work> newtypes can have instances?
12:25:13 <sclv> mkLimitedInt x = if x > limit then error "uh oh" else LimitedInt x
12:25:24 <Guest78851> so it's impossible to define something like data Nat = [x | x <- [0..]] ?
12:25:30 <sclv> EvanR-work: yep!
12:25:45 <sclv> Guest78851: for nat you can cheat :-)
12:25:46 <sclv> by defining it inductively
12:26:17 <sclv> see http://hackage.haskell.org/package/nat for a very clever implementation
12:26:42 <sclv> Even in that one though, 3 - 10 will yield a runtime error.
12:26:55 <sclv> If you ban subtraction, things get easier :-)
12:27:04 <flosit> hi, I try to define a datatype recursively
12:27:14 <Guest78851> defining it inductively will make it infinite
12:27:26 <flosit> after studieng the tutorial i got something like this:
12:27:33 <flosit> data Relation = Entity | (Entity, [Relation])
12:27:39 <mauke> flosit: that's invalid
12:27:42 <sclv> Guest78851: right. But if you define it inductively and strictly you can disallow infinity at least.
12:27:48 <mauke> flosit: you're mixing data constructors with types
12:27:55 <flosit> oh, ok
12:28:04 <sclv> But you can't have, e.g., only one through ten withoug being somewhat clever.
12:29:03 <sclv> you can work with modular numbers very easily though, and only pay the cost of a smart constructor.
12:29:10 <Guest78851> i had the wishful thinking of defining it like list comprehension, like a higher order type comprehension
12:29:13 <flosit> is there any way to describe a type, that means something like:  'a relation is an entity or an entity with a list of relations'?
12:29:30 <flosit> perhaps i understand something wrong with types in haskell
12:29:45 <mauke> flosit: do you really need to distinguish between no list and an empty list?
12:30:04 <sclv> data Relation = RelEntity Entity | RelEntityAndThen Entity [Relation]
12:30:17 <sclv> but makue is right that you can do just data Relation = Relation Entity [Relation]
12:30:28 <mauke> data Relation = Foo Entity (Maybe Relation) -- if you do
12:30:36 <mauke> er, Maybe [Relation]
12:30:41 <flosit> oh, of course, thanks
12:30:50 <flosit> didnt thought of empty list...
12:31:08 <yitz> flosit: data Relation = Relation Entity [Relation] -- because the list can be empty
12:31:22 <flosit> thanks folks
12:31:44 <flosit> just for the beginner: why do i need the 'Relation' after '='?
12:32:06 <sclv> flosit: The relation after the = is a constructor
12:32:11 <sclv> The "Relation" before the = is the name of the type
12:32:24 <sclv> so we have data Either a b = Left a | Right b
12:32:39 <flosit> a alright, i think i have to do much more reading on types in general, thanks to all
12:32:42 <sclv> Either is in the type signatures, but to create one you either use the Left or Right constructor.
12:33:20 <Guest78851> thanks for helping me, sclv
12:33:42 <soupdragon> shapr come to #epigram ?
12:33:59 <navaati> has anybody here ever played with the alsa package ?
13:15:50 <alexyk> I compiled with --make -prof -fforce-recomp, but only get toplevel for a whole module in report.  Do I have to place SCCs on each function under a module myself?
13:20:07 <Choko> alexyk: use -auto-all
13:20:08 <ClaudiusMaximus> alexyk: try adding -auto-all
13:20:12 <Choko> :D
13:21:48 <alexyk> well that's what I did, but don't get things in a module, just top functuin there, not its callees
13:22:55 <kmc> you have to build that module with prof too
13:23:10 <kmc> your make is hitting that module?
13:32:57 <qz> is there any simple string replace function in haskell? like haystack needle -> result
13:33:30 <Twey> qz: Use Text.Regex
13:34:01 <qz> alright. thought there's a function for simple cases
13:34:50 <Twey> qz: There is — Text.Regex.subRegex
13:35:13 <Twey> > subRegex (mkRegex "foo") "foobar" "baz"
13:35:14 <lambdabot>   Not in scope: `subRegex'Not in scope: `mkRegex'
13:35:18 <Twey> Oh
13:35:24 <Twey> Well… that's how it's done, anyway.  ☺
13:35:44 <Twey> subRegex (mkRegex needle) subject replacement
13:35:57 <qz> i see, thanks
13:36:25 <guest4214> preflex, seen medfly
13:36:26 <preflex>  medfly was last seen on ##C 15 days, 22 hours, 52 minutes and 28 seconds ago, saying: okay thanks
13:36:38 <guest4214> !markov medfly
13:36:41 <psychobot> medfly-- medfly-- medfly-- medfly-- medfly-- medfly++ medfly-- medfly-- medfly-- medfly-- medfly-- medfly-- medfly, let's eat, grandma aka interpreter > len
13:37:02 <Twey> ;3~Hahaha
13:38:17 <Hunner> Is there a Functor type class for * -> * -> * ?
13:38:37 <guest4214> Hunner, how can that be a functor
13:38:37 <Hunner> :k Either
13:38:38 <lambdabot> * -> * -> *
13:38:55 <Twey> It's not even a type
13:40:15 <Hunner> Basically I'm trying to figure out how to not have a rigid type variable bound for Left in `instance Functor (Either e)`
13:40:32 <kmc> Hunner, did you check category-extras?
13:40:44 <kmc> they got functors like you wouldn't believe
13:41:21 <Hunner> Looking
13:41:23 <djahandarie> category-extras is scary though
13:41:33 <ezyang> It's not scary! It's warm and fuzzy.
13:41:49 <Hunner> Well, I'm doing this as an exersize, so I'm not just looking for functor instances :)
13:42:03 <djahandarie> I've seen useful stuff in there but it's kind of lost in the middle of all the not-so-useful stuff
13:42:07 <Hunner> o/ ezyang. Using your haskell.html
13:42:57 <kmc> Hunner, it's a bifunctor i think
13:43:07 <ezyang> Hunner: cool!
13:43:24 <Hunner> Ah
13:43:24 <kmc> what's haskell.html?
13:43:32 <Hunner> kmc: http://ezyang.com/haskell.html
13:43:58 <ezyang> I should update the error section. Actually I should update the whole thing.
13:44:28 <Hunner> Seeing as lucid and haskell 2010 are out now :)
13:44:36 <ezyang> yeahhh
13:45:06 <kmc> does GHC have a flag for Haskell 2010 yet?
13:49:00 <navaati> bye
13:49:14 <jamwt> is it expected that STM works as-advertised even with TVars shared via "true" threads (forkOS) ?
13:49:55 <jamwt> I think I might be seeing some evidence of copies, here.. state inconsistencies that didn't arise under forkIO
13:50:01 * hackagebot haskell-cnc 0.1.3 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1.3 (RyanNewton)
13:50:18 <Heffalump> jamwt: I believe so
13:52:25 <kmc> forkOS threads are not more "real" than forkIO threads
13:52:30 <kmc> the only difference is if you make FFI calls
13:52:50 <kmc> it's a bad name that causes a lot of confusion, imo
13:53:15 <kmc> jamwt, so i would look elsewhere first
13:53:21 <kmc> but maybe there is a subtlety i'm unaware of
13:53:26 <kmc> can you give a simple test case?
13:53:26 <jamwt> okay, I'll give it a shot.. bit puzzling so far
13:53:45 <Heffalump> kmc: if jamwt is seeing different behaviour in STM just from changing forkIO to forkOS, then the reasons for using forkOS are irrelevant IMO
13:53:54 <kmc> yeah
13:53:58 <jamwt> the reason I'm using forkOS to begin with is it looked like I was having a waitpid block all `IO` microthreads
13:54:02 * hackagebot hashed-storage 0.5.1 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.1 (PetrRockai)
13:54:22 <kmc> jamwt, if you use the threaded runtime, then a blocking FFI call does not block all threads
13:54:49 <kmc> Heffalump, right, e.g. there might be a bug in GHC
13:55:20 <qz> hm.. subRegex function is in package Text.Regex (posix regex), any way to make it work with PCRE regexes ?
13:55:40 <jamwt> kmc: ah, that explains things
13:55:48 <jamwt> b/c when I switched to forkOS, it required I do -threaded
13:55:50 <kmc> "Using forkOS instead of forkIO makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the -threaded option when linking your program, and t
13:55:50 <kmc> o make sure the foreign import is not marked unsafe."
13:55:54 <kmc> sorry for spam
13:56:11 <kmc> that's from the Control.Concurrent docs
13:56:30 <jamwt> .. and.. that's probably what caused the waitpid to free up.. lemme switch back to forkIO and see if the STM worries disappear
13:56:38 <Heffalump> jamwt: so where does the problem arise, with -threaded or the forkIO/forkOS change?
13:56:59 <Heffalump> if STM is misbehaving under any scenario, it sounds like a real bug
13:57:07 <Heffalump> but it's important to understand what the trigger is
13:57:14 <jamwt> Heffalump: two problems--waitpid block, which may have been lack of -threaded, and nothing with IO vs. OS
13:57:23 <jamwt> but that sounds like it's sorta solved and I misdiagnosed
13:57:36 <jamwt> .. then the STM inconsistency, which I can't explain yet, but I'll try to get more info right now
13:57:52 <Heffalump> the waitpid block is plausible without -threaded. The STM inconsistency is the interesting one.
13:57:56 <jamwt> right
13:58:04 <jamwt> I buy it.  so lemme go back to forkIO in -threaded
13:58:09 <jamwt> and see what things look like
14:02:21 <c_wraith> doesn't forkOS break the IO manager in the child?
14:02:32 <c_wraith> Or am I thinking of something entirely different?
14:03:10 <hpc> it would be mentioned if that were the case, i think
14:03:37 <c_wraith> @hoogle fork
14:03:37 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
14:03:37 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
14:03:57 <pastorn> fork :: Food -> Mouth -> Satisfaction
14:05:10 <hpc> spork :: Joke -> It Exists -> Confusion
14:10:43 <Peaker> fork Pasta Italian = Yummy
14:11:29 <jberryman> I'm feeling too lazy to test it, and wondering if GHC is smart enough not to recompute the same view pattern on the same object in a different function
14:12:01 <Heffalump> I'd be amazed if it was that "smart"
14:12:08 <dolio> In a different function?
14:12:17 <Heffalump> is this a situation where one use of the viewpattern dominates the other?
14:12:22 <jberryman> Heffalump: what about referential transparency?
14:12:28 <kbojcic> hello
14:12:30 <Heffalump> what about it?
14:12:44 <Heffalump> it _could_, but only at the cost of introducing possible space leaks
14:13:20 <Heffalump> except in limited situations where it could prove that it wouldn't
14:15:05 <kbojcic> where could i use haskell, i am intrigued by functional programmig yet I don't see how could I use it in real life
14:15:26 <Twey> Where you program
14:15:59 <kbojcic> ?
14:16:21 <jberryman> Heffalump: that makes sense. I think my situation is pretty simple. maybe I'll test it out myself
14:16:21 <Twey> If you program it, you can use Haskell for it.
14:16:58 <soupdragon> kbojcic: you could use it to calculate the number of prime numbers below 1000 which are 2 digits off a palindrome
14:17:10 <ehamberg> kbojcic: the book real world haskell (freely available online) shows some real-world programs. but really, it's a general-purpose language. people use it for everything from financial applications to games.
14:17:12 <Twey> Excepting some corner cases, like extremely restricted embedded systems and existing codebases.
14:17:28 <tensorpudding> You can use functional programming in most every language.
14:17:31 <araujo> kbojcic, haskell is general purpose language
14:17:48 <araujo> kbojcic, haskell.org/himerge # GUI for daily life example
14:17:55 <Philonous> c_wraith: Apaprently you can do IO in a forkOS-ed child, though the documentation sais the IO manager wouldn't be available. I ran across that a while ago
14:17:58 <Heffalump> I hear it makes a great host for EDSLs for embedded systems
14:18:16 <jamwt> Heffalump, hpc : nope, was a bug on my end.  :-)
14:18:23 <tensorpudding> FP is kinda faddish
14:18:29 <jamwt> fixed and tested with forkOS and IO, all good
14:18:35 <jamwt> yay STM
14:18:38 <kbojcic> I did some reasearch, I found that book, and some tutorials. But still i feel like I am better of in ruby, or some other imperative language. How did you guys went over that urdle
14:18:47 <kbojcic> hurdle
14:18:52 <Peaker> kbojcic, I wrote some code in Haskell
14:19:02 <Peaker> kbojcic, and quickly I became more and more comfortable with the functional style
14:19:11 <jamwt> kbojcic: the learning curve is just a lot steeper IME
14:19:24 <soupdragon> you don't sound like the kind of person would us haskell
14:19:27 <Peaker> kbojcic, I discovered Haskell though because I was noticing that I'm inventing my own (crappy) functional DSL in Python, and wondered how others do it
14:19:34 <jamwt> but I've just started to get a decent pace lately
14:19:39 <kbojcic> I did some prolog is it similar?
14:19:46 <jamwt> and I think I'll be able to write within 20-50% as fast as python, first shot, eventually
14:19:47 <ezyang> To use real-world languages as an example,
14:19:52 <Peaker> kbojcic, After learning a lot of Haskell and using it for some things, I don't think I want to use Python for much (it's a nicer calculator than ghci, maybe)
14:20:01 <ezyang> Traditional C-based languages are "Roman" languages; pretty easy to pick up
14:20:02 <jamwt> but probably make up the time in maintenance
14:20:08 <ezyang> if you know one
14:20:21 <ezyang> and then Haskell is in another family of languages, say, Asian
14:20:45 <ezyang> so there are a lot fewer similarities, but once you know one there's another branch of languages that seem really similar
14:21:06 <soupdragon> bad metaphor
14:21:18 <ezyang> :-)
14:21:21 <sepp2k> kbojcic: It's similar in that both achieve iteration with recursion.
14:21:31 <yashton> haskell and functional languages are much closer to discrete math than traditional programming
14:21:42 <sepp2k> And that they have singly linked list as the most common datastructure.
14:22:05 <Peaker> I think Haskell is higher-level, which to me means it is closer to a spec than other languages, leaves more implementation details open/unspecified
14:22:14 <kbojcic> @yashton - I feel like it's superior for math problems, but I don't do that for living
14:22:21 <lambdabot> No match for "-".
14:22:21 <lambdabot> No match for "I".
14:22:21 <lambdabot> No match for "feel".
14:22:21 <lambdabot> No match for "like".
14:22:21 <lambdabot> No match for "it's".
14:22:23 <lambdabot> [11 @more lines]
14:22:36 <Twey> kbojcic: It's superior for *programming*.
14:22:42 <hpc> @yashton
14:22:48 <hpc> o.O
14:22:57 <Twey> It's not particularly well-suited to mathematical problems, any more than any other language.
14:23:08 <monochrom> If you feel like using ruby or python or ... then do it. I see no point asking me why you use haskell. I can tell why I, not you, use haskell. Namely, none of the hurdles you perceive exists to me.
14:23:39 <monochrom> I mean, until I have the technology to open your brain for examination.
14:23:56 <tensorpudding> your mind to my mind
14:24:06 <kbojcic> Well, I rediscoverd vim year ago, Now I can't stop talking about it, like you guys about haskell :) I belive that there is something in what you say. It's just that I can't grasp what. So I am asking.
14:24:26 <soupdragon> you can't be told
14:24:30 <soupdragon> you have to experience it
14:24:35 <tensorpudding> Oh noes, it's like zen
14:24:35 <hpc> the best explanation i have found is that haskell functions aren't things that are done, they are relations
14:25:12 <aavogt> oO ( haskell functions go multiple ways? )
14:25:27 <kbojcic> Is that 99 problems in haskell good way to start?
14:26:21 <monochrom> It is really like a Wall Street executive asking a bunch of grad students "why do you do your PhD? why not be a Wall Street executive?"
14:26:21 <Zao> I've got 99 problems but Haskell ain't one.
14:26:39 <tensorpudding> i've got 99 problems but referential transparency ain't one.
14:28:45 <kbojcic> @hpc - could you elaborate a bit on that?
14:28:46 <lambdabot> Maybe you meant: ghc pl rc src
14:32:15 * hackagebot haskell-cnc 0.1.3.1 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1.3.1 (RyanNewton)
14:32:20 <hpc> kbojcic: i would try, but i am a bit busy atm and probably would do a bad job explaining it anyway
14:32:27 <hpc> sorry
14:32:57 <qz> hrm.. i'm getting linkage errors on source that uses ByteString. how do i tell linker to link ByteString in?
14:33:48 <aavogt>  --make
14:34:11 <qz> aavogt, thanks
14:39:36 <Zao> Or -package
14:44:02 <Nereid> Is it just me or is haskell.org rather slow today?
14:44:22 <mreh> I can't be bothered to reimplement gaussian filters in haskell
14:47:31 <osfameron> ooo, there's a wiki page on iphone dev with haskell
14:48:38 <mreh> can I use tries for infinite structures?
14:49:21 <mreh> like a function over the integers
14:50:30 <Nereid> sure why not
14:52:43 <tibbe> is plusInteger (i.e. addition for Integers) non-strict?
14:52:58 <mreh> you mean lazy? sure
14:53:47 <benmachine> how would it be
14:53:49 <mreh> haskell is non-strict by default, unless specified otherwise
14:54:01 <tibbe> mreh: but + for Int is strict
14:54:16 <tibbe> mreh: I have a piece of code that gets lazier when switching from Int to Integer
14:54:21 <benmachine> you can get plus-thunks
14:54:24 <benmachine> tibbe: magic!
14:54:31 <benmachine> but
14:54:35 <mreh> lazier?
14:54:44 <benmachine> there shouldn't be any difference in behaviour
14:55:33 <tibbe> mreh: yes, the integer version is (plusInteger a b) but the Int version is (case a of a# -> I# (a# +3 1))
14:55:47 <tibbe> (case a of a# -> I# (a# +# 1))
14:55:58 <tibbe> chunkFiller i bs = do
14:55:58 <tibbe>    if (B.null bs ) then return 1
14:55:58 <tibbe>                   else chunkFiller (i+1) bs
14:56:16 <tibbe> it's a silly function but it changes space behavior if you add a type signature
14:57:04 <tibbe> (I checked the core)
14:58:32 <tibbe> can anyone explain what's going on?
14:59:39 <dolio> What's the purpose of i?
15:00:53 <dolio> Anyhow, chunkFiller is an infinite loop that builds up a giant nested thunk.
15:01:14 <dolio> (((i + 1) + ...) + 1)
15:02:07 <Saizan> tibbe: with Int it gets splitted into a strict loop and a lazy wrapper?
15:02:23 <tibbe> Saizan: doesn't look like it
15:02:31 <tibbe> Saizan: let me check again
15:03:28 <Saizan> dolio: unless it's return 1 :)
15:03:47 <dolio> Yes, if bs is null.
15:03:52 <tibbe> Saizan: no, no wrapper from what I can see
15:04:09 <qz> are there any workarounds for ghci error "Loading package regex-pcre-0.94.1 ... can't load .so/.DLL for: pcre (/usr/lib64/libpcre.so: invalid ELF header)" ?
15:04:16 <tibbe> so it's clear to me why the function isn't strict in its first argument
15:04:33 <benmachine> qz: iirc that can happen if libpcre.so is a linker script?
15:04:36 <tibbe> what I don't get is how GHC can make a strict version out of that
15:04:37 <qz> yep
15:04:40 <qz> it is linker script
15:04:40 * benmachine vague recollection
15:04:46 <tibbe> I could see how constr-spec would do it
15:04:57 <benmachine> so a workaround is replacing it with a symlink, but that's quite an ugly workaround
15:05:04 <benmachine> or well
15:05:11 <tibbe> actually no
15:05:15 <benmachine> I was always reticent to muck about with my libraries
15:05:17 <Saizan> tibbe: can you paste the core?
15:05:19 <pikhq> qz: The *simplest* way is to look at the linker script, and replace it with a symlink. This is, unfortunately, somewhat ugly.
15:05:19 <tibbe> I don't see how it would be ok to evaluate i strictly
15:05:27 <Peaker> what's {-# SPECIALIZE ... ?
15:05:55 <qz> i'm afraid it can break something else on machine =p
15:06:01 <dolio> tibbe: What difference would it make, since it's never used?
15:06:08 <Zao> Peaker: Lets you replace a generic function with a semantically identical but more tuned function for some types.
15:06:17 <pikhq> qz: Well, what's the linker script in question?
15:06:17 <dolio> I suppose it blows up if you pass in bottom.
15:06:36 <benmachine> Peaker: it generates a specific case of a polymorphic function, and a rewrite rule to turn the function into that case where applicable
15:06:52 <Peaker> benmachine, ah cool
15:06:55 <qz> pikhq: GROUP ( /lib64/libpcre.so.0 )
15:07:13 <tibbe> http://pastebin.com/wdA7F3wA
15:07:23 <Zao> http://www.haskell.org/ghc/docs/6.12-latest/html/users_guide/pragmas.html#id669619
15:07:29 <tibbe> dolio: if i was undefined it would get a bottom result
15:07:39 <Zao> GHC docs have a horrible lack of anchors, by the way.
15:07:40 <tibbe> dolio: although it's already (some other kind of) bottom
15:07:51 <tibbe> the puzzling part is that the result is different between Int and Integer
15:08:05 <qz> i can put symlink but it will 1) last until next softwaer update 2) its ugly =p 3) there must be better way..
15:08:10 <qz> *software
15:08:25 <pikhq> The trick is to make GHC handle linker scripts.
15:08:27 <Saizan> tibbe: is there also the Int version there?
15:08:40 <tibbe> Saizan: sec
15:08:49 <qz> pikhq, how can i make ghci do it?
15:09:23 <dolio> tibbe: Are you testing it unannotated versus annotated Int? Or annotated Integer vs. annotated Int?
15:09:41 <tibbe> Saizan: http://pastebin.com/jrv9uwsV
15:09:54 <pikhq> qz: Not easily. I *think* it's breaking because it's trying to dlopen libpcre.so. And dlopen doesn't do linker scripts.
15:10:01 <tibbe> dolio: unannotated (which default to Integer) and annotated with Int
15:12:48 <Saizan> tibbe: anyhow, if the case appears only in the branch where bs is non-empty, then it's fine
15:13:14 <qz> pikhq, it looks like there's a patch that fixes this issue, but it is in .12.3 and ghc is at .12.1 here.. will try to update
15:14:12 <stepkut> did MVar use to have some warning about using more than one MVar in a multi-threaded program? Or am I thinking about something else ?
15:14:37 <tibbe> Saizan: but why doesn't Integer have a case?
15:14:56 <tibbe> Saizan: I wonder if it comes down to GHC knowing + is strict for Ints
15:15:20 <Saizan> tibbe: that might be it, or maybe having 2 constructors instead of one
15:15:21 <tibbe> Saizan: but still, is it safe to evaluate i every time around the loop? i is never used in the function
15:16:19 <Saizan> tibbe: well, it doesn't introduce any bottoms if it's after the null check, so it's safe, afaiu
15:17:25 <tibbe> Saizan: why doesn't it introduce any new bottoms?
15:18:03 <Saizan> tibbe: because if bs is non-empty the whole thing is bottom anyhow
15:18:12 <tibbe> Saizan: if bs is non-null the function will spin indefinitely unless i is evaluated
15:18:27 <tibbe> Saizan: right, do you think GHC knows this?
15:19:05 <Saizan> tibbe: no idea, but it's plausible
15:19:23 <tibbe> Saizan: but again, why doesn't it know this in the Integer case?
15:19:43 <tibbe> Saizan: perhaps it thinks plusInteger is expensive so it choses to not evaluate it even if it would be safe
15:21:04 <Saizan> tibbe: i think we'd need to look at which transformation is doing this
15:22:13 <tibbe> Saizan: yes, I'll have a look tomorrow
15:22:17 <tibbe> i'm too tired
15:23:59 <dolio> tibbe: I get the exact same space leak with Int.
15:24:25 <tibbe> dolio: really?
15:24:29 <dolio> Yes.
15:24:47 <tibbe> dolio: I don't
15:24:55 <tibbe> GHC 6.12.1
15:25:42 <dolio> That's the version I have.
15:27:01 <tibbe> Saizan: not sure which transformation does it, -ddump-simpl-iterations doesn't say
15:27:16 <tibbe> dolio: that's strange
15:27:22 <tibbe> dolio: what does the core look like?
15:27:42 <tibbe> dolio: I have a case statement that evaluates the Int in the $wa worker in the core
15:28:35 <dolio> Yes, but it looks like "Main.$wa (case a of I# a# -> I# (a# +# 1)) ..." right?
15:29:02 <tibbe> dolio: yes
15:29:15 <tibbe> dolio: hmm
15:29:17 <dolio> That isn't any different than inlining plusInteger.
15:29:20 <tibbe> dolio: I might have read that wrong
15:29:22 <dolio> That doesn't actually get evaluated.
15:29:47 <tibbe> dolio: it should have been case a of I# a# -> wa (I# a#) if it gets evaluated
15:29:59 <tibbe> my bad :/
15:30:01 <dolio> Right.
15:30:13 <tibbe> getting late here
15:30:17 <tibbe> heading off to bed
15:30:19 <tibbe> gnight
15:30:22 <dolio> Night.
15:30:24 <tibbe> thanks for the input
15:34:19 <alexyk> if I want to serialize a Map ByteString (Map Int (Map Bytestring Int)) with Data.Binary, do I need any instances hand-made?
15:35:13 <alexyk> like the one in http://code.haskell.org/binary/
15:37:22 <c_wraith> alexyk, if you do, the compiler will tell you
15:42:52 <applicative> alexyk see http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html
15:43:27 <applicative> alexyk there's an instance (Ord k, Binary k, Binary e) => Binary (Map k e)
15:43:44 <alexyk> cool cool
15:53:32 <JoeyA> Can you use the data keyword in ghci?
15:53:46 <JoeyA> e.g. let data Tree = Leaf a | Tree a Tree a
15:53:51 <JoeyA> (which doesn't work)
15:53:53 <monochrom> No.
15:54:02 <alexyk> if I want to compress a bytestring and spit it out into a file, which hPut... function is fastest?
15:55:19 <Nereid> ok, where's conal, his vector-space package doesn't do what it says it does
15:55:19 <Nereid> :o
15:56:44 <Nereid> (specifically Data.VectorSpace.normalize doesn't return the zero vector if given it)
16:00:38 <alexyk> if I print a ByteString and > stdout to a file, will it be faithful to the bytes?
16:01:08 <Nereid> probably
16:02:28 * ddarius wouldn't want normalize to return the zero vector given the zero vector.
16:02:50 <Nereid> ddarius: but the documentation says it does
16:02:52 <Nereid> :0
16:03:04 <ddarius> Nereid: I understand and agree with your complaint.
16:03:24 <alexyk> how do I find out where things like Codec.Compress.GZip come from to cabal install <it>?
16:03:28 <Nereid> also in some cases it is useful to treat 1/0 as 0
16:03:50 <Nereid> alexyk: zlib
16:03:55 <ddarius> Nereid: Yes, but that doesn't mean you want div to return zero when dividing by zero all the time.
16:03:59 <alexyk> ddarius: you sound like you have a CS experience :)
16:03:59 <Nereid> ddarius: well yes
16:04:03 <Nereid> so provide a normalize' or something
16:04:13 <Saizan> alexyk: hayoo can tell in general
16:04:22 <Nereid> hayoo
16:04:25 <Nereid> is broken right now
16:04:55 <ddarius> Nereid: For the case of normalize, I would just have it throw an exception.  If you want to return zero when normalize does, it's best just to check the norm (squared) ahead of time and then divide if it is not zero.
16:05:09 <Nereid> ddarius: I wrote a normalize' for that purpose.
16:05:16 <alexyk> "I understand and agree with your complaint.  Unfortunately, as much as I'd love to give you a freebie, the company is almost broke, and you wouldn't want us to go out of business and live you without any future wirbles, would you?"
16:05:29 <alexyk> leave
16:06:18 <ddarius> Nereid: As a local function, yes that's fine, though I suspect most of the time I'd want that I'd prefer having what's going on explicit.  I don't think it is worthwhile enough to predefine in the library.
16:06:25 <JoeyA> I'm beginning to learn about Haskell's data declarations.  Anything wrong wth this?  data Graph a = Graph [a] ((a,Int) -> (a,Int) -> Bool)
16:06:36 <JoeyA> (or any way I could improve it?)
16:06:51 <JoeyA> Not sure if using Graph in 2 different ways is weird / won't work.
16:06:57 <ddarius> With an exception throwing version of normalize, it has the strong invariant that magnitude (normalize v) == 1 for all v.
16:07:07 <alexyk> if I want my cabal installs to be suitable for profiling, should I just uncomment: library-profiling: True -- and make it True like so?
16:07:11 <Nereid> JoeyA: it's normal to give the type and constructor the same name
16:07:33 <ddarius> @src (,)
16:07:33 <lambdabot> Source not found. :(
16:07:38 <ddarius> @src ,
16:07:38 <lambdabot> Source not found. :(
16:07:38 <alexyk> what's library-vanilla?
16:07:47 <Saizan> alexyk: yep
16:08:25 <alexyk> Saizan: meaning just library-profiling right?
16:08:34 <JoeyA> Nereid: Thanks
16:08:40 <Saizan> yeah, library-vanilla is True by default
16:09:02 <Saizan> which is the normal build of libs, afaiu
16:09:08 <alexyk> is there a bz2lib and 7zlib or something?
16:09:23 <Nereid> ther'es bzlib for bzip2
16:09:27 <alexyk> and executable-profiling means those in .cabal/bin, for some purpose?
16:10:09 <Saizan> it means to build the executables with profiling enabled
16:10:23 <alexyk> so if I want to retroactively cabal --reinstall -p, do I have to rebuild the graph in my mind and toil all night at it?
16:10:42 <alexyk> isn't there an automatic way?...
16:10:50 <Saizan> no
16:11:05 <alexyk> isn't haskell like good at such things?
16:11:33 <alexyk> they should ship cabal with library-profiling set to True, IMHO.
16:11:46 <Saizan> ghc-pkg doesn't yet track if a package has the profiling version installed, nor enough data to build a profiling version that corresponds to the exact built version
16:11:54 <alexyk> 'cause changing it post factum is painful
16:11:59 <Saizan> and noone wrote an hacky script that "sort of works"
16:12:19 <alexyk> Saizan: I don't ask for matching post factum, just rebuild the hell out of it
16:12:40 <alexyk> rebuild all, just use the names from .cabal and be smart about the build order
16:12:51 <alexyk> and don't come back asking or whining until it's all done
16:13:13 <Saizan> and noone wrote an hacky script that "sort of works" <- that would fall here :)
16:13:35 <alexyk> yeah
16:13:44 <alexyk> with a thud
16:17:00 <FunctorSalad> output the package list, nuke the ghc-pkg state, <packs xargs cabal install?
16:17:29 <FunctorSalad> after enablifying library-profiling
16:18:10 <alexyk> introducing type names shouldn't interfere with Data.Binary instances, should it?  if I call Map Int String MyType, will it still be serializable?
16:18:37 <Saizan> "type" definitions are completely transparent
16:19:03 <FunctorSalad> "fall" in the sense of "not be accepted" Saizan? we don't have hacky scripts in haskell tools? hehe
16:21:08 <Saizan> as in "fall in this category"
16:22:25 <Saizan> not sure how much better than what you suggested above we could get
16:22:29 <alexyk> how do I slurp a whole file into a ByteString?
16:22:41 <Saizan> readFile
16:23:26 <Saizan> Data.ByteString[.Lazy].readFile
16:24:19 <tommd> Yeah, readFile is one of the several IO functions that are duplicated an unfortunate number of times.
16:24:35 <tommd> So many libraries have 'readFile' or something similar.
16:25:14 <applicative> alexyk, you said something about writing to stdout and to file with >  there is also
16:25:19 <applicative> @type Data.ByteString.interact
16:25:19 <lambdabot> (BSC.ByteString -> BSC.ByteString) -> IO ()
16:25:45 <alexyk> applicative: nice!  but I don't read, just write
16:25:56 <alexyk> I dump the results of labor
16:26:54 <applicative> alexyk, I see you were just asking about readFile...
16:27:03 <alexyk> right
16:27:44 <alexyk> why type mismatch: http://paste.pocoo.org/show/221671/ ?
16:28:43 <alexyk> decode is form Data.Binary and decompress from Codec.Compression.GZip
16:29:06 <FunctorSalad> alexyk: the command I wrote *would* do the dependency stuff for you though
16:29:31 <alexyk> FunctorSalad: hmm!  you wrote prose! :)
16:29:34 <applicative> alexyk, kill the type signature on the first line
16:29:47 <FunctorSalad> since - I think - cabal *does* simultaneous dependence analysis for all the cmdline args
16:29:54 <alexyk> applicative: I did, this is second attempt, same result
16:30:33 <FunctorSalad> alexyk: oh. hehe.... I meant "cabal install ....... list of all previously installed packages minus the  base ones ...."
16:31:07 <alexyk> applicative: should I import some other kind of ByteString, not Char8?
16:31:32 <alexyk> FunctorSalad: ah ok, then we can scriptify indeed
16:31:33 <mauke> alexyk: Char8 is not a separate type
16:31:53 <mauke> looks like you're trying to mix strict and lazy bytestrings
16:32:00 <alexyk> mauke: so where does Data.ByteString.Lazy.Internal.ByteString pop up from?
16:32:14 <alexyk> ah, decompress is probably lazy...
16:32:37 <alexyk> how do I strictify them?
16:32:50 <applicative> alexy, are you using Codec.Gzip or something?
16:32:55 <alexyk> applicative: yep
16:33:01 <alexyk> Codec.Compression.GZip
16:33:30 <mauke> alexyk: because decompress takes a lazy bytestring, apparently
16:33:47 <alexyk> mauke: how do I read a lazy one then?
16:34:03 <mauke> import Data.ByteString.Lazy(.Char8)
16:34:11 <alexyk> ah
16:35:48 <applicative> http://hackage.haskell.org/packages/archive/zlib/0.5.2.0/doc/html/src/Codec-Compression-GZip.html begins:
16:35:49 <applicative> import Data.ByteString.Lazy (ByteString)
16:39:48 <applicative> alexyk, if you write, say, Prelude> :m +Codec.Compression.GZip in ghci, then Prelude Codec.Compression.GZip> :t decompress tells you exactly the necessary type.
16:40:15 <alexyk> yes, thx!
16:42:38 <alexyk> so I get incorrect header check, I can't write with print (compress ...) apparently?
16:43:03 <Saizan> print uses show
16:43:17 <Saizan> you probably want to get the actual bytes out instead
16:43:35 <alexyk> Saizan: what doesn't?
16:43:41 <Saizan> hPutStr
16:43:54 <JoeyA> How would I execute a shell script, piping a string into it?  What module should I look into?
16:44:00 <JoeyA> (on Linux)
16:44:01 <Saizan> from Data.ByteString[.Lazy]
16:44:05 <alexyk> ah ok, so putStr will dump to stdout virginally?
16:44:43 <alexyk> cool
16:44:44 <Cale> alexyk: The ByteString one will
16:45:00 <Cale> alexyk: The one for String does some text encoding
16:45:12 <Cale> (at least, by default)
16:45:34 <Saizan> Cale: are you sure the bytestring one sends raw bytes? however the solution would be to set binary mode for the handle
16:45:53 <Cale> Saizan: pretty sure
16:46:45 <alexyk> yay!  all works, champaigne all around!
16:47:00 <applicative> JoeyA, do you mean, a non-Haskell script, you want to call in a Haskell module
16:47:06 <JoeyA> Yes
16:47:12 <JoeyA> a shell script written in Bash
16:47:27 <applicative> System.IO.Cmd.system
16:47:31 <applicative> Is that it?
16:48:06 <FunctorSalad> System.Process.system
16:48:12 <FunctorSalad> maybe that's the same
16:48:29 <applicative> thats it i think, its exported into System.Cmd
16:48:56 <FunctorSalad> readProcess may also be useful
16:49:35 <FunctorSalad> JoeyA: readProcess "cat" [] "fooooooooooooooooooooooooooooO"
16:49:50 <FunctorSalad> will pipe that to the cat
16:50:09 <applicative> JoeyA, the trashy way is 'system' from http://hackage.haskell.org/packages/archive/process/1.0.1.2/doc/html/System-Cmd.html
16:50:46 <FunctorSalad> I don't think that lets you get your hands on the process's stdin
16:51:00 <JoeyA> Fantastic, readProcess is what I wanted
16:51:17 <applicative> indeed, you cant name the handle
16:51:18 <FunctorSalad> downside: it's strict
16:51:50 <JoeyA> :(
16:51:55 <FunctorSalad> for full control, you'd use System.Process.createProcess
16:52:03 <FunctorSalad> and set it up such that it gives you handles
16:52:08 <JoeyA> As in, you can't readProcess "/dev/urandom" [] "" ?
16:52:16 <JoeyA> because it'll run forever?
16:52:40 <FunctorSalad> the first arg is the executable, but apart from that, yeah, I think you can't
16:52:41 <JoeyA> Rather than demonstrate the connection between piping and lazy evaluation.
16:53:12 <FunctorSalad> it kinda needs to be strict to give you such a simple abstraction (string in, string out)
16:53:25 <JoeyA> Indeed, it is strict
16:53:51 <FunctorSalad> pure strings don't give you much power to control how exactly sending and receiving to the process are interleaved....
16:54:30 <JoeyA> Fortunately, I don't need to work with infinite streams today :-)
16:54:39 <FunctorSalad> and it'd leak handles if you don't read the process's stdout until the end
16:54:55 <FunctorSalad> so it's kinda sane that it's strict ;)
16:55:29 <FunctorSalad> (I'm not sure what resource exactly would be leaked, but at least the handle wouldn't be closed with lazy IO)
17:05:26 <gwern> 'Our animals talk. Rather, my mother has conversations with them that she makes up. Different voices for each one too. My cousins are exactly the same.
17:05:29 <gwern> I remember being a little kid and cheerfully mentioning this to some family friend, to my mother's greatest embarrassment. That was when I realised this was a 'family thing' not ever to be discussed because other people will think you're crazy.
17:05:33 <gwern> Once my Ma went away for the weekend and my sister remarked, "the dog's been quiet these last few days-" then broke off and realised what she was saying...
17:05:36 <gwern> er. mischan.
17:24:01 <kniu> Is there a GitHub, except with darcs repos?
17:24:48 <Heffalump> patch-tag.com and something newer whose name I forget
17:24:54 <Heffalump> darcsden
17:27:48 <kniu> k thanks
17:28:19 <gwern> or patchtag
17:28:26 <gwern> oh, Heffalump already said that one
17:42:13 <seit> Anyone familiar with a fixed width arithmetic library for haskell?
17:43:03 <ClaudiusMaximus> seit: not personally, but Data.Fixed seems to exist for that
17:43:14 * seit going to check Data.Fixed out
17:45:04 <seit> ClaudiusMaximus, thanks for the link, but I should have clarified.  I'm looking for fixed width integer arithmetic.  I'd like to do some DSP modeling that has restricted bit widths
17:45:36 <ClaudiusMaximus> seit: oh, then Word8/Int16/etc might be enough?
17:46:02 <seit> ClaudiusMaximus, how about a Word12 and Word17? :-)
17:46:11 <ClaudiusMaximus> no clue :)
17:46:47 <seit> thanks though, I'll keep looking around
17:52:57 <tommd> seit: You can define "WordX" data types and make instances of Num, Integral, etc by masking them appropriately.  Not sure if that's what you're looking for.
17:53:15 <ddarius> "For out of olde feldes, as men seith, Cometh al this newe corne fro yeere to yere; And out of olde bokes, in good feith, Cometh al this new science that men lere."
17:54:42 <seit> tommd, that's true.  I'll admit, I'm being lazy hoping this was already implemented.
17:55:38 <seit> I come from more of a hardware and signal processing background, so fixed width precision is fairly common
17:55:42 <ddarius> There's probably a generic modular arithmetic library.  In fact, I'm sure that there are.
17:55:59 <seit> ddarius, good idea...
17:56:08 * seit starting to look through hackage
17:57:51 <tommd> seit: NumLazyByteString started down that path, but it really isn't ready for your use I'd say.
17:58:19 <seit> tommd, and I'm not having much luck on hackage so far
17:58:43 <tommd> It was intended to be a limited-size (multiple of 8) Word, but I didn't get around to making checks to ensure all the operations followed the word length rules correctly.
17:59:12 <tommd> So if you are looking for Word12, Word17 that first restriction eliminates NumLazyByteString even if it were implemented right.
17:59:33 <kulakowski> Generic modulo library seems like it might not be smart enough to do specialize for powers of 2.
18:00:07 <JoeyA> Is it possible to write a variant of show that doesn't wrap String and Char values in quotes?
18:00:23 <JoeyA> More generally, is it possible to create new classes and make existing types instances of them?
18:00:46 <pikhq> Yes, you can always define new typeclasses and make existing types instances of them.
18:01:00 <JoeyA> Yay
18:01:15 <JoeyA> I guess I'd need to do that to implement the function I'm talking about (let's call it label)
18:01:21 <pikhq> Though I seem to recall there being screwy things making instances for all instances of another typeclass.
18:01:23 <seit> tommd, yes, looks like it.  Since I'm not too concerned with performance, I wonder if it will be easiest to just create a new type and perform all the arithmetic with bit manipulations
18:01:26 <JoeyA> So label 5 = "5" (same as show 5)
18:01:32 <JoeyA> whereas label "hello" = "hello"
18:01:36 <JoeyA> and label 'c' = "c"
18:07:14 <gwern> @quote critic
18:07:14 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
18:10:32 <gwern> 'Quantum computers no better than classical ones for NP-complete problems. (arstechnica.com) '
18:10:35 <gwern> hm
18:10:40 <gwern> glad that's finally settled
18:11:19 <soupdragon> gwern: but that's not even true is it
18:11:46 <gwern> soupdragon: the article has a worrisome qualifier about 'adiabatic' computers
18:12:24 <JoeyA> I can't write `instance Label String` without getting an error message telling me to turn on -XTypeSynonymInstances
18:12:37 <JoeyA> Is there another way to write the same thing?
18:12:44 <gwern> 'This has almost certainly only been shown for a restricted class of adiabatic quantum computers. The full adiabatic quantum computing model is equivalent to ordinary quantum computing (http://arxiv.org/abs/quant-ph/0405098 ). If the linked article is literally correct, then that means quantum computers can efficiently solve NP-complete problems if and only if classical computers can efficiently solve NP-complete problems. That may be true, but I'd be ...
18:12:48 <JoeyA> (without needing that extension)
18:12:51 <gwern> ... very surprised if someone has proved it.
18:12:54 <gwern> bleh
18:12:55 <interferon> i have a function String -> [Blah] that splits a string into lines and parses each line into a Blah.  if there's a problem parsing a line, what's a good way of aborting further processing and returning an error value?
18:13:01 <interferon> the Either monad?
18:14:01 <gwern> interferon: well, if you must return an error value, then Either is good. if just 'error' is good enough, Maybe
18:15:18 <JoeyA> I wonder if forM with Maybe might be good for that.  I guess the ideal thing here might be to have your function return String -> Maybe [Blah]
18:15:31 <JoeyA> And your line mapping function would be of the form String -> Maybe Blah
18:17:09 <beutdeuce> is there any way to get language-python working on 6.12 ?
18:17:52 <JoeyA> interferon: check out mapM versus map.  Example:
18:18:00 <JoeyA> @let safeDiv n d = if d /= 0 then Just (n `div` d) else Nothing
18:18:01 <lambdabot>  Defined.
18:18:07 <JoeyA> > safeDiv 3 0
18:18:08 <lambdabot>   Nothing
18:18:11 <JoeyA> > safeDiv 3 1
18:18:12 <lambdabot>   Just 3
18:18:23 <JoeyA> > map (20 `safeDiv`) [0..5]
18:18:24 <lambdabot>   [Nothing,Just 20,Just 10,Just 6,Just 5,Just 4]
18:18:24 <interferon> hmm that sounds like what I want
18:18:28 <interferon> mapM with maybe, that is
18:18:29 <mauke> > safeDiv minBound (-1 :: Int)
18:18:30 <lambdabot>   Just *Exception: arithmetic overflow
18:18:42 <gwern> beutdeuce: buy more memory?
18:18:55 <JoeyA> > mapM (20 `safeDiv`) [0..5]
18:18:56 <lambdabot>   Nothing
18:19:01 <JoeyA> > mapM (20 `safeDiv`) [1..5]
18:19:03 <lambdabot>   Just [20,10,6,5,4]
18:19:04 <beutdeuce> gwern: ?
18:19:11 <ddarius> JoeyA: To avoid that problem you could write instance Label [Char], but that would, itself, require a different extension.
18:19:23 <JoeyA> :(
18:19:24 <gwern> problem is ghc demands lots of memory, I thought, not that it couldn't finish given unbounded ram
18:19:28 <c_wraith> I think you want catMaybes more than MapM
18:19:31 <c_wraith> err, mapM
18:19:38 <JoeyA> How the heck do people write instances for anything but base types, then?
18:19:43 <interferon> does anyone use formlets?  they seem very interesting but i don't see much discussion around them
18:20:16 <c_wraith> JoeyA, String is the only real problem with overlapping.
18:20:33 <c_wraith> Which is why I think string should be a real type, not an alias for [Char]
18:20:49 <JoeyA> catMaybes filters out failed lines, while mapM (in this case) lets us fail with Nothing when one line fails.
18:21:32 <gwern> c_wraith: but [Char] is so convenient
18:22:09 <c_wraith> Just have String implement Foldable and Traversable, and that takes care of most of it.
18:22:26 <Saizan> c_wraith: views too, i guess :)
18:23:06 <c_wraith> views would also work.  I just think it's a hindrance for the development of real software that instances for String and [a] overlap, because you almost never want to treat them the same.
18:23:21 <ddarius> Just use Data.Text.
18:23:25 <interferon> is there a haskell currency type?
18:23:34 <interferon> in a library
18:23:50 <JoeyA> Suppose I wanted to say instance Label [Int] .
18:24:08 <c_wraith> that would require an extension.  flexible something or others :)
18:24:18 <JoeyA> Does Haskell 2010 support it?
18:24:22 <c_wraith> probably FlexibleInstances
18:24:25 <Saizan> FlexibleInstances, which is a fairly tame extension
18:24:35 <JoeyA> -XFlexibleInstances
18:24:36 <JoeyA> Yup
18:24:37 <Saizan> it's been in -fglasgow-exts for ages
18:25:04 <Saizan> no idea if haskell'10 has it
18:25:10 <ddarius> It doesn't.
18:25:29 <ddarius> And most GHC extensions have been in -fglasgow-exts as that is almost the only place to put them
18:25:52 <c_wraith> '10 has very little.  Don't consider it to be the arbiter of what extensions you're willing to use.
18:26:06 <ddarius> -XNPlusK
18:26:28 <Saizan> ddarius: only those considered sufficiently non-controversial/safe
18:27:25 <tomberek> does GHCi not work with TypeOperators?
18:28:07 <Saizan> maybe you need to ":set -XTypeOperators" at the prompt?
18:28:29 <tomberek> oooh, perhaps!
18:28:46 <tomberek> hm, no
18:28:47 <JoeyA> I'm getting the impression that without XFlexibleInstances, Haskell's type system is far weaker than it would be
18:29:11 <JoeyA> I mean, is it even possible to work around instance Label [Int] not being allowed without an extension?
18:29:14 <tomberek> Saizan: i have the pragma in the .hs file i'm loading
18:29:26 <Saizan> JoeyA: newtype
18:29:28 <tomberek> it works, but ghci doesn't show them as infix
18:29:52 <tomberek> and it won't accept it if i manually enter it
18:30:19 <gwern> JoeyA: couldn't you newtype [int] and then do the instance on it?
18:30:27 <tomberek> Saizan: or rather, it un - infixes it
18:31:20 <Saizan> tomberek: ah, maybe the pretty printer needs some fixing then
18:31:59 <JoeyA> I tried newtype IntArray = IntArray [Int], but in order to use the function, the input must be wrapped:
18:32:03 <JoeyA> label (IntArray [1..3])
18:32:05 <tomberek> Saizan: of GHCi? (so i won't get pretty looking type sigs?)
18:32:24 <gwern> JoeyA: but you canb still do it
18:33:15 <JoeyA> Isn't there a better way?
18:33:17 <Saizan> tomberek: isn't that what you were referring to?
18:33:35 <JoeyA> It's almost like not being allowed to use pointers in a struct in C.
18:33:51 <gwern> JoeyA: oh, it may involve a little more typing, but the power is there!
18:33:58 <tomberek> yes... .. let me rephrase... Is this my fault, or something that the developers of GHCi need to fix?
18:34:01 <Saizan> JoeyA: you can say "instance IsInt a => Label [a] where" for some suitable IsInt class
18:34:21 <gwern> 'beware the Turing tarpit...'
18:34:24 <c_wraith> tomberek, ghci's :type direction won't show type operators infix, no matter what you do
18:34:29 <c_wraith> err, directive
18:34:36 <tomberek> c_wraith, Saizan :  roger.. thanks
18:34:47 <Saizan> yeah, the latter
18:34:53 <tomberek> grumble grumble, but thanks
18:35:01 <JoeyA> Saizan: Ah, good.
18:35:06 <c_wraith> Maybe no one's filed an enhancement request for it.
18:35:18 <JoeyA> Now I just have to figure out how to define the IsInt class...
18:35:35 <Saizan> i'd just use the extension though, honestly.
18:36:56 <tomberek> c_wraith.. http://hackage.haskell.org/trac/ghc/ticket/1930
18:37:35 <gwern> @wn palinode
18:37:36 <lambdabot> No match for "palinode".
18:40:13 <qz> how do i match compiled regex against anything? compile returns me something of type IO (Either (MatchOffset, String) Regex)
18:43:43 <ddarius> Saizan: An "IsInt" approach like that wouldn't really work.  However, a completely Haskell 98 answer would be to make a ListLabel class and then [] instances of Label could refer to it.
18:44:42 <ddarius> Another alternative, and the one Show uses, is to have show and showList.
18:44:51 <ddarius> @src Show
18:44:52 <lambdabot> class  Show a  where
18:44:52 <lambdabot>     showsPrec :: Int -> a -> ShowS
18:44:52 <lambdabot>     show      :: a   -> String
18:44:52 <lambdabot>     showList  :: [a] -> ShowS
18:44:59 <Saizan> ddarius: it'd work if you only wanted Label [Int], but ok :)
18:47:25 <JoeyA> Now I have an instance Label [Char] and instance Label Char .  How would I make an instance Label EverythingElse such that label x = show x ?
18:48:13 <ddarius> You can't unless you use OverlappingInstances and maybe also IncoherentInstances.
19:07:56 <qz> is it possible to turn Either a b into b in ghci ?
19:08:12 <aavogt> what happens if it's a Left?
19:08:41 <qz> i dont care =p i'm trying to make regular expression match something
19:09:11 <aavogt> let Right x = y
19:09:39 <aavogt> or apply a function like   either undefined id
19:09:43 <qz> and compiling regex gives me IO (Either (MatchOffset, String) Regex), so r <- compile gives that Either
19:09:50 <qz> hrm
19:09:55 <aavogt> @hoogle Either a b -> b
19:09:55 <lambdabot> Data.Either rights :: [Either a b] -> [b]
19:09:55 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
19:09:55 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
19:10:24 <aavogt> qz: you're allowed patterns there too
19:12:02 <qz> aavogt, nice.. let Right x = y removed Either, now its just Regex
19:12:25 <ddarius> qz: aavogt was saying you can write Right x <- compile ...
19:12:32 <ddarius> :t Data.Either.fromRight
19:12:33 <lambdabot> Not in scope: `Data.Either.fromRight'
19:12:34 <qz> oh
19:12:57 <ddarius> That also has the benefit of throwing an IOError rather than an asynchronous exceptino.
19:13:44 <qz> ok, now final step.. (s =~ r) :: Int gives 'No instances for...' even though s is ByteString and r is Regex
19:15:28 <ddarius> Hmm.  Are all invertible elements of a geometric algebra versors?
19:17:21 <Olathe> @hoogle debug
19:17:21 <lambdabot> module Text.XHtml.Debug
19:17:21 <lambdabot> Network.Socket Debug :: SocketOption
19:17:21 <lambdabot> Test.QuickCheck.Batch debug_tests :: TestOptions -> Bool
19:46:55 <aledge> hi there, any users of OpenGL here?
19:47:56 <aledge> actually I might have figured out my problem
20:16:22 <alexyk> well, in my case, haskell proved excruciatingly slow so far.  building a big graph in memory takes 2 hours.  serializing it to disk with Data.Binary spits data at a rate which will end in an ice age or so...
20:16:56 <alexyk> sure the data is 2-4 gigs in memory, but still
20:17:02 <alexyk> even clojure can handle it faster
20:17:20 <alexyk> I'm surely not doing something right though
20:17:24 <alexyk> in terms of speed
20:18:10 <Axman6> probably means you're doing it wrong
20:18:42 <Axman6> many structures can be built lazily, so something that would be gigs in memory can use les than 2MB for the whole program to run
20:19:13 <gwern> alexyk: my suggestions are to either post your program to -cafe as proof that haskell is useless and slow, or submit your spec to the great programming language shootout
20:19:16 <Axman6> really depends what you're doing though, as to whether you can expect good performance or not
20:19:45 <alexyk> gwern: that was of course angling for -cafe :)
20:20:36 <alexyk> haskell is surely useful, it's just my hope to switch to a compiled language and get quick speedup were dashed
20:20:54 <alexyk> it turns out you have to gauge laziness very carefully
20:20:58 <alexyk> or something
20:21:02 <kmc> you're using ghc -O2 i assume?
20:21:05 <kmc> and you've profiled?
20:21:13 <kmc> you can also try C and LLVM backends
20:21:14 <djahandarie> Definitely profile first before anything else
20:21:27 <djahandarie> LLVM won't help with structural flaws
20:21:29 <alexyk> e.g. ocaml just chugs along like crazy.  kmc: profiled but not clear where's the problem
20:21:50 <Axman6> profilling will tell you where you're going wrong, in terms of allocations etc
20:22:11 <kmc> did you try increasing the allocation area size?
20:22:17 <kmc> how much % time is it spending in GC?
20:22:41 <alexyk> kmc: ummm... is it in .prof?
20:22:54 <Axman6> alexyk: writing fast and efficient programs in any language takes experience. sadly haskell often punshed new users even more than most languages
20:23:16 <kmc> alexyk, ./foo +RTS -s
20:23:32 <alexyk> kmc: yep, did that... 1 sec
20:23:35 <mxc> any fedora using haskellers here/
20:23:37 <mxc> ?
20:27:35 <siracusa> Is there a way to determine if another process is already bound to a certain port?
20:28:03 <iaefai> If I want to do matrix transformations on a set of points, is hmatrix the best thing to look at?
20:28:13 <kmc> siracusa, there's a command called lsof
20:29:02 <mxc> siracusa an ugly way would be to  bind to htat port and catch an exception
20:29:17 <ddarius> iaefai: Your problem statement is massively underdefined, but hmatrix is probably a good place to start.
20:29:28 <alexyk> kmc: the profiling is here: http://paste.pocoo.org/show/221696/, the code is in two puny files, TC2.hs and JSON2Graph.hs, at http://github.com/alexy/husky.  I'm surprised that main has a bulk of time, along with json2graph, since there's nothing in main but fetch and that.
20:29:31 <siracusa> kmc: Where is it, in the network package?
20:29:56 <siracusa> mxc: I already tried that but it doesn't work.
20:29:57 <kmc> alexyk, but how long does it spend in gc?
20:30:01 <kmc> siracusa, i mean a command line command
20:30:07 <alexyk> kmc: this was done with 100,000 records fetched, while full run is 3M+
20:30:36 <kmc> alexyk, err, shouldn't main always have 100% inherited time?
20:30:46 <kmc> or you mean the individual time?
20:30:55 <alexyk> kmc: % alloc
20:30:58 <kmc> ah
20:31:08 <Axman6> alexyk: are you reading in a file in main?
20:31:11 <kmc> can you paste the output from -s
20:31:20 <alexyk> I ran with +RTS -p, do I have to run -s separately?
20:31:29 <kmc> yes
20:31:30 <alexyk> Axman6: reading from TokyoCabinet
20:31:40 <alexyk> okok
20:31:43 <kmc> -s prints various RTS info to stdout
20:31:46 <kmc> it's not profiling
20:32:12 <iaefai> ddarius: I shall improve my problem statement. I want to create a list of points for an ellipse defined by a semi-major axis and an eccentricity. I was going to create a list of points on a circle and tilt it back by the angle given by the arcsin of that eccentricity to form the ellipse.
20:33:28 <kmc> alexyk, you can manually add some cost centers inside main
20:33:35 <kmc> TC itself will have no cost centers unless you built in specially
20:33:46 <kmc> so your runTCM call and the like are showing up in "main"
20:34:28 <alexyk> ah ok
20:34:48 <kmc> as you probably noticed, the profiling output with -auto-all here is not too useful
20:34:57 <alexyk> kmc: does -s do stdout or stderr?
20:35:02 <kmc> don't remember
20:35:04 <kmc> you can do explicitly
20:35:06 <kmc> -sstderr
20:36:12 <djahandarie> Is there some nice lazy function that let's me work with two lists and a "combining" function at once?
20:36:38 <alexyk> well got to go for now, will continue later :)
20:36:49 <Axman6> Jonno_FTW_: zip(With)?
20:36:58 <Axman6> uh, djahandarie*, not Jonno_FTW_
20:36:59 <kmc> :t zipWith
20:37:00 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:37:08 <djahandarie> Oh wow
20:37:19 <Axman6> @src zipWith
20:37:19 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
20:37:19 <lambdabot> zipWith _ _      _      = []
20:37:22 <djahandarie> Seen that one before too
20:37:24 <kmc> @. hoogle type zipWith
20:37:25 <lambdabot> Parse error:
20:37:25 <lambdabot>   --count=20 "forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:37:25 <lambdabot> "
20:37:27 <kmc> eep
20:37:34 <kmc> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
20:37:34 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
20:37:34 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
20:37:34 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
20:38:01 <alexyk> kmc: ^C'ed out of write, got http://paste.pocoo.org/show/221697/ -- too much ain't it?
20:38:13 <alexyk> (apaprently -s went to stderr)
20:38:17 <kmc> your program is spending 93.6% of its time collecting garbage
20:38:20 <kmc> so yeah
20:38:23 <kmc> try
20:38:26 <kmc> +RTS -A400M
20:38:33 <kmc> with -sstderr also
20:38:39 <kmc> see if it goes down
20:38:39 <Axman6> uh, productivity pf 6.4%
20:38:43 <gwern> I've always found :T's use of forall to be odd. why output that format when it's not a valid typesig
20:38:50 <Axman6> wow, that's amazingly bad :)
20:39:03 <alexyk> imagine a graph of 5 GB
20:39:04 <kmc> gwern, it's valid with the right magic switches :)
20:39:06 <alexyk> a small one
20:39:26 <ddarius> gwern: That was reported as a bug at one point and now GHCi should only produce it when certain extensions are enabled.
20:39:26 <gwern> kmc: anything is valid if you throw enough options and hacks at it
20:39:29 <alexyk> see I need to exercise a language for real world data, no puny arrows-schmarrows :)
20:39:33 <kmc> not dependent types gwern :/
20:39:49 <gwern> ddarius: did it actually get resolved? cause I thought :t in lambdabot called out to ghci
20:39:56 <kmc> oh
20:40:02 <ddarius> gwern: Lambdabot has various extensions enabled.
20:40:02 <kmc> you're talking about ghci not \bot
20:40:03 * alexyk wonders if he's the first to data mine twitter in haskell or what
20:40:14 <gwern> alexyk: odds are pretty good
20:40:22 <gwern> ddarius: hm, it does?
20:40:32 <kmc> why do you think you're the first?
20:40:47 <gwern> (output, errors, _) ←  popen (ghci config) ["-v0","-fglasgow-exts","-XNoTemplateHaskell","-iState","-iscri
20:40:49 <Axman6> alexyk: well, use it in a way that it can do what you want. you obviously aren't at the moment, if you're spending 93.6% of your runtime doing garbage collection etc instead of doing actual work
20:40:50 <ddarius> There have definitely been people who've dealt with large data sets.  I'm sure there are people who've "data mined" before as well.
20:40:54 <alexyk> kmc: can I say -A20G or so?
20:40:59 <gwern> pts","-XNoMonomorphismRestriction"]
20:41:01 <kmc> is using TC mandatory for data-mining twitter?
20:41:03 <kmc> alexyk, sure
20:41:12 <kmc> alexyk, but your program may use all your RAM ;P
20:41:12 <alexyk> kmc: super-fast to interop with clojure
20:41:18 <kmc> ok
20:41:18 <gwern> ddarius: is it really useful for lambdabot to have -fglasgow-exts on for :t?
20:41:22 <alexyk> kmc: that's a fraction of my box :)
20:41:24 <kulakowski> Cabal says not to upgrade core packages. Which are those, or how does one determine if a package is a core package?
20:41:34 <kmc> i'm glad you have a big box
20:41:53 <alexyk> kmc: thank you for your gladness
20:41:59 <alexyk> :)
20:42:01 <ddarius> gwern: I doubt it uses -fglasgow-exts, probably just selected extensions, but, yes, of course it is.
20:42:03 <gwern> kulakowski: core = what came with ghc
20:42:18 <Axman6> things like base
20:42:25 <gwern> ddarius: well, that's what Plugin/Type.hs says, -fglasgow-exts, see my paste
20:42:30 <kulakowski> gwern: Just ghc, or things included with the platform as well?
20:42:44 <gwern> kulakowski: it should be safe to upgrade platform stuff, but don't take me at my word
20:42:50 <alexyk> you give haskell -A5G, it grabs it in 1 sec!
20:43:01 <alexyk> man, never saw something so greedy
20:43:19 <alexyk> and it's done at once!
20:43:26 <alexyk> was I being an idiot not to do it earlier?
20:43:38 <alexyk> the small part is done, of course
20:43:41 <kmc> alexyk, possibly, but it is not as prominently documented as i'd like
20:43:46 <gwern> alexyk: how could you've known?
20:44:06 <kmc> it'd be nice if the RTS would print a warning when the GC time is, say, over half
20:44:07 <alexyk> look at that: http://paste.pocoo.org/show/221699/
20:44:19 <gwern> you know what an OS thrashing looks like, but what does a haskell program thrashing feel like?
20:44:39 <ddarius> kmc: It shouldn't do that by default and -s effectively does that.  It could suggest -A though.
20:45:01 <kmc> yeah i don't like RTS output by default
20:45:10 <kmc> at the same time, there has to be a better way to disseminate this knowledge
20:45:23 <kmc> at least RWH mentions -s
20:45:54 <alexyk> so +RTS -Abig-ass-number works with any haskell executable, not necesserily a -prof'ed one, right?
20:46:00 <kmc> i feel like a lot of the tricks for writing good Haskell code are only documented in the oral history here
20:46:01 <Axman6> alexyk: you haven't solved your problem though, just posponed it
20:46:08 <kmc> alexyk, correct.  it'll be faster without -prof too
20:46:15 <alexyk> Axman6: dude, I've solved it for now :)
20:46:21 <kmc> Axman6, how's that?
20:46:35 <Axman6> no, you haven't. your program is still broken if it's so heavily allocating
20:46:41 <alexyk> but I'll post it to the cafe anyways, I have a clojure version and will have an ocaml version to compare.
20:46:51 <alexyk> let the real data-based shootout occur
20:46:55 <kmc> hehe
20:46:56 <ddarius> Axman6: There's nothing inherently wrong with quickly producing garbage.
20:47:16 <ddarius> But it is likely that steps could be taken to significantly reduce the turn-over.
20:47:30 <Axman6> yes
20:47:38 <kulakowski> This is possibly a silly question, but why does cabal let me upgrade core packages as easily as non-core packages? Seems like if I'm not supposed to do so, there should be a "I know what I'm doing" knob if you actually need to do so.
20:47:49 <iaefai> Is there a library that handles summation and product of series? (sigma, pi) in a manner that would permit a notation not too far removed from the math itself?
20:48:21 <ddarius> sum (\n -> x^n) is already pretty darned close
20:48:27 <Axman6> anyone think that a nice binding to MPI would be useful? there's an old one, but i'd be surprised if it even still compiled
20:48:37 <kmc> Axman6, yes :D
20:48:44 <DrSyzygy> Axman6: Definitely, yes.
20:48:47 <Axman6> heh
20:48:57 <Axman6> maybe this could be a holiday project for me :)
20:49:05 * Axman6 needs to know more MPI though
20:49:13 <kmc> also write an auto-distribution MPI backend for DPH
20:49:18 <kmc> that should be a fun holiday project ;)
20:49:34 <Axman6> i think i'd make it so it were quite type safe, but keep the semantics quite close to how it works in  C
20:50:22 <Axman6> kmc: in the DPH darcs repo, there's already a mysterious distributed folder somewhere
20:50:27 <kmc> :O
20:50:36 <kmc> DDPH
20:50:38 <Axman6> but i haven't heard any news about it
20:51:41 <gwern> kulakowski: cabal doesn't know what's core
20:51:41 <Axman6> and it didn't look very well fleshed out when i looked at it last
20:52:09 <Axman6> i wonder how easily you could make haskell programs play nice with MPI, so that you can run mpirun on a haskell program, and have it all work
20:53:04 <Axman6> hopefully it could just work
20:54:32 <alexyk> Axman6: I read a graph, say 5 GB, as key->value string pair list, then convert JSON to a structure, and do a fromList Map of all.  I need to hold the whole graph in RAM by the end, when the algorithms will devour it.  So the allocations make sense I guess -- it's not like I can slide small data through a read/write window
20:55:28 <Axman6> just run: main = do { getArgs >>= mpiInit; rank <- mpiGetRank; nodes <- mpiGetNodes; if rank = 0 then foo else bar}
20:55:32 <alexyk> boy it's cooking -- from 4 hours to 5 seconds read, now writing a meg a sec of gzipped
20:55:45 <Axman6> alexyk: maybe you might look at using a more efficient datastructure
20:55:59 <alexyk> Axman6: nah, a graph is a map of maps
20:56:20 <Axman6> sounds like that could be pretty inefficient
20:56:24 <alexyk> best way -- clojure rips it, and interop is clean, and reasoning is clear
20:56:47 <alexyk> well, for my purposes, before I drop it into hadoop, should do it :)
20:56:53 * Axman6 has no idea what clojure rips it is supposed to mean
20:58:24 <alexyk> clojure the languages rips the maps as a dog rips a sausage
21:01:47 <alexyk> perhaps the aussie equivalent would involve a koala and an indigenous fruit :)
21:01:50 <Axman6> is that a good thing or a bad thing?
21:01:55 <alexyk> copumpkin: haskell works!
21:02:23 <Axman6> perhaps you could say things that make sense to more people than just yourself ;)
21:02:29 <copumpkin> alexyk: yay
21:02:51 <alexyk> 11 minutes, 100 M tweets graph serialized into a 200 MB Data.Binary thing, compressed
21:03:21 <copumpkin> alexyk: cool, how much better is that?
21:04:45 <JoeyA> I have two data definitions that are exactly the same, but are used for different purposes.  Both data types share several common functions.  How might I use a class or something to factor it?
21:04:48 <JoeyA> data Graph a = Graph [a] ((a,Int) -> (a,Int) -> Bool)
21:04:52 <JoeyA> data DiGraph a = DiGraph [a] ((a,Int) -> (a,Int) -> Bool)
21:05:21 <copumpkin> JoeyA: just consider a graph as a digraph with edges in both directions?
21:05:36 <copumpkin> I wouldn't use a function representation for a graph, though
21:06:00 <copumpkin> at least not in that way
21:06:22 <copumpkin> it prevents you from enumerating over the neighbors of a given node easily
21:06:28 <JoeyA> I thought it was extremely elegant, but I guess a boxed array of bools would be better than this.
21:06:41 <alexyk> copumpkin: it's not slower than the best clojure, and much faster than the equivalent one.  it's almost as good as ocaml feels on a sunny day :) ttyl...
21:07:13 <copumpkin> alexyk: great! ciao :)
21:07:22 <JoeyA> Granted, there are better representations
21:07:40 * Axman6 still thinks that using -A5G is cheating, but oh well
21:07:41 <JoeyA> (depending on circumstances)
21:07:53 <ddarius> JoeyA: For operations that apply to any graph-like thing, a class would not be inappropriate.
21:08:51 <JoeyA> Indeed.  Consider a 2D matrix of bools representation.  If we want to count edges for an undirected graph, we just count the bools in the upper triangle.
21:09:01 <JoeyA> While for a directed graph, we count all combinations.
21:10:00 <JoeyA> [(0,1),(0,2),(1,2)] instead of [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
21:12:06 <JoeyA> Also, I suppose a really fancy Graph implementation could implement multiple representations and choose the best one as it goes.
21:15:40 <tomberek> JoeyA: Graph implementation?
21:15:53 <JoeyA> as in, for manipulating topologies
21:16:10 <tomberek> ivanm and myself are working on a FGL rewrite
21:16:48 <tomberek> darcs repo at code.haskell.org/FGL/fgl  if you have any ideas, i'd love to hear them
21:16:49 <JoeyA> I've been toying around, and I came up with a working implementation for this:
21:16:52 <JoeyA> showgraph $ topology ["abc","bd"]
21:17:12 <JoeyA> err
21:17:21 <JoeyA> showdigraph $ topology ["abc","bd"]
21:17:29 <JoeyA> actually, both work, but the latter shows a directed graph
21:17:42 <JoeyA> with a -> b -> c and b -> d
21:19:11 <tomberek> JoeyA, what kind of representation is that?
21:19:45 <digitteknohippie> anyone know how to get a bot to identify it's nick?  i thought it'd be as simple as getting it to say just what i would say if i were identifying.  but that just posted it to the chat, instead of actually doing a /msg nickserv identify
21:21:11 <JoeyA> tomberek:  For the above snippets, doesn't matter :-)  Currently, it's using the list of elements and a "does A point to B" predicate, but I'm switching it over to data Graph a = Graph [a] (Array (Int,Int) Bool) instead
21:21:29 <JoeyA> Hmm, I wonder if I should use Array (Int) a instead
21:21:40 <JoeyA> might help for some algorithms
21:22:11 <tomberek> JoeyA, can I suggest you use a Graph API, Data.Graph, FGL, or our rewrite,, that way your code will work with any graph that is part of the appropriate typeclass
21:23:15 <Axman6> digitteknohippie: /commands are a client specific thing. you'd need to QUOTE the message (i think). you'll have to create the message by hand
21:24:00 <digitteknohippie> i think i tried doing it with !id too, if thats what you mean.
21:24:08 * digitteknohippie checks again
21:25:26 <digitteknohippie> yeah, that fails too.
21:25:44 <tomberek> JoeyA, because eventually, i'd like to include things like what you are writing into the FGL package
21:25:53 <digitteknohippie> especially given it means i'd have to present the password in chat for all to see.  ^_^  i presume you didnt mean what i thought u meant then
21:26:11 <JoeyA> tomberek:  Dumb answer:  I'd rather reinvent the wheel because I hate seeing that other people "already thought of it".  Normal answer:  I'm doing this for learning purposes.  Smart answer:  I'd rather do this on my own first so new ideas can divergently evolve.
21:27:25 * digitteknohippie likes JoeyA's answer distinctions. :)
21:27:28 <tomberek> JoeyA : ok, if you get somehing working and are satisfied, I'd like to port it to the FGL rewrite.
21:27:46 * Rotaerk hates it when other people already thought of it !! >=(
21:28:22 <JoeyA> Rotaerk: I hear you there
21:28:47 <digitteknohippie> yeah, isnt the typical dumb answer usually more along the lines of:  "i want it to just work!"
21:30:07 <JoeyA> It's worse when someone else thought of it, but they do something stupid with it.
21:30:21 <JoeyA> I was really looking forward to inventing JSONPath (an XPath analogue for JSON)
21:30:35 <tomberek> anyone familiar with Mu?
21:30:38 <JoeyA> But noooo, someone else already did it, and their implementation makes you put a $ before just about every pattern.
21:30:46 <kmc> tomberek, yeah
21:30:49 * digitteknohippie goes back to his issue n fears he may have to write his own monad for the first time.    "i'm not ready for this!" he wails and starts crying.    XD
21:31:34 <tomberek> kmc: i've been working on a project, and the more i work on it, it seems category-extras has most of what I need.  So I'm trying to use it.
21:31:46 <kmc> right
21:32:38 <tomberek> kmc: i'm trying to connect his unfzip function and Zip classes
21:33:22 <copumpkin> tomberek: you should do this all in agda
21:33:27 <copumpkin> I'm sure it'll be way easier
21:33:55 <copumpkin> tomberek: category-extras has most of what everyone needs in it, which is part of the problem :P
21:34:02 <tomberek> copumpkin, i've heard that (this is also a learning project for myself)
21:34:26 <tomberek> so the idea would be to have    izip  m = fzip (fst m) (snd m)     izip :: (Zip f) => (f a ,f b) -> f (a, b)
21:34:47 <copumpkin> @typo uncurry (liftA2 (,))
21:34:48 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
21:35:19 <tomberek> so izip.unfzip == id
21:35:42 <tomberek> copumpkin,, that requires Applicative?
21:36:16 <copumpkin> yep, it's practically the definition of a lax monoidal functor
21:36:29 <copumpkin> or the interesting part of it, anyway
21:36:38 <tomberek> copumpkin, mine is Zip... which is the more general?
21:36:40 <copumpkin> (which is the mathturbatory name for applicative)
21:36:46 <copumpkin> I can't remember what Zip does
21:36:56 <tomberek> fzip :: f a -> f b -> f (a, b)
21:37:08 <tomberek> class Functor f => Zip f where
21:37:27 <copumpkin> ah, Applicative can have an instance for that, but what laws are there on fzip?
21:37:40 <DrSyzygy> So applicative is a lax monoidal functor?!
21:37:45 <DrSyzygy> Suddenly things start making sense!!
21:38:00 <tomberek> copumpkin,, there is only that one function  (that and fzipWith :: (a -> b -> c) -> f a -> f b -> f c)  so no laws
21:38:11 <copumpkin> tomberek: :O
21:38:16 <copumpkin> NO LAWS?!
21:38:19 <copumpkin> anarchy!
21:38:23 <tomberek> so it seems Zip is more general, or do i have that backwards?
21:38:25 <DrSyzygy> That's the lax part, is it?
21:38:29 <copumpkin> lol
21:38:42 <tomberek> copumpkin,,, er... i see no laws listed in the code
21:38:45 <copumpkin> tomberek: well you can't get more general than no laws
21:38:59 <copumpkin> :)
21:39:19 <copumpkin> why am I even awake this early
21:39:21 <copumpkin> ugh
21:39:26 <tomberek> copumpkin, at first I was working with liftA2 as well, then found Zip
21:39:31 <copumpkin> ah
21:40:11 <tomberek> copumpkin: so now I'm trying to expand the usage
21:40:26 <danielq> has anyone ever used "getDay"? which module does it belong to?
21:40:31 <copumpkin> hmm
21:40:44 <copumpkin> I assume there's some deep categorical notion of zipping
21:40:48 <copumpkin> that I'm not aware of because I'm a n00b
21:40:50 <tomberek> copumpkin.. eg: right now it works on a Functor of (a,b)
21:40:59 <copumpkin> tomberek: you may need to await edwardk :)
21:41:12 <tomberek> copumpkin: i want it to work on a Functor of Functor of (a,b)
21:41:15 <tomberek> and etc.
21:41:39 <copumpkin> hmm
21:41:45 <tomberek> i looked at it, and edwardk has a Functor composition
21:41:47 <tomberek> CompF
21:41:52 <copumpkin> yeah
21:42:26 <tomberek> so, i can get all that to work, IF you go in there and compose them by hand,,, i want to make it automatic.. recursive.. and so i thought of Mu
21:42:39 <copumpkin> well, Mu will give you recursion :P
21:42:47 <tensorpudding> How does OverlappingInstances work anyway?
21:43:01 <copumpkin> tensorpudding: implementation-wise? or what does it give you?
21:43:19 <tensorpudding> I mean, how does it figure out which instance to use in a particular situation?
21:43:26 <copumpkin> I think it has some heuristics for determining what counts as more specific
21:43:31 <copumpkin> and always picks that
21:43:40 <copumpkin> sometimes it's a tough decision though
21:43:51 <tensorpudding> Hmm.
21:44:02 <copumpkin> so maybe Maybe Int is more specific than Maybe a
21:44:09 <copumpkin> but how about Either Int a vs. Either a Int
21:44:13 <copumpkin> anyway, I'm talking out of my ass
21:44:18 * copumpkin shuts up
21:44:47 <copumpkin> tomberek: why do you want functor fixed points though?
21:44:49 <kmc> you get a partial order from substitutability
21:45:05 <kmc> and i'd assume "most specific" means "dominates in this order"
21:45:08 <kmc> which wouldn't be heuristic
21:45:11 <kmc> but i'm not totally sure
21:45:20 <copumpkin> that sounds about right :) maybe not a heuristic
21:45:24 <tomberek> copumpkin.. so i was thinking of a function that would compose the Functors for you... (um, i don't, it just sounded like recursion in types, i know next to nothing about 'fixed points')
21:45:38 <copumpkin> hmm, then you shouldn't need Mu
21:45:47 <copumpkin> Mu is fix at the type level
21:45:54 <tomberek> ok,, then i was wrong.. then what should I use?
21:45:56 <copumpkin> or Nu
21:46:11 <copumpkin> well, if you're just composing functors, use his functor composer!
21:46:37 <copumpkin> newtype Beethoven f g a = Beethoven (f (g a))
21:46:55 <DrSyzygy> Latest xkcd is bloody hilarious.
21:47:21 <tomberek> copumpkin,, yes, but then you have to do this:  compose $ compose # [[(1,2)]]
21:47:54 <tomberek> and then compose $ compose $ compose [[[(1,2)]]]
21:47:57 <kmc> the great thing about xkcd is how, even if i didn't subscribe, i'd hear about it from every unrelated blog and IRC channel
21:48:00 <copumpkin> really?
21:48:18 <copumpkin> tomberek: you don't have an instance (Functor f, Functor g) = Functor (Beethoven f g) ?
21:48:40 <tomberek> lol
21:48:43 * copumpkin fmaps furiously
21:48:51 <tensorpudding> why Beethoven?
21:48:52 <kmc> copumpkin, you'll go blind
21:49:02 <tomberek> tensorpudding: 'compose'
21:50:58 <copumpkin> "For example, a tweaked Motorola Droid can hit 52 Mflop/s, which is more than 15 times faster than the CPUs used in the 1979 Cray-1."
21:51:20 <tomberek> copumpkin, the other issue is that ((,)a) is a functor as well... so CompF [(1,2)] gives a List x half tuple composition
21:52:03 <copumpkin> well there are only two ways to make a tuple into a functor and one of them can't be written in haskell without a wrapper type
21:52:04 <tensorpudding> They used to make computers with 68k, now they use that for calculators.
21:53:04 <tomberek> copumpkin, yes, but because unfzip works on f (a,b).. i need the recursion of compose to stop there.. so i can't just recurse on ANY two functors
21:53:46 <tensorpudding> Does the TI-89 Titanium have more processing power than a Commodore PET?
21:56:23 <tensorpudding> Apparently it's significantly more powerful.
21:57:50 <jewillco> @seen lambdabot
21:57:50 <lambdabot> Unknown command, try @list
21:57:56 <jewillco> @list
21:57:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:58:07 <tensorpudding> preflex: seen lambdabot
21:58:08 <preflex>  lambdabot was last seen on #haskell 10 seconds ago, saying: http://code.haskell.org/lambdabot/COMMANDS
21:58:17 <jewillco> @pl liftA2 (<=<) (liftA return . (:)) $ liftA (flip list $ return []) $ flip . (flip (scanlM f) >>>) . (>=>) . f
21:58:18 <lambdabot> liftA2 (<=<) (liftA return . (:)) (liftA (flip list (return [])) (flip . (flip (scanlM f) >>>) . (>=>) . f))
21:58:27 <jewillco> @pl (\ f -> liftA2 (<=<) (liftA return . (:)) $ liftA (flip list $ return []) $ flip . (flip (scanlM f) >>>) . (>=>) . f)
21:58:27 <lambdabot> liftA2 (<=<) (liftA return . (:)) . liftA (flip list (return [])) . (flip .) . ap ((.) . (>>>) . flip . scanlM) ((>=>) .)
21:58:51 <tensorpudding> Maybe you want @unpl?
21:59:13 <tensorpudding> @unpl liftA2 (<=<) (liftA return . (:)) $ liftA (flip list $ return []) $ flip . (flip (scanlM f) >>>) . (>=>) . f
21:59:13 <lambdabot> (liftA2 (<=<) (\ p -> liftA return (((:)) p)) (liftA (\ c -> list c (return [])) (\ w e g -> ((\ i j -> scanlM f j i) >>> ((>=>) (f w))) g e)))
21:59:24 <tensorpudding> eh, that's not helpful
21:59:39 <jewillco> I wanted to see if it could mangle it further
21:59:44 <jewillco> I got it to what I posted by hand
21:59:54 <tensorpudding> If it's already point-free, than it can't be made moreso
22:00:02 <jewillco> There is f in there
22:00:14 <jewillco> (this is a function body)
22:00:22 <tensorpudding> I missed that I guess.
22:00:28 <copumpkin> you're really using liftA?
22:00:33 <copumpkin> and return?
22:00:39 <jewillco> I was being creative :-)
22:00:41 <copumpkin> o.O
22:00:53 <copumpkin> (pure <$>) ftw
22:00:53 <jewillco> It's a way to get things points-free a lot easier
22:01:04 <jewillco> What is that one?
22:01:06 <copumpkin> oh I just mean
22:01:11 <copumpkin> liftA = fmap = <$>
22:01:12 <copumpkin> return = pure
22:01:16 <copumpkin> they're shorter
22:01:22 <jewillco> OK
22:01:25 <copumpkin> and liftA and return impose different constraints on the types
22:01:29 <tensorpudding> They also require importing Applicative.
22:01:45 <jewillco> I was already doing that to get liftA
22:01:52 <jewillco> and >>>
22:02:01 <tensorpudding> It's kinda silly to import Applicative just for <$>
22:02:02 <copumpkin> Applicative shouldn't give you >>>
22:02:07 <copumpkin> Category or Arrow should
22:02:10 <tensorpudding> Though I've done that before.
22:02:16 <tomberek> jewillco : look at TypeCompose package
22:02:21 <copumpkin> tensorpudding: Data.Functor ftw :P
22:02:27 <copumpkin> (don't ask me why it's Data.)
22:02:28 <jewillco> I forgot -- it was Arrow
22:02:32 <copumpkin> but it's in the standard library now
22:02:37 <jewillco> (my GHC is too old to have Category)
22:02:41 <tensorpudding> When did that happen?
22:02:54 <copumpkin> tensorpudding: beats me, but I first noticed it in 6.12
22:02:57 <jewillco> :type ap
22:03:01 <jewillco> @type ap
22:03:01 <tensorpudding> I've never heard of Data.Functor.
22:03:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:03:13 <tomberek> @src on
22:03:13 <lambdabot> (*) `on` f = \x y -> f x * f y
22:03:25 <copumpkin> tensorpudding: well, now you have :P
22:03:29 <tomberek> that's in Data.Functor
22:03:44 <jewillco> Is that the same as liftA2?
22:03:45 <copumpkin> it's in Data.Function
22:03:51 <jewillco> @type liftA2
22:03:52 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
22:03:55 <tensorpudding> It's kinda weird that a lot of Functor instances are in Data.Monad.Instances
22:04:00 <jewillco> @type on
22:04:01 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:04:10 <jewillco> Not quite I guess
22:04:20 <tomberek> jewillco : it is different
22:04:25 <jewillco> I just wish Hoogle could search all of the Monad, Arrow, Applicative, ... instances
22:04:38 <jewillco> it doesn't know you can use liftA, ... for points-free functions
22:05:00 <jewillco> @hoogle (a -> b) -> (b -> c) -> (a -> c)
22:05:00 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:05:00 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
22:05:00 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
22:05:05 <tomberek> so, no ideas on how to auto-compose Functors? anyone?
22:05:17 <jewillco> What do you mean auto-compose?
22:05:30 <jewillco> :type <<<
22:05:33 <jewillco> @type <<<
22:05:34 <lambdabot> parse error on input `<<<'
22:05:38 <jewillco> @type (<<<)
22:05:39 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
22:05:48 <jewillco> @type (>>>)
22:05:48 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:06:06 <jewillco> @type ((>>>) :: (a -> b) -> (b -> c) -> (a -> c))
22:06:06 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
22:06:12 <jewillco> but Hoogle can't find it
22:06:19 <tomberek> jewillco: i want to turn   [[[[(1,2)]]]] into Functors [] [] [] [] (1,2)  or something
22:06:31 <jewillco> There isn't a type class trick for that?
22:06:38 <tomberek> i think so,, i don't know it
22:06:47 <jewillco> Isn't that what Data.Generic is for, though?
22:06:54 <jewillco> gmap or such?
22:07:00 <jewillco> I don't know them that much
22:07:07 <jewillco> but what you're doing sounds like that
22:07:23 <copumpkin> tomberek: hmm, I don't really understand
22:07:26 <tensorpudding> gmap is Data.Data right?
22:07:31 <tomberek> @src gmap
22:07:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:07:35 <copumpkin> on the type level, that would be [[[[(Int, Int)]]]]
22:07:43 <copumpkin> which is already equivalent to [] [] [] [] (Int, Int)
22:07:51 <tomberek> copumpkin,, correct, but can you unfzip it?
22:08:00 <tensorpudding> Eh, thinking of gfold and co.
22:08:09 <tomberek> nope, you have to create a new functor out of ([] [] [] [])
22:08:13 <tensorpudding> @type gfoldl
22:08:14 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
22:09:46 <tomberek> tensorpudding: is that for me?
22:10:39 <tensorpudding> No, I just look at gfoldl sometimes, someday I might get a feel for what it actually is
22:10:52 <tomberek> lol
22:11:38 <jewillco> @help run
22:11:38 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
22:11:45 <jewillco> @help let
22:11:45 <lambdabot> let <x> = <e>. Add a binding
22:11:50 <jewillco> @type
22:11:51 <lambdabot> <no location info>: not an expression: `'
22:11:52 <jewillco> @help type
22:11:52 <lambdabot> type <expr>. Return the type of a value
22:11:57 <jewillco> @help data
22:11:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:12:32 <jewillco> @help compose
22:12:32 <lambdabot> . <cmd1> <cmd2> [args].
22:12:32 <lambdabot> . [or compose] is the composition of two plugins
22:12:32 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
22:12:35 <tomberek> compumpkin:  so.. i can write irip=unfzip  and then irip2 m = (runCompF $ fst pair , runCompF $ snd pair) where pair = irip $ CompF
22:13:13 <tomberek> copumpkin: and keep going with irip3,4,5... but it looks like a recursion, so I think i can make one that does all that for me
22:13:18 <copumpkin> tensorpudding: the docs are actually fairly helpful on that
22:14:22 <tensorpudding> As far as I can see, knowing what gfoldl is isn't necessary to make use of Data.Data.Data
22:14:33 <copumpkin> yeah
22:14:34 <Olathe> Is there a function that does f [id, negate] [a, b] = [[a, b], [-a, -b]] ?
22:14:34 <tensorpudding> That's a really unfortunate name.
22:15:05 <copumpkin> @typo liftA2 id
22:15:06 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
22:15:15 <copumpkin> @typo (<*>)
22:15:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:15:22 <tensorpudding> typo?
22:15:24 <Olathe> > liftA2 [id, negate] [1, 2]
22:15:24 <lambdabot>   Couldn't match expected type `a -> b -> c'
22:15:25 <lambdabot>         against inferred type `[...
22:15:26 <copumpkin> > [id, negate] <*> [a, b]
22:15:26 <lambdabot>   [a,b,negate a,negate b]
22:15:36 <copumpkin> oh, too flat
22:15:40 <Olathe> Yeah :(
22:16:08 <copumpkin> well, you can write one really easily :P
22:16:24 <Olathe> @hoogle [a -> a] -> [a] -> [[a]]
22:16:24 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:16:24 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
22:16:24 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
22:16:26 <tensorpudding> @hoogle [a -> b] -> [a] -> [[b]]
22:16:26 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:16:26 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
22:16:26 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
22:16:29 <kulakowski> zipWith ($)
22:17:04 <copumpkin> kulakowski: that won't give him the same behavior
22:17:07 <Olathe> > zipWith ($) [id, negate] [1, 2]
22:17:08 <lambdabot>   [1,-2]
22:17:15 <kulakowski> oh I misread
22:17:43 <Olathe> Now that I think of it, there's probably not one, since the functions would have to be a -> a, rather than merely a -> b
22:17:49 <jewillco> Here's an easy way:
22:17:54 <jewillco> class T t where f :: (Int -> Int) -> t -> t instance T s => T [s] where f g ls = map (f g) ls instance T Int where f g x = g x
22:18:02 <copumpkin> > map (zipWtih id [id, negate]) [1, 2]
22:18:03 <lambdabot>   Not in scope: `zipWtih'
22:18:09 <copumpkin> > map (zipWith id [id, negate]) [1, 2]
22:18:09 <lambdabot>   No instance for (GHC.Num.Num [b])
22:18:10 <lambdabot>    arising from a use of `e_112' at <inte...
22:18:14 <jewillco> class T t where f :: (Int -> Int) -> t -> t; instance T s => T [s] where f g ls = map (f g) ls; instance T Int where f g x = g x
22:18:17 <copumpkin> boo
22:18:34 <jewillco> Then f (+1) ([[[[[[3,4]]]]]]::[[[[[[Int]]]]]])
22:18:52 <copumpkin> > map (sequence [id, negate]) [1, 2]
22:18:53 <lambdabot>   [[1,-1],[2,-2]]
22:19:05 <Olathe> I'm basically trying for :
22:19:06 <Olathe> > let negatize [] = [[]]; negatize xxs@(x:_) = let (ys, zs) = span (==x) xxs; zs' = negatize zs in map (ys++) zs' ++ map ((map negate ys)++) zs' in negatize [1, 1, 2, 2, 3, 3]
22:19:07 <lambdabot>   [[1,1,2,2,3,3],[1,1,2,2,-3,-3],[1,1,-2,-2,3,3],[1,1,-2,-2,-3,-3],[-1,-1,2,2...
22:20:01 <danielq> has anyone used getDay?
22:20:15 <tomberek> jewillco, perhaps
22:20:25 <tomberek> but edwardk is here now,, hi!
22:21:20 <tensorpudding> > [id,negate] `ap` [1,2]
22:21:21 <lambdabot>   [1,2,-1,-2]
22:22:00 <jewillco> @help unlambda
22:22:00 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
22:22:46 <copumpkin> > (sequence . map map $ [id, negate]) [1, 2]
22:22:46 <lambdabot>   [[1,2],[-1,-2]]
22:22:54 <copumpkin> Olathe: ^
22:23:06 <jewillco> @help fact
22:23:06 <lambdabot> fact <fact>, Retrieve a fact from the database
22:23:20 <copumpkin> Olathe: so sequence . map map
22:23:40 <copumpkin> or in Caleskell ;)
22:23:51 <jewillco> @type (sequence . map map)
22:23:52 <lambdabot> forall a b. [a -> b] -> [a] -> [[b]]
22:23:59 <Olathe> > let negatize = map concat . sequence . map (\xs -> [xs, map negate xs]) . group in negatize [1, 1, 2, 2]
22:24:00 <lambdabot>   [[1,1,2,2],[1,1,-2,-2],[-1,-1,2,2],[-1,-1,-2,-2]]
22:24:31 <Olathe> @type sequence . map map
22:24:31 <lambdabot> forall a b. [a -> b] -> [a] -> [[b]]
22:24:41 <jewillco> @type transpose
22:24:42 <lambdabot> forall a. [[a]] -> [[a]]
22:24:49 <jewillco> @type transpose . ap
22:24:50 <lambdabot>     Couldn't match expected type `[[a]]'
22:24:50 <lambdabot>            against inferred type `m a1 -> m b'
22:24:50 <lambdabot>     Probable cause: `ap' is applied to too few arguments
22:25:00 <Olathe> > let negatize = map concat . sequence . map (\xs -> [xs, map negate xs]) . group in transpose $ negatize [1, 1, 2, 2]
22:25:01 <lambdabot>   [[1,1,-1,-1],[1,1,-1,-1],[2,-2,2,-2],[2,-2,2,-2]]
22:25:03 <jewillco> @type transpose . (<*>)
22:25:04 <lambdabot>     Couldn't match expected type `[[a]]'
22:25:04 <lambdabot>            against inferred type `f a1 -> f b'
22:25:04 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
22:25:31 <copumpkin> jewillco: <*> has already "flattened" it, so there's no information there to transpose it anymore
22:25:39 <jewillco> OK
22:25:40 <copumpkin> and transposing isn't quite what he wants anyway
22:25:52 <copumpkin> unflatten :: [a] -> [[a]] :P
22:25:52 <jewillco> I wasn't trying to deal with the group part
22:25:56 <copumpkin> ah
22:26:09 <copumpkin> need moar naturality
22:27:35 <kulakowski> @type flip (map . flip map)
22:27:36 <lambdabot> forall a b. [a -> b] -> [a] -> [[b]]
22:29:00 <tensorpudding> > liftM2 ($) [id,negate] [1,2]
22:29:00 <lambdabot>   [1,2,-1,-2]
22:29:03 <tensorpudding> meh
22:31:47 <tensorpudding> > let func a b = do f <- a; return (fmap f b) in func [id,negate] [1,2]
22:31:48 <lambdabot>   [[1,2],[-1,-2]]
22:32:47 <tensorpudding> I think there should be a way to do this for Applicatives instead of Monads though
22:33:13 <tensorpudding> @pl \a b -> do f <- a; return (fmap f b)
22:33:13 <lambdabot> (line 1, column 18):
22:33:13 <lambdabot> unexpected ";"
22:33:13 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
22:33:23 <tensorpudding> @pl \a b -> (do f <- a; return (fmap f b))
22:33:23 <lambdabot> (line 1, column 19):
22:33:24 <lambdabot> unexpected ";"
22:33:24 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
22:33:37 <ddarius>  @pl doesn't understand do-notation
22:33:37 <tensorpudding> bleh
22:34:17 <jewillco> @pl \ a b -> f >>= flip fmap b
22:34:17 <lambdabot> const ((f >>=) . flip fmap)
22:34:33 <tensorpudding> yeah
22:34:38 <jewillco> @pl \a b -> a >>= flip fmap b
22:34:38 <lambdabot> (. flip fmap) . (>>=)
22:35:35 <jewillco> @type (. flip fmap) . (>>=)
22:35:36 <lambdabot> forall a b (m :: * -> *). (Functor m, Monad m) => m (a -> b) -> m a -> m b
22:36:21 <jewillco> @hoogle product
22:36:21 <lambdabot> Prelude product :: Num a => [a] -> a
22:36:21 <lambdabot> Data.Foldable product :: (Foldable t, Num a) => t a -> a
22:36:21 <lambdabot> Data.List product :: Num a => [a] -> a
22:36:28 <jewillco> @hoogle cart
22:36:29 <lambdabot> No results found
22:37:04 <jewillco> @type (\ f -> fmap (fmap f))
22:37:05 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
22:37:39 <jewillco> @type fmap (fmap ($))
22:37:40 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (f (a -> b))
22:38:04 <jewillco> @type fmap fmap ($)
22:38:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:38:40 <jewillco> :type <$>
22:38:43 <jewillco> @type <$>
22:38:44 <lambdabot> parse error on input `<$>'
22:38:48 <jewillco> @type (<$>)
22:38:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:38:59 <jewillco> @type (<*>)
22:39:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:42:39 <tensorpudding> okay
22:42:59 <tensorpudding> @type \a b -> fmap ((flip (<$>)) b) a
22:43:00 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f a -> f1 (f b)
22:43:44 <tensorpudding> > (\a b = fmap ((flip (<$>)) b) a) [id,negate] [1,2]
22:43:44 <lambdabot>   <no location info>: parse error on input `='
22:43:52 <tensorpudding> > (\a b -> fmap ((flip (<$>)) b) a) [id,negate] [1,2]
22:43:52 <lambdabot>   [[1,2],[-1,-2]]
22:43:57 <tensorpudding> there we go
22:44:17 <tensorpudding> works on generic Functors
22:45:10 <tensorpudding> > (\a b -> fmap ((flip (<$>)) b) a) [id,negate] (Just 3)
22:45:11 <lambdabot>   [Just 3,Just (-3)]
22:45:45 <kulakowski> > flip (fmap . flip fmap) [id, negate] (Just 3)
22:45:46 <lambdabot>   [Just 3,Just (-3)]
22:47:04 <alexyk> it's late and I don't get why I get a parse error on = here: http://paste.pocoo.org/show/221706/
22:47:24 <ezyang> I heard that polymorphic functions in Haskell are /almost/ like natural transformations, but not quite. Why the not quite?
22:47:30 <tensorpudding> can't use = in a do block
22:47:43 <tensorpudding> you'll need a let binding
22:48:13 <alexyk> argh of course
22:48:20 <dolio> ezyang: What about 'forall a. (a -> a) -> a'?
22:48:25 <alexyk> I was staring at the first =
22:48:43 <tensorpudding> The problem is almost assuredly with the one inside the do block
22:49:25 <ezyang> dolio: Huh.
22:49:34 <tensorpudding> You could also go wild with long lines and just put that statement for g in where you see g on line 4
22:49:37 <dolio> FA = A -> A isn't even a functor.
22:50:03 <ezyang> I don't think you can write that function, if that's what you mean...
22:50:10 <copumpkin> :t fix
22:50:11 <lambdabot> forall a. (a -> a) -> a
22:50:15 <dolio> You can in Haskell.
22:50:27 <ezyang> oh right ^_^
22:50:39 <tensorpudding> Ah fix, that thing...
22:50:46 <ezyang> So, is it a tad too lax?
22:50:53 <tomberek> copumpkin: hey, i'm back
22:50:58 <copumpkin> yo
22:51:28 <Olathe> @hoogle (Eq a) => [a] -> [a]
22:51:28 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
22:51:28 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
22:51:28 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
22:52:28 <dolio> Anyhow, if you consider F, L : Hask^op x Hask -> Hask, F A B = A -> B, L A B = B, then 'fix :: forall a. (a -> a) -> a' is probably a dinatural transformation from F to L.
23:01:48 <cat_gone_mad>  anyone wanna see an attempt at writing a window framework from scratch ?
23:07:34 <kniu> cat_gone_mad, whuh?
23:08:01 <cat_gone_mad> kniu, http://www.sendspace.com/file/0dgtaj
23:10:31 <tomberek> @src (:*:)
23:10:31 <lambdabot> Source not found.
23:11:27 <DrSyzygy> tomberek: Bound to be a type constructor.
23:11:54 <tomberek> yes, i've encountered :**:  and i am curious as to what :*: is
23:12:00 <copumpkin> it depends who defines it :P
23:12:06 <copumpkin> @typo 1 :*: 1
23:12:07 <lambdabot> forall t t1. (Num t, Num t1) => t :*: t1
23:12:17 <copumpkin> :k 1 :*: 1
23:12:18 <lambdabot> *
23:12:19 <tomberek> yeah, i found :**: in category-extras
23:12:43 <tomberek> in the composition
23:12:43 <copumpkin> :t Unit :*: Unit
23:12:44 <lambdabot> Unit :*: Unit
23:13:56 <tomberek> copumpkin: anyway.. i guess i'm looking for something like: fullCompose :: Functor h => (f :.: g) (h a) --> (f :.: g :.: h) a
23:14:11 <tomberek> where type :.: = CompF
23:20:18 <djahandarie> Hayoo has 500 errors, again.
23:26:14 <tensorpudding> ohnoes :(
23:26:17 <tensorpudding> it just came back
23:26:20 <tensorpudding> and it's gone again
23:27:29 <tensorpudding> hayoo, hpaste and code.haskell are all really unreliable
23:31:33 <djahandarie> Yeah, haskell.org was down itself a few days back as well
23:33:01 <tomberek> can i set up a recursive call that is stopped by a constraint?
23:35:54 <tensorpudding> what do you mean?
23:40:06 <tomberek> i want to call a function on the result of itself,,
23:40:18 <tensorpudding> so you want to iterate
23:40:35 <tomberek> but stop it depending on a constraint... i'm trying typeclases now .. i think so
23:40:37 <tensorpudding> rather, you want something like iterate
23:40:40 <tensorpudding> @src iterate
23:40:40 <lambdabot> iterate f x =  x : iterate f (f x)
23:41:06 <tensorpudding> well, maybe not with lists
23:41:10 <tomberek> um... yes.. ish
23:42:39 <tensorpudding> you could use something like (head . dropWhile isNotOkay . iterate function)
23:42:55 <tomberek> isNotOkay???
23:43:02 <tensorpudding> isNotOkay is the constraint
23:43:17 <copumpkin> :t until
23:43:18 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
23:43:19 <tensorpudding> when it becomes False, you stop dropping the results
23:43:34 <tensorpudding> oh hey, there is something like this already
23:43:35 <tomberek> um.. can that be something like Functor f... that's the type of constraint i mean
23:43:43 <tensorpudding> @src until
23:43:43 <lambdabot> until p f x | p x       = x
23:43:43 <lambdabot>             | otherwise = until p f (f x)
23:43:48 <copumpkin> you want this on the type level?
23:43:59 <tomberek> yes
23:44:25 <copumpkin> not easily at all
23:44:57 <copumpkin> you should figure out what you're doing in agda first and then figure out how to port it to haskell :P
23:45:02 <tomberek> this shows what i want, except i have overlapping instances http://pastebin.com/qW9pCRLz
23:45:17 <tomberek> copumpkin.. hm.. i DO have agda on this machine
23:45:19 <copumpkin> lol
23:45:32 <copumpkin> you actually named it beethoven :)
23:45:37 <tomberek> sure
23:45:52 <tomberek> but you see what i'm doing.. keep composing "hehe" until you hit a bifunctor
23:50:28 <Olathe> I'm using putStrLn, but it's only showing output after the whole line is generated instead of lazily (each line shows a list, each item of which takes a while to compute). Is there a way to switch it to display as it's computed ?
23:51:59 <tensorpudding> @hoogle putStrLn
23:51:59 <lambdabot> Prelude putStrLn :: String -> IO ()
23:51:59 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
23:51:59 <lambdabot> System.IO putStrLn :: String -> IO ()
23:52:18 <tensorpudding> hmm, is there a putStrLn for lazy bytestrings?
23:52:23 <tomberek> copumpkin, ideas.. or just go agda?
23:52:47 <copumpkin> tomberek: too much work to do in haskell :P I'd try to figure it out in a less constrained system first
23:53:28 <tomberek> hm.. gotta go learn Agda,, any good tutorial to start with for a Haskeller?
23:54:15 <copumpkin> http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
23:54:16 <copumpkin> #agda
23:55:24 <tomberek> copumpkin:  k, working on it.. so what's the plug for agda?  I mean, if it's so great why use Haskell? and vice versa?
23:55:29 <tomberek> pros/cons
23:55:59 <copumpkin> just much more flexible type system
23:56:05 <copumpkin> and also has a pretty neat parser
23:57:16 <copumpkin> tomberek: but no typeclasses ;)
23:58:00 <tomberek> do you see what i'm trying to do with Beethoven?  perhaps is there some sort of way to tell the compiler to pick one over the other if there is an overlap?
23:58:22 <bastl> @kind []
23:58:23 <lambdabot> * -> *
23:58:59 <tomberek> i tried OverlappingInstance, but it still gives me error, only this time it says overlap OK
23:59:55 <bastl> @pl f x = 3 * x
23:59:55 <lambdabot> f = (3 *)
