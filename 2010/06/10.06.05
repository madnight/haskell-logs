00:00:05 <bill``> yeah, i mean in haskell. sorry. hopefully real world haskell covers them
00:00:08 <Nereid> :>
00:00:31 <tomberek_> bill`` it will
00:00:41 <Nereid> (law-abiding) functors really are functors in haskell though
00:00:45 <bill``> this is day #1 of my haskell journey
00:00:48 <Nereid> heh
00:00:49 <tomberek_> ski, Nereid: http://pastebin.com/QcdCjWas  this gives an idea
00:01:26 <Nereid> wall of code...sleepy...
00:01:27 <Nereid> :(
00:01:41 <tomberek_> if you look at the examples at the bottom, it will be clearer
00:02:00 <Nereid> nope :-)
00:02:38 <Nereid> yeah I think I'll go to bed
00:02:41 <tomberek_> erg
00:03:23 <ski> bill`` : <http://catonmat.net/blog/on-functors> might possible be of interest
00:04:32 <ski> (that contains a short explanation of what "functor" means in C++,ML,Haskell,Prolog (different things in all cases))
00:05:10 <ski> bill`` : have you met the `map' function, yet ?
00:05:46 <Nereid> :t map
00:05:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:05:48 <Nereid> :t fmap
00:05:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:11 <Nereid> :t (.)
00:06:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:16 <Nereid> oh gee, thanks :(
00:06:57 <tomberek_> Nereid: can't help just a bit?
00:07:04 <Nereid> tomberek_: my brain isn't working
00:07:10 <tomberek_> arg
00:07:20 <Nereid> + I'm far from an expert
00:07:31 <tomberek_> me too
00:08:39 <Nereid> but [] and ((->) a) are standard examples of functors
00:08:47 <Nereid> (where fmap becomes map and (.), respectively)
00:09:02 <tensorpudding> Huh, what functor means in Prolog is weird.
00:09:08 <tomberek_> Nereid, yes, i'm trying to stop a recursion down functors at a (,) or ((,)a)
00:09:45 <Nereid> tomberek_: I don't think there's much you can do other than write your own typeclass. and then there's still nothing preventing someone else from making ((,) a) an instance of that
00:09:52 <FunctorSalad_> JN: <$> "fmap" <*> "apply" >>= "bind"
00:09:57 <Nereid> there's probably a different solution
00:10:00 <FunctorSalad_> (re pronounciation :))
00:10:04 <tomberek_> Nereid: that's what i'm trying, but i'm running into problems
00:10:14 <FunctorSalad_> or "ap", not "apply"
00:10:14 <Nereid> no surprise
00:10:25 <tomberek_> I want to compose Functors until it hits a (,)
00:10:33 <FunctorSalad_> ("ap" is actually with a different context, but fair enough for pronounciation ;))
00:10:53 <Nereid> every Monad should be an Applicative anyway
00:10:55 <JN> how do you pronounce >>
00:11:01 <FunctorSalad_> hmm
00:11:09 <dv-> then?
00:11:09 <tensorpudding> four different meanings of functor, the only one that makes sense to me is Haskell's, since it mirrors the CT defintion
00:11:13 <FunctorSalad_> "ind"? made up on the spot
00:11:18 <Nereid> lo
00:11:19 <Nereid> l
00:11:24 <FunctorSalad_> (like "bind", but without the b)
00:11:31 <Nereid> but it's the right end that's missing
00:11:32 <Nereid> bin?
00:11:33 <FunctorSalad_> taking better suggestions
00:11:51 <JN> bindnull
00:12:03 <FunctorSalad_> "rabbit"
00:12:04 <Nereid> or "then"? because that's what it means for certain monads.
00:12:16 <Nereid> but that conflicts with if/then/else
00:12:17 <FunctorSalad_> yeah "then" makes sense if it's not confusable with if-then
00:12:23 <tomberek_> "also"
00:12:27 <tomberek_> "andThen"
00:12:32 <Nereid> (*>)
00:12:50 <FunctorSalad_> I've seen "andThen" proposed for logical and when it's abused for shortcircuit
00:13:02 <tomberek_> after/before
00:14:54 <ski> `(>>)' has been called "then" in code before the `Monad' type-class
00:15:13 <ski> (like `fooThen' and `fooBind' seen in some papers, iirc)
00:15:57 <ski> FunctorSalad_ : btw, in SML, `&&' is called `andalso'
00:16:08 <FunctorSalad_> oh
00:16:24 <ski> (and is a special syntax construction, since it is potentially lazy in the second argument)
00:16:32 <ski> (and `||' is called `orelse')
00:16:33 <FunctorSalad_> neither really makes the shortcircuit semantics clear though, IMHO
00:16:39 <FunctorSalad_> whereas orElse is good
00:16:58 <FunctorSalad_> "andThen" or "andAlso" could be interpreted as "do the second arg anyway"
00:17:31 <ski> well, not necessarily, i think .. i.e. if the first one fails (akin to throwing an exception)
00:18:28 <ski> "first establish a database connection and then send a query", could entail that if the first fails, then second isn't tried
00:18:35 <FunctorSalad_> I mean && is "do the first, and if it succeeds, do the second", which isn't really captured by "andthen"
00:18:57 <ski> but i agree it's not as clear-cut as with `orElse'
00:19:20 <FunctorSalad_> "buy vegetables and then buy chicken" would probably mean you should buy chickens even if vegetables are out
00:19:28 <ski> *nod*
00:19:38 <Nereid> natural language semantics, fun fun
00:20:33 <FunctorSalad_> :)
00:20:47 <ski> btw, one could have a `/\' connective such that `A /\ B' is well-formed iff `A' is well-formed, and also : assuming that `A' is true, then `B' is definitely well-formed
00:22:05 <ski> if one would try to determine the truth of `A /\ B' one would (generally) be forced to establish the truth of `A' before being able to consider `B' (otherwise we don't know that `B' is well-formed)
00:22:48 <FunctorSalad_> "well-formed"? like in an undefined-expression-tolerant logic? I've pondered that once
00:23:25 <FunctorSalad_> (even the partiality of division is usually glossed over...)
00:23:26 <ski> `A' being well-formed meaning more or less that we can derive `A : *'
00:24:07 <FunctorSalad_> ((/) isn't really a function symbol in a logic where everything's supposed to be total... unless you add 'bottom' as an individual, of course... but one might want special hardware support in the logic?)
00:24:11 <FunctorSalad_> ;)
00:24:27 <ski> so, we have a formation rule that says : assuming `Gamma |- A : *' and `Gamma , A |- B : *' we may derive `Gamma |- A /\ B : *'
00:26:04 <ski> FunctorSalad_ : there's variants of predicate logics with partially defined terms, e.g. Troelstra talks about `ICQE' and `ICQE+' in "Constructivism in Mathematics", to be able to handle reciprocal and division of real numbers
00:26:23 <ski> (but i don't really like those logics much)
00:26:45 <FunctorSalad_> ski: I've read a little bit into it too at that time, there seem to be many choices to be made...
00:27:07 <FunctorSalad_> it may not be nice, but how should we handle partiality?
00:27:53 * ski has pondered having a rule like : assuming `Gamma |- m : |N' and `Gamma |- n : |N', we may derive `Gamma |- m - n : |N  |  m < n'
00:28:22 <ski> here the `|  m < n' is sortof like an `Either (m < n)' monad
00:28:48 <ski> so `m - n' would be a side-effectful expression .. but if are in a branch where we have refuted `m < n', it is pure
00:28:54 <FunctorSalad_> every term carries around its preconditions?
00:29:00 <FunctorSalad_> seems reasonable
00:29:22 <FunctorSalad_> (better than doing the same "manually" in propositions...)
00:29:50 <ski> (though, it might be nicer to have `m =< n' there .. and have the "disjunction" be a pushout, in CT speak)
00:30:00 <FunctorSalad_> hmm why side-effects?
00:30:15 <tomberek_> is there some sort of hasType or isType?
00:30:35 <ski> because we want to use `m - n' directly in expressions, instead of having to type `m - n >>= \d -> ..d..'
00:30:50 <ski> we don't have to allow global side-effects for this .. only local ones
00:31:08 <ski> > typeOf "a string"
00:31:09 <lambdabot>   [Char]
00:31:22 <ski> > typeOf "a string" == typeOf (undefined :: String)
00:31:23 <lambdabot>   True
00:31:26 <tomberek_> ski, hm,, thanks
00:31:40 <FunctorSalad_> couldn't f( (x | p) , (y | q) ) be <whatever> | p /\ q ?
00:31:41 <ski> @type id `asTypeOf` not
00:31:41 <lambdabot> Bool -> Bool
00:31:46 <ski> > (id `asTypeOf` not) False
00:31:46 <lambdabot>   False
00:31:53 <FunctorSalad_> (in addition to any conditions f might add)
00:32:09 <tomberek_> ski, is that Prelude?
00:32:15 <ski> which ?
00:32:19 <ski> @index asTypeOf
00:32:19 <lambdabot> Prelude
00:32:29 <tomberek_> nice, thanks!
00:32:34 <ski> @index typeOf
00:32:34 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
00:32:44 <FunctorSalad_> (and isn't this more like a Writer monad?)
00:32:50 <FunctorSalad_> maybe seen from a different angle
00:33:17 <tomberek_> @index typeOf
00:33:17 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
00:33:19 <ski> FunctorSalad_ : i'm not sure i understand what you mean by `f( (x | p) , (y | q) )' and `<whatever> | p /\ q'
00:33:27 <tomberek_> @src asTypeOf
00:33:28 <lambdabot> asTypeOf = const
00:33:31 <FunctorSalad_> ski: the | as in your notation
00:33:39 <FunctorSalad_> 'f' some random binary function...
00:33:39 <tomberek_> :t asTypeOf
00:33:40 <lambdabot> forall a. a -> a -> a
00:34:03 <ski> FunctorSalad_ : the `|' would be a part of the notation for (typing) judgements, not a part of the expression syntax
00:34:25 <FunctorSalad_> the result of applying a (total, strict) binary function to two args should have the "and" of the preconditions of the args
00:34:28 <FunctorSalad_> ah
00:34:50 <FunctorSalad_> (which is nice because it's a commutative monad)
00:34:58 <tomberek_> ski: yeah, i need to do a typing judgement,, is this a guard situation?
00:35:00 <FunctorSalad_> since `and' is commutative...
00:35:44 <ski> yes, we should have more or less `Gamma |- e0 : t0  |  c0' and `Gamma |- e1 : t1  |  c1' implies `Gamma |- (e0,e1) : t0 * t1  |  c0 /\ c1'
00:35:46 <FunctorSalad_> (I mean "preconditions" for being defined)
00:36:23 <FunctorSalad_> any reason for not attaching the | to arbitrary subexpressions?
00:36:32 <ski> tomberek_ : are you talking about type system inference rules ?
00:36:54 <tomberek_> um..... don't know enough to answer that question
00:37:03 <ski> `e0 : t0  |  c0' is parsed as `(e0 : t0)  |  c0'
00:37:53 <ski> i'm not sure what the semantics of your `e | c' expression would be
00:38:09 <tomberek_> ski, is it possible to do something like typeOf f == typeOf (undefined,undefined) ?
00:38:26 * ski was mostly thinking of `(e0 : t0)  |  c0' as expressing static properties ("exceptional situations") in the type system
00:38:45 <FunctorSalad_> ski: "if c is true, this denotes an element of whatever type e would usually have. otherwise, it denotes nothing"
00:39:04 <ski> tomberek_ : sure, if `f :: a' for some `a' for which you know (e.g. have assumed) `Typeable a'
00:39:08 <FunctorSalad_> haven't thought about whether this is composable enough :)
00:39:23 <tomberek_> hm... ok
00:40:04 <ski> FunctorSalad_ : hm, so you basically want that `Gamma |- e : t' and `Gamma |- c : Bool' implies `Gamma |- (e | c) : t  |  c' ?
00:40:49 <ski> FunctorSalad_ : hm, if i'm to follow what you said exactly, one'd need to negate one of the `c's actually
00:41:16 <FunctorSalad_> hmm. Haven't thought about the type of it :) But it'd be "if c then t else ()" I'd say
00:41:39 <FunctorSalad_> () being the dummy for "no information"
00:41:43 <ski> (since i was interpreting `(e : t) | c' as that if `c' can be refuted, then `e' is a valid expression of type `t')
00:41:43 <tomberek_> ski, hm, telling me i have ambiguous variables
00:42:04 <ski> `()' really being `_|_' ?
00:42:08 <tomberek_> foo f | typeOf f == typeOf (undefined,undefined) = f
00:42:11 <FunctorSalad_> ski: ah. Then we had opposite signs, yes
00:42:21 <ski> or maybe more like `error ?' or `Nothing' ?
00:42:40 <tomberek_> so if f is a tuple, return id
00:42:42 <FunctorSalad_> ski: hmm if it was _|_ then the type would assert that c is true, since there can be no member of _|_
00:42:54 <FunctorSalad_> so if we want to say nothing about whether c is true, doesn't it have to be Unit?
00:43:18 <ski> (i was interpreting `foo | bar' (on the type level) as to be eliminated with "disjunctive syllogism" .. if one of the disjuncts can be refuted, then the other case holds)
00:43:28 <FunctorSalad_> I mean, if we have an element of "if c then t else _|_", we are asserting that c is true
00:43:52 <FunctorSalad_> ok, I was interpreting the thing to the right of "|" as the precondition for being defined :)
00:43:54 <ski> FunctorSalad_ : "since there can be no member of _|_" .. are you talking about a *type* `_|_' here ? (`Void' ?)
00:44:23 <FunctorSalad_> ski: I understood you as calling Void _|_ so I didn't change the notation :)
00:44:32 <FunctorSalad_> but yeah, I mean the empty type
00:44:36 * ski didn't call `Void' `_|_'
00:44:48 <FunctorSalad_> well, I meant the unit type by '()', not its element :)
00:44:48 * ski called the bottom element in every (lifted) type `_|_'
00:45:10 <FunctorSalad_> so I deduced that _|_ is supposed to be a type from "<ski> `()' really being `_|_' ?" :)
00:45:28 <FunctorSalad_> but ok, lets call the type Void
00:45:39 <ski> .. oh, your `if c then t else ()' was a type-level conditional !?
00:45:44 <FunctorSalad_> yes
00:46:18 <FunctorSalad_> it was supposed to be a logic for math, not anything decidable for a compiler :)
00:46:22 <ski> hm .. possibly that could work (using that conditional as the type)
00:46:57 <FunctorSalad_> were you talking about an extension to haskell's type system?
00:47:04 <tomberek_> foo f | typeOf f == typeOf (undefined,undefined) = f
00:47:08 <FunctorSalad_> (then we were indeed on a different page)
00:47:16 <ski> (just to be clear, i used `|' as an alternative notation for an "or", of sorts)
00:47:42 <ski> tomberek_ : i believe you have to say what type you want the two `undefined's to have
00:48:18 <tomberek_> ski, i can't do something isomorphic to    foo f | isTuple f = blah?
00:48:27 <ski> tomberek_ : if you only want to check whether the type of `f' is a pair type, i think there's some other operations in `Data.Typable' that lets you pull apart an application of a type constructor into the constructor and the arguments
00:48:40 <FunctorSalad_> yes, I think I kinda see what you did now :)
00:48:45 <tomberek_> hm... i'll look
00:48:57 <FunctorSalad_> declaring possible exceptions
00:49:24 <FunctorSalad_> (which may be useful to have as part of the type system instead of typeclass abuse ;))
00:49:25 <ski> FunctorSalad_ : i was talking about something that possibly might be implementable, at least in a dependently typed language like Agda2 or Epigram
00:49:50 <tomberek_> ski: what package is Data.Typeable in?
00:49:55 <FunctorSalad_> (there already is a package which does make types keep track of possible exceptions)
00:49:58 * ski isn't sure
00:50:29 <FunctorSalad_> Data.Typeable
00:50:37 <tomberek_> ah,, it's just in bas
00:50:39 <FunctorSalad_> the type is Data.Typeable.Typeable
00:50:40 <tomberek_> base
00:50:46 <FunctorSalad_> oh sorry, "package"
00:50:51 <ski> maybe lambdabot should have a command for asking what package(s) on hackage(?) provide a particular module ?
00:51:03 <tomberek_> yeah, hoogle and hayoo are down, my main "where is this function" tool
00:51:08 * ski doesn't know whether that would be hard to implement
00:51:17 <FunctorSalad_> ghc-pkg dump | grep -E 'name|Data.Typeable'
00:51:19 <FunctorSalad_> :)
00:52:52 <ski> FunctorSalad_ : .. at the least, i would like a logic along these lines which you could use to reason formally or semi-formally (instead of using atrocities like `ICQE' and `ICQE+')
00:53:07 <FunctorSalad_> nevermind, there is a specific command... ghc-pkg find-module Data.Typeable
00:53:09 <tomberek_> ski: so i guess i just cast it and see if i get Nothing
00:53:15 <ski> .. about terms that might not be well-defined in all circumstances, i mean
00:53:45 <ski> tomberek_ : you can't cast to a type `(a,b)' if you don't already know which `a' and `b' you want to try to cast into
00:53:53 <tomberek_> arg!
00:54:18 <zachk-wut> you prolly dont want to cast and use dynamic typing anyways 
00:54:53 <FunctorSalad_> you can cast to (Dynamic,Dynamic) ;)
00:55:35 <ski> > (typeRepTyCon &&& typeRepArgs) (typeOf (undefined :: (Int,Bool)))  -- tomberek_, use these operations
00:55:35 <lambdabot>   ((,),[Int,Bool])
00:55:58 <tomberek_> ok... parsing
00:56:04 <ski> (.. if indeed you want to do this sort of thing, as zachk-wut noted)
00:56:11 <ski> @type typeRepTyCon
00:56:12 <lambdabot> TypeRep -> TyCon
00:56:18 <ski> @type typeRepArgs
00:56:19 <lambdabot> TypeRep -> [TypeRep]
00:57:01 <ski> > (typeRepTyCon . typeOf) (undefined :: (Int,Bool)) == (typeRepTyCon . typeOf) (undefined :: ((),()))
00:57:02 <lambdabot>   True
00:57:02 <tomberek_> ski, damn,,, but it can't be for arbitrary (a,b)
00:57:07 <ski> > (typeRepTyCon . typeOf) (undefined :: (Int,Bool,Char)) == (typeRepTyCon . typeOf) (undefined :: ((),()))
00:57:08 <lambdabot>   False
00:57:10 <tomberek_> ooh
00:57:25 <ski> that is how you can check (using `Typable') that a type is a pair type
00:57:35 <tomberek_> nice!
00:58:01 <ski> you still need `Typable a' for the `a' such that `f :: a', yes
00:58:37 <tomberek_> um... is there a 'preferred' way though?
01:01:07 <zachk-wut> tomberek_, you might want data MyType = MyInteger Integer | MyString String | MyFloat Double 
01:01:25 * zachk-wut but has never gotten into writing a parser, but has tried 
01:01:32 <tomberek_> @src CompF
01:01:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:01:51 <tomberek_> newtype CompF f g a = CompF ( f ( g a) )
01:02:11 <ski> tomberek_ : i'm not sure
01:02:14 <tomberek_> I want to run CompF until (g a) is not a tuple
01:02:24 <tomberek_> i mean: is a tuple
01:03:01 <ski> it might be nice to define an `unTyConApp :: TyCon -> TypeRep -> Maybe [TypeRep]' operation
01:03:05 <ski> @type mkTyConApp
01:03:06 <lambdabot> TyCon -> [TypeRep] -> TypeRep
01:03:21 <ski> @type funResultTy  -- is a special case of this
01:03:22 <lambdabot> TypeRep -> TypeRep -> Maybe TypeRep
01:03:25 <RyanT5000> tomberek_: i know very little about what you're doing, but it seems like you're trying to do a lot of type-based metaprogramming; have you considered TH instead? sometimes it's nice to be able to write normal code for metaprogramming tasks
01:03:50 <zachk-wut> what are your tuplles of? parsed data and its type? 
01:04:02 <ski> > funResultTy (typeOf (undefined :: Bool -> Int)) (typeOf (undefined :: Bool))
01:04:02 <lambdabot>   Just Int
01:04:06 <ski> > funResultTy (typeOf (undefined :: Bool -> Int)) (typeOf (undefined :: Char))
01:04:07 <lambdabot>   Nothing
01:04:25 <zachk-wut> is haskell.org still down for you guys? 
01:05:02 <tomberek_> RyanT5000 : i'm not sure if TH is what i need, honestly, it seems that this should be simple, but i just can't figure it out, I thought some sort of Mu trick or something with typeclasses could do it
01:05:09 <FunctorSalad_> http://downforeveryoneorjustme.com/haskell.org
01:05:58 <zachk-wut> FunctorSalad_, ty i wonder if i can remember the url :-/ 
01:06:04 <RyanT5000> tomberek_: it does seem interesting :)
01:06:19 <FunctorSalad_> ... typeclasses. Now they have two problems. (Can't remember what the original was)
01:06:28 <ski> @let unTyConApp :: TyCon -> TypeRep -> Maybe [TypeRep]; unTyConApp con ty = do guard (con == typeRepTyCon ty); return (typeRepArgs ty)
01:06:29 <lambdabot>  Defined.
01:06:51 <tomberek_> RyanT5000 : CompF is basically a composition of two Functors
01:07:04 <RyanT5000> right
01:07:07 <ski> > unTyConApp ((typeRepTyCon . typeOf) (undefined :: ((),()))) (typeOf (undefined :: (Bool,Char)))
01:07:08 <lambdabot>   Just [Bool,Char]
01:07:30 <tomberek_> RyanT5000: i want to keep running CompF as long as there are functors to go  (but stop at a tuple, ie: don't compose the ((,)a) functor)
01:08:05 <tomberek_> RyanT5000 : other stop case: no more functors
01:08:14 <RyanT5000> right
01:08:19 <FunctorSalad_> ah, found it. "Some people, when confronted with a problem, think “I know,
01:08:19 <FunctorSalad_> I'll use regular expressions.”  Now they have two problems.
01:08:19 <FunctorSalad_> " Jamie Zawinski
01:08:31 <ski> > mkAppTy (typeOf1 Nothing) (typeOf False)
01:08:32 <lambdabot>   Maybe Bool
01:08:40 <zachk-wut> haha i remember reading that quote awhile ago FunctorSalad_ 
01:08:44 <Makoryu> @hoogle Either a -> IO a
01:08:44 <lambdabot> Did you mean: Either a a -> IO a /count=20
01:08:44 <lambdabot> Control.Exception evaluate :: a -> IO a
01:08:44 <lambdabot> Control.OldException evaluate :: a -> IO a
01:09:04 <zachk-wut> @hoogle mapPar 
01:09:05 <lambdabot> No results found
01:09:12 <zachk-wut> @hoogle parMap 
01:09:13 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:09:28 <ski> Makoryu : .. what are you looking for ?
01:09:54 <Makoryu> ski: Not sure
01:10:08 * ski is not sure he can help, then ..
01:11:19 <ski> @type Control.Exception.throwIO `either` return  -- Makoryu, this ?
01:11:20 <lambdabot> forall a a1. (GHC.Exception.Exception a) => Either a a1 -> IO a1
01:11:38 <Makoryu> ski: I'm just screwing around :p Don't worry about it.
01:11:42 <Makoryu> But thanks.
01:12:04 <ski> @type Control.Exception.try  -- hmm ..
01:12:05 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
01:12:48 <ski> .. do these, sortof, form a retract situation ?
01:13:57 <FunctorSalad_> first the first, then the second, does look much like id
01:14:17 <FunctorSalad_> could even be INVERSES :o
01:16:17 <FunctorSalad_> for second, then first... if it throws no error, #2 = Right and #1 = return . fromRight... if it does throw, #2 = Left and  #1 = throwIO . fromLeft
01:16:59 <FunctorSalad_> inverses modulo weird corner cases, I'd say ;) (and if you ignore the missing IO in Either a a1)
01:19:52 <ski> (yes, in one direction we'd be aiming for `return' and in the other for `id')
01:20:18 * ski just checked that throwing a specific exception can be caught as `SomeException'
01:22:58 <ski> @type fix Control.Exception.SomeException
01:22:59 <lambdabot> GHC.Exception.SomeException
01:23:05 <ski> > fix Control.Exception.SomeException  -- hmm ?
01:23:05 <lambdabot>   Not in scope: data constructor `Control.Exception.SomeException'
01:25:12 <zachk-wut> is there an easy (idiomatic) way to memoize map f [1..] ? 
01:25:50 <ski> hm, memoize in what sense ?
01:26:01 <FunctorSalad_> it's a value, it is memoized already
01:26:11 <zachk-wut> really? 
01:26:20 <FunctorSalad_> if it's monomorphic
01:26:24 <zachk-wut> uhhhh
01:26:53 <ski> @type let f = (+) in map f [1..]
01:26:54 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
01:28:46 <Makoryu> zachk-wut: A monomorphic type doesn't have any type variables
01:28:56 <FunctorSalad_> zachk-wut: function values aren't automemoized, but a constant value will have a single "global" state of how executed it is
01:29:41 <zachk-wut> so if have to do list = map f [1..10] then list!!n to have it memoized? 
01:29:44 <FunctorSalad_> so if you do "x = map f [1..]" for some f... x !! 10 will return the 10th elements, and all the evaluation done on the way is remembered
01:30:05 <FunctorSalad_> that's more or less how 'call by need' is different from call by name (*ducks*)
01:30:56 <Nereid> but not map f [1..] !! 10
01:31:04 <Nereid> ?
01:31:53 <FunctorSalad_> you'd have no way to refer to the "map f [1..]" thunk from elsewhere if you do it like that
01:31:59 <Nereid> right.
01:32:31 <Nereid> bye
01:32:47 <zachk-wut> bye nereid 
01:32:53 <tomberek_> bye
01:33:11 <Nereid> (I have this problem where I say bye intending to go to bed but I never actually do)
01:33:17 <Nereid> (but I think I'll really go this time.)
01:33:20 <soupdragon> I should go too
01:33:27 <soupdragon> :/
01:33:33 * zachk-wut got woken up by his dog 
01:34:23 <scree> he was trying to tell you about the children trapped down the mineshaft, but you wouldn't listen
01:35:17 <FunctorSalad_> they can wait until noon
01:35:20 <jystic> those damn kids will never learn
01:38:38 <tomberek_> g'damn!
01:40:18 <ivanm> hey tomberek_ 
01:40:26 <tomberek_> hey ivanm
01:40:45 <tomberek_> if you have a minute, can i get some help
01:41:04 <ivanm> sure
01:41:55 <tomberek_> i'm working with category-extras, but for this, all i'm using is   newtype CompF f g a = CompF {runCompF :: f (g a)}
01:42:12 <tomberek_> this is meant to compose Functors
01:42:20 <ivanm> OK...
01:42:26 <ivanm> I've never used cateogry-extras
01:42:27 <ski> (FunctorSalad_ : function *values* are memoized .. but applications of them aren't)
01:42:39 <tomberek_> listTuple = Of $ [(1,"hi"),(3,"there"),(4,"you")]  :: Of [] (,) Int String
01:42:48 <tomberek_> er.. sorry
01:42:56 <tomberek_> wrong example
01:43:11 <ivanm> heh, about to say...
01:43:37 <tomberek_> CompF [(1,"hi"),(3,"there"),(4,"you")] :: CompF [] (Int,String)
01:44:34 <tomberek_> or rather the ((,) Int) String
01:45:15 <ivanm> OK...
01:45:32 <tomberek_> now,,,  CompF [[(1,"hi")]] :: CompF [] [] (Int,String)
01:46:04 <ivanm> OK...
01:46:35 <tomberek_> and ... CompF $ CompF $ [[[(1,"hi")]]] :: CompF (CompF [] [] ) [] (Int,String)    or ([] :.: [] :.: []) (Int,String)  using infix types
01:47:04 <ivanm> never heard of infix type sigs like that before....
01:47:27 <ivanm> anyway, what's your query?
01:47:28 <tomberek_> well, it just looks better, but same meaning
01:47:30 <tomberek_> ok.. now, i want a function that does the correct number of CompF
01:48:06 <tomberek_> I want to call CompF until either I no longer have a Functor, or reach ((,)a)
01:48:09 <ivanm> as in counts how many times you used CompF?
01:48:12 <ivanm> not sure if that's possible
01:48:19 <ivanm> since it's type would be weird
01:48:56 <ivanm> the only way I can think of off the top of my head is to use a type class and use overlapping hackery to do something different on the CompF (CompF...) cases as opposed to CompF (something-that-isn't-CompF)
01:48:59 <tomberek_> no, as in it calls CompF repeatedly, until i have something like :: CompF (blah...blah)   (Int,String)
01:49:13 <ivanm> tomberek_: so you want join for CompF?
01:49:22 <tomberek_> ivanm: yeah, i tried to make a Beethoven class   (all that composing)
01:49:24 <ivanm> that still won't do it all for you
01:49:33 <ivanm> you would need some overlapping instance or something
01:49:49 <ivanm> tomberek_: it's exactly like how many monads do you have in something like m (m (m (...)))
01:50:01 <ivanm> or how many nested lists you have
01:50:12 <tomberek_> yes
01:50:19 <tomberek_> count the nested functors
01:50:27 <tomberek_> except ((,)a)
01:51:42 <ivanm> as I said, the only way I can think of is to write a type class with an overlapping instance
01:51:45 <ivanm> and then have it recurse
01:51:49 <ivanm> which is a really hacky thing to do
01:51:57 <ivanm> tomberek_: any particular reason you need such functionality?
01:51:59 <tomberek_> honestly, at this point i'd be happy with just lists too... I've tried MPTC with ATs,, couldn't get it to work
01:52:35 <Jafet> @faq can haskell have a reliable web site?
01:52:35 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:42 <ivanm> tomberek_: what for?
01:52:44 <tomberek_> ivanm: well, this is just a learning project, but i'm close to a cool result, but this would make it usable
01:52:58 <ivanm> Jafet: in case you haven't seen it: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
01:53:19 <tomberek_> if i can 'auto-newtype' someone else's structure
01:53:28 <Jafet> ivanm, cool
01:53:47 <ivanm> tomberek_: ummm, why would you want to do that?
01:54:59 <tomberek_> so if someone has a data structure in the form of Functors of Functors, it can be composed for them
01:55:47 <tomberek_> so Functor (F) of F of F of F a   -----> BigFunctor a
01:56:26 <zachk-wut> is that all the same functor? 
01:56:38 <tomberek_> at least in newtypes.. then i can manipulate BigFunctor  -- which is itself a Functor
01:57:00 <tomberek_> zachk-wut: no , but if you have an idea assuming they were the same, i'm all ears
01:57:51 <zachk-wut> i was thinking of monads and how join can collapse them down to one layer 
01:58:34 * zachk-wut still isnt sure wtf a functor or a monad is but it no longer seems to bother him :-D 
01:58:50 <Jafet> @quote monads.are
01:58:50 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
01:58:59 <tomberek_> hm,, that creates a new monad.  I'm just newtype'ing them into one
02:00:08 <tomberek_> http://pastebin.com/jp7nprCZ  i have examples near the bottom
02:03:27 <FunctorSalad_> ski: ah yes, I meant "function values" in the sense of "points in the graph" ;)
02:03:37 <FunctorSalad_> not "first-class functions"
02:03:52 <FunctorSalad_> maybe a germanism
02:11:09 <tomberek_> ivanm: i have a function (Typeable a) => a -> Bool   that returns true if given a tuple type
02:11:19 <tomberek_> does that help?
02:11:35 <ivanm> oh, using typeable... that might work
02:11:35 <ivanm> but isn't that kinda dynamic typing?
02:12:51 <tomberek_> i don't know,, ski volunteered it... if it is dynamic typing, is that bad?
02:13:28 <ivanm> nah, not really
02:13:33 <Jafet> No, that's not dynamic typing
02:13:34 <soupdragon> return true depending on the type is dynamic typing
02:13:46 <tomberek_> isTuple f = (typeRepTyCon . typeOf) f == (typeRepTyCon . typeOf) (undefined :: ((),()))
02:14:17 <tomberek_> so how do i use this to do what i want?
02:14:37 <soupdragon> why don't you do this
02:14:43 <soupdragon> isTuple :: (a,b) -> Bool
02:14:46 <soupdragon> isTuple _ = True
02:14:52 <soupdragon> that's NOT dynamic typing
02:15:08 <soupdragon> prety much anything else /is/
02:15:50 <tomberek_> soupdragon... because I don't know that the type is (a,b)
02:16:29 <Jafet> Unless "dynamic typing" has acquired a strange different meaning in haskelland
02:16:33 <tomberek_> soupdragon,, how about I explain the actual problem   (not what i think the subproblem is)
02:16:37 <FunctorSalad_> you might be able to avoid getting into that situation in the first place ;) unless it is something intrinsically dynamic like loading plugins at runtime
02:16:44 <ivanm> unless you use hack up a type class and use overlapping instances there's no real other way to do it
02:16:51 <ivanm> FunctorSalad_: agreed
02:16:54 <Jafet> I would go with type classing
02:17:14 <soupdragon> tomberek_: the fact that you don't know what type something is means you are using dynamic typing
02:17:18 <Jafet> Since this looks like type programming
02:17:23 <tomberek_> ivanm: ok, i tried the type class solution, and i failed due to lack of experience
02:17:28 <ivanm> OK, according to the docs Data.Typeable isn't dynamic
02:17:29 <soupdragon> tomberek_: yeah explain the real problem if you want to
02:17:42 <ivanm> soupdragon: he's experimenting IIUC
02:18:04 <tomberek_> soupdragon: take a look at http://pastebin.com/jp7nprCZ  to avoid me pasting everything all over the place
02:18:13 <c_wraith> Data.Typeable is a standard typeclass.  It has to be resolved at compile time.
02:18:37 <tomberek_> soupdragon: examples near the bottom show what's going on
02:18:45 <copumpkin> tomberek_: knowing whether something is a tuple at runtime won't help your type-level stuff
02:18:49 <copumpkin> no dependent types :)
02:19:19 <tomberek_> copumpkin, i'm starting to think that what i want isn't possible in Haskell
02:19:27 * copumpkin points at #agda
02:19:37 <c_wraith> tomberek_, there's always unsafeCoerce!  >_>
02:19:46 <tomberek_> soupdragon: the idea is to turn a Functor of Tuples into a Tuple of Functors   and vice versa
02:19:48 <zachk-wut> tomberek use lists instead of tuple 
02:19:53 <soupdragon> tomberek_, lol why
02:20:17 <zachk-wut> oh wait let me guess you want different types, try HList or something then 
02:20:27 <soupdragon> well it looks pretty wild
02:21:03 <c_wraith> HList is terrifying, if you just start at the docs.
02:21:06 <tomberek_> soupdragon: Functor = F , Tuple = T............   so i want to be able to commute F and T... ie   F of F of T -> F of T of F -> T of F of F
02:21:31 <tomberek_> now, if i have the newtypes all set up,, i already can do most of that
02:22:09 <tomberek_> F of F of T   --->   T of F of F    is done, as is the vice versa
02:22:24 <tomberek_> but the newtypes have to be there already
02:23:19 <tomberek_> soupdragon: so i want to be able to take an arbitrary data structure, and "auto-newtype" it  (of course have some constraints)
02:26:36 <soupdragon> tomberek_, no I don\t really see it
02:27:05 <soupdragon> it's beyond my understanding
02:27:06 <copumpkin> sounds a bit like the type family "reshaping" of nested arrays that happens in DPH
02:27:18 <tomberek_>  [ (1,2) ]   ->  (  [1]  , [2]  )  is a trivial example... DPH?
02:27:48 <c_wraith> data-parallel haskell
02:27:52 <tomberek_> that only works with one level of a specific Functor, i'm trying to generalize it
02:28:03 <soupdragon> oh I see
02:28:36 <tomberek_>  [[ (1,2) ]]   ->  (  [[1]]  , [[2]]  )   is harder
02:29:02 <Jafet> For arbitrary Functors?
02:29:13 <Jafet> Erm, have fun
02:29:24 <tomberek_> Jafet, honestly, at this point.. if it was just for [] i'd be happy
02:29:42 <soupdragon> I can't even imagine programming this for  [^n (a,b) ]^n -> ([^n a ]^n,[^n b ]^n,)
02:29:47 <soupdragon> I mean that's hard enough already
02:30:03 <soupdragon> but it's possible :)
02:30:08 <tomberek_> soupdragon: hence my headaches... the thing is,, i have it working if the newtypes are there
02:30:09 <c_wraith> I feel like fermat's last theorem comes into play soon :)
02:30:12 <soupdragon> but you want to go further than that.. which is where it gets hard
02:30:38 <tomberek_> for any functor! it already works,, (well, the zipping requires Zip)
02:31:07 <tomberek_> it's just that i can't yet take an un-newtyped structure and do it
02:31:09 <Taejo> I'm writing a liveness analysis for a little compiler -- would Hoopl be worth looking at for this?
02:32:26 <ivanm> @src shows
02:32:26 <lambdabot> Source not found. My mind is going. I can feel it.
02:33:59 <ivanm> when does the precedence in showsPrec matter?
02:35:41 <tomberek_> soupdragon: and with a function isTuple (which i have working) i can get this to work, but i can't recurse it for some reason, it has to be func1 func2 func3 func4 down the line
02:41:59 <FunctorSalad_> @type dataCast1
02:42:00 <lambdabot> forall (c :: * -> *) (t :: * -> *) a. (Data a, Typeable1 t) => (forall d. (Data d) => c (t d)) -> Maybe (c a)
02:42:07 <FunctorSalad_> @type dataCast2
02:42:08 <lambdabot> forall (c :: * -> *) (t :: * -> * -> *) a. (Data a, Typeable2 t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
02:42:24 <FunctorSalad_> eh
02:42:28 <tomberek_> hm
02:43:07 <FunctorSalad_> ivanm: I recommend just copying the output of -ddump-deriving ;)
02:43:26 <FunctorSalad_> @ty showsPrec
02:43:26 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
02:43:35 <ivanm> FunctorSalad_: the reason I'm not deriving it is because it's using ATs and hence can't be derived
02:44:08 <ivanm> the reason I'm asking is that instances for Map, etc. use shows for the sub-components, whereas DrIFT seems to always use showsPrec 10
02:44:10 <FunctorSalad_> ivanm: IIRC it's the precedence of the operator to which the present value is an rag
02:44:15 <ManateeLazyCat> Hi all. :)
02:44:16 <FunctorSalad_> s/rag/arg/
02:44:26 <FunctorSalad_> hi ManateeLazyCat 
02:44:29 <ivanm> hey ManateeLazyCat 
02:44:50 <FunctorSalad_> ivanm: I mean -ddump-deriving for a regular type
02:44:58 <FunctorSalad_> and go from there
02:45:00 <ManateeLazyCat> FunctorSalad_: ivanm Hi :)
02:45:01 <ivanm> hmmm....
02:45:16 <FunctorSalad_> btw, stalonederiving will now always follow orders ;)
02:45:25 <FunctorSalad_> that is, generate the code and see if it compiles
02:45:29 <ivanm> what orders didn't it follow before?
02:45:38 <FunctorSalad_> it just gave up on non-h98
02:45:48 <FunctorSalad_> like a usual deriving clause still does
02:46:26 <ivanm> FunctorSalad_: ghc says it doesn't know -ddump-deriving
02:47:08 <FunctorSalad_> -ddump-deriv
02:47:19 <ivanm> doesn't know that either
02:47:43 <ivanm> but that looks like the right option name...
02:47:48 <FunctorSalad_> it says so in the manpage
02:47:54 <ivanm> ugh, I had an extra - in there
02:49:24 <ManateeLazyCat> ivanm: I'm afraid of open source my project, I will be exhausted in. :)
02:50:23 <ivanm> FunctorSalad_: well, -ddump-deriving seems to use different behaviour for how to do Show than elsewhere I've seen
02:50:50 <ivanm> as it seems to use >= 11 for showParen rather than >= 10 like DrIFT and what the source for Map, Set and Array use
02:51:29 <FunctorSalad_> ? it's not constant
02:51:43 <FunctorSalad_> it's the precedence of the enclosing context of that hole or somehting
02:52:09 <ivanm> my point was was that everything else seems to use 10 as the min precedence for when to enclose it in parens
02:52:16 <ivanm> but GHC's derived instances use 11
02:52:40 <FunctorSalad_> function application has 11 on the left and 10 on the right? don't remember surely
02:53:02 <ivanm> something like that
02:54:35 * ManateeLazyCat xiami.com -- My favourites music site.... 
02:54:57 <Peaker> on the left of = or what?
02:55:20 <ivanm> "Function application has precedence 10. "
02:55:36 <FunctorSalad_> but it's left-associative
02:55:48 <FunctorSalad_> you need an extra +1 or it will have parens on the left
02:56:18 * ivanm is confused
02:56:19 <FunctorSalad_> which isn't wrong, but redundant
02:56:40 <FunctorSalad_> well, if the left hole is another function application, it will do the check "showParen (prec >= 10)"
02:57:03 <FunctorSalad_> * prec <= 10
02:57:13 <FunctorSalad_> hmm wait ;)
02:57:16 <FunctorSalad_> it was >=
02:57:32 <FunctorSalad_> ok so maybe the 11 goes on the right ;)
02:57:45 <FunctorSalad_> you want the right arg to have parens if it is another function application
02:57:50 <FunctorSalad_> the left arg not
02:58:33 <tomberek_> hi ManateeLazyCat
02:58:44 <ManateeLazyCat> tomberek_: Hi
02:59:20 <robin_rytich> !topic
02:59:29 * ManateeLazyCat I just login IRC when i'm boring...... :)
03:00:21 * ManateeLazyCat Looking for inspiration ....
03:01:36 <FunctorSalad_> ivanm: whatever the exact values may be, I think that last part makes sense ;)
03:02:02 <ivanm> robin_rytich: do you mean "/topic" ?
03:02:19 <robin_rytich> yeah, typo ;-)
03:02:25 <ivanm> FunctorSalad_: ummm... kinda...
03:07:00 <ivanm> _anyway_ I was trying to see what the difference was between doing "showsPrec 0" and "showsPrec 10" and I can't find any real difference
03:07:21 <ivanm> and on a related note, I can't find where Maybe's Show instance is defined :/
03:08:43 <Heffalump> ivanm: it'll affect whether you get parens round the result, in some situations
03:09:08 <ivanm> Heffalump: right, but I'm trying to work out what those situations are
03:09:42 <ivanm> as I'm trying to work out whether I should use "showsPrec 10" for the fields of the data type like DrIFT spits out, or just shows like Map, Set, etc. use
03:11:56 <ivanm> OK, Maybe uses > 10
03:12:46 <ivanm> actually, so does Maybe; I must have misread that :s
03:14:39 <ivanm> s/Maybe/Map/
03:14:40 * ivanm facepalms
03:15:14 <ivanm> but why do Arrays use (p > 9) rather than (p > 10) like all the others do?
03:16:05 <ivanm> ugh; since haskell.org is down, is there an alternate place I can find a copy of the report?
03:16:40 <copumpkin> http://webcache.googleusercontent.com/search?q=cache:-mqyjHM6QvoJ:www.haskell.org/tutorial/classes.html+haskell+report+show+typeclass&cd=2&hl=en&ct=clnk&gl=it&client=safari
03:16:54 <ivanm> hmm... the report says it should use p > 10, so why does the actual implementation use p > 9 ?
03:17:16 <ivanm> copumpkin: eh, ended up finding an old draft of what was then the haskell' report on d.h.o ;-)
03:17:27 <copumpkin> :)
03:17:46 <ivanm> Heffalump: do you know why there's a discrepancy there?
03:18:10 <Heffalump> sounds like a bug. Don't arrays just Show using fromList?
03:18:23 <Heffalump> the precedences will mainly be used for arithmetic expressions
03:18:29 <ivanm> @hoogle array
03:18:29 <lambdabot> package array
03:18:30 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
03:18:30 <lambdabot> module Data.Array
03:18:38 <ivanm> ^^ they use the array function, yeah
03:19:09 <ivanm> showsIArray p a =  showParen (p > 9) $ showString "array " .  shows (bounds a) .   showChar ' ' . shows (assocs a)
03:19:13 <ivanm> ^^ what it uses
03:19:31 <ivanm> whereas the report has:
03:19:53 <ivanm> showsPrec p a = showParen (p > arrPrec) (showString "array " . showsPrec (arrPrec+1) (bounds a) . showChar ' ' . showsPrec (arrPrec+1) (assocs a)  
03:20:00 <ivanm> where arrPrec = 10
03:20:26 <ivanm> also, the report specifies a Read instance, whereas the docs don't seem to have one :s
03:20:37 <Heffalump> I don't know what would generate 10 (and thus see a difference)
03:20:52 <ivanm> *nod*
03:21:12 <Heffalump> the precedences are the same as the infix <nnn> ones, I think
03:21:32 <ivanm> but that lack of a Read instance is a bigger wtf, unless there's a technical reason why it can't have one...
03:23:11 <Heffalump> > array (0,1) [1,2]
03:23:12 <lambdabot>   array *Exception: Error in array index
03:23:20 <Heffalump> > array (0,1) [1]
03:23:21 <lambdabot>   array (0,1) [(0,*Exception: (Array.!): undefined array element
03:23:26 <Heffalump> huh?
03:23:36 <ivanm> @type array
03:23:37 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
03:23:47 <Heffalump> oh, so why did my first one even typecheck?
03:23:53 <ivanm> > array (0,1)  [(0, 'a'), (1, 'b')]
03:23:54 <lambdabot>   array (0,1) [(0,'a'),(1,'b')]
03:24:09 <ivanm> Heffalump: good question... >_>
03:24:10 <Heffalump> > read "array (0,1)  [(0, 'a'), (1, 'b')]"
03:24:11 <lambdabot>   *Exception: Prelude.read: no parse
03:24:23 <Heffalump> > read "array (0,1)  [(0, 'a'), (1, 'b')]" :: Array Int Char
03:24:24 <lambdabot>   array (0,1) [(0,'a'),(1,'b')]
03:24:28 <ivanm> maybe a mueval bug trying to be too lazy in reading it in?
03:24:32 <Heffalump> looks like there is a read instance somewhere
03:24:49 <ivanm> OK, so the Data.Array module just doesn't know about it...
03:24:56 <ivanm> or else Haddock isn't displaying it for some reason
03:28:08 <Peaker> openFile + hPutStrLn + normal exit out of main --> Empty file!
03:28:15 <Peaker> how come?
03:28:46 <Jafet> trace it!
03:28:56 <Peaker> seems someone's not flushing buffers when exiting
03:29:09 <Peaker> main = do { h <- openFile "test.txt" WriteFile ; hPutStrLn h "Hello!" }
03:29:12 <Jafet> Closing a file flushes its buffer
03:29:12 <Peaker> Empty test.txt
03:29:45 <Jafet> closeFile h? Though that shouldn't be required
03:30:04 <Peaker> Yeah, this is a trivial test thingie, I shouldn't need to close here
03:30:21 <Jafet> Or hFlush
03:30:24 <ivanm> why shouldn't you?
03:30:41 <ivanm> Peaker: lazy I/O, don't forget
03:30:49 <ivanm> which is why you should use iteratees instead! :p
03:30:53 <Jafet> Aha.
03:31:02 <Peaker> ivanm, Well, FILE* in C has atexit handlers to fflush.  open() in Python works similarly (perhaps wrapping FILE*).. There was graceful flushing at graceful exit everywhere else I've worked
03:31:12 <Peaker> ivanm, hPutStrLn isn't lazy I/O
03:31:33 <Jafet> @undo do { h <- openFile "test.txt" WriteFile ; hPutStrLn h "Hello!" }
03:31:33 <lambdabot> openFile "test.txt" WriteFile >>= \ h -> hPutStrLn h "Hello!"
03:31:36 <Peaker> it would be reasonable if it failed when I explicitly called some low-level exit() thing
03:31:51 <Jafet> I suppose adding return () will fix it
03:31:53 <Peaker> WriteMode and not WriteFile, btw
03:31:58 <ivanm> Peaker: isn't it? I figured since everything else is lazy...
03:32:06 <ivanm> Jafet: I doubt it...
03:32:13 <Peaker> ivanm, There's no Lazy O, just Lazy I, but it's called Lazy I/O :)
03:32:19 <Peaker> (What would lazy output do?)
03:32:35 <Jafet> ivanm, that won't force hPutStr to run?
03:32:41 <ivanm> Peaker: not output stuff until it's forced to
03:33:06 <Peaker> ivanm, what would force output?
03:33:19 <ivanm> Peaker: I've had a problem dealing with a command that expected interactive stuff that i had to flush the input buffer to get it to start spitting out output
03:33:25 <Peaker> Jafet, hPutStr runs by being bound to main, laziness shouldn't have a role here
03:33:42 <ivanm> "shouldn't" /= "doesn't" ;-)
03:35:36 <Twey> Peaker: Exactly what it currently does — buffering :þ
03:37:43 <Peaker> Twey, yes, FILE* also does buffering, but it has atexit() hook to flush all FILE*s
03:42:46 <mreh> how can I visualise a matrix of pixel values?
03:43:00 <mreh> anyone done this before?
03:43:12 <Peaker> maybe I should open a ticket on the ghc trac
03:43:50 <Jafet> mreh, ... draw the pixels?
03:44:12 <mreh> Jafet: yes :)
03:44:15 <mreh> but with what?
03:44:27 <mreh> I don't want to load openGL just for this
03:44:28 <Jafet> If you're cheap, ppm.
03:44:45 <Peaker> Hayoo is down too?
03:44:46 <ivanm> mreh: well, I cheated and used matlab... >_>
03:44:53 <ivanm> but that was because I wanted an animation
03:45:05 <ivanm> mreh: maybe hmatrix has something...
03:45:09 <ivanm> or else use gnuplot maybe
03:45:22 <mreh> gnuplot is T_T
03:45:39 <mreh> at least henning's bindings are
03:46:11 <ivanm> definitely
03:46:17 <mreh> been looking at Chart, but I can't find a suitable output
03:46:19 <ivanm> mreh: what kind of visualisation are you wanting?
03:46:31 <mreh> a surface plot would do
03:46:38 <ivanm> and no, AFAIK Chart is just for function data
03:46:43 <ivanm> mreh: oh, a 3D plot?
03:46:47 <ivanm> CHart is definitely out then
03:46:49 <mreh> in 2D
03:47:01 <ivanm> as in a contour kind of thing then?
03:47:10 <mreh> you can think of an image as a surface plot that is colour coded
03:47:16 <ivanm> lemme dig up what I wrote to call to gnuplot a few years back
03:48:14 <ManateeLazyCat> mreh: Do you like Cairo? I use it draw pixel. :) 
03:48:18 <ivanm> just have to remember which assignment wanted 3D plots (and thus made me use gnuplot rather than Chart)
03:48:40 <mreh> ManateeLazyCat, I think Chart is based on Cairo, it looks nice
03:49:15 <mreh> is there an open letter to Henning? I'd be inclined to ask that he stops writing modules in this fashion
03:49:27 <mreh> it's entirely unsuited to Haddock 
03:49:27 <ivanm> mreh: you're welcome to look through my butchered gnuplot-generating code here if you want: http://paste.pocoo.org/show/222147/
03:49:32 <mreh> sweeeet
03:49:36 <ivanm> mreh: which fashion?
03:49:53 <mreh> ivanm: Ts and Cs everywhere
03:49:59 <Peaker> Filed a ticket..
03:50:35 <ivanm> mreh: I had 2 weeks to write that and all the simulation stuff, whereas people who were using matlab had it for free ;-)
03:50:47 <ivanm> oh, wait, you mean henning's stuff?
03:50:59 <mreh> ivanm: I know the feeling!
03:51:02 <ivanm> there was a discussion on reddit about that; IIRC the idea is you can drop and replace them all
03:51:54 <Twey> mreh: No, but there's a movement to write a tool to de-Henning-ise code.
03:52:04 <Peaker> Is argv[0] exposed?
03:52:09 <soupdragon> man that is so silly why can't people just get along
03:52:17 <Twey> Peaker: getProgramName
03:52:25 <mreh> handcuffs :)
03:52:28 <Peaker> Twey, Ah. Unfortunate name, since that is only a convention
03:52:30 <Twey> getProgName, sorry
03:52:51 <ivanm> Peaker: yeah, in System.Cmd or something IIRC
03:52:57 <Twey> Well, I imagine that on a platform that didn't follow the convention, it would do something different
03:53:01 <Twey> It's just in System
03:53:13 <byorgey> I don't see why Henning ought to stop writing code that way.  Why can't we fix Haddock so it works better with his code?
03:53:27 <ivanm> byorgey: because the former is easier? :p
03:53:53 <ivanm> mreh: http://www.reddit.com/r/haskell/comments/c9ynh/punt_the_prelude/c0r4oj9
03:54:40 <ManateeLazyCat> byorgey: haddock replace? Where?
03:54:48 <Peaker> Twey, Any shell/exec call can violate the convention
03:55:11 <byorgey> ManateeLazyCat: eh?
03:55:31 <ManateeLazyCat> byorgey: What do you talking about? Fix haddock
03:55:32 <ManateeLazyCat> ?
03:56:26 <byorgey> ManateeLazyCat: there's a certain style of writing Haskell code where you only put one type or class per module and always call the type T or the class C
03:56:44 <byorgey> then you import it qualified  like  import qualfied My.Module
03:56:53 <byorgey> and then you refer to the type as My.Module.T  and so on
03:57:05 <byorgey> but the documentation Hackage generates just says 'T'
03:57:16 <byorgey> instead of My.Module.T, so it's impossible to tell which type it is talking about
03:57:37 <ManateeLazyCat> byorgey: I see, so haddock don't support it now?
03:58:09 <ivanm> nope
03:58:40 <byorgey> but it really ought to.  I see no reason why if you use qualified names in the code, the documentation shouldn't also show the qualified names.
03:59:28 <mreh> it's not idiomatic haskell
03:59:37 <Twey> Because nobody *writes* code with qualified names
03:59:50 <Twey> Qualified names are for the library's users, not its creators
03:59:58 <mreh> I know that's paradoxical
04:00:30 <Twey> So there is no information for Haddock to use in deciding whether to use a qualified name, or what qualified name to use (in the case of re-exported symbols)
04:00:36 <mreh> where does the inspiration come from? Is it Java?
04:00:52 <Twey> Henning's?  ML, if I remember correctly
04:03:53 <alip> is there a way i can make cabal pass some options to ghc only if ghc is of a specific version?
04:04:51 <byorgey> alip: yes,  if impl(ghc == 6.12.1) ...  or something like that
04:06:35 <robin_rytich> guys... situation is: package i need fails to build with my version of ghc (6.12). is there any way i can install other version of ghc?
04:07:30 <FunctorSalad_> "a certain style" lol
04:07:31 <byorgey> alip: see the cabal manual, it's pretty well-documented
04:07:45 <alip> byorgey: thanks! :)
04:08:34 <byorgey> robin_rytich: you can easily install another version of ghc, but it's not so easy to do it in a way that doesn't clobber your current install.
04:08:53 <tomberek_> hey byorgey
04:08:55 <byorgey> robin_rytich: you could look into using a tool like stow, I think that's how most people do it who have multiple versions
04:09:19 <byorgey> robin_rytich: what's the package, ot of curiosity?
04:09:22 <byorgey> *out
04:09:26 <robin_rytich> vacuum-cairo
04:09:34 <robin_rytich> visualizing haskell structures
04:10:06 <robin_rytich> very cool, you should check out screenshots
04:10:33 <byorgey> robin_rytich: oh yeah, I've seen it, it's very cool =)
04:10:39 <byorgey> robin_rytich: why doesn't it build with 6.12?
04:11:25 <tomberek_> how does the 'more specific' deal with type classes work?
04:11:35 <byorgey> hey tomberek_ 
04:11:52 <robin_rytich> byorgey: don't know, there is some sort of "Ambigouus occurence `G.evenKeyName'"
04:11:53 <tomberek_> i have one that says Functor f, and one that says ((,)a)    so why is there a conflict?
04:11:59 <tomberek_> howdy
04:12:06 <robin_rytich> byorgey: here's build log http://hackage.haskell.org/packages/archive/vacuum-cairo/0.4.1/logs/failure/ghc-6.12
04:12:27 <robin_rytich> byorgey: it's common error, not just i have it
04:12:27 <byorgey> robin_rytich: oh, I don't think that 6.12 itself is the problem
04:12:49 <robin_rytich> byorgey: really? what is then?
04:13:55 <byorgey> robin_rytich: looks like vacuum-cairo is naughty and doesn't specify upper bounds on the versions of its dependencies
04:13:57 * hackagebot TeaHS 0.3 - TeaHS Game Creation Library  http://hackage.haskell.org/package/TeaHS-0.3 (LiamOConnorDavis)
04:14:12 <byorgey> robin_rytich: so I'm guessing the gtk package got updated and now vacuum-cairo doesn't work with the latest version
04:15:00 <robin_rytich> byorgey: i'll check it out. a pity i'm not quite familiar with haskell development circle yet ;-)
04:15:21 <byorgey> robin_rytich: I suggest doing a 'cabal unpack vacuum-cairo'
04:15:26 * soupdragon  can't seem to get anything done
04:15:37 <byorgey> then go in and edit the vacuum-cairo.cabal file to add some upper bounds on the versions
04:15:56 <byorgey> then just 'cabal install' in the directory and see if you can get it to work with an older version
04:16:13 <robin_rytich> byorgey: cool, thanks, i'll try that
04:16:58 * hackagebot TeaHS 0.3.1 - TeaHS Game Creation Library  http://hackage.haskell.org/package/TeaHS-0.3.1 (LiamOConnorDavis)
04:17:57 <byorgey> robin_rytich: alternatively, you could bug dons to fix it, he ought to know better =)
04:22:10 <byorgey> tomberek_: oh, sorry, I missed your question
04:22:25 <ManateeLazyCat> byorgey: I think fix any cairo library is easy.
04:22:27 <tomberek_> no question.. well, i still have one, but it's long
04:22:36 <byorgey> tomberek_: the Functor f one says something like   instance Functor f => Foo f where ... ?
04:22:58 <byorgey> tomberek_: note that instance selection ONLY looks at the part to the right of the =>
04:23:10 <tomberek_> ah,, that sucks
04:23:14 <byorgey> you might think that means, "if f is a Functor, then it is an instance of Foo"...
04:23:23 <tomberek_> it doesn't look at constraint?
04:23:26 <tomberek_> dang
04:23:30 <byorgey> but it ACTUALLY means, "any f is an instance of Foo, and if you use it as such, it had better be an instance of Functor too"
04:23:54 <ManateeLazyCat> byorgey: From http://hackage.haskell.org/packages/archive/vacuum-cairo/0.4.1/logs/failure/ghc-6.12 , it's easy to fix.
04:24:30 <byorgey> tomberek_: part of the reason is that type classes are open.
04:24:59 <tomberek_> byorgey, i'm trying to auto compose functors
04:25:04 <byorgey> tomberek_: so at compile time you don't know whether a type is an instance of Functor or not; ther might not be one at the moment but you might later link with another module that provides an instance
04:25:30 <tomberek_> hm, makes me think what i'm doing is impossible 
04:25:34 <byorgey> tomberek_: yeah, I think I saw you talking earlier about what you are trying to do, and it sounds difficult
04:25:53 <tomberek_> i'm trying a type class hack
04:25:59 <byorgey> I don't think it's impossible, but it probably requires >500 milliOlegs of type hackery
04:27:00 <byorgey> actually looking at some of Oleg's code might actually be helpful, in fact
04:27:16 <robin_rytich> byorgey: well, mailing maintainer is the best options i have now: vacuum-cairo depends on svgcairo (version 0.11.0 available only) while svgcairo depends on gtk-0.11.*
04:27:25 <robin_rytich> byorgey: but thanks for your help
04:27:52 <byorgey> robin_rytich: ok. Don Stewart often hangs out in here too, as dons
04:28:06 <byorgey> tomberek_: maybe something here:  http://okmij.org/ftp/Haskell/types.html
04:28:31 <byorgey> tomberek_: this in particular: http://okmij.org/ftp/Haskell/types.html#class-based-overloading
04:29:05 <tomberek_> sounds right
04:29:54 <byorgey> robin_rytich: oh, note that version 0.11.0 is the only version of svgcairo *available on Hackage*
04:30:08 <byorgey> robin_rytich: this is because it iw only with 0.11 that gtk2hs has been cabalized at all
04:30:21 <byorgey> robin_rytich: but you should be able to download older versions from the gtk2hs website.
04:30:34 <byorgey> robin_rytich: then again, it probably isn't worth it. =)
04:32:51 <robin_rytich> byorgey: actually i have archlinux vm running having all i need in distro repos
04:33:46 <robin_rytich> byorgey: was just fighting ubuntu, but well it sucked if to compare to arch. one of million times
04:34:05 <byorgey> hehe, I switched from Ubuntu to arch last year too =)
04:34:17 <byorgey> although I don't use the arch haskell packages
04:34:34 <Ke> you should have joined ubuntu community in order to maintain haskell packages
04:34:56 <robin_rytich> byorgey: there are some in aur, but it doesnt worth it most of times so don't bother
04:39:02 <benmachine> > fix (printf . ("%s" ++))
04:39:03 <lambdabot>   "*Exception: Printf.printf: argument list ended prematurely
04:39:14 <benmachine> makes sense I guess
05:02:53 <ManateeLazyCat> robin_rytich: If i have permission, i can fix any gtk2hs-base package that broken by 0.11.0
05:03:07 <ManateeLazyCat> robin_rytich: I recommend you use gtk2hs-0.11.0 and don't use old version.
05:03:42 <ManateeLazyCat> robin_rytich: Infact, we change some export or module name, so fix broken problem is pretty easy.
05:04:37 <robin_rytich> ManateeLazyCat: would really appreciate that
05:05:04 <ManateeLazyCat> robin_rytich: So which hackage package broken?
05:05:18 <ManateeLazyCat> robin_rytich: I can give your fix patch.
05:05:28 <ManateeLazyCat> robin_rytich: You can use it install it before author fix it.
05:06:13 <robin_rytich> ManateeLazyCat: vacuum-cairo fails to build with gtk 0.11 I guess
05:06:35 <ManateeLazyCat> robin_rytich: Ok, i will look it, and send your fix patch later.
05:07:06 <robin_rytich> ManateeLazyCat: would be superb
05:11:24 <ManateeLazyCat> robin_rytich: Got it.
05:11:41 <ManateeLazyCat> robin_rytich: Add " hiding (eventKeyName)" at line 21
05:11:45 <ManateeLazyCat> import qualified Graphics.UI.Gtk as G hiding (eventKeyName)
05:12:10 <ManateeLazyCat> dons: Are you there?
05:14:08 <ManateeLazyCat> @tell dons Use "import qualified Graphics.UI.Gtk as G hiding (eventKeyName)" replace 21 line of file "vacuum-cairo-0.4.1/System/Vacuum/Cairo.hs" to fix vacuum-cairo-0.4.1 failed with gtk2hs-0.11.0
05:14:09 <lambdabot> Consider it noted.
05:14:18 <robin_rytich> ManateeLazyCat: it worked! I'm actually ashamed i didn't figured it out previously
05:14:21 <robin_rytich> ManateeLazyCat: thanks
05:14:29 <ManateeLazyCat> robin_rytich: NP :)
05:15:27 <blackdog>  /query lambdabot
05:15:43 <ManateeLazyCat> robin_rytich: Infact, it's ours (gtk2hs developers) fault. But sometimes, it's unavoidable that make better gtk2hs APIs.
05:16:19 <blackdog> blah, my hoogle-fu is failing me - what's the idiom for repeating an action n times in a monad?
05:16:32 <byorgey> replicateM
05:16:59 <byorgey> @hoogle Int -> m a -> m [a]
05:16:59 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
05:16:59 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
05:16:59 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:17:00 <robin_rytich> ManateeLazyCat: don't bother, you're doing a great work
05:17:10 <ivanm> tomberek_: I forget, why did we split the two classes up?
05:17:17 <ivanm> I'm thinking of just making it all one big class...
05:17:21 <tomberek_> which two?
05:17:27 <ManateeLazyCat> @tell dons I recommend you use Graphics.UI.Gtk.Gdk.EventM replace Graphics.UI.Gtk.Gdk.Events in your vacuum-cario code, we won't maintain Graphics.UI.Gtk.Gdk.Events anymore.
05:17:27 <lambdabot> Consider it noted.
05:17:35 <ivanm> InductiveGraph and Graph
05:17:51 <blackdog> cheers byorgey
05:18:18 <tomberek_> ivanm: Graph was just the required definition, InductiveGraph was defaulted functions
05:19:31 <portnov> @hoogle toString
05:19:31 <lambdabot> System.Time calendarTimeToString :: CalendarTime -> String
05:19:32 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
05:19:32 <lambdabot> Network.HTTP.Base uriAuthToString :: URIAuth -> String
05:20:10 <portnov> @hoogle ToString
05:20:11 <lambdabot> System.Time calendarTimeToString :: CalendarTime -> String
05:20:11 <lambdabot> System.Time timeDiffToString :: TimeDiff -> String
05:20:11 <lambdabot> Network.HTTP.Base uriAuthToString :: URIAuth -> String
05:20:18 <portnov> :/
05:20:52 <portnov> Are there any "standart" class with single method toString :: a -> String? Except for Show.
05:21:09 <Saizan> IsString
05:21:18 <ManateeLazyCat> robin_rytich: I will send patch to Dons.
05:23:04 <mauke> @src IsString
05:23:04 <lambdabot> Source not found. :(
05:23:17 <mauke> @hoogle fromString
05:23:18 <lambdabot> Data.String fromString :: IsString a => String -> a
05:23:41 <robin_rytich> ManateeLazyCat: Great news, other guys I study Haskell with have already given up building this ;-)
05:24:19 <ManateeLazyCat> robin_rytich: I have send patch to Dons. :)
05:24:27 <byorgey> portnov: yes, Pretty, from the package 'pretty'
05:24:57 <ManateeLazyCat> robin_rytich: If you have any gtk2hs-base package broken, tell me, i will help you fix it.
05:25:22 <robin_rytich> ManateeLazyCat: I'll sure do. Thks again
05:25:31 <robin_rytich> ManateeLazyCat: Gone testing
05:26:00 <ManateeLazyCat> robin_rytich: gtk2hs-0.11.0 just bug fix version, old APIs haven't change. (except departed APIs).
05:26:34 <ManateeLazyCat> robin_rytich: So any gtk2hs-0.10 code should be work in gtk2hs-0.11.0
05:27:46 <robin_rytich> ManateeLazyCat: I haven't had a chance to try vacuum-cairo on gtk2hs-0.10 since it depends on svgcairo-0.11.0 which depends on gtk2hs-0.11.*. But it's over now, problem solved.
05:30:19 <ivanm> tomberek_: other way round actually ;-)
05:30:29 <ivanm> tomberek_: but I'm thinking we just make it one big class...
05:30:35 <tomberek_> ivanm: ah
05:30:38 <ivanm> since it makes type signatures nicer ;-)
05:31:01 <ivanm> IIRC, the reason we proposed the split was to avoid having one big mega-class which might make it harder to find documentation
05:31:15 <ivanm> but having two big mega-classes doesn't make the documentation any easier to go through
05:31:15 <ManateeLazyCat> robin_rytich: Hmm, i haven't found any gtk code exist in svgcairo-0.11.0, maybe i need remove "gtk >= 0.11 && < 0.12" from svgcairo.cabal
05:31:23 <ivanm> so how about we just join them together again?
05:31:37 <ivanm> since there's no real technical reason why a graph would be an instance of one but not the other
05:32:26 <robin_rytich> ManateeLazyCat: Never used it before, so don't know.
05:36:50 <ManateeLazyCat> robin_rytich: svgcairo-0.11.0 should just depend on glib-0.11.0 and cairo-0.11.0
05:37:02 <ManateeLazyCat> robin_rytich: I will fix this in svgcairo darcs version.
05:38:18 <robin_rytich> ManateeLazyCat: So there is no need to install gtk2hs-0.11.* for svgcairo... very nice!
05:38:39 <ManateeLazyCat> robin_rytich: Yes, svgcairo just need cairo. don't need gtk-0.11.0
05:40:51 <ManateeLazyCat> robin_rytich: I have fix this problem in darcs version, in svgcairo-0.12.0 don't need gtk-0.xx anymore.
05:42:01 <robin_rytich> ManateeLazyCat: Great, already messaged couple of buddies to tell them problem's gone.
05:43:27 <IRCSTINKS> why foldr (+) 0 [1..1000000] leads to overflow in ghci? it is not possible to evaluate it iteratively?
05:43:43 <benmachine> IRCSTINKS: not with foldr
05:43:49 <benmachine> IRCSTINKS: try Data.List.foldl'
05:43:55 <benmachine> (the ' is important)
05:44:02 <ManateeLazyCat> robin_rytich: If you find any problem like vaccum-cairo, please complain it at gtk2hs list, we will help you guys fix those problem, even that's not gtk2hs package, at least we can provide patch. :)
05:44:40 <robin_rytich> ManateeLazyCat: will do ;)
05:48:25 <aristid> Cale: cale.yi.org seems to be down :/
05:59:11 <ManateeLazyCat> Bye all. :)
06:01:14 <aristid> seems like haskell.org is having problems too
06:02:36 <sioraiocht> again?
06:02:50 <copumpkin> it was "compromised"
06:03:45 <copumpkin> http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
06:04:06 <copumpkin> surely an evil plan by jdh
06:04:11 <copumpkin> to undermine the credibility of haskell
06:04:30 <aristid> is cale.yi.org affected by the same problem?
06:04:39 <copumpkin> I doubt it
06:04:58 <copumpkin> different IPs
06:05:45 <copumpkin> they could be the same machine but it seems unlikely, especially given that the IPs are completely different
06:06:14 <aristid> they could be in the same data center or something
06:06:59 <copumpkin> haskell.org lives at yale
06:08:23 <aristid> yi.org seems to be a dyndns service
06:08:35 <copumpkin> ah
06:16:28 <ville> haskell.org AWOL?
06:16:46 <alexsuraci> ville: yep
06:16:51 <ville> rgr
06:17:02 <alexsuraci> ville: related: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
06:22:28 <ville> Ok.
06:23:40 <ivanm> tomberek_: so, you happy with re-joining the classes?
06:29:39 <Jafet> Perhaps someone should add that to the topic.
06:29:52 <ivanm> Jafet: we've tried things like that before
06:30:00 <ivanm> people still come in and ask "is hackage down?" :s
06:30:22 <Jafet> Then you can righteously berate them for not reading the topic.
06:30:23 <roconnor> ivanm: did you try all caps?
06:30:28 <roconnor> maybe blink
06:30:33 <chrisdone> it's pretty good practice to put your classes, types and instances in .Class, .Types and .Instances respectievly right? in case the user wants to define their own class or instances
06:30:42 <Jafet> Topic marquee?
06:30:44 <ivanm> roconnor: lol
06:30:46 <mauke> chrisdone: sounds like a terrible idea
06:30:53 <ivanm> definitely
06:30:59 <ivanm> first of all, you get orphan instances
06:31:27 <chrisdone> so?
06:31:55 <copumpkin> "friend module X"
06:32:13 <ivanm> chrisdone: depending upon what your package is for, having a separate module for the classes might make sense
06:32:21 <ivanm> but actually naming them .Class, .Types, etc. doesn't
06:32:38 <mauke> chrisdone: http://www.p-nand-q.com/humor/programming_languages/sorted_/manual.html
06:32:43 <ivanm> instead, name the modules after the class/datatype that it's about
06:32:53 <ivanm> e.g. Data.Functor, Data.Set, etc.
06:33:04 <chrisdone> well duh
06:34:08 <ville> Haskell doesn't leak imports from a module to another module that imports said module, right?
06:34:19 <mauke> ville: not by default
06:34:29 <ville> I take it I could force it?
06:34:53 <mauke> module Foo (module Bar, baz) where import Bar; baz = 42
06:34:58 <mauke> reexport everything
06:35:11 <ville> ok
06:35:35 <roconnor> I hope I don't pass today's round of google code jam, otherwise I will have two contests to do in 2 weeks time.
06:36:10 <roconnor> oh no
06:36:22 <roconnor> the next round google code jam is next week
06:39:10 <blackdog> roconnor: worst of luck then, i guess:)
06:39:18 <blackdog> what's the other contest?
06:39:23 <roconnor> ICFP
06:39:25 <blackdog> oh, duh
06:39:33 <blackdog> i ought to get a team together for that this year
06:39:34 <roconnor> the good contest
06:39:37 <blackdog> heh
06:39:51 <roconnor> google code jam reminds me of why I don't like the ACM contests
06:39:56 <blackdog> why?
06:40:01 <blackdog> i've been having fun with it
06:40:08 <blackdog> although coding at midnight's a bit off-putting
06:40:10 <roconnor> I really enjoy making beautiful code
06:40:27 <roconnor> but the short time of the contest makes this a bad strategy
06:40:34 <blackdog> true, i guess.
06:40:46 <blackdog> if you write ugly code for ICFP you'll just get bogged down
06:40:49 <roconnor> the ICFP is just long enough to make vaguely good code worthwhile
06:40:51 <ville> blackdog: brain doesn't start until 3pm
06:41:10 <blackdog> but you can get away with the chainsaw solution in gcj
06:42:22 <roconnor> ya
06:42:51 <roconnor> all the gcj C solutions begin with int foo[600][600]
06:42:54 <blackdog> i ended up writing C for one of the last ones
06:43:13 <blackdog> i still haven't quite mastered array-based solutions in haskel
06:43:14 <blackdog> l
06:43:35 <roconnor> blackdog: I spent 12 hours on question C from round 1C.
06:43:39 <roconnor> blackdog: I learned a lot!
06:44:02 <roconnor> granted I slept for maybe 8 or 9 of those hours
06:44:16 <blackdog> heh. i looked at that one, looked at my position, decided i'd already made it and had a bottle of wine and watched a movie with my girl.
06:44:24 <blackdog> i maintain i made the correct decision
06:44:29 <roconnor> damn you
06:44:36 <blackdog> (that was the chessboard?)
06:44:39 <roconnor> yes
06:44:43 <blackdog> how'd you do it?
06:44:50 <blackdog> i was thinking about lists of partial solutions
06:45:27 <roconnor> blackdog: oh I looked at the solution after the contest
06:45:47 <roconnor> well I (almost) solved the small problem before the contest
06:45:52 <roconnor> but it would never have scaled
06:46:04 <roconnor> after reading the solution it still took me hours to get it to run in Haskell
06:46:37 <roconnor> (with purely functional code,  no ST monad)
06:46:43 <blackdog> yeah
06:46:50 <blackdog> i need to dive into the ST monad at some point
06:47:05 <roconnor> I ended up using the PSQueue package
06:47:12 <roconnor> priority search queues
06:47:13 <blackdog> actually, has anyone written a really good intro on mutation-based code in haskell?
06:47:34 <roconnor> to give me the priority queue to find the largest chess board
06:47:54 <roconnor> and then the search queue lets me update the new values for the largest boards at each coordinate
06:47:57 <chrisdone> module Foo.Food where class Food a where taste :: a -> Taste; data Taste = Nice | Orrid
06:47:57 <chrisdone> module Foo.Banana where import Foo.Food; data Banana; instance Food Banana where taste = const Nice
06:47:57 <chrisdone> the user of the Foo library is welcome to implement their own Food instance for Banana, but how?
06:48:26 <roconnor> the the trick was to use a small Array to calculate the new sizes for the portion of the board that needs updating
06:48:40 <roconnor> Array's in haskell are great for dynamic programming IMHO.
06:48:54 <roconnor> lazy boxed arrays
06:49:07 <blackdog> roconnor: they're fine if you can state the problem in a no-update way
06:49:07 <chrisdone> ivanm: mauke: ?
06:49:20 <blackdog> not always possible, though
06:49:36 <ivanm> chrisdone: sorry, haven't been paying attention
06:49:56 <ivanm> chrisdone: but that looks alright
06:50:25 <ivanm> this of course depends upon circumstances: does it really make sense to have Banana in a separate module?
06:50:49 <ivanm> if you're always going to use Banana, probably not; if it's an optional choice (the user picks which Food they're going to use for their program) then it makes sense
06:51:13 <ivanm> e.g. with FGL, tomberek_ and I are going to have the class defined in one module, then a few sample instances in their own modules
06:51:14 <benmachine> ivanm: it seems a weird idea to me to have multiple possible instances for the same data type
06:51:23 <benmachine> eeer, chrisdone:
06:51:27 <ivanm> since people aren't necessarily going to use the one graph all the time
06:51:34 <Twey> benmachine: Why?
06:51:35 <ivanm> benmachine: huh?
06:51:47 <ivanm> benmachine: when does the one data type have different possible instances for the same class?
06:52:03 <ivanm> benmachine: if you meant the other way round: so, you use lists for everything do you?
06:52:07 <Twey> Maybe's Monoid instance, for example…
06:52:09 <ivanm> rather than Set, Map, Seq, etc. ?
06:52:10 * benmachine blinks
06:52:33 <Twey> And List's Applicative
06:52:46 <benmachine> ivanm: I mean, in chrisdone's example it might make more sense to have data TastyBanana and data NastyBanana
06:52:50 <benmachine> with corresponding instances
06:52:58 <roconnor> blackdog: usually dynamic programming problem are (locally) no update
06:53:08 <benmachine> rather than having a single Banana and being able to choose what its instance Food does
06:53:13 <ivanm> benmachine: that's not what he was saying AFAICT
06:53:20 <adekoba> is haskell.org going up anytime soon?
06:53:27 <ivanm> adekoba: good question
06:53:33 <ivanm> benmachine: he's saying have each different Food in its own separate module
06:53:49 <ivanm> oh, right, sorry, I missed the second thing that he said
06:54:02 <ivanm> chrisdone: I think users picking their own instance in general is a bad idea
06:54:13 <ivanm> but if you have to do it, have different modules that do nothing but define that instance
06:54:13 <benmachine> right, that's more or less what I meant :P
06:54:15 <blackdog> roconnor: yeah, that's true.
06:54:27 <chrisdone> lol
06:54:48 <roconnor> blackdog: no worrying about scanning through the array in the correct order
06:54:57 <blackdog> and i can usually get the lazy references right with a bit of headscratching, but as soon as i hit the cases where you'd like to update a cache, for instance, it all goes to hell
06:55:03 <roconnor> though I guess that usually isn't too hard to get right
06:55:04 <chrisdone> i'm asking how do you do it, not how do you feel about it?
06:55:18 <chrisdone> n/m
06:55:31 <roconnor> blackdog: what is your gcj name?
06:55:54 <blackdog> roconnor: i remember trying to do the collatz problem from project euler in haskell and it was hell of ugly until i thought of the dynamic programming approach
06:55:58 <blackdog> oh, mwotton@gmail.com
06:56:12 <roconnor> I want to add you to my friends list there
06:56:22 <blackdog> which was very embarrassing, because I was trying to show someone how elegant Haskell was:)
06:56:53 <roconnor> User mwotton not found.
06:57:04 <jnj> How do I make a global constant variable? Like pi in Prelude.
06:57:21 <benmachine> jnj: just put x = 17 at the top level
06:57:21 <aavogt> @src pi
06:57:21 <lambdabot> Source not found. :(
06:57:22 <ddarius> pi isn't a global constant
06:57:22 <Taejo> jnj: pi isn't actually a constant, but just "x = 5"
06:57:24 <blackdog> roconnor: hm, that's weird. how are you logging in, anyway? i've still got the "compete in 3 minutes" thing up
06:57:30 <jnj> ah.. of course
06:57:33 <jnj> i should have realised
06:57:41 <jnj> Thanks, I'll just do that :)
06:57:44 <blackdog> roconnor: oh, nickname is mrak
06:57:45 <blackdog> sorry
06:57:52 <roconnor> I went to the scoreboard from round 1C
06:58:00 <chrisdone> ivanm: the problem is when you have a library that has a complex data type and a bunch of instances of different classes. but maybe you don't like the way one of the instances was defined, and you don't want to use a newtype and wrap it
06:58:01 <aavogt> @src Double pi
06:58:01 <lambdabot> Source not found. I am sorry.
06:58:07 <roconnor> blackdog: cool thanks
06:58:15 <roconnor> blackdog: roconnor here
06:58:22 <ivanm> chrisdone: RW example of why you'd want to do such a thing?
06:58:24 <chrisdone> ivanm: you're stuck with it
06:58:37 <benmachine> you use a newtype despite not wanting to :P
06:58:38 <ivanm> users choosing their own instances sounds like a bad idea IMHO
06:58:43 <benmachine> that's what they're *for*
06:58:48 <aavogt> take Either's Applicative instance
06:58:55 <ivanm> benmachine: yup, especially with GeneralisedNewtypeDeriving
06:59:02 <ivanm> (theough they're also for data safety, etc.)
06:59:09 <chrisdone> ivanm: yeah you said users choosing their own instances blah blah before
06:59:51 <benmachine> chrisdone: I think making the instance optional might potentially lead to people defining their own, and then even if it's the same then you get all the usual orphan problems
07:00:05 <aavogt> this looks suspiciously like   Monoid m => Either m    http://hackage.haskell.org/packages/archive/applicative-extras/0.1.6/doc/html/Control-Applicative-Error.html
07:00:11 <blackdog> roconnor: here we go...
07:00:15 <ivanm> aavogt: where is this instance?
07:00:26 <ivanm> benmachine: yup
07:00:59 <aavogt> to clarify:   Monoid m  => Applicative (Either m)
07:01:03 <aavogt> that's the instance
07:01:10 <aavogt> ivanm: it doesn't exist
07:01:15 <darq> hello.. i would like to read 4 numbers from haskell .. how to do that .. somethin like this in c :scanf("%d %d %d %d", &x,&y,&z,&q) 
07:01:42 <ivanm> darq: on one line?
07:01:50 <darq> yes
07:01:56 <ivanm> @type map read . words . getLine
07:01:57 <lambdabot> forall a. (Read a) => IO [a]
07:02:03 <ivanm> @hoogle readLn
07:02:03 <lambdabot> Prelude readLn :: Read a => IO a
07:02:03 <lambdabot> System.IO readLn :: Read a => IO a
07:02:07 <benmachine> er
07:02:09 <ivanm> nah, readLn won't work
07:02:12 <dschoepe> darq: there's also a type-safe scanf available here: http://hackage.haskell.org/packages/archive/liboleg/2010.1.5/doc/html/Text-PrintScan.html
07:02:17 <copumpkin> @typo replicateM 4 readLn :: IO [Int]
07:02:17 <benmachine> @type fmap (map read . words) getLine
07:02:18 <lambdabot> IO [Int]
07:02:18 <lambdabot> forall a. (Read a) => IO [a]
07:02:27 <benmachine> copumpkin: on separate lines, though
07:02:32 <ivanm> copumpkin: looks like it's on the one line to me
07:02:32 <copumpkin> oh I see
07:02:37 <mauke> that scanf isn't restricted to a single line
07:02:39 <aavogt> except that doesn't match the format string
07:02:59 <ivanm> wait, hang on, how come mine type checked? :/
07:03:01 <mauke> darq: I'd read a line and split it into words
07:03:08 <benmachine> ivanm: . = fmap :P
07:03:26 <ivanm> I didn't fmap/liftM the map and words
07:03:29 <ivanm> benmachine: oh, Caleskell
07:03:29 <ivanm> right
07:03:36 <benmachine> :t fmap fmap fmap (map read) words getLine
07:03:37 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
07:03:37 <lambdabot>       Expected type: String -> [[String]]
07:03:37 <lambdabot>       Inferred type: String -> [String]
07:03:38 <benmachine> aw
07:03:45 <zachk> > let string = "1234 4 8 10" in let ri n = read n::Integer in sort.map ri.words $ string 
07:03:45 <lambdabot>   [4,8,10,1234]
07:04:29 <chrisdone> benmachine: what's bad about orphan instances?
07:04:44 <ivanm> chrisdone: GHC bitches about them :p
07:04:54 <benmachine> chrisdone: if module A and module B define orphan instances, I can't use both modules at once
07:05:03 <benmachine> well
07:05:08 <benmachine> if module A and module B define instances
07:05:10 <ivanm> and in general, instances are/should be defined either with the datatype in question or the class
07:05:18 <aavogt> qualified names should have reserved . without spaces for namespacing
07:05:21 <chrisdone> benmachine: (why would you?)
07:05:21 <benmachine> but that's not possible unless at least one of them is orphan
07:05:22 <zachk> sup edwardk
07:05:31 <chrisdone> ivanm: why?
07:05:38 <benmachine> chrisdone: why wouldn't I?
07:05:42 <chrisdone> ivanm: when you define an instance of Ord, are you defining it in the same module?
07:05:44 <ivanm> chrisdone: then again, there is one situation where I can think of that a user might want different instances for the same class/type pair: Arbitrary instnaces for graphs...
07:05:55 <ivanm> chrisdone: I define it with the data type...
07:05:57 <chrisdone> benmachine: because those modules are for instances and you can only pick one
07:06:18 <benmachine> chrisdone: but suppose some other library picks one, and some other other library picks a different one
07:06:21 <edwardk> heya zachk, not much, adding the last few operations to my ad lib  today hopefully
07:06:24 <benmachine> and then I want to use both libraries
07:06:29 <ivanm> the real problem here is that importing instances is transitive
07:06:32 <zachk> ad lib? edwardk
07:06:44 <chrisdone> ivanm: or an instance of your own class for a standard data type?
07:06:48 <ivanm> if there was an explicit instance namespace, you could state which instance you wanted and not have this problem
07:06:56 <ivanm> chrisdone: then I define it with the class
07:07:07 <chrisdone> ivanm: but your instance and data type are separate
07:07:26 <benmachine> chrisdone: the instance has to be with *either* the class or the data type to avoid being orphan
07:07:27 <ivanm> the only times I've had orphan instances is when I define Arbitrary instances for my types in their own stand-alone testing modules (since they aren't built by default)
07:07:33 <edwardk> zachk https://patch-tag.com/r/ekmett/ad/snapshot/current/content/pretty
07:07:54 <benmachine> chrisdone: because if it's with either of them, no-one else can define an instance of that class for that datatype
07:08:00 <chrisdone> benmachine: yeah i get it
07:08:10 <ivanm> chrisdone: (emphasis added) <ivanm> and in general, instances are/should be defined either with the datatype in question *or the class*
07:08:12 <aavogt> ivanm: control over whether instances are imported lets you change the behavior of code just like -XOverlappingInstances
07:08:24 <edwardk> zachk: lets you calculate partial derivatives of haskell functions along with their answers
07:09:09 <ivanm> aavogt: hmmmmm...
07:09:23 <aavogt> maybe it's ok because it's an explicit feature then
07:09:39 <ivanm> I didn't say that the ability to choose which instance via imports/exports was a well thought out perfect idea ;-)
07:09:48 <benmachine> no I think it's sensible for there to be at most one instance for every type in the haskell universe
07:10:17 <benmachine> because for example you can generate a Set with one Ord instance in one module and then pass it to a different module which uses another
07:10:21 <benmachine> and it breaks
07:10:31 <ivanm> benmachine: I think Arbitrary is an exception to that
07:10:39 <benmachine> ivanm: newtype newtype newtype :P
07:10:39 <ivanm> since you often want to generate data specific to your application
07:10:42 <edwardk> confluence is one of the most important properties of type classes
07:10:47 <edwardk> ivanm: use a newtype
07:10:59 <edwardk> propFoo (Positive a) = ...
07:11:00 <benmachine> use two newtypes stacked on top of each other
07:11:01 <benmachine> just in case
07:11:01 <aavogt> you don't have to use arbitrary
07:11:02 <ivanm> benmachine: I don't want to have to newtype my use of Strings in graphviz just to make testing (which users shouldn't see) easier!
07:11:14 <aavogt> @hoogle forAll
07:11:15 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
07:11:15 <lambdabot> Language.Haskell.TH ForallC :: [Name] -> Cxt -> Con -> Con
07:11:15 <lambdabot> Language.Haskell.TH.Syntax ForallC :: [Name] -> Cxt -> Con -> Con
07:11:26 <edwardk> and QuickCheck is set up so you can explicitly call something named to generate values
07:11:26 <ivanm> as such, I've had to resort to a specific arbString function to use instead
07:11:34 <benmachine> resort?
07:11:39 <benmachine> that doesn't sound so terrible :P
07:11:44 <ivanm> @wn resort
07:11:46 <lambdabot> *** "resort" wn "WordNet (r) 2.0"
07:11:46 <lambdabot> resort
07:11:46 <lambdabot>      n 1: a hotel located in a resort area [syn: {resort hotel}, {holiday
07:11:46 <lambdabot>           resort}]
07:11:46 <lambdabot>      2: a frequently visited place [syn: {haunt}, {hangout}, {repair},
07:11:48 <lambdabot> [11 @more lines]
07:11:51 <aavogt> hehe
07:11:52 <ivanm> gah
07:11:53 <ivanm> @more
07:11:53 <lambdabot>          {stamping ground}]
07:11:53 <lambdabot>      3: something or someone turned to for assistance or security;
07:11:54 <lambdabot>         "his only recourse was the police"; "took refuge in lying"
07:11:56 <lambdabot>         [syn: {recourse}, {refuge}]
07:11:58 <lambdabot>      4: act of turning to for assistance; "have recourse to the
07:12:00 <lambdabot> [6 @more lines]
07:12:05 <benmachine> I know what it means >_>
07:12:06 <ivanm> benmachine: third and fourth definitions!
07:12:20 <ivanm> edwardk: not sure I follow what you mean there
07:12:39 <benmachine> arbString = unNewtype . arbitrary . NewType -- sorted
07:12:41 <aavogt> ivanm: did you use forAll?
07:12:56 <aavogt> (or some variant of it)
07:13:00 <ivanm> aavogt: no
07:13:09 <ivanm> oh, wait, yeah, I might have
07:13:15 <ivanm> can't recall
07:13:18 * ivanm checks
07:13:22 <ivanm> what are "variants" of it though?
07:13:53 <ivanm> OK, I didn't use "forall"
07:14:47 <aavogt>  forAllShrink
07:15:32 <aavogt> you don't _need_ to use the Arbitrary class with quickcheck
07:15:43 <ivanm> except it makes it a lot easier
07:15:52 <ivanm> rather than generating my own clone with it
07:15:55 <chrisdone> aavogt: you don't?
07:16:03 <ivanm> if you don't, how do you get shrink being used?
07:16:06 <aavogt> not when you want/have multiple Arbitrary instances
07:16:17 <ivanm> benmachine: right, but I still have to define such a function
07:16:34 <ivanm> and thus in some of my generating code I need to special case String to call arbString rather than just arbitrary
07:16:58 <ivanm> I've had a few problems where I've accidentally written arbitrary instead of arbString and tests failed because an invalid String was generated :s
07:17:15 * benmachine hmms
07:17:19 <ivanm> and it's not that noticeable when you're doing something like "liftM4 Foo arbitrary arbitrary arbitrary arbitrary" :s
07:17:32 <aavogt> add type signatures
07:17:43 <aavogt> (left as an exercise to the reader)
07:17:50 <benmachine> aavogt: heh
07:18:00 <ivanm> aavogt: excepct arbitrary works instead of arbString since it matches the type...
07:18:27 <aavogt>  liftM4 Foo (arbitrary :: Gen String) ...
07:18:45 <ivanm> ugh
07:18:55 <ivanm> that makes it even more verbose
07:19:20 <aavogt> arbitrary instances can be written mechanically
07:19:29 <ivanm> really?
07:19:37 <ivanm> I use suchThat a lot in my Arbitrary instances
07:19:57 <ivanm> http://code.haskell.org/graphviz/Data/GraphViz/Testing/Instances.hs
07:20:06 <jystic> hi all, can anyone help me out with some code? i'm looking for the best way to apply "dropWhile (not . end) . takeWhile (not . start)" to a list over and over again until it has been completely consumed
07:20:42 <ivanm> that almost sounds like an unfoldr
07:20:45 <ivanm> @type unfoldr
07:20:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:21:00 <copumpkin> it sounds iterative though
07:21:05 <jystic> yeah i'm sure there is something which does this
07:21:05 <copumpkin> if you're doing it over and over again
07:21:21 <ivanm> copumpkin: he's doing it on the rest of the list IIUC
07:21:26 <copumpkin> ah
07:21:54 <ivanm> is there a variant of takeWhile that returns the rest of the String?
07:21:58 <aavogt> so the dropWhile should be a span/break
07:22:02 <jystic> simplifying the problem to numbers, i want [1,1,1,2,3,3,3,2,4,4,4] => [1,1,1,3,3,3,4,4,4]
07:22:04 <ivanm> aavogt: that's the one
07:22:05 <mauke> span
07:22:13 <ivanm> aavogt: actually, the takeWhile should, not dropWhile
07:22:20 <jystic> yeah span might be what i want
07:22:23 <chrisdone> @src span
07:22:23 <lambdabot> span _ xs@[]                     =  (xs, xs)
07:22:23 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
07:22:23 <lambdabot>                   | otherwise    =  ([],xs)
07:22:25 <mauke> jystic: filter (/= 2)
07:22:33 <jystic> mauke: lol
07:23:08 <ivanm> no, wait, it is for dropWhile
07:23:23 <ivanm> jystic: so with unfoldr you'd want something like this:
07:23:26 <ivanm> f "" = Nothing
07:23:39 <chrisdone> figuring out unfoldr is a good exercise
07:23:55 <ivanm> f str = Just . span (not . end) . takeWhile (not . start) $ str
07:24:10 <ivanm> methinks that should do it
07:24:20 <jystic> thanks, i'll try it out
07:26:21 <jystic> hmm actually i've explained myself wrong :)
07:26:28 <Olathe> What's an efficient way to have GHC memoize an Integer -> t function ? I know a [t] will work, but (!!) is slow.
07:26:39 <jystic> actually i want [1,1,1,2,3,3,3,2,4,4,4] => [1,1,1,4,4,4]
07:26:59 <jystic> everything between start and end should be removed
07:27:05 <Jafet> Olathe, intmap?
07:27:16 <benmachine> jystic: everything not equal to either the first element or the last element?
07:27:25 <ivanm> jystic: oh...
07:27:35 <Olathe> Jafet: I'll look at that. Thanks.
07:27:51 <ivanm> jystic: so you want to span/break first, then on the remainder do a dropWhile, then join them back together again
07:27:51 <jystic> so "aaaSbbbEcccSdddEeee" => "aaaccceee"
07:28:04 <ivanm> OK, I'm confused
07:28:07 <Olathe> deleteSingles
07:28:09 <benmachine> ah no I see
07:28:21 <ivanm> Olathe: it deleted ddd as well
07:28:30 <Olathe> Oh. O-o
07:28:31 <benmachine> jystic: so you're walking through the list and dropping sections between some delimiters?
07:28:36 <jystic> yep
07:28:46 <ivanm> jystic: sounds like you want what we said before and then do a concat
07:28:56 <ivanm> get the sections you want, then join them back up
07:30:14 <Olathe> deleteBetween start finish xs = ok xs where ok [] = []; ok (start:xs) = aw xs; ok (x:xs) = x:ok xs; aw [] = []; aw (finish:xs) = ok xs; aw (_:xs) = aw xs in deleteBetween 'S' 'E' "aaaSbbbEcccSdddEeee"
07:30:16 <Olathe> > deleteBetween start finish xs = ok xs where ok [] = []; ok (start:xs) = aw xs; ok (x:xs) = x:ok xs; aw [] = []; aw (finish:xs) = ok xs; aw (_:xs) = aw xs in deleteBetween 'S' 'E' "aaaSbbbEcccSdddEeee"
07:30:17 <lambdabot>   <no location info>: parse error on input `='
07:30:20 <Olathe> Bah
07:30:33 <benmachine> let
07:30:40 <Olathe> > let deleteBetween start finish xs = ok xs where ok [] = []; ok (start:xs) = aw xs; ok (x:xs) = x:ok xs; aw [] = []; aw (finish:xs) = ok xs; aw (_:xs) = aw xs in deleteBetween 'S' 'E' "aaaSbbbEcccSdddEeee"
07:30:41 <lambdabot>   ""
07:30:46 <jystic> :)
07:31:08 <benmachine> Olathe: you need to use guards
07:31:19 <benmachine> ok (x:xs) | x == start = aw xs
07:31:19 <benmachine> etc.
07:31:43 <Olathe> > let deleteBetween start finish xs = ok xs where ok [] = []; ok (x:xs) = if x == start then aw xs else x:ok xs; aw [] = []; aw (x:xs) = if x == finish then ok xs else aw xs in deleteBetween 'S' 'E' "aaaSbbbEcccSdddEeee"
07:31:44 <lambdabot>   "aaaccceee"
07:32:02 <benmachine> woooo
07:32:10 <mauke> s/S.*?E//g
07:32:19 * benmachine glares at mauke
07:32:22 <jystic> cool :) thanks so much guys
07:33:26 <jystic> mauke: lol, i wonder if regexes can be made polymorphic
07:34:03 <mauke> :t noneOf
07:34:04 <lambdabot> Not in scope: `noneOf'
07:34:04 <benmachine> :t (=~)
07:34:05 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
07:34:45 <mauke> :t Text.Parsec.noneOf
07:34:45 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
07:35:00 <benmachine> :t subRegex
07:35:01 <lambdabot> Not in scope: `subRegex'
07:35:03 <benmachine> oh
07:35:11 <jystic> what if i have a list of Fruit instead of a list of Char?
07:35:25 <benmachine> jystic: as long as they're Eq it should be fine
07:36:01 <aavogt> I doubt that
07:36:05 <jystic> can i provide a function that returns Bool?
07:36:16 <benmachine> yes
07:36:17 <jystic> eg.    s/S.*?E//g where S :: (a -> Bool); E :: (a -> Bool)  -- :)
07:36:20 <benmachine> with minor modifications
07:36:50 <benmachine> if you understand why the thing given above works it shouldn't be too hard to work out the necessary changes :)
07:37:06 <benmachine> if you don't understand the thing above then you should do that first :P
07:37:08 <benmachine> and we can help there
07:37:29 <jystic> yeah, i don't really want regexes over fruit :)
07:37:40 <jystic> but it's cool that you can do that if you want
07:37:47 <benmachine> wait
07:37:48 <mauke> :t \a z -> liftM2 (,) (Text.Parsec.many (Text.Parsec.noneOf a)) (Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf z) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf a)))
07:37:49 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
07:37:49 <lambdabot>     In the first argument of `Text.Parsec.Char.char', namely `a'
07:37:49 <lambdabot>     In the first argument of `(>>)', namely `Text.Parsec.Char.char a'
07:37:55 <jystic> i think Olathe
07:37:56 <benmachine> what are you talking about I suspect it's different from what I'm talking about
07:38:04 <jystic> i think Olathe's solution will be fine
07:38:10 <mauke> :t \a z -> liftM2 (,) (Text.Parsec.many (Text.Parsec.noneOf [a])) (Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf [z]) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf [a])))
07:38:10 <benmachine> oh ok
07:38:10 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Char -> Char -> Text.Parsec.Prim.ParsecT s u m ([Char], [[Char]])
07:39:25 <Olathe> jystic: Here it is nicely laid-out: http://codepad.org/NlcoCz4U
07:40:15 <jystic> Olathe: thanks! deleteBetweenFuncs is exactly what i want
07:40:16 <mauke> :t \a z -> parse (do x <- Text.Parsec.many (Text.Parsec.noneOf [a]); xs <- Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf [z]) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf [a])); return (x ++ concat xs)) "delBetween"
07:40:16 <lambdabot> Not in scope: `parse'
07:40:18 * hackagebot yaml-rpc 0.3 - Simple library for network (TCP/IP) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-0.3 (IlyaPortnov)
07:40:24 <mauke> :t \a z -> Text.Parsec.parse (do x <- Text.Parsec.many (Text.Parsec.noneOf [a]); xs <- Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf [z]) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf [a])); return (x ++ concat xs)) "delBetween"
07:40:25 <lambdabot> forall s. (Text.Parsec.Prim.Stream s Identity Char) => Char -> Char -> s -> Either Text.Parsec.Error.ParseError [Char]
07:40:41 <Absolute0> Is the 3rd edition of the CLRS worth the extra cash or should I just go with the cheapest 1st edition I can find?
07:40:57 <Olathe> jystic: You're welcome.
07:41:02 <mauke> > let db = \a z -> Text.Parsec.parse (do x <- Text.Parsec.many (Text.Parsec.noneOf [a]); xs <- Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf [z]) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf [a])); return (x ++ concat xs)) "delBetween" in  db 'S' 'E' "aaaSbbbEcccSdddEeee"
07:41:03 <lambdabot>   Not in scope: `Text.Parsec.parse'Not in scope: `Text.Parsec.many'Not in sco...
07:41:12 <mauke> :t let db = \a z -> Text.Parsec.parse (do x <- Text.Parsec.many (Text.Parsec.noneOf [a]); xs <- Text.Parsec.many (Text.Parsec.char a >> Text.Parsec.many (Text.Parsec.noneOf [z]) >> Text.Parsec.char z >> Text.Parsec.many (Text.Parsec.noneOf [a])); return (x ++ concat xs)) "delBetween" in  db 'S' 'E' "aaaSbbbEcccSdddEeee"
07:41:12 <lambdabot>     No instance for (Text.Parsec.Prim.Stream [Char] Identity Char)
07:41:12 <lambdabot>       arising from a use of `db' at <interactive>:1:286-317
07:41:12 <lambdabot>     Possible fix:
07:41:16 <mauke> aww
07:41:30 <copumpkin> wall o' text
07:41:51 <portnov> mauke: maybe running ghci would be simpler? ;)
07:42:11 <benmachine> :t (=~~) -- what is the point of this
07:42:12 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
07:42:21 <aavogt> benmachine: fail
07:42:27 <benmachine> oh
07:42:31 <benmachine> laaaaaame
07:43:00 <benmachine> just use maybe like normal people do :(
07:44:18 <aavogt> > "how about" =~~ "abc" :: Either String String
07:44:19 <lambdabot>   Left "regex failed to match"
07:45:09 <aavogt> benmachine: you could theoretically avoid quite a bit of plumbing that way
07:45:31 <cconstantine> I found a page talking about how to generate llvm code from haskell (not compile haskell to llvm; use the haskell llvm binding) and now I can't find it... does anyone know where it is?
07:45:31 <benmachine> > "what of" =~~ "flib[blr"
07:45:32 <lambdabot>   No instance for (GHC.Show.Show (m target))
07:45:32 <lambdabot>    arising from a use of `M91500...
07:45:36 <benmachine> > "what of" =~~ "flib[blr" :: Either String String
07:45:37 <lambdabot>   *Exception: user error (Text.Regex.Posix.String died: (ReturnCode 7,"Unmatc...
07:45:55 <benmachine> l(replicate 30 'a')me
07:46:33 <mauke> @hoogle ungetc
07:46:33 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
07:47:16 <aavogt> benmachine: unless you generate regexes including user input, it's probably for the better that you get an exception there
07:47:58 <Olathe> cconstantine: I think that was augustss's page.
07:48:05 <benmachine> aavogt: mm, I guess so
07:48:18 <benmachine> aavogt: but I'm still not pleased about the fail thing
07:48:46 <benmachine> mzero would be more appropriate, and Maybe even more so
07:49:31 <aavogt> perhaps the argument to fail sometimes contains useful information?
07:49:32 <benmachine> or just make instances for all the relevant types, it's not hard to do that either
07:49:45 <Olathe> cconstantine: http://www.serpentine.com/blog/2008/01/03/llvm-bindings-for-haskell/ and http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
07:49:47 <benmachine> aavogt: it's invariably "regex failed to match" as far as I can see
07:49:50 <benmachine> aavogt: http://hackage.haskell.org/packages/archive/regex-base/0.93.1/doc/html/src/Text-Regex-Base-Context.html
07:49:57 <cconstantine> Olathe, awesome, thanks :)
07:50:08 <benmachine> anyway, if it did it would be textual information, which is a stupid form to have information in
07:51:14 <benmachine> aavogt: the RegexContext a b () instance is particularly silly if you ask me
07:51:27 <Olathe> cconstantine: You're welcome
07:51:54 <benmachine> aavogt: it is vitally important that I whine at you about this what with how well-placed you are to address the issue
07:53:10 <aavogt> if you're using regex, I think you've already given up enough static guarantees that a little fail isn't going to make things much worse
07:54:05 <benmachine> aavogt: it's not about static guarantees it's about silly functions that aren't at all appropriate in this case :P
07:54:32 <benmachine> it's just... not a sensible way to represent failure
07:54:42 <aavogt> so you're after more sensible type errors?
07:55:12 <Twey> 15:48:25 < benmachine> mzero would be more appropriate, and Maybe even more so
07:55:24 <benmachine> I'm just after dropping the monadic version of (=~) because it isn't genuinely more useful than (=~~)
07:55:32 <benmachine> eeer
07:55:35 <Twey> benmachine: Why would a particular instance of a thing be more appropriate than the general concept?
07:55:39 <benmachine> (=~~) isn't more useful than (=~)
07:56:07 <benmachine> Twey: the particular instance is easily converted into other instances
07:56:19 <benmachine> Twey: using e.g. maybe
07:56:22 <Twey> But it's already a Maybe, if you want it to be
07:56:32 <Twey> :t maybe
07:56:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:56:58 <benmachine> Twey: I think explicitly giving a Maybe discourages lazy error handling
07:57:00 <Twey> :t maybe undefined undefined (undefined :: MonadPlus a => a)
07:57:01 <lambdabot>     `a' is not applied to enough type arguments
07:57:01 <lambdabot>     Expected kind `*', but `a' has kind `* -> *'
07:57:01 <lambdabot>     In the type `(MonadPlus a) => a'
07:57:05 <Twey> Oops
07:57:11 <Twey> :t maybe undefined undefined (undefined :: MonadPlus m => m a)
07:57:12 <lambdabot> forall a. a
07:57:43 <Twey> benmachine: ‘Lazy error handling’?
07:57:57 <Twey> If I want to handle lazy errors, then I should damn well be allowed to ☺
07:58:09 <benmachine> heh
07:58:21 <benmachine> I dunno I think excess polymorphism can be a bad thing
07:58:49 <Twey> Why?
07:59:23 <benmachine> it makes things less obvious I guess?
07:59:41 <aavogt> you need to see what happens without Num
07:59:50 <benmachine> I said excess :P
07:59:54 <aavogt> + +.
08:00:25 <plucky__> Num and Show are pretty handy :)
08:00:41 <benmachine> anyway, in this specific case the monadic versions are generally pretty useless
08:00:47 <aavogt> benmachine: less obvious is the whole point
08:01:01 <aavogt> those details aren't important
08:01:37 <chrisdone> hmm the ERC project's C files are named as .d. is that a common convention?
08:01:46 <chrisdone> i've never seen that
08:01:53 <benmachine> aavogt: but when you're reading code and something is used in two different ways, it's just more of a headache to work out what's going on
08:03:12 <benmachine> aavogt: I would prefer "do blah; guard (str =~ pat); blah" to "do blah; str =~ pat; blah"
08:04:23 <benmachine> or equally, "do blah; let x = str =~ pat; guard (x /= 0); blah"
08:04:31 <benmachine> etc. etc.
08:04:43 <aavogt> I don't think people use Text.Regex much
08:04:51 <benmachine> yes I wonder why :P
08:05:19 <Jafet> jwz syndrome
08:05:20 <aavogt> it's hard to learn by looking at type signatures
08:05:49 * ddarius just doesn't use regex much at all
08:05:58 <benmachine> only if they're multiply-polymorphic in every single typevar >_>
08:06:53 <benmachine> ddarius: well, there is that too
08:07:08 <benmachine> regex are quite handy for high information density though
08:07:13 <aavogt> well that's how you get "function overloading"
08:07:19 <jystic> i often use some sort of regex for search and replace, is there a way to do that with something like parsec?
08:07:27 <benmachine> yes
08:07:36 <Twey> chrisdone: No, the .d extension is for D code.
08:07:41 <Jafet> parsec can parse any LL grammar, I think
08:07:55 <Jafet> Well, unless you are comparing parsec to irregular expressions.
08:08:02 <Twey> It's a C-successor — something like C++ done right (relatively speaking).
08:09:50 <Ke> a bit too late for that
08:10:08 <benmachine> one can but hope
08:10:27 <Jafet> C++ is well done in the sense of a steak
08:10:41 <plucky__> hehe
08:11:12 <chrisdone> Twey: i know about D but this is all c code. the top line of the files has: /* -*- mode: c; c-basic-offset: 8 -*- */ O_O
08:11:24 <Jafet> Or like the old asian proverb, you cannot turn rice back to grains
08:12:31 <Jafet> chrisdone, which editor is that for?
08:12:50 <aristid> chrisdone: that's emacs stuff
08:13:12 <Jafet> Perhaps emacs has a better cc-mode than a d-mode.
08:13:28 <chrisdone> does gcc support D?
08:13:31 <aristid> it tells emacs that this code is C, and that indentation should use 8 spaces
08:13:42 <aristid> chrisdone: i think it does not.
08:13:45 <chrisdone> because that's what it's compiled with
08:14:11 <aristid> and D is certainly not C++ done right.
08:14:19 <chrisdone> http://ecls.git.sourceforge.net/git/gitweb.cgi?p=ecls/ecl;a=tree;f=src/c;h=45919bf3563fac1cccd7076081467ed1ba61e7b8;hb=HEAD
08:14:25 <jystic> benmachine: do you have any links to examples of the replacement part? i've used parsec for parsing but i haven't found much about doing search/replace, how would you do something like s/abc(.*?)abc/x\\1x/g
08:14:40 <Jafet> Perhaps you should ask the developers, not us
08:15:02 <Jafet> jystic, transform the parse tree
08:15:38 <Jafet> If you're doing regular language search and plain text replace, then use regular expressions
08:15:38 <chrisdone> Jafet: you can't say that after replying to me :p
08:15:41 <Twey> chrisdone: It does: gdc comes with gcc, I think.
08:16:19 <Jafet> The GCC project doesn't develop a D compiler -- so you might be using some other kind of "gcc"
08:16:33 <chrisdone> "how do you bake a cake?" "you mix soap and water right?" "that's not working" "perhaps you should ask a baker" "ya think?"
08:17:16 <ville> http://codepad.org/gGXwTQwm -- Are the lines 1 and 2 syntax-wise somehow different, are there other tricks to lessen the ()?
08:17:36 <ville> I guess I meant logic-wise really, syntatically they do appear different.
08:17:40 <Jafet> "These guys are using soap to bake a cake, why?" "Maybe they are using soap for the utensils?" "No this recipe says put the soap in the cake" "Uh, no idea then"
08:17:45 <aavogt> ville: ... `Gtk.onClicked` ...
08:17:53 <jystic> Jafet: i was doing some quick and dirty search/replace on html, i ended up using tagsoup
08:18:05 <Jafet> HTML isn't regular, so that's wrong anyway
08:18:13 <chrisdone> Jafet: haha soap for the utensils :D
08:18:18 <ville> aavogt: wouldn't I still need the () since I am passing the "g" to the functions
08:18:25 <aavogt> then you don't need the parentheses around Ndc
08:18:27 <jystic> Jafet: how do you mean?
08:18:37 <aavogt> ville: you still need one pair then
08:18:48 <Jafet> jystic, HTML isn't a regular language, as I said.
08:19:00 <jystic> yeah
08:19:14 <chrisdone> keep repeating it until he gets it
08:19:16 <ville> aavogt: The use of $ on line 1 then, good, bad or same difference?
08:19:18 <chrisdone> are you a teacher?
08:19:40 <aavogt> $ is the same
08:19:53 <aavogt> but if you do infix, you can't use the $
08:20:00 <ville> Ok.
08:20:18 <chrisdone> ville: are you doing _ <_ foo to avoid memory leaks?
08:20:32 <ville> chrisdone: Just something ghc tells me to do.
08:20:39 <aavogt> how does that avoid memory leaks, chrisdone?
08:20:52 <chrisdone> ville: yeah that's the motivation for it. are you using -Wall/
08:20:59 <aavogt> it's so that you're explicit about ignoring return values
08:21:12 <aavogt> say you have an   IO (IO a)
08:21:17 <chrisdone> aavogt: and why would you want to do that?
08:21:19 <ville> chrisdone: Yes, I suppose there's some sort of -Wno-<something> for it but haven't looked it up.
08:21:42 <aavogt> err, maybe  IO (IO ())
08:21:46 <chrisdone> http://neilmitchell.blogspot.com/2008/12/mapm-mapm-and-monadic-statements.html
08:22:09 <aavogt> then you catch mistakes where you don't end up running the inner action
08:22:58 <aavogt> I see the memory leak connection now
08:24:39 <chrisdone> -f-warn-unused-do-bind
08:25:38 <chrisdone> http://webcache.googleusercontent.com/search?q=cache:http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-sanity.html&hl=en&strip=1#id570436
08:25:44 <Peaker> I think this warning should not warn if the type is unifiable with () (ideally with type products of ())
08:25:52 <plucky__> is there a way to index a list using a range.  Something to the effect of [1, 2, 3, 4] !! [2..3]?
08:26:40 <chrisdone> Peaker: e.g. ((),())?
08:26:46 <Peaker> ya
08:26:55 <chrisdone> i see good point
08:26:57 <chrisdone> doesn't it do that?
08:27:03 <aavogt> no
08:27:04 <chrisdone> or does it only check for ()
08:27:17 <Peaker> No, I got warnings for IO actions that result in forall a. (IO a)
08:27:21 <aavogt> @type (>>)
08:27:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:27:32 <Peaker> It does check for () but not for unifiable-with-(), just is-()
08:27:52 <Peaker> (I mean, IO actions of type forall a. IO a)
08:28:48 <ville> chrisdone: So having read the links. Do you suggest I continue to do _ <-, or switch to ignore $?
08:28:49 <chrisdone> Peaker: so that would ignore e.g. putStrLn "sup" >> return undefined
08:28:54 <gwern> plucky__: could you 'map (x !!) list'?
08:29:06 <ddarius> () is not unifiable with ((), ())
08:29:07 <chrisdone> ville: good question
08:29:25 <chrisdone> ddarius: i meant ((),()) is a type product of ()
08:29:28 <chrisdone> right?
08:29:52 <ddarius> The type () is not isomorphic to ((), ()) let alone equal.
08:29:52 <Peaker> Yeah, it would be nice to allow all types which are unifiable with formulations of 1 to be O.K to ignore
08:29:57 <Peaker> (or 0)
08:30:03 * chrisdone doesn't know what a type product is
08:30:35 <Peaker> ddarius, Does it make sense to do something with an IO action result ((), ()) ?  Check it isn't bottom or such?
08:30:58 <plucky__> gwern: cool trick, thanks
08:31:16 * gwern notes that that is o(n^2)
08:31:28 <Jafet> ((), ()) with strict (,) is isomorphic to ()
08:31:33 <aavogt> probably better to work out the  take n . drop m
08:31:38 <mreh> what's the "binding-file" in c2hs? It can't be the output, that's specified by -o
08:31:49 <Jafet> Ah no, it still isn't
08:31:55 <Jafet> () needs to be strict as well
08:32:55 <ddarius> Peaker: Maybe.  Probably not, but then the solution is not to write such IO actions not to identify them with IO ().
08:33:50 <aavogt> so a warning with less false-positives may be that the ignored type has only 1 non-bottom value, but isn't ()
08:33:56 <aavogt> this misses  [()]
08:34:12 <ddarius> [()] ~ Nat (roughly)
08:34:19 <illissius> yay for h.o being down again
08:34:30 <illissius> is there any way to call a FunPtr from within haskell?
08:34:32 <chrisdone> [()] carries more information than () though
08:36:23 <Jafet> There's plenty of room at the bottom.
08:38:13 <rajeshsr> hi folks
08:45:07 <Peaker> rxvt sends the same input sequence for Sh-F1/Sh-F2 and F11/F12
08:45:47 <Jafet> Good to know
08:46:10 <Twey> Terminal sends ‘P’ and ‘Q’ for S-f1/S-f2
08:51:17 <Peaker> Twey, The OS X terminal?
08:51:31 <Twey> No, Terminal
08:53:08 <Peaker> Twey, oh Linux?
08:53:09 <Jafet> Your keystrokes. Give them to me. Now.
08:53:30 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25922#a25922
08:53:48 <Peaker> If someone can run that on OSX with "osx.txt" as an arg, and paste the result osx.txt file, it would be nice
08:53:59 <Peaker> (for each key, press that key, and then return)
09:03:52 <sizzler> anybody use bindings-DSL package here?
09:05:02 <monochrom> Oh God, the Beauty and the Beast: "Berp is an implementation of Python 3. At its heart is a translator, which takes Python code as input and generates Haskell code as output." http://lambda-the-ultimate.org/node/3970
09:05:40 <mreh> In Pieter Koopman and Chris Clack, editors, Implementation of Functional Languages, 11th. International Workshop (IFL'99), Springer-Verlag, LNCS 1868, 2000. 
09:05:43 <Jafet> If the beast didn't turn back into a man, that would have made for some grotesque love moments
09:05:46 <mreh> huh, I was taught by Chris Clack
09:06:04 <mreh> what does that mean? He edited that edition?
09:06:18 <monochrom> Yes.
09:06:30 <Jafet> That sounds like a book of proceedings
09:06:58 * alexsuraci wonders why Language.Haskell.Exts.Build doesn't have doubleE/floatE
09:07:34 <sizzler> I am trying to write a binding for a c lib that adds features to libsdl and wondering how to reuse some of the data decls already defined in SDL binding
09:08:03 <alexsuraci> ah, good, I can still do it via .Syntax.
09:09:49 <Peaker> monochrom, Yeah, I don't think it will actually have Python's semantics
09:09:54 <blackdog> roconnor: ah, you bastard, you've actually solved something:)
09:09:56 <Peaker> (it doesn't seem near that, anyway)
09:18:25 <blackdog> *sigh* i wrote a whole bunch of really crappy haskell tonight.:/
09:18:39 <blackdog> all Just and Nothing and faulty reasoning
09:19:03 <gwern> > 365 * 50
09:19:04 <lambdabot>   18250
09:19:11 <koala_man> if you realize it, it's not all bad
09:19:25 <kbojcic> show some :)
09:19:46 <blackdog> heh. i don't think i'm allowed to until the contest is over.
09:19:52 <blackdog> not that it's likely to be helpful to anyone
09:20:59 * gwern ponders how one is supposed to solve '18250 / k = ln(2)'
09:21:04 <gwern> I should've paid more attention in math class
09:21:09 <gwern> > ln 2
09:21:10 <lambdabot>   Not in scope: `ln'
09:21:11 <Olathe> What's the contest ?
09:21:14 <gwern> > log 2
09:21:14 <lambdabot>   0.6931471805599453
09:21:18 <blackdog> google code jam
09:21:21 <Olathe> Ahh.
09:21:27 <gwern> maybe something with 'iterate'
09:22:04 <blackdog> and i've just realised i've built up an elaborate log-n structure, when there are only 1000 entries and the naive algorithm is quadratic. *facepalm*
09:22:21 <gwern> :t iterate
09:22:22 <Olathe> > let k = 18250/log 2 in k
09:22:22 <lambdabot> forall a. (a -> a) -> a -> [a]
09:22:22 <lambdabot>   26329.184496223585
09:22:39 <Olathe> > let k = 18250/log 2 in 18250/k == log 2
09:22:40 <lambdabot>   True
09:22:59 <gwern> Olathe: now I feel dumb. I should've divided by the ln2 not the k
09:25:20 <ddarius> > log 2 * log 2
09:25:21 <lambdabot>   0.4804530139182014
09:27:57 * gwern writes a really silly email
09:30:17 <gwern> http://lists.urth.net/pipermail/urth-urth.net/2010-June/015108.html
09:30:26 <gwern> I figure as an old man I'll look back on this and smile
09:31:18 <roconnor> blackdog: woot, within the top 1000
09:31:25 <roconnor> that was one of my goals
09:33:20 <Jafet> gwern, brilliant
09:34:46 <blackdog> roconnor: well done:)
09:34:53 <roconnor> thx
09:34:55 <blackdog> i never left the runway, sadly
09:34:58 <roconnor> Alf beat me
09:35:10 <copumpkin> @tell kmc omg
09:35:10 <lambdabot> Consider it noted.
09:35:11 <roconnor> these problems were waaaay harder than the other rounds
09:35:23 <blackdog> started on the league problem, abandoned it, started the bacteria problem... don't think i'm that far off, but it's al lmoot now.
09:35:40 <blackdog> yeah, you're not kidding
09:35:58 <copumpkin> edwardk: btw, do you have a camcorder and a tripod? :) seems a pity to not let us poor remote people see the talks
09:36:42 <gwern> just buy a spy camera
09:36:46 <Jafet> gwern, but would that imply that there are 254000000 / 26329 cars with that bumper sticker
09:36:52 <gwern> when you're not recording talks, you can stash it in the bathroom
09:37:20 <Schalken> Is there a readFile function that is FilePath -> IO [Word8] instead of FilePath -> IO [Char]?
09:37:25 <gwern> Jafet: would it?
09:37:33 <gwern> Schalken: bytestring?
09:37:42 <Jafet> Would Fermi?
09:40:16 <copumpkin> Enrico?
09:40:30 <Schalken> gwern: (\f ->Data.ByteString.Lazy.readFile f >>= Data.ByteString.Lazy.unpack) would indeed do it, but I wasn't sure if 'upack' would cause the entire file to be read in or keep the IO lazy.
09:41:07 <Schalken> gwern: That function has a type error, but im sure you get the idea.
09:41:11 <gwern> Schalken: I think the chunk-wise laziness should work
09:41:17 <gwern> unpack doesn't need the entire bytestring
09:41:38 <gwern> Schalken: but if you need the laziness you should notice any performance issues
09:42:14 <Schalken> gwern: True. Thanks for your help.
09:47:27 <tomh-> so anyone has some cool haskell thesis ideas which involve a more practical topic? :)
09:48:17 <dancor> real-time haskell
09:48:33 <dancor> hard real-time
09:49:00 <copumpkin> region inference would be a step towards that
09:49:09 <copumpkin> probably sufficient but not necessary :P
09:49:31 <wli> Region inference is good to have anyway, no?
09:49:46 <tomh-> whats region inference
09:50:00 <copumpkin> wli: I'd think so :)
09:50:06 <dancor> http://en.wikipedia.org/wiki/Region-based_memory_management#Region_inference
09:50:16 <copumpkin> tomh-: figure out what's alive when so you can figure out allocation without GC
09:50:56 <tomh-> ah I see
09:51:05 <tomh-> probably I dont have the required courses to do that 
09:51:19 <copumpkin> tomh-: what level of thesis?
09:51:23 <tomh-> master
09:51:35 <gwern> tomh-: you could pick up ndm's supercompilation stuff and try to get it into mainline ghc
09:51:39 <copumpkin> hmm
09:51:44 <copumpkin> gwern: pejo's already working on that
09:51:51 <gwern> copumpkin: really? I hadn't heard
09:51:56 <gwern> (who is pejo?)
09:52:00 <dancor> what about a less intense way of getting hard real-time
09:52:04 <copumpkin> he doesn't hang out in here, but is usually in #ghc
09:52:13 <tomh-> actually im more interested in something which uses haskell, not in something to give haskell more fancy features, everyone seems to be doing that :P
09:52:19 <dancor> heh
09:52:26 <copumpkin> tomh-: you could revive the static contract checking stuff and get it working with modern GHC and integrated (so we don't lose that fun stuff again)
09:52:30 <copumpkin> oh
09:52:50 <dancor> fix reactive :)
09:52:57 <gwern> tomh-: hm. if you lack ideas, try reading through old HCAR reports
09:53:12 <copumpkin> tomh-: for user-level projects, you could check out the haskell-proposals subreddit
09:53:20 <gwern> that would work too
09:53:24 <tomh-> cool I will check it out
09:53:42 <copumpkin> but static contract checking is super-cool!
09:53:51 <copumpkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/HaskellContract.ps
09:53:52 <pastorn> copumpkin!!
09:53:57 <tomh-> I mean there are lots of complaints about not having success stories etc, so imo there should be some space for a topic there
09:53:59 <copumpkin> allo allo pastorn 
09:54:09 <pastorn> copumpkin: i need name suggestions!
09:54:14 <pastorn> line 25: http://codepad.org/JxfNmdSF
09:54:15 <copumpkin> for what?
09:54:15 <gwern> tomh-: oh, you could take over hpodder
09:54:27 <tomh-> lemme look what that is
09:54:32 <gwern> tomh-: I heard goerzen was looking for someone to take over its maintenance, and it already has a userbase and is in distros
09:54:36 <gwern> unusual for a haskell app
09:54:42 <copumpkin> pastorn: lol
09:54:55 <copumpkin> pastorn: what are distinguishing characteristics of the library?
09:55:21 <gwern> tomh-: also useful would be tackling missingh - splitting it up into libraries, moving stuff into base libs, etc
09:55:23 <pastorn> copumpkin: doing interactive terminals without passing around an implementation-close datatype (Grapics.Vty.Vty)
09:55:24 <Peaker> how does static contract verification differ from DT's?
09:56:01 <pastorn> copumpkin: basically MonadVty is ReaderT IO, but with the reader locked to a Vty
09:56:17 <pastorn> (don't want to take up the MonadReader functions, corrupting namespace and whatnot)
09:56:23 <tomh-> gwern: probably its usefull, but I have to be able to formulate a research question aswell
09:56:34 <gwern> tomh-: that could be a problem
09:56:58 <copumpkin> Peaker: the contracts are distinct from types but give you a form of compile-time (symbolic) execution
09:57:06 <copumpkin> as far as I understand
09:57:06 <tomh-> yeah, its very hard to have a topic approved here if its not proposed by one of the teachers here 
09:57:12 <gwern> haskell has had quite enough research; what it needs is followthrough
09:57:20 <tomh-> I know
09:57:29 <copumpkin> enough research?? oxymoron!
09:57:29 <Peaker> copumpkin, it doesn't sound like a good approach to me
09:57:37 <copumpkin> Peaker: why not?
09:58:05 <pastorn> copumpkin: any suggestions?
09:58:05 <copumpkin> Peaker: it saves you from actually writing proofs for many common properties, and can give you really useful debug information at compile time
09:58:09 <pastorn> i need a name
09:58:17 <pastorn> Graphics.CanHaz is quite good
09:58:36 <copumpkin> pastorn: lol, sure :) I can't really think of anything off the top of my hea
09:58:38 <copumpkin> d
09:58:39 <pastorn> copumpkin: (nothing too serious, there's plenty of boring names in the hackage namespace)
09:58:40 <Peaker> copumpkin, seems much less nice than DT's, but I only skimmed that paper
09:59:23 <copumpkin> Peaker: yeah, definitely, but DTs involve proofs and are remarkably cumbersome, especially since all equality is definitional
09:59:44 <copumpkin> so if you can avoid writing proofs, it's a win for a practical language
09:59:50 <tomh-> mm that subreddit contains lots of stuff
10:00:02 <copumpkin> DTs break lots of things that programmers like in programming languages
10:00:03 <tomh-> unfortunately most is related to give haskell programmers even more features :P
10:00:18 <copumpkin> like abstraction and so on :)
10:00:45 <copumpkin> they're definitely nice, but come at a very high cost
10:01:03 <Olathe> It would be nice if www.haskell.org stayed up.
10:01:14 <copumpkin> I've been struggling for hours to prove that modular addition is associative :P
10:01:22 <copumpkin> even though it's pretty clearly true
10:01:23 <Peaker> copumpkin, what happens when the contracts cannot be statically verified?
10:01:34 <Blkt> is haskell.org working for you?
10:02:34 <copumpkin> Peaker: I think it'll just tell you that the contract failed
10:02:55 <copumpkin> Peaker: I see it more as a bigger, badder form of symbolic unit testing than proofs
10:03:09 <copumpkin> but I don't know too much about it
10:03:22 <copumpkin> I feel like it meshes with haskell-ness better than DTs though
10:04:22 <Saizan> "it" being?
10:04:41 <copumpkin> the static contract checking
10:04:46 <Blkt> can you guys reach haskell.org?
10:04:57 <Saizan> ah, saw the link, thanks
10:04:58 <copumpkin> Blkt: no, it's down
10:05:13 <Blkt> copumpkin: thanks
10:05:14 --- mode: ChanServ set +o copumpkin
10:05:22 <Olathe> Blkt: http://downforeveryoneorjustme.com/
10:05:27 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Church, Milner, Rudin, Gardner", "Yes, haskell.org is down"]' by copumpkin
10:05:35 <Peaker> copumpkin, I like static guarantees, I don't like a lot of "magic" (stuff that might happen at compile time or run-time, and you are barely notified which)
10:05:35 <Blkt> copumpkin: I saw no error message I thought was my problem only
10:05:37 --- mode: ChanServ set -o copumpkin
10:05:44 <Blkt> Olathe: thanks :D
10:06:42 <monochrom> By the curry-howard tarpit, you can use dependent type for specification/contract. But this is a tarpit. A contract language and proof system explicitly designed for contracts is ergonomically different from a type system explicitly designed for type fetish.
10:06:51 <tomh-> so just wondering, is anyone here doing haskell programming for end users (which are not other haskell programmers)?
10:07:52 <ville> why would the implementation language matter to the end user of a binary?
10:08:02 <copumpkin> Peaker: http://snapplr.com/f5gd just seems really nice
10:08:24 <tomh-> ville: doesn't matter, im just wondering how many people do that..
10:08:48 <monochrom> Some languages give end users more confidence.
10:08:58 <Olathe> With functional dependencies, how is a -> b c different from a -> b, a -> c ?
10:09:12 <Saizan> Olathe: it isn't
10:09:25 <gwern> ville: it matters based on what needs to be installed
10:09:36 <copumpkin> Peaker: showing the same thing in agda would involve the comparatively painful < datatype, and you'd have to write the proof yourself. And you wouldn't know that the function is wrong, just that you haven't been able to write the proof
10:09:51 <gwern> ville: ie an interpreter based pile of source app is going to cause more errors than something distributed as a statically linked binary
10:09:53 <monochrom> "I wrote Agda in C" gives you a different confidence from "I wrote Agda in Haskell".
10:09:54 <copumpkin> Peaker: it also can't point at specific parts of the function (assuming something more complex than that example) that are wrong
10:10:13 <copumpkin> monochrom: confidence? in agda? people prove false in it all the time :P
10:11:00 <Olathe> Saizan: Ahh, thanks.
10:11:24 <Saizan> well, trying to find a counterexample is pretty different from trying to find a proof..
10:11:37 <copumpkin> Saizan: yeah, definitely
10:11:38 <JoeyA> In GHCi, is there a way to read a line and have it retained?
10:12:07 <copumpkin> I'm just saying it seems like something desirable for haskell and wouldn't involve a whole new type system and throwing inference out the door
10:12:07 <Saizan> l <- getLine
10:12:20 <Saizan> yup, it does look nice
10:12:28 <JoeyA> I thought I tried that
10:12:29 <ville> gwern: That's just matter of packaging. I've deployed both kinds of programs -- binary and interpreted.
10:12:42 <JoeyA> I guess I tried l <- getLine ; doSomethingWith l
10:12:45 <gwern> ville: whenever I hear the word 'just', I reah for my pistol!
10:13:06 <ville> gwern: You must do it often when reading Haskell source
10:13:13 <Saizan> (a counter example searcher for Agda would be nice too :)
10:13:33 <copumpkin> Saizan: I agree!
10:13:44 <copumpkin> would've saved me much time in the past
10:13:54 <copumpkin> where I had subtle mistakes in the properties I was trying to prove which made them false
10:14:03 <gwern> 'just', 'only' - these are words used to shut down thought. when someone uses them, they are trying to hide something
10:14:23 <c_wraith> @quote monoid.endofunctor
10:14:23 <lambdabot> No quotes match. You type like i drive.
10:14:26 <ville> Oh well.
10:14:35 <c_wraith> @quote endofunctors
10:14:35 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
10:14:51 <c_wraith> see the "just"?  copumpkin doesn't want us to think!
10:14:59 <Olathe> gwern: Is that the only use of those words ?
10:15:02 <Saizan> going on with general statements is a way to shut down a discussion :)
10:15:18 <copumpkin> general statements are bad, except for this one
10:15:50 <JoeyA> Has anyone been having trouble accessing haskell.org today, or is it just me?
10:15:58 * copumpkin points upwards
10:16:02 <monochrom> counterexample searcher: http://www.umsu.de/logik/trees/
10:16:12 <ville> JoeyA: it is down for now
10:16:12 <Blkt> JoeyA: yes, it's down
10:16:30 <Olathe> JoeyA: http://downforeveryoneorjustme.com/
10:16:34 <JoeyA> monochrom: wowzer
10:16:55 <monochrom> another counterexample searcher: http://alloy.mit.edu/alloy4/
10:16:57 <JoeyA> Olathe: oh yeah, forgot about that
10:17:38 <monochrom> Note how much more practical work gets done once you give up the "everything must go into a type" mantra.
10:18:12 * wli is unclear on how counterexample searchers would work at all.
10:18:12 <monochrom> You have a logic. Keep it as a logic. Don't force it into a type.
10:19:13 <copumpkin> types are great for procrastination
10:19:22 <JoeyA> FunctionalProgrammer monochrom;
10:19:28 <Saizan> monochrom: how does "forcing it into a type" get in the way?
10:19:48 <monochrom> curry-howard tarpit. think of turing tarpit.
10:20:04 <monochrom> how does "forcing it into a turing machine" get in the way?
10:20:27 * copumpkin postulates DNE and doesn't let anything get in the way
10:20:38 <monochrom> ergonomically, all encodings get in the way.
10:20:44 <Saizan> monochrom: so the logics you've linked are more expressive than the usual type theories?
10:20:45 <JoeyA> monochrom: Are you arguing against strong typing?
10:21:04 <pastorn> @where haddock
10:21:04 <lambdabot> http://www.haskell.org/haddock/
10:21:11 <monochrom> curry-howard tarpit again. same expressiveness. different user interface.
10:21:12 <pkrumins> guys, haskell.org has been down 2 days straight.
10:21:17 <pastorn> copumpkin: i've decided on the names!
10:21:25 <pastorn> PM me for a pre-release party!
10:21:29 <copumpkin> pkrumins: yep, everyone knows :)
10:21:38 <Olathe> Why does haskell.org go down ?
10:21:46 <copumpkin> Olathe: because of evil hax0rz
10:21:52 <ddarius> Because Apache is written in C.
10:21:53 <pkrumins> goes down all the time :( deeply upsetting.
10:21:53 <Olathe> srsly ?
10:22:02 <copumpkin> and because it's not hosted at a professional hosting place
10:22:05 <Blkt> ddarius: nice one
10:22:08 <copumpkin> pastorn: what are they?
10:22:19 <pastorn> copumpkin: it's a SIKRITT
10:22:23 <copumpkin> onoes
10:22:25 <pastorn> but i might tell you
10:22:25 <Olathe> Why isn't it hosted at a professional hosting place ?
10:22:30 <Saizan> monochrom: ok, what is in these logic user interface that makes them easier to write a counterexample searcher for?
10:22:32 <pkrumins> is it hosted on SPJ's laptop
10:22:32 <pastorn> PM if you wanna know... :)
10:22:35 <copumpkin> Olathe: because that takes moneh
10:22:39 <Olathe> pkrumins: Haha
10:22:48 <Rotaerk> haskellers don't have money
10:22:54 <Olathe> Ahh, why not put a PayPal donate button on it or something ?
10:22:57 <monochrom> I don't know. But it happens. As you can see.
10:23:14 <copumpkin> Olathe: maybe something about "image"
10:23:16 <Olathe> (if there is a PayPal donate button, I can't check to see ;))
10:23:16 <copumpkin> I dunno
10:23:20 <Olathe> Ahh.
10:23:37 <davean> No one has just donated hosting?
10:23:37 <Saizan> so it might just be that people working with type theories just spend their time otherwise.
10:23:37 <monochrom> Existence in our civilization of several practical counterexample searchers for logics but none for types.
10:24:03 <copumpkin> monochrom: that just means not enough people are researching types!
10:24:05 <Olathe> monochrom: What are logics and types ?
10:24:11 <copumpkin> too many mainstream logic people
10:24:16 <gwern> we can only afford to program because Haskell is Free
10:24:47 <Olathe> gwern: Haha
10:25:04 <edwardk> copumpkin: i'm personally devoid of recording equipment =/
10:25:11 <copumpkin> edwardk: oh no! :(
10:25:31 <ddarius> edwardk: You don't even have a digital camera?
10:25:32 <edwardk> clearly you should donate one to BostonHaskell ;)
10:25:54 <copumpkin> edwardk: yeah, cause I'm just rolling in money after quitting :)
10:26:05 <edwardk> copumpkin: true nuff
10:26:15 * copumpkin goes and plants another money tree
10:26:21 <edwardk> ddarius: closest i get is an iphone, and i doubt it'd record a whole talk ;)
10:26:25 <gwern> well, cheap digital cameras can also record...
10:26:47 <copumpkin> seems like a bigger issue for the iphone is the lack of a tripod mount
10:26:49 <gwern> edwardk: I dunno, iphones are pretty big
10:26:53 <copumpkin> and the difficulty of fixing it to htings
10:27:08 <ddarius> Double-sided tape.
10:27:09 <edwardk> gwern: mine is pretty packed i think i'm using like 30/32 gigs or so
10:27:17 <davean> So, has anyone asked for professional hosting for haskell.org?
10:27:23 <gwern> edwardk: delete some games
10:27:24 <copumpkin> ddarius: not fancy enough
10:27:44 <gwern> edwardk: my rule of thumb incidentally is that an hour of video is <100 mb
10:27:47 <ddarius> copumpkin: Okay, Apple-brand double sided tape.
10:27:54 <Silvah> Hell yeah... haskell.org is down again!
10:27:54 <eevar> hosting is cheap, tho. take http://www.hetzner.de/de/hosting/produkte_rootserver/eq4/ for instance. administration is the expensive/hard part
10:27:57 <copumpkin> ddarius: oh okay
10:28:07 <eevar> -tho
10:28:43 <Silvah> Who is responsible for haskell.org?
10:29:01 <monochrom> The channel topic is.
10:29:18 <edwardk> gwern: hrmm. anyways, i'll look into acquiring something to record the sessions because it has been the most common request we've had. if I don't come up with something by tuesday, then definitely July.
10:29:34 <copumpkin> edwardk: who knows, kmc might have something
10:29:38 * copumpkin pokes kmc
10:29:43 <Olathe> Silvah: Yale University, CS Department, Haskell group (http://network-tools.com/default.asp?prog=whois&host=haskell.org)
10:29:53 <gwern> the truth is, haskell.org is down because I gifted it with consciousness and infused it with the writings of grim social theorists like Hobbes and Malthus
10:30:00 <edwardk> copumpkin: he's giving the other talk this week
10:30:02 <Olathe> gwern: Heheh
10:30:08 <copumpkin> edwardk: yeah, I saw :)
10:30:17 <copumpkin> so he'll definitely be there
10:30:29 <RyanT5000> howdy edwardk, copumpkin :)
10:30:36 <copumpkin> allo allo RyanT5000 
10:30:48 <edwardk> gwern: now you just have to introduce it to shapr. shapr will convince it of the value of community, and it will proceed to donate its time to serving up content for us haskellers.
10:30:49 <Silvah> Olathe: ok, they're my biggest enemies now.
10:31:05 <Olathe> preflex seen mmorrow
10:31:06 <edwardk> RyanT5000: coming to bostonhaskell?
10:31:08 <preflex>  mmorrow was last seen on #ghc 138 days, 14 hours, 33 minutes and 23 seconds ago, saying: * mmorrow is rtfm'ing
10:31:09 <gwern> edwardk: not if I introduce it to the existentialists first and it commits suicide!
10:31:15 * copumpkin goes back to spending hours proving trivial things in agda
10:31:21 <RyanT5000> edwardk: when/where is it?
10:31:25 <copumpkin> Olathe: I found a phone number for him but can't/don't want to call it
10:31:35 <edwardk> RyanT5000: tuesday, 7pm, csail reading room
10:31:49 <ddarius> copumpkin: You could use Coq and have Ltac prove trivial things for you.
10:31:50 <RyanT5000> cool; i'll put it on my calendar
10:32:01 <Silvah> What GADTs are? Generally annoying data types?
10:32:24 <edwardk> and i'm not even planning on talking, so some newcomers who attend this session may actually attend the following one ;)
10:32:30 <copumpkin> ddarius: probably, but coq syntax makes me shudder and agda just feels nicer and less imperative
10:32:33 <RyanT5000> edwardk: lol
10:32:35 <Olathe> Silvah: Generalized abstract data types, I think.
10:32:39 <copumpkin> lol
10:32:56 <copumpkin> Silvah: they're like regular ADTs but individual constructors can specialize the type
10:33:10 <copumpkin> (and they allow you to express existentials easily too)
10:33:17 <aavogt> they aren't abstract unless you use the module system to hide the constructors
10:33:20 <ddarius> Olathe: s/abstract/algebraic
10:33:38 <Blkt> could anyone explain me why I get this error "Couldn't match the expected type `Int' against inferred type `Float'" when I evaluate this expression "4*(p par)/(1-(w par))" where "p :: Parameters -> Int" and "w :: Parameters -> Float"?
10:34:11 <aavogt> > (1::Int) / (1:: Float)
10:34:12 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:34:12 <lambdabot>         against inferred type ...
10:34:29 <aavogt> > fromIntegral (1::Int) / (1:: Float)
10:34:30 <lambdabot>   1.0
10:34:40 <Blkt> thank you aavogt 
10:34:44 <copumpkin> Silvah: for example, you could make a data Moo a where X :: Moo Int; Y :: Moo Bool... then if you wrote a function zomg :: Moo Int -> Int, you could pattern match and do zomg X
10:34:45 <Olathe> ddarius: Ahh
10:34:59 <copumpkin> Silvah: you wouldn't be able to do zomg Y because Y has the wrong type, despite still being a Moo
10:35:00 <aavogt> no problem
10:35:03 <Blkt> aavogt: I couldn't look on haskell.org so I was getting quite nervous
10:35:10 <IRCSTINKS> > (1/1)::Int
10:35:11 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
10:35:11 <lambdabot>    arising from a use o...
10:35:23 <copumpkin> Silvah: also, if you have a function where you get a Moo a and pattern match on X, a gets refined magically to Int for you
10:35:29 <aavogt> I'm not sure what there would be on haskell.org to directly answer the question
10:36:50 <copumpkin> Silvah: not sure if that helps at all :P
10:37:25 <Silvah> copumpkin: it does, thanks.
10:37:32 <aavogt> IRCSTINKS: Fractional has other methods which don't make too much sense with Int
10:38:00 <copumpkin> how do abstract protocols have a smell?
10:38:20 <danderson> irc certainly does
10:38:36 <danderson> it smells of decay and Finland
10:38:57 <aavogt> so unless Fractional was split up, you would be allowing more 'broken' programs
10:38:57 <RyanT5000> what's the deal with Language.Haskell.Exts.Annotated.Syntax.XmlPage (a constructor of Module)
10:39:13 <RyanT5000> is there really such a thing as an XML module syntax for Haskell?
10:39:19 <aavogt> RyanT5000: it's for some unimplemented extension?
10:39:41 <RyanT5000> seems odd that it'd be in haskell-src-exts; shouldn't it be in a different place, then?
10:40:24 <RyanT5000> or does syntax for various extensions always get thrown into these datastructures?
10:40:35 <aavogt> possibly for parsing code used with HSP's preprocessor or something?
10:41:00 <RyanT5000> yeah, i suppose that could be, although i don't think defining a whole module as an XML source is legal in hsp
10:41:31 <aavogt> I'd much rather have hsx support unimplemented extensions rather than the other way around
10:41:53 <RyanT5000> certainly
10:42:10 <RyanT5000> i just didn't realize that sort of stuff would be added directly to haskell-src-exts
10:42:23 <RyanT5000> is it usual for syntax extensions to modify haskell-src-exts?
10:47:10 <edwardk> RyanT5000: haskell-src is the official version haskell-src-exts contains every extension broberg ever heard of ;)
10:47:44 <aavogt> is it possible to collect these typeclass constraints into a single one? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25924#a25924
10:47:46 <benmachine> copumpkin: I have an abstract protocol with no nose?
10:47:53 <RyanT5000> edwardk: ah, ok
10:48:02 <edwardk> at the time there was a push towards some jsp-like format that made minor changes to the parser so he integrated it
10:48:31 <aavogt> people use haskell-src?
10:48:56 <ddarius> Is there a way to control which extensios haskell-src-exts allows?
10:48:59 <edwardk> it is mostly minor tweaks to allow for a top level tag and changes to the grammar to make sure that foo <bar/> baz -- gets parsed as a tag and not the use of two operators
10:49:14 <RyanT5000> right
10:49:19 <benmachine> ddarius: in theory yes
10:49:26 <edwardk> ddarius: part of his last summer of code project was to let you fiddle with what extensions you use
10:49:29 <benmachine> that is to say, yes
10:49:55 <benmachine> it reads pragmas on complete source files, or you can specify them yourself in parseWithMode or whatever it's called
10:50:01 <edwardk> some extensions mutually conflict, so it was needed
10:50:30 <copumpkin> they should encode which ones conflict in the type system
10:50:37 <copumpkin> mmmGADTs
10:51:09 <copumpkin> it'd be nice to have a mechanism to make your fancy types print prettier error messages if your conditions fail
10:51:43 <copumpkin> like, I can see how I would encode which extensions are compatible, but if someone messed it up they wouldn't have a clue what went wrong
10:52:02 <aavogt> copumpkin: can you encode the same with typeclasses?
10:52:35 <copumpkin> you probably could, using a custom list
10:52:49 <copumpkin> whereas I think we could GADT it using regular lists
10:53:11 <aavogt> I think if you feel to name all compatible extensions, you can have an overlapping instance whose head is unsatisfiable
10:53:39 <aavogt> and if it's first, you get something like    No instance for (OmgYouFail LoL, .... 10 pages later ... ) ...
10:53:59 <copumpkin> :)
10:54:00 <aavogt> or do incoherent instances allow the opposite?
10:54:28 <copumpkin> incoherent instances mostly affect the behavior with unconstrained variables like instance Moo (Maybe a)
10:54:36 <copumpkin> and what happens when you then have a function that doesn't mention the constraint
10:54:41 <copumpkin> I think
10:54:52 <copumpkin> I'm still not entirely sure what they do :P
10:55:06 <aavogt> when multiple instances match, pick the more general one
10:55:31 <MorganF> hi
10:56:02 <MorganF> Any idea when the website will be online again?
10:57:34 <cconstantine> I'm trying to compile an example haskell program using the LLVM package (installed via cabal) and hmake can't find LLVM, how do I tell hmake about LLVM?
10:59:49 <edwardk> one thing i wish was that there would be a flag that you could use to find unused language pragmas
11:00:03 <edwardk> i tend to go nuts using features, then back off and encode something closer to haskell 98
11:00:26 <mauke> brute force it, it's only O(n)
11:00:44 <Twey> Hehehe
11:00:44 <aavogt> is it, considering some flags imply other flags?
11:01:01 <ddarius> aavogt: Worst-case it is only O(n)
11:01:08 <mauke> yes
11:01:49 <edwardk> aavogt: it still should be O(n), if only because there are only a few such flags in existence ;)
11:02:06 <monochrom> I have a better way. Delete all pragmas. Let GHC tell you what you need, one pragma at a time.
11:02:22 <ddarius> monochrom: Which is an O(n) algorithm.
11:02:29 <aavogt> I mean in the general case where each extension implies a couple others
11:03:32 <c_wraith> really, it's O(1) with a huge coefficient. :)
11:03:45 <aavogt> so if it still builds after you remove one flag, you might not get to the shortest list of LANGUAGE, or one that adds the minimum number of features
11:03:53 <mauke> c_wraith: but I can use the same flag twice
11:04:04 <ddarius> c_wraith: The number of extensions approaches infinity as time approaches infinity.
11:04:23 <c_wraith> hmm.  anyone have a handy graph of number of extensions ghc supports vs time?
11:04:24 <aavogt> or do you still have an O(n) algorithm for that case?
11:04:24 <edwardk> ddarius: sadly, the compiler doesn't tell you everything you need to know to know which ones to add back in (i.e. TemplateHaskell or Rank2Types aren't stated as such)
11:04:30 <monochrom> no. approaches 0.
11:04:37 <edwardk> monochrom: hahaha
11:05:15 <edwardk> c_wraith: well it used to be pretty boring. it was ~1 for -fglasgow-exts -- for a long time ;)
11:05:32 <edwardk> (yes i know many could be turned on separately -fth, etc)
11:05:55 <mauke> -ﬃ
11:05:55 * monochrom loves -fffi and -ffi
11:06:46 <aavogt> it works with two fs?
11:06:47 <monochrom> -ppp -mp -cresc -ffff 
11:07:11 <monochrom> both works
11:07:20 <ddarius> aavogt: No, it works without an f.
11:07:26 <copumpkin> -fffffuuu
11:07:42 <mauke> g++ -ftemplate-depth-128, fuck yeah
11:08:01 <Rotaerk> copumpkin, http://img209.imageshack.us/f/fuuuucopyuy1.jpg/
11:08:05 <Rotaerk> ffffuuuuuuuuuuuuuuuu
11:08:17 <lispy> bah, freenode is blocking webchat access
11:08:20 <Rotaerk> wait...
11:08:24 <lispy> from their own webchat!
11:08:36 * Rotaerk didn't see that one frame.
11:08:56 <Rotaerk> although I'm not sure if that's what I think it is
11:09:35 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/templates/ffffuuuu.jpg
11:10:02 <monochrom> That's the problem with pictures. Maybe it's worth 10000 words but there is no consensus on which words.
11:10:15 <ddarius> mauke: You have a directory just for internet stupidity?
11:10:28 <mauke> several
11:10:34 <monochrom> which is another way to say: constructively, it doesn't worth 10000 words.
11:10:45 <pastorn> CAN HAZ on-topic-discussion?
11:10:58 <pastorn> does anyone have a haddock guide?
11:11:06 <pastorn> isn't there a big PDF with syntax etc?
11:11:17 <lispy> pastorn: hmm...there is a pdf manual for sure
11:11:18 <lispy> er
11:11:19 <shortcircuit> FunctorSalad_: "short circuit" is normally two words. ;)
11:11:21 <lispy> html not pdf
11:11:34 <pastorn> aww... and haskell.org is down :(
11:11:40 <lispy> yeah :(
11:11:56 <pastorn> lispy: do you know any of the words in the title?
11:11:57 <monochrom> google may have a cache
11:12:06 <mauke> archive.org?
11:12:08 <copumpkin> just site:haskell.org
11:12:13 <copumpkin> and whatever it is you're looking for
11:12:32 <lispy> pastorn: Haddock User Guide
11:12:39 <pastorn> www.haskell.org/~simonmar/papers/haddock.pdf
11:12:43 <pastorn> there it is...
11:13:13 <copumpkin> http://docs.google.com/viewer?a=v&q=cache:ezyPxi2oIUoJ:www.haskell.org/~simonmar/papers/haddock.pdf+haddock.pdf&hl=en&gl=it&pid=bl&srcid=ADGEESjbLKehU1XEeM0Fl7qiuUGM3NSge7e90rI24UI5vSV9fEowh9Apy13bzuNlhyxwO2vPLR0mYMTSvTeMNjXCr_SqcQBix_J8S5IWCkuzpolZc89wXHNVeWyhbkGi7T9z9fLaKSVQ&sig=AHIEtbTvIZMBJQqTiAwCJqgEK1PjPzss9Q
11:13:29 <pastorn> copumpkin: tiny?
11:13:38 <copumpkin> did it get truncated?
11:13:51 <monochrom> the url works for me
11:14:01 <copumpkin> http://bit.ly/9KkuhD
11:14:03 <copumpkin> if you insist
11:14:16 * pastorn is running weechat
11:14:22 <Rotaerk> lol
11:14:26 <mauke> copumpkin: http://hugeurl.com/
11:14:26 <pastorn> and i don't have a 500 characters wide terminal window
11:14:38 <mauke> pastorn: get a terminal with clickable links
11:14:55 <Twey> WeeChat breaks links
11:15:00 <Twey> Amongst other things
11:15:03 <pastorn> mauke: i have, but gnome-terminal doesn't support links with line breaks
11:15:07 <copumpkin> http://5z8.info/openme.exe_d0u8w_dont-just-drizzle
11:15:14 <copumpkin> pastorn: that's it
11:15:30 <Twey> It does support links with line-breaks — it just doesn't support links with chunks of sidebar inserted in the middle of them
11:15:34 <monochrom> @quote 1970s.terminal
11:15:34 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
11:15:46 * copumpkin loves shadyurl
11:15:47 <lispy> copumpkin: wow, from that url alone, I assumed that was a link to a trojan
11:15:56 <monochrom> just use a non-terminal irc program
11:16:00 <pastorn> copumpkin: hmm... the Download linky at the top doesn't work
11:16:02 <copumpkin> lispy: it's a great service
11:16:09 <copumpkin> pastorn: yeah, but you can still read it
11:16:23 <pastorn> copumpkin: true :D
11:16:32 <Twey> mauke: Hahaha, nice site
11:16:48 <lispy> 1970s terminals are the best
11:16:53 <lispy> I bet they are even a monad!
11:16:57 <Twey> Haha
11:17:04 <Rotaerk> hah
11:17:05 <Rotaerk> http://5z8.info/start-trojan_e3o6n_gain-inches
11:17:06 <copumpkin> hugeurl is too big for irc :(
11:17:16 <Rotaerk> the link ... to haddock
11:18:16 <Saizan> except that my terminal doesn't have any problem with that link, but it's nice to generalize :)
11:18:30 <JoeyA> Is there a cheaper way to build Arrays than from a list?
11:18:54 <ddarius> JoeyA: Not really which is part of why other array libraries exist.
11:18:56 <aavogt> which array?
11:19:00 <copumpkin> JoeyA: use vector and the gen :: (Int -> a) -> Vector a thingy
11:19:08 <c_wraith> If you're using an IArray, building it should be a low-cost operation.
11:19:20 <JoeyA> copumpkin: yes, similar to that
11:19:26 <pastorn> copumpkin: haha, the download link didn't work, BUT the print link opened the PDF in acroread for me :)
11:19:49 <JoeyA> But it'd be nice if it generalized to 2D arrays (I guess I can just stack vectors like one does in C++)
11:20:01 <pastorn> lispy: wait for my library...
11:20:29 <ddarius> JoeyA: There are a bunch of array libraries.
11:20:33 <monochrom> building array from list is cheap.
11:20:38 <c_wraith> JoeyA, what are you doing with this array?  What is the use pattern?  Why is building from a list too expensive?
11:20:47 <lispy> pastorn: what is your library going to do?
11:21:31 <ddarius> monochrom: Building arrays from lists was one of the performance bottlenecks identified in the standard array libraries.
11:21:56 <c_wraith> ddarius, does it cost O(n^2) time or something?
11:22:06 <copumpkin> I sure hope not
11:23:08 <c_wraith> I mean.  If it uses an O(n) algorithm, I don't see why it should be slow...  It should just be copying boxed values, unless it's a UArray
11:23:21 <c_wraith> I can see it being sort of bad for a UArray
11:23:27 <Saizan> too much garbage maybe?
11:24:38 <ddarius> c_wraith: The slow part is making the list.
11:24:56 <djahandarie> kmc, nice, you are presenting?
11:25:03 <ddarius> http://www.cse.unsw.edu.au/~chak/papers/CK03.html
11:26:33 <newsham> roconnor: around?
11:27:14 <c_wraith> Hmm.  I guess that for the use cases IArray is good for, you don't really care if creating the array is a bit slow.  Because that's nothing compared to how slow further updates to the array are.
11:28:17 <aavogt> updates mean creating new arrays
11:28:27 <c_wraith> but not from a list
11:29:23 <ddarius> The array update operation for the standard immutable arrays takes a list of changes.
11:31:39 <aavogt> @type (\\)
11:31:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
11:31:44 <roconnor> newsham: here
11:31:49 <aavogt> @type (//)
11:31:49 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
11:32:39 <newsham> roconnor: is any of your creal stuff in coq public yet?  are there any papers on it?
11:32:58 <newsham> btw, saw your coq tutorial video, pretty good.
11:33:20 <roconnor> newsham: it is part of CoRN
11:33:26 <JoeyA> Hmm, I wonder if using UArray and freeze to generate an array would be efficient.  I should try it
11:33:28 <roconnor> so you can download CoRN to get it
11:33:46 <newsham> c-corn.cs.ru. nl?
11:33:56 <roconnor> ya
11:33:58 <roconnor> hmm
11:33:59 <newsham> danke
11:34:05 <roconnor> I wonder if it is the relased version
11:34:43 <roconnor> ya looks highly likely to be available there
11:34:59 <newsham> definitely be in the git tree yes?
11:35:03 <newsham> git clone http://www.fnds.cs.ru.nl/git/CoRN.git
11:36:06 <roconnor> definitely in the git repo
11:36:21 <roconnor> but I think you can also just download the released tar ball
11:46:22 <jethr0> good evening, haskell!
11:47:23 <pastorn> @src ReaderT
11:47:23 <lambdabot> Source not found. That's something I cannot allow to happen.
11:48:04 <jethr0> maybe control.monad.reader?
11:48:43 <aavogt> @help unmtl
11:48:44 <lambdabot> unroll mtl monads
11:49:30 <jethr0> all those lambdabot functions, being added all the time ;)
11:52:43 <newsham> roconnor: i was wondering how constructive math would deal with the various discontinuous functions that seem to crop up in classic math (like unit step for example)
11:53:41 <Phyx-> Church Milner Rudin and Gardner died?
11:54:53 <tensorpudding> ah shit, rudin died?
11:55:40 <luite> did you still have questions for him? exercises that you couldn't solve?
11:56:40 <tensorpudding> no
11:57:53 <newsham> didnt church die a long time ago?
11:57:58 <tensorpudding> the 90's
11:58:27 <Phyx-> oh, go figure, I know who they are, just not how old they are :P
11:58:41 <monochrom> many days ago
11:58:57 <tensorpudding> relatively recent given how old he was
11:59:49 <monochrom> not sure about church but milner was within months, rudin and gardner was within weeks.
11:59:53 <jethr0> anyone of you ever tried coding in "J"?
12:00:12 <chrisdone> soupdragon has but ain't here
12:01:25 <tensorpudding> milner was like april or may, rudin died in may, gardner died like a week ago
12:01:31 <newsham> 3/20/2010, 5/20/2010, 5/22/2010
12:01:40 <tensorpudding> oh well
12:01:44 <Phyx-> heh
12:01:47 <Phyx-> that sucks
12:01:54 <tensorpudding> but march is recent i guess
12:02:34 <ddarius> jethr0: J is fun.
12:02:39 <newsham> prehaps a formal defn of recent wouldhelp ;-)
12:03:08 <jethr0> ddarius: I am certain it is. and also quite mind-blowing, which can be helpful at times ;)
12:03:18 <jethr0> ddarius: have you ever coded in it?
12:03:35 <ddarius> I've written code in it.  I haven't really done too much with it though.
12:03:38 <Phyx-> that's odd, the moment I decide to start debugging a function it starts working
12:03:50 <jethr0> heisenbug?
12:04:15 <Phyx-> most likely
12:04:53 <jethr0> how are you debugging?
12:05:43 <newsham> ship it with a debugger? ;-)
12:05:50 <Phyx-> I wasn't getting information from the file I was requesting from GHC, it was giving me some data from another module
12:06:11 <jethr0> that's the kind of out-of-the-box thinking I'm talking about!!
12:06:26 <roconnor> newsham: I need a bit more context
12:06:41 <Phyx-> so i figure something's wrong with the dependency graph and i'm picking the wrong module, but it was consistently failing the same way, so I decided the print the name of the module i'm inspecting
12:06:46 <roconnor> newsham: I define formal step functions in my thesis
12:06:47 <monochrom> formal definition of recent: an event is n-recent iff it happened within n time units ago.
12:06:57 <roconnor> newsham: but they are for integration, not for evaluation
12:07:00 <Phyx-> the print reveiled the right module name, and then everything started working all of a sudden
12:07:05 <ddarius> newsham: Even in classical mathematics, it is often useful to use different representations for discontinuous functions, e.g. distributions.
12:07:17 <Phyx-> though it *might* be that ghci just replaced the interface file on disk
12:07:23 <newsham> ddarius: I was made aware of that recently (dirac distribution)
12:07:50 <newsham> roconnor: its just a vague question at this point so i dont have further info.. it sounds like you kinda answered my quesiton already though.. you were able to deal with step just fine.
12:07:53 <monochrom> out-of-the-bug thinking
12:08:23 <newsham> I had seen some discussion online that seemed to imply that constructive math has some problems with discontinuities, but i guess perhaps thats only ifyou need to compute em...
12:08:24 <ddarius> newsham: One representation for such things is hyperfunctions which are equivalence classes of pairs of holomorphic functions and holomorphic functions can be readily represented constructively.
12:08:50 * wli cries
12:09:07 * Phyx- hands wli a hankie
12:09:20 <newsham> <- n00b
12:09:25 <gwern> wli: don't cry! everyone dies, so you will be avenged eventually
12:09:46 <newsham> gwern: last one out turn off the lights
12:09:50 <ddarius> gwern: Who kills God or how does He die otherwise?
12:10:02 <gwern> ddarius: haven't you heard? god is dead
12:10:04 <wli> holomorphy.com 
12:10:13 <newsham> didnt someone alread say that church died?
12:10:18 <roconnor> newsham: discontinuous functions cannot be evaluated at the discontinuity
12:10:30 <Phyx-> newsham: it would seem, someone already turned out the lights for haskell.org :P
12:11:08 <Phyx-> wli: that site didn't load
12:11:25 <jao> roconnor: you can define a discontinuous function by parts and give it a value at the discontinuity
12:11:45 <newsham> jao: "at the discontinuity" is undecidable though, no?
12:11:46 <Veinor> roconnor: f 0 = 1; f _ = 0
12:11:48 <roconnor> jao: yes but you can't tell which part your input point lies on
12:12:29 <jao> roconnor: see Veinor's example
12:12:43 <wli> Phyx-: That's why I'm crying at least right now. That is/was my domain.
12:12:59 <newsham> jao: comparing with zero is undecidable.
12:13:07 <newsham> (equality)
12:13:47 <Phyx-> wli: aha, time to go kick the server
12:13:52 <roconnor> jao: given some turing machine M define x to be sum f(i)/2^i where f(i) = 1 if M halts within i steps
12:14:28 <roconnor> jao: Veinor's function applied to x is 0 if and only if M halts.
12:14:42 <roconnor> so if Veinor's function was computable in general you can solve the halting problem.
12:14:54 <wli> Phyx-: Try getting me my job, my home, my dead bf, and my (numerous) computers back.
12:15:05 <Veinor> roconnor: but that relies on x being computable, doesn't it
12:15:07 <Veinor> ?
12:15:16 <roconnor> x is computable for any M
12:16:06 <roconnor> x is the caucy sequence of partial sums
12:16:48 <roconnor> and each partial sum is a finite sum
12:17:13 <newsham> I think what veinor is missing (maybe?) is that the computable reals are represented in a way that lets you ask for any finite number of their digits (or alternernately gives you an approximation that is within some distance of the real value)
12:17:26 <ddarius> roconnor: Have you looked at Paul Taylor's Abstract Stone Duality stuff?
12:17:37 <ezyang> http://blog.sigfpe.com/2010/04/on-representing-some-real-numbers.html seems relevant 
12:17:45 <jao> roconnor: ok. sorry, i was missing the point of the discussion.
12:17:55 <wlangstroth> anyone else having trouble reaching haskell.org?
12:18:03 <chrisdone> is there an xmonad "plugin" for switching windows like C-x b in emacs?
12:18:05 <roconnor> ddarius: yes
12:18:23 <Veinor> ahh.
12:19:01 <Phyx-> wli: ouch, that sounds rough :| 
12:20:02 <copumpkin> does nobody read the topic?
12:20:14 <copumpkin> maybe we should change it more often so people don't just ignore it
12:20:23 <monochrom> almost everybody read the topic.
12:20:51 <aavogt> perhaps because the topic is rather long?
12:20:57 <monochrom> maybe we should just ignore questions answered by the topic.
12:21:04 --- mode: ChanServ set +o monochrom
12:21:09 <copumpkin> we could bit.ly the URLs
12:21:17 <ddarius> monochrom: The question seems to be being ignored currently.
12:21:18 <wlangstroth> monochrom: mine cuts out at "The Haskell progra"
12:21:21 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "Yes, haskell.org is down"]' by monochrom
12:21:38 <ezyang> YEah, that's too long 
12:22:00 <copumpkin> we could shadyurl all the URLs in it
12:22:01 <wlangstroth> "yes, haskell.org is down" might help at the beginning of that message
12:22:27 <aavogt> haha copumpkin
12:22:33 <monochrom> This is 2010 CE. Your computer can store 2GB of data. What do you mean truncated.
12:22:39 --- mode: monochrom set -o monochrom
12:22:54 <ezyang> 2GB? Man that's puny. 
12:23:08 <newsham> i have core dumps larger than that ;-)
12:23:12 <Peaker> any idea who compromised haskell.org?
12:23:22 <jethr0> and how?
12:23:32 <copumpkin> I eated its configuration file, sry
12:24:03 <ezyang> Speaking as a sysadmin for a server that once had a compromised server, that's generally a Hard(TM) question to answer. 
12:24:09 <Saizan> copumpkin: was it good?
12:24:18 <copumpkin> Saizan: noes :(
12:24:18 <ezyang> *was compromised 
12:24:31 <Saizan>  aw
12:24:48 <jethr0> hmm, didn't mean "how" as in "what was the attack used", but rather "was data lost, and where do we stand?"
12:25:14 <flux> so it was attacked, not just some hardware down?
12:25:18 <ezyang> Oh, I was responding to who. :-) 
12:25:46 <JoeyA> Does this mean Haskell has to be written all over again?
12:26:05 <djahandarie> lol
12:26:06 <copumpkin> ezyang: omg u fail, i run big survur 2 but no haz compromize kthx
12:26:14 <newsham> joeya: no, we have haskell2010 now
12:26:17 <ddarius> JoeyA: The official Haskell 98 specification is a published book.
12:26:20 <ezyang> copumpkin: :-P 
12:26:27 * copumpkin > ezyang 
12:26:33 <monochrom> I think JoeyA is just joking.
12:26:33 <JoeyA> > ((+ 5) . (^2)) 5
12:26:34 <lambdabot>   30
12:26:49 <copumpkin> > (5 . 2) 5
12:26:50 <lambdabot>   5
12:26:56 <djahandarie> > ((+ 5) + (^ 2)) 5
12:26:57 <lambdabot>   35
12:26:59 <flux> and if its security indeed was compromised, it's time to have a House & Happs-based server next time?-)
12:27:02 <JoeyA> Is there a variant of this that doesn't require repeating the 5?  I'd imagine it would involve <$> or <*>
12:27:17 <JoeyA> Granted, there's the obvious:
12:27:20 <copumpkin> @pl \x -> ((+ x) . (^2)) x
12:27:20 <lambdabot> (+) `ap` (^ 2)
12:27:27 <JoeyA> > (\x -> x^2 + x) 5
12:27:28 <lambdabot>   30
12:27:34 <jethr0> ddarius: I hope we are not going back all the way to haskell 98. I was getting kinda used to many of the newer "extensions"...
12:27:36 <JoeyA> Ah
12:27:44 <aavogt> @type (+) =<< (^2)
12:27:45 <lambdabot> forall a. (Num a) => a -> a
12:27:48 <ezyang> (More seriously, we have a little less than 3000 local shell accounts. Lot's of attack vectors :-) 
12:27:50 <mauke> > (+) <*> (^2) $ 5
12:27:51 <lambdabot>   30
12:27:52 <roconnor> > (+) <$> (^2) $ 5
12:27:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:27:52 <lambdabot>    arising from a use of `...
12:28:03 <roconnor> gah
12:28:06 <roconnor> mauke wins!
12:28:12 <JoeyA> > ((+) <*> (^2)) 5
12:28:13 <lambdabot>   30
12:28:15 <JoeyA> Indeed, that's what I wanted
12:28:19 <newsham> flux: not sel4?
12:28:22 <JoeyA> What does @pl do?
12:28:25 <copumpkin> please don't write that, JoeyA 
12:28:29 <ddarius> @help @pl
12:28:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:28:33 <ddarius> @help pl
12:28:33 <lambdabot> pointless <expr>. Play with pointfree code.
12:28:33 <roconnor> JoeyA: removes lambdas
12:28:36 <chrisdone> JoeyA: gives a point-free/pointless version of a function
12:28:43 <benmachine> wait a sec
12:28:48 <benmachine> :t (+ 3) + (+ 2)
12:28:49 <lambdabot> forall a. (Num a) => a -> a
12:28:52 <benmachine> huh
12:28:59 <benmachine> where does that come from?
12:29:01 <aristid> :t (<*>)
12:29:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:29:03 <benmachine> and does this mean...
12:29:03 <Veinor> wait, haskell.org was compromised?
12:29:05 <copumpkin> benmachine: isn't it awesome? and did you see me composing numbers earlier?
12:29:06 <djahandarie> benmachine, there is a Num instance
12:29:08 <benmachine> > 4 4 3 4 3 3 2 3
12:29:08 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:29:08 <lambdabot>    `GHC.Num.Num t' arising f...
12:29:10 <djahandarie> > 4 5
12:29:10 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:29:10 <lambdabot>    `GHC.Num.Num t' arising f...
12:29:12 <benmachine> > 4 4 3 4 3 3 2 3 :: Integer
12:29:13 <lambdabot>   4
12:29:15 <ddarius> benmachine: vector-space I think
12:29:15 <djahandarie> Yeah
12:29:18 <chrisdone> hahaha copumpkin has totally been waiting to say that
12:29:18 <benmachine> copumpkin: nope
12:29:27 <Veinor> wait
12:29:32 <Veinor> how does composing numbers work? O_o
12:29:33 <copumpkin> > (5 . 6 . 7) 5
12:29:33 <benmachine> copumpkin: haha okay
12:29:33 <lambdabot>   5
12:29:38 <mauke> > iterate 42 1
12:29:39 <lambdabot>   [1,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
12:29:41 <copumpkin> Veinor: fromInteger = const 
12:29:49 <Veinor> ...
12:29:57 <copumpkin> to be truly newbie-friendly!
12:30:00 <mauke> Veinor: http://mauke.ath.cx/stuff/haskell/fun.hs
12:30:07 <copumpkin> > (fix . fix) 5
12:30:08 <lambdabot>   5
12:30:09 <zachk> 5.6.7.2.1.3 $ 5 
12:30:10 <aavogt> > fix 42
12:30:10 <lambdabot>   42
12:30:20 <zachk> > 5.6.7.2.1.3 $ 5 
12:30:21 <lambdabot>   5.6
12:30:27 <Veinor> that's horrible!
12:30:33 <benmachine> :P
12:30:53 <chrisdone> mauke: for tryhaskell, if i define a Show (a -> b) instance, will that pick up polymorphic functions too?
12:30:54 <ddarius> > 300.000.00
12:30:54 <lambdabot>   No instance for (GHC.Show.Show (f b))
12:30:54 <lambdabot>    arising from a use of `M1178350442...
12:30:59 <djahandarie> Oh god, that is a mix of decimal points and composing numbers
12:31:02 <mauke> chrisdone: I don't know
12:31:05 <djahandarie> > 10.10.10
12:31:05 <lambdabot>   No instance for (GHC.Show.Show (f b))
12:31:05 <lambdabot>    arising from a use of `M3462301235...
12:31:06 <copumpkin> djahandarie: mmm
12:31:13 <copumpkin> djahandarie: gotta apply it!
12:31:15 <djahandarie> > 10.10.10 $ 1
12:31:16 <lambdabot>   10.1
12:31:20 <mauke> > 10.10.10()
12:31:20 <djahandarie> O.o
12:31:21 <lambdabot>   No instance for (GHC.Show.Show (f b))
12:31:21 <lambdabot>    arising from a use of `M2873131269...
12:31:21 <jethr0> > 5.6 $ 5
12:31:22 <lambdabot>   5.6
12:31:35 <chrisdone> i thought i knew about type classes until i started using multiple parameters
12:31:49 <JoeyA> > (map . vertex <*> roots) $ topology ["abc", "ac", "def", "eg"]  
12:31:50 <JoeyA> "ad"
12:31:50 <lambdabot>   Not in scope: `vertex'Not in scope: `roots'Not in scope: `topology'
12:31:51 <aavogt> flexible instances?
12:31:51 <JoeyA> :)
12:31:56 <copumpkin> > let f = (10.000.000$) in f 5
12:31:57 <lambdabot>   10.0
12:31:58 <JoeyA> Aww shaddup, lambdabot
12:32:03 <copumpkin> omg, so much money
12:32:18 <Veinor> you wanna see somehting really stupid?
12:32:30 <newsham> > 1.2.3.4.5.6
12:32:30 <lambdabot>   No instance for (GHC.Real.Fractional (f a))
12:32:31 <lambdabot>    arising from a use of `e_112...
12:32:32 <chrisdone> i've already seen a picture of you
12:32:33 <chrisdone> zing!
12:32:35 <newsham> > 1.2.3.4.5
12:32:36 <lambdabot>   No instance for (GHC.Num.Num (f a))
12:32:36 <lambdabot>    arising from a use of `e_112345' at ...
12:32:36 <Veinor> D:
12:32:38 <Veinor> $ perl
12:32:40 <Veinor> print 104.101.108.108.111.32.119.111.114.108.100;    
12:32:42 <Veinor> hello world
12:32:52 <copumpkin> mmm
12:32:52 <djahandarie> Heh
12:32:54 <chrisdone> valid perl code
12:33:06 <copumpkin> okay, now make htat work in haskell
12:33:11 <copumpkin> go!
12:33:23 <Veinor> :P
12:33:30 <Veinor> oh god, you know why it does that?
12:33:30 <djahandarie> mauke, that doesn't have the weird flip definition in it
12:33:33 <newsham> > map chr [104,101,108,108,111,32,119,111,114,108,100]
12:33:34 <lambdabot>   "hello world"
12:33:36 <copumpkin> you don't have to use the prelude (.), but if you don't, you must use the category one
12:33:44 <Veinor> because those strings are version numbers
12:33:52 <djahandarie> Wow
12:33:54 <Veinor> and this way you can say if ($version > v0.1.8.3)
12:33:55 <mauke> Veinor: not quite
12:34:01 <mauke> and no, you can't say that
12:34:04 <ddarius> copumpkin: All you really need is a Num type that shows as "hello world"
12:34:13 <Veinor> you can't?
12:34:21 <mauke> Veinor: would have to be gt, not >
12:34:29 <Veinor> oh yeah.
12:34:36 <newsham> > let 104 = (+5) in 104 8
12:34:37 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:34:37 <lambdabot>    `GHC.Num.Num t' arising f...
12:34:49 <ddarius> copumpkin: This is the test-driven development answer.
12:34:56 <copumpkin> :P
12:34:59 <mauke> > let 104 = (+5) in 104 8 :: Int
12:35:00 <lambdabot>   104
12:35:17 <Veinor> why does that work in lambdabot but not my local ghci?
12:35:28 <copumpkin> Veinor: lambdabot is thoroughly fucked
12:35:36 <Veinor> Apparently!
12:35:45 <chrisdone> the word is 'enhanced'. you're only jealous
12:36:03 <newsham> hot4vixen
12:36:04 <mauke> Veinor: 'let 104 = (+5) in 104 8 :: Int' works in my ghci
12:36:05 <jethr0> @vixen are you thoroughly fucked?
12:36:05 <lambdabot> yes, i am
12:36:17 <copumpkin> told you
12:36:29 <chrisdone> well that's incontravertible
12:36:37 <Veinor> I get 'no instance for Num (a -> a1)'
12:36:41 <chrisdone> @vixen do you lie for attention?
12:36:41 <lambdabot> yes i do
12:36:42 <Veinor> 6.12.1
12:36:52 <mauke> Veinor: did you load fun.hs first?
12:36:52 <copumpkin> Veinor: grab it from conals' vector space package
12:36:53 <djahandarie> Veinor, that's because you don't have the instance for Num (a -> a1)
12:36:55 <copumpkin> conal's
12:37:00 <Veinor> oh, I didn't load fun.hs, yeah
12:37:03 <Veinor> doh.
12:37:09 <chrisdone> @smack Veinor 
12:37:09 * lambdabot puts on her slapping gloves, and slaps Veinor
12:37:11 <copumpkin> or fun.hs
12:37:19 <mauke> *> "123" + 4
12:37:20 <mauke> "567"
12:37:27 <chrisdone> oh god it's like perl
12:37:29 <djahandarie> lol wut
12:37:35 <mauke> that's not like perl at all
12:37:36 <monochrom> chrisdone: You knew single-parameter type classes perfectly. Don't feel bad. Multi-parameter type classes are enhanced, expect surprises.
12:37:46 <chrisdone> mauke: why isn't it?
12:37:54 <mauke> chrisdone: because in perl that's 127
12:38:07 <chrisdone> lol
12:38:17 <djahandarie> > () + () :: Integer
12:38:18 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
12:38:18 <lambdabot>         agains...
12:38:23 <chrisdone> they're both horrible string->number coercions
12:38:26 <mauke> *> "123" + "42"
12:38:26 <mauke> "ecfdge"
12:38:37 <aavogt> monochrom: except Show is a single-parameter typeclass
12:38:42 <Veinor> copumpkin: I think you could actually make show (104.111.108.108.111) evaluate to "hello"
12:38:46 <mauke> chrisdone: there are no coercions here
12:38:48 <mauke> this is haskell
12:38:52 <chrisdone> lol
12:38:53 <Veinor> if you defined a new type, Version
12:38:54 <djahandarie> > () + () :: ()
12:38:54 <lambdabot>   No instance for (GHC.Num.Num ())
12:38:55 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
12:38:57 <copumpkin> Veinor: ddarius gave a simple solution too
12:39:00 <djahandarie> Shouldn't that be working?
12:39:05 <jethr0> THIS IS HASKELLLLL!!
12:39:12 <copumpkin> > Unit :+: Unit :: 1 :+: 1
12:39:12 <lambdabot>   Not in scope: data constructor `:+:'
12:39:13 <mauke> djahandarie: only if you define a Num () instance first
12:39:20 <Veinor> well yeah, but show = const "Hello world" is cheating
12:39:23 <djahandarie> mauke, isn't it already?
12:39:24 <copumpkin> > InL Unit :: 1 :+: 1
12:39:25 <lambdabot>   Not in scope: data constructor `InL'
12:39:30 <djahandarie> mauke, it is in that file you linked
12:39:36 <copumpkin> ugh, what is the constructor for that called, anyway?
12:39:39 <mauke> djahandarie: yes, but that's not what lambdabot uses
12:39:44 <djahandarie> Ah okay
12:39:46 <mauke> fun.hs is just for illustration purposes
12:40:03 <newsham> just for fun?
12:40:09 <mauke> yes!
12:40:37 * chrisdone ponders pain.hs
12:40:53 <djahandarie> chrisdone, they are synonymous in Haskell
12:40:55 <chrisdone> would presumably involve template haskell
12:41:03 <benmachine> mauke: are you using overloadedstrings or just instance num [char]
12:41:18 <mauke> benmachine: neither
12:41:26 <benmachine> touché
12:41:31 <newsham> pain.hs embeds a perl interpretter?
12:41:41 <chrisdone> all haskell code is valid perl code
12:41:48 <Veinor> I forget, what do I need to do to be able to say instance Num (Foo -> Bar)?
12:41:59 <mauke> chrisdone: http://mauke.ath.cx/stuff/haskell/yes.hs
12:42:00 <benmachine> FlexibleInstances probably
12:42:07 <jethr0> chrisdone: how interesting, I didn't know that! ;)
12:42:17 <benmachine> heehee I remember that, mauke
12:42:21 <benmachine> I have it saved somewhere
12:42:26 <benmachine> as mauke.c.pl.hs
12:42:42 <chrisdone> Steven Wright: I wish the first word I ever said was the word "quote," so right before I die I could say "unquote."
12:42:42 <chrisdone> right before I die I'm going to say "valid perl code"
12:42:54 <texodus> I assume theres no haskell.org mirror?
12:42:58 <newsham> http://codepad.org/SQ1i0eie
12:43:03 <newsham> ^^ mauke
12:43:04 <lispy> chrisdone: or, </life>
12:43:20 <jethr0> "more light!"
12:43:21 <chrisdone> mauke: i'm afraid
12:43:44 <newsham> p2: http://codepad.org/ovEEB9Nk   p3: http://codepad.org/NCkv77An
12:43:49 <benmachine> newsham: if that is what I think it is it's brilliant and I love it
12:44:10 <chrisdone> oh wow
12:44:31 <mauke> newsham: http://www.ioccc.org/2000/dhyang.c
12:44:38 * monochrom re-wires lambdabot to automatically pass every url through shadyurl
12:44:56 <rajeshsr> ghci 6.10.4 is good enough, right?
12:45:32 <chrisdone> mauke: hehe, that's novel
12:45:33 <copumpkin> mauke: I love that one
12:45:40 <copumpkin> chrisdone: it's pretty damn impressive
12:45:50 <Veinor> @hoogle Int -> Integer
12:45:50 <lambdabot> Prelude toEnum :: Enum a => Int -> a
12:45:50 <lambdabot> Data.Bits bit :: Bits a => Int -> a
12:45:50 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
12:45:59 <lispy> well, lambdabot used to pass everything through tinyurl, I think that was disabled though?
12:46:22 <monochrom> <newbie> hi I can't get it to work. paste: http://safe-paste-bin.org/32093  <lambdabot> http://5z8.info/porn-now-3jch8-spam-me
12:46:44 <copumpkin> chrisdone: it's a circular quine-like thing that generates asciified code for 3 or 4 steps iirc
12:46:44 <djahandarie> lmao
12:46:53 <copumpkin> I mean ascii-artified
12:47:08 <mauke> http://mauke.ath.cx/stuff/poly.poly - do you have enough compilers, king of polyglots?
12:47:34 <copumpkin> :)
12:48:39 <Veinor> bleh
12:48:40 <benmachine> mauke: my head hearts, but in a fun way
12:48:47 * benmachine cycles through vim syntax highlightings
12:48:49 <djahandarie> I don't even know what is going on in that
12:48:52 <Veinor> I have instances for Num (String -> String)
12:48:56 <Veinor> but I can't get 2 . 3 to work
12:49:15 <Veinor> ... it says no instance for Num (a -> b)
12:49:17 <Veinor> wat
12:49:35 <mauke> your instance is too specific and your expression too polymorphic
12:49:40 <newsham> someone should codepad.org up the dhyang.c
12:50:12 <Veinor> hm.
12:50:15 <copumpkin> that was hard: http://codepad.org/bprq0xPi
12:50:18 <aavogt> Veinor: you need a type signature
12:50:34 <newsham> copumpkin: you're a few iterations short
12:50:36 <Veinor> aavogt: (2 . 3 . 4) doesn't work
12:50:44 <copumpkin> newsham: working on the next ones :)
12:50:45 <Veinor> er, (2 . 3 . 4) :: String -> String
12:50:51 <copumpkin> http://codepad.org/pda50CTL
12:50:59 <Veinor> it does if I explicitly say that each number is a String -> String though
12:51:20 <copumpkin> http://codepad.org/GUrhzBTw
12:51:29 <jsanders> so whats up with haskell.org these days?
12:51:38 <benmachine> it isn't
12:51:38 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25925#a25925
12:51:43 <copumpkin> http://codepad.org/LQiqd4RD
12:52:00 <aavogt> Veinor: perhaps   default can be abused?
12:52:18 <copumpkin> Veinor: just use conal's package?
12:52:28 <Veinor> copumpkin: conal's package?
12:52:29 <aavogt> why does this need undecidable instances?
12:52:36 <copumpkin> @hackage vector-space
12:52:36 <lambdabot> http://hackage.haskell.org/package/vector-space
12:52:41 <Veinor> cause I was copy-pasting stuff from fun.hs
12:52:50 <Veinor> copumpkin: bah
12:53:03 <Veinor> I'm definitely going to upload this to hackage when I'm done
12:53:03 <copumpkin> Veinor: that's where lambdabot's evil num instance comes from
12:53:05 <Veinor> under Acme
12:54:15 <aavogt> perhaps you need some TypeCast from HList
12:54:17 <mauke> :t (sqrt + 1) readLn
12:54:18 <lambdabot> forall a. (Floating (IO a), Read a) => IO a
12:54:37 <newsham> gcc dhyang.c; while : ; do ./a.out > x.c; cat x.c; gcc x.c; done
12:56:37 <Veinor> yeah, I dunno how to get this to work @_@
12:57:06 <Veinor> I can do it if I break . for everything else
12:57:59 <Veinor> just wish I could understand why what I have doesn't work.
12:58:17 <mauke> :t ?f . ?g
12:58:18 <lambdabot> forall a b (f :: * -> *). (?f::a -> b, ?g::f a, Functor f) => f b
12:58:25 <mauke> :t ?f Prelude.. ?g
12:58:26 <lambdabot> forall b c a. (?g::a -> b, ?f::b -> c) => a -> c
12:58:43 <newsham> ok, saved the dhyang.c series on http://codepad.org/users/haskell
13:01:18 <JoeyA> > let {list = [1,2,3]; a = 2; b = 3} in do {a <- elemIndex list; b <- elemIndex list; return (a && b)}
13:01:19 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:01:19 <lambdabot>         against inferred type ...
13:01:31 <JoeyA> Why isn't a's type just a Bool?
13:01:53 <mauke> :t elemIndex
13:01:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:02:04 <mauke> because a :: Int
13:02:12 <JoeyA> oh
13:02:14 <JoeyA> headslap
13:02:26 <mauke> a = 2 is not used, btw
13:02:51 <JoeyA> oh yeah
13:03:05 <ddarius> And elemIndex list is a function that will return the index of [1,2,3] in a list of lists.
13:03:23 <copumpkin> it should return a (Maybe) dependent pair with a proof that the Int is the correct index
13:04:48 <aavogt> Veinor: there's probably a safer way... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25926#a25926
13:05:26 <Veinor> so unsafe hpaste won't load
13:05:32 <JoeyA> @let after a b list = fromMaybe False $ do {ai <- elemIndex a list; bi <- elemIndex b list; return (ai > bi)}
13:05:32 <lambdabot>  Defined.
13:05:39 <Veinor> there we go
13:05:44 <aavogt> it works though
13:05:44 <Veinor> oh god, that's horriblre
13:05:45 <JoeyA> > after 'i' 'c' "abcdefghi"
13:05:45 <lambdabot>   Ambiguous occurrence `after'
13:05:45 <lambdabot>  It could refer to either `L.after', defined a...
13:05:58 <JoeyA> @let itemAfter a b list = fromMaybe False $ do {ai <- elemIndex a list; bi <- elemIndex b list; return (ai > bi)}
13:05:58 <mauke> @undefine
13:05:59 <lambdabot>  Defined.
13:06:04 <JoeyA> @undefine after
13:06:07 <Veinor> haaaaaate
13:06:15 * JoeyA isn't sure what @undefine does, sorry
13:06:25 <mauke> removes all @let definitions
13:06:28 <sizzler> what am I missing in this FFI binding http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25927#a25927 ?
13:06:38 <JoeyA> @let itemAfter a b list = fromMaybe False $ do {ai <- elemIndex a list; bi <- elemIndex b list; return (ai > bi)}
13:06:39 <lambdabot>  Defined.
13:06:42 <JoeyA> > itemAfter 'i' 'c' "abcdefghi"
13:06:43 <lambdabot>   True
13:06:55 <JoeyA> I'm building up to a question, hang on :-)
13:06:59 <conal> JoeyA: try liftA2 
13:07:05 <ddarius> :t after
13:07:05 <lambdabot> forall source. (Extract source) => Int -> source -> source
13:07:14 <mauke> sizzler: Ptr CInt, not Ptr Int
13:07:14 <conal> JoeyA: (twice)
13:07:51 <conal> JoeyA: that itemAfter def can almost disappear
13:08:17 <mauke> sizzler: why is SDLayerDisplay a ForeignPtr, not a Ptr?
13:08:23 <conal> result.result (or fmap.fmap) will help also
13:08:26 <sizzler> k is the data and type decls fine.'
13:08:33 <ddarius> :t on
13:08:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:08:43 <Veinor> > let itemAfter a b [] = False; itemAfter a b (b:xs) = a `elem` xs; itemAfter a b (x:xs) = itemAfter a b xs in itemAfter 7 3 [1..9]
13:08:44 <lambdabot>   Conflicting definitions for `b'
13:08:44 <lambdabot>  In the definition of `itemAfter'
13:08:57 * ManateeLazyCat http://farm5.static.flickr.com/4037/4672133763_1468157220_b.jpg my Google homepage. :)
13:09:04 <JoeyA> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') "aeiouy"
13:09:05 <copumpkin> @@ @djinn @typo on
13:09:05 <lambdabot> Plugin `compose' failed with: Unknown command: "typo"
13:09:05 <lambdabot>   Overlapping instances for GHC.Show.Show
13:09:05 <lambdabot>                              ([GHC....
13:09:12 <copumpkin> @@ @djinn @type on
13:09:13 <lambdabot>  f a b c _ = a (b c) (b c)
13:09:17 <JoeyA> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') "aeiouy" $ alphabet
13:09:18 <lambdabot>   "iouy"
13:09:18 <copumpkin> aww
13:09:20 <aavogt> Veinor: well the TypeCast constraints sort of stop you from using non-string type variables apparently
13:09:26 <copumpkin> it doesn't do edit distance for composed commands?
13:09:51 <Veinor> oh, derp
13:10:23 <Veinor> > let itemAfter a b [] = False; itemAfter a b (x:xs) | x == b =  a lemxs | otherwise = itemAfter a b xs in itemAfter 7 3 [1..9]
13:10:23 <lambdabot>   Not in scope: `lemxs'
13:10:43 <Veinor> > let itemAfter a b [] = False; itemAfter a b (x:xs) | x == b =  a `elem` xs | otherwise = itemAfter a b xs in itemAfter 7 3 [1..9]
13:10:44 <lambdabot>   True
13:10:49 <JoeyA> let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') (something else using alphabet) $ alphabet
13:11:11 <sizzler> mauke I have pasted the struct which the function returns as a pointer to
13:11:26 <mauke> sizzler: cool story, bro
13:12:11 <Veinor> JoeyA: why are you using filterM?
13:12:19 <JoeyA> Monad m => I'm trying to use filterM like (b -> m Bool) -> m [b] -> m [b] rather than (b -> m Bool) -> [b] -> m [b]
13:12:21 <Veinor> actually
13:12:29 <JoeyA> good question :)
13:12:43 <sizzler> should I be defining the struct also using FFI macros
13:12:49 <mauke> sizzler: irrelevant
13:12:51 <mauke> sizzler: why is SDLayerDisplay a ForeignPtr, not a Ptr?
13:13:11 <JoeyA> Well actually, I want the filter function to be applied to my function as well as the expression for the input list.
13:13:17 <Veinor> > let itemAfter a b list = a `elem` dropWhile (/= b) list in filter (`itemAfter` 'e') "aeiouy"
13:13:18 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:13:18 <lambdabot>         against inferred type ...
13:13:27 <Veinor> > let itemAfter a b list = a `elem` (dropWhile (/= b) list) in filter (`itemAfter` 'e') "aeiouy"
13:13:28 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:13:28 <lambdabot>         against inferred type ...
13:13:43 <Veinor> > let itemAfter a b list = a `elem` (dropWhile (/= b) list) in filter (`itemAfter` 'e') "aeiouy" $ "aeiouy"
13:13:43 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:13:43 <lambdabot>         against inferred type ...
13:13:46 <Veinor> blah
13:13:47 <Veinor> screw it
13:14:09 <JoeyA> I'm using itemAfter as part of a larger question
13:14:19 <sizzler> mauke after fixing the Ptr Cint and Ptr for the struct it compiles now
13:14:24 <JoeyA> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') "aeiouy" $ alphabet
13:14:25 <lambdabot>   "iouy"
13:14:28 <Veinor> well you can use my definition I think
13:14:32 <mauke> that doesn't really answer my question
13:14:51 <JoeyA> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') (reverse alphabet) $ alphabet
13:14:52 <lambdabot>   "zyxwvutsrqponmlkjihgf"
13:14:57 <sizzler> well I dont understand what ForeignPtr is then
13:15:19 <JoeyA> okay, now my goal is to get rid of the mention of alphabet for reverse
13:15:28 <JoeyA> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') <$> reverse $ alphabet
13:15:28 <lambdabot>   Overlapping instances for GHC.Show.Show
13:15:28 <lambdabot>                              ([GHC....
13:15:43 <mauke> sizzler: a wrapper around a pointer to which you can attach finalizers
13:15:50 <mauke> for automatic cleanup
13:15:51 <Veinor> @pl \x -> f z x $ x
13:15:51 <lambdabot> join (f z)
13:16:05 <dmwit> ?pl \x -> f z (g x) $ x
13:16:05 <lambdabot> f z =<< g
13:16:35 <Veinor> > let alphabet = ['a'..'z'] in join (filterM $ `itemAfter` 'e') "aeiouy"
13:16:36 <lambdabot>   <no location info>: parse error on input ``'
13:16:45 <sizzler> ok I havent yet thought how to release these
13:17:00 <dmwit> > let alphabet = ['a'..'z'] in filterM (`itemAfter` 'e') =<< reverse $ alphabet
13:17:01 <lambdabot>   "zyxwvutsrqponmlkjihgf"
13:17:19 <Veinor> > let alphabet = ['a'..'z'] in join (filterM (`itemAfter` 'e')) alphabet
13:17:20 <lambdabot>   "fghijklmnopqrstuvwxyz"
13:17:25 <Veinor> monads!
13:17:37 <mauke> fucking monads, how do they work
13:17:47 <Veinor> a monad is like clown paint
13:17:50 <Veinor> on your face
13:17:52 <dmwit> I don't wanna talk to no category theorist...
13:17:52 <sizzler> the surfaces held in the struct will have to be released similar to how they do in http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/src/Graphics-UI-SDL-Video.html#createRGBSurface
13:18:36 <Veinor> faygo is actually not bad :/
13:18:38 <JoeyA> Does anyone feel like monads are like the Green Glass Doors?
13:18:50 <ddarius> JoeyA: No.
13:18:54 <JoeyA> It seems like nobody ever really tells you what they are, they just show you examples.
13:19:03 <JoeyA> Monads are not behind the Green Glass Doors, btw.
13:19:17 <ddarius> JoeyA: Plenty of people say what they are and then people say they want examples instead.
13:19:24 <mauke> JoeyA: class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
13:19:28 <mauke> that's what monads are
13:19:30 <Veinor> @quote endofunctors
13:19:30 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
13:19:44 <Veinor> mauke: you forgot the laws!
13:19:55 <mauke> I'm a rebel
13:19:59 * Veinor gasps
13:20:08 <JoeyA> What I mean is, when someone gives a definition, it doesn't really tell you "what they are".
13:20:10 <Veinor> you're a loose cannon, mauke! hand in your . key!
13:20:15 <mauke> JoeyA: yes, it does
13:20:21 <ddarius> JoeyA: Yes, it does.
13:20:30 <mauke> it's just useless
13:20:35 <ddarius> mauke: No it isn't.
13:20:49 <JoeyA> For instance, a sandwich is a type of food with meat between two slices of bread.
13:20:56 <JoeyA> Here, it's obvious what you can do with it:  eat it!
13:21:05 <Veinor> put it on your head... I mean eat it
13:21:10 <copumpkin> only because you have enough experience to know that
13:21:11 <mauke> with a monad, you can call return and (>>=)
13:21:14 <JoeyA> With monad definitions, it doesn't quite give you an idea what they're for.
13:21:23 <mauke> says so right in the definition
13:21:24 <JoeyA> What benefit you get out of them.
13:21:28 <Peaker> JoeyA, It isn't obvious to a visiting alien -- if it was meant for eating, why the peculiar arrangement? He would have to think some.  With monads, you might have to think a bit more
13:21:29 <mauke> irrelevant
13:21:32 <aavogt> because it's not as limiting as food
13:21:33 <copumpkin> JoeyA: what does "for" mean?
13:21:34 <ddarius> JoeyA: "What are they for?" is a different question than "What are they?"
13:21:49 <JoeyA> Nevermind :P
13:22:04 <copumpkin> most people aren't used to thinking on that level of abstraction
13:22:13 <copumpkin> i.e., ur dum, giv up nao
13:22:18 <JoeyA> lol
13:22:33 <JoeyA> I'm understanding them better by applying them
13:22:56 <ddarius> JoeyA: There are plenty of examples of people providing definitions, plenty of examples of people saying what monads are "for", and plenty of examples of people providing examples.
13:23:02 <JoeyA> For instance, I think I "get" the concept that you can use a monad to defer application of a function, then "let it loose" when you've defined what you want to do with it.
13:23:21 <aavogt> defer?
13:23:49 <copumpkin> @typo liftM2 (+) (5+) (^3) -- there, 5+ and ^3 are deferred
13:23:50 <lambdabot> forall a1. (Num a1) => a1 -> a1
13:23:52 <JoeyA> As in, pretend you don't have to apply a particular argument
13:23:52 <Peaker> JoeyA, The idea is simply that a mathematical structure re-appears in different contexts.  It is useful to "capture" that structure so that anything that only depends on that structure can work on any of those instances..  The structure itself tells you little
13:23:56 <JoeyA> (until the end)
13:24:15 <Peaker> JoeyA, Do you understand Applicative?
13:24:17 <aavogt> monad zoos
13:24:29 <ddarius> JoeyA: I think you are describing the reader monad which is but one example of a monad.
13:24:36 <JoeyA> Peaker: I'm not quite there yet.
13:24:45 <Peaker> JoeyA, I think you should be there before you're at Monads :)
13:24:57 <Peaker> JoeyA, Also, it might be better to "invent" monads yourself when you see code duplication
13:24:59 <JoeyA> Well, maybe I don't give myself enough credit.
13:25:01 <copumpkin> I'd start with Maybe, myself
13:25:13 <JoeyA> When I need to use it, it'll make more sense.
13:25:14 <copumpkin> it's bite-sized
13:25:17 <aavogt> or you might not
13:25:23 <Peaker> JoeyA, If you write a lot of code involving Maybe, you'll find out that there's a really useful combinator for Maybe's  (Maybe a -> (a -> Maybe b) -> Maybe b)
13:25:57 <JoeyA> Is that the maybe function
13:25:58 <JoeyA> ?
13:26:04 <ddarius> JoeyA: No
13:26:18 <Peaker> JoeyA, or perhaps you instead use the combinator: Maybe (Maybe a) -> Maybe a   along with   (a -> b) -> Maybe a -> Maybe b  -- they both cover the same grounds
13:26:46 <aavogt> where was that blog with funny names for those functions?
13:26:46 <Peaker> JoeyA, (Maybe a -> (a -> Maybe b) -> Maybe b)   is (>>=) :: m a -> (a -> m b) -> m b   where m=Maybe
13:26:47 <JoeyA> @pl \x -> f (g j) (+ j) (h x) $ x
13:26:48 <lambdabot> f (g j) (j +) =<< h
13:27:01 <JoeyA> @src filterM
13:27:01 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:27:12 <Peaker> JoeyA, And  (a -> b) -> Maybe a -> Maybe b   is just fmap :: (a -> b) -> f a -> f b   where f = Maybe   and  Maybe (Maybe a) -> Maybe a   is just join :: m (m a) -> m a
13:27:24 <aavogt> supposedly to practice writing each of those in terms of eachother
13:27:31 <Peaker> JoeyA, I think it is better to go from the concrete examples to the abstraction than the other way around
13:27:48 <JoeyA> Peaker: I agree
13:27:59 <conal> JoeyA: if you want to grok Monad, don't start with Monad.  too much magical thinking has accumulated around it.  start with Monoid.  then Functor & Applicative.  and only then Monad, and you'll find there's nothing mysterious about it.
13:28:00 <aavogt> if you have to think through them yourself, perhaps you're more likely to 'understand'
13:28:02 <JoeyA> And I have been using >>= more and more in lay contexts.
13:28:35 <Peaker> JoeyA, so maybe given  xmlLookup :: String -> Element -> Maybe Element ; try to write a function that gets a grand-child at "a" "b".  Then try to write another one where you get [Element] instead of Maybe Element
13:28:49 <JoeyA> @pl \x -> f (+ j) (g x) $ x
13:28:49 <lambdabot> f (j +) =<< g
13:28:52 <Peaker> JoeyA, Then see what kind of code sharing you might want to do
13:30:19 * ddarius thinks Kleisli composition is more likely to be arrived at before (>>=) is.
13:30:35 <hpc> :t (>=>)
13:30:36 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:30:42 <copumpkin> it's so much prettier than >>=
13:31:12 <monochrom> there is no "understand". it is just a subjective feeling.
13:32:13 <Peaker> copumpkin, can you build (>>=) from (>=>) as you can vice versa?
13:32:17 <ddarius> monochrom: It (usually) correlates with some more objective measures.
13:32:24 <copumpkin> Peaker: yeah, with an undefined value
13:32:28 <conal> Monad always rubbed me the wrong way, and I didn't understand why until i saw (=<<).  i wonder if (=<<) got perverted into (>>=) in order to mimic imperative programming more closely.
13:32:33 <copumpkin> Peaker: or something that doesn't get used
13:32:55 <Peaker> copumpkin, "with undefined", anything can be implemented in terms of anything :)
13:33:01 <copumpkin> :t (>=>, >>=)
13:33:02 <lambdabot> parse error on input `,'
13:33:08 <ddarius> conal: I'm pretty sure (>>=) was specifically chosen to support a "flat" looking style.
13:33:10 <copumpkin> :t ((>=>), (>>=))
13:33:10 <jethr0> Peaker: at least on the type level ;)
13:33:11 <lambdabot> forall a (m :: * -> *) b c (m1 :: * -> *) a1 b1. (Monad m, Monad m1) => ((a -> m b) -> (b -> m c) -> a -> m c, m1 a1 -> (a1 -> m1 b1) -> m1 b1)
13:34:31 <hpc> =<< has some nice similarities with $
13:35:12 <conal> it's the partial application of (=<<) that was the epiphany for me.
13:35:13 <ddarius> hpc: Indeed.  In more mathematical texts, (f =<<) is usually written f^*, i.e. it is viewed as "extending" a function a -> m b into a function m a -> m b.
13:36:04 <Peaker> @type (=<<)
13:36:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:37:19 <hpc> :t fmap
13:37:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:37:24 <hpc> :t (f =<<)
13:37:25 <lambdabot> forall a (m :: * -> *) b. (Show a, SimpleReflect.FromExpr (m b), Monad m) => m a -> m b
13:37:31 <ddarius> However, I think there is a very good reason why ap is "ap" and (>>=) is called "bind."  Or to shift the emphasis, why "(>>=)" or "(=<<)" is NOT called a "monadic application."
13:37:45 <hpc> :t (f `fmap`)
13:37:46 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f) => f a -> f b
13:38:09 <JoeyA> I've been writing my own topology library for fun, and I (with the help of @pl) wrote this function:
13:38:11 <JoeyA> parents graph j = (do indices <- graphIndices; filterM (--> j) indices) $ graph
13:38:23 <JoeyA> Now, I know I can use >>= here instead.
13:38:49 <JoeyA> I'm seeing a pattern here:  I wrote an operator --> that sees if two indices on the graph are connected.  You use it like:
13:38:50 <ddarius> @undo do indices <- graphIndices; filterM (--> j) indices
13:38:50 <lambdabot> Unbalanced parentheses
13:38:52 <JoeyA> (i --> j)
13:38:57 <JoeyA> err:
13:39:00 <JoeyA> (i --> j) graph
13:39:32 <hpc> :t (-->)
13:39:33 <lambdabot> parse error (possibly incorrect indentation)
13:39:43 <JoeyA> and I'm seeing how monad trickery lets me not have to provide the graph as an argument all over the place
13:39:45 <hpc> @src (-->)
13:39:45 <lambdabot> Source not found. Sorry.
13:40:04 <hpc> what's (i --> j)?
13:40:14 <ClaudiusMaximus> so i've started a project with SVG/Javascript, and I want to port it to OpenGL/Haskell for various reasons - but the algorithms have lots of mutable state, and I'm not really sure how to go about it - anyone fancy taking a look at the svg/js code and offering some advice?
13:40:30 <JoeyA> (i --> j) graph is a custom operator for seeing if two indices on a graph are connected.
13:40:38 <hpc> nice
13:41:12 <JoeyA> And monads make it so I can say filterM (--> j) rather than having to do something funky like filter (\x -> (x --> j) graph)
13:42:35 <ddarius> JoeyA: All of this is using one particular monad.
13:42:40 <JoeyA> I have a bunch of functions that take a graph argument.  Now I'm wondering if I should make a Graph monad or something so I can write transformations more easily.
13:42:58 <JoeyA> and if I do, how do I avoid mixing it up with the Graph type?
13:43:01 <JoeyA> make a GraphM ?
13:43:42 <JoeyA> or if I should just stick to the function (applicative?) monad.
13:44:49 <hpc> :t (<*>)
13:44:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:46:01 <hpc> :t ((>>=) . return $ id)
13:46:01 <lambdabot> forall (m :: * -> *) b a. (Monad m) => ((a -> a) -> m b) -> m b
13:46:20 <JoeyA> Is there a way to flip this around?  (+ 3) $ 5 
13:46:27 <JoeyA> e.g. 5 <*> (+ 3), but that doesn't work.
13:47:08 <Polarina> Can I use GHC 6.12.1 on OpenBSD?
13:47:55 <ClaudiusMaximus> > let (£) = flip ($) in 5 £ (+ 3)
13:47:55 <lambdabot>   8
13:48:14 <BMeph> JoeyA: ...you DO know that you can write your own functions, don't you? :)
13:48:29 <JoeyA> Yes
13:48:49 <BONUS> > flip id 5 (+3)
13:48:49 <lambdabot>   8
13:48:56 <hpc> 5 $> (+3)
13:49:02 <hpc> > 5 $> (+3)
13:49:02 <lambdabot>   Not in scope: `$>'
13:49:47 <BMeph> JoeyA: So, tell us what you "Really" want to know... ;)
13:50:12 <ClaudiusMaximus> anyway the unfinished svg/js version is here, don't really know the best way to port it to haskell because of the heavy usage of mutable data structures.. http://claudiusmaximus.goto10.org/g/kjhf/kjhf.svg?code=+[[^\%3E+^%3C/+]+[^/%3C+^%3E\+]+^+]
13:50:41 <deech> Hi all, just wanted to let someone know that messages I sent to beginners@haskell.org and haskell-cafe@haskell.org bounced back today. 
13:50:50 <BONUS> interesting observation: if you have a CPS-ized list like of the type (a -> r -> r) -> r -> r, you can do appends in O(1)
13:50:55 <dv-> Polarina: yes
13:50:57 <BONUS> deech: yeah the mailing lists are down
13:51:00 <Veinor> pirate lists.
13:51:02 <dv-> Polarina: it's in -current
13:51:13 <Veinor> arrrr
13:51:39 <deech> BONUS: Ok, thanks! 
13:52:41 <JoeyA> BMeph: I think I know what I need to know for now. :)
13:53:18 <BMeph> JoeyA: Okay, as long as you think you've figured out the answer to the one which you didn't ask... ;)
13:53:52 <BMeph> JoeyA: The Question, that is. :)
13:54:19 <BONUS> > let append l r c e = l c (r c e) in append (\c e -> c 3 (c 4 (c 5 e))) (\c e -> c 6 (c 7 e)) (:) []
13:54:19 <lambdabot>   [3,4,5,6,7]
13:56:39 <BONUS> @pl (\l r c e -> l c (r c e))
13:56:39 <lambdabot> liftM2 (.)
13:56:57 <BONUS> tres interessant
14:00:04 <djahandarie> liftM2 is so common, I wish it were nicer to type/look at.
14:00:07 <blueonyx> why is haskell.org down? :(
14:00:26 <copumpkin> blueonyx: EVIL HAX0RZ
14:00:27 <ezyang> djahandarie: f <$> a <*> b 
14:00:28 <djahandarie> The machine it was hosted off of was taken down (comprimised?)
14:00:29 <Veinor> :t liftM2 (.)
14:00:30 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
14:01:10 <blueonyx> @hoogle request
14:01:10 <lambdabot> Network.Browser request :: HStream ty => Request ty -> BrowserAction (HandleStream ty) (URI, Response ty)
14:01:11 <lambdabot> Network.HTTP.Base data Request a
14:01:11 <lambdabot> Network.HTTP.Base Request :: URI -> RequestMethod -> [Header] -> a -> Request a
14:01:18 <djahandarie> :t (\f a b -> f <$> a <*> b)
14:01:19 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
14:01:48 <djahandarie> :t (\f a b -> f <$> a <*> b) (.)
14:01:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f (a -> b) -> f (f1 a) -> f (f1 b)
14:02:19 <BMeph> @ty liftM2 (Prelude..)
14:02:20 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
14:02:21 <BONUS> if you're not in caleskell, liftM2 (.) has a type of liftM2 (.) :: (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
14:02:29 <djahandarie> Yeah
14:02:48 <benmachine> type liftA2, that's much more pleasant
14:02:48 <BMeph> BONUS: Jinx! ;)
14:02:59 <BONUS> haha
14:03:20 <BONUS> yeah i prefer liftA2, but sometimes monads don't have applicative instances :\
14:03:23 <BONUS> when they should
14:03:25 <BONUS> like ST
14:07:56 <BMeph> BONUS: Which ST do you want? ;)
14:07:58 <tensorpudding> instance Applicative Foonad where pure = return, <*> = ap, was that so hard....
14:08:18 <BONUS> BMeph: all of them!
14:08:51 <BONUS> tensorpudding: well but it would be so nicer if those instances were already there
14:08:54 <BMeph> BONUS: "I'm sorry, Dave, but I cannot comply with your request." ;)
14:09:21 <tensorpudding> Yeah, I'm saying "if you define a Monad instance, you're just being lazy if you don't do Applicative too"
14:09:33 <BONUS> ah, yeah
14:09:51 <BONUS> i usually define functor, then monad, and then applicative by way of pure = return and <*> = ap
14:09:57 <benmachine> you're just being lazy by not seeing into the future and determining the class methods of things that don't exist yet
14:10:40 <BMeph> benmachine: You had me at "you're just being lazy..." ;)
14:10:50 <benmachine> :P
14:11:09 <benmachine> but I guess there's no good reason why the Applicative module doesn't define an instnace
14:11:12 <benmachine> tnace? tance
14:11:20 <benmachine> for stuff in the stdlib
14:11:26 <JoeyA> since haskell.org is down, looks like I have to type this in front of 641 people...
14:11:28 <JoeyA> @hoogle children
14:11:28 <lambdabot> No results found
14:11:53 <benmachine> children of what
14:12:04 <jethr0>  "/msg lambdabot" is your friend
14:12:10 <Veinor> that too.
14:12:23 <Starfire> @pl (\f a b c -> f c a b)
14:12:23 <lambdabot> (flip .) . flip
14:12:43 <benmachine> hayoo isn't hosted on haskell.org is it?
14:12:46 <jethr0> JoeyA: *bah*, of those 642 only about 20 are mentally present ;)
14:12:55 <benmachine> oh, it does 500 though
14:13:15 <BMeph> jethr0: Define "mentally". ;)
14:13:58 <copumpkin> > length (permutations [1..5])
14:13:59 <lambdabot>   120
14:14:00 * gwern and 100 minions watch JoeyA intently. and judge. oh how we judge
14:14:07 <jethr0> adverb of mental. http://www.urbandictionary.com/define.php?term=mental
14:14:15 <Veinor> @src permutations
14:14:15 <lambdabot> Source not found.
14:14:29 <benmachine> jethr0: "mental" as in slang usage?
14:14:45 <jethr0> never mind *gg*
14:15:05 <benmachine> :)
14:15:24 <benmachine> "when something is absolutely insane, or just down right gnar." -- thanks urbandictionary!
14:15:30 <benmachine> I feel enlightened
14:16:28 <benmachine> I wonder if I climbed more would I have more finger strength and thus fewer RSI
14:16:44 <benmachine> where more = more than zero
14:17:19 <jethr0> if you need significant finger strength for typing, your doing sth. very wrong. Or are you on a typewriter?
14:17:32 <benmachine> could be!
14:17:43 <benmachine> but strength gives you bone support and stuff
14:17:45 <benmachine> and stamina
14:22:25 <Cale> Perhaps a Model M? :)
14:22:43 <aristid> Cale: cale.yi.org is down!
14:23:01 <Cale> oh, is it?
14:23:10 <aristid> it seems to be.
14:23:21 <Cale> oh, I see
14:23:29 <Cale> Stupid router is stupid
14:23:51 <Cale> It randomly assigns internal IPs despite making port forwarding based on that.
14:24:11 <Cale> Well, not quite random. I think it just assigns them sequentially.
14:24:24 <Cale> So whenever we have a power outage, I can be irritated.
14:24:30 <tensorpudding> Can't you configure it to give static IP's?
14:24:37 <Cale> Apparently not.
14:26:06 <aristid> Cale: is it on your desktop box?
14:26:07 <tensorpudding> What kind of router is this?
14:26:34 <BONUS> hmm, is appending cpsized lists of type (a -> r -> r) -> r -> r really done in O(1) time? 
14:26:50 <aristid> Cale_: works again
14:26:54 <Cale_> good
14:28:46 <vermin_slam> frac, i can't finish my code; i keep seeing higher order abstractions and i can't stop going after them ...
14:29:01 <BONUS> vermin_slam: it's abstractions all the way down
14:29:16 <Cale> BONUS: well, it would just be  xs ++ ys = (\cons nil -> xs cons (ys cons nil)), right?
14:29:18 <monochrom> or all the way up
14:29:21 <Cale> That looks constant time to me.
14:29:37 <BONUS> Cale: yeah
14:30:10 <BONUS> but is that gotten for free or is there some kind of trade-off that i'm not seeing
14:30:51 <Cale> The trade off is having to evaluate the application of those functions to various parameters over and over.
14:30:59 <jethr0> few things lower bound O-notation are for free ;)
14:31:23 <gwern> there ain't no free lunch
14:31:44 <gwern> you pay for performance by either shifting the slowness elsewhere, or by de-generalizing
14:32:44 <Cale> That's not always true. Sometimes things are just less efficient than they have to be.
14:33:26 <Oejet> gwern: That's a nice term for (certain classes of) "optimization": Degeneralization.
14:33:43 <gwern> Oejet: is it? it seem quite ugly to me
14:34:25 <BONUS> intuitively i see some parallels with this to difference lists
14:34:56 <BONUS> (\cons nil -> xs cons (ys cons nil)) = liftA2 (.)
14:34:57 <ddarius> xs ++ ys = \cons -> xs cons . ys cons
14:35:11 <BONUS> ah, yeah
14:35:39 <BMeph> I.e., it's a monoid transform.
14:35:41 <Oejet> gwern: I think so. It tells you more than just the word optimization.
14:36:10 <gwern> Oejet: true, 'optimization' embraces both being less stupid like Cale says, shifting complexity around, and degeneralization
14:36:17 <djahandarie> @pl (\x y -> (x . ) . y)
14:36:17 <lambdabot> (.) . (.)
14:36:22 <djahandarie> Oh, right
14:36:32 <gwern> but maybe there's a better term for degeneralization. 'deabstracted'?
14:36:45 <aavogt> {-# SPECIALIZE #-}
14:37:03 <gwern> hm, specialize might work too
14:37:22 <gwern> yes, I think that's much better than degeneralized
14:39:04 <djahandarie> Does anyone ever let ... = (.) . (.) in their code?
14:39:42 <Oejet> gwern: Optimization is used about things which are not giving an optimum, but just some improvement. Do you have a better word for optimization too?
14:40:17 <monochrom> deslowization
14:40:30 <BONUS> > let .. = (.) . (.) in (show .. (+)) 3 2
14:40:31 <lambdabot>   <no location info>: parse error on input `..'
14:40:38 <jethr0> djahandarie: personally, I find it hard to decipher. but I'm sure there are some "advanced" users in here that like points-free style
14:41:09 <aristid> > let (..) = (.).(.) in (show .. (+)) 3 2
14:41:10 <lambdabot>   <no location info>: parse error on input `..'
14:41:10 <jethr0> hmm, those air quotes sounded more sarcastic than they were meant *hmm*
14:41:11 <monochrom> (.).(.) is a bit extreme
14:41:12 <ddarius> BONUS: let + = ... is a syntax error, and similarly for all other operators.  Furthermore, .. is a reserved operator.
14:41:23 <BONUS> i like let result = (.), but i don't like points-free golfing otherwise (except on #haskell)
14:41:35 <BONUS> ddarius: of course, agh :) my brain is malfunctioning
14:41:52 <ddarius> Some people use (.:)
14:41:54 <aristid> BONUS: i think point-free is good when it reduces complexity
14:42:09 <BONUS> aristid: yeah me too, i use it when it comes naturally
14:42:12 <gwern> Oejet: 'optimizing'
14:42:19 <aristid> f = a . b is more readable than f x = a (b x)
14:42:21 <BONUS> like with foo = f . g . h x . z
14:42:23 <BONUS> yeah
14:42:25 <jethr0> point-free should be easily readable by the target audience!
14:42:28 * ddarius thinks most people in #haskell have no idea what the purpose of "point-free" code is.
14:42:35 <BMeph> BONUS: Technically, isn't "result = (.)" sort-of anti-golfing? :)
14:43:01 <jethr0> I would except simple concatenation which I use a lot. But I find stuff like "(.) . (.)" tough to read. Could be only me though
14:43:14 <gwern> ddarius: I don't really. I mean, it doesn't change the type...
14:43:19 <BONUS> BMeph: yeah, that's a nice way of putting it
14:43:57 <BMeph> BONUS: "Obfuscation through sesquipedalianization"? ;)
14:44:07 <BONUS> haha
14:44:09 <Oejet> gwern: Does that word really mean "the process of moving a bit toward and optimum"?
14:44:19 <gwern> Oejet: sure. like 'traveling' versus 'traveled'
14:44:34 <gwern> Oejet: if you are traveling, then you are not there yet. if you have traveled, then you're done.
14:45:00 <BMeph> Oejet: See: "perfecting" versus "perfected". :)
14:45:18 <gwern> zacklee
14:46:34 <Veinor> @unpl (.) . (.)
14:46:34 <lambdabot> (\ i b c f -> i (b c f))
14:46:47 <Oejet> gwern: Ah, okay. But it still has something to do with optimal/optimum, which optimizing almost never achieves.
14:47:16 <gwern> Oejet: we get asymptotically optimal structures all the time
14:47:45 * BMeph has yet to see the perfecting process that achieves perfection...
14:49:27 <Oejet> gwern: Heh, which may or may not give an improvement in running time.
14:49:46 <djahandarie> I'd like h = f ... g more than h = (f .) . g or h a b = f (g a b)
14:49:48 <Oejet> For a given workload.
14:55:06 <BMeph> djahandarie: h = f .: g ? ;)
15:10:03 <Twey> h = fmap f . g
15:11:03 * copumpkin just wrote permutations : ∀ {n} {A : Set} → Vec A n → Vec (Vec A n) (n !)
15:11:14 <Twey> In Haskell?!  :þ
15:11:29 <copumpkin> nope :P
15:11:35 <Twey> What's that, Agda?
15:11:40 <copumpkin> yep
15:11:54 <ddarius> copumpkin: That type is woeful.
15:12:00 <Twey> Dependent types look pretty nifty.  I want them in a real programming language.  ☹
15:12:04 <copumpkin> hey, it provides plenty of information
15:12:18 * copumpkin actually just updated it to permutations : ∀ {n a} {A : Set a} → Vec A n → Vec (Vec A n) (n !)
15:12:27 <copumpkin> might as well make it fully polymorphic
15:12:29 <ddarius> copumpkin: permutations vs = replicate n! vs
15:12:43 <copumpkin> ddarius: oh, I'll prove something about it eventually
15:12:51 <copumpkin> haven't decided what I'm after yet though
15:13:38 <ddarius> copumpkin: The question is what statement of the property is most useful to users.
15:13:47 <copumpkin> yeah...
15:14:07 <copumpkin> I'm trying to think of any statement of the property at all
15:14:17 <ddarius> copumpkin: For example, one statement is simply that there are no duplicates which (through external reasoning we know) implies that we have all the permutations.
15:14:25 <copumpkin> yeah
15:14:32 <copumpkin> hmm
15:14:33 <ddarius> However, that leaves a lot of reasoning upon the users.
15:14:43 <copumpkin> it could be a useful property for someone
15:14:45 <copumpkin> I'll state it for now
15:14:52 <copumpkin> and think of what else
15:14:58 <safiire> I am using osx.  I am trying to compile a C project in Xcode/gcc that is calling functions i have written in haskell.  I have linked it to the nessessary .a files found in the haskell framework so it is able to find those symbols.  However, I can't seem to make it find some symbols related to iconv.  Can anyone help me figure out why?
15:15:34 <ddarius> copumpkin: Well one is to follow the structure of the (likely) implementation and have an induction on the size of the vector.
15:16:04 <copumpkin> ddarius: what would I be stating?
15:16:46 <ddarius> copumpkin: For each element of the input vector you have that element consed on to every permutation of the remainder of the vector.
15:17:00 <copumpkin> oh okay
15:17:04 <copumpkin> yeah, that's pretty much the implementation
15:17:22 <copumpkin> I'm using the selections function behind the scenes
15:17:32 <copumpkin> selections : ∀ {n a} {A : Set a} → Vec A (suc n) → Vec (A × Vec A n) (suc n)
15:18:07 <safiire> Does anyone know why haskell.org is not online?  I was following some instructions found there, but now it is offline.
15:18:53 <ddarius> Why is xmonad 0.9 broken?
15:22:59 <safiire> Ok, well thanks for all your help :)
15:24:23 <BONUS> safiire: it's offline because something, but yeah, it's offline atm
15:25:01 <dmwit> > 275.4 / 9.3
15:25:02 <lambdabot>   29.61290322580645
15:26:24 <dmwit> pretty good mileage for a 25-year-old car
15:26:38 <andrewsw> woo... that is good.
15:27:41 <Twey> Hmm
15:27:51 <byorgey> that's kilometers per barrel?
15:27:58 <Twey> Clojure vs. Scala: which one is less horrible from the perspective of a Haskeller?  :-\
15:28:15 <jlouis> Twey: Scala i'd say
15:28:25 <copumpkin> me too, but it has horrible syntax
15:28:33 <copumpkin> clojure seems a bit more immutable-minded from what I hear
15:28:39 <jlouis> perhaps
15:28:46 <Twey> copumpkin: So why do you say Scala?
15:28:51 <copumpkin> types
15:28:52 <Twey> Doesn't that make Clojure more Haskelly?
15:28:53 <jlouis> Static typing!
15:28:59 <Twey> Oh, Clojure is dynamic?
15:29:00 <jlouis> **5's copumpkin 
15:29:05 <copumpkin> :D
15:29:09 <Twey> Hehe
15:29:36 <jlouis> now, since I hack Erlang on a regular basis, I can't claim to hate dynamic typing
15:29:56 <jlouis> but still, quite many bugs would have been naturally caught by the checker, had Erlang had it
15:30:49 <Twey> Yeah
15:31:04 <Twey> OTOH, types aside, Clojure looks much nicer than Scala from what I've seen
15:31:09 <Twey> And I do love my Lisps
15:31:10 <jlouis> true
15:31:24 <ddarius> There's Dialyzer and other tools...
15:31:28 <jlouis> There is basically no language out there I am entirely happy with
15:31:35 <Jason9> ehello
15:31:40 <ddarius> jlouis: The typical response then is to make your own.
15:31:44 <Twey> Yeah
15:31:46 <Jason9> does any one in here good at java
15:31:48 <jlouis> My main Haskell gripe is lazy evaluation
15:31:52 <copumpkin> or wait for my amazing language
15:31:56 <copumpkin> Jason9: ##java
15:32:02 <Jason9> do you know how i could find a median
15:32:07 <Twey> I was just trying to decide on a language for programming Android, since I can't have my Haskell
15:32:10 <Jason9> of an array in java
15:32:12 <jlouis> Jason9: try the ##java channel
15:32:21 <monochrom> perhaps this is why people talk of "internal language". because "languages out there" are never good enough.
15:32:22 <Jason9> how do i get there
15:32:27 <Twey> Jason9: Sum and divide by length, same as in any language.
15:32:29 <RyanT5000> Twey: my company's beginning work on ghc-android now :)
15:32:33 <Jason9> haha
15:32:37 <Twey> Jason9: /join ##java
15:32:38 <Jason9> well i need more help than that
15:32:43 <Jason9> Thank you Twey
15:32:47 <Twey> Jason9: /msg chanserv help register
15:32:47 <ddarius> Twey: Median /= mean.
15:32:49 <copumpkin> lol
15:32:49 <burp> that's not the median
15:32:52 <Twey> Jason9: ^ in case you get kicked out
15:32:56 <Twey> ddarius: Oh yeah.  Haha.
15:33:17 <Twey> Sorry, brain-fart.
15:33:18 <burp> take element: length of list / 2
15:33:24 <Twey> Nah
15:33:29 <Twey> Need to handle the even case
15:33:32 <Jason9> how do i add up the elements
15:33:35 <copumpkin> agda needs to be smarter
15:33:35 <jlouis> burp: not if there is an even number of elems
15:33:43 <monochrom> you should use a fold
15:33:45 <ddarius> copumpkin: Why?
15:33:51 <jlouis> Jason9: do you know what the median is?
15:33:52 <burp> ah, who likes even numbered lists anyway :P
15:34:05 <Jason9> http://pastie.org/993340
15:34:06 <Twey> arr.slice(floor(arr.length), ceil(arr.length)).mean()
15:34:19 <Twey> (yay, pseudocode)
15:34:29 <ddarius> Twey: + /2
15:34:33 <Jason9> here is my code it is under Print array
15:34:35 <Jason9> method
15:34:38 <Twey> ddarius: That's handled by the ‘.mean()’
15:34:49 <ddarius> Twey: No, I mean length/2
15:34:55 <Twey> Oh!
15:34:58 <Twey> Right, yeah.
15:35:03 <Jason9> can some one seriously help me
15:35:10 <Jason9> http://pastie.org/993340
15:35:11 <Twey> I'm going to shut up and go and learn Clojure now :þ
15:35:16 <Philonous> Why do you assume the array is sorted?
15:35:18 <Twey> RyanT5000: Looking forward to that, though ☺
15:35:21 <copumpkin> ddarius: well, my permutations function returns a Vec of length (n !) which is defined in the simplest way possible (fac 0 = 1, fac (s n) = s n * fac n), and selections wants a Vec of length (suc n) for any n (so at least 1). It can't unify n ! with suc n even though across all cases it could see that it's always suc n
15:35:22 <Jason9> yes
15:35:26 <ddarius> Jason9: Yes, the #java channel.  You can get there presumably the same way you got here only putting "java" where you had "haskell"
15:35:29 <Twey> Jason9: Seriously, ##java is where you should be.
15:35:39 <monochrom> Let's just give Jason9 a lot of haskell code.
15:35:45 <Jason9> i tried it
15:35:50 <Jason9> i couldn't get in
15:36:10 <Twey> 23:32:25 < Twey> Jason9: /msg chanserv help register
15:36:11 <ddarius> Jason9: That nevertheless doesn't make this the place to ask your question.
15:36:16 <Twey> Okay…
15:36:20 <copumpkin> Jason9: then register your nickname and try again :) but you're basically asking a bunch of classical musicians about cooking and they don't know how or want to answer you
15:36:47 <dmwit> (Even though some of them may cook in their spare time.)
15:36:58 <dmwit> (Or even for a living...)
15:37:03 <Twey> No, we know how, we just don't want to a) answer Java questions or b) do homework
15:37:06 <dmwit> (Okay, this is stretching the metaphor a bit far, maybe.)
15:37:10 <Twey> Haha
15:37:11 <copumpkin> :P
15:37:24 <monochrom> Twey: You realize that /msg chanserv help register doesn't get anyone into ##java. :)
15:37:26 <burp> ya, this sounds like a school homework
15:37:30 <BONUS> i like the comparison that haskell is like classical music while java is like cooking
15:37:46 <Twey> monochrom: Ugh
15:37:54 <Twey> I'm really out of it tonight
15:38:00 <Twey> I blame my cold
15:38:00 <copumpkin> ddarius: and what's frustrating about that particular example is that I can't do case analysis to show it, because it's in a type :/
15:39:01 <Philonous> BONUS: Clearly, gangsta rap seems to be a more appropriate comparison
15:39:47 <monochrom> Twey: I mean this. Even /msg nickserv help register doesn't either. Here is a homework asker. Interested in getting fish, not interested in getting taught how to fish. :)
15:40:22 <dmwit> Maybe we're not interested in giving fish away.
15:40:39 <dmwit> Why do classical musicians have fish, anyway? Shouldn't that be the cooks...?
15:41:13 <copumpkin> someone transcribed schubert's trout for piano
15:41:25 <copumpkin> I guess it doesn't even need to be piano (although that's what I had in mind when I said it)
15:41:28 <copumpkin> but yeah, we have the trout quintet
15:41:42 <monochrom> Because Bizet composed a piece about fish.
15:42:03 <monochrom> and what copumpkin says
15:42:34 * copumpkin can't think of any other fishy music
15:42:50 <sepp2k1> Sorry for OT (it doesn't seem there's a general fp channel on freenode), but are there any statically typed, functional(ish) languages that target shell scripting-type problem areas (like file system operations, string and file processing, chaining together program invocations, etc.)?
15:43:43 <monochrom> someone wrote a lib for haskell to make it work like that.
15:45:22 <copumpkin> beware of the wall o' agda: http://snapplr.com/xnn3
15:46:40 <Veinor> wat
15:48:52 <illissius> what the heck is exists exists iff exists exists, for example?
15:49:06 <illissius> though I dunno, I guess if exists doesn't exist then you're in deep shit
15:49:48 <dmwit> I guess there are some things left out there.
15:49:56 <dmwit> Hooray for (partial) type inference!
15:50:40 <monochrom> "∃∃↔∃∃" is a law that says "∃ x y. blah" = "∃ y x. blah"
15:51:27 <dmwit> Oh. Yeah, that makes a lot more sense, then.
15:53:12 <Phyx-> hrm
15:53:20 <Phyx-> which unicode character is \u2203
15:53:22 <monochrom> "logic formula as type" is the best thing since "logic formula as number [Gödel1931]"
15:53:54 <dmwit> Phyx-: google?
15:53:57 <monochrom> \u2203 is the "exists" symbol
15:53:59 <dmwit> Phyx-: and/or just putChar?
15:54:02 <copumpkin> > text "\2203"
15:54:02 <lambdabot>   ࢛
15:54:06 <copumpkin> lol
15:54:10 <ddarius> illissius: Exists often doesn't exist.
15:54:13 <copumpkin> > 0x2203
15:54:14 <lambdabot>   8707
15:54:20 <copumpkin> > text "\8707"
15:54:21 <lambdabot>   ∃
15:54:24 <Phyx-> dmwit: it's just that i couldn't see what monochrom was typing
15:54:28 <dmwit> First hit on Google: http://www.fileformat.info/info/unicode/char/2203/index.htm
15:54:29 <Phyx-> monochrom: thanks :)
15:54:31 <monochrom> > text "\x2203"
15:54:31 <lambdabot>   ∃
15:54:35 <copumpkin> oho
15:54:50 <Phyx-> aye, my client isn't set to display unicode
15:54:58 <dmwit> > text "\x2203&4"
15:54:59 <lambdabot>   ∃&4
15:55:04 <dmwit> > text "\x220&4"
15:55:05 <lambdabot>   Ƞ&4
15:55:12 <dmwit> Oh, right.
15:55:14 <dmwit> > text "\x2203\&4"
15:55:15 <lambdabot>   ∃4
15:55:41 <dmwit> > '\&' -- hmm, I never wondered about this before
15:55:42 <lambdabot>   <no location info>:
15:55:42 <lambdabot>      lexical error in string/character literal at chara...
15:55:47 <dmwit> Yeah, that makes sense.
15:56:12 <ddarius> > length "\&\&\&\&\&\&"
15:56:13 <lambdabot>   0
15:56:19 <fryguybob> http://☃.net/
15:56:19 <monochrom> like an escape code for the empty string. no correspondence as character.
15:56:44 <Twey> monochrom: Maybe not, but there's not much more hand-holding one can give.
15:57:28 <Twey> monochrom: Sure, I *could* allocate the chap a password and email address and tell him exactly what to type into NickServ, or I could just give him the command to get the full instructions, which are too large to paste into the channel
15:57:40 <monochrom> I still think we should just feed a lot of haskell golfing code to all java askers.
15:57:47 <Twey> Hehe.
15:58:18 <ddarius> monochrom: Feel free to do so in a private message.
15:58:22 <aristid> fryguybob: that is the best domain ever.
15:58:27 <monochrom> Right, don't bother with handholding. I'm totally against handholding.
15:58:39 <fryguybob> aristid: Isn't it thought.
15:58:53 <fryguybob> The less interesting: http://unicodesnowmanforyou.com/ is the first google entry.
16:00:45 <monochrom> nice, codepad can execute haskell code with main
16:03:19 <Twey> monochrom: Isn't that the whole point of CodePad?  :þ
16:03:26 <jethr0> i always forget, do we have strictness annotations for function types?
16:03:43 <jethr0> like "someFunction :: [a] -> !Int"?
16:03:50 <monochrom> No.
16:04:03 <monochrom> Would be nice, eh? :)
16:04:16 <jethr0> any good, clean way of forcing a function result on lists? in my case "length"?
16:04:25 <ddarius> I don't know what that would mean.
16:04:45 <jethr0> myFunction = length <someBigList>
16:05:14 <jethr0> and I "need" to force evaluation of length to a number, instead of keeping lots of thunks around
16:05:17 <Twey> length is already strict
16:05:27 <monochrom> do the forcing at the call site
16:05:50 <ddarius> And in any situation, A -> !B doesn't make sense.  You wouldn't force the result of such a function until you forced the result any way.
16:05:54 <jethr0> at the call site I am at the moment within a list comprehension
16:05:55 <Twey> There's only one thunk, and when you read the number it gets evaluated, along with all the other thunks it produces 'til the end of the list
16:06:33 <chrisdone> if it produces any thunks at all
16:06:42 <monochrom> momFunction xs = let n = length xs in seq n [ i | i <- [1..n] ]
16:07:10 <chrisdone> guessing length is tail recursive modulo cons
16:07:29 <chrisdone> but with (+) instead of cons
16:07:32 <monochrom> this ensures length is done even before the list [ i | i <- [1..n] ] starts construction.
16:07:33 <chrisdone> @src length
16:07:33 <lambdabot> Source not found.
16:07:39 <chrisdone> not found my arse
16:07:52 <chrisdone> i am sick of lambdabot and its lies
16:07:55 * chrisdone downloads the source
16:08:01 <ddarius> monochrom: The seq does nothing there.
16:09:00 <monochrom> Fine.
16:09:06 <monochrom> momFunction xs = let n = length xs in seq n [ i | i <- [1..10] ]
16:10:02 <ddarius> monochrom: Okay, that still doesn't guarantee that n gets evaluated before the list comprehension produces something.  All it guarantees is that if xs = undefined or an infinite list momFunction xs will be bottom.
16:10:12 <ddarius> (or a list with an undefined tail)
16:11:05 <ddarius> If the compiler knew the length xs was not bottom, it could omit n and length xs entirely.
16:11:11 <chrisdone> which is more complete in its coverage of hackage these days, hoogle or hayoo?
16:11:28 <ddarius> monochrom: pseq would give you something closer to the guarantee you are looking for.
16:11:55 <byorgey> chrisdone: hayoo
16:12:10 <byorgey> but hoogle has the nice type-search feature.
16:12:18 <chrisdone> yeah, it is a good feature
16:13:09 <chrisdone> i can't remember what the search results for hayhoo are like, but iirc it gives you a docs page. lambdabot could use that to look-up the source of functions
16:17:54 <chrisdone> ... if hayoo was up
16:19:26 <pastorn> @hoogle a -> b
16:19:26 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:19:26 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:19:26 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
16:19:29 <pastorn> chrisdone: ^^
16:19:35 <pastorn> almost as good?
16:25:35 <chrisdone> pastorn: whaddayamean
16:31:12 <djahandarie> I sometimes wonder if it's good practice to do things like type SomethingBlah = ByteString
16:32:00 <hpc> it can help sometimes for functions were the parameters are the same type holding wildly different information
16:32:27 <djahandarie> Yeah, but it also doesn't really mean anything at all
16:33:37 <hpc> it's still a nice way of documenting
16:34:18 <pastorn> chrisdone: sorry, didn't read all the scrollback... thought you just wanted to search hayoo
16:35:19 <dons> djahandarie: its ok, but usually that's not helpful
16:35:31 <dons> better to use a newtype, and get the type system to help you distinguish them
16:35:36 <dons> that is, unless the name is really long
16:35:39 <dons> or a complicated type
16:36:43 <hpc> newtype introduces an extra constructor/wrapper though
16:36:56 <chrisdone> also use haddock documentation e.g. foo :: String -- ^ Name
16:36:56 <chrisdone>                                         -> String -- ^ Address
16:36:56 <chrisdone>                                         -> Reg    -- ^ ...
16:37:05 <dons> hpc: but guarantees no runtime cost
16:37:20 <dons> hpc: so it fits the usual case where you want to treat the underlying type differently somehow
16:37:34 <hpc> fair point
16:37:37 <jethr0> any ideas what the most efficient way is to convert a number into a list of its digits?
16:37:39 <dons> e.g. newtype CompressedString = C ByteString ; compress :: ByteString -> CompressedString
16:37:50 <dons> that way you get type errors if you use zlib strings in the wrong place
16:37:52 <jethr0> "map Char.digitToInt . show" seems like it could be slow...
16:38:05 <dons> jethr0: bytestring-show package?
16:38:14 * hackagebot ad 0.12 - Mixed-Mode Automatic Differentiation.  http://hackage.haskell.org/package/ad-0.12 (EdwardKmett)
16:38:42 <edwardk> I wondered if cabal would take a 2-character package name. guess it will ;)
16:38:42 <jethr0> dons, thx, I'll have a look at that
16:38:46 <djahandarie> dons, is there anywhere you'd use type instead of newtype?
16:38:47 <chrisdone> dons: is there a speed penalty for calling newtype constructors, or is it inlined/no-op?
16:39:07 <hpc> newtypes get unwrapped by the compiler
16:39:20 <dons> djahandarie: only as a local name for a long type
16:39:21 <hpc> they are identical to their contents at runtime
16:39:34 <dons> chrisdone: its a no op. compile time only 
16:39:47 <dons> it only exists at type checking
16:39:56 <chrisdone> such a nice way to make opaque types
16:40:15 <dons> type R a = (# a, State #)
16:40:18 <dons> was one I use sometimes
16:40:23 <dons> so I don't have to have ugly types leak
16:41:04 <dons> 'type' is just 'let' for types, remember. it exists just to give types names
16:41:12 <edwardk> chrisdone: the only time that newtypes have a cost is when the compiler isn't smart enough to figure out that they are a nop, (i.e. map MyNewType may not realize that it could skip the map if it doesn't inline it all away)
16:41:46 <aristid> edwardk: that'd be the same cost as an unoptimized map id, then?
16:41:52 <edwardk> aristid: yeah
16:41:53 <aristid> :t map id
16:41:53 <lambdabot> forall a. [a] -> [a]
16:42:17 <edwardk> aristid: but its still a pain in the neck sometimes ;)
16:42:28 <djahandarie> edwardk, what are using TH for in that library?
16:42:28 <dons> map NewType xs == map id
16:42:34 <dons> and ghc won't spot that.
16:42:44 <dons> so it has interesting 'structural' implications
16:42:45 <aristid> edwardk: oh sure, i was just wanting to make sure i understand it right
16:42:52 <Twey> Lajla: Lists are *defined* as data [a] = [] | a : [a]
16:42:54 <dons> nested id /= id
16:43:01 <aristid> dons: you mean ghc CANNOT optimise it?
16:43:06 <edwardk> djahandarie: Numeric.AD.Internal derives the common 'beautiful differentiation'-style jacobian definitions for me for each of the Numeric.AD.Foo
16:43:39 <Twey> Lajla: You can't cons other things because cons is part of the definition of lists, not of other types (though they may have their own ‘cons’ constructors, of course, if that makes sense for the type)
16:44:07 <edwardk> so you define Primal, Jacobian, and Mode and it defines Lifted, which is actually a requirement for the Mode you just defined!
16:44:08 <dons> aristid: ghc can. {-# RULES "map id == id" map id == id #-}
16:44:09 <dons> done.
16:44:11 <Lajla> Twey, I know that, and that's the part I don't like.
16:44:12 <edwardk> its fairly circular ;)
16:44:15 <dons> aristid: but ghc doesn't have such a rule by default
16:44:32 <Lajla> Haskell is too much rooted in 'making sense to human beings', as I'm utterly and utterly insane, I don't care.
16:44:42 <aristid> dons: why not?
16:45:04 <dons> aristid: i think because it is a very rare problem. mapping a newtype constructor over a polymorphic container
16:45:12 <dons> so no one has felt the need to add that rule
16:45:19 <Twey> Lajla: It doesn't make sense to *anything* to attempt to cons, say, a string to an integer.  ☺
16:45:28 * chrisdone ponders list fusion
16:45:35 <Twey> That's just not what cons does.
16:45:38 <aristid> dons: i think it's not something extraordinary at all
16:45:38 <edwardk> besides you can always fuse it away by moving your container into Yoneda ;)
16:45:40 <djahandarie> dons, shouldn't there be some sort of way to automatically detect that rather than require a rule?
16:45:43 <Lajla> Twey, it does no more or less than consing it to an empty list to me.
16:45:49 <aristid> dons: (map Just) is plain standard haskell too
16:45:50 <dons> aristid: have you run into it in practice?
16:45:51 <djahandarie> dons, i.e., mapping a noop over anything
16:45:52 <Lajla> Twey, as I said, I don't believe in this 'ordered collection of items'
16:45:59 <dons> map Just isn't a newtype.
16:46:05 <dons> mapping constructors is very common.
16:46:09 <aristid> dons: yeah but it's a similar pattern i think
16:46:11 <dons> mapping newtype constructors is very rare, imo.
16:46:11 <Lajla> I believe in two values, one an item, another a similar construct again until a special constant [] is reached.
16:46:14 <edwardk> dons: i have
16:46:19 <dons> edwardk: so have i. 
16:46:43 <dons> but still, why don't people ask about it more often? because it isn't very common.
16:46:44 <mauke> Lajla: that's an ordered collection of items
16:46:48 <hpc> Lajla: you just described an ordered collection of items
16:46:52 <Twey> Lajla: Okay… that's an ordered collection of items :þ
16:47:05 <edwardk> {-# RULES "map MyNewType == unsafeCoerce" map MyNewType == unsafeCoerce #-}
16:47:06 <edwardk> ;)
16:47:13 <Twey> Lajla: It doesn't make sense because an integer is not a ‘similar construct containing []’
16:47:26 <chrisdone> i've never done it. usually the newtype is applied before hand 
16:47:32 <Lajla> Twey, I said I saw a list as that.
16:47:36 <Lajla> A list is a special case of a pair.
16:47:44 <Lajla> Where 'special' is a meaningless term.
16:47:47 <Lajla> I want to pair ALL things.
16:47:51 <mauke> so use tuples
16:47:53 <ddarius> edwardk likes proposing solutions that are worse than the disease.
16:47:56 <edwardk> but you can always work around it with the generalizednewtypederiving iso hack anyways ;)
16:48:00 <edwardk> ddarius: =)
16:48:02 <Lajla> mauke, I can't eaisly translate tuples to list.
16:48:07 <mauke> why not?
16:48:34 <hpc> Lajla: you can make a heterogeneous list type, but it is damn near useless because you have to unsafeCoerce everything you want to extract from it
16:48:38 <Twey> data List a = (Maybe a, Maybe (List a))
16:48:47 <mauke> Twey: no
16:48:49 <chrisdone> hpc: well it's not that bad
16:48:56 <Twey> Hm, no
16:49:03 <Lajla> What if I have (3, "a") and want [3,'a',"three-a"'] from that, it'll be a type error.
16:49:19 <mauke> Lajla: no, a syntax error
16:49:20 <Lajla> Ah, ad hoc lists you mean.
16:49:26 <mauke> but go on
16:49:34 <chrisdone> hpc: if you have a list of (Ord a,Show a) => a and all you want to do is re-arrange them and then print them out, it's useful
16:49:41 <Lajla> Yeah, I thought about that, but haskell is so limiting in its type system that almost nothing will accept that.
16:49:54 <Lajla> I like to have functions that ask types and let it be my responsibility to deal with it.
16:50:04 <mauke> why?
16:50:16 <hpc> you are asking for zero type safety?
16:50:25 <mauke> I mean, you can do everything with Data.Dynamic, I just don't see the point
16:50:43 <kmc> damn type system, preventing me from writing incorrect programs
16:50:43 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
16:50:46 <Lajla> hpc, well, I'd like that.
16:50:46 <kmc> so restricting
16:50:55 <Lajla> kmc, incporrect is in the eye of the beholder.
16:50:57 * hpc points towards lisp
16:51:21 <mauke> Lajla: languages without a type system make it hard to write 'return'
16:51:30 <ddarius> "Those C programs are /designed/ to corrupt memory when that input is given."
16:51:43 <Lajla> C is ugly for what it tries to do.
16:51:49 <Lajla> C-- however is much more elegant.
16:52:05 <hpc> C doesn't try to be anything more than portable assembly language
16:52:08 <mauke> I totally wanted that ArrayStoreException there
16:52:10 <robin_rytich> C--? does it even exist?
16:52:23 <kmc> yes, it (or a variant) is an intermediate language in GHC
16:52:33 <kmc> also a well-specified language in its own right
16:52:37 <kmc> but not much used compared to LLVM
16:52:45 <robin_rytich> hey, right! never heard of
16:52:47 <kmc> which has a broadly similar goal
16:53:22 <Lajla> hpc, and C-- is much better at that.
16:53:30 <chrisdone> you come to #haskell and say that you don't like the type system; you've just entered a synagogue and started dissing the 613 Mitzvot
16:53:40 <Lajla> chrisdone, I didn't come, I was addressed.
16:53:54 <mauke> let me get my lwall quote
16:54:16 <monochrom> "Hi!" -- Larry Wall
16:54:19 <mauke> "The trick is to use Perl's strengths rather than its weaknesses."
16:54:23 <mauke> s/Perl/Haskell/
16:54:38 <chrisdone> monochrom: valid perl code
16:54:50 <Lajla> mauke, well, I 'could', write code myself that comforms to HAskell's type system without the compiler enforcing or checking it.
16:54:50 <hpc> XD
16:55:09 <mauke> chrisdone: it isn't, actually
16:55:12 <Lajla> But it's the theory that fascinates me about HAskell, that's why I learnt it.
16:55:28 <Twey> Lajla: You could, but it would be horribly clumsy and inelegant.
16:55:35 * monochrom deplores advocacy
16:55:43 <Lajla> Twey, it would be the same wouldn't it?
16:55:45 <mux> not being able to have heterogeneous lists simply (there's still HList) sounds limiting at first, but in practice I /never/ found that to be an issue; just my 2 cents
16:55:46 <Twey> Lajla: No
16:55:56 <Twey> Lajla: Haskell doesn't just use types to annoy you
16:55:59 <chrisdone> mauke: that's not how the joke works ~_~
16:56:02 <Lajla> Twey, what I mean is enfocring haskell's type constraints on my own.
16:56:04 <mauke> chrisdone: what joke?
16:56:13 <ddarius> "Advocacy makes an ad out of Bo and Kacy"
16:56:13 <Twey> Lajla: Types are not merely constraints
16:56:20 <Lajla> Twey, I know what they are for, and whence they came, and I find the maths behind it most elegant.
16:56:31 <zakwilson> Haskell *doesn't* use types just to annoy people? All this time, I thought it was to keep the riffraff out!
16:56:32 <chrisdone> mauke: http://dis.4chan.org/read/prog/1194881935
16:56:38 <Lajla> Twey, well, they are actually, but to protect people against their own foolishness and errors.
16:56:54 <Lajla> ूपThis is usually helping people, I realize.
16:56:57 <Twey> Lajla: The Haskell compiler uses types to infer things about your program to allow it to deduce things without you having to write them out explicitly
16:57:05 <Lajla> But a type in the end is nothing more than a constraint to what can be applied to what.
16:57:17 <Lajla> Twey, sure, but I could theoretically do that by hand.
16:57:20 <mauke> Lajla: that's not the whole truth
16:57:25 <Lajla> mauke, elaborate.
16:57:41 <Twey> Sure.  But it would be horribly clumsy and inelegant, because your code would be littered with all sorts of pointless implementation details.
16:57:50 <ddarius> You can use the type system to enforce constraints on the input your code is given allowing you to give better (or any) guarantees, e.g. STM.
16:57:50 <Twey> (also about twenty times longer)
16:58:19 <mauke> you can use the type system to broadcast information through your program
16:58:45 <Lajla> Twey, no, I mean just writing Haskell code without a compiler enforcing types and keeping to those types by hand to ensure it goes well. Sort of like using untyped lambda calculus but agreeing to stay within the constraints of Ssystem F.
16:58:47 <ddarius> In Haskell, you can use its type system to provide type-directed code generation.
16:58:51 <mauke> type inference flows in all directions
16:59:15 <mauke> Lajla: then how would minBound work?
16:59:15 <Twey> Lajla: You mean writing the types out anyway?
16:59:18 <Lajla> mauke, well, that is a type system, not the type of a function or cosntant.
16:59:21 <hpc> untyped lambda calculus is lisp's domain
16:59:24 <ddarius> Lajla: It's is simply not true that you could just omit types and your code would "just work" in Haskell.
16:59:27 <Lajla> Twey, well, in my head, sort of.
16:59:34 <Twey> Lajla: No, the compiler can't read your mind ☺
16:59:59 <Lajla> ddarius, it would lead to _somethig_ that something would just 'make no sense' to human beings.
17:00:01 <chrisdone> nor other contributors do your library/program, for that matter
17:00:02 <Twey> Lajla: If you want it to be able to figure out what you meant and fill in all the ugly boilerplate to get there, you have to tell it stuff.
17:00:07 <Bigglotron> wasn't there a type theorist who got all angry and said lisp had one type as opposed to being untyped
17:00:12 <glguy> You need the types to resolve the typeclass instances
17:00:25 <ddarius> Lajla: No, it would lead to something which is not compilable.  Crucial information would be missing.  It would "make no sense" to the compiler as well.
17:00:38 <ddarius> Bigglotron: No.
17:00:44 <Twey> Bigglotron: ezyang said that
17:00:51 <Twey> Well… he wasn't very angry
17:00:59 <Veinor> I can't imagine ezyang being angry
17:01:03 <Veinor> it's not a mental picture that fits in my head
17:01:04 <Twey> Heh
17:01:06 <ddarius> Type theorist usually simply equate untyped and unityped.
17:01:17 <ddarius> They don't get angry about it.
17:01:19 <Lajla> Twey, let me put it like this: Some people see the nth natural number, other people see an n-th order compositional operator. I chose to see an 'abstract machine that is fed a list of symbols and rewrites them into another list of symbols'
17:01:31 <Lajla> ddarius, that's because the compiler enforeces types.
17:01:34 <Lajla> garbage in, garbage out.
17:01:40 <Twey> Lajla: No
17:02:00 <Twey> Lajla: It's because the compiler uses types to understand what your program means.
17:02:02 <ddarius> Lajla: No.  The types propagate information.  Without the types that information is not propagated and the code becomes ambiguous.  It no longer has -any- meaning.
17:02:04 <monochrom> abstract machines are less abstract than abstract functions
17:02:14 <Twey> It's not about enforcement.  It's about telling the compiler what you want.
17:02:21 <ddarius> Lajla: It is no longer -implementable-.
17:02:23 <Lajla> ddarius, but it still would lead to some output.
17:02:23 <Bigglotron> hwell i don't know about type theorists so i guess i learned a *new fact*
17:02:26 <Lajla> ddarius, probably.
17:02:27 <mauke> Lajla: no
17:02:29 <ddarius> Lajla: No. It wouldn't.
17:02:30 <Lajla> It would not be an executable.
17:02:34 <Twey> It just happens to be inseparable from enforcement, because if you get them wrong the compiler will get confused, so it has to error.
17:02:35 <Lajla> But it would be some output.
17:02:43 <mauke> Lajla: wtf?
17:02:45 * chrisdone mentally replaces 'types' with 'spice' in this conversation and suddenly it has a Dune feel
17:02:57 <Twey> Lajla: No, it wouldn't… it would be a very confused compiler
17:03:10 <Twey> Unless you consider error messages output
17:03:13 <Lajla> Twey, well, maybe it would run forever without halting.
17:03:17 <Twey> In which case, you'd get lots of output
17:03:19 <mauke> Lajla: run what?
17:03:19 <Lajla> Twey, an error message is a form of type checking.
17:03:23 <mauke> Lajla: you no longer have a program
17:03:29 <orbisvicis> is there a shortcut in matching, so before binding the match to the variable name, I can apply a function ?
17:03:39 <Lajla> I'm talkinbga bout applying all sequential operations that normally apply on the source code witohut checking if anything is 'in order'.
17:03:41 <chrisdone> orbisvicis: yes, views!
17:03:45 <mauke> Lajla: are you saying perl is a C compiler because you can do perl hello.c and get an error message?
17:03:48 <Lajla> mauke, I never claimed it was executable.
17:03:59 <Lajla> I said it matched an input determinsticialyl to an output.
17:04:07 <chrisdone> orbisvicis: http://www.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
17:04:07 <Lajla> Where that input is a bit vector, and so is that output.
17:04:13 <mauke> Lajla: you lost me
17:04:15 <chrisdone> orbisvicis: scroll down to View Patterns
17:04:16 <ddarius> orbisvicis: There is a relatively new extension called view patterns.
17:04:29 <Lajla> mauke, a compiler is an algorithm that rewrites one bit vector to another.
17:04:32 <mauke> call me back when we're talking about executing haskell again
17:04:37 <ddarius> Views and view patterns have some rather significant differences.
17:04:40 <Twey> Lajla: You can't do that.  A compiler is not merely a bunch of string replacements.
17:04:43 <Lajla> People chose to interpret the former as 'source code' and the latter as 'object code'
17:04:46 <orbisvicis> thanks, looking at it now
17:04:49 <mauke> Twey: I think it is exactly that
17:04:50 <Twey> Lajla: (at least, a Haskell compiler)
17:04:59 <Lajla> Twey, I said a bit vector.
17:05:01 <Lajla> Not strings.
17:05:08 <mauke> Lajla: that's what strings are
17:05:17 <chrisdone> orbisvicis: actually ViewPatterns may be the wrong way round for what you want
17:05:23 <Lajla> mauke, no, a subset of bit vectors are.
17:05:32 <Lajla> If we chose to interpret them as such.
17:05:33 <Twey> Lajla: A Haskell compiler must *understand* your code, to some extent.  If it can't do that, then it doesn't have enough information to produce output, and it will error.
17:05:45 <Lajla> Twey, it will error when it cheks if things are 'in order'.
17:06:03 <Lajla> If it removes all checks, it will either produce a certain output, or it will run forever.
17:06:03 <Twey> No, it will error when it assumes that they are in order and attempts to perform a lookup with non-existant information.
17:06:17 <mauke> Lajla: why would the compiler run forever?
17:06:17 <Lajla> And to know it doesn't exist, it much check if it exists.
17:06:23 <Lajla> mauke, quite possible.
17:06:26 <Lajla> On some input.
17:06:31 <Twey> … no, that's not the case
17:06:35 <Lajla> Twey, I'm talking about no checks at all.
17:06:43 <mauke> yeah, whatever
17:06:45 <monochrom> This is just theology.
17:06:51 <Lajla> I'm talking about a series of instructions launched at a processor.
17:06:54 <mauke> I think this "discussion" is silly
17:06:55 <Twey> Walking into a wall and bouncing off it is not the same as looking and seeing that there's a wall in front of you.
17:07:08 <Twey> Lajla: We call that assembly language.
17:07:10 <Lajla> Twey, that's because what gives the info checkts itself.
17:07:19 <chrisdone> example :: Maybe ((String -> Integer,Integer), String) -> Bool
17:07:19 <chrisdone> example Just ((f,_), f -> 4) = True
17:07:19 <chrisdone> now that is cool
17:07:21 <Twey> And it fits neatly into the ‘horribly clumsy and inelegant’ category.
17:07:24 <Lajla> Twey, you know what 'garbage in, garbage out' means right?
17:07:38 <Bigglotron> unless you are hard empiricist in which case all walls must be verified
17:07:55 <monochrom> ghc -Wall
17:08:00 <Lajla> If you launch random opcodes at a CPU, it will produce 'something', that something will not 'make sense' to human beings, but it will be the composition of its oprerations.
17:08:06 <orbisvicis> chrisdone: yes it is backwards from what I wanted. also requires extra compiler options which I rather not use. 
17:08:11 <Twey> Lajla: Sure.  Probably errors.
17:08:11 <orbisvicis> no big deal though
17:08:17 <monochrom> "a haskell program runs into a ghc -Wall. ouch."
17:08:26 <Twey> Lajla: But a Haskell compiler is not a processor.
17:08:29 <Lajla> Twey, again, then you have to check if things are in order.
17:08:34 <Twey> And Haskell is not machine code.
17:08:42 <Lajla> Twey, I know, but if you remove all checks from all compontents involved.
17:08:45 <mauke> Lajla, Twey: you're both making me angry
17:08:47 <chrisdone> yawn
17:08:53 <Lajla> And just let them apply their sequential bit-rewriting operations.
17:09:03 <Lajla> It will in the end be one bit vector rewriten to another.
17:09:22 <Twey> Lajla: You're speaking rubbish, sir.  I'm going to go back to my Clojure tutorial now.  Have a good evening.  ☺
17:09:25 <mux> and how is that useful and/or meaningful in any way?
17:09:53 <mauke> Lajla: imagine we wrote a haskell compiler that simply didn't do any typechecks. we could feed it a correct haskell program and get an executable, or an incorrect program and get garbage
17:09:58 <mauke> Lajla: is this what you mean?
17:10:00 <Bigglotron> i think he's talking theory for the sake of theory.
17:10:13 <mux> he wants haskell post type erasure
17:10:16 <Lajla> mauke, we would get garbage.
17:10:20 <Lajla> mux, not at all.
17:10:26 <mauke> Lajla: was that a yes or a no?
17:10:49 <ddarius> Lajla: The point that people are making, which has nothing to do with "what a compiler does", is that you cannot recreate the behavior of typed Haskell code from the same code with all types erased without either reimplementing a type checker or by making global changes to the type-erased code, therefore the types are not just "constraints."  Whether you can produce -different- behavior is completely irrelevant and pointless.
17:11:11 <Lajla> mauke, if all type checks were remove,d it would result intoa  bit vector most likelty that cannot be interpreted as text, floatss, or whatever.
17:11:20 <mauke> Lajla: what?
17:11:24 <Lajla> ddarius, I know that.
17:11:29 <Bigglotron> oh, is he trying to make an argument against the type system?
17:11:34 <Lajla> Bigglotron, no.
17:11:37 <mauke> Lajla: my compiler outputs machine code, thank you
17:11:42 <mauke> Lajla: why would I interpret that as floats?
17:11:50 <ddarius> Lajla: So you agree that a type system is not just a "bunch of constraints?"
17:12:02 <Lajla> I'm saying that a computer is a formalism that has no conception, it manipulates symbols without interpreting them, interpretation we give to it.
17:12:09 <Lajla> ddarius, I said types were.
17:12:11 <Lajla> Not a type system.
17:12:23 <monochrom> I also manipulate symbols without interpreting them.
17:12:28 <Lajla> I told that before, a type system is more than that, but a type in itself is simply a whitelist.
17:12:29 <Bigglotron> Laija assuming a deterministic universe, we assign meaning on the same level a computer does
17:12:43 <Lajla> Bigglotron, I agree.
17:12:56 <Bigglotron> righto.
17:13:06 <wagle> www.haskell.org is down, long live haskell.org?
17:13:16 <monochrom> heh yeah
17:13:16 <Lajla> I do not believe in human 'consciousness', I believe that human beings are soulless automatons that have evolved to _claim_ consciousness as it gives an advnatage to survival.
17:13:22 <EvanR> without some type safety some operations could cause a segfault, not just gibberish answers. that doesnt seem like something that is unreasonable constrained
17:13:25 <EvanR> unreasonbl
17:13:27 <EvanR> y
17:13:34 <aristid> wagle: maybe god does this to tell use that SPOFs are bad.
17:13:36 <Lajla> EvanR, that's true.
17:13:40 <EvanR> Lajla: what advantage is that/
17:13:41 <aristid> -use+us
17:13:51 <Bigglotron> I disagree there.
17:13:55 <Lajla> EvanR, claim that you feel pain, and awaken sympathy.
17:14:04 <EvanR> i knew you were going to say that
17:14:05 --- mode: ChanServ set +o mauke
17:14:05 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org (currently down)", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke
17:14:11 <Bigglotron> I think consciousness is a phenomena that exists and we have not properly classified yet.
17:14:24 <mauke> why do people do this
17:14:36 <mauke> "a phenomena" makes no sense
17:14:44 <Bigglotron> phenomenon
17:14:48 <Bigglotron> christ.
17:14:50 <Lajla> Bigglotron, that violates occkam's razor though, conciouysness is not needed to explain human behaviour, and assuming its existence raises a lot of quaestions, and answers none.
17:15:09 <EvanR> until theres a proof of occams razor i dont know how useful it is
17:15:17 <ddarius> Lajla: A type only has meaning in the context of a type system and in that context, in a way that will appeal to you, types are just meaningless formal combinations of symbols.  Types don't have meaning on their own.
17:15:18 <Lajla> The simplest theory is to say that humans are not conscious, but simply claim and behave as if they are outwardly, similarly to AI's that pass the turing test.
17:15:19 <Bigglotron> Actually it answers a lot of questions about language.
17:15:25 <gwern> EvanR: what manner of proof would you consider acceptable?
17:15:31 <Lajla> ddarius, I agree.
17:15:53 <chrisdone> gwern: me and you can make a proof right now
17:16:01 <EvanR> at least something the claimer finds acceptable
17:16:03 <mauke> kinky
17:16:05 --- mode: mauke set -o mauke
17:16:06 <ddarius> EvanR: Occam's Razor does actually come out of probability theory.
17:16:09 <gwern> chrisdone: whoa now, I don't think we know each other well enough
17:16:11 <Lajla> EvanR, well, the idea is more that if you have a more complex theory, you have to justify why that more complex theory out of the many. Ther eis one simplset theory, and multiple theories which assume more than is needed.
17:16:24 <Bigglotron> Basically a hugeass lump of modern science depends on some kind of consciousness and indicates that such a thing exists.
17:16:41 <mauke> how do you measure the simplicity of a theory?
17:16:50 <Lajla> I can say gravitational laws make things fall, or say that 'There are pink aliesn with mohawks that are invisible that pull invissible chains in such a way that all things alway smatch gravitational physics'
17:16:52 <EvanR> in a sound theory with redundant assumptions you should be able to prove the assumptions too
17:16:56 <Bigglotron> mauke: K-C complexity? ;]
17:16:56 <gwern> mauke: kolmogorov complexity!
17:16:57 <EvanR> so its not like the assumptions are wrong
17:16:57 <Lajla> But then I have to justify why they are pink, and not purple.
17:17:09 <gwern> EvanR: then you have to justify the redundancy...
17:17:15 <EvanR> no you dont
17:17:25 <EvanR> if the redundant assumption is true either way
17:17:30 <Bigglotron> Laija I think you read a bit much skinner.
17:17:30 <ddarius> mauke: For what I'm referring to, it would mainly mean the number of parameters.  
17:17:31 <gwern> what I don't even
17:18:14 <gwern> how can an assumption be true either way
17:18:26 <Bigglotron> god said it.
17:18:27 * hackagebot ad 0.13 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.13 (EdwardKmett)
17:18:29 <mauke> a wizard did it
17:18:38 <Bigglotron> it was ghosts
17:18:50 <ddarius> mauke: For example, you will always be able to get a better match to some data given a quadratic model v. a linear model, but the extra flexibility of the quadratic model weighs against it and may lead to preferring a linear model.
17:19:23 <EvanR> gwern: an assumption is redundant if you can prove it with other assumptions? then its true
17:19:34 <gwern> EvanR: but then it's not an assumption, it's a theorem
17:19:42 <EvanR> yes
17:19:45 <monochrom> Is type class why Haskell (98) programs need types to tell the computer what to do?
17:19:48 <ddarius> gwern: You can assume things that are true.
17:19:50 <Lajla> Bigglotron, what's 'skinner'?
17:20:09 <Lajla> Anyway, I migh invite you all to ##philosophy, the channel whose topic is off topic.
17:20:11 <ddarius> monochrom: Not only those, but mainly those.
17:20:17 <gwern> ddarius: truth is independent of our formal systems
17:20:27 <Bigglotron> the key proponent of the perspective you're advocating who got owned really hard in the 1950s iirc?
17:20:34 <ddarius> gwern: Usually "truth" is defined by our formal systems.
17:20:44 <Lajla> gwern, platonism?
17:20:51 <Lajla> gwern, define 'truth'.
17:21:02 <Lajla> Formal systems usualyl just define truth as 'that which is defined as true'
17:21:04 * gwern remains silent and waits to be crucified by Lajla 
17:21:15 * chrisdone groans in boredom-pain
17:21:25 <Lajla> Amazingl simple, define theorem as 'all the things the definition of the formal system define as theorem'
17:21:26 * monochrom fingers chrisdone
17:21:37 * EvanR pops the conversation stack before it overflows
17:21:39 <gwern> chrisdone: come on, my Pilate allusion wasn't that bad
17:21:55 <Lajla> I like the conversation heap more, it branches off.
17:22:27 <monochrom> I like queue. It's more fair.
17:22:56 <mauke> a skew binomial priority queue
17:22:56 <monochrom> I also want union-find.
17:23:56 <monochrom> I wonder if orbisvicis gets some pattern matching to work.
17:24:03 <ddarius> EvanR: You may find this interesting: http://bayes.wustl.edu/glb/model.pdf
17:24:07 * gwern has a half-written union-find package. I find the semantics hard to grasp :(
17:26:52 <monochrom> the semantics (specification, observable behaviour) shouldn't be hard. if it seems hard, it is because expositions jump to implementations too quickly, so quickly you don't notice they're already talking about implementations not specifications.
17:27:04 <EvanR> ddarius: wgot
17:27:26 <monochrom> the specification is just "can haz equivalence classes, can merge"
17:28:22 <gwern> monochrom: I know, but it's not obvious to me what the haskell translation of stuff is
17:29:11 <gwern> also, I was writing multiple implementations (lists, Seq, Sets) and got meself thoroughly confused
17:29:24 <gwern> weighted lists, almost forgot
17:29:48 <Bigglotron> so where IS haskell.org
17:29:49 <zachk> i do this but its sillly :) 
17:30:00 <monochrom> did you try to break the logarithmic barrier?
17:30:12 <gwern> I smacked right into it!
17:30:27 <zachk> > let setify n=nub.sort n in setify [3,45,3,2,1,2,2,4] 
17:30:28 <lambdabot>   No instance for (GHC.Num.Num [a])
17:30:28 <lambdabot>    arising from a use of `e_1345321224' a...
17:30:33 <zachk> oh my
17:30:36 <monochrom> ok, I won't hope for anything better. :)
17:30:45 <gwern> it felt like glass
17:30:49 <zachk>  let setify n=nub.sort $ n in setify [3,45,3,2,1,2,2,4] 
17:30:59 <zachk> >  let setify n=nub.sort n in setify [3,45,3,2,1,2,2,4] 
17:31:00 <lambdabot>   No instance for (GHC.Num.Num [a])
17:31:00 <lambdabot>    arising from a use of `e_1345321224' a...
17:31:09 <gwern> didn't get anywhere near the diffarray one that got written in Coq
17:31:33 <zachk> >  let setify n=nub.sort $ n in setify [3,45,3,2,1,2,2,4] 
17:31:34 <lambdabot>   [1,2,3,4,45]
17:31:46 * zachk apologizes for the bad code 
17:32:06 <gwern> >  let setify = nub . sort  in  setify [3,45,3,2,1,2,2,4]
17:32:07 <lambdabot>   [1,2,3,4,45]
17:32:31 <zachk> i still like my $ , im not over them yet 
17:32:34 <EvanR> logarithmic barrier?
17:33:24 <monochrom> such as because you use Data.Set rather than hash table you multiply O(log n) to every thing.
17:35:15 <EvanR> hash table breaks the logarithmic barrier?
17:35:43 <gwern> hm, collisions mean I never can remember the complexities for hash tables
17:38:53 <ddarius> Given a set A, a partition is a surjective function from A.  find is just application of the function, union is post-composition by a function that identifies only a given set of elements.
17:39:27 <ddarius> ... post-composition by a surjective function ...
17:40:43 * gwern appreciates how you say all that as if I would understand
17:41:17 <ddarius> gwern: I'm pretty sure you know what a surjective function is.  "surjective" was the only particularly technical term.
17:41:38 <gwern> it's not the individual words that bother me, but how they all come together
17:42:38 <m3ga> I'm doing 'ghc -package tagsoup --make Main.hs -o whatever' but i still get "Could not find module `Text.HTML.TagSoup.Match': it is a hidden module in the package `tagsoup-0.9'". I have tagsoup installed. why doesn't it compile?
17:42:45 <mreh> I'm playing all the right notes, but not necessarily in the right order
17:42:50 <gwern> and actually, I've forgotten what surjective means. I remember that the three are surjective/injective/bijective, but can't remember what each means
17:42:50 <ddarius> A partition of a set A can always be represented by a surjective function where each element of the partition is the inverse image of an element of the codomain.
17:43:22 <gwern> m3ga: tagsoup around .5 hid a bunch of modules and began re-exporting them. I suggest you edit your Main.hs to import one of the exposed modules
17:43:52 <gwern> (fortunte for m3ga that I just dealt with a problem like that in lambdabot the other day)
17:45:55 <m3ga> thanks gwern. thats a good pointer in the right direction
17:48:39 <monochrom> surj is onto
17:48:58 * mreh feels like getting the ball rolling with a libavcodec binding, but fears he will not be bothered to cross every t and dot the Is, maybe a J or two
17:49:18 <gwern> dot your Js?
17:49:26 <mreh> always
17:49:39 * gwern only dots the lower-case ones
17:49:45 * ddarius doesn't ever dot his capital Is or Js.
17:49:56 <ddarius> Well, that's not true.
17:50:03 <ddarius> Rotational mechanics and all that.
17:50:04 <mreh> German?
18:00:48 <Twey> Turkish has a capital İ to distinguish it from a capital ı
18:01:12 <djahandarie> How many languages do you know Twey? :P
18:09:38 <Veinor> http://www.xanxys.net/haskell/hoogle/
18:09:40 <Veinor> FYI
18:10:28 <benmachine> neat
18:11:29 <flippo> djahandarie, you have a very Persian name.
18:33:47 <djahandarie> flippo, that's because I'm persian. :)
18:34:05 <flippo> djahandarie, that's quite a coincidence!
18:34:17 <jethr0> @src (%)
18:34:17 <lambdabot> x % y = reduce (x * signum y) (abs y)
18:34:29 <jethr0> > 4%5
18:34:30 <lambdabot>   4 % 5
18:34:47 <djahandarie> :t reduce
18:34:47 <lambdabot> Expr -> Expr
18:35:06 <djahandarie> Eh
18:35:28 <djahandarie> :t 4%5
18:35:29 <lambdabot> forall t. (Integral t) => Ratio t
18:36:06 <jethr0> hmm, why does ghci say "not in scope: '%'"?
18:36:23 <djahandarie> Did you import Data.Ratio?
18:37:57 <jethr0> nope, just figured that part out
18:38:13 <jethr0> I've always assumed it was somewhere in Prelude since it worked so well in here with lambdabot ;)
18:56:34 <aristid> @hoogle catA
18:56:34 <lambdabot> No results found
19:05:35 <JoeyA> @hoogle foldl'
19:05:35 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
19:05:35 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
19:05:35 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
19:38:23 <manjunaths> hello
19:38:51 <manjunaths> What is the equivlanet of a C array ?
19:38:58 <manjunaths> mutable stores
19:39:43 <lispy> manjunaths: either the Vector package or STUArray
19:40:00 <manjunaths> lispy, thanks
19:40:16 <lispy> manjunaths: cheers
19:40:19 <manjunaths> is haskell.org down for anyone else ?
19:40:41 <lispy> manjunaths: yes
19:40:46 <edwardk> manjunaths: haskell.org has been having troubles for a couple of days now
19:40:49 <lispy> manjunaths: down for maintentance
19:40:56 <manjunaths> ah... :-(
19:40:58 <edwardk> we've been pwnd
19:41:30 <manjunaths> really ?
19:41:38 <manjunaths> that is kind of sad actually
19:42:11 <ddarius> There's a package -called- carray.  However, the closest thing to an actual C array is a Ptr.
19:42:15 <manjunaths> what kind of moron would want to 'pwn' a language portal
19:42:26 <dcoutts> manjunaths: spammers
19:42:28 <edwardk> manjunaths: probably something automated ;)
19:43:22 * edwardk twiddles his thumbs while waiting for hackage to finish letting him upload.
19:43:36 <manjunaths> one weekend I decide to do some haskell hacking and spammers attack my favorite wesite...bleh
19:43:51 <lispy> manjunaths: quite a few resources are still available though
19:43:57 <lispy> manjunaths: haskell.org was mainly the wiki
19:44:00 <edwardk> yeah hackage for one
19:44:13 <edwardk> the main things that are down are the mailing list archives, and the wiki
19:44:26 <manjunaths> yes...but unfortunately most google searches lead to haskell.org
19:44:39 <lispy> manjunaths: archive.org? :)
19:44:55 <manjunaths> lispy, yeah and google cache
19:45:07 * hackagebot ad 0.15 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.15 (EdwardKmett)
19:45:14 <gwern> edwardk: if it was automated, that's even more embarassing
19:45:17 <edwardk> woot it uploaded
19:45:22 <lispy> edwardk: woot
19:45:29 <ddarius> edwardk: Are you just uploading those things hourly?
19:45:36 <gwern> I hope it wasn't a mediawiki exploit. I've been suggesting for a while that it be upgraded
19:45:47 <edwardk> ddarius: nah, there are some pretty big changes between versions there as i get more functionality wired in
19:45:49 <lispy> gwern: several things on that machine were too old
19:46:03 <gwern> lispy: that doesn't make me feel any better
19:46:17 <lispy> gwern: the really old mysql was making it very difficult to upgrade to a newer mediawiki (attempt(s) had been made)
19:46:23 <lispy> gwern: yeah, me either
19:46:35 <edwardk> this version gave me 'gradWith' combinators that zip the gradient back up with the input (without actually using a zip) by exploiting the fact that I know both at all the right points in the process, which makes gradient descent faster
19:46:43 <lispy> archive.org is super slow
19:47:17 <edwardk> and i plumbed them through each of forward, reverse and mixed mode.
19:47:23 <edwardk> i also added directional derivatives
19:47:40 <edwardk> though i still need to add directional derivatives of functions that return multivariate output
19:48:01 <edwardk> and add them to the main Numeric.AD module
19:49:07 <gwern> lispy: what I hate about archive.org is that you can't search it, its coverage is patchy, and you never know whether a version will be available or not
19:49:36 <gwern> lispy: when I was searching through dead sites for _Evangelion_ material, I'd had to schedule reminders for weeks and months later to get a page
19:50:23 <manjunaths> archive.org does not like  http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
19:50:28 <lispy> gwern: heh.  I would never have guessed you were an evangelion fan, but some how I feel like I should have
19:50:49 <gwern> lispy: I allude to it every so often. can't help myself
19:53:24 <ttmrichter> Is there any news at all concerning the return of Haskell.org?
19:53:49 <gwern> ttmrichter: wait. be patient. it comes like a thief in the night!
19:53:54 <dcoutts> http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
19:53:56 <dcoutts> ttmrichter: ^^
19:54:08 <gwern> yea, I say unto you: it is not given to any man to know the day nor the hour of the second coming
19:54:27 <ttmrichter> So you're trying to say that the return of Haskell.org will be 2010 years away (and counting)?
19:54:39 <gwern> but of the sons of clay here, none shall taste of death before that date
19:55:13 <gwern> dcoutts: 'eta 24 hours' 'posted 1 day ago'
19:55:24 <ddarius> edwardk: You going to build a whole geometric calculus framework atop your library?
19:55:35 <dcoutts> gwern: aye
19:55:43 <gwern> lispy: I'm actually watching _Tokyo Godfathers_ right now
19:57:31 <edwardk> ddarius: hah, well i have some clifford algebra code lying around ;)
19:58:04 * ttmrichter facepalms.
19:58:28 <ttmrichter> Now I've got some yahoo in private messages claiming that "they" are not giving Haskell.org up yet and to not mention "their" attack anymore.
19:58:42 <edwardk> now i need to decide if i want monadic/applicative grad/etc.
19:59:03 <lispy> ttmrichter: better pay up or the hostage gets i
19:59:05 <lispy> it
19:59:24 <ddarius> edwardk: ?
19:59:29 <gwern> yahoo? that doesn't sound like a very elite chat service to use
19:59:35 <ttmrichter> The hostage is digital.  You can make exact clones trivially.
19:59:47 <ddarius> ttmrichter: And shoot them all.
19:59:54 <edwardk> ddarius: i.e. gradA :: (Traversable f, Applicative t, Num a) => (forall s. f (AD s a) -> t (AD s a)) -> f a -> t (f a)
20:00:02 <ttmrichter> Now he's threatening me with being next.
20:00:09 <ttmrichter> Script kiddies.
20:00:13 <jethr0> having some weird problem with ghc under ubuntu...
20:00:15 <jethr0> "(.text+0xaa): undefined reference to `containerszm0zi3zi0zi0_DataziMap_lookup_closure'"
20:00:21 <ddarius> Use --make
20:00:31 <jethr0> under ghci using "Data.Map" works fine, but not under ghc...
20:00:44 <ddarius> edwardk: And why would you make it monadic if you can make it applicative?
20:00:47 <jethr0> i'll try it with make, but Data.Map should really be in the standard includes, no?
20:01:23 <edwardk> ddarius: i wouldn't necessarily. the applicative combinators are the ones that i think make sense
20:01:32 <jethr0> ddarius: thx, worked. didn't know that even Data.Map was treated like any old external dependency...
20:01:42 <ddarius> jethr0: Just always use --make.
20:01:57 <edwardk> not sure if i should throw a suffix on all of the existing combinators and add them to the same modules, or if i should export Numeric.AD.Applicative
20:02:00 <edwardk> etc.
20:02:28 <gwern> jethr0: I think only the Prelude is included by default
20:02:40 <gwern> jethr0: which makes sense; why hardwire one particular Data.Map?
20:02:42 <jethr0> k
20:02:44 <ttmrichter> So if I were to offer up, say, VPS space for free, would that permit haskell.org to come up for a while until the underlying problems are resolved?
20:03:05 <ddarius> edwardk: I still don't understand.  Why do you need different versions at all?  Convenience for those who don't have instance Applicative MyMonad ?
20:03:10 <gwern> ttmrichter: probably not; the shift would be nontrivial and probably require multiple people to sign off
20:03:23 <edwardk> ddarius: no, i mean right now i don't have the Applicative or Monad in there at all
20:03:50 <edwardk> i have grad :: (Traversable f, Num a) => (forall s. f (AD s a) -> AD s a) -> f a -> f a
20:04:10 <ddarius> edwardk: Okay, so will the applicavite versions add power or are they just convenience things, i.e. liftings?
20:04:17 <gwern> ttmrichter: I mean, a running server is important; think of the passwords...
20:04:36 <ttmrichter> gwern: When I said "make available" I meant "hand over the keys to root".
20:05:03 <ttmrichter> Basically fund the VPS for a month or whatever and let the site at least run for a while.
20:05:39 <Veinor> ttmrichter: careful, he'll hack all your javaports!
20:06:02 <ttmrichter> OH NOES!  NOT MY JAVA PORTS!
20:06:10 <ttmrichter> Where would I get my coffee now?
20:07:55 <dcoutts> ttmrichter: it's not that easy to just shift a whole server setup around
20:08:32 <edwardk> ddarius: they add power if you have a function that needs a side-effect to compute its output, though I have to admit, I need to make sure that in that case that they all still make sense.
20:08:37 <jethr0> do you have any ideas for looking up quickly in a large number of primes (primes < 1000000)? Data.Map and Data.IntMap are doing really poorly for some reason ;(
20:08:45 <lispy> I hope when they get it working again they start using SELinux
20:08:45 <jethr0> @paste
20:08:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:08:56 <edwardk> some like jacobian need multiple traversals, and would probably not work
20:09:11 <dcoutts> lispy: not using an obsolete RHEL would be a good start
20:09:14 <edwardk> but i can do a reverse mode grad in one pass
20:09:26 <ddarius> edwardk: I seriously expect that it wouldn't make sense in general, but arguably only in cases where what is being done is unreasonable anyway.
20:09:27 <lispy> dcoutts: yes :)
20:10:16 <edwardk> ddarius: yeah. basically it looks like i should be able to do it for any of my combinators that only make one pass, which since i can choose between forward/backwards is actually quite a few
20:10:27 <lpsmith> out of curiousity, has anybody tried translating Filinski's "Representing Monads" into Haskell?
20:10:31 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25935#a25935
20:10:38 <ddarius> lpsmith: Yes.
20:10:38 * lpsmith is working on that translation right now
20:11:02 <edwardk> lpsmith: yes
20:11:04 <ddarius> lpsmith: You probably want to look at some of Oleg's work on related systems.
20:12:05 <jethr0> *hmpf*
20:13:24 <ddarius> lpsmith: This I believe: http://okmij.org/ftp/Computation/Continuations.html#genuine-shift
20:13:54 <lpsmith> ddarius, ahh yes, I've played with that already
20:14:23 <ddarius> jethr0: Are you trying to make a Map out of an infinite list?
20:14:33 <lpsmith> Unless I missed something, it doesn't quite touch upon what I'm interested in.
20:14:48 <jethr0> ddarius: i'm so sorry. just noticed it... probably time to go to bed ;O
20:15:06 <ddarius> lpsmith: It covers the core you'll need.  I believe there are some issues trying to translate the continuation system into Haskell if done naively.
20:15:17 <jethr0> map of infinite primes would be nice to have though...
20:16:27 <lpsmith> Yeah, actually,  the family of shift operators at my disposal were borrowed from Oleg's ShiftResetGenuine,  CC Shan's "From Shift and Reset to Polarized Linear Logic",  and a few other places
20:16:39 <edwardk> ddarius: heh well, my gradA turns out to just be my jacobian implementation, so that is a good sign ;)
20:16:50 <ddarius> lpsmith: The ML code in "Representing Monads" or "Representing Layered Monads" used a trick to get dynamic typing at one point.
20:16:57 <lpsmith> aye
20:17:14 <lpsmith> I see that,  I haven't quite gotten that far with the haskell translation yet
20:18:29 <ddarius> lpsmith: If I'm not mistaken, you shouldn't have an issue using something like Oleg's continuation library, but using a normal Cont monad a little unsafeCoerce magic is the easiest thing.
20:18:34 <lpsmith> shift0 :: ((a -> r) -> r) -> Cont r a 
20:18:35 <lpsmith> shift0 = Cont
20:19:43 <lpsmith> shift1 :: ((a -> b) -> Cont b b) -> Cont b a
20:20:33 <lpsmith> shift2 :: ((a -> Cont r b) -> Cont b b) -> Cont b a
20:20:46 <lpsmith> shift3 :: ((Cont r a -> Cont r b) -> Cont b b) -> Cont b a
20:21:15 <lpsmith> They are all inter-definable,  given any one,  and run, reset, return, and (>>=),  you can define the rest
20:22:55 <lpsmith> Of course,  I gave the Murthy types,  Oleg uses the generalized types whose name is temporary escaping me
20:23:13 <lpsmith> And each appears in literature, to some degree of explicitness or another
20:25:54 <lpsmith> ddarius:  Filinski simply fixes the result type to be the universal type you mentioned;  I'm hoping it will be possible to avoid this ugliness using either Murthy or Danvy/Filinski types
20:25:59 <edwardk> ddarius: hah. after going through all of the signatures i actually don't add any value with applicative variants because i made the signatures general enough that wherever i wanted to drop an Applicative t => ... in i already had another function that took a Functor t => ... with the right semantics.
20:26:57 <lpsmith> ddarius, the "trick" used in Representing Monads is some New Jersey extensions to SML,   which is not that big a deal because they also use New Jersey callcc
20:27:02 <edwardk> (i'd replaced most of the vectors and lists in the usual implementations with functors and traversables as appropriate a while back)
20:27:51 <ddarius> edwardk: Curse abstraction.  Whose going to feed all the unemployed programmers?
20:28:03 <edwardk> iirc you can dodge the universal type with some nice parameterization
20:28:21 <edwardk> its just plumbing and extra complexity
20:28:26 <gwern> ddarius: the robot overlords
20:31:57 <Saizan> hah! i've conquered the termination checker.
20:31:59 <lpsmith> edwardk, did you have anything in mind regarding translating "Representing Monads" to Haskell other than Oleg's work?
20:32:15 <lpsmith> Saizan, solving the halting problem is always fun :)
20:32:19 <edwardk> lpsmith: i took a stab at it a while back, but i'm not sure what i did with the resulting code
20:47:27 <ddarius> The representing monads construction is not very compelling in Haskell.
20:53:03 <lpsmith> ddarius, I don't disagree
20:54:05 <lpsmith> I'm trying to distill out the precise, pure representation of the State monad to show that it does not correspond to the lazy state monad, actually
20:54:59 <lpsmith> ddarius, I'm somewhat confident that the "Representing Monads" construction doesn't even work in lazy languages
20:55:30 <lpsmith> well, work completely, that is.   It probably does work if you add in some more pre-conditions
20:59:05 <ddarius> My issue is simply that it doesn't solve any of the issues Haskellers have with monads, and since Haskell does not have continuations natively (for good reason) to use this technique you have to use a monad anyway and we already have techniques for allowing post-facto choice of monad.
20:59:45 <ddarius> There are benefits for using that representation for performance, but that is a hideable implementation detail.
21:04:30 <jmcarthur> @pl \f -> liftM2 (>>) f return
21:04:31 <lambdabot> flip (liftM2 (>>)) return
21:04:35 <jmcarthur> meh
21:10:03 <lpsmith> ddarius, well, my issues is that I don't really believe the "continuations can express *all* control constructs" folk wisdom anymore
21:10:24 <lpsmith> And "Representing Monads" is one of the standard justifications
21:11:14 <ddarius> lpsmith: There are different monadic transforms (and thus equivalently) different CPS transforms for CbV v. CbN.
21:12:19 <lpsmith> ddarius, You've said as much in the past.   Do you have source code or a paper in mind that expands on this statement?
21:13:57 <ddarius> I can rustle some up.  The CPS one is standard.  Moggi covers the monadic one in one of his papers.  Basically, the idea is whether you translate a ~> b into a -> m b or m a -> m b.
21:14:58 <lpsmith> well, I've played with Reynold's CBN CPS transformation,  and it produces expressions that have large, incomprehensible types
21:15:11 <lpsmith> (well, at least that I find incomprehesible at the present time)
21:15:41 <lpsmith> And that's for simple expressions such as const
21:20:14 <ddarius> lpsmith: See the paragraph following proposition 3.8 on page 19 in this: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
21:23:10 <ddarius> Remark 2.1 is also of note.
21:25:09 <lpsmith> ddarius, interested in a challenge then?  :)
21:26:31 <ddarius> lpsmith: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.8668 This is likely of significant relevance.
21:27:35 <lpsmith> yeah,  I've seen that paper before,  as well as several other Danvy/Hatfield papers
21:27:36 <ddarius> lpsmith: The upshot is that for "lazy monads" for a certain type of laziness requires a different monadic style, not a different monad.
21:27:59 <ddarius> I've probably read it before too about a decade ago.
21:28:06 <lpsmith> I don't claim to understand any of them though
21:28:19 <lpsmith> Heh, that's way before I found them
21:28:42 <ddarius> Well, it's probably closer to six or seven years ago.
21:28:53 <lpsmith> that's still way before I found them :)
21:33:41 <Bigglotron> you could read a decade ago? haskell mofos is old.
21:34:40 <ddarius> I could read two decades ago, albeit not terribly well.
21:35:06 <Bigglotron> well i could read a decade ago i guess but it was like... harry potter.
21:36:21 <lpsmith> I could read when I was in Kindergarden, though not well
21:36:24 <Bigglotron> i have this mental block where i think things only start existing when i find out about them and then have to take a step back and comprehend how long ago people actually thought of them.
21:36:54 <lpsmith> so yeah, I could sort of read when I was 5 or so
21:37:26 <lpsmith> I could read basic as well or better than I could read English at the time;  in fact it was probably the basic that did it
21:38:16 <Bigglotron> i didn't encounter basic until i was around 8.
21:38:42 <Bigglotron> but it was 1998 and i had no idea how to compile it.
21:39:06 <edwardk> hrmm i need a better name for a function that takes a function and returns both its answer and first derivative. ideas?
21:39:09 <ddarius> I was probably using BASIC before five or so but I wasn't programming it and I didn't realize it.
21:39:13 <Bigglotron> since we didn't get internet till the next year.
21:39:24 <ddarius> edwardk: "Better name" suggests you have a current name.
21:39:37 <edwardk> right now i'm using barak's "diff2" -- but i didn't want to bias the selection ;)
21:40:07 <edwardk> diff2 suggests to me that it should return the second derivative, not the answer and first derivative
21:40:23 <ddarius> So what's wrong with diff or diff1 ?
21:40:24 <FunctorSalad_> edwardk: tangent?
21:40:26 <djahandarie> diff'' would be even more confusing
21:40:29 <lpsmith> I was playing with BASIC,  the original with line numbers,  when I was 3
21:40:41 <valgrind> Yikes. What took down haskell.org? I'm sure that's been asked 400 times already...
21:40:54 <FunctorSalad_> in the sense of "point in the tangent bundle", which includes both teh value and derivative
21:40:56 <lpsmith> I didn't really start writing my own programs that did something halfway interesting until 6 or 7 though
21:40:59 <edwardk> FunctorSalad_: tangent is being used for extracting the tangent vector from a tangent bundle ;)
21:41:00 <FunctorSalad_> maybe that's too contrived ;)
21:41:06 <FunctorSalad_> oh :(
21:41:37 <Bigglotron> pretangent
21:41:42 <lpsmith> edwardk:   fxdiff... f x diff
21:41:42 <djahandarie> edwardk, answerAndFirstDerivative
21:41:54 <edwardk> djahandarie: hah not very haskelly ;)
21:42:07 <lpsmith> fXdiff
21:42:16 <edwardk> lpsmith: i don't like jamming letters together into a function name. you wind up with perfectly good libraries i can't stant to use that way ;)
21:42:21 <edwardk> er stand
21:42:23 <polux_> hi
21:42:24 <djahandarie> evalDiff
21:42:25 <lpsmith> lol
21:42:30 <djahandarie> Err that is confusing too
21:42:35 <djahandarie> eval&Diff heh
21:42:39 <djahandarie> Is that legal? :P
21:42:46 <ddarius> No.
21:42:53 <portnov> eval'diff
21:42:56 <edwardk> i mean i could name one d and one diff
21:43:00 <polux_> does a library exists that defines a "restricted" notion of monad with bind :: m a -> (a -> ma) -> m a ?
21:43:00 <lpsmith> if haskell had a humane lexical syntax like scheme,  then yess
21:43:01 <ddarius> ord'x'
21:43:04 <edwardk> but its not obvious which would be which
21:43:09 <lpsmith> you could call it id***diff
21:43:17 <lispy> polux_: I don't think so
21:43:25 <djahandarie> f'this
21:43:36 <lpsmith> heh
21:43:55 <polux_> lispy: do you think I can overload the do notation for such a monad ?
21:44:00 <lispy> polux_: yes
21:44:19 <Bigglotron> what's ***
21:44:25 <lispy> polux_: You need to use some GHC extensions and redefine the monad class and hide the one from the prelude
21:44:26 <portnov> :t (***)
21:44:26 <ddarius> Well, in synthetic differential geometry a tangent vector (with base point) is represented just by exponentiating with an atom.
21:44:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:44:42 <polux_> lispy: ok thanks
21:45:09 <lispy> polux_: this blog post should have the secret sauce you need: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
21:45:26 * djahandarie likes secret sauce
21:45:36 <edwardk> I'm currently using diff, diff2, diff2UU, diffF, diff2F, dufU, duf2U, dufF, duf2F, diffM, diff2M, diffs, diffs0UU , diffsF, diffs0F , diffs, diffs0, taylor, taylor0, maclaurin, maclaurin0, grad, grad2, gradWith, gradWith2, gradM, grad2M, gradWithM, gradWith2M, jacobian, jacobian2, jacobianWith, jacobianWith2
21:45:47 <edwardk> I don't like the '2's in any of those really
21:46:04 <ddarius> Sorry the vector space is, a particular tangent vector is just an arrow from an atom.
21:46:08 <edwardk> er and the UU variants don't exist any more
21:46:19 * BMeph likes "fUUD"...
21:46:42 <polux_> lispy: yeah, you mean for overloading the do notation right ? not for the a -> (a -> m a) -> m a type, beacause this is different from the notion of restricited monad in that post
21:46:51 <lispy> edwardk: I haven't been following the conversation, but what about putting the alternatives into modules and then you can give them all the same name and control which one with module imports?
21:47:27 <edwardk> lispy: i have 4 modules full of alternates now for different directions, i'd hate to double that
21:47:30 <lispy> polux_: Well, Following their formula (rebindable syntax, extension, no implicit prelude, redefining Monad class) you should be good to go
21:47:53 <lpsmith> iddiff
21:47:53 <Bigglotron> i do not even remotely understand that type signature
21:48:03 <lpsmith> diffid
21:48:14 <edwardk> i have to admit i kinda like the idea of just priming the ones which include the extra info
21:48:17 <polux_> lispy: do you have any idea how I could reuse all the Control.Monad functions for my simpler notion of monad ?
21:48:41 <lispy> polux_: nope, because the type signatures for many things would be different.
21:48:42 <ddarius> vectorDerivative (\∇ x -> ...)
21:49:21 <edwardk> lpsmith: iddiff is almost viable if verbose for such a common function
21:49:35 <lispy> polux_: Maybe you could do something really weird with TH where you read in the source of those modules, fix up the type signatures, and emit new definitions based on that.  But, it's probably a LOT easier to just duplicate them statically and fix them up
21:50:06 <ddarius> polux_: Many of them wouldn't work with your notion of monad.
21:50:26 <lispy> :t guard
21:50:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:50:29 <lispy> :t when
21:50:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:50:45 <lispy> those two for example, would force the rest of your monad to be type m ()
21:50:53 <edwardk> d, d', dF, dF', dM, dM', grad, gradM, grad', gradM', gradWith, gradWith' -- they wind up short that way
21:50:56 <adu> hi
21:50:59 <djahandarie> Man, I still haven't gotten over how confusing it is that someone in this room has my name in their nick... I keep on think I'm talking
21:51:07 <lispy> So, eventually, I would assume every use of your monad degenerates to m ()
21:51:29 <lispy> djahandarie: Yeah, it's confusing for me when people refer to this or that as being lispy
21:51:48 <djahandarie> lispy, the only thing is that _I_ don't have my (first) name in my nick
21:51:54 <djahandarie> ddarius does though :P
21:52:01 <lispy> djahandarie: aaah
21:52:12 <ddarius> Well consider something like mapM.  mapM f [] = return []; mapM f (x:xs) = do x' <- f x; xs' <- mapM f xs; return (x':xs')  The f x and mapM f xs lines wouldn't be able to be together.
21:53:46 <lispy> oh, yeah, constructing infinite type is hard in Haskell
21:54:30 <polux_> ddarius: which one for instance ?
21:55:01 <polux_> i have the impression that my notion of monad is just a special case
21:55:16 <lispy> polux_: mapM  example ^^
21:55:23 <lispy> ?src sequence
21:55:23 <lambdabot> sequence []     = return []
21:55:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:55:23 <lambdabot> --OR
21:55:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:55:50 <lispy> sequence has the same problem as mapM?
21:56:28 <ddarius> polux_: Your notion of "monad" doesn't even allow join to be defined.
21:56:52 <lispy> :t join
21:56:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:57:01 <polux_> yes ok, in the same way that I have a special version of Monad, the definition of mapM works with a special version of the type signature of mapM
21:57:06 <polux_> lispy: yeah right..
21:57:36 <polux_> i'm implementing a paper that has that special notion of moand but at the same time they define join...this is weird
21:57:37 <ddarius> polux_: No, the issue isn't f :: a -> m b, it's that f x :: m a and mapM f xs :: m [a]
21:57:44 <polux_> I have to look at their version of join
21:58:08 <ddarius> polux_: join can simply be added, but it is no longer defineable as (>>= id)
21:58:57 <polux_> oh yes
21:59:02 <polux_> right
21:59:22 <polux_> ok, thank you for all your remarks and answers
21:59:39 <polux_> I wonder if that special case has been studied somewhere
22:04:23 <ddarius> Again, it's not a special case.  It's a different structure.
22:04:26 <ville> Something strikes me as odd with my imperative background, reading real world haskell and don't recall any talk about object lifetime?
22:04:57 <ezyang> ville: Haskell GC'ed, like most modern languages 
22:05:11 <ville> That explains it then.
22:05:14 <lispy> ville: Not all computations have to terminate in a Haskell program
22:05:45 <lispy> ville: So sometimes it's tricky to know when an object has reached its end
22:06:09 <ddarius> Not all computations have to terminate in most languages...
22:06:10 <ezyang> Laziness does make figuring out when stuff gets GC'ed a tad tricky, but then again backtraces ahve been known to lead to space leaks in Python programs, so I think it's a global problem :-) 
22:06:17 <Gracenotes> some C FFIs define a withXXX method, which allocate data, run code on data, and deallocate
22:06:35 <lispy> oh yeah, bracket et al are good for scoping resources
22:06:36 <Gracenotes> but those are largely for Haskell to match the imperative program's semantics
22:06:49 <Gracenotes> or use the nice general version :)
22:06:56 <ddarius> Dynamic memory management in general makes object lifetimes difficult to predict in a Turing-complete language.
22:07:01 <lispy> You can also use a left fold style (iteratees being one well discussed example)
22:07:57 <lispy> ville: You're used to C++V
22:07:59 <lispy> er
22:08:01 <lispy> C++?
22:08:38 <ville> Yes I've ~15 years of C++ experience. ( I know there hasn't been a standard for more than 12 )
22:08:55 <lispy> ville: okay. Well, you know how it's safe to grab 1 resource inside a constructor?
22:09:28 <ddarius> There hasn't been a standard for Python, say, ever, but that doesn't mean you can't claim any years of experience with it.
22:09:49 <lispy> ville: the analog of that sort of object creation/destruction to scope resources life times is pretty much exactly what bracket does in Haskell
22:10:22 <ddarius> lispy: C++'s destructor mechanism is pretty unique to it.
22:10:50 <ville> lispy: bracket?
22:10:54 <lispy> :t bracket
22:10:55 <lambdabot> Not in scope: `bracket'
22:11:00 <lispy> ?hoggle bracket
22:11:00 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:11:00 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:11:00 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:12:00 <ville> ddarius: Just playing it safe, if you recall the "looking for Java programmer with 5 years of experience" when the language hadn't been out for 3 years.
22:12:09 <lispy> ddarius: the point is that C++ gives you a mechanism to control the lexical scope of a resource.  We have that too.
22:12:47 <ddarius> lispy: And my point is bracket and similar things don't really give you the same thing as C++'s destructors, though they certainly cover a common case.
22:12:58 <lispy> ville: for example: http://www.zvon.org/other/haskell/Outputio/bracket_f.html
22:13:09 <ville> googled my self there already
22:13:18 <jethr0> I am currently "iterating" over a list of items and would like to abort the iteration on certain conditions.
22:13:38 <jethr0> what would you say is the most straightforward way of doing this? continuation monad?
22:13:55 <ddarius> jethr0: Probably the most obvious thing would be an Either monad.
22:14:12 <lispy> ville: we also have finalizers (which probably covers some of the other cases ddarius has in mind)
22:14:23 <lispy> ?hooge finalizer
22:14:23 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
22:14:23 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
22:14:23 <lambdabot> Foreign.ForeignPtr type FinalizerPtr a = FunPtr (Ptr a -> IO ())
22:14:31 <ddarius> lispy: No, it does not.  Again, C++'s destructor system is pretty unique to it.
22:14:43 <lispy> ddarius: then what do you have in mind?
22:14:44 <ddarius> lispy: Sorry, it does cover -some- sort of.
22:14:53 <jethr0> do {x <- Left [1,2,3]; guard (/=2)} ?
22:16:01 * hackagebot ad 0.17 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.17 (EdwardKmett)
22:16:14 <ddarius> edwardk: Did I miss 0.16?
22:16:31 * lispy assumes edwardk is on a hyperfocus
22:16:49 <edwardk> ddarius: it may have been an internal version bump that didn't see hackage
22:17:17 <edwardk> i have a patch-tag repo that gets spammed more frequently that a pearlmutter and co. use
22:17:41 <lispy> edwardk: patch-tag is pretty good?
22:17:45 * lispy hasn't tried it yet
22:18:05 <edwardk> its something other than comonad.com and other people can upload to it without me having to be the gatekeeper of all patches
22:18:16 <lispy> but I am slightly envious of how ubiquitous github is
22:18:29 <edwardk> i've managed to integrate it into my workflow and can't really complain about the result.
22:19:06 <lispy> "I wrote some code you might want to try."  "Oh, what is your username on github?"
22:19:14 <edwardk> lispy: hah
22:20:02 <lispy> The response at that point is like when I tell a starbucks employee I don't drink coffee, or tell a geek I don't have twitter, or ...
22:20:24 <ddarius> lispy: Finalizers don't give you any sort of deterministic finalization.  Oddly, C++ is somewhat safer than many of the bracket approaches because resource is identified with its reference and so you can't hold an invalid resource, e.g. a closed handle from bracket.
22:20:48 * ddarius doesn't drink coffee.
22:20:57 <ddarius> And I've gone to Starbucks a decent amount.
22:21:14 <lispy> ddarius: me too, I end up buying yogurt and oatmeal there fairly regularly
22:22:21 <lpsmith> I don't drink coffee often
22:22:43 <lpsmith> but I do love coffee once in a while
22:23:24 <lispy> ddarius: finalizers now run when the GC runs, which helps make them at least useful now, even if not deterministic
22:28:34 <FunctorSalad> is there a solution for this issue where cabal-install reinstalls certain base packages with a different ABI, breaking lots of stuff?
22:29:03 <FunctorSalad> example reinstalled base package: network
22:29:06 <FunctorSalad> sometimes random
22:29:41 <ezyang> I've broken my cabal install with somethign that sounds like that 
22:29:44 <FunctorSalad> (`random')
22:29:52 <ezyang> Basically, cabal was too eager to upgrade packages that it shouldn't have upgraded.. 
22:30:31 <lispy> were you using cabal upgrade?
22:30:34 <FunctorSalad> `shpider' is an example package which causes reinstallation of `network'
22:30:51 <lispy> FunctorSalad: what type of breakage do you see?
22:31:34 <FunctorSalad> lispy: nope, ezyan: I don't think it's that; it is that some packages cause reinstallation of the base package with different flags or dependencies or whatever else difference there is; the network version is 2.2.1.7 with either of the two ABIs
22:31:51 <FunctorSalad> I don't mean the `base' package, I mean packages tied to ghc
22:31:53 <FunctorSalad> like network
22:32:07 <FunctorSalad> lispy: ghc-pkg check
22:32:24 <FunctorSalad> claims that some pkgs are broken due to network-2.2.1.7-$ABI not existing
22:32:30 <FunctorSalad> after said incident happens
22:32:40 <lispy> FunctorSalad: I've never experienced that
22:32:48 <lispy> Sounds unfortunate
22:32:50 <Berengal_> FunctorSalad: Do they 
22:33:07 <Berengal_> *exist in both user and global pkg-repos
22:33:13 <FunctorSalad> lispy: maybe you can reproduce it with "cabal install shpider" followed by "cabal install network"
22:33:26 <FunctorSalad> Berengal: nope, purely global setup
22:33:59 <FunctorSalad> lispy: the former will install some network-2.2.1.7, then cabal install network will install the 'normal' network-2.2.1.7  again
22:34:23 <FunctorSalad> btw shpider fails because tagsoup-parsec does, but that's not the point
22:34:35 <FunctorSalad> I've seen the same with other pkgs than shpider
22:34:48 <lispy> FunctorSalad: yeah, I can't get far enough to install network
22:34:59 <lispy> but my package database is old
22:35:10 <FunctorSalad> ah. for me installing shpider it does network first
22:35:17 <FunctorSalad> s/\bit\b//
22:35:56 <lispy> I only have network-2.2.1.7 globally.  Maybe that's why it's different for me?
22:36:06 * hackagebot ad 0.18 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.18 (EdwardKmett)
22:36:13 <lispy> FunctorSalad: I'm on ghc 6.12.1
22:36:20 <lispy> (maybe I should upgrade?)
22:36:50 <FunctorSalad> lispy: "only globally"? I have only a global package database too
22:37:07 <FunctorSalad> lispy: but no ABI? I mean for example if you "ghc-pkg describe network"
22:37:11 <FunctorSalad> I get id: network-2.2.1.7-f093d7431bcdb27d26ac66048bf446cb
22:37:17 <lispy> ah, I install everything user
22:37:25 <lispy> how did you get that?
22:37:55 <lispy> oh n/m
22:37:55 <lispy> ido: network-2.2.1.7-26c5451dfd3b0cb3cdfbb0ee136642c1
22:38:10 <FunctorSalad> after c-i shpider: id: network-2.2.1.7-ea4c90e3415be421311952f340195f0d
22:38:25 <lispy> how are those generated?
22:38:41 <FunctorSalad> ah so you have yet another one, but the point is, I think, that some packages depend on the first network I pasted, while others depend on the second...
22:38:46 <FunctorSalad> and only one can be installed at a time
22:39:03 <FunctorSalad> lispy: looks like some hash digest, of, AFAIK, the interface
22:40:16 <lispy> FunctorSalad: well, is the hash convergent?  Also, does it depend on OS specific things?
22:40:48 <FunctorSalad> lispy: what's a convergent hash?
22:41:23 <lispy> FunctorSalad: I might be misusing terminology, but my understanding is that if it's convergent then given 'the same inputs' it gets the same result
22:41:44 <lispy> FunctorSalad: so one that uses random bits would not be convergent in my sense, because I'm not including those bits in the input
22:42:01 <FunctorSalad> lispy: you might well be correct (I'm not a hash expert either), but I'd call that "deterministic" :) which all hashes are
22:42:37 <lispy> FunctorSalad: GUIDs are not convergent but look visually like hashes
22:42:49 <lispy> FunctorSalad: (that is, GUIDs in the microsoft sense)
22:43:40 <FunctorSalad> lispy: if I reinstall network by itself again, I get the old hash again (f093d...), so the answer is probably "yes" :)
22:44:09 <lispy> FunctorSalad: interesting
22:44:13 <FunctorSalad> (as it should be... you just want to identify a particular way of building the package, not a particular build event)
22:44:54 <FunctorSalad> I think this scheme was added to have more fine-grained dependencies that take stuff like flags and ifdef-caused differences into account...
22:45:41 <FunctorSalad> the problem is that existing packages in the database break if you reinstall e.g. network with slightly different "options" (as shpider does)
22:45:53 <FunctorSalad> (I don't know which options are different)
22:46:57 <lispy> Okay right.  So, I'm not convinced it's the best way to solve this problem.
22:47:16 <lispy> But...it's hard to propose something with finer granularity :)
22:47:24 <FunctorSalad> than versions?
22:47:49 <FunctorSalad> (and coarser than hashes, I suppose)
22:48:05 <ksf> http://bddbddb.sourceforge.net/
22:48:36 <lispy> FunctorSalad: Well, version + compilation flags in a format you can compare the flags and versions numbers would be sweet
22:48:48 <lispy> FunctorSalad: Including platform and other fiddly bits
22:50:53 <edwardk> ksf: what about it?
22:51:11 <ksf> I just found it worthwile to mention
22:51:17 <ksf> and I rarely drop links to #haskell
22:51:31 <edwardk> no worries, just curious about the mention =)
22:52:01 <edwardk> you may be curious to find that a lot of folks who were using robdd's for everything have switched, for instance in the datalog community
22:52:22 <ksf> it might be particularily interesting to a) compiler guys b) meat-based logical systems, so I guess this is the right audience
22:57:28 <ski> FunctorSalad : ah, ok (re "function values" -- i've heard "value of a function (in a point)")
22:58:09 <ski> (edwardk : have switched to what ?)
22:58:22 <tensorpudding> it seems that there's always at least one major haskell website down at a time
22:58:37 <ddarius> This is quite late, but, I think it was the Dean and Deluca a block away from the Shin-Marunouchi building that I went to that was amazing.  (Also, Google seems to have a "3D mode" now...)
22:58:59 <edwardk> ski: basically to relational algebra backends
23:00:51 * ksf suspects that's because of too much research in relational technology
23:00:58 <ksf> aka the gcc pit.
23:00:59 <edwardk> ski: http://doop.program-analysis.org/ (docs at http://doop.program-analysis.org/documentation.html )
23:01:24 <ksf> I'm no database expert, but I never liked those tables
23:01:36 <edwardk> ksf: actually go through the NEPLS paper in the doc link there. bravenboer made a pretty darn convincing case that bdd's have trouble scaling if you make your analysis more precise
23:01:50 <edwardk> the delta sets you get from the relational version scale better
23:02:22 <ksf> choosing how to express things just seems arbitrary and awkward
23:02:50 <ezyang> Aren't BDDs exponential in construction time? 
23:03:50 <Gracenotes> huh. apparently RecordWildCards doesn't play nice with warning about names not being used
23:04:10 <Gracenotes> I suspect it is a dirty hacky backend transformation... oh, I've been deceived! -.-
23:05:57 <Gracenotes> then again, I suppose it behaves as expected.
23:07:17 <ski> Saizan : SYN
23:08:43 <Saizan> ski: SYNACK ?
23:08:57 <ddarius> Also pretty late, I think a substructural system akin to the URAL system, specifically the linearly type capability aspect, would allow us to get the control of and even more flexibility than the C++ RAII pattern in a way that would fit with Haskell.
23:09:45 <ski> Saizan : ACK. were it you who were talking about `((b -> o) -> (a -> o)) -> (((t -> b) -> o) -> ((t -> a) -> o))' some days ago ?
23:09:49 <djahandarie> Hm, I can't have BS.empty in a case statement?
23:09:51 <edwardk> URAL with uniqueness perhaps ;)
23:10:00 <djahandarie> "Bot.hs:163:5: Qualified name in binding position: BS.empty"
23:10:06 <djahandarie> BS being ByteString
23:10:34 <FunctorSalad> dequalify it ;)
23:10:35 <edwardk> uniqueness (with strictness info) provides you with the ability to edit values directly in memory
23:10:50 <edwardk> once that will be inspected by multiple users later
23:10:54 <edwardk> er ones that
23:10:55 <FunctorSalad> hmm wait
23:11:02 <Gracenotes> djahandarie: still.. you can have constructors or numbers in case statements
23:11:03 <FunctorSalad> djahandarie: nvm, I was confused
23:11:11 <Saizan> ski: i think so, i was asking djinn for the Not . Not of that, right?
23:11:14 <Gracenotes> and bytestring hides its constructors :/
23:11:26 <ski> djahandarie : you can't match on non-constructors, if that's what you're attempting
23:11:32 <ddarius> edwardk: That aspect may not be that important for resource management, particularly reclamation.  You may only need the relevant modality.
23:11:36 <djahandarie> ski, it is
23:11:52 <djahandarie> Normally -XOverloadedString would work, but that doesn't work with "" for some reason
23:12:03 <edwardk> ddarius: relevant is almost never what you want scott domain style strictness subsumes it
23:12:06 <ski> Saizan : yes. my brother proved (basically) that in (classical) linear logic, and i translated it to a nicer form
23:12:47 <Saizan> ski: oh, cool, how does it look?
23:13:13 <edwardk> ddarius: relevance says that it is never weakened in any context. you really only care that in each context it is used at least once, strictness analysis is an 'any' rather than an 'all' and is trickier but more useful
23:13:47 <edwardk> relevance + uniqueness lets you know it is not only safe to mutate in place, but that you should because you'll need the answer.
23:14:17 <ski> Saizan : more concretely, we proved `(B -o O) -o (A -o O) |- ((T -> ?B) -o O) -> ((T -o A) -o ?O)'
23:14:30 <edwardk> strictness + uniqueness proves the same thing
23:14:41 <edwardk> but permits more scenarios, all of which are safe
23:14:49 <ski> Saizan : where `X -> Y' (`->' occurs twice above) is basically the same as `!X -o Y' (intuitionistic implication)
23:14:59 <FunctorSalad> logicians are using GNU find notation now? ;)
23:15:03 <FunctorSalad> ("-o")
23:15:34 <ski> FunctorSalad : `-o' is the linear implication of Girard's Linear Logic (`-o' is affectionately known as "lollpop")
23:15:54 <FunctorSalad> ok. I need to learn about that too ;)
23:17:50 <ski> Saizan : the proof term proving the above sequent is `bo_ao |-> (\! tb_o |-> (\ ta |->? bo_ao (\b |-> tb_o (\! _ |->? a)) (ta t) | tb_o (\! t |->? ^)))'
23:18:13 <ski> (that's using natural deduction, with right introduction and right elimination rules)
23:18:30 <Saizan> ski: !X -o Y means that you can use X multiple times, right? i'm a bit clueless about ? though
23:18:54 <ski> Saizan : yes, you can use `X' as many times as you like when proving `Y'
23:19:01 <ski> (including zero times)
23:19:55 <Saizan> X -o ?Y means that you can return multiple Y, perhaps?
23:20:18 <ski> yes, multiple *interacting* `Y's
23:20:50 <ski> (which `Y' one of them happens to be can depend on how you *use* another of them)
23:20:56 <applicative> djahandarie, did you try BS.Empty -- the constructor?
23:21:24 <Saizan> (ah, tricky)
23:21:44 <ski> the amount of `!'s (i.e. `->'s in this case) and of `?' expresses how far the above is from the "pure" version, with no `!' and `?' at all complicating things
23:22:47 <djahandarie> applicative, oh, that exists? No I didn't, thanks
23:23:01 <ski> Saizan : `\! x |-> e' has type `!X -o Y' (alt. `X -> Y') iff assuming `x : !X' (roughly), we can show that `e : Y'
23:23:20 <blackdog> anyone know what happened to Data.Generics.Instances in HEAD ghc?
23:23:32 <ski> Saizan : similarly `\ x |->? e' is used to introduce `X -o ?Y'
23:24:19 <JoeyA> > [x | x <- [0..10], x `mod` 2 == 0]
23:24:20 <lambdabot>   [0,2,4,6,8,10]
23:24:26 <JoeyA> Is there a way to do that with do syntax?
23:24:30 <ski> Saizan : `_' is the discarding pattern, which can only be used on inputs with type of form `!X', while `^' is the "failing expression", which can only be used as an expression of type of form `?Y'
23:24:42 <JoeyA> > do {x <- [0..10]; x `mod` 2 == 0; return x}
23:24:43 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:24:43 <lambdabot>         against inferred type ...
23:24:57 <ski> Saizan : `... | ...' combines two expressions of type `?Y' into one expression of that type
23:25:06 <Veinor> > do {x <- [0..10]; guard $ x `mod` 2 == 0; return x}
23:25:07 <lambdabot>   [0,2,4,6,8,10]
23:25:17 <Saizan> ski: btw, where is 'a' coming from in the proof above?
23:25:47 <applicative> djahandarie, wait, Empty exists for lazy bytestrings.  Man what a nightmare these swank modern libraries are.
23:26:12 <ski> Saizan : oh, sorry, i copied that off wrong (i was supposed to switch all `a's and `b's) .. that single `a' in `(\! _ |->? a)' should be a `b'
23:26:40 <djahandarie> Heh
23:27:16 <JoeyA> thanks
23:27:36 <ski>   bo_ao |-> (\! tb_o |-> (\ ta |->? bo_ao (\b |-> tb_o (\! _ |->? b)) (ta t) | tb_o (\! t |->? ^)))
23:27:39 <blackdog> any kind of guide for converting from base-3 packages to base-4?
23:27:40 <ski> (corrected)
23:28:13 <ski> Saizan : still, note that the scoping of `t' appears "weird" :)
23:28:27 <Saizan> ski: yeah, pretty weird :)
23:29:08 <JoeyA> @undo {x <- [0..10]; guard $ x `mod` 2 == 0; return x}
23:29:08 <lambdabot>  Parse error at "{x" (column 1)
23:29:10 <ski> that's because the `t' is bound in one branch of the `... | ...' (which combines two `?Y' things), and it is then available in the other branch, because of the interaction
23:29:17 <JoeyA> @undo do {x <- [0..10]; guard $ x `mod` 2 == 0; return x}
23:29:17 <lambdabot> [0 .. 10] >>= \ x -> guard $ x `mod` 2 == 0 >> return x
23:29:34 <FunctorSalad> blackdog: no real answer, but... set "base >= 4" in .cabal, cabal install, get not-found error, add dep, repeat? ;)
23:29:41 <Saizan> ski: do you have to have at least an alternative that's not ^ ?
23:29:54 <ski> that's not what ?
23:29:55 <FunctorSalad> possible change Control.Exception to Control.OldException
23:30:03 <JoeyA> > [0 .. 10] >>= \ x -> guard $ x `mod` 2 == 0 >> return x
23:30:04 <lambdabot>   Couldn't match expected type `m a'
23:30:04 <lambdabot>         against inferred type `GHC.Bool....
23:30:20 <blackdog> FunctorSalad: right, that's basically what i'm doing. just hoping to skip some pain - haskell-src seems to require base 3, and when you change it to base 4, it complains about Data.Generics.Instances not being there any more
23:30:23 <Saizan> ski: that doesn't end with a "^", the failing expression
23:30:29 <blackdog> and i can't seem to find anything about where it might have gone
23:31:19 <Saizan> blackdog: in syb
23:32:22 <ski> Saizan : the `^' and the `_' wouldn't be needed at all here, if certain other parts of the computation/proof wasn't "in the way" (basically, one input has to be duplicated, just to be discarded in one branch; similarly one output has to be merged from two outputs, just to have one of those be the failing output, in one branch)
23:32:52 <blackdog> Saizan: cheers, i'll check that out.
23:34:34 <Saizan> ski: yeah, but i was wondering if (!A -o ?B) was provable simply by (\! _ |-> ^)
23:35:04 <applicative> djahandarie, I see, just noise: the constructors of lazy bytestrings are not exported. Or so it seems.  We're just the 'users'.
23:35:42 <c_wraith> applicative, they should be in the Internal package.  But that's documented to *not* be stable, so beware of using it.
23:35:48 <applicative> yeah
23:35:57 <ski> Saizan : yes, it'd be
23:36:18 <djahandarie> lol
23:36:26 <FunctorSalad> blackdog: maybe haskell-src-exts is a good replacement?
23:36:42 <djahandarie> I wonder why -XOverloadedStrings isn't working for ""
23:37:35 <djahandarie> Oh, HA! It was, I was doing something unrelated wrong :D
23:37:51 <FunctorSalad> djahandarie: it is
23:38:16 <ski> Saizan : the only sub-formula above i see where that could be used (directly), though is `T -> ?B' (i.e. `!T -o ?B'), and to prove that that way, we'd have to replace the `B -o O' with `!B -o O' (since that's where the `B' in `!T -o ?B' comes from)
23:38:24 <applicative> c_wraith, i was looking at the source for the export module and formed the false idea that empty = Empty, one could write "Empty".  God forbid we should pattern match on 
23:38:39 <applicative> God forbid we should pattern match on "PS nullForeignPtr 0 0
23:38:39 <applicative> "
23:38:48 <blackdog> FunctorSalad: nah, checked that - it seems to be doing different things...
23:39:17 <ski> Saizan : another way of presenting the proof (in the sequent style, with left- and right- introduction rules) is `(\ (\ b |-> o1) |-> (\ a |-> o)) |-> (\! (\ (\! _ |->? b) |-> o1) @ (\ (\! t |->? ^) |-> o0) |-> (\ (\ t |-> a) |->? o0))'
23:39:23 <FunctorSalad> blackdog: it isn't a superset?
23:39:24 <blackdog> at least, the module hierarchy is very different
23:39:43 <FunctorSalad> that may be because it has several flavours of AST ;)
23:39:57 <ski> (Saizan : where `@' is like haskell's "at/as - patterns", except we allow both patterns to be compound)
23:40:12 <blackdog> FunctorSalad: hm, fair enough - i'll give it a go
23:41:38 <ski> Saizan : hm, it seems i misparsed your "do you have to have at least an alternative that's not ^ ?" before .. well, i don't think we can get away with proving this with an "always failing proof"
23:42:26 * hackagebot ad 0.19 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.19 (EdwardKmett)
23:42:29 <edwardk> added ad-mode composition
23:42:45 <ski> Saizan : if you'd like, i could paste the actual derivation tree these expressions were derived from ..
23:42:48 <Saizan> ski: it was mostly a general curiosity about "^", it felt too easy to have ^ working for any ?X
23:43:12 <blackdog> FunctorSalad: my problem with all of this is that I want to be able to tell my users "run cabal install hubris, and robert is the brother of your mother." it's very hard to do if you've got to patch cabal files all along the way - would it be rude to fork them and chuck clones on Hackage?
23:43:15 <Saizan> ski: hah, i'm not really good at reading derivation trees anyhow :)
23:43:38 <blackdog> in a way we need a slightly more decentralised package system - github style or something.
23:43:50 <ski> Saizan : in this case, i don't think there's an "easy way out" trying to use `^ : ?Y'
23:44:34 <ski> Saizan : since we can't prove `|- ^ : ?Y' we can't prove it from scratch .. only if we have already proved that (multiplicative) false, can we prove `^ : ?Y'
23:45:32 <ddarius> Probably a lot more readable than ski's asciifications.
23:45:36 <FunctorSalad> blackdog: I have no idea whether it'd be rude, and I've found the situation a bit annoying too (that there's no way to make trivial patches to packages without contacting the owner)
23:46:24 <Saizan> blackdog: you can start your own hackage server if you want :)
23:46:44 <applicative> djahandarie, where a stringy thing is a list "" == [], a constructor. But bytestrings aren't given to us that way, of OverloadedStrings doesn't know what to do with it. 
23:46:47 <applicative> So it seems
23:47:04 <ski> Saizan : this roughly corresponds to my idea about writing the "impossibly case" in Agda2 for `at : {A : Set} -> (n : |N) -> Vec A n -> Fin n -> A' as `at Zero _ ^ = ^' rather than as `at Zero _ ()'  (so, we can only use the failing expression `^', if we have already successfully matched on the failing pattern `^')
23:47:06 <djahandarie> applicative, no, I got it working
23:47:13 <djahandarie> applicative, I was doing something else wrong in my code
23:47:16 * copumpkin yawns
23:47:19 <blackdog> Saizan: it's a bit extreme:) i think the fewer barriers to contribution we have the better - i've noticed i'm much more likely to contribute patches to github based sites, as opposed to code.google.com or *spit* sourceforge projects
23:47:36 <sshc> WHat is the nam of the function in Data.Bit that performs the same function as C's ~ bitop?
23:47:41 <applicative> djahandarie, okay now I will try it...
23:47:55 <sshc> Inversion of bits
23:47:58 <ddarius> complement
23:48:01 <ski> ddarius : well, i was of course thinking about pasting an asciifications of a derivation tree (with `------'-inference-lines) :)
23:48:28 <sshc> ddarius: Thanks
23:49:22 <Saizan> blackdog: well, contributed patches still need to get accepted by the maintainer before your users can make use of them no? unless you make your own release
23:50:44 <blackdog> Saizan: yes, but if it's trivial to fork and host on github, you can fork everything you need - you're not hostage to the maintainer
23:52:26 <Saizan> blackdog: and users manually clone etc? or do other "cabal-install" things can usually be instructed to fetch packages directly from a git repo?
23:53:46 <Saizan> anyhow, it's not like it's hard to fork on hackage :)
23:53:59 <Saizan> more persistent, though
23:54:08 <blackdog> Saizan: bundler can do that, yes.
23:54:25 <blackdog> yeah, it's there forever
23:55:04 <blackdog> i wouldn't mind forking it on github because it's not in anyone's way, but it'd be embarrassing for people to have bugs because they didn't realise mine's a fork.
23:55:11 <blackdog> (on hackage, that is)
23:55:12 <ski> Saizan : hm, my bro suggested removing the `!'s, replacing `-o' with `->' and replacing `?' with intuitionistic double-negation, and then trying to prove (or adapt the proof) to intuitionistic logic ..
23:56:02 <ski> Saizan : anyway, i just wanted to share the proof, and that you actually *can* prove it, with a few modifications, in classical linear logic (which is a constructive logic)
23:57:29 <blackdog> FunctorSalad: haskell-src-exts seems mostly compatible, but not entirely. dammi.t
23:57:33 <lpsmith> ski:  do you understand CbN monadic style?  a -> b becomes m a -> m b instead of a -> m b?
23:58:01 <ski> i would assume it to be "similar to CbN CPS
23:58:12 <ski> (i haven't considered it much)
23:58:15 <AshleyS> Hello, is this a channel where noobs can get help learning Haskell?
23:58:24 <dibblego> AshleyS, yes definitely
23:58:24 <lpsmith> do you understand CbN CPS then? :)
23:58:25 <ski> AshleyS : yes, what is your question ?
23:58:30 <edwardk> AshleyS: very much so
23:58:58 <ski> lpsmith : with a little thought, i can reconstruct the translation rules, i think :)
23:59:02 <blackdog> jeez, fellas. just once, we could be horrible to a newbie. i bet shapr wouldn't even notice.
23:59:07 <lpsmith> heh
23:59:28 <blackdog> come back, i was kidding...
