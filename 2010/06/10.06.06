00:00:15 <FunctorSalad> "<blackdog> Saizan: it's a bit extreme:) i think the fewer barriers to contribution we have the better" <-- agreed...
00:00:43 <Saizan> you don't need to create a whole new server btw, just one with your forks.
00:00:50 <pastorn> @pl f g = mkVty >>= \v -> govern g v >>= \x -> shutdown v >> return x
00:00:50 <lambdabot> f = (mkVty >>=) . (`ap` ((. return) . (>>) . shutdown)) . ((>>=) .) . govern
00:00:58 <Saizan> it's a bit less extreme :)
00:01:02 <pastorn> maybe not...
00:01:10 <ski> lpsmith :  [| x |] = x  [| \x. M |] = \k. k (\x. [| M |])  [| M N |] = \k. [| M |] [| N |] k  iirc
00:01:27 <ski> hm
00:01:32 <blackdog> Saizan: that's just about as much work, really. maybe a bit less bandwidth.
00:01:46 <lpsmith> that looks vaguely like Reynold's transform
00:01:49 <lpsmith> I'd have to check...
00:01:54 <ski>   [| M N |] = \k. [| M |] (\m. m [| N |] k)   -- actually
00:03:06 <ski> lpsmith : i think i'd have to look at the CbV monadic style first, to recall what is it we'd want in CbN monadic style
00:03:19 <edwardk> gah, no instance for Traversable ((,) a) ?
00:03:27 <Saizan> blackdog: if we have transient forks, i guess we also need some notion of merge? so that if some package depends on Foo-0.1-somefork, and Foo-0.2 says that it merged somefork in, cabal-install can use the latter when the former vanishes?
00:03:36 <edwardk> or (Traversable (Either a)) ?
00:03:54 <ski> > Data.Traversable.traverse (^ 2) (3,4)
00:03:55 <lambdabot>   No instances for (GHC.Num.Num (f b),
00:03:57 <lambdabot>                    Data.Traversable.Tr...
00:04:02 <Saizan> blackdog: or do we just let these packages break in the hope a new release is made when a fork is retracted?
00:04:06 <blackdog> Saizan: I don't think you need to cater for that case
00:04:27 <FunctorSalad> you could name the fork by the version number
00:04:29 <edwardk> >traverse pure (1,2)
00:04:37 <FunctorSalad> that's slightly decrease the 'stays there forever' problem
00:04:46 <FunctorSalad> (people would see at one glance that it's out of date)
00:05:03 <ski> AshleyS_ : so, what is your haskell question ?
00:05:42 <ski> AshleyS_ : if you have no question right now, you're welcome to just idle a bit :)
00:05:58 * Saizan wonders how/if they handle this on CPAN
00:06:07 <lpsmith> ski, so ddarius and I have discussed a "CbN Contination Monad" a few times,  and he claims that I don't need to change the monad,  but rather change the way I use it
00:06:13 <edwardk> (now that i've got ad mode-composition, i wanted to extend things like the cheesy newton's method extremum finder to actually give back the result of the internal function, which i need to plumb it out via a traversable of some kind
00:06:18 <lpsmith> Unfortunately,  I don't see how,  and I don't know of an example
00:06:24 <edwardk> and (,) fit the bill
00:06:40 <blackdog> I kind of like the cheap-arse github method (I know i've said that a lot) - the main line doesn't know anything about it, it just gets its dependencies from the individual repos. the problem there is that it's hard to do dependency analysis before the fact - you just have to try it.
00:06:42 <ski> lpsmith : instead of writing functions `foo :: A -> B -> M C' write functions `foo :: M A -> M B -> M C'
00:06:49 <lpsmith> right
00:06:53 <lpsmith> thats what ddarius said
00:07:00 <ski> heh
00:07:06 <lpsmith> :)
00:07:13 <blackdog> i guess we just keep coming back to the question of whether we're living in an open package ecosystem or a closed one
00:07:26 <blackdog> at the moment it's definitely closed
00:07:53 <blackdog> (not in the sense that you can't put up anything you like - just that the central repo expects to Know All)
00:08:09 <Saizan> what i don't see is how .cabal files and cabal-install should handle these forks
00:08:35 <dhun> I build my own parser based on parsec and some wired stuff of my own, it does what I want, but I did a rough test and found that happy seems to be 30 times faster
00:08:56 <Saizan> well, you can have libs installed in some other way, it just won't look for the dependencies for you
00:09:13 <blackdog> Saizan: in an open system, you'd say you have dependencies on http://my_repo_server.com/some_repo/#branch
00:09:15 <Saizan> but we can have cabal-install take directories/tarballs/repos on the command-line
00:09:15 <ski> AshleyS : having connection troubles ?
00:09:31 <lpsmith> ski,  I don't suppose you have any suggestions for an attempt at coming up with a simple concrete example... most of my uses of laziness are a bit more... involved
00:09:33 <FunctorSalad> btw @ Saizan , blackdog : is the hackage branch currently in use frozen or something? somehow everyone has good ideas for it but it hasn't changed in a looong time;)
00:09:34 <AshleyS> Yeah, I was trying to use a Chrome Extension IRC client.
00:09:53 <Saizan> FunctorSalad: Gracenotes is doing his GSoC on it
00:09:54 <FunctorSalad> (I understand that there's a complete overhaul under dev, but until then it might help to fix the current one)
00:09:57 <AshleyS> It kept closing the connection everytime the extension was minimised
00:09:58 <FunctorSalad> ah
00:10:35 <Saizan> blackdog: but you jsut said you don't want to create another server :)
00:10:56 <blackdog> Saizan: when i say my_repo_server, of course i mean github.com:)
00:11:09 <blackdog> i just don't want to come across as a shill
00:11:15 <lpsmith> ifM seems a little too boring
00:11:21 <lpsmith> :t ifM
00:11:22 <lambdabot> Not in scope: `ifM'
00:11:28 <Saizan> blackdog: ah, k, that kind of repo
00:11:28 <lpsmith> :t Control.Monad.ifM
00:11:29 <lambdabot> Not in scope: `Control.Monad.ifM'
00:11:51 <Saizan> blackdog: if you add a revision number that might actually be sane
00:13:04 <AshleyS> I have come onto the channel to ask someone to help me port a lil bit of Python/Psuedo code over to Haskell. Here is the python-like code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25936#a25936. Here is what I have written so far: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25937#a25937. I would appreciate anyone who is willing to help me. If you write any code, please heavily document it.
00:13:33 <ski> lpsmith : hm, nothing immediately pops my mind, no ..
00:13:36 <FunctorSalad> blackdog: hackage.haskell.org isn't hardcoded into cabal-install I think
00:13:46 <FunctorSalad> but I wouldn't want to put my own hackage up either ;)
00:14:15 <Saizan> it's not, and you can have more than one configured at once
00:14:24 <FunctorSalad> (that was just @ open/closed)
00:16:12 <blackdog> AshleyS: you might get more help with more specific questions
00:16:53 <lpsmith> @let ifM' g a b = g >>= \bool -> if bool then return a else return b
00:16:54 <lambdabot>  Defined.
00:17:07 <lpsmith> :t ifM'
00:17:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> b -> b -> m b
00:17:30 <lpsmith> @let ifM g a b = g >>= \bool -> if bool then a else b
00:17:31 <lambdabot>  Defined.
00:17:35 <FunctorSalad> blackdog: right now I'd go with forking a "haskell-src-2010-06-06" package or something... that should make it clear that it's a temporary solution, not a hostile takeover attempt ;o
00:17:35 <lpsmith> :t ifM
00:17:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
00:18:58 <lpsmith> @let ifM'' g a b = do { x <- g; t <- a; f <- b; if x then t else b }
00:18:58 <lambdabot>  Defined.
00:19:02 <AshleyS> blackdog: OK, how would I rewrite 'checkForCollisions' in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25936#a25936 into Haskell Code?
00:19:07 <lpsmith> :t ifM''
00:19:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m (m b) -> m b -> m b
00:19:21 <lpsmith> @undefine
00:19:22 <blackdog> FunctorSalad: righto, i might do that. although given that i'd have to fork hint to get it to use it anyway, i might just make the changes there
00:19:28 <lpsmith> @let ifM'' g a b = do { x <- g; t <- a; f <- b; if x then t else f }
00:19:29 <lambdabot>  Defined.
00:19:51 <Saizan> FunctorSalad, blackdog: also, if this is just about the .cabal file, i think there's some plan for allowing that to be edited from hackage itself, not sure who would have the permissions though
00:19:52 <lpsmith> @undefine
00:19:58 <lpsmith> @let ifM'' g a b = do { x <- g; t <- a; f <- b; if x then return t else return f }
00:19:59 <lambdabot>  Defined.
00:20:10 <lpsmith> :t ifM''
00:20:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
00:20:14 <ski> lpsmith : i thought `ifM g a b = g >>= \bool -> if bool then a else b' was the one you wanted ..
00:20:28 <lpsmith> yeah, usually
00:20:35 <lpsmith> Right now I'm just messing around
00:21:11 <dolio> @type ifte
00:21:12 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b -> m b
00:21:31 * ski has called that one `cond'
00:22:24 <lpsmith> :t get
00:22:25 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
00:23:16 <dibblego> @src MonadLogic
00:23:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:23:46 <lpsmith> @google logict
00:23:47 <lambdabot> http://okmij.org/ftp/Computation/monads.html
00:23:47 <lambdabot> Title: Monads
00:23:57 <lpsmith> err,  there is a logict on hackage
00:24:05 <blackdog> AshleyS: something like "let collisions = filter (== pacman game) (foods game)"
00:24:16 <lpsmith> (Based on Oleg's work,  with dolio doing the legwork)
00:24:24 <blackdog> but then i think your event type isn't wide enough to capture everything you want to know about the event
00:24:24 <AshleyS> Thanks blackdog
00:25:00 <blackdog> that'll just give you the list of positions that collide, where you actually want a list of events out the end
00:25:04 <blackdog> np
00:26:50 <lpsmith> @let fact ifM = set 1 >> loop where { loop n = ifM (n <= 0) get (get >>= \a -> set (a * n) >> loop (n-1)) } 
00:26:50 <lambdabot>  <local>:2:11: Not in scope: `set'
00:26:50 <lambdabot>  
00:26:50 <lambdabot>  <local>:2:74: Not in scope: `set'
00:27:06 <lpsmith> @let fact ifM =loop where { loop n = ifM (n <= 0) get (get >>= \a -> put (a * n) >> loop (n-1)) } 
00:27:06 <lambdabot>  Defined.
00:27:08 <ski> AshleyS : btw, next time, try to annotate (by clicking "add revision" or "modify") the original paste, when pasting things related to it
00:27:11 <lpsmith> :t fact
00:27:11 <lambdabot> forall (m :: * -> *) s (m1 :: * -> *) b a. (Num a, Ord a, MonadState s m, MonadState a m1) => (Bool -> m s -> m1 b -> m1 b) -> a -> m1 b
00:28:25 <AshleyS> ski: So your saying instead of having two paste pages, just add a revision for the ported code instead?
00:29:06 <ski> yeah. it's easier to compare the two pastes, then
00:29:21 <AshleyS> OK for sure. thanks for the advice ski.
00:34:26 <lpsmith> @let ifM' g t f = do { x <- t; y <- f; if g then return x else return y }
00:34:27 <lambdabot>  Defined.
00:34:49 <lpsmith> @let ifM g t f = if g then x else y
00:34:50 <lambdabot>  Defined.
00:35:04 <lpsmith> > runState (fact ifM 5) 1
00:35:05 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
00:35:05 <lambdabot>         a...
00:35:22 <dibblego> s/if g then return x else return y/return (if g then x else y)
00:35:26 * ivanm assumes the server for the mailng lists is still down seen as how there haven't been any new messages in the 16 hours since he last checked his emails...
00:35:36 <lpsmith> thanks, dibblego
00:35:43 <lpsmith> @let ifM2 g t f = if g then t else f
00:35:44 <lambdabot>  Defined.
00:35:47 <lpsmith> > runState (fact ifM 5) 1
00:35:47 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
00:35:48 <lambdabot>         a...
00:35:52 <lpsmith> > runState (fact ifM2 5) 1
00:35:52 <lambdabot>   (120,120)
00:35:56 <lpsmith> > runState (fact ifM' 5) 1
00:36:00 <lambdabot>   mueval-core: Time limit exceeded
00:36:39 <lpsmith> actually,  if you run that on your local machine,  you can see you get (120, _|_) with the lazy state monad,  or _|_ with the strict
00:38:18 <ski> > evalState (fact ifM' 5) 1
00:38:19 <lambdabot>   120
00:38:58 <lpsmith> ahh, of course
00:39:55 <lpsmith> > evalState (runContT (fact ifM' 5) return) 1
00:39:59 <lambdabot>   mueval-core: Time limit exceeded
00:40:02 <lpsmith> > evalState (runContT (fact ifM 5) return) 1
00:40:03 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.ContT
00:40:03 <lambdabot>                     ...
00:40:31 <lpsmith> > evalState (runContT (fact ifM2 5) return) 1
00:40:33 <lambdabot>   120
00:41:57 <ivanm> blackdog: is this you? http://www.flickr.com/photos/jeremynicoll/4441032543/ :p
00:42:47 <AshleyS> hey blackdog, I am getting an error because it is expecting 'Game' when I am giving it an IORef Game. I have updated the first paste bin with the compiler error.
00:42:50 <lpsmith> so clearly there is something more to the CbN Monadic style than the type
00:43:13 <AshleyS> Not sure If I should be using an IORef or not though.
00:44:03 <blackdog> ivanm: ha. no
00:44:06 <blackdog> that's james britt
00:44:30 <blackdog> AshleyS: almost certainly not
00:44:39 <blackdog> ivanm: wish i'd been there to see his talk, though.
00:44:42 <blackdog> or even seen it on video.
00:45:10 <ivanm> you mean there's more than one of you chasing a lost cause? :o
00:45:10 <ivanm> :p
00:45:42 <AshleyS> If I want to constantly update a variable in a main program loop, what should I use?
00:45:43 <blackdog> oh, very funny. there are more ruby hackers than haskell hackers by a long shot, sunshine:)
00:46:04 <blackdog> AshleyS: best way is to just pass the updated version to the next iteration of the loop
00:46:32 <blackdog> ivanm: if i can convert 1% of them, we'll have a lot more hackers...
00:46:39 <AshleyS> Ah hah! That makes sense but I have no idea how to do that
00:46:54 * blackdog is perfectly aware of the "if we only get 1% of the market" fallacy but chooses to ignore it
00:47:17 <ivanm> blackdog: why would we want people that chose to use ruby? :p
00:47:28 <blackdog> AshleyS: in essence: "gameloop currentState = gameloop (next currentState)
00:47:49 <AshleyS> hmm, sounds good
00:47:53 <AshleyS> I will try that now
00:48:08 <blackdog> ivanm: because we'd like a decent web presence? because we'd like people who care about good visual design and user interaction working in haskell?
00:48:41 <voker57> what about "avoid success at all costs"?
00:48:44 <ivanm> how does "ruby user" translate to people who care about good visual design and user interaction?
00:48:53 <ivanm> voker57: we lost that fight already
00:48:56 <ivanm> damn galois, etc. :@
00:48:58 <voker57> :(
00:49:06 <blackdog> ivanm: sorry if i'm going off on you a bit - it annoys me slightly that the response i get from haskell types is quite often "why would you use anything but haskell?", where other communities are far more open to external ideas.
00:49:19 <ivanm> blackdog: not my opinion at all
00:49:38 <ivanm> I for one would very rarely choose anything except Haskell because I know it best, etc.
00:49:50 <blackdog> ivanm: because that's the way rails sites tend to get developed. they're focused on fast iteration of prototypes, of polishing user interactions rather than polishing the internals.
00:50:12 <Phyx-> that's not my impression of "rails sites"
00:50:23 <blackdog> so ruby is slow, and sometimes buggy, but rails sites tend to be functional and pleasant to use.
00:50:50 <danharaj> What about the ones that are balls slow.
00:51:02 <ivanm> blackdog: just because some rails teams have good UI people doesn't mean we'd necessarily get that 1% ;-)
00:51:29 <blackdog> ivanm: i suspect you would, actually. they're the leading edge - the people who like to try new things. they're not rusted on to anything.
00:51:36 <portnov> hm. Should we publish a FAQ with single question "Why haskell.org is down again?" ? ;)
00:51:49 <Phyx-> blackdog: so now you're saying haskell programmers are rusted?
00:52:02 <blackdog> Phyx-: a little, yeah. we've got a superiority complex.
00:52:07 <ivanm> portnov: there is one on the haskell reddit
00:52:13 <AshleyS> blackdog: I think why I was using a OIRef is because I saw it in an OpenGl example. If I use OpenGL later on, would I need to use a OIRef for the game state?
00:52:25 <Phyx-> portnov: actually I only noticed when I didn't get any mails from cafe :)
00:53:03 <blackdog> AshleyS: IORef:) hm. i haven't used opengl much, but the actual state of the system doesn't have to live in an ioref.
00:53:14 <Phyx-> blackdog: how so? everyone expresses how much they like their language of choice
00:53:41 <blackdog> what might happen is that the open gl library expects control of the top level runloop, and won't pass your variables around - in that case, yes, you would have to use an IORef
00:54:10 <blackdog> Phyx-: I'm not sure that's true.
00:54:20 <AshleyS> Yes I think that is the case
00:54:24 <blackdog> your average rails dev spends about equal amounts of time in ruby, CSS and javascript
00:55:28 <blackdog> anyway. i think it'd be sad to see haskell go down the common lisp path of being so enamoured of itself that it disappears up its own fundamental orifice.
00:55:50 <blackdog> or the haskell community, to be more precies.
00:56:14 * blackdog is going to stop browbeating #haskell now
00:56:33 <Phyx-> i've found the haskell community and particulairly this channel and stackoverflow to be the most usefull and friendly of most i've been in
00:56:43 <Phyx-> certainly beats the c community any day
00:57:02 <jaspervdj> Wait, is there still a c community?
00:57:06 <Saizan> blackdog: actually, we'd probably shift to something more obscure like one of those dependently typed languages :)
00:57:42 <blackdog> Saizan: heh, I wasn't gonna mention the Agda crowd
00:57:50 <Phyx-> jaspervdj: somewhat, but the general answer there for everything is "google it"
00:58:16 <Phyx-> jaspervdj: atleast #haskell has the decency to just ignore you when they don't wanna answer :P
00:58:25 <blackdog> Phyx-: yep, agree entirely. we're hugely friendly, so long as someone wants to learn haskell.
00:59:14 <Phyx-> this IS a haskell channel
00:59:22 <ivanm> Phyx-: nah, #haskell will usually have the decency of stating _why_ you're being ignored
00:59:28 <Phyx-> not really the place to be if you want to learn something else
00:59:37 <ivanm> whereas other langs you're either lost in the noise or else no-one's paying attention at all :/
00:59:42 <Phyx-> ivanm: lol
00:59:43 <danharaj> I've asked about Coq and Agda in this channel and gotten lots of helpful advice in addition to the pointing to #coq and #agda
00:59:55 <danharaj> It's not a Haskell bubble.
01:00:11 <blackdog> danharaj: but all the paths out of the bubble lead to even more esoteric languages:)
01:00:35 <danharaj> 'esoteric'
01:00:40 <Saizan> it's no fun to go backwards on the esoteric scale
01:00:50 <Phyx-> hahaahh
01:00:59 <blackdog> Saizan: unless it means you get the chance to slip something esoteric into a thoroughly commercial project:)
01:01:59 <blackdog> which is why i think haskell folk sort of miss the point about hubris. i'm not writing it because i think ruby is the best language in the world: i'm writing it because it gives you a smooth upgrade path to move more and more haskell into an existing rails project.
01:02:09 <Saizan> blackdog: not sure how much i'd really appreciate that, but i can see your motivation :)
01:02:31 <Phyx-> is Ruby really that "mainstream"
01:02:38 <danharaj> Ruby is not an interesting language.
01:02:42 <Phyx-> I know by far more Haskell programmers than Ruby
01:02:56 <danharaj> Languages that are most popular are also the least interesting, they have weak conceptual underpinnings and poor semantics. Haskell is the easiest step into a world of programming that has something to teach about computation, instead of bashing out code.
01:03:02 <blackdog> Phyx-: of course, you hang out in #haskell. try searching for ruby jobs.
01:03:21 <danharaj> The roads out of #haskell lead to ideas.
01:03:47 <Saizan> danharaj: that sounds a little too enthusiastic :)
01:03:50 <blackdog> danharaj: it'd be lovely if they also led to solid commercial projects too.
01:04:14 <danharaj> Saizan: It is 4 am and someone likes ruby in a channel I'm in :p
01:04:36 <blackdog> dude, read what i'm actually writing.
01:04:52 <Phyx-> it's 10am and i'm wondering why my Haskell code is giving me segfaults
01:05:01 <blackdog> Phyx-: FFI?
01:05:04 <Phyx-> yup
01:05:05 <danharaj> Phyx- : unsafeCoerce?
01:05:14 <ville> danharaj: Oh I've just guess-coded a skeleton of a Gtk application in Haskell.
01:05:21 <Phyx-> danharaj: nah, i think my marshalling code is off
01:05:34 <smarmy> anyone generous enough to take a look at this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25939
01:05:35 <danharaj> Phyx-; you are working in the realm of dragons :p
01:06:25 <Phyx-> danharaj: lol, yeah I heard it's not very common to do haskel -> c
01:07:01 <blackdog> Phyx-: really? common enough to merit a chapter in RWH:)
01:07:47 <danharaj> blackdog: I don't know what you're main point is because I came in here late, but let me just say. Haskell isn't inaccessible because of a fault in the community. This is a community that provides top notch friendly help to anybody willing to learn. Certainly it is much easier to get friendly help from a person for Haskell than for C, in my experience.
01:08:08 <Phyx-> blackdog: if I remember correctly, that chapter only deals with using FFI with primitives, Doesn't explain Storable for instance. And I meant, there's a c2hs tool but not a hs2c for instance
01:08:33 <blackdog> Phyx-: oh, you're calling Haskell from C? yeah, embedding is sort of a weak spot.
01:08:45 <smarmy> danharaj: i second that.  this community has bene leaps and bounds better than any i've encountered.  i'm still amazed to this day... it's unparalleled
01:09:56 <Phyx-> smarmy: i can sense the sarcasm
01:10:00 <Phyx-> @type transitionMap
01:10:01 <lambdabot> Not in scope: `transitionMap'
01:10:05 <blackdog> danharaj: Not suggesting haskell is inaccessible. It's been one of the friendliest places on the net i've ever been.
01:10:20 <Phyx-> oh, it's a record
01:10:29 <smarmy> Phyx-: no sarcasm
01:10:32 <blackdog> #haskell, rather. i'm talking about haskellers attitude to other languages.
01:10:38 <smarmy> Phyx-: for once....
01:12:31 <Phyx-> blackdog: I actually have a tool written to do that, but the more larger and complex examples i try (exporting core GHC functionality) I keep finding small annoying bugs, which is why I haven't released it
01:12:47 <Saizan> smarmy: i think the problem is that the 'a' in the signature of eClosures and the 'a' in the one of eClosure are both implicitly quantified, so different by definition
01:13:07 <danharaj> blackdog: I think haskellers have plenty of respect for other languages. In this channel I have seen more respect for other languages than in communities for any other language. There are very few holy warriors here.
01:13:28 <Phyx-> Saizan: Yeah, I've been thinking the same
01:13:31 <Saizan> smarmy: hence you can't use (transitionMap nfa) inside eClosure since that'd require them to be unified.
01:13:35 <danharaj> blackdog: But I do acknowledge that most of us are apathetic towards more mainstream languages :p
01:13:40 <blackdog> Phyx-: hm, so compiling at runtime?
01:14:01 <Saizan> smarmy: the solution is to either remove the signature on eClosure, or use ScopedTypeVariables
01:14:47 <Phyx-> blackdog: yeah, It reads your haskell source, finds functions you marked with a speciall comment -- @@ Export, then traces the datatypes that functions has in it's functions, generates a list of datatypes to marshall
01:15:06 <blackdog> danharaj: which i think is a mistake. it gets lonely in the ivory tower: if we really think we're sitting on advanced alien technology, it makes sense to make it as accessible as possible to other languages so we can devour them from the inside.
01:15:14 <Saizan> smarmy: the latter would look like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25939#a25944
01:15:18 <Phyx-> blackdog: then generates the C headers with the datatypes and extern statements, and compiles your source into a shared lib
01:15:32 <blackdog> Phyx-: heh. i'm doing almost exactly the same thing with hubris.
01:16:03 <blackdog> except i'm doing a bit of introspection on the source, and automatically exporting anything that makes sense in ruby terms
01:16:17 <blackdog> rather than annotating.
01:16:40 <blackdog> the dynamic library stuff is a colossal pain in the arse, though, if you're on mac at least.
01:16:48 * hackagebot ad 0.20 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.20 (EdwardKmett)
01:17:04 <smarmy> Saizan: thanks... mentally consuming...
01:17:19 <Phyx-> well, I only export what's needed,I usually don't want to export every function
01:17:36 <Phyx-> so I use that annotation, just to tell the tool *which* functions to export
01:17:45 <blackdog> sure. different approaches.
01:18:04 <blackdog> i figure ruby's a big soupy mess anyway, so it doesn't hurt to export everytihng
01:18:15 <blackdog> makes it kind of fun to play with at runtime too
01:18:21 <danharaj> blackdog: This is going to sound arrogant, but it's not meant to be. I come from a mathematical background, so this sort of thing is familiar to me. Haskell can't be as accessible as, say Ruby because the ideas on which Haskell is predicated are harder. They are harder because they are more rigorous, more mathematical, and deeper. I know these ideas are hard because I had a hard time learning them.
01:19:14 <edwardk> opinion poll: I have code that will let me make UArray, STUArray, and IOUArray safely contain AD Forward Floats and AD Forward Doubles by relying on the guts of the array package. Should I include it?
01:19:27 <danharaj> In order to really understand Haskell I had to learn a lot of foundational computer science that I neglected when I used to hack in C/C++, for example. I had to understand what the real fundamentals of programming were.
01:19:46 <Phyx-> blackdog: the problem is, I trace dependencies cross modules. If i were to export everything and want for instance to export the ghc api functions, I would end up generating a very huge file while only using a small portion of it
01:20:03 <danharaj> blackdog: The question is, are these harder ideas worth the effort? I think anyone in this channel thinks so :) Certainly I carry them in whichever language I hack in nowadays.
01:20:19 <dibblego> danharaj, Ruby is harder to learn than Haskell, for any person who has never programmed before
01:20:33 <Phyx-> danharaj: I would also add, that learning Haskell has cauzed me to actually think *more* about a problem I was solving, which now also carries back to my imprative coding
01:21:17 <danharaj> dibblego: I believe you. I haven't really touched Ruby. I know I had to unlearn C/++ thinking when I started on Haskell. My intuition from math was more helpful than my actual programming experience!
01:21:24 <blackdog> danharaj: i don't believe we're actually in disagreement. what i'm cranky about is the idea that the rest of the programming community has nothing of value to offer, which means we reject stuff that isn't wholly haskell.
01:21:46 <blackdog> dibblego: yeah. and writing good ruby is even harder than writing good haskell:)
01:22:29 <danharaj> blackdog: Well I told you about two languages I know are enthusiastically explored by haskelletors. There are plenty of others. Languages with hard ideas are the ones that catch interest in this community. What does Ruby, for example, have to offer that we already don't understand?
01:23:04 <edwardk> danharaj: baroque syntax and needlessly complicated semantics? =) j/k
01:23:13 <AshleyS> I gtg, thanks blackdog for all your help.
01:23:39 <dibblego> danharaj, it is possible to learn from that which is degenerate e.g. I know a lot of people found Scala easier to move to, after having used Functional Java (which is just pure Java)
01:23:40 <smarmy> Saizan: alright... that resulted in the same error.  unfortunately, it's 4am, i've been staring at this exact error for 24 hours, and i haven't a hope in the world of understanding what it means.  time to call it.  thanks for the help
01:23:52 <danharaj> edwardk: :p But seriously. If I can learn something from Ruby, I am genuinely interested.
01:24:04 <blackdog> danharaj: runtime metaprogramming is the big one.
01:24:54 <danharaj> blackdog: Can you give some motivating examples of problems best solved with such an idea?
01:25:36 <Saizan> smarmy: hah, i forgot to do the same for eClosureF, assuming the types are somewhat correct
01:32:31 <Saizan> smarmy: no, sorry, it should have covered eClosureF too
01:33:14 <jethr0> damn my memory. i seem to remember there was a tool for converting profilings into a visual representation... but alas, I can't recall
01:34:41 <Saizan> hp2ps
01:34:49 <jethr0> cool, that's it. thanks
01:35:06 <jlouis> jethr0: hp2ps -e8in -c -d 
01:39:51 <Saizan> smarmy: ok, this is typechecked with ghc-6.12.1 :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25939#a25946 , it seems the "Ord a =>" were making ghc quantify the 'a' anyhow
01:39:55 <smarmy> Saizan: so if i remove the type signatures, it does in fact work
01:40:34 <smarmy> Saizan: if i retain them, but pass nfa to eClosure/eClosureF explicitly, rather than using the functional closure of eClosures, it works
01:41:40 <smarmy> Saizan: i'm on 6.10.4
01:42:17 <Saizan> smarmy: i think it'd work the same in 6.10.4
01:43:03 <smarmy> yep, your source compiles perfectly
01:43:28 <smarmy> weird, i had removed the Ord a constraints in testing previously
01:43:34 <smarmy> although perhaps not in combination with ScopedTypeVariables
01:43:50 <Saizan> smarmy: note the forall a. in the signature of eClosures, also
01:44:04 <copumpkin> what's an eClosure?
01:45:03 <Saizan> too bad that all the resources on ScopedTypeVars are on haskell.org which is dead :\
01:45:32 <smarmy> Saizan: hmmm... i can't say i'm completely aware of the significance of the revisions
01:45:41 <copumpkin> if there were a backup lying around somewhere I could host it on a couple of machines I have control of
01:45:51 <smarmy> haskell certainly keeps me on my toes
01:46:14 <smarmy> copumpkin: the transitive closure of e-transitions from a state in an nfa
01:46:20 <copumpkin> ah ok
01:46:48 <Saizan> smarmy: well, are you aware that variables in type signatures are implicitly quantified?
01:47:45 <Saizan> like "id :: a -> a" actually means "id :: forall a. a -> a" where forall a. is binding the variable a
01:48:15 <smarmy> loosely yes, but not quite enough to feel like i'm on solid ground
01:49:41 <Saizan> so if you were to write "id :: a -> a; id x = y where y :: a; y = x", you'd actually be writing "id :: forall a. a -> a; id x = y where y :: forall a. a; y = x"
01:50:58 <Saizan> but that would be a type error, because x doesn't have type (forall a. a), i.e it isn't polymorphic
01:51:54 <Saizan> it has the type that id will be used with.
01:52:18 <smarmy> gotcha
01:52:31 <Saizan> and since id promises to be able to work for any type (that's the meaning of the forall), inside the body you can't assume anything about it
01:53:01 <Saizan> ScopedTypeVariables basically let you turn off this implicit insertion of foralls
01:54:09 <Saizan> so writing "id :: forall a. a -> a; id x = y where y :: a; y = x" will work, because the 'a' in the signature of y refers to the 'a' bound in the signature of id
01:55:14 <lispy> i've finally resurrected my coding blog: http://blog.codersbase.com
01:58:21 <jlouis> yay lispy 
01:58:42 <smarmy> alright.  so referencing the nfa from the where clause types without ScopedTypeVariables was in fact trying to unify a local forall a with the particular outer a being bound
01:58:46 <lispy> this time around I'm using blogspot for hosting so I hope it doesn't get exploited again
01:58:50 <smarmy> which explains the "less polymorphic than expected" error
01:59:17 <smarmy> it inferred a particular "a", but was typed implicitly with forall
02:04:27 <smarmy> Saizan: many thanks.  it's 5am now... at last i can rest easy
02:14:21 <dhun> is there an equivalent to "notFollowedBy" as defined by Parsec in the happy parser generator?
02:14:41 <ivanm> dhun: are you wanting a Parsec function or a happy function?
02:14:56 <dhun> I want to write a happy function
02:15:15 <dhun> I got a parse in parsec, its cool but its slow
02:16:05 <ivanm> dhun: IIUC, happy generates parsers based upon the grammar
02:16:11 <ivanm> you're not actually meant to write the parsers yourself
02:16:17 <ivanm> what are you parsing?
02:16:19 <Phyx-> hmmm, simpler really is better... removed a few lines and all bugs fixed
02:16:34 <dhun> I am parsing mediawiki
02:16:46 <ivanm> dhun: as in markdown?
02:16:50 <ivanm> see pandoc! ;-)
02:17:20 <dhun> pandoc can write mediawiki, but not read it
02:18:00 <ivanm> there's a branch that can read it IIRC
02:19:58 <dhun> pandoc website says Pandoc can read markdown and (subsets of) reStructuredText, HTML, and LaTeX,
02:20:41 <dhun> well what I am afraid of is that mediawikis grammer might not be in the class of grammers that happy can generate parsers for
02:20:59 <ivanm> dhun: I'm sure someone on github had a branch that read mediawiki, but I can't seem to find it
02:22:04 <Phyx-> @runGhc
02:22:04 <lambdabot> Unknown command, try @list
02:22:08 <Phyx-> @hoogle runGhc
02:22:08 <lambdabot> No results found
02:22:20 <ivanm> preflex: seen kowey
02:22:21 <preflex>  kowey was last seen on #haskell 27 days, 15 hours, 22 minutes and 45 seconds ago, saying: (I had linked to http://www.haskell.org/pipermail/haskell-cafe/2010-April/076192.html found via Google earlier, but it seemed to be a dead end)
02:22:48 <ivanm> dhun: ask kowey about it, he was interested in this (not sure how far he got); he should be in #darcs
02:23:05 <dhun> ok
02:36:53 <wvd> "Exception: getAddrInfo: does not exist (error 11001)", what could this be causing?
02:37:09 <mreh> does c2hs exploit the fact that GHC compiles to C as an intermediate step?
02:37:18 <tomberek> what do you guys know about ATS?
02:37:33 <copumpkin> tomberek: what about it? :)
02:37:43 <copumpkin> it's an ugly language
02:37:47 <Utkarsh> Hey all. I'm just starting out with haskell. What's wrong with http://pastebin.com/dXRT2ue8 ?
02:37:47 <mreh> I suppose it's the only possible way you can statically compile in the header
02:37:49 <copumpkin> but has some neat stuff 
02:37:56 <tomberek> copumpkin, i was reading, came across it
02:38:03 <tomberek> why ugly?
02:38:26 <copumpkin> have you seen the syntax? :P
02:38:46 <tomberek> copumpkin, reading the wiki now
02:40:28 <Phyx-> Utkarsh: head will return a single element, so of type a and last expects a list [a]
02:41:20 <Utkarsh> Phyx-: oh! I thought it returns all but the last element.
02:41:30 <Phyx-> Utkarsh: that's init
02:41:36 <Phyx-> > init [1..10]
02:41:37 <mreh> mixing up c2hs and the FFI here
02:41:37 <lambdabot>   [1,2,3,4,5,6,7,8,9]
02:41:46 <Phyx-> > head [1..10]
02:41:47 <lambdabot>   1
02:42:09 <Utkarsh> Phyx-: thanks!
02:43:36 <tomberek> copumpkin : what about agda, coq? i found some talk about a agda to haskell compiler.... i'm just looking for a "dependently typed haskell" that's still fast
02:43:48 <copumpkin> tomberek: no such thing :P
02:43:50 <copumpkin> tomberek: agda is nice though
02:43:52 <tomberek> lol
02:49:39 <Phyx-> damnit, that sucks
02:50:18 <copumpkin> tomberek: it's still worth learning a dependently typed language for knowledge's sake :P
02:51:03 <Phyx-> It sucks getting to the end of implementing something and realizing it won't work
02:51:21 <tomberek> copumpkin: yeah, i think i keep trying to do stuff that needs is
02:51:26 <tomberek> it
02:52:10 <copumpkin> it's worth playing with even just got get a feel for what it would take to get it working the way you want
02:52:24 <copumpkin> then with a working implementation you can think about how you can bring it back to haskell
02:58:34 <chrisdone> ciao!
02:58:40 <copumpkin> :o
03:00:05 <wvd> I'm trying to install chart using cabal install, however it fails on some times, it needs depencies but it can't install them: http://codepad.org/0dLTQkvZ - should I manually install them?
03:01:18 <chrisdone> wvd: ivanm see this is why that guy needs a terminal resize
03:01:57 <chrisdone> wvd: i think glib comes with the gtk2hs which isn't cabal installable
03:01:57 <wvd> also, trying to install glib-0.11.0 manually doesn't work also
03:02:10 <wvd> I *did* cabal install gtk2hs already though
03:02:21 <chrisdone> oh really? awesome!
03:02:25 <wvd> http://dockerz.net/twd/HaskellCharts
03:02:29 <wvd> Look at News > 27 May
03:03:13 <chrisdone> that's so cool, i feel like making a gtk program just because i can
03:03:27 <Phyx-> that's the spirit
03:05:05 <wvd> oh wait.
03:05:08 <Phyx-> bleh, tabs are evil reincarnate
03:05:12 <wvd> I only did cabal install gtk2hs-buildtools and gtk
03:05:12 <chrisdone> wvd: hm glib doesn't work here either. must be my cabal version
03:05:24 <wvd> chrisdone: i just did "cabal install cabal-install"
03:05:28 <lispy> Phyx-: you can make ghc complain about tabs with a flog
03:05:32 <lispy> flag*
03:05:35 <blackdog> danharaj: sorry, having dinner. the impetus behind runtime metaprogramming is moer flexibility than anything - it's helpful to have a system that can move in any direction without a restart, at least in some circumstances
03:05:54 <chrisdone> i'm unable to do that right now, building cabal results in 50 linker errors and i can't be bothered spending an afternoon figuring it out
03:06:15 <blackdog> it's something that is very difficulty to achieve in haskell-  you have to decide ahead of time where your points of dynamism are going to be
03:06:16 <Phyx-> lispy: yeah, but the GHC files themselves are full of tabs, edited a few now it's complaining about parse errors because i used spaces
03:07:17 <lispy> Phyx-: oh, that's evil and interesting
03:07:41 <blackdog> danharaj: incidentally, it's one of the other motivations for Hubris. anything you actually understand well enough to put types on, you can write as a haskell library - otherwise, use ruby as glue.
03:10:34 <wvd> So I have problems with glib: "setup.exe: The pkg-config package glib-2.0 is required but it could not be found. cabal: Error: some packages failed to install:", then it exists with ExitFailure 1, but cabal install glib-2.0 resolves in "cabal: There is no available version of glib that satisfies ==2.0"
03:11:08 <dcoutts> wvd: the hint there is "The pkg-config package glib-2.0"
03:11:16 <dcoutts> i.e. not a Haskell package
03:11:19 <wvd> oh
03:11:21 <dcoutts> a system package
03:11:36 <dcoutts> a system package that provides the pkg known to the pkg-config system as glib-2.0
03:12:20 <dcoutts> i.e. the "dev" flavour of your system's native glib package
03:13:30 <wvd> How would I get that package? I can't do sudo apt get, since i'm on Windows
03:13:52 <chrisdone> haha time to enjoy the benefits of windows
03:14:13 <wvd> I can't use Linux :S
03:14:24 <chrisdone> you can get windows versions of glib just check the web site
03:14:33 <chrisdone> there are build instructions for MinGW or cygwin iirc
03:14:44 <wvd> http://www.gtk.org/download-windows.html
03:14:51 <wvd> There are binaries for 2.24 here, should that work?
03:15:49 <chrisdone> i think you need development files too. maybe those package come with
03:16:07 <chrisdone> yeah -- get the Dev packages
03:16:14 <wvd> It only has some dl's
03:16:15 <wvd> Oh
03:16:18 <chrisdone> the Gtk+ site is a lot friendlier these days
03:16:56 <wvd> So where should I exactly put those?
03:17:27 <dhun> so kowey, what do you think, is happy strong enough to parse the syntax of mediawiki?
03:17:36 <ivanm> chrisdone: bah
03:18:01 * Phyx- hugs his windows. Don't worry, i still love you no matter what anyone in #haskell says
03:18:04 <Phyx-> :P
03:18:06 <chrisdone> well, for example the glib package, extract it then read the makefile. the typical step is ./configure && make install, but on Windows it's usually slightly modified. the rEADME has instructions though
03:18:23 <kowey> presumably happy handles context free grammars only, right, dhun?
03:18:24 <hamishmack> wvd: TakeoffGW is a quick way to install MinGW stuff (including GTK) on windows.  http://sourceforge.net/projects/takeoffgw/
03:18:24 <Heffalump> happy is just a lexer, isn't it? So if mediawiki has any nesting it certainly can't.
03:18:26 <chrisdone> s/read the makefile/read the readme
03:18:33 <Heffalump> oh, sorry, confusing happy and alex
03:18:37 <wvd> chrisdone, no readfile.
03:18:41 <wvd> chrisdone, readme*
03:18:59 <wvd> hamishmack: I've already installed cygwin, so I'd prefer not to install mingw along side it.
03:19:10 <kowey> dhun: I think the mediawiki language is not context free, so we're stuck with something like parsec (but I don't entirely know what I'm saying)
03:19:13 <dhun> yes as far as I see happy is limited to context free grammers, but I don't know much about grammers in computer science
03:19:38 <kowey> dhun: just know that lots and lots of people have tried to model the mediawiki language in a formal grammar (usually a CFG) and failed
03:19:51 <dcoutts> wvd: ohhh, you're on windows, then you need to follow the gtk2hs INSTALL instructions
03:20:02 <chrisdone> wvd: ah, it's already been built. do you have mingw installed already?
03:20:09 <kowey> I imagine you can write some simple proof based on some subset of the language
03:20:22 <dcoutts> wvd: http://code.haskell.org/gtk2hs/INSTALL
03:20:30 <tomberek> copumpkin.. what about coq?
03:20:36 <dcoutts> wvd: cygwin/mingw is not needed to build gtk2hs
03:21:23 <kowey> dhun: I seem to remember that mediawiki works by converting mediawiki syntax directly to HTML
03:21:26 <dhun> well I think you can write down a grammer, the point is that it won't be a context free one and thus happy will not be able to parse it
03:21:45 <dhun> yes the mediawiki engine does html
03:22:06 <kowey> dhun: well, my point being that it does not build up some sort of parse tree
03:22:18 <dcoutts> dhun: btw, happy has a more generalised grammar mode, though I don't know how useful that is in practice
03:22:19 <dhun> I got a parse tree
03:22:50 <kowey> one of the difficulties I ran into was that you can embed HTML into mediawiki into HTML
03:23:06 <kowey> the distinction between block and inline elements is not very clear
03:23:23 <kowey> so if you say something like ''<p>foo</p><p>bar</p>''
03:23:44 <kowey> that will be like saying <p>"foo''</p><p>''bar''</p>
03:23:54 <bustercopley> dcoutts, you linked haskell.org -- isn't it offline?
03:23:58 <kowey> not insurmountable problems perhaps, but you really need to do a lot of thinking
03:24:02 <dhun> yes this is a problem
03:24:38 <dcoutts> bustercopley: yes but code.haskell.org is still online (all *.haskell.org subdomains are served off of a different box)
03:24:45 <kowey> this is embarassing... as an NLP guy I *ought* to be able tell you exactly what's going on right off the bat
03:25:06 <systemfault> What is a good book to read after RWH?
03:25:18 <dhun> I think this is a special case of malformated html, this is html that is not xhtml
03:25:19 <dcoutts> systemfault: purely functional data structures
03:25:22 <bustercopley> thanks.
03:25:33 <chrisdone> a good example of a context-sensitive grammar is PHP's $mystring = <<<EOT blah blah EOT; syntax
03:26:00 <systemfault> dcoutts: Thank you, last question: Is that a book on haskell or functional programming in general?
03:26:39 <Phyx-> functional programming in general, I think the examples are even in ML
03:26:41 <dcoutts> systemfault: it uses Haskell (and ocaml) as the language for the code
03:26:45 <FunctorSalad> chrisdone: is it?
03:26:48 <kowey> dhun: xhtml is an XML-ised variant of html, which I don't think mediawiki was aiming for
03:26:56 <chrisdone> FunctorSalad: the 'EOT' string is user-supplied
03:27:00 <dhun> currently I generate some latex pdfs, like this one  http://upload.wikimedia.org/wikibooks/de/7/75/Soziologie.pdf, but the problem is that the parser run 14 minutes for it
03:27:08 <FunctorSalad> hmmmm
03:27:15 <Phyx-> dcoutts: doesn't it only have "some" examples in haskell too?
03:27:16 <systemfault> dcoutts: I should be able to understand it despite the fact that I don't have any experience with ocaml?
03:27:17 <dhun> yes mediawiki is allowing everything
03:27:39 <systemfault> dcoutts: Thank you for your answers :)
03:27:48 <kowey> what I'm saying is "not XHTML" is not the same thing as "malformatted HTML" :-)
03:27:49 <chrisdone> FunctorSalad: so you can't just write a PEG grammar, for example, to parse it, because it would require memory of what the first quotation symbol was
03:27:53 <FunctorSalad> chrisdone: is the lang of all words of the form xx for x any string CF? I don't remember
03:27:57 <dcoutts> systemfault: yes, it's fairly clear, you don't need to know ocaml
03:28:03 <dcoutts> Phyx-: iirc it gives Haskell code at the back
03:28:06 <FunctorSalad> (if not, then yours surely isn't either ;))
03:28:25 <kowey> dhun: well, you could try my pandoc-mediawiki branch, http://github.com/kowey/pandoc/tree/mediawiki
03:28:31 <kowey> dhun: but it's not very good :-(
03:28:46 <dhun> you can also call it non Xhtml, but that is problem, that you don't get a tree in that case
03:28:52 <FunctorSalad> { xx | x \in \Sigma^* }
03:29:32 <dcoutts> systemfault: it's good for making you think about persistence, lazyness and efficiency in FP  
03:29:42 <dhun> well yeah I could try that branch, but the speed issue will persist I think
03:30:04 <dcoutts> systemfault: several of the data structures in the book only work (or only have such good performance) because of laziness
03:30:12 <wvd> hmm
03:30:21 <wvd> How can I set the PKG_CONFIG_PATH on Windows?
03:30:33 <dcoutts> wvd: you should not need to
03:30:39 <systemfault> dcoutts: Excellent :)
03:30:51 <dcoutts> wvd: if cabal can find pkg-config from the gtk+ installation then everything should work
03:31:12 <wvd> dcoutts, I added the bin\ folder to my %PATH%, but it still cannot find the pkg-config package (pkg-config --cflags gtk+-2.0 works, but pkg-config --cflags glib+-2.0)
03:31:37 <dcoutts> wvd: there's no such package as glib+-2.0
03:31:42 <wvd> oh
03:31:49 <wvd> there is a glib+-2.0.pc though
03:31:58 <chrisdone> FunctorSalad: i'm not sure how you would decide to parse that language
03:32:10 <dcoutts> wvd: really? never heard of such a thing
03:32:14 <temoto> Hello. I can't compile language-python, because needs more memory. Any way to work around that?
03:32:25 <dcoutts> wvd: gtk2hs needs gtk+-2.0 and glib-2.0, so you'll be ok
03:32:42 <lispy> preflex: seen Heffalump 
03:32:42 <preflex>  Heffalump was last seen on #haskell 14 minutes and 9 seconds ago, saying: oh, sorry, confusing happy and alex
03:32:43 <wvd> dcoutts, yeah, but what do I need to install now? 'cabal install chart' doesn't work.
03:32:45 <melba> someone ban marlboro^kancil, spambot
03:32:56 <Heffalump> I'm here.
03:33:03 <lispy> Heffalump: oh hai
03:33:06 <dcoutts> wvd: have you followed the gtk2hs install instructions?  http://code.haskell.org/gtk2hs/INSTALL
03:33:29 <chrisdone> FunctorSalad: I think you could express that in regex as (.+){2}. for regex it would never parse because (.+) would consume everything
03:33:38 <lispy> Heffalump: Since my blog isn't currently syndicated anywhere you might not see this, but I think you might find it interesting: http://blog.codersbase.com/2010/06/delimited-continuations-and-version.html
03:33:41 <siracusa> What am I doing wrong here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25947#a25947 ? This example is pretty much the same as one from a GtkTextView tutorial.
03:33:44 <wvd> dcoutts, "You may now install the cabal packages of Gtk2Hs into any directory you like (including one that contains embedded spaces). Note that cabal installs the tools necessary to build into something like" - which packages? gtk2hs is not a cabal package.
03:34:13 <FunctorSalad> chrisdone: thought {n} is only applicable to character sets... it definitely is that way if you want to stay regular
03:34:13 <Heffalump> lispy: indeed. thanks :-)
03:34:35 <dcoutts> wvd: it lists them all at the top of the INSTALL file
03:34:55 <lispy> Heffalump: I'm interested in hearing any insights or objections you have after read it it :)
03:34:59 <chrisdone> FunctorSalad: what do you mean by your last sentence?
03:35:06 <Heffalump> I'll comment
03:35:12 <wvd> dcoutts, do I need those install all?
03:35:21 <dcoutts> wvd: almost certainly not
03:35:58 <FunctorSalad> chrisdone: that such 'regex'es don't describe regular languages
03:36:06 <wvd> dcoutts, http://dockerz.net/twd/HaskellCharts -> Look at news > 27 may.
03:37:15 <dcoutts> wvd: good that it works with the new gtk2hs release, he's not right about quite how simple it is, at least on windows.
03:37:19 <Zeerious> hello, everyone play the LastCO???
03:37:32 <dcoutts> wvd: it is that simple on linux because linux has the gtk+ C libs installed (usually)
03:37:34 <chrisdone> FunctorSalad: regex is just an example. for such a language to parse, you'd need to decide on values of * that don't consume everything. that doesn't sound like a very reliable parser
03:37:51 <dcoutts> wvd: the special steps on windows are to get the gtk+ C libs installed
03:37:54 <wvd> dcoutts, do I need to take extra steps? cabal install chart fails, I could give you the error message there if you want.
03:37:57 <wvd> right
03:38:00 <wvd> but I did that now?
03:38:17 <dcoutts> wvd: oh you mean you do have the Haskell 'gtk' package installed now?
03:38:18 <FunctorSalad> chrisdone: woha. Apparently posix extended regexp lets you {2} arbitrary expressions
03:38:29 <FunctorSalad> didn't know...
03:38:46 <wvd> dcoutts, second, I just did 'cabal install gtk2hs-buildtools' again, because I got those gtk+ libs on my %PATH% now.
03:39:01 <wvd> dcoutts, yeah, but I think I installed it already.
03:39:11 <chrisdone> FunctorSalad: oh, sorry. i was thinking of PCRE
03:39:12 <dcoutts> wvd: ghc-pkg list gtk will tell you
03:39:17 <FunctorSalad> chrisdone: regular expressions matchers are supposed to backtrack, or something smarter but functionally equivalent (i.e. calculate the minimal automaton)
03:39:43 <wvd> dcoutts: "WARNING: cache is out of date: C:/Program Files/Haskell Platform/2010.1.0.0\lib\
03:39:43 <wvd> package.conf.d\package.cache", should I recache?
03:39:52 <FunctorSalad> chrisdone:  (so I don't see how it's an issue that the first .+ would consume anything)
03:40:02 <chrisdone> FunctorSalad: so 'xyz' would consume 'x' and then 'yz'?
03:40:21 <dcoutts> wvd: that's a bit odd, yes I guess so
03:40:24 <chrisdone> FunctorSalad: or 'xy' and then 'z'?
03:40:53 <wvd> dcoutts, http://pastie.org/993694
03:41:19 <FunctorSalad> chrisdone: oh, wait. the {2} postfixed to an expression is just a "macro" equivalent to having the expression twice. it doesn't actually mean that the same string has to be matched each time
03:41:32 <dcoutts> wvd: ok so try installing the gtk package, following the INSTALL instructions 
03:41:50 <FunctorSalad> chrisdone: I tried: echo abaaa | grep -E '^(ab*a){2}$'
03:41:52 <FunctorSalad> succeeds.
03:42:01 <chrisdone> FunctorSalad: oh, really? so i guess the more correct description is (.+)\1
03:42:10 <wvd> dcoutts, it tells I need to have gtk2hs-buildtools installed, so I guess that's fine - I'll just do "cabal install gtk"?
03:42:34 <dcoutts> go for it
03:42:36 <FunctorSalad> chrisdone: yeah, but backrefs are well-known to send you far out of regex (in the classical sense) land ;)
03:43:22 <chrisdone> FunctorSalad: but we both understand the meaning of it
03:43:37 <FunctorSalad> I just wasn't sure whether this (.+)\1  (or (.*)\1) is *contextfree*
03:43:45 <FunctorSalad> chrisdone: yes
03:44:09 <wvd> dcolish, http://codepad.org/zZIAQ0wb
03:44:15 <lpsmith> marlboro^kancil is a spammer
03:44:23 <FunctorSalad> chrisdone: just thought for a moment you were saying it's regular
03:44:23 <lpsmith> could a op please kickban him?
03:44:48 <chrisdone> FunctorSalad: I think having them immediately following is context-free, because it's just like 'a'* or x* in PEG, we're just repeating an arbitrary parser
03:45:17 <wvd> woops
03:45:20 <wvd> dcoutts, http://codepad.org/zZIAQ0wb
03:45:22 <wvd> dcolish, sorry.
03:45:30 <FunctorSalad> chrisdone: but it has to do the same things each time... .+.+ is of course regular
03:45:52 <FunctorSalad> (but doesn't force the two parsers to make the same choices)
03:46:23 <chrisdone> FunctorSalad: hmm ah good point
03:46:27 <hamishmack> wvd: Make sure the GTK pkg-config is ahead of any cygwin one you might have in your PATH.
03:46:29 <chrisdone> FunctorSalad: yeah, that sounds context-sensitive
03:46:51 * hackagebot tccli 0.0.1 - TokyoCabinet CLI interface  http://hackage.haskell.org/package/tccli-0.0.1 (JaroslavGridin)
03:47:18 <chrisdone> FunctorSalad: i was confusing repeating a parser with (foo)\1
03:47:23 <dcoutts> wvd: check that the pkg-config on your $PATH is the one from your gtk installation (not mingw/cygwin) and that pkg-config --modversion glib-2.0 reports something sensible
03:47:24 <copumpkin> lpsmith: ?
03:47:28 <copumpkin> lpsmith: who?
03:47:36 <copumpkin> oh
03:48:05 <lpsmith> copumpkin, marlboro^kancil has been pm'ing me spam links
03:48:07 <chrisdone> FunctorSalad: btw have you seen this? http://pegjs.majda.cz/online
03:48:09 <copumpkin> aww ok
03:48:09 --- mode: ChanServ set +o copumpkin
03:48:17 --- mode: copumpkin set +b *!*afrid*@115.132.185.*
03:48:17 --- kick: marlboro^kancil was kicked by copumpkin (marlboro^kancil)
03:48:28 <wvd> dcoutts, it returns 2.22.3 (pkg-config --modversion glib-2.0) and this is my PATH: http://codepad.org/xoHnwl0v
03:48:36 --- mode: ChanServ set -o copumpkin
03:49:13 <FunctorSalad> chrisdone: I'm not familiar with PEGs, but according to wikipedia they describe a subset of deterministic CF languages?
03:49:31 <chrisdone> FunctorSalad: that's right
03:49:33 <FunctorSalad> (or maybe all of them)
03:49:44 <dcoutts> wvd: in the same shell session as the one where you're running cabal install gtk?
03:49:54 * hackagebot hlint 1.7 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.7 (NeilMitchell)
03:49:54 <lpsmith> parsec is a PEG formalism
03:49:55 <wvd> dcoutts, yeah.
03:50:10 <chrisdone> lpsmith: how so?
03:50:15 <siracusa> wvd: Have you tried installing from MinGW? I think I've gotten the same problems in the Windows console.
03:50:30 <wvd> siracusa: what installing? the cabal packages?
03:50:36 <dcoutts> wvd: odd, can you post the log of cabal install glib -v
03:50:39 <siracusa> wvd: Yes
03:50:53 <FunctorSalad> chrisdone: nope haven't seen it
03:50:55 <wvd> siracusa: would cygwin also work?
03:51:06 <lpsmith> chrisdone, parsec provides all the PEG operations,  esp. ordered choice
03:51:09 <dcoutts> siracusa: what? that pkg-config works in the shell and not via cabal?
03:51:16 <siracusa> wvd: I don't know, just tested it with MinGW
03:51:23 <wvd> dcoutts, http://codepad.org/Paa0SiCZ
03:51:58 <chrisdone> lpsmith: sure. Frisby is more like a PEG though, being context-free and supporting the performance capabilities
03:52:03 <FunctorSalad> lpsmith: but also commutative choice
03:52:09 <chrisdone> http://repetae.net/computer/frisby/
03:52:21 <FunctorSalad> lpsmith: \x y -> try x <|> y
03:52:28 <dcoutts> wvd: ok, next, cabal unpack glib, cd ./glib-x.y.z/; cabal configure -v3
03:52:35 <siracusa> dcoutts: Not sure what the problem was but something went wrong in the Windows console with pkg-config
03:53:39 <dcoutts> siracusa: if you can find any other details on that, that'd be useful. It should work fine from the windows console, in fact should work more smoothly than from mingw, less stuff to get in the way.
03:53:41 <wvd> dcoutts, done, alot of text ending with: "Package glib-2.0 was not found in the pkg-config search path.
03:53:41 <wvd> Perhaps you should add the directory containing `glib-2.0.pc' to the PKG_CONFIG_PATH environment variable No package 'glib-2.0' found setup.exe: The pkg-config package glib-2.0 is required but it could not be found."
03:54:24 <dcoutts> wvd: does it show you how cabal is invoking pkg-config?
03:54:48 <dcoutts> wvd: could you paste the tail of the log, where it invokes pkg-config
03:54:49 <wvd> dcoutts, "("C:\\Windows\\system32\\pkg-config.exe",["--modversion","glib-2.0"]) C:\Windows\system32\pkg-config.exe returned ExitFailure 1 with error message:"
03:55:00 <lpsmith> hayoo's down?  bummer
03:55:06 <dcoutts> wvd: ohh, wrong path to pkg-config
03:55:35 <dafis> wvd: Is there, in fact a glib-2.0.pc anywhere in your file system? I've often encountered the situation that packages don't come with a .pc file.
03:55:52 <wvd> dafis: yeah, but pkg-config works fine with glib-2.0, we just tested that.
03:55:55 <chrisdone> lpsmith: that web site is really cool. i wrote a parser for a mini-form describing language embedded in markdown with it. i already wrote the PEG grammar out in my specification/documentation of the project, then i found that page, pasted it in and i had a working parser, haha. so awesome
03:56:05 <wvd> dcoutts, so my commandline pkg-config uses a different one from the system32 one?
03:56:10 <chrisdone> FunctorSalad: i meant you above ^
03:56:14 <dcoutts> wvd: apparently so
03:56:17 <wvd> dcoutts, I could rename the pkg-config in C:\Windows\System32?
03:56:37 <dcoutts> wvd: you can use --with-pkgconfig=${the gtk one}
03:56:51 <dcoutts> wvd: when doing cabal install or configure
03:57:20 <wvd> Is there any way to see where pkg-config lives when invoking it from the cmd-line?
03:57:45 <dcoutts> wvd: does windows command line have a which/where command?
03:58:00 <wvd> It has
03:58:06 <chrisdone> FunctorSalad: Lojban is parseable with a PEG grammar, apart from one construct which is context sensitive :(
03:58:07 <wvd> C:\gtkmm\bin\pkg-config.exe
03:58:07 <wvd> C:\Windows\System32\pkg-config.exe
03:58:12 <lpsmith> chrisdone, hayoo?
03:58:14 <wvd> So it seems the cmd-line uses the gtkmm as first.
03:58:28 <chrisdone> lpsmith: hm?
03:58:38 <lpsmith> FunctorSalad, is that really commutative choice?  I'm skeptical
03:58:53 <lpsmith> <chrisdone>  lpsmith:  that web site is really cool [...]
03:59:14 <chrisdone> lpsmith: http://pegjs.majda.cz/online
03:59:18 <lpsmith> oh
03:59:18 <dcoutts> wvd: so my guess is that command.exe uses the one on the $PATH where as the default windows find executable function looks in system first (it also looks in the dir of the current process)
03:59:20 <lpsmith> :)
03:59:31 <FunctorSalad> lpsmith: how so?
03:59:41 <wvd> dcoutts, yeah. I removed the one from the System32 (I probably downloaded it once standalone to do some things fast), let's see how this works out now.
04:00:06 <wvd> dcoutts, yay, it's compiling some glib modules now :)
04:00:15 <dcoutts> wvd: there's no guarantee the gtkmm one will work, better would be to use the gtk+ installation you downloaded as per the INSTALL instructions
04:00:30 <FunctorSalad> (I'm excluding error messages and the leftover string)
04:02:03 <wvd> dcoutts, iirc, I downloaded gtkmm 2.20 before (same as the GTK+ bundle) since I needed it for some C++ applications, it's really becoming one big mess.
04:02:25 <wvd> dcoutts, so far it processed cairo/pango/glib fine.
04:03:02 <FunctorSalad> lpsmith: err, and I'm excluding the monadic value ;) since the language stuff is usually binary accept/refuse
04:03:21 <hamishmack> wvd:  I really recommend looking at TakeoffGW it includes gtkmm, gtk-engines and gtksourceview
04:03:38 <lpsmith> FunctorSalad, I just about had that complaint typed up, but you beat me to the punch :)
04:03:49 <siracusa> dcoutts: I tried to rebuild only the gtk package, configure works and build starts preprocessing, so I guess it works fine and I just did something wrong the last time.
04:03:52 <lpsmith> Even so, I'm not sure... I'll have to think about it
04:04:12 <FunctorSalad> the latter point could be fixed by combining the return values with some commutative operation...
04:04:20 <dcoutts> siracusa: wvd discovered yet another windows oddity which explains the problem
04:04:33 <wvd> I *wish* I could use Linux.
04:04:50 <wvd> Is it normal that it's "Preprocessing library gtk-0.11.0..." for like 10 minutes already now?
04:05:00 <siracusa> wvd: Yes :-)
04:05:13 <wvd> siracusa, just when you said Yes it started compiling :P
04:06:27 <FunctorSalad> (not that there is any commutative operation a -> a -> a ;) but let's say we are at some type where there is one ;))
04:06:49 <FunctorSalad> except const _|_ and _|_, yes :p
04:07:08 <FunctorSalad> * const (const _|_) and _|_
04:08:56 <lpsmith> FunctorSalad, there isn't a commutative operation a -> a -> a?    Oh... right, parametericity.  I thought you meant for some a
04:09:02 <FunctorSalad> yeah
04:09:40 <wvd> dcoutts, noes, 'cabal install gtk' worked fine, but then 'cabal install chart' throwed an error again
04:10:04 <wvd> dcoutts, http://codepad.org/PxJ9KAWV
04:10:09 <FunctorSalad> lpsmith: but anyway, I understood you as ignoring the value of the parser anyway (otherwise it wouldn't be clear what a PEG even is)
04:10:45 <dcoutts> wvd: oh noes, chart uses template haskell
04:11:05 <wvd> oh
04:11:09 <lpsmith> yeah, I haven't worked through the exact correpsondence (or lack thereof) between parsec and PEGs,  but I'm pretty sure it's a PEG of some kind,  or rather,  a superset thereof
04:11:16 <dcoutts> wvd: see the section on ghci in the gtk2hs INSTALL notes, template haskell is basically the same as ghci in this context.
04:11:47 <lpsmith> well, maybe a superset,  I dunno
04:12:11 <hamishmack> dcoutts: I did a patch for that as you advised
04:12:12 <wvd> dcoutts, "If you use ghc 6.10 or earlier, you need to upgrade your Cabal system to 1.8 if you want to build Gtk2Hs with ghci support. Note that it is always possible to build executables on Windows." > I'm using 6.12
04:12:36 <dcoutts> hamishmack: hmm?
04:12:55 <hamishmack> Oh yes it only works for 6.12
04:13:03 <wvd> dcoutts, and cabal is also version 1.8.0.2
04:13:14 <hamishmack> searches the PATH for the DLLs
04:13:25 <hamishmack> during gtk2hs build
04:13:48 <hamishmack> wvd: make sure the GTK dlls are in your PATH
04:14:28 <hamishmack> If not you will need to rebuild gtk2hs
04:14:40 <dcoutts> no, it'd say it could not load the dlls if that were the problem
04:14:55 <dcoutts> it might be getting different dlls at runtime to the ones built with however
04:15:06 <wvd> hamishmack, the bin\ folder is on my PATH, so libglib and such are on my %PATH%
04:15:13 <dcoutts> not impossible given the various gtk installations floating about on wvd's machine
04:15:27 <wvd> that might be possible
04:15:28 <dcoutts> wvd: but you built using the gtk libs from your gtkmm installation
04:15:33 <wvd> I added the gtk+ bin
04:15:43 <dcoutts> we know that because you used the pkg-config from gtkmm
04:16:28 <wvd> dcoutts, hmm, nope, removed the bin\ folder from my PATH but no changes.
04:18:07 <hamishmack> wvd: can you find the cairo-*.conf file from your package.conf.d folder
04:19:43 <wvd> wow
04:19:48 <wvd> I have two package.conf.d's, second.
04:20:05 <siracusa> dcoutts: Any ideas about this one http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25948#a25948 ? I don't know how to ensure this assertation
04:20:26 <wvd> hamishmack, http://codepad.org/V4wX7s3k - it's in the second list (with all those other GTK+ libs I suppose)
04:21:16 <dcoutts> siracusa: look at the tag table thing in the docs
04:21:17 <hamishmack> So in C:\Users\Doorn\AppData\Roaming\ghc\i386-mingw32-6.12.1\package.conf.d there should be a file cairo-*.conf
04:21:42 <hamishmack> wvd: can you put that up on codepad
04:24:27 <wvd> hamishmack, put what on codepad? there is a cairo-* file there, yes.
04:25:02 <wvd> hamishmack, i'll "dir" in it, second.
04:25:22 <hamishmack> wvd: Might be the wrong link.  I just see the output of pkg-config list
04:25:38 <hamishmack> filename will be like cairo-0.10.5-727c2e7de4953c7bba72bfe89cef6562.conf
04:25:47 <wvd> hamishmack, http://codepad.org/zKpjAXsi
04:26:19 <hamishmack> so what is in cairo-0.11.0-72dde87f1e0a5c90fea5cd07ed797405.conf ?
04:26:58 <wvd> http://codepad.org/g9p9Afpq
04:27:39 <hamishmack> Is libcairomm-1.0-1.dll in your PATH?
04:28:27 <wvd> C:\Users\Doorn\AppData\Roaming\ghc\i386-mingw32-6.12.1\package.conf.d>where libc
04:28:27 <wvd> airomm-1.0-1.dll
04:28:27 <wvd> C:\gtkmm\bin\libcairomm-1.0-1.dll
04:28:29 <wvd> So yeah.
04:33:20 <hamishmack> wvd: Firing up my windows VM...
04:33:56 <wvd> hamishmack: I'm sorry.
04:34:07 <wvd> I wish I could use Linux for a long time already
04:34:21 <hamishmack> wvd: oh is that the mm lib
04:34:43 <temoto> Hello. I can't compile language-python, because needs more memory. Any way to work around that?
04:34:44 <hamishmack> wvd: does it include cairo in that DLL?
04:35:18 <wvd> hamishmack, what do you mean?
04:35:40 <hamishmack> wvd: is there libcairo-*,dll too
04:36:05 <wvd> hamishmack, in C:\gtkmm\bin yes, there is libcairo-2.dll
04:36:48 <hamishmack> wvd: I think there might be a bug in the way I search for .dll files in the path
04:37:18 <wvd> hamishmack, wait, you're the owner of chart?
04:37:44 <hamishmack> wvd: it should have put libcairo-2 in the .conf file instead of libcairomm-1.0-1
04:37:54 <wvd> hamishmack, can I change that manually?
04:38:16 <hamishmack> wvd: yes that should work
04:40:10 <wvd> hamishmack, nope :$
04:40:19 <hamishmack> wvd: It will probably be the same in other gtk*.conf
04:40:26 <hamishmack> and pango*.conf
04:40:30 <ll900> hi, the haskell.org domain seems down and the mailing lists too, is that right?
04:40:31 <wvd> it still errors about cairo though
04:40:43 <wvd> hamishmack, http://codepad.org/p7eon1o6
04:40:55 <Bigglotron> ll900: yep
04:41:05 <ll900> Bigglotron: thanks
04:41:20 <Bigglotron> welcome
04:42:18 <tmug> hi, can anyone point what I'm doing wrong here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25949#a25949 - GHC gives me Parse error in that line 4, column right before 'case ..' ?
04:42:39 <tmug> ..more specifically, parse error in pattern
04:43:42 <dafis> tmug: you need another 'do' in the case-branches
04:43:57 <chrisdone> so judging from ghci's -Wall warnings, ghci builds up bindings by merely embedding let ... = ... in ... repeatedly
04:44:31 <dafis> tmug: only in the 'h' branch
04:44:32 <chrisdone> is that right?
04:44:37 <tmug> dafis: ok.. I'll try that.. - is there any particular reason why GHC points me to that case line?
04:46:31 <dafis> tmug: since there's no 'do' in that branch, it treats the whole branch as one line
04:47:20 <dafis> hex <- many1 (oneOf hexChars)   let ((d, _):_) = readHex hex return (Number d)
04:48:13 <tmug> dafis: ok.. looks like that do was the problem.. I just have to change those other case-branches to do as well since they required same kind of 'let' there..
04:48:47 <tao_> how can i convert ByteString to normal string?
04:49:07 <tmug> dafis: ok.. got it working - thanks :)
04:49:16 <dafis> tao_: unpack (in Data.ByteString[.Lazy].Char8
04:49:28 <dafis> ')'
04:49:41 <dafis> tmug: welcome
04:49:52 <tao_> :O
04:50:42 <ville> Anyone with some consistent rule when to apply $ over (), seems like that's what it does basically -- replaces a set of ()?
04:52:12 <temoto> ville, no, $ is more like a shell pipe. Although it replaces () in most cases as well.
04:52:43 <temoto> ville, how about this rule: use which one improves readability ?
04:53:02 <benc__> thinking about how i use it - I think I use $ for functions of one argument when that argument is non-trivial
04:53:16 <benc__> which basically came from me applying temoto's rule
04:53:20 <benc__> to my personal tastes
04:54:17 <ville> temoto: So there is syntax that absolutely requires $ and () couldn't replace it to get the same effect?
04:55:08 <dafis> ville: no, you never *need* $, you can always do it with parentheses
04:55:22 <dafis> It will only be less readable sometimes
04:55:25 <siracusa> ville: `map ($)' ;-)
04:55:27 <temoto> ville, no, but there are a lot of places where you would put () in different positions than trying to replace first (.
04:56:03 <dafis> siracusa: what about map id?
04:56:41 <siracusa> dafis: Sure, but ville asked about replacing it with ()
04:56:46 <ville> siracusa: Ok.
04:57:27 <temoto> > let plus_1 = (+) 1 in map $ plus_1 10 $ [1,2,3]
04:57:28 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [b])
04:57:28 <lambdabot>    arising from a use ...
04:57:56 <temoto> > map $ (+) 1 $ [1,2,3]
04:57:57 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
04:58:16 <augur> anyone familiar with unification?
04:58:24 <temoto> > map ((+) 1) [1,2,3]
04:58:24 <lambdabot>   [2,3,4]
04:58:55 <temoto> ville, ^ i tried to provide an example where () is more appropriate.
04:58:57 <tao_> The code ` name <- (maybe (writeBS "404") id) =<< getParam "name"` will first get the result of getParam function, then pass it to maybe function and then assign that to name variable?
04:59:30 <temoto> @do name <- (maybe (writeBS "404") id) =<< getParam "name"
04:59:30 <lambdabot>  Parse error at "<-" (column 6)
04:59:48 <ville> temoto: Ok. Now that I recall there was a snippet the other day where apparently $ wasn't replaceable with (), it did indeed involve a list.
05:00:04 <temoto> @do do { name <- (maybe (writeBS "404") id) =<< getParam "name" }
05:00:04 <lambdabot>  Parse error at "}" (column 61)
05:00:26 <tao_> getParam is not a Prelude funcion tbh
05:01:09 <AshleyS> Could someone please tell me how to "overload" the == operator for the following data type: data Position = Position {x :: Float, y :: Float} ?
05:01:23 <Twey> AshleyS: Give it an Eq instance
05:01:34 <Twey> data Position = Position { x, y :: Float } deriving Eq
05:01:52 <AshleyS> Thank you very much Twey.
05:02:05 <Axman6> @do (maybe (writeBS "404") id) =<< getParam "name"
05:02:05 <lambdabot> (maybe (writeBS "404") id) =<< getParam "name"
05:02:08 <Axman6> bleh
05:02:09 <ville> Twey: Haskell doesn't warn you against comparing floating point types for equality?
05:02:16 <Twey> ville: No
05:02:23 <Twey> > 4.05 == 4.06
05:02:24 <lambdabot>   False
05:02:26 <Twey> > 4.05 == 4.05
05:02:27 <lambdabot>   True
05:02:43 <Axman6> > 1/100000000 == 1/100000001
05:02:44 <lambdabot>   False
05:02:44 <copumpkin> > sum (replicate 10 0.1)
05:02:45 <lambdabot>   0.9999999999999999
05:02:51 <Axman6> > 1/1000000000 == 1/1000000001
05:02:51 <lambdabot>   False
05:02:52 <temoto> ville, why should it warn about comparing floating point types?
05:02:58 <Axman6> > 1/10000000000000 == 1/10000000000001
05:02:59 <lambdabot>   False
05:03:02 <copumpkin> temoto: because floating point types are terrible
05:03:09 <ville> Twey: Still suffers from the same difficulties as say IEC559?
05:03:09 <copumpkin> here, it even lets you use them in patterns
05:03:09 <Twey> AshleyS: do n <- getParam "name"; writeBS "404" `maybe` id
05:03:29 <benc__> copumpkin: well you could always not use them at all? ;)
05:03:29 <copumpkin> > let f 1.0 = 5 in f (sum (replicate 10 0.1))
05:03:30 <lambdabot>   *Exception: <interactive>:1:165-173: Non-exhaustive patterns in function f
05:03:31 <Twey> ville: Float still has rounding errors, yes
05:03:46 <Twey> > sum $ replicate 10 0.1
05:03:47 <lambdabot>   0.9999999999999999
05:03:51 <Twey> As seen… ;)
05:03:53 <ville> temoto: due to erros involved in calculations it's quite difficult.
05:04:03 <copumpkin> you should just stick to powers of 2
05:04:08 <Twey> Heh
05:04:11 <copumpkin> > sum $ replicate 16 0.5
05:04:11 <lambdabot>   8.0
05:04:19 <copumpkin> that's exact
05:05:03 <dibblego> (`maybe` id) = fromMaybe
05:05:06 <aristid> > sum . replicate 16 0.5
05:05:07 <lambdabot>   No instance for (GHC.Real.Fractional [a])
05:05:07 <lambdabot>    arising from a use of `e_11605...
05:05:11 <aristid> > sum . replicate $ 16 0.5
05:05:12 <lambdabot>   Couldn't match expected type `[a]'
05:05:12 <lambdabot>         against inferred type `a1 -> [a1]'
05:05:25 <copumpkin> aristid: needs moar .s
05:05:27 <aristid> ooh, of course
05:06:26 <jpcooper> @pl flip fromMaybe files <$> (getCurrentDirectory >>= getDirectoryContents)
05:06:26 <lambdabot> flip fromMaybe files <$> (getDirectoryContents =<< getCurrentDirectory)
05:06:34 <jpcooper> hah
05:06:46 <triyo> What is the/a way of determining what asm my haskell program yields? 
05:07:18 <copumpkin> triyo: you can ask ghc to dump it
05:07:28 <copumpkin> -ddump-asm or something like that
05:07:32 <copumpkin> ghc-core also dumps it for you
05:07:43 <triyo> ok I'll --help thx
05:08:26 <gerryxiao> is haskell.org down?
05:09:10 <benc__> gerryxioa: http://downforeveryoneorjustme.com/www.haskell.org
05:09:20 <benc__> xiao, sorry
05:10:04 <gerryxiao> i can't connect to it, no know others
05:10:31 <benc__> its not worked for me in the last maybe 24h
05:11:07 <gerryxiao> oh right
05:11:19 <dafis> gerryxiao: http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
05:11:42 * Twey points at /topic
05:12:08 <gerryxiao> oh,thx
05:13:12 <jpcooper> how can I divide integers by integers?
05:13:20 <jpcooper> or to which type should I convert them?
05:13:24 <Twey> > 5 / 2
05:13:25 <lambdabot>   2.5
05:13:30 <Twey> > (5 :: Integer) / 2
05:13:30 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
05:13:30 <lambdabot>    aris...
05:13:35 <Twey> > div 5 2
05:13:36 <lambdabot>   2
05:13:36 <jpcooper> Ints, sorry
05:13:42 <jpcooper> but yes, I have the same problem
05:13:43 <gerryxiao> 5 `div` 2
05:13:50 <Twey> Use Integer unless you have a good reason not to
05:13:55 <jpcooper> thanks
05:13:59 <Twey> And the function you're looking for is ‘div’
05:14:07 <jpcooper> actually I want a Float result
05:14:30 <Twey> Which float result: 2.5, or 2.0?
05:14:40 <jpcooper> 3 / 4 = 0.75
05:14:43 <hamishmack> wvd:  I am confused as to why that did not work.  Perhaps it is loading gtk and therefor looking in gtk .conf.  I was able to get Chart to build ok with my Gtk2Hs build.
05:14:54 <Twey> Then you need to cast the operands using fromIntegral
05:14:58 <jpcooper> thanks
05:15:02 <Twey> > fromIntegral 3 / fromIntegral 4
05:15:03 <lambdabot>   0.75
05:15:13 <Twey> > on (/) fromIntegral 3 4
05:15:13 <lambdabot>   0.75
05:15:15 <hamishmack> wvd: I am going to prepare a fix that should avoid the conflict with gtkmm DLLs
05:15:24 <wvd> hamishmack, ah ok.. I'm thinking of cleaning up my windows system and doing it all over again, but thanks, i'll try further.
05:15:30 <jpcooper> that solves it
05:15:48 <Twey> @quote fromIntegral
05:15:48 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:16:04 <ville> ( 9876543.0f + -9876547.0f ) + 3.45f
05:16:09 <hamishmack> wvd:  Best to delay installing gtkmm until after you have Gtk2Hs built if possible
05:16:10 <ville> lambdabot: ( 9876543.0f + -9876547.0f ) + 3.45f
05:16:22 <Twey> ville: Syntax error
05:16:27 <Twey> > 5.0f
05:16:28 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:16:28 <lambdabot>    `SimpleReflect.FromExpr a...
05:16:40 <gerryxiao> > 3 / -2
05:16:41 <lambdabot>   Precedence parsing error
05:16:41 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
05:16:43 <Twey> Oh, not a syntax error — it interpreted it as ‘5.0 f’ ☺
05:16:59 <gerryxiao> >3 / (-2)
05:17:02 <Twey> gerryxiao: Negative numbers are weird for the moment — bracket them, or use ‘negate’
05:17:06 <Twey> > 3 / negate 2
05:17:07 <lambdabot>   -1.5
05:17:22 <ville> Anyhoo, ( 9876543.0f + -9876547.0f ) + 3.45f vs 9876543.0f + ( -9876547.0f + 3.45f ), not sure how to show that with lambdabot
05:18:13 <Twey> > ((9876543.0 + negate -9876547.0) + 3.45, 9876543.0 + (negate -9876547.0 + 3.45))
05:18:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:18:13 <lambdabot>    arising from a use of `...
05:18:14 <Axius> Where can I find a good tutorial for Haskell?
05:18:23 <Twey> Oops
05:18:29 <Twey> > ((9876543.0 + negate 9876547.0) + 3.45, 9876543.0 + (negate 9876547.0 + 3.45))
05:18:30 <lambdabot>   (-0.5499999999999998,-0.5500000007450581)
05:18:36 <Twey> Axius: There's a book
05:18:37 <ville> Axius: http://book.realworldhaskell.org/read/
05:18:38 <Twey> @where rwh
05:18:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:18:47 <gerryxiao> SomeException :: forall e. (Exception e) => e -> SomeException
05:18:54 <Twey> Or LYAH, if you prefer something a little more whimsical
05:18:56 <Twey> @where lyah
05:18:56 <lambdabot> http://www.learnyouahaskell.com/
05:19:03 <gerryxiao> what's the meanings of "forall." here?
05:19:18 <Twey> gerryxiao: Just means that it applies to any possible ‘e’
05:19:29 <Twey> (that fits the Exception constraint)
05:19:49 <gerryxiao> Twey: why not just (Exception e)? and any diffs?
05:19:49 <ville> Twey: haskell has no notion of `f' from C-like languages?
05:20:48 <Twey> gerryxiao: There's no difference here because it's top-level, but ‘forall’s can be embedded deeper to limit the scope of a type variable
05:21:01 <Axius> form where can I download a txt or html version of Real World Haskell?
05:21:23 <Twey> ville: No… a . in the number automatically indicates a Fractional
05:21:23 <gerryxiao> i can't understand this SomeException's type
05:21:37 <gerryxiao> is it a function?
05:21:43 <Twey> gerryxiao: Yes
05:21:57 <dafis> Twey, gerryxiao: SomeException is an existential type
05:21:59 <Twey> It's a function from ‘Exception e => e’ to ‘SomeException’
05:22:16 <dafis> That's why there's the 'forall' on the data constructor
05:22:43 <gerryxiao> existential type?
05:22:44 <Twey> Aye, indeed
05:23:09 <Twey> gerryxiao: It can hold a value of *any* type ‘e’
05:23:40 <Twey> So you don't have to say, for example, SomeException fooException :: SomeException fooException
05:23:44 <Twey> Er
05:23:44 <Twey> So you don't have to say, for example, SomeException fooException :: SomeException FooException
05:23:55 <Twey> You can simply say that SomeException fooException :: SomeException
05:24:10 <Twey> It doesn't matter what the type inside is — it behaves the same and the outside world need never know
05:24:37 <gerryxiao> Twey: you mean i can't put xxxException into one list?
05:24:51 <gerryxiao> or something alike?
05:24:58 <Twey> You can put SomeException's into one list
05:25:08 <Twey> Even if they have different Exception e => e types inside
05:25:27 <gerryxiao> ok, i'm abit see
05:26:11 <Twey> A SomeException is a SomeException — it doesn't matter what type the exception is that you used to construct it
05:26:39 <gerryxiao> forall = exist type?
05:26:57 <Twey> In a data constructor, yes
05:26:58 <copumpkin> depends where you put it
05:27:18 <Twey> In a function, as here, it's pretty much irrelevant
05:27:18 <copumpkin> data Moo = forall a. Moo a /= data Moo = Moo (forall a. a)
05:27:50 <copumpkin> the former would accept Moo True or Moo 5
05:27:58 <copumpkin> the latter only works with Moo undefined
05:28:24 <Axius> What do I need to download to run  haskell?
05:29:07 <Twey> Axius: http://hackage.haskell.org/platform/
05:29:18 <gerryxiao> copumpkin: so data Moo= Moo (forall a. a) is useless?
05:29:26 <copumpkin> gerryxiao: yeah
05:29:36 <copumpkin> but data Moo = Moo (forall a. Num a => a) isn't
05:29:41 <copumpkin> it'll keep a polymorphic number for you
05:29:48 <copumpkin> so Moo 5
05:30:11 <gerryxiao> and Moo 0.5
05:30:27 <Twey> [Moo 5, Moo 0.5, Moo $ 22 % 7]
05:30:27 <AshleyS> Is there a way to add the java equivalent of a object variable to the following data type with the name 'object': data Event = Event { eventType :: String } ?
05:30:38 <benmachine> data Moo = forall a. Moo a is pretty useless too right?
05:30:38 <gerryxiao> ok,nice
05:30:38 <copumpkin> gerryxiao: nope
05:30:42 <copumpkin> oh well yeah
05:30:42 <copumpkin> sorry
05:30:51 <copumpkin> benmachine: yeah, for a different reason
05:30:54 <Twey> AshleyS: What are you trying to do?
05:31:11 <copumpkin> one is useless because you can stick anything in and not get anything out, and the other is useless because you can stick nothing in but get anything out (if you could stick anything in)
05:31:25 <benmachine> heh
05:31:37 <gerryxiao> Event "hello"?
05:32:06 <gerryxiao> let aObject= Event "hello" ?
05:32:19 <ville> In C++ when I've a value that may or may not be set, I either use a pointer-to-the-type where the pointer's value 0 indicates not set or I use boost::optional. What is the Haskell replaces of this sort of thing? Should I provide a specific data constructor like data X = Invalid?
05:32:21 <benmachine> gerryxiao: that would work but wouldn't solve the problem
05:32:30 <benmachine> ville: Maybe
05:32:30 <Zao> ville: Maybe.
05:32:31 <Twey> ville: ‘Maybe’ encodes this behaviour
05:32:33 <AshleyS> Twey: I am trying to design a generic Event constructor. I am not sure if I am trying to do this the "OOP" way. Maybe I should write a specific constructor for my specific need. I am not sure what is the right thing to do.
05:32:34 <Zao> @src Maybe
05:32:34 <lambdabot> data Maybe a = Nothing | Just a
05:32:40 <benmachine> whee answers in triplicate
05:32:48 <Zao> With a slew of Fun Functions in Data.Maybe
05:32:52 <Twey> AshleyS: You are — you should almost certainly parameterise your event
05:32:53 <Zao> fromJust, etc.
05:33:01 <ville> Ok Maybe it is, seemed bit silly that a type it self would need to know whether is is optional or not where it is used.
05:33:03 <copumpkin> NO FROMJUST
05:33:13 <Twey> AshleyS: data Event a = Event { eventType :: String, object :: a }
05:33:14 * Zao concats copumpkin's maybes.
05:33:17 <Chaze> @hoogle foldM
05:33:17 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
05:33:17 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
05:33:17 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:33:25 * Zao ncats pumpkin's comaybes.
05:33:33 <Twey> ville: Why?
05:33:34 <copumpkin> :O
05:33:55 <Twey> ville: That way you don't have to check everything you do for nulls.
05:33:56 <benmachine> fromJust can be handy when e.g. using find on an infinite list
05:34:07 <benmachine> although I tend to prefer going let Just x = in
05:34:11 <AshleyS> Twey: So setting it to 'a' is fine? Is it bad from a functional programming perspective to have such a generic constructor?
05:34:17 <gerryxiao> @hoogle SomeException
05:34:17 <lambdabot> Control.Exception data SomeException
05:34:17 <lambdabot> Control.Exception SomeException :: e -> SomeException
05:34:17 <lambdabot> Control.Exception.Base data SomeException
05:34:49 <benmachine> AshleyS: it's sort of but not really generic, because what type is used is specified in the type of the event
05:34:52 <Twey> benmachine: maybe (error "THE UNIVERSE BROKE!") id
05:34:53 <benmachine> Event Thing
05:35:03 <benmachine> Twey: but the universe isn't broken :P
05:35:10 <Twey> benmachine: You don't know that
05:35:13 <Twey> benmachine: It might be
05:35:34 <benmachine> :(
05:35:37 * benmachine despairs
05:35:49 <ville> Twey: I mean the use of a specific data constructor just because this particular type might be optional in some places it is used at. Seems more modular to me to wrap it with Maybe ( or in C++ as a pointer or boost::optional ).
05:36:17 <Zao> Maybe is pretty much a 1:1 correspondence to an optional.
05:36:29 <mauke> VIOLENT AGREEMENT
05:36:37 <alip> can someone help me figure out what I'm doing wrong with http://paste.pocoo.org/raw/222503/ . Apperaently ghc doesn't like return (Just s)
05:36:43 <Zao> Or a variant with none_t as first type :D
05:36:52 <ville> Twey: If I used the data constructor approach I'd have to always check whether it was constructed with that, even in places where the value can't be optional.
05:37:04 <Zao> Heck, optional even has a ctor that takes a `none' :D
05:37:12 <Axius> What do I need to run haskell?
05:37:13 <Twey> ville: You're right
05:37:23 <Twey> 13:28:47 < Twey> Axius: http://hackage.haskell.org/platform/
05:37:24 <benmachine> ville: does anyone disagree with you? :P
05:37:26 <Zao> Axius: A Haskell interpreter and/or compiler.
05:37:38 <Zao> Axius: The common one tends to be GHC (and GHCi) nowadays.
05:37:40 <ville> benmachine: I doubt it.
05:37:46 <benmachine> right ok
05:37:48 <benmachine> just checking
05:37:51 <Axius> ok
05:38:20 <mauke> alip: it looks like you're trying to call an IO action with two arguments
05:38:24 <benmachine> alip: the specific error'd be useful, but my first guess is something's up with your indentation
05:38:29 <mauke> alip: that makes no sense because an IO action isn't a function
05:38:39 <benmachine> oh wait mauke is right
05:38:44 <benmachine> I think you're missing a do?
05:38:50 <mauke> benmachine: no
05:39:28 <benmachine> suit yourself
05:39:44 <Axius> I've tried to get the source from www.haskell.org and I can't connect. What alternatives do I have to get the source?
05:39:46 <chrisdone> do m <- defaultModule "REPL" "REPL"; d <- parseBinding "x = 1"; return $ prettyPrint $ addDecl d $ addDecl d $ addDecl d m
05:39:46 <chrisdone> Just "module REPL where\nit = let x = 1 in let x = 1 in let x = 1 in ()"
05:39:46 <chrisdone> yeah, bitch. tryhaskell top-level bindings here we come
05:39:49 <mauke> the problem is 'return' semantics
05:39:59 <benmachine> mauke: ok, they're both problems
05:40:24 <benmachine> and the indentation is a little bit odd too
05:40:30 <alip> benmachine: http://paste.pocoo.org/raw/222510/ is the error
05:40:46 <zygoloid> chrisdone: aren't top-level bindings supposed to be mutually-recursive? :)
05:40:53 <benmachine> alip: oh yes, that's due to use of when
05:41:07 <mauke> alip: (\v -> ( ... ) return Nothing)
05:41:14 <chrisdone> zygoloid: not in ghci!
05:41:20 <mauke> alip: this tries to call ( ... ) with two arguments, 'return' and 'Nothing'
05:41:28 <alip> oh
05:42:00 <mauke> alip: the other problem is that 'return' is just a function
05:42:05 <mauke> a constructor
05:42:22 <mauke> using 'return' in 'when' makes no sense
05:42:28 <Axius> Can any give me other site to download ghc-6.12.1? 
05:42:39 <Axius> Can anyone give me other site to download ghc-6.12.1? 
05:42:42 <chrisdone> Axius: what OS?
05:42:50 <Axius> linux
05:42:53 <chrisdone> yeah, what OS
05:42:54 <benmachine> is haskell.org still toast
05:43:05 <benmachine> oh well
05:43:06 <ville> Axius: use your package manager
05:43:09 <Axius> I use slackware.
05:43:10 <mauke> Axius: why do you need the source?
05:43:22 <ivanm> mauke: because slackware doesn't really have a package manager
05:43:23 <benmachine> ghc is unpleasant to compile :P
05:43:31 <ivanm> benmachine: huh?
05:43:31 <benmachine> well that's not really true
05:43:33 <chrisdone> people still use slackware. interesting
05:43:33 <benmachine> but it takes a while
05:43:37 <benmachine> and uses ghc
05:43:42 <mauke> benmachine: ghc is impossible to compile if you don't have ghc
05:43:42 <ivanm> ./configure && make && make install
05:43:50 <ivanm> but yeah, the bootstrapping can be a pain
05:43:57 <Axius> I have a ghc.SlackBuild and I need the source.
05:44:08 <mauke> Axius: no, first you need a working ghc
05:44:13 <ivanm> Axius: which version do you want?
05:44:46 <benmachine> http://darcs.haskell.org/ would something from here be useful
05:44:49 <Axius> ivanm: 6.12.1
05:45:01 <alip> mauke: now i get it :) thanks!
05:45:08 <ivanm> any particular reason why not 6.12.2?
05:45:26 <benmachine> I thought 6.12.2 was unrecommended
05:45:26 <ivanm> then again, the ebuild transition from .1 to .2 was non-trivial, so I suppose the SlackBuild for it wouldn't be either
05:45:32 <ivanm> benmachine: huh?
05:45:33 <Axius> ivanm: 6.12.2 will ok.
05:45:43 <ivanm> benmachine: only because the platform is recommended
05:45:43 * benmachine pokes through mail
05:45:51 <mauke> if v == nullPtr then return Nothing else fmap Just (peekCString v)
05:45:52 <ivanm> and 6.12.3 is apparently coming out some time this month
05:46:31 <mauke> hmm, the latest ghc sources I have are 6.10.3
05:46:38 * ivanm checks to see if there's a gentoo mirror for it
05:46:57 <ivanm> I have 6.12.2, but don't particularly feel like uploading it atm (since the only place I have to upload it to is c.h.o and it's _slow_)
05:47:45 <Axius> I've tried to download it from here and it does not work:http://www.haskell.org/ghc/dist/6.12.1/ghc-6.12.1-i386-unknown-linux-n.tar.bz2
05:48:07 <mauke> that doesn't look like sources to me
05:48:13 <ivanm> yeah, because haskell.org is down
05:48:25 <ivanm> mauke: true, looks like the generic binary
05:48:42 <mauke> ivanm: mediafire.com?
05:49:03 <Axius> I need to compile ghc.
05:49:09 <mauke> Axius: no, first you need a working ghc
05:49:11 <Axius> I need to that compile ghc.
05:49:28 <mauke> but if you already have a working ghc, why compile ghc?
05:49:29 <ivanm> mauke: I think the plan is to get the generic tarball and then compile ghc from that
05:49:39 <benmachine> ivanm: http://www.mail-archive.com/haskell@haskell.org/msg22776.html
05:49:45 <ivanm> mauke: to use the system package
05:49:51 <ivanm> mauke: slack builds everything IIRC
05:50:21 <LeNsTR> i have ghc-6.12.2-src.tar.bz2
05:50:29 <gio123> z
05:50:37 <Axius> ivanm: you are right, that's I'm planing to do.
05:50:54 <ivanm> ugh
05:51:14 <ivanm> the first one is fixed in Gentoo (we've applied the patch), but not the second
05:51:20 <ivanm> and I didn't know about the second
05:51:33 <ivanm> oh well, it's not like I'm doing anything with lazy bytestrings atm anywaya
05:51:46 <benmachine> heh
05:52:31 <LeNsTR> mauke: http://rghost.net/download/1814892/e224706461f623185bfae27ed7a9f56731e74331/ghc-6.12.2-src.tar.bz2
05:53:27 <mauke> http://5z8.info/dogs-being-eaten_z4l3w_facebook-hack
05:55:03 <Axius> LeNsTR: Can you give me a like to download the binary?
05:55:58 <LeNsTR> only linux ghc-bin-6.12.1-x86.tbz2
05:56:27 <Axius> LeNsTR: ok
06:04:09 <mauke> http://www.mediafire.com/download.php?yhz3rg5z4ct - ghc-6.10.2-i386-unknown-linux.tar.bz2
06:05:20 <LeNsTR> http://rghost.net/1814996
06:05:22 <LeNsTR> Axius: ^^
06:06:35 <Axius> LeNsTR: hello
06:20:11 <Chaze> can someone tell me if these are equivalent, and if they are, why? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25951#a25951
06:24:21 <Twey> Chaze: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25951#a25952
06:24:31 <Twey> Er, oops
06:24:45 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25951#a25953
06:25:21 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25951#a25954 even.  Think that's everything.  :þ
06:25:32 <Chaze> thanks a lot! :)
06:25:42 <ClaudiusMaximus> wow, my program seems to be running in constant memory (45MB Virt) - which i don't totally understand as it's navigating an infinite graph of mutable cells...
06:25:56 <Twey> As you can see, the simplest way to write it is as ‘mother x >>= father’
06:26:54 <Twey> Hm
06:28:00 <Twey> :t \x -> (undefined :: a -> Maybe b) x >>= (undefined :: b -> Maybe c)
06:28:00 <pastorn> preflex: seen Cale
06:28:01 <lambdabot> forall a b. a -> Maybe b
06:28:01 <preflex>  Cale was last seen on #haskell 15 hours, 55 minutes and 17 seconds ago, saying: That's not always true. Sometimes things are just less efficient than they have to be.
06:28:04 <pastorn> preflex: seen Cale_
06:28:04 <preflex>  Cale_ was last seen on #haskell 16 hours, 1 minute and 10 seconds ago, saying: good
06:28:06 <Axman6> ClaudiusMaximus: welcome to the wonders of laziness
06:28:11 <AshleyS> Do I have to import a package to use 'Nothing'?
06:28:18 <copumpkin> nope
06:28:32 <Twey> :t (undefined :: a -> Maybe b) >=> (undefined :: b -> Maybe c)
06:28:33 <lambdabot> forall a c. a -> Maybe c
06:28:38 <Twey> So that's what that's for
06:28:46 <ClaudiusMaximus> Axman6: but when the cells are mutated, it must remember what the non-default value is....
06:28:46 <copumpkin> lol
06:28:51 <copumpkin> glad you figured it out
06:28:59 <copumpkin> it composes monadic functions!
06:28:59 <Twey> I guess you can write it as ‘mother >=> father’, then
06:29:08 <copumpkin> aka kleisli arrows
06:29:11 <Twey> copumpkin: I've always understood it in theory, but never in practice :þ
06:29:21 <Axman6> ClaudiusMaximus: there's a good chance that there is no graph at all, the compiler could have completely eliminated it
06:29:22 <copumpkin> mother >=> father ? pegging?
06:29:27 <Twey> Hahaha
06:29:33 <Twey> I've been writing stuff like (>>= father) . mother
06:29:44 <copumpkin> aha yep
06:29:53 <Twey> This is nicer
06:30:39 <copumpkin> I love it
06:30:47 <copumpkin> :t readFile <=< readFile
06:30:48 <lambdabot> FilePath -> IO String
06:30:48 <copumpkin> ;)
06:30:52 <ClaudiusMaximus> Axman6: i doubt it, i've got a Map Int Cell, with data Cell = Cell{ u,l,r,dl,dr :: Maybe Int, x :: Bool }
06:30:56 <copumpkin> homemade symlinks
06:31:00 * wli has yet to grok arrows
06:31:31 <copumpkin> they allow you to treat things like Monad m => a -> m b as a regular function and compose it using a custom composition operation
06:31:37 * wli has probably regressed wrt. monads too
06:31:40 <copumpkin> Kleisli is a separate category in that
06:31:44 <copumpkin> and does just that
06:31:46 <copumpkin> :t Kleisli
06:31:47 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
06:32:04 <copumpkin> :t runKleisli (Kleisli readFile <<< Kleisli readFile)
06:32:05 <lambdabot> FilePath -> IO String
06:32:12 <copumpkin> :t runKleisli (Kleisli readFile Control.Cateogry.. Kleisli readFile)
06:32:13 <lambdabot> Couldn't find qualified module.
06:32:17 <copumpkin> ugh
06:33:13 <copumpkin> well, that's what Control.Category buys you, anyway. The ability to make function-like things that aren't regular functions. Arrow adds some properties on top of that about operating on tuples and so on
06:34:00 <Twey> It's just that you typed ‘Cateogry’ :þ
06:34:10 <copumpkin> :t runKleisli (arr reverse <<< Kleisli readFile <<< Kleisli readFile)
06:34:11 <lambdabot> FilePath -> IO [Char]
06:34:11 <copumpkin> whoops :)
06:34:16 <Twey> Hehe
06:34:33 <copumpkin> arr "lifts" a pure function into the right place
06:34:52 <copumpkin> so that's equivalent to fmap reverse . (readFile <=< readFile)
06:35:07 <copumpkin> :t fmap reverse . (readFile <=< readFile)
06:35:08 <lambdabot> FilePath -> IO [Char]
06:35:44 <copumpkin> (it's nice that you can treat the whole chain as a regular composition instead of composing readFile with itself and then fmapping reverse to the result
06:35:54 * copumpkin shuts up
06:36:09 <Twey> :t Kleisly
06:36:09 <lambdabot> Not in scope: data constructor `Kleisly'
06:36:10 <Twey> Ack
06:36:11 <Twey> :t Kleisli
06:36:12 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
06:36:26 <copumpkin> (Kleisli m) behaves like (->)
06:36:27 <Twey> copumpkin: Nice, but dreadfully verbose :þ
06:36:34 <copumpkin> yeah :/
06:36:47 <Twey> Where instance Arrow (Kleisli m)?
06:36:55 <copumpkin> yep, and Category
06:37:00 <copumpkin> given that m is a Monad, of course
06:37:03 <Twey> Aye
06:37:08 <Twey> Well
06:37:09 <Twey> Hm
06:37:16 <Twey> There's no such restriction on Kleisli
06:37:22 <Twey> :t runKleisli
06:37:23 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
06:37:30 <Twey> Or runKleisli…
06:37:35 <copumpkin> yeah, but you don't get instances unless it's a monad
06:37:39 <Twey> Ah
06:37:51 <copumpkin> instnace (Monad m) => Category (Kleisli m) where ...
06:37:59 <Twey> *nod*
06:38:29 <copumpkin> @let (?) = (Control.Category..)
06:38:30 <lambdabot>  <local>:6:6: Not in scope: `Control.Category..'
06:38:41 <copumpkin> boo
06:38:47 <Twey> :t (.)
06:38:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:38:48 <copumpkin> @let (?) = (Control.Category.<<<)
06:38:49 <lambdabot>  <local>:6:6: Not in scope: `Control.Category.<<<'
06:38:52 <Twey> Huh
06:39:00 <copumpkin> that's Caleskell
06:39:14 <Twey> Yeah, I thought he'd generalised as far as Category
06:39:32 <copumpkin> nope, it's a bit weird, really
06:39:38 <copumpkin> sort of a reverse generalization
06:39:43 <Twey> Heh
06:39:59 <copumpkin> not a huge fan of it conceptually, but it's tiny syntax for a common operation
06:40:12 <copumpkin> which can be nice
06:40:17 <Twey> Aye
06:44:03 <benmachine> istr Arrows being equivalent to Applicatives or something
06:44:18 <benmachine> I know I wrote this down somewhere
06:45:03 <benmachine> hmm, I wonder if these are actually equivalent
06:45:08 <benmachine> you can write
06:45:12 <benmachine> (&*&) :: (Applicative (a b)) => a b c -> a b c' -> a b (c, c')
06:45:22 <benmachine> but that's not necessarily the same as 
06:45:26 <benmachine> :t (&&&)
06:45:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:48:30 <illissius`> benmachine: http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html ?
06:49:46 <illissius`> applicative + category == arrow, arrowapply == monad, afaik... not that I understand very much about them beyond that :\
06:50:15 <benmachine> mm
06:59:39 <chrisdone> i have 6 emacs buffers containing the word 'haskell'. nightmare for buffer switching
07:01:32 <Philonous> M-x rename-buffer 
07:01:57 <chrisdone> to what? :p
07:02:20 <Philonous> original buffer name sans "haskell" ?
07:03:11 <chrisdone> Philonous: then i'd have: #, #-blah, **, -json.hs, ,-json.cabal
07:03:16 <chrisdone> Philonous: not helpful!
07:03:34 * benmachine wonders about **
07:03:47 <chrisdone> benmachine: haskell-mode's buffer name is *haskell*
07:03:56 <benmachine> oic
07:03:59 <chrisdone> well, inferior-haskell-mode
07:04:40 <Philonous> I'd chose "irc" "bla" "ghci" "json" "cabal-json". 
07:05:31 <chrisdone> i have 200~ buffers open no way!!
07:05:47 <chrisdone> ghci's a good one, i'll take that one
07:06:58 <Philonous> M-x clean-buffer-list :-P
07:07:15 <chrisdone> lol
07:17:39 <bustercopley> just about to write some emacs lisp so i can press f1 to see documentation on the haskell function named at point. has that already been done for me?
07:18:23 <ivanm> bustercopley: as in open the haddock docs?
07:18:31 <bustercopley> probably, yeah
07:18:35 <bustercopley> only just found haddock
07:18:40 <ivanm> I don't think it's been done for the very simple reason: how do you find which docs to use?
07:18:44 <ivanm> in terms of which URL to use
07:19:04 <bustercopley> hmm, good point
07:19:24 <bustercopley> but something like the list of matches from hoogle would be nice
07:21:19 <bustercopley> eek. yep, not as simple as i hoped
07:24:21 <bustercopley> my next idea: set up a local web server and search engine so i can do keyword search on the generated haddock html in firefox
07:25:31 <bustercopley> but seriously, do you have any ideas about what to use for reference when haskell.org is down? i'm trying to learn but not having much fun
07:26:10 <benmachine> hackage.haskell.org is still up isn't it?
07:26:20 <benmachine> or do you mean, for when it isn't
07:26:35 <bustercopley> um, don't know what that is ...
07:26:44 <bustercopley> :P
07:27:08 <benmachine> the haskell package database
07:27:13 <bustercopley> right, cool and an api search
07:27:15 <bustercopley> thanks!
07:27:25 <bustercopley> ah
07:27:39 <bustercopley> but that's broken too?
07:27:44 <benmachine> hayoo appears to be broken
07:28:00 <benmachine> but you can find the docs for packages directly
07:28:56 <benmachine> like, suppose I have Data.Sequence then I go ghc-pkg find-module Data.Sequence and it says containers
07:28:59 <benmachine> so then I go to
07:29:02 <benmachine> @hackage containers
07:29:02 <lambdabot> http://hackage.haskell.org/package/containers
07:29:11 <benmachine> and the docs are there
07:29:14 <wvd> hamishmack, hey, did you commit some fix yet?
07:29:34 <bustercopley> cool
07:30:07 <benmachine> you can also ask cabal to build documentation when installing libraries
07:30:17 <benmachine> but you don't get hyperlinked source which is a shame
07:34:23 <bustercopley> ok, what you said for packages, and google with site:hackage.haskell.org will be good enough for keywords. thanks very much.
07:35:33 <hamishmack> wvd: I don't have write access to gtk2hs, but I have just sent it to the gtk2hs-devel list.
07:35:42 <wvd> oh, ok.
07:35:44 <wvd> thanks
07:39:01 * hackagebot hashed-storage 0.5.2 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.2 (PetrRockai)
07:40:44 <benmachine> @tell edwardk I think some of the build-dep constraints on your monoids package can be relaxed -- do you have a source repo or some preferred place to send patches?
07:40:44 <lambdabot> Consider it noted.
07:44:39 <wvd> Are there any other sites who have haskell.org pages stored?
07:45:10 <temoto> google
07:45:32 <temoto> archive.org
07:45:44 <temoto> wvd, ^
07:47:32 <portnov> @hoogle (a -> r) -> a -> r
07:47:32 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:47:32 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:47:32 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:53:29 <aristid> @src $!
07:53:29 <lambdabot> f $! x = x `seq` f x
07:59:20 <ClaudiusMaximus> ah my program does slowly consume more memory, after an hour running its usage increased from 45MB to 46MB
08:08:10 * hackagebot records 0.1.1.1 - A flexible record system  http://hackage.haskell.org/package/records-0.1.1.1 (WolfgangJeltsch)
08:08:47 * edwardk is greatly amused. I just spent several hours looking for an algorithm for something just to find out that one of the guys I've been collaborating with wrote the canonical paper on how to do it 16 years ago. ;)
08:08:47 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:09:25 <copumpkin> edwardk: what is it? :o
08:10:18 <bustercopley> the algorithm, not the message ...
08:10:32 <edwardk> an efficient way to compute a hessian vector product and inverse hessian vector product
08:11:03 <edwardk> th message was an inquiry into if monoids had a darcs repo.
08:11:51 <copumpkin> pearlmutter is the (author of the) paper you're talking about?
08:12:03 <edwardk> copumpkin: yeah
08:12:11 * copumpkin just googled, doesn't actually know the topic :P
08:12:43 <copumpkin> edwardk: so your AD package will be the ultimate AD package for haskell?
08:12:59 <edwardk> copumpkin: hoping so, it does er... well almost everything
08:13:17 <edwardk> i'm also planning on including a number of uses, second order newton's method, etc.
08:13:25 <copumpkin> we need a universe of differentiable (polynomial?) types in haskell that we can apply your AD to too
08:13:50 <edwardk> haha new generation of zippers is upon us ;)
08:13:54 <copumpkin> data OMG : Set1 where _+_ : Set -> Set -> OMG etc.
08:14:18 <edwardk> shouldn't that set be indexed? =)
08:14:20 <copumpkin> edwardk: oh you should port it to agda afterwards
08:14:27 <copumpkin> indexed by the level?
08:14:35 <edwardk> perhaps
08:14:36 <copumpkin> that could be hard :P
08:15:20 <copumpkin> I dunno what I'd index it by
08:15:50 <copumpkin> but anyway, then we have a simple semiringish thing
08:16:35 <edwardk> copumpkin: well, then you should take my ad code from monoids and apply it to that ;)
08:17:04 <copumpkin> maybe later :P
08:17:05 <edwardk> which works with a module over a right seminearring
08:17:16 <copumpkin> :o
08:17:26 <copumpkin> agda's standard library doesn't know about seminearrings
08:17:34 <paul_hfx> is there a mirror of hoogle anywhere?
08:17:36 <edwardk> well start by fixing that ;)
08:17:43 <copumpkin> I've only ever come across them in that ccshan set of blog posts
08:17:43 <aristid> @hoogle a -> b
08:17:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:17:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:17:43 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
08:17:49 <aristid> paul_hfx: @hoogle works
08:18:12 <edwardk> they come up in recognizers for context free grammars
08:18:28 <copumpkin> yeah, it was related to a string problem
08:18:40 <edwardk> a kleene algebra is a right seminearring with an extra operation (postfix *)
08:19:00 <paul_hfx> @aristid what's @hoogle?
08:19:00 <lambdabot> Unknown command, try @list
08:19:24 <edwardk> and they are equivalent to having an alternative following the 'left distributive' model of monadplus that you don't use the argument type of.
08:20:23 <copumpkin> hmm
08:21:07 <wvd> I'm going to write a simple parser for my language in Haskell, should I just use getContents to read everything in the memory and then parse by word?
08:22:35 <hpc> that would be the simplest way
08:23:03 <hpc> there isn't anything wrong with getContents as long as you don't close the handle prematurely, but as getContents works from stdin, it shouldn't be an issue
08:23:12 <aavogt> getContents doesn't necessarily mean that your whole input is in memory at once
08:23:25 <aavogt> @src getContents
08:23:25 <lambdabot> getContents = hGetContents stdin
08:23:29 <aavogt> @src hGetContents
08:23:30 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:23:40 <hpc> hGetContents is a lazy read from a handle
08:23:48 <aavogt> anyhow, there should be an unsafeInterleaveIO in sources
08:25:55 <aristid> @src second
08:25:55 <lambdabot> Source not found. It can only be attributed to human error.
08:26:06 <aristid> hmm too bad @src can't show defaults
08:27:10 <ddarius> @hackage ad
08:27:10 <lambdabot> http://hackage.haskell.org/package/ad
08:27:23 <aristid> in an instance, can you define methods of the superclasses? like, say can you define >>> in an instance of Arrow?
08:27:31 <ddarius> Ah, he did finally stop.
08:27:43 <ddarius> aristid: No.
08:28:14 <aristid> was >>> in Arrow at some point in the past?
08:28:18 <ddarius> aristid: The best you can do is define a function that defines one in terms of the other and then any future instances can use that function to define the method trivially.
08:28:22 <hpc> :t (>>>)
08:28:22 <ddarius> aristid: Yes.
08:28:23 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:28:25 <aristid> because i'm seeing this in a paper
08:28:38 <ddarius> It only recently got moved to Category.
08:28:47 <digitteknohippie> anyone have any idea when the site will be back?
08:31:40 <edwardk> hrmm
08:31:48 <edwardk> copumpkin: it seems that i'm choosing the right set of combinators
08:31:57 <edwardk> the ever so complicated algorithm turned into:
08:31:59 <edwardk> hessianProduct f = duF (grad (decompose . f . fmap compose))
08:32:35 <hpc> impressive
08:32:49 <edwardk> the one that http://justindomke.wordpress.com/2009/01/17/hessian-vector-products/ refers to as 'kinda complex' ;)
08:33:15 <edwardk> i'm getting a lot of mileage out of those compose/decompose operations that merge AD modes.
08:33:52 <edwardk> that version there is 'forward-on-reverse'. i'll be adding forward-on-forward as well which will look the same just with a different grad in scope
08:34:31 <ddarius> edwardk: What's decompose do?
08:34:59 <edwardk> it splits AD (f :. g) a into AD f (AD g a)
08:35:33 <edwardk> where (Mode f, Mode g) => Mode (f :. g) -- so i can use it behind the facade of something like:
08:35:41 <edwardk> hessianProduct :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f (a, a) -> f a
08:35:53 <edwardk> and nobody sees the fact that there are really two infinitesimals involved
08:36:03 <edwardk> each potentially using a different AD direction, etc.
08:36:38 <aristid> edwardk: what's "AD"?
08:37:28 <edwardk> aristid: automatic differentiation, the constructor itself is just a very dumb wrapper newtype AD f a = AD (f a)
08:37:39 <ddarius> edwardk: Okay.  That makes sense.
08:38:13 <ddarius> edwardk: So you can do the "nested applications" that Barak mentioned in a comment on that blog post?
08:38:14 <edwardk> AD serves as a common setting for me to 'lift' numeric instances in a compatible way.
08:38:18 <edwardk> ddarius: yeah
08:38:35 <edwardk> it turned out to be cleaner than i expected it to
08:38:47 <ddarius> edwardk: Once you could do that, it should be straight forward.
08:38:54 <ddarius> (as it is)
08:38:59 <aristid> edwardk: seems like differentiating functions is your big thing?
08:38:59 <wvd> http://codepad.org/w9z57JvX < why doesn't that work as I expect? (such that I can do, Add (Num 5) (Num 5))
08:39:17 <ddarius> aristid: edwardk has a lot of "big things"
08:39:23 <mauke> wvd: because Add takes no arguments
08:39:32 <edwardk> i'm using it for my implementation of finding an extremum of a function using newton's method and now in hessian products, it'll follow in finding the actual hessian, etc.
08:39:40 <mauke> Add :: Op  -- no -> here, not a function
08:39:42 <wvd> mauke: But, Op can either be Add or Mul or Div?
08:39:46 <wvd> Ah right
08:39:51 <edwardk> aristid: my obsession of the moment. i've only been at this for about 3 weeks now
08:40:05 <hpc> Add :: Op, but Op :: IExpr
08:40:09 <mauke> wvd: Op (Num 5) (Num 5) would work
08:40:19 <edwardk> aristid: though i took a very brief stab at it a year or two back
08:40:24 <wvd> mauke: Yeah I see.
08:40:34 <aristid> edwardk: is it purely intellectual curiosity, or do you do it as a means for achieving some goal?
08:40:53 <edwardk> aristid: it is an effort to create the most thorough reply to a stack overflow post, ever.
08:41:27 <mtnviewmark> uhoh - SO - SO is like a drug - once you start, you can't stop!
08:41:29 <aristid> edwardk: i see.
08:41:34 <Blkt> could anyone explain me why this definition doesen't work? http://pastebin.com/h16z85sx
08:41:35 <edwardk> http://stackoverflow.com/questions/2744973/is-there-any-working-implementation-of-reverse-mode-automatic-differentiation-for/2842605#2842605
08:42:34 <mtnviewmark> Blkt - what doesn't work about it?
08:42:38 <wvd> edwardk: I could change "data Op = Add IExpr IExpr" but then it's type is Op, why isn't it IExpr? I though I was saying: "a type of Op with two IExpr types as arguments"
08:42:47 <ddarius> If StackOverflow had existed in the 1910's. "Well, in reply to your question on the motion of the planets, I invented a theory I call 'general relativity'.  It turns out that all those other answers you were given are off by a few arcseconds."
08:43:40 <Blkt> mtnviewmark: I get a type error, let me reproduce it
08:43:43 <edwardk> ddarius: and people would be measuring physics ability in milliEinsteins
08:44:15 <aristid> and they would show it off on EinsteinOverflow
08:44:25 <edwardk> wvd: you porbably want data IExpr = Num Int | Var String | Op Op IExpr IExpr --
08:44:41 <edwardk> you forgot that the outermost word there is a data constructor, not the type Op
08:45:05 <wvd> edwardk, ah right.
08:45:13 <edwardk> then Op Add (Num Int) (Var "Hello") is an IExpr like you probably want
08:45:21 <wvd> yeah, thanks.
08:48:19 <mtnviewmark> Blkt - the problem is that (t par) and (p par) are still Int, but you are using them in a * or + expression with a Float
08:48:32 <mtnviewmark> there is no automatic "up conversion" of numerics in Haskell
08:49:08 <mtnviewmark> wouldn't this be easier to work with: type Parameters' = (Float, Float, Float, Float)
08:49:21 <mtnviewmark> Why are the last three defined as Int in your version?
08:49:41 <Blkt> because they're always Int in the problem formulation (university project)
08:50:06 <Blkt> iterated prisoner dilemma
08:50:13 <Blkt> (sort of)
08:50:37 <wvd> Is ~= a standard function?
08:50:45 <hpc> :t (~=)
08:50:46 <lambdabot> Not in scope: `~='
08:51:08 <hpc> er, isn't that the regex match operator?
08:51:11 <wvd> I mean =~*
08:51:17 <aavogt> @type (=~)
08:51:18 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:51:24 <wvd> Ah
08:51:30 <wvd> Thanks.
08:51:36 <hpc> it isn't defined in Prelude though, i don't think
08:52:23 <mtnviewmark> Blkt - okay, so the issue is that you've got mostly Int, and I get why you want to correctly model them as Int, but that you've got to evaluate them in a Float context alot --- so they are awkward to work with
08:52:35 <mtnviewmark> the solution is to redefine your accessors so that they are more flexible
08:52:40 <mtnviewmark> t :: (Num a) => Parameters -> fromInteger a
08:52:41 <mtnviewmark> t (_,x,_,_,_) = x
08:52:56 <mtnviewmark> Now you can use (t par) and let Haskell do the work
08:53:19 <mtnviewmark> er
08:53:30 <mtnviewmark> ignore that last paste
08:53:32 <mtnviewmark> silly
08:53:33 <mtnviewmark> t :: (Num a) => Parameters -> a
08:53:33 <mtnviewmark> t (_,x,_,_,_) = fromInteger x
08:53:34 <mtnviewmark> there
08:53:44 <Blkt> mtnviewmark: nice, thank you
08:54:22 <mtnviewmark> onece more
08:54:25 <mtnviewmark> that should be
08:54:29 <mtnviewmark> t :: (Num a) => Parameters -> a
08:54:30 <mtnviewmark> t (_,x,_,_,_) = fromIntegral x
08:54:41 <mtnviewmark> I always get fromInteger and fromintegral confused
08:54:51 <Blkt> :D
08:54:56 <aavogt> what's there to confuse?
08:55:10 <aavogt> @type [fromInteger, fromIntegral]
08:55:11 <lambdabot> forall a. (Num a) => [Integer -> a]
08:56:02 <aavogt> so you never need fromInteger, unless you write a Num instance
08:57:14 <mtnviewmark> Blkt - so now all your expressions are of the form: (fromIntegral i*(t par)+4*(p par))/(1-(w par))
08:57:24 <mtnviewmark> which begs the question - why build the list only to index it?
08:57:25 <mtnviewmark> why not
08:58:00 <mtnviewmark> meanygain'' :: Parameters -> Int -> Float
08:58:01 <mtnviewmark> meanygain'' par n = (fromIntegral n*(t par)+4*(p par))/(1-(w par))
09:00:16 <mtnviewmark> updated version posted to your pastebin, Blkt
09:00:44 <Blkt> thanks mtnviewmark , I was getting mad correcting it
09:01:41 <copumpkin> edwardk: very nice
09:01:45 <mtnviewmark> Blkt - was there a typo in the original: the middle element of the list had 2*(p par) rather than 4*
09:02:36 <wvd> BONUS, sorry for being inpatient, but any concrete date for the Monads chapter :$?
09:02:53 <mtnviewmark> if that difference was intentional, I can show you how to handle it, still without building the list
09:03:06 <ddarius> BONUS: This is your reward.
09:03:12 <Blkt> mtnviewmark: could you link it to me? I don't get the updated version
09:03:17 <BONUS> haha :)
09:03:25 <mtnviewmark> http://pastebin.com/TCeq2Bek
09:04:04 <BONUS> wvd: well i have to give it to my publisher in like three weeks, so that's the latest date. but i'll put it up sooner to get some feedback from people
09:04:15 <wvd> cool
09:04:18 <wvd> thanks
09:04:34 <BONUS> but in three weeks you can be a monad master anyway
09:04:46 <Blkt> mtnviewmark: thank you very much, it made me mad for almost a whole day
09:05:25 <BONUS> wvd: the key is to lurk #haskell and wait until Cale is chatty and then ask him to explain monads
09:05:25 <mtnviewmark> yes, dealing with numeric types in Haskell can be very vexing if you are used to other languages, and before you get tricks like the polymorphic accessors under your belt
09:05:28 <BONUS> insight guaranteed
09:05:33 <mtnviewmark> did you see my question about the typo?, Blkt?
09:05:37 <ddarius> Just try my patented monad growing serum: http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
09:06:06 <Cale> meow
09:06:19 * mtnviewmark is too wary to click on random .ps files
09:06:27 * hackagebot ad 0.21 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.21 (EdwardKmett)
09:06:32 <hpc> it's just postscript
09:06:39 * mtnviewmark wonders if ddarius has implemented Monads in PostScript...
09:06:41 <ddarius> So edwardk just stopped for sleep.
09:06:41 <Blkt> mtnviewmark: yes I saw it, it is not a typo, it's the way the actors in the game behave
09:06:43 <hpc> save your worry for PDFs
09:06:51 <mtnviewmark> ah, then
09:06:57 <Blkt> mtnviewmark: do you know anything about iterated prisoner dilemma?
09:06:57 * copumpkin barks at Cale 
09:07:05 <mtnviewmark> add this:    where f = if n == 2 then 2 else 4
09:07:11 <mtnviewmark> and replace the 4* with f*
09:07:23 <mtnviewmark> Blkt - nothing in particular
09:07:25 <wvd> BONUS, well, I've read some simple tutorials which said things like: "you need monads when you need side-effects" but I decided to stay away and wait for your chapter :P
09:07:46 * BONUS wonders why all academic urls are like http://www.bale.pc.ak.inf.edu-info.info.org/something
09:08:12 <ddarius> Edinburgh academic UK
09:08:40 <ddarius> From there it is just the fact that universities have multiple campuses and divisions and so the namespace is split up accordingly.
09:08:41 <BONUS> universities *love* subdomains
09:09:00 <mtnviewmark> new version, Blkt: http://pastebin.com/aCKwembt
09:09:16 <hpc> then there's http://cs.harvard.postdoc.en.info.edu/home/~professor/cs/academics
09:09:28 <ddarius> BONUS: The (US) military is the same way.
09:09:42 <BONUS> wvd: if you understand how applicatives work monads aren't that big of a leap. a lot of good info out there right now
09:09:51 <hpc> subdomains are cheaper than top-level domains, i think is the reason
09:09:56 <Blkt> mtnviewmark: that should do the trick, let me test it
09:10:01 <arw> well, one could argue that splitting up by the structure of the organisation is the point of subdomains.
09:10:16 <arw> its just that most commercial organisations do it more like the marketing dept wants.
09:10:18 <ddarius> hpc: Yes and no.  Mostly no.  Why would a school get another top-level domain.
09:10:26 <ddarius> arw: Exactly.
09:10:39 <ddarius> For a commercial site, it is better to present a coherent facade.
09:10:42 <wvd> BONUS, problem is, I don't understand functors already, so understanding applicatives is impossible then :P
09:10:53 <mtnviewmark> Blkt - good deal- let me know if there is anything about that you don't understand thoroughly - it'll be your project submission after all! :-)
09:11:13 <BONUS> wvd: haha, get busy then!
09:11:26 <chrisdon`> http://github.com/chrisdone/haskell-json/raw/706f53028d2d31387ac268115073aedc59ce5416/src/haskell-json.hs
09:11:26 <chrisdon`> http://github.com/chrisdone/haskell-json/raw/9c5fee0ce2ad6de4d28d98318837d8e302f039bc/src/haskell-json.hs
09:11:26 <chrisdon`> http://github.com/chrisdone/haskell-json/raw/master/src/haskell-json.hs
09:11:29 <chrisdon`> improvement?
09:11:39 <ddarius> hpc: Subdomains are handled by the domains DNS server(s).  So you can make as many and as deep as you want.
09:12:01 <BONUS> i don't see why the structure should be reflected in the domain structure though. something like http://edinbrough.edu/wadler would be far easier to remember
09:12:02 <byorgey> wvd: (shameless plug) have you tried reading the Typeclassopedia?
09:12:22 <byorgey> @where typeclassopedia
09:12:22 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:12:31 <wvd> mmh not really.
09:12:35 <wvd> thanks, going to try that
09:12:35 <hpc> BONUS: that doesn't let you use different physical servers, i don't think
09:12:48 <arw> hpc: cost is really not an issue for larger organisations like universities. a domain costs like 10 dollars per year. most spend more on chalk per room...
09:12:54 <mtnviewmark> re domains: Because domains are just that: "domains of delegated authority" -- it has to do with being about to distribute the administration of the name space
09:12:59 <wvd> byorgey, guess what, haskell.org is down :P
09:13:10 <Blkt> mtnviewmark: I do love you, did you know that?
09:13:17 <Blkt> you solved my problem...
09:13:19 <ddarius> BONUS: The structure usually corresponds to the logical structure on the organization.  Philip Wadler is part of the informatics school.
09:13:20 <Cale> wvd: Need help with stuff?
09:13:41 <wvd> Cale, no need to waste your time. I first need to know some basic concepts like functors.
09:13:42 <mtnviewmark> if one wants to have a simple top domain name, and have all your URLs use only that, then you need central administration of the, at the very least, the redirector server
09:13:49 <ddarius> hpc: The domain name structure does not need to be related to the physical structure at all.
09:13:58 <Cale> wvd: Well, I can explain those. :)
09:14:01 <BONUS> wvd: functors and applicatives are explained in lyah though, so if you like lyah you could read those
09:14:14 <mtnviewmark> aw gee, Blkt.... I'm kinda already in a relationship.....  :-)
09:14:16 <wvd> BONUS, yeah, but already the first sentence about functors confuses me.
09:14:21 <Cale> wvd: Do you know about datatypes?
09:14:28 <wvd> "And now, we're going to take a look at the Functor typeclass, which is basically for things that can be mapped over."
09:14:35 <ddarius> And so BONUS' plan springs into action.
09:14:36 <wvd> mapped over? what exactly do you mean with that.
09:14:40 <Cale> wvd: You know the 'map' function?
09:14:43 <wvd> yeah
09:14:45 <Cale> wvd: (for lists)
09:14:51 <hpc> applicatives are much more clearly explained, imo
09:14:55 <Cale> Well, imagine the obvious generalisation to other datastructures
09:14:56 <Blkt> mtnviewmark: too bad, I'll have to regress to standard "thanks"
09:15:01 <mtnviewmark> heh
09:15:13 <mtnviewmark> laters all
09:15:18 <BONUS> when we do map (+3) [1,2,3], we map the function (+3) over the list [1,2,3]
09:15:23 <Cale> wvd: Something which applies a function to all the 'elements' of a datastructure, or in some cases, to the 'result' of a computation.
09:15:39 <chrisdone> medfly: long time no see
09:15:47 <wvd> I understand, but how are we going to define what "mapped over" is? can I map over an Integer?
09:16:01 <BONUS> (i should probably change that first sentence and include the list example as something that can be mapped over)
09:16:01 <Cale> wvd: No.
09:16:08 <mauke> wvd: first you need a container
09:16:17 <ddarius> BONUS: Have you ever read a web comic called "Wigu" at some point?
09:16:21 <Cale> wvd: If f is a functor, then we have a function   fmap :: (a -> b) -> f a -> f b
09:16:24 <hpc> wvd: the definition that helped me was that fmap/map apply the function to the inside of the container
09:16:29 <BONUS> ddarius: i don't think so, no
09:16:39 <BONUS> got a link?
09:16:40 <Cale> wvd: So f is like a type-level function from types to types (a type constructor)
09:16:40 <medfly> hi chrisdone 
09:16:55 <Cale> wvd: and this fmap will take functions (a -> b), and turn them into functions (f a -> f b)
09:17:13 <wvd> Cale, wait, f is a type constructor?
09:17:14 <Cale> wvd: Does that make sense?
09:17:16 <Cale> Yeah
09:17:22 <edwardk> oh nice, the hessian also became really easy: hessian f = Forward.jacobian (grad (decompose . f . fmap compose))
09:17:29 <hpc> wvd: f can be something like Maybe
09:17:30 <Cale> For example, [] for lists, or Maybe
09:17:43 <BONUS> wvd: are you familiar with Maybe?
09:17:48 <wvd> BONUS, kind of.
09:17:54 <wvd> But.
09:18:01 <Cale> Let's introduce this tree datatype:
09:18:01 <wvd> The type constructor only takes one argument?
09:18:01 <edwardk> the only tricky bit being since grad f :: R^n -> R^n -- it never makes sense to compute the jacobian using reverse mode
09:18:12 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
09:18:24 <Cale> So, "Tree" is going to become our functor
09:18:28 <mauke> wvd: yes
09:18:35 <wvd> Cale, yeah.
09:18:35 <Cale> and we need an  fmap :: (a -> b) -> Tree a -> Tree b
09:18:41 <Cale> So...
09:18:50 <Cale> fmap f Tip = Tip
09:19:05 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
09:19:41 <wvd> Cale, "fmap f Tip = Tip", 'f' is not defined here?
09:19:49 <hpc> f is not used
09:19:55 <hpc> there's nothing to apply f to
09:20:02 <Cale> wvd: f is a parameter to fmap here
09:20:05 <BONUS> wvd: just like when you map something over an empty list, it doesn't matter what you mapped
09:20:13 <ddarius> BONUS: http://www.wigucomics.com/adventures/index.php?comic=1  I haven't read it in years, and had only read about the first couple of years so I give no warranty of merchantability of later work.
09:20:19 <Cale> Tip is our "empty tree"
09:20:39 <BONUS> haha i'll check it out
09:20:57 <hpc> another example is Maybe
09:21:03 <aristid> @src on
09:21:03 <lambdabot> (*) `on` f = \x y -> f x * f y
09:21:05 <hpc> Maybe a = Nothing | Just a
09:21:09 <wvd> Yeah
09:21:19 <mauke> map f [] = []; map f (x : xs) = f x : map f xs
09:21:25 <hpc> so fmap f Nothing = Nothing
09:21:37 <hpc> and fmap f (Just a) = Just (f a)
09:21:58 <hpc> applying the function to the inside of the Maybe, if there is something there to apply it to
09:22:18 <ddarius> BONUS: The great part is Topato.
09:22:24 <wvd> So with
09:22:34 <wvd> fmap f (Just a) = Just (f a)
09:23:02 <wvd> f is a type with a type constructor? e.g. data Bar = Foo String
09:23:08 <mauke> f is not a type
09:23:10 <mauke> f is a function
09:23:15 <hpc> f is the parameter
09:23:24 <hpc> er, a parameter
09:23:29 <Cale> wvd: Oh, sorry, that must be confusing. It's important to keep straight things which are going on at the type level and things which are going on at the value level.
09:23:45 <Cale> When I wrote  fmap :: (a -> b) -> f a -> f b
09:23:49 <Cale> That f is a different f
09:24:00 <hpc> that f is a Functor
09:24:03 <Cale> It's a type-level function (a type constructor, like  Maybe or Tree)
09:24:19 <hpc> the f that is a parameter is just a function
09:24:32 <Cale> But the f parameter when we write fmap f (Just a) is just an ordinary function
09:24:39 <Cale> It's the (a -> b) parameter to fmap
09:24:41 <wvd> Ah
09:24:42 <wvd> Right
09:24:54 <Cale> Sorry for reusing the letter :)
09:25:09 <hpc> > fmap (+2) (Just 5)
09:25:10 <lambdabot>   Just 7
09:25:19 <wvd> I see.
09:25:21 <mauke> > fmap (+2) [5]
09:25:22 <lambdabot>   [7]
09:25:26 <Twey> Hm
09:25:29 <wvd> But, why use fmap over Nothing? It's just a "single" value?
09:25:30 <Twey> on is very similar to liftM2
09:25:36 <wvd> Just*
09:25:40 <wvd> s/Nothing/Just/
09:25:45 <mauke> wvd: huh?
09:25:48 <Cale> wvd: Because maybe you don't know if it's Nothing or Just
09:26:06 <Cale> wvd: and it's convenient to be able to apply a function in the case that it's Just
09:26:08 <BONUS> wvd: why use map over an empty list? because eyou got that list from somewhere else and you don't know if it's empy or not
09:26:14 <Cale> wvd: and leave it alone if it's Nothing
09:26:25 <wvd> ah right
09:26:29 <Twey> wvd: For example, ‘f x = case x of Just y -> y * 2; Nothing -> Nothing’ can be rewritten to f = fmap (* 2)
09:26:39 <mauke> no, it can't
09:26:44 <mauke> that's a type error
09:26:46 <Twey> Er
09:26:49 <Twey> Just (y * 2)
09:26:52 <Twey> Sorry
09:26:57 <hpc> wvd: you will see how useful fmap over Nothing can be when you read the applicative section
09:27:08 <hpc> > (+) <$> Nothing <*> Just 5
09:27:09 <lambdabot>   Nothing
09:27:15 <hpc> > (+) <$> Just 2 <*> Just 5
09:27:15 <lambdabot>   Just 7
09:27:33 <hpc> > (+) <$> Just 2 <*> Nothing
09:27:33 <lambdabot>   Nothing
09:27:58 <hpc> you can use that for error handling, and string together lots of operations and have the whole series return Nothing if any of them fail
09:28:30 <hpc> er, as part of error handling; there's a bit more to it than that
09:28:31 <ville> Where's a good explanation for <$> amnd <*>, I had bit difficulty googling for such tokens
09:28:42 <mauke> @hoogle (<$>)
09:28:42 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:28:44 <kmc> typeclassopedia
09:28:52 <hpc> learn you a haskell has an excellent section on those
09:28:53 <kmc> <$> is just infix fmap
09:29:02 <mauke> ville: do you know Control.Monad.ap?
09:29:07 <ville> hpc: Ok I haven't gotten that far then
09:29:13 <ville> mauke: Not yet.
09:29:14 <kmc> > show <$> [2,3,4]
09:29:15 <lambdabot>   ["2","3","4"]
09:29:30 <kmc> > [pred,succ] <*> [1,5,50]
09:29:31 <lambdabot>   [0,4,49,2,6,51]
09:29:39 <aristid> ville: <$> is just fmap
09:29:42 <hpc> a quick primer though, <$> is fmap, and <*> is a beefed up fmap
09:29:50 <copumpkin> also known as ap
09:29:53 <hpc> > (+2) <$> Just 2
09:29:53 <lambdabot>   Just 4
09:29:55 <kmc> (<$>): apply a single function throughout a "container"
09:29:55 <BONUS> :t (<*>)
09:29:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:30:03 <hpc> > Just (+2) <*> Just 5
09:30:04 <lambdabot>   Just 7
09:30:05 <kmc> (<*>): apply a container of functions to a container of values
09:30:11 <copumpkin> omg it's kmc
09:30:12 <aristid> copumpkin: isn't ap just the <*> for Monads?
09:30:12 <kmc> with the caveat that "container" is a general term here
09:30:15 <kmc> omg it's copumpkin
09:30:16 <ville> Ok I'll find them in RWH
09:30:17 <aristid> :t ap
09:30:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:30:20 <copumpkin> aristid: yep
09:30:27 <aristid> :t <*>
09:30:27 <kmc> ap = (<*>) for any well-behaved Monad
09:30:28 <lambdabot> parse error on input `<*>'
09:30:35 <aristid> :t (<*>)
09:30:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:30:46 <aristid> @src ap
09:30:46 <lambdabot> ap = liftM2 id
09:31:21 <aristid> :t liftM2
09:31:21 <wvd> When I want to make an instance of Functor it needs to be a function which returns a concrete type with 1 argument? e.g. instance Functor (MyType String) where works, if I had like: data MyType = MyType String Int?
09:31:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:31:37 <aristid> is the (m :: * -> *) new?
09:31:43 <copumpkin> sort of
09:31:46 <copumpkin> it's not standard
09:31:48 <copumpkin> but it's not new
09:31:53 <mauke> wvd: no, with that 'data' definition, 'MyType String' is invalid
09:31:59 <aristid> copumpkin: don't recall seeing it
09:32:10 <copumpkin> aristid: it's telling you that m is a type constructor of kind * -> *
09:32:22 <wvd> mauke: why? doesn't it produce a function with takes one argument and returns a concrete type?
09:32:30 <mauke> wvd: huh?
09:32:36 <mauke> wvd: it's a type, it doesn't produce anything
09:32:38 <Cale> wvd: When you make an instance of Functor, it requires the thing to be a type-level function.
09:32:56 <mauke> wvd: 'data X = ...' means X has no parameters
09:32:56 <hpc> in "data Maybe a = Nothing | Just a"
09:33:05 <Cale> wvd: So, if you write  instance Functor MyType   then MyType had better take one type parameter
09:33:06 <mauke> wvd: so 'X Y' is malformed
09:33:08 <wvd> Such as, :t Just is a function which takes one argument and returns a concrete type.
09:33:10 <hpc> the important part is "data Maybe a"
09:33:13 <BONUS> you make Maybe an instance of Functor, not Nothing or Just.
09:33:13 <wvd> Oh right
09:33:18 <wvd> I need to specify those arguments.
09:33:21 <BONUS> and it has to take one type parameter, like Maybe a
09:33:26 <Cale> Or if you write  instance Functor (MyType String),  then MyType had better take *two* type parameters
09:33:39 <wvd> So with data MyType a a = MyType a a -> instance Functor (MyType String) works?
09:33:39 <Cale> (The first of which is being applied to String here)
09:33:54 <mauke> wvd: that doesn't look like valid Haskell98
09:33:54 <Cale> data MyType a b = M a b  perhaps
09:34:02 <Cale> you can't reuse the variable like that
09:34:10 <wvd> erhm, typo.
09:34:11 <wvd> Sorry.
09:34:13 <mauke> wvd: instance Functor (MyType x) ...
09:34:22 <mauke> I don't think you can use String there
09:34:23 <copumpkin> data Moo a b where Moo :: Moo a a
09:34:54 <copumpkin> you can reuse it there :)
09:35:36 * copumpkin kind of wants to abolish non-GADT ADT syntax
09:35:54 <copumpkin> sure, it's more redundant GADT style but it's also kind of nice
09:40:41 <copumpkin> @ask glguy I noticed on the (old) reddit 6.12 platform announcement you mentioned that your snow leopard GHC appeared to be 64-bit. Does it actually generate 64-bit code? Or is it some weird hybrid that has Int = Int64 but still produces 32-bit code?
09:40:41 <lambdabot> Consider it noted.
09:42:08 <jmcarthur> i love making functional libraries, but wrapping imperative libraries to expose a purely functional interface sucks
09:42:32 <jmcarthur> it's like the task you're performing is *exactly* what you do functional programming to avoid
09:43:01 <wvd> heh, I was always wondering if it's hard to write libaries in C for Haskell, since you need to have an API which works for functional concepts.
09:43:16 <jmcarthur> well, you don't need to, but it makes your haskell more pleasurable
09:43:33 <ezyang> IMO, in many cases you had to have designed for persistence originally 
09:43:45 <ezyang> and the binding will always feel unnatural if you didn't 
09:43:56 <jmcarthur> well, i didn't write the library, so... :\
09:44:19 <ezyang> "yep" 
09:44:47 <mauke> wvd: in general, you can call any C library from Haskell
09:44:55 <mauke> it doesn't have to be "written for Haskell"
09:45:04 <jmcarthur> (i'm making a purely functional, but still low level interface to opengl)
09:45:16 <wvd> mauke, true. but if it works well is a second point.
09:45:17 <copumpkin> :O
09:45:21 <copumpkin> jmcarthur: how does that work?
09:45:23 <wvd> jmcarthur, isn't there hopengl?
09:45:56 <jmcarthur> copumpkin: well, for example, i'm using operational semantics similar to DiffArray for the buffer objects
09:46:02 <copumpkin> :O
09:46:21 <jmcarthur> wvd: that's not pure! :P
09:46:54 <jmcarthur> copumpkin: as you can imagine, coding the thing is Tedious
09:47:01 <copumpkin> I bet
09:47:23 <jmcarthur> i think there will be a reasonably nice payoff for it though in terms of mental overhead when i use it later :)
09:47:32 <Null-A> haskell is at 1.82 on the computer language shootout, any ideas on the huge perf improvement?
09:47:50 <jmcarthur> Null-A: what was it before? and how long ago are you comparing to?
09:48:01 <Null-A> jmcarthur: I think it was at ~3 a few weeks ago
09:48:44 <Null-A> I don't recall ever seeing it below 2
09:49:07 <jmcarthur> i know a few weeks ago there was some regressions. maybe we just fixed them?
09:49:13 <jmcarthur> s/was/were/
09:49:24 <jmcarthur> i don't know who does that stuff
09:49:25 <Null-A> oh ok
09:49:45 <copumpkin> Null-A: which one?
09:49:58 <Null-A> I'm just looking at the average score
09:50:02 <Null-A> I don't know which benchmark changed
09:50:09 <jmcarthur> i'm seeing 3.17 for the average score
09:50:12 <copumpkin> I mean, 64/32 quad/single
09:50:21 <copumpkin> there are lots of subareas of the shootout
09:50:48 <aristid> liftM2 id is a devious way of writing liftM2 ($)
09:50:52 <Null-A> "	Haskell GHC	1.00	1.00	1.43	1.82	" copumpkin 
09:50:54 <pokoko222> someone has done some work with NURBS in haskell?
09:51:03 <Null-A> It's right after java 6 steady state 
09:51:07 <aavogt> use opengl, pokoko222?
09:51:16 <copumpkin> pokoko222: there are purely functional splines somewhere, but I guess you want to draw them?
09:52:03 <pokoko222> copumpkin yeah i want to program them, not use opengl
09:52:08 <copumpkin> http://hackage.haskell.org/package/lazysplines
09:52:17 <copumpkin> not quite NURBS, but might give you some ideas
09:54:18 <byorgey> pokoko222: I think edwardk mentioned to me a while ago that he had some NURBS code
09:54:34 <byorgey> but IIRC it was unpublished
09:54:39 <byorgey> but you may want to ask him about it
09:54:53 <pokoko222> ok
09:54:54 <copumpkin> soon he'll be giving you tangents to those curves :P
09:54:55 <copumpkin> with his new package
09:55:23 * edwardk looks up
09:55:26 <edwardk> hah
09:55:47 <byorgey> hehe
09:56:17 <edwardk> you want real nurbs not the anemic little things from opengl?
09:56:23 <copumpkin> lol
09:56:31 <jesusabdullah> nurbs are a real thing?
09:56:39 <dmwit> oh, BURN
09:56:44 <copumpkin> jesusabdullah: why not?
09:56:46 <jmcarthur> aren't "opengl nurbs" just glu stuff anyway?
09:57:10 <jesusabdullah> copumpkin: idk, silly name I guess :)
09:57:21 <copumpkin> non-uniform rational b-spline :P
09:57:53 <copumpkin> pokoko222: what do you need them for, anyway? and have you learned all of math and category theory and haskell now? is that why you don't hang out in here anymore?
09:57:54 <b0fh_ua> Hello! How do I solve the issue when having both bytestring-0.9.1.6 and bytestring-0.9.1.5 installed and registered? When trying to remove any of them I'm getting a lot of dependencies to break.
09:58:33 <dmwit> Use cabal, or ghc-pkg hide.
09:58:39 <Cale> b0fh_ua: Basically, I think you have to accept that you're going to break a bunch of deps and reinstall things to keep them straight.
09:58:45 <pokoko222> copumpkin well i did calculus at college, i have enough linear algebra knowledge, and i am interested in cad programming so. that is why nurbs
09:58:47 <dmwit> Or reinstall the things that depend on the older one.
09:58:55 <edwardk> http://www.amazon.com/Nurbs-Projective-Geometry-Practical-Use/dp/1568810849 is probably where i'd start
09:58:55 <Cale> dmwit: Usually not.
09:59:20 <Cale> Usually you want to install everything such that the version of bytestring used agrees with the bytestring that comes with your ghc.
09:59:24 <pokoko222> copumpkin category theory is on the list yes, but in two years maybe, i gotta pass first next college year, including cool stuff like: information theory, probability and statistics, numerical methods and other cool stuff
09:59:33 <copumpkin> ah
09:59:50 <edwardk> by the time you get around to understanding knot insertion and the de Boor algorithm you'll have it pretty well down
09:59:59 <copumpkin> sounds Booring to me
10:00:25 <copumpkin> de Boor thinks knots are forever
10:00:29 <edwardk> copumpkin: hrmm, i thought i was de Booring you. I must have flipped the polarity
10:00:47 <copumpkin> :P
10:01:02 <Cale> heh, "have you tried reversing the polarity?"
10:03:19 <Cale> edwardk: That's weird, the NURBS page links from the word "knots" to a definition of the word for digraphs.
10:03:31 <Cale> edwardk: Is there a relationship there?
10:04:09 <edwardk> hrmm
10:04:16 <edwardk> haven't really thought about it
10:05:22 <ddarius> The kiwi was not ripe.
10:05:29 <Cale> Heh, it reminds me a bit of my evil plan to make a bot which spuriously makes random almost-sensible links between articles on wikipedia.
10:06:13 <Cale> (Take random words in articles for which there is an article of that name and turn them into links :)
10:07:09 <jmcarthur> evil
10:07:21 <hpc> if you limited that bot to words longer than say, 8 characters, that would be really useful
10:07:29 <ddarius> Cale: Working on how to undo that would be more interesting.
10:08:29 <jmcarthur> damn, i need to make these functions thread safe, too. i forgot all about that
10:11:55 <aristid> somehow, using id as ($) seems "evil" to me, but i can't articulate why precisely.
10:13:01 <mauke> Cale: <Foone> that's a quote from 2005, right?  <Foone> and he's been running it constantly since then?
10:13:12 <benmachine> it's educational
10:13:12 <lambdabot> benmachine: You have 1 new message. '/msg lambdabot @messages' to read it.
10:13:20 <Cale> mauke: what?
10:15:20 <benmachine> darcs failed:  fromSlurpFile:  Couldn't find file "./Data/Generator/Compressive/LZ78.hs"
10:15:31 * copumpkin imagines newbie questions in agda like appear in #haskell. The equivalent of "I have an IO String and need a String, how can I get it?" might be "My goal is _|_ and I need a value of that type. Anyone know where I can find it?"
10:15:34 <benmachine> ^ this is what I get trying to darcs get http://comonad.com/haskell/monoids/
10:16:16 <copumpkin> bug edwardk 
10:16:40 <copumpkin> ddarius: that's terrible
10:16:47 <copumpkin> (the unripe kiwi)
10:19:13 <edwardk> benmachine: ack
10:19:25 <hpc> :t id
10:19:25 <lambdabot> forall a. a -> a
10:19:27 <hpc> :t ($)
10:19:28 <lambdabot> forall a b. (a -> b) -> a -> b
10:19:45 <edwardk> benmachine: erm. you can uh.. grab it from the monoids-0.1.36.tar.gz on hackage? =)
10:20:14 <copumpkin> I thought there was a newer version than that
10:20:22 <ezyang> maybe because id isn't strictly binary 
10:21:08 <edwardk> copumpkin: i plan on largely reverting
10:21:16 <copumpkin> oh?
10:21:18 <copumpkin> how come?
10:21:23 <edwardk> i took out too many goodies with 0.2
10:23:25 <jmcarthur> yes you did
10:23:28 <jmcarthur> :)
10:24:38 <jmcarthur> it would be nice if we had this defined:  takeMVar_ :: MVar a -> IO ()
10:33:14 <dancor> idM_ = (>> return ())
10:34:49 <jmcarthur> idM_ = (()<$)
10:35:04 <jmcarthur> but that's still not as nice as just using takeMVar_  ;)
10:36:58 <benmachine> fff
10:37:01 <hpc> takeMVar_ = takeMVar `idM_` ?
10:37:15 <benmachine> idM_ takeMVar
10:37:30 <roconnor> turns out that all I've been taught about concurent programming is wrong.
10:37:36 <benmachine> roconnor: ouch
10:37:39 <zygoloid> const () <$> takeMVar
10:37:41 <benmachine> what led to this insight?
10:37:43 <roconnor> apparently we don't get a consistent view of memory because of caching
10:37:53 <benmachine> eek
10:37:59 <zygoloid> roconnor: right. memory barriers ahoy!
10:38:02 <ddarius> roconnor: Why would caching give a consistent view?
10:38:30 <zygoloid> roconnor: things are a bit nicer on x86 at least, since it's almost always strongly-ordered
10:39:28 <pumpkin> Omg
10:39:36 <zygoloid> coomg?
10:39:43 <BONUS> yeah but there should be cache coherence mechanisms
10:39:54 <BONUS> like snooping
10:40:04 <zygoloid> BONUS: not on all architectures
10:40:16 <benmachine> edwardk: I found a darcs repo for reflection-0.1.0 but hackage has 0.3.0
10:40:20 <roconnor> ddarius: because writes are cached and so if you do a read on another processor you won't necessarily see the write
10:40:27 <benmachine> what's up with that
10:40:35 <zygoloid> BONUS: plus some architectures reorder reads and writes anyway
10:40:39 <BONUS> ah
10:41:07 <roconnor> you can with tonnes of effort get conistency ... maybe
10:41:15 <roconnor> but in the end it just isn't worth while
10:41:25 <roconnor> bending our cpus to fit our models of concurency
10:41:29 <benmachine> so what do you do
10:41:29 <roconnor> it is better to make new models
10:41:32 <benmachine> oh
10:41:44 <benmachine> sounds scary
10:41:54 <zygoloid> the CPU abstraction leaks /heavily/ if you can view it from another processor
10:43:22 <ddarius> roconnor: Exactly.  This is what I've been saying about the shared memory model of concurrency.  It becomes less and less true even on a single processor.
10:54:22 <edwardk> benmachine: i don't upload everything to comonad i'll see if i have it locally and patch-tag it
10:55:15 <benmachine> edwardk: I started out trying to be helpful and now have probably caused you more work than I've saved, sorry about that >_>
10:55:49 <ezyang> I wonder if counter-example based error messages would be a usability win. 
10:56:12 <ddarius> ezyang: Such things have been considered and probably would be helpful in many cases.
10:58:57 <edwardk> benmachine: hahah no worries =)
10:59:39 <edwardk> benmachine: hrmm i suppose the missing file might be why i can't get patch-tag to initialize from the comonad.com/haskell/monoids repo
11:00:32 <ddarius> benmachine: You can check if you've affected his productivity by considering the second derivative of the sequence of version numbers for the ad package.
11:00:45 <benmachine> hah
11:00:46 <benmachine> noted
11:01:22 <edwardk> hahah, if you have trouble calculating it, please, feel free to use the package to assist you in your calculation ;)
11:11:00 * hackagebot ad 0.22 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.22 (EdwardKmett)
11:11:11 <edwardk> apparently benmachine hasn't cost me too much productivity ;)
11:12:07 <benmachine> \o/
11:12:31 <edwardk> i could probably stand to slow my release cycle down. ;)
11:12:40 <benmachine> /o\
11:13:01 <c_wraith> now, did your cheering guy just fall over, or is he taking cover against falling debris?
11:13:16 <benmachine> he's holding his hands to his head in horror
11:13:56 <edwardk> what i want to figure out is how to use the combinators i have or minor generalizations to make a tower of answer, jacobian, hessianTensor, etc,
11:14:00 <edwardk> i.e.
11:15:21 <edwardk> gradients :: (Traversable f, Traversable g) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (a, f (a, f (a, ...))) 
11:15:48 <edwardk> which would be something like g (Cofree f a)
11:16:28 <edwardk> as, as usual, it all comes back to category theory
11:19:19 <altmind> hi
11:24:43 <byorgey> hi altmind 
11:38:45 <illissius`> @hoogle a -> [a]
11:38:45 <lambdabot> Prelude repeat :: a -> [a]
11:38:45 <lambdabot> Data.List repeat :: a -> [a]
11:38:45 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:44:55 <TheMagician> is there a mirror for "ghc-6.12.2-i386-windows.exe (64 MB); a Windows Installer for GHC 6.12.2"?
11:45:07 <pokoko222> edwardk is not here, anyone else i can ask about nurbs here? :)
11:49:26 <temoto> Hello. I can't compile language-python, because needs more memory. Any way to work around that?
11:49:41 <FauxFaux> Get more memory.
11:50:06 <opqdonut> use swap
11:50:49 <arjanb> or try disabling optimizations
11:51:36 <opqdonut> -Ocompiletime
12:00:03 <dons> temoto: needs to use ghc 6.10.x
12:00:13 <dons> temoto: this is a known bug in 6.12.1,2 at the moment.
12:02:06 <wvd> So there are those two functor laws, but why don't the compilers obey these rules, so when they're not applied on the functor it results in an error?
12:02:34 <BONUS> wvd: it's impossible to write such a compiler
12:03:00 <jmcarthur> temoto: i've managed to get it to compile by turning off optimizations :(
12:03:09 <jmcarthur> temoto: -O1 might work okay too, but i didn't try it
12:03:20 <jmcarthur> temoto: oh, and i limited the heap to like 3G
12:03:23 <wvd> BONUS, oh ok.
12:03:39 <BONUS> and not just that we don't know how, it's been proven impossible
12:04:10 <Paul___> What has?
12:04:31 <BONUS> someone correct me if i'm wrong though
12:04:31 <wvd> Also just a random question, since you don't really have global variables, and you can't have side-effects, how would you print to the console/debug when you're parsing something which was a type signature of String -> String?
12:04:43 <mauke> @index trace
12:04:43 <lambdabot> Debug.Trace
12:05:00 <CGI537> give it 2 me babay, help me to see her naked: http://www.sexy-fussball-wm2010.net/?id=6348406
12:05:01 <temoto> dons, thanks. This is terrible.
12:05:25 <dons> temoto: ghc 6.10.4 is fine. 
12:05:26 <temoto> jmcarthur, thanks. Will something like cabal build -O1 do?
12:05:28 --- mode: ChanServ set +o mauke
12:05:29 --- kick: CGI537 was kicked by mauke (CGI537)
12:05:29 --- mode: mauke set +b *!*@s5.miete-server.de
12:05:35 <dons> no, -O0 or -O1 don't help
12:05:41 <tensorpudding> sexy fussball?
12:05:48 <mauke> marienz: hi, looking for spammers?
12:05:56 <BONUS> Paul__: see halting problem
12:06:00 <marienz> mauke: how did you guess?
12:06:01 <tensorpudding> fussball sounds unsexy
12:06:06 <marienz> mauke: do you have one for me?
12:06:10 <mauke> because I just kickbanned CGI537!~4e37dc8a@s5.miete-server.de
12:06:14 <temoto> dons, but that would mean i must recompile everything as well, which is kinda step back.
12:06:35 <marienz> mauke: thanks, klined
12:06:39 <dons> temoto: you'll need to get the 6.10.4 installer, and cabal install libraries, yes.
12:06:42 <dons> thanks marienz !
12:07:29 --- mode: mauke set -o mauke
12:07:58 <benmachine> BONUS: but might Functor be a bit different on the grounds that there's only one possible implementation of fmap?
12:08:12 <benmachine> it ought not to be impossible to work out if a given implementation is "the" fmap for that type
12:08:38 <benmachine> or you could just only allow Functor to be derived
12:08:39 <BONUS> benmachine: i thought there are several possible fmap implementations
12:08:50 <Paul___> are you talking about a compiler that would garentee a perfectly optimized program?
12:08:53 <BONUS> instance Functor [] where fmap f xs = xs
12:09:01 <BONUS> i think this satisfies the laws
12:09:02 <benmachine> BONUS: doesn't typecheck
12:09:08 <BONUS> oh, bugger
12:09:08 <benmachine> you need [a] -> [b]
12:09:11 <BONUS> right
12:09:16 <BONUS> how about
12:09:38 <BONUS> instance Functor [] where fmap f xs = []
12:09:44 <benmachine> fmap id /= id
12:09:53 <BONUS> right-o
12:10:11 * benmachine wonders if unsafeCoerce allows cheating
12:10:28 <benmachine> it... probably does
12:10:36 <Twey> Cheating the functor laws?
12:10:39 <benmachine> yes
12:10:42 <Twey> How?
12:10:45 <benmachine> well
12:10:59 <benmachine> fmap f xs = unsafeCoerce xs
12:11:04 <benmachine> satisfies fmap id = id
12:11:10 <benmachine> and fmap prettymuchanythingelse = broken
12:11:23 <benmachine> so fmap (f . g) = fmap f . fmap g is probably satisfied by default :P
12:12:14 <benmachine> but this is kind of silly because the semantics involved don't even know what "segfaulting the compiler" is
12:12:34 <Twey> Haha
12:12:42 <Twey> Nice
12:13:54 <BONUS> hmm interesting. has anyone written a (semi)formal proof that there's only one Functor instance for a data type?
12:14:11 <hpc> not that i have heard of
12:14:19 <benmachine> BONUS: I've asked this a few times, perhaps sometimes I've even been given an answer
12:14:23 <benmachine> but I keep forgetting >_>
12:14:31 <benmachine> you can do an extremely informal proof
12:14:38 <BONUS> now that i think about it it seems intuitive
12:14:53 <benmachine> on the sort of grounds of, you have a function f, and you can't do anything with it except apply it to the a in the structure
12:14:54 <BONUS> well any sort of proof that's convincing realyl
12:15:14 <benmachine> and you must apply it to every a
12:15:24 <benmachine> and you can't do anything else, otherwise you wouldn't get fmap id = id
12:15:27 <benmachine> QED :P
12:15:31 <BONUS> haha, nice try
12:16:04 <BONUS> a proper proof has to be typeset in TeX and have a lot of greek letters and letters with at least two indices
12:16:09 <benmachine> :D
12:16:50 <ddarius> BONUS: Well, one thing you could do is show that if there is only one functor for f and one functor for g then there is only one functor for f . g.
12:17:28 <ddarius> Then show that there is only one functor for 1, and (,) (for each argument) and Either (for each argument) and you can then build up all non-recursive types.
12:18:02 <BONUS> ah, so sort of proof by construction?
12:18:06 <BONUS> that would work yeah
12:18:13 <ddarius> BONUS: Proof by induction on the structure of types.
12:18:23 <BONUS> right, i always mix those two up
12:18:48 <benmachine> is 1 in this case something like data Foo a = Foo?
12:19:08 <ddarius> benmachine: Yes.
12:19:25 <benmachine> neat
12:26:07 <BONUS> so then i guess that checking if something satisfies the functor laws is decidable
12:29:44 <ddarius> BONUS: Not in general.
12:29:58 <BONUS> how so
12:30:16 <ddarius> You are equating functions.  That's not decidable in general.
12:31:06 <hpc> you can have fmap = id . id . const id id . etc, littered in your fmap definition
12:31:48 <sinelaw> howdy mateys!
12:31:57 <ddarius> data Collatz a = Collatz Integer a; instance Functor Collatz where fmap f (Collatz n a) = collatz n `seq` Collatz n (f a)
12:32:31 <BONUS> ah, haha, clever
12:32:45 <benmachine> seq always ruins everything :(
12:32:53 <ddarius> benmachine: It's not seqs fault there.
12:32:59 <benmachine> true
12:33:37 <ddarius> Collatz n (applyNTimes (collatz n) f a) would have the same issue.
12:33:50 <benmachine> would that typecheck?
12:33:55 <benmachine> no
12:34:01 <benmachine> erm
12:34:02 <benmachine> no
12:34:04 <benmachine> but I see your point
12:34:06 <ddarius> It wouldn't.
12:34:35 <AmunRa> Hello! Is haskell.org down.. or is it my ISP ?
12:34:40 <hpc> it is down
12:34:45 <ddarius> Anyway, to definitely and elegantly answer the question a higher-kinded parametricity theorem is needed.
12:35:46 <bos> @seen jaffacake
12:35:46 <AmunRa> is there a mirror?
12:35:46 <lambdabot> Unknown command, try @list
12:35:53 <bos> preflex: seen jaffacake
12:35:53 <preflex>  jaffacake was last seen on #ghc 2 days, 7 hours, 56 minutes and 21 seconds ago, saying: I just rebuilt cabal-install with 6.12.1 and that fixed it
12:36:01 <zygoloid> ddarius: wouldn't that need to be data Collatz a = Collatz !Integer a? Otherwise fmap id (Collatz undefined a) /= Collatz undefined a
12:36:55 <benmachine> AmunRa: it depends what you want; there isn't a mirror of the whole thing
12:37:09 <benmachine> AmunRa: note that hackage.haskell.org and darcs.haskell.org are fine
12:37:16 <benmachine> and, I believe, code.haskell.org
12:38:01 <AmunRa> I'm after the API docs.. e.g. what's in Data.List or in Prelude
12:38:08 <benmachine> ah, then you're safe
12:38:11 <benmachine> @hackage base
12:38:11 <lambdabot> http://hackage.haskell.org/package/base
12:41:15 <illissius`> oh, that's nice
12:41:19 <illissius`> i'd been using the google cache
12:44:12 <benmachine> so I decided to change my indentation style
12:44:44 <benmachine> now I have to decide whether to CHANGE EVERYTHING and face possible embarassment if I change styles again
12:44:56 <benmachine> or to be inconsistent which is obviously a high form of evil
12:45:15 <opqdonut> change how?
12:45:16 <benmachine> or just to carry on writing code in the old style and pretend it's just as good
12:45:18 <benmachine> what a dilemma.
12:45:23 <benmachine> trilemma
12:45:25 <opqdonut> you must mean trilemma
12:45:27 <opqdonut> gah
12:45:33 <benmachine> :P
12:45:55 <hpc> when used in proofs, it is occasionally called the dilemma-lemma :P
12:46:12 <benmachine> change as in, multiline where clauses don't start on the same line as the where itself
12:46:16 <benmachine> and
12:46:25 <benmachine> two spaces instead of one
12:46:41 <emilmeln> Maybe use something like "indent" for C?
12:46:44 <ddarius> You've been using one space indentation?!
12:46:44 <zygoloid> benmachine: sounds like what i do :)
12:46:48 <davean> \
12:46:49 <benmachine> one space tabs are kind of cute but they tend to lead to massive blocks of evil
12:46:49 <opqdonut> sounds like what i do
12:47:10 <benmachine> emilmeln: but I don't want useless "reindent everything" commits
12:47:17 <benmachine> especially if I decide to revert or change to something else
12:47:33 <benmachine> zygoloid, opqdonut: before or after
12:47:39 <hpc> change to the new style and leave everything as is until you have to touch it again
12:47:43 <hpc> and clean it up as you go
12:47:45 <opqdonut> benmachine: after
12:47:47 <zygoloid> after
12:47:51 <benmachine> ddarius: yeah it works nicely in small cases, but it gets perverse in large blocks
12:48:01 <benmachine> hpc: option #2 then
12:48:06 <opqdonut> so you align "where a = b; foo = bar" so that a and foo start on the same column?
12:48:08 <zygoloid> it'd be nice if darcs could automatically convert between indent styles on checkin/checkout
12:48:27 <benmachine> opqdonut: I used to, but the new style is to newline after where
12:48:30 <ddarius> opqdonut: You have to if you use layout.
12:48:32 <zygoloid> where goes on a line by itself, one half-indent in
12:48:48 <benmachine> yeah
12:48:54 <opqdonut> ah, I leave the where on the same line
12:49:04 <benmachine> zygoloid: re: checkin/checkout, I've often thought that
12:49:05 <ddarius> I don't bother with a newline after where, but I always have a newline after do.
12:49:17 <opqdonut> I almost never have
12:49:28 <zygoloid> i'm tempted to put where on the end of a line rather than on its own line
12:49:28 <benmachine> haskell source files should be stored as a graph, and you should be able to apply your own indentation slash variable names afterwards :P
12:49:30 <ddarius> And I use four space indents primarily but not strictly.
12:49:32 <zygoloid> (that's what i do for 'do')
12:49:45 <hpc> benmachine: XML!
12:49:53 <ddarius> benmachine: Talk to Peaker.
12:49:55 <opqdonut> ddarius: btw, doesn't layout permit indenting the foo = bar line less than "a", as long as it's indented more than the "where"
12:49:56 <benmachine> hpc: that's a little excessive isn't it
12:50:06 <ddarius> opqdonut: No.
12:50:09 <opqdonut> oh
12:50:15 <benmachine> ddarius: they're doing something like that?
12:50:25 <ddarius> opqdonut: Layout allows indenting a less than the where (as long as that doesn't conflict with other blocks of layout.)
12:50:35 <opqdonut> ok
12:50:50 <ddarius> benmachine: Peaker is one person.  He is interested in doing something like that though he just seems to talk about i.t
12:51:04 <benmachine> ddarius: one person yes, but of unknown (to me) gender :P
12:51:12 <jmcarthur> i wish version control was agnostic about silly things like code style
12:51:14 <benmachine> and yes, talking about things is nice
12:51:20 <benmachine> jmcarthur: join the club!
12:51:22 <jmcarthur> yeah peaker is doing something about this
12:51:26 <jmcarthur> supposedly
12:51:31 <benmachine> supposedly.
12:51:35 <benmachine> that's cool
12:51:39 <jmcarthur> i've considered doing it myself, but never got around to it
12:51:43 <benmachine> heh
12:51:51 <jmcarthur> meaning i never will ;)
12:51:54 <benmachine> like so many things :(
12:52:01 <jmcarthur> yeah :(
12:52:13 <jmcarthur> there is not enough time in one lifespan to do everything i want to do
12:52:23 <ddarius> It's a fairly wide-spread idea, but all actual projects to do it seem to fall through, though some aspects have been adopted.
12:52:33 <roconnor> jmcarthur: transhumamism
12:52:36 <ddarius> It's likely that many projects attempting to do such a thing try to reach too far.
12:53:05 <ddarius> For example, intentional programming.
12:53:19 <byorgey> feeping creatures love to devour such projects.
12:53:29 <benmachine> heheh
12:53:41 <jmcarthur> man, OpenGLRaw code gets freaking dense (characters, not concepts)
12:53:45 <EvanR> jmcarthur: that feeling well pass ;)
12:53:47 <EvanR> will
12:53:52 <jmcarthur> EvanR: no, it won't
12:53:55 <EvanR> haha
12:54:45 <benmachine> everything passes eventually!
12:54:54 <jmcarthur> when you're dead!
12:55:02 <benmachine> woo
12:55:22 <illissius`> is there any utility function in base that lets me write "a == b = (foo a) == (foo b)" without repeating the foo?
12:55:31 <jmcarthur> there's a magnet on the fridge where i work that says "Drink coffee! You can sleep when you'
12:55:33 <jmcarthur> dang
12:55:40 <jmcarthur> "[...] when you're dead!"
12:55:42 <EvanR> i dont know if its the drudgery of the real world, or the length of time ive been out of the university system, but i become more bored / satisfied with personal achievements each day. what benefit do my actions have for me or the universe in general, really.
12:55:56 <ksf> jmcarthur, I think the logical conclusion would be to go into the cloning business, then.
12:56:01 <hpc> illissius`: (foo `on` (==))
12:56:02 <EvanR> things either are or arent regardless of whether i know about it
12:56:03 <jmcarthur> EvanR: yeah, i lapse into that occasionally
12:56:08 <hpc> :t (f `on` ==)
12:56:09 <lambdabot> parse error on input `=='
12:56:15 <hpc> :t (f `on` (==))
12:56:15 <illissius`> hpc: oh right, on. thanks
12:56:16 <lambdabot> forall c a. (Show (a -> Bool), SimpleReflect.FromExpr c, Eq a) => a -> a -> c
12:57:10 <ksf> EvanR, whether they are cosmically relevant or irrelevant is wholly irrelevant to the question whether you enjoy what you're doing or not.
12:57:27 <EvanR> if i play out the detailed progression of some project in my head (far faster than really doing it) it seems more and more that thats just as good
12:57:29 * ddarius doesn't drink coffee.
12:57:44 <ksf> as a boy I could spend days picking my nose, and the universe isn't the wiser for it.
12:58:09 <ddarius> jmcarthur: I imagine sleeping at work is frowned upon, so as far as the company is concerned you can sleep on your own time, which is (presumably) what you do.
12:58:21 <ksf> EvanR, you say you'd rather dream about girls than digging one?
12:58:54 <EvanR> had one youd had em all
12:59:25 <ksf> well, then write a note "this is the only achievement left for me" and commit seppuku.
12:59:46 <EvanR> maybe so
12:59:51 <jmcarthur> ddarius: when i first started working there i inherited a computer from somebody who was no longer working there. i found a log file that he kept that tracked what he did when. one of they days went like this:  8am, arrived at the lab. 12:30pm, woke up on the couch
12:59:59 <ksf> the japanese got to be the busy beavers they are that way, I guess.
13:00:03 <jmcarthur> *one of the days
13:00:17 <gwern> jmcarthur: I don't get it
13:00:26 <jmcarthur> gwern: he came to work and fell asleep on the couch
13:00:40 <gwern> jmcarthur: is the joke that he was diligently tracking his lack of diligence?
13:00:52 <ddarius> It wasn't a joke.
13:00:52 <jmcarthur> well, the joke is that it's not a joke :\
13:01:12 <gwern> humor. it is a difficult concept.
13:01:44 <EvanR> lt cmdr data ^
13:01:58 <gwern> EvanR: he spoke sooth!
13:02:14 <ksf> let's get to _business_.
13:02:22 <ksf> what do you guys think of data-reify?
13:02:42 <ksf> is it sufficiently clean or should I listen to the fundamentalists and use do rec?
13:03:34 <gwern> ksf: maybe you should add some modules for learning emotions
13:04:27 <ksf> emotions can't be learned, they're inborn firmware. you can only learn how to deal with them.
13:04:41 <ddarius> jmcarthur: My former supervisor wanted me to keep track of what I did on a daily basis.  I didn't always fill it out the day of so I'd have to fill in previous days upon occasion.  One of the entries was "I can't remember, probably nothing."
13:04:43 <Twey> Disagree
13:05:11 <ksf> ...it'd be like saying "learn to detect photons with your eyes and prcosess horizontal and vertical patterns"
13:05:22 * ddarius starts work on a modularity module, to be followed up with a maintainability module and a security module.
13:05:23 <ksf> that's pre-wired hardware.
13:05:24 <EvanR> we control the horizontal, and the vertical
13:05:27 <ksf> special-purpose chips.
13:05:42 <edwardk1> ksf: that sounds like something from anathem.
13:05:56 <gwern> ddarius: I worked a nightwatch job once when I was younger. we have to maintain a logbook, but no one ever read them. sometimes I would kill time by recording 'fought off 3 velociraptors'
13:06:33 <gwern> 'observed banshees in wood; they fled when approached'
13:07:14 <edwardk1> gwern: and in 10,000 years your logbook will be extracted from some archaelogical dig preserved by some freaking arrangement of minerals and used and with the surviving scraps of xkcd to prove that dinosaurs walked among us
13:07:14 <aristid> ksf: you can reliably detect photons with your eyes?
13:07:29 <ksf> dunno, you'd have to ask my eyes.
13:07:46 <edwardk1> s/freaking/freaky/
13:08:02 <aristid> ksf: maybe they don't detect anything and make it all up at the spot
13:08:13 <ddarius> edwardk1: In 10,000 years most of what is digitally recorded today will no longer exist due to demagnetization.
13:08:22 <ksf> I'm quite sure that there's a second layer of reality beyond my dreams.
13:08:27 <alt> optical storage
13:08:35 <edwardk1> ddarius: heck in 20 years that is likely to be the case ;)
13:08:43 <ddarius> Our archeology will be piles and piles of meaningless circular medal disks.
13:09:03 <soupdragon> demagnetization???
13:09:40 <soupdragon> A demonic demagnetic dearth destroyes digital disinformation?
13:09:54 <byorgey> the medal disks may actually be meaningful, due to being imprinted with things like "3rd place"
13:09:55 <aristid> ddarius: that's just our religion. we worship shiny silver disks made of a weird non-metallic material.
13:10:04 <byorgey> the metal disks, on the other hand... ;-)
13:10:06 <ksf> wtf I'm going to ask my question in -blah.
13:10:42 <ddarius> mettle disks
13:11:01 <soupdragon> I heard that north and south are gonna switch and it will fry us all and that beetlejuice is gonna blow up and other stuff
13:11:13 <illissius`> @hoogle Bool -> a -> a -> a
13:11:14 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
13:11:14 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
13:11:14 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
13:11:28 <ddarius> ksf: Beware the black iron prison cages.
13:11:36 <byorgey> illissius`: that doesn't exist, unfortunately =(
13:11:59 <illissius`> byorgey: easily rectified, though :)
13:12:03 <byorgey> indeed =)
13:12:09 <gwern> edwardk1: velociraptors know no fear and can defeat death. of course they walk among us, like Niels Bohr - unobserved and immortal
13:12:13 <emilmeln> @hoogle (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
13:12:13 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
13:12:13 <lambdabot> Control.Parallel.Strategies (-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
13:12:13 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
13:12:40 <mauke> @djinn (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
13:12:40 <lambdabot> f a b c d =
13:12:40 <lambdabot>     case a d of
13:12:40 <lambdabot>     False -> b d
13:12:40 <lambdabot>     True -> c d
13:13:14 <illissius`> byorgey: though if-then-else is basically the same thing
13:13:29 <byorgey> illissius`: yes, but it's special syntax =(
13:13:58 <emilmeln> imho, if-then-else is somewhat redunant...
13:14:21 <benmachine> somewhat
13:14:24 <ddarius> soupdragon: The poles have reversed multiple times with primates about.  We'll get by.
13:14:29 <benmachine> but it's pretty
13:14:43 <soupdragon> I can't imagine what sort of deranged thought process would have happened for something like 'if/then/else' to be added to haskell
13:15:02 <aavogt> soupdragon: everybody else has it
13:15:11 * byorgey can't imagine what sort of deranged thought process would have happened for something like 'if/then/else' to be called 'pretty'
13:15:12 <aavogt> programming language peer pressure
13:15:18 <byorgey> =)
13:15:22 <ddarius> I don't have a problem with if-then-else, though I do dislike the fact that there is no equivalent library function (and arguably that if-then-else isn't defined in terms of it)
13:15:42 <benmachine> that would be neat
13:15:49 <benmachine> then we could override it with NoImplicitPrelude
13:15:55 <benmachine> just to confuse and upset people
13:15:57 <illissius`> you can use do-notation, if-then-else, braces on their own lines, and semicolons to write code which looks almost like C
13:16:08 <illissius`> though I suppose for many people that's a minus :-)
13:16:11 <Twey> benmachine: Muhaha
13:16:12 <ddarius> If there was only a function I'd have to write if (x == 0) 1 (n * fac (n - 1) instead of if x == 0 then 1 else n * fac (n - 1)
13:16:24 <emilmeln> Also, the Standard is missing "anyM"/"allM".
13:16:34 <Twey> benmachine: Have you seen this?  http://samuelhughes.com/isstring/index.html
13:16:45 <ddarius> benmachine: It would be extremely useful for many EDSLs to be able to override if-then-else.
13:16:47 <Twey> emilmeln: Also untilM
13:16:59 <forrest> I'm still confused about I/O: anyone care to help this poor fool out? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25961#a25961
13:17:03 <benmachine> Twey: lol, IsString Integer
13:17:10 <Twey> :-D
13:17:19 <forrest> doesn't help that www.haskell.org appears to be down
13:17:29 <rj248842> Can someone help me define a (lucid) haskell function f :: [a] -> [a] that returns the alternate elements of the input list?  For example, f [0,1,2,3,4,5] = [1, 3, 5]?  
13:17:30 <emilmeln> Twey: there are plenty of "...M".
13:17:56 <illissius`> forrest: <- and do go together, for one thing
13:18:00 <Twey> forrest: It's not IO you seem to be having a problem with, it's do-notation in general
13:18:19 <Twey> forrest: <- isn't really assignment
13:18:25 <zeiris> Is haskell.org down? :\
13:18:30 <Twey> zeiris: /topic
13:18:42 <forrest> true, I tried to write writePart with do, and couldn't get that to work, ending up using >> instead
13:18:46 <soupdragon> > let keep = return ; drop = const [] in concat $ zipWith ($) (cycle [keep, drop]) [0..5]
13:18:47 <lambdabot>   [0,2,4]
13:18:54 <soupdragon> > let keep = return ; drop = const [] in concat $ zipWith ($) (cycle [drop, keep, keep]) [0..5]
13:18:55 <lambdabot>   [1,2,4,5]
13:19:00 <Twey> forrest: Do you know how to de-sugar do-notation?
13:19:09 <Twey> Into >>= and >>
13:19:14 <aristid> Twey: with @undo
13:19:19 <Twey> aristid: :þ
13:19:26 <forrest> Twey: don't you just put >>= between each line?
13:19:34 <aavogt> @info do x; y ; z
13:19:34 <lambdabot> x >> y >> z
13:19:36 <Twey> forrest: No
13:19:42 <forrest> ah, i am confused
13:19:45 <rj248842> is there some simple, more lucid implementation?
13:19:54 <rj248842> i don't understand that implementation
13:19:54 <Twey> forrest: Very confused ☺
13:20:13 <Twey> forrest: Why don't you read the Typeclassopedia?
13:20:18 <mauke> because it's down
13:20:25 <Twey> @where typeclassopedia
13:20:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:20:28 <Twey> Ick
13:20:37 <Twey> The TMR article shouldn't be
13:20:42 <aavogt> > map snd . filter fst . (zip (cycle [False,True])) $ [0..5]
13:20:43 <lambdabot>   [1,3,5]
13:20:43 <ddarius> illissius`: http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
13:20:47 <Twey> It's on a different site
13:20:50 <aavogt> rj248842: ^^
13:20:54 <forrest> I'd still be fighting this myself if haskell.org were up, I know I have a lot of reading to do
13:21:14 <rj248842> i don't know how long the list is, or what the list contents are
13:21:21 <forrest> but you guys have helped me in the past, and now you're stuck with me :-)
13:21:24 <Twey> forrest: www.catonmat.net/docs/typeclassopedia.pdf
13:21:34 <aavogt> @type map snd . filter fst . (zip (cycle [False,True])) 
13:21:35 <lambdabot> forall b. [b] -> [b]
13:21:49 <Twey> That has a good ground-up introduction to the standard typeclasses, like Functor, Applicative, and Monad
13:21:50 <illissius`> ddarius: oh heh, I've actually seen that before. but guess I forgot about it because I prefer braces on their own lines =)
13:21:53 <aavogt> rj248842: neither does that function
13:24:04 <Twey> > catMaybes . zipWith id . cycle [const Nothing, Just] $ [0 .. 5]
13:24:05 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
13:24:05 <lambdabot>         against inferre...
13:24:10 <Twey> ☹
13:24:16 <Twey> Oops
13:24:24 <Twey> > catMaybes . zipWith id (cycle [const Nothing, Just]) $ [0 .. 5]
13:24:25 <lambdabot>   [1,3,5]
13:24:31 <Veinor> @undo do {x; y <- f z; return q}
13:24:31 <lambdabot> x >> f z >>= \ y -> return q
13:25:09 <Twey> x >> f z >> return q
13:25:10 <ddarius> > catMaybes . zipWith id (cycle [mzero, Just]) $ [0..5]
13:25:11 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) b))
13:25:11 <lambdabot>    arising from a use of...
13:25:20 <ddarius> > catMaybes . zipWith id (cycle [mempty, Just]) $ [0..5]
13:25:20 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:25:20 <lambdabot>    `GHC.Enum.Enum b'
13:25:20 <lambdabot>      a...
13:25:28 <Philonous> > fst $ foldr (\z (x,y) -> (z:y,x)) ([],[]) [1..10]
13:25:29 <lambdabot>   [1,3,5,7,9]
13:25:36 <Twey> ddarius: const mempty
13:25:39 <ddarius> > catMaybes . zipWith id (cycle [mempty, Just]) $ [0 .. 5 :: Int]
13:25:40 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
13:25:40 <lambdabot>    arising from a use of...
13:25:51 <Twey> > catMaybes . zipWith id (cycle [const mzero, return]) $ [0 .. 5]
13:25:52 <lambdabot>   [1,3,5]
13:26:01 <soupdragon> > partition $ zipWith ($) (cycle [Left,Right]) [1..10]
13:26:01 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:26:01 <lambdabot>         against inferred ...
13:26:02 <ddarius> Curse you multiple ways of making Int into a monoid.
13:26:05 <soupdragon> :t partition
13:26:06 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:26:06 <ddarius> Twey: mempty = const mempty
13:26:07 <Twey> Hehe
13:26:07 <soupdragon> :t partitionEithers
13:26:08 <lambdabot> forall a b. [Either a b] -> ([a], [b])
13:26:13 <soupdragon> > partitionEithers $ zipWith ($) (cycle [Left,Right]) [1..10]
13:26:14 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
13:26:15 <Twey> ddarius: Eh?
13:26:22 <zeiris> Are there any mirrors for the Windows build of cabal.exe (cabal-install)?
13:26:27 <Twey> For (e ->)?
13:26:29 <illissius`> ddarius: oh yeah, and uncurried functions so you can write foo( a, b, c );
13:26:37 <ddarius> Twey: Yes.
13:26:43 <Twey> Nice
13:26:54 <Twey> > catMaybes . zipWith id (cycle [mempty, return]) $ [0 .. 5]
13:26:55 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:26:55 <lambdabot>    `GHC.Enum.Enum b'
13:26:55 <lambdabot>      a...
13:27:09 <Twey> Oh, right… hence different monoids
13:27:13 <ddarius> > catMaybes . zipWith id (cycle [mempty, Just]) $ [0 .. 5 :: Sum Int]
13:27:14 <lambdabot>   Ambiguous occurrence `Sum'
13:27:14 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
13:27:20 <ddarius> > catMaybes . zipWith id (cycle [mempty, Just]) $ [0 .. 5 :: Data.Monoid.Sum Int]
13:27:21 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
13:27:21 <lambdabot>    arising fr...
13:27:53 <Philonous> > catMaybes . zipWith id (cycle [mempty, Just]) $ Sum <$> [0 .. 5]
13:27:54 <lambdabot>   Ambiguous occurrence `Sum'
13:27:54 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
13:28:09 <Philonous> > catMaybes . zipWith id (cycle [mempty, Just]) $ Data.Monoid.Sum <$> [0 .. 5]
13:28:10 <lambdabot>   [Sum {getSum = 1},Sum {getSum = 3},Sum {getSum = 5}]
13:28:14 <soupdragon> lol
13:28:22 <Veinor> this is like anti-golfing
13:28:26 <Twey> > map getSum . catMaybes . zipWith id (cycle [mempty, Just]) $ Data.Monoid.Sum <$> [0 .. 5]
13:28:27 <lambdabot>   Ambiguous occurrence `getSum'
13:28:27 <lambdabot>  It could refer to either `Data.Monoid.getSum...
13:28:30 <soupdragon> This is haskaaaaaal!
13:28:30 <ddarius> Sum (and Product) should really be an instance of Num
13:28:33 <Twey> > map Data.Monoid.getSum . catMaybes . zipWith id (cycle [mempty, Just]) $ Data.Monoid.Sum <$> [0 .. 5]
13:28:34 <lambdabot>   [1,3,5]
13:28:36 <Twey> There we go!
13:28:42 <benmachine> wooooo
13:28:47 <benmachine> what was the point of that >_>
13:28:48 <Twey> That's much better than aavogt's original!  ;)
13:29:22 <emilmeln> "There is more than one way to do it" =)
13:29:48 <Twey> Always ☺
13:29:56 <mauke> > iterate (drop 2) [1 ..]
13:29:56 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:30:11 <mauke> > map head $ iterate (drop 2) [1 ..]
13:30:11 <emilmeln> No way for Perl hackers ;)
13:30:12 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:30:15 <ddarius> > map head . iterate (drop 2) $ [1..]
13:30:16 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:30:30 <benmachine> "there are zero or more ways of doing it"
13:30:52 <ddarius> benmachine: (ways of doing it)*
13:30:58 <benmachine> :P
13:31:00 <illissius`> what's "golfing"?
13:31:06 <emilmeln> > [1, 3 ..]
13:31:07 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:31:11 <Veinor> try to solve the problem in the fewest number of (key)strokes
13:31:21 <illissius`> oh
13:31:24 <aavogt> @type zipWith ($) (cycle [(:),const])
13:31:25 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
13:31:25 <lambdabot>       Expected type: [b] -> [b]
13:31:25 <lambdabot>       Inferred type: [b] -> b
13:31:31 <aavogt> @type zipWith ($) (cycle [(:),flip const])
13:31:32 <lambdabot> forall b. [b] -> [[b] -> [b]]
13:31:49 <Veinor> a list of functions of lists
13:31:55 <aavogt> @type foldr (.) id . zipWith ($) (cycle [(:),flip const])
13:31:56 <lambdabot> forall b. [b] -> [b] -> [b]
13:32:01 <benmachine> a function from lists to lists of list functions
13:32:02 <emilmeln> :t ((.) . (.)) . ((.) . (.))
13:32:03 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
13:32:21 <aavogt> > (foldr (.) id . zipWith ($) (cycle [(:),flip const])) [1..10] []
13:32:22 <benmachine> :t appEndo . foldMap Endo
13:32:23 <lambdabot>   [1,3,5,7,9]
13:32:23 <lambdabot> Not in scope: `foldMap'
13:32:26 <benmachine> bzzt
13:32:34 <rj248842> how do I see the source code for data.list?
13:32:48 <Twey> rj248842: Read the Haskell report, which is hosted on… oh wait
13:32:56 <ddarius> "A parser of things is a function of strings to lists of pairs of strings and things."
13:32:59 <illissius`> > let l = [5,23,57,2,68,-1] in map (l !) [1,3..]
13:33:00 <lambdabot>   Couldn't match expected type `GHC.Arr.Array a e'
13:33:00 <lambdabot>         against inferred t...
13:33:05 <illissius`> > let l = [5,23,57,2,68,-1] in map (l !!) [1,3..]
13:33:06 <lambdabot>   [23,2,-1,*Exception: Prelude.(!!): index too large
13:33:09 <aavogt> > (appEndo . mconcat . map Endo . zipWith ($) (cycle [(:),flip const])) [1..10] []
13:33:09 <illissius`> meh
13:33:10 <lambdabot>   [1,3,5,7,9]
13:33:36 <Twey> Haha, ‘appEndo’?
13:33:39 <benmachine> Twey: http://darcs.haskell.org/haskell98-report/
13:33:54 <Twey> Oh, that's up, is it?  Good-o
13:33:58 <aavogt> Twey: where else would you apply?
13:34:00 <Veinor> Appendo, Lando Calrissian's brother.
13:34:23 <ddarius> > zipWith (flip (!!)) [1,3..] [1..]
13:34:24 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
13:34:24 <lambdabot>    arising from a use...
13:34:32 <benmachine> http://darcs.haskell.org/haskell98-report/report/ neat
13:34:33 <Twey> benmachine: http://darcs.haskell.org/haskell98-report/libraries/list.html ☹
13:34:38 <benmachine> oh
13:34:42 <benmachine> yes
13:35:16 <Philonous> ddarius: That will overflow because it still tries to compute a value for each value in the original list
13:35:23 <emilmeln> > [x | x <- [1..], odd x]
13:35:23 <ddarius> > flip sequence [1,3..] . flip (!!) $ [1..]
13:35:24 <lambdabot>   Couldn't match expected type `[a -> [t] -> a1]'
13:35:24 <lambdabot>         against inferred ty...
13:35:24 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:35:44 <Twey> rj248842: Here we are, this one's up: http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/list.html
13:35:57 <aavogt> > mapM (!!) [1,3 ..] [a,b,c,d] :: [Expr]
13:35:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:35:58 <lambdabot>         against inferred type ...
13:36:05 <aavogt> > mapM (flip (!!)) [1,3 ..] [a,b,c,d] :: [Expr]
13:36:06 <lambdabot>   [b,d,*Exception: Prelude.(!!): index too large
13:36:11 <ddarius> Philonous: Using (!!) is crappy code in almost any situation.
13:36:21 <Veinor> @djinn (a -> b -> c) -> a -> [b] -> [c]
13:36:21 <lambdabot> Error: Undefined type []
13:36:22 <tensorpudding> good for quick hacks
13:36:27 <Philonous> ddarius: Nah, it's valid for glofing purposes ;)
13:36:29 <benmachine> Twey: looks like only the index pages are .html in the repo
13:36:31 <Veinor> @hoogle (a -> b -> c) -> a -> [b] -> [c]
13:36:32 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:36:32 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:36:32 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
13:36:34 <Philonous> golfing even
13:36:46 <benmachine> http://darcs.haskell.org/haskell98-report/libraries/list.verb much good may it do you
13:36:47 <aavogt> next. Write it with unfoldr
13:36:54 <benmachine> whoever it was that originally asked for it anyways
13:36:54 <aristid> @src unfoldr
13:36:54 <lambdabot> unfoldr f b  = case f b of
13:36:54 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
13:36:54 <lambdabot>    Nothing        -> []
13:36:59 <aristid> :t unfoldr
13:37:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:37:02 <Twey> I'm surprised they have zipWith7 in the Prime Prelude still
13:37:12 <Twey> I'd think they'd deprecate all that for ZipList
13:37:12 <aavogt> zipWith666
13:37:13 <emilmeln> Haskell Obfuscated Code Contest?
13:37:44 <aavogt> emilmeln: unfoldr is a design pattern...
13:37:50 <aavogt> that means it's good for you :)
13:37:57 <aristid> > unfoldr (const (Just (1, ()))) ()
13:37:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:38:03 <ddarius> emilmeln: There were a handful.
13:38:04 <Veinor> Twey: ZipList helps you and your family to manage your grocery shopping list in one convenient, central place from any web browser or mobile phone.
13:38:06 <Veinor> @_@
13:38:07 <benmachine> I think if there was an hocc then we'd have to have a separate category for NoImplicitPrelude (and possibly OverloadedStrings)
13:38:11 <ddarius> Unsurprisingly, Lennart did well.
13:38:12 <Twey> Veinor: Hehe
13:38:17 <emilmeln> aavogt: It was about [1,3,5...] code above :)
13:39:49 <Twey> Veinor: newtype ZipList a = ZipList { getZipList :: [a] }; instance Applicative ZipList where pure = ZipList . (: []); fs <*> xs = zip fs xs
13:39:54 <Twey> Or something like that
13:40:05 <Veinor> what's the purpose?
13:40:07 <Twey> Veinor: newtype ZipList a = ZipList { getZipList :: [a] }; instance Applicative ZipList where pure = ZipList . (: []); (ZipList fs) <*> (ZipList xs) = ZipList $ zip fs xs
13:40:08 <ddarius> repeat not singleton and zipWith ($) not zip.
13:40:10 <Twey> Rather
13:40:16 <benmachine> pure = ZipList . repeat
13:40:27 <Twey> repeat, is it?  Okay
13:40:38 <Twey> Veinor: It allows arbitrary-arity zips
13:40:39 <aavogt> newtypes are inconvenient
13:40:45 <Twey> aavogt: Agreed
13:40:52 <aavogt> Twey: you're just pushing the problem to liftAn
13:40:55 <benmachine> newtypes are cool
13:41:01 <benmachine> aavogt: nah, you can do
13:41:11 <benmachine> fn <$> arg1 <*> arg2 <*> arg3 <*> arg4
13:41:13 <ddarius> aavogt: Not really.
13:41:17 <benmachine> which is all the liftAn are anyway
13:41:18 <Twey> Veinor: (+) <$> ZipList [1, 2, 3] <*> ZipList [4, 5, 6]
13:41:19 <benmachine> and besides
13:41:27 <benmachine> the liftAn exist regardless
13:41:37 <benmachine> might as well have one fewer series of functions
13:41:52 <Veinor> ooh.
13:41:57 <aavogt> and nobody wants to actually have variable numbers of arguments because you need another function to indicate when the zipping stops
13:42:01 <benmachine> > (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:42:02 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
13:42:02 <lambdabot>    arising ...
13:42:06 <benmachine> ^ this is really annoying
13:42:09 <aavogt> though zipWithN should catch on
13:42:11 <benmachine> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:42:12 <lambdabot>   [5,7,9]
13:42:16 <Veinor> wait, they don't have Show instances?
13:42:20 <benmachine> yes
13:42:21 <Veinor> that's stupid.
13:42:21 <benmachine> it's stupid
13:42:26 <Twey> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
13:42:26 <lambdabot>   [5,7,9]
13:42:28 <benmachine> but getZipList'll sort you out
13:42:29 <aavogt> Veinor: they are infinite sometimes
13:42:30 <Twey> But yeah
13:42:36 <Veinor> aavogt: so are lists
13:42:39 <Twey> aavogt: So… right :þ
13:42:46 <aavogt> perhaps that's not nice that  pure ()  prints forever
13:42:58 <Veinor> show (ZipList xs) = "ZipList " ++ show xs
13:43:13 <benmachine> Veinor: it's a little more complicated than that because you have to parenthise where appropriate
13:43:13 <Veinor> speaking of applicative!
13:43:25 <Veinor> true.
13:43:37 <benmachine> but not much more :)
13:43:39 <aavogt> parenthesize where?
13:43:59 <ddarius> ZipList Just 3 is not correct
13:44:01 <Twey> No, that's it
13:44:08 <Twey> But ZipList only takes a list
13:44:09 <mauke> ddarius: did you mean: Just ZipList [3]
13:44:14 <Twey> ZipList [Just 3] is just fine
13:44:25 <Twey> Oh, right
13:45:03 <aavogt> how does  Just ZipList [3] work?
13:45:11 <aavogt> Just takes more arguments now?
13:45:18 <benmachine> if you show Just (ZipList [3])
13:45:28 <benmachine> you need the show on the ZipList to do the right thing
13:45:33 <benmachine> i.e. parenthise
13:45:52 <ddarius> showsPrec p (ZipList xs) = showParens (p > 0) (("ZipList "++) . shows xs)
13:46:12 <benmachine> isn't it (p > 10)
13:46:15 <benmachine> no
13:46:19 <benmachine> it's deriving (Show)
13:46:20 <benmachine> sorted
13:46:32 <hpc> haha
13:46:34 <ddarius> ZipList { getZipList = [3] }
13:46:46 <benmachine> 's good enough
13:47:08 <benmachine> you can derive Eq and Ord and Read while you're at it too
13:47:32 <mauke> I shall derive Eq, Ord, Read, Show, Functor, Typeable, Data
13:47:50 <benmachine> Foldable and Traversable
13:48:05 <mauke> I'll traverse your folds
13:48:10 <Twey> IsString ;)
13:48:59 <Twey> getZipList $ (+) <$> "z[1,2,3]" <*> "z[4,5,6]"
13:49:01 <Twey> Ohhh yeah.
13:49:28 <benmachine> "1 and 2 and 3 and 7"
13:49:35 <Twey> Nahh
13:49:41 <Twey> "1, 2, 3, and 7"
13:49:49 <benmachine> k
13:49:53 <jmcarthur> "one, two, three, and seven"
13:49:58 <benmachine> jmcarthur wins
13:50:08 <mauke> Twey: you don't need the z
13:50:15 <benmachine> type inference!
13:50:16 <Twey> mauke: Yeah, I was just thinking that
13:50:22 <jmcarthur> or the [ or the ]
13:50:32 <Twey> Or the commas, really
13:50:33 <mauke> instance (Read a) => IsString a where fromString = read
13:50:44 <aavogt> isn't fromString applied at runtime?
13:50:51 <jmcarthur> Twey: you need the commas if functions are made into an instance of Num ;)
13:50:55 <jmcarthur> > 1 2
13:50:56 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:50:56 <lambdabot>    `GHC.Num.Num t' arising f...
13:51:01 <jmcarthur> > 1 2 :: Int
13:51:02 <lambdabot>   1
13:51:07 <Twey> aavogt: Yes, but *which* fromString is decided at compile-time
13:51:20 <Twey> jmcarthur: Hehehehe
13:51:26 <Twey> Why is that 1?
13:51:32 <Twey> I want multiplication!
13:51:39 <mauke> Twey: just look at the types
13:51:47 <Twey> Oh, wait
13:51:55 <jmcarthur> > (2+) * (3+) $ 5 :: Int
13:51:55 <lambdabot>   56
13:51:59 <jmcarthur> :)
13:52:02 <Twey> Yeah, I saw that one before
13:52:04 <mauke> > (sqrt + 3) 2
13:52:04 <lambdabot>   4.414213562373095
13:52:11 <jmcarthur> instance Num b => Num (a -> b)
13:52:19 <aavogt> Twey: the litterals are there at compile time... so is the function you apply to them
13:52:32 <aavogt> therefore you could evaluate it at compile time
13:52:42 <Twey> aavogt: That's true…
13:52:43 <aavogt> or is this already the case?
13:52:50 <Twey> It's probably the case
13:52:55 * aavogt tries with a bogus FromString instance
13:52:59 * Twey guesses
13:53:03 <jmcarthur> a lot of things like this are evaluated at compile time, i think
13:53:12 <benmachine> I'd hazard it's subject to the same inlining and stuff as everything else
13:53:24 <aavogt> @hoogle fromString
13:53:24 <lambdabot> Data.String fromString :: IsString a => String -> a
13:53:35 <benmachine> if fromString = repeat 'a', that won't be fully expanded at compile time
13:54:04 <jmcarthur> :t repeat 'a'
13:54:05 <lambdabot> [Char]
13:54:11 <jmcarthur> good luck defining that one ;)
13:54:21 <benmachine> bzzt
13:54:25 <benmachine> you get what I mean >_>
13:54:41 <aavogt> @hoogle IsString
13:54:41 <lambdabot> Data.String class IsString a
13:55:02 <jmcarthur> getZipList $ (+) <$> "1,2,3" <*> cycle "1,"
13:55:19 <shadwick> my god, Haskell is beautiful
13:55:35 <jmcarthur> it's full of stars!
13:55:37 <aavogt> Twey: it's not the case
13:55:48 <Twey> Huh
13:55:50 <aavogt> but you can use quasiquotes instead
13:55:57 <shadwick> I only started looking at it a couple days ago
13:56:02 <Twey> I wonder why
13:56:47 <applicative> shadwick, it will be the ruin of you.  
13:57:07 <shadwick> applicative: how so?
13:57:14 <jmcarthur> you will hate every other language
13:57:20 <shadwick> fair enough haha
13:57:31 <shadwick> I normally use C and I've been doing some basics with Ada
13:57:32 <benmachine> aavogt: did you compile with -Olog n
13:57:35 <benmachine> or whatever
13:57:37 <aavogt> it might be nice if instead of fromString :: String -> a,  if it was  fromString :: a -> QuasiQuoter, where `a' is a dummy because QuasiQuoter has not type variables
13:57:44 <aavogt> benmachine: no
13:57:50 <applicative> shadwick, just kidding.  i feel the same way, of course.
13:57:50 <jmcarthur> it will also drag you into areas that your peers don't understand and thus are afraid of. they will call you names
13:58:00 <benmachine> well you've got to optimise if you want inlining
13:58:02 <Heffalump> aavogt: IsString isn't specific to quasiquotation
13:58:10 <aavogt> benmachine: same thing with -O2
13:58:14 <benmachine> k
13:58:33 <aavogt> Heffalump: I know that... it would be nice if IsString was done as some implicit quasiquoter
13:58:36 <Twey> Ah, that's why
13:58:38 <shadwick> although, the type system in Ada is one of my favourites
13:58:56 <aavogt> that way you'd have a static guarantee that your strings are sensible
13:59:02 <jmcarthur> shadwick: wait until you see Agda or Coq :) they have cool type systems
13:59:17 <benmachine> I was thinking of learning one of those
13:59:25 <Philonous> Or wait until Haskell comes with dependent types
13:59:26 <benmachine> which would be a better idea?
13:59:34 <jmcarthur> Philonous: will that ever happen, really?
13:59:41 <emilmeln> Dependent types are tough stuff...
13:59:43 <benmachine> given that the sole purpose of my education is to go "cool!"
13:59:44 * earthy would guess not
13:59:49 <jmcarthur> benmachine: i think of them as almost entirely different things now, really
14:00:24 <applicative> did you see the depraved IsString abuses at http://samuelhughes.com/isstring/rpn.html and http://samuelhughes.nfshost.com/isstring/english.html 
14:00:38 <Twey> applicative: Yeah, that's what started this whole thing :þ
14:00:42 <jmcarthur> benmachine: coq is probably a bit easier to get into with it's maturity and larger number of tutorials. agda is designed for more general purpose programming, but is in my opinion a bit tougher to get into
14:00:44 <applicative> haha, i see.  
14:00:45 <shadwick> jmcarthur: I'd never heard of Agda nor Coq
14:00:51 <benmachine> jmcarthur: noted
14:00:52 <Philonous> jmcarthur: I wouldn't hold my breath. I think there will be something else when haskell ability to generate papers is exhausted
14:00:54 <jmcarthur> shadwick: learn more haskell first :)
14:01:06 <shadwick> jmcarthur: Haskell is my first functional programming language :P
14:01:10 <jmcarthur> shadwick: they are the next step in type system power
14:01:19 <benmachine> jmcarthur: which is prettier? :P
14:01:31 <applicative> shadwick, but it's nice to know that there are more serious drugs when you get tired of this one....
14:01:33 <jmcarthur> benmachine: IMO, agda
14:01:36 <Twey> Hehe
14:01:39 <benmachine> done
14:01:41 <Twey> They're not so serious right now, sadly
14:01:45 <Philonous> benmachine: adga has neat mixfix operators!
14:01:54 <jmcarthur> yeah agda's mixfix syntax rocks
14:01:56 <emilmeln> Oh yes!
14:02:01 * Twey is waiting for a Real Programming Language with dependent typing.
14:02:13 <Twey> Someone said that's not going to happen with Haskell ☹  But I'm sure something will come along
14:02:19 <jmcarthur> Twey: agda is trying to be that language, but i don't know whether it will be met with success
14:02:33 * applicative never makes progress with Agda, since he's emacs-enfeebled
14:02:45 <jmcarthur> i am itching to see what is to become of epigram 2
14:03:11 * soupdragon doesn't like mixfix
14:03:16 <soupdragon> also #epigram
14:03:17 <shadwick> well, I should get back to trying to wrap my head around thinking in this functional way..
14:03:19 <Philonous> Twey: There is ATS, though I have no clue whether it is a "real language"
14:03:21 <Twey> jmcarthur: Doesn't Agda still advertise itself as a proof assistant?
14:03:24 * applicative is waiting for epigram2 to learn emacs properly.  might be a long wait.
14:03:29 <jmcarthur> Twey: not that i know of
14:03:40 <soupdragon> mixfix sucks because you have to notate things in the same order as type dependency
14:03:49 <ddarius> Twey: I'm pretty sure the emphasis was switched when Agda went from Agda 1 to Agda 2.
14:03:54 <jmcarthur> Twey: it does, secondary to being a programming language
14:04:01 <jmcarthur> http://wiki.portal.chalmers.se/agda/pmwiki.php
14:04:10 <applicative> shadwick, don't let these wild enthusiasts frighten you away.
14:04:12 <soupdragon> Topic  of #agda:  Agda: is it a dependently-typed programming language? Is it a proof-assistant based on intuitionistic type theory? ¯\(°_0)/¯ Dunno, lol
14:04:24 <jmcarthur> at least, if the order of the text is any indication
14:04:31 <applicative> shadwick, what are you reading to study Haskell?
14:04:34 <mreh> who was it that was having trouble with the c2hs?
14:04:46 <mreh> I've discovered a way you could remove enums
14:04:47 <Twey> Oh, is ATS that fugly language that showed up and took the Shootout by storm?
14:04:49 <mreh> a hacky way
14:04:53 <jmcarthur> Twey: yup :\
14:05:03 <Twey> I didn't realise it had deptypes
14:05:07 <mreh> enums or constants
14:05:12 <jmcarthur> i think of ATS as an extension for C, honestly
14:05:18 <wli> How is ATS taking the shootout by storm?
14:05:26 <Twey> Cool
14:05:36 <jmcarthur> it took the shootout by using a ton of inline C
14:05:46 <jmcarthur> that may have been scaled back a bit now, though
14:05:47 <jmcarthur> dunno
14:05:50 <soupdragon> ATS is closer to Ocaml than C
14:05:50 <shadwick> applicative: I'm skimming over the starting chapters of learnyouahaskell simply because it was the first thing I stumbled across. Is it decent or is there something way better I should be using to grip the basics?
14:05:58 <medfly> it's decent
14:05:59 <Twey> It just sprang up out of nowhere and overtook GHC
14:06:10 <jmcarthur> soupdragon: but all the code i have seen suggests that it is best used in conjunction with a lot of inline C
14:06:16 <mreh> shadwick: it's a great start
14:06:18 <benmachine> shadwick: I loved lyah
14:06:19 <Twey> And everyone gave a collective ‘wow’ followed by ‘urgh’
14:06:24 <soupdragon> jmcarthur, well I think that's how he wins the shootout heh
14:06:28 <medfly> hehe
14:06:34 <medfly> well, is it better than C?
14:06:39 <shadwick> ok great, as so far it's explained things in an easy-to-understand way
14:06:41 <jmcarthur> all the blog posts i've seen about it also treat it as a way to write safer C
14:06:44 <mreh> there's still no gonads in lyah is there?
14:07:39 <applicative> shadwick, LYAH is universally agreed to be very good. 
14:07:55 <jmcarthur> shadwick: learn you a haskell is really good, yes. if you feel like stepping up the pace (or you run out of material in learn you a haskell) you can also give real world haskell a shot
14:08:02 <ddarius> applicative: That's somewhat exaggerated.
14:08:05 <applicative> shadwick, it goes on and on with no monad blather. 
14:08:05 <wli> Is ATS' inline C handwritten or C-front-end-generated?
14:08:14 <Rotaerk> yea I didn't care for LYAH myself because it was too slow
14:08:27 <jmcarthur> wli: handwritten, i'm sure
14:08:33 <shadwick> I like it, but it probably fits me better as Haskell is my first functional language
14:09:04 <applicative> LYAH doesn't go slowly enough. 
14:09:15 <applicative> > length "HAHAHAHAHAHAHA"
14:09:15 <jmcarthur> it depends who's reading it
14:09:15 <lambdabot>   14
14:09:38 <jmcarthur> shadwick: well, hang around. we like beginners here :)
14:09:44 <hpc> when you are learning a language as dense in concepts as Haskell, it takes quite a bit to be slow enough of a tutorial
14:09:53 <Veinor> > cycle "HA"
14:09:54 <lambdabot>   "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA...
14:10:01 <applicative> it's for an audience like shadwick, no?   And it goes in the right order with 'typeclasses"
14:10:20 <ddarius> Gentle Introduction all the way
14:10:29 <Twey> YAHT!  YAHT!
14:10:54 <applicative> I used YAHT.   It is a bit clunky.
14:11:29 <danharaj> Gentle Introduction +1
14:11:51 <shadwick> awesoem, well I shall stick with LYAH then
14:11:52 <shadwick> for now
14:12:08 <wli> YAHT is what got me through monads (don't ask what I was doing from 1998 nutil then).
14:12:11 <chrisdon`> gentle introduction and yaht, here
14:12:24 <hpc> LYAH and the wikibook here
14:12:29 <wli> springschool95.ps was how I got started on Haskell though.
14:12:30 <ddarius> I didn't care for YAHT, but it was still being written when I looked at it.
14:12:31 <applicative> I only read the Gentle Introduction recently.  It was pleasantly lucid, except for certain points -- suddenly it seemed to make no sense. 
14:12:48 <chrisdon`> i didn't think yaht was that great, but i appreciated the exercises
14:13:03 <danharaj> I think Haskell should have a built-in unbounded Naturals type for at least pedagogical purposes.
14:13:03 <wli> ddarius: YAHT wasn't started until after I'd started on Haskell and been farting around for a few years.
14:13:29 <ddarius> wli: Same for me only it was more like a few months.
14:13:44 <mreh> Nats = Suc Nats | Zero
14:13:49 <wli> Gentle Introduction never got me anywhere. I'm not sure when it came out relative to when I started on Haskell.
14:14:14 <applicative> wli, wasn't it in connection with the Haskell 98 specification?
14:14:17 <chrisdon`> if RWH was out when i was learning haskell life wouldn't been easier
14:14:19 <wli> (I was still in college at the time and H98 hadn't quite taken everything over when I first started but was rapidly changing things over at the time).
14:14:20 <mreh> start learning Miranda
14:14:24 <chrisdon`> would've
14:14:24 <mreh> it's easier
14:14:31 <danharaj> mreh: What about numeric literals?
14:14:40 <wli> applicative: Gentle Introduction or what else?
14:14:48 <applicative> Gentle Introduction
14:14:52 <emilmeln> LYAH have a neat analogy for IO as "Box with little feet" =)
14:14:54 <chrisdon`> RHW is to haskell what PCL is to Lisp
14:15:02 <wli> applicative: Could've been. I didn't notice it right away but it could've been there.
14:15:18 <applicative> They say it is an accompaniment to the specification document, whatever it's called. 
14:15:57 <chrisdone> the Haskell Report?
14:16:33 <wli> My progress in Haskell has been glacially slow compared to most people who put more effort into it in a given period of time, but I've been at it so long that my progress has had time to add up to only slightly less than some modicum of something (respectability? maybe even that's too much).
14:17:21 <wli> I mean, 1998? Shouldn't I have gotten a *LOT* farther by now, like rewriting ghc or revolutionizing the world or something?
14:17:39 <benmachine> heh
14:17:42 <chrisdone> wli: true, true. it's funny how you think like that
14:17:50 <aavogt> I've been speaking english since 1993. I should have written shakespeare by now
14:18:04 <benmachine> well fuck, I've been haskelling for about a year now
14:18:06 <aavogt> or something
14:18:09 <chrisdone> aavogt: or at least some decent limmericks
14:18:10 <applicative> Haskell does have its Hamlet. 
14:18:12 <danharaj> Ghc is totally not Shakespeare.
14:18:20 <benmachine> agreed
14:18:20 <applicative> Not sure it compares to the original.
14:18:21 <emilmeln> You can't save an IO value =)
14:18:31 <wli> I guess there's that Fibonacci thing.
14:18:39 <hpc> emilmeln: sure you can; hibernate the computer :P
14:19:03 <wli> Who was it that farted around with my IMAP code? Did they turn it into a library?
14:19:21 <chrisdone> i started haskell new year's eve at 4 in the morning on a compulsion to learn something new. that was two years ago. never looked back!
14:19:24 <emilmeln> hpc: nope, how about network connections, for example?
14:19:35 <hpc> right
14:19:41 <Gracenotes> chrisdone: well that's positively exciting compared to most people
14:20:06 <wli> I just decided that I should learn a buttload of programming languages. Haskell somehow made it into the list.
14:20:08 <chrisdone> never written a monads tutorial
14:20:09 <Gracenotes> read RWH when it came out. hung around in the channel. [...]
14:20:10 <applicative> shadwick, see?  Soon enough you'll be chrisdone
14:20:21 <Veinor> I followed copumpkin back when he did iPhone jailbreak devwork, he mentioned Haskell, and I decided to look into it.
14:20:26 <Gracenotes> 3. ??? 4. Profit
14:20:26 <shadwick> haha nice
14:20:28 <wli> Originally my focus was on Standard ML because it sounded, well, standard.
14:20:35 <shadwick> btw, what does !! do? LYAH used it in an example right now but either I forgot that it mentioned it earlier, or it never did
14:20:38 <chrisdone> wli: hahaha
14:20:45 <Veinor> shadwick: list indexing
14:20:51 <Veinor> > [1,2,3,4,5] !! 0
14:20:52 * chrisdone implements Best Haskell
14:20:52 <lambdabot>   1
14:20:55 <Veinor> > [1,2,3,4,5] !! 1
14:20:55 <applicative> > "abcdefg" !! 3
14:20:55 <lambdabot>   2
14:20:56 <lambdabot>   'd'
14:20:56 <shadwick> ahhhh I get it
14:20:59 <Veinor> > [1,2,3,4,5] !! 999
14:21:00 <lambdabot>   *Exception: Prelude.(!!): index too large
14:21:05 <shadwick> ok thanks
14:21:07 <Gracenotes> you broke it, Veinor!
14:21:09 <Veinor> takes an Int, not an Integer
14:21:22 <wli> chrisdone: I'm not kidding, either. The "standard" in the title made me think it was somehow adopted by some standards organization, used by enough industrial users to have a standards organization, etc.
14:21:27 <aavogt> > [1,2,3,4,5] `genericIndex` (4 :: Int)
14:21:27 <lambdabot>   5
14:21:41 <chrisdone> wli: haha. me too for a while
14:21:49 <applicative> @type genericIndex
14:21:49 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
14:22:11 <Veinor> genericIndex needs a better name
14:22:14 <Veinor> it needs an operator
14:22:21 <danharaj> !!
14:22:33 <applicative> @type length
14:22:33 <lambdabot> forall a. [a] -> Int
14:22:35 <Gracenotes> I'd imagine in most cases converting to Int and then !! would be more efficient than genericIndex
14:22:54 <applicative> Is there a length that returns a bona fide integer?
14:22:56 <Gracenotes> well. if there's an easy, not O(n) conversion (looking at you, Natural)
14:23:00 <ddarius> fromIntegral (fix Succ) :: Int
14:23:08 <Ke> emilmeln: there is actually program called cryopid, but that's not a haskell solution
14:23:11 <ddarius> genericLength
14:23:30 * wli had a tough time getting LambdaProlog and other interesting Prolog variants to work on the systems he had access to at the time, but ordinary Prolog and Mercury I picked up, too, though I think Mercury was probably later on. I guess I was a relatively early user of Mercury; a bunch of my old code predated language changes that made them non-feasible etc.
14:23:34 <Gracenotes> natural succs
14:23:40 <applicative> > "HAHAHAHAH" `genericLength` (10 :: Integer)
14:23:41 <lambdabot>   9
14:23:45 <applicative> indeed
14:24:18 <aristid> :t genericLength
14:24:19 <lambdabot> forall b i. (Num i) => [b] -> i
14:24:25 <wli> Agda, Isabelle, Twelf, Coq, et al I've never learned, but I probably should've at some point.
14:24:29 <aavogt> applicative: haha
14:24:33 <soupdragon> wli, I think Teyjus has gotten more stable recently though
14:25:04 <chrisdone> fax/soupdragon told me about haskell. i was a smug lisp weenie. i remmeber them telling me about currying and me saying "what's the point?" haha
14:25:14 <soupdragon> :)
14:25:17 <wli> soupdragon: It was literally 12 years ago that I went on my language learning spree. I've forgotten how Teyjus extends Prolog (if at all).
14:25:54 <wli> Or was that the name of the LambdaProlog implementation?
14:25:55 <soupdragon> wli, the main difference as I see it is it adds lambda and higher order unification -- still no clue how to use that stuff
14:26:03 <soupdragon> yeah Teyjus is a particular lambda prolog impl.
14:26:05 <soupdragon> in ocaml
14:26:05 <Veinor> Gracenotes: but what if you want a list bigger than maxInt!
14:26:09 <Veinor> (or whatever)
14:26:23 <Gracenotes> then you must scale to the cloud
14:26:33 <ddarius> (define (flip f) (lambda (x) (lambda (y) ((f y) x))))
14:26:36 <Gracenotes> *awesomeness*
14:26:39 <Veinor> of course
14:27:04 <emilmeln> Does it make any sense to write C (or any other low-lever language) compilers on Haskell?
14:27:32 <Gracenotes> sure
14:27:34 <FauxFaux> Yes.
14:27:34 <chrisdone> "on"?
14:27:53 <emilmeln> s/on/in/
14:27:58 <dons> emilmeln: sure. 
14:28:18 <chrisdone> haskell's got a name for being great for writing compilers
14:28:28 <ddarius> emilmeln: What about C would make writing a -compiler- for it in Haskell at all difficult?
14:28:35 <Gracenotes> you can compile to the same assembly as any other C compiler.. and functional programming has features that make manipulation of programming language representations pretty elegant
14:28:49 <dons> well, you can already do it: Language.C composed with Language.LLVM
14:28:53 <dons> C compiler done.
14:29:15 <dons> making the types match is an exercise.
14:29:37 <dons> front end: http://hackage.haskell.org/package/language-c
14:29:37 <Gracenotes> todo: rewrite the entirety of llvm in haskell
14:29:42 <dons> back end: http://hackage.haskell.org/package/llvm
14:29:43 <Ke> main = Canguage.C >>= Language.LLVM
14:29:49 <Veinor> todo: write haskell in haskell
14:29:51 <Veinor> oh wait
14:29:56 <dons> for bonus credit, add the -python flag, http://hackage.haskell.org/package/language-python
14:30:13 <Gracenotes> Veinor: you mean rewrite the haskell RTS in haskell
14:30:18 <ddarius> hcc -python foo.py -o foo.exe
14:30:23 <emilmeln> Hmm, and can we make some kind of source-code optimisation here?
14:30:30 <dons> (seriously, someone should hack up Language.C >>= Language.LLVM this week for lolz)
14:30:52 <ddarius> dons: I might.  It'd be fun.
14:30:58 <emilmeln> ... and, of course, some formal verification.
14:31:03 <dons> the one line C compiler. :-)
14:31:39 * Gracenotes writes a one line nop compiler
14:33:03 <wli> Maybe C-front-end compilers can skip actually generating intermediate C by having the function composition pipeline from Language.C to Language.LLVM?
14:33:45 <Gracenotes> emilmeln: well, if LLVM is used, it's a compiler toolkit, so the language writer's task is to put the language in a form which can be in turn easily optimized by it
14:35:20 <chrisdone> soupdragon: lol i remembered that lisp quine ((lambda (x) `(,x ',x)) '(lambda (x) `(,x ',x)))
14:35:43 <Gracenotes> generating x86/arm/.. opcodes is closer to the compiler writing that gets you familiar with the internals of an architecture, register spilling, etc., what might traditionally be taught in that kind of course
14:36:11 <soupdragon> I like that noe
14:36:13 <soupdragon> one
14:36:46 <ddarius> > ap(++)show"ap(++)show"
14:36:47 <lambdabot>   "ap(++)show\"ap(++)show\""
14:37:25 <hpc> :t ap
14:37:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:37:34 <hpc> ah
14:37:40 <chrisdone> :t flip $ flip ap
14:37:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:38:00 <hpc> :t (flip . flip)
14:38:00 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
14:39:19 <emilmeln> btw, is there any tool for cleaning "simple" Core language from those nasty alphanumeric suffixes?
14:39:33 <pchickey> Does anyone have a mirror of the ghc source releases?
14:39:53 <dons> most distros have mirrors
14:39:56 * hackagebot ad 0.23 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.23 (EdwardKmett)
14:39:56 <dons> e.g. debian
14:40:09 <dons> and there are binaries on hackage.haskell.org/platform
14:40:23 <pchickey> ok. i'm trying to start a cross-compile
14:40:29 <edwardk1> now with shiny higher-order directional derivatives
14:41:04 <chrisdone> apart from cabal issues os x doesn't seem to be a too bad dev. environment for haskell
14:41:35 <dons> doesn't have a very active packaging culture though, it seems.
14:41:38 <T_S_> [(a->b)] -> a -> [b]
14:42:12 <chrisdone> true
14:43:34 <edwardk1> @type \xs a -> map ($a) xs
14:43:35 <lambdabot> forall a b. [a -> b] -> a -> [b]
14:44:23 <chrisdone> @djinn [(a->b)] -> a -> [b]
14:44:24 <lambdabot> Error: Undefined type []
14:45:29 * edwardk1 is racking his brain trying to figure out how to generate a nice 'gradients' function that returns a cofree comonad.
14:46:08 <edwardk1> the types all fit, but i haven't figured out what i need for an underlying AD mode.
14:46:56 <ddarius> sequence xs a
14:47:05 <ddarius> :t \xs a -> sequence xs a
14:47:06 <lambdabot> forall t a. (Monad ((->) t)) => [t -> a] -> t -> [a]
14:47:10 <edwardk1> even better
14:47:25 <edwardk1> though you need Control.Monad.Instances in scope
14:49:05 <edwardk1> @t \xs a -> sequenceA xs a
14:49:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:49:12 <sinelaw> edwardk1 what sort of gradients
14:49:15 <edwardk1> :t \xs a -> sequenceA xs a
14:49:16 <lambdabot> Not in scope: `sequenceA'
14:49:27 <sinelaw> the linear operator?
14:49:52 <sinelaw> edwardk1 and how does your package relate to Conal's?
14:49:53 <aristid> :t ap
14:49:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:49:59 <edwardk1> sinelaw: i have a bunch of combinators for automatic differentiation. i started adding higher order derivatives to the mix. in particular what i have right now are calculations that generate the hessian etc.
14:50:19 <sinelaw> ah, higher order meaning more dimensions
14:50:25 <aristid> :t ap :: [(a -> b)] -> [a] -> [b]
14:50:26 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
14:50:41 <aristid> :t (flip ap) . return
14:50:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (a -> b) -> m b
14:50:52 <aristid> :t flip ((flip ap) . return)
14:50:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
14:50:59 <edwardk1> sinelaw: effectively it subsumes it. i handle forward-, reverse-, and forward-tower -based ad and various mixtures of them to make an efficient ad library that can handle more industrial applications
14:51:03 <aristid> :t flip ((flip ap) . return) :: [(a -> b)] -> a -> [b]
14:51:04 <lambdabot> forall a b. [a -> b] -> a -> [b]
14:51:23 <aristid> T_S_: flip ((flip ap) . return)?
14:51:43 <edwardk1> so you just import Numeric.AD and each operator in their chooses an ad mode or combination of modes that is optimal for the relative arity of its inputs and outputs
14:52:07 <edwardk1> (optimal with regards to the selection of forward or back at each pass, not with regards to optimal jacobian accumulation, which is np-hard)
14:53:06 <edwardk1> sinelaw: so what I have right now is something like: http://hackage.haskell.org/packages/archive/ad/0.22/doc/html/Numeric-AD.html#v%3Ajacobian%27
14:53:14 <edwardk1> (from a version ago which has been haddocked by hackage)
14:53:27 <edwardk1> jacobian' :: (Traversable f, Traversable g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (a, f a)
14:53:36 <sinelaw> edwardk1 nice :)
14:54:21 <edwardk1> I can compute something like: hessianTensor' :: (Traversable f, Traversable g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (a, f (a, f a)) -- which returns all of the information in the result, jacobian, and hessianTensor
14:54:27 <edwardk1> but I could iterate that process
14:55:04 <edwardk1> and get a higher order hessian tensor by noting the recurring (a, f (a, ... )) -- is a cofree comonad
14:55:22 <edwardk1> and so given data f :> a = a :< f (f :> a)
14:55:29 <edwardk1> i should be able to define something like
14:56:05 <edwardk1> gradients :: (Traversable f, Functor g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (f :> a)
14:56:34 <edwardk1> which computes grad, grad^2, grad^3...
14:56:46 <edwardk1> each of which is a higher and higher order tensor
14:57:30 <ddarius> Can I AD the rotor equation yet?
14:58:03 <edwardk1> ddarius: good question. ;)
14:58:29 <sinelaw> edwardk1 my connection failed
14:58:44 <soupdragon> http://upload.wikimedia.org/math/1/b/4/1b47cac3c0bcc7dd089dde3aecc0eba6.png
14:58:46 <ddarius> sinelaw: See logs.
14:58:51 <edwardk> sinelaw heh; you might want to skim the last 20 lines on tunes.org ;)
14:58:53 <soupdragon> I'm guessing that's it
14:59:06 <ddarius> soupdragon: No.
14:59:19 <ddarius> R' = 1/2 Ω R
14:59:38 <edwardk> sinelaw: the end of http://tunes.org/~nef/logs/haskell/10.06.06
14:59:39 <ddarius> soupdragon: That looks like a hideous form of the inertia tensor.
15:00:17 <sinelaw> edwardk yeah got it
15:00:23 <sinelaw> i don't know much about tensors
15:00:24 <edwardk> soupgdragon that looks like it should derive just fine, but i don't think its what ddarius is looking for =)
15:00:33 <edwardk> sinelaw: 'matrix with more than 2 dimensions'
15:00:34 <sinelaw> edwardk which linear algebra / matrix lib do you use / recommend?
15:00:35 <edwardk> now you know tensors
15:00:41 <sinelaw> ah good :)
15:00:56 <edwardk> with potentially more than
15:00:59 <sinelaw> edwardk i want to write a filtering lib, starting with kalman filter
15:01:09 <ddarius> A tensor is a multilinear form, i.e. a multilinear scalar-valued function.
15:01:30 <edwardk> ddarius's way is the more correct way to think about them
15:01:34 <ddarius> Plus (usually) all kinds of requirements on how it transforms with respect to coordinates.
15:01:36 <edwardk> (as usual) =)
15:02:15 <ddarius> edwardk: I don't use that definition, though the definition I do use (when I care, which is rarely) is slightly more general.
15:02:40 <ddarius> I'm not sure I've come across a tensor that could not be better viewed as a vector field, or a linear transformation field.
15:02:59 <edwardk> right now i'm just modeling them in a terribly generalized form by wrapping functors in functors in functors.
15:03:23 <sinelaw> edwardk so which Lin. Alg. lib?
15:03:29 <sinelaw> for matrices
15:03:41 <sinelaw> HMatrix?
15:03:51 <edwardk> sinelaw: i er.. don't like any of them ;)
15:04:07 <sinelaw> i don't like that the dimensions are not in the type
15:04:13 <edwardk> hmatrix has the crufty license which keeps me from even looking at it
15:04:21 <soupdragon> you can't realy put dimensions in the type nicely afaict
15:04:22 <sinelaw> license? i didn't look
15:04:27 <edwardk> GPL
15:04:27 <sinelaw> soupdragon yeah i know
15:04:39 <sinelaw> edwardk ah heh
15:04:48 <edwardk> soupdragon: thats why i've been using Traversable's and Functors to enforce shapes for my ad library
15:05:05 <edwardk> and not commuting things over each other in ways i can't safely zip back up
15:05:14 <sinelaw> edwardk can you give a super-simplified example for that?
15:05:18 <sinelaw> for dummies
15:05:24 <edwardk> its kind of like putting together a ship in a bottle sometimes but it works
15:05:26 <edwardk> well, sure
15:05:28 --- mode: ChanServ set +o mauke
15:05:29 --- mode: mauke set -b *!*@s5.miete-server.de
15:06:16 <edwardk> The jacobian matrix of a function is the matrix of its partial derivatives with respect to its outputs.
15:06:20 <edwardk> jacobian :: (Traversable f, Traversable g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (f a)
15:06:42 <sinelaw> i'm having font problems
15:06:43 <edwardk> since you gave me the shape 'f' i can't change it
15:06:57 <dancor> doesn't the "regular shape-polymorphic parallel arrays in haskell" paper put the shapes in the types?
15:07:15 <ddarius> dancor: Shape but not dimensions.
15:07:21 <dancor> oh
15:07:23 <Cale> edwardk: What is it in particular about the GPL that bothers you?
15:07:24 <sinelaw> there's hmatrix-static
15:07:29 --- mode: mauke set -o mauke
15:07:34 <sinelaw> that puts in the dimensions i think
15:07:34 <ddarius> Er, the terminology is getting overloaded and conflictig here.
15:07:35 <edwardk> but i can wrap it in g there giving you a square matrix from two vectors
15:07:49 <Cale> Personally I find the infectiousness to be awkward because I don't want to have to think about licenses.
15:07:53 <edwardk> Cale: the fact that i every so often like to make money, and occasionally do so by selling software.
15:07:58 <ddarius> dancor: It tracks how many indices the array has, but not their extent.
15:07:58 <emilmeln> "Vector" library is incredibly great.
15:07:58 <Cale> Oh, I see :)
15:08:02 <soupdragon> what's catastrophe theory?
15:08:29 <dancor> edwardk: so you would call GPL and BSD both crufty?
15:08:37 <gwern> soupdragon: the embryo of chaos theory, as far as I can tell
15:08:41 <edwardk> Cale: but in general i find that when someone asininely places the GPL on a library rather than a product that I rarely need their library enough to justify tying my hands with it
15:09:09 <edwardk> dancor: no i love the BSD license with the caveat that I don't like the fact that the GPL often serves as a solid end-run around building a BSD'd community 
15:09:46 <edwardk> one of the major things that drew me into the haskell community was that it is really solidly BSD'd to the core. in that GPL'd libraries get pushed back on a bit, which keeps the GPL'd fork of a lib from killing its BSD'd kin.
15:09:47 <gwern> IMO, BSD licensors are largely freeriding off GPL licensors
15:10:42 <gwern> which is fine, as long as enough GPL licensors exist to make FLOSS toxic in general to people who wish to steal from it
15:11:03 <Cale> gwern: Isn't that backwards?
15:11:28 <Cale> Or, perhaps I misunderstand what you mean by 'freeriding'
15:11:36 <edwardk> gwern: i prefer to write code under BSD on the premise that if someone takes my code private, very often they bring me in to consult on it, and if their in house codebase risks no longer being able to incorporate the changes from the community is when they do merge. both the gpl and bsd licenses fail to subsume the other in terms of audiences
15:11:50 <gwern> not in the least. if you GPL a BSD project, then you're only using the freedom the licensor decided was so important...
15:11:51 <edwardk> that and i've had one too many shouting matches with stallman
15:11:56 <Cale> It's impossible for BSD-licensed software to freeride off of GPL licensed software because it would have to be GPL'ed.
15:12:16 <kynky> i like bsd
15:12:22 <gwern> Cale: the freeriding is more general: corporate leeches/predators have to be careful, and they can be fought off trivially
15:12:33 <Cale> I don't understand
15:12:35 <gwern> and the gpl offers legal precedents
15:12:48 <gwern> Cale: are you familair with poison, camouflage, and protective mimicry?
15:12:52 <Cale> no
15:12:57 <soupdragon> "Christian has developed a software library for geometric algebra computations and visualisation under OpenGL. More details can be found on his website." http://www.perwass.de/cbup/programs.html -- 404 :/
15:13:00 <wli> Isn't it possible to dual license with BSD/GPL?
15:13:07 <dancor> i think apple proves you can still freeride off GPL by dumping undocumented code only with releases :)
15:13:28 <ddarius> soupdragon: It studies the possibility of sudden changes from one behavior to another in relatively well-behaved phase-spaces.
15:13:33 <kynky> if you own the code, licenese as you see fit, look at mysql crazyiness
15:13:33 <gwern> Cale: if haskell.org was up I'd link you my essay on the topic
15:13:46 <sinelaw> :(
15:13:59 <sinelaw> edwardk so what do you recommend for what i want to do
15:14:01 <edwardk> i guess the thing is i write code, i put it down because either i don't care about it any more, or because it is polished and i want other people to use it. in either of the latter two cases i prefer the license that fosters adoption. my intellectual property doesn't need protection from corporate predators
15:14:09 <Philonous> wli what purpose would that serve? You can happily convert BSD to GPL
15:14:23 <edwardk> sinelaw: not sure. like i said, i don't like any of them. last one i really liked was some blas bindings in boost in c++ ;)
15:14:25 <gwern> Cale: but here's one obvious example of freeriding: because the GPL exists and has enforcers, a BSD community can always threaten a freerider that they will switch to (A)GPL
15:14:39 <Cale> If I decide that I want to BSD license my software, but I end up using a library that is under the GPL, I am forced to distribute my software under the GPL. So it's impossible for me to freely use GPLed software to contribute to the BSD-licensed community.
15:14:39 <wli> Philonous: I'm guessing if someone wanted to release a derived work with a more restrictive license like the GPL they could.
15:14:39 <gwern> Cale: if the GPL didn't exist, such a threat would not be credible
15:14:44 <sinelaw> heh
15:14:47 <dancor> edwardk: i heard blas was good
15:14:52 <kynky> gwern, like with what the wine project did
15:15:01 <gwern> kynky: oh, someone actually did this?
15:15:23 <dancor> edwardk: what is the meaning of "shape" in your-library, and what is the meaning in the parallel arrays paper?
15:15:26 <Ke> gwern: that's not relevant, apple mostly forked those gpl-projects anyways so they weren't dependent on upstream contributions
15:15:29 <Cale> gwern: Sorry, I'm still completely lost.
15:15:37 <gwern> Ke: not everyone is apple
15:16:01 <edwardk> gwern: its been done, it has also destroyed a few communities
15:16:07 <Cale> gwern: Suppose I licensed my software under BSD. What do you mean by a freerider?
15:16:08 <gwern> Ke: the fact that nukes aren't enough to credibly threaten the Empire's Star Destroyers doesn't mean that nukes aren't useful for deterrence
15:16:17 <gwern> edwardk: examples pls
15:16:24 <Cale> gwern: Someone who uses my software freely as I entitled them to do?
15:16:28 <edwardk> gwern: one sec
15:16:42 <kynky> wine was bsd, it got forked , then maintainers didnt like peope making money off their efforts so changed license to gpl.
15:16:51 <edwardk> http://www.antigrain.com/license/index.html
15:17:07 <edwardk> AGG was BSD under 2.4 with a ton of commercial users and a thriving community
15:17:07 <halberd> hey how about the software development idea of "locking" code after a while so that it can't be altered except for bugfixes
15:17:18 <edwardk> 2.5 went GPL and the community died overnight
15:17:18 <halberd> so that in order to add to the product you have to write new code, not change existing code
15:17:19 <gwern> halberd: what about it?
15:17:36 <Cale> gwern: Keep in mind that I would put my software under the public domain if I could, except that I like the disclaimer of warranty I get by keeping it technically under copyright.
15:17:37 <halberd> I'm putting it out there gwern 
15:17:40 <ezyang> halberd: Locked hardware, which is what GPLv3 tries to combat. 
15:17:50 <halberd> no no
15:17:58 <edwardk> while they could use the old code nobody really had the gumption to go through and update it with more modern features.
15:18:01 <gwern> halberd: sounds dumb; what if the software is distributed with macros or patches to modify the old code?
15:18:13 <Cale> gwern: Could you explain to me what you mean without making use of weird analogies?
15:18:20 <halberd> they shouldn't modify the old code
15:18:22 <halberd> that's the point
15:18:28 <gwern> Cale: I'm afraid I only think in weird analogies
15:18:29 <Cale> I don't understand what a freerider is to you, I think.
15:18:42 <halberd> that you designate certain old pieces of code as "finished" and never change them except to fix any bugs
15:18:47 <Cale> Do you mean any user of the BSD licensed software?
15:18:49 <halberd> and then just treat them as black boxes
15:19:00 <Cale> (obviously it's free, so any user would be a freerider?)
15:19:22 <kynky> now some licenses may be updated/created  to combat the perceptual free loading of commercial products based on SAAS,
15:19:24 <halberd> this prevents modules from growing out of control
15:19:27 <Philonous> Cale: I would assume someone who converts BSDed code into a proprietary license
15:19:27 <ezyang> Cale: afaict, the making money is the objectionable part 
15:19:35 <halberd> and it prevents products from taking on features they weren't designed to do
15:19:36 <Axman6> Cale: sounds like dem nasty people who take advantage of the BSD licence, when they're perfectly entitled to! bastards!
15:19:51 <edwardk> gwern: i don't see how the BSD license "free rides" on the GPL if anything the GPL community can get a free ride by the fact that they can use the BSD'd code as a starting point for anything and need not communicate anything back. Now, that was somethat that they were explicitly entitled to by the BSD license, but it as a consequence means that BSD'd has to work twice as hard
15:19:52 <gwern> Cale: try http://community.haskell.org/~gwern/static/Evolutionary%20Licenses.html
15:19:56 <Axman6> Philonous: there's no need to convert it
15:19:57 <edwardk> to retain its open source community
15:20:11 <halberd> you see what I'm saying
15:20:19 <kynky> macosx is the famous example of using bsd code for commercial gain
15:20:21 <halberd> changing old code is a dangerous practice
15:20:26 <halberd> likely to introduce bugs
15:20:32 <Philonous> Axman6: True, what I meant is "distribute it without the sources" 
15:20:33 <gwern> halberd: what meaningful principle could possibly defeat all possible ways of modifying at compiletime or runtime 'old code'?
15:20:36 <Axman6> kynky: and giving plenty back ;)
15:20:37 <edwardk> because they don't only have to worry about corporate exclusion, but also about some smarmy GPL advocate forking their project and refusing to commit back
15:20:44 <eevar> #haskell-blah ? ;)
15:20:49 <halberd> gwern it's voluntary
15:20:50 <edwardk> eevar: yeah
15:20:51 <Cale> Philonous: But I permitted them to do that!
15:20:53 <Axman6> yeah, what edwardk said
15:20:56 <halberd> a software engineering voluntary practice
15:21:01 <halberd> to choose not to modify old code
15:21:13 <gwern> halberd: ok, that also sounds like a bad idea. immortalizing mistakes...
15:21:19 <Axman6> oi, --> #haskell-blah 
15:21:22 <halberd> if there are mistakes then they can be bugfixed
15:21:27 <Cale> If someone takes my BSD licensed software and slaps a commercial license on it and sells it, more power to them.
15:21:32 <halberd> but if the mistakes are more serious then the whole software should be rewritten
15:21:32 <ezyang> bugfixes are dangerous 
15:21:35 <edwardk> halberd: that way lies 'lava flow' http://en.wikipedia.org/wiki/Lava_flow_(programming)
15:21:37 <bos> #haskell-blah people, please
15:21:40 <halberd> don't try to layer patches upon patches
15:22:18 <Philonous> Cale: Yes , of course, you did. but I just tried to make sense of the word. 
15:22:23 <edwardk> so back to the gradients problem =-)
15:22:56 <Axman6> halberd: take it to #haskell-blah 
15:23:05 <dancor> i don't see how you encode array size without dependent types
15:23:09 <edwardk> so I should be able to build something like gradients :: Traversable f => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> Cofree f a
15:23:23 <edwardk> dancor: i don't encode it, but traversable doesn't give me any machinery to CHANGE the size ;)
15:23:26 <Axman6> dancor: can that be done in general?
15:23:29 <halberd> it's the idea of functional programming where you define primitives which you don't change, instead you build more on top of the primitives
15:23:40 <Cale> gwern: I don't understand why I should care if someone takes the software that I put under BSD and makes money from it.
15:23:45 <edwardk> dancor: so given polymorphism there i know that the 'f's i get out will all have the same shape as the 'f's i put in
15:23:57 <Cale> gwern: In fact, I'm happy if they can.
15:24:00 <dancor> shape-and-size
15:24:01 <gwern> Cale: it's a community level thin
15:24:03 <Axman6> Cale: i'd be somewhat pleased if it happened with my code
15:24:08 <Cale> Yes.
15:24:15 <Axman6> Cale: #haskell-blah though
15:24:29 <Cale> fine, I'll join another channel :P
15:24:32 <gwern> (even if you don't personally feel any theft, the effects on communities is enough to justify copyleft)
15:24:33 <ddarius> dancor: You just use type classes to bind a type and value and then you can reify and reflect between them, but it is pretty ugly.
15:24:35 <Axman6> good! :P
15:26:02 <dancor> edwardk: so you don't have any operations which change tensor shape-or-size?
15:26:18 <dancor> in AD
15:26:18 <dons> the effect on community of BSD code is greater access to paid work in Haskell, and more contributions back from commercial users in the forms of libraries, hosting, sponsorships and others. I think BSD* has been critical to the adoption we've had.
15:26:46 <edwardk> dancor: i add dimensions, but they all come in some way from my inputs
15:26:47 <davean> A lot of companies using BSD software find it efficient to contribute changes back
15:27:06 <dons> definitely. commercial users have written a large proportion of the most popular librarries on hackage, for example.
15:27:14 <ivanm> bos: did my last attempt at a patch for criterion work?
15:28:01 <Axman6> dons: care to continue this in -blah?
15:28:34 <kynky> with ghc 6.12 there is shared lib support in linux which means lgpl can be easier used, whereas before bsd was the only way togo, because of the way haskell compilled its objects i thought
15:29:15 <gwern> 'The Wine project originally released Wine under the same MIT License as the X Window System, but owing to concern about proprietary versions of Wine not contributing their changes back to the core project,[8]  work as of March 2002 has used the LGPL for its licensing.[9]'
15:29:19 <gwern> kynky: so you're right
15:29:54 <kynky> gwern, :)
15:30:01 <dons> ivanm: no, too busy to dive into a license war. fwiw, hackage is ~75% BSD, <10% LGPL, 3% or so GPL, last I checked
15:30:03 <davean> gwern: is there any evidence that has helped it?
15:30:15 <gwern> davean: is there any evidence that it's hurt it?
15:30:22 <ivanm> dons: huh? I didn't say anything!
15:30:23 <sinelaw> MY LICENSE WILL EAT YOUR LICENSE.....in #haskell-blah
15:30:24 <gwern> the wine devs obviously felt it had to be done
15:30:24 <dons> maybe haskell's different, and commercial users are especially involved in the community
15:30:31 <dons> s/ivanm/Axman6/
15:30:33 <davean> gwern: a lack of evidence isn't an arguement really
15:30:35 <dons> you guys look the same.
15:30:35 <Axman6> :)
15:30:39 <Axman6> heh
15:30:47 <Axman6> we live pretty close together too
15:30:47 <ivanm> dons: but yes, I was about to state that to you when you joined -blah :p
15:30:57 <edwardk> the amusing part is the discussion of GADTs had to move to -blah instead ;)
15:31:02 <davean> gwern: and people's feels are notoriously wrong
15:31:08 <ivanm> Axman6: at least we don't have the blackdog vs blackh problem... >_>
15:31:11 <zeiris> Style/convention question: liberally using "type UserName = String" synonyms seems to produce very readable code purely by type signature. (Example: the fastirc package on Hackage.) I remember someone once telling me it wasn't idiomatic - is it?
15:31:19 <Axman6> ivanm: heh, yeah
15:31:22 <ivanm> zeiris: sure it's idiomatic
15:31:25 <gwern> dons: I think it's that haskell commercial users are too small. apple can maintain a whole OS, and thumb its nose at the BSD community; if the GHC devs en masse switched to GPL, say, what commercial haskell user would be able to take over maintenance?
15:31:32 <zeiris> Phew. Great :)
15:31:34 <ivanm> the only thing more idiomatic is to enforce that difference with newtypes
15:31:39 <ezyang> zeiris: Yes, but you should note that you get no typechecking safety 
15:31:42 <bos> ivan: yes, thanks
15:31:53 <ivanm> hooray!
15:32:00 <davean> gwern: how many people would continue to use ghc?
15:32:08 <ivanm> davean: I would
15:32:09 <Axman6> gwern: how does Apple thumb its nose at the BSD community?
15:32:26 <gwern> davean: most; it would only directly affect GHC API users, I think, unless the RTS and other things screw us up
15:32:41 <kynky> http://industry.haskell.org/ seems very beneficial
15:32:41 <ivanm> Axman6: well, IMO they butchered the whole KHTML thing and created the fork purely for publicity reasons
15:33:04 <ivanm> gwern: might need an official statement ala GCC that you can use the compiler for non-GPL stuff
15:33:05 <gwern> Axman6: you think they contribute back very much of their work? I saw an apple presentation at a college, and had to laugh at how little they could come up with for 'FLOSS contributions' slide
15:33:38 <gwern> ivanm: right, but the point is only a tiny fraction of haskell users would have to change license and so would care. so maybe a better example would be the haskell platform?
15:33:51 <ivanm> gwern: yup
15:34:04 <Axman6> ivanm: which has been fantastically successful at bring a fairly stagnant project into a world's best project, making it good enough that they're replacing KHTML with WebKit?
15:34:10 <kynky> i hope hackage stays predominately bsd
15:34:12 <ivanm> note, however, that IIRC the platform is specifically BSD licensed (so all packages have to use BSD-style licensing)
15:34:25 <ivanm> Axman6: last I checked they're still not replacing it
15:34:38 <ivanm> Axman6: but there was no need for a fork if they bothered to create proper patches
15:34:50 <Axman6> that woud have been far more work for them
15:35:05 <Axman6> they needed to get it into shape, not sit around waiting for patches to be accepted
15:35:21 <ivanm> Axman6: it would have been more work to create smaller, more easier to understand patches rather than one (or several) big patch(es) and tell upstream to apply them ASAP?
15:35:29 <ivanm> sure
15:35:37 <pastorn> wli: hello :D
15:35:38 <ivanm> but then that would have been a more responsible thing to do
15:36:20 <gwern> I suppose khtml/webkit is this decades emacs/xemacs argument over proper contributing and fault finding :)
15:36:28 <alt> sorry for newb question. Can haskell be staticaly compiled and is RT lib needed for haskell program execution? (Windows)
15:36:34 <ivanm> IMHO you shouldn't fork just because you can; you should fork only if there's some legitamate reason you can't work with upstream (e.g. when gcc was forked, and then later the fork became the official one)
15:36:49 <jmcarthur> alt: yes and you can compile statically
15:36:57 <jmcarthur> err, that is statically linked
15:36:57 <ivanm> gwern: nope; the problem is due to big huge blobs of patches rather than smaller, more easily digestible ones
15:36:57 <Axman6> ivanm: unlike the people who were developing KHTML, Apple had deadlines to meet. they couldn't wait for the KHTML maintainers to apply patches. if they were going to put in as much word as they have, basically completely reworking the project, why not make a fork? it's the way major changes get done
15:37:11 <jmcarthur> so you don't need a dynamic lib
15:37:14 <gwern> ivanm: sounds like an argument over 'proper contributing'...
15:37:18 <sinelaw> alt yes it can, and until recently it was the only way (i think)
15:37:23 <alt> jmcarthur, thanks
15:37:26 <ivanm> alt: all Haskell dependencies are by default statically linked to, but for C dependencies there is always going to be at least one dynamic link to glib IIRC
15:38:26 <ivanm> http://www.kdedevelopers.org/node/1001
15:38:42 <ivanm> not sure how much of that still applies (OSX APIs, etc.), but still
15:39:41 * ivanm should go and head off to uni... :s
15:40:04 <selektah> hi
15:40:08 <Axman6> i doubt it is true anymore, since webkit is used everywhere these days, on all platforms
15:41:11 <Axman6> i mean, there's bindings to GTK and Qt, at lease one of which is even available from Haskell
15:41:15 <selektah> how to read list form file e.g. file: [("1","a"), ("2", "b")] . I have to write dedicated parser or there is such function?
15:41:59 <dons> > read [("1","a"), ("2", "b")] :: [(String,String)]
15:42:00 <selektah> i heard about readList, but couldn't find any docs
15:42:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:42:00 <lambdabot>         against inferred type...
15:42:18 <dons> > (read (show [("1","a"), ("2", "b")])) :: [(String,String)]
15:42:19 <lambdabot>   [("1","a"),("2","b")]
15:42:26 <tomh-> mm whats the technical difference between anonymous functions and closures?
15:42:31 <Axman6> > read "[("1","a"), ("2", "b")]" :: [(String,String)]
15:42:32 <lambdabot>   No instance for (GHC.Read.Read
15:42:32 <lambdabot>                     (t
15:42:32 <lambdabot>                      ...
15:42:35 <selektah> dons: thx
15:42:37 <dancor> tomh-: closures pull in external vars
15:42:50 <dancor> actually closures don't have to be anonymous
15:43:05 <kynky> haskell bindings to both gtk and qt , just gtk bindings are more mature and at least they are modular now
15:43:05 <dons> closures are a way to implement anonymous functions
15:43:09 <tomh-> and the part you call closure is basically the function which uses an external var?
15:43:42 <dons> a closure is a function body, some arguments, and a captured environment, all as a value on the heap.
15:43:46 <dancor> dons: oh is g not a closure here?   f x y = g y where g z = x z
15:43:57 <dons> in haskell everything is a closure 
15:44:00 <dancor> since it's pulling in the x from an outer scope
15:44:12 <dons> so there's no distinction in haskell. 
15:44:29 <dancor> is (f x = 4) a closure?
15:44:33 <dons> everything (basically) is a function body, some argument slots, and a captured environment.
15:44:35 <tomh-> dons: that was the best definition ive ever seen of a closure, they should edit wikipedia :D
15:44:44 <chrisdone> it's cheating talking about closures in haskell
15:45:19 <dancor> i don't think (f x = 4) is a closure.
15:45:27 <dons> sure. just one with a null environment.
15:45:39 <danharaj> oh god
15:45:43 <dancor> then you don't even need to say "in haskell"
15:45:43 <dons> > map f [1..10] where f x = 4
15:45:43 <lambdabot>   <no location info>: parse error on input `where'
15:45:45 <danharaj> five-star programming
15:45:50 <dancor> in fact, everything in the world is in haskell
15:45:56 <dons> dancor: most languages don't represent f x = 4 as a closure.
15:45:58 <dancor> it may just be that container is null
15:46:00 <tomh-> the captured environment refers to free variables its using?
15:46:14 <hpc> > map (const 4) [1..10]
15:46:15 <lambdabot>   [4,4,4,4,4,4,4,4,4,4]
15:46:33 <dons> tomh-: yeah
15:46:40 <dancor> dons: is what you are saying something in the haskell report, or the ghc implementation?
15:46:45 <dancor> or neither
15:47:48 <Saizan> the haskell report doesn't talk about heap at all :)
15:48:32 <dancor> so, unless you are discussing compiler implementations, i prefer to say that a closure must have a non-null environment.
15:48:50 <dons> dancor: ghc. in ghc everything is represented as a closure. functions, data, lambdas, ...
15:48:53 <illissius`> why is unsafeForeignPtrToPtr unsafe? is there any chance of it ending up finalizing the pointer if I still have the ForeignPtr itself around?
15:48:56 <soupdragon> dancor why?
15:49:04 <Saizan> dancor: unless we are debating compiler implementations we should talk about closures.
15:49:09 <dancor> soupdragon: because then it because distinct from "function"
15:49:13 <Saizan> dancor: err, shouldn't
15:49:20 <dancor> and then it becomes an interesting independent concept
15:49:26 <dancor> instead of just an academic synonym
15:49:40 <dons> yes, talk about funcitons, vs functions with a bound environment capturing their free variables
15:49:43 <soupdragon> oh okay, it doesn't make sense to arbitrarily separate them like that. to me
15:51:16 <Rafau> hi, why haskell.org isn't working?
15:52:31 <tomh-> I think the webservers are down
15:52:38 <tomh-> and no staff to fix it untill monday
15:54:13 <dancor> i think it's a practical distinction.  consider:
15:54:32 <dancor> "you can move a function from a where clause to top-level iff it is not a closure"
16:03:26 <applicative> dancor, in Haskell, is moving something from the top level to a where clause -- perhaps thus eliminating a slot -- likely to be more efficient?
16:03:40 <dancor> applicative: i have no idea
16:03:49 <dancor> "In computer science, a closure is a first-class function with free variables that are bound in the lexical environment."
16:04:01 <dancor> i've really never heard a compiler-implentation-specific version before
16:04:06 <bos> dcoutts: ping
16:04:12 <dancor> i guess closure has two meanings then
16:04:15 <ivanm> applicative: I would think only if it could do more agressive inlining/optimisation because that definition isn't used elsewhere
16:04:19 <ddarius> dancor: That's just a misdefinition.
16:04:46 <applicative> ivanm, that was the sort of thing I was wondering about.  
16:04:55 <ddarius> dancor: A closure is a pair of a "function pointer" and a lexical environment where by "function pointer" I mean a first class function that has no environment.
16:05:06 <jeffwheeler> @pl \s -> (show $ length s) ++ (head s : [])
16:05:07 <lambdabot> ap ((++) . show . length) (return . head)
16:05:28 <applicative> but there is the other point that often you can close off variables.  That's the part i don't like -- what dancor is calling a closure.  
16:05:41 <ddarius> dancor: First class functions could be implemented by compilation to combinators, or lambda lifting, or defunctionalization instead, none of those producing a closure.
16:05:58 <jeffwheeler> @type ap
16:05:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:06:35 <dancor> so traditionally "closure" refers to an implementation for lambdas
16:06:36 <applicative> I wondered if anything is gained by it using "where" with fewer variables than would be necessary at the 'top level', other than speed in writing. 
16:06:38 <ddarius> "You can move a function from a where clause to the top-level if it has no (none global) free variables."
16:06:55 <dancor> anyway you can see how it would evolve into the trifling web2.0 version i've been exposed to
16:07:09 <ddarius> You can also turn free variables into parameters as you lift and you get lambda lifting.
16:07:20 <applicative> the loss of intelligibility to the module is immense, since typechecking means moving it to the so called top level
16:07:37 <ddarius> HaRe should support that refactoring too.
16:08:18 <monochrom> If decades ago there was only one defacto implementation, people use the implementation name. Example: today people still say "pass me the kleenex" and "xerox this paper", even though clearly it is Royale and it is Canon.
16:08:42 <dancor> so now Closure^TM just means anon-func
16:08:50 <dancor> even Lambda^TM is a brand imho
16:09:05 <applicative> the great advantage often claimed for Haskell, that the types are your guide, that they are 'documentation' goes out the window with every dancor-closure in a 'where'
16:09:37 <ivanm> monochrom: I keep hearing that people associate Kleenex with tissues, but I've never actually heard anyone say "pass me a kleenex"
16:09:48 <dancor> well fine a func-with-external-vars-pulled-into-it is dancorosure^tm
16:09:58 <ddarius> applicative: You don't put a type on every subexpression do you?  Also, you can give types to locally defined functions.
16:10:28 <applicative> ddarius, in fact I often put types on locally defined functions.  
16:10:40 <ddarius> ivanm: It happens.  Perhaps even more common is Band-Aid.
16:10:56 <ivanm> ddarius: true
16:11:09 <ivanm> ddarius: because there is no one canonical "name" for that type of product that I've seen
16:11:15 <ddarius> adhesive bandage
16:11:18 <dancor> applicative: i've put in some where-func types.  usually if i have to do it to debug i'll leave it in
16:11:27 <dancor> figuring that, in that case, it needed it
16:11:32 <ivanm> I've heard variations on "sticking plaster" as well, even though that's different
16:11:41 <applicative> ddarius, the problem isn't that the types aren't stated, its that  figuring out what the writer was thinking is a nightmare. 
16:11:43 <dancor> but you can't infer their types with ghci which is lame
16:11:58 <dancor> i think there should probably be a tool to infer their types..
16:12:18 <ddarius> @google chameleon type debugger
16:12:19 <applicative> i should write a de-where-ifying de-let-ifying program.  
16:12:19 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.73.6170&rep=rep1&type=pdf
16:12:19 <lambdabot> Title: The Chameleon Type Debugger (Tool Demonstration)
16:12:44 <chrisdone> applicative: why
16:12:50 <ddarius> applicative: There are (toy) programs that do that and HaRe will do that (though not en masse)
16:13:05 <benmachine> @pl let x = 4 in x
16:13:05 <lambdabot> 4
16:13:20 <dancor> chrisdone: well then we could infer the type!
16:13:21 <benmachine> @pl let x = 0 : x in x
16:13:21 <lambdabot> fix (0 :)
16:14:15 <dancor> oh i guess chameleon type debugger can do that
16:14:20 * hackagebot rosezipper 0.2 - Generic zipper implementation for Data.Tree  http://hackage.haskell.org/package/rosezipper-0.2 (IavorDiatchki)
16:15:04 <applicative> ddarius, maybe I should study HaRe.  chrisdone, like I said, if you are trying to understand a library with complexly interlocking 'wheres' you have no type clues.
16:15:43 <chrisdone> oh i see
16:16:26 <chrisdone> i was thinking of the same problem yesterday
16:16:28 <applicative> so you can't really understand what's going on, in a way you can by piecing together the types in a bunch of top level definitions
16:16:47 <chrisdone> how to get the type of a value anywhere in a top-level func/pattern decl
16:17:32 <benmachine> applicative: sometimes I put typesigs in wheres
16:18:15 <applicative> benmachine, i just started doing it a few weeks ago. it makes things longer of course, but it has uses besides keeping the workings clear to you 
16:18:33 <applicative> like making things determinate (:: Int -> String) and so on
16:18:56 <benmachine> I think just Being Sensible About Things will get you far
16:19:02 <applicative> same as supplying a signature at the top level does. 
16:19:03 <benmachine> don't blame where for people writing shitty code :P
16:19:28 <chrisdone> one way i like is: foo = bar mu. you want to get the type of mu, make the following transformation: foo mu = bar mu, then just to :t foo
16:19:37 <applicative> benmachine, i agree.  this isn't a serious complaint, anyway.  
16:20:06 <applicative> chrisdone, yes, what to do is clear.  if there are six things in the "where" it can become a nightmare
16:20:31 <chrisdone> applicative: well what i mean is you could do this in emacs
16:20:53 <chrisdone> just extend C-t to make it do the transformation, get the type, and display it in the minibar
16:21:00 <chrisdone> er, C-c C-t
16:21:09 <applicative> hmmmm.  
16:21:50 <chrisdone> i've only never done it before because i just considered it yesterday. i can't remember what we were talking about
16:21:57 <chrisdone> oh yeah, completion
16:22:32 <applicative> When I started adding a type signature to the  subordinate wheres and the wheres subordinate to them, "module Foo where" became clearer to me...hah. 
16:22:35 <dancor> what is IOExts called now
16:22:56 <chrisdone> foo = bar <cursor here>, hit TAB, transform to foo x bar x, get the type, get the list of all symbols of that type, do completion
16:23:22 <chrisdone> applicative: what, how many levels of wheres does this code have?
16:23:23 <chrisdone> O_O
16:23:37 <chrisdone> if it doesn't fit in 80 columns it's usually a sign
16:23:55 <applicative> with type signatures it doesnt matter ... except you soon run out of columns. 
16:24:13 <chrisdone> applicative: do you use emacs?
16:25:11 <applicative> chrisdone, I periodically have another go.  I started using it for regular writing a bit now that it has a pandoc mode... ha
16:25:30 <chrisdone> i see
16:25:55 <dancor> ddarius: is there a newer version of the chameleon code anywhere?
16:26:05 <dancor> before i put too much into getting this to compile..
16:26:14 <applicative> chrisdone,but clearly a true haskeller must get to the bottom of it...
16:26:36 <applicative> ddarius, i was going to ask the same about chameleon
16:26:45 * chrisdone waits for the vimers to chime in
16:27:22 <dancor> also is Set.mkSet now Set.singleton or Set.fromList
16:27:41 <chrisdone> not if you want a *real* editor scoffle *pushes glasses up nose with one finger*
16:28:03 * applicative thinks the semi-intelligibility of emacs lisp is decisive against vim,
16:28:13 <dancor> i should try yi again
16:28:38 <dancor> i couldn't get-to-work/add HTML highlighting last time i tried
16:29:49 * applicative has to keep reading emacs tutorials every time he tries yi, which is ideally his one true editor
16:29:55 <Peaker> It's hard to give up some of the emacs features I got used to and switch to Yi..
16:30:02 <dancor> the answer for earlier was Set.fromList
16:32:47 <dancor> ddarius: wait, is chameleon a haskell-like lang or a debugger for haskell?
16:33:25 * hackagebot sendfile 0.6.2 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.6.2 (JeremyShaw)
16:34:19 <dancor> i'm going to go ahead and say that's it's not haskell and oldoldol
16:34:21 <dancor> d
16:35:45 <dancor> applicative: i guess after you have your where-to-top-level converter i can use that to get type-inferrence-in-the-original
16:37:52 <ddarius> dancor: Chameleon is a Haskell-like language but the type debugger will work with Chameleon and Haskell 98 code.
16:38:03 <ddarius> But, it is rather old.
16:40:40 <dons> not haskell research language for exploring gadts and such like.
16:40:54 <dons> nice type checker
16:42:38 * soupdragon hasn't been able to compile Chameleon in the past
16:49:48 <ddarius> What kind of spellchecker doesn't accept "movie"?
16:50:18 <benmachine> a russian one
16:50:41 <benmachine> by which I mean one for checking russian spell checking
16:50:53 <benmachine> not to imply that russians are somehow bad at checking english spelling
16:51:08 <monochrom> chinese spellchecker :)
16:51:12 <interferon> what's a good book to learn lambda-calculus, typed lambda-calculus, y combinators, the curry-howard isomorphism, etc?  
16:51:33 <gwern> interferon: Pierce, I suppose
16:51:39 <tensorpudding> that one book by the Miranda guy
16:51:42 <gwern> but then, TaPL does assume a lot of background
16:51:57 <interferon> gwern: types and programming languages?
16:52:00 <monochrom> cabal install TaPL
16:52:06 <ddarius> interferon: TaPL isn't a bad suggestion.  Lectures on the Curry-Howard Isomorphism also covers most of those.
16:52:46 <gwern> interferon: ayuh
16:53:00 <tensorpudding> ah, type theory and functional programming, that was the name
16:53:07 <interferon> gwern: i have a CS degree, we just focused more on FSM's and turing machines than lambda-calculus
16:53:15 <gwern> interferon: most do
16:53:16 <interferon> gwern: do i need more background than that?
16:53:23 <tensorpudding> the downside is that it is old
16:53:33 <ddarius> I would really just learn Scheme for the untyped lambda calculus/Y combinator.
16:53:39 <gwern> interferon: I think you probably should. maybe work through RWH or SICP first?
16:53:47 <tensorpudding> the upshot is that it is available for free on the author's webpage
16:53:49 <interferon> gwern: done both of those
16:53:53 <gwern> pierce isn't very strong on motivating examples
16:53:55 <ddarius> In that vein, besides SICP and HtDP, there's Shriram's book PLAI.
16:54:17 <interferon> ddarius: true, i've been seeing that mentioned
16:54:28 <ddarius> http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
16:54:30 <tensorpudding> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
16:55:28 <ddarius> I highly recommend reading SICP if you haven't read it and I also highly recommend PLAI.
16:55:52 <ddarius> I wouldn't bother with HtDP unless you really think you'd need babying to learn Scheme.
16:55:55 <gwern> he already did SICP he said
16:55:58 <gwern> and RWH
16:56:42 <soupdragon> yeah I am not really keen on HtDP
16:56:43 <soupdragon> myself
16:57:18 <interferon> soupdragon: i didn't really get into that one either
16:57:30 <interferon> so sounds like TaPL and PLAI should be next on my list
16:57:34 <ddarius> I recommend it for people very new to programming, but it isn't really worth the time for someone with a decent amount of experience already.
17:00:33 <Peaker> I haven't read SICP, but I skimmed some and it seems interesting. I've seen most of the terms in the titles elsewhere
17:00:36 * benmachine drowns in initialisms
17:00:39 <Peaker> (call-by-*)
17:01:10 <ddarius> @vera SICP
17:01:11 <lambdabot> No match for "SICP".
17:01:15 <ddarius> @foldoc SICP
17:01:15 <lambdabot> No match for "SICP".
17:01:20 <gwern> @google SICP
17:01:21 <ddarius> That's odd.
17:01:21 <lambdabot> http://mitpress.mit.edu/sicp/
17:01:21 <l06:08 <JoeyA> I'm trying to write a function that performs a given action on an STUArray, but I'm running into issues involving the general-ness of ST s:  http://codepad.org/ayLzXOtm
20:06:34 <JoeyA> (it doesn't work in GHC error, saying "Couldn't match expected type `s' against inferred type `s1'"
20:06:40 <JoeyA> s/error/either/
20:08:51 <ddarius> The universal quantification in ST's type makes it less general, not more.
20:09:11 <JoeyA> If I turn on ScopedTypeVariables and use forall s, it still gives the same error, btw
20:10:10 <edwardk> try  withArray :: (Int,Int) -> (forall s. STUArray s Int Bool -> ST s ()) -> UArray Int Bool
20:10:56 <edwardk> and drop the signature on the a <- newArray bounds True line
20:11:06 <edwardk> and then see what you get
20:12:14 <edwardk> you probably some other error
20:12:17 <JoeyA> Works, but I had to turn on Rank2Types
20:12:22 <edwardk> yeah that is expected
20:12:24 <djahandarie> How would you write something like the strength transformation (for strong monads) in Haskell? fmap fmap (,) :: Functor f => a -> f b -> f (a,b) ?
20:12:35 <edwardk> djahandarie: i have it in category-extras ;)
20:12:44 <edwardk> and a blog post ;)
20:12:54 <djahandarie> Should have looked first :P
20:13:02 <edwardk> http://comonad.com/reader/2008/deriving-strength-from-laziness/
20:13:54 <Veinor> edwardk: what does \\a mean?
20:14:01 <ddarius> A monad is strong if its functor is strong.  A functor is strong if its action on arrows is itself an arrow.
20:14:13 <edwardk> Veinor: it means that my blog started doubling up my \'s due to crappy php formatting
20:14:19 <Veinor> ahh. :P
20:14:22 <edwardk> and all functors over Hask are strong
20:14:36 <Veinor> was gonna say, is this some crazy new notation?!
20:16:24 <ddarius> All functors in Haskell are strong because fmap is an arrow.
20:16:45 <applicative> @type fmap
20:16:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:18:06 <monochrom> freedom is slavery? laziness is strength? :)
20:18:28 <ezyang> unsafe pointers are slavery 
20:19:19 <Veinor> edwardk: what do you use to color your code? I use codecomplete
20:19:37 <JoeyA> What is the difference between withArray :: (Int,Int) -> (forall s. (STUArray s Int Bool -> ST s ()) ) -> UArray Int Bool
20:19:48 <edwardk> Veinor: i bounced through a few plugins i don't remember if what i have now is something stock or some third party thing i mangled into place
20:19:57 <JoeyA> and withArray :: forall s. (Int,Int) -> (STUArray s Int Bool -> ST s ()) -> UArray Int Bool
20:19:59 <Veinor> ah.
20:21:06 <edwardk> JoeyA: the former says the function you pass it has to be able to give you back an ST s for for _any_ choice of s, an the latter says that your function may only work for some particular choice of s
20:21:12 <edwardk> @type runSTArray
20:21:13 <lambdabot> Not in scope: `runSTArray'
20:21:27 <JoeyA> ah
20:21:34 <edwardk> runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e -- relies on that safety
20:21:52 <Axman6> JoeyA: it may seem subtle, but the difference is what allows the magic that is ST to occur
20:22:22 <edwardk> it says if you have some function that will return an STArray in _any_ ST monad, then nobody else could get their hands on the choice of s and use it to inspect the underlying STArray you built once you get done with runSTArray
20:23:01 <JoeyA> From my experiences so far, ST would be more aptly described as "type hell" than "magic" :-)
20:23:21 <edwardk> on the other hand if lameRunSTArray :: Ix i => ST s (STArray s i e) -> Array i e - was all I had i could do things like
20:23:34 <JoeyA> But perhaps when I get better, it'll be a piece of cake.
20:23:41 <Axman6> i tend not to write the types for ST stuff, unless completely necessary
20:23:56 <edwardk> foo = do arr <- newSTArray ... ; let foo = runSTArray (return arr); bar = runSTArray (return arr)
20:24:10 <edwardk> and try to 'freeze' the array twice
20:24:26 <JoeyA> Axman6: Even if it means not giving a toplevel a type signature?
20:24:39 <edwardk> the reason runSTArray can work without having an IO or something similar on the output is that safety.
20:24:44 <Axman6> get ghci to tell you the type
20:24:52 <kulin> n/quit
20:25:00 <edwardk> JoeyA: you can give them, just use universal quantification whenever you consume the ST s with a runST
20:25:06 <edwardk> or runSTArray
20:25:20 <edwardk> I tend to use a lot of those universal quantifications in my code
20:25:48 <edwardk> JoeyA: if you think Control.Monad.ST is hell: http://hackage.haskell.org/packages/archive/ad/0.17/doc/html/Numeric-AD.html
20:25:51 <ddarius> JoeyA: The difference in the types is the same as the difference between the following two statements: "Given Fido is a dog and all dogs hate cats then Fido hates cats" and "Given any dog Spot, if Fido is a dog and Spot hates cats then Fido hates cats"
20:27:33 <applicative> If you can eat any fish, you can eat *any* fish.
20:31:27 <midfield> hello, have an emacs / cabal question if anyone is around.....
20:39:23 <JoeyA> Why can't the type of "dummy" be deduced here?  http://codepad.org/dCm7qbck
20:39:50 <edwardk> @type writeArray
20:39:50 <lambdabot> Not in scope: `writeArray'
20:39:59 <JoeyA> (though it can if dummy is used, e.g. let dummy = ... ; dummy ; ...
20:40:14 <c_wraith> @hoogle writeArray
20:40:14 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
20:41:01 <c_wraith> JoeyA, it can't figure out what MArray instance you mean.
20:41:02 <JoeyA> Because it doesn't know what monad it's working in, just the array?
20:41:16 <JoeyA> okay, I guess I was right there
20:41:19 <JoeyA> thanks
20:41:39 <edwardk> JoeyA: probably because when you say newArray bounds True you bind that you have some MArray instance for (ST s), but when you go to just dangle it there is has no idea which monad you want the MArray for
20:41:49 <edwardk> MArray has three type arguments, but it doesn't have any fundeps
20:42:04 <midfield> hello, have an emacs / cabal question if anyone is an emacs user.....
20:42:11 <edwardk> ultimately it probably would have been better served by adding them
20:42:46 <midfield> how do you deal with developing multiple codependent cabal packages in emacs?
20:42:49 <edwardk> at least   class (HasBounds a, Monad m) => MArray a e m | a -> m would have been useful
20:42:59 <edwardk> codependent?
20:43:19 <edwardk> are there any cycles in your mutual dependencies?
20:43:44 <midfield> no cycles
20:44:56 <midfield> package B depends on package A.  if i realize i need to make a change to package A while working on package B, what i have been doing is to make the edit to A, then reinstall the cabal package so B can see the changes in ghci in emacs.....
20:45:52 <midfield> it's not very convenient.  was wondering what other people do with multiple package development.
20:46:24 <ddarius> Why not develop them as one project until a reasonable stable state exists in some and then break them off into separate packages?
20:47:10 <edwardk> midfield: what do the packages do?
20:47:26 <edwardk> midfield: i admit i have a few packages like that and its hell maintaining them
20:48:03 <midfield> it's an option, but for version control reasons it'd be nice to keep them separate.  i was just wondering what other people do with multiple package development.....
20:48:18 <midfield> edwardk: unfortunately i can't talk about what they do, sorry.
20:48:20 <edwardk> midfield: mostly suffering ;)
20:48:24 <edwardk> midfield: no worries
20:49:12 <midfield> ddarius: maybe another question is, is there a good way with darcs to fork off a subproject, maintaining history?
20:49:31 <gwern> midfield: do a darcs get, then darcs rm the unwatned files?
20:50:06 <midfield> gwern: i'm a darcs newbie, will that save the history?
20:50:15 <gwern> so far as I know
20:50:34 <edwardk> midfield: it works fine
20:50:39 <ddarius> Of course it will.
20:50:44 <gwern> I doubnt you want to mess around with tricks like pulling only patches touching certain files and building a history out of that
20:50:57 <edwardk> midfield: the new repository is just another repository with all the history for the no longer relevant portions though.
20:51:31 <midfield> yeah, well perhaps i will go with ddarius's suggestion and turn them all into one big project, which i can fork off later.  thanks.
20:51:38 * hackagebot ad 0.24 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.24 (EdwardKmett)
20:51:45 <ddarius> Regardless, building projects together doesn't require them to be version controlled together.
20:52:00 <midfield> edwardk: ps thanks for category-extras, it's fun
20:52:13 <edwardk> midfield: =)
20:52:22 <edwardk> happy to help
20:52:46 <JoeyA> Why is the type signature on dummy2 required here?  http://codepad.org/4zC7Qq5G
20:53:25 <edwardk> JoeyA: because it isn't being determined as a STUArray or STArray. it could be either
20:53:41 <midfield> ddarius: how would that work with in practice?  can you make a folder which is a repository in two different ways?
20:54:15 <JoeyA> Also, why can't I write:  (dummy2 :: STArray s Int Bool) <- newArray (0::Int, 5::Int) False  ?
20:54:16 <ddarius> You don't have to have them in the same folder.
20:54:29 <FunctorSalad> midfield: unionfs ;)
20:55:09 <midfield> so you can have emacs / ghci search in multiple folders for source?
20:55:13 <FunctorSalad> I've actually used it for overlaying module-folder-hierarchies from different packs
20:55:18 <edwardk> when working with multiple projects with mutual dependencies i slap together a cheesy little alias/build script i can use, then make sure to fix bugs in them in topological order ;)
20:55:21 <ddarius> You have a directory with your overall cabal file (or whatever build infrastructure) subdirectories (usually, they can be any directories) for each subproject that, if you like, are each version controlled independently.
20:55:23 <JoeyA> (I have ScopedTypeVariables on, of course)
20:55:34 <FunctorSalad> (whether that was really necessary is another q)
20:55:58 <edwardk> er s/mutual//
20:56:58 <midfield> basically i just want C-c C-l to work in emacs, and have had trouble doing that with multiple source trees
20:57:10 <midfield> but i will try your suggestion, thanks
20:57:23 <ddarius> Or you can just version control them all together.  The only cost being the extra history stored in the forks when you do fork them off.
20:57:34 <FunctorSalad> midfield: for that, what I said would actually work I think
20:57:46 <FunctorSalad> if you want to interpretedly load mods from more than one package in ghci
20:58:03 <FunctorSalad> well, or just use the -i or -I flag or what it is to ghci
20:58:29 <midfield> FunctorSalad: it sounds interesting, but i don't have control over the machine i'm building on to install something like that, unfortunately.
20:58:39 <FunctorSalad> I see
20:58:51 <midfield> thanks for the idea though, i'll check it out
21:05:24 <midfield> goodnight!
21:05:37 <absentia> good night
21:07:37 <edwardk> whoa, when did haddock get smart enough to find template haskell instances?
21:07:58 <ddarius> Anyone aware of a good, online, low-barrier to entry description of logic in terms of game theory?
21:08:28 <edwardk> ddarius: i've seen one, but i can't recall the link lemme take a quick look
21:08:32 <ddarius> "template haskell instances"?  Surely you don't mean spliced instances or something?
21:08:36 <FunctorSalad> edwardk: hmm it isn't simply run after TH expansion?
21:08:40 <edwardk> ddarius: yeah
21:08:47 <ddarius> That is impressive.
21:08:59 <edwardk> i have a crud ton of instances that i spit out through TH that it just found for me =)
21:09:25 <FunctorSalad> what other "TH instances" are there except spliced ones?
21:09:47 <edwardk> http://hackage.haskell.org/packages/archive/ad/0.23/doc/html/Numeric-AD-Newton.html#t%3AAD -- all the instances with Lifted f in the LHS are all TH generated
21:09:58 <FunctorSalad> == spliced, no?
21:10:03 <edwardk> FunctorSalad: yeah
21:10:21 <FunctorSalad> maybe you missed the negation in what ddarius said?
21:10:40 <edwardk> FunctorSalad: you're right i did ;)
21:23:11 <ksf> all hail to graphviz, keeper of sanity.
21:23:31 <mtnviewmark> @hoogle (t -> t1) -> t -> (t, t1)
21:23:32 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
21:23:32 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
21:23:32 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
21:23:36 <Gracenotes> im in ur graphviz, minimizing ur edge crossings
21:23:42 * JoeyA repeats the hail
21:27:23 <mtnviewmark> @hoogle (a -> [b]) -> a -> [(a,b)]
21:27:23 <lambdabot> No results found
21:27:48 <FunctorSalad> favourite way to parse commandline args in haskell?
21:28:10 <dancor> FunctorSalad: http://github.com/dancor/polyopt :)
21:28:15 <mtnviewmark> @pl \f a -> map (\b -> (a,b)) (f a)
21:28:15 <lambdabot> liftM2 map (,)
21:28:18 <ezyang> cmdargs 
21:28:36 <FunctorSalad> one of the packages claims to be much more concise than getopt but breaks purity for it! I can't imagine how that's necessary
21:28:45 <FunctorSalad> ezyang: think it was that one
21:29:03 <FunctorSalad> unsafePerformIO should be a last resort, not first :(
21:29:17 <ezyang> I saw some pretty evil unsafePerformIO code at work 
21:29:19 <dancor> what about TH madness
21:29:28 <dancor> where does that rank
21:29:50 <FunctorSalad> dancor: I don't have any issue with that in comparison
21:30:07 <dancor> well only two ppl have used polyopt so far
21:30:08 <FunctorSalad> is that what yours does? *takes a look...*
21:30:19 * ksf reverses all edges except those he doesn't reverse
21:30:24 <mtnviewmark> should I feel bad that I can't look at "liftM2 map (,)" and just "get it"
21:30:25 <mtnviewmark> ?
21:30:32 <mtnviewmark> :-)
21:30:41 <Axman6> mtnviewmark: i can't get it either
21:31:03 <FunctorSalad> there's also a new one, comandline-program or so
21:31:09 <ksf> @unpl liftM2 map (,)
21:31:09 <lambdabot> (\ e -> (,) >>= \ b -> e >>= \ a -> return (map b a))
21:31:14 <mtnviewmark> where as   \f a -> map (\b -> (a,b)) $ f a     is pretty easy to get
21:31:25 <BMeph> Does anyone have a short-and-sweet answer to why functions returning functions are higher-order?
21:31:30 <FunctorSalad> *console-program
21:31:53 <mtnviewmark> BMeph - try doing it in C!
21:32:04 <ksf> excellent answer.
21:32:27 <FunctorSalad> another option is to make an options monoid and just mconcat the argz...
21:32:32 <ddarius> BMeph: Curry is the core of HOFs.
21:32:43 <FunctorSalad> deriving Monoid componentwise with derive
21:32:51 <dancor> that sounds cool
21:32:56 <mtnviewmark> not to mention the basis for many a fine cuisine
21:33:27 <BlueSilver39> anyone using haskell for web apps?
21:33:40 <Makoryu> BlueSilver39: Sure, check out Snap
21:33:43 <Makoryu> @where snap
21:33:43 <lambdabot> I know nothing about snap.
21:33:46 <Makoryu> >:|
21:33:53 <BlueSilver39> i see
21:34:04 <BlueSilver39> is snap a pretty "serious" project?
21:34:12 <BlueSilver39> with users or just an educational deal
21:34:12 <Raynes> BlueSilver39: As serious as it gets.
21:34:24 <BlueSilver39> ocaml has some web apps 
21:34:26 <Raynes> Serious kitty is serious.
21:34:33 <BlueSilver39> none of them really used though i dont think 
21:34:54 <dancor> snap is seriously new and they seem to seriously want help making it into something serious
21:35:16 <BlueSilver39> the website looks nice 
21:35:23 <BlueSilver39> atleast they read something on user interface design 
21:35:28 <dancor> srsly
21:36:03 <FunctorSalad> BMeph: hmm are they really higher-order? thought you need a function as *input*; function-as-output is just multiple args after all
21:36:10 <dancor> i've only really used happstack for webapps so far
21:36:28 <FunctorSalad> of course the issue at hand is just the definition of 'higher-order'
21:36:40 <MrBones> Aren't you arguing over semantics?
21:36:51 <FunctorSalad> I just said that
21:36:57 <dancor> "said"?
21:36:57 <MrBones> :(
21:37:19 <FunctorSalad> up to semantic similarity
21:37:29 <BlueSilver39> i have not even used haskell yet heh
21:37:37 <dancor> Pol the category of discourse
21:37:46 <BlueSilver39> but alot of other functinal langauges 
21:37:54 <FunctorSalad> Pol?
21:38:05 <dancor> polemic
21:40:46 <FunctorSalad> dancor: but seriously isn't it pretty much the same to be saying that one is discussing definitions or arguing semantics? :(
21:40:55 <FunctorSalad> insecure cat is...
21:41:19 <dancor> i think so
21:45:16 <jmcarthur> does ST not like being at the bottom of a transformer stack?
21:46:09 <jmcarthur> @type runST . runWriterT :: (forall s . WriterT o (ST s) a) -> (a, o)
21:46:10 <lambdabot>     Couldn't match expected type `forall s. WriterT o (ST s) a'
21:46:10 <lambdabot>            against inferred type `WriterT w m a1'
21:46:10 <lambdabot>     In the second argument of `(.)', namely `runWriterT'
21:46:17 <FunctorSalad_> hmm how do you install cabal-install-HEAD? it requires Cabal-1.9, but I thought we aren't meant to upgrade ghc-bundles packs
21:53:13 <FunctorSalad_> ok did it anyway, let's see what happens :F
21:54:58 <MrBones> how do I persistently change the default editor for GHCI in windows?
21:57:02 <FunctorSalad_> MrBones: :set editor foo
21:57:06 <FunctorSalad_> in your .ghci
21:58:17 <MrBones> i'm in windows - is there a .ghci equivalent? I can't see something appropriate
22:00:36 <FunctorSalad_> hmm I don't know where it is in windows, presumably in your home directory or the application data (?) subdir
22:00:55 <mtnviewmark> how do you express   [ a | a <- someList, b <- f a, pred a b ]  get expressed in do notation?
22:01:08 <mtnviewmark> notable the predicate part
22:01:15 <mtnviewmark> er, specifically
22:01:27 <Axman6> @undo [ a | a <- someList, b <- f a, pred a b ]
22:01:27 <lambdabot> concatMap (\ a -> concatMap (\ b -> if pred a b then [a] else []) f a) someList
22:01:37 <rl> now lemme see
22:01:41 <Axman6> @. do undo [ a | a <- someList, b <- f a, pred a b ]
22:01:41 <lambdabot> concatMap (\ a -> concatMap (\ b -> if pred a b then [a] else []) f a) someList
22:01:45 <mtnviewmark> undo eh?
22:02:29 <ddarius> mtnviewmark: Use guard.
22:02:39 <mtnviewmark> in a do block?
22:02:49 <ddarius> :t guard
22:02:49 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:03:06 <mtnviewmark> oh, not the construct called guard --- the function guard!
22:03:13 <mtnviewmark> heh --- that's what I was looking for 
22:03:14 <mtnviewmark> thanks
22:07:38 <FunctorSalad_> cabal-install bash-completion uses a tempfile because "putting it into a variable would mess up the lines"? what?
22:07:53 <FunctorSalad_> with some odd shells?
22:08:05 <ODAY> w/quit
22:09:09 <FunctorSalad_> ok, you get spaces... but I don't think spaces are valid in package names
22:10:08 <BlueSilver39> nto to sure what to think about this snap thing
22:19:46 <mtnviewmark> BlueSilver - looks pretty good to me - what's not to like about it?
22:22:15 <djahandarie> Is anyone working on making IO actually denote something?
22:22:34 <ezyang> Like, denotational semantics? 
22:23:01 <copumpkin> djahandarie: subsets of it, in FRP work
22:23:11 <copumpkin> in general, it's a big bag o' shit, so no
22:23:28 <djahandarie> Yeah, I've seen the FRP stuff. But is anyone trying to uh... solve it all?
22:25:33 <djahandarie> I think conal said something like "IO expressions 'denote something' but we don't know what that something is", and that it'd need require tractable denotations to be proper
22:25:51 <danharaj> IO is very complicated.
22:26:50 <ddarius> @hackage IOSpec
22:26:50 <lambdabot> http://hackage.haskell.org/package/IOSpec
22:26:56 <danharaj> It's probably not worth it to give it proper denotational semantics. What would you gain from it? Any such denotation would be just as complicated to the point of intractability.
22:27:15 <danharaj> Giving IO operational semantics on the other hand, is an A+ idea.
22:27:21 <danharaj> (It probably already has those)
22:27:55 <ddarius> Operational and denotational semantics are not that far separated.  In fact they are intimately related.
22:28:00 <djahandarie> danharaj, if it is denotational it'd be a lot easier to reason about and more compositional
22:28:16 <danharaj> djahandarie: I read Conal's papers too :)
22:28:19 <djahandarie> Yes
22:28:35 <djahandarie> So then where do you disagree?
22:29:15 <danharaj> but the fact of the matter is, that doesn't mean anything if the model you get is intractable as a mathematical theory. Just because it is denotative means that it is easy to reason about, even if it relatively closer to that goal than no denotation at all.
22:29:58 <danharaj> I am talking about the specific IO monad, by the way.
22:30:02 <danharaj> Not I/O in general.
22:30:23 <djahandarie> I'm pretty sure conal is about scrapping monadic IO entirely
22:30:32 <ddarius> "'There's only one principle of war and that's this.  Hit the other fellow, as quick as you can, and as hard as you can, where it hurts him most, when he ain't lookin'!'"
22:31:05 <danharaj> Yes, he is. Instead of trying to reason about IO, build a new model of input and output that is by construction easy to reason about.
22:31:37 <djahandarie> And why would this be "not worth it"?
22:31:44 <danharaj> That would be worth it, maybe.
22:31:55 <danharaj> I was talking about trying to give IO the monad a denotation.
22:32:16 <djahandarie> Ah I see
22:33:11 <djahandarie> That IOSpec thing looks pretty nifty
22:39:54 <ddarius> "The enemy must be made to see the situation not only as deteriorating, but deteriorating at an ever-increasing rate."
22:46:40 <augur> anyone familiar with unification theory?
22:47:14 <ddarius> augur: Unification a la Prolog?
22:47:28 <augur> after a fashion, yes
22:47:37 <ddarius> You were the one doing the ACI unification stuff, yes?
22:47:45 <augur> ACI unification?
22:48:07 <ddarius> Associative, commutative, idempotent unification (i.e. set unification)
22:48:34 <augur> probably not :P
22:48:46 <augur> lets talk about prolog, since that might answer my questions
22:49:08 <augur> unification of a hash. { a: 1 } U { b: 2 } ==> { a: 1, b: 2 }
22:49:11 <augur> yes?
22:49:38 <augur> not necessarily in prolog, i dont know about prologs hashes, if it has any, but in general
22:50:09 <ddarius> That's a union of a hash, not unification.
22:50:19 <augur> mm, well
22:50:46 <augur> { a: X } U { a: 1} ==> { a: 1 } / X = 1
22:51:03 <ddarius> Sure.
22:51:16 <augur> its unification in the unification-grammar sense
22:51:38 <augur> which includes all the normal senses, plus some
22:52:39 <augur> i mean, as far as i can tell, the notion is that its the smallest possible object you can construct that contains all contents of the unificands, modulo variables unifying with values
22:52:56 <augur> hence X U 1 ==> 1 / X = 1
22:52:59 <augur> etc.
22:54:00 <ddarius> augur: Similar to the categorical notion of limit which is related to unification.
22:54:11 <augur> perhaps!
22:54:21 <augur> but im not sure how to approach certain things
22:54:31 <augur> so lets say we're talking about hashes
22:54:53 <augur> if we admit of the notion that a unification is the smallest possible way of combining the two items, preserving information, modulo variable binding
22:55:12 <augur> { a: X } U { Y: 1 } ==> ???
22:55:21 <augur> { a: 1 } / X = 1, Y = a
22:55:21 <augur> ?
22:55:49 <augur> this seems to make some amount of sense, i suppose. so lets assume this does make sense.
22:56:14 <augur> by analogy then, [a,X] U [Y,1] ==> [a,1] / X = 1, Y = a. reasonably.
22:56:17 <augur> normal unification
22:56:34 <ddarius> Well, you can view unification in a dual way in which case you arrive at a colimit.  A typical way of describing a colimit is it combines things with the "least destructive" identification of selected subparts.
22:56:56 <ddarius> Your equation isn't the least destructive identification.  It identifies things unnecessarily.
22:57:03 <augur> but.. what about [a,1] U [b,2] ? normally this would fail, but [a,1,b,2] and [b,2,a,1] are both the smallest possible lists that contain [a,1] and [b,2]
22:57:17 <ddarius> { a: X } U { Y: 1 } should be { a: X, Y: 1} arguably.
22:57:32 <augur> do you think so
22:57:53 <augur> so unification, you'd say, shouldn't assign variables unless forced to
22:57:54 <ddarius> Are you using [a,b] to notate a list?
22:57:58 <augur> yes
22:58:07 <ddarius> augur: Yes.  Unification shouldn't bind variables unless forced to.
22:58:24 <augur> hm. ok. so then i think that makes the hash unification trivial
22:58:44 <augur> what about set unification.. {1} U {X} ==> {1} / X = 1
22:58:46 <augur> i think
22:58:54 <augur> but what about {1,X} U {1}
22:59:06 <augur> is this the same? or is it a failure?
22:59:16 <ddarius> augur: Unifying to hashes should be unioning them together and unifying any slots that are in both.
22:59:26 <augur> right
22:59:31 <augur> i suppose!
23:00:08 <ddarius> It would be something like unionWith unify (using made up Haskell functions)
23:01:12 <augur> so should those sets unify?
23:01:25 <augur> if so, should they produce {1} or should they produce {1,X}?
23:01:52 <augur> with the hashes i can sort of see why you'd not unify the key variable
23:01:59 <ddarius> {1} U {X} leads to {1,X}, {1} =:= {X} leads to {1} / X = 1, {1,X} U {1} leads to {1,X}.  {1,X} =:= {1} leads to {1} / X = 1.
23:02:21 <augur> well, im not sure what you're using Y and =:= for
23:02:45 <ddarius> Well, I think I may have been misinterpreting what you intended U to mean.
23:02:56 <augur> im just using U to mean the unification of the two. set union is obviously trivial and we dont need to talk about that :P
23:03:13 <augur> if you're using =:= for unification, ill stick to that for your convenience
23:03:20 <ddarius> Okay, U is the typical notation for union which is how I've been interpreting it this whole time.
23:03:40 <ddarius> So, that changes most of my responses.
23:03:50 <augur> i figured in context of me saying unification of X and U is X U Y.. :P
23:04:13 <augur> { a: X } =:= { Y: 1 } ==> ??
23:04:44 <ddarius> Then, yes, you are right that Y is forced to be a and X 1.
23:05:16 <augur> because its the smallest hash that preserves the information, right
23:06:10 <augur> so that brings me back to lists; [1] =:= [2] ---- is this null, or is it [1,2] [2,1]
23:06:20 <ddarius> It's unification failure.
23:06:25 <augur> normally you'd say null, but smallest possible information-preserving list eh..
23:06:34 <augur> i suppose it depends on what "information" means
23:06:47 <augur> is ordinality the information preserved?
23:06:53 <ddarius> If there are no logic variables the two things have to be equal with whatever the relevant notion of equality is, usually structural equality.
23:07:10 <augur> right
23:07:35 <augur> except { a: 1 } =:= { b: 2 } should be { a: 1, b: 2 }
23:07:43 <ddarius> No, that should be failure too.
23:07:53 <augur> well not in the sense of unification i need to use :P
23:08:09 <augur> like i said, smallest possible information preserving hash
23:08:41 <ddarius> And what should { a: 1 } =:= { a: 2 } do ?
23:08:46 <augur> failure
23:08:51 <augur> theres no way to preserve information that way
23:09:09 <augur> keys are unique in hashes, thus you can unify those only if you can unify 1 and 2
23:09:17 <ddarius> augur: The question is, can you test for a key being available?  If so, adding a key changes (neither increases nor decreases) the information content.
23:09:50 <augur> well theres always information that changes, depending on your definition of what is information, obviously
23:10:07 <ddarius> Yes.  You need to provide a definition of what information is relevant.
23:10:18 <augur> thats i think part of what im trying to understand
23:10:49 <augur> im not sure if these are really clearly defined notions
23:11:12 <augur> in standard unification-based models of grammar, you get hash unification like i described
23:11:14 <ddarius> augur: I'm not saying there is a particular one.  I'm saying "you" need to choose one.
23:11:22 <augur> and im trying to!
23:11:22 <augur> :P
23:11:27 <augur> im trying to work out what makes sense tho
23:11:40 <ddarius> augur: One view is to view hashes as having every key bound to an unbound logic variable.
23:11:58 <augur> er
23:11:59 <augur> what?
23:12:29 <ddarius> Then { a: 1 } =:= { b: 2 } will unify in the normal way as, { a: 1 } is "really" { a: 1, b: X, c: Y, ... }
23:12:57 <augur> right, ok
23:13:12 <ddarius> All this means is that when you look up a key in these hashes, it always succeeds but it may return an unbound logic variable.
23:13:15 <augur> thats sort of the view i think im working in
23:13:43 <augur> at least i suppose it is :p
23:14:03 <augur> the domain im working in usually only has three kinds of objects that can be unified, values, variables, and hashes
23:14:36 <augur> variables being unifiable with anything, but those other things dont, usually, participate in unifications.
23:15:01 <ski> why are variables a kind of object in your system ?
23:15:27 <ski> are you modeling an object system with variables in a meta-system ?
23:15:29 <augur> maybe they do and im just not familiar with enough of the literature, who knows
23:15:51 <augur> well, objects in the sense that they're things that show up in the representations of the things being unified
23:16:00 <ddarius> He may have meant "terms" instead of "objects" per se ... 
23:16:02 <augur> and yes, i am indeed building a metasystem
23:16:04 <ski> that'an another thing ..
23:16:24 <augur> but im trying to grasp at the most sensible notion of unification
23:18:41 * ski wonders why the above are called hashes ..
23:18:52 <augur> { a: 1 } looks like a hash to me :P
23:19:07 <augur> associative list? key-value pairs? feature structures?
23:19:08 <augur> take your pick
23:19:11 <augur> its all the same
23:19:11 <ddarius> Mapping.
23:19:15 <augur> indeed!
23:19:15 <ski> `#' looks like a hash, to me
23:19:19 <augur> :P
23:19:21 <ddarius> Key -> Value
23:19:32 <ski> ok, a hash *map*
23:19:42 <augur> key -> value
23:19:42 <augur> key -> value
23:19:43 <augur> key -> value
23:19:46 <augur> draw the spaces!
23:20:12 * ski peers curiously at augur
23:20:12 <augur> key#->#value
23:20:12 <augur> ############
23:20:14 <augur> key#->#value
23:20:16 <augur> ############
23:20:18 <augur> key#->#value
23:20:20 <augur> look at the shape!
23:20:22 <augur> its just like #!
23:20:30 <augur> :p
23:20:46 <augur> maybe i should take that to /esoteric e.e
23:22:36 <safiire> The library libHSbase-4.2.0.0.a is referencing a symbol named "_environ".  Does anyone know what library that symbol resides in?
23:24:35 <mauke> I don't know, but libc has environ
23:25:21 <augur> see, i think the thing is its difficult for me to sort of grasp entirely what it means to really do this
23:25:27 <augur> i suppose you can view lists as hashes yeah
23:25:41 <augur> [a,b,c] is { 0: a, 1: b, 2: c }
23:26:02 <mauke> oh hey, javascript
23:26:09 <augur> no, not JS
23:26:18 <augur> so conflicting lists, [a,b,c] =:= [x,y,z] will have conflicting values for the values of the indices
23:26:48 <ski> and sure, `[a,b,c] = [x,y,z]' would fail
23:26:52 <augur> right
23:26:53 <ski> (in Prolog)
23:27:18 <augur> but it also explains why the "smallest information preserving combination" is a failure as well
23:27:35 <ddarius> augur: You can, except list length is usually an important part of their structure so it would not do to allow arbitrarily long tails.  However, you can represent that as in, e.g. Prolog [X|[Y|Zs]] which would be like X:Y:Zs in a Haskelly notation.
23:27:38 <augur> i mean, one purely list-oriented interpretation could be that [a] =:= [b] is [a,b] and [b,a]
23:27:48 <ski> augur : what do you mean by that former statement ? 
23:27:59 <augur> because both of the resultant lists preserve the elements of the first, and are the smallest lists that do so
23:28:14 <augur> ddarius: i take that as not being part of the information :P
23:28:35 <augur> it can be epiphenomenal on the idea that lists-qua-hashes are hashes with key constraints
23:28:54 <ddarius> Then your "lists" are unbounded streams if we take the perspective of the "hashes with all keys bound to unbound logic variables"
23:29:05 <augur> ah, true
23:29:10 * ski arbitrarily declaims that `{ a: 1 }' really meaning `{ a: 1, b: X, c: Y, ... }' is bad
23:29:14 <augur> [1] =:= [1,2]
23:29:49 <augur> ski: perhaps, but thats sort of what im working with, since i _must_ have {a:1} =:= {b:2} == {a:1,b:2}
23:29:58 <ddarius> That would really be: 1:Xs =:= 1:2:Ys in your system (and such things are commonly done in Prolog)
23:30:18 <ski> (at least if two occurances of `{ a: 1 }' expand to *different* variables `X',`Y',&c. each time)
23:30:49 <ski> augur : maybe you're really after some kind of union, and not unification ?
23:30:55 <augur> but its not merely union
23:31:18 <augur> because {a:[1,X}} =:= {a:[Y,2]} unifies to {a:[1,2]}
23:31:41 <ski> (where if the two uniands have common attributes, their values have to be unified, because your hash maps describe (partial) functions)
23:31:53 <augur> right, but thats not merely union then :p
23:31:54 <ddarius> ski: The existential quantification would occur at the "creation" of the "hash" so they should be the same logic variables for a given "instance."  How exactly to nail down "instance" is somewhat tricky.
23:31:59 <ddarius> (potentially)
23:32:11 <ski> augur : so, i'd say that's still union, declaratively speaking
23:32:25 <augur> fine, call it what you like
23:32:46 <ddarius> ski: View the "hashes" as total functions.  It is not observable that a key is not bound (or rather keys are always bound, potentially to unbound logic variables).
23:33:01 <augur> im not sure how its supposed to work on hashes like {a:1} =:= {X:1} tho
23:33:21 <augur> the smallest possible super-hash is obviously just {a:1}, unifying X=a
23:33:39 <ski> ddarius : so the term `{ a: 1 }' would introduce referential opacity; you couldn't replace a variable set to such a term with its definiens
23:33:49 <augur> lets assume thats what its supposed to be tho
23:34:09 <augur> what is [1] =:= [X] if we have some notion of "union" not unification in the traditional sense?
23:34:20 <augur> is it just [1], or is it some different list
23:34:45 <ddarius> augur: That's not an answerable question.
23:34:59 <ski> ddarius : i'm just objecting to writing `{ a: 1 }' when `{ a: 1 | _ }' is "really" meant
23:35:00 <ddarius> augur: What's 1 + 1 if we have some notion of "+" not the traditional one?
23:35:06 <ddarius> ski: I agree.
23:36:30 <augur> ddarius: i suppose. i mean, again, the idea, i think, is, at its core, that the result of the "un(ificat)ion" is the smallest object that contains all of the information of the original
23:36:32 <augur> s
23:36:41 <augur> for some notion of "all of the information"
23:36:55 <ski> augur : the union (not unification) of `{a:1}' and `{X:1}' would be `{a:1,X:1}' with the understanding that `X' may later be known to be `a', in which case the answer actually is `{a:1,a:1}' which is the same as `{a:1}'
23:37:25 <augur> i suppose, but how would you later show that X=a?
23:37:33 <augur> perhaps if X is referenced elsewhere
23:37:49 <ddarius> ski: Incidentally, there are issues with referential transparency for similar reasons in (some) logic languages.  E.g. in Curry something analogous to f x = (y,y) where y = x + 1 | x - 1 is different than f x = (x + 1 | x - 1, x + 1 | x - 1)
23:38:23 <ski> ddarius : i know, i *know* :) :(
23:38:44 <ddarius> If the only way you can bind logic variables in key position is by unifying your "lax hashes" then such logic variables will never be bound.
23:39:12 <ski> (and that's a failing of Curry, imo)
23:39:45 <ddarius> ski: I don't think it is reasonably avoidable except perhaps by viewing non-determinism as an effect.
23:40:11 <ski> augur : if `X' is not referenced anywhere, then `{a:1,X:1}' represents possibly many concrete answers .. but usually that wouldn't matter
23:40:22 <ddarius> And by "I don't think" I mean "I'm not sure that"
23:40:42 <augur> hmm
23:41:03 <augur> all of this might be purely academic because the actual systems in question might not ever have variables in key position ;)
23:41:09 <augur> but im trying to be general here
23:41:18 <augur> btw
23:41:18 <augur> http://streamer.perimeterinstitute.ca/Flash/9a93c428-c616-4dca-8713-915277e28056/viewer.html
23:43:09 <ski> take the union of `{a:1,X:1,d:e}' with `{Y:X,c:Y}' and `{c:d}'; this will instantiate `Y' and therefore `X'
23:43:15 <ddarius> ski: This is a good read if you haven't read it before: http://comjnl.oxfordjournals.org/cgi/reprint/35/5/514.pdf
23:44:57 <safiire> If the symbol _environ is from crt1.o, I wonder how any program on osx could have trouble finding it.
23:45:20 <copumpkin> wrong arch crt1.o maybe?
23:45:40 <augur> ski: all of this raises another question, that of sets. _by analogy_ to the union-esque notions, which ill just denote ~ for lack of a clear conception of it, {1} ~ {2} = {1,2}
23:45:43 <copumpkin> they have a bunch of different architectures coexisting and if your linker settings are messed up it might be trying to link it incorrectly
23:45:49 <safiire> Ah, perhaps that is what's going on.  I find xcode's archetecture options a bit confusing.
23:45:58 <augur> but what is {1} ~ {X} ?
23:46:04 <safiire> I am just trying to link some haskell code into a project I am writing in xcode.
23:46:05 <augur> {1} with X = 1, or is it {1,X}
23:47:41 <augur> btw can i just say that monad-esque operations have a huge place in this project im working on?
23:48:07 <augur> ive got binds everywhere, its horrible
23:48:18 <copumpkin> very S&M
23:48:27 <ski> ddarius : ty
23:48:32 <copumpkin> or D&S, maybe
23:49:13 <augur> copumpkin: o mai
23:49:14 <augur> what
23:49:16 <augur> XD
23:49:17 <Gracenotes> :o
23:49:18 <ski> augur : the union is `{1,X}' which might be `{1}' if `X' is `1'
23:49:20 <augur> oh i see
23:49:23 <augur> binds everywhere :)
23:49:25 <augur> Gracenotes!
23:49:32 <augur> just the queer i was looking for
23:49:36 <Gracenotes> augur, you person you
23:49:42 * augur ties Gracenotes up
23:50:16 <ski> (augur : but `X' doesn't *need* to be `1')
23:50:23 <augur> right
23:50:30 <augur> i suppose. i guess i really should just stick with the bind-vars-only-when-necessary approach
23:50:34 <Gracenotes> I've posted an overview of my Hackage gsoc progress this week: http://cogracenotes.wordpress.com/2010/06/07/hackage-modular-features/
23:50:44 <augur> [1,X] ~ [1,2] necessitates it
23:50:52 <augur> but {1,X} ~ {1,2} doesn't
23:51:15 <ddarius> augur: For a strict unification, that forces X to be 1 or 2.
23:51:20 <ski> `[1,X] ~ [1,2]' only necessitates it if `~' is *unification*
23:51:38 <ski> if `~' is concatenation, it doesn't necessitate it
23:51:40 <ddarius> Sorry, it forces X to be 2.
23:51:42 <augur> right
23:52:13 <augur> this again tho is sort of the tricky thing tho, because its intended to be the set/list analog of what we did with hashes
