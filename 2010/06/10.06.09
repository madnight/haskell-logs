00:00:44 <dmwit> Silvah: Hm. If you really, really want a strict, exact port, then I guess you're going to have to do some nasty things.
00:03:13 <Silvah> It's not a strict, exact port, yet it still needs that function badly.
00:04:19 <Silvah> So the only way is to unsafeCoerce a Float to a Word32, twiddle the bits, and then coerce it back?
00:05:42 <Zao> I'd unbox before coercing though, as the impossible has happened in this channel before.
00:05:55 <Gracenotes> without the FFI yes
00:06:57 <Silvah> Zao: so, unadorned Float# and Word# instead, yeah?
00:08:04 <dmwit> Silvah: My recommendation would be to write a Bits instance that does the coercing for you.
00:08:27 <dmwit> Silvah: Then you can write the bit-twiddling in sane-looking Haskell.
00:08:39 <danharaj> don't twiddle my bits
00:08:41 <danharaj> :|
00:08:44 <dmwit> unsafeCoerce should get compiled away
00:09:35 <dmwit> dunno whether GHC is clever enough to compile away sequential box/unbox operations
00:10:10 <Silvah> Then it's possible to make a rule.
00:10:18 <dmwit> sure
00:12:26 <Gracenotes> and it becomes unsafeCoerce# ofc
00:15:36 <Silvah> Should I write the Bits instance for Float, will it be available in every module which imports the one that defines it, won't it?
00:18:24 <exDM69> http://www.pasteall.org/13679  <<--- I'm experiencing this problem again when trying to install Haskell Platform 2010 in Ubuntu (lucid 64 bit)
00:18:50 <exDM69> can I configure the header and library search paths in the configure script of the platform installer?
00:19:53 <exDM69> "library containing glEnd" not found is the error
00:26:23 <ksf> exDM69, you need opengl-dev or whatever the package is called
00:26:49 <ksf> ubuntu, as a member of the despicable debian family, leaves out the headers by default for no good reason.
00:27:03 <Raynes> Despicable me.
00:27:28 <mreh> not everyone is a developer :)
00:28:10 <newsham> ksf: dont redhat and fedora do the same?
00:28:15 <newsham> (despite not being debian family)
00:28:25 <ksf> if they'd left out the page-long login motd and shipped headers instead they'd use less total disk space.
00:28:53 <newsham> #include <motd>
00:29:05 <newsham> #include <issue>
00:29:07 <ksf> dunno. I ever only used lfs and gentoo, with a short depart to debian.
00:29:14 <Silvah> Windows does the same too and nobody complains.
00:29:18 <newsham> does your gentoo box have a spoiler?
00:29:50 <ksf> my lian li case does, indeed, come with a small part of carbon fibre imitation
00:30:01 <ksf> but no, my build flags are not riced.
00:30:29 <newsham> ground effect could be slowing down your /bin/ls
00:30:51 <exDM69> ksf: yeah, I had my nvidia-supplied opengl headers and libs
00:31:08 <exDM69> ksf: but I actually ended up installing libmesa because nvidia doesn't ship with the GLU library
00:31:14 <mreh> can I marshal a haskell function into a c function pointer?
00:31:34 <ksf> mreh, yes.
00:31:41 <mreh> sweeeeeet
00:31:50 <ksf> but iirc and they didn't change anything you need a haskell wrapper
00:31:50 <Raynes> @faq Can he do that?
00:31:50 <lambdabot> The answer is: Yes! Haskell can do that.
00:31:54 <Silvah> mreh: AFAIK yes, see FunPtr or something and friends.
00:32:06 <mreh> I hope it's in c2hs
00:32:16 <ksf> that is, haskell has to do the actual dispatching but the dispatch function is completely polymorphic
00:32:36 <exDM69> wtf now the haskell platform installer is failing again: "Could not find module `Control.Monad'"
00:32:51 <exDM69> Building the mtl-1.1.0.2 package failed
00:32:53 <mreh> that seems wrong
00:33:07 <newsham> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
00:33:09 <mreh> Control.Monad is in the system libraries
00:33:15 <ksf> it should be neigh impossible to have a ghc without mtl
00:33:37 <ksf> unless it's not finding its own nose.
00:34:11 <Silvah> We ain't got no mtl anymore!
00:34:16 <exDM69> I can even load Control.Monad in GHCi
00:34:31 <Gracenotes> perhaps you have a configuration that hides everything by default
00:34:48 <mreh> Silvah: since when? 6.12?
00:34:49 <Gracenotes> e.g. it expects a non-split base but you're giving it only 'base'
00:35:03 <Gracenotes> (which doesn't include 'mtl')
00:35:03 <exDM69> I have ghc 6.12.1 installed from ubuntu packages
00:35:38 <Gracenotes> exDM69: ooh. install libghc6-mtl-dev ?
00:35:41 <newsham> is there a separate package for ghc base libraries?
00:35:59 <Silvah> mreh: nah, it is just my silly comment to that situation ;)
00:36:17 <mreh> Silvah: WELL!
00:36:33 <mreh> indeed!
00:36:35 <Gracenotes> exDM69: other things worth installing from synaptic are network, HTTP and zlib
00:36:57 <Silvah> Tho I won't be surprised if it's really the case.
00:37:12 <ksf> gosh nested word automata are nice
00:37:18 <exDM69> Gracenotes: libghc6-{http, zlib}?
00:37:41 <mreh> exDM69, that sounds right
00:37:54 <Gracenotes> this is mostly because cabal-install needs them
00:37:56 <mreh> you need to bootstrap cabal with those installed
00:38:32 <exDM69> installed libghc6-mtl-dev, now the failure is even more spectacular: http://www.pasteall.org/13681
00:39:13 <mreh> most of those are warnings
00:39:16 <Gracenotes> well.. you've installed base.. just not profiled-enabled base. why would you need it?
00:39:16 <mreh> it's the same error as before
00:39:18 <Silvah> Could it be that base package is broken?
00:39:38 <Zao> Silvah: I would recommend a properly sized Word.
00:39:49 <Gracenotes> let's try another work around: install ghc6-prof
00:40:01 <Zao> Silvah: Also, ensure that floats indeed are IEEE754.
00:40:16 <exDM69> ubuntu actually has a cabal-install package, maybe I'll try that
00:40:43 <Zao> Or IEC559 or whichever name you want to have on the standard :D
00:40:51 <Gracenotes> exDM69: the main advantage of having your own is that it can reinstall itself for updates, and it isn't lagged behind 6 months
00:41:18 <mreh> what's the @name and @param markup called again?
00:41:24 <mreh> what uses it?
00:41:26 <Zao> haddock?
00:41:44 <mreh> I should have mentioned it's in C
00:41:46 <exDM69> Gracenotes: I did cabal --user install cabal-install right away :)
00:41:51 <Starfire> mreh: Doxygen?
00:41:53 <Silvah> Zao: floats on x86 are and I'm not interested in making it work anywhere else ;)
00:42:01 <mreh> Starfire, sounds right
00:42:03 <mreh> thanks
00:42:25 <BlueSilver39> i must be nuts for wanting to do a website in haskell
00:42:28 <Zao> Silvah: Word32 then.
00:42:49 <Gracenotes> or awesome
00:42:56 <Gracenotes> you decide
00:55:01 <dv-> Either
00:57:12 <soupdragon> Eyether
00:57:23 <Raynes> BlueSilver39: Once you eat a Slim Jim(TM), anything is possible!
00:59:15 <danharaj> slim jims are disgusting.
00:59:59 <jdsc> hello everyone
01:00:13 <augur> hello jdsc
01:00:44 * hackagebot graphics-formats-collada 0.3.0 - Load 3D geometry in the COLLADA format  http://hackage.haskell.org/package/graphics-formats-collada-0.3.0 (LukePalmer)
01:01:31 <jdsc> Is it possible to ask cabal to build only the library in a package (and not the executable) ?
01:02:38 <mreh> what am I supposed to do with a texi file?
01:02:54 <writer> mreh: makeinfo texi2*
01:03:27 <alip> anyone can give me some ideas on how to integrate a vty application with a line editing library like editline,readline or haskeline? I searched hackage but couldn't find an application that does this. basically i need a way to send vty keyboard events to the line editing library
01:05:20 <jdsc> alip: I have no idea, that seems kinda complicated :(
01:20:42 <quicksilver> alip: it is considered basically impossible to integrate readline into curses
01:20:52 <quicksilver> alip: since vty uses curses, you're probably out of luck
01:23:23 <alip> quicksilver: i see :( what about haskeline?
01:23:29 <BlueSilver39> Raynes: hmm i hateee those things 
01:23:53 <Raynes> BlueSilver39: So do I. :(
01:25:24 <quicksilver> alip: haskeline is probably more promising.
01:27:22 <quicksilver> but I expect it would require lots of hacking.
01:35:12 <shadwick> wow
01:35:18 <shadwick> LionMadeOfLions really wants in
01:36:42 <Gracenotes> if you want to convince him to use Haskell, you only have 8 seconds to do it
01:37:59 <Gracenotes> ..on average
01:40:29 <shadwick> does he normally come on this channel?..
01:55:53 <Phyx-> Gracenotes: you could see it as a challenge! :P
01:56:34 <kamatsu> man, i need Wolfram to write my falling sand game 
02:15:09 * ksf boings
02:17:08 <ksf> the estimated amount of grammars parseable with a nested word automaton with an attached tokenizer seems to be gigantic
02:17:43 * soupdragon wonders what one of them is
02:17:44 <ksf> ...I wouldn't want to parse <b><i></b></i>, anyway.
02:17:51 <ksf> http://en.wikipedia.org/wiki/Nested_word
02:18:33 <ksf> the nice thing is that they share all the goodness of regular languages, albeit in a higher complexity class
02:19:19 <ksf> but in the end it doesn't matter how fast you can minimize such a beast, the nice thing is that you can, and that you can do it compile-time...
02:26:03 <Phyx-> @where IORef
02:26:03 <lambdabot> I know nothing about ioref.
02:26:08 <Phyx-> @index IORef
02:26:08 <lambdabot> Data.IORef
02:28:01 <Phyx-> @hoogle a -> IORef a
02:28:01 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
02:28:01 <lambdabot> Prelude id :: a -> a
02:28:01 <lambdabot> Data.Function id :: a -> a
02:29:26 <Phyx-> @hoogle IORef a -> a -> IORef a
02:29:27 <lambdabot> Prelude asTypeOf :: a -> a -> a
02:29:27 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:29:27 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
02:29:38 <Phyx-> @hoogle a -> IORef a -> IORef a
02:29:39 <lambdabot> Prelude asTypeOf :: a -> a -> a
02:29:39 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:29:39 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
02:29:42 <Phyx-> hm
02:29:56 <Phyx-> ah
02:31:33 <wli> I'm not familiar with nested word automata. I know of nested stack automata.
02:32:01 <ksf> they're quite new
02:32:08 <ksf> 2004-ongoing
02:33:08 <ksf> the main property is that stack pushes and pops are done by the input, and always match
02:33:48 <ksf> formally, the state at a return token is both the usual linear dfa state plus the usual linear dfa state at the corresponding call.
02:34:40 <soupdragon> http://www.e-pig.org/darcsweb?r=Pig09;a=headblob;f=/test/Differentiation.pig
02:37:50 <luqui> Hi.  Is there a LANGUAGE parameter to enable all Haskell 2010 features?
02:39:49 <wli> Hmm, tree-adjoining grammars and embedded pushdown automata look interesting.
02:45:34 <wli> http://en.wikipedia.org/wiki/Combinatory_categorial_grammar <-- very interesting indeed
02:48:09 <yitz> wli: cool. as a first exercise, it should be trivial redo the lojban consistency proof in this formalism.
02:48:24 <yitz> s/redo/to redo/
02:50:31 <wli> yitz: I just like more general parsing algorithms. Not sure if parser combinators are very good at things since I think they choke on the wrong sorts of recursion etc.
02:50:47 <ksf> what does "efficently parseable"?
02:50:58 <ksf> "not resulting in exponential blowup"?
02:51:06 <ksf> +mean
02:51:15 <wli> ksf: Polynomial time parsing instead of NP-complete parsing a la indexed grammars.
02:51:46 <wli> Or undecidable parsing as per other things.
03:01:42 <earthy> best case general parsing is n^3, for ambiguous grammars, generating the parse forest
03:03:08 <earthy> anything non-linear on deterministic grammars is not worth talking about.
03:04:00 <ksf> ...time _and_ space
03:04:12 <ksf> I don't care much about expressivity, right now.
03:04:27 <wli> earthy: You must mean for LR(1) or similar.
03:04:33 <earthy> (ofcourse, the trick is to go linear when selecting a 'best' parse from a parse forest resulting from the possible parsess from an ambiguous grammar)
03:05:01 <wli> earthy: These are more general than CFG's.
03:06:52 * earthy did indeed mean general CFG, or even 2-level grammars with finite lattices in the attribute level
03:07:36 <earthy> when going to full 2-level grammars there is proof that the problem is turing-complete, and therefore arbitrarily expensive.
03:07:38 <wli> These would be things like tree-adjoining grammars, linear indexed grammars, and so on.
03:11:12 * earthy nods
03:12:07 <earthy> context-sensitive but restricted in the generality of the context.
03:12:22 <earthy> not all that much unlike attribute grammars or affix grammars.
03:25:31 <ivanm> is Antoine Latter ever on here?
03:33:28 <dayz> is the lemma "EX x y. f x ~= f y --> ALL x y. f x = f y" supposed to be true?
03:33:40 <tao_> Hello
03:34:22 <tao_> I have a list, i want to make another list with elements on odd positions
03:34:39 <tao_> which function should i use?
03:35:22 <Zao> Depends on what you mean by "odd positions".
03:35:34 <Zao> Do you want every other of the elements from a list?
03:36:14 <dayz> f is a function of type real => real
03:36:26 <tao_> well, for example in the list [1,2,3,4] i want to get elements 2 and 4
03:36:46 <tao_> because they are on positions 1 and 3
03:37:32 <Zao> I assume this is homework.
03:37:41 <tao_> umm, not really
03:37:46 <Zao> A function on the form of   f (x:y:xs)  would probably help.
03:37:52 <soupdragon> dayz totally offtopic
03:37:57 <Zao> Making it recursive and add a bunch of base cases.
03:38:23 <tao_> hmm
03:39:09 <Zao> [] and x:[] would probably be suitable ones.
03:39:24 <tao_> oh
03:39:26 <tao_> got it
03:39:32 <Zao> Or you could zip with [0..] and filter on fst.
03:39:32 <tao_> thanks
03:44:55 <Zao> > zip [0..] [9001,42,3,5]
03:44:56 <lambdabot>   [(0,9001),(1,42),(2,3),(3,5)]
03:45:50 <Zao> Bah, I've forgotten the smooth way to construct a predicate that compares on fst.
03:46:20 <Zao> @type (==) `on` fst
03:46:21 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
03:46:34 <dafis> Zao: comparing ?
03:47:06 <dafis> @type comparing
03:47:07 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:47:57 <Zao> > map snd $ filter (odd . fst) $ zip [0..] [9001,42,3,5]
03:47:58 <lambdabot>   [42,5]
03:48:08 <Zao> I didn't want to compare at all :D
03:48:14 * Zao blames ... something
03:49:17 <wlangstroth> I hate that: when you know you've seen a really slick solution ... and now you can't remember it as soon as you need it
03:49:57 <Zao> I'm currently skimming perldoc. There's awesome solutions all over the place.
03:50:02 <dafis> wlangstroth: Standard operating procedure
03:51:02 <ivanm> anyone here know much about UUIDs?
03:51:57 <Zao> They're large, they come from different schemes, they're reasonably unique, and they look sexy.
03:53:34 <caxapok> how to find sum of digits for number in haskell?
03:53:53 <Zao> show, convert to digit, sum?
03:53:56 <dafis> caxapok: simple way or good?
03:54:00 <ivanm> nah, there's a better way
03:54:03 <Zao> Or divide down until 0, sum remainders.
03:54:05 <caxapok> dafis: simple
03:54:11 <ivanm> the numeric library has a fold IIRC
03:54:15 <Zao> ivanm: Ooh.
03:54:26 <zygoloid> > filter fst . zip (cycle [False,True]) $ [9001,42,3,5]
03:54:27 <lambdabot>   [(True,42),(True,5)]
03:54:28 <dafis> caxapok: sum . map digitToInt . show
03:54:36 <zygoloid> > man snd $ filter fst . zip (cycle [False,True]) $ [9001,42,3,5]
03:54:37 <lambdabot>   Not in scope: `man'
03:54:38 <ivanm> @hoogle digits
03:54:38 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
03:54:38 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
03:54:38 <lambdabot> Numeric lexDigits :: ReadS String
03:54:41 <Zao> zygoloid: That's almost elegant.
03:54:43 <zygoloid> > map snd $ filter fst . zip (cycle [False,True]) $ [9001,42,3,5]
03:54:43 <lambdabot>   [42,5]
03:55:00 <ivanm> http://hackage.haskell.org/packages/archive/digits/latest/doc/html/Data-Digits.html#v:digits
03:55:16 <zygoloid> > concat $ zipWith ($) (cycle [const [], return]) [9001,42,3,5]
03:55:17 <lambdabot>   [42,5]
03:55:45 <ivanm> note that the documentation there is suffering from the haddock bug
03:55:50 <Zao> zygoloid: Now you're tending towards perverse.
03:56:04 <ivanm> I think the arguments are: base -> number -> digits_of_number_in_the_given_base
03:56:10 <ivanm> so you can use base 2, etc.
03:56:20 <ivanm> this is the digits library
03:56:28 <caxapok> dafis: sorry, im in haskell 2 days. What is '.' ?
03:56:48 <caxapok> sumdigits n = ...
03:57:16 <Zao> caxapok: (.) is function composition.
03:57:23 <zygoloid> > concat $ zipWith id (cycle [mempty,(:[])]) [9001,42,3,5]
03:57:24 <lambdabot>   [42,5]
03:57:32 <Zao> @src (.)
03:57:32 <lambdabot> (f . g) x = f (g x)
03:57:32 <lambdabot> NB: In lambdabot,  (.) = fmap
03:57:39 <wlangstroth> ivanm: "the" haddock bug?
03:57:58 <ivanm> wlangstroth: the haddock bug relating to documentations of the individual parameters of a function
03:58:05 <zygoloid> > concat . getZipList $ ZipList (cycle [mempty,(:[])]) <*> ZipList [9001,42,3,5]
03:58:05 <lambdabot>   [42,5]
03:58:06 <Zao> caxapok: In your snippet there, ... means "fill in the blanks"
03:58:10 <zygoloid> ^^ Zao perverse enough?
03:58:15 <ivanm> caxapok: why are you wanting to do this?
03:58:16 <dafis> caxapok: '.' is function composition
03:58:44 <Zao> zygoloid: You incorporated the ninja robot monkey operator. Well done.
03:59:10 <zygoloid> i thought mempty as \x -> [] was quite nice too :)
03:59:31 <wlangstroth> haskellites and their operators
03:59:37 <caxapok> ivanm:  i want make function Integer -> Integer, that return sum of digits
03:59:51 <ivanm> caxapok: why are you wanting to do this?
04:00:14 <SubStack> > sum [3,4,5]
04:00:14 <lambdabot>   12
04:00:15 <caxapok> ivanm: leraning haskell
04:00:21 <caxapok> *learning
04:00:31 <ivanm> I'm just wondering why you're wanting to learn Haskell in this way, that's all
04:00:32 <wlangstroth> caxapok: learnyouahaskell.com
04:00:38 <SubStack> > foldr1 (+) [3,4,5]
04:00:39 <lambdabot>   12
04:00:56 <caxapok> SubStack: ok. but how to 345 -> [3,4,5]?
04:01:16 <zygoloid> caxapok: well, you tell us a method and we can tell you how that method might be expressed in haskell
04:01:24 <dv-> > map digitToInt 123
04:01:24 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:01:25 <lambdabot>    arising from the literal ...
04:01:28 <ivanm> a few ways of doing it
04:01:36 <ivanm> you can keep dividing by 10
04:01:57 <ivanm> you can use a hack and convert it to a String and then convert each individual digit character in that string to a digit
04:02:16 <dv-> > map digitToInt (show 123)
04:02:17 <lambdabot>   [1,2,3]
04:02:48 <zygoloid> > map fromEnum $ showIntAtBase 10 toEnum 345 ""
04:02:48 <lambdabot>   [3,4,5]
04:03:10 <zygoloid> > map fromEnum $ showIntAtBase 16 toEnum 0xf00 ""
04:03:11 <lambdabot>   [15,0,0]
04:03:16 <jlouis> yay
04:03:26 <zygoloid> points for novelty? ;-)
04:03:37 <ivanm> or you could just use the digits library...
04:03:51 <caxapok> Thanx to all. I do it: sum ( map digitToInt ( show 123))
04:04:39 <zygoloid> > sumDigits 0 = 0; sumDigits n = m + sumDigits d where (d,m) = n `divMod` 10
04:04:40 <lambdabot>   <no location info>: parse error on input `='
04:04:51 <zygoloid> > let sumDigits 0 = 0; sumDigits n = m + sumDigits d where (d,m) = n `divMod` 10 in sumDigits 345
04:04:51 <lambdabot>   12
04:05:15 <wlangstroth> nice
04:05:21 <zygoloid> manually fused for your viewing pleasure ;-)
04:07:12 <caxapok> How to make n'th composition of function?
04:07:22 <caxapok> f(f(f(...)))
04:07:32 <soupdragon> caxapok, the first think I would do is define natural numbers like  data N = Z | S  N
04:07:40 <soupdragon> then define the fold for this data type
04:07:42 <soupdragon> do you know about folds?
04:10:10 <geheimdienst> caxapok, check out the function "iterate": file://localhost/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Prelude.html#v%3Aiterate
04:10:39 <caxapok> It's ok:  let nth f n = f (nth f (n-1))  ??
04:10:54 <bastl> can someone suggest a good template-haskell introduction which teaches me how to generate data types, instances and the like ?
04:10:57 <SubStack> > sin . sin . sin $ 1
04:10:58 <lambdabot>   0.6784304773607402
04:11:00 <pastorn> haskell.org is up!
04:11:04 <SubStack> > head $ drop 3 $ iterate sin 1
04:11:04 <lambdabot>   0.6784304773607402
04:11:07 <SubStack> that?
04:11:15 <zygoloid> @type \n -> execState . replicateM_ n . modify
04:11:15 <lambdabot> forall s. Int -> (s -> s) -> s -> s
04:11:21 <caxapok> SubStack: I want 'nth sin 3'
04:11:40 <zygoloid> > (\n -> execState . replicateM_ n . modify) 3 sin 1
04:11:41 <lambdabot>   0.6784304773607402
04:12:38 <caxapok> zygoloid: it's very hard for me (yet). Why nth f n = f (nth f (n-1)) don't work?
04:13:15 <SubStack> caxapok: you need a base case too
04:13:40 <caxapok> 'let nth f 1 = f; nth f n = f (nth f (n-1));' is error in ghci
04:13:54 <caxapok> Occurs check: cannot construct the infinite type: t = t1 -> t
04:15:05 <noteed> bastl: shamless plug: http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
04:15:17 <noteed> bastl: but it is very short, not all what you want
04:15:45 <bastl> short is good, once i get the main ideas, the API will help
04:16:07 <noteed> bastl: yes, that's what I thought to add
04:16:09 <robertmassaioli> pastorn: why, yes, yes it is. :) woot
04:16:14 <SubStack> caxapok: because to make that work, f would need to take as an argument its own type
04:17:32 <SubStack> > let nth f 1 = f; nth f n = nth (f . f) (n-1) in nth sin 3 $ 1
04:17:33 <lambdabot>   0.6275718320491591
04:18:02 <caxapok> SubStack: thanx
04:18:52 <pastorn> robertmassaioli: !!!
04:18:59 * pastorn goes and reads stuff
04:19:30 <caxapok> how to get nth element of list? not !!
04:20:55 <SubStack> caxapok: why not (!!)?
04:21:17 <geheimdienst> > [3,4,5] !! 1
04:21:18 <lambdabot>   4
04:21:23 <caxapok> map (\x iterate sd x !! 7) [1000,999..]
04:21:29 <caxapok>  parse error on input `!!'
04:21:47 <caxapok> oh. sorry ->
04:21:59 <caxapok> i'm idiot
04:29:42 <bastl> noteed: nice article, exactly what I needed.
04:30:52 <lgm> does anyone know if the monadic presentation of delimited continuations can be given a direct representation in terms of McBride's dissection?
04:31:20 <Axman6> robertmassaioli: G'day, thanks for signing up for AusHac :)
04:31:36 <ivanm> hey Axman6 
04:31:41 <Axman6> o/
04:31:42 <noteed> bastl: :)
04:31:51 <ivanm> yup another sucker^H^H^H^H^H^H attendee!
04:31:55 <ivanm> ;-)
04:32:16 <ivanm> Axman6: clem was about to get on your case until you put the assignment marks in this arvo ;-)
04:32:19 <caxapok> Problem: find number, that after 7th iteration of sumdigits return 1000 (oh, sorry 4 my english). What is most shorter solve?
04:32:33 <ivanm> caxapok: where are you getting these problems from?
04:32:34 <Axman6> oly half of them are done though
04:32:36 * ivanm guesses PE
04:33:37 <geheimdienst> is aushac referring to austria or australia?
04:33:46 <Axman6> the former
04:33:54 <caxapok> ivanm: it's my problem.
04:34:02 <Axman6> uh, latter
04:34:28 <ivanm> caxapok: you have actually written out problems for you to solve for yourself?
04:34:33 <geheimdienst> axman6, okay :-)
04:34:43 <alip> what does the exclamation mark in data MyData = MyData { color :: !String } mean?
04:34:49 <Zao> ivanm: After a few days of netbook, I keep trying to use the palmrest as touchpad.
04:34:52 <Zao> ivanm: Quite annoying :D
04:34:56 <ivanm> lol
04:34:59 <dafis> alip: It's a strict field
04:34:59 <caxapok> ivanm: I learning haskell and invent problems and find its most simple solve
04:35:02 <Zao> alip: It's a strictness annotation.
04:35:07 <ivanm> Zao: wrong channel though, isn't it? :p
04:35:13 <Zao> alip: The field is reduced to WHNF.
04:35:16 <Zao> ivanm: Most certainly.
04:35:37 <Zao> alip: That is, it's less lazy.
04:35:40 <ivanm> caxapok: I highly suggest you learn by going through tutorials instead
04:36:00 <ivanm> if you prefer learning whilst doing, then hack on a real problem whilst going through tutorials rather than toy problems like these
04:36:12 <caxapok> ivanm: It's too. For the problem i tried to combine sum, my sumdigits, map, iterate, but i don't get result.. help me please
04:36:36 <caxapok> ivanm: i like toy problems, haskell is hobby
04:36:36 <ivanm> well, seeing as how I have no idea what you're trying to do... ;-)
04:36:38 <Zao> Proper teaching resources put the fun in fundamentals.
04:37:00 <ivanm> Haskell is my hobby as well, and as part of it I get into arguments about maintaining backwards compatability... :/
04:40:24 <geheimdienst> @hoogle (a, b) -> (b, a)
04:40:24 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:40:24 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
04:40:24 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
04:40:37 <ivanm> preflex: seen Cale 
04:40:37 <preflex>  Cale was last seen on #haskell 1 day, 5 hours, 25 minutes and 47 seconds ago, saying: o hidden/exposed) where cabal would avoid installing a different version of that package automatically.
04:40:52 <ivanm> @type uncurry (flip (,)
04:40:53 <lambdabot> parse error (possibly incorrect indentation)
04:40:53 <ivanm> @type uncurry (flip (,))
04:40:54 <lambdabot> forall b a. (a, b) -> (b, a)
04:40:57 <ivanm> geheimdienst: ^^
04:41:05 <geheimdienst> :-o
04:41:08 <geheimdienst> duuude!
04:41:20 <ToRA> @type (snd &&& fst)
04:41:21 <ivanm> geheimdienst: there was a discussion about this a few months back ;-)
04:41:21 <lambdabot> forall a c. (a, c) -> (c, a)
04:41:32 <ivanm> ToRA: now you're just showing off ;-)
04:41:39 <ToRA> :p
04:41:55 <Starfire> :t flip flip
04:41:56 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
04:43:29 <geheimdienst> > flip (flip (42,3))
04:43:30 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
04:43:30 <lambdabot>         against inferred type `...
04:43:31 <ivanm> *groan* even flip is part of caleskell? :/
04:43:44 <ivanm> > flip flip (42, 3)
04:43:44 <lambdabot>   Overlapping instances for GHC.Show.Show (f ((t, t1) -> b) -> f b)
04:43:44 <lambdabot>    arisin...
04:43:47 <ivanm> bah
04:43:56 <ivanm> anyway, the functor there is (a,)
04:43:57 <geheimdienst> > flip flop (42,3)
04:43:58 <lambdabot>   Not in scope: `flop'
04:44:01 <geheimdienst> bah
04:44:06 <ivanm> > flip flip (42, 3) show
04:44:07 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:44:07 <lambdabot>         against inferred ty...
04:44:26 <ivanm> > flip flip 3 (2,show)
04:44:27 <lambdabot>   (2,"3")
04:44:32 <ivanm> there we are!
05:07:17 <alar> GHCi doesn't want to load my module with "import"
05:07:39 <alar> the file is "./Device/Cmd.hs"
05:07:56 <alar> the first line is "module Device.Cmd where"
05:08:15 <alar> ":l Device/Cmd.hs" works normally
05:08:20 <alar> what do I do wrong?
05:09:08 <ivanm> alar: ghci doesn't support the import command
05:09:14 <ivanm> use :m +Device.Cmd
05:09:26 <ivanm> (the + means it won't override whatever module you currently have loaded)
05:09:32 <alar> ivanm: :m + gives the same result
05:09:36 <dafis> ivanm: It does support import, just not qualified
05:09:50 <ivanm> alar: what's the error?
05:09:53 <alar> Prelude> :m + Device.Cmd
05:09:53 <alar> module `Device.Cmd' is not loaded
05:09:57 <zygoloid> Carnegie: warning: SubStack's nth is incorrect
05:10:10 <ivanm> alar: what does ":! pwd" say?
05:10:17 <zygoloid> caxapok: ... oh, you're gone.
05:10:20 <ivanm> is that the correct directory relative to your file?
05:10:20 <zygoloid> Carnegie: sorry :)
05:10:50 <alar> Prelude> :l Device/Cmd.hs
05:10:51 <alar> [1 of 1] Compiling Device.Cmd       ( Device\Cmd.hs, interpreted )
05:10:51 <alar> Ok, modules loaded: Device.Cmd.
05:11:17 <ivanm> alar: care to paste the file up somewhere?
05:11:26 <ivanm> alar: also, are there any .hi or .o files in Device/ ?
05:11:30 <ivanm> if so, try deleting them
05:11:48 <alar> no .hi, no .o
05:11:52 <alar> @where paste
05:11:52 <lambdabot> http://hpaste.org/new
05:12:06 <dafis> alar: does :l Device.Cmd work?
05:12:30 <alar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26041#a26041
05:12:35 <ivanm> dafis: doesn't load take a filename?
05:12:52 <ivanm> alar: remove the indentation before Module
05:12:53 <alar> yes, :l works
05:12:55 <ivanm> that mi ght help
05:13:00 <ivanm> (certainly can't hurt)
05:13:21 <ivanm> and I'm really hoping that that file was auto-generated for you ;-)
05:14:11 <alar> ivanm: yes,i've autogenerated it, and want to place it in separate directory to avoid mixing "normal" programs and autogenerated files
05:14:11 <ivanm> I wonder if you write a file and have it load if it'll work
05:14:21 <ivanm> alar: do you have anything currently loaded in ghci?
05:14:29 <dafis> ivanm: :load [*]<module> ...       load module(s) and their dependents should also work with qualified module names, I think
05:14:45 <ivanm> I'm thinking that it can't tell that it's meant to be loading it relative to the current directory
05:15:04 <ivanm> alar: might have more luck asking in #ghc about this
05:15:11 <alar> then why :l works?
05:15:44 <ivanm> because it's explicitly looking for a file
05:16:03 <dafis> alar, ivanm: maybe ghci does only invoke CPP with :l
05:16:57 <ivanm> dafis: nah, I don't think so
05:16:58 <alar> dafis: I wonder if importing Device.Cmd from other module will work if it doesn't work from GHCi
05:17:24 <ivanm> tried it with a non-CPP file; doesn't work there either
05:17:32 <ivanm> alar: I think so, if you then explicitly load that file
05:17:56 <ivanm> yeah, :m seems to be more for installed modules
05:18:14 <ivanm> I think that's why it doesn't work here ;-)
05:18:17 <markus3> hi! a question. i couldn't find on the net, that how could i test my programs performance, like timing and memory usage? i could switch timing "on" on the ghci, but then i have to look at all the generated output too. on the lists i have seen, that people test programs in the interpreter, and then it just gives out the time and memory used
05:18:46 <geheimdienst> markus3, you might be looking for the topic of profiling
05:18:59 <alar> yes, it is imported normally
05:19:06 <alar> tahnks to dafis and ivanm
05:19:51 <ivanm> markus3: you can enable GHC's profiling option, and you can also try using criterion to profile and compare specific algorithms
05:20:21 <markus3> criterion is a package?
05:20:27 <ivanm> yes
05:21:14 <markus3> ok, i'll go and see profiling and criterion then, thank you
05:22:48 <geheimdienst> you're welcome :-)
05:24:20 <Axman6> markus3: you don't use interpreters if you want to test performance
05:24:29 <Axman6> you compile your code
05:24:57 <markus3> but can't you make like "compiled modules" or something?
05:25:32 <ivanm> Axman6: yet another sucker! \o/
05:25:47 <Axman6> ivanm: yeah :) i think chak must've mentioned it to his class or something
05:25:52 <Axman6> TacticalGrace: you around?
05:25:54 <ivanm> markus3: ghci will use precompiled modules if they're available
05:25:55 <dafis> markus3: Sure, just compile them and load the compiled modules in ghci
05:26:07 <ivanm> but there's still a severe performance penalty
05:26:30 <ivanm> IIRC, you're looking at an order of magnitude slow down compared to compiling without any optimisations
05:26:47 <dafis> ivanm: not necessarily severe, for simple code it's close
05:27:08 <ivanm> true
05:27:15 <markus3> ok, but when I compile with profiling, then i just launch it somehow afterwards, and it'll just print me the statistics?
05:27:31 <Axman6> no
05:27:42 <ivanm> dafis: as an example, Axman6 and I were recently marking assignments where students had to implement a minimax algorithm for a game
05:27:46 <dafis> markus3: For profiling, you need an executable
05:27:50 <ivanm> those that did it within ghci ended up taking a while
05:27:56 <ivanm> those that compiled it ran almost instantly
05:28:13 <Axman6> and i'd walk away and come back later to mark them
05:28:17 <ivanm> admittedly, it wasn't the most impressive way of doing things (a lot of list manipulation, etc.) but still
05:28:25 <dafis> ivanm: I meant when you've compiled your modules (with -O2) and then load them in ghci
05:28:44 <ivanm> dafis: oh, right, if the Main module is rather small
05:29:02 <ivanm> markus3: you compile them with profiling support, run it with profiling enabled and then it creates a profile report file
05:29:27 <ivanm> note that compiling an executable with profiling support enabled makes it take twice as long to run even when you're not enabling the profiler
05:29:41 <dafis> ivanm: Or more
05:29:51 <ivanm> anyway, this is how I profile: ghc -O2 -prof -auto-all -caf-all --make Foo.hs
05:30:00 <ivanm> then run it as: ./Foo +RTS -p
05:30:11 <dafis> ivanm: I've had ByteString stuff take ~60 times as long with profiling than without
05:30:27 <ivanm> dafis: well, in my experience it's always been about x2, though I suppose there's no reason why it can't be even more ;-)
05:30:38 <ivanm> wow, profiled bytestrings are that bad? :o
05:31:28 <dafis> ivanm: generally, it's 1.5-3 times, but some things like ByteStrings use a *lot* of optimisations that can't be done with profiling
05:31:41 <markus3> ok
05:32:17 <ivanm> dafis: hmmm...
05:32:45 <ivanm> dafis: I know that the realisation that its slowed down even without +RTS -p was a shock to me; instantly my test suite only took an hour rather than two! :p
05:33:31 <markus3> ok, but istn't there a way to test functions from the interpreter, and give them different arguments? if i compile, then i'd have to hardcode some set of tests in there, so that it would execute when i execute them
05:33:42 <dafis> ivanm: Yes, actually collecting the statistics costs additional time
05:33:51 <petermarks> In the Cabal API, is there an easy way to load the ConfigFlags from the user's config file?
05:33:57 <ivanm> markus3: sure you can; there's just no reliable way to benchmark them then
05:34:10 <markus3> and when i want to try some other numbers, i'd have to recompile and stuff
05:34:17 <ivanm> dafis: right, even if you don't want the statistics, because of all the extra hooks put in
05:34:19 <dcoutts_> petermarks: no that's not handled by the Cabal lib
05:34:19 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
05:34:36 <dafis> markus3: If you compile your modules before loading them in ghci it's reasonable
05:34:49 <petermarks> :-(
05:34:49 <dcoutts_> petermarks: the ~/.cabal/config file is a feature of the cabal-install tool
05:34:51 <ivanm> markus3: that's why you write a good enough sample driver script that does enough calculations and hard enough calculations that its a reliable performance comparison
05:35:27 <dafis> markus3: Or pass the input as command line parameters
05:35:42 <petermarks> is the file in a "standard" format for which there is a parser?
05:36:12 <TacticalGrace> Axman6: hey
05:36:18 <Axman6> o/
05:36:26 <ivanm> TacticalGrace: we were wondering: were you promoting aushack to your students?
05:36:32 <ivanm> because we just had two sign-ups!
05:36:46 <TacticalGrace> I was, but already two weeks ago
05:36:54 <ivanm> Axman6: oh, did you ask ben r.e. names for wifi?
05:37:26 <dcoutts_> petermarks: the parsing is partly handled by the parser stuff in the Cabal lib
05:37:27 <Axman6> no, i haven't been able to get ahold of him
05:37:28 <TacticalGrace> ivanm: I talked with benl23 wifi a while ago
05:37:36 <dcoutts_> petermarks: what are you trying to do?
05:37:44 <TacticalGrace> but its probably best to email him abaout it again
05:37:50 <Axman6> ok
05:37:58 <TacticalGrace> but not much will be happening from our side before Tuesday
05:38:19 <petermarks> I'm trying to make Scion able to use packages from non standard locations.
05:38:19 <TacticalGrace> Haskell Symposium deadline is Monday/Tuesday night (Oz time)
05:39:04 <petermarks> we use our own package.cnf
05:39:32 <Axman6> ah, thanks for the heads up, i'll send him an email on wednesday then i guess
05:39:43 <petermarks> we make cabal install use the right stuff using the config file
05:40:32 <petermarks> thought the best route would be to get Scion to read the config file to get its settings
05:40:47 <dcoutts_> petermarks: you could just supply your own config file, or you could pass the command line args
05:40:52 <ivanm> TacticalGrace: right
05:41:04 <dcoutts_> petermarks: I don't guarantee that I will keep the config file format stable
05:41:52 <dcoutts_> petermarks: if you're calling the cabal-install prog from Scion, I'd just pass it the flags you want explicitly, and perhaps give it an empty/default config file
05:42:14 <petermarks> I can't pass any args on the command line as it is launched by the eclipsefp plugin and I don't want to start messing with Java code
05:42:39 <petermarks> It soesn't use cabal-install, it calls the cabal api
05:42:56 <petermarks> s/soesn't/doesn't/
05:43:49 <comb> hi. Let's say I have a data type like Either. I would like to generate a predicate for each constructor: ex, isLeft, isRight :: Either a b -> Bool. Is there an automated way to do that for arbitrary data types? (in my case I have *many* constructors)
05:43:56 <dcoutts_> petermarks: so you're trying to extract the setting from the config file to pass them to the eclipsefp plugin, which in turn calls the Cabal API.
05:44:25 <dcoutts_> petermarks: and you specifically want the user's config file, not just your own store of settings?
05:44:38 <petermarks> yes, I could use a separate config file, but I thought it would be neat to keep the settings in just one place
05:44:40 <ivanm> comb: you could possibly use something like TH to do it
05:45:17 <comb> ivanm: yes. I was looking for something like that. Is there anything already written?
05:45:19 <dcoutts_> petermarks: the problem will be compatibility, the ~/.cabal/config file is not a stable public API
05:45:43 <ivanm> comb: not sure; have a look through syb, etc.; they might have something
05:45:56 * ivanm -> land of nod
05:45:58 <ivanm> g'night all
05:46:24 <Axman6> o/
05:49:15 <dcoutts_> petermarks: if you decide you really want to do it anyway, just copy the code from cabal-install, but keep the consequences in mind
05:49:58 <petermarks> dcoutts_: actually, I could inject some command line arguments to the scion server by launching it from a batch file. Then I could alter the Scion code to allow the packagedb to be specified on the command line
05:50:45 <dcoutts_> petermarks: extending Scion to allow specifying multiple package dbs sounds like a good idea
05:50:57 <petermarks> is there some command line parsing code in the cabal api?
05:51:20 <petermarks> I thought I saw some somewhere
05:51:20 <dcoutts_> petermarks: yes
05:51:38 <dcoutts_> for example, cabal-install re-uses command line specs from the Cabal lib
05:52:03 <petermarks> k, I'll look at that. thx
05:52:27 <aristid> comonads don't seem to be that complicated
05:52:33 <aristid> why aren't they used more often? :)
05:52:51 * geheimdienst wonders if an underscore appended to the nick is the IRC equivalent of toilet paper stuck to one's shoe. geheimdienst wonders if you should say something in that case, or what ...
05:56:50 <dcoutts_> geheimdienst: :-)
06:01:11 <geheimdienst> aristid, well i'm a newbie and nowhere near the level of comonads and stuff, but my 2¢ are: the haddock for Control.Comonad is just a bunch of fluffy laws with no code examples. ⅓ the functions are undocumented and the rest have 1-line docs like "fmap defined in terms of extend" or "Calls a comonadic function in a modified context"
06:01:40 <geheimdienst> so it's not like comonads look very inviting, or it's made clear what they're good for
06:02:07 <geheimdienst> i mean, i'd try to fix the doc, but i have of course no clue about comonads ...
06:02:46 <aristid> geheimdienst: basically a comonad is a monad with all the function arrows flipped :)
06:03:26 <aristid> so join :: m (m a) -> m a becomes duplicate :: m a -> m (m a)
06:03:56 <aristid> and pure :: a -> m a (well, return in the case of monad, but that's a misnomer) becomes extract :: m a -> a
06:04:19 <aristid> geheimdienst: you should read typeclassopedia, wait a moment
06:04:54 <aristid> geheimdienst: http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf second article
06:05:16 <geheimdienst> woah thanks man, i'm looking at all that now
06:06:41 <lovinVer> hi
06:07:48 <robertmassaioli>  lovinVer hi?
06:11:47 <ddarius> geheimdienst: Reference documentation is not the place to make a case for using a library.
06:15:33 <geheimdienst> ddarius, then a link would be a good idea imho
06:23:55 <ddarius> geheimdienst: A link to what?
06:28:41 <madf> eagletmt: 
06:28:43 <madf> oops
06:29:00 <geheimdienst> ddarius: a link to code examples, showing what the library can do for you. many modules in xmonad-contrib have a section "usage". if you feel that's inappropriate to have in reference docs, a compromise could be to link to a blog post, -cafe announcement mail, or similar
06:29:14 <Phyx-> hrm.. 1-2secs... way too slow...
06:36:26 * geheimdienst 's preliminary finding about the matter is that the typeclassopedia is major-league awesome
06:37:01 <wlangstroth> typeclassopedia++
06:37:39 <wlangstroth> definitely
06:45:51 <aristid> i want to see a real use case of comonad :)
06:46:46 <BONUS> dan piponi has a bunch of them i think
06:46:48 <BONUS> http://blog.sigfpe.com/2008/03/comonadic-arrays.html
06:47:08 <geheimdienst> also, this is linked to from the typeclassopedia http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/
06:48:11 <aristid> thanks
06:54:14 <aristid> geheimdienst: your link does not work:(
06:54:33 <alip> is there a library function to expand tilde at the beginning of path to user's home directory?
06:54:36 <aristid> i think dan's article helped though
06:54:48 <Zao> aristid: Something in Directory maybe?
06:54:55 <dmwit> nope
06:55:05 <dmwit> You can call out to a particularly shell if you like.
06:55:25 <aristid> Zao: you mean alip?
06:55:27 <dmwit> ~ doesn't *actually* mean anything, in fact...
06:55:32 <Zao> Isn't there some friendly home directory retrieval functions somewhere?
06:55:45 <dmwit> Yes.
06:55:53 <Zao> Or query ${HOME} or %HOMEDRIVE%%HOMEPATH% for some pretense of portability.
06:55:59 <geheimdienst> aristid, strange, works for me. i made you a tinyurl http://tinyurl.com/6bctm2
06:56:05 <Zao> aristid: Likely.
06:56:14 <Zao> aristid: Typing more than one character before completing is a bit overrated.
06:57:31 <dmwit> getAppUserDataDirectory and its friends
06:58:25 <dmwit> But that is not the same as translating ~'s. To translate ~'s, you have to parse the entire path, plus do something about things like ~dmwit and ~Zao and stuff.
07:00:50 <aristid> geheimdienst: maybe the server was briefly down or something? now it works
07:01:13 <aristid> dmwit: i think doing that is an interesting exercise :)
07:01:43 <hpc> :t fmap fix return
07:01:43 <lambdabot> forall a. a -> a
07:02:03 <aristid> :t fix return
07:02:04 <hpc> > fmap fix return 2
07:02:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
07:02:04 <lambdabot>       Expected type: a
07:02:04 <lambdabot>       Inferred type: m a
07:02:05 <lambdabot>   2
07:02:14 <hpc> huh
07:02:15 <aristid> :t fmap fix
07:02:15 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
07:02:25 <hpc> it typechecks in ghci, but can't be evaluated
07:02:28 <aristid> :t fix . return
07:02:29 <lambdabot> forall a. a -> a
07:02:30 <Zao> User data is evil.
07:02:37 <Zao> Destroy the users instead.
07:02:39 <geheimdienst> dmwit, alip, i think the best bet is to call the shell and tell it to "compgen" (see bash manpage)
07:02:59 <Zao> geheimdienst: Assuming you _have_ such a shell.
07:03:02 <Zao> See Windows, others.
07:03:13 <Zao> Or have the rights to shell out at all.
07:03:33 <geheimdienst> yeah, but on windows, what would a path like "~" even mean ...
07:03:59 <Zao> geheimdienst: If you share configuration files, "home" would probably be a good approximation.
07:04:36 <Zao> or cry. I prefer it.
07:04:38 <fryguybob> geheimdienst: On windows powershell "cd ~" goes to user home folder.
07:05:20 <alip> i think I'll go with http://paste.pocoo.org/raw/223555/
07:06:16 <mreh> what can I use to parse a binary file?
07:06:21 <geheimdienst> sensible. however i don't think that can expand "~"
07:06:44 <Zao> Get?
07:07:17 <mreh> Parsec + ByteStrings?
07:08:20 <aristid> @src join
07:08:20 <lambdabot> join x =  x >>= id
07:08:27 <aristid> what i expected!
07:08:34 <aristid> :t join
07:08:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:08:42 <aristid> :t fmap
07:08:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:08:47 <aristid> :t liftM
07:08:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:09:05 <hpc> :t join
07:09:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:09:06 <aristid> :t (>>=)
07:09:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:09:17 <hpc> ooh, sneaky
07:10:06 <aristid> ok, i want to express (>>=) in terms of join and liftM and return
07:10:26 <aristid> (i'd use fmap if Monad was properly defined)
07:10:40 <aristid> but ... how to put the pieces together :D
07:11:44 <hpc> :t join . liftM
07:11:44 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
07:11:44 <lambdabot>     Probable cause: `liftM' is applied to too few arguments
07:11:44 <lambdabot>     In the second argument of `(.)', namely `liftM'
07:12:17 <hpc> :t join . liftM return
07:12:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
07:12:49 <hpc> you would apply (join . liftM return) to the continuation, then apply the m a to that
07:12:59 <hpc> er, wait
07:13:14 <hpc> :t join . liftM f
07:13:15 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Show a1, SimpleReflect.FromExpr (m a)) => m a1 -> m a
07:13:34 <aristid> :t \a -> liftM (return a)
07:13:35 <lambdabot> forall r a1 (m :: * -> *). (Monad m) => r -> m a1 -> m r
07:13:49 <hpc> (>>=) x f = (join . liftM f) x
07:13:51 <hpc> i think
07:13:58 <Olathe> Is there some way to get truncate without it rounding up at all ?
07:14:10 <hpc> :t \x f -> (join . liftM f) x
07:14:11 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> (a1 -> m a) -> m a
07:14:15 <Olathe> > floatDigits (undefined :: Double)
07:14:15 <lambdabot>   53
07:14:17 <aristid> :t \a b -> liftM (return a) b
07:14:18 <lambdabot> forall r a1 (m :: * -> *). (Monad m) => r -> m a1 -> m r
07:14:18 <hpc> there we go
07:14:40 <aristid> :t (=<<)
07:14:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:14:46 <aristid> :t join.liftM
07:14:46 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
07:14:47 <lambdabot>     Probable cause: `liftM' is applied to too few arguments
07:14:47 <lambdabot>     In the second argument of `(.)', namely `liftM'
07:15:01 <hpc> :t (join.liftM f)
07:15:01 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Show a1, SimpleReflect.FromExpr (m a)) => m a1 -> m a
07:15:14 <aristid> @pl \f -> join . liftM f
07:15:14 <lambdabot> (=<<)
07:15:21 <aristid> lol!
07:15:28 <hpc> if lambdabot didn't whine, join.liftM would probably be fmap
07:15:31 <aristid> hpc: you're right :)
07:15:39 <aristid> not about the fmap tho
07:15:43 <hpc> er, yeah
07:15:47 <aristid> lambdabot whines for a reason
07:16:03 <hpc> :t fmap f
07:16:04 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f) => f a -> f b
07:17:27 <aristid> :t (Prelude..)
07:17:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:17:34 <dafis> :t flip ((join .) . liftM)
07:17:35 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> (a1 -> m a) -> m a
07:17:47 <alpounet> where is the Generic typeclass defined ?
07:17:48 <dafis> aristid: ^^
07:17:51 <alpounet> @hoogle Generic
07:17:51 <lambdabot> Data.Generics.Aliases type Generic c = a -> c a
07:17:51 <lambdabot> Data.Generics.Aliases data Generic' c
07:17:51 <lambdabot> Data.Generics.Aliases Generic' :: Generic c -> Generic' c
07:17:56 <aristid> dafis: :)
07:18:52 <hpc> that was a fun little puzzle
07:20:02 <aristid> hpc: the cool thing about this is that Monads can be fully defined by fmap,pure and join
07:20:53 <aristid> and comonads by fmap,extract and duplicate
07:21:13 * hpc wishes the openGL bindings weren't a royal pain in the ass to install on windows
07:22:08 <benmachine> what's with the old haskell logo reappearing on haskell.org?
07:22:52 <markus3> a q about profiling: if i compile a program which traverses a list, but doesn't to anything with it (like print something of it out), then how is the appropriate way to force it to finish its action?
07:23:27 <Olathe> @hoogle rnf
07:23:27 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:23:27 <markus3> i don't want to get the length of it, because that effects the profilinng (at least i think it will)
07:23:39 <Olathe> markus3: Use rnf, I think.
07:24:27 <hpc> @src Strategy
07:24:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:24:44 <Olathe> markus3: http://bonsaicode.wordpress.com/2009/04/27/forcing-evaluation-in-haskell/
07:24:47 <lowasser> honestly, length won't do anything that rnf doesn't do
07:24:48 <markus3> ok, thx :)
07:25:10 <djahandarie> lol benmachine
07:25:16 <djahandarie> That'd pretty weird
07:25:19 <djahandarie> That's*
07:25:34 <markus3> lowasser: what do you mean?
07:25:39 <dafis> in fact, length will do far less, generally
07:25:53 <lowasser> yes, but it won't really do more
07:26:07 <J-roen> Is it possible to check if an instance of a certain class for a data type exists, for example by using something like a case expression?
07:26:08 <markus3> ok, but then how would be a good way to benchmark the list traversal?
07:26:10 <lowasser> length will force all of the conses, rnf will force the conses and the elements themselves
07:26:23 <lowasser> I think that length will do quite fine, actually
07:26:50 <lowasser> it shouldn't have any ill effects on benchmarking that I can think of, besides what you want it to do
07:26:56 <dafis> length, or last
07:27:01 <aristid> when talking about forcing... do you think an optimization map id -> id is safe?
07:27:27 <lowasser> I believe so
07:27:32 <lowasser> still thinking
07:27:55 <markus3> hmm, ok
07:27:57 <lowasser> :t foldl const
07:27:57 <lambdabot> forall a b. a -> [b] -> a
07:28:11 <aristid> :t foldr
07:28:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:28:13 <lowasser> :t foldl const ()
07:28:14 <lambdabot> forall b. [b] -> ()
07:28:16 <aristid> :t seq
07:28:17 <lambdabot> forall a t. a -> t -> t
07:28:24 <lowasser> no, we want foldl, I think
07:28:31 <aristid> :t foldl' (const ())
07:28:32 <Olathe> @type map id
07:28:32 <lowasser> we don't want to force list elements, we want to force the list thunks
07:28:32 <lambdabot>     Couldn't match expected type `b -> a' against inferred type `()'
07:28:32 <lambdabot>     In the first argument of `foldl'', namely `(const ())'
07:28:32 <lambdabot>     In the expression: foldl' (const ())
07:28:32 <lambdabot> forall a. [a] -> [a]
07:28:34 <lowasser> ffoldl does that
07:28:41 <aristid> :t foldl' const ()
07:28:42 <lambdabot> forall b. [b] -> ()
07:28:46 <lowasser> exactly
07:29:00 <benmachine> :t \xs -> foldr seq xs
07:29:01 <lambdabot> forall a b. b -> [a] -> b
07:29:02 <hpc> > foldr seq 0 [1,2,3]
07:29:03 <lambdabot>   0
07:29:10 <hpc> > foldr seq 0 [1,2,undefined]
07:29:11 <lambdabot>   *Exception: Prelude.undefined
07:29:16 <benmachine> :t \xs -> foldr seq xs xs
07:29:16 <lambdabot> forall a. [a] -> [a]
07:29:23 <hpc> > map id [1,2,undefined]
07:29:23 <lambdabot>   [1,2,*Exception: Prelude.undefined
07:29:30 <lowasser> benmachine, that forces the list elements
07:29:35 <lowasser> we just want to force the list thunks
07:29:40 <lowasser> foldl' const () would indeed do it
07:29:46 <Olathe> > id [1, 2, undefined]
07:29:47 <lambdabot>   [1,2,*Exception: Prelude.undefined
07:29:55 <lowasser> > foldl' const [1,2,undefined]
07:29:55 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [t])
07:29:55 <lambdabot>    arising from a use ...
07:29:59 <lowasser> oops
07:30:00 <aristid> lowasser: i think foldl' const () will be much better than length
07:30:06 <lowasser> > foldl' const () [1,2,undefined]
07:30:06 <lambdabot>   ()
07:30:10 <lowasser> good, good
07:30:13 <lowasser> let me check the Core output
07:30:15 <hpc> map id only breaks if the entire list is undefined
07:30:24 <benmachine> > foldl' const () (1 : 2 : undefined)
07:30:24 <lambdabot>   *Exception: Prelude.undefined
07:30:27 <lowasser> but id breaks in the same case
07:30:27 <hpc> whereas id would still be lazy with the whole list
07:30:35 <lowasser> no, id undefined = undefined
07:30:46 <lowasser> map id undefined = undefined
07:30:55 <aristid> map id [undefined] = undefined
07:30:57 <aristid> i think
07:31:03 <benmachine> no
07:31:05 <aristid> > map id [undefined]
07:31:06 <lambdabot>   [*Exception: Prelude.undefined
07:31:06 <Olathe> map id [undefined] = [undefined]
07:31:12 <aristid> oh
07:31:13 <hpc> wait, no lowasser is right
07:31:15 <benmachine> map id (undefined : []) = id undefined : []
07:31:18 <aristid> so map id = id totally
07:31:32 <aristid> why isn't map id = id a default ghc rule then?:)
07:31:44 <benmachine> it is isn't it?
07:31:46 <Olathe> aristid: Are you sure it isn't ?
07:31:50 <hpc> aristid: make it so!
07:31:52 <aristid> i was told it isn't iirc
07:32:00 <yitz> > map id [undefined] `seq` 42
07:32:01 <lambdabot>   42
07:32:02 <benmachine> foldr (:) id = id is
07:32:14 <yitz> so map id [undefined] /= undefined
07:32:14 <benmachine> and it may be that map f = foldr ((:) . f) []
07:32:15 <Olathe> I guess map id ensures the argument is a list.
07:32:17 <Olathe> :t id
07:32:18 <benmachine> er foldr (:) []
07:32:18 <lambdabot> forall a. a -> a
07:32:21 <Olathe> :t map id
07:32:22 <lambdabot> forall a. [a] -> [a]
07:32:33 <benmachine> Olathe: yeah but the typechecker takes care of that
07:32:36 <hpc> :t foldr (:) []
07:32:37 <lambdabot> forall a. [a] -> [a]
07:32:37 <Olathe> Sure :)
07:32:55 <benmachine> so does id :: [a] -> [a] anyway :P
07:33:34 * edwardk waves hello.
07:33:41 <edwardk> kmc: great talk the other day
07:33:57 <lowasser> actually, foldl' const () isn't quite as effective as actually coding it out, it would appear
07:34:05 <lowasser> force (x:xs) = force xs; force [] = ()
07:34:53 <hpc> isn't that how rnf is implemented for [a]?
07:35:24 <lowasser> nope
07:35:37 <lowasser> rnf for [a] is pretty much equivalent to foldr rnf ()
07:35:43 <lowasser> oops
07:35:46 <lowasser> foldr deepseq ()
07:35:46 <jmcarthur> anybody in here work for galois?
07:35:58 <jmcarthur> *in here currently
07:36:06 <jmcarthur> i know a few regulars do
07:36:07 <kmc> thanks edwardk
07:36:09 <lowasser> the whole point of rnf is to evaluate all of the elements, recursively
07:36:16 <lowasser> all of the substructures
07:36:29 <lowasser> so for lists, the list elements themselves get evaluated, which isn't the objective here
07:36:38 <hpc> ah
07:37:47 <lowasser> the only way to find middle ground between whrnf and rnf is to do it yourself
07:38:07 <aristid> lowasser: you could write a package.
07:38:20 <lowasser> hah, not for something that small
07:38:40 <lowasser> certainly not something that's a valuable and necessary lesson to figure out for yourself, either ;)
07:38:52 <hpc> haha
07:38:56 <djahandarie> I really wonder what's going on with haskell.org
07:39:30 <djahandarie> And hey edwardk & kmc, how'd the meet go?
07:39:40 <yitz> djahandarie: it's up. but still needs more cleanup work
07:39:47 <lowasser> yeah, I was wondering
07:39:50 <edwardk> djahandarie: i had a blast.
07:39:53 <aristid> "Derek Elkins is an active-duty Ariman in the United States Air Force"... not what i'd expected when reading a text about category theory, lol
07:40:09 <lowasser> I was having a little argument on the Language Shootout, needed a clarification, and haskell.org was down
07:40:27 <djahandarie> aristid, that is ddarius btw, in case you didn't know
07:40:35 <aristid> djahandarie: i didn't know
07:40:44 <edwardk> djahandarie: there were probably 18-20 of us over all. two good talks, lots of code. all good things.
07:41:37 <djahandarie> edwardk, cool. I ended up falling asleep at like 7pm though so it was probably a good thing that I didn't go heh
07:41:41 <lowasser> whoa, hey, I didn't know I did *that* well! http://shootout.alioth.debian.org/u64q/performance.php?test=revcomp
07:42:00 <edwardk> kmc's lambda calculus -> pi calculus compiler served as a nice finishing point for his talk, and nirav's SMT monad is surprisingly slick about recovering higher order sharing
07:42:14 <djahandarie> Are there any slides?
07:42:16 <yitz> lowasser++
07:42:29 <benmachine> lowasser: :O
07:42:33 <lowasser> and without using parallelism, no less
07:42:35 <edwardk> djahandarie: t0rch.org has kmc's slides
07:42:43 <edwardk> i don't think nirav's are online anywhere though
07:42:53 <edwardk> i'll ping him to see if i can get him to send them to the mailing list
07:43:06 <benmachine> lowasser: do you think it'd be even better with parallelism?
07:43:17 <benmachine> or would that be more trouble than it's worth
07:43:24 <yitz> SMT = flip STM ?
07:43:39 <lowasser> my tests indicated that it wasn't significantly better, because the problem doesn't parallelize much really, but I actually do have a parallelized version up my sleeve waiting for submission
07:43:53 <edwardk> yitz: 'satifsiability modulo theories' SAT solving with higher level info
07:44:01 <djahandarie> lowasser, nice job
07:44:01 <alpounet> where is the Generic typeclass defined ?
07:44:21 <mux> @index Generic
07:44:21 <lambdabot> Data.Generics.Aliases, Data.Generics
07:44:29 <mux> apparently there
07:44:30 <edwardk> er satisfiability
07:44:31 <yitz> edwardk: like strategies?
07:44:37 <alpounet> that's for the Generic *type* mux 
07:44:40 <alpounet> @hoogle Generic
07:44:40 <lambdabot> Data.Generics.Aliases type Generic c = a -> c a
07:44:40 <lambdabot> Data.Generics.Aliases data Generic' c
07:44:40 <lambdabot> Data.Generics.Aliases Generic' :: Generic c -> Generic' c
07:44:43 <alpounet> see
07:44:56 <lowasser> let me submit the parallelized version, 'cause the way the Shootout works, improving the first-place program even further can shuffle things up quite a bit =D
07:44:58 <mux> can you have a typeclass and a type of the same name? I thought not
07:45:07 <edwardk> yitz: like adding a theory of bit vectors, or the natural numbers, or undefined functions, etc.
07:45:22 <yitz> edwardk: ah ok
07:45:28 <mux> alpounet: it seems to really be in Data.Generics.Aliases ..
07:45:44 <mux> ah, wait, I misread again
07:46:07 <mux> hayoo finds Generic type-classes, but they seem totally unrelated
07:46:27 <alpounet> these are the ones I might be interested in
07:46:49 <alpounet> oh ok
07:46:53 <alpounet> i found the one i want
07:46:53 <djahandarie> kmc, what's the api flaw in threadDelay?
07:47:17 <kmc> djahandarie, google "2^31 microseconds in minutes"
07:47:30 <kmc> if you have a 32-bit machine you can only wait for ~ 35 min
07:47:33 <Olathe> > truncate ((853**5 - 1)**(1/5))
07:47:34 <lambdabot>   852
07:47:36 <Olathe> > truncate ((854**5 - 1)**(1/5))
07:47:37 <lambdabot>   854
07:47:37 <djahandarie> kmc, oh haha
07:47:46 <kmc> this is a bigger problem with the timeout example that comes later -- you can't give an action more than 35 min to complete!
07:47:59 <yitz> lowasser: that task actually sounds very parallel computationally, but IO-bound the way they have it set up.
07:48:04 <Olathe> How do I find out, for each root, when Doubles will start to become inexact ?
07:48:13 <djahandarie> kmc, I think I did forever (threadDelay maxBound :: Int) in my code somewhere
07:48:20 <lowasser> yitz: they only give you three sequences, actually
07:48:26 <kmc> ha
07:48:29 <kmc> btw the slides don't load in fancy slide-mode in Chromium
07:48:53 <yitz> lowasser: how long is each sequence?
07:48:53 <djahandarie> Oh, I was wondering why they weren't "slide"y
07:48:53 <lowasser> and you can't parallelize the actual reverse-complementing, which ends up being necessarily sequential
07:49:17 <lowasser> yitz: 25 million
07:54:11 <Olathe> > truncate ((99999999999999**6 - 1)**(1/6))
07:54:12 <lambdabot>   99999999999998
07:54:14 <Olathe> > truncate ((99999999999999**2 - 1)**(1/2))
07:54:15 <lambdabot>   99999999999999
07:54:27 <Olathe> How is the 6th root so much more precise ?
07:56:29 <djahandarie> Is there a way to work with monad transformers without needing to do lift and liftIO everywhere?
07:56:45 <hpc> djahandarie: i wish
07:57:04 <hpc> @hoogle IOT
07:57:04 <lambdabot> Data.Array.Diff data IOToDiffArray a i e
07:57:04 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
07:57:04 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
07:57:15 <benmachine> IOT doesn't make sense as an idea
07:57:20 <geheimdienst> use a cofree comonoidal confusing complication
07:57:35 <hpc> yeah, just making sure no one got the clever idea of implementing it
07:58:01 <hpc> geheimdienst: you mean, unlambda?
07:58:59 <yitz> lowasser: the trick is getting ca to stay in cache, isn't it?
07:59:18 <yitz> hpc: or lazyK
07:59:22 <lowasser> no, that's not hard
07:59:31 <hpc> @hoogle lazyK
07:59:31 <lambdabot> No results found
07:59:32 <lowasser> I mean, we only call revcomp a total of 3 times
07:59:49 <lowasser> we could afford to redo it entirely for every sequence
08:00:26 <kmc> djahandarie, by making all the monad primitives live in typeclasses
08:00:46 <kmc> class MonadIO m where { putStr :: String -> m (); getChar :: m Char }
08:00:47 <yitz> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
08:01:08 <kmc> class MonadNet m where { listenOn :: PortID -> m Socket }
08:01:17 <kmc> this has the advantage too that privileges are separated
08:01:54 <lowasser> the oddest thing is that
08:02:15 <lowasser> even though the input is read into a strict bytestring, -sstderr implies that the memory used by Haskell is smaller than the input itself
08:02:35 <lowasser> although the Shootout doesn't seem to agree
08:02:46 <kmc> possible it doesn't count bytestring's ForeignPtr-allocated memory?
08:03:07 <lowasser> or possible it makes the ForeignPtr point directly into the input, or something
08:03:21 <lowasser> although wait, no, your explanation is much more reasonable
08:04:14 <Silvah> :O
08:04:17 <Silvah> I don't belive.
08:04:40 <Silvah> I was right, we really ain't got no mtl since GHC 6.12...
08:05:13 <McManiaC> http://npaste.de/Wd/ <- whats wrong with that data definition?
08:06:05 <hpc> McManiaC: nothing that i can see; what does the compiler say?
08:06:16 <lowasser> the compiler message is on the bottom
08:06:21 <McManiaC> ooooh
08:06:34 <McManiaC> my own fault
08:06:35 <McManiaC> :D
08:06:44 <lowasser> wait
08:06:49 <lowasser> yeah,, I see it
08:06:57 <McManiaC> crossProduct should be a vector again
08:06:58 <lowasser> your cross product comes out as a scalar
08:06:59 <lowasser> yup
08:07:09 <McManiaC> cool
08:07:44 <Phyx-> @src perm
08:07:44 <lambdabot> Source not found.
08:07:46 <Phyx-> @src perms
08:07:46 <lambdabot> Source not found. I am sorry.
08:07:49 <jesusabdullah> dot product?
08:08:05 <benmachine> cross products can only be defined in three dimensions
08:08:10 <benmachine> and, like, seven, or something
08:08:20 <jesusabdullah> Isn't that strange?
08:08:33 * jesusabdullah & shcool
08:08:44 <lowasser> cross products can be defined in n dimensions, but they take n-1 arguments
08:08:54 <lowasser> corollary: it's only a binary operation in three dimensions
08:09:15 <hpc> the crossproduct is just the n-1 tensor that is normal to all the specified n tensors
08:09:20 <lowasser> yup
08:09:30 <hpc> or something; i might me misusing "tensor"
08:09:37 <quicksilver> good luck visualising the right-hand-rule in n dimensions to work out which way it points, though ;)
08:09:55 <quicksilver> last time I tried that I dislocated my thumb.
08:10:04 <McManiaC> well, good luck visualising *anything* in n dimensions ;)
08:10:37 <hpc> McManiaC: it isn't that hard; it is just the projection of n+1 dimensions :P
08:11:05 <lowasser> actually, I'm not getting any parallelism kicking in in that problem at all
08:13:20 <lowasser> wait, some
08:19:15 <djahandarie> kmc, oh wow, and once you do that all the other things like putStrLn come in automatically?
08:19:19 <lowasser> whoa, I should've expected it, but single-threaded wins by even more http://shootout.alioth.debian.org/u64/performance.php?test=revcomp
08:19:52 <djahandarie> lowasser, very nice
08:19:59 <gwern> > 10 * 4 * 60
08:20:00 <lambdabot>   2400
08:20:03 <lowasser> but I'm irritated that my parallelism isn't working
08:20:09 <lowasser> =P
08:21:09 <kmc> djahandarie, depends
08:21:12 <kmc> probably not
08:21:13 <kmc> hi ido
08:21:28 <djahandarie> Depends on what?
08:25:34 <yitz> lowasser: this whole thing is just IO-bound, isn't it? parallelism shouldn't have any significant effect.
08:26:05 <djahandarie> It'd be interesting to see what sort of improvements those programs would get with HEAD/LLVM
08:26:30 <Phyx-> grrrr why do the haskell docs links keep breaking
08:26:57 <monochrom> because the ghc versions keep changing
08:27:50 <monochrom> the bizarre bazaar mantra: release often, break often. :)
08:28:18 <Phyx-> monochrom: why not have a always stable link then?
08:28:49 <edwardk> kmc: still around?
08:28:51 <Phyx-> instead of /6.12.2/ won't work anyway when a new version comes out
08:28:52 <edwardk> @hpaste
08:28:52 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:29:28 <monochrom> because it breaks some other people's assumptions
08:29:31 <int-e> what happened to removing the parsec < 3 preference on hackage?
08:29:47 <edwardk> kmc: your pi calculus in finally tagless form (well, at least a finally tagless pretty printer) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26043#a26043
08:30:14 <Phyx-> monochrom: I would think that non-fustrated users is a bigger concern
08:30:23 <Phyx-> and hoogle breaking everytime a new ghc comes out
08:30:31 <lowasser> yitz: concurrency, then ;)
08:30:34 <edwardk> *Pi> pretty example -- "nu a. (nu b. (b<a>. 0 | b(c). c<b>. b(d). 0) | a(b). b<b>. 0)"
08:30:40 <Phyx-> and wiki pages that people rarely read having dead links
08:30:42 <lowasser> at a bare minimum, we can handle all three sequences separately
08:30:46 <lowasser> with separate threads
08:30:50 <monochrom> for example you link to "/latest/Data/Map/index.html". This assumes Data.Map always comes with GHC. Let's say one day GHC 7.8 decides to drop it.
08:30:50 <yitz> lowasser: how can it help?
08:31:12 <lowasser> the reversal is the time-intensive part, and that can be done in parallel once you've figured out where each of the streams begin and end
08:31:19 <lowasser> sequences
08:31:35 <lowasser> you break it into the subsequences, and run revcomp on each one in parallel
08:31:51 <lowasser> it works, 'cause I'm achieving a parallelism-based speedup now ;)
08:32:05 <Phyx-> monochrom: then the url will just report a 404, don't really see the problem, if it's not part of GHC anymoe it shouldn't be under ghc/docs/ anymore
08:32:39 <lowasser> ...maybe
08:34:07 <monochrom> I feel that you are biased. Let me counter-bias.
08:34:15 <yitz> lowasser: but don't you need to wait for seq n to finish outputting before you can start outputting seq n+1?
08:34:26 <lowasser> yes, but that's what MVars are for
08:34:45 <lowasser> yep, the speedup is definitely parallel
08:34:55 <monochrom> I don't use hoogle. I use other, static web pages. I don't see the problem with hoogle broken links. I see the problem with other, static webpages broken links.
08:35:18 <lowasser> you create an MVar and fork a thread to compute and store the reverse-complement for each sequence
08:35:29 <kolmodin> ssh to code.haskell.org is down?
08:35:32 <monochrom> To quote, "then the url [from hoogle] will just report a 404, don't really see the problem,"
08:35:36 <lowasser> then you just takeMVar on them one by one, and you get output in the correct order
08:35:37 <yitz> lowasser: so if the second thread just wait around for the MVar until the first completely finishes, how can having two threads help?
08:35:44 <yitz> s/wait/waits/
08:35:49 <lowasser> well, the second thread computes the reverse-complement in the meantime
08:35:57 <Phyx-> monochrom: right, i rarely use google aswell. But i do use the GHC documentation extensively. and I always have trouble with broken links and finding *where* the documentation of GHC.html is now
08:35:58 <lowasser> which is the time-intensive part of the program
08:36:10 <hpc> yitz: he makes all the treads first, then outputs them in order as they finish
08:36:21 <Phyx-> google/hoogle
08:36:27 <lowasser> one thread does the computation for each sequence
08:37:00 <yitz> lowasser: i though it's io-bound; waiting around for a chance to output the next character should be what limits this. it should be possible to do a simple lookup during that time, no?
08:37:17 <lowasser> the time-intensive part of the program is the call to reverse-complement
08:37:37 <lowasser> and we can do those in any order, we just have to do the *outputs* in order
08:37:49 <lowasser> so we do the reverse-complement work in parallel
08:38:12 <lowasser> I'm posting the current version
08:38:29 <lowasser> which is demonstrating something like a 15% speedup, which ain't much, but it's the result of parallelism
08:38:38 <yitz> lowasser: oh, don't you just do the complement one by one as you iterate through the buffer outputing in reverse order? there's not enough time for that?
08:39:04 <lowasser> not only is there not enough time, but it's considerably less efficient than doing it all in-place
08:39:35 <lowasser> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26044
08:40:04 <yitz> ok. in that case, you can even split up a single sequence and have separate threads doing different parts.
08:40:41 <lowasser> not exactly
08:40:57 <lowasser> it's necessarily sequential because of the approach I had to use
08:41:36 <yitz> are there effects from cores contending for memory access where you'll get better results by making sure that the parts of memory being accessed by the different cores are distant from each other?
08:41:50 <yitz> where "distant" is defined properly
08:41:58 <lowasser> I mean, they're not writing into overlapping pieces, they've each got their own little piece
08:42:23 <yitz> not just non-overlapping, distant
08:42:32 <lowasser> it'd be too expensive to fix in any event
08:42:50 <monochrom> as long as there is only one memory bus, there is only one distance.
08:43:10 <lowasser> this implementation essentially performs only two traversals of the entire ByteString, and copying a piece of the array for use by a thread locally would kill that
08:43:22 <yitz> monochrom: right, that's my question. do they play games with that architecture in multi-core?
08:43:58 <lowasser> I think they do, but I don't much care, either it's too expensive to fix myself, or the compiler is smart enough to recognize that the threads are working on separate pieces
08:44:01 <monochrom> In practice no.
08:44:06 <yitz> lowasser: no, just poke different parts of it originally into distant areas of memory during the first pass.
08:44:37 <lowasser> mmmm, still adds an irritating linear expense in return for a tiny bit of parallelism
08:44:38 <jmcarthur> dons: around?
08:44:53 <lowasser> besides, recall that this is improving on a program that's already in 1st place in the Shootout ;)
08:45:02 <lowasser> it's not that critical
08:46:01 <monochrom> The only commercially successful computer with better than single-memory-bus is Sparcs. It has something resembling telephone switching network for system bus.
08:46:47 <yitz> lowasser: i see that the c++ entry breathing down our necks is doing a lot more chunking
08:47:03 <lowasser> mmm, but I like that we're *not*
08:47:28 <lowasser> it's a very natural program
08:47:43 <lowasser> three times shorter
08:48:01 <lowasser> and in the single core case, 25% faster
08:49:22 <lowasser> tests on my computer seem to indicate that this parallelized version will be about 20% faster than the C++
08:50:09 <thaostra> which program are you referring to
08:50:49 <Olathe> > (4**6)**(1/6)
08:50:49 <lambdabot>   3.9999999999999996
08:50:59 <lowasser> thaostra: me>
08:50:59 <lowasser> ?
08:51:07 <thaostra> uhm yeah
08:51:18 <lowasser> lol
08:51:21 <zygoloid> > (4**6)**(1/6) :: CReal
08:51:22 <lambdabot>   4.0
08:51:30 <lowasser> http://shootout.alioth.debian.org/u64/performance.php?test=revcomp
08:51:31 <benmachine> lowasser: wait, does that make it slower than the single core version?
08:51:52 <jmcarthur> woah
08:51:57 <jmcarthur> we're number 1!
08:52:01 <lowasser> ...actually, it appears to be faster than the current single-core version
08:52:07 <jmcarthur> is it a new benchmark?
08:52:13 <lowasser> yup, it's my work
08:52:17 <jmcarthur> awesome
08:52:19 <lowasser> that I did instead of studying for exams <_<
08:52:23 <jmcarthur> heh
08:52:25 <benmachine> totally worth it
08:52:28 <lowasser> =D
08:52:36 <benmachine> wait, why does the one-core page have four numbers for cpu load?
08:52:53 <lowasser> because their system for enforcing single-core-ness isn't perfect, mostly
08:53:04 <benmachine> ah
08:53:06 <jmcarthur> more importantly, why does one of the runs have 150% cpu usage?
08:53:07 <lowasser> heck, it might be other programs' fault on their server
08:53:10 <jmcarthur> http://shootout.alioth.debian.org/u64/program.php?test=revcomp&lang=ghc&id=3
08:53:14 <thaostra> hm
08:53:18 <lowasser> that'd explain it
08:53:29 <zygoloid> is the computer language shootout secretly some computational geneticist harnessing the power of the internet to write and optimize his code for him?
08:53:39 <benmachine> weird that the lua version only uses 96% CPU
08:53:46 <quicksilver> it's a shame that lowasser's version isn't haskell.
08:53:46 <lowasser> if other programs on their server were running and got mistakenly added to the tally
08:53:53 <lowasser> quicksilver: *ouch!*
08:53:53 <quicksilver> but I guess you can't win them all ;)
08:53:57 <lowasser> but more importantly
08:54:07 <jmcarthur> i wish none of the benchmarks used Foreign or GHC.*
08:54:18 <lowasser> it would be written in natural Haskell, except that the Shootout doesn't have any libraries available
08:54:26 <lowasser> otherwise I'd be using the vector package up the wazoo
08:54:27 <thaostra> all benchmarks seem flawed in some way
08:54:32 <jmcarthur> yeah
08:54:49 <lowasser> hence, the need to openly use those nasty foreign bits.
08:54:59 <quicksilver> lowasser: it's not just that they're foreign
08:55:04 <quicksilver> Ptr is fine with me
08:55:07 <lowasser> it's also the C-like style?
08:55:08 <jmcarthur> i want to see a shootout spinnoff where programs are also rated according to how idomatic they are. it would require some honesty from each language community though
08:55:14 <quicksilver> it's that you have functions which are not functions.
08:55:14 <lowasser> yeah, I feel that too
08:55:19 <lowasser> wait, what?
08:55:24 <lowasser> oh, heh
08:55:24 <quicksilver> rw8 :: Ptr Word8 -> Int# -> Word#
08:55:29 <kmc> yikes
08:55:29 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
08:55:29 <quicksilver> that's not a function.
08:55:31 <lowasser> I think I eliminated that in my most recent revision =D
08:55:42 <quicksilver> it's an IO action pretending to be a function
08:55:43 <jmcarthur> wow
08:55:44 <benmachine> inlinePerformIO, eek
08:55:49 <lowasser> yeah, I got rid of that
08:56:09 <quicksilver> jmcarthur: honesty on the internet? where do you come up with these mad fantasies?
08:56:12 <lowasser> since it was only being used in IO-based computations, there's no reason it needs to return a pure value
08:56:57 <wli> Or how about some actual responding to inputs and little performance graphs like "for input N, runtime was T" and maybe (for parallel affairs) scaling charts ("input N on C cpus yielded runtime T") etc.?
08:57:35 <lowasser> okay, the hpaste now has an updated copy
08:57:47 <lowasser> I would never use unsafePerformIO myself
08:57:57 <lowasser> if it can't be done with runST, you're doing it wrong.
08:58:22 <lowasser> mind, sometimes I might hack my own inlineRunST, which is safe but might perform computations twice if misused
08:58:52 <jmcarthur> i use unsafePerformIO a lot :(
08:59:00 <jmcarthur> but it's for new pure primitives
08:59:04 <lowasser> heh
08:59:07 <Silvah> o.O
08:59:19 <lowasser> I have a confession
08:59:22 <Silvah> You're still alive?
08:59:32 <jmcarthur> Silvah: but badly burned
08:59:33 <lowasser> when I discovered how extensively GHC used unsafePerformIO internally, I felt betrayed
08:59:34 <kmc> there's no forkST unfortunately
08:59:42 <lowasser> kmc: that's true, but there is par
08:59:48 <jmcarthur> kmc: fortunately
09:00:02 <kmc> well yes it would be problematic to have
09:00:08 <jesusabdullah> Heh, I just figured out why cabal keeps asking me to cabal install cabal-install
09:00:14 * sclv is not so sure you can't have it?
09:00:17 <jesusabdullah> ~/.cabal/bin isn't in my path >_<
09:00:19 <jmcarthur> jesusabdullah: PATH?
09:00:21 <jmcarthur> heh
09:00:23 <jesusabdullah> exactly
09:00:31 <jesusabdullah> PFFSHT SHOULD BE AUTOMATIX
09:00:37 <lowasser> if you'd like to look at some very functionally written code that I'm rather proud of, check out http://hackage.haskell.org/package/rangemin
09:00:49 <kmc> how about forkST :: (forall s1. ST s1 a) -> ST s2 (ST s2 a)
09:00:56 <kmc> would there be an advantage over par and runST?
09:01:05 <lowasser> kmc: it'd be a Bad Idea
09:01:06 <jesusabdullah> Actually, I'd love to see some example code!
09:01:12 <kmc> why?
09:01:13 <jesusabdullah> ooh, that looks handy lowasser
09:01:21 <lowasser> race conditions result in nondeterminism
09:01:28 <zygoloid> why is k-nucleotide performance so terrible?
09:01:30 <lowasser> nondeterminism in a function that can be compiled down to pure things is bad
09:01:31 <kmc> not with the type i just provided
09:01:42 <Silvah> forkST?
09:01:52 <kmc> uses the same rank-2 trick as runST to keep state threads separate
09:02:06 <jmcarthur> kmc: but why not just use par then?
09:02:12 <kmc> well, that's what i'm asking
09:02:25 <kmc> i still like being able to specify computation by execution rather than evaluation, when that's what you want
09:02:29 <kmc> and that's what ST is for
09:02:37 <lowasser> zygoloid: mostly because the benchmark is bitchy and requires use of a hashtable, even if you're a functional language, but on the 64-bit quad-core Haskell does much better http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc 
09:02:38 <jmcarthur> kmc: that function doesn't allow the threads to share data anyway, so you might as well just use runST and par
09:02:47 <Phyx-> man, having typechecking as you type rocks
09:02:48 <Phyx-> lol
09:02:50 <lowasser> but more importantly, you still have race conditions
09:03:01 <lowasser> imagine forking two threads which both continuously write into an STRef
09:03:02 <thaostra> so lowasser, all the benchmarks at http://shootout.alioth.debian.org/u64/performance.php?test=revcomp compare different languages doing the same task?
09:03:03 <kmc> one thing i am asking is whether that forkST could have better performance than runST and par
09:03:09 <jesusabdullah> typechecking as you type?
09:03:10 <lowasser> thaostra: yes
09:03:14 <jesusabdullah> Sounds like a Yo Dawg joke
09:03:16 <lowasser> and then reading off that STRef
09:03:17 <jmcarthur> i very much doubt it
09:03:19 <lowasser> and returning that value
09:03:23 <lowasser> that's nondeterministic
09:03:24 <lowasser> unavoidable
09:03:37 <jmcarthur> lowasser: kmc'
09:03:40 <jmcarthur> dang
09:03:46 <lowasser> guaranteeing that it has the same state type variable is irrelevant
09:03:50 <jmcarthur> lowasser: kmc's function doesn't allow the threads to share STRefs
09:03:55 <thaostra> so yours is almost 3 times shorter than the c++ version but was still faster despite it using templates
09:04:03 <lowasser> thaostra: exactly.  ;)
09:04:07 <lowasser> sure it does, within the overall ST thread
09:04:08 <lowasser> one moment
09:04:10 <jmcarthur> lowasser: it's effectively just par and runST
09:04:15 <quicksilver> isn't a better question than asking if we can have a forkST, asking if we can run STM actions without IO?
09:04:18 <thaostra> that's actually pretty good
09:04:20 <lowasser> holdon
09:04:25 * Silvah thinks how to improve the C++ version
09:04:27 <quicksilver> STM seems a better-defined notion of pure concurrency
09:04:41 <lowasser> um.  jmcarthur is right
09:04:59 <Silvah> Hahahahaha.
09:05:18 <thaostra> however, i do notice that it still isn't the shortest, namely compared to those like ruby and python
09:05:34 <lowasser> thaostra: it's not designed to be used as an imperative language
09:05:43 <jmcarthur> quicksilver: if you can specify in what order the transactions should (appear to) be applied, it's probably okay to use in pure code (ignoring ghc's implementation disliking nested calls to atomically)
09:05:47 <lowasser> although yes, I'm still trying to shorten it without losing the efficiency
09:05:54 <jmcarthur> quicksilver: that's my hypothesis, anyway
09:06:01 <lowasser> also, I'm a fan of having multiple concurrency abstractions as a general rule
09:06:11 <thaostra> well, not really true for ruby and python either
09:06:25 <lowasser> thaostra: I have to do a super ugly workaround just to duplicate the functionality of "i++"
09:06:26 <jesusabdullah> man pandoc is awesome o_o
09:06:29 <jesusabdullah> <3
09:06:46 <thaostra> uhm okay
09:06:51 <jesusabdullah> It is!
09:07:37 <lowasser> look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26044, and the code for revcomp
09:07:59 <monochrom> I disagree. All attempts of adding clutches and clutches to plain text file, such as pandoc, are misguided.
09:08:13 <jesusabdullah> clutches?
09:08:16 <lowasser> rc is essentially equivalent to if x == '\n' i++;
09:08:18 <thaostra> well, at least i get to see my favorite language, ruby, have one of the shortest entries. 
09:08:23 <lowasser> rc1 is equivalent to the same thing except j--
09:08:34 <jesusabdullah> You mean, conversions?
09:08:45 <monochrom> I mean escape codes.
09:08:50 <lowasser> also, my code would be shorter if I had access to Haskell Platform libraries
09:09:06 <jesusabdullah> monochrom: explain? I'm feeling dumb this morning.
09:09:10 <thaostra> how small do you think you can get it lowasser
09:09:23 <lowasser> maintaining the same performance, too?
09:09:39 <djahandarie> Why doesn't shootout just use the platform libraries? They are pretty much standard for everyone who wants haskell
09:09:40 <thaostra> well, cpu cycles are cheaper than developer time, but sure
09:09:51 <lowasser> I mean, if I can sacrifice performance, I could do something much smaller
09:10:02 <lowasser> one moment, then, please.
09:10:07 <monochrom> I don't know or care the details of pandoc, but there are always things like: 'a' stands for 'a', 'b' stands for 'b'... so far so good, but oh '[' no longer stands for '[', you have to say '\[' because '[' is hijacked for some other semantics...
09:10:37 <monochrom> And you don't see this problem because:
09:10:43 <monochrom> @quote 1970s.terminals
09:10:43 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
09:10:53 <djahandarie> lol
09:10:55 <benmachine> monochrom: sometimes it's hard to do exactly what you want but it's almost always nearly fine
09:11:08 <monochrom> And because the problem is so pervasive that programmers stop noticing it.
09:11:11 <benmachine> I like pandoc for making easy things easy
09:11:17 <zygoloid> kmc: that forkST looks a lot like a Futures library for ST. I like it...
09:11:30 <kmc> that's the idea zygoloid
09:11:37 <jesusabdullah> monochrom: That sounds more like a problem with markup languages and less a problem with pandoc in particular
09:11:44 <kmc> but futures for pure computation are what we already have with laziness and par
09:11:55 <kmc> so i'm not sure there's a benefit to another construct
09:12:16 <zygoloid> to be honest i can't think of a better implementation than par and runST... :)
09:12:20 <monochrom> Yes, all markup languages should die. Clutches added on plain text file. Why plain text file? Again, because 1970s etc.
09:12:34 <petermarks> how do I get the GHC API to use a custom package.conf and the global one to find its packages? In http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/GHC.html#t%3ADynFlags there is SystemPackageConfig, but contrary the comment, it only takes a single FilePath.
09:12:43 <thaostra> sounds like some sort of ultimatum
09:12:43 <jesusabdullah> but all I really did was feed pandoc an html file and say, -w plain
09:12:57 <jesusabdullah> monochrom: What would you suggest as an alternative?
09:12:58 <zygoloid> monochrom: i think there's something to be said for being able to edit various types of file in the same editor
09:13:32 <zygoloid> (that's basically the reason i don't like the idea of visual languages and editors)
09:13:40 <jesusabdullah> I'm just thinking, if word's the alternative I'd rather stick with my \{{[\{}[]]}}ness
09:13:57 <zygoloid> i think epigram takes an interesting approach here
09:14:06 <monochrom> I suggest editing syntax trees.
09:14:09 <Silvah> ;(
09:14:27 <zygoloid> monochrom: can i do that in vim? and if so, is that not a markup language?
09:14:31 <thaostra> html, tex..they should all die?
09:14:39 <kmc> tex is an awful language
09:14:59 <thaostra> enlighten me, kmc
09:14:59 <kmc> people love it because the implementation is virtually bug-free and produces beautiful output
09:15:13 <jesusabdullah> I'll agree with you kmc
09:15:24 <kmc> and in practice this is much more important
09:15:24 <jesusabdullah> XD
09:15:30 <kmc> than whether the language has decent syntax and semantics
09:15:45 <zygoloid> tex is very effective and quite pragmatic, and has a proven track record
09:15:51 <mreh> @src Parser
09:15:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:15:52 <monochrom> to "prefer markups because MSWord is horrible" is like to "prefer untyped because C++ is horrible"
09:15:57 <thaostra> damn them and their eye practical things
09:15:58 <BONUS> except for not being able to place figures *right here*
09:16:08 <BONUS> i hate that about tex
09:16:09 <Phyx-> is there a way to write "(\(a,b) (c,d)->(a+c,b++d))" using arrows?
09:16:24 <zygoloid> BONUS: *shrug* i find that a nightmare in Word and OpenOffice too fwiw
09:16:28 <mreh> (+) *** (++)
09:16:29 <thaostra> well, in some cases WYSIWYM is just better than WYSISWY
09:16:34 <jesusabdullah> monochrom: Maybe, but you still have to explain and sell any alternative ideas if that's all your audience knows
09:16:35 <BONUS> Phyx-: curry $ (+) *** (++)
09:16:40 <BONUS> :t curry $ (+) *** (++)
09:16:41 <lambdabot> forall a b. (Num a, Monoid b) => a -> b -> (a -> a, b -> b)
09:16:42 <thaostra> *WYSIWYG
09:16:51 <jesusabdullah> what's the triple star?
09:17:02 <jesusabdullah> o_o
09:17:04 <zygoloid> @type curry $ uncurry (+) *** uncurry (++)
09:17:05 <lambdabot> forall a a1. (Num a, Monoid a1) => (a, a) -> (a1, a1) -> (a, a1)
09:17:08 <BONUS> zygoloid: yeah those suck at it as well
09:17:16 <monochrom> I don't have to sell. I have no audience anyway.
09:17:22 <quicksilver> the problem with smart editors (like syntax tree editors) is they have *such* a long way to go before they can catch up with text/markup formats
09:17:23 <Phyx-> zygoloid: ah, thanks :)
09:17:38 <mreh> jesusabdullah, it's in Control.Arrow
09:17:43 <Phyx-> doesn't look much nicer than just writing it out though :(
09:17:43 <zygoloid> Phyx-: that's not what you asked for, though.
09:17:47 <quicksilver> the structured editing I can do with editor features, regexp replace, and shell pipelines are really powerful. You'd have to re-invent all that .
09:17:55 <Phyx-> zygoloid: ah indeed
09:17:58 <quicksilver> s/the problem/a problem/;
09:18:04 <mreh> it takes two arrows and runs them in parallel
09:18:07 <jesusabdullah> mreh: I thought you were talking about not-markup document writing for a second <_>
09:18:07 <mreh> :t (***)
09:18:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:18:16 <Phyx-> the ones from BONUS and mreh didn't have the correct type either, tried those already
09:18:16 <jesusabdullah> oh lawdy
09:18:24 <jesusabdullah> someday I'll understand that!
09:18:26 <jesusabdullah> SOMEDAY
09:18:26 <mreh> yeah, mine was rubbish sorry
09:18:39 <BONUS> ah wait
09:18:40 <jesusabdullah> (fuck you 8:00am)
09:18:40 <BONUS> try
09:18:43 <mtnviewmark> :t let mu = (+) *** (++) in (3,"hello") `mu` (4, " world")
09:18:44 <lambdabot>     Couldn't match expected type `(t1, [Char]) -> t'
09:18:44 <lambdabot>            against inferred type `(t2 -> t2, [Char] -> [Char])'
09:18:44 <lambdabot>     In the expression: (3, "hello") `mu` (4, " world")
09:18:48 <mtnviewmark> so, that's not it
09:18:50 <BONUS> curry $ uncurry (+) *** uncurry (++)
09:18:54 <Phyx-> mreh: nah, it was also the first thing i tried
09:19:06 <BONUS> > curry (uncurry (+) *** uncurry (++)) (1,2) ("1","2")
09:19:07 <lambdabot>   (3,"12")
09:19:08 <mtnviewmark> really? uncurry it? 
09:19:21 <Phyx-> :t  curry $ uncurry (+) *** uncurry (++)
09:19:21 <lambdabot> forall a a1. (Num a, Monoid a1) => (a, a) -> (a1, a1) -> (a, a1)
09:19:26 <jesusabdullah> you can uncurry adding?
09:19:28 <Phyx-> not the right types
09:19:34 <jesusabdullah> :t uncurry (+)
09:19:34 <benmachine> :t uncurry (+)
09:19:35 <lambdabot> forall a. (Num a) => (a, a) -> a
09:19:35 <lambdabot> forall a. (Num a) => (a, a) -> a
09:19:38 <Silvah> O.O
09:19:38 <benmachine> heh
09:19:40 <Silvah> O.O
09:19:41 <djahandarie> jesusabdullah, its the same as any other function
09:19:46 <mreh> @pl (\(a,b) (c,d) -> (a+c,b++d))
09:19:46 <Silvah> Driewerf O.O!
09:19:46 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (+))
09:19:54 <BONUS> Phyx-: which type are you looking for
09:19:57 <djahandarie> Heh
09:20:00 <illissius> rofl
09:20:01 <mtnviewmark> @hoogle (a -> a -> a) -> (b -> b -> b) -> (a, b) -> (a, b) -> (a, b)
09:20:01 <lambdabot> No results found
09:20:11 <BONUS> lambdabot has Caleskell so ++ is mappend instead of the usual ++
09:20:20 <jesusabdullah> > uncurry (+)
09:20:21 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, a) -> a)
09:20:21 <lambdabot>    arising from a use...
09:20:23 <Phyx-> BONUS: Num a => (a, [b]) -> (a, [b]) -> (a, [b])
09:20:26 <jesusabdullah> damn!
09:20:35 <Silvah> That's impossible!
09:20:35 <Phyx-> was just wodnering if there was a nice way of writting it in arrows
09:20:38 <djahandarie> jesusabdullah, eh? It worked just fine
09:20:51 <BONUS> oooh you want a+c and b+d
09:20:56 <Phyx-> yeah
09:20:56 <djahandarie> Just the instances for functions are messed up in Haskell
09:21:02 <BONUS> sorry i thought you wanted a+b and c++d
09:21:05 <benmachine> pl doesn't know about arrows
09:21:17 <djahandarie> Phyx-, you wrote it wrong when you asked :P
09:21:17 <mtnviewmark> wait
09:21:23 <Phyx-> i did?
09:21:44 <Phyx-> :t (\(a,b) (c,d)->(a+c,b++d))
09:21:44 <djahandarie> < Phyx-> is there a way to write "(\(a,b) (c,d)->(a+c,b++d))" using arrows?
09:21:44 <lambdabot> forall t t1. (Num t, Monoid t1) => (t, t1) -> (t, t1) -> (t, t1)
09:21:54 <Phyx-> djahandarie: right, which is correct
09:21:57 <mtnviewmark> :t (+) *** (++) $ (3, "hello")
09:21:57 <lambdabot> forall b. (Num b) => (b -> b, [Char] -> [Char])
09:22:01 <lowasser> Still there, thaostra?
09:22:11 <djahandarie> What?
09:22:14 * djahandarie is confused
09:22:20 <jesusabdullah> I think my problem is that currying is partial application, right? So what's (+) partially applied to?
09:22:23 <mtnviewmark> :t (+) *** (++) $ (3, "hello") (4, " world") 
09:22:24 <lambdabot>     Couldn't match expected type `t -> (b, b')'
09:22:24 <lambdabot>            against inferred type `(t1, [Char])'
09:22:24 <lambdabot>     In the second argument of `($)', namely
09:22:26 <Silvah> Rewriting the shiny foldM as ugly explicit recursion resulted in 40% faster program, o.O...
09:22:27 <jesusabdullah> or, I mean
09:22:35 <Phyx-> djahandarie: it's adding the first component of the tuples and the second component of each tuple
09:22:45 <zygoloid> jesusabdullah: currying is not partial application.
09:22:47 <BONUS> jesusabdullah: uncurry takes a function like a -> b -> c and turns it into (a,b) -> c
09:22:58 <mtnviewmark> @hoogle (a -> b, c -> d) -> (a, c) -> (b, d)
09:22:58 <lambdabot> No results found
09:23:06 <jesusabdullah> Oh, makes it take a tuple?
09:23:13 <BONUS> so if you curry (+), which is Num a => a -> a -> a, you get a function (a,a) -> a
09:23:16 <thaostra> yes i am here, just not paying attention to boring math-speak =P
09:23:18 <jesusabdullah> oh, awesome
09:23:32 <mtnviewmark> isn't there away to apply a tuple of functions to a tuple of args in Arrow?
09:23:39 <mreh> The Parser type in Text.Parsec.LazyByteString has no parameterised type
09:23:42 <jesusabdullah> That's rather nifty
09:23:42 <byorgey> Phyx-: mtnviewmark gave the answer abov, (+) *** (++)
09:23:46 <lowasser> I have a short but somewhat inefficient implementation
09:23:52 <lowasser> I think it's technically linear time
09:23:59 <jesusabdullah> BONUS: thanks!
09:24:10 <lowasser> I've tested it
09:24:17 <lowasser> behold! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26046
09:24:17 <benmachine> BONUS: uncurry, surely
09:24:18 <thaostra> gist/pastebin?
09:24:19 <byorgey> mtnviewmark: not unless you make an Arrow instance for tuples of functions
09:24:21 <mtnviewmark> byorgey - but how do you apply that to two tuples? with all that curry/uncurry? 
09:24:25 <mtnviewmark> there has got to be a better way
09:24:27 <Phyx-> byorgey: how so? that returns a tuple of functions
09:24:44 <BONUS> benmachine: shirley! my mistake
09:24:44 <jesusabdullah> You could make it THAI currying!
09:24:46 <thaostra> hm how many bytes would that take up
09:24:49 <jesusabdullah> :9
09:24:52 <byorgey> oh, silly me, I read the question wrong
09:24:54 <jesusabdullah> (oh like you haven't heard that one before)
09:24:56 <zygoloid> jesusabdullah: BONUS is talking about uncurrying. currying is converting a function taking a tuple of arguments into a function which takes the first argument adn returns a function which takes the second and ...
09:25:04 <lowasser> the Shootout uses a nonstandard code size scoring mechanism
09:25:09 <benmachine> BONUS: that's okay, just stop calling me shirley
09:25:15 <lowasser> http://shootout.alioth.debian.org/help.php#gzbytes
09:25:23 <zygoloid> jesusabdullah: so curry :: ((a, b) -> c) -> (a -> b -> c)
09:25:33 <mtnviewmark> :let pairAp = \(f, g) (a, b) -> (f a, g b) in  ((+) *** (++)) (3, "hello") `pairAp` (4, " world")
09:25:42 <jesusabdullah> zygoloid: Oh, okay. Cool, I now understand currying better!
09:25:53 <jesusabdullah> \o/ +1
09:26:20 <byorgey> yeah, there's really not any very good way to do that
09:26:34 <Phyx-> yeah, starting to think that too
09:26:43 <byorgey> you want to treat a tuple of functions as a function-like thing, which isn't a very Arrowy thing to do
09:26:50 <byorgey> it's more of an Applicativey sort of thing
09:27:10 <edwardk> preflex: xseen kmc
09:27:10 <preflex>  kmc was last seen on freenode/#haskell 11 minutes and 40 seconds ago, saying: than whether the language has decent syntax and semantics
09:27:14 <lowasser> thaostra: I just sent up a faster but just as short version
09:27:21 <Saizan> unless you make an appropriate Arrow instance, i guess
09:27:28 <byorgey> but you won't be able to use an Applicative instance either, unless the tuples have both elements of the same type
09:27:35 <thaostra> oka
09:27:36 <thaostra> y
09:27:39 <mtnviewmark> : let pairAp = \(f, g) (a, b) -> (f a, g b) in  ((+) *** (++)) (3, "hello") `pairAp` (4, " world")
09:27:41 <Phyx-> :(
09:27:50 <Phyx-> guess i'll just write it out
09:27:54 <byorgey> Saizan: that doesn't really help, since the Arrow class has no "apply" method
09:27:55 <edwardk> kmc: http://www.haskell.org/pipermail/haskell-cafe/2010-June/078750.html
09:28:27 <alexyk> is there a library way to setup a record for optional parameters with defaults?
09:28:37 <illissius> http://haskell.pastebin.com/CvebudWN <- can someone explain to me what this means? I sort of understand what it's saying, but not why.
09:28:43 <geheimdienst> come to think of it: why is it called "curry"? i always thought currying means nailing down one argument of a function, giving you a new function with one less argument. i mean, what's it have to do with tuples?
09:28:50 <mtnviewmark> > let pairAp = \(f, g) (a, b) -> (f a, g b) in  ((+) *** (++)) (3, "hello") `pairAp` (4, " world")
09:28:51 <lambdabot>   (7,"hello world")
09:29:07 <zygoloid> @type \xs -> ($ fst xs) *** ($ snd xs)
09:29:08 <lambdabot> forall b a b1 b2. (a, b1) -> (a -> b, b1 -> b2) -> (b, b2)
09:29:14 <sclv> geheimdienst: that's partial application
09:29:15 <benmachine> geheimdienst: taking f (a,b) = c to f a b = c allows you to curry f
09:29:17 <byorgey> geheimdienst: that's partial application
09:29:20 <benmachine> partially apply f
09:29:27 <aristid> :t (+++)
09:29:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
09:29:28 <benmachine> you can't do it if f takes a tuple
09:29:41 <byorgey> geheimdienst: currying means representing a function of two arguments as a function of one argument which returns a function
09:29:45 <edwardk> alexyk: i've been leaning towards something like having a class Options t where options :: t -- provides the default version then you just define data MyMethodOptions = MyMethodOptions { foo :: Int }; instance Options MyMethodOptions where ... 
09:29:50 <byorgey> but of course, that enables partial application
09:30:07 <alexyk> /me associates currying with trying to slurp spicy curry and dropping the (tail) pieces
09:30:09 <edwardk> alexyk: but there isn't such a construct in a library anywhere that i know of
09:30:32 <lowasser> okay, dammit, I need to finish this paper, bye all
09:30:42 <zygoloid> @type liftA2 (***) (flip ($) . fst) (flip ($) . snd)
09:30:42 <lambdabot> forall c c' a b. (a, b) -> (a -> c, b -> c') -> (c, c')
09:30:43 <kmc> i use the word "curry" to mean a particular convention for how to encode functions of multiple arguments in languages that don't have this feature built in
09:30:50 <kmc> as well as the combinator "curry" in Haskell
09:30:57 <kmc> which takes you from a different convention to that convention
09:30:58 <sclv> edwardk: ndm wrote a blog post on that technique like a year and a half ago
09:30:59 <alexyk> edwardk: where do I do the defaults?
09:31:13 <Saizan> illissius: it can't tell which type you want to use for "hack" in the call to objects', because you don't use hack in objects' signature at all
09:31:14 <sclv> but yeah I don't know of a hackage package that just proves that class
09:31:27 <alexyk> sclv: link?
09:31:30 <zygoloid> @type liftA2 (***) fst snd
09:31:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
09:31:31 <byorgey> edwardk: yes there is, in the 'data-default' package
09:31:31 <kmc> Haskell has currying as the "default" convention, but all that means is the syntax encourages it
09:31:38 <geheimdienst> yes, i know it can be called partial application, i just thought partial application is roughly synonymous with currying
09:31:38 <edwardk> byorgey: nice
09:31:40 * geheimdienst shrugs
09:31:42 <thaostra> lowasser, not bad 
09:31:42 <illissius> hmm.
09:31:42 <kmc> (and the standard libs)
09:31:47 <edwardk> sclv: ahh missed it
09:31:59 <sclv> haha, there's a package for that!
09:32:09 <sclv> like the apple slogan
09:32:17 <zygoloid> @type liftA2 (***) fst snd :: (a -> b, c -> d) -> (a, c) -> (b, d)
09:32:17 <lambdabot> forall a b c d. (a -> b, c -> d) -> (a, c) -> (b, d)
09:32:18 <kmc> is it "partial application" whenever the result of an application is another function?
09:32:29 <edwardk> sclv: solved the ad problems i was having at hac-phi
09:32:37 <kmc> or only when the result is another lambda term after a single beta reduction?
09:32:45 <sclv> edwardk: i saw. template haskell to the rescue
09:32:47 <edwardk> sclv: as usual there is a use for a cofree comonad ;)
09:32:48 <sclv> http://neilmitchell.blogspot.com/2008/04/optional-parameters-in-haskell.html
09:32:50 <jesusabdullah> hah! I did not intend for this to happen
09:32:53 <byorgey> geheimdienst: 'currying' is about types.  'partial application' is about what you actually do with functions of those types.
09:33:00 <alexyk> sclv: is there a package indeed? thx for the link
09:33:00 <Saizan> illissius: it'd work if you had "class IsObject' hack o | o -> hack where .."
09:33:00 <mtnviewmark> okay, forget the Arrow...
09:33:04 <sclv> you used the cofree comonad to solve yr problem! ?
09:33:12 * jesusabdullah needs a coffee comonad
09:33:14 <jesusabdullah> er
09:33:16 <jesusabdullah> a coffee >_<
09:33:17 <mtnviewmark> > let pairAp = \(f, g) (a, b) -> (f a, g b) in  ((+), (++)) `pairAp` (3, "hello") `pairAp` (4, " world")
09:33:18 <lambdabot>   (7,"hello world")
09:33:19 <edwardk> well, the problem of how to obtain the tower of all gradients of a function
09:33:26 <byorgey> geheimdienst: I agree sometimes the boundary can be a bit blurred in Haskell, but you can have one without the other
09:33:29 * jesusabdullah is a walking rimshot this morning
09:33:33 <mtnviewmark> pairAp FTW!
09:33:43 <sclv> I just worked out yesterday why the cofree comonad and the free monad flow naturally from their definitions, which is now super obvious in retrospect.
09:33:59 <lowasser> yeah, that's a wonderful insight
09:34:03 <lowasser> the first time I had it
09:34:09 <lowasser> so sweet
09:34:16 <byorgey> mtnviewmark: nice.  You could make that an instance of a sort of generalized Applicative class for things with two type parameters.
09:34:26 <edwardk> sclv: it turns out that it gives me a nice model for computing all higher order partials in the same pass... and it lets me use Data.Vector to do it, so things nicely fuse away
09:34:37 <edwardk> sclv: i'll be uploading a version with Vector support soon
09:34:44 <edwardk> sclv: yeah
09:34:48 <aristid> is there a good example of code generation from a haskell DSL somewhere?
09:34:50 <sclv> it set me wondering if there is such a thing as a "free arrow" (not obviously generated by a functor though)
09:35:05 <aristid> :t arr id
09:35:06 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
09:35:06 <byorgey> class Applicative2 f where  pure2 :: a -> b -> f a b; ap2 :: f (a -> c) (b -> d) -> f a b -> f c d
09:35:37 <jmcarthur> sclv: well, you can make arrows from free monads and cofree comonads, of course
09:35:46 <sclv> right -- but that's going in the wrong direction
09:35:58 <mtnviewmark> @byorgey - that looks like a nice direction, and ap2 is a nice name for pairAp
09:35:58 <lambdabot> Unknown command, try @list
09:35:58 <jmcarthur> you mean something more general?
09:36:06 <edwardk> sclv: well, both the free monad and cofree comonad are arrows, but neither one is particularly free there
09:36:25 <mtnviewmark> though - beyond 2-tuples, I wonder how generally useful such a thing would be
09:36:41 <mreh> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-ByteString-Lazy.html -- I don't get how they've used "Parser a" in parseFromFile when Parser has kind *
09:36:42 <mtnviewmark> Either is sort of an instance
09:36:51 <illissius> Saizan: hmm, right. thanks
09:37:25 <benmachine> personally what I'd do is rename <**> to >*< (it sorta makes sense) and then use <**>
09:37:32 <edwardk> to add my two cents to the other discussion, curry to me is clearly just curry :: CCC k => Hom k (Prod k a b) c -> Hom k a (Exp k b c)
09:37:41 <byorgey> mtnviewmark: hmm, but for Either you'd want to have  pureL :: a -> f a b  and pureR :: b -> f a b
09:37:51 <mtviewmark_afk> right - so perhaps not...
09:37:55 <mtviewmark_afk> out for a bit
09:37:58 <jmcarthur> edwardk: :\
09:38:01 <edwardk> benmachine: why rename it out of the way? oh for the bifunctor ap above?
09:38:01 <mreh> halp! :(
09:38:07 <benmachine> edwardk: yes
09:38:16 <benmachine> and also because <**> is a silly name anyway
09:38:20 <jmcarthur> i get it, but that's still a dense type for something so simple
09:38:22 <benmachine> it's not mnemonic at all really
09:38:39 <edwardk> benmachine: sadly it is already in widespread use
09:39:01 <benmachine> I once had a weird idea where the arrows and the asterisks had some obscure symbolism wrt the ordering of effects and gathering of values
09:39:04 <Saizan> mreh: Parser has kind * -> *
09:39:11 <benmachine> but I never worked out the details
09:39:21 <mreh> Saizan: you can curry types?
09:39:22 * geheimdienst looked at http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying and is still not convinced that currying is so different from partially applying. and geheimdienst finds it still unclear why a function which basically unwraps a 2-tuple is named "curry"
09:39:34 <benmachine> mreh: sure why not
09:39:51 <Saizan> the correct term here is eta-reduce i'd think, but yeah
09:40:00 <Saizan> type Foo = IO
09:40:05 <jmcarthur> geheimdienst: think of curry as transforming a function, not as manipulating the functions argument directly
09:40:07 <Saizan> that's perfectly fine
09:40:11 <jmcarthur> *function's
09:40:14 <mreh> excelent
09:40:22 <mreh> I hate being a software engineer
09:40:32 <benmachine> more usual is type MonadStack = RWST r w s IO
09:40:34 <wlangstroth> mreh: really?
09:40:43 <benmachine> for some values of r, w, and s
09:40:53 <mreh> wlangstroth, I was not given enough training in the fundamentals
09:40:57 <edwardk> geheimdienst: curried definitions admit "partial application" because you never have more than one argument. currying takes a function that takes a tuple and gives you one that returns a function when fed the first argument. so currying and partial application are related, but different ideas
09:41:10 <sclv> data FreeArr f a b = Arr (f (a -> b)) | ... is the notion
09:41:29 <edwardk> sclv: what is its . ?
09:41:33 <Silvah> Bleh.
09:41:35 <wlangstroth> mreh: nobody is - I've done hiring before
09:41:57 <kmc> what are the fundamentals?
09:41:57 <edwardk> sclv: it requires some notion of zipping 'f's
09:41:59 <sclv> If I knew what to put in the ellipsis it would be more than a notion :-)
09:42:36 <zygoloid> geheimdienst: partial application is something you do with a curried function, in the same way that recharging is something you do with an electric can-opener
09:42:43 <wlangstroth> kmc: in certain cases, I've interviewed people who have a hard time with a for loop
09:42:46 <mreh> the lambda calculus would be considered a fundamental to cs
09:42:55 <sclv> edwardk: right. so the f needs to be applicative, maybe? at which point I think that gets back to the result from the "meticulous, etc." paper
09:42:58 <edwardk> sclv: you'll find that your result needs something more out of f than you're willing to give it.
09:43:07 <aristid> zygoloid: what if the electric can opener is cabled?
09:43:12 <kmc> mreh, not by "software engineers"
09:43:15 <edwardk> sclv: but at that point you just rederived that idioms are oblivious arrows
09:43:27 <wlangstroth> kmc: I think that was his complaint
09:43:29 <edwardk> sclv: and the extra requirement on f no longer makes it free
09:43:36 <mreh> kmc: software engineering has nothing to do with programming
09:43:42 <zygoloid> aristid: ah, implicit arguments :)
09:43:44 <kmc> eh i wouldn't go that far
09:43:58 <kmc> good software engineers are good computer scientists and vice versa
09:44:08 <aristid> zygoloid: i don't know much about electric can openers! mine is mechanical!!
09:44:14 <wlangstroth> kmc: what country/planet are you on?
09:44:15 <kmc> look at chem vs. chem-e
09:44:18 <aristid> zygoloid: and i know nobody who has an electric can opener
09:44:21 <zygoloid> aristid: then how do you make curry?
09:44:31 <mreh> I think we're talking cross purposes with kmc
09:44:41 <aristid> zygoloid: i go to a restaurant and they make me curry \o/
09:44:52 <mreh> I'm talking about the trends in academic cs depts. in the UK
09:45:03 <kmc> which trend is that?
09:45:11 <aristid> zygoloid: well i would, if i would eat curry. haven't bothered trying it yet.
09:45:24 <mreh> agile development, software testing, code coverage, managing people
09:45:27 <sclv> edwardk: a different question maybe is that given lots of applicatives, transformations on them are well represented by arrows.
09:45:46 <kmc> mreh, they don't categorize that differently from CS?
09:45:51 <sclv> but is there some way to show that a given applicative has an arrow over it that flows naturally.
09:45:55 <mreh> kmc: absolutely not
09:45:58 <kmc> :/
09:45:58 <edwardk> sclv: well, you have static arrows
09:46:01 <kmc> it's important stuff
09:46:07 <kmc> but definitely not CS
09:46:17 <monochrom> I am all for using algorithms to manage people, in fact using computers to manage people.
09:46:21 <mreh> OH LORD, WHY HAST THOU FORSAKEN ME!
09:46:26 <wlangstroth> haha
09:47:00 <monochrom> Anyway you can always go to Oxford and join their "algebra of programming" group. Nice math and algorithms there.
09:47:06 <sclv> what's the best article that discusses static arrows?
09:47:16 <mreh> monochrom: is it free?
09:47:30 <edwardk> sclv: not sure. do they come up in the original idiom paper?
09:47:31 <mreh> sounds like a secret society
09:47:32 <jmcarthur> as it is taught in universities, software engineering = design patterns + bureaucracy
09:47:48 <wlangstroth> absolutely
09:47:54 <sclv> hmm, yeah
09:48:02 <wlangstroth> of course, I'd probably hire a software engineer over a cs grad
09:48:19 <monochrom> a group with a public webpage cannot be a secret society: http://www.comlab.ox.ac.uk/research/pdt/ap/
09:48:19 <jmcarthur> i'd rather hire somebody who has cool stuff on the internet
09:48:26 <jmcarthur> regardless of major or lack thereof
09:48:35 <edwardk> jmcarthur: i like this hiring policy ;)
09:48:35 <wlangstroth> yeah, github is the greatest for that
09:48:36 <jmcarthur> but that's just me
09:48:55 <kmc> yay design patterns ;P
09:49:05 <wlangstroth> edwardk: you don't count - I've seen your PoMonad abilities
09:49:13 <edwardk> wlangstroth: hahah
09:49:22 <mreh> I'm now stuck in the middle of being a dissatisfied software engineer, and a mediocre haskeller!
09:49:24 <monochrom> perhaps that's an old webpage. this one is recent: http://www.comlab.ox.ac.uk/activities/algprog/
09:49:26 <aristid> jmcarthur: all power to your hiring method.
09:49:27 <mreh> onwards though!
09:49:40 <edwardk> wlangstroth: technically those were pomorphisms ;)
09:49:45 <kmc> yes onwards mreh :)
09:49:50 <wlangstroth> haha
09:50:04 <wlangstroth> mreh: have you read typeclassopedia yet?
09:50:11 <kmc> if you were a non-haskeller rather than a mediocre haskeller, you might be a less  dissatisfied software engineer ;P
09:50:32 <mreh> kmc: indeed, Chris Clack ruined my life
09:50:36 <kmc> whozat
09:50:42 <mreh> he teaches a third year FP class at UCL
09:50:43 <monochrom> Hrm Richard Bird seems to have retired. But I'm happy Jeremy Gibbons and Ralf Hinze are there.
09:50:45 <mreh> it was AMAZING
09:50:55 <mreh> but in the 3rd year(!)
09:51:32 <kmc> also it's not as though the choice is solely between Haskell and slaving away down in the Java mines
09:52:04 <mreh> kmc: I don't see many alternatives to the goulags
09:52:07 <lowasser> LIES AND FALSEHOOD, MEANT TO SEDUCE US INTO BECOMING YOUR WILLING CORPORATE SLAVES
09:52:10 <mreh> that's all the agents want
09:52:16 <kmc> whose agents?
09:52:23 <wlangstroth> kmc: that's true, there's also the PHP mines
09:52:24 <mreh> the suits
09:52:30 <kmc> heh
09:52:39 <lowasser> oh god the PHP mines are even worse
09:52:52 <tomh-> "php mines" hehe
09:52:53 <edwardk> design patterns are a great solution if your problem that you are stuck in a mediocre language. ;) it is so cute, its like java programmers discovered higher order thinking and are compiling their code down from them in their heads
09:53:01 <lowasser> not only are they completely lost to type safety, but they're terribly inefficient to boot!
09:53:14 <ddarius> The suits just want us to work white-collar jobs as that is their means of reproduction
09:53:16 <lowasser> hah, edwardk, so true
09:53:21 <kmc> choice of language isn't everything; any decent language will let you express yourself pretty well
09:53:25 <mreh> ezyang has a great post about patterns
09:53:27 <kmc> Java and C++ are not decent languages :)
09:53:29 <tomh-> I dont think design patterns are that bad
09:53:41 <Zao> C++ is spectacularly awesome.
09:53:45 <jmcarthur> i think they are great for talking about code you already wrote
09:53:46 <tomh-> they force common solutions to be implemented in a somewhat consistant way
09:53:54 <edwardk> i actually like having access to the design pattern vocabulary, but they tend to get cargo culted
09:53:57 <monochrom> there are very few decent languages
09:54:04 <jmcarthur> i think design patterns are horrible for actually designing with explicitly
09:54:08 <alexyk> how do you pattern-match a record?
09:54:13 <wlangstroth> edwardk: haha too true
09:54:19 <monochrom> if definition of decent language is let you express yourself pretty well :)
09:54:25 <mreh> alexyk: like this Foo { bar = baz }
09:54:26 <Zao> alexyk: View pattern, guard?
09:54:43 * monochrom should write book "implementation patterns"
09:54:48 <mreh> or equivalently "Foo bar"
09:54:53 <kmc> but i think Python, Ruby, JavaScript, Erlang, Clojure, Scala, F#, OCaml, SML, Groovy, D, Scala, Lisp, Scheme all are
09:54:58 <alexyk> Zao: I need to extract a tuple of 3 out of a record with say 4 fields
09:55:00 <ddarius> monochrom: What about "analysis patterns"?
09:55:13 <alexyk> 3 certain fields 
09:55:14 <monochrom> I don't want "analysis patterns".
09:55:21 <kmc> and it's easier to find a job doing "not Java or PHP" than it is to find a job doing Haskell specifically
09:55:21 <mreh> JavaScript is ghastly
09:55:25 <tomh-> I bet if most CRUD apps are written in haskell, there would come some design patterns for haskell too
09:55:26 <kmc> why mreh
09:55:32 <Zao> For most code monkeys, the step from analysis to "just code stuff" is not far.
09:55:37 <mreh> kmc: lack of any type system
09:55:45 <monochrom> design patterns are implementation workarounds and so should be called implementation patterns.
09:56:04 <wlangstroth> JavaScript got ghastly because they standardized it while it was still being built
09:56:04 <kmc> mreh, i like static types but i've had plenty of fun and job satisfaction programming without them
09:56:21 <kmc> anyway
09:56:29 <jmcarthur> i've heard javascript described as a great language but with glaring flaws. i agree with it
09:56:41 * tomh- likes JS
09:56:42 <wlangstroth> I'd agree with that
09:57:03 <wlangstroth> there's a lot of "it would be so great if ..."
09:57:17 <kmc> i think JS is pretty good if you ignore its usual applications
09:57:24 <kmc> and that web stuff has some ugly but is getting better
09:57:25 <Cale_> tomh-: Why particularly with CRUD apps?
09:57:30 <edwardk> ... if they hadn't let microsoft kill ecmascript 3
09:57:34 <alexyk> wlangstroth: sounds like a tragic Frankenstein story.  They animated it too early
09:57:35 <monochrom> I don't like static types because I am an end-user of a dynamic-typed program (duplicity, written in python) that craps out just because of a type error when I add the flag --short-filenames.
09:57:41 <monochrom> err
09:57:43 <c_wraith> things like the distinction between == and === are horrible warts
09:57:44 <aristid> kmc: it does have some painful flaws in the language itself, like the variable scoping.
09:57:44 <jmcarthur> Cale_: because CRUD is a design pattern! :P
09:57:51 <monochrom> I don't like dynamic types because I am an end-user of a dynamic-typed program (duplicity, written in python) that craps out just because of a type error when I add the flag --short-filenames.
09:58:00 <tomh-> Cale_: most design patterns are applicable to typical enterprise CRUD apps ;p
09:58:09 <Cale_> tomh-: You think that patterns in applications are more difficult to abstract than others?
09:58:18 <jmcarthur> "I bet if most MVC apps are written in haskell, there would come some design patterns for haskell too"
09:58:22 <Cale_> er, in persistent storage applications, sorry
09:58:29 <tomh-> Cale_: no 
09:58:51 <tomh-> I just think that if something is done over and over, people start writing books about it with "design patterns"
09:58:56 <wlangstroth> alexyk: that's probably the best analogue
09:59:12 <jmcarthur> tomh-: you have a much looser definition of design pattern than i do, i think
09:59:13 <kmc> tomh-, which is much worse than writing libraries to abstract it
09:59:22 <Cale_> Design patterns are any sort of repetition in code which either we are too lazy to abstract away, or our language is insufficiently expressive to abstract over.
09:59:42 <kmc> "design patterns" are anything the "design patterns community" likes and wants to encourage
09:59:49 <wlangstroth> jmacarthur: who ... said ... that?
10:00:01 <Cale_> kmc: I don't think I agree with that definition :)
10:00:03 <ddarius> jmcarthur: CRUD is not a design pattern.  MVC has little to do with end-user requirements.  CRUD is just a certain, common class of end-user applications.
10:00:10 <alexyk> can I add a deriving to a record?  why isn't it show-ing right away?
10:00:20 <aristid> Cale_: the former would probably occur in haskell programs too?
10:00:24 <jmcarthur> wlangstroth: i was kind of parodying something tomh- said
10:00:29 <monochrom> But of course, writing in python and the like is so much fun, at the expense of we poor end-users.
10:00:32 <Cale_> aristid: Yes, and to some extent the latter as well.
10:00:34 <c_wraith> Cale_, the original GoF book included "little languages" as a design pattern.  Those seem impossible to abstract out.
10:00:37 <int-e> alexyk: yes you can
10:00:56 <jmcarthur> ddarius: CRUD is often used to design programmer interfaces too. i'm thinking things like web services
10:00:58 <wlangstroth> ah - cuz why on earth would MVC ever occur to someone writing Haskell?
10:01:15 <jmcarthur> wlangstroth: actually it's kind of enforced by the type system to an extent
10:01:18 <Cale_> wlangstroth: MVC is in part enforced by Haskell
10:01:26 <wlangstroth> my point
10:01:30 <wlangstroth> exactly
10:01:53 <ddarius> jmcarthur: And what, exactly, does the "CRUD design pattern" suggest for design?
10:02:10 <Cale_> We have at least put the Model / (View Controller) split into our library :)
10:02:58 <jmcarthur> ddarius: i'd say it's a subset of "RESTful design"
10:03:13 * geheimdienst made a lolcat about edwardk's remark from a few minutes ago. hope u lykes. http://images.cheezburger.com/completestore/2010/6/9/129205763362424529.jpg
10:03:31 <McManiaC> http://npaste.de/We/ <- whats wrong here? why does he wants to use different ns?
10:03:48 <ddarius> jmcarthur: What?  CRUD isn't limited to network application.
10:03:51 <ddarius> +s
10:03:55 <jmcarthur> ddarius: neither is REST
10:04:50 <Cale_> McManiaC: There's nothing to say that for a given v, there won't be many instances with varying n
10:04:55 <jmcarthur> arguably, the abstraction is used across many kinds of module or process boundaries
10:05:21 <Cale_> McManiaC: You have run into the motivation behind functional dependencies
10:05:23 <jmcarthur> s/abstraction/design/
10:05:48 * sclv is quite disappointed to find out that the lambdacats website is down
10:05:50 <Cale_> McManiaC: You could write   class Num n => Vector v n | v -> n where ...
10:06:09 <McManiaC> Cale_: oh hmkay
10:06:23 <Cale_> McManiaC: and add {-# LANGUAGE FunctionalDependencies #-} to the top of your source file
10:06:41 <geheimdienst> sclv, yes it hasn't worked for months. it's very sad
10:06:45 <Cale_> McManiaC: This would mean that for a given type v, there can be at most one n for which there is an instance Vector v n
10:07:13 <Cale_> McManiaC: and thus that if the typechecker knows the type v, it can assume that all corresponding n's are equal
10:07:16 <benmachine> you can also do that with type families can't you?
10:07:23 <Cale_> benmachine: absolutely
10:08:11 <sclv> all those kittys will be lost in time, like tears in rain...
10:08:18 <Cale_> If I recall correctly, associated types are equivalent to functional dependencies. (Though there are some things one does better than the other)
10:08:35 <Cale_> So, here, you could also write:
10:08:46 <Cale_> class (Num (Scalar v)) => Vector v where
10:08:52 <McManiaC> Cale_: great, thx
10:08:52 <Cale_>   type Scalar v
10:09:03 <Cale_>   multiplication :: Scalar v -> v -> v
10:09:07 <Cale_> etc.
10:09:42 <McManiaC> cool
10:09:58 <Cale_> for that you'd want the TypeFamilies extension
10:10:19 <lgm> anyone on this list familiar with McBride's dissection procedure?
10:11:09 <lgm> i'm curious of if the Dybvig-Peyton-Jones-Sabry approach to delimited continuations can be derived as an instance of dissection
10:12:09 <ddarius> jmcarthur: Arguably the term "REST" can be applied to non-network scenarios, but regardless, I would say relatively few CRUD applications are RESTful and even fewer are intentionally RESTful.
10:12:23 <Cale_> I remember reading the clowns and jokers paper, but I don't remember it so well.
10:14:50 <jmcarthur> ddarius: i can't really think of any CRUD interfaces that don't fit the meaning of "representational state transfer"
10:15:22 <Cale_> lgm: I certainly don't know enough about delimited continuations to be able to properly answer that, but is there even a polynomial functor involved?
10:16:32 <alexyk> so record field names have to be distinct in a module??
10:16:43 <kmc> correct
10:16:45 <kmc> they're just functions
10:16:50 <alexyk> horrors
10:16:58 <Cale_> They are functions which extract the given field
10:17:11 <alexyk> wish they were auto-qualified
10:17:14 <Cale_> So like any functions you'd care to define, they must have distinct names.
10:17:31 <alexyk> is there a language extension to qualify them with the type? :)
10:17:43 <Cale_> You can put them in separate modules, but most people don't do that. Instead, just tag each one in some way with the name of the structure.
10:17:49 <Cale_> No.
10:17:52 <ddarius> jmcarthur: I would say it is extremely common for CRUD applications to use DBMSs like Sql Server and that it is not uncommon for such to not be stateless and statelessness is, according to Wikipedia and others, one of the defining attributes of REST.
10:17:59 <sclv> there are lots of other nice extensions for records though.
10:18:01 <kmc> there's an extension to disambiguate them by type, in the context where they're used as field names and not as selector functions
10:18:58 <Cale_> alexyk: If you're doing really complicated things with records, you might at some point want to check out one of the many record system packages on Hackage. My new favourite is 'records' :)
10:19:09 <Cale_> But lots of people like fclabels
10:20:00 <noteed> ddarius: the statelessness in REST is w.r.t. the client/server connection...
10:20:03 <alexyk> can a module name coincide with a type name? 
10:20:07 <kmc> yes
10:20:10 <kmc> quite often
10:20:18 <alexyk> Cale_: thx, will check it out
10:20:36 <Cale_> alexyk: I think it may be a bit daunting for beginners though.
10:20:42 <jmcarthur> ddarius: Create/Read/Update/Delete sounds like four atomic operations to me
10:20:49 <alexyk> Cale_: smells of Perl OO :)
10:20:53 <jmcarthur> ddarius: what kind of state are you talking about?
10:21:12 <Cale_> alexyk: If you really don't need row polymorphism, then don't bother with it. Just name your field labels distinctly :)
10:21:29 <Cale_> alexyk: OR: split the types up to expose the commonality between them
10:22:04 <Cale_> alexyk: In a lot of cases where you're repeating field names between types, it indicates a problem with how you've decided to break up your types in the first place.
10:23:11 <alexyk> ok
10:23:25 <alexyk> bb
10:24:02 <lgm> @Cale_ : it turns out there is
10:24:03 <lambdabot> Unknown command, try @list
10:25:07 <lgm> If you look at the way the DSPJS approach works they represent continuations more syntactically, using contexts to control order of evaluation
10:25:43 <Cale_> hmm, okay
10:26:08 <Cale_> I usually expect most things involving continuations to have at least higher order abstract syntax :)
10:26:35 <Cale_> (so the datatypes end up with functions inside them and aren't polynomial)
10:29:17 <Cale_> So we're looking at "A Monadic Framework for Delimited Continuations"?
10:35:49 <lgm> that's the one
10:37:49 <lgm> they adopt a monadic meta-language of the form http://paste.pocoo.org/show/223636/
10:41:31 <lgm> then the translation is structured via http://paste.pocoo.org/show/223641/
10:46:05 <lgm> underlying this translation is the syntactic machinery http://paste.pocoo.org/show/223645/
10:47:10 <sinelaw> lgm, what's this about?
10:48:03 <lgm> i've a hunch you can calculate the Dybvig, Peyton-Jones, Sabry presentation of delimited continuations using McBride's dissection
10:48:26 * sinelaw explodes
10:48:35 <lgm> i was really looking for a reference -- 'cause i'm sure somebody's already noticed this
10:48:44 <sinelaw> you've got one less user to support now
10:49:08 <lgm> say again?
10:49:28 <sinelaw> never mind. i have not the slightest of faintest of ideas what you're talking about
10:49:44 <sinelaw> lgm, link to some background?
10:50:17 <lgm> http://www.cs.indiana.edu/ftp/techreports/TR615.pdf
10:50:24 <sinelaw> thanks
10:50:31 <lgm> that's the Dybvig, Peyton-Jones, Sabry presentation of delimited continuations
10:50:59 <lgm> http://www.cs.nott.ac.uk/~ctm/CJ.pdf
10:51:27 <lgm> that's McBride's paper: Clowns to the Left of me, Jokers to the Right -- describing dissection
10:51:37 <lgm> dissection is more general than differentiation
10:52:14 <lgm> it gives a way to abstract "freezing" the control flow of a fold
10:52:52 <lgm> i'm pretty sure you can derive http://www.cs.indiana.edu/ftp/techreports/TR615.pdf from http://www.cs.nott.ac.uk/~ctm/CJ.pdf
10:53:17 <lgm> before i go to all the trouble of coding it up, i thought i'd see if someone had already done the obvious
10:54:23 <noteed> ddarius: the statelessness in REST is w.r.t. the client/server connection...
10:54:26 <noteed> oups
10:54:35 <thoughtpolice> dons: ping
10:56:38 <gwern> preflex: seen dons
10:56:38 <preflex>  dons was last seen on #ghc 9 minutes and 49 seconds ago, saying: i know  i know
10:57:15 <jmcarthur> bah!
10:59:42 <siracusa> Is there a way to suppress a GHC warning for a single function?
11:00:05 <Igloo> No
11:00:17 <ezyang> sounds like a useful pragma to have tho 
11:00:54 <sclv> lgm: if you do code it up, i look forward to reading it :-)
11:01:20 <dons> thoughtpolice: pong
11:02:39 <benmachine> siracusa: depends which warning - unused parameters can be marked explicitly used via use of _
11:02:53 <benmachine> er, by which I mean, names starting with an _ are used
11:02:56 <benmachine> "used"
11:02:59 <Kaidelong> is GHC smart enough to see that it can update foldl''s accumulator in place?
11:02:59 <lgm> @sclv -- yeah, but because it's for a book on Scala, it'll be in Scala
11:02:59 <lambdabot> Unknown command, try @list
11:03:42 <siracusa> benmachine: No, it's the uninitialised record field thing
11:03:47 <dons> Kaidelong: well, its a register or stack slot, so yes.
11:03:51 <thoughtpolice> dons: oh good! you're here
11:03:57 <thoughtpolice> i was about to email iavor about this :)
11:04:06 <dons> oh, you should email iavor then
11:04:10 <djahandarie> lol
11:04:10 <dons> i'm super busy :}
11:04:18 <thoughtpolice> dons: fair enough then :) it was about a tech talk video
11:04:23 <dons> ok.
11:04:28 <dons> what's the question?
11:05:00 <thoughtpolice> dons: mark jones had a talk @ galois a few weeks ago and me and a coworker are really interested in seeing it. in this thread you said it was recorded, but I've seen no indication of the video being publicly available:
11:05:04 <thoughtpolice> http://www.reddit.com/r/haskell/comments/c3umt/galois_tech_talk_developing_good_habits_for/
11:05:14 <dons> right, we will likely have the first video up today or tomorrow
11:05:26 <dons> mark's talk i think we still need his ok on, but that should follow
11:05:34 <dons> there'll be a big announcement :)
11:05:40 <thoughtpolice> ok, that's fine. :) i was wondering if it was just a space/time issue
11:05:45 <sclv> lgm: a book on scala that deals with clowns, jokers, and delcont!? w. a. o.
11:05:57 <dons> just time working out how best to publish the weekly stream of tech tlaks we have.
11:06:03 <dons> likely to be a vimeo channel, just fyi
11:06:11 <thoughtpolice> dons: thanks for the tip. and that sounds great :)
11:06:13 <dons> stay tuned for more infos
11:06:13 <djahandarie> w.a.o.?
11:06:44 <sclv> (wow, just with a funny spelling and some dots)
11:07:04 <jmcarthur> awesome :)
11:07:21 <jmcarthur> i am particularly interested in that talk as well
11:14:08 <lgm> 'wao' is also a transliteration of Oolof for 'yes'
11:14:37 <lgm> Oolof being one of the primary native dialects spoken in Senegal
11:42:49 <tao_> Hello
11:43:03 <tao_> I'm using split package for working with Strings
11:43:05 <tao_> but i wonder
11:43:15 <tao_> how can I convert IO String to String?
11:43:22 <Botje> you can't
11:43:33 <dv-> tao_: unsafePerformIO
11:43:36 <tao_> ok
11:43:37 <tao_> then
11:43:41 <tao_> what should i do?
11:43:42 <Botje> you can bind the IO String to a String in a do block and work with it there
11:43:52 <jmcarthur> tao_: the correct thing to do is convert the function you want to apply to it from (String -> a) to (IO String -> IO a)
11:44:07 <tao_> jmcarthur: the function is in separate package
11:44:15 <jmcarthur> tao_: doesn't matter :)
11:44:30 <tao_> Botje: I have this code inside my do block: 'input <- hGetLine h'
11:44:33 <tao_> does that mean
11:44:41 <tao_> that i have to do
11:44:48 <tao_> bla <- input
11:44:51 <tao_> ?
11:44:52 <Botje> tao_: after that line, input has type String
11:44:53 <jmcarthur> tao_: input should have type String
11:44:58 <tao_> hmm
11:44:58 <tao_> strange
11:45:14 <Botje> tao_: what are you doing with input afterwards?
11:46:16 <tao_> http://paste.lisp.org/display/111297
11:46:17 <tao_> :(
11:46:30 <jmcarthur> :t liftM  -- tao_: i think this may be slightly irrelevant to your problem in this case, but this is an example of what i meant. you can use liftM to change a pure function into one operating on values you got from IO
11:46:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:46:50 <jmcarthur> for IO:    liftM :: (a -> b) -> (IO a -> IO b)
11:47:25 <Botje> tao_: what's the return type of splitOn ?
11:47:26 <tao_> this is the error: http://pastebin.com/25LqFzi3
11:47:28 <hpc> usually, liftM is also fmap
11:47:50 <Botje> tao_: and what do you want to do with the result of the splitOn?
11:47:55 <tao_> Prelude Data.List.Split> :t splitOn
11:47:56 <tao_> splitOn :: (Eq a) => [a] -> [a] -> [[a]]
11:48:06 <tao_> Botje: for now, just compute the result
11:48:13 <Botje> tao_: okay ..
11:48:19 <tao_> later on i want to separe first elemnt and tail
11:48:28 <Botje> tao_: let input' = splitOn " " input
11:48:56 <tao_> hmm
11:48:59 <Botje> since splitOn is not an IO action, the let just executes it and binds the result to input'
11:48:59 <tao_> now it's working
11:49:01 <tao_> thanks...
11:49:04 <tao_> oh
11:49:14 <Botje> you could have also done input' <- return (splitOn " " input)
11:49:14 <tao_> i should have done return(splitOn), right?
11:49:17 <tao_> yep
11:49:18 <tao_> silly
11:49:19 <tao_> me
11:49:22 <Botje> but the let form is more readable :)
11:49:22 <tao_> thanks :)
11:50:25 <c_wraith> tao_: think about what '(>>=) :: IO a -> (a -> IO b) -> IO b' really means.  It means "combine an IO action resulting in an a with a function that takes an a and returns an IO b, and compose them into an IO b."  That's the fundamental building block for working with IO.  Every other function for manipulating multiple IO values is built on that function, and return.  It's a useful observation at some point, but not necessary when you're just learning h
11:50:25 <c_wraith> ow to work with IO
11:51:42 <c_wraith> it means (>>=) is approximately "treat something as though it's not in IO, so long as the ultimate result is also in IO"
11:54:53 <benmachine> or you can look at (=<<)
11:54:56 <benmachine> :t (=<<)
11:54:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:55:16 <benmachine> "take a function that uses an a and make a function that uses an IO a"
11:55:31 <benmachine> (a -> m b) -> (m a -> m b)
11:56:38 <seric> :type (-=-)
11:57:04 <Blkt> benmachine: I read about comparing >>= and return operators to the operator and the identity function on a monoid
11:57:11 <Blkt> that's been quite enlightening
11:57:25 <benmachine> Blkt: well, return and (<=<) make a monoid
11:57:42 <Blkt> I see
11:57:42 * mux wants an operator for mappend
11:57:56 <Veinor> (=<<) = flip (>>=) right?
11:58:02 <edwardk> hrmm, i'm trying to figure out an optimal way to memoize higher order partial derivatives in a way that captures di dj / dx^2 = dj di / dx^2. the best i've got o far is to compute a multiset of indices and use that as a key for some kind of trie
11:58:02 <c_wraith> yes, Veinor 
11:59:46 <Blkt> stupid question incoming: is there a data structure that guarantees constant time access to it's fields in Haskell's prelude?
12:00:01 <edwardk> Blkt: Data.Array.Array ? not in the prelude though
12:00:02 <benmachine> Blkt: join is kinda a monoid as well
12:00:11 <benmachine> or, it's associative anyway
12:00:22 <benmachine> as in join . join = join . fmap join iirc
12:00:26 <Blkt> edwardk: should do the trick, thanks
12:00:27 <jmcarthur> my favorite monad combinator:  (<=<)
12:00:36 <edwardk> Blkt: there are plenty of data structures with O(1) field access. they just can't contain an arbitrary amount of data ;)
12:00:37 <benmachine> you can join the inner or the outer monad first and you get the same thing
12:00:52 <jmcarthur> a <=< (b <=< c)  ==  (a <=< b) <=< c
12:01:22 <Blkt> edwardk: I can give an upperbound to the needed size, it should be fine
12:01:25 * edwardk prefers his fish to swim the other way. a >=> (b >=> c) == (a >=> b) >=> c
12:02:27 <jmcarthur> for me left-to-right vs. right-to-left depends on if i'm treating my function as something declarative or as something imperative
12:02:53 <jmcarthur> also on whether i'm mixing it with (.) and such
12:03:04 <edwardk> jmcarthur: any thoughts on the indexing problem above?
12:03:16 <edwardk> there should even be a sexy way to map it down to a single integer i'm just not seeing it
12:03:20 <jmcarthur> f . g <=< h . j   reads a lot nicer to me than   h . j >=> f . g
12:03:25 * jmcarthur reads up
12:03:54 <Olathe> Is there a way to get GHC to show RULES applications as it works ?
12:04:06 <Associat0r> MoALTz
12:04:13 <jmcarthur> edwardk: what's the type of the function you are memoizing?
12:05:13 <noteed> edwark: can't you looj it up twice ? once for ij, then maybe once for ji?
12:05:21 <noteed> s/looj/look
12:05:27 <jmcarthur> edwardk: i have the ad haddock docs up right now awaiting instructions for where to look :)
12:05:28 <edwardk> i for the mth derivatives I have m indices each of range [1..n], and need to have it any set of indices that would sort to the same gets memoized to the same slot
12:05:52 <benmachine> Olathe: try -ddump-rules
12:05:57 <Olathe> Ahh, thanks :)
12:06:01 <benmachine> Olathe: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-debugging.html#dumping-output
12:06:29 <edwardk> jmcarthur: the idea is so that when i go to compute gradients :: Traversable f => FU f a -> f a -> (f :> a) -- i can generate the second and higher derivatives with the vastly increased sharing that becomes important as i go farther out
12:06:39 <jmcarthur> aha
12:07:12 <edwardk> ultimately i'd like to even extend that with error bounds on the taylor model
12:07:23 <edwardk> but for now i want to increase sharing
12:07:56 <jmcarthur> edwardk: so basically you have a function like ([Int] -> a) and you want the ordering of the list to be insignificant in the lookup?
12:08:00 <kmc> "Every other function for manipulating multiple IO values is built on that function, and return."
12:08:06 <jmcarthur> without having to sort every time, i assume?
12:08:07 <edwardk> yeah the naive version is to just sort the list
12:08:09 <kmc> there are primitives that manipulate multiple IO values
12:08:19 <edwardk> the slightly sexier version is to track a multiset of the indices used so far
12:08:27 <jmcarthur> hmm
12:08:29 <edwardk> and just insert another one and take the in order traversal
12:08:32 <jmcarthur> i'll have to think over this slightly
12:08:43 <jmcarthur> s/slightly/a little/
12:08:48 <jmcarthur> dunno why i chose that word
12:08:56 <kmc> Blkt, if you have an upper bound on the needed size, then all operations are O(1) ;P
12:08:58 <edwardk> so i pay a logarithmic cost in the number of indices, which is trivial
12:09:09 <edwardk> since i have such an insane size explosion as i get farther out
12:10:23 <edwardk> i.e. if i have 10 inputs, i have 10 partials, all of which are needed, but 100 entries in the hessian, with only just over half of them unique, but in the jacobian of the hessian that number shoots down fast
12:11:05 <kmc> Blkt, i don't mean that just as a smartass comment, unless you have millions of elements you're better off ignoring asymptotic complexity and just profiling
12:11:14 <jmcarthur> edwardk: the lists can have duplicates or no?
12:11:18 <edwardk> they will
12:11:26 <jmcarthur> edwardk: i don't know reverse mode ad so... okay
12:11:33 <edwardk> dx^2/dy^2
12:11:38 <jmcarthur> i don't knwo it very well, anyway
12:11:47 <edwardk> well, this is just derivatives not ad specific
12:12:03 <jmcarthur> alright
12:12:17 <kmc> Blkt, in particular, 'IntMap' is plenty fast (O(1) depending on how you count), and is nicer than arrays in a lot of ways
12:12:18 <jmcarthur> i'll just ignore the use case and just focus on the memoization
12:12:54 <edwardk> 'all of the second derivatives of a function'. for z = f (x,y)  are dx^2/dz^2, dxdy/dz^2, dy^2/dz^2
12:13:28 <edwardk> stored as a hessian that is a 2x2 symmetric matrix
12:13:44 <edwardk> moving up to higher orders you get additional symmetries
12:14:40 <edwardk> i can't think of anything faster than the multiset
12:15:13 <edwardk> and then reading off the keys from the multiset as an index into a trie
12:16:42 <edwardk> if i store the memotrie lazily, then have the conversion to the f-branching stream store references to elements in the trie, then i should get sharing in all my higher order partials
12:16:55 <jmcarthur> i think i have come to the same conclusion as you
12:17:13 <noteed> edwardk: in your example, what are the keys that resolve to thesame values?
12:17:46 <edwardk> [1,1], [1,2], [2,1], [2,2] --  the [1,2] and [2,1] entries are identical
12:18:09 <noteed> edwardk: ok, is it possible to 'normalize' them ?
12:18:16 <edwardk> noteed: sort ;)
12:18:27 <noteed> edwardk: for instance, sort the x,y ?
12:18:28 <edwardk> noteed: but i'm getting them one symbol at a time, so i wan tto do the sort incrementally
12:18:43 <edwardk> hence why i want something like a multiset of the ones i've seen so far
12:18:53 <edwardk> into which i'll insert each new index as i get it
12:20:21 <edwardk> i.e. i'm at a node in a tree that represents the dxdy ('m going to stop writing the /df^3) , and i need to compute the dz child i'd add z to the multiset built from [x,y], and then serialize that into a key for the trie
12:21:10 <edwardk> on the other hand if i'm at dxdz and i need to compute the dy child i'd add y to the multiset build from [x,z] and then serialize that into a key for the trie -- resolving to the same value
12:22:04 <edwardk> so now what i'd really want is to even allocate the nodes in the memotrie which can't exist. ;)
12:22:47 <edwardk> er to not even
12:22:57 <mreh> is the semantics of parserReturn a the parser that parses a
12:23:33 <edwardk> so i.e. given 3 indices, what i'd have is 3 numbers that sum to at most n. which are the relative offsets
12:23:58 <jmcarthur> edwardk: thanks. now your problem is going to be on my mind all day
12:24:08 <edwardk> jmcarthur: perfect!
12:24:18 <edwardk> please feel free to infect others with it ;)
12:24:18 <sclv> edwardk: you can always just sacrifice purity under the covers. its not like the library doesn't already :-)
12:25:05 <edwardk> sclv: heh, well i'd prefer this part remain pure so that the end user code doesn't need to care about it. i could play silly mvar games, but the memotrie isn't bad
12:26:35 <edwardk> the next trick is how to ensure that when i'm calculating those derivatives i don't bother calculating anything extra. so figuring out the right encoding of the trie keys is key to figuring out how to walk the minimal representation optimally
12:26:37 <_Matt_J_W_> hi guys
12:26:47 <_Matt_J_W_> Is the following a recursive definition?
12:26:59 <_Matt_J_W_> data Iden a = Iden a
12:27:04 <sclv> no
12:27:06 <edwardk> _Matt_J_W_: no
12:27:15 <edwardk> the "Iden" on the right hand side is the name of the data constructor
12:27:18 <_Matt_J_W_> please explain
12:27:19 <edwardk> its not the type
12:27:36 <edwardk> data Foo x y z = Bar (Some Complicated Type) | Baz (Some Other Complicated Type)
12:27:45 <_Matt_J_W_> So the type adn the constructor can have the same name
12:27:48 <edwardk> Bar and Baz are constructor names., they are tags put on the contents of Foo
12:27:50 <edwardk> yes
12:27:54 <edwardk> they occupy different namespaces
12:28:15 <_Matt_J_W_> aha
12:28:34 <edwardk> in fact if you only have one constructor it is typically encouraged to make them the same
12:28:51 <jmcarthur> edwardk: you could make paths down the trie in which indices are out of order return thunks that traverse the trie with the indices sorted... if that makes sense
12:28:57 <noteed> edwardk: (I don't understand everything but heh) instead of walking the tree and 'discover' the, say, y after x and z, maybe you can generate the 'paths' x, xy, xyz, ... then walk the tree along those paths
12:29:16 <edwardk> jmcarthur: the danger is that it doesn't give me the machinery to efficiently compute wit hthe trie
12:29:30 <jmcarthur> edwardk: what do you mean?
12:29:35 <_Matt_J_W_> okay guys
12:29:39 <edwardk> noteed: indeed, that is basically the trick
12:29:40 <_Matt_J_W_> what I'd like to know
12:29:57 <_Matt_J_W_> I created an instance of Monad
12:30:03 <_Matt_J_W_> with the Idn type
12:30:15 <_Matt_J_W_> and defined reutnr as return Iden
12:30:36 <edwardk> jmcarthur: well, what is going to happen with this is i'm going to start with a bunch of these tries. one for each input, where the head of the trie is associated with the value of the original input, and the entire body of the trie has value 1
12:30:57 <_Matt_J_W_> return 'f' returns 'f' I would have thought It would require the data def to derive Show but even without it it works
12:31:02 <_Matt_J_W_> what's going on there please?
12:31:14 <edwardk> representing the tower of partial derivatives (with the magical structure that ensures that i don't have redundant values)
12:31:18 <jmcarthur> edwardk: oh wait, so this is a trie you will be explicitly inserting key-value pairs into over time?
12:31:33 <edwardk> when i go to add two of those inputs i need to be able to add the tries elementwise
12:31:41 <sclv> not sure what you mean Matt?
12:32:09 <sclv> return should be Iden, not return Iden
12:32:20 <edwardk> product requires a product-rule traversal that convolves them yielding another trie
12:32:22 <sclv> otherwise you get an accidentally recursive definition
12:32:22 <jmcarthur> edwardk: oh i think i see
12:32:27 <_Matt_J_W_> maybe I hould ask you to explain hw return = Iden works
12:32:29 <gwern> :t foldr
12:32:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:32:52 <gwern> > foldr (>) 0 [1,2,5,8]
12:32:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
12:32:53 <lambdabot>    arising from the literal `0'...
12:32:57 <sclv> Iden (at the value level) is a constructor. It says "give me an a and I will give you an Iden a"
12:32:59 <gwern> > foldr (>) True [1,2,5,8]
12:33:00 <jmcarthur> so you *are* going to use these tries explicitly, not as a "trick" underneath a normal function
12:33:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
12:33:00 <lambdabot>    arising from the literal `1'...
12:33:06 <edwardk> the result is something that i want to be able to extract the gradient Tensors from, in such a way that they point to shared nodes in the lazy trie.
12:33:10 <sclv> which is the same thing as saying that Iden is a function a -> Iden a
12:33:24 <sclv> and return is a function Monad m => a -> m a
12:33:32 <edwardk> that way user level code doesn't have to care about the crazy amounts of sharing that start happing at the third order partials
12:33:36 <edwardk> er happening
12:33:50 <sclv> so if we fix m to type Iden, then the Iden constructor itself fulfills exactly that type
12:34:06 <gwern> @src foldr1
12:34:06 <lambdabot> foldr1 _ [x]    = x
12:34:06 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
12:34:06 <lambdabot> foldr1 _ []     = undefined
12:34:18 <gwern> :t foldr1
12:34:19 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:34:21 <sclv> If you don't understand how data types and constructors work fully, its probably better to spend more time on them before going on to monads.
12:34:38 <_Matt_J_W_> maybe I hould ask you to explain hw return = Iden worksthank you guys I'm afraid I have to change this screen as the quick moving text is hurting my eyes
12:35:18 <_Matt_J_W_> thanks for your help
12:35:25 <djahandarie> lol
12:35:55 <gwern> > foldr (>) 0 [1,2,5,8]
12:35:56 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
12:35:56 <lambdabot>    arising from the literal `0'...
12:36:06 <gwern> @src max
12:36:06 <lambdabot> max x y = if x <= y then y else x
12:36:10 <gwern> @src all
12:36:10 <lambdabot> all p =  and . map p
12:36:14 <gwern> @src and
12:36:14 <lambdabot> and   =  foldr (&&) True
12:36:38 <jmcarthur> edwardk: your problem sucks. i'm not doing any work right now
12:36:54 <jesusabdullah> It's weird how functional programming paradigms have influenced my coding in matlab
12:36:59 <sizzler> lets say I have a function f x y z and sequence [1..3] how do I execute f multiple times substituting values from the sequence for y
12:36:59 <noteed> edwardk: did what I said was ovious because it is why you use the trie in the first place?
12:37:15 <jesusabdullah> It's frustrating that some things work really well functionally in matlab, but others so terribly
12:38:01 <jesusabdullah> sizzler: map?
12:38:03 <sclv> sizzler: map (\y -> f x y z) [1..3]
12:38:05 <sizzler> I tried list comprehension but I dont want a list as f performs an IO
12:38:15 <sclv> then mapM
12:38:19 <sclv> :t mapM
12:38:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:42:43 <edwardk> jmcarthur: =)
12:43:07 <edwardk> noteed: erm kinda =/ but i have a lot more context than you do
12:44:28 <noteed> edwardk: no harm, was interested in the discussion
12:45:42 <jmcarthur> edwardk: all i can think of is using an IntMap to explicitly alias locations in the trie
12:45:48 <edwardk> jmcarthur: there should be a connection to the number of coordinates required to store a k-flat in an n-dimensional space.
12:46:03 <edwardk> well the trie itself can store only the non-redundant entries
12:46:11 <edwardk> i can sort in the key assembly step
12:46:34 <jmcarthur> oh, i was thinking you kind of wanted a trie that worked on unsorted keys
12:47:19 <edwardk> jmcarthur: http://comonad.com/thesis.pdf page 32 top of page i have a chart of the number of coefficients used to store different representations
12:47:23 <mreh> has somebody not already written a library of ByteString parsers?
12:47:42 <edwardk> there seems to be a connection to the series i'm getting when i write these out and count them up by hand
12:47:47 <edwardk> but i haven't solved it ;)
12:47:56 <mreh> yes they have
12:48:03 <edwardk> mreh: attoparsec
12:48:12 <edwardk> mreh: parsec 3 also does bytestrings
12:48:20 <mreh> edwardk, oh I was thinking binary
12:48:24 <Phyx-> hahaha
12:48:39 <edwardk> Phyx-: ?
12:49:50 <mreh> edwardk, it supports them, but doesn't implement any basic parsers
12:50:36 <edwardk> attoparsec is the one i'd use. parsec 3 has issues when you try to use it 'in the large' since other libs use the older parsec internally
12:51:02 <jmcarthur> edwardk: are the indices integers, naturals, some other monomorphic type, or entirely polymorphic?
12:51:13 <edwardk> jmcarthur: the indices will at least be naturals
12:51:28 <edwardk> i can assign some number n to the number of partial derivatives about which I am concerned
12:51:32 <Phyx-> edwardk: wrong channel :P
12:51:58 <jmcarthur> edwardk: *obviously* then, the best solution is to map each index to a unique prime and look up the product of the indices as the key of an IntMap :P
12:52:27 <edwardk> jmcarthur: actually that is a pretty good solution except for the fact that the result is fairly sparse
12:53:17 <edwardk> but i can relatively quickly count off the first n primes
12:53:24 <c_wraith> Also, you don't need very many primes to exceed the max value for an Int
12:53:52 <jmcarthur> i think that would be the bigger issue
12:54:43 <edwardk> well, i can store the key as an Integer.
12:55:00 <c_wraith> Then you lose the performance of IntMap
12:55:01 <edwardk> but you suffer asymptotically if you want to be anal retentive
12:55:04 <jmcarthur> yeah and use a Map instead of an IntMap...
12:55:09 <edwardk> c_wraith: well, there is bytestring-trie ;)
12:55:16 <jmcarthur> ah, there is that
12:55:27 <jmcarthur> that would be quite nice actually
12:56:05 <c_wraith> @src Integer
12:56:05 <lambdabot> data Integer = S# Int#
12:56:05 <lambdabot>              | J# Int# ByteArray#
12:56:06 <jmcarthur> still makes me nervous to multiply huge numbers like that
12:56:24 <c_wraith> I wonder if there's a quick conversion from ByteArray# to ByteString
12:56:27 <edwardk> well, the reason i'd rejected it when i sketched the idea out was that multiplying the new key in can be quite expensive
12:56:29 <jmcarthur> although i guess that would be the rare case?
12:56:38 <sclv> a multiset represented as Map idx int doesn't seem so awful?
12:56:40 <gwern> > let ascending (x:y:ys) = if null ys then True else x < y && ascending (y:ys) in [1,2,5,8]
12:56:40 <lambdabot>   [1,2,5,8]
12:56:53 <gwern> > let ascending (x:y:ys) = if null ys then True else x < y && ascending (y:ys) in ascending [1,2,5,8]
12:56:53 <edwardk> sclv: yeah there are even some on hackage
12:56:54 <lambdabot>   True
12:56:57 <edwardk> that part is fine
12:57:06 <gwern> huh. I didn't expect that to work, actually
12:57:24 <gwern> expected a pattern-match failure at the end of the list
12:57:31 <gwern> > let ascending (x:y:ys) = if null ys then True else x < y && ascending (y:ys) in ascending [2,1,5,8]
12:57:31 <lambdabot>   False
12:57:32 <sclv> and that's isomorphic to the product-of-primes representation, no?
12:57:33 <edwardk> i'm trying then to figure out the right encoding for the trie itself. 
12:57:49 <c_wraith> gwern, your pattern match failure will only happen when the first input has less than two elements
12:58:27 <gwern> c_wraith: I lop off one element at each recursion, so at the end there ought to be [8], which wouldn't match. but I guess null takes care of it
12:58:39 <edwardk> which i'm thinking looks like something along the lines of a Trie n m a -- has two natural numbers n and m associated with it. n is the number of symbols in the key, m is the 'fanout' of the trie.
12:58:57 <c_wraith> gwern: yeah, it does.
12:59:07 <edwardk> the slot k of that trie has m - n as its symbol count
13:01:38 <xkb> hi
13:01:43 * hackagebot hjson 1.1.3 - JSON parsing library  http://hackage.haskell.org/package/hjson-1.1.3 (JaroslavGridin)
13:02:23 <gwern> ☉‿☉
13:02:27 <gwern> new releases = yay
13:02:42 <c_wraith> But I'm not using that lib!  I'm using one of the alternative ones! :)
13:02:50 <gwern> then GDIAF
13:03:09 <c_wraith> aww.  I didn't realize the punishment for choosing the wrong lib was so harsh. :(
13:03:40 <gwern> it was only a suggestion
13:03:52 <edwardk> c_wraith: hackage isn't just a cute portmanteau, it is a warning about what will happen if you don't use the subset of libraries on it that gwern likes ;)
13:04:10 <gwern> dying in a fire can be really impressive. ever watch any videos of monks?
13:04:15 <gwern> now that's serious protest
13:05:03 <gwern> kind of against the spirit of 'non-violent protest', but no one can accuse them of not taking it seriously
13:07:34 <xkb> Any tips on what to change on this code please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26051#a26051
13:08:16 <gwern> xkb: I don't even understand what you're asking
13:08:18 <tommd> xkb: Could you say what that is supposed to do and what you want?
13:08:56 <xkb> Yes, it is a part of the Douglas-Peucker algortihm to reduce polylines. This version stops when a certain threshold distance is reached
13:09:15 <gwern> so where do you calculate your threshold difference?
13:09:17 <xkb> however I'm trying to change it so it stops when a certain number of points in the polygon is reached
13:09:36 <gwern> xkb: certain # of the final result?
13:09:38 <xkb> it's in the result tuple from selectGreatestOrthogonalDistance
13:09:43 <xkb> so much for brevity :)
13:09:50 <gwern> xkb: just wrap the entire thing in a 'take 100' or whatever then maybe
13:09:51 <xkb> gwern: indeed
13:09:54 <Zao> s'god
13:10:00 <gwern> sblood!
13:10:05 <gwern> strewth
13:10:24 <xkb> gwern: hmm good tip
13:10:37 <gwern>  @wn strewth
13:10:40 <gwern> @wn strewth
13:10:42 <lambdabot> No match for "strewth".
13:10:48 <gwern> we need a better dictionary
13:10:50 <xkb> only problem might be it recurses both ways, e.g. it devides in two each time
13:11:10 <gwern> I mean, wiktionary has 'strewth', and 'zounds' too
13:16:01 <edwardk> jmcarthur: perhaps think about multinomial coefficients?
13:16:45 <jmcarthur> maybe
13:18:27 <jmcarthur> i'm struggling to see how it ties in, actually
13:18:31 <jmcarthur> (wishes he was more mathy)
13:18:31 <edwardk> jmcarthur: it is clear i can use the multinomial theorem to show that i can start from a multiset and derive all the different values i need to index all n^d elements of the dth derivative of my function
13:18:40 <jmcarthur> s/()/\/me/
13:19:07 <edwardk> jmcarthur: what i'm looking for is how i might use something from that area to describe the data structure it would be best to put those in
13:20:56 <jmcarthur> that's an interesting approach
13:21:03 <jmcarthur> damnit i need to get back to work
13:21:10 <edwardk> of course if i google anything about multinomials and derivatives i wind up sclv's territory ;)
13:21:10 <jmcarthur> edwardk: leave me alone :P
13:21:21 <edwardk> jmcarthur: but fun data structures!
13:21:24 <fergie> does anyone know of any good tutorials for the hjs library?
13:21:26 <jmcarthur> i know!
13:21:33 <edwardk> hjs?
13:22:25 <fergie> the javascript interpreter/parser
13:22:51 <fergie> the stuff on the wiki is either incomplete or I am too stupid to understand it
13:26:50 <BMeph> Is it feasible to separate execution and evaluation in an impure language? I keep slipping into the idea that said separation is also influenced by laziness, but I figure that's just because my education was/is so spotty.
13:27:37 <BMeph> (As an aside, I highly recommend William Cook's Data Abstraction paper. :)
13:27:41 <jmcarthur> BMeph: what's the difference in an impure language?
13:28:55 <BMeph> jmcarthur:  "Dogs and cats living together..."? ;)
13:31:26 <JoeyA> is there a way to do something like this?  instance (Fractional a) => MyClass a where
13:31:30 <edwardk> BMeph: its hard to get folks in an impure language to want to wear the hair shirt
13:31:32 <jmcarthur> BMeph: it might be feasible to do a version of it, but not quite the same thing. e.g. you could separate things that have effects outside of the vm from things that are only internal to the vm
13:31:42 <sclv> JoeyA -- exactly what you just did.
13:31:50 <JoeyA> Didn't work
13:31:54 <edwardk> BMeph: you can do it though, just pass around nullary functions. thats how the ml guys do it
13:31:57 <JoeyA> Couldn't match expected type `a1' against inferred type `a'
13:31:58 <jmcarthur> meaning mutation would be "evaluation," but I/O would be execution
13:32:29 <sclv> That's going to be a problem in what you wrote -- you can always put class constraints on instance headers. I forget which extensions you may / may not need though.
13:32:34 <jmcarthur> can't say it would be very useful though
13:32:37 <JoeyA> Maybe it's my implementation
13:33:27 <JoeyA> I have a type constructor:  Number (Fractional a => a)
13:33:43 <JoeyA> and my instance uses it
13:33:48 <JoeyA> I guess I need a forall somewhere
13:34:29 <sclv> JoeyA -- that's probably a bad idea. that constructor.
13:35:06 <JoeyA> How would I rewrite it?
13:35:15 <sclv> Depends what you want to do :-)
13:35:20 <sclv> What's the end goal?
13:35:48 <JoeyA> I'm just making a braindead JSON datatype to prototype things
13:36:08 <sclv> You should probably pick a single concrete representation like Rational or Double
13:36:24 <JoeyA> I'm trying to write a syntactic sugar ==> operator so I can say Object ["key" ==> "value"] instead of Object [("key", String "value")]
13:36:42 <JoeyA> ah, thanks
13:36:57 <edwardk> sclv: you may be amused given what we talked about at hac-phi that my current solution is likely to involve some notion of a "multinomial tree" ;)
13:36:58 <sizzler> sclv, mapM worked and thats what what I was looking for. Thanks
13:39:16 <sclv> its a pretty powerful and suggestive concept
13:40:17 <sclv> One thing that hit me as maybe fun is a representation sort of like "perfect trees" where each slice is guaranteed to have the right number of elements.
13:41:54 <BMeph> jmcarthur: The use is I keep hearing that separation of eval and exec is a purity thing, when I've always had the impression that it's a laziness thing. Having a useless, but possible separation of them may help me understand which property it is, and why. :)
13:43:44 <alexyk> is there a SortedMap?
13:44:03 <ClaudiusMaximus> what would it do?
13:44:10 <aavogt> sorted by what?
13:44:14 <ClaudiusMaximus> :t Data.Map.minViewWithKey
13:44:15 <lambdabot> forall k a. M.Map k a -> Maybe ((k, a), M.Map k a)
13:44:59 <aavogt> that function would be clearer if it had  Ord k =>
13:45:13 <alexyk> ClaudiusMaximus: in Java, a SortedMap equivalent would return pairs in the sorted order of keys
13:45:29 <mauke> that's just Map
13:45:36 <Saizan> BMeph: the lazy thing is the confusion between values and redexes
13:45:39 <aavogt> otherwise you might think it finds the minimum value instead of key
13:45:39 <JoeyA> What's invalid about this type signature?  JSON :: a -> JSON (data JSON = ... appears above)
13:45:54 <alexyk> mauke: is any Map guaranteed to return in sorted order of keys??
13:46:04 <mauke> what do you mean by "any Map"?
13:46:08 <JoeyA> it's inside a class that categorizes a
13:46:08 <mauke> there's only one Data.Map
13:46:24 <alexyk> mauke: map of any type of keys
13:46:34 <ClaudiusMaximus> @hoogle Map k a -> [(k,a)]
13:46:34 <lambdabot> Data.Map assocs :: Map k a -> [(k, a)]
13:46:34 <lambdabot> Data.Map toAscList :: Map k a -> [(k, a)]
13:46:34 <lambdabot> Data.Map toList :: Map k a -> [(k, a)]
13:46:34 <aavogt> you can't have a map of any key type
13:47:02 <aavogt> @hoogle [(k,a)] -> Map k a
13:47:02 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
13:47:02 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
13:47:02 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
13:47:15 <alexyk> but yeah, if Data.Map can do that, that's fine; to toList will return a sorted one?
13:47:18 <aavogt> a map that works correctly anyhow
13:47:29 <alexyk> good
13:47:50 <ClaudiusMaximus> use toAscList if you require sorting
13:47:55 <JoeyA> d'oh, function names have to start with a lowercase letter
13:48:19 <aavogt> ClaudiusMaximus: toAscList is the same as toList actually
13:48:35 <ClaudiusMaximus> aavogt: is that guaranteed?
13:48:45 <sclv> but toAscList is guaranteed to do the right thing
13:48:52 <sclv> while the behavior of toList may change in the future
13:48:57 <sclv> though one hopes it wouldn't
13:50:29 <aavogt> you could see the implementation of Data.Map changing anytime soon?
13:52:47 <markus3> just to be sure: is Data.Map String a comparing the string on every step of the binary tree?
13:53:04 <dafis> markus3: Yes
13:53:06 <mreh> markus3 of course
13:53:26 <mreh> but string comparisons are efficient in the average case
13:53:34 <markus3> ok
13:53:41 <dafis> markus3: But it usually needs to compare only a few letters
13:53:48 <mreh> exactly
13:54:10 <mreh> or even one
13:54:23 <markus3> but it would be more, if searching for the right value would look at every Char once
13:54:40 <markus3> on every level
13:54:49 <mreh> @src (==) [Char]
13:54:49 <lambdabot> Source not found.
13:54:58 <mreh> @src (==) [a]
13:54:58 <lambdabot> Source not found. My brain just exploded
13:55:17 <mreh> you just compare every element piecewise
13:55:30 <dafis> markus3: when your strings have a long common prefix, comparisons become more expensive
13:55:43 <dafis> markus3: then you should consider a trie
13:56:13 <markus3> not to sound stupid, but whats that?
13:56:56 <kmc> it looks at every Char once, on each level
13:57:40 <dafis> markus3: I can't explain in a few words, so http://en.wikipedia.org/wiki/Trie
13:57:52 <kmc> it's exactly what you just asked for ;)
13:57:59 <markus3> for some reason I had thought that binary tree was just that... but recently found out, that it wasnt
13:58:19 <kmc> "binary tree" could mean just any tree where non-leaves have two children
13:58:23 <kmc> which would include some tries
13:58:51 <kmc> and some heaps, and lots of other unrelated stuff
13:59:02 <kmc> i.e, it's an implementation technique, not a data structure API
13:59:04 <kmc> but "binary search tree" is more specifically an associative container based solely on comparison
14:00:00 <aavogt> is the word associative here at all related to  a(bc) = (ab)c ?
14:00:18 <dafis> aavogt: No
14:00:33 <dafis> aavogt: It associates a value with a key
14:00:33 <aavogt> dafis: as in, there's not connection at all?
14:00:56 <dafis> aavogt: Only an etymological connection
14:03:44 <danharaj> does real world haskell go over gui's?
14:03:55 <kmc> yes
14:04:01 <danharaj> goodie
14:04:11 <kmc> http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
14:04:15 <danharaj> oh
14:04:18 <danharaj> gtk :|
14:04:50 <kmc> ;P
14:05:21 <danharaj> Maybe this is irrational, but I have a deep-seated hatred for software that uses GTK on windows.
14:05:30 <mreh> can all Integral types be constructed with a integer literal?
14:05:41 <mauke> :t 0
14:05:41 <lambdabot> forall t. (Num t) => t
14:05:45 <mreh> > show . unpack "1"
14:05:46 <lambdabot>   Not in scope: `unpack'
14:05:53 <mreh> excellent
14:06:12 <mreh> unpack is a bytestring anyway
14:06:24 <mreh> :t 'c'
14:06:25 <lambdabot> Char
14:06:36 <mreh> @hoogle Char -> Word8
14:06:36 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
14:06:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:06:36 <lambdabot> Prelude error :: [Char] -> a
14:06:56 <mauke> :t Data.ByteString.Char8.unpack
14:06:57 <lambdabot> BSC.ByteString -> [Char]
14:07:32 <mreh> just efficiently writing my parser so it uses literals
14:07:42 <mreh> apparently makes it 100 time faster reading them
14:08:07 <mreh> task 1) create lookup table for all ascii characters
14:08:34 <mreh> @instances Bounded
14:08:34 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
14:09:10 <mreh> > [fromEnum c | c <- ([minBound..maxBound] :: Char)]
14:09:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:09:11 <lambdabot>         against inferred type...
14:09:19 <mreh> > [fromEnum c | c <- ([minBound..maxBound] :: [Char])]
14:09:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:09:49 <mreh> excellent smithers
14:11:02 <mreh> hmm, Chars aren't ascii encoded are they
14:11:20 <mauke> what do you mean by "encoded"?
14:11:30 <c_wraith> > '\4660'
14:11:30 <lambdabot>   '\4660'
14:11:32 <dafis> > fromEnum (maxBound :: Char)
14:11:33 <lambdabot>   1114111
14:11:59 <dafis> mreh: Too many Chars for ASCII
14:12:00 <mreh> interpreted as an ascii code
14:12:13 <mreh> ascii fits in 8bits
14:12:14 <mauke> what does that mean?
14:12:15 <mreh> correc?
14:12:27 <c_wraith> 32-127 are the same as ascii
14:12:39 <c_wraith> But they're unicode codepoints
14:12:47 <edwardk> aavogt: re: minViewWithKey I'm not a big fan of using unnecessary instances as documentation. =/
14:12:56 <mreh> i'll do it the other way around, Word8 -> Char
14:13:01 <edwardk> aavogt: they wind up getting constructed and then wasted
14:13:50 <mreh> mauke: I'm assuming that underlying the Char datatype is some kind of binary representation
14:14:05 <mauke> what difference does it make?
14:14:46 <edwardk> mreh: chars are guaranteed to be able to hold the 21 bits of the unicode range
14:15:09 <c_wraith> if you want individual bytes, just use a bytestring
14:15:26 <mreh> I'm not awake enough to be 101% logically precise, I'm sorry
14:15:29 <mreh> oops, there i go again!
14:15:46 <edwardk> > logBase 2 1114111
14:15:46 <lambdabot>   20.087461546321563
14:15:56 <dcoutts_> more precisely, a Char is exactly a Unicode code point
14:16:03 <edwardk> dcoutts_: fair enough
14:16:13 <mreh> "point"?
14:16:21 <edwardk> dcoutts_: well, with some minor additions, it includes the gap ;)
14:16:29 <aavogt> edwardk: how about for classes that have no methods?
14:16:53 <dcoutts_> edwardk: true, it includes the unallocated ranges
14:16:57 <edwardk> aavogt: if you need one to express a law that is another matter entirely
14:17:18 <dcoutts_> > maxBound :: Char
14:17:18 <lambdabot>   '\1114111'
14:17:30 <edwardk> dcoutts_: which i can hardly begrude it, otherwise the fromEnum, toEnum and enumFrom would have to have some pretty crazy behavior ;)
14:18:09 <dcoutts_> > Char.chr (1114111 + 1)
14:18:10 <lambdabot>   Not in scope: `Char.chr'
14:18:14 <dcoutts_> bah
14:18:24 <mauke> > chr 1114112
14:18:25 <lambdabot>   *Exception: Prelude.chr: bad argument
14:18:40 <edwardk> > toEnum (1114111 + 1) :: Char
14:18:41 <lambdabot>   *Exception: Prelude.chr: bad argument
14:19:10 <dcoutts_> interesting, the error message is wrong
14:19:15 <dcoutts_> chr is not in the Prelude :-)
14:19:21 <edwardk> hah
14:20:37 <aavogt> edwardk: documentation and laws aren't too different, but I see your point
14:22:06 <edwardk> aavogt: well, an instance for a law will likely vanish, one for Ord might be pretty expensive to construct. (for instance some of my ad modes have to build an enormous Lifted instance, one for a Mode, another for the AD wrapper around them, and then use that to define Ord for AD.
14:22:12 <edwardk> and since dictionaries are strict...
14:22:52 <yitz> > showHex (fromEnum (maxBound :: Char)) ""
14:22:53 <lambdabot>   "10ffff"
14:27:06 <aavogt> edwardk: do instance dictionaries have to be strict though?
14:27:33 <edwardk> aavogt: it is an implementation detail, that is the way they are handled at the moment
14:28:00 <edwardk> and its a fairly sensible policy overall, since the vast majority of the time its a pure win to avoid the check
14:35:50 <louis> exlevan: 
14:35:59 <louis> Heffalump: 
14:36:53 <jesusabdullah> > replicate 3 "kmin:kres:kmax"
14:36:53 <lambdabot>   ["kmin:kres:kmax","kmin:kres:kmax","kmin:kres:kmax"]
14:37:12 <jesusabdullah> hah!
14:39:24 <Heffalump> louis: ?
14:44:05 <MrBlueSky> Ello, my sieve of eratosthenes has been running about 2 hours on an alright pc to calculate the prime numbers up to 2,000,000. 
14:44:07 <MrBlueSky> sieve :: [Int] -> [Int]
14:44:11 <MrBlueSky> sieve :: [Int] -> [Int]
14:44:12 <MrBlueSky> erf
14:44:15 <MrBlueSky> it's not copying code
14:44:41 <MrBlueSky> one moment
14:45:11 <MrBlueSky> http://pastebin.com/KFse4MRd
14:45:29 <MrBlueSky> does that look alright? It seems ridiculous that it could be taking this long
14:45:50 <mauke> did you compile with -O2?
14:45:59 <MrBlueSky> I ran it in ghci 
14:46:30 <c_wraith> it's correct, but really slow.  as you've already seen. :)
14:46:42 <jbapple> That still sounds strangely slow to me
14:47:00 <MrBlueSky> think I should compile it and run again? 
14:47:09 <c_wraith> takes about 10 seconds to list that many primes using a faster algorithm on my system...  Most of that time was waiting for the terminal to catch up :)
14:49:09 <MrBlueSky> does that algorithm have a name or could you link me to it c_wraith?
14:49:56 <jbapple> MrBlueSky: Have you read Melissa O'Neil's JFP article on sieves?
14:50:15 <c_wraith> the algorithm I'm using is
14:50:17 <c_wraith> @hackage primes
14:50:18 <lambdabot> http://hackage.haskell.org/package/primes
14:50:26 <c_wraith> handy package that contains a list of all prime numbers. :)
14:50:27 <jbapple> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
14:50:32 <BMeph> MrBlueSky: That's a naive sieve you're using, not SoE.
14:50:38 <MrBlueSky> thanks both of you (:
14:50:40 <c_wraith> Mostly based on the paper jbapple mentions
14:51:35 <jbapple> MrBlueSky: That paper talks about performance issues and computational complexities, so even if you don't use her code, her article might explain why yours wasn't as fast as you might like
14:51:47 <BMeph> MrBlueSky:  Also, I just ran it in GHCi right now; it took 3.25 secs. Of course, I do have a dual-core 3 GHz machine with 3 GB of memory. On the other hand, it's running WinXP... ;)
14:52:39 <MrBlueSky> BMeph, you ran my code?
14:53:16 <JoeyA> How do you convert a Float to a Double?
14:53:22 <BMeph> MrBlueSky: Technically, no. I wrote out your list comprehension as a filter, but it's otherwise the same. :)
14:53:29 <MrBlueSky> weird
14:53:33 <MrBlueSky> I'll try that
14:53:36 <BMeph> JoeyA: Don't Just use a Double. ;)
14:54:03 <JoeyA> Then how do I do that?  In my circumstance, it's giving an ambiguous type on Fractional, despite the fact that Fractional appears nowhere in my code.
14:54:07 <BMeph> MrBlueSky:  "let {sieve [] = []; sieve (x:xs) = x: filter ((/=0).flip mod x) xs}"
14:54:44 <JoeyA> I have a class with instance Double a where ..., but when I invoke the involved function on a literal like 8.95, it gives an ambiguous type error
14:54:48 <aavogt> @type toRational . fromRational
14:54:49 <lambdabot> Rational -> Rational
14:54:53 <BMeph> JoeyA: If you're using a function that has a Fractional constraint, then it's in your code.
14:54:59 <mauke> JoeyA: realToFrac
14:55:10 <aavogt> JoeyA: what's the intermediate value there?
14:55:23 <aavogt> (it's type that is)
14:55:24 <byorgey> :t 8.95
14:55:24 <lambdabot> forall t. (Fractional t) => t
14:55:47 <byorgey> 8.95 is not a Double, it is polymorphic
14:55:56 <aavogt> it defaults though
14:56:06 <byorgey> sure, in some circumstances
14:58:26 <JoeyA> http://codepad.org/1T7LRRzV
14:58:59 <mauke> well, yes
14:59:08 <mauke> it doesn't know which type you want
15:00:05 <JoeyA> Hence, the perfect case where a toDouble or fromFractional would make sense:  http://codepad.org/VoTQ0ZLT
15:00:21 <mauke> lolwut
15:00:29 <mauke> that's not how instance works
15:01:04 <mauke> JoeyA: will you ever define any other instances of Bar?
15:01:25 <JoeyA> Yes
15:01:31 <aavogt> won't they overlap?
15:01:42 <JoeyA> nope
15:01:50 <mauke> yes, they will
15:01:53 <aavogt> have you tried it?
15:01:57 <JoeyA> Not if they're String, etc.
15:02:00 <mauke> yes, they will
15:02:06 <mauke> a matches everything
15:02:16 <dafis> JoeyA: They will, because the instance selection doesn't look at contexts
15:03:16 <JoeyA> So you're saying Fractional a means nothing in  instance (Fractional a) => Bar a where  ?
15:03:20 <mauke> class Bar a; instance (Fractional a) => Bar a; works like Bar :: Type -> Whatever; Bar a = Fractional a
15:03:29 <mauke> Fractional a is the "body" here
15:04:17 <dafis> JoeyA: it means nothing for instance selection. After the instance has been selected, the compiler looks for an instance of Fractional
15:04:28 <dafis> and if it doesn't find one, barfs
15:04:44 <mauke> just like functions
15:05:11 <mauke> the part before the = is used for selecting the right equation, then the function calls in the body are done
15:07:20 <JoeyA> Isn't there a way for an instance to select a class, then?
15:07:30 <JoeyA> Simply listing the instances doesn't cut it here:  http://codepad.org/12qJashX
15:07:47 <mauke> JoeyA: what's wrong with realToFrac?
15:08:32 <JoeyA> Didn't know I could do that :-)  Still doesn't answer my question, though.
15:08:32 <mauke> JoeyA: also, can't you just specify a fixed type in line 13?
15:08:42 <mauke> <mauke> JoeyA: realToFrac
15:08:51 <dafis> JoeyA: realToFrac, really
15:09:00 <JoeyA> Needing to cast the literals is what I'm trying to avoid here.
15:09:08 <mauke> it's not a cast :-[
15:09:35 <JoeyA> (I mean, use :: syntax)
15:10:07 <dafis> JoeyA: You can't avoid it here, I'm afraid
15:10:13 <mauke> that code can't work anyway
15:10:24 <mauke> there is no way to convert an arbtriary Fractional a to Double
15:11:12 <dafis> mauke: If line 13 is changed to test = bar (3.45 :: Double) it'll work
15:11:51 <dafis> also if :: Float is used
15:12:00 <BMeph> JoeyA: Here's what we're trying to get you to see: you're not telling the computer that you want it to use a Double. You're telling it that it needs to have a Double, but you aren't telling it to actually use a Double, when it needs one. :)
15:12:28 <mauke> what is Foo for?
15:12:44 <BMeph> Fighting? ;þ
15:19:03 <gwern> a fig for't!
15:36:21 <jesusabdullah> :t foldl
15:36:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:36:38 <jesusabdullah> crap I don't follow :(
15:37:05 <jesusabdullah> oh okay, 's what I thought I guess
15:37:15 <jesusabdullah> foldl (+) [1..5]
15:37:18 <jesusabdullah> > foldl (+) [1..5]
15:37:19 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
15:37:19 <lambdabot>    arising from a us...
15:38:08 <jesusabdullah> > foldl (+) 1 [2..5]
15:38:09 <lambdabot>   15
15:38:15 <jesusabdullah> > 1+2+3+4+5
15:38:16 <lambdabot>   15
15:38:25 <jesusabdullah> Ah, you need to give it an initial value!
15:38:27 * jesusabdullah learns
15:38:42 <jesusabdullah> I'm matlabbing, and I'm basically ending up reimplementing half of the prelude
15:38:47 <jesusabdullah> d-oh!
15:38:52 <jesusabdullah> serves me right
15:38:52 <mauke> @src sum
15:38:52 <lambdabot> sum = foldl (+) 0
15:39:01 <jesusabdullah> Just an example, you see
15:39:15 <jesusabdullah> I'd use sum any other day :)
15:39:41 <jesusabdullah> in fact, MATLAB *has* sum()
15:39:49 <jesusabdullah> well, a form of sum() anyways
15:41:11 <hpc> it takes args as sum(x, y, z) instead of sum(biglist), right?
15:41:26 <jesusabdullah> octave:276> sum([1:5])
15:41:26 <jesusabdullah> ans =  15
15:41:39 <jesusabdullah> caveat: octave, not matlab, but should be the same
15:42:08 <hpc> ah
15:48:34 <jesusabdullah> @src foldl
15:48:34 <lambdabot> foldl f z []     = z
15:48:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:48:45 <noteventime> Something seems fishy about the monad instances from the Iteratee IO slides
15:49:07 <jesusabdullah> oh neat, recursive
15:49:09 <jesusabdullah> heh
15:49:12 <jesusabdullah> <--easily amused
15:49:49 <dafis> jesusabdullah, but most of the time you won't want foldl, rather foldl'
15:49:53 <zygoloid> > foldl f z [a,b,c,d,e]
15:49:54 <lambdabot>   f (f (f (f (f z a) b) c) d) e
15:49:59 <zygoloid> > foldr f z [a,b,c,d,e]
15:49:59 <lambdabot>   f a (f b (f c (f d (f e z))))
15:50:29 <jesusabdullah> hmm
15:51:19 <dafis> jesusabdullah, foldl builds a huge thunk for a long list
15:52:13 <jesusabdullah> > foldl' 1 [2:5]
15:52:14 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [[t]])
15:52:14 <lambdabot>    arising from a us...
15:52:23 <jesusabdullah> > foldl' (+) 1 [2:5]
15:52:24 <lambdabot>   No instance for (GHC.Num.Num [t])
15:52:24 <lambdabot>    arising from a use of `e_1125' at <int...
15:52:31 <jesusabdullah> > foldl' (+) 1 [2..5]
15:52:32 <lambdabot>   15
15:52:34 <jesusabdullah> ugh too much matlab
15:52:48 <jesusabdullah> so wait, how is foldl' different from foldl?
15:53:20 <dafis> jesusabdullah, foldl' evaluates the accumulator to whnf in each step
15:53:23 <Axman6> it's strict
15:53:29 <jesusabdullah> oh
15:53:39 <jesusabdullah> it's less lazy?
15:53:41 <krey> evening, anyone know a strict function that returns a non-strict function?
15:54:02 <Heffalump> krey: sounds like homework...
15:54:07 <dafis> jesusabdullah, try foldl (+) 0 [1 :: Int .. 1000000] in your ghci (:set +s) vs foldl'
15:54:15 <jesusabdullah> About to
15:54:16 <greb> hi
15:54:23 <jesusabdullah> is foldl' in prelude?
15:54:35 <mreh> jesusabdullah, nope, it's in Data.List
15:54:39 <dafis> jesusabdullah, no, :m + Data.List
15:54:40 <krey> Heffalump: I have answers, and yes it is homework
15:55:02 <krey> Heffalump: I'm just not convinced by the answers given to me
15:55:30 <dafis> krey: care to give an example you're not convinced by?
15:55:35 <Heffalump> I think many people aren't convinced by (&&) / (||), if that helps.
15:55:40 <krey> yes
15:55:41 <jesusabdullah> ah
15:55:46 <jesusabdullah> avoids stack overflows
15:55:49 <krey> my tutor says they're not right
15:56:03 <jesusabdullah> :D :D
15:56:05 <krey> I think they are
15:56:14 <Heffalump> they're not very good because the behaviour in the second argument depends on which first argument you supply
15:56:15 <jesusabdullah> Thanks guys
15:56:23 <jesusabdullah> Oh, so when would you want foldl and not foldl' ?
15:56:32 <jesusabdullah> ooc?
15:56:32 <Heffalump> you can write an alternative that is unconditionally non-strict in the second argument
15:56:32 <jesusabdullah> ever?
15:56:33 <mreh> jesusabdullah, all the time
15:56:50 <mreh> when you're reducing a very long list of things down to a single value
15:57:02 <Heffalump> mreh: why not use foldl' then?
15:57:07 <jesusabdullah> That's what I mean
15:57:15 <mreh> oh, sorry, wrong way round
15:57:19 <jesusabdullah> hah XD
15:57:32 <mreh> you never need foldl
15:57:36 <mreh> :D
15:57:37 <dafis> jesusabdullah, I don't know any real example when one would want foldl and not foldl'
15:57:48 <jesusabdullah> Just a bad implementation in prelude, I guess
15:57:51 <jesusabdullah> Hmm!
15:57:53 <jesusabdullah> Awesomesauce
15:57:56 <Olathe> If you're summing, perhaps you'd like foldb.
15:58:02 <jesusabdullah> Oh, I'm not
15:58:06 <jesusabdullah> at least, not in this case
15:58:07 <mreh> jesusabdullah, converting a reversed list of characters to an Integer is a good example of foldl
15:58:19 <krey> Heffalump: very true, thank you!
15:58:26 <mreh> foldl and foldl' are precisely the same semantically, they're just operationally different
15:58:37 <jesusabdullah> I don't even remember why I wanted to be able to foldl in matlab anymore >_<
15:58:39 <dafis> mreh: no, not precisely
15:58:42 <jesusabdullah> but it was important at the time!
15:59:20 <dafis> mreh: you can make examples where foldl' errors and foldl returns a good value
15:59:23 <mreh> dafis: well if they return partial results it's a bit different
15:59:33 <dafis> They're quite artificial, though
15:59:48 <mreh> don't confuse the man
15:59:59 <dafis> mreh: If both return a good value, it's the same
16:00:04 <jesusabdullah> I'm not THAT confused
16:00:05 <jesusabdullah> XD
16:00:22 <mreh> it took me ages to get foldr and l down
16:00:48 <mreh> 'r' and 'l' don't seem to my mind, to have any connection to way they work
16:00:49 <jesusabdullah> I'm taking my sweet time absorbing ideas from fp, myself
16:00:50 <alexyk> why do Haskellers use camelCase instead of under_score?
16:01:04 <Olathe> alexyk: The other Haskellers made us.
16:01:06 <jesusabdullah> Why do pythonistas use under_score?
16:01:08 <tommd> _under_score_takes_longer_to_types
16:01:09 <jesusabdullah> :S
16:01:14 <alexyk> camelCase is so anti-FP.
16:01:19 <dafis> mreh: associate to the *r*ight or to the *l*eft
16:01:31 <alexyk> underscore allows to translate lisp_things easier
16:01:35 <jesusabdullah> :t foldr
16:01:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:01:41 <jesusabdullah> er
16:02:01 <alexyk> tommd: write once, read many times
16:02:03 * jesusabdullah scrolled up
16:02:19 <tommd> alexyk: I have no issues reading camel case.
16:02:24 <jesusabdullah> measure twice, cut once?
16:02:25 <alexyk> tommd: or just call everything a, b, c... wait, you guys do that
16:02:26 <mreh> I think it just stuck
16:02:29 <dafis> alexyk: but some find camelCase nicer to read
16:02:55 <alexyk> camelCase is the convention of the unspeakable language.  who wants to be seen doing that?
16:03:00 <sproingie> iPreferCamelCase
16:03:11 <tommd> lol, alexyk: Many programmers do that unfortunately.  It actually works OK for haskell because so often the variables are that general (xs  - plural for 'x'.  'x' meaning some value of which we know nothing else about).
16:03:16 <alexyk> can ' be n the middle of a name?
16:03:23 <sproingie> yep
16:03:27 <dafis> alexyk: yes
16:03:27 <alexyk> yay!
16:03:34 <mreh> c2hs has a function for converting between the two, heh
16:03:48 <tommd> alexyk: there is actually a library that exports the symbol: don't
16:03:52 <tommd> All one symbol.
16:03:55 <alexyk> I translate Clojure manually
16:04:07 <sproingie> > let ph'ngluiMglw'nafhCthulhuR'lyehWgah'naglFhtagn = 1
16:04:08 <lambdabot>   not an expression: `let ph'ngluiMglw'nafhCthulhuR'lyehWgah'naglFhtagn = 1'
16:04:15 <jesusabdullah> What does don't do?
16:04:23 <jesusabdullah> oh wait, I think I remember seeing that!
16:04:24 <jesusabdullah> nvm
16:04:29 <jesusabdullah> doesn't do, right? XD
16:05:08 <sproingie> perl turns ' in an identifier into ::, an ancient perl4 compatibility thing
16:05:32 <sproingie> so there's a test method of isn::t so you can say isn't $a, $b
16:05:50 <jre2> when using the fg library to solve max flow the edge labels are used to story capacity. is there a good way to keep track of which node/edge refers to what in your original data (since you can't use the labels in this case)?
16:06:01 <mreh> I was going to ask before I got involved in this, how can I cast bytestrings into different word sized strings?
16:06:17 <dafis> mreh: ?
16:07:00 <dafis> mreh: do you want to interpret them as e.g. Word32 arrays?
16:07:14 <mreh> dafis: bytestring is something like [Word8], how can I cast that to a [Word16] by reading two consecutive bytes
16:07:22 <mreh> dafis: yah
16:07:33 <ClaudiusMaximus> @hoogle ByteString -> (Ptr a -> Int -> IO b) -> IO b
16:07:34 <lambdabot> No results found
16:08:00 <Olathe> @hoogle ByteString -> [Word8]
16:08:00 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
16:08:00 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
16:08:00 <lambdabot> Data.ByteString head :: ByteString -> Word8
16:08:29 <hpc> @hoogle pack
16:08:29 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
16:08:30 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:08:30 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
16:08:31 <jesusabdullah> woo! cfoldd works XD
16:08:52 <jesusabdullah> geez, this is terrible
16:08:57 <mreh> worst part is I want to make a polymorphic function that reads a file and returns the right [WordX] depending on the header
16:09:31 <Olathe> @type map ((\[a, b] -> 256*fromIntegral a + fromIntegral b :: Word16) . take 2) . iterate (drop 2) . unpack
16:09:32 <lambdabot> Not in scope: `unpack'
16:09:35 <Olathe> Bah
16:09:42 <dcoutts_> mreh: do you care about performance? Do you want something safe and high level or something unsafe and low level?
16:09:57 <mreh> dcoutts_ performance is critical
16:10:23 <Olathe> mreh: You can look at how Data.Binary does it.
16:10:36 <mreh> Olathe: okay
16:11:10 <Cale_> I seem to recall the Crypto package containing something like that.
16:11:20 <dcoutts_> mreh: then you can use Data.ByteString.Internal.toForeignPtr
16:11:34 <dafis> mreh: also look at the ByteString sources, I think peekElemOff instead of peekByteOff might work
16:11:40 <Cale_> Oh, looks like it operated on lists of Word8
16:11:56 <hpc> :t Data.ByteString.Internal.toForeignPtr
16:11:57 <lambdabot> BSC.ByteString -> (GHC.ForeignPtr.ForeignPtr Word8, Int, Int)
16:12:07 <dcoutts_> mreh: and cast the ForeignPtr Word8 to a ForeignPtr Word32 and then do something like make a StorableArray, with the correct bounds
16:12:13 <ivanm> Cale_: have you been following dons, et al's arguments about why we shouldn't call the new version fgl?
16:12:19 <Cale_> no
16:12:43 <ivanm> well, here's a summary: http://haskell.org/haskellwiki/Libraries/WhenToRewriteOrRename
16:12:50 <mreh> dcoutts_ that's good, thanks, however can I define a polymorphic function that can read it into a variety of formats?
16:12:59 <mreh> formats, meaning word size
16:13:02 <dcoutts_> mreh: but it's ugly, it'd be better if you did not start with a ByteString, since you're breaking the abstraction
16:13:11 <dcoutts_> mreh: if you don't mind copying then it's much easer
16:13:24 <ivanm> Cale_: just wondering what your thoughts were, because they're using the QuickChec, Parsec, etc. situations as examples about why you shouldn't make major API changes to "historic" libraries
16:14:05 <dcoutts_> ivanm, Cale_: btw, I disagree with dons, so long as you're careful, I think what you're planning is ok
16:14:25 <ivanm> right
16:14:40 <ivanm> AFAICT, most of the problems are because people don't put versions in their cabal files
16:15:10 <ivanm> dcoutts_: I'm just trying to get the opinions of people like Cale_ who don't usually read -cafe and as such might not have been aware of the discussions
16:15:23 <dcoutts_> the critical issues are: is the new api in the spirit of the old, do you have the support of the previous maintainer and current users, will the new implementation actually be better, will the transition be managed well
16:15:36 <Cale_> I think a major version number update is enough warning of API incompatibility
16:15:46 <ivanm> dcoutts_: do you mind if I quote you on that on the wiki page?
16:16:00 <dcoutts_> ivanm: fine
16:16:02 <Cale_> (and yeah, make sure that whoever it was that originally produced the original fgl package blesses it :)
16:16:15 <ivanm> Cale_: he gave it up for adoption, so *shrug*
16:16:23 <dcoutts_> ivanm: that's not quite the same thing
16:16:31 <ivanm> hmmm.....
16:16:31 <dcoutts_> ivanm: his opinion is relevant
16:16:36 <ivanm> OK
16:16:47 <Igloo> I don't think it's as important as everyone else seems to
16:16:56 <Olathe> mreh: It looks like ByteString itself has a converter to String (8-bit characters, but still) that you could probably modify: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.2/doc/html/src/Data-ByteString-Char8.html#unpack
16:17:09 <alexyk> so RWH tells of the horros of foldl and thunkness of foldr, and praises foldl'.  Why would anybody use foldl now?
16:17:13 <dcoutts_> ivanm: because it's an indication that the new impl+api are in the spirit of the original design
16:17:20 <dafis> ivanm, Igloo: But he should be asked, I think
16:17:47 <Olathe> Are there any uses of foldl that aren't covered by foldl' ?
16:17:47 <Igloo> If the original author wanted to keep "control" of the name, he wouldn't have orphaned the library
16:17:51 <mreh> alexyk: performance, I think
16:17:56 <dcoutts_> Olathe: but note that it'd be unsafe, it'd be endian-dependent
16:18:11 <alexyk> mreh: foldl is faster than foldl'?
16:18:22 <ivanm> Olathe: I have seen one or two cases where foldl is better than foldl', but can't remember which
16:18:25 <Olathe> dcoutts_: You could write it to make it big-endian only.
16:18:26 <alexyk> RWH riuined the folfl for us
16:18:30 <ivanm> basically, if seq-ing is bad
16:18:32 <zygoloid> @hoogle [Maybe [a]] -> [a]
16:18:32 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
16:18:32 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
16:18:32 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
16:18:34 <alexyk> foldl, not falafel
16:18:36 <Olathe> ivanm: Ahh, OK.
16:18:40 <sproingie> mmm falafel
16:18:43 <ivanm> zygoloid: concat . catMaybes
16:18:44 <mreh> rofld
16:18:55 <dcoutts_> alexyk: there's almost no reason to ever use foldl, the choices are foldl' and foldr
16:19:01 <ivanm> Igloo: that was my thinking
16:19:02 <Olathe> rofl, rofl', and rofr
16:19:07 <zygoloid> ivanm: yeah, i was wondering if there was a precomposed function ;-)
16:19:16 <zygoloid> thanks
16:19:43 <alexyk> Olathe: rolling on the floor recursively?  (rofr)
16:19:54 * sproingie wonders if falafl.com is taken
16:20:00 <Olathe> rolling on the floor right-associatively.
16:20:14 <alexyk> sproingie: I've just taken functional.tv btw
16:20:25 <sproingie> "functionl"
16:20:30 <dcoutts_> Igloo: while that's true, I think that if the original author said the new api was bad but the new maintainers wanted to do it anyway, they'd need much stronger support from the users
16:20:34 <alexyk> that's a dutch one
16:21:01 <sproingie> you're not hip unless you drop the final vowl
16:21:30 <alexyk> sproingie: why not a leading one?  flcker
16:21:30 <Olathe> you'r nt hp unlss yo drp th finl vowls
16:22:16 <alexyk> yu're not hip nless yu drop the lading vwels
16:22:38 <ivanm> dcoutts_: however, the reason Martin gave it up for adoption is because people from the HNN project were pestering him for changes and he didn't have the time, etc. to do them
16:22:44 <sproingie> jst g ll th wy nd drp ll th vwls
16:22:52 * dafis sn't hp vn f m drps ll vwls
16:23:07 <hpc> oe ae oo
16:23:08 <dcoutts_> ivanm: yes, but the point is does he agree with the specific changes
16:23:17 <hpc> ("vowels are cool")
16:23:21 <dcoutts_> ivanm: not just that he doesn't have time to do it himself
16:23:37 <sproingie> when you have a gun in your mouth, you speak only in vowels
16:23:47 <inetic_> hi there, I would like to have two functions with the same name, where one would take an argument of type String and the other would take any other list (they would both return the same type), is this possible in haskell? (preferably without extensions I guess)
16:23:53 <dcoutts_> ivanm: if he does, you have a very strong argument
16:24:15 <hpc> inetic_: String is just [Char]
16:24:18 <ivanm> hmmmm...
16:24:20 <dafis> inetic_, with a type class
16:24:29 <ivanm> well, we would need to clean the code up a bit more before we ask him
16:24:40 <ivanm> but yeah, asking him wouldn't be a problem
16:24:45 <sproingie> type class and overlapped instances
16:25:07 <sproingie> the latter being an "extension", but everyone has it
16:25:24 <dcoutts_> ivanm: you don't need all the code, so long as the design/api is there
16:25:25 <dafis> ivanm: I think with an API outline you could ask him before the code's cleaned up
16:25:36 <inetic_> hpc: i know, that's the problem I think, the other way of saying it is, one function shoult be of type foo:: [Char] -> Bar, and the other one foo:: [AnythingElse] -> Bar
16:25:38 <ivanm> sproingie: not everyone has OverlappedInstances... >_>
16:25:41 <dcoutts_> ivanm: though code is useful to check a design is possible! :-)
16:25:46 <ivanm> dcoutts_: comments, etc. are needed ;-)
16:26:02 <inetic_> dafis: I'll check out type classes then, thanks
16:26:15 <sproingie> i think RWH has an example of doing exactly this
16:26:19 <ivanm> it's a tad messy at this stage: http://code.haskell.org/FGL/fgl/Data/Graph/Inductive/Graph.hs
16:26:34 <hpc> inetic_: ah, i see
16:26:42 <ivanm> sproingie: right, using the Show approach as well as the extension
16:27:01 <ivanm> IMHO, the Show approach is usually better if you're going to be applying it to lists as well
16:28:18 <ivanm> and I've got to check whether our map functions actually work; I have the sneaking suspicion that they don't type check...
16:29:22 <dcoutts_> ivanm: I don't get the split between the class InductiveGraph and Graph
16:29:33 <hpc> actually, you might not have to use overlapped instances
16:29:35 <ivanm> dcoutts_: yeah, I'm wanting to join them back up
16:29:46 <hpc> if you make a typeclass with a default implementation
16:29:47 <ivanm> dcoutts_: it was originally to stop the class being too big, but now I think it's just silly
16:30:02 <ivanm> @hoogle readS_to_p
16:30:03 <lambdabot> Text.ParserCombinators.ReadP readS_to_P :: ReadS a -> ReadP a
16:30:03 <lambdabot> Text.ParserCombinators.ReadPrec readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
16:30:03 <dcoutts_> ivanm: I thought you'd have a split between read only and updatable graphs
16:30:05 <hpc> er, crap nvm
16:30:24 <ivanm> dcoutts_: nah, not in FGL
16:30:28 <ivanm> we're making FGL all updateable
16:30:44 <ivanm> and I'll make the graph-classes library deal with read-only graphs
16:31:01 <dcoutts_> ivanm: what's the rationale there?
16:31:03 <ivanm> a lot of stuff that's in there will be moved down to the graph-classes library as well
16:31:19 <ivanm> dcoutts_: the whole point of FGL is inductive graphs
16:31:43 <ivanm> graph-classes is going to provide some common classes for dealing with a wide variety of graph-like data types (Cabal package dependency graphs, etc.)
16:31:52 <dcoutts_> ivanm: there's no such thing as an inductive graph that can only be decomposed?
16:31:53 <inetic_> hpc: will do, thanks
16:31:57 <ivanm> the only thing that FGL should cover IMHO is the addition of inductivity on graphs
16:32:13 <ivanm> dcoutts_: I don't think so, but I'm willing to be convinced otherwise
16:32:23 <ivanm> since if you can remove an arbitrary vertex, why can't you add one back in?
16:32:25 <dcoutts_> ivanm: if you add new dependencies you need to go via the platform proposal process
16:32:39 <ivanm> dcoutts_: right; I'm not planning on getting this into the platform any time soon though
16:32:57 <dcoutts_> ivanm: because adding one violates a graph invariant (for my special kind of graph)
16:33:10 <dcoutts_> ivanm: fgl is already in the platform of course
16:33:12 <hpc> inetic_: no, i was wrong; it only works if you are fine with making everything an instance of the typeclass by had
16:33:19 <zygoloid> woo, pretty close to being able to spelunk into the heap of a running haskell process :)
16:33:46 <ivanm> dcoutts_: oh? as in you want to stop adding arbitrary Contexts ?
16:34:43 <dcoutts_> ivanm: sure, I don't see why a Cabal package dep graph can't be made an instance of this class, except that it must be read-only
16:34:52 <ivanm> hmmm....
16:35:04 <inetic_> hpc: hmm, and the other way would be to use the "overlapping instances" thingy extension?
16:35:19 <ivanm> dcoutts_: OK, I'll look at putting the DynGraph split back in then
16:35:36 <ivanm> dcoutts_: I was just thinking that anyone that wanted to do the split inductively would want to be able to join it together again inductively
16:36:05 <dcoutts_> ivanm: maybe I'm crazy :-)
16:36:10 <ivanm> heh
16:36:16 <ivanm> yeah, dammit, our graph mapping functions have the wrong type :@
16:36:32 * ivanm has to think about how to do it without explicitly requiring kind * -> * -> *
16:36:45 <ivanm> @tell tomberek gmap, nmap and emap are too restrictive :s
16:36:46 <lambdabot> Consider it noted.
16:37:01 <Igloo> By "update", you mean "make a new graph" rather than destructively update, right?
16:37:30 <ivanm> right
16:37:49 <Igloo> So how is updating a graph less safe than making a new graph from scratch?
16:38:09 <Igloo> And surely I can update a graph with fromList . f . toList?
16:38:36 <ivanm> currently, yes
16:38:51 <ivanm> though we're calling it fromContexts . f . toContexts ;-)
16:39:14 <dcoutts_> Igloo: an example here is a Cabal InstallPlan, you can decompose that but you cannot add arbitrary nodes and you cannot construct one from a list
16:40:04 <ivanm> dcoutts_: in that scenario, you wouldn't even allow arbitrarily creating new graphs, which FGL currently allows
16:40:27 <dcoutts_> ivanm: right
16:40:40 <dcoutts_> just a view of an existing type as a graph
16:40:48 <dcoutts_> only for deconstruction
16:41:29 <ivanm> @tell tomberek and I can't work out any way of keeping it in the class; it appears that if we want to force mapping not changing the graph type, we need kind * -> * -> * which we don't want in general :s
16:41:30 <lambdabot> Consider it noted.
16:41:34 <ivanm> dcoutts_: right
16:41:54 <ivanm> dcoutts_: but do you want it done in the sense of FGL decomposition, or is just having a list of nodes and edges sufficient?
16:42:49 <dcoutts_> ivanm: well if FGL style decomposition is useful then yes
16:43:04 <ivanm> OK
16:43:15 <gwern> @flish
16:43:19 <ivanm> @tell tomberek and dcoutts_ wants us to make the Graph/DynGraph split again...
16:43:19 <lambdabot> Consider it noted.
16:43:30 <ivanm> gwern: hmmm... does @fish work as well? :p
16:43:39 <dcoutts_> ivanm: perhaps I'm wrong and it's just not useful
16:44:00 <ivanm> dcoutts_: I suppose it depends on what kind of algorithms arise using these decompositions
16:44:06 <dcoutts_> ivanm: aye
16:44:31 <ivanm> but IIRC any cool thing I did that involved inductive decomposition required inductive composition as well
16:44:34 <dcoutts_> that split was not in the original fgl for at least the reason that it provided concrete implementations, not a class that could be used as a view for existing types
16:45:17 <dcoutts_> ivanm: then maybe it's not useful, I don't know
16:45:25 <ivanm> well, both the default implementations instanced both graphs
16:45:38 <ivanm> @hoogle match
16:45:38 <lambdabot> Language.Haskell.TH match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
16:45:38 <lambdabot> Data.Graph.Inductive.Graph match :: Graph gr => Node -> gr a b -> Decomp gr a b
16:45:38 <lambdabot> Language.Haskell.TH.Lib match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
16:46:14 <djahandarie> How would I do something like... map ($ 1 2) [const]  without using uncurry
16:46:44 <djahandarie> i.e. use $ without the side-effect of it grouping everything to the right
16:46:46 <ivanm> dcoutts_: actually, it's not _quite_ true
16:47:04 <noteventime> The way the monad instance for Itaratee in the Iteratee IO slides handles the "rest stream" seems strange
16:47:14 <jesusabdullah> > sum [6..10]
16:47:14 <lambdabot>   40
16:47:17 <jesusabdullah> *whew*
16:47:20 <jesusabdullah> alright!
16:47:26 <ivanm> e.g. my code that finds cliques in graphs needs DynGraph only because i need to make an arbitrary graph to a simple one, not because of the actual clique detection functions
16:48:09 <ivanm> djahandarie: use uncurry ;-)
16:48:16 <djahandarie> lol
16:48:24 <ivanm> or else do it in two passes with partial application
16:48:39 <djahandarie> Hm
16:48:41 <ivanm> @type \map ($2) . map ($1)
16:48:42 <lambdabot> Parse error in pattern
16:48:46 <ivanm> @type map ($2) . map ($1)
16:48:47 <lambdabot> forall a b a1. (Num a, Num a1) => [a1 -> a -> b] -> [b]
16:48:52 <noteventime> It ignores the rest from the bound function (terminology?) only if the rest from the right hand side isn't empty
16:48:53 <ivanm> djahandarie: ^^
16:48:54 <djahandarie> In reality I have like 9 variables so I can't
16:49:02 <ivanm> djahandarie: you could do a two-level map
16:49:22 <dafis> djahandarie, map (flip id 1 2) [const]
16:49:25 <ivanm> djahandarie: one map takes the arguments and converts it to (($2) . ($1) ), etc.
16:49:35 <ivanm> then you apply that to your functions
16:50:23 <djahandarie> Hm maybe I should just do uncurry :P
16:50:38 <ivanm> djahandarie: except uncurry won't work for 9 arguments
16:51:13 <ivanm> @type foldr (\ arg args -> ($arg) . args) id
16:51:13 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
16:51:13 <lambdabot>       Expected type: f (a -> b)
16:51:13 <lambdabot>       Inferred type: f b
16:51:14 <dcoutts_> ivanm: is there an obvious read-only non-inductive graph view interface? I mean the node/edge lookup stuff.
16:51:17 <ivanm> bah
16:51:25 <djahandarie> Oh yeah
16:51:32 <ivanm> dcoutts_: that's what the generic graph class library is going to do!
16:51:38 <ivanm> which I'll be writing at AusHack
16:52:08 <ivanm> @type ($1) . ($2) . ($3)
16:52:08 <lambdabot> forall a b a1 a2. (Num a, Num a1, Num a2) => (a2 -> a1 -> a -> b) -> b
16:52:18 <dcoutts_> ivanm: if it's really obvious what that class should be, perhaps the containers lib is the right place, along with the existing Data.Graph impl
16:52:35 <ivanm> dcoutts_: well, I'll be doing it in a separate library first
16:52:42 <ivanm> then we'll see about merging it in
16:52:57 <ivanm> dcoutts_: note that it's going to need extensions though, which means it probably won't suit containers...
16:53:10 <dcoutts_> ivanm: type functions you mean
16:53:23 <ivanm> well, either type families or MPTCs + Fundeps
16:53:46 <ivanm> I'd prefer type families, especially if TacticalGrace gets the super-class constraint stuff fixed in time for 6.14
16:54:15 <interferon> so, do i want HDBC or HSQL?
16:54:48 <ivanm> interferon: how are we supposed to know which one you want? :p
16:54:58 <ivanm> if you mean which do we recommend on the other hand...
16:55:02 <ivanm> *shrug*
16:55:04 <interferon> i don't know :)  is one more widely used or maintained than the other?
16:57:10 <ivanm> I think HDBC is still the preferred one atm
16:57:22 <ronwalf> uhg, my type class constraints are getting longer than my functions!
16:57:27 <ivanm> and RWH has a section on HDBC (then again, seeing as how one of the authors is the maintainer of HDBC...)
16:57:31 <ivanm> ronwalf: lol
16:57:32 <ronwalf> I need 'type' for class constraints
16:59:01 <ronwalf> Sometimes I think that after I write the type, my editor should just guess the function for me.
16:59:17 <ivanm> haskell-mode in emacs can help you do that
16:59:26 <Cale> ronwalf: That's on its way, I hope. See: http://www.cl.cam.ac.uk/~dao29/talks/haskell-type-constraints-10-fun.pdf
16:59:55 <ivanm> Cale: what's the TL;DR version?
16:59:57 <Cale> er, sorry, that's slides
17:00:17 <ivanm> (since I should have already gone to uni rather than stayng here discussing things via IRC, reading papers, etc.)
17:00:41 <Cale> ivanm: class constraint synonyms and synonym families do for classes what type synonyms and families do for datatypes
17:00:54 <ivanm> cool
17:01:25 <Cale> http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf -- I think this is it :)
17:02:23 <sproingie> haskell-mode + flymake = win
17:02:43 <sproingie> flymake is a bigger win with haskell since it does so darn much at compile-time
17:03:03 * ivanm heads off to uni
17:03:11 <ivanm> bye all
17:14:01 <ronwalf> Type constraint monstrosity: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26052#a26052
17:16:34 <dafis> ronwalf, wow :)
17:16:50 <ronwalf> I regularly have to set -fcontext-stack to prevent blowouts
17:17:04 <ronwalf> Blame Wouter
17:17:11 <ronwalf> I based this on his paper :)
17:17:18 <ronwalf> Plus someone's idea for extensible records
17:18:22 <ronwalf> Only 11 language extensions!
17:19:00 * dafis is duly impressed
17:19:18 <ronwalf> I was going for horrified, but OK
17:19:34 <dafis> ronwalf: That, too
17:20:05 <ronwalf> Turns out I've traded type safety for succinctness 
17:20:22 <ddarius> The question is more -which- extensions rather than how many (though there is a minimal number at which you -must- have enabled some unpleasant extension.) 
17:20:51 <ddarius> That said, I imagine you are using some less than nice extensions.
17:23:11 <ronwalf> ddarius: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26053#a26053
17:23:23 <ronwalf> Several of them are covered under -fglasgow-exts
17:23:44 <ronwalf> At one time I was using both undecidable and incoherent types
17:24:49 <ronwalf> sorry, UndecidableInstances, and apparently I still use them
17:25:24 <Cale> ronwalf: Undecidable instances is not so bad, incoherent is somewhat problematic.
17:32:28 <illissius> is there anyplace where IncoherentInstances is explained in greater detail, along with how to tell when it's safe to use? (i.e. "ghc is just being paranoid" as opposed to "I'm trying to do something fundamentally unsound")
17:33:27 <kmc> the manual explains it
17:33:47 <kmc> it's a subcase of overlapping
17:34:05 <kmc> in which you commit to a less-general instance now, but someone might call your function with a more specific type for which there is a more specific instance
17:34:09 <illissius> ...the manual was my reference point for "greater", fwiw
17:34:18 <kmc> ok
17:34:30 <kmc> everything i know about it is from reading the manual, though it took a while to decode
17:34:39 <illissius> so I guess maybe I should say "incoherentinstances for dummies" or something
17:42:28 <benmachine> illissius: let's see what lambdabot knows about incoherentinstances
17:42:31 <benmachine> @quote incoherent
17:42:31 <lambdabot> ghc says: Use -fallow-incoherent-instances
17:42:36 <benmachine> hmm
17:42:41 <benmachine> that was not what I was aiming for
17:42:42 <benmachine> @quote incoherent
17:42:42 <lambdabot> ghc says: Use -fallow-incoherent-instances
17:42:46 <benmachine> fff
17:42:54 <kmc> @vixen when should i be willing to use incoherent instances?
17:42:54 <lambdabot> maybe you should :)
17:42:59 <benmachine> @quote incoherentinstances
17:42:59 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
17:43:02 <benmachine> there we go
17:43:55 <illissius> frightening
17:44:39 <kmc> now you know the danger
17:45:58 <benmachine> there's also a quick silver quote somewhere I think
17:46:03 <benmachine> but I don't think lb has it
17:46:16 <kmc> illissius, would an incoherent-instances example help?
17:47:05 <dafis> benmachine, I think quicksilver's was about OverlappingInstances
17:47:28 <dafis> @quote OverlappingInstances
17:47:28 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
17:47:28 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
17:47:30 <benmachine> he says a lot of things
17:48:29 <illissius> Possibly. I think my problem may be more with understanding the tangled mess of type class hackery I've woven rather than with IncoherentInstances in general
17:49:31 <benmachine> 11:59:54<@quicksilver> overlapping actually shatters the language into tiny inconsistent pieces
17:49:38 <benmachine> 12:00:21<@quicksilver> and incoherent files off the edges of the pieces so they don't even fit together any more.
17:49:44 <kmc> haha
17:50:00 <kmc> illissius, what are you working on?
17:50:02 <benmachine> @remember quicksilver overlapping actually shatters the language into tiny inconsistent pieces, and incoherent files off the edges of the pieces so they don't even fit together any more.
17:50:02 <lambdabot> Good to know.
17:52:05 <gwern> ivan: @fish doesn't work; too long an edit distance away
17:52:07 <gwern> @flish
17:52:32 <illissius> kmc: tinkering with Qt bindings...
17:54:55 <Baughn> How does the "last core slowdown" work on hyper-threaded processors? Anyone tried benchmarking it?
17:58:51 <Baughn> benmachine: I wouldn't /need/ overlapping instances if I could say "a :-: Char".
17:59:35 <benmachine> Baughn: you just said it :O
17:59:41 <benmachine> but seriously, what?
18:00:39 <Baughn> I just made that up on the spot. I've never actually used overlapping instances except when deriving happstack things.
18:01:00 <Baughn> Still..
18:01:17 <Baughn> "instance Show a => Show [a], except when a is Char" could work
18:01:34 * Baughn has no idea if that would just cause more issues elsewhere, though
18:01:48 <kmc> ugh
18:01:55 <benmachine> sure it could, but instance Show a => Show [a] except for some exceptions I'll tell you about later
18:01:58 <benmachine> is just ew
18:02:12 <kmc> that's a good way to get incoherent instances too
18:02:42 <Baughn> Oh?
18:03:17 <illissius> kmc: does whether instances are incoherent depend only on how the instances themselves are defined? or also on how they're used?
18:03:59 <kmc> how they're used
18:04:36 <illissius> ok, that was my impression
18:05:47 <kmc> it happens when generalizing a function that wants to use the less-specific instance, but might be called at the more specific type
18:06:59 * Baughn wonders how far he can get with "class Foo a where foo :: a"
18:08:30 <Baughn> ..and if there was a language extension such that /all/ bindings in a module where effectively instances of such a class (one per binding name), but with instance definition scope limited to that module...
18:09:03 <Baughn> Um. Is there a name for that kind of thing already?
18:09:22 <aavogt> implicit parameters?
18:09:39 <Baughn> I don't /think/ so..
18:10:00 <Baughn> It sounds more like C++ function overloading, than anything else
18:10:04 <kmc> that's bad and you should feel bad ;P
18:10:13 <Saizan> yes, and it sounds just as bad.
18:10:36 <Baughn> So what to do about record names, then?
18:10:43 <Baughn> I'm getting real tired of writing dateTypeNameFieldName
18:10:47 <Saizan> however there is in fact a name for it "Type Directed Name Resolution", i think there's a proposal somewhere
18:10:53 <ddarius> Baughn: Use the module system.
18:11:41 <Baughn> ddarius: Doesn't help me when I need to access same-named fields in the same function.
18:11:53 <Baughn> Though there is that one record extension, I suppose
18:11:56 <Saizan> Baughn: it does if you import qualified
18:12:09 <ddarius> Baughn: It doesn't seem unreasonable to have to specify a name in that situation.
18:12:42 <Baughn> ddarius: Perhaps you're right. My data structures may be Doing It Wrong.
18:13:32 <Baughn> Trying to do a kind of sql-like table with multiple indexes.. naturally causes me to need multiple maps. But there is that one happstack thing for that, too.
18:13:54 * Baughn really likes the relational model, just not sql
18:14:08 <ddarius> Good thing they aren't related.
18:14:17 <djahandarie> @pl map (\f -> f 1 2 3 4) [const, flip const]
18:14:17 <lambdabot> [1 3 4, 2 3 4]
18:14:20 <Baughn> ..it's not /that/ bad.
18:14:27 <djahandarie> ...
18:14:35 <wli> Baughn: Wanting Prolog or some other logic language as a query language?
18:14:47 <Baughn> wli: Indeed.
18:14:58 <Baughn> wli: Or, you know, a /relational model/.
18:14:59 <djahandarie> @pl map (\f -> f a b c d) [g, h]
18:14:59 <lambdabot> [g a b c d, h a b c d]
18:15:08 <djahandarie> God damn it pl
18:15:20 <kmc> haha
18:15:26 <kmc> ask a stupid question, get a stupid answer ;P
18:15:37 <djahandarie> Oh
18:15:40 <ddarius> @pl \f -> f 1 2 3 4
18:15:41 <lambdabot> flip (flip (flip ($ 1) 2) 3) 4
18:15:53 <djahandarie> Yeah that's kind of annoying
18:15:57 <kmc> haha
18:15:59 * Baughn feels a great need to define a "flop" function
18:16:13 <djahandarie> Isn't there some clean way to do this?
18:16:18 <ddarius> Baughn: You can define it as the inverse to flip...
18:16:24 <djahandarie> "Apply some parameters to a list of functions"
18:16:33 <ddarius> djahandarie: What's wrong with your original code?
18:16:35 <Baughn> ddarius: Indeed.
18:16:43 <gwern> whoa, I didn't realize @pl took an entire directory in lambdabot
18:16:44 <djahandarie> ddarius, it's not pointless!
18:17:01 <gwern> maybe I should split that off as a separate library
18:17:05 <ddarius> gwern: It is an optimizing compiler.
18:17:06 <kmc> @pl (\f -> f a b c d)
18:17:06 <lambdabot> flip (flip (flip ($ a) b) c) d
18:17:16 <ddarius> gwern: Isn't it split off into a separate application?
18:17:26 <gwern> ddarius: I mean on the package level
18:17:32 <djahandarie> Wouldn't ($ a b c d) work if $ wasn't infixr?
18:17:40 <kmc> no
18:17:55 <kmc> (+ a b) is always going to be (+) (a b)
18:18:04 <kmc> application always associates tighter than infix operators
18:18:06 <djahandarie> Hm
18:18:10 <kmc> err
18:18:16 <gwern> > (+ 5 7) -- i can haz lithp?
18:18:17 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:18:17 <lambdabot>    arising from a use of `...
18:18:22 <kmc> (+ a b) is always going to be \x -> x + a b
18:18:24 <gwern> apparently not
18:18:45 <flippo> I'm not seing it
18:18:59 <Philonous> > (+ 5 7) 3
18:19:00 <lambdabot>   8
18:19:08 <djahandarie> lol
18:19:44 <Baughn> What the heck?
18:19:45 <djahandarie> It just seems like (\f -> f ...) should be easy to rewrite some other way
18:19:59 <Baughn> What happened to the 7?
18:20:09 <gwern> Baughn: I dunno either. it doesn't work in ghci or plain mueval
18:20:11 <kmc> > 2 3
18:20:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:20:12 <lambdabot>    `GHC.Num.Num t' arising f...
18:20:21 <djahandarie> > 2 3 :: Int
18:20:21 <ddarius> djahandarie: It is for the single argument case.  You can use curryN/uncurryN and get it.
18:20:22 <lambdabot>   2
18:20:23 <Philonous> Baughn: Num instances for Num b => (a -> b) have fromIntegral x = const x
18:20:23 <gwern> Baughn: maybe it has something to do the SimpleReflect stuff
18:20:31 <Baughn> djahandarie: Now you're scaring me.
18:20:33 <kmc> lambdabot has some cheeky instances loaded
18:20:34 <ddarius> It's still going to look ugly.
18:20:39 <kmc> > 2 'x'
18:20:40 <lambdabot>   2
18:20:44 <kmc> > 2 id
18:20:44 <lambdabot>   2
18:20:54 <Baughn> > id 2
18:20:54 <lambdabot>   2
18:20:54 <kmc> the all-devouring two!
18:20:56 <djahandarie> > 2 fix
18:20:56 <lambdabot>   2
18:21:01 <kmc> > 2 undefined
18:21:02 <lambdabot>   2
18:21:03 <ddarius> > fix 2
18:21:04 <lambdabot>   2
18:21:06 <ddarius> All better.
18:21:06 <kmc> haha
18:21:09 <Baughn> > break 2
18:21:10 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
18:21:10 <lambdabot>    arising from the literal `2'...
18:21:16 * gwern bows down and worships
18:21:18 <benmachine> > [f, g] <*> pure a <*> pure b <*> pure c
18:21:19 <lambdabot>   Ambiguous type variable `b' in the constraints:
18:21:19 <lambdabot>    `GHC.Show.Show b'
18:21:19 <lambdabot>      a...
18:21:22 <benmachine> > [f, g] <*> pure a <*> pure b <*> pure c :: Expr
18:21:23 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:21:23 <lambdabot>         against inferred ...
18:21:26 <benmachine> :(
18:21:31 <Baughn> I broke it! Yay!
18:22:16 <benmachine> > [f, g] <*> pure a <*> pure b <*> pure c :: [Expr]
18:22:17 <lambdabot>   [f a b c,g a b c]
18:22:27 <djahandarie> That's nice
18:22:40 <djahandarie> Go applicatives!
18:22:45 <SubStack> neat!
18:22:46 <Baughn> I much preferred your original
18:23:13 <benmachine> I had an original?
18:23:39 <Baughn> No, you're just a copycat. djahandarie had an original.
18:23:47 <benmachine> oh
18:24:15 <benmachine> zmew
18:24:17 <benmachine> -z
18:25:22 <djahandarie> > [f, g] <*> [a] <*> [b] <*> [c] :: [Expr]
18:25:23 <lambdabot>   [f a b c,g a b c]
18:25:30 <djahandarie> @src <*>
18:25:30 <lambdabot> Source not found. You speak an infinite deal of nothing
18:25:35 <djahandarie> @src (<*>)
18:25:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:25:39 <djahandarie> lol
18:25:59 <benmachine> @src [] <*>
18:25:59 <lambdabot> Source not found. :(
18:26:22 <djahandarie> Yeah, would need the instance anyways
18:26:29 <benmachine> @src [] (<*>)
18:26:29 <lambdabot> (<*>) = ap
18:26:38 <benmachine> oh, thx
18:26:59 <djahandarie> > [f,g] `ap` [a] :: [Expr]
18:26:59 <lambdabot>   [f a,g a]
18:28:06 <kmc> @pl \f g -> [f,g]
18:28:06 <lambdabot> (. return) . (:)
18:28:12 <kmc> @pl \f g h -> [f,g,h]
18:28:12 <lambdabot> (. ((. return) . (:))) . (.) . (:)
18:29:35 <Axman6> > [f,g] <*> [a,b] <*> [c,d] :: [Expr]
18:29:36 <lambdabot>   [f a c,f a d,f b c,f b d,g a c,g a d,g b c,g b d]
18:30:03 <Olathe> Is there a way to specify a default instance for a class (like Integral has Integer as a default) ?
18:30:39 <kmc> Olathe, not in general; there are some hacky special rules for numeric classes
18:32:27 <Olathe> Ahh
18:32:31 <Olathe> Alright, thanks.
18:33:34 <Philonous> > let x = 3; y=x "foo" in x
18:33:35 <lambdabot>   3
18:33:37 <aavogt> if you type `a' has Num a =>, you can set the default with  default
18:33:41 <Philonous> @type let x = 3; y=x "foo" in x
18:33:42 <lambdabot> forall t. (Num t) => t
18:33:50 <aavogt> that keyword nobody uses
18:33:58 <Philonous> Where is the monomorphism restriction when you need it
18:34:55 <aavogt> @type case 3 of x -> case x "foo" of _ -> x
18:34:56 <lambdabot> forall t. (Num ([Char] -> t)) => [Char] -> t
18:35:11 <aavogt> Philonous: use case
18:35:17 <aavogt> or lambdas
18:35:35 <Philonous> Oh, fair enough. Thanks.
18:35:51 <Philonous> > case 3 of x -> case x "foo" of _ -> x
18:35:52 <lambdabot>   *Exception: show: No overloading for function
18:36:25 <aavogt> > show (
18:36:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:36:29 <aavogt> > show (\x -> x)
18:36:30 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
18:36:30 <lambdabot>    arising from a use of `...
18:36:41 <dcoutts_> jrockway: ping
18:37:05 <aavogt> that's unfortunate since the smallcheck instance for functions can't work anymore
18:40:51 <djahandarie> > let apr x y = ap x (return y) in foldl1 apr [[const,const,const], 1, 2]
18:40:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = m (a -> b)
18:40:57 <djahandarie> Ah, damn
18:41:31 <BMeph> Haskell needs a reserved word for at least "locally closing" type classes (if you get my drift...)
18:42:42 <djahandarie> :t (. return) . ap
18:42:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
18:42:49 <benmachine> aren't they... GADTs, or something?
18:43:05 * benmachine has a vague idea that there was a pre-existing idea that corresponded to closed type classes
18:43:35 <BMeph> @type flip
18:43:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:43:47 * BMeph wins! \o/
18:43:59 <djahandarie> Heh
18:44:03 <djahandarie> Knew I had seen it somewhere
18:44:49 <Philonous> BMeph: What? Caleskell doesn't count!
18:45:00 <Philonous> @src flip
18:45:00 <lambdabot> flip f x y = f y x
18:45:04 <benmachine> :t flip (\x -> fmap ($ x))
18:45:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
18:45:16 <benmachine> :t \y x -> fmap ($ x) y
18:45:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
18:45:51 <djahandarie> > [f, g] `flip` a `flip` b :: [Expr]
18:45:52 <lambdabot>   [f a b,g a b]
18:45:56 <djahandarie> nifty
18:47:09 <BMeph> It's like a weird variation on costrength...if only I knew enough CT to figure out what C it goes to - probably something Braided...
18:49:52 <alexyk> is there a library function to partition a list of tuples by the second element?
18:50:37 <BMeph> djahandarie: I like that; I imagine the "flip" function giving "a" and "b" a boster over the prison walls of the list bracket...
18:50:54 <aavogt> @hoogle partition
18:50:54 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
18:50:54 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
18:50:54 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
18:50:56 <djahandarie> Hahaha
18:51:09 <aavogt> there's one in Data.List too
18:51:43 <alexyk> I mean as clojure's partition-by, which creates a list of lists where in each sublist the predicate has the same value, not necessarily boolean
18:52:16 <aavogt> @type group
18:52:16 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
18:52:20 <aavogt> @type sort
18:52:21 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:52:36 <alexyk> yay
18:52:46 <aavogt> though maybe you want the  *By versions of those
18:53:03 <alexyk> that's what's good about Haskell: bizzarrely humongous library!
18:53:14 <alexyk> pedantically complete
18:53:35 <BMeph> @type groupBy
18:53:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
18:54:01 <aavogt> well there is no function:    \p -> groupBy p . sortBy p
18:54:34 <BMeph> alexyk: Eh, it's a library! If it isn't complete, you (e.g., Data.List.Split) write one yourself! :)
18:55:09 <alexyk> BMeph: I know, I know, I just prefer the fully stuffed libraries, 's all :)
18:55:23 <BMeph> alexyk: ...
18:55:39 <BMeph> alexyk: Well, then, "stuff it, yourself!" ;
18:55:40 <alexyk> ocaml used to have a puny one before Batteries, and clojure is under heavy rework, though it looks awesomer by day
18:56:01 <alexyk> BMeph: dangerous comma! :)
18:56:23 * alexyk finds translating from clojure inflates the line count
18:56:31 <BMeph> alexyk: Yeah, I lapsed into it... ;
18:57:11 <aavogt> code can be more concise the better you know the language
18:57:46 <alexyk> aavogt: I'll cross-post the two versions to the two lists for clojure and haskell... 
18:57:49 <BMeph> @type liftM2 groupBy sortBy p
18:57:50 <lambdabot>     Couldn't match expected type `[a] -> Bool'
18:57:50 <lambdabot>            against inferred type `[a]'
18:57:50 <lambdabot>     Probable cause: `sortBy' is applied to too many arguments
18:57:57 * alexyk anticipates polyglot golfiong
18:58:00 <alexyk> golfing
18:58:45 <aavogt> haskell is at bit of a disadvantage due to less overloading/polymorphism in standard library functions
18:58:45 <alexyk> but clojure can beat haskell as you don't need to indent and () are shorter
18:59:03 <alexyk> aavogt: yeah, clojure has most things obeying the seq
18:59:05 <aavogt> you may use {;} instead of layout
18:59:34 <alexyk> aavogt: I'm OK with ML syntax, and in fact switch to camelCase for authentic feel
18:59:43 <alexyk> btw Ocaml folks don't do camelcase
18:59:45 <alexyk> IIRC
18:59:51 <alexyk> so you don't have to do it
19:00:02 <alexyk> ML /= camelCase
19:00:04 <aavogt> a_of_b
19:00:09 <alexyk> yay!
19:00:14 <alexyk> a'of'b
19:05:59 <alexyk> :t groupBy
19:06:00 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:06:26 <alexyk> > groupBy (\(_,x) (_,y) -> x == y) [(1,2),(2,2),(1,3)]
19:06:27 <lambdabot>   [[(1,2),(2,2)],[(1,3)]]
19:07:16 <alexyk> is there a shorter way to express the lambda above?
19:07:19 <BMeph> > groupBy (equating snd) [(1,2),(2,2),(1,3)]
19:07:20 <lambdabot>   [[(1,2),(2,2)],[(1,3)]]
19:07:25 <djahandarie> Damn, beat me to it
19:07:26 <alexyk> :)
19:07:33 <BMeph> alexyk: ...why, yes there is! ;)
19:08:00 <alexyk> :t equating
19:08:01 <lambdabot> forall a b. (Eq b) => (a -> b) -> a -> a -> Bool
19:08:37 <benmachine> :t liftM2 (.) groupBy sortBy
19:08:38 <lambdabot>     Couldn't match expected type `Bool'
19:08:38 <lambdabot>            against inferred type `Ordering'
19:08:38 <lambdabot>       Expected type: a -> a -> Bool
19:08:41 <benmachine> whatever
19:09:13 <smarmy> hmmmm... i ended up with...
19:09:15 <smarmy> :t groupBy (curry $ (fst *** fst) >>> uncurry (==))
19:09:16 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
19:09:24 <smarmy> aparently i like things to be needlessly complicated
19:09:57 <smarmy> s/fst/snd/
19:10:28 <alexyk> smarmy: that can make an aspiring haskell learner go drinking instead :)
19:10:36 <aavogt> where is equating?
19:10:39 <alexyk> yeah
19:10:44 <alexyk> gimme equating
19:10:48 <aavogt> @hoogle equating
19:10:48 <lambdabot> No results found
19:10:55 <aavogt> @type (==) `on` snd
19:10:55 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
19:10:59 <alexyk> same here!  I scream fraud!
19:11:07 <aavogt> there is comparing
19:11:19 <alexyk> lambdadot is full on counterfeit functions
19:11:22 <alexyk> of
19:11:25 <alexyk> bot
19:11:28 <djahandarie> @type on (==)
19:11:29 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
19:12:49 <aavogt> > map length ["on (==) snd","equating"]
19:12:50 <lambdabot>   [11,8]
19:13:03 <aavogt> > map length ["on(==)snd","equating"]
19:13:04 <lambdabot>   [9,8]
19:13:32 <dafis> > map length ["on (==)","equating"]
19:13:33 <lambdabot>   [7,8]
19:14:06 <aavogt> > map length ["on(==)snd","equating snd","\(_,x)(_,y)->x==y"]
19:14:07 <lambdabot>   <no location info>:
19:14:07 <lambdabot>      lexical error in string/character literal at chara...
19:14:15 <aavogt> > map length ["on(==)snd","equating snd","\\(_,x)(_,y)->x==y"]
19:14:15 <lambdabot>   [9,12,17]
19:15:36 <alexyk> ok how do we compose (equating snd) form (==) and snd?
19:15:38 <alexyk> from
19:15:56 <dafis> (==) `on` snd
19:16:06 <alexyk> :t on
19:16:07 <dafis> or on (==) snd
19:16:07 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:16:32 <dafis> but on is meant for infix use
19:16:48 <benmachine> really annoying thing about on: fixity 0
19:16:52 <benmachine> screws with my $s
19:16:58 <benmachine> so infix on is overrated
19:17:53 <BMeph> :i on
19:17:53 <dafis> benmachine, yes, but it reads better infix
19:18:09 <alexyk> we still need to find out who slipped the fake equating onto da bot
19:18:49 <aavogt> @undefine
19:18:58 <aavogt> @type equating snd
19:18:58 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
19:19:20 <dafis> @info on
19:19:20 <lambdabot> on
19:19:29 <benmachine> @info isn't a thing
19:19:29 <lambdabot> isn't a thing
19:19:35 <benmachine> @hoogle equating
19:19:35 <lambdabot> No results found
19:19:40 <benmachine> @index equating
19:19:40 <lambdabot> bzzt
19:19:41 <alexyk> see!
19:19:44 <benmachine> bzzt
19:20:01 <alexyk> @wtf 
19:20:02 <lambdabot> Maybe you meant: bf ft wn
19:20:09 * gwern feel likes telling a joke
19:20:20 * alexyk feels like saying ok
19:20:29 * BMeph feels with his fingers!
19:20:32 <Philonous> @arr
19:20:32 <lambdabot> Keelhaul the swabs!
19:20:38 <gwern> so, a man starts cutting up rusty in a bar, and the police are called in
19:20:50 <gwern> the man defends himself, saying that he's actually a bear
19:21:02 <gwern> it's no crime for a bear to be rough - that's just how they are, no?
19:21:14 <gwern> well, then, the officer says, where is your fur?
19:21:24 <gwern> Ah, I left my fur home tonight, the man says
19:21:37 <gwern> the officer nods, and begins cuffing him and reading him his rights
19:21:50 <gwern> but officer! you can't arrest a bear for assault!
19:22:02 <gwern> I'm not arresting you for assault; I'm arrest you for indecent exposure
19:22:28 <dafis> gwern: nice :)
19:22:42 * BMeph appreciates the souds of crickets chirping...
19:23:04 * BMeph dropped an 'n' from 'sounds', there.
19:23:24 <alexyk> apparently, souds are them chirping tentacles
19:23:26 <gwern> (at least dafis liked it)
19:24:16 <aavogt> is there supposed to be a pun in there?
19:24:25 <BMeph> gwern: Sorry; I grew up in Arizona. There, indecent exposure isn't a crime, it's a punishment. ;)
19:24:47 <gwern> aavogt: if he's a bear and left his fur at home, then he's naked...
19:25:09 <aavogt> he's also an animal who has negligible rights
19:25:32 <alexyk> let's all compose a real pun: what the bear/man replies to the pre-pun
19:26:07 <gwern> 'I'm not arresting you for assault; I'm arresting you for bearing arms without a permit.'
19:26:24 <gwern> alexyk: that good enough?
19:26:43 <alexyk> gwern: warmer :)
19:27:22 * BMeph respects the right to arm bears...
19:27:47 * Axman6 does also, and is wearing a t-shirt
19:27:56 <benmachine> I'm wearing a t-shirt
19:28:19 <benmachine> also gwern I didn't laugh at your joke but I still liked it
19:28:19 * dafis is wearing a perspiration shirt
19:28:22 <benmachine> it made me smile inside
19:28:31 <benmachine> dafis: is that just like a normal shirt, but for longer?
19:28:51 <JoeyA> In order to use fmap and the like on a custom Monad, does one have to make it an instance of Functor and implement fmap?
19:29:01 <benmachine> yes
19:29:07 <dafis> benmachine, BFBS expression for sweat shirt
19:29:20 <benmachine> however, if it's already a monad, you're free to use fmap = liftM
19:29:47 <benmachine> dafis: BFBS?
19:30:06 <dafis> however, a direct implementation of fmap may be more efficient than liftM
19:30:14 <benmachine> it may indeed be so
19:30:29 <dafis> benmachine, British Forces Broadcasting Service
19:30:34 <benmachine> oh ok
19:30:45 <benmachine> I googled it and got that
19:30:52 <benmachine> but I didn't get why they'd have expressions for stuff
19:31:37 <BMeph> benmachine: Because "thingy" only gets you so far... ;)
19:31:49 <benmachine> <_<
19:32:03 <gwern> BMeph: we just need to reiterate 'thingy'
19:32:12 <gwern> assign each thing a unique number of 'thingy's
19:32:50 <gwern> for example, gwern could be 'thingy', respect and veneration for gwern could be 'thingy thingy', the verb for serving gwern could be 'thingy thingy thingy' and so on and so forth
19:32:58 <gwern> basic unary
19:33:34 <dafis> thingy, I thingy thingy thingy thingy
19:33:53 <gwern> well spoken
19:33:54 <aavogt> > fix ("thingy "++)
19:33:54 <lambdabot>   "thingy thingy thingy thingy thingy thingy thingy thingy thingy thingy thin...
19:34:39 <benmachine> gwern: but that only allows you to describe countably many things!
19:35:01 <Axman6> > fix ( ++ "thingy")
19:35:02 <gwern> benmachine: I can count on no hands the number of times I've needed to describe uncountably many things
19:35:04 <lambdabot>   mueval-core: Time limit exceeded
19:35:09 <dafis> benmachine, isn't the universe finite?
19:35:27 <theorbtwo> Your computer certianly is.
19:35:27 <benmachine> dafis: it's certainly at least a hundred miles across
19:35:50 <alexyk> how about that: the man opens a giant mouth, bites the head off the officer, burps, and says: a naked bear can still bite
19:35:56 <dafis> benmachine, but is more than twenty miles long?
19:36:16 <benmachine> gwern: is the number of fingers on no hands like the number of functions between empty sets?
19:36:21 <aavogt> you can talk about uncountable things with countably many words
19:36:38 <benmachine> aavogt: but not an uncountable number of them
19:36:40 <gwern> benmachine: I think it's more like zero fingers on indefinitely many hands
19:36:42 <benmachine> at least, not individually
19:36:53 <gwern> alexyk: eh. too abruptly murderous
19:36:56 <aavogt> does anybody?
19:37:21 <dafis> aavogt, does anybody what?
19:37:47 <aavogt> name uncountable numbers of things individually
19:37:56 <jrockway> dcoutts_: pong
19:38:06 <benmachine> not using a countable number of words!
19:38:10 <dcoutts_> jrockway: re the c2hs patch
19:38:52 <alexyk> gwern: opens a giant mouth, roars, and warns the officer: ... then the story continues until the kids are properly terrified
19:38:54 <dcoutts_> jrockway: looks good, would you like to submit a darcs patch? if you do the only minor change I might suggest is to use a new enum type for the calling convention rather than using String
19:39:33 <jrockway> ok, sure, sounds like a good idea
19:39:49 <dcoutts_> jrockway: great, thanks
19:40:06 <jrockway> btw, i noticed something weird in c2hs today
19:40:19 <jrockway> apparently my cpp spits out lines like ``# 1 "foo.h"''
19:40:24 <jrockway> and this breaks c2hs completely
19:40:44 <jrockway> have you ever seen this?  (i upgraded from the 6.10 haskell platform to 6.12, but i'm not really sure what changed other than that)
19:40:48 <jrockway> anyway, if not, i will investigate
19:40:55 <jrockway> it makes me happy to know that c2hs is maintained again :)
19:41:05 <dcoutts_> jrockway: btw, the darcs repo is now at http://code.haskell.org/c2hs/
19:41:43 <dcoutts_> jrockway: it's always had maintainers, just busy ones :-)
19:41:44 <JoeyA> When an operator's fixity isn't given, does it default to 5?
19:41:58 <dafis> JoeyA: to infixl 9
19:42:10 <dcoutts_> jrockway: what's odd about # 1 "foo.h" ? that's normal isn't it?
19:42:15 <jrockway> i guess
19:42:28 <jrockway> all my test cases are on my work machine (which i can't irc from)
19:42:41 <jrockway> but it says something like "lexical analyzer: you can't have a '#' here" at line 1 col 1
19:42:54 <jrockway> need to get things working on my home machine, then i can debug more intelligently
19:43:17 <dcoutts_> jrockway: oh I wonder if it's something to do with it being the first line of the file
19:43:47 <jrockway> could be
19:43:51 <jrockway> i wonder why it used to work though
19:44:26 <jrockway> i will let you know what i find :)
19:44:42 <jrockway> now that someone on irc admits to using c2hs, i am motivated to send patches :)
19:46:12 <dcoutts_> jrockway: actually I don't use it much atm, just one of the maintainers :-)
19:46:29 <dcoutts_> I used to use it more when I helped maintain gtk2hs
19:46:45 <jrockway> interesting
19:47:02 <jrockway> when i was looking for FFI helpers earlier in the year, it seemed like it was the "best" of the various solutions
19:47:04 <dcoutts_> I don't see anything wrong with the lexer for # line pragmas
19:47:11 <jrockway> (erm, greencard or doing it manually, i guess)
19:47:37 <dcoutts_> jrockway: when it fits the problem it's great, it's also slightly frustrating in places
19:48:24 <dcoutts_> jrockway: e.g. {# fun #} hooks are not brilliant, and structure offsets are dodgy, but {# call #} and the {# pointer #} stuff is excellent
19:48:57 <jrockway> ahh, thanks for reminding me
19:49:05 <jrockway> i recall problems with the structure offsets
19:49:13 <jrockway> i think i ended up writing my own instances for structures
19:49:27 <dcoutts_> jrockway: for gtk2hs, we used hsc2hs for Storable instances and c2hs for function calls
19:50:06 <jrockway> ah, ok
19:50:11 <dcoutts_> for sizes and struct offsets it really needs a comprehensive testsuite
19:50:17 <jrockway> my approach would not have scaled to more than 2 structs, but that's all this library had
19:50:32 <jrockway> (yay for c programmers and "every conceivable thing goes in one struct", i guess)
19:50:36 <dcoutts_> something that compares what the C compiler thinks with what c2hs thinks, for every .h and .c file you throw at it
19:50:47 <dcoutts_> then compile a whole gentoo system for testing :-)
19:51:13 <dcoutts_> that's how I tested the C parser when I rewrote it
19:51:33 <jrockway> nice
19:51:47 <jrockway> i just need to go back in time and include my weird cpp output in your test setup ;)
19:51:59 <dcoutts_> heh, apparently so
19:54:42 <A1kmm> I'm trying to write a FFI interface using bindings-DSL, and have a C function which calls a callback which returns a void*, which is returned from the function. I'd like to make the void* map to a type parameter in Haskell.
19:54:48 <A1kmm> Anyone know how I can do that?
19:55:44 <A1kmm> (I tried the following:
19:55:53 <A1kmm> #callback ekOptimizerCallback_t a, Ptr <ekOptimizer> -> IO a
19:55:55 <A1kmm> #ccall withEkOptimizer a, CSize -> ekOptimizerCallback_t a -> IO a but it doesn't work)
19:56:49 <jrockway> FWIW, i usually have my FFI functions return something C-like, and then I haskell-ize it in a separate function
19:57:10 <jrockway> i.e. autogenerate foo', and then write foo which calls foo' and makes the valuable sane
19:57:16 <jrockway> (unless c2hs does it for me automatically, of course ;)
19:58:04 <alexyk> do $ eval right to left?
19:58:13 <alexyk> f $ g $ x
19:58:45 <Philonous> > f $ g $ h :: Exp
19:58:46 <lambdabot>   Not in scope: type constructor or class `Exp'
19:58:51 <Philonous> > f $ g $ h :: Expr
19:58:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:58:52 <lambdabot>    `SimpleReflect.FromExpr ...
19:58:55 <jrockway> haha
19:59:17 <alexyk> > succ $ pred . pred $ 3
19:59:17 <A1kmm> jrockway: I'm planning on doing that anyway to make it into a pure wrapper, and call unsafePerformIO... but I'm not sure of a clean way to do the callback thing at all.
19:59:18 <lambdabot>   2
19:59:48 <Saizan> "evaluation" is orthogonal, but it does associate to the right
20:00:01 <Saizan> i.e. f $ g $ x = f (g x)
20:00:04 <alexyk> assoc, right
20:00:26 <jrockway> A1kmm: yeah, not really sure about that
20:00:30 <alexyk> so is f $ g $ x <=> f . g $ x ?
20:00:37 <Saizan> yes
20:00:46 <alexyk> good
20:01:52 <djahandarie> > ask "hi"
20:01:52 <lambdabot>   "hi"
20:01:59 <djahandarie> Why does that work?
20:02:27 <scott_> @src ask
20:02:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:02:36 <scott_> @type ask
20:02:37 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
20:02:41 <djahandarie> It's from Control.Monad.Reader.Class
20:04:01 <scott_> @instances MonadReader
20:04:01 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
20:05:30 <BMeph> djahandarie: Why shouldn't it work? :)
20:06:05 <djahandarie> ask evaluates to a value, and then you apply a value to a value, why would it work?
20:06:41 <BMeph> djahandarie: Ask isn't just a value, it's an action. :)
20:06:57 <BMeph> s/Ask/"ask"/
20:06:58 <djahandarie> Oh, is it assuming the IO monad?
20:07:38 <BMeph> djahandarie: Maybe it's assuming the first option, the ((->) r) r monad. :)
20:07:57 <BMeph> djahandarie: I.e., m r :: (r -> r)
20:08:06 <djahandarie> Ah
20:08:09 <alexyk> does elemAt in Data.Map return in sorted or implementation order?
20:08:34 <BMeph> alexyk: s/implementation/insertion/, maybe? :)
20:09:05 <alexyk> BMeph: hmm
20:09:15 * kmc seems to have angered ld
20:09:46 <alexyk> kmc: not super ego?
20:10:03 <kmc> that's a good name for an alternative linker
20:10:07 <kmc> better than "gold" anyway
20:13:50 <alexyk> does emacs mode parse error and place you at them in the source?
20:14:43 * alexyk hears shoulders shrug and wonder where are the emacs zealots
20:17:57 * JoeyA is writing his first monad
20:18:33 <JoeyA> Well, technically, the _first_ one was the one Cale walked me through a week or two ago.
20:18:36 <gwern> alexyk: it should be able to jump if you hit enter on the error line in the ghic buffer
20:18:53 <gwern> alexyk: so you could write a hook on C-c c-l...
20:19:09 <alexyk> hmm
20:19:09 <gwern> if it doesn't have an option to already do that
20:19:41 <gwern> a hook which runs an i-search and c-j may not be the prettiest solution, but you knew when you married emacs that life wouldn't be a rose of gardens!
20:19:44 <gwern> or something like that
20:20:23 <aavogt> oO rose of garden
20:20:33 <aavogt> it goes the other way too :)
20:21:40 <gwern> a rose among gardens, a mensch 'midst jewels, a print amongst paintings!
20:28:14 <lispy_> So, how do I contact the planet haskell admins?
20:28:21 <lispy_> It looks like the email address on the main page is broken
20:28:34 <lispy_> after some 4 days or so of undelivered mail, it gave up
20:29:21 <lispy_> the address they say to use is planet at community dot haskell .org
20:30:51 <gwern> lispy_: was the failure coicident with the past downtime?
20:31:11 <lispy_> gwern: yes, but it retried after haskell.org was back up, and community is a different machine
20:31:29 <lispy_> I'm writing an email to -cafe now, and I'll include that
20:46:33 <jbapple> lispy_: When I emailed planet, I got a response from Antti-Juhani Kaijanaho
20:47:19 <lispy_> jbapple: was this recently?
20:47:38 <jbapple> lispy_: yes
20:47:53 <jbapple> http://users.jyu.fi/~antkaij/
20:48:12 <jbapple> except that's not the email address he emailed me from
20:48:29 <jbapple> I don't want to paste it in the irc, because of logs and spam
20:48:58 <lispy_> jbapple: I have their address in my gmail
20:49:02 <jbapple> ok
20:49:17 <lispy_> jbapple: Thanks for the lead, I'll forward my original request to them
20:51:31 <lispy_> jbapple: is it a .fi address?
20:51:41 <lispy_> The address I have is several years old
20:52:05 <jbapple> a kaijanaho.fi address
20:52:20 <lispy_> cool, that's what I have
20:57:13 <alexyk> how do you change just one field in a record?
20:59:49 <ClaudiusMaximus> alexyk: \x -> x{ fieldName = newValue }
20:59:59 <alexyk> thx
21:01:13 <ClaudiusMaximus> but, you can't do \n -> x{ n = v } for example, which gets to be a pain if you have a lot of records (you have to build your own setter functions)
21:11:07 <EvanR> > 3 `div` 0
21:11:08 <lambdabot>   *Exception: divide by zero
21:12:30 <lispy_> > fix (3 `div`)
21:12:34 <lambdabot>   mueval-core: Time limit exceeded
21:12:47 <lispy_> > fix (1 `div`)
21:12:51 <lambdabot>   mueval-core: Time limit exceeded
21:12:57 <lispy_> Shouldn't that be 1?
21:13:13 <dmwit> div is strict
21:13:41 <dmwit> ...and the least fixpoint of any strict function is bottom
21:14:01 <lispy_> That kind of makes sense
21:14:13 <lispy_> > iterate (1 `div`) 1
21:14:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:14:40 <dmwit> It's a little weird, I know. =)
21:15:00 <dmwit> > fix (1 `div`) :: Natural
21:15:00 <lambdabot>   Not in scope: type constructor or class `Natural'
21:15:04 <dmwit> hm
21:15:06 <dmwit> > O
21:15:07 <lambdabot>   Not in scope: data constructor `O'
21:15:11 <dmwit> oh, bugger
21:15:17 <lispy_> > iterate (1 `div`) 1 :: [Expr]
21:15:18 <lambdabot>   [1,1 `div` 1,1 `div` (1 `div` 1),1 `div` (1 `div` (1 `div` 1)),1 `div` (1 `...
21:15:57 <lispy_> > iterate (1 `div`) 1 :: [Nat]
21:15:58 <lambdabot>   Not in scope: type constructor or class `Nat'
21:16:30 <dmwit> > Zero
21:16:31 <lambdabot>   Not in scope: data constructor `Zero'
21:16:42 <dmwit> > infinity
21:16:43 <lambdabot>   Not in scope: `infinity'
21:17:25 <lispy_> Does Haskell have a version of mod for RealFrac?
21:17:30 <lispy_> Like C's fmod
21:17:50 <lispy_> (by RealFrac I just mean Double/Float)
21:18:25 <dmwit> > properFraction (3 / 2.5)
21:18:26 <lambdabot>   (1,0.19999999999999996)
21:19:26 <dmwit> > let fmod x y = let (_, f) = properFraction (x / y) in f * y in fmod 3 2.5
21:19:27 <lambdabot>   0.4999999999999999
21:20:01 <dmwit> > mod' 3 2.5
21:20:02 <lambdabot>   0.5
21:20:23 <dmwit> There you have it! mod'
21:20:27 <lispy_> cool
21:20:31 <lispy_> :t mod'
21:20:32 <lambdabot> forall a. (Real a) => a -> a -> a
21:45:43 <jbhatta> sorry, noob question: http://pastebin.ca/1880170
21:45:51 <jbhatta> oops
21:46:28 <jbhatta> http://pastebin.ca/1880172
21:47:13 <jbhatta> infinite type error on products [x]
21:47:17 <jbhatta> but [x] is a singleton...?
21:48:18 <aavogt> jbhatta: your problem is line 4
21:48:41 <aavogt> @type \x -> x:x
21:48:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
21:48:42 <lambdabot>       Expected type: [a]
21:48:42 <lambdabot>       Inferred type: a
21:49:08 <aavogt> you should use ++ there
21:49:25 <jbhatta> oh!  : takes an element on the left and a list on the right?
21:49:46 <jbhatta> my bad
21:49:54 <aavogt> or simplify your cases to: http://pastebin.ca/1880175
21:50:11 <aavogt> also, why the excessively specific type?
21:50:43 <aavogt> it's probably even better to write that in terms of library functions
21:50:57 <aavogt> @type map (uncurry (*))
21:50:58 <lambdabot> forall a. (Num a) => [(a, a)] -> [a]
21:51:01 <jbhatta> this was a cleaned-up example of a function being written in a tutorial
21:51:14 <jbhatta> i didn't want to include all the extra implementation detail
21:51:18 <aavogt> well it's still not clean
21:53:05 <jbhatta> ok, thanks
22:07:21 <jbhatta> http://pastebin.ca/1880184
22:07:44 <jbhatta> aavogt: is there a better way to do pairMap?
22:08:00 <aavogt> @type uncurry
22:08:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
22:10:26 <jbhatta> ohhhhhhhhhhhhhhhhhhhhhhhhh, i get uncurry now
22:10:30 <jbhatta> ok, thanks
22:24:22 <danharaj> Will Haskell ever see uniqueness types?
22:24:32 <danharaj> I think they might be an interesting extension to experiment with.
22:24:55 <ddarius> Why not experiment with them in Clean?
22:25:25 <danharaj> Because I don't want to leave my playground to go to another one.
22:25:27 <danharaj> :|
22:27:26 <ddarius> I think some kind of substructural type system would be an interesting direction for Haskell, but between the details being vague and the fact that getting significant benefit would require rewriting most of the libraries, I don't believe it will ever happen.
22:28:06 <tensorpudding> Maybe in the language that supplants Haskell
22:28:09 <danharaj> well isn't uniqueness typing implicit in Clean?
22:28:19 <aakarsh> hi , was wondering where i can find source code for the prelude 
22:28:23 <ddarius> danharaj: I don't know what you mean, but no.
22:28:25 <aakarsh> is it part of ghc code base
22:28:34 <danharaj> ddarius: inferred by the compiler, at least in some cases
22:28:41 <danharaj> (rather, the type checker)
22:28:56 <aavogt> @where report
22:28:56 <lambdabot> http://www.haskell.org/onlinereport/
22:29:12 <ddarius> danharaj: Yes, it can be inferred, but so can types in Haskell.  That doesn't mean you don't need to write your code a certain way to get a benefit.
22:29:27 <tensorpudding> Does GHC use the real report?
22:29:34 <tensorpudding> I was under the impression that it didn't.
22:29:37 <danharaj> ddarius: Ah I see, it is not idiomatic haskell to write code that exposes uniqueness
22:30:34 <ddarius> danharaj: It's not a matter of "exposing" but of getting it there in the first place.
22:31:01 <tensorpudding> It's rather awful that the GHC docs for the Prelude source don't seem to work
22:31:48 <aavogt> tensorpudding: the Prelude in base just re-exports stuff from elsewhere
22:31:58 <danharaj> ddarius: it's late >_<
22:32:22 <aavogt> so looking at the source of the Prelude.hs isn't helpful... though haddock's links to function implementations should be good
22:33:21 <aakarsh> k
22:34:41 <ddarius> danharaj: If you really want uniqueness types in Haskell, implement them as a low-level analysis in GHC for optimization purposes.  Add to external core some syntax to support them.  Finally, hope that it "trickles up" to the language level.
22:34:45 <tensorpudding> presumably the source to GHC would have it
22:34:55 <tensorpudding> but that's a bit of large download
22:35:10 <aavogt> you only need to look at base, tensorpudding
22:35:26 <danharaj> ddarius: maybe as a big project sometime in the future :p
22:35:30 <aavogt> http://darcs.haskell.org/libraries/base/
22:37:09 <danharaj> ddarius: do you think un    02beI,kfL,lj,psmntirRcOAQKVCuzNSMTG perfomance benefits?
22:37:11 <danharaj> what the
22:37:36 <danharaj> do you think that uniqueness types could confer worthwhile performance benefits?
22:37:45 * danharaj has no idea what just happened
22:38:57 <ddarius> danharaj: It's probably not worth the effort for the gains that would be had from a purely "automatic" system, but that's why you'd expose it in the (external) core and why it might actually trickle up.
22:41:39 <danharaj> ddarius: I don't know how much you know about this, but it seems to me from preliminary research that uniqueness types annotate sort of 'historical usage conditions'  while linear types annotate 'future usage conditions' is this at face value correct?
22:42:29 <ddarius> I guess that's one way of thinking about it.
22:43:24 <danharaj> actually I am doubting myself now...
22:43:29 <danharaj> It doesn't seem like a very useful perspective.
22:43:31 * danharaj hits head
22:45:00 <ddarius> danharaj: It seems reasonable enough.  I'm just not exactly sure what all those terms mean to you, but it does seem roughly correct.
23:03:57 <Peaker> Funny, this guy trying to show how much Haskell sucks by pasting some Java code that manipulates tree nodes in-place. I posted 1-to-1 translation of his Java code to Haskell using IORefs. http://www.reddit.com/r/programming/comments/ccdg3/a_little_help_on_this_haskellrelated_issue_would/ 
23:04:12 <Peaker> The Haskell translation of idiomatic Java is.. *shorter* than Java. haha
23:05:07 <Peaker> (I argued with him in separate threads, so I know his "request for help" is just about trying to show "purity sucks")
23:05:52 <danharaj> I don't get it though
23:06:05 <danharaj> Doesn't Haskell compete with, and often beat Java in terms of performance?
23:07:35 <Peaker> danharaj, I don't think he was saying anything about performance
23:08:13 <danharaj> Then I don't get it. Haskell code is definitely shorter most of the time than java code. So why does purity suck?
23:08:16 <Peaker> He's trying to say "programming is inherently a sequence of destructive writes" and that purity makes it hard to describe that sequence. I am trying to explain to him programming is not that, but he thinks his point of view is fact...
23:08:37 <danharaj> He has been bound by the chains of von Neumann.
23:09:09 <SubStack> I remember wishing I could express computation as a series of transformations back in 7th grade or so
23:09:47 <SubStack> I would write really long expressions on my calculator instead of a bunch of short ones like everybody else did for some reason
23:12:02 <BMeph> Peaker: You should edit it so the variables are m_children and m_valid, just toreally rub it in... >;)
23:12:11 <Peaker> BMeph, yuck :)
23:15:34 <dcoutts_> Peaker: note also that he misses the step where he sets 'b's parent to be 'a'
23:15:59 <dcoutts_> Peaker: and a functional version would be more like 5 lines :-)
23:16:03 <Peaker> dcoutts_, Yeah, I wrote a comment about that
23:16:14 <Peaker> dcoutts_, It depends on what the functional version needs to do
23:16:39 <Peaker> A functional version would be much less likely (impossible) to forget to set the parent, that would be a useful comment in the thread
23:16:55 <dcoutts_> Peaker: I was just thinking of a tree traversal that reconstructs the parents but now marked as invalid
23:17:23 <Peaker> dcoutts_, O(entire tree)?
23:17:27 <dcoutts_> Peaker: and I was assuming the child nodes would not reference the parent
23:17:40 <Peaker> I'd prefer a SEC that "modifies" a tree node
23:17:44 <dcoutts_> Peaker: log of the size of the tree
23:18:00 <dcoutts_> SEC?
23:18:06 <Peaker> @where SEC
23:18:06 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
23:18:20 <Peaker> dcoutts_, how do you know the traversal path though, given just a child node?
23:18:38 <dcoutts_> Peaker: you don't, you identify nodes by their path
23:18:42 <BMeph> Peaker: Heck, you could even do it like Clojure does, it'd still work fine... :)
23:19:21 <Peaker> dcoutts_, ah, I see
23:19:32 <Peaker> BMeph, how does Clojure do it? I don't know much Clojure
23:19:47 <dcoutts_> Peaker: or one could do something more sophisticated with zippers, but that's harder to explain to a beginner
23:20:17 <Peaker> dcoutts_, IMO, it is also harder in general :)
23:20:55 <Peaker> Zippers are nice when you want to combine pure semantics with performance.. But it seems to compromise some simplicity
23:21:12 <BMeph> Peaker: Everything is a trie, and every insert/delete does structural sharing up the wazoo... :)
23:27:19 <ClaudiusMaximus> fwiw, here's my code that manipulates an infinite-in-all-directions graph (translated from imperative code): http://gitorious.org/maximus/kjhf/blobs/master/src/DataTape.hs
23:28:17 <fffej> I'm trying to use type classes to avoid mixing up units (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26059).  It doesn't work because I don't know how to define construct.  Should I be trying to solve this problem like this, or is there a simpler way of doing things?
23:28:35 <aavogt> @hackage dimensional
23:28:35 <lambdabot> http://hackage.haskell.org/package/dimensional
23:29:26 <fffej> @aavogt, looks like that doesn't build on 6.12?  
23:29:26 <lambdabot> Unknown command, try @list
23:29:39 <aavogt> did you try?
23:29:58 <aavogt> hackage lies sometimes
23:30:13 <fffej> yup, you're right, hackage is lying to me
23:30:44 <aavogt> actually the failure is just for documentation
23:31:01 <Peaker> fffej, Instead of that, I'd use a Vector2 data-type, and newtypes around it.  I'd use the GeneralizedNewTypeDeriving extension to copy the Applicative instance (or Num instance if you're feeling brave) from Vector2 to the newtypes.  Then I could use liftA2 (+) or (+) for Applicative or Num on the newtypes
23:31:37 <aavogt> isn't is simpler to just use    Vec a, where a is a type that doesn't have any values?
23:31:56 <aavogt> so you can have functions that operate on any vector type
23:31:56 <Peaker> That's an interesting idea as well :)
23:32:02 <aavogt> so long as they are all the same
23:32:11 <fffej> so that's phantom types?
23:32:13 <aavogt> or not... if that makes sense in the application
23:32:14 <Peaker> newtype PVector2 p a = Vector2 a  deriving ...
23:32:14 <aavogt> yes
23:32:35 <Peaker> Then use (PVector2 UnitGoesHere) with Applicative or whatever to do constricted arithmetic
23:32:44 <aavogt> this is more or less what that package dimensional does
23:33:17 <fffej> thanks - i'll give that a whirl
23:33:23 <aavogt> which defines it's own * ^ + - so that you correctly multiply units and so on
23:33:33 <Peaker> If only "Num" died
23:33:35 <aavogt> well, the + - could be the same as Num
23:33:38 <Peaker> and a sane set of classes emerged instead
23:33:44 <Peaker> Haskell stdlib needs a huge face lift!
23:34:00 <Veinor> the numeric prelude does suck, yeah
23:34:06 <aavogt> does it, or does the class system need a correction
23:34:06 <Peaker> I also hate "length" to be ambiguous in ghci because I imported ByteString!  Damnit, "length" should be a type-class method somewhere
23:34:08 <Veinor> which is rather ironic considering it's a mathematician's language.
23:34:28 <Peaker> Veinor, some mathematicians say the maths in Haskell is just cargo-cult maths :)
23:34:37 <Veinor> Peaker: Traversable?
23:34:45 <Peaker> @src Traversable
23:34:45 <lambdabot> class (Functor t, Foldable t) => Traversable t where
23:34:45 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
23:34:45 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
23:34:45 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
23:34:45 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
23:34:56 <Peaker> Veinor, Where's length?
23:35:08 <aavogt> Peaker: sounds like a strawman
23:35:24 <Veinor> I mean, I'm thinking of what it'd be a typeclass method of
23:35:39 <Peaker> Veinor, oh. No, I wouldn't want to mess up an elegant class :)
23:36:05 <Peaker> We probably need class aliases, and then safely creating one-method classes we can later group together if necessary
23:36:16 <Veinor> rewriting the prelude would probably mess up a whole bunch of stuff though
23:36:36 <aavogt> @type getSum . Data.Foldable.foldMap (const (Sum 1))
23:36:37 <lambdabot>     Ambiguous occurrence `getSum'
23:36:37 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
23:36:37 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
23:36:43 <aavogt> @src Sum
23:36:43 <lambdabot> Source not found. I am sorry.
23:36:47 <aavogt> @type Sum
23:36:47 <lambdabot>     Ambiguous occurrence `Sum'
23:36:48 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
23:36:48 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
23:36:59 <aavogt> vector space is rather bothersome
23:37:15 <aavogt> @type Data.Monoid.getSum . Data.Foldable.foldMap (const (Sum 1))
23:37:15 <lambdabot>     Ambiguous occurrence `Sum'
23:37:15 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
23:37:15 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
23:37:21 <aavogt> @type Data.Monoid.getSum . Data.Foldable.foldMap (const (Data.Monoid.Sum 1))
23:37:22 <lambdabot> forall a a1 (t :: * -> *). (Num a, Data.Foldable.Foldable t) => t a1 -> a
23:37:41 <aavogt> there's your length
23:37:45 <Veinor> Foldable looks good, yeah
23:37:48 <aavogt> perhaps it's even called length?
23:37:54 <aavogt> @type Data.Foldable.length
23:37:55 <lambdabot> Not in scope: `Data.Foldable.length'
23:38:20 <aavogt> but of course that's not an efficient implementation as possible
23:38:33 <aavogt> so you end up putting lots of functions into typeclasses instead
23:38:36 <BMeph> Trees are Foldable. Trees don't have "length".
23:38:47 <BMeph> (Hint: try "size" instead. ;)
23:38:48 <aavogt> they have size?
23:39:00 <Veinor> number of elements, duh
23:39:24 <Peaker> aavogt, length can often be O(1)
23:39:24 <aavogt> anyhow, it's still not efficient for lots of data
23:39:32 <aavogt> not that one
23:39:52 <Peaker> yes, which is why it makes sense to have "length" be a class method
23:40:14 <aavogt> do you know why nobody uses edison?
23:41:10 <Veinor> edison?
23:41:18 <aavogt> exactly my point!
23:41:29 <aavogt> @where edison
23:41:29 <lambdabot> http://www.cs.princeton.edu/~rdockins/edison/home/
23:41:31 <Veinor> why?
23:42:22 <aavogt> look at it. Massive typeclasses like peaker is trying to do to Foldable
23:43:07 <Peaker> aavogt, I don't want to change Foldable!
23:43:25 <Peaker> aavogt, But I would definitely prefer an ugly class to having no class at all (e.g: The horrible situation with the ByteString api)
23:44:11 <Peaker> "Binary" is a class, but should not really be (there are many useful ways to [de]serialize data types), whereas ByteString should be generalized to some class (so we can "decode" either strict or lazy byte strings)
23:44:25 <Peaker> The ByteString API's live in backwards land
23:45:53 <Peaker> btw: Will ByteString ever die and be replaced by some parameterized type? (UArray Word8 instead of ByteString)
23:46:07 <Peaker> (or some newtype around [UArray Word8] for lazy bs)
23:47:04 <Peaker> That way, at least "ByteString.map" and such could be replaced by fmap
23:47:27 <aavogt> :k UArray
23:47:27 <lambdabot> Not in scope: type constructor or class `UArray'
23:47:33 <aavogt> @hoogle UArray
23:47:33 <lambdabot> Data.Array.Unboxed data UArray i e
23:47:33 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
23:47:33 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
23:47:41 <aavogt> :k Data.Array.Unboxed.UArray
23:47:42 <lambdabot> * -> * -> *
23:48:14 <aavogt> interesting, I thought it only worked for some types that are unboxable
23:51:22 <Peaker> @hoogle [(i, a)] -> UArray i a
23:51:22 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
23:51:22 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
23:51:22 <lambdabot> Data.Graph.Inductive.Graph delEdges :: DynGraph gr => [Edge] -> gr a b -> gr a b
23:51:48 <danharaj> So I'm browsing reddit
23:51:55 <danharaj> and my brain is trying to kill itself
23:52:30 <tensorpudding> reddit: it was never good
23:54:09 <Veinor> aieeeeee
23:54:28 <Peaker> aavogt, listArray (1,3) [[1],[2],[3]] :: UArray Int [Int] => No instance for (IArray UArray [Int])
23:54:30 <danharaj> I should have know something would suck when there was a dedicated 'atheism' section.
23:54:36 <Peaker> aavogt, Only unboxable types have the array instances
23:54:48 <Peaker> Reddit has good subreddits
23:54:54 <Peaker> The Haskell subreddit has less noise
23:57:56 <alex404> Anyone know why when I use the exact same :set comments=... in a haskell file vs a c file in vim I get different results?
