00:00:47 <xmonader> is "an expression contains lambda" is a valid definition for "lambda expression"?
00:01:48 <napping> as a matter of syntax? The lambda expression is the bit that starts with the \, has args, a ->, and one expression in the body
00:02:37 <kmc> i would say a lambda expression is an expression whose outermost syntactic element is a lambda
00:02:59 <xmonader> kmc: i like that
00:03:00 <kmc> «\x -> x» is a lambda expression but «(\x -> x) y» is not -- it's an application
00:03:23 <napping> "contains lambda" sounds a bit vague - kmc's second thing is an application, where the function is a lambda
00:09:21 <theorbtwo> I would say the outermost semantic element, which would also make (\x -> x) a lambda.
00:15:33 <kmc> what's a semantic element?
00:16:07 <ezyang> Really awesome syntax trick: constructor for the continuation monad is infix. Then, invoking the continuation is just value # continuation 
00:16:16 <kmc> data Lam = Var String | Abs String Lam | App Lam Lam
00:16:38 <kmc> any term built with the Abs constructor is a "lambda term"
00:17:32 <napping> ezyang: is that a field name?
00:17:42 <napping> constructor doesn't sound like it would work
00:18:56 <ezyang> napping: Oh, sorry, I meant field name! 
00:18:56 <kmc> cool, infix field names
00:19:02 <kmc> didn't know you could do that
00:22:43 <cizra> Does gtk2hs not support assistants?
00:28:03 <blueonyx> hey, how to set a package module as import for hint? c_wraith? i'm getting the error: module Foo is a package module
00:31:31 <Palmik> Hi, I have a question and that is how is the haskell's integer implemented (roughly) and how is it really limited (ehat part of hardware is limiting it)
00:31:51 <ezyang> Palmik: Integer? 
00:32:02 <ezyang> as in, with a capital I and spelled out all the way? 
00:32:52 <Palmik> ezyang, yes, with capital I
00:33:07 <ezyang> Integer is arbitrary precision and I believe uses gmp under the hood 
00:33:11 <Palmik> at least that is what :type returns for me
00:33:34 <ezyang> > 23942348729347298357293572348957349865348967349673496346 :: Integer 
00:33:35 <lambdabot>   23942348729347298357293572348957349865348967349673496346
00:33:53 <ezyang> (the GNU bignum library) 
00:34:36 <cizra> Palmik: There's also Int that uses whatever machine-specific int type. There are also fixed-width portable ints.
00:34:59 <ezyang> cizra: Not quite true; Int is a smidge less than the machine int. 
00:35:24 <kmc> Palmik, the Haskell standard does not specify a particular way to implement Integer
00:35:31 <Palmik> ok
00:35:40 <kmc> just that it's unbounded
00:35:47 <ezyang> > maxBound :: Int 
00:35:48 <lambdabot>   9223372036854775807
00:35:54 <ezyang> > maxBound :: CInt 
00:35:55 <cizra>  The finite-precision integer type Int covers at least the range [ - 229, 229 - 1].
00:35:55 <lambdabot>   Not in scope: type constructor or class `CInt'
00:35:58 <Palmik> that is number of digits?
00:36:01 <ezyang> blah 
00:36:11 <kmc> whereas Int is an implementation-specific bounded type
00:36:19 <ezyang> 2^29, not 229, I hope. 
00:36:27 <kmc> which is guaranteed to go at least to 2^29 -1
00:36:36 <cizra> -2²⁹
00:36:42 <kmc> but usually goes to 2^31 - 1 or 2^63 - 1, depending on your machine
00:36:46 <Palmik> ok, thanks guys :)
00:36:57 <cizra> kmc: I've never seen a system where int would be 64 bits long...
00:37:07 <ezyang> cizra: It's called a 64-bit system :-) 
00:37:10 <Palmik> ezyang, hmm, btw what do you mean by gmp?
00:37:16 <kmc> it's a library
00:37:18 <kmc> a GNU library
00:37:26 <Palmik> oh, ok
00:37:33 <kmc> Palmik, GHC implements Integer using either bindings to GMP (the integer-gmp package), or a simpler, pure-Haskell implementation (integer-simple)
00:37:40 <kmc> which one you use is a compile-time option in GHC
00:37:50 <kmc> other Haskell implementations are of course free to implement Integer other ways
00:38:01 <Palmik> ok :)
00:38:15 <cizra> ezyang: nope. On all 64-bit systems I've tried, long is 64-bit, pointers are 64-bit, ints are 32-bit.
00:38:28 <kmc> err, you mean the C types?
00:38:54 <kmc> GHC gives you 64-bit Int on a 64-bit machine
00:39:05 <cizra> I meant C, yes
00:39:12 <kmc> of course it would be within its rights to give you a 30-bit Int
00:39:23 <cizra> .. but this would be just mean
00:39:28 <kmc> if you need types corresponding to what C provides on your platform, that's CInt / CLong / CLongLong
00:40:02 <kmc> > maxBound :: Foreign.C.Types.CInt
00:40:03 <lambdabot>   Not in scope: type constructor or class `Foreign.C.Types.CInt'
00:40:03 <cizra> Anyway, gtk... Does gtk2hs not provide interface to Assistants?
01:04:08 <c_wraith> is it possible to do imports only for TH?
01:04:32 <c_wraith> ...  That probably doesn't even make sense in TH's execution model
01:04:47 <exDM69> how can I tell GHCi to look for dynamic libraries in /usr/local/lib
01:14:21 <tibbe> Is there a way to use type families to get unpacked representations in a Data.Map without writing an instance for every type?
01:14:48 <tibbe> e.g. data Map k a = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
01:15:02 <tibbe> I can reduce indirections by specializing a to e.g. !Int manually
01:15:08 <tibbe> but I would like to do it generally
01:15:28 <tibbe> what do I need to do? Map down to some representation types?
01:15:57 <exDM69> trying to use the OpenCLRaw library from hackage, OpenCL libs, etc. are installed in /usr/local/{lib,include,...}. I get undefined references when linking (using ghc --make) and when trying to do anything in GHCi. Can someone point me to GHC + shared library search path docs or help me with some handy command line options?
01:16:52 <Axman6> tibbe: is this at all related to http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/ ?
01:17:43 <tibbe> Axman6: in a sense, I want to write a more (data) compact Data.Map
01:18:04 <Axman6> can you use the same technique for Data.Map?
01:18:11 <tibbe> Axman6: we have a specialized version in the new event manager but hand rolling cut-n-paste versions doesn't feel right
01:18:24 <Axman6> hmm
01:18:59 <tibbe> Axman6: it leads to a combinatorial explosions
01:19:09 <Axman6> yeah
01:19:27 <tibbe> I need instances for {Int8, ..., Int64, Word8, ..., Word64} x {Int8, ..., Int64, Word8, ..., Word64}
01:19:32 <tibbe> also for all user defined types
01:19:38 <tibbe> Doubles, etc
01:19:47 <Axman6> can't TH be used to make that all easier?
01:19:52 <tibbe> I can do it with a CPP macro but not with Haskell :/
01:20:03 <tibbe> Axman6: maybe, but it's a very heavy hammer to use
01:21:00 <danharaj> TH fulfills many of the rolls C++ templates and macros do.
01:21:06 <danharaj> roles*
01:21:08 <danharaj> mmm rolls.
01:21:43 <tibbe> Axman6: Data.Vector uses a CPP macro!
01:21:45 <Axman6> seems you should be able to do something like define a list in TH with all the types that can be unpacked, and then use something like... [ defineMapForTypes a b | a <- types, b <- types]
01:21:54 <Axman6> heh
01:22:34 <c_wraith> TH is failing me..  I could use a CPP macro for this.
01:22:42 <c_wraith> this upsets me, actually. :(
01:23:01 <Axman6> i should learn TH
01:23:25 <tibbe> Axman6: yes
01:23:59 <tibbe> Axman6: I'm always weary of adding TH deps; It's a new "language" for contributors to learn and many tools don't speak TH.
01:23:59 <c_wraith> I want to import a module only conditionally, based on a compile-time constant.  I can't do that with TH.
01:24:13 <Axman6> hmm, this is true
01:24:32 <danharaj> c_wraith: Why?
01:24:46 <Axman6> tibbe: can't you get GHC to output the results of exdecuting the TH?
01:24:57 <edwardk> i'm going through breaking apart category-extras, how many folks would object to me defaulting to a simpler definition for Bifunctor (without the category arguments) and making a Control.Bifunctor.Categorical which provides the existing functionality/is used to build up the more complicated categories?
01:25:10 <tibbe> Axman6: sure, but it adds complexity
01:25:12 <c_wraith> danharaj: because of the linker.  If I import that module, the size of the executable goes up by 20 MB
01:25:19 <kmc> the std libs use CPP macros a lot for that sort of thing
01:26:03 <c_wraith> actually, 22 MB.  11 -> 33
01:26:14 <exDM69> http://osdir.com/ml/haskell-cafe@haskell.org/2009-12/msg01312.html  <<<-- someone seems to have had similar problem to mine. with -L/usr/local/lib -lOpenCL, I get undefined reference to clGetProgramInfo. without the cmd line args I get undef.refs for all opencl functions
01:27:20 <c_wraith> I wish the linker could figure out when I'm not using anything from that module, despite having imported it, so it could go ahead and not link in the ghc-api package
01:32:29 <Phyx-> hmm how accurate is the memory consumption displayed in ghci when using +s?
01:34:13 <napping> it should be accurate
01:35:33 <Phyx-> according to this then my tiny structure with a few strings took 477mb
01:35:40 <Phyx-> it seems... excessive
01:35:59 <c_wraith> does it measure allocation, rather than peak memory usage?
01:36:49 <Phyx-> I have no idea what that number actually is, if it's total allocations I *could* see that being right, but still a bit high, but alot of strings so
01:37:19 <Phyx-> but even something simple like "putStrLn "lol"" says it takes 528kb
01:39:13 <danharaj> edwardk: Your first post for comonad is cheesy as all hell.
01:39:15 <danharaj> ;)
01:48:40 <napping> Phyx-: it's supposed to be bytes allocated
01:49:06 <napping> with some cavet about granularity
01:49:40 <Phyx-> napping: ah, and it's probably reporting allocations from the packages I use aswell?
01:49:58 <napping> It seems like it might include something along the lines of current heap
01:50:17 <napping> anyway, the real profiling stuff is probably a lot more useful
01:51:44 <Phyx-> napping: yeah, I was just wondering why that number was so high :|
01:51:51 <Phyx-> also need to optimize this
01:51:56 <Phyx-> 2secs is way to slow
01:52:52 <napping> it's reporting allocations, not peak memory usage
01:53:12 <napping> you should expect to allocate and quickly reclaim tons of small things
01:53:23 <napping> and ghci is horrible for timing things also
01:53:45 <napping> well, if you precompile your modules with decent options it might be reasonable
01:54:01 <Phyx-> i know, but the actual usage is slow also :P need to check if i compile with optimizations on
02:05:20 <edwardk> danharaj: hah i wanted to test that everything was working =)
02:05:49 <triyo> N00bie question. When searching and parsing a particular string(s) out of a text file, would this be a job suited for regex or parsec, or combination of too?
02:06:04 <triyo> *two
02:06:20 <roconnor_> > 2454/777
02:06:21 <lambdabot>   3.158301158301158
02:07:12 <Axman6> regex's are almost never the answer
02:09:06 <triyo> Axman6: so parsec would be? I need to search through source-code file and retrieve certain meta-tag out of each
02:09:51 <ManateeLazyCat> I have finish some poppler APIs binding at https://patch-tag.com/r/AndyStewart/poppler/home , i will finish rest APIs when i'm boring, any test and help are welcome! :) 
02:10:17 <ManateeLazyCat> poppler is APIs that fork from xpdf to provide common library to render PDF file.
02:10:45 <ManateeLazyCat> And code at https://patch-tag.com/r/AndyStewart/poppler/home can integrate with gtk2hs to build your own powerful pdf viewer. :)
02:11:00 <triyo> yet another ;)
02:11:54 <ManateeLazyCat> triyo: I think you need some lexical parser do that.
02:12:20 <ManateeLazyCat> triyo: Of course, regexp can do same thing, but it's not the natural way, and buggy.
02:12:57 <triyo> ManateeLazyCat: parsec if what I have beeing learning a bit now and seems to be somewhat of a natural fit for lexical parsing
02:13:06 <triyo> if=is
02:13:12 <ManateeLazyCat> triyo: You can write right parser, but it's hard to write regular expression to match everything.
02:13:32 <ManateeLazyCat> triyo: Regexp just useful when you want search some string and don't care syntax.
02:14:47 <ManateeLazyCat> triyo: Example, haskell-mode in Emacs use regexp highlight keyword or function/variable name, in some special situation, regular expression will failed.
02:15:20 <robertmassaioli> yeah, unless the regex is small (one line), or a throwaway, then don't use regex. You are better off with a parser.
02:15:44 <ManateeLazyCat> triyo: Special to parse complicated syntax, multi-line regex will crazy you and hard to maintain.
02:16:23 <triyo> any suggestions which parser libs to use in Haskell. Everything so far seems to point to parsec. Parsec is tricky a bit to grasp for noobies like be. :)
02:16:46 <triyo> *be=me
02:16:55 <ManateeLazyCat> robertmassaioli: Right, when simple match, such as highlight "where", i think regexp "\bwhere\b" is simple.
02:17:18 <ManateeLazyCat> s/simple/simpler
02:22:11 <napping> triyo: you could try ReadP
02:24:11 <triyo> napping: thanks, I'll give ReadP a look
02:26:08 <napping> triyo: easy stuff is simple in Parsec, but it does have a bunch of extra stuff like the tokens and state threading that are more complicated
02:27:25 <triyo> napping: My requirement is to parse some meta-tags that are scattered through give source-code "text" files
02:31:23 <pastorn> triyo: there's a paper called "monadic parsing in haskell" which is a great read
02:31:50 <pastorn> triyo: if you read that you'll have no trouble understanding how to use parsec
02:33:43 <robertmassaioli> ManateeLazyCat: exactly
02:34:12 <robertmassaioli> triyo: you could also try out the alex / happy combination if you are feeling adventurous
02:36:42 <triyo> robertmassaioli: that looks cool, nice docs too :)
02:38:21 <robertmassaioli> triyo: yes it is rather nice. The docs are great and you don't have to write too much. Though if you are just starting then the Real World Haskell chapter on parsec might be better. (It's your call :D )
02:40:52 <triyo> robertmassaioli: yup, I am just starting out and am currently going through ch16 of RWH book. So I'll try Parsec as first option and see how far that gets me to building a simple lexer :)
03:01:29 <derferman> I am trying to follow the learnyousomehaskell tutorial, but am stuck at the part in which I define my own function
03:01:47 <derferman> I have a file called baby.hs which contains doubleMe x = x + x
03:02:02 <derferman> I run ghci from the command line in the same folder as baby.hs
03:02:09 <derferman> and then type :1 baby
03:02:12 <derferman> and get an error
03:02:38 <dibblego> use ell not one
03:02:44 <dibblego> :load baby.hs
03:02:46 <derferman> lol
03:02:53 <derferman> wow, thanks
03:02:55 <dibblego> np
03:14:51 <ivanm> greetings edwardk 
03:24:57 <pastorn> derferman: you can also use ":r" in ghci, short for Reload
03:25:11 <pastorn> (no file needs to be specified)
03:48:29 <ivanm> greetings m3ga 
03:48:52 <m3ga> ivanm: howdy! it seems the next fp-syd is the night before the first day of aushack. you coming? :-)
03:49:10 <ivanm> as in the Thursday?
03:49:16 <Axman6> hey, i didn't know that, i might be able to come :D
03:49:25 <ivanm> if so, timing is too late; it'd cost too much to change my hotel and bus bookings :s
03:49:29 <Axman6> and evangelise!
03:49:32 <ivanm> m3ga: YOU SHOULD HAVE TOLD US EARLIER!!!!!!
03:49:58 <Axman6> ivanm: i might go if i can, make sure everyone knows about it
03:50:01 <m3ga> organization is not my strong point
03:50:11 <Axman6> heh
03:50:18 <m3ga> i only realised because benl32 figured it out
03:51:03 <ivanm> Axman6: if you're up to doing a joint AusHack wrap-up session for the CLUG P-SIG in August, we'd need to tell the organisers
03:51:10 <ivanm> m3ga: so it's _his_ fault!
03:51:10 <ivanm> :p
03:51:44 <pastorn> 70 minutes left...
03:51:50 <ivanm> Axman6: it's usually 2nd thursday of the month; that OK with you?
03:52:06 <ivanm> pastorn: stop tempting me! :p
03:52:11 <Axman6> probably not, i have SES training every thursday
03:52:17 <pastorn> ivanm: 69 MINUTES!!!!
03:52:26 <ivanm> Axman6: fair enough; you just said you might have been able to do it
03:52:29 <m3ga> icfp?
03:52:29 <ivanm> @slap pastorn 
03:52:30 <lambdabot> I won't; I want to go get some cookies instead.
03:52:36 <ivanm> m3ga: the ICFP programming contest
03:52:38 <pastorn> haha... shit...
03:52:43 <pastorn> lambdabot has karma?
03:52:47 <ivanm> http://icfpcontest.org/
03:52:48 <m3ga> have fun!
03:52:49 <pastorn> @slap m3ga 
03:52:49 <lambdabot> Come on, let's all slap m3ga
03:53:00 <Phyx-> @karma Phyx- 
03:53:01 <lambdabot> You have a karma of 0
03:53:05 <Phyx-> neutral huh
03:53:08 <pastorn> @karma pastorn
03:53:08 <lambdabot> You have a karma of 0
03:53:11 <ivanm> @karma lambdabot 
03:53:11 <lambdabot> lambdabot has a karma of -1
03:53:14 <m3ga> ha!
03:53:15 <ivanm> lambdabot++
03:53:16 <pastorn> @karma ivanm
03:53:16 <lambdabot> ivanm has a karma of 23
03:53:19 <ivanm> :o
03:53:20 <pastorn> wait...
03:53:22 <pastorn> wut?
03:53:29 * ivanm helps people here...
03:53:30 <ivanm> :D
03:53:37 <Phyx-> ivanm: lies!
03:53:38 <m3ga> i'm hacking ddc this weekend
03:53:43 <ivanm> cool
03:53:47 <pastorn> thank you ivanm 
03:53:49 <pastorn> @karma ivanm
03:53:49 <lambdabot> ivanm has a karma of 23
03:53:54 <pastorn> no, that's not it...
03:54:02 <ivanm> m3ga: is ben still working on that?
03:54:04 <Phyx-> @karma +ivan
03:54:05 <lambdabot> +ivan has a karma of 0
03:54:07 <Phyx-> hm
03:54:12 <ivanm> (clem is still reading his thesis AFAIK)
03:54:14 <Phyx-> @karma ivan +1
03:54:15 <lambdabot> ivan has a karma of 0
03:54:18 <ivanm> Phyx-: it's @karma+
03:54:22 <Phyx-> ivanm: ah
03:54:23 <m3ga> yes, about 100 commits in the last 2 months
03:54:41 <pastorn> @karma+ pastorn 
03:54:41 <lambdabot> You can't change your own karma, silly.
03:54:44 <pastorn> awww
03:54:46 <ivanm> lol
03:54:52 <pastorn> @karma- ivanm 
03:54:52 <lambdabot> ivanm's karma lowered to 22.
03:54:54 <ivanm> pastorn: stop trying to game the system!
03:54:56 <pastorn> muahahaha
03:54:57 <ivanm> hey, that's not nice!
03:54:58 <ivan> thanks for the karma
03:55:01 <ivanm> @karma- pastorn 
03:55:02 <lambdabot> pastorn's karma lowered to -1.
03:55:06 <pastorn> ivan: you laughed at me!
03:55:11 <m3ga> benl23 won;t be at the next fp-syd because he's graduating. i suspect clem has finished with the thesis :-)
03:55:17 <ivanm> pastorn: he didn't; I did!
03:55:32 <ivanm> ivan: and you didn't get any karma, Phyx- just tried to work out _how_ to give you karma
03:55:39 <ivanm> m3ga: ooohhh....
03:55:47 <ivanm> wait, does that mean ben won't be at aushack? :/
03:55:51 <pastorn> ivan: sorry... didn't auto complete properly :/
03:55:57 <benmachine> @karma+ ivan -- out of sympathy
03:55:57 <m3ga> he will for sat/sun
03:55:57 <lambdabot> ivan's karma raised to 1.
03:56:06 <ivanm> benmachine: heh
03:56:10 <ivanm> m3ga: *nod*
03:56:23 <Phyx-> lol
03:56:25 <pastorn> ivanm: 64 minutes...
03:56:41 <ivanm> ivan: wait, I registered my nick 26 weeks before you did, but I don't recall `ivan' being available then... >_>
03:56:45 <ivanm> @slap pastorn 
03:56:45 * lambdabot smashes a lamp on pastorn 's head
03:56:57 <ivan> ivanm: it's been registered on and off since the beginning of time
03:57:15 <ivan> I lost it for a few years until someone gave it back to me
03:57:36 <ivan> if I abandon my IRC life, it's yours
03:57:49 <ivanm> heh
03:57:54 <ivanm> nah, I'm happy with this nick
03:58:02 <m3ga> ivan: benl23 is offereing an undergrad thesis subject on ddc at unsw next semester
03:58:08 <ivanm> m3ga: methinks you mean me :p
03:58:21 <ivanm> and what's an "undergrad thesis subject"? honours?
03:58:35 <m3ga> yes, too many eyevans
03:58:45 <m3ga> yes, i think so
03:59:10 <ivanm> @slap m3ga 
03:59:10 * lambdabot smacks m3ga  about with a large trout
03:59:31 <ivanm> just because the yanks can't pronounce anything right doesn't mean you have to copy them!
03:59:35 <pastorn> what's with all the beatings?
03:59:40 <pastorn> can't we all just get along?
03:59:47 <m3ga> so you're eevan?
03:59:48 <ivanm> pastorn: in your case, because you think you're funny :p
03:59:55 <ivanm> m3ga: that's closer to it, yes
04:00:22 <pastorn> @karma- ivanm 
04:00:22 <lambdabot> ivanm's karma lowered to 21.
04:00:24 <pastorn> be nicer
04:00:28 <ivanm> grrrr......
04:00:37 <m3ga> i should have got that right. eastern european surname and all
04:00:39 * ivanm is tempted to @slap pastorn, but that would just be proving him right...
04:00:44 <ivanm> m3ga: exactly!
04:00:53 <m3ga> @karma- pastorn
04:00:54 <lambdabot> pastorn's karma lowered to -2.
04:00:58 <pastorn> awww
04:01:02 <pastorn> m3ga: but wai?
04:01:18 <ivanm> because us Aussies have to stick together! :p
04:01:27 <pastorn> haha... wtf?
04:01:38 <m3ga> i'm trying to talk to ivanm and you;re .... yeah what he said
04:01:51 <ivanm> heh
04:01:57 <m3ga> the aussie cabal
04:02:25 <ivanm> lol
04:03:57 <jeltsch> ivanm: Can you tell me how you create messages like “ivanm is tempted to @slap pastorn, but that would just be proving him right...” above?
04:04:08 <Zao> /me, typically.
04:04:20 <Zao> (it's a CTCP ACTION)
04:04:36 <Zao> (or maybe regular action, can never remember the IRC particulars)
04:04:39 <ivanm> yeah
04:04:56 <ivanm> (to all 3 things Zao said)
04:04:58 <Raynes> It's a CTCP action.
04:05:52 * jeltsch hopes that this attempt to write such a message is successful.
04:06:20 <benmachine> as indeed it was
04:06:42 * jeltsch doesn’t like that http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands doesn’t cover the /me.
04:06:52 <jeltsch> Thank you all.
04:07:05 <benmachine> in fairness /me isn't an IRC command as such
04:07:08 <benmachine> it's an IRC client command
04:07:40 <Zao> benmachine: Where by "it" I referred to the operation, not /me in particular.
04:07:44 <benmachine> i.e. it gets translated to a PRIVMSG before getting to the server
04:07:49 <benmachine> ah
04:08:03 <jeltsch> benmachine: It doesn’t look very private. Why is it a PRIVMSG then?
04:08:17 <benmachine> jeltsch: it's private in that it only goes to #haskell and no-one else >_>
04:08:24 <benmachine> which is uh not very private
04:08:29 <benmachine> but you know
04:08:31 <Zao> jeltsch: When you send to a channel, it's a privmsg to the #haskell entity.
04:08:42 <ivanm> IRC has a lot of weird terminology; just live with it ;-)
04:08:43 <Zao> While when you send privately to someone, it's a privmsg to the user.
04:08:56 <jeltsch> Zao, benmachine: Okay.
04:08:58 <Zao> I assume it makes sense considering that IRCops can address the whole network at once.
04:09:02 <sinelaw> hi
04:09:16 <ivanm> hey sinelaw 
04:09:26 * Zao thankfully wasn't around before channels had names.
04:09:45 <Zao> Which is why joining channel `0' disconnects you from all connected channels.
04:09:46 <ivanm> how do you refer to a channel if it doesn't have a name?
04:09:50 <Zao> Numerals.
04:10:02 <ivanm> well, a numeral is in a sense a name for that channel
04:10:07 <ivanm> it's the ith channel
04:10:28 <Raynes> IRC sucks and should be replaced immediately.
04:10:36 <Zao> Raynes: Many have tried. Most have failed.
04:10:41 <Zao> See Jabber et. al.
04:10:44 <Raynes> More should try. :\
04:11:11 <sinelaw> irc is fast
04:11:15 <ivanm> Raynes: go ahead then
04:11:30 <Raynes> ivanm: I didn't say me.
04:11:37 <sinelaw> all the AIM stuff i've ever used was slow, unreliable and had heavy ugly client apps
04:11:39 <Axman6> can anyone see what's wrong with this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26330#a26330
04:11:55 * ivanm is of the firm opinion that anyone who says something like "Foo sucks, someone should write/why isnt there a better one?" should stfu if they're not willing to help write or at least define what a better one is
04:12:12 <ivanm> Axman6: what's the error?
04:12:18 <Axman6> i'm getting errors saying that insert and getIndex "is not a (visible) method of class `KeyMap'"
04:12:33 <Raynes> Well, I never said I wouldn't do that. But, I don't think anyone was offering to spend time writing an IRC replacement that nobody will never use.
04:12:38 <ivanm> that's your actual code there?
04:12:44 <Axman6> yes
04:12:58 <sinelaw> ivanm I agree
04:13:01 <ivanm> humph, happens here
04:13:06 <Raynes> Surely I'm of the right to complain at least just a little without doing anything to solve the problem myself.
04:13:07 <ivanm> @hoogle insert
04:13:07 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
04:13:08 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
04:13:08 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
04:13:08 <Raynes> ;P
04:13:12 <ivanm> OK, it isn't in the prelude
04:13:17 * Phyx- slaps his haskell code for being slow
04:13:45 <sinelaw> @slap her own soul
04:13:45 <lambdabot> I'd rather not; her own soul looks rather dangerous.
04:13:56 <ivanm> Axman6: is your type family usage correct?
04:14:02 * ivanm has only used ATs, not TFs directly
04:14:10 <sinelaw> @slap my very own soul
04:14:10 <lambdabot> I'd rather not; my very own soul looks rather dangerous.
04:14:13 <sinelaw> there.
04:14:42 <Axman6> ivanm: i'm basically adapting dons' code from http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/
04:14:50 <ivanm> Raynes: well, I get annoyed with people bitching that Haskell support on windows is so bad, that X11 sucks, etc. if they're not willing to get off their backsides and help out
04:15:13 <ivanm> Axman6: you don't have a definition for empty... >_>
04:15:53 <ivanm> Axman6: interesting; ghci doens't bitch if you forget to do the extension
04:16:02 <Axman6> eh? huh
04:16:14 <Raynes> ivanm: Right behind you. IRC is one of those things that aren't really feasible to replace though. Even if you write a perfect replacement, nobody is going to switch to it.
04:16:31 <ivanm> Axman6: the type class on its own (with the extension) seems to be fine though
04:16:51 <kamatsu> Haskell libraries for 2d games are lacking :(
04:17:13 <kamatsu> my Tea library is reasonably thorough but I lack openGL knowledge so it's slow SDL stuff
04:17:53 <ivanm> Axman6: and trying to set "empty = IntTip" results in an error where it doesn't like the = for some reason
04:18:09 <Axman6> seems to just give me the same error here
04:18:33 <Phyx-> :t first
04:18:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:18:54 <Phyx-> :t first (+1)
04:18:55 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
04:18:59 <ivanm> Axman6: methinks something is rotten in the territory of the capital (since this isn't Europe :p)
04:19:03 <Phyx-> yup, the one i need
04:19:22 <ivanm> @instances Arrow
04:19:23 <lambdabot> (->), Kleisli m
04:20:25 <benmachine> are you normally allowed a class and type name to be the same?
04:20:41 <benmachine> istr it conflicts in import/export lists
04:20:42 <ivanm> I think so
04:20:48 <ivanm> Axman6: there's the problem
04:20:55 <Axman6> ah, good call
04:20:57 <ivanm> Axman6: the class is MapKey; you've written "instance KeyMap"
04:21:04 <Axman6> heh
04:21:16 <Axman6> that's a bad choice of names i think
04:21:18 <benmachine> heh
04:21:20 <ivanm> so it wans't what benmachine thought, but that showed me what the error was ;-)
04:21:38 <ivanm> Axman6: actually, on the friday of aushack I was thinking of hacking on some container classes
04:21:49 <benmachine> I assumed KeyMap was defined somewhere else >_>
04:21:51 <sinelaw> Raynes unless you can do something that integrates with existing irc channels
04:22:02 <sinelaw> so that you can use either one transparently
04:22:20 <ivanm> something like Collection, Sequence (i.e. list-like) and Dictionary ([(a,b)] and Maps)
04:22:35 <benmachine> as a class, hence the question (and the answer seems to be Multiple declarations of...)
04:27:27 * hackagebot MazesOfMonad 1.0.6 - Console-based Role Playing Game  http://hackage.haskell.org/package/MazesOfMonad-1.0.6 (JeanPhilippeMoresmau)
04:28:19 <Phyx-> @pl second (\y->foldr (\x -> insert x ()) y (map _Tname current))
04:28:20 <lambdabot> (line 1, column 46):
04:28:20 <lambdabot> unexpected "_"
04:28:20 <lambdabot> expecting variable, "(", operator or ")"
04:28:37 <Phyx-> fail
04:34:39 <Phyx-> hmm what ya know
04:34:42 <Phyx-> it works
04:34:46 * Phyx- pets ghc
04:36:50 <ivanm> what does?
04:37:49 <Phyx-> a large function that scrapes the information i need from modules using the ghc api
04:37:54 <Phyx-> still need to optimize though
04:38:04 <Phyx-> this 2.3seconds is very very slow
04:38:47 <ivanm> what info do you need?
04:40:15 <Phyx-> ivanm: what functions (and types if typechecked), imports, datatypes, foreigns, warnings, errors, constructors, classes, types, instances  there are in a module
04:40:51 <ivanm> any particular reason for using the GHC API rather than haskell-src-exts?
04:41:08 <Phyx-> ivanm: haskell-src-exts can't typecheck afaik
04:41:36 <ivanm> oh, right
04:41:45 <ivanm> I thought you just meant "and types if they're there"
04:42:29 <Phyx-> no no, I do keep a record if the types were infered or were present in the file, but i need ghc to actually typecheck the file
04:42:34 <Phyx-> since i need type errors aswell
04:44:48 <Phyx-> ivanm: it's for http://mistuke.files.wordpress.com/2010/06/errors1.png that's a older screenshot
04:44:49 <etate> is there an ICFP channel?
04:45:12 <ivanm> etate: for the contest you mean?
04:45:26 <etate> ivanm: yeah
04:45:30 <ivanm> Phyx-: oh, isn't there a project working on stuff like that?
04:45:40 <ivanm> etate: try #icfp-contest
04:45:55 <etate> ivanm: thanks :)
04:46:32 <ivanm> Phyx-: I can never remember what it's name is, but they've currrently got emacs and vi modes for it IIRC
04:46:50 <ivanm> ahhh, scion
04:46:52 <ivanm> @where scion
04:46:52 <lambdabot> http://github.com/nominolo/scion
04:47:07 <Phyx-> ivanm: the scaping? well there's scion which hasn't been updated in a while and doesn't include all the things i need afaik, but also does string serialization i don't know how well that'll do when pumping alot of data through all the time
04:47:08 <ivanm> first result for googling (without quotes) for "github haskell emacs" :p
04:48:04 <Phyx-> ivanm: and Leksah also just uses the ghc api afaik, ideally we should all use the same things, but at this point scion just doesn't have every functionality i need. (scion also just wraps the ghc api)
04:48:36 <ivanm> right, that's what i meant
04:48:48 <ivanm> I thought nominolo was still working on scion though...
04:49:32 <Phyx-> he mentioned he was going to update it, but the my project would be dependend on some other project. I'd have no problem switching over to it later if it proves beneficiary
04:49:49 <ivanm> what project are you working on? is that Visual Haskell?
04:49:57 <Phyx-> yeah
04:51:10 <Phyx-> hope to have typechecking done today, so i can move on to cabal support
04:59:47 <eevar2> ~1 minute until icfp starts
05:00:01 <mjrosenb> indeed
05:00:10 <mjrosenb> well icfp contest
05:00:25 <ivanm> eevar2: that's pastorn's job!
05:00:27 <ivanm> ;-)
05:00:51 <mjrosenb> aaannnnd their servers get punched in the face.....
05:01:02 <eevar2> hehe. stealing his thunder ;)
05:01:13 <mjrosenb> although by my clock, it started a couple of minutes ago
05:01:17 <mjrosenb> damned ntp
05:01:31 <mjrosenb> The server at icfpcontest.org is taking too long to respond.
05:02:05 <Tomsik> heh, how funny, my prof mentioned icfp contest today
05:02:13 <Tomsik> and that they let you use non-functional languages now
05:02:27 <aristid> Tomsik: you could use non-functional languages for a while
05:02:33 <aristid> i participated 2008 or so with c++
05:02:41 <ivanm> you still can AFAIK
05:02:59 <ivanm> oh, right, I misunderstood what aristid said
05:03:12 <ivanm> I thought you always could though, since the hoped-for outcome was that FP beats non-FP
05:03:59 <aristid> oh, it was actually 2006
05:04:05 <aristid> and we scored place 25 \o/ http://www.boundvariable.org/scoreboard.shtml
05:04:22 <aristid> with a bit less cluelessness we might have done better :D
05:04:45 <aristid> i actually played the adventure by hand... :D
05:05:21 <aristid> wow, how time passes. didn't think it was as long ago as 2006
05:07:45 <aristid> hmm, should i do university stuff, or should i participate in icfp. hard.
05:08:59 <mjrosenb> aristid: icfp
05:09:07 <mjrosenb> aristid: always icfp
05:09:23 <mjrosenb> this year looks much more interesting than the last two years
05:09:23 <poiuy> Beginner's question: I have installed Crypto package. In ghci +m Data.Digest.MD5 works but ghc doesn't find the library while compiling
05:09:24 <ivanm> it is the ICFP _Contest_!
05:09:27 <aristid> mjrosenb: doesn't matter if i'm already ~2 months late on the uni stuff?:)
05:09:30 <ivanm> the conference itself isn't on yet!
05:09:37 <mjrosenb> aristid: nope.
05:09:44 <poiuy> how to make clear to ghc where to look for the library?
05:09:44 <ivanm> poiuy: how did you install it?
05:09:47 <aristid> mjrosenb: !
05:09:50 <ivanm> poiuy: what is the error message?
05:09:52 <poiuy> using cabal
05:10:00 <ivanm> then GHC should know
05:10:10 <ivanm> especially if it knows where to look within ghci
05:10:26 <ivanm> poiuy: also, how are you calling ghc?
05:10:34 <poiuy> my bad: typo!
05:10:38 * mjrosenb ->sleep
05:10:54 <poiuy> I did 'Digist' rather than 'Digest' in source code :-(
05:11:03 <ivanm> lol
05:11:23 <poiuy> hehe ... slaps forehead
05:11:24 <ivanm> @tell tomberek another problem: match won't work properly because context doesn't do a complete decomposition
05:11:25 <lambdabot> Consider it noted.
05:12:05 <ivanm> @tell tomberek I have the sneaking suspicion that match has to be a per-instance definition (unless you want to do a really inefficient default that explicitly finds all edges and then deletes them from the graph)
05:12:06 <lambdabot> Consider it noted.
05:13:36 <aristid> :t match
05:13:37 <lambdabot> forall regex source target. (RegexContext regex source target) => regex -> source -> target
05:14:07 <aristid> oO long type names, how un-haskelly
05:14:33 <aristid> :t match :: (RegexContext rx a b) => rx -> a -> b
05:14:34 <lambdabot> forall rx a b. (RegexContext rx a b) => rx -> a -> b
05:15:05 <aristid> better.
05:15:50 <ivanm> @hoogle match
05:15:51 <lambdabot> Language.Haskell.TH match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
05:15:51 <lambdabot> Data.Graph.Inductive.Graph match :: Graph gr => Node -> gr a b -> Decomp gr a b
05:15:51 <lambdabot> Language.Haskell.TH.Lib match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
05:16:12 <ivanm> aristid: I'm referring to the version of the second one in the new version of fgl tomberek and I are working on ^^
05:17:57 <aristid> ivanm: i don't understand the docs for that function. what does it do?
05:18:32 <ivanm> given a graph and a node, if the node is in that graph it will decompose that graph into what's known as a "Context" and the rest of the graph
05:18:41 <aristid> lol, yoda documentation for type Context: "Links to the Node, the Node  itself, a label, links from the Node. "
05:19:18 <ivanm> in FGL, graphs are defined inductively as Context & Graph ==> Graph, where  Context is a node plus the edges from/to it to/from those nodes already in the graph
05:19:20 <aristid> ivanm: so it basically removes a Node and all links to/from the node?
05:19:27 <ivanm> aristid: right
05:19:52 <aristid> because links without a node are pointless, you can simplify that "it removes a Node" :)
05:20:28 <ivanm> aristid: well, it doesn't just remove it; it _decomposes_ it
05:20:53 <aristid> ivanm: you mean because the context of the node is returned too?
05:20:54 <ivanm> uncurry (&) . fromJust . match n == id
05:20:58 <ivanm> aristid: right
05:22:08 <aristid> ivanm: is suppose this graph representation is especially well-suited for some algorithms?
05:22:33 <ivanm> I think so, yes
05:23:35 <aristid> ivanm: why the distinction between Graph and DynGraph?
05:24:04 <ivanm> aristid: because it might be possible for some graph type to be decomposable but not composable
05:24:15 <ivanm> unless people want that distinction, we're going to remove it in the new version
05:24:18 <tcrayford> anybody else entering the icfp contest?
05:25:01 * ivanm would like to, but has other stuff to do
05:25:17 <tcrayford> the server seems down from here :(
05:25:27 <ivanm> tcrayford: it's just overloaded, try again
05:25:32 <tcrayford> I am
05:25:36 * ezyang never quite understood contest programming. 
05:25:46 <tcrayford> have been for the past 20 mins
05:26:06 <ivanm> ezyang: an excuse to do some completely different coding than what you normally do in a group and see how you compare to other people?
05:26:36 <ivanm> ezyang: most people doing the ICFP do it more for the challenge than the prize AFAICT
05:26:42 <ivanm> (as opposed to other contests)
05:26:46 <tcrayford> aye for that here
05:26:47 <Jafet> An excuse to write horrible fortran era code
05:27:11 <ezyang> ivanm: If I want completely different coding I'll, like, go learn an interactive proof assistant or something.  Not really interested in seeing how I compare with other people; just getting their good style and ideas and improving :-) 
05:27:21 <ezyang> But I guess I can see the appeal. 
05:27:34 <tcrayford> at least if the server wasn't so overloaded
05:28:14 <aristid> it works fine here
05:28:30 <aristid> but i'm in the same country, maybe that gives me better access :D
05:28:33 <eevar2> tcrayford: direct link to the problem: http://icfpcontest.org/2010/task/
05:28:33 <tcrayford> even http://icfpcontest.org/icfp10/ ?
05:28:49 <tcrayford> I can get to the task, its the team registration stuff that's annoying
05:29:04 <aristid> tcrayford: http error 503
05:29:18 <aristid> tcrayford: take the time to read the task
05:29:22 <pastorn> shit...
05:29:24 <tcrayford> already done
05:29:36 <ivanm> pastorn: what, you missed the beginning of it? :p
05:29:39 <pastorn> http://icfpcontest.org/icfp10/ <-- b0rked?
05:29:48 <pastorn> ivanm: i was talking to a cute girl
05:29:51 <ivanm> tcrayford: then start hacking, unless you're attempting the lightning challenge
05:29:56 <ivanm> pastorn: good excuse
05:29:59 <ivanm> now _prove it_! :p
05:30:10 <ivanm> yeah, I get a 503 there as well
05:30:35 <tcrayford> ivanm: there's an advantage to registering early
05:30:38 <pastorn> hmm... at least it's not 15 pages like last years...
05:30:50 <ivanm> tcrayford: there is? what?
05:31:14 * ivanm had a quick skim through the task, and decided he couldn't be bothered trying to decode the bytecode they use
05:31:15 <tcrayford> right at the bottom of the task description
05:31:45 <tcrayford> your first submission is a car with code "0", and that starts earning profit as soon as you submit
05:31:57 <ivanm> oh, this one is time based as well?
05:32:04 <ivanm> not just "get it done by the end of the deadline" ?
05:32:06 <tcrayford> yeah
05:32:16 <aristid> ezyang: i haven't played the past few years, but in 2006 you had to first write an interpreter for a simple machine language and then solve various puzzles on a unix-like system run on there. together with the theme of archaeology, it was quite atmospheric, and that was part of the appeal.
05:32:52 <ezyang> Oh, that sounds kind of fun; like a mystery hunt type thing. 
05:32:56 <ivanm> aristid: that's the general approach nowadays IIUC, because the whole "implement a VM" approach means people aren't continually flooding their servers trying to test their code
05:33:07 <tcrayford> otherwise I'd be hacking away already, but you need to submit that car before you get the "key prefix"
05:33:26 <aristid> tcrayford: oh, that sucks
05:33:43 <pastorn> ivanm: have you ever used Data.Binary?
05:33:48 <pastorn> it's not that hard :)
05:34:00 <ivanm> nope
05:34:01 <aristid> i guess it makes sense to have disposal to computing resources in that case?
05:34:03 <ivanm> never had a reason to
05:34:28 <ivanm> for the most part, my code (that has been publically released) has been graph based
05:34:47 <ivanm> even the exception was vaguely graph based (but the actual graph stuff was shunted off to something else)
05:35:10 <tcrayford> I'm mostly entering this year so I can learn haskell somewhat better
05:35:31 <aristid> ivanm: if all you have is a hammer, everything looks like a nail? or, if all you have is a graph library, everything looks like a graph? :D
05:35:43 <ivanm> nope
05:35:57 <ivanm> aristid: my packages on hackage are: SourceGraph, Graphalyze, graphviz and haskell-updater
05:37:25 <pastorn> ivanm: let me find something for you...
05:37:30 <aristid> ivanm: in that case, the proper remark would probably be that you specialize in graph-based problems.
05:37:38 <genneth> does anyone know if there is some mailing list or channel for the ICPFC this year?
05:37:44 <ivanm> aristid: exactly
05:37:51 <ivanm> genneth: #icfp-contest
05:37:57 <ivanm> (seems to exist, anyway)
05:38:08 <ivanm> aristid: thing is, I started off with latin squares and got sucked into graphs :s
05:38:15 <ivanm> you do one honours thesis dealing with graphs...
05:38:16 <ivanm> ;-)
05:38:19 <genneth> @ivanm thanks
05:38:19 <lambdabot> Unknown command, try @list
05:38:27 <genneth> ivanm: thanks
05:38:32 <ivanm> np
05:38:44 <aristid> the command @ivanm is not yet implemented :D
05:38:45 <genneth> (ah lambdabot; how i have missed thee)
05:39:21 <genneth> (the channel certainly has grown since i last came around)
05:57:56 <tibbe> I'm trying to write a type family and type class for a Map data type: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26331
05:58:04 <tibbe> I can't quite figure out how to write it though
05:58:17 <tibbe> The concrete type of the map depends on both the key and value types
05:59:00 <ivanm> tibbe: lol, Axman6 was just doing that a few hours ago
05:59:37 <ivanm> tibbe: I would be tempted to use an AT for say the lookup type
05:59:54 <ivanm> unless you're explicitly wanting the instances to be for the lookup/value pair
06:00:09 <aristid> AT=Associated Type?
06:00:24 <ivanm> yup
06:00:27 <tibbe> ivanm: that all sounds sensible but I'm not sure what it means
06:01:24 <ivanm> tibbe: nvm, my idea isn't going to work
06:01:56 <ivanm> tibbe: are you wanting specialised instances for each lookup/value pair?
06:02:05 <ivanm> or just for each value?
06:02:07 <tibbe> ivanm: for each key/value yes
06:02:26 <ivanm> then what you have seems sensible
06:02:37 <ivanm> tibbe: except you need to have the "data IntMap" bit inside the instance
06:02:50 <ivanm> "data M Int Int = IntTip | IntBin ..."
06:02:58 <tibbe> ivanm: ah
06:03:30 <ivanm> Axman6: care to share your MapKey class with tibbe?
06:06:59 <tibbe> ivanm: I'd like one type class 'Map' that given the key value type defines the representation and the empty, lookup, etc functions
06:07:26 <ivanm> so it should be polymorphic in the value type?
06:07:47 <ivanm> tibbe: just remove the v from the type class definition?
06:09:31 <tibbe> ivanm: no, not polymorphic in the value type
06:10:00 <tibbe> ivanm: lets start with the basics: how many type families, type classes, associated types do I need?
06:10:01 <ivanm> oh, the key/value pair you mean?
06:10:20 <ivanm> tibbe: AFAIK, what you have is what you need
06:10:42 <aristid> tcrayford: is it just me, or does the icfp contest task seem to be rather difficult?
06:11:02 <ivanm> aristid: aren't they meant to be difficult?
06:11:19 <aristid> ivanm: well, maybe, but i have trouble even understanding it :)
06:11:27 <ivanm> heh
06:12:22 <tibbe> ivanm: I get constant type errors
06:12:32 <ivanm> paste them up?
06:12:44 <ivanm> tibbe: note: I've only ever used ATs, never type families themselves
06:13:57 <tibbe> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26333
06:14:08 <tibbe> ivanm: now it works, why is the extra GIntMap name needed?
06:14:19 <ivanm> tibbe: because it has to be unique
06:14:22 <ivanm> to that instance
06:14:34 <ivanm> which is why I said you should move the entire data structure into the type class
06:14:41 <ivanm> s/type class/instance/
06:14:56 <Phyx-> @hoogle trace
06:14:57 <lambdabot> Debug.Trace trace :: String -> a -> a
06:14:57 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
06:14:57 <lambdabot> module Debug.Trace
06:15:16 <tibbe> ivanm: I see
06:16:03 <ivanm> tibbe: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26334
06:16:22 <ivanm> tibbe: doing that kind of stuff with type families is around auto-magically picking the correct data structure for the task
06:16:58 <ivanm> unfortunately, you then have to be good at thinking of constructor names :s
06:17:48 <aristid> couldn't you use type instead of data in that class?
06:18:04 <tibbe> aristid: no idea :/
06:18:16 <Axman6> tibbe: this is what i've been working on: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26335#a26335
06:18:23 <ivanm> aristid: no
06:18:39 <ivanm> aristid: since it has to be able to distinguish between individual instances
06:18:40 <cizra> dcoutts_: Does gtk2hs support Assistants?
06:18:58 <ivanm> cizra: dcoutts doesn't hack on gtk2hs anymore
06:19:04 <aristid> ivanm: huh? can't type IN the class do that too?
06:19:08 <ivanm> better off asking ManateeLazyCat when he's online
06:19:15 <ivanm> aristid: not quite
06:19:23 <ivanm> aristid: see the actual type family paper for the graph example
06:19:46 <cizra> ivanm: OK, thanks
06:19:48 <ivanm> they try defining a Graph type class, and whilst they can use type for the node type for the edge type they need to use data
06:20:00 <ivanm> preflex: seen ManateeLazyCat
06:20:00 <preflex>  ManateeLazyCat was last seen on #haskell 4 hours, 2 minutes and 41 seconds ago, saying: s/simple/simpler
06:20:36 <aristid> ivanm: what is wrong about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26336
06:21:05 <ivanm> aristid: ummm... that _might_ work
06:21:22 <blobl> anyone knows how could i possibly change the size of a tab in wxhaskell?
06:21:30 <Axman6> tibbe: i have a feeling that my way of doing this should have better locality, since all the values will be stored in an unboxed array, and the key map just maps keys to indicies
06:21:40 <ivanm> aristid: but generally with this kind of stuff, you're writing throw-away types that you don't want to see outside the class anyway
06:21:48 <ivanm> so you might as well define it inside the class
06:22:01 <tibbe> Axman6: could be
06:22:06 <tibbe> Axman6: I can't tell at this point
06:22:14 <aristid> ivanm: ok so i didn't misunderstand it completely
06:22:23 <tibbe> Axman6: how do you avoid sparsity problems?
06:22:33 <aristid> tibbe: can you try if my version works?:)
06:22:35 <ivanm> aristid: I don't understand it fully myself, so my explanation could be wrong
06:22:36 <Axman6> what do you mean?
06:22:47 <ivanm> but I think it's right ;-)
06:23:03 <ivanm> Axman6: if you use an actual array, you might have a value with index 0 and another with index 100 and nothing in between
06:23:25 <ivanm> which is when Maps become better than arrays (not to mention resizing)
06:23:47 <Axman6> not the way i'm planning on using it. the KMaps hold the indicies that the the element was inserted into the array
06:24:22 <aristid> ivanm: i think rwh is much too thin :)
06:24:36 <Axman6> once the array is full, i'll make a new one, and put all the values from the old one, but the new one will be twice the size. so it should have amotised O(ln n) insert
06:24:55 <tibbe> aristid: can't you compile it yourself? :)
06:24:55 <ivanm> aristid: heh, we need an RWH2! (Mainly Real World Haskell? Slightly Future Haskell? :p)
06:25:01 <tibbe> aristid: I have something that works now
06:25:07 <ivanm> Axman6: and if you remove one in the middle?
06:25:20 <Axman6> ivanm: i'm not planning on having removals
06:25:38 <ivanm> fair enough
06:25:55 <aristid> tibbe: hmm it doesn't have many dependencies, so i could probably try
06:26:04 <Axman6> of, if i do, it'll be creating a completely new piece of data
06:30:45 <aristid> tibbe, ivanm: it does not work :(
06:30:50 <ivanm> aristid: :(
06:30:53 <ivanm> didn't think it would
06:31:13 <ivanm> because there was no way of forcing that type alias to be exclusive to Int/Int
06:32:09 <aristid> ivanm: well, my current code is this:
06:32:39 <aristid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26337
06:33:50 <ivanm> aristid: after all, you could be using IntMap for an Int/Word pairing that does fromIntegral conversions as part of lookup
06:37:30 <philo> any one here participating to the ICPcontest ?
06:37:50 <zenzike> yup
06:38:29 <zenzike> haven't got much done yet, only just started reading the spec
06:38:49 <philo> lol
06:38:54 <philo> i just heard of the constest 
06:39:07 <philo> i thought it was to late to even try
06:39:10 <pastorn> zenzike: at least it's not control theory madness, like last year
06:39:27 <zenzike> pastorn: very true. I gave up when I thought I had to work out some astrophysics
06:39:32 <pastorn> philo: the task was released just 1:40 ago
06:39:47 <pastorn> this seems more doable :)
06:39:52 <philo> really ? lol
06:40:07 <tibbe> Axman6: I'm thinking about how to abstract over the constructor so most functions (like lookup) can be written once generically
06:40:52 <Axman6> i'm not sure there's an easy way to do that. though there's a good chace that the specialised versions will perform better anyway
06:41:37 <ivanm> yeah, that's kinda the whole point of these types of classes
06:42:00 <ivanm> tibbe: unless you instead have the class have methods to get the individual parts of the data structure
06:42:04 <philo> btw how is the state of the haskell debugger
06:42:13 <philo> it seems it deosnt receive much love
06:42:15 <ivanm> hmmm.... can you force a type family to have records? :p
06:42:22 <ivanm> philo: the one in ghci?
06:42:25 <Axman6> philo: because no one uses it, it's not needed
06:42:26 <ivanm> I've never used it
06:42:29 <tibbe> Axman6: could one do something like: class GMap k v where { data Map k v :: * ; tip :: Map k v ; bin :: Size -> k -> k -> Map k v -> Map k v -> Map k v }
06:42:41 <tibbe> ivanm: exactly
06:42:50 <tibbe> ivanm: gives much less code duplication
06:42:58 <edwardk_> hrmm the icfp contest registration seems to be broken if you include a + in your email address.
06:43:10 <tibbe> ivanm: so the smart constructors is easy, I guess I need a function that abstracts the case statement
06:43:10 <Axman6> tibbe: could work
06:43:37 <Axman6> i don't know, i haven't tried using ... GADTs? before
06:43:38 <edwardk_> tibbe: that approach has worked quite well actually
06:44:04 <ivanm> tibbe: not even a smart constructor, I'm talking about getter methods
06:44:06 <tibbe> maybe: unMap :: a -> (Size -> k -> v -> Map k v -> Map k v -> a) -> a
06:44:07 <philo> is there any other debugger ?
06:44:09 <edwardk_> tibbe: you can then use view patterns to deconstruct GMaps.
06:44:15 <ivanm> philo: just using ghci itself
06:44:21 <edwardk_> tibbe: or continuation passing style like that
06:44:26 <tibbe> ivanm: what I just gave above is the getter method (it abstracts case)
06:44:31 <Axman6> philo: you don't need a debugger
06:44:32 <ivanm> philo: smaller functions + type sigs + interactive testing == debugging ;-)
06:44:40 <tibbe> Edward__: makes the code a bit ugly though
06:44:47 <philo> yea yea the same thing everyone is saying 
06:44:48 <ivanm> tibbe: oh, must have missed that bit
06:44:52 <philo> still not convince of that
06:44:57 <ivanm> tibbe: Edward__ /= edwardk_ 
06:44:58 <ivanm> ;-)
06:45:03 <edwardk_> gah
06:45:06 <ivanm> philo: why do you need a classical debugger?
06:45:15 <Axman6> philo: basically, if your functions are big enough that you can't tell where they're going wrong with ghci, they're too big
06:45:24 <ivanm> Axman6: agreed
06:45:25 <edwardk> there =)
06:45:29 <tibbe> edwardk:  makes the code a bit ugly though
06:45:32 <kamatsu> what about some enormous monadic action?
06:45:38 <tibbe> edwardk: continuation style that is
06:45:38 <edwardk> tibbe: its not so bad. let me dig up an example
06:45:39 <ivanm> kamatsu: split it up!
06:45:51 <Axman6> philo: seriously, _no one_ uses the debugger, because haskell's style basically eliminates the need for it
06:45:53 <kamatsu> ivanm: that writes to a file? how do you test that in GHCi?
06:46:01 <edwardk> http://hackage.haskell.org/packages/archive/unboxed-containers/0.0.1/doc/html/Data-Set-Unboxed.html
06:46:06 <kamatsu> (i'm just playing devil's advocate)
06:46:21 <ivanm> this is probably the biggest function I've written, and it's only so big because i was following the paper's definition of this algorithm: http://hackage.haskell.org/packages/archive/Graphalyze/0.9.0.0/doc/html/src/Data-Graph-Analysis-Algorithms-Clustering.html#nbrCluster
06:46:29 <philo> the whole functional languages/haskell dont need debugger thing still havent convince me 
06:46:33 <edwardk> findMax (view -> Bin _ x _ (null -> True))  = x, etc.
06:46:46 <Axman6> philo: well try it and find out for yourself
06:46:48 <philo> but hey is the communuty agrees with it 
06:46:51 <ivanm> philo: OK, let's say there's a greatly reduced need for a classical debugger
06:47:05 <ivanm> and it's more "the langs with decent REPLs" rather than functional langs
06:47:05 <philo> ivanm:  true to that 
06:47:29 <ivanm> and I don't do that much IO stuff that I would need to step through something like that
06:47:29 <philo> REPLS ?
06:47:32 <edwardk> tibbe: the view patterns are far less invasive than using a cps'd case
06:47:40 <ivanm> when I have, however, I stepped it out line by line explicitly by entering it into ghci
06:47:48 <ivanm> probably not the most efficient method, but *shrug(*
06:47:52 <ivanm> philo: Read Eval Print Loop
06:47:57 <ivanm> i.e. interactive interpreter
06:48:04 <ivanm> or just an interactive environment
06:48:29 <ivanm> there are pseudo-REPLs for C and Java, but they're a PITA (at least the Java one is)
06:48:40 <ivanm> Lisp languages probably have the best REPLs
06:48:43 <ivanm> Python's isn't bad
06:48:48 <philo> RELS = ?
06:49:00 <edwardk> philo: read-eval-print-loop -- the console
06:49:02 <ivanm> where did I use "RELS" ?
06:49:20 <ivanm> ghci and hugs are limited in that you can't define new data types or complex functions
06:49:21 <tibbe> edwardk: in my experience they don't get eliminated by the compiler well enough
06:49:27 <ivanm> apparently HBC's REPL let you though
06:49:28 <philo> lol
06:49:44 <arw_> ghci lacks something like hoogle does...
06:49:52 <philo> ruby ineractive shell is much more powerfull , but that s not the point
06:50:11 <EvanR-work> than ghci?
06:50:21 <philo> yea in term of defining stuff
06:50:23 <ivanm> arw_: you can put hoogle into ghci
06:50:27 <ivanm> see the wiki
06:50:39 <Axman6> philo: if only they spent more time making it less of a shitty language ;)
06:50:41 <arw_> ivanm: really? cool.
06:50:47 <philo> but really is it the job of an interactive shell to replace a debugger ?
06:50:56 <EvanR-work> philo: what do you use a debugger to do?
06:50:57 <philo> Axman6: shitty ?
06:51:02 <Axman6> yes shitty
06:51:03 <ivanm> arw_: in the sense that you can do hoogle searches inside ghci, like @hoogle does here
06:51:04 <ivanm> philo: right, it's proabably a full-on REPL
06:51:07 <edwardk> tibbe: i wound up with equivalent output with -O2 and -fdicts-cheap (and IIRC, -fspec-constr)
06:51:11 <Axman6> it's slow and typeless
06:51:15 <edwardk> tibbe: your mileage may vary =)
06:51:24 <philo> EvanR-work:  not much 
06:51:25 <arw_> ivanm: thats close enough
06:51:39 <ivanm> philo: put it this way: I've never used a debugger with Haskell
06:51:52 <tibbe> edwardk: ok, good to know
06:52:01 <ivanm> (actually, I don't think I've used a debugger full stop... but then, I did minimal C coding and don't really do any interactive coding)
06:52:04 <philo> ivanm: yea ...you but your are not the only one using haskell are you ?
06:52:24 <ivanm> no
06:52:32 <EvanR-work> debugging to me is checking that functions evaluate correctly, and stepping through IO actions
06:52:33 <ivanm> but AFAIK most of us here don't use a debugger
06:52:43 <tibbe> do INLINE pragmas go in the type class definition or instance?
06:52:45 <philo> the ICPcontest is freaking strage lol
06:52:55 <ivanm> philo: you can step through stuff explicitly yourself in ghci
06:53:04 <Axman6> hands up those who have used the ghci debugger more than once
06:53:12 <ivanm> so you have greater control over what you're testing rather than trying to do that testing at run-time
06:53:22 <Axman6> tibbe: instances i believe
06:53:25 <ivanm> Axman6: no, make that "who has seriously used the ghci debugger"
06:53:33 <EvanR-work> whats the ghci debugger?
06:53:35 <Phyx-> I've tried.. but...
06:53:37 * pastorn has
06:53:41 <ivanm> EvanR-work: there's a debugger inside ghci
06:53:43 <Phyx-> i got fustrated with it
06:53:45 <EvanR-work> wow
06:53:48 <ivanm> the whole step, break points, etc.
06:53:56 <ivanm> pastorn: :o
06:53:59 <pastorn> i found a call to 'undefined' inside a library somewhere
06:54:01 <ivanm> someone has used it! :o
06:54:06 <ivanm> which library?
06:54:14 <pastorn> (someplace where it was never supposed to be executed)
06:54:34 <pastorn> it was like 'if False then undefined else ...'
06:54:39 <philo> but even in a purely theorical point of view i really have hard time understanding why  an interactive shell is a replacement for a debugger 
06:54:40 <ivanm> hmmmmm....
06:54:41 <pastorn> ivanm: GPipe
06:54:45 <philo> they seems to be totaly unrelated
06:54:48 <ivanm> *tsk, tsk*
06:55:03 <ivanm> philo: OK, tell me, what does a debugger give you?
06:55:06 <ivanm> in terms of functionality
06:55:07 <pastorn> i still have the log from my debugging session, if someone want to start quickly
06:55:14 <pastorn> (see what commands are used etc.)
06:55:14 <EvanR-work> philo: imperative code has a lot of bugs which simply dont exist or is impossible either because all haskell functions are pure or there is a non shitty type system
06:55:32 <philo> ivan in short analysing how my program behave on runtime 
06:55:34 <EvanR-work> so you are left with unit testing functions to make sure they work right
06:55:51 <pastorn> ivanm: it worked on nvidia+windows, not ati+ubuntu
06:56:07 <EvanR-work> performance is not measured with a debugger
06:56:38 <ivanm> philo: well, why not just do interactive testing of your individual functions at development time?
06:57:02 <philo> ivanm: i do 
06:57:20 <ivanm> so why do you need to analyse how your programs behave at runtime?
06:57:34 <philo> ivanm: but would that be better than using a full flege debugger ?
06:57:39 <pastorn> ivanm: not all functions can be pure...
06:57:56 <EvanR-work> blasphemy!
06:57:56 <philo> ivanm: will partial value and everything
06:58:03 <philo> EvanR-work: LOL
06:58:04 <pastorn> hehe
06:58:30 <ivanm> pastorn: "will partial value" ?
06:58:38 <EvanR-work> you can usually easily set up necessary inputs for a function
06:58:52 <EvanR-work> even in IO
06:58:57 <ivanm> philo: there might be a point for IO stuff
06:59:01 <ivanm> but for pure stuff?
06:59:09 <ivanm> philo: anyway, you asked why it wasn't getting any love
06:59:10 <baldurb> nerds!
06:59:17 <ivanm> @where ops
06:59:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
06:59:32 <ivanm> philo: the reason is simple: who do you expect to maintain it?
06:59:43 <tibbe> edwardk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26331#a26338 <-- type error with the continuation representation. any idea why?
06:59:43 <ivanm> SPJ, etc. are more interested in implementing cool stuff
06:59:56 <philo> ivanm: i see
07:00:07 <allbery_b> mrf?
07:00:15 <ivanm> if someone actually cares about it, they should stand up and do something about it
07:00:23 <allbery_b> someone batsignaled?
07:00:40 <ivanm> allbery_b: nvm; the obvious troll left before you woke up
07:01:05 <Phyx-> ivanm: speaking of SPJ does he have a public repo with implementations of stuff he references in his papers? or should i just mail him?
07:01:07 <philo> ivanm: well is nobody is gonna use it there is very litle point to that
07:01:28 <ivanm> OK, and now they're trying to troll #xmonad
07:01:41 <ivanm> philo: probably email him
07:01:53 <philo> email who ?
07:02:14 <ivanm> philo: sorry, that was meant for Phyx- 
07:02:35 <Phyx-> ivanm: Think you meant me :) but ok, I'll give him a mail, interesting in his stack trace implemenation
07:03:58 <Alcohol17646> You know Stephen William Hawking?
07:04:20 <ivanm> not personally
07:04:38 <philo_> is there any other language that have lazy avaluation 
07:04:44 <philo_> but not as default 
07:04:57 <edwardk> tibbe: loading it up
07:05:10 <pastorn> philo_: i've heard of a weird german language that's only used at some university...
07:05:28 <tibbe> edwardk: thanks
07:05:34 <EvanR-work> philo: well any language with generators or coroutines etc
07:05:35 <pastorn> but that language seemed to have everything (from partial application to object orientation to lazy evaluation etc)
07:06:00 <pastorn> EvanR-work: public new GeneratorFactory()
07:06:06 <EvanR-work> yes
07:06:08 <edwardk> unRep m Nothing ?
07:06:31 <edwardk> you missing an arg for unRep in its type signature?
07:06:46 <ivanm> Guest83829: you wanting an official invitation or something? :p
07:06:52 <EvanR-work> static public void InsaneSubclassOfSpecializedNonsense(
07:06:55 <edwardk> unRep a -> (Size -> k -> v -> Rep k v -> Rep k v -> a) -> Rep k v -> a  -- or to get your code to be happy, placed in first position
07:07:03 <edwardk> er unRep :: 
07:07:04 <tibbe> edwardk: do
07:07:58 <edwardk> the only interesting inhabitant of your existing unRep type is 'const' =)
07:08:05 <tibbe> edwardk: how do I refer to the inner rep type in type signatures outside the type class?
07:08:15 <tibbe> heh
07:08:26 <Alcohol17646> Who wishes to talk to the guy from Russia, is final in English
07:08:37 <sinelaw> ivanm: yes. :)
07:08:53 <edwardk> just use Rep k v 
07:09:20 <edwardk> lookup :: Map k v => k -> Rep k v -> Maybe v
07:09:25 <tibbe> edwardk: oh so it's promoted to global scope?
07:09:28 <edwardk> yeah
07:09:45 <tibbe> edwardk: it's a bit annoying that I have two names, Rep and Map
07:09:57 <edwardk> tibbe: i have a full implementation of this using trees of bounded balance if you want ;)
07:10:10 <edwardk> tibbe: i don't have it handy though
07:10:26 <edwardk> tibbe: yeah that is the cost of type families =/
07:10:30 <tibbe> edwardk: some other day maybe, I want to stare at the core for a while and run some benchmarks
07:10:36 <EvanR-work> how do i split on ;, but not \;, but do split on \\; but the left side gets a \ at the end
07:10:39 <EvanR-work> ;)
07:10:43 <edwardk> tibbe: sure thing.
07:10:46 <edwardk> key observation
07:10:55 <edwardk> you probably need to move your balance method _into_ your map class
07:11:16 <edwardk> even if you provide the default implementation and don't export it ;)
07:11:26 <tibbe> edwardk: yes, and perhaps other stuff as well if I want to use IntMap for implemeting some Map types
07:11:27 <edwardk> that way the dictionary selection happens once
07:11:30 <edwardk> yeah
07:11:55 <tibbe> edwardk: so there's no way of preventing both Rep and Map to appear in type signatures?
07:12:05 <edwardk> also, this approach worked really well for unboxing, but i'm not as certain it is ideal for generalized tries.
07:12:20 <edwardk> tibbe: fraid not.
07:12:25 <tibbe> edwardk: could be, I'm trying the unboxing thing now
07:12:28 <edwardk> tibbe: the alternative is to use MPTCs
07:12:33 <edwardk> tibbe: but
07:12:36 <tibbe> edwardk: I think Data.Vector avoids it somehow
07:12:49 <edwardk> looup :: Map k v m => k -> m -> Maybe v 
07:12:58 <Ulfalizer> how do lexers/parsers handle situations in which the token type depends on context, such as when you're allowed to use keywords as the names of identifiers?
07:13:18 <tibbe> edwardk: I was wrong, it doesn't
07:14:28 <edwardk> Ulfalizer: if you're using parser combinators just call the appropriate parser at that point
07:14:52 <edwardk> Ulfalizer: or use (keyword <|> token), etc.
07:15:08 <Ulfalizer> edwardk: i'm not using anything at all currently. i just got curious.
07:15:23 <Ulfalizer> not really haskell related, but i figured there'd probably be people into parsing here :)
07:16:19 <edwardk> Ulfalizer: the key is that while you probably want your grammar to be unambiguous, keywords don't need to be keywords in all contexts. and even if you tokenize and generate them before handing off to a parser, you can dumb them back down into identifiers as needed
07:16:56 <Ulfalizer> it'd get trickier for a flex/bison-like solution though. i guess you could set flags in the parser as you enter certain constructs that are then checked by the lexer..
07:17:10 <Ulfalizer> edwardk: yeah, that could work too
07:17:57 <edwardk> Ulfalizer: nah, you just make your "keyword-or-identifier rule that matches the arbitrary keywords or the underlying identifier type." We do it even in the Haskell grammar, 'as' and 'qualified' are only keywords in import declarations.
07:18:17 <Ulfalizer> or maybe have a type_or_id token that you then interpret correctly in the parser
07:18:23 <edwardk> yeah
07:18:51 <edwardk> though in general it is easier to generate a keyword and dumb it back down than the other way, because that requires more conditional reasoning in the parser
07:19:00 <Tomsik> I had that problem some time ago, I just had "string: X" kind of token
07:19:03 <Tomsik> and let parser decide
07:19:14 <Ulfalizer> yep, i would think that too
07:19:28 <Tomsik> because parser has enough data to know this
07:19:50 <Tomsik> but in general, if I was designing anything, I would try to avoid that
07:20:07 <Ulfalizer> a keyword getting converted to an id is the rarer case anwyay, so it'd probably be cleanest to just have some special code to handle it where it's needed
07:23:55 <ivanm> tibbe: I can't recall where I read it, but if you're wanting to do a balance method IIRC the Set and Map implementations don't do any balancing because IIRC, on average it ends up balancing itself out anyway so not having an explicit balance method means that the runtimes are better
07:24:02 <tibbe> edwardk: core for lookup looks good
07:24:14 <nominolo> @seen JPMoresmau
07:24:15 <lambdabot> Unknown command, try @list
07:24:19 <nominolo> preflex: seen JPMoresmau
07:24:19 <preflex>  Sorry, I haven't seen JPMoresmau
07:24:37 <tibbe> ivanm: Data.Map does balance
07:24:45 <tibbe> ivanm: IntMap doesn't I think
07:24:48 <ivanm> oh? whatever I read must have been wrong/mistaken then
07:24:51 <edwardk> ivanm: you want a tree of bounded balance
07:25:01 <edwardk> ivanm: not a red-black tree or the like
07:25:06 <ivanm> edwardk: I don't want anything of the sort! :p
07:25:34 <nominolo> tibbe: IntMap doesn't balance, correct.  Data.Map isn't fully balanced
07:25:41 <edwardk> bounded balance strikes a good er.. balance between balancing and not copying stuff around
07:25:49 <tibbe> nominolo: what does "fully" mean in this context?
07:26:00 <tibbe> nominolo: oh, you mean it's bounded? yes
07:26:04 <edwardk> nominolo: that is because IntMap is a patricia trie, which relies on the fact that each bit only gets observed once to provide its bounds
07:26:40 <nominolo> tibbe: it doesn't guarantee max(depth) = ceil(log2(N))
07:27:25 <nominolo> edwardk: right, it's max depth is bitlength(key)
07:27:32 <ivanm> nominolo: is it true that you've stopped hacking on scion? Phyx- was saying that he couldn't/didn't want to use it for Visual Haskell because it was no longer being actively developed and didn't have some stuff he needed
07:28:10 <nominolo> ivanm: no, it's not true.  I just committed big patches yesterday
07:28:23 <nominolo> ivanm: I'm working on it Right Now (tm)
07:28:34 <ivanm> Phyx-: see! I told you!!! ^^
07:29:11 <nominolo> I've had to re-organise things considerably, hence no progress on the feature front.
07:29:16 <edwardk> tibbe: i'd been thinking about doing an unboxed fingertree using the same technique (though with the view pattern matchinery)
07:29:35 <ivanm> nominolo: any idea when an actual release can be expected?
07:30:01 * ivanm has so far put off trying out scion because he doesn't want to spend the time fiddling with getting it working
07:30:03 <nominolo> in a month, aybe
07:30:34 <ivanm> cool
07:30:59 <nominolo> ivanm: it has still a lot of basic stuff missing, mainly because it requires an infratructure
07:31:19 <nominolo> e.g. looking up documentation
07:31:40 <ivanm> *nod*
07:32:08 <Phyx-> ivanm: no no, i said, that he was gonna work on it but if i used it I would have to wait untill something I needed was implemented, which would not be ideal
07:32:09 <edwardk> tibbe: by moving the balance algorithm into your particular instance you can flip back and forth between patricia and bounded balance on a type-by-type basis
07:32:10 <nominolo> people generally just hack up half-assed solution and declare it good enough.
07:32:23 <ivanm> Phyx-: oh, my apologies then
07:32:38 <nominolo> Phyx-: why not help then?
07:33:05 <tibbe> edwardk: exactly what I had in mind
07:34:00 <ttmrichter> Is there somewhere that explains the "forall" keyword extension in GHC in a way that a dullard like me can understand?
07:34:59 <Phyx-> nominolo: good question, my current approach is just a bit easier, as i've mentioned before i'm not adversed to switching later. And also I'm not quite sure how useful some of the stuff I need would be for others
07:35:46 <nominolo> Phyx-: ok, what I've been interested in is a collection of feature-stories.
07:36:31 <nominolo> Phyx-: I.e., a brief description of a feature + a number of use cases illustrating the interesting corner cases.
07:36:33 <edwardk> wait, i just caught the reference to visual haskell. does this mean someone is actively maintaining/improving it?
07:37:09 <nominolo> Phyx-: those can then be discussed to figure out, what features need to be provided from the backend.
07:37:18 <nominolo> s/,//
07:37:41 <Phyx-> edwardk: http://mistuke.files.wordpress.com/2010/06/errors1.png my current progress, I need to get a version done before september, since then I'll have to switch and put more time in my thesis project :|
07:38:04 <Phyx-> nominolo: true, I'll start writing them down, I'm still doing alot of experimentation
07:38:05 <edwardk> Phyx-: nice!
07:38:40 <Phyx-> nominolo: what I just added for instance, aside from getting information about the type of functions etc, I wanted to know if the type was infered or statically there
07:39:25 <edwardk> Phyx-: did you start from JaffaCake's old visual haskell?
07:39:43 <Phyx-> edwardk: JaffaCake made one?
07:39:58 <edwardk> http://www.haskell.org/visualhaskell/
07:40:13 <edwardk> used cabal files as project files
07:40:22 <JaffaCake> I wouldn't start from there if I was making one now
07:40:23 <nominolo> Phyx-: Scion can show the type that something is used at (e.g., mempty :: Int instead of Monoid m => m)
07:40:25 <edwardk> worked in 2003 and 2005 iirc
07:40:52 <Phyx-> edwardk: oh, that's his? no, I couldn't use that
07:41:30 <Phyx-> nominolo: not what I meant, what i mean is, if i have a function definition, and i get it's type, was that type infered or checked
07:41:50 <Phyx-> edwardk: it used internal structures from GHC and some just dissappeared around 6.8
07:42:04 <edwardk> Phyx-: ah
07:42:13 <nominolo> Phyx-: I still don't get it.  You mean whether it was specified via a type declaration?
07:42:17 <Phyx-> edwardk: add to that that the com bridge was not maintained, and the IDLs for visual studio changed, I had to rewrite
07:42:22 <Phyx-> nominolo: yes
07:42:41 <nominolo> Phyx-: what would that be good for?
07:43:16 <Phyx-> edwardk: in order to avoid that in the future, I wrote the core in C# and all the interaction with ghc is just via the ghc api
07:43:19 <nominolo> Phyx-: it doesn't correspond much to GHC's notion of inferred vs. expected
07:43:43 <edwardk> Phyx-: yeah, i ran into the visual studio IDL changes in another context. i was mostly pointing to it as a reference in case you didn't know the general areas to plugin into in visual studio, or how to juggle some of the big things like project types
07:44:08 <Phyx-> nominolo: well, what I use it for, is if you don't have a type declaration for a function, it can display the type ghc infered for you, and you can just press tab to insert it in the file
07:45:12 <nominolo> Phyx-: ah, right, Scion has that (except for the TAB+insert part, but that's not hard to add)
07:47:00 <Phyx-> nominolo: ah, ok, well I guess i have to give it another consideration.
07:47:13 <Phyx-> edwardk: I do email him and simon once a while when I'm really stuck
07:47:25 <Phyx-> they've both been nice enough to answer too
07:52:27 <edwardk> Phyx-: fair enough. =) Doug Hodges over an Microsoft was really useful when I got stuck dealing with visual studio internals as well, but looking at his title these days, he might be a bit high up the foodchain
07:54:04 <Phyx-> edwardk: I've been getting alot of help from random Visual studio devs on the msdn forums, most notably Noah Richards
07:54:14 <Phyx-> and they're recently put alot of nice samples online
07:55:08 <JaffaCake> Phyx-: how's it coming along?  any idea when you'll have something we can play with?
07:55:28 <Phyx-> my only annoyance is that their project templates (MPF) has MSBuild hardcoded in it. So I'm working on abstracting the functionality needed to interfaces so I can just implement cabal over it as the build engine
07:56:34 <Phyx-> JaffaCake: well, vacation from uni starts on the 30th for me, I think around end July I would have something that's feature complete compared to the original one. since then I can work on it all day
07:57:02 <JaffaCake> sounds great! look forward to seeing it
07:57:03 <Phyx-> currently i'm juggling between my thesis work and it, and thesis has been winning out
07:57:07 <Phyx-> lol
07:57:28 <JaffaCake> ah, you need to get your priorities straighened out :)
07:58:35 <Phyx-> hehehe :)
08:01:09 <J-roen> Is it possible to print the type of a value?
08:02:20 <gwern> :t 5.0
08:02:21 <lambdabot> forall t. (Fractional t) => t
08:02:25 <sinelaw> J-roen in ghci you can
08:02:25 <gwern> J-roen: yes
08:02:30 <sinelaw> as gwern has shown
08:02:42 <J-roen> Thanks, but can it be done in Haskell?
08:02:43 <sinelaw> but during normal program runtime, you can't (as far as I know)
08:02:55 <J-roen> Okay, that was what I wanted to know.
08:03:02 <sinelaw> maybe I'm wrong
08:03:02 <gwern> type erasure
08:03:05 <sinelaw> yeah
08:03:09 <gwern> you'd lose newtypes, at the very least
08:03:42 <sinelaw> maybe there's a debug mode that allows it
08:03:59 <sinelaw> J-roen but types are static, so you can know at compile time anyway
08:04:11 <sinelaw> J-roen why do you want it?
08:04:13 <gwern> I guess you could get the type by linking in the ghc api... it supports querying the type of an expression, eg. look at mueval
08:04:35 <J-roen> Just being curious
08:04:44 <sinelaw> unless you're doing dynmaic code interpretation like ghci does
08:05:02 <sinelaw> you can know they type of every value when the program compiles
08:05:15 <Axman6> isn't this kind of the point of typable?
08:05:21 <c_wraith> hint has a simple interface to get a string representation of the type of an arbitrary expression.
08:05:39 <Axman6> @hoogle typRep
08:05:40 <lambdabot> No results found
08:05:44 <Axman6> @hoogle TypeRep
08:05:45 <lambdabot> Data.Typeable data TypeRep
08:05:45 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
08:05:45 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
08:05:58 <c_wraith> @hoogle typeOf
08:05:58 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
08:05:58 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
08:05:58 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
08:06:14 <Axman6> > show (typeOf (1 :: Int))
08:06:15 <lambdabot>   "Int"
08:06:22 <Axman6> > typeOf (1 :: Int)
08:06:23 <lambdabot>   Int
08:06:41 <c_wraith> Typeable only works on monomorphic arguments, though.
08:06:45 <J-roen> Looks nice
08:06:50 <Axman6> > typeOf x where x = undefined; x :: Bool
08:06:50 <lambdabot>   <no location info>: parse error on input `where'
08:07:08 <c_wraith> > typeOf 1
08:07:09 <lambdabot>   Integer
08:07:17 <J-roen> What does the polytypeable package provide?
08:07:18 <c_wraith> See defaulting kick in?
08:07:43 <Axman6> @instances Typeable
08:07:43 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
08:07:54 <J-roen> Looks like doing the same thing for polymorphic types...
08:08:04 <Axman6> @instances-importing Data.Typeable.Typeable Typeable
08:08:04 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
08:08:23 <Axman6> @instances-importing Data.Typeable Typeable
08:08:24 <lambdabot> s a
08:08:29 <Axman6> o.O
08:08:30 <c_wraith> hahaha.
08:08:52 <c_wraith> that's the (Typeable1 s, Typeable a) => Typeable (s a) instance.
08:09:31 <c_wraith> And apparently, it's the only one defined in Data.Typeable.
08:09:37 <Axman6> > typeOf1 (Just 4)
08:09:38 <lambdabot>   Maybe
08:09:42 <Axman6> > typeOf (Just 4)
08:09:43 <lambdabot>   Maybe Integer
08:10:10 <J-roen> Have you tried polyTypeOf yet? Seems to work.
08:10:10 <Axman6> anyway, sleep time. night all
08:10:15 <J-roen> Bye
08:10:27 <c_wraith> I wasn't aware of the package.  Sounds kinda cool.
08:10:41 <J-roen> Indeed
08:10:45 <sinelaw> night Axman6
08:10:51 <benmachine> does it use HorribleInstances or something
08:10:57 <J-roen> Guess so :)
08:11:08 <gwern> -XScarifyingInstances
08:11:34 <edwardk> c_wraith: you can make Typeable's for polymorphic arguments, you just need to do it yourself
08:11:35 <c_wraith> Oleg wrote it..
08:11:46 <c_wraith> So it probably is terrifying
08:11:47 <benmachine> Incoherent apparently
08:11:48 <benmachine> ew
08:12:08 <edwardk> benmachine: Typeable?
08:12:21 <benmachine> edwardk: hm?
08:12:24 <c_wraith> undecideable and incoherent, actually
08:12:33 <Shown> does anyone known something about SLR parsers?
08:12:42 <benmachine> yes but I'm personally not opposed to undecideable :)
08:12:48 <gwern> Shown: they're better than analog cameras, but pretty expensive
08:12:50 <benmachine> *undecidable
08:13:00 <edwardk> benmachine: the (Typeable1 s, Typeable a) => Typeable (s a) -- is coherent
08:13:03 <benmachine> I am way underqualified to be passing comment on GHC extensions
08:13:31 <c_wraith> edwardk: we're talking about polytypeable
08:13:34 <benmachine> edwardk: sure, but
08:13:38 <edwardk> ahhh
08:13:39 <c_wraith> http://hackage.haskell.org/packages/archive/polytypeable/0.1.0.0/doc/html/src/Data-PolyTypeable.html
08:13:41 <benmachine> http://hackage.haskell.org/packages/archive/polytypeable/0.1.0.0/doc/html/src/Data-PolyTypeable.html <-- Incoherent
08:13:45 <benmachine> oh
08:13:45 <benmachine> yes
08:13:48 <benmachine> that
08:14:11 <J-roen> What does "incoherent" mean in this context?
08:14:11 <edwardk> how... interesting =)
08:14:30 <Fuco> is there any way to represent a list of different types?
08:14:32 <benmachine> J-roen: it's a type extension which people other than me understand
08:14:57 <Fuco> I want to make unification algorithm, so I need to represent terms with variables/constants
08:15:09 <benmachine> J-roen: I believe it's somewhat similar to OverlappingInstances, but less picky about which instances it uses
08:15:12 <c_wraith> Fuco: pretend the answer is no.  Use an ADT.  possibly a GADT
08:15:26 <edwardk> Fuco: HLists, or an ADT for your value types
08:15:28 <J-roen> benmachine: Okay, thanks
08:15:40 <edwardk> Fuco: but the hlist probably won't work for the scenario you just mentioned
08:15:57 <edwardk> Fuco: there is also 'Dynamic' ;)
08:16:03 <benmachine> J-roen: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#instance-overlap has more information
08:16:29 <c_wraith> is Dynamic in instance of Typeable? :)
08:16:47 <c_wraith> err, *an* instance
08:16:51 <edwardk> Fuco: or you can do horrible trickery like i do in my stable maps: http://hackage.haskell.org/packages/archive/stable-maps/0.0.1/doc/html/System-Mem-StableName-Map.html
08:17:08 <benmachine> c_wraith: yes
08:17:16 <benmachine> > typeOf (toDyn 'a')
08:17:16 <lambdabot>   Dynamic
08:17:30 <Fuco> ok thanks for some ideas
08:17:36 <benmachine> > typeOf (toDyn 'a') == typeOf (toDyn [(), ()])
08:17:37 <lambdabot>   True
08:17:42 <benmachine> *gasp*
08:17:50 <edwardk> Fuco: in general the usual answer is to just build an ADT out of all the different types you might store
08:17:51 <benmachine> but there you go
08:17:59 <c_wraith> nah.  The whole point of Dynamic is that it throws away compile-time type info. :)
08:18:19 <benmachine> I don't think it throws it away as such
08:18:31 <c_wraith> well.  From the type-checker's perspective, it does
08:18:42 <benmachine> it's still safe as long as you don't break Typeable
08:19:00 <benmachine> but then I guess that is throwing away information since that's now sorted at runtime instead of compile time
08:19:33 <c_wraith> I don't think you can break typeable in a way that will turn Dynamic into unsafeCoerce
08:19:47 <benmachine> you can break typeable in a way that turns cast into unsafeCoerce
08:20:07 <benmachine> and fromDynamin . toDyn is basically cast isn't it?
08:20:12 <benmachine> :t fromDynamic . toDyn
08:20:13 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a1 -> Maybe a
08:20:17 <benmachine> yeah
08:20:30 <c_wraith> really?  Huh.  I thought Typeable used some form of object identity
08:20:34 <benmachine> basically you just use a newtype wrapper that lies about what's inside it
08:20:58 <c_wraith> heh.  thanks to my dealings with hint, I've become familiar with lying in Typeable instances. :)
08:21:16 <c_wraith> (In order to make things work, rather than break them.  But that's just a minor detail)
08:21:25 <benmachine> newtype Eek a = Eek { erk :: a }; instance Typeable (Eek a) where typeOf _ = typeOf ()
08:21:48 <benmachine> then you can happily cast between Eek Int and Eek Bool because they're both type ()
08:21:54 <benmachine> (except of course they're not.)
08:22:54 <c_wraith> Yeah.  Typeable is really kind of dangerous to trust.
08:23:21 <benmachine> well, you have to deliberately try to break it for it to go wrong really :)
08:24:05 * Phyx- really needs to learn to comment better
08:24:09 <edwardk> benmachine: well, one can say the same about unsafeCoerce ;)
08:24:48 <c_wraith> I guess typeable doesn't break anything by itself.  unsafeCoerce is still a required step.
08:25:08 <benmachine> mm
08:25:13 <c_wraith> It's just that using Typeable to determine when you can unsafeCoerce isn't as reliable as you'd hope.
08:25:44 <benmachine> in theory it's possible to write cast and hence Dynamic and all that without unsafeCoerce
08:25:55 <benmachine> or so I've heard
08:26:09 <Philonous> Maybe ghc should include magic that gives us runtime representations of types that are statically proven save
08:26:16 <Phyx-> @url syb
08:26:17 <lambdabot> http://www.cs.vu.nl/boilerplate
08:26:18 <c_wraith> well, you can do it with unsafePerformIO instead of unsafeCoerce...  But that doesn't worry me.
08:26:24 <Phyx-> @url syb docs
08:26:25 <lambdabot> http://www.cs.vu.nl/boilerplate
08:26:33 <Phyx-> @url syb haddock
08:26:33 <lambdabot> http://www.cs.vu.nl/boilerplate
08:26:35 <Phyx-> boo
08:26:51 <Phyx-> ah, maybe i should be more specific..
08:26:58 <Phyx-> @index Data.Generic
08:26:58 <benmachine> @package syb
08:26:58 <lambdabot> http://hackage.haskell.org/package/syb
08:26:58 <lambdabot> bzzt
08:27:08 <benmachine> http://hackage.haskell.org/packages/archive/syb/0.2.1/doc/html/Data-Generics.html
08:27:19 <Phyx-> benmachine: wish that command actually validated urls :|
08:27:34 <Phyx-> and thanks :)
08:27:34 <edwardk> Philonous: it is called template haskell ;)
08:28:15 <Philonous> edwardk Can TH check all instanced that are in scope at a certain point? 
08:28:23 <Philonous> instances*
08:30:41 <edwardk> Philonous: i don't believe so. you can, however, reify types and do some fun stuff. you might be able to get away with something like data ReallyDynamic a = ReallyDynamic a Type -- and some kind of foo = $(reallyDynamic  ''bar) -- or something along those lines
08:31:20 <edwardk> and then unify the types yourself
08:32:02 * hackagebot cpsa 2.0.5 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.0.5 (JohnRamsdell)
08:34:11 <edwardk> gah. every time i try to dumb down one part of category extras, i wind up then not being able to use it for another part =(
08:34:27 <benmachine> heh
08:37:20 <Ulfalizer> edwardk: it's how my projects always end up. i first attempt some "smart" simple solution, then discover it won't work for a few cases, reiterate with a slightly more complete solution, discover that won't work either, etc.
08:37:55 <Ulfalizer> and in the end i end up implementing the complete, proper solution anyway, as i should have from the start :)
08:42:57 <verdelyi> can anyone give me a hint about what can possibly cause such a high level of unwanted non-determinism? http://fpaste.org/k6nk/
09:02:48 <cheater99> so how does haskell parallelization over network look right now?
09:02:54 <cheater99> it it cool? or does it suck?
09:06:59 <kamatsu> cheater99: look at Holumbus, I believe it covers that domain
09:07:15 <cheater99> i heard haskell can pretend to be an erlang node
09:07:18 <cheater99> does that work well?
09:08:58 <sclv> there's a library for that
09:09:15 <cheater99> cool. what's the quality of that?
09:09:34 <sclv> http://hackage.haskell.org/package/erlang
09:09:42 <sclv> I've heard good things, but haven't used it myself
09:09:50 <cheater99> ah cool
09:10:07 <cheater99> so in that case i use erlang as the 'master' and i assign work to haskells right?
09:11:03 <sclv> if you want. it's general purpose.
09:15:38 <cheater99> oh
09:15:43 <cheater99> well yes
09:15:47 <Phyx-> hmm when you have multiple project in a cabal file (e.g. a lib and exe) and you do cabal haddock why doesn't it document both?
09:18:23 <Phyx-> I suppose since you normally wouldn't want documentation for the exe
09:18:25 <Phyx-> hrm
09:20:00 <gwern> 22but you can ask for it
09:22:35 <Phyx-> yeah, just noticed --executables :P
09:28:35 <cheater99> sclv, kamatsu thanks guys
09:30:52 <dschoepe> Is there a way to use hoogle as a library(e.g. for converting databases) or does one have to call the executable normally as one would from the command line?
09:31:51 <dschoepe> oh there's an open bug about that.
09:42:29 <soupdragon> hi
09:42:55 <soupdragon> can anyone help me figure this out http://pastie.org/1010311.txt ? The program compiles and runs it just does the wrong thing
09:43:56 <soupdragon> It's meant to use a symplectic method so that H  is constant but when I run it the thing spirals outwards
09:45:02 <alexbobP> soupdragon: I tried to read it but then my head exploded, my haskell is weak :/
09:47:50 <cheater99> single-char indent?
09:48:07 <cheater99> lines over 72 characters?
09:48:23 <HugoDaniel> is there a read :: String -> Maybe a   ?
09:48:23 <cheater99> no surprise you can't find anything
09:48:34 <HugoDaniel> that automagically avoids the exception... ?
09:48:35 <soupdragon> oh I figured it out hehe I will leave it as a puzzle for anyone bored
09:48:48 <dschoepe> HugoDaniel: you can build one using reads
09:49:07 <cheater99> soupdragon: lol
09:50:19 <ClaudiusMaximus> soupdragon: not using the newly calculated v when computing x?
09:50:32 <dschoepe> HugoDaniel: case reads foo of [(a,"")] -> Just a; _ -> Nothing
09:50:50 <soupdragon> yes you go tit
09:50:52 <soupdragon> got it
09:51:30 <HugoDaniel> yes, thanks ive done it already :)
09:51:51 <ClaudiusMaximus> @hoogle readMaybe
09:51:51 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
09:51:51 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
09:52:07 <dschoepe> HugoDaniel: that being said, I also find it a little annoying that this doesn't already exist in the standard libs.
09:52:13 <Saizan> there's readMay in the safe package
09:52:24 <dschoepe> @hoogle Read a => String -> Maybe a
09:52:24 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
09:52:24 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
09:52:24 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
09:52:36 <mightybyte> Anyone know how ghc implements a derived read for types like "data MyData = ItemA | ItemB | ItemC ..."?
09:52:38 <Saizan> @hackage safe
09:52:38 <lambdabot> http://hackage.haskell.org/package/safe
09:53:19 <dschoepe> Saizan: ah, handy
09:58:59 <pkrumins> Anyone from LtU crew here?
10:00:14 <soupdragon> A lot of LtU readers
10:01:58 <pkrumins> Just wanted to report that registration is broken. But I just found a contact email and just reported it.
10:13:29 <soupdragon> http://pastie.org/1010346.txt that's my working program now
10:14:08 <mcnster> happy newb here.  i have a lex/parse monad of "newtype P a = P { runP :: PState -> ParseResult a }" and i need to do IO within the monad.... is liftIO the right approach?
10:14:41 <Cale> mcnster: You can't do IO inside that monad.
10:15:00 <mcnster> Cale, period?
10:15:03 <Cale> Right.
10:15:08 <Cale> You could return an IO action.
10:15:18 <Cale> (as part of your result)
10:15:19 <soupdragon> now I am wondering if I can use http://hackage.haskell.org/package/ad-0.44.4 to solve the equations instead of doing it on paper
10:15:29 <Saizan> unless ParseResult..
10:15:57 <soupdragon> does it do vector differentation?
10:16:28 <mcnster> P { runP :: PState -> IO (ParseResult a) }?
10:16:42 <Cale> yeah, you could change it to something like that, perhaps :)
10:16:51 <Cale> and then write a liftIO for your monad
10:17:21 <Phyx-> I really need to find that memory leak
10:17:25 <dons> Cale: you might want to try to answer ttmrichter's question, http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
10:17:57 <dons> clear non-jargon english explanation of 'forall' and the consequences for various types with quantification
10:18:35 <mcnster> ok Cale, i'll give it a shot... thanks
10:19:38 <dons> ttmrichter: seriously...
10:19:47 <Cale> There seem to be some explanations already
10:21:32 <Cale> Well, hmm...
10:21:49 <Cale> In this case there are two completely different type system extensions which just happen to use the same keyword.
10:22:44 <soupdragon> "A non-scalar-to-non-scalar automatically-differentiable function." -- is it possible to differentiate a function from R^2 -> R^2?
10:22:56 <soupdragon> oh wait it's R^2 -> R
10:23:14 <Saizan> it's probably best to explain existentials using GADT syntax and then showing how to mangle it into the old one
10:23:23 <cheater99> soupdragon: yes it is
10:23:33 <soupdragon> with this http://hackage.haskell.org/package/ad-0.44.4 ?
10:23:54 <sclv> yep
10:23:54 <soupdragon> I have solved the equation myself on paper but I think it would be cool if AD does it automatically
10:24:04 <sclv> it gives you numerical results, of course.
10:24:16 <cheater99> soupdragon: it is possible to differentiate a function of any amount of values over any scalar body
10:24:35 <soupdragon> h (xx,xy) (vx,vy) = 1/2 * m2 * (vx^2 + vy^2) - g * m1 * m2 / sqrt (xx^2 + xy^2) <-- this is my function h(x,v)
10:24:44 <soupdragon> and I need both partial derivatives 
10:25:12 <sclv> but they are "exact" numerical results (within the limits of what you can do with double precision)
10:26:47 <Saizan> what do you use to represent vectors in ad?
10:26:58 <soupdragon> i can't figure out how to use this library other than  diff (*7) 234  gives   7
10:27:09 <zenzike> thank goodness nobody has submitted a scoring ICFP entry yet
10:27:13 <sclv> heh
10:27:26 <sclv> looks like one solution for car 0 so far
10:27:40 <zenzike> oh?
10:27:51 <zenzike> oh yeah
10:28:12 <sclv> I figure that once I solve car 0 I'll probably be happy.
10:28:15 <zenzike> I'm happy enough that I've understood the circuit syntax. Still trying to understand what it does though
10:28:25 <sclv> and lay off on further work.
10:28:51 <sclv> I built an interpreter for what I think the syntax does. Now working on brute-forcing my way through possible circuits until I get one that does what I want.
10:29:32 <zenzike> neat. I'm brute forcing too, but right now i'm going blind
10:29:34 <etate> how do you exclude prelude from being imported?
10:29:48 <soupdragon> type FU  f a = forall s. Mode  s => f (AD  s a) -> AD  s a  -- if I set  data F a = Vector a a  maybe then  Fu F Double  works
10:30:00 <benmachine> etate: there are several ways
10:30:28 <soupdragon> etate:  import qualified Prelude
10:30:36 <benmachine> etate: GHC has an extension -XNoImplicitPrelude to disable the prelude import (which also screws about with some syntax stuff)
10:30:44 <benmachine> or you can import Prelude hiding (stuff)
10:30:44 <Saizan> or "import Prelude ()"
10:30:54 <SonOfLilit> Hello
10:30:55 <benmachine> or either of the other two mentioned options yes
10:31:00 <sclv> soupdragon: see barak p's article on the fad library for usage
10:31:17 <soupdragon> where is that?
10:31:36 <SonOfLilit> remember me asking for a funtion (return.) :: a -> b -> a -> Monad b ?
10:31:37 <soupdragon> google is just saying Barack Obama is a fad
10:31:48 <etate> benmachine: thanks
10:32:02 <SonOfLilit> so what I really wanted was the same with a function of two parameters
10:32:29 <SonOfLilit> i.e. returnDot2 :: (a->b->c)->a->b->Monad c
10:32:41 <SonOfLilit> is there a such?
10:32:53 <soupdragon> Barak A. Pearlmutter
10:32:58 <Cale> fmap (fmap return)
10:33:10 <benmachine> :t fmap (fmap return)
10:33:11 <SonOfLilit> :type fmap (fmap return)
10:33:11 <lambdabot> forall a (m :: * -> *) (f :: * -> *) (f1 :: * -> *). (Monad m, Functor f, Functor f1) => f1 (f a) -> f1 (f (m a))
10:33:14 <Cale> Or, without the Functor instance, ((return .) .)
10:33:46 <Cale> Or you could just write a lambda
10:33:50 <SonOfLilit> :type (return.).
10:34:00 <Cale> :t ((return .) .)
10:34:01 <lambdabot> forall a (m :: * -> *) (f :: * -> *) (f1 :: * -> *). (Monad m, Functor f, Functor f1) => f1 (f a) -> f1 (f (m a))
10:34:05 <SonOfLilit> :type ((return.).)
10:34:07 <Cale> (.) is fmap in lambdabot
10:34:08 <soupdragon> Algorithmic Differentiation, Functional Programming, and Iterate-to-Fixedpoint?
10:34:14 <Cale> :t ((return P..) P..)
10:34:15 <lambdabot> Couldn't find qualified module.
10:34:23 <Cale> :t ((return Prelude..) Prelude..)
10:34:24 <lambdabot> forall b (m :: * -> *) a a1. (Monad m) => (a1 -> a -> b) -> a1 -> a -> m b
10:34:33 <SonOfLilit> excellent
10:34:35 <SonOfLilit> thank you
10:34:44 <SonOfLilit> I'll take a piece of paper and figure out why this is correct
10:34:45 <sclv> soupdragon: hmm, it looks like his papers are only on the lisp library
10:34:46 <gwern> 'Southwest does not accept pets (cats or dogs) traveling without a Customer.'
10:34:53 <SonOfLilit> brb :)
10:35:04 <Cale> SonOfLilit: I think many people would find that obfuscated
10:35:27 <Cale> SonOfLilit: It might be better just to write (\f x y -> return (f x y))
10:35:52 <sclv> soupdragon: in any case, http://hackage.haskell.org/packages/archive/fad/1.0/doc/html/Numeric-FAD.html
10:36:04 <sclv> it might be somewhat simpler than the ad package, at first
10:36:29 <Cale> SonOfLilit: The easy way to think of it is actually via the functor generalisation
10:36:45 <Cale> SonOfLilit: For any type e, the type constructor (e ->) is a functor
10:37:02 <Cale> If f is any functor, then  fmap :: (a -> b) -> f a -> f b
10:37:16 <soupdragon> The diffMU  function calculate the product of the Jacobian of a nonscalar-to-scalar function with a given vector. Aka: directional derivative. 
10:37:21 <soupdragon> I think that is what I need
10:37:36 <jmcarthur> :t (fmap.fmap) return
10:37:37 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (m :: * -> *). (Functor f, Functor f1, Monad m) => f (f1 a) -> f (f1 (m a))
10:37:55 <gwern> > 16 + 15 + 30
10:37:55 <lambdabot>   61
10:37:56 <Cale> SonOfLilit: So we have return :: a -> m a, and then fmap return :: f a -> f (m a)
10:38:11 <Cale> SonOfLilit: but let's specialise those f's right now to "e ->"
10:38:21 <Cale> So fmap return :: (e -> a) -> (e -> m a)
10:38:30 <Cale> and if we can do it once, we can do it again
10:38:46 <Cale> So fmap (fmap return) :: (e2 -> (e -> a)) -> (e2 -> (e -> m a))
10:39:16 <cheater99> soupdragon: a directional derivative is not the derivative
10:39:25 <Cale> SonOfLilit: Make sense?
10:39:55 <soupdragon> huh?
10:40:05 <Cale> after that, all you need to know is that fmap = (.) for the function instance
10:40:48 <soupdragon> well the derivative of abs on R -> R gives {-1,0,1} depending but the derivative of abs on R^2 -> R gives the direction (normalized to length 1)
10:40:59 <Cale> So it could also be written (.) ((.) return) or using operator sections, ((return .) .)
10:41:13 <soupdragon> so I need some kind of geometric derivative maybe that is not implemented
10:41:33 <Cale> How is the derivative of abs ever 0?
10:42:27 <tromp_> not
10:43:14 <dskippy> Derivative of abs() is a piece-wise function undefined at zero, right? -1 for x<0, 1 for x>0.
10:43:41 <Cale> yeah
10:43:51 <Cale> abs isn't differentiable at 0
10:44:23 <tromp_> altough it is from the left or from the right
10:44:58 <Cale> Heh, I suppose we could do some sort of balanced secant thing :)
10:45:17 <SonOfLilit> Cale: I can follow the expansion, but I don't think I have the intuition to perform it myself when a similar case appears
10:45:37 <Cale> f'(x) = limit as h -> 0 of (f(x+h) - f(x-h))/(2h)
10:45:52 <Cale> (make that the definition :)
10:46:20 <benmachine> that sounds scary
10:46:47 <benmachine> is it guaranteed to agree with normal derivative when they're both defined?
10:46:51 <benmachine> I suppose it is
10:47:52 <soupdragon> mine is (f(x+dx)-f(x))/dx for infintesimal dx
10:48:14 <soupdragon> does limit as h -> 0 of (f(x+h) - f(x-h))/(2h) give abs'(0) = 0?
10:48:21 <Cale> soupdragon: You probably want to take the standard part of that
10:48:37 <soupdragon> ah yes I forgot that
10:48:53 <Cale> yes, it would
10:49:11 <Cale> |0+h| - |0-h| = h - h = 0
10:49:22 <cheater99> none of those formulas is the definition of a derivative
10:49:25 <Cale> so it would become the limit as h -> 0 of 0
10:49:35 <soupdragon> (abs(+h)-abs(-h))/2h = 2h/2h = 1
10:49:41 <cheater99> they are merely formulas that hold if the derivative at a point exists
10:49:44 <Cale> soupdragon: sign fail
10:49:46 <soupdragon> oh! 0/2h = 1
10:49:49 <soupdragon> cool
10:49:53 <Cale> = 0
10:50:50 <soupdragon> can you define the derivative of a complex function the integral of an infinitesimal circle divided by 2pi around the point??
10:50:58 <cheater99> the derivative at 0 of |x| is not defined because for different sequences over which we are doing the derivation we get different results.
10:51:04 <danderson> is GHC's dependency chasing machinery available as a library?
10:51:12 <cheater99> *the differentiation
10:51:19 <Cale> cheater99: I'm considering this alternate definition of derivative where it does.
10:51:24 <danderson> (I want to play with the dependency DAG that ghc --make builds)
10:51:32 <cheater99> Cale: where it does what?
10:51:39 <Cale> cheater99: exist.
10:52:01 <cheater99> yes
10:52:15 <cheater99> just explaining it for soupdragon who seems to be confused what a derivative is
10:52:15 <Cale> The usual definition is that the derivative of f at x is the limit as h -> 0 of (f(x+h) - f(x)) / h. The function is called differentiable if that limit exists.
10:52:36 <soupdragon> think about it (f(x+h) - f(x)) / h is the integral
10:52:42 <soupdragon> from x to x+h
10:52:43 <Cale> ?
10:52:58 <soupdragon> a 1D circle
10:53:02 <cheater99> it is not
10:53:09 <soupdragon> divided by the radius
10:53:13 <soupdragon> sorry diameter
10:53:17 <cheater99> you are on drugz
10:53:25 <c_wraith> my brain is about to collapse.
10:53:26 <Cale> It's actually just the slope of a line through the points (x,f(x)) and (x+h,f(x+h))
10:53:45 <soupdragon> but if you think of it as a 1D circle integral divided by the area then it generalized to nD
10:53:53 <soupdragon> doesn't it?
10:54:08 <Cale> soupdragon: I have no idea what you're talking about now
10:54:13 <cheater99> drugs
10:54:23 <soupdragon> int_a^bf(x)dx=F(b)-F(a). 
10:54:48 <soupdragon> so let b = x+h and a = h
10:56:07 <Cale> You mean a = x?
10:56:11 <soupdragon> yes sorry
10:56:53 <cheater99> int_a^bf(x)dx=F(b)-F(a)     divide by C = int_a^b*dy   => f(x)dx/dy=(F(b)-F(a))/(int_a^bdy)   => f(x) dx/dy = (F(b) - F(a))/((b-a)dy)
10:57:13 <cheater99> oh wait scratch that last dy.
10:57:27 <cheater99> ;-)
10:58:24 <soupdragon> anyway it doesn't seem like I can implement any of this in haskell
10:58:53 <cheater99> it does not, indeed.
10:59:18 <cheater99> i am surprised there isn't a good CAS for haskell
10:59:51 <soupdragon> I tried to write one but it flopped
11:00:02 <jacobian> hah, I thought you were talking about me.
11:12:40 <dons> cheater99: DOCON?
11:12:50 <dskippy> I would like style advice. This program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26344#a26344 is marching off to the right of the screen. I am not quite sure of the best way to structure this.
11:12:51 <dons> http://www.haskell.org/docon/
11:14:01 <dskippy> I am fairly new to Haskell and I'm wondering if there might be a solution where I can encapsulate the tests of the hand rank in a monad. This might allow me to short circuit when I find one that fits, though I'm not sure that's going to work.
11:14:47 <soupdragon> dskippy make a list like  [(StraightFlush, striaghtFlush), (isFourOfAKind), 
11:14:50 <soupdragon> oops
11:14:58 <soupdragon> [(StraightFlush, striaghtFlush), (FourOfAKind, isFourOfAKind),...]
11:15:09 <soupdragon> after extending all functions to take the same parameters
11:15:24 <BMeph> dskippy: Have you considered that, just maybe,...you're doing it wrongly? ;)
11:15:25 <soupdragon> then you can use a lookup or reverse lookup or iterate through it (all to implement different programs)
11:15:51 <jmcarthur> dskippy: i'm making an alternative version of your function for you. will paste in a sec
11:16:25 <mangomadness> i'm trying to understand some syntax but i'm having a hard time looking it up. what does the => mean in a type signature? and what is it called so that i can search for information on it?
11:16:35 <dskippy> jmcarthur: Thanks!
11:17:02 <mauke> mangomadness: (class constraints) => normal type here
11:17:39 <jmcarthur> dskippy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26344#a26345
11:17:47 <jmcarthur> dskippy: guards are your friend :)
11:17:51 <mangomadness> mauke: thanks, i'll look into that!
11:18:29 <dskippy> jmcarthur: Ah. That's basically like the Lisp function I'd have written using COND. 
11:18:39 <benmachine> jmcarthur: thing with indenting it like that, you have to reindent everything if you change the name of the function
11:18:46 <benmachine> so I usually like to start guards on the next line
11:18:47 <dskippy> jmcarthur: Guards are very nice. I'll use that. Thanks a bunch.
11:18:50 <mangomadness> now i'm seeing all kinds of infomation now that i know to search for class constraints. it there some glossary that maps syntax to terms?
11:19:01 <jmcarthur> benmachine: i don't normally mind
11:19:05 <ManateeLazyCat> mangomadness: BTW, you can read gtk2hs-api (http://hackage.haskell.org/packages/archive/gtk/0.11.0/doc/html/Graphics-UI-Gtk-Abstract-Widget.html), you will found many "=>"
11:19:18 <jmcarthur> benmachine: i usually would put it on the next line if i need the horizontal space
11:19:24 <ManateeLazyCat> mangomadness: You will get better understand about "=>" if you familiar with gtk+ . :)
11:19:30 <benmachine> *gasp* inconsistency :P
11:19:45 <jmcarthur> it's a consistent rule for me
11:19:56 <benmachine> I guess so
11:19:57 <jmcarthur> if it fits in 80 cols, don't newline
11:20:06 <mangomadness> ManateeLazyCat: thanks, i'll keep that as reference as i get there, that might be a bit ahead of my skill level at the moment, just getting started
11:21:54 <ManateeLazyCat> mangomadness: Simple is like mauke said, *left* of "=>" is mean *class*, example "foo :: (Ord a, Ord b) => a -> b -> Bool"
11:22:12 <mauke> that type makes no sense :-)
11:22:34 <ManateeLazyCat> @hoogle compare
11:22:34 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
11:22:34 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
11:22:34 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
11:22:41 <roconnor_> @index mplus
11:22:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:22:52 <roconnor_> @type mplus
11:22:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:22:58 <ManateeLazyCat> mangomadness: Data.Ord compare :: Ord a => a -> a -> Ordering
11:23:05 <roconnor_> @type mconcat
11:23:06 <lambdabot> forall a. (Monoid a) => [a] -> a
11:23:36 <ManateeLazyCat> mangomadness: "Ord" is class, "a" is instance of class "Ord"
11:23:51 <roconnor_> @hoogle [m a] -> m a
11:23:51 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
11:23:51 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
11:23:51 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
11:24:15 <SonOfLilit> mangomadness: If you don't find it anywhere else, you can browse for an instance of some syntax in the Zvon reference or in the Haskell report
11:24:23 <mangomadness> looks like i need to read more about classes. a lot of the tutorials and online help use => in type signatures before talking about classes
11:24:28 <mauke> @where report
11:24:29 <lambdabot> http://www.haskell.org/onlinereport/
11:24:44 <mangomadness> so i was just curious what is was
11:25:09 <mangomadness> thanks a lot for your help everyone. i'm sure i'll be back. i'm loving haskell so far :)
11:25:40 <cheater99> dons: is it good?
11:28:46 <benmachine> mangomadness: it's not vital that you understand everything as soon as it appears, sometimes it's ok to only havea a vague idea what it means until you come back to it
11:28:47 <cheater99> dons: that's not really a CAS, it's just an algebraic domain manipulator
11:28:54 <cheater99> that's a very very very small subset
11:29:08 <benmachine> mangomadness: although that can also lead to a buildup of delayed-learning thunks that lead to mental stack overflow
11:29:56 <SonOfLilit> Cale: I think I got it. My thought process goes: "Lets look at the type of "((f::(b->a)).)", which is "((c->b)->(c->a))", or in other words, (.) "adds" a parameter at the beginning and takes a function that swallows it - which can be done multiple ties
11:30:01 <SonOfLilit> times*
11:30:10 <SonOfLilit> is this correct intuition?
11:30:14 <mangomadness> benmachine: yeah, i can understand that. i don't plan to get too immersed in topics before i get to them, i just wanted a general idea of what => was and it's hard to google for it if you don't know what to search for :)
11:30:53 <MrFenix> hi.. cabal tells me Cabal-1.8.0.2-873a6c63b11eb59988b79dbcabd40907 is shadowed by package Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a ; wtf is that?
11:31:23 <benmachine> mangomadness: well, (Eq a) => a -> a -> Bool, just means that a is anything that has an idea of equality
11:31:38 <SonOfLilit> benmachine: excellent definition
11:32:03 <benmachine> (Ord k) => [k] -> [k], means that k must be something that can be ordered
11:32:21 <Cale> SonOfLilit: yeah
11:32:28 <SonOfLilit> explanation*
11:32:47 <benmachine> the stuff on the right of the => is a normal type signature and the stuff on the left just tells you more about the type variables in it
11:32:57 <benmachine> SonOfLilit: thx2u
11:32:59 <ManateeLazyCat> MrFenix: Paste all error information?
11:33:07 <Saizan> MrFenix: you've to unregister one of the two
11:34:05 <MrFenix> mangomadness: (X a) => fun a -> b is roughly compareable to java public B fun(X a) { ...; return b; }
11:34:18 <MrFenix> mangomadness: where X is an interface
11:34:37 <Saizan> no.
11:35:01 <Saizan> "fun :: (X a) => a -> b" might be comparable to that
11:35:10 <ManateeLazyCat> mangomadness1: You can understand "=>" completely after understand "type-class and instance" 
11:35:28 <mangomadness1> ManateeLazyCat: that's what i figure, i'm reading about that now
11:35:49 <mangomadness1> i had been search about types to find information about it, which was my mistake
11:36:50 <MrFenix> ManateeLazyCat: Full Error: http://de.pastebin.ca/1885930
11:37:34 <dskippy> Anyone know where the 'on' function is located? It's *really* hard to Google for. :)
11:37:44 <nlogax> hoogle it :)
11:37:45 <benmachine> dskippy: Data.Function, if I recall correctly
11:37:48 <ManateeLazyCat> dskippy: Data.Function
11:37:53 <benmachine> but yeah, find hayoo and hoogle
11:37:55 <benmachine> they are nice
11:38:05 <ManateeLazyCat> benmachine: Slower than you. :)
11:38:20 <ManateeLazyCat> @hoogle on
11:38:20 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:38:20 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
11:38:20 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
11:38:34 <nlogax> dskippy: cabal install hoogle, add this to .ghci: :def hoogle \x -> return $ ":!hoogle --count=10 " ++ show x
11:38:40 <nlogax> maybe there's a nicer way but that works for me
11:38:47 <nlogax> then you can :hoogle on in ghci
11:39:13 <dskippy> Wow, cool.
11:39:36 <gwern> nlogax: there are no nicer ways in .ghci
11:39:47 <roconnor_> arrggg  Kate's fancy new haskell auto indenter is driving me crazy!
11:39:49 <gwern> it's really pretty horrible, as I found out when I added hlint
11:39:55 <ManateeLazyCat> MrFenix: use "ghc-pkg unregister" unregister Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a
11:39:59 <roconnor_> it's putting tabs everywhere!!!!
11:40:02 <roconnor_> who wrote this?
11:40:15 <gwern> that darn kate
11:40:29 <gwern> nlogax: the tricks one has to go through to get the loaded filenames!
11:40:44 <zenzike> sigh. I thought I was onto something with those ICFP circuits. elusive little blighters.
11:41:49 <nlogax> gwern: i haven't done much with ghci, but that felt a bit awkward :)
11:41:55 <gwern> roconnor_: just write a pre-save hook that turns tabs into spaces
11:42:01 <gwern> surely kate can do that
11:45:26 <SonOfLilit> speaking of hoogle: how can I get hoogle to search all my local packages?
11:46:07 <applicative> SonOfLilit, there is a post by the author about this.  
11:46:24 <gwern> with difficulty. build .hoos for each package, then merge them all together, and put it under the default's name
11:47:13 <ManateeLazyCat> roconnor_: Why not replace tab with space always?
11:47:36 <applicative> http://neilmitchell.blogspot.com/2008/08/hoogle-database-generation.html
11:48:08 <ManateeLazyCat> (setq-default indent-tabs-mode nil)
11:48:13 <SonOfLilit> applicative: no automatic way to do it yet?
11:48:18 <ManateeLazyCat> (setq default-tab-width 4)
11:48:34 <applicative> SonOfLilit, and http://www.haskell.org/haskellwiki/Hoogle#Database_Creation
11:48:52 <gwern> ManateeLazyCat: I think roconnor is not using emacs
11:49:00 <etate> does anyone know what: No instance for (RegexContext Regex [Char] [String]) arising from a use of '=~' means?
11:49:17 <applicative> SonOfLilit, I don't think so, I suppose you could script it all pretty readily.  
11:49:24 <etate> I used to do "foo foo foo" =~ "foo" :: [String] using regex-posix lib and everything worked, now it fails
11:49:30 <ManateeLazyCat> gwern: His editor don't support "space replace tab"?
11:49:40 <gwern> ManateeLazyCat: he has yet to say so
11:49:45 <applicative> SonOfLilit, On the other hand, when I was looking up his posts on Hoogle he seemed to be suggestion that we should be pitching in if we want that sort of functionality.....
11:50:07 <ManateeLazyCat> gwern: I'm curious, which editor he use?
11:50:12 <gwern> scroll up
11:50:33 <ManateeLazyCat> gwern: Oh, kate.
11:50:47 <applicative> SonOfLilit, http://neilmitchell.blogspot.com/2009/02/hoogle-package-search.html
11:50:51 <ManateeLazyCat> gwern: I suppose Kate is some people. :)
11:51:22 <ManateeLazyCat> etate: Wait, i give you some function.
11:52:12 <etate> ManateeLazyCat: thanks
11:52:16 <ManateeLazyCat> etate: I recommend you use regex-tdfa
11:52:25 <ManateeLazyCat> etate: Faster, and always work.
11:52:51 <etate> ManateeLazyCat: i've never used that before :/
11:53:37 <applicative> roconnor is Kate otherwise good for writing Haskell with?  I was thinking about trying it.
11:53:48 <ManateeLazyCat> etate: "cabal install regex-tdfa"
11:54:10 <etate> ManateeLazyCat: can you use it exactly the same as regex-posix?
11:55:22 <ManateeLazyCat> etate: I never use posix, i think it compatible with posix, just faster. IIRC
11:56:17 <brad_larsen> In haskell-mode for emacs, the word boundaries are not what I like---sometimes `M-x f' skips over many words at a time.  How can I configure emacs in haskell-mode so that it treats whitespace-delimited tokens as words?
11:56:34 <ManateeLazyCat> etate: http://www.haskell.org/haskellwiki/Regular_expressions#regex-tdfa
11:57:05 <etate> ManateeLazyCat: thanks I'll try that now
11:57:27 <ManateeLazyCat> etate: All your code with posix can work with regex-tdfa.
11:58:07 <etate> ManateeLazyCat: tdfa fails with the same error
11:58:22 <ManateeLazyCat> etate: Hmmm? Can you paste your error?
11:58:52 <etate>  No instance for (RegexContext Regex [Char] [String])      arising from a use of `=~' at src/Main.hs:83:30-45
11:59:29 <etate> e.g when I do this: "foo foo foo" =~ "foo" :: [String]
11:59:35 * Phyx- loves seeing "Linking main.exe" after hours of debugging
12:00:08 <EvanR-work> unless its on ubuntu with 256M of ram and linking is on haskell platform
12:00:48 <ManateeLazyCat> etate: "foo foo foo" =~ "foo" :: (String,String,String,[String])
12:00:51 <Phyx-> EvanR-work: ouch
12:01:05 <applicative> etate, man the regex error statements are a nightmare; I guess it's due to the extravagant  abstractness of the libraries
12:01:53 <ManateeLazyCat> etate: Should use "foo foo foo" =~~ "foo" :: [String]
12:02:30 <ManateeLazyCat> etate: Above is *two* kind of use for [String]
12:02:47 * brad_larsen is kind of turned off by the regular expression libraries in Haskell.  In particular, ``Seems to work, passes a few tests'' in the Stability field doesn't give me confidence.
12:02:54 <brad_larsen> Although, it's probably fine.
12:03:08 <etate> now I'm really confused :/
12:03:10 <kmc> the API is weird and unhaskellish
12:03:26 <brad_larsen> And the vast number of regex packages on haskell are bewildering.  Which one should I be using.
12:03:39 <brad_larsen> (/me has a copy of RWH)
12:03:50 * brad_larsen is an irc noob.  ;-)
12:03:55 <applicative> etate, one ~ versus two ~~
12:04:00 <ManateeLazyCat> etate: Read http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
12:05:19 <etate> ManateeLazyCat: thats what i was reading, but his examples with [String] fail for me
12:05:29 <gwern> brad_larsen: you could always look at how many packages use the regex libs and pick the most popular
12:05:48 * ManateeLazyCat All haskell regular expression libraries is difficult to use and understand. 
12:06:01 <ManateeLazyCat> etate: Use "=~~"
12:06:09 <gwern> brad_larsen: http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
12:06:11 <etate> ManateeLazyCat: what is the difference? :D
12:06:36 <gwern> regexps are hard, let's go parsing
12:06:43 <applicative> > "foo foo foo" =~~ "foo" :: [String]
12:06:43 <lambdabot>   ["foo"]
12:06:49 <applicative> > "foo foo foo" =~ "foo" :: String
12:06:50 <lambdabot>   "foo"
12:07:06 <ManateeLazyCat> gwern: I love emacs's regular expression library/function, easy to use.
12:07:09 <etate> shouldn't it return multiple matches?
12:07:35 <etate> i.e: "foo foo foo" =~~ "([a-z]+)" :: [String]
12:07:42 <gwern> ManateeLazyCat: really? everytime I try to do a regexp replace in emacs, I curse the womb that bore me
12:07:51 <ManateeLazyCat> gwern: Regular expression is not hard, is haskell library APIs looks ugly
12:07:53 <etate> shouldnt that return: ["foo","foo","foo"] ?
12:07:59 <ManateeLazyCat> gwern: Example?
12:08:14 <ManateeLazyCat> gwern: I always use Emacs regexp feature to refactory code ... :)
12:08:17 <applicative> > "foo foo foo" =~ "foo" :: (String,String,String)
12:08:17 <lambdabot>   ("","foo"," foo foo")
12:08:25 <gwern> ManateeLazyCat: how do you mean?
12:08:51 * edwardk waves hello.
12:08:53 <etate> that tuple confuses me
12:08:57 <edwardk> preflex: xseen ski
12:08:57 <preflex>  ski was last seen on freenode/#haskell 12 hours, 17 minutes and 48 seconds ago, saying: napping : hm, `Y^X' being `Y' abstracted wrt `X', or vice versa ?
12:09:16 <ManateeLazyCat> gwern: Tell me the regular expression that confuse you, i give your solution .:)
12:09:26 <brad_larsen> emacs regular expressions have slightly different syntax, different escapes, and character classes from other regex tools I'm used to.  I always have to look up the emacs regex help when doing complicated regex stuff in emacs.
12:09:37 <gwern> ManateeLazyCat: it's all of them
12:09:37 <gwern> ManateeLazyCat: the last one I managed to figure out after half an hour in #emacs
12:09:42 <benmachine> etate: before, during, after, I think
12:09:49 <etate> ManateeLazyCat: how would you get those "foo foo foo" to match like this: ("foo", "foo", "foo") or something like it?
12:10:21 <ManateeLazyCat> etate: Read http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ 
12:10:31 <benmachine> etate: it couldn't be in a tuple because tuples are fixed size
12:10:32 <ManateeLazyCat> etate: That's site clear enough
12:11:04 <ManateeLazyCat> gwern: brad_larsen I think your guys haven't read "Emacs Reference Manual" deeply. :)
12:11:08 <benmachine> > "foo foo foo" =~ "foo" :: [[String]]
12:11:08 <lambdabot>   [["foo"],["foo"],["foo"]]
12:11:33 <gwern> ManateeLazyCat: yes, it's all my fault for expecting to not have to memorize every quirk...
12:11:34 <ManateeLazyCat> IMO, Emacs's regular expression is most feature i like
12:11:37 <benmachine> > "foo foo foo" =~ "f(oo)" :: [[String]]
12:11:41 <lambdabot>   [["foo","oo"],["foo","oo"],["foo","oo"]]
12:12:10 <applicative> > map (=~~ "foo") (lines "fofof foo\nfo\nfoo\nfo fo") :: [[String]]
12:12:11 <lambdabot>   [["foo"],[],["foo"],[]]
12:12:17 <ManateeLazyCat> gwern: Use "re-builder" to study Emacs regexp, it's will give your feedback when you typing some regexp you can't understand.
12:12:19 <edwardk> cocurry :: CoCCC (>=), subtract ~ Coexp (>=), (+) ~ Sum (>=) => (c >= a + b) -> subtract b c >= a -- i think that is a lot prettier than the current definition
12:12:25 <ManateeLazyCat> gwern: re-builder.el
12:12:40 <gwern> ManateeLazyCat: rebuilder in fact was responsible for a good deal of my pain
12:12:40 <ManateeLazyCat> gwern: Then do "M-x re-builder"
12:12:44 <gwern> apparently it is not quite the same as what you need to type in replace-regexp...
12:12:54 <edwardk> starts to look like a proof term
12:13:09 <brad_larsen> I'm used to being able to use '\d' as the character class [0-9]
12:13:15 <ManateeLazyCat> gwern: For replace, you need something \(\n\)
12:13:24 <brad_larsen> emacs regex doesn't support it, when every other regex tool I've used does.
12:13:33 <gwern> ManateeLazyCat: yes, I know
12:13:41 <benmachine> brad_larsen: isn't that a perl thing?
12:14:12 <benmachine> grep only gets it with -P
12:14:18 <edwardk> hrmm, i think i can do the same thing to curry, just by making an odd choice of notation for exponential.
12:14:37 <etate> oh the confusion was in "foo foo foo" =~ "foo" :: [String] not working (as per the site and rwhs book). It works with "foo foo foo" =~ "foo" :: [[String]]... But thats confusing
12:14:59 <brad_larsen> benmachine: maybe a perl thing.  egrep (which is grep -P?) and vim and perl and python support it.
12:15:28 <ManateeLazyCat> brad_larsen: [a-zA-Z]
12:15:31 <edwardk> curry :: (CCC (==), (*) ~ Product (==), (\) ~ Exp (==)) => ((a * b) == c) -> a == b \ c
12:15:57 <ManateeLazyCat> benmachine: Emacs' regexp syntax is different with perl 
12:17:05 <brad_larsen> ManateeLazyCat: yes, I'm aware I can type out the character classes explicitly.  It gets tedious.
12:17:53 <ManateeLazyCat> brad_larsen: In emacs,  . mean any character (but newline)
12:18:37 <ManateeLazyCat> ".+" mean 1 or more characters.
12:18:45 <HugoDaniel> hmm
12:18:47 <ManateeLazyCat> ".*" mean 0 or more characters.
12:19:00 <HugoDaniel> if i have Maybe a, how do i do a quick n dirty transformation into Maybe [a]
12:19:03 <HugoDaniel> ?
12:19:07 <HugoDaniel> fmap []  ?
12:19:08 <kmc> fmap return
12:19:14 <HugoDaniel> ah ok
12:19:15 <HugoDaniel> yes
12:19:17 <HugoDaniel> :D
12:19:18 <HugoDaniel> thanks
12:19:21 <HugoDaniel> so obvious
12:19:26 <kmc> or: fmap pure
12:19:45 <sjoerd_visscher> Hi, does anybody know how to export data constructors of an associated data family?
12:20:09 <brad_larsen> ManateeLazyCat: I am familiar with regular expressions.
12:20:22 <edwardk> sjoerd_visscher: its on the haskell wiki somewhere, one sec.
12:20:26 <ManateeLazyCat> brad_larsen: Me too. :)
12:21:02 <edwardk> sjoerd_visscher: http://www.haskell.org/haskellwiki/GHC/Indexed_types#Associated_families
12:21:33 * ManateeLazyCat pasted "emacs regexp speical" at http://paste2.org/get/882967
12:21:35 <ManateeLazyCat> brad_larsen: Above
12:22:33 <ManateeLazyCat> brad_larsen: Emacs regexp and do everything that perl do, just different sytax. 
12:23:31 <ManateeLazyCat> gwern: Do you use color-moccur.el and moccur-edit.el, i use them with regexp to refactory Haskell code in Emacs :)
12:23:37 <gwern> ManateeLazyCat: no
12:23:44 <sjoerd_visscher> edwardk: I've seen that, but that doesn't seem to work
12:23:44 <ManateeLazyCat> gwern: You should try.
12:23:50 <brad_larsen> ManateeLazyCat: the different syntax is what irritates me.  :-)
12:24:01 <ManateeLazyCat> gwern: Special moccur-edit.el , awesome extensive.
12:24:35 <ManateeLazyCat> brad_larsen: Yes, since more regexp expert like perl or posix something, then emacs's one is weird.
12:24:39 <edwardk> sjoerd_visscher: module YourModule (YourClass(yourMembers), YourDataType(SomeConstructors)) where doesn't work?
12:24:42 <sjoerd_visscher> I have: class Category (~>) where data Obj (~>) :: * -> * and instance Category (->) where data Obj (->) a = HaskO
12:25:24 <sjoerd_visscher> I have exported Category(..), but when I import the module, HaskO is not recognized
12:25:46 <Saizan> try exporting Obj(..) too
12:25:52 <edwardk> ahh
12:26:22 <edwardk> that isn't covered by the above export
12:26:32 <sjoerd_visscher> Saizan: that works, thanks!
12:26:43 <Saizan> np
12:27:01 <edwardk> yep
12:32:03 <max_atreides> hey, i'm trying to import Control.Monad.State but ghc is complaining that there are two version: mtl and monads-fd. Which is the right one and how do I get rid of the wrong one?
12:32:38 <ManateeLazyCat> max_atreides: sudo ghc-pkg hide monads-tf
12:33:01 <ManateeLazyCat> max_atreides: Use "ghc-pkg hide" monads-td
12:33:02 <max_atreides> ManateeLazyCat: thank you
12:33:14 <tolkad> Lambda calculus seems pretty slow... I got this http://lci.sourceforge.net/ and it can take minutes just to substract 2 numbers
12:33:38 <ManateeLazyCat> Is "sudo ghc-pkg hide monads-td" not "monads-tf", typo.
12:33:40 <ManateeLazyCat> :)
12:36:25 <gwern> tolkad: what do you expect?
12:36:42 <gwern> haskell is fast because it has decades of effort behind good compilers
12:36:51 <dolio> It's highly doubtful that that interpreter is optimized for speed.
12:39:41 <dolio> It lets you choose between evaluation strategies, and print terms after every reduction.
12:39:54 <dolio> So it must be manipulating syntactic terms.
12:42:29 <ManateeLazyCat> Bye all, happy bla.... :)
12:43:12 <tolkad> attempting to calculate 9999 * 9999 just used up all available RAM... it used over 2GB memory
12:43:59 <tolkad> 2 gigabytes of memory to calculate 9999 * 9999
12:44:06 <gwern> again, so?
12:44:14 <gwern> you say that like it's interesting or meaningful
12:44:37 <aristid> > 9999 * 9999 -- eating up lambdabot's memory?
12:44:38 <lambdabot>   99980001
12:45:29 <jmcarthur> tolkad: just because some poopy interpreter is slow doesn't mean the lambda calculus, which is simply a mathematical theory not a compiler or interpreter, is slow
12:45:39 <jmcarthur> > 99999 * 99999
12:45:40 <dolio> If it's pure lambda calculus, then those are probably Church-encoded Peano numerals.
12:45:40 <lambdabot>   9999800001
12:46:04 <dolio> Which is about the least efficient representation of natural numbers there is.
12:46:17 <mreh> but important
12:46:21 <dolio> Sure.
12:46:59 <tolkad> well why can't it just do some optimization? treat them as church-numerals from the programmers point of view but encode them like normal binary numbers in memory
12:47:16 <kmc> it could
12:47:23 <kmc> evidently it doesn't
12:47:24 <dolio> 9999*9999 is \z s -> s (s (s (s ... 99980001 times ... (s z))))
12:47:41 <kmc> it's obvious that the performance of some toy lambda calculus interpreter has nothing to do with the performance of ghc, and i'm not sure why you're all jumping on tolkad as if he claimed it did
12:47:42 <McManiaC> is there any datatype for positive numbers?
12:47:44 <jmcarthur> > length . join (liftA2 undefined) $ replicate 9999 undefined  -- basic equivalent will probably also fail in lambdabot
12:47:47 <lambdabot>   mueval-core: Time limit exceeded
12:47:51 <jmcarthur> yeah
12:47:52 <kmc> McManiaC, machine size, yes.  Word and Word8 Word16 etc.
12:47:55 <aavogt> word
12:47:57 <kmc> (if by positive you mean nonnegative)
12:48:05 <kmc> unfortunately there's no nonnegative equivalent of Integer
12:48:06 <McManiaC> nonegative, yeh
12:48:14 <danharaj> Isn't that what views are for?
12:48:29 <mreh> according to the documentation, there's no demand for them
12:48:32 <jmcarthur> > length . join (liftA2 undefined) $ replicate 10 undefined  -- sanity check
12:48:33 <lambdabot>   100
12:48:47 <gwern> kmc: because that's the obvious thrust of tolkad's statements. the only other meaningful interpretation is that he likes to spam tech channels with random factoids about even more random toy projects
12:49:00 <kmc> gwern, lots of us do that regularly...
12:49:18 <gwern> kmc: and those are usually regulars. I don't recognize tolkad as a regular, although I could be mistaken
12:49:23 <kmc> plenty of chatter here comes down to "look at this interesting thing i found which is tangentially related to haskell"
12:49:39 * jesusabdullah likes interesting things
12:49:39 <jmcarthur> kmc: he claimed that the lambda calculus is slow, which is ridiculous
12:49:50 <tolkad> I obviously meant that implementation
12:49:52 <kmc> yes, it is a nonsensical statement
12:49:56 <jesusabdullah> Aren't lambdas often slow in other languages?
12:49:57 <kmc> as for "lambda calculus seems pretty slow", that sounds like a meaningless statement... but if you wanted to talk about asymptotic complexity bounds of church-encoded data vs. primitive constructors, there's probably something to be said there
12:50:00 <jmcarthur> tolkad: okay, then i forgive you :)
12:50:06 <jesusabdullah> idk about haskell, but I know that they're slow in matlab
12:50:09 <jesusabdullah> <_<
12:50:27 <kmc> jesusabdullah, "lambda" is just syntax -- it's the literal syntax for a function, as 3 is the literal syntax for an integer
12:50:29 <jmcarthur> jesusabdullah: lambdas are all we have in haskell and they don't seem to be that slow to me :)
12:50:45 <danharaj> That's not true, we have lambdas with primitive types.
12:50:58 <jmcarthur> danharaj: still semantically true
12:51:01 <kmc> but in some languages, functions are slow except in restricted cases
12:51:06 <tolkad> doesn't lambda just mean unnamed function...
12:51:12 <mreh> yes
12:51:51 <jesusabdullah> I just mean that @(x)=*some function of x* in matlab is slower than defining it in a function block
12:52:01 <jesusabdullah> ^ anonymous function
12:52:10 <jesusabdullah> but that doesn't mean much. I mean, it's matlab
12:52:15 <jmcarthur> heh
12:52:30 <BMeph> danharaj:  What do _you_ mean by that? :)
12:52:34 <kmc> there's no good reason why anonymous functions without free variables should be slower -- they can be lambda-lifted trivially
12:52:40 <mreh> hehe, the name alone makes people laugh
12:52:51 <kmc> with free variables you likely have the overhead of constructing closures
12:52:59 <jesusabdullah> lambda-liftind goes somehow sound dirty
12:53:09 <danharaj> BMeph: I meant we have lambda calculus with primitive types, so some function applications reduce in asymptotically less time than if those types were Church encoded
12:53:13 <jesusabdullah> Speaking of matlab, I made a thing and idk if I showed it off (or if you'll even care)
12:53:16 <jesusabdullah> but
12:53:20 <danderson> reasking now that there are people around - is GHC's dependency chasing logic (what `ghc --make` does) available as a library somewhere?
12:53:32 <danderson> bonus points for also understanding hsc and chs sources
12:53:33 <mreh> how are closures represented in haskell? someone asked me, and I said you can do it with a string and an unbound variable
12:53:43 <jesusabdullah> http://github.com/jesusabdullah/methlabs
12:53:45 * BMeph thinks of Andy Griffith in a lab coat when he hears /sees "matlab"..."is that dangerous?" ;)
12:53:54 <jesusabdullah> haha
12:53:57 <jesusabdullah> BMeph: awesome
12:54:05 <danharaj> Hmm speaking of lambda calculus and performance
12:54:13 <gwern> methlabs are certainly dangerous
12:54:14 <jesusabdullah> Makes me think of all the ways that "methlabs" is an appropriate name
12:54:17 <jesusabdullah> Exactly!
12:54:26 <jesusabdullah> They're also addicting, and let you do things REALLY FAST
12:54:39 <danharaj> Can you do parallel reduction on a term?
12:54:40 <mreh> and lose weight
12:54:53 <tolkad> and they both cause hallucinations
12:55:07 <jesusabdullah> hehe
12:55:12 <jmcarthur> mreh: maybe read up on the STG machine
12:55:16 <jmcarthur> @where stg
12:55:17 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:55:17 <gwern> danharaj: mumble mumble strong normalization mumble evaluation strategy mumble
12:55:45 <BMeph> I think "Delusions of Grandeur" is the technical term. ;)
12:56:05 <danharaj> gwern: Well I don't think you could evaluate all redexes in a term at once... there's at least some dependency.
12:56:44 <aavogt> jesusabdullah: have you used matlab's symbolic toolbox? There's quite a bit of FPish stuff in that language
12:58:14 <jesusabdullah> aavogt: I have not! I did discover that the symbolic toolbox has a reduce in it
12:58:29 <jesusabdullah> but afaik I don't have it!
12:58:36 <gwern> I wonder why korean hangul look so much worse in emacs than my other apps
12:58:42 <gwern> emacs must be using a bad font
13:00:42 <Cale> gwern: Yeah, I'm not sure if it applies so much to Korean, but one of the most common problems with ugly Japanese is when a Chinese font gets selected (some of them have somewhat poor renditions of kana)
13:01:04 <gwern> Cale: that wouldn't be an issue with korean - hangul is pretty much korea-only
13:01:59 <Cale> Yeah, I'm not sure. I just thought it's possible that some Chinese fonts might include half-assed Hangul for completeness' sake.
13:02:09 <RichardBarrell> gwern: does it use one font for English and fall back to a different one for the Hangul glyphs? I've seen really ugly text in gnome-terminal once or twice when it decided to pick a font for the fallback that was radically different in size to the main font.
13:02:20 <jesusabdullah> oh, if you guys have suggestions/feedback/etc re: methlabs, I'd love to hear it
13:02:27 <aavogt> jesusabdullah: well it has a significant subset of Data.List, among standard symbolic stuff
13:02:28 <jesusabdullah> I'm certainly no FP expert
13:02:41 <jesusabdullah> hmm
13:02:47 <gwern> RichardBarrell: I dunno. how would I notice that? looks the right size
13:02:55 <aavogt> I never worked out how to integrate that with the rest of the program
13:03:03 <monochrom> Yes, many Chinese fonts contain probably-suboptimal Japanese, and vice versa.
13:03:06 <jesusabdullah> I should look at it mebbs
13:03:45 <aavogt> that is, use a function that was calculated with some symbolic math directly in some regular calculations
13:03:48 <monochrom> Of course, the problem of Japanese fonts containing suboptimal Chinese bugs me more.
13:04:04 <kmc> mreh, Haskell specifies no representation for closures -- indeed, an implementation is not required to have anything called a "closure"
13:04:08 <RichardBarrell> gwern: IIRC, when I got gnome-terminal to do that, it showed some glyphs actually managing to make their way out of the rectangle that they're supposed to fit into, so that they overlapped a lot.
13:04:26 <gwern> RichardBarrell: definitely no overlapping
13:04:55 <RichardBarrell> No idea, then. Sorry I couldn't help.
13:05:01 <kmc> mreh, the traditional representation of closures in compiled functional code is a code pointer (into read-only program memory) plus a vector of zero or more free variables
13:05:22 <kmc> i'm not sure what you mean by "a string and an unbound variable"
13:05:45 <mreh> kmc: explicitly writing out the lambda expressions, and eta reducing
13:05:55 <Cale> People talking about 'closures' when they mean 'functions' is one of my pet peeves.
13:06:40 <RichardBarrell> kmc: couldn't you go one farther than that and say that H98 doesn't actually specify *any* representations? It only specifies semantics. You only get representations specified when you add the C FFI, and even then only in terms of the local C compiler.
13:06:46 <mreh> so when that man asked me about closures in haskell, it was a trick question!
13:06:49 <kmc> yeah
13:07:00 <kmc> he probably meant "in GHC"
13:07:12 <jesusabdullah> ghc, haskell, same thing!
13:07:26 <kmc> a lot of people are confused about the language/implementation distinction, and a lot of languages do their best to confuse them
13:07:26 <mreh> well yes, but haskell is synonymous with GHC
13:07:31 <mreh> sorry Hugs
13:07:44 <Cale> Closures are always an implementation detail for functions. Programming languages typically don't "have closures", they have first class functions. Language implementations might use closures as an internal representation of functions.
13:07:50 <mreh> in common parlance
13:07:59 <kmc> i'll believe that when GHC has all the cool extensions from Hugs and JHC and UHC
13:08:10 <RichardBarrell> Cale: you do sometimes need to use the term "closure" as a subset of "function" though, because the distinction impacts on reachability. Arguably, space consumption *is* part of the semantics.
13:08:20 <ddarius> kmc: What about YHC, LHC, NHC, and HBC?
13:08:29 <kmc> they might have cool extensions too
13:08:36 <kmc> i'm not aware of any that aren't in GHC
13:08:48 <RichardBarrell> ddarius: have you tried MHC?
13:08:50 <gwern> ddarius: which are used by a score and twain...
13:09:02 <Cale> RichardBarrell: Well, even if you want to talk about space consumption, I'm not sure you need anything more detailed than the graph reduction view of things.
13:09:25 <mreh> does cabal insist on installing the newest libraries when I have a working set of libraries that are sufficient
13:09:26 <ddarius> You rarely need graph reduction.
13:09:28 <Cale> and there are no closures to speak of when you're just talking about graphs representing expressions
13:09:41 <RichardBarrell> ddarius: MHC is the Manual Haskell Compiler. That's when someone slaps you with a trout and forces you at gunpoint to rewrite your program in something lower-level. :)
13:09:43 * ddarius usually uses syntactic substitution.
13:09:52 * fryguybob waits for ☃hc
13:09:55 <Cale> ddarius: indeed
13:10:06 <gwern> mreh: I don't think it would
13:10:11 <Cale> and most of the time even when you do need to represent sharing, you can do it using let
13:10:16 <mreh> gwern: I didn't think so either
13:10:20 <Cale> (if not all of the time)
13:10:28 <ddarius> Cale: You can do it all the time.
13:10:34 <dcoutts_> mreh: by default cabal install tries to use existing installed versions of dependencies
13:10:35 <Cale> Sometimes it gets awkward though
13:10:39 <mreh> I'm trying to conditionally compile lambdacube with OpenGL 2.1
13:11:03 <Cale> (you end up making a somewhat arbitrary choice of where to cut the cycles)
13:11:07 <mreh> but it kept installing the OpenGL 3 bindings
13:11:09 <dcoutts_> mreh: it's not always possible of course and it might have to pick newer versions or reinstall existing versions
13:11:28 <dcoutts_> mreh: you can add extra constraints to force what it picks
13:13:20 <Cale> To a lesser extent, I also dislike the overuse of the word 'thunk'.
13:13:32 <Cale> When often 'expression' would do.
13:14:26 <Cale> I don't really want to think about how expressions are represented at runtime :)
13:14:51 <benmachine> is "thunk" a bit like "closure" in that it's an implementation detail that people get confused with a concept
13:14:58 <Cale> yes
13:15:12 <Cale> (at least, I think so)
13:15:27 <c_wraith> Well, no.  To me, and to many people, thunk *explicitly* means "an expression that is not yet fully evaluated"
13:15:32 <Cale> thunks are the runtime machine representation of expressions
13:15:41 <RichardBarrell> Cale: okay, but people don't usually start throwing the term "thunk" around until they've reached a point where they actually *are* concerned with implementation details, because they have written a program whose CPU or memory consumption they cannot afford.
13:15:48 <aavogt> c_wraith: isn't it still one after you evaluate it fully?
13:16:00 <Cale> RichardBarrell: Yes, but that's one step too low-level most of the time
13:16:06 <c_wraith> aavogt, technically, but really people only care about unevaluated thunks.
13:16:10 <aavogt> there's still some indirection
13:16:29 <Cale> RichardBarrell: Usually you don't care about the *exact* mechanism for representing expressions, you only care about what expressions are floating around at runtime.
13:16:50 <Cale> (and how complicated those expressions are, roughly)
13:17:05 <c_wraith> Cale: The fact that it's still unevaluated is important.  and the capability to be in different states, evaluated/unevaluated, is a pretty distinguishable feature of a thunk.
13:17:34 <Cale> c_wraith: Well, you have expressions and data constructors.
13:17:41 <RichardBarrell> There's also the aaah-I-just-caused-a-stack-overflow problem, which causes you to really, really care about exactly how many of the expressions that sit between you and the nearest constructor or not-yet-applied function.
13:18:06 <RichardBarrell> In that case, the term "thunk" as shorthand to refer specifically to an unevaluated expression is really useful.
13:18:09 <ksf> I think the english can rest comfortably in the fact that there's something that's worse than their football, which is their food.
13:18:27 <Cale> RichardBarrell: I tend to think of the GHC stack as consisting of all the case expressions which are waiting for their scrutinee to be sufficiently evaluated so that they can pattern match.
13:18:35 <RichardBarrell> ksf: I'd swear at you for that, but I'm Welsh and I just cooked noodles.
13:18:57 <gwern> ksf: the tragedy of canada is that it could have had british culture, french food, and american tech. instead it got british food, american culture, and french tech
13:19:20 <c_wraith> ksf: where does their dentistry fit in?
13:19:38 <RichardBarrell> Cale: cool. Now come up with a one syllable name for a case expression which is waiting for its scrutinee to be sufficiently evaluated so that it can pattern match, because people need to talk about them in email and on IRC when they are helping friends and strangers to debug their programs. :)
13:19:59 <ksf> c_wraith, how should I know?
13:20:00 <Cale> RichardBarrell: Well, those aren't thunks.
13:20:14 <Cale> I don't know of a particular name for them.
13:20:14 <gwern> c_wraith: american, I assume. I don't remember any canucks I've met having hrroible british teeth
13:20:38 <Cale> I might call them pending cases.
13:20:54 <gwern> Cale: and the datastructure holding them all 'the docket'? :)
13:21:01 <Cale> hehe
13:21:09 <c_wraith> I like that.
13:21:10 <RichardBarrell> Cale: oh, I see. But aren't the number of pending cases that aren't thunks always constant for any given program?
13:21:15 * gwern objects! because that is equivalent to the halting problem
13:21:26 <c_wraith> legal-terminology-oriented programming!
13:21:27 <Cale> RichardBarrell: No, that is exactly what the stack consists of
13:21:53 <gwern> c_wraith: if you don't like the result (+) returned, appeal it to the unit test court
13:22:05 <RichardBarrell> Cale: oops.
13:22:08 <Cale> Whenever you bump into a case expression which tries to match on something which isn't a data constructor already, the case goes on the stack, and you start evaluating the thing
13:23:15 <Cale> Of course, for this view to work out in detail, you need to think of strict primitive functions as still using case internally :)
13:23:46 <Cale> So, for instance, (+) for Integer will pattern match on both of its args :)
13:25:53 <RichardBarrell> Cale: what? Of course it pattern-matches! Adding a pair of Word64s could only ever be done with giant LUTs!
13:27:32 <SonOfLilit> what is the naming convention for functions that return maybe?
13:27:50 <gwern> I haven't noticed any
13:28:35 <SonOfLilit> I think I noticed that the fact is usually ignored - as in, they are given the same name they would be given if (error) was used to handle edge cases
13:28:45 <monochrom> xxxToMaybe
13:28:53 <SonOfLilit> except that maybeHead is called listToMaybe for some reason
13:29:26 <SonOfLilit> that is a horrible naming convention
13:29:42 <monochrom> Yes, please give us a better one.
13:29:57 <monochrom> Perhaps enterpriseSafeXxx
13:30:00 <SonOfLilit> I'm writing a function that chooses a 4-in-a-row move. Should I call it boardToMaybe?
13:30:19 <SonOfLilit> I'm thinking of something like maybeChooseMove
13:30:24 <SonOfLilit> or just chooseMove
13:30:46 <SonOfLilit> after all, if people guess wrong the type from the name, the compiler will be quick to alert them to it
13:30:59 <monochrom> just call it chooseMove if there is no other version.
13:31:10 <SonOfLilit> (btw, just set up flymake, and it is so awesome to get alerted within milliseconds to my type errors :) )
13:31:39 <SonOfLilit> guess I will, if there is no convention against it
13:31:40 <monochrom> If there is another version, one that skips the maybe, then it becomes unsafeChooseMove
13:31:41 <SonOfLilit> thanks
13:32:41 <RichardBarrell> SonOfLilit: ooh, flymake sounds nice.
13:47:06 <soupdragon> @pl \xy vx vy -> diff (\xx -> h xx xy vx vy) xx
13:47:07 <lambdabot> flip flip xx . ((flip . (diff .) . flip) .) . flip . flip h
13:49:05 <nominolo> anyone understand this year's icfp contest task?
13:49:45 <BMeph> soupdragon: Did you intend that shadowing you wrote? :)
13:49:59 <soupdragon> no I didn't
13:51:19 <soupdragon> \xx xy vx vy -> diff (\xx -> h xx xy vx vy) xx   -- doesn't work :/
13:57:34 <soupdragon> oh I see,  foo = diff (h 3 7 6) 7  works but  foo' q = diff (h 3 q 6) 7  does not
13:59:05 <soupdragon> how can I do this then :/
14:00:16 <max_atreides> where can i find examples of well written haskell code?
14:00:24 <max_atreides> just for learning
14:01:17 <RichardBarrell> max_atreides: XMonad is said to be pleasingly well-written, although it needs to be slightly insane in order to cope with the fact that X11 is slightly insane too. ;)
14:01:50 <max_atreides> RichardBarrell: no joke! Thanks, I will check it out :)
14:02:03 <RichardBarrell> max_atreides: darcs is also supposed to be pretty nice. :)
14:03:29 <adyxax> hi
14:03:41 <adyxax> i have a dependency problem with an app
14:03:45 <max_atreides> also, is there a way to nuke all haskell-related files from the orbit? Something went wrong with my cabal upgrade and now I'm having trouble fixing it
14:04:21 <adyxax> anyone willing to help me?
14:04:22 <dcoutts_> max_atreides: rm -r ~/.ghc ~/.cabal
14:04:40 <dcoutts_> max_atreides: don't use "cabal upgrade". Use "cabal install".
14:04:40 <nominolo> RichardBarrell: really?  I'd suggest looking at Xmonad first in any case.
14:04:50 <Heffalump> max_atreides: darcs is not really an example of well-written Haskell code
14:04:59 <Heffalump> well, we're gradually getting it in that direction
14:05:07 <Heffalump> but it's quite an old codebase
14:05:20 <max_atreides> dcoutts_: dcoutts_ alright :)
14:05:23 <Heffalump> and was originally written by someone who was learning Haskell as he went
14:06:55 <max_atreides> hellige: noted :)
14:07:51 <soupdragon> This is cool http://pastie.org/1010732.txt
14:08:05 <soupdragon> It is using differentiation now
14:08:16 <soupdragon> so you don't have to solve any equations yourself
14:08:36 <Phyx-> adyxax: don't ask to ask, just ask
14:09:15 <c_wraith> is it worth using unsafeInterleaveIO to make an internal-only API cleaner?  The use is totally safe, in this internal API.
14:09:20 <soupdragon> it figures out the motion from the hamiltonian
14:09:26 <Heffalump> c_wraith: yes
14:09:49 <c_wraith> @hoogle unsafeInterleaveIO
14:09:49 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
14:11:12 <dcoutts_> c_wraith: unsafeInterleaveIO is fine if you understand it, it's not unsafe like unsafePerformIO is
14:12:01 <adyxax> ok Phyx
14:12:11 <adyxax> I am working on a bot
14:12:19 <adyxax> I depend on parsec-3 for parsing
14:12:31 <adyxax> but I also depend on network, which depends on parsec-2
14:12:45 <adyxax> each time I cabal install my bot, it recompiles me network...
14:12:46 <Heffalump> why on earth does network depend on parsec?
14:12:50 <adyxax> and it's driving me mad
14:13:05 <adyxax> i don't know, i just report my warning
14:13:10 <adyxax> and this behaviour
14:13:22 <adyxax> i am using OpenBSD 4.7, and ghc 6.12.3
14:13:24 <andreo> i have a problem with unicode in ghci. I.e. if I type "привет" ghci evaluates it as "\1087\1088\1080\1074\1077\1090"
14:13:39 <andreo> how can i fix it?
14:13:50 <dcoutts_> adyxax: as a workaround, use parsec 2 and unregister local versions of the network package
14:13:56 <Cale_> andreo: That's what you get for the empty string?
14:13:57 <dcoutts_> Heffalump: URI parsing I think
14:14:32 <andreo> Cale_: i get it for unicode string (hello in Russian)
14:14:34 <nominolo> dcoutts_: really?  what's so fine about unsafeIlvIO?
14:14:56 <adyxax> in fact I am wondering because it was working well in previous ghc 6.12
14:15:14 <andreo> Cale_: it is empty because of irc
14:15:18 <Cale_> andreo: Well, that's a 6 character unicode string.
14:15:22 <andreo> yes
14:15:28 <Cale_> If you putStrLn it, it should show up correctly
14:15:51 <dcoutts_> nominolo: the appropriate question is what is unsafe about it, and what the safety obligation is. People are often unduly worried because of the naming similarity with unsafePerformIO.
14:15:55 <c_wraith> Cale: that depends on your version of ghc.  in 6.12, yes.  in 6.10, not even close
14:15:57 <Cale_> 'show' will automatically quote things so that they're in a representation which is ASCII printable.
14:16:22 <dcoutts_> adyxax: out of interest, what does cabal install -v --dry-run report about the reason it's reinstalling network?
14:16:34 <Cale_> c_wraith: Well, it seems to be handling unicode properly, so it's probably 6.12
14:16:34 <nominolo> dcoutts_: right, that's what I meant;  what's the safety obligation for unsafeIlvIO?
14:16:56 <dcoutts_> nominolo: it's about the non-determinism "not mattering"
14:16:59 <adyxax> I will paste that in a second
14:17:01 <andreo> Cale_: ghci 6.12
14:17:20 <Cale_> andreo: Yeah, so that behaviour you're seeing is "correct"
14:17:40 <Cale_> andreo: It's arguably suboptimal, but at present, that's just what 'show' does to strings.
14:18:03 <andreo> Cale_: how can i make 'show' print unicode characters from different languages
14:18:08 <Cale_> andreo: Does the string show up properly when you apply putStrLn to it?
14:18:48 <Cale_> andreo: Well, you'd have to do something inside the Prelude in GHC to make it not quote printable characters from other languages.
14:19:00 <andreo> Cale_: yes
14:19:03 <dcoutts_> nominolo: if any possible interleaving is an acceptable behaviour then it's ok to use. This usually comes down to the deferred IO effect being independent of other effects.
14:19:12 <andreo> cale_: thanks
14:19:35 <nominolo> dcoutts_: hm, the docs don't mention any of that
14:19:49 <nominolo> dcoutts_: while the unsafePerformIO docs have clearly been improved
14:19:52 <c_wraith> nominolo, dcoutts_: In my case, the deferred effect is reading an MVar.  The way it's getting populated isn't being affected by any other IO actions, so it's safe.
14:20:25 <Cale_> andreo: I think the goal for show at present is to print the string in a way which is valid source code, and fairly independent of encoding, but it does tend to make strings in other languages pretty hard to read :P
14:20:28 <dcoutts_> c_wraith: and why don't you want to read the MVar there and then?
14:21:34 <dcoutts_> nominolo: I'm not sure it's universally agreed what the semantics of unsafeInterleaveIO are, and some people think it's just evil and has broken semantics.
14:22:11 <c_wraith> dcoutts_, err.  Why not, indeed?  I was totally misreading the case I'm in.  Yeah, I can ignore the unsafe, once again. :)
14:22:14 <dcoutts_> nominolo: you'll see people arguing that it break purity or referential transparency
14:22:54 <nominolo> dcoutts_: well, it does :)
14:22:56 <dcoutts_> c_wraith: even better :-)
14:23:07 <c_wraith> Every time I nearly use unsafeInterleaveIO, it turns out I don't need to.  I like this. :)
14:23:15 <dcoutts_> nominolo: heh, I disagree, I think it has a perfectly sensible, though not always useful semantics.
14:24:33 <c_wraith> There is a similar case where unsafeInterleaveIO . takeMVar makes sense.  But that's the case where you're starting a bunch of slow actions to run in parallel, and so you want to start the next before reading the return value of the first.
14:25:00 <c_wraith> And that's not my case, which is just "start a process, or wait for an existing one, then continue when its results are in"
14:25:00 <Heffalump> c_wraith: shouldn't you use forkIO then?
14:25:17 <dcoutts_> c_wraith: right, you could use that to implement a kind of implicit async IO system
14:25:35 <c_wraith> Heffalump, You need to use forkIO *and* an MVar for the first case.  You can hide the MVar with unsafeInterleaveIO, though.
14:25:43 <dcoutts_> Heffalump: the forkIO would be explicit async IO
14:25:47 <nominolo> dcoutts_: the critque is about the semantics of asynchronous exceptions.  also lazy I/O is built on assumptions that are simply not true.
14:26:16 <nominolo> dcoutts_: of course, we have to separate lazy I/O issues from unsafeInterleaveIO semantics
14:26:32 <dcoutts_> nominolo: you mean lazy I/O is a slightly leaky abstraction because of the possibility of other processes changing files behind our backs etc
14:26:33 <adyxax> /srv/www/wiki.adyxax.org/
14:26:37 <adyxax> oups
14:26:58 <c_wraith> I can use a pattern guard in a case statement, righ?
14:27:05 <adyxax> http://wiki.adyxax.org/uploads/graou.txt
14:27:08 <nominolo> dcoutts_: yes.  or the file may disappear, or the socket buffer may overflow in he meantime
14:27:22 <nominolo> c_wraith: right
14:27:38 <dcoutts_> nominolo: right, it's not always an appropriate abstraction.
14:27:49 <Heffalump> dcoutts_: btw, you know your reddit comment about F# async being about more than just lightweight threads? Can you expand on it?
14:28:28 * Heffalump thinks anything you'd write with async, you could just write with an IO computation that you forked.
14:28:36 <Heffalump> (with the same structure etc too)
14:28:37 <dcoutts_> Heffalump: I think Don Syme's slides will be up shortly, he had some nice examples of using async IO to make writing little network client apps nice and simple.
14:29:02 <dcoutts_> Heffalump: you could of course, the question is what is the nicer program to write.
14:29:09 <dcoutts_> or the nicer program to read
14:29:20 <Heffalump> dcoutts_: I mean that there is a close structural correspondence in the code
14:30:17 <dcoutts_> Heffalump: I suspect that we could do something similar in a few lines using forkIO and MVars, but it may still be useful to have it as a standard idiom
14:30:42 <dcoutts_> Heffalump: I don't know a huge amount about it in F#, just that it seems worth looking at what they're doing.
14:32:33 <Heffalump> I guess there is some stuff around exception handling and cancellation, which you'd need to add a monad transformer to IO to handle properly.
14:32:36 <dcoutts_> nominolo: note that the file disappearing should be handled fine with lazy Io, you're not likely to be able to do much better with strict IO, you're probably just going to end up throwing an exception anyway.
14:32:42 <Heffalump> I think it'd be a small library.
14:32:56 <dcoutts_> nominolo: though if you need more detailed control then sure, you want to use a more detailed interface
14:41:21 <dcoutts_> Heffalump: google "async F#" turns up a bunch of talks and blog posts with examples
14:44:33 <dromal> msg nickserv register kaiwhakahaka neiljones@lavabit.com
14:44:41 <dromal> oops
14:45:05 <mauke_> and this is why you use /query
14:45:24 <gwern> I wonder if that's his email password too
14:45:33 <dromal> haha, fortunately not
14:47:28 <gwern> guess not
14:48:14 <gwern> *seems
14:56:53 <dschoepe> In case there are any cabal people around: Is there a way to get the temporary directory in which cabal-install compiles a package (from within the functions in cabal-install's Install.hs)?
14:57:46 <jbapple> dschoepe: I asked this question a few weeks ago. I was told no
14:58:27 <jbapple> You can, apparently, set up cabal and build the package in such a way that Haskell programs importing a prticular compiled package can call a function in the IO monad that will return the correct directory
14:58:36 <jbapple> But there is no way for a human to find out this information
14:59:13 <jbapple> This means, for instance, there is no reasonable way to install any documentation that isn't Haddock-generated
14:59:44 <jbapple> Or, you can install it, but don't expect to find it later
14:59:55 <gwern> jbapple: who but a human writes a program using the the Paths_ module?
15:00:02 <chrisdone> heylo
15:00:16 <dschoepe> jbapple: Well, I want to determine that directory from within one of the installation functions of cabal-install, so that should be somewhat simpler.
15:02:16 <jbapple> gwern: Robots. Seriously, though, I hope I made it clear by the context that it would be nice if a user could figure out where cabal had installed files without using the find command or requiring the package author to build an otherwise useless library artifact so the user can load a language interpreter, then load that library, to call a function to print a directory name. It seems a bit like overkill
15:02:54 <gwern> jbapple: Paths_ is built for all cabal packages
15:03:11 <gwern> I'm afraid you are replete with useless artifacts
15:04:02 <gwern> and if the user is deathly allergic of ghci, then they can go look at their cabal config and see where stuff gets isntalled
15:04:26 <Saizan> dschoepe: i'm pretty sure there is
15:04:44 <Saizan> jbapple: what is it that you'd want to find?
15:05:20 <jbapple> Saizan: documentation installed along with the package
15:05:24 <dcoutts> jbapple: I don't recall talking about that
15:05:53 <jbapple> dcoutts: let me find a reference for you
15:05:56 <dcoutts> dschoepe: from within Install.hs in the cabal-install code, no. The temp dir is chosen randomly at a lower level
15:06:22 <dcoutts> dschoepe: are you hacking on cabal-install? what are you trying to do?
15:06:50 <jbapple> gwern: I'm trying to figure out where I got the idea that Paths_ would have to be built or exported by an additional specification in the .cabal file, but I can't even find a reference to it in the cabal user guide right now.
15:06:50 <dschoepe> dcoutts: I'm trying to implement this: http://hackage.haskell.org/trac/hackage/ticket/402
15:07:12 <dcoutts> jbapple: I think installing non-haddock docs different from what dschoepe it talking about
15:07:13 <andreo> How can I resolve name conflict in haskell? It could refer to either `Prelude.lookup', imported from Prelude
15:07:14 <andreo>                           or `Data.HashTable.lookup', imported from Data.HashTable
15:07:24 <gwern> jbapple: the best ref I know of right now remains ndm's blog post
15:07:40 <mauke> andreo: use Prelude.lookup or Data.HashTable.lookup
15:07:49 <jbapple> dcoutts: I assume there was an "is" left out of that sentence?
15:07:51 <Heffalump> andreo: either refer to the name qualified, or add hiding (lookup) to one of the import statements
15:07:54 <Saizan> dschoepe: see installAvailablePackage, that's the function that prepares the source tree for the installing procedure
15:08:02 <dschoepe> dcoutts: I only have trouble locating the .txt generated by cabal haddock --hoogle. I guess I could just redirect the output to another temporary directory, but then I'd have to take care of all the details like possible symlink attacks etc.
15:08:02 <Heffalump> (for Prelude you might first have to add an explicit "import Prelude")
15:08:04 <dcoutts> jbapple: erm, yes :-)
15:08:17 <andreo> so using full name, thx
15:08:17 <jbapple> dcoutts: I was responding to dschoepe before he specified exactly what he was looking for
15:08:45 <jbapple> gwern: I don't remember that blog post. I don't know if I ever saw it
15:09:04 <dcoutts> dschoepe: I think the best approach would be to get it to be put somewhere specific under your control, rather than to rely on fishing it out from somewhere
15:09:13 <jbapple> dcoutts: I filed a bug about this issue. Are you still concerned that " I don't recall talking about that"?
15:09:45 <Saizan> jbapple: can't you find the documentation by the haddock-interface and haddock-html fields in ghc-pkg describe $pkg?
15:10:02 <dcoutts> jbapple: ah, http://hackage.haskell.org/trac/hackage/ticket/674
15:10:11 <dcoutts> jbapple: sorry, I'd forgotten that I'd seen it before
15:10:29 <jbapple> Saizan: maybe. I have at least three other IRC messages I am trying to lookup info for now, but I promise I will get to this soon. Thank you for the tip
15:11:01 <c_wraith> sometime this weekend, I'll get to Saizan's code for reading ghc config out of cabal.  Now that I really have a good idea what I want to do with said data, that seems much more interesting.
15:11:20 <Saizan> jbapple: nvm, you say in the ticket these aren't haddock docs
15:11:41 <dcoutts> jbapple: btw, for point 2 in that ticket, wouldn't looking in the "standard" place be ok? I mean the --docdir specified at configure time (which defaults to $prefix/share/doc/$pkgid)
15:11:45 <dschoepe> dcoutts: would it be okay to create a temporary directory somewhere in cabal's data directory? Since putting it in some public place like /tmp/ raises possible security issues especially since there seems to be function in the standard library to securely create a temporary directory.
15:12:18 <jbapple> dcoutts: how is that specified at configure time? That is, I don't type it in in the command prompt.
15:12:32 <aristid> is there a good data structure for containers mapped over very small enumerations?
15:13:05 <dcoutts> jbapple: you get the default doc dir which is $prefix/share/doc/$pkgid , eg ~/.cabal/share/doc/$pkgid or /usr/local/share/doc/$pkgid
15:13:05 <mauke> aristid: an array?
15:14:08 <dschoepe> dcoutts: as it turns out, I was just blind, there's getTemporaryDirectory
15:14:13 <jbapple> dcoutts: That's fine that it's there, but I want to be able to find it without poring through hundreds of lines of the output of the tool
15:14:20 <dschoepe> oh, wait, that's not what I'm looking for
15:14:55 <aristid> mauke: by instancing Ix over the enumeration?
15:14:56 <dcoutts> jbapple: I'm not sure I follow, if you want the docs for some package, just look in the standard directory for it
15:15:25 <dcoutts> jbapple: is the issue that most users do not know what that directroy is? (perfectly reasonably)
15:15:47 <jbapple> dcoutts: OK, here's the scenario. I type "cabal install somepackage". It outputs hundreds of lines of compiler messages. I now want to look at the docs. How do I find them?
15:15:50 <jbapple> dcoutts: yes
15:16:02 <dcoutts> ok right, not everyone knows what the unix conventions are on where files get installed
15:16:26 <dcoutts> jbapple: so perhaps cabal info blah should list the package's doc directory
15:16:35 <dcoutts> if it's installed
15:17:10 <dschoepe> dcoutts: problem solved, Distribution.Simple.Utils.withTempDirectory does what I need.
15:17:18 <jbapple> dcoutts: It's not just "the unix conventions". For instance, I expected the files to be in /usr/packagename or /usr/local/packagename or /opt/packagename or opt/cabal/packagename or opt/ghc/cabal/packagename
15:17:48 <jbapple> sun wants to put java in /usr/java
15:17:58 <jbapple> and openoffice in /opt/oo.o3 or something
15:18:17 <jbapple> make likes /usr/local, but aptget likes /usr
15:18:27 <jbapple> Thus, I end up using the find command
15:18:30 <jbapple> which makes me sad
15:18:34 <dcoutts> jbapple: the "usual" location for packages that are not installed by the system package manager is /usr/local
15:18:39 <jbapple> and cabal list doesn't help
15:19:17 <jbapple> dcoutts: usr/local/cabal?
15:19:21 <jbapple> /usr/local/ghc?
15:19:33 <jbapple> /usr/local/cabal-install?
15:19:38 <jbapple> yes, I can find them
15:19:44 <dcoutts> jbapple: different kinds of files go in different places
15:19:45 <jbapple> I just would like it to be a little bit easier
15:20:16 <dcoutts> lib files go in $prefix/lib/$pkgid, arch independent files go in $prefix/share/$pkgid
15:20:26 <monochrom> I put ghc and haskell platform in /usr/local/haskell-platform-2010.1.0.0
15:20:32 <dcoutts> documentation files go in $prefix/share/doc/$pkgid
15:20:36 <jbapple> sorry, I mean /usr/local/share/doc/{ghc,cabal,...}
15:21:29 <dcoutts> jbapple: right, it'd be /usr/local/share/doc/$pkgid for global installs by default
15:21:42 <jbapple> I have a directory "/usr/local/share/doc/ghc/Cabal"
15:21:52 <jbapple> dcoutts: yes, I know that now
15:22:14 <jbapple> dcoutts: But I may forget later
15:22:27 <jbapple> It would be nice if cabal list told me when I forget
15:22:54 <jbapple> and it would be nice if it told me if the package it found if global or user-only, so I din't have to look two places
15:22:58 <dcoutts> jbapple: cabal info says, though I'm just trying to work out why it's not working for me
15:23:41 <jbapple> dcoutts: It does say, for Haddock-generated docs
15:23:55 <jbapple> dcoutts: But I need to install docs that are not Haddockable
15:24:13 <dcoutts> jbapple: ah so the point is you want it to list the package's doc dir even if there are no haddock docs and only other docs
15:24:31 <dcoutts> jbapple: ok so what makes that tricky is that we don't know if there are any other docs installed
15:24:54 <jbapple> dcoutts: hence, my bug report
15:24:57 <dcoutts> and actually we do not necessarily know where they are installed
15:25:14 <dcoutts> jbapple: so this comes under the more general issue of cabal tracking files that it installs
15:25:37 <dcoutts> and it would not know about the doc location of libs that were installed by the system package manager
15:25:48 <dcoutts> again, except for haddock docs
15:25:59 <dcoutts> since those are actually listed with the ghc-pkg registration info
15:26:18 <jbapple> dcoutts: The files in my package that are extra docs are not, as far as I can tell, installed by the system package manager
15:26:48 <jbapple> gwern: Are you sure Paths_ is generated regardless of cabal build specs?
15:27:11 <dcoutts> jbapple: Paths_ is always generated (unless one does something invasive to prevent it)
15:27:44 <jbapple> dcoutts: Since I want them installed, and there is no way to specify that, I list them as data-files
15:27:56 <jbapple> so, presumable, cabal-install installs them itself
15:28:22 <jbapple> but then won't tell me where later, using info
15:28:39 <jbapple> I mean, cabal info
15:29:17 <dcoutts> jbapple: right, data files are presumed not to be needed by users, just by the program that installed them.
15:29:47 <jbapple> dcoutts: So, my problem is that there is no way to install files that are needed by users but not generated from .hs files
15:29:59 <dcoutts> the solution is to handle general documentation properly, rather than to pretend they are data files
15:30:18 <dcoutts> jbapple: that's not quite true, but it's not that easy.
15:30:28 <jbapple> dcoutts: I don't really have any other choice right now, do I?
15:30:46 <jbapple> I mean, if I don't pretend they are data files, they won't get installed, right?
15:30:56 <dcoutts> jbapple: you'd need to add code in Setup.hs to do special things in the build and copy actions. There you'd look up the selected target docdir and copy the files there.
15:31:47 <gwern> jbapple: I don't know any way to disable it short of messing around in dist/, and it may not exist for executables, dunno
15:32:06 <jbapple> dcoutts: Would cabal then correctly list them in "cabal info"?
15:32:25 <dcoutts> jbapple: no, that only looks at the haddock info from ghc-pkg
15:32:45 <dcoutts> jbapple: though if the haddock docs were also installed, the location would happen to be the same
15:33:56 <jbapple> dcoutts: BTW, cabal info isn't working for me either, unless these docs really are not installed
15:34:02 <jbapple> I mean, the haddock docs
15:34:11 <chrisdone> dcoutts: does cabal-install support installing all the dependencies of a package without installing the package itself?
15:34:12 <jbapple> which I think are installed, but cabal info isn't aware of
15:34:59 <dcoutts> chrisdone: no but there's a ticket for it, and it should not be too hard to implement
15:35:07 <jbapple> OK, they aren't. How do I make cabal install haddock docs?
15:35:37 <chrisdone> dcoutts: oh, awesome, in that case i might try this weekend
15:36:23 <dcoutts> jbapple: --enable-documentation 
15:36:39 <jbapple> Hm. That is in my alias, and yet the haddock docs were not built
15:38:06 <Starfire> @pl \x -> fmap ($x)
15:38:07 <lambdabot> fmap . flip id
15:38:38 <ddarius> :t \x -> fmap ($x)
15:38:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
15:38:51 <ddarius> :t fmap . runCont . return
15:38:53 <lambdabot> forall (f :: * -> *) r a. (Functor f) => a -> f (a -> r) -> f r
15:42:03 <jkramer> Meh
15:42:06 <jkramer> hsc2hs: Char.intToDigit: not a digit 128
15:42:21 <gwern> isn't ascii 0-127?
15:42:25 <dcoutts> jbapple: ah, actually it's every so slightly more useful. It reports the documentation location if the doc dir exists and I think that the ghc-pkg info always reports the doc dir even if no haddock docs are actually built/installed.
15:42:30 <gwern> > intToDigit 0
15:42:31 <lambdabot>   '0'
15:42:36 <gwern> > intToDigit 11
15:42:36 <lambdabot>   'b'
15:42:41 <gwern> > intToDigit 128
15:42:42 <lambdabot>   *Exception: Char.intToDigit: not a digit 128
15:42:44 <gwern> > intToDigit 127
15:42:45 <lambdabot>   *Exception: Char.intToDigit: not a digit 127
15:42:49 <gwern> hm
15:43:00 <gwern> maybe it's hex
15:43:04 <gwern> > intToDigit 16
15:43:04 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
15:43:07 <gwern> > intToDigit 15
15:43:07 <lambdabot>   'f'
15:43:10 <dcoutts> jbapple: see, ghc-pkg field ${pkgname} haddock-html
15:43:21 <jkramer> I'm getting that error when trying to install download
15:43:23 <gwern> well. that's not what I would've expected something named 'intToDigit' to do
15:43:24 <dschoepe> dcoutts: If I give the second call(for generating hoogle-output) to cabal-haddock another temporary directory via haddockDistPref so that I know where it is, it says that the package has not been configured. Yet I feel uncomfortable to pass the original directory along through those function calls. Is there a better alternative?
15:43:29 <jkramer> (the package "download")
15:43:29 <dcoutts> jbapple: if that directory exists, then cabal info will report the location
15:44:52 <jbapple> dcoutts: How can I get ghc-pkg to just list all the info it has about a package?
15:45:02 <dcoutts> jbapple: ghc-pkg describe
15:45:19 <chrisdone> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/697 -- this one?
15:45:22 <Saizan> dschoepe: actually, haddock can generate both the .txt and the html with a single invocation, though the Distribution.Simple.Haddock doesn't currently support that
15:46:00 <dcoutts> dschoepe: I'm not quite sure I follow the details here
15:46:12 <Saizan> dschoepe: there should even be a nominolo's patch to support both --html and --hoogle flags at once floating around on cabal-devel@
15:46:16 <dschoepe> Saizan: yes, that's why I'm currently calling it twice. But anyhow, that'd still leave me with the same problem iirc.
15:46:23 <dschoepe> oh, I'll try that
15:46:34 <dcoutts> dschoepe: in principle there is no problem in using a different temp file for the hoogle txt, even if it's in a totalyl different directory to the build
15:47:20 <dschoepe> dcoutts: Yes, that's what I expected. But how do I tell cabal/haddock to put the file somewhere else? I tried setting haddockDistPref which caused the mentioned problem.
15:47:31 <dcoutts> Saizan: oh is there, it's passed me by. We need a "patch" status flag on bugs so that we don't lose track of tickets with patches.
15:48:14 <dcoutts> dschoepe: you don't want to change the haddockDistPref, you want to specify the output location of the hoogle text file
15:48:49 <dcoutts> dschoepe: and it looks like the problem there is that that output location currently cannot be specified
15:49:12 <dcoutts> dschoepe: it'd need to be extended to be --hoogle= rather than just --hoogle
15:49:35 <dcoutts> chrisdone: that's the one
15:50:01 <dschoepe> hmm, haddock supports a "--odir" argument and from what I understand I can set some other arguments to be given to haddock via the CommandUI structure, right?
15:50:41 <Saizan> dcoutts: "darcs patch: Add --html for haddock command." is the subject of the cabal-devel post
15:50:52 <dcoutts> jbapple: so one of the current limitations that Cabal/cabal-install operates under is that it's not a proper package manager in the sense that it does not track installed files. The only way it knows about installed packages is via what ghc-pkg keeps track of.
15:51:42 <dcoutts> jbapple: from one POV that's great, it means that cabal-install does not mind if packages were installed manually or via a system package manager. The downside is that it works with limited information.
15:51:54 <dcoutts> Saizan: ta
15:53:42 <chrisdone> dcoutts: which would you prefer a contradiction error or install-all? maybe it could error by default or disregard the fact that build-dep'ing A and B is essentially build-dep'ing A and installing B by providing -f?
15:54:04 <Saizan> dschoepe: i think it'd make sense to make the D.S.Haddock code support both --html and --hoogle at once like in the patch i mentioned, so that the .txt will be present in the dist/ alongside the html
15:54:31 <dcoutts> chrisdone: I suggest the simplest thing to do to start with is to fail in that situation
15:54:32 <Saizan> dschoepe: what's your plan on what should then be done with the .txt?
15:54:50 <dschoepe> Saizan: Converting it to a .hoo and putting it in some user-specified directory
15:54:51 <dcoutts> chrisdone: do you have a use case yourself btw? would it matter for your use case?
15:55:09 <jbapple> dcoutts: Does that mean that bugs 674 and 330 are WONTFIX?
15:55:41 <dcoutts> jbapple: no, but it might mean it has to wait until we add tracking of installed files in cabal-install.
15:56:21 <jbapple> dcoutts: I see.
15:56:33 <dcoutts> jbapple: or a reconsideration of what auxiliary info we keep in the ghc-pkg database
15:57:41 <chrisdone> dcoutts: i agree. thinking about it, i'm not sure i'd ever personally want to build-dep more than one package. my use case is specifically: i've downloaded a package and i want to run "cabal build-dep && cabal build", or more often, i'm using cabal as a build environment but not as an install environment for a project. i want to tell users of my software "cd $project; cabal build-dep"
15:57:44 <jbapple> dcoutts: Is ghc-pkg going to start keeping track of test info for the GSOC cabal test project
15:57:46 <dschoepe> Saizan, dcoutts: I think I managed to convince haddock to put the file somewhere I know, thanks for your help.
15:58:19 <dcoutts> jbapple: no I think the test stuff will need any extensions to what ghc-pkg tracks.
15:58:27 <Saizan> dschoepe: i see, i guess we could let cabal install the .txt together with the html, so that cabal-install can just look at the InstalledPackageInfo's haddock-html field and do the rest
15:58:37 <chrisdone> dcoutts: (well, i realise in that case i'm using it to install dependencies, but not to install my own project as it doesn't make sense to install a lot of Executable projects)
15:58:40 <Saizan> dschoepe: ah, ok :)
15:59:15 <Saizan> dschoepe: still, it'd probably be quite wasteful to run haddock twice if we can avoid it
15:59:30 <dcoutts> chrisdone: right, so it probably does not matter in practice. So go with the simple option of failing.
15:59:33 <dschoepe> Saizan: imo, it would be handy to be able to put those files all together in one directory, so that one can use "hoogle --i=..." to search all installed packages
15:59:45 <dschoepe> Saizan: Yes, I'll try to find a way around it with the patch you mentioned
15:59:58 <Saizan> dschoepe: yeah, you should still do that
16:00:00 <dcoutts> dschoepe: I'd go the other way and make cabal update the hoogle db, like it does for the haddock index
16:00:23 <dcoutts> dschoepe: at least that's worth considering if updating it is relatively quick
16:00:42 <dschoepe> dcoutts: the comments in the bug report seem to suggest that it
16:00:51 <dschoepe> 's not clear what the default for hoogle searches should be
16:00:56 <dschoepe> http://hackage.haskell.org/trac/hackage/ticket/402
16:01:25 <T_S_> Is there a straightforward way to override an instance of Show for an installed package. I have Data.Vector.Vector in mind.
16:01:33 <dschoepe> so throwing them all together in one file would make it harder to search only in e.g. the base packages
16:01:44 <dcoutts> jbapple: sorry, I mean I think the test stuff will *not* need any extensions to what ghc-pkg tracks. [I'm dropping crucial words again :-)]
16:02:11 <jbapple> dcoutts: My brain seems to have already inserted that word for you :-)
16:02:16 <dcoutts> :-)
16:02:17 <chrisdone> T_S_: the most straight-forward way is to use newtype and derive it
16:02:19 <Saizan> T_S_: you can newtype it and give your instance for the newtype
16:03:01 <T_S_> cheers
16:03:31 <dcoutts> jbapple: there's a certain tension between wanting lots of information about what is installed and making it easy to construct an environment and have the tools work.
16:04:03 <chrisdone> dcoutts: would you accept a "build-dep" patch or would you prefer "--only-dependencies"?
16:04:35 <dcoutts> jbapple: in particular for executables, it's nice if all you have to do to install a program is have the binary file on the path and not have to add a lot of registration information before the tools will recognise its existence.
16:04:46 <dcoutts> chrisdone: I'd prefer the flag
16:05:27 * hackagebot text-json-qq 0.1 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.1 (OscarFinnsson)
16:11:30 <dschoepe> Is this expected behaviour for hoogle? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26349#a26349
16:14:44 <stepkut> I am experiencing a weird space leak, and I am not sure how to proceed.. this is my code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26350
16:15:28 <stepkut> in 'big', if I simply ignore the 'e' value, the leak goes away. Or in 'splitParts' if I don't check if 's' in null, the leak goes away..
16:15:38 <stepkut> neither of those things make sense to me though
16:17:07 <Saizan> the latter might be because it fuses better without the check
16:17:32 <Saizan> for the former i'd try switching the let into a case expression, in big
16:17:52 * Saizan is wildly speculating
16:17:55 <jbapple> dcoutts: That last paragraph you added on http://hackage.haskell.org/trac/hackage/ticket/674#comment:2 really clarifies the issue.
16:17:57 <jbapple> Thanks
16:17:59 <danharaj> You know, the prevalence of monkey patching tells me that OOP is a failed paradigm.
16:18:13 <danharaj> Because monkey patching basically destroys every concept of OOP.
16:19:21 <dcoutts> jbapple: in the mean time, cabal info ought to mostly work in the usual cases, even with docs that are not haddock docs.
16:19:50 <jbapple> dcoutts: I don't understand what you mean.
16:20:14 <dcoutts> jbapple: as for your problem with --enable-documentation, that should work fine, though note that by default it only generated haddock docs for libs not exes.
16:20:35 <jbapple> dcoutts: Do you mean using the idea you explained before, about manually specifying extra installation instructions for extra docs in Setup.hs?
16:21:02 <dcoutts> jbapple: I mean the cabal info thing where it shows the location of the installed documentation. Even though it's somewhat specific to haddock html documentation it will happen to work for other html documentation installed in the same place.
16:21:10 <stepkut> Saizan: let -> case may have done the trick.. how annoying :)
16:21:33 * stepkut wonders if Agda has space leaks too
16:21:41 <dcoutts> jbapple: oh there's that too, that's how you would go about installing other documentation like man pages or html user guides / tutorials etc.
16:21:45 <chrisdone> dcoutts: just so you get the use case: http://github.com/chrisdone/haskell-json my little download and build bit would be complemented nicely with a step to install deps first
16:22:46 <jbapple> dcoutts: Yes, I don't plan on learning more Setup.hs details to get the docs installed in the haddock dir. It just doesn't seem like the time tradeoff is worth it
16:22:58 <dcoutts> jbapple: for example lhs2tex installs a man page using custom code in Setup.hs, it calls a function from the Cabal lib to work out where the target man dir is. The same function can be used to find other kinds of install location including general or html documentation.
16:23:34 <jbapple> dcoutts: well, maybe if I can just copy someone else's hard work, it might be worth it
16:23:44 <dcoutts> jbapple: right, it's not easy. Ticket #330 covers design ideas for a scheme that'd cover the easy cases with less effort on the part of users.
16:24:02 <dcoutts>  /users/package authors/
16:24:42 <Saizan> stepkut: unpacking tuples with let is known to be a potential cause of unwanted retaining, so you were probably keeping the whole p in memory until you forced e to whnf
16:25:22 <stepkut> Saizan: known to some :)
16:25:43 <stepkut> Saizan: this could be trouble though :-/ Because people using this API probably won't know that 
16:25:50 * mauke is now known as stepknuth
16:26:04 <Saizan> stepkut: ah, yeah, i had a post by Simon Marlow in mind ;)
16:27:10 <stepkut> Saizan: and, unfortunately, the real code still has the issue even though it fixed the test version :(
16:27:49 <Saizan> compiling with -O2, right?
16:27:55 <stepkut> yeah
16:29:20 <stepkut> not really sure how to figure out what is actually holding on the data now
16:29:49 <Saizan> retainer profiling should help, but i've never done it
16:30:09 <stepkut> yeah, they say that.. but the output is meaningless to me
16:30:36 * hackagebot bird 0.0.1 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.1 (MattParker)
17:36:07 <OscarZ> Common imperative languages such as C++, Java, etc base their syntax on the implementation of CPU (or a Turing machine?). What about Haskell? What is it "based on" following this analogy? 
17:36:23 <c_wraith> Lambda Calculus
17:36:54 <c_wraith> See the Church-Turing thesis proving that lambda calculus is equivalent to Turing machines.
17:37:57 <ddarius> How many lambda calculus interpreters are there in Brainfuck?
17:38:07 <gwern> too many
17:38:22 <roconnor> @hoogle a  -> [a] -> Bool
17:38:23 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
17:38:23 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
17:38:23 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
17:38:46 <ddarius> @hoogle a -> [a] -> Maybe a
17:38:47 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
17:38:47 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
17:38:47 <lambdabot> Prelude asTypeOf :: a -> a -> a
17:39:10 <Veinor> gwern: even 1 is too many
17:39:17 <aristid> parsec is very nice to use \o/
17:39:36 <OscarZ> Why is that people find it easier to learn imperative programming vs functional ? 
17:39:49 <ddarius> OscarZ: What makes you think that that's true?
17:39:55 <OscarZ> Or is it just me since I've learned imperative first ;) 
17:39:59 <c_wraith> I'm not sure it is easier.  It's just different, and most people start with imperative languages.
17:40:08 <Zao> It's simpler to get useful stuff done?
17:40:41 <dolio> Depends what you think is useful.
17:40:51 <OscarZ> Yeah, it's a good question.. someone who is fluent in math should find the Haskell syntax intuitive?
17:40:51 <ddarius> Zao: Many people have started with C (though it is much less common nowadays.)  Binary trees of various sorts, as well as lists, are extremely useful.  Implement each in C and in Haskell.
17:40:54 <Rotaerk> to achieve side effects, which is kind of necessary for something to be a program, in a purely functional language, you have to use some rather contrived mechanisms to do so
17:40:56 <aristid> c_wraith: you can quickly get to a painful level of abstraction in haskell, so maybe its perceived difficulty is higher
17:41:08 <OscarZ> (im someone whos not ;-) 
17:41:59 <heatsink> Becoming fluent in Haskell helped me understand math syntax
17:42:00 <Rotaerk> and side effects are the first things new programmers want to see
17:42:44 <lispy_> Rotaerk: what contrived mechanisms do you have to use?  Monads seem to be enough
17:42:53 <OscarZ> heatsink: how did you learn it ?
17:43:11 <ddarius> Rotaerk: Output is what they want to see, not side-effects.  Furthermore, to a first approximation, the syntax for "imperative" code in Haskell and in C, say, is pretty similar.
17:43:49 <heatsink> Rotaerk: #include <stdio.h> is a pretty contrived system, but it's a long time between learning to type that and learning how it actually works (via CPP and linking)
17:43:49 <c_wraith> You know, if you'd *never* heard the word "monad", and were just taught how to use IO, haskell's not very tough to learn, I think.
17:44:15 <aristid> ddarius: i think it's funny that "side-" has become a part of "effects".
17:44:20 <heatsink> Rotaerk: Similarly, I think it should be possible to start out using do-notation to achieve useful results without understanding how it really works
17:44:28 <Rotaerk> lispy_, using monads as a mechanism for side effects is fairly contrived; they're not easy to grasp for beginners, though I guess if you teach  it to them as magical syntax without explaining the concepts... then it might be easier to pick up
17:44:29 <aristid> programs don't have effects anymore, they have side-effects :>
17:44:33 <heatsink> OscarZ: Online tutorials and asking questions in this chanel
17:44:52 <ddarius> Rotaerk: That's all you are doing for an imperative language essentially.
17:45:02 <lispy_> Rotaerk: I'll go look up contrived, I may be misunderstanding that word
17:45:10 <ddarius> @wn contrived
17:45:12 <lambdabot> *** "contrived" wn "WordNet (r) 2.0"
17:45:12 <lambdabot> contrived
17:45:12 <lambdabot>      adj 1: showing effects of planning or manipulation; "a novel with a
17:45:12 <lambdabot>             contrived ending"
17:45:13 <lambdabot>      2: artificially formal; "that artificial humility that her
17:45:14 <lambdabot> [4 @more lines]
17:45:39 <Rotaerk> lispy_, "they're not easy to grasp for beginners" wasn't an explanation for why they're contrived
17:45:44 <danharaj> Rotaerk: It is not contrived. It is very natural.
17:46:33 <lispy_> Monads do show the effects of planning
17:47:06 <Gracenotes> hm. map NewtypeConstructor should be a no-op, right?
17:47:07 <heatsink> They're a plan-and-effect system?
17:47:28 <ddarius> Gracenotes: It gets converted, at some point, to map id.
17:47:28 <heatsink> Gracenotes: I don't think so
17:47:35 <Gracenotes> just extra syntax :/
17:47:40 <ddarius> Which then may or may not be optimized.
17:47:55 <heatsink> Let me check
17:49:29 <Gracenotes> they are stripped sometime (after typeclass-dictionary-work in core), never looked at where
17:49:33 <Rotaerk> danharaj, it is more natural to think of I/O as behavior... to be described as instructions, I think
17:49:36 <dolio> It won't get turned into 'map id' exactly, though, most likely.
17:49:52 <Rotaerk> the imperative model caters best to the natural way of thinking about computers: as machines that *do* I/O
17:49:53 <heatsink> It's still 'map' in the output of -ddump-simpl
17:50:02 <heatsink> GHC Core doesn't get rid of newtype wrappers
17:50:04 <Gracenotes> honestly, I personally wouldn't be worried about that so much as their verbosity, except when said verbosity can be stowed away in monad instances etc.
17:50:31 <danharaj> Rotaerk: I disagree, I think IO is naturally described as a series of actions where later actions can depend on earlier actions. >>= naturally expresses this dependency.
17:50:45 <dolio> I'm not sure if GHC's rewrite rules let you write 'map (\x -> x) = id'. And it's probably optimistic to think it'll get to that point.
17:51:21 <OscarZ> why is that the concept of Monad is so important in programming ? 
17:51:29 <ddarius> OscarZ: It isn't.
17:51:42 <Rotaerk> it is in haskell but not necessarily in programming-in-general
17:52:00 <ddarius> Rotaerk: Haskell existed without monads.
17:52:13 <heatsink> What comes before cmm in GHC?
17:52:25 <Gracenotes> stg
17:52:31 <Rotaerk> ddarius, that was a different haskell
17:53:08 <dolio> It wasn't that different.
17:53:19 <OscarZ> Monads do not have direct counterpart in OO, for example Java ?
17:53:22 <HugoDaniel> haskell is actually a monad
17:53:23 <gilgamesh> hey guyshey guys... i am new to haskell, and am trying to understand what is wrong with the following code http://pastebin.com/z0pSvBZY
17:53:24 <HugoDaniel> Haskell a
17:53:38 <ddarius> OscarZ: The counterpart of monads in Java is monads.
17:53:41 <gilgamesh> can anyone have a look and give me some help?
17:53:57 <gwern> @quote Neo
17:53:57 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
17:54:07 <heatsink> Gracenotes: 'map' is still hanging around in STG, so I don't think it'll get optimized out.
17:54:37 <Gracenotes> ah. maybe if you slipped in an optimization flag.. funboxing probably wouldn't hurt either
17:54:54 <heatsink> Using -O2, will try unboxing
17:54:54 <OscarZ> ddarius: ok.. i understand that monads are just a "design pattern" in Haskell too 
17:55:51 <heatsink> O2 and unbox-strict-fields don't get rid of it
17:55:54 <ddarius> OscarZ: No.  They are not a "design pattern."
17:56:16 <Rotaerk> they're not?
17:56:24 <stepkut> gilgamesh: several things: you don't need the 'do', you are missing an 'else' on the mod x 1000 line, and your function returns integers sometimes, but then tries to return a string (show (x)), as well..
17:56:50 <Rotaerk> "a design pattern is a general reusable solution to a commonly occurring problem in software design"
17:56:54 <Rotaerk> I'd say monads fit that description
17:56:59 <gilgamesh> stepkut: thing is, i want both ifs to be evaluated...
17:57:02 <ddarius> Rotaerk: So does -everything-.
17:57:08 <Rotaerk> nope
17:57:23 <ddarius> Rotaerk: Is IEnumerable a design pattern?
17:57:32 <gilgamesh> stepkut: i plan to give a high value to that function, but i want it to print every time it executes 1 thousand times so i know it is progressing
17:57:43 <gwern> trace
17:57:54 <Rotaerk> nope, but it's an implementation of the iterator design pattern
17:58:02 <stepkut> gilgamesh: ah
17:58:15 <Gracenotes> for some reason I thought GHC had more of a focus on reducing the (rather minor) performance hit of newtypes
17:58:27 <lispy_> the Monad class is an implementation of the abstraction design pattern 
17:58:38 <pastorn>  gilgamesh then you need to do IO
17:58:39 <Gracenotes> but anyway, it's not the only abstraction you pay for, and you don't pay much anyway
17:59:01 <lispy_> Gracenotes: Well, the wrapper of the newtype doesn't exist at run-time.
17:59:07 <Rotaerk> "abstraction" isn't a design pattern; it's a concept that's ubiquitous in all software design
17:59:12 <gilgamesh> pastorn: sorry if the question is dumb... but how so?
17:59:20 <lispy_> Gracenotes: but if you associate a dictionary with that newtype that dictionary may still exist
17:59:23 <pastorn> gilgamesh: in haskell, printing stuff is considered naughty, so you can't do that from inside that function
17:59:31 <Rotaerk> Monad class is an implementation of the monad design pattern
17:59:36 <heatsink> Gracenotes: The relevant optimizations are performed in Core; however Core is strongly typed, which requires newtype wrappers to stay there 
17:59:42 <gilgamesh> oh :\ 
17:59:54 <pastorn> gilgamesh: you can think of all functions that needs to go *outside* of the programs memory space as naughty (if that helps)
18:00:01 <Gracenotes> lispy_: if newtypes exist to select instances, then wrapping and unwrapping e.g. a list should be painless methinks
18:00:10 <pastorn> gilgamesh: or you can see it as functions that needs to communicate with the OS
18:00:30 <pastorn> gilgamesh: because we can't trust the OS, everything we do with it gets tainted
18:00:36 <gilgamesh> well, what if i wanted it to do something else other than printing to the screen?
18:00:44 <Gracenotes> though, they can also exist to put an instance-able type on a more complicated type expression
18:00:54 <gilgamesh> i mean, i need 2 ifs to be executed but one cannot be else to another
18:01:01 <dolio> Gracenotes: Even in the core, where newtype constructors don't exist as such (I think), you have explicit coercions between equal types. And I think rewrite rules fire before that stage, even.
18:01:01 <pastorn> gilgamesh: first of all, you have two different return types :(
18:01:08 <lispy_> Rotaerk: the reason it's weird to talk about the monad design pattern is because monads are a structure that originated in category theory.  Category theory is not concerned with design patterns, software engineering, or even computability
18:01:10 * hackagebot heist 0.2.2 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.2.2 (DougBeardsley)
18:01:12 <stepkut> gilgamesh: http://pastebin.com/jz2F2PbR
18:01:15 <gilgamesh> pastorn: yeah i am now considering the same return type
18:01:24 <pastorn> gilgamesh: "considering"
18:01:33 <pastorn> your function won't load unless you have that :p
18:01:44 <gilgamesh> stepkut: that looks nice
18:01:50 <dolio> And 'map id => id' would only happen due to a rewrite rule.
18:01:51 <gwern> pastorn: if there are no limits to our distrust of the OS, we may be screwed. but if we assume limits on how 'noisy' OS operations are, we can get around it
18:01:52 <Rotaerk> lispy_, I understand; but in application to software, it's a design pattern that originated from category theory
18:01:54 <gilgamesh> pastorn: no no... i mean
18:02:08 <gilgamesh> pastorn: change that show(x) to 20 for example
18:02:17 <gwern> pastorn: like that lambda calculus which compiled down to running on unreliable hardware I saw on LtU
18:02:18 <Rotaerk> I mean, other design patterns originated from somewhere too
18:02:19 <pastorn> yes, then it should load :)
18:02:24 <heatsink> map MyNewTypeConstructor => unsafeCoerce#
18:02:26 <Rotaerk> doesn't mean they aren't patterns for design
18:02:34 <gilgamesh> pastorn: it doesn't :(
18:02:43 <lispy_> Rotaerk: so what is the monad design pattern?
18:02:47 <gilgamesh> test.hs:5:1: parse error (possibly incorrect indentation)
18:02:50 <applicative> Axman6, ping
18:02:55 <gilgamesh> that is what i get from ghci
18:03:06 <stepkut> gilgamesh: I guess.. it's not a very haskelly way to do things
18:03:11 <pastorn> gwern: don't mess with the n00bz heads now... saying that stuff that comes/goes to the OS is tainted is a pretty good explanation of which functions that are IO
18:03:14 <Rotaerk> lispy_, http://en.wikipedia.org/wiki/Monad_(functional_programming)
18:03:31 <gilgamesh> stepkut: oh :| it is pretty new stuff to me... am only used to C :)
18:03:31 <pastorn> gilgamesh: have you seen guards?
18:03:33 <Gracenotes> Rotaerk: I'd consider design patterns to be abstractions which exist outside of the language. monads are in-language abstractions, so I'd just call them 'abstractions'
18:03:39 <gilgamesh> pastorn: not yet
18:03:40 <dolio> "Monad" is not the design pattern.
18:03:40 <gwern> pastorn: if their heads do no explode a few times, they are being ill-served
18:03:50 <dolio> "Domain specific embedded language" is the design pattern.
18:04:04 <gilgamesh> guys i am so sorry... i need to leave for some minutes... girl wants to go out to grab something to eat... i will bbiab
18:04:13 <gilgamesh> tks for the time and explanations stepkut and pastorn 
18:04:19 <Rotaerk> Gracenotes, so you're suggesting a definition of "design pattern" that makes it applicable on a language-by-language basis
18:04:20 <pastorn> gwern: fine... but you provedid gilgamesh with no good answer about it, so my, according to you, insufficient answer had to do :p
18:04:21 <Gracenotes> though this isn't always a good dichotomy
18:04:24 <gilgamesh> i will bother some more later ;)
18:04:25 <lispy_> Rotaerk: I searched for 'design' and 'pattern' but I'm not seeing it defined there.  What is the definition you had in mind?
18:04:26 <dolio> It just happens that many DSELs are like algebraic theories, and monads are a way of talking about algebraic theories.
18:04:38 <Rotaerk> Gracenotes, so in the context of haskell it's just a language feature, whereas in, say, C# it'd be a design pattern
18:04:39 <Gracenotes> Rotaerk: I am a design pattern relativist, you might say
18:04:40 <aristid> @src findIndex
18:04:40 <lambdabot> findIndex p     = listToMaybe . findIndices p
18:04:48 <aristid> @src findIndices
18:04:49 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
18:04:49 <gwern> pastorn: gilgamesh asked me no question, and I found your statement more interesting
18:04:54 <Gracenotes> Rotaerk: yeah. more direct example - command pattern
18:04:59 <gwern> pastorn: running on satan's computer is an interesting problem
18:05:28 <Rotaerk> lispy_, http://en.wikipedia.org/wiki/Design_pattern_(computer_science)
18:05:44 <Gracenotes> nobody bats an eye about a list of functions here, or a list of data structures containing functions. in C# or Java, you have to make a bit more of a production about it..
18:05:49 <heatsink> The point of documenting design patterns is that they are not part of a language.  Design patterns get attention because they're reinvented.  If you can program an entire design pattern once and for all, the pattern ceases to become useful.
18:05:59 <Rotaerk> Gracenotes, true
18:06:08 <lispy_> Rotaerk: I mean, the definition of the monad design pattern that you had in mind
18:06:10 <heatsink> Because you can just write a library and use it.
18:06:37 <lispy_> In software engineering, a design pattern is a general reusable solution to a commonly occurring problem in software design. A design pattern is not a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.
18:06:54 <lispy_> So, the wikipedia def'n seems to capture the "outside of the language" bit
18:07:00 * ddarius thinks that Christopher Alexander avoids reading most of what is written about "design patterns" in the programming community.
18:07:58 <Rotaerk> I'd still call iterator a design pattern, even if I'm using C#; it's just that the language itself already implements that design pattern so I don't have to do so manually
18:07:58 <heatsink> "A design pattern is not a finished design that can be transformed directly into code."
18:08:04 <Gracenotes> though design patterns can carry across language barriers
18:08:13 <pastorn> gilgamesh: i'm rewriting your function in a more haskell-y way :)
18:08:24 <heatsink> That's why design patterns that _have_ implementations as code irritate me.
18:08:35 <heatsink> They should stop being design patterns at that point.
18:08:36 <gwern> ddarius: as an architect, he probably should
18:09:00 <Rotaerk> singleton is also considered a design pattern
18:09:00 <Rotaerk> but C# static classes are effectively singletons
18:09:28 <Rotaerk> singleton would be the design pattern, implemented by the language feature "static class"
18:09:36 <lispy_> The only def'n of 'monad design pattern' that I can think of is: The process of looking for monad structure within a design and building/use an instance of the Monad class based on that structure.
18:09:53 <lispy_> monadic*
18:10:51 <Gracenotes> I recall some argument that static classes are not the same as singletons (global instance vs. single instance).. not sure if I care that much
18:11:48 <stepkut> gilgamesh: a more haskellish approach, http://pastebin.com/qEAUEKxW
18:11:56 <danharaj> "design pattern" is the oop buzzword for abstraction.
18:12:18 <Rotaerk> lispy_, a wrapper type along with a natural *policy* for transforming instances of that wrapper type into others, fits the *pattern* known as monad
18:12:24 <lispy_> danharaj: I don't think that's fair.
18:12:34 <danharaj> lispy_: Why not?
18:12:40 <Gracenotes> they certainly work in architecture
18:12:48 <lispy_> danharaj: A design pattern is part of the design process not part of the finished program.
18:12:48 <Gracenotes> and I don't think you can claim architecture is that abstract
18:12:52 <dolio> danharaj: Because they have many buzzwords for abstraction. :)
18:13:04 <lispy_> danharaj: An abstraction presumably can existing in the final program
18:13:30 <lispy_> exist*
18:13:42 <edwardk> danharaj: design pattern is the oop buzzword for a reusable idiom that can't be factored away into a class and forgotten about ;)
18:13:48 <lispy_> Rotaerk: I don't think that's a monad though
18:13:54 <danharaj> lispy_: Let us define abstraction to be more precise, it is a nebulous word. When I say abstraction, I mean a structure that is satisfied by many concrete models. A concrete model is... well I hope concrete is more concrete a word than abstract :D
18:14:07 <ivanm> edwardk: and to cover up deficiencies in the language in question, right?
18:14:09 <Rotaerk> a design pattern tends to be something that's so abstract that it addresses domain-agnostic abstractions
18:14:15 <Rotaerk> lispy_, howso?
18:14:16 <edwardk> ivanm: basically, yes ;)
18:14:33 <ivanm> danharaj: lol
18:14:43 <danharaj> I always set up for a cheesy pun.
18:15:01 <ivanm> danharaj: OK, how was that statement a setup for a cheesy pun?
18:15:06 <Gracenotes> OOP languages have built-in abstractions. it's just that said abstractions tend to be insufficient (dynamic dispatch through inheritance is meh), prompting piles of other abstractions called design patterns
18:15:26 <LurkingBM> ivanm: Thick concrete!
18:15:27 <lispy_> Rotaerk: I think you gave some operational requirements of monads as implemented in haskell, but I don't think your description captures their essence as defined in terms of cat. theory
18:15:28 <danharaj> ivanm: I used the word concrete in more than one way for humorous effect, IMO that is punny.
18:15:34 * LurkingBM goes back to lurking...
18:15:51 <ivanm> Gracenotes: right; those kinds of languages need some kind way of communicating wtf you're doing because the code is full of auto-generated verbose mess and is hard to read
18:15:53 <lispy_> Rotaerk: for all I know, you described functors
18:15:58 <pastorn> x `f` y z <-- this is not valid haskell, right?
18:16:00 <edwardk> Rotaerk: actually a static class and a singleton are different beasts, usually a singleton is implemented with the double check locking pattern to construct the singleton on first demand, even though c++ has the same machinery to render a class uninstantiable
18:16:14 <ivanm> danharaj: no, you said you _always_ set up for a cheesy pun, so how is your statement saying that a setup for a cheesy pun?
18:16:27 <edwardk> Rotaerk: a static class can be viewed as a particular instance of the singleton idiom/design pattern, but does not subsume it
18:16:29 <Philonous> pastorn: It is, but it means f x (y z)
18:16:34 <danharaj> ivanm: I don't claim to be a consistent theory ;p
18:16:45 <Rotaerk> edwardk, static classes in C# are constructed on demand
18:16:49 <ivanm> danharaj: heh, fair enough
18:17:00 <danharaj> "I always set up for a cheesy pun" is my Goedel sentence.
18:17:09 <lispy_> So, the WP def'n of design pattern makes me think that the term applies during the design process not during the code writing process.
18:17:16 <danharaj> Don't make me derive peano arithmetic in puns to establish the applicaiblity of incompleteness.
18:17:16 <Rotaerk> lispy_, I don't know or care about the definition within category theory; it's not just "haskell monads" and "category theory monads"; there's also "functional programming monads"
18:17:17 <Gracenotes> danharaj: too bad, I like consistency in a man
18:17:22 <Gracenotes> :P
18:17:29 <lispy_> design patterns are about designing, not about code that has been written
18:17:32 <ivanm> danharaj: go on
18:17:50 <danharaj> Design patterns are encodings of ideas into OOP
18:18:05 <Rotaerk> I don't think "design pattern" is OOP-specific
18:18:19 <pastorn> gilgamesh: http://pastebin.com/pMxWqEUx
18:18:20 <Rotaerk> there are "OOP design patterns" and "FP design patterns"
18:18:21 <ivanm> danharaj: so, would our analagous encoding be type sigs?
18:18:21 <Gracenotes> danharaj: s/encodings/shoehornings/
18:18:23 <danharaj> Rotaerk: I have only heard OOPeople use 'design pattern'.
18:18:23 <Rotaerk> and whatnot
18:18:30 <lispy_> I don't even think it's software specific.  It seems to apply to design processes
18:18:40 <Gracenotes> ooh. I like that definition. "Design patterns are shoehorning of ideas into OOP"
18:18:42 <LurkingBM> danharaj: Don't you mean that it's your Gouda sentence? ;)
18:18:43 * Gracenotes might use it
18:18:45 <Rotaerk> danharaj, doesn't mean the concept isn't abstract enough to extend beyond the domain of OOP
18:18:53 <danharaj> LurkingBM++
18:18:53 <Gracenotes> LurkingBM: 3 points
18:19:05 <ivanm> LurkingBM: mmmmmm..... Gouda.....
18:19:16 <ivanm> haven't had any gouda for a while...
18:19:17 <aristid> what's the default operator precedence?
18:19:33 <ddarius> A design pattern is merely an element of a pattern language used to concisely express (usually somewhat ambiguously) parts of design.
18:19:47 * LurkingBM goes back to lurking...
18:19:47 <stepkut> pastorn: did you see, http://pastebin.com/qEAUEKxW
18:19:53 <edwardk> rotaerk: static classes contain static members, cannot be instantiated and are sealed. you have a static constructor, but with a static constructor (which is also provided by c++) you get no control over the time that the static constructor gets invoked. if you have a digraph of singletons in the usual idiom, you can be sure they invoke each other in dependency order, and that you can do other environmental set up be
18:19:53 <danharaj> Rotaerk: You think monad is a design pattern, right?
18:19:54 <ivanm> Rotaerk: the concept of pointer arithmentic is abstract enough to extend beyond C, but I don't see much use for it in Haskell
18:20:04 <ivanm> except for possibly some low-level implementation of data structures
18:20:08 <lispy_> Rotaerk: When I talk about monads, I too would like to not care about the specific language or implementation.  That leads me to think about them more abstractly and in an idealized sense.  This is what mathematics is about.  So, it seems like the category theory definition is what we should care about and then we should know how to fit that into the languages we use
18:20:14 <danharaj> ivanm: Pointers are just random access iterators of arrays!
18:20:16 <pastorn> stepkut: || is for psusies
18:20:26 <pastorn> wat is this? walls of text in my #haskell?
18:20:36 <danharaj> yeah, maybe this should go to overflow or blah.
18:20:38 <ivanm> pastorn: except it isn't _your_ #haskell
18:20:43 <pastorn> :(
18:20:44 <Rotaerk> whoa, wall of red
18:20:48 <edwardk> Rotaerk: with static classes in c# you don't get the ability to defer until you've resolved things like arguments before you kickstart the dominos falling. but this is definitely moved into #haskell-blah territory
18:20:53 <ivanm> pastorn: it's dons'
18:21:32 <ivanm> stepkut: I think it would be nicer to pattern match on x == 2 rather than use a guard
18:21:43 <ivanm> also, the normal Haskell convention is camelCase, not underscores
18:23:33 <Veinor> yeah, underscores aren't used much (if at all) in haskell identifiers
18:24:39 <stepkut> ivanm: yeah, camelCase is more normal, I just copied what was there.. not sure if mixing pattern matching and guards really improves things..
18:24:41 <monochrom> I use underscores. It is more consistent. "work" and "moreWork" are just wrong.
18:25:29 <monochrom> or "print" and "hPrint"
18:25:41 <lispy_> Our editors should just show it to use the way we like to see it :)
18:26:00 <stepkut> I like to use random unicode symbols instead of underscores :p
18:26:04 <lispy_> monochrom: so you prefer h_print?
18:26:12 <ivanm> lispy_: emacs has a mode to do that... (goggles or something IIRC)
18:26:21 <ivanm> however, how should it be saved for the actual API?
18:26:30 <monochrom> hprint and more_work
18:26:39 <danharaj> I want a case insensitive language
18:26:41 <Gracenotes> I think the inconsistency of camel case is worth taking, so long as your code doesn't look like it's been ravaged by a vicious army of underscore mongols
18:26:44 <ddarius> ivanm: Talk to Peaker (or many, many others...)
18:26:45 <lispy_> monochrom: isn't that inconsistent too?
18:26:48 <danharaj> that warns you when you use inconsistent cases
18:26:48 <monochrom> but h_print is good too
18:26:58 * ddarius retches on h_print.
18:27:03 <ivanm> danharaj: that is slightly contradictory IMHO
18:27:22 <ivanm> danharaj: and I like the obviousness of Haskell: if it starts with a capital it's either a data type, a constructor or a type class
18:27:23 <danharaj> ivanm: Well the compiler wouldn't warn you, the ide would.
18:27:27 <Gracenotes> except in C. underscores are tolerable in C.
18:27:30 <ivanm> danharaj: ugh
18:27:34 * ddarius very distinctly wants case-sensitivity.
18:27:47 <ivanm> Gracenotes: why?
18:27:59 <monochrom> I also like h'print and more'work
18:28:10 <danharaj> ddarius: WhY wOUld YOu? ArE YOU PaRSiNG THIs COrRectL?
18:28:10 <Gracenotes> I can handle them being used for namespacing
18:28:17 <ivanm> monochrom: well, that makes _me_ retch
18:28:35 <ddarius> danharaj: ESPELLING
18:28:35 <ivanm> danharaj: that's a matter of someone being an idiot
18:28:41 <lispy_> what'about_mixingEverything
18:28:48 <danharaj> heh
18:28:50 <ivanm> @slap lispy_ 
18:28:50 <lambdabot> *SMACK*, *SLAM*, take that lispy_ !
18:28:53 * ddarius like ord'x'.
18:29:03 <ddarius> +s
18:29:05 <monochrom> wellCamelCaseMakesMeRetch
18:29:07 <Gracenotes> that's a valid haskell identifier
18:29:58 <lispy_> > let what'about_mixingEverything = 1; ord'x' x = (<) x in ord'x' 2 what'about_mixingEverything
18:29:59 <lambdabot>   False
18:30:16 <aristid> the Maybe monad buys me fun.
18:30:21 <lispy_> > fix error
18:30:22 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:30:25 <aristid> except when it doesn't
18:30:44 <Gracenotes> @quote o_o
18:30:45 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
18:30:57 <Gracenotes> hm.
18:31:05 <lispy_> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
18:31:06 <lambdabot>   [[0.0]]
18:31:12 <lispy_> That's awesome
18:32:01 <aristid> ooh
18:32:04 <aristid> evil Monoid
18:32:12 <aristid> the Monoid instance for Maybe is evil
18:32:41 <aristid> well well, is there something like foldMap except for MonadPlus (i know about msum . map)
18:32:41 <Gracenotes> I've found it useful. though usually you want First/Last.. or want it to be more general..
18:33:04 <aristid> Alternative would be fine too
18:33:47 <Lycurgus> are you just generally peevish monochrom or is there some reason why you dislike CamelCase?
18:33:54 <pokoko222> i know this is not the right place but some of you guys knows Microsoft Project? I have some questions, and there are no chanels or good forums on the Project.
18:33:58 <Lycurgus> do you hate Smalltalk for instance?
18:34:26 <monochrom> I already said what's wrong with camelCase. Please read.
18:35:00 <Lycurgus> i c, "just wrong"
18:35:02 <ddarius> pokoko222: This place nevertheless remains not the right place.
18:35:18 <Gracenotes> hobgoblin of little minds etc.
18:35:22 <ivanm> Lycurgus: and he thinks camelCase is less consistent
18:35:46 <Gracenotes> though I suppose no consistency is too foolish when it comes to programming language syntax, amirite
18:35:51 <stepkut> pokoko222: #haskell-blah maybe ?
18:36:09 * Lycurgus chases hobgoblins in #haskell.
18:36:16 <gwern> Gracenotes: if we believed that, we'd all program in a syntactically pure lisp
18:36:33 <bremner> "Syntax is the Viet Nam of programming languages"
18:36:40 <bremner> from a lisp book :)
18:36:44 <ddarius> gwern: Why not something like factor or Forth or Joy?
18:37:02 <gwern> ddarius: factor has a ton of syntax last I looked
18:38:04 <Lycurgus> my prior association of the hate of camelcase was an programming labor ad I saw where some little shop of horrors was lawing down the law on it
18:38:13 <Lycurgus> *a
18:38:26 <Lycurgus> *laying
18:38:34 <danharaj> I like lawing down the law
18:38:38 <danharaj> It sounds like a colorful idiom.
18:38:40 <Gracenotes> for the most part, the only special syntax in factor is whitespace, [], (), and :, afaik (as well as its quasiquoting stuff)
18:38:52 <lispy_> I'm all, lawing what?
18:39:07 <gwern> Gracenotes: look at all that syntax!
18:39:10 <danharaj> we should verb more nouns.
18:39:21 <Gracenotes> I forget if () counts or not
18:39:26 <gwern> all you need are atoms and one pair of delimiters
18:39:54 <ddarius> gwern: For the concrete syntax, and atoms aren't all that trivial in many Lisps.
18:40:10 <gwern> ddarius: hence my comment about 'syntactically pure'
18:40:12 <Gracenotes> anyhow, the core grammar is ridiculously small, and all the rest bootstraps on that. whereas in lisp, you don't do much bootstrapping, you just use the core grammar throughout your entire damn program
18:40:33 <ddarius> The abstract syntax of Lisp tends to be pretty involved, not particularly simpler than most abstract syntaxes.
18:41:29 <Gracenotes> still, look at MDL, now that was complicated
18:41:44 <ddarius> Whereas, for Joy, the abstract syntax really is just a list that may contain nested lists and no further restrictions.
18:41:46 <Gracenotes> I can barely read it
18:42:31 <danharaj> Turing machines have the simplest syntax
18:43:48 <monochrom> Gödel numbering in unary notation is simpler.
18:44:26 <monochrom> GU ::= λ | 1 GU
18:45:02 <Axman6> applicative: pong
18:45:13 <lispy_> monochrom: gets rid of the underscores vs. camelCase argument anyway ;)
18:45:29 <lispy_> I miss being able to use - as in lisp.  this-is-an-identifier
18:45:38 <applicative> Axman6, hey, check out my deprave new threadring....
18:45:48 <Axman6> ?
18:45:54 <Axman6> shootout?
18:45:58 <monochrom> yes, this-is-an-identifier is sweet
18:46:00 <applicative> Axman6, yeah
18:46:15 <applicative> Axman6, i feel i must be hallucinating.  See http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26356#a26356
18:46:24 <dolio> Better than the 10x speedup Axman6 made a couple days ago?
18:46:36 <applicative> dolio, its as fast as C
18:46:46 <dolio> Nice.
18:46:53 <applicative> dolio, but evidently it cheats in the same way....
18:47:09 <applicative> i used the ghc to reduce it to C etc. as usual
18:48:10 <Axman6> heh
18:48:17 <applicative> You see my evil plan
18:48:43 <danharaj> wait you got it to be as fast as C?
18:48:56 <applicative> just barely less, it's completely sick
18:49:02 <danharaj> wicked.
18:49:04 <dolio> It requires unsafePerformIO?
18:49:11 <applicative> but i'm out of my depth, so i could be making some crazy mistake
18:49:11 <dolio> Is that to get the right C produced?
18:49:17 <applicative> dolio, yes
18:49:17 <danharaj> unsafeBeatC
18:50:11 <applicative> it's a little slower than the time for the C program posted, but I think it must have gone down to basically the same.   The two optimization passes got rid of the threading
18:50:19 <applicative> unless, again, im hallucinating
18:51:06 <applicative> i meant to add, it's a little slower than the C posted, but I am using a weaker machine.  
18:56:06 <danharaj> applicative: Are you going to submit that? I doubt it'll get accepted, but I'll laugh if it does :p
18:57:53 <danharaj> Which other benchmarks do you guys think we could really cut down time on?
18:58:00 <applicative> danharaj, what i really want to know is, whether the C program is in fact doing this.   Axman6 said it was cheating, but I only know a tiny bit of C.
18:58:23 <applicative> It'd be nice if I could get the GHC to write my C for me....
18:59:14 <cheater99> hi
18:59:26 <cheater99> is there a way to implement this point-free? maximum' (x:xs) = max x (maximum' xs)  
19:03:22 <applicative> @pl let maximum' (x:xs) = max x (maximum' xs) in maximum'
19:03:22 <lambdabot> fix ((`ap` tail) . (. head) . flip ((.) . max))
19:03:40 <applicative> cheater99, I dont think you wanted that. ...
19:04:18 <cheater99> i don't know
19:04:56 <applicative> Axman6, curses, sorry about the typesetting, heres the right way http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26357#a26357
19:05:13 <Axman6> ta
19:05:41 <applicative> they're kicking me out of the coffee house. ah well.
19:06:13 <cheater99> damn laptop users
19:06:17 <cheater99> ;-)
19:26:40 <ReinH> Any suggested Haskell oriented blogs for my feed reader?
19:27:02 <ddarius> planet.haskell.org
19:27:31 * BMeph "BOO-Yah!"'s from the side lines
19:28:07 <ddarius> The lurking black mephit strikes.
19:28:38 <ReinH> :)
19:28:38 <BMeph> dddarius: Strikes...out, maybe. :)
19:28:45 <ReinH> zing
19:28:55 <ReinH> Any of you folks doing the IFPC this weekend?
19:29:52 <BMeph> ReinH: Not I - seriously respecting the Task, though. =8*O
19:30:23 * BMeph auto-corrected to "ICFP" - go ahead and tell me if I'm wrong, though... ;)
19:30:40 <ReinH> BMeph: yes ICFP
19:31:05 <edwardk> ReinH: i'd wanted to, but i have a bunch of random obligations all weekend =/
19:31:18 <ReinH> My brain is stuck thinking that it's the "international functional programming challenge"
19:32:19 <ReinH> BMeph: we're using Haskell for it (and some other glue languages)
19:32:29 <ReinH> the task is certainly daunting
19:32:46 <ReinH> but we've managed to simulate circuits and even reverse-engineer them from a given output
19:36:48 <gwern> what's the ICFP task this year?
19:37:11 <aristid> gwern: http://icfpcontest.org/2010/task/
19:37:15 <aristid> it's evil:)
19:37:24 <ReinH> aristid: it sure is
19:37:33 <ReinH> I think we're going to make a good run at it
19:38:34 <gwern> it's... odd. what's it asking for really?
19:38:37 <gwern> I can't tell
19:38:56 <dolio> So, it's cryptology?
19:38:58 <aristid> gwern: it's like a matroshka of puzzles.
19:39:13 <aristid> and we only solved the first of the chain :/
19:39:32 <ReinH> aristid: which, the fuel prefix?
19:39:42 <aristid> ReinH: no, not even that.
19:39:45 <ReinH> aristid: ah
19:39:48 <aristid> we figured out the circuit syntax :D
19:39:50 <edwardk> gwern: you set up cars (NP-like problems) with known existent fuel (P solutions)
19:39:51 <ReinH> aristid: oh :D
19:39:54 <ReinH> aristid: good work!
19:39:59 <edwardk> gwern: and try to solve each other's problems
19:40:09 <aristid> ReinH: still trying to figure out the gates
19:40:10 <edwardk> cars are open source, fuels are not
19:40:24 <ReinH> fuels are derived by creating ternary circuits
19:40:53 <edwardk> you win points by solving problems based on how many other people have a solution to the same problem and your relative solution fuel sizes
19:40:53 <aristid> neither the circuit code, nor the fuel code, nor the car code are really explained
19:41:03 <aristid> nor is the input to the circuit evaluator known
19:41:18 <ReinH> and the car code is particularly opaque
19:41:22 <gwern> so you want a car which takes the smallest fuel which others can't guess?
19:41:28 <edwardk> gwern: exactly
19:41:32 <ReinH> right
19:41:33 <edwardk> you can make 72 cars
19:41:39 <edwardk> and the earlier you make one the better
19:41:46 <edwardk> because the points tick every so often
19:41:48 <ReinH> "smallest" in terms of number of gates in the circuit that outputs the fuel formula
19:42:16 <aristid> you can't make any cars without first making a fuel
19:42:17 <edwardk> and the circuits are kind of like and-inverter graphs with loopback timedelay
19:42:26 <ReinH> right
19:42:29 <ReinH> kind of
19:42:32 <ReinH> heh
19:42:40 <gwern> very weird
19:42:50 <ReinH> thank god I did a little work on quantum computing recently
19:43:02 <ReinH> so ternary logic gates are something I'm actually familiar with
19:43:05 <aristid> lol.
19:43:07 <ReinH> totally random but helpful
19:43:21 <ReinH> aristid: have you constructed your truth table yet?
19:43:30 <aristid> ReinH: that's what why're trying to do.
19:43:36 <ReinH> word
19:43:45 <aristid> we have an idea how to do that without using billions of years.
19:43:51 <ReinH> yay
19:43:52 <edwardk> nah, they haven't figured out a single trit does, let alone a word ;)
19:44:09 <ReinH> because there are what, 3^18 possible gates?
19:44:29 <ReinH> "a very large number"
19:44:31 <aristid> i'm currently working on the infrastructure to implement that idea, and the other guy (who understands the whole problem better than i) can help implement it after he wakes up
19:44:40 <ReinH> aristid: hah good plan :)
19:45:00 <ReinH> aristid: we can currently produce a valid circuit for any desired output string
19:45:13 <ReinH> in about 250 LOC
19:45:21 <aristid> ReinH: neat.
19:45:38 <ReinH> tomorrow we start reverse engineering the car spec
19:45:56 <ReinH> which is totally opaque except for cryptic errors from the server ;)
19:46:12 <aristid> i'm gonna be proud if we get any points at all *sigh*
19:46:17 <ReinH> yeah
19:46:25 <ReinH> it's crazy tough this year
19:46:29 <gwern> ReinH: just construct an infinite tree of all possible specs and treat the errors as single bits eliminating half the tree :)
19:46:36 <ReinH> gwern: indeed ;)
19:46:50 <ReinH> leaving... an infinite tree of all remaining possible specs...
19:47:00 <gwern> ReinH: well, then you apply occam's razoer
19:47:03 <ReinH> gwern: except they're trits
19:47:24 <ReinH> so for each node you have to make one or two tries
19:47:30 <edwardk> ReinH: it can be a ternary tree ;)
19:47:31 <aristid> > filter (/= 'r') "trits"
19:47:32 <lambdabot>   "tits"
19:47:36 <ReinH> so it's a ternary search ;)
19:47:45 <gwern> but you're not getting 1.5 bits from the error
19:48:04 <ReinH> if no error, 1 trie. if error, the remainder is binary search ;)
19:48:08 <ReinH> *try
19:48:13 <ReinH> not to be confused with trie
19:48:16 <ReinH> which is what the tree is
19:48:19 <ReinH> ;)
19:48:30 <ReinH> nice freudian typo there
19:49:45 <aristid> ReinH: your freudian typos are "trie" instead of "try"? what does that say about your desires?
19:49:52 * ReinH shrugs
19:49:59 <ReinH> I like trees.
19:50:07 <ReinH> you can take it from there.
19:50:17 <edwardk> aristid: that they aren't good at pronouncing things. trie is sadly supposed to be pronounced tree ;)
19:50:37 <aristid> edwardk: wtf? i pronounce trie like try
19:50:40 <edwardk> if at first you don't succeed tree tree again.
19:50:48 <edwardk> aristid: as do i, but that isn't the original forumation ;)
19:50:50 <ReinH> o_O
19:50:55 <edwardk> er formulation
19:51:07 <ReinH> I thought it was "tree-eh"
19:51:14 <edwardk> http://en.wikipedia.org/wiki/Trie trie as in re-trie-val
19:51:23 <aristid> edwardk: i was astonished when i found out that recipe is pronounced ray-zee-peeh
19:51:25 <ReinH> AH
19:52:33 <ReinH> it's rather awkward that trie and tree are homophones
19:52:48 <edwardk> ReinH: hence why most of us say 'try' ;)
19:53:10 <ReinH> I think I'll stick with "prefix tree" :p
19:53:37 * ddarius says "tree" unless I feel context does not distinguish well enough.
19:53:53 <ddarius> That said, I rarely need to say "trie" aloud.
19:54:05 <ReinH> heh
19:54:37 <aristid> when i read or write a word, i also imagine its pronunciation, so no way to avoid that
19:56:02 <edwardk> ddarius: that might say more about the mixture of folks you interact with online vs. the mixture of folks you interact with in person though ;)
19:57:09 <gwern> aristid: that probably slows your reading down a lot, subvocalizing
19:57:50 <aristid> gwern: dunno, can't compare
19:58:43 <aristid> gwern: i mean, i need fractions of a second for a word
19:58:59 <gwern> large fractions or tiny ones like 1/1000?
19:59:15 <gwern> if it takes a quarter of a second or more, your WPM must be abysmal
19:59:17 <aristid> more like 1/5 or so
19:59:29 <aristid> gwern: abysmal by which standard?
19:59:44 <gwern> by anyone but the dyslexics'
20:00:02 <edwardk> i definitely couldn't subvocalize what i read
20:00:06 <aristid> gwern: well, compared to normal people i can measure out.
20:00:38 <aristid> edwardk: well, maybe my brain just presents me with the illusion of subvocalization
20:00:40 <gwern> if you can program (and in haskell), anything below 300WPM is a failing
20:00:55 <ddarius> edwardk: It does.
20:01:31 <aristid> gwern: i did not measure it, but i have been said to be a fast programmer.
20:01:55 * ddarius subvocalizes all the time and has no intention of changing that.
20:02:30 <aristid> i mean, i probably actually subvocalize only unfamiliar words
20:02:55 <aristid> like "damocles"
20:04:36 <aristid> gwern: seems like i'm at ~800 WPM
20:04:47 <gwern> that seems unlikely to me
20:05:05 <aristid> well i read a paragraph with roughly that size
20:05:15 <aristid> not 800 words but... it took 10 seconds
20:05:43 <ddarius> http://en.wikipedia.org/wiki/Words_per_minute
20:06:17 <ddarius> Stenographers beat the shit out of typists.
20:06:30 <aristid> gwern: well maybe it's only 500-600 wpm because i wasn't reading the last few sentences carefully
20:06:46 <BMeph> aristid: "Damocles" is an unfamiliar word? Here' how about a Sword, real cheap... ;)
20:07:06 <aristid> BMeph: well, it's not as familiar as, say, Applicative
20:07:26 <aristid> gwern: i do spend most of my time reading stuff.
20:07:30 <gwern> aristid: 500 I might believe
20:08:06 <aristid> gwern: did you measure what you get?
20:08:25 <danharaj> what the hell are you talking about, 500 words per minute?
20:08:32 <aristid> danharaj: reading
20:08:49 <gwern> yes; I normally read at around 400WPM but past 500WPM I start losing large chunks
20:09:38 <danharaj> ok, because I was thinking typing speed
20:09:46 * ddarius has never measured his reading rate.
20:09:48 <danharaj> 500 wpm would melt your keyboard :p
20:09:55 <ddarius> I'm certainly capable of reading much faster than I do, but I choose not to.
20:10:04 <orlandu63> i think everyone is
20:10:24 <danharaj> The longer you take to read, the more you get out of each word. :p
20:10:41 <gwern> I find serious diminishing returns for most words...
20:10:45 <aristid> i think it's best not to obsess over it
20:10:58 <aristid> gwern: yeah that's why you don't read the new york times
20:11:02 <aristid> terrible word efficiency
20:11:05 <ddarius> danharaj: I don't find speed reading enjoyable and at higher rates you start losing comprehension.  So for entertainment reading I'm not interested and for technical reading I'm not interested.
20:11:09 <edwardk> I made the mistake of taking a speed reading course as a small child. I usually take two passes over everything. One to figure out where the bits I care about are, and then another to refine my understanding of those areas. It doesn't work well with all authors though ;)
20:11:15 <gwern> aristid: the NYT is better than most papers
20:11:37 <danharaj> ddarius: I take to heart what my english and literature teachers have told me: read slowly and reread
20:11:41 <edwardk> On the other hand, if I get interrupted between those passes I may say some incredibly stupid things about the text in question ;)
20:11:51 <aristid> gwern: well, i need very long to read a paper because i need to understand things. i'm especially bad at reading formulas.
20:12:00 <gwern> speed reading software and courses are good for getting rid of handicaps keeping one below 300WPM but past that they're not very useful
20:12:56 <ddarius> edwardk: Were you the one that chose to take the speed reading course?
20:13:17 <aristid> gwern: did you know that there must have been a revolution in reading speed? spacing between words probably did help a lot
20:13:20 <gwern> ddarius: small childs are rarely given choices like that
20:13:28 <gwern> aristid: heck, silent reading is a revolution
20:13:37 <aristid> gwern: yeah that's what i mean
20:13:49 <gwern> aristid: you ever read St. Augustine writing about how everyone was freaked out that st. ambrose would read silently?
20:13:55 <aristid> gwern: no
20:14:08 <ddarius> gwern: He was a cheat!  Saint or no.
20:14:09 <gwern> oh. it's an interesting passage
20:14:13 <edwardk> i usually read something technical with a straw man implementation in my mind, so that as I skim I'm looking for anything that disconfirms my hypothesis. I found that that helps me maintain decent retention as long as my initial guess is close. It has also dramaticaly affected my reading patterns. I love any author who can surprise me
20:14:17 <gwern> you sort of assume that everyone could always silently read
20:14:22 <gwern> but that seems to not be the case
20:14:48 <aristid> gwern: well we both now know that people could NOT always silently read.
20:14:49 <edwardk> gwern: in my case, i was. my uncle had the material lying around
20:14:57 <gwern> edwardk: from an information theoretic point of view, if you can predict what the author says next, there was no information in the author's writing :)
20:15:20 <ddarius> No information for you.
20:15:25 <aristid> gwern: yes, there is, because you did not know before that you could predict it
20:15:37 <aristid> and that is information
20:15:41 <gwern> but on the other hand, what author would write 'oh, and everyone here was reading aloud, just like we always have'?
20:15:42 <edwardk> gwern: exactly =) but if you go through 3 books on the subject quickly you tend to get the benefit of multiple authors point of view, even if you only extracted a bit more information than the guy who read 1-2 books slower ;)
20:15:43 <ddarius> aristid: Often you do.
20:15:52 <aristid> ddarius: well then don't read it
20:16:07 <ddarius> aristid: I don't once I realize that nothing new is being said.
20:17:34 <edwardk> gwern: it also provides a nice benchmark for how far behind the state of the art in a field you are, because you can guess a solution, and then go figure out where in literature it was superceded. then count back to the date of the paper. voila, instant benchmark ;)
20:18:13 <gwern> that doesn't sound like a very good benchmark, but then, I'm a cynic
20:18:28 <edwardk> gwern: you keep doing it, you get enough samples that it becomes representative ;)
20:18:35 <danharaj> Unless you are ahead of the art.
20:18:43 <ddarius> danharaj: Then you publish.
20:18:52 <edwardk> danharaj: exactly
20:19:25 <edwardk> danharaj: then i try to blog to see if i just missed the reference first ;)
20:19:36 <evanbd> Is there a decent explanation of how to make Haskell play well with Debian Apt somewhere?
20:20:00 <ddarius> evanbd: Only ever use Debian packages.  Alternatively, use checkinstall.
20:20:21 <evanbd> ddarius: I was taking the first approach.  Which means I basically can't get stuff from hackage to install.
20:20:43 <ddarius> evanbd: Then update/make Debian packages.
20:20:46 <c_wraith> I recommend reversing your approach:  don't play nicely with apt.  Just install what you need.
20:21:34 <evanbd> c_wraith: Package management is a problem that does *not* benefit from mixing solutions.  No thanks.
20:21:36 <c_wraith> a user install of haskell is so easy to manage that I see no reason to get your package manager involved.
20:21:59 <c_wraith> It's not mixed:  the package manager doesn't keep up with haskell.  So it's not an option.
20:22:02 <ReinH> aristid: I now have a pipeline that lets me do this: echo "0" | ./gen_circuit/CreateSubmission | ./bin/submit_fuel
20:22:11 <ReinH> yay langauge interop
20:22:27 <evanbd> c_wraith: Yeah, I've noticed.  So far that's the thing I hate most about Haskell.
20:22:33 <ReinH> that submits the circuit for fuel prefix + circuit that generates 0
20:22:34 <ReinH> :D
20:22:51 <evanbd> c_wraith: Actually, the only thing I truly dislike.  There's plenty I just don't understand yet, but that's different :D
20:23:23 <c_wraith> A user install of haskell is *trivial*, though.  Way easier than a user install of any other language I've used.
20:23:37 <edwardk> ReinH: awesome. nobody will think to make such a sneaky car as that ;)
20:23:40 <ReinH> c_wraith: srsly, superb OS X packaging
20:23:50 <ReinH> edwardk: :p
20:24:03 <ReinH> edwardk: point being I can now try arbitrary fuel specification strings
20:24:06 <aristid> ReinH: i've written tools to parse, manipulate, print and visualize (with graphviz) circuits. tomorrow is the day to crack the gates.
20:24:09 <edwardk> ReinH: yeah
20:24:17 <ReinH> aristid: wow :D
20:24:36 <ReinH> aristid: not sure that graphviz is capable of visualizing the gates though
20:24:48 <aristid> the gates are opaque to graphviz
20:24:52 <ReinH> no no
20:25:06 <evanbd> c_wraith: I suppose I should give that a try.  The fact that decent debs is apparently hard is not an encouraging sign, though.
20:25:07 <ReinH> if a gate sequence is like this: X-[]=[]=[]-X right?
20:25:10 <aristid> well, in my current visualization code they are
20:25:19 <ReinH> or X-[0]=[1]=[2]-X
20:25:27 <ReinH> that's a trivial sequence of parallel gates
20:25:52 <aristid> it's also invalid because not all gates have 4 wires
20:25:57 <ReinH> with, say, rhs output of 2 looping back to rhs input of 0
20:26:01 <ReinH> (to make it valid)
20:26:11 <aristid> ah there.
20:26:16 <ReinH> that's easy to graph
20:26:23 <aristid> yeah that's what we do
20:26:32 <ReinH> but how do you graph: X-[0]x[1]=[2]-X
20:26:41 <ReinH> where x means crosswired
20:26:46 <aristid> well, graphviz deals with the ugliness of that.
20:26:55 <ReinH> yes, it has layout
20:27:24 <ReinH> but can graphviz directed graph nodes actually have two in-edges?
20:27:32 <ReinH> that you can address?
20:28:01 <ReinH> i.e. can you tell graphviz: rhs of 0 -> lhs of 1?
20:28:06 <aristid> yes
20:28:33 <ddarius> GraphViz is pretty old.  By now such a thing would have been added.
20:28:35 <edwardk> ReinH: you can address parts of nodes, etc.
20:28:58 <aristid> wow it's getting bright outside
20:29:15 <ReinH> cool
20:29:26 <ReinH> it's been a while since I messed with dot format
20:29:31 <aristid> ReinH: how big's your team?
20:29:41 * edwardk tries (as in try) to concentrate for a bit so he can finish up at least splitting off categories from category-extras tonight
20:29:45 <ReinH> aristid: 4 but we're a man down atm
20:29:55 <ReinH> aristid: you?
20:29:56 <aristid> ReinH: we're only 2 :)
20:29:59 <ReinH> :)
20:30:06 <ReinH> good luck!
20:30:09 <aristid> thanks
20:32:19 <ReinH> aristid: you have a /msg
20:36:40 * ddarius has never got into programming contests.
20:39:50 <edwardk> hrmm, what are the functors in the Prelude? IO, [], Maybe, Either a, any others? (,) a and (->) a if only in spirit, but what am i overlooking?
20:40:06 <edwardk> or is Either a even a functor?
20:40:24 <ddarius> @instances Functor
20:40:25 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:40:35 <edwardk> ddarius: yeah but many of those aren't in the prelude
20:40:41 <ddarius> True.
20:40:44 <Gracenotes> according to ghci, just IO, [], and Maybe
20:40:56 <edwardk> Gracenotes: much obliged
20:41:02 <edwardk> slim pickins
20:41:15 <Gracenotes> it is a nice feature, keeping track of instances for you
20:41:24 <Gracenotes> (and where they're defined)
20:41:36 <Gracenotes> yeah true
20:41:36 <dolio> edwardk: I wouldn't be surprised if Either a weren't declared a Functor in the prelude.
20:41:54 <edwardk> dolio: iirc its off in that horrible MTL module
20:42:07 <Gracenotes> yeah.. instance Functor (Either a) -- Defined in Control.Monad.Instances
20:42:19 <ddarius> MTL has served honorably for, like, 14 years or more.
20:42:35 <dolio> There isn't even a bad reason for that not to be in there.
20:42:48 <edwardk> ddarius: yes, i appreciate its longevity and its life time of servitude
20:44:24 <edwardk> ddarius: but even though i love my grandpa, i still have to acknowledge he has faults ;)
20:45:23 <dolio> Looks like 'either' is the only Either-related definition in the prelude.
20:45:37 <dolio> Eq, Ord, Read and Show being derived.
20:45:39 <ddarius> dolio: 'sall you need.
20:45:54 <edwardk> ddarius: yes, but they missed a prime opportunity for a haskell 98 bifunctor ;)
20:46:15 <ddarius> edwardk: They missed more than one (though that number might be two.)
20:46:31 <ddarius> Unless we are allowing mixed variances raising the number to a staggering three.
20:46:43 <edwardk> ddarius: that and (,) come to mind
20:47:19 <edwardk> though i supose that opens the door to (,,) a and (,,,) a b and (,,,,) a b c also wanting in on the action
20:48:11 <aristid> edwardk: tuples are somewhat ugly in general.
20:48:25 <evanbd> c_wraith: So yeah...  after I figured out which libs I needed to get configure to run, I get compilation errors.
20:49:08 <evanbd> c_wraith: That being the basic reason I wanted to use Apt...
20:49:11 <c_wraith> evanbd, are you compiling with --make ?
20:49:21 <applicative> edwardk, the main functor instances are in Data.Functor in base.  -- a little different from lambdabot's list, as usual.
20:49:42 <evanbd> c_wraith: I'm following the instructions on the web site!  ./configure, make, make install
20:49:59 <ddarius> evanbd: What are you trying to install?
20:50:03 <evanbd> ddarius: GHC
20:50:20 <c_wraith> oh.  follow the instructions in the README
20:50:24 <evanbd> ddarius: Well, the whole platform.  GHC, cabal, and...  whatever else it is I want.
20:50:29 <c_wraith> it's just ./configure, make install
20:50:35 <c_wraith> the "make" step is optional
20:50:40 <c_wraith> in fact, should be skipped
20:50:42 <edwardk> applicative: ah that is a much better list to target out of the box, thanks
20:50:46 <c_wraith> assuming you got the binary download
20:51:00 <ddarius> evanbd: I would install those with your package manager and, from there, install further Haskell "packages" with cabal-install.
20:51:30 <evanbd> ddarius: That was my original plan; it then refused to compile the packages I actually wanted to use...
20:52:04 <evanbd> ddarius: Which led to much frustrations and gnashing of teeth, so now I'm trying the approach of ignoring apt and doing a user install
20:52:51 <ddarius> The latest Haskell Platform should be in Debian or at least have a Debian package, so installing it "manually" won't help you any.
20:52:53 <bogner> evanbd: what distro/release are you on?
20:53:15 <c_wraith> evanbd, I do the following:  download the binary install, ./configure --prefix=$HOME, make install
20:53:17 <evanbd> c_wraith: Which README?
20:53:48 <evanbd> Ah, I went with the source install
20:53:50 <evanbd> ok
20:54:05 <evanbd> bogner: Debian Testing
20:54:30 <evanbd> ddarius: Lovely :/  So the issues are actually with cabal / hackage?
20:56:13 <ddarius> evanbd: What package did you want to use that didn't compile and why did it not compile?
20:56:50 <evanbd> ddarius: Glome-hs, and I don't remember the error off hand.
20:57:07 <evanbd> ddarius: Something about wrong base versions, maybe?
20:58:42 <evanbd> ddarius: I just thought a functional CSG package looked like a wickedly cool and easy way to see if the CAM code I was writing was producing sane output before I crashed a pricey end mill or something.
21:00:00 <evanbd> Really, my main goal right now is to make some fancy mathematical surfaces in aluminum.  I don't really want to be learning the inner workings of cabal or solving dependencies and such.
21:00:21 <dons> cabal solves deps for you, that's its job :)
21:01:08 <evanbd> dons: No, cabal solves deps for you :)
21:01:56 <dons> well, it should work for everyone. but not every .cabal file is correct.
21:04:36 <ReinH> evanbd: making fancy mathematical surfaces in aluminum with Haskell sounds fab :)
21:04:50 <dons> it does!
21:05:45 <evanbd> Well, there are some other steps first.  Like making sure the milling machine works properly.  It's...  somewhat old and persnickety.
21:06:50 <evanbd> But so far the haskell to generate the surfaces has been delightfully simple and easy.  I just figured it would be wise to do some renders of the tool paths first before I break something, and using glome-hs looked easier than creating output something else could read.
21:07:20 <dons> ah
21:07:24 <dons> let's see.
21:07:47 <dons> $ cabal install glome-hs
21:08:03 <dons> GlomeVec OK
21:08:13 <dons> GlomeTrace OK
21:08:21 <dons> glome-hs-0.60 failed during the building phase.
21:08:28 <dons> ah, rnf change.
21:10:14 <dons> fixing...
21:10:26 <evanbd> c_wraith: I did the bin install, and it looks like it worked...  what's the right way to get cabal along with it?
21:10:33 <Axman6> dons: did you end up seeing the program i submitted to the shootout, which was 10x faster than the previous entry?
21:10:46 <c_wraith> @hackage cabal
21:10:46 <lambdabot> http://hackage.haskell.org/package/cabal
21:11:00 <dons> evanbd: cabal update ; cabal install glome-hs
21:11:02 <dons> (i fixed it)
21:11:12 <c_wraith> evanbd: grab the .tar.gz from the bottom of that page, unzip it, and run bootstrap.sh
21:12:16 <dons> i really want to officially be able to patch .cabal files on hackage
21:12:19 <evanbd> c_wraith: which tar.gz?
21:12:20 * hackagebot glome-hs 0.61 - ray tracer  http://hackage.haskell.org/package/glome-hs-0.61 (DonaldStewart)
21:12:23 <dons> :D
21:12:31 <dons> i pinged jim about it.
21:12:52 <dons> Axman6: oh no??
21:12:57 <evanbd> c_wraith: Oh, the hackage URL from lambdabot? that gives a 404...
21:12:59 <dons> Axman6: in what benchmark?
21:13:05 <Axman6> thread-ring
21:13:11 <dons> nice. well, it got kinda broken.
21:13:18 <dons> or did you beat the proper fast entry?
21:13:19 <c_wraith> evanbd:  oh, then, just find it from hackage.
21:13:31 <c_wraith> evanbd: oh, what I did wrong is that the package name is cabal-install
21:13:39 <evanbd> oh ok
21:13:43 <dons> thread-ring's not an official benchmark anymore, is it?
21:13:47 <dons> http://shootout.alioth.debian.org/u64q/haskell.php ?'
21:14:12 <Axman6> dons: well, the previous one which i submitted i think got majorly slowed down in 6.12. was running in 5 minutes
21:14:28 <Axman6> dons: depends on which machine you look at
21:14:34 <dons> mm
21:14:42 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
21:14:45 <dons> so its not there?
21:14:54 <dons> i only care about u64q :)
21:15:00 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
21:15:10 <BMeph> ReinH: "i c wat u did ther..." ;)
21:15:32 <dons> ah, you just pin via forkOnIO numCapabilities?
21:15:40 <Axman6> yup
21:15:47 <dons> basically, programmatic version of -qm -qw. nice.
21:15:50 <Axman6> communication between cores is expensive
21:15:53 <dons> yup
21:15:59 <ReinH> BMeph: wat?
21:16:02 <dons> we used to use -qm -qw
21:16:09 <dons> but they removed that, hence the slowdown on that benchmark
21:16:18 <ReinH> BMeph: what did who do where? :)
21:16:23 <Axman6> ah, i see
21:16:40 <Axman6> what do they do again? i remember when we had them it made a huge difference
21:16:49 <dons> they pin :)
21:16:54 <Axman6> ah, heh
21:16:57 <dons> whatever core each thread starts on, it stays there.
21:17:08 <dons> -qm(igration -qw(wake up and don't move)
21:17:43 <BMeph> ReinH: ":04] <ReinH> evanbd: making fancy mathematical surfaces in aluminum with Haskell sounds fab :)"
21:17:48 <evanbd> Oh my, that's a lot of warnings that the bootstrap script throws...
21:18:00 <ReinH> BMeph: I don't see what I did there?
21:18:01 <ReinH> oh
21:18:02 <ReinH> fab
21:18:05 <dons> evanbd: you're building cabal ?
21:18:05 * ReinH facepalms
21:18:07 <BMeph> ReinH: "sounds _fab_". Heh-heh. ;)
21:18:15 <ReinH> I am awesome
21:18:20 <Axman6> anyway, i got bored with that, and i've moved onto a fast map implementation, which you may be interested in. it's based on the work you did on self optimising datastructures
21:18:22 <dons> evanbd: you don't have  the Haskell Platform installed?
21:18:26 <evanbd> dons: Yeah.  Or trying :/
21:18:31 <dons> Axman6: oh, yes, interesting.
21:18:35 <ReinH> also, yay 6X circuit generation algoritm improvement (ICFP)
21:18:36 <dons> Axman6: i'm writing a paper on that.
21:18:47 <dons> Axman6: so if you do something nice with IntMap let me know.
21:18:48 <ReinH> our circuits are now 600% shorter
21:18:50 <ReinH> :D
21:18:54 <evanbd> dons: That's what I'm trying to do!
21:18:55 <dons> ReinH: nice!
21:19:07 <dons> evanbd: hmm. not using the linux source installer?
21:19:21 <dons> http://hackage.haskell.org/platform/
21:19:25 <ReinH> dons: I just hope our re-submissions obsolete the previous versions in terms of our score
21:19:34 <dons> go go go!
21:19:41 <ddarius> evanbd: If you already have the Haskell Platform package installed, then glome-hs should build now that dons fixed it.
21:19:47 <ReinH> dons: now we just have to figure out the car engine...
21:19:48 <ReinH> o_O
21:19:52 <ReinH> dons: are you doing ICFP?
21:20:00 <dons> no, not this year.
21:20:07 <ReinH> ah
21:20:10 <Axman6> dons: tibbe started it, and we're both working on similar ways of making a faster Map. i'm using specialised key -> Int maps, and an array for the data (both boxed and unboxed), tibbe is trying to make n^2 different specialised Map implementations
21:20:18 <ReinH> dons: did you look at the task?
21:20:19 <evanbd> dons: Using the source installer produced compilation errors.
21:20:22 <ReinH> crazy hard and crazy awesome
21:20:27 <dons> Axman6: oh, that's what i want to put in this paper. :)
21:20:32 <Axman6> heh
21:20:36 <Axman6> i'll beat you to it :P
21:20:36 <evanbd> dons: So I switched to the binary one, and now I can't get cabal to build
21:20:38 <dons> we should totally get coordinated on this.
21:20:49 <dons> evanbd: hmm. what distro?
21:20:52 <Axman6> dons: well... if you come to AusHac we certainly could :P
21:20:57 <dons> when is it?
21:21:17 <Axman6> 16-18th of july
21:21:19 <dons> evanbd: the src installer for linux should work everywhere.
21:21:22 <evanbd> Anyway, perhaps I should just go back to where I started and see if the deb packages work properly now that you fixed glome.
21:21:24 <dons> Axman6: ah , no chance. but later in the year.
21:21:39 <dons> evanbd: oh. if you install ghc6 from cabal, the linux src installer should just work.
21:21:57 <evanbd> dons: Wait, what?  Now I'm really confused.
21:22:10 <evanbd> dons: Where do I get cabal from?
21:22:12 <dons> evanbd: well, you're on debian. and you already have ghc right?
21:22:16 <ddarius> dons: He should be able to use (and probably already has) a debian package for the platform.
21:22:28 <dons> oh,  the haskell-platform package. yes, if you have  that you're done.
21:22:58 <evanbd> I *tried* the debian package for haskell.  That didn't work.  But that sounds like it might simply have been the flome issues you fixed, so I'm about to go try that again.
21:23:03 <Axman6> well maybe you could help me anyway. is there an array type which can be defined to be of size n, while still leaving the elements empty, and then mutate the values to have actual values later?
21:23:12 * dons thinks we need a script to check people's environments are sane
21:23:19 <BMeph> dons, Axman6: Can we do any crib-sheet-stealing from Clojure?
21:23:24 <evanbd> (It was also complaining about my outdated cabal version, which is why I thought it wasn't just a broken glome package, but maybe that doesn't matter?)
21:23:39 <dons> Axman6: i'd use vector. you can freeze an uninitiazlied mutable array
21:23:46 <ddarius> evanbd: cabal install cabal-install 
21:23:49 * dons needs to do some hacking with tibbe.
21:24:03 <Axman6> excellent, i'm using Vector at the moment, but just using snoc, to make sure the idea works
21:24:05 <evanbd> ddarius: bash: cabal: command not found
21:24:05 <tommd> hacking for ICFP?
21:24:15 <dons> tommd: nah. just in principle.
21:24:22 <ddarius> evanbd: Do you have the haskell-platform package installed?
21:24:36 <dons> tommd: T-12 days to submission, so busy :-)
21:24:43 <tommd> Oh, cool!
21:24:48 <tommd> T-12 days till HALVM!!!!
21:24:53 <dons> damn straight
21:24:56 <evanbd> ddarius: *which* package?  The source one?  the binary one?  the debian one?
21:25:11 <ddarius> The debian one.
21:25:18 <ddarius> (Or any for that matter, they all do the same thing.)
21:25:55 <tommd> huh, I would have expected someone else to jump at that statement.  Oh well, there will be a cool reaction when it happens.
21:25:56 <evanbd> ddarius: No, I'm working on trying that approach again...  give me a few minutes...
21:25:57 <ddarius> evanbd: All it sounds like you are doing right now is trying to manually reinstall the haskell platform and hoping things will be different.
21:26:13 <evanbd> ddarius: Uhm, yeah.
21:26:18 <applicative> dons, did you see my reductio of the threadring benchmark?  I can't figure out how to make it one module and get my result, and thus an amusing protest letter...
21:26:24 <evanbd> ddarius: That is in fact precisely the plan.
21:26:31 <dons> tommd: we registered halvm.org to start
21:26:36 <evanbd> ddarius: Seeing as how dons says he fixed something :)
21:26:49 <ddarius> evanbd: I'm sure glome-hs is not in the Haskell Platform.
21:26:49 <dons> applicative: oh, i was wondering. protests eh?
21:27:10 <ddarius> evanbd: Don fixed the glome Hackage package, not GHC/Cabal/Haskell Platform.
21:27:21 <dons> evanbd: i uploaded it to hackage, fixed. meaning "cabal update ; cabal install glome-hs"
21:27:24 <dons> should work
21:27:28 <evanbd> ddarius: Right.  And so I install the haskell platform, and then use cabal to get glome
21:27:31 <applicative> dons, I don't know, I reposted it to make it plain it's the same code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26361#a26362
21:27:34 <ddarius> evanbd: Yes.
21:27:43 <evanbd> dons: Right, that's the plan.
21:27:50 <dons> Axman6: well, i'm probably going to submit something to PADL on this idea, fwiw
21:27:59 <evanbd> Be patient guys, my downloads aren't instant :D
21:28:23 <Axman6> dons: go for it, i'm looking forward to seeing what you produce
21:28:42 <dons> Axman6: my target is IntMap, then .... mtl.
21:28:59 <ddarius> evanbd: Manually installing the Haskell Platform would never have fixed anything unless your install was seriously screwed which would mean either you are doing something really odd or the Debian packagers are incompetent.  Neither seems likely.
21:29:15 <dons> ddarius: oh, did glome-hs fail, and he reinstalled the HP?
21:29:17 <dons> doh.
21:29:19 <Axman6> dons: so how are you implementing it?
21:29:30 <ddarius> dons: That's what it sounds like.
21:29:36 <dons> Axman6: secret sauce. but same as in adaptive-containers
21:29:43 <Axman6> heh, ok
21:29:53 <Axman6> so soecialising on the values then?
21:29:56 <evanbd> ddarius: Then consider this a bug report of the form "error reporting in cabal sucks".
21:29:59 <dons> got some sweet speedups in work code.
21:30:01 <Axman6> specialising*
21:30:04 <dons> yeah
21:30:16 <Axman6> the stuff i'm working on is specialising on the keys
21:30:19 <dons> tommd: time for summer pdx hackathon. july.
21:30:48 <tommd> July?  Who set that up?
21:30:50 <applicative> dons, my complaint was just that it's telling us exactly how to calculate what is in fact a pure function -- something a Haskeller won't do the C way... But anyway, it's clear the GHC via C manages to reduce it to what the C code is doing. 
21:30:56 <dons> tommd: just pondering.
21:31:01 <dons> tommd: maybe at galois.
21:31:06 <Axman6> i have a binary tree for each key type which makes keys to int indicies, then use the ints to fetch the values from a vector (unboxed or boxed)
21:31:06 <dons> we got coffee beans
21:31:15 <dons> Axman6: sweet
21:31:20 <applicative> dons, so if the Haskell is wrong, so is the C.
21:31:27 <dons> applicative: hmm
21:31:41 <evanbd> Ugh.  "The following packages are broken, either because they have a problem listed above, or because they depend on a broken package. [long list]"
21:31:53 <dons> evanbd: what are you  trying to build?
21:31:55 <tommd> dons: Caylee was talking about having one, so was Tim.  I'll talk to them when I get back to PDX.
21:31:57 <evanbd> (using debian haskell-platform package)
21:32:02 <Axman6> so the maps have unpacked keys and ints, which would reduce the overhead of all the pointers in the current maps (whic is what tibbe's problem was)
21:32:05 <evanbd> dons: glome-hs
21:32:11 <dons> tommd: sweet. yes. i think i could swing galois.
21:32:21 <applicative> if i'm not threading, they aren't.  the times are too similar.  i think the gcc is making the optimization after ghc passes it off.
21:32:33 <tommd> sounds good.
21:32:41 <dons> evanbd: works for me :/
21:32:57 <evanbd> dons: I got rid of the bits of user install of the platform, and went back to the debian haskell-platform package.  I then did cabal-update && cabal install glome-hs
21:33:19 <evanbd> $ cabal --version
21:33:20 <evanbd> cabal-install version 0.8.0
21:33:24 <evanbd> Is that the problem?
21:33:28 <dons> nope
21:33:32 <ddarius> What's the error message?
21:36:01 <c_wraith> > foldl1 f [1, 2, 3, 4]
21:36:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:36:02 <lambdabot>    `SimpleReflect.FromExpr ...
21:36:12 <c_wraith> Why does it keep doing that to me?
21:36:26 <ddarius> :t f
21:36:26 <evanbd> http://dark-code.bulix.org/dp3qan-75350
21:36:27 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
21:36:41 <c_wraith> > f 1
21:36:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:36:42 <lambdabot>    `SimpleReflect.FromExpr ...
21:36:48 <c_wraith> > x + y
21:36:48 <lambdabot>   x + y
21:37:14 <c_wraith> > foldl1 (+) [a, b, c, d]
21:37:15 <lambdabot>   a + b + c + d
21:37:21 <c_wraith> grr. :(
21:37:22 <ddarius> :t x
21:37:23 <lambdabot> Expr
21:37:33 <c_wraith> > foldl1 f [a, b, c, d]
21:37:33 <lambdabot>   f (f (f a b) c) d
21:37:37 <c_wraith> hah!
21:37:38 <ddarius> :t f 2 :: Expr
21:37:40 <lambdabot> Expr
21:37:57 <ddarius> c_wraith: You have to resolve the overloading.
21:38:43 <c_wraith> > foldl1 f [1, 2, 3, 4] :: Expr
21:38:44 <lambdabot>   f (f (f 1 2) 3) 4
21:38:48 <c_wraith> ah
21:40:58 <evanbd> ghc-pkg check output: http://dark-code.bulix.org/i2adal-75351
21:41:13 <c_wraith> :t AppE
21:41:14 <lambdabot> Not in scope: data constructor `AppE'
21:41:25 <c_wraith> :t Language.Haskell.TH.AppE
21:41:26 <lambdabot> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp
21:41:46 <ddarius> evanbd: Are you sure you are not using the stuff you tried to build rather than the debian packaged stuff?
21:42:23 <c_wraith> :t foldl1 Language.Haskell.TH.AppE
21:42:24 <lambdabot> [Language.Haskell.TH.Syntax.Exp] -> Language.Haskell.TH.Syntax.Exp
21:42:28 <evanbd> ddarius: Yeah, I cleaned out all the stuff I tried to build.
21:42:35 <c_wraith> Ah, that's cute. :)
21:42:40 <evanbd> ddarius: 'which ghc' etc confirms I'm using the debian versions
21:43:43 <ddarius> Did you delete ~/.cabal ?
21:44:01 <evanbd> ddarius: No, let me try that...
21:44:04 <ddarius> Don't.
21:44:24 <evanbd> Oh.
21:44:41 <evanbd> So...  what should I try?
21:45:38 <ddarius> Did you uninstall the Debian haskell-platform/ghc package before trying to build your own, or did you just start trying to build your own.
21:45:44 <ddarius> ?
21:46:11 <evanbd> ddarius: Uninstalled first
21:46:19 <om-foxy> I uploaded a package to Hackage (hstatistics), which builds and installs fine on my local machine, but I get a build error on the Hackage server.  The actual error is caused by there being no 'localBuildInfo' on the Hackage server.  The offending file 'configure.hs' is the same as the hmatrix package's, which builds fine on the Hackage server.  Does the Hackage server compile the code or...
21:46:21 <om-foxy> ...just the documentation?
21:46:46 <dons> just the docs, afaik.
21:46:53 <dons> heya om-foxy 
21:47:00 <om-foxy> dons: Hi!
21:47:23 <om-foxy> dons: how's the thesis?
21:47:29 <dons> almost done.
21:48:40 <evanbd> ddarius: What do I need to get rid of to put things in a clean state?
21:48:49 <Axman6> i thought hackage tried to build the package?
21:49:04 <dons> hmm. 
21:49:13 <dons> maybe it does. it certainly tries to build the docs
21:49:39 <evanbd> Ah-hah!  Deleting .cabal/ and .ghc/ seems to have done the trick.
21:50:58 <dons> om-foxy: i'm not sure whether to support au, usa or nz in the world cup :}
21:51:04 <evanbd> Awesome.  I have a glome test scene on my screen!
21:51:07 <evanbd> Woo!
21:51:23 <dons> sweet
21:51:42 <evanbd> Now, time to get some sleep, and then see if I can get some renders of my toolpath before I have to be at work
21:51:49 <evanbd> thanks everyone!
21:52:02 <om-foxy> dons:  The day after the draw the Aussie press called the team the 'Australasians.'  *mumble* *pavlova* *mumble* *mumble*
21:52:16 <dons> heh
21:52:25 <evanbd> And wow, I'd forgotten how ugly raytracing can look without antialiasing :D
21:52:26 <dons> om-foxy: finally i found some rugby on the telly. the churchill cup. usa/uk/canada/russia :}
21:52:55 <om-foxy> dons: :)
21:54:48 <dons> evanbd: cabal is the win.
21:56:11 <evanbd> dons: maybe when it works...  but the error messages were basically completely unhelpful.
21:56:12 <ddarius> Does GHC search .ghc before checking its stuff or something?
21:56:29 <dons> evanbd: ah, but very helpful for me. that's how i fixed the package.
21:56:35 <ddarius> evanbd: Cabal doesn't give error messages.  Those (for glome) where GHC error messages.
21:56:42 <dons> evanbd: it isn't good at tell you if it was the package's fault, or yours.
21:56:50 <ddarius> (Actually, cabal will produce error messages in some cases.)
21:57:26 <ddarius> If you are using the Haskell Platform, it's always the packages' fault unless it explicitly requires a newer version.
21:57:42 <ddarius> (of GHC pretty much)
21:57:55 <evanbd> Well, my point is that I ran "cabal install glome-hs" and it didn't work, and the stuff that came back didn't help much.  And this was still true after dons fixed things on hackage.
21:58:22 <dons> well, something was scrambled on your system, cause unknown as yet.
21:58:33 <ddarius> evanbd: You broke your install after you first tried but before dons fixed the hackage package.
21:58:44 <evanbd> ddarius: Sounds plausible.
21:58:46 <dons> that   shouldn't really happen, though.
21:59:00 <ddarius> dons: Yeah, I'm kind of wondering about that too, hence the .ghc question.
21:59:02 <dons> ghc-pkg check is useful, but we need a  full env checker.
21:59:11 <ddarius> dons: Apparently.
21:59:21 <evanbd> dons: My point is that it migt work beautifully when everything goes well, but when whatever it is went wrong, it didn't recover gracefully.
21:59:54 <evanbd> (And yeah, I know that making things respond well in such cases can be bitchy at best)
22:00:05 <dons> evanbd: yeah, its  hard to know what    to do. the package was broken in this case.
22:00:19 <dons> evanbd: so maybe we could have really good QA and warnings that it isn't going to build
22:00:25 <dons> hackage 2.0 is working on such support
22:00:39 <evanbd> Well, imho the problem isn't that the package was broken.  That's a minor issue.
22:00:51 <evanbd> The real problem is that you fixing the package didn't make the errors go away.
22:00:55 <dons> yes, more of an issue is what happened to your system.
22:01:03 <ddarius> evanbd: There is only so much that can be done.  I doubt Linux/Windows/etc. would gracefully handle it if you told it all the main files were somewhere that no longer existed.
22:01:27 <ddarius> evanbd: Yes it did.  He fixed your original problem.  He didn't fix your broken configuration which was not the original problem.
22:01:43 <evanbd> ddarius: Beside the point.  Apt doesn't offer me a way to tell it that through normal usage patterns.  Neither should cabal, or any combination of cabal and apt.
22:02:24 <evanbd> ddarius: Yeah, and the broken config is the problem I care more about.  Broken packages happen, and are generally easily fixed.
22:03:31 <ddarius> evanbd: I'm pretty sure the problems you had stemmed with the configuration stemmed from your attempt to build the platform from source, not from cabal or apt.
22:03:50 <evanbd> ddarius: Could be.  Shouldn't matter.
22:04:27 <ddarius> evanbd: My point with that was it wasn't through "normal usage patterns of cabal and apt".
22:05:03 <evanbd> Uh...  Yeah, it was.  I only performed steps that were on the web page, or in the readme, or that people here suggested.
22:05:08 <evanbd> Those are pretty normal patterns.
22:05:15 <ddarius> evanbd: Where did you get your GHC?
22:05:22 <evanbd> ddarius: Debian.
22:05:38 <ddarius> When you were trying to build the haskell-platform?  GHC is part of the platform.
22:06:01 <evanbd> And the first thing the web page says is that you need ghc to build ghc...
22:06:11 <ddarius> evanbd: Indeed.  And did you then build GHC?
22:06:30 <evanbd> Yeah.
22:07:01 <ddarius> So that GHC was built from source.  It was not from cabal, because GHC isn't cabalized and it wasn't from apt or else there would have been nothing to build.
22:07:04 <evanbd> I followed the steps on http://hackage.haskell.org/platform/linux.html
22:07:22 <evanbd> Right.
22:07:45 <evanbd> Wait, hmm?
22:08:00 <evanbd> I used the ghc from apt to build the platform that I downloaded from that page.
22:08:58 <evanbd> Then at some point I went and tried the binary version of the install instead (as suggested here)
22:10:19 <evanbd> I guess I think the biggest problem was that at no point in all this was it clear how I was supposed to get back to a clean starting point.
22:10:24 <dons> ghc from apt to build the platform should work fine.
22:10:39 <dons> if it doesn't, that's a serious error.
22:11:26 <evanbd> dons: it built the platform; the problems didn't appear until I started trying to get cabal working as well
22:11:40 <dons> mm. but the platform builds cabal for you.
22:11:53 <evanbd> No, it didn't...
22:12:02 <dons> so the platform failed to build completely?
22:12:11 <evanbd> No, it built ghc...
22:12:16 <om-foxy> evanbd: ghc from apt is 6.8 unless you use an unstable repository (sid)
22:12:41 <dons> mm. that doesn't sound right, evanbd. "the platform" is this: http://hackage.haskell.org/platform/2010.1.0.0/haskell-platform-2010.1.0.0.tar.gz
22:12:46 <evanbd> om-foxy: Not true.  It's 6.12.1 in testing as well.
22:12:49 <dons> you have to obtain ghc elsewhere (e.g. from apt)
22:12:57 <dons> it can't build ghc for you.
22:13:08 <evanbd> OK.  Well, I may be misremembering which errors came when.
22:13:15 <dons> ah well.
22:13:16 <evanbd> It's way past my bedtime.
22:13:28 <dons> once you jumped into sh bootstrap.sh for cabal, that was getting scary
22:13:47 <evanbd> heh
22:14:10 <evanbd> well, like I said: the biggest problem here, imho, is that it was completely unclear how I was supposed to get back to a clean starting point.
22:14:25 <dons> yes, that's reasonable. 
22:14:48 <dons> but its pretty easy. so maybe we need nice instructions "in case something goes wrong"
22:15:03 <dons> just nuke X, Y, and Z. etc.
22:15:10 <danharaj> just nuke <OS>
22:15:48 <evanbd> Yeah, that would help.  The relevant one this time was ~/.ghc/
22:16:55 <evanbd> I mean, it would be nice if the config hadn't gotten broken in all this, or it had recovered well from same, but that can be a pretty tall order.
22:18:47 <evanbd> Anyway
22:18:55 <evanbd> good night all, and thanks again for the help
22:35:22 <Runar> Any category theorists awake?
22:38:05 <Saizan> a sleep deprived category aficionado could do?
22:39:30 * ddarius wonders if Runar goes into restaurants and asks if anyone sells food there.
22:39:44 <Runar> hah
22:40:02 <Runar> More akin to walking into a bar and asking if the kitchen is open
22:41:05 <Runar> OK, so every abstract category is isomorphic to a "concrete" one, i.e. one in which the objects are sets and the arrows are functions.
22:42:21 <ddarius> That would mean every abstract category is locally small.
22:42:22 <Runar> I'm thinking of the category of sets with relations, where composition is transitive closure. What's the "concrete" category isomorphic to it?
22:43:05 <ddarius> Runar: R \subseteq AxB  ~ A -> P(B)
22:43:57 <Runar> what's P?
22:44:05 <ddarius> The powerset construction.
22:44:27 <Runar> do we have that functor?
22:44:33 <Runar> in Hask, I mean
22:44:56 <ddarius> It's contravariant.
22:47:16 <Runar> ddarius: ok, so is it just F b = [b] ?
22:47:36 <Runar> no
22:48:17 <dolio> b -> Bool is a better choice.
22:50:27 <Runar> oh, of course, a -> b -> Bool
22:50:42 <Runar> that clicks
22:52:39 <dolio> In fact, if you view relations as R \in P(AxB), then the above is AxB -> Bool ~ A -> (B -> Bool), which is currying.
23:22:02 * hackagebot hsignal 0.1.0.3 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.0.3 (VivianMcPhail)
23:25:56 <max_atreides> i started to learn haskell and it got me interested in the background category theory/lambda calculus. can anyone recommend introductory books on the subjects?
23:26:59 <kmc> _Types and Programming Languages_ by Pierce, if you want to learn about the various typed lambda calculi
23:27:59 <om-foxy> ooooo  hackagebot
23:28:02 <max_atreides> nice, i this is likely what i was looking for
23:28:36 <kmc> it's a fantastic book
23:36:39 <Cale_> max_atreides: Awodey's book on Category Theory is rather nice
23:37:09 <Cale_> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
23:37:28 <danharaj> You'll get much more out of Pierce than Awodey at a beginner level.
23:37:42 <danharaj> Pierce gives almost immediate dividends in understanding Haskell.
23:38:09 <wli> cale.yi.org doesn't resolve here
23:38:44 <danharaj> One does not simply http:// into cale.yi.org
23:38:54 <max_atreides> appreciated!
23:38:54 <toast`> yeah, i'm really liking pierce
23:40:20 <kmc> TaPL doesn't say anything about category theory, iirc
23:40:22 <cjs> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ is fun, and pretty easy reading, too (for a math book).
23:40:51 <danharaj> Conceptual Mathematics is starved of real material.
23:41:05 <danharaj> I was really disappointed by it- it doesn't even cover natural transformations!
23:41:25 <cjs> Possibly. But the Pierce, well, the first three pages I was thinking, "this is so simple!", and then after that my brain fried.
23:41:50 <cjs> Think of it as a quick (or slow, for slow learners like me) intro.
23:42:12 <danharaj> You have to pace yourself with Pierce, it is as vigorous as a college course, so you should expect to take a semester to even cover only part of the book.
23:42:24 <cjs> You can do Pierce, and if you get to page six and you're still going strong, yeah, skip _Conceptual_.
23:42:45 <max_atreides> cjs: thanks :)
23:43:20 <danharaj> I would not call you a slow learner if you spent an entire day on a particularly hard page of Pierce -especially without assitance-. If you can get through Pierce on your own, you are either already fairly familiar with theoretical computer science or mathematics, or you are very gifted.
23:43:29 <cjs> danharaj: Indeed. That sort of density is something of which I approve of in theory, but in practice I end up saying, "Ow! My head hurts!" :-)
23:43:42 <danharaj> But you don't have to go it alone, you have #haskell :)
23:43:47 <max_atreides> it's just that i have little background in math and I feel that to get full benefits of using haskell you have need to understand the background
23:44:01 <cjs> max_atreides: Not true.
23:44:45 <cjs> I think I may be from a similar background as you hear, so hear me out.
23:45:21 <cjs> Basically, Haskell does have a very strong mathematical background, yes. This is why the whole thing holds together so well.
23:46:34 <cjs> But you can, in the same way that you can stand on a bridge that doesn't fall down without knowing the details of how the structure was engineered, use Haskell in the way that I do (for commerical applications, for example), without having the brilliance to create such a thing.
23:47:07 <dolio> Is "Pierce" referring to "Basic Category Theory ..."? Because I don't think that's a very good book to learn from.
23:47:18 <kmc> the book by Pierce I mentioned was TaPL
23:47:23 <toast`> oh, i was thinkging of TaPL
23:47:34 <dolio> Yeah, I saw. That's not really about category theory, though.
23:47:36 <toast`> TaPL i've found *very* helpful
23:47:50 <kmc> dolio, yeah.  the other half of the question was about lambda calculus
23:47:51 <danharaj> dolio: he asked about Type Theory or Category Theory :p
23:47:59 <kmc> it's a good intro to typed lambda calculi
23:48:06 <cjs> E.g., reading about I/O in Haskell in pre-monad days is fasincating, and clearly the language at that point would have been completely useless to me, except as an intellectual curiousity. And I certainly don't have anywhere near the capability to come up with the idea of using moands for dealing with I/O, and state and general. But when I see it, I can appreciate it, and use it.
23:48:16 <dolio> Yeah, but I'm not sure why you'd compare TaPL to the Awodey book. They're on different subjects.
23:48:20 <cjs> Oh, I don't know TaPL.
23:48:34 <dolio> I kind of pictured TaPL as a thick book, too. Is it not?
23:48:35 <kmc> once you've read TaPL you will be able to understand things like page 5 of http://www.cse.unsw.edu.au/~chak/papers/fc.pdf or the figures in research.microsoft.com/pubs/79812/outsidein-icfp09.pdf
23:48:41 <cjs> What's the full title of that?
23:48:44 <danharaj> oh cjs, were you talking about his Category Theory book?
23:48:48 <cjs> Yeah.
23:48:49 <danharaj> Because that thing sucks.
23:48:49 <kmc> Types and Programming Languages
23:48:50 <max_atreides> cjs: right, i see what you are saying.
23:48:53 <kmc> 656 pages
23:48:58 <danharaj> My bad.
23:49:03 <cjs> Oh, that one. That's been on my "to-read" list for years.
23:49:27 <danharaj> kmc: I think any book that allows you to start reading research papers is a bit more than an introductory text.
23:49:32 <danharaj> kmc: But that is just philosophy.
23:50:13 <dolio> I think it's hard to get much out of Pierce's category theory book without already having a little experience with category theory.
23:50:20 <dolio> Which I guess invalidates the purpose of the book.
23:50:29 <kmc> danharaj, sure
23:50:33 <kmc> it's more than just an introductory text
23:50:38 <kmc> it is among other things an introductory text
23:51:07 <cjs> Really, the first three pages of Pierce's category theory book are great. It was just the rest that killed me.
23:51:22 <dolio> Yeah.
23:51:31 <cjs> (I am not saying this sarcastically; there's a lot there.)
23:51:46 <dolio> I'd read some other intro, and then read the later chapters on applications in functional programming.
23:51:50 <kmc> i was referring more to understanding the notation and conventions of formal presentations of systems as sequents like that
23:51:57 <kmc> which has sort of an amazing information density
23:51:59 <dolio> Where he talks about stuff like initial algebras.
23:52:00 <kmc> even compared to most maths
23:52:00 <cjs> I think the hard thing about category theory is how simple it is. It's so general that it's just hard to see how it works.
23:52:10 <danharaj> Abstract Nonsense
23:52:11 <kmc> and is one of the main reasons you might get stuck reading one page of TaPL for a day
23:52:16 <cjs> danharaj: Exactly.
23:53:19 <cjs> BTW, what do people around here think of CTM?
23:53:29 <danharaj> What is CTM?
23:53:32 <Axman6> CTM?
23:53:39 <Axman6> not much obviously :P
23:53:46 <cjs> _Concepts, Techniques and Models of Computer Programming_.
23:53:49 <BMeph> Peter Van Roy
23:53:53 <cjs> Yeah.
23:54:31 <ski> CTM is good
23:55:13 <cjs> I was just talking with a friend about this, and, while the book seems a brilliant idea, they seem to get certain things about FP and Haskell wrong, so I worry about whether they're just as wrong about the stuff I don't know intimately.
23:55:36 <max_atreides> well, i'm off to read that Category Theory Introduction. i'm really enjoying expanding my mind (comming from imperative language bg) with Haskell so thanks to everyone for being so helpfull.
23:55:48 <cjs> max: good luck!
23:57:27 <ski> (afaik, it doesn't talk about Haskell at all)
23:57:37 <cjs> E.g., that thing in the intro where they worry about whether a curried function has all of its arguments or not, where they seem to completely miss the fact that, even if a function does now have all of it arguments, in Haskell, that *still* doesn't mean it will be evaluated.
23:59:56 * ski doesn't have the book here to check the intro
