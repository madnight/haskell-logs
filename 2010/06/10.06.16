00:01:43 <sinelaw> jmcarthur, yo
00:02:14 <sinelaw> every time i come here i forget whether it was kmc or ksf i spoke to last time
00:02:34 <kmc> heh
00:02:39 <kmc> i get that a lot
00:02:43 <kmc> i'm here more
00:06:26 <adu> lol
00:22:33 <chrisf> and for RA, i'm inclined to agree with you that it's not a win.
00:23:56 <solrize> kmc, yeah, eventfd is what they used in linux.  the pipe thing seemed incredibly hackish but i couldn't think of anything better at the time.
00:24:02 <solrize> wha'ts RA?
00:24:42 <chrisf> solrize: sorry, i failed at whispering. RA = red alert, and has nothing to do with #haskell.
00:25:06 <solrize> oops :)
00:25:36 <sinelaw> i thought it was a cross betwen AR and MA 
00:26:54 <solrize> has anyone looked at HASP?
00:26:55 <chrisf> solrize, sinelaw: this, which, regrettably isnt written in haskell, but is c#, so we can pretend..: http://open-ra.org
00:27:17 <solrize> oh cute
00:34:04 <solrize> does LitHaskell mode mess up indentation a lot or is it just me?
00:35:53 <coppro> someone remind me why I'm getting tons of linker errors?
00:36:18 <ezyang> because you didn't tell GHC where to find the static/dynamic libraries? 
00:36:30 <robertmassaioli> sinelaw: yeah I was confused today too
00:36:36 <coppro> that would do it
00:37:21 <coppro> what's the best way to link against Cabal libraries?
00:37:47 <ezyang> cabal configure && cabal build 
00:37:54 <ezyang> that is, with cabal itself./ 
00:38:01 <ezyang> But this shouldn't be giving you linker problems 
00:38:08 <ezyang> what's the lib in question? 
00:38:47 <coppro> parsec
00:38:56 <ezyang> yeah, that should be fine... 
00:39:31 <coppro> no, I mean how do I tell GHC to link my code against Parsec
00:39:51 <Zao> -package ?
00:40:24 <coppro> uh, what? my invocation is currently 'ghc file.hs'
00:40:35 <coppro> what must it be?
00:40:49 <ezyang> ghc --make file.hs 
00:41:02 <coppro> thanks
00:41:17 <coppro> yay it worked
00:41:18 <coppro> awesome
00:41:20 <coppro> :)
00:44:12 <edwardk> does anyone remember the module that contains the 'Any' data type?
00:44:41 <edwardk> i thought it was in ghc.prim
00:46:05 <solrize> i just saw that someplace
00:46:06 <edwardk> looks like it is hiding there still
00:46:10 <solrize> data.monoid?
00:46:16 <edwardk> different Any
00:46:19 <solrize> ok
00:46:26 <edwardk> the one in GHC.Prim is a safe placeholder for unsafeCoerce
00:46:36 <coppro> awesome, things are working. Thanks
00:47:01 <solrize> how does lazy io work in haskell 98, where there is no unsafeInterleave ?
00:47:36 <edwardk> solrize: the magic of pretending file system side effects don't exist...
00:49:14 <solrize> heh
00:50:57 <earthy> actually, the magical fiction that an IO program is constructed purely, and then executed by the IO interpreter.
00:52:28 <kmc> Haskell 98 does not specify how readFile should be implemented
00:52:39 <kmc> just as it does not specify how IO itself should be implemented
00:56:05 <earthy> well, it *does* specifiy that the sequential chaining of actions that is specified by the user should be observed.
00:57:06 <edwardk> liftAny2 f a b = unsafeCoerce $ f (unsafeCoerce a) (unsafeCoerce b) -- i feel safe...
00:58:32 <earthy> plus, it does specify that file system side effects should not occur with lazy IO within a single program
00:59:01 <edwardk> earthy: the problem is one does not control the side effects induced by the real world
00:59:06 <earthy> true. :)
00:59:36 <earthy> however, this is not something other languages explicitly guard against either
01:00:01 <edwardk> yeah but we're better than that. hrmph ;)
01:00:09 * earthy laughs
01:02:37 <earthy> we try to be, yes
01:02:52 <earthy> however, reading from a file that at the same time is being written to... that's crazy :)
01:03:52 <edwardk> i hate working with stablenames. i wind up with an unsafecoerce every 2-3 lines. i think i'm just going to package something up for dealing with this once and forall
01:06:10 <solrize> stablenames?
01:06:34 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
01:06:46 <edwardk> er
01:06:47 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.htm
01:08:50 <solrize> tx
01:09:20 <edwardk> basically its a hack on the storage manager that is useful for memoization, and for doing sneaky things like figuring out sharing info
01:09:30 <edwardk> and a bit of a golden hammer for me
01:09:49 <solrize> ic.  yeah, that sounds like naked pointer hell
01:09:58 <edwardk> its a bit better
01:10:12 <edwardk> but a great source of dirty tricks
01:10:35 <solrize> have you ever looked at ATS?  
01:10:42 <edwardk> yeah
01:11:02 <edwardk> great ideas, terrible language
01:11:12 <solrize> heh
01:11:30 <solrize> it looked pretty neat to me but i didn't try to actually use it, just read a few of the docs
01:11:33 <cizra> jarick: ldd shows linking to libgtk-x11-2.0.so.0, libcairo.so.2 etc
01:12:07 * dMazz is newbie in a need of help: Exercise 1.2 in chapter 3.3 : http://jonathan.tang.name/files/scheme_in_48/tutorial/parser.html
01:12:24 <edwardk> it is a great melting pot of crazy stuff, but everything hongwei can think of is a keyword, and that keyword usually involves an ad hoc abbreviation _and_ an underscore.
01:13:59 <solrize> dmazz could you implement liftM if it wasn't in the library?
01:14:44 <dMazz> solrize, sorry.. no idea 
01:14:48 <aristid> easy. liftM=liftA
01:14:55 <edwardk> aristid: cheating ;)
01:15:06 <c_wraith> well, then...  It's fmap!
01:15:07 <edwardk> dMazz: take a look at the types of return and (>>=)
01:15:09 <aristid> edwardk: yeah, not all monads are applicative :(
01:15:12 <danharaj> ats makes my eyes bleed
01:15:13 <edwardk> @type (>>=)
01:15:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:15:17 <edwardk> @type return
01:15:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:15:28 <edwardk> what looks the same between them?
01:15:29 <aristid> @type liftM
01:15:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:16:22 <edwardk> brb
01:21:27 <cizra> How weird. When I run my test Gtk2Hs app with runhaskell, it works fine. when I run it it ghci (just call main), it also works fine, but ghci segfaults if I type anything into it afterwards.
01:22:26 <drbean> I just realized that the <- in a list comprehension is ASCII art for Ïµ, which makes it a lot more comprehensible.
01:25:15 <solrize> edwardk, that paper keeps talking about proof obligations but gives no clue about how to fulfill them :(
01:25:37 <edwardk> solrize: thats the hard part ;)
01:25:51 <edwardk> you only have to reason about unwritten semantics, whats the problem? =)
01:26:31 <solrize> that's why i thought ats was interesting, as it allowed type-checking all kinds of pointer bashing
01:26:45 <solrize> disciple also looked cool
01:26:57 <solrize> but i think it is dead
01:30:48 <dMazz> I don't know,  I don't want to skip this exercise.. this tutorial is quite hard, maybe I missed some point.. the talk about Monads and all without clearing them first, it causes confusion and doubt about my reasoning
01:33:39 <solrize> dMazz, you should do that exercise or something like it, it's important
01:34:07 <solrize> well if your immediate goal is to just use parsec, maybe the exercise can wait
01:34:29 <solrize> but understanding monads requires being able to do that exercise
01:35:15 <solrize> if you like abstract algebra you might like the haskell wikibook on category theory.  that's what demystified the subject for me
01:35:22 <solrize> of monads, i mean
01:35:45 <solrize> they are like burritos :)
01:36:01 <mjrosenb> hey, is there any way of matching on a constructor with fields without explicitly ignoring every field?
01:36:16 <quicksilver> what do you mean by "explicitly" ignoring?
01:36:21 <squidsoup> hey, is anyone aware of any frameworks that allow non programmers do develop application logic and forms? (aware that it sounds unusual)
01:36:22 <Zao> mjrosenb: Omg {}
01:36:23 <quicksilver> you only have to name the fields you want
01:36:32 <quicksilver> (as few as zero if you wish)
01:36:34 <napping> only for records
01:36:38 <mreh> with records
01:36:39 <Zao> If you want to refer to it,  o@(Omg {})
01:36:44 <quicksilver> no, Omg {} works even for non-records.
01:36:47 <mjrosenb> awesome
01:36:58 <quicksilver> which might or might not be a GHC extension.
01:37:06 <mjrosenb> i'm used to sml where you need to use ... in order to ignore 'all other fields'
01:37:09 <mreh> zomg
01:37:09 <napping> That works for non-records? Wow
01:37:48 <solrize> Omg _ _   should work (number of _'s = number of fields in the data constructor)
01:38:17 <Zao> > let f (Just {}) = True in f (Just "pie")
01:38:18 <lambdabot>   True
01:38:39 <Zao> @src Maybe
01:38:40 <lambdabot> data Maybe a = Nothing | Just a
01:38:47 <napping> still, if you want to match on some but not all of the fields it has to be a record
01:38:53 <jarick> squidsoup: You're looking for something like Access?
01:39:50 <squidsoup> jarick: it's an odd domain, I've been tasked with redeveloping a system that uses a prolog decision support engine that allows domain experts to build expressions graphically which are bound to form elements
01:40:06 <squidsoup> clinical decision support specifically
01:40:40 <jarick> squidsoup: I see, and you are looking for a prolog-like language?
01:41:34 <squidsoup> not as such, really we're looking for a non-proprietary alternative.. but the concept of domain experts being intimiately involved in the development of application logic is just bizarre 
01:41:53 <squidsoup> from my perspective at least, but apparently it's not that unusual amoungst expert systems/decision support systems etc
01:42:08 <dMazz> solrize, ok thank, I'll look into the wikibook, maybe I'll get the "A-ha!" and can return to this
01:42:41 <jarick> squidsoup: It sounds painful.
01:42:58 * hackagebot stable-maps 0.0.1 - Heterogeneous maps keyed by StableNames  http://hackage.haskell.org/package/stable-maps-0.0.1 (EdwardKmett)
01:43:28 <squidsoup> figured I would ask here, as it's more an academic than corporate problem. yes, it is rather painful :/
01:43:53 <jarick> squidsoup: What's wrong with the existing one?
01:43:59 <edwardk> solrize: that package may help answer what you can do with stablenames, maybe not ;)
01:44:00 <squidsoup> almost tempted to suggest we do things "traditionally" but with BDD and have the domain experts just write stories
01:44:08 <squidsoup> extremely expensive, and unstable
01:44:20 <squidsoup> and not particularly intuitive tooling
01:44:25 <jarick> squidsoup: Hey, I pay for matlab and labview. :D
01:44:41 <squidsoup> :)
01:45:02 <fasta> squidsoup, I think lots of research shows that experts are in fact not experts ;)
01:45:06 <jarick> squidsoup: Considered just teaching them any language?
01:45:13 <zuserm> ghc, "Invalid type signature" is not a helpful exception
01:45:19 <solrize> edwardk,  tx
01:45:29 <jarick> fasta: Research also shows that research tends to be refuted after a while. :D
01:45:50 <squidsoup> well, their medical knowledge is certainly better than mine.. at least, they ask the doctors the right questions when we're developing guidelines
01:46:10 <edwardk> solrize: http://github.com/ekmett/stable-maps/blob/master/System/Mem/StableName/Map.hs is the actual meat of it
01:46:42 <edwardk> http://hackage.haskell.org/package/data-reify also uses them to evil effect
01:46:45 <squidsoup> jarick: one of them can write fair to midling javascript, but I don't think he enjoys it :)
01:46:47 <solrize> ok
01:46:56 <jarick> squidsoup: Python?
01:46:58 <squidsoup> the others are really very non-technical
01:48:15 <squidsoup> jarick: actually, now that you mention python, we were thinking about potentially providing some kind of dsl in ruby (presumably python would be suitable too)
01:48:57 <squidsoup> I guess recognising that they do need to code to some extent, but attempt to make it as intuitive as possible
01:50:28 <jarick> squidsoup: What is the problem domain?
01:50:31 <jarick> Expert systems?
01:50:57 <squidsoup> similar to an expert system, it's technically a rule based decision support system
01:51:16 <squidsoup> supported by a rule/logic engine (the prolog I mentioned)
01:51:25 <squidsoup> no AI of any sort
01:51:52 <solrize> edwardk, can you use data.dynamic instead of unsafecoerce all over the place?
01:52:04 <edwardk> solrize: at an efficiency cost
01:52:08 <solrize> ic
01:52:18 <edwardk> solrize: the point of the library there is that those unsafeCoerces _are_ safe ;)
01:52:23 <edwardk> hence why i wrapped it up
01:52:36 <edwardk> that way i don't have to do that reasoning again
01:52:49 <solrize> yeah
01:53:05 <edwardk> the stablename serves as a witness of the type i want to extract
01:53:23 <edwardk> much like dynamic carries around a typerep
02:04:34 <solrize> hmm
02:04:58 <solrize> could you have written in agda and used a code extractor?
02:05:17 <edwardk> possibly. but i find the code i get out of agda to be hardly idiomatic
02:05:30 <edwardk> and hard to maintain in the long run since agda changes a lot faster than ghc versions ;)
02:05:35 <solrize> heh
02:05:42 <solrize> coq?
02:05:58 <edwardk> worse on the idiomatic front, but more stable over time
02:06:20 <solrize> why do you care if the output is idiomatic?  it's compiler output
02:07:18 <edwardk> because ultimately, someone other than me eventually winds up maintaining half these things, the coq scripts get lost in the sands of time or become obsolesced, and it becomes an unmaintanable mess
02:07:23 <ivanm> greetings edwardk 
02:07:41 <edwardk> it is hard to get coq to use built in types, and nigh impossible to get it to use built in typeclasses
02:07:44 <edwardk> so the API suffers
02:07:49 <solrize> hmm ok
02:08:11 <edwardk> i suppose a comparison might be in order
02:08:14 <solrize> if gadt's had been invented first would haskell even have typeclasses?
02:08:32 <solrize> and, i'd hope the build system and so forth would know about the coq scripts
02:08:42 <solrize> otherwise it's like losing the yacc scripts that generate a C parser
02:08:47 <edwardk> idiomatic: http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html
02:08:49 <edwardk> coq: http://hackage.haskell.org/packages/archive/meldable-heap/2.0.3/doc/html/Data-MeldableHeap.html
02:09:43 <edwardk> yes, GADTs and typeclasses serve very different purposes.
02:10:02 <edwardk> typeclasses make ad hoc polymorphism less ad hoc
02:10:07 <ivanm> edwardk: are you talking about comparing the API or the imiplementation of said API?
02:10:09 <edwardk> GADTs let you recover type information
02:10:16 <edwardk> ivanm: both ;)
02:10:20 <solrize> the haddock docs for meldable heap look ok
02:10:34 <ivanm> solrize: what I was thinking, hence my query
02:11:04 <edwardk> ivanm: note that it is actually a skin over the real guts
02:11:09 <ivanm> edwardk: I notice that you don't claim credit to the Coq-generated code either ;-)
02:11:43 <edwardk> http://hackage.haskell.org/packages/archive/meldable-heap/1.1.2/doc/html/src/Data-MeldableHeap-BrodalOkasakiExtract.html -- though jbapple seems to have cleaned that up a lot
02:11:51 <ivanm> ugh, I'm going through more and more layers of source trying to find where said guts are...
02:12:06 * hackagebot regions 0.6 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.6 (BasVanDijk)
02:12:08 * hackagebot regions-monadsfd 0.3.1.2 - Monads-fd instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadsfd-0.3.1.2 (BasVanDijk)
02:12:10 * hackagebot regions-monadstf 0.3.1.2 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.2 (BasVanDijk)
02:12:16 <ivanm> edwardk: what's with the TypeSynonmINstances usage though?
02:12:27 <edwardk> ivanm: in mine?
02:12:40 <edwardk> oh his
02:12:51 <ivanm> oh, wait, you no longer maintain meldable-heap?
02:13:05 <edwardk> meldable-heap is jbapple
02:13:05 <ivanm> duh, you have heaps, he has meldable heaps
02:13:06 * hackagebot explicit-iomodes 0.4 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.4 (BasVanDijk)
02:13:16 <ivanm> sorry, for some reason I thought it was different versions of the same package
02:13:32 <edwardk> nah, mine implements more tricks than are easily proved
02:13:44 <solrize> looks like it was written by @pl ;-)
02:14:00 <edwardk> his is based on the version at the beginning of brodal/okasaki, mine are used the fairly horrid techniques at the end ;)
02:14:01 <solrize> or like ghc core
02:14:08 * hackagebot explicit-iomodes-bytestring 0.1 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.1 (BasVanDijk)
02:14:09 <ivanm> solrize: presumably coq has @pl built into it!
02:14:10 * hackagebot safer-file-handles 0.6 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.6 (BasVanDijk)
02:14:12 * hackagebot safer-file-handles-bytestring 0.1 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.1 (BasVanDijk)
02:14:14 * hackagebot regional-pointers 0.2 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.2 (BasVanDijk)
02:14:16 * hackagebot usb 0.4 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.4 (BasVanDijk)
02:14:30 <ivanm> it's times like this that hackagebot is a pain
02:14:34 <ivanm> hackagebot: stop spamming!
02:14:36 <ivanm> hey TacticalGrace 
02:14:40 <solrize> oops
02:14:53 <edwardk> in any event, jbapple is a lot better at making coq-extracted output look pretty than I am. mine looks like total chickenscratch when I try ;)
02:15:17 <ivanm> edwardk: because he understands wtf the coq output means? :p
02:15:18 * hackagebot usb-safe 0.7 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.7 (BasVanDijk)
02:15:28 <edwardk> ivanm:  =)
02:16:08 <solrize> http://code.google.com/p/priority-queues/source/browse/brodal-okasaki/SkewBinHeapVerify.v
02:16:11 <edwardk> i think it has more to do with structuring things so that proof erasure doesn't leave proof terms scattered throughout your result, since those turn into holes
02:16:19 <solrize> how hard is it to get the hang of writing those proofs?  and if it's not hard, can't a machine do it?
02:16:51 <edwardk> solrize: machines can't do it, each of those statements _is_ a fairly complicated sequence of step being run by a machine
02:17:18 <edwardk> whenever you see 'auto' read it as 'then magic happens'
02:17:25 <solrize> true
02:17:45 <fasta> Machines can do it, just not on a human time scale. 
02:17:46 <ivanm> edwardk: is that in the output or in the coq code?
02:18:12 <edwardk> ivanm: auto is in the coq code, the _'s from the proof term residue tend to wind up in the output
02:18:42 <ivanm> @remember edwardk whenever you see 'auto' [in coq code] read it as 'then magic happens'
02:18:43 <lambdabot> I will remember.
02:18:56 <ivanm> just didn't want me to quote you wrongly :p
02:19:21 <edwardk> =)
02:19:56 <fasta> auto is well-defined, but fairly complicated. Maybe too complicated, since I don't remember the exact semantics by heart. 
02:21:43 <TacticalGrace> Hey ivanm
02:29:52 <mreh> I've never seen the Hermine polynomials written as a constant
02:30:03 <mreh> I thought they were a function
02:31:05 * mreh goes to blah
02:32:22 <ivanm> TacticalGrace: for AusHack, do you know if there's going to be any places on campus available to get food from (i.e. lunch) then?
02:33:37 <mreh> get yourself some bush tucker mate
02:38:05 <mornfall> Hm. Anyone know of a fulltext indexing/search library available from Haskell?
02:38:21 <ivanm> mornfall: as in for normal text? don't think there are any
02:38:36 <ivanm> mreh: well, it's in the middle of suburbia... not much bush around there to get the tucker from
02:38:36 <mornfall> I mean like in Xapian and friends.
02:38:46 <ivanm> though there might be some horses across the road... :p
02:38:50 <ivanm> mornfall: oh, for indexing?
02:38:52 <mreh> ewwww
02:38:55 <ivanm> duh, you said indexing
02:39:19 <ivanm> mreh: in case you aren't aware, AusHack is going to be at UNSW, which is across the road from the Randwick racecourse
02:39:23 <mornfall> It seems so. :)
02:39:41 <ivanm> mornfall: there's tracker, which is a library for something else
02:39:58 <ivanm> looks like that's about it though
02:40:23 <mornfall> There's also a sphinx client, but it doesn't seem to be what I want either.
02:41:57 <ivanm> I thought sphinx was for OCR...
02:42:12 <ivanm> obviously I'm wrong :p
02:57:05 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26276#a26276 - ?
02:57:28 <ivanm> mreh: fromIntegral
02:58:15 <ivanm> wait, actually... sig is Double, so sqrt 2 would also be Double
02:58:18 <ivanm> @type (^^)
02:58:19 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
02:58:20 <mreh> I know what it is
02:58:25 <mreh> i've used x' in gaussian
02:58:38 <ivanm> duh, wrong way round
02:58:46 <mreh> sometimes these errors are at the end of an inferential trail
02:58:47 <ivanm> it's wanting Int but it ends up being a Double
02:58:55 <mreh> exactly
02:59:03 * ivanm always gets that expected vs inferred error mixed up :s
03:00:31 <mreh> and hermitePolynomial is polymorphic, and I was calling it with a double
03:00:39 <mreh> why do I write such complicated software
03:01:58 <ivanm> how do you expect me to know why you're masochistic?
03:03:55 <ivanm> preflex: seen tomberek
03:03:55 <preflex>  tomberek was last seen on #haskell 9 days, 23 hours, 43 minutes and 24 seconds ago, saying: copumpkin.. what about coq?
03:03:58 <ivanm> grrrr......
03:04:01 <mreh> -viaC? is that right
03:04:03 <Blkt> good day everyone
03:04:07 <ivanm> mreh: -fvia-C
03:04:09 <ivanm> hey Blkt 
03:04:10 <ivanm> @hoogle singleton
03:04:11 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
03:04:11 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
03:04:11 <lambdabot> Data.IntSet singleton :: Int -> IntSet
03:10:30 * hackagebot hlcm 0.2.1 - Fast algorithm for mining closed frequent itemsets  http://hackage.haskell.org/package/hlcm-0.2.1 (AlexandreTermier)
03:18:55 <dibblego> does QC have a Show for (a -> b) ?
03:19:07 <ivanm> dibblego: no, but Text.Show or something does
03:19:16 <ivanm> it's just "<function>" IIRC
03:19:35 <ivanm> make that Text.Show.Functions
03:20:03 <dibblego> ta
03:20:17 <ivanm> np
03:20:37 * ivanm is currently bashing his head against the code tomberek wrote for FGL
03:21:37 * hackagebot hlcm 0.2.2 - Fast algorithm for mining closed frequent itemsets  http://hackage.haskell.org/package/hlcm-0.2.2 (AlexandreTermier)
03:45:34 <geheimdienst> as part of ghc's ongoing mission to drive me crazy, she is today telling me this:
03:45:40 <geheimdienst> Ambiguous module name `Control.Monad.Error': it was found in multiple packages: mtl-1.1.0.2 monads-tf-0.1.0.0
03:45:54 <Raynes> GHC is a she?
03:46:02 <geheimdienst> just because i read about ErrorT and thought it's kinda handy and wanted to import it
03:46:02 <Raynes> You're not my friend anymore.
03:46:08 <geheimdienst> raynes: what did you think?
03:46:43 <k23z__> I went at some interview with a very small company and they saw Haskell in my cv and said "hmm Haskell ... *rubs beard* interesstiiiiing..."
03:46:44 <Raynes> It's genderless. 
03:47:17 <p_l> k23z__: lol
03:47:32 <mreh> k23z__ sounds bad
03:47:51 <mreh> maybe they mistrust intelligence
03:47:53 <geheimdienst> i guess the correct answer would have been: "hmm Haskell ... *rubs neckbeard* interesstiiiing ..."
03:48:54 * p_l is reminded of dirty incest joke... just replace Haskell with "goat" (male)...
03:48:55 <mreh> eww, neckbeard
03:49:08 <mreh> billygoat?
03:49:26 <p_l> heh
03:50:06 <mreh> tell them you're pagonaphobic
03:50:20 <geheimdienst> @wn pagonaphobic
03:50:21 <lambdabot> No match for "pagonaphobic".
03:50:29 <mreh> @wn pagonophobic
03:50:30 <lambdabot> No match for "pagonophobic".
03:50:34 <mreh> @wn pagonophobe
03:50:34 <lambdabot> No match for "pagonophobe".
03:50:37 <mreh> @wn pagonaphobe
03:50:38 <lambdabot> No match for "pagonaphobe".
03:50:43 <p_l> panophobic? Phobia against Pan ? :D
03:50:59 <geheimdienst> "did you mean: pogonophobia"
03:51:05 <geheimdienst> @wn pogonophobia
03:51:06 <lambdabot> No match for "pogonophobia".
03:51:19 <geheimdienst> anyhoo, it's fear of beards
03:51:23 <mreh> yes
03:54:08 <geheimdienst> hint that a word is only for joking use: it's not in the dictionary
03:55:03 <mreh> neither is gullible
03:56:51 <jarick> geheimdienst: pogono- is a valid greek prefix 
03:57:29 <ksf> splice :: (Throws EBADF l, Throws EINVAL l, Throws ENOMEM l, Throws ESPIPE l, Throws POSIXException l)
03:57:29 <ksf>        => Fd -> Maybe COff -> Fd -> Maybe COff -> CSize -> CUInt -> EMT l IO CLong
03:57:33 <ksf> finally, some clarity.
03:57:36 <Botje> ksf: EEK!
03:58:19 <ksf> hey you can catch all of the E* ones by catching POSIXExcetpion
03:58:56 <ksf> ...and not accounting for the possibility of errno being set is bloody insanity.
03:59:03 <Botje> hehe :)
03:59:05 <geheimdienst> jarick: yes yes, but saying something as highfalutin as "pogonophobia" is like wearing a tuxedo
03:59:08 <Botje> if only we had type-level sets :[
03:59:28 <geheimdienst> as a joke, fine. if you're serious, it's likely you're not exactly sane
03:59:39 <ksf> I took that list from the man page
03:59:47 <jarick> geheimdienst: But my colleagues have already established my sanity!
04:00:14 <ksf> with splice it's bound to be correct, but I don't think not throwing an exception to catch unexpected errnos is a good idea in the general case.
04:01:05 <benmachine> Botje: context aliases?
04:01:07 <geheimdienst> if someone's sanity needs to be "established" first, i get a little worried
04:01:08 <geheimdienst> ;-)
04:01:33 <ksf> context aliases are doable even now with UndecidableInstances
04:01:46 <ksf> it's still better than carrying too big contexts around
04:01:55 <jarick> geheimdienst: This is true...
04:02:21 <ksf> but I don't think control-monad-excetpion is overly verbose
04:04:11 <ksf> "pogonophophia" sounds like jumping into mosh pits
04:06:38 <mreh> I'm not insane! Ask the man with one arm! He'll tell you!
04:07:15 <TacticalGrace> ivanm: I'm not sure
04:07:16 <mreh> @wn highfalutin
04:07:17 <lambdabot> *** "highfalutin" wn "WordNet (r) 2.0"
04:07:17 <lambdabot> highfalutin
04:07:17 <lambdabot>      adj : affectedly genteel [syn: {grandiose}, {hifalutin}, {highfaluting},
04:07:17 <lambdabot>             {hoity-toity}, {la-di-da}]
04:07:23 <ivanm> TacticalGrace: hmmm...
04:07:37 <TacticalGrace> ivanm: as it's semester break, many will be closed
04:07:44 <ivanm> that's what I figured :s
04:07:54 <ivanm> oh well, I'm sure we can organise food runs by people with cars, etc.
04:07:59 <ivanm> TacticalGrace: on another matter: is getting superclass constraints for type families looking like it'll be ready for 6.14?
04:08:00 <TacticalGrace> in any case, there are quite a few restaurants and coffee shops around UNSW
04:08:45 <TacticalGrace> there are two local shopping districts (Randwick and Kensington) in walking distance
04:08:54 <kamatsu> TacticalGrace: Isn't it Week 0?
04:08:54 <ivanm> *nod*
04:09:05 <ivanm> kamatsu: it ends the day before classes start
04:09:06 <TacticalGrace> too far, to just grab a coffee, but close enough for lunch etc
04:09:11 <kamatsu> ivanm: right, week 0
04:09:17 <TacticalGrace> kamatsu: hmm, probably
04:09:20 <ivanm> whatever you want to call it ;-)
04:09:20 <kamatsu> the shops are all open in week 0
04:09:25 <geheimdienst> uh, it means bombastic. pompous
04:09:25 <geheimdienst> (what does that mean, "affectedly genteel"?)
04:09:30 <ivanm> kamatsu: on a weekend as well?
04:09:32 <ivanm> @wn bombastic
04:09:33 <lambdabot> *** "bombastic" wn "WordNet (r) 2.0"
04:09:33 <lambdabot> bombastic
04:09:33 <lambdabot>      adj : ostentatiously lofty in style; "a man given to large talk";
04:09:33 <lambdabot>            "tumid political prose" [syn: {declamatory}, {large}, {orotund},
04:09:33 <lambdabot>             {tumid}, {turgid}]
04:09:40 <kamatsu> ivanm: potentially not, but at least on friday they will be
04:09:41 <ivanm> geheimdienst: ^^
04:09:46 <ivanm> kamatsu: *nod*
04:23:55 <ksf> hmmm things get a bit hairy with cme and sticking monads through monads
04:29:42 <ksf> HOWTO make your code not compile by making typing too strong
04:31:29 <quicksilver> Yo dawg, I heard you liked control flow, so I put a monad in your monad so you can throw while you throw?
04:32:22 <ksf> err yes.
04:33:30 <ksf>       Expected type: EMT AnyException (EMT l IO) b
04:33:30 <ksf>       Inferred type: EMT AnyException (EMT l (EMT l IO)) b
04:33:32 <ksf> and stuff
04:34:17 * geheimdienst hates shaky wifi
04:35:57 <ksf> it doesn't help that iteratees come with their own exception handling which is utterly incompatible to cme
04:36:32 <ksf> ...that is, enumerators can't throw things that iteratees catch with emt, just the other way round.
04:37:15 <geheimdienst> EMT = emergency medical technician?
04:37:38 * ksf thinks he should go shopping, meditating on the way about whether to waste the rest of the day on trying to get cme to run with iteratees or throwing it out completely.
04:37:47 <ksf> that's the cme monad transformer
04:38:07 <geheimdienst> oic
04:38:23 <ksf> and I haven't seen join on the transformer monad, yet.
04:38:53 <ksf> (I actually meant what I wrote there)
04:39:03 <ksf> ... the (monad transformer) monad
04:41:05 <Botje> please state the nature of the monadic emergency
04:41:43 * ksf decides to stop fooling around and get the whole stuff into a state where it's integrateable into combinatorrent asap
04:41:54 <ksf> ...and meditate about how to go about that while shopping.
04:42:36 <geheimdienst> this is what the emergency monadic hologram aboard starfleet ships would look like: http://twitter.com/account/profile_image/donsbot?hreflang=en
04:42:57 <Eelis> a twitter login page?
04:43:13 <geheimdienst> uh, a picture of don stewart
04:43:35 <Eelis> i only get a twitter login page
04:43:49 <exDM69> me too, no pictures
04:43:52 * benc__ also gets login page
04:45:44 <fasta> We should have a ban on login only pages here. 
04:46:11 <benmachine> seems too rare to bother banning
04:46:32 <benmachine> it's generally covered under off-topic-not-allowed anyway
04:46:55 <geheimdienst> guys, i'm sorry. i'm logged in to twitter and have no way of telling whether a link needs logging in or not. it was just a picture of don stewart as a silly joke 
04:47:15 <geheimdienst> as far as i am concerned, we can now just move on
04:47:55 <fasta> I was thinking of something like lambdabot visiting the page, detecting whether or not it is a login page, and then replying in channel "user foobar pasted a <some witty text here saying how useless it is>"
04:47:56 <Zao> Shunning tends to be enough.
04:47:58 <Zao> Shuuuun.
04:48:21 <fasta> geheimdienst, I don't care particularly about it, if you have that impression. 
04:48:25 <benmachine> fasta: you want to provide the plugin? :P
04:48:37 <fasta> benmachine, I have more important things to do :)
04:48:51 <benmachine> heh
04:48:55 <fasta> You can reply that when a newbie asks for a silly project to do.
04:49:14 <benmachine> nah, lambdabot code is far too evil for newbie eyes I think
04:49:38 <benmachine> or at least it's years old and crufty as all heck
04:52:49 <geheimdienst> as an aside: how would one implement a login page detection, anyway? short of detecting "redirect to twitter.com/login", which would mean you need to maintain a list of hard-coded urls
04:53:12 <ksf> a first step would be to detect redirects
04:53:29 <geheimdienst> yeah but it might just as well be a legitimate redirect
04:53:31 <benc__> lambabot posting a note that the URL leads to a redirect to "this url"
04:53:36 <benc__> so that you can eyeball the URL
04:53:38 <ksf> unlikely if it's pasted
04:53:42 <Zao> ksf: That would ruin tinyurls etc.
04:53:54 <benc__> interestingly that would de-ref tinyurls too, i guess
04:54:03 <ksf> proper tinyurls don't auto-redirect
04:54:12 <Zao> For your definition of "proper".
04:54:23 <benc__> ksf: they host the content right on the tinyurl server ;)
04:54:29 <geheimdienst> i guess there's no clean way of telling whether a url gave you the proper resource or the "you need to jump through some hoops first" page
04:54:35 <Zao> What about JS?
04:55:27 <ksf> lambdabot wrote her thesis about strictly typed js, I don't think that's a problem for her.
04:58:07 <Zao> @vixen Can JS really be strictly typed or is it a type dream?
04:58:08 <lambdabot> yup, really
04:59:30 <benmachine> you could check the page for a password form but I guess those could exist on contenty pages as well
05:06:49 <ksf> semantic web!
05:11:04 <ivanm> TacticalGrace: on another matter: is getting superclass constraints for type families looking like it'll be ready for 6.14?
05:31:13 <TacticalGrace> ivanm: spj is currently rewriting quite a bit of the type checker again
05:31:26 <TacticalGrace> I'm not sure when that will be completed
05:31:40 <TacticalGrace> and I don't think there will be any major additions before that
05:38:40 <Axman6> TacticalGrace: why's he rewriting it?
05:39:19 <TacticalGrace> I think, he likes undertaking heart lung transplants on GHC :)
05:39:44 <Axman6> lol :)
05:40:36 <TacticalGrace> Basically, there are two separate constraint solvers in there now
05:40:46 <quicksilver> TacticalGrace: it's part of bet he has undertaken that, if a paper on the GHC type checker/inference is ever presented at a conference or published in a journal, it should be obsolete by the time it is given/read.
05:40:56 <TacticalGrace> one for classes and implication constraints and one for equality constraints
05:40:59 <quicksilver> who made the bet with him is unknown.
05:41:01 <TacticalGrace> that leads to problems
05:41:58 <TacticalGrace> the plan is to integrate it all into The One Great Unified Constraint Solver
05:42:01 <TacticalGrace> It's all in http://haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
05:42:50 <TacticalGrace> quicksilver: ;)
05:43:50 <exDM69> what about generic algebraic data types? is the haskell' type system going to be based on that?
05:44:12 <exDM69> SPJ, et. al research paper from fall 2009 
05:44:54 <Axman6> ... when did the haskell wiki get to ugly?
05:45:14 <Axman6> so*
05:46:47 <aristid> @pl \f g h -> f . g . h
05:46:47 <lambdabot> (. (.)) . (.) . (.)
05:46:59 <aristid> is there a better point-free way of writing this?
05:47:48 <quicksilver> @pl \f g h -> [f,g,h]
05:47:48 <lambdabot> (. ((. return) . (:))) . (.) . (:)
05:47:51 <Axman6> :t \f g h -> const h >>= const g >>= const f
05:47:52 <lambdabot> forall a b a1 b1. (b -> b1) -> (b -> a1) -> a -> b -> b1
05:47:53 <quicksilver> I don't think so, no.
05:48:03 <geheimdienst> don't the guys on reddit write ( . ) ( . ) for boobies, or something ...
05:48:14 <geheimdienst> @pl \f g h -> f . g . h
05:48:14 <lambdabot> (. (.)) . (.) . (.)
05:48:29 <Axman6> geheimdienst: that's far far older than reddit
05:49:38 <benmachine> Axman6: post-compromise
05:49:48 <benmachine> I've heard it's something to do with restoring from backups
05:49:50 * benmachine shrug
05:50:07 <Axman6> there was a compromise?
05:50:47 <benmachine> when haskell.org was down for ages
05:51:16 <Axman6> ah
05:53:33 <geheimdienst> > show "abc"
05:53:34 <lambdabot>   "\"abc\""
06:00:37 <quicksilver> benmachine, Axman6: looks as simple as a missing css file to me
06:00:53 <benmachine> quicksilver: well, perhaps, but the logo is also different
06:00:59 <Axman6> i hope so, because it
06:01:03 <Axman6> it's damn ugly :(
06:02:53 <ivanm> quicksilver: yeah
06:02:55 <danderson> probably a silly question, but why does GHC have Cmm as an intermediate between STG and the codegen backends?
06:03:09 <danderson> my understanding was that STG was low-level enough that it would feed directly into code generation
06:03:13 <benmachine> http://haskell.org/haskellwiki/MediaWiki:Standard.css maybe this has something to do with it
06:03:15 <danderson> clearly I'm confused and mistaken
06:03:36 <ivanm> danderson: not for the native code gen it doesn't
06:03:55 <ivanm> the pseudo-Cmm is there for the C backend (and I believe for the LLVM backend)
06:04:34 <danderson> I can kinda see why for the C backend, but why LLVM as well?
06:05:09 <ivanm> because they go via the C interface to LLVM
06:05:10 <Axman6> because it's easier to make a Cmm -> LLVM IR translator
06:05:18 <ivanm> it's not up to generating LLVM bytecode directly ;-)
06:05:20 <Axman6> no they don't ivanm 
06:05:28 <ivanm> Axman6: oh? I thought they did
06:05:31 <Axman6> no
06:05:40 * ivanm apologises most humbly to danderson and Axman6 
06:05:56 <danderson> generating LLVM bitcode by hand is generally a bad idea anyway, the builder API is there for good reason
06:05:59 <Axman6> there's no C involved. they create LLVM assembly, and then use LLVM to compile it (i believe anyway)
06:06:23 <ivanm> danderson: which is why I thought they were going via the C bindings to LLVM
06:06:51 <danderson> well, if the backend generates LLVM assembler (the ascii form), that's not too hard
06:06:56 <danderson> it's just annoying
06:07:12 <danderson> since you have to handle all the SSA, variable naming and control flow by hand
06:07:35 <danderson> instead of building a nice abstract code DAG and telling LLVM to figure it out ;)
06:07:57 <danderson> anyway, so NCG doesn't go via Cmm?
06:08:31 <danderson> I should say that I'm reading the draft paper on the LLVM backend, which is what is prompting all these philosophical questions
06:09:05 <quicksilver> danderson: the NCG does go via Cmm as far as I'm aware.
06:09:10 <Axman6> i don't know if this is how it actually works
06:09:26 <danderson> clearly I need to spend some quality time with the GHC source code at some point
06:09:32 <quicksilver> danderson: the justification is that, otherwise, you duplicate an awful lot of work between two different native backends
06:09:36 <quicksilver> (sparc and i386, say)
06:09:44 <ivanm> quicksilver: it does? :o
06:10:02 <quicksilver> Cmm is intended as a kind of portable assembly; it has a very simple purpose to LLVM although huge differences in practice
06:10:09 <danderson> that's what the LLVM paper's diagram says too.
06:10:20 <ivanm> huh, the GHC docs agree with you: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/NCG
06:10:22 <danderson> Haskell -> Core -> STG -> Cmm -> {LLVM, NCG, C}
06:10:29 <quicksilver> they both try to abstract the similarities between different native backends.
06:10:48 <quicksilver> in another universe, another GHC might have forgone Cmm entirely
06:10:52 <quicksilver> and just used LLVM for that purpose
06:10:57 <ivanm> and the LLVM backend generates LLVM assembly: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Design
06:11:00 <quicksilver> however there were all kinds of reasons that didn't happen.
06:11:05 <ivanm> quicksilver: if LLVM was developed earlier on?
06:11:26 <quicksilver> if LLVM was much *better* developed early on, as well as very different in all sorts of ways.
06:11:56 <danderson> basically, if it had been a viable competitor to C-- at the time the decision was made?
06:12:20 <quicksilver> roughly, yes
06:12:26 <quicksilver> although SPJ was personally quite involved in C--
06:12:40 <quicksilver> (Also, just to be pedantic, Cmm is not C--)
06:13:17 <danderson> heh
06:13:43 <quicksilver> there were good reasons why LLVM made a poor target for GHC; some of those reasons were a question of taste, some of them are now obsolete because hardware architecture is so different, some of them are now obsolete because GHC is so different.
06:13:58 <quicksilver> ...and some are obsolete because LLVM is so different.
06:14:07 <quicksilver> There are at least 4 separate axes of change in that time span.
06:16:20 * edwardk waves hello.
06:17:04 * dafis waves back
06:17:11 <Axman6> o/
06:18:00 <pastorn> preflex: seen conal
06:18:00 <preflex>  conal was last seen on #haskell 4 days, 22 hours, 7 minutes and 43 seconds ago, saying: ah -- "Haskell -- the language of happy elitists"
06:18:23 <edwardk> well at least we get to be happy
06:19:12 <danderson> quicksilver: understandable. Everything changes (except for dead things)
06:19:27 <benmachine> quicksilver: so what's Cmm? it's fairly hard to google three-letter thing
06:19:27 <benmachine> s
06:19:40 <geheimdienst> c minus minus?
06:19:42 <Zao> A variant on C--, a nice cuddly intermediary langauge.
06:19:43 <danderson> GHC's internal dialect of C--
06:19:50 <Zao> It should be documented on the dev wiki/
06:19:56 <benmachine> oic
06:20:01 <danderson> C-- spoken with a heavy haskell accent
06:20:35 <benmachine> heh
06:20:44 <benmachine> (looks like cminusminus.org expired?)
06:20:46 <Zao> http://hackage.haskell.org/trac/ghc/wiki/Commentary
06:21:15 <quicksilver> benmachine: it's GHC's implementation of C--, which is different from the cminusminus.org one
06:21:23 <quicksilver> I don't know what the differences are, or why.
06:21:26 <edwardk> benmachine: cminusminus was at one point supposed to be a nice cross-compiler way of writing fairly low level but portable-ish code. in practice, ghc was sort of the killer app for it and the other adopters never materialized.
06:22:01 <edwardk> (yes there are a few, but overall, it turns out that each implementation is different from the next, so in some senses it failed its design goals)
06:22:05 <quicksilver> I harbor dark suspicions that the NCG, in practice, relies on Cmm passing through some rather GHC-specific notions which would be out of place in a truly general intermediate language.
06:22:25 <quicksilver> But these are only dark suspicions, because I'm not familiar with the details.
06:22:35 <geheimdienst> how do i tell ghc to exclude a package when --make'ing? the package i'm trying to resolve an "ambiguous import" error
06:23:41 <edwardk> norman ramsey was sort of the big driving force behind c-- outside of ghc as i understand it, and when he didn't get tenure over at harvard the amount of attention it received took a bit of a nose dive. he's over at tufts and happy now, so it may pick up
06:23:47 <lajla> So, how long did it took you guys to switch to functional programming?
06:24:00 <ttmrichter> Who switched, lajla?
06:24:06 <pastorn> lajla: "switch to"?
06:24:12 <pastorn> i don't really know anything else...
06:24:16 <edwardk> lajla: 4-5 months before my brain fully flipped over ;)
06:24:23 <ttmrichter> I added functional programming to my toolbelt.
06:24:29 <ttmrichter> I didn't switch.
06:24:44 <Zao> ttmrichter: Didn't you get the memo? Languages are mutually exclusive.
06:25:09 <ttmrichter> Zao: A memo is a piece of paper.  Like a contract.  Easily dispensed with.  :D
06:25:41 <Zao> Garbage collected I guess.
06:25:43 <lajla> Well
06:25:45 <lajla> that's how they call it
06:25:50 <lajla> learn how to handle a functional style.
06:25:56 <quicksilver> edwardk: but it's hard for C-- to replace llvm now - there may be all kinds of differences, all kinds of reasons to prefer C--, LLVM is here, it works, it has a framework for optimisations, it has a good variety of native code backends, it has cool stuff like JIT, ....
06:26:03 <winxordie> lajla:   It took me till a few months ago to realize that I was trying to program functionally in C the entire time, so not long at all. :P
06:26:25 <quicksilver> edwardk: (to be clear I'm now not talking about GHC, but about 'A. N. Other compiler looking for a backend')
06:26:43 <ttmrichter> lajla: It took me about six months to grok basic functional programming enough to be semi-productive with it.  I haven't mastered it yet.  (I started looking at it in '98.)
06:26:49 <edwardk> quicksilver: i agree, llvm leapt in to fill that void.
06:27:34 <lajla> winxordie, C was your first language?
06:28:01 <ttmrichter> winxordie: I hear you there, actually.  I've been trying to get the benefits of functional programming without the language support since I was ... let's just say an embarrassingly long time ago and leave it at that.
06:28:21 <winxordie> lajla: yeah. I went C -> C++ -> C.
06:29:21 <winxordie> ttmrichter: Good to hear it's not just me.
06:29:55 <ttmrichter> I remember when I switched to C, myself.
06:30:42 * geheimdienst shudders at "switched to C". geheimdienst thinks C has its niche and so on, but all in all C is a necessary evil
06:30:55 <quicksilver> edwardk: I wonder if the new interesting direction for a language like haskell is just-in-time optimisation or compilation.
06:30:57 <ttmrichter> What came before it was worse, geheimdienst.
06:31:10 <ttmrichter> I mean what came before it *for me*.  Just to be clear.
06:31:34 <quicksilver> edwardk: to fix up all the broken stuff we have which only works if inline does the right thing and RULES are visible in the right place and the wind is in the right direction.
06:31:40 <ttmrichter> My first language was literally wires.  :D  But that doesn't count.  It was an educational kids thing.
06:31:48 <edwardk> quicksilver: i'd like to try some of the tricks i've been exploring for kata in a larger haskell context. the spineless tagless g-machine and a tracing jit are a beautiful combination
06:32:07 <ttmrichter> About 32 long slider switches connected to 16 lights that you wired in "programs" for fun and profit.
06:32:11 <edwardk> quicksilver: but that is rather ambitious given the other draws on my time at the moment =(
06:32:52 <quicksilver> ttmrichter: how much profit?
06:32:54 <quicksilver> :-)
06:32:58 <ttmrichter> Approximately 0.
06:33:00 <lajla> winxordie, and now you still program in C?
06:33:01 <ttmrichter> Give or take.
06:33:18 <quicksilver> edwardk: edwardk has never lacked ambition. :P
06:33:34 <edwardk> quicksilver: =)
06:33:43 <quicksilver> edwardk: but GHC is big enough to be quite a challenge to hack on
06:33:53 <quicksilver> takes quite a long time to see enough of the big picture to understand which way to proceed.
06:33:55 <ManateeLazyCat> What's your favorites multimedia player? I want do an investigation before i implement it with gtk2hs. Thanks!
06:34:03 <winxordie> lajla: I haven't programmed in C in months. I'm running around with lua now for a bit of game development.
06:34:10 <ManateeLazyCat> mplayer, vlc, or mpc?
06:34:15 * quicksilver spent a few weeks work of train journeys examining GHC code before running out of copious free time.
06:34:21 <lajla> winxordie, and Haskell?
06:34:28 <EvanR-work> ManateeLazyCat: mplayer is king
06:34:54 <winxordie> lajla: I use haskell all the time, but not any hardcore features. I mostly use it for math research. :P
06:34:57 <edwardk> quicksilver: yeah there is a reason why i haven't tried to port my jit over to it in its entirety. I did take a few small programs and mock things up to see how well i could predict thunks using a polyinline cached tracing jit though, and was very pleased with the results
06:35:07 <fasta> EvanR-work, I have the impression that vlc currently is.
06:35:11 <ManateeLazyCat> EvanR-work: If i build a gtk2hs client for mplayer, what's the feature you want add?
06:35:13 <EvanR-work> wrong
06:35:37 <quicksilver> edwardk: very interesting...
06:35:39 <EvanR-work> ManateeLazyCat: sounds pointless, because you cant expose all the functionality with a gui ;)
06:35:40 <edwardk> quicksilver: it'd be difficult to extrapolate what end performance would be like, but it eliminated all the indirect jumps in my tests
06:36:02 <edwardk> considering there are 2 for every case...
06:36:12 * ManateeLazyCat I'm not multimedia mplayer expert, so i want listen your guys suggestion, then i can implement you want feature in my gtk2hs/haskell client.
06:36:16 <fasta> EvanR-work, why would that be wrong? 
06:36:28 <fasta> EvanR-work, they use mostly the same libraries.
06:36:41 <edwardk> In larger problems clearly I wouldn't get such beautiful coverage, but still
06:36:44 <ManateeLazyCat> EvanR-work: I mean integrate feature, example lyric display, wiki information, or other cool thing. :)
06:36:45 <fasta> EvanR-work, still for some reason vlc appears to be more stable. 
06:36:48 <EvanR-work> library shmibary
06:37:03 <EvanR-work> some reason and appears, interesting analysis
06:37:07 <EvanR-work> get your flames on
06:37:20 <ManateeLazyCat> EvanR-work: expose mplayer in gtk+ widget is so easy, so i want other cool feature you want. :)
06:37:32 <edwardk> i started working on just trying to jit the ghc bytecode but then mmorrow vanished, and i lost the person who i was bouncing ideas off ;)
06:37:51 <EvanR-work> ManateeLazyCat: playing a video maybe. but theres a lot of options and adjustable parameters its just too many
06:37:52 <quicksilver> :(
06:37:55 <fasta> EvanR-work, I also don't need an analysis to know that a BMW works better than a Fiat.
06:38:09 <quicksilver> let me count the ways I morn mmorrow's disappearance
06:38:13 <fasta> EvanR-work, I used both, and vlc works better for my purposes :)
06:38:20 <ttmrichter> fasta: which era's BMW vs. which era's Fiat?
06:38:24 <ManateeLazyCat> EvanR-work: Yes, i want build a buffer for music-list manager, then other buffer for video display.
06:38:24 <EvanR-work> a cant argue with that
06:38:27 <EvanR-work> i*
06:38:29 <ttmrichter> BMWs in the '80s sucked.  Badly.
06:38:36 <ManateeLazyCat> EvanR-work: But i haven't to design, but will do it soon.
06:38:45 <ManateeLazyCat> EvanR-work: Since my core has finish. :)
06:38:56 <benmachine> quicksilver: some people had the idea of calling the number listed in whois for moonpatio.com, but I think no-one was bold enough to do so
06:39:02 <fasta> ttmrichter, this was in 2008 or so, I don't own one. 
06:39:50 <edwardk> benmachine i actually have his number
06:40:07 <ksf> of course bmws suck. how can you expect good cars from a people who can't even brew beer?
06:40:08 <benmachine> edwardk: oh ok, neat
06:41:04 <fasta> Belgians should produce cars soonish then. 
06:41:17 <ManateeLazyCat> quicksilver: morrow told me he won't login #haskell. 
06:41:27 <ksf> I think they're too busy disintegrating their state
06:41:43 * ManateeLazyCat bazinga 
06:41:44 <fasta> That won't happen for the next few years.
06:41:48 <edwardk> ManateeLazyCat: is it our breath?
06:41:49 <benmachine> ksf: and replacing it with writer?
06:42:05 <ManateeLazyCat> Because morrorw is busy on his new ghc. :)
06:42:51 <ManateeLazyCat> edwardk: I last time seen morrow, he told me he is busy on it's new haskell compiler, to support script feature something.
06:43:28 <ManateeLazyCat> edwardk: But since then I never saw him.
06:44:27 <ManateeLazyCat> fasta: Why vlc is better? I want to know. Thanks!
06:44:45 <ManateeLazyCat> fasta: What's the favorites of vlc?
06:45:13 <fasta> ManateeLazyCat, as EvanR-work pointed out I could not offer anything by my own limited experience (but you should wear sunscreen).
06:45:21 <fasta> but*
06:46:07 <ManateeLazyCat> fasta: I'm not mean which multimedia player is better, i just want to know which feature you like, then i add my client code. :)
06:46:10 <edwardk> Hrmm in a lot of ways writing an actual Haskell compiler to test my backend code is easier than nailing down kata's front end long enough to test the back end code ;)
06:46:51 * hackagebot regions 0.6.0.1 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.6.0.1 (BasVanDijk)
06:46:53 <fasta> ManateeLazyCat, a player should play all formats, it should have sane keybindings (meaning the same as existing players) and that's basically it. 
06:47:10 <fasta> ManateeLazyCat, the other features are pretty much gimmicks. 
06:47:30 <fasta> Naturally, someone will point out in 3,2,1 that there are some other features they like.
06:47:43 <ManateeLazyCat> fasta: AFAIK, mplayer and vlc is best mplayers about formats support.
06:47:46 <fasta> But it is also hugely off-topic. 
06:48:27 <ManateeLazyCat> mpc is cool, but don't support video.
06:49:47 <EvanR-work> i dont think playing a movie in the correct display format on an ipod/old cell phone/gameboy is a gimmick
06:51:10 <ManateeLazyCat> EvanR-work: Go ahead, more suggestion.... :)
06:51:28 <EvanR-work> gui features for a mplayer wrapper?
06:51:32 <pastorn> EvanR-work: if you can play any kind of movie on a Z80, i will be migtily impressed
06:51:35 <EvanR-work> i guess a playlist is all that matters
06:51:38 <ManateeLazyCat> EvanR-work: Of course.
06:52:15 <ManateeLazyCat> EvanR-work: Infact, i use emms (Emacs Multi Media System) for a mplayer client, but i want build a better one.
06:52:27 <ManateeLazyCat> EvanR-work: Embedded video in it.
06:52:59 <ManateeLazyCat> EvanR-work: And not just playlist.
06:53:35 <ManateeLazyCat> EvanR-work: I want build efficient client for geek, all operation finish  by keyword.
06:54:22 <fasta> ManateeLazyCat, Emacs is sluggish for that stuff. 
06:54:41 <ManateeLazyCat> fasta: Yes, i know. 
06:54:51 <EvanR-work> if the geek doesnt have X :) ?
06:55:11 <ManateeLazyCat> fasta: I think you have know that, i'm a emacs judas . :)
06:56:03 <ManateeLazyCat> EvanR-work: I think gtk+ is not problem. :)
06:56:19 <fasta> EvanR-work, on a gameboy? That is sort of nice, but the first gameboys where only two color, so it remains a gimmick. 
06:56:20 <ManateeLazyCat> EvanR-work: But i don't know how to play mplayer on Windows. :)
06:56:30 <fasta> were*
06:56:31 <EvanR-work> fasta: not the original gameboy!
06:56:42 <EvanR-work> ManateeLazyCat: linux framebuffer, i mean
06:56:59 <fasta> EvanR-work, the Gameboy color was in color.
06:57:13 <EvanR-work> i am out of the loop in that i see the 'DS' as a gameboy
06:57:17 <ManateeLazyCat> EvanR-work: I just support gtk+ GUI program.... :) 
06:57:32 <fasta> EvanR-work, the one before that one, was not, because obviously they wouldn't name the Gameboy color, a Gameboy color.
06:58:10 <EvanR-work> i know capabilities of the original few gameboys
06:58:27 <EvanR-work> newer 'gameboys' could in principle play a movie
06:58:34 <emmanuelux> gameboys 1990 ?
07:01:18 <earthy> gameboy advance, right? :)
07:01:37 <EvanR-work> yes those, but i was thinking of DS
07:01:51 <EvanR-work> which i know is not a gameboy, sorry for offending nintendo fanboys
07:02:09 <quicksilver> you can play realtime video on a 286 PC with an EGA display
07:02:12 <quicksilver> it's on youtube somewhere
07:02:22 <quicksilver> gameboy color is more powerful than that, in general
07:02:31 <earthy> don't need to see it on youtube. saw it back in the day in real life.
07:02:36 <EvanR-work> fewer colors though
07:03:26 <EvanR-work> i watched 'real time' videos on all sorts of dos games
07:03:32 <earthy> (although the 4-bit grayscale versions on a 'paperwhite' screen looked better)
07:03:35 <EvanR-work> back when they used puppets
07:06:08 <alexyk> dafis: thanks for the improvements, gets a very respectable 16 day run on full data before getting stuck :)
07:06:12 <jdsc> hi everyone :)
07:07:06 <dafis> alexyk: memory usage?
07:07:54 <ManateeLazyCat> Thanks anyone for suggestions! :)
07:08:08 <ManateeLazyCat> s/anyone/everyone
07:08:12 <alexyk> dafis: probably a bug in ghc like Simon suspects -- it's very perky jumping through days from 1 to 16 in much less memory than before, not growing much; then it's stuck and RAM goes up and up
07:08:32 <alexyk> if I restrict it to say -M30G from the get go it reaches 7 days and segfaults
07:08:58 <alexyk> although I don't know if it's expected and how does -A1G figures into it
07:09:07 <dafis> alexyk: suspicious indeed
07:09:44 <jdsc> Is is hard to understand the code of the snap server? I read the routing module, but I imagine the rest to be much harder (http parser, iteratee, libevent, etc)
07:10:05 <alexyk> dafis: I also very happily eliminated another M.lookup replacing M.mapWthKey tick ... by intersectionWith tick ustats termsStats
07:10:24 <jdsc> I'm using the snap server to implement a REST api and it's a pleasure to work with :)
07:10:25 <dafis> alexyk: -A1G should make garbage collection a reasonably rare occasion, but it should cause breakage
07:10:44 <alexyk> dafis: I had -A5G before :)
07:10:45 <dafis> alexyk: I'll try that out
07:11:06 <jmcarthur> @seen sinelaw
07:11:06 <lambdabot> Unknown command, try @list
07:11:07 <dafis> alexyk: the inetrsectionWith tick, not -A5G :)
07:11:41 <alexyk> yeah :)  you're braver indeed trying it on a 1 G RAM total :)
07:11:58 <dafis> alexyk: typo above, s/ir should/it shouldn't/
07:12:09 <dafis> *it*
07:13:23 <dafis> alexyk: with what you had in your repo yesterday, it died after 26 days on the sample data
07:14:18 <alexyk> dafis: I've pushed with tag cafe3 for the intersectionWith update in your SocRun.hs.
07:14:50 <alexyk> dafis: I now resigned myself to carefully rewriting with IntMap :)
07:14:53 <quicksilver> alexyk: intersectionWith is one of my favourite functions.
07:15:11 <quicksilver> alexyk: it's such a surprisingly flexible and powerful combination.
07:15:17 <dafis> alexyk: but if you run it for a shorter period, say 10 days, it outputs the counts pretty quickly, but takes a loong time afterwards to finish the calculation
07:15:40 <alexyk> quicksilver: I'm not surprised as in Clojure it's merge-with and also much admired :)
07:16:12 <alexyk> actually I use intersectionWithKey there
07:16:17 <dafis> alexyk: with more strictness, the counts are output more slowly, but when they're output, the work has been pretty much done and not deferred until the very end
07:16:57 <alexyk> dafis: yeah, funny how it just sits there in teh end...  on my box the sample data eats 10G.  I wonder how you run it!
07:17:33 <dafis> alexyk: +RTS -M700M -A128M -H512M
07:18:08 <alexyk> dafis: pushed the tag cafe3 now, too. Always forget --tags to git push at first.
07:18:13 <dafis> alexyk: uses 659M in total, according to -s with what I mailed yesterday
07:18:34 <alexyk> dafis: so it's that -A1G I give it which makes it consume like cray?
07:18:38 <alexyk> crazy cray
07:19:24 * hackagebot hstatistics 0.1.0.2 - Statistics  http://hackage.haskell.org/package/hstatistics-0.1.0.2 (VivianMcPhail)
07:19:44 <mreh> I like how appending an h makes a haskell module
07:20:32 <Zao> prepending?
07:20:50 <geheimdienst> shtatistics
07:20:59 <Zao> Appending makes things british.
07:21:02 <Zao> statisticsh.
07:21:18 <geheimdienst> i guess mine would be german then
07:21:52 * geheimdienst likes how the submitter's name is Vivian McPhail
07:21:52 <hpc> and it would be russian if it was tsatistics
07:22:00 <geheimdienst> lol
07:22:08 <akosch> can i run hoogle --info with lamdabot somehow?
07:22:10 <hpc> haha, McPhail
07:22:32 <alexyk> dafis: I got, with your RTS settings, heap exhausted at dat 19 (with intersectionWith) -- is your box 64-bit or 32-bit?
07:22:50 <geheimdienst> 'tistics or 'tics would be the name in redneck
07:23:14 <mreh> I suspect that's an alias
07:23:37 <hpc> geheimdienst: i think you mean "lies", not "'tistics"
07:23:46 <dafis> alexyk: I don't think so. Reading in the sample data fills five-hundred-something MB, extrapolating to 35 times the users, you'd be at ~20G. Then you need some space for the real computations. I think the consumption is due to thunks built during the calculation which aren't evaluated soon enough
07:24:12 <dafis> alexyk: 32 bits, of course. Ever seen a 64-bit machine with only 1G RAM?
07:24:26 <alexyk> dafis: who knows, maybe it's zen :)
07:24:26 <EvanR-work> dafis: yes
07:24:40 <EvanR-work> most of the smaller laptops on lenovo
07:25:08 <alexyk> dafis: so your bits get you more!  JVM has lovely compressed references option which allows the whole thing to run in a 31GB JVM in Clojure fine
07:25:14 <sonoflilit> Hi
07:25:26 <sonoflilit> I'm trying to install Yi with cabal-install
07:25:34 <sonoflilit> on a quite fresh arch linux install
07:25:42 <alexyk> dafis: -M1G -K128M did it fine for the sample.
07:25:43 <sonoflilit> it isn't working out very well
07:25:45 <dafis> alexyk: so for 64 bits, double the sizes, it should run then
07:25:57 <sonoflilit> dependencies on conflicting versions of transformers
07:25:57 <alexyk> I got away with ^^ and -A -H like yours
07:25:59 <danharaj> sonoflilit: welcome to hell
07:26:22 <ManateeLazyCat> danharaj: I remember someone has ask same problem?
07:26:28 <sonoflilit> isn't it supposed to be a usable editor?
07:26:35 <alexyk> danharaj: do you mean haskell in general or just Yi? :)
07:26:38 <hpc> don't use cabal-install, is my advice
07:26:42 <alexyk> or #haskell? :)
07:26:46 <sonoflilit> hpc: then what?
07:26:51 <danharaj> alexyk: getting things to build :p
07:26:57 <hpc> wget the tar, unpack to /usr/src, and compile yourself
07:27:10 <dafis> alexyk: -H is the initial heap size, so it would got through with -H2M, it would just need to reallocate sooner :)
07:27:15 <hpc> and pray that it can work on the version you have without compile errors
07:27:34 * hpc is assuming cabal doesn't always have the correct dependencies
07:27:39 <sonoflilit> hpc: there will still be a thousand missing dependencies
07:27:44 <alexyk> dafis: ok.  will be back after a while
07:27:47 <sonoflilit> should I just abandon the idea of using it?
07:27:47 <hpc> ah, nvm then
07:27:50 <aristid> does parsec 3 use Applicative/Alternative?
07:27:58 <ManateeLazyCat> sonoflilit: Best to paste your conflict. :)
07:28:08 <danharaj> sonoflilit: have you seen this page? http://www.haskell.org/haskellwiki/Yi#From_Hackage
07:28:28 <anders^^> sonoflilit: if you check the yi maillist, there should be some mails about these things and the solution
07:30:04 <jkingkong> is there a simple way to turn a parallel list like [: t :] into a normal one like [t]?
07:31:33 <jkingkong> it looks like there's a fromP function in GHC.PArr but the library is no longer supported. What am I supposed to use instead?
07:32:25 <sonoflilit> is anyone here using Yi day-to-day?
07:32:30 <anders^^> sonoflilit: yes
07:33:29 <sonoflilit> so once I manage to install, I can expect a good user-experience?
07:33:42 <sonoflilit> or will it still be alpha-level experience?
07:34:36 <ManateeLazyCat> sonoflilit: It depends on what you want?
07:34:45 <anders^^> sonoflilit: if you want something similar to emacs, that you can extend using haskell then yes
07:35:09 <danharaj> Is Yi easier to learn than emacs?
07:35:19 <danharaj> Because I have found that my neckbeard isn't strong enough to learn emacs.
07:35:33 * hackagebot hsignal 0.1.0.2 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.0.2 (VivianMcPhail)
07:35:36 <ManateeLazyCat> anders^^: Yi has *long* way to powerful as Emacs, IMO. 
07:35:40 <sclv> I found it quite usable. I just didn't want to put in the tweaks to make it work exactly how I wanted, figure out how to extend it, etc. given that I'm comfortable with my emacs environment already.
07:35:46 <anders^^> ManateeLazyCat: yeah
07:35:59 <leimy_> I need to update my Emacs
07:36:10 <leimy_> the C mode appears broken at the moment
07:36:15 <sonoflilit> compiling, finally
07:36:22 <sclv> If it gets a few new/better integration features with the ghc api that put it above and beyond emacs, then I might really switch
07:36:50 <ManateeLazyCat> anders^^: Since Yi don't like Emacs has a build interpreter for extension language, many cool features won't be implement even you want to do.
07:37:07 <sonoflilit> by doing this I practically killed the possibility to ever use pacman to install haskell packages, right?
07:38:01 <anders^^> ManateeLazyCat: true, It would take many years to be able to be even close to emacs
07:38:08 * ManateeLazyCat But Yi is awesome educational project
07:38:34 <sonoflilit> speaking of emacs
07:38:53 <sonoflilit> what is the emacs haskell setup you guys use?
07:38:58 <ManateeLazyCat> anders^^: IMO, clone Emacs doomed to fail, Yi should he's it's own feature that Emacs haven't.
07:39:13 <leimy_> Yi has a lot of ways to be different from Emacs
07:39:17 <leimy_> the Emacs stuff is just a mode.
07:39:30 <ttmrichter> sonoflilit: Yi is great for a half-completed editor that you can hack on.
07:39:31 <ManateeLazyCat> sonoflilit: Search haskell at http://www.emacswiki.org/emacs/AndyStewart
07:39:45 <ttmrichter> sonoflilit: I wouldn't even begin to consider it for my real work.
07:39:51 <ManateeLazyCat> ttmrichter: Yes, for hacking, Yi is perfect project.
07:40:03 <leimy_> I've used Yi for real work before
07:40:24 * exDM69 didn't get the GTK version of Yi working
07:40:26 <leimy_> Leksah has Yi integration last I checkd to.
07:40:30 <leimy_> I don't like GTK so that's ok :-)
07:40:51 <ManateeLazyCat> sonoflilit: In my homepage, you will found how to : completion haskell, flymake, extension code for haskell-mode, and configuration file for haskell-mode.
07:41:42 <ManateeLazyCat> sonoflilit: Completion Haskell code is use hoogle integrate with auto-complete.el (but not too much, since hoogle don't support regular expression search).
07:43:14 <aristid> hmm somehow, it feels like tools like "happy" are un-haskelly
07:43:18 <ManateeLazyCat> Clone Emacs is insignificant since emacs/elisp has own style, the best way to build Haskell editor is find it's own style.
07:45:08 <exDM69> aristid: yes, happy is not very haskelly. but there's parsec and friends to solve that issue
07:45:17 <ManateeLazyCat> anders^^: If someday, ghc provide a feature that interpretation haskell code make it more scriptable like elisp, then we have *dynamic power* that Emacs have.
07:45:35 <anders^^> ManateeLazyCat: yeah, that would be cool
07:45:37 <Deltaf1re> i can't hear a thing
07:45:41 <McManiaC> dcoutts_: ping
07:45:46 <aristid> exDM69: yeah :)
07:45:46 <leimy_> I think that's what hsplugins was supposed to be
07:45:56 <leimy_> or at least a step in that direction
07:45:58 <ManateeLazyCat> anders^^: Before that, just Haskell static feature can't finish most cool feature that Emacs can have.
07:46:02 <leimy_> Dons started that and Yi years ago.
07:46:15 <leimy_> I remember being in this channel, when it had a lot less people, testing Yi on Mac OS X for him :-)
07:46:38 <ManateeLazyCat> anders^^: Then we can build-in a haskell-interpreter in haskell project to test experience code.
07:47:11 <ManateeLazyCat> anders^^: Like elisp environment provide that, extent Emacs-core in *runtime*.
07:47:19 <sonoflilit> ManateeLazyCat: I feel that XMonad is pretty dynamic
07:47:31 <sonoflilit> oh
07:47:34 <ManateeLazyCat> sonoflilit: That's not dynamic IMO.
07:47:49 <ManateeLazyCat> sonoflilit: That's just re-compile your configuration and relaunch new entry.
07:47:56 <ManateeLazyCat> sonoflilit: See dyre project
07:47:59 <ManateeLazyCat> @package dyre
07:47:59 <lambdabot> http://hackage.haskell.org/package/dyre
07:48:13 <sonoflilit> ManateeLazyCat: but it allows me to make ocnfiguraiton changes without having to restart
07:48:21 <sonoflilit> that's all the dynamic I feel I need
07:48:37 <aristid> parsec 3 seems to incorporate a lot of modern haskell principles \o/
07:48:54 <aristid> the docs are still hard to read
07:48:55 <ManateeLazyCat> sonoflilit: No, that's not "without restart", infact, it's just re-compile all module and relaunch *new entry"
07:49:02 <sonoflilit> damn, compilation on this machine is so sloooow
07:49:18 <sonoflilit> in terms of feel, there's no restart
07:49:19 <ManateeLazyCat> sonoflilit: Infact, it's has restart, just restore new state after relaunch.
07:49:51 <sonoflilit> nobody who hasn't seen the code or docs would think there's a restart involved
07:49:51 <ManateeLazyCat> sonoflilit: And it's not really *dynamic* like Emacs interperter.
07:50:16 <sonoflilit> what have yo done with emacs that this kind of dynamicity isn't enough for?
07:50:17 <ManateeLazyCat> sonoflilit: If your configuration is *huge* you will feeling it's in "restarting". :)
07:50:25 <sonoflilit> mmm
07:50:48 <sonoflilit> why is configuration size relevant?
07:50:49 <ManateeLazyCat> sonoflilit: You need feeling in Emacs.
07:51:14 <ManateeLazyCat> sonoflilit: Read dyre code, that's all answer you want to know.
07:51:28 <aristid> ManateeLazyCat: doesn't emacs also compile everything to bytecode first?
07:51:59 <ManateeLazyCat> aristid: But they don't need *relaunch* new entry.
07:52:48 <ManateeLazyCat> aristid: Yi and XMonad, all those re-compile technology is pretty different with Emacs's build-in interperter do.
07:53:43 <ManateeLazyCat> aristid: For elisp, you can test (run/compile) any elisp code when you run Emacs. And you don't need restart Emacs to apply those change.
07:54:02 <ksf> metacircularity is going to come at the same time as jit
07:54:13 <ManateeLazyCat> aristid: That's why emacs can add new feature so *fast*...
07:55:13 <ManateeLazyCat> aristid: If you want some handy feature, you can ask in #emacs, i think most old Emacs hacker will give your answer in 5 mintues, they can test new code when you ask .... :)
07:55:23 <ManateeLazyCat> aristid: And those don't need restart Emacs.
07:55:51 <aristid> ManateeLazyCat: so compiling is ok, it's the restart of the whole editor that disturbs you?
07:56:46 <ManateeLazyCat> aristid: The real problem is not whether re-compile/restart editor, it's the status of current session. 
07:56:57 <ksf> xmonad does that just fine
07:57:06 <ManateeLazyCat> aristid: In Emacs, you can add any new feature and won't lost all "status"
07:57:19 <aristid> i thought you said that yi saves the status
07:57:28 <ksf> you can end up with state that's not restarted, but that's then because you changed the config in a way that makes it impossible to automatically carry the state over
07:57:55 <ManateeLazyCat> aristid: For re-compile tech, you need save status before re-compile, and restore those status after relaunch.
07:58:28 <ksf> ideally that should be exact the same thing as a single mainloop run.
07:58:40 <ksf> ...just changing the mainloop in the process
07:58:53 <ManateeLazyCat> ksf: So the solution is build a good layout, make core won't change. then you don't need restart current entry, just re-compile extension module.
07:59:18 <ksf> yeah that's fine, too
07:59:24 <ksf> yi should definitely do that
08:00:32 <ManateeLazyCat> ksf: Infact, the key of *dynamic* tech not whether restart, user don't care it. User really care is keep current status won't lost after re-compile.
08:01:08 <sonoflilit> ManateeLazyCat: so XMonad does that, doesn't it?
08:01:09 <ManateeLazyCat> ksf: We even can add some *delay relaunch* make user can't feeling the time cost in re-compile/relaunch
08:01:21 <quicksilver> it's not trivial to save *all* state though.
08:01:28 <quicksilver> requires you to plan that beforehand.
08:01:28 <ManateeLazyCat> sonoflilit: I think Yi and XMonad use same tech since they're develop by dons.
08:01:52 <ksf> it goes by the name of StateT and knowing your IO
08:02:01 <sclv> ManateeLazyCat: that's not why. they use the same gist because it makes sense.
08:02:07 <edwardk> preflex: xseen tommd
08:02:07 <preflex>  tommd was last seen on freenode/#haskell 9 hours, 50 minutes and 18 seconds ago, saying: I'd like cheap SPI Flash more.
08:02:13 <Saizan> sonoflilit: XMonad restarts completely passing the state via stdin
08:02:17 <quicksilver> and in some cases it makes it hard to use nice haskell tricks like sharing and functions-as-data
08:02:17 <sclv> Yi used to use plugins
08:02:18 <ManateeLazyCat> quicksilver: The key is keep core little enough, then just re-launch extensive module
08:02:19 <edwardk> tommd: around?
08:02:35 <quicksilver> ManateeLazyCat: yes, I understand your general argument. I'm just pointing out that saving all state is hard.
08:02:38 <ManateeLazyCat> I think dyre has split those feature from Yi.
08:02:41 <quicksilver> or can be hard.
08:02:50 <quicksilver> arguably the costs are worth it.
08:02:56 <ManateeLazyCat> quicksilver: Yes, but we try to don't lost user's status. :)
08:03:15 <quicksilver> restoring state including exact sharing is another level of tricky
08:03:29 <quicksilver> restoring state including maximumal sharing (possibly more than before save) is sometimes easier.
08:03:29 <ManateeLazyCat> quicksilver: Example, i have similar project like *dynamic* configuration like YI or XMoand, it's hard to restore all stauts.
08:03:58 <edwardk> @tell tommd went in and hacked up Tagged a bit to add something 'for' like but went with a safer variant that still avoids the undefineds. data Proxy p = Proxy; proxy :: Tagged s a -> Proxy s -> a; tag :: (Proxy s -> a) -> Tagged s a
08:03:58 <lambdabot> Consider it noted.
08:04:10 <ManateeLazyCat> quicksilver: I just build a save/restore interface to application developer (through type-calss)....
08:04:32 <ManateeLazyCat> quicksilver: But like you said, save all status is really hard sometimes.
08:04:55 <edwardk> @tell tommd that way you can still match tags with type signatures, but don't risk the user trying to use a tag of type Int as an actual Int
08:04:55 <lambdabot> Consider it noted.
08:05:17 <ksf> making code serialisable woud ease things
08:05:36 <ManateeLazyCat> sonoflilit: I recommend you read the source code of "dyre", it's a project split from Yi.
08:06:19 <sonoflilit> ManateeLazyCat: one day I might. Right now I'm more into getting a working haskell development environment
08:06:26 <sonoflilit> ManateeLazyCat: thank you
08:06:37 * ManateeLazyCat pasted "Core.hs" at http://paste2.org/get/880043
08:06:38 <ManateeLazyCat> sonoflilit: Or see my own *re-compile/relaunch* library at above.
08:07:03 <ManateeLazyCat> sonoflilit: Pretty simple, you can the principle of "re-compile/relaunch"
08:07:07 <ManateeLazyCat> sonoflilit: No magic.
08:07:10 <ManateeLazyCat> :)
08:07:29 <ManateeLazyCat> sonoflilit: If you want real work environment, i recommend you use Emacs or Vi. :)
08:08:02 <edwardk> dyre is only really usable if you don't need to tweak the environment of which packages get used, etc. so its only really applicable for something that would have a brain-dead simple .cabal file
08:08:35 <sonoflilit> I probably will
08:08:35 <sonoflilit> thank you
08:08:41 <sonoflilit> and I'll try to use the cofiguration for emacs that you linked
08:08:54 <sonoflilit> yi is refusing to recognize backspace :P
08:08:57 <ManateeLazyCat> sonoflilit: Search haskell-mode.
08:09:18 <ManateeLazyCat> http://www.emacswiki.org/emacs/haskell-extension.el have some improve code for haskell-mode. 
08:09:40 <sonoflilit> how do I quit yi?
08:09:50 <pastorn> sonoflilit: :wq or :q
08:09:53 <pastorn> (i guess)
08:09:53 <ManateeLazyCat> edwardk: dyre is just for local configuration re-compile.
08:10:01 <sonoflilit> in emacs mode
08:10:12 <pastorn> Cale: helloez
08:10:14 <ManateeLazyCat> edwardk: My code at http://paste2.org/get/880043 is for *all project* re-compile. :)
08:10:19 <edwardk> ManateeLazyCat: yes, but if your executable has a lot of fiddly dependencies it blows up ;)
08:10:26 <Cale> pastorn: hey
08:10:26 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:10:56 <ManateeLazyCat> edwardk: I use some *delay* make user can't feeling that.
08:10:58 <edwardk> ManateeLazyCat: nice. i'll bookmark it for next time i go to tackle recompilation =)
08:11:57 <ManateeLazyCat> edwardk: Just re-lauch *new entry* when all project re-compile finish, before that, users still use old entry, so when relaunch new entry, user can't feeling the *long-time* of re-compile. :) 
08:12:39 <ManateeLazyCat> edwardk: I plan to improve my code for "multi-processes" re-launch.... :)
08:13:59 <ManateeLazyCat> edwardk: But for better experience, i want make build haskell-interperter for test new code that don't need re-compile something. 
08:14:08 <gio123_> Cale: hey
08:15:06 <ManateeLazyCat> sonoflilit: If you prefer to Emacs, ask at #emacs, i think have many haskell spy at #emacs . :)
08:16:48 <edwardk> ManateeLazyCat: nice. you might want to look at http://nathanwiegand.com/wp/2010/02/hot-swapping-binaries/ to see ways you can avoid users even seeing the file handles close ;)
08:17:08 <edwardk> a little bit of Serializable magic and everything can continue on as before
08:17:52 <ManateeLazyCat> edwardk: I have read a lot of dons paper before my code, but i think it's need a lot work for build-in haskell-interperter.
08:17:56 <edwardk>     deriving (Eq,Ord,Ix,Enum,Bounded,Read,Data,Typeable,Num,Real,Integral,Fractional,Floating,RealFrac,RealFloat) seems excessive. i wish i could just say deriving (Prelude) ;)
08:18:18 * ManateeLazyCat Why Emacs's develop speed is so fast? The answer is Emacs has a build-in interperter!
08:21:10 <ManateeLazyCat> edwardk: Thanks for your link, interesting.... :)
08:21:11 <sonoflilit> where does haskell-refac-mode come from?
08:22:04 <ManateeLazyCat> sonoflilit: haskell-refac-mode is a mode of HaRe.
08:22:17 <ManateeLazyCat> sonoflilit: HaRe is haskell project to "refactory code"
08:22:30 <ManateeLazyCat> sonoflilit: Just comment it even i don't use HaRe.
08:23:13 <ManateeLazyCat> sonoflilit: BTW, all my haskell link pretty old, so the best way is ask haskeller at #emacs, or emacser at #haskell. :)
08:23:40 * ManateeLazyCat pasted "haskell configuration file." at http://paste2.org/get/880062
08:23:45 <ManateeLazyCat> sonoflilit: Above is my configuration file.
08:23:47 <ManateeLazyCat> for Emacs.
08:24:15 <ManateeLazyCat> sonoflilit: Before that, you need install haskell-mode and hs-lint.el
08:24:38 <ManateeLazyCat> sonoflilit: hs-lint.el is emacs-mode for hlint (a code suggest tool).
08:25:33 <ManateeLazyCat> sonoflilit: BTW, use HaRe refactory haskell code maybe dangerous since i never use it.
08:25:52 <ManateeLazyCat> sonoflilit: I use color-moccur.el and moccur-edit.el refactory haskell code.
08:26:18 <lpsmith> I see that haddock strips parens out of types, at least in some cases.   Is this expected?
08:26:32 <McManiaC> what is the safest and most efficient way of turning a String into a Int?
08:26:41 <McManiaC> "50" â 50
08:26:48 <ManateeLazyCat> solidsnack: http://www.emacswiki.org/emacs/auto-complete-extension.el with auto-complete.el will provide some "code completion" for Haskell.
08:26:50 <Botje> that's what read is for
08:26:58 <Botje> but it will error at runtime if it fails
08:27:03 <McManiaC> yeh
08:27:04 <ManateeLazyCat> solidsnack: Sorry, is sonoflilit.
08:27:05 <Botje> use reads :)
08:27:17 <tromp_> :t read
08:27:18 <lambdabot> forall a. (Read a) => String -> a
08:27:18 <ManateeLazyCat> McManiaC: Read
08:27:24 <danharaj> :t reads
08:27:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:27:32 <tromp_> > read "hello" :: Int
08:27:33 <ManateeLazyCat> read "50" :: Int
08:27:34 <lambdabot>   *Exception: Prelude.read: no parse
08:27:54 <ManateeLazyCat> > read "50" :: Int
08:27:55 <lambdabot>   50
08:27:57 <lpsmith> e.g.  the parens are stripped from (e -> IO a) in the type of catch:  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#v%3Acatch
08:28:04 <danharaj> Why doesn't read return a maybe?
08:28:12 <danharaj> Maybe*
08:28:16 <tromp_> :r reads
08:28:19 <tromp_> :t reads
08:28:20 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:28:20 <ManateeLazyCat> danharaj: You has know it's 50 ?
08:28:22 <ManateeLazyCat> :)
08:29:21 * ManateeLazyCat I guess sonoflilit restart it's Emacs for loading configuration file? Since emacs don't need restart.... :)
08:29:29 <edwardk> quick poll: I want to extended 'tagged' to also export a Proxy type, which has a bunch of combinators. I can either place Proxy in Data.Tagged. I can make Data.Proxy or I can make a separate 'proxy' package that depends on Tagged and provides Data.Proxy. Preferences?
08:29:31 <McManiaC> is there an easy way to use reads? a big "case reads of [(i :: Int,_):_] -> ..." sounds kinda complicated :>
08:29:47 <Botje> McManiaC: listToMaybe is a bit nicer
08:29:50 <edwardk> many of the combinators for Proxy convert back and forth to Tagged
08:30:01 <edwardk> and its usage is mostly a preference thing
08:30:13 <McManiaC> Botje: ah cool :)
08:30:21 <danharaj> You need to give it a fancy non-descriptive name, edwardk.
08:30:22 <Botje> > listToMaybe $ reads "123foo" :: Maybe (Int, String)
08:30:22 <lambdabot>   Just (123,"foo")
08:30:52 <Gracenotes> McManiaC: usually what you're looking for is [(a, "")]
08:31:02 <edwardk> danharaj: nah, other people want to use this package. i'd like to not mess that up by draping it in category theory ;)
08:31:38 <Gracenotes> McManiaC: the thing about ReadS is that you can use it to indicate multiple parser results, but for the Read typeclass, you usually only want one result, and you usually don't want any additional string
08:31:59 <edwardk> spoon (read "123foo") ;)
08:32:01 <sclv> I usually use readMay from the Safe library
08:32:03 <Gracenotes> but if not, then not
08:32:17 <sclv> I think it is on track for the standard libs, last I heard?
08:32:41 <McManiaC> sclv: link?
08:32:47 <Saizan> edwardk: well, the right thing would be a separate package of course, then we can refactor all the type-hackery libs in hackage to use it :)
08:32:58 <sclv> ?hackge Safe
08:32:58 <lambdabot> http://hackage.haskell.org/package/Safe
08:33:10 <Saizan> actually, Proxy should be in base, and used by Storable
08:33:10 <sclv> ?hackage safe
08:33:11 <lambdabot> http://hackage.haskell.org/package/safe
08:33:31 <sclv> the second -- with the lowercase name, is the correct one.
08:34:17 <McManiaC> ok cool
08:34:22 <McManiaC> thx :)
08:35:16 <McManiaC>     Ambiguous module name `Safe':
08:35:16 <McManiaC>       it was found in multiple packages: safe-0.2 Safe-0.1
08:35:22 <McManiaC> can I just "unregister" Safe?
08:35:36 <Saizan> ghc-pkg unregister Safe
08:35:37 <sclv> better to just ghc-pkg hide Safe-0.1
08:35:49 <McManiaC> sclv: ok
08:35:52 <sclv> unregister is dangerous and better avoided 
08:36:00 <McManiaC> k, cool
08:36:03 <McManiaC> thx a lot :)
08:36:08 <Saizan> well, not really
08:36:22 <Saizan> it'll tell you if it could cause other packages to break
08:36:39 <sclv> right -- but why put yourself through that?
08:37:01 <Saizan> if he just installed Safe there's no problem :)
08:39:05 <Gracenotes> and also, having both safe and Safe won't do nicely on Windows..
08:40:43 <Gracenotes> according to the revdeps hackage, only httpspec and firstify use Safe
08:41:07 <Gracenotes> whereas dozens of modules use safe
08:41:35 <Gracenotes> (firstify being written by neil himself)
08:42:43 <yrlnry> This page: http://blog.plover.com/prog/springschool95-2.html is discussing the declaration "data Mu f = In (f ( Mu f))", which is a least-fixed-point operator for types.  For example, (Mu Maybe) is the type { _|_, Nothing, Just Nothing, Just (Just Nothing), ... }.   
08:43:38 <ManateeLazyCat> edwtjo: IMO, perfect way is split core out from "status pool", and build-in haskell-interperter in program, then don't need restart entry after add new modules. Even you don't need restart entry, then all status (include file) won't lost. Then we can extend haskell program in *runtime* ... :)
08:43:49 <yrlnry> The page points out that there are other types that are fixed points of Maybe, all of which are supersets of (Mu Maybe), and says ""Further consideration of this point might take me off to co-induction, paraconsistent logic, Peter Aczel's nonstandard set theory".
08:44:24 <yrlnry> Does anyone have any thoughts on what the connection to co-induction or paraconsistent logic could be?
08:44:27 <ManateeLazyCat> Edward__: For integrate core with haskell-interperter, i haven't try ... looks need deep hacking .. :)
08:48:08 <gio123> Cale: hi
08:48:10 <danharaj> Doesn't (Mu Maybe) = Maybe?
08:48:44 <Cale> danharaj: Mu Maybe = Nat
08:49:17 <danharaj> Cale: That would be Mu (1 + X), no? I thought Maybe was (1 + A)
08:49:34 <Cale> what?
08:49:40 <danharaj> heh yeah uh
08:49:43 <danharaj> that came out wrong
08:50:30 <danharaj> you are right
08:50:34 <danharaj> I don't know what I was thinking
08:50:45 <danharaj> In my defense, I had 4 hours of sleep and this sandwich is *too* delicious.
08:57:59 <gio123> Cale : hey
09:04:40 <ManateeLazyCat> Bye all, night!
09:12:27 <sclv> Anyone have experience with a 64 and 32 bit install of ghc on the same machine?
09:14:25 <gio123> Cale: hi
09:17:29 <yrlnry> danharaj: Mu Maybe = Maybe  doesn't even kind0check correctly.  Maybe has kind *â* and Mu has kind (*â*)â*.
09:18:26 <yrlnry> Nobdy has any thoughts on the connection between non-least fixed points of functors and paraconsistent logic, co-induction, or non-well-founded set theory?
09:18:43 <yrlnry> I wonder what that guy was thinking of.
09:26:45 <alpounet> @hoogle Storable
09:26:45 <lambdabot> module Data.Array.Storable
09:26:45 <lambdabot> module Foreign.Storable
09:26:45 <lambdabot> Foreign.Storable class Storable a
09:27:03 <alpounet> @instances-importing Foreign.Storable Storable
09:27:03 <lambdabot> Bool, Char, Double, Float, Int
09:30:02 <McManiaC> http://npaste.de/Y2/ is there any nicer solution to this?
09:30:12 <gio123> s
09:30:17 <gio123> Cale: hi
09:30:36 <McManiaC> (without putting the ifs inside the { ... })
09:33:06 <gwern> McManiaC: you can abstract cfg'''
09:33:18 <gwern> probably
09:33:21 <gwern> hm.
09:34:02 <gwern> maybe not, then, since you're extracting the value from the Just
09:34:11 <McManiaC> hmm
09:34:16 <gwern> @hoogle maybe
09:34:17 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:34:17 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
09:34:17 <lambdabot> module Data.Maybe
09:34:26 <edwardk> preflex: xseen tommd
09:34:26 <preflex>  tommd was last seen on freenode/#haskell 11 hours, 22 minutes and 37 seconds ago, saying: I'd like cheap SPI Flash more.
09:34:29 <pastorn> McManiaC: maybe using applicative...
09:34:30 <alexyk> so I need an efficient two-way dictionary ByteString<=>Int.  How's (Trie ByteString, IntMap ByteString)?
09:34:56 <pastorn> McManiaC: could i see the Config type?
09:35:23 <mux> alexyk: bytestring-trie works fine in my experience
09:35:27 <McManiaC> data Config = Config
09:35:27 <McManiaC>     { login     :: String
09:35:36 <McManiaC> argh sorry
09:35:39 <McManiaC> http://npaste.de/Y3/
09:35:54 <mux> alexyk: I suppose having an IntMap for the other direction is fine
09:36:09 <pastorn> McManiaC: is this the creation of the Config or is this a modifying function?
09:36:16 <McManiaC> modifying
09:36:27 <alexyk> mux: how do I get the specialized Trie ByteString?  or is the specialization picked automagically?
09:36:55 <pastorn> shit...
09:37:00 <alexyk> mux: is it the same Data.Trie we're talking about?
09:37:02 <mux> alexyk: you want a Trie Int and a IntMap ByteString
09:37:09 <pastorn> McManiaC: creation would have been much more fun :)(
09:37:11 <pastorn> :(
09:37:13 <pastorn> :)
09:37:16 <McManiaC> hehe yeh
09:37:20 * pastorn takes some typing lessons
09:37:23 <mux> alexyk: I was talking about the bytestring-trie package
09:37:41 <alexyk> mux: ah, Trie is bytestring-keyed always
09:37:52 <McManiaC> http://npaste.de/Y4/ is the creation pastorn 
09:37:52 <alexyk> from Data.Trie right
09:37:53 <McManiaC> :>
09:38:14 <pastorn> McManiaC: boooo
09:38:19 <pastorn> read about Applicative :)
09:38:24 <pastorn> @where Applicative
09:38:24 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
09:38:37 <pastorn> well, there's a paper...
09:38:40 <McManiaC> hm I know about applicatives
09:38:41 <pastorn> (somewhere)
09:38:43 <McManiaC> how would I use them here?
09:38:58 <gwern> fromJSString smells like a code smell
09:39:28 <gwern> maybe define something like Num and put the conversions in there
09:39:32 <pastorn> pure Config <*> somthingThatMonadicallyGetsLogin <*> somethingThatMonadicallyGetsPassword
09:39:34 <pastorn> ...
09:39:48 <pastorn> McManiaC: it doesn't have to be monadically, it's just that it can be :)
09:39:52 <mux> alexyk: bytestring-trie exports it via the Data.Trie module, and yes, it's always keyed by bytestrings hence the name of the package (bytestring-trie), but a trie can only be keyed by a sequence of integral values anyways, it's how it works
09:40:22 <McManiaC> pastorn: well I just have to turn a list into config
09:40:24 <McManiaC> ;)
09:40:33 <McManiaC> theres not much monadic about it
09:40:37 <alexyk> mux: ok
09:40:51 <pastorn> McManiaC: stick the list in a Reader and do local (tail)
09:41:10 <pastorn> and maybe with mapM and you've got yourself a winner :)
09:41:18 * pastorn is just guessing
09:41:19 <sclv> mux: well, generic tries :-)
09:41:36 <McManiaC> pastorn: maybe on my next obfuscating contest ;)
09:42:04 <mux> sclv: I don't get what you mean
09:42:13 <pastorn> McManiaC: hang on... do you start doing this from cfg'''?
09:42:16 <pastorn> or from cfg'?
09:42:26 <McManiaC> hm?
09:42:28 <pastorn> cfg''' is doing the first testing, right?
09:43:16 <McManiaC> hm?
09:43:18 <McManiaC> ^^
09:43:40 <pastorn> McManiaC: perpaps with a list... [(Bool, Config -> Config)]
09:44:14 <pastorn> McManiaC: let me see the whole function
09:46:17 <McManiaC> http://npaste.de/Y5/ :P
09:46:49 <sclv> mux: seen generalizing generalized tries?
09:47:23 <pastorn> oh shi~!
09:47:30 <mux> sclv: nope, sounds interesting
09:47:42 <sclv> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.223
09:47:51 <mux> already reading it from this very source ;-)
09:47:52 <mux> but thanks
09:48:21 <mux> this is the same ralph hinze that has been doing work with spj or something?
09:48:53 <sclv> not just that, but yes :-)
09:49:00 <sclv> he's got lots of very interesting practical work in haskell
09:49:20 <pastorn> McManiaC: ok... what you need is MonadState
09:50:13 <McManiaC> I'll just leave it like that
09:50:13 <McManiaC> :)
09:50:17 <McManiaC> thx anyway
09:50:19 <pastorn> bah!
09:50:23 <pastorn> i'm writing it now!
09:50:27 <McManiaC> haha
09:50:27 <McManiaC> ok
09:54:49 <pastorn> McManiaC: http://npaste.de/fKRfoZ7AxG/
09:55:15 <pastorn> McManiaC: that would have been even prettier if you were using fclabels
09:55:49 <McManiaC> fclabels?
09:56:13 <pastorn> McManiaC: yeah... it solves the problem of having a function 'gets' but not a 'sets'
09:56:16 <pastorn> @type gets
09:56:17 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
09:56:39 <pastorn> it makes it real pretty to update records
09:57:22 <tommd> edwardk: Thanks I'll check it out once it hits hackage.
09:57:42 <pastorn> McManiaC: that way you culd just have 'set password password' :: Config -> Config
09:58:50 <pastorn> or, with MonadState, like here, it would be just 'setM password password'
09:59:15 <sclv> anyone used DoCon?
10:01:53 <sms_> hi everyone, how can i generate a unix timestamp? it should be easy but i just can't figure it out
10:02:37 <pastorn> McManiaC: i think i just WON @ LYFE
10:02:46 <McManiaC> hm?
10:03:21 <pastorn> McManiaC: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26290#a26290
10:03:42 <Saizan> sms_: seen Data.Time?
10:03:59 <pastorn> McManiaC: if that ain't readable i don't know what is :/
10:04:41 <sms_> Saizan: i've seen some stuff
10:04:44 <sms_> i will check it
10:05:01 <pastorn> McManiaC: all you have to do is to rename all your record fields from "data Rec = Rec { x,y,z :: T }" to "data Rec = Rec { _x,_y,_z :: T }"
10:05:55 <pastorn> then you put some cool word in front of that (template haskell... i think it's "$mkLabels") and it generates functions without the '_' in front of them
10:06:55 <edwardk> heya tommd 
10:07:05 <edwardk> i wanted to talk to you about the api to make sure it met your needs
10:07:11 <edwardk> let me hpaste
10:08:03 <sms_> Saizan: do i have to calculate the timestamp myself or is there some function that allows me to be lazy?
10:08:19 <sms_> you can call me blind any time by the way
10:08:38 <edwardk> @hpaste
10:08:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:08:43 <edwardk> gah we need to fix that =)
10:09:19 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26291#a26291
10:09:33 <edwardk> tommd: i didn't know what .::. was supposed to do ;)
10:09:45 <edwardk> tommd: since it wasn't mentioned anywhere else i found
10:10:34 <edwardk> tommd: the two methods you probably care about are proxy and unproxy
10:11:55 <Saizan> sms_: there's http://hackage.haskell.org/packages/archive/time/1.2.0.2/doc/html/Data-Time-Clock-POSIX.html#v%3AgetPOSIXTime 
10:11:59 <aristid> :t (.::.)
10:12:00 <lambdabot> Not in scope: `.::.'
10:12:12 <Saizan> Prelude Data.Time.Clock.POSIX> getPOSIXTime 
10:12:13 <Saizan> 1276708299.802418s
10:12:37 <djahandarie> I like my ::.:..:.:...::..: operator
10:12:57 <djahandarie> It really makes things clear
10:13:25 <int-e> But it's a constructor!
10:13:32 <edwardk> djahandarie: when you need a named operator to be infix, just encode it in Morse code!
10:14:03 * hpc is imagining BlindPrelude
10:14:23 <djahandarie> lmao
10:14:43 <edwardk> .--..-....-..----. is so much clearer than `addition`
10:14:53 <hpc> although i think Braille needs three vertical dots
10:15:04 <edwardk> hpc: it does, you can't fit braille
10:15:14 <edwardk> well, with unicode operators you could
10:15:16 <sms_> Saizan: thank you so much. i knew it had to be so easy
10:15:25 <hpc> Haskell does unicode, too :D
10:15:51 <edwardk> hpc: the trick is if the braille unicode symbols are classified symbols though ;)
10:17:12 <edwardk> oh, neat, they are Symbols ;)
10:17:35 <pyNem> i have been asked to give a talk on haskell at the place where I study sometime
10:17:51 <djahandarie> I'm pretty sure it'd make more sense for something to convert Haskell code into Braille rather than use Braille unicode in the code itself
10:17:52 <pyNem> i am fairly fluent with haskell, but it seems a very mmm.. touchy issue to speak about
10:18:01 <pyNem> is there any place containing guidelines or pointers?
10:18:15 <djahandarie> Wing it
10:18:20 <djahandarie> Come in 5 minutes late
10:18:22 <djahandarie> Unshaven
10:18:24 <SubStack> import Foreign -- pointers
10:18:30 <SubStack> :p
10:18:35 <pyNem> djahandarie, SubStack :)
10:18:40 <pyNem> (touchy because it is contrary to the imperitave programmers mind)
10:19:05 <tommd> edwardk: (.::.) = for     -- really not necessary.  That and for are in the current crypto repo.
10:19:20 <edwardk> â â â â â â â â 
10:19:24 <djahandarie> pyNem, it really depends on who you are talking to
10:19:28 <edwardk> tommd: ah
10:19:30 <djahandarie> Oh god
10:19:34 <SubStack> pyNem: I love talks that have fun examples for people to play with
10:19:39 <sclv> pyNem: spj has given a number of very good "introduction to haskell" talks online
10:19:45 <edwardk> tommd: ah
10:19:51 <sclv> available online, that is
10:19:52 <edwardk> tommd: then proxy should be all you need
10:19:53 <pyNem> djahandarie, right .. i didnt mention that ..computer science students
10:19:59 <SubStack> especially if people don't need to install anything to try them out
10:20:10 <edwardk> proxy is basically your for with an extra newtype wrapper added for safety
10:20:51 <edwardk> but it probably screws your current usage pattern ;)
10:20:55 <sclv> pyNem: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/index.htm is really good, but quite long
10:21:58 <djahandarie> > let â â â â â â â â  = const in 1 â â â â â â â â  2
10:21:59 <lambdabot>   <no location info>: parse error on input `â â â â â â â â '
10:22:03 <tommd> edwardk: Great.  I think proxy and unTagged would do it then.  I'll look at updating crypto, DRBG once the Tagged library hits hackage.
10:22:15 <pyNem> sclv, thanks :)
10:22:19 <djahandarie> > let â â â â â â â  = const in 1 â â â â â â â  2
10:22:20 <lambdabot>   <no location info>: parse error on input `â â â â â â â '
10:22:20 <pyNem> sclv, that looks awesome
10:22:22 <djahandarie> :-(
10:22:25 <sclv> You can probably also direct folks to tryhaskell.org to play with ghci while you talked
10:22:40 <edwardk> tommd uploading now
10:23:17 <djahandarie> > let (â â â â â â â ) = const in 1 â â â â â â â  2
10:23:18 <lambdabot>   1
10:23:35 <pyNem> sclv, yes, that is something I would like. tryhaskell.org is awesome :)
10:24:39 * hackagebot tagged 0.1.0 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.1.0 (EdwardKmett)
10:24:49 <edwardk> tommd there ya go
10:25:08 <cwb> pyNem: for what it's worth, I did CS which included a course in Haskell. I found it neat, but I failed to see as anything more than an academic language (this was in 2003-2004). Do point out all the cool features of Haskell (there are clearly lots for CS students to get excited about), but I recommend emphasising that it is indeed very practical -- particularly thanks to how features help contain complexity.
10:25:17 <edwardk> flipping connections to upload to github
10:25:54 <pyNem> cwb, should I touch on monads and monad transformers in a hour talk ? or arrows or FRP?
10:25:57 <c_wraith> Ok.  Typeable is a very sad interface.
10:26:22 <pyNem> cwb, how else can i make it seem more practical?
10:26:26 <djahandarie> pyNem, if you can do it correctly, you could probably say something about monads
10:26:35 <sclv> monads yes. transformers briefly. arrows and frp not so much.
10:26:49 <zygoloid> c_wraith: sad?
10:26:52 <djahandarie> Make sure you don't mention category theory at any point
10:26:53 * SubStack uses haskell for all sorts of practical programming
10:27:13 <djahandarie> pyNem, something people will probably find interesting is the performance
10:27:20 <sclv> pyNem: maybe a slide with a selection of hackage packages
10:27:30 <sclv> to show the things that people are doing with it
10:27:51 <pyNem> djahandarie, yes. No category theory, I think too.
10:27:57 <c_wraith> zygoloid, It doesn't really support anything interesting.  It might as well just be a random string assigned to each implementing type.
10:28:19 <pyNem> sclv, yep, a slide with packages from hackage a nice idea. :)
10:28:19 <sclv> that's not true.
10:28:46 <cwb> pyNem: I'd probably cover monads briefly, but the best you can do in an hour is get them excited about it and glimpse the benefits -- then they can go off explore. Why not set them a simple challenge to encourage that?
10:28:53 <sclv> c_wraith: you can do all sorts of things with TypeReps
10:29:25 <pyNem> cwb, hmm. Yeah. I'll have to do that really carefully though. Will spend some time on it :)
10:29:39 <pyNem> cwb, will spend some time thinking* on it.
10:29:59 <sclv> c_wraith: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Typeable.html#5
10:30:48 <cwb> pyNem, sure, whatever works.
10:31:34 <c_wraith> sclv: All of those are boring.  There's no way to resolve a TypeRep against a set of imports, for instance, to get the most concise string for representing a type.
10:32:53 <sclv> well, to each their own I suppoe.
10:32:57 <sclv> suppose.
10:38:35 <chrisdone> is there a withEnvironment function about, similar to withArgs?
10:39:50 <McManiaC> dcoutts_: ping
10:40:03 <blueonyx> hi, anyone into hint? i dont want to import Text.JSON in all the modules i interpret, but i have no luck with setImports,setTopLevelModules or loadModules :(
10:40:23 <c_wraith> blueonyx: at the moment, I might know more about it than anyone except its author
10:41:05 <blueonyx> so is it possibly to import some module "per default"?
10:41:29 <c_wraith> hpaste the code you're trying to use, please.
10:41:54 <tommd> blueonyx: You mean, have ghci start up with some modules loaded?  Yes, modify your .ghci file.
10:42:16 <chrisdone> tommd: no, he doesn't mean that
10:43:07 <blueonyx> just what tommd said only with hint
10:45:36 <c_wraith> hint is very picky about types in strange ways, due to using reified type descriptions from the Typeable interface.  Which is why I was just complaining Typeable isn't good enough.
10:45:42 <chrisdone> setImports should be alright
10:45:55 <c_wraith> I really want to see your hint code.
10:46:19 <chrisdone> c_wraith: he's keeping it from you. he doesn't want you or the world to know
10:48:47 <blueonyx> c_wraith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26293#a26293
10:49:14 <blueonyx> the example may not compile, but its still complaining about wrapMap
10:52:31 <FusionGyro> quick regex question. using Text.Regex.Posix, I used to have code that looked like this: s =~ "([0-9][0-9])" :: [String] and it used to work. Now I have to do [[String]] and it gives me the whole string as well as the captures. Is there a way to get the behavior I used to have?
10:53:57 <blueonyx> FusionGyro: i think i got it by using getAllTextSubmatches
10:55:26 <McManiaC> does anyone know if you can change the label of a MenuItem in gtk2hs?
10:55:32 <blueonyx> c_wraith: is it that bad?
10:55:33 <McManiaC> (how)
10:57:29 <FusionGyro> blueonyx: getAllTextSubmatches $ "12345678" =~ "([0-9]{2})" :: [String] produced ["12", "12"] rather than ["12","34","56","78"], which is what I was hoping for
10:58:15 <c_wraith> blueonyx, No.  But what's the error?  Is it a hint compile error?
10:59:41 <kmc> > "12345678" =~ "([0-9]{2})" :: [[String]]
10:59:42 <lambdabot>   [["12","12"],["34","34"],["56","56"],["78","78"]]
10:59:55 <kmc> > map head ("12345678" =~ "([0-9]{2})" :: [[String]])
10:59:56 <lambdabot>   ["12","34","56","78"]
11:00:18 <FusionGyro> kmc: that's how I changed the code to make it work, I was just hoping there was a cleaner way. after all, this is a pretty common use case
11:00:52 <blueonyx> c_wraith: added the errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26293#a26294
11:00:54 <McManiaC> is there a way to match a type class in a "case"?
11:01:58 <sclv> McManiac: not really. but do a paste of what you think you want to do, and there might be suggestions for how to do it differently.
11:02:20 <FusionGyro> this seems a little better, but still: concat $ "12345678" =~ "[0-9]{2}" :: [String]
11:03:20 <Philonous> McManiaC: Types only exist at compile time, so it isn't meaningfull to match on them at runtime
11:03:32 <c_wraith> oh, I see.  Yes, the modules you're loading need to actually be valid haskell.  That means they need to import names defined in other modules.
11:04:32 <McManiaC> yeh okay
11:04:44 <McManiaC> I think I already found an other way to do what I wanted to do
11:04:45 <McManiaC> :>
11:04:52 <c_wraith> If you always intend to load just a single function, you could just read the file as a string and interpret that string?
11:04:57 <kmc> i'm curious what it was
11:05:06 <pookleblinky> chrisdone, I really like your lojban utilities
11:05:17 <c_wraith> And then you could set what's in scope when you do that interpretation
11:05:56 <blueonyx> c_wraith: whats then the use case of setImports? xD
11:06:24 <c_wraith> blueonyx, it sets the imports visible when you interpret a string.
11:06:40 <FusionGyro> thanks
11:06:43 <c_wraith> In your case, that string is just the name of a function
11:07:31 <c_wraith> So the only import it needs is the module containing the function...  Well, and because of the wacky type reification, it also needs all the types of the string being interpreted to be imported
11:07:53 <chrisdone> pookleblinky: they still work? ;D
11:08:27 <sproingie> Wacky Type Reification
11:08:34 <pookleblinky> I'm reading them, haven't yet compiled them
11:09:06 <sproingie> data Wacky t where...
11:09:22 <c_wraith> yeah.  I know why it does type reification the way it does, but it's a rather severe limitation sometimes.
11:12:28 <blueonyx> ah, thanks
11:18:34 <pookleblinky> chrisdone, jbobaf.hs seems to work fine under ghc 6.12.1
11:19:04 <w3rs> hi all, do you now some (preferably simple) examples of using YAML? 
11:20:06 <chrisdone> pookleblinky: sure
11:20:35 <chrisdone> w3rs: http://hackage.haskell.org/package/hamlet-0.2.0
11:21:11 <chrisdone> w3rs: i believe hamlet is based on yaml
11:21:33 <sclv> don't think so?
11:21:35 <chrisdone> w3rs: oh, it's based on haml. hard to keep track 
11:22:12 <sclv> what about coq? oh wait... that's caml :-)
11:23:33 <w3rs> chrisdone, it has self-documenting name :) but same author with Data.Yaml
11:25:34 <sclv> what about cows? oh wait... those are mammals.
11:56:23 <alexyk> according to jdh, someone in this channel falls under the following Wikipedia definition: "low habits, general improvidence, love of gambling, total want of education, disregard for lawful marriage ceremonies, and their use of a peculiar slang language"
11:56:47 * sproingie
11:58:13 <alexyk> oh wait, that's about anybody on the IRC :)
11:59:01 <Tomsik> I don't have a disregard for marriage, hum
11:59:27 <kmc> it's not clear what that means anyway
11:59:51 <sproingie> i suspect it means philanderer and/or homewrecker
11:59:58 <kmc> probablp
12:00:39 <kmc> but it's not really the ceremony that's important...
12:01:20 <Mathnerd314> @google low habits, general improvidence, love of gambling, total want of education, disregard for lawful marriage ceremonies, and their use of a peculiar slang language
12:01:21 <lambdabot> http://en.wikipedia.org/wiki/Costermonger
12:01:21 <lambdabot> Title: Costermonger - Wikipedia, the free encyclopedia
12:01:46 <Mathnerd314> maybe Haskell is a type of fruit?
12:02:04 <alexyk> kmc: costermonger, a synonym for "barrow boy" which idh used on stack overflow recently; a nice way to learn British English!
12:03:04 <kmc> this is a new kind of monger i have learned about
12:03:43 <alexyk> so I need to walk a Map ByteString Blah, interning BS into Int and producing IntMap Blah.  Looks like there's no uber map for that?  Map.Map is for them Maps, and IntMap.map is for them IntMaps...
12:04:00 <jmcarthur> alexyk: bytestring-trie
12:04:16 <kmc> bytestring-trie's Trie is a more efficient version of Map ByteString
12:04:32 <alexyk> jmcarthur: right, that's what I'm carrying along; now I need the function to map original Ord Maps into IntMaps
12:04:33 <kmc> but it won't make your problem easier to code
12:04:48 <jmcarthur> alexyk: huh?
12:04:54 <alexyk> kmc: that's what I'm converting to
12:05:02 <kmc> why take a Map ByteString in the first place?
12:05:20 <alexyk> kmc: I take it for granted, as it's been granted to me
12:05:26 <kmc> fair enough :)
12:05:42 <kmc> it sounds like a fold
12:05:56 <alexyk> right
12:07:45 <gio123> Cale: hey
12:07:57 <alexyk> why isn't there a Map.foldWithKey' or fold' or any other strict fold?
12:07:59 <kmc> i'd use Data.Map.foldWithkey
12:08:03 <kmc> hmm
12:08:49 <kmc> yeah i'm not sure
12:10:19 <alexyk> is there a verion of Debug.Trace which won't emit a newline after what it prints?  Then I could employ it as a progress bar with "."
12:10:42 <kmc> :t unsafePerformIO $ putChar '.'
12:10:43 <lambdabot> Not in scope: `unsafePerformIO'
12:10:47 <kmc> bah
12:11:19 <alexyk> kmc: will it be given to trace as the thing to print?
12:11:31 <kmc> no
12:11:44 <kmc> (unsafePerformIO $ putChar '.') is a value which, when forced, will print .
12:11:51 <alexyk> or I'd just brazenly like do it? wow
12:12:04 <kmc> but you have to arrange for the evaluation to occur
12:12:12 <kmc> so maybe what you want is
12:12:32 <kmc> withDot x = unsafePerformIO (putChar '.') `seq` x
12:12:43 <alexyk> yay!
12:12:55 <kmc> (withDot x) is like x, except when forced it will print a dot
12:13:05 <alexbobP> http://70.253.79.130/ip
12:13:16 <alexbobP> aww, lambdabot isn't reading the url for me :P
12:13:49 <alexyk> back to Map.fold' desired.  Folks said Map implements Data.Foldable, so it must be able to do fold'; what does it mean -- how do I obtain one that way?
12:17:08 <kmc> :t Data.Foldable.foldl'
12:17:10 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
12:17:24 <kmc> here t = Map k
12:17:29 <kmc> however you won't get the keys that way
12:17:40 <kmc> wouldn't it be easiest to use Map.toList?
12:19:18 <gwern> @src Foldable
12:19:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:19:20 * sm likes withDot
12:19:20 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
12:19:40 <zygoloid> withDot = trace "." ?
12:19:59 * zygoloid can't remember whether trace adds a newline
12:20:26 <alexyk> zygoloid: it does, hence the whole exercise
12:20:37 <zygoloid> ah, i see
12:21:08 <zygoloid> withDot x = unsafePerformIO $ do putChar '.'; evaluate x
12:21:42 <kmc> :t Control.Exception.evaluate
12:21:44 <lambdabot> forall a. a -> IO a
12:21:51 <zygoloid> ^^ ensures the dot is printed /before/ x is evaluated. the 'seq' version doesn't guarantee that.
12:22:01 <kmc> yeah
12:22:09 <kmc> though pseq would
12:22:41 <zygoloid> i'd also worry that the unsafePerformIO (putChar '.') might get CSE'd out and you might miss dots
12:25:59 <dv-> @src trace
12:25:59 <lambdabot> trace string expr = unsafePerformIO $ do
12:25:59 <lambdabot>     hPutStrLn stderr string
12:25:59 <lambdabot>     return expr
12:27:22 <alexyk> so dons said you can't achieve a strict Map unless you use insertWith'; what if I do Map.fold step where step has bangs on all its arguments?
12:27:28 <alexyk> why wouldn't that be strict enough?
12:29:01 * alexyk remembers a jazz ballad: "bang bang -- and you're evaluated"
12:32:08 <djahandarie> Anyone used HJScript before?
12:39:04 <jmcarthur> alexyk: what is it that you are doing?
12:39:56 <alexyk> jmcarthur: converting a big Map ByteString Blah into IntMap Blah, interning BS as Int in a Trie which is carried in the M.foldWIthKey
12:40:09 <jmcarthur> alexyk: i mean, i get that you are doing something like ((ByteString -> Int) -> Map ByteString a -> IntMap a), but to what end?
12:40:41 <alexyk> jmcarthur: converting a huge graph with bytestring nodes to same but with int nodes
12:40:58 <jmcarthur> alexyk: why do you have a huge graph with bytestring nodes in the first place?
12:41:00 <alexyk> the eventual end is peace for all mankind
12:41:25 <alexyk> jmcarthur: Twitter made me
12:41:42 <jmcarthur> alexyk: would you be able to convert from bytestrings to ints as you create the graph in the first place?
12:42:03 <alexyk> jmcarthur: I could, but I want to exercise my graph transformation-fu :)
12:42:17 <jmcarthur> ah
12:42:22 <jmcarthur> so it's academic exercise
12:42:42 <alexyk> jmcarthur: haskell is academic :)
12:42:55 <jmcarthur> alexyk: not only :P
12:43:29 <alexyk> jmcarthur: I'd understand if folks in #java said that, here it's a compliment :)
12:43:37 <jmcarthur> heh
12:43:56 <jmcarthur> no offense was taken. i was merely stating the truth
12:43:56 <alexyk> so it's academic exercise -- let's get that ball rolling!  hois your caps and gowns, shallya!
12:44:39 <jmcarthur> i'm actually kind of annoyed at how badly haskell has failed at avoiding success sometimes
12:44:48 <alexyk> in any case, given 6.12 added foldl/rWithKey to Map, a lack of strict folds is glaring.  It's glaringly glaring!
12:45:01 <aristid> jmcarthur: work on your dream, and you can make it happen.
12:45:14 <alexyk> jmcarthur: well, bangifyng my code I kind of start sensing why
12:45:18 <jmcarthur> aristid: my dream?
12:45:30 <aristid> jmcarthur: "avoiding success" :P
12:45:45 <alexyk> working on a dream sounds like strangling it and setling for status quo
12:46:06 <aristid> alexyk: the status quo being a successful haskell?
12:46:17 <alexyk> here's a $1000.  work on your dream and rewrite it in C by tomorrow
12:46:45 <jmcarthur> aristid: i just said i *don't* want a successful haskell :P
12:46:48 <alexyk> aristid: perhaps!
12:47:01 <aristid> jmcarthur: then that's your dream.
12:47:12 <jmcarthur> not really
12:47:26 <alexyk> aristid: his dream involves girls and Porsches
12:47:26 <jmcarthur> it was a reality for a time
12:47:45 <aristid> jmcarthur: well, some people dream of things that used to exist
12:48:02 <aristid> like people dreamed of high-quality alcohol during prohibition
12:48:14 <jmcarthur> *sigh*
12:48:14 <dons> alexyk: how you going?
12:48:24 <aristid> alexyk: no comonads?
12:48:46 <alexyk> dons: much progress on strictifying with dafis, we get to day 16 quickly then it dies
12:48:52 <dons> alexyk: did you see  Daniel Fischer's patches?
12:49:04 <alexyk> dons: that's with those.
12:49:10 <djahandarie> I wonder if "imperitive" should be listed under "Paradigm" in the wikipedia entry
12:49:25 <dons> alexyk: did you produce heap graphs yet?
12:49:30 <Veinor> I wonder. For every f that takes nonnegative integers as input and returns nonnegative integers, can you write f 'in the type system'?
12:49:30 <gwern> djahandarie: why not?
12:49:35 <alexyk> so sounds like ghc dies from a bug: it works through day 16 in roughly same RAM, then spins out of control.
12:49:36 <djahandarie> imperative* is what I mean of course
12:49:41 <Veinor> (using the Succ (Succ (Succ Zero)) approach to numbers)
12:49:48 <gwern> Veinor: the type system is turing complete with extensions, so...
12:49:50 <dons> alexyk: did you see simon marlow's offer to debug it?
12:49:55 <djahandarie> gwern, it isn't currently, I'm wondering if it should be added
12:50:01 <jmcarthur> Veinor: depends on the extensions, at the very least
12:50:04 <alexyk> dons	: the raw data for heap graphs is in my prof/ directory, but now the code moved ahead
12:50:13 <Veinor> ah.
12:50:14 <dons> alexyk: he wrote the runtime, so you might want to let him at it.
12:50:23 <jmcarthur> Veinor: haskell 98 doesn't allow nonterminating types, afaik
12:50:32 <Veinor> nonterminating types?
12:50:44 <jmcarthur> well, nonterminating type inference
12:50:51 <alexyk> dons: I'll try to figure out a way.  What's Simon's timezone?
12:50:54 <jmcarthur> but probably some extensions would allow it or something
12:51:01 <dons> alexyk: he's in cambridge, england.
12:51:05 <gwern> so UTC 0?
12:51:12 <Veinor> yeah.
12:52:26 <dons> still need to do the basic stuff: heap profile. modify dataa types. measure. iterate.
12:52:31 <Veinor> what package gives me Nat, Succ, and Zero?
12:52:36 <alexyk> dons: yeah, I figured.  I'll email... for now, I wonder -- you said we can't achieve a strict Map unless we use insertWith'.  I convert a Map ByteString into an IntMap while interning ByteStrings, using IntMap.foldWithKey -- will it be strict if the step function has bangs on all its arguments?
12:52:48 <Veinor> @hoogle Succ
12:52:48 <lambdabot> Prelude succ :: Enum a => a -> a
12:52:48 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
12:52:48 <lambdabot> System.Exit ExitSuccess :: ExitCode
12:52:54 <Veinor> >:(
12:53:45 <napping> Are there any record libraries that put labels in a distinct namespace?
12:53:52 <alexyk> dons: why isn't there a strict Map.fold' while foldl and foldr were added to Map in 6.12?
12:53:53 <dons> alexyk: IntMap's are great. you'll probably be fine.
12:54:25 <dons> but do you know why you're switching to IntMap? 
12:54:32 <dons> do you have a way to measure the change it makes?
12:54:54 <alexyk> dons: I see much time spent looking up in Map ByteString
12:54:55 * dons encouages alexyk to be very methodical about profiling and tuning
12:54:56 <Veinor> Awesome, I wrote fibonacci numbers in the type syste
12:54:59 <Veinor> *system
12:55:04 <dons> alexyk: great.
12:56:00 <earthy> being methodical is only part of the trick though
12:56:18 <earthy> finding out exactly *where* to put strictness is the other part...
12:56:49 <dons> heap and retainer profiling help make that pretty methodical
12:57:05 <gwern> well, that's what we have that genetic algorithm program for evolving strictness annotations for :)
12:57:32 <earthy> dons: yah. until 50% of your heap is retained by SYSTEM...
12:58:11 <alexyk> gwern: the genetic makeup evolved into gwern!
12:58:35 <earthy> (I'm going to try again some time, but I gave up for the moment)
12:58:41 <gwern> I packaged too many programs... until finally the programs packaged me
12:58:43 <sclv> Veinor if you want to look through a broader range of packages don't use hoogle, use hayoo
12:58:55 <dons> its not magic. all this stuff can be done methodically. there's no excuse for just thrashing around blindly.
12:59:05 * earthy is not saying it's magic
12:59:07 <Veinor> what does hayoo get that hoogle doesn't?
12:59:18 <gwern> Veinor: most of hackage
12:59:25 <Veinor> why doesn't hoogle get it, then?
12:59:33 * earthy is simply saying that it's still a boatload of work with sometimes relatively little in the way of pointers towards progress
12:59:52 <aristid> Veinor: HList maybe?
12:59:52 <sclv> Veinor: because hoogle is designed to search only core packages.
13:00:01 <gwern> Veinor: hoogle doesn't ship .hoos for all the packages, and ndm has issues with supplying hits that may not be installable on someone's machines
13:00:02 <aristid> oh, lol, scrolling down is hard
13:00:08 <Veinor> ah
13:00:11 <aristid> chat client 1 : aristid 0
13:00:13 <earthy> unwanted laziness is hard to combat... even when you know roughly where it is
13:00:24 <Zao> Bros before .hoos.
13:00:31 <Veinor> itym broos.
13:01:49 <napping> Is there a packaged record library that lets you reuse field labels on ordinary constructors?
13:04:18 <napping> hmm, guess I'll go with my homegrown type synonym thing
13:10:32 <pastorn> hello
13:10:36 <pastorn> i suck at threads...
13:10:43 <danharaj> No one is good at threads.
13:10:47 <danharaj> Thread concurrency is hard.
13:11:25 <pastorn> i want to play with Vty... i think i will be needing two threads...
13:11:39 <pastorn> one to constantly redraw the screen, and one to handle input
13:12:00 <pastorn> (to be have the screen refreshing on more occasions than on user input)
13:12:19 <pastorn> this sounds like something for threads, right?
13:13:28 <Saizan> yes
13:14:01 <pastorn> so i was thinking of making this all very hello world-y
13:14:42 <pastorn> so one thread constantly asking for next_event, and the other redrawing at constant intervals...
13:14:48 <kmc> alexyk, did you profile IntMap versus Trie?
13:14:54 <kmc> you may not need to go to the trouble of interning
13:15:01 <pastorn> but when something happends in the event thread; how do i communicate that to the drawing thread?
13:15:05 <pastorn> IORef?
13:15:15 <gwern> block on an mvar?
13:15:16 <pastorn> or will i need more fancy stuff?
13:15:18 <kmc> both structures use the same sort of trie
13:15:22 <Saizan> pastorn: MVar or Chan
13:15:25 <kmc> pastorn, IORefs aren't in general thread-safe
13:15:37 <alexyk> kmc: I have nested ByteStrings in the adjacency lists
13:15:44 <kmc> MVar and Chan are the basic thread communication primitives
13:15:47 <alexyk> so if I were to quash BS, I'd intern
13:15:52 <kmc> (actually, Chan is implemented with MVar too)
13:16:21 <pastorn> @hoogle MVar
13:16:21 <lambdabot> module Control.Concurrent.MVar
13:16:21 <lambdabot> Control.Concurrent.MVar data MVar a
13:16:21 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
13:16:22 <kmc> pastorn, it sounds like the redrawing thread could use tryTakeMVar
13:16:54 <pastorn> kmc: it should also be using thredDelay, right?
13:17:06 <kmc> to redraw at regular intervals?
13:17:07 <kmc> yes
13:17:11 <pastorn> cool
13:17:58 <pastorn> > 1000 / 50
13:17:59 <lambdabot>   20.0
13:18:37 <pastorn> oh shi...
13:18:46 <pastorn> threadDelay takes microseconds....
13:19:24 <danharaj> Can you actually get microsecond time resolution on all platforms?
13:19:33 <pastorn> hehe...
13:19:41 <pastorn> i'm setting microSecondsBetweenRedraw = 20000
13:19:48 <pastorn> that should give me 50 Hz, right?
13:20:11 <danharaj> how many microseconds are there in a second ;p
13:20:18 <kmc> 7
13:20:21 <pastorn> 10^6?
13:20:33 <pastorn> danharaj: i don't know if i'm right....
13:20:37 <kmc> > 1000000 / 20000
13:20:38 <Botje> yes, 10^6
13:20:38 <lambdabot>   50.0
13:20:42 <pastorn> thanks :)
13:21:18 <danharaj> units have caused things to explode
13:21:22 <danharaj> this is a scientific fact.
13:21:25 <danharaj> always double check!
13:21:27 <kmc> a microsecond is a long time
13:21:39 <kmc> almost 300 meters long
13:21:53 <alexyk> kmc: I lean towards IntMap as it has a rich and uniform Map API vs Trie
13:21:57 <Tomsik> danderson: are you talking about that NASA newtons vs pounds thing?
13:22:01 <kmc> ok
13:28:30 <alexyk> do you have to unpack a ByteString to read an Int?
13:28:37 <danderson> Tomsik: no, I'm trying to configure a kernel that'll boot on this darn hardware
13:28:52 <jmcarthur> @hoogle readBS
13:28:52 <lambdabot> No results found
13:29:01 <jmcarthur> @where hayoo
13:29:01 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:29:24 <jmcarthur> hayoo is down?
13:29:40 <noteed> jmcarthur: hayoo.info is easy to remember
13:30:16 <noteed> jmcarthur: it seems
13:30:46 <jmcarthur> @hoogle Read a => ByteString -> a
13:30:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:30:47 <lambdabot> Prelude id :: a -> a
13:30:47 <lambdabot> Data.Function id :: a -> a
13:30:50 <jmcarthur> meh
13:31:44 * hackagebot tagged 0.1.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.1.1 (EdwardKmett)
13:41:02 <Philonous> Oh nice, just what I needed the other day
13:53:55 <aristid> the monad reader blog doesn't contain links to the old readers
13:54:03 <aristid> byorgey: ^
13:57:56 <Mathnerd314> say, are there any units packages? (for specifying microseconds etc.)
13:58:51 <sclv> Mathnerd314: there's one called dimensional but it is quite complicated
13:59:05 <sclv> and the numeric prelude offers a simpler take as well
13:59:26 <sclv> you can find them both on hackage
14:00:13 <sclv> dimensional is statically checked, the numeric prelude version is dynamic. both are very comprehensive. if you want a simple subset, you may be better rolling your own.
14:02:09 <Mathnerd314> ok
14:03:42 <Spewns> i think i might be starting to understand monads a little better... i suppose i'll try to write something later and see
14:04:06 <Spewns> aren't you all jumping for joy?
14:05:27 <mreh> \o/
14:06:17 <Spewns> yeah!
14:06:19 <Spewns> now all together now
14:08:40 <Peaker> Spewns, After you understand monads, you wonder what all the difficulty fuss was about :)
14:10:47 <svk_> Hey, style question: I have a function that provides a description for a type I've defined, e.g. f (StringType "x") == "character string"
14:11:05 <svk_> I use pattern matching for this, and at the end I have something like: f _ = "unknown type"
14:11:24 <svk_> However, when I cover all the actual types, that triggers a warning
14:11:57 <gwern> why shouldn't it?
14:12:08 <svk_> Is there something I should be doing otherwise so that I can write this without warnings, and so that I can get the effect I'm after?
14:12:09 <gwern> you are contradicting yourself
14:12:45 <svk_> Fair enough, but in a practical sense I might add another type later and forget to change this function
14:13:37 <zygoloid> svk_: do you really mean to match against StringType "x"?
14:13:52 <zygoloid> or do you actually want to match against StringType x?
14:14:07 <svk_> Eh, no, I meant that as an illustration of what a call to the function would look like
14:14:10 <svk_> Not a definition
14:14:20 <zygoloid> if you cover all the cases, you shouldn't get a warning
14:14:53 <svk_> Right, but I'm covering all the cases twice over because of the 'f _ = "unknown type"' at the end
14:15:10 <Spewns> Peaker: i hope so!
14:15:13 <zygoloid> svk_: you shouldn't need the f _ case if you're covering all the cases
14:15:23 <zygoloid> svk_: if you still get a warning it probably means you missed a case
14:15:42 <svk_> zygoloid: Right, but I might add a type later and forget to change the description function
14:15:54 <svk_> I'm not missing any cases, I'm getting the warning because of the f _, which is still there
14:16:51 <Saizan> svk_: i see your point, but in that case you'd get a warning about a missing case if you use -Wall
14:17:31 <svk_> Aha, there's a -Wall, thanks.. that solves my problem
14:17:45 <svk_> Oh wow, lots of other warnings
14:18:18 <Saizan> svk_: for completeness, i think there's a -fno-warn-overlapping-patterns or similar, which you can use for the while file by putting it in {-# OPTIONS_GHC .. #-} at the top of it
14:18:19 <chrisdone> :hoogle [Either a b] -> [b]
14:18:23 <chrisdone> @@hoogle [Either a b] -> [b]
14:18:24 <chrisdone> @hoogle [Either a b] -> [b]
14:18:25 <lambdabot> Data.Either rights :: [Either a b] -> [b]
14:18:25 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
14:18:25 <lambdabot> Data.Graph.Inductive.Graph nodes :: Graph gr => gr a b -> [Node]
14:18:29 <chrisdone> excellent
14:21:03 <gwern> @@?
14:21:12 <chrisdone> @_@
14:21:26 <gwern> oh no! a D
14:21:40 <chrisdone> i've been having some fun type errors today
14:21:42 <gwern> and my armor without fire intrinsics
14:22:09 <chrisdone> seems like every library i'm using is generic with type classes
14:22:28 <chrisdone> cgi, haskelldb, parsec3
14:22:37 <gwern> hoist on your own abstraction
14:23:07 <Paczesiowa> now, if only you could control those libraries with xml config files...
14:23:08 <lambdabot> Paczesiowa: You have 4 new messages. '/msg lambdabot @messages' to read them.
14:23:25 <svk_> Hm, a lot of the warnings I'm getting are for is for stuff like "symbol ';'" in Parsec code.. is it better style to write that as "_ <- symbol ';'" like the warning says, or should I suppress the warning?
14:23:40 <gwern> it is more explicit
14:24:12 <gwern> now the reader knows you were intentionally scrapping the result
14:24:23 <gwern> iirc it may also be more space efficient
14:24:30 <chrisdone> svk_: if space doesn't bother you hide the warning
14:24:36 <mauke> you should define ignore p = p >> return (); symbol_ x = ignore (symbol x)
14:24:51 <mauke> or would that be ignore p = p >>= const (return ())
14:25:10 <gwern> mauke: it would be Control.Monad.void
14:25:18 <mauke> oh ho
14:25:18 <chrisdone> :t void
14:25:18 <lambdabot> Not in scope: `void'
14:25:34 <Peaker> @type (()<$)
14:25:35 <svk_> Hm, could you explain the part about space efficiency, does this make a difference in the generated executable?
14:25:36 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
14:26:06 <gwern> svk_: it's somewhere in neil mitchell's blog
14:26:15 <chrisdone> @google neil mitchell mapm_
14:26:15 <lambdabot> http://neilmitchell.blogspot.com/2008/12/mapm-mapm-and-monadic-statements.html
14:26:16 <lambdabot> Title: Neil Mitchell's Haskell Blog: mapM, mapM_ and monadic statements
14:26:19 <mauke> preflex: seen ndm
14:26:19 <preflex>  ndm was last seen on #haskell 1 year, 38 days, 11 hours, 7 minutes and 39 seconds ago, saying: plus with current compiler technology, it would be slower
14:27:01 <Peaker> I wonder if with *current* compiler technology, it would be any faster
14:27:40 <gwern> Peaker: of course not. as neil says, 'it would be slower'
14:27:43 <gwern> duh
14:27:49 <mauke> that was more than one year ago
14:28:06 <Peaker> 1 year, 38 days, 11 hours, 7 minutes and 39 seconds are enough time to make some compiler improvements
14:28:41 * mauke ponders making preflex print milliseconds too
14:28:55 <gwern> mauke: what, are you advocating some sort of screwy reinterpretation of neil's statement where all temporal references are changed to something arbitrary like now = 1 year 38 days 7 minutes 39 seconds ago?
14:29:14 <Philonous> Wait a second, `foo` and `_ <- foo` desugar to the same code, don't they? f >> g  = f >>= \_ -> g
14:29:16 <olsner> it would make sense for time offline of IRC to result directly in compiler improvements
14:29:29 <gwern> I will thank you to permit me to retain my simple sensible interpretation of 'now' = 'now'
14:29:35 <gwern> and a = a
14:29:58 <mauke> __ = __   -- oleg style
14:31:57 <gwern> now do that with delimited continuations!
14:37:32 <McManiaC> did anyone get threadDelay to work with gtk2hs or is there anything else I can use?
14:37:52 <kmc> how doesn't it work?
14:38:41 <kmc> btw gtk gets cross if you do GUI stuff from more than one thread; that's what this stuff is for: http://hackage.haskell.org/packages/archive/gtk/0.11.0/doc/html/Graphics-UI-Gtk-General-General.html#v%3AunsafeInitGUIForThreadedRTS
14:38:42 <napping> are you being careful with threads in general around gtk2hs?
14:40:18 <McManiaC> napping: yeh, that thread has nothing to do with the GUI
14:40:30 <kmc> so what's the problem?
14:41:52 <McManiaC> oooh nvm
14:41:53 <McManiaC> lol
14:42:01 <McManiaC> I thought threadDelay was using seconds :(
14:42:13 <napping> it should work just fine, just don't ever try to directly call GUI stuff out from the main thread
14:42:47 <gwern> McManiaC: that's what you get for not reading the docs
14:42:59 <McManiaC> gwern: sorry :(
14:43:25 <gwern> if you assume threadDelay is in seconds, then either it's uselessly coarse-grained or you can ask it to do the impossible - 'threadDelay 0.0000000000000000000000000001'
14:44:07 <McManiaC> :D
14:44:10 <McManiaC> yeh
14:45:12 <napping> gwern: It doesn't promise hard realtime. As long as it sleeps at least that long it's fine
14:48:29 <alexyk> I need to write with Data.Binary the following: data IntBS = IntBS { trieIB :: Trie Int, totalIB :: Int, backIB :: IntMap ByteString } -- how do I enable that?
14:50:12 <dons> i think there's an instance of Binary for IntMap already preovided
14:50:25 <dons> but you'll need to write an instance of Binary for Trie Int
14:50:38 <dons> there's a tutorial for how to use Data.Binary in its documentation
14:50:40 <ivanm> dons: did you check through my counter arguments on that wiki page?
14:50:48 <dons> ivanm: haven't had time.
14:51:04 <ivanm> fair enough
14:52:33 <alexyk> dons: apparently Trie Int got some as its own write compiles :)
14:53:57 * BMeph is amused that napping is our resident expert on sleep commands...
14:55:09 <Peaker> Wouldn't it be better if Binary wasn't a type-class? There isn't necessarily one "true way" to serialize a data-type
14:55:55 <alexyk> BMeph: would be more surprising if he'd advise on excitement
14:56:05 <gwern> Peaker: there isn't? aside from switching around synonyms, I'd expect there to be an optimal serialization
14:56:33 <Peaker> gwern, With "Binary" you often have to support various wire formats.. Little-endian, big-endian, the same structure serialized for different purposes, etc
14:57:14 <Peaker> A friend of mine is trying his current project with Haskell and came to me to complain instances were global, it turned out he just wanted different serializations for stuff and was bummed he couldn't explicitly select the Binary instance.. 
14:57:33 <alexyk> dons: given Trie got a Binary instance, is this enough: instance Binary IntBS where put IntBS t n m = put t >> put n >> put m --?
14:57:35 <gwern> why would little-endian or big-endian matter? those are predefined serializations of numbers, not your optimal serialization of your datatype
14:57:51 <alexyk> spoken like a little-endian man
14:57:56 <Peaker> gwern, There's no "optimal" involved, you just have to be able to communicate in binary protocols
14:58:00 <napping> the design seems fine to mee. Binary instance gets you a reasonable global default, and you can directly use function to Get or Put for customizations
14:58:02 <gwern> Peaker: tell him to newtype it and defined the one he wanted
14:58:50 <Peaker> gwern, newtype'ing it is a problem, because many types are nested deep inside other types, and so these types would have to start taking type params to choose which newtype to use, or you'd have to make variants of them
14:59:07 <alexyk> and likewise get of just IntBS get get get --?  
14:59:20 <napping> if you just want to define one instance of the outer type, you can just serialize the inner types as you like
14:59:31 <dons> alexyk: yep
14:59:41 <dons> its great   the trie already has an instance. 
14:59:51 <dons> so then you just take apart the structure and serialize it.
15:00:23 <napping> Peaker: there's no rule you have to serialize substructures by calling put and get from their Binary instance, even if they do have one
15:00:38 <chrisdone> i tell the what, haskelldb makes coding with databases quite relaxing
15:00:39 <napping> now, if you want multiple serializations for the same structure that can be more trouble
15:01:01 <Peaker> napping, Right, but then you just use get/put directly and don't get to enjoy all the Binary-based goodies
15:01:12 <napping> oh, and newtypes can be used like .. put (Foo x) = put fooTag >> put (BigEndianInt x)
15:01:14 <Peaker> napping, If Binary was just a record containing get/put rather than a class...
15:01:44 <Peaker> napping, Right, but what if you have a big record with Int inside it, how do you get it to use the (Foo x) wrapper around its fields?
15:02:29 <napping> if you are writing the instance yoursef, you were directly calling put fieldN on each of the fields, and not liking what you got, right?
15:03:05 <napping> so if you define a newtype MyInt = MyInt Int with the binary instance you want, then you can still have the record fields be plain Int, but serialize them by calling put (MyInt fieldN) in your Binary instance
15:03:18 <Peaker> napping, but then I get to have just one instance
15:03:23 <napping> hmm?
15:03:26 <alexyk> dons: perhaps I've spoken too early... encoding Trie Int compiled, in the instance with get I get: Couldn't match expected type `Trie Int' against inferred type `Get t'
15:03:38 <Peaker> napping, I can't have one serialization of the record with big-endian ints, and one with little-endian ints. I get to have just 1 instance
15:03:52 <napping> Yes, this still ends up with one instance for your record type. I'm describing a way you can use not-default serializations of the members with some conveneint
15:04:28 <Peaker> napping, Yes, I know -- I'm trying to explain why I think a class is less flexible here.. I think an explicit record would be better
15:04:36 <napping> You can do it at a higher level, defining a newtype BERecord = BERecord {fromBERecord :: Record}, and using it similarly
15:05:02 <Peaker> napping, This may become cartesian
15:05:04 <dons> alexyk: looks like a type error, not a missing instance. you maybe didn't specify the type of the thiiing you're loading.
15:05:20 <shapr> Any Haskellers in the southeast USA?
15:05:20 <napping> well, nothing stops you from defining your own own serializers if you like
15:05:34 <shapr> Looks like there's a random #haskell meeting happening in Birmingham AL
15:05:58 <Rikardo3> @all how can you divide a long line in haskell into several lines - in order to keep the restrictions 80 signs each line ?
15:06:10 <lambdabot> *** "How" gcide "The Collaborative International Dictionary of English v.0.48"
15:06:10 <lambdabot> How \How\, adv. [OE. how, hou, hu, hwu, AS. h?, from the same
15:06:10 <lambdabot>    root as hw[=a], hw[ae]t, who, what, pron. interrog.; akin to
15:06:10 <lambdabot>    OS. hw[=o]w, D. hoe, cf. G. wie how, Goth. hw[=e] wherewith,
15:06:10 <lambdabot>    hwaiwa how. [root]182. See {Who}, and cf. {Why}.]
15:06:12 <lambdabot> [6115 @more lines]
15:06:13 <mauke> Rikardo3: with the <enter> key
15:06:19 <alexyk> dons: indeed
15:06:21 <napping> Probably best to do the dictionary passing yourself if you want to deal with multiple instances.
15:06:43 <Peaker> napping, btw: I have a pickler combinator to replace Binary on my TODO list anyway. I guess it's a good opportunity to make it use a record as well :)
15:06:56 <napping> Why not make a record for binary?
15:07:13 <napping> data Picker a = Pickler {pget :: Get a, pput :: a -> Put ()}
15:07:44 <Peaker> napping, Sure, that's a competitor to data.binary then, and has to reimplement everything built on top of the binary class
15:07:48 <napping> I wouldn't like to try to compete with the engineering on Get and Put
15:08:00 <alexyk> dons: forgot liftM3 gah
15:08:01 <Peaker> (though it can re-use get/put.. though it also seems silly that put is not just a monoid)
15:08:15 <dons> napping: there's a type class for that
15:08:28 <dons> and you use newtypes to control which instance is used
15:08:37 <dons> Peaker: the do notation is nice.
15:08:50 <gwern> hm. I wonder what serializations couldn't make put a monoid. maybe something that needs to modify the header? eg a compressed format
15:08:51 <Peaker> dons, You never use <- in it :)
15:08:57 <Peaker> dons, so might as well mappend [ ... ]
15:09:07 <shapr> Any Haskellers in the southeast USA?
15:09:15 * shapr waves a lambda flag
15:09:19 <napping> dons: building explicit dictionaries can be more flexible if you want to e.g. pass in a choice of serialization for all ints in the structure
15:09:53 <napping> parameterizing like that would be a huge pain with newtypes
15:10:32 <napping> how would you use newtypes to give you independent choices of serializing Int in big or little endian, and chars in ASCII or EBDIC?
15:10:35 <mauke> Rikardo3: http://hpaste.org/fastcgi/hpaste.fcgi/new
15:10:45 <Peaker> I think the notion of using a class Binary here means "There's one true way to serialize any type 'a' ". I think this notion doesn't work well
15:10:59 <dons> napping: but its un-haskellish.
15:11:07 <napping> Peaker: nonsense. It means "here is the default way to serialize 'a'"
15:11:17 <shapr> dons: Do you know any Haskellers in the southeast USA?
15:11:23 <Peaker> dons, It is quicksilver's first rule of type-classes :)
15:11:37 <napping> btw, if you want to go from records back to code that requires classes you can play fun tricks with unsafeCoerce#
15:12:14 <napping> callWithPickler :: Pickler a -> a -> (forall x . (Binary x) => x -> r) -> r
15:12:25 <Peaker> dons, "un-haskellish" is a bit less convincing IMO
15:13:07 <gwern> Peaker: clearly the adjective is 'un-haskelly'
15:13:13 <napping> .. callWithPickler p a f = unsafeCoerce# f p a !!!
15:13:16 <Peaker> composable picklers are probably easier for the kinds of serializations in the binary world than in the text world
15:13:25 <napping> I'm not sure if that's actually safe at all
15:13:45 <napping> certainly not portable
15:13:50 <kmc> so, so wrong
15:14:03 <napping> not as bad as taking the address of a value!
15:14:41 <napping> I'm pretty sure the existential even makes it safe w.r.t any given type only having a single instance for a given class
15:15:13 <alexyk> napping: what's Pickler?  is it a fast serializer?!
15:15:32 <alexyk> gimme some of those picklers!
15:15:47 <napping> alexyk: Nah, just making a pair of the put and get functions from a Binary instances, for cases when you want to parameterize things a bit more
15:16:02 <alexyk> ah
15:16:11 <napping> Data.Binary is as good as it gets for serialization, at least so far
15:17:25 <napping> By the why, why does the stream-fusion package not include a nice enumFromTo?
15:17:36 <McManiaC> is there a portable "new line variable"?
15:17:51 <McManiaC> like \n for unix, \n\r for windows etc
15:17:54 <napping> that seems to be the final missing ingredient to get full fusion for "loops" done up in nice Haskell style
15:18:39 <ivanm> McManiaC: just use \n and then the String IO does the conversions for you
15:18:47 <McManiaC> ok
15:19:00 <napping> Is the cabal gtk2hs build broken with 6.12.3 as well?
15:19:21 <ivanm> napping: don't think so
15:19:44 <napping> I'm getting an error trying to build glib :  Cannot find a definition for `g_object_get_type' in the header file.
15:20:45 <Saizan> that might depend on the version of the C gtk you've installed
15:21:16 <napping> pkg-config says 0.22
15:21:22 <napping> apt calls it libglib2.0-dev
15:23:49 <david_ko> Hey all. I'm trying to read someone else's code and came across an operator: ($=) . Unfortunately, it's a little hard to google symbols... Have any insight on how to figure out where this operator is defined and what it does?
15:24:09 <Baughn> @ask Saizan I'm cabalizing TypedIxSet - what license do you want?
15:24:09 <lambdabot> Consider it noted.
15:24:26 <napping> can you open the file in ghci? :info ($=) should tell you
15:24:29 <Baughn> david_ko: Basically, it's variable assignment
15:24:29 <ddarius> @hoogle ($=)
15:24:29 <lambdabot> No results found
15:24:34 <mauke> david_ko: http://www.holumbus.org/hayoo/hayoo.html?query=%24%3D
15:24:38 <Baughn> david_ko: Originally from the opengl package, now.. hmm
15:25:10 <Baughn> david_ko: http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
15:25:22 <napping> I suppose asking #haskell is a reasonably general procedure as well
15:25:31 <david_ko> Awesome, thanks :)
15:25:49 <Peaker> david_ko, You can try hoogle or hayoo too
15:26:23 <david_ko> And yeah, the ghci trick didn't work, but that's probably because I didn't have any opengl stuff imported
15:26:39 <napping> I mean running ghci on that exact file
15:27:07 <david_ko> Peaker: And yeah, I did try hoogling it, but the strings "$=" and "($=)" came up w/ no results..
15:27:10 <napping> Delete the .o or .hi if there is one, and it should open with a prompt like *Module>, which means everything inside the module is in scope
15:27:22 <david_ko> napping: I tried that too... Didn't work
15:27:26 <mauke> or run ghci on '*Module'
15:27:31 <napping> "Didn't work"?
15:27:56 <david_ko> napping: Yeah, said "Top level, not in scope", etc. The code compiles and runs fine though
15:28:16 <david_ko> napping: I tried both ":t ($=)" and ":info ($=)"
15:28:26 <napping> Are you sure you got *Module>? If there are any compiled files lying around you will only see the things exported from the module, not everything in scope
15:28:32 <david_ko> Ahhh
15:28:37 <david_ko> Let me try again
15:29:11 <napping> :info will tell you the original site of the definition, which might not be exactly what you want but should at least let you find the package
15:29:31 <napping> for example, :info Prelude.(+) says it's defined in GHC.Num
15:30:00 <napping> but, combine that with ghc-pkg find-module {module}, and you can tell what package defines it
15:30:02 <david_ko> napping: Yes, it was because I had compiled code lying around. Worked after I cleaned the dir
15:30:47 <alexyk> I rewrote my JSON2Graph to intern ByteStrings as it goes, so now all functions have a "dic" -- the accumulator.  It reminds me vaguely of the state monad.  How could I rewrite it shorter with that?  http://github.com/alexy/husky/blob/intern/JSON2Graph.hs
15:34:56 <napping> mapM will be like mapAccumL
15:35:33 <napping> IntBS -> (IntBS, a) ~= State a
15:37:15 <McManiaC> http://npaste.de/YB/ â why doesnt that ErrorT catch that exception?
15:37:35 <napping> ErrorT doesn't catch any exceptions
15:37:38 <alexyk> napping: didn't get the ~= line
15:37:53 <napping> alexyk: State IntBS a is equivalent to IntBS -> (IntBS, a)
15:37:56 <alexyk> ah ok
15:37:58 <alexyk> :)
15:38:08 <alexyk> ~= gave me a Perl flashback
15:38:33 <alexyk> "an old vet saw ~= and started running"
15:38:34 <McManiaC> napping: no exceptions at all?
15:39:06 <napping> ErrorT lets you raise the given err, and catch that. It has nothing to do with the usual exception system, which can only be caught in IO
15:39:29 <McManiaC> hmkay
15:39:32 <McManiaC> pity
15:40:01 <kmc> why do you want to use ErrorT?
15:40:42 <napping> oh, that's funny. Just deleting the #include <cairo-version.h> line is enough to get cairo compiling
15:41:44 <alexyk> napping: so how do I go about rewriting in state?
15:42:37 <napping> find all the things that are equivalent to inlining functions from State
15:42:54 <napping> first step, make the IntBS the last argument everywhere
15:43:41 <Peaker> Are there fclabels defined for tuples?
15:43:45 <Peaker> like first/second
15:44:04 <napping> make the body a do, turn all the where bindings that don't mention dic into a let
15:44:17 <napping> and the ones that do bind a (dic,val) = expr, make that val <- expr
15:45:12 <fryguybob> preflex: seen byorgey
15:45:12 <preflex>  byorgey was last seen on #haskell 2 days, 12 hours, 42 minutes and 24 seconds ago, saying: sigh, I hate proving substitution lemmas
15:45:39 <fryguybob> swallowed by the lemma...
15:45:46 <alexyk> napping: thx!  I had IntBS in the last position before finding mapAccumL, which wants it first, and then had to move it first everywhere :)
15:46:24 <napping> mapAccumL should turn into mapM, I think
15:46:34 <napping> mapM with state passes the state through left to right
15:54:39 <alexyk> IntMap has no insertWith' ?
15:54:47 <alexyk> is it "strict enough"?
15:54:53 <McManiaC> "getAddrInfo: does not exist (Temporary failure in name resolution)" â is there a way to fix this exception without having to restart my programm?
15:54:56 <McManiaC> after I get back my internet connection
15:55:24 <Saizan> you could catch the exception
15:55:25 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:25 <chrisdone> mmkay. don't use postgresql keywords for fieldnames with haskelldb
15:56:06 <McManiaC> Saizan: I do
15:56:18 <Saizan> @tell Baughn anything is fine, so i guess BSD3
15:56:19 <lambdabot> Consider it noted.
15:56:37 <McManiaC> but the exception gets raised and raised again, until I restart the programm by hand
15:57:19 <dons> alexyk: the question is whether you're combining a value with one previously stored in the tree, in a lazy or strict manner
15:57:51 <dons> alexyk: that is, will inserting either evaluate or discard a previously stored element? 
15:59:46 <Saizan> McManiaC: ah, you mean that if you don't restart the program it'd never succeed even if your connection works again?
16:00:20 <McManiaC> yep
16:02:02 <Saizan> ah, ok, then i don't know :)
16:02:06 <Baughn> @clear
16:02:06 <lambdabot> Messages cleared.
16:02:37 <sonoflilit> Hello
16:02:49 <Baughn> Saizan: I forked the repository.. I'm going to clean up what you have now, document it, add a TH deriver, and then probably upload if you don't object.
16:03:21 <Baughn> Saizan: I'm also going on vacation this weekend, so it might be a little while. :P
16:03:47 <sonoflilit> I was writing some code earlier, and I was wondering if there is a standard function kindaLiftM2 :: (Monad m) => (a -> b) -> a -> m b
16:03:53 <Baughn> Saizan: After that.. well, right now you can't have multiple key fields of the same type. I'm going to think about that one.
16:04:17 <ddarius> :t (return .)
16:04:18 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
16:04:32 <kmc> :t let (.) = (Prelude..) in (return .)
16:04:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
16:04:43 <napping> silly gtk2hs, not #ifdefing gtk symbols with proper version guards
16:04:53 <alexyk> dons: it appends to a list, and I want it all fast! :)
16:04:58 <dcoutts> napping: send patches!
16:05:10 <napping> where?
16:05:18 <napping> I'll make some if I get it to build
16:05:24 <dcoutts> napping: wherever darcs send says to send them
16:05:33 <napping> oh, ok
16:06:48 <napping> GIO had no version guards at all, which caused trouble around Emblem, and something assumed all the builder stuff exists since 2.12, when some was added a bit later
16:07:06 <alexyk> what do folks use to parse command line options?
16:08:10 <sonoflilit> thanks
16:08:18 <sonoflilit> now off to sleep :-)
16:10:30 <napping> dcoutts: what generates System/GIO/Types.chs?
16:10:37 <Saizan> Baughn: no objection :) for the key fields the obvious solution is to switch to indexing by labels, it'd be great if one could support both labels and type indexing, to cover all the cases with minimum hassle
16:10:47 <napping> the Emblem stuff needs to be guarded by GLIB_CHECK_VERSION(2,18,0)
16:10:53 <napping> but something seems to be overwriting it
16:10:57 <danharaj> Is it planned that thte LLVM backend will be the main one in the future for ghc?
16:11:43 <dcoutts> napping: the hierarchyGen program, from a text file describing the GObject class hierarchy
16:12:20 <dcoutts> napping: the text file has version tags on each class, to indicate the version it was added in
16:12:49 <napping> what version means >= glib-2.18?
16:13:17 <dcoutts> napping: look at the text file, it should be obvious
16:13:39 <dcoutts> napping: it's the marshal.list
16:14:07 <dcoutts> oh, no, that's the callbacks
16:15:06 <napping> that helped. How about removing individual functions?
16:15:19 <napping> the two builder_add_object calls only exist after 2.14
16:15:45 <dcoutts> napping: there's a macro for that, take a look in other files, you should find an example
16:16:28 <_Matt_J_W_> hi guys, what's the function log function for calculating log to the base 2?
16:16:31 <napping> hmm, well it seems the GTK_CHECK_VERSION I added by hand in Builder.chs is left alone
16:16:33 <_Matt_J_W_> in haskell
16:16:46 <napping> I don't see any obvious examples of controlling individual methods
16:17:57 <alexyk> uncommenting type signature for loadData at line 15 makes the proggy error, now it compiles OK: http://paste.pocoo.org/show/226319/.  Why?
16:17:58 <dons> alexyk: ah, so there's a list of values. then doing it lazy is probably fine. you could also experiment with a DList -- which supports fast append
16:18:26 <alexyk> dons: OK.  who do I provide a type signature ^^?
16:18:27 <dons> alexyk: what type error do you get .... :)
16:18:31 <alexyk> how
16:18:33 <dons> alexyk: the type signature you wrote is wrong.
16:18:44 <dons> loadData :: Binary a => FilePath -> IO a
16:19:04 <alexyk> dons: right, IO ()
16:19:13 <dcoutts> napping: it'd be GLIB_CHECK_VERSION for gio
16:19:25 <dcoutts> napping: see System/GIO/File/File.chs
16:19:33 <napping> Oh, yes, I know about that.
16:19:48 <napping> The problem was Types.chs was being automatically regenerated, overwriting where I tried to add it by hand
16:20:06 <dcoutts> napping: you found the tools/hierarchyGen/hierarchy.list then?
16:20:19 <napping> fortunately in that case it's just a matter of types being gone entirely, so begin more specific with if gio-2.18 in hierachy.list worked there
16:20:44 <alexyk> dons: hmm, at first I simply replaced IO a by IO () and it worked.  Then I did yours and it worked too -- compiled that is.  Hmm...
16:20:54 <dons> alexyk: IO () is wrong though
16:20:55 <napping> The problem in gtk was in Builder.chs, which needed a few methods guarded (with a GTK_CHECK_VERSION), which I did by hand. I was worried that would be overwritten, but it seems that file isn't automatically generated
16:21:02 <alexyk> dons: so why did it compile?
16:21:05 <dons> alexyk: youre telling it that the file containers only a single () value...
16:21:16 <dons> alexyk: some wrong programs can still compile
16:21:16 <napping> I don't see any way in hierarchy.list to put a version check on individual object methods
16:21:19 <alexyk> ah ok
16:21:33 <napping> But it seems I don't need to, if Builder.chs is not make by the hierarchy tool
16:21:34 <dons> alexyk: when you say IO (), the compiler says you obviously want to decode () from a file.
16:21:47 <dons> which you don't.
16:21:50 <alexyk> right
16:22:26 <napping> dcoutts: The last thing is the include of cairo-version.h, which doesn't exist for me
16:24:12 <dcoutts> napping: oh, that used to work, they've changed something.
16:24:17 <napping> I am confused, it seems Graphics.Rendering.Cairo.hs defines things that were already defined in cairo.h
16:24:47 <dcoutts> napping: they used to conditionally include cairo-version.h if the cairo version was recent, otherwise they defined the version macros locally
16:25:03 <dcoutts> napping: not sure why they changed it, maybe ask on the mailing list
16:25:28 <napping> well, it was certainly breaking for me - and working if I commented out the include
16:25:34 <alexyk> I often want to import functions qualified, as they may clash, but constructor naked, as they don't, so I do something like:
16:25:36 <alexyk> import qualified IntBS as IB
16:25:37 <alexyk> import IntBS (IntBS)
16:25:46 <alexyk> -- is there a better way?
16:26:02 <dcoutts> alexyk: I do the same
16:26:22 <alexyk> why is there no: import A, B, C -- syntax?
16:26:53 <alexyk> Haskell one liners are preceded by 20 import lines :)
16:27:07 <alexyk> top-heavy in imports
16:27:39 <Igloo> It wouldn't help much with hierarchical libs
16:29:14 <dons> alexyk: we have a lot of modules (something like 20 thousand on hackage). picking and gluing together pieces of those seems essentially to require some verbosity.
16:29:36 <napping> dcoutts: I have those things defined in cairo.h, but it's not safe to just include
16:29:42 <napping> Hey - if I put it in {- -} it might be
16:29:42 <alexyk> Igloo: how about shell syntax: import Data.{Map,List (mapAccumL)}
16:29:43 <dons> it would be interesing to design a module import syntax, for the case of a glue language with many many libraries in a hier namespace, that minimizes the number of characters you need to type
16:30:47 <chrisdone> lots of import lines is lame at first
16:30:52 <chrisdone> but then you realise it's great!
16:31:09 <chrisdone> where's this function from? oh, here it is in the module list!
16:31:29 <chrisdone> import qualified or explicit 4life
16:32:05 <napping> Can -} appear in a legal C file?
16:32:18 <napping> hmm, I guess obviously inside a comment, but otherwise?
16:32:34 <c_wraith> inside a string literal! >_>
16:32:47 <c_wraith> Um, yeah, don't mind me.
16:32:52 <dcoutts> napping: I'm not sure I follow
16:33:17 <napping> They include some funny internal header because it only #defines version macros
16:33:32 <napping> After preprocessing that leaves no junk that would confuse GHC, but it means it's fragile
16:33:48 <napping> including cairo.h reliably gets you the macros, but also definitions you don't waht
16:34:07 <napping> writing {- and then #include<cairo.h> and then -} gets the macros, and hides C declarations from GHC
16:34:14 <dcoutts> napping: oh in the .hs file, yes, it only works because cairo-version does not have any C code, just macros
16:34:41 <napping> except it doesn't work because my cairo doesn't have a cairo-version.h at all, and just defines that stuff somewhere under cairo.h
16:34:45 <dcoutts> napping: I think you'd have to email the gtk2hs-devel mailing list to work out why they changed it
16:34:51 <chrisdone> alexyk: check this bitch for an import list: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=26300
16:35:35 <Philonous> napping:  like inf if(...){i--} 
16:35:52 <alexyk> chrisdone: reads like a story :)
16:35:55 <chrisdone> :D
16:35:56 <napping> but that needs a trailing semicolon, right?
16:36:09 <napping> Ah, array literals -- int[1] a = {i--};
16:36:22 <alexyk> you almost don't need to write anything else, Haskell must be able to compose a program from that :)
16:36:31 <Philonous> napping: It's the last statement of a block, does that need a semi colon?
16:37:15 <dcoutts> napping: hmm, looking at the darcs history it seems my memory is failing me, it looks like it's always been like that since they cabalised it.
16:37:41 <chrisdone> alexyk: the rest of the file is short as a result
16:39:07 <napping> ok, patches sent
16:39:51 <napping> (and just now checking that the library I built actually works :p)
16:40:55 <napping> at least it does
16:43:22 <ezyang> What can I reasonably cast a C long into, Haskell side? 
16:43:39 <Veinor> the abyss from whence it came!
16:43:49 <revertTS>  /h
16:43:53 <revertTS> err, sorry
16:45:20 <c_wraith> I want . and $ on the type level. >_>
16:45:42 <c_wraith> I'm sick of types like IO (IO (MVar a)).  I should totally be able to write them as IO . IO . MVar $ a
16:46:37 * chrisdone wants type level currying
16:46:41 <blackdog> parentheses never hurt anyone
16:47:04 <c_wraith> they killed my mother :(
16:48:10 <c_wraith> Yeah, I know, not a very convincing story
16:48:25 <Philonous> chrisdone: Huh? Are there type-level functions that take pairs?
16:48:43 <Veinor> (->)? :P
16:48:57 <Philonous> Veinor: No, (->) is already curried
16:49:00 <chrisdone> well
16:49:12 <chrisdone> i really mean i wish type aliases were more flexible
16:49:14 <Philonous> Oh, you meant partial application. Sorry. Yeah, i second that
16:49:19 <chrisdone> type Foo a = IO a
16:49:19 <chrisdone> type Bar a = StateT () Foo a
16:49:20 <chrisdone>     Type synonym `Foo' should have 1 argument, but has been given 0
16:50:14 <chrisdone> i suppose this is because "Foo" isn't a proper type constructor, kinda
16:50:38 <Philonous> Type level lambdas
16:52:16 <Peaker> What's a good way to remove the Nth item from a list?  take n xs ++ drop (n+1) xs   would incur an extra copy (due to ++) which isn't necessary
16:53:15 <Saizan> unless take fuses with ++
16:53:51 <Peaker> I guess so, yeah
16:53:57 <twanvl> I would use  case splitAt n xs of (a,_:b) -> a++b
16:55:46 <blackdog> explicit recursive function? :) otherwise you're at least going to go down the front half twice
16:55:57 <blackdog> or a difflist approach
16:57:19 <pokoko222> cs people here have studied project managment in college? I wonder why i have such dumb subject in computer science.
16:57:35 <EvanR> i am looking for literature like web, blog, flames etc that talk about automatic type conversion (like int to floats in arithemetic)
16:57:54 <EvanR> i know i saw a link to it but never followed it
16:59:39 <Taejo> pokoko222: we had it, but I wouldn't say we have a good CS department
16:59:55 <pokoko222> same here
17:07:15 <alexyk> this is wrong: http://paste.pocoo.org/show/226330/ -- I need to either load dic from a file or assign a default; how do I do the syntax right in a main's do?
17:08:16 <mauke> dic <- case users of
17:08:16 <mauke>     Just fileName | fileName /= "no" -> loadData fileName
17:08:16 <mauke>     _ -> return IB.empty
17:09:17 <alexyk> mauke: return, of course
17:29:17 <pastorn> @hoogle Identity
17:29:17 <lambdabot> module Control.Monad.Identity
17:29:17 <lambdabot> Control.Monad.Identity newtype Identity a
17:29:17 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
17:29:36 <pastorn> oh, "mtl"
17:29:39 <pastorn> nice
17:30:07 <Veinor> is there a name for a monad m that also has an m t -> t?
17:30:20 <gwern> a monoid!
17:30:35 <gwern> because then you can define that as 'foo _ = mempty' 
17:30:36 <gwern> :)
17:30:44 <ddarius> A copointed monad.
17:30:46 <heatsink> semicomonad?
17:30:48 <mauke> Veinor: Identity?
17:30:48 <c_wraith> copointer...
17:30:54 <c_wraith> yeah, I was a bit slow on that one
17:31:12 * heatsink doesn't really know category theory
17:31:20 <Veinor> mauke: that's a good question
17:31:30 <c_wraith> all monads are pointed, meaning you have a -> m a
17:31:47 <c_wraith> co-pointed reverses the arrow in that, hence m a -> a
17:31:50 <Veinor> is there a natural monad that has m a -> a that isn't identity?
17:32:11 <Veinor> related; I know I asked this before, but what's a functor that isn't pointed?
17:32:22 <c_wraith> Veinor: (,) a
17:32:23 <ddarius> Veinor: No free monad will satisfy that (except Identity)
17:32:27 <pastorn> GeneralizedNewtypeDeriving is like cheating....
17:32:45 <ddarius> Veinor: Most comonads won't be pointed I suspect.
17:32:46 <pastorn> i just defined my own MxT which relied heavily on IO
17:32:56 <heatsink> Veinor: The list monad limited to non-empty lists
17:33:13 <ddarius> No cofree comonad will be pointed (except Identity).
17:33:13 <c_wraith> err, "(,) a" is an answer to your second question:  a non-pointed functor
17:33:18 <pastorn> then i just made a non-transformer version with "deriving (Monad, MonadIO, MonadMx)" and it all magically worked
17:33:29 <Veinor> c_wraith: yeah, that's the answer I got last time too :D
17:33:39 <c_wraith> Veinor: I'm the one who gave it, too :)
17:34:04 <Veinor> hey, anybody know a functor m that doesn't have a function of type a -> f a? :D
17:34:07 <Veinor> er, m a
17:34:22 <Veinor> also, why's that called pointed?
17:34:42 <ddarius> There are things that are monads and comonads, e.g. M -> A and (M,A) where M is a monoid.
17:34:50 <c_wraith> I bet topology is involved
17:35:17 <c_wraith> Something like "there is a special point in the functor"
17:35:52 <benmachine> whee I interfaced a C library enough to make the LEDs on my wii remote flash in sequence
17:35:59 <benmachine> without writing a single line of C :O
17:36:02 * benmachine hugs bindings-DSL
17:36:17 <benmachine> (actually I wrote a lot of C but only as testing >_>)
17:38:44 <Veinor> is (,) t a monad or just a functor?
17:39:15 <Baughn> Veinor: If you can implement join, it's a monad
17:39:28 <Baughn> ..well, if it's an applicative functor and you can implement join
17:39:32 <Veinor> so, so, ((a,t),t) -> (a,t)
17:39:42 <mauke> and return
17:39:54 <Baughn> Thus the applicative functor.
17:40:02 <Baughn> So, there's a reason there's a Monoid constraint for that one. ;)
17:40:02 <jmcarthur> you mean (t, (t, a)) -> (t, a)
17:40:07 <Veinor> yes :P
17:40:38 <Veinor> so you need that and (t,a) -> (a -> (t,b)) -> (t,b)
17:41:12 <jmcarthur> you can write that in terms of join and fmap
17:41:21 <Veinor> yeah.
17:42:00 <jmcarthur> so sad that it's not defined as a monad in base :(
17:42:09 <Baughn> >>= is a mess.. I'd much prefer if join was the one in Monad
17:42:22 <jmcarthur> it's just Writer, after all, but with a sane ordering of values
17:42:51 <jmcarthur> i'd like join and (=<<) to be in Monad with default definitions in terms of each other
17:43:33 <Baughn> I could live with that.
17:43:42 <benmachine> and (>>=) to be defined externally as flip (=<<)?
17:43:53 <benmachine> it seems like (>>=) is used most often of all the methods though
17:43:54 <jmcarthur> maybe even (<=<) so that you could define the monoid-like functions (return and (<=<))
17:44:07 <benmachine> can you define join or whatever from (<=<)?
17:44:13 <jmcarthur> sure
17:44:33 <jmcarthur> don't want to prove it, but i am pretty sure about it...
17:44:43 * benmachine has a look
17:44:54 <jmcarthur> hmm... maybe not
17:44:59 <benmachine> I didn't think so
17:45:02 <heatsink> :t (<=<)
17:45:03 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:45:17 <benmachine> you can't put a monadic value *in* anywhere
17:45:54 <ddarius> A global point (of X) in category theory is an arrow 1 -> X where 1 is the terminal object.  One can also have "variable points" which is just an arrow (i.e. every arrow is a "variable point").  The category of endofunctors over a category does not have a terminal object unless the base category does; however, it does have a monoidal product and unit, namely identity and composition.  We can say a point of a functor is an arrow I -> F where
17:45:55 <ddarius>  I is the unit of the monoidal product.
17:46:41 * Veinor head explode
17:46:52 <Baughn> benmachine: >>= may be used often, but it's the least convenient when /implementing/ the thing. pure/fmap/join make much more sense. :/
17:47:28 <benmachine> Baughn: I dunno, with something like State, since >>= is the most used it's usually obvious what behaviour it should have
17:48:21 <Baughn> I'd have to say it's pretty obvious how join should work, too
17:48:40 <Baughn> I mean, for State, join is just .!
17:48:52 <benmachine> join :: (s -> (s, s -> (s, a))) -> s -> (s, a)
17:48:53 <danharaj> :t join
17:48:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:49:19 <benmachine> it's not perfectly obvious how to thread the states there
17:49:25 <benmachine> although I suspect there's only one way to do it
17:49:34 <benmachine> er
17:49:35 <benmachine> two
17:49:36 <c_wraith> ask djinn
17:49:41 <mauke> @djinn  (s -> (s, s -> (s, a))) -> s -> (s, a)
17:49:41 <lambdabot> f a b =
17:49:41 <lambdabot>     case a b of
17:49:41 <lambdabot>     (c, d) -> d c
17:49:44 <benmachine> given existence of reverse state monad :)
17:51:51 <danharaj> that type signature reminds me of continuations
17:55:07 <ddarius> :t \m k -> (const m >=> k) ()
17:55:08 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
17:56:29 <pastorn> @type (>=>)
17:56:29 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:56:34 <ddarius> :t \m -> (const m >=> id) ()
17:56:35 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
18:11:36 <heatsink> principle types.  PRINCIPLE types.  PRINCIPLE.
18:12:43 <danharaj> Principal Types of Haskell High
18:14:11 <ddarius> Principal typings.
18:14:35 <EvanR> you people are insane
18:15:26 <Pseudonym> Java has principle typing.  Haskell has principal typing.
18:15:27 <ddarius> @google principal typings
18:15:28 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.6144
18:15:54 <napping> Haskell doesn't have principal typings
18:16:06 <Pseudonym> H98 does.
18:16:12 <napping> It might have principal types
18:16:24 * Pseudonym thinks about that
18:16:47 <Pseudonym> It has a type inference algorithm which computes principal types.  I would call that "principal typing".
18:16:58 <Pseudonym> But what do I know.
18:17:33 <napping> No, "principal typings" means given a piece of code alone, you can decide if it's valid, and if so you end up with a "most general" combination of 1) A type for the code, and 2) assumptions about the environment
18:17:55 <napping> The classic counterexample is simply "x x"
18:18:17 <napping> It's valid if (x :: a -> a), or if (x :: (a -> a) -> (a -> a)) and so on
18:18:32 <napping> and each is a weaker assumption about the environment that the last
18:18:53 <EvanR> i have been told that a function of the form forall a . a -> a -> Bool always evaluates to the same value regardless of input?
18:19:03 <EvanR> is that true
18:19:07 <napping> principal typings are very nice for all sorts of separate compilation and compositional type inference stuff, but hardly any interesting systems have them
18:19:14 <napping> EvanR: unless there is evil inside
18:19:40 <napping> you can't do anything with the "a" without using unsafe* functions
18:19:45 <EvanR> so you are anticipating my bringing up ocaml (<=) : 'a -> 'a -> Bool 
18:19:53 <EvanR> which actually works on anything
18:20:02 <EvanR> this is evil
18:20:16 <Pseudonym> @free f :: a -> a -> Bool
18:20:16 <lambdabot> f x = f (g x) . g
18:20:24 <Veinor> how does it compare functions?
18:20:24 <Pseudonym> f y x = f (g x) (g y)
18:20:28 <Pseudonym> Sorry.
18:20:32 <Pseudonym> f x y = f (g x) (g y)
18:20:37 <Pseudonym> So yes.
18:20:44 <Pseudonym> That's for all g.
18:21:05 <EvanR> Veinor: with an Invalid_argument exception
18:21:09 <Veinor> Pfffff
18:22:03 <napping> Pseudonym: "principal types" means given the environment you can come up with a most general type for the expression. That's weaker, but even that's hard to combine with higher rank types
18:22:09 <Pseudonym> EvanR: O'Caml's (<=) works on a union of monotypes.
18:22:18 <Pseudonym> It's not really polymorphic.
18:22:47 <EvanR> does that mean its type signature is inaccurate
18:22:49 <Pseudonym> napping: There you go.  You learn new terminology every day.
18:23:15 <Pseudonym> EvanR: It means that the implied "forall" is not a real "forall".
18:23:34 <Pseudonym> Plenty of languages have this.  Java, for example, derives all objects from java.lang.Object.
18:23:53 <Pseudonym> So in Foo<X> you can assume X is-a Object.
18:24:03 <EvanR> but not int
18:24:17 <Pseudonym> Similarly, in Prolog-like languages, any two variables can be unified
18:24:54 <EvanR> i need to know more :((
18:25:28 <Pseudonym> We all do.
18:25:59 <EvanR> so in haskell we would represent this as
18:26:01 <Pseudonym> The one thing you can't buy is time.  Contrary to what The Beatles claimed, you can buy a close enough approximation to love that it doesn't matter, but you can't buy time.
18:26:35 <EvanR> wait i cant represent it in haskell
18:26:44 <EvanR> it needs to be two of the same type
18:26:57 <EvanR> but has the same constructor
18:27:11 <EvanR> (<=) :: Compare -> Compare -> Bool
18:27:21 <EvanR> but i cant compare int and float
18:27:39 <Pseudonym> :t (<=)
18:27:40 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:27:41 <Veinor> @type (<=)
18:27:42 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:27:44 <EvanR> a type class is cheating
18:27:49 <Pseudonym> No, it isn't.
18:28:01 <EvanR> its ad hoc polymorphism
18:28:02 <Pseudonym> Because effectively what O'Caml is doing is putting a typeclass constraint on 'a.
18:28:08 <Pseudonym> Only it's checked at run-tim.
18:28:10 <Pseudonym> time
18:28:13 <ddarius> Type classes were specifically designed to solve the problem the MLs had with comparing and equality and numeric types.
18:28:22 <Pseudonym> And, I might add, Miranda.
18:28:24 <EvanR> yes
18:28:27 <heatsink> You can buy space and a means of acceleration.  With those two things you can make time.
18:28:33 <EvanR> i see exactly why type classes are good
18:28:39 <Pseudonym> Miranda's = and show had the same problem.
18:29:05 <EvanR> what im trying to understand is how bad everything else is, and if theres anything better, theoretically
18:29:34 <EvanR> object oriented programming fails miserably in this case
18:30:10 <EvanR> c++ regularly overloads stuff with every combination of two types
18:30:48 <heatsink> That's ad hoc polymorphism, resolved statically
18:30:50 <Pseudonym> C++ ad-hoc overloading has little to do with object oriented programming.
18:31:09 * ddarius wishes he had a good reason to use C++.
18:31:14 <EvanR> right but thats where you see adhoc a lot
18:31:40 * Pseudonym is using C++ right now
18:31:44 <EvanR> what im saying is that OOP subtyping cant really handle basic arithmetic and comparison
18:32:23 <ddarius> EvanR: It's called the binary method problem.  One solution is multimethods, but oftentimes those are essentially Turing-complete hammers, e.g. in Common Lisp.
18:32:33 <EvanR> ddarius: i must know more
18:32:47 <Pseudonym> EvanR: I think it's more correct to say that most OO languages don't implement all of OO.
18:33:00 <Pseudonym> Haskell is, ironically, closer than most OO languages.
18:33:17 <EvanR> what part is missing... ah... type classes?
18:33:18 <ddarius> Pseudonym: I think the binary method problem is intrinsic to something that can make a good claim of being OO.
18:33:23 <heatsink> What does all of OO comprise?
18:33:46 <Pseudonym> OK, first of all some terminology.
18:33:50 <zeiris> Is there a way to make runInteractiveProcess search PATH on Windows?
18:33:51 <EvanR> ddarius: yes thats what im seeing in practice
18:33:55 <Pseudonym> A "type" is a collection of values.
18:34:03 <Pseudonym> A "class" is a collection of types".
18:34:12 <Pseudonym> This is in keeping with non-naive set theory terminology.
18:34:27 <Pseudonym> When you say "class Foo" in Java or C++, you're doing three things:
18:34:32 <Pseudonym> 1. Declaring a type, "Foo".
18:34:45 <Pseudonym> 2. Declaring a class with the same name, "Foo".
18:34:54 <Pseudonym> 3. Declaring that the type "Foo" is a member of the class "Foo".
18:35:00 <Pseudonym> In Haskell we decouple those three things.
18:35:48 <EvanR> this is good
18:36:12 <c_wraith> the CPP pass is before the template haskell pass, right?
18:36:20 <ddarius> c_wraith: Yes.
18:36:23 <Pseudonym> Yes, it is good, but we don't have a mechanism for implementation inheritance.
18:36:32 <ddarius> Don't want.
18:36:51 <ddarius> Anyway, with various encodings of OO, implementation inheritance is straightforward.
18:37:10 <kmc> implementation inheritance is a bad idea
18:37:12 <heatsink> When is implementation inheritance useful?
18:37:27 <ddarius> (Of course, most of those reduce it to delegation which is the Right Thing To Do.)
18:37:29 <EvanR> Pseudonym: question, what does a class consist of? operations on types in that class?
18:37:29 <heatsink> You mean how a derived C++ class gets the same fields and methods as its base?
18:37:31 <kmc> of course, when the alternative is a ton of boilerplate to delegate, it's useful
18:37:47 <kmc> but the right solution is not implementation inheritance -- it's good lightweight ways to specify delegation
18:38:40 <kmc> when i do OOP in Haskell it's usually with straight-up records, not lots of types and type classes
18:38:43 <Pseudonym> I think it was Philippa who pointed out that supertypes (the dual of subtypes) would also do some of the job.
18:38:43 <ddarius> Incidentally, I would say the core of "OOP," as most programmer's intend it, is dynamic dispatch.
18:38:54 <kmc> and for all its flaws, the Haskell record syntax makes delegation relatively simple
18:39:17 <kmc> since we're arguing about what is and isn't OOP, i'm obliged to link http://www.paulgraham.com/reesoo.html
18:39:29 * ddarius isn't aware of any "flaws" with Haskell's record system; just some overconservativeness.
18:40:04 <kmc> "Perhaps part of the confusion ... is that the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects..."
18:40:10 <Pseudonym> ddarius: There's also the general flaw that Haskell doesn't have a good concept of nested namespaces.
18:40:33 <allbery_b> * ddarius isn't aware of any "flaws" with Haskell's record system; just some overconservativeness.
18:40:40 <allbery_b> update syntax isnt first class
18:41:24 <kmc> well i'll admit that these "flaws" might be by-design conservativeness and not mistakes
18:41:29 <EvanR> Pseudonym: your OO concept of class coincides with haskell type class?
18:41:38 <kmc> but that's irrelevant to whether they get in the way when actually coding
18:41:42 <solrize> main hassle with the record system is it spews all the accessors into the namespace
18:41:58 <ddarius> kmc: His list is retarded and also he is trying to tell "all those people" that they are wrong, rather than trying to find out what all those people are agreeing on.
18:42:05 <kmc> haha
18:42:09 <solrize> also, update is slow because it copies the whole value.  i wonder if the underlying implementation could be more like IntMap
18:42:10 <ddarius> Pseudonym: I agree with that, but that isn't a problem with records.
18:42:12 <kmc> i don't see what's especially wrong with the list
18:42:29 <kmc> i agree that Graham is the prototypical smug Lisp weenie, but the list isn't even written by him
18:42:48 <kmc> (and i also think "smug Lisp weenie" is a prejudicial term)
18:42:54 <Pseudonym> EvanR: In fact, my description of "OO" doesn't coincide with Alan Kay's definition, and his probably wins.
18:43:02 <Pseudonym> But then neither do C++ or Java.
18:43:04 <kmc> "dynamic dispatch" sounds like fancy terminology for something utterly unremarkable in a world of first-class functions
18:43:19 <kmc> if you store ints in a data structure, you don't talk about how they're "dynamically dispatched"
18:43:35 <ddarius> kmc: First-class functions + existentials (+ subtyping if you like) and you have dynamic dispatch.
18:43:36 <EvanR> yes dynamic dispatch confuses me 
18:43:46 <Pseudonym> ddarius: Plus there's syntax.
18:43:56 <Pseudonym> And syntax matter.s
18:44:04 <Pseudonym> You can write Smalltalk in C, but it's painful.
18:44:48 <kmc> i don't see how existentials deserve to be included in that definition
18:44:51 <kmc> they are useful in conjunction, sure
18:45:04 <kmc> but you can get pretty far doing OOP in Haskell without them
18:45:19 <kmc> and dispatching dynamically all the while
18:45:25 <ddarius> kmc: There's an existential in your closures and when closures don't work nicely, it's easier to pull that existential out.
18:46:10 <kmc> Existentials? In *my* closures? It's more likely than you think.
18:46:12 <ddarius> Personally, my opinion of what "OO" should be, is that style of programming that is rather naturally evoked from message passing concurrency.
18:46:26 <Pseudonym> Yes, I agree.
18:46:27 <kmc> mm
18:46:35 <Pseudonym> IMO, Erlang is one of the best OO languages in existence.
18:46:52 <kmc> yet another perspective from which C++ is one of the least object-oriented languages in existence
18:47:07 <Pseudonym> Most C++ luminaries will agree with you.
18:47:20 <Pseudonym> They argue that C++ is multi-paradigm, and there is some truth in that.
18:47:41 <kmc> any paradigm you like as long as it's black
18:47:52 <ddarius> kmc: Again, what I think "OO" should mean and what people mean when they say "OO" is not equal.
18:48:02 <gwern> kmc: that's racist!
18:48:16 <Pseudonym> No, not true.  C++ gives you generic, generative, functional, and also provides mechanisms for "outboard paradigms", e.g. relational databases.
18:48:40 <gwern> generative?
18:48:52 <Pseudonym> Yeah, in the sense of product line engineering.
18:49:08 <Pseudonym> C++'s problem is Picasso's problem.
18:49:09 * gwern dunt know that sense either
18:49:10 <EvanR> outboard paradigms
18:49:18 <EvanR> wahhahhahaha
18:49:29 <kmc> but can it *utilize* the outboard paradigms
18:49:29 <gwern> EvanR: I dunno, that's a pretty good analogy
18:49:33 <kmc> and *leverage* them
18:49:45 <kmc> i'm not satisfied with a language that merely *uses* and *provides*
18:49:49 <kmc> it must *facilitate* and *leverage*
18:50:02 <EvanR> or do they spontanouesly detach and fly into nearby c# java and d boats
18:50:19 <Pseudonym> Picasso commented that paint manufacturers make Paris green, cadmium green, and just about every colour of green imaginable.
18:50:27 <Pseudonym> There's only one shade of green they don't make, and that's the one you need.
18:50:43 <gwern> EvanR: exactly, can the host language hold together under the power of the outboard paradigm?
18:50:46 <kmc> if programming languages were boats
18:50:51 <EvanR> haha
18:51:11 <Pseudonym> gwern: The thing about product line engineering is that most developers don't write single programs, but rather product lines.
18:51:12 <gwern> kmc: haskell would be a catamaran, I think
18:51:16 <kmc> hell yeah
18:51:24 <EvanR> i claim the U boat language
18:51:27 <gwern> c++ would be a soviet-era hoverboat
18:51:31 <kmc> and/or one of the new USN ships with a railgun on top
18:51:32 <gwern> EvanR: that'd be assembler
18:51:35 <Pseudonym> For example, GCC isn't a single compiler.
18:51:48 <Pseudonym> It's a product line of compilers.
18:51:51 <kmc> which language is http://www.boatdesign.net/forums/attachments/open-discussion/3481d1120586048-building-raft-75-table_boat.jpg
18:52:21 <EvanR> gwern: what about the civil war era submersibles
18:52:22 <gwern> EvanR: it floats beneath high level languages, unobserved, cramped, smelly, until it brutally fires a error upon its target
18:52:34 <EvanR> PDP11 ;)
18:52:36 <Pseudonym> What Coplien calls "outboard paradigms", Haskellers usually call EDSLs.
18:52:40 <gwern> kmc: PHP?
18:52:42 <Pseudonym> Which isn't necessarily a better term.
18:52:44 <kmc> yeah
18:53:03 <kmc> i think C++ might be the Titanic
18:53:07 <Pseudonym> Haskell can handle any EDSL so long as it has a nice algebra.
18:53:17 <EvanR> the titantic was actually sinkable though
18:53:19 <gwern> kmc: that said, I'm surprised it floats. it doesn't look like it displaces enough to hold a human
18:53:23 * ddarius encounters COBOL in the wild.
18:53:27 * ddarius attacks with fire.
18:53:27 <kmc> gwern, it might not float at rest
18:53:29 <ddarius> No effect.
18:53:32 <kmc> It's super effective!
18:53:35 <gwern> ddarius: so that would be the HMS Constitution...
18:53:36 <kmc> oh :/
18:53:59 <gwern> hm. USS Constitution?
18:54:24 <EvanR> someone take this and generate a webpage with to-scale comparisons of the boats
18:54:28 <gwern> ah yes, USS. not USN
18:55:19 <kmc> i think i've had this conversation before
18:55:33 <kmc> on IRC or in YOSPOS or something
18:55:44 <Pseudonym> The very name "HMS Constitution" is wrong.
18:55:53 <kmc> what, Britain has a constitution too
18:55:54 <gwern> kmc: this is the 15,983rd iteration.
18:56:01 <Pseudonym> Kinda.
18:56:11 <ddarius> kmc: You should use the semantic web to keep track of your conversations and relate/query them.
18:56:14 <kmc> it's just nobody knows exactly what's in it ;)
18:56:19 <kmc> eah
18:56:23 <ddarius> "HMS Magna Carta"
18:56:23 <kmc> gotta get me some of that semantic web
18:56:25 <gwern> kmc: in 2 loops, we did not argue about the bon festival. in 459 loops PHP was not likened to a table
18:56:45 <kmc> i don't get your bon festival reference
18:56:53 <gwern> the suggestions for breaking the loop have taken 6 different forms; one was a part time job
18:57:11 <Pseudonym> Accoring to the British constitution, James Hewitt should have been executed and had his head put on a spike in the Tower of London.
18:57:32 <kmc> for shagging the princess?
18:57:33 <gwern> kmc: apparently this loop will not add to the two's number
18:57:43 <Pseudonym> The consort to the heir to the throne, yes.
18:57:46 <Pseudonym> That's treason.
18:58:08 <gwern> by the treason act of 1351, yes
18:58:59 <sshc> What i[C[C[C[C[C[Cs the typo of r' in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26301#a26301?
18:59:13 <kmc> nice control codes
18:59:30 <kmc> sshc, add a sig r' :: Int
18:59:30 <Pseudonym> Actually, he might not technically be "nobility".
18:59:32 <kmc> then look at the error
18:59:43 <Pseudonym> Ah, beheading was abolished in 1973.
18:59:44 <sshc> type
18:59:51 <ddarius> Lame.
19:00:12 <ddarius> Nothing gets the blood flowing like a good beheading.
19:00:17 <kmc> sshc, it's probably (Integral a) => a -> a, but subject to that 'a' being the same as gfc's 'a'
19:00:24 <Pseudonym> That's weird, though, that it stayed on the books until then.
19:00:25 <kmc> that means you can't write the signature without the ScopedTypeVariables extension
19:00:33 <gwern> Pseudonym: it's england
19:00:37 <kmc> in which case, you' have to put an explicit "forall a." before the type for gfc, to bring 'a' into scope
19:01:07 <Pseudonym> Most of this stuff was taken off the books in the 19th century, though.
19:01:20 <gwern> none dare call it treasion
19:02:02 <kmc> in fact
19:02:11 <kmc> you would then omit (Integral a) on the sig for r'
19:02:17 <kmc> because the context is already in scope
19:02:48 <kmc> intuitively, the implicit type class dictionary is a free variable of r', just as a and b are
19:06:36 <ddarius> @google paradox of self-amendment
19:06:37 <lambdabot> http://www.earlham.edu/~peters/writing/psa/index.htm
19:06:38 <lambdabot> Title: Peter Suber, Paradox of Self-Amendment, Table of Contents
19:07:28 <Saizan> if you keep the (Integral a) => in the type of r' it'd be like if you also added a forall a. to it
19:10:20 <EvanR> dammit im trying to parse my buffer for everything everyone said about OOP
19:10:28 <EvanR> need to learn to use my client at some point
19:10:31 <kmc> lies, all lies
19:10:41 <kmc> btw you can read all of #haskell ever
19:10:46 <kmc> at http://tunes.org/~nef/logs/haskell/
19:10:46 <EvanR> kmc: did you say that OO to you seems to basically be like concurrent communicating processes
19:10:48 <kmc> no
19:10:53 <EvanR> who was that
19:10:56 <kmc> i agreed with someone who said that
19:11:01 <EvanR> :S
19:11:04 <Saizan> ddarius
19:11:21 <EvanR> so far with my concurrent haskell ive only needed one-way communication
19:11:29 <EvanR> so this is like the actors model, or something
19:11:44 <Saizan> and in particular message passing, rather than shared-state.
19:12:04 <EvanR> message passing is two way
19:12:39 <EvanR> what do you mean by shared state
19:13:13 <dolio> Shared state is where you have a variable of some sort that can be accessed from multiple threads.
19:13:51 <Saizan> and yeah, one can emulate the other, but that's not the point
19:13:52 <EvanR> an MVar can be both a message and a shared state
19:14:59 <kmc> a Chan likewise
19:16:02 <alexyk> what exactly does +RTS -A... do
19:16:02 <alexyk> ?
19:16:17 <dolio> Message passing would be more like a one-directional Chan. I don't think that's how the actual Chan works, though.
19:16:20 <dolio> Kind of curious.
19:16:38 <ddarius> dolio: Chans are implemented with essentially linked lists of MVars.
19:16:46 <kmc> there's a pattern for it in Haskell anyway
19:16:50 <kmc> and maybe a library as well
19:17:06 <kmc> where you make a chan, fork a thread which has access to the "read" method only, and return a function which has access to the "write" method only
19:17:08 <kmc> all using closure
19:17:10 <EvanR> i figured a message pass has a result, whereas a chan write has none
19:17:24 <kmc> which is sort of like the old-school non-concurrent way to build objects out of closures
19:17:30 <dolio> Yes, I suppose that's good enough.
19:17:45 <ddarius> Alternatively, you can use newtype wrapping.
19:19:48 <EvanR> does haskell have sub classes?
19:23:33 <QtPlatypus> EvanR: What is a sub class?
19:23:37 <heatsink> EvanR: Yes.  You can have a class B where every member of B is also a member of A.
19:24:14 <EvanR> so were talking about Ord is a sub class of Eq
19:24:22 <heatsink> yea
19:25:15 <kmc> haskell has no subtyping however
19:25:19 <EvanR> man haskell's type system is more complex than its... value system
19:25:32 <ddarius> EvanR: It quite definitely is not.
19:25:33 <kmc> EvanR, that's why we should get dependent types
19:25:59 <dolio> GHC has subtyping, of a sort.
19:26:05 <kmc> it would unify the two and the result is simpler than either alone
19:26:14 <kmc> it just... fails to have certain desired properties
19:26:21 <dolio> So does Haskell proper, I suppose, although it's very limited.
19:26:39 <Saizan> dolio: what are you referring to?
19:26:51 <kmc> GHC has subkinds, even
19:27:03 <dolio> forall a. a < Int < exists a. a
19:27:08 <EvanR> heres haskell without a type system. (x y z), (Foo x), case, let, f x y = z, and do notation. done
19:27:23 <dolio> forall a. a -> a < Int -> Int < exists a. a -> a
19:27:32 <EvanR> most of the code in this channel is type declarations
19:27:47 <kmc> EvanR, and the only types you need for that are (->) and (Foo x)
19:28:37 <kmc> most of the code in this channel is types, because it's documentation
19:28:45 <kmc> and that will make up a large part of any language channel
19:29:05 <EvanR> yeah but the actual code is simple
19:29:12 <dolio> Int -> Int < (forall a. a) -> Int (I think that's right).
19:29:18 <c_wraith> Is there any way to get the File for a Name in Template Haskell?
19:29:25 <kmc> also i'm not sure why you included "do" but not other sugars
19:30:00 <dolio> P' < P /\ Q < Q' => (P -> Q) < (P' -> Q')
19:30:08 <EvanR> stuff that stands out in my mind in generalized abstract nonsense sourcecode
19:30:15 <kmc> also you need to include type classes as part of both the type system and value system
19:30:43 <c_wraith> actually, location :: Q Loc will suffice.  Kind of hacky, but it will suffice.
19:30:59 * ddarius wonders if he can make a Yoneda like result between the type level and the value level via type classes.
19:31:49 <dolio> forall a. P < P[a := T] < exists a. P, I think is a rule.
19:32:02 <dolio> For some particular T.
19:32:16 <Saizan> ah, i've never looked at implicit abstraction/instantiation as subtyping
19:32:34 <dolio> Anyhow, once you have higher rank types, you have a sort of subtyping relation.
19:34:11 <kmc> more complicated because in H98, polymorphism is not really first-class
19:35:26 <dolio> Which helps to understand how you're allowed to pass an use higher-rank types.
19:36:06 <dolio> You can pass x : T to f : H -> R if T < H, I think.
19:36:28 <dolio> Although I don't think about this much, so maybe I'm making mistakes.
19:36:56 <kmc> sure
19:37:08 <kmc> the usual rule for contravariant subtyping of functions
19:37:43 <dolio> f : (forall a. a) -> R, x : Int, (forall a. a) < Int, so I must have it backwards.
19:38:41 <kmc> the usual rule is that (S1 -> T1) <= (S2 -> T2) if S2 <= S1 and T1 <= T2
19:39:30 <kmc> but i think the sense in which "Haskell doesn't have subtyping" is that, if you want to formalize Haskell's type systems, it's less useful to introduce a subtyping judgement and more useful to introduce explicit type applications, a la System F
19:40:11 * kmc read the System Fc paper recently and quite enjoyed it
19:40:23 <EvanR> how much does that cost
19:40:27 <kmc> ham
19:40:36 <EvanR> fresh out
19:40:37 <Saizan> dolio: you've it right, you can't pass x to that f in fact
19:40:39 <kmc> no, i have no idea what you mean
19:40:49 <EvanR> freely available?
19:40:52 <mjrosenb> kmc: system Fc?
19:40:54 <kmc> the System Fc paper?
19:40:55 <kmc> yes
19:40:58 <EvanR> ok
19:41:03 <kmc> http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html
19:41:05 <mjrosenb> kmc: i assume it has nothing to do with systemc
19:41:10 <kmc> no
19:41:14 <kmc> it has to do with System F
19:41:16 <EvanR> i cant seem to find anything for free these days
19:41:24 <dolio> If H < T, then you can treat H as a T. So you can instantiate (forall a. a) to Int.
19:41:35 <kmc> which is the prototypical typed lambda calculus with polymorphism
19:41:45 <mjrosenb> kmc: what does it add to system f?
19:41:53 <kmc> type equality coercions
19:42:02 <kmc> hence the title of the paper ;)
19:42:05 <mjrosenb> i assume it doesn't remove anything, since there really isn't anythign to remove
19:42:08 <Saizan> dolio: yeah, but to apply f to x you'd have to instantiate Int to (forall a. a)
19:42:13 <dolio> Right.
19:42:15 <kmc> "We introduce System FC, which extends System F with support for non-syntactic type equality. There are two main extensions: (i) explicit witnesses for type equalities, and (ii) open, non-parametric type functions, given meaning by top-level equality axioms. Unlike System F, FC is expressive enough to serve as a target for several different source-language features, including Haskell's newtype, generalised algebraic data types, associated
19:42:16 <kmc>  types, functional dependencies, and perhaps more besides."
19:42:17 <mjrosenb> well, c is rather ambiguous
19:42:22 <dolio> So I had it backwards.
19:42:35 <Saizan> what is "it"?
19:42:44 <kmc> i've found almost every Haskell-related paper I want is freely available online
19:42:47 <kmc> even old-ish stuff
19:42:56 <kmc> it's extraordinarily nice
19:43:06 <kmc> since you really do have to read papers at some point
19:43:08 <EvanR> i havent been looking up haskell, but rather OOP
19:43:26 <EvanR> it seems to be a racket
19:43:34 <kmc> OOP?
19:43:35 * ddarius usually has little trouble finding papers.
19:43:50 <kmc> there's some solid theory, and also a lot of bullshit, since it's been commercialized much more heavily
19:44:33 <mjrosenb> kmc: there is a row polymorphism paper that i can never remember how to find
19:47:11 <dolio> GHC apparently doesn't successfully implement the subtyping.
19:52:12 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26303#a26303
19:52:27 <dolio> It's true modulo eta expansion, though.
20:03:21 <napping> Well, that was anticlimactic. My Lava processor design was correct, the assembly -> machine code encoder was broken
20:03:21 <danharaj> I don't understand the allure of depth and width subtyping for records
20:06:15 <zeiris> Is there anything like Matplotlib for Haskell?
20:07:12 <Saizan> does Chart fit?
20:07:42 <napping> danharaj: probably for structural subtyping
20:09:27 <danharaj> napping: I am not sold on structural subtyping :p
20:11:08 <dolio> Row polymorphism is where it's at.
20:12:04 <zeiris> Chart is a good start. Mainly I'm curious whether Haskell can serve as host to some gargantuan cross of R, Matplotlib, and NumPy. Except better than all of them combined.
20:12:21 <zeiris> If all 3 are too much, just Matplotlib would be awesome.
20:12:54 <napping> in Recipe in york lava, do the "go" bits for parts of the recipe stay active for the clock cycle?
20:13:07 <napping> I guess they do stay high - then Sig makes a bit more sense
20:13:39 <c_wraith> stupid TH stage restriction...  look what it made me do!  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26304#a26304
20:13:39 <napping> such tricky circular programming
20:13:53 <c_wraith> ...  yes, I'm mixing TH and CPP
20:14:24 <napping> why are you doing that?
20:14:43 <c_wraith> because CPP can detect flags set by cabal.  TH can't.... as far as I know.
20:14:53 <c_wraith> can you set flags in cabal that TH can see?
20:14:58 <napping> Ah, if the build system can only set CPP flags that makes sense
20:15:34 <napping> dunno exactly what you get in cabal, but if you can emit a Config.hs module that defines constants you could refer to it (--make should compile it first, if the TH stuff needs it)
20:20:04 <napping> c_wraith: nope, looks like CPP is the easiest way to go
20:20:28 <c_wraith> and.....  Done.  Holy crap.  this works!
20:20:41 <napping> autoconf could process a Config.hs.in, but that's not really easier
20:20:46 <BMeph> c_wraith: \o/
20:21:19 <Pseudonym> M4 is underused.
20:21:43 <c_wraith> BMeph:  I now have a wrapper for loading Snap actions dynamically...  That can be enabled/disabled from a cabal flag.
20:22:08 <TacticalGrace> Axman6: around?
20:23:04 <BMeph> c_wraith: Sweet! If I could do a "bowing-down" figure in ASCII art, I would. I guess a celebrating cheer will have to do, then. :)
20:25:05 <gwern> BMeph: orz
20:25:41 <gwern> ^ there's your bowing
20:25:49 <monochrom> where o is the head, z is the legs
20:26:18 <monochrom> in fact it's kneel down and on your hands and knees
20:26:42 <c_wraith> if you say orz, I just think about frumples and go-gos and *happy*
20:26:44 <gwern> that's a bow too, I think, although it's possible that it is kowtowing and not bowing
20:27:03 <monochrom> yes kowtow
20:27:52 <BMeph> monochrom: As in literally? :)
20:28:04 <monochrom> literally
20:30:33 <gwern> do you mean literally like figuratively?
20:31:09 <monochrom> no
20:31:44 * gwern literally shits bricks in amusement
20:32:12 <c_wraith> sounds painful
20:32:41 <gwern> c_wraith: you literally have no idea
20:34:19 <danharaj> Can anyone point me towards a categorical formulation of parametricity?
20:34:32 <danharaj> Wadler's paper mentions it and says it'd be in a future paper, but I can't find that one.
20:37:10 <Saizan> just "naturality", maybe? which then would make us wonder in which category.
20:37:19 <dolio> Try: Types, Abstraction and Parametric Polymorphism, Part 2.
20:37:50 <dolio> Just naturality isn't enough.
20:38:16 <dolio> I also have "Dinaturality for Free", but I glanced at that and I'm not sure it'd be helpful.
20:38:28 <danharaj> Thanks Dolio. Almost got Springer'd but a few links down led to the pot of gold :)
20:39:00 <dolio> Well, I have both of those, so they must be available somewhere, because I don't have any journal subscriptions.
20:39:18 <danharaj> No university access?
20:39:23 <dolio> No.
20:39:42 <danharaj> no... shady areas of the internet?
20:40:49 <dolio> Are there shady areas that specialize in old research papers?
20:40:52 <dolio> I suppose there are.
20:41:15 <danharaj> I have found some pretty obscure proceedings-type books in certain *ahem* reaches of the web.
20:41:44 <gwern> CS is full of neglected results; I suppose obscure stuff from the 70s and 80s might be useful to an ambitious researcher
20:42:01 <gwern> modify things a little, and even if someone digs up your original, you can still claim novelty
20:42:20 <danharaj> :o
20:42:34 <dolio> Anyhow, that first one defines relations in categories, similar to the relations of sets that get used in Wadler and Reynolds and such.
20:42:39 <danharaj> Academic integrity is worth more than a research paper's weight in gold.
20:42:49 <danharaj> (which is probably less than the worth of a research paper to a career but ANYWAY)
20:42:50 <gwern> danharaj: that and 5$ will get you a starbucks
20:42:55 <dolio> So I'm not sure if it's a totally satisfying categorical treatment, but it's something.
20:43:04 <danharaj> dolio: once again, thanks.
20:43:21 <gwern> danharaj: how much does 1M of electrons weigh? probably less than a pennyweight of gold
20:43:28 <dons> dolio: "Types, Abstraction and Parametric Polymorphism" cardelli?
20:43:35 <dons> that's weird, i was reading that  today.
20:43:36 <danharaj> gwern: come now, you have to count the substrate too!
20:43:47 <gwern> danharaj: do I? the subtrate weighs the same either way
20:43:55 <dolio> dons: No, Part 2. QingMing Ma and John C. Reynolds.
20:44:02 <dons> dolio: oh, "On understanding types, data abstraction, and polymorphism"
20:44:03 <danharaj> I kind of get the idea of parametricity, but if I don't see it in familiar terms, which means equations and dry mathematical horseshit, I don't *really* get it.
20:44:06 <dons> is what i was reading.
20:44:07 <gwern> heck, if you redo the results in haskell, you'll probably want to do some stuff in the type system, and that alone you can spin as novel
20:44:22 <mm_freak> how do i tell runghc that the program is literate?
20:44:29 <BMeph> I wonder if there's a "Rule 51" concerning pirated papers, as an odd corner case to Rule 34, perhaps...
20:44:33 <mm_freak> it doesn't have the .lhs extension
20:44:42 <danharaj> mm_freak: show runghc the program's GED
20:44:58 <mm_freak> what's a GED?
20:45:07 <danharaj> oh, maybe that was too obscure.
20:45:14 <gwern> mm_freak: the dumb way would be to do a -pgMF or whatever through 'unlit'. the samrt way would be to rename the file...
20:45:34 <gwern> danharaj: no, you should've gone for 'the program's bachelor'. high school doesn't count for much
20:45:36 <danharaj> General Education Development test, equivalent to an american high school diploma.
20:45:36 <mm_freak> gwern: renaming the file isn't always smart, because i'd like to use haskell for scripting
20:45:49 <gwern> mm_freak: don't follow
20:45:50 <danharaj> gwern: I am using a very weak definition of 'literate' :p
20:46:15 <mm_freak> gwern: well, it should become a command line command
20:46:37 <gwern> so use a symlink
20:46:40 <mm_freak> so the .lhs would be inconvenient
20:46:54 <mm_freak> hmm, that's an ideaâ¦  runghc is smart enough?
20:47:30 <gwern> symlink foo -> foo.lhs, and foo.lhs has the shabang
20:48:36 <mm_freak> i guess, compiling is the only way to get rid of the shebang?
20:48:55 <mm_freak> (or using a shell script)
20:48:59 <gwern> what do you expect your shell to do, read your mind?
20:49:22 <mm_freak> no, but maybe i can tell runghc to run CPP first
20:49:41 <mm_freak> hmm, that's not sufficient
20:49:46 <gwern> it's got to know what to do with this 'foo' thing you've told it to run; if it isn't an ELF, then it needs to know what to feed it to, and that's the shabang
20:50:01 <mm_freak> the problem i've got with the shebang is that i have to use literate haskell
20:50:19 <mm_freak> that's ok for larger projects, but inconvenient for quick-n-dirty scripting
20:53:44 <dolio> danharaj: For what it's worth, I think work by Tim Sheard and Nathan Mishra-Linger does a better job of explaining what it means for types to ensure that functions/values are "parametric" in the intuitive sense than does "parametricity."
20:54:05 * edwardk waves hello.
20:54:26 <dolio> The latter is more about "once we have a system where some things are parametric, what nice properties/theorems do we get from that."
20:54:45 <dolio> Although you can turn it around and use the theorems you get to quantify how parametric things are.
20:55:23 <dolio> The Sheard and Mishra-Linger stuff is on erasure. I meant to mention that.
20:56:10 <dolio> So (x : T) -> U is parametric in x if you can erase it.
20:56:30 <dolio> Or, f : (x : T) -> U
20:58:12 <ezyang> Monadic return values (ala MonadReader r m, MonadWriter w m => m ()). In style or out of style? 
20:59:59 <mjrosenb> ezyang: do you want the answer as of now, or tomorrow morning?
21:00:23 <ezyang> Fashion is never in the past or future: it is now! 
21:02:51 <dolio> But if you design now for what's in style in the future, you won't have to fix it then.
21:03:19 <ezyang> but if the future never comes my laziness will have paid off! 
21:03:33 <dolio> By your potato sacks now for when Derelicte is in fashion.
21:04:00 <ezyang> (more seriously, I am honestly interested in peoples opinions of the practice.) 
21:05:36 <ezyang> I can start the conversation off: I used to think monadic returns were the pinnacle of generality, and should be aspired to at all times, but lately, if that means that I have to explicitly specify a type at the call site, that means too much generality. 
21:07:39 <dolio> I don't think your question is clear enough.
21:07:54 <ezyang> Hm. 
21:08:27 <dolio> Are we talking about injecting everything into a monad regardless of whether doing so is necessary?
21:08:51 <ezyang> no, something else 
21:08:54 <dolio> id :: (Monad m) => a -> m a?
21:09:31 <ezyang> Basically, instead of stating WriterT w (Reader r a), or (MonadWriter w m, MonadReader r m) => m a 
21:09:41 <ezyang> s/instead of// 
21:10:41 <ezyang> Maybe parametrized monads is a better term for it. 
21:11:33 <dolio> Then I think it depends on whether you're writing something intended to be general and reusable, or some one-off thing for a specific case.
21:12:22 <ezyang> Well, if I have an "exemplar" standard of the parametrized monad, I can easily write a "lift" function that converts it to the more general form 
21:12:39 <ezyang> So one extra function call and you get generality 
21:12:49 <dolio> Can you?
21:13:07 <ezyang> I think so. 
21:13:18 <ezyang> Let me pastebin an example that I did recently 
21:14:03 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26307#a26307 
21:14:14 <ezyang> erm, excuse the doublepaste 
21:15:20 <ezyang> (monad instance omitted, it should be pretty obvious) 
21:15:58 <dolio> Oh, you mean something like a free monad for the operations you're interested in.
21:16:12 <ezyang> Yeah. 
21:16:17 <dolio> I believe that, then.
21:16:18 <ezyang> Free is a good word for it. 
21:20:10 <gio123> Cale: hey
21:20:45 <mm_freak> can i make the 'cabal' tool install and link source files of packages, just like on hackage?
21:21:04 <mm_freak> perhaps even with syntax highlighting?
21:21:56 <zeiris> What's the standard array package now, vector or uvector?
21:22:55 <ezyang> mm_freak: Yes. 
21:23:08 <mm_freak> ezyang: how can i do that?
21:23:26 <mm_freak> (preferably using ~/.cabal/config
21:23:27 <mm_freak> )
21:23:35 <ezyang> mm_freak: cabal unpack FOOBAR; cd FOOBAR; cabal haddock 
21:23:47 <ezyang> ah 
21:23:56 <mm_freak> zeiris: look at the package description of uvector
21:23:59 <mm_freak> http://hackage.haskell.org/package/uvector
21:24:09 <ezyang> documentation: True 
21:24:19 <ezyang> you should probably also set docdir/haddockdir 
21:24:31 <mm_freak> ezyang: it generates documentation, but doesn't link source files
21:25:13 <ezyang> What do you mean by "link source files"? 
21:25:20 <mm_freak> on hackage i can click on the "Source" link on the right hand side of a function's documentation
21:25:44 <mm_freak> it links to a syntax-highlighted version of the source, so i can review the implementation right in the browser
21:25:47 <ezyang> you need to pass --hyperlink-source to someone 
21:26:18 <zeiris> Oh. Heh, woops.
21:27:01 <ezyang> I don't see anything obvious in .cabal/config though 
21:30:06 <edwardk> zeris: vector is taking over the world 
21:37:12 <alexyk> why doesn't IntMap have an elemAt?
21:45:40 <alexyk> tweaking -A -H seems black art
22:01:42 <kmc> how so alexyk?
22:01:46 <kmc> also what would IntMap.elemAt do?
22:02:12 <kmc> i don't know much about +RTS -H
22:03:03 <alexyk> kmc: it's the element at an insertion order
22:03:20 <kmc> ah, so not by key
22:03:34 <mm_freak> ezyang: ok, thanks anyway
22:04:18 <mm_freak> insertion order?  is that preserved in an IntMap?
22:04:22 <mm_freak> i don't think so
22:28:26 <jmcarthur> nope
22:45:01 * clanehin chokes on a quickcheck version mismatch and dies
22:45:07 <clanehin> another one bites the dust . . .
23:06:37 <kniu> In hindsight, splitting terms into an expression type and a value type was a mistake.
23:07:15 <kniu> is there a tutorial on how to implement type inference?
23:09:00 <dolio> I think Milner's original paper on the HM type system is pretty good.
23:09:14 <dolio> Well-typed Programs Can't Go Wrong, I think.
23:09:45 <dolio> That is, it's pretty readable.
23:09:52 <kmc> kniu, that can really go either way
23:09:59 <kmc> separating expressions and values
23:10:25 <kmc> kniu, have you read TaPL?
23:10:42 <kniu> no.
23:11:06 <kmc> iirc it explains how to do inference for ML
23:11:37 <kmc> there's also "Typing Haskell in Haskell"
23:11:40 <kmc> an excellent paper
23:12:05 <kmc> it's much more complicated than inference for STLC / HM / ML
23:12:16 <kmc> but at the end you get a real working inferer/checker for all of H98
23:12:28 <kniu> cool.
23:12:30 <kniu> Looking it up.
23:12:34 <kmc> including classes, defaulting, mutual recursion
23:13:47 <kmc> the intro says "In short, this paper will probably not be useful as a tutorial introduction to Hindley-Milner style type inference!"
23:13:49 <kmc> so, there's that ;P
23:23:35 <danharaj> Ok, so I just got up from a sleepless kind of mental haze, so this might be ill-posed.
23:23:59 <danharaj> What does parametricity say about dealing with existential types? How is this impacted by passing around explicit witnesses of type equality?
23:28:39 <dolio> kniu: Do you know how to type *check*?
23:28:54 <kniu> aye.
23:32:19 <dolio> Inference isn't far off from that. Wherever you'd have an annotation on something, you don't, and instead make up a fresh variable for the type.
23:32:42 <dolio> And whenever you'd compare types for equality, you instead do unification, which will fill structure into the variables you create.
23:33:39 <dolio> That's the gist, at least.
23:35:43 <kniu> k.
23:58:29 <drbean> I keep on reading (x:xs) as "ex, exess", rather than "ex, ex's"
23:59:49 <theorbtwo> drbean: You should be thinking of it as "ex, exes".  ex's is something which belongs to ex.
