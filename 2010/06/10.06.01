00:01:49 <tomberek> does pattern matching on a newtype work the same as the record function?
00:02:20 <pastorn> @hoogle exitSuccess
00:02:20 <lambdabot> System.Exit exitSuccess :: IO a
00:02:20 <lambdabot> System.Exit ExitSuccess :: ExitCode
00:02:45 <tomberek> so newtype Foo = Foo {runFoo::Foo}    is  func (Foo f) = blah   the same as func = blah.runFoo  ?
00:04:12 <aavogt> tomberek: why the dot?
00:04:52 <aavogt> or are the two blah's different?
00:05:00 <tomberek> composition? wait, did i mess that up?
00:05:20 <aavogt> I'm reading the blah as the same
00:05:40 <aavogt>  func (Foo f) = blah $ f   is the same as   func = blah . runFoo
00:05:53 <aavogt> unless the monomorphism restriction strikes
00:05:56 <tomberek> yes yes, that's what i meant
00:06:16 <tomberek> aavogt : is the pattern matching version the same as the composition?
00:06:30 <aavogt> yes
00:06:35 <tomberek> from the compiler point of view?
00:07:06 <tomberek> so it's just a matter of style, matching vs point free ?
00:07:07 <aavogt> you can substitute for  runFoo   the function  (\(Foo a) -> a)
00:07:17 <aavogt> which is a no-op because the newtype doesn't exist at runtime
00:07:58 <aavogt> so if your compiler did no optimizations at all, you'll have the same number of function calls as the version using $
00:08:22 <aavogt> actually you'll have more calls using .
00:08:47 <tomberek> aavogt: so the pattern matching is preferred?
00:08:48 <aavogt> but those are all rather simple functions which you shouldn't worry about costing much
00:09:05 <aavogt> since they probably get inlined and then it's all the same
00:09:16 <aavogt> tomberek: no, the one that looks better is preferred
00:09:32 <freiksenet> is haskell standard library reference installed when one installs haskell?
00:09:40 <tomberek> aavogt: so, you'd say with -O2 it's the same.... ok, because I like the point free style instead of the matching.. i wanted to make sure I wasn't adding calls, etc.
00:09:50 <FunctorSalad> freiksenet: with ghc at least, yes
00:09:57 <FunctorSalad> /usr/local/share/doc/ghc/libraries or so
00:10:04 <freiksenet> thanks
00:10:17 <freiksenet> google cache is slow to use.
00:10:39 <FunctorSalad> which incidentally doesn't follow the pattern for all the packages installed by cabal :(
00:10:54 <FunctorSalad> which is /usr/local/share/doc/$package
00:12:17 <tomberek> aavogt: thanks
00:19:00 <freiksenet> is there an ordered map datatype in haskell?
00:19:22 <Silvah> Data.Map?
00:19:29 <freiksenet> is it ordered?
00:19:37 <Silvah> IIRC yes.
00:19:40 <tomberek> @src Data.Map
00:19:40 <lambdabot> Source not found. Wrong!  You cheating scum!
00:19:47 <tomberek> @src Map
00:19:47 <lambdabot> Source not found. You type like i drive.
00:19:51 <tomberek> erg
00:20:50 <freiksenet> it is ordered by keys it seems
00:21:33 <freiksenet> meaning it doesn't keep an order that of insertion
00:21:38 <freiksenet> order of*
00:21:52 <tomberek> freiksenet: an association list might be what you want then?
00:22:05 <freiksenet> yeah, I guess
00:22:06 <tomberek> a simple list of tuples?
00:22:17 <freiksenet> yeah
00:22:32 <Silvah> You didn't define 'ordered', why you're expecting I knew you meant 'preserving the order of insertion'?
00:22:32 <freiksenet> I need to write union function for it though
00:22:57 <tomberek> i think there is an AssociationList or something,, but hoogle,yahoo, and haskell.org is down
00:23:02 <freiksenet> Silvah: because in python ordered dictionary is this kind of dictionary, I though it is standard name for this kind of structures. sorry
00:23:16 <freiksenet> thought*
00:25:20 <freiksenet> tomberek: hackage doesn't have it
00:25:40 <tomberek> i could have sworn there's something, i'll look
00:26:17 <freiksenet> hmm, though there is Data.Map.List in collections, I wonder what that means
00:27:05 <tomberek> freiksenet: Data.List.Utils
00:28:16 <freiksenet> tomberek: is it installed by default?
00:28:51 <tomberek> in MissingH package, the same sort of idea is probably present in many places
00:29:06 <tomberek> http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html#3
00:29:38 <freiksenet> aha, thanks
00:30:03 <FunctorSalad> you could just use a pair ([k],Map k v)...
00:30:16 <FunctorSalad> the list to keep the order, the map for fast lookups
00:31:33 <freiksenet> FunctorSalad: I don't need fast lookups yet
00:31:55 <freiksenet> so I'll use assoc list now and then if there are performance problems them I will think about using something else.
00:31:58 <aavogt>  Seq (k,v) ?
00:32:04 <tomberek> hehehe
00:32:42 <tomberek> freiksenet, i have found that the types of performance problems are usually more subversive than I would think
00:33:29 <FunctorSalad> freiksenet: this is a major asymptotic difference (n*log(n) vs n^2), I could never use assoc lists for anything except a one-shot program without feeling guilty
00:34:18 <FunctorSalad> or drop a factor of `n' there for lookup
00:34:53 <freiksenet> FunctorSalad: I need proof of concept fast, performance and efficient data structures are for version 0.2
00:35:04 <freiksenet> s/,/;
00:35:28 <Taejo> I have a simple programming language implementation... which would be better style-wise: to have the AST definition in Language.<name> and everything else in Language.<name>.Parser, L.<name>.Compiler, etc., or to have L.<name> empty and put the AST at L.<name>.AST?
00:35:30 <aavogt> actually association lists are rather inconvenient for insertions
00:35:41 <aavogt> apparently there are no functions for inserting
00:35:45 <Peaker> freiksenet, I find Data.Map to be a nicer/easier interface than assoc lists
00:36:39 <freiksenet> Peaker: I need them to keep the ordering
00:37:01 <freiksenet> so probably using assoc lists right now is faster than using map
00:45:32 <tomberek> aavogt, um  (:)  no?
00:45:56 <Peaker> freiksenet, Why not keep a list and a map? if you want I can write this data structure for you :)
00:46:17 <tomberek> or    insertAscList key value myList = (key,value) : myList   ?
00:46:39 <tomberek> seems simple for a proof-of-concept
00:46:49 <SubStack> association lists?
00:47:03 <Peaker> SubStack, Yeah,  Eq a => [(a, b)]
00:47:04 <tomberek> er.. did i forget to filter for an existing key,,, dang
00:47:08 <SubStack> ah
00:47:38 <SubStack> probably just Data.Map will do
00:48:08 <SubStack> with an ordered list of keys alongside or else storing the order in the elements
00:48:33 <tomberek> insertAscList key value myList = (key,value) : (filter (\(k,_)->k /=key ) myList)
00:49:26 <SubStack> freiksenet: I would refrain from making assertions about performance without evidence to back them up
00:49:42 <SubStack> haskell performance is surprising given all the crazy stuff that happens under the hood
00:50:05 <tomberek> insertAscList key value myList = (key,value) : (filter ((/=key).fst) myList)
00:50:46 <tomberek> that replaces any existing key, but only adds to the front
00:50:46 <Peaker> SubStack, I think he meant "faster" as in "easier to start working with"
00:51:00 <SubStack> ah
00:52:59 <freiksenet> SubStack: I was talking about my own performance, not actual structure performance :)
00:54:24 <freiksenet> Peaker: mm, what exactly do you mean by "keep a list and a map"?
00:54:40 <Peaker> freiksenet, A Data.Map and a list for the order
00:54:57 <dmwit> Why bother with the list?
00:54:59 <dmwit> :t M.keys
00:54:59 <lambdabot> forall k a. M.Map k a -> [k]
00:55:23 <kniu> so what if in pattern matching the contructor can be from an arbitrary expression?
00:55:46 <freiksenet> dmwit: wouldn't they be ordered alphabetically?
00:55:48 <kniu> I'm trying to figure out whether that would mess some things up.
00:55:56 <dmwit> kniu: As in "case arbitrary expression of Foo x -> ..."?
00:55:58 <Peaker> dmwit, He wants to preserve a (non-sorted) order
00:56:24 <dmwit> Is it a deterministic order?
00:56:30 <dmwit> If so, newtype your keys to have the order you want.
00:56:40 <kniu> dmwit, as in (\ ((expressionThatYieldsADataConstructor) x) -> doStuffWith x)
00:56:45 <freiksenet> Peaker: so something like dataOrderedMap k, v = OMap [k] Map k v?
00:57:20 <Peaker> freiksenet, s/k, v/k v,  and some () there, but ya
00:57:20 <freiksenet> dmwit: no really.
00:57:58 <dmwit> Then yes, a Map and a separate ordering seems natural.
00:58:09 <kniu> type checking should be good enough to take care that that expression has the correct type for x.
00:58:23 <dmwit> kniu: Not really, no.
00:58:27 <freiksenet> not* . damn, my typing sucks :[
00:58:28 <kniu> huh?
00:58:38 <kniu> Must be something I'm not seeing.
00:58:39 <dmwit> kniu: By which I mean yes, maybe, I'm an idiot.
00:58:59 <kniu> data Foo a = Bar a | Baz a
00:59:07 <dmwit> kniu: It sounds rather halting-problem-ish, though, doesn't it?
00:59:14 <dmwit> kniu: If there's multiple patterns...?
00:59:27 <kniu> then something like (\ (if whatever then Bar else Baz) x -> ...)
00:59:44 <kniu> dmwit, what do you mean, multiple patterns?
00:59:51 <dmwit> Anyway, it seems silly.
00:59:54 <dmwit> Do this.
01:00:09 <Peaker> kniu, typically different constructors have different types.. when is this useful? Why not use Eq?
01:00:12 <dmwit> data Foo a = Bar { unFoo :: a } | Baz { unFoo :: a }
01:00:21 <dmwit> data ConsRep = BarRep | BazRep
01:01:01 <kniu> Actually, the real reason I'm asking this is that I'm writing an interpreter for a Haskell-like language,
01:01:07 <dmwit> case complicatedExpression of BarRep -> {- something to deal with Bar values -} . unFoo $ x; BazRep -> {- something to deal with Baz values -} . unFoo $ x
01:01:20 <Peaker> I see pattern-matching as a "low-level" building block.. And at that level, I'm not sure why you'd want to have high-level logic to choose the pattern to match, might as well use Eq there
01:01:21 <kniu> and I'm just wondering why Haskell does things the way it does.
01:02:54 <dmwit> No obvious reason that the feature you propose would be bad, I guess.
01:03:19 <dmwit> It seems like it would be of limited use. But I don't know, perhaps that's just the blub speaking.
01:03:47 <kniu> I was hoping someone would tell me that the "normal" way somehow allows for some crazy optimization or something.
01:04:22 <dmwit> Well, it makes it possible to emit a warning for missing patterns.
01:04:45 <kniu> oh.
01:06:49 <dmwit> You can also generalize pattern matches in the Prolog direction, and I think there are some Haskell dialects that allow this, too.
01:10:36 <sinelaw> can cabal remove?
01:10:49 <kniu> dmwit, what's the prolog direction?
01:11:10 <FunctorSalad> kniu: you can't match on arbitrary functions, simply because arbitrary functions aren't injective
01:11:35 <FunctorSalad> f (multiply x 0) = x
01:11:50 <kniu> FunctorSalad, not what I was suggesting.
01:11:53 <Twey> FunctorSalad: o.@
01:12:10 <dmwit> sinelaw: No, but see ghc-pkg hide, ghc-pkg unregister, and man rm.
01:12:18 <FunctorSalad> kniu: " (\ (if whatever then Bar else Baz) x -> ...) "?
01:12:23 <sinelaw> heh rm
01:12:47 <dmwit> sinelaw: unregister first or you'll regret it later ;-)
01:13:01 <FunctorSalad> Twey: ? :o
01:13:24 <FunctorSalad> maybe `multiply with 0' is a bad example because it's not quite surjective either ;)
01:14:04 <FunctorSalad> (but "f (x * y) = (x,y)" will do)
01:14:12 <dmwit> f (xs ++ ys) = 3
01:14:14 <Peaker> kniu, It is very probably that knowing exactly what patterns are being matched enables interesting optimizations
01:14:19 <Peaker> probable, that is
01:14:42 <scott_> I'm trying to install lambdabot with cabal-install and getting this: http://gist.github.com/420707
01:14:52 <scott_> It already installed all the other deps in a prior attempt.
01:15:16 <FunctorSalad> "<kniu> so what if in pattern matching the contructor can be from an arbitrary expression?" <-- not trying to be belligerent, but how did I misunderstand that then?
01:15:23 <dmwit> Peaker: Dunno. The only related thing I could think of is pointer tagging, but that optimization would work fine whether you knew which thing you were looking for at compile-time or not.
01:15:36 <kniu> the constructor is from an arbitrary expression, which is expected to yield a constructor.
01:15:42 <FunctorSalad> that most number types are primitives rather than ADTs isn't the point
01:15:48 <FunctorSalad> you can make numbers as ADTs just fine
01:16:01 <dmwit> kniu: Actually, on second thought, how would you enforce that an arbitrary expression yield a constructor?
01:16:15 <kniu> I'm assuming that if the expression yields something that's not a data constructor, the thing fails.
01:16:25 <kniu> hm
01:16:32 <dmwit> And how do you tell if it's not a data constructor...?
01:16:37 <kniu> I guess I haven't thought this all the way through.
01:16:47 <FunctorSalad> in a pattern you need to *reverse* the function
01:17:01 <FunctorSalad> if you just want to "preprocess" the argument with a function (forwards), that's view patterns
01:17:25 <kniu> I guess it's too much to ask for constructors to have a "special" type.
01:17:49 <dmwit> No, not at all, if you're writing your own language.
01:18:04 <FunctorSalad> what does it have to do with the language?
01:18:04 <Peaker> dmwit, I was thinking about partial evaluations, constant folding, etc
01:18:34 <dmwit> I think it would be too much to ask if he were proposing a change to GHC.
01:18:50 <dmwit> I'd be a little upset if my Haskell constructors suddenly became something other than functions.
01:18:55 <FunctorSalad> deducing the x given the value of an expression "f x" requires f to be injective, that's fundamental
01:19:09 <kniu> I COULD create a "constructor" type, but it's not exactly elegant, is it?
01:19:34 <dmwit> kniu: What is your imagined use-case?
01:19:52 <kniu> for what, the language?
01:20:03 <dmwit> FunctorSalad: I wasn't arguing with you, I was arguing with kniu.
01:20:07 <dmwit> kniu: No, for these special patterns.
01:20:22 <kniu> same as in Haskell, I guess.
01:20:32 <dmwit> What is your imagined use-case in Haskell, then?
01:20:33 <kniu> wrap up values, and unpack them later.
01:20:49 <kniu> you mean the arbitrary expression thing?
01:20:52 <dmwit> Yes.
01:21:00 <kniu> I don't know. I just thought it might be a cool thing to have.
01:21:06 <dmwit> If you haven't got a good use case, it's certainly not worth all the trouble. =P
01:24:24 <kniu> ah well.
01:24:26 <FunctorSalad> dmwit: I know, but it sounded like you could have matching on arbitrary expressions in other languages ;)
01:25:00 <kniu> dmwit, what does Prolog's pattern matching have?
01:25:52 <FunctorSalad> (of course it would work if you supplied the partial-inverse to the function you want to match on... but that can be done already, with view patterns)
01:27:06 <dmwit> FunctorSalad: Yes, I think you could have matching on arbitrary expressions in other languages, with the caveat that its return type have a special "Constructor (a -> b -> Foo a b)" type or so.
01:27:41 <dmwit> Perhaps with a subtyping relation that Constructor a <: a.
01:28:36 <Peaker> and then need "unConstructor" if you don't have subtypes
01:28:44 <dmwit> kniu: It has pattern matching on arbitrary expressions, using search (usually via backtracking) to find a satisfying assignment. Reading wiki would help more than what I can type here, probably.
01:29:27 <dmwit> True :: Constructor Bool, Left :: Constructor (a -> Either a b) -- weird, eh? =)
01:29:59 <dmwit> ALSO as I was going to bed I came up with a use case for it, in case you also had a type for proofs (yay, dependent typing!).
01:30:12 <kniu> oh?
01:30:27 <jeltsch> Hello, can anyone say when haskell.org will be up again. The problem is that in a few days there is the Haskell meeting in Leipzig, Germany, and so participants and organizers need to install software (GHC, libraries from Hackage, etc.) these days in order to make the meeting successful.
01:30:52 <jeltsch> Who is responsible for haskell.org?
01:30:52 <dmwit> You could have a coercion "construct" that took a function and a proof that the function was injective, and turned it into a value in the Constructor type -- allowing you to pattern match.
01:31:11 <kniu> jeltsch, there's http://hackage.haskell.org/platform/
01:31:18 <dmwit> And I could *finally* write down f (base ++ ".jpg") = it's a jpg lol
01:31:46 <kniu> dmwit, this language I'm designing is certainly dependently typed.
01:31:56 <jeltsch> kniu: Aha, hackage.haskell.org works.
01:32:00 <dmwit> jeltsch: I think the appropriate people have been informed; but today was a holiday in the US.
01:32:20 <juhp> jeltsch: yep it is just http://haskell.org that is affected I believe
01:32:30 <dmwit> kniu: Then again, nobody really knows how pattern matching really ought to work in a dependently typed language anyway...
01:32:44 <kniu> dmwit, why is that?
01:33:04 <FunctorSalad> dmwit: I was assuming we want the variables inside the pattern to be *uniquely* determined
01:33:06 <kniu> Not that I want to keep you from going to sleep, but I'm really curious.
01:33:08 <FunctorSalad> not just any solution
01:33:41 <dmwit> <- not an expert; the 10,000 foot view is that pattern matching does funny things to type preservation
01:34:14 <dmwit> Sometimes ccasin and byorgey appear on here, and they (among others) would be able to describe it more clearly.
01:34:37 <kniu> alright.
01:34:46 <dmwit> FunctorSalad: Yes, I assume the same thing.
01:34:54 <FunctorSalad> (++".jpg") happens to be injective
01:35:05 <FunctorSalad> which you can't expect the language to prove...
01:35:15 <dmwit> I certainly don't.
01:35:19 <FunctorSalad> (constructors are more or less by definition of an ADT injective)
01:35:22 <dmwit> I expect to be forced to provide a proof of that myself.
01:35:32 <kniu> Given a Smart Enough Compiler (tm), anything is possible.
01:35:58 <FunctorSalad> this is undecidable in general
01:36:02 <dmwit> Yes.
01:36:25 <dmwit> But I don't want general. I want the kinds of functions that I can sit down and prove are injective.
01:36:50 <FunctorSalad> dmwit: that was @ kniu
01:37:01 <FunctorSalad> (@smart enough compiler)
01:37:03 <dmwit> Okay. Good night, all!
01:37:08 <FunctorSalad> good night
01:37:16 <kniu> night.
01:37:43 <dolio> I certainly wasn't aware that no one knows how pattern matching should work in dependently typed languages.
01:38:01 <dolio> Considering I've been using a language that does dependent pattern matching for a while now.
01:39:59 <Silvah> g'night dmwit
01:41:47 <danharaj> dolio: no one knows how to use agda
01:41:52 <danharaj> ;)
01:42:07 <FunctorSalad> dolio: what does it have to do with dependent types?
01:42:25 <FunctorSalad> in fact ISTR that ignoring the injectivity issue caused an inconsistency in agda
01:42:42 <dolio> Not an inconsistency.
01:42:58 <dolio> And it was injectivity of type constructors.
01:43:26 <FunctorSalad> maybe we're not thinking of the same issue... I mean the with-clauses
01:43:55 <Silvah> ;/
01:43:56 <dolio> I'm not sure what you're talking about, then.
01:44:55 <FunctorSalad> dolio: sorry, I don't have any references, I just overheard it here on IRC ;)
01:45:25 <kniu> One more completely unrelated question:
01:46:25 <kniu> According to that isomorphism about programs and proofs, if a type is inhabited by something, then that something is "proof" of the specification indicated by the type, right?
01:46:43 <FunctorSalad> yes
01:47:05 <kniu> Then how come proof assistants have special "proof" objects?
01:47:20 <Gracenotes> @src msum
01:47:20 <lambdabot> msum =  foldr mplus mzero
01:47:21 <kniu> isn't a function itself a proof?
01:47:30 <FunctorSalad> kniu: you mean the 'Prop' type in coq?
01:47:38 <kniu> FunctorSalad, yeah, sure.
01:48:25 <FunctorSalad> kniu: I'm not a logician, but roughly, one can safely add the proof irrelevance axiom for Prop, which says: forall P:Prop, x y : P, x = y
01:48:50 <dolio> Prop behaves differently in multiple ways.
01:48:54 <FunctorSalad> (the rules for Prop are constructed in such a way that one can never prove two proofs unequal)
01:49:02 <dolio> It's also impredicative.
01:49:06 <FunctorSalad> this in turn, allows Prop to be impredicative
01:49:09 <FunctorSalad> yes :)
01:49:37 <FunctorSalad> which means that a proposition quantifying over all propositions is a proposition itself
01:50:06 <kniu> Sorry, now I'm even more confused.
01:50:07 <FunctorSalad> such a rule would cause problems for types where you don't have this can't-ever-prove-inequality property
01:50:34 <dolio> That's not true. It's okay for Set to be impredicative, too.
01:50:50 <Baughn> http://hackage.haskell.org/packages/archive/ClassyPrelude/0.1/doc/html/Prelude-Classy.html#v%3A%24 <-- Anyone know why ($) here doesn't get its haddockumentation?
01:51:08 <FunctorSalad> dolio: I don't remember what the catch was with that...
01:51:19 <FunctorSalad> that adding classical logic breaks it, maybe
01:51:28 <dolio> It was that way by default, before someone figured out you could prove the LEM false in general with it.
01:51:35 <FunctorSalad> right
01:51:45 <FunctorSalad> I consider that "problems" ;)
01:51:50 <dolio> That is "Not (forall P. P \/ Not P)"
01:53:04 <dolio> It's not really a problem. It just makes you anti-classical.
01:54:08 <dolio> Except that it's helpful to allow people a choice of whether they want to be classical-compatible or not.
01:54:36 <FunctorSalad> "problems" is not an exact term... it's not a contradiction without LEM, sure
01:55:28 <FunctorSalad> but at least if you want to use it as a prover for usual mathematics, I think most people would consider it a problem
01:55:38 <FunctorSalad> as a programming language it's not so bad maybe
01:55:39 <dolio> I imagine there are toposes (or what have you) that are accurately described by that result.
01:56:38 <dolio> Just like the anti-classical mathematics you get when you assume things like "all functions are uniformly continuous."
01:57:13 <FunctorSalad> Baughn: try escaping it? $ is used to refer to named chunks of documentation in haddock sometimes
01:57:25 <FunctorSalad> (random guess)
01:57:32 <Baughn> FunctorSalad: I can't exactly escape the /function name/...
01:57:50 <FunctorSalad> Baughn: you have a dollar in the haddock too :)
01:58:00 <dolio> Oh man, left associative ($).
01:58:03 <Baughn> So I do.
01:58:08 <Baughn> ..removing the $ entirely did nothing.
01:58:22 <FunctorSalad> and elisp can do that :o
01:58:28 <FunctorSalad> ;)
01:58:40 <FunctorSalad> ok, was just a guess ;)
01:58:55 <FunctorSalad> next one: type sig?
01:59:09 <FunctorSalad> dolio: good or bad?
01:59:17 <dolio> Excellent.
01:59:41 <FunctorSalad> the right-assoc is a bit redundant, yes...
01:59:53 <FunctorSalad> (just put dots everywhere except the last ..)
02:00:33 <dolio> Yes, and you get to do 'f $ g x $ h y' and such.
02:00:39 <Baughn> dolio: And I shall now../write code with it/.
02:00:39 <FunctorSalad> but `(foo . bar . baz) x' is kinda prettier than either ;)
02:01:20 <kniu> "foo . bar . baz $ x" looks better, IMHO.
02:04:04 <FunctorSalad> for some reason I don't like ($) so much anymore
02:04:11 <FunctorSalad> don't know ._.
02:04:41 <Baughn> FunctorSalad: Type sig.. right, I should have a type sig. >_>
02:05:02 <Baughn> That did it.
02:06:38 <caxapok> (sorry for my english) what the best haskell book (tutorial) on russian language? on english?
02:07:30 <kniu> caxapok, in english it's Real World Haskell, available free online if you google it and in dead tree form from O'Reilly press.
02:07:38 <kniu> In Russian, I don't know.
02:07:51 <kamatsu> alright, the jig is up
02:07:55 <kniu> Also, there are a lot of tutorials out there.
02:07:56 <kamatsu> which one of you is a Somali pirate?
02:08:06 <kniu> wha
02:08:39 <pozic> caxapok: there is some Russian forum on functional programming, no idea which one.
02:08:40 <FunctorSalad> if a major haskell contributor was also a pirate, the correlation should be negative
02:08:53 <kamatsu> FunctorSalad: why?
02:08:55 <caxapok> I search book fro beginners. So, I know english very bad, and it's better that book is russian
02:09:00 <FunctorSalad> (between hackage uploads and piracy, that is)
02:09:14 <FunctorSalad> kamatsu: because you can't haskell while you're busy boarding ships etc?
02:09:22 <scott_> I'm having trouble installing lambdabot with cabal-install. I get this output: http://gist.github.com/420707  Some problem with tagsoup
02:09:36 <kamatsu> FunctorSalad: what if the pirates have simply replaced themselves with robots powered by Haskell software?
02:09:36 <caxapok> any one else besides "Real World Haskell"?
02:09:58 <FunctorSalad> hmpf. I didn't expect the robots, granted.
02:10:01 <JaffaCake> anyone know why haskell.org is down?
02:10:06 <kamatsu> JaffaCake: Yale's fault
02:10:27 <JaffaCake> I presume someone has contacted them?
02:10:32 <kamatsu> yes
02:10:33 <FunctorSalad> @quote steam
02:10:33 <lambdabot> <kmc> says: SYB has some pretty serious machinery inside <kmc> as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
02:10:39 <kamatsu> they're on holidays till June 1
02:10:54 <JaffaCake> that's today :)
02:11:04 <kamatsu> oh yeah
02:11:05 <Gracenotes> but yet yale.edu is up! does anyone else see an obvious bias in yale's interests here..?!?!!11
02:11:13 <kamatsu> war on yale!
02:11:41 <FunctorSalad> Gracenotes: no I don't :(
02:11:58 <Gracenotes> commence the creation of witty haskell protest signs!
02:12:01 <FunctorSalad> or are they in league with harrop
02:13:55 <kamatsu> hm
02:14:10 <kamatsu> seems like the pirates have to produce 500 haskell libraries just to make 7 more successful hijackings
02:14:20 <kamatsu> not really sure it's worth the effort
02:14:41 <kamatsu> surely if you could make 500 haskell libraries you could make enough money not to have to hijack ships?
02:31:18 <mun> if F and G are both functions, then is F = G a FOL formula, i.e. the comparison between 2 functions?
02:33:10 <pozic> Since when has this become #homework?
02:33:26 <pozic> mun: go read a book, and the answer is no.
02:33:31 <Traveler4> hi
02:33:42 <Traveler4> any idea when the website is gonna be back online?
02:34:42 <coud> Hi. Is http://haskell.org down or is that just my problem with connection ?
02:35:06 <Traveler4> Its down.
02:35:17 <tomberek> been down a while
02:35:34 <Traveler4> How long?
02:37:56 <Taejo> Surely I should only see "The signature contexts in a mutually recursive group should all be identical | When generalising the type(s) for assemble, prelude, postlude" if assemble, prelude and postlude are mutually recursive?
02:38:40 <Twey> About half a week
02:38:42 <FunctorSalad> Taejo: I think it's talking about the typelevel, not neccessarily valuelevel
02:39:08 <FunctorSalad> Taejo: does -fglasgow-exts change/solve the error?
02:39:19 <Taejo> FunctorSalad: prelude, postlude :: String -- I don't see where the typelevel recursion is
02:39:21 <FunctorSalad> don't remember which specific flag changes these recursive groups
02:39:34 <FunctorSalad> (RelaxedPolyRec?)
02:39:39 <Taejo> it suggests that
02:39:54 <FunctorSalad> Taejo: subexpressions in their definition?
02:39:57 <Taejo> but I don't want to use it if it's hiding a problem I don't understand
02:40:30 <FunctorSalad> I admit I don't understand the odd restriction on type inference that's relaxed by that flag...
02:41:13 <scott_> how do I deal with different packages that depend on different versions of 'unix' in the lambdabot dependencies
02:42:38 <Taejo> ok, it seems to be a template haskell issue: prelude and postlude are splices, but if I replace them with plain ol string constants, I don't get the error
02:44:19 <Taejo> @paste
02:44:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:44:47 <FunctorSalad> Taejo: I was talking about ghc user's guide (offline) 8.8.7. Generalised typing of mutually recursive bindings
02:44:53 <FunctorSalad> but not sure if it's this
02:45:23 <FunctorSalad> but sounds likely since the error is talking about "generalizing" of the the types of a "recursive group"
02:46:29 <Taejo> yes, ISTR something like that, but the thing is that I don't have mutual recursion, but using TH splices makes GHC think I do
02:46:31 <FunctorSalad> (I understand your toplevel types are monomorphic, but could it be polymorphic subexpressions?)
02:46:41 <FunctorSalad> ah
02:47:33 <FunctorSalad> The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence).
02:47:46 <FunctorSalad> getting close ;)
02:48:03 <Taejo> http://pastebin.com/Gziu7QFg
02:48:48 <FunctorSalad> Taejo: apparently your sig is ignored for this stage of typechecking, *unless* you enable the flag
02:49:35 <Taejo> ok, I'll enable it, but I'm still curious
02:49:59 <FunctorSalad> I don't quite see how prelude depends on assemble though
02:50:37 <FunctorSalad> do you have -XOverloadedStrings on? ;) that'd make the result of the splice polymorphic
02:50:53 <Taejo> nope
02:51:34 <FunctorSalad> so you think it's that ghc just assumed that splices depend on everything? could be, I don't know
02:51:38 <FunctorSalad> *assumes
02:52:11 <Taejo> that's what it seems like, though I thought splices couldn't depend on definitions in the same module
02:53:27 <FunctorSalad> the code that runs at TH-expansion time can't, correct
02:53:40 <FunctorSalad> but we're speculating about the produced code ;)
02:53:47 <FunctorSalad> and what its deps are
02:53:48 <Taejo> oh, right
02:54:14 <FunctorSalad> I don't see why it shouldn't be treated like ordinary code though
03:03:00 <Taejo> FunctorSalad: http://thread.gmane.org/gmane.comp.lang.haskell.template/457
03:03:21 <Taejo> known issue
03:03:30 <Taejo> dependency analysis runs before splice expansion
03:07:45 <b0fh_ua> Hi there. Is haskell.org down, or there are some problems here?
03:08:12 <temoto> b0fh_ua, http://downforeveryoneorjustme.com
03:08:45 <Gracenotes> should be up in course. http://www.reddit.com/r/haskell/comments/ca4ls/
03:09:39 <temoto> Any advices on (preferrably typed) message exchange protocol implementation? I'd like to add another constructor to Message type and have it automagically serializable and parsable.
03:10:42 <b0fh_ua> Gracenotes: ok, thanks )
03:12:12 <alip> how do you guys usually handle memory errors when writing FFI/C extensions? (e.g. when a library function calling malloc internally returns NULL etc.) is there a builtin exception type for this?
03:13:56 <kamatsu> alip: Check Control.Exception
03:14:01 <kamatsu> if none of those, i suppose you could make one
03:14:18 <alip> ah, thanks
03:18:11 <b0fh_ua> are there any documentation for gtk2hs available?
03:18:53 <dcoutts> b0fh_ua: it's usually on the gtk2hs site, but haskell.org appears still to be down
03:19:09 <dcoutts> b0fh_ua: you can find it on hackage
03:19:12 <dcoutts> @hackage gtk
03:19:12 <lambdabot> http://hackage.haskell.org/package/gtk
03:19:14 <b0fh_ua> that's why i'm asking :)
03:19:37 <b0fh_ua> thanks!
03:26:10 <pastorn> lol = do { x <- f; y <- g; return (x,y) }; lulz = do { (x,_) <- lol; return x }
03:26:21 <pastorn> will calling 'lulz' run the function g?
03:32:22 <qz> is haskell.org down or there's something with my isp?
03:32:42 <akosch> qz: down for me too...
03:33:08 <qz> heh. exactly when its needed.. =p
03:33:52 <akosch> qz: i don't think we share the same isp ;)
03:34:12 <qz> yeh, probably something with server
03:35:10 <bleh\> why does it take so long to find the reset button
03:35:25 <tao_> hello, can someone tell how can i use 'where' with guards? I am trying to run this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25874#a25874
03:36:37 <tao_> oh nvm, that's wrong logic
03:38:28 <temoto> qz, if you need hackage for documentation, it's working.
03:46:39 <pastorn> @hoogle unsafeInterleaveIO
03:46:39 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
03:50:36 <fasta> tao_, your comma should not be there.
03:56:18 <tao_> fasta: yeah i should use '=' instead
03:56:19 <tao_> sorry
03:57:03 <FunctorSalad> can I put stuff back on a (read)-Handle? ;)
03:57:41 <FunctorSalad> or better question: how do I read a bytestring from a handle until I reach a null byte...
03:58:22 <FunctorSalad> I suppose I should read whole blocks at a time with hGet, but what to do with the rest? do I need a pair of Handle and "leftover data" as the resulting state of the handle?
04:00:13 <temoto> FunctorSalad, you can read by byte.
04:00:34 <FunctorSalad> isn't that very inefficient?
04:00:43 <temoto> FunctorSalad, it is.
04:01:07 <temoto> FunctorSalad, you didn't ask for very efficient option :)
04:01:19 <FunctorSalad> I could use a lazy BS and just hGetContents, then takeWhile...
04:01:45 <temoto> Or attoparsec, yes.
04:01:47 <FunctorSalad> slightly unclean due to lazy IO issues
04:02:08 <FunctorSalad> attoparsec does this better than hGetContents/takeWhile?
04:02:10 <temoto> It would make the same thing (per byte) but at lower level, which would make it a bit more efficient.
04:02:37 <FunctorSalad> the latter wouldn't do byte-per-byte, I thought
04:02:51 <FunctorSalad> it'd read additional chunks as required
04:03:35 <temoto> I didn't measure performance of attoparsec vs. lazy bytestring.
04:03:43 <temoto> Do you really have problem with performance?
04:03:54 <FunctorSalad> no :)
04:04:28 <FunctorSalad> but trying to learn how to do things efficiently for when I'll need it
04:05:50 <temoto> Well, when you need it, you could just read large chunk and return (data, rest) (sacrifice clean API to speed).
04:08:01 <FunctorSalad> I'd encapsule (Handle,LeftoverData) pairs I guess
04:09:02 <ejt> is uniplate a good choice for a generics library, or would people recommend something else ?
04:09:25 <temoto> In theory, this is the only way. In practice, there may well be some push-back API, but i don't know of any but ungetc(3)
04:09:43 <akosch> i try to build leksah with cabal
04:10:05 <Botje> ejt: uniplate is pretty good
04:10:12 <akosch> but i get this error while building haddock: <command line>: cannot satisfy -package-id ghc-paths-0.1.0.6-eee06b711e672618fb6af89efd53ee48
04:10:14 <ejt> Botje: thx
04:10:17 <Botje> i wrote two compilers with it, and haven't seen any nasty surprises
04:10:29 <akosch> any ideas?
04:10:50 <geheimdienst> akosch, have you tried ghc-pkg check?
04:11:08 <akosch> geheimdienst: nope, i'll try...
04:16:02 <tao_> hmm
04:16:18 <tao_> what's the best way to make a graph data structure in haskell?
04:16:50 <mreh> DAGs are easy
04:17:03 <mreh> a matrix?
04:17:15 <tao_> sorry, what's a DAG?
04:17:20 * tao_ is not a native speaker
04:17:24 <mreh> a directed a cyclic graph
04:17:32 <mreh> what kind of graph are we talking about?
04:17:44 <mreh> the kind you draw on paper with axes?
04:17:54 <tao_> yes
04:18:01 <geheimdienst> tao_, a DAG is this: http://en.wikipedia.org/wiki/Directed_acyclic_graph
04:18:02 <flux> heh, "a cyclic" sort of makes it the inverse, no?-)
04:18:06 <tao_> biconnected (?) graph?
04:18:24 <tao_> if element a is connected to element b, then element b is connected to element a
04:18:30 <tao_> like a road system
04:18:38 <tao_> thanks geheimdienst
04:18:54 <RyanT5000> tao_: not the road system in Boston :P
04:19:00 <tao_> heh
04:19:01 <mreh> that's just a list of tuples
04:19:24 <tao_> hmm
04:19:29 <tao_> hold on please, lemme draw it
04:19:33 <geheimdienst> a directed graph is like one-way roads. with normal roads it would be an undirected graph
04:19:33 <mreh> or a symmetric matrix
04:19:48 <tao_> geheimdienst: yeah, undirected graph
04:19:53 <tao_> how can it be just a lisp of tuples?
04:19:56 <mreh> the tuple list would be a sparse representation
04:20:13 <mreh> pairs of indices
04:20:21 <mreh> every node is numbered
04:21:02 <tao_> oh
04:21:14 <tao_> uhh, i gues i shouldn't touch graphs for now
04:21:39 <mreh> they don't bite
04:22:02 <geheimdienst> (except for DNG, directed nomming graphs. they do bite.)
04:23:19 <bremner> especially cyclic ones
04:24:11 <tao_> i've done some work with graphs, but not in haskell
04:24:15 <tao_> and it's reallly different
04:24:16 <geheimdienst> well a cyclic nomming graph would kinda bite its own tail
04:24:26 <mreh> get back you trolls!
04:24:33 * mreh cracks whip
04:24:46 <akosch> how can i fix packages reported as broken by ghc-pkg check?
04:24:55 <akosch> tried recompiling them, but that didn't work...
04:25:03 <mreh> akosch, cabal install --reinstall will do it
04:25:18 <mreh> well it will try to do it
04:25:31 <mreh> akosch, paste your errors and I'll have a look
04:26:38 <akosch> mreh: thanks
04:26:47 <mreh> @where paste
04:26:48 <lambdabot> http://hpaste.org/new
04:27:08 <scree> akosch: are these global or user installed packages?
04:27:13 <mreh> can I get lambdabot to tell other people?
04:27:29 <mreh> they better not be global
04:27:34 <geheimdienst> mreh, i think it was something with @give or !give ...
04:27:52 <mreh> @give
04:27:53 <lambdabot> Maybe you meant: dice gsite time
04:27:54 <tomberek> what's the standard name for newtype H f g a = H (f (g a)) ?
04:28:03 <Gracenotes> I have just spent the last hour meditating, and now I have emitted a foldl/foldr hybrid function
04:28:28 <Gracenotes> one that relies heavily on thunks...
04:28:30 <mreh> @dice
04:28:31 <lambdabot> unexpected end of input: expecting number
04:28:37 <mreh> @dice 2
04:28:38 <lambdabot> 2 => 2
04:28:46 <mreh> <_<
04:29:35 <scree> Gracenotes: I never realized you could do that with meditation
04:30:06 <scree> Gracenotes: it's not like when you dream you've proved a beatiful theorem, and then wake up and find it's gibberish, is it?
04:32:57 <akosch> reinstall fixed some packaged, these are my remaining errors from ghc-pkg check: http://pastebin.com/ndFCF0aE
04:33:14 <Gracenotes> scree: well, my brain has scarcely recovered from near-impossible lazy State trickery, and now I'm trying to do it on a tree..
04:33:21 <akosch> scree: user installed
04:33:43 <Gracenotes> and it was a year and a third ago that I learned about lazy state looping :/
04:34:20 <zygoloid> mreh: @tell <someone> <something>
04:34:29 <DrMoreau> Gracenotes: I have no idea what you are talking about :-)
04:35:58 <mreh> does lambdabot have function composition?
04:36:13 <mreh> I want her to tell someone where something is
04:38:08 <jeltsch> mreh: Are bots female?
04:38:18 <jeltsch> mreh: In German, it is „der Bot“ (male).
04:38:18 <mreh> this one is
04:38:30 <jeltsch> mreh: How do you know that?
04:38:39 <jeltsch> lambdabot: gender
04:38:40 <mreh> @vixen are you a woman?
04:38:40 <lambdabot> yeah, why? of course i'm a girl
04:38:53 <jeltsch> vixen?
04:39:15 <DrMoreau> Vixen is a brand of telescope
04:39:46 <jeltsch> So @ means “lambdabot” and “vixen” is a lambdabot command?
04:40:12 <mreh> lambdabot listens to what you have to say, but normally she ignores it
04:40:13 * geheimdienst thinks of lambdabot as a woman, too, but it would be clearer if she called herself lambdabette
04:40:17 <DrMoreau> @vixen
04:40:17 <lambdabot> have you ever made it with a man?
04:40:19 <DrMoreau> hmmm
04:40:35 <geheimdienst> @define vixen
04:40:37 <mreh> @vixen have you even made it with a man?
04:40:38 <lambdabot> no, i'm a woman
04:40:44 <Gracenotes> oh, I think I botched it
04:40:44 <mreh> touche!
04:40:55 <Gracenotes> but at least it doesn't hang forever
04:41:40 <jao> @pwn vixen
04:41:41 <geheimdienst> @wn vixen
04:41:42 <lambdabot> *** "vixen" wn "WordNet (r) 2.0"
04:41:42 <lambdabot> vixen
04:41:42 <lambdabot>      n : a malicious fierce-tempered woman [syn: {harpy}, {hellcat}]
04:41:42 <lambdabot> *** "vixen" wn "WordNet (r) 2.0"
04:41:43 <lambdabot> vixen
04:41:44 <lambdabot>      n : a malicious fierce-tempered woman [syn: {harpy}, {hellcat}]
04:42:24 <DrMoreau> @wn lambdabot
04:42:24 <lambdabot> No match for "lambdabot".
04:42:59 <mreh> @more
04:43:07 <mreh> also a female fox
04:43:23 <DrMoreau> @wn lamba
04:43:24 <lambdabot> No match for "lamba".
04:43:43 <jeltsch> DrMoreau: lamba?
04:43:43 <DrMoreau> @wn lambda
04:43:45 <lambdabot> *** "lambda" wn "WordNet (r) 2.0"
04:43:45 <lambdabot> lambda
04:43:45 <lambdabot>      n 1: the 11th letter of the Greek alphabet
04:43:45 <lambdabot>      2: the craniometric point at the junction of the sagittal and
04:43:45 <lambdabot>         lamboid sutures of the skull
04:43:53 <jeltsch> @wn lambada
04:43:55 <lambdabot> No match for "lambada".
04:43:58 <jeltsch> @wn lama
04:43:59 <lambdabot> *** "lama" wn "WordNet (r) 2.0"
04:43:59 <lambdabot> lama
04:43:59 <lambdabot>      n 1: a Tibetan or Mongolian priest of Lamaism
04:43:59 <lambdabot>      2: llamas [syn: {genus Lama}]
04:44:19 <DrMoreau> jeltsch: thanks, I have that song running through my head now
04:44:22 <jeltsch> DrMoreau: Maybe you meant these? ;-)
04:44:37 <jeltsch> DrMoreau: Is this good or a problem?
04:45:15 <DrMoreau> ;-)
04:45:49 <DrMoreau> @djinn
04:45:49 <lambdabot> Cannot parse command
04:46:25 <DrMoreau> @quote
04:46:25 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
04:48:06 <DrMoreau> @quote
04:48:06 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
04:48:18 <geheimdienst> now that's a good quote ...
04:48:24 <DrMoreau> That was a crappy quote
04:49:02 <DrMoreau> I have to invent my own quotes now
04:49:26 <DrMoreau> @quote fortune
04:49:26 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
04:49:58 <yitz> @quote
04:49:59 <lambdabot> DanaXu says: Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell
04:50:12 <DrMoreau> How do you add a quote?
04:50:15 <kmc> haha
04:50:23 <yitz> @help remember
04:50:23 <lambdabot> quote <nick>
04:50:23 <lambdabot> remember <nick> <quote>
04:50:24 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:50:24 <mreh> @remember DrMoreau How do you add a quote?
04:50:24 <lambdabot> Okay.
04:50:26 <kmc> DrMoreau, @remember DrMoreau How do you add a quote?
04:50:38 <mreh> @forget DrMoreau How do you add a quote?
04:50:38 <lambdabot> Done.
04:50:57 <DrMoreau> i c, I think
04:51:43 <DrMoreau> @remember DrMoreau I like big bots and I can not lie
04:51:43 <lambdabot> Okay.
04:51:50 <mreh> @quote bots
04:51:50 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
04:51:52 <mreh> @quote bots
04:51:52 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
04:51:56 <mreh> @quote big bots
04:51:56 <lambdabot> No quotes for this person. Sorry.
04:52:27 <DrMoreau> @quote DrMoreau
04:52:30 <lambdabot> DrMoreau says: I like big bots and I can not lie
04:53:21 <yitz> @. vixen quote DrMoreau
04:53:24 <lambdabot> how's the weather over there?
04:54:13 <DrMoreau> @help karma
04:54:13 <lambdabot> karma <polynick>. Return a person's karma value
04:54:27 <DrMoreau> @karma yitz
04:54:27 <lambdabot> yitz has a karma of 1
04:54:42 <DrMoreau> @karma kmc
04:54:42 <lambdabot> kmc has a karma of -1
04:54:50 <DrMoreau> -1 !!
04:54:52 <yitz> kmc++
04:54:55 <kmc> :)
04:54:59 <kmc> @karma weed
04:54:59 <lambdabot> weed has a karma of 315
04:55:05 <yitz> @karma member:kmc
04:55:05 <lambdabot> member:kmc has a karma of 0
04:55:16 <DrMoreau> negative karma is better, right?
04:55:20 <yitz> @karma member:kmckmc
04:55:20 <lambdabot> member:kmckmc has a karma of 0
04:55:27 <yitz> @karma kmc
04:55:27 <lambdabot> kmc has a karma of 0
04:55:33 <yitz> kmc++
04:55:34 <geheimdienst> who is weed?
04:55:35 <yitz> @karma kmc
04:55:36 <lambdabot> kmc has a karma of 1
04:55:38 <geheimdienst> !preflex seen weed
04:56:44 <DrMoreau> DrMoreau --
04:56:55 <DrMoreau> @karma DrMoreau
04:56:56 <lambdabot> You have a karma of 0
04:57:03 <DrMoreau> DrMoreau--
04:57:09 <DrMoreau> @karma DrMoreau
04:57:10 <lambdabot> You have a karma of 0
04:58:16 <DrMoreau> karma==0, I have broken free of the great wheel os samsara
05:00:03 <DrMoreau> @help slap
05:00:05 <lambdabot> slap <nick>. Slap someone amusingly.
05:00:16 <DrMoreau> @slap lambdabot
05:00:17 <lambdabot> go slap lambdabot yourself
05:00:40 <DrMoreau> @help log
05:00:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:00:47 <DrMoreau> @help list
05:00:47 <lambdabot> list [module|command]
05:00:49 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
05:07:15 <Gracenotes> okay, so an hour and a half of deep thought yielded:
05:07:20 <Gracenotes> treeFold TrunkRoot topLevel newChild = (topLevel, newChild)
05:07:22 <Gracenotes> treeFold (TrunkName otherTree dir) topLevel newChild = let (tree, newTree) = treeFold otherTree topLevel (tree { dirForest = reinsert (dir, newChild) (dirForest tree) }) in (fromMaybe (ServerTree Nothing []) $ lookup dir (dirForest tree), newTree)
05:08:17 <Gracenotes> which takes a path to the root of a tree, essentially a linked list specifying the nodes in order from bottom to top, and a node to insert, and inserts the node into the tree with one recursive pass
05:09:07 <Gracenotes> inserting any nodes which did not previously exist. and my brain is now a useless mass of melted goo
05:27:45 * hackagebot parsec-extra 0.1.0.1 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.1 (AriePeterson)
05:28:03 <chrisdone> @vixen do you like ice cream?
05:28:04 <lambdabot> yah, i like
05:28:37 <temoto> @vixen stfu
05:28:38 <lambdabot> Ok
05:28:45 <temoto> haha
05:32:35 <Gracenotes> that's no way to talk to a lady
05:36:02 <Cerulean> using cabal, can I find a package name given a module that it provides?
05:36:30 <Cerulean> e.g. I'd like to be able to find (and install) the ansi-terminal package when searching for System.Console.ANSI
05:36:53 <Gracenotes> you can use Hayoo - http://holumbus.fh-wedel.de/hayoo/hayoo.html for just that
05:37:10 <McManiaC> hoggle down?
05:37:12 <Gracenotes> in this case I don't think it has that library in its database, meh
05:37:20 <McManiaC> *hoogle
05:37:41 <Gracenotes> haskell.org more generally down
05:38:21 <Gracenotes> Cerulean: actually, System.Console.ANSI is a successful query in Hayoo
05:38:34 <Gracenotes> although it's not as big as some of the other entries
05:38:59 <Gracenotes> and it's available, as you can see from the results page, in the ansi-terminal package
05:39:11 <McManiaC> oh ok
05:46:55 <Gracenotes> hm
05:50:28 <danderson> yale hosts haskell.org?
05:53:19 <Saizan> yep
05:57:32 <sioraiocht> Saizan, danderson, but not hackage?
05:58:33 <Saizan> no, that's on another machine
05:58:35 <danderson> looks like hackage is hosted by Galois
05:58:59 <danderson> maybe they could also take over h.o? :)
05:59:27 <danderson> oh, and code.h.o is also at yale. I had no idea.
06:00:01 <danderson> Why yale? It doesn't really strike me as a nexus for haskell things, maybe I'm missing something
06:00:03 <Saizan> are you sure?
06:00:28 <sioraiocht> danderson: I have seen people from Yale at FP things, so they have at least one interested person and obviously one spare server
06:00:38 <Enl> hi
06:00:43 <Enl> site seems to be down
06:00:44 <danderson> well, at least the DNS response for c.h.o is served by yale's DNS
06:00:44 <Saizan> i think code.h.o is the one on a cheap commercial host:)
06:00:45 <sioraiocht> danderson: and way too much money
06:00:56 <Enl> when is it going to be fixed? :)
06:01:18 <Saizan> Enl: it's memorial day in the US, so probably tomorrow
06:01:28 <Enl> ah, I see
06:01:31 <danderson> wait, wasn't memorial day yesterday?
06:01:45 <Saizan> ah, might be
06:01:50 <danderson> yeah, yesterday
06:01:56 <danderson> regardless, that means the US is barely waking up
06:02:04 <danderson> and dragging themselves to work
06:02:06 <Enl> morning in US will be in 4 houres
06:02:09 <Enl> so need to wait I think
06:02:30 <dpratt71> presently 9:00 AM EST
06:02:53 <gwern> it's still too early, but you can start expecting responses now
06:03:02 * gwern /= morning person
06:03:06 <danderson> heh
06:03:10 <danderson> indeed.
06:03:21 <danderson> The day I start a revolution and take over, mornings will be made illegal
06:03:27 <danderson> or at least strongly discouraged.
06:03:36 <sioraiocht> is bos awake yet?
06:03:37 <gwern> let's also ban mondays
06:03:38 <sioraiocht> unlkely, I suppose
06:03:49 <danderson> sioraiocht: I think bos is in san francisco
06:03:51 <danderson> so, probably not
06:04:00 <danderson> it would be 6am with him
06:04:04 <sioraiocht> Time zones are inconvenient
06:04:10 <sioraiocht> danderson: can you abolish them, as well?
06:04:17 <sioraiocht> perhaps a little flatten of the earth?
06:04:24 <sioraiocht> *flattening
06:04:41 <danderson> I would actually seriously prefer that the whole world use the same time
06:04:49 <sioraiocht> lol
06:04:57 <danderson> timezones screw with everything just so that people can say they're getting up at 8am
06:05:05 <sioraiocht> LOL
06:05:14 <danderson> so what if the sun rises at 5pm "earth time" where you are?
06:05:22 <sioraiocht> I am fine with that
06:05:25 <dpratt71> danderson: agreed. it's about time, pun intended
06:05:28 <sioraiocht> but then agian, that's what UTC is all about
06:05:44 <danderson> and it makes it way easier to converse with people from across the world
06:05:59 <danderson> "I'll be in the office from 1900 to 0500 today"
06:06:05 <danderson> you immediately know if you have any overlap
06:06:12 <sioraiocht> It's true
06:06:27 <danderson> without having to mess about with DST, wondering if they're in some crazy indiana county that goes forward 45 minutes and 12 seconds every fortnight, ...
06:06:31 <sioraiocht> How do you neutralise the prefernces?
06:06:39 <dpratt71> this reminds me of being in Ethiopia, where they start the clock @ sunrise; i.e. sunrise = 12:00 AM
06:06:53 <danderson> dpratt71: nice.
06:07:01 <sioraiocht> "true time" = somewhere randomly in the middle of the pacific/atlantic
06:07:02 <sioraiocht> ?
06:07:03 <danderson> not really scalable to a global solution, but nice
06:07:19 <dpratt71> the real problem is that Ethiopians know this confuses westerners, so they "translate"...usually
06:07:19 <danderson> sioraiocht: I'd just go with UTC, because it's an already established unmoving reference clock
06:07:36 <sioraiocht> danderson: we can now conduct all of our correspondence wrt to UTC
06:07:40 <sioraiocht> I will make it happen
06:07:53 <danderson> no matter where you put the reference, it will make some people angry
06:07:59 <sioraiocht> PS do we think I can change my IRC name without causing too much confusion
06:08:17 <danderson> because we have this sort of intolerance of extreme numbers
06:08:20 <temoto> If the topic is still to say his random rants, then AM/PM thing is just as misleading as timezones are.
06:08:31 * sioraiocht hates am/pm
06:08:36 <sioraiocht> 24-hour clock all the way
06:08:36 <danderson> we all want as a society to be awake from 0800 to 2200
06:08:42 <danderson> somehow if we're not, it's "unnatural"
06:08:54 <danderson> you know what, I'm going to start doing this.
06:09:01 <sioraiocht> danderson: the hours are useless if you live in a polar region anyway
06:09:01 * danderson resets his watch to UTC
06:09:14 <Twigathy> Change to decimal time. Then it can be 100-o-clock :D
06:09:19 <danderson> all my email communications will now use 24-hour UTC time.
06:09:21 <tab> sioraiocht: not many people live there, less people angry about time ;)
06:09:28 <temoto> danderson, society punishes unnatural.
06:09:32 <sioraiocht> tab: Well, Icelanders don't seem to care
06:09:39 <sioraiocht> they are on GMT just for ease
06:09:44 <sioraiocht> despite the fact that they are nowhere near that time zone
06:09:51 <danderson> temoto: good thing I hate society then :)
06:10:20 <sioraiocht> I don't know how people in Tromsø and Kiruna feel about it, though
06:10:50 * geheimdienst wonders what timezone they have on the space station ... probably houston time
06:10:52 <Saizan> bos would still be asleep even if we used UTC everywhere :)
06:10:56 <sioraiocht> If I am doing a concatenation benchmark, do we think I need to use different strings for a series of concatenatoins
06:10:58 <sioraiocht> or is sharing okay?
06:11:41 <Saizan> mh, depends on what you want to measure
06:12:10 <Saizan> sharing will prevent GC, and fusion too i suspect?
06:12:24 <sioraiocht> Saizan: Well, the time of concatenation due to the asymptotic bounds of the algorithms being used
06:12:29 <temoto> geheimdienst, space station is on geostationary orbit, no? Which would mean they are always floating above same timezone.
06:12:32 <sioraiocht> Saizan: well, fusion prevents sharing
06:12:37 <sioraiocht> well, it can
06:12:41 <danderson> temoto: no, they're way too low for geosync
06:12:54 * sioraiocht signs
06:12:57 * sioraiocht sighs
06:13:14 <sioraiocht> I can just chunk a large doc to get plenty of strings
06:13:15 <danderson> they're at ~350km up, geosync is 36000km
06:13:15 <sioraiocht> ;)
06:13:41 <danderson> they go round the earth once every 1.5 hours, says wikipedia :)
06:13:54 <sioraiocht> wow
06:13:58 <sioraiocht> Do they age slower? =p
06:14:04 <temoto> danderson, i wanted to point out that, despite i totally agree with your 24-UTC time idea, you can't really push it. You need society, while society doesn't need you.
06:14:06 <sioraiocht> *more slowly
06:14:07 <geheimdienst> temoto, no, low earth orbit i believe
06:14:23 <sioraiocht> temoto: no, he would have to persuade!
06:14:31 <sioraiocht> for many purposes, UTC is used, anyway
06:14:51 <geheimdienst> they have a nice sticker on the station, "speed limit: 17000 mph"
06:15:06 <temoto> lol
06:15:42 <temoto> And probably we could move it to #haskell-blah.
06:17:46 <danderson> temoto: I can at least try to get it started at the office. If engineers picked it up, it would greatly simplify things.
06:20:07 <geheimdienst> plus, it looks cool when you have multiple clock on the wall with "local time", "UTC", etc. looks important
06:20:27 <EvanR> tokyo, new york, london
06:20:51 <geheimdienst> moon, mars, venus
06:25:06 <sioraiocht> danderson: you have ME convinced!
06:25:34 <mokrzu> hello, is it true that i should not use tabs in my haskell code ?
06:26:16 <danderson> sioraiocht: yeah, the problem is convincing all the irrational time-bigoted people out there
06:26:35 <danderson> I'm sure a crapload of people will refuse to be in the timezone that has the sun rise at 20:00
06:26:42 <danderson> for no particular reason, just "because it's unnatural"
06:27:20 <geheimdienst> danderson, while you're at it, why not scrap the 24-hour/60-min system and go to something more decimal
06:27:33 <geheimdienst> it would seriously simplify Date libraries
06:27:35 <madhadron> mokrzu, Yes, nor in any of your other code except Makefiles.
06:27:36 <Jafet> mokrzu, indent with spaces.
06:27:53 <madhadron> mokrzu, They are handled woefully differently in different editors and by different tools
06:28:04 <danderson> geheimdienst: true, although for some reason I can't quite formulate, I suspect that would be harder to push.
06:28:10 <mokrzu> i use vim
06:28:16 <Jafet> danderson: oh mister sun, sun, mister golden sun
06:28:38 <alip> anyone knows of a mirror where i can fetch haddock-doc-html-2.0.0.0.tar.gz? haskell.org is still down :S
06:28:40 <geheimdienst> mokrzu, tabs tend to get messed up, and they always seem to be the wrong width. most people avoid them. spaces are simpler and more predictable
06:28:43 <madhadron> mokrzu, It's not a problem *within* an editor.  It's a problem between tools, i.e., does your editor with your config treat tabs the same way the compiler does
06:29:04 <madhadron> geheimdienst, Until the leap seconds and all the rest of that start coming in again
06:30:12 * geheimdienst fixes the leap seconds issue by attaching rockets to the earth equator, speeding up the earth a tiny bit
06:30:23 <madhadron> ...that's one way to do it.
06:30:37 <mokrzu> ok, how many spaces should have standard indent ?
06:30:45 <geheimdienst> i use 4 spaces
06:30:55 <madhadron> I use whatever Emacs does for me.
06:32:01 <mokrzu> ok, thanks
06:32:49 <dafis> Can somebody give a short explanation of the stability levels for Cabal packages, in particular, what's the difference between experimental and provisional?
06:33:22 <madhadron> dafis, Experimental means that the code may suddenly turn into the flying spaghetti monster and touch you improperly with its noodly appendage
06:33:28 <madhadron> Provisional means that this is unlikely.
06:33:46 <madhadron> though it may turn into a toad at some point in the future
06:35:16 <dafis> Okay, so experimental means "I don't really have an idea what I'm doing" and provisional means "likely to change, but I'm fairly sure it's useable"?
06:35:49 <madhadron> dafis, Yeah, more or less.
06:35:52 <Gracenotes> if by "what I'm doing" you mean "where I'm going with this"
06:38:20 <dafis> @Gracenotes: By "where I'm going with this", you mean, whether it'll be maintained at all, for example?
06:38:20 <lambdabot> Unknown command, try @list
06:38:37 <madhadron> dafis, Right.  Or the next version may not share any API with this version.
06:38:46 <dafis> Dang, forgot about the bot.
06:38:56 <Gracenotes> well, unmaintained things are pretty stable :)
06:39:00 <kmc> twitter has ruined IRC
06:39:07 <madhadron> Or this only compiles if you enable the InvokeSimon language pragma
06:39:32 <kmc> @quote simonSays
06:39:32 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
06:39:33 <Gracenotes> but yeah
06:39:39 <triyo> I've been watching the Data Parallel Haskell video by Simon and was wandering where do I get this GHC extension? Is it available via hackage?
06:39:40 <dafis> Gracenotes, Yes :)
06:39:50 <Axman6> madhadron: what about the SendToOleg pragma?
06:39:54 <kmc> triyo, iirc it's built in to later version of GHC
06:40:06 <fxr> how can I delete one of my package from Hackage?
06:40:19 <dafis> Thanks, so it's going to be provisional.
06:40:51 <triyo> kmc: later ver? you mean 6.12.x and up or?
06:40:59 <madhadron> Axman6, That's only if your program contains no code, only types.
06:41:31 <madhadron> But should not be confused with the SendToDons pragma, which all O(n^k) algorithms to order O(n^(k-1))
06:41:37 <madhadron> converts all, rather
06:41:53 <Axman6> boegel: i thought the nick looked familliar :)
06:42:46 <kmc> triyo, i think it's in the latest version.  not sure when they added it
06:42:56 <boegel> Axman6: :D
06:42:59 <kmc> its still experimental though
06:43:09 <Jafet> @remember madhadron the SendToDons pragma, which converts all O(n^k) algorithms to order O(n^(k-1))
06:43:33 <kmc> even if k=1?
06:43:34 * madhadron cries out in horror as Data Parallel Haskell suddenly morphs into the flying spaghetti monster and touches him with an enormous number of noodly appendages at once
06:43:43 <madhadron> kmc, Optimized away at compile time.
06:43:44 <kmc> haha
06:43:55 <Jafet> > "ping"
06:44:01 <Jafet> Foiled
06:44:16 <Jafet> kmc, notice that the value of k is not known
06:44:26 <Jafet> It probably depends on whether you're compiling a shootout entry
06:45:06 <kmc> where did lambdabot go?
06:45:25 <HugoDaniel> http://lambda-the-ultimate.org/node/3963
06:45:50 <Gracenotes> oh dear
06:46:52 <McManiaC> @hoogle asks
06:47:00 <McManiaC> where's that from?
06:47:35 <geheimdienst> mcmaniac, xmonad. XMonad/Core.hs or Operations or something
06:47:45 <McManiaC> huh?
06:48:10 <McManiaC> no, theres something more general for reader/state monads
06:49:25 <Axman6> @src (->) (>>=)
06:49:28 <Axman6> bleh
06:49:34 <geheimdienst> not really sure about other monads, but i've seen it a lot in the xmonad code. http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=asks
06:49:56 <Axman6> Cale: what's up with lambdabot?
06:51:10 <geheimdienst> haskell.org down, lambdabot down, everything is down. i guess the mayans were right
06:51:33 <McManiaC> :(
06:52:03 <dafis> geheimdienst: Then Haskell would still be two years ahead of the times, wouldn't it?
06:52:23 <McManiaC> geheimdienst: oh its "gets" for State monad
06:52:24 <McManiaC> ^^
06:52:41 <kamatsu> geheimdienst: the mayans would still be wrong, 2 years too early
06:52:55 <Saizan> it's just that haskell is ahead of the times
06:54:15 <tomberek> mayans? they still alive?
06:54:26 <tomberek> who put them in charge?
06:54:34 <ClaudiusMaximus> McManiaC: asks :: MonadReader  r m => (r -> a) -> m a
06:55:02 <ClaudiusMaximus> McManiaC: from my ~/.cabal/share/doc/mtl-1.1.0.2/html/Control-Monad-Reader-Class.html
06:55:12 <McManiaC> yup thx
06:55:21 <gwern> tomberek: there are still mayans alive in mexico and places like guatemala. pretty numerous actually
06:55:37 <McManiaC> I guess its "gets :: MonadState a m => (a -> b) -> m b"
06:56:09 <tomberek> gwern: yeah, but they're not the ones predicting stuff..   those who made predictions are long dead
06:56:35 <MacMagnus> hi! where can i find the package dev-haskell/regex-posix?
06:56:40 <geheimdienst> no no, the mayans said that in june 2010, the lazy will get screwed six ways to wednesday. the lazy clearly includes haskell
06:57:01 <tomberek> hehe
06:57:34 <byorgey> MacMagnus: http://hackage.haskell.org/package/regex-posix
06:57:35 <sioraiocht> danderson: my office is behind your UTC plan, mostly becasue they say they need to get on it before someone else does and they want our time zone to remain the standard ;)
06:57:45 <tomberek> ok, i get a runtime expected/infered error
06:57:47 <danderson> sioraiocht: heh
06:57:57 <tomberek> i've been stuck
06:58:12 <sioraiocht> tomberek: I didn't know that was possible
06:58:23 * sioraiocht is clearly not challening Haskell enough.
06:58:42 <MacMagnus> oh thanks :D but i will try cabal... with so many dependencies...
06:58:53 <byorgey> sioraiocht: it isn't. =)
06:59:02 <kamatsu> wow
06:59:04 <kamatsu> > {-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleInstances, MultiParamTypeClasses, DeriveDataTypeable, TypeFamilies #-}
06:59:22 <sioraiocht> x.x
06:59:24 <kamatsu> is this normal?
06:59:24 <danderson> heh
06:59:25 <byorgey> kamatsu: looks fairly normal to me =)
06:59:28 <sioraiocht> lol
06:59:35 <danderson> {-# LANGUAGE NotQuiteHaskell #-}
06:59:39 <kmc> back in my day
06:59:44 <kmc> we just turned on -fglasgow-exts
06:59:52 <tomberek> byorgey: i've had some luck, check this out
06:59:54 <Axman6> doesn't using -fglasgow-exts do the same thing?
06:59:58 <geheimdienst> if you've programmed haskell for a while, your perception of "normal" changes a little
06:59:59 <sioraiocht> kmc: Yes, these new pragmata need to get off my lawn, as well
07:00:02 <Axman6> yes...
07:00:08 <byorgey> Axman6: it might.  but it's deprecated.
07:00:20 <danderson> kmc: didn't that turn on everyting indiscriminately for all files ghc had to touch?
07:00:21 <kamatsu> are type families part of glasgow-exts?
07:00:29 <Saizan> no
07:00:29 <danderson> rather than enable the necessary pragmas on a per-file basis?
07:00:32 <Saizan> but the rest is
07:00:50 <Saizan> danderson: you could turn it on per file too
07:00:51 <kmc> glasgow-exts is rather deprecated now
07:01:01 <sioraiocht> well, then there was {-# GHC_OPTIONS <compiler flags> #-}
07:01:15 <tomberek> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
07:03:50 <byorgey> tomberek: nice =)
07:04:31 <kamatsu> actually, haskell.org is down so i can't check
07:04:37 <kamatsu> when I have a type family part of a class
07:04:48 <kamatsu> can I specify a default type if one is not specified?
07:05:03 <Saizan> mh, i don't think so
07:05:09 <dafis> kamatsu: No.
07:05:10 <tomberek> byorgey: I'm trying to translate into edwardk's style, having some difficulties, not sure if it's worth it... what do you think so far? we already have this for lists, but it generalizes it
07:05:20 <Saizan> it would make sense though
07:05:22 <byorgey> kamatsu: not yet.
07:05:27 <kamatsu> byorgey: yet?
07:05:36 <edwardk> neat: i have a style ;)
07:05:40 <Silvah> lambdabot is down again?
07:05:44 <tomberek> oh, hey
07:05:58 <byorgey> it seems like a logical extension, therefore I logically assume it will be implemented at some point in the future =)
07:06:30 <Saizan> more likely if you make a feature request on the track :)
07:06:44 <dafis> Hooray, haskell.org is back up!
07:06:48 <tomberek> yeah, edwardk, here's what i have  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25876#a25876
07:06:59 <kamatsu> Hooray!!!
07:07:08 <kamatsu> i was starving over here for some haskell goodness
07:07:27 <kamatsu> it's really annoying googling for info and finding most of the links dead
07:07:33 <Saizan> *trac
07:07:42 <edwardk> you could split your class into two pieces, one peice that lets you go from DataStructure -> Data * Structure and one that lets you zip it back up
07:07:50 <edwardk> that would let you use it in more situations
07:08:43 <tomberek> edwardk : will that still allow me to scale it up? i have examples here  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
07:09:57 <edwardk> tomberek: more things will be rip/tearable (or whatever you called them) than will be able to be rejoined with |*|
07:10:11 <edwardk> tomberek: all this does is let your operators work in more scenarios
07:10:18 <tomberek> edwardk : correct
07:11:21 <tomberek> edwardk : btw, do you have a newtype Id a = Id a   or equivalent in your package?
07:14:21 <edwardk> tomberek: i just use the one from mtl as it is a dependency for cateogry-extras
07:14:43 <tomberek> ok, thanks.    anyway, in the older version... i can pull out a Product through any number of Functors
07:14:59 <edwardk> by wrapping it enough times?
07:15:38 <tomberek> no, the 'lifter'   (now 'raise')  floats a Product to the top, no matter how deep
07:16:19 <edwardk> erm, you need to tell it where to stop, after all, ((,) e)  is a functor too
07:17:15 <tomberek> edwardk: i'm not sure what stops it... no, it floats it up, the other way
07:17:48 <edwardk> kind of low bandwidth at the moment (coding in another window) so i can't check atm
07:18:24 <tomberek> edwardk,, that's fine,, i'll try splitting the typeclass
07:22:20 <ejt> is it possible to automatically derive a Show instance for a type in another module (that I can't change) ?
07:22:54 <tomberek> um.. newtype it, then GenNewDerive it?
07:22:55 <fryguybob> byorgey: I think I made a little progress.
07:23:08 <ejt> tomberek: thx
07:24:39 <fryguybob> byorgey: It occurred to me last night that we want to preserve the perpendicular (as that is the angle of the boundary that we care about).
07:25:40 <ClaudiusMaximus> ejt: http://pastebin.ca/1875403 works for me
07:26:01 <ejt> ClaudiusMaximus: perfect
07:26:02 <ejt> thanks
07:26:02 <fryguybob> byorgey: Mapping the perpendicular in, finding it's perpendicular in that space, then taking the bounds of that gives us a vector that we can project onto the image of our original vector.
07:26:34 <fryguybob> byorgey: It only makes sense in 2D as far as I can tell thought, so I don't know how to code it up.
07:29:10 <kmc> GeneralizedNewtypeDeriving won't do it.  StandaloneDeriving is the way as ClaudiusMaximus said
07:30:00 <zygoloid> also, feel bad for doing it! :) orphan instances are evil
07:31:02 <kmc> what's the definition of an orphan instance?
07:31:32 <zygoloid> an instance which is not in the module defining the class nor the module defining a type in the instance.
07:32:02 <zygoloid> operationally, it's an instance which isn't guaranteed to be visible when it's looked for
07:32:16 <kmc> ok
07:32:21 <fryguybob> byorgey: Here is a picture: http://tinyurl.com/2bbwr23
07:33:18 <kmc> zygoloid, hmm, that would be a problem if A.hs and B.hs both had orphan instances, and some code imported A and some imported B
07:33:28 <kmc> wouldn't that cause total chaos with separate compilation?
07:33:40 <edwardk> tomberek: would it make more sense to rename your rip and peel into something like structure and contents? (i'd say data and structure, but data is a keyword)
07:33:57 <ejt> that solved my problem (I wanted to see the AST built by language-c)
07:34:01 <kmc> there is a very nasty problem similar to that with C++ template specializations
07:34:13 <tomberek> edwardk: ok
07:34:35 <kmc> in which forgetting to include a header will silently generate code with an ABI mismatch
07:34:54 <edwardk> ejt: standalone newtype deriving works, but be careful, since other people can use it to and orphan instances can screw you up
07:35:00 <madhadron> edwardk, I told him yesterday that they should be car and cdr (:
07:35:20 <kmc> is the situation in Haskell as bad (violation of memory safety) or is there some link-time instance consistency check?
07:35:28 <ejt> edwardk: just using for debugging - and yes I can see why they're a bad idea
07:35:31 <edwardk> madhadron: heh, well, he's not trying to model a pair per se
07:35:53 <edwardk> ejt: np, feel free to abuse it then as long as you know what you've gotten yourself in for ;)
07:36:25 <madhadron> edwardk, It's linear and he gonna iterate down it.
07:36:27 <tomberek> edwardk: car cdr? i heard you say that the other day, but didn't understand
07:36:29 <Saizan> kmc: well, you don't normally get an ABI problem, but you break the "one instance per type" invariant, so things like Data.Map or Storable can break
07:36:42 <madhadron> tomberek, It's a Lisp thing.
07:36:43 <kmc> right
07:36:44 <tomberek> i mean: madhadron
07:36:45 <kmc> makes sense
07:36:48 <Saizan> kmc: and GHC doesn't currently add a check
07:37:14 <zygoloid> kmc: yes, it's that sort of horrible problem which is the reason why orphan instances are nasty
07:37:14 <edwardk> madhadron: his Products are actually possibly functors wrapped around pairs, or arbitrary separable data and structure
07:37:20 <Raynes> tomberek: head and tail
07:37:23 <edwardk> madhadron: so the lisp analogy doesn't quite hold
07:37:36 <tomberek> madhadron : i have a version that somewhat works, it has some examples to get the gist across http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
07:37:52 <madhadron> edwardk, <shrugs> Never stopped me from referring to them as car and cdr in Scheme (:
07:38:11 <zygoloid> kmc: more badness is listed here: http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/separate-compilation.html#orphan-modules
07:39:40 <tomberek> how about Structure/Datums
07:39:42 <tomberek> hehe
07:39:57 <kmc> thanks zygoloid
07:40:03 <Twey> I've called lots of things ‘datums’ in Haskell.  ;)
07:40:32 <tomberek> Info ?
07:40:39 <edwardk> structure/annotation ? =)
07:40:46 <kmc> > let dαta = 3 in dαta
07:40:57 <tomberek> lol... too long
07:41:01 <madhadron> Eh.  Looking at it, I still say car/cdr.
07:41:06 <edwardk> spoken like a true haskeller ;)
07:41:07 <Twey> kmc: Haha
07:41:18 <tomberek> Shape/Info  short and sweet
07:41:35 <edwardk> madhadron: the problem is that car/cdr doesn't convey which is the shape and which is the information carried, not everyone has the mental model of assoc lists in their head to disambiguate ;)
07:41:38 <edwardk> tomberek: that works
07:41:49 <kmc> > let dаta = 3 in dаta
07:42:02 <kmc> (cyrillic 'а')
07:42:06 <madhadron> edwardk, Actually, anyone whose up to speed on Data.List *does* have a mental model of assoc lists.
07:42:08 <geheimdienst> lambdabot is still down i think
07:42:12 <madhadron> who's, rather
07:42:19 <kmc> good fun, tricking people to go to bаnkofamerica.com
07:42:57 * madhadron suddenly realizes he might be a Lisp weeny.
07:42:58 <edwardk> i see we can look forward to a wonderful era of unicode phishing in the future
07:43:21 <kmc> quick register xn--bnkofamerica-x9j.com while you still can
07:43:31 <madhadron> God knows I love infix operators!
07:43:42 <geheimdienst> can you really use every unicode char in .com these days? i thought they disallow the easy-to-confuse characters
07:43:45 <edwardk> madhadron: then there is hope for you yet ;)
07:44:07 <kmc> geheimdienst, they probably do
07:44:32 <kmc> when all you have is a car, everything looks like a cdr
07:45:08 <Twey> kmc: I don't think that's allowed… canonical equivalence FTW.
07:45:30 <tomberek> is it generally ok to use FlexibleContexts?
07:45:38 <kmc> yes tomberek
07:45:43 <tomberek> sweetness
07:45:47 <kmc> i don't think it enables any nasty surprises
07:46:04 <kmc> like UndecidableInstances (divergent type checking) or RankNTypes (inference failure)
07:46:26 <zygoloid> or GeneralizedNewtypeDeriving (inconsistent type system!)
07:46:34 <madhadron> kmc, I usually end up with RankNTypes turned on within an hour or so of starting on a module.
07:46:41 <kmc> hehe zygoloid, that's our dirty secret
07:46:45 <kmc> that one is just a bug though
07:46:50 <zygoloid> :D
07:46:53 <kmc> i mean it's not an inevitable consequence of the system
07:47:04 <zygoloid> it may even be fixed in 6.14
07:47:09 <kmc> i hope so...
07:47:16 <kmc> madhadron, heh.  it is a good one...
07:47:22 <temoto> What, 6.13 is out already?
07:47:31 <Saizan> 6.13 will never be out
07:47:35 <kmc> temoto, odd minor versions are development
07:48:05 <kmc> 6.13.<today's date>
07:48:13 <kmc> "The Glorious Glasgow Haskell Compilation System, version 6.13.20100525"
07:48:22 <kmc> it's like linux
07:48:25 <gwern> there are worse versioning systems
07:48:48 <kmc> indeed
07:49:01 <temoto> Okay, but there eventually will be last of 6.13, right?
07:49:08 <kmc> Java 1.5, err, I mean, Java 5
07:49:10 <madhadron> 0.9, 0.99, 0.999, ...
07:49:22 <kmc> i like TeX's versioning system
07:49:41 <kmc> 3, 3.1, 3.14, 3.141, 3.1415, ...
07:50:04 <kmc> when Donald Knuth dies it will be set to pi exactly, frozen forever, and all remaining bugs are declared to be features
07:50:07 <Jafet> It's at about 30 digits now I think
07:50:52 * hackagebot clash 0.1 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1 (ChristiaanBaaij)
07:51:03 <madhadron> So I've been doing some web programming in Haskell lately...
07:51:04 <kmc> "This also simplifies modifying the program, should the value of PI change."
07:51:24 <madhadron> And it occurred to me that there are two separate things that should be separated in the code
07:51:53 <madhadron> There's the form elements and the triggers to submit them, and there's sticking those elements into HTML templates
07:52:54 <madhadron> I think that the form elements and triggers constitute an arrow.
07:53:35 <madhadron> Anyone messed with anything like this?
07:55:54 <Saizan> seen formlets?
07:56:29 <madhadron> Saizan, Have.  Used them.  They're not up to much as it stands.
07:57:14 <madhadron> And after rewriting a piece of code in various ways for the past couple weeks, I think the real issue is that writing it into the HTML and formulating its logic need to be separated.
07:57:24 <apfelmus> Hello. :) I have made a Haskell related video. Where should I upload that? Youtube? Vimeo?
07:57:38 <madhadron> Though I suppose I could write a render function on formlets that did essentially that.
07:57:52 <danderson> apfelmus: both? :)
07:58:02 <madhadron> apfelmus, Wherever you already have an account?
07:58:16 <pozic> apfelmus: Youtube please.
07:58:21 <apfelmus> I am a virgin when it comes to accounts at video sites. ;)
07:58:28 <apfelmus> pozic: Any specific reason?
07:58:34 <pozic> apfelmus: (because command line download applications exist)
07:58:34 <ClaudiusMaximus> apfelmus: i use archive.org for my things, though seldom do you get "reviews" and there isn't any general comment system
07:58:50 <pozic> apfelmus: if you put it on an FTP server, even better.
07:58:57 <apfelmus> ClaudiusMaximus: reviews?
07:59:02 <pozic> apfelmus: I am old-fashioned :)
07:59:38 <apfelmus> pozic: That would likely send my bandwidth costs through the roof. ;)
07:59:54 <pozic> apfelmus: it doesn't have to be your FTP server ;)
08:00:31 <ClaudiusMaximus> apfelmus: archive.org has a comment system, except they call it "reviews" which puts people off
08:00:34 <Jafet> cabalize it!
08:00:46 <pozic> Heh
08:01:00 <ClaudiusMaximus> apfelmus: and archive.org doesn't have good features for discovering related content
08:02:03 <apfelmus> ClaudiusMaximus: Is there a specific license I have to use to upload it to archive?
08:02:46 <ClaudiusMaximus> apfelmus: they have a creative commons license chooser, but it's not obligatory (unless they changed it recently)
08:03:25 <ClaudiusMaximus> apfelmus: have used Free Art License for some stuff, and not specified a license for other stuff..
08:04:25 <gwern> archive.org has an amazing amount of stuff
08:04:30 <apfelmus> ClaudiusMaximus: Ah, ok.
08:04:35 <gwern> I like it as much as wikipedia (and donate more money to it)
08:07:28 <applicative> apfelmus, but what is your video about?
08:07:46 <apfelmus> applicative: It's me explaining GADTs.
08:08:30 <applicative> well, if I was in charge of the Academy Awards....
08:08:35 <apfelmus> Haha :D
08:08:43 <Makoryu> apfelmus: I sure hope you narrate it while doing a George Takei impersonation
08:08:56 <apfelmus> Who's George Takei?
08:09:14 <Makoryu> Sulu from the original Star Trek.
08:09:36 <EvanR-work> future governor of california
08:09:44 <Makoryu> I'd vote for him.
08:10:02 <EvanR-work> id love to see sulu vs terminator in an election
08:10:31 <pozic> apfelmus: but don't you have a secret identity?
08:10:55 <apfelmus> pozic: Like Sulu? Not that I know of.
08:11:13 <applicative> apfelmus, the Monoid Warrier.   -- not right
08:11:37 <pozic> apfelmus: Heinrich Aphelmus is not your real name.
08:11:58 <pozic> apfelmus: or are you a different one?
08:12:04 <apfelmus> pozic: I'd probably change my real name if it ended with "Applesauce". ;)
08:12:27 <applicative> Hank Applesauce
08:12:35 <pozic> apfelmus: right, so, we get to see who is really apfelmus.
08:12:42 <applicative> I think I'm gravitating toward a new nick
08:13:13 <gwern> applicative: applicative is pretty hard to google
08:13:23 <gwern> I like welsh nicks, my self. those are rare in google and short
08:13:31 <Jafet> apfelsaat?
08:13:50 <applicative> gwern, yes thats part of why i chose it.  my 'real name' is ungooglably dull too.
08:13:56 <madhadron> gwern, Kind of why I hang on to madhadron.  Over the years it turned out that everything in google under that phrase is me.
08:14:08 <gwern> madhadron: really? too long for me though
08:14:31 * gwern screwed up with my old nick 'maru' though. who would've thought it'd become so common in english search results
08:15:00 <madhadron> gwern, Hey, when you find yourself in possession of all Google ranks for a phrase, may as well keep it, up to about twelve letters.
08:16:09 <gwern> madhadron: not bad. I have to go all the way down to find spam or commercial hits
08:17:59 <applicative> has anyone attempted a haskell connection with some of the google machinery?
08:18:39 <applicative> I looked into the API for doc.google a while ago, but they weren't making enough available for anything amusing
08:18:49 <Makoryu> We need bigger fanbelts
08:19:59 <edwardk> I gave up on the pseudonym thing about 15 years ago
08:20:21 <apfelmus> ClaudiusMaximus: What format should I choose if I'm going to upload to the archive?
08:20:23 <edwardk> I have to admit mr. applesauce has a pretty good one though ;)
08:21:25 <apfelmus> Hehe :)
08:22:53 <ClaudiusMaximus> apfelmus: i use DVD MPEG
08:23:01 <edwardk> madhadron: i used to largely own the word 'harmless' (no mean feat in the era of douglas adams!), but then the world moved on past altavista ;)
08:23:03 <ClaudiusMaximus> apfelmus: but they transcode
08:23:41 <edwardk> now i console myself by the fact that for some reason my blog shows up at the top of the list when you google almost anything category theoretic -- even before the sites of real category theorists
08:23:58 <ClaudiusMaximus> apfelmus: eg, i uploaded 1 MPEG file here, and the archive system made smaller versions: http://www.archive.org/details/ClaudiusMaximus_-_rdex_2010-05-22 (not haskell related though)
08:24:02 <apfelmus> ClaudiusMaximus: Do they change aspect radio? Is there a recommended resolution?
08:25:01 <pozic> apfelmus: are you going to wear a balaclava to remain anonymous?
08:25:17 <ClaudiusMaximus> apfelmus: i've uploaded anamorphic widescreen mpeg and it's been transcoded to square pixels with the correct appearance, iirc
08:25:30 <apfelmus> pozic: No, because I don't know what a balaclava is. ;)
08:25:46 <tomberek> getting confused:
08:25:47 <tomberek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25877#a25877
08:25:59 <Makoryu> pozic: He's going to disguise himself as Gerald Jay Sussman, alias "GSM Jay Sussman"
08:26:08 <Makoryu> Whoops how'd I do that
08:26:11 <Makoryu> "GJS"
08:26:22 <edwardk> tomberek: you probably want class Splittable p, and Class Splittable p => Joinable p.
08:26:27 <edwardk> instead of vice versa
08:26:30 <pozic> He is somewhere from Leipzig probably. Probably not a student anymore.
08:26:34 <edwardk> since more things can be split than joined
08:26:59 <pozic> If it is infact a "he" ;)
08:27:08 <tomberek> hm... , well, it's that once something has been joined, we can then split
08:27:35 <edwardk> tomberek: yeah but in general you can always split something that contains pairs, but you can only join zippable things
08:27:46 <Makoryu> apfelmus: Well anyway, _why managed to remain anonymous for ages, so I don't see why you couldn't
08:28:03 <gwern> _why is also crazy
08:28:05 <Makoryu> apfelmus: Just don't make chunky bacon jokes, and then people won't stalk you
08:28:12 <apfelmus> ClaudiusMaximus: Sounds good. What's the size of a widescreen video, though? 864x480 pixels?
08:28:20 <applicative> _why is wonderful.
08:28:43 <apfelmus> Makoryu: If anything, I will only make jokes related to fruits. ;)
08:28:54 <Makoryu> Saucy.
08:28:55 <applicative> haskell could do with a few more mad artiste types.  i would aspire to this if i had the preconditions.
08:29:05 <edwardk> applicative: i thought so until he pulled the vanishing act hissy fit
08:29:42 <applicative> edwardk, i thought that was wonderful too, abstracting from the pain it caused his collaborators
08:29:53 <ClaudiusMaximus> apfelmus: pretty sure anything will work as long as it's in a codec ffmpeg can read, so just make sure the file you upload is a reasonable balance between quality and your own upload bandwidth...
08:30:08 <tomberek> edwardk: ok, change mad, but that error keeps killing me, same type of error i've been banging against all night (morning now)
08:30:14 <tomberek> mad -> made
08:31:01 <ClaudiusMaximus> apfelmus: but PAL DVD is 720x576 pixels, with 1044x576 square pixels as input to the encoder to get circles to appear circular when the dvd is played on a tv
08:32:16 <applicative> tomberek, what are you going to use the pasted module for?  or is it just an experiment?
08:32:24 <edwardk> not sure i buy your 'raise' definition
08:32:40 <tomberek> applicative : experiment, learning,, maybe something useful, we'll see
08:32:55 <apfelmus> ClaudiusMaximus: Ah. Hm, I think I'll try the "youtube standard" of 864x480 pixels.
08:33:21 <tomberek> edwardk: should that be Zip f instead?
08:33:22 <edwardk> applicative: he's playing around with trying to separate shape from data and sew it back together again
08:33:39 <kamatsu> what does this mean with regards to type families?
08:33:42 <kamatsu> "   Application is no smaller than the instance head
08:33:51 <edwardk> tomberek: well, I think for one, that the Of and On stuff just makes it harder to see what is going on
08:34:23 <tomberek> edwardk: a bit, but the types end up looking nice,,,, plus it's helping me decipher category-extras
08:34:48 <Baughn> Is there any way I can make GHC /not/ create accessors for named data-fields? So I can use the syntactic extensions (record punning, etc.), but it won't actually add functions to the function namespace?
08:35:06 <edwardk> did you define Splittable/Joinable instances for Of and On as well?
08:35:06 <kamatsu> Baughn: you could put it in a module and not export them?
08:35:20 <Baughn> kamatsu: Then the syntactic extensions owuld be out as well.
08:35:34 <Baughn> Probably not, I guess. Kinda thought that'd be the case.
08:35:38 <apfelmus> ClaudiusMaximus: (It's 854x480, actually)
08:35:44 <dabd> Hi I would like to try haskell and I'm a emacs user. Is there any advantage in using the haskell platform instead of emacs? Thanks?
08:35:58 <ClaudiusMaximus> apfelmus: cool
08:36:04 <edwardk> tomberek: i'll catch up tonight. =/
08:36:09 <Makoryu> dabd: There's no "instead of" involved.
08:36:11 <Baughn> dabd: They're different things. There is no relation.
08:36:21 <applicative> edwardk, is the idea to make data -> data functions into data -> shape ; shape -> shape ; shape -> data -- with the middle (shape -> shape) somehow cleaner?
08:36:24 <tomberek> edwardk: i make an instnace of Of
08:36:29 <byorgey> dabd: the Haskell platform is just a collection of libraries, not an IDE
08:36:33 <tomberek> edwardk:   thanks...later
08:36:43 <applicative> edwardk, sorry, that's a little opaque
08:36:52 <tomberek> applicative, here's a dirtier example that works,,,, with examples!!!  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25875#a25875
08:37:06 <apfelmus> ClaudiusMaximus: Ah, and another question. Can I embed the player for archive videos on a HTML like I can with Youtube?
08:37:18 <dabd> byorgey: thanks. Is there a recommended IDE or is emacs fine for writing haskell?
08:37:33 <kamatsu> dabd: emacs is fine
08:37:42 <byorgey> dabd: emacs works fine, especially once you have installed the haskell-mode
08:37:52 <byorgey> emacs is what I use for editing Haskell
08:38:11 <ClaudiusMaximus> apfelmus: i think so, i've never done it myself - but the play video link has an "embed" button that gives you html code
08:38:11 <tomberek> applicative... the idea is to be able to convert a Functor of Products into a Product of Functors and vice versa... then do that through several levels of Functors
08:38:55 <apfelmus> ClaudiusMaximus: Awesome, thanks!
08:40:20 <kamatsu> no one can help me with my type family prob?
08:40:31 <tomberek> kamatsu, say again
08:40:38 <kamatsu>   Application is no smaller than the instance head
08:40:47 <kamatsu> i don't know what that means or how to fix it
08:40:48 <tomberek> kamatsu : oh, your context is jacked up
08:41:01 <kamatsu> tomberek: elaborate?
08:41:31 <tomberek> kamatsu : um, get rid of one of them, paste something up
08:43:27 <kamatsu> tomberek: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25879#a25879
08:43:49 <kamatsu> tomberek: i removed all the unecessary methods of the typeclass.
08:44:34 <applicative> tomberek, I see, I'm trying to understand your Products...slowly.   I have checked that runList (unwrap listTuple) == runList (unwrap goBack)   :)
08:44:44 <tomberek> kamatsu, if that's all that's left, i don't know
08:45:04 <kamatsu> tomberek: i have no class constraints anywhere
08:45:34 <tomberek> applicative , nice... the concept is to make Functor and Product commutative
08:46:18 <kamatsu> tomberek: the full error is
08:46:20 <kamatsu>     Application is no smaller than the instance head
08:46:20 <kamatsu>       in the type family application: ProcessCommands DocumentManager
08:46:55 <tomberek> kamatsu,, oh
08:46:56 <kamatsu> i'll add the documentmanager instance to the paste
08:47:10 <tomberek> i see, you are trying to make one instance depend on another, right?
08:47:32 <kamatsu> tomberek: i guess so.
08:47:48 <tomberek> i don't think that's ok... each instance has to be self contained,, i think
08:47:52 <kamatsu> tomberek: i am making a generalization of threads i use in my server
08:48:01 <kamatsu> tomberek: obviously these threads communicate with chans of various types
08:48:46 <kamatsu> tomberek: so I associate the chan type with each instance of the process class with a type family..
08:48:58 <benmachine> I'm back!
08:49:00 <benmachine> did anyone miss me
08:49:01 <kamatsu> tomberek: but evidently storing those chans in the state of such a process is a bad idea..
08:49:34 <tomberek> kamatsu, you can do it, but it must be a type variable
08:50:01 <kamatsu> so just Chan a
08:50:01 <kamatsu> ?
08:50:30 <kamatsu> or enable undecidableinstances :/
08:51:06 <aristid> i have read a few pages of the agda tutorial
08:51:07 <tomberek> kamatsu, um...  i don't want to lead you astray,, but i'd avoid undecidableinstances
08:51:23 <aristid> and i somehow think that this language is a bit painful to actually use
08:51:23 <kamatsu> tomberek: what if i promise not to make the type checker loop?
08:51:38 <tomberek> ok
08:51:40 <kamatsu> aristid: I've used Agda a fair bit, it's not too bad once you get the hang of it
08:52:15 <kamatsu> aristid: once you get across the standard library being productive in it becomes alot eaiser
08:52:18 <kamatsu> *easier
08:53:00 <aristid> kamatsu: the requirement that all functions be total is not a problem?
08:53:23 <fasta> aristid, I consider that to be a feature.
08:54:19 <aristid> does it find out whether you inadvertently return bottom by for example looping indefinitely?
08:54:40 <fasta> aristid, it won't accept your definition.
08:54:58 <jmcarthur> well, it will accept it, but it will be colored obnoxiously in emacs
08:55:07 <aristid> huh? it can solve the halting problem?
08:55:10 <jmcarthur> no
08:55:10 <fasta> aristid, you can write infinite processes, as long as it actually produces something useful.
08:55:28 <jmcarthur> it is stricter than necessarily when checking for termination
08:55:56 <Saizan> guarded (co)recursion
08:56:10 <fasta> Saizan, I didn't want to scare him.
08:56:12 <aristid> that is it rejects all non-halting programs and then some programs that do halt?
08:56:15 <jmcarthur> that is, a function that halts may nontheless fail the termination check
08:56:34 <jmcarthur> that is my understanding, anyway
08:56:46 <kamatsu> if you can provide a proof that it does terminate after all, agda will accept it
08:56:46 <fasta> jmcarthur, that is correct, AFAIK.
08:57:01 <Saizan> the nice thing is that you can explain yourself better, and then it'll be able to see that it terminates :)
08:57:02 <jmcarthur> but we also have corecursion as Saizan said, which adds greater flexibility to what you can do
08:57:03 <fasta> What is unknown to me is what the actual impact of this is.
08:58:12 <jmcarthur> (you can think of corecursion as laziness. it means there are ways to generate infinite data structures and still pass the termination checker)
08:58:17 <aristid> kamatsu: so agda only accepts programs that provably terminate?
08:58:30 <kamatsu> aristid: yes
08:58:44 <fasta> I wish people would write converters between all the dependently typed programming languages.
08:58:49 <benmachine> that's pretty much the whole idea of agda isn't it :P
08:58:56 <soupdragon> it might be better to phrase it:   If agda accepts a non-terminating program that is a bug
08:58:57 <jmcarthur> they are not all equal in power, are they?
08:59:00 <aristid> i wish there was a DT extension for haskell
08:59:01 <benmachine> fasta: I wish people would write converters from every other language to haskell :P
08:59:12 <kamatsu> aristid: Then you'd basically end up with Agda.
08:59:13 <benmachine> but I think it's reasonable for there to be variety
08:59:22 <soupdragon> Since I beleive it's inconsistent and you can prove False with it
08:59:25 <jmcarthur> aristid: it would conflict with so many of our existing language features :\
08:59:30 <aristid> kamatsu: well agda is a bit more extreme
08:59:35 <kamatsu> not by much
08:59:49 <soupdragon> fasta you can't really convert back and forth, they have different foundations
08:59:52 <aristid> kamatsu: and it completely loses type inference
09:00:00 <kamatsu> aristid: any DTs will lose type inference.
09:00:14 <aristid> kamatsu: you could mark functions as using DT
09:00:21 <aristid> and then only these would lose type inference
09:00:23 <fasta> soupdragon, they both do constructive mathematics, no?
09:00:28 <kamatsu> aristid: sounds like a horrendous language extension to me.
09:00:36 <soupdragon> it's not 'lose type inference' it's just that type inference isn't complete anymore
09:00:38 <fasta> soupdragon, it might not be _easy_, but I don't see it is impossible.
09:00:42 <kamatsu> DTs introduce a whole pile of undecidability into the HM algorithm
09:00:53 <soupdragon> Perhaps you could still have advanced algorithms which infer the types in all practical cases
09:00:58 <kamatsu> if you have any DTs in Haskell at all, you lose *all* type inference
09:01:15 <Makoryu> soupdragon: Scala programmers love explaining to me how it's theoretically impossible to have nicer type inference in Scala
09:01:19 <soupdragon> kamatsu, that is fale
09:01:21 <soupdragon> fase
09:01:26 <aristid> false
09:01:43 <kamatsu> soupdragon: Well, I mean that the type inference is not fully decidable by the compiler
09:02:00 <Saizan> yeah, even Agda has some type inference, i don't see why haskell should lose it completely
09:02:00 <jmcarthur> we already lose some type inference from a lot of extensions, e.g. RankNTypes
09:02:14 <soupdragon> yes that's true, but it's important to note the distinction between practical cases and what's theoretically possible
09:02:47 <kamatsu> anyway, yes, DT's aren't quite as easy as they seem to implement in Haskell
09:03:01 <aristid> RankNTypes is cool
09:03:07 <kamatsu> and they have conflicts with alot of existing haskell features which would mean we'd end up with a wierd mishmashing of stuff
09:03:15 <tomberek> dang, i need infinite types
09:03:24 <Saizan> tomberek: use a newtype
09:03:42 <Saizan> kamatsu: what would they conflict with?
09:03:51 <aristid> :t 4 :: forall f. Fractional f => f
09:03:58 <tomberek> Saizna: I am... using CompF and Of
09:04:07 <aristid> lambdabot not here :(
09:04:13 <aristid> 4 :: forall f. Fractional f => f :: (Fractional f) => f
09:04:28 <soupdragon> kamatsu adding dependent types wuold rurin haskell
09:04:40 <aristid> soupdragon: would it?
09:05:08 <soupdragon> kamatsu, that's just branch of the language design path we're at now, and since Agda is exploring it Haskell should take a different turn
09:05:34 <soupdragon> just one*
09:05:39 <gwern> I need to do more work on mueval. people seem to know about it, but not many are using it. to me, that says it's too limited and unpolished
09:06:00 <aristid> gwern: not many people are using mueval? everybody uses lambdabot
09:06:06 <Makoryu> There are limited use cases of dependent types that can be faked with (e.g.) Peano numerals. I don't see why we can't have extensions (and Prelude support!) to make these nicer
09:06:14 <Saizan> gwern: does it still give you the "usage" twice when you call it with --help?
09:06:15 <gwern> aristid: and what else? try haskell?
09:06:28 <gwern> Saizan: it doesn't here
09:06:28 <aristid> gwern: there's a bot in EUIrc that uses mueval
09:06:38 <aristid> nihongobot is its name
09:06:41 <gwern> aristid: maybe more bots would use it if it were better
09:06:53 <gwern> Saizan: it does say 'mueval-core: unrecognized option `--help'
09:06:54 <kmc> what's EUIrc?
09:06:58 <gwern> Saizan: is that what you mean?
09:07:06 <aristid> kmc: an irc network.
09:07:08 <kmc> i see
09:07:12 <kmc> does it have its own haskell channel?
09:07:19 <fasta> gwern, that seems pretty much trivial to use.
09:07:29 <aristid> kmc: no, but it has a java channel where nobody likes java.
09:07:32 <fasta> gwern, better than most Haskell libraries from a 10 second look.
09:07:32 <kmc> or is it used for something other than lambdabot-style haskell interpretation?
09:07:34 <kmc> hehe
09:07:39 <soupdragon> Makoryu, yeah numbers make sense as a special case - and I think stuf flike DML has explored that avenue a bit
09:07:41 <gwern> fasta: it's not so trivial if you want to use a file's worth of stuff
09:07:46 <gwern> doesn't work on stdin either
09:07:58 <gwern> I don't think it works on windows either
09:08:27 <fasta> gwern, Aren't 1 and 2 trivial to add? And Windows? Well, do it if someone pays you to do so.
09:08:29 <Saizan> gwern: i guess it morphed into that
09:08:36 <aristid> soupdragon: so what's more interesting than DT in terms of language development, in your eyes?
09:08:40 * gwern wonders how to handle --help. I don't understand our getargs stuff very well
09:08:42 <kmc> kamatsu, do you mean that DT in Haskell would preclude even heuristic inference like Coq and Agda do?
09:09:00 <gwern> fasta: hah, if I have to wait for someone to pay me, I'll be waiting a long time :)
09:09:05 <Saizan> Agda doesn't do heuristic inference
09:09:08 <kmc> inference is theoretically undecidable in Coq but in practice it gets by well enough
09:09:15 <kmc> hmm
09:09:20 <kmc> it has implicit type arguments (and other arguments)
09:09:23 * fryguybob wishes mueval worked on windows...
09:09:23 <kmc> but i guess that's different
09:09:26 <kmc> because there's no unification?
09:09:41 <Saizan> there is unification and all, but there's no heuristic part about it :)
09:09:45 <fasta> gwern, why doesn't it work on Windows or did you simply not try?
09:09:49 <kmc> heh Saizan
09:10:02 <kmc> so how does that reconcile with inference being undecidable? you can make the inference system diverge?
09:10:03 <gwern> fasta: most haskell stuff doesn't work on windows, and mueval uses posix stuff
09:10:06 <Saizan> i.e. it doesn't guess, it only concludes what's necessary
09:10:16 <kmc> gwern, i wouldn't be so sure nobody would pay you...
09:10:24 <fasta> gwern, using mingw should work, no?
09:10:35 <gwern> fasta: I hear horribel things about haskell and mingw
09:10:37 <kmc> i can think of commercial applications of something like mueval
09:10:52 <fasta> gwern, well, from my experience it does work.
09:11:20 <Saizan> kmc: it simply doesn't try to be complete, it infers what it knows it can, and asks annotations for the rest
09:11:42 <kmc> Saizan, so how is what it can infer determined?
09:11:46 <kmc> that's the part i thought was heuristic
09:12:01 <kamatsu> kmc: no, i mean the HM algo wouldn't be very applicable anymore.
09:12:08 <Saizan> no, it's determined by constraint solving
09:12:42 <benmachine> it seems like a lot of the time I hear the word "isomorphic" in haskell it just refers to types with a bijection between them
09:12:44 <Saizan> but with no "let's try this value and see if it works"
09:12:49 <benmachine> is there anything deeper to it than that?
09:13:17 <Saizan> isn't that what isomorphic means in general?:)
09:13:27 <fasta> benmachine, http://en.wikipedia.org/wiki/Isomorphism
09:13:30 <dancor> iso also means structure-preserving
09:13:33 <benmachine> yeah
09:13:47 <fasta> Up to iso is used sometimes.
09:13:48 <Makoryu> @hoogle Either () a -> Maybe a
09:13:51 <Makoryu> Whoops
09:13:55 <dancor> but i wouldn't know what to decide that means for types..
09:13:56 <benmachine> I've heard the word only in the context of group theory where you need to preserve the operation as well
09:14:04 <Saizan> "bijection" is overloaded, it means different things depending on the category :P
09:14:20 <benmachine> I was curious if there was anything interesting being preserved in a haskellian isomorphism
09:14:46 <dancor> can you define an etropy based on the log of the number of ways a vague data type could be specifically implemented? :)
09:14:49 <Saizan> in Hask it means two continuos functions which are inverse of each other
09:14:58 <sclv> Bijection is weaker than isomorphism
09:15:04 <dancor> s/etropy/entropy
09:15:34 <sclv> I can construct a bijection between ints and bools, but it is lossy
09:15:44 <benmachine> sclv: uh, then it isn't very bijective?
09:15:58 <dancor> does Hask include _|_
09:15:59 <benmachine> a function Bool -> Int cannot possibly be surjective
09:16:20 <benmachine> Saizan: what haskell functions are not continuous?
09:16:43 <Saizan> dancor: the object in Hask are the types, so _|_ exists if you also give structure to them
09:16:47 <Saizan> benmachine: none
09:17:08 <benmachine> oh ok
09:17:09 <sclv> ah, you're right. i'm thinking sloppily
09:17:16 <dancor> so Hask is before you even think about values
09:17:50 <benmachine> so is it not possible to have a bijection that is not an isomorphism
09:17:50 <Saizan> Hask is the category with types as objects and monomorphic functions as arrows
09:18:04 <kmc> dancor, yeah, the spirit of category theory is to avoid thinking about values
09:18:33 <kmc> though Hask morphisms are also values, and each belongs to a type (an object in the category), so Hask is a special sort of category
09:18:39 <kmc> i believe that's what's called a cartesian closed category
09:18:43 <Saizan> yup
09:19:40 <cads> morphisms are also values?
09:19:46 <Saizan> also, these functions are only those haskell-definable, not all the mathematical functions, but to talk about this you've first to make a model for the values of your types
09:20:29 <Saizan> which is where you read about Dana Scott denotational semantics, with the "definedness" lattices, and here comes _|_
09:20:46 <kmc> domain theory?
09:20:57 <Saizan> yeah
09:20:59 <kmc> i did not grok category theory at all until i realized that it's about the morphisms, and the "objects" are just types for morphisms
09:21:13 <kmc> in other words, a category is like a "typed monoid"
09:21:17 <Saizan> yeah
09:21:23 <kmc> cads, yeah, the morphisms in Hask are Haskell functions, which are also values
09:21:31 <kmc> and if A and B are types, then A -> B is also a type
09:21:55 <kmc> which is not true of categories in general
09:22:02 <cads> which morphism corresponds to the value "kitten"?
09:22:32 <kmc> i said all morphisms are values
09:22:36 <kmc> not that all values are morphisms
09:22:42 <cads> ah, tricky!
09:22:49 <kmc> though, you can identify each value v with the unique morphism \() -> v
09:22:59 <Saizan> benmachine: i guess that depends on the context
09:23:05 <pickles> kinda like a dualspace?
09:23:16 <kmc> which has some CT meaning as well
09:23:19 <kmc> but i forget which
09:23:35 <ksf> there are no objects in CT, just identity functions.
09:23:51 <kmc> well the word "object" is used in CT to mean what we mean by "type"
09:24:20 <kmc> the type () is a terminal object because for any T there's only one function T -> () (ignoring bottom and strictness)
09:24:24 <kmc> but that's an unrelated fact
09:24:32 <benmachine> Saizan: well if it depends on the context, then sometimes it is possible, so the answer to my question is no :P
09:24:34 <dancor> i guess you can't use \ _ -> v since it's not monomorphic
09:25:10 <ksf> ...depends on what v is bound to
09:25:18 <ksf> polymorphism is just semantic sugar, anyway.
09:25:20 <dancor> does it?
09:25:26 <dancor> the _ can be anything is the problem
09:25:49 <ksf> yes, so there are an unbounded number of \_ -> 1 functions.
09:25:55 <ksf> ...one for each possible type.
09:26:02 <dancor> ya
09:26:13 <dancor> (also 1 polymorphic too)
09:26:17 * Saizan wonders if CT really has a concept of "bijection" or only of isomorphism
09:26:28 <gwern> (argh, I hate getargs, why is it so hard to add --help)
09:26:34 <ksf> isos are defined by bijections...
09:26:40 <Saizan> dancor: add a type annotation :)
09:26:53 <dancor> \ (_ :: ()) -> (1 :: Int)
09:27:12 <gwern> (such read-only code, I don't even understand it)
09:27:39 <ksf> read-only code is a speciality of gnu libraries
09:27:59 <dancor> ya i think CT just has isomorphisms
09:28:00 <ksf> unless it's write-only code.
09:28:53 <ksf> but bijections and isomorphisms are isomorphic!
09:29:04 <dancor> sometimes
09:29:05 <ksf> er you can write a bijection from one to the other
09:29:15 <jmcarthur> lol
09:30:06 * benmachine wonders by what perversion his code thinks the 2nd and the 4th are both tomorrow
09:30:16 <kmc> yikes
09:30:36 <cads> Is there a special term for when a set X is covered by a family of sets B such that the union of B is exactly X?
09:30:37 <Saizan> outside of CT, where a function is just a set of pairs etc..., isomophism has a "structure preserving" attached, inside of CT the "structure preserving" part is inside the definition of your category
09:30:51 <cads> hmm, this is the wrong channel...
09:31:33 <kmc> in Alaska they once went from Friday October 6th directly to Friday October 18th
09:31:40 <applicative> cads, a partition
09:31:59 <kmc> partition would also require the b \in B to be pairwise disjoint
09:32:08 <kmc> "cover" is used in topology for the thing which isn't necessarily disjoint
09:32:10 <applicative> kmc, indeed, i take it back
09:32:24 <dancor> so, for monomorphic haskell functions, isomorphism == bijection == invertible and morphism == any function?
09:32:44 <applicative> kmc, but cover doesn't entail that the union of the covering sets = the covered set
09:32:50 <kmc> oh true
09:32:52 <cads> yeah, if it were a partition it would be an exact cover, but this doesn't specify that that all the sets in B are contained in X
09:32:56 <kmc> implies that it's a superset
09:33:00 <Saizan> dancor: that's my understanding
09:33:03 <dancor> ok
09:33:25 <gbacon> is there a more sensible way to decompress UTF8-encoded, gzipped text than with decode . unpack . decompress . pack . map c2w?
09:33:49 <dancor> benmachine: so ya, nothing deeper :)
09:33:56 <gbacon> I tried toString . decompress . fromString, but that doesn't typecheck
09:34:26 <c_wraith> gbacon, you are reading it as a string?  eww.  read it as a bytestring, at least
09:34:44 <Saizan> gbacon: a String that has utf8 octects in it is a bad String :)
09:34:54 <gbacon> c_wraith: agreed, but that's what I get back from Network.HTTP.getResponseBody
09:35:11 <gbacon> Saizan: gzipped UTF-8
09:35:11 <c_wraith> I thought Network.HTTP had a Bytestring version
09:35:20 <gbacon> c_wraith: I'd be pleased to find it
09:36:09 <Saizan> gbacon: getResponseBody :: Result (Response ty) -> IO ty
09:36:17 <Saizan> it's polymorphic
09:36:20 <applicative> http://hackage.haskell.org/package/network-bytestring
09:36:30 <gbacon> w00t!
09:36:33 <pickles> > let brubeck = take 5
09:36:44 <dancor> is (toEnum :: Int -> Bool) an morphism even tho it's not total?  is it an isomorphism since it's invertible over its domain/codomain?
09:37:12 <jmcarthur> network-fancy also supports bytestrings
09:37:34 <Saizan> HTTP also supports bytestring :)
09:38:03 <dancor> how fancy how you really be without using iteratee IO
09:38:05 <applicative> oh, i see network-bytestring has far fewer functions
09:38:32 <Saizan> dancor: its domain is Int and its codomain is Bool, so it's not invertible
09:38:51 <Saizan> since [2..] are mapped to _|_::Bool
09:38:57 <Makoryu> Is there an extension somewhere that lets you write "foo :: Bar => Baz" as "foo :: Baz where Bar"?
09:39:07 <soupdragon> no
09:39:08 <dancor> so in that sense Hask excludes _|_ from consideration
09:39:22 <hstefan> hey there. How do I set a key 'k' to call a fuction when pressed? (i'm using gtk2hs)
09:39:22 <Saizan> how so?
09:39:22 <kmc> Makoryu, not that i know of, why?
09:39:24 <gbacon> but how about on the back end of the composition? the value of decompress is a Data.ByteString.Lazy.Internal.ByteString, not its UTF8 cousin
09:39:29 <Saizan> dancor: how so? it's included
09:39:31 <kamatsu> if you forkIO inside a bracket, is Haskell smart enough to not close the bracket until all threads are done?
09:39:35 <dancor> err actually i guess Hask explicitly includes _|_
09:39:38 <applicative> Makoryu, are you wishing the signatures were more readable?
09:39:47 <Makoryu> applicative: A bit, yes
09:40:07 <zygoloid> Makoryu: Disciple (a Haskell dialect) accepts foo :: Baz :- Bar, iirc
09:40:33 <dancor> even tho _|_ is not relevant for the objects of Hask, it is for the morphisms
09:40:58 <Saizan> it is to decide what's a morphism and what isn't
09:41:13 <dancor> so you could also consider BottomlessHask where (toEnum :: Int -> Bool) isn't even a morphism?
09:41:23 <Makoryu> zygoloid: That could work, I guess. I think I like "where" better though
09:41:27 <Makoryu> That, or Habit's approach
09:41:35 <Makoryu> (Even though it's goofy and messy)
09:41:36 <applicative> zygloid, that's nice.  I do find long class constraints distracting, somehow the brain has to process them second.
09:42:01 <Saizan> dancor: right, it'd be more like Agda i guess
09:42:04 <dancor> ya
09:42:20 <dancor> i'm going to go with "Hask does include _|_"
09:43:14 <applicative> rem7, any luck with repa
09:44:16 <aristid> gwern: the guy who runs the mueval-bot says that the biggest problems with mueval are (1) installing ghc and (2) the fact that it requires a lot of RAM and CPU
09:45:18 <Accidus> This might be slightly off-topic, but this channel is the closest I can think of: What's the intuition behind the difference between projection products and pattern-matching products? The distinction appears in Paul Levy's CBPV book and papers...
09:47:53 <Accidus> Ah, I think I found it. NM
09:48:35 <Saizan> somthing about the laziness i guess?
09:49:40 <Accidus> Sort of. The pattern matching products perform all effects but choose one result
09:50:02 <Accidus> Whereas projection products don't even have effects (or rather, they may be thunked)
09:50:16 <b4taylor> I am trying to find what is defined by default for alex. All I know of is $white. I don't see these defined in the documentation.
09:52:38 <Accidus> Oh, actually, I'm wrong.
09:52:41 <Accidus> Hmm... that's interesting.
09:54:13 * hackagebot HDBC-mysql 0.6.3 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.3 (ChrisWaterson)
09:55:33 <gwern> aristid: hm. both of those are kind of out of my hands
09:56:26 <gwern> I can't even profile mueval to see where the time and space are going
09:56:34 <aristid> gwern: it's a shame the virtualised servers are still so expensive
09:56:50 <aristid> so you pay 10 euros for something with barely enough RAM for anything
09:57:04 <jesusabdullah> according to the google, hdbc stands for Halifax Harbour
09:57:05 <jesusabdullah> bridges
09:57:08 <jesusabdullah> >_<
09:57:27 <jesusabdullah> well, duck duck go not google, but
09:57:31 <jesusabdullah> yeah
09:58:21 <soupdragon> :/
10:04:09 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25881#a25881
10:04:10 <gwern> phew
10:04:32 <gwern> any suggestions on style, and how to avoid using 'error' in line 6?
10:04:52 <gwern> (I don't want to exit with a nonzero status, but I can't think how to do so without unsafePerformIO and whatnot)
10:08:56 <aristid> gwern: Either monad? :P
10:09:00 <aristid> -monad
10:09:33 <pastorn> will this work? mapM_ ($ chan) (fs :: [Chan X -> IO ()])
10:11:18 <zygoloid> gwern: here's my immediate thoughts on the code structure: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25881#a25882
10:11:31 <benmachine> :t mapM_ ($ ?chan) ?fs
10:11:35 <benmachine> oh
10:11:37 <benmachine> buggerit
10:11:40 <soupdragon> about people you might ask 'how does brain give rise to mind' , but what you would ask about programming languages?
10:11:48 <Twey> Millenium hand and trumpet!
10:11:57 <benmachine> trumpet?
10:12:02 <Twey> Shrimp trumpets.
10:12:03 <Philippa> buggrall!
10:12:06 <benmachine> oh ok
10:12:37 <Philippa> soupdragon: you'd ask about sapir-whorf, I guess
10:12:51 <benmachine> pastorn: you could more easily have found out yourself than waited for us to answer, but yes
10:12:54 <aristid> where is lambdabot hosted btw?
10:13:09 <zygoloid> gwern: i agree with aristid; i'd probably use "interpreterOpts :: [String] -> Either String (Options, [String])" too
10:13:39 <gwern> zygoloid: hm. that just defers the printing, and I'm not sure it's better
10:14:05 <aristid> gwern: it's total
10:14:22 <benmachine> modularity etc.
10:14:27 <zygoloid> gwern: well, if you just want to avoid using error in line 6 and 7, you could use my refactoring. i use it in lines 3 and 4 instead
10:15:04 <applicative> Makoryu, I meant to show you the goofy way I sometimes write things when I'm lost in class constraints http://pastebin.com/pfH9JDb3
10:15:45 <zygoloid> gwern: you could always use: interpreterOpts :: (String -> a) -> (Options -> [String] -> a) -> [String] -> a
10:15:49 <gwern> and Either doesn't work, there are three cases: when --help is supplied, when the options don't make sense, and when the options do make sense
10:16:10 <benmachine> gwern: but the former two cases are just "whine in some form"
10:16:15 <gwern> you want error status 0 in the first, error status 1 in the second, and to execute as normal in the last
10:16:15 <zygoloid> gwern: that way the caller can recover your version as "interpreterOpts error (,)", and avoid error if they like
10:16:17 <benmachine> which is subsumed into a single String
10:16:19 <gwern> benmachine: --help isn't whining
10:16:22 <benmachine> oh, yes
10:16:24 <benmachine> true
10:16:25 <aristid> gwern: Either (Either a b) c
10:16:34 <Makoryu> applicative: Man, that's a lotta whitespace...
10:16:34 <gwern> eitehr either? -_-
10:16:38 <benmachine> or Either (ExitCode, String) c
10:16:50 <aristid> Left Left
10:16:53 <aristid> Left Right
10:16:54 <aristid> :D
10:16:54 <gwern> benmachine: and the message isn't the same either
10:16:57 <applicative> Makoryu, yeah, that is one of several objections.
10:17:02 <benmachine> gwern: so what?
10:17:15 <gwern> hm, true
10:17:33 <Twey> Left (Right (Left (Right (Left (Right (Left (Right ())))))))
10:17:34 <applicative> Makoryu, but when accustomed to it, it's much more readable.  I should make something to convert back and forth.
10:17:48 <Makoryu> applicative: I can see how some of this is useful for absolutely gigantic instance names and such, but for small stuff like this....
10:17:51 <benmachine> aristid: Just Right
10:17:52 <zygoloid> Left (Right (Left (Right (Left (Right Attention))))))
10:17:55 <gwern> so I guess I can do Either (ExitCode, String) Options, and then do 'case Left n s = print s >> exitWith n; Right opts = continueWith opts
10:18:10 <gwern> @hoogle Either
10:18:13 <aristid> zygoloid: use dots to make that more readable
10:18:26 <aristid> Left . Right . Left . Right . Left . Right $ Attention
10:18:31 <gwern> hm, Data.Either. never actually used it before
10:19:09 <Twey> gwern: Left (n, s)
10:19:11 <applicative> Makoryu, in this case, some were hard for me to follow, others were kept in line with it.  (It's a medly of other peoples' modules)
10:19:13 <Twey> Confused me :þ
10:19:19 <zygoloid> aristid: i think we're half way to an IOHCC entry
10:19:33 <benmachine> there's not much in Data.Either that's not already in the prelude is there?
10:20:40 <benmachine> there are three functions not re-exported and two of them are fairly easily done with foldr and either
10:22:54 * benmachine works out how to do the other after a little thought and some Control.Arrow
10:23:47 <tao_> how can i take elements from 5 to 6 from a list?
10:23:57 <benmachine> combine take and drop
10:24:01 <tao_> oh
10:24:01 <tao_> ok
10:24:10 <tao_> just thought there was a builtin function
10:24:30 <tomberek> hey,, what's the common name for newtype Foo a b = Foo a
10:24:39 <BONUS> phantom type
10:24:40 <benmachine> tomberek: Const in Control.Applicative I think
10:24:54 <tomberek> thanks benmachine
10:24:56 <BONUS> b being the phantom type parameter here
10:25:11 <BONUS> oh you mean like that, lol, sorry
10:25:14 <benmachine> instance (Monoid m) => Applicative (Const m)
10:26:00 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25881#a25883
10:26:02 <gwern> yay
10:26:43 <gwern> what a lot of work though for such a small point
10:26:50 <gwern> Saizan: there! --help now works perfectly
10:26:56 * gwern hopes he is happy
10:27:54 <applicative> gwern, looks great.  You don't follow a uniform policy with the long argument names
10:27:57 <benmachine> gwern: you're kind of using that Int as a Bool :P
10:28:10 <benmachine> not a big deal though
10:28:37 <gwern> benmachine: you're right. I originally thought I could just chuck an Int into a System.Exit function, but nope, ExitSuccess and ExitFailure are different types, so I had to have a conditional anyway
10:28:39 <applicative> gwern, --inferred-type  --timelimit=TIME
10:28:49 <tao_> ummh
10:28:57 <tao_> why can't i do something like: n = sqrt $ fromIntegral $ length mat
10:28:57 <tao_> ?
10:29:07 <tao_> No instance for (Floating Int)
10:29:21 <applicative> gwern, why not --time-limit=    --no-imports=
10:29:28 <soupdragon> :t toIntegral
10:30:32 <djahandarie> lambdabot is down?
10:30:32 <tao_> fromIntegral :: (Integral a, Num b) => a -> b
10:30:36 <benmachine> tao_: something thinks n should be an Int, how are you using it?
10:30:47 <gwern> applicative: fine, done
10:30:55 * gwern switches to bool while I'm at it
10:30:56 <djahandarie> There seem to be a lot of things going down recently
10:31:06 <tao_> benmachine: i am using it in "take"
10:31:12 <tao_> and yes, it should be an int
10:31:18 <tao_> should i use something like floor?
10:31:27 <benmachine> yes
10:31:31 <benmachine> floor/ceiling/round
10:31:36 <benmachine> whichever of those suits you
10:31:51 * benmachine wishes he knew a good algorithm to get integer square roots
10:32:04 <Twey> Babylonian works…
10:32:09 <tao_> well, n will be 100% a integer
10:32:17 <tao_> i mean, it will be something like 10.0
10:32:23 * benmachine wishes he knew what Babylonian was
10:32:26 <tao_> the part after the dot will be zero
10:32:37 <benmachine> tao_: go with round
10:32:41 <kmc> tao_, btw we prefer (f . g . h $ x) rather than (f $ g $ h $ x).  because (f . g . h) is a valid expression by itself, and these pipelines are often refactored to be points-free
10:32:59 <Twey> benmachine: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
10:33:15 <djahandarie> Point-free is a god damn confusing name when introducing that concept to someone
10:33:18 * benmachine wishes he had read that wikipedia page
10:33:26 <benmachine> maybe soon my wishes will come true :PO
10:33:32 <benmachine> *:O
10:33:49 <jesusabdullah> I'm still a bit fuzzy on what the difference is between . and $
10:33:55 <jesusabdullah> and I know there are important ones!
10:33:59 <kmc> f . g = \x -> f (g x)
10:34:04 <kmc> f $ g = f g
10:34:05 <Makoryu> jesusabdullah: (.) always takes two functions as arguments, and returns a third function
10:34:05 <Twey> jesusabdullah: $ applies a function, and . composes two functions
10:34:12 <jesusabdullah> hah
10:34:25 <Makoryu> jesusabdullah: The left argument of ($) has to be a function, but the right argument doesn't
10:34:31 <Twey> > (+ 5) $ 2
10:34:36 <Twey> Oh, no \b
10:34:37 <kmc>  7
10:34:42 <djahandarie> lol
10:34:46 <Twey> \o/
10:34:47 <jesusabdullah> oh
10:34:51 <Twey> @kmcsnack
10:34:56 <kmc> :)
10:35:03 <tao_> hmm
10:35:07 <djahandarie> I do have an instance of mueval hooked into an irc bot I can put up real quick
10:35:15 <tao_> is it wrong to have IO function which also has recursion?
10:35:18 <kmc> it seems that today's my day in the barrel
10:35:21 <jesusabdullah> (+5).2 wouldn't make sense! Cool
10:35:22 <dolio> See, that's another reason why ($) shouldn't be infixr. That has to be one of the most asked questions here.
10:35:24 <kmc> tao_, not in general
10:35:32 <jesusabdullah> infixr?
10:35:34 <kmc> tao_, by "IO function" do you mean a function that returns an IO action?
10:35:41 <jesusabdullah> yecch
10:35:41 <tao_> yes
10:35:43 <dolio> If it were infixl, it wouldn't make any sense, because they'd do obviously different things.
10:35:47 <tao_> a do monad
10:36:03 <benmachine> dolio: I think both infixr and infixl versions are useful sometimes
10:36:12 <kmc> tao_, sure, (IO a) is just another type . you can have recursive functions that return Int or Bool or String or (IO a) etc.
10:36:18 <benmachine> or at least, I recall defining it infixl once and then finding myself wanting the other version as well
10:36:24 <tao_> uhh
10:36:30 <jesusabdullah> (+5) $ 2 == 2 (+5) ?
10:36:32 <tao_> how can i end recursion then?
10:36:33 <tao_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25884#a25884
10:36:34 <applicative> well, if (.) = fmap and  ($) is the fmap for the identity functor, i can see why jesusabdullah might assimilate them.
10:36:36 <jesusabdullah> idk why this is so hard for me to grasp
10:36:43 <tao_> is there is a command for do... nothing?
10:36:50 <kmc> tao_, sure
10:36:50 <monoidal> return ()
10:36:51 <kmc> return ()
10:36:52 <Makoryu> jesusabdullah: No, foo $ bar == foo bar
10:36:58 <tao_> oh
10:36:59 <tao_> hehe
10:37:00 <tao_> silly me
10:37:03 <tao_> thanks a lot <3
10:37:04 <kmc> tao_, «return v» is an IO action which does nothing except produce the result «v»
10:37:05 <kmc> :)
10:37:07 <jesusabdullah> So why have the dollar at all?
10:37:11 <jesusabdullah> ow8
10:37:21 <tao_> jesusabdullah: looking better
10:37:31 <tao_> reminds me of unix pipes, reversed version :)
10:37:34 <kmc> jesusabdullah, because then «f $ g x y» = «f (g x y)»
10:37:37 <kmc> allows you to omit parens
10:37:50 <jesusabdullah> (a+b)*c = a
10:37:51 <Makoryu> jesusabdullah: So that when you have "foo (baz (bar (quux gesundheit)))" you don't have to write all those fucking parentheses ;)
10:37:53 <jesusabdullah> dammit
10:37:54 <kmc> jesusabdullah, also, since ($) is just like any other operator, you can use it in a section
10:37:54 <kmc> e.g.
10:37:56 <Twey> jesusabdullah: It saves on brackets in some places, and it's handy for function-application sections.
10:38:00 <kmc> > map ($ 3) [succ, pred]
10:38:04 <kmc>   [4,2]
10:38:05 <kulakowski> It also allows you to write sections (like you did above)
10:38:07 <jesusabdullah> (a+b)*c = a+b $ (*c) ?
10:38:19 <kmc> > zipWith ($) [succ, pred] [3,5]
10:38:20 <kmc>   [4,4]
10:38:45 <Makoryu> jesusabdullah: Ah, I see the use of sections is confusing you :/
10:38:47 <monoidal> jesusabdullah: c * (a+b) = (c *) (a+b) = (c *) $ a + b
10:38:55 <kmc> (x+) = \y -> x+y
10:38:59 <kmc> (+x) = \y -> y+x
10:39:01 <jesusabdullah> hmmm
10:39:08 <monoidal> like in (1+) 2 = 3
10:39:09 <jesusabdullah> = \ ?
10:39:09 <kmc> the "missing side" of the operator becomes an implicit argument
10:39:25 <monoidal> \x -> ... is a function
10:39:40 <dolio> That lets you write plenty of confusing stuff, too.
10:39:41 <jesusabdullah> I should prooobably wait until I'm more awake (and read up again) before asking questions
10:39:43 <kmc> «\x -> 3+x» is the function which takes some argument x and returns 3+x
10:39:46 <dolio> @type (1 + 2 + 3 + )
10:39:54 <jesusabdullah> because I think just looking up some literature would really clear things up for me
10:39:58 <jesusabdullah> that, and actual use XD
10:39:59 <kmc> \ is pronounced "lambda" (and is supposed to look a little like λ)
10:40:02 <dolio> Oh, no bot.
10:40:11 <Makoryu> I wonder if I still have that one page
10:40:19 <kmc> jesusabdullah, it allows you to create function values without naming them
10:40:23 <Makoryu> Man I haven't worked on this in like a year
10:40:25 <jesusabdullah> Could you use a unicode lambda if you wanted to?
10:40:33 <kmc> «\x -> e» is like «let f x = e in f»
10:40:36 <jesusabdullah> that'd be nifty
10:40:36 <Makoryu> jesusabdullah: No :(
10:40:39 <kmc> jesusabdullah, no, because it's a lower-case letter
10:40:39 <jesusabdullah> :(
10:40:45 <Makoryu> jesusabdullah: http://echo.rsmw.net/n00bfaq.html
10:40:46 <kmc> so thus starts an identifier
10:41:01 <monoidal> some editors render \ as lambda
10:41:02 <kmc> i strongly object to the name of that thing
10:41:08 <jesusabdullah> thanks Makoryu !
10:41:09 <kmc> "Haskell *Syntax*: The Confusing Parts"
10:41:11 <djahandarie> jesusabdullah, editors like Yi render \ as λ though
10:41:19 <Makoryu> kmc: That's 'cause I never finished it.
10:41:24 <kmc> ah, fair enough
10:41:25 <jesusabdullah> cool
10:42:22 <Makoryu> kmc: There's twice that much text sitting on my hard drive somewhere, addressing some polymorphism stuff and the like
10:42:26 <tao_> uhh, what's wrong with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25884#a25885
10:42:29 <tao_> (second paste)
10:42:38 <tao_> or is there other way to end recursion?
10:42:48 <kmc> tao_, you need another "do" after "then"
10:43:01 <kmc> "do" joins several statements together into a single expression
10:43:21 <tao_> and what about the fisrt do?
10:43:24 <applicative> jesusabdullah: c * (a+b)  =  (c *) (a+b)  =  (c *) $ a + b  =  ($(a*b)) (c*) = ($(c*)) ($(a*b)) = ($ ($(a*b)) ) ($(c*)) = ($($(c*)) )($ ($(a*b)) )
10:43:56 <djahandarie> lol overkill?
10:44:17 <kmc> tao_, also, you're going to recompute "length mat" over and over
10:44:18 <Makoryu> tao_: Your indentation puts the "where" block inside the "do" block
10:44:21 <monoidal> tao_: you can use when from Control.Monad instead of if .. then .. else return ()
10:44:24 <c_wraith> uh.  a + got converted into a * in there
10:44:36 <applicative> @type  ($($(1.1*)) )
10:44:55 <Makoryu> tao_: But a where-block has to be associated with a (=)
10:44:57 <applicative> guess we dont have that back
10:45:02 <tao_> monoidal: thanks
10:45:10 <tao_> Makoryu: ok, thnkas
10:45:12 <tao_> noted
10:46:09 <applicative> c_wraith, indeed:  c * (a+b) = (c*) (a+b) = (c*) $ a+b = ($(a+b)) (c*) = ($(c*)) ($(a+b)) = ($ ($(a+b)) ) ($(c*)) = ($($(c*)) )($ ($(a+b)) )
10:46:37 <kmc> tao_, you could also use guards
10:46:41 <kmc> but i think "when" is the correct solution here
10:47:42 <tao_> yeah
10:48:26 <kmc> also you could precompute (length mat)
10:48:33 <kmc> and do the recursion within a local "where" function
10:48:45 <monoidal> tao_: also, putStrLn . show can be shortened to print
10:49:37 <HugoDaniel> http://donsbot.wordpress.com/2010/05/31/there-are-a-hell-of-a-lot-of-haskell-libraries-now-what-are-we-going-to-do-about-it/  :)
10:49:41 <HugoDaniel> soon: world domination
10:49:59 <zygoloid> tao_: i think guards are a better solution fwiw
10:50:29 <tao_> monoidal: thanks, that's handy
10:50:36 <tao_> zygoloid: better then when?
10:50:40 <zygoloid> tao_: alwo, if start == length mat, then putStrLn $ show $ take n (drop start mat) == putStr "[]\n"
10:51:19 <tao_> also, this is still not ending the recursion: http://codepad.org/f8KP9Pw9
10:51:26 <zygoloid> tao_: yes. no point using the monadic machinery of when, if you can use something cleaner
10:51:30 <tao_> sorry, i am new to haskell
10:51:43 <tao_> zygoloid: ok, i'll try guards
10:51:50 <monoidal> tao_: return is not like in imperative language
10:52:05 <tao_> ooh
10:52:08 <tao_> heh
10:52:25 <kmc> do { return (); m} is the same as do { m }
10:52:33 <kmc> it doesn't do an early exit or anything
10:52:36 <monoidal> when (start < len) $ do putStrLn...
10:52:38 <Zao> return lifts a value into a monad.
10:52:47 <Zao> @type return
10:52:51 <zygoloid> tao_: unwrap [] 0 calls unwrap mat (start+n), where start == 0 and n == 0. that's one way it can recurse infinitely.
10:52:52 <kmc> it just takes a value and gives you a do-nothing action which produces that value
10:52:53 <djahandarie> I still don't understand why the hell they called it return
10:53:04 <Zao> I prefer `pure', mostly because it's shorter.
10:53:06 <Zao> And annoys people.
10:53:13 <benmachine> heh
10:53:17 <benmachine> I like that reasoning
10:53:26 <Zao> Who ate lambdabot?
10:53:34 <zygoloid> djahandarie: if you don't use it to short-circuit, it does act like an imperative return. plus, you know, trying to avoid success at all costs :)
10:54:01 <HugoDaniel> haskell exceptions always remind me of a space shuttle getting blown away
10:54:02 <djahandarie> zygoloid, how does it act like an imperative return?
10:54:05 <tao_> zygoloid: yeah, i thought return would just end monad
10:54:13 <HugoDaniel> ...you never know when they are going to happen
10:54:17 <Twey> zygoloid: No it doesn't
10:54:18 <kmc> you can't win.  when you use unfamiliar names like "Monad", people complain that it's confusing.  when you use familiar names like "return", people complain that it's confusing.
10:54:19 <djahandarie> zygoloid, more than any other value, like '5'
10:54:37 <Twey> Imperative ‘return’: do { return 5; return 3 } returns 5, not 3
10:54:38 <soupdragon> You can win by not listening to such stupid complaints
10:54:52 <benmachine> heh
10:55:00 <tao_> "Monad" is not confusing, it's just something different
10:55:02 <benmachine> I prefer unfamiliar names to familiar ones generally
10:55:04 <zygoloid> Twey: ? I said, if you're not using it to short-circuit. there, you are using it to short-circuit
10:55:04 <Twey> (and it doesn't wrap stuff up, either)
10:55:07 <tao_> while return is confusing
10:55:13 <sinelaw> hey all
10:55:16 <tao_> because it has different meaning in imerative languages
10:55:17 <Twey> zygoloid: Ah, I see — you meant in the imperative.
10:55:28 <zygoloid> Twey: right :)
10:55:40 <tao_> thanks everyone :)
10:56:00 <monoidal> tao_: often, in haskell you can do I/O later and build auxiliary functions
10:56:11 <Makoryu> http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/ <- This is still my favorite monad explanation
10:56:12 <HugoDaniel> *** Exception: spaceShuttle: BOOM!
10:56:13 <monoidal> for example, unwrap could return a list of lists
10:56:26 <kmc> tao_, people still complain about the name "Monad"
10:56:42 <Twey> Heh
10:56:44 <kmc> soupdragon, i like your style
10:57:05 <Makoryu> kmc: I like it when people complain that Monad, Functor, and Applicative are redundant distinctions, and they should all be called DataStructure
10:57:10 <kmc> haha
10:57:16 <monoidal> tao_: I think unwrap mat (drop n) would be better if you passed length additionaly
10:57:18 <Twey> They have public virtual inline const destructors, and they complain when we call something ‘monad’?
10:57:21 <Makoryu> It's kind of like watching teabaggers run under a bus
10:57:25 <monoidal> because your version is O(n^2)
10:57:26 <kmc> let's just get rid of static types and call everything "Value"
10:57:43 <sinelaw> intel CnC for haskell looks nice
10:57:49 <sinelaw> first intel lib for haskell?
10:57:52 <benmachine> let's just get rid of computers and count on our fingers
10:58:36 <Apocalisp> > (iterate (+1) 0) !! 9000000
10:59:04 * osfameron doesn't understand Applicative at all.  Why aren't there 300 billion tutorials about *that*, eh?
10:59:33 <Twey> osfameron: An Applicative is just a functor with a function inside ☺
10:59:37 <kmc> osfameron, ah, you see, an applicative functor is like an enchilada
10:59:38 <Makoryu> osfameron: The link I pasted above does exactly that!
10:59:42 <kmc> that's really all you need to know
10:59:45 <soupdragon> I don't understand what's to not underrstand about applicative
10:59:49 <Makoryu> Twey: Well, then again, a monad is just.... etc. etc.
10:59:50 <kmc> osfameron, for serious though, Typeclassopedia covers it
10:59:55 <Makoryu> osfameron: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
10:59:56 <kmc> on the way to Monad
10:59:56 <soupdragon> instead of writing   f  $ x   you write  f <$> x
10:59:58 <soupdragon> not very diffcult
11:00:05 <kmc> soupdragon, that's just Functor actually
11:00:08 <monoidal> osfameron: the original paper about applicatives is quite readable
11:00:17 <kmc> applicative gets you f <$> x <*> y <*> z
11:00:22 <alip> are there any open source haskell projects using hs-curses? I need examples :)
11:00:22 <dever_> hey all, im doing some unit testing with hunit, and its giving me some strange results of testcases, output: http://pastebin.com/H5qeY1Nk  anyone have any ideas why this might be?
11:00:30 <soupdragon> :t (<$>)
11:00:32 <soupdragon> :t (<*>)
11:00:42 <kmc>   (Functor f) => (a -> b) -> f a -> f b
11:00:48 <kmc>   (Applicative f) => f (a -> b) -> f a -> f b
11:00:55 <kmc> sorry i forgot the foralls
11:00:58 <soupdragon> oh geeee
11:01:02 <soupdragon> I see
11:01:05 <kmc> you'll have to live with H98 types
11:02:05 <applicative> > let itsec = iterate (\str -> "($" ++ str ++ ")") ; equivs = zipWith (++) (itsec "(c*)") (itsec "(a+b)") in equivs
11:02:13 <sinelaw> alip, Peaker has started something using vty
11:02:25 <kmc>   mueval: Time limit exceeded
11:02:40 <applicative> > let itsec = iterate (\str -> "($" ++ str ++ ")") ; equivs = zipWith (++) (itsec "(c*)") (itsec "(a+b)") in take 10 equivs
11:02:47 <applicative> oh well
11:02:50 <sinelaw> alip, vty is an ncurses-style lib for haskell http://hackage.haskell.org/package/vty-4.2.1.0
11:02:57 <soupdragon> :t ?f <*> ?x <$> ?u
11:03:05 <sinelaw> Peaker's code is at http://github.com/Peaker/vtywidgets
11:03:53 <sinelaw> he's building a widget set for text-based
11:03:58 <applicative> osfameron, there should be a hundred million Applicative tutorials.
11:04:12 <Twey> soupdragon: Functor f => f a
11:04:13 <djahandarie> I have a bot to run > stuff, but I don't have access to it atm lol
11:04:14 <kmc>   forall (f :: * -> *) a b c. (Applicative f, ?f :: a -> b -> c, ?x :: f a, ?u :: f b) => f c
11:04:16 <kmc> or so
11:04:20 <sinelaw> osfameron, try this
11:04:25 <applicative> osfameron and two hundred million Functor tutorials.
11:04:25 <sinelaw> @google typeclassopedia
11:04:31 <kmc> oh nm
11:04:31 <Apocalisp> osfameron: Applicative lets you combine (m a) values. You can combine n values with a function of arity n.
11:04:36 <monoidal> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
11:04:38 <kmc> you have <*> and <$> swapped from what i expected
11:05:02 <kmc> if you know what liftM2, liftM3 do etc.
11:05:14 <kmc> that's all you get with Applicative
11:05:23 <soupdragon> I swapped them on purpose
11:05:30 <kmc> soupdragon, to confuse me :/
11:07:59 <Apocalisp> How do I get the nth iteration of a computation without blowing the stack for large n?
11:08:15 <alip> sinelaw: thanks!
11:08:45 <Makoryu> Apocalisp: Discard the previous results by letting them go out of scope
11:09:03 <Apocalisp> iterate is just so convenient
11:09:27 <dever_> no one?
11:11:01 <monoidal> Apocalisp: would iterate (f $!) help?
11:11:02 <Twey> Apocalisp: And use strictness annotations appropriately to avoid building up a huge thunk
11:11:58 <Apocalisp> monoidal: No, apparently not.
11:12:02 <applicative> kmc, liftM17 doesnt use `ap`, it's the ugly liftA17 .  You dont get e.g.   [(+),(*),(^),(\x y -> x+y+17)] <*> [100,200,300] <*> [1,2,3]
11:12:39 <kmc> applicative, ?
11:13:06 <kmc> you can recover [f,g] <*> [x,y]
11:13:16 <kmc> as liftM2 ($) [f,g] [x,y]
11:13:17 <applicative> kmc, i was meditating  on "if you know what liftM2, liftM3 do etc. <kmc> that's all you get with Applicative
11:13:29 <kmc> it's not direct, i agree
11:13:31 <applicative> of course you can recover them.
11:13:37 <kmc> but equal in power
11:13:45 <kmc> and less than what you get with (>>=)
11:15:03 <applicative> of course.  but it's a different point of view.   <*> is like whitespace in another 'idiom'
11:15:46 <kmc> yeah
11:19:17 * hackagebot data-accessor 0.2.1.4 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.4 (HenningThielemann)
11:19:19 * hackagebot data-accessor-monads-fd 0.2.0.2 - Use Accessor to access state in monads-fd State monad class  http://hackage.haskell.org/package/data-accessor-monads-fd-0.2.0.2 (HenningThielemann)
11:20:19 <monoidal> Apocalisp:  iterate' f x = x seq x : iterate' f (f x)
11:20:25 <monoidal> (credit: http://hackage.haskell.org/trac/ghc/ticket/3474)
11:21:01 <Cale> Probably want that seq in backticks
11:21:09 <monoidal> whoops, yes
13:31:11 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Church, Milner, Rudin, Gardner"]'
13:31:11 --- topic: set by copumpkin!~copumpkin@c-75-69-96-50.hsd1.nh.comcast.net on [Wed May 26 23:03:44 2010]
13:36:51 <pastorn> @hoogle showHex
13:36:56 <pastorn> @hoogle showhex
13:37:15 * fryguybob misses lambdabot...
13:37:29 <jimmyjazz14> I am trying to figure out the best way to deal with multi parameter type classes and existential types, so far I have the following http://pastie.org/988071
13:37:42 <Twey> pastorn: Numeric
13:38:00 <Twey> (Integral a) => a -> String -> String
13:38:13 <danharaj> Where did lambdabot go?
13:38:30 <jimmyjazz14> but my DoesIt type does not hide everything and creating a new instance of it requires me to explicitly list the type I want
13:38:46 <gwern> danharaj: beyond the event horizon
13:38:57 <kmc> jimmyjazz14, can you give an example of the problem you want to solve?
13:39:10 <danharaj> gwern: I don't follow.
13:39:14 * danharaj rimshot
13:39:25 <jimmyjazz14> kmc: basically I want my typeclass to be able to work in pure code or in IO depending on what monad I call it in
13:39:49 <kmc> jimmyjazz14, and you've already considered and rejected simpler ways to accomplish this?
13:39:59 <kmc> i'm not sure what the existential is for
13:40:27 <kmc> it's common to have a function like your "doit" with instances for several monads
13:40:29 <jimmyjazz14> kmc: well I need to be able to build up a list of types that can be used with the DoIt typeclass
13:40:33 <kmc> ah
13:40:45 <kmc> and you want to force that they all use the same monad, but not that they have the same type inside
13:40:58 <jimmyjazz14> kmc: right
13:41:05 <kmc> the only thing you could do with a "DoesIt m" value is call "doit", right?
13:41:15 <jimmyjazz14> kmc: exactly
13:41:29 <kmc> jimmyjazz14, so why not just use the type [m String]
13:41:48 <kmc> the type "a" goes away once you've applied doit
13:41:50 <kmc> so why not pre-apply
13:42:14 <jimmyjazz14> kmc: well my example is simplistic, that is not possible in my real usage
13:43:04 <alexyk> copumpkin: you're back!? :)
13:43:05 <jimmyjazz14> basically the problem is that to create an instance of the "DoesIt" type I have to do some like: DI "Test" :: DI IO
13:43:23 <jimmyjazz14> even if I do so in the IO monad
13:43:29 <gwern> alexyk: he's just produced a little more output, that's all
13:43:48 <kmc> jimmyjazz14, why is that a problem?
13:44:27 <jimmyjazz14> kmc: well because I have to explicitly provide the type, which is inconvenient
13:44:27 <alexyk> gwern: well, the philosophical forks from here leave me speachless
13:44:36 <kmc> jimmyjazz14, which? "IO"?
13:44:40 <jimmyjazz14> yeah
13:44:51 <kmc> otherwise you get an ambiguity error?
13:44:55 <soupdragon> jimmyjazz14, what's the point of this?
13:45:02 <jimmyjazz14> kmc: yes
13:45:28 <sioraiocht> bos: ping?
13:45:51 <alexyk> so, I parse JSON and get things like Object of Object of Number or String.  I want to have a Map instead of the Object and an Int instead of the Number.  Do I have to boringly case-walk the original, producing the result, or there's a magic Schmonad which will take care of it all in a single <%^&> op?
13:46:08 <jimmyjazz14> soupdragon: to be able to allow my typeclass function to be used in IO or pure code, but still be able to conveniently use existential types.
13:46:16 <soupdragon> no I mean what are you trying to do
13:46:49 <Saizan> alexyk: are you asking that again in the hope something magical appeared in the meantime?:)
13:46:50 <soupdragon> you know about hte Identity monad?
13:46:54 <soupdragon> or State monad
13:47:01 <jimmyjazz14> soupdragon: indeed I do
13:47:07 <soupdragon> good
13:47:33 <jimmyjazz14> soupdragon: in fact the Identity monad is how I will use my typeclass function in pure code
13:47:45 <Saizan> alexyk: in any case it should take very little to do that conversion
13:48:01 <kmc> alexyk, sounds like maybe you want Data.Data
13:48:13 <kmc> alexyk, http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB
13:48:23 <alexyk> Saizan: that's a new desire!  I have now the nice ADT so I can easily walk, OCaml-style.  But being formidably shocked and awed by the monadic chapters of RWH, I live in fear now that everything I can think of is wrong and the gurus would conjure a magic op I'd never find out about unless I ask!
13:48:25 <Saizan> that sounds way overkill
13:48:53 <jimmyjazz14> soupdragon: as far as I can tell my code is correct for generalizing the monad that my typeclass function can work in
13:49:12 <alexyk> the conversion is easy indeed.  I still need a magic potion to cure the fear of not using the monads.
13:49:28 <Saizan> alexyk: i'd just use the Maybe monad to propagate "parse" failure
13:49:44 <alexyk> like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
13:49:54 <Twey> Haha
13:49:56 <kmc> @remember alexyk like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
13:49:59 <kmc> aww right
13:50:10 <kmc> preflex, tell lambdabot @remember alexyk like a centipede, when I start typing, I stop and search inside me for a monad waiting to happen.  Is it ripe enough?  I never know!
13:50:11 <preflex>  Consider it noted.
13:50:11 <Twey> Damn :þ
13:50:27 <Twey> preflex: tell Twey foo
13:50:27 <byorgey> alexyk: try searching for Functors and Applicatives first.
13:50:27 <preflex>  what
13:50:30 <Twey> Haha
13:50:36 <kmc> preflex, tell Twey you suck ;P
13:50:36 <preflex>  Consider it noted.
13:50:43 <Twey> So, will that work?
13:50:44 <preflex>  Twey: you have 1 new message. '/msg preflex messages' to read it.
13:50:47 <Twey> No, it won't
13:50:47 <kmc> :(
13:51:05 <Twey> Leading space and /msg indirection ☺
13:51:33 <alexyk> wow, a Kafkian bureaucracy of haskell bots!
13:51:48 <alexyk> Saizan: a Maybe is good
13:52:02 <Twey> Haha
13:53:02 <kmc> anyway i'm not sure whether SYB is overkill here
13:53:04 <kmc> it frequently is
13:53:16 <kmc> but if you're asking for the fancy way to avoid boring case traversals
13:53:19 <kmc> that's one
13:53:32 <kmc> also look at "Uniplate"
13:53:53 <applicative> jimmyjazz14, this does yield the right result for  DI "Test" :: DI IO    http://pastebin.com/z7r3ue19   but it seems absurdly complicated
13:53:57 <alexyk> ok
13:54:37 <applicative> jimmyjazz14, I assume you've tried every pragma in ghc --supported-languages :)
13:59:13 <idnar> -feverything
14:02:28 <jimmyjazz14> applicative: here is a further fleshed out example
14:03:23 <jimmyjazz14> applicative: sorry pastie mangled that last one http://pastie.org/988139
14:08:26 <ksf> hmmm monadic pattern guards?
14:10:50 <ksf> ...I just want to get some state in a guard.
14:14:03 * soupdragon is still struggling to come up with a name
14:14:40 <applicative> jmmyjazz, cant get to the bottom of it, but have to go
14:14:53 <applicative> too many pragmas!
14:17:45 <FCo> hi, is hpaste.org down?
14:19:21 <monoidal> yes
14:23:24 <Polarina> How does parsec3 perform memory wise?
14:25:03 <aristid> Polarina: dunno if this is what you care about: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
14:29:57 <Polarina> aristid, that article concentrates much more on performance than memory usage. :)
14:44:28 * hackagebot Hawk 0.0.2 - Haskell Web Application Kit  http://hackage.haskell.org/package/Hawk-0.0.2 (BjoernPeemoeller)
14:50:23 <triyo> Is there a way to run multiple versions of GHC on single machine?
14:50:56 <triyo> I am running 6.10.4 but would also play around with some new features from head ver.
14:51:19 <dcoutts> triyo: yep, I've got 5 versions installed
14:51:20 <kmc> yeah triyo
14:51:26 <kmc> you can install to a local "prefix" directory
14:51:37 <kmc> ./configure --prefix=/home/me/wherever && make install
14:51:43 <kmc> in a ghc binary tarball
14:51:45 <kmc> should do it
14:51:51 <dcoutts> I've got one system one in /usr and 4 local versions in the prefix /usr/local
14:51:59 <dcoutts> the different versions co-exist happily
14:52:09 <triyo> ok, and effect on caba? will cabal keep seperate versions of packages / builds for different ghc vers?
14:52:13 <dcoutts> yes
14:52:13 <triyo> *cabal
14:52:25 <triyo> perfect, thats awesome
14:54:16 <triyo> I saw there was work done around "nested data parallelism". Has this bean committed to head or elsewhere?
14:54:26 <triyo> ref http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:54:58 <dcoutts> triyo: it's an ongoing multi-year project
14:55:22 <dcoutts> all the available stuff is in ghc head, or older released versions
14:56:13 <triyo> cool, thx
14:57:04 <Heffalump> I'm beginning to think NDP is a bit like nuclear fusion ;-)
14:57:10 <dcoutts> :-)
14:57:37 * hackagebot threads 0.2 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.2 (BasVanDijk)
14:57:39 <dcoutts> though there are useful things they've produced along the way
14:58:19 <Heffalump> so when will GHC start using stream fusion (for lists)? ;-)
14:59:18 <Heffalump> but yeah, they have, and it does look like there's light at the end of the tunnel now
15:00:11 <dcoutts> Heffalump: it's not clear in the end if stream fusion is better for lists than build/foldr
15:00:21 <dcoutts> we have not solved the concatMap problem
15:00:34 <dcoutts> and build/foldr could possible be improved to handle accumulating parameters
15:00:45 <dcoutts> by adding a particular (generic) optimisation
15:00:55 <dcoutts> though build/foldr will not handle zips still
15:01:06 <Heffalump> I've read a lot of papers about adding accumulating parameters, and they all gave me headaches.
15:01:18 <dcoutts> I don't think it's that hard
15:01:34 <dcoutts> the optimisation is in Andy's thesis
15:01:37 <soupdragon> I love that F5 one
15:01:45 <soupdragon> but that's sort of for beginners but I really enjoyed raeding it
15:01:59 <soupdragon> graham huttons paper
15:02:04 <dcoutts> Heffalump: it's the arity analysis and arity raising transform
15:02:32 <dcoutts> Heffalump: the one that converts a foldl written in terms of foldr into the usual foldl
15:03:52 <dcoutts> Heffalump: the other problem is sharing, which of course is not really a problem for arrays since they tend not to share tails
15:04:21 <toki78> are ther ODE bindings for haskell ?
15:04:39 <jimmyjazz14> soupdragon: hey regarding my earlier question does this make any more sense http://pastie.org/988256
15:08:15 <soupdragon> let me try it out
15:09:04 <ksf> why does my ghci segfault on startup all of a sudden?
15:09:41 <ksf> just before opening the prompt
15:09:51 <gwern> ksf: because it was gifted with consciousness and infused with the writings of grim social theorists like hobbes and malthus?
15:10:10 <soupdragon> jimmyjazz14: you can do this:
15:10:25 <soupdragon> http://pastie.org/988268
15:11:57 <jimmyjazz14> soupdragon: thats true, but its not possible to do that in what I am really doing
15:12:02 <soupdragon> why neot?
15:12:04 <soupdragon> why not?
15:12:21 <soupdragon> unless you are working for NSA or MI5 or something :p
15:12:36 <jimmyjazz14> soupdragon: lemme rewrite my example
15:15:13 <soupdragon> jimmyjazz14, also consider http://pastie.org/988273.txt
15:15:26 <soupdragon> keep in mind that the does record could have more fields
15:22:08 <ksf> @hoogle (a-> Bool) -> Maybe a -> Maybe a
15:22:15 <ksf> @bot
15:25:53 <jimmyjazz14> soupdragon: this is much closer to what I am trying to do in real life http://pastie.org/988289
15:26:18 <gwern> '    Abstract: We prove that it is NP-hard to decide whether two points in a polygonal domain with holes can be connected by a wire. This implies that finding any approximation to the shortest path for a long snake amidst polygonal obstacles is NP-hard. On the positive side, we show that snake's problem is "length-tractable": if the snake is "fat", i.e., its length/width ratio is small, the shortest path can be computed in polynomial time. ' <-- truly, ...
15:26:24 <gwern> ... np problems are everywhere
15:27:08 * benmachine wonders why fat snakes are easier
15:27:08 <jimmyjazz14> soupdragon: I don't show it but I want "doit", to be able to be flexible enough to perform IO or whatever upon lookups
15:27:50 <soupdragon> I think you can acheive this using the technique from http://pastie.org/988273.txt
15:27:53 <ddarius> benmachine: They are slower due to being weighed down by pigs.
15:28:15 <benmachine> oh, ok
15:29:21 <jimmyjazz14> soupdragon: okay, I'll look a little closer at that example and see what I can figure out
15:29:36 <jimmyjazz14> soupdragon: thanks
15:30:50 <mreh> why hasn't my cabal doc linked to my source code?
15:31:23 <kmc> moving furniture is PSPACE complete
15:31:32 <soupdragon> LOL
15:31:34 <kmc> if you allow for weirdly shaped objects with hinges and such
15:31:38 <kmc> and weirdly shaped corridors
15:31:55 <soupdragon> kmc, hey that sounds like a lot of fun
15:31:58 <dcoutts> mreh: use cabal haddock --hyperlink-source to generate links to sources
15:31:58 <soupdragon> as a puzzle game
15:32:00 <kmc> yeah
15:32:11 <mreh> dcoutts: oh okay
15:32:27 <mreh> I thought it would have been default, can I add it to my cabal config>
15:32:28 <soupdragon> I wonder if there's a neat way you could encode descision problems for a certain set into furnature moving problems
15:32:34 <ddarius> We should turn all the NP-hard problems into cheap web games.
15:32:41 <kmc> i wonder if you can study professional movers and figure out what they do differently
15:32:47 <dcoutts> mreh: no, there's no option for that in the config
15:32:49 <soupdragon> ddarius, this produces an efficient algorithm for solving them ??
15:32:49 <djahandarie> Haha ddarius
15:32:57 <kmc> when i help friends move stuff there's always a lot of arguing about which way to tilt things etc
15:33:05 <kmc> i saw a game where the goal was to fold proteins
15:33:10 <kmc> it wasn't actually very fun though
15:33:11 <Saizan> soupdragon: an highly distributed one, at least
15:33:16 <ddarius> kmc: The magic is that professional movers don't care.
15:34:29 <dcoutts> mreh: http://hackage.haskell.org/trac/hackage/ticket/517
15:34:47 <theorbtwo> Professional movers will also move trashcans full of trash without.
15:34:56 * hackagebot hsyscall 0.3 - FFI to syscalls  http://hackage.haskell.org/package/hsyscall-0.3 (AycanIrican)
15:37:03 <kmc> that's what makes them professional
15:37:09 <kmc> why should they assume you meant to throw out that trash
15:41:16 <ksf> what makes them professional is using a door to maneuvre a sofa into a position where it's stuck when that door dissapears, and making lunch break at exact the right time.
15:42:38 <soupdragon> yeah that modifcation makes it NP complete
15:45:14 <ksf> do we have a transformer library where one can tag say StateT with a phantom type and filter it out of the stack somehow so that the user can stack another StateT without hell breaking loose?
15:46:34 <ksf> ...and of course get etc. taking an extra argument to choose the right StateT
15:47:03 <benmachine> surely in most cases you could just replace the previous state with a new one
15:47:22 <benmachine> like, swap your old StateT s m a for a StateT (t, s) m a
15:48:02 <ksf> but I'm using a StateT here that should be confined, and the user shouldn't touch it at all
15:48:26 <ksf> the state type won't be exported, too, and it's hidden in a newtype
15:48:36 <ksf> but it of course still has a MonadState instance.
15:50:12 * ksf thinks he worries too much
15:50:27 * benmachine worries he thinks too much
15:50:35 <benmachine> (except not really)
15:52:26 <kmc> ksf, sounds like http://tomschrijvers.blogspot.com/2010/03/bruno-oliveira-and-i-are-working-on.html
15:53:16 <kmc> ksf, in that situation i might just not derive MonadState
15:53:30 <kmc> i find that usually i don't really want the generic State or Error interface on my newtype-wrapped transformer stack
15:53:39 <kmc> instead i have a few domain-specific operations
15:54:49 <kmc> i am beginning to think that the common wish of "newtype without wrappers" is less crazy than i previously thought
15:54:55 <kmc> it's a lot like Hugs's scoped type synonyms
15:55:51 <kmc> the simple wish-list item would be a construct that acts like a synonym within a module, but is exported as an opaque abstract type
15:56:55 * ksf would currently like cps without the confusion
15:57:07 <ksf> the problem is that suddenly every other function is a bleeding control structure
15:57:37 <ksf> taking a gazillion of possible continuations and not being very obvious about when each one of them would be called
15:59:14 <kmc> well, the situation is clearer in Haskell than in Scheme
15:59:42 <ksf> sometimes I'm wishing for named parameters, which is why I'm using a ReaderT
16:00:00 <ksf> ...but then the non-extensibility of data types makes stuff even more complicated
16:00:09 <kmc> functions can't invoke continuations, only actions on the LHS of (>>=) can
16:00:23 <kmc> (and the stuff directly inside runCont)
16:00:45 <kmc> maybe you could use the "records" package?
16:01:01 <kmc> it looks slightly vorpal
16:01:57 <ksf> possibly, but then I also want to write code and not read up on a gazillion of packages that either for the first couple of days look that they can do what I want but then can't, or don't look that they can do what I want until I stumble across them again, months later.
16:02:13 <kmc> yeah
16:02:54 <aristid> don't GADTs theoretically obsolete old-style datas?
16:02:57 <ksf> or come with ten thousand classes all named C
16:03:12 <ksf> they're a superset
16:03:29 <soupdragon> aristid, yes!
16:03:37 <BMeph> ...with class derivation "issues". :|
16:03:45 <soupdragon> you can write any of the old data types in GADT style
16:03:53 <aristid> BMeph: huh?
16:03:57 <ksf> I'd think that -XGADTs changes the accepted syntax, not what ghc does in the background.
16:04:15 <soupdragon> basically 'deriving' is broken when it comes to GADTs
16:04:25 <soupdragon> which is a shame.... but maybe something more general will come along
16:04:39 <benmachine> you can do StandaloneDeriving on them
16:04:41 <aristid> aah, you can't use the deriving keyword with them
16:04:56 <benmachine> ooh, that reminds me
16:05:07 <benmachine> I came up with yet another syntax proposal for
16:05:08 <benmachine> something
16:05:22 <benmachine> where you go instance Monad deriving (Functor, Applicative) where
16:05:24 <gwern> benmachine: I second that notion. everyone is for something
16:05:32 <benmachine> heh
16:05:43 <benmachine> it's an idea that lots of people have had before but I just like my way of writing it
16:06:05 <benmachine> class Monad deriving (Functor) where fmap f m = m >>= return . f
16:06:12 <benmachine> and the other monad stuff
16:06:51 <ksf> ah user-specified deriving, so to say
16:06:58 <benmachine> well sort of
16:07:08 <benmachine> I'm thinking the same kind of mechanism that went into class aliases
16:07:10 <Gracenotes> I found a use case for GADTs in my code
16:07:21 <Gracenotes> I'm so proud :3
16:07:26 <benmachine> where one instance can imply others
16:07:34 <Gracenotes> granted, it was as a replacement for a messy existential construct...
16:07:53 <ksf> and as it'd be class (Functor m, Applicative m) => Monad m you could then just say instance Monad Foo where and ghc automagically derives the required context
16:08:03 <shapr> Does berp build with ghc 6.12 yet?
16:08:16 <ksf> not if either of one didn't fix anything
16:08:22 <ksf> yesterday it reportedly didn't work
16:08:31 <shapr> Ah, too bad
16:08:37 <shapr> I couldn't build it yesterday either.
16:08:41 <benmachine> ksf: the problem with automagic derivation is
16:08:42 <benmachine> umm
16:08:45 <benmachine> I can't remember
16:08:48 <benmachine> but there's a problem with it
16:08:56 <benmachine> possibly it's just that sometimes you want to do that deriving yourself
16:09:07 <benmachine> sometimes there might already be a Functor and you want to add an Applicative
16:09:32 <ksf> if you don't like the default instances performance-wise, you can say instance Monad Foo where fmap = ... iff there's no other explicit functor instance for Foo
16:10:21 <ksf> anyway, the deriving can be made explicit, too.
16:10:23 <jesusabdullah> !!! RWH is readable online. How did I not know this?! XS
16:10:28 <jesusabdullah> stompy stompy
16:10:29 <benmachine> the deriving should be explicit I think
16:10:30 <jesusabdullah> :E
16:10:47 <ksf> instance Monad Foo deriving (Functor, Applicative) where return = ...
16:10:54 <benmachine> yes exactly that
16:10:56 <gwern> jesusabdullah: it's a plot to get you to buy it
16:11:11 <benmachine> I should write this down somewhere
16:11:20 * benmachine goes looking for a wiki page that cares
16:11:40 <ksf> http://piratepad.net/
16:11:42 <gwern> benmachine: this is a dream. there is no point in writing anything. you will forget upon awkening
16:11:45 <c_wraith> I feel like this should be a simple operation...  f a b = if a == mzero then b else a
16:12:10 <c_wraith> err, mempty, not mzero
16:12:16 <jesusabdullah> gwern: haha, I believe it!
16:12:28 <c_wraith> :t let f a b = if a == mempty then b else a
16:12:31 <c_wraith> :t let f a b = if a == mempty then b else a in f
16:12:41 <c_wraith> oh.  missing bot
16:12:44 <Makoryu> SÅ.
16:12:59 <gwern> c_wraith: what would the type be?'(Monoid a) => a -> a -> a'?
16:13:05 <c_wraith> yeah
16:13:14 <BMeph> f  :: (Eq a, Monoid a) => a -> a -> a
16:13:16 <benmachine> gwern: can't I write things down for reference later in the dream?
16:13:27 <c_wraith> oh, yeah.  there is also the Eq instance
16:13:38 <gwern> benmachine: ever try to read things in dreams? the lucid dreaming folks generally report that you can't - it changes
16:14:01 <benmachine> gwern: hmm, I don't think I have actually!
16:14:09 <gwern> c_wraith: the closest hoogle turns up is... mappend
16:14:19 <benmachine> maybe I'll just make writing motions in the air and hope I fell asleep holding a pen
16:14:23 <benmachine> and in front of some paper
16:14:37 <BMeph> That reminds me: is it ossible to write if-then-else in TH? I.e. if-then-else as implemented in GHC.
16:14:42 <BMeph> *possible
16:14:58 <c_wraith> For some instances of alternative, <|> does what I want.  But that's not true of the [] instance of Alternative
16:15:05 <Makoryu> BMeph: Don't you always have to use the $() syntax to invoke templates?
16:15:15 <djahandarie> > "test"
16:15:16 <haskybot>  "test"
16:15:24 <djahandarie> Only mueval though
16:15:30 <c_wraith> It's actually true for nearly every instance of Alternative that I know of.  I was sad (<|>) didn't work.
16:15:31 <djahandarie> At least until lambdabot is back
16:15:43 <kmc> Makoryu, in expressions, yeah
16:17:09 <benmachine> c_wraith: pretty sure empty <|> b is supposed to be b
16:17:20 <benmachine> oh but
16:17:24 <benmachine> a <|> b is not a
16:17:38 <benmachine> right
16:19:19 <c_wraith> For many instances of Alternative, it is.  But not [].  :(
16:19:54 <benmachine> I think the idea with Alternative is that
16:19:59 <benmachine> if you're doing e.g. parsers
16:20:09 <benmachine> as String -> [(a,String)]
16:20:27 <benmachine> then the Alternative will try the ones on the left and then the ones on the right
16:20:38 <benmachine> what am I talking about
16:20:43 <benmachine> well it makes sense somehow
16:21:27 <c_wraith> parsers are an example of what I want, though.  The result of a <|> b is a if it parsed successfully, b otherwise.
16:21:42 <benmachine> yes but a might not fail immediately
16:21:44 <benmachine> it might fail later
16:21:53 <benmachine> in which case the <|> will have remembered b for you
16:21:57 <benmachine> and you can backtrack
16:22:06 <c_wraith> That's an implementation detail
16:22:23 <benmachine> using Alternative is an implementation detail >_
16:22:24 <benmachine> >
16:22:25 <haskybot>  not an expression: `'
16:22:29 <benmachine> :O
16:22:31 <benmachine> > wat
16:22:31 <haskybot>  Not in scope: `wat'
16:22:42 <benmachine> oh right yes
16:22:46 <benmachine> I pay attention to things
16:22:58 <benmachine> > typeOf ()
16:22:58 <haskybot>  ()
16:23:02 <benmachine> > unsafePerformIO
16:23:03 <haskybot>  Not in scope: `unsafePerformIO'
16:23:08 <benmachine> oh good
16:23:13 <benmachine> it doesn't exist
16:23:15 <benmachine> lest we forget
16:23:22 <BMeph> benmachine: Not one to pussy-foot around, I see... ;)
16:23:34 <benmachine> :D
16:24:02 <c_wraith> > print "hello"
16:24:03 <haskybot>  No instance for (GHC.Show.Show (GHC.Types.IO ()))
16:24:07 <c_wraith> good, good
16:24:32 <benmachine> > Debug.Trace.trace "wibble" ()
16:24:33 <haskybot>  Not in scope: `Debug.Trace.trace'
16:24:41 <zygoloid> c_wraith: <|> works for [] if you only look at the first element of the list ;-)
16:24:57 <c_wraith> zygoloid, that's really close to what I want, except not. ;)
16:25:06 <Makoryu> Hey, anyone wanna reimplement PCC in Haskell? （　°∀°）
16:26:22 <BMeph> c_wraith: Cheat; use ZipList instead of List. ;)
16:27:00 <zygoloid> hmm, what's <|> do for ZipList?
16:27:07 <c_wraith> It's not an instance of Alternative
16:27:24 <yes> hi
16:27:45 <yes> is anyone available?
16:28:01 <c_wraith> Just ask your question.  Someone will probably answer.
16:28:11 <BMeph> c_wraith: Not that that works, either, just thinking out loud...
16:28:33 <anyone> Did someone call for me? ;)
16:28:39 <c_wraith> BMeph: I actually tried it in GHCi before saying something. :)
16:29:33 <c_wraith> Hmm.  If I'm defining my own operator to do this, I want it to be infixr to work how I think it should, right?
16:29:50 <zygoloid> c_wraith: sounds associative to me.
16:30:01 <zygoloid> "pick the leftmost non-empty value"
16:30:27 <c_wraith> err, that's true.  I guess it doesn't matter, so long as it allows association
16:30:42 <c_wraith> but infixr would be more efficient
16:31:05 <c_wraith> infixl would examine every value, infixr will stop when it gets to one that's not empty
16:31:56 <zygoloid> infixr would be lazier
16:32:08 <c_wraith> yes, that's what I mean.  thanks :)
16:33:21 * hackagebot hsyscall 0.4 - FFI to syscalls  http://hackage.haskell.org/package/hsyscall-0.4 (AycanIrican)
16:35:35 <Gracenotes> generating monadic code from data structures is really no more useful than generating applicative code from data structures..
16:36:15 <Gracenotes> namely in the case of recursive data structures: you don't get the benefit of contextual variables
16:36:45 <Gracenotes> ah well.
16:41:48 <djahandarie> I still don't know if I want to go the hsplugins route for this
16:42:07 <kmc> plugins is dead iirc
16:42:08 <c_wraith> I thought hsplugins was deprecated in favor of hint
16:42:10 <kmc> use hint
16:42:40 <kmc> djahandarie, what are you doing?
16:42:43 <djahandarie> But didn't hsplugins do all sorts of things to help make things... plugable?
16:42:52 <djahandarie> Rather than a straight up interpreter
16:43:33 <djahandarie> I'm trying my hand at making a nicer lambdabot
16:43:48 <kmc> oh, you're thinking about the plugin side rather than the mueval side
16:43:49 <kmc> i see
16:43:49 <djahandarie> Which is what haskybot is running right now
16:43:54 <kmc> hi haskybot
16:44:03 <kmc> what does she (?) know how to do?
16:44:05 <benmachine> a nicer lambdabot?
16:44:11 <djahandarie> > "this sort of stuff"
16:44:12 <haskybot>  "this sort of stuff"
16:44:16 <benmachine> have you asked lambdabot what she thinks of this? :(
16:44:17 <anyone> Why don't we have a Boolean class, and do the same thing with it a la Data.String? :)
16:44:23 <djahandarie> And misc managament commands for me
16:44:28 <djahandarie> Nothing else at the moment
16:44:29 <lispy> ?vixen What do you know?
16:44:36 <lispy> doh!
16:44:38 <benmachine> :P
16:44:42 <lispy> where is she?
16:44:42 <benmachine> guess not
16:44:50 <djahandarie> I want to figure out how I want to architect it before I go further
16:44:54 <gwern> chrisdone: I've pushed some changes to the argument handling of mueval you might want to look at
16:44:55 <benmachine> she's in a coma
16:45:03 <chrisdone> wtf
16:45:21 <chrisdone> gwern: did you set that as some kind of irc client hook?
16:45:35 <lispy> hmm...the scripts are running
16:45:51 <lispy> Cale: Any idea why lambdabot is disconnected?
16:46:04 <djahandarie> lispy, that's just something I brought up for the moment
16:46:07 <Cale> lispy: Nope. I'll bring it up.
16:46:31 <Cale> ah, it still thinks it is connected.
16:46:41 <djahandarie> Silly lambdabot
16:46:52 <djahandarie> !quit
16:47:01 <lispy> ?vixen Feeling better?
16:47:06 <lambdabot> whoa whoa whoa, one question at a time!
16:47:06 <monoidal> has anyone run lambdabot on 6.12?
16:47:06 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
16:47:16 <djahandarie> monoidal, 99% sure it will not work
16:47:26 <djahandarie> I wonder who left a message for lambdabot, lol...
16:48:47 <benmachine> hmm
16:48:50 <benmachine> @undo messages
16:48:58 <benmachine> wat
16:48:58 <lambdabot> messages
16:49:01 <benmachine> ah
16:49:05 <benmachine> didn't work though :P
16:49:26 * hackagebot vector-space 0.7.1 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.7.1 (ConalElliott)
16:49:39 <conal> byorgey: ping
16:49:49 <djahandarie> @undo \nPRIVMSG preflex messages
16:49:53 <djahandarie> lol
16:49:54 <lambdabot>  Parse error at end of input
16:49:58 <djahandarie> lol what
16:50:10 <djahandarie> Oh
16:50:14 <deech> Hi all, can someone help me to convert a JSON object into an Alist using the json package? Here's what I have so far: either print (doSomeIO . fromJSObject) (runGetJSON readJSObject jsonmessage)
16:50:19 <benmachine> djahandarie: she's not quite that stupid :P
16:51:02 <deech> GHC complains that it expects something of type JSObject String , but its getting JSValue.
16:51:37 <djahandarie> @undo do { x <- y; z <- t; return x }
16:51:37 <lambdabot> y >>= \ x -> t >>= \ z -> return x
16:51:54 <djahandarie> Figured that's what it did
16:52:00 <djahandarie> @undo "test"
16:52:00 <lambdabot> "test"
16:52:05 <djahandarie> @undo "te\nst"
16:52:05 <lambdabot> "te\nst"
16:52:08 <benmachine> @undo [ toUpper c | c <- s ]
16:52:09 <lambdabot> concatMap (\ c -> [toUpper c]) s
16:52:16 <Axman6> @src (->) (>>=)
16:52:16 <lambdabot> f >>= k = \ r -> k (f r) r
16:52:18 <djahandarie> Whoa
16:52:18 <benmachine> it is clever
16:52:22 <monoidal> @undo [f x y | x <- a | y <- b]
16:52:22 <lambdabot>  Parse error at "|" (column 17)
16:52:29 <djahandarie> How'd it do that?
16:52:37 <benmachine> @undo [ toUpper c | c <- s, s <- lines ]
16:52:37 <lambdabot> concatMap (\ c -> concatMap (\ s -> [toUpper c]) lines) s
16:52:56 <benmachine> list comprehensions are part of the deal
16:53:02 <djahandarie> Is the list comprehension somehow being evaluated as do notation?
16:53:07 <benmachine> no
16:53:13 <benmachine> it's just that @undo does both
16:53:16 <djahandarie> Ah
16:53:27 <benmachine> they are similar concepts in many ways
16:53:35 <djahandarie> It'd be cool if list comprehensions were actually do notation
16:53:39 <monoidal> but in some sense, [a | x <- y; z <- t; u] is equivalent to do x <- y; z <- t; guard u; return a
16:53:40 <djahandarie> Into the list monad
16:53:46 <djahandarie> Yeah
16:54:08 <monoidal> long time ago, comprehensions worked for any monad, not just []
16:54:11 <benmachine> monoidal: in some sense? in the sense that, they're the same thing, you mean? :P
16:54:17 <monoidal> yes
16:54:27 <benmachine> ah, that sense
16:54:35 <benmachine> (although the semicolons should be commas >_>)
16:54:40 <benmachine> (in the listcomp)
16:54:43 <monoidal> whoops, right
16:55:03 <ddarius> "long time ago" = ~12 years
16:55:10 <benmachine> that is ages
16:55:13 <chrisdone> that's a long time in cs
16:55:18 <benmachine> nearly two-thirds of my life :x
16:55:32 <chrisdone> in internet years that's about 2500 years
16:55:37 <benmachine> heheh
16:55:47 <djahandarie> Exactly 2/3s of my life :P
16:55:58 <chrisdone> i always knew you were an old git
16:56:06 * benmachine version control joke
16:56:32 <ddarius> The kids are multiplying.
16:57:06 <djahandarie> I think that's how things work
16:57:18 <ddarius> Not forever.  Not forever.
16:57:58 <benmachine> fix . (>>)
16:59:00 <djahandarie> So yeah, I'm not entirely sure about how I should do this "plug-stuff-in" sort of stuff. How would you make an extra piece of code affect the evaluation of some other code but also be optional?
16:59:19 * benmachine blinks
16:59:29 <ddarius> By making it not optional, but providing a "do nothing" operation by defaulht.
16:59:49 <benmachine> I think "affect the evaluation of" is quite a vague idea
17:00:11 <djahandarie> Well I only have a vague idea of what I'm trying to do.
17:00:32 <Cale> ddarius is right. This is what id/return/etc. are for :)
17:00:32 <benmachine> are you talking about plugins loaded at runtime? or compiled in?
17:00:55 <benmachine> or maybe I'm reading too much into you using "plug-stuff-in"
17:00:56 <djahandarie> I specifically want to be able to load in an extra module which will automatically add in some extra logic to another function
17:01:04 <benmachine> automatically :OP
17:01:06 <benmachine> *:O
17:01:06 <djahandarie> Well, at runtime would be nice, not neccessary though
17:01:09 <benmachine> that sounds dangerous
17:01:19 <benmachine> runtime is scary and involves hint and stuff
17:01:27 <benmachine> or dlopen?
17:01:27 <djahandarie> I'm already using hint elsewhere
17:01:31 <benmachine> oh
17:01:31 <mauke> can you do IO in TH?
17:01:33 <Cale> djahandarie: hint is good, yeah
17:01:46 <benmachine> mauke: I think there's a runIO
17:01:51 <benmachine> mauke: that makes IO a into Q a
17:02:08 <benmachine> :t Language.Haskell.TH.runIO
17:02:09 <lambdabot> forall a. IO a -> Language.Haskell.TH.Syntax.Q a
17:02:17 <djahandarie> I have hardly touched template haskell. I haven't felt like I have needed it ever
17:02:30 <benmachine> it's cute :P
17:02:42 <Cale> djahandarie: If it's worth doing once, it's usually worth doing multiple times. Think about how you'd handle multiple modules of that sort, and the zero case will fall out as a consequence.
17:02:44 <djahandarie> Seems like it adds an unneeded layer of complexity to things
17:02:58 <Cale> djahandarie: TH? That's usually true.
17:03:09 <Cale> There are some things which TH is really good for though.
17:03:21 <benmachine> I like TH-printf
17:03:27 <benmachine> but that's probably an example of overkill
17:03:27 <djahandarie> Cale, my main problem is that I don't even know where to start.
17:03:42 <djahandarie> hint can interpret an expression
17:03:42 <Cale> djahandarie: What do you want to do?
17:04:06 <djahandarie> "I specifically want to be able to load in an extra module which will automatically add in some extra logic to another function"
17:04:36 <djahandarie> I guess automatically is not the correct word to use there
17:04:49 <Cale> djahandarie: Yeah, hint can evaluate an expression whose result is an arbitrary Typeable type.
17:05:14 <Cale> djahandarie: Which includes almost anything that isn't too polymorphic or otherwise fancy.
17:05:25 <mauke> oh, TH can't generate imports :/
17:05:30 <Cale> So, for instance, IO actions are Typeable, and functions.
17:05:46 <benmachine> mauke: ouch, really?
17:06:01 <ddarius> mauke: Whatchya need imports for?  Just inline the entire file.  You can query Hackage while compiling your code.
17:06:07 <benmachine> hahaha
17:06:24 * benmachine notices there are constructors for foreign imports
17:06:25 <deech> Can someone suggest any other JSON parsing libs?
17:06:25 <mauke> ddarius: how do I inline a file?
17:06:44 <benmachine> mauke: runIO readFile and then... dunno
17:06:49 <mauke> exactly
17:06:51 <ddarius> mauke: Read it in, parse it into AST, and splice it.
17:07:09 <mauke> ddarius: what if that file contains imports?
17:07:18 <kmc> djahandarie, as an alternative, you could use "dyre" and do plugins statically with ordinary imports
17:07:26 <benmachine> mauke: parse them, follow them, inline them :P
17:07:29 <sw17ch> does any one remember the name of the package which will pretty print the default Show instance?
17:07:30 <djahandarie> I'm currently using dyre for configuration
17:07:33 <kmc> or even don't use dyre, that's just an extra layer of niceness
17:07:34 <mauke> benmachine: ... Prelude?
17:07:47 <benmachine> mauke: well, you'll already have that one!
17:07:50 <benmachine> so no problem
17:07:53 <benmachine> no problem at all.
17:07:54 <kmc> djahandarie, can't a plugin just be a value of some particular record type?
17:07:59 <kmc> presuming you don't need dynamic loading
17:08:17 <kmc> what you want sounds vaguely aspect-oriented
17:08:31 <kmc> you want certain functions to have "holes" where other plugins can insert stuff
17:08:39 <djahandarie> Yes, exactly
17:08:40 <kmc> but i think this is pretty easily done with a simple encoding of plugins
17:08:52 <kmc> that doesn't require hint, TH, or any other fancy stuffs
17:08:57 <kmc> @quote majesty
17:08:57 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
17:09:18 <djahandarie> kmc, well, if I wanted to load it in dynamicly it would, but I suppose I can add that in afterwards
17:09:31 <kmc> yeah, that's a pretty separate issue
17:09:39 <kmc> because you could use "hint" to load one of these records
17:10:00 <djahandarie> Hm. I still don't understand how to do the core issue of "plugging it in" though
17:10:04 <kmc> so i'm picturing like
17:10:20 <kmc> data Plugin = Plugin { onConnect :: IO (), onPrivmsg :: String -> IO (), ... }
17:10:29 <mauke> preflex has a global list of plugin records
17:10:33 <kmc> then you launch the system with a [Plugin]
17:10:45 <kmc> btw, i think fastirc works like this
17:10:45 <djahandarie> Oh
17:10:46 <anyone> The thing that disappoints me the most about TH, is that it adds to the mental parsing I have to do, without adding to the parsing I can make the computer do. :\
17:10:49 <djahandarie> That makes it really simple
17:12:09 <kmc> djahandarie, look at Network.FastIRC.Session from fastirc also
17:13:04 <djahandarie> Yeah I'm looking at that now, although hackage is moving quite slow at the moment
17:13:49 <djahandarie> And it seems like much of what I'm trying to do is already accomplished by that package
17:13:52 <kmc> there's also plain old "irc"
17:14:01 <djahandarie> irc is what I'm currently using for parsing
17:14:02 <kmc> smaller in scope
17:14:03 <kmc> yeah
17:14:24 <kmc> i don't think fastirc handles plugins in the sense you want
17:14:26 <kmc> but it shouldn't be hard
17:14:36 <kmc> to read a list of type [Plugin] as mentioned above
17:14:40 <kmc> and to add all the requisite handlers
17:14:52 <djahandarie> Yeah, that made it seem really easy, dunno why I hadn't thought of that
17:15:12 <kmc> djahandarie, it's a common pattern
17:15:30 <kmc> people expect to need fancy machinery to manipulate behaviors dynamically
17:15:42 <kmc> when usually it boils down to first-class functions or actions
17:15:56 <djahandarie> Hey, I wasn't the one making assumptions here :P
17:16:06 <kmc> i'm speaking generally ;P
17:16:25 <benmachine> when you make assumptions, you make an ass out of you and umm
17:16:54 <lispy> benmachine: you and umption actually
17:17:00 <lispy> poor umption
17:17:06 <benmachine> well, surely mption
17:17:14 <kmc> so has anyone done work specifically on AOP in Haskell
17:17:14 <benmachine> the u is already consumed
17:17:18 <kmc> i guess She has a little thing for it
17:17:24 <kmc> and UHC is written in that style
17:18:02 <kmc> there was that paper on extensible compilers with attribute grammar that went pretty far over my head
17:18:50 <kmc> i guess i should read about attribute grammars by themselves, i see there's a TMR article
17:21:56 <djahandarie> Hm, I kind of like this fastirc thing
17:22:01 <djahandarie> Maybe I'll rewrite what I have so far
17:24:14 <jre2> Cale: good generic advice wrt the zero case often falling out once you figure out how to do multiple
17:25:26 <jbapple> And now the community server is down!
17:27:01 <jbapple> ok, it's back up
17:27:17 <jbapple> which machine hosts trac.haskell.org?
17:27:34 <jbapple> it's really crawling for me right now
17:27:46 <djahandarie> Hackage is going quite slow as well
17:29:07 <Cale> jre2: thanks :)
17:34:46 <mreh> have we got a nice wrapper so I can openGL without naffing around with callbacks
17:34:54 <mreh> HGL seems to manage it
17:35:00 <solidsnack> I read about an "overloaded do-notation" a while back, that would support working with any `>>=' in scope.
17:35:08 <solidsnack> Is this part of the language these days?
17:35:40 <benmachine> solidsnack: it's a GHC extension I think
17:35:49 <benmachine> it comes for free with NoImplicitPrelude
17:37:18 <BMeph> What if your definition of '>>=' has a different type (Restricted Monads, anyone)?
17:37:49 <benmachine> I think NoImplicitPrelude says "make no assumptions"
17:37:57 <solidsnack> BMeph: That's what I was thinking, yeah...
17:38:07 <benmachine> you can have fromInteger typed as Integer -> Bool -> () -> Mu Maybe
17:38:31 <benmachine> if that suits you somehow
17:40:11 <RyanT5000> you might not be able to produce a well-typed do expression of more than one statement if your type doesn't have the right number of arguments
17:40:22 <benmachine> it'd be tricky yeah
17:40:48 <RyanT5000> it'd be nice to at least have some supertypes to Monad
17:40:54 <kmc> heh, Mu Maybe
17:41:06 <kmc> peano numbers?
17:41:45 <BMeph> That's something that reminds me of something I should check is in Haskell 2 - Naturals!
17:41:57 <kmc> there's a Haskell 2 now?
17:42:06 * soupdragon is desinging a language called Haskell'
17:42:14 <benmachine> soupdragon: deja vu?
17:42:35 <benmachine> or er, deja ecoute or deja lit possibly
17:42:37 <kmc> i'm partial to presque vu myself
17:42:46 <benmachine> it's been a long time since GCSE french :(
17:43:18 <BMeph> I believe "Haskell 2" is the generic name for "if you could change Haskell in a way that made it better (in your eyes), what would you do?"
17:43:55 <kmc> Haskell 9000
17:44:05 <Olathe> We need it to be over 9000.
17:44:10 <kmc> i think Haskell' is used for that as well
17:44:26 <kmc> since there will never be a language released as Haskell'
17:44:47 <systemfault> What's wrong with "Haskell Prime"?
17:44:59 <Makoryu> BMeph: FWIW, Habit (a kernel/driver variant of Haskell) has a lot of nice changes
17:46:26 <BMeph> Makoryu: Yes, it's on my "short stack" of things to peruse... :)
17:46:27 <ddarius> Olathe: No, we don't.
17:46:39 <Olathe> !seen intoverflow
17:46:50 <Olathe> > 5
17:46:51 <lambdabot>   5
17:46:58 <Olathe> @seen intoverflow
17:46:58 <lambdabot> Unknown command, try @list
17:47:03 <Olathe> :\
17:48:36 * zygoloid hugs lambdabot 
17:48:42 <zygoloid> @vixen welcome back
17:48:42 <lambdabot> so, what do you think of me?
17:48:44 <jbapple> Olathe: try asking preflex
17:48:53 <jbapple> preflex, seen intoverflow
17:48:53 <preflex>  intoverflow was last seen on #haskell 1 year, 118 days, 2 hours, 31 minutes and 7 seconds ago, saying: yeah, the link works
17:49:19 <jbapple> Also, seen is helpfully still on the lambdabot list
17:49:48 * hackagebot ieee 0.6.1 - Approximate comparisons for IEEE floating point numbers  http://hackage.haskell.org/package/ieee-0.6.1 (PatrickPerry)
17:50:49 <Olathe> Ahh, thanks
17:52:23 <jbapple> @list
17:52:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:53:07 <jbapple> Does anyone know who operates the lambdabot that is active on this channel?
17:53:42 <mauke> I thought it was Cale
17:53:47 <ddarius> It is Cale.
17:53:52 <Cale> yes
17:53:57 <Stinger> for some reason my cabalized version of gtk2hs doesn't have Graphics.UI.Gtk.Glade, and neither did an installer version for 6.10 I had installed before. Anyone know anything about this?
17:54:11 <Stinger> on windows btw
17:55:25 <dcoutts> Stinger: cabal install glade
17:55:43 <Stinger> that easy huh, heh
17:55:57 <dcoutts> Stinger: as for the 6.10 one, you were likely using my minimal build that did not include the non-core packages
17:56:07 <Stinger> yes I beleive it was
17:57:02 <dancor> does habit have lazy-evaluation or any GC?
17:58:28 <zachk> dancor: whats habit?
17:58:46 <dancor> http://docs.google.com/viewer?a=v&q=cache:x-dxYVptWGEJ:hasp.cs.pdx.edu/habit-report-Aug2009.pdf+habit+language+haskell&hl=en&gl=us&pid=bl&srcid=ADGEESjBDAQBLJFsZZMFhorXnvHMb_7AI67WZkWX0o4_eGiEvyg-xGPQ4Nf4GTDQ_Kob47xrwZQkReYdKocDY4-ctwJ8O4KxJuaEhO8h2zKcFMHF12QWQp-eDfRBSRbkO_2zZGgnsoda&sig=AHIEtbS8s9MQYBSO8vVZPjCqWuNE2-M7YA
18:01:24 <deech> Hi all, I am having some trouble understanding how the runGetJSON method (http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON-String.html) works. Any help is appreciated.
18:02:52 <ezyang> deech: It looks like json has multiple implementations for JSON parsers
18:03:03 <ezyang> so runGetJSON lets you actually "run" different ones
18:03:25 <deech> ezyang: yes, I need to use the readJSObject function, but I am having trouble extracting the result.
18:03:34 <ezyang> So if you do, like, runGetJSON readJSTopType "{'a'...}" etc
18:03:45 <ezyang> deech: Ah. Do you have Either String a ?
18:04:49 <deech> ezyang: yes, I match up "Right (JSObject x)" on the result. I am trying to convert a JSON object into an a-list using fromJSObject(http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON.html).
18:05:16 <ezyang> deech: Maybe you should post some code and the error you're getting.
18:06:01 <winxordie> newbie question - when would I use something like HaskellDB and when would I just start writing prolog? (I'm new to the database world.)
18:07:20 <m3ga> winxordie: prolog??? don't you mean SQL?
18:07:25 <dancor> winxordie: are you asking reasons that ppl use databases at all?
18:07:30 <deech> coming up
18:08:05 <BMeph> Prolog, SQL, what's the difference? ;)
18:08:12 <Gracenotes> I forget, the syntax for deriving instances from other modules..
18:08:15 <soupdragon> yes
18:08:24 <scott_> I'm trying to install lambdabot using cabal install, and I'm getting errors about tagsoup: http://gist.github.com/421771
18:08:34 <winxordie> SQL *seems* a bit like a subset of prolog. (Don't eat me, I've only taken glimpses of SQL.)
18:08:55 <ezyang> They generally are for different use-cases though
18:09:08 <ezyang> Prolog is, "Here are a bunch of rules, now tell me stuff about it."
18:09:09 <Gracenotes> oh, -XStandaloneDeriving
18:09:17 <ezyang> SQL is, "Here is a rule, apply it to a dataset and give me the results"
18:09:43 <soupdragon> winxordie: they are both based on search
18:10:06 <blackdog> recursion's a lot harder to model in SQL, right?
18:10:07 <soupdragon> winxordie: the main difference is that prolog is based on terms and sql is based on tables
18:10:18 <soupdragon> winxordie: (sort of like how c is based on bits and lisp is based on lists)
18:10:23 <blackdog> anyone else still in google codejam?
18:10:27 * blackdog is unreasonably excited.
18:10:30 <soupdragon> sorry
18:10:32 <soupdragon> don't kill me:p
18:10:34 <gwern> scott_: weird. darcs lambdabot-utils declares its tagsoup dep
18:10:38 <soupdragon> I shoul dhave said  bytes... not bits
18:11:15 <scott_> http://hackage.haskell.org/package/lambdabot-utils
18:11:19 <scott_> That does list tagsoup.
18:11:29 <scott_> But if it needs a certain version, it's not being specific enough.
18:11:48 <scott_> What's it use in darcs?
18:11:48 <winxordie> alrighty, thanks for the responses everyone; this relational database thing makes a bit more sense.
18:12:27 <soupdragon> also both SQL and prolog are used as database
18:12:40 <soupdragon> but it is more rare for people to use SQL for computations
18:12:43 <gwern> looks like tagsoup changed modules names at some point
18:12:45 <soupdragon> mostly it is just database
18:12:49 <soupdragon> but some have done it ;0
18:13:04 <soupdragon> it's a challenge to program in SQL
18:13:13 <scott_> gwern: Do you have an idea of what version of tagsoup I should be using?
18:13:20 <winxordie> soupdragon: any direct benefit from it? I've heard claims of *speed*.
18:13:46 <soupdragon> I am not an expert enough to be able to say things about the efficiency
18:13:52 <gwern> scott_: actually looks like tagsoup has hidden that module, hm
18:14:06 <soupdragon> I just know that there is a lot of scope for optimizations in SQL
18:14:43 <winxordie> soupdragon: gotcha. I'll take a look at it.
18:15:00 <gwern> pfft, it fails on other stuff
18:17:56 * hackagebot lambdabot-utils 4.2.1 - Utility libraries for the advanced IRC bot, Lambdabot  http://hackage.haskell.org/package/lambdabot-utils-4.2.1 (GwernBranwen)
18:18:05 <kmc> so advanced
18:18:41 <scott_> gwern: http://hackage.haskell.org/package/tagsoup-0.6 is the newest version where that module is listed under Modules (so un-hidden I assume)
18:18:45 * gwern flutters hand at scott_. you may kiss the ring
18:18:58 <scott_> O_o
18:19:09 <scott_> Ah
18:19:14 <scott_> I missed that hackagebot line
18:19:32 <scott_> Are you sure you meant >0.6?
18:19:51 * gwern gestures languidly. this audience is at an end
18:19:54 <scott_> hmm
18:20:18 <scott_> Does it consider 0.10 to be >0.6 ?
18:20:27 <scott_> 0.10 is newer
18:20:27 <byorgey> it should
18:20:36 <scott_> And I have 0.10, and lambdabot isn't working with it
18:20:45 <Saizan> he changed the code, i assume?
18:20:59 <scott_> Silly me..
18:21:37 <scott_> Thanks gwern, consider your ring kissed.
18:22:50 <jre2> anyone know if bernie pope lurks on #haskell?
18:23:00 <gwern> jre2: rarely to never AFAIK
18:27:52 <scott_>     Could not find module `System.Posix.Signals':
18:27:53 <scott_>       It is a member of the hidden package `unix-2.4.0.0'.
18:28:07 <scott_> Is this just a missing dependency on lambdabot?
18:29:20 <alexyk> how do you ask lambdadot when a nick was last seen?
18:29:28 <gwern> scott_: lambdabot specifies unix as a dep
18:29:30 <dancor> is the buddha debugger something that we should try to revive
18:29:33 <go|dfish> preflex: seen alexyk
18:29:33 <preflex>  alexyk was last seen on #haskell 13 seconds ago, saying: how do you ask lambdadot when a nick was last seen?
18:29:39 <gwern> alexyk: that was removed; too space intensive or something
18:29:52 <gwern> dancor: I doubt it; work is better spent on the ghci debugger
18:29:54 <scott_> Hmm it does indeed.
18:30:06 <scott_> What exactly is the problem here?
18:30:09 <alexyk> gwern: see, you're proved wrong even before you say it!
18:30:29 <alexyk> preflex: seen copumpkin
18:30:30 <preflex>  copumpkin was last seen on #haskell-blah 3 hours, 37 minutes and 5 seconds ago, saying: oh, fair enough
18:30:41 <gwern> alexyk: preflex is a different box
18:30:42 <ddarius> alexyk: preflex /= lambdabot
18:30:44 <gwern> and bot
18:30:46 <gwern> and program
18:30:54 <dancor> gwern: isn't some of what the ghci debugger is missing supplied by the ideas behind buddha?  are they too disparate to reconcile?
18:31:03 <alexyk> gwern: don't care which, as long as it listens :)
18:31:14 <jbapple> buddha was radically better than the GHCi debugger
18:31:47 <alexyk> there's a guy on clojure who walks a lambdadot there from time to time to entertain the lonely clojurebot.  so they're all lambdabots to me
18:31:47 <jre2> anyone know why some people/language insist on using "reduce" instead of "fold"?
18:31:50 <ddarius> jbapple: You could probably rewrite Buddha to work on modern Haskell code fairly easily nowadays.
18:31:52 <jbapple> It could be used, for instance, to understand the stack trace
18:32:06 <alexyk> jre2: 'cause it's cute
18:32:08 <dancor> i'm reading the buddha paper now
18:32:10 <scott_> gwern: Do you know what I should do to resolve the 'unix' package issue?
18:32:15 <gwern> scott_: not really
18:32:17 <alexyk> python & clojure & R have reduce
18:32:18 <ddarius> I've also always wanted to use Hat but never could for a variety of reasons.
18:32:28 <kmc> "reduce" is arguably a more descriptive name
18:32:33 <alexyk> there's a version for reduce without the init elem in each
18:32:37 <jbapple> ddarius: maybe, with the GHC api
18:32:39 <ddarius> jre2: What's special about "fold"?
18:32:43 <jre2> alexyk: "reduce" implies the output is smaller than the input, which isn't true
18:33:06 <gwern> scott_: I'm not very good at debugging build problems which aren't on my machine
18:33:23 <scott_> I don't know enough of how cabal works. :/
18:33:24 <alexyk> jre2: if I reduce something to rubble, the rubble may occupy more space.  If you reduce somebody to tears, the result is not less than the original!
18:33:31 <jbapple> ddarius: but I might accidentally spend 4 months on it if it turns out to be not that easy
18:33:45 <kmc> there's a rule which says that every FP concept will have at least two names, one used by the FP community and at least one used by others when they've either reinvented the idea by accident, or don't want to admit that it came from FP
18:33:50 <kmc> sometimes there are like seven of the latter
18:33:50 <jre2> alexyk: that's a horrible play on words...
18:33:55 <ezyang> kmc: Haha
18:34:03 <dancor> you aren't very good at reducing ppl to tears if they don't lose some of themselves..
18:34:07 <kmc> and i don't mean to imply that the first name is the best one
18:34:13 <alexyk> jre2: a folded cloth may be thicker than the unfolded one
18:34:25 <kmc> for example "hash consing" and "flyweight pattern" are two awful names for the same concept
18:34:32 <kmc> one used by Lisp weenies and one used by C++ fanboys
18:34:39 <BMeph> 'reduce' also means 'concentrate'. :)
18:35:05 <alexyk> kmc: as opposed to the haskell, um, fastidious perfectionists?
18:35:20 <kmc> alexyk, i believe the preferred term is "zealot"
18:35:37 <alexyk> kmc: that works
18:35:47 <kmc> (my life for Aiur)
18:35:53 <BMeph> Didn't Bird call is 'reduce'? Or, wait - wasn't there also a 'fold' function?
18:36:12 <alexyk> weenies is not fitting for Lisp, nor fanboys for C++;; fanboys are reserved for Apple
18:36:17 <kmc> heh
18:36:23 <kmc> i thought weenies for Lisp was nearly canonical
18:36:42 <kmc> also whenever a Lisp user tells you a better way to do something, he is just being "smug" and you should ignore him
18:36:42 <mauke> only if they're smug!
18:36:44 <alexyk> kmc: have to dig
18:37:18 <alexyk> obviously haskellers can't be smug; I wonder what's their adjective
18:37:35 <gwern> self-righteous
18:37:40 <gwern> we are purer than the masses
18:37:40 <kmc> that works
18:37:43 <alexyk> impenetrable?
18:37:55 <alexyk> immutable?
18:38:12 <BMeph> Inscrutable! ^_^
18:38:26 <alexyk> indented & thunked
18:38:35 <kmc> spineless & tagless
18:38:36 <dancor> academic
18:38:43 <jre2> HOT
18:38:57 <theorbtwo> lazy
18:39:11 <kmc> elitist left-coast ivory-tower academics
18:39:13 * alexyk just bought RWH PDF from OReilly direct.  There's a 3 for 2 books now deal going on.
18:39:23 <kmc> anyway Haskell is the ultimate hipster language
18:39:31 <kmc> it has probably surpassed Ruby at this point
18:39:33 <dancor> lazeratti
18:39:35 <gwern> alexyk: I like the HTML version better. comments
18:39:37 <jre2> theorbtwo: lazy in the most positive sense mind you
18:39:51 <gwern> the Perl sense
18:39:54 <gwern> not very positive
18:39:55 <alexyk> gwern: I like to read in a cafe without the internets
18:40:48 <alexyk> with the departure of copumpkin, I'm the only NH resident here I'm sure, and we have less internet than moose
18:40:50 <gwern> ...and PDF is so much more offline?
18:40:59 <theorbtwo> gwern: The perl sense *is* very positive.
18:41:09 <gwern> nothing perl is very positive
18:41:15 <alexyk> gwern: did you scrape HTML without paying dons a sinlge farthing?
18:41:33 <dancor> pdf is actually worse
18:41:33 <theorbtwo> In any case, I quite understand all the several senses.
18:41:41 <tomberek> howdy
18:41:42 * gwern harrumphs, it's not scraping when you use wget -r
18:41:52 <gwern> and I paid in the cold coin of comments!
18:42:27 <gwern> besides, if anything dons owes me for all the packaging I did back when cabal wasn't popular
18:42:39 <dancor> grab all his blog posts and haskell meetup pix, and .rar it up for rapidshare
18:42:55 <theorbtwo> gwern: True lazyness, in the perl sense, is applied long-term.  It is recognizing that you should have tests, because in the long term, tests help you not have bugs, and make the bugs you do have less annoying to fix.
18:43:06 <alexyk> well, when I saw that pic of dons in a funny hat, I had to pay for his hard work and others'.  You people need to think more of the children of the authors'.
18:43:15 <theorbtwo> False lazyness is not writing tests, because it is more work *right now*.
18:43:21 <kmc> tests are really important if you have a type system that exists to confound the programmer
18:43:26 <gwern> alexyk: I didn't think dons yet had children
18:43:29 <dancor> theorbtwo: do tests pay off in the long run better than correctness proofs?
18:43:40 <gwern> didn't he get married only a little while ago?
18:43:44 <alexyk> gwern: for the future ones then.  Mae a deposit, won't hurt'ya
18:43:48 <alexyk> make
18:43:56 <dancor> i think proofs would have to eventually win but maybe in the very long term
18:43:56 <theorbtwo> dancor: I'm not sure, I haven't played about with correctness proofs much.
18:43:58 <gwern> alexyk: yes it would
18:44:12 <gwern> proofs suck when the desired theorems keep changing on you
18:44:15 <kmc> actual proofs are way more work
18:44:17 <kmc> than tests
18:44:17 <dancor> right
18:44:28 <dancor> but infinitely more effective!
18:44:28 <kmc> but good static types get most of the low-hanging fruit
18:44:29 <deech> ezyang: are you still there? Sorry it took a while.
18:44:37 <alexyk> gwern: you're too sensitive to parting eith cash then.  just let go
18:44:56 <theorbtwo> However, the advantage of tests is that they are, or at least should be, obviously correct.  That is, you should be able to trust that if your test is failing, it is because the code is wrong, and not because the test is wrong.
18:44:59 <alexyk> ...and feel flush with karma
18:45:06 <gwern> alexyk: 'poverty is nothing to be ashamed of, but neither is being wealthy'
18:45:11 <theorbtwo> I'm not sure I'd have that confidence with correctness proofs.
18:45:23 <alexyk> gwern: donate $1!
18:45:40 <gwern> alexyk: at that point, paypal is eatign a good fraction. I don't like paypal
18:45:44 <ddarius> theorbtwo: It is often the case that the tests are wrong.
18:45:53 <jbapple> you need correctness corollaries, then
18:46:13 <jbapple> that prove your tests' correctness are implied by your proofs
18:46:30 <dancor> what if you used a language with optional proofs and then only put as much time into proofs as you would have into tests
18:46:36 <dancor> seems like it would be better but idk
18:46:36 <theorbtwo> ddarius: Well, yes, I suppose... but they tend to at least be obviously wrong.
18:46:57 <dancor> i do far less testing in haskell than e.g. dynamic langs
18:47:07 <dancor> and i would do none in agda
18:47:10 <ddarius> theorbtwo: No, that's not true either, and they are subject to some of the same issues with a formal proof.
18:47:12 <scott_> Can anyone with some cabal experience figure out what is going on here? http://gist.github.com/421803 (Trying to install Lambdabot using cabal install.)
18:47:20 <gwern> beware, I have only proven this code correct...
18:47:22 <alexyk> kmc: if static types get the low-hanging fruit, they are not giraffes.  (that was a short proof of the inequality)
18:47:34 <kmc> heh
18:47:38 <theorbtwo> dancor: OTOH, you have the implied test that your code actually complies, which is saying a fair bit in Haskell, but much less in Perl.
18:47:56 * alexyk wonders if the haskell bug is big enough to get the low-hanging fruit
18:48:03 <kmc> i would still test if writing real-world software in agda
18:48:13 <deech> I have some code up on http://pastebin.com/hCnyP0aJ I was hoping somone could look at. It uses Text.JSON to read a JSON object into an association list.
18:48:34 <kmc> it's easy to write the wrong proposition and prove it
18:48:44 <kmc> relational modeling tools like Alloy are also nice
18:48:57 <kmc> you can describe your constraints and it will generate some examples that satisfy
18:49:00 <dancor> well i guess just bc your functions are total doesn't mean they do what you think
18:49:07 <kmc> and you can look at them and see if they're ridiculous
18:49:27 <kmc> well the idea is to write a total function whose type is your correctness property by curry-howard
18:49:33 <Cale> scott_: Well, that problem is easily fixed (just edit the .cabal file), but I think the lambdabot on hackage is a bit strange. You might try the repo on code.haskell.org instead.
18:49:42 <ezyang> deech: The error message seems pretty spot-on
18:49:43 <kmc> (or a term anyway, it might not be a function)
18:49:53 <theorbtwo> Are there any decent test coverage tools for Haskell, BTW?
18:49:59 <scott_> Cale: Okay, I'll try that repo
18:50:15 <kmc> theorbtwo, there's "hpc"
18:50:22 <kmc> which has been in GHC for a long time
18:50:26 <dancor> kmc: i'm not sure i understand, but isn't there room for error between informal spec and agda implementation?
18:50:33 <kmc> dancor, indeed
18:50:48 <ezyang> You need a fromJSONObject somewhere
18:50:58 <jbapple> kmc: that's called the intrinsic encoding. Sometimes extrinsic encoding is easy http://twelf.plparty.org/wiki/Intrinsic_and_extrinsic_encodings
18:51:06 <dancor> i have another divisive question, why sohuld i learn agda2 instead of epigram
18:51:12 <gwern> 'you cannot proceed from the informal to the formal by formal means' as Perlis said
18:52:04 <jbapple> agda2 is extant, but epigram2 is barely so
18:52:59 * alexyk ponders Cale's slogan: avoid a head at all!
18:56:17 <dancor> is there a best/any-extant functional systems language that supports optional (pref. by-default) formal verification
18:56:43 <dancor> maybe i should ask if there's even a good functional systems language
18:56:55 <jbapple> ATS
18:57:06 <soupdragon> Coq
18:57:28 <jbapple> Has anybody used Coq for systems programming?
18:57:31 <dolio> Dependently typed assembly!
18:57:39 <soupdragon> oh I didn't see 'systems'
18:57:40 <soupdragon> what is that?
18:57:54 <gwern> well, people keep working on typed assembly language...
18:57:54 <soupdragon> there are dependently typed assembly
18:57:55 <jbapple> I guess the ynot people with their RDBMS
18:58:06 <dolio> Yes, I know.
18:58:38 <dolio> I sometimes wonder about the purpose, though.
18:59:08 <bremner> dancor: you know about bitc?
18:59:15 <dolio> Translating high-level languages with fancy types into low-level languages with fancy types seems like it'd be difficult.
18:59:32 <dancor> ATS has a flag for GC?  ::confused::
18:59:38 <dancor> bremner: i heard it was dead?
18:59:59 <bremner> dancor: dunno. I read activity a few months ago.
19:00:01 <jbapple> DTAL won the judge's prize at at ICFP programming competition a few years ago
19:00:01 <dancor> i guess it's back maybe
19:00:06 <dancor> as of Mar '10
19:00:26 <jbapple> the DTAL was compiled from something, Cyclone perhaps
19:00:37 <dolio> Hmm.
19:00:44 <jbapple> I think it is also envisioned for proof-carrying code
19:01:51 <Makoryu> dancor: The creator of BitC worked at MS for a while, and put the whole project on hold while he was there
19:02:49 <jbapple> Are there any machine-checked proofs of bitc code?
19:03:06 <Makoryu> I dunno if there is any BitC code...
19:03:14 <jbapple> frama-C can be used to verify systems code
19:06:14 <Stinger> hmm ok I've installed gtk and glade and now when I build I get a : Loading package glib-0.11.0 ... linking ... : unable to load package `glib-0.11.0'
19:07:27 <dolio> jbapple: I suppose it's not that I don't understand the desire for it, but how feasible will it be to use. I don't want to program in assembly, and translating not just high-level code to low-level code, but proofs about high-level code into proofs about the result of the translation seems hairy.
19:07:49 <shikanai> @pl netpay h = wage h - tax h
19:07:49 <lambdabot> netpay = liftM2 (-) wage tax
19:08:05 <dolio> But I suppose you might not try to preserve everything.
19:08:33 <jbapple> dolio: I think it's mostly for safety properties
19:09:10 <kent37> newbie question: what is $! ? (pointers to the FM welcome...)
19:09:23 <benmachine> @src $!
19:09:23 <lambdabot> f $! x = x `seq` f x
19:09:38 <benmachine> kent37: if you understand seq, that definition should be straightforward
19:09:41 <benmachine> big if, though :)
19:09:48 <Jonno_FTW> @src seq
19:09:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:10:15 <gwern> my understanding was that PCC and TAL were so you could prove basic safety properties (won't eat your computer), and the motivation for binaries at all was to avoid shipping all the source necessary to compile locally (which wuld get you the proofs you wanted)
19:10:17 <shikanai> @pl f n = n/3 + 2
19:10:17 <lambdabot> f = (2 +) . (/ 3)
19:10:19 <gwern> seems kind of silly now
19:10:32 <gwern> even if google tries to revive it with nacl
19:10:43 <kent37> no, I don't understand seq....
19:10:44 <shikanai> @pl f1 n = n^2 + 10
19:10:44 <lambdabot> f1 = (10 +) . (^ 2)
19:11:09 <dolio> kent37: You know how in a lot of languages, when you write f(x), x gets evaluated first?
19:11:20 <kent37> dolio: yes
19:11:24 <dolio> f $! x is like that.
19:11:40 <kent37> so it forces evaluation of an expression?
19:11:54 <byorgey> except it only gets evaluated far enough to tell what the top-level constructor of x is
19:12:01 <byorgey> i.e. 'weak head normal form'
19:12:19 <dolio> kent37: That's a beginner explanation, at least.
19:12:22 <kent37> byorgey: you've lost me
19:12:29 <kent37> beginner explanation is fine
19:12:30 <kent37> thx
19:12:35 <byorgey> ok, sorry =)
19:13:17 <dolio> kent37: byorgey's point is that, if you do 'f $! [1..]', it won't hang forever.
19:13:18 <fryguybob> > 1:undefined `seq` 2
19:13:19 <lambdabot>   2
19:13:38 <dolio> it only checks up to the outermost constructor.
19:14:13 <dolio> > const 5 $! (undefined :: [Int])
19:14:13 <lambdabot>   *Exception: Prelude.undefined
19:14:18 <dolio> > const 5 $! ([1..] :: [Int])
19:14:19 <lambdabot>   5
19:15:01 <benmachine> it forces a little bit of evaluation
19:15:10 <shikanai> @pl areaOfRing outer inner = areaOfDisk outer - areaOfDisk inner
19:15:10 <lambdabot> areaOfRing = (. areaOfDisk) . (-) . areaOfDisk
19:16:17 <gwern> pointless
19:16:20 <kent37> I don't know what "outermost constructor" is. "a little bit of evaluation" is more my speed :-)
19:16:30 <kent37> very newbie
19:17:06 <kent37> thx
19:17:15 <Makoryu> Fffff
19:17:21 <Makoryu> I was just about to give him a good example
19:17:25 <benmachine> me too :P
19:18:02 <gwern> think of it as like a banana...
19:19:05 <Makoryu> I like bananas. Bananas are good.
19:19:16 <Makoryu> Always bring a party to a banana.
19:19:23 <Makoryu> No, wait, that's backwards.
19:19:47 <byorgey> bananas are either empty, or there's some peel and then another banana...
19:19:58 <gwern> and inside is barbed wire and broken glass
19:20:22 <byorgey> the barbed wire is called a bananamorphism
19:21:26 <dolio> And envelopes!
19:21:27 <Makoryu> ♪ Do you want a catamorphism? ♪
19:21:37 <Makoryu> ♪ Peel it down and go fmap fmap fmap fmap ♪
19:24:08 <jbapple> gwern: I had a similar impression about PCC. I was told that the JVM + Moore's law eventually ate its lunch, sinve VMs became fast enough
19:24:51 <gwern> and source code obfuscators reassured Brainless Business Betties
19:25:13 <aavogt> > ((*) `on` g) x y :: Expr -- shikanai
19:25:14 <lambdabot>   g x * g y
19:26:02 <deech> ezyang: thanks a lot for the input! I managed to fix the problem. Appreciate the help.
19:29:01 <Makoryu> :t fmap fmap fmap fmap
19:29:02 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
19:29:15 <benmachine> :t fmap fmap fmap fmap fmap fmap fmap
19:29:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
19:29:23 <soupdragon> does anyone know the projection method for penrose tiles?
19:29:30 <soupdragon> I can't understand it.... I want to program it in haskell though
19:29:46 <soupdragon> I was trying to read De Bruijns paper on it but it's too complicate
19:29:48 <Makoryu> soupdragon: That pretty much sums up my attitude to category theory.
19:30:03 <soupdragon> Makoryu, you want to implement category theory in haskell?
19:30:17 <soupdragon> or just the other bits?
19:30:21 <soupdragon> of what I said
19:31:02 <gwern> 'yes'
19:31:27 <Makoryu> soupdragon: No soap, radio
19:31:31 <jrockway> hah, i took the flamebait: http://news.ycombinator.com/item?id=1396823
19:31:35 <soupdragon> radio ???
19:32:02 <soupdragon> jrockway, Why is Lisp used so little in the industry?
19:32:27 <gwern> soupdragon: suits are allergic to the marijuana shipped with every compiler
19:32:38 <soupdragon> what the fuck has marijuana got to do with tihs
19:32:43 <shikanai> Does anybody know where to learn to do lambdabot's @pl transformations by hand?
19:32:52 <shikanai> I am often amazed at what it does
19:32:56 <shikanai> but have no clue how it got those answers
19:32:59 <uorygl> The Unlambda documentation.  :P
19:32:59 <soupdragon> gwern am I typing something completely opposite to what I think I'm writing?
19:33:11 <gwern> jrockway: it's
19:33:28 <uorygl> http://www.madore.org/~david/programs/unlambda/#lambda_elim teaches the basics of #pl-ing.
19:33:35 <gwern> soupdragon: person: 'do you like emacs or vi?' RMS: 'yes'
19:33:41 <uorygl> Unfortunately, it only uses three combinators.
19:34:00 <uorygl> ap, return and id.
19:34:10 <gwern> jrockway: 'My team can't find any C++ or Java developers, despite offering pretty interesting work and pay that's at the top of the industry. There just aren't very many programmers -- hiring a programmer for any language is hard.' <-- is that really true?
19:34:16 <jrockway> yup
19:34:34 <uorygl> @type ap return
19:34:34 <lambdabot> forall b a. (b -> a) -> b -> b
19:34:38 <uorygl> @type return id
19:34:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
19:34:40 <gwern> but universities graduate tons of java programmers every year
19:34:45 <jrockway> if you know C++ and want to be a team leader for a new project, let me know
19:34:57 <jrockway> (C++ is the existing codebase, the new stuff is probably going to be scala)
19:35:07 <gwern> 'You know what really reached out and poked me in the eye? The "Don Stewart (who failed his PhD)" part.'
19:35:10 <gwern> wait what
19:35:11 * uorygl declares those correct.
19:35:25 <uorygl> dons failed his PhD?
19:35:36 <uorygl> Wait, I think this is hearsayhearsayhearsay.
19:35:48 <soupdragon> pretending that having PhD gives someone credibility?
19:35:52 <jrockway> yeah, who cares?
19:35:59 * gwern ponders. did I ever read dons' thesis? I probably would have if it was ever released
19:36:06 <jrockway> dons is a smart guy who knows how to program and talk about programming
19:36:11 <jrockway> doesn't need a title from a university to do that
19:36:17 <jcreigh> I have a hard time believing that someone as smart and motivated as dons didn't complete his PhD.
19:36:19 <gwern> maybe galois hired him before he finished
19:36:30 <gwern> I could understand him not finishin in that case
19:36:32 <Zao> The dreaded Real World strikes another victim :D
19:36:40 <jcreigh> yeah, I guess that could be
19:36:51 <jrockway> wait, how could that be?  haskell has no use in industry!  it's only for academics!
19:36:54 <jrockway> MY MIND IS BLOWN
19:37:02 <tommd> jcreigh, gwern: Yep, and now Uni has threatened to kick him out if he doesn't finish soon.
19:37:27 <tommd> They did that to a whole bunch of students who wandered off into industry before submitting the thesis.
19:37:32 <gwern> tommd: that's harsh of them. does dons plan to not finish?
19:37:34 <tommd> Gave one guy -2 months as I understand it.
19:37:44 <tommd> No, he will finish.
19:37:59 <gwern> tommd: but he's still at galois?
19:37:59 <p_l> ... what was the funding source?
19:38:05 <jrockway> he can have a phd from the university of jrockway, if he wants
19:38:05 <tommd> Yeah, he's still at Galois.
19:38:30 <p_l> jrockway: it would be probably worthless in most places
19:38:39 <gwern> tommd: is he planning to do both? that doesn't sound like a terrific idea
19:38:47 <tommd> p_l: In Aus the Uni gets 50K for each PhD they legitimately graduate (as I understand it).  So the administration has good motivation to hunt down the students and make sure they actually finish by the deadline.
19:38:59 <jrockway> interesting
19:39:00 <tommd> gwern: I don't think it will be a problem.
19:39:26 <jrockway> when i read an article like the one i was replying to, i ignore all personal attacks
19:39:29 <gwern> tommd: even if it's dons, that's stressful. maybe that explains his irritability over xmonad stuff
19:39:44 <jrockway> i just mentally skip over them because they have no bearing on anything
19:39:51 <jrockway> "let's make fun of someone famous in the community"
19:39:52 <soupdragon> ill tell you a funny sorty
19:39:54 <soupdragon> story*
19:39:57 <p_l> tommd: iirc here (UK) the student has to acquire sponsorship (or pay himself) and it would be up to sponsor to withdraw funds because of missed deadline
19:39:58 <tommd> perhaps, he'll probably read this whole conversation later and rebut that though.
19:39:58 <jrockway> yeah, that will sure prove that the language sucks
19:40:16 <soupdragon> John Harrop posted on comp.lang.functinonal "hey guys I don't understand ML type inference, I just found this haskell implementations which is useless because haskell sucks"
19:40:24 <gwern> tommd: how would he do that? 'I am half-raptor, and neither know fear nor fatigue.'
19:40:48 <soupdragon> (1) ML type inference is trivial stuff
19:40:59 <soupdragon> (2) reading haskell code if you know any programming is easy
19:41:00 <tommd> gwern: Great, now you just gave him the rebuttal.
19:41:24 <soupdragon> he just came across as a whiny dork
19:41:40 <soupdragon> anyone serious about learning this stuff could just pick up a textbook
19:41:41 <tommd> @quote+ gwern 'I am half-raptor, and neither know fear nor fatigue.'
19:41:42 <lambdabot> No quotes match.
19:41:50 <tommd> @remember gwern 'I am half-raptor, and neither know fear nor fatigue.'
19:41:50 <lambdabot> Done.
19:42:10 * gwern thinks the humor is kind of lost sans context
19:42:30 <tommd> perhaps, yes.  I was just thinking I should have added a few words of context.  Oh well.
19:42:53 <jcreigh> never too late to @forget :)
19:43:02 <tommd> @forget gwern 'I am half-raptor, and neither know fear nor fatigue.'
19:43:02 <lambdabot> Done.
19:43:11 <gwern> perhaps rewrite it to 'dons's defense would be ...'
19:43:16 <tommd> @forget lambdacalculus
19:43:16 <lambdabot> Incorrect arguments to quote
19:43:22 <gwern> and come to think of it, transpose neither know
19:43:30 <gwern> it should be 'know neither fear nor fatigue'
19:43:35 <gwern> more euphonious
19:44:38 <tommd> @remember gwern [wrt dons dissertation/defense being due shortly] 'I am half-raptor, and know neither fear nor fatigue.'
19:44:38 <lambdabot> It is forever etched in my memory.
19:46:34 <gwern> @flish
19:48:53 <jrockway> if a raptor was 5 units away from you and running towards you at 5 units per second
19:48:59 <jrockway> how long would haskell be used in industry?
19:49:30 <Jonno_FTW> @faq can haskell solve jrockway's problem?
19:49:30 <lambdabot> The answer is: Yes! Haskell can do that.
19:50:02 <tommd> -10 years?
19:51:02 <tommd> "Haskell used in industry" is kind of like "Linux on the Desktop".  I have no $@%! clue what people mean by either one because in my statistically insignificant experience both have been true for many years.
19:51:24 <dcolish> tommd: is it the year of haskell in industry?
19:51:31 <tommd> @$%%@ off dan!
19:51:31 <lambdabot> Unknown command, try @list
19:51:33 <tommd> ;-)
19:51:35 <dcolish> :)
19:51:57 <dcolish> there should be a parse for that command in lambdabot
19:51:58 <jrockway> hahaha
19:52:02 <benmachine> soupdragon: isn't Jon Harrop the one who sells OCaml consultancy or something and thus has a specific material interest in making haskell look bad?
19:52:03 <jrockway> the year of haskell in industry
19:52:06 <jrockway> i like that a lot
19:52:09 <jrockway> benmachine: C#
19:52:15 <benmachine> close enough
19:52:21 <jrockway> no, that's F#
19:52:22 <jrockway> C# is java
19:52:22 <soupdragon> benmachine, no idea but he came across as a total idiot on that comp.lang.functional thread
19:52:35 <byorgey> I think he used to do OCaml.
19:52:35 <benmachine> soupdragon: mm, sounds like him :P
19:53:05 <benmachine> jrockway: there are two languages, haskell, and wish-it-was-haskell
19:53:17 <Makoryu> byorgey: Yeah, he switched to F# when it proved to have some kind of staying power on .NET
19:53:23 <dcolish> i'm excited to read the slides from dons multicore talk at osbridge
19:53:34 <dcolish> those new libs from intel look pretty awesome
19:53:43 <jrockway> F# is not a bad language for industry
19:53:59 <jrockway> it lets the monkeys feel like they are doing something familiar, and lets the smart people enjoy their work
19:54:17 <jrockway> microsoft is evil though, so fuck it
19:54:38 <jrockway> (i liked F# until i got a windows netbook that informed me i had to pay microsoft $80 to change the desktop background.  WTFFFF)
19:55:04 <tommd> I see why edwardk left ;-)
19:55:09 <tommd> He must own microsoft stock.
19:57:35 <dons> gee.
19:57:37 <dons> harrop eh
19:57:41 <mreh> yampa never seems to use "actuate False b"
19:57:44 <benmachine> hi dons!
19:57:57 <dons> hey guys
19:58:09 <mreh> Hi dons!
19:59:23 <tomberek> hello dons
19:59:24 <dons> dcolish: are the slides up? i sent them into the organizers
19:59:32 <dons> maybe i should put them up first
20:00:20 <dcolish> doesnt appear they are
20:00:29 <wlangstroth> this channel is the greatest
20:00:30 <dons> uploading now
20:00:52 <dcolish> sweet, thanks! i wish i could have seen the talk in person. i had a conflicting class :(
20:01:03 <mreh> > max "Haskell" "The rest of the world"
20:01:05 <lambdabot>   "The rest of the world"
20:01:12 <mreh> no!
20:01:17 <mreh> it isn't true
20:01:23 <gwern> they called me crazy and I called them crazy, and damn them, they outvoted me
20:01:25 <sw17ch> is there a good way to extract specific pieces/patterns of the haskell-src-exts Module type sorta like how uniplate does with universe?
20:01:28 <gwern> as the english playwright said
20:02:17 <dons> gwern, jrockway et al. i've been a part-time grad student for 2 years since working for galois. i'm due to complete in 4 freaking weeks.
20:02:30 <benmachine> good luck :P
20:02:35 <gwern> what's your thesis on anyway? more stream fusion stuff?
20:02:42 <dons> business gets in the way of thesis writeup, but at the moment thesis writeu is winning
20:02:44 <sw17ch> dons: i thought you already had your phd?
20:02:56 <dons> gwern: nope, that's dcoutts_. mine's on type safe dynamic linking
20:03:01 <dons> gwern: hs-plugins et al
20:03:10 <gwern> oh. that's kind of odd
20:03:13 <gwern> are you reviving hs-plugins?
20:03:14 <dons> sw17ch: nope, just finishing up. started at galois before i was done -- my mistake :)
20:03:23 <dons> gwern: possibly after finishing all the writing
20:03:58 <sw17ch> oops :)
20:04:01 <scott_> I'm having a problem with lambdabot on another network... in the same lambdabot process using the same rc file, it will join the default channels on freenode, but not on ninthbit.
20:04:09 <dons> anyway, harrop doesn't know much about a lot of things, but he's sure happy to invent things in his own midn.
20:04:10 <gwern> I suppose that shows how haskell can move fast sometimes. 'hs-plugins? what's that? we use hint these days'
20:04:15 <dons> gwern: hehe
20:04:26 <gwern> 'I remember reading some old papers about it'
20:04:27 <sw17ch> has any one here played with generating functions from a specification?
20:04:29 <dons> gwern: well, the specific details are kind of irrelevant. its the approach
20:04:59 <gwern> mm. I look forward to reading it
20:05:22 <gwern> a grand unified synthesis of typechecking new code, unifiying the ghc api, hs-plugins, and xmonad-style loading
20:05:27 <dons> 'zactly
20:05:49 * gwern was kidding, but if that's what it is, that's cool too
20:05:52 <dons> well, 94 pages in.
20:05:56 <dons> yeah, you got it.
20:06:15 <dons> the entire framework for adding dynamic extension to a statically typed functional language with type erasure semantics
20:07:23 <dons> harrop has no class. ostracism is too good for him.
20:07:50 <gwern> let us cleave the flesh from his bones using oyster shells
20:07:56 <dolio> I didn't realize he downvotes all kinds of articles on the haskell reddit. Why even bother?
20:08:15 <Makoryu> Doesn't he have a botnet for that?
20:08:58 <dons> dolio: its an odd business model for a consultant. garner clients by alienating everyone who'd possibly recommend your work?
20:09:15 <sw17ch> dons, does he have clients?
20:09:19 <gwern> he is not starving in a gutter, so it must work
20:09:27 <dons> unclear, gwern, unclear.
20:09:30 <Makoryu> Or is he?
20:09:51 <gwern> hard to mass downvote lying in a gutter
20:09:51 <FunctorSalad> benmachine, on harrop: but the yield seems pretty drop-in-the-ocean... 1. take down a whole programming language 2. some users convert to your pet language 3. they buy your books ???
20:10:02 <gwern> when you get hungry enough, your hands start shaking too much to type
20:10:13 <FunctorSalad> he could be irrational, of course
20:10:27 <dons> anyway.
20:10:35 <FunctorSalad> (I mean, what's the expectancy of extra book buyers through that chain? 1.3?)
20:11:08 <Makoryu> gwern: I picture him as an eight-foot homeless guy built like an ox on steroids, lurking in the rafters of a Unitarian church with a flock of carrier pigeons and an eeepc
20:11:24 <gwern> Makoryu: that's... actually kind of awesome
20:11:43 <gwern> bad Makoryu!
20:11:56 <Makoryu> If he needs more bandwidth, he climbs into his satanic Ronald McDonald costume (complete with striped cape) and mugs people for their 3G cellphones
20:12:55 <dolio> dons: I just mean, I don't go into the Java reddit (if there is one) and vote all their articles down because I don't like Java.
20:13:10 <dolio> 1) It's not going to have a noticeable effect. 2) I might as well not read the Java reddit.
20:13:38 <dolio> I never see him post in the Haskell reddit.
20:13:39 <dons> hehe
20:13:40 <FunctorSalad> it affects whether others read it
20:13:56 <FunctorSalad> at least on mixed-reddit pages
20:14:20 <FunctorSalad> like the front page..
20:14:21 <dons> slides from today's osbridge talk: http://donsbot.wordpress.com/2010/06/01/open-source-bridge-talk-multicore-haskell-now/
20:14:26 <gwern> > 219 / 3
20:14:26 <lambdabot>   73.0
20:14:56 <dolio> FunctorSalad: I'm not going to personally counteract the opinions of all the Java fans who follow the Java reddit.
20:15:31 <FunctorSalad> dolio: I mean the downvoting will. But I'm not saying that it's a fair thing to do
20:16:12 <dcolish> dons: thanks again
20:16:53 <gwern> all's fair in love and war?
20:17:26 <dolio> FunctorSalad: But the voting won't. I'm one person with a crazy vendetta, vastly outnumbered by people predisposed to enjoying the articles in question.
20:17:42 <FunctorSalad> is there any good reason why lowercase is ok in filenames of main modules but underscore isn't?
20:17:52 <dolio> Unless I have a bot net or something.
20:17:54 <FunctorSalad> (modules without any `module' decl)
20:18:24 <FunctorSalad> dolio: how does it matter that you're outnumbered? it is some positive (to you) effect, however small
20:18:38 <FunctorSalad> but I wouldn't do it
20:18:52 <FunctorSalad> just saying it's rational if you're at war with java and the downvoting was free
20:18:54 <dolio> Because what's the difference between +27 and +28?
20:19:00 <FunctorSalad> 1
20:19:56 <FunctorSalad> it's the difference that makes that java posting appear in front of that COBOL posting on someone's frontpage
20:20:06 <FunctorSalad> you can imagine the rest
20:21:25 <FunctorSalad> the point is the automatical ordering here, not how +27 feels compared to +28
20:21:49 <FunctorSalad> (but even that would be a tiny tiny effect)
20:22:46 <gwern> every so often I use an emacs macro, and I think, 'actually this is pretty damn neat. when did it stop being so impressive?'
20:26:27 <FunctorSalad> gwern: "I can not put my finger on it now, the child has grown, the dream is gone"?
20:27:12 <FunctorSalad> or I'm misparsing your sentence
20:27:40 <FunctorSalad> you're saying emacs macros aren't impressing you as much as they used to?
20:28:58 <gwern> FunctorSalad: you had it imprimis
20:31:35 <FunctorSalad> gwern: OTOH, maybe we're just impressed by more advanced things now...
20:31:57 <FunctorSalad> (like bacon?)
20:32:02 <gwern> no
20:32:18 <edwardk> hrmm i need a name for an infinitesimal that isn't ;)
20:32:29 <edwardk> i.e. one where the infinitesimal is always 0
20:32:40 <edwardk> (as arises in standard analysis)
20:32:41 <soupdragon> zero
20:32:48 <edwardk> soupdragon: how, boring ;)
20:33:20 <FunctorSalad> and what does zero have to do with standard analysis?
20:33:33 <sjanssen> http://www.reddit.com/user/jdh30/disliked/
20:33:33 <FunctorSalad> there's no infinitesimal real, sure...
20:33:56 <edwardk> http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/
20:33:57 <FunctorSalad> but it's sequences that converge to 0..
20:34:49 <edwardk> i'm modeling a bunch of different AD modes as different instances of an infinitesimal typeclass so i can parameterize over them.
20:34:59 * BMeph always wondered how an article had "83 up votes / 1 down vote"...now I know why. >;)
20:35:09 <soupdragon> lol
20:35:13 <dons> BMeph: now you know why.
20:35:21 <FunctorSalad> infinitesimals don't exist in the epsilon-delta framework, nothing ideological about it
20:35:24 <edwardk> jdh30 = harrop?
20:35:29 <FunctorSalad> just staying consistent in your logic.
20:35:33 <sjanssen> dons posts are a strict subset of jdh30's dislikes, I bet
20:35:37 <dons> hehe
20:36:13 <edwardk> -1825 comment karma, he's well loved
20:36:15 <FunctorSalad> [not as real numbers]
20:36:20 <dolio> You mean he actually downvotes everything dons posts?
20:36:25 <jrockway> his dislikes list makes for good reading
20:36:27 <dolio> I suppose that would explain the haskell reddit ones.
20:36:29 <FunctorSalad> of course you can rigorously define tangential vectors etc etc
20:36:31 <jrockway> it's like anti-crowd-sourcing
20:36:33 <c_wraith> jrockway, I was just thinking that
20:37:24 <jrockway> and his troll article got killed on HN
20:37:26 <dolio> FunctorSalad: Now that I can understand, because downvoting everything dons posts probably has a noticeable negative karma effect.
20:37:27 <sjanssen> dolio: I saw one from the xmonad reddit, I think he would have gone out of his way to find and downvote that one
20:37:29 <jrockway> now nobody will see my rant :(
20:37:35 <sjanssen> jrockway: troll article?
20:37:37 <edwardk> thats ok, overall importance of a reddit factors in both up and downvotes, figuring that if nobody downvotes then its just a lovefest anyways, so harrop is doing you a favor
20:37:55 <FunctorSalad> dolio: you lost the connection before my msg'es I think
20:38:09 <dolio> FunctorSalad: Last thing I saw was 1.
20:38:15 <FunctorSalad> it's the difference that makes that java posting appear in front of that COBOL posting on someone's frontpage
20:38:20 <FunctorSalad> (repeated)
20:38:22 <jrockway> sjanssen: the one at the top here http://flyingfrogblog.blogspot.com/
20:38:25 <edwardk> FunctorSalad: yes, i realize that, however in an intuitionistic framework you can't use the usual trick to disprove their existence
20:38:31 <dons> don't link to his trash
20:38:37 <dolio> FunctorSalad: 1 point will do that?
20:38:41 <jrockway> not worth reading, unless you are trying to get over an episode of low blood pressure
20:38:47 <FunctorSalad> dolio: with some probability, of course
20:38:56 <dolio> I suppose.
20:38:58 <FunctorSalad> on a page ordered by points
20:39:01 <edwardk> FunctorSalad: hence why i was leaning debating between Zero or Classical as a way of saying that it was an instance of infinitesimal that was always 0 ;)
20:39:12 <FunctorSalad> (the actual algorithm takes time into account too)
20:39:16 <dolio> I'm not really up on how reddit agregates stuff from other areas.
20:39:18 <jrockway> i did learn something interesting from that article
20:39:36 <jrockway> it could be fun to make up my own fictional world, and then write about it in the real world, as though it was based on actual facts
20:39:54 <jcreigh> jrockway: it's called "journalism"
20:40:16 <dons> he seems to have comprehension problems. he thought wadler worked at galois, because wadler had a site of experience reports, including one from galois. he though bluespec clients were online commenters on some 3rd party site.
20:40:30 <dons> and repeated this stuff for years
20:40:37 <jrockway> and he apparently knows everyone in the financial industry using haskell
20:40:56 <dons> nah, just Heffalump i think. they met at a bar once.
20:41:05 <dons> the rest he's making up
20:41:07 <edwardk> ok, i'm going to stop reading harrop's trolling and go code to lower my bloodpressure
20:41:14 <jrockway> haha
20:41:18 <jrockway> his next article is also hilarious
20:41:27 <jrockway> "i wrote a bad implementation of heap sort in haskell, and it breaks"
20:41:29 <edwardk> damn you jrockway i was almost free ;)
20:41:32 <jrockway> it's really just wonderful
20:41:48 <jrockway> it's a great satirical outlook on programming blogs
20:42:06 <soupdragon> dons, yeah maybe he is dyslexic ? or something
20:42:09 <c_wraith> link to that one, plz? :)
20:42:11 <dons> jrockway: fyi, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25826
20:42:30 <jbapple> The heap post he made seemed to my free of bizarrre assertions or obvious outright fabrications
20:42:53 <jrockway> wait, it works if you do it right? what a concept? ;)
20:43:08 <jbapple> I actually tested his "heapsort a bunch of doubles" on some Haskell heaps
20:43:13 <sjanssen> jbapple: his Haskell code does have a novice flaw in it, though: foldr where there should be a foldl'
20:43:14 <edwardk> meh, who gives a flying frog ;)
20:43:28 <dons> well, if you actually write in haskell, instead of stupid.
20:44:02 <dons> when i ran it, and it was 5x faster than what he claimed, i just closed the tab and walked away.
20:44:07 <jbapple> yes, I think laziness is the culprit, but it seems like a legit mistake that a person would make
20:44:17 <sjanssen> s/person/Haskell novice
20:44:26 <jbapple> don't be too hasty
20:44:29 <dons> this guy gets zero sympathy points.
20:44:37 <edwardk> i stopped presuming his mistakes were legit a long time ago
20:44:41 <jrockway> i'm confused as to how this helps his business
20:44:47 <jrockway> "i hate stuff"
20:44:49 <jrockway> ok, great?
20:44:53 <jbapple> For instance, I rarely write code that deals with huge data sets, so it is a mistake I might make
20:44:57 <c_wraith> people who use languages other than F# hurt his business
20:45:01 <sjanssen> foldr vs. foldl' comes within the first 3 weeks of learning Haskell for just about everybody
20:45:02 <jbapple> But I am not a total Haskell noob
20:45:09 <jbapple> sjanssen: I disagree strongly
20:45:26 <dons> well, he dropped the consulting business -- no one would hire this guy. recently he's aiming to sell fewer books at even higher prices. maybe you can live on that.
20:45:43 <jbapple> It might come in the first three weeks of learning Haskell if you're focused on performance, like he is
20:45:46 <sw17ch> his book prices shock me
20:45:49 <soupdragon> maybe he has some kind of mental health issues?
20:45:56 <dons> c_wraith: don't taint the F# guys. he's ostracized there as well.
20:45:56 <soupdragon> like anger problems or something
20:46:08 <Associat0r> dons: that's not true
20:46:19 <soupdragon> and he just discovered haskell on a really bad day
20:46:20 <c_wraith> dons, fair point.  I shall not assume he's representative of any F# community
20:46:27 <dons> Associat0r: well, talking to MSR folk.
20:46:32 <soupdragon> and it's like um, a bad first impression -- you know what I mean?
20:46:39 <jbapple> I think, for many programmers, especially Haskell programmers, on small projects, huge data sets are not the priority
20:47:00 <jbapple> Additionally Louis Wasserman's pqueue package also stack overflows
20:47:13 <soupdragon> FWIW I still don't see the reason for F# to exist, why couldn't they just use ocaml or haskell?
20:47:13 <jbapple> And he's no Haskell noob
20:47:32 <Makoryu> soupdragon: It *is* OCaml, more or less. But on .NET.
20:47:34 <Associat0r> soupdragon: many reasons
20:47:38 <c_wraith> soupdragon, well, Haskell's type system doesn't fit well into .NET
20:47:41 <soupdragon> yeah but why not just actually use Ocaml
20:47:44 <jbapple> I tested pqueue, edwardk's heaps, and my coq-derived heaps
20:47:47 <dons> anyway. there's zero value in talking about this guy. he's been doing this for years and years to all sorts of communities
20:47:48 <soupdragon> rather than a language which is essentially the same
20:47:48 <Makoryu> soupdragon: It's been a good influence on C#
20:47:57 <gwern> jbapple: they all overflow? that's an issue. they should fix that
20:47:59 <edwardk> jbapple: how bad were my heaps btw? =)
20:48:06 <Associat0r> op overloading, structs, unboxed floats, unsigned types
20:48:07 <jbapple> no, some do not overflow
20:48:13 <jrockway> if F# became the de-facto enterprise language, the world would not be a bad place
20:48:16 <jrockway> same with scala
20:48:19 <blackdog> heh. apparently, don generates enormous quantities of contentless propaganda
20:48:20 <sjanssen> in my opinion, stack overflowing is tantamount to a correctness issue rather than just a performance issue
20:48:21 <jrockway> not as good as haskell, but better than java :)
20:48:28 <jbapple> the strict coq heaps and edwardk's don't overflow
20:48:30 <blackdog> hiya, pot. got this friend i'd like you to meet
20:48:40 <jbapple> wasserman's and the lazy coq heaps do stack overflow
20:48:41 <edwardk> woot, i avoided the newbie mistake!
20:48:45 <edwardk> doh
20:49:22 <edwardk> they just forgot to add bang patterns appropriately?
20:50:11 <jbapple> It may not be worth talking about Harrop's crazy assertions like "Dons is well known as an evil scientist" and "OCaml has no showstopper bugs", but I think it is worth talking about any legit performance problems he points out
20:50:20 <jbapple> including hash tables and stack-overflowing heaps
20:50:26 <alexyk> how do you convert Integer to Int?
20:50:40 <Cale> alexyk: fromIntegral or fromInteger
20:50:40 <sjanssen> alexyk: fromInteger
20:50:47 <alexyk> thx
20:51:06 <jbapple> BTW, to further emphasize that this is not anoob mistake, in the heap thread on haskell-libraries a month or two ago, Simon M suggested NOT making the heaps strict in order to make ||ization work
20:51:23 <edwardk> jbapple: the problem comes down to the signal to noise ratio for me.
20:51:32 <Cale> alexyk: fromIntegral has the nice property of being the answer to almost all questions about how to convert from one sort of number to another (with the remainder pretty much covered by realToFrac and round/floor/ceiling/truncate)
20:51:32 <jbapple> and Simon M is *definitely* not a Haskell noob
20:51:57 <jbapple> edwardk: no doubt. I have seen jdh30 make some bizarre assertions
20:52:03 <sjanssen> jbapple: the issue isn't the strictness of the heap structure.  The issue is that a right fold was used when a left fold was the appropriate choice
20:52:06 <alexyk> I've tried: fromList . zip $ (ks vs) -- wrong; fromList (zip ks vs) -- works; why doesn't the first form work?
20:52:15 <jbapple> BTW, dons, in what way is he ostracized from the F# community?
20:52:17 <Associat0r> jbapple: he talked about plentyof OCaml issues
20:52:31 <Cale> alexyk: (ks vs) means apply the function ks to the value vs
20:52:40 <tomberek> hi Cale
20:52:40 <jbapple> sjanssen: I disagree. I used foldl' in my testing code and Wasserman's heap still overflowed
20:52:41 <sjanssen> jbapple: and Simon is probably right, lazy branches are probably faster
20:52:42 <dons> sjanssen, yeah, fold' is all that's needed. and -O2 -funbox-strict-fields reduces the time 5x what he quotes. so its bad science :)
20:52:44 <Cale> tomberek: hello
20:52:47 <alexyk> sorry, I meant fromList . zip $ ks vs -- no go
20:52:53 <Cale> alexyk: same thing
20:52:54 <dons> jbapple: !Int in the data type.
20:53:05 <alexyk> ah!
20:53:09 <dons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25826
20:53:09 <sjanssen> jbapple: you've got some other bug then, I'm not sure what it might be
20:53:15 <dons> jbapple: ^
20:53:17 <Cale> alexyk: $ has low precedence, so that expression means the same as (fromList . zip) $ (ks vs)
20:53:17 <alexyk> so . ... $ x syntax is for single x only?
20:53:24 <jbapple> dons: Sorry, what is the !Int about?
20:53:33 <dons> oh, Wasserman. wrong code.
20:53:34 <jbapple> sjanssen: How do you know?
20:53:36 <Cale> alexyk: Yeah, sort of.
20:53:39 <alexyk> kk
20:53:57 <tomberek> is there a standard name for newtype Foo a b c = Foo (a b)
20:54:00 <Cale> alexyk: f $ x is the same as f x, but $ has the lowest possible precedence
20:54:05 <dons> tomberek: hmm. no
20:54:21 <jbapple> sjanssen: Especially when edwardk's code and the coq-derived code (when made strict) both don't overflow?
20:54:24 <sjanssen> jbapple: it is true that debugging space and stack leaks in Haskell is a bit of a black art.  But the issue with Harrop's code is seriously Haskell 101
20:54:43 <Cale> tomberek: That's kind of a strange type... the c is a phantom?
20:54:52 <tomberek> well, it's like Const
20:54:57 <sjanssen> jbapple: I'm not familiar with any of those packages, so I really don't know
20:55:15 <jbapple> sjanssen: If you don't know, it's probably best not to assert what the bug is :-)
20:55:26 <tomberek> Cale: newtype Const a b = Const a   in Control.Applicative
20:55:37 <Cale> okay
20:55:42 <tomberek> dons: i thought there might be a version from a 2 kind to 3
20:55:58 <Cale> So it's a bit like a lifted version of that, mixed with type application. :)
20:56:04 <tomberek> aye
20:57:12 <jbapple> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25886#a25886
20:57:12 <alexyk> what's the veteran's way to do top-down conversion: http://paste.pocoo.org/show/220893/
20:57:33 <soupdragon> what is top-down conversion?
20:57:52 <jbapple> That is the code I used to test the stack overflows. I hope it is obvious from the comments how to convert to testing the different packages
20:57:54 <tomberek> Cale: and the other way around? newtype Bar a b = Bar (a b b) ?
20:58:01 <edwardk> jbapple: while you were checking correctness did you sneak any benchmarks in?
20:58:02 <edwardk> =)
20:58:03 <glguy> soupdragon: it is what veterans do
20:58:08 <soupdragon> lol
20:58:11 <alexyk> soupdragon: I have a JSON type which is Object | Number, and I know it represents my schema type AdjList.
20:58:39 <alexyk> soupdragon: so I walk it and complain if it's wrong, otherwise convert.  Like top-down parsing.
20:58:41 <jbapple> edwardk: Sorry, checking correctness of what? The coq-based heap implementation?
20:58:47 <scott_> What must I install for the @source command of lambdabot to work?
20:58:52 <edwardk> jbapple: with regards to stack overflows
20:59:02 <alexyk> I'm sure "there's a monad for that"
20:59:14 <edwardk> jbapple: i still need to find a good heap benchmark set
20:59:22 <edwardk> especially one that uses them persistently
20:59:28 <soupdragon> alexyk, nhm
20:59:30 <jbapple> edwardk: I didn't check correctness except for "doesn't stack overflow"
20:59:40 <edwardk> jbapple: fair nuff
20:59:40 <alexyk> nhm?
20:59:43 <soupdragon> so it's a function from JSon -> MyDataType
20:59:43 <soupdragon> ?
20:59:45 <soupdragon> is that correct
20:59:50 <jbapple> edwardp: I did time -p them. Yours was about 1.5x faster than mine, IIRC
20:59:54 <alexyk> soupdragon: yep
20:59:57 <soupdragon> except that it might give an error, so really  Either MyDataType Error
20:59:58 <tomberek> Cale: it's Join... newtype Join p a = Join (p a a)
21:00:07 <jbapple> edwardk: I think another heap package on hackage includes some tests
21:00:12 <alexyk> in fact I already invoked JSONb' decode
21:00:16 <scott_> Hmm, nevermind.
21:00:17 <soupdragon> alexyk, I see what you mean -- this is basiaclly a mini typechecker
21:00:41 <alexyk> soupdragon: yep, and I want to work with Map of Maps of String->Int, not JSON
21:00:43 <jbapple> edwardk: Also, in his proposal to add heaps to the containers package, wasserman mentioned a few packages that had rolled their own heaps
21:00:50 <Cale> alexyk: You might be able to break it into a bunch of simpler combinators of some sort. You could use the Maybe monad, I suppose.
21:01:08 <alexyk> Cale: yeah, I wonder how :)
21:01:42 <tomberek> edwardk: i'm trying that idea where type Shape m :: * -> * and i'm running into kind problems.. i think *->*->* fits better, but ran into other problems down the line
21:02:03 <edwardk> jbapple: i suppose i'll poke around when i get around to using them again. i have a pet project that will run a bit faster with a soft heap, so i'll probably hack around getting those into the heaps package eventually, which should motivate me to benchmark
21:02:19 <alexyk> also, I tried defining functions without parens: j2adj Object o = ... j2adj _ = error ... -- and the thing complained of a different number of arguments.  Now isn't Object o a single constructor?
21:02:52 <Cale> alexyk: j2adj Object o  looks like j2adj applied to two parameters
21:03:27 <Cale> (even though it'd be illegal anyway to pattern match a partially applied data constructor like that)
21:03:30 <jbapple> edwardk: what do you plan to use a soft heap for?
21:03:33 <edwardk> tomberek: depends on your goals i guess, i think Shape m :: * -> * fits the few examples you started with, but if it gets any more complicated you're more or less back where you started with the Shape m :: * -- and just having the lower-kinded isntances
21:03:36 <alexyk> Cale: so do we always match like this in functions, with parens?  but in a case I'd not need it -- j2adj x = case Object o -> ... -- right?
21:03:55 <alexyk> sorry, case x of Object o -> ...
21:03:56 <Cale> j2adj x = case x of Object o -> ...
21:03:59 <Cale> yeah
21:04:24 <edwardk> jbapple: just a minimum spanning tree annotation for a toy graph library really
21:04:29 <Cale> You might need parens on the left side of an -> in a case, if the pattern you're matching is more complicated
21:04:48 <alexyk> so using a nested case is cuter when parens are annoying... hmm
21:05:05 <Cale> alexyk: I wouldn't do it just to avoid a single pair of parens.
21:05:06 <ksf> can I do a running status line with vty?
21:05:13 <ksf> one of those that backspace over themselves
21:05:17 <FunctorSalad> is there getArgs :: IO [ByteString] somewhere?
21:05:20 <jbapple> edwardk: doesn't MST w/ soft heaps need delete or decreaseKey, both of which need an imperative priority queue to beat O(lg n) on the lookup
21:05:35 <Cale> FunctorSalad: fmap BS.pack getArgs
21:05:42 <Cale> er
21:05:47 <edwardk> jbapple: that may be a monkeywrench in the idea ;)
21:05:47 <FunctorSalad> ksf: why not? it has some setCursor function doesn't it?
21:05:49 <Cale> fmap (map BS.pack) getArgs
21:05:58 <FunctorSalad> you could just overwrite the line then
21:06:09 <edwardk> jbapple: i was going to use it as an excuse to learn them ;)
21:06:12 <FunctorSalad> Cale: decode'd be better
21:06:14 <FunctorSalad> (than pack)
21:06:25 <FunctorSalad> pack evilly truncates things iirc
21:06:31 <ksf> ...but it takes a line, too
21:06:31 <Cale> yeah
21:06:36 <ksf> I don't want to go fullscreen
21:06:45 <Cale> Though I'm not sure if the commandline args are even encoded anyway
21:06:49 <FunctorSalad> but this seems like a pointless encode-decode round
21:06:54 <FunctorSalad> err decode-encode
21:07:03 <jbapple> edwardk: I think most of the algorithmically interesting heaps and heap problems are inherently imperative, sadly
21:07:14 <Cale> I suppose they might be.
21:07:21 <FunctorSalad> it'd seem better to never be involved in the encoding business in the first place
21:07:22 <alexyk> is there a shorter way to extract r from Right r, besides x = case rr of {Right r -> r; ...} ?
21:07:34 <alexyk> and any other ADT constructor
21:07:37 <FunctorSalad> (bytes passed, bytestring received)
21:07:42 <edwardk> jbapple: well, theoretically a number of soft heap algorithms still work with just deleteMin (i.e. softheap selection)
21:08:04 <alexyk> I want: x = unRight rr; -- raise error if fails
21:08:10 <alexyk> (in a general way)
21:08:11 <jbapple> edwardk: cool. approxsort, for one, right?
21:08:25 <edwardk> jbapple: that'd be another one
21:08:41 <alexyk> x = UberExtract rr
21:08:59 * alexyk knows he's dreaming
21:09:08 <jbapple> edwardk: oh, I see what you mean now by selection
21:09:21 <Cale> cale@zaphod:~$ cat foo.hs
21:09:22 <Cale> import System.Environment
21:09:22 <Cale> main = mapM_ print =<< getArgs
21:09:22 <Cale> cale@zaphod:~$ ./foo 日本語
21:09:22 <Cale> "\230\151\165\230\156\172\232\170\158"
21:09:28 <Cale> FunctorSalad: ^^
21:10:13 <Cale> FunctorSalad: It appears there's no need to decode anything, the args are a sequence of bytes anyway
21:10:39 <jbapple> edwardk: what else besides approxmedian and approxsort?
21:10:43 <edwardk> i need to adapt some kind of multipass framework for my monoids library though, since i can't make a soft heap selection monoid as it requires multiple passes.
21:11:30 <edwardk> jbapple: not sure, my other candidate was playing with minimum spanning trees to make someone like tomberek here happy, but you dashed those hopes ;)
21:11:34 <jbapple> oh, I see exact selection works, too
21:11:41 <alexyk> Cale: does it mean "Japanese"?
21:11:44 <edwardk> yeah
21:11:46 <Cale> alexyk: yeah
21:11:53 <jbapple> well, I'm not sure about it, so you should doublecheck me
21:11:57 <FunctorSalad> Cale: haha I just tried almost the same thing
21:12:01 * alexyk is glad Google translate works :)
21:12:15 <jbapple> edwardk: You could always put it in the ST monad
21:12:24 <edwardk> i could, but that feels like i'm cheating ;)
21:12:37 <FunctorSalad> I received a length-2 string for "ä" too
21:12:39 <edwardk> and it doesn't play as nicely with other algorithms
21:13:12 <Cale> If you deconstruct it some more, it means "sun origin language", which makes it seem kind of profound.
21:13:26 <FunctorSalad> ok, so simply 'pack<$>getArgs' it is
21:13:50 <FunctorSalad> heh sounds like a name someone *west* of them should give them
21:14:00 <alexbobP> gwern: lisp ships with weed?!?
21:14:03 <alexbobP> where can I get this version?
21:14:11 <Cale> There's traditionally not much to the east of them.
21:14:54 <FunctorSalad> yes but usually you name your own language ;)
21:15:23 <alexyk> Cale: right, if one assumes a random starting point where Earth had begun its rotation after fully forming Japanese isles
21:15:24 <Olathe> @index intersperse
21:15:24 <lambdabot> Data.List
21:15:42 <FunctorSalad> alexyk: there's a largish body of water there to be fair
21:15:44 <FunctorSalad> ;)
21:16:05 <alexyk> FunctorSalad: not if you look kitty-corner to NE!
21:16:10 <Cale> FunctorSalad: Everyone knows that China is the middle country.
21:16:10 <alexyk> or NW
21:16:22 <Cale> 中国
21:16:25 <FunctorSalad> my point was just that Japan isn't west of itself
21:16:50 <alexyk> FunctorSalad: OK, as opposed to horizontal countries, true.
21:17:05 <alexyk> Britain is also a rising country sun then; or the never-setting one.
21:17:14 <alexyk> any vertical country will do.
21:17:37 <alexyk> ...and any horizontal country can claim it's South or North something.
21:17:47 <Cale> 中国 the name for China, is literally 中 (middle, center) 国 (country)
21:18:08 <alexyk> I wonder how Middle Earth translates into Chinese then
21:19:15 <alexyk> ...in a Chinese translation of the Lord of the Rings, e.g.
21:19:55 <FunctorSalad> all this implied 'bs' in bytestring usage is getting boring. I'll call the function 'getBullshitArgs' now
21:20:17 <jrockway> earth is a different character
21:20:17 <monochrom> haha
21:20:27 <alexyk> Cale: ah, so you meant Maybe monad to swallow the _ = error ... equations?
21:20:42 <Cale> alexyk: In any case, if you had a bunch of functions like: object :: JSON -> Maybe (Trie JSON),  array :: JSON -> Maybe [JSON], etc.
21:21:03 <Cale> then you could use do-notation in the Maybe monad to put a chain of them together handily.
21:21:20 <Cale> Another possibility perhaps is to use pattern guards
21:21:41 <alexyk> to have just one j2my function?
21:21:46 <soupdragon> are quasicrystals offtopic
21:21:48 <soupdragon> ?
21:21:48 <Cale> yeah
21:21:51 <soupdragon> I want to code it in haskell
21:21:51 <Cale> soupdragon: no
21:22:07 <soupdragon> Cale - I tried to read De Bruijns paper but it's too hard core
21:22:14 <soupdragon> I need something simpler :(
21:22:38 <Cale> soupdragon: I know very little about quasicrystals myself, except that they're related to nonperiodic tilings
21:23:10 <alexyk> later
21:23:11 <soupdragon> if you have a line y=mx, where m is irrational you can make an aperiodic 1D sequence by projecting it down
21:23:19 <tomberek> soupdragon.. quasicrystals look interesting
21:23:22 <soupdragon> and I think the idea with the penrose stuff is basically a 5D analogue
21:23:30 <soupdragon> tomberek they are really amazing!
21:24:09 <soupdragon> but my problem is that like what do I write in haskell? I don't know the inner workings in detail to actually turn it into a program
21:25:48 <Cale> Seems like you'd need to have a pretty good handle on the geometry of it to write some code.
21:25:49 <tomberek> soupdragon,  they are made of local rules, right?
21:26:03 <djahandarie> Gah, debian repo is failing to update my GHC
21:26:04 <soupdragon> I don't really know
21:26:13 <tomberek> sounds,,,, comonadic? ... someone back me up
21:26:24 <Cale> I happen to know that you can construct Penrose tilings using L-systems
21:26:36 <dons> part 2 of the intel concurrent collections for haskell posts is out, http://news.ycombinator.com/item?id=1397089
21:27:12 <dons> yay intel
21:27:45 <djahandarie> ghc-pkg: /home/darius/.ghc/x86_64-linux-6.12.1/package.conf.d/binary-shared-0.8-00180db675f2ea73ce16a4820071cd80.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
21:27:49 <Cale> tomberek: If you are right about that, you could probably turn it into a PhD.
21:27:55 <tomberek> dons: what does that mean?
21:27:57 <djahandarie> I seem to get that error when doing anything with ghc-pkg
21:28:10 <tomberek> Cale: um.. then maybe i was wrong
21:28:11 <djahandarie> dons, yeah, that was quite cool when I saw they were doing those posts
21:28:41 <Cale> tomberek: I'm just saying that I have no idea if it's true, but it would be interesting to see.
21:28:46 <jbapple> edwardk: maybe you don't need imperative features: http://www.cs.au.dk/~gerth/advising/thesis/claus-andersen.pdf
21:28:52 <soupdragon> tomberek, this one uses local rules http://www.youtube.com/watch?v=ZSVpdk_d63I but I want to implement the other one
21:29:06 <soupdragon> I want to do the 5D version
21:29:26 <tomberek> Cale, general rule = If something I say is too smart, it's probably wrong.
21:29:32 <jbapple> edwardk: pg 18 & 19 seem to inducate that soft heap delete and decreaseKey are not used in the thesis, yet it describes the optimal (on a PM) MST algorithm
21:29:37 <tomberek> soupdragon: there we go! so it's possible
21:29:58 <babusri> dons: Can you tell why the simple Mutuable Vector code is taking so much memory and copying 65M during GC: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25743
21:32:47 <Cale> http://upload.wikimedia.org/wikipedia/commons/5/52/RogerPenroseTileTAMU2010.jpg -- heh, Penrose standing on his tiling.
21:33:15 <tensorpudding> he looks like a nice guy
21:33:20 <edwardk> jbapple: nice. i'll have to take a look when i'm not neck deep in other code ;)
21:33:26 <JoeyA> I saw this in my cheez-its.  Is it a sign?  http://constellationmedia.com/~funsite/pic/lambda-cheezit.jpg
21:33:27 <tomberek> hehe
21:33:28 <soupdragon> Cale that's a really nice pic :)
21:34:39 <edwardk> cale: hah
21:34:43 <JoeyA> Crap, my cheezit lambda is backwards!
21:34:53 <danharaj> I always write my lambdas backwards.
21:35:03 <danharaj> I am in the wrong orientation.
21:35:04 <edwardk> JoeyA: a tasty mistake
21:35:08 <JoeyA> lol
21:35:58 <soupdragon> how can I learn the 5D geometry well enough to program this?
21:36:11 <tommd> danharaj: Just claim it's a special form of dyslexia - such a form actually exists, though I don't think it's specialized to lambdas.
21:36:49 <Cale> JoeyA: perhaps it was meant to be a Y
21:37:29 <edwardk> dysλexia
21:37:58 <Cale> Y cheezit = cheezit (Y cheezit)
21:38:35 <JoeyA> Yes, but it's lowercase!
21:38:51 <JoeyA> See, a normal person would have gone, "Hey look, a y!  *nom nom nom*"
21:39:20 <edwardk> i guess its more dysʎexia i suppose
21:39:44 <Cale> "Hey look, a fixpoint combinator! *contemplates the nature of recursion* *nom nom nom*"
21:39:46 <JoeyA> If it were capital, maybe they would think about the Y combinator :-)
21:39:51 <JoeyA> right
21:40:03 <JoeyA> !quote Cale
21:40:05 <soupdragon> ourborous - philosophy puffs
21:40:23 <JoeyA> bah, didn't work
21:40:28 <soupdragon> @quote Cale
21:40:28 <lambdabot> Cale says: I should write a program which automatically mods down any article containing the word "Agile"
21:40:35 <edwardk> soupdragon: sounds filling
21:41:27 <JoeyA> Amazing how much productivity is lost because of a manufacturing anomaly in one cheez-it!
21:41:48 <tomberek> what's a cheesy morphism? lactomorphism  hardy har har
21:42:03 <JoeyA> The future is gonna be so different now
21:42:03 <soupdragon> yeah that was a cheesy joke too :P
21:42:12 <soupdragon> extra points for being meta
21:42:18 <edwardk> i have plenty of cheesy morphisms in category-extras, just look for the ones that sound like i made them up
21:42:29 <tomberek> works on two levels
21:42:31 <tomberek> chrono-?
21:42:33 <Makoryu> soupdragon: I wish I could insert drumlines into IRC.
21:42:35 <edwardk> exactly
21:42:46 <edwardk> way to mix up greek and latin ;)
21:42:47 <Makoryu> soupdragon: Because if I could... I would rickroll you.
21:43:02 <soupdragon> that is the problem with IRC
21:43:42 <ddarius> edwardk: Isn't that most of them?
21:44:07 <edwardk> ddarius: that i made up or that muddle together greek and latin?
21:44:11 <ksf> oh. ghc crashes with TERM=Eterm
21:44:33 <ddarius> edwardk: The former.
21:46:11 <FunctorSalad_> I have a bytestring-trie with 314757 entries (filepaths) and it's hideously fast... good work :)
21:46:21 <edwardk> ddarius: nah, i think the only ones i can really be blamed for are a few of the generalized versions created for symmetry, g_hylo, chrono, and the lifting of histo and futu into the (co)density (co)monad of the (co)free (co)monads.
21:46:29 <dons> FunctorSalad_: sweet
21:47:19 <tomberek> edwardk: you're supposed to yell "Earmuffs!" before you say something like that.
21:47:31 <danharaj> edwardk: Are there any references that make category-extras make sense? ;p
21:47:41 <danharaj> Maybe you should add a bibliography to the documentation
21:47:42 <edwardk> danharaj: my blog? =)
21:47:52 <danharaj> pff
21:48:01 <tomberek> danharaj, actually, i've been playing with it, and it makes more and more sense by the day
21:48:20 <danharaj> tomberek: said the occultist as he fingered through his necronomicon
21:48:20 * copumpkin yawns
21:48:27 <edwardk> danharaj: i need to go through and thin out a bit of the esoterica
21:48:34 <soupdragon> I guess to project a point  (u,v)  onto the line ax+by=0 I can use t=-(au+bv)/(a^2+b^2) and the point is (u+at,v+bt)
21:48:40 <ksf> \o/ Transfer-Encoding: chunked
21:48:43 <soupdragon> which probably extends to n-dimensions easily
21:48:50 <Cale> What is knowledge? How do we know what we know? These are tricky questions, but what we do know is that Epistem-O's cereal tastes great with milk! Also try new Honey Nut Epistem-O's and Existenchex!
21:48:52 <edwardk> mornin copumpkin
21:49:03 <copumpkin> soupdragon: you'd want to talk in terms of vectors, probably, if you want to go dimension-independent
21:49:04 <ksf> iteratees are tEH win
21:49:07 <copumpkin> edwardk: g'morning!
21:49:12 <soupdragon> not sure how to iterate over a 2D plane though
21:49:12 <tomberek> danharaj, the first thing to understand is Hask,, helps you read the type signatures better
21:49:25 <soupdragon> but I think I solved the 1D case
21:49:35 <soupdragon> hmor did I....
21:49:55 <soupdragon> whats the best way to output a vector graphic from haskell ?
21:50:09 <soupdragon> probably byorgeys thing I guess
21:50:15 <edwardk> soupdragon: by bribing byorgey to release his shiny new version of diagrams
21:50:18 <edwardk> if he hasn't already
21:50:34 <Makoryu> Is that the one with an OpenGL backend
21:50:54 <edwardk> now with all the projective geometry goodness we sold him on at hac-phi ;)
21:50:59 <ksf> what is _extremely_ non-intuitive is that they reverse the dataflow direction of . , though.
21:51:03 <FunctorSalad_> (deserializing the trie just takes two seconds as well)
21:51:09 <ksf> stuff flows from left to right.
21:51:11 <FunctorSalad_> (from harddisk)
21:51:13 <ddarius> Of course edwardk would be selling projective geometry.
21:51:24 <ddarius> edwardk: You should sell conformal geometry.
21:51:27 <edwardk> ddarius: duality ftw ;)
21:51:28 <soupdragon> 'The library is currently undergoing a major rewrite to be much more elegant and flexible. The ultimate vision is for diagrams to become a viable alternative to drawing systems like metapost  or Asymptote' WOW
21:51:56 <soupdragon> http://code.haskell.org/diagrams/example/examples.html
21:53:37 <edwardk> soupdragon: the stuff that was being worked on at hac-phi was pretty slick. it basically tracks a convex hull in functional form, so it can look for a (hyper)plane that it can slide between the two diagrams when you say that you want one next to another (or at a 32 degree angle slightly above and to the right, etc)
21:54:14 <edwardk> soupdragon: so they nestle in close but don't overlap
21:54:19 <soupdragon> nice
21:55:04 <Cale> How much would you expect to pay for all this projective geometry? $500? $300? If you call right now, you can get this beautiful projective geometry for only 5 easy payments of $29.95! But wait! There's MORE! Call in the next half hour, and we'll throw in an extra set of 5 conformal mappings, at absolutely no extra cost!
21:55:06 * ddarius wonders how you combine the worst features of C++ and Java.
21:55:15 <edwardk> cale: =)
21:55:48 <c_wraith> ddarius, that sounds like a strict subset of C++
21:56:08 <ksf> nope, c++ has unsigned types
21:56:15 <edwardk> ddarius: its called 'managed c++' ;)
21:56:25 <ksf> and identifiers that fit on a screenwidth
21:56:28 <Cale> C++ for the JVM
21:56:39 <c_wraith> It just seems that every bad C++ feature is also present in java.
21:56:53 <c_wraith> err, strike that and reverse it
21:56:59 <ksf> not really, java lacks type errors that don't fit in a scroll buffer
21:57:04 <Cale> yeah, it's the other way around :)
21:57:13 <edwardk> ksf: you obviously aren't trying hard enough
21:57:20 <JoeyA> Somebody should create an intercal++
21:57:37 <edwardk> JoeyA: i thought that WAS java
21:57:40 <Makoryu> JoeyA: I think there is one. It's subject-oriented. Everything is subjective.
21:57:57 <c_wraith> Is this like objectivism-oriented programming?
21:58:00 <JoeyA> Another idea might be: "Everything's an argument"
21:58:04 <JoeyA> Or "Everything's a battle"
21:58:08 <JoeyA> Battle-oriented programming :)
21:58:10 <Makoryu> c_wraith: Yes ;)
21:58:13 <ksf> actually, oop is actually subject-oriented programming
21:58:16 <JoeyA> x = 3
21:58:20 <JoeyA> no, x = 5!
21:58:26 <JoeyA> um..., x = 3
21:58:29 <ddarius> Henderson's picture language never dies
21:58:34 <edwardk> who.is(John.Galt)
21:58:38 <ksf> oop would be pure objects... only subjects can perform side effects.
21:58:44 <soupdragon> oh man I don't think I can use diagrams this is really annoying
21:58:52 <edwardk> soupdragon: whats wrong?
21:59:08 <soupdragon> Configuring cairo-0.11.0...
21:59:08 <soupdragon> setup: gtk2hsC2hs is required but it could not be found.
21:59:09 <soupdragon> that
21:59:14 <soupdragon> trying to install cairo so I can install diagrams
21:59:18 <soupdragon> and so it wants other things
21:59:24 <soupdragon> and it's just going to go on forever problably
21:59:37 <soupdragon> I should just write SVG files that is easy to do
21:59:48 <edwardk> soupdragon: if it makes you feel better about 4-5 folks were up to speed and hacking on it within an hour or two at hac-phi
22:00:05 <edwardk> so the dependency chains can't be that vad
22:00:07 <edwardk> er bad
22:00:12 <Cale> My friend had his Java program for a CS assignment stack overflow by accident, and for some stupid reason the stack size on the machines they were testing the submissions on was ridiculously high, and they were printing all the output. The TAs showed him the resulting box of output.
22:02:11 <Cale> (Not exactly a giant type error story, but still pretty funny :)
22:02:41 <JoeyA> not sure I get it entirely
22:02:48 <ezyang> What a waste of paper!
22:02:54 <JoeyA> oh
22:03:02 <JoeyA> *printing*
22:03:15 <Cale> The stack trace filled an entire box of paper.
22:03:17 <dolio> babusri: You're using boxed vectors.
22:03:19 <soupdragon> cabal: There is no package named gtk2. Perhaps you need to run 'cabal update'
22:03:19 <soupdragon>  what the hell????
22:03:20 <Makoryu> （　≖‿≖）
22:03:32 <soupdragon> http://www.haskell.org/gtk2hs/
22:03:36 <soupdragon> someone should fix this site
22:03:42 <soupdragon> oh wait it's my own fault for misreading
22:03:46 * alar wonders why Network.Socket uses network-byte-order port numbering but does not have htons/ntohs functions
22:04:22 <Cale> alar: There's a special numeric type you're meant to use for port numbers
22:04:42 <Cale> alar: You don't use its data constructor unless you want flippage :)
22:05:00 <Cale> alar: Just use fromIntegral to convert from Int or Integer to PortNumber
22:05:07 <alar> @hoogle PortNumber
22:05:07 <lambdabot> Network PortNumber :: PortNumber -> PortID
22:05:07 <lambdabot> Network data PortNumber
22:05:07 <lambdabot> Network.BSD data PortNumber
22:05:19 <Cale> (It's an instance of Num)
22:05:27 <Siasia> hehe
22:05:27 <FunctorSalad_> soupdragon: pcakage's called just gtk
22:05:33 * alar goes to check fromIntegral behavior
22:05:39 <FunctorSalad_> or 'just called' even
22:05:46 * Siasia loved this problem with brain
22:06:02 <ddarius> Going through byorgey's slides on diagrams, I can't help but think of constraint logic programming.
22:06:05 <Cale> alar: fromIntegral converts from any integer-like type of number to any sort of number at all
22:06:28 * alar also wonders why Network.listen silently chooses TCP6 when it is available
22:07:00 <soupdragon> ;((((
22:07:00 * ksf wonders why most programs default to ipv4 even if he has ivp6
22:07:02 <FunctorSalad_> turn it off in the kernel, problem solved ;)
22:07:12 <soupdragon> I installed everything and setup everything and now it says setup: The pkg-config package cairo-pdf is required but it could not be found.
22:07:20 <FunctorSalad_> (disclaimer: dunno if that's a good idea, maybe some of my system malfunctions are due to it)
22:07:55 <ksf> I'd kill ipv4 if the rest of the internet finally switched...
22:07:57 <FunctorSalad_> some programs complain but I think they just go on and use ipv4 as they're supposed to
22:08:09 <alar> FunctorSalad_: yes, most of the time I turn it off in the kernel. Just hoped there is other way around
22:08:11 <FunctorSalad_> ksf: sure but as a desktop I can react relatively quickly ;)
22:08:14 <FunctorSalad_> once they do switch
22:08:31 <Olathe> Is it possible to put two instances of a class on a line ? "instance Cl A; instance Cl B" ?
22:08:39 <Olathe> ghci is giving me trouble with that.
22:08:48 <alar> FunctorSalad_: I never had any problems with missing IP6 in my kernel
22:08:54 <Siasia> what for?
22:10:32 <ksf> ghci doesn't take instances at all iirc
22:10:48 <ksf> ...you can't put them in a do block and that's what ghci is
22:12:18 <Olathe> I mean loading a file into ghci
22:12:50 * soupdragon just gives up because this isn't working
22:12:55 <alar> ksf: you should kill all Windows user first: on Windows module Network silently uses TCP4 ;)
22:13:10 <soupdragon> also I don't see how you can project from n+2 dimensions to n
22:13:12 <ksf> principally, it should work due to the layout rules etc. could be an oversight, tohugh.
22:13:13 <soupdragon> that doesn't make sense
22:13:19 <soupdragon> only from n+1 to n makes sense
22:13:39 <soupdragon> though I suppose n+1+1 = n+2
22:13:58 <dolio> I think I can prove that in Agda.
22:14:08 <soupdragon> :D
22:14:15 <ksf> I've seen enough hypercubes being projected on my 2d screen
22:16:05 <FunctorSalad_> 'projection' can be a pretty general word
22:16:27 <FunctorSalad_> sometimes synonymous with 'idempotent'
22:17:00 <FunctorSalad_> anyway, surely a linear or perspective projection two dimensions down qualifies o_o
22:17:42 <soupdragon> oo_o
22:17:50 <soupdragon> I need a way to render stuff
22:17:54 <Gracenotes> you have an extra eye. let me poke it out for you
22:17:59 <tomberek> edwardk:  in Control.Functor.Combinators.Biff, I tried something like mkOn ([1],[2])
22:20:51 <tomberek> edwardk: am I missing something?  Biff ([1],[2]) :: Biff (,) [] [] Int Int    doesn't terminate
22:21:40 <Olathe> Is there a way to do "Use -fcontext-stack=N to increase stack size to N" in a source file ?
22:22:05 <alar> @karma+ Cale
22:22:05 <lambdabot> Cale's karma raised to 36.
22:22:08 <Olathe> Or is that a compiler switch or what ?
22:22:11 <edwardk> soupdragon: you can project from n + 1 dimensions to n just by choosing a plane a unit away from the origin, and identifying all points on the line from the origin that pass through a given point on that plane, that gives you a standard projective geometry. you can repeat that process if you want a pretty whacked out view ;)
22:22:29 <edwardk> tomberek: hrmm
22:22:52 <tomberek> edwardk: nvm,, my Show instance for On, is jacked up
22:23:19 <edwardk> tomberek: ok, that i'd believe ;)
22:23:30 <tomberek> thanks... gr
22:26:20 <codnik> :t mkPic
22:26:21 <lambdabot> Not in scope: `mkPic'
22:30:00 <tomberek> edwardk: what's the class that can pull apart a (,) ?
22:30:08 <copumpkin> bifunctor?
22:30:25 <tomberek> i thought so, but it can only map on it
22:30:42 <tomberek> it'll just produce another (a,b)
22:30:46 <copumpkin> what do you want to do with it then?
22:31:02 <tomberek> well, if i knew it was going to be (,)  i would just do fst
22:31:38 <dolio> What do you mean by "pull apart"?
22:31:46 <tomberek> (a,b) -> a
22:32:11 <copumpkin> Copointed functor but not one that works in haskell
22:32:19 <copumpkin> you could only do (a,b) -> b in haskell without a wrapper
22:32:46 <babusri> dolio: In this example using Unboxed makes a big difference (8k copied during GC), but on another similar example it didn't. I will check that. But if only one 16*Word32 Vector is allocated, how does it matter whether it is boxed or unboxed: 65 M copied during gc vs 8k?
22:33:15 <tomberek> copumpkin: yeah, just found that...  why can't it be done in Haskell?
22:33:28 <copumpkin> tomberek: wrong direction of partial application of the type constructor :)
22:33:34 <dolio> babusri: I don't really understand what's making the boxed version so slow.
22:33:35 <copumpkin> you can do it easily with a newtype
22:34:02 <tomberek> so just Flip?
22:34:03 <dolio> babusri: When I ran it with a much larger size, I think it was leaking space, but I'm not sure why.
22:34:03 <dons> babusri: boxed values are also lazy
22:34:06 <edwardk> tomberek: well, http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html gives you fst and snd
22:34:09 <dons> babusri: so you might introduce a space leak
22:34:14 <edwardk> tomberek: but thats probably not what you want
22:34:35 <tomberek> hm... i have yet to fully decipher the Cartesian section
22:35:00 <dolio> babusri: I think it might be setting up a huge indirection that only gets evaluated at the end.
22:35:01 <edwardk> read k as (->), p as (,), s as Either -- and it should come clear
22:35:22 <tomberek> edwardk: actually, that looks like it's what i want,, why did you say no?
22:35:23 <edwardk> fst :: k (p a b) a -- (a, b) -> a
22:35:45 <edwardk> tomberek: mostly because the fundep there won't make you happy ;)
22:36:01 <tomberek> so any PreCartesian can be pulled in two?
22:36:07 <dolio> final value -> value from previous index of previous version of the array -> ... -> value from some index of the original array.
22:36:08 <edwardk> no
22:36:36 <dolio> Do that 100,000 times, for 16 spaces, and it adds up.
22:36:40 <tomberek> arg,, so (->) imples (,)    ouch
22:36:52 <edwardk> a (pre)cartesian category has an associated bifunctor, which acts as its product, which satisfies a couple of laws
22:36:57 <dolio> But that's only a theory.
22:37:02 <edwardk> tomberek: told you you wouldn't be happy ;)
22:37:07 <tomberek> can't have (->) and Prod  (for example)
22:37:19 <edwardk> tomberek: exactly, not and use that class off the shelf
22:37:31 <edwardk> tomberek: that isn't to say you couldn't use it as inspiration
22:37:53 <edwardk> but you'll very quickly get into territory where you'll need to supply a ton of type annotations
22:37:53 <dolio> Or a conjecture, if you prefer.
22:38:15 <tomberek> edwardk : well, you know I'm building a fancy version of Product,, i thought some simple version was out there
22:38:52 <edwardk> i've built something like it a couple of times for dealing with unboxed tuples, etc. but never kept it around
22:38:55 <dolio> That sounds like it would overflow the stack, though, so maybe I'm wrong.
22:40:06 <tomberek> edwardk : ouch, man, that fundep does suck!
22:40:39 <edwardk> tomberek: feel free to copy the code for that module and maybe for the Cartesian.Closed module and play around without the fundep
22:40:51 <edwardk> i don't claim to have found the optimal set of dependencies for all circumstances
22:40:54 <alar> is there a way to pass RTS options to cabal-install?
22:41:52 <tomberek> edwardk: um.. i'm not sure i'm up for that yet.. Coassociative, braided, etc.. i don't know what i'm mucking with... thanks though
22:42:24 <edwardk> they aren't that hard, braided is just a weaker symmetric. symmetric says you can swap :: p a b -> p b a
22:42:36 <edwardk> braid :: p a b -> p b a -- doesn't ensure that braid . braid = id
22:42:55 <edwardk> the associative/coassociative are crappy names i need to rewrite
22:43:36 <edwardk> most people just start at monoidal, where things get interesting
22:44:28 <edwardk> Associative gives you the law that you can take ((a,b),c) -> (a, (b,c)) -- coassociative gives you the inverse
22:45:04 <tomberek> edwardk : for now I'll just do this instance (Show (f a),Show (f b),Show a, Show b) => Show (On (,) f a b)  and then again for Prod
22:45:14 <edwardk> monoidal gives you an 'identity' which is a weak form of fst and snd
22:46:24 <edwardk> well, you can just have instance (Show (f a), Show (f b)) => Show (On (,) f a b)
22:46:38 <edwardk> no need for the other two Show's
22:46:41 <tomberek> really?
22:46:46 <tomberek> hm,, oh ya!
22:46:47 <tomberek> dug
22:46:48 <tomberek> guh
22:46:53 <tomberek> duh
22:51:49 <alexbobP> Why are people in here so damned nice?  nobody's nice in #c... everybody's butthurt in #java...
22:52:09 <alexbobP> what is it about pure functional programming?  is it the ganja that comes with ghc?
22:52:38 <edwardk> alexbobP: i blame shapr. he infected the whole community some how
22:52:57 <alexbobP> edwardk: awesome.
22:53:06 <edwardk> alexbobP: nah, its not functional programming, try #coq some time. its hit or miss
22:53:07 * soupdragon is trying to gain some niceness from these people 
22:53:09 <tomberek> alexbobP: well, it's just that we know the ganja is good.  We get the same effects every time we use it. Dependable
22:53:30 <edwardk> tomberek: but... but... side effects!
22:53:31 <tomberek> hardy har har
22:54:06 <alexbobP> edwardk: #coq?  is that supposed to be a dick joke?
22:54:08 * alexbobP tries it
22:54:14 * soupdragon sometimes worries that I'm harming the channel by being here but I try to be good
22:54:33 <tomberek> edwardk:  takeGanja :: Me -> Happy Me    alexbobP: coq is a theorem prover
22:54:43 <soupdragon> alexbobP, Coq is this turbo charged funtion programming + logic language
22:54:44 <tomberek> and yes, it's a french dick joke
22:55:01 <alexbobP> I actaually don't get the same results frmo weed every time, I get a tolerance if I use it too often and then I get more effect if I wait a while
22:55:07 <alexbobP> maybe there's a memoizer under the covers
22:55:08 <edwardk> alexbobP: it was more of a reference to a past #haskell incident in which one of the more prominent developers in the coq community managed to rather consistently piss off a few folks around here, to the point where he found himself banned
22:55:22 <alexbobP> edwardk: hehe
22:55:26 <dons> edwardk: hmm. smerdyakov?
22:55:30 <edwardk> dons: yeah
22:55:35 <soupdragon> edwardk, I guess I don't find it hard to beleive but I always liked talking to him myself
22:55:45 <p_l> alexbobP: everybody is butthurt in #java because they have reasons to be (not only bad language, but also the bad rep...)
22:55:48 <soupdragon> I guess I have thick skin in a certain patch (and not in others)
22:55:56 <edwardk> soupdragon: i get along with smerdyakov just fine
22:56:05 <dons> not sure why he's such a jerk online. smart guy, reasonable in person.
22:56:19 <dons> just doesn't like newbies or something
22:56:29 <tomberek> dons: it's easier to be mean online than in person
22:56:38 <soupdragon> tomberek is true
22:57:00 <tomberek> something about anonymity, and not seeing the one you hurt
22:57:01 <alexbobP> p_l: inorite?  no unsigned variables, what rubbish XD
22:57:02 <soupdragon> that's why #haskell is sort of magic
22:57:09 <dons> ah.
22:57:16 <edwardk> dons: yeah, he lives about a mile from me. hes fine once he knows you're using haskell because you want to, not because you don't have the chops for coq ;)
22:57:22 * monochrom is reading smerdyakov's Coq online book recently. Actually pretty helpful, cuts to the mustard quickly.
22:57:38 <dons> http://art.penny-arcade.com/photos/215499488_8pSZr-L-2.jpg
22:57:40 <soupdragon> speaking of coq I found this cool new thing
22:57:41 * monochrom thinks of it as Real World Coq :)
22:57:50 <blackdog> monochrom: link?
22:57:54 <soupdragon> it adds desicision procedures to the conversion rule
22:57:57 <soupdragon> that seems really useful to me
22:57:59 * ddarius is pretty confident people would not find his behavior in person significantly different than his behavior online.
22:58:02 <dons> edwardk: well, in ocaml days, this was also a problem.
22:58:07 <edwardk> but i have to admit, that ##logic pretty much froze in growth/started to shrink the moment he becae a regular
22:58:09 <dons> ddarius: you're a jerk in person? :P
22:58:14 <ddarius> dons: Yes.
22:58:14 <tomberek> edwardk: why would you use coq vs Haskell? and vice versa? is it that it is a more complete language, but not practical?
22:58:34 <ddarius> dons: People usually like me nevertheless.  It's frustrating.
22:58:38 <monochrom> http://adam.chlipala.net/cpdt/
22:58:40 <soupdragon> edwardk I left cause there was some tension w/ sbahra
22:58:55 <soupdragon> he has some kind of problem with me
22:59:02 <dons> ddarius: interesting!
22:59:05 <edwardk> tomberek: coq is nice in that you can prove a lot more about the code you can write, it is bad in that some times that takes a lot more code, and that some code cannot be proven correct regardless, so you can write strictly fewer programs in coq but be more sure they are correct
22:59:07 <blackdog> monochrom: oh, smerdyakov is adam?
22:59:14 <soupdragon> anyway I don't know heck all about logic so that's not a big loss
22:59:20 <monochrom> ya
22:59:33 <tomberek> edwardk: like the laws associated with things?
22:59:42 <blackdog> heh. hadn't realised... have looked into ur/web and talked to smerdyakov online and never put the two together:)
22:59:43 <tomberek> you can be sure that they're followed?
23:00:00 <edwardk> soupdragon: i admit i kind of tuned out over the whole vixey/sbahra affair, i gave them both chanops and let them fight it out ;)
23:00:12 <edwardk> tomberek: exactly
23:00:21 <dons> edwardk: oh they fought it out somewhere else?
23:00:27 <dons> sigh. can't people just get along.
23:00:50 <tomberek> that sounds like a good idea
23:00:55 <edwardk> tomberek: the downside to coq is that it has some pretty rough edges, for instance the 'tactics' you use to prove things are written in this hideous imperative metalanguage
23:00:55 <ddarius> dons: People getting along is like people keeping a secret...
23:01:25 <tomberek> isn't the dependently typed functional language the holy grail?
23:01:33 <soupdragon> tomberek, Epigram ?? ;p
23:01:39 <edwardk> tomberek: we have two or three
23:01:50 <edwardk> tomberek: they are just a pain in the neck to actually use for real code
23:01:51 <dolio> Nah, you need other stuff besides that.
23:01:57 <copumpkin> tomberek: unfortunately not
23:02:06 <dolio> Some substructural types.
23:02:06 <blackdog> Agda, Epigram and Coq are the big three? (Isabelle??)
23:02:15 <dolio> Maybe some modal types.
23:02:15 <tomberek> ah,, what are the problems with them?
23:02:19 <copumpkin> there are a few more
23:02:19 <soupdragon> Agda Epigram and Coq would all be in the same family
23:02:22 <dons> Isabelle for sure.
23:02:24 <copumpkin> tomberek: you don't get proofs for free
23:02:25 <soupdragon> and Cayenne too
23:02:47 <soupdragon> whereas you get stuff like ATS, DML and Omega
23:02:51 <copumpkin> tomberek: you also lose some nice stuff in haskell like inference (except in restricted cases)
23:02:55 <soupdragon> that would be classed separately
23:03:00 <edwardk> tomberek: you know the headaches you've had with associated types? multiply that 10 fold.
23:03:16 <tomberek> ouchie
23:03:24 <tomberek> edwardk, but i'm making progress!
23:03:29 <edwardk> type inference goes out the window, so you're left being very explicit about types, to the point where you say very little about terms
23:03:30 <ddarius> You know the headaches you've had with type level programming?  divide that 10 fold
23:03:39 <soupdragon> would it make sense to group  PVS and Isabelle?
23:03:42 <edwardk> ddarius: hah true enough
23:03:49 <soupdragon> those are the ones I've not really understand
23:03:52 <blackdog> ddarius: ... divide that? it's easier?
23:04:10 <edwardk> blackdog: it is in a lot of ways
23:04:12 <dolio> Type level programming in Haskell is crude.
23:04:13 <soupdragon> but as I understand it, every type in Isabelle is inhabited ?
23:04:16 <copumpkin> blackdog: you often have to duplicate type-level and value-level stuff in haskell, which isn't necessary in a dep typed language
23:04:45 <soupdragon> it goes deeper than just the repetition is elided
23:04:59 <soupdragon> you actually get this logical interpretation of the functional code by moving it across the :
23:05:47 <tomberek> edwardk : so, i think what i'm looking for in an abstract sense are Of -> On and On -> Of functions (with appropriate contexts)
23:06:59 <edwardk> sounds right, but you only care where the bifunctor is 'product-like'
23:07:53 <tomberek> yes
23:08:22 <tomberek> and the Shape/Info has to line up right
23:09:52 <Veinor> soupdragon: but what about bottom? :O
23:11:01 <dolio> You don't get bottom.
23:11:13 <FunctorSalad_> is the topic whether dependent types are more or less complicated?
23:11:51 <dolio> Something like that.
23:12:04 <dolio> Advantages and disadvantages.
23:12:10 <soupdragon> for me it's just 'say random stuff that vaugely relates at least in terms of keywords to what they are'
23:12:25 <FunctorSalad_> type inference in general goes out of the window, but you get heuristics...
23:12:36 <FunctorSalad_> like coq's hint database for `auto'...
23:13:03 <edwardk> i like spending a few hours with dependent types every few weeks to try out ideas i'd be afraid to compile without proof of correctness, but then i go back to hacking ;)
23:13:17 <FunctorSalad_> which has the disadvantage of chaotic ;) behaviour with respect of whether your program will compile
23:13:27 <dolio> I suppose one positive point is that inasmuch as the language does inference, you get term inference as well.
23:13:30 <soupdragon> yeah. I was working on some mathematics libarary in haskell but I wasn't brave enough without a safety net
23:13:34 <FunctorSalad_> (adding or removing some hint can make searches later fail)
23:13:42 <soupdragon> when I tried to do it in Coq though I got into other problems so I end up with nothing
23:13:54 <edwardk> soupdragon: thus ends much coq hacking ;)
23:14:08 <FunctorSalad_> soupdragon: haha did you try categories? that's a life project
23:14:15 <soupdragon> it's all fun and games until you end up in someone elses reseach territory
23:14:28 <edwardk> FunctorSalad_: who hasn't? =)
23:14:29 <FunctorSalad_> (or so I think now)
23:14:53 <FunctorSalad_> easiest way is probably to just encode zfc first *runs*
23:15:01 <soupdragon> thats already been done!
23:15:07 <dolio> Doubtful.
23:15:33 <dolio> Writing Coq proofs that correspond to ZFC proofs is going to be extra painful.
23:15:41 <FunctorSalad_> dolio: think dep types are the perfect match for directly encoding categories? try it... hehehehe
23:15:43 <FunctorSalad_> ;)
23:16:07 <soupdragon> FunctorSalad (if we had quotient types ala epigram, I think it would be perfect)
23:16:21 <soupdragon> of course the operation of quotenting forms a category...
23:16:29 <FunctorSalad_> soupdragon: I don't know epigram quotients, but yeah, at some point I needed quotients
23:16:30 <soupdragon> but you need an implementation of category theory to use that
23:16:44 <soupdragon> so you get this vertigo feeling and you just can't move
23:16:51 <dolio> Actually, there's a mathematician at the n-category cafe that thinks that dependent types would be an asset to category theory and other mathematics, and that their approximation by set theory and whatnot is just that, a poor approximation.
23:17:20 <soupdragon> FunctorSalad, I mean quotients in the sense that you literaly get a new type (Rather than just having to prove respectfulness of every morphism)
23:17:28 <ddarius> Dependent types in mathematics = higher order logic (aka "type theory")
23:17:29 <soupdragon> (as opposed to setoids)
23:17:46 <Makoryu> Say, there are a lot of bans in this channel.
23:17:52 <Makoryu> Is there a ban expiration policy?
23:18:05 <FunctorSalad_> dolio: I've read a little bit about it, but since the devil is in the details here (nobody is saying that it's *impossible*, just hard to do without becoming a horrible mess), I'd like to see an implementation ;)
23:18:05 <ddarius> Set theory = untyped dependent types (if that makes sense...)
23:19:27 <dolio> FunctorSalad_: Like, Hom is conceptually a family of sets/types ala type theory; that's how people actually think about it.
23:20:27 * soupdragon always wondered why everything in math was a set
23:21:29 <kynky> maths is all sets sets sets to you!
23:21:44 <soupdragon> :)
23:21:46 <FunctorSalad_> soupdragon: an extra axiom that you can conjure a quotient type with quotient map given an equivalence relation? that'd be nice but I think there were some difficulties there too :(
23:21:59 <dolio> FunctorSalad_: Part of the problem with requesting an implementation is that you have to be way more detailed than any mathematician actually is. :)
23:22:05 <soupdragon> FunctorSalad_, if there are difficulties that is scary! I don't know about them
23:23:29 <FunctorSalad_> if you demand that your quotient types comes with a "give me a representative" function (a right inverse to the quotient map), that's the axiom of choice already ;) (in a form that's enough to imply LEM, I think?)
23:24:28 <FunctorSalad_> which is not a problem if you're not being constructive though
23:24:44 <soupdragon> I think it's okay to give a representation as long as you promise not to look inside it
23:25:15 <soupdragon> s(i.e. you only feed respectful morphism)
23:26:19 <FunctorSalad_> "a function out of the quotient is made by defining a function out of the original type, which is respectful"? yes, that'd the idea, but I thought you still have to be careful
23:27:18 <FunctorSalad_> I thought there was something on McBride's site how he ran across a contradiction when trying to implement this rule the wrong way in epigram
23:27:26 <dolio> I've seen at least one type theory with a "give me a representative" function.
23:27:30 <dolio> For quotients.
23:27:41 <soupdragon> dolio PVS?
23:27:53 <dolio> And it somehow just gave you back what you put in, without that being a problem. But I don't remember how.
23:28:00 <soupdragon> mm not PVS
23:28:01 <dolio> It was just a paper.
23:28:34 <dolio> A Simple Model for Quotient Types, perhaps?
23:29:31 <Associat0r> soupdragon: why is Smerdyakov banned?
23:29:54 <dolio> From here? He's not n00b friendly.
23:30:15 <Associat0r> well he was friendly to me
23:30:24 <Makoryu> dolio: Please express your reply in terms of endofunctors
23:30:24 <soupdragon>  Associat0r ditto
23:30:33 <FunctorSalad_> dolio: but what I was trying to say is that without convenient quotient types or some replacement, you can't define, for example, functor categories (they won't literally satisfy the laws)
23:30:42 <edwardk> Associat0r: yes, many of us get along with him fine, but there was also months of melodrama on here.
23:30:42 <Makoryu> (But seriously what'd he do)
23:31:39 <edwardk> feel free to ask shapr, he'll start foaming at the mouth and give an hour long rant ;)
23:32:15 <Associat0r> edwardk: that's not shap from BitC right?
23:32:20 <dolio> FunctorSalad_: Because functors-as-implemented-in-type-theory hold coherence proofs?
23:32:24 <dons> edwardk: a long period of hostility to newbies. continued in #ocaml and now #coq apparently. :)
23:32:29 <edwardk> Associat0r: nah
23:32:39 <edwardk> dons: and ##logic
23:32:47 <FunctorSalad_> dolio: yeah, and missing functional extensionality I think
23:33:08 <dolio> Oh, well, yes, that's also a problem.
23:33:21 <dons> well, we have ~650 people here, while #ocaml hasn't moved in 3 years, so shapr was right.
23:33:22 <edwardk> associat0r: but the gist of it is he was putting off newbies at a fairly alarming rate
23:33:30 <FunctorSalad_> (in coq, at least... it is compatible with functional extensionality as an axiom, but that's not quite as easy-to-use as just happily replacing equals for equals in set theory :))
23:33:31 <dolio> I don't usually associate function extensionality with quotient types.
23:33:57 <Makoryu> dons: Didn't we have 800-ish people in here at times?
23:34:03 <Associat0r> edwardk: can you give me a concrete example?
23:34:04 <dons> shapr's often right. more than he gets credit for.
23:34:05 <FunctorSalad_> hmm, me neither, but if you have quotient types, you have extensional function sets, no?
23:34:17 <dons> Makoryu: quite possibly. its spiked recently
23:34:24 <dolio> FunctorSalad_: You can get around that even in an intenstional type theory by using setoids, but that increases your pain.
23:34:25 <edwardk> ##logic fell from about 60-70 to 20 after his sustained presence ;)
23:34:25 <Makoryu> dons: Or has it?
23:34:34 <FunctorSalad_> dolio: yes
23:35:42 <FunctorSalad_> dolio: maybe what I'd have needed was just an extensional type theory, decidability being sacrificed...
23:35:58 <FunctorSalad_> (of typechecking? I think)
23:36:29 <dolio> Well, Epigram 2 has extensional equality and decidable type checking.
23:36:35 <dolio> But usually, yes.
23:37:42 <edwardk> Associat0r: i've personally watched him mock users for asking perfectly reasonable questions. in the old days many of his comments were about why one should be doing what they are doing in coq or ocaml rather than haskell.
23:38:37 <edwardk> and in general left people slinking away feeling small. intervention was tried, a couple of short term bans, and then he was banned for good
23:38:53 <Makoryu> His nick sure is hilarious
23:39:12 <soupdragon> some kind of russian literature reference
23:39:16 * soupdragon (is not good at books)
23:39:19 <edwardk> In the meantime he tried to escalate it all the way to SPJ and company, and much melodrama ensued.
23:39:22 <dolio> Doesn't it mean "shithead"?
23:39:36 <FunctorSalad_> edwardk: I often felt subtly insulted by his answers to reasonable questions too
23:39:38 <Makoryu> dolio: Not exactly but it might as well
23:40:11 <FunctorSalad_> don't remember why really :)
23:40:48 <copumpkin> " smerdet meaning "to stink" / "son of the reeking one" in Russian."
23:40:56 <copumpkin> apparently
23:41:21 <edwardk> copumpkin: wel, smerdyakov comes from the brothers karamazov, the character's father was the stinky one
23:41:24 <Associat0r> I need a concrete example
23:41:31 <edwardk> or at least that is the derivation of the name
23:41:38 <copumpkin> yep
23:41:42 <Associat0r> I never seen him done anything that warranted a ban
23:41:51 <soupdragon> I imagine he has changed
23:41:57 <copumpkin> Associat0r: you "need"? :P
23:42:01 <soupdragon> due to time etc
23:42:15 <Makoryu> Yeah, "Reekerton" would be a nicer translation than "shithead"
23:42:23 <FunctorSalad_> lol is there any way to generate the :DocIndex for haskell in gvim without having to repeatedly press 'd' until it has all scrolled by?
23:42:34 <edwardk> Associat0r: it was quite a while ago, feel free to hunt through the logs, but most folks here have washed their hands of it
23:42:44 <FunctorSalad_> ^^
23:42:58 <soupdragon> it doesnt' seem that way :P
23:43:02 <Olathe> Is there a way to get ghc to show the steps it takes in resolving functional dependencies ?
23:43:09 <soupdragon> this is not the first time we've talked about it
23:43:16 <FunctorSalad_> (it doesn't seem to continue working unless you're supervising it by pressing 'd')
23:43:30 <edwardk> soupdragon: he's mellowed a bit, but he also doesn't irc as much either
23:44:14 <soupdragon> oh yeah he said he was working on a new systems programming language or smoething
23:44:15 <edwardk> but really we've drifted pretty far OT towards -blah or -ops territory ;)
23:44:28 <copumpkin> I agree
23:44:30 <edwardk> soupdragon: he's working on YNOT over at harvard under morrissett
23:44:36 <soupdragon> huh??
23:44:42 <FunctorSalad_> :o
23:48:37 <Axman6> > logBase 2 99999999999999
23:48:38 <lambdabot>   46.50699332842306
23:48:58 <Gracenotes> @src Maybe mappend
23:48:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:49:14 <FunctorSalad_> > 10 * length "99999999999999" / 3
23:49:14 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
23:49:14 <lambdabot>    arising from a use o...
23:49:28 <FunctorSalad_> > fromIntegral (10 * length "99999999999999") / 3.0
23:49:29 <lambdabot>   46.666666666666664
23:49:31 <FunctorSalad_> hehehehe
23:49:38 <FunctorSalad_> poor-man's version
23:50:11 <FunctorSalad_> > log 10 / log 2
23:50:11 <lambdabot>   3.3219280948873626
23:50:22 <FunctorSalad_> (real conversion factor)
23:50:40 <danharaj> shapr sounds like an alpha programmer
23:51:08 <edwardk> danharaj: ?
23:51:49 <danharaj> I dunno, it's 2:51 and I typed a random thought.
23:52:05 <Gracenotes> hurrah, Monoid does what MonadPlus fails to do
23:52:16 <edwardk> he's good at getting a lot of people around him to work on a lot of neat stuff.
23:52:19 <edwardk> Gracenotes: ?
23:52:56 <Gracenotes> the Monoid a => Monoid (Maybe a) instance, if both are Just, mappends the a's together
23:53:08 <edwardk> yeah i hate that instance ;)
23:53:16 <FunctorSalad_> I can't remember which is which :(
23:53:36 <danharaj> I don't like how instances work :\
23:53:42 <danharaj> They're so global.
23:53:42 <Gracenotes> I guess I would use First/Last if newtypes weren't so messy
23:53:48 <FunctorSalad_> ah wait... the monadplus can only do it one way, can't it...
23:53:59 <Gracenotes> but this instance is actually useful, in this case
23:54:00 <edwardk> FunctorSalad_: the monoid instance for Maybe is the one that adds an identity to a semigroup. unfortunately there being no semigroup class, you're stuck with it lifting a monoid into a monoid
23:54:07 <tomberek> can is there an Either at the type level?
23:54:28 <edwardk> tomberek: there is a higher order one that gets used from time to time
23:54:51 <tomberek> what is it? it would make my types easier to read
23:55:16 <FunctorSalad_> edwardk: I see... it adds a new identity to the monoid :o
23:55:19 <Makoryu> @pl \x -> a x (\f -> m (f x))
23:55:19 <lambdabot> ap a ((m .) . flip id)
23:55:34 <FunctorSalad_> (which makes the old one not an identity anymore, yes)
23:55:41 <edwardk> data (f :+: g) a = Inl (f a) | Inr (g a) -- in category extras thats just On Either or something
23:55:47 <danharaj> http://www.codinghorror.com/blog/2007/11/the-two-types-of-programmers.html
23:56:05 <tomberek> yeah! i remember that somewhere
23:56:23 <FunctorSalad_> so you'd prefer if it was the same as mplus/mzero?
23:56:36 <FunctorSalad_> (it=(mappend,mempty))
23:56:45 <Gracenotes> hm, even the limited Monoid instance can't solve the long-term problem that my tree is missing the top half of its root
23:57:33 <edwardk> so what is the solution? water it? take clippings?
23:57:50 <edwardk> not sure what you mean by the top half of its root
23:59:20 <Gracenotes> edwardk: aha, just need to apply more miracle-grow
