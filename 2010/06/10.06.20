00:04:44 <solrize> is there a way to inherit all the operations of a type into a newtype?  i.e.    newtype PhoneBook = PhoneBook (Data.Map Name PhoneNumber)
00:05:21 <solrize> where i could lookup things in a phonebook using similar (maybe explicitly lifted) versions of the data.map functions
00:06:46 <ManateeLazyCat> http://farm5.static.flickr.com/4050/4716653618_878db4cec3_b.jpg build your own PDF viewer with haskell! :)
00:15:02 <Feuerbach> ManateeLazyCat: cool :)
00:16:20 <ManateeLazyCat> Feuerbach: I'm uploading my package to hackage... 
00:17:49 <ManateeLazyCat> Shit, i patch-tag.com destroy my package when i do "darcs push"...
00:18:38 * hackagebot poppler 0.11.0 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.11.0 (AndyStewart)
00:19:04 <Feuerbach> solrize: explicitly lifted means "composed with unwrapper". But since the argument may be in different positions, I doubt it can be done with a single combinator
00:19:06 <ManateeLazyCat> haskell.org always down, and patch-tag.com is buggy... Oh my....
00:19:17 <ManateeLazyCat> Feuerbach: http://hackage.haskell.org/package/poppler-0.11.0 , Enjoy! :)
00:19:45 <Feuerbach> ManateeLazyCat: greetings! btw consider using github :)
00:20:58 <ManateeLazyCat> Feuerbach: I'm faithful haskeller, since Darcs hosting is suck.... :)
00:21:21 * ManateeLazyCat No plan to switch to git since Darcs make me happy.
00:21:55 <ManateeLazyCat> I hope someday haskell.org stable enough, then i don't need other darcs hosting.
00:32:28 <Feuerbach> ManateeLazyCat: do you have collaborators, or just use darcs hosting as a backup?
00:33:21 <ManateeLazyCat> Feuerbach: No, just me. 
00:33:28 <Feuerbach> and why is poppler under UI.GTK?
00:33:46 <ManateeLazyCat> Feuerbach: Because it's depend gtk package.
00:33:55 <ManateeLazyCat> Feuerbach: Since i binding poppler-glib library.
00:34:49 <ManateeLazyCat> Feuerbach: poppler-glib APIs just work you have install package "cairo and gtk" from hackage.
00:34:59 <ManateeLazyCat> s/you/when you.
00:36:08 <ManateeLazyCat> Feuerbach: I use darcs for backup and want someone join to me :)
00:56:49 <ReinH> ivanm: ping
00:56:59 <ivanm> pong
00:57:43 <ReinH> ivanm: I think I'm pretty close to implementing read for Addresses, which is a much smaller problem.
00:57:58 <ReinH> ivanm: I was hoping you could look at a couple lines of code and tell me if there's an obvious problem with them
00:58:07 <ivanm> k
01:01:16 <ManateeLazyCat> ivanm: http://farm5.static.flickr.com/4050/4716653618_878db4cec3_b.jpg pdf viewer with haskell. :)
01:01:41 <ivanm> nice
01:02:53 <ReinH> Innominate: ok, let me know if you need any more info https://gist.github.com/b1467be4f7821566b5d7
01:03:07 <ReinH> woops
01:03:10 <ReinH> :(
01:03:26 <ReinH> anyone else want to give it a shot?
01:04:06 <ReinH> woops syntax error? really?
01:04:10 * ReinH facepalms
01:04:18 <ManateeLazyCat> ivanm: I have tried to with Emacs' pdf viewer (it's event not real viewer), it's always with "White" background hurt my eye, now with poppler APIs, i can make it with any color background i like. :)
01:04:30 <ManateeLazyCat> s/tried/tired
01:04:54 <ReinH> ok, never mind
01:05:03 <ReinH> my code works when I fix my retarded typos
01:05:11 * ReinH triple facepalms
01:05:23 <dolio> Triple?
01:05:28 <dolio> Does that involve a foot?
01:05:48 <dolio> Or do you have three hands?
01:06:46 <ReinH> one sec
01:07:10 <ReinH> http://www.citadelsaber.co.uk/img,316.jpg
01:08:18 <dolio> Yeah, I found that one after I asked.
01:08:29 <dolio> An excellent shop.
01:08:56 <ManateeLazyCat> ReinH: Photoshop?
01:09:48 <danharaj> No it's the facepalm fairy.
01:10:01 <danharaj> Who lends a helping hand in cases of extreme fail
01:11:17 <dolio> Picard actually had three hands in that episode due to quantum subspace tachyon interference.
01:11:47 * ManateeLazyCat It's a good idea that just binding library when you boring.... I found it save me much time... :)
01:13:01 <ReinH> or something
01:14:06 * dolio likes his kung pao spicy.
01:18:17 * BMeph feels lucky to ever find any spicy kung pao...
01:19:01 <ManateeLazyCat> In Emacs, doc-view mode, when you watch pdf file, you need convert split many picture (one picture per page), when you zoom view, you need convert again .... it's too slow for big PDF file... 
01:20:39 <Saizan> sometimes i've wanted a pdf viewer that could reflow the text to move a figure near the text commenting it
01:21:45 <ManateeLazyCat> Saizan: Yes, use poppler APIs can do that.
01:22:08 <ManateeLazyCat> Saizan: I'm binding more and more library for integrate to my platform.
01:22:47 <ManateeLazyCat> Saizan: Don't worried, i will build Document (pdf, ps, dvi, etc...) viewer with gtk2hs. 
01:23:05 <ManateeLazyCat> Saizan: Then you can write some Haskell code to implement your idea. :)
01:23:16 <emilmeln> ManateeLazyCat: How about djvu?
01:23:26 <ManateeLazyCat> emilmeln: Yes, i will support it.
01:23:30 <Saizan> that'd be nice :)
01:23:42 <emilmeln> And it is all in Haskell and gtk2hs?
01:23:57 <ManateeLazyCat> emilmeln: My plan is use different backend render page, but we have same behaviour for those different document.
01:24:00 <ManateeLazyCat> emilmeln: Yes.
01:24:19 <ManateeLazyCat> emilmeln: http://hackage.haskell.org/package/poppler-0.11.0 APIs for build PDF viewer.
01:24:26 <emilmeln> ManateeLazyCat: It's *very* cool!
01:24:33 <emilmeln> Thank you very much!
01:24:44 <ManateeLazyCat> emilmeln: http://farm5.static.flickr.com/4050/4716653618_878db4cec3_b.jpg
01:25:35 <emilmeln> Evince even doesn't have "goto page" function, and Okular requires KDE...
01:25:48 <ManateeLazyCat> For same behaviour, like this: "j ==> scroll-up" "k ==> scroll-down" "n ==> next page" "p ==> previe page"
01:26:42 <ManateeLazyCat> emilmeln: I'm build a gtk2hs platform to integrate editor, file-manager, document-viewer, webkit-browser, rss-reader, mplayer-client, terminal,... etc in *one* framework. 
01:27:22 <ManateeLazyCat> emilmeln: I use ivanm's word : IIE -- "Integrate Live Environment". :)
01:27:28 <emilmeln> ManateeLazyCat: You're going to make a desktop environment?
01:27:35 <emilmeln> Wow.
01:27:45 <roconnor> how do I create a pipe?
01:27:47 <ManateeLazyCat> emilmeln: Similar like that, but have some different.
01:27:50 <ivanm> didn't I say Live Integrated Environment? :p
01:27:58 <ManateeLazyCat> roconnor: I'm not use pipe, i use DBus.
01:28:02 <ivanm> roconnor: between two processers?
01:28:07 <ivanm> @hoogle pipe
01:28:07 <lambdabot> Network.Socket AF_WANPIPE :: Family
01:28:07 <lambdabot> Network.Socket.Internal AF_WANPIPE :: Family
01:28:07 <lambdabot> Foreign.C.Error ePIPE :: Errno
01:28:12 <ManateeLazyCat> roconnor: All processes communication through DBus.
01:28:29 <emilmeln> ManateeLazyCat: What's the difference?
01:28:33 <roconnor> ivanm: I want to send a haskell string as stdin to a process I run
01:28:43 <ManateeLazyCat> ivanm: Oh,  yes Live Integrated Environment.
01:28:54 <ivanm> roconnor: oh, that's easy
01:28:59 * ivanm digs out where he's done that
01:29:04 <ivanm> roconnor: you use the process library
01:29:05 <ManateeLazyCat> roconnor: Use dbus-core and dbus-client.
01:29:26 <ManateeLazyCat> roconnor: Use interactiveRunCommand ?
01:29:36 <emilmeln> roconnor: Maybe you need System.Process?
01:29:45 <ivanm> roconnor: depending upon how complicated you want it: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle%27
01:29:48 <Ke> as I said earlier, I would just love++ abstract ipc library
01:29:50 <ivanm> using runInteractiveProcess
01:29:56 <ivanm> @karma love
01:29:56 <lambdabot> love has a karma of 1
01:30:06 <roconnor> oh
01:30:18 <ManateeLazyCat> emilmeln: Becuase i use Xembbed Protocol to implementation my program, so it's looks like natural gtk+ program.
01:30:36 <ivanm> @type runCmd
01:30:36 <lambdabot> Not in scope: `runCmd'
01:30:46 <emilmeln> :t runInteractiveCommand
01:30:47 <lambdabot> Not in scope: `runInteractiveCommand'
01:30:48 <ivanm> @hoogle system
01:30:48 <lambdabot> No results found
01:30:53 <emilmeln> @type runInteractiveCommand
01:30:54 <lambdabot> Not in scope: `runInteractiveCommand'
01:30:55 <ivanm> grrr...
01:30:56 <ManateeLazyCat> emilmeln: But because i use GtkSocket/GtkPlug and DBus to build multi-process framework, so in principle, it's like environment more than application.
01:31:23 <ManateeLazyCat> @type runInteractiveCommand
01:31:24 <lambdabot> Not in scope: `runInteractiveCommand'
01:31:30 <ivanm> roconnor: system is another approach methinks
01:31:32 <emilmeln> @import System.Process
01:31:33 <lambdabot> Unknown command, try @list
01:31:36 <ManateeLazyCat> roconnor: Is runInteractiveCommand, i'm sure.
01:31:46 <ivanm> no, wait, it doesn't accept stdin
01:31:47 <roconnor> ManateeLazyCat: thanks
01:31:49 <emilmeln> runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
01:31:53 <ivanm> roconnor: you want to use something from process, anyway
01:32:07 <ivanm> roconnor: my example above uses runInteractiveCommand, as does Cabal
01:32:18 <ManateeLazyCat> roconnor: runInteractiveCommand return (inputHandle, outputHandle, errorHandle, processHandle).
01:32:20 <roconnor> oh damn
01:32:21 <ivanm> actually, I use runInteractiveProcess
01:32:23 <roconnor> readProcess!
01:32:25 * ivanm forgets the difference
01:32:30 <ivanm> @hoogle readProcess
01:32:30 <lambdabot> No results found
01:32:31 <ManateeLazyCat> roconnor: So you just "hPutStr inputHandle yourstring"
01:32:32 <ivanm> bah
01:33:02 <roconnor> readProcess 
01:33:03 <roconnor>     :: FilePath                 -- ^ command to run
01:33:04 <roconnor>     -> [String]                 -- ^ any arguments
01:33:06 <roconnor>     -> String                   -- ^ standard input
01:33:07 <roconnor>     -> IO String                -- ^ stdout + stderr
01:33:50 <ManateeLazyCat> emilmeln: My framework like Chrome, but more general, and not just for browser.
01:34:45 <ivanm> roconnor: right; be careful if you don't want stderr mixed up with stdout
01:35:01 <roconnor> my process has no output
01:35:12 <ivanm> even better then
01:35:13 <roconnor> readProcess "xclip" [] "Testing"
01:35:29 <roconnor> it works
01:35:34 <roconnor> but the process never ends :(
01:35:46 <ziman> @index readProcess
01:35:47 <lambdabot> bzzt
01:36:06 <Saizan> yours or xclip?
01:36:08 <emilmeln> ManateeLazyCat: Actually, I don't have expirience in that things. I've thought that you are writing something like XFCE.
01:36:13 <Saizan> maybe you need -threaded
01:36:18 <roconnor> xclip
01:36:20 <roconnor> or mine
01:36:21 <roconnor> not sure
01:36:37 <roconnor> Testing
01:36:37 <ManateeLazyCat> emilmeln: No, i'm written SuperEmacs, but not just for Text world.
01:36:38 <roconnor> 
01:37:02 <ManateeLazyCat> emilmeln: But safer and faster.
01:37:30 <hamishmack> roconnor: Process probably won't end until output it read.  Just check it is empty as you expect.
01:37:47 <roconnor> pft
01:37:49 <roconnor> stupid
01:37:54 <roconnor> xclip doesn't produce output
01:38:03 <ivanm> you should be right then
01:38:07 <roconnor> no
01:38:18 <roconnor> readprocess is waiting for the output
01:38:22 <roconnor> which will never come
01:38:25 <Saizan> readProcess forks a thread to read the output, it won't get blocked on that.
01:38:27 <ivanm> if you need something like that though, then do something like ">>= (evaluate . length)"
01:38:27 * roconnor adds -verbose flag
01:38:38 <roconnor> oh
01:38:55 <ivanm> just to force it
01:39:18 <roconnor> @hoogle evaluate
01:39:18 <lambdabot> Control.Exception evaluate :: a -> IO a
01:39:18 <lambdabot> Control.OldException evaluate :: a -> IO a
01:39:18 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
01:39:21 <ivanm> roconnor: my guess is that the input handle isn't explicitly closed, so xclip is just sitting there waiting for the input to finish coming in, etc.
01:39:23 <Saizan> it seems like xclip wants EOF twice though, i've to give it ^D twice at least
01:39:34 <ivanm> roconnor: evaluate is analogous to seq but using IO
01:40:13 <ziman> roconnor, the content of the clipboard seems to be alive only while xclip is running, here
01:40:22 <roconnor> ziman: ya, strang :(
01:40:25 <roconnor> strange
01:40:28 <roconnor> ;(
01:40:30 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/src/System-Process.html#readProcess <- the input handle is explicitly closed, and the output is already forced
01:41:33 <ManateeLazyCat> ivanm: Live Integrated Environment is right syntax? And not "Integrated Live Environment" ?
01:42:08 <ivanm> look at what the acronym is... ;-)
01:42:26 <ManateeLazyCat> ivanm: Ok, i change my hanatee.cabal. :)
01:42:56 <roconnor> ah!
01:43:06 <roconnor> xclip ends after someone else selects something!
01:43:08 <roconnor> nice
01:43:57 <ManateeLazyCat> ivanm: I hope someday, i can use my SuperWeapon kill all applications that not written by Haskell. :)
01:44:07 <ManateeLazyCat> ivanm: Joking...
01:44:16 <ivanm> roconnor: heh
01:44:22 <ivanm> what, it just backgrounds?
01:44:29 <roconnor> no, it foregrounds
01:44:35 <roconnor> afaik
01:49:21 <ManateeLazyCat> If anyone found bug at http://hackage.haskell.org/package/poppler-0.11.0 , please send bug report to lazycat.manatee@gmail.com Thanks!
01:49:30 <ManateeLazyCat> It's time to coding ... bye all. :)
02:04:29 <BMeph> Sleep for me - g'night...
02:05:15 <roconnor> I can do tab completion with writeFile in ghci!
02:05:18 <roconnor> for file names!
02:05:30 <roconnor> wtf?
02:05:34 <roconnor> how does it know?
02:05:46 <roconnor> I should start using ghci for my shell
02:06:44 <emilmeln> It's linked with libedit.
02:06:57 <emilmeln> But no completion for Emacs session...
02:07:13 <Saizan> it's not linked with libedit anymore :)
02:07:41 <ReinH> can anyone give me an example of Test.QuickCheck.sample ?
02:07:42 <emilmeln> Ah , Haskeline?
02:07:53 <Saizan> yup
02:08:09 <ReinH> all the QuickCheck info out there aside from the docs only cover 1.x
02:09:06 <Saizan> e.g. "sample (arbitrary :: Gen Int)"
02:09:45 <Saizan> should print a bunch of Int's to stdout
02:10:02 <krainboltgreene> Hmm, so a question: HTML rendering engine in Haskell? Possible?
02:10:22 <emilmeln> Saizan: btw, do you know why they are using ghc-binary boot package instead of "normal" binary. I've browsed their code, and it seems that they are idetical.
02:12:22 <Saizan> emilmeln: i don't know, sorry
02:14:17 <Saizan> krainboltgreene: it seems so http://www.cse.chalmers.se/~hallgren/Thesis/wwwbrowser.html
02:15:20 <emilmeln> http://hackage.haskell.org/package/webkit
02:16:26 <pokoko222> someone can help me with Microsoft Project question?
02:21:02 <pokoko222> edwardk was around a while ago?
02:22:48 <Lemmih> preflex: @seen edwardk
02:22:49 <preflex>  edwardk was last seen on #haskell 8 hours, 23 minutes and 59 seconds ago, saying: er +1
02:23:36 <pokoko222> i hope he comes soon
02:29:54 <m3ga> what does the question mark in 'let ?args = setupArgs setup' mean?
02:30:47 <emilmeln> m3ga: ?args is implicit parameter.
02:31:30 <ReinH> Saizan: well that's stupid easy, I wonder what I was doing before that didn't work
02:32:27 <Saizan> ReinH: maybe you forgot the type annotation
02:36:09 <ReinH> Saizan: I think I just had the type annotation slightly wrong
02:43:53 <roconnor> is there an easy way to do HTTP post with HTTP 4000?
02:45:49 <Saizan> just set rqMethod to POST
02:46:10 <theorbtwo> "HTTP 4000"?  Do you mean port 4000, or is there a library with a silly name?
02:46:18 <roconnor> library
02:46:21 <Saizan> Form and formToRequest should also be useful
02:46:41 <roconnor> Saizan: where are they?
02:47:01 <michael|> Part of Network.Browser
02:47:32 <Saizan> yup, Network.Browser
02:47:40 <roconnor> undocumented :(
02:47:52 <roconnor> -- This form junk is completely untested...
02:47:53 <roconnor> :D
02:48:21 <Saizan> it worked in a throwaway script for me in the past :)
02:48:31 <roconnor> good enough
02:49:08 <m3ga> emilmeln: thanks. now i know what its called i have found some docs
02:51:20 <roconnor> @hoogle parseURI
02:51:20 <lambdabot> Network.URI parseURI :: String -> Maybe URI
02:51:20 <lambdabot> Network.HTTP.Base parseURIAuthority :: String -> Maybe URIAuthority
02:51:20 <lambdabot> Network.URI parseURIReference :: String -> Maybe URI
02:51:44 <michael|> Seems kind of silly for the library to call that Form though.
02:55:54 <scriptdevil> I get a (.text+0x19a7): undefined reference to `__stginit_stmzm2zi1zi2zi0_ControlziConcurrentziSTM_' while compiling a simple STM program
02:56:19 <Saizan> are you using --make ?
02:56:25 <Saizan> you should :)
02:57:04 <scriptdevil> Saizan: Oh. Ok :D 
02:57:26 <scriptdevil> Saizan: Works now :)
02:59:44 <Saizan> yay :)
03:10:06 <romildo> Hi.
03:10:21 <jedai> Hello
03:11:09 <romildo> Is there a symbol type in Haskell suitable for using in a compiler, with constant time comparison?
03:11:48 <jedai> romildo: search for atom on hackage
03:12:41 <jedai> romildo: http://hackage.haskell.org/package/stringtable-atom-0.0.6.1
03:13:17 <jedai> I don't know if there's another better solution around but this one is probably pretty good for your usecase
03:13:55 <romildo> jedai, i am taking a look at it. thanks.
03:49:24 <roconnor> Saizan: hmm, things like content-type and content-length are not being set :(
03:50:40 <Saizan> roconnor: no? for POST the code seems to be quite explicit about setting them http://hackage.haskell.org/packages/archive/HTTP/4000.0.9/doc/html/src/Network-Browser.html#Form
03:50:50 <roconnor> hmm
03:52:28 <roconnor> Saizan: oh, maybe setHeaders is clobbering them
03:53:20 * hackagebot Encode 1.3.4 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.4 (OtakarSmrz)
03:53:29 <roconnor> ah insert headers
03:55:21 * hackagebot bindings-sqlite3 1.0.1 - Low level bindings to sqlite3.  http://hackage.haskell.org/package/bindings-sqlite3-1.0.1 (MauricioAntunes)
04:05:58 <roconnor> I wish instead of plus patterns, haskell had string prefix patterns
04:06:13 <roconnor> so I could write foo ("22"++x) = ...
04:06:18 <ivanm> instead of doing foo ('a':'b':'c':chars) ?
04:06:21 <roconnor> ya
04:06:41 <roconnor> I'm now writing ' ':'w':'i':'t':'h':' ':'s':'i':'z':'e':' ':x
04:07:03 <Saizan> ?type stripPrefix
04:07:04 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
04:07:42 <Saizan> foo s | Just x <- stripPrefix " with size " s = ..
04:08:03 <roconnor> true
04:08:07 <wvd> I'm trying to install priority-sync on Hackage using cabal but it fails at the final step, anyone has an idea? http://codepad.org/lQKORgek
04:08:08 <Saizan> or "foo (stripPrefix " with size " -> Just x) = .."
04:08:10 <roconnor> @index stripPrefix
04:08:10 <lambdabot> bzzt
04:08:18 <Saizan> Data.List
04:08:19 <roconnor> is stripPrefix in Data.List?
04:09:12 <portnov> @hoogle stripPrefix
04:09:12 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
04:09:25 <Saizan> wvd: i think the library got installed though
04:09:37 <roconnor> oh wait
04:09:47 <roconnor> this doesn't work on the lefthand side of a let
04:09:57 <roconnor>    let [(cid,' ':'w':'i':'t':'h':' ':'s':'i':'z':'e':' ':drops')] = reads drops
04:10:03 <Saizan> wvd: check with "ghc-pkg list priority-sync"
04:10:33 <wvd> Saizan, http://codepad.org/7MmY6qcq
04:10:43 <Saizan> roconnor: i think it'll work with view patterns but not pattern guards
04:11:34 <Saizan> wvd: it seems you pasted the error from before again
04:12:02 <wvd> Saizan, no, see. roguestar-gl depends on the priority thing.
04:12:53 <Saizan> ah, i see
04:14:00 <mreh> is "IO a" a type synonym in practice?
04:14:08 <Saizan> i think it's having problems with the name of the executable
04:14:43 <Saizan> mreh: in ghc it's a newtype, in haskell is just abstract
04:14:55 <Tomsik> mreh: within the monad, yes
04:15:05 <Tomsik> otherwise, no
04:15:09 <Saizan> well IO is
04:15:28 * hackagebot bindings-libcddb 0.3 - Low level binding to libcddb.  http://hackage.haskell.org/package/bindings-libcddb-0.3 (MauricioAntunes)
04:15:54 <Saizan> wvd: you could "cabal unpack priority-sync" then cd into the directory, edit the .cabal file deleting the whole Executable section and then run "cabal install" from that directory
04:15:54 <mreh> is newtype just used for encapsulation?
04:16:03 <Saizan> ?src IO
04:16:03 <lambdabot> Source not found. stty: unknown mode: doofus
04:16:11 <mreh> that's the only thing I've used it for
04:16:31 <Saizan> and to be able to define the monad instance
04:19:29 * hackagebot bindings-gobject 0.2 - Low level bindings to GObject.  http://hackage.haskell.org/package/bindings-gobject-0.2 (MauricioAntunes)
04:20:31 * hackagebot regex-xmlschema 0.1.4 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/regex-xmlschema-0.1.4 (UweSchmidt)
04:23:52 <Feuerbach> and not only Monad, of course
04:29:31 * hackagebot bindings-libffi 0.3 - Low level bindings to libffi.  http://hackage.haskell.org/package/bindings-libffi-0.3 (MauricioAntunes)
04:35:27 <FunctorSalad> mreh: newtype is used to make it harder to accidentally mix up things that have the same representation as data, but represent totally different things
04:37:23 <FunctorSalad> and also to work around limitations with typeclasses ;o
04:38:07 <dibblego> also a different representation with a restriction on construction, implemented as an abstract type
04:43:35 * hackagebot regex-xmlschema 0.1.5 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/regex-xmlschema-0.1.5 (UweSchmidt)
04:46:35 * hackagebot hstatistics 0.1.0.5 - Statistics  http://hackage.haskell.org/package/hstatistics-0.1.0.5 (VivianMcPhail)
04:53:20 <illissius> what's the best data structure for a map with Int keys which gets constructed once, and then never again mutated-copied-updated or anything else, and I just want lookups to be as fast as possible? plain Map?
04:54:06 <illissius> (typically, the number of elements will be countable on one or two hands)
04:54:14 <Tomsik> I'm not sure it's implemented at all, but you could do interpolation search to go to log log n :p
04:54:43 <Tomsik> why'd bother with selecting data structures if you've got so few elements
04:54:59 <Tomsik> you could even have just a list of these
04:55:04 <wli> IntMap
04:55:22 <ClaudiusMaximus> how dense are the keys? maybe some kind of Array would work?
04:55:34 <illissius> Tomsik: lookups could happen quite frequently though
04:55:38 <wli> Why bother is to use API's.
04:55:57 <Tomsik> illissius: implementation constant is more important then
04:56:22 <wli> It may literally be slower to have call overhead but the API reuse and wheel reinvention avoidance is the important part.
04:57:02 <illissius> wli: as far as I can tell IntMap is optimized for inserts/deletes not lookups -- lookups can be linear while they're logarithmic with Map
04:57:31 <illissius> anyway I'll just go with Map for now and change it later once I get to the point where it works at all and I can try optimizing
04:57:58 <wli> Map is fine for wheel non-reinventing using standard API's etc.
04:58:49 <wli> (I can rarely be arsed to specialize to IntMap myself.)
04:59:00 <Tomsik> illissius: what are you doing that you need to think about such small differences?
04:59:45 <Saizan> lookups can be linear with IntMap? really?
05:00:06 <illissius> Saizan: linear up to the number of bits in the int type iirc
05:00:59 <Saizan> ah, yeah, makes sense
05:01:48 <illissius> Tomsik: basically I figured out how to do something Typeable-ish except for (existentials of) typeclass instances
05:01:59 <illissius> this is all kinds of premature optimization but it'd be nice to know regardless
05:02:25 <Saizan> though the specialization could still mean that the lookup is faster even for small maps
05:07:42 * hackagebot gtk2hs-rpn 0.2 - Adds a module to gtk2hs allowing layouts to be defined using  reverse polish notation.  http://hackage.haskell.org/package/gtk2hs-rpn-0.2 (MauricioAntunes)
05:09:25 <ivanm> seriously? rpn notation for layouts? :/
05:09:43 <Tomsik> that makes sense to me
05:31:15 <_2easy> hi, is there a predefined function in haskell which has signature (a -> Bool) -> [a] -> Bool ? In words which takes function(condition) and if all elements of the list satisfies the condition it returns True, otherwise False?
05:32:30 <Igloo> all
05:33:17 <ivanm> @hoogle (a -> Bool) -> [a] -> Bool
05:33:17 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:33:17 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
05:33:17 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
05:33:18 <sepp2k> @hoogle (a -> Bool) -> [a] -> Bool
05:33:18 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:33:18 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
05:33:19 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
05:33:23 <_2easy> Igloo: thanks
05:34:23 <_2easy> oh, i havent know about this, thanks a lot
05:45:56 <ski> > all isUpper "ACK"
05:45:56 <lambdabot>   True
05:46:44 <ski> > (`all` "ACK!") $ \c -> not (isLower c)
05:46:45 <lambdabot>   True
06:00:46 <soupdragon> @seen wli
06:00:46 <lambdabot> Unknown command, try @list
06:00:55 <Jonno_FTW> @src words
06:00:55 <lambdabot> words s = case dropWhile isSpace s of
06:00:55 <lambdabot>     "" -> []
06:00:55 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:00:55 <soupdragon> preflex: seen wli
06:00:55 <preflex>  wli was last seen on #haskell-blah 50 minutes and 17 seconds ago, saying: What reads that config file and is it really "gentoo" etc.?
06:04:17 <soupdragon> http://pastie.org/1012320.txt here is a double pendulum 
06:04:59 <soupdragon> it uses automatic differentiation to simulate the motion
06:09:48 <Saizan> soupdragon: which package provides "Graphics"?
06:09:55 <soupdragon> dammit
06:09:57 <soupdragon> sorry about that
06:10:31 <soupdragon> http://pastie.org/1012331.txt
06:10:42 <soupdragon> that's the same file with the import resolved
06:12:04 <KaffeeJunky123> is haskell>perl?
06:12:19 <Saizan> i probably need to fix something with OpenGL/GLUT, i get a segfault :\
06:12:29 <soupdragon> oh that is a shame
06:14:38 <pastorn> KaffeeJunky123: maybe not for golfing :)
06:15:00 <pastorn> Saizan: what are you trying to do?
06:15:19 <pastorn> you know that you get segfault if you don't initialize GLUT in the correct order, right?
06:16:38 <wli> What did I do this time?
06:16:55 <soupdragon> wli I got my double pendulum to work finalyl!
06:17:02 <wli> yay
06:17:18 <soupdragon> I forgot to eliminate some variables in the hamiltonian 
06:17:54 <soupdragon> I tried to do 3-body problem next but now that doesn't work.
06:19:11 <wli> I think symplectic integrators have to be tuned to the specific Hamiltonian etc.
06:19:33 <soupdragon> wli mine is a very basic one though like euler integration
06:19:49 <wli> It probably only works for what it does because kinetic energy looks the same.
06:20:00 <soupdragon> ah I see
06:22:09 * hackagebot hsignal 0.1.0.4 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.0.4 (VivianMcPhail)
06:22:58 <soupdragon> this is the n-body problem http://www.mpa-garching.mpg.de/galform/virgo/millennium/seqD_063a_half.jpg
06:23:14 <soupdragon> I can't even do 3 body >:(
06:25:53 <Bigcheese> soupdragon: that project was amazing.
06:26:43 <illissius> hmm... how do I do a TH function which constructs an instance, where the class is a given and the type that should be made an instance of it is a parameter? foo :: Name -> Q Dec; foo t = [d| instance Class $(conT t) |] says illegal instance declaration for t_aK0 and I need FlexibleInstances, while [d| instance $(appT [t|Class|] (conT t)) |] says malformed instance header
06:28:58 <illissius> (I could construct the whole instance without quotes but would rather not...)
06:30:24 <om-foxy> is it possible to get ghci to execute concurrently on multiple processors?  I get an 'unexpected RTS option' with ghci +RTS N2
06:34:40 <ivanm> om-foxy: try with -n2
06:34:56 <ivanm> nope, doesn't like that
06:35:06 <om-foxy> ah, -N2
06:41:36 <maltem> oh, nice to learn that multi-threaded ghci "just works"
06:49:39 <st0p> hi
06:50:51 <st0p> is it okay if i ask some n00b questions here?
06:50:59 <fxr> st0p: sure
06:51:03 <maltem> st0p, please, don't ask to ask!
06:51:27 <st0p> okay, out of educational interest, i'd like to write my own foldl function
06:51:44 <st0p> i came up wit this:
06:51:45 <st0p> foldl' :: (a -> b -> a) -> a -> [b] -> a
06:51:46 <st0p> foldl' _ _ [] = []
06:51:46 <st0p> foldl' f x (y:ys) = f x y : foldl' f x ys
06:52:16 <st0p> which give me the following error message:
06:52:18 * hackagebot bindings-DSL 1.0.7 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.7 (MauricioAntunes)
06:52:18 <st0p> Occurs check: cannot construct the infinite type: a = [a]
06:52:18 <st0p> When generalising the type(s) for `foldl''
06:52:29 <maltem> st0p, you got the base case wrong
06:52:36 <maltem> you're returning a list there
06:52:56 <maltem> where you'd rather want to return the accumulated value
06:54:01 <st0p> you mean like this:
06:54:03 <st0p> foldl' _ x [] = x
06:54:27 <st0p> makes sense, but still gives me the same error
06:54:45 <Lemmih> st0p: Your recursive case is also incorrect.
06:55:34 <ski_> st0p : your recursive case is `... : ...', i.e. a call to `(:)', which constructs a list
06:55:51 <ski_> while your type says you don't want to return a list, but something of type `a'
06:56:49 <ski_> st0p : if you call  foldl' f z [a,b,c,d]  then you do know what this should simplify to, yes ?
06:57:06 <st0p> yeah, i can see my logic is flawed
06:57:24 <st0p> this compiles:
06:57:26 <st0p> foldl' :: (Num a) => (a -> b -> a) -> a -> [b] -> a
06:57:26 <st0p> foldl' _ x [] = x
06:57:27 <st0p> foldl' f x (y:ys) = f x y + foldl' f x ys
06:57:40 <maltem> lol, I didn't even notice that the recursive case is wrong too. It looked so nice
06:58:00 <ski_> that assumes `a' is a numeric type .. which you shouldn't assume (since it needn't be)
06:58:13 <maltem> st0p, yeah that's because (+) :: (Num a) => a -> a -> a
06:58:47 <ski_> st0p : again, you know that `foldr f z [a,b,c,d]' simplifies to `f a (f b (f c (f d z)))', yes ?
06:58:56 <st0p> and also seems to give me the same results as using the official foldl
06:59:00 <ski_> st0p : what should `foldl f z [a,b,c,d]' simplify to ?
07:00:06 <ski_> st0p : i doubt that, try it with   foldl' (\s n -> concat ["(",s," + ",show n,")"]) "0" [4,5,6,7]
07:00:09 <maltem> st0p, your last version does something different that foldl. It's a fold too, but it folds a different function over the list
07:00:32 <ski_> (i.e. try both  foldl  and your  foldl'  with that)
07:00:44 <st0p> btw: am i the only one who is learning a lot (learned a lot if you already know haskell) by implementing functions which are already in the prelude?
07:01:03 <ski_> not at all
07:02:00 <ski_> it is good exercise to get familiar with simple recursion, worker-wrapper, and the various syntax things like patterns, guards, `where', `let', type signatures, &c.
07:04:08 <st0p> i'm trying it right now, not seeing the error yet
07:05:26 <st0p> it should simply to f d (f c (f b (f a z))))
07:06:35 <soupdragon> st0p what's foldl f z (x:xs) ?
07:06:39 <benmachine> st0p: z :: a right? so f a z doesn't work
07:06:55 <ski_> correct (apart from that you need to flip the order of argument to each `f')
07:07:04 <ski_> hint : do you see any `+' in there
07:07:06 <ski_> ?
07:07:41 <illissius> st0p: after that you can try project euler :)... and after that some actual application which does useful things of nontrivial size
07:11:42 <st0p> i can see that there is no + there, but i'm not sure how to solve it
07:13:17 <p0ts> oops, wrong button
07:14:40 <p0ts> exit
07:16:28 <Gracenotes> hm. there's not much of a difference between state and writer in CPS'd monads, is there?
07:16:32 <maltem> st0p, just take the term    f d (f c (f b (f a z))))   and replace some of it by a recursive call
07:17:12 <Gracenotes> and reader for that matter. isn't there a lambdabot plugin that calculates it for you..
07:17:22 <Gracenotes> @commands
07:17:22 <lambdabot> Unknown command, try @list
07:17:26 <Gracenotes> @list
07:17:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:20:15 <st0p> would this be correct:
07:20:52 <st0p> foldl' f x (y:ys) = foldl' f (f x y) ys
07:27:16 <aavogt> st0p: what's the ' supposed to mean?
07:27:45 <ski_> aavogt : myFoldl
07:27:50 <st0p> well, i use it to indicate it's my own version of a function already in the prelude
07:28:10 <st0p> @ski_: correct
07:28:10 <lambdabot> Unknown command, try @list
07:28:11 <aavogt> @type foldl
07:28:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:28:23 <ski_> st0p : with what base case ?
07:28:44 <st0p> foldl' _ x [] = x
07:29:59 <ski_> so, let's evaluate using this
07:30:38 <ski_>      foldl' (+) 0 [2,3,5]
07:31:06 <ski_>   =  foldl' (+) (0 + 2) [3,5]  -- by recursive equation
07:31:16 <ski_>   =  foldl' (+) ((0 + 2) + 3) [5]  -- by recursive equation
07:31:26 <ski_>   =  foldl' (+) (((0 + 2) + 3) + 5) []  -- by recursive equation
07:31:48 <ski_>   =  ((0 + 2) + 3) + 5  -- by base case
07:31:56 <ski_>   =  (2 + 3) + 5  -- arithmetic
07:32:01 <ski_>   =  5 + 5  -- arithmetic
07:32:05 <ski_>   =  10  -- arithmetic
07:33:01 <ski_> note that `f x y' when `f = (+); x = 0; y = 2' is `(+) 0 2' which is the same as `0 + 2', &c.
07:33:20 <ski_> st0p : so, does that look like your equations do the job ?
07:33:28 * ski_ sighs ..
07:33:30 * hackagebot bindings-posix 1.2.2 - Low level bindings to posix.  http://hackage.haskell.org/package/bindings-posix-1.2.2 (MauricioAntunes)
07:33:53 <mreh> could you say there is an invisible root node for a haskell program that includes all the top level definitions and imported functions as children
07:34:16 <ski_> "imported functions as children" meaning ?
07:34:43 <mreh> well, I see haskell prorams as graphs
07:34:45 <ski_> you could view the top-level `module Foo (...) where ...' as the root node, yes
07:35:12 <st0p> apparently my connection isn't really stable
07:35:26 <Gracenotes> directly acyclic graphs at least
07:35:29 <Gracenotes> *directed
07:35:54 <st0p> ski_: sorry if i missed everything after you wrote so, let's evaluate using this
07:36:16 <Gracenotes> uh. there may be more than one root per module forest, but there's only one root per program
07:36:22 <ski_> st0p : see private messages
07:36:35 <mreh> Gracenotes: that's what I wanted to hear, cool thanks
07:36:48 <mreh> awesome nick
07:36:58 <maltem> st0p, in case you missed a large part of what has been said, see the logs (link in the topic)
07:39:55 <Gracenotes> so I've been thinking about CPS'd monads. e.g., ErrorT e (StateT s IO) a, more generally, is like: forall r. (e -> IO r) -> (a -> s -> IO r) -> s -> IO r. what would it look like encoding RWST instead of StateT?
07:40:38 <ski_> @let st0p_foldl _ x [] = x; st0p_foldl f x (y:ys) = st0p_foldl f (f x y) ys
07:40:40 <lambdabot>  Defined.
07:40:57 <ski_> > st0p_foldl f x [2,3,5,7,11] :: Expr
07:40:58 <lambdabot>   f (f (f (f (f x 2) 3) 5) 7) 11
07:42:40 <Gracenotes> I'm wondering what the best place for the writer state is, for instance.. does the middle function have to become (a -> s -> w -> IO r)?
07:42:40 <ski_> @unmtl ErrorT e (StateT s IO) a
07:42:40 <lambdabot> s -> IO (Either e a, s)
07:43:55 <Gracenotes> and a -> s -> w -> rd -> IO r for all of RWS
07:44:03 <ski_> Gracenotes : i'm not convinced `forall r. (e -> IO r) -> (a -> s -> IO r) -> s -> IO r' is a valid encoding of `ErrorT e (StateT s IO) a' ..
07:45:05 <Gracenotes> ski: oh.. hm. it's more of an encoding of unmtl'd IO (Either e (a, s)), right?
07:45:54 <Gracenotes> I haven't particularly done much CPS encoding of monad stacks before :/
07:45:56 <ski_> Gracenotes : i was thinking of `Either (IO e) (IO (a,s))' ..
07:46:11 * ski_ ponders
07:48:07 <Gracenotes> I suppose it doesn't have to be a one-to-one encoding, just one that's capable of emulating the monad in question
07:48:14 <ski_> hm, in `forall r. (e -> IO r) -> (a -> s -> IO r) -> s -> IO r', if we instantiate `r' to `(Either e a,s)', then how do we construct `e -> IO (Either e a,s)' and `(a -> s -> IO (Either e a,s))', so that we can recover `s -> IO (Either e a,s)' ?
07:48:34 <ski_> well, `a -> s -> IO (Either e a,s)' is `\a s -> return (Right a,s)'
07:48:57 <ski_> but i don't see how we construct `e -> IO (Either e a,s)' ..
07:48:59 <Gracenotes> the error function can only exist as e -> IO (Either e (something else))
07:49:41 <ski_> if `s -> IO (Either e a, s)' is equivalent to `forall r. (e -> IO r) -> (a -> s -> IO r) -> s -> IO r', then we ought to be able to convert back and forth between them (and both compositions should be `id')
07:49:54 <Gracenotes> in my case, I don't particularly care about the state in the case of failure, so no MTL lines up with it
07:51:16 <Gracenotes> hm.
07:54:38 <_Cactus_> hi
07:54:54 <_Cactus_> I have a backtracking code that uses the [] monad. what's the easiest way to make it breadth-first?
07:55:18 <soupdragon> well not exactly breadh first but fair, by changing >>= to >>- from LogicT
07:55:37 <_Cactus_> that's all?
07:55:53 <Gracenotes> I thought the [] monad did breadth-first (non-deterministic)
07:56:25 <aavogt> > do x <- "ab"; y <- "xy"; return [x,y]
07:56:26 <lambdabot>   ["ax","ay","bx","by"]
07:56:33 <Gracenotes> with LogicT being the backtracking one
07:56:45 <Gracenotes> prolog-esque
07:57:02 <aavogt> breadth first would be    ax bx ay by ?
07:57:06 <soupdragon> you have got it the wrong way around
07:57:10 <soupdragon> Grace
07:57:35 <soupdragon> > "ab" >>- \x -> "xy" >>- \y -> return [x,y]
07:57:36 <lambdabot>   ["ax","bx","ay","by"]
07:57:40 <soupdragon> > "ab" >>= \x -> "xy" >>= \y -> return [x,y]
07:57:41 <lambdabot>   ["ax","ay","bx","by"]
07:57:48 <Gracenotes> fair enough. monads are confusing me today.
07:58:10 <_Cactus_> so I guess what I want now is to automagically covert my code, which uses the do-notation, to explicit >>='s so I can change them to >>- where appropriate :)
07:58:14 <soupdragon> [] is DFS (the same search as prolog) but LogicT uses a more sophisticated procedure
07:58:55 <soupdragon> _Cactus_, there should be a better way than changing the source code but I don't know it
07:58:56 <Gracenotes> aaaah. right. DFS. I get it, sorry for the stupid
08:00:37 <benmachine> :t (>>-)
08:00:38 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
08:00:59 <_Cactus_> hrm
08:01:05 <_Cactus_> OK looks good so far
08:01:14 <_Cactus_> but something's still not breadth-first enough :)
08:02:17 <Gracenotes> ski_: I suppose my error monad could also be considered a bit closer to - ErrorT' e m a = ErrorT' { runErrorT' :: IO (Either e (m IO a)) }.. kind of a leaky abstraction though
08:03:12 <Gracenotes> s/e/IO e/ in the record field, maybe
08:04:28 <Ferdirand> @hoogle (>>-)
08:04:29 <lambdabot> No results found
08:04:35 <Gracenotes> in either case it's hard to generalize over m :/
08:04:57 <_Cactus_> uh-oh
08:05:08 <_Cactus_> it's still totally depth-first
08:05:12 * ski_ sometimes wishes `do mplus (do ...; x <- ...; ...) (...; x <- ...; ...); ..x..' would work
08:05:16 <_Cactus_> at least by my definition of depth-first:)
08:06:37 * _Cactus_ prepares an hpaste:)
08:06:44 <Gracenotes> yeah, I can't think of a way to decode it into a distinct error monad and rws-type monad. well, doesn't mean I can't try to saddle more writer/reader action onto it
08:07:50 <geheimdienst> so, in the wikibooks there's a chapter where they shoe-horn a Maybe onto an IO. something about monad transformers.
08:08:18 <geheimdienst> now i wanted something like that, but instead of the Nothing with an Errno 
08:08:41 <Feuerbach> geheimdienst: you can use Either monad
08:08:51 <geheimdienst> so i've stumbled on the ErrorT thingy. 1) am i on the right track? 2) how do i tell the ErrorT to fail?
08:08:52 <Gracenotes> if you declare a dummy instance Error of Errno
08:08:52 <Feuerbach> i.e. EitherT transformer
08:09:02 <ski_> `ErrorT Errno IO', if you can stand the `Error Errno' constraint in this case
08:09:07 <Gracenotes> @src MonadError
08:09:07 <lambdabot> class (Monad m) => MonadError e m | m -> e where
08:09:07 <lambdabot>     throwError :: e -> m a
08:09:07 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
08:09:38 <ski_> @hoogle EitherT
08:09:38 <lambdabot> No results found
08:09:41 <geheimdienst> ok, so that means i'd use things like "throwError ENOTFOUND" to go to the failure state, right?
08:09:42 <ski_> @hoogle ErrorT
08:09:43 <lambdabot> Control.Monad.Error newtype ErrorT e m a
08:09:43 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
08:09:43 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
08:10:01 <Gracenotes> yeah. the relevant instance is.. instance (Monad m, Error e) => MonadError e (ErrorT e m)
08:10:54 <_Cactus_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26401#a26401
08:11:04 <_Cactus_> so if I run this, I see that "n" grows
08:11:06 <geheimdienst> yes, Control.Monad.Error is what i stumbled upon. it exists in monads-tf and in mtl, but i added a cabal file to ignore monads-tf, whatever that is
08:11:16 <_Cactus_> which I think would be depth-first
08:11:51 <maltem> geheimdienst, transformers + monads-something is supposed to be an alternative mtl
08:12:19 <Gracenotes> is it true that transformers is supposed to replace mtl eventually?
08:12:48 <maltem> Depends on who you ask :p
08:13:04 <geheimdienst> transformers is supposed to inflict "ambiguous import" errors on unsuspecting newbies who just copy-pasted code from the web ...
08:13:05 <geheimdienst> ;-)
08:13:14 <geheimdienst> @hoogle throwError
08:13:14 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
08:13:24 <maltem> There's also mmtl, monadlib, possilby others
08:13:39 <_Cactus_> so basically my question would be, what in the above code makes it depth-first
08:13:53 <Gracenotes> don't tell me all of them use the same modules
08:14:32 <Gracenotes> or well. at least ghc's package manager is good enough to just hide the unused ones.
08:14:48 <geheimdienst> Gracenotes, i said an innocent "import Control.Monad.Error" and it told me it's ambiguous because mtl uses it and monads-tf
08:14:57 <maltem> Gracenotes, they call it "compatible apis" or "drop-in replacement" :)
08:15:18 <geheimdienst> both of which i'd never heard of. i somehow heard somewhere that mtl probably is the more mature, normal thing
08:15:38 <geheimdienst> anyway, thanks guys. you're great.
08:15:54 <Gracenotes> maltem: right, because if you use library foo that has an mtl MonadIO, you can drop-in transformers in your own modules and have it work seamlessly, right? :(
08:15:57 * geheimdienst will go ahead throwingErrors around and messing with ErrorT
08:17:01 <maltem> Gracenotes, sigh :) Though I think the point of transformers is so that you can use those classes independently of the implementations found in monads-â€¦
08:18:02 <aristid> heh, i just thought about a module wrapping all standard IO functions in MonadIO. maybe that even exists
08:19:27 <maltem> (or was it the other way around?)
08:19:41 <pastorn> aristid: i think i saw something about something like that... search reddit (like that ever works) for MonadIO and you might find it
08:22:15 <aristid> pastorn: didn't find
08:23:26 <pastorn> aristid: http://www.reddit.com/r/haskell/comments/cfd0m/monadio_migration/
08:23:32 <pastorn> dunno if that's what you want, though...
08:31:13 <_Cactus_> I've rewritten everything to explicitly calculate results in Logic
08:31:54 <_Cactus_> I just need to somehow interleave the recursive call with the branches
08:31:57 <shajen> is in haskell flatten function?
08:32:47 <_Cactus_> (which is what I thought >>- would give me)
08:35:54 <ski> @type concat
08:35:55 <lambdabot> forall a. [[a]] -> [a]
08:36:19 <ski> > concat [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:36:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
08:57:38 <om-foxy> dons: and the ball wasn't even the right shape!
08:58:10 <_Cactus_> OK got it breadth-first finally
08:58:18 <_Cactus_> now I just need to figure out a way to do the pruning
09:02:47 <roconnor> > [1,2,2,3] \\ [1,2,3]
09:02:48 <lambdabot>   [2]
09:10:14 <pielgrzym> hi :) can I stuff an if statement before guards in a function?
09:10:43 <aavogt> you can put guards in a case expression
09:11:05 <aavogt> > case 1 of _ | False -> 0; 1 -> 2
09:11:06 <lambdabot>   2
09:11:37 <aavogt> if you want to nest a bunch of pattern guards
09:11:41 <benmachine> pielgrzym: why would you want to
09:13:41 <pielgrzym> aavogt: benmachine: I'm trying to modify the bot from bot tutorial to have flood protection: http://wklej.org/id/353785/
09:13:59 <pielgrzym> I know the nature of return is different in haskel
09:14:16 <pielgrzym> but in bot tutorial there was a function for uptime that used return too ;)
09:14:33 <aavogt> so you want to decide what to do based on the Bool you get from running timecheck?
09:15:09 <pielgrzym> aavogt: no, I want to perform this check before even deciding to check what to do, so eval would return () if the check fails
09:15:27 <pielgrzym> I thought about moving "!quit" to guard
09:15:36 <pielgrzym> and putting the if before
09:15:43 <mak__> any now how to generate all permutation of functions?
09:15:46 <pielgrzym> it seems a little, err, imperative though ;)
09:15:51 <mak__> any one know*
09:16:22 <aavogt> it might be best to leave the definition of eval as is (maybe renamed to make it look like an intermediate function)
09:16:38 <pielgrzym> or maybye eval timecheck = return ()
09:16:39 <pielgrzym> hmm
09:16:53 <mak__> ie if i have a list of [foo,bar,baz] i want all posible composition of them
09:16:59 <benmachine> pielgrzym: if your flood protection triggers, do you want to just forget the message?
09:17:03 <aavogt> so you can then have:   do b <- timecheck; unless b (eval str)
09:17:22 <pielgrzym> benmachine: for now I just want to ignore it (and let it be printed on screen) :)
09:17:45 <benmachine> pielgrzym: is it to avoid the bot spamming, or to avoid people spamming the bot?
09:17:51 <pielgrzym> aavogt: aaah, good idea :) in the place where eval is used :))
09:17:55 <aavogt> consider also that your logic on line 12 is a bit redundant ;)
09:18:14 <pielgrzym> benmachine: the second thing (for now)
09:18:36 <aavogt> pielgrzym: or hide the current definition of eval in a where clause, with that same check done for the real eval
09:18:39 <benmachine> pielgrzym: ah, then yeah do what aavogt says :)
09:18:59 <pielgrzym> aavogt: ah, cool :)
09:19:46 <pielgrzym> hm, like:
09:20:02 <aavogt> sometimes I think it would be nice to have non-recursive let/where so that you don't have to make a new name for those intermediate functions
09:20:02 <pielgrzym> where \n eval x = if timecheck eval x else return () ?
09:20:13 <aavogt> @src when
09:20:13 <lambdabot> when p s = if p then s else return ()
09:20:35 <pielgrzym> hmmm
09:20:39 <benmachine> pielgrzym: also, if b then return False else return True = return (if b then False else True) = return (not b)
09:20:43 <aavogt> not like that since you have no then
09:21:00 <pielgrzym> aavogt: how cool! :)))
09:21:23 <Philippa> aavogt: do on the identity monad?
09:21:54 <benmachine> or let foo = bar in let foo = baz in foo
09:22:00 <benmachine> oh I guess that doesn't work
09:22:06 <aavogt> Philippa: I don't think we're using an identity monad here:  http://wklej.org/id/353785/
09:22:50 <pielgrzym> aavogt: this way (using when): if ping s then pong s else when timecheck (eval (clean s)) 
09:23:21 <pielgrzym> aavogt: or shorter: if ping s then pong s else when timecheck $ eval $ clean s ??
09:23:24 <aavogt> @type when
09:23:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:23:28 <Philippa> aavogt: there the lets are nested, so you can shadow the previous one
09:23:37 <aavogt> notice that it doesn't take a    m Bool
09:24:16 <pielgrzym> aavogt: so I have to change the type to Net () -> Bool ?
09:24:24 <pielgrzym> errr
09:24:25 <aavogt> Philippa: maybe just doing all the logic in pattern guards is better
09:24:26 <pielgrzym> Net ()
09:24:29 <pielgrzym> ?
09:25:29 <aavogt> @type \b f -> do b' <- b; f b
09:25:29 <lambdabot> forall (m :: * -> *) t b. (Monad m) => m t -> (m t -> m b) -> m b
09:25:43 <aavogt> @type \b f -> do b' <- b; when b f
09:25:44 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m t'
09:25:44 <lambdabot>     In the first argument of `when', namely `b'
09:25:44 <lambdabot>     In the expression: when b f
09:25:49 <aavogt> @type \b f -> do b' <- b; when b' f
09:25:50 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
09:26:00 <pielgrzym> aavogt: I got lost, sorry ;)
09:26:17 <benmachine> :t (flip when =<<)
09:26:17 <pielgrzym> why are you showing a lambda function?
09:26:17 <lambdabot> forall (m :: * -> *). (Monad m) => (Bool -> m ()) -> Bool -> m ()
09:26:28 <benmachine> waaait what
09:26:33 <benmachine> :t (flip when >>=)
09:26:34 <lambdabot> forall (m :: * -> *) b. (Monad m) => ((Bool -> m ()) -> m () -> b) -> m () -> b
09:26:39 <benmachine> whaaaat
09:26:46 <geheimdienst> i'm wondering if this month's Ponder This lends itself to being solved with a haskell program ... *think* *think*
09:26:47 <geheimdienst> http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/June2010.html
09:27:06 <benmachine> oh
09:27:14 <benmachine> :t \thing -> (flip when thing =<<)
09:27:15 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m Bool -> m ()
09:27:19 <aavogt> pielgrzym: the definition of when doesn't run an action to give the Bool
09:27:39 <aavogt> if you have a  m Bool, you need to explicitly say that it is executed before you get to when
09:28:38 <aavogt> in your case, the `b' should be your timecheck function
09:28:43 <pielgrzym> aavogt: so I have to let tc = timecheck and put a tc instead of a function? is there some kind of usage example of when?
09:29:27 <aavogt> let doesn't accomplish anything there
09:29:41 <_Cactus_> aavogt: it should be tc <- timecheck; when tc $ do ...
09:29:51 <aavogt> you need to use    <-   in the do block to say that you run it before
09:30:04 <pielgrzym> aah, ok 
09:30:47 <pielgrzym> I'm invoking timecheck in listen :: Handle -> Net () and it claims it's not in scope (timecheck:: Net Bool), why?
09:30:58 <pielgrzym> The type signature for `timecheck' lacks an accompanying binding
09:31:15 <aavogt> you have a typo
09:31:27 <aavogt> > "timeckeck" == "timecheck"
09:31:27 <lambdabot>   False
09:31:50 <pielgrzym> aavogt: ah, right ;) phew ;)
09:32:53 <aavogt> @type liftM2 when
09:32:54 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m ()) -> m1 (m ())
09:33:35 <aavogt> @type (. join) liftM2 when
09:33:36 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m ()'
09:33:36 <lambdabot>     Probable cause: `when' is applied to too many arguments
09:33:36 <lambdabot>     In the second argument of `(. join)', namely `when'
09:33:46 <pielgrzym> aavogt: now I get it - if I use timecheck directly inside when it will fail sinde the type Net Bool does not match expected Bool, right?
09:33:59 <aavogt> @pl \b x -> join (liftM2 when b (return x))
09:33:59 <lambdabot> (join .) . (. return) . liftM2 when
09:34:08 <aavogt> right
09:34:36 <aavogt> because when isn't written with type      m Bool -> m () -> m ()
09:34:45 <aavogt> it could be, but it's not
09:34:58 <aavogt> @type \b x -> join (liftM2 when b (return x))
09:34:59 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
09:35:09 <pielgrzym> aavogt: what is an instance declaration?
09:35:11 <aavogt> @let whenM b x = join (liftM2 when b (return x))
09:35:12 <lambdabot>  Defined.
09:35:37 <pielgrzym> the floodInterval is apparently treated as plain int not Num TimeDiff and it fails to compile ;)
09:36:02 <aavogt> there are many ways to correct type errors
09:36:36 <pielgrzym> ah, timeDiff seems a complex type, can I somehow reduce it to int?
09:36:51 <pielgrzym> ah tdSec mydiff
09:36:54 <pielgrzym> probably :)
09:37:30 <pielgrzym> ha, yay :) it compiled :)
09:38:17 <illissius> bah
09:38:30 <illissius> TH supports neither GADTs nor ExistentialQuantification? :-(
09:39:16 <aavogt> illissius: IIRC it supports RankN types though
09:39:53 <aavogt> which means you can still deal with values that are sort of like those you get with ExistentialQuantification
09:39:54 <pielgrzym> aavogt: strange - it does not ignore the messages, it simply delays them, any idea why? (full src: http://wklej.org/hash/5e1c6e7a588/ )
09:40:20 <illissius> it's not going to let me reify an existential type either way :\
09:40:47 <illissius> (ironically it says "Can't reify a GADT data constructor" even if I'm actually using ExistentialQuantification)
09:41:00 <illissius> guess I'll have to wait, or figure out how to hack ghc and implement it myself...
09:41:02 <aavogt> reify has so much potential
09:41:32 <aavogt> too bad TH is pretty low priority for the ghc devs  :(
09:42:45 <pielgrzym> aavogt: nvm, I did not update the 'lastMsgTime' ;)
09:47:15 <pielgrzym> aavogt: sorry for dumb question - how can I actually update the lastMsgTime that is a part of: data Bot = Bot { socket :: Handle, lastMsgTime :: ClockTime } ?
09:47:58 <Zao> pielgrzym: Given a Bot b;  b { lastMsgTime = 9001 }
09:49:09 <pielgrzym> Zao: http://wklej.org/hash/5e1c6e7a588/ - I only use return (Bot h t) :(
09:55:31 <Sadache> anyone has experience with MiniHttp package?
09:56:07 <pielgrzym> how can I refer to monad instance from inside it? Like in Reader monad I user asks to retrieve monad fields, how can I update them?
09:56:23 <Sadache> i am trying to run a simple program and it is hanging with no result
09:59:17 <pielgrzym> how can I refer to monad instance from inside it? Like in Reader monad I user asks to retrieve monad fields, how can I update them?
10:00:06 <Lemmih> pielgrzym: What?
10:01:20 <pielgrzym> Lemmih: http://wklej.org/hash/5e1c6e7a588/ - take a peek at line 51 - I want to change from there lastMsgTime that is set in line 30 to the actual time (but I can't assing this a new value)
10:04:36 <pielgrzym> shit, I'm clueless
10:04:52 <pielgrzym> it's not possible to just assing a variable new value in haskell
10:05:07 <pielgrzym> so how the heck can I store the lastMsgTime??
10:05:37 <Lemmih> pielgrzym: I don't see what you're trying to do.
10:06:18 <pielgrzym> Lemmih: I want to set lastMsgTime to <- io getClockTime each time eval function is ran
10:06:47 <benmachine> pielgrzym: out of interest, why do you catch all exceptions in your loop?
10:07:04 <benmachine> pielgrzym: to answer your question, you can use an IORef
10:07:11 <pielgrzym> benmachine: it's a tutorial bot, I'm only modifying it for sake of understanding haskell ;)
10:07:27 <pielgrzym> benmachine: IORef? let me google
10:07:42 <benmachine> pielgrzym: they're in Data.IORef
10:07:56 <benmachine> they're references to a cell of memory that can be read or written using IO actions
10:08:12 <Sadache> I am looking for an http client that gets the result lazily
10:08:19 <benmachine> a bit like a variable in other languages
10:08:20 <Sadache> any suggestions?
10:08:26 <pielgrzym> benmachine: errr, cell of memory? like low level memory access?
10:08:36 <pielgrzym> benmachine: hmm
10:08:42 <benmachine> pielgrzym: not really, I'm just using that term to mean, a bit of memory
10:09:07 <pielgrzym> benmachine: so how to use it?
10:09:15 <pielgrzym> writeIOref/readIOref?
10:09:19 <benmachine> pielgrzym: the IO action newIORef will make one for you
10:09:21 <benmachine> and then yes
10:09:54 <pielgrzym> benmachine: so I don't need mine lastMsgTime in Bot anymore?
10:10:31 <benmachine> pielgrzym: you do, but you make it an IORef instead of the value exactly
10:10:41 <benmachine> IORef ClockTime
10:10:59 <pielgrzym> in data Bot = { socket ... } ?
10:11:01 <benmachine> then you do ref <- newIORef =<< getClockTime
10:11:04 <benmachine> yes
10:12:08 <Phyx-> > 1# +# 4#
10:12:09 <lambdabot>   Not in scope: `+#'
10:12:10 <pielgrzym> in line 30: ref <- newIORef =<< getClockTime?
10:12:15 <pielgrzym> benmachine: ^
10:12:24 <Phyx-> > 1# + 4#
10:12:25 <lambdabot>   Couldn't match kind `#' against `*'
10:12:40 <Phyx-> lol
10:12:41 <pielgrzym> benmachine: ah, lastMsgTime :: IORef ClockTime is like a pointer then, right??
10:12:47 <aristid> @hoogle +#
10:12:47 <lambdabot> No results found
10:12:49 <benmachine> pielgrzym: yeah, pretty much
10:12:56 <Lemmih> Phyx-: Psst, the answer is 5#.
10:13:05 <Phyx-> Lemmih: it is? :O
10:13:08 <benmachine> pielgrzym: note that like all haskell values, it's immutable, but in this case that just means it always points to the same thing
10:13:18 <benmachine> the value of the thing itself can change
10:13:43 <benmachine> er, to be more clear, it always points to the same bit of memory
10:13:48 <pielgrzym> benmachine: now it makes a lot of sense :) so basically can I create my own IORef kind of stuff or will I always use this thing in my 'unpure' part of apps?
10:13:50 <benmachine> but the contents of the memory can be changed
10:13:54 * Phyx- stops procrastinating now
10:14:04 <benmachine> pielgrzym: err, don't really know what you mean
10:14:44 <pielgrzym> benmachine: is it common to replicate this IORef mechanism on your own or is it a normal way to keep variables (mutable)?
10:14:54 <aavogt> you need to be in IO to manipulate IORefs
10:15:08 <aavogt> (as in read/write/create them)
10:15:19 <pielgrzym> connect :: IO Bot will do?
10:15:26 <benmachine> pielgrzym: I don't think you can implement it yourself very easily
10:15:45 <benmachine> connect :: IO Bot is fine yes
10:16:03 <pielgrzym> and later on I just should use liftIO?
10:16:06 <Phyx-> :t RealWorld
10:16:07 <lambdabot> Not in scope: data constructor `RealWorld'
10:16:10 <Phyx-> aww
10:16:30 <Phyx-> :t undefined :: RealWorld
10:16:31 <lambdabot>     Not in scope: type constructor or class `RealWorld'
10:16:41 <Phyx-> *shrug*
10:16:45 <sinelaw> yo
10:16:47 <Phyx-> yo
10:16:57 <sinelaw> sup?
10:17:03 <aavogt> you can do the liftIO earlier
10:17:11 <aavogt> might trigger the monomorphism restriction though
10:17:21 <Phyx-> sinelaw: procrastinating, :P
10:17:36 <pielgrzym> O_o
10:17:45 <pielgrzym> haskel *is* rocket science :/
10:18:07 <aavogt> @hackage dimensional
10:18:08 <lambdabot> http://hackage.haskell.org/package/dimensional
10:18:20 <aavogt> for your actual rocket science....
10:18:24 <Phyx-> no, it's at most argricultural science, in that you get a few rocks in the beginning but later on it's smooth sailing
10:18:38 <Phyx-> boy what a bad analogy
10:18:50 <sinelaw> Phyx- it's an art
10:19:05 <Phyx-> creating bad analogies?
10:19:14 <sinelaw> that and procrastinating
10:19:24 <Phyx-> ah, lol
10:19:32 <pielgrzym> shit, bot.hs:18:50: Not in scope: type constructor or class `IORef`
10:19:38 <pielgrzym> I feel totally helpless :/
10:19:41 <sinelaw> procrastinating is like drinking water through a green straw
10:19:45 <mauke> @index IORef
10:19:46 <lambdabot> Data.IORef
10:19:57 <Phyx-> I'm afraid I only have talent for the latter
10:20:11 <Phyx-> @src IORef
10:20:12 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
10:20:12 <pielgrzym> Not in scope: `newIORef'
10:20:37 <Phyx-> no i'm confused. so does lamndabot hide RealWorld or?
10:20:48 <mauke> there is no RealWorld
10:20:59 <pielgrzym> how come after reading a half dozen of haskell tutorial it's the first goddamn time I hear about scope :/ 
10:21:28 <mauke> pielgrzym: because scope is a really basic concept that appears in most programming languages
10:21:56 <Phyx-> mauke: that sounded philosophical\
10:22:06 <geheimdienst> so, i have an ErrorT Errno IO Something. i'm trying to say now: throwError eNOTDIR, which gives me "No instance for (Error Errno)". i think i need more monads. halp?
10:22:24 <pielgrzym> mauke: :)
10:22:27 <aavogt> geheimdienst: write the instance already
10:22:52 <aavogt> for once that suggestion ghc gives is correct
10:23:30 <aavogt> @unmtl ListT (ListT []) a
10:23:30 <lambdabot> [[[a]]]
10:24:14 <geheimdienst> sorry, man. i thought i'd ask, in case there's an import for that. i thought Error Errno might be common enough
10:24:27 <mauke> what's Errno?
10:24:43 <pielgrzym> what is wrong with line 67? -> http://wklej.org/id/353841/
10:25:06 <aavogt> pielgrzym: needs more =<< and liftIO
10:25:08 <mauke> :t asks
10:25:08 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
10:25:32 <mauke> pielgrzym: ptr <- asks lastMsgTime; last <- liftIO (readIORef ptr)
10:25:47 <pielgrzym> mauke: thank you :)
10:26:08 * aavogt would write   liftIO . readIORef . lastMsgTime =<< ask
10:26:24 * mauke prefers to keep things simple
10:26:58 <mauke> s/liftIO/io/g
10:27:07 <pielgrzym> aavogt: I don't have event the half IQ you do :P so stop :P
10:27:30 <aavogt> It's more about experience I think
10:27:36 <pielgrzym> mauke: I used io due to io :: IO a -> Net a \n io = liftIO :)
10:27:38 <pielgrzym> right?
10:27:46 <pielgrzym> aavogt: :)
10:27:51 <mauke> it's just pattern matching
10:29:42 <mauke> asks lastMsgTime >>= \ptr -> liftIO (readIORef ptr) >>= \last -> ...   -- desugar do notation
10:30:20 <mauke> ã€Œ\ptr -> liftIO (readIORef ptr)ã€ == ã€Œ\ptr -> (liftIO . readIORef) ptrã€ == ã€ŒliftIO . readIORefã€
10:30:37 <mauke> @src asks
10:30:37 <lambdabot> asks f = do
10:30:37 <lambdabot>     r <- ask
10:30:37 <lambdabot>     return (f r)
10:31:10 <aavogt> @type gets something
10:31:11 <lambdabot> forall u a (m :: * -> *). (Data a, MonadState (GenericQ (Maybe u)) m) => m (a -> Maybe u)
10:31:15 <mauke> asks f = ask >>= \r -> return (f r)
10:33:07 <aristid> :t ask
10:33:08 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:34:03 <aristid> @pl asks f = ask >>= \r -> return (f r)
10:34:04 <lambdabot> asks = (ask >>=) . (return .)
10:34:08 <pielgrzym> oh, yeah :)))) it works now :) thanks aavogt mauke benmachine Lemmih :)
10:36:27 * hackagebot uuagc 0.9.26 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.26 (ArieMiddelkoop)
10:36:32 <pielgrzym> could you guys just tell me if I formed updateTime correctly (lines 43 and 64)? I shouldn't use return in it, right? :)
10:36:38 <pielgrzym> it seems to work fine :)
10:42:18 <EvanR> :t sum
10:42:19 <lambdabot> forall a. (Num a) => [a] -> a
10:52:01 <Saizan> pielgrzym: http://wklej.org/id/353841/ <- in here?
10:56:37 <pielgrzym> Saizan: in here: http://wklej.org/id/353848/
10:56:41 <pielgrzym> :)
10:57:18 <tromp_> :t unfoldr
10:57:19 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:57:47 <Phyx-> why is there no unfoldl 
10:58:57 <Tomsik> reverse.unfolr ?
11:01:46 <Saizan> pielgrzym: the time part is fine, updateTime is a bit weird though, the most natural thing to do would be to make "updateTime :: Net ()" so without taking x and using it as last action, and then have "if ping s then pong s else when tc (do updateTime; eval (clean s))" in place of line 43
11:02:36 <tromp_> what is the precedence of shiftR and (.&.) ?
11:02:49 <mauke> tromp_: ask ghci
11:02:56 <tromp_> i forgot how:(
11:03:04 <mauke> :info
11:03:11 <tromp_> :info (.&.)
11:04:07 <Saizan> pielgrzym: also, some people would prefer stacking a StateT layer inside of Net rather than using an IORef, or at least hide the use of the IORef behind some combinators
11:04:22 <pielgrzym> Saizan: heh, didn't know about the ; thing :]
11:04:40 <pielgrzym> Saizan: just learned about ioref ;) but for sure I'll do it :)
11:04:50 <Saizan> you could also use layout to put it in two lines :)
11:06:25 <Saizan> http://wklej.org/id/353862/ <- like this
11:06:42 <Saizan> btw, "do x; y" desugars to "x >> y"
11:07:20 <bremner> or in this case sugars to :)
11:07:26 <Saizan> (the indentation of then and else wasn't required, but it looked nicer to me)
11:09:03 <pielgrzym> Saizan: cool :) thanks :) and I need to remove x from updateTime definition, too, right? in 69? :)
11:09:59 <Saizan> pielgrzym: ah, yeah and amend the type signature, i forgot about that :)
11:10:13 <pielgrzym> Saizan: thanks a lot for straightening this :)
11:10:25 <pielgrzym> I didn't realize about the simples option :]
11:10:43 <Saizan> np
11:11:59 <Sadache> what package do you suggest for doing lazy web requesting
11:12:13 <Sadache> by lazy I mean getting the response as a stream
11:13:11 <gwern> @remember turbopascal I heard that next year, the whole [ICFP] spec will be given in a made up alien language that you will have to decipher as step I.
11:13:11 <lambdabot> Nice!
11:14:36 <gwern> @flish
11:14:41 <aristid> lol "#scala is full of Haskell lurkers.  They bring a lambdabot with them to annoy Java people with what the types of things should be."
11:16:08 <edwardk> aristid: hahaha
11:17:19 <Saizan> Sadache: the HTTP package does that if you use String or lazy ByteString for the body, iiuc
11:18:40 <ddarius> edwardk: 'know anything about gaggle theory?
11:19:02 <edwardk> ddarius: i used to know a fair bit, but i've let it kind of fade away over the last 4 years or so
11:19:25 <ddarius> edwardk: What was your overall impression?
11:20:17 <ddarius> (Eventually, mathematicians are going to run out of different ways of saying "collection.")
11:20:36 <edwardk> well my major exposure to it was the Restall paper on it in the context of display logic, and from chasing down the references from that
11:21:05 <ddarius> That's what I'm reading now.  The references don't seem very handy.
11:21:19 <edwardk> well, the belnap papers aren't available online
11:21:28 <edwardk> which kind of set up the whole notion of display logic
11:21:56 <edwardk> that and the best paper on substructural logic on display seems to have vanished off the internet
11:22:09 <edwardk> i need to check and see if i still have it printed out somewhere
11:22:09 <Sadache> Saizan: good. But strangely that is not what is writting in RWH http://book.realworldhaskell.org/read/extended-example-web-client-programming.html
11:22:19 <int80_h> I just installed ghc-6.8.3, where can I find cabal?
11:22:29 <c_wraith> ack.  Why a version that old?
11:22:36 <int80_h> it's not in the /usr/pkg/bin directory where ghc is
11:22:40 <Sadache> "The HTTP library used here does not read the HTTP result lazily. As a result, it can result in the consumption of a large amount of RAM when downloading large files such as podcasts."
11:22:57 <aavogt> get it from http://haskell.org/cabal
11:22:59 <int80_h> I need lambdabot, and that's what netbsd has in pkgsrc
11:23:23 <c_wraith> That's nearly obsolete by now.
11:23:26 <aavogt> it's probable that you will have difficulty building lambdabot
11:23:43 <gwern> c_wraith: well, netbsd itself is nearly...
11:23:45 <edwardk> but of course it is easy to spot the connection to galois connections, adjoints, etc.
11:23:52 <int80_h> the lambdabot site says 6.10 support is forthcoming
11:24:05 <int80_h> what version would you recommend?
11:24:14 <aavogt> @vixen are you running on ghc-6.10?
11:24:15 <lambdabot> i truely am
11:24:25 <gwern> int80_h: we have a lambdabot site?
11:24:30 <c_wraith> @vixen are you running on ghc-4.2?
11:24:30 <lambdabot> i truely am
11:24:51 <int80_h> @vixen are you running on ghc-6.8?
11:24:52 <lambdabot> i truely am
11:25:13 <aavogt> well my question was answered correctly
11:25:22 <int80_h> http://www.haskell.org/haskellwiki/Lambdabot
11:25:27 <int80_h> page, I meant.
11:25:56 <ddarius> edwardk: There is a Belnap display logic paper online, possibly via JSTOR, because I downloaded it.
11:26:22 <ddarius> edwardk: I'm more interested in the Dunn papers on Gaggle Theory.
11:26:32 <edwardk> ddarius: the original 1982 paper?
11:26:37 <gwern> int80_h: oh. that page is pretty old
11:26:44 <gwern> I guess I should update that
11:26:53 <edwardk> i think i printed out the first dunn paper, but couldn't find the others
11:27:31 <edwardk> er s/printed/photocopied/
11:27:38 <Sadache> any idea why RWH say that?
11:28:00 <aavogt> Sadache: because it's true?
11:29:07 <aavogt> lazy IO for accessing things over the network is a bit more risky because it's quite possible that your connection might time out (or something) before you get around to forcing that IO to happen
11:29:14 <ddarius> edwardk: It looks like it.  It's on CiteSeer.
11:29:50 <kmc> yeah.  reading from a network socket is emphatically a matter of execution and not evaluation
11:30:06 <kmc> lazy IO has problems even in the best of circumstances
11:30:11 <edwardk> ddarius: link? i'd like to be able to send folks there
11:30:57 <kmc> to do incremental, composeable, safe IO you need something more complicated like iteratees
11:31:11 <aavogt> with files it's not so bad since they are less likely to disappear
11:31:56 <ddarius> edwardk: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.147.5163
11:31:57 <Sadache> aavogt: but Saizan just told me that you actually can with HTTP package
11:32:11 <aavogt> perhaps these are different libraries?
11:32:33 <edwardk> odd it didn't come up in a search thanks =)
11:32:56 <kmc> how do you do lazy IO with the HTTP package?
11:33:04 <Sadache> kmc: but it is really a bad idea to hold the whole respone in memory
11:33:06 <ddarius> edwardk: Also, http://www.pitt.edu/~belnap/papers.html
11:33:12 <kmc> Sadache, correct
11:33:32 <edwardk> ddarius: yeah he didn't have that page when I last looked. =)
11:33:39 <aavogt> and in any case, you can make any IO lazy with unsafeInterleaveIO, and strict with appropriate use(s) of seq
11:33:49 <kmc> yeah, but you probably shouldn't
11:34:02 <edwardk> correcting the citeseer entry
11:34:03 <kmc> at least when you do that, it's clear that there are shenanigans
11:34:13 <kmc> less clear that "readFile" uses "unsafeInterleaveIO"
11:34:32 <aavogt> it's too late to call it unsafeReadFile
11:34:46 <kmc> yeah
11:34:49 <gwern> int80_h: ok, I've updated the wiki. I know darcs lb installs on 6.10.4 since I just did it
11:34:51 <kmc> plus there's no strict version in the std lib :/
11:35:00 <kmc> it's really bad that we tell beginners to use readFile + seq
11:35:03 <Sadache> ok, my question is easy, does the basic HTTP package offer respone body as a stream?
11:35:12 <kmc> Sadache, what kind of stream?
11:35:25 <aavogt> @hackage HTTP
11:35:26 <lambdabot> http://hackage.haskell.org/package/HTTP
11:35:37 <ddarius> edwardk: For Dunn, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.9361
11:36:12 <int80_h> gwern thanks. I'm investigating how to install cabal. It seems the way to install cabal is with darcs. Also, the way to install darcs is with cabal.
11:36:23 <dons> kmc: use the strict package, or bytestring.
11:36:33 <Sadache> kmc: any kind of lazy stream so that I can make a transformation and, say, count bytes without holding it entierly in memory
11:36:38 <gwern> int80_h: you're usually expected to bootstrap using your distro's packages or various tgzs or the haskell platform
11:37:03 <kmc> Sadache, ok.  do you understand why a regular lazily-evaluated String is not suitable?
11:37:22 <dons> what do you guys think of the 'haskell in the large' modelling and practices advice? http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell 
11:37:26 <dons> anything we're missing?
11:37:53 <Sadache> kmc: didnt get the question
11:37:57 * dons ponders a position paper from galois on best practices for haskell programming.
11:37:58 <int80_h> ah, I just discovered darcs is in pkgsrc
11:38:15 <kmc> Sadache, which part?
11:38:15 <int80_h> devel/pkgsrc
11:38:17 <Sadache> kmc: is it not suitable?
11:38:19 <monochrom> use haskell platform to get cabal and more.
11:38:22 <kmc> correct
11:38:31 <Sadache> kmc: why?
11:38:33 <kmc> a lazily-evaluated String is not a suitable way to do incremental IO
11:38:34 <int80_h> monochrom, I'm afraid I can't. No platform for netbsd
11:38:42 <kmc> it's a hack we sometimes do, that barely works for read-only unchanging local files on disk
11:38:54 <kmc> Sadache, because it breaks a fundamental idea of Haskell
11:39:05 <kmc> which is that evaluation (of function application) never causes execution (of IO actions)
11:39:27 <kmc> meaning things that look like pure computation now start to have all sorts of problems
11:39:45 <gwern> dons: http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell/3077912#3077912 -Wall *and* hlint I think you meant to say
11:39:51 <aavogt> I dunno if it's fundamental since it's broken by functions like getContents and readFile which are in the prelude, kmc
11:39:51 <kmc> they can depend on evaluation order, which is complicated and is something you're supposed to ignore whenevr possible
11:39:53 <gwern> int80_h: what version of darcs is it?
11:40:04 <dons> gwern: oh, good point. hlint 
11:40:12 <kmc> aavogt, yeah.  putting those in the prelude is a serious mistake
11:40:18 <kmc> they should be in a module akin to Debug.Trace
11:40:23 <kmc> System.IO.QuickHack
11:40:30 <kmc> because yes they're useful, just as trace is
11:40:35 <int80_h>  gwern tell you in a minute, I can't scroll the screen atm
11:40:39 <monochrom> Do you have ghc (bare-bone suffices), zlib-dev, libgmp3-dev, freeglut3-dev, libedit-dev on netbsd? If so, building haskell platform from source is a no-brainer. No bootstrap problem.
11:40:45 <int80_h> dependecies downloading and installing
11:40:59 <Sadache> kmc: ok. And that is why HTTP package is not suitable for me, right?
11:41:02 <kmc> nope
11:41:10 <int80_h> monochrom I'll check
11:41:11 <kmc> i don't know what the HTTP package does for incremental IO
11:41:16 <kmc> i was asking earlier about that
11:41:21 <aavogt> just have a more lenient definition of referential transparency wrt. IO and then you can accept lazy IO
11:41:36 <kmc> aavogt, a uselessly lenient definition
11:41:45 <monochrom> building haskell platform from source takes just 5 minutes on my 1.5-year-old cheapo laptop
11:41:48 <aavogt> apparently that's what happened to include those function in the prelude
11:42:10 <monochrom> and 30 seconds of human labour
11:42:17 <kmc> Sadache, what i'm saying is, a hypothetical HTTP library which provided responses incrementally as a String you can evaluate lazily would not be suitable for real-world use
11:42:32 <monochrom> human labour of dumb end-user like me, not git-savvy hackers
11:42:35 <Sadache> ok, clear enough
11:42:51 <kmc> what if the server times out before you've evaluated the whole string?
11:43:03 <kmc> you're not supposed to care about evaluation order, but now you care about it in real time
11:43:03 * monochrom doesn't even know how to "pull from darcs"
11:43:37 <edwardk> monochrom: darcs get <url> or darcs pull <url> if you already have the repository
11:43:42 <aavogt> evaluation order is constrained by data dependencies
11:43:54 <Sadache> kmc: what would I use instead? Is there any better HTTP library that offeres a stream kind of respone?
11:44:09 <Sadache> kmc: maybe iteratee based, i dont know!
11:44:24 <kmc> i don't know either
11:44:41 <kmc> nor do i know what "HTTP" actually does
11:44:54 <aavogt> it speaks http
11:45:11 <Sadache> kmc: seems it doesn't do what I need after reading RWH note
11:46:03 <Sadache> I am really blocked here. Maybe I'd post a question on StackOverflow. I am not asking a weired question, or am i?
11:46:20 <aavogt> Sadache: did you look at other modules in the HTTP package?
11:46:52 <Sadache> aavogt: no, once I saw the note on RWH i started looking for something else
11:48:16 <aavogt> RWH would be even more massive if it showed you how to use all aspects of the libraries it discusses
11:48:39 <aavogt> to the point that it probably wouldn't be finished yet....
11:48:53 <Saizan> also, libraries change, books not so much
11:49:09 <Sadache> aavogt: they suggest mini-http which is 1:deprecated on hackage 2: hangs on my macosx
11:49:31 <Saizan> it'd help if HTTP's documentation was more explicit about this point
11:50:04 <dons> let's write a book! 10 pages per library. 2200 libraries on hackage. Done.
11:50:06 <dons> oh wait.
11:50:24 <Saizan> Sadache: you could test HTTP with lazy bytestrings, it should be clear if it's reading incrementally or not
11:50:27 <dons> The Haskell Universe: a complete encyclopedia of functions
11:51:00 <dons> ok. 1 paragraph per library. 4 packages per page. 500 pages. that's doable.
11:51:12 <gwern> interesting question: how do we get people to write better documentation?
11:51:14 <dons> just take the synopsis from the .cabal file :]
11:51:21 <monochrom> The Haskell Multiverse: many complete encyclopedias...
11:51:24 <dons> gwern: social mechanisms. 
11:51:24 <gwern> one of the most common complaints about hackage, besides 'i don't know which ones to use'
11:51:27 <dons> review and praise. 
11:51:33 <dons> monthly awards for best docs
11:51:43 <dons> votes.
11:51:45 <dons> wiki docs
11:51:46 <gwern> dons: 'socal mechanisms' is pretty vague
11:51:57 <gwern> monthly awards might work, but awards without prizes aren't so great
11:52:02 <monochrom> "whining in #haskell" may be more concrete
11:52:06 <dons> no no. people will play for karma points.
11:52:09 <dons> that works on the internets
11:52:19 <aavogt> when it isn't so much work
11:52:21 <dons> name recognition as a good doc writer
11:52:22 <gwern> maybe we could put the winner on the front page of hackage
11:52:25 <dons> right
11:52:27 <gwern> something like 'featured package'
11:52:28 <dons> distinguished docs
11:52:39 <monochrom> featured wishlist
11:52:45 <aavogt> even haddockizing docs that are already there, but not formatted correctly takes quite a bit of time
11:53:01 <gwern> traffic is free to the hackage sysadmins, but valuable to package devs
11:53:02 <Sadache> so does that suggest that noone of you here does http or web requesting?
11:53:16 <aavogt> ex. between hlist and template-haskell it took me at least 3h
11:53:30 <monochrom> I use the HTTP package.
11:53:33 <gwern> aavogt: what do you mean by formatted? I find it pretty easy
11:53:53 <Sadache> monochrom: and what kind of requests u do?
11:53:59 <gwern> aavogt: I mean, once you have your alias like 'runhaskell Setup haddock && firefox dist/doc/foo/bar.html', then it's very easy to edit and check
11:54:00 <monochrom> dumb ones
11:54:23 <aavogt> gwern: I mean making up a pretty document structure
11:54:44 <c_wraith> gwern, why not just "cabal haddock" for the first portion?
11:54:58 <gwern> c_wraith: well, that'd work too
11:55:06 <aavogt> reorganizing the text so it's in the places that matter
11:56:47 <aavogt> cabal still can't give the --hyperlink-source
11:57:17 <sadekdrobi> quit
11:58:02 <aavogt> gwern: I'll agree that the markup isn't a problem once learned
11:58:53 <aavogt> perhaps more important than good docs is to have good types:
11:59:18 <aavogt>  f :: Int -> Int -> String -- nobody's going to know (or be able to check) which Int means what
12:00:22 <gwern> aavogt: that's what -- ^ is for
12:01:20 <gwern> one thing that annoys me about XMonad.Core and I couldn't fix was the type sig for mouseBinding - it's so big that it leaves only a tiny column for the actual text
12:01:28 <gwern> and this affects all the types in that section, even the short ones
12:01:36 <aavogt> add a  type
12:01:51 <aavogt> but oh noez, LoC++
12:02:01 <gwern> I tried linebreaking the mouseBinding type, but haddock promptly unbroke it
12:02:39 <aavogt> it's worse for type-level code where you start collecting 10s of typeclass constraints
12:02:42 <lowasser> Is there a faster version of floor for doubles?
12:03:04 <lowasser> Oh, double2Int from Prim.
12:03:04 <mauke> what kind of program is this?
12:03:06 <FunctorSalad_> have you checked whether it already gets rewritten, lowasser ?
12:03:16 <lowasser> yeah, it's awkward and nasty
12:03:21 <FunctorSalad_> ghc -ddump-simpl-stats or something like that
12:10:03 * edwardk is sad. you don't appear to be able to use infix variable names for type equality constraints
12:10:12 <edwardk> i.e. bimapProduct :: (PreCartesian (~>), (*) ~ Product (~>)) => (a ~> c) -> (b ~> d) -> (a * b) ~> (c * d)
12:10:24 <edwardk> it blows up on the (*)
12:10:41 <ddarius> Submit a bug report (or feature request).
12:11:02 <edwardk> ddarius: will do. i hadn't expected it, so now i have to go strip it out of a few dozen lines of code
12:11:42 <edwardk> it gives rise to some very pretty almost agda like expressions
12:11:44 <edwardk> unitCoCCC :: CoCCC (<=), subtract ~ Coexp (<=), (+) ~ Sum (<=)) => a <= b + subtract b a
12:11:53 <edwardk> er there is a missing ( there
12:12:00 <jedai> Given that this part of GHC is being completely reworked and improved right now it's really the time to signal those kind of things
12:12:46 <edwardk> ah i think its the choice of *
12:12:52 <edwardk> because it could be parsed as a kind
12:13:11 <ddarius> edwardk: How could it be parsed as a kind in that context?
12:13:32 <edwardk>  :: * -- is a kind annotation i think the parser just assumes that a * found in a type is a kind annotation
12:13:53 <ddarius> Then that is still a bug.
12:14:32 <edwardk> yes but a much more defensible one ;)
12:15:00 <ddarius> I consider the first one perfectly defensible too.
12:15:21 <tromp_> > (-1) :: Word64
12:15:22 <lambdabot>   18446744073709551615
12:15:34 <tromp_> > (-1)/255 :: Word64
12:15:35 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Word.Word64)
12:15:35 <lambdabot>    arising from a use...
12:15:48 <tromp_> > (-1)`div`255 :: Word64
12:15:50 <lambdabot>   72340172838076673
12:16:28 <tromp_> > (-1)`div`51 :: Word64
12:16:29 <lambdabot>   361700864190383365
12:17:03 * hackagebot YampaSynth 0.0.2 - Software synthesizer  http://hackage.haskell.org/package/YampaSynth-0.0.2 (GeorgeGiorgidze)
12:27:52 <aristid> @hoogle Word64
12:27:52 <lambdabot> Data.Word data Word64
12:32:57 <edwardk> hrmm why would ghc be flipping out about a (\) ~ Exp (<=) in a type signature?
12:34:01 <edwardk> i can't think of a special meaning for \
12:34:19 <c_wraith> I think it's considered special syntax because of lambas
12:34:28 <edwardk> c_wraith: ick
12:34:35 <c_wraith> err, lambdas
12:34:44 <edwardk> c_wraith: that must be it
12:53:34 <Saizan> heh, those well known haskell type lambdas :)
12:53:47 <pielgrzym> is there a way to compile a haskell program statically? So I can run it say on a machine without haskell installed?
12:54:03 <edwardk> well, even after replacing things with *! and \! it blew up so i wound up having to go down to a much harder to read type =(
12:54:15 <edwardk> Saizan: we call them 'type families' these days ;)
12:54:30 <kmc> pielgrzym, GHC does that by default
12:54:43 <kmc> also, "Haskell installed" is a nonsense idea -- Haskell is a specification, not a program
12:54:56 <pielgrzym> kmc: and haskell binaries are normal elf binaries right? 
12:55:11 <kmc> GHC outputs the normal binaries used by your operating system
12:55:14 <pielgrzym> kmc: I referred to all haskell libraries etc.
12:55:43 <kmc> but, for example, NHC and YHC output bytecode, JHC outputs portable C code, and Hugs outputs nothing at all (interprets directly)
12:55:51 <Saizan> with GHC the haskell libraries get linked in statically by default
12:55:52 <kmc> so i'm not (just) being pedantic
12:56:04 <Heffalump> pielgrzym: it's actually quite hard to dynamically link GHC produced executables
12:56:16 <Saizan> some system libraries won't, but i think you can pass -optl-static for those
12:56:21 <Heffalump> in terms of the linkage to the Haskell libraries, that is. C libraries are dynamically linked by default.
12:56:21 <kmc> it's easy to have GHC produce executables which dynamically link to the system libraries
12:56:23 <kmc> that's the default mode
12:56:32 <kmc> it's harder to have GHC dynamically link Haskell code to other Haskell code
12:56:39 <Veinor> pielgrzym: yes, they are ELF binaries
12:56:45 <Veinor> or whatever OS X uses if you compile on OS X
12:56:46 <pielgrzym> so a compiled haskell binary could, say, work on windows?
12:56:54 <Heffalump> not if you compiled it on Linux..
12:57:01 <kmc> GHC on Windows produces regular Windows PE executables
12:57:05 <pielgrzym> cool
12:57:08 <kmc> GHC on Linux produces regular Linux ELF
12:57:12 <Philonous> edwardk: Regarding your category-extras package, why is the distinction between CompF and PointedCompF necessary? Wouldn't it suffice to say "instance (Pointed f, Pointed g) => Pointed CompF f g where point = CompF . point . point" ?
12:57:22 <kmc> (i don't know if GHC works on any non-ELF Linux platform, if those even exist anymore)
12:57:35 <theorbtwo> kmc: I think that they do not.
12:57:38 <pielgrzym> and they are as difficult to disassemble as usual binaries? 
12:57:47 <kmc> yes
12:57:53 <kmc> disassembly is easy in all cases
12:57:59 <kmc> decompilation is hard
12:58:04 <pielgrzym> ah, indeed :)
12:58:08 <kmc> i'm not sure anyone has studied decompilation of GHC output
12:58:24 <c_wraith> dissassembly is sometimes hard.  In cases of self-modifying code.
12:58:38 <kmc> it might be easier than C, because Haskell is higher-level.  or it might be harder because Haskell is higher level
12:58:43 <pielgrzym> is it possible to achievie with haskell something like a commercial library? a binary library with header/documentation for normal people? :)
12:58:48 <c_wraith> you need to disassemble at runtime, rather than statically
12:59:03 <kmc> pielgrzym, do you mean in theory, or with existing tools?
12:59:10 <edwardk> Philonous: the distinction comes down to the fact that there are multiple forms of composition where you generate different definitions for Pointed =/
12:59:12 <pielgrzym> kmc: in practice
12:59:23 <pielgrzym> kmc: at current haskell dev state
12:59:24 <kmc> you didn't answer my question
12:59:25 <kmc> ok
12:59:26 <Saizan> i think it's quite possible in practice
12:59:36 <pielgrzym> is it hard?
12:59:36 <Saizan> with current tools
12:59:48 <Heffalump> are you planning on exporting a C interface or a Haskell interface?
12:59:49 <edwardk> Philonous: there is applicative composition, pointed/monad composition, etc.
13:00:13 <pielgrzym> Heffalump: nope, I'm planning to write myself a haskell web framework
13:00:15 <Saizan> it's not hard if you don't care about allowing it to get linked to different versions of its dependencies
13:00:28 <Saizan> (or different builds even)
13:00:34 <kmc> pielgrzym, the work on making GHC link Haskell to Haskell dynamically was sponsored by the Industrial Haskell Group for just this purpose, i believe
13:00:36 <Heffalump> pielgrzym: I don't understand what you mean about a commercial library then.
13:00:36 <pielgrzym> Heffalump: and my own simplistic web server for this very framework
13:00:54 <kmc> does your business model really depend on the software being closed-source?
13:01:14 <pielgrzym> Heffalump: well, it would be a nice feature to be able to extend some code with commercial libraries (I mean in marketing)
13:01:28 <kmc> an often-neglected option is to make source available but under a license with more restrictive terms than a free-software license
13:01:34 <pielgrzym> kmc: of course not :) but you have to attract dumb business with something :)
13:01:39 <Heffalump> pielgrzym: I don't really understand what you want to do.
13:02:08 <pielgrzym> Heffalump: let's leave off the closed source libraries for the moment - I just wanted to know if it's possible :)
13:02:17 <kmc> pielgrzym, is that a selling point of any of the currently popular open-source web frameworks?
13:02:30 <pielgrzym> Heffalump: I'm such a noob it will probably take me decades to write a functional web framework ;)
13:02:30 <kmc> do Django or Rails tout their compatibility with closed-source plugins?
13:03:09 <pielgrzym> kmc: those languages do not compile, so they could never benefit from it the easy way (I know there are some extensions)
13:03:31 <monoidal> could someone confirm if the following is a bug in GHCi: let x = (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
13:03:41 <pielgrzym> kmc: plus they really, really suck at one thing (I use django/pylons for like 2 years now)
13:03:45 <monoidal> with one component in the tuple less, it works OK
13:03:51 <Heffalump> pielgrzym: yes, closed source libraries are possible. As are web frameworks.
13:03:53 <pielgrzym> kmc: the deployment is *really* messy
13:03:53 <kmc> pielgrzym, there are several Python compilers.  but if you mean in standard use, then i agree
13:04:01 <Igloo> monoidal: There's a limit to the size of tuple that is supported
13:04:08 <Veinor> monoidal: the bug is that you need that large of a tuple!
13:04:14 <monoidal> Igloo: Yes, (0,0,0...,0) gives a proper error
13:04:23 <kmc> i very rarely need a tuple bigger than 2
13:04:29 <monoidal> Igloo: (,,,..,) gives linking error
13:04:30 <kmc> if you do, you should consider defining your own type instead
13:04:38 <pielgrzym> kmc: what I'd like to write is a webserver/framework combo - so to make deployment much easier (like in java web servers, tomcat etc)
13:04:56 <kmc> isn't that also how people use rails and django?
13:05:01 <kmc> or is that only for dev / toy examples?
13:05:10 <pielgrzym> Heffalump: this is so much cooler about haskel than python - it really compiles :)
13:05:11 <kmc> of course you'll put your big static files on a separate server
13:05:15 <Philonous> edwardk: I see. Thanks for the package btw. I like it a lot. 
13:05:19 <ddarius> (Java web framework deployment is easy?)
13:05:52 <kmc> everything in Java is easy, because we measure difficulty in weird ways
13:05:55 <pielgrzym> kmc: well, there are various problems with jython (dunno about ruby in java) - plus I thing xml config sucks ;)
13:05:57 <edwardk> Philonous: no problem. actually working on it this weekend, trying to break it up a bit
13:06:17 <kmc> spending three hours to write ten pages of code is easy, because you're making a little progress all the time
13:06:25 <kmc> spending three hours thinking and then writing 10 lines of code is hard
13:06:36 <pielgrzym> kmc: ever tried deploying massive amount of apps (for django/rails) as fcgi? this is *hell*
13:06:41 <ddarius> kmc: I'm not talking about coding.  I'm talking about deployment.
13:06:43 <kmc> no i haven't
13:06:51 <pielgrzym> kmc: but it's so much rewarding
13:07:01 <pielgrzym> kmc: this is the awesomeness of haskell
13:07:12 <pielgrzym> kmc: it forces you not to do shit :)
13:07:29 <kmc> btw i expect we will see several popular python compilers in the near future
13:07:37 <kmc> Google is working on one
13:07:58 <kynky> wasnt facebook too ?
13:08:04 <kmc> they wrote a PHP compiler
13:08:06 <kmc> in C
13:08:13 <kmc> oddly enough
13:08:46 <kmc> writing a compiler in C makes me think of cleaning a stadium with a toothbrush
13:08:51 <kmc> but it's a popular thing to do
13:08:57 <kynky> :)
13:09:06 <pielgrzym> ddarius: java web servers come with cool packaging utility - so deploying an app on tomcat takes uploading and registering a package. on the other hand deploying with fcgi means taking care of dependencies, using git/svn/hg etc., taking a hassle to create a nice way to communicate with webserver + creating some init scripts so this whole mess will launch by itself uppon next reboot etc
13:09:10 <kmc> partially because C runs everywhere
13:09:23 <pielgrzym> kmc: hehe, indeed :)
13:09:25 <nlogax> "i could have written a shorter letter, but i did not have the time" <- i often feel like that about code :)
13:09:48 <ddarius> kmc: Yes!  That's what we need.  PHP on embedded devices.
13:09:56 <kmc> haha
13:09:59 <kynky> lol
13:10:06 <kmc> well, nobody runs their embedded device compilers on the device
13:10:14 <nlogax> Portable Hypertext Pasta, mmm
13:10:14 <pielgrzym> ddarius: now imagine you have 80 fcgi apps on your machine - without a sensible webserver packaging it's a *hell* :)
13:10:15 <kmc> writing a compiler to target C is reasonable
13:10:20 <kmc> writing a compiler in C is highly questionable
13:10:32 <monoidal> Igloo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26404#a26404 Is it intented?
13:10:56 <pielgrzym> ddarius: and I didn't even come to topic of giving a broader spectrum of your users ability to deploy :) this is a harsh shit ;)
13:11:04 <johnw> what is a better choice than C then?
13:11:06 * kmc i think needed to run gcc on a Zaurus at one point... needed swapfile over NFS and a couple days compile time :)
13:11:12 <kmc> johnw, for writing a compiler?
13:11:14 <johnw> yeah
13:11:23 * hackagebot categories 0.54.0 - categories from category-extras  http://hackage.haskell.org/package/categories-0.54.0 (EdwardKmett)
13:11:23 <pielgrzym> logo :P
13:11:27 <kmc> it's close to the ideal application for functional languages
13:11:27 <johnw> i've written compilers in C for a living for a long time now
13:11:34 <edwardk> yay 1 package down a dozen to go!
13:11:38 <kmc> compilers are as close as you might get to a real task that's a pure function
13:11:40 <johnw> true, writing in Haskell would be much much better
13:11:46 <ddarius> edwardk: 'ever going to have a 1.0 release of your libraries?
13:11:50 <kmc> and more than "functional" you need good symbolic data manipulation
13:11:54 <edwardk> ddarius: eventually =)
13:11:56 <kmc> which to me means algebraic types and pattern matching
13:12:01 <kmc> which correspond very precisely to abstract syntax trees
13:12:05 <kmc> though the Lisp route could also work
13:12:09 <johnw> kmc: yeah, it's just one giant data transformation
13:12:17 <Igloo> monoidal: I think it probably ought to give a nicer error
13:12:35 <kmc> if i had to write a compiler and didn't have algebraic data, i'd want a good object system for faking it
13:12:58 <johnw> there aren't that many object types to deal with
13:13:00 <kmc> so Python, Ruby, JavaScript, maybe C#
13:13:09 <pielgrzym> anyway since haskell really rocks in concurrency it would be a cool playground to write a modular webserver for a web framework :)
13:13:12 <johnw> "type", "routine", "variable", etc.
13:13:33 <kmc> johnw, the usual encoding of algebraic data in rigid OOP involves a class for each alternative
13:13:37 * ksf thinks he got himself a nearly fully compliant (modulo ipv6) RFC 3986 parser
13:13:42 <kmc> so each different syntactic form of an expression is its own type
13:13:54 <kmc> then you do visitors over those
13:13:56 <ksf> now what's left is the other half of the rfc, which describes normalising and stuff...
13:14:11 <johnw> i've never worked on a fancy compiler.  they are all doggedly straightforward -- which does make it easier for time-disparate teams
13:14:52 <edwardk> ddarius: that package is just the categories from category-extras. i needed to bundle up the basic notion of a nicer functor and bifunctor to make it self contained, but i think overall the transition to type families helped. sadly i didn't get to use the pretty type equalities to make the function type signatures easier to read they just seem to have not propagated right somehow
13:15:00 <patch-tag> on restarting patch tag I get   internal error: PAP object entered! (ghc error) 
13:15:10 <patch-tag> any way to get more debug output out of this?
13:15:45 <edwardk> patch-tag: ever have any luck figuring out where the last few weeks of changes to my repo list went?
13:15:59 <dons> patch-tag: yikes. ghc bug.
13:16:13 <dons> patch-tag: load it in ghc, and talk to simon marlow. you might consider recompiling all dependencies
13:16:14 <patch-tag> edwardk: kind of
13:16:22 <kmc> ghc bug, or someone is using unsafe functions... unsafely
13:16:26 <edwardk> eaten by macid or something?
13:16:30 <patch-tag> git's hc 6.12.1. worth upgrading?
13:16:57 <patch-tag> edwardk: I lost some metadata with all this crashes. the repos are stil there obviously
13:17:01 <edwardk> wow, the haddock generated when using infix type operators is awful.
13:17:18 <patch-tag> so I have a workaround that will load repos on hard disks into macid state
13:17:39 <patch-tag> but first I have to get things more stable in general
13:18:56 <edwardk> it starts showing stuff like: associateProduct :: PreCartesian ~> => Product ~> (Product ~> a b) c ~> Product ~> a (Product ~> b c)
13:18:57 <patch-tag> but pretty much yes, eaten by macid. the other thing is I am transitioning to a checkpoint every half hour instead of depending on event files. but it's all a little icky.
13:19:17 <edwardk> instead of associateProduct :: PreCartesian (~>) => Product (~>) (Product (~>) a b) c ~> Product (~>) a (Product (~>) b c)
13:19:18 <patch-tag> I think I just need to understand macid better
13:21:27 <clanehin> What's this about? That version of GLUT clearly exists, and WFM: http://hackage.haskell.org/packages/archive/rsagl/0.4.0.1/logs/failure/ghc-6.12
13:29:15 <pielgrzym> hm, libgmp.so.10 is a mandatory dependency of all ghc compiled stuff?
13:29:34 <kmc> pielgrzym, you can build a GHC which outputs code that doesn't use gmp
13:29:35 <pielgrzym> I can't run my haskell program on other machine due to lack of libgmp.so.10
13:29:40 <kmc> by default it is used by the implementation of Integer
13:29:51 <kmc> most linux distros have a package for libgmp
13:30:12 <pielgrzym> kmc: can't I just pass an option for some sort of really-totally-static linking to ghc? 
13:30:15 <kmc> if you absolutely can't install it, you can either build a GHC which uses integer-simple, or figure out some way to link it in statically
13:30:27 <pielgrzym> kmc: I see
13:30:29 <pielgrzym> kmc: thanks
13:30:36 <kmc> i'm not sure if it's possible to tell GHC which integer lib to use after you've already built it with integer-gmp
13:30:43 <kmc> it has been implied that the answer is 'no' but i don't understand why
13:31:13 <Igloo> kmc: The integer-gmp functions would be inlined in base etc
13:31:14 <kmc> pielgrzym, i have had some success with manually collecting the .o files and calling ld along with relevant .a's to produce a .so
13:31:32 <kmc> Igloo, ah.  so it's not GHC itself but the core libraries that get installed with GHC?
13:31:46 <kmc> pielgrzym, but there's probably a nicer way
13:32:10 <Igloo> yeah
13:32:34 <stephenjudkins> wikipedia says: "Early versions of Haskell used a problematic "lazy list" model for I/O, and Haskell 1.3 introduced monads as a more flexible way to combine I/O with lazy evaluation."  however, i was under the impression that "monads" require no language/library support and can be easily created using basic haskell.  can anyone clarify what this sentence means?
13:33:46 <johnw> is it referring to the IO monad?
13:33:46 <edwardk> stephenjudkins: sugar was added around that time. and the IO subsystem was replaced with one that was monadic in nature rather than relying on the previous Request/Response version
13:34:10 <edwardk> stephenjudkins: the do sugar isn't necessary to use monads, it just makes them real convenient
13:34:30 <stephenjudkins> edwardk: oh, i see.  can you explain how the sugar helps?
13:34:34 <djahandarie> Monads can be created using just haskell's type system. The IO Monad has extra stuff going on behind the scenes.
13:34:45 <pielgrzym> kmc: thanks for help:)
13:34:47 <jedai> stephenjudkins: Monads don't require support but the standard for IO operation was changed around Haskell 1.3 to use this new method (monads)
13:34:55 <monochrom> The quoted sentence is pretty clear IMO. Your impression is unclear IMO. I recommend clarifying your impression and finding it is wrong.
13:35:06 <djahandarie> IMO
13:35:29 <edwardk> stephenjudkins: foo = do x <- readLine; putStrLn x; putStrLn x; return (x ++ "\n Hello World" -- reads fairly naturally to a programmer from an imperative background
13:35:32 * hackagebot bindings-directfb 0.0.2 - Low level bindings to DirectFB  http://hackage.haskell.org/package/bindings-directfb-0.0.2 (MauricioAntunes)
13:35:34 <edwardk> stephenjudkins: compared to
13:35:41 <jedai> And the IO monad require an interpretation somewhere as a mechanism to do impure things in a pure language (at least if you want the usual semantics)
13:35:44 <edwardk> @undo do x <- readLine; putStrLn x; putStrLn x; return (x ++ "\n Hello World")
13:35:44 <lambdabot> readLine >>= \ x -> putStrLn x >> putStrLn x >> return (x ++ "\n Hello World")
13:36:40 <stephenjudkins> edwardk: thanks.
13:37:39 <kmc> yeah
13:37:47 <kmc> there are three different interlocking things here
13:37:49 <edwardk> djahandarie: i think you just filled in the days you did on the boston haskell poll so you wouldn't have to drive up ;)
13:37:58 <djahandarie> :P
13:38:00 <kmc> 1) describing IO in terms of Â«a -> IO aÂ» and Â«IO a -> (a -> IO b) -> IO bÂ»
13:38:19 <djahandarie> I really can't go on a weekday because I have work the next day
13:38:21 <kmc> 2) recognizing that that's an instance of a more general pattern
13:38:27 <djahandarie> And also it leaves me no time to eat before going there
13:38:28 <kmc> 3) providing some special syntax for working with those instances
13:38:29 <edwardk> djahandarie: fair enough
13:38:35 <stephenjudkins> monochrom: no, edwardk answered my question very well.  i think the sentence isn't especially clear; if i had a slightly worse idea of what monads are I would have been misled.
13:38:48 <monochrom> Your "
13:38:49 <kmc> (1) is only labeled "monadic" because we have (2).  without that we'd just call it "the way IO works"
13:39:11 <monochrom> Fine. Nevermind.
13:39:21 <kmc> as for language features, (1) is ordinary higher-order functions, (2) is type classes, and (3) is a special case
13:39:36 <kmc> but only (3) is a monad-specific language feature
13:40:02 * djahandarie contemplates writing his "Introduction to Programming, Using Haskell"
13:40:31 <ddarius> "Introduction to HVAC, using Haskell"
13:43:03 <titaniumdecoy> groupBy (\x y -> x /= y) [1,2,3,1,2,3,2,1]
13:43:03 <titaniumdecoy> [[1,2,3],[1,2,3,2],[1]]
13:43:06 <titaniumdecoy> how does this make sense?
13:43:28 <djahandarie> @src groupBy
13:43:29 <lambdabot> groupBy _  []       =  []
13:43:29 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:43:29 <lambdabot>     where (ys,zs) = span (eq x) xs
13:43:41 <ddarius> By the specification of the input of groupBy by the Prelude, you are abusing groupBy.  By the source in the Prelude, it makes perfect sense.
13:44:00 <titaniumdecoy> how am i abusing it?
13:44:29 <Phyx-> why does configure call a missing license a warning while without it it won't compile
13:44:41 <monoidal> titaniumdecoy: http://stackoverflow.com/questions/1316365/haskell-surprising-behavior-of-groupby
13:45:00 <titaniumdecoy> thanks
13:45:10 <Phyx-> also this is quite odd "setup.exe: /LICENSE: does not exist" but cat /LICENSE shows it's there
13:45:11 <monochrom> groupBy is not supposed to make sense if your relation is not an equivalence relation.
13:45:12 <ddarius> "When the "By" function replaces an Eq context by a binary predicate, the predicate is assumed to define an equivalence"
13:45:27 <stephenjudkins> kmc: yeah; frankly it seems some people conflate (3) with (2) and (1)
13:47:47 <djahandarie> It'd be really cool if someone could replace the rolling junk ball logo with the new haskell logo on the wiki
13:49:26 <drejk> hi to all
13:49:51 <djahandarie> Hi
13:50:31 <drejk> whats up
13:51:15 <djahandarie> Not much.
13:52:11 <drejk> ql ql
13:52:34 <ddarius> Ugh.
13:53:07 <djahandarie> By the way, if you are running IRC as root, it'd be a good idea to switch it to a regular user.
13:53:35 <Phyx-> > let push = \(f::(forall a.a->a)) -> (f 1, f "a")
13:53:36 <lambdabot>   not an expression: `let push = \(f::(forall a.a->a)) -> (f 1, f "a")'
13:53:57 <Phyx-> > let push = \(f::(forall a.a->a)) -> (f 1, f "a") in push id
13:53:58 <lambdabot>   (1,"a")
13:59:39 <cheater99> if i have multiple definitions for my function, and the pattern on the first definition matches but the guards don't match, then it goes on to the next definition, right?
14:00:04 <ddarius> Yes.
14:00:04 <Botje> yes
14:00:40 <stephenjudkins> how is Data.Map implemented efficiently (IE, not copying the entire data structure every insert?)  i know scala.collection.immutable.Map actually DOES copy everything on insert.  is there an explanation that someone with limited functional programming experience could understand?
14:00:41 * hackagebot categories 0.54.1 - categories from category-extras  http://hackage.haskell.org/package/categories-0.54.1 (EdwardKmett)
14:01:09 <ddarius> stephenjudkins: It's a tree.  It only needs to copy the path to the node, it can share everything else.
14:01:19 <gwern> stephenjudkins: wow, it does? that's so terrible
14:01:35 <stephenjudkins> gwern: yeah it is kind of terrible.   this may have change with 2.8
14:01:40 <gwern> java libraries must be really awesome if people are willing to sell their souls like that
14:01:49 <cheater99> thank you
14:01:59 <ddarius> gwern: The secret is to use imperative programming.
14:02:29 <gwern> that's like saying 'the secret is to use lube'
14:02:49 <kmc> hehe, Haskell as a katamari which sort of accumulates FP features as it rolls
14:03:11 <kmc> that is the secret
14:03:12 <monochrom> If you have root node X, left child B, right child C, and you want to replace C by D. You also have to replace X. But that's it, you can reuse B. New tree: root new X, left child old B, right child new C.
14:03:15 <edwardk> gwern: I would suppose 'not using it' would be more appropriate ;)
14:03:19 * ddarius hopes gwern is not expecting a denial from him.
14:03:25 <monochrom> and oh, s/new C/D/
14:03:40 <kmc> stephenjudkins, Rich Hickey gave a great talk about Clojure which touches on many important things (and things relevant to Haskell)
14:03:44 <kmc> including Clojure's hash tries
14:03:50 <gwern> edwardk: the suppressed part of my statement was 'the secret to butsecks'
14:04:01 <kmc> which have performance close to a hashmap, are persistent/immutable and copy only a few nodes on insert
14:04:12 <kmc> they're 32-ary trees iirc, so it partitions your hash value into groups of 5 bits
14:04:17 * kmc looks for the talk
14:04:27 <kmc> (he's given a lot of different ones obviously)
14:04:44 <gwern> wasn't edwardk working on getting us awesome hash tries like clojure?
14:04:53 <ddarius> I don't think so.
14:04:57 <ddarius> There is HAMT
14:05:00 <ddarius> @hackage HAMT
14:05:01 <lambdabot> http://hackage.haskell.org/package/HAMT
14:05:19 <edwardk> hamt?
14:05:21 <kmc> it might have been this one? http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey
14:05:51 <monochrom> http://hackage.haskell.org/package/HAMT is 404
14:05:57 <stephenjudkins> kmc: great, will look at it.  thanks
14:06:27 <kmc> stephenjudkins, the bible of this stuff is _Purely Functional Data Structures_ by Okasaki
14:06:29 <kmc> i have not yet read it :/
14:06:31 <ddarius> Yeah, I don't think it's been put on Hackage.  It was by Edward Yang. 
14:06:48 <ddarius> http://github.com/ezyang/hamt
14:07:24 <monochrom> I see. Thanks.
14:07:43 <stephenjudkins> kmc: wow, that paper looks like exactly what i'm looking for.  thanks.
14:08:43 <danharaj> It's also a book.
14:08:43 <kmc> what's the best paper to read as an introduction to delimited continuations (in Haskell ideally)
14:09:27 <Saizan> i've found Shift to Control quite nice, but it's schemish
14:09:30 <ddarius> kmc: For an introduction, I'd probably read a Scheme one.  Also, they are more compelling in an effectful context.
14:09:36 <stephenjudkins> gwern: i found that introducing scala to my coworkers was possible;  if i had suggested haskell i probably would have been laughed out of the room.
14:09:53 <gwern> stephenjudkins: so scala is good for lying to the ignorant?
14:09:58 <monochrom> I read Oleg's stuff for deliminted continuations.
14:10:19 <FunctorSalad_> stephenjudkins: :(
14:10:25 <illissius> how awesome is Scala, relative to Haskell?
14:10:33 <illissius> (obviously this channel is biased but w/e)
14:11:04 <stephenjudkins> illissius: scala's OK, it's reasonable to write purely functional code using it.  it's also easy to stray off the "golden path" too.
14:11:16 <gwern> it is approximately 8/10ths of an Oleg less awesome
14:12:44 <sinelaw> gwern what's in Oleg in SI units?
14:12:49 <sinelaw> s/in/an/
14:12:55 * Phyx- sometimes thinks this channel makes things way too difficult
14:12:57 <illissius> I guess the more direct question is whether its type system is more or less powerful, as that's what I like about Haskell more than the functionalness itself (though obv they're not independent)
14:13:05 <aristid> gwern: we must insist on using SI units in this international channel
14:13:13 <ddarius> illissius: The type systems are incomparable.
14:13:18 <illissius> Oleg isn't an SI unit?
14:13:28 <stephenjudkins> http://lamp.epfl.ch/~rompf/continuations-icfp09.pdf is also a fantastic read;  it's about scala but you can ignore that part.
14:13:29 <gwern> sinelaw: it's the product of Djikstras and micro-Kays
14:13:40 <Phyx-> I rest my case..
14:13:41 <kmc> illissius, Scala is more powerful in some ways
14:13:53 <kmc> it has subtyping
14:13:59 <kmc> which is a whole big can of worms
14:14:01 <sinelaw> gwern which are equal to Kilos per Joul-meter squared, divided by megawatts to the power of millimeters
14:14:07 <kmc> but necessary if you want to integrate a standard OO type system well
14:14:21 <gwern> sinelaw: and that's precisely why we have these shorthand names
14:14:33 <aristid> i haven't looked at scala closely yet, but is my perception correct that it would be a very complex and java-compatible dialect of ML?
14:14:45 <kmc> i wouldn't consider it a dialect of ML
14:14:48 <kmc> any more than Haskell is
14:14:49 <ddarius> aristid: Not really.  It's not an ML dialect.
14:14:50 <kmc> probably even less so
14:14:59 <aristid> ok, then i was wrong
14:15:11 <sinelaw> gwern yeah, they say the sun's magentic field is about 0.2 oleg per second
14:15:17 <kmc> (how does F# handle that?  does it also introduce subtyping into H-M or does it follow a doctrine of non-overlapping magisteria?)
14:15:25 <illissius> ha, magentic field
14:15:32 <sinelaw> heh oops.
14:15:36 <illissius> I don't know if that was a freudian typo but I like it
14:15:51 <ddarius> kmc: F# is based on O'Caml which presumably has some sort of subtyping.
14:15:55 <kmc> Scala even lets you declare type constructors explicitly as having covariant or contravariant subtyping in the argument
14:16:17 <stephenjudkins> gwern: i wouldn't call people very proficient at writing ruby "ignorant" even if it may be true in some context.  that kind of attitude explains some part of why haskell isn't a more widely used language
14:16:21 <illissius> oh, that makes sense
14:17:23 <kmc> i would call people ignorant if they are ignorant, regardless of whether they're good at ruby
14:17:32 <kmc> seems like being good at ruby would be a poor predictor either way
14:17:34 <wli> I'd be fine with widths on variants and records, which I think can be recast as row kinds or some such.
14:17:36 <illissius> i knew about scala having explicit variancy annotations (so does C# iirc) and not having them being a pain in C++ sometimes, but never really connected the haskell doesn't have subtyping <=> haskell doesn't need them dots
14:17:44 <kmc> yeah
14:17:51 <kmc> avoiding subtyping simplifies so many things
14:17:59 <ddarius> "ignorant" takes an indirect object.
14:18:07 <kmc> can you imagine subtyping with undecidable MPTC, fundeps, and type families?
14:18:32 <Gracenotes> there are cases where subtyping is a great way to model things
14:18:37 <wli> width subtyping -esque things on variants are very helpful.
14:18:45 <kmc> i think that "Haskell => laughed out of the room" is the indicator of ignorance here
14:19:44 <stephenjudkins> kmc: nah, saying this as someone who is genuinely interested in haskell (if pretty incompetent at actually using it) i'd say for the vast majority of professional programmers it is very difficult for them to learn.
14:20:05 <danharaj> 'professional programmers' are rarely professional :p
14:20:26 <Phyx-> what's width subtyoing?
14:20:30 <kmc> stephenjudkins, right.  there are lots of fair responses, laughing at things you don't understand is not one of them
14:20:31 <ddarius> danharaj: "Professional" means "gets paid"
14:20:42 <stephenjudkins> professional to me means "paid".
14:20:55 <kmc> i'm not saying everyone should learn haskell or should want to learn haskell
14:21:22 <Phyx-> oh, you meant "with"
14:21:31 <danharaj> ddarius: they don't act in a manner as professionalism connotes.
14:21:55 <danharaj> ddarius: They do not exhibit professionalism in their vocation.
14:21:58 <ddarius> danharaj: Indeed.
14:22:01 <kmc> danharaj, because tech companies cultivate a neotenous pseudo-undergraduate workplace culture in order to convince their employees to live at the office
14:22:13 <illissius> Phyx-: don't think so, see his previous line.
14:22:18 <Gracenotes> Phyx-: both width and depth subtyping are covariant in that all values in the subtype map to one in the supertype (maybe not uniquely)
14:22:22 <ddarius> @wn neotenous
14:22:24 <lambdabot> *** "neotenous" wn "WordNet (r) 2.0"
14:22:25 <lambdabot> neotenous
14:22:25 <lambdabot>      adj : of or relating to or characterized by neoteny; "neotenic
14:22:25 <lambdabot>            development" [syn: {neotenic}]
14:22:31 <Gracenotes> if I understand it correctly
14:22:34 <ddarius> Very helpful word net.
14:22:37 <danharaj> kmc: I think there are multiple factors.
14:22:40 <danharaj> @wn neoteny
14:22:41 <lambdabot> *** "neoteny" wn "WordNet (r) 2.0"
14:22:41 <lambdabot> neoteny
14:22:41 <lambdabot>      n : an evolutionary trend to be born earlier so that development
14:22:41 <lambdabot>          is cut off at an earlier stage and juvenile
14:22:41 <lambdabot>          characteristics are retained in adults of the species
14:22:58 <illissius> is there some IDE or other haskell-viewing tool which lets you click things to jump to their definition and such (or even better show the definition in a tooltipish)?
14:23:02 <gwern> ddarius: not really. it only has common words, and not the obscure ones I need to look up
14:23:11 <Gracenotes> Phyx-: hm. I guess this is it. http://en.wikipedia.org/wiki/Subtype_polymorphism#Record_types
14:23:16 <gwern> leksah can do tha I think
14:23:17 <danharaj> gwern: i think there was sarcasm all up in his base :p
14:23:18 <kmc> danharaj, well you can also consider the absurdly low standards of quality compared to other engineering fields to be a lack of professionalism
14:23:21 <Tomsik> illissius: leksah is okay
14:23:25 <kmc> i mean if bridges were built like software...
14:23:29 <illissius> hmm, k
14:23:46 <wli> Maybe "professionalism" is not all it's cracked up to be as it's literally merely money-whoring.
14:23:49 <gwern> (software engineering is not engineering)
14:24:10 <Phyx-> Gracenotes: oh well, I knew what subtyping is, just didn't know it came in two variants
14:24:23 <illissius> it's more of a supply-and-demand thing
14:24:33 <Tomsik> there's high demand and low supply
14:24:45 <Tomsik> that's why bad people write bad software that should be ashamed of itself
14:24:53 <illissius> if software failing caused people to die rather than just become severely annoyed it would be engineered a lot better
14:24:53 <Tomsik> and in fact is, that's why it suicides at times
14:24:56 <danharaj> kmc: Indeed. I think it's because 'practical computer science' curricula do not emphasize the mathematical foundation of programming. How many engineers can graduate without knowing how to solve differential equations like they know how to breathe? How many programmers can graduate without knowing what operational/denotational/axiomatic semantics are?
14:24:59 <monochrom> software wants to be ashamed?
14:25:03 <illissius> and in cases where software failing *does* cause people to do die
14:25:06 * kmc wonders how different things would be if a master's degree were an absolute prerequisite for doing commercial software development
14:25:13 <illissius> it not coincidentally *is* engineered much better
14:25:32 <ddarius> gwern: I was being sarcastic.
14:25:38 <gwern> illissius: well, obviously. if software were more important, there'd be more money for writing proofs than hacking together state changes
14:26:05 <monochrom> No, money-whoring is more important.
14:26:37 <danharaj> Programming/Software Engineering/Whatever is not treated with respect by many businesspeople.
14:27:07 <monochrom> Also I don't blame low-tier programmers. I blame high-tier managers. They are the ones saying no to proofs. "Not a deliverable. Customer didn't pay for proofs." What can a low-tier programmer do?
14:27:11 <danharaj> So you see technologies that push *business* succeed more often.
14:27:25 <stephenjudkins> i think the average 'practical computer science' curriculum would be more 'practical' if it emphasized source control, agile-y development techniques, agile-ish practices, and testing more than it does now.
14:27:29 <kmc> danharaj, i can't fault business people for wanting their businesses to succeed
14:27:43 <kmc> stephenjudkins, that sounds like a software engineering curriculum, a totally different but also important thing
14:27:55 <kmc> physics is not mechanical engineering
14:27:55 <ddarius> kmc: What would be different is that a Master's degree would be much more watered down and meaningless.
14:28:03 <sinelaw> kmc they'd be a whole lot more idiots in master's programs
14:28:25 <danharaj> kmc: Except they don't evaluate their Programmer technologies and personnel properly to make effective decisions. Instead they buy the buzzword snake oil.
14:28:27 <kmc> the world needs physicists, and mechanical engineers, and especially people who know both
14:28:28 <ddarius> kmc: It would also rule out many competent programmers.
14:28:30 <stephenjudkins> kmc: true
14:28:48 <danharaj> stephenjudkins: Agile development is snake oil.
14:28:57 <stephenjudkins> danharaj: how so?
14:28:58 <kmc> danharaj, i think this is to some degree a caricature 
14:29:08 <danharaj> kmc: Isn't it always?
14:29:25 <k23z> kmc: the world needs construction workers in Canada, it needs programmers all over the world, there's also an increasing need for doctors
14:30:20 <kmc> why canada?
14:30:36 <danharaj> stephenjudkins: Tough question.
14:30:37 <danharaj> :p
14:30:41 <monochrom> The world needs more snake oil. Because petroleum oil is running out.
14:30:42 <Darkone> Don't forget nurses.
14:30:43 <kmc> canada oh canada i never was your son
14:31:02 <sinelaw> in canada, you get to see them all
14:31:06 <Darkone> USA is it to our ankles when it comes to lack of RNs
14:31:07 <gwern> kmc: because canada has less illegal immigration and their housing bubble either hasn't popped yet or didn't rise
14:31:21 <kmc>  /join #nursing
14:31:23 <kmc> ;)
14:31:33 <monochrom> /join #nursing
14:31:37 <wli> I daresay Canada isn't far enough
14:31:45 <Darkone> I'm momentarily confused.
14:31:58 <Darkone> I saw people talking about job shortaged, so I chipped in :X
14:32:37 <triyo> What function can I use to split, by a delimiter, a given String? myFunc ',' "x, y, z" => ["x", "y", "z"]
14:32:49 <kmc> triyo, take a look at the "split" library on hackage
14:32:52 <gwern> triyo: see the split package
14:32:54 <kmc> the standard lib is lacking in such things
14:32:58 <kmc> i don't think agile itself is snake oil
14:33:14 <Darkone> Uhhm
14:33:29 <kmc> i think anyone who claims to have the only true magical agile special sauce and will sell it to you
14:33:32 <kmc> is selling snake oil
14:33:36 <Darkone> I haven't look at haskell i na while, but I'm pretty sure there's a function that breaks a list at a delimiter.
14:33:37 <triyo> kmc: thanks
14:33:38 <monochrom> I stole the code of "words" to split.
14:33:43 <monochrom> @src words
14:33:43 <lambdabot> words s = case dropWhile isSpace s of
14:33:43 <lambdabot>     "" -> []
14:33:43 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:33:48 <monochrom> I stole that. :)
14:34:03 <gwern> Darkone: at one delimiter
14:34:19 <Darkone> Yes, but you can make it recursive pretty easy IIRC.
14:34:20 <illissius> monochrom: and we can make biofuels out of bullshit
14:34:20 <gwern> @hoogle break
14:34:20 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
14:34:20 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
14:34:20 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
14:34:22 <monochrom> (And I mean I stole it for my own code. I didn't release a package.)
14:34:38 <Darkone> I've been too busy playing games, so I forgot the function and stuff :P
14:34:52 <gwern> Darkone: there are a lot of edge cases and ways you might want things to split - that's why we don't have Data.List.split, because no one could agree
14:34:52 <monochrom> And when stealing from "words" doesn't suffice, I go regex splitting.
14:35:54 <gwern> @remember sigfp Clearly the first line of code ought to be 'extract :: (Monad m) => m a -> a'. The rest of the post will fill in the details.
14:35:54 <lambdabot> I will never forget.
14:36:10 <mauke_> sigfp?
14:36:33 <gwern> @forget sigfp Clearly the first line of code ought to be 'extract :: (Monad m) => m a -> a'. The rest of the post will fill in the details.
14:36:33 <lambdabot> Done.
14:36:38 <gwern> @remember sigfpe Clearly the first line of code ought to be 'extract :: (Monad m) => m a -> a'. The rest of the post will fill in the details.
14:36:38 <lambdabot> Done.
14:38:03 <tromp_> :t swap
14:38:04 <lambdabot> Not in scope: `swap'
14:38:30 <gwern> another long-debated additional to base
14:41:53 <monochrom> And the debate surrounds about Â«swap (x,y) = ...Â» vs Â«swap ~(x,y) = ...Â»
14:41:54 <triyo> Looking at 'split' package, can't see if there is a way when doing split on string to ignore white space, for example:   splitTrimWhiteSpace "," "xxx   ,  yyy  ,   zzz" => ["xxx", "yyy", "zzz"]
14:42:05 <triyo> any ideas?
14:42:41 <monochrom> is the number of spaces constant?
14:43:11 <triyo> monochrom: no num of spaces is not contant
14:43:24 <c_wraith> what's the downside to the swap ~(x, y) version again?
14:43:40 <aavogt> laziness is expensive / stack overflowage
14:44:00 <kmc> laziness is hard
14:44:08 <kmc> a nice paradox
14:44:55 <aavogt> so given implementation limitations, the strict version might terminate when the lazy version overflows the stack
14:46:12 <c_wraith> I guess the lazy version would blow up the stack in "last $ iterate swap (1, 2)", where the less-lazy version would just not terminate. :)
14:46:31 <c_wraith> bottoms for everyone!
14:46:43 <sinelaw> hah
14:47:03 <Saizan> the strict version will blow the stack if you don't do tail recursion, the lazy one will blow the stack if you do
14:47:05 <aavogt> > iterate (\x -> let (a,b) = x in (b,a)) (1,2) !! 10000
14:47:05 <lambdabot>   (1,2)
14:47:11 <aavogt> > iterate (\x -> let (a,b) = x in (b,a)) (1,2) !! 1000000
14:47:15 <lambdabot>   mueval-core: Time limit exceeded
14:47:37 <aavogt> > iterate (\x -> let (a,b) = x in (b,a)) (1,2) !! 100000
14:47:39 <lambdabot>   (1,2)
14:47:46 <aavogt> > iterate (\x -> let !(a,b) = x in (b,a)) (1,2) !! 100000
14:47:47 <lambdabot>   (1,2)
14:48:00 <Saizan> but tbh, swap being strict doesn't help much with the tail recusion, since you probably want to force the contained values too anyway.
14:50:27 <tromp_> the >>= for Maybe doesn't have an alternative name?
14:50:39 <Saizan> no
14:51:01 <tromp_> i guess it's maybe Nothing
14:51:18 <tromp_> hmm, not quite
14:51:21 <monoidal> :t maybe Nothing
14:51:23 <monoidal> :t (>>=)
14:51:24 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
14:51:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:51:35 <kmc> :t flip $ maybe Nothing
14:51:35 <lambdabot> forall a a1. Maybe a1 -> (a1 -> Maybe a) -> Maybe a
14:51:39 <kmc> cute
14:55:37 <Phyx-> has anyone ever noticed that on msys haskell programs tend to hang?
14:58:15 <monochrom> triyo: split (condense . dropDelims $ oneOf " ,") "xxx   ,  yyy  ,   zzz"
14:58:55 <triyo> monochrom: thanks a mill
14:59:56 * Phyx- taps the mic
15:00:06 <Phyx-> this thing doesn't seem to be working tnight
15:00:09 <Phyx-> :P
15:00:26 <monochrom> what is msys?
15:01:12 <ddarius> The real solution re swap is to have different types for strict and lazy pairs, or just do what is done now and not bother.  Writing the lambda is not that cumbersome.
15:01:43 <Phyx-> monochrom: MSYS, a contraction of "Minimal SYStem", is a Bourne Shell command line interpreter system. Offered as an alternative to Microsoft's cmd.exe, this provides a general purpose command line environment, which is particularly suited to use with MinGW, for porting of many Open Source applications to the MS-Windows platform
15:03:14 * Saizan found simpler to use mingw from cmd.exe in the past
15:25:34 <sinelaw> whoa computer almost on fire
15:25:43 <sinelaw> get me the firehouse
15:26:10 <djahandarie> lol
15:26:13 <fxr> yeah here is a thunderstorm
15:26:14 <kmc> better tweet it
15:26:25 <kmc> or do you live in one of those backwards countries where the firemen still aren't dispatched by twitter?
15:26:44 <k23z> I saw a website today
15:26:46 <k23z> I want to show it
15:27:01 <k23z> http://gf3.ca/
15:27:17 <k23z> kmc: notice the "herp,derp" sound of the bird
15:28:11 <djahandarie> Odd website...
15:30:09 <k23z> djahandarie: let me guess, you didn't like it
15:30:11 <sinelaw> at least i'm not in those parts where execution verdicts are tweeted
15:30:23 <ivanm> lol
15:30:38 <sinelaw> "wowzors, he's had it coming! hehe c u @ dinner"
15:32:48 <kmc> heh
15:33:01 <kmc> i don't see the big deal there
15:33:06 <kmc> the message wasn't like that ;P
15:33:13 <sinelaw> kmc yeah, i know
15:33:50 <sinelaw> i don't think it's such a big deal. worse things are happening all the time
15:34:12 <sinelaw> it does seem a bit tasteless though
15:35:03 <sinelaw> i never use tweeter anyway so i can patronize them all regardless
15:35:19 <kmc> yeah
15:35:24 <djahandarie> I tried using twitter once, but it failed pretty hard.
15:35:27 <kmc> worse things are happening all the time
15:35:36 * sinelaw twiddles his thumbs and spins his cane
15:35:38 <djahandarie> I also tried writing a blog, that didn't work either.
15:35:44 <kmc> also i don't see why it's considered barbaric to execute people by firing squad
15:35:48 <kmc> more so than executing them in general
15:36:10 <sinelaw> yeah, historically it's considered the more honourful way to get executed
15:36:12 <kmc> given that the guy chose it too
15:36:15 <sinelaw> if there is such a thing
15:37:13 <sinelaw> some of the nurenberg convicts really tried to get firing squad executions instead of hanging, to make a point that they were "only soldiers"
15:38:20 <kmc> heh
15:38:44 <sinelaw> they didn't get it though
15:42:51 <Riviera> sinelaw: it was not so much about "only soldiers"
15:43:36 <Riviera> sinelaw: they understood this kind of death more "honourable", because it's what a soldier deserves, contrary to hanging, which lacks all honour
15:44:12 <chaosape> I have a constant variable with a particularly messy type.  I would like to wrap that constant in a data structure.  I would also like to avoid filling in that messy type in the definition of the data structure.  Any suggestions?
15:44:51 <monoidal> define a synonym for that messy type?
15:44:51 <sinelaw> Riviera yeah, that's what i meant more or less
15:45:08 <sinelaw> Riviera they were trying to emphasize that they deserve at least an honour death
15:45:16 <chaosape> ((Data.Record.:&)
15:45:16 <chaosape>           ((((Data.Record.X Data.Record.:& (Source Data.Record.::: Word16))
15:45:16 <chaosape>              Data.Record.:& (Destination Data.Record.::: Word16))
15:45:16 <chaosape>             Data.Record.:& (Len Data.Record.::: Word16))
15:45:16 <chaosape>            Data.Record.:& (CheckSum Data.Record.::: Word16))
15:45:17 <chaosape>           (Network.HeaderNinja.EndField Data.Record.::: ())
15:45:17 <chaosape>           (Data.TypeFun.Id Data.Kind.KindStar),
15:45:18 <chaosape>         B.ByteString)
15:45:21 <Riviera> sinelaw: oh, sorry, i should have read the backlog
15:45:32 <chaosape> sorry about that ...
15:46:16 <chaosape> I should have been a bit more careful with the cut and paste.  I apologize.
15:47:42 <kmc> don't use qualified names?
15:47:56 <kmc> i agree it's pretty gruesome either way
15:49:31 <npouillard> Why the `Real' class is not derivable when Enum is?
15:49:53 <Saizan> ?src Real
15:49:53 <lambdabot> class  (Num a, Ord a) => Real a  where
15:49:53 <lambdabot>     toRational      ::  a -> Rational
15:50:10 <mauke> npouillard: because Enum is simple
15:50:11 <npouillard> The implementation of toRational could be simply toRational . fromEnum
15:50:11 <kmc> what would the obvious derivation be?
15:50:32 <kmc> hmm interesting
15:50:41 <Saizan> but Enum is not a superclass of Real, i think?
15:50:42 <kmc> are there any "conditional derivations" like that?
15:50:51 <kmc> where deriving S requires an instance for T but T is not a superclass of S?
15:51:06 <ddarius> kmc: I don't believe so.
15:51:23 <kmc> fwiw "derive" doesn't have Real either
15:51:32 <kmc> the boilerplate instance you suggest is only one line
15:51:42 <kmc> and feels kind of controversial
15:51:54 <kmc> so i imagine if it was ever discussed it committee, it was resolved as "not a big deal"
15:52:18 <npouillard> indeed that's not big deal
15:52:22 <kmc> you can't derive Integral either
15:52:32 <kmc> but that might be less surprising
15:53:13 * npouillard is deriving arithmetic modulo for a from (Bounded a, Enum a)
15:53:34 <npouillard> Num/Real/Integral
15:54:05 <kmc> cool
15:54:25 <kmc> that sounds like TH or even CPP would make short work of it
15:54:32 <sinelaw> npouillard can you do finite fields too? :)
15:54:40 <kmc> CPP is used for Typeable a lot in the std lib
15:54:52 <kmc> (to not rely on the GHC DeriveDataTypeable extension?)
15:54:57 <kmc> non-derived Typeable is just dangerous though :/
15:55:12 <npouillard> sinelaw: to what end if I don't release the code :)
15:55:36 <sinelaw> :(
15:56:21 <sinelaw> npouillard could be useful for implementing some coding (as in error control coding, etc.) stuff
15:57:08 <npouillard> I mean that I can share it but won't take time for it
15:58:10 <sinelaw> i don't really need it, just a thought about this being useful for other things as well
16:00:46 <chaosape> Okay, I think I my question is better explained here -> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26408#a26408.  I am open to any suggestions.
16:01:07 <kmc> hmm
16:01:16 <kmc> does GHC have any knowledge that typeOf ignores its first arg
16:01:29 <kmc> in order to compile-time constant-fold Typeable dictionaries?
16:01:58 <kmc> and if not, would Typeable be faster if Â«typeOf :: Tagged a TypeRepÂ» ?
16:06:00 <Saizan> chaosape: i think the only way is to use TH for something like TYPEOF, hoping reify 'updheader will tell you its type
16:07:01 <gwern> kmc: look at the core
16:08:28 <chaosape> Saizan: Thanks!
16:08:41 <chaosape> Saizan: I will go give that a whirl.
16:08:55 <kmc> but core is scary
16:09:21 <gwern> eh. it's easy enough for your purpose
16:09:48 <monoidal> is there instance for Applicative (GenParser st a) by default?
16:10:18 <Saizan> there should be one in parsec-3
16:11:05 <kmc> in core:  Foo.t = Data.Typeable.$fTypeableChar1
16:11:10 <kmc> what's the $ mean here?
16:12:49 <cheater99> hey guys
16:13:14 <cheater99> what's the logic behind the fact that :l modulename loads the functions defined in that module into the global space, as opposed to some specific namespace?
16:13:20 <monoidal> Saizan: thanks
16:13:51 <gwern> cheater99: in ghci, what specific namespace would there be?
16:14:37 <cheater99> well, if i do :l mystuff then i would normally expect something like, oh, mystuff.foo() and mystuff.bar()
16:14:58 <kmc> it acts like a regular import
16:15:03 <kmc> also not sure what the () syntax means here
16:15:13 <kmc> the fix to this would be to add real import statements to GHCi
16:15:20 <kmc> i'm often annoyed that i can't do qualified imports in GHCi
16:15:32 <gwern> iirc, that was fixed
16:15:35 <kmc> really?
16:15:43 <kmc> in HEAD?
16:15:45 <gwern> or at least, I remember that bug report being modified recently
16:16:06 <gwern> dunno. go lookc it up on trac
16:16:18 <cheater99> kmc: yeah, those parens shouldn't be there :)
16:16:43 <cheater99> gwern: so how would i do this then? :)
16:17:12 <gwern> cheater99: for the most part you don't
16:17:16 <gwern> it's an interpreter
16:17:23 <gwern> you want to type as little as possible
16:17:36 <gwern> but you can give fully qualified names when it clashes
16:17:47 <cheater99> how?
16:17:48 <gwern> you just can't import under arbitrary prefixes
16:17:53 <kmc> you can make a module which does a qualified import
16:17:55 <kmc> and load that module
16:18:07 <gwern> cheater99: Prelude.map, eg
16:18:12 <cheater99> looking
16:18:51 <cheater99> wait a sec
16:19:46 <cheater99> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26410#a26410
16:20:44 <cheater99> ^ doesn't seem to work, gwern
16:21:36 <gwern> cheater99: as ghci tells you, the name of what you have loaded is not 'recursion'
16:27:12 <cheater99> gwern: what is it then?
16:28:07 <Saizan> cheater99: when you load a file the things defined in that file are dumped in the toplevel namespace, so to speak
16:28:20 <cheater99> Saizan: how do i make it not do that?
16:28:35 <Saizan> you can't
16:28:46 <cheater99> that is extremely crap
16:29:07 <roconnor> is sort stable?
16:29:13 <roconnor> sortBy
16:29:35 <cheater99> Saizan: is this only limited to importing in ghci, or is it that way everywhere?
16:29:36 <Saizan> cheater99: though if you put "module Recusion where" at the top of your file and also rename recursion.hs to Recursion.hs you can also refer to them as Recursion.foo
16:30:23 <cheater99> Saizan: ah
16:30:32 <cheater99> Saizan: is that the typical way to develop modules in haskell?
16:30:45 <Saizan> cheater99: it's the same if you just do "import Recursion" from some other module, but there you can do "import qualified Recursion" too
16:31:15 <illissius> kmc: if it's defined as `typeRep = const $ whatever` then would it be a constant by default?
16:31:22 <cheater99> it makes me sad that the interpreter is different than the language
16:31:31 <Saizan> adding "qualified" means that you'll be able to refer to things defined in Recursion only by qualified names, i.e. those with Recursion. in front
16:32:03 <cheater99> Saizan: yeah
16:32:32 <cheater99> Saizan: but you can't do that in the interpreter :(
16:32:53 <kmc> illissius, yeah
16:33:27 <Gracenotes> @hoogle Eq a => [(a, b)] -> [(a, c)] -> [(b, c)]
16:33:28 <lambdabot> Data.Graph.Inductive.Graph insNodes :: DynGraph gr => [LNode a] -> gr a b -> gr a b
16:33:28 <lambdabot> Data.Graph.Inductive.Query.BFS leveln :: Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]
16:33:28 <lambdabot> Data.Graph.Inductive.Query.BFS bfen :: Graph gr => [Edge] -> gr a b -> [Edge]
16:33:43 <Gracenotes> hm. worth a shot.
16:33:55 <kmc> my question didn't really make sense
16:34:16 <kmc> because a function polymorphic on a Typeable-qualified variable will have to take a Typeable dictionary
16:34:18 <kmc> same as any other class
16:34:21 <kmc> unless it's inlined everywhere
16:35:10 <Saizan> cheater99: yeah, ghci accepts a quite limited subset of haskell atm, it's mostly that not many have needed much more so no one has made the effort to extend it
16:35:44 <cheater99> is there an interpreter that does the whole shebang?
16:36:20 <kmc> hugs iirc
16:36:23 <Saizan> there was the interpreter for hbc they say
16:36:35 <Saizan> hugs doesn't accept declarations either iirc
16:36:38 <kmc> oh
16:36:45 <cheater99> what's hbc?
16:37:03 <Saizan> Haskell B? Compiler
16:37:12 <ddarius> Saizan: Haskell B Compiler
16:37:37 <Saizan> http://www.haskell.org/haskellwiki/Implementations#HBI_and_HBC.2C_Chalmers.27_Haskell_Interpreter_and_Compiler <-
16:38:06 <Saizan> ddarius: where does the B come from?
16:38:16 <ddarius> Saizan: Look at Haskell Curry's wikipedia entry.
16:38:55 <Saizan> oh, nice :)
16:41:37 * hackagebot bindings-gsl 0.2 - Low level bindings to GNU GSL.  http://hackage.haskell.org/package/bindings-gsl-0.2 (MauricioAntunes)
16:42:10 <coreyn> Haskell newbie question: is using last on a list (or indexing in general) a linear time operation?
16:42:21 <ddarius> coreyn: Yes.
16:42:29 <coreyn> thought so
16:43:53 <kmc> it can also throw a runtime exception
16:43:54 <kmc> if the list is empty
16:44:21 <kmc> Data.Sequence provides a fast indexable sequence
16:44:25 <coreyn> I'm trying to implement Graham's scan algorithm and it's driving me mad, being a FP idiot atm 
16:44:38 <kmc> Data.Map and Data.IntMap provide general key-value maps, which could be used for sequencestoo
16:44:50 <mauke> but you can get a O(1) length by annotating lists with their length
16:45:04 <coreyn> thanks
16:45:14 <kmc> and Data.Array provides constant-time indexing, but has a variety of other inconveniences
16:45:28 <kmc> i think it's best to avoid arrays except in actual stateful imperative code (IO or ST etc)
16:46:20 <coreyn> yes, I'm reading Real World Haskell and I haven't learned about any stateful stuff yet
16:53:26 <marcelofs> i just started learning Haskell a few days ago, so here goes a very newbie question: any hints on how do i get a list of sums out of a list of even numbers?
16:53:44 <marcelofs> i started with a list of numbers in sequence, so [x*(x+1)/2|x<-[1..10]] solved it
16:54:11 <marcelofs> i was wondering how to do it if, for instance, i have [2, 4, 6] 
16:54:44 <kmc> you want the running sums?
16:54:49 <Axman6> > scanl (+) 0 [2,4..]
16:54:50 <lambdabot>   [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462...
16:55:05 <monochrom> immutable arrays are useful for write-once dynamic programming
16:55:09 <kmc> scanl is like foldl but produces a list of every accumulator value rather than only the last one
16:55:16 <Axman6> though scanl is a bit advanced if you're new to haskell (it won't be for long though ;)
16:55:23 <kmc> true monochrom
16:55:46 <kmc> marcelofs, if you're new to Haskell you might find it more satisfying/enlightening to write the recursion yourself
16:55:48 <kmc> rather than using scanl
16:55:59 <monochrom> There are a few dynamic programming algorithms not write-once, and so I don't know how to tame them. :)
16:56:15 <marcelofs> indeed kmc, though i'll take a look at scanl later too
16:56:26 <kmc> scanl, foldl, map, etc. are just generalizations of common patterns of recursion
16:57:01 <Saizan> monochrom: oh, for example?
16:57:34 <danharaj> can you write scan in terms of fold?
16:57:43 * hackagebot Vec-OpenGLRaw 0.2.0.0 - Instances and functions to interoperate Vec and OpenGL.  http://hackage.haskell.org/package/Vec-OpenGLRaw-0.2.0.0 (ChristopherLaneHinson)
16:57:44 <danharaj> or maybe fold and unfold?
16:57:45 <Saizan> it might be even more enlightening to write an implementation of scanl yourself :)
16:57:56 <marcelofs> kmc: any hints on where to start, without using those you mentioned?
16:58:09 <ReinH> Axman6: out of the entire haskell canon, you picked "scanl" as the "a bit advanced if you're new to haskell" thing?
16:58:10 <monoidal> marcelofs: do you know how to write foldl?
16:58:11 <monochrom> There is a slick n*log n dynamic programming algorithm for longest increasing subsequence (can be non-consecutive) and it can modify the same array entry several times.
16:58:13 <ReinH> :p
16:58:15 <marcelofs> Saizan: i'm yet too newbie fot that =p
16:58:19 <marcelofs> *for
16:58:26 <kmc> marcelofs, the problem is to compute the running sum of a sequence
16:58:28 <kmc> right?
16:58:32 <kmc> write the case for []
16:58:35 <kmc> and the case for (x:xs)
16:58:46 <danharaj> marcelofs: No you're not. You can do it. We believe in you.
16:58:52 <marcelofs> yes, that's it, i guess
16:58:56 <kmc> once you've done this
16:59:06 <kmc> generalizing to the point where you've implement scanl
16:59:08 <kmc> will be easy
16:59:32 <Saizan> marcelofs: you probably want to take an extra argument for the value of the sum so far.
16:59:36 <gwern> roconnor: I'm pretty sure Data.List.sort is stable; note that Data.Sequence.sort is stable, and the unstable sort, while faster, has to be asked for specifically
17:00:39 <roconnor> thanks
17:01:58 <gwern> > sort [(1,0),(2,2),(4,0),(1,2),(1,3)]
17:01:59 <lambdabot>   [(1,0),(1,2),(1,3),(2,2),(4,0)]
17:02:04 <gwern> stable
17:02:38 <gwern> 1,0 comes before 1,2 and 1,2 comes before 1,3 as they were in the original, are now, and ever shall be, world without end amen
17:03:16 <mauke> > sort (reverse [(1,0),(2,2),(4,0),(1,2),(1,3)])
17:03:17 <lambdabot>   [(1,0),(1,2),(1,3),(2,2),(4,0)]
17:03:29 <monoidal> (1,0) < (1,2)
17:04:05 <mauke> > sortBy (comparing fst) [(1,0),(2,2),(4,0),(1,2),(1,3)]
17:04:07 <lambdabot>   [(1,0),(1,2),(1,3),(2,2),(4,0)]
17:04:25 <danharaj> 01> sortBy (comparing fst) [(1,0),(2,2),(4,0),(1,3),(1,2)]
17:04:46 <danharaj> 01> sortBy (comparing fst) [(1,0),(2,2),(4,0),(1,2),(1,3)]
17:04:55 <danharaj> :[
17:05:04 <mauke> > ()
17:05:05 <lambdabot>   ()
17:05:33 <danharaj> > sortBy (comparing fst) [(1,0), (2,2),(4,0),(1,3),(1,2)]
17:05:34 <lambdabot>   [(1,0),(1,3),(1,2),(2,2),(4,0)]
17:06:52 <aristid> @hoogle maximumOn
17:06:53 <lambdabot> No results found
17:06:58 <aristid> @hoogle sortOn
17:06:58 <lambdabot> No results found
17:07:22 <aristid> @pl \f -> sortBy (comparing f)
17:07:22 <lambdabot> sortBy . comparing
17:07:53 <aristid> @let sortOn = sortBy.comparing
17:07:54 <lambdabot>  <local>:22:0:
17:07:54 <lambdabot>      Multiple declarations of `L.sortOn'
17:07:54 <lambdabot>      Declared at: <lo...
17:15:49 * hackagebot bindings-gobject 0.2.1 - Low level bindings supporting GObject and derived libraries.  http://hackage.haskell.org/package/bindings-gobject-0.2.1 (MauricioAntunes)
17:18:29 <interferon> is there any way to catch "bottom"?  or when you call "error blah" does that always terminate your program?
17:18:59 <mauke> there is, with Control.Exception.catch
17:19:10 <mauke> but not bottom in general, because that includes infinite loops
17:19:35 <kmc> interferon, evaluating an "error" call is a regular Control.Exception exception
17:19:56 <kmc> so you can catch it easily from an IO action
17:20:25 <interferon> i see
17:20:32 <aristid> does that include catchin undecorated "undefined"?
17:20:33 <mauke> well, "easily"
17:20:37 <interferon> so bottom can either mean "nonterminating" or "error / underfined"
17:20:37 <mauke> @src undefined
17:20:38 <kmc> yeah
17:20:38 <lambdabot> undefined =  error "Prelude.undefined"
17:20:42 <interferon> @src error
17:20:43 <kmc> yes
17:20:43 <lambdabot> error s = throw (ErrorCall s)
17:20:48 <kmc> bottom is a term from denotational semantics
17:21:01 <aristid> mauke: i don't trust @src very much
17:21:04 <kmc> meaning that there's no value
17:21:11 <mauke> good :-)
17:21:19 <interferon> i see
17:21:20 <kmc> we don't distinguish between a loop and an exception, since those are operational concerns
17:21:22 <aristid> sometimes @src has code that isn't the real code
17:21:27 <kmc> indeed GHC will sometimes detect a loop and throw an exception
17:21:44 <interferon> kmc: really?
17:21:51 <kmc> yes
17:21:52 <interferon> kmc: how can it tell?
17:21:56 <roconnor> which has more sharing (map inits . tails) or (map tails . init) ?
17:21:57 <danharaj> Deep magic.
17:21:58 <KaffeeJunky123> http://www.haskell.org/tutorial/goodies.html <-- is this a good place to start learning haskell?
17:22:11 <kmc> it's not that magical or clever
17:22:14 <interferon> KaffeeJunky123: book.realworldhaskell.org
17:22:17 <roconnor> probably map tails . inits ?
17:22:19 <danharaj> kmc: hush, you are ruining the mysticism :p
17:22:22 <kmc> if forcing x requires forcing x, there is an infinite loop
17:22:47 <kmc> this is implemented by having each updatable closure replace itself with a special "black hole" closure when entered
17:22:51 <monochrom> > let {x :: Bool; x = x} in x
17:22:54 <lambdabot>   mueval-core: Time limit exceeded
17:22:56 <kmc> then when evaluation of the closure completes, it is again replaced with the final value
17:23:04 <kmc> entering a black-hole closure raises an exception
17:23:14 <KaffeeJunky123> interferon: thanks
17:23:15 <monochrom> > let {x :: Bool; x = not x} in x
17:23:18 <lambdabot>   mueval-core: Time limit exceeded
17:23:21 <monochrom> strange
17:23:33 <danharaj> KaffeeJunky123: I think gentle introduction is mainly for people who have worked with functional programming before but not haskell specifically. It may be rough for someone with no background or an imperative background.
17:23:58 <aristid> monochrom: you expected it to show an exception?
17:24:02 <kmc> in a threaded RTS, the black hole is instead a "white hole", which does not raise an exception but merely blocks the current thread by placing it on a wait queue, and unblocking it when evaluation finished
17:24:06 <monochrom> Yes.
17:24:13 <kmc> KaffeeJunky123, danharaj, imo the Gentle Introduction is not a tutorial at all, URL aside
17:24:20 <kmc> it doesn't have the form of a tutorial
17:24:26 <danharaj> kmc: You think it's more of a reference?
17:24:27 <monochrom> Oh! I remember why now.
17:24:34 <kmc> it's an informal tour of the language spec, with more examples
17:24:46 <kmc> it's not a reference, in that it's meant to be read through
17:24:59 <kmc> but not with "learn how to write Haskell code" as the goal
17:25:01 <KaffeeJunky123> danharaj: I have a strong c++ background, so functional programming is somewhat new to me 
17:25:03 <kmc> the goal is "understand the Haskell spec"
17:25:33 <KaffeeJunky123> well it's a good read 
17:25:37 <kmc> KaffeeJunky123, you'll find that Haskell has a lot of new concepts beyond just FP
17:25:58 <danharaj> For example, Haskell has this concept of syntax that doesn't rape your eyes.
17:26:06 <aristid> :t text
17:26:07 <lambdabot> String -> Doc
17:27:58 <kmc> Haskell and C++ both have many features found almost nowhere else
17:28:23 <monochrom> (why bring up c++?)
17:28:29 <monochrom> (oh nevermind)
17:28:42 <aristid> monochrom: because it's a much-beloved topic here.
17:28:45 <kmc> hehe
17:28:52 <danharaj> #trolls :D
17:29:42 <coreyn> features like driving me mad? 
17:29:51 <kmc> no, plenty of languages do that
17:30:00 <aristid> c++ has types parametrised on values
17:30:05 <aristid> haskell does not :>
17:30:06 <kmc> indeed
17:30:16 <kmc> C++ is dependently typed ;)
17:30:21 <kmc> sort of
17:30:22 <monochrom> was going to say...
17:30:26 <aristid> kmc: in a very restricted way
17:30:27 <kmc> templates are not really first-class types
17:30:35 <gwern> aristid: but we can fake dependent types!
17:30:52 <aristid> gwern: which is just what c++ does.
17:30:58 <dolio> C++ has types parameterized by static values.
17:31:04 <monochrom> use GÃ¶del numbering to obtain full dependent predicate subtype
17:31:04 <kmc> it might be fairer to say that C++ has metaprograms which input values and output types
17:31:20 <aristid> kmc: is there a difference?
17:31:22 <dolio> You can simulate static values by encoding them into types in Haskell.
17:31:39 <dolio> In GHC, at least.
17:31:45 <kmc> aristid, yes
17:31:49 <dolio> It'd be better if there were things like datakinds, of course.
17:31:51 <aristid> dolio: and if you add some extensions you get turing complete type computations?
17:31:59 <dolio> Yes.
17:32:35 <kmc> for example, templates have "runtime" name lookup and "dynamic" duck typing
17:32:43 <kmc> where the run time is the compile time of your program
17:33:10 <kmc> there is only a halfassed attempt to type-check a template before it is instantiated
17:33:21 <kmc> which imo is worse than making no attempt and having them be simple hygenic macros
17:33:39 <kmc> (for example the name lookup rules change in complicated nonintuitive ways when inside a template due to this halfassed attempt)
17:33:59 <aristid> hygienic macros, like in r5rs?
17:34:02 <mauke> @quote .knives
17:34:02 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
17:34:08 <kmc> haha
17:34:22 <kmc> yeah aristid
17:34:28 <kmc> (with the caveat that i don't know scheme in detail)
17:34:40 <aristid> kmc: i think it's funny that scheme abandoned this macro system
17:34:45 <kmc> it did?
17:34:51 <aristid> afaik r6rs has a "normal" macro system
17:35:00 <danharaj> no one uses r6rs, though.
17:35:10 <aristid> danharaj: does anybody use hygienic macros?
17:35:17 <danharaj> aristid: does anyone use lisp?
17:35:19 * danharaj rimshot
17:35:21 <aristid> yes:)
17:35:25 <aristid> people do use lisp
17:35:28 <kmc> 'Macros defined using syntax-rules and identifier-syntax are â€œhygienicâ€ and â€œreferentially transparentâ€ and thus preserve Schemeâ€™s lexical scoping' -- r6rs Â§9.2
17:35:33 <danharaj> aristid: does anyone without a neckbeard use lisp?
17:35:38 <kmc> haha
17:36:08 <jbapple> danharaj: The clojure author doesn't have a neckbeard
17:36:15 <jbapple> He does had a fluffy mullet, though
17:36:17 <kmc> crazy hair though
17:36:19 <jbapple> *have
17:36:32 <danharaj> crazy hair totally counts as a neckbeard, except on your head.
17:36:34 <danharaj> headbeard?
17:36:45 <jbapple> or "hair", in the vernacular.
17:36:55 <aristid> danharaj: does anybody without a neckbeard use haskell?
17:37:06 * kmc .
17:37:11 <danharaj> aristid: I do. I use windows, so I can't have a neckbeard.
17:37:12 <jbapple> SPJ doesn't have a neckbeard
17:37:26 <aristid> jbapple: SPJ presumably uses windows too
17:37:29 <jbapple> I don't understand this line of questioning
17:37:32 <kmc> SPJ uses Comic Sans MS
17:37:34 <aristid> aren't people at microsoft forced to use windows?
17:37:39 <KaffeeJunky123> doesn't everyone wear neckbeards nowdays?
17:37:41 * Pseudonym has one at the moment, but only because he hasn't shaved in a week
17:37:43 <kmc> i think MSR gets to do whatever they want
17:37:44 <danharaj> jbapple: neckbeard is a metaphor :)
17:37:46 <aristid> kmc: Comic Sans MS probably counts as a neckbeard.
17:37:52 <kmc> no
17:37:54 <kmc> it's the total opposite
17:37:59 <aristid> oh
17:38:02 <danharaj> Comic Sans MS is prepubescence.
17:38:15 <kmc> neckbeard = pedantic, strong angry opinions about stupid things
17:38:18 <Pseudonym> Comic Sans is like the pop song that's overplayed.
17:38:20 <kmc> comics sans is one of two things
17:38:29 <kmc> it's either totally uninformed and tasteless, therefore not an angry elitist opinion
17:38:34 <kmc> or it's ironic and therefore hipsterish
17:38:36 <robertmassaioli> vaccum-cairo does not compile on my machine and the hackage page (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-cairo) says that it is because it does not compile on ghc-6.12. Has anybody with 6.12 got it to compile?
17:38:40 <Pseudonym> It might be an okay song out of context, but it's the over-playedness that makes it crap.
17:38:50 <aristid> kmc: hipsterish as in http://www.mcsweeneys.net/links/monologues/15comicsans.html
17:38:53 <danharaj> kmc: I think it's more like, stereotypical basement dwelling programmer attitude, but those are strongly correlated in my stereotypes :p
17:38:54 <kmc> yes, and ruins it even for the cases where you'd want it
17:38:55 <Pseudonym> IF you're doing actual comic lettering, then there are worse choices.
17:38:55 <aristid> i love dropping that link
17:38:58 <Pseudonym> Yeah.
17:39:12 <Pseudonym> But everyone uses it inappropriately, therefore even for comic lettering it's useless.
17:39:14 <kmc> http://mirror.ctan.org/macros/latex/contrib/comicsans/comicsans.pdf
17:40:07 <Pseudonym> Handy!
17:40:34 <Saizan> robertmassaioli: what error do you get when you try it?
17:41:10 <kmc> http://achewood.com/index.php?date=06302003
17:41:26 <Pseudonym> The guy who originally did comic sans did it because a MS product required comic book lettering.
17:41:39 <Pseudonym> What he should have done is hidden it so nobody else could use it.
17:41:54 <robertmassaioli> Saizan: here is a pastebin link: http://pastebin.com/8jRyuWuk
17:42:07 <robertmassaioli> There is a name clash I think
17:42:08 <Pseudonym> But I tend to forgive, say, a kindergarten which uses it for signs around the room.
17:42:22 <danharaj> I'm glad you can take it upon yourself to forgive.
17:42:27 <danharaj> Forgive someone for using a font.
17:42:38 <Pseudonym> People say I have a messiah complex, but I forgive them.
17:43:12 <aristid> so, people with an intense hate of comic sans ms are neckbeards?
17:43:21 <kmc> the're probably hipsters too
17:43:24 <kmc> it's all very complicated
17:43:30 <danharaj> aristid: Science has shown correlation of at least .72
17:43:38 <Saizan> robertmassaioli: yeah, so the problem is not really with the version of ghc used, but with the version of gtk/cairo
17:44:05 <danharaj> I bet if you say 'gtk' three times in a row in #haskell, ManateeLazyCat_ shows up :)
17:44:09 <robertmassaioli> Saizan: oh, okay. should I try and install a different version?
17:44:35 <Saizan> robertmassaioli: actually just gtk
17:44:41 <aristid> kmc: what's the correlation between physical neckbeards and ACTUAL neckbeards?
17:45:09 <robertmassaioli> Saizan: ok, which version of gtk should I use?
17:45:21 <danharaj> aristid: Everyone who wears a neckbeard is either a hipster or a neckbeard, while not all neckbeards have a neckbeard.
17:45:58 <aristid> danharaj: and what are people who have been too lazy to shave and have hair on their neck?
17:46:13 <robertmassaioli> Saizan: I just checked, there is only one version of GTK on hackage: http://hackage.haskell.org/package/gtk-0.11.0
17:46:27 <Pseudonym> BTW, in my case it's partly deliberate.  I'm growing my hair out, but it's not quite at the stage where I can put it in a ponytail yet.
17:46:33 <Pseudonym> So I resemble RMS.
17:46:37 <robertmassaioli> Saizan: it's (0.11.0)
17:46:38 <Saizan> robertmassaioli: an older one, the one that was available at the moment of upload is the most likely to work, which was Sun Apr 19 10:15:26 UTC 2009
17:46:49 <Pseudonym> Except my hair is washed.
17:46:54 <Saizan> robertmassaioli: yeah, older gtk versions can be found on the gtk2hs website
17:47:08 <danharaj> aristid: Neckbeards have non-strict semantics. If when evaluated these people shave their neckbeards (such as needing to hygeine it up for a party), then they are not neckbeards.
17:47:12 <Saizan> robertmassaioli: OTOH one could try to update vacuum-cairo's code
17:47:14 <danharaj> This is called beard-by-need
17:47:31 <danharaj> shave-by-need*
17:47:44 <aristid> danharaj: ah, it's like non-deterministic haskell values
17:48:12 <robertmassaioli> Saizan: I guess that would be worthwhile. Make a bugfix maybe. Perhaps I'll do that.
17:48:43 <SuperMario> I downloaded GHCi ...what do I save a haskell file as in order to run it like in python it's .py 
17:49:20 <mauke> SuperMario: you don't
17:49:24 <mauke> you compile it first
17:49:45 <aristid> well there's runhaskell
17:50:17 <SuperMario> so in the command line i type what ...compile C:/Documents and Settings/blahblhafile name . Somethng ?
17:50:26 <SuperMario> and then run file name
17:50:29 <mauke> oh god
17:50:39 <coreyn> runghc filename
17:50:54 <Saizan> robertmassaioli: it's quite simple actually, add " hiding (eventKeyName)" to the "import qualified Graphics.UI.Gtk as G" line in System.Vacuum.Cairo
17:51:03 <kmc> ghc --make foo.hs && ./foo
17:51:19 <kmc> this will be faster (in every sense) than runghc
17:51:24 <Saizan> robertmassaioli: you should send a patch to dons :)
17:51:27 <SuperMario> is there a way to cd to the Documents and Settings so I dont have to type it each time
17:51:30 <kmc> except if you touch every file, maybe
17:51:35 <mauke> SuperMario: ... yes
17:51:37 <kmc> cd
17:51:54 <SuperMario> im in windows
17:52:01 <kmc> windows doesn't have cd?
17:52:05 <kmc> maybe it's name chdir
17:52:14 <mauke> kmc: it does
17:52:19 <robertmassaioli> Saizan: I think that sounds like a good idea. :) And it would mark my first contrib back to the haskell community. Yay.
17:55:03 <Axman6> SuperMario: it's cd in windows too
17:55:40 <kmc> btw ##windows might have better advice on using the windows command shell
17:55:46 <kmc> my advice is likely to be snarky and unhelpful
17:55:48 <KaffeeJunky123> it's billrlznowctfd 
17:55:53 <KaffeeJunky123> in windows
17:56:03 <SuperMario> Axman : yea i got it thanks
17:58:26 <coreyn> wow, I think I'm too stupid for Haskell lol
17:58:39 <coreyn> still can't figure out how to write Graham's scan in it
17:58:51 <Pseudonym> Haskell's purpose for existence is to keep programmers humble.
17:59:00 <coreyn> well it's working
17:59:25 <Pseudonym> Having said that, Graham's scan sounds like an excellent problem to implement in Haskell.
17:59:47 <coreyn> yes, it
17:59:53 <kmc> coreyn, how long have you been studying Haskell
17:59:54 <coreyn> it's a problem in real world haskell
17:59:57 <Pseudonym> Right.
18:00:02 <coreyn> about 2 days
18:00:05 <kmc> heh
18:00:23 <SuperMario> so I saved my haskell file as haskell.txt ...and in the command line i type runghc haskell.txt  but it's not working ...guess im summed to change the extension to .hk ? 
18:00:28 <Pseudonym> Try implementing Graham's scan in any other language you've only spent two days on.
18:00:31 <kmc> i'd say you're not too dumb, or at least there's no evidence yet that you are
18:00:38 <kmc> Haskell is not a jump-right-in language
18:00:44 <danharaj> SuperMario: .hs
18:00:49 <KaffeeJunky123> most languages aren't jump right in
18:00:52 <Pseudonym> Actually, I think Haskell rewards people who jump-right-in.
18:00:55 <kmc> Pseudonym, it'd work fine if that language is just a trivial syntactic variation on another language you know
18:01:01 <Pseudonym> Well, yes./
18:01:17 <kmc> which is how a lot of them are -- at least to the relatively shallow level of implementing a single algorithm
18:01:21 <Pseudonym> So if you have an implementation in an imperative language, implementing it in another one should be easy via cargo cult programming.
18:01:33 <kmc> no, imperative languages differ vastly
18:01:39 <kmc> for example Haskell and C++ are both imperative languages
18:01:46 <Pseudonym> However, by the time you've got working code in Haskell, you'll REALLY understand the essence of the algorithm, no?
18:01:46 <danharaj> I think that is a misuse of 'cargo cult'
18:01:49 <kmc> or Java and x86 assembly
18:02:06 <KaffeeJunky123> x86 assembly is more readable then java 
18:02:15 <kmc> Pseudonym, maybe, but is that due to Haskell itself, or due to having to think harder due to unfamiliarity?
18:02:17 <kmc> i'd say some of each
18:02:19 <Pseudonym> danharaj: What I mean in this sense is that you may not learn what all of the boilerplate module prelude stuff means.
18:02:31 <danharaj> Pseudonym: Ah, then it is a good use.
18:02:31 <Pseudonym> kmc: Some of each, yes.
18:02:36 <QtPlatypus> I've found that when learning languages the second period is translating idioms from laugnages I know into it.
18:03:11 <SuperMario> sweet 
18:03:50 <Pseudonym> danharaj: When translating an algorithm in, say, Java into one in, say, Python, you probably will only get familiar with the Python control structures and built-in data structure.
18:03:51 <Pseudonym> s
18:04:02 <Pseudonym> You won't get familiar with how to express an API.
18:04:11 <Pseudonym> Which in many languages, is the hard bit.
18:04:27 <kmc> yeah
18:04:35 <kmc> languages differ more in how they support programming in the large
18:04:38 <Pseudonym> Yeah.
18:04:44 <kmc> than in how they support coding individual algorithms
18:04:45 <KaffeeJunky123> I begin to like that realworldhaskell book
18:04:50 <KaffeeJunky123> 'don't panic' 
18:04:54 <kmc> hehe
18:04:57 <coreyn> I could almost type the pseudocode from CLRS into a text editor and run it with python... but I obviously have to think about it quite differently in haskell
18:05:04 <Pseudonym> Yeah.
18:05:08 <Pseudonym> You actually need to think.
18:05:15 <Pseudonym> However...
18:05:23 <coreyn> hence I'm panicking :p
18:05:35 <Pseudonym> That time spent thinking and understanding the algorithm when programming it in Haskell, you will have to spend that thinking time in Python too.
18:05:38 <kmc> coreyn, it takes time
18:05:50 <Pseudonym> But you'll spend it in the debugging phase rather than in the coding phase.
18:06:08 <Pseudonym> "What should I write?" is a more productive question than "What did I just write?"
18:06:10 <Pseudonym> IMO
18:06:11 <danharaj> coreyn: I think translating the wikipedia article's description of the algorithm into Haskell is much easier than imperative pseudocode.
18:06:19 <coreyn> it'd be helpful if i could litter my code with print statements
18:06:37 <Pseudonym> coreyn: I shouldn't be telling you this, but Debug.Trace.
18:06:57 <Pseudonym> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Debug-Trace.html
18:07:03 <coreyn> thanks I will look at that
18:07:05 <kmc> there is this reputation that Haskell is only for very smart people, but i think that's largely just a correlate of who cares enough to learn it
18:07:25 <Pseudonym> It's also true that the cutting edge of Haskell is more academic than, say, the cutting edge of C++.
18:07:29 <coreyn> I understand the algorithm, I can do it in my head... just having difficulty writing it in Haskell
18:07:47 <kmc> motivation and persistence matter more
18:07:53 <Pseudonym> Boost.PropertyMap isn't necessarily any easier to understand than Data Types a la Carte.
18:07:55 <coreyn> (or in a functional programming style, really)
18:08:03 <danharaj> coreyn: Ok, so let's go through the algorithm in your head step by step. Let's write it as a function. What is the type of the function?
18:08:07 <Pseudonym> But it's expressed in less mathematically-oriented language.
18:08:41 <aristid> kmc: i think that with very productive tools, we will need only relatively few programmers in the future, and these might as well be very smart.
18:08:44 <coreyn> [a] -> [a] where a is a pair of numbers
18:08:46 <Pseudonym> (I say this because I understand Data Types a la Carte, but I don't understand Boost.PropertyMap.)
18:09:18 <gwern> aristid: when our tools get better, our eyes get bigger, and the need for programmers goes up
18:09:27 <kmc> yes
18:09:34 <gwern> aristid: I don't think we're anywhere near the point of having computerized everything that can be
18:09:37 <kmc> people will always want more out of their computers
18:09:42 <coreyn> I've found the starting point and sorted them by their cotan
18:09:59 <FunctorSalad_> gwern: not even on computers
18:10:05 <danharaj> coreyn: Ok
18:10:11 <FunctorSalad_> (mechanizing tasks on computers, that is)
18:10:11 <coreyn> and I have a function that takes 3 points and gives the direction of the turn
18:10:23 <gwern> FunctorSalad_: 'as long as we have a single program, we shall never run out of programs to write'
18:10:42 <aristid> gwern: well no, but today most programmers are very unproductive
18:10:56 <gwern> most people are very unproductive
18:11:27 <FunctorSalad_> gwern: that's a stronger claim than that computers help you solve problems you wouldn't have without them... so you're saying the "chain reaction" is supercritical? ;)
18:11:56 <gwern> FunctorSalad_: no
18:12:13 <kmc> well, it's correct that soon there will be no human programmers
18:12:17 <kmc> because soon there will be no humans at all
18:12:26 <FunctorSalad_> how could a single initial program be enough then? gwern 
18:12:40 <KaffeeJunky123> kmc: depends on your definition of soon
18:12:46 <kmc> few hundred years
18:12:49 <kmc> 's nothing
18:12:51 <KaffeeJunky123> kmc: and on what you are going to do about it
18:12:56 <KaffeeJunky123> oh
18:13:02 <KaffeeJunky123> I'd doubt that 
18:13:18 <KaffeeJunky123> 2012 is coming, you know?
18:13:22 <kmc> right
18:13:23 <blackdog> kmc: depends on your definition of human, too
18:13:30 <kmc> yes
18:13:39 <coreyn> I hope I can figure this out before the world ends :(
18:14:32 <KaffeeJunky123> well still 1 and a half year left 
18:14:43 <KaffeeJunky123> so you better get going
18:15:32 <gwern> FunctorSalad_: given a program, there is always another program one can write. by induction...
18:15:40 <SuperMario> >sum[1,2,3] I type that in notepad and save it as haskell.hs and when i run it it says parse error
18:15:55 <SuperMario> what am i doing wrong ...it works when i type it in ghc directly
18:16:01 <aristid> gwern: i'd like to claim that most people are less unproductive at things other than programming. but i can't
18:16:06 <mauke> SuperMario: ghc is not the same as ghci
18:16:07 <blackdog> SuperMario: try haskell.lhs and give an extra space after the >
18:16:17 <blackdog> oh, and you need a main :)
18:16:21 <mauke> SuperMario: >sum[1,2,3] is not a valid haskell program
18:16:56 <mauke> main = print (sum [1,2,3])
18:17:18 <tensorpudding> don't you also need "module Main where"
18:17:24 <mauke> that's implicit
18:17:29 <tensorpudding> hmm
18:17:40 <SuperMario> ok cool that worked mauke
18:17:52 <mauke> 'module Main (main) where import Prelude; ...'
18:17:56 <SuperMario> should probably find a tutorial instead of trying to guess
18:18:01 <Saizan> coreyn: there's a running joke about how you need to let your brain explode a few times until it gets back together in the proper form to really be productive in haskell if you've learned typical imperative programming first :)
18:18:22 <djahandarie> I will write this guide... one day...
18:18:59 <coreyn> Saizen: well then I guess I am getting somewhere :)
18:19:59 <aavogt> @quote ghc.*brain
18:19:59 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
18:20:03 <aavogt> @quote ghc.*brain
18:20:03 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
18:20:24 <blackdog> one too many "the impossible happened"s?
18:20:31 <mauke> @ghc
18:20:32 <lambdabot> ghc says: WARNING: SE CAFs unsupported, forcing UPD instead
18:21:13 <aristid> @ghc
18:21:14 <lambdabot> ghc says: Cycle in class declarations (via superclasses)
18:21:50 <monochrom> in Soviet Russia, you check the type-checker
18:22:20 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26411#a26411
18:25:50 <aavogt> hmm, so that means you can't recursively define values that you've unpacked from one of those constructors?
18:26:49 <KaffeeJunky123> monochrom: wrong, in Soviet Russio, type-checker checks you!
18:26:56 <KaffeeJunky123> *Russia 
18:27:22 <aavogt> > let (x:xs) = x ++ xs in ()
18:27:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
18:27:34 <monochrom> much restriction in examining the value of an existential type
18:31:51 <ReinH> is there a function that takes an int and a list and returns a list of n-sized sublists? So that 3 `groupsOf` [1,2,3,4,5,6,7,8,9] => [[1,2,3],[4,5,6],[7,8,9]] ?
18:32:05 <ReinH> I suppose I could use splitAt?
18:32:31 <eugenn> >1
18:32:33 <aavogt> and unfoldr or iterate
18:32:41 <aavogt> haha, those are all functions
18:32:52 <JoeyA> Do the <* and *> operators give you pretty much nothing when handling functions?
18:33:06 <JoeyA> > (+3) *> (* 5) $ 20
18:33:07 <lambdabot>   100
18:33:08 <aavogt> @type (*>)
18:33:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
18:33:18 <JoeyA> Well, I already ran:
18:33:22 <JoeyA> @src *>
18:33:22 <lambdabot> (*>) = liftA2 (const id)
18:33:43 <JoeyA> Looks pretty useless to me.  I guess it's more useful for other Applicative instances?
18:33:57 <aavogt> so here   f *> g = \x -> f x `const` g x -- no?
18:34:10 <aavogt> err, flip the const
18:34:30 <sshc> In a list monad, I have "(x:xs) <- foo".  How do I add a type signature to x and xs?
18:34:38 <eugenn> @src liftA2
18:34:39 <lambdabot> liftA2 f a b = f <$> a <*> b
18:35:00 <aavogt> sshc: you can write them in directly if you use an extension
18:35:03 <eugenn> @src liftM2
18:35:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:35:17 <sshc> aavogt: How do I write them directly, and which extension?
18:35:23 <aavogt> but really, you can just put the same signature (plus some []) on foo
18:35:24 <JoeyA> ScopedTypeVariables , if I recall correctly.
18:35:33 <JoeyA> (x:xs) :: [Int] <- foo
18:36:06 <aavogt> that's no different that   x:xs <- foo :: [[Int]]
18:36:10 <aavogt> *than
18:36:33 <eugenn> @src const
18:36:34 <lambdabot> const x _ = x
18:36:37 <sshc> That worked.  THanks!
18:37:04 <aavogt> you can also force the type sometimes by putting on the line below:
18:37:56 <eugenn> @src (.)
18:37:57 <lambdabot> (f . g) x = f (g x)
18:37:57 <lambdabot> NB: In lambdabot,  (.) = fmap
18:38:09 <aavogt>  return () `const` (x :: blah)
18:38:16 <SuperMario> i want to write the next halo
18:38:17 <SuperMario> in haskell
18:38:52 <SuperMario> hey is this a valid program? g=g=g=g
18:39:02 <kpreid> No.
18:39:08 <monochrom> No.
18:39:18 <kpreid> g = let g=g in g is, though
18:39:33 <kpreid> So is g=g==g===g.
18:39:37 <mauke> > let g@g = 42 in 2
18:39:39 <lambdabot>   Conflicting definitions for `g'
18:39:39 <lambdabot>  In the binding group for: g, g
18:39:49 <mauke> THAT'S NOT HOW CONFLICTS WORK
18:39:49 <djahandarie> Can you override (=) ?
18:39:57 <monochrom> No.
18:40:05 <djahandarie> > let (=) = (+) in 5=5
18:40:06 <lambdabot>   <no location info>: parse error on input `='
18:40:06 <fxr> 03:30 <aristid> gwern: which is just what c++ does.
18:40:07 <fxr> 03:30 <dolio> C++ has types parameterized by static values.
18:40:07 <fxr> 03:30 *** Pseudonym (~ajb@bromage.elder-gods.net) has joined channel #haskell
18:40:07 <fxr> 03:30 <monochrom> use GÃ¶del numbering to obtain full dependent predicate
18:40:10 <fxr>                   subtype
18:40:12 <djahandarie> :-(
18:40:14 <fxr> 03:30 <kmc> it might be fairer to say that C++ has metaprograms which input
18:40:16 <JoeyA> > let g = let g = g in g in g
18:40:17 <fxr>             values and output types
18:40:19 --- mode: ChanServ set +o mauke
18:40:19 --- kick: fxr was kicked by mauke (fxr)
18:40:19 <lambdabot>   mueval-core: Time limit exceeded
18:40:59 <kmc> wtf was that
18:41:09 <mauke> mispaste, I hope
18:41:13 <eugenn> > let g=1 in g+1
18:41:15 <lambdabot>   2
18:41:27 <fxr> sorry
18:41:35 <JoeyA> I ran an infinitely recursive program at the same time fxr pasted a bunch.
18:42:03 <fxr> I don't understand how it happened
18:42:09 <fxr> sorry again
18:42:19 --- mode: mauke set -o mauke
18:42:30 <kmc> > let g = g in g
18:42:33 <lambdabot>   mueval-core: Time limit exceeded
18:42:38 <Jafet> > g
18:42:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:42:39 <lambdabot>    `SimpleReflect.FromExpr ...
18:42:39 <kmc> > fix id
18:42:41 <eugenn> @quote a
18:42:41 <lambdabot> <aristid> says: i only read bold text ;)
18:42:43 <lambdabot>   mueval-core: Time limit exceeded
18:42:44 <JoeyA> Maybe you middle-mouse-clicked
18:43:06 <eugenn> @quote prime
18:43:06 <lambdabot> dons says: -fglasgow-exts ~= -fhaskell-prime
18:43:13 <jkingkong> Haskell, I was wondering how you can expose things in a package that were not explicitely exported
18:43:23 <jkingkong> for example, I want to reimplement a data.map function
18:43:34 <jkingkong> but Data.Map doesn't export (Bin and Tip)
18:43:44 <jkingkong> well, the top level data constructor i guess
18:43:53 <jkingkong> Is there a way of accessing this?
18:43:53 <eugenn> @quote good
18:43:54 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
18:43:58 <aavogt> you can't jkingkong
18:44:08 <gwern> jkingkong: if you could, it'd kind of defeat the purpose
18:44:13 <jkingkong> aavogt: hmm good to know I guess
18:44:15 <jkingkong> well
18:44:24 <jkingkong> i know it's supposed to make it difficult
18:44:36 <jkingkong> but some languages have a way of exposing it if you put in more effort
18:44:40 <jkingkong> so normal users won't see it
18:45:00 <jkingkong> i might just end up modifying the source/version numbers myself
18:45:04 <Jafet> You aren't programming in one of those languages, thankfully
18:45:12 <jkingkong> haha no i suppose not
18:45:12 <eugenn> @lambdabot hi
18:45:12 <lambdabot> Unknown command, try @list
18:45:32 <gwern> imagine a language where you could monkey patch everything
18:45:35 <eugenn> @list
18:45:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:45:45 <gwern> it'd be like having a nuclear-powered chainsaw
18:45:52 <jkingkong> still though
18:45:57 <jkingkong> Data.Map is missing some key stuff
18:46:08 <Mathnerd314> eugenn: /msg lambdabot @
18:46:10 <jkingkong> it has the function I want most of the time
18:46:10 <aavogt> perhaps those things cannot be implemented?
18:46:15 <Jafet> Hey, I do want a nuclear powered chainsaw
18:46:16 <blackdog> gwern: why imagine? i work in one every day...
18:46:19 <jkingkong> no what I'm thinking of should be easy
18:46:30 <jkingkong> and should be in the package imo, if only I knew who to tell
18:46:38 <blackdog> jkingkong: maybe it is. what are you looking to add?
18:46:39 <kmc> i think Haskell should allow this sort of monkey patching
18:46:41 <aavogt> you can talk about it here?
18:46:44 <jkingkong> there's no easy way of mapping the keys and values all at once
18:46:47 <kmc> at least overriding export lists, which is not quite true monkey patching
18:46:49 <jkingkong> there is a map keys function
18:46:52 <jkingkong> for example
18:46:54 <kmc> we provide hacks to get around most of the other guidelines
18:46:57 <jkingkong> that transforms all the keys
18:47:09 <jkingkong> there's no reason why you can't update the values at the same time
18:47:23 <kmc> referential transparency, type system, automatic memory management can all be subverted
18:47:27 <mauke> fromList . map f . toList
18:47:33 <jkingkong> expecially for a function like mapKeysMonotonic, clearly geared to performance users
18:47:40 <jkingkong> mauke: well yea I know how to do that
18:47:41 <blackdog> jkingkong: foldWithKey?
18:48:02 <jkingkong> blackdog: that's what I've been doing
18:48:07 <jkingkong> but there's a lack of elegance to it
18:48:09 <aavogt> jkingkong: you know that fromList is linear time if your keys are sorted?
18:48:16 <jkingkong> because why should i use a fold if I want a map
18:48:30 <jkingkong> yes
18:48:32 <blackdog> because fold is a generalisation of map?
18:48:57 <aavogt> at least it claims to do so (since fromAscList = fromList, and I trust the comment about the asymptotics there)
18:48:59 <blackdog> is your objection based on performance?
18:49:13 <jkingkong> does foldwithkey take advantage of the fact that the key transformation is linear? I'm pretty sure it doesn't
18:49:23 <jkingkong> yes performance, I'm trying to write an HPC thingy
18:49:34 <jkingkong> (pardon completely imprecise terminology)
18:49:47 <jkingkong> foldWithKey requires you to update a map as an accumulator
18:49:55 <jkingkong> and each insertion requires time
18:49:58 <Mathnerd314> > let l3t = l3t in let in 13t -- is there something more obfuscated than l3t?
18:49:59 <lambdabot>   13
18:50:06 <ReinH> ok, how can I split a list into groups of n? for instance, the generalization of f (x:y:z:xs) = [x:y:z] : f xs
18:50:12 <jkingkong> mapKeysMonotonic preserves the original structure of the tree
18:50:27 <jkingkong> and hence is O(n) to update the keys
18:50:40 <jkingkong> tacking on a value transformation should be free
18:50:49 <blackdog> ah, you're trying to avoid the extra nlogn step
18:50:57 <aavogt> jkingkong: you have timings to show this is a problem?
18:50:58 <jkingkong> yea precisely
18:51:09 <sshc> Why does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26412#a26412 cause a "Occurs check: cannot construct the infinite type: b = [b]" error for the "61 combinations 0 _  = [[]]" line?
18:51:15 <jkingkong> yea i'm doing several million computations
18:51:17 <aavogt> mauke's suggestion is linear time if your function is monotone in keys
18:51:24 <jkingkong> the profiling shows this is a problem
18:51:29 <jkingkong> and the heap profile is just as bad
18:51:34 <aavogt> who knows about constant factors
18:51:37 <jkingkong> foldlwithkey takes up too much stack space
18:51:52 <jkingkong> so i've reverted to map . mapKeysMonotonic
18:52:25 <eugenn> @src split
18:52:25 <lambdabot> Source not found. I feel much better now.
18:52:30 <kmc> > let lÐµt = lÐµt in lÐµt
18:52:33 <lambdabot>   mueval-core: Time limit exceeded
18:53:09 <aavogt> > map head $ takeWhile (not . null) $ iterate (drop 3) "1234567890"
18:53:10 <lambdabot>   "1470"
18:53:27 <djahandarie> > let = let in let
18:53:28 <lambdabot>   <no location info>: parse error on input `='
18:53:37 <djahandarie> lol fail
18:53:42 <djahandarie> > let let = let in let
18:53:43 <lambdabot>   <no location info>: parse error on input `='
18:53:51 <djahandarie> ftw
18:53:53 <ReinH> ah, I can use take size : drop size
18:53:53 <aavogt> > concatMap (take 3) $ takeWhile (not . null) $ iterate (drop 3) "1234567890"
18:53:53 <gwern> silly kmc. thinking you can subvert mueval
18:53:54 <lambdabot>   "1234567890"
18:53:55 <djahandarie> > let let = let in let
18:53:56 <lambdabot>   <no location info>: parse error on input `='
18:54:00 <aavogt> > map (take 3) $ takeWhile (not . null) $ iterate (drop 3) "1234567890"
18:54:01 <lambdabot>   ["123","456","789","0"]
18:54:03 <gwern> I would eat my chapeau if you can break mueval!
18:54:16 <kmc> gwern, it did what i expected
18:54:20 <blackdog> toAscList is linear, and fromAscList is linear, though. isn't that enough?
18:54:30 <eugenn> @src not
18:54:31 <lambdabot> not True   =  False
18:54:31 <lambdabot> not False  =  True
18:54:33 <blackdog> gah, sorry, i'm about a page behind :)
18:54:48 <Jafet> Linear in the logarithm
18:54:49 <kmc> @src (||)
18:54:49 <lambdabot> True  || _ =  True
18:54:49 <lambdabot> False || x =  x
18:54:55 <aavogt> blackdog: so is the map and mapKeysMonotonic
18:55:13 <djahandarie> > let ã‚Œã¦ = ã‚Œã¦ in ã‚Œã¦
18:55:17 <lambdabot>   mueval-core: Time limit exceeded
18:55:45 <gwern> yes, we even got unicode working
18:55:47 <gwern> that was hard
18:56:00 <gwern> I don't look forward to fixing it for 6.12
18:56:14 <aavogt> it's broken?
18:56:33 <eugenn> @src (+)
18:56:33 <lambdabot> Source not found. I am sorry.
18:56:52 <gwern> aavogt: well, it'll probably be broken
18:57:13 <gwern> I doubt the 6.12 unicode stuff plays well with the manual unicode handling
18:57:29 <Saizan_> well, that depends on utf8-string iirc
18:57:29 <aavogt> I see
18:57:40 <eugenn> @src ($)
18:57:41 <lambdabot> f $ x = f x
18:57:47 <Saizan_> maybe it'll just work if that got "fixed"
18:58:18 <eugenn> > :t (+)
18:58:19 <lambdabot>   <no location info>: parse error on input `:'
18:58:24 <gwern> I used to be optimistic like that
18:58:33 <gwern> it was nice
18:59:23 <eugenn> @src repeat
18:59:23 <lambdabot> repeat x = xs where xs = x : xs
19:00:07 <eugenn> > repeat 2
19:00:08 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
19:00:56 <eugenn> > repeat "repeat"
19:00:57 <lambdabot>   ["repeat","repeat","repeat","repeat","repeat","repeat","repeat","repeat","r...
19:01:15 <SuperMario> xs = x => { (s,0) : s in R } U { ((1,x) x in R\{0} }
19:01:34 <eugenn> > take 2 $ repeat "waka"
19:01:36 <lambdabot>   ["waka","waka"]
19:01:46 <gwern> > repeat "waka laka! "
19:01:47 <lambdabot>   ["waka laka! ","waka laka! ","waka laka! ","waka laka! ","waka laka! ","wak...
19:02:30 <eugenn> @src cycle
19:02:30 <lambdabot> cycle [] = undefined
19:02:31 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
19:03:31 <eugenn> @src plane
19:03:31 <lambdabot> Source not found. Are you on drugs?
19:03:52 <sshc> Why does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26412#a26412 cause a "Occurs check: cannot construct the infinite type: b = [b]" error for the "61 combinations 0 _  = [[]]" line?
19:04:08 <eugenn> > "waka" ++ "kawa"
19:04:10 <lambdabot>   "wakakawa"
19:04:14 <kmc> :t [[]]
19:04:15 <lambdabot> forall a. [[a]]
19:04:42 <kmc> hmm
19:04:49 <eugenn> > cycle "hoo"
19:04:50 <lambdabot>   "hoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohoohooho...
19:04:57 <kmc> the error is not really on that line
19:05:00 <kmc> it's with the function as a whole
19:05:07 <kmc> that being the first line of the function
19:05:33 <kmc> you probably mean return (y:zs) ?
19:05:34 <aavogt> you may be missing some parentheses on 65
19:06:20 <kmc> alternately
19:06:21 <kmc> combinations n xs = [y:zs | (y:ys) <- tails xs, zs <- combinations (pred n) ys]
19:06:46 <sshc> kmc: Aha, return (y:zs)!  Thanks!
19:07:33 <SuperMario> does haskell have built in library of number theoretic functions like Sieveoferathothenes(n)
19:07:38 <eugenn> > let combinations n xs = [y:zs | (y:ys) <- tails xs, zs <- combinations (pred n) ys] in combinations 3 [1,2,3,4,5]
19:07:39 <lambdabot>   []
19:07:47 <kmc> SuperMario, not built in, but see hackage
19:09:34 <SuperMario> i dont like downloading packages 
19:09:37 <SuperMario> feels lime im cheating
19:09:40 <eugenn> :t take 2 $ drop 2
19:09:42 <lambdabot>     Couldn't match expected type `[a]'
19:09:42 <lambdabot>            against inferred type `[a1] -> [a1]'
19:09:42 <lambdabot>     In the second argument of `($)', namely `drop 2'
19:10:02 <aavogt> use .
19:10:18 <monochrom> i dont like downloading ghc
19:10:22 <eugenn> :t take 2 . drop 2
19:10:23 <lambdabot> forall a. [a] -> [a]
19:10:24 <monochrom> feels lime cheating
19:10:34 <SuperMario> why nonochrom whats wrong with it
19:10:40 <monochrom> i ought to write my own compiler
19:10:57 <SuperMario> why not build your own computer
19:10:58 <monochrom> oh, i shouldn't download ubuntu either. ought to write my own os.
19:10:59 <kmc> yes monochrom
19:11:17 <monochrom> Precisely my point, my dear SuperMario.
19:11:21 <aavogt> what are you doing using english?
19:11:27 <aavogt> you gotta invent your own language
19:11:45 <monochrom> So what's wrong with downloading packages again?
19:11:50 <eugenn> you gotta invent your own air to breath
19:12:22 <monochrom> Or are you just a chat bot?
19:12:34 <SuperMario> im not a bot
19:12:37 <SuperMario> or am I
19:12:43 <SuperMario> perhaps I was written in Haskell
19:13:03 <eugenn> @quote higher-order
19:13:04 <lambdabot> JonHarrop says: Interesting statements given Haskell's lack of higher-order modules and comparatively poor type inference.
19:13:19 <Veinor> Higher-order modules?
19:13:24 <kmc> SuperMario, sounds like something bots would say
19:13:36 <kmc> Veinor, yeah.  i presume he means parametrized modules
19:13:39 <kmc> like ML functors
19:13:41 <Jafet> Call Deckard.
19:13:42 <aavogt> Veinor: parameterize modules by types (and maybe other modules I think)
19:14:04 <eugenn> @quote stupid
19:14:04 <lambdabot> pyschobot says:   pig-latin FunctorSalad: shut up educated stupid it's entailed by a team of visionary leaders
19:14:06 <kmc> Haskell's module system is quite primitive
19:14:10 <kmc> i think it's good for what it aspires to be
19:14:12 <aavogt> typeclasses sort of fill the gap
19:14:17 <kmc> sort of
19:14:35 <kmc> type classes subsume one of the major use cases of parametrized modules in ML
19:14:41 <Veinor> I like educated stupid
19:14:42 <kmc> they're not a general substitute in any way i'm aware of
19:14:45 <kmc> hehe Veinor
19:14:45 <FunctorSalad_> I don't think I ever said that
19:14:57 <Veinor> I want to write an anti-imperative timecube parody
19:15:01 <eugenn> @quote amazing
19:15:01 <lambdabot> matthew-_ says: wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
19:15:10 <Veinor> @quote monads
19:15:11 <lambdabot> Cale says: [more monad clarity] monads as food gathering in post-industrial America
19:15:15 <Veinor> haha
19:15:21 <kmc> haha
19:15:36 <FunctorSalad_> what?
19:15:43 <aavogt> so psychobot is more sensible than cale?
19:16:08 <monochrom> hahaha
19:16:35 * hackagebot cuda 0.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.2 (TrevorMcDonell)
19:16:44 <eugenn> @quote polymorphism
19:16:45 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
19:18:09 <eugenn> @quote world
19:18:10 <lambdabot> dylan says: everything's a hack. the world's a hack.
19:19:23 <Veinor> @quote python
19:19:24 <lambdabot> python says: is a mediocre language invented by a mediocre person
19:19:29 <Veinor> ouch.
19:19:46 <kmc> damn
19:19:50 <kmc> ice burn
19:19:58 * kmc likes Python
19:20:27 <monochrom> @quote It
19:20:27 <lambdabot> newsham says: so the key to immortality is ambiguous naming?
19:20:54 <kmc> @. elite quote spj
19:20:54 <lambdabot> zpJ 54YS: iT |o0xz |ik3 |-|0psCOtcH! (Reph3rring 7O A phUnNy N0t47iOn f0R lis75)
19:21:01 <kmc> @. elite ghc
19:21:01 <lambdabot> 9hC $Ay$: on1Y unIT Nu/\/\eRiC 7yp3 P4t7ern iz0rz \/AliD
19:21:09 <kmc> @. elite ghc
19:21:09 <lambdabot> 9|-|c s4Y$: kINd 3Rr0R
19:21:33 <Jafet> They should replace the error message with that!
19:22:21 <eugenn> @quote firefox
19:22:22 <lambdabot> Gracenotes says: Firefox, for all its other faults, never fails to respond to a SIGTERM. firefox++
19:22:25 <kmc> like nmap -oS
19:22:38 * Veinor likes python too. It's his 'quick script' language of choice for anything that isn't text munching
19:22:53 * Veinor uses perl for that.
19:23:28 <Jafet> I hear perl 6 will entirely subsume python
19:24:36 <gwern> everytime I see mention of Rakudo, I have to restrain myself from making a _Lucky Star_ joke
19:24:38 <kmc> Perl Nukem Forever?
19:24:40 <gwern> even though I know that they are different Rakudos in Japanese
19:24:55 <gwern> now now. perl 6 has been good to haskell
19:24:59 <kmc> that's right
19:25:11 <Jafet> @remember kmc Perl Nukem Forever
19:25:11 <lambdabot> It is forever etched in my memory.
19:25:17 <kmc> err context
19:25:21 <kmc> @forget kmc Perl Nukem Forever
19:25:21 <lambdabot> Done.
19:25:27 <kmc> @remember kmc [on Perl 6] Perl Nukem Forever
19:25:27 <lambdabot> Nice!
19:25:39 <Jafet> Blah, we all know the context.
19:25:42 <kmc> bah
19:25:44 <kmc> change it back if you care
19:25:46 <kmc> i won't stop you
19:25:52 <Jafet> Or do you actually think perl 6 will ever be released
19:26:01 <gwern> I mean, quite aside from a competitor stabbing itself. repeatedly. for more than half a decade. we got good PR from pugs
19:26:02 <dobblego> is lambdabot installable at all?
19:26:16 <kmc> http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
19:26:45 <kmc> afaik these are all magical built-ins
19:27:11 <gwern> dobblego: of course
19:27:18 <gwern> matter of fact, I installed it earlier today
19:27:31 <dobblego> gwern, on what platform?
19:27:38 <gwern> x86
19:28:01 <aavogt> I've done it on x86_64 relatively recently
19:28:22 <dobblego> I am on x86_64
19:28:24 <dobblego> http://paste.pocoo.org/show/227835/
19:28:24 <gwern> let's see, seems I'm on i686
19:28:39 <dobblego> how can that issue be resolved?
19:28:40 <gwern> dobblego: that from darcs?
19:28:52 <dobblego> it's from "cabal install lambdabot"
19:29:05 <dobblego> the unix package is from cabal too
19:29:12 <gwern> oh. well, that's probably why
19:29:16 <aavogt> one of the issues with \bot is that there's no way to quickly get all the packages it makes available by default
19:29:16 <gwern> try darcs
19:29:32 <aavogt> so you need to chase down arrow transformers etc.
19:29:41 <aavogt> or comment out those imports in L.hs
19:29:49 <dobblego> gwern, will that resolve the issue related to the GHC package?
19:29:59 <gwern> probably
19:33:26 <dobblego> where does module `Distribution.Simple' come from?
19:34:04 <gwern> cabal
19:34:27 <monochrom> cabal, the lib. (does not need cabal-install)
19:34:32 <dobblego> strike me unlucky
19:34:48 <aavogt> it tends to come with ghc I think
19:35:24 <monochrom> comes with ghc since last time I saw you
19:35:35 <dobblego> runhaskell Setup.hs configure # says Distribution.Simple is not around
19:35:40 * hackagebot ghc-mod 0.4.2 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.4.2 (KazuYamamoto)
19:35:56 <monochrom> perhaps your runhaskell points to runhugs
19:36:35 <dobblego> GHC 6.12.1
19:37:15 <monochrom> cannot reproduce your problem
19:38:16 <dobblego> http://paste.pocoo.org/show/227839/
19:39:18 <gwern> package Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a is unusable due to missing or recursive dependencies: directory-1.0.1.0-d465e84539827bbaf52354a7a78d750c process-1.0.1.2-d10eb9528cbd95f3032e472adaaecc29
19:39:25 <gwern> well gee that looks like a problem
19:40:09 <Veinor> haha, what
19:40:17 <monochrom> someone destroyed your package database.
19:40:33 <gwern> also, interesting names. nixos?
19:40:40 <Saizan_> dobblego: see "ghc-pkg check"
19:41:04 <dobblego> this is ubuntu 64-bit
19:41:13 <dobblego> Saizan_, I get no outpu
19:41:33 <Saizan_> dobblego: ah, right ghc-pkg doesn't always catch this issue
19:41:53 <dobblego> earlier I did ghc-pkg hide unix
19:41:58 <Saizan_> dobblego: anyway, check "ghc-pkg list" do you have two installations of the same version of some package?
19:42:17 <dobblego> Saizan_, yes haskell-src-exts
19:43:14 <Saizan_> dobblego: mh if it what i think it should also be some package Cabal depends on (even indirectly) however you should unregister one of the two installations
19:43:28 <Saizan_> http://www.haskell.org/cabal/FAQ.html#dependencies-conflict <- the problem i'm referring to is better explained here
19:43:41 <dobblego> Saizan_, I cabal installed one of those
19:44:12 <dobblego> unregistering one of those does not resolve the Distribution.Simple issue
19:44:25 <Saizan_> dobblego: can you paste ghc-pkg list?
19:44:44 <dobblego> http://paste.pocoo.org/show/227840/
19:46:01 <Saizan_> you've process-1.0.1.2 installed both in the global and the user db, unregister the user one
19:46:10 <Saizan_> then it should work.
19:46:32 <monochrom> also directory-1.0.1.0
19:46:35 <dobblego> how is that done exactly when it has the same name?
19:46:36 <Saizan_> and haskell98-1.0.1.1 too
19:46:45 <gwern> dobblego: --user?
19:46:49 <monochrom> ghc-pkg unregister --user process-1.0.1.1  etc
19:47:10 <dobblego> I need --force
19:47:40 <monochrom> "To avoid this problem in the future, avoid upgrading core packages." --- from that page.  "core packages" means those that come with ghc.
19:47:58 <interferon> i still find myself baffled by package errors.  what do i do here?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26414#a26414
19:48:04 <Saizan_> same thing for mtl, though it won't affect Setup.hs i think
19:48:06 <interferon> are they explicitly requiring two different versions of the same package?  if so, how on earth can i resolve that>
19:48:29 <monochrom> However, if I had the say, I would make it: "To avoid this problem in the future, avoid being promiscuous in installing packages"
19:48:55 <dobblego> heh, well that got passed that one
19:49:06 <dobblego> Setup.hs: Missing dependency on a foreign library: * Missing header file: HsUnix.h 
19:49:28 <Saizan_> interferon: "requires" there really means "it has been built with"
19:49:55 <interferon> so do i need to reinstall a package?
19:50:40 <Saizan_> what command are you running, specifically? cabal configure?
19:50:47 <interferon> yes
19:51:01 <monochrom> I feel like I'm listening to patients in a STD clinic.
19:51:49 <Saizan_> interferon: well, you could try "cabal build" and then "cabal install --only", maybe you're lucky :)
19:52:02 <interferon> :)
19:52:20 <interferon> when i build i get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26415#a26415
19:52:31 <interferon> do i need to hide .3?
19:52:46 <Saizan_> otherwise you could "cabal install --dry-run -v" to see which packages it'd end up reinstalling, though that's not entirely safe as dobblego's problem shows :)
19:53:18 <Saizan_> ah, you already have dobblego's problem :)
19:53:25 <dobblego> do you happen to know which package HsUnix.h comes from?
19:53:28 <interferon> :)
19:53:50 <monochrom> unix
19:53:52 <gwern> /home/gwern/bin/ghc/libraries/unix/include/HsUnix.h
19:53:59 <Saizan_> interferon: so, you should "ghc-pkg unregister --user haskell98-1.0.1.1"
19:54:24 <dobblego> but I am trying to install unix
19:54:36 <interferon> it says it will break lots of other packages unless i force it.  should i?
19:55:00 <gwern> this channel is painful to watch soemtimes
19:55:06 <monochrom> ghc-pkg unregister --user unix-2.4.0.1
19:55:06 <Saizan_> interferon: yeah, that's the only option atm
19:55:21 <dobblego> monochrom, been there done that
19:55:33 <dobblego> there is another unix though
19:56:03 <monochrom> I should just bow out of this tarpit.
19:56:16 <dobblego> thanks for trying
19:56:33 <gwern> monochrom: I say tell them both to just nuke their haskell installation and start over, older sadder and wiser
19:56:47 <dobblego> I have installed xmonad
19:56:48 <monochrom> Yes.
19:57:03 <dobblego> by haskell installation you mean ~/.ghc6 ?
19:57:07 <interferon> ha!
19:57:08 <interferon> i got it
19:57:25 <interferon> thanks, Saizan_ !
19:57:30 <Saizan_> np :)
19:57:59 <Saizan_> dobblego: which version of unix is giving you taht error?
19:58:13 <monochrom> This totally belongs to a STD clinic. Including the part about "so I tried to have more sex hoping to rub away the germs"
19:58:14 <interferon> i had to unregister haskell98 and then reinstall it
19:58:17 <dobblego> Saizan_, the one in darcs when I try to configure
19:59:00 <Saizan_> interferon: hopefully a different version?
19:59:28 <interferon> no, actually.  haskell98-1.0.1.1
19:59:52 <gwern> monochrom: or, I tried to pick up another STD in the hope it'd negate all the others
20:00:12 <dobblego> Saizan_, I am going to start again
20:00:57 <Saizan_> gwern, monochrom: go hack GHC and Cabal until they can tell one installation of a package from another, thanks :)
20:01:51 <interferon> yeah really guys.
20:02:48 <monochrom> But it wouldn't stop bleeding edge people from blindly wanting the latest versions just for increasing the 4th digit by 1.
20:05:02 <Saizan_> dobblego: you need to run "autoreconf"
20:05:03 <dobblego> I am trying again on a fresh linux 32-bit machine
20:05:43 <Saizan_> otherwise you'll miss include/HsUnixConfig.h.in
20:06:02 <monochrom> I mean, what does it take to get to the state of having two instances of "blahblah-2.0.1.0"?
20:06:31 <dobblego> following the instructions of course
20:06:42 <aavogt> the wrong instructions perhaps
20:06:45 <Saizan_> monochrom: it can be as simple as having two conflicting packages and cabal-install deciding to rebuild some dependency to solve the conflict
20:07:00 <monochrom> If you just say "cabal install blahblah", cabal will just say "No packages to be installed. All the requested packages are already installed" and do nothing. I have just tried it.
20:07:27 <monochrom> Someone seriously said "--reinstall" to make it happen.
20:07:40 <Saizan_> no, --reinstall is not needed
20:08:02 <Saizan_> you need to have upgraded at least one "core" package though, i think
20:09:10 <interferon> i didn't intentionally do this
20:09:19 <interferon> i'm not going around upgrading for the sake of upgrading
20:10:31 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26416#a26416 is the (++) preventing tail recursion?
20:10:52 <interferon> om-foxy: shouldn't be
20:11:14 <dons> om-foxy: go kiwis
20:11:17 <om-foxy> hm...  I'm getting stack errors with this function
20:11:22 <om-foxy> dons:  Yar!
20:11:33 <Saizan_> om-foxy: doing zipWith tail-recursively is the worst thing you could do in a lazy language :)
20:11:37 <om-foxy> dons: and the ball wasn't even the right shape :)
20:11:41 <dons> hehe
20:11:53 <dolio> Stacks aren't used for what you think they're used for in Haskell.
20:12:22 <om-foxy> well, the way I see it, I'm getting lots of unevaluated thunks and I need to strictify my zipWith?
20:12:33 <Saizan_> om-foxy: zipWith is a function that can produce it's output incrementally, one cons cell for every one consumed, you should take advantage of that
20:12:53 <monochrom> (((zs ++ [g x y]) ++ [g x y]) ++ [g x y]) ++ [g x y]  etc. is going to cost you trouble.
20:12:55 <Saizan_> and then you won't consume any stack at all
20:13:16 <monochrom> or cause you trouble
20:14:13 <monochrom> don't use tail recursion
20:14:22 <monochrom> @src map
20:14:23 <lambdabot> map _ []     = []
20:14:23 <lambdabot> map f (x:xs) = f x : map f xs
20:14:32 <monochrom> does not use tail recursion
20:15:29 <SuperMario> can u write a function to differentiate multivariable functions in haskell
20:15:34 <monochrom> the accumulator technique does not make sense for lazy lists
20:15:38 <kmc> yes.  GHC code's stack is a stack of pattern-matches and forcings, not of applications
20:15:46 <kmc> SuperMario, yes
20:15:50 <SuperMario> ya rite
20:16:05 <om-foxy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26416#a26417 Here's more code.   The data file is groups of records of sequences that need to be reassembled a1 {- = a1,0 a1,1 a1,2 -}b1 c1 d1 a2 b2 c2 d2 a3 b3 c3 d3 -> [a,b,c,d]
20:16:11 <kmc> SuperMario, most programming languages are capable of roughly the same things
20:16:18 <SuperMario> do it then
20:16:20 <SuperMario> ill watch
20:16:23 <kmc> ok
20:16:26 <kmc> i think i won't
20:16:31 <Rotaerk_> lol
20:16:33 <kmc> but you can ask edwardk about it
20:16:42 <SuperMario> why is he a wizard or something
20:16:45 <kmc> he's been working on a badass automatic differentiation library
20:16:58 <kmc> here it is http://hackage.haskell.org/package/ad
20:17:03 <Rotaerk_> "can you write an MMO that beats WoW in Haskell?" "sure" "PROVE IT"
20:17:19 <SuperMario> kmc: looks boring 
20:17:24 <kmc> SuperMario, what's your problem
20:17:25 <interferon> oh brother
20:17:29 <interferon> can we /kick?
20:17:36 <kmc> not yet
20:17:46 <Saizan_> om-foxy: so, why don't you use the zipWith from Data.List ?
20:17:58 <om-foxy> Saizan_: stack overflow
20:18:16 <kmc> SuperMario, you may have heard that the only way to get answers on IRC is to insult the thing you want answers about
20:18:17 <Saizan_> om-foxy: Data.List.zipWith is not the cause of that
20:18:22 <kmc> and its developers will come to its defense
20:18:26 <kmc> that is true in a lot of channels
20:18:30 <SuperMario> lol
20:18:37 <interferon> kmc: :)
20:18:38 <gwern> Rotaerk_: the right response is to assume that the MMO exists, and then prove a compilation from the language it is written in to haskell
20:19:09 <Rotaerk_> nonsense, no existing MMO beats WoW !
20:19:13 <Rotaerk_> *cough*
20:19:34 <kmc> IRC is a pretty fun MMO
20:19:38 <Rotaerk> in terms of subscribers and profits anyway
20:19:47 <om-foxy> Saizan_: that's the only place in the program that could cause a stack overflow, I believe
20:20:02 <ddarius> Last I checked "MMO" was an adjective.
20:20:18 <gwern> Rotaerk: so WOW can't beat itself?
20:20:21 <Rotaerk> ddarius, it's also short for the already short "MMORPG"
20:20:30 <Rotaerk> which is a genre
20:20:34 <kmc> or just MMOG
20:21:00 <Saizan_> om-foxy: the overflow might come from readData, but Data.List.zipWith works in constant stack so that's not the problem
20:21:08 <Rotaerk> gwern, maybe? that'd be a bit creepy though
20:21:45 <gwern> Rotaerk: if it can beat itself, then the proof goes through
20:21:49 <om-foxy> Saizan_: [Double] gets converted into a (Vector Double) incrementally and then two Vector Doubles joined with each pass.  OK about zipWith.
20:21:58 <gwern> in fact, it even becomes an intuitionistic constructive proof since WOW exists
20:22:14 <Rotaerk> lol
20:23:30 <Saizan_> om-foxy: how large is "s" going to be in readRecord?
20:24:39 <om-foxy> Saizan_: maybe around 2048 Doubles which gets turned into a Data.Packed.Vector Double in the next line
20:26:22 <SuperMario> can anyone recommend a good tutorial for someone who wants to type the haskell into notepad 
20:26:38 <kmc> a tutorial on Haskell?
20:26:43 <kmc> or a tutorial on using Notepad?
20:26:50 <SuperMario> yea but most of them dont work on notepad when i type it in
20:26:55 <absentia> xn/me grosk teh haskell.
20:26:55 <SuperMario> like that guy said earlier i had to type main = 
20:27:01 * absentia grosk teh haskell.
20:27:06 <kmc> that's because it's important to learn Haskell from the interactive prompt
20:27:15 * absentia sucks.  dammit. "groks" ...   argh.
20:27:19 <SuperMario> is that how you usually program?
20:27:20 <kmc> most tutorials don't get to writing a complete compiling program until later
20:27:28 <kmc> it's how we try out ideas, explore, test, and debug
20:27:36 <SuperMario> yea but i want to write a program
20:27:38 <kmc> and it's much easier as a way to learn the language
20:27:39 <Saizan_> om-foxy: i've asked because replicateM is something that could benefit from a tail-recursive version, though don't use "++[x]" since (xs ++ ys) is O(length xs), use a reverse at the end instead
20:27:51 <kmc> SuperMario, Haskell is not instant-gratification.  you won't get to do what you want immediately
20:28:01 <Saizan_> om-foxy: not sure if that's where the overflow is coming
20:28:24 <SuperMario> i want to multiply matricies
20:28:30 <kmc> that's fantastic
20:28:44 <om-foxy> Saizan_: ok, thanks.  I suspected zipWith because it's lazy, and so pieces of lists will be floating around
20:28:48 <kmc> that's a good exercise
20:28:51 <kmc> but not a good first exercise
20:29:05 <kmc> and why do you want a standalone program to multiply matrices
20:29:15 <kmc> wouldn't it be easier to use as an interactive prompt?
20:29:21 <kmc> like matlab, mathematica, etc.
20:29:30 <SuperMario> well i was trying to make a library for computational number theory and the version of the extended euclidean algorithm i want uses matricies
20:29:39 <ddarius> om-foxy: How big is the Int argument "n" to readData?
20:29:40 <SuperMario> python sucks 
20:29:46 <kmc> ok
20:29:56 <kmc> what does that have to do with anything
20:30:09 <SuperMario> cause i need a language that multiplies matricies realy easily
20:30:25 <kmc> you want to write a computational number theory library as your first haskell code of any kind?
20:30:28 <Saizan_> om-foxy: pieces of things floating around would cause an Heap Overflow :)
20:30:36 <SuperMario> like it'd be cool if i could just go Matrix=M[n] for n =1 to 100 MultiplyM[n] or something 
20:30:45 <SuperMario> kmc: yea 
20:30:47 <kmc> ok
20:30:53 <kmc> well, it doesn't work that way
20:30:59 <kmc> you can ignore this advice if you want
20:31:06 <kmc> you will probably get frustrated
20:31:07 <om-foxy> ddarius:  n == 60, s == 2048
20:31:13 <om-foxy> Saizan_: ah
20:31:14 <kmc> and people will not answer your questions if it's clear you're in too deep
20:31:15 <SuperMario> do you know a language that does work that way?
20:31:21 <kmc> matlab or mathematica
20:31:28 <SuperMario> i dont like those
20:31:30 <SuperMario> feels like cheating
20:31:32 <kmc> also python with numpy, maybe you weren't using it right
20:31:37 <kmc> well great
20:31:51 <kmc> you want it to be easy but not too easy
20:31:56 <SuperMario> yea
20:32:06 <kmc> i'm not interested in helping you; have fun
20:33:13 <ddarius> om-foxy: It seems unlikely that you would get a stack overflow on input that small with the code you've presented.  However, there are definitely issues in this code.  For example, readData is blatantly not tail recursive.
20:34:13 <om-foxy> ddarius: ok, what do I need to do?  Because this is where the error starts
20:34:52 <om-foxy> ddarius, use an accumulator version?
20:36:50 <ddarius> om-foxy: If n will never be large, I just wouldn't bother.  But if I were going to fix it, then yes, you'd use something akin to a standard accumulator transform.
20:37:47 <om-foxy> ddarius: my test file has n == 60, but real data files will have huge n's.  The problem is that I get stack errors already on a small test file.
20:39:29 <ddarius> om-foxy: Yes, and I don't think the thing that is giving you problems is in the code you presented.  However, as I said earlier, there are problems in that code that will give you problems on large input.  If n will be large, then you will definitely need to rewrite readData.
20:43:09 <SuperMario> http://learnyouahaskell.com/ lol look at the elephant and the pretty colors....this should teach me how to do what i want
20:44:42 <kmc> BONUS, another satisfied customer ^^^^
20:44:45 <tensorpudding> lol
20:45:50 <om-foxy> ddarius: huh, I changed readRecord to "return $! fromList m" and it works on my test file :)
20:49:12 <interferon> it occurs to me that quickcheck can give you an empirical version of dependent types
20:53:14 <aavogt> interferon: what are empirical types?
20:54:05 <Jafet> Deterministically empirical, too, so you never have to worry about code that accidentally works accidentally stop working
20:54:22 <interferon> well dependent types are about enforcing logical propositions about your data, if i understand it correctly.  so quickcheck tests give you empirical evidence that your propositions hold, since there's no static enforcement in haskell yet
20:54:43 <dolio> Dependent types are about types depending on values.
20:57:28 <kmc> Jafet, can you explain your comment
20:57:51 <kmc> i'd say QC provides an empirical version of something provided logically by DT
20:58:01 <Jafet> I can't!
20:58:21 <Jafet> Well, not without one of those quickcheck subversion examples
21:01:52 <jbapple> I have some ideas that I think might make IntSet faster. Is there a standard set of benchmarks for it, or should I write my own?
21:02:38 <interferon> quickcheck subversion examples?
21:05:04 <A1kmm> Is there an idiomatic way to group data in a list (e.g. (a -> a -> Ordering) -> [(a, b)] -> [(a, [b])] or Ord a => [(a, b)] -> [(a, [b])])
21:05:33 <dobblego> A1kmm, there is sortBy
21:05:52 <kmc> :t M.toList . foldr (\(k,v) -> M.insertWith (++) k [v]) M.empty
21:05:52 <lambdabot> forall k t. (Ord k) => [(k, t)] -> [(k, [t])]
21:06:15 <kmc> where M = Data.Map
21:07:02 <A1kmm> kmc: I was thinking about doing that... it just seems like something there should be a library function for (although Hoogle doesn't find anything).
21:07:08 <kmc> yeah
21:09:03 <BMeph> A1kmm: It seems a general trend in GHC, at least, that many one-liners you would expect in a library are not, perhaps because they're so easy to reproduce... 
21:09:35 <Saizan_> jbapple: performance for such structures in "containers" has been discussed on the libraries@ mailing list in the past, so i think they had some benchmarks
21:09:37 <kmc> there are some gaps in the standard lib
21:09:38 <aavogt> the libraries are already full of one-liners
21:11:17 <carter> hello all, whats the recommended lib for requesting web pages?
21:11:33 <carter> http?
21:11:36 <carter> or a different one?
21:11:44 <A1kmm> kmc: I guess it is because Data.List is in base, and Data.Map is in containers, so it might be more than a one-liner using base only.
21:12:09 <interferon> carter: that's what i use
21:12:40 <interferon> carter: Network.HTTP.simpleHTTP (getRequest url) >>= getResponseBody
21:12:41 <carter> ok
21:12:47 <carter> gotcha
21:13:33 <carter> had some funny problems with it partly 'cause the example usage in the hackage docs includes a Take 100 part, which made things not work (the perils of coding when ill and not aware of being spacey)
21:13:50 <carter> thank interferon!
21:13:53 <carter> *thanks
21:14:07 <interferon> np
21:15:17 <jbapple> I am trying to use criterion, but I keep getting "output type SOMETHINGSOMETHING not supported on this platform"
21:15:25 <jbapple> How can I make the output tpes supported?
21:15:36 <jbapple> so far, win, pgn, and svg don't work
21:15:40 <interferon> @source sort
21:15:41 <lambdabot> sort not available
21:15:49 <interferon> @source Prelude.sort
21:15:50 <lambdabot> Prelude.sort not available
21:16:30 <Jafet> @src sort
21:16:31 <lambdabot> sort = sortBy compare
21:16:35 <Jafet> @src sortBy
21:16:35 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
21:16:46 <Jafet> Reference implementation
21:17:32 <jbapple> the only hit I can find on google so far for criterion and "output type" "not supported on this platform" is a comment on bos's blog
21:17:45 <jbapple> from April 14
21:17:45 <interferon> Jafet: true
21:17:49 <jbapple> still unanswered
21:18:00 <interferon> just curious what algorithm ghc uses for sort
21:18:29 <Jafet> A standard mergesort
21:18:37 <jbapple> there's this: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18190.html
21:18:44 <jbapple> But I think I have gtk2hs installed
21:18:52 <Jafet> Which of course, isn't standard because it's lazy
21:19:00 <kmc> interferon, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-List.html#sortBy
21:19:07 <jbapple> At least, I do according to http://haskell.org/gtk2hs/archives/2010/05/25/gtk2hs-0110-released/
21:19:22 <interferon> kmc, Jafet: thanks!
21:19:32 <jbapple> Does anybody here have criterion working?
21:20:28 <kmc> jbapple, yes. i'm not generating graphs though
21:20:42 <jbapple> kmc: have you tried?
21:20:44 <kmc> no
21:21:39 <jbapple> Does anyone have criterion successfully making graphs?
21:21:54 <jbapple> I'm not sure what I'm supposed to do with the CSV output
21:22:10 <jbapple> BOS says something like "call gnuplot manually", but that doesn't work
21:22:46 <jbapple> And gtk is definitely installed
21:25:59 <coreyn> if i have a list and i want that list except for the second element, is there a builtin function to do that?  right now i'm doing [head stack] ++ (drop 2 stack)
21:26:34 <Jafet> Why not head stack : drop 2 stack
21:26:37 <dobblego> head stack : drop 2 stack -- though this is very suspicious
21:27:09 <coreyn> I guess because i'm a haskell noob and like my parenthesis 
21:27:12 <Jafet> @pl \(x:_:xs) -> x:xs
21:27:13 <lambdabot> ap ((. tail) . (:) . head) tail
21:27:39 <dobblego> slightly different for the single element list
21:27:43 <cdsmithus> Yeah, write that. :)
21:28:11 <Jafet> That will also give you a pattern match failure like you should be getting
21:28:17 <Jafet> > head []
21:28:18 <lambdabot>   *Exception: Prelude.head: empty list
21:28:26 <coreyn> I'll go with your first one, Jafet 
21:28:47 <coreyn> I don't know what -> is yet
21:29:00 <coreyn> i guess it's just a lambda expression
21:29:09 <coreyn> but it's just a bunch of weird symbols to me atm :p
21:29:29 <Saizan_> \ <pattern> -> <body>
21:29:32 <cdsmithus> Coreyn: yes, backslashes start lanbdas
21:29:37 <Jafet> @pl Î»x â†’ x
21:29:38 <lambdabot> (line 1, column 2):
21:29:38 <lambdabot> unexpected "\187"
21:29:38 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
21:29:42 <Jafet> Darn
21:29:43 <BMeph> liftM2 (++) (take 1) (drop 2) $ list -- ;)
21:30:08 <Saizan_> so that "\(x:_:xs) -> x:xs" is the same as "let f (x:_:xs) = x:xs in f"
21:30:13 <Jafet> That will require an unhealthy dose of monad tutorials
21:30:53 <SuperMario> why does f x = x + x give 'parse error on ='
21:31:13 <Jafet> Because you're typing that into ghci?
21:31:18 <SuperMario> yea
21:31:30 <coreyn> precede it with "let" when in ghci
21:31:33 <Jafet> ghci runs inside an implicit do-block, so you must use let
21:32:10 <SuperMario> so i do let f x = x+x and it goes 'scope on + '
21:32:18 <SuperMario> not in scope +
21:32:33 <Jafet> Heh
21:32:56 <Jafet> import Prelude
21:33:10 <cdsmithus> Did you do a -XNoImplicitPrelude?
21:33:18 <SuperMario> prelude wasnt tehre
21:33:20 <SuperMario> now it is
21:33:25 * BMeph wants to import Overture!
21:33:38 <SuperMario> nice it works
21:34:00 <Jafet> Overture.unsafeFireCannons
21:34:58 <danharaj> takeANap >> fireZeMissiles
21:35:11 <BMeph> Overture.WilliamTell.Is.Not.TheLoneRanger
21:35:24 <Jafet> @hoogle missile
21:35:24 <lambdabot> No results found
21:35:27 <Jafet> Er
21:35:30 <Jafet> @quote missile
21:35:30 <lambdabot> EvilTerran says: {-# LANGUAGE FlexibleMorals #-} -- needed for unsafeLaunchMissiles
21:39:49 <om-foxy> @hoogle replicateM
21:39:50 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
21:39:50 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
21:43:54 <SuperMario> haskell sucks, i could do all of this in python and way easier
21:47:41 <jbapple> @hoogle (:*:)
21:47:41 <lambdabot> No results found
21:47:47 <jbapple> @hoogle :*:
21:47:48 <lambdabot> No results found
21:47:56 <coreyn> that's how I've felt all night... took me 5 hours to figure out how to implement this algorithm in haskell when I could have done it i 5 minutes in python...  I think I got a little smarter, though :)
21:48:33 <kmc> great SuperMario
21:48:50 <kmc> to hear a Haskell expert like you say that really makes me reconsider my opinion on the language
21:49:40 <Jafet> @quote python
21:49:40 <lambdabot> python says: is a mediocre language invented by a mediocre person
21:50:00 <SuperMario> how do I even do a prime number generator like this wont even work [x : x<-[1..100] && for all y: y->[1..50] bool(y|x)=False ] should be all primes right? 
21:50:02 <Jafet> Is that a real quote
21:50:03 <SuperMario> from 10 to 100
21:50:23 <kmc> SuperMario, that's nonsensical code
21:50:31 <kmc> you are not going to write valid Haskell by random guessing
21:51:01 <kmc> and you're not going to learn Haskell if you have no patience
21:51:41 <kmc> i'm guessing you can't lift 400 lbs over your head
21:52:05 <kmc> and if you tried you'd probably decide it sucks and you should lift styrofoam instead
21:52:11 <SuperMario> lol
21:52:21 <kmc> which, that's valid
21:52:25 <danharaj> kmc: styrofoam doesn't give you inexplicable runtime failures
21:52:25 <kmc> if you don't want to be strong, don't lift weights
21:52:31 <Jafet> > [x | x <- [2..], all (\y -> mod x y /= 0) [2..x-1] ]
21:52:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:52:45 <kmc> if you don't want to write Haskell code, don't learn Haskell
21:53:49 <kmc> but i'm not sure then why you're here
21:53:57 <coreyn> I'm sure we'd be getting pretty biased opinions if we asked if it's worth it 
21:53:58 <SuperMario> i want to learn
21:54:06 <kmc> SuperMario, no you don't
21:54:08 <kmc> you want to know
21:54:15 <kmc> you have no attitude or patience for the learning process
21:54:24 <kmc> of course there's one simple explanation for why you're here
21:54:32 <kmc> but it's sort of the godwin's law of online community dispites
21:54:35 <kmc> disputes*
21:54:38 <m3ga> SuperMario: if you want to learn, pissing off people who can help you is not a good start.
21:54:42 <SuperMario> youre like hitler kmc
21:54:43 <ReinH> is there a more elegant way to do the following (where m1 and m2 are [[Int]]): all (\(a,b) -> a <= b) $ zip (concat m1) (concat m2)
21:54:45 * danharaj is having a great time watching kmc go all jedi mentor
21:54:50 <kmc> :D
21:54:51 <ddarius> > nubBy((>1).gcd)[2..]
21:54:52 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:54:52 <lambdabot>         against inferred ...
21:55:40 <kmc> (\(a,b) -> a <= b)  ===  uncurry (<=)
21:56:04 <ddarius> > nubBy(((>1).).gcd)[2..]
21:56:06 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:56:06 <kmc> :t \a b -> and $ zipWith (<=) (concat a) (concat b)
21:56:07 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]] -> Bool
21:56:13 <ReinH> oh it is
21:56:34 <kmc> @pl \a b -> and $ zipWith (<=) (concat a) (concat b)
21:56:35 <lambdabot> (and .) . (. join) . zipWith (<=) . join
21:56:38 <Saizan_> :t \a b -> and $ (zipWith (<=) `on` concat) a b
21:56:39 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]] -> Bool
21:56:44 <kmc> ooh
21:56:47 <kmc> nice Saizan_
21:56:56 <ddarius> @pl \m1 m2 -> all (\(a,b) -> a <= b) $ zip (concat m1) (concat m2)
21:56:56 <lambdabot> (all (uncurry (<=)) .) . (. join) . zip . join
21:57:13 <ReinH> yay Haskell :)
21:57:23 <danharaj> the pointless code doesn't look too bad
21:57:36 <kmc> :t (and .) . (zipWith (<=) `on` concat)
21:57:37 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]] -> Bool
21:57:45 <kmc> that's *almost* readable
21:57:52 <ReinH> o_O
21:57:54 <kmc> if you recognize the Â«(f .) .Â» pattern
21:58:04 <danharaj> :t (a .) .
21:58:05 <lambdabot> parse error (possibly incorrect indentation)
21:58:09 * kmc mumbles about design patterns and libraries
21:58:09 <ReinH> kmc: what is that pattern?
21:58:14 <kmc> :t ((?a .) .)
21:58:15 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?a::a -> b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
21:58:17 <kmc> err
21:58:21 <ReinH> oh
21:58:23 <kmc> :t let (.) = (Prelude..) in ((?a .) .)
21:58:24 <lambdabot> forall b c a a1. (?a::b -> c) => (a1 -> a -> b) -> a1 -> a -> c
21:58:25 <ReinH> that's esay then O_O
21:58:34 <ReinH> heh
21:58:41 <m3ga> > let sieve (p : xs) = p : sieve [ x | x <- xs, x `mod` p > 0 ] in takeWhile (< 100) $ sieve [2..]
21:58:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
21:59:00 <ddarius> ((f .) .) is \g x y -> f (g x y)
22:00:37 <coreyn> Thanks for the help everybody, I'll probably be back for  some more tomorrow  :)
22:00:55 <Saizan_> coreyn: great :)
22:01:10 <kmc> coreyn, thank you :)
22:03:09 <ReinH> ddarius: @pl ?
22:03:19 <kmc> @unpl ((f .) .)
22:03:19 <lambdabot> (\ b e i -> f (b e i))
22:04:07 <ClaudiusMaximus> -- someone must be able to come up with a better anagram than this nonsense? @pl \u n i nt e l li g ib le fl ip s t re am -> i n s t i l li nt am g i fl le re ib
22:04:50 <kmc> what
22:06:26 <Saizan> @pl \u n i nt e l li g ib le fl ip s t re am -> i n s t i l li nt am g i fl le re ib
22:06:29 <lambdabot> const (((const .) .) . ((((((((const .) .) .) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . ((((
22:06:30 <lambdabot> (((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip
22:06:30 <lambdabot> .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .)
22:06:30 <lambdabot> .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .)
22:06:30 <lambdabot>  .) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . (flip .) . ((flip .) .) . flip ap id . (flip .) . ((flip .) .) . flip id)
22:06:31 <lambdabot> optimization suspended, use @pl-resume to continue.
22:06:44 <Saizan> @pl \x -> x
22:06:44 <lambdabot> id
22:07:59 <Saizan> still nice that you get almost only flips there :)
22:08:51 <kmc> :t ((((((flip .) .) .) .) .) .)
22:08:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6)
22:08:52 <lambdabot>  => f6 (f5 (f4 (f3 (f2 (f1 (f (a -> b))))))) -> f6 (f5 (f4 (f3 (f2 (f1 (a -> f b))))))
22:09:12 <kmc> 7 functors at the same time
22:09:58 <Veinor> MORE FUNCTORS THAN YOUR TYPE HAS ROOM FOR
22:10:05 <Saizan> can you do that with only one hand?
22:12:22 <ReinH> WAT
22:15:56 * BMeph quickly checks to see if "2girls7functors.com" is available...
22:16:12 <ReinH> wat
22:18:15 <Jafet> <lambdabot> Plugin `pl' failed with: thread killed
22:19:39 <Saizan> yay, the timeout works :)
22:33:11 <BMeph> Are there dynamic-scoped languages with multiple namespaces, or is that self-contradictory by definition? If this even makes sense to ask...
22:42:28 <dolio> Some lisps have both dynamic scope and separate namespaces for values and functions.
22:42:35 <dolio> Does that win?
22:43:35 <kmc> silly paleo-lisp
23:36:33 <SuperMario> what does it mean when they use xs or ns 
23:36:51 <koala_man> it's plural of x or n 
23:36:54 <SuperMario> i keep seeing this like it says average ns = (sum ns) div (length ns) 
23:37:02 <SuperMario> plural?
23:37:22 <koala_man> like "cat" and "cats"
23:37:32 <Veinor> it means that it's a list
23:37:42 <Veinor> it's a convention
23:37:46 <SuperMario> ok 
23:37:59 <dolio> It's like Hungarian notation, only not terrible.
23:38:04 <Veinor> so, like
23:38:05 <Veinor> @src head
23:38:05 <lambdabot> head (x:_) = x
23:38:05 <lambdabot> head []    = undefined
23:38:10 <jbapple> Does anyone here know how to plot two densities on the same graph using criterion?
23:38:24 <Veinor> well, head (x:xs) = x would be the way to write it if you didn't wildcard-match the rest of the list :P
23:38:27 <jbapple> (BTW, I fixed the criterion bug I was asking about earlier and can now output graphics)
23:38:44 <jbapple> (It required some patching, so I sent BOS a patch)
23:38:47 <Jafet> @src map
23:38:47 <lambdabot> map _ []     = []
23:38:47 <lambdabot> map f (x:xs) = f x : map f xs
23:41:23 <SuperMario> why does 'let avg ns = (sum ns) div (length ns) avg [1,2,3]' give error
23:44:26 <Pseudonym> > let avg ns = (sum ns) div (length ns) avg [1,2,3]
23:44:27 <lambdabot>   not an expression: `let avg ns = (sum ns) div (length ns) avg [1,2,3]'
23:44:31 <Pseudonym> > let avg ns = (sum ns) div (length ns) in avg [1,2,3]
23:44:32 <lambdabot>   6
23:44:36 <Pseudonym> That what you wanted?
23:45:06 <Pseudonym> Incidentally, I think you want:
23:45:13 <Pseudonym> > let avg ns = (sum ns) `div` (length ns) in avg [1,2,3]
23:45:13 <lambdabot>   2
23:45:19 <orbisvicis> is there a quick way to check if a number is in range without referring to the number more than once, or using nested functions etc ?
23:45:25 <SuperMario> isnt average a function tho
23:45:35 <SuperMario> why cant I just type avg [1,2,3] after defining it 
23:45:41 <Pseudonym> > let avg ns = (sum ns) `div` (length ns)
23:45:42 <lambdabot>   not an expression: `let avg ns = (sum ns) `div` (length ns)'
23:45:52 <Pseudonym> That in GHCi should do it
23:45:56 <orbisvicis> i just want to avoid (really . long . method . to extract . number)
23:46:06 <Saizan> ?type inRange 
23:46:07 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
23:46:23 <Saizan> that'd be a bit abusive though :)
23:47:17 <Saizan> orbisvicis: (\n -> l <= n && n <= r) . really . long . method . to extract . number ?
23:47:31 <Pseudonym> @pl  (\n -> l <= n && n <= r)
23:47:31 <lambdabot> liftM2 (&&) (l <=) (<= r)
23:47:38 <Pseudonym> Oooh, I like that.
23:48:04 <c_wraith> Hmm.  I want a Language.Haskell.TH.Syntax.Lift instance for ByteString.
23:48:08 <Saizan> yeah, nicer than i imagined 
23:48:16 <Pseudonym> :t loftM2
23:48:17 <lambdabot> Not in scope: `loftM2'
23:48:18 <Pseudonym> :t liftM2
23:48:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:48:34 <orbisvicis> Saizan: perfect, i forgot i could use lambda expressions on the spot
23:48:37 <Pseudonym> :pl \n -> (l <= n, n <= r)
23:48:45 <Pseudonym> @pl \n -> (l <= n, n <= r)
23:48:45 <lambdabot> liftM2 (,) (l <=) (<= r)
23:49:14 <Pseudonym> :t (l <=) &&& (<= r)
23:49:15 <lambdabot> Expr -> (Bool, Bool)
23:49:42 <Pseudonym> :t \l r -> uncurry (&&) . (l <=) &&& (<= r)
23:49:43 <lambdabot>     Couldn't match expected type `(Bool, Bool)'
23:49:43 <lambdabot>            against inferred type `Bool'
23:49:43 <lambdabot>       Expected type: b -> (Bool, Bool)
23:49:50 <Pseudonym> Damnit.
23:49:57 <Pseudonym> Too unwieldy.
23:50:26 <Pseudonym> uncurry (&&) . ((l <=) &&& (<= r))
23:50:33 <Pseudonym> Makes sense I guess, though.
23:50:35 <Saizan> c_wraith: i want a version of lift that gets compiled to a pointer to a static closure.
23:52:35 <c_wraith> Saizan, that *would* be awesome.
23:57:39 <c_wraith> Huh.  There's no instance (Lift GHC.Word.Word8)?
23:57:50 <c_wraith> That confuses me.
23:59:18 * hackagebot yi 0.6.2.3 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.2.3 (JeffWheeler)
