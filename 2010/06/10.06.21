00:02:16 <SuperMario> I dont understand ...why does let N = 5/3 work but If I set let xs=[1,2,3,4,5] then let N = (length xs)/3 doesnt work
00:02:17 <SuperMario> wtf
00:02:31 <Zao> "work"?
00:02:33 <SuperMario> 'Not in scope, data constructor 'N''
00:02:45 <Zao> You probably meant `n'
00:03:04 <danharaj> identifiers starting with a capital refer either to types or data constructors
00:03:06 <Zao> As variables and functions begin with lowercase.
00:03:12 <danharaj> identifiers starting with a lowercase refer to terms
00:03:21 <danharaj> I don't like the term 'variable'
00:03:26 <danharaj> But I am a fascist :p
00:03:27 <Zao> Your former attempt working is either an accident or misremembrance.
00:03:37 <Zao> danharaj: I couldn't come up with a more appropriate describing name.
00:03:43 <Zao> danharaj: Especially before first coffee :D
00:03:47 <danharaj> heh
00:03:52 <Zao> > let N = 5/3 in 9001
00:03:53 <lambdabot>   Not in scope: data constructor `N'
00:03:56 <SuperMario> let a = (length xs)/3 doesnt work either
00:04:09 <SuperMario> 'No instance for (fractional int) '
00:04:09 <danharaj> what is the error
00:04:28 <Zao> > let xs = [1..5] in let a = (length xs) `div` 3 in a
00:04:29 <lambdabot>   1
00:04:30 <SuperMario> 'arising from use of /
00:04:36 <Zao> @type (/)
00:04:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:05:10 <Zao> is for things that are fractional, like floats and such.
00:05:14 <Zao> @type div
00:05:16 <lambdabot> forall a. (Integral a) => a -> a -> a
00:05:17 <Zao> @type quot
00:05:18 <lambdabot> forall a. (Integral a) => a -> a -> a
00:05:38 <danharaj> SuperMario: Do you mean fractional division or dividing integers with remainders?
00:05:42 <Zao> div/mod and quot/rem are the integral functions corresopnding to / and %
00:05:44 <SuperMario> fractional
00:06:24 <danharaj> >01 let xs = [1..5] in let a = (fromIntegral $ length xs) / 3 in a
00:06:32 <danharaj> ... lambdabot hates me
00:06:45 <danharaj> > let xs = [1..5] in let a = (fromIntegral $ length xs) / 3
00:06:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:06:50 <Zao> What's the rational constructor now again?
00:06:51 <Zao> :% ?
00:07:00 <c_wraith> Rational's constructor isn't exposed
00:07:09 <c_wraith> % is a function that acts like a constructor
00:07:18 <c_wraith> > 5 % 3
00:07:19 <danharaj> well I suck. Anyway.
00:07:20 <lambdabot>   5 % 3
00:07:43 <danharaj> SuperMario: length returns an integer, which you can't fraction, so apply fromIntegral to it to say that you want to convert it to another numeric type.
00:07:45 <c_wraith> > 10 % 6
00:07:47 <lambdabot>   5 % 3
00:08:45 <SuperMario> wtf
00:09:08 <c_wraith> Haskell has different numeric types, and doesn't *ever* automatically convert between them.
00:09:18 <c_wraith> If you need to convert between them, you need to do it explicitly
00:10:21 <SuperMario> so fromIntegral(length xs) to fraction?
00:10:23 <danharaj> you can also import Data.List and use genericLength
00:11:35 <danharaj> fromIntegral (length xs) and the compiler will infer what type you want
00:11:43 <EvilMachine> hello guys. there's one thing I always stumble over. i guess my thinking and the haskell thinking just bump heads there. i call it the "specific generics case". to put it in an exampled how would you implement a e.g. SQL database in haskell, considering how it does not allow mixed types in data structures (e.g. lists)?
00:12:27 <EvilMachine> to be more specific: say you have a "select" function. What return type would it have?
00:12:56 <c_wraith> look at what HDBC does.
00:12:58 <danharaj> EvilMachine: Perhaps it would be instructive to look at a haskell library for db access
00:13:02 <EvilMachine> (I guess "Table". But at the end you end up with atomar cells of lots of data types)
00:13:04 <danharaj> er, what c_wraith just said.
00:13:14 <EvilMachine> yes, right. i should have thought of that! :)
00:13:33 <danharaj> I'm going to guess there is a typeclass to describe datatypes that can be selected
00:13:40 <c_wraith> It just uses a data type.
00:13:45 <danharaj> fair enough
00:13:57 <danharaj> I have never touched a database in my life. I ought to.
00:14:19 <c_wraith> HDBC is very low-level.  It's easy to understand, but using it ends up being a LOT of code.
00:14:29 <Jafet> SQL databases are particularly terrible examples of databases
00:14:52 <EvilMachine> just a quick check: is it hard to do? because i always asked in possibly wrong ways, and got horrible cludges or rants about "wrongthink" as answers. ;) which surprised me, because I consider everything that's inelegant to be bad Haskell, and hence refuse to do it. ;)
00:15:23 <c_wraith> It just uses a data type that has constructors for the different types SQL uses.
00:16:06 <EvilMachine> danharaj: i wish someone would develop a modern database that stops with the primitive table relation paradigms and allows everything that haskell data type definition allows. :)
00:16:34 <danharaj> EvilMachine: I don't have an opinion about theory I haven't tried to learn.
00:17:26 <EvilMachine> c_wraith: sounds straightforward. So something like data SQLType = SQLType1 Type1 | SQLType2 Type2 | ...?
00:17:38 <c_wraith> EvilMachine, yep.
00:17:43 <EvilMachine> nice
00:17:55 <EvilMachine> allright.
00:18:17 <Pseudonym> EvilMachine: So serialise a function.
00:18:20 <EvilMachine> The only problem then, is what types you choose. As it ends up being rigid, later.
00:18:27 <EvilMachine> Pseudonym: ?
00:18:51 <Pseudonym> I mean store functions in the database.
00:18:54 <Pseudonym> Polymorphic ones.
00:19:09 <EvilMachine> Pseudonym: well, that would be very sweet. :)
00:19:26 <Pseudonym> And existential types on each row.
00:20:04 <EvilMachine> Pseudonym: but I guess that would mean to store the machine code required for it in the file.
00:20:20 <EvilMachine> Pseudonym: like, a snippet from the binary.
00:20:34 <EvilMachine> Sounds like a crazy dangerous thing to do, though.
00:20:35 <EvilMachine> ;)
00:21:57 <chaosape> anybody got a guess at why I am getting this error "cannot find normal object file while linking"?  I am using TH.
00:23:25 <EvilMachine> Hmm, damn. Am I the only one who thinks it's badly bloated to write data MyDBType = DBWord8 Word8 | DBWord8 Word16 | DBWord8 Word32 | DBWord64 Word64, and so on for all the types I would want to store, but at the same time just using Word64 and only a small subset being too limiting?
00:24:03 <EvilMachine> oops. typo
00:24:20 <EvilMachine> i meant MyDBType = DBWord8 Word8 | DBWord16 Word16 | DBWord32 Word32 | DBWord64 Word64 | ...
00:26:38 <EvilMachine> Someone should do a stand-up comedy part, where he says: "Hey, I'm a Haskell guy, and I'm going to do a little advanced 22nd century quantum mechanics to relax my brain from that coding session. ;))"
00:27:09 <chaosape> EvilMachine: I had to do something similar for field parsing out of headers.  Got tired of it and hacked out some nonesense that allows me to build arbitrary bit sized fields.
00:28:19 <SuperMario> so these little men just appeared on my screen
00:28:26 <SuperMario> and i thought i was hallucinating or something
00:28:27 <chaosape> EvilMachine: To be honest, I don't really know how it works but I copied enough of other peoples crazy type operator stuff such that I think it does what I want.
00:28:29 <SuperMario> but i print screened it
00:28:36 <SuperMario> http://i45.tinypic.com/21yb02.jpg
00:28:44 <SuperMario> what teh hell
00:29:05 <danharaj> SuperMario: You haven't seen those kinds of pop-ups before?
00:29:12 <SuperMario> no
00:31:32 <EvilMachine> chaosape: but that voids the whole point of the safe type system of haskell. :(
00:32:19 <EvilMachine> SuperMario: Protip: https://addons.mozilla.org/de/firefox/addon/1865/ :D
00:32:39 <chaosape> EvilMachine: Its Safe.  I even have the compiler checking that the headers are byte aligned!
00:33:00 <SuperMario> lol
00:33:33 <EvilMachine> But a function will not know what it ends up with, and henca can crash when facing an unexpected type, right?
00:34:00 <pastorn> What's a good port to use for testing communication on?
00:34:19 <EvilMachine> SuperMario: I had to surf at my brother's computer once. I think I foamed and started shaking after 10 minutes. ;)
00:34:27 <Jafet> Choose one at random, try binding to it
00:34:34 <pastorn> Jafet: binding?
00:35:11 <EvilMachine> pastorn: a not usually used port above 1056. and one that is not known to be a botnet port. ;)
00:35:34 <pastorn> EvilMachine: is there a list?
00:35:36 <EvilMachine> pastorn: so no 12345
00:35:42 <EvilMachine> yep, IANA has a complete list
00:35:58 <Jafet> ... of IANA-registered recommended ports.
00:36:10 <Jafet> Not very useful for most purposes.
00:36:50 <EvilMachine> pastorn: but above 1024 (os 1056 on Windows) it's basically free. just check that it does not conflict which what runs on the computers you're using it on.
00:36:51 <chaosape> EvilMachine: Well, I can only say what I meant it to do ... But when I do something like this "test0 = properlyFormed $ RFS6Bit $ RFS2Bit $ RFSWord8 $ RFSStop" it builds a special type using peano numbers ... I think ...
00:37:15 <int80_h> I just manually installed cabal. prefix is /usr/pkg, but I can't find where cabal went
00:37:24 <int80_h> could someone give me a hint where to look?
00:37:40 <pastorn> EvilMachine: how can i check which ports my computer currently uses?
00:37:51 <EvilMachine> chaosape: peano numbers? LOL. That is cool, but I fear that performance might be worse than crawling.
00:38:22 <pastorn> (rinning lolbuntu
00:38:24 <pastorn> )
00:38:30 <EvilMachine> pastorn: man netstat :)
00:38:31 * pastorn can't spell for shit
00:38:38 <koala_man> netstat -lt
00:39:01 <EvilMachine> pastorn: lolbuntu? What? Running the LOLcat desktop? ;)
00:39:09 <pastorn> almost...
00:40:16 <EvilMachine> pastorn: implemented in lolcode?
00:40:32 <EvilMachine> btw, there is a language that beats the crap out of Haskell: http://99-bottles-of-beer.net/language-lolcode-1544.html
00:40:36 <pastorn> http://mkeyd.net/~alexander/lolcat-almost.png
00:40:37 * EvilMachine ducks
00:40:40 * EvilMachine runs and hides
00:40:42 <pastorn> EvilMachine: ^^^^
00:42:45 <EvilMachine> pastorn: don't worry. he can help himself: http://navid.radiantempire.com/pix/Lustiges/lolcats/ihasclawsyou128420192974615000.jpg
00:48:13 <EvilMachine> hm... nno ByteString for Word32?
00:52:08 <EvilMachine> oh, ok, i've already found the solution
00:52:17 <EvilMachine> (Data.Binary.Get)
00:56:50 <arno5270> Woohoo! I created my first somewhat real Haskell program!
00:57:14 * Zao pats arno5270 on the back
00:57:25 <arno5270> And I say "somewhat", because I haven't found any real use for it yet, besides entertainment...
00:57:35 * arno5270 beams at Zao
00:57:41 <EvilMachine> arno5270: so it's more surreal? ;)
00:57:47 <Zao> import BASIC; 10 PRINT HI!; 20 GOTO 10
00:57:48 <EvilMachine> i like it already!
00:57:56 <arno5270> lol
00:58:34 <arno5270> It's a Markov chain generator. I was surprised at the size of the codebase once I was done stripping out everything that wasn't needed.
00:59:02 <Lemon> so I was playing around with type families.
00:59:25 <Lemon> Fun stuff. They're just type-level functions, right?
00:59:28 <arno5270> Plus I got to use the word "thongs" in my code in a defendable way.
00:59:32 <arno5270> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26421#a26421
01:00:13 <Lemon> but really, the syntax for it feels "bolted on".
01:02:14 <arno5270> I think type families are a bit out of my league just yet, Lemon... :)
01:02:22 <EvilMachine> arno5270: I can now see why you did not find any real use for it. ;)
01:02:34 <EvilMachine> arno5270: But I think learning is a good use on its own.
01:02:49 <killerstorm> hi. is there a way to find where does exception come from?
01:02:52 <EvilMachine> arno5270: Apart from that, why not state a goal, and then fulfill that? :)
01:03:02 <Saizan> Lemon: what in particular feels clunky?
01:03:18 <killerstorm> like a call stack or something like that.
01:03:26 <Lemon> having to type "type instance" a billion times.
01:03:33 <Saizan> killerstorm: you could try the ghci debugger or the profiler trick
01:03:53 <EvilMachine> hey, Professor Dr. dr. rer. nat. hab. ing. Saizan! ;) I finally start remembering names of the users in here! ;)-
01:04:29 <Saizan> rer. nat. hab. ?:)
01:04:55 <EvilMachine> Saizan: no idea. ignore my random blabbing. ;)
01:04:58 <Lemon> really, it can't be that bad to simply define an operator like "~=" or ":=" for this purpose.
01:05:15 <arno5270> EvilMachine: Right now I am trying to figure out if there is a faster way to create the whole Markov map.. right now it takes ages. And the main goal was to learn more about Haskell, so goal achieved. :)
01:05:54 <EvilMachine> sounds good
01:06:35 <EvilMachine> the road to world dominance is paved with slow Markov maps... I guess. ;)
01:07:04 <EvilMachine> (or is it "domination"?)
01:07:13 * EvilMachine is not a native speaker.
01:07:33 <arno5270> Me neither.. I will have to watch more "Pinky and the Brain" to answer that question.
01:09:21 <Saizan> (some hours ago someone asked if i was a PhD student, now all these titles, i should get my first degree at least..)
01:11:48 <arno5270> Degrees are overrated, Saizan :)
01:12:31 <EvilMachine> arno5270: agreed
01:12:45 <Cale> killerstorm: It's somewhat unfortunate that there's no such thing as a call stack in the lazy evaluation model :)
01:13:41 <EvilMachine> Cale: but there should be a evaluation stack, so? Something that has one line for every step in the substitution process...
01:13:43 <Cale> killerstorm: If you're totally at a loss about where the exception is coming from, then yes, you could try compiling with -prof -auto-all and then running the program with +RTS -xc on the commandline
01:13:46 <EvilMachine> so=no
01:14:01 <Cale> EvilMachine: The GHC stack consists of case expressions which are waiting to match
01:14:11 <EvilMachine> ah, hmm...
01:14:25 <Cale> EvilMachine: That might actually be pretty useful if they were associated with line numbers
01:15:25 <EvilMachine> hey, it should be pretty easy to create a ternary operator in Haskell, right? just by using two functions working together. 
01:15:26 <Cale> But lots of them probably have nothing to do with the input program...
01:15:33 <Cale> yes
01:17:43 <Cale> let (?) b x y = if b then x else y in [b ? "hello" $ "goodbye" | b <- [True, False]]
01:17:47 <Cale> > let (?) b x y = if b then x else y in [b ? "hello" $ "goodbye" | b <- [True, False]]
01:17:47 <lambdabot>   ["hello","goodbye"]
01:19:37 <Cale> You could also do something like define a datatype like  data Pair a = a :*: a, and then (?) :: Bool -> Pair a -> a, and set the operator precedences appropriately :)
01:20:28 <mm_freak> is there a to-JVM-compiler for haskell?
01:20:47 <Cale> I don't think so
01:21:16 <Cale> However, there was a somewhat Haskell-inspired language which ran on the JVM, called CAL or something
01:21:34 <EvilMachine> Hmm, when i have a value x of a complex type MasterPain, another type "Betty Int MasterPain" and i do (Betty 0 x, Betty 1 x), will this keep only one version of x in memory?
01:22:06 <Cale> yes
01:22:09 <Zao> Likely.
01:22:18 <Cale> In any sane implementation, yes ;)
01:22:21 <mm_freak> Cale: ok, thanks
01:22:24 <Veinor> I like your naming scheme.
01:22:29 <EvilMachine> Veinor: :D
01:22:36 <mm_freak> seems like scala is a fine language, but i'd prefer haskell if possible =)
01:23:05 <Cale> EvilMachine: In fact, those x's will only be code pointers to code that returns x when entered.
01:23:06 <EvilMachine> Veinor: module EvilPlan where { it = evil; evil = so evil }
01:23:15 <Veinor> evil = fix so?
01:23:52 <EvilMachine> Cale: hey, thank you. That makes me feel a bit safer
01:24:58 <EvilMachine> Cale: I'm basically creating a graph (math) structure with "Node NodeValue [Relation]" and "Relation Node Node Node" types, and don't want everything to have a billion copies. :)
01:25:42 <EvilMachine> Veinor: it's so evil, that GHC is too scared to point out that "so" is undefined. it just knows what is meant. ;)
01:25:42 <Zao> Updating that will be ... fun.
01:25:47 <Cale> EvilMachine: By mututal recursion?
01:25:52 <Cale> mutual*
01:26:00 <EvilMachine> Zao: what do you mean? 
01:26:03 <Zao> I thought that tying the knot with graphs was horribly non-trivial.
01:26:08 <Cale> EvilMachine: So long as you never need to change the graph, that works fine
01:26:30 <EvilMachine> Cale: obviously, no? :)
01:26:36 <Zao> s/non-trivial/impossible/
01:26:36 <EvilMachine> Cale: why?
01:26:45 <EvilMachine> looks pretty easy to me
01:26:56 <Cale> EvilMachine: Because there will be no visible difference between your graph and one which is infinite.
01:27:03 <EvilMachine> now i'm frightened. please enlighten me. 
01:27:10 <EvilMachine> Cale: correct
01:27:19 <EvilMachine> Cale: but infinite graphs is kinda the point
01:27:33 <Cale> EvilMachine: Even though your graph is finite in memory, if you were to do something like map a function over the NodeValues in the obvious recursive way, you'd start building an infinite graph
01:28:11 <Cale> (not all of which would necessarily be in memory all at once, and which would be constructed lazily, of course, but still could grow arbitrarily large
01:28:13 <EvilMachine> Cale: yep, I'm aware of that. But it's not worse than mapping over [1..], is it?
01:28:20 <Cale> right
01:28:37 <Cale> Or, better example, mapping over  ones = 1 : ones
01:29:00 <EvilMachine> I am still thinking and planning. Of course I will try anything to limit endless recursion.
01:29:02 <Cale> Which will be finite in memory, despite being an infinite list :)
01:29:21 <Cale> It's often more convenient in the end just to use a Data.Map
01:29:38 <Cale> One of my favourite graph representations is  Map Vertex (Set Vertex)
01:29:43 <EvilMachine> Wait, I have already written code that does prevent endless recursion, and letting a graph hang down by an arbitrary node.
01:30:17 <Cale> If your "NodeValue" parameters can be assumed to be unique, then you can prevent endless loops.
01:30:47 <Cale> (and they're equality-testable, or better, ordered)
01:31:06 <EvilMachine> Cale: I am still new. So my experience with the whole library is still very small. I fear I will re-invent half a dozen wheels and the tank around it. ;)
01:42:06 <EvilMachine> Cale: yes, they should be equality-testable. but I don't want to enforce ordering
01:42:35 <EvilMachine> Cale: by the way, I just found my first attempt at a graph from last week: http://pastebin.com/wL9Yhp9p 
01:43:17 <EvilMachine> Cale: it may not be efficient or elegant, but it works, and for a newbie I'm happ at how well I can just "grab a node, and let the rest hang down by the relations".
01:43:22 <EvilMachine> +y
01:45:11 <EvilMachine> btw: the reason it looks so unaligned, is that i translated the words to english via search/replace. it still compiles and works though.
01:49:08 * hackagebot hamlet 0.3.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.3.1 (MichaelSnoyman)
01:55:40 <EvilMachine> hamlet looks like yet another one falling for the inner platfrom anti-pattern. :/
02:02:19 <Saizan> the what?:)
02:04:20 <EvilMachine> Saizan: http://en.wikipedia.org/wiki/Inner-platform_effect and especially http://thedailywtf.com/Articles/The_Inner-Platform_Effect.aspx
02:04:46 <EvilMachine> Saizan: TypoScript, implemented in PHP is perhaps the prime example of that anti-pattern. :)
02:05:28 <EvilMachine> weird, why does the following to work?: let x (>==) y = (x,y) :: Int -> Int -> (Int,Int)
02:06:38 <EvilMachine> ah lol, i get it
02:06:47 <EvilMachine> i forgot to remove the ()
02:07:21 <c_wraith> nah, hamlet just builds html templates.  It's far short of replicating the functionality of haskell
02:07:31 <EvilMachine> yay for unicode, neo 2.0 and haskell!  atomV >≠≠ atom2 = (atomV,atom2)
02:07:36 <EvilMachine> oh, that did not work here
02:07:55 <EvilMachine> Cale: but why write %html instead of just <html>?
02:07:55 <c_wraith> I think there's an extension to tell ghc to allow unicode
02:08:34 <EvilMachine> c_wraith: don't worry.unicode already works here. only the paste fails, since it's over a ssh and screen seession going into irssi. ^^
02:08:35 <c_wraith> I'm not cale, but...  Because it's *not* an sgml.  It doesn't use matched open/close pairs to determine nesting.  It uses indentation instead.
02:08:52 <EvilMachine> c_wraith: lol. sorry
02:09:00 <c_wraith> So using sgml syntax for a non-sgml language would be...  misleading, at best.
02:09:11 <EvilMachine> c_wraith: i mean, why not write it right in html?
02:09:48 <c_wraith> I don't know.  I didn't invent HAML.  Hamlet is basically just a compile-time HAML -> haskell expression converter.
02:10:21 <Saizan> one reason might be that sgml sucks :)
02:10:35 <c_wraith> Saizan, your ghciutils thing is incredibly intimidating.  why are all the type signatures in cabal's stuff so scary? :)
02:10:48 <EvilMachine> I am against inventing custom syntax for no reason. I'd go with just pudding <= someHaskellExpression %>
02:10:52 <EvilMachine> oops
02:11:04 <Saizan> c_wraith: mh, because they use LongDescriptiveNames for the types?:)
02:11:15 <EvilMachine> I'd go with just putting <%= someHaskellExpression %> into the html file.
02:11:58 <EvilMachine> c_wraith: can I see that intimidating thing?
02:12:02 <Saizan> the reason is better ergonomics
02:12:11 <c_wraith> http://github.com/Saizan/ghci-utils/blob/master/GhciUtils.hs
02:12:42 <Saizan> especially within a language that doesn't have matching open/close delimiters (or well, they are there but are mostly unused :)
02:12:46 <EvilMachine> I don't see anything intimidating there. Looks pretty actually.
02:13:07 <c_wraith> The scary parts are figure out where the data comes from and goes.
02:13:09 <Saizan> c_wraith: got any question in particular?
02:13:27 <c_wraith> I really just wonder why ghcOptions has so many arguments.
02:13:51 <EvilMachine> c_wraith: that scary part a general Haskell thing. ;)
02:14:25 <c_wraith> the first three arguments seems like they should, in normal cases, be intimately linked.
02:14:27 <Saizan> c_wraith: ultimately all the data comes from LocalBuildInfo
02:14:27 <EvilMachine> c_wraith: MOAR PWR? ;)
02:15:40 <Saizan> c_wraith: though the fact that LBI contains data for both the library and all the execs, means that you're going to extract the relevant records by hand and pass them explictly so the ghcOptions knows what you want
02:16:44 <Saizan> s/so the/so that/
02:18:32 <c_wraith> Hmm.  Is this in a package anywhere?  I feel like not copying & pasting the whole thing. :)
02:19:52 <Saizan> i don't feel like i've tested/used it enough to release it as a package
02:23:46 <c_wraith> hmm...  I won't have any way of getting the name of the exe I care about from where the code will be running, if there are multiple exes in the cabal file.
02:23:59 <c_wraith> Still, for the case I'm looking at, I don't see a good reason to have multiple exes.
02:27:37 <ukl> hmm I tried to install hakyll using 'cabal install hakyll' on debian/sid, everything looked fine but 'ghc --make hakyll.hs' in an example directory gets me "Could not find module `Text.Hakyll.CreateContext'.  'ghc-pkg list' does list hakyll tho.... Kind of confusing.
02:27:54 <Saizan> mh, "withLibLBI" might be intimidating since it's in IO, but it's really a pure function i think
02:29:13 <Saizan> ukl: which version of hakyll did you get?
02:29:53 <ukl> Saizan: hakyll-2.1.1
02:30:33 <ukl> Using ghci, even ':m + Text.Hakyll' fails
02:30:42 <EvilMachine> what the... I just did import Data.ByteString.Lazy as BSl, and then used (x `elem` ys) expecting it to use Prelude.elem because I did not mention the BSl, but GHC complains about it being ambigious. If it is ambigious, why did I say "as BSl" then?
02:30:55 <danharaj> import qualified
02:31:04 <EvilMachine> danharaj: aah
02:31:05 <EvilMachine> lol
02:31:13 <danharaj> if you don't add qualified, it imports it with both names.
02:31:30 <Saizan> ukl: "ghc-pkg check"?
02:31:36 <EvilMachine> thanks
02:31:51 <Saizan> ukl: can you paste your whole "ghc-pkg list" if that doesn't report any error?
02:31:57 <ukl> Saizan: no output, exitcode 0
02:32:09 <ukl> sure,just a second
02:33:06 <ukl> http://pastie.org/1013352
02:33:43 <ukl> uhm that was stupid, hidden things don't look hidden this way... let me re-post...
02:35:01 <Saizan> that's not so relevant anyway
02:35:30 <ukl> ok then... getting 503 when trying to edit at the moment... I'll leave it that way
02:35:51 <Saizan> however, maybe it'd be more interesting to start ghci with -v, and see if it hides any packages because of conflicts
02:36:11 <Saizan> and if hakyll is among those
02:38:05 <ukl> Saizan: indeed! oh....
02:38:35 <Saizan> ?
02:38:37 <ukl> package hakyll-2.1.1-d2a7...2cce is unusable due to missing or recursive dependencies:  pandoc-1.5.1.1-d072...07c0
02:38:53 <ukl> pandoc is shadowed by pandoc-1.5.1.1-...
02:39:41 <ukl> http://pastebin.org/347691
02:39:45 <EvilMachine> I thought the following was OK: instance SomeTypeClass stc => Eq stc where ...
02:39:51 <EvilMachine> It seem it is not.
02:40:02 <EvilMachine> how come?
02:40:14 <EvilMachine> looks reasonable to me
02:40:14 <Saizan> because it overlaps with any other Eq instance
02:40:21 <EvilMachine> it does?
02:40:37 <EvilMachine> somehow i just have a mental blackout...
02:40:44 <Saizan> since the context is not taken into account when resolving the instance, it's only added as an additional requirement after the fact
02:41:43 <EvilMachine> aaah, ok, i think i am beginning to get it... again... i feel like i have read something about this already
02:41:57 <Saizan> ukl: hah! you've two installations of the same version of both pandoc and texmath, you've to keep only one of each
02:42:01 <EvilMachine> but there were, i think, about 3 sensible ways around it.
02:42:34 <Saizan> ukl: you can use "ghc-pkg unregister foo" passing it either --global or --user depending from which user db you want them to be removed
02:43:01 <Saizan> EvilMachine: you could use a newtype
02:43:42 <Saizan> then there's the AdvancedOverlapping wikipage, not sure if it applies here though
02:44:34 <ukl> Saizan: Hmm probably one from debians repositories and one from installing hakyll via cabal -- but why did cabal install hakyll install those and not rely on the debian packages (which is what I hoped for)?
02:47:35 <ukl> Saizan: got rid of the debian packages. Works now. Thanks a lot
02:47:52 <EvilMachine> Saizan: yes. I'll first have to understand why it happens at all. Because GHC tells me that "All instance types must be of the form (T a1 ... an), where a1 ... an are type *variables*,, nd each type variable appears at most once in the instance head.). From my understanding, 
02:48:09 <Saizan> ukl: well, assuming the debs were installed first, one possible reason is that since "cabal install" also sees the versions of packages in the user db, and you've some newer versions there of some packages, it might have decided to recompile against these newer deps rather than using the packages you got from the debs
02:48:51 <EvilMachine> Saizan: yes. I'll first have to understand why it happens at all. Because GHC tells me that "All instance types must be of the form (T a1 ... an), where a1 ... an are type *variables*,, nd each type variable appears at most once in the instance head.). From my understanding, instance SomeTypeClass stc => Eq stc where... fulfulls these rules. stc only appears once, and is a type variable, no?
02:49:22 <Saizan> ukl: btw you can pass "--dry-run -v" to see what cabal install is going to do and decide if it's sensible enough :)
02:50:09 <Saizan> EvilMachine: you missed the T, which is meant to be a type constructor, not the class
02:50:35 <Saizan> so ... => Eq (T stc) ... would have been accepted
02:50:40 <EvilMachine> Saizan: aaah, ok. :/
02:50:46 <ukl> Saizan: :) 
02:53:13 <Saizan> EvilMachine: btw, you can make ghc accept "instance SomeTypeClass stc => Eq stc where" using FlexibleContexts, OverlappingInstances, UndecidableInstances, but it won't be very pleasant to use
02:53:57 <Saizan> that kind of instance only makes sense when you want to make a sort of typeclass synonym/alias
02:58:33 * hackagebot hsignal 0.1.0.5 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.0.5 (VivianMcPhail)
02:59:25 <EvilMachine> Saizan: yep. i figured that there is a reason it is not on by default. :)
02:59:46 <illissius`> "since the context is not taken into account when resolving the instance, it's only added as an additional requirement after the fact" seems everyone runs into this... it's like clockwork
03:00:05 <illissius`> (the new OutsideIn(x) thingie isn't going to have any bearing on it, right?)
03:00:31 <Cale_> No, it's by design.
03:01:07 <Cale_> Instances can always be added by later imports, so you can never prove that an instance won't exist.
03:01:18 <Cale_> Er, later modules, I should say.
03:02:36 <illissius`> can't it throw an error when compiling the later module in that case?
03:03:43 <EvilMachine> hmm... is there such a thing as parametrized type classes?
03:04:24 <illissius`> EvilMachine: what do you mean?
03:05:34 <EvilMachine> illissius`: the concept of being able to create a function that is not a member of one, but two type classes at once.
03:06:06 <Jafet> You can't normally add functions to type classes, eh
03:06:25 <Jafet> Oh, you're talking about methods. Nevermind
03:07:02 <EvilMachine> like class Query query, DB db where { queryDB :: db -> query -> Result }
03:07:32 <illissius`> EvilMachine: there's multiparameter type classes (also associated types)
03:07:53 <EvilMachine> where? :)
03:08:14 <illissius`> or you can put the function in a superclass and have both of the other classes 'inherit' from it (I'm not sure what the proper haskell terminology is?)
03:08:18 <EvilMachine> (no idea what to enter into google here)
03:08:33 <illissius`> "multiparamtypeclasses" and "typefamilies" respectively
03:09:47 <illissius`> EvilMachine: does either the query or the db uniquely determine the other, or can you mix and match different types of queries to different types of db?
03:14:19 <EvilMachine> oh, i read up on multi-parameter type classes, and they seem pretty usable. but the type families page is huge and i don't feel experienced enough to read it.
03:15:33 <illissius`> EvilMachine: basically (in this context) what it lets you do is you can have not just methods in your type classes but types, and then each instance can declare a different instance for that type
03:15:58 <EvilMachine> illissius`: there can be multiple query types per db. (like using either sql or xpath on a postgre db). but of course there can also be different dbs (that then have to have their own implementation of that query language for them)
03:16:22 <EvilMachine> illissius`: sound great and like an useful tool
03:16:41 <EvilMachine> but i think multi-parameter type classes suffices in my case.
03:16:49 <illissius`> EvilMachine: in that case you probably want plain multiparamtypeclasses and then declare a separate instance for each valid db-query pair
03:17:36 <EvilMachine> I'll remember type families for when i'm done with reading Real World Haskell. I have planned to read up on all the GHC extensions.
03:17:56 <EvilMachine> thanks, illissius`! :)
03:18:32 <EnglishGent> hello
03:18:54 <EvilMachine> by the way: everyone who ever helped me in here, can get a drink of his choice, in case he ever happens to be in Cologne. :)
03:19:26 <EvilMachine> (and I may introduce him to some girls. ;)
03:20:00 <illissius`> for the case where each db has its own query type you could do it with associated types(==typefamilies) like this: class DB db where { type Query db; queryDB :: db -> Query db -> Result }; instance DB SomeDB where { type Query SomeDB = SomeQuery; queryDB db somequery = yourcodehere }
03:20:05 <EnglishGent> hi EvilMachine :)
03:20:05 <illissius`> EvilMachine: and you're welcome :)
03:21:10 <EvilMachine> EnglishGent: hi
03:22:41 <mm_freak> is there a binding to the fsync() syscall?
03:22:58 <mm_freak> i'm unable to find anything in System.IO and System.Posix.*
03:23:20 <EvilMachine> illissius`: sounds simpler than i thought, those type families. man, with all those extensions, you could write code that would look nothing like Haskell at all, totally weirding out newbies. ;)
03:24:56 <ez0teric> Hello, ghc (6.10.4 or 6.12.3 from portage) can be compiled by gcc 4.5 ?
03:26:34 <illissius`> @faq can you write BASIC in Haskell?
03:26:35 <lambdabot> The answer is: Yes! Haskell can do that.
03:27:14 <wto> And it has already been done!
03:41:36 <mreh> is ~ lazy pattern matching?
03:41:58 <Jafet> It's dangerously lazy
03:42:16 <Jafet> "Negligent" pattern matching?
03:43:17 <mreh> so dangerous, it's currently being investigated by social services
03:43:46 <Jafet> Now the poor patterns will be put on welfare.
03:46:19 <Gracenotes> mreh: something like \~(a, b) -> .. is closer to \x -> let (a, b) = x in ...
03:48:01 <Gracenotes> so you don't snap the neck of the computation. er, force the spine.
03:48:40 <Botje> woo! violence!
03:48:52 * Gracenotes thinks the former should be a valid term in the study of semantics
03:48:54 <SuperMario> Haskell should be renamed Hell
03:49:13 <EnglishGent> SuperMario - your thinking of Perl surely? :)
03:49:29 * EnglishGent hastily crosses himself after naming *that* language 
03:49:34 <EnglishGent> :)
03:49:51 <Botje> hey, i like perl!
03:50:24 <arw_> haskell stole the regexp-operator from perl!
03:50:58 <Jafet> Heh, what
03:51:15 <Jafet> > let a (~=) b = "success" in 1 ~= 2
03:51:16 <lambdabot>   Not in scope: `~='
03:51:22 <Jafet> > let a ~= b = "success" in 1 ~= 2
03:51:23 <lambdabot>   "success"
03:52:02 <Gracenotes> haskell is proficient at stealing operators
03:52:11 <theorbtwo> ...but Perl's operator is =~, not ~=.
03:52:18 <Gracenotes> perl has a large horde of operators, but it can't acquire any more
03:52:20 <Jafet> How would I know.
03:52:39 <Jafet> > let a =~ b = "failure" in 1 =~ 2
03:52:40 <lambdabot>   "failure"
03:52:42 <Gracenotes> (though apparently perl 6 is even more crazy ad-hoc)
03:53:11 <theorbtwo> (Because ~= is reserved as a shortcut for in-place binary not, which doesn't exist, because binary not is a unary operator, so a = a ~ b doesn't make sense.)
03:54:10 <theorbtwo> Gracenotes: It's more ad-hoc in that you can dynamicly modify the parser in the middle of parsing, including adding new operators.
03:54:27 <theorbtwo> It is less ad-hoc in that it is meant to have an actual specification independent of the implementations.
03:54:54 <EvilMachine> EnglishGent: Perl? That's nothing! I raise you TypoScript, oimplemented* in PHP! ;P
03:54:57 <Gracenotes> perl seems to be concerned more with the power of its parsers than the efficient
03:55:02 <Gracenotes> efficiency
03:55:03 <EvilMachine> OH TEH HORRORZ
03:55:13 <Gracenotes> but with a language that's rooted in linguistics, it's just what you'd expect :)
03:55:51 <Jafet> If you think that is ad-hoc, Common Lisp lets you modify the reader
03:56:14 <Jafet> (As your program is read in.)
03:56:49 <SuperMario> how do you say for all in haskell
03:56:54 <theorbtwo> Jafet: What's the difference between the reader and the parser here?
03:57:00 <SuperMario> as in for all y in [1...100]
03:57:15 <EvilMachine> theorbtwo: maybe he meant the parser. or the tokenizer perhaps?
03:57:17 <SuperMario> for all y in [1...100] such that something
03:57:29 <Jafet> The reader reads lexical structure like S-expressions, character and string literals
03:57:37 <sioraiocht> SuperMario: what do you want to do?
03:57:45 <SuperMario> make primes
03:57:56 <EvilMachine> not fix pipes? ;)
03:58:05 <SuperMario> lol
03:58:11 <theorbtwo> Jafet: Sounds like a parser to me.
03:58:21 <Jafet> I've never actually seen mario fix a pipe, eh
03:58:49 <sioraiocht> SuperMario: well, there is no explicit for looping in haskell
03:58:57 <Jafet> @hoogle for
03:58:58 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
03:58:58 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
03:58:58 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
03:59:18 <sioraiocht> tha's a function, not a language construct
03:59:21 <EvilMachine> SuperMario: map myForallFunction [1.00] ?
03:59:25 <EvilMachine> oops
03:59:30 <EvilMachine> SuperMario: map myForallFunction [1..00] ?
03:59:33 <EvilMachine> noooo
03:59:34 <theorbtwo> Almost everything in Haskell is an expression, and a for loop would be an expression that doesn't return anything.  Given lazyness, that means it's body would never run.
03:59:34 <EvilMachine> :i
03:59:37 <theorbtwo> You want a map.
03:59:38 <EvilMachine> SuperMario: map myForallFunction [1..100] ?
03:59:42 <EvilMachine> yeah! this thime!
03:59:48 <EvilMachine> aaaah!
04:00:42 <Jafet> I'm sure you can emulate C-like for loops with some suitable overload of ;
04:00:43 <SuperMario> i want to do mod stuff
04:01:00 <SuperMario> like x mod y ==0 
04:01:03 <SuperMario> is true
04:01:33 <ClaudiusMaximus> @check \ x y -> x `mod` y == 0
04:01:35 <lambdabot>   "*Exception: divide by zero
04:01:37 <EvilMachine> Jafet: but why? :)
04:01:54 <Jafet> Because BASIC is basic.
04:01:56 <EvilMachine> Jafet: wait... you can overload ";"??
04:02:20 <Jafet> Hm, maybe not. do-while loops?
04:03:25 <EvilMachine> Jafet: I want to override ";","[","]","{","}","->", "::", "\" and most importantly "=" ;))
04:04:07 <Jafet> Well, [] is a constructor
04:04:20 <Jafet> You omitted ","
04:04:27 <koala_man> what do you call it in AI when your goal is to add as few rules as possible and get maximal learning, as opposed to adding lots of rules by hand to get maximal performance?
04:07:12 <illissius`> you can do 'while' loops: while :: IO Bool -> IO () -> IO ()
04:07:38 <illissius`> it's just awkward as hell because of half of things being in IO and the other half not and all the lifting shenanigans
04:07:52 <Gracenotes> the C solution for that is to use IORefs
04:08:13 <Starfire> :t forM_
04:08:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:08:57 <Gracenotes> thankfully, C makes IORef declaration very simple: int i = 0; then readIORef is implemented by naming the variable in context, and it does do lifting for you, right..
04:09:36 <Gracenotes> hum
04:10:03 <ksf> It wouldn't be possible in general to exchange a haskell .so with a recompiled version due to inlining etc. would it?
04:11:00 <illissius`> I wonder if you could do an imperative-style language which is completely monadic (and you can use different monads), it just does all the lifting for you automatically
04:11:17 <ksf> you mean something like monad transformers?
04:11:42 <Twey> Hmmm
04:11:55 <Jafet> Clean uses linear typing with a similar vein
04:13:08 <illissius`> that's maybe half. the other half is that when it sees one thing in a monad and another thing not, it silently lifts it rather than giving a type error
04:13:19 <illissius`> but I'm not sure if that can be done unambigiously or without other unpleasant effects
04:14:00 <Jafet> What if you have two incompatible monads
04:14:09 <illissius`> then presumably it would give you a type error :)
04:14:46 <Jafet> I expected you to say it would do a complete search of the type space to find a compatible lift
04:15:07 <Twey> Ad-hoc polymorphism: data FooMonad = …; instance MonadIO FooMonad where …; instance Monad FooMonad where return = …; (>>=) :: FooMonad a -> (a -> FooMonad b) -> FooMonad b; (>>=) = …; (>>=) :: MonadIO m => FooMonad a -> (a -> m b) -> FooMonad b; a >>= b = a >>= liftIO (liftIO b)
04:16:15 * hackagebot vhdl 0.1.2 - VHDL AST and pretty printer  http://hackage.haskell.org/package/vhdl-0.1.2 (ChristiaanBaaij)
04:16:16 <illissius`> Jafet: oh. I haven't even used monad transformers before so this is just total speculation :(
04:16:35 <Jafet> I used monad transformers once. I decided never to again
04:17:04 <Jafet> Three layers of StateT, fun for all
04:17:13 <Twey> Hehe
04:17:21 <Twey> Needs moar encapsulation
04:17:39 <SuperMario> how come this doesnt work? [ x | x<-[1..100], if (y<-[1..50]) then (mod x y /= 0)] 
04:18:00 <Twey> ‘if’ expressions need an ‘else’ clause
04:18:11 <Twey> Otherwise, what would the expression be if the condition was false?
04:18:28 <SuperMario> wtf
04:18:47 <SuperMario> then itd be true
04:18:52 <SuperMario> and x would be in the set
04:18:57 <yitz> > [ x | x<-[1..100], y<-[1..50], mod x y /= 0]
04:18:58 <lambdabot>   <no location info>: lexical error at character '\GS'
04:19:16 <ksf> you want "when"
04:19:19 <ksf> :t when
04:19:21 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:19:27 <Twey> No it wouldn't… you haven't said what the value of the expression should be if ‘y <- [1 .. 50]’ is false
04:19:44 <Twey> Though ‘y <- [1 .. 50]’ isn't a boolean expression anyway
04:20:26 <yitz> SuperMario: what are you trying to do?
04:20:32 <SuperMario> list primes
04:20:49 <Twey> > [ x | x <- [1 .. 100], y <- [1 .. 50], mod x y /= 0 ]
04:20:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:20:54 <ksf> [x | x <- [1..100], y <- [1..50], guard (mod x y /= 0)] ?
04:20:58 <Twey> ☺
04:21:35 <soupdragon> what's a primes
04:21:36 <Twey> > [ x | x <- [2 .. 100], y <- [2 .. 50], mod x y /= 0 ]
04:21:37 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
04:21:38 <soupdragon> SuperMario
04:21:54 <yitz> > [ x | x <- [1..], and [x `mod` y /= 0 | y <- [2..x`div`2]]]
04:21:54 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
04:22:06 <yitz> SuperMario: something like that?
04:22:33 <SuperMario> yea
04:22:34 <SuperMario> thanks
04:22:45 <yitz> SuperMario: 'and' applied to a list of Bool returns True if everything is True in the list.
04:23:56 <SuperMario> i thought [ x ' mod y /=0 | y <-[2...x 'div' 2 ]] is a set
04:24:08 <SuperMario> how could it be a part of a boolean connective
04:24:08 <yitz> SuperMario: yeah, it's a list.
04:24:17 <yitz> @type and
04:24:18 <lambdabot> [Bool] -> Bool
04:24:38 <yitz> SuperMario: the binary 'and' operator is &&
04:24:44 <yitz> > True && False
04:24:45 <lambdabot>   False
04:25:16 <Twey> and = foldr (&&) True
04:25:21 <yitz> SuperMario: same thing for 'or' and ||
04:25:49 <SuperMario> ok
04:25:56 <yitz> SuperMario: there are also 'any' and 'all', very useful
04:25:58 <yitz> @type any
04:25:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:26:00 <SuperMario> but then and returns true ....why doesnt it output true
04:26:51 <yitz> SuperMario: a boolean expression in a list comprehension just tells whether or not to include this item in the result
04:27:32 <SuperMario> so everyting between the commas must be true and a boolean expression for it to be included
04:28:10 <yitz> SuperMario: so there are basically three things you can do - iterate over items from a list, select which to include, and bind values to local variables using 'let'.
04:28:35 <om-foxy> who maintains the hackage scripts that get run on uploaded packages?
04:28:40 <SuperMario> ok
04:31:58 <SuperMario> im going to bed thanks for the help
04:32:17 <blackh> If I've got a pair of functions (a -> b, b -> a) which are inverses, is there some bit of category-extras funkiness to encapsulate this idea?
04:32:39 <soupdragon> yes
04:33:05 <blackh> That's good news. Can you point me in the right general direction?
04:35:22 <blackh> Basically all I really need is the ability to carry the two functions round as one unit, and use it backwards or forwards, but I would like to take a look at any related useful stuff or theory.
04:36:15 <xenoblitz> i don't think its possible but I'm going to ask just in case, is possible to show a variable's name directly from it? sort of like let a = 5 in (name a ++ " " ++ show a) would output a string "a = 5", my guess IO is required to even attempt this...
04:36:47 <Botje> it's trivial with macros
04:36:54 <soupdragon> yes but you have to call it like this:  name "a"
04:37:02 <Botje> and probably with TH as well
04:37:15 <illissius`> Botje: wait. there's macros separately from TH?
04:37:56 <xenoblitz> soupdragon: I wish to derive the name directly by passing the function itself
04:38:00 <Botje> with cpp, yes
04:38:08 <illissius`> oh, i see
04:38:10 <xenoblitz> Botje: any simple example I can start with?
04:38:56 <soupdragon> That breaks alpha-conversion
04:39:00 <soupdragon> do you know lambda calculus?
04:39:43 <ksf> .oO( what I want is a non-overlapping segment tree )
04:39:56 <ksf> gotta get those terms right or google will return bunk
04:40:17 <illissius`> inspect :: Name -> Q Exp; inspect var = [| $(nameBase var) ++ " = " ++ show $var |] and then you use it like putStrLn $(inspect 'foo)
04:40:20 <xenoblitz> soupdragon: a little and i know its not really possible without something besides something on top of haskell, was wondering if its possible or if there is an example somewhere of this
04:40:22 <illissius`> I think -- didn't test it
04:40:42 <soupdragon> you mean a source code pre-processor
04:40:59 <xenoblitz> illissuis' thanks I'll try using it
04:41:08 <xenoblitz> soupdragon: I guess yeah it would have to be something like that
04:41:11 <illissius`> xenoblitz: you need to put it in a separate module
04:41:15 <ksf> great. all that wikipedia references is a print book.
04:41:20 <EvilMachine> *woohooo!!* mind-bogginling code, you work! and you are short too! i love you, mind-boggling code! i'll never leave you again!
04:41:26 <illissius`> with {-# LANGUAGE TemplateHaskell #-} and import Language.Haskell.TH
04:41:26 <ksf> 8 references to different pages of it
04:41:31 <soupdragon> C preprocessor can do something called pasting - do you know C?
04:41:47 <illissius`> you need the language pragma in the module where you use it as well
04:41:47 <xenoblitz> illissuis'; thanks load I'll give it a shot
04:41:56 <soupdragon> someone is leading you astray
04:42:03 <ksf> xenoblitz, nope.
04:42:16 <xenoblitz> ?
04:42:16 <ksf> ...not even with TH
04:42:23 <xenoblitz> so its not possible?
04:42:37 <ksf> the data structures just don't carry the name of the binding they're in.
04:42:55 <EvilMachine> hey, by the way: i noticed that I often, when comparing values, where one value is wrapped in a type constructor, and the other isnt, I always have to wrap it, rather than unwrap the other. what am I doing wrong?
04:42:58 <ksf> er wait.
04:43:15 <ksf> if you quote the whole binding it works.
04:43:26 <EvilMachine> (i mean that in those cases, pattern matching seems to not be possible to use)
04:43:59 <ksf> but if you just want to get stuff done right now, I'd recommend -XCPP
04:44:15 <xenoblitz> wait let me explain
04:44:24 <xenoblitz> I wrote a simple language embedded in haskell
04:44:25 <ksf> and if you want to have a middle ground, there's a package called MonadLoc which might work for you.
04:44:32 <xenoblitz> and am writing a pretty printer for it
04:44:46 <EvilMachine> i would like to do val `elem` listOfUnwrappedValues, rather than Wrapper val `elem` listOfWrappedValues...
04:44:48 <xenoblitz> sometimes I make use of haskell functions as part of my language
04:44:56 <xenoblitz> in the sense
04:45:09 <xenoblitz> they act as predicates for me on the state my language works on
04:45:10 <ksf> most haskell functions don't even have names
04:45:30 <ksf> ...you want to read up on shallow vs. deep embedding
04:45:30 <xenoblitz> in the pretty printer i just wish I can somehow show the function name by its variable if its remotely possible
04:45:38 <xenoblitz> i am using deep embedding ksf
04:45:43 <soupdragon> I already showed you how to do that dude
04:46:09 <xenoblitz> soupdragon: you mean using C?
04:46:12 <soupdragon> no
04:46:55 <xenoblitz> soupdragon: pasting then>
04:46:56 <xenoblitz> ?
04:46:58 <ksf> the trick is to parse the haskell and transform every binding into a binding that carries an annotation inside your dsl
04:47:22 <soupdragon> just use quotation: Instead of writing  name a,  you write  name "a"
04:47:32 <illissius`> xenoblitz: I'm not sure whether this does what you want but at any rate here's the version which actually works: inspect :: Name -> Q Exp; inspect var = [| $(stringE $ nameBase var) ++ " = " ++ show $(varE var) |]
04:47:50 <xenoblitz> illissius': will give it a shot
04:47:59 <xenoblitz> soupdragon: you mean passing the name itself
04:48:05 <soupdragon> This is an important technique, you can read SICP to learn about this
04:48:08 <ksf> both haskell-src-exts and th should be able to do that for you
04:48:57 <ksf> ...but you won't get around parsing the whole thing at compile time, outputting it again and then finally compiling it.
04:49:04 <xenoblitz> soupdragon: isn't "a" a simple string there... in my case I am pattern matching against a constructor which has a function as a parameter, I can't pattern match on it 
04:49:40 <xenoblitz> soupdragon: I will lookup SICP
04:50:13 <soupdragon> I don't think this has anything to do with pattern matching
04:50:33 <yitz> soupdragon: SICP is about scheme
04:50:48 <xenoblitz> soupdragon: I am deeply embedding the language
04:50:58 <soupdragon> as a GADT?
04:51:28 <xenoblitz> so I have something of this sort Prog = Check pred where pred is a function over my state so State -> Bool
04:51:54 <xenoblitz> while pretty printing I would like to show the predicate name if possible, was wondering how feasible it is or if I will just resort to outputting "<predicate>"
04:52:15 <soupdragon> Change State -> Bool to (Name, State -> Bool)
04:52:18 <soupdragon> where type Name = String
04:52:35 <xenoblitz> soupdragon: yeah I was thinking of doing that, annotating the function with a name
04:52:54 <xenoblitz> soupdragon: I guess its the simplest solution although I don't like it :P
04:53:30 <xenoblitz> the reason being the person using the dsl now has to input the function name as well
04:54:22 <ksf> xenoblitz, I have the feeling that you're procrastinating by premature perfecting.
04:54:34 <soupdragon> but xenoblitz, is that not everything a programmer does?
04:54:40 <ksf> always remember that termination of software design is undecidable.
04:54:47 <soupdragon> When I write a program all I am really doing is naming things
04:55:12 <soupdragon> You're saying it like it's a hassle one would rather avoid, but I think it it everything
04:55:33 <xenoblitz> ksf: I guess you are right, just that my work is technically seeing how feasible haskell is for embedding, so I'm kinda stretching to see how much it is
04:55:54 <ksf> it could be better, but it could be waaaay worse.
04:56:00 <soupdragon> how could it be better?
04:56:09 <xenoblitz> oh i can think of many ways...
04:56:11 <ksf> that is, nothing you couldn't fix with some th/preprpocessing and data-reify
04:56:50 <xenoblitz> my thesis is about how feasible it is to make a game scripting language inside of haskell
04:57:05 <xenoblitz> a script writer wouldn't like to have to annotate everything manually
04:57:10 <ksf> soupdragon, haskell could have a reify primitive that captures bindings alongside with source.
04:57:17 <soupdragon> I think you either implement a script language interpreter or you program in haskell
04:57:45 <soupdragon> trying to make a distinction about embedding a language inside haskell and scripting in there.. it's just silly - that is standard haskell programming practices
04:57:46 <xenoblitz> soupdragon: I would agree but my work is whether its feasible or not
04:57:50 <xenoblitz> to use dsels
04:57:56 <xenoblitz> so it beats the purpose of it if i do :P
04:58:15 <ksf> ...that is, for every binding, generate a graph edge/node, even if it doesn't happen to be cyclic
04:58:34 <soupdragon> ksf, oh yeah I've seen parser combinator libraries crash because they tried to do that with unsafe functions
04:58:38 <xenoblitz> anyway thanks for the input guys
04:58:51 <ksf> soupdragon, tell me about it.
04:59:17 <soupdragon> I find it hilarious someone would go to the trouble of learning haskell just to pull out stuff like unsafePerformIO
04:59:22 <ksf> well, data-reify itself is reasonably pure, but managing a typed graph in haskell is its own can of worms
04:59:32 <soupdragon> it's like gee.. if you were happy programming in C why didn't you just stick with it?
04:59:47 <ksf> I ended up deciding agoinst typeable because I didn't want to infect everything with typeable contexts.
05:00:00 <ksf> ...and in principle, those unsafeCoerces should be safe.
05:00:23 <soupdragon> sometimes you can use GADTs to get rid of the need to coerce
05:00:33 <soupdragon> of course it can take a bit of puzzling
05:00:36 <ksf> that is, if I get a segfault, my graph is bunk, anyway.
05:01:04 <ksf> I don't think so. well, at least I don't want to think about it.
05:01:20 <ksf> after transformation all the types would have to be re-unified
05:02:10 <ksf> as it's all about re-ordering the effects of an applicative without changing the semantics
05:03:59 <ksf> sometimes I think I should get rid of open recursion alltogether by constructing inside a monad, the parser is meant to be used with RFC-like grammars anyway, and they (at least newer ones) seem to be kleene algebras, already.
05:06:25 <Nip8888> hi, how do i setup Leksah without going online?
05:06:49 <ksf> it wants to go online?!
05:07:23 <Nip8888> i use comodo to block its internet connection. and it won't load.
05:07:53 <Nip8888> i'm sure it was installed successfully.
05:08:10 <ksf> does comodo tell you what it wants to access?
05:08:16 <Nip8888> yes
05:08:57 <ksf> hmmm it could be that it's waiting for a tcp timeout
05:09:35 <ksf> that is, in the no-net case it would detect having no net right away, but some firewalls just blackhole everything and apps are left waiting
05:10:02 <Nip8888> 127.0.0.1 port 26411
05:10:13 <ksf> oh, it wants to connect to itself
05:10:28 <ksf> 127.0.0.1 isn't on the internet, that's your own machine.
05:10:46 <Nip8888> but the leksah server tries to access DNS/RPC client service
05:10:50 <ksf> it recently changed from being only a gui to being split into gui in server
05:11:44 <aristid> leksah... server? oO
05:12:00 <aristid> it's an IDE, right? why is there a server?
05:12:14 * ksf would guesstimate that it's trying to contact hackage.haskell.org to check the timestamp on the package list
05:12:20 <Jafet> To read mail!
05:12:46 <ksf> aristid, model/view?
05:12:57 <aristid> ksf: ?
05:13:12 <ksf> also, not all windowing systems are network transparent
05:13:25 <aristid> leksah is network transparent?
05:13:37 <ksf> I'd suppose so if it's split into server and gui
05:13:53 <ksf> a hell a lot of programs and frameworks are.
05:14:54 <Nip8888> leksah-server.exe and leksah.exe?
05:14:54 <cheater99> hi
05:14:54 <ksf> Nip8888, yes
05:14:55 <aristid> ksf: and for some programs it's justified. heck, even emacs has a server, but it's optional and local
05:14:56 <orlandu63> does foldl mean fold to the left or fold from the left?
05:14:57 <ksf> an additional benefit is that you don't have to have gtk and everything installed on the remote box.
05:15:14 <ksf> @src foldl
05:15:14 <lambdabot> foldl f z []     = z
05:15:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:15:27 <aristid> http://cale.yi.org/index.php/Fold_Diagrams
05:15:31 <soupdragon> fold left and fold right make no sense
05:15:38 <soupdragon> they should not be called that
05:15:46 <orlandu63> more like fold inner or fold outer?
05:15:51 <aristid> soupdragon: if you look at the diagrams, it makes sense
05:16:02 <ksf> it's also the order of composition.
05:16:15 <soupdragon> I don't agree
05:16:21 <ksf> foldl does [1,2] -> 1 + 2, foldr 2 + 1
05:16:43 <ksf> yes, that's dependent on the direction you write lists in...
05:17:05 <m3ga> soupdragon: if you look at the last two arguments, foldl accumulates the left argument while fold right accumulates the right argument.
05:17:49 <Nip8888> if i disconnect from internet, will it cripple leksah in anyway?
05:18:02 <cheater99> ksf: is there something like @src in ghci?
05:18:10 <ksf> nope
05:18:11 <soupdragon> m3ga, you can just as easily flip f
05:18:14 <ksf> it's a lambdabot feature
05:18:20 <ksf> ...and they're all compiled by hand
05:18:31 <cheater99> what does that mean?
05:18:35 <ksf> you can find the source to virtually everything on hackage, though.
05:18:41 <cheater99> aha
05:18:42 <cheater99> neat
05:18:50 <ksf> cheater99, if you want lambdabot, you can install it locally.
05:19:06 <aristid> or you can open a query window with it
05:19:09 <zygoloid> soupdragon: foldl f associates f to the left. foldrf associates f to the right
05:19:12 <aristid> /query lambdabot
05:19:30 <Jafet> Nip, if you disable lo, I would guess yes
05:19:42 <npouillard> I wrote this function (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26423#a26423) and I don't get it fails say on toBoundedEnum 1 :: Bool
05:19:56 <npouillard> ... +why it ...
05:20:10 <soupdragon> zygoloid, oh yeah that works
05:20:27 <npouillard> I'm completely puzzled
05:20:33 <ksf> there seems to be some strange and extreme paranoia epedemic among windows users regarding networking
05:20:40 <exDM69> cheater99: GHCi on Acid (GoA) has many of lambdabot
05:20:43 <Nip8888> Jafet, what is 'lo'?
05:20:53 <exDM69> cheater99: many lambdabot features
05:20:54 <Jafet> The loopback device
05:20:56 <cheater99> exDM69: cool, where do i get it?
05:20:59 * cheater99 googles
05:21:02 <ksf> Nip8888, the loopback interface, in unix terms, that is, 127.0.0.1
05:21:09 <exDM69> cheater99: haskell wiki has installation instructions
05:21:31 <Nip8888> that means, i only need to enable access to 127.0.0.1?
05:21:49 <ksf> that's what it definetely needs.
05:21:58 <zygoloid> npouillard: what type do you think (maxBound `aTypeOf` x) will have? :)
05:22:16 <npouillard> the type of x
05:22:21 <zygoloid> which is Int
05:22:22 <ksf> if the rest isn't at least negotiable, I suggest you file a bug against leksah.
05:22:48 <npouillard> zygoloid: oops
05:23:00 <cheater99> exDM69: is it in general just like ghci with more, or does it usually take some considerable time for it to gain ghci's new features?
05:23:37 <zygoloid> > let toBoundedEnum x = r where r = toEnum (x `mod` (1+bnd)); bnd = fromEnum (maxBound `asTypeOf` r) in toBoundedEnum 1 :: Bool
05:23:38 <ksf> ghci has new features?
05:23:39 <lambdabot>   True
05:23:50 * npouillard switches to ScopedTypeVariables
05:23:53 <npouillard> zygoloid: yep
05:23:55 <ksf> it's been the same since at least 6.4
05:23:59 <zygoloid> npouillard: sounds like a good choice :)
05:24:36 <exDM69> cheater99: it's actually an addon to ghci, so it's not lagging behind if that's what you fear
05:25:09 <npouillard> zygoloid: thanks to help me see what was in front my eyes 
05:26:26 <npouillard> zygoloid: What do you think about the usefullness of this function BTW
05:27:08 <Nip8888> i am in leksah ide. how to i proceed to install wxHaskell package?
05:29:02 <Nip8888> can i access cabal thru leksah?
05:30:06 <Nip8888> do i have to access cabal thru WinGHCi only?
05:32:48 <Sadache> what is !ByteString
05:33:20 <zygoloid> npouillard: i think "toBoundedEnum :: (Enum a, Bounded a) => Int -> Maybe a" with Nothing if out of range would be more useful
05:33:27 <aristid> Sadache: maybe this? http://www.haskell.org/ghc/docs/6.10.3/html/users_guide/bang-patterns.html
05:35:14 <cheater99> exDM69: great
05:36:17 <Sadache> data Cookie = Cookie {
05:36:17 <Sadache>       -- | The name of the cookie.
05:36:17 <Sadache>       cookieName    :: !ByteString
05:36:52 <aristid> Sadache: that's a bang pattern, yeah.
05:37:15 <npouillard> zygoloid: OK, then I should call this one "modulo" something
05:37:35 <Nip8888> OK, got it. Thanks everyone.
05:38:17 <danharaj> 'bang pattern' sounds dirty
05:38:23 <Sadache> aristid: banf pattern in a type?
05:39:47 <aristid> Sadache: well, it's not a pattern match, but it's a bang :D
05:40:24 <Sadache> aristid: and what does that mean?
05:41:28 <zygoloid> Sadache: it means "strict"
05:44:16 <Sadache> so it is NOT the bang pattern
05:44:30 <StdDoubt> in order to do a "for cycle between two values (for instance 2..10)" in order to access the elements at those positions in a list  I have to use a function with an accumulator?
05:44:37 <Sadache> zygoloid: is it simply the name of the type or can I use it for !FOO
05:49:25 <Sadache> ?
05:50:25 <zygoloid> Sadache: it's not the name of a type, it's special syntax to denote a strict field
05:50:57 <Sadache> ok, thank you zygoloid 
05:54:45 <zygoloid> Sadache: for more information see the haskell'98 report, section 4.2.1, "Strictness Flags"
05:54:53 <xenoblitz> illissius`: the suggestion you gave almost works but i think that as someone said earlier nameBase is not enough, I might need to reify and I am a bit lost on how to use reify... any pointers anyone?
05:55:24 <zygoloid> xenoblitz: what's the problem?
05:56:15 <illissius`> xenoblitz: what's the problem specifically?
05:56:17 <xenoblitz> zygoloid: illissius` suggested using template haskell to find the show the name of a variable, the actual name
05:57:47 <xenoblitz> illissius`: unfortunately its taking the local name... in the sense that I am trying to obtain the name from data Prog = Check pred and instead of the original function name I am getting [red ( the local one)
05:57:49 <zygoloid> xenoblitz: you want to accomplish this without actually typing the name of the variable?
05:57:53 <xenoblitz> sorry pred
05:58:05 <xenoblitz> zygoloid: yes for pretty printing reasons
05:58:06 <illissius`> oh
05:58:21 <zygoloid> xenoblitz: how will the compiler know which variable you want the name of?
05:58:23 <illissius`> don't think there's anything you can do in that case :\ (with template haskell that is)
05:58:53 <illissius`> reify will give you information about the type and structure and such of the variable but not what names refer to it
05:59:21 <xenoblitz> ah ok then I can't do it I guess unless I use annotations (which I was trying to avoid) =/
05:59:36 <aavogt> put the code in a [| |], and then look at the Expr you get out of it?
06:00:09 <xenoblitz> aavogt: unfortunately that went right over my head as I don't know much TH =/
06:00:32 <zygoloid> xenoblitz: if you want an expression to refer to its own name, you could probably make something with CPP pretty easily
06:01:22 <xenoblitz> zygoloid: I never used CPP is it C++ or it stands for something else (probably, just unsure at this point)
06:01:28 <illissius`> c preprocessor
06:01:28 <xenoblitz> oh preprocessing
06:01:45 <illissius`> zygoloid: afaict he doesn't want the name, he wants the name it was under before it was passed to the function which calls the splice (correct me if I'm wrong!)
06:02:03 <xenoblitz> yeah the simples example is something of this form
06:02:16 <illissius`> which just seems impossible to me
06:02:25 <zygoloid> xenoblitz: you could pass 'x in. that way the TH can refer to both the name and its value
06:02:40 <xenoblitz> let a = 5 in print a ++ show " " + show a, returns "a = 5"
06:02:44 <aavogt> xenoblitz: well I don't understand your problem so I'm probably way off
06:03:17 <illissius`> xenoblitz: can't you manually inline the function everywhere? then one which uses the $(inspect etc)? then it'll use the right name
06:03:34 <aavogt> do what zygoloid says, it's easy to go from Name -> value, the other way around not so much
06:04:26 <xenoblitz> zygoloid: sorry I don't know how to do that =/ I never used TH before
06:04:55 <illissius`> xenoblitz: oh I think I know what you could do
06:05:35 <illissius`> or wait
06:05:46 <zygoloid> > let x = "Hello world" in $( (\n -> [| $( stringE $ show n ) ++ " = " ++ $( varE n ) |]) 'x )
06:05:48 <lambdabot>   <no location info>: parse error on input `$'
06:06:06 <illissius`> zygoloid: that's basically what i've given him already and it's not what he wants
06:06:24 <zygoloid> what's wrong with it?
06:06:24 <illissius`> xenoblitz: 'data Prog = Check pred' what's pred here? did you mean Pred?
06:06:38 <illissius`> zygoloid: [14:57:23] <xenoblitz> illissius`: unfortunately its taking the local name... in the sense that I am trying to obtain the name from data Prog = Check pred and instead of the original function name I am getting [red ( the local one)
06:06:49 <illissius`> where [red = pred
06:06:53 <xenoblitz> zygoloid: yeah that works but it works only locally... when i parse what illissius` just quoted it simply returns what i pattern matched against
06:07:02 <aristid> is it true that a haskell thread running a tight loop can block the light-weight threading system?
06:07:17 <xenoblitz> yes Pred... actuall Predicate = State -> Bool
06:07:21 <illissius`> ok
06:07:25 <illissius`> then what you can do is
06:07:41 <illissius`> data Prog = Check Pred String
06:07:58 <illissius`> but then have a TH function to actually construct them
06:08:03 <xenoblitz> and the String is the name right?
06:08:05 <illissius`> so you don't have to type the name twice
06:08:06 <illissius`> yes
06:08:46 <xenoblitz> so you are saying have a function called check :: String -> Prog which does the magic
06:09:01 <illissius`> well, Name -> Prog, but yes, exactly
06:09:07 <illissius`> or rather no
06:09:12 <illissius`> Name -> Q Exp
06:09:21 <illissius`> which when you splice it in gives you a Prog
06:09:31 <illissius`> (if I'm thinking straight which I may not be.)
06:09:52 <xenoblitz> yes i think that could work if i figure out how to write in TH hehe
06:10:33 <xenoblitz> all I need is a function which given a function name actually generates the code Predicate name "name"
06:10:38 <xenoblitz> sorry
06:10:43 <xenoblitz> Check name "name"
06:10:53 <xenoblitz> where "name" is function's name
06:11:17 <xenoblitz> am I understanding you?
06:11:17 <illissius`> something like mkProg name = [| Check $(varE name) $(stringE $ nameBase name) |], and then someprog = $(mkProg 'pred)
06:11:22 <illissius`> right
06:11:57 <xenoblitz> let me try it out
06:12:13 <zygoloid> another option might be to register all of your functions up-front in a StablePtr -> name map, then use that to find which one you have
06:12:18 <zygoloid> but eww...
06:14:12 <xenoblitz> the funny part is... how will it know what $(varE name) actually refers to if the constructor is in a different module?
06:15:33 <illissius`> I think that works out, TH is designed so that it does -- at least, if I'm understanding correctly
06:15:41 <xenoblitz> ok lets see
06:16:00 <Palmik> Hi guys. I have probably a trivial question. I have this function which works fine http://codepad.org/1SGGdhMO but I would like to solve some exceptions as showed here http://codepad.org/P6lFULSM which does not work. The question is -- why does not it work? :)
06:19:03 <Palmik> oh, and this is the error http://codepad.org/qNJMgLqm
06:19:41 <Palmik> it expects list of lists, I do not know why exactly :/
06:22:00 <xenoblitz> illissius`: is someprog the part which actually generates the Check object?
06:22:33 <illissius`> someprog *is* the Prog
06:23:07 <illissius`> pred is the function/predicate which goes into it
06:25:23 <xenoblitz> illissius`: I wrote it like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26425#a26425 but got an error, see paste
06:25:48 <illissius`> right
06:25:49 <xenoblitz> illissius`: oh nevermind
06:25:59 <xenoblitz> illissius`: need to define it elsewhere
06:26:02 <illissius`> right
06:26:12 <illissius`> TH functions need to be in a different module from where they're used
06:26:31 <illissius`> ...but you'll have to import Prog/Check into that module which may be annoying
06:26:47 <illissius`> (in the case that it results in recursive imports)
06:29:11 <xenoblitz> illissius`: yeah I was worrying about that
06:29:33 <xenoblitz> illissius`: I might need to create another module just for that ... which is really ugly... but what can you do
06:30:39 <Gracenotes> > sort [1..10000]
06:30:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:30:47 <illissius`> one way is to have the module which defines Prog (but doesn't use mkProg), import and reexport it in the TH module, and then the TH module is what everything else imports
06:30:51 <Gracenotes> > length $ sort [1..10000]
06:30:52 <lambdabot>   10000
06:31:55 <illissius`> > 10000
06:31:57 <lambdabot>   10000
06:31:59 <illissius`> !
06:32:00 <Gracenotes> hm.. I think Data.List source has statistics on how sort does for already-sorted lists... /look/
06:34:26 <Gracenotes> ouch - the old quicksort algorithm handled sorted lists of length 100000 in 5831.47 seconds of user time :/
06:34:42 <Gracenotes> but the newer mergesort impl only took 2.23
06:34:50 <xenoblitz> meta-programming is messy... I think that I'll stick with the user-has-to-help-himself approach
06:35:06 <xenoblitz> i mean it probably works but it really messes up things
06:35:44 <soupdragon> metaprogramming is not messy
06:36:01 <illissius`> template haskell is messy :)
06:36:44 <tromp_> can't argue with that
06:37:50 <xenoblitz> when you get cyclic dependencies between modules its just not worth it anymore imo
06:40:26 <ksf> th could definitely use less restrictive stage management
06:40:48 <ksf> ...and less bugs like not being able to quote classes etc.
06:40:50 <edwardk> ksf: its tricky. you need a lot of info to provide splices in types
06:41:25 <ksf> I was rather thinking along the lines of "just compile those two modules five times if you have to"
06:41:44 <edwardk> the problem is what is the fixed point?
06:41:51 <edwardk> when do you know to stop
06:42:21 <illissius`> call 'fix' on it :-)
06:42:23 <edwardk> in retrospect perhaps using a strongly typed macro system wasn't such a good idea for haskell, but its the devil we have ;)
06:42:42 <ksf> I don't expect magic, just something that doesn't make me use 1000 modules
06:42:47 <aristid> edwardk: a weakly typed macro system would be better?
06:42:57 <FunctorSalad_> hmm I don't see where this becomes recursive?
06:42:59 <ksf> that is, if you ask me cycles can simply be forbidden.
06:43:02 <FunctorSalad_> (splicing in types)
06:43:29 <FunctorSalad_> yeah I think most users haven't ever even thought of the cases that make splicing so hard apparently ;)
06:43:44 <ksf> I think it's a good idea in general, but it feels like a hack on top of a language
06:43:49 <FunctorSalad_> most would just like a slightly more syntactically-knowledgable CPP I gues
06:43:52 <FunctorSalad_> or maybe that's just me
06:43:54 <edwardk_> FunctorSalad_: you need to evaluate the file far enough to know what the types are in your quasiquotations, but you also need to be able to add types to the environment through your declaration splices.
06:44:23 <edwardk_> FunctorSalad_: so in the end, template haskell and type expansion are somewhat incestuous
06:44:36 <ksf> compile it first ignoring everything containing splices, then compile it again with one-level splices, then two etc.?
06:44:44 <FunctorSalad_> s/gues/\0s/
06:45:00 <edwardk_> ksf: the problem being that a splice can refer to what is in scope, so you can quickly embed a barbershop paradox
06:45:20 <FunctorSalad_> why would you want to typecheck or namecheck [| ... |] (does that count as QQ?) at all?
06:45:27 <FunctorSalad_> just check the final result...
06:45:33 <ksf> I'm not talking about lifting the stage restrictions, just allowing multiple stages to co-exist in one file
06:46:14 <edwardk_> aristid: yes ;)
06:46:24 <ksf> I think the grammar is unambiguous enough to do that
06:46:53 <FunctorSalad_> the user can already produce arbitrarily nonsensical code using the AST directly... why not with this more convenient AST syntax?
06:47:05 <FunctorSalad_> (that's what [| |] is in my book)
06:47:22 <edwardk_> FunctorSalad_: actually i agree with you regarding he fact that typechecking quasiquotation is sometimes pretty annoying
06:47:32 <ksf> ...there's definitely a case to be made for an ast-syntax that doesn't distinguish between e.g. operators and functions
06:47:37 <edwardk_> i've had to rip it out of code wholesale as a result
06:47:45 <ksf> lisp's simplicity is its great strength in metaprogramming
06:47:49 <FunctorSalad_> ksf: that's beyond what I was thinking of :)
06:48:00 <FunctorSalad_> I'd leave the parser alone
06:48:30 <StdDoubt> how to do sublist?
06:48:37 <edwardk_> StdDoubt: sublist?
06:48:41 <ksf> well, just transformation stages (a + b) * c -> ((*) c ((+) a b)))
06:49:08 <FunctorSalad_> StdDoubt: take bar . drop foo
06:49:26 <edwardk_> ksf: heh well, that is largely how the macro system i have for kata has been working... the problem i i've been chewing on it for a bit over a year now to little avail ;)
06:49:28 <StdDoubt> for instance if you have a list o elements and you want a new list containing the elements from position x to y in the original list
06:49:36 <FunctorSalad_> gives you the [foo,foo+bar[ sublist
06:49:59 <edwardk_> StdDoubt: take n . drop m  -- will give you elements from m to m + n in the list
06:50:19 <edwardk_> +-1 as i didn't think about your bounds too hard ;)
06:50:30 <edwardk_> what FunctorSalad_ said ;)
06:50:32 <StdDoubt> thanks :D
06:50:39 <ksf> haskell programmers can't be bothered to think about off-by-one.
06:51:33 <FunctorSalad_> that's why sublists should always use the lower-inclusive, upper-exclusive convention... (which is what take n . drop m does, if we are zero-based)
06:51:38 <ksf> did I tell you guys how I wrote a binary lookup on an array after one and a half year of imperative abstinece and produced 5 off-by-one errors in three lines?
06:51:57 <Botje> ksf: impressive
06:52:01 <illissius`> what was the original reason for indexing arrays from 0? for the +1 element you can index with one byte? :\
06:52:12 <ksf> FunctorSalad_, now please don't allow [..) , that messes up any sane parsing.
06:52:15 <opqdonut> illissius`: arithmetic
06:52:19 <Botje> illissius`: so it's isomorphic to pointers+offsets
06:52:22 <opqdonut> you have a pointer to the start of the table
06:52:28 <opqdonut> offset 0 is the first element
06:52:33 <illissius`> oh
06:52:35 <ksf> illissius`, because it makes more sense.
06:52:37 <FunctorSalad_> ksf: oh, that one defies it, yes
06:52:40 <ksf> it's cardinal, not ordinal.
06:52:43 <FunctorSalad_> (the existing enumFromTo)
06:53:08 <FunctorSalad_> (agree about the parsing... someone think of the lowlevel tools)
06:54:05 <illissius`> ksf: how? I've never looked at a container and thought "give me the 0th" element... more frequently "give me the Nth element... oh wait, N-1, because the stupid thing starts from zero"
06:54:14 <ksf> illissius`, cardinal numbers are quite new, they weren't know before the 0. that's why we don't have a year 0 but go from 1bc directly to 1ad
06:54:15 * illissius` looks up cardinal and ordinal
06:54:45 <ksf> the problem arises when you include negative numbers.
06:55:06 <ksf> that is, taking 6 beers out of a sixpack == 0 left.
06:55:13 <Palmik> Hmm, could someone please explain me why the latter does not work? http://codepad.org/v0ytePmp
06:55:28 <illissius`> conveniently, containers don't have negative indices (unless you go from the end, but you can just abstain from doing that)
06:55:47 <ksf> Palmik, because [] is a list and head xs is a single element.
06:55:59 <Palmik> Aah, you are right :)
06:56:36 <Botje> Palmik: you should avoid taking the length of a list if you can, it's really costly
06:57:06 <Palmik> byt :type error gives me that it is [Char] so it's not the same type as well?
06:57:24 <Palmik> *but
06:57:48 <Palmik> Botje, ok... will remember that :)
06:58:12 <edwardk_> Botje: clearly we need skew binary lists in the prelude ;)
06:58:39 <ksf> Palmik, lastButOne x:y:[] = x; lastButOne x:xs = lastButOne xs
06:59:19 <Palmik> ksf, I'm not that far yet :D
06:59:19 <ksf> but...but...
06:59:19 <ksf> it's simpler!
06:59:48 <Botje> Palmik: error has type String -> a
06:59:54 <Palmik> I was wrong, error takes [Char] and returns a. How is it possible that I can use it in the then branch when it does not match the type with else branch?
06:59:57 <Botje> e.g. any type.
07:00:00 <Palmik> I see
07:00:30 <ksf> oh, the joys of non-totality
07:00:54 <ksf> one thing you can do is lastButOne :: [a] -> Maybe a
07:01:51 <ksf> another is to keep track of the list length on the type level.
07:01:59 <Palmik> Sure I could do that if I understood what it was :D But thanks guys :)
07:02:18 <ksf> which should'nt cost much more than five milliolegs.
07:16:34 <edwardk_> ksf: man, a millioleg doesn't go as far as it used to ;)
07:17:31 <ksf> edwardk_, it's a log scale.
07:28:04 <shepheb> so Jinjing Wang removed all his Haskell libraries from Github. he wrote a ppm library that desperately needs to use Bytestrings, but I can't just submit a patch. I ca edit the source code taken from Hackage, but how do I upload the new version without giving it a new name?
07:28:28 <shepheb> or did somebody else rescue the repos
07:28:55 <ksf> ppm?
07:29:11 <shepheb> dead-simple image format
07:29:20 <ksf> ah, yes.
07:29:27 <ksf> I think only admins can do that
07:30:10 <shepheb> well, so I expect. I'm mostly inquiring whether this has happened already to one of his other libraries so I can do the same thing
07:30:12 <ksf> did you use lazy bytestrings or strict ones and return a continuation?
07:30:22 <shepheb> I haven't done it yet
07:30:43 <ksf> ...do the latter and be cheered at by everyone who uses iteratees.
07:33:08 <StdDoubt> how to count the number of occurrences of an element in a list? use an accumulator?
07:33:25 <StdDoubt> count and remove the counted elements
07:33:41 <ksf> filter and length?
07:33:47 <shepheb> I would use length . filter (==x)
07:34:15 <ksf> that keeps the counted elements, though.
07:34:35 <Gracenotes> oh dear. Just got 97 "Not in scope" errors. I guess that's what you get from forgetting to add imports before compiling your 200-line module
07:34:40 <shepheb> to count occurrences of everything, perhaps map length . group . sort
07:34:54 <shepheb> er, well, not quite
07:35:02 <StdDoubt> it has to be done in two passages right? first transverse the list to count the elements and afterwards remove them
07:35:04 <StdDoubt> ?
07:35:05 <shepheb> map (head &&& length)
07:35:31 <shepheb> StdDoubt: partition (==x)
07:35:37 <Gracenotes> effectively, you do pass through the list twice. but it's a bit more complicated than that
07:36:04 <Axman6> > let f y (x:xs) = if x == y then first (+1) $  f y xs else second (x:) $ f y xs; f _ [] = (0,[]) in f 4 [2,3,4,5,4,5,7,3,2,4,5,2,45]
07:36:05 <lambdabot>   (3,[2,3,5,5,7,3,2,5,2,45])
07:36:07 <Gracenotes> at least, if you use the 'group' approach, you do that
07:36:50 <ksf> @pl let f y (x:xs) = if x == y then first (+1) $  f y xs else second (x:) $ f y xs; f _ [] = (0,[]
07:36:51 <lambdabot> (line 1, column 85):
07:36:51 <lambdabot> unexpected "["
07:36:51 <lambdabot> expecting pattern or "="
07:36:58 <ksf> @pl let f y (x:xs) = if x == y then first (+1) $  f y xs else second (x:) $ f y xs; f _ [] = (0,[])
07:36:59 <lambdabot> (line 1, column 85):
07:36:59 <lambdabot> unexpected "["
07:36:59 <lambdabot> expecting pattern or "="
07:37:10 <ksf> @pl \f y (x:xs) ->  if x == y then first (+1) $  f y xs else second (x:) $ f y xs; f _ [] = (0,[])
07:37:11 <lambdabot> (line 1, column 78):
07:37:11 <lambdabot> unexpected ";"
07:37:11 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
07:37:19 <Axman6> StdDoubt: firstly, there is no real sense of ordering in functional programs, and secondly, i just showed how to do it in one pass :)
07:37:52 <ksf> argh I don't have the nerve to squeeze that into @pl syntax right now
07:38:06 <edwardk_> shepheb: the 'nice' way to do it is to download the version from hackage and upload another version to hackage under a different name after patching it
07:38:27 <edwardk_> shepheb: you can keep the module names, etc.
07:38:33 <edwardk_> but just change the package name
07:39:11 <ksf> do we have a standard procedure to establish that a package has been orphaned and thus is available for foster parents?
07:39:12 <StdDoubt> Thanks :D
07:39:14 <edwardk_> the even nicer way is to talk to the original author and ask to take over maintainership
07:39:28 <sclv> shepheb: exactly. my first step would be to email him.
07:39:28 <edwardk_> ksf: 'talking to the author'
07:40:17 <Gracenotes> shepheb: is he actively doing maintenance on github for it?
07:40:39 <zygoloid> > (\x -> second length . partition (==x)) 'l' "Hello world"
07:40:41 <lambdabot>   ("lll",8)
07:40:42 <Gracenotes> oh wait, removed from github? :/
07:40:47 <zygoloid> > (\x -> second length . partition (/=x)) 'l' "Hello world"
07:40:48 <lambdabot>   ("Heo word",3)
07:41:09 <Axman6> StdDoubt: i'm going to go out on a limb and say that you don't understand what that code does, and it's for homework right? 
07:42:09 <Gracenotes> the fun part about partition is that both parts of the tuple are being unwound at the same time... so by evaluating the length part, you also evaluate the removed part
07:42:37 <zygoloid> yeah. there's also a risk of building a massive thunk for the length in this case :-/
07:42:51 <Gracenotes> the downside is, you can't evaluate it as you process it.. so it is nearly two passes
07:43:59 <StdDoubt> Axman6: wrong is not for homework... I decided to learn Haskell after have been learning OCaml for one semester
07:44:22 <zygoloid> > (\x -> foldr (\c (cs,!n) -> if c == x then (cs,n+1) else (c:cs,n)) ([],0)) 'l' "Hello world"
07:44:23 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
07:44:38 <zygoloid> > (\x -> foldr (\c (cs,n) -> n `seq` if c == x then (cs,n+1) else (c:cs,n)) ([],0)) 'l' "Hello world"
07:44:40 <lambdabot>   ("Heo word",3)
07:44:52 <zygoloid> ^^ fixed the space leak. :)
07:45:04 <Axman6> > let f y (x:xs) = if x == y then first (+1) $  f y xs else second (x:) $ f y xs; f _ [] = (0,[]) in f 'l' "Hello world"
07:45:04 <StdDoubt> Axman6: I am still struggling with some concepts like monads but eventually I'll get them in due time
07:45:05 <lambdabot>   (3,"Heo word")
07:45:09 <Gracenotes> nonetheless there are many solutions :) all of them are correct, but they perform differently
07:46:11 <zygoloid> > (const (const (3, "Heo word"))) 'l' "Hello world"
07:46:12 <lambdabot>   (3,"Heo word")
07:46:24 <Gracenotes> it's often the case that laziness picks the optimal order for incrementally evaluating, say, a list of values. but sometimes it isn't fine-grained enough...
07:48:21 <edwardk_> Gracenotes: well, here the trade off is that you need to hold onto the intermediate structure. laziness chooses to hold onto the intermediate values, which is what screws you up.
07:49:03 <edwardk_> clearly you should encode each problem into a monoid and then foldMap over in a single pass ;)
07:49:53 <edwardk_> zygoloid: the space leak is definitely fixed by that one, but I worry you may have partially evaluated too far for the core observation to be obvious to the lay person ;)
07:52:57 <ManateeLazyCat> @users
07:52:57 <lambdabot> Unknown command, try @list
07:53:03 <ManateeLazyCat> @list
07:53:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:53:33 <ManateeLazyCat> @user
07:53:33 <lambdabot> Unknown command, try @list
08:02:01 <ManateeLazyCat> http://www.xiami.com/song/play?ids=/song/playlist/id/1275873/type/3
08:02:49 * ManateeLazyCat Some Chinese songs...
08:03:04 <k23z__> ManateeLazyCat: how is manatee ?
08:03:20 <ManateeLazyCat> k23z__: Not bad, still in testing... :)
08:03:20 <k23z__> ManateeLazyCat: is she chaineeze ?
08:03:41 <ManateeLazyCat> k23z__: You mean my LIE project or my girl? ;-)
08:03:56 <ManateeLazyCat> k23z__: Yes, manatee is Chinese girl. :)
08:04:02 <k23z__> the chick
08:04:48 <ManateeLazyCat> k23z__: What's the chaineeze?
08:05:04 <k23z__> ManateeLazyCat: it's leet spelling of Chinese :)
08:05:54 <ManateeLazyCat> k23z__: Hehe, :)
08:11:47 * hackagebot hakyll 2.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.2 (JasperVanDerJeugt)
08:18:02 <b52> http://soundcloud.com/dotb52/cowboy-troy-buffalo-stampede-ft-m-shadows-of-avenged-sevenfold
08:22:38 <u_quark> are there any 'just-another-haskell-hacker' programs out there ?
08:24:26 <shepheb> what's the 
08:24:55 <Axman6> u_quark: huh?
08:25:31 <shepheb> I've never really worked with Bytestrings before, what's the best way to build a Bytestring from lots of little pieces taken with minor processing from a list?
08:26:45 <u_quark> like perl hackers have 'Just another Perl hacker' signatures... and the idea is adopted in other languages too
08:27:49 <Jafet> Haskell has hackers? Must have missed the memo
08:28:03 <danharaj> Haskers.
08:28:17 <u_quark> lol
08:29:13 <FunctorSalad_> Jafet: what's your definition of it then?
08:29:51 <Axman6> u_quark: perl hackers like making ugly unreadable code to show off. haskell hackers like making clear, easy to use code to show off ;)
08:29:57 <Jafet> What if I told you it's not recursively enumerable?
08:30:23 <Jafet> Axman6, despite most examples of > in this channel to the contrary
08:30:25 <u_quark> *attempting to start yet another flame* FunctorSalad_: mathematicians
08:30:28 <Jafet> I enjoy your optimism
08:30:48 <soupdragon> There are 3 kinds of mathematicians: Ones that are good at arithmetic and ones that aren't.
08:30:57 <FunctorSalad_> u_quark: there's an overlap
08:31:06 <FunctorSalad_> Jafet: what? the definition?
08:31:23 <Axman6> Jafet: well, of course, lambdabot imposes restrictions on acheiving those goals
08:31:52 <u_quark> Axman6: accepted, but still, to many plain old haskell is obfuscated ... so ... there is no need for extra obfuscation
08:33:41 <shepheb> "To those who don't know it, foo is obfuscated/hard to read" is true of pretty much all lnaguages, natural, constructed or programming.
08:34:06 <soupdragon> except XML
08:34:24 <danharaj> Someone needs to read more Nabokov
08:34:28 <soupdragon> it only makes sense to people who DON'T use it
08:34:59 <shepheb> soupdragon: a data format that can be tortured into carrying programming semantics
08:35:39 <shepheb> anyway, building a Bytestring from a lot of small bits?
08:38:29 <shepheb> hmm I'll probably use Binary
08:48:58 * hackagebot agum 2.3 - Unification and Matching in an Abelian Group  http://hackage.haskell.org/package/agum-2.3 (JohnRamsdell)
08:50:01 * hackagebot cmu 1.3 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.3 (JohnRamsdell)
08:50:17 <jmcarthur> wha-?
08:50:37 <jmcarthur> oh, cool
08:51:28 <danharaj> lol gpl license
08:52:34 <HugoDaniel> Prelude> ^D^?^?
08:52:36 <HugoDaniel> how do i solve this ?
08:52:38 <HugoDaniel> :(
09:01:21 <gwern> HugoDaniel: huh?
09:03:11 <gwern> > sum [] / length []
09:03:12 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:03:12 <lambdabot>    arising from a use o...
09:04:00 <Jafet> The type system prevents division by zero!?
09:04:32 <Botje> > sum [] / genericLength []
09:04:33 <lambdabot>   NaN
09:06:15 <HugoDaniel> my ghci does not respond well to Ctrl-d or Ctrl-u or up and down arrow keys, and backspace...
09:06:17 <HugoDaniel> :(
09:06:21 <HugoDaniel> im using it in freebsd 7.2
09:14:03 <dkc> Hi .. simple question about haskellmode in vim.  How do I get the commands starting with underscores to work?  For me underscore just goes to the first word on the line
09:14:19 <dkc> (maybe it's really a vim question, but I figured someone here might know..)
09:14:42 <pastorn> HugoDaniel: installed from ports ?
09:15:59 <StdDoubt> how to do indicate a expression returns a list of tuples?
09:16:39 <soupdragon> you can do that with a type annotation
09:16:47 <pastorn> StdDoubt: f :: a -> b -> [(c,d)]
09:16:48 <u_quark> (expr :: [(type_left, type_right)])
09:17:05 <StdDoubt> for instance if we have 'resultList = f xtpo' that returns a list of tuples and we want to pass that result list to another function to process the tuples 
09:17:51 <pastorn> StdDoubt: does the 2nd function take a list of tuples as an argument?
09:18:04 <StdDoubt> yes
09:18:28 <StdDoubt> but I am getting this error  No instance for (Num [Char]) arising from a use of `processSolutionList'
09:18:32 <pastorn> iTakeTuples (iReturnTuples something)
09:18:48 <pastorn> StdDoubt: you might be using + instead of ++
09:19:32 <StdDoubt> can I paste here a short function (3 lines)?
09:19:59 <pastorn> StdDoubt: paste everything, so we can get the context here instead:
09:20:02 <pastorn> @hpaste
09:20:02 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:20:56 <StdDoubt> the page does not open
09:21:13 <pastorn> StdDoubt: use http://codepad.org then ;)
09:21:32 * ksf wants Eq on functions
09:21:39 <ksf> I don't even care for false negatives.
09:21:43 <pastorn> ksf: heh, that would be swell
09:21:55 <ksf> false negtives are way better than nothing at all
09:22:02 <pastorn> ksf: (+1) == (1+) ?
09:22:39 <ksf> I don't care.
09:22:44 <pastorn> haha
09:22:56 <pastorn> so what do you want it for?
09:23:04 <ksf> it'd be enough for starters to detect same-binding.
09:23:19 <StdDoubt> http://codepad.org/RUet5zkB here is the code
09:23:20 <pastorn> ksf: you might be able to do it with template haskell...
09:23:38 <ksf> I've got a segment map from, well, segments to what's going to include functional values
09:24:00 <StdDoubt> the problem is in the processResultList function
09:24:02 <pastorn> StdDoubt: where's the error?
09:24:11 <ksf> as unionWith on such a thing tends to create a lot of segments, it'd be great to unify them, again.
09:24:17 <StdDoubt> Line 58
09:25:15 <StdDoubt> ghc -> ProcessData.hs:65:20:
09:25:15 <StdDoubt>     No instance for (Num [Char])
09:25:15 <StdDoubt>       arising from a use of `processSolutionList'
09:25:15 <StdDoubt>                    at ProcessData.hs:65:20-51
09:25:33 <ksf> yeah that won't work.
09:25:45 <ksf> characters aren't numbers, and list of those even less so.
09:26:49 <pastorn> StdDoubt: replace numberOfOccurences with (show numberOfOccurences)
09:26:59 <dkc> getting this GHC error:   Ambiguous module name `Control.Monad.Reader': it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1  ...  what's the way to avoid this?
09:27:04 <pastorn> StdDoubt: i can give you some golfing advice, if you'd like...
09:27:24 <pastorn> dkc: ghc-pkg hide monads-fd
09:27:32 <dkc> cheers
09:27:35 <pastorn> :)
09:28:06 <StdDoubt> still have the error
09:28:34 <ksf> StdDoubt, the error can't be in processResultList, it doesn't mention processSolutionList
09:28:55 <Gracenotes> "WARNING in hptSomeThingsBelowUs" .. o_O
09:29:50 <ksf> StdDoubt, often it helps to write a few type annotations to move the type error to somewhere it makes sense.
09:29:55 <Gracenotes> the naming sounds ominous there
09:30:05 <pastorn> StdDoubt: i think that if you type annototate your code better you might more easily see what the error is
09:30:08 <Gracenotes> although the actual thing itself, 'Probable cause: out-of-date interface files'
09:30:13 <StdDoubt> if I comment out the processResultList  the program works
09:30:37 <pastorn> StdDoubt: you want some help golfing that code?
09:30:41 <StdDoubt> ok
09:30:47 <StdDoubt> that would be nice
09:31:06 <pastorn> countNumberOfOccurences v xs = length (filter (==v) xs)
09:31:30 <pastorn> that replaces both that functions lines, making it a one-liner! :D
09:32:36 <ksf> printStringList = mapM_ putStrLn
09:32:39 <pastorn> printStringList xs = do { mapM_ putStrLn xs; putStrLn "" }
09:32:59 <ksf> oh yes, you're right, I'm missing a newline.
09:33:00 <pastorn> well, ksfs solution is better, but use mine if you HAVE to have that extra empty line
09:35:11 <pastorn> processResultList xs = unlines $ map (\(name,occs) -> name ++ " " ++ show occs) xs
09:35:49 <Berengal> filterFileList = filterM (not . doesDirectoryExist)
09:36:55 <Berengal> Well, fmap not doesDirectoryExist
09:37:01 <pastorn> StdDoubt: the basic idea here is that when you're doing stuff over lists there are four functions (and variants) for working with them:
09:37:15 <pastorn> map: one function over a list
09:37:38 <pastorn> fold: one function that reduces a list to some value (sum and product are defined in terms of fold)
09:37:50 <ManateeLazyCat> I love this extension : https://chrome.google.com/extensions/detail/dbepggeogbaibhgnhhndojpepiihcmeb
09:37:52 <pastorn> filter: takes out element from the list for which the property is false
09:38:13 <pastorn> zipWith: uses a function to consolodite two lists into one in some way
09:38:45 <pastorn> ManateeLazyCat: vimperator?
09:39:01 <ManateeLazyCat> pastorn: No, but i love it's design for Chromium
09:39:25 <monochrom> vimperator is for a different browser
09:39:28 <ManateeLazyCat> pastorn: Special it's use *two-character* replace *number* when you type "f" to active link. 
09:39:36 <StdDoubt> pastorn: I have to practice using them (still a long way to go)
09:39:36 <ManateeLazyCat> monochrom: Firefox?
09:39:52 <monochrom> I forgot.
09:39:53 <Berengal> pastorn: Don't forget concatMap
09:40:13 <pastorn> Berengal: that's not really as useful as the rest of them
09:40:15 <monochrom> It is not like I have a fetish over vi keys.
09:40:18 <ManateeLazyCat> monochrom: Before i use it in firefox, but it's need you type "number" for open link, but it's painful when link is too many.
09:40:29 <pastorn> basically filter and map takes you a really long way
09:40:48 <Berengal> And fold takes you all the way
09:40:51 <ManateeLazyCat> monochrom: I foud vimium use awesome design for link, that's use *two character* instead number for explain link.
09:41:08 <pastorn> Berengal: yeah, but fold is much more difficult for n00bz
09:41:33 <ManateeLazyCat> monochrom: Now i can open any link use keyword and don't need typing stupid number. :)
09:42:11 <monochrom> @quote 1970s.terminal
09:42:11 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
09:42:24 <sshc> @sit
09:42:25 <lambdabot> Maybe you meant: bid dict ft gsite id let list quit src
09:42:25 <sshc> #flip
09:42:27 <sshc> @flip
09:42:27 * lambdabot pokes  in the eye
09:43:13 <ddarius> Too many programmers dismiss, or, more often, are completely ignorant of 1970s technology.
09:43:19 <pastorn> @botsnack
09:43:19 <lambdabot> :)
09:43:22 * ksf doesn't get why data.ranged claims that ('A' <= x <= 'Z') < (x == 'm')
09:43:42 <ksf> er wait.
09:43:44 * ManateeLazyCat I love use keyword do everything since i'm young. :)
09:44:04 <ksf> > chr (ord 'k' + ord 'A')
09:44:05 <lambdabot>   '\172'
09:44:09 <ksf> > chr (ord 'k' - ord 'A')
09:44:10 <sshc> ManateeLazyCat: You make no sense.  Quotations please? :)
09:44:11 <lambdabot>   '*'
09:44:22 <ksf> > (ord 'a' - ord 'A')
09:44:23 <lambdabot>   32
09:44:43 <ksf> > chr (ord 'k' + 32)
09:44:44 <lambdabot>   '\139'
09:44:46 <ManateeLazyCat> brb, use keyword watch movie now ...
09:44:47 <ksf> > chr (ord 'k' - 32)
09:44:49 <lambdabot>   'K'
09:45:25 <ksf> there were times where lowercase chars having higher ord than upcase chars wouldn't have tripped me off.
09:45:33 <StdDoubt> Thanks :D to all
09:46:21 <ksf> my keyboard was built in '94!
09:46:34 <ksf> based on '80s design
09:46:42 <ksf> it is most modern!
09:46:46 <andrewsw> ksf: 10NOV88
09:47:34 <ManateeLazyCat> ksf: I use Microsoft 3000, comfortable...
09:47:56 <ksf> there is no keyboard but the model M and it is the model M
09:48:21 <andrewsw> indeed
09:48:47 <andrewsw> I got mine about three years ago, and it was like going back in time.
09:50:58 <ksf> @pl sortBy (\x y -> compare (fst x) (fst y)) 
09:50:58 <lambdabot> sortBy ((. fst) . compare . fst)
09:51:05 <ksf> :t on
09:51:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:51:10 <ksf> @hoogle on
09:51:11 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:51:11 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
09:51:11 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
09:51:24 <pastorn> @type sortBy (fst `on` id)
09:51:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b) -> c
09:51:25 <lambdabot>     Probable cause: `fst' is applied to too many arguments
09:51:25 <lambdabot>     In the first argument of `on', namely `fst'
09:52:00 <pastorn> @type sortBy (compaare `on` fst)
09:52:01 <lambdabot> Not in scope: `compaare'
09:52:04 <pastorn> @type sortBy (compare `on` fst)
09:52:05 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
09:52:08 <pastorn> there we go
09:52:11 <pastorn> ksf: ^^^
09:55:34 <shivam3013> hi
09:55:43 <ksf> Data.Function is a quite unusual import
09:55:50 <ksf> > unionWith (++) [(loAlpha, "lo"),(hiAlpha, "hi")] [(singletonRange 'm', "m"),(singletonRange 'M',"M")]
09:55:51 <ksf> [('A' <= x < 'M',"hi"),(x == 'M',"hiM"),('M' < x <= 'Z',"hi"),('a' <= x < 'm',"lo"),(x == 'm',"lom"),('m' < x <= 'z',"lo")]
09:55:51 <lambdabot>   Not in scope: `unionWith'Not in scope: `loAlpha'Not in scope: `hiAlpha'Not ...
09:55:54 <shivam3013> does anyone here know how to code?
09:55:58 <soupdragon> yes
09:56:01 <soupdragon> I know how to code
09:56:07 <ksf> I think I get points for doing that in the least efficient way ever.
09:56:29 <shivam3013> soup dragon talk to me in private
09:56:53 <ksf> but I know how to code, too!
09:57:22 <ksf> and lambdabot is bound to be interested in talking to you in private.
09:57:34 <shivam3013> umn ok
09:58:49 <orlandu63> lol
09:59:36 * hackagebot XAttr 0.1 - Read, set, and list extended attributes  http://hackage.haskell.org/package/XAttr-0.1 (NicolaSquartini)
09:59:43 <shivam3013> less rp
09:59:56 <pastorn> less WAT?
10:00:03 <ksf> spealing.
10:00:08 <shivam3013> less roleplay
10:00:14 <soupdragon> let's
10:00:17 <soupdragon> let's roleplay
10:00:32 <soupdragon>  ill pretend to be a haskell programmer
10:03:17 <shivam3013> ksf?
10:03:33 <ksf> that's my nick.
10:03:46 <shivam3013> i know
10:03:48 <shivam3013> pc me
10:04:21 <shivam3013> pruvate chat
10:04:26 <ksf> I only write where I can embarress myself in public
10:05:38 <shivam3013> umn ok
10:05:43 <shivam3013> do you own any sites?
10:06:45 <ksf> nope
10:07:18 <shivam3013> k
10:08:25 <aristid> soupdragon: nobody will believe that you are a haskell programmer
10:08:53 <shivam3013> i am a haskell programmer
10:09:00 <shivam3013> i know over 160 languaghes
10:09:10 <soupdragon> but aristid, I just used a monad transformer stack to invert the control operators used in a tagless interpreter for my semantic FRP implementation
10:09:42 <soupdragon> By leveraging curry-howard on the monomorphisms of the functorial representation of bifunctors
10:09:47 <aristid> soupdragon: haha, so obvious. a real haskell programmer would have used a simple foldr.
10:10:04 <shivam3013> actually he wouldn't have
10:10:38 <soupdragon> bbl
10:10:48 <pastorn> shivam3013: no, that's obviously a place where you want foldl
10:11:12 <ksf> real haskell programmers write everything with flip id
10:11:31 <shivam3013> i am one
10:11:33 <shivam3013> and less rp
10:11:43 <shivam3013> 03anyways
10:11:53 <shivam3013> 03does anyone here know how to code except ksf
10:11:59 <shivam3013> 04?
10:12:21 <pastorn> I DO! I DO! I DO!
10:12:23 <Zao> shivam3013: Yes. We also know how to neuter people who use colours.
10:12:29 <shivam3013> 04calm down
10:12:38 <shivam3013> 00g
10:12:51 <Zao> Actually, I don't know how to neuter people that use colours in any persistent way.
10:12:52 <shivam3013> and less caps
10:12:54 <Zao> I leave that to ops.
10:13:11 <Zao> Why aren't we +C?
10:13:11 <shivam3013> there is no op on except chanserv who is basicaaly a lazy bot
10:13:24 <Zao> shivam3013: They lurk in the shadows, and that's no excuse for polluting.
10:13:49 <ksf> but he's still fun. let's play with him a little more before sacrificing him to oleg.
10:14:00 <shivam3013> oleg?
10:14:16 <ksf> he is said to have aleph heads.
10:14:39 <yitz> 6hmm, I never knew you could use colors on IRC.
10:15:02 <mauke> 04th07e 05mo08re09 y03ou10 k11no12w!
10:15:14 <mauke> hay guise
10:15:26 <Botje> how i mine for fish?!
10:15:40 <yitz> 8,2that's what I like about this channel.  Always learning something new.
10:15:45 <Zao> #haskell_201003.log:04:01 -!- mode/#haskell [+b *!*user@*.dsl.bell.ca] by Saizan
10:15:47 <mauke> how to kill a mockingbird?
10:15:50 <Zao> that sounds like an excellent idea :)
10:16:00 <shivam3013> yes
10:16:02 <shivam3013> must i say
10:16:03 <FunctorSalad>  /exec xcoltest-hs # j/k
10:16:14 <FunctorSalad> script I just wrote to output all 256 xterm colors ;)
10:16:33 <Hunner> FunctorSalad: I don't think they all work over irc
10:16:57 <FunctorSalad> (I have such a thing installed in colortest-256, but silly thing won't actually *tell* you the numbers corresponding to the colours)
10:17:01 <mauke> there's only one way to find out
10:17:08 <FunctorSalad> Hunner: aw :(
10:17:22 <FunctorSalad> 32 lines would get me akicked :|
10:17:23 <Hunner> I think it's just the 16 fg colors and 8 bg colors
10:17:33 <FunctorSalad> (two 16x16 blocks (fg/bg))
10:17:38 <shivam3013> akicked by whom? the lazy bot
10:17:43 <FunctorSalad> lol
10:18:06 <FunctorSalad>  000 
10:18:06 <FunctorSalad> 01 001 04 002 02 003 03 004 05 005 10 006 09 007 07 008 01 009 04 010 02 011 03 012 05 013 10 014 09 015 07 016 
10:18:13 <FunctorSalad> hmm that was the head -2
10:18:16 <Hunner> If you want to see all 256, start emacs in curses mode and run M-x list-colors-display
10:18:26 <Hunner> It will list the names numbers
10:18:36 <FunctorSalad> that missed the point since the first 16 xterm colors are equal to the traditional once I think ;)
10:18:44 <FunctorSalad> I'll head -5 ok? ;)
10:18:47 <mauke> no
10:18:53 <mauke> #haskell-blah if you have to
10:19:11 <FunctorSalad> :(
10:19:35 <FunctorSalad> it's not like I was interrupting any conversation :(
10:19:56 <mauke> true
10:20:09 <yitz> I'm on the mac right now. how does one get color in irssi?
10:20:27 <Hunner> yitz: please no?
10:20:27 <shepheb> please don't ban half of Canada :P
10:20:38 <mauke> yitz: ctrl-c and numbers
10:20:54 <yitz> mauke: interesting. thanks.
10:27:17 <shepheb> need a suggestion for a library for drawing real-time graphics in Haskell. GTK, or is there something slicker?
10:27:26 <shepheb> er, perhaps SDL
10:27:52 <lispy> shepheb: HOpenGL
10:28:07 <lispy> shepheb: What type of graphics do you want to do?
10:28:23 <lispy> shepheb: we also have cairo binding
10:28:39 <shepheb> white rectangle with a few hundred pixels turned a different colour
10:28:59 <shepheb> doing simulation visualization, basically
10:29:11 <ksf> gpipe
10:29:15 <shepheb> few hundred scattered, single pixels
10:29:32 <lispy> shepheb: I bet either cairo, opengl, or sdl would do that
10:29:46 <shepheb> well, SDL certainly would. I'm reading about Gpipe now
10:29:53 <ksf> sdl is the definition of legacy and cruft
10:30:09 <mreh> I really wish I could find a high-level openGL wrapper that works on my system :(
10:30:16 <ksf> mreh, gpipe?
10:30:21 <ksf> runs with glsl upwards.
10:30:25 <lispy> ksf: How so?  That seems a bit harsh
10:30:49 <shepheb> plus I would have given that honour to X11
10:30:55 <mreh> ksf: amazing
10:30:56 <mreh> thanks
10:30:56 <ksf> it'd non-optimal wrt. window managing (supporting only one of them), and doesn't have any sensible 2d primitives
10:31:21 <ksf> it's basically a glorified framebuffer with a bit of event support
10:31:36 <lispy> Well, that last bit I would have guessed from the name
10:31:48 <mreh> that's what my fg
10:31:52 <mreh> that's what my graphics card is
10:32:15 <ksf> mreh, the only drawback is texture management
10:32:51 <lispy> gpipe also sounds very  low level
10:32:57 <ksf> ...it's not possible to index properly into the texture memory with indices that are kept in the geometry
10:33:09 <mreh> dynamically loading textures
10:33:16 <ksf> yes, exactly.
10:33:35 <ksf> most importantly, automatic management of textures.
10:33:55 <ksf> it's already doing a lot of magic wrt. compiling and caching shaders and re-uploading geometry etc.
10:34:09 <mreh> I think it's something that could be better optimised imperatively
10:34:30 <mreh> :X
10:34:31 <ksf> but I think to do proper texture management one would need to have a scenegraph or something, and lod...
10:36:38 <mreh> scenegraphs being the opposite of what openGL does
10:36:56 <mreh> why cant we build on top of gpipe?
10:37:18 <jmcarthur> gpipe is actually somewhat high level, but i don't really like its implementation
10:37:38 <lispy> mreh: if you want all the scene management stuff, you might try an existing rendering engine with Haskell bindings like Ogre3d
10:37:47 <ksf> or lambdacube
10:37:56 <jmcarthur> and its interface is still kind of limiting if you want certain extensions or whatever
10:37:58 <mreh> lambdacube wont work on my damned computer
10:37:59 <ksf> which seems to have decent, but messy source.
10:38:02 <soupdragon> I could use some 3D graphics
10:38:23 <soupdragon> height map
10:38:28 <soupdragon> and camera
10:38:37 <soupdragon> it's so boring to implement that stuff
10:38:40 <jmcarthur> i'm just using OpenGL for a 2D engine (and OpenGLRaw for a more ambitious 3d graphics library in the long term)
10:38:42 <shepheb> GPipe seems like overkill for my simple 2D application
10:38:46 <soupdragon> and it's never as good as someone else would have done
10:39:08 <mreh> jmcarthur: what's the 3d lib going to do?
10:39:36 <mreh> I think openGL is a decent compromise, because it's so widely used
10:39:53 <ksf> but it's not really optimal for 2d
10:39:53 <lispy> soupdragon: yeah, for my 3d rendering side projects, ogre is currently winning my interest
10:40:12 <sproingie> torchlight uses ogre
10:40:15 <soupdragon> i  like ogre
10:40:23 <lispy> soupdragon: crystal space was equally footed until I saw the difference in documentation
10:40:31 <lispy> community++
10:40:44 <lispy> soupdragon: well, we have Haskell bindings on Hackage :)
10:40:44 <ksf> @karma community
10:40:44 <lambdabot> community has a karma of 2
10:41:15 <ksf> what's wrong with lambdacube?
10:41:25 <mreh> I get the dreaded black screen
10:41:34 <p_l> mreh: depends on the kind of rendering you are doing
10:41:39 <jmcarthur> mreh: well, it's actually a couple libs. one is just fairly low level, just a more convenient, more complete abstraction than the OpenGL package and supporting OpenGL 3. the other, if i every actually do it, would be something offering something like parametric surfaces as the main modelling unit rather than polygons, at least ideally. there are many ideas of course, and since i've put it on the 
10:41:40 <jmcarthur> backburner for now the vision will probably change over time
10:41:50 <ksf> I don't, and I merely have glsl, too.
10:41:55 <jmcarthur> mreh: either way, i'd still probably like to make the nicer low level OpenGL abstraction
10:42:00 <ksf> gforce 7600gs
10:42:31 <k23z__> jmcarthur: what are you talking about ? (I just woke up but my attention was caught by OpenGL
10:42:32 <ksf> jmcarthur, like fieldtrip?
10:42:39 <edwardk> jmcarthur: bah. implicit surfaces rule, parametric surfaces drool ;) parametricity is clearly overrated ;)
10:42:45 <jmcarthur> ksf: opengl is optimal for certain kinds of 2d, just not the usual sprites-and-tiles style of 2d
10:43:07 <ksf> ...or drawing cirles.
10:43:08 <edwardk> er i suppose the parametric ones are ruled, but still, the highschool chant applies ;)
10:43:18 <ksf> the amount of vertices necessary amounts to insanity.
10:43:36 <p_l> jmcarthur: DF got quite far when it came to sprites...
10:43:45 <ksf> doing tiles with opengl is trivial compared to aliasing issues...
10:43:49 <edwardk> p_l: daggerfall?
10:43:55 <jmcarthur> ksf: that's why you use a circle sprite or a shader on a billboard to generate it
10:43:58 <p_l> edwardk: Dwarf Fortress
10:44:06 <sproingie> opengl is great for sprites and tiles.  the API is just a little ... raw
10:44:19 <freenod> Question on Cabal with HEAD version: I am volunteering for an academic project that uses the HEAD version of Haskell (6.13.xxx) not the released 6.12.x because the project relies on a feature just introduced. the Cabal install command-line tool did not get built with the HEAD version and I couldn't get it to work afterward (nor could I get the 6.12.x version of Cabal to install packages into the 6.13.x) version.  Does this ring a bell for anybody?
10:44:25 <jmcarthur> p_l: DF?
10:44:25 <p_l> Daggerfall could probably use GL, but the only card supporting it wasrather rare ;-)
10:44:35 <p_l> jmcarthur: Dwarf Fortress
10:44:35 <jmcarthur> oh daggerfall
10:44:40 <jmcarthur> dawrf fortresds
10:44:46 <jmcarthur> :o i can't type
10:45:18 <ksf> freenod, in general cabal-install lags behind HEAD
10:45:34 <ksf> cabal should work though, unless the ghc guys broke HEAD
10:45:45 <jmcarthur> i'm using opengl for a so-called "2.5D" engine at the moment
10:45:55 <ksf> so for now resolve dependencied manually and install with runhaskell Setup.hs ...
10:46:20 <freenod> thx ksf
10:46:25 <edwardk> p_l: daggerfall was 96. at the time you had the 3dfx running around, and glide, direct3d and opengl were all just getting spun up on the PC, so software rendering still made sense. ;)
10:46:41 <p_l> edwardk: right
10:46:58 <k23z__> what are you up to with OpenGL ?
10:47:12 <ksf> freenod, hint: use a ghc 6.12 cabal-install with --dry-run to get the list of dependencies, then pipe the list through a script to install it on your ghc 6.13
10:47:16 <mreh> gam ez
10:47:22 <jmcarthur> k23z__: the topic of conversation i think is just opengl generally
10:47:37 <freenod> thx ksf
10:47:40 <k23z__> mreh: nice
10:47:44 <k23z__> jmcarthur: ah I get it
10:47:50 <k23z__> well I wrote a rubik's cube in OpenGL
10:47:52 <k23z__> in Perl
10:48:09 <mreh> I bet it killed you to death
10:48:28 <k23z__> mreh: Motorhead - Killed by death <-- is this what you mean ?
10:48:37 <ksf> shivam3013 left, already?
10:48:43 <mreh> <_<
10:48:44 <ksf> trolls aren't what they once used to be.
10:48:55 <soupdragon> :/
10:49:02 <ksf> it's called "to kill so. until he's dead"
10:49:07 <soupdragon> just call anyone that isn't the same as everyone else a troll
10:49:18 <k23z__> mreh: basically it was pretty bad I must say .. I would take Haskell over any other language any day but noone would hire me to write it..
10:49:27 <k23z__> mreh: Python on the other hand .. a little better
10:49:51 <mreh> k23z__ i think that's my experience so far too
10:49:53 * hackagebot np-extras 0.2.0.2 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.2.0.2 (BrentYorgey)
10:50:16 <mreh> I don't trust dynamically typed languages yet
10:50:50 <Ke> what on earth could change to make dynamic typing bearable
10:51:20 <ksf> supercompililation for dynamic languages
10:51:30 <ksf> which would throw most run-time errors at compile time...
10:51:44 <Ke> ok
10:51:48 <ksf> bluntly said, they've lost.
10:51:54 <Ke> yes
10:52:03 <mreh> says us :)
10:52:35 <Ke> sadly the worst options always prevail 
10:53:04 <ksf> I've never seen a perl programmer complaining "wtf I can't add "foo" to "bar"! haskell sucks, every sane language can do that!!!one!"
10:53:29 <yashton> the assumption is that sane programmers don't do things like that.
10:53:51 <mreh> sane programmers know the limit of the size of their own skull
10:53:52 <yashton> but i've found the old C programmer assumption of "they know what they are doing, don't get in their way" is bad
10:54:27 <yashton> type inference gives you all the benefits of dynamic programming with the type safety you need
10:54:31 <mreh> haskell is pessimistic by their standards
10:54:37 <sproingie> > "foo" ++ "bar"
10:54:38 <lambdabot>   "foobar"
10:54:53 <zygoloid> sproingie: TWO plusses? screw this i'm going back to perl
10:54:56 <sproingie> perl should be the last to complain about needing a special concatenation operator
10:55:02 <ksf> that's a monoid, but not over the natural numbers.
10:55:12 <sproingie> considering that *adding* "foo" and "bar" results in zero
10:55:15 <yashton> yeah, but then you get crap like in PHP, where 1 + "13foo" == 14
10:55:15 <aristid> zygoloid: in perl you need to use a dot.
10:55:26 <zygoloid> aristid: yeah, but only ONE. sheesh!
10:55:34 <ksf> zygoloid, well, I _did_ think "wtf" after toying with ocaml and having to type "/."...
10:55:41 <aristid> zygoloid: that's true!
10:56:06 <zygoloid> then we all agree?
10:56:12 <sproingie> lack of overloading is one thing i really hate about the ML family
10:56:41 <sproingie> not that haskell has ad-hoc overloading either but typeclasses are close enough
10:57:01 <yashton> type classes are closer to the true meaning of overloading
10:57:08 <ksf> you can't overload non-class methods in java, either.
10:57:13 <yashton> because in principle you shouldn't use + for anything but addition
10:57:32 <zygoloid> unicode syntax it is then. ⊕ or ⧺!
10:57:51 <ksf> +/* are meant to be used with rings.
10:58:13 <zygoloid> > ⊥
10:58:18 <yashton> but isn't the crossed circle XOR in boolean logic notation?
10:58:20 <lambdabot>   <no location info>: parse error on input `⊥'
10:58:24 <noteed> or + for monoids
10:58:33 <sclv> <+>
10:58:35 <ksf> * is, strictly speaking, wrong because that's the kleene star and not multiplication.
10:58:44 <Berengal> ⋅
10:58:52 <ksf> I think we once agreed on <> for mappend
10:59:12 <zygoloid> i think there may even be an accepted library proposal for that in base
10:59:13 <monochrom> > let x⊕y=x+y in 5⊕4
10:59:15 <Berengal> ksf: We all agreed on "not mappend" at least
10:59:16 <lambdabot>   9
10:59:21 <ksf> it's nice to have <+> for vectors  or such
10:59:22 <monochrom> > let x⊕y=x+y in a⊕b
10:59:23 <lambdabot>   a + b
10:59:53 <ksf> I'd go with such a syntax if it comes with a pure-ascii input method
10:59:56 <sclv> x `monoidaloperator` y
11:00:12 <sclv> self documenting :-)
11:00:13 <ksf> that is, code in tex syntax and have it displayed fully rendered as soon as you cursor away.
11:00:21 <Berengal> ksf: You should try Haskell in emacs with Agda-input and unicode syntax
11:00:31 <sproingie> x \N{SKULL AND CROSSBONES} y
11:00:37 <ksf> that's not what I mean.
11:00:41 <aristid> Berengal: agda-input simplifies unicode input?
11:00:43 <mauke> ksf: can't I just code in unicode?
11:00:52 <Berengal> aristid: Yes, it has tex-like input
11:00:53 <ksf> no.
11:00:58 <ksf> absolutely and positively no.
11:01:02 <sclv> apl keyboards for everyone!
11:01:03 <monochrom> > let x☠y=x+y in a☠b
11:01:06 <ksf> I don't have that many keys on my keyboard.
11:01:11 <zygoloid> @botsmack
11:01:16 <aristid> Berengal: i personally am not sure if unicode in code is a good idea.
11:01:17 <mauke> ksf: use combinations
11:01:21 <monochrom> we crashed her!
11:01:26 <zygoloid> ;(
11:01:35 <zygoloid> and unicode claims another life
11:01:36 <ksf> which I'd have to memorise without being able to look them up in the source.
11:01:48 <lambdabot> :)
11:01:49 <lambdabot>   a + b
11:01:54 <monochrom> New found secret: use ☠ to ☠ lambdabot :)
11:02:02 <Berengal> aristid: So far I've not seen code that's been worse of for using unicode
11:02:04 <zygoloid> > foldr (⋅) 1 [1..10]
11:02:16 <edwardk> Berengal: the consensus last time it came up on libraries@ was <>
11:02:38 <aristid> Berengal: i think i do have
11:02:45 <ksf> unicode is fine as long as I can infer from the source how to input it.
11:02:55 <ksf> that is, I'm fine with x \times y = x * y
11:02:59 <edwardk> ksf: so agda is off your radar ;)
11:03:32 <ksf> indeed. I spend half a day searching for a bug that turned out to be me misinterpreting a unicode symbol as ascii.
11:03:32 <aristid> i don't see how \lambda beats \ in any case. it's harder to type, and not easier to read.
11:03:46 <edwardk> ksf: the colon thing?
11:03:51 <ksf> it's not meant to be read. the latex output is meant to be read.
11:03:55 <mauke> × = <compose> x x
11:03:56 <Berengal> Agda has been pretty intuitive in its input as far as I've seen.
11:04:13 <ksf> ...and you have to look at the whole picture, not just lambda to see why it's easier to write.
11:04:17 <lambdabot>   3628800
11:04:19 <edwardk> Berengal: agda is great to input as long as you have another source file that uses the operator in question handy
11:04:38 <monochrom> use a better input method
11:05:06 <Berengal> edwardk: Which you do if you really need it.
11:05:14 <ksf> mauke, what's wrong with, instead of using editor support to compose x and x, to write \xx ?
11:05:45 <ksf> that way you don't have to search through docs to find out how to input a symbol.
11:05:46 <edwardk> monochrom: i have. the trick is you have a much larger exposure surface of things you need to hold in your head in order to code in agda. not just the operator you want to see, but which version of the unicode code point it is.
11:06:09 <mauke> ksf: yes, I do
11:06:20 <mauke> what's the difference between typing <compose> and typing \?
11:06:30 <ksf> the latter is visible in the source.
11:06:39 <soupdragon> there is no 'source' 
11:06:39 <Berengal> Not in agda
11:06:43 <soupdragon> only 1 and 0
11:06:49 <ksf> so when I use your code, I can look at how you wrote \something, and use the same.
11:07:00 <monochrom> (there is no monochrom either, but I digress)
11:07:04 <mauke> or copy/paste directly
11:07:08 <ksf> if you compose, I'd have to visually match your symbol against a unicode list, or copy+paste.
11:07:13 <soupdragon> ASCII is just as arbitrary as anything else
11:07:13 <ksf> ...both suck.
11:07:25 <mauke> why visually?
11:07:29 <ksf> ascii is fine for english-based stuff.
11:07:40 <ksf> because I'd have to copy&paste, otherwise...
11:07:44 <mauke> you can take the codepoint or the name of the character
11:07:45 <ksf> anyway, it's more work.
11:07:46 <mauke> why?
11:07:47 <edwardk> ksf: prior to actually using agda, i was a huge proponent of unicode encoded operators and mixfix for everything.
11:07:48 <Berengal> Unicode makes it easier to read code.
11:07:56 <ksf> more muscle memory to train.
11:08:10 <edwardk> ksf: thankfully the agda folks cured me ;)
11:08:13 <mauke> train ga, it displays the codepoint under the cursor
11:08:14 <ksf> I'm _very_ fast with any combination of latin characters, shortcuts arn't that easy.
11:08:33 <gwern> suppose I mention that my friend is a 'tween'. what gender would you guess that friend is?
11:08:44 <monochrom> neuter
11:08:46 <c_wraith> at that age, doesn't matter
11:08:47 <ksf> Berengal, true. that's why I'm proposing tex output.
11:08:54 <ksf> ...with ascii syntax.
11:08:58 <byorgey> gwern: female
11:09:04 <mauke> gwern: transsexual
11:09:07 <Berengal> ksf: Fortress looks nice in that regard
11:09:19 <Berengal> gwern: Either one or the other, or something inbetween
11:09:26 <mauke> 'tween
11:09:28 <edwardk> heya byorgey numeric-prelude extras? i thought i was over the top in terms of esoterica ;)
11:09:28 <ksf> actually, the easiest and most compatible thing would be to just use lhs2tex and render/edit in-line.
11:09:29 <gwern> Berengal: har har. I'm being serious here
11:09:48 <gwern> I know what gender I would guess a 'tween' likely is. but I don't know if my connotations are shared
11:09:54 <ksf> ...splitting up the file at the paragraphs.
11:10:02 <edwardk> gwern: i'd probably guess girl
11:10:27 * ksf wonders whether there's a full grammatical-framework parser for haskell
11:10:31 <edwardk> especially if it was a self-identified tween ;)
11:10:33 <monochrom> Your editor should be happy to tell you "this × character is U+00D7 'multiplication sign' " upon your request.
11:10:39 <gwern> ksf: what, NLP? see Gf I guess
11:10:47 <gwern> edwardk: hm, I see
11:11:05 <Berengal> gwern: I wasn't kidding. I have no connotations at all, so if I had to guess it'd be entirely arbitrary
11:11:23 <edwardk> monochrom: which requires me to load the file i'm referencing into my editor, rather than just skim the docs via a web browser, etc.
11:11:27 <ksf> not necessarily to the native language level, but Gf's transformation abilities are truly impressive.
11:13:25 <byorgey> edwardk: it's not all that esoteric =)
11:13:31 <mreh> we were talking about dynamically typed programming
11:13:57 <byorgey> I mean, formal power series in a countably infinite number of variables, doesn't everyone want those all the time?
11:14:01 <ksf> ...their infiority has been established, and thus we moved on.
11:14:54 <gwern> ksf: I once wanted to use Gf to parse english text and indent it by clause depth, but I couldn't figure out how to use it
11:15:35 <ksf> I once tried to write a library for toki pona, but gave up
11:15:48 <ksf> ...because toki pona is just too ambiguous to make sense of programmatically.
11:16:07 <ksf> every sentence would explode into a long chains of ORs
11:16:14 <gwern> really? conlangs are usually good for parsing
11:16:29 <ksf> ...have a look at toki pona
11:17:32 <ksf> though I bet a baby would start to speak sense as soon as it can control its tounge if you talk toki pona to it.
11:19:21 <ksf> it's not really possible to use it to talk about anything outside of one's own experience. "good complexity" is self-contradictory in toki pona
11:19:29 <ksf> ...as you can't both feel good and confused.
11:20:03 <sclv> byorgey: nice
11:20:31 <edwardk> byorgey: actually i know that i do. and maybe sclv does ;)
11:20:45 <edwardk> so in a sufficiently small universe, yes. ;)
11:20:51 <byorgey> =)
11:21:11 <edwardk> byorgey: i even implemented the same thing in my ad library ;)
11:21:44 <soupdragon> edwardk I used your awesome library
11:21:51 <edwardk> soupdragon: ad?
11:21:54 <soupdragon> yes
11:22:10 <edwardk> soupdragon: happy to hear. feedback is welcome
11:22:11 <soupdragon> h [theta,phi,p1,p2] = (l2^2 * m2 * p1^2 + l1^2 * (m1 + m2) * p2^2 - 2 * m2 * l1 * l2 * p1 * p2 * cos (theta - phi)) / (2 * l1^2 * l2^2 * m2 * (m1 + (sin (theta - phi))^2 * m2)) - m2 * g * l2 * cos phi - (m1 + m2) * g * l1 * cos theta
11:22:32 <edwardk> i can see why one might not want to take the derivative of that by hand
11:22:37 <soupdragon> now grad h computes what I need to evolve a double pendulum
11:23:02 <soupdragon> h [x1,y1, x2,y2, x3,y3, xv1,yv1, xv2,yv2, xv3,yv3] = (1/2) * (xv1^2+yv1^2) / m1 + (1/2) * (xv2^2+yv2^2) / m2 + (1/2) * (xv3^2+yv3^2) / m3 - g * m1 * m2 / sqrt ((x1-x2)^2 + (y1-y2)^2)  - g * m1 * m3 / sqrt ((x1-x3)^2 + (y1-y3)^2)  - g * m2 * m3 / sqrt ((x2-x3)^2 + (y2-y3)^2)
11:23:06 <soupdragon> and that's the 3 body problem
11:23:07 <edwardk> soupdragon: what no higher order derivatives? =)
11:23:24 <zygoloid> is there a name for a structure which is a Monoid two ways, with the same zero?
11:23:30 <soupdragon> edwardk, well I haven't learned any integration methods for higher order but I probably should do
11:23:36 <sclv> do the two ways relate to one another?
11:23:40 <edwardk> zygoloid: with the same zero? not really.
11:23:48 <soupdragon> anyway it's a lot of fun
11:24:03 <edwardk> zygoloid: if they both have identities and they abide then the eckman-hilton conjecture tells you they are the same
11:24:17 <zygoloid> edwardk: what does 'abide' mean?
11:24:18 <edwardk> soupdragon: =)
11:24:33 <zygoloid> sclv: there's a distributive law, i think
11:25:06 <zygoloid> actually, no, there isn't ;(
11:25:12 <soupdragon> I couldn't figuer out where to place the sun moon and earth so they stay in orbit though
11:25:13 <edwardk> if (a + b) * (c + d) = (a * c) + (b * d) and if * and + have identities at all then then * = + and they are commutative
11:25:20 <soupdragon> I always get the moon fly off and and stuff
11:25:25 <soupdragon> but that's Gods problem
11:25:32 <soupdragon> I don't have to deal with it I just got the equations working
11:25:51 <edwardk> oh and the identities are the same
11:26:10 <yaaaa> hi, Does anybody know how to properly read umlauts from a file? (in C) .. i got the whole code running but it's still giving me wrong values for  etc :/
11:26:23 <yaaaa> i'm new here so sry if its wrong channel
11:26:30 <soupdragon> um
11:26:30 <edwardk> but that is the only real theorem/structure involving two monoids with the same identity that i can think of
11:26:31 <monochrom> it is wrong channel
11:26:31 <ksf> read it as unicode
11:26:32 <soupdragon> you could try ##c
11:26:34 <sclv> yaaaa: this is a hasklell channel
11:26:35 <ksf> using wchar etc.
11:26:40 <ksf> and yes, it's the wrong channel
11:26:41 <edwardk> yaaaa: try ##c
11:26:56 <yaaaa> ty
11:27:46 <zygoloid> edwardk: interesting. my values are (size,alignment) pairs and my operations are concatenation and union (both with identity (0,1)).
11:27:51 <djahandarie> I bet it was another person misled by the "programming chat" google search
11:28:59 <edwardk> zygoloid: calculating alignment with the remainder for aliasing purposes?
11:29:18 <edwardk> or for building a structure purposes?
11:29:34 <zygoloid> i'm parsing stuff with language.c and figuring out its memory layout
11:29:40 <edwardk> ah
11:30:20 <edwardk> but if the unit for alignment is 1 and the unit for size is 0, then they have different units =)
11:30:36 <andreo> how can i connect to mysql database in haskell?
11:30:39 <zygoloid> both operations operate on (size, alignment) pairs
11:30:49 <edwardk> oh you mean concatenation and union as your operators
11:30:59 <zygoloid> yeah
11:31:16 <sclv> grrr -- I built a spine-lazy element strict data stream which was awesome and killed space leaks. but now I want to map over it efficiently, and the strictness is killing me.
11:32:15 <sclv> laziness/strictness optimizations don't always compose well :-(
11:32:17 <edwardk> zygoloid: you just have some kind of algebra. with operations for union and concatenation over (size,alignment) pairs
11:32:27 * hackagebot bitspeak 0.0.1 - Writing helper for those with Stephen Hawking like impairment.  http://hackage.haskell.org/package/bitspeak-0.0.1 (MauricioAntunes)
11:32:34 <djahandarie> ...lol
11:32:59 <djahandarie> Odd package
11:33:15 <edwardk> zygoloid: http://en.wikipedia.org/wiki/Universal_algebra
11:33:36 <tafryn> How would I go about constructing a list of all ascii characters with even character codes?
11:34:05 <mauke> > ['\0', '\2' .. ]
11:34:09 <zygoloid> > ['\0','\2'..'\177']
11:34:16 <mauke> 177? wtf?
11:34:20 <sclv> map char [0,2..127]
11:34:30 <tafryn> Is there a way to do it with a list comprehension?
11:34:40 <edwardk> zygoloid: but that insight doesn't really inform your design decisions much ;)
11:34:43 <zygoloid> mauke: hah, haskell uses decimal there? :o
11:34:51 <zygoloid> edwardk: indeed not :)
11:34:54 <mauke> tafryn: [ x | x <- ['\0', '\2' .. '\126'] ]
11:34:59 <djahandarie> lol
11:35:08 <tafryn> [ char x | x <- [0..177] ] ?
11:35:09 <Zao> > [ chr x | x <- [0..127], even x ]
11:35:09 <sclv> brillant
11:35:16 <edwardk> tafryn: [ x | x <- [minBound :: Char .. maxBound], fromEnum x `mod` 2 == 0 ]
11:35:28 <Zao> tafryn: \177 is octal 127.
11:35:41 <mauke> Zao: what are you talking about?
11:35:51 <Zao> 20:34 < tafryn> [ char x | x <- [0..177] ] ?
11:36:01 <mauke> that doesn't contain \177, and \177 is not octal 127
11:36:04 <djahandarie> > char 177
11:36:09 <Zao> Or rather, '\177' is the character with ordinal represented by 0177.
11:36:21 <djahandarie> God damn it lambdabot
11:36:23 <mauke> Zao: indeed it is, but what does that have to do with octal?
11:36:29 <zygoloid> mauke: but it does contain 177, which indicated tafryn had been confused by my earlier confusion
11:36:41 <Zao> mauke: It was used above as \177, and tafryn used it as a decimal number in his question.
11:36:49 <mauke> Zao: you're confused
11:36:54 <mauke> 0177 is a decimal number
11:37:03 <Zao> mauke: I did not claim it was octal 127. I said that it was the octal representation of the decimal number 127.
11:37:08 <Zao> Read me right.
11:37:19 <mauke> except it isn't
11:37:30 <Zao> obase=8
11:37:30 <Zao> 127
11:37:30 <Zao> 177
11:37:34 * Zao pets bc
11:37:36 <mauke> \177 is a lambda, '\177' is chr 177
11:37:46 <Zao> Context, fucktard.\
11:37:52 <mauke> and 0177 is 177
11:37:52 <Zao> *breathes*
11:38:01 <zygoloid> mauke: both of those statements are true but irrelevant to the statement that 0o177 == 127
11:38:07 <Zao> 0177 as the sane octal convention used by anyone.
11:38:10 <mauke> zygoloid: no one made that claim
11:38:18 <mauke> Zao: it's not sane, and Haskell doesn't use it
11:38:21 <zygoloid> mauke: that is what Zao was claiming, to my reading
11:38:29 <Zao> Please do not troll me, mauke..
11:38:38 <Zao> I'm in a shitty mood today and can't take aggravation.
11:38:43 <mauke> Zao: please do not tell Haskell newbies to use a syntax that doesn't work
11:38:46 <Zao> You know very well what I said.
11:38:47 * soupdragon smooches Zao 
11:38:50 <soupdragon> ;DDDDDDD
11:39:07 <mauke> preflex: seen Cale
11:39:07 <preflex>  Cale was last seen on #haskell 10 hours, 8 minutes and 20 seconds ago, saying: (and they're equality-testable, or better, ordered)
11:41:22 <tafryn> where does char and/or chr come from?
11:41:54 <c_wraith> @hoogle chr
11:42:04 <mauke> tafryn: why do you insist on using chr?
11:42:50 <tafryn> I don't. I simply lack any kind of metric to determine the best solution of the ones provided above.
11:43:21 <mauke> tafryn: ['\0', '\2' .. '\126' ] is the best one
11:43:28 <mauke> but the restriction to ASCII is weird
11:44:26 <sclv> Data.Char
11:45:36 * zygoloid marginally prefers ['\0','\2'..'\127']
11:46:17 <Twey> > ord '\177'
11:46:21 <tafryn> mauke: Would you mind explaining how that is superior to [ chr x | x <- [0..127] ] ? 
11:46:23 <mauke>  177
11:47:02 <mauke> tafryn: it generates the list directly
11:47:10 <mauke> instead of generating a list of numbers and mapping over it
11:47:28 <mauke> also, it actually works
11:47:42 * Twey prefers ['\0', '\2' ..]
11:47:54 <Twey> Wast here an ASCII limit in the question?
11:48:06 <tafryn> mauke: And what I typed doesn't work?
11:48:09 <Zao> Twey: Yes.
11:48:14 <Twey> Oh, okay.
11:48:18 <Twey> Was there**
11:48:18 <mauke> tafryn: no, yours generates all ASCII characters
11:48:31 <Zao> 20:33 < tafryn> How would I go about constructing a list of all ascii characters with even character codes?
11:48:57 <Zao> If you want to filter in a list comprehension, you can have an expression with boolean result in it.
11:49:01 <tafryn> Ah, left off the predicate.
11:49:17 <Twey> [ chr x | x <- [0 .. 127] ] = map chr [0 .. 127] = ['\0' .. '\127']
11:49:50 <Zao> In the case of a uniform step, an [a,b..c] would be considered nicer, by me.
11:50:05 <Zao> If your predicate is trickier, a filter or a list comprehension might be suitable.
11:50:47 <tafryn> So that should have been [ chr x | x <- [0..127], even x ] , but ['\0', '\2'..'\127'] is still better, correct? 
11:50:59 <Zao> For some definitions of "better".
11:51:01 <Zao> Both work.
11:51:17 <Zao> Almost.
11:51:29 <Zao> You probably meant '\177' there.
11:51:36 <Zao> Or am I misreading the confusion above?
11:51:56 <Zao> Ignore that.
11:52:02 <Twey> Yeah, it's ASCII.
11:52:09 <Zao> I blame whoever said '\177' in the first place, way up there.
11:52:10 <tafryn> No, I think '\127' is right... yeah.
11:52:19 <Zao> It's all zygoloid's fault!
11:52:25 * Zao hands out pitchforks.
11:52:33 <tafryn> No torches?
11:52:40 <Zao> Enough flame already.
11:53:13 <Twey> Heheh.
11:55:07 <chrisdone> so today i was thinking a great way to judge a language is by how willing its users are to bet on their programs not exhibiting bugs
11:55:30 <Twey> Assembly would win
11:55:41 <Twey> ‘I don't code bugs — I'm a Real Programmer!’
11:55:48 <chrisdone> i wrote some simple web service in a couple days in haskell and i'll put money on no one being able to elicit a bug in it
11:56:06 <djahandarie> How much money? ;-)
11:56:07 <chrisdone> i asked one of my colleagues if they'd do the same for one of their projects in Java
11:56:09 <edwardk> chrisdone: normalize by dividing that metric by the amount of time said programs take to develop and you might be on to something. ;)
11:56:40 <edwardk> chrisdone: otherwise smerdyakov, mattam and the coq brigade will take you to the cleaners ;)
11:56:47 <aristid> why are list comprehensions limited to a return on the left-hand side?
11:57:12 <Twey> Because the point of a list comprehension is to get something out of it
11:57:28 <Twey> And it has to be an expression, besides, so there must be something returned
11:57:33 <aristid> [ x + 1, x - 1 | x <- [1,2,3] ]
11:57:38 <aristid> could be valid, but is not.
11:57:44 <chrisdone> edwardk: yeah i already thought about this. i was asked to complete it within a few days, so time-wise it's reasonable
11:57:54 <Twey> You mean you want a multiple return with an implicit concat?
11:58:40 <aristid> Twey: [ x + 1 | x <- [1,2,3] ] is equivalent to [ 1,2,3 ] >>= return . (+1)
11:58:40 <Twey> concat [ [x + 1, x - 1] | x <- [1, 2, 3] ] = [2, 0, 3, 1, 4, 2]
11:58:41 <edwardk> chrisdone: i find that haskell has a very good development time to correctness ratio. i find that erlang has a very good uptime to correctness ration ;) in that even if the program is crap, it still probably runs and is stable ;)
11:58:48 <edwardk> er ratio
11:58:53 <aristid> Twey: yes, basically
11:59:06 <aristid> Twey: the syntax wouldn't have to change for the single-expression case
11:59:10 <Twey> They're limited because they were originally monad comprehensions
11:59:19 <Twey> And with luck will be again some day
11:59:35 <aristid> Twey: do expressions do not have the same limitation
11:59:42 <edwardk> [ y | x <- [1,2,3], y <- [x + 1, x - 1] ]
11:59:51 <soupdragon> edwardk, although I am not sure why I have to use a list (for grad) rather than a triple or whatever
11:59:52 <edwardk> just move the left to the right
12:00:15 <edwardk> soupdragon: the problem comes down to the shape of the instance head. there is a 'vgrad' combinator but its unsafe
12:00:31 <edwardk> soupdragon: (it can potentially be used to confuse infinitesimals)
12:01:01 <Twey> aristid: do expressions have an explicit return
12:01:05 <edwardk> soupdragon: you can make a traversable triple type though
12:01:20 <Twey> I guess we could write [ return x | x <- [1, 2, 3] ] for everything, but it wouldn't be as nice
12:01:29 <edwardk> soupdragon: data Triple a = Triple a a a deriving (Functor, Foldable, Traversable) -- then pass that to grad
12:01:36 <soupdragon> oh cool!
12:01:38 <soupdragon> okay
12:01:42 <aristid> Twey: hmm so the problem is that lists get an implicit return for free in this syntax, but other monads do not?
12:01:54 <edwardk> soupdragon: all my combinators take arbitrary traversables where possible
12:01:55 <Twey> No, all monads get an implicit return for free in this syntax
12:02:04 <Twey> But the list return only allows returning a single item
12:02:10 <chrisdone> edwardk: yeah it's good. you definitely ahve to take speed into account
12:02:17 <Twey> return x = [x]
12:02:41 <Twey> What you want to do is change the return to something else for lists
12:02:55 <aristid> Twey: well if you could write [ x,y | ... ] you would get both things at the same time.
12:02:57 <aristid> yeah.
12:02:57 <Twey> Which would either be inconsistent magic or else limit us only to lists in comprehension for all eternity
12:03:06 <Twey> But that wouldn't be a return
12:03:24 <aristid> Twey: given that it's list comprehensions at this time, my proposal is not entirely insane :)
12:03:25 <edwardk> aristid: the problem is that is fairly magical syntax for ,
12:03:33 <lispy> > (,) 1 2
12:03:39 <lispy> !!
12:03:40 <edwardk> aristid: which is unrelated to its use for tuples.
12:03:46 <chrisdone> i've found i use tuple sections CONSTANTLY since finding out about them
12:03:46 <lispy> Where is lambdabot?
12:03:47 <Twey> Not entirely insane, no, but I'd much rather have monad comprehensions.
12:03:54 <aristid> > [1,2]
12:04:00 * chrisdone <lambdabot> (1,2)
12:04:05 * chrisdone <lambdabot> [1,2]
12:04:11 <lispy> heh
12:04:11 <aristid> yay chrisdone is our lambdabot now
12:04:18 <Twey> edwardk: 'cause we don't have any other magical syntaxes for , at all, do we?  ;)
12:04:19 * chrisdone waits for someone to write a really hard expression
12:04:24 <aristid> edwardk: haskell already uses , for non-tuply things :)
12:04:33 <aristid> > fix id
12:04:42 <Twey> > fix error
12:04:44 <edwardk> Twey: well, one might argue that that is not always a good thing. ;)
12:04:50 * chrisdone <lambdabot> Exception: stack overflow, you insensitive clots!
12:05:05 <edwardk> Twey: watch it or you'll get chrisdone to blow his stack
12:05:13 <Twey> edwardk: I agree, but I don't consider it nearly as big a disadvantage as tying us to lists.
12:05:19 <chrisdone> edwardk: keep it clean
12:05:25 <chrisdone> :p
12:05:30 <Twey> There's nothing else that applies here, as far as I can tell.
12:06:10 <lispy> Can we have Monad+1 Patterns too?
12:06:32 * lispy admits that reference might be obscure
12:06:42 <edwardk> chrisdone: do I have to? but i prefer to have access to partial application and (a -> b) -> [a] -> [b] reads so much nicer than (a -> b) [a] -> [b]. plus do I really need uniqueness types at the cost of most uses of currying?
12:07:15 <edwardk> lispy: m+k? ;)
12:08:17 <lispy> edwardk: oh right, k not 1
12:08:32 <edwardk> Twey: well, we already have parallel list comprehensions which pretty much shackle us to lists as is
12:09:43 <lispy> edwardk: I put Monad Comps in the same category as n+k.  It's cool, it make sense, it's even reasonable.  But given how much we use them and the overhead of having them (cognitively and compiler implementor) let's just leave them out.  (And yes, I realize monad comps are well-defined unlike n+k, but then they have even higher learning curve for beginners who just want the list instance of monad)
12:09:59 <Twey> edwardk: Fair enough then.  Multiple returns it is!
12:10:13 <edwardk> Twey: ack!
12:10:19 <Twey> edwardk: :þ
12:10:37 <gwern> Welcome to the N+K - a sinister conspiracy to produce haskellers and shackle them to ints and haskell98
12:10:58 <Twey> edwardk: It's not actually a magical use of ',', either — it's the same as the list syntax one
12:11:43 <Twey> (unlike the usage on the *right* of the pipe, which is indeed magical)
12:11:48 <sclv> it wouldn't limit us to lists. it would limit us to monadplus
12:12:13 <Twey> sclv: Oh, but then it is a magic syntax.
12:12:17 <edwardk> Twey: very well. i leave it to you to go tackle plumbing it into ghc. having seen the code in question, i doubt you'll be back ;)
12:12:27 <Twey> Eek.
12:12:39 <sclv> list comprehensions are already magic syntax :-)
12:12:51 <sclv> especially with group and all.
12:12:55 <edwardk> Twey: while you're down there if you could hack in a {-# LANGUAGE MonadComprehensions #-} it'd be all good.
12:12:59 <sclv> (speaking of limiting to lists...)
12:13:08 <edwardk> sclv: yeah
12:13:18 <sclv> hey, speaking of which, has anybody used that stuff?
12:13:21 <djahandarie> magic--
12:14:23 <edwardk> sclv: i think it was mostly a reaction to meijer taking the monad comprehension stuff and building linq. a way to say 'hrmpph. we could do that too if we wanted to' ;)
12:14:25 * zygoloid is quite fond of n+k
12:14:49 * edwardk is an edward+k pattern.
12:14:53 <sclv> right, but since it only really works on lists it doesn't really find much use....
12:14:58 <edwardk> sclv: yeah
12:15:21 <sproingie> actually isn't there already a linq-like sytax for comprehensions?
12:15:22 <Saizan> we should just have a pattern declaration to register an inverse for an arbitrary function.
12:15:30 <sproingie> its in some obscure place in the docs and i've never seen anything use it
12:15:36 <zygoloid> > let fib 0 = 0; fib 1 = 1; fib (n+2) = fib (n+1) + fib n in fib 10
12:15:40 <edwardk> zygoloid: i'm not sorry to see them voted off the island.
12:16:48 <zygoloid> i'm a little sad that some of my code isn't haskell'10 as a result, but it's not a big loss
12:16:54 <sclv> sproingie: http://haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#generalised-list-comprehensions
12:17:04 <sproingie> yeah that's it
12:17:24 <zygoloid> (i have more modules which now /are/ standard haskell due to using pattern guards)
12:17:25 <sproingie> i guess it's only an obscure place if the docs are obscure :)
12:17:34 <Saizan> so with generalized-list-comprehensions + monadcomprehension we'd have linq?
12:17:42 <sproingie> tho i've still never seen anything using them
12:18:21 <zygoloid> Saizan: doesn't linq also give you full reflection of the expression?
12:18:42 <Saizan> zygoloid: never used linq :) but your monad could be reflective
12:18:56 <zygoloid> it's still got to admit an fmap
12:19:00 <edwardk> zygoloid: yep
12:19:22 <zygoloid> even an Arrow isn't static enough :(
12:19:53 <edwardk> Saizan: nah linq pretty much pisses all over parametricity ;)
12:21:09 <edwardk> Saizan: it can literally inspect the entire syntax tree so you really have no reasoning power about what your linq provider will do, except that if it gives you  value you have a pretty good guess at its type ;)
12:21:56 <zygoloid> i love Language.C. i just got to write: show (pretty sue)
12:22:16 <gwern> but does C pass the man or boy test?
12:26:15 <andreo> how can i split string like this: "world, hello world!" -> ["world", ",", "hello", "world", "!"]
12:26:59 <zygoloid> > words =<< groupBy isAlpha "world, hello world!"
12:27:31 <djahandarie> Depends what you want to happen with "World,,,, hello,! world!"
12:27:37 <ksf> what's the fastest way to match a bounded key against a list of ranges and points?
12:27:53 <ksf> that is, naively speaking, are there perfect hashes that can deal with ranges?
12:27:54 <djahandarie> And throw some consecutive spaces in there too
12:34:54 <andreo> zygoloid: doesn't work ;)
12:39:18 <dons> ksf: i think there's some range tree and range matching libraries on hackage
12:42:18 <ksf> "range" isn't a word that's fun to search for
12:42:22 <ksf> dons, I know
12:42:31 <ksf> ...we have segment- and interval trees
12:43:17 <ksf> I already hacked a (slow and inefficient) interval map because I need unionWith, and I don't trust segmenttree's types to save values...
12:43:35 <edwardk> gwern: not as originally formulated =)
12:44:47 <edwardk> ksf: there is an interval tree in the fingertree package: http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html it is asymptotically optimal, but has kinda ugly constants ;)
12:45:28 <ksf> I want to query for points, not ranges
12:45:37 <ksf> that is the lookup keys are single values
12:45:56 <edwardk> ksf: yes but you can encode a query as a range using 'point' which returns a single point interval
12:46:14 <ksf> ...and said interval tree doesnt' have the union I want
12:46:49 <ksf> mine splits up two overlapping ranges into three and unifies the associated value with a function
12:46:50 <edwardk> ksf: that is more of a problem. =)
12:47:40 <edwardk> ksf: as for ways to encode an interval into a hash function, not directly such that you can hash any value in the range to a value that collides with the hash
12:48:18 <edwardk> not without being grossly equivalent to the original range (or just pushing the boundaries outward)
12:49:07 <ksf> in laymans terms, I'd have to make my ranges explicit and shove a gazillion keys to a vanilla perfect hash generator
12:49:18 <edwardk> ksf: any merge is likely n log n ish
12:49:35 <ksf> I'm not worried about construction speed
12:49:46 <edwardk> hrmm, can you reformulate things into a range min query somehow?
12:49:59 <edwardk> i.e. what are the values you are looking for?
12:50:04 <ksf> ranges don't overlap, if that helps.
12:50:16 <edwardk> that helps a LOT
12:50:29 <ksf> ...that's why I do unionWith in the first place
12:50:54 <edwardk> just dump it into a Map (or fingertree) with a value for the item also including the upper end of the range.
12:51:00 <ksf> keys are Chars, values are going to be continuations.
12:51:08 <edwardk> then you can use Map or IntMap.union directly
12:51:57 <edwardk> query using IntMap.splitLookup, and check the nodes above and below you
12:52:02 <ksf> ...I've already nailed that part, I have a sorted list of ranges that I can use to construct the final lookup function
12:53:15 <ksf> the naive approach is of course just traversing the list, the slightly less-naive ad-hoc one splitting the list approx. in the half of the search space and doing an unbalanced binary lookup
12:53:24 <ksf> ...or maybe balance differently.
12:53:40 <edwardk> well, what keeps you from just dumping the list of intervals directly into an IntMap?
12:53:53 <ksf> the problem with tree lookups in general is that their performance is dependent on input distribution.
12:54:14 <ksf> nothing.
12:54:43 <ksf> but I'm thinking of generating straight code out of the automaton I built
12:54:44 <edwardk> ksf: yes, but you still have an "O(1)" ceiling given that it is a bounded height patricia trie. sucky constants perhaps
12:56:28 <ksf> ...what's true in any case is that construction and lookup won't be intertwined.
12:56:38 <edwardk> ksf: if you're compiling it down, you could just store it in a flat array and binary search that
12:56:43 <edwardk> *nods*
12:57:21 <legonis> hi
12:57:25 <kmc> hi
12:57:26 <ksf> I once benchmarked traversing a binary tree against a flat array, and they turned out to be indistinguishable
12:57:32 <edwardk> but its equivalent to the tree
12:57:33 <edwardk> yeah
12:57:37 <legonis> noob question I have 
12:57:41 <edwardk> because you just stored the tree implicitly
12:57:43 <ksf> ...they were quite small, though, there might be cache effects when they're bigger.
12:57:57 <legonis> I am trying to define a bunch of data types 
12:58:01 <edwardk> the tree will take up a bit more memory and may make the gc work harder
12:58:08 <edwardk> legonis: so far so good
12:58:15 <legonis> using record syntax, and all have a field with a common name 
12:58:27 <legonis> how to go about it to avoid name conflict 
12:58:32 <ksf> ...the fastest thing, though, was to unroll the tree into ifthenelses.
12:58:35 <legonis> I tried defining a typeclass for it
12:58:39 <legonis> but don't like the solution
12:58:59 <edwardk> legonis: the short version is 'you can't' at least not such that you can use it for record syntax. the longer version is you kinda can, but need to farm everything out to different modules and use extensions
12:59:04 <ksf> if it's in the same data type, there's no problem.
12:59:20 <legonis> no it's not the same
12:59:27 <legonis> there are a bunch of types
12:59:38 <ksf> can't any of those lenses packages do that?
12:59:44 <edwardk> legonis: things like this are why a lot of folks have switched to libraries like fclabels, which give us a way to update a specific field in an object, we can then make the fclabel a member of the typeclass
12:59:47 <legonis> so let's say they all have a field called 'name'
12:59:50 <edwardk> and use that rather than the record syntax.
13:00:02 <legonis> what I did was defining a type class , i.e., Named
13:00:22 <edwardk> ksf: fclabels or data-accessor, but you still need to use their sugar rather than record sugar. there is typedirectednameresolution, but then everything needs to be in a different module
13:00:24 <legonis> and then defined every type to be the instance of that class and mapped from their specific name field to the name function
13:00:47 <kmc> legonis, yeah, problem is with regular Haskell records, the field names aren't really first-class values
13:00:56 <kmc> they are when used as accessors, but not as modifiers
13:01:06 <kmc> that's where fclabels / lenses / data-accessor come in
13:01:12 <edwardk> legonis: check out http://hackage.haskell.org/package/fclabels
13:01:14 <kmc> they'll provide a more useful value for you to put in your type class
13:01:20 <kmc> which can do both access and update
13:01:28 <legonis> okay I am beginner 
13:01:36 <legonis> which one is the easiest to use/learn 
13:01:39 <edwardk> legonis: you can make an instance for class Named t where name :: t :-> String -- and then use get and set, etc.
13:01:41 <legonis> don't want to look at all of them
13:01:42 <edwardk> legonis: fclabels
13:01:44 <kmc> fclabels is popular i think
13:01:52 <legonis> ok, cool
13:01:53 <ksf> hmmm I could perfectly hash the single-value ranges and then fallback to an ifthenelse chain for the ranges.
13:02:10 <legonis> so while we are at it, let me ask another (somewhat relevant) question
13:02:15 * kmc is pleased to have discovered the hashmap package on hackage
13:02:27 <edwardk> ksf: if you implement it as a function, you could encode it several ways behind a functional facade.
13:02:30 <legonis> I am porting some Java code to haskell 
13:02:47 <legonis> and there is a data schema based in the java program that has leveraged inheritance quite a bit 
13:03:00 <legonis> (name is an apt example of data sharing in the hierarchy)
13:03:13 <ksf> kmc, is it faster for knucleotide?
13:03:17 <legonis> so what's the easiest way to do it in Haskell without having to define it in all my data types
13:03:20 <edwardk> legonis: the usual haskell idiom would be to encode data Foo = Foo { fooName :: String, fooField :: Int } ...
13:03:39 <edwardk> legonis: and then define the name fclabel to access those uniformly
13:03:44 <kmc> ksf, no idea
13:03:56 <kmc> ksf, it's just something i've wanted in the past
13:04:24 <kmc> dunno how usual that is
13:04:28 <kmc> but it would work
13:04:45 <kmc> legonis, note that quite often, things which have to be separate types in Java don't have to be separate types in Haskell
13:04:59 <kmc> in which case this problem just goes away
13:05:46 <kmc> you might be using the translation {Java class => record type, Java methods => functions on that type}
13:06:10 <kmc> but sometimes you can do {Java interface => record type, Java class => function returning that type, Java methods => functions stored in the record itself}
13:06:19 <edwardk> When encoding OOP problems in Haskell. I usually look at a subtyping relationship like foo subclasses bar and rewrite that into a class like class IsaBar t where bar :: t :-> Bar
13:06:32 <edwardk> and then make accessors for each of Bar's fields by composing the basic accessor with bar
13:06:40 <legonis> all I want to do is to map the data, not the code
13:07:08 <kmc> ok
13:07:15 <kmc> well ignoring Java for a bit
13:07:18 <edwardk> and then define an instance IsaBar Bar where bar = id;   instance IsaBar Foo where bar = fooBar
13:07:19 <kmc> what is the data actually
13:07:23 <legonis> so If my first class in the hierarchy has a field which is shared with the rest of my classes, do I have to include it explicitly in every data in haskell?
13:07:51 <sclv> legonis: you might also just want composition.
13:08:02 <kmc> legonis, sounds like you are mapping the code
13:08:06 <kmc> if you're mapping each class
13:08:07 <ksf> classes have no fields in haskell
13:08:10 <sclv> if Name {firstName::String, lastName ::String}
13:08:10 <edwardk> legonis: nah, you can use the schema i just specified and then make something like name :: IsaBar t => t -> String; name = barName . bar
13:08:14 <ksf> they have functions, and functions only
13:08:20 <sclv> then you can have Person {personName :: Name}
13:08:21 <kmc> ksf, ?
13:08:32 <kmc> legonis, i'd start with a language-neutral view of what the data is
13:08:37 <sclv> you need to decide if you want isA or hasA
13:08:41 <edwardk> legonis: but in general if you need all this machiner you're tackling the problem somewhat sideways ;)
13:08:42 <ksf> well, at least not in the java field sense. they're all methods.
13:08:44 <edwardk> er machinery
13:08:49 <kmc> ksf, i don't think he means a haskell class
13:08:53 <ksf> for once, you can't write to them.
13:09:03 <ksf> -c
13:09:09 <legonis> @ksf classes, have no fields, and therein lies my problem, I can uniform the interfaces using them, but they give no provision to actually hold the data 
13:09:29 <kmc> that's what fclabels is for
13:09:44 <kmc> you can make a uniform interface for both accessing and modifying the data
13:09:47 <sclv> legonis: you hold data in a data type. you write functions that operate on data. if these functions are the "same" then you can generalize that in a typeclass.
13:09:47 <ksf> there's no real need in haskell to hold any data
13:10:00 <edwardk> legonis: you need a data type ultimately to hold your values. but you can use classes intelligently to avoid having to name every single field in every single subclass
13:10:02 <kmc> legonis, you've probably noticed that Haskell's "class" is not at all like Java's "class"
13:10:13 <kmc> it's more like Java's "interface"
13:10:26 <edwardk> or in haskell's parlance, every single instance
13:10:35 <kmc> anyway
13:10:36 <kmc> again
13:10:41 <legonis> I understand
13:10:44 <kmc> i don't think translating the Java classes to Haskell is the right way to do this
13:10:50 <legonis> let me paraphrase, I guess I failed to make myself clear 
13:11:00 <Twey> 21:05:55 < edwardk> When encoding OOP problems in Haskell. I usually look at a subtyping relationship like foo subclasses bar and rewrite that  into a class like class IsaBar t where bar :: t :-> Bar
13:11:02 <kmc> if you are only interested in the data
13:11:04 <Twey> edwardk: :->?
13:11:09 <ksf> one way to do this is to show us a java class hierarchy and let us map them.
13:11:15 <kmc> then figure out what the data really is, without reference to Java's peculiarities
13:11:22 <edwardk> Twey: fclabels http://hackage.haskell.org/packages/archive/fclabels/0.4.2.1/doc/html/Data-Record-Label.html
13:11:27 <Twey> Ah
13:11:29 <legonis> yes, I am am going to write a very simple, pedagogical case
13:11:45 <kmc> Java is not a very good OO language, so don't use it as a proxy for generic "OO data model"
13:12:03 <legonis> say I have public class foo { String name; String fooField;}
13:12:04 <ksf> kmc, yes, we all know.
13:12:26 <legonis> and then, public class bar extends foo {String barField;}
13:12:43 <legonis> now I map it to this :
13:13:09 <legonis> data Foo = Foo { name :: String, fooField :: String}
13:13:29 <kmc> data Bar = Bar { myFoo :: Foo, barField :: String }
13:13:31 <legonis> data Bar = Bar {name :: String, fooField :: String, barField :: String}
13:13:46 <kmc> implementation inheritance is just a weird, restricted way to do composition
13:13:47 <ksf> legonis, kmc edwardk http://piratepad.net/hUr8TgzEU7
13:13:49 <legonis> what I would like to avoid is repeating 'name' and 'fooField' in my latter definition
13:14:22 <kmc> the only reason people use it is that some poorly-designed OO languages make it difficult to delegate methods to a component object
13:14:26 <legonis> I understand and agree with the shortcommings of Java and Subtype polymorphisms
13:14:39 <kmc> anyway if you use the composition model
13:14:39 <legonis> but this is a port of an existing application
13:14:50 <kmc> legonis, i'm saying don't bring those shortcomings over to Haskell
13:14:57 <sclv> legonis -- in this case, composition is still the most idiomatic way to do it.
13:15:00 <edwardk> @hpaste
13:15:03 <kmc> anyway when you declare your classes for uniform access
13:15:15 <ksf> edwardk, pastes aren't good for discussions
13:15:23 <shepheb> someone still needs to resurrect lambdabot
13:15:30 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26441#a26441
13:15:41 <edwardk> ksf: in this case its written ;)
13:16:06 <legonis> @sclv so you mean my Bar data should, for example, have a fooSide :: Foo in it ?
13:16:21 <edwardk> legonis: check that paste link i provided
13:16:43 <edwardk> legonis: it'll show you how you could implement a class hierarchy in haskell using fclabels. it isn't the most idiomatic encoding, but it'll get you by
13:17:01 <sclv> legonis: if your example is close to your real code, then yep
13:17:46 <sclv> if its significantly more complex, then fclabels is nicer
13:18:56 <shepheb> I'm having a weird space leak. I've got code roughly like map (\x -> foldl' f x xs) xs
13:19:05 <edwardk> legonis: the version i pasted a link to above shows how to do inheritance by composition. the '.' in there composes two labels and isn't the function composition you expect.
13:19:23 <shepheb> (it's solving a 400-body problem of sorts)
13:20:20 <lispy> shepheb: What have you done to pinpoint the leak?
13:20:38 <lispy> shepheb: Have you read the chapter in Real-World Haskell about optimizing?
13:20:42 <shepheb> profiling shows that code as doing 99.3% of the allocating
13:21:08 <lispy> shepheb: next would be to look at the type of the data, -hy, IIRC
13:21:13 <shepheb> when run, it allocates 10M per iteration or so and eventually gets killed
13:21:20 <sclv> shepb: so that's a 400 x 400 cross product, right?
13:21:44 <lispy> shepheb: It sounds like the solution will be to either increase sharing or add strictness
13:21:54 <shepheb> sclv: maybe? it's a naive model with lists and not aclever one with matrices
13:22:00 <lispy> shepheb: are you using any funny monads like Lazy State?
13:22:03 <sclv> what does f produce?
13:22:09 <olsner> is the foldl' producing a list?
13:22:12 <shepheb> lispy: no
13:22:12 <sclv> a strict value or a lazy value?
13:22:35 <shepheb> no, the foldl' produces a value of the same type as x
13:22:42 <sclv> what type is x?
13:22:45 <legonis> @edwardk thank you. got it. have a good day every one. will be back soon
13:22:54 <edwardk> legonis: happy to help =)
13:23:27 * ksf thinks that encoding should have a preprocessor to generate it
13:23:40 <ksf> ...so I won't do ad-hoc stuff just to avoid typing.
13:23:48 <edwardk> ksf: yeah
13:23:53 <shepheb> x is a custom datatype
13:24:00 <sclv> is it strict?
13:24:16 <shepheb> data Agent = Agent Int Color Double Double Double Double
13:24:22 <shepheb> no?
13:24:24 <edwardk> preflex: xseen ddarius
13:24:24 <preflex>  ddarius was last seen on freenode/#haskell 3 hours, 41 minutes and 10 seconds ago, saying: Too many programmers dismiss, or, more often, are completely ignorant of 1970s technology.
13:24:26 <lispy> shepheb: what is Color?
13:24:37 <shepheb> actually it's Pixel now, from SDL
13:24:49 <shepheb> newtype around Word32, probably
13:25:02 <lispy> shepheb: It's important for us to look at the types of the things in the heap.  We need to figure out if it's thunks or some other intermediate representation using up the space
13:25:16 <shepheb> I'm a profiling newb
13:25:28 <shepheb> +RTS -hhy instead of -p?
13:25:33 <shepheb> -hy, rather
13:25:34 <lispy> shepheb: that's okay.  Have you read the rwh chapter on it?
13:25:38 <shepheb> no
13:25:41 <sclv> shepb -- your first thing to do is to make that data type strict
13:25:48 * ksf needs to redo his URI type
13:25:54 <sclv> add bangs like Agent !Int !Color, etc.
13:26:05 <ksf> it's not like you'd need inheretance, there, but saner nesting
13:26:10 <lispy> shepheb: http://book.realworldhaskell.org/read/profiling-and-optimization.htmlfiling-and-o!
13:26:24 <lispy> that's a broken link
13:26:33 <shepheb> I'll find it, no worries
13:26:36 <lispy> shepheb: http://book.realworldhaskell.org/read/profiling-and-optimization.html  try that one :)
13:26:50 <sclv> the second thing I'd do right away is make the map strict, unless you really want it to be lazy.
13:27:02 <lispy> sclv: I really doubt strictness will help much here
13:27:13 <ReinH> I would like to thank Haskell for helping us get 15th place in the ICFP this weekend.
13:27:16 <lispy> sclv: on the data type I mean
13:27:18 <ReinH> gg all :)
13:27:22 <sclv> lispy -- the strict data type probably will, the strict map probably less.
13:27:46 <sclv> because if he's generating these things, and they have a lazy field, then that holds on to the whole previous iteration until forced, right?
13:27:59 <sclv> so if there's some stuff that never gets forced for whatever reason, then boom.
13:28:26 <sclv> in general, strict data types for core things like that are almost always a win
13:28:43 <sclv> plus then you either manually add unbox pragmas or unbox-strict-fields and you get a performance win there too.
13:29:45 <sclv> the strict map won't help much, i suspect, because in the next iteration the strict fold will force it anyway.
13:30:34 <olsner> wouldn't you get one thunk per foldl' and iteration, since the foldl's themselves aren't getting forced?
13:30:54 <olsner> something like map f (map f (map f etc)))?
13:30:59 <lispy> shepheb: as a long term solution, you'll probably want to switch to vector if your lists are array-like at all
13:31:04 <kmc> hmm so this year's ICFP contest was actually a way to get a bunch of people to work on a class of open problems?
13:31:09 <kmc> http://icfp.gnumaniacs.org/2010/06/21/whats-this-thing-with-cars-and-fuels/
13:31:25 <sclv> kmc: well, only after they reverse-engineered a bunch of compiler errors :-)
13:31:28 <lispy> oh, was that this weekend.  I totally missed it
13:32:36 <sclv> I liked one of the proggit quips: "If I wanted to reverse engineer an obscure and arbitrary protocol from error messages, I'd write a driver for a graphics card."
13:32:49 <kmc> haha
13:33:18 <lispy> ?quote proggit
13:33:27 <lispy> oh right, no lambdabot
13:33:31 <shepheb> hmm. switching to strict fields made it significantly slowr and didn't seem to stop it allocating lotts
13:33:33 <kmc> where's the final rankings page
13:33:40 <sclv> :-(
13:33:41 <benmachine> what is it with haskell things and staying online >_>
13:33:45 <shepheb> I'll read my RWH ad see what happens
13:33:51 <ReinH> kmc: yep
13:33:54 <ReinH> sclv: lol :)
13:34:07 <lispy> shepheb: did adding the strictness make a difference?
13:34:08 <dons> shepheb: -funbox-strict-fields ?
13:34:10 <ReinH> sclv: the ternary protocol bit was the weakest link, agreed
13:34:19 <lispy> dons: !!  Enjoying the solstice?
13:34:40 <ReinH> sclv: but once you got past it, the actual problem was fascinating
13:34:47 <dons> lispy: was very tired yesterday, but enjoying a bit of sun todya.
13:34:52 <sclv> ReinH: right, but I didn't get past it :-)
13:34:58 <dons> lispy: up for reading a bit this week?
13:34:59 <ReinH> the problem is that it was too much of a barrier for so many teams
13:35:00 <ReinH> yeah
13:35:06 <lispy> dons: send it my way!
13:35:09 <dons> ok.
13:35:25 <sclv> To be fair, I was hacking on my own for a limited span of time.
13:35:34 <ReinH> sclv: the contest would have been better without the ternary protocol imo
13:35:50 <ReinH> it was rather arbitrary and petty
13:36:04 <ReinH> but the circuit design and the linear math were really interesting
13:36:24 <Athas> What's the justification for most Haskell projects including a comment header with module and author information?
13:36:25 <monochrom> would have been better without "you must guess the tenary encoding"
13:36:31 <ReinH> monochrom: right
13:36:32 <Athas> Is this some Haddock-related thing?
13:36:44 <sclv> Athas: yep -- that stuff gets pulled into haddock.
13:36:50 <sclv> but its also nice anyway.
13:36:57 <monochrom> But I guess different people have different ideas of what constitutes programming.
13:37:00 <Athas> Even the module name?  Isn't it always evident from the code?
13:37:13 <ReinH> monochrom: exactly
13:37:15 <shepheb> okay, strict fields did fix the space leak. it's running in 6M constant now
13:37:20 <ReinH> monochrom: that was the least interesting part
13:37:20 <monochrom> Some people do say "guessing the user is part of programming"
13:37:23 <ReinH> it was just make-work
13:37:43 <ReinH> I wouldn't say that it isn't "programming", but not all programming is interesting ;)
13:38:04 <ReinH> writing the curl scripts to post solutions was programming, and also very uninteresting
13:38:13 <lispy> dons: cool.  I'll take a look soon.  Probably tonight actually
13:38:35 <tibbe> dons: reading?
13:39:43 <sclv> whee
13:39:50 <sclv> psychic debugging ftw
13:41:32 <olsner> strictness annotations yet again make the difference between running out of memory and producing a sensible result?
13:41:38 <zygoloid> is there an mconcatMap somewhere?
13:41:52 <sclv> zygoloid: not a cannonical one, last I checked.
13:41:56 <sclv> its a oneliner though
13:41:59 <olsner> something like concat <$> mapM
13:42:14 <zygoloid> mconcatMap f = mconcat . map f
13:42:14 <byorgey> zygoloid: perhaps you want Foldable.foldMap
13:42:17 <sclv> olsner: that's for monads -- I assume he wants for monoids.
13:42:24 <benmachine> :t foldMap
13:42:27 <benmachine> oh
13:42:29 <benmachine> :(
13:42:29 <kmc> :t (mconcat .) . map
13:42:29 <sclv> oh, right! I always forget that.
13:42:35 <ksf> technically, I have    data URI = URI { uriScheme :: Maybe String, uriAuthority :: Maybe Authority, uriPath :: Path, uriQuery :: Maybe String, uriFragment :: Maybe String }
13:42:50 <olsner> sclv: ah, right, I'm thinking concatMapM
13:43:01 <sclv> foldMap  :: (Data.Foldable.Foldable t, Data.Monoid.Monoid m) =>      (a -> m) -> t a -> m
13:43:07 <sclv> that'll do it.
13:43:11 <ksf> I'd like to have that more strictly typed, as there are instances where a URI is required to have a Nothing fragment or something
13:43:39 <ksf> but unrolling the data type into each possible combination of Just/Nothing explodes stuff
13:44:05 <sclv> ksf -- use phantom types?
13:44:59 <ksf> ...and smart constructors.
13:45:02 <sclv> type level bools to indicate fields that must be / can't be filled.
13:45:06 <sclv> exactly.
13:45:17 <ksf> trits.
13:45:26 <sclv> the underlying data type can still keep the maybes.
13:45:32 <ksf> there are cases where it's unknown at the type level, e.g. after parsing.
13:45:40 <sclv> ksf: well, if they can be anything, they're just free variables.
13:46:43 <dons> tibbe: phd thesis
13:46:54 <tibbe> dons: interesting!
13:46:58 <tibbe> dons: topic?
13:47:00 <dons> due in a few days, so just finishing up now.
13:47:07 <ksf> data True; data False; or data HasBar; data NoBar?
13:47:07 <tibbe> k
13:47:08 <dons> dynamic extension of haskell
13:47:12 <tibbe> right
13:47:15 <dons> plugins, eval etc.
13:47:30 <ksf> typed kinds would be great.
13:47:32 <dons> then my summer opens up for containers hacking, i think.
13:47:44 <byorgey> ksf: working on it. =)
13:49:49 <ksf> zomfg everthing's going to be even more complicated, resolved vs. unresolved dns, whether the regname is a dns-resolvable in the first place, reverse lookup, ipv4 vs. ipv6...
13:51:48 <olsner> hmm, maybe you rather want some kind of ... extensible records?
13:52:05 <Athas> Anyone know of a Haskell interface to the POSIX TTY control functions?
13:52:19 <Athas> (I don't expect it.)
13:52:25 <ReinH> sclv: ping
13:52:36 <sclv> pong
13:54:45 <sclv> ReinH: yes?
13:54:59 <ReinH> sclv: so, as a fellow ICFP competitor, I have a question
13:54:59 <ksf> I don't think phantom types blend well with fclabels
13:55:19 <sclv> go on
13:55:22 <ReinH> sclv: would you consider yourself to be a good idiomatic haskell programmer?
13:55:43 <sclv> dunno, I suppose?
13:55:44 <ReinH> (that's not the question, it's just a lead-up)
13:56:22 <ReinH> sclv: I'd be interested in seeing an experienced haskeller's refactoring of our solution code. I thought you might be interested in seeing the solution code.
13:56:44 <ReinH> I suspect we could be doing some things far more cleanly by using monads, etc
13:56:45 <sclv> ReinH: sure. not sure I'll have time to refactor it, and certainly not today (about to take off from work)
13:56:51 <ReinH> sclv: nod
13:57:01 <sclv> I'd imagine that you could post it to -cafe and get a nice discussion going.
13:57:01 <ReinH> sclv: even a brief writeup of "I would do this like x and this like y"
13:57:09 <ReinH> sclv: that sounds interesting too
13:57:17 <ReinH> sclv: I'll bring that up to my team
13:57:29 <ReinH> sclv: I suspect we'll do that and then I'll ping you about it :)
13:57:43 <sclv> in fact, a little blog post (with some -cafe publicity) seems like the best idea. I love reading the blog retrospectives :-)
13:57:59 <ReinH> sclv: was planning on a retrospective and I know my other team members were as well
13:58:26 <ReinH> I feel like I'm on the cusp of grokking higher order haskell programming
13:58:37 <sclv> I found monads very helpful for maintaining the state of the simulator, and for generating random circuits.
13:58:38 <ReinH> and this could help push me over, you know?
13:58:45 <sclv> but I didn't get any further...
13:59:00 <ReinH> sclv: we basically implemented a monadic car factory
13:59:04 <ReinH> one sec
13:59:17 <ReinH> but we didn't actually use a monad
14:00:02 <byorgey> did people like the contest?  I read the task when it came out but didn't participate this year
14:00:16 <chrisdone> Should've used an Arrow™
14:00:37 <sclv> byorgey: there's been lots of grousing about the makework that set the barrier to entry high. apparently, after that, it got quite interesting.
14:01:20 <byorgey> ok, that's kind of what I guessed after reading the task description =)
14:01:21 <sclv> also, the setup unfortunately left them open to/encouraged spamming the server
14:01:33 <byorgey> ah, that's too bad
14:02:20 <ReinH> byorgey: I liked most of the contest
14:02:30 <olsner> if it weren't for all the reverse-engineering I might have made a half-hearted attempt at the actual problem
14:03:14 <ReinH> byorgey: there was a barrier to entry that was very arbitrary and possibly even petty: reverse-engineering an arbitrary encoding in a "trit stream" by making server requests and parsing the errors you received
14:03:30 <ReinH> which prevented a lot of teams from even making it out of the gate
14:03:46 <shivam3013> hey
14:04:04 <ReinH> basically we spent all of friday and most of saturday solving an uninteresting programming task that most teams never even solved, before we ever got to the *very* interesting problem underneath
14:04:08 <ReinH> so that was lame
14:04:13 <sclv> so quick performance question -- if profiling shows that I'm spending all my time in M.unionWith, does that indicate that I should want a unionWith', or what?
14:04:40 <shivam3013> does anyone here know how to code
14:04:48 <sclv> Or does it indicate that my maps are too small and sorted assoclists would be more efficient?
14:04:49 <EvanR-work> no
14:05:10 <shivam3013> does anyone here know how to code 
14:05:11 <chrisdone> shivam3013: church or godel?
14:05:19 <shivam3013> pardon?
14:05:29 <sclv> I'm just using unionWith (+) so I assume it's the unionWith itself that's eating my time?
14:05:30 <chrisdone> seems you don't know how to code! get out of here!
14:05:34 <ksf> ReinH, see, I am long since wise enough to not even attempt to solve such tasks.
14:05:38 <shivam3013> actually i do
14:05:48 <ReinH> sclv: for instance, this is the bottom of our "car generation" code: https://gist.github.com/6930102f8ae482760712
14:05:58 * EvanR-work encodes shivam3013 
14:06:17 <ReinH> sclv: I think it's very obviously monadic in nature, but I'm not sure how to write it using the clever syntax ;)
14:06:19 <shivam3013> ...
14:06:25 <sclv> chrisdone: I prefer hamming myself :-)
14:06:30 <shivam3013> so does anyone here know how to code except ksf?
14:06:40 <ReinH> ksf: yes, I wish we could have spent more time on the interesting problems
14:06:51 <ReinH> ksf: but I'm glad we persevered on the encoding problem
14:06:52 <ksf> shivam3013, I don't even know what a zygohistomorphic prepromorphism is.
14:06:59 <sclv> ReinH: see MonadRandom on hackage.
14:07:05 <ReinH> sclv: hmm
14:07:12 <shivam3013> lol
14:07:16 <ReinH> sclv: I looked at that but didn't grok how to implement it
14:07:19 <EvanR-work> huffman
14:07:33 <olsner> ksf: you'll learn, in time :)
14:07:56 <shivam3013> practice makes perfect
14:08:08 <Baughn> How would you write "exists a. Show a => [a]", but with a concrete type instead of the variable?
14:08:26 <sclv> ReinH: here's how I used it to do my quick and dirty circuit generation code (well, part of it) for example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26444#a26444
14:08:45 <chrisdone> Baughn: shamefully?
14:08:51 <Saizan_> Baughn: ?
14:08:56 <shivam3013> thats a wierd code
14:09:03 <sclv> Just added that data type for sgstate as well
14:09:07 <Baughn> Saizan_: chrisdone has it right, I suppose..
14:09:28 <Baughn> Saizan_: I was thinking about ixset while I was on vacation.. and then I got to thinking about ways to implement it.. and then...
14:09:29 <shivam3013> that is certainly not coding
14:09:35 <ksf> looks like a perfectly fine braindump.
14:09:39 <shivam3013> as you forgot the atserik
14:09:41 <olsner> Baughn: [a], where a = concrete type?
14:09:43 <ndxtg> I have a question. Let say a "partial" function f :: Int -> Int -> Bool; do I have to put brackets around i.e. f :: Int -> (Int -> Bool) ?
14:09:44 <sclv> reinH: http://www.haskell.org/haskellwiki/New_monads/MonadRandom
14:09:56 <Baughn> olsner: Without losing the existential quantification part of it
14:10:11 <Saizan_> Baughn: so you want to pack the dictionary but not the polymorphism? 
14:10:11 <shivam3013> thats impossible
14:10:19 <Baughn> Saizan_: Yep! ^_^
14:10:25 <shivam3013> considering it requires a lot of modurification
14:10:27 <Baughn> Saizan_: On record accessors, to be precise.
14:10:45 <Saizan_> Baughn: ok, "keeping the existential qualification" is a very weird way to put it :)
14:10:50 <Baughn> Saizan_: GHC can't do it, but I'd like to at least know what the type should be
14:11:05 <shivam3013> existential quantification would be very rare in terms of modurification
14:11:11 <Baughn> Saizan_: ..for the moment, I'm getting around the issue with reallyUnsafePointerEquality.
14:11:39 <olsner> hmm, but why would you want to do that?
14:11:40 <EvanR-work> existential pontification
14:11:41 <Saizan_> Baughn: i'm not sure i see the motivation for this
14:11:54 <shivam3013> that has very low chance of succeeding
14:12:01 <shivam3013> d
14:12:19 <shivam3013> as it interferes with its natural hidronific velocity
14:12:29 <byorgey> ndxtg: no, you don't
14:12:34 <shivam3013> hydronific*
14:12:42 <byorgey> Int -> Int -> Bool is exactly the same as Int -> (Int -> Bool)
14:12:54 <shivam3013> byorgey you are very random
14:12:58 <byorgey> the former is just an abbreviation for the latter.
14:13:10 <shivam3013> i don't even comprehend a bit of your speaking genre
14:13:30 <shivam3013> implyfying the rest
14:13:37 <Baughn> Saizan_: It's so I can say "get :: IxSet a -> (a -> b) -> a", with the second parameter a record accessor (for a).. and get the /right a/.
14:13:38 <sclv> ReinH: and the nice thing is, if I went further, I could have swapped MonadRandom for List (although, the order of the two monads is probably backwards) and then gotten something that generated all possibilities rather than a single random one.
14:13:40 <byorgey> @where lyah
14:13:50 <AmunRa> Hello! I'd like to request some more functions to be provided in Data.ByteString and Data.ByteString.Lazy ...  is there a an official channel for this? (I'm happy to contribute with code too)
14:13:56 <Saizan_> Baughn: data ShowD a where Dict :: Show a => a; then you have "(ShowD Foo, [Foo])" where Foo is your concrete type
14:14:21 <byorgey> AmunRa: your best bet is probably the libraries@haskell.org mailing list.
14:14:23 <Baughn> Saizan_: Now do it for functions, and make them callable. :P
14:14:30 <tromp_> @hoogle Writer
14:14:35 <Saizan_> Baughn: which functions?
14:14:44 <sclv> AmunRa: Generally you talk it around and see if its a good idea, then get in touch with the maintainers. Very often, if the functions don't need to be in core, then you might be encouraged to write a small seperate library instead.
14:14:47 <sclv> modularity ftw
14:14:53 <Baughn> Saizan_: Record accessors, but I shouldn't think that matters.
14:14:59 <Saizan_> Baughn: err, it was data ShowD a where Dict :: Show a => ShowD a, of course
14:15:01 <ndxtg> byorgey: does it just apply for 3 arguments or any number of arguments? i.e. is Int -> Int -> Int ->Int -> Bool equivalent to Int -> (Int -> (Int -> (Int -> Bool))) ?
14:15:11 <byorgey> ndxtg: any number, and yes.
14:15:19 <Saizan_> Baughn: can you give me the type?
14:15:25 <ndxtg> byorgey: cool, thank you
14:15:26 <byorgey> ndxtg: we say that -> "associates to the right"
14:15:43 <dons> AmunRa: in general, you want to propose the functions, explain why they should be added to the library -- they must be of general utility.
14:15:46 <Baughn> Saizan_: Basically, I'm using the accessor function as an index - for "data Foo = Foo { a, b, c :: String }", I want a function (Foo -> a) -> Int that returns 0 for a, 1 for b and 2 for c
14:15:48 <byorgey> ndxtg: on the other hand if you want  (Int -> Int) -> Bool  then of course you must explicitly write the parentheses.
14:15:52 <shivam3013> I CAN PROGRAM HASKELL
14:16:00 <shivam3013> apologize for caps.
14:16:13 <Saizan_> Baughn: i mean, you can use anything you want in place of [] and Show there
14:16:14 <Baughn> Saizan_: To which the "obvious" solution is to attach a ditionary to the function, and have /it/ carry the int along
14:16:21 <shivam3013> you guys are weid
14:16:38 <ndxtg> and you are troll
14:16:44 <ReinH> sclv: I think seeing part of that code rewritten using MonadRandom, for instance, would be the missing key in my search for grokkitude
14:16:46 <Baughn> Saizan_: And I don't know the type, which was rather the problem, except that it must still be a function type - the accessor must still be usable /as an accessor/
14:16:53 <ReinH> sclv: I'm having trouble getting there on my own
14:17:01 <ReinH> will continue to endeavour
14:17:06 <AmunRa> sclv: Yes, it is a fair point.. but some libs, I believe should also cater for ease of use.. namely I think it would be best to have an efficient commonly accepted implementation of `trim` and `replaceAll`
14:17:37 <Baughn> Saizan_: ..reallyUnsafePointerEquality /works/, but gives runtime errors if the Foo -> String function I pass it is not, in fact, one of the three accessors.
14:17:45 <Baughn> When it should be possible to detect at compile-time.
14:18:10 <sclv> ReinH: gotcha. I'm gonna take off for now though. Cheers.
14:18:28 <ReinH> sclv: no worries, you aren't obligated to do my work for me ;) cheers
14:18:29 <Baughn> Saizan_: I should mention, the same trick can be used to make lenses look much nicer. :3
14:18:49 <Baughn> @index reallyUnsafePointerEquality
14:19:23 <tromp_> hmm, i cant find the Writer Monad on http://www.haskell.org/ghc/docs/6.12-latest/html/libraries/index.html
14:19:54 <byorgey> tromp_: the Writer monad isn't in the base libraries
14:20:00 <byorgey> it's in mtl or transformers
14:20:17 <Saizan_> Baughn: that it's still applayable as a normal function is the fundamental requirement, i guess?
14:20:40 <Baughn> Saizan_: Right.
14:20:44 <tromp_> is there like a standard place of online docs for that?
14:20:48 <ReinH> wow
14:21:06 <c_wraith> tromp_, hayoo and hoogle are search engines that would help you out
14:21:19 <byorgey> tromp_: yes, the docs are all on Hackage
14:21:31 <c_wraith> hoogle understands the type system better, but hayoo's index is much larger.
14:21:42 <tromp_> @hayoo Writer
14:21:57 <c_wraith> I meant the web sites.  :)  http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:21:59 <shivam3013> !quit
14:22:24 <tromp_> thx, c_wraith
14:23:15 <Baughn> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26447#a26447 <-- So basically, this is the code I don't want to write.
14:23:18 <Saizan_> Baughn: it'd be possible if we could index typeclasses by functions :) i wonder if we can get that behaviour with some trickery
14:24:26 <Baughn> Saizan_: I don't think it can be done without attaching data to the /function/. There's nothing stopping anyone from writing a "Foo -> String" function of their own, after all.
14:24:45 <Athas> What's usual custom for doing low-level wrappers of C functions that use -1 and errno to report errors?
14:24:58 <Athas> I'm thinking an Either type where Left will contain the errno value.
14:25:01 <Athas> Is this kosher?
14:25:03 * ksf scratches another mark into #haskell. one more troll driven to insanity.
14:25:08 <c_wraith> It's common enough, Athas.
14:25:22 <kmc> i think it's more common to throw an exception
14:25:38 <kmc> but perhaps that's better left for the higher-level binding
14:25:39 <Athas> That's the alternative, yes.  I could just put strerror(errno) in an exception.
14:26:01 <kmc> look all over e.g. System.Posix source
14:26:04 <kmc> they do that
14:26:15 <c_wraith> I guess it depends on how recoverable the error condition is.
14:26:20 <kmc> createDirectory name mode = withCString name $ \s -> throwErrnoPathIfMinus1_ "createDirectory" name (c_mkdir s mode)
14:26:25 <kmc> why?
14:27:34 <c_wraith> I was going to say "it's more code to recover from an exception" but it's really not.  handling eithers is pretty verbose, too.
14:28:03 <Saizan_> Baughn: imagine if we could write "accessorIndex :: (f :: (a -> b)) -> SomeClass f => Int", 
14:29:57 <Baughn> Saizan_: You mean "accessorIndex :: SomeClass f => (f :: (a -> b)) -> Int"?
14:30:46 <Saizan_> Baughn: that'd be a out of scope error the way i see it, but that's the sense
14:30:58 <Saizan_> Baughn: note how 'f' is a value there :)
14:31:11 <Baughn> Well, yes, it's supposed to be..
14:31:24 <Saizan_> anyhow, we don't get any close to that in haskell
14:31:25 <Baughn> Saizan_: I can't even parse yours. Not sure what that means, though. :P
14:31:42 <illissius`> if you could do that you could also declare monoid instances (for instance) for functions rather than datatypes and not have to newtype everything
14:32:12 <Saizan_> > let foo :: () -> Show a => a -> String; foo () = show in foo () 1
14:32:48 <Baughn> Saizan_: ..function arrows in the typeclass clause?
14:32:55 <Saizan_> no
14:33:11 <Saizan_> foo :: () -> (Show a => (a -> String))
14:33:20 <Saizan_> typeclass contexts in the result type :)
14:33:39 <Baughn> Oh!
14:33:45 <Baughn> Right-associativity strikes again.
14:33:48 <Saizan_> requires FlexibleContexts in fact
14:33:55 <Saizan_> yup :)
14:36:43 <kmc> CS is the study of boxes and arrows
14:38:56 <BMeph> It's fun - and funny - when the trolls resort to gibberish that they hope looks plausible, but is just hopelessly obvious gibberish. That's another thing I love about Haskell; we aspire to a higher class of gibberish! :D
14:39:03 <tensorpudding> The box has an arrow: "this side up"
14:39:37 <illissius`> tensorpudding: i was thinking more like "you hide in the box from the people shooting arrows"
14:39:43 <endojelly> tensorpudding, that is a really cool nick.
14:40:08 * chrisdone changes nick to: teslagravy
14:40:21 <endojelly> I did some type programming: http://dl.dropbox.com/u/6617799/foo.hs
14:40:30 <illissius`> and, um, if they get too close you put -them- in the box to neutralize them
14:40:32 <endojelly> oh no wait.
14:41:39 <endojelly> http://dl.dropbox.com/u/6617799/TypeProgramming.hs
14:41:41 <endojelly> this is what I meant
14:41:59 <endojelly> I know this has been done a lot before, but I wanted to see if I can figure it out myself
14:42:08 <djahandarie> God damn I hate when my browser trys to download stuff rather than just display it
14:42:11 <endojelly> only compiles with -fglasgow-exts, though
14:42:38 <c_wraith> You really should use LANGUAGE pragmas
14:42:42 <endojelly> I wasn't able to figure out the language option that causes contexts in instance declarations to be honored in the method bodies?
14:42:53 <endojelly> does anyone know which one it is?
14:43:03 <endojelly> c_wraith, I did, if you look at the top of the file, there are a lot
14:43:12 <endojelly> but I couldn't find that one
14:45:26 * hackagebot STMonadTrans 0.3 - A monad transformer version of the ST monad  http://hackage.haskell.org/package/STMonadTrans-0.3 (JosefSvenningsson)
14:46:11 <c_wraith> What?  doesn't STT imply time-travel?
14:46:53 <EvanR-work> haskell has time travel support now
14:47:06 <c_wraith> oh, yay!
14:47:28 <djahandarie> > "hi"
14:47:33 <djahandarie> :-(
14:47:52 <EvanR-work> djahandarie: lambdabot evaluated that yesterday and you werent here
14:48:26 <djahandarie> > ":-)"
14:48:28 <haskellbot>  ":-)"
14:48:50 <djahandarie> Only has mueval though, none of the type stuff or anything
14:49:01 <djahandarie> Haven't bothered porting that stuff over to my saner bot
14:49:18 <benmachine> > typeOf foldMap
14:49:19 <haskellbot>  Not in scope: `foldMap'
14:49:20 <EvanR-work> backup bot. now we dont have to use Twey
14:49:25 <benmachine> > typeOf Data.Foldable.foldMap
14:49:26 <haskellbot>  Ambiguous type variable `a' in the constraint:
14:49:28 <benmachine> :(
14:49:38 <benmachine> that makes sense I guess
14:49:47 <djahandarie> Apparently only prints out the first line of the error too
14:49:57 <benmachine> > System.IO.Unsafe.unsafePerformIO (return ())
14:49:57 <haskellbot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
14:50:02 <djahandarie> It's mueval
14:50:07 * benmachine standard test
14:50:40 <benmachine> > Unsafe.Coerce.unsafeCoerce () :: Int
14:50:41 <haskellbot>  Not in scope: `Unsafe.Coerce.unsafeCoerce'
14:50:42 <Baughn> @ask jmcarthur http://patch-tag.com/r/jmcarthur/overloaded-whitespace/ <-- Do you have a copy of this anywhere else?
14:50:47 <benmachine> ok you win this time :P
14:52:49 <ndxtg> http://codepad.org/sKRIxpu9 <---- does any one know why this maybe monad doesnt work?
14:53:53 <benmachine> ndxtg: you should find that >>= and return are already defined
14:54:04 <benmachine> oh no wait
14:54:08 <benmachine> I see what you're doing
14:54:16 <benmachine> ndxtg: you need to declare an instance of the Monad class
14:54:26 <benmachine> instance Monad MaybeOK where
14:54:36 <benmachine> and then your definitions of return and >>=, appropriately indented
14:55:22 <ndxtg> benmachine: right, it works now, thank you
14:55:51 <EvanR-work> MaybeOK MaybeNotOK
14:56:03 <Botje> True, False, FileNotFound
14:56:06 <monochrom> Haskell Platform from Source on Unix-Like: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
14:56:11 <EvanR-work> instance Monad WhateverWorks
14:56:27 <EvanR-work> Botje: troolean logic
14:57:04 <monochrom> droolean logic is the logic of droolers :)
14:58:33 * hackagebot zeromq-haskell 0.3.1 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.3.1 (ToralfWittner)
14:59:25 <illissius`> data Bool = True | False | Pancakes
15:02:12 <Twey> c_wraith: Not for lazy ST, I think
15:04:07 <Botje> illissius`: agree.
15:10:04 <McManiaC> hmmm
15:10:15 <McManiaC> why can't I post to the haskell-cafe mailing list?
15:10:27 <McManiaC> You are not allowed to post to this mailing list, and your message has
15:10:28 <McManiaC> been automatically rejected.
15:10:43 <McManiaC> where can I check my subscriptions?
15:10:45 <ivanm> McManiaC: are you registered to it?
15:10:50 <McManiaC> I think I am
15:10:57 <ivanm> http://haskell.org/haskellwiki/Mailing_lists
15:10:57 <Twey> McManiaC: It doesn't like your hair
15:11:19 <ivanm> Twey: oh, they enabled that feature did they?
15:11:37 <Twey> Yeah, it hijacks your webcam and takes pictures to compare
15:11:38 <McManiaC> twanvl: :(
15:11:57 <Twey> If you don't have a webcam, it assumes you don't want people looking at your hair, and rejects you automatically
15:11:59 <McManiaC> ivan: I get all the mails every day, so I guess I'm subscribed?
15:12:30 <twanvl> McManiaC: :)
15:12:58 <McManiaC> twanvl: oh... wanted to highlight Twey :)
15:13:10 <twanvl> that happens a lot
15:13:59 <Twey> Yeah :-\
15:15:55 <ndxtg> is import SomeModule (func1) equivalent to import SomeModule.func1 ? 
15:16:13 <benmachine> ndxtg: the first one will work and the other one will not
15:16:40 <ndxtg> benmachine: ? how about import Data.Bool ?
15:16:58 <monochrom> the whole module name is Data.Bool
15:17:00 <benmachine> ndxtg: that imports a module called Data.Bool
15:17:07 <Twey> c_wraith: Oh, it's not so nice
15:17:10 <benmachine> it doesn't import Bool from Data
15:17:17 <monochrom> consider import Data.Bool(Bool)
15:17:20 <Twey> c_wraith: « Warning! This monad transformer should not be used with monads that can contain multiple answers, like the list monad. The reason is that the will be duplicated across the different answers and this cause Bad Things to happen (such as loss of referential transparency). Safe monads include the monads State, Reader, Writer, Maybe and combinations of their corresponding monad transformers. »
15:17:46 <ndxtg> oh so actually Data is a module of modules ?
15:17:56 <Twey> ndxtg: Data is just a module namespace
15:18:02 <ReinH> Is there any code in the wild using MonadRandom? I'd love to see it in action.
15:18:14 <Twey> A name can be both a module and a module namespace
15:18:21 <monochrom> Indeed, if you have "module Foo.Foo where data Foo = Foo", you can import Foo.Foo(Foo(Foo))
15:18:40 <benmachine> in principle STT doesn't need time travel because everything ST does is reversible
15:18:40 <ReinH> better question: "where can I find such code"?
15:18:43 <monochrom> There is a Buffalo joke here. :)
15:18:44 <ndxtg> ok I think I have got it clear :) thanx guys
15:18:48 <benmachine> it's just efficient STT that needs time travel
15:18:49 <Twey> But Data isn't a module on its own — you can't ‘import Data’
15:19:08 <ReinH> monochrom: buffalo from Buffalo do not buffalo. Your argument is invalid :)
15:19:56 <benmachine> ReinH: http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html this may come in handy
15:20:24 <benmachine> ReinH: to be precise, http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/MonadRandom-0.1.4#direct
15:20:51 <ReinH> benmachine: oh, reverse dependency lookup. Brilliant!
15:21:02 <ReinH> benmachine: I was wondering why you were pointing me there :)
15:21:03 <aristid> hmm toTitle
15:21:04 <McManiaC> ivan: ok, looks like somehow the list forgot about my registration... works again :)
15:22:15 <ReinH> benmachine: I always learn best by reading other people's code (and then trying it myself a lot). Thanks a lot :)
15:22:30 <ReinH> hmm, I said a lot a lot.
15:24:45 <monochrom> import "alot-alot" ALot(ALot(ALot))
15:26:43 <Twey> import qualified "alot-alot" ALot (ALot (ALot)) as ALot
15:27:27 <aristid> oO
15:27:31 <benmachine> import qualified "as" As (As (as)) as As
15:28:40 <monochrom> Oh, I be damned. "as" is not reserved!
15:28:43 <Esteth> Heya #haskell. I'm trying to compile a program with GHC, and I'm getting heaps of undefined symbol errors. I've installed the haskell platform, so I'm pretty sure I have the Network module, for instance, but GHC seems to hate me. Is there something obvious I might have missed? A quick google didn't turn up anything.
15:28:44 <benmachine> :)
15:29:15 <benmachine> Esteth: hmm, which program, and how are you compiling it?
15:29:28 <benmachine> undefined symbol errors sound like a missing C library?
15:29:41 <Esteth> compiling with "ghc -o messenger main.hs", I'll pastie the program, just a sec...
15:29:53 <Philonous> Esteth: try ghc --make
15:29:56 <monochrom> ghc --make -o messenger main.hs
15:30:01 <benmachine> yeah, --make is magic
15:30:10 <roconnor> @instances ArrowLoop
15:30:18 <monochrom> because otherwise you would have to list every package used manually
15:30:36 <Esteth> Thanks. magic wizardry prevails again! :)
15:44:43 <danharaj> "Let Over Lambda is one of the most hardcore computer programming books out there.... Only the top percentile of programmers use lisp and if you can understand this book you are in the top percentile of lisp programmers."
15:44:48 <danharaj> That is so pretentious.
15:46:25 <cdsmithus> yes, not the way to make me want to read the book.
15:47:41 <ddarius> "Closure-Oriented Programming"
15:47:47 <monochrom> For every programmer P, there exists a metric M, P is in the top percentile according to M.
15:48:08 <ddarius> "Let over lambda is a nickname given to a lexical closure."
15:48:09 <FauxFaux> Annoyingness. \o/
15:48:15 <monochrom> Proof: let M be distance from P's name
15:48:42 <quaestor> 00:47 < monochrom> For every programmer P, there exists a metric M, P is in the top percentile according to M.
15:48:45 <quaestor> 00:47 < ddarius> "Let over lambda is a nickname given to a lexical closure."
15:48:48 <quaestor> 00:47 < FauxFaux> Annoyingness. \o/
15:48:49 <quaestor> whoops
15:50:33 <lowasser> Someone remind me, don't we have some tool that automatically infers a function body from its type, for simple types?
15:50:58 <micahjohnston> djinn
15:51:02 <gwern> djinn? but it sucks
15:51:10 <lowasser> that's okay
15:51:11 <gwern> there is magichaskeller also
15:51:15 <aristid> @djinn (a -> b) -> a -> b
15:51:24 <aristid> oh right
15:51:27 <aristid> dang
15:51:36 <micahjohnston> it was fun to get it to make the S combinator and then it got boring :P
15:51:52 <Saizan> djinn works for the subset of haskell types that correspond to first order propositional instuitionistic logic, roughly
15:52:16 <aristid> Saizan: -s?
15:52:22 <ddarius> gwern: Why does Djinn suck?
15:52:25 <Saizan> micahjohnston: it's quite fun with the Cont r monad :)
15:52:28 <Saizan> aristid: yeah
15:52:41 <gwern> ddarius: because it can do so little, but people hear about it and expect it to do more
15:52:43 <micahjohnston> Saizan: I couldn't get it to work with typeclasses
15:53:08 <ddarius> I'm happy with what it can do, and if one wanted to it could be extended to heuristically do more.
15:53:49 <Saizan> micahjohnston: well, if you specialize it to the Cont r there shouldn't be much typeclasses involved, but yeah djinn only really works with non-constructor classes, i.e. those for types of kind *
15:54:41 <aristid> Saizan: no idea what "propositional intuitionistic logic" is, though.
15:54:59 <monochrom> haskell sucks. people hear about it and expect it to do more. like printing money for your web 2.0 startup.
15:55:03 <jacobian> wikipedia calls
15:55:03 <danharaj> Logic without excluded middle or quantifiers.
15:55:21 <ddarius> http://books.google.com/books?id=8PpDSu4vLuQC&printsec=frontcover&dq=inductive+program+synthesis&source=bl&ots=Say6cJBp_g&sig=Y91OfwtQAXl51Q0qZQux-fZTlNU&hl=en&ei=X-0fTKHOOMP48AahhJSQDA&sa=X&oi=book_result&ct=result&resnum=5&ved=0CDgQ6AEwBA#v=onepage&q=inductive%20program%20synthesis&f=false
15:55:32 <danharaj> monochrom: I thought web 2.0 was dead.
15:57:25 <aristid> danharaj: that's because it's web 3.0 now \o/
15:57:32 <monochrom> depression 2.0 brought it back
15:57:44 <aristid> ddarius: what a beautiful book cover.
15:58:04 <ivanm> aristid: it is? when did they announce that?
15:58:13 * ivanm thought it was still web 2.1
15:58:18 <aristid> ivanm: well, it's not announced yet. top secret.
15:58:25 <ivanm> oh, right
15:58:32 * ivanm runs before aristid can kill him
15:58:45 <ddarius> Web 2.71828
15:58:57 <aristid> ivanm: we will hunt you, and trust us: one day, you WILL be dead.
15:59:01 <monochrom> "in soviet russia, wikipedia calls you"?
15:59:08 <ivanm> wow, zdnet was talking about web 3.0 back in 2006
15:59:13 <aristid> might take 70 years tho
15:59:26 <ivanm> even though some one else called web 2.1 "web 2007" :s
15:59:38 <monochrom> web prime
16:02:33 <jmcarthur> Baughn: i probably do. patch tag dead?
16:03:49 <tensorpudding> it's back up
16:04:07 <Baughn> FSVO "up"
16:04:12 <Baughn> I now get "repo not found"
16:04:22 <tensorpudding> oh wait, down again
16:04:40 <tensorpudding> "repo hazy, try again later"
16:07:13 <jmcarthur> Baughn: lemme put this repo somewhere public
16:09:17 <jmcarthur> would using `scp -r' be equivalent to using `darcs put'? the server i want to put this on doesn't have darcs on it
16:09:32 <jmcarthur> a web server, i mean, and presumably it would work fine through http
16:09:45 <jmcarthur> for `darcs get'
16:09:47 <dancor> what would haskell be like with manual memory management?
16:09:58 <jmcarthur> dancor: pretty strange
16:10:00 <Baughn> dancor: Unpossible
16:10:06 <dancor> would it be able to do hard realtime?  would it be faster?  would laziness be craziness?
16:10:12 * jmcarthur shrugs and tries with scp
16:10:19 <tensorpudding> how could you manage memory in a lazy language?
16:10:24 <newsham> f r@(x:xs) = free r >> return xs
16:10:25 <Baughn> jmcarthur: scp is fine so long as the repo doesn't change while scp is running
16:10:29 <dancor> well what manual memory management functional langs are there
16:10:45 <dons> tensorpudding: isn't memory management fundamentally lazy?
16:10:47 <jmcarthur> Baughn: cool
16:10:51 <dons> you allocate stuff when you need it, and not before.
16:10:56 <dons> unless you're a kernel.
16:11:00 <tensorpudding> true
16:11:11 <newsham> what about preallocated pools?
16:11:13 <newsham> free lists?
16:11:18 <Baughn> jmcarthur: Odd thing about scp, though, it tends to stall at the end of each file.
16:11:19 <dancor> dons: what if you want to do hard realtime or (maybe?) be faster
16:11:27 <Baughn> jmcarthur: rsync /doesn't/, so you can treat it as a faster scp.
16:11:38 <dons> dancor: you try to do as much statiiically as possible
16:11:43 <jmcarthur> Baughn: doesn't seem to do that for me
16:12:01 <newsham> if you were doing manual memory management seems like you'd have to throw out having pure functions
16:12:02 <dons> but that's an optimization for performance reasons, not semantics.
16:12:05 <Baughn> jmcarthur: Maybe it's only noticable with a high bandwidth*latency product
16:12:05 <jmcarthur> woops, i should probably clean the build dir and stuff first
16:12:10 <newsham> since you'd constantly have to be doing imperative frees
16:12:28 <dons> newsham: why? its a locally scoped ST operation
16:12:45 <dons> runST mymemoryrequest $ operations
16:12:46 <newsham> ok, so monadic (ST) at least..
16:12:51 <dons> the effect won't escape the scope
16:13:03 <dons> this is very similar to region based memory
16:13:36 <dancor> isn't region-based memory management completely crazy
16:13:41 <newsham> you wouldnt get to write little   f [] = 0; f (_:xs) = 1+f(xs)
16:13:53 <jmcarthur> Baughn: darcs get http://jake.devio.us/darcs/overloaded-whitespace
16:13:57 <newsham> you'd have to lift em into ST at least
16:15:13 <jmcarthur> Baughn: that was the first time i'd ever used haskell-src-exts or uniplate, and it's also not well-tested, so use at your own risk
16:15:30 <Baughn> jmcarthur: Ah. Somehow, I was hoping for a ghc patch..
16:15:36 <jmcarthur> ah sorry
16:15:41 <Baughn> Nah, it's fine
16:15:48 <dancor> right now it seems like you use haskell until you need something like hard realtime or more performance and then you use c.  but it seems like there is probably some intermediary area that would be good..
16:16:06 <Baughn> What I'm trying to do.. it can't be done. Not in Haskell, anyway.
16:16:07 <dancor> i.e. a non-GC'd functional lang
16:16:26 * Baughn pokes his reallyUnsafePtrEquality#-based implementation and sweatdrops
16:16:40 <jmcarthur> Baughn: what are you trying to do?
16:16:51 <danharaj> I bet he's trying to unsafeWalkIntoMordor
16:17:31 <Baughn> jmcarthur: For data Foo = Foo { a,b,c :: Bar }, I'm trying to write a function index :: (Foo -> a) -> Int that returns 0 for a, 1 for b, 2 for c and a compile-time error for any other function with that type..
16:17:39 <jmcarthur> dancor: you use haskell for hard realtime anyway using Atom :)
16:18:06 <dancor> jmcarthur: is atom good
16:18:11 <aristid> hah.
16:18:20 <jmcarthur> dancor: it's used in industry
16:18:26 <aristid> there are exactly 12 characters for which toTitle is not the same as toUpper
16:18:33 <jmcarthur> i know that doesn't necessarily say anything, but that's all i know :)
16:18:51 <jmcarthur> Baughn: are a, b, and c supposed to be A, B, and C?
16:19:02 <Baughn> jmcarthur: No.
16:19:07 <jmcarthur> oh wait
16:19:14 <jmcarthur> those aren't types
16:19:15 <FunctorSalad> toTitle works on characters? :o
16:19:16 * jmcarthur teh dum
16:19:21 <FunctorSalad> singleton I assume
16:20:06 <Baughn> FunctorSalad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24074 <-- Here's what I've got at the moment.
16:20:06 <aristid> FunctorSalad: yes
16:20:22 <Baughn> er
16:20:23 <jmcarthur> Baughn: okay, so you intend to pass the a, b, or c accessors to index?
16:20:27 <Baughn> FunctorSalad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26447 <- This, I mean
16:20:31 <Baughn> jmcarthur: Right.
16:20:36 <aristid> :t toTitle
16:20:36 <aristid> toTitle :: Char -> Char
16:21:09 <Baughn> jmcarthur: Ideally they'd be instances of some class which is defined /differently/ for a, b and c, but that would require lexical instances. :P
16:22:20 <cdsmithus> The first paste was interesting...
16:22:32 <Baughn> cdsmithus: It's a review reply for a fanfiction.
16:22:38 <Baughn> Admittedly a very good one, but not really on topic.
16:23:14 <Saizan> Coq's "typeclasses" would work here :)
16:23:31 <FunctorSalad> hmm, hadn't read the context... thought we were talking about toTitle "foo of the bars" -> "Foo of the Bars"
16:23:49 <jmcarthur> i've got an idea
16:23:50 <aristid> FunctorSalad: no, Data.Char's toTitle
16:23:56 <jmcarthur> lemme try it
16:24:04 <aristid> FunctorSalad: i expected the same before i looked at the type
16:24:17 <dcoutts> freenod: if the HEAD version of Cabal and cabal-install do not work with the HEAD version of ghc then I'd be interested to know.
16:24:53 <dcoutts> freenod: (I'm the maintainer of Cabal and cabal-install)
16:25:14 <jmcarthur> dang, autogenerated TH code... didn't notice that
16:25:35 <jmcarthur> Baughn: so you're absolutely wanting this to work without introducing extra types or anything?
16:26:28 <Baughn> jmcarthur: I'm perfectly fine with extra types, but I want it to work without extra /values/ - the standard ADT accessors should be used, and while modifying GHC is fine, they should still work as /accessor functions/.
16:26:32 <jmcarthur> Baughn: because the only way i see it would fail at compile time is if you either introduce new types or you perform a check using TH
16:26:44 <Baughn> jmcarthur: Problem is, the "modify GHC" step is getting pretty daunting, with all the prerequisites
16:27:06 <jmcarthur> Baughn: ah, so they shouldn't change to (a :: Foo -> A) or anything, where we have (newtype A = A String), right?
16:27:12 <Baughn> Right
16:31:27 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:31:27 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Jun 07 12:23:51 2010]
16:31:27 --- names: list (clog zakwilson teukka Gracenotes Grey_Fox danharaj_ JaffaCake1 RogueShadow1 jesusmiguel ccasin AndChat- robertmassaioli Stalafin Bigglotron jsgf LouisJB dysinger lowasser1 BMeph agricola zachk JoesphL0t hadronzoo rl sigh _gaffer m3ga digitteknohippi1 confounds lispy der_eq Esteth Darkone anRch jb55 dual harinath Raynes tux21b haskellbot yashton gjl cloudhead tensorpudding xinming_ ErhardtMundt mwc saccade winxordie Walt travisbrady ddarius solidsnack)
16:31:27 --- names: list (Itkovian ikke bos31337 jon_of_arc go|dfish Mortomes zax Saizan miclorb arjanb shaleny FunctorSalad MrFahrenheit LeNsTR pickles illissius` Baughn absentia c_wraith toekutr Bobrobyn wli therp perspectival SonOfLilit Blkt flazz akosch thetallguy conal dixie mindeavor achelous Modius emmanueloga s76_ endojelly Saterus pookleblinky regalia carlocci neurogeek||m zeussphinx Eridius freenod andyjgill lbc mtnviewmark_afk rizzix lopex gwern saiam Bleadof samulihs)
16:31:27 --- names: list (dogmaT jd10 bos stephenjudkins Amadiro fmardini thorkilnaur ville jsdelfino mrsolo lihaitao Philonous dfkjjkfd gogonkt birkenfeld IIcke dkc jmelesky milan` emmanuelux grahamalot SyntaxNinja siracusa jacobian gbeshers Alabarda trez yairchu ankit9 triplez cyanoacry ozamosi|netbook caligula_ fxr metasyntax savonarola Philippa Buglouse IceDane asap18 ivanm GuilOooo mlh zeiris Shown nniro janbanan cognominal welterde CompanionCube Exteris ryanakca jayne mxc)
16:31:27 --- names: list (jendap shortcircuit mpiechotka The_third_man BorisL ksf m0nkfish Lycurgus dju JeroenW arnihermann rdd hackagebot novas0x2a1 occamshatchet snhmib amiri scm otto_s_ mae kmc kadoban fonz MacCoaster Innominate otulp guenni69 Berengal jekor Mathnerd314 eagletmt theorbtwo helgikrs rokoteko seafood AnMaster vili plediii_ Axman6 mauke htoothrot cozmic preflex monochrom Dashkal int-e qz makmanalp dleslie ski jonafan bremner Sgeo DrSyzygy tridactyla mk64ftw_ maskd)
16:31:27 --- names: list (sbok bnonym mahogny m4thrick PepeSilvia Paradox924X integral Nereid prince alexbobP Apocalisp EvanR-work srh Cale jamwt mm_freak myu2 ikeg ibt objorn ybit chromakode elzurk nchaimov Igloo hgolden dancor sm Cthulhon alip smorg orbitz ptrf muhtimin pkrumins pielgrzym chid|away luite tomaw twobitsprite smly- ath Ytinasni Twey Garen lsthemes coonsta kniu jvoorhis MadX` biiter deavidsedice ReinH mle naota pprakash Veinor tamiko niksnut jlouis fpletz Riviera waern)
16:31:27 --- names: list (seric sshc peddie sclv lastebil joga dcoutts Twigathy sjanssen Botje iizukaway wagle tltstc dMazz Lajla nominolo dmwit TML kalven BrianHV shadowspar electrogeek blackdog alexsdutton fabjan kermit dv- chitragupt PsiOmega twn_ QtPlatypus dcolish emias djahandarie anders^^ wto xian drk-sd alexsuraci cods duairc dumael stroan profmakx olsner eno ibid Vindy bd_ joed johnny_ozone Draconx ClaudiusMaximus `0660 felipe_ SimonRC araujo Taggnostr a11235 eamelink)
16:31:27 --- names: list (slabanja ennen solrize mjrosenb HugoDaniel kolmodin nzfrio tessier Nanar bbee eldragon suiside tromp_ Deltaf1re newsham max_atreides dobie_gillis cizra rdrake uorygl dreacu666 stepnem cjay jmcarthur nothingmuch dino- wjt zsol StoneToad hzh earthy quasimodo_ eintopf gspr nornagon erg Jonno_FTW ve palmje Boney clanehin emma yahooooo byorgey epokal desu samferry sahazel ahihi etpace dreixel obraun trzkril ingy encryptio megaTherion flori andrewsw Khisanth)
16:31:27 --- names: list (eevar_ thetallguy1 saccade_ yrlnry Counter-Strike shajen fab__ geekounet levitation[A] drbean stenobot2010 ehamberg LionMadeOfLions Handheldo ido Jon tilman tafryn And[y] lenbust EvanR cypher- bgs100 dayz pettter canvon inr edwinb aavogt Deewiant mafs p_l davidL baaba theclaw mattam snr_ sproingie _br__ icee_ majoh kaol Reisen impl boyscared jvogel shutdown_-h_now andersk Rooz jsk npouillard ernst nlogax quicksilver arw_ kennethd_ davean norm2782 pwerken)
16:31:27 --- names: list (jmv_ muep Choko Raku^ ixzkn mfoemmel temp Guest42356 Yahovah AnAdorableNick Obfuscate Hunner beatmox dropdrive Sisu elliottcable bqf burp bill`` RyanT5000 teratorn ToRA igorgue_ kevinclark wolverian Fingerzam noddy dejones yottis Ornedan karld drhodes Fireknight hellige ahf eyck Vulpyne companion_square gds Liskni_si Laney noj mietek gereedy tab jbauman edwtjo Lemmih shachaf MrDomino idnar Gilly pimeys_ jdsc osfameron b4taylor benmachine tumult Cerulean)
16:31:27 --- names: list (magicman dqd Jiten Jaak jml ps-auxw Heffalump neme4ta sohum tvaalen OnionKnight creichen quaestor exDM69 benc__ Gabbie FauxFaux regulate __marius__ qebab Ferdirand willb matthew-_ pastorn kar-1 clarkb ezyang jesusabdullah SubStack Starfire Tomas BONUS Blub\0 alpounet aiko_ untwisted zygoloid sebbe1991 PHO_ tao| guerrilla opqdonut gdsx Vq DustyDingo Tinned_Tuna danderson chr1s_ LeoD flux lostman kosmikus Zao saurik shepheb Stephan212 hiredman dwon_ mike-burns)
16:31:27 --- names: list (nasloc__ mercury^ nimred defn cynick koninkje_away jrockway epmf skaar albertos1ntini rhlampe ziman Ke aleator taruti jql jix Aikawa vpetro erk__ McManiaC cYmen dax hc_e tew88 aristid allbery_b harlekin laz0r mrshoe dilinger mrd thoughtpolice @ChanServ)
16:31:28 <Baughn> Saizan: I want this perfect, dang it. ;_;
16:31:36 <jmcarthur> i think new types would be perfect
16:31:54 <Saizan> newtypes are quite decent, yeah
16:32:03 <jmcarthur> i would be upset if i could pass a function as a parameter but constructing my own function that does the same thing causes an error
16:32:30 <jmcarthur> so it makes perfect sense to me that the parameter would be a special type
16:32:39 <Baughn> Right, that makes sense to me too
16:32:42 <Saizan> (and you don't even need to change the definition of your ADT to use the newtypes)
16:32:58 <Baughn> ..it's just, I want the /functions/ to be those special types. But still functions.
16:33:21 <Saizan> right, but haskell is not enough dependently typed yet :)
16:33:22 <jmcarthur> Baughn: you could have a function that transforms them into functions
16:33:34 <jmcarthur> get A myFoo
16:33:36 <Baughn> jmcarthur: Then existing code would break
16:33:49 <jmcarthur> no way
16:33:56 <jmcarthur> existing code can still use the original functions too
16:34:20 <Baughn> ..well, ideally it'd be /replacing/ the original functions...
16:34:39 <jmcarthur> why ideally?
16:34:48 <Baughn> Namespace pollution is a bad thing?
16:35:06 <jmcarthur> i think if you want type checking then you need types, but that's just me ;)
16:35:58 <Baughn> Right, so we need a way to change the type of a function that still lets it stay a function.
16:36:16 <Baughn> Contexts, as it were.
16:36:30 <jmcarthur> why not just make it so you can say (index A) but also (get A myFoo) *and* (a myFoo)?
16:36:43 <jmcarthur> why does it have to be the *function* that you pass to index?
16:37:05 <Baughn> Principally, so people don't have to /think/ about picking one
16:37:18 <aristid> has anybody been tracking how much "dependend types" has been said? was it always such a popular topic? just wondering.
16:37:52 <kmc> aristid, i'll have an answer for you in a bit
16:46:02 <Saizan> aristid: in the past it was just "typeclass hackery" then GADTs and later typefamilies came and the connection got more obvious
16:47:00 <aristid> Saizan: did kmc say something? seems like there has been a netsplit
16:47:00 <kmc> @quote jwz
16:47:05 <kmc> aristid, still coding
16:47:12 <c_wraith> I found a typo in tibbe and bos's paper!  Which, otherwise, is quite great. :)
16:47:13 <aristid> kmc: ah, that's why
16:47:54 <aristid> Saizan: matrices parametrised by their length were probably known somewhat earlier, tho?
16:48:36 <djahandarie> Finding typos in Haskell-related papers seems to be a reoccurring theme
16:48:57 <glenker> does anyone know of a way of looking up arbitrary haskell functions? google appears to be useless for non-ascii operators like "*<>"
16:48:58 <djahandarie> Although the other one I'm thinking about was a code typo
16:49:05 <djahandarie> glenker, hoogle
16:49:10 <djahandarie> Or hayoo
16:49:41 <Saizan> aristid: those were (or are?) done with typeclass hackery yeah, which evoked prolog/logic programming more than anything else
16:49:41 <ksf> @hoogle String -> Int
16:49:50 <ksf> @botsmack
16:50:10 <ksf> seems to be partying hard, again.
16:50:15 <djahandarie> Maybe I should add more stuff for next time lambdabot goes down :P
16:50:53 <c_wraith> This paper really is great: "After several weeks of research, heated discussion, hacking, epic debugging, and with casualties including one whiteboard, Si- mon Marlow performed a wholesale replacement of GHC’s black hole mechanism."
16:51:01 <kmc> haha
16:51:06 <kmc> why does Text.Regex have this crackhead API anyway
16:51:07 <djahandarie> Yeah I remember reading that heh
16:51:24 <kmc> which paper c_wraith
16:51:37 <Saizan> kmc: they tried to emulate Perl, succesfully it seems
16:51:37 <djahandarie> It's that one about the new IO manager
16:51:40 <kmc> ah
16:51:41 <ksf> kmc, because it's insane
16:51:43 <ivanm> kmc: so you can do heaps of stuff with it
16:52:02 <kmc> ivanm, but i could specify what i want to do the usual way, by choosing a function
16:52:10 <ivanm> after all, if you want the number of matches, why should you have to get the list of matches and calculate the length?
16:52:11 <djahandarie> Or maybe just do one thing multiple different ways
16:52:13 <kmc> that's how every other library that does heaps of stuff works
16:52:14 <ksf> it's perfectly possible to give an applicative syntax to regexen, there's no need for typeclass trickery.
16:52:21 <aristid> kmc: i'm curious what you will present to me :)
16:52:29 <ivanm> kmc: I'm not saying it's a good API... ;-)
16:52:48 <sproingie> it's really hard to replace a black hole.  can't see what you're doing.
16:52:53 <c_wraith> kmc:  http://www.serpentine.com/bos/files/ghc-event-manager.pdf
16:52:55 <kmc> thanks
16:53:10 * ivanm heads off to uni
16:53:17 <c_wraith> You probably found it already, but I figured I'd throw it out there for completeness' sake :)
16:54:08 <glenker> hmm, hoogle and hayoo doesn't seem to know what "*<>"
16:54:18 <glenker> im getting it from: http://pastebin.com/6e1nHPy0
16:54:25 <djahandarie> glenker, then it might not be in a hackage package
16:55:23 <Saizan> glenker: start looking for Data.Vector modules, maybe
16:55:33 <djahandarie> Probably from the Parallel stuff
16:55:41 <djahandarie> Since I don't think that is on hackage
16:55:43 <djahandarie> Not sure though
16:57:35 <Saizan> the only Data.Vector module hayoo finds is not about linear algebra
17:01:52 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26450
17:01:56 <chrisdone> ;D
17:03:07 <Saizan> :O
17:10:47 <aristid> kmc: can you please save the DT stuff? it's sleeping time for me now
17:10:53 <kmc> save?
17:11:07 <kmc> sorry i'm having trouble with the server i've got logs saved on
17:11:15 <kmc> bug me about it later
17:11:33 <aristid> yeah that's just fine given i'm going off now
17:11:37 <kmc> me too actuall
17:11:38 <kmc> ttyl
17:12:32 <aristid> ah, yeah, had to look it up... ttyl
17:29:39 <andrewsw> hrmm.. I have a list of values and a list of functions to apply to *each* value. I'd like back a list of lists of results.
17:29:53 <andrewsw> map . swing . map [f's] [v's]?
17:30:56 <aavogt> @type sequence [succ,pred] 2
17:31:03 <aavogt> > sequence [succ,pred] 2
17:31:03 <haskellbot>  [3,1]
17:31:26 <andrewsw> ah
17:31:34 <aavogt> oh, that's not exactly what you're asking
17:31:41 <aavogt> how to collect them up?
17:31:46 <ddarius> > map (sequence [succ, pred]) [1..10]
17:31:47 <haskellbot>  [[2,0],[3,1],[4,2],[5,3],[6,4],[7,5],[8,6],[9,7],[10,8],[11,9]]
17:32:04 <aavogt> > do f <- [succ,pred]; x <- ['a','b']; return (f x)
17:32:05 <haskellbot>  "bc`a"
17:32:17 <aavogt> > do f <- [succ,pred]; x <- [1,2]; return (f x)
17:32:17 <haskellbot>  [2,3,0,1]
17:33:04 <andrewsw> ddarius: that's it I think
17:33:05 <andrewsw> thanks
17:33:10 <andrewsw> both of you
17:34:50 <Axman6> printf doesn't have an escape to show things that have just a show instance does it?
17:35:29 <Saizan> iirc it does
17:35:30 <Axman6> like printf "this is my type which implements Show: %@" x
17:35:35 <Axman6> oh?
17:35:42 <Axman6> :t printf
17:35:54 <Axman6> lambdabot!
17:35:58 <Axman6> :'(
17:36:39 <Saizan> maybe i'm thinking of some of the alternative printf's
17:46:54 <ddarius> @type map . sequence
17:51:44 <SailorReality> fact n = (if (n==0 || n==1) then 1 else n*(fact (n-1)))
17:54:44 * Axman6 prefers: fact n = if n < 2 then 1 else n*(fact (n-1))
17:54:57 <Axman6> or, even better, a tail recursive case
17:55:23 <blackdog>  someone really ought to write a fibonacci package so no-one need ever write one again.
17:55:39 <infinity0> i'm a noob to haskell. how do i make "cabal install" not attempt to recompile everything from scratch after making a 3-line change in a source file?
17:55:43 <wli> Please don't make me.
17:56:12 <wli> fact n | n < 0 = undefined | n < 2 = 1 | otherwise = n * fact (n-1)
17:56:16 <blackdog> infinity0: it'll only recompile everything it needs to.
17:56:17 <Axman6> fact n | n < 2 fact' n 0 1 | otherwise = 1 where fact 0 x y = x; fact' n x y = fact' (n-1) y (x+y)
17:56:32 <Axman6> fact n | n < 2 = fact' n 0 1 | otherwise = 1 where fact 0 x y = x; fact' n x y = fact' (n-1) y (x+y)
17:56:33 <Saizan> infinity0: how are you using it, specifically?
17:56:33 <infinity0> blackdog: well it's still taking ages working out what it should or shouldn't be compiling
17:56:37 <Axman6> fact n | n < 2 = fact' n 0 1 | otherwise = 1 where fact' 0 x y = x; fact' n x y = fact' (n-1) y (x+y)
17:56:55 <dcoutts> infinity0: you can avoid the step where it looks at dependencies and installs files by using: just cabal build
17:57:02 <infinity0> i've checked out gitit from its repo on github, ran "cabal install", made a few changes, then ran "cabal install" again
17:57:10 <infinity0> dcoutts: ah ok thanks
17:57:10 <benmachine> Axman6: fact 2 = 1?
17:57:11 <blackdog> if you change something at the base level that other code depends on, those files will have to be recompiled too
17:57:31 <Axman6> fact n | n > 2 = fact' n 0 1 | otherwise = 1 where fact' 0 x y = x; fact' n x y = fact' (n-1) y (x+y)
17:57:34 <Axman6> >_>
17:57:39 <Axman6> used to writing it the other way
17:57:57 <dcoutts> infinity0: and if you do configure -O0 then that builds with optimisation turned off, in turn that tends to mean far fewer cross-module dependencies and thus less rebuilding
17:58:01 <benmachine> >= itym
17:58:10 <infinity0> oh ok
17:58:11 <Axman6> yeah
17:58:25 <Axman6> fact n | n > 1 = fact' n 0 1 | otherwise = 1 where fact' 0 x y = x; fact' n x y = fact' (n-1) y (x+y)
17:58:36 <Axman6> fact n | n > 1 = fact' n 0 1 | otherwise = 1 where fact' 0 x y = x; fact' !n !x !y = fact' (n-1) y (x+y)
17:58:57 <dcoutts> infinity0: since with -O1 (which is the default for cabal configure/install), ghc does lots of cross-module inlining which means more stuff has to be recompiled when you make minor changes
17:58:59 <Axman6> gogoiOS4!
17:59:20 <infinity0> hmm, the change i'm making isn't a dependency of anything else, though
17:59:41 <blackdog> Axman6: have you upgraded? am a bit wary, bos lost all his music...
17:59:51 * benmachine ponders how to structure his FFI code - is it sensible to keep any of .hs, .hsc, .c, .h separate and if so which?
17:59:59 <Axman6> blackdog: about to, just doing a backup
18:00:35 <Axman6> i just sync all my music, so doesn't really matter if its lont on the iPhone
18:00:45 <aavogt> infinity0: between modules inside the package
18:01:13 <Axman6> and updating
18:02:44 <Axman6> Cale: where's lambdabot? :(
18:04:21 <SailorReality> what the hell haskell just computed 1000! in like 3 seconds
18:04:38 <aavogt> > product [1..1000]
18:04:39 <haskellbot>  402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136
18:04:48 <aavogt> does it actually take 3 seconds?
18:05:25 <aavogt> haskellbot: you shouldn't print so much at once
18:05:27 <Axman6> > product [1..10000]
18:05:27 <haskellbot>  284625968091705451890641321211986889014805140170279923079417999427441134000376444377299078675778477581588406214231752883004233994015351873905242116138271617481982419982759241828925978789812425312059465996259867065601615720360323979263287367170557419759620994797203461536981198970926112775004841988454104755446424421365733030767036288258035489674611170973695786036701910715127305872810411586405612811653853259684258259955846881464304255898366
18:05:38 <aavogt> or silently truncate
18:05:41 <wli> Please stop.
18:06:00 <djahandarie> You know
18:06:08 <Saizan> who owns haskellbot?
18:06:09 <djahandarie> I whiped that up in like 5 minutes so give me a break :P
18:06:10 <djahandarie> Me
18:06:32 <aavogt> > print "o hai"
18:06:32 <haskellbot>  No instance for (GHC.Show.Show (GHC.Types.IO ()))
18:06:53 <djahandarie> It uses mueval just like lambdabot
18:06:55 <aavogt> > Debug.Trace.trace "yes?" ()
18:06:56 <haskellbot>  Not in scope: `Debug.Trace.trace'
18:07:28 <djahandarie> I'll improve it a bit for next time around
18:07:42 * hackagebot bitspeak 0.0.2 - Writing helper for those with Stephen Hawking like impairment.  http://hackage.haskell.org/package/bitspeak-0.0.2 (MauricioAntunes)
18:07:51 <Saizan> installing lambdabot was too painful?
18:08:20 <djahandarie> Basically.
18:08:57 <gwern> @wn obstance
18:26:26 <BrianHV> I just attempted my first haskell "project" of any "substance": a connect 4 game.  I'd appreciate any input on how to do it better or more idiomatically, or how to make my main function work: http://gist.github.com/447796
18:27:16 <BrianHV> (I know gravity is sideways.  that's a future project.)
18:27:45 <benmachine> BrianHV: for your main, try
18:27:53 <benmachine> hmm
18:28:20 <benmachine> basically, in an IO do-block, the stuff on the right hand side of a <- should be IO stuff
18:28:24 <BrianHV> there are two different attempts commented out.  but I couldn't get anything more than a one-liner to work
18:28:36 <BrianHV> ok
18:28:53 <benmachine> if it's not IO stuff you can just do let board = addToBoard emptyBoard 2 Red
18:29:34 <BrianHV> I could have sworn I tried that.  this time it worked.
18:30:24 <BrianHV> ok... so if I do getChar, I have an IO Char.  how do I get that into a digit that I can pass to addToBoard?
18:30:31 <BrianHV> an Int, rather
18:30:35 <benmachine> oh I added a comment but it ate my formatting
18:30:45 * benmachine deletes comment
18:30:48 <benmachine> ok so
18:31:05 <benmachine> just do
18:31:11 <benmachine> columnChar <- getChar
18:31:20 <benmachine> let column = digitToInt columnChar
18:31:28 <BrianHV> the formatting was right in the email gist sent me
18:31:32 <benmachine> heh
18:31:33 <benmachine> ok
18:32:08 <benmachine> you can also do, fmap digitToInt getChar
18:32:13 <benmachine> but that's a bit more complicated
18:32:38 <benmachine> so I wouldn't until you understand how to do it "the easy way"
18:32:55 <BrianHV> "the easy way" makes some sense now.  thanks!
18:33:24 <benmachine> np
18:34:40 <BrianHV> any thoughts on the rest of it?  parts feel awkward to me, but I don't know how much of that is unfamiliarity, and how much is because it's not very good code.
18:35:00 <BrianHV> addToColumn feels especially awkward
18:35:51 <benmachine> hmm
18:36:30 <tromp_> :t showHex
18:36:37 <benmachine> you have gravity going from right to left?
18:36:49 <BrianHV> benmachine: I consider that a display issue. ;)
18:36:59 <benmachine> well I mean
18:37:15 <benmachine> when you drop a new piece in, it goes on the end of the list?
18:37:25 <benmachine> I'd not do that, I'd put it on the beginning of the list
18:37:26 <BrianHV> no, on the head
18:37:44 <benmachine> addToColumn seems to keep the first n pieces the same
18:37:52 <BrianHV> if they're not Nothing
18:37:58 <benmachine> yeah
18:38:38 <BrianHV> so you start with [N,N,N,N,N,N,N].  the first piece you drop, takeWhile takes nothing, then append the piece, so you get [JR,N,N,N,N,N,N]
18:39:13 <benmachine> ok so you've added a piece and you've got your column as [R,N,N,N]
18:39:14 <BrianHV> the next piece, takeWhile takes the JR, appends JB, and then appends 5 Ns
18:39:23 <benmachine> right
18:39:41 <benmachine> so you have your columns arranged bottom [piece,piece,piece] top
18:39:51 <benmachine> right?
18:40:24 <benmachine> which is backwards in my view
18:40:31 <benmachine> should be top [piece,piece,piece] bottom
18:40:43 <benmachine> in fact
18:40:49 <benmachine> you don't even need the Maybe at all, I think
18:41:00 <benmachine> emptyColumn = []
18:41:04 <BrianHV> well, I considered just making it a stack...
18:41:05 <Axman6> is there a name for this idiom? f (x:y:xs) | x `op` y = f (x:xs) | otherwise = f (y:xs)?
18:41:24 <BrianHV> but then I realized that the display code would need to pad everything out anyway
18:41:41 <Axman6> a lot of my students used it this semester, i thought it was kind of odd
18:41:53 <BrianHV> and I further considered the game board to be analagous to something like chess, where a stack-based board wouldn't make sense
18:42:03 <benmachine> BrianHV: leave that up to your display code, I think
18:42:21 <benmachine> hmm or maybe you're right I'm not sure
18:42:33 <benmachine> it's just that if you did it as a stack you wouldn't need all these Maybes and Nothings
18:42:41 <BrianHV> yeah
18:42:42 <tromp_> how do you write a section of (,) ??
18:42:45 <benmachine> and addToColumn would basically be (:)
18:42:56 <benmachine> tromp_: before GHC 6.12 it wasn't possible
18:43:11 <benmachine> tromp_: with 6.12, -XTupleSections lets you do the obvious thing
18:43:26 <benmachine> and also some less obvious things like (,,,7,4,,'c')
18:44:21 <benmachine> BrianHV: or, you could use an Array, but maybe that wouldn't be any better
18:44:34 <tromp_> thx, benmachine
18:45:27 <BrianHV> benmachine: if I could change an element in the array without having to append it to itself twice like I'm doing now, it would probably help
18:46:41 <benmachine> BrianHV: I still think that stacks are the way to go
18:46:58 <BrianHV> you may be right
18:47:00 <benmachine> maybe pairs of (stack, height of stack) to save you calculating the length all the time
18:47:15 <BrianHV> I was thinking of the column as a Nothing-padded stack, but it might not be worth it
18:47:28 <benmachine> if you do it as a stack you don't need any padding
18:49:02 <SailorReality> Axman: what class do you teach?
18:49:17 <benmachine> BrianHV: I think intercalate "" is concat, btw
18:49:20 <Axman6> i'm a tutor for a first year comp course at the ANU
18:49:40 <BrianHV> benmachine: hah.  you're probably right. :)
18:50:01 <benmachine> also, there exists a concatMap
18:50:13 <gwern> @src concat
18:50:24 <gwern> dammit
18:51:00 <BrianHV> there does indeed exist a concatMap
18:51:07 <BrianHV> which works as expected
18:51:43 <benmachine> BrianHV: interesting thing about ordering function parameters:
18:51:48 <BrianHV> obviously I haven't written much haskell, but in my reading I've gotten the sense that a lot of code starts to turn into combining functions
18:52:00 <benmachine> compare Piece -> Board -> Board with Board -> Piece -> Board
18:52:11 <benmachine> the nice thing about the former is that you can partially apply a Piece to it
18:52:17 <benmachine> and get a function that transforms Boards
18:52:19 <aavogt> flip is nice
18:52:37 <benmachine> this is probably going to be more useful than partially applying a Board to make a function that turns Pieces into Boards
18:52:41 <tromp_> funny, i'm writing something similar this very minute
18:52:43 <tromp_> dfs :: PawnMap -> [(PawnDist,PromsCaps)] -> Writer String PawnMap
18:52:49 <benmachine> heh
18:52:50 <BrianHV> benmachine: very good point
18:53:09 <benmachine> BrianHV: it's not vitally important but it makes composing things a little neater :)
18:53:09 <tromp_> and pawncaps :: PawnState -> [PawnState]
18:54:57 <BrianHV> tromp_: I imagine haskell could model chess pretty elegantly
18:55:20 <gwern> I dunno. the rules of chess are kind of complex and arbitrary
18:55:22 <tromp_> it models go pretty well
18:55:25 <gwern> now, Go, would beelegant
18:55:46 <djahandarie> Why? Because Go is complex and arbitrary also? :P
18:55:48 <tromp_> http://homepages.cwi.nl/~tromp/go/SimpleGo.hs
18:56:27 <gwern> djahandarie: the rules of go, I'd argue, are much simpler than chess
18:56:32 <gwern> that's why you have a larger board :)
18:57:01 <djahandarie> You know, I totally thought you were talking about Go the programming language there
18:57:09 <gwern> what
18:57:10 <tromp_> i'm not implementing rules of chess. just counting pawn structures
18:57:33 <benmachine> BrianHV: http://gist.github.com/447809 I haven't typechecked this or anything but it's kind of how I might do things
18:58:39 <tromp_> funny, you display Columns horizontally?
18:58:44 <benmachine> (annoying thing: writing l + 1 and realising the two characters look EXACTLY IDENTICAL).
18:58:55 <benmachine> tromp_: yeah, we can fix that later :P
18:58:55 <tromp_> i'd call them ranks then
18:59:10 <benmachine> it's only that way because that way is easier
18:59:19 <tromp_> that looks like connect4
18:59:21 <BrianHV> benmachine: it looks like you did something with case that would have made my addToBoard much simpler (as geeky as the recursive solution was...)
18:59:34 <BrianHV> tromp_: it's supposed to. ;)
18:59:53 <benmachine> BrianHV: well, the clever bit was using splitAt
19:00:11 <benmachine> which just comes of knowing more library functions I suppose
19:00:18 <tromp_> http://homepages.cwi.nl/~tromp/c4/Fhourstones.tar.gz has connect4 in haskell ...
19:00:23 <tromp_> using bitmaps
19:00:35 <benmachine> the case was to handle an error which probably won't happen anyway (and you didn't handle before I don't think)
19:01:27 <tromp_> with bitmaps you can test for a win with a few shifts and or's
19:02:37 <benmachine> that's neat
19:02:51 <benmachine> but with lists I guess you can mirror that with a few zips and conses
19:03:16 <benmachine> or something
19:03:23 <gwern> benmachine: I think the point is that there's probably an order of magnitude or two difference in speed
19:03:28 <tromp_> the bitmap tests all locations in parallel
19:03:44 <benmachine> gwern: oh sure, because I really need to find out who won connect 4 *now*
19:03:55 <benmachine> ...I suppose it'd be useful for AI >_>
19:03:58 <gwern> benmachine: yes! you do!
19:04:05 <gwern> hurry hurry hurry
19:04:26 <tromp_> i made the haskell as strict as i cld, and as close to the C version as i cld
19:04:32 <tromp_> but it's like 50 times slower still:(
19:04:40 <gwern> as the cock crew, those who stood before / the tavern cried, open then the door! / you know how little while we have to say / and once gone may return no more
19:05:08 <gwern> *stay
19:05:13 <Saizan> tromp_: tried -fvia-C ?
19:05:28 <tromp_> no, i havent
19:05:32 <tromp_> nor with llvm
19:05:44 <gwern> Saizan: I doubt -fviaC or llvm are going to buy him 50x or even 25x
19:06:08 <tromp_> well, one huge cause of slowdown was library calls for 64 bit ops
19:06:11 <Saizan> who knows, they might do a very good job for bit twiddling
19:06:59 <benmachine> test: Socket creation error (control socket): failed (Success)
19:07:03 * benmachine <3 errno
19:07:06 <tromp_> i think the test for a win function itself was over 20 times slower
19:07:23 <tromp_> and that only does some shifts and or's on 64 bit ints
19:07:30 <BrianHV> benmachine: thanks for the help.  it's just about bedtime for me.
19:07:44 <benmachine> BrianHV: long past mine :(
19:07:49 <Axman6> tromp_: writing C in haskell usually isn't a good idea, unless you know what you're doing
19:08:33 <tromp_> well, i did make it a bit nicer
19:09:15 <tromp_> like define the game tree as a static lazy entity
19:09:24 <tromp_> to be only partially expanded by alpha beta
19:10:11 <tromp_> but i also wanted identical results
19:10:27 <tromp_> since it's a benchmark
19:11:24 <robertmassaioli> at the llvm comment: who knows, llvm does alot of optimisation, it may very well do some amazing stuff. We'll know when we try it out.
19:11:43 <BMeph> tromp_:If you're leaving marks on benches, you should see a Doctor... ;
19:12:49 <Axman6> tromp_: ok, if you want a benchmark, write it the haskell way, then try and do the same in C ;)
19:13:13 <tromp_> i wrote the c long before i knew haskell:(
19:13:13 <Axman6> trying to make apple juice out of oranges probably isn't going to work too well
19:13:42 <EvanR> is it possible for an algorithm to compare two graphs for equality
19:14:41 <tromp_> if they're labelled, yes
19:14:53 <tromp_> otherwise it's graph isomorphism
19:15:05 <tromp_> which has no efficient solution
19:15:15 <EvanR> the nodes are labeled
19:15:32 <tromp_> uniquely?
19:15:37 <EvanR> no
19:16:03 <Saizan> robertmassaioli: the GHC NCG is also quite new, so it lacks quite a few standard ones
19:17:00 <EvanR> tromp_: but if the nodes stay in one place i guess you could use the memory address of the nodes
19:17:08 <EvanR> :S
19:17:27 <EvanR> but two may be labeled the same
19:17:36 <tromp_> u want equality on labels, not on memory address:(
19:17:48 <EvanR> ah right
19:17:54 <EvanR> its two different graphs
19:18:34 <tromp_> i'm going home...
19:18:38 <tromp_> g'night folks
19:18:40 <EvanR> bah
19:18:44 <gwern> whenever I hear about graphs, I cringe
19:18:52 <gwern> it seems like *nothing* is efficient when it comes to graphs
19:19:58 <BMeph> EvanR: Dude, just check the pointers! <ducks>
19:20:34 <bremner> graph isomorphism is not too bad in practice for moderate sized graphs.
19:21:01 <bremner> look for nauty (C) and bliss (C++)
19:21:21 <bremner> @hoogle nauty
19:23:05 <dancor> how can you make this shorter:
19:23:09 <dancor> nqueens :: (FDConstraint s ~ Constraint (TreeSolver tree), Show (FDTerm s), Eq (FDTerm s), Term (TreeSolver tree) (Expr (FDTerm s)), MonadTree tree) => Int -> tree [Expr (FDTerm s)]
19:23:21 <dancor> ?
19:23:28 <Axman6> leave the type sig out :P
19:23:38 <dancor> lolnation
19:23:55 * BMeph thinks that one's better than "Chop off its feet!"... ;)
19:24:11 <gwern> I don't believe I've ever seen tildes in a type sig before
19:24:13 <gwern> what's that?
19:24:32 <aavogt> type equality
19:24:50 <aavogt> there are some type families going on
19:25:00 <gwern> eek
19:25:15 <dancor> http://www.haskell.org/haskellwiki/GHC/Type_families
19:25:29 <gwern> @remember gwern when all you have is a condom, every problem looks like something you can safely have sex with
19:25:41 <aavogt> @botsnack
19:25:51 <BMeph> dancor: Have you considered making FDTerms Show and EQ elsewhere? ;)
19:26:25 <EvanR> you cant just quote yourself like that
19:26:32 <gwern> EvanR: obviously I can
19:26:36 <gwern> since I just did
19:26:39 <Saizan> dancor: nqueens :: (solver ~ TreeSolver tree, FDConstraint s ~ solver, term ~ FDTerm s, Show term, Eq term, Term tree (Expr term), MonadTree tree) => Int -> tree [Expr term] -- somewhat shorter
19:26:48 <Axman6> gwern: no you didn't
19:27:01 <gwern> I didn't?
19:27:13 <Axman6> no, lambdabot's dead
19:27:16 <gwern> is there some other gwern which I quoted? perhaps I should get this treated
19:27:18 <EvanR> lol
19:27:18 <mun_> hi
19:27:41 <mun_> does higher-order logic support quantification of types?
19:27:57 <Saizan> BMeph: i think FDTerm is a type function
19:28:21 <gwern> Axman6: so? one day lambdabot's state will be corrupted or lost, and the way to restore it will be to cat in the complete #haskell logs; my @remember will function then
19:28:40 <dancor> Saizan: where should i send hbuild patches?  i don't think the darcs repo has a default email
19:28:40 <Saizan> mun_: yeah
19:28:41 <Axman6> heh
19:28:56 <mun_> Saizan, right. thanks.
19:28:56 * gwern isn't joking. this is actually my backup strategy.
19:29:08 <Saizan> dancor: oh, you're using it?
19:29:24 <dancor> Saizan: i use it to infer package deps
19:29:28 <Saizan> dancor: sanzhiyan at gmail dot com, btw
19:29:34 <gwern> Axman6: in the long run, lambdabot being present doesn't matter. lambdabot is present in teh HEAD
19:29:38 <gwern> I mean, future
19:30:20 <EvanR> gwern: lamdabot will be restored during the omega point big crunch systematic enumeration of all possible configurations of the universe
19:30:34 <gwern> EvanR: and we will be restored from our archived messages
19:30:59 <gwern> incidentally, I hear that the universe is open, so the tiplerian omega point is out
19:31:12 <dancor> Saizan: how far is it from concurrent build (-j) working^
19:31:25 <EvanR> tipler has not given up
19:31:51 <gwern> EvanR: I'm sure he hasn't, but if the universe is open, and cosmological inflation is actually increasing...
19:31:56 <gwern> tough row to hoe
19:32:10 <gwern> heck, with increasing inflation even dyson's eternal intelligence might not work
19:32:26 <Saizan> dancor: well concurrent build worked from the start
19:32:28 <EvanR> as wtf as accelerating universe is, i dont discount anything 
19:32:47 <EvanR> it might decide to take a U turn
19:32:47 <djahandarie> I don't even know what is going on in here
19:33:55 <Saizan> dancor: but it can't build so much atm, and i haven't worked on it recently
19:36:04 <dancor> Saizan: is that email address chinese
19:36:40 <dancor> the name
19:39:23 <Saizan> yeah, i think it's the chinese-ish way to pronounce an indian word for triclops, or something like that :)
20:08:42 <dancor> Saizan: hm i hope i didn't send that patch 3 times..
20:08:57 * dancor v. bad at darcs
20:11:46 <Saizan> dancor: you did, but it's not a problem :)
20:11:57 <Saizan> dancor: they are all the same, right?
20:18:00 <dancor> Saizan: yes
20:19:03 <Saizan> mh, this fresh darcs get is taking a while, i should put an optimized version of the repo up later
20:19:36 <gwern> the slow uptake of darcs-2 format is a little disappointing
20:19:55 <dancor> surprising too
20:21:43 <aavogt> darcs-1 is fast enough?
20:22:25 <Saizan> they should have started with the "F*CKING UPGRADE YOUR REPO" banners much earlier :)
20:22:44 <Axman6> upgrade that shit bitch!
20:22:57 <aavogt> it's not slow for the people who maintain the repos
20:23:06 <aavogt> because you have your own local copy
20:23:08 <ddarius> Axman6: Commas are a good thing.
20:23:38 <aavogt> sometimes, they, don't, resolve, ambiguity
20:23:46 <Axman6> yeah, i'm usually a comma overuser, and realised there should have been one as i was pressing enter
20:24:20 <cdsmithus> I' definitely prefer "pardon me, but if it's not too much trouble, might you upgrade your repo?
20:24:27 <aavogt> commaholic
20:24:51 <dancor> olive twist wants more updates?
20:24:55 <dancor> oliver
20:24:58 <ddarius> aavogt: No one is expecting commas to a) resolve all ambiguity and certainly not b) resolve ambiguity when misused.
20:25:04 <gwern> never before has a dvcs asked for more!
20:25:36 <aavogt> I am sorely disappointed
20:25:47 <aavogt> the comma just can't meet my expectations
20:26:13 <dancor> great expectations
20:26:13 <gwern> you often disappoint me as well, aavogt
20:26:15 <gwern> that's life
20:26:56 <aavogt> gwern: where did I underachieve?
20:27:09 <gwern> aavogt: haddocks, mostly
20:27:30 <gwern> it's not anything specific, it's just a general malaise of unsatisfactoriness
20:27:33 <aavogt> which package?
20:28:15 <aavogt> it must be the text. English is my first language
20:28:34 <gwern> better to ask which package isn't
20:29:07 <aavogt> so there are some good ones out there?
20:29:15 * dancor commatose
20:29:23 <aavogt> satisfactory even
20:29:24 <gwern> I'm not dogmatic enough as to say there is none
20:29:46 <gwern> as david hume said on his deathbed about him going to heaven, 'and it is possible that a knob of coal placed upon the fire will not burn'
20:29:49 <aavogt> dogma doesn't look very rational
20:30:16 <aavogt> is that supposed to be an innuendo?
20:32:53 * BMeph leaps in through the window: "NO ONE EXPECTS THE COMMA INQUISITION!"
20:34:01 <dancor> Demarcation
20:34:02 <aavogt> BMeph: commish? commie?
20:35:05 <BMeph> aavogt: Comma-rific! (Action hyphen sold separately. See participating stores for details.)
20:35:25 <djahandarie> Hmmm... has there been an attempt to find lower bounds on the graph isomorphism problem through quantum argument?
20:36:13 <djahandarie> I suppose that means some sort of relation between GI and BQP
20:40:28 <Saizan> dancor: i don't think we want the ABI hash for the packages in the output of --infer, right?
20:45:06 <djahandarie> Wow, figures I would stumble upon a paper written by a professor I know about this exact thing
20:49:50 <Saizan> is there something i should know about put-ing large hashed repos via ssh, with darcs?
20:50:20 <aavogt> Saizan: that it may take some time?
20:50:34 <aavogt> though my experience is with darcs-1 repos I believe
20:51:24 <Saizan> it's taking a lot of memory, actually
20:51:47 <Saizan> more than 1.5G, sounds like there's a leak somewhere
21:03:41 * hackagebot time 1.2.0.3 - A time library  http://hackage.haskell.org/package/time-1.2.0.3 (AshleyYakeley)
21:06:37 <SailorReality> how long have you guys been doing haskel?
21:10:22 <FunctorSalad> new time lib?
21:10:30 <Cale> SailorReality: I've been programming in Haskell for 9 years or so
21:10:35 * FunctorSalad wonders what changed...
21:10:45 <aavogt> newer than time?
21:10:57 <Axman6> SailorReality: two and a half years here
21:11:18 * Saizan wonders if it's safe to scp -r a darcs repo
21:12:38 <aavogt> preflex: seen lambdabot
21:12:39 <preflex>  lambdabot was last seen on #haskell 10 hours, 8 minutes and 22 seconds ago, saying:   3628800
21:13:05 <Cale_> oh, I should fix that :)
21:13:19 <Katovatzschyn> The last element in the list [0,pi..99] is 100.53096..., why is it this instead of value one before this number?
21:13:35 <Katovatzschyn> 97.389...
21:13:41 <Cale_> Katovatzschyn: That is something that I consider a bug in the standard.
21:13:52 <aavogt> so the standard says so
21:14:03 <Katovatzschyn> thank you
21:14:54 <Cale_> The Enum instance for Float and Double does a trick to try to avoid problems with rounding errors, but it means that numbers less than 1/2 of the step size larger than the stated maximum element can end up in the list.
21:14:54 <Mathnerd314> hmm, is it weird that (2010-1985)/e is about 9 years?
21:15:31 <Cale_> > product [1..10]
21:15:32 <haskellbot>  3628800
21:15:38 <lambdabot>   3628800
21:16:18 <aavogt> Cale_: while you're at it, you could allow -XTemplateHaskell with \bot?
21:16:42 <Katovatzschyn> Thank you Cale_
21:16:53 <FunctorSalad> we had a TH bot, it was called 'lunabot', but he/she/it is missing :(
21:16:55 <aavogt> provided you don't have things like runIO imported, stuff should be fine
21:16:58 <FunctorSalad> ( @ aavogt )
21:17:19 <aavogt> I'm trying to find a substitute, FunctorSalad
21:17:24 <jbapple> @tell lambdabot @tell haskellbot @tell lambdabot
21:17:24 <lambdabot> Nice try ;)
21:17:35 <FunctorSalad> aavogt: /exec ghc -e ... ;)
21:17:40 <Axman6> lambdabot!
21:17:45 <jbapple> @tell haskellbot @tell lambdabot
21:17:45 <lambdabot> Consider it noted.
21:17:53 <Axman6> > 1+1
21:17:53 <haskellbot>  2
21:17:54 <jbapple> oh, well
21:17:54 <lambdabot> haskellbot: You have 1 new message. '/msg lambdabot @messages' to read it.
21:17:54 <lambdabot>   2
21:18:18 <Axman6> huh, wonder why the 2 came after the message
21:18:33 <aavogt> nondeterminism
21:20:28 <aavogt> Cale_: should I keep pestering, or is there some reason it'll never happen?
21:20:44 <Cale_> what?
21:21:13 <Cale_> oh, template haskell?
21:21:17 <Cale_> hmm
21:21:47 <Cale> I'd have to think too hard about whether it's safe?
21:22:13 <FunctorSalad> IO is a subfunctor of Q...
21:22:26 <FunctorSalad> (submonad? never heard that word...)
21:22:36 <aavogt> so you need to make sure any functions IO a -> Q a aren't available
21:22:46 <aavogt> ie. they are as bad as unsafeCoerce
21:22:58 <FunctorSalad> which allows you to do funny things like automatically assign the build date to a variable ;)
21:25:47 <Cale> Why do you want TH in lambdabot anyway? :)
21:25:58 <aavogt> for teaching people
21:26:29 <Cale> I suppose that's a decent reason... wasn't there another bot here which had TH support?
21:26:50 <aavogt> as functorsalad brought up earlier...
21:26:56 <aavogt> but lunabot isn't around anymore
21:28:54 <Saizan> lunabot also had a "Show a => Show (Q a)" instance iirc, or similar
21:29:07 <Cale> I wonder where it went... it would be interesting to know exactly what its TH support looked like.
21:29:56 <FunctorSalad> istr it was created by mmorrow, who is missing too :(
21:30:36 <Cale> oh, right...
21:31:54 <aavogt> Cale: if you can't find sources elsewhere, I have a copy on c.h.o in my public_html
21:32:02 <aavogt> same user there as here
21:32:24 <aavogt> I guess you have to go over ssh then
21:35:02 <ManateeLazyCat> Have this function "findNext :: [a] -> a -> Maybe a"?
21:35:20 <aavogt> @type find
21:35:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:35:39 <ManateeLazyCat> Example, "findNext 3 [1,2,3,4,5]" will return "Just 4"
21:36:32 <ManateeLazyCat> Hmm, i can write some function call findIndex, then use index find next.
21:37:32 <aavogt> you'll do better to use dropWhile
21:38:22 <aavogt> @type \p -> listToMaybe . drop 1 . dropWhile (not p)
21:38:24 <lambdabot>     Couldn't match expected type `a -> Bool'
21:38:24 <lambdabot>            against inferred type `Bool'
21:38:24 <lambdabot>     In the first argument of `dropWhile', namely `(not p)'
21:38:28 <aavogt> @type \p -> listToMaybe . drop 1 . dropWhile (not . p)
21:38:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:39:20 <markmcw> cabal problems vs HEAD version -- I posted about this earlier today from another account
21:39:41 <aavogt> that is all?
21:39:42 <markmcw> Just trying now to set up individual packages for the HEAD version without cabal and for
21:39:47 <markmcw> the first one I get:
21:39:59 <ManateeLazyCat> aavogt: Thanks, :)
21:40:03 * aavogt thinks if you've posted it before, you'd be more organized
21:40:05 <markmcw> ghc --make cpphs
21:40:06 <markmcw>  
21:40:06 <markmcw> cpphs.hs:19:8:
21:40:06 <markmcw>     Could not find module `List':
21:40:09 <markmcw>       Use -v to see a list of the files searched for.
21:40:12 <markmcw>  
21:40:15 <markmcw> any ideas? 
21:40:35 <aavogt> your install of ghc must be horribly broken
21:40:47 <ManateeLazyCat> markmcw: ghc-pkg check ?
21:40:56 <markmcw> will try that & BRB
21:41:28 <aavogt> on the other hand, why do you build cpphs like that?
21:41:37 <markmcw> yep, shows broken stuff. Thanks will try recompiling something weird must have happened
21:41:44 <aavogt> (perhaps your haskell98 package is hidden)
21:41:49 <markmcw> just tried it because was having trouble with cabal
21:42:17 <markmcw> I'm working on a project that requires the HEAD version but didn't realize cabal-install was
21:42:21 <markmcw> out of sync with the HEAD
21:42:29 <ManateeLazyCat> markmcw: If you can't fix it, paste the result of "ghc-pkg check", someone will help you. :)
21:42:29 <markmcw> and not installed with HEAD by default
21:42:50 <aavogt> you didn't say HEAD of which packages/ghc etc.
21:43:04 <markmcw> thanks I'll just try compiling the latest head (of ghc) and go from there
21:43:19 <PetRat> I want to use MusicXML, and I see it uses HaXml. Does that mean I need to load/parse a document into a HaXml form, and then give it to the MusicXML module?
21:43:58 <dons> PetRat: haxml parses xml 
21:44:05 <dons> PetRat: so what format is your input in?
21:44:21 <BMeph> :t flip elemIndex
21:44:22 <lambdabot> forall a. (Eq a) => [a] -> a -> Maybe Int
21:44:39 <BMeph> ManateeLazyCat: ^^
21:44:43 <Saizan> PetRat: depends on MusicXML's api
21:44:55 <PetRat> dons: Input is a MusicXML file, which is an XML text file.
21:45:20 <dons> then you shouldn't need to do anything
21:46:03 <PetRat> Saizan: when I look at Haddock docs for MusicXML, I'm just bewildered. 
21:46:32 <PetRat> dons: I don't know how to "load" a file into HaXml, if that's even the term for it.
21:46:51 <ManateeLazyCat> BMeph: I need scan list again after i got index. So I think aavogt's code is better, more effectie. :)
21:47:20 <dons> PetRat: oh, doesn't the musicxml lib define a way to import files?
21:47:38 <Saizan> PetRat: yeah, it's not very nice
21:48:25 <PetRat> dons: I can't find any function like String -> "Document". I do find a lot of references to the Content datatype and wonder if that's from HaXml.
21:48:37 <Saizan> PetRat: however it seems you're supposed to use "read_CONTENTS read_MusicXMLDoc filename contents"
21:49:16 <Saizan> or read_FILE similarly
21:50:13 <PetRat> Saizan: can you explain Document Posn -> Result a?
21:50:48 <PetRat> That's a function to process a document, I guess, and return a result, which I recall Result is a kind of Either
21:50:50 <blackh> PetRat: Consider hexpat.  <-- plug by author
21:51:14 <Saizan> PetRat: yep
21:51:27 <blackh> PetRat: Oh, right - you're using MusicXML which depends on HaXML.  Never mind!
21:51:51 <PetRat> blackh: yeah I think that's my issue
21:52:09 <PetRat> Saizan: what is Document Posn? What does Posn stand for? Position?
21:52:30 <Saizan> PetRat: so read_FILE expects a function that processes a Document Posn an produces a Result a, and gives you back a "Result a" presumably by reading the content of the file, parsing it into a Document and then applying the function you gave to it
21:52:37 <Saizan> PetRat: i think so
21:52:58 <Saizan> PetRat: Document is an haxml type
21:53:24 <PetRat> I'm a bit rusty in my terminology, but so Document is parameterized by the type of position indicator?
21:54:30 <Saizan> yeah, it seems so
21:55:26 <PetRat> I'll try the read_FILE and see if it works...
22:00:02 * hackagebot derive 2.3.0.2 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.3.0.2 (NeilMitchell)
22:10:03 <PetRat> Okay it seemed to load a MusicXML document without error. Looks like it will work.
22:27:01 <dons> PetRat: yay
22:31:05 <turdbird11> Is this a programming chat by chance?
22:31:43 <joga> turdbird11: yes, revolving around haskell
22:32:19 <turdbird11> Never heard of haskell...
22:32:29 <turdbird11> Guess i'm in the wrong area :)?
22:33:07 <Saizan> this channel is about the Haskell programming language, not programming in general
22:33:21 <ski> turdbird11 : well, if you want to learn Haskell, you're welcome :)
22:33:52 <ski> otherwise maybe you want to look some of the other programming-language-channels, or maybe the general ##programming channel ?
22:34:20 <turdbird11> When was haskell developed?
22:34:36 <markmcw> There are some good tutorials around on the web for haskell -- just google 'haskell tutorial'
22:34:44 <kmc> turdbird11, http://en.wikipedia.org/wiki/Haskell_(programming_language)#History
22:34:53 <Axman6> turdbird11: it's well over 20 years old
22:35:05 <kmc> turdbird11, the first version of the standard is from 1990
22:35:16 <kmc> the most recent standard is from six months ago
22:35:37 <kmc> Haskell the language exists separately from implementations
22:35:46 <kmc> the most popular Haskell compiler was started in 1989
22:35:50 <kmc> and was last released 10 days ago
22:35:57 <turdbird11> I've never heard of haskell and i'm cs major either that or i'm really drunk :). I'm interested now though
22:36:08 <kmc> turdbird11, it's a very interesting language
22:36:16 <kmc> very different from most other languages
22:36:20 <Axman6> wow, CS major and never heard of haskell, that's amazing imo
22:36:38 <kmc> Axman6, have you seen what passes for CS at some schools?
22:36:44 <kmc> not saying there aren't smart people there too
22:36:48 <kmc> but nothing is demanded of them
22:36:56 <ski> (maybe s/he's a CS major *and* very drunk ? :)
22:37:33 <Axman6> wow, CS major and never heard of haskell, that's amazing imo (just in case that didn't get through before i got disconnected)
22:37:39 <kmc> i got it
22:37:41 <turdbird11> I would say the reason being is that haskell oviously is not an important language "to have to know".
22:37:41 <kmc> Axman6, have you seen what passes for CS at some schools?
22:37:43 <kmc> not saying there aren't smart people there too
22:37:44 <kmc> but nothing is demanded of them
22:37:56 <Axman6> heh
22:37:59 <kmc> turdbird11, it's not important for writing code for your job
22:38:07 <kmc> it's important for understanding programming
22:38:09 <turdbird11> Exactl.
22:38:17 <kmc> it will expand your mind and make you better at every language
22:38:21 <turdbird11> Both good pointskmc
22:38:28 <ski> turdbird11 : i would say that it is not really imporant to know specific languages, but to know different paradigms, and be willing to learn new things
22:38:31 <Axman6> turdbird11: but it's important in learning advanced topics in programming that can be applied to other languages to make your code betterer
22:38:34 <kmc> it will also make you bitter about being required to program in other languages
22:39:00 * kmc has watched the CS department at his alma mater kind of fall apart in recent years :/
22:39:07 <dons> and there's a reason the #haskell channel is the 2nd largest after #python
22:39:10 <Axman6> kmc: i disagree, who wants to use anything else after using haskell ;)
22:39:40 <kmc> dons, do you happen to have stats comparing # active regulars?
22:39:50 <kmc> i think #haskell is big because there are a ton of lurkers
22:40:02 <turdbird11> I wouldn't mind learning haskell when i get time
22:40:08 <turdbird11> Either way
22:40:21 <turdbird11> :)
22:40:23 <dons> kmc: all channels do
22:40:34 <kmc> i mean proportionally
22:40:44 <dons> don't have the stats.
22:40:49 <kmc> turdbird11, cool :) we're always happy to help beginners
22:40:52 <kmc> or anyone for that matter
22:41:29 <turdbird11> The problem i'm facing as some of you CS major have forgotten is that "I HAVE TO LEARN THE REQUIREMENTS FIRST!v:)"
22:41:33 <kmc> this channel is one of the best examples i've seen of collaborative, freeform learning
22:41:44 <kmc> people hang out, they ask questions and answer questions according to their respective knowledge
22:42:09 <kmc> if you stay long enough you start to answer more questions, but you'll still learn something every day
22:42:15 <Axman6> ah, #haskell is by far the best learning resource i've ever found for any languages
22:42:16 <dancor> is it better to have - or _ word breaks in unix executable names
22:42:16 <danharaj_> The CS program at my university doesn't even teach lambda calculus to people.
22:42:38 <kmc> dancor, i like - but for no good reason
22:42:39 <glenker> danharaj_: same here
22:42:40 <Axman6> people like Cale who are willing to take the time to teach you complex ideas are a fantastic thing to have in a community
22:42:49 <dancor> ok
22:43:01 <kmc> dancor, you could search over binaries on your system
22:43:04 <Axman6> danharaj_:  urgh
22:43:18 <dancor> kmc: i did vaguely but e.g. git- seems to skew..
22:43:23 <kmc> hmm yes
22:43:33 <dancor> there's quite a bit of both
22:43:38 <kmc> danharaj_, meaning not mandatory, or not at all?
22:44:08 <danharaj_> kmc: I couldn't find it in any of the undergraduate courses. I think type theory is taught at the graduate level though.
22:44:09 <ski> turdbird11 : .. the requirements being ?
22:44:10 <dons> i'm enjoying stackoverflow, fwiw. can't keep up answering questions in #haskell anymore, so SO works. 
22:44:14 <dons> kind of replaces haskell-cafe ...
22:44:24 <dons> but you can downvote the trolls
22:44:30 <Saizan> i don't think it's mandatory here either, and it's probably relegated in a single course in the major
22:44:45 <kmc> dons, i really enjoyed watching you thoroughly own one of jdh's troll arguments on SO
22:45:05 <kmc> at my school they still do Scheme and SICP for intro CS
22:45:13 <danharaj> Then again there are no type theory researchers last I checked 'round here.
22:45:28 <dons> he's an odd bird. think everyone in FP is conspiring against him.
22:45:40 <kmc> but there are no classes in systems, languages, type theory, or compilers, beyond the intro required level
22:45:45 <kmc> at all, even for grad students
22:45:56 <kmc> they may have fixed it slightly for next year
22:46:00 <dons> move to UNSW :-)
22:46:03 <kmc> heh
22:46:04 <dons> joint the systems and languages group.
22:46:05 <kmc> well i got my degree
22:46:18 <dons> all we do are systems, languages, type theory, and compilers
22:46:21 <kmc> haha
22:46:25 <dons> seriously.
22:46:33 <kmc> you want to move the department to Pasadena?
22:46:38 <dons> hehe
22:46:41 <dons> sydney is fine, i think.
22:46:45 <kmc> yeah
22:46:57 <kmc> much more a real city than f%*#king LA
22:47:58 <blackdog> dons: pls posse represent:)
22:48:30 <danharaj> I'll be in sydney in about a month.
22:49:18 <dons> yo dawg
22:50:05 <Axman6> danharaj: where're you now?
22:50:11 <dons> blackdog: looking forward to being back in sydney later in the year.
22:50:21 <danharaj> Axman6: Long Island new york. Going to sydney to visit family.
22:50:41 * Axman6 is still waiting for the talk dons was supposed to do at ANU earlier in the year ;)
22:50:56 <blackdog> dons: when are you coming?
22:51:08 <markmcw> regarding schools: I'm a grad student at U of Washington Seattle and highly recommend it for anybody considering CS grad school.
22:51:19 <m3ga> dons: can i book you in for fp-syd :-)
22:51:19 <kmc> long island is long
22:51:49 <markmcw> kmc: MIT? I never heard of anybody else using Scheme for CS intro
22:52:08 <kmc> markmcw, Caltech.  and it's a popular choice actually
22:52:11 <kmc> though less so in recent years
22:52:28 <kmc> it's not the first CS class period at Caltech anymore
22:52:41 <kmc> that's a Python course which is required of all students now
22:52:44 <markmcw> ah, ok ... wish I'd gone to such a school as undergrad ... oh well
22:52:48 <kmc> and is practical and useful for real scientists and such
22:52:58 <kmc> it's now the first course in the CS-major core
22:52:59 <markmcw> yep, I think python is a good choice
22:53:01 <kmc> me too
22:53:05 <kmc> i'm happy with that change
22:53:10 <kmc> and it lets them cover more in the SICP course
22:53:19 <kmc> before they stopped right before it gets really cool
22:53:25 <kmc> i.e. right before the metacircular evaluator
22:53:56 <kmc> i'm in favor of exposing non-CS-majors to SICP, but it's pretty common there to take courses outside your major if interested, so i think it will still happen
22:53:58 <markmcw> I'm not that deep into Python; didn't get a Python job I applied for because I programmed Python too much like a C++ programmer
22:54:04 <kmc> yikes
22:54:06 <kmc> don't do that
22:54:07 <kmc> ;)
22:54:10 <markmcw> "guilty" I had to plead
22:54:26 <kmc> Python is much closer to being an object-oriented language than C++ is
22:54:30 <markmcw> but just because I wound up back at my previous goofy employer
22:54:51 <markmcw> that was stuck on C++ and wouldn't listen to my trying to drag them to python
22:54:54 <blackdog> heh, i once missed a ruby job because i programmed too much like a haskell hacker
22:54:58 <kmc> haha
22:55:10 <dons> m3ga: i'll certainly give a talk. not sure whem i'm back yet. but in coming months.
22:55:14 <solrize> berkeley used sicp in the past, i don't know about now
22:55:15 <dons> m3ga: i'll let you know.
22:55:16 <markmcw> I quit -- let them stew in their own C++ juice!
22:55:16 <blackdog> they don't mind blocks, but honest-to-god function objects make them very uncomfortable
22:55:29 <kmc> blocks have an implicit lambda *and* an implicit call/cc :D
22:55:34 <m3ga> dons: awesome. thanks!
22:56:27 <kmc> in fact
22:56:34 <kmc> it seems that Proc.new captures a continuation
22:57:11 <m3ga> anyone else here who ever makes it to sydney is welcome to come to fp-syd as well. bonus if you have something to present to us.
22:58:11 <Axman6> anyone played with Apple's blocks in C* languages?
22:58:19 <kmc> it was funny to watch people on proggit boggle at this fact
22:58:32 <Axman6> makes it quite possible to write curried functions in C
22:58:33 <kmc> and then talk about wouldn't it be cool if there were a language where "where to return to" was first-class
22:58:54 <Axman6> m3ga: i might rock up the night before AusHac :)
22:59:09 <m3ga> Axman6: do it!
22:59:19 <Axman6> m3ga: mind if i do a little advertising for AusHac while i'm there?
22:59:31 <m3ga> by all means
22:59:40 <Axman6> awesome
22:59:51 <Axman6> now just gotta convince my girlfriend not to get annoyed with me :P
22:59:56 <Axman6> she'll be fine i'm sure
23:00:08 <m3ga> i hate advertising , but ifs its fp related, its not advertising its information.
23:00:19 <Axman6> aye
23:02:49 <danharaj> what's AusHac?
23:03:18 <Axman6> the first aussie haskell hackathon
23:03:30 <SailorReality> u can hack in haskell?
23:03:39 <SailorReality> u mean haskell isnt just for doing useless mathematical calcuations?
23:03:39 <kmc> yes
23:03:40 <Axman6> ?
23:03:45 <Axman6> of course
23:03:46 <kmc> har har SailorReality
23:03:50 <kmc> you're the first one to come up with that joke
23:04:01 <kmc> @wordnet u
23:04:02 <lambdabot> Unknown command, try @list
23:04:04 <kmc> @wn u
23:04:05 <lambdabot> *** "u" wn "WordNet (r) 2.0"
23:04:05 <lambdabot> u
23:04:05 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
23:04:06 <lambdabot>            especially in language use
23:04:06 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
23:04:07 <lambdabot> [5 @more lines]
23:04:47 <shepheb> @more
23:04:48 <lambdabot>           derived from pyrimidine; pairs with adenine [syn: {uracil}]
23:04:48 <lambdabot>      2: a heavy toxic silvery-white radioactive metallic element;
23:04:48 <lambdabot>         occurs in many isotopes; used for nuclear fuels and
23:04:48 <lambdabot>         nuclear weapons [syn: {uranium}, {atomic number 92}]
23:04:48 <lambdabot>      3: the 21st letter of the Roman alphabet
23:04:57 <kmc> is there a way to invoke a lambdabot command but have her PM the output to another user?
23:05:15 <kmc> @quote _pizza_
23:05:15 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
23:05:22 <danharaj> when is AusHac?
23:05:52 <Axman6> 17-19th of july i think
23:06:00 <Axman6> i should really know this, since i'm organising it
23:06:08 <danharaj> hey, I actually could make that.
23:06:10 <Axman6> 16-18th
23:06:15 <Axman6> excellent :)
23:06:45 <Axman6> danharaj: http://www.haskell.org/haskellwiki/AusHac2010
23:07:14 <Axman6> if you want to come, could you fill out the signup form? 
23:08:52 <danharaj> axman6: I have to see exactly when my flight is :)
23:08:59 <Axman6> righto
23:09:14 <Axman6> well, even if you just say you might be able to come, we can keep you updated if you want
23:09:59 <SailorReality> you're going to fly to australia
23:09:59 <Axman6> signing up doesn't mean you have to come
23:10:03 <SailorReality> to particpate in a hackathon?
23:10:34 <SailorReality> why cant u just do it from your compuer
23:10:36 <SailorReality> computer
23:10:51 <Axman6> he said he's already coming to australia
23:10:56 <Axman6> pay attention
23:11:04 <SailorReality> ive been there before
23:11:08 <SailorReality> twice
23:11:10 <kmc> SailorReality, don't say 'u' to mean 'you'
23:11:19 <SailorReality> kmc: why
23:11:24 <kmc> because it makes you sound retarded
23:11:25 <SailorReality> are you a grammarian
23:11:55 <Axman6> kmc's right
23:12:06 <kmc> i'm offering this as advice
23:12:11 <kmc> unless you want to sound retarded
23:12:48 <Axman6> which seems to be working fairly well so far
23:13:51 <SailorReality> you know what's weird?
23:13:54 <kmc> and no i'm not a grammarian
23:14:16 * shepheb begins: a) working through 8629 Haskell-cafe posts since December, b) wondering if he secretly hates himself
23:14:35 <kmc> i generally don't care about grammar when meaning is clear, and i use lots of incorrect idioms myself
23:14:36 <SailorReality> there's 600 people in here and most of them happen to be haskell programmers
23:14:38 <SailorReality> what are the chances
23:15:12 <kmc> not really true
23:15:29 <kmc> there's 600 people in here and most of them have some interest in Haskell
23:15:34 <danharaj> I think most of us have non-haskell as a first language.
23:15:42 <kmc> i'm not sure what you mean by 'Haskell programmer'
23:15:43 <danharaj> C++ is my first.
23:15:56 <Axman6> you know, i think SailorReality might be one of the most successful trolls i've seen on IRC. under the radar, baseline annoyance without the peaks that get people kicked
23:15:57 <kmc> i'd guess that a fair number of people here have never written any haskell
23:16:16 <McManiaC> :>
23:16:30 <johnw> danharaj: same here
23:16:33 <kmc> and a lot write Haskell for fun occasionally but rarely for a "serious" project
23:16:45 <Jafet> Who are you to judge what is serious
23:16:55 <kmc> nobody, that's why i'm not drawing that line
23:17:34 <dancor> how do i write in a haddock doc string: {-# LANGUAGE TemplateHaskell #-}
23:17:41 <Jafet> Also, there is a scheduled daily discussion on the success and popularity of haskell, as seen now
23:17:46 <kmc> yeah
23:18:08 <glenker> I write haskell because it gets me chicks
23:18:26 <kmc> yup
23:19:45 <SailorReality> i like it because from what ive seen it requires some level of mathematical sophistication that wouldn't be accessible to the average programmer ...so one day if I do manage to learn it I can be an elitist  prick about it
23:19:55 <dancor> it's obvious that haskell isn't serious if i can't do this :)
23:19:59 <kmc> haha SailorReality
23:20:04 <kmc> you don't get to make those jokes
23:20:07 <kmc> because you don't know Haskell
23:20:12 <danharaj> or Math
23:20:18 <SailorReality> lol i have a math degree
23:20:26 <danharaj> Uh-huh.
23:20:26 <kmc> dancor, common IRC question asking algorithm i see ;)
23:20:43 <dancor> well i'm not asking about an algorithm
23:20:45 <dancor> this time
23:20:49 <kmc> no i mean
23:20:53 <kmc> to get answers, insult the thing you want answers about
23:20:57 <dancor> right
23:21:10 <kmc> SailorReality, why do you think Haskell requires mathematical sophistication?
23:21:14 <danharaj> So is engineering for elitist pricks to because you need to have a firm grasp of the theory of differential equations to do it, too?
23:21:29 <johnw> kmc: if he's really a troll, you're proving him exceptionally effective, which goes against denigrating his intelligence
23:21:44 <SailorReality> kmc: well the syntax seems to be close to what id write myself if i were doing a proof some of it at least
23:21:47 <dancor> i think math is singularly elitist and trendy compared to engineering fields
23:21:47 <kmc> i know he's a troll but i want to hear the answer anyway
23:21:50 <SailorReality> and it has set comphrenesions etc
23:21:52 <kmc> i'm interested in the discussion
23:22:14 <SailorReality> danharaj: differential equations arent really math 
23:22:15 <blackdog> kmc: I think I saw Cale pull this trick...
23:22:21 <SailorReality> they're like first year lol
23:22:24 <kmc> i think people commonly confuse the background of typical haskellers with the set of things required for haskell
23:22:25 <dancor> actually i don't think haskell math (or at least category theory) is trendy right now
23:22:38 <dancor> in math
23:22:45 <danharaj> SailorReality: Cool story bro.
23:22:46 <kmc> the background of typical haskellers says more about who learns haskell than about what haskell itself requires
23:22:50 <McManiaC> SailorReality: first year or... physics
23:22:51 <McManiaC> :D
23:23:01 <glenker> holy shit. I think differential equations finally makes sense to me because of this conversation
23:23:13 <glenker> haha, just graduated too
23:24:08 <kmc> SailorReality, if you want a language that's *actually* for proofs, read http://www.cis.upenn.edu/~bcpierce/sf/ and http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
23:24:11 <glenker> yeah, so is anyone working on some cool haskell projects right now?
23:24:35 <kmc> glenker, modifying GHC to target Android.  though so far most of the code has been in sh, make, and C
23:25:07 <glenker> thats pretty cool
23:26:41 <kmc> god the Text.Regex API is fucking impossible to understand from haddock
23:26:52 <Saizan> kmc: regex-compat
23:26:56 <kmc> anyone have a good comprehensive list of examples
23:27:14 <chrisdone> kmc: there's the blog post if you google haskell regex by bryan
23:27:18 <kmc> thank you Saizan!
23:27:56 <chrisdone> i wonder if there's a wiki page and if not it's probably worth making one
23:28:00 <Saizan> (next ICFP contest could be guessing how to use the Text.Regex API)
23:28:04 <kmc> haha
23:28:36 <dancor> i thought this might work but it does not: {\-# LANGUAGE TemplateHaskell #-\}
23:29:15 <blackdog> kmc: oh, that's cool. how close are you?
23:29:18 <chrisdone> why the backslashes?
23:29:36 <kmc> blackdog, proof of concept is working
23:29:44 <kmc> i.e. i can compute 5 factorial
23:29:46 <dancor> chrisdone: dancor> how do i write in a haddock doc string: {-# LANGUAGETemplateHaskell #-}
23:30:00 * BMeph has no degrees, not even an Associate's...but is still a right pompous bar steward anyway!
23:31:05 <SailorReality> smartest guy in the world (at least according to an IQ test) was a bar bouncer 
23:31:22 <SailorReality> Matt langdon i think his name was 
23:31:34 <McManiaC> could he write haskell?
23:31:44 <SailorReality> not sure
23:32:09 <blackdog> kmc: on dalvik? wasn't aware android could run native code
23:32:43 <kmc> it's native code
23:32:44 <kmc> it can
23:32:52 <kmc> as of fairly recently
23:33:02 <kmc> apps are all Java still, but they can make JNI calls
23:33:04 <blackdog> ah, right. that's pretty cool - are there restrictions on it for apps?
23:33:14 <kmc> most of the public APIs are Java-only
23:33:25 <kmc> but a few important performance-critical ones like OpenGL have public native APIs
23:33:55 <blackdog> can you package your own C library in an app package?
23:34:10 <kmc> you package a .so
23:34:16 <ndxtg> http://codepad.org/UYnfxicD <----- how come exp2 is not in scope? I cant figure out the reason
23:34:40 <kmc> ndxtg, because the RHS of an equation isn't in scope over "where"
23:34:47 <kmc> "where" binds to the equation level, not expression level
23:35:06 <kmc> ndxtg, it doesn't solve your problem, but you probably ought to be pattern-matching at the top level
23:35:06 <kmc> i.e.
23:35:10 <kmc> eval a b (Var A) = a
23:35:15 <kmc> eval a b (Num x) = x
23:36:53 <blackdog> kmc: hm. with your work on android and blackh's work on ghc-on-iphone, i bet we could get haskell as banned as flash in appleland.
23:37:01 <kmc> we'll see about that
23:37:03 <kmc> ;)
23:37:09 <danharaj> blackdog: But haskell isn't a terrible technology.
23:37:11 <kmc> it's already banned by the book, of course
23:37:17 <kmc> but the book doesn't matter
23:37:22 <kmc> because Apple has absolute power anyway
23:37:40 <danharaj> Fascists.
23:37:46 <chrisdone> kmc: that's way more code for no good reason, he's pattern matching on exp, not a or b
23:38:03 <ndxtg> kmc: I see. I have just deleted the where and replace the left/right by the equations. It works now. Thank you. alot of copy & paste though
23:38:22 <kmc> chrisdone, you object just to the repetition of 'a' and 'b' on the LHS?
23:38:22 <blackdog> danharaj: none of this is based on taste. they just don't want people to be able to develop cross-platform easily. makes perfect sense, commercially.
23:38:28 <kmc> or am i missing something more
23:39:04 <kmc> ndxtg, you can do better
23:39:18 <kmc> want hints?
23:39:27 <ndxtg> kmc: sure?
23:39:51 <kmc> data BinOp = Plus | Minus | Times | Div
23:40:00 <kmc> now Expression gets simpler
23:40:56 <ndxtg> kmc: how about Var and Num?
23:41:06 <kmc> what about them?
23:41:36 <chrisdone> kmc: repetition of 'eval a b' -- not just needless repetition but also indicates they are going to be pattern matched to readers, when they aren't
23:42:19 <kmc> ndxtg, binary operators in your language have a uniform semantics: two sides are evaluated and some primitive function applied to the result
23:42:39 <kmc> Var and Num don't fit that pattern and so we keep them as different cases of Expression
23:44:47 <ndxtg> kmc: I think I have got what you meant. I thought u meant replace completely the Expression by binOp... but actually it should be Expression = Var .. | Num .. | binOp .. ..
23:45:12 <kmc> right
23:47:11 <ndxtg> weird work = werk
23:47:24 <McManiaC> data Expression = Var .. | Num ..; instance Num Expression where...
23:47:25 <McManiaC> :D
23:47:51 <McManiaC> ok, doesnt work too well :(
23:48:21 <kmc> ndxtg, if you like i'll take a look at your improved code when it's done
23:49:40 <ndxtg> kmc: actually im not writing any program, just randomly practice coding
23:49:44 <kmc> ok
23:49:48 <kmc> that's good :)
23:49:53 <kmc> this is a great exercise
23:50:55 <Axman6> making a Num instance is awesomesause, because you can then do things like: 1+2*3*4/3 :: Expr and it'll all just work
23:51:50 <exDM69> what type is Expr?
23:52:03 <McManiaC> Axman6: youre getting problems with Var tho :P
23:52:03 <kmc> some type you define
23:52:20 <Axman6> McManiaC: hmm?
23:52:38 <McManiaC> Var A + 5 = ?
23:52:51 <kmc> Add (Var A) (Lit 5)
23:52:54 <Axman6> should work i think
23:53:05 <kmc> hmm what's like "forever" but allows me to terminate the loop from inside?
23:53:13 <Axman6> define v = Var to make things nicer
23:53:19 <kmc> «ContT r IO» seems like overkill
23:53:51 <ndxtg> doit :: (Eq a, Ord a) => [a] -> [a]  -----> error!!? so we can only use either Eq a or Ord a instead of both?
23:54:11 <Axman6> you only need Ord, all Ord instances implement Eq
23:54:13 <Axman6> they have to
23:54:15 <Axman6> @src Ord
23:54:15 <lambdabot> class  (Eq a) => Ord a  where
23:54:15 <lambdabot>     compare      :: a -> a -> Ordering
23:54:15 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:54:15 <lambdabot>     max, min         :: a -> a -> a
23:54:58 <Axman6> which makes sense, because Ord implies Eq
23:55:10 <kmc> it shouldn't be an error though
23:55:17 <Jafet> > let doit :: (Eq a, Ord a) => [a] -> [a]; doit xs = xs; in "success"
23:55:18 <lambdabot>   "success"
23:55:19 <kmc> :t let f :: (Eq a, Ord a) => [a] -> [a]; f = undefined in f
23:55:20 <lambdabot> forall a. (Ord a) => [a] -> [a]
