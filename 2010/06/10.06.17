00:01:04 <kmc> according to some, apostrophes are used to pluralize acronyms, year numbers, etc. in English
00:01:37 <drbean> OK. I keep on reading (x:xs) as "ex, exess", rather than "ex, exes" :-)
00:05:22 <Veinor> ex-exes
00:06:46 <kmc> that is known to happen
00:11:05 <Jonno_FTW> test
00:16:38 <Sadache> what is the package to use for doing regex in haskell?
00:19:12 <Dashkal> @hoogle (=~)
00:19:12 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
00:19:12 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
00:19:24 <Dashkal> Sadache: Text.Regex.Posix
00:21:42 <alar> can somebody recomment me _the_right_way_to_do_?
00:21:42 <alar> I have entity called "command" and can represent it in 2 ways:
00:21:43 <alar> as (CmdCode,[Word8]) - everything will be untyped, but I get "instance Binary" for free
00:21:43 <alar> as GADT - all will be flexible, but I have to hand-code instance Binary for all constructors
00:23:08 <Sadache> Dashkal: does Text.Regex.Posix capture groups?
00:23:40 <alar> Sadache: it's polymorphic on result type
00:24:04 <alar> AFAIK, if you use 4ple result type
00:24:18 <alar> 4th component will be list of captured groups
00:25:03 <alar> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
00:25:49 <Sadache_> the first thing i'd thing about is Text.Regex. does it have any problems?
00:26:47 <Sadache> alar: thank you for the link, very useful
00:27:17 * alar haven't encountered any problems with regexes
00:28:04 <Dashkal> The only issue I'm seeing is the docs for Text.Regex.Posix warn that only ASCII is supported (no unicode)
00:28:17 <Dashkal> But a couple other regex backends do support it
00:28:42 <Dashkal> Browse hackage under the "Text" category for a number of them.
00:30:41 <Sadache> hmm, i am planning to use it for parsing urls
00:31:09 <Dashkal> iirc urls must be within ascii so you should be good.  anything extended would be escaped.
00:32:04 <Dashkal> not that I've read the RFC lately so don't quote me on that one :P
00:34:40 <Sadache> Dashkal: :) that is helpful anyway. 
00:45:03 <J-roen> Hi. I am trying to read existential types. I found a solution at http://haskell.org/pipermail/haskell-cafe/2007-July/028227.html which works surprisingly well, only the parse is ambiguous for non-nullary data types. Well, not really, but it gives the exact same parse result twice and I can't figure out why. A test can be found at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26309. I hope someone can help me to understand the problem and hopefully 
00:59:05 <sinelaw> Peaker
01:06:53 * hackagebot explicit-iomodes 0.4.0.1 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.4.0.1 (BasVanDijk)
01:23:00 <obscaenvs> hi'
01:24:19 <Botje> hallo!
01:28:24 <obscaenvs> I am following learnyouahaskell.com, and I would like to know if and when you are going to update it...
01:29:00 * hackagebot hakyll 2.1.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.1.1 (JasperVanDerJeugt)
01:29:59 <eevar2> obscaenvs: real world haskell is good, and free on the web
01:30:26 <sinelaw> obscaenvs it's written by BONUS
01:30:33 <sinelaw> (LYAH)
01:32:47 <obscaenvs> Yes, and I wanted to direct that msg to BONUS privately, but apparently ERC doesn't understand the IRC command I used, or I made some other error. Sorry about that, I will do an RTFM!
01:35:29 <fasta> Real world Haskell is written for corporate programmers that will still have little understanding of Haskell after reading that book. 
01:36:19 <fasta> It certainly is not a "get an educated Haskell user book". That said, it is kind of nice to have some practical issues in one book together.  
01:37:03 <toki78> Hi,
01:37:27 <toki78> is it possible to generate dynamic websites with haskell ?
01:37:54 <Starfire> toki78: http://snapframework.com/
01:39:04 <fasta> toki78, you can do everything with Haskell, except real-time computation (unless you use a DSL, which would not be Haskell anymore).
01:40:01 <fasta> toki78, if you want to know whether Haskell is the easiest way to build websites, probably not. 
01:40:16 <kmc> fasta, why do you say that about RWH?
01:40:25 <kmc> it covers a lot of stuff not covered in typical haskell intros
01:40:28 <fasta> toki78, to build high-performance websites it seems to be viable, though.  
01:41:17 <kmc> do you mean that most people reading it won't understand most of it?
01:41:23 <toki78> fasta, I just like it the hard way ;)
01:41:34 <fasta> kmc, try find the mention of "monomorphic type" in RWH, for example.
01:41:34 <kmc> you've come to the right place then
01:41:58 <fasta> kmc, it basically says "look for details in the Haskell report".
01:42:08 <kmc> yeah
01:42:16 <fasta> kmc, there are lots of things like that in that book. 
01:42:20 <kmc> it's not theory-oriented, nor is it a comprehensive tour of the language
01:42:41 <fasta> kmc, it is a bag of tricks showing how indeed real world Haskell development works. 
01:42:43 <kmc> the Gentle Introduction, btw, is a lot more valuable if you see it as a guided tour of the spec, and not as a tutorial for beginners
01:42:59 <fasta> kmc, I think it is quite a nice book in that regard.
01:43:13 <obscaenvs> The RWH has a rather awkward introduction to the type system IMHO.
01:43:23 <fasta> kmc, but it is not like you can say you understand Haskell after reading that book. 
01:43:27 <Starfire> I really liked RWH. It's what finally convinced me to try to really learn Haskell.
01:43:28 <kmc> ok, but i dispute the claim that someone who knows only the real-world aspects of Haskell is not "an educated Haskell user"
01:43:48 <kmc> i'll agree they're not an "expert"
01:44:03 <kmc> no book will make you an expert, unless it takes 10,000 hours to read
01:44:13 <fasta> kmc, ok, they will certainly know more than the average "I heard Haskell is cool"-person. 
01:44:27 <kmc> yes
01:44:32 <kmc> that person usually has negative knowledge ;)
01:44:51 <fasta> kmc, Haskell has built-in memoization, right, right!!?!!?!
01:45:03 <kmc> in Haskell, impure functions are tagged in the type system ;)
01:46:23 <toki78> is there a good tutorial about Monads ? I still don't understand their background (although I know how to use them)
01:47:33 <Peaker> fasta, I was bummed out when I heard pure functionality didn't imply both automatic memoization and automatic parallelism with no work :)
01:47:46 <kmc> toki78, try Typeclassopedia
01:47:58 <toki78> are Monads just about "preseving some kind of state" ?
01:48:02 <kmc> no
01:48:14 <danharaj> Automatic parallelism isn't really that desirable is it?
01:48:27 <Peaker> toki78, Monads are just a general structure.. Not "about" anything much
01:48:34 <fasta> danharaj, it was pretty much the promise of functional programming for a long time.
01:48:50 <Peaker> danharaj, why not?
01:48:52 <kmc> right.  individual instances of the typeclass Monad (that is to say, individual monads) are about things
01:49:18 <kmc> Parsec is about parsing, [] is about nondeterminism, (State s) is about state, STM is about transactional memory, etc.
01:49:36 <Peaker> toki78, Type-classes, including Monads, are about capturing a recurring structure such that many functions can work with it -- and be general to all instances of that structure
01:49:39 <kmc> toki78, have you looked at the implementation of simple monads like Maybe, (Either e), and (State s) ?
01:50:00 <Starfire> I think I started to 'get' monads after trying to implement my own.
01:50:20 <quicksilver> toki78: there are 50+ monad tutorials, most of them probably aren't "good" in the sense of answering the question you want answered.
01:50:22 <toki78> kmc I took a look at the list monad
01:50:31 <kmc> Maybe is the simplest interesting one
01:50:39 <quicksilver> toki78: if you already feel you know how to use them, but want background, I would point you at the original paper
01:50:42 <danharaj> Peaker: I don't think it would be that efficient with a naive algorithm, say one that splits off a thread whenever it has the chance, and I don't know how well you could build such an algorithm that works efficiently without it getting too complicated.
01:50:46 <toki78> kmc, thanks thats good help
01:50:46 <quicksilver> toki78: "Notions of Computation" I think, by Moggi
01:50:47 <kmc> @src Maybe (>>=)
01:50:47 <lambdabot> (Just x) >>= k      = k x
01:50:47 <lambdabot> Nothing  >>= _      = Nothing
01:50:59 <danharaj> Peaker: As opposed to measuring your program and then applying judicious amounts of parallelism yourself.
01:51:00 <quicksilver> toki78: just ignore the boring mathsy bits, but it has good intuition too.
01:51:09 <kmc> toki78, the other thing to realize is that the type class Monad by itself isn't that useful.  it exists so we can provide general reusable control flow structures,  e.g. Control.Monad, but none of those are useful in isolation
01:51:22 <kmc> each particular monad provides some "primitives" above and beyond the Monad API
01:51:22 <Peaker> danharaj, Of course stupid parallelism is undesirable... But it seems plausible that pure FP *can* do smart parallelism automatically. Even if maybe it can't
01:51:47 <Peaker> danharaj, For example, I'd love to see that process of profiling+parallelizing automated
01:51:51 <kmc> the Monad API is a uniform way to glue together whatever primitives you're given, regardless of the specific primitives are, i.e. regardless of which monad
01:52:02 <napping> reasonable diagrams: http://en.wikipedia.org/wiki/Monad_%28category_theory%29
01:52:05 <danharaj> Peaker: I think it is delightful enough that it is trivial to determine whether parallelism is semantically correct when you want to apply it :p
01:53:02 <Peaker> danharaj, Very disappointing IMO :)
01:53:08 <toki78> napping, good link !
01:53:26 <Peaker> But OTOH the richness of types and the ability to figure out what most functions do from the type was a pleasant surprise
01:55:46 <danharaj> toki78: The way I think of >>= is that something of type (a -> m b) is a monadic value that depends on a value of type a. >>= let's you attach this dependency to a value of type (m a)
01:56:46 <toki78> danharaj, I think I agree, good explanation
01:59:33 <toki78> ok now in the special case of the Maybe Monad. I guess it can be used for error propagation, right ?
01:59:39 * ManateeLazyCat pasted "Mplayer demo" at http://paste2.org/get/880996
01:59:40 <ManateeLazyCat> Above is MPlayer demo code, you will see how easy use gtk2hs to build a MPlayer client. 
02:02:12 <jdsc> hi all, I have a question regarding multi parameter type classes
02:03:32 <jdsc> so, I want to convert values to a json types using the following type class : class ToJson env a where toJson :: env -> a -> JSON
02:03:54 <jdsc> here, the type "env" contains additional data to help me render to JSON
02:04:27 <jdsc> Let's say I have the same to convert from JSON : class FromJson env a where fromJson :: env -> JSON -> a
02:04:58 <earthy> are a and env independent?
02:05:02 <danharaj> toki78: Right. In this case >>= does the obvious thing. If its argument is Nothing, then it propogates the error. If it is (Just v), then it threads the value to the next computation.
02:05:34 <Hyuma> hello all
02:05:56 <jdsc> Now I declare a type class for values which we can convert back and forth to json : class (ToJson e1 a, FromJson e2 a) => BiJson e1 e2 a
02:06:24 <earthy> jdsc: no problems there.
02:06:42 <jdsc> So for a simple type like Int I have to declare ToJson () Int, FromJson () Int
02:06:55 <quicksilver> is it always () if it's Int?
02:07:13 <quicksilver> ...if so, then there is a functional dependency there
02:07:18 <quicksilver> | a -> env
02:07:33 <quicksilver> which will make type inference work better in some cases.
02:07:56 <jdsc> I have to look up on that, but I think I see what you mean
02:07:58 <quicksilver> or, alternatively, there as an associated type family way to say the same thing.
02:08:18 <quicksilver> jdsc: it tells the compiler it is allowed to assume it's () if it sees Int
02:08:28 <quicksilver> rather than requiring you to explicitly specify that in all cases.
02:08:32 <napping> jdsc: what's the problem?
02:08:32 <jdsc> ok
02:08:35 <quicksilver> still, you didn't get to your question yet :)
02:08:47 <jdsc> it's a tiny detail
02:09:07 <jdsc> apparently, if I declare ToJson and FromJson instances, the compiler does not infer the BiJson class
02:09:21 <jdsc> I have to declare it and it bothers me because it's two extra lines :)
02:09:35 <Hyuma> haskell make me crazy
02:09:51 <napping> you said class, not instance
02:10:25 <napping> That just says a set of types must have the ToJson and FromJson instances to be allowed to make a BiJson instance
02:10:30 <jdsc> I mean, I declare instances of ToJson () Int and FromJson () Int but the compiler does not infer BiJson () () Int
02:10:41 <ManateeL`> Since the principle is same, you can modified code at http://paste2.org/get/880996 to build your own client for Emacs, Vim or any gui program that accept WINDOW_XID argument
02:10:58 <jdsc> I have to declare BiJson () () Int on top of that
02:10:59 <quicksilver> jdsc: that's right, it doesn't.
02:11:05 <jdsc> and could it ?
02:11:11 <quicksilver> well, it never does
02:11:18 <napping> Just like when you define an Eq instance for a type, it doesn't automatically make an instance of Ord
02:11:22 <quicksilver> the compiler never generates automatic instances for you.
02:11:35 <earthy> jdsc: you'd have to also declare
02:11:41 <quicksilver> in this case though you can probably write a single generic instance
02:11:54 <quicksilver> instance (ToJson e1 a, FromJson e2 a) => BiJson e1 e2 a where
02:11:59 <earthy> instance (ToJson e1 a, FromJson e2 a) => BiJSon e1 e2 a where
02:12:01 <quicksilver> because it probably will apply in the same fashion to each.
02:12:04 * quicksilver wins.
02:12:08 * earthy nods
02:12:36 <quicksilver> what you're effectively saying is that a BiJson instance is no more and no less than a FromJson plus a ToJson
02:12:38 <jdsc> but you can declare things like: instance ToJson env a => ToJson env [a] where
02:12:47 <earthy> yes.
02:12:53 <quicksilver> in other words, it's really just a context alias
02:12:57 <jdsc> which looks like the compiler automatically infers instances for lists ?.
02:13:04 <napping> No
02:13:09 <quicksilver> haskell doesn't have context alises although they are commonly requested.
02:13:13 <earthy> jdsc: no. it takes an instance for a and defines an instance for [a]
02:13:30 <napping> that's an instance delcaration saying how to make instances
02:13:41 <napping> separate thing from defining the class in the first place
02:14:05 <napping> It's only in the special case where a class has no methods that you might think they could be the same
02:14:38 <napping> Also, if you just use a plain MTPC you will probably run into trouble with that BiJson, if you ever try to put it on a function that only serializes or deserializes it will have no idea what the env for the other direction should be
02:15:36 <jdsc> so I should stop worrying, write BiJson classes and add functional dependecies to FromJson and ToJson ?
02:15:47 <jdsc> I mean write BiJson instances, sorry
02:15:54 <napping> just write one instance
02:16:08 <napping> instance (ToJson e1 a, FromJson e2 a) => BiJson e1 e2 a
02:16:17 <napping> will get all the instances, but you do need that instance
02:16:33 <jdsc> well, there are cases where I want to write the serialization, but not the deserialization
02:16:43 <jdsc> oh ok
02:16:45 <napping> Then,  you could use it as an abbreviation on excatly those functions that really do use both directions together, and only use To or From when  you just need one
02:17:06 <jdsc> why didn't I think of that ?
02:17:10 <jdsc> thank you :)
02:17:29 <jdsc> I'll take a look at the haskell wiki page on context aliases, looks interesting
02:17:51 <napping> but do you really need to define several ToJson or FromJson instances with different env types?
02:18:04 <jdsc> sometimes yes
02:18:10 <jdsc> I'm implementing a REST api
02:18:29 <napping> What does the env do at all?
02:18:58 <jdsc> the data I display contains ids
02:19:10 <jdsc> the env datatype contains intmap
02:20:41 <jdsc> using both, i retrieve extra data from env
02:20:53 <Sadache> I am not finding a Context of Text.Regex that returns named matched groups
02:21:08 <Sadache> http://www.regular-expressions.info/named.html
02:21:54 <napping> jdsc: that sounds like a single program-wide env type could do
02:22:02 <napping> or at worst IntMap a
02:22:40 <jdsc> I have a lot of data
02:23:00 <napping> anyway, MTPC can often be annoying in type inference if you have any methods that don't mention all the types
02:23:01 <ManateeL`> Sadache: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
02:23:34 <napping> and functional dependencies or associated types can usually clean it up, if you didn't really need full generality
02:23:53 <jdsc> ok, thanks
02:24:09 <jdsc> what I meant earlier is that I already have a big Env datatype
02:24:41 <quicksilver> Sadache: do any of the haskell regexp bindings suport named groups?
02:24:44 <jdsc> but sometimes I want the types to be more precise, always using ToJson Env a would be too general
02:25:12 <jdsc> sometimes I only want to retrieve data from a certain table, not the whole DB
02:25:26 <jdsc> (when I'm converting to json, that is)
02:25:49 <Sadache> quicksilver: I dont know, I am just looking for any regex binding that supports named groups
02:26:46 <napping> jdsc: it might go better with separate functions for elaborating a structure from the DB, and then a class for turning specific data into JSON
02:27:00 <jdsc> anyway, thank you very much for your help, napping ! (also quicksilver and earthy)
02:27:11 <quicksilver> Sadache: I don't think there are any.
02:27:16 <quicksilver> Sadache: (I could be wrong...)
02:27:26 <jdsc> napping: that's basically what i have now
02:27:29 <Sadache> ManateeL`: the link you provided doesn't provide any information about Named Groups
02:27:48 <Sadache> quicksilver: strange
02:28:50 <quicksilver> Sadache: well, regexps aren't used much in haskell.
02:28:57 <jdsc> but my big datatype contains : client data, user parameters, rules and so on, so sometimes I want to be more explicit and say that I only need client data, or rules, to convert values of a certain type to JSON
02:29:54 <Sadache> quicksilver: so how would I then in haskell capture groups provided by a user of my api?
02:30:37 <Sadache> an easy example is something/{id}/{name}
02:30:52 <quicksilver> Sadache: well, just use ordinary (not named) groups
02:31:18 <quicksilver> although I'd personally tend to use parser combinators.
02:31:30 <quicksilver> I would only use regexps in the case that they are user-entered or user-configurable
02:31:39 <quicksilver> (e.g. if you're writing a text editor)
02:31:42 <Sadache> quicksilver: imagine I have an api that takes a regex and returns a Map of captured strings
02:32:02 <Sadache> quicksilver: well in my case they are
02:32:10 <quicksilver> if you have an api which takes a regexp with named groups
02:32:11 <Sadache> I mean they are user entered
02:32:13 <quicksilver> then you have work to do.
02:32:22 <quicksilver> because none of the bindings support named groups (AFAIK)
02:32:31 <Sadache> I see
02:32:34 <quicksilver> I imagine that pcre supports named groups
02:32:47 <quicksilver> so you might start by doing a modified version of the pcre binding?
02:34:59 <quicksilver> or start with the pure haskell regexp engine which might be easier to modify
02:35:00 <quicksilver> I dunno.
02:35:25 <jdsc> napping: what are associated types.
02:35:26 <jdsc> ?
02:35:48 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-families.html
02:36:07 <Sadache> quicksilver: why to modify pcre if it has them?
02:36:13 <napping> you can make a type like Env a, which has a different definition for each instance
02:36:19 <kmc> associated types are type / data families which happen to live in a type class
02:36:34 <quicksilver> Sadache: the binding, not the library.
02:36:46 <Sadache> ok ok
02:38:33 <jdsc> napping: I'm afraid I don't understand
02:38:56 <quicksilver> jdsc: you can make a type as part of a type class.
02:39:14 <quicksilver> jdsc: a conventional typeclass associates some functions with the types in the head
02:39:23 <quicksilver> jdsc: (actually, values, not functions, but they're very often functions)
02:39:32 <quicksilver> jdsc: with associated types you can also put some types in the class.
02:40:02 <quicksilver> class ToJson a where toJson :: a -> JSON; type Env a;
02:40:21 <quicksilver> jdsc: says that for any type 'a' which is a member of 'ToJson' there is a functon toJson and also a type 'Env a'
02:40:38 <quicksilver> ..which you could use in the method signatures, so
02:40:45 <quicksilver> toJson :: a -> Env a -> JSON 
02:40:52 <quicksilver> woudl haev been a better example.
02:41:02 <quicksilver> this is instead of having 'env' in the head of the class
02:41:16 <quicksilver> so it is, in a sense, a replace for multi-param type classes in some cases.
02:41:29 <jdsc> wow, that opens up a whole new design space for me
02:42:19 <jdsc> just out of curiosity, are they strictly equivalent ? I would imagine type families to be able to do everything MPTC do, and more
02:42:34 <quicksilver> they're much stronger than MPTC>
02:42:49 <quicksilver> in fact, you do use them together - you don't always reduce back to only one type in the head
02:42:55 <quicksilver> it's just this particular example did reduce that way.
02:43:15 <quicksilver> but (associated) type families genuinely add power.
02:45:06 <jdsc> thank you, you convinced me to go read that haskell wiki page on type families ^^
02:45:21 <Sadache> quicksilver: stupid question, what do you mean by "the binding not the library"?
02:45:38 <jdsc> if things go over my head, I'll go back to pestering people here :)
02:46:30 <quicksilver> Sadache: pcre is a C library.
02:46:37 <quicksilver> Sadache: it supports named groups (or so I imagine)
02:46:48 <quicksilver> Sadache: haskell-pcre is a haskell binding to a C library.
02:47:03 <quicksilver> the binding is not complete. It does not expose all the capabilities of the underlying library.
02:47:14 <quicksilver> In particular, it doesn't expose the named group functionality.
02:47:17 <quicksilver> Or, so I believe.
02:47:45 <quicksilver> I'm not entirely sure about this stuff, but I did check the docs for haskell-pcre and named groups certainly don't seem to get a mention.
02:48:02 <quicksilver> meanwhile, google tells me that pcre (version 7, at least) supports named groups.
02:49:09 <Sadache> quicksilver: ok now I understand
02:49:16 <Sadache> thank you quicksilver 
02:50:11 <fasta> quicksilver, how do you define "power"?
02:50:55 <fasta> quicksilver, with fundeps you can compute in the type-system if you enable everything, so I don't see what more power it brings. 
02:51:16 <quicksilver> fasta: I wasn't comparing ATs to FDs
02:51:26 <quicksilver> fasta: I was comparing ATs to MPTCs alone (with neither ATs nor FDs)
02:51:51 <fasta> quicksilver, ok.
02:51:55 <quicksilver> fasta: also, I never 'enable everything' because I consider some things to be misguided, immoral, or criminal.
02:52:08 <quicksilver> in that category are overlapping and incoherent instances.
02:52:17 <fasta> quicksilver, yes, I am familiar with your opinions on those things. 
02:52:56 <fasta> In my experience those things enable cool hacks, but in the end they usually get deleted from my code. 
02:53:25 <kmc> undecidable instances are totally fine, though
02:53:33 * hackagebot happy 1.18.5 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.5 (SimonMarlow)
02:53:34 <BAFANA|Taejo> I'm planning to give a lesson on parser combinators to some new Haskellers -- which library should I use? Is Parsec still considered cool, or is there something better that's almost as easy?
02:53:48 <BAFANA|Taejo> no, simonmar, not happy
02:53:49 <BAFANA|Taejo> :)
02:54:02 <kmc> i don't know why people get so upset about the idea that their compiler might not terminate
02:54:08 <kmc> especially when there's an ad-hoc way to bound it
02:54:29 <bremner> there are compilers with proofs of termination?
02:54:43 <kmc> yes, a few
02:54:47 <kmc> but that's besides the point
02:54:52 <quicksilver> kmc: I think one valid objection might be that the ad-hoc bound is a rather ad-hoc, and may be fragile w.r.t. some natural program transformations.
02:55:02 <quicksilver> kmc: but in general I agree with your line of argument.
02:55:09 <kmc> yeah
02:55:18 <kmc> it adds a little potential breakage at the build stage, i agree
02:55:34 <kmc> we Haskellers are used to plenty of errors as long as they're caught at compile time ;)
02:55:37 <quicksilver> BAFANA|Taejo: I would err on what you know well/can talk about comfortably.
02:55:51 <bremner> and have reference materials for
02:56:02 <quicksilver> BAFANA|Taejo: I have reasons to prefer polyparse to parsec, but I don't know that those reasons outweigh more pragmatic issues about what you can easily talk about
02:56:10 <BAFANA|Taejo> well I have at least a month, I'm sure I could learn polyparse
02:56:16 <kmc> BAFANA|Taejo, Parsec is still a big deal and it changed quite a bit in version 3
02:56:32 <kmc> a lot of people (including myself) might not know the new API in detail
02:56:36 <kmc> so it could be a good topic
02:56:48 <kmc> of course if you can learn four or five libraries and contrast them, so much the better :)
02:57:06 <kmc> iirc the uu-parsinglib tutorial is a sort of "you could have written uu-parsinglib yourself" document
02:57:07 <BAFANA|Taejo> what are the changes between 2 and 3?
02:58:12 <kmc> more generality, ParsecT is a monad transformer now, and there are appropriate Applicative instances as well
02:58:30 <kmc> it can parse from ByteStrings etc. via an input-stream abstraction
02:58:33 <kmc> beyond that, i don't know
02:59:11 <BAFANA|Taejo> ok, yeah, I don't think I'll talk too much about monad transformers. I'm very happy about the Applicative instance
02:59:29 <kmc> yeah, it is nice to write context-free grammars that way
02:59:30 <BAFANA|Taejo> in fact, I'm planning to introduce Applicative and Monad through the twin examples of IO and Parsec
03:05:47 <quicksilver> BAFANA|Taejo: of course, the applicative instance betrays the things I don't like about parsec.
03:06:00 <quicksilver> a <|> b doesn't necessarily parse everything you want it to
03:06:10 <quicksilver> if some aspect of 'a' commits to a symbol, then b will never get run.
03:06:21 <quicksilver> ...and that's not somethign you can easily know, without careful inspecton of the code of 'a'
03:06:26 <BAFANA|Taejo> quicksilver: agreed
03:06:55 <BAFANA|Taejo> is this Parsec wart or a problem with combinator parsing in general?
03:07:07 <quicksilver> it's a Parsec design decision
03:07:11 <quicksilver> but one with which I disagree.
03:07:19 <quicksilver> the justification is performance
03:07:24 <BAFANA|Taejo> yeah, I realise
03:07:27 <quicksilver> but it's not clear that that holds water in practice.
03:07:35 <quicksilver> polyparse has a <|> which 'works'
03:07:47 <BAFANA|Taejo> do you know of any benchmarks?
03:07:59 <zygoloid> a <|> b = try a <||> b.
03:08:08 <quicksilver> I prefer the situation in which, if I write a grammar with absurd amounts of backtracking, it runs slowly, but correctly
03:08:12 <zygoloid> s/|/||/ s/||/|/ ;-O
03:08:12 <BAFANA|Taejo> zygoloid: you mean the other way around?
03:08:15 <zygoloid> yeah
03:08:15 <BAFANA|Taejo> yeah
03:08:17 <quicksilver> I can always find ways to fix the backgracking.
03:08:34 <quicksilver> and in practice the grammars I write generally only have very small localised bits of backtracking
03:08:42 <quicksilver> and the exponential case doesn't actually happen.
03:09:06 <quicksilver> even better I'd prefer a system which did static analysis and left-factoring automatically, though.]
03:09:07 <BAFANA|Taejo> otoh, in practice I don't find it difficult to see which way to order <|> arguments and which ones need try
03:09:19 <zygoloid> quicksilver: as i understand it, the DDC parser has been made to avoid backtracking (almost) everywhere and there was a measurable speedup
03:09:28 <quicksilver> BAFANA|Taejo: but you do have to think carefully about the internals of "A"
03:09:38 <quicksilver> BAFANA|Taejo: which is, in some loose sense, an abstraction leak.
03:09:46 <quicksilver> or, at least, a weakening of abstraction.
03:09:58 <quicksilver> I'd rather have the ability to write A <|> B without worrying.
03:10:01 <zygoloid> (hooray for arrow-based parsing)
03:10:04 <quicksilver> of course, zygoloid is right w.r.t. try.
03:10:07 <BAFANA|Taejo> does the implementation of "a" make a difference, or only the language which it accepts?
03:10:15 <zygoloid> it's nice that parsec lets you choose
03:10:26 <quicksilver> zygoloid: sure. there are cases when the speedup is measurable.
03:10:29 <BAFANA|Taejo> it might be nice to have a correct default
03:10:38 <BAFANA|Taejo> and a faster "wrong" option
03:10:47 <quicksilver> zygoloid: on none of the occasions that I have personally used parser combinators, has speed of parsing ever been an issue.
03:11:01 <quicksilver> zygoloid: I appreciate that this is only an anecdote, and doesn't apply to every case.
03:11:24 <quicksilver> but I think there are plenty of occasions where parsing speed is not remotely close to bottlenecking a usage case.
03:11:37 <quicksilver> BAFANA|Taejo: the implementation matters, I believe.
03:13:02 <quicksilver> BAFANA|Taejo: (try (do char 'a'; char 'b') <|> try (do char 'b';char 'a')) and ((do char 'a';char'b') <|> (do char'b';char'a')) accept the same language
03:13:07 <cizra> I've got a weird problem with Gtk. I have a moderately simple window and a hello-world-simple program to show it. It only stays up for a limited time before dying. What could be wrong? Do you want to see the code?
03:13:18 <quicksilver> BAFANA|Taejo: but the former never commits on failure and the latter commits on failure if the first char is 'a' or 'b'
03:13:47 <blackh> cizra: Yep - paste away.
03:14:32 <cizra> The code: Your paste can be seen here: http://paste.pocoo.org/show/226457/
03:14:40 <cizra> The glade UI: http://paste.pocoo.org/show/226458/
03:14:41 <zygoloid> quicksilver: FWIW my experience has generally been the same. even parsing huge files, you need a very slow parser for the speed of the disk IO to not be the bottleneck.
03:15:30 <killerstorm> hi. I do not quite understand what is "weak head normal form" in context of strict evaluation. E.g. if I write "x `seq` (f x) where x = map foo [1,2,3]" would it actually map whole list before evaluating (f x)? 
03:15:31 <quicksilver> zygoloid: parsing multi-gig XML files is one case where you need to take some care in designing your parser.
03:15:37 <quicksilver> zygoloid: but, that's not the "common" case
03:15:45 <quicksilver> zygoloid: in the anecdotal sense of the word "common"
03:15:48 <killerstorm> I guess it won't and so I need a strict map...
03:16:08 <quicksilver> killerstorm: no.
03:16:15 <quicksilver> killerstorm: it will just evaluate to the top constructor
03:16:19 <quicksilver> which will be (:)
03:16:37 <quicksilver> so it will evaluate the map far enough to demonstrate that what is produced is not the empty list.
03:16:50 <quicksilver> you might think of the thunk as "foo 1 : map foo [2,3]"
03:16:56 <quicksilver> (foo 1 itself not yet evaluated)
03:17:08 <killerstorm> Is there a strict map?
03:17:12 <quicksilver> no.
03:17:15 <killerstorm> Like foldl' but for map
03:17:22 <quicksilver> you may want to deepSeq/rnf the result list
03:17:42 <quicksilver> although in general that's a nasty thing to do and you may need to explain what you're actually doing to get better suggestions.
03:18:12 <killerstorm> I'm going to experiment with parallel Haskell. 
03:18:23 <fasta> quicksilver, is there anything done in the compiler to rewrite rnfs to nops?
03:18:27 <killerstorm> As I understand I need to force it to evaluate something in parallel.
03:18:55 <fasta> (That's how it is supposed to work, imho.)
03:19:33 <quicksilver> fasta: I don't think so.
03:19:51 <quicksilver> killerstorm: the 'correct' way to force things to evaluate the way you want in paralle is the combinators in Control.Parallel.Strategies
03:19:54 <quicksilver> that's what they're for.
03:20:22 <quicksilver> certainly using 'seq' or 'rnf' isn't going to make anything parallel.
03:20:33 <blackh> cizra: I don't know of any reason why that code would die like you described.
03:20:49 <quicksilver> fasta: I think it will rewrite `seq` to a NOP in a few very specific cases
03:20:56 <quicksilver> fasta: but I don't believe that generalises well.
03:20:58 <quicksilver> I could be wrong.
03:21:59 <cizra> blackh: It doesn't give any errors. It just won't stay running.
03:22:05 <killerstorm> Umm, as I understand Control.Parallel.Strategies is like a high-level API for underlying `par` and `seq`. I want to understand how it works on low-level before going to high-level.
03:22:42 <ManateeLazyCat> Plan to binding poppler library (http://poppler.freedesktop.org/), then we can use haskell build a "pdf viewer" ! :)
03:22:55 <cizra> blackh: It's probably not dependent on the program. I have another hello-worldish test app that behaves the same.
03:23:15 <killerstorm> Or does Control.Parallel.Strategies do something what `par` and `seq` cannot do?
03:24:16 <quicksilver> killerstorm: well `par` and `pseq` and `seq`
03:24:29 <quicksilver> killerstorm: but yes, that is all it does.
03:25:00 <blackh> cizra: If you tell me what package Graphics.UI.Gtk.Glade is in, I'll try it here.
03:25:23 <cizra> blackh: How do I check it?
03:25:44 <cizra> blackh: "glade" sounds reasonable
03:26:03 <Twey> It's in Gtk2Hs
03:26:04 <quicksilver> cizra: ghc-pkg find-module Graphics.UI.Gtk.Glade
03:26:07 <blackh> Glade looks right
03:26:29 <quicksilver> not because you don't already have the answer, but because everyone should know about ghc-pkg find-module
03:26:33 <Twey> Hehe
03:26:53 <ManateeLazyCat> Anyone interesting poppler binding ? We work together? :)
03:27:12 <blackh> cizra: It hasn't died for me yet.  What OS are you using?
03:27:24 <cizra> quicksilver: thanks
03:27:32 <ManateeLazyCat> cizra: What's wrong with gtk2hs?
03:27:39 <killerstorm> quicksilver: Looks like I've found some good articles to read, thank you for keywords!
03:27:42 <cizra> blackh: Linux, amd64
03:27:59 <cizra> ManateeLazyCat: my program quits spontaneously in a few seconds after launching
03:28:14 <ManateeLazyCat> cizra: Example code?
03:28:21 <fasta> cizra, with what exit status?
03:28:26 <blackh> cizra: I'm on Ubuntu x86_64 and it works fine for me. I'm using GHC version 6.12.2.20100521
03:28:42 <ManateeLazyCat> blackh: gtk2hs with ghc-6.12.2 ?
03:28:55 <cizra> ManateeLazyCat: http://paste.pocoo.org/show/226457/ http://paste.pocoo.org/show/226458/
03:28:56 <blackh> ManateeLazyCat: No, 6.12.2.20100521. :)
03:29:13 <cizra> fasta: 11
03:29:16 <ManateeLazyCat> blackh: ghc-6.12.2 release version have bug that will crash gtk2hs signal.
03:29:18 <fasta> cizra, you should just try the gtk2hs tutorial and see whether that works. If it doesn't report a bug. 
03:29:31 <cizra> Arch Linux, amd64, The Glorious Glasgow Haskell Compilation System, version 6.12.1
03:29:40 <fasta> cizra, one of the first things is creating this hello world stuff you are doing.
03:29:57 <cizra> fasta: I did exactly that, followed the gtk2hs + Glade tutorial.
03:30:09 <blackh> ManateeLazyCat: But What I Am Trying To Say To You Is ... I'm not using that version!
03:30:20 <ManateeLazyCat> blackh: I know now :)
03:30:28 <fasta> cizra, ok, odd. (since when I tried it on my machine also Linux x86-64, it did work)
03:30:49 <fasta> cizra, you could try running it in gdb.
03:31:42 <cizra> hmmm, hasn't closed in GHC yet
03:31:44 <cizra> GDB, I mean
03:31:51 <ManateeLazyCat> cizra: Your code is correct, maybe you need run your program in gdb
03:32:00 <ManateeLazyCat> cizra: Then type "bt" to get backtrace
03:32:32 <cizra> owait
03:32:49 <cizra> Do you mean that GHC exit code 11 means something got a segfault inside?
03:33:34 <ManateeLazyCat> cizra: Get backtrace in gdb first, then we know how to help you. :) 
03:33:51 <fasta> cizra, 11 usually means segfault, yes.
03:34:12 <cizra> hmmm, it seems the _compiled_ version doesn't exit. runhaskell version does
03:34:29 <cizra> ManateeLazyCat: can't get backtrace in runhaskell (at least not easily)
03:34:36 <cizra> anyway, AFK for a couple
03:34:45 * blackh wouldn't even attempt to run gtk2hs in runhaskell. :)
03:34:54 <fasta> cizra, there was something broken about running gtk2hs in ghci. 
03:35:07 <fasta> I don't remember what, but I am sure someone knows.
03:35:21 <ManateeLazyCat> cizra: I mean, compile your program, then use "./gdb YourProgrom"
03:35:38 <ManateeLazyCat> cizra: If you talk about ghci, yes, it will got segfault
03:35:38 <blackh> Or compile your program, and it'll probably work.
03:35:40 <fasta> IMHO, runhaskell should work. 
03:36:01 <ManateeLazyCat> cizra: This is some issue that can't run gtk2hs program in ghci.
03:36:04 <fasta> Otherwise we should call it runhaskellandprayitworks
03:36:26 <ManateeLazyCat> cizra: But i'm sure it works correctly after you compile it.
03:36:39 <blackh> cizra - I just ran your program on my system with runhaskell and it died after a few seconds like you said.
03:37:25 * ManateeLazyCat I remember Axel has fix ghci issue in darcs version, let me check changelog......
03:37:50 <triyo> Hmm, something like this wouldn't work, would it? ... fileContents <- (bracket (openFile path ReadMode) hClose hGetContents)
03:38:01 <triyo> hGetContents is lazy seq right?
03:38:23 <ManateeLazyCat> cizra: Do you use Windows?
03:38:24 <quicksilver> hGetContents uses interleave IO, yes
03:38:42 <quicksilver> I don't think you're supposed to hClose the handle you get from hGetContents
03:38:54 <quicksilver> just use 'readFile' if that's what you want
03:38:58 <triyo> Right thats what I thought
03:39:28 <ManateeLazyCat> cizra: I remember someone report ghci issue at gtk2hs-list. 
03:39:42 <triyo> quicksilver: I don't wish to do all the manual labour of closing the the file after getting the contents
03:39:52 <ManateeLazyCat> cizra: And the result is, if you use ghci on Windows, you need Cabal 1.8
03:39:52 <ManateeLazyCat> cizra: Otherwise can't work.
03:40:06 <quicksilver> triyo: well, personally I'd put the action inside as a continuation
03:40:13 <quicksilver> triyo: but otherwise, use readFile.
03:40:19 <ManateeLazyCat> cizra: If you has Cabal 1.8 and still have ghci problem, maybe you need report it as bug to gtk2hs list.
03:41:00 <ManateeLazyCat> Dinner now, leave message to me.
03:41:07 <triyo> @type withFile
03:41:08 <lambdabot> Not in scope: `withFile'
03:41:14 <triyo> hmm :)
03:41:59 <quicksilver> @hoogle withFile
03:41:59 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
03:42:16 <quicksilver> triyo: yes, that's what I meant by 'action inside as a continuation'
03:42:32 <triyo> cool
03:42:36 <triyo> I'll give that a try
03:42:52 <quicksilver> withFile "firstFile" ReadMode $ \h1 -> withFile "secondFile" ReadMode $ \h2 -> doTheRealWork h1 h2
03:43:28 <quicksilver> withFile should do the whole exception handling/definitely closing the file thing correctly.
03:47:41 <triyo> quicksilver: Hmm not to sure if I understand the handler part 100% ... I need something like ... fileContents <- withFile path ReadMode \h -> parseFile hGetContents .... the handler will contain a pare file function call hat need to receive the content of the source file
03:49:19 <triyo> I can probably use getContents
03:49:22 <triyo> right?
03:49:30 <Botje> triyo: hGetcontents h >>= return . pureFunction
03:49:33 <Botje> or, if you want
03:49:44 <Botje> pureFunction `liftM` hGetcontents h
03:51:44 <quicksilver> just make sure you consume every byte of that string before you action returns
03:51:53 <quicksilver> because after you return, the hClose will truncate the string
03:53:41 <quicksilver> well, every byte you care about anyway
03:53:50 <quicksilver> if there is a tail of the file you catually don't need to read that won't matter, I don't think.
03:55:07 <triyo> Ok, now it looks like so: .... fileContents <- withFile path ReadMode $ \h -> parseFile `liftM` hGetContents h ... but the fileContents binding has an empty String and I know the file contains content
03:56:59 <quicksilver> because Botje gave you very bad advice.
03:57:10 <quicksilver> since parseFile is a pure function, it's applied lazily
03:57:12 <triyo> hehe :),
03:57:21 <quicksilver> so it's not actually applied until after your action returns
03:57:28 <quicksilver> at which point you have hClosed the file and the string is empty
03:57:36 <triyo> right, so how do I forse the evaluation
03:57:40 <quicksilver> this is why hGetContents is a bloody mess, and a wart on the language
03:57:41 <Botje> tricksy lazy io :(
03:57:50 <quicksilver> Botje: s/tricksy/utterly broken/
03:57:55 <quicksilver> Botje: s/lazy/interleaved/
03:58:07 <Botje> :)
03:58:08 <triyo> Poor, poor n00bies
03:58:17 <quicksilver> the single worst decision in the haskell report was hGetContents and readFile
03:58:22 <quicksilver> what a disastrous idea.
03:58:50 <quicksilver> design a language intended to have well-defined semantics and make the basic IO primitives have subtle and apparently broken semantics.
03:59:00 <mreh> a grain of sand in a sea of diamonds
03:59:05 <quicksilver> sure.
03:59:07 <quicksilver> haskell's great.
03:59:33 <triyo> Maybe just to restate my ultimate intention. :) I wish to, in single swoop, load the contents of a text file.
03:59:45 <quicksilver> the simplest answer is to use readFile
03:59:50 <quicksilver> and not worry about when the file gets closed.
04:00:03 <agocorona> IO is a bad decission. All computations should live in their inmutable pure heaven forever
04:00:05 <triyo> By load, I mean run the action and not get lazy seq...
04:00:41 <triyo> quicksilver: cool, thx
04:00:54 <Zao> agocorona: Where does data come from, daddy?
04:01:15 <agocorona> who needs data? we just need equations ;)
04:01:20 <mreh> what about the real world?
04:01:32 <pastorn> is there such a thing?
04:01:36 <agocorona> kidding
04:01:37 <mreh> RealWorld(TM)
04:02:06 <mreh> isn't that the constructor in the ST monad?
04:02:15 <exDM69> I lost count after RealWorld'''
04:03:02 <profmakx> look in what state it is
04:03:06 <profmakx> okay lame joke.
04:03:12 <pastorn> newtype IO a
04:03:14 <pastorn>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
04:03:16 <pastorn>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
04:03:46 <pastorn> RealWorld only exists as a construct in GHC :D
04:04:11 <mreh> which is implemented in the real world, d'oh!
04:07:34 <triyo> quicksilver: thanks I got it to work but I can't close the file explicitly of course because of the laziness. :)
04:07:58 * quicksilver nods
04:08:33 * triyo shakes his head
04:11:39 <blueonyx> hey, when implementing MapReduce, where the map and reduce functions are interpreted haskell, what would be a good name for the map function (because of Prelude.map)?
04:12:36 <mreh> it's the same function
04:13:16 <mreh> at least as far as I understand it
04:13:42 <mreh> haskell supports map reduce natively :D
04:14:27 <quicksilver> well the point of mapreduce is distributed processing
04:14:35 <quicksilver> haskell doesn't support that natively.
04:14:49 <blueonyx> okay it's couchdb, and it's map has type JSValue -> [(JSValue,JSValue)]
04:14:57 <quicksilver> there have been a few independent attempts in that direction with some success but they all bit rotted.
04:15:28 <blueonyx> so you have to produce keyvalue pairs
04:15:32 <quicksilver> I'd just call it xyzMap where xyz is some sensible abbreviation of your library/module name
04:16:15 * triyo map-   ;-)
04:51:59 <ManateeLazyCat> http://farm5.static.flickr.com/4007/4708981380_d59262b82d_b.jpg build your own mplayer . :)
04:54:56 <ivanm> ManateeLazyCat: which episode of Dr Who is that?
04:56:01 <ivanm> ManateeLazyCat: also, you should probably consider using a different name rather than mplayer...
04:56:14 <ManateeLazyCat> ivanm: Christmas special of Doctor season 5. :)
04:56:30 <ivanm> oh, the wooden cyberking?
04:56:34 <ivanm> yeah, that one was cool
04:56:51 <ManateeLazyCat> ivanm: Yep.
04:57:12 <ManateeLazyCat> ivanm: Now, i have use code show how easy use gtk2hs build a client for other program.
04:57:33 <ManateeLazyCat> ivanm: Webkit, mplayer, emacs, vim, terminal, pdf viewer..... :)
04:58:18 <ManateeLazyCat> ivanm: Emacs and vim has similar option like mplayer, so i can embedded it my program .... :)
04:58:28 <ivanm> XEmbed?
04:58:39 <ManateeLazyCat> ivanm: Yes
04:58:59 <p_l> actually, doesn't that work for all properly written X11 apps?
04:59:07 <ManateeLazyCat> ivanm: I use GtkSocket/GtkPlug (the gtk+ implementation of Xembeded protocol).
04:59:23 <p_l> with the difference being that the ones that don't have special support for XEmbed might have some focus issues etc.?
04:59:25 <ivanm> p_l: nah, they have to support XEmbed IIRC
04:59:29 <ManateeLazyCat> p_l: Yes, in principle.
04:59:31 <ivanm> emacs has only gotten XEmbed recently
04:59:59 <ManateeLazyCat> ivanm: Even Qt program can embedded in.
04:59:59 <p_l> ivanm: Emacs recently got *embedding*, not being *embedded*. You just have to force it into proper window ;)
05:00:32 <ivanm> p_l: nah, it only recently got the ability to be embedded as well
05:00:39 <ManateeLazyCat> ivanm: Maybe i don't need write editor sub-module for vi user. Just embedded vim in ... :)
05:00:58 <ivanm> I know becuase I wanted to try some python-based meta-IDE that let you use your own editor a few years back and emacs had to have some patches applied for it to work
05:01:45 <ivanm> see http://www.emacswiki.org/emacs/EmacsXembed
05:01:49 <ivanm> only as of 23.1
05:03:13 <p_l> ivanm: it means that as of 23.1 you can pass it as an option to it and that Emacs will be aware of being embedded... however, you could embed it before. How do you think most WMs do their window decorations? ;D
05:03:16 <ManateeLazyCat> ivanm: Embedded emacs is cool, but i don't like idea, it's will confusion me. :)
05:03:41 <ivanm> p_l: well, by embedding I assumed you meant support XEmbed properly
05:04:04 <p_l> well, I hinted about using force :D
05:08:10 <ivanm> p_l: so you admit you were being a smart-arse? :p
05:08:57 <cizra> ManateeLazyCat, fasta, blackh: Thanks you guys (gals?). Compiling my program instead of runhaskelling it is good enough workaround.
05:09:51 <ManateeLazyCat> cizra: You're welcome. :)
05:13:17 * ManateeLazyCat I hope oneday we have *completely* haskell/gtk+ environment, then will more and more people to join the haskell. :)
05:13:54 <cizra> ManateeLazyCat: You mean everything is written in Haskell using GTK?
05:14:11 <ManateeLazyCat> cizra: Yes.
05:14:20 <ManateeLazyCat> cizra: Infact, i has working on it.
05:15:11 <ManateeLazyCat> cizra: That's why i try to binding many gui library for gtk2hs, ready for this Environment.
05:16:03 <ManateeLazyCat> cizra: I think use gtk2hs will get better/bug-free program than C base on Gtk+.
05:16:36 <quicksilver> ManateeLazyCat: as long as the bindings are appropriately safe, definitely.
05:16:47 <mjk> ManateeLazyCat: Haskell + Gtk? beautiful!
05:16:48 <ManateeLazyCat> quicksilver: Yes.
05:17:12 <Ke> still dynamic linking, seccomp, daemon, fork ... lots of necessary low level stuff still missing
05:17:35 <Ke> and quite a few high level libs
05:17:49 <Ke> like ipc
05:17:53 <ManateeLazyCat> quicksilver: Of course, all (include guil toolkit) is Haskell is perfect, but from currently situation, mix low-level C library and Haskell is cheapest way.
05:18:43 <ManateeLazyCat> Ke: Well, i understand what you mean, but we can't write everything with Haskell since has other language (such as C) implementation, that's costly.
05:19:42 <Ke> imo there shouldn't be any programs that interface with remote data without seccomp
05:20:03 <Ke> well besides sshd and such...
05:20:28 <ManateeLazyCat> gtk2hs can make you focus your real problem, and don't disturb by some many low-level detail . (such as memory manage).
05:20:58 <ManateeLazyCat> Ke: Well, for remote operation, we can use gtk2hs build a terminal, then do those work in terminal.
05:21:03 <ManateeLazyCat> Ke: "cabal install vte"
05:21:08 <ManateeLazyCat> @package vte
05:21:09 <lambdabot> http://hackage.haskell.org/package/vte
05:21:16 <mnislaih> ping Heffalump
05:21:26 <Ke> hwe are not really communicating =o)
05:21:48 <ManateeLazyCat> Ke: My english is always the best. :)
05:21:51 <ManateeLazyCat> is not
05:21:56 * ManateeLazyCat Damn.... 
05:23:27 * ManateeLazyCat I hope someday i can travel in other country to improve my English, sometimes, i can't explain my point exactly.
05:24:27 * earthy grins
05:24:34 <ManateeLazyCat> Ke: seccomp? http://en.wikipedia.org/wiki/Seccomp ?
05:26:48 * ManateeLazyCat I like Chrome's sandbox model, to beat baleful code ...
05:26:59 <quicksilver> ManateeLazyCat: your english is already much better than when you first came here.
05:27:07 <quicksilver> ManateeLazyCat: I'm sure it will continue to improve quickly.
05:27:20 <ManateeLazyCat> quicksilver: Indeed :)
05:27:23 <quicksilver> and 'baleful', by the way, is a beautiful word. I resolve to use it more often.
05:27:27 <ivanm> quicksilver: whilst you're here: what's your take on the FGL naming controversy I seem to have kicked off?
05:27:33 <ivanm> quicksilver: lol
05:27:38 <quicksilver> ivanm: I'm afraid I can't get very excited by it.
05:27:45 <ivanm> heh, fair enough
05:28:03 <quicksilver> I don't much care what things are called.
05:28:15 <ivanm> especially libraries you don't use? :p
05:29:41 <fasta> ivanm, just name it the exact same as existing libraries (not only BGL, but there are also others). 
05:30:16 <ivanm> fasta: well, there'd be no point in calling it the boost graph library since I'm not writing it in C++... :p
05:30:18 <quicksilver> ivanm: well there is that :)
05:30:42 <fasta> ivanm, oh, I thought you were talking about API functions. The name of the actual library is even of less interest :)
05:30:49 <ivanm> lol
05:30:57 <ivanm> fasta: you obviously missed the whole argument
05:31:02 <fasta> ivanm, yes, I did :)
05:31:16 <ivanm> see the controversy section here: http://ivanmiljenovic.wordpress.com/2010/06/12/pre-announce-for-the-new-fgl/
05:31:33 <triyo> I'm trying to figure out how parsec works. I'm trying to do something very simple like find all integers in a given string. I saw there is a "integer" function Parsec.Token...
05:31:52 <ivanm> triyo: RWH has a chapter on parsec (parsec-2 though, not parsec-3)
05:32:02 <ivanm> also, what does "all integers in a given string" mean?
05:32:13 * ivanm also thinks polyparse is nicer than parsec, but that's another story
05:32:28 <ManateeLazyCat> ivanm: Your blog filter by GFW, sadly......
05:32:38 <ivanm> ManateeLazyCat: :(
05:32:45 <ivanm> ManateeLazyCat: is planet haskell filtered?
05:32:48 <triyo> "xxx 1 yyy 2 zzz 3" -> [1,2,3]
05:32:51 <ManateeLazyCat> ivanm: All.
05:32:52 <ivanm> because you should be able to read it there as well
05:33:09 <ivanm> ManateeLazyCat: oh, and don't worry, we're most likely going to get our own filter here as well :s
05:33:12 <ManateeLazyCat> ivanm: All wordpress.com and blogspot.com and many other sites.
05:33:39 <ivanm> well, planet.haskell.org has a copy of it atm
05:34:07 <fasta> ivanm, first you say you maintain FGL and then you are going to change the API. That's not maintaining. 
05:34:21 <fasta> ivanm, I am in the change the name camp obviously. 
05:34:42 <ivanm> fasta: so once an API is set it should never ever be changed?
05:35:06 <ivanm> IMHO, maintaining is not just comprised of bug-fixing
05:35:09 <fasta> ivanm, the API can be changed, but it should get a completely new name, something like FGLFoobar.
05:35:12 <ManateeLazyCat> ivanm: Unfortunately, i need develop proxy tool before i relase webkit browser, otherwise i even can access many sites (google, flickr, wordpress.com, blogspot.com, facebook.com, twitter.com, all *top-level* sites.... ) 
05:35:26 <ivanm> the reason martin gave it up for adoption is because people from the HNN project were asking for improvements and he didn't have time
05:35:47 <fasta> ivanm, what happens when you want to commit a bugfix in the old version?
05:35:47 <ivanm> fasta: so yes, you're saying that once someone has developed an API they can never change it again
05:36:01 <ivanm> fasta: no reason I can't do that if necessary
05:36:22 <ivanm> I'm even considering doing gradual transition releases once we've determiend what the new API is going to be like
05:36:26 * ManateeLazyCat Why i'm borned in China? And not other country? ....
05:36:33 <fasta> ivanm, and how would that work? You will get FGL-1.0 being the old version and FGL-1.1 being the new version and so on?
05:36:43 <fasta> ivanm, arbitrary version numbers
05:36:54 <ivanm> not at all
05:36:56 <ivanm> @where PVP
05:36:56 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
05:37:43 <ivanm> for a.b.c.d, change in a denotes major API change; change in b denotes minor non-backwards-compatible API change; change in c denotes backwards-compatible change (i.e. inclusions to the library) and change in d denotes bugfix
05:37:47 <fasta> ivanm, if that policy is codified in tools then it would make sense, I suppose. 
05:38:02 <fasta> ivanm, but I don't think tools actually care about those things yet. 
05:38:28 <ivanm> well, no, but dcoutts is working towards codifying it in Cabal by optional opt-in
05:38:44 <fasta> The whole concept of version numbers is also a mistake, since they are a human maintained number, not what we actually want to express: "did we break the API?"
05:38:50 <ivanm> and it's already recommended that you go and use those requirements for setting upper and lower bounds
05:39:04 <ivanm> fasta: how else would we express that?
05:39:19 <fasta> Feature detection like in autoconf is a very old method and known to be better than version numbers. 
05:39:33 <ivanm> and by comparing two version numbers that follow the PVP, you can tell if the API is broken (assuming the developer does their job properly)
05:39:52 <fasta> ivanm, yes, but there is still a human part there. 
05:40:23 <fasta> Humans are pretty unreliable and it only wastes time to have numbers. 
05:40:28 <ivanm> someone has also written an initial hacky script (in perl IIRC) to compare two versions and determine if the version change makes sense
05:40:58 <fasta> Right, a "hacky script". Things like that have to be done once and they have to be done well. 
05:41:19 <fasta> Otherwise you end up with "yes, it works in situations x and y, but not in z".
05:43:04 <ivanm> right; there are some people working on a proper version (using haskell-src-exts, etc.)
05:43:24 <ivanm> anyway, I should try to get an early night for once
05:43:25 <ivanm> g'night all
05:49:43 <Ke> ManateeLazyCat: yup that seccomp indeed
05:59:04 * hackagebot gsmenu 2.0 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-2.0 (TroelsHenriksen)
06:21:40 <gio123> i need to install haskell, which interpreter is good to install
06:21:41 <gio123> ?
06:22:02 <p_l> gio123: get ghc (compiler)
06:22:14 <gio123> could u gve me a link please
06:22:19 <gio123> and also is it for mac
06:22:20 <gio123> ?
06:22:42 <eevar2> haskell.org/platform
06:23:41 <gio123> For most users, we recommend installing the Haskell Platform instead of GHC
06:24:02 <eevar2> the platform contains ghc+++
06:24:47 <gio123> ok
06:24:54 <gio123> thanks i am downloading it
06:32:02 <magthe> I have a file where the 8 first bytes are an integer-as-a-string (think printf("%08d", ...)), I thought I'd use bytestrings (they're handy for some other things I need to do with the file)... but how do I convert the [Word8] into an Int in a nice way?
06:33:26 <Axman6> TacticalGrace: i'm around now if you're still here
06:34:30 <Zao> magthe: Sneak into a [Char], use read?
06:34:45 <Zao> Or maybe fiddle with ByteString.Char8.
06:35:09 <magthe> Zao: yes, it seems to be the easiest route I suppose
06:36:01 <EvanR-work> i could install platform without ghc
06:36:05 <EvanR-work> couldnt
06:38:57 <quicksilver> magthe: unpack . take 8
06:39:07 <quicksilver> magthe: (on the Char8 version of the byestring)
06:39:10 <quicksilver> and then erad
06:39:11 <quicksilver> read
06:40:10 <magthe> quicksilver: yes, thanks!
06:40:39 <quicksilver> @hoogle w2c
06:40:40 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
06:40:53 <quicksilver> you can just use chr, of course
06:40:56 <quicksilver> @hoogle chr
06:40:56 <lambdabot> Data.Char chr :: Int -> Char
06:40:56 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
06:40:56 <lambdabot> Network.Browser chRealm :: Challenge -> String
06:41:11 <quicksilver> :t map (chr . fromIntegral)
06:41:12 <lambdabot> forall a. (Integral a) => [a] -> [Char]
06:41:24 <quicksilver> :t read . map (chr . fromIntegral) . take 8
06:41:25 <lambdabot> forall a a1. (Read a, Integral a1) => [a1] -> a
06:42:00 <quicksilver> :t read . map (chr . fromIntegral) . BS.take 8
06:42:01 <lambdabot>     Couldn't match expected type `[a]'
06:42:01 <lambdabot>            against inferred type `BSC.ByteString'
06:42:01 <lambdabot>       Expected type: BSC.ByteString -> [a]
06:42:09 <quicksilver> :t read . map (chr . fromIntegral) . BS.unpack . BS.take 8
06:42:09 <lambdabot> forall a. (Read a) => BSC.ByteString -> a
06:43:34 * hackagebot QuickCheck 2.1.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.1.1 (NickSmallbone)
06:48:38 <robertmassaioli> hmm new version of quickcheck
06:48:44 * robertmassaioli goes to check
06:49:21 * edwardk_ goes to check, quickly
06:53:54 * fryguybob verifies new QuickCheck passed 100 tests.
06:55:09 <andrewsw> :t flip when 
06:55:10 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
06:55:39 <fasta> Is there any memory allocator known with some nice provable bounds? I might be solving a very related problem and I seem to recall I had a discussion here once about that subject.  
06:56:06 <edwardk_> fasta: several, it depends on your concurrency requirements what is ideal for you though
06:56:21 <fasta> edwardk_, currently there are no concurrency requirements.
06:56:41 * hackagebot QuickCheck 2.1.1.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.1.1.1 (NickSmallbone)
06:56:57 <edwardk_> are you willing able to garbage collect this thing that you're modeling with memory?
06:57:03 <edwardk_> er willing/able
06:57:10 <TacticalGrace> Axman6: hey
06:57:18 <Axman6> o/
06:57:20 <Axman6> what's up?
06:57:31 <TacticalGrace> Axman6: I was wondering how many people registered for AusHac?
06:57:40 <Axman6> one sec, i'll check
06:57:48 <fasta> edwardk_, it basically is a mirror of a vertex buffer of a game-engine, so I have to manage it myself.  
06:58:34 <magthe> quicksilver: I settled for: read . unpack (where unpack comes from Data.ByteString.Char8)
06:58:38 <fasta> edwardk_, basically the game-engine doesn't provide stuff to delete primitive objects, so I am built a layer on top of that, which does that using a simple amortization trick.
06:58:40 <edwardk_> fasta: ah, so you're going to kep allocating fragments but can't suffer long pauses, etc.
06:59:03 <edwardk_> http://domino.watson.ibm.com/comm/research_projects.nsf/pages/metronome.metronomegc.html exists, but might be serious overkill
06:59:03 <fasta> edwardk_, well, currently I don't see any way around not having any pauses. 
06:59:28 <fasta> edwardk_, basically because the thing I am mirroring is quicksand.  
06:59:40 <edwardk_> *nods*
06:59:45 <Axman6> TacticalGrace: 29 have put something on the list, not all are confirme, and a few of those i think have said they can't come
06:59:57 <edwardk_> is it something you can at least reset every frame in your current model?
07:00:19 <Axman6> TacticalGrace: you will be chaining david t to a table in the room to stop him from leaving right?
07:00:19 <edwardk_> that is usually the easiest way to get nigh free allocation in a game engine
07:00:54 <TacticalGrace> Axman6: I wonder whether it would make sense to send a brief email to everybody who registered and ask them to confirm that they are still coming
07:01:05 <TacticalGrace> the reg started quite a while ago
07:01:07 <Axman6> yeah, that's a good idea
07:01:09 <edwardk_> Axman6: better to find something structural that is part of the building. tables can be moved.
07:01:17 <TacticalGrace> there may be quite a number of people whose plans changed
07:01:24 <Axman6> yeah
07:01:36 <TacticalGrace> Axman6: davidt is currently at MSR
07:01:38 <fasta> edwardk_, if the UI is changed, something like that could work, I guess. 
07:01:41 <TacticalGrace> (internship with GHC HQ)
07:01:55 <Axman6> we'll put some more stuff on reddit and -cafe etc, and send emails to all who have registered
07:02:15 <Axman6> ah bastard, he sensed my plan and got out before we could stop him!
07:02:18 <TacticalGrace> great that gives us a better idea of numbers
07:02:23 <TacticalGrace> hehe
07:02:44 <edwardk_> fasta: then a cheesy bump allocated heap would probably be where i'd go. just grab a chunk of memory and track a pointer into it that you carve off chunks from by either subtracting from or adding to (i tend to walk down)
07:05:35 <TacticalGrace> Axman6: when you email the registered people, you may want to suggest that they have another look at the wiki page and update plans on what they want to work on
07:05:48 <Axman6> ok
07:06:10 <TacticalGrace> it'll be more effective if people already formed groups and started to think about their projects before they come
07:06:36 <TacticalGrace> otherwise, we lose have a day on that stuff, I guess
07:07:36 <blackh> TacticalGrace, Axman6: I want to ask a question: What is the difference between repa and accelerate? I'm thinking of working on accelerate.
07:07:53 * Axman6 deferrs to TacticalGrace 
07:08:48 <TacticalGrace> blackh: repa is a regular Haskell library, where arrays are an abstract data type and it has a range of functions on those arrays
07:09:03 <TacticalGrace> Accelerate is an EDSL
07:09:15 <gio123> i downladed ghc
07:09:23 <TacticalGrace> so you Haskell program, describes a program in an embedded min-array-language
07:09:25 <gio123> but install button is not actove
07:09:27 <blackh> I've read the code for accelerate in great detail.  Is any of the GPU or LLVM code on hackage or is that elsewhere?
07:09:30 <TacticalGrace> min = mini
07:09:31 <gio123> when i want to install it
07:10:18 <eevar2> gio123: the platform installer? you have to click "install for all users", even if it's the only choice and looks selected already
07:10:21 <TacticalGrace> as a result, the kind of programs you can do in Accelerate are restricted (compared to Repa), but they can be more aggressively optimised, too
07:10:32 <gio123> yes
07:10:33 <gio123> i did
07:10:38 <blackh> TacticalGrace: I also want to ask, where does accelerate fit in to the greater scheme? Is it ultimately going to be replaced by GHC's improved optimization, for example?
07:10:40 <TacticalGrace> blackh: neither backend is released yet
07:10:51 <gio123> i tried both
07:10:55 <gio123> the platfor installer
07:10:56 <gio123> and
07:11:09 <TacticalGrace> blackh: there is a reasonable chance that the GPU backend will be released before AusHac
07:11:28 <gio123> install new ghc
07:11:42 <gio123> but platform fails during instalation
07:11:53 <TacticalGrace> blackh: the LLVM backend is further behind (I basically didn't get any chance to work on it the last 3 month due to teaching)
07:11:55 <gio123> and install new ghc does not give me active intsall button
07:12:29 <TacticalGrace> blackh: I don't think GHC's optimisations will ever get to the point where they can compete with Accelerate performance-wise
07:12:35 <blackh> TacticalGrace: I work for this games company iPwn Studios which you may have heard of. accelerate could be immediately useful.
07:12:47 <eevar2> gio123: any kind of error message then? does it say you need to install XCode first, for instance?
07:12:55 <gio123> noo
07:13:02 <TacticalGrace> blackh: it's a tradeoff between expressiveness and performance, Accelerate goes for performance and repa for expressiveness
07:13:03 <gio123> it says to contact 
07:13:11 <gio123> ghc ppl
07:13:12 <gio123> :)
07:13:43 <blackh> TacticalGrace: OK - it's all becoming clear.  Well, we have code to generate terrain that isn't fast enough, and we have translated some of it into C. Most of it could be written in accelerate instead.
07:14:02 <TacticalGrace> blackh: yeah, you could imagine generating standalone kernels from Accelerate that don't work with a Haskell runtime, but, say, in an Objective-C program
07:14:32 <fasta> edwardk_, what do you mean by a cheesy bump allocated heap? In particular the cheesy bump part ;)
07:14:38 <blackh> Aha, right - excellent.  Well, I think accelerate is my first choice of project to work on.
07:14:44 <gio123> the instalation encountered an error that caused instalation to fail
07:14:48 <TacticalGrace> blackh: when I say, you could imagine, I mean that that would require an extension to the current model, but I reckon it would not be that hard
07:14:59 <gio123> contact the sfotware manufacturer
07:15:04 <gio123> this is a message
07:15:23 <gio123> eevar2: do u have any sugestion?
07:15:46 <edwardk_> pool = (char *) malloc(LOTSOFMEMORY) + LOTSOFMEMORY;   alloc<T>(n) = (T)(pool -= n)
07:15:51 <TacticalGrace> blackh: when you say your terrain code isn't fast enough, how much faster would it need to be?
07:15:56 <blackh> TacticalGrace: So in an application you could either have baked accelerate kernels or include the llvm / CUDA compilers and generate them on the fly.
07:16:24 <edwardk_> alloc just bumps a pointer and gives it to you
07:16:33 <blackh> TacticalGrace: About 60% of it is in C and 25% to 50% faster would be acceptable.
07:16:42 <eevar2> gio123: i don't, sorry. someone else might, though. or you could find something useful on google / the haskell platform page
07:17:06 <fasta> edwardk_, but that doesn't solve the problem.
07:17:06 <blackh> TacticalGrace: We've kept all the Haskell because ultimately we want to get rid of the C.
07:17:10 <edwardk_> fasta: feel free to amend with a check for empty heap, etc.
07:17:15 <TacticalGrace> blackh: at the moment, everything is generated dynamically, but you could change that, for example with TH
07:17:22 <fasta> edwardk_, the problem would be finding holes in this LOTSOFMEMORY. 
07:17:31 <edwardk_> fasta: well, the idea being that if you can reset it every frame you just blow away the heap and start over from the top.
07:17:38 <TacticalGrace> blackh: for iOS, it might be interesting to generate NEON code
07:17:46 <fasta> edwardk_, that is, it should solve the memory fragmentation problem that people in the C world have.
07:17:54 <blackh> TacticalGrace: With LLVM you could easily turn that into an object file and link it in.
07:18:01 <edwardk_> fasta: lots of game engines used to use this since you accumulate a ton of detritus that only last the frame
07:18:27 <fasta> edwardk_, ok, it is not that kind of problem. 
07:18:32 <TacticalGrace> blackh: yep
07:18:55 <edwardk_> fasta: i figured it wouldn't be, but i was hopeful based on your earlier response.
07:19:16 <fasta> edwardk_, yes, I misunderstood what you meant by that. Sorry, about that.
07:19:19 <blackh> TacticalGrace: So I'll get lots of coffee and pizza and get stuck in at AusHack, and see what I can do!
07:19:29 <TacticalGrace> blackh: cool :)
07:19:35 <edwardk_> fasta: so it sounds like you need an real, honest to goodness garbage collector
07:20:22 <fasta> edwardk_, yes, but it is slightly more complicated since references to memory cells also need to be remembered in another structure.
07:20:32 <blackh> TacticalGrace: Any priority list?  (I'm more interested in advancing the project in general than whatever needs I might have for now.)
07:20:38 <fasta> edwardk_, so, when the GC might move stuff it has to keep track of that too. 
07:20:55 <edwardk_> probably with real time guarantees, but then everyone claims their GC is 'real time', so you need something really real time ;)
07:21:15 <fasta> edwardk_, well, it is more for an editor, so "not slow" would be OK. 
07:21:21 <TacticalGrace> blackh: the backends are the priority atm, if the GPU backend is far enough, it might be nice to hack that
07:21:51 <blackh> TacticalGrace: Oh yes - what about parallelism?
07:22:13 <TacticalGrace> blackh: the GPU backend generates massively parallel code
07:22:21 <edwardk_> fasta: *nods* tracking references in is actually not so bad, you can use some pointer inversion techniques to basically let the objects you're tracking know a linked list of their references, so they know who to tell when they move
07:22:43 <blackh> TacticalGrace: I like the sound of that.  Well, I have an NVidia card in my computer.
07:23:14 <TacticalGrace> blackh: but a C backend generating multithreaded code might be interesting
07:23:21 <edwardk_> fasta: that lets most of the surrounding code not have to care that you're collecting some particular resource.
07:23:30 <fasta> edwardk_, ok, so that pretty much nails it. 
07:23:40 <TacticalGrace> might = might also
07:23:52 <TacticalGrace> or acually an OpenCL backend
07:24:09 <TacticalGrace> quite a few people asked whether we had plans for that
07:24:14 <fasta> edwardk_, I had been using some data structures that were in the previous implementation, but it seems I need to can all of that. 
07:24:26 <Axman6> TacticalGrace: using OpenMP?
07:24:28 <p_l> TacticalGrace: try making a NCG that generates code that would exploit SMT directly, or try fitting multiple threads (non-OS) into different parts of pipeline
07:24:43 <Axman6> or, GCD on OS X, which i have a strong feeling should perform better than OpenMP
07:25:02 <blackh> TacticalGrace: I also thought about translating some of the game code into accelerate as a real world test case.  If that sounds like it fills a need, tell me, and I'll seek approval.  (It's all proprietary.)
07:25:15 <Axman6> it's more like the threading model of GHC, m:n threading with the system deciding how many threads to use
07:25:39 <blackh> Axman6: Or TBB
07:25:42 <TacticalGrace> blackh: sure that would be ineresting if accelerate in its current form is expressive enough
07:26:47 <TacticalGrace> p_l: for SMT, I think, going via LLVM would be the easiest
07:27:08 <blackh> TacticalGrace: I think it should be, but it'd be great to put the abstraction to the test with something real.
07:27:29 <TacticalGrace> blackh: sure
07:28:06 <TacticalGrace> blackh: maybe even not the exact code you are using, if you don't want to open that, but some variant
07:28:20 <fasta> edwardk_, hmm, actually, I am already doing that, but the real problem would still be the "hole finding".
07:28:28 <TacticalGrace> blackh: eg, maybe you do something in 3D, which could also be done in 2D
07:28:39 <blackh> It is in many parts. I'll have a talk to Ryan - he is very interested in speed, as well as doing good stuff for the community.
07:28:45 <blackh> Ryan is the boss of the project.
07:28:49 <TacticalGrace> ok
07:29:05 <fasta> edwardk_, AFAIK, you have best-fit (and some other basic strategies), but fundamentally it all isn't that great.
07:29:42 <edwardk_> fasta: well, there are a bunch of strategies you can use for collection, mark/sweep leaves you with holes. how you handle holes is up to you. there are various compaction techniques. if you don't have hard realtime requirements and your data isn't huge, you might just use a copying collector or something to pack it every once in a while
07:29:54 <TacticalGrace> blackh: I just got package llvm to load into ghci, that should make dev''ing with it much nicer
07:30:04 <edwardk_> do these objects refer to each other?
07:30:20 <edwardk_> or are all references coming in? do you need to gc or just reference count?
07:30:30 <fasta> edwardk_, just reference count. 
07:30:31 <TacticalGrace> (now I only need to massage configure.ac, such that it generates the correct pkg conf automatically)
07:30:38 <edwardk_> fasta: then this is getting simpler and simpler ;)
07:30:41 <fasta> edwardk_, which is what I am currently doing. 
07:30:49 <quicksilver> edwardk_: or you use 2 (or more) generations with different strategies
07:31:12 <edwardk_> quicksilver: yeah. but it doesn't even sound like it needs real gc, just a heap compaction mechanism
07:31:14 <fasta> edwardk_: I could do a copying phase according to some condition. 
07:32:22 <fasta> edwardk_, and to get some kind of speed illusion I could simply create two threads, one containing the old structure and one updating one and when the machine outperforms the user, make the switch behind the scenes.
07:33:31 <edwardk_> so straw man #2, you have references into this heap which you've backthreaded pointers from the object themselves. you maintain a list threaded through your heap in order tracking the gaps, when you need to compact you just shove everything down to the bottom of the heap that is still alive. when the refcount goes to zero on an object it threads itself back in as a gap
07:34:08 <edwardk_> no gc, just ref counting, no cycles because your allocated widgets don't refer to each other, occasional stop the world and memcpy overhead
07:34:57 <edwardk_> annoyingly as with all refcounting every read only reference becomes a write to thread the reference in, but its unobtrusive
07:35:34 <gwern> fasta: what if the switch induces latency? it's no good to do it behind the user's back if it takes a couple seconds and the user's input gets buffered waiting
07:35:39 <fasta> edwardk_, I think I am doing that already. I just don't understand the "it threads itself back in as a gap".
07:36:28 <fasta> gwern, the switch should take not longer than 5 ms. 
07:36:29 <edwardk_> fasta: just meaning that your heap contains allocated and unallocated blocks, with the ability to traverse that block chain in, say, ascending order by memory address
07:37:04 <edwardk_> deallocating just threads the node back into that list appropriately widening an unallocated block if need be
07:37:08 <fasta> edwardk_, the problem is that I cannot control the whole heap.
07:37:23 <fasta> edwardk_, I can only mark entries as being unused and keep a list of that. 
07:37:38 <fasta> edwardk_, basically a free list in GC terms.
07:37:51 <edwardk_> fasta: sure, but with just that you'll never fully manage fragmentation
07:38:28 <edwardk_> fasta: another approach, how big are these structures?
07:38:38 <edwardk_> i.e. what are the range of sizes you're concerned with?
07:38:40 <fasta> edwardk_, right, but if I would only have to allocate "memory cell sized" objects there would be no problem.
07:39:24 <fasta> edwardk_, between 100 and a few thousand I think. 
07:39:25 <edwardk_> fasta: sure. the model above assumed things could be arbitrarily sized, but that you could allocate a large contiguous block of memory for dealign with just this kind of object
07:40:04 <fasta> edwardk_, I think the approach I have now with a copying phase would solve the whole problem. 
07:40:13 <edwardk_> s/dealign/dealing
07:40:22 <fasta> edwardk_, thanks. 
07:40:46 <edwardk_> *nods*
07:40:48 <edwardk_> np
07:48:03 <SockPupMex-> is there an offtopic channel for haskell?
07:48:36 <SockPupMex-> !offtopic
07:49:01 <geheimdienst> it's called #haskell-blah
07:51:03 <edwardk_> geheimdienst: depending on the time of night it is sometimes just called #haskell ;)
07:53:35 <pastorn> :clear
07:53:37 <pastorn> wait...
07:53:40 <pastorn> this isn't cmus...
07:58:31 <_nickel> Hi all, I'm fighting my way through the second chapter of Algebra of Programming, and I was wondering if anyone would mind answering some questions on showing that the product functor preserves composition?
07:59:43 <_nickel> or point me to a better irc channel for the question. Came here first since I've gotten such top notch help in the past :D
08:00:04 <hpc> this is probably the right place ;)
08:00:22 <_nickel> hpc: cool, just wanted to make sure
08:01:51 <geheimdienst> #haskell is the prime channel for simple things buried under foreign words
08:02:15 <_nickel> maybe a more specific question: can you compose function pairs and what is the result? I would expect (f,g) . (m,n) = ((f . m), (g . n)) 
08:02:22 <_nickel> but thats total speculation
08:03:03 <_nickel> (not in haskell mind you)
08:05:13 <hpc> assuming you apply function pairs like (f,g) x = (f x, g x)
08:05:48 <hpc> then (f,g) ((m,n) x) = (f (m x), g (n x))
08:06:04 <hpc> so yes, it should, i think
08:06:14 <leimy> are there strictness differences in the evaluation of case vs if then else statements?
08:06:43 <leimy> and if so is that an implementation detail or something I can count on in Haskell?
08:07:11 <hpc> no, if-then-else desugars to case _ of _ | condition -> thing; | otherwise -> other thing
08:07:23 <jmcarthur> fasta: doing managed buffer objects?
08:07:31 <hpc> where the _'s can be anything that doesn't evaluate anything
08:07:48 <leimy> ah ok.
08:07:50 <fasta> jmcarthur, the buffer is managed by third party code, yes.
08:08:01 <hpc> er, more concisely
08:08:14 <hpc> case condition of True -> action; False -> other action;
08:08:17 <jmcarthur> ah, i was under the impression that this was buffer objects on the GPU specifically
08:08:19 <_nickel> hpc: thanks, in that case I believe I can show that it preserves composition, I'll pastbin my work and get someone to double check it when the US is awake!
08:08:45 <hpc> it's 11 on the east coast, so there should be at least a few americans
08:08:49 <fasta> jmcarthur, they are sent to the GPU every frame by the game-engine. 
08:08:51 * _nickel wishes it weren't so basic
08:09:05 <_nickel> hpc: ahh you are correct, I have my clock set for home in LA
08:09:09 <jmcarthur> ah, high access frequency
08:09:15 <fasta> jmcarthur, but that's invisible for me as a programmer in a certain sense. 
08:09:33 <leimy> I suppose I should just really learn to read core :-)
08:09:49 <jmcarthur> ah, so this is something higher level then opengl?
08:09:54 <leimy> then these questions would sort of answer themselves, but the problem is, I don't think I should have to know how to read core in order to write efficient haskell
08:10:07 <leimy> maybe I'm being wimpy :-)
08:10:08 <fasta> jmcarthur, yes, probably every game engine has these kinds of objects. 
08:10:10 <jmcarthur> i don't think i have any suggestions. i was just seeing how similar this is to what i've been working on
08:10:13 <jmcarthur> okay
08:10:18 <jmcarthur> i'm working at a lower level
08:10:23 <fasta> jmcarthur, basically wrapping directx/opengl. 
08:10:31 <jmcarthur> ah
08:10:34 <hpc> leimy: you should probably read the Report
08:10:40 <jmcarthur> so a simple wrapper
08:10:40 <fasta> jmcarthur, what have you been working on?
08:10:45 <leimy> hpc: that would help sure.
08:10:53 <fasta> jmcarthur, yes, I don't think it does anything intelligent. 
08:10:57 <leimy> been over it once, need to look at some things in more detail.
08:11:13 <fasta> jmcarthur, or should I say, "magical". 
08:11:48 <jmcarthur> i've been making a more haskelly opengl interface with e.g. garbage collected buffer objects, but i haven't been concerning myself with anything managing the contents of the buffer objects yet
08:12:10 <jmcarthur> also been making a pure interface
08:12:19 <jmcarthur> but that is of course limited
08:12:53 <fasta> jmcarthur, unless you integrate the objects into the actual RTS GC, it will never work seamlessly.
08:13:04 <jmcarthur> yes, that's what i'm doing
08:13:22 <jmcarthur> oh you mean at C level?
08:13:31 <fasta> jmcarthur, you are actually modifying GHC? Ok, that's kind of nice. 
08:13:43 <jmcarthur> no i'm not doing that. i'm curious what you mean now though
08:14:33 <jmcarthur> i do expect some potential problems with things not always being collected from GPU memory in a timely manner
08:15:34 <jmcarthur> what do you mean by "seamlessly"?
08:16:00 <jmcarthur> i'm just using finalizers
08:16:19 <edwardk_> jmcarthur: fasta you can integrate with gc by just adding a finalizer here or there
08:16:54 <jmcarthur> edwardk_: yeah, fasta confused me there, but now i wonder if he just didn't know that
08:16:59 <fasta> edwardk_, I am not sure whether it would solve my problem.  
08:17:14 <edwardk_> the trickier part being that while abstractly this is sufficient, in practice you need a more dynamic model that actively manages the memory on the GPU
08:17:23 <fasta> jmcarthur, I know that, but in my case that is not possible, since this particular component is not written in Haskell. 
08:17:43 <edwardk_> i.e. write in an EDSL, and interpret that in something stateful
08:17:56 <fasta> jmcarthur, I also have the impression that finalizers in GHC have almost no guarantees.
08:18:15 <jmcarthur> they don't. i might have to tinker to get things working smoothly
08:18:35 <fasta> jmcarthur, stuff which doesn't have guarantees is basically worthless, imho. 
08:18:43 <jmcarthur> maybe even add some primitives to special hooks in GHC (in which case you can say "that's kind of neat" after all)
08:19:03 <jmcarthur> *primitives or special hooks
08:19:46 <fasta> jmcarthur, so, back to what I meant: basically the same as you are doing with finalizers, but then in a guaranteed manner. 
08:19:56 <jmcarthur> fasta: at the worst you can force a GC from within haskell, but that's not ideal
08:21:01 <fasta> edwardk_, are there actual instructions on modern GPUs to modify certain memory cells in less time than to touch all of them?
08:21:27 <jmcarthur> there are vendor extensions to opengl for monitoring GPU memory. i've been thinking about using those to trigger a GC if it's running low
08:21:43 <jmcarthur> which wouldn't require a GHC extension at elast
08:21:46 <jmcarthur> *least
08:21:51 <jmcarthur> it wouldn't be "real time" though
08:21:52 <fasta> edwardk_, I had the impression they are basically functional programming hardware substrates without DiffArray. 
08:22:18 <fasta> edwardk_, certainly not the RAM model illusion you have when programming usually. 
08:22:51 <fasta> edwardk_, but I don't know a lot about GPUs, since we work on a "higher-level". 
08:23:27 <edwardk_> fasta: you can target a portion of a texture as a frame buffer
08:24:06 <edwardk_> fasta: in general things in gpu-land work best if you can block-structure your targets
08:24:16 <jmcarthur> i've been thinking about also integrating some opencl stuff into all this since it plays nice with opengl
08:24:39 <jmcarthur> an opencl backend to accelerate would be especially nice for me :)
08:25:01 <fasta> edwardk_, right, but if you cannot?
08:25:22 <edwardk_> fasta: depends, you can do a lot with directcompute and the more modern gpus
08:25:49 <fasta> edwardk_, this particular engine still has everything in RAM, but I don't think it is state of the art. 
08:26:04 <edwardk_> fasta, jmcarthur: i'll be back in about an hour.
08:26:27 <fasta> It might be a good reason to switch to something else, if it actually possible to present an efficient interface to inplace GPU memory updates.
08:26:29 <jmcarthur> blackh, TacticalGrace: you guys hear that? i want an opencl backend for accelerate so i can integrate it with opengl! :D
08:28:05 <fasta> it is*
08:29:52 <dpratt71> can cabal (or something else) generate a list of installed packages?
08:30:07 <jmcarthur> ghc-pkg list
08:30:28 <dpratt71> jmcarthur: I'll try it, thanks
08:31:57 <fasta> These kinds of limited computations are what GPUs are good at: http://www.youtube.com/watch?v=sLv_fhQlqis  ;random access data structure maintenance has not been demonstrated, AFAIK. 
08:35:21 <cheater99> hi guys
08:35:33 <cheater99> someone here wrote learnyouahaskell right?
08:35:51 <Axman6> BONUS did cheater99 
08:35:56 <cheater99> ah right
08:36:03 <cheater99> BONUS: you around? :)
08:36:22 <cheater99> i've got a bit of a problem because the listings have a white background and are invisible
08:38:00 <geheimdienst> do you have javascript active? i guess the syntax highlighting might be done by javascript
08:38:51 * hackagebot Vec 0.9.8 - Fixed-length lists and low-dimensional linear algebra.  http://hackage.haskell.org/package/Vec-0.9.8 (ScottDillard)
08:43:21 <Sadache> hello everyone
08:43:54 <Tomsik> hi
08:46:20 <Sadache> I am trying to do a mechanism similar to Regex Named Groups in Haskell and I've got the idea to pass once on the Regex to transform it to a normal regex and then apply it to the string and then use index to tuple matches to their names
08:46:39 <Sadache> performance aside, does it look for like a good idea?
08:47:20 <Sadache> Actually I am dealing with short string (URLs) so I dont think that performance matters much
08:48:41 <Tomsik> "normal regex"?
08:49:27 <Tomsik> I'm new here, so maybe that's some jargon, but if not, do you mean some normal form?
08:49:38 <Tomsik> or maybe determinization of a regexp
08:50:30 <Sadache> Tomsik: regex without named groups
08:56:46 <Sadache> I meant that I will go through it with a 'meta-pattern' to transform it into a pattern that doesnt use named groupes
08:58:20 <geheimdienst> i'm not sure what you mean, but you should have a look at the chapter on "Parsec" in "Real World Haskell"
08:58:31 <geheimdienst> it's an alternative to regexes which might suit your needs
09:00:28 <cheater99> geheimdienst: yes
09:00:45 <cheater99> geheimdienst: i've just installed firebug (had a problem with restarting ff, hah) so let me debug it a little
09:02:16 <geheimdienst> i mean, it is a bug that the code just disappears ... it should just be there black on white, and for people who have js enabled it's colored
09:10:32 <Sadache> geheimdienst:  I have (P?<id>[a-b])/(P?<year>[a-b]) and when I match with "12/2009" I want to get [("id","12"),("year","2009")]
09:10:55 <Sadache> this is Named Groupes in Regex
09:11:13 <Sadache> no haskell package seem to implement them
09:11:33 <allbery_b> too new.  does anything oither than perl5.12/perl6 do them yet?
09:11:46 <davean> python has for ages
09:12:01 <allbery_b> huh
09:12:25 <davean> I wouldn't call them new at all
09:12:28 <Sadache> and I was thinking of passing a Regex on that Regex, to remove the special syntax and then match it with the string and then use index to group matches with their extracted names
09:12:35 <Sadache> no not new for sure
09:12:47 <Sadache> .net had them for a long time
09:12:59 <Sadache> Java has them too if I remember right
09:13:29 <geheimdienst> no haskell package has named groups because haskellers tend to use parsec where in other languages you might use regexes. have a look at http://book.realworldhaskell.org/read/using-parsec.html it's really quite good
09:13:47 <Sadache> pcre implement them too
09:14:03 <Mathnerd314> is there a nice way to write \(a,x) (b,y) -> compare x y in a pointfree style? 
09:14:18 <jmcarthur> :t comparing snd
09:14:19 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
09:14:39 <Mathnerd314> ah, much better
09:14:58 <Sadache> geheimdienst: would parsec help when the regex is passed by the user of my api. The user should pass me the regex with named groups and I should return a map
09:15:01 <jmcarthur> :t comparing
09:15:02 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:15:27 <Mathnerd314> so the sort could just be sortBy (comparing snd) ?
09:15:32 <jmcarthur> exactly
09:16:00 <Mathnerd314> @hoogle comparing
09:16:01 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
09:16:24 <jmcarthur> personally i wish instead of sortBy we had  sortOn :: Ord b => (a -> b) -> [a] -> [a]
09:16:39 <geheimdienst> @src on
09:16:40 <lambdabot> (*) `on` f = \x y -> f x * f y
09:17:13 * geheimdienst is sure `on` somehow can be used for something like that, or something
09:17:20 <jmcarthur> because then it could just map the function over the list to get a list of tuples, sort based on the transformed value, then unzip it to get the original elements in the new order, and it would mean it doesn't have to reapply the function for every comparison
09:17:29 <jmcarthur> @src comparing
09:17:29 <lambdabot> Source not found.
09:17:32 <jmcarthur> grr
09:17:46 <jmcarthur> comparing f = compare `on` f
09:17:50 <hpc> yeah
09:18:14 <hpc> or comparing = on compare, but that doesn't read as easily
09:18:16 <jmcarthur> and it would read better to:   sortOn snd
09:18:20 <jmcarthur> *too
09:19:10 <jmcarthur> most people just define sortOn = sortBy . comparing, but that doesn't take advantage of the optimization at all
09:19:24 <hpc> :t sortBy
09:19:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:20:09 <edwardk_> jmcarthur: the Scwartzian transform?
09:20:39 <jmcarthur> yes
09:20:40 <edwardk_> er schwartzian
09:20:55 <jmcarthur> can't do that with sortBy
09:21:15 <edwardk_> sure you can fmap ... sortBy snd . fmap ... ;)
09:21:20 <jmcarthur> ugh
09:21:29 <jmcarthur> that's what the definition of sortOn *should* be
09:22:02 * sproingie awaits the Sufficiently Smart Compiler that would realize it's moot in a functional language because the comparison function is deterministic anyway
09:22:09 <jmcarthur> :t sortOn
09:22:10 <lambdabot> Not in scope: `sortOn'
09:22:32 <jmcarthur> @let sortOn f = fst . unzip . sortBy snd . fmap (id &&& f)
09:22:33 <lambdabot>  <local>:11:32:
09:22:33 <lambdabot>      Occurs check: cannot construct the infinite type:
09:22:33 <lambdabot>       ...
09:23:18 <jmcarthur> @let sortOn f = map fst . sortBy snd . map (id &&& f)
09:23:18 <lambdabot>  <local>:11:28:
09:23:19 <lambdabot>      Occurs check: cannot construct the infinite type:
09:23:19 <lambdabot>       ...
09:23:23 <jmcarthur> doh!
09:23:31 <jmcarthur> @let sortOn f = map fst . sortBy (comparing snd) . map (id &&& f)
09:23:32 <lambdabot>  Defined.
09:23:41 <jmcarthur> has sortOn on the mind
09:24:32 <jmcarthur> @let groupOn f = (map.map) fst . groupBy ((==) `on` snd) . map (id &&& f)
09:24:33 <lambdabot>  Defined.
09:25:10 <jmcarthur> @let maximumOn f = fst . maximumBy (comparing snd) . map (id &&& f)
09:25:12 <lambdabot>  Defined.
09:25:41 <ski> @type let sortOn f = map fst . sortBy (comparing snd) . map (graph f) in sortOn
09:25:42 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
09:25:42 <cheater99> i think my problems with learnyouahaskell.com might be because of my internet connection. would someone be kind enough to tar up a downloadable version of it?
09:25:50 <jmcarthur> :t sortOn
09:25:52 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
09:26:51 <ski> @type groupOn
09:26:52 <lambdabot> forall a b. (Eq b) => (a -> b) -> [a] -> [[a]]
09:27:18 <jmcarthur> :t graph
09:27:19 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
09:27:28 <jmcarthur> ah that one
09:28:19 <sepp2k> Does anyone know what call by name is?
09:28:39 <jmcarthur> it's like lazy evaluation but without sharing
09:28:42 <bvck> sepp2k, wikipedia has great information on 'call by xxxx'
09:28:49 <sepp2k> Thanks.
09:29:43 <BuZZ-dEE> sepp2k: do you know call by weed
09:29:50 <jmcarthur> lol
09:30:12 <geheimdienst> call by number is what the phone system is based on
09:30:26 <BuZZ-dEE> ^^
09:31:17 <quicksilver> geheimdienst: that's the "chesney hawks" calling convention, right?
09:31:55 <quicksilver> obscure 1990s music jokes go down brilliantly every time, I find.
09:32:07 * geheimdienst is googling chesney hawks
09:32:41 <cheater99> nobody? :()
09:32:51 * cheater99 gets depressed
09:33:29 <jmcarthur> cheater99: alright, i'm doing it i guess
09:33:36 <quicksilver> cheater99: http://learnyouahaskell.com/learnyouahaskell.pdf
09:33:45 <cheater99> oh oh
09:33:56 <jmcarthur> woah
09:34:03 <quicksilver> the PDF doesn't have the cool pictures
09:34:08 <quicksilver> but I eblieve the words are the same.
09:34:23 <jmcarthur> well, i got a tarball if you still want it :)
09:34:28 <cheater99> yes please
09:34:35 <cheater99> :)
09:35:00 <c_wraith> dcoutts: Is there a way to disable "install" in a cabal file?  There are times when it makes no sense to install a binary in .cabal/bin
09:41:01 <ski> @type let schwartz (inn,out) fooBy cmp f = out . fmap fst . inn . fooBy (cmp `on` snd) . fmap (graph f) in schwartz
09:41:01 <lambdabot> forall a (f :: * -> *) a1 b b1 a2 b2 c (f1 :: * -> *) a3 b3. (Functor f1, Functor f) => (a -> f (a1, b), f a1 -> b1) -> (((a2, b2) -> (a2, b2) -> c) -> f1 (a3, b3) -> a) -> (b2 -> b2 -> c) -> (a3 ->
09:41:02 <lambdabot> b3) -> f1 a3 -> b1
09:41:05 <ski> .. ho hum
09:43:21 <jmcarthur> o_O
09:43:56 <c_wraith> do we really need more perlisms in haskell?
09:45:21 <ski> jmcarthur : the basic problem is that we can't abstract `a',`f a',`f (f a)' into `g0 a',`g1 a',`g2 a' (for any `a')
09:45:26 <ddarius> Just because it is in Perl doesn't mean it is bad.
09:45:38 <ski> @type maximumOn
09:45:39 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> a
09:45:41 <geheimdienst> may the schwartz be with you, is all i can say to that
09:45:45 <ski> @type sortOn
09:45:46 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
09:45:48 <maltem> Basic question: What would be a good data structure for data blocks (laudio data) such that reading them in from a file involves as few copies as possible? I'd feel uneasy about reading into a Bytestring, then copying into a UArray or equivalent
09:45:51 <ski> @type groupOn
09:45:51 <lambdabot> forall a b. (Eq b) => (a -> b) -> [a] -> [[a]]
09:46:45 <ski> jmcarthur : here `f' is `[]', but we still can't manage to `fmap' over the `a' inside `a',`[a]',`[[a]]' (or rather, do it on the versions with `(a,b)' instead of `a', to get the `a's)
09:47:21 <jmcarthur> ski: could try with functor composition?
09:47:32 * ski wonders whether it would be possible to ask for L-lambda unification in haskell types ..
09:47:37 <jmcarthur> (f :. f) a
09:47:58 <jmcarthur> still dunno how that would be constructed properly
09:48:27 <ski> jmcarthur : that's what `(inn,out)' was supposed to do (i.e. map between the `a',`f a',`f (f a)' representations and `g0 a',`g1 a',`g2 a' representations)
09:48:52 <ski> the point is that we want to be able to do it uniformly, not having to special-code each case
09:49:25 <jmcarthur> yeah
09:49:47 <edwardk_> ski/jmcarthur: what are you trying to model?
09:50:22 <ski> @type let schwartz :: (Functor f,Functor g,Functor gg) => (gg (a,b) -> g (a,b),g a -> gg a) -> (((a,b) -> (a,b) -> c) -> f (a,b) -> gg (a,b)) -> (b -> b -> c) -> (a -> b) -> (f a -> gg a); schwartz (inn,out) fooBy cmp f = out . fmap fst . inn . fooBy (cmp `on` snd) . fmap (graph f) in schwartz
09:50:22 <lambdabot> forall (gg :: * -> *) a b (g :: * -> *) c (f :: * -> *). (Functor gg, Functor g, Functor f) => (gg (a, b) -> g (a, b), g a -> gg a) -> (((a, b) -> (a, b) -> c) -> f (a, b) -> gg (a, b)) -> (b -> b ->
09:50:23 <lambdabot>  c) -> (a -> b) -> f a -> gg a
09:50:27 <ski> (doesn't really help)
09:50:35 <jmcarthur> edwardk_: ^^ o_O
09:50:52 <ski>   maximumOn f = fst . maximumBy (comparing snd) . map (graph f)
09:50:54 <ski>   sortOn f = map fst . sortBy (comparing snd) . map (graph f)
09:51:02 <ski>   groupOn f = (map.map) fst . groupBy ((==) `on` snd) . map (graph f)
09:51:05 <edwardk_> clearly sortOn :: Ord b => Traversable f => (a -> b) -> f a -> f a
09:51:09 <ski> @type maximumOn
09:51:10 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> a
09:51:11 <edwardk_> is easy
09:51:12 <ski> @type sortOn
09:51:13 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
09:51:15 <ski> @type groupOn
09:51:16 <lambdabot> forall a b. (Eq b) => (a -> b) -> [a] -> [[a]]
09:51:27 <ski> i want to abstract over the definitions of these
09:51:40 <edwardk_> ski: hrmm, Stream [] a =P
09:52:10 <edwardk_> but the problem is the latter does something very different than the former two, given that it returns a new shape
09:52:12 <ski> passing `maximumBy',`compare' ; `sortBy',`compare' ; `groupBy',`(==)' as arguments
09:52:24 <ski> all of them returns different shapes
09:52:40 <edwardk_> *nods*
09:52:47 <ski> i want to abstract `a',`[a]',`[[a]]' into `g0 a',`g1 a',`g2 a', in a uniform fashion
09:53:04 <edwardk_> i don't see any particularly elegant  benefits to said generalization though.
09:53:17 <ski> but, afaics, the way haskell matching of `f a' to some type works, this doen't work out
09:53:19 <edwardk_> each one only uses some small subset of the resulting sea of types
09:53:59 <ski> (i'm not sure what you mean by that last comment ..)
09:54:49 <ski> (.. eh, now i see what you meant by `Stream [] a' :)
09:54:50 <edwardk_> meaning that i don't see the commonalities, i see 2-3 combinator because of the different shapes of the result, at which point you've almost gone all the way back to the original number of functions
09:55:06 <edwardk_> er 2-3 combinators
09:55:32 <ski> i just want a single function i can pass one pair out of `maximumBy',`compare' ; `sortBy',`compare' ; `groupBy',`(==)', to get the behaviour i want
09:55:45 <ski> (so, only one combinator)
09:56:07 <jmcarthur> you also need to pass id, map, or (map.map)
09:56:10 <edwardk_> @type ((maximumBy, sortBy, groupBy), (compare, ==))
09:56:11 <lambdabot> parse error on input `)'
09:56:35 <edwardk_> @type (maximumBy, sortBy, groupBy)
09:56:36 <lambdabot> forall a a1 a2. ((a -> a -> Ordering) -> [a] -> a, (a1 -> a1 -> Ordering) -> [a1] -> [a1], (a2 -> a2 -> Bool) -> [a2] -> [[a2]])
09:56:57 <ski> jmcarthur : well, that's what ideally the system should figure out for itself (based on that `\a -> a',`\a -> f a',`\a -> f (f a)' are all functors, given that `f' is a functor)
09:58:00 <ski> i'm thinking maybe one could get something like this, with L-lambda unification in the type system ..
09:58:12 <edwardk_> ultimately you will have to apply the function directly because you won't know the result type shape well enough to match it. so you'll need to treat your inputs as ((a -> a -> Ordering) -> [a] -> b) -- so you can't use a Swartzian transform -- you have no way to extract the extra argument
09:58:19 <jmcarthur> i think special definitions of sortBy, groupBy, and maximumBy would need to be provided that have some special result types
09:58:38 <edwardk_> (that and you have another problem, in that Ordering and Bool fail to unify
09:58:48 <ski> .. but one would have to check in each case that the unification as exactly one solution (there can be many : quick, give an `f' such that `f a = (a,a)' !)
09:58:48 <edwardk_> fromEnum LT
09:58:56 <edwardk_> > fromEnum EQ
09:58:57 <lambdabot>   1
09:59:00 <edwardk_> > fromEnum True
09:59:01 <lambdabot>   1
09:59:12 <jmcarthur> i could envision a horrible implementation using type families or something maybe, but ugh...
09:59:19 <jmcarthur> not useful, not worth it
09:59:44 <ski> edwardk_ : `Bool' and `Ordering' would be abstracted by some type `c' :)
09:59:48 <edwardk_> jmcarthur: you can't get 'a' and [a] into the same instance
09:59:58 <edwardk_> er same instance head
10:00:12 <ski> (and the `compare' ; `compare' ; `(==)' argument tells us which one we are using)
10:00:16 <jmcarthur> edwardk_: yeah it would have to be a custom type designed for this
10:00:20 <ski> edwardk_ : exactly
10:01:02 <ski> we'd have some restricted system that allows `x' to be treated as `(\a -> a) x', in some circumstances
10:01:03 <edwardk_> jmcarthur: i mean that you can't say class Foo x; instance Foo a; instance Foo [a] -- because those heads unify, you'd need overlapping instance and all sorts of badness
10:01:05 <jmcarthur> basically if you don't pass this kind of information at the value level you have to pass it at the type level... assuming either are possible
10:01:12 <jmcarthur> edwardk_: right
10:01:28 <edwardk_> so now you're down to newtypes and at that point in time, just write another combinator =P
10:01:37 <jmcarthur> edwardk_: i'm talking about special definitions for the *By functions that don't just return lists or nested lists
10:01:42 <jmcarthur> right
10:01:46 <jmcarthur> it would suck
10:01:55 <edwardk_> jmcarthur: you can sortOn over a traversabl
10:01:58 <ski> so, this would use `instance Functor (\a -> a)' and `instance (Functor f,Functor g) => Functor (\a -> g (f a))', obviously ;)
10:02:24 <jmcarthur> @hoogle sortBy
10:02:25 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
10:02:37 <edwardk_> jmcarthur: i mean you can trivially define said sort
10:03:42 <jmcarthur> makes sense. Traversable is basically for "list-ish" functors
10:04:00 <ski> so .. who knows of any research being done to add some kind of L-lambda unification of types to a type system ? ;)
10:04:25 <edwardk_> jmcarthur:  you need to exploit the parametricity guarantee that the result of sorting has the same number of elements as the input. but this can be used to releaf a tree with its elements in sorted order, etc.
10:04:53 <edwardk_> ski: the research is that its not happening ;) there were a couple of papers showing how it destroys type inference in general
10:05:12 <ski> recall any names ?
10:05:15 <jmcarthur> edwardk_: actually, does parametricity actually guarantee that in this case?
10:06:28 <edwardk_> jmcarthur: parametricity doesn't guarantee the properties of sort, but what i have is a guarantee that if i have a function that takes only one,  Traversable f => f a, and has no other way to construct such a 'f', and knows nothing else about it. all i can do with it is traverse it which doesn't change its shape
10:06:53 <jmcarthur> oh Traversable. i was still thinking about lists
10:06:58 <jmcarthur> you're right
10:07:00 <edwardk_> jmcarthur: that is sufficient to allow me to apply a zipWithT :: Traversable f => (a -> b -> c) -> f a -> f b -> f c -- in that context
10:07:55 <cheater99> hey guys
10:08:04 <cheater99> what's the motivation for having both let bindings and where bindings?
10:08:05 <edwardk_> or more generally a zipWithT :: (Foldable f, Traversable g) => (a -> b -> c) -> f a -> g b -> g c -- where f and g have the same number of elements, and perhaps f was obtained by using toList on the traversable functor g
10:08:21 <edwardk_> cheater99: they have different lexical scoping rules and are useful for different scenarios
10:08:32 <cheater99> oh?
10:08:36 <cheater99> such as?
10:08:49 <k23z__> cheater99, hello
10:08:54 <edwardk_> where's scope 'over' guards, so they are usefl when you need to specify  foo | cnd 1 = .. | cnd 2 = ... where cnd = ... 
10:09:05 <edwardk_> on the other hand lets can be defined inside of lambdas, etc.
10:09:34 <edwardk_> they are both just a whole crud ton of sugar over a simpler internal calculus, but having that expressiveness in the surface syntax is very nice
10:09:36 <jmcarthur> let is an expression and where isn't
10:09:54 <jmcarthur> i think?
10:10:01 <cheater99> k23z__: hi
10:10:04 <Cale> jmcarthur: right
10:10:13 <jmcarthur> > map (f where f = (+1)) [1..3]
10:10:13 <lambdabot>   <no location info>: parse error on input `where'
10:10:25 <cheater99> edwardk: so i can't use let with guards?
10:10:38 <edwardk_> cheater99: you can use it in the guard itself. ;)
10:10:47 <cheater99> aha, but not around guards
10:10:50 <cheater99> ok, cool
10:10:53 <jmcarthur> cheater99: well, the bound variable won't be usable in all the guards
10:10:53 <edwardk_> yeah
10:11:09 <edwardk_> you could also use the let in a view pattern i suppose ;)
10:11:18 <jmcarthur> ew
10:11:20 <illissius> can anyone recommend a good medium-length latex tutorial? like an hour long or so?
10:11:21 <edwardk_> which would expose it to subsequent guards, how awful
10:11:32 <jmcarthur> it would?
10:11:45 <kmc> illissius, www.ctan.org/tex-archive/info/lshort/english/lshort.pdf
10:11:47 <jmcarthur> i guess it would
10:11:51 <jmcarthur> gross
10:11:53 <illissius> kmc: thanks
10:11:54 <luite> an hour is already medium-length?
10:12:13 <cheater99> luite: that's 120 attention spans
10:12:16 <illissius> i dunno
10:12:22 <Cale> edwardk_: oh? How so?
10:12:23 <illissius> last time i searched i found one which was like 5 minutes
10:12:34 <edwardk_> foo x y (let f z w = x + y + z in f -> fz) | fz == 23 = ..  | fz == 30 = ... 
10:12:49 <Cale> oh, sure :)
10:12:50 <edwardk_> er i probably screwed up the arity on that
10:13:35 <cheater99> 'arity'?
10:13:53 <Apocalisp> adicity
10:13:55 <Cale> cheater99: Number of parameters
10:15:38 <edwardk_> foo x | bar x = ...; baz x = ... could become foo (let f x = (x, {- def for bar x ... -}, {- def for baz x -}) in f -> (x, y, z)) | y = .. | z = ... but god that is an abuse ;)
10:16:14 <edwardk_> cheater99: http://en.wikipedia.org/wiki/Arity
10:18:15 <edwardk_> there does not appear to be an automatic differentiation library for c# =P
10:18:59 <edwardk_> i can corner the market on that whole 1-2 user demographic!
10:21:13 <cheater99> thanks
10:21:54 <cheater99> The arity of a relation is the number of domains in the corresponding Cartesian product.
10:22:02 <cheater99> domains as in partition domains?
10:22:44 <shapr> edwardk_: Dude, I'll trade you a copy of Okasaki's book for Rabhi & LaPalme's Purely Functional Data Structures - http://www.amazon.com/dp/0201596040
10:23:15 <Cale> cheater99: A relation between sets (S_1,S_2,...,S_n) is a subset of the Cartesian product S_1 x S_2 x ... x S_n. The arity of such a relation is n.
10:23:29 <edwardk_> shapr: this doesn't sound cost effective to me ;)
10:23:36 <cheater99> ok, so what they mean is 'the number of components of the cartesian product'
10:23:44 <edwardk_> cheater yeah
10:23:46 <Cale> yeah
10:23:51 <cheater99> ok cool, thanks
10:23:56 <sinelaw> who are you calling a cheater?! ah
10:24:04 <sinelaw> ;P
10:24:38 <alexyk> JaffaCake: ping
10:25:11 <shapr> edwardk_: Eh, probably so. But I still prefer reading PFDs.
10:25:42 <shapr> edwardk_: Actually, I'd like to read an updated version of Rabhi & LaPalme's book that covers all the latest and greatest goodies.
10:27:04 <alexyk> shapr: that book got a single bad review on Amazon :)
10:27:16 <shapr> alexyk: I had a copy, loaned it out, never got it back.
10:27:33 <alexyk> shapr: so that's how it ended up in Denmark
10:27:34 <cheater99> kill people
10:27:37 <shapr> alexyk: I really enjoyed it, found a typo, had a short email conversation with the authors.
10:28:05 <alexyk> shapr: so when you say you'd like to read a new edition, is it general wishing or are they writing one?
10:28:13 <shapr> alexyk: wishing
10:28:13 <dpratt71> so I'm looking at snap framework, which has recently been updated to be Windows-compatible, but...
10:28:47 <fryguybob> edwardk_: C# doesn't have a good story for fancy operator overloading so AD will have a non "native" feel unless you use 4.0's dynamic keyword.
10:28:51 <dpratt71> ...when you do 'snap init', the proto-app you get still has a dependency on unix
10:29:04 <fryguybob> edwardk_: That being said, I would use AD in C# if it existed.
10:29:09 <dpratt71> looks like just for getEnv/setEnv
10:29:29 <dpratt71> how does one getEnv/setEnv on a Windows system?
10:32:52 <cheater99> can you somehow define this in pointfree style? square x = x * x
10:33:02 <Philonous> @pl \x -> x*x
10:33:03 <lambdabot> join (*)
10:33:04 <sclv> @pl \x -> x * x
10:33:04 <Cale> square = join (*)
10:33:04 <lambdabot> join (*)
10:33:15 <Cale> @pl square x = x * x
10:33:16 <lambdabot> square = join (*)
10:35:21 <cheater99> ah join of course
10:35:27 <cheater99> thanks
10:35:51 <cheater99> what do i need to do to have access to join again? first day in haskell since last year :^)
10:36:02 <Cale> cheater99: import Control.Monad
10:36:02 <cheater99> i remember you needed to import some lib of some sort..
10:36:06 <cheater99> perfect, thanks
10:36:19 <Cale> Oh, and you'll also want Control.Monad.Instances if you want to use it that way
10:36:34 <Cale> The instance of Monad for functions isn't in the Prelude :(
10:37:56 <cheater99> thank you very much
10:41:12 <Saizan> ski: got any experience with twelf?
10:43:13 <esdee> I have two lists, I want to subtract every element in list B from every element in list A, what is that called?
10:43:19 <Cale> \\
10:43:22 <Cale> :t (\\)
10:43:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:43:30 <Cale> er
10:43:41 <Cale> Or do you mean  liftM2 (-)?
10:43:55 <Cale> > liftM2 (-) [10,20,30] [1,2,3]
10:43:56 <lambdabot>   [9,8,7,19,18,17,29,28,27]
10:44:02 <jmcarthur> could mean either liftA2 (-) or zipWith (-)
10:44:22 <sclv> > zipWith (-) [10,20,30] [1,2,3]
10:44:23 <lambdabot>   [9,18,27]
10:44:24 <esdee> liftM2 looks like what I need
10:44:44 <Cale> You could also just use a list comprehension if you don't like the use of the monad
10:44:53 <jmcarthur> hmm
10:44:54 <Cale> > [x - y | x <- [10,20,30], y <- [1,2,3]]
10:44:55 <lambdabot>   [9,8,7,19,18,17,29,28,27]
10:45:04 <jmcarthur> > [10,20,30] ^-^ [1,2,3]
10:45:06 <lambdabot>   No instance for (Data.AdditiveGroup.AdditiveGroup [t])
10:45:06 <lambdabot>    arising from a us...
10:45:09 <jmcarthur> worth a shot
10:45:39 <jmcarthur> theoretically there could be a Num instance for lists
10:45:48 <jmcarthur> lifted through Applicative
10:46:04 <sclv> lambdabot has vector space installed now!?
10:46:08 <jmcarthur> yeah
10:46:15 <jmcarthur> > 4 5 :: Int
10:46:16 <lambdabot>   4
10:46:23 * sclv hasn't been keepin gup
10:46:33 <edwardk_> fryguybob: I can overload most of the common operators just fine in c#. +, -, etc. the trickiest part is that I need an IComparer<T>-like interface for Math since I can't overload sin, etc. on the existing Math namespace, since it isn't an object that I can add extension methods to
10:46:52 <cheater99> what is an auxiliary function?
10:46:55 <edwardk_> fryguybob: and i can use IEnumerable<T>'s to return lazy streams of derivatives
10:47:12 <monochrom> I can overload sin in haskell :)
10:47:31 <monochrom> In fact:
10:47:45 <monochrom> > (sin 1 :: Double, sin 1 :: CReal)
10:47:45 <lambdabot>   (0.8414709848078965,0.8414709848078965066525023216302989996226)
10:47:46 <edwardk_> monochrom: yes. =)
10:47:50 <jmcarthur> cheater99: that's not really a haskell-specific term afaik. probably just means a helper function
10:48:02 <monochrom> CReal is a user-defined type loaded into lambdabot.
10:48:09 <cheater99> yeah, i couldn't find any info on it at all
10:48:28 <monochrom> "auxilliary" is just english
10:48:41 <edwardk_> cheater99: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-CReal.html
10:48:43 <monochrom> @wn auxilliary
10:48:44 <lambdabot> No match for "auxilliary".
10:48:47 <monochrom> @wn auxiliary
10:48:48 <lambdabot> *** "auxiliary" wn "WordNet (r) 2.0"
10:48:48 <lambdabot> auxiliary
10:48:48 <lambdabot>      adj 1: functioning in a subsidiary or supporting capacity; "the
10:48:48 <lambdabot>             main library and its auxiliary branches" [syn: {subsidiary},
10:48:48 <lambdabot>              {supplemental}, {supplementary}]
10:48:50 <lambdabot> [6 @more lines]
10:48:57 <cheater99> edwardk_: ?
10:49:00 <gwern> monochrom: I guess it isn't
10:49:15 <monochrom> haha
10:49:23 <edwardk_> cheater99: CReal -- or did i misparse what you meant as an antecedent for it?
10:49:57 <cheater99> edwardk_: i wasn't talking about CReal :)
10:50:09 <edwardk_> cheater99: misparse then
10:50:13 <cheater99> :)
10:50:17 <jmcarthur> > sin 2 ** 2 + cos 2 ** 2 :: CReal
10:50:18 <lambdabot>   *Exception: log of negative number
10:50:24 <jmcarthur> :(
10:50:29 <sinelaw> hey jmcarthur 
10:50:37 <jmcarthur> hey sinelaw 
10:50:40 <sinelaw> sup?
10:50:52 <jmcarthur> digging through kernel code
10:50:54 <sinelaw> ooh
10:51:00 <sinelaw> linux?
10:51:04 <jmcarthur> yeah
10:51:06 <jmcarthur> at work
10:51:12 <sinelaw> why on earth
10:51:29 <jmcarthur> i do antitamper software
10:51:34 <monochrom> because we need someone to work on linux so ghc has a good os to run on
10:53:11 <gwern> monochrom: you mean so ghc has some good device drivers
10:53:47 <jmcarthur> well, i do neither of those
10:53:57 <Mathnerd314> how would I write a "collect" function (Eq a) => [(a,b)] -> [(a,[b])] where the output list has unique a's?
10:55:02 <maltem> Mathnerd314, with (Ord a) it would probably be much easier
10:55:37 <jmcarthur> :t map (fst . head &&& map snd) . groupOn fst . sortOn fst
10:55:38 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, [b])]
10:55:51 <jmcarthur> where sortOn and groupOn are defined earlier :)
10:56:18 <Mathnerd314> @type groupOn
10:56:20 <lambdabot> forall a b. (Eq b) => (a -> b) -> [a] -> [[a]]
10:56:23 <jmcarthur> in this case, this would be just as efficient:
10:56:29 <Mathnerd314> @type sortOn
10:56:31 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
10:56:41 <jmcarthur> :t map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst)
10:56:42 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, [b])]
10:57:03 <jmcarthur> that version has the advantage of not requiring functions that i defined earlier using @let
10:57:20 <jmcarthur> and in this case is not slower (maybe even faster if the compiler is dumb enough)
10:57:56 <Mathnerd314> I don't think it matters in GHC :p
10:58:11 <sinelaw> i hate web
10:58:19 <jmcarthur> web?
10:58:22 <sinelaw> web development
10:58:27 <jmcarthur> ah
10:58:27 <sinelaw> which is what i have to do at work
10:58:30 <sinelaw> for now
10:58:31 <jmcarthur> it has its ups and downs to me
10:58:36 <sinelaw> client side
10:58:47 <sinelaw> i use GWT because it seems to be the least worst
10:59:16 <sinelaw> really need javascript backend for ghc
11:00:40 <sinelaw> makes we wanna puke
11:00:50 <gwern> go work on yhc then
11:00:51 <gwern> you pansy
11:01:33 <sinelaw> tell my boss that
11:01:39 <sinelaw> need results NOW
11:01:52 <sinelaw> and heaps of problems LATER
11:02:11 <sinelaw> in this case it's justified. the company won't survive until later if no results now
11:02:20 <kmc> Mathnerd314, you should probably use Data.Map
11:02:50 <Mathnerd314> kmc: I don't think it helps
11:04:13 <Mathnerd314> I'm doing a lot of insertion/removal
11:04:24 <kmc> i mean to write collect
11:05:11 <kmc> :t foldr (\(k,v) -> M.insertWith (++) k [v]) M.empty
11:05:13 <lambdabot> forall t t1. (Ord t) => [(t, t1)] -> M.Map t [t1]
11:05:21 <sinelaw> edwardk, is there a chance you'll extract some of your stuff into a linear algebra lib i can use to build a filter lib?
11:05:22 <fryguybob> edwardk_: It looks like http://bling.codeplex.com has some AD, but I'd rather call into haskell AD...
11:05:25 <kmc> :t M.toList . foldr (\(k,v) -> M.insertWith (++) k [v]) M.empty
11:05:26 <lambdabot> forall k t. (Ord k) => [(k, t)] -> [(k, [t])]
11:05:52 <edwardk_> fryguybob: oh?
11:06:12 <kmc> do your web dev in ur/web
11:06:15 <edwardk_> fryguybob: haven't found the ad bits yet
11:06:20 <kmc> the world's only dependently-typed web framework
11:06:48 <sinelaw> kmc, client side?
11:06:55 <kmc> apparently
11:07:09 <Mathnerd314> kmc: that's still n log(n), right? so I don't see the benefit.
11:07:28 <kmc> asymptotic complexity isn't everything ;P
11:07:48 <sinelaw> hmm
11:07:48 <kmc> the version using groupBy is going to do a lot of extra (==)
11:07:51 <gwern> I wonder if there's any llvm->js bridge
11:07:55 <gwern> though that would be pretty weird
11:08:08 <sinelaw> gwern, i tried finding and some guy was working on it but no news since a long while ago
11:08:34 <edwardk_> fryguybob: i found the Bling.Derivatives namespace, but I don't see any jacobian calculation going on
11:08:42 <kmc> Mathnerd314, plus if k is Int or ByteString or anything in Enum, you can use a faster version of Map
11:08:50 <gwern> sinelaw: great, so some of the work is already done
11:08:55 <kmc> that will be a lot better than pairwise comparison
11:09:00 <sinelaw> gwern, nope, couldn't find anything he did
11:09:05 <gwern> sinelaw: so email him
11:09:12 <sinelaw> only a single mailing list message about some question regarding it
11:09:18 <kmc> anyway, they're both one-liners, write them both and profile it with criterion
11:09:20 <sinelaw> gwern, ok i'll try to find it again
11:09:22 <kmc> let me know which one is faster :)
11:09:34 <edwardk_> fryguybob: ah found it in Bling.NewDerivatives
11:10:15 <gwern> hm. I think today I will read about funnel sort
11:10:21 <fryguybob> edwardk_: Yeah, the unreadableness certainly doesn't make it attractive.
11:10:43 <gwern> it would be interesting to see whether funnel sort gives a constant speed up when done in haskell
11:10:45 <fryguybob> edwardk_: I can't tell off hand, but from some other stuff I read it looked like they are using expression trees for some of it.
11:10:51 <edwardk_> fryguybob: that and it is only forward AD, which is actually highly suboptimal for their usage patterns
11:12:55 <gwern> so, as part of my backup strategy, I copied the output of 'find ~/' to a file and gzipped it. it took 19M
11:13:09 <gwern> it occurs to me that I should perhaps clean up my hard drive
11:13:26 <sinelaw> gwern, sent.
11:13:41 <gwern> sinelaw: cool. how was he linking llvm with js do you know?
11:13:54 <sinelaw> gwern, http://lists.cs.uiuc.edu/pipermail/llvmdev/2009-January/019205.html
11:14:43 <gwern> sinelaw: eek. so he's doing it at a pretty low level. but I'm surprised - javascript doesn't have labels to jump to?
11:16:31 <sinelaw> nope
11:22:16 <kmc> @hoogle void
11:22:17 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
11:24:47 <zygoloid> @type (()<$)
11:24:48 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
11:27:10 <gwern> kmc: don't use that void, use Control.Monad.void
11:27:24 <kmc> i don't have it
11:27:25 <hpc> :t Control.Monad.void
11:27:26 <lambdabot> Not in scope: `Control.Monad.void'
11:27:28 <benmachine> gwern: does it exist yet?
11:27:48 <benmachine> I thought that was one of the things which was stuck in an eternal we'll-do-it-tomorrow
11:28:09 <djahandarie> Control.Monad.void?
11:28:15 <hpc> what is void?
11:28:24 <kmc> void = (>> return ())
11:28:29 <gwern> benmachine: 'simon cat says is fixed in teh HEAD'
11:28:35 <Blkt> good evening everyone
11:28:39 <djahandarie> Been wanting that for ages
11:28:39 <kmc> hi Blkt
11:28:40 <benmachine> gwern: awesome
11:28:45 <gwern> kmc: but generalized to Functor iirc
11:28:46 <hpc> that's so simple...
11:28:48 <Blkt> hello there
11:28:49 <benmachine> void should be (() <$)
11:28:59 <kmc> :t fmap (const ())
11:29:00 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
11:29:02 <hpc> @hoogle (<$)
11:29:02 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
11:29:02 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
11:29:02 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
11:29:12 <gwern> benmachine: yes, it was stuck in the eternal tomorrow. and then I devoted several months to hectoring people
11:29:17 <benmachine> gwern: :D
11:29:22 <kmc> hmm, i'm benchmarking stuff, and getting suspiciously small times
11:29:26 * benmachine hugs
11:29:31 * AnAdorableNick ghcis
11:29:37 <kmc> with new Strategies, is «evaluate (x `using` rdeepseq)» sufficient for a full traversal to normal form?
11:29:38 <djahandarie> Damn it, beat me :P
11:29:40 * gwern needs no thanks. our father in heaven will reward me with a ringside seat of sinners burning in hell for it
11:30:06 <hpc> :t using
11:30:07 <lambdabot> forall a. a -> Strategy a -> a
11:30:32 <gwern> in fact, if I recall my new testament aright, being thanked down here actually reduces my heavenlyr eward
11:30:39 <gwern> so no thanks please
11:30:49 <kmc> what if we tell you to fuck yourself
11:30:52 <gwern> your finite benefit costs me infinitely
11:30:54 <kmc> does that increase your heavenly reword?
11:30:57 <benmachine> kmc: I've never quite trusted the new strategy stuff, throw some undefineds at it and see what happens
11:31:05 <gwern> kmc: I should think so, if I turn the other cheek
11:31:05 <kmc> heh benmachine
11:31:07 <monochrom> thank you gwern
11:31:09 <kmc> fair enough
11:31:20 <akosch> what is this Strategy thing anyway?
11:31:21 <gwern> dammit monochrom did you not just read what I wrote
11:31:36 <monochrom> I'm naughty. thanks a million gwern.
11:31:36 <kmc> akosch, evaluation strategies
11:31:45 <kmc> for when you want to control sequential and/or parallel evaluation order
11:31:55 <kmc> see http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html
11:31:57 <akosch> kmc: i see
11:32:09 <akosch> thx
11:32:20 <zygoloid> gwern: you suck ;)
11:32:21 <kmc> and http://bit.ly/asAPSD
11:32:22 <kmc> (pdf link)
11:32:25 <gwern> that's more like it
11:32:33 <zygoloid> i'm so confused
11:32:45 <gwern> zygoloid: religion is like that
11:34:19 <gwern> I wonder if my criterion module for testing sorts still works
11:34:23 <benmachine> kmc: from the source, it seems like rwhnf does no work at all, but rdeepseq looks like it should do the right thing ish
11:35:16 <benmachine> kmc: but I'd use deepSeq directly
11:35:47 <benmachine> or rnf or whatever
11:37:48 <dpratt71> so I'm trying to 'foreign import' getenv and it was all going swell until I tried to getenv a non-existent variable...
11:38:02 <kmc> why not use an existing wrapper?
11:38:03 <mauke> just for fun?
11:38:29 <dpratt71> ...is it likely that I need to model a NULL return somehow?
11:38:47 <kmc> yes
11:38:49 <mauke> that depends on what you're doing, and why
11:38:53 <kmc> how are you marshalling back from the C string?
11:39:04 <dpratt71> foreign import ccall unsafe "getenv"
11:39:04 <dpratt71>   c_getenv :: CString -> IO CString
11:39:28 <kmc> right
11:39:49 <kmc> but at some point you're converting those CString to/from String yes?
11:40:02 <dpratt71> kmc: with peekCString
11:40:14 <mauke> there you go
11:40:22 <kmc> probably not going to work on a null string
11:40:24 <mauke> dpratt71: and why are you doing this?
11:40:45 <dpratt71> I need getEnv/setEnv on Windows; couldn't find it anywhere
11:40:56 <mauke> @hoogle getenv
11:40:56 <lambdabot> System.Environment getEnv :: String -> IO String
11:40:56 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
11:41:00 <mauke> there it is
11:41:12 <dpratt71> @hoogle setenv
11:41:12 <lambdabot> No results found
11:41:21 <mauke> yeah, setenv isn't portable
11:41:24 <hpc> @hoogle setEnv
11:41:24 <lambdabot> No results found
11:41:46 <dpratt71> mauke: ok, thanks
11:42:18 <dpratt71> kmc: just for curiosity's sake, how should I marshall a CString to account for NULLs?
11:42:23 <kmc> check it for null first
11:42:47 <mauke> first decide what you want to do with NULL
11:43:05 <kmc> \x -> if x == nullPtr then return Nothing else Just <$> peekCString x
11:43:42 <dpratt71> @hoogle nullPtr
11:43:42 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
11:44:18 <mauke> nurupo
11:45:08 <dpratt71> kmc: so if I have an IO String, I can compare it directly to nullPtr?
11:45:13 <ClaudiusMaximus> @hoogle Ptr a -> Bool
11:45:13 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
11:45:13 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
11:45:13 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
11:45:18 <kmc> dpratt71, no
11:45:24 <kmc> dpratt71, type CString = Ptr CChar
11:45:26 <kmc> it's a simple alias
11:45:27 <kmc> just as in C
11:45:42 <mauke> dpratt71: IO String is neither a String nor a pointer
11:45:55 <dpratt71> kmc: oh, duh, got mixed up on the types for a minute
11:46:05 <kmc> dpratt71, did you read the RWH chapter on FFI?
11:46:07 <mauke> (this is why I don't use CString)
11:46:11 <dpratt71> kmc: no
11:46:31 <kmc> hmm, my criterion times are still suspicious
11:47:40 <kmc> it should take more than 11 ns to group a list of 10,000 key-value pairs right?
11:47:45 <kmc> i mean that's like 20 instructions
11:48:41 <dpratt71> awesome, it works, thanks mauke, kmc
11:49:12 <djahandarie> 母しいとなの地
11:49:19 <djahandarie> Whoa
11:49:33 <kmc> i think you're turning japanese
11:49:51 <mauke> ... I really think so
11:49:57 <djahandarie> Maybe. :P That was by accident anyways
11:51:32 <endojelly> djahandarie, what does it say?
11:52:04 <djahandarie> endojelly, nothing, hit the keys by accident. The first character says "mother" though
11:52:20 <djahandarie> And the last is "earth"
11:52:24 <djahandarie> Or ground
11:52:28 <endojelly> djahandarie, ah. I was trying to decipher it
11:52:51 <endojelly> djahandarie, and desperately searching for an adjective "母しい" 8)
11:52:59 <djahandarie> Heh
11:52:59 <endojelly> maybe "motherly" or something %)
11:53:35 <endojelly> djahandarie, but funnily, "しいと" apparently means father in law
11:53:51 <EvanR-work> are existential types just type syntactic sugar
11:53:52 <aristid> too bad, MaybeT has no MonadPlus instance
11:58:49 <gwern> > fix (take 5^(3/2)) [1..100]
11:58:49 <lambdabot>   Couldn't match expected type `[t1] -> t'
11:58:50 <lambdabot>         against inferred type `[a]'
11:58:56 <gwern> :t fix
11:58:56 <lambdabot> forall a. (a -> a) -> a
11:59:03 <gwern> @src fix
11:59:03 <lambdabot> fix f = let x = f x in x
11:59:14 <Saizan> EvanR-work: you could church-encode them with higher-rank polymorphism, but that's true for ADTs too
11:59:26 <gwern> > 5^(3/2)
11:59:27 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:59:27 <lambdabot>    `GHC.Real.Fractional t'
11:59:27 <lambdabot> ...
11:59:33 <gwern> > 5^(1.5)
11:59:34 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:59:34 <lambdabot>    `GHC.Real.Fractional t'
11:59:34 <lambdabot> ...
11:59:39 <gwern> :t (^)
11:59:39 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:59:49 <gwern> -_-
12:00:15 <gwern> @src exp
12:00:16 <lambdabot> Source not found.
12:00:49 <gwern> @hoogle (Num a, Float b) => a -> b -> b
12:00:49 <lambdabot> Warning: Unknown class Float
12:00:49 <lambdabot> Prelude seq :: a -> b -> b
12:00:49 <lambdabot> Control.Parallel par :: a -> b -> b
12:00:57 <gwern> @hoogle (Num a, Floating b) => a -> b -> b
12:00:57 <lambdabot> Prelude seq :: a -> b -> b
12:00:57 <lambdabot> Control.Parallel par :: a -> b -> b
12:00:57 <lambdabot> Control.Parallel pseq :: a -> b -> b
12:01:18 <gwern> good gravy. is it so strange to want to raise something to the 1.5th power?
12:01:38 <EvanR-work> > 5**1.5
12:01:39 <lambdabot>   11.180339887498949
12:01:47 <EvanR-work> jackpot
12:01:59 <gwern> :t (**)
12:01:59 <lambdabot> forall a. (Floating a) => a -> a -> a
12:02:12 <dv_> (-5)**2
12:02:16 <gwern> > 5**(3/2)
12:02:17 <lambdabot>   11.180339887498949
12:02:57 <EvanR-work> > (-5)**(1.3)
12:02:58 <lambdabot>   NaN
12:03:04 <EvanR-work> > (-5)**(2)
12:03:05 <lambdabot>   25.0
12:03:18 <dv_> (-1)**2
12:03:34 <EvanR-work> 1.0
12:03:44 <dv_> imaginary fail
12:03:57 <jmcarthur> > (-5)**(1.3) :: CReal
12:03:58 <lambdabot>   *Exception: log of negative number
12:04:02 <jmcarthur> > (-5)**(1.3) :: Complex CReal
12:04:03 <lambdabot>   (-4.7629902328325812033184051890422236721622) :+ (-6.5556936438515501156294...
12:04:35 <EvanR-work> > (1)**(-1)
12:04:36 <lambdabot>   1.0
12:04:44 <EvanR-work> > (1)**(-0.5)
12:04:45 <lambdabot>   1.0
12:04:50 <jmcarthur> > sin 2 ** 2 + cos 2 ** 2 :: Complex CReal
12:04:54 <lambdabot>   mueval-core: Time limit exceeded
12:05:01 <EvanR-work> > (-1)**(0.5)
12:05:02 <lambdabot>   NaN
12:05:38 <jmcarthur> > (-1) ** 0.5 :: Complex CReal
12:05:38 <lambdabot>   0.0 :+ 1.0
12:05:47 <EvanR-work> its supposed to be i. sqrt(-1). isnt there enough room in the unused bits of ieee754 for an imaginary flag ;)
12:06:06 <jmcarthur> > (-1) ** 0.5 :: Complex Double
12:06:07 <lambdabot>   6.123233995736766e-17 :+ (-1.0)
12:06:14 <jmcarthur> yuck DOuble
12:06:27 <EvanR-work> DOOOOuble crisp
12:06:42 <EvanR-work> NaNs for breakfast?!
12:07:46 <EvanR-work> there are no unused bits. but there are unused values
12:08:17 <EvanR-work> they could have put a i, and e, and pi in there ;)
12:08:32 <EvanR-work> so that e^ipi + 1 would work in floating point
12:09:18 <jmcarthur> > exp (pi * sqrt (-1)) + 1 :: Complex CReal
12:09:18 <lambdabot>   0.0 :+ 0.0
12:09:34 <Twey> \o/
12:09:44 <jmcarthur>  |
12:09:52 <EvanR-work> A
12:09:59 <Twey> Heh
12:10:08 <Twey> Sadly, jmcarthur's nick is too long.  ;)
12:10:15 <jmcarthur> looks alright to me :)
12:10:22 <EvanR-work> haha
12:10:32 <jmcarthur> except for EvanR-work's part
12:10:40 <Twey> > exp (pi * sqrt (-1)) :: Complex Float
12:10:40 <lambdabot>   (-1.0) :+ (-8.742278e-8)
12:10:45 <Twey> Fail
12:10:50 <jmcarthur> o_O
12:10:57 <Twey> Okay, I guess that's pretty small
12:11:02 <EvanR-work> i didnt have enough room, jmcarthur didnt space it far enough to the right
12:11:03 <Twey> Really
12:11:13 <jmcarthur> EvanR-work: yes i did :P
12:11:16 <EvanR-work> wrong
12:11:23 <EvanR-work> i have the canonical client
12:11:34 <Twey> jmcarthur: He's right you know.
12:11:39 <jmcarthur> "Twey | \o/"   "jmcarthur |  |"
12:11:51 <Twey> WeeChat?
12:11:55 <jmcarthur> yeah
12:12:18 <jmcarthur> the left pipes are aligned
12:12:45 <Twey> Yeah, I get that
12:12:50 <Twey> Stupid thing to do IMO
12:12:55 <EvanR-work> weeweechat
12:13:06 <jmcarthur> why stupid?
12:14:14 <Twey> Because you can't tell people apart by nick length, you have to adjust the screen every time someone with a longer nick approaches (and back when they haven't said anything in a while, or else leave a huge mass of white-space hanging), you waste screen real-estate, and it makes copy/pasting lines harder (since they end up filled with a whole bunch of spaces)
12:14:46 <jmcarthur> i can too tell nicks apart by length....
12:14:54 <Twey> I get why you'd want to do it, visually speaking, but it's just not practical
12:14:59 <jmcarthur> and i don't really have any issues with long nicks
12:15:14 <Twey> I'm assuming you have a huge terminal then ;)
12:15:17 <vitka> If I have something like "data OuterType = OuterType Int String InnerType" and function that works on InnerTypes but depends on OuterType value it belongs to, is there elegant way to implement such function?
12:15:18 <jmcarthur> copy/pasting from a terminal client sucks anyway
12:15:32 <jmcarthur> if it's more than one line and you have a user list showing, at least
12:15:50 <Twey> jmcarthur: Works fine in irssi.
12:15:55 <jmcarthur> yes i do have a large terminal
12:15:57 <Twey> (+ Terminal)
12:16:20 <EvanR-work> 80columns is the universal terminal width limit, nothing can exceed this width. scientists have hypothesized theoretical terminals that can be wider than 80 columns but they cause problems with causality
12:16:33 <Twey> vitka: Take the OuterType
12:16:46 <kmc> vitka, isn't that essentially a function on OuterType values
12:16:56 <Twey> f (OuterType i s v) = doSomethingWith s v i
12:17:03 <Toxaris> vitka: f (OuterType i s inner) = g inner where g = ... 
12:17:09 <kmc> vitka, maybe you have an example you can hpaste
12:17:19 <vitka> Hmm.
12:17:47 <jmcarthur> f (OuterType a b (InnerType c d)) = ...
12:18:00 <jmcarthur> lots of ways to do it really
12:18:19 <sinelaw> jmcarthur: one possible bonus if we go down the measurabality road, may be an easy way to describe random signals in the same model
12:18:30 <jmcarthur> sinelaw: oh?
12:18:33 <sinelaw> but it won't fit with what i suggested so far
12:18:50 <sinelaw> jmcarthur, probabilities are actually just one kind of measure
12:19:07 <jmcarthur> oh, probability as a measure
12:19:14 <sinelaw> yeah
12:19:44 <sinelaw> i didn't think much about it, but maybe there's a bonus waiting there
12:19:48 <jmcarthur> my limited understanding of measure has just expanded
12:20:14 <sinelaw> jmcarthur: probability = measure with the added constraint that the measure of the entire set = 1
12:20:23 <sinelaw> (and also it's a positive measure)
12:20:35 <jmcarthur> i see
12:20:36 <EvanR-work> non negative?!
12:20:37 <sinelaw> the set is the event space
12:20:52 <jmcarthur> yeah, non-negative, not positive, i bet
12:20:55 <sinelaw> EvanR-work, ya, non-negative is better. it is called positive
12:20:59 <sinelaw> positive measure
12:21:01 <sinelaw> for some reason
12:21:10 <sinelaw> but it's non-negative :)
12:21:37 <sinelaw> so we could have our "signals" be random variables
12:21:51 <sinelaw> since they are functions on a measurable domain
12:21:55 <jmcarthur> that sounds awesome
12:22:09 <sinelaw> and a system is something that transforms random signals
12:22:20 <jmcarthur> s/is/can be/
12:22:32 <sinelaw> yeah. random variables, i meant
12:22:45 <sinelaw> but this probably isn't what we really want. we want to work on random processes
12:22:58 <sinelaw> which are defined on time (or on discrete time for random sequences)
12:23:10 <sinelaw> so in that case it's just the regular thing
12:23:36 <sinelaw> random process : T -> (Omega -> R)
12:24:00 <jmcarthur> can measure be expressed as a type class, maybe with an associated type or something?
12:24:11 <sinelaw> i tried implementing a measurable type class
12:24:26 <sinelaw> but got stuck at one point with haskell's type system's limitations
12:24:38 <sinelaw> could be my haskell knowledge limitations :)
12:24:51 <jmcarthur> worth sharing your attempt?
12:25:16 <sinelaw> of course, as soon as i boot into linux again
12:25:21 <jmcarthur> okay
12:30:13 <beroal> hello. is anyone familiar with GHC API and 'CoreModule' type?
12:32:37 <edwardk_> EvanR-work: re: unused values, there are a large number of redundant NaN values, but the fact that all those values are signalling or non-signalling NaNs is exploited by other applications, and there isn't enough room in that space to encode a full complex number
12:34:13 <EvanR-work> no. but you could have vanity values ;)
12:35:14 <EvanR-work> kind of like the smiley faces and card suits in the upper plane of ascii
12:35:18 <EvanR-work> lol
12:44:11 <texodus> Anyone familiar with the "bus error" issue regarding GHC 6.12 & osx?
12:46:15 <edwardk_> EvanR-work: that way lies unicode ;)
12:48:37 <edwardk_> evanr-work just encode your float as 11111111101(21 bit unicode code point)
12:49:16 <EvanR-work> o_O
12:50:32 <edwardk_> EvanR-work: using 'i' and π or even ℵ
12:51:30 <edwardk_> EvanR-work: that is a non-signalling nan, with an extra bit set to keep it from getting confused with the nans the CPU usually spits out
12:51:49 <edwardk_> (the 0 there is the non-signalling bit) 
12:52:26 <alar> is there any difference between GADT and "sealed class"?
12:52:44 <edwardk_> the 1 after the 0 also ensures that the payload is non-zero and so that that becomes a nan
12:54:09 <Twey> EvanR-work: There is no upper plane of ASCII.  That's not ASCII any more.
12:54:18 <alar> it seems that GADTs and classes are mostly interchangeable
12:54:26 <EvanR-work> yes of course
13:00:04 <gwern> and an hour later I manage to get criterion to install with profiling
13:00:10 <alexyk> so looks like I need a stricter version of  IntMap.foldWithKey -- anybody hgot one?
13:00:12 <gwern> damn I hate profiling dep chasing
13:00:34 <c_wraith> yeah, the sooner you enable profiling in your cabal config, the happier you are.
13:00:49 <alexyk> c_wraith: why is it not on by default?
13:00:51 <c_wraith> it only double compile time for every package you install!
13:01:07 <alexyk> c_wraith: so what
13:01:09 <c_wraith> alexyk, I think that answers your question, even if I typed it before I saw it. :)
13:01:16 <alexyk> :)
13:01:38 <gwern> alexyk: exactly it's just a constant factor
13:02:12 <alexyk> all the time spent watching top, swap filling, box crashing...
13:02:43 <c_wraith> it's a *really* annoying constant factor, on packages like hxt, that take forever to compile
13:03:04 <c_wraith> two forevers is a long time
13:03:42 <alexyk> well it can prompt
13:03:51 <alexyk> are you a guru? y/N
13:04:10 <alexyk> guru stays unprofiled
13:05:16 <alexyk> (since he's omniscient anyways)
13:05:48 <alexyk> @src Data.Map.foldWithKey
13:05:49 <lambdabot> Source not found. Wrong!  You cheating scum!
13:06:11 <dschoepe> Is there a way to make cabal(-install) generate hoogle information and merge it with an existing database for each package it installs?
13:06:33 <alexyk> lamdbadot: shut up you cursing bastard!
13:06:50 <alexyk> lambdabot: see above
13:07:37 <gwern> dschoepe: nope. open bug
13:07:51 <Mathnerd314> I need a function of type (a -> b -> (a, b)) ->  a -> b -> (b, a)... unless there's something better than mapAccumL
13:08:51 <alexyk> where do I find the source for Data.IntMap.foldWithKey?
13:12:52 <dons> alexyk: cabal unpack containers
13:13:17 <alexyk> dons: thx
13:14:50 <dschoepe> gwern: ah, found an already existing bug report.
13:15:53 <napping> Does anyone here use Lava?
13:17:16 <alexyk> ha!  Data.IntMap defines foldWithKey via foldr, and there's foldr' there.  Strict?
13:18:13 <kmc> alexyk, if you're after strict folds, why not convert the map to a list?
13:18:24 <kmc> and use foldl'
13:18:28 <alexyk> kmc: it's big-ass
13:18:36 <alexyk> its huuge
13:18:46 * FunctorSalad has been wondering about this year-of-haskell-on-the-shell thing some more ;) what about a haskell parser with bash-style "everything but the head is a string by default"?
13:18:49 <alexyk> I want to avoid any conversions
13:18:51 <kmc> right, and that would be a show-stopper in a strict language
13:19:06 <FunctorSalad> with a type system it wouldn't actually suck as much as string issues sometimes can in shells ;)
13:19:20 <kmc> but if foldl' is consuming one cons cell at a time
13:19:26 <kmc> and M.toList is producing one cons cell at a time
13:19:33 <kmc> then the list is really a control-flow structure, not a data structure
13:19:42 <kmc> as Cale said, lists are loops waiting to happen
13:19:47 <FunctorSalad> and word-splitting in some contexts, I guess
13:19:55 <alexyk> hmm
13:20:16 <kmc> this is the argument for lazy-by-default -- it's more composable
13:20:33 <alexyk> but still I wonder for science's sake what foldr' does in Map and why is it jailed
13:20:37 <c_wraith> with decent fusion, you don't even allocate the cons cells
13:20:37 <kmc> whereas a Python library has to decide between providing lists, or providing generators (and often duplicates functionality by providing both)
13:20:51 <kmc> a Haskell library will just provide lists, which can be used either as data or as control flow
13:21:22 <kmc> c_wraith, does that sort of fusion work across a module boundary?
13:21:26 * FunctorSalad doesn't quite understand yet why that elimination of cons cells isn't straightforward and built-in?
13:21:45 <c_wraith> kmc: I don't really know how it's implemented, so I don't know.
13:21:47 <EvanR-work> just provide generators, a list can be generomatically generated from a generator
13:21:48 <FunctorSalad> naively it seems like it should be visible to the compiler that it's building something and taking it apart in the next step?
13:21:55 <kmc> yeah EvanR-work 
13:22:02 <kmc> but regardless, a lot of libraries don't do that
13:22:11 <kmc> that's the lazy-by-default solution ;)
13:22:13 <FunctorSalad> (maybe someone can point me to a counterexample that illustrates the trickyness)
13:22:24 <kmc> FunctorSalad, the question is whether you'll have to *again* take it apart in the future
13:22:32 <kmc> and you can't always know
13:22:40 <kmc> and if you might, then you have to save the result
13:22:45 <alexyk> so if foldr' is not exported by IntMap, the only way for me to get at it is to copy IntMap into MyIntMap exporting it?
13:22:48 <FunctorSalad> linearity inference issues again?
13:22:51 <gwern> dschoepe: I told you so
13:22:51 <FunctorSalad> hmm
13:22:55 <kmc> alexyk, unfortunately :/
13:23:05 <kmc> alexyk, i wish haskell had a way to override module export lists
13:23:15 <dschoepe> gwern: oh, I misparsed your sentence.
13:23:16 <alexyk> #if __GLASGOW_HASKELL__ >= 503 -- looks like it was before Cromwell
13:23:27 <kmc> haha
13:23:35 <gwern> kmc: couldn't that break all sorts of internal optimizations?
13:23:41 <kmc> time immemorial
13:23:51 <gwern> kmc: currently ghc can inline and fuse all sorts of things which aren't exported
13:24:14 <kmc> gwern, yeah, it'd probably have to be coupled with a way to re-compile the module locally
13:24:21 <alexyk> this information hiding is so PHB-enterprise "software"
13:24:28 <FunctorSalad> kmc: so I guess that's the tradeoff one makes with CPS-like data structures? like edwardk_ 's ran, or this pkg with lists encoded as newtype L a = L (forall m. Monoid m => (a -> m) -> m)
13:24:49 <kmc> hmm is that they enable better linearity inference / fusion?
13:24:50 <FunctorSalad> (namely, that you'll have to recalc everything when used more than once)
13:24:53 <kmc> oh
13:24:58 <kmc> yeah i suppose so
13:25:04 <FunctorSalad> sorry, sentence wasn't completed before I hit return ;)
13:25:24 <FunctorSalad> (don't remember how these lists were called)
13:25:25 <napping> alexyk: information hiding?
13:25:34 <FunctorSalad> (wasn't actually 'L')
13:25:52 <alexyk> napping: kidding, hiding implementation 
13:25:52 <gwern> wonder where to find a good binary tree
13:26:13 <napping> I don't see how you can prove anything if you can't quotient over internals
13:26:26 <FunctorSalad> 'information hiding' is another phrase for 'abstraction', isn't it... at least disregarding actual usage
13:26:40 <napping> well, hmm, I guess you could define a representation predicate and your invariants
13:26:44 <FunctorSalad> so I would say it's a very fundamental principle, not something enterprisy ;)
13:26:45 <EvanR-work> ignoring reality... <insert anything here> ;)
13:27:11 <FunctorSalad> EvanR-work: I realized the self-defeatingness of my msg, but I think you get what I mean anyway ;)
13:27:21 <EvanR-work> rofl
13:27:38 <napping> So nobody uses Lava? I've been looking at it a bit after reading the recent Reduceron stuff
13:27:56 <FunctorSalad> "information hiding" taken literally is abstraction. "information hiding" as a phrase is more common in IT, yes
13:28:06 <kmc> preflex, seen andygill
13:28:06 <preflex>  Sorry, I haven't seen andygill
13:28:15 <kmc> hmm he was here recently, wrong nick?
13:28:37 <EvanR-work> FunctorSalad: it gets perverted into you asking someone in python or java how something is implemented, and they tell you 'you dont need to know about that go away' ;)
13:28:48 <EvanR-work> the information has been hidden
13:28:51 <alexyk> ah no, foldr' is called from foldr.  Can anybody tell me what's strict there?http://paste.pocoo.org/show/226655/
13:28:56 <FunctorSalad> heh
13:29:22 <kmc> alexyk, how do you know it's strict?
13:29:27 <kmc> the ' suffix is used for lots of things
13:29:47 <alexyk> kmc: I don't anymore
13:29:53 <EvanR-work> it sort of weird to see haskell docs say stuff like 'heres Data.Map its implemented as a so and so sophisticated self balancing tree, heres the interface'
13:30:12 <EvanR-work> considering 
13:30:40 * alexyk craves fast dirty maps of yore
13:30:53 <kmc> that's because Haskell makes no attempt to be friendly to people who actively dislike learning
13:31:23 <kmc> information hiding often breaks down when you care about performance, especially beyond naive asymptotic analysis
13:31:57 <gwern> > round (5**(3/2))
13:31:57 <lambdabot>   11
13:32:00 <alexyk> so what about that foldr'?  
13:32:03 <kmc> also when you care about security -- because many successful exploits are not a head-on attack, but rely on something which was considered an irrelevant implementation detail
13:32:13 <FunctorSalad> hmm so it really isn't used in the sense of 'abstraction'? (hiding the things that are coincidental or specific to this case, extracting the essential)
13:32:21 <kmc> that's why i think security is interesting from a pure academic perspective
13:32:24 <FunctorSalad> ("information hiding")
13:32:27 <EvanR-work> kmc: well as long as the interface holds up...
13:32:42 <EvanR-work> otherwise they arent really hidden details
13:33:07 <EvanR-work> if internal integers can overflow with unexpected consequences then your interface doesnt deliver
13:33:48 <kmc> sure, i'm talking about things like timing analysis, voltage analysis, EM emissions
13:33:58 <FunctorSalad> it isn't a complete breakdown of the abstraction as long as you only need to look under the abstraction for performance
13:34:19 <EvanR-work> nah those dont exist, im running an intel mathematical turing machine
13:34:23 <FunctorSalad> (still semantic abstraction at least)
13:34:26 <kmc> the interface used in software and digital logic is a massive underspecification of the physics involved
13:34:44 <kmc> i like the result about how two supposedly isolated processes can communicate using the CPU cache
13:34:55 <EvanR-work> a uniformly distributed, frictionless, spherical cow
13:35:22 <gwern> @hoogle round
13:35:22 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
13:35:22 <lambdabot> Text.Html background :: String -> HtmlAttr
13:35:22 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
13:35:23 <FunctorSalad> kmc: now that sounds pretty leet ;)
13:35:29 <gwern> > (5**(3/2))
13:35:30 <lambdabot>   11.180339887498949
13:35:39 <EvanR-work> kmc: ... how?
13:35:39 <gwern> guess the easiest way to round up would be to just add 1
13:35:47 <FunctorSalad> 0.5
13:36:08 <gwern> > round $ (5**(3/2)) + 0.5
13:36:09 <lambdabot>   12
13:36:18 <edwardk_> functorsalad exactly right re the trade off of cps data structures giving you fusion at the expense of intermediate results
13:36:19 <FunctorSalad> you don't want to round 0.6 up to 2 ;)
13:36:27 <codolio> > ceiling $ 5 ** (3/2)
13:36:28 <lambdabot>   12
13:36:41 <gwern> @hoogle ceiling
13:36:41 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:36:49 <kmc> EvanR-work, well, it's easy for a process to control what's in the cache, and it's not too hard for a process to time how long a memory access takes
13:37:22 <micahjohnston> kmc: aha that's clever
13:37:24 <EvanR-work> kmc: how do you access the cache?
13:37:30 <kmc> which part?
13:37:35 <EvanR-work> an arbitrary part
13:37:37 <FunctorSalad> edwardk_: great, that clears it up some... if there was no downside to the CPS structures, you'd wonder why ordinary data doesn't just compile to it ;)
13:37:43 <kmc> you control what's in the cache by reading stuff from memory
13:37:54 <Ferdirand> you just use it, and try to observe if there was a miss
13:37:54 <kmc> you test what's in the cache by reading stuff from memory, and measuring how long it takes
13:37:58 <FunctorSalad> ok so I use CPS data to tell the compiler "trust me, it's linear" essentially?
13:38:09 <EvanR-work> kmc: ah, so you dont directly communicate data
13:38:13 <edwardk_> FunctorSalad: that is one use =)
13:38:18 <kmc> EvanR-work, don't know what you mean by 'directly'
13:38:21 <Ferdirand> there will be a miss if another process filled the same cache line by accessing some memory address that happen to map to the same cache line
13:38:21 <kmc> you can send bits this way
13:38:23 <EvanR-work> IPC
13:38:34 <kmc> it's not a reasonable way to do IPC
13:38:44 <edwardk_> functorsalad: rather more precisely 'cheaper to rederive than store' 
13:38:52 <FunctorSalad> *nod*
13:38:56 <kmc> it's a way to smuggle information out of the top-secret section of your fancy DoD approved security-level isolated operating system
13:39:01 <EvanR-work> kmc: practical applications? :)
13:39:27 <EvanR-work> wouldnt the two sides need to communicate
13:39:29 <kmc> yes
13:39:31 <FunctorSalad> edwardk_: the purely-functional-tries stuff is sort-of inverse to CPS-ifying, isn't it?
13:39:31 <EvanR-work> i mean, cooperate
13:39:43 <edwardk_> i've been toying with some nice bindings to MPFR or OpenCL that use that approach somewhat dynamically.
13:39:48 <FunctorSalad> (at least in the data -> CPS data -> trie'd CPS data direction)
13:39:51 <Ferdirand> there is a "practical" application where you can recover encryption key bits
13:39:55 <edwardk_> FunctorSalad: that analogy breaks my brain a little but i can see it
13:39:59 <kmc> the theory is that you have an OS that isolates privileged and non-privileged processes
13:40:09 <Ferdirand> especially for cyphers that use look up tables to accelerate processing
13:40:11 <FunctorSalad> edwardk_: I haven't thought about it in any detail either or mine would break even more ;)
13:40:14 <kmc> and the privileged processes can only talk to other privileged processes and networks
13:40:17 <FunctorSalad> just a vague idea
13:40:29 <RayNbow> hmm, can Hayoo be used to find all instances of a certain class?
13:40:31 <kmc> and your vector for getting the information out (the Internet, USB stick, etc) is non-privileged
13:40:34 <Ferdirand> if you can figure out which part of a look up table was accessed recently, you recover information about the key and such
13:40:40 <edwardk_> kmc: capability systems?
13:40:43 <kmc> yeah
13:40:47 <kmc> or something like that
13:41:28 <EvanR-work> i need to read about this
13:41:29 <ezyang> @pl not . null 
13:41:29 <lambdabot> not . null
13:41:31 * edwardk_ was obsessed with single address operating systems at one point using capabilities and orthogonal persistence.
13:42:02 <edwardk_> ultimately i relented in the face of evidence that such a system just doesn't survive in practice due ot the eventuality of a random bit flip
13:42:44 <kmc> that reminds me of another physical-level attack
13:43:04 <edwardk_> kmc: the one on vms by shining a light on the cpu?
13:43:05 <kmc> which is that you can write a Java applet which uses memory in a particular way
13:43:09 <edwardk_> yeah
13:43:15 <kmc> such that with high probability a single bit-flip error will give you control of the VM process
13:43:16 <kmc> yes
13:43:36 <gwern> edwardk_: what makes such a system unable to use any ECC?
13:43:55 <ezyang> cheapskateness :-) 
13:44:00 <edwardk_> gwern: ecc just protects the bit flips from happening in memory. it doesn't keep your registers from flipping, a bit on a bus, ....
13:44:23 <edwardk_> gwern: it helps with, but it doesn't solve the problem.
13:44:47 <sinelaw> edwardk_ such a system DOES solve 99% percent of software security problems
13:45:16 <FunctorSalad> kmc: interesting perspective how security calls our whole tower of abstractions into doubt again...
13:45:23 <sinelaw> most security flaws are silly mistakes
13:45:30 <sinelaw> not fundamental limits of the system
13:45:38 <FunctorSalad> (doubt insofar as "can the level below this be totall ignored?")
13:45:42 <edwardk_> gwern: and such errors are also often correlated, so if you have one flip you may likely have two. you only need one to accumulate violations of system invariants, that if you're using an orthogonal persistence mechanism get fossilized for all time
13:46:16 <edwardk_> sinelaw: yes, but in the case of the sasos models i mention, the problem is actually the fundamental limit =)
13:47:00 <sinelaw> edwardk_ is that problem really what should be bothering us though? it would be nice to have orth. persistence and capabilities
13:47:06 <sinelaw> very nice even
13:47:12 * alexyk and so they all got distracted, and Map's foldr' was left on the side of the road...
13:47:25 <alexyk> avoiding success
13:47:31 <edwardk_> sinelaw: sure, until 4 months later you can't boot the machine at all
13:47:32 <zygoloid> what's a single address operating system?
13:47:43 <FunctorSalad> zygoloid: I was about to ask
13:47:48 <edwardk_> sinelaw: and because you had orthogonal persistence you'd never bothered to write anything to serialize out your data
13:48:08 <sinelaw> edwardk_ why is not using orth. persistence free of this problem?
13:48:17 <sinelaw> i mean the same way it doesn't happen now, it could not happen then
13:48:28 <kmc> what's orthogonal persistence?
13:48:50 <edwardk_> sinelaw: because when a process dies in a posix environment, you go out to the disk which acts as your canonical store. you store intermediate data serialized to disk with checksums and parity checks, etc.
13:49:17 <sinelaw> kmc something that makes the idea of persistent vs. volatile memory not an issue. as far as software is concerned everything is persisted until you release it.
13:49:21 <edwardk_> sinelaw: and because disks have so many other sources of bit errors, we're used to dealing with them and have engineered all of our low level processes on that front to handle them
13:50:08 <edwardk_> kmc: straw man implementation. mark all pages in memory copy-on-write, and save a copy of them out to disk, then when you're done, check the dirty ones, serialize those out to disk, and repeat. 
13:50:20 <sinelaw> edwardk_ but why can't we do this also to protect from the same when abstracting away the persistence stuff?
13:50:42 <sinelaw> you could still have checked versions in the store or something
13:51:06 <edwardk_> sinelaw: because the bit flip happened while it was sitting in memory and you were computing with it. you're serializing arbitrary computation. you can't checksum that without running 3 times. losing all the performance benefits
13:51:32 <edwardk_> (well running twice plus a tiebreaker pass)
13:52:48 <cheater99> does haskell have any functionality for fault tolerance?
13:52:59 <cheater99> e.g. 5 of 9 and so on
13:53:00 <edwardk_> kmc: you have to be a bit smarter than that naive algorithm, but then what you get is something that you can load up into memory just enough pages to describe the core of your kernel (straight from the log, since the pages describing your processes, their page mappings, etc. are all in the log too!) and you can boot really fast
13:53:16 <edwardk_> kmc: the only tricky part is notifying the system that its rebooted and needs to reininitialize devices
13:53:39 <edwardk_> kmc: and extending a sufficient portion of the kernel to be willing to be paged out
13:54:36 <EvanR-work> how about using a kernel that doesnt take freakin forever to load
13:55:01 <edwardk_> sinelaw: a typical orthogonal persistence implementation hits you for about 3% overhead. doing every calculation twice takes you to ~103%, plus you can't then do lock-free or non-deterministic stuff
13:56:07 <sinelaw> edwardk_ not if you have hardware that's designed for it
13:56:38 <uorygl> > product . map (read . return) . show $ 277777788888899 :: Integer
13:56:40 <lambdabot>   4996238671872
13:57:00 <uorygl> > iterate (product . map (read . return) . show) 277777788888899 :: [Integer]
13:57:01 <lambdabot>   [277777788888899,4996238671872,438939648,4478976,338688,27648,2688,768,336,...
13:57:21 <uorygl> Aw, where's the rest of it?
13:57:27 <uorygl> > iterate (product . map (read . return) . show) 336 :: [Integer]
13:57:28 <lambdabot>   [336,54,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:58:00 <jmcarthur> i wish i could get in on this conversation
13:58:11 <edwardk_> sinelaw: commodity hardware isn't going to change to accomodate you, so this now becomes a theoretical exercise, but even granting that, you still can't win. since the perfect fault-detecting hardware can't be built.
13:58:13 <jmcarthur> this is the kind of security issues i work with
13:58:17 <sinelaw> edwardk_ since multi-coring has become so cheap, we might as well have a little less performance and several order of magnitudes less errors
13:58:51 <jmcarthur> but it would be best if i don't participate
13:58:59 <sinelaw> jmcarthur why?
13:59:00 <edwardk_> sinelaw: in any event, i have to run. bbiab
13:59:06 <sinelaw> k
13:59:09 <EvanR-work> if he told you, hes have to kill you
13:59:18 <jmcarthur> i mean, i could talk in general terms i guess
13:59:37 <kmc> hehe
14:00:11 <jmcarthur> yeah i don't even have clearance. in my case it's just NDA stopping me
14:00:40 <EvanR-work> security by obscurity (tm)
14:00:47 <aristid> uorygl: couldn't you use map ord instead of map (read . return)?
14:01:03 <sinelaw> jmcarthur NDA?
14:01:05 <ddarius> aristid: No.
14:01:19 <jmcarthur> sinelaw: non-disclosure agreement
14:01:19 <aristid> ddarius: why not?
14:01:20 <siracusa> > ord '1'
14:01:21 <lambdabot>   49
14:01:21 <uorygl> > ord '3'
14:01:22 <lambdabot>   51
14:01:27 <aristid> oh, right :D
14:01:37 <jmcarthur> standard corporate document
14:01:41 <ddarius> > map digitToInt "336"
14:01:42 <lambdabot>   [3,3,6]
14:01:48 <aristid> better.
14:02:46 <sinelaw> jmcarthur yeah
14:02:57 <sinelaw> i've signed those
14:15:55 <aristid> byorgey: sorry for pestering you about this, but it would be cool to link the old monad readers from the new blog
14:17:41 <monochrom> This is the problem with "everything is a blog".
14:18:01 <redocdam> the blog monad will solve this
14:18:13 <EvanR-work> a monad is like a blog
14:18:14 <redocdam> you need to study up your category theory
14:18:27 <aristid> i prefer Comonadic blogs.
14:18:58 <ddarius> There's a "Previous Issues" link that has links to all the previous issues.
14:19:10 <ddarius> monochrom: You misplaced the error.
14:20:36 <aristid> ddarius: oh, totally didn't see that
14:21:01 <aristid> ddarius: i actually used the history on the haskellwiki page to find the old readers...
14:21:44 <monochrom> I did not misplace the error. There is a "previous issues" link and I have known it for weeks. Because of the blog nature, "previous issues" cannot be in the same stream as current issues, lest the stream would look counterintuitive, i.e., old issues are in newer blog entries than some new issues.
14:21:51 <McManiaC> can someone help me to get gtk2hs running on windows? I could install everything with cabal, but if I try to run anything I get a "can't load .so/.DLL for: libintl-8 (addDLL: could not load DLL)"
14:21:56 <redocdam> When you have made a blog you need to identify the morphisms in it and do a cocone construction to possibly create more jargon or indentify new jargon relationships in your blog
14:22:10 <McManiaC> my PATH contains a intl.dll tho
14:22:28 <McManiaC> should I copy & rename that/link it or anything?
14:22:50 <ddarius> monochrom: Easy enough to fix that.  Just repost -all- the issues up to current.
14:23:14 <ddarius> monochrom: Nevertheless, I still don't think that would solve the problem in general.
14:23:25 <redocdam> I think it would be best if you just gave up monochrom 
14:23:32 <redocdam> that's the quickest solution
14:23:33 <ddarius> The real solution is to get rid of humans.
14:23:57 <redocdam> misanthropy can be viewed as a category
14:24:08 <redocdam> possibly a helpful one
14:25:00 <Twey> PEBCAK solved.
14:26:07 <aristid> monochrom: in most blogs, you can give entries a fake date.
14:30:42 <redocdam> I think he should just give up
14:43:44 <sinelaw> hey conal :)
14:45:21 <conal> sinelaw: hi! :)
14:45:32 <sinelaw> conal: how are you?
14:46:06 <conal> sinelaw: pretty great.  enjoying the summer.  lots of outdoor work this time of year, getting the property ready for fire season.
14:46:18 <conal> sinelaw: and having fun ipad programming.
14:46:20 * hackagebot Twofish 0.2 - An implementation of the Twofish Symmetric-key cipher.  http://hackage.haskell.org/package/Twofish-0.2 (RonLeisti)
14:46:37 <zygoloid> woo, my first foray into heap spelunking is a success
14:46:43 <sinelaw> conal,  great sounds like fun
14:46:46 <mreh> fire-season sounds menacing
14:47:06 <conal> sinelaw: how are you doing?  finished with school?
14:47:12 * zygoloid 's debugger is attached to an external haskell process and has found some heap roots
14:47:16 <sinelaw> conal: almost. one more exam and i'm done!
14:47:27 <sinelaw> unfortunately it's one of the hardest i've had
14:47:33 <conal> sinelaw: good luck!
14:48:04 <sinelaw> conal, i have a new pet idea about a model for frp. 
14:48:16 <conal> sinelaw: neat.  let's hear.
14:49:30 * BMeph licks a slate and waits with chalkboard-baited breath...
14:49:43 <sinelaw> conal: basically the idea is to define what properties a "system" should have to be expressible in the model. and then come up with building blocks to build only those types of systems 
14:50:23 <sinelaw> the important properties are causality and something i called "insensitivity"
14:50:27 <jmcarthur> :D FRP minds in one place
14:50:35 <sinelaw> jmcarthur :)
14:51:08 <conal> sinelaw: sounds great
14:51:17 <mreh> there's too much insensitivity in this world
14:51:22 <sinelaw> the causality property can be assured by providing something akin to scanl over any type of signal, continuous time or not. and by not allowing arbitrary sampling of signals.
14:51:41 <zygoloid> using the ghc api, how can i inject a name into the interactive context?
14:51:57 <mreh> zygoloid: you mean ghci?
14:52:13 <sinelaw> conal: so to calculate something over time, you need to use that primitive ("scanlT"?)  which works in time-order, so you can never violate causality
14:52:15 <zygoloid> no. i mean using ghc-as-a-library directly
14:52:33 <EvanR-work> but if you dont include acausality, i cant make my multiplayer relativistic flight sim
14:52:34 <zygoloid> i'm implementing a ghci-like environment, and i want to expose some values i've created in it
14:52:44 <mreh> cripes, I have no idea
14:53:05 <sinelaw> welcome back
14:53:11 <sinelaw> router problems still?
14:53:47 <zygoloid> for simple things i can 'runStmt ("let " ++ name ++ " = " ++ show value) RunToCompletion', at least
14:53:54 <conal_> oh, hm.  i'm at a wifi café today.  i don't usually drop out here.
14:54:04 <danharaj> I wonder what the specification of time signals looks like as coalgebras.
14:54:17 <sinelaw> conal_ what was last i said that you got?
14:54:31 <conal_> sinelaw: "the causality property can be ...."
14:54:48 <sinelaw> conal: so to calculate something over time, you need to use that primitive ("scanlT"?)  which works in time-order, so you can never violate causality
14:56:21 <redocdam> sinelaw: I hold that time can't change by Parmenides proof that change is impossible
14:56:32 <redocdam> there is only now and it will never change
14:56:39 <sinelaw> redocdam good luck with life
14:57:06 <sinelaw> redocdam :P actually recent physics models are sort of using that style of thinking to solve some problems
14:57:17 <redocdam> sinelaw: It stands to reason that there is only one moment in time, and it never changes
14:57:44 <ivanm> redocdam: have you read Thief of Time by Terry Pratchett?
14:57:58 <ivanm> for some reason your statement reminded me of that book ;-)
14:58:39 <redocdam> http://hackage.haskell.org/package/acme-now
14:58:42 <Twey> By its complete rejection of the philosophy posited therein?  :þ
14:59:46 <danharaj> Why is that on hackage.
14:59:54 <Twey> ‘The universe is destroyed and created anew every moment, and therefore the only appropriate attitude is surprise.’
15:00:38 <Twey> danharaj: For completeness
15:00:56 <yashton> there are three acme packages, all seem to be humorous
15:01:00 <Twey> http://hackage.haskell.org/package/acme-dont and http://hackage.haskell.org/package/pony likewise — where would we be without them?
15:01:19 <Twey> ‘empty’ isn't very funny
15:01:21 <yashton> reminds me of 'import antigravity' in python
15:01:34 <Twey> I think it's intended to be a blank sample package
15:02:59 <yashton> it's a reference to the famous lithograph of a smoking pipe with the caption "this is not a pipe"
15:03:16 <Twey> Just the message
15:03:44 <yashton> http://en.wikipedia.org/wiki/The_Treachery_of_Images
15:03:51 <yashton> sorry, a painting
15:04:57 <danharaj> but it is a package
15:05:15 <danharaj> It would be an homage if it had a hackage page without the ability to cabal it or download it.
15:05:52 <yashton> well, but if a package is a package, but doesn't actually contain anything, it isn't a package?
15:06:24 <ddarius> @wn package
15:06:26 <lambdabot> *** "package" wn "WordNet (r) 2.0"
15:06:27 <lambdabot> package
15:06:27 <lambdabot>      n 1: a collection of things wrapped or boxed together [syn: {bundle},
15:06:27 <lambdabot>            {packet}, {parcel}]
15:06:27 <lambdabot>      2: a wrapped container [syn: {parcel}]
15:06:28 <lambdabot> [7 @more lines]
15:07:04 <ddarius> According to 2, it is a package.  According to 1 it depends on your definition of collection.
15:07:18 <mreh> old OpenGLs have bitrotted T_T
15:08:26 <mreh> anyone doing haskell opengl things on 2.1?
15:08:48 * fryguybob thinks a package can contain the empty set.
15:09:07 <Arcs> some help on this error:   ghc: mmap 4096 bytes at (nil): Operation not permitted
15:09:33 <Arcs> while compiling
15:09:39 <ivanm> preflex: seen paczesiowa
15:09:39 <preflex>  paczesiowa was last seen on #haskell 1 day, 46 minutes and 32 seconds ago, saying: now, if only you could control those libraries with xml config files...
15:10:08 <Arcs> file compiles fine on windows but not linux
15:11:42 <tommd> Arcs: Are you using a recent version of GHC?  Does setting you min_addr to 0 fix the issue?
15:13:10 <Arcs> i'm using 6.12.1, how do i set the min_addr?
15:13:57 <Arcs> i guess i'll try upgrading first.
15:15:48 <monochrom> (I use ubuntu 10.04 and ghc 6.12.1 and haven't got this problem)
15:15:49 <tommd> Arcs: min_addr can be set via sysctl or using cat 0 > /proc/sys/vm/mmap_min_addr
15:16:40 <ivanm> Arcs: what are you trying to compile that you get this problem?
15:16:41 <tommd> It sounds oddly like on open embedded issue I ran into with a recent regressed kernel (used in both Fedora and Ubuntu).
15:16:47 <ivanm> and what architecture?
15:17:12 <Arcs> it's a 32 bit VM
15:17:27 <Arcs> and the minaddr didn't help
15:18:14 <ivanm> I wonder if it's the VM that's interfering...
15:18:19 <ivanm> Arcs: which VM are you using?
15:18:22 <Arcs> vmware 6.5
15:18:34 <Arcs> http://pastebin.com/Lec9RApK
15:18:40 <Arcs> that's the particular file causing problems
15:18:45 <Arcs> all the other files int he project compiles fine
15:20:56 <tommd> That file has some includes that aren't available.  If you are able to pair this down to a semi-small test case then I might test it.
15:23:30 <Arcs> sort of solved it, i had the files on a vmware shared folder, upon moving it out of the shared folder the compile worked fine
15:23:54 <tommd> huh, well at least its solve (ish).
15:24:00 <tommd> s/solve/solved
15:24:47 <Arcs> i'll assume it's vmware weirdness..
15:24:52 <Arcs> thanks
15:35:39 <ezyang> How do I pattern match against a constructor without needing to have dummy vars for all of its parameters? 
15:35:53 <ezyang> i.e. st@(ConstructorName  _  _ _) but shorter 
15:36:00 <gwern> > 10 ** (1/3)
15:36:00 <lambdabot>   2.154434690031884
15:36:02 <Twey> st@ConstructorName{}
15:36:09 <ivanm> dammit, Twey beat me to it
15:36:17 <ezyang> cool. 
15:37:58 <gwern> > 10**(2/3)
15:37:59 <lambdabot>   4.641588833612778
15:39:52 <ManateeLazyCat> "Haskell Interperter + Dynamic Linking" is only way i can think to build a extensibility haskell system that extend sub-module in runtime... Maybe have better solution?
15:40:07 <gwern> maybe but I've no idea what that means
15:40:37 <ManateeLazyCat> gwern: Do what elisp do for Emacs. :)
15:40:45 <ManateeLazyCat> gwern: But use haskell. :)
15:40:49 <gwern> so xmonadlike?
15:41:09 <ManateeLazyCat> gwern: More powerful than that.
15:44:26 <monochrom> http://hackage.haskell.org/package/direct-plugins uses the GHC API and so is equivalent to "Haskell Interpreter".
15:44:45 <ManateeLazyCat> monochrom: Thanks for link, i will read it. :)
15:45:04 <ddarius> s/equivalent//
15:45:46 <Dashkal> direct-plugins has me confused.  "unfortunately does not work on GHC 6.12", "base (≥4.1 & <5), ghc (≥6.12), ghc-paths  (≥0.1.0.6)" seem to be at odds with each other
15:46:26 <monochrom> It means the other lib, http://hackage.haskell.org/package/plugins , does not work on GHC 6.12.
15:46:30 <ManateeLazyCat> Dashkal: Maybe it can compile pass, but can't works well. :)
15:46:47 <Dashkal> oh!  plugins doesn't and that replaces it
15:46:55 <Dashkal> yeah
15:47:00 <Dashkal> teach me to skim
15:48:54 <dons> finishing up my write up about hs-plugins this week. probably see a new release in july
15:50:44 <ManateeL`> Good package, i will try to merge it in my project.... :)
15:52:43 <monochrom> oh god, hs-plugins has a comeback this july, like many movies like toy story?! :)
15:52:59 <Gracenotes> wah... the map ($x) [f, g, h] question on haskell-cafe got 7 (nearly identical) replies within 10 minutes!
15:52:59 <monochrom> 2010 year of re-makes :)
15:53:23 <gwern> Gracenotes: this is called not checking for replies
15:53:29 <gwern> often happens with easy questions
15:53:37 <Gracenotes> low-hanging fruit
15:53:48 * Gracenotes is glad for gmail's feature
15:55:04 <Gracenotes> low-hanging but nonetheless delicious and citrusy
15:55:04 <monochrom> this is called using 1970s email programs that don't do threading.
15:55:04 <ManateeL`> monochrom: Have you use direct-plugin ? How about it compare with hs-plugins?
15:55:12 <monochrom> I haven't.
15:58:52 <dons> "any rate rather poorly documented." :(
15:59:01 <dons> we didn't have no damn haddock back then. 
15:59:09 <dons> http://www.cse.unsw.edu.au/~dons/hs-plugins/ so i wrote everything in tex
15:59:26 <monochrom> but your paper became unsync with the lib
15:59:40 <dons> we didn't have no cabal either
15:59:47 <dons> also no other libraries.
15:59:49 <ddarius> Hasn't haddock been around for quite a while.
15:59:49 <dons> or ghc-api
15:59:58 <dons> ddarius: i used idoc at the time.
16:00:00 <Igloo> And it was uphill both ways
16:00:06 <dons> Igloo: in the snow!
16:00:07 <monochrom> dons predates the dawn of humankind :)
16:00:23 <Igloo> Exactly!  :-)
16:00:32 <dons> http://www.cse.unsw.edu.au/~chak/haskell/idoc/
16:00:55 <dons> 2004 is the dark ages, apparently. wow. we've come a long way
16:00:58 <geheimdienst> monochrom, yeah who do you think made the dawn of humankind?
16:01:12 <monochrom> a fixed point.
16:01:41 <monochrom> to understand the dawn of humankind, you must first understand recursion.
16:02:05 <geheimdienst> to understand the dawn of humandkind, you must first understand dons
16:02:10 <ddarius> dons: Haddock seems to predate hs-plugins by a couple of years.
16:02:21 <ddarius> Admittedly it was new when I got here.
16:02:25 <ddarius> (Haddock that is.)
16:02:36 <dons> i think it was still unclear which doc tool would win.
16:02:43 <dons> cabal --haddock basically ensured the winner 
16:03:03 <monochrom> don't feed bad. just come back. :)
16:03:07 <ddarius> dons: Really?  It seems iDoc stopped having releases when Haddock started being released.
16:03:17 <dons> 2004 was the last release, looks like.
16:03:28 <ddarius> My impression was that haddock had won solidly well-before cabal.
16:03:35 <dons> but yes, iirc haddock was an attempt to produce a unified tool
16:03:43 <dons> ddarius: maybe, but it wasn't in wide use
16:03:44 <monochrom> "plugin wars: episode #5: the dons strikes back"
16:03:47 <dons> since we used makefiles
16:03:48 <stepcut> I have a monad like, newtype MyMonad m a = MyMonad { unMyMonad :: ErrorT Response (WriterT [(Response -> Response)] m) a }. If I move that monad definition from the module I use it in, to another module, I get a giant space leak sometimes when using liftIO... any idea why ?
16:03:59 <dons> and didn't have libraries 
16:03:59 <ddarius> dons: Wasn't it used for GHC documentation by then?
16:04:06 <dons> probably.
16:04:21 <dons> that might have been the only user. i certainly recall trying to rip out hte makefile code
16:04:27 <ddarius> Certainly Haddock (and any Haskell documenting tool) is massively more used now than then.
16:04:50 <dons> well, there's no choice now. to the point that the direct-plugins author thought hs-plugins was undocumented :)
16:05:02 <dons> which is fine. but i just remember spending a lot of time writing docs
16:05:02 <monochrom> stepcut: did you compile with -O? -O2?
16:05:16 <stepcut> monochrom: -O2 and -threaded
16:06:15 <ddarius> dons: People often consider libraries undocumented even when they are well documented.
16:06:46 <Saizan> stepcut: "not enough inlining", also writer with [] tends to give poor performance
16:07:08 <aristid> ddarius: that's because the user is always stupid.
16:07:34 <ddarius> aristid: No.
16:07:35 <stepcut> Saizan: it's actually using WiriterT with (SetAppend $ Dual $ Endo a), but that seemed like it would just confuse the issue :)
16:07:48 <stepcut> Saizan: how can I get more inlining ?
16:08:13 <QtPlatypus> aristid: No its because the documentation isn't presented in a mannor that is accessable.
16:08:29 <QtPlatypus> aristid: From a mental point of view rather then a techical one.
16:08:36 <ddarius> QtPlatypus: That's sometimes the problem, but certainly not always.
16:08:40 <Saizan> stepcut: adding some specialize/inline pragmas for MyMonad's >>=/return/other important methods
16:08:48 * geheimdienst thinks software development would be so much easier if users didn't exist
16:08:51 <gwern> some libraries' documentation is worse than useless. I think of Sibjorn finne's docs, which are just repetitions of the function and type names. -- | Wikimedia parser \n wikimediaParser :: ...
16:09:01 <ddarius> geheimdienst: 'sure would.
16:09:06 <elitheeli2> Anyone know how to make a thing of type GHC.Word.Word8 instead of a Char? Basically, I want to split a Data.ByteString but when I call BS.split '.' foo, it tells me '/' is a Char, which I sps it is.
16:09:17 <gwern> elitheeli2: pack?
16:09:32 <elitheeli2> gwern: how?
16:09:41 <gwern> @hoogle pack
16:09:41 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
16:09:41 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:09:41 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
16:09:45 <Saizan> stepcut: see for examples Get's Monad instance here http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary-Get.html
16:09:46 <stepcut> Saizan: is there a way to do that if the Monad instance is derived ?
16:10:13 <Saizan> stepcut: not sure
16:10:14 <Gracenotes> elitheeli2: you can split on Chars if you're using Data.ByteString.Char8
16:10:21 <Gracenotes> or the lazy variant ofc
16:10:58 <dons> elitheeli2: use the Data.ByteString.Char8 interface
16:11:17 <elitheeli2> gwern: pack looks like it yields a ByteString, not a Word8
16:11:30 <elitheeli2> dons: how, I'm very new to Haskell
16:12:13 <Saizan> elitheeli2: just import Data.ByteString.Char8 rather than Data.ByteString
16:12:18 <elitheeli2> oh ok
16:12:36 <elitheeli2> Oh I see split :: Char -> ByteString -> [ByteString}
16:12:37 <elitheeli2> awesome
16:12:47 * geheimdienst thinks it's a turn-off if the docs just say: "This package is a simple, user-friendly implementation of strong lax cerebral allegories as introduced by Poopenmayer et al. (2002)"
16:12:58 <tommd> Does Marcel Fourné hang out here?  Creator of hecc?
16:13:13 <gwern> > 8**0.5
16:13:14 <lambdabot>   2.8284271247461903
16:13:31 <gwern> tommd: never heard of it
16:13:35 <stepcut> Saizan: seems that adding an {-# INLINE liftIO #-} fixed the issue. Not sure if I should be happy or sad.
16:13:38 <tommd> @hoogle hecc
16:13:38 <lambdabot> No results found
16:13:44 <tommd> err,
16:13:45 <tommd> @hackage hecc
16:13:45 <lambdabot> http://hackage.haskell.org/package/hecc
16:14:35 <napping> geheimdienst: I've found the reference paper usually does a better job of introducing the concept and perhaps even describing how to use the code than about 90% of intentional documentation
16:14:53 <Saizan> stepcut: heh, one day we'll have whole program compilation to save us
16:15:38 <Saizan> stepcut: in the meanwhile if performance matters you might try to see if the CPSed version performs better
16:16:01 <geheimdienst> napping: still, i'd rather have a summary or something in the haddock, instead of just a link (possibly broken) to a pdf blob. my 2 cents.
16:16:10 <stepcut> Saizan: by july perhaps ?
16:16:34 <gwern> (wow, this is terrible. half an hour of discussion and I still don't understand funnel sort. it's stateful, so I blame haskell)
16:17:11 <Saizan> stepcut: whole program compilation by july? you'd have to ask lemmih but i don't think so :)
16:17:35 <gwern> isn't supero sort of like whole program compilation?
16:18:07 <Saizan> it's supercompilation, still quite different afaiu
16:20:05 <Saizan> however yeah, i forgot about that, it'll probably solve a lot of this
16:21:47 <elitheeli2> Does anyone use Snap for anything real?
16:22:25 <c_wraith> It's still awfully early in Snap's lifecycle for that.
16:22:38 <c_wraith> I do use snap for something fake. :)
16:22:42 <elitheeli2> Nice
16:23:04 <gwern> > 64 ** (1/3)
16:23:05 <lambdabot>   3.9999999999999996
16:23:10 <c_wraith> something fake:  http://commie.pwrsrc.net/  source:  http://github.com/chowells79/homepage
16:23:19 <tommd> So close!
16:23:33 <gwern> > 8 ** (1/3)
16:23:33 <lambdabot>   2.0
16:23:44 <elitheeli2> It found me
16:24:20 <c_wraith> The source is more interesting than the app.
16:24:33 <elitheeli2> c_wraith: that's a lot of code for something that does essentially nothing
16:24:49 <gwern> > 64 / 4
16:24:50 <c_wraith> But it does it in a really cool way. :)
16:24:50 <lambdabot>   16.0
16:24:50 <interferon> this "how do you get off haskell" thread on the cafe is depressing
16:25:14 <c_wraith> I implemented dynamic loading.  When I said I wanted to integrate that into snap-core, they made me a committer. :)
16:25:16 <gwern> > 16 ** (1/3)
16:25:16 <lambdabot>   2.5198420997897464
16:28:31 <tommd> interferon: There's a reason most people I know unsubscribed from -cafe many months ago.
16:28:46 <gwern> we need more list snipers
16:29:15 <interferon> tommd: where do people have non-IRC discussion?
16:30:17 <tommd> interferon: In real life.
16:30:25 <interferon> tommd: about haskell
16:30:28 <tommd> Yes.
16:30:38 <interferon> oh i don't know anyone who cares about haskell
16:30:43 <tommd> I live in Portland.
16:30:55 <gwern> I know Gracenotes but I'd have to stalk him to know him in real life
16:31:09 * EvanR wakes up from a nap
16:31:12 <gwern> Gracenotes: I know where you live... to within 1 or 2 square miles
16:31:14 <EvanR> > undefined == undefined
16:31:15 <lambdabot>   *Exception: Prelude.undefined
16:31:17 <EvanR> shucks
16:31:19 <interferon> tommd: :D enough said
16:31:22 * EvanR goes back to sleep
16:31:23 <tommd> :-)
16:31:37 <Gracenotes> gwern: you can see my exact address with the gsoc location map
16:31:39 <interferon> are there haskell shops other than galois in portland?
16:31:43 <tommd> EvanR:
16:31:43 <tommd> > let undefined = 1 in undefined == undefined -- :-)
16:31:44 <lambdabot>   True
16:31:47 <Gracenotes> USE THIS INFORMATION WISELY
16:31:48 <gwern> Gracenotes: with the what?
16:32:35 <tommd> interferon: Other than Galois and Academic?  No, but pdxfunc (a functional programmer user group) is always interested and there are sometimes hackathons.
16:32:36 <elitheeli2> newbie question: given a of type Maybe b, and I have a function f from b -> b, I know there must be an easy way to apply the function to a and get a Maybe b out. How does this work?
16:32:52 <tommd> We're overdue for a hackathon actually
16:32:53 <interferon> Academic?
16:32:57 <EvanR> elitheeli2: maybe
16:33:00 <interferon> is that a company or are you referring to universities?
16:33:00 <EvanR> :t maybe
16:33:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:33:03 * gwern has never heard of Academic
16:33:11 <Gracenotes> er, fmap
16:33:13 <tommd> elitheeli2: 'fmap'
16:33:16 <EvanR> oh
16:33:31 <Gracenotes> the useful functions for Maybe: =<<, maybe, fromMaybe, and fmap
16:33:41 <EvanR> Just . f
16:34:05 <tommd> interferon: I mean, Portland State University (Andrew Tolmach, Bart Massey, Mark Jones, Jim Hook, Tim Sheard, etc - all Haskell fans of a sort).
16:34:07 <elitheeli2> fmap looks pretty good
16:34:11 <interferon> gotcha
16:34:24 <gwern> > 16**1/3
16:34:24 <blackh> TacticalGrace hello!
16:34:24 <lambdabot>   5.333333333333333
16:38:27 <interferon> i have to say that learning haskell has made me incredibly unproductive at java crap
16:38:34 <tommd> lol
16:38:45 <gwern> > 16 ** (2/3)
16:38:46 <lambdabot>   6.3496042078727974
16:38:50 <gwern> 16 / 6
16:39:11 <gwern> > 16 / 6
16:39:12 <lambdabot>   2.6666666666666665
16:40:16 <gwern> > 7**1/3
16:40:17 <lambdabot>   2.3333333333333335
16:43:42 <gwern> > 3 **1/3
16:43:42 <lambdabot>   1.0
16:43:46 <Mathnerd314> I need a function of type ([a] -> [b]) -> [(a,c)] -> [(b,c)]
16:44:02 <gwern> @hoogle ([a] -> [b]) -> [(a,c)] -> [(b,c)]
16:44:02 <lambdabot> No results found
16:44:23 <Mathnerd314> I tried that first
16:45:24 <Saizan> ?type \f -> uncurry zip . first f . unzip
16:45:25 <lambdabot> forall a b a1. ([a1] -> [a]) -> [(a1, b)] -> [(a, b)]
16:45:49 <Mathnerd314> ah, unzip
16:47:12 <elitheeli2> is there a way to have Cabal spit out the types of everything it compiles when you're running `cabal install`?
16:47:52 <ezyang> What do you mean by types? 
16:48:04 <elitheeli2> like for each function, what its type is
16:48:27 <Gracenotes> that might get verbose
16:48:32 <elitheeli2> That's true
16:48:32 <Saizan> no, but it can generate haddock docs
16:48:34 <ezyang> You could generate Haddock docs. 
16:48:44 <elitheeli2> Does it need to be able to compile first, though?
16:48:47 <Gracenotes> if you install a library module, you could also do :browse Module.Name in ghci
16:49:30 <Gracenotes> haddock can process the source code without it being compiled.. it uses the ghc api though, right?
16:50:45 <kniu> :t parse
16:50:46 <lambdabot> Not in scope: `parse'
16:50:51 <kniu> @hoogle parse
16:50:52 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
16:50:52 <lambdabot> Text.ParserCombinators.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
16:50:52 <lambdabot> Network.URI parseAbsoluteURI :: String -> Maybe URI
16:51:18 <kniu> See, I got a problem with this: Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
16:51:36 <Saizan> Gracenotes: it might get compiled too if TH is involved, and it has to typecheck anyway
16:51:44 <lpsmith> so,  anybody have an idea for a "sensible" definition of abs and signum would be for an affine martrix?
16:51:45 <kniu> The documentation says that the 'u' in "Parsec s u a" is the "user state" of the parser,
16:51:54 <Gracenotes> kniu: you can't extract it at the end, sadly
16:51:58 <kniu> but I don't see a function that allows me to supply an initial user state.
16:52:12 <kniu> Gracenotes, really?
16:52:17 <kniu> that sucks.
16:52:27 <kniu> how the hell am I supposed to use that, then?
16:52:34 <Gracenotes> I mean, you can extract it within the Parsec monad, of course
16:53:02 <Gracenotes> the relevant functions are at the bottom of the decl listings in http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Prim.html
16:53:09 <Saizan> kniu: use runParser
16:53:25 <kniu> okay, thanks.
16:54:04 <Saizan> and you can "extract it at the end" by adding a liftM2 (,) getState
16:55:43 <Gracenotes> hm yeah. the Parsec monad is just a bit too complicated to have a special runState variant, I suppose
17:02:21 <cheater99> so guys
17:02:28 <cheater99> what's the preferred way to indent haskell?
17:02:52 <gwern> 4 spaces
17:03:04 <benmachine> two spaces!
17:03:06 <elitheeli2> cheater99: afaik there is no pretty way to do it
17:03:17 <benmachine> you mean there are TOO MANY pretty ways to do it
17:03:22 <benmachine> that you can't decide between them?
17:03:30 <cheater99> wai
17:03:30 <cheater99> t
17:03:30 <elitheeli2> the "where" keyword always seems awkardly placed
17:03:33 <cheater99> there's no standard?
17:03:53 <benmachine> cheater99: apart from python, is there ever?
17:04:04 <elitheeli2> benmachine: Ruby is all 2 spaces
17:04:14 * benmachine prefers no standard to GNU standard <_<
17:04:36 <benmachine> apart from python and ruby\
17:04:42 <benmachine> apart from everything
17:04:43 <elitheeli2> also the standard in "whitespace" is pretty strict
17:05:02 <benmachine> I think trying to indent your whitespace program prettily
17:05:02 <cheater99> gnu standard = ?
17:05:04 <benmachine> is going to go wrong
17:05:05 <blackh> cheater99: Experiment. I use four spaces except for 'where' and 'else', where I use two spaces. That works quite nicely.
17:05:27 <benmachine> cheater99: run the 'indent' program on a C file with default settings, and then recoil in horror
17:05:31 <benmachine> (iirc)
17:05:38 <cheater99> blackdog: can you paste bin an example?
17:05:42 <blackh> cheater99: also do <something> `catch` \exc -> do <something>   <-- I indent `catch` two spaces here
17:05:42 <cheater99> benmachine: i don't have one.
17:06:10 <cheater99> blackh: i'm afraid i didn't understand what you're doing there
17:06:14 <benmachine> cheater99: well then be glad you never have to find out :P
17:06:35 <cheater99> o k
17:06:53 <arw_> just indent 1 tab, then everybody can choose how much the indentation will be.
17:07:01 <blackdog> cheater99: uh, whert?
17:07:04 <cheater99> aargaghh
17:07:14 <blackdog> were you talking to the hirsute kiwi?
17:07:16 <cheater99> blackdog: sorry that was for blackh.
17:07:19 <benmachine> arw_: I think GHC gets upset
17:07:37 <arw_> benmachine: no. only if you mix tabs and spaces
17:07:37 <benmachine> arw_: well, it *can* work with tabs but the result is ugly and confusing
17:07:50 <benmachine> -fwarn-tabs exists for a reason :P
17:08:21 <Axman6> arw_: don't use tabs
17:08:21 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
17:08:25 <benmachine> arw_: I believe the width of a tab character for the purposes of the layout rule is mandated by the haskell98 report
17:08:35 <benmachine> so if your editor has a different idea of what it is, you are going to get errors
17:09:30 <blackh> cheater99: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26318#a26318  <- that's what I do, and it works nicely, but there's nothing standard about it.
17:10:33 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26319#a26319 here's the new way I'm trying out
17:10:39 <cheater99> thanks
17:10:43 <benmachine> the old way was fairly awful
17:10:46 <applicative> elitheeli2, if you have a local hoogle instance, you can do a little song and dance to include function names and type signatures in the database it uses  http://neilmitchell.blogspot.com/2008/08/hoogle-database-generation.html
17:11:29 <cheater99> 1-space indent?
17:11:33 <cheater99> i don't think i could bear that
17:11:59 <benmachine> what where
17:12:17 <benmachine> the 'where' is indented one space from the case yes
17:12:24 <benmachine> it's sort of in between the case and the branches
17:12:34 <benmachine> wait does that even make sense
17:12:42 <benmachine> I think where attaches to branches rather than case statements
17:13:00 <benmachine> in which case it should probably be one space from the branch
17:13:06 * benmachine twiddles
17:17:30 <arw_> benmachine, Axman6: i know. the tab rule in the report is a huge mistake imho, as is too much reliance on layout.
17:18:14 <benmachine> arw_: huge? seems like an overstatement to me
17:18:26 <Axman6> haskell has an indentation based syntax, and when using tabs, you can't guarantee things will line up
17:18:28 <benmachine> haskell basically needs sub-tab indentation to look pretty
17:18:39 <benmachine> mixing sub-tab indentation with tab indentation
17:18:42 <benmachine> tends to lead to pain
17:18:53 <blackdog> "doctor, doctor, it hurts when i use tabs..."
17:19:12 * ddarius doesn't understand why many people are so gung-ho about things always being on "tabstops."
17:20:39 <monochrom> things went badly ever since some editor author invented "I can let user customize semantics of tab"
17:20:59 <benmachine> well, tabs were originally a typographic thing weren't they?
17:21:05 <arw_> monochrom: tabs were always customizable. thats the idea since the age of typewriters.
17:21:14 <benmachine> I don't know that they even make sense in the context we're talking about
17:21:28 <benmachine> i.e. electronic communications
17:21:30 <benmachine> what's the point
17:21:53 <blackh> They made sense in the 70s for compression
17:21:54 <ddarius> benmachine: The same point they had with typewriters.
17:22:29 <benmachine> blackh: that is the weediest form of compression ever :P
17:22:36 <theorbtwo> In fact, the word "tab" comes from the customiztion mechinisim -- the tab was the end of the stop that protrouded from the front of the machine, so you could see where it went, and had something to grasp to slide it along the rod.
17:22:44 <blackh> benmachine: In the 70s it was a good idea
17:22:55 <benmachine> blackh: a lot of things were good ideas in the 70s :(
17:23:20 <blackh> I think we should get rid of them now.
17:24:38 <aristid> the tab key is nice i think, but only as a "function key" that invokes procedures. no need to use physical \t
17:26:23 <arw_> tabs nicely solve the issue of "that is too much indentation for me" and "i like it when there is some more room on the left".
17:26:26 <McManiaC> how do you "add" icons to your binary?
17:26:58 <sproingie> highly platform specific
17:27:35 <benmachine> arw_: I like that principle, it just doesn't translate well to nice-looking haskell code in my experience
17:28:27 * hackagebot priority-sync 0.2.1.0 - Cooperative task prioritization.  http://hackage.haskell.org/package/priority-sync-0.2.1.0 (ChristopherLaneHinson)
17:28:48 <arw_> benmachine: yes, thats a haskell and python specific problem. too much reliance on whitespace in the syntax.
17:29:10 <benmachine> arw_: so you think C is better off?
17:29:25 <arw_> on that isolatex aspect, yes.
17:29:29 <arw_> isolated
17:29:55 <benmachine> but C has all the aesthetic appeal of decaying roadkill
17:30:07 <aristid> arw_: in practice there is extremely ugly tab-infested code in C
17:30:07 <benmachine> I would contend its typical indentation is partly to blame
17:30:28 * hackagebot roguestar-engine 0.4.0.0 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-engine-0.4.0.0 (ChristopherLaneHinson)
17:30:30 <applicative> \me , in the mood for mayhem, just ran /usr/bin/indent on a random haskell file,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26318#a26320
17:30:31 <aristid> stuff like void\tfoo\t\t\t(\tint\tbar\t\t\t)
17:30:38 <benmachine> but I would also contend that this is even sillier than emacs vs vim, so I'm going to bed instead >_>
17:30:54 <arw_> aristid: thats just plain wrong, nobody should ever do _that_
17:31:07 * applicative , rather
17:31:30 * hackagebot roguestar-gl 0.4.0.0 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-gl-0.4.0.0 (ChristopherLaneHinson)
17:31:32 * hackagebot rsagl 0.4.0.0 - The RogueStar Animation and Graphics Library  http://hackage.haskell.org/package/rsagl-0.4.0.0 (ChristopherLaneHinson)
17:31:38 <aristid> arw_: yes. it's happening though.
17:31:55 <arw_> benmachine: yes, exactly my point. thats also why its not a good idea to build a language which picks one side of a useless battle.
17:31:58 <aristid> it's especially annoying when you don't use the same tabwidth
17:32:12 <aristid> arw_: like Make?
17:32:19 <arw_> benmachine: saying "use that indentation style, or it will break" is like "use vim, or it will break"
17:32:30 <arw_> aristid: yes. exactly like the uglyness of make
17:32:34 <benmachine> arw_: i.e. argument-settling :)
17:32:37 <ddarius> arw_: Haskell's interpretation of tabs only affects you if you mix tabs and spaces.
17:33:04 <applicative> well, you can hardly avoid spaces
17:33:55 <arw_> ddarius: yes, i know, i mentioned that before. but as applicative says, sometimes there are problems, for example editing other peoples' code.
17:34:24 <arw_> bedtime...
17:34:42 <arw_> n8
17:38:59 <blackdog> arw_: the best part about picking a side is that you get consistency. it almost doesn't matter which side you pick
17:39:45 <benmachine> as long as it's not the tabs side
17:39:48 <benmachine> because that's stupid.
17:39:55 <benmachine> (jklol)
17:40:20 <applicative> @elite tabs
17:40:20 <lambdabot> 7AB5
17:41:49 <aristid> @elite applicative prefers tabs
17:41:49 <lambdabot> app1iC4+iVE prEph3R5 TAbz
17:42:26 <geheimdienst> @elite applicative is not entirely sane, it seems
17:42:26 <lambdabot> apPLi(4+Ive iS n0T 3ntIr3LY 5AN3, It SEE/\/\5
17:42:29 * applicative PrEpheRz0rz T4Bz
17:47:11 <FunctorSalad> "but applicative says" is that like "my lawyer says" now?
17:47:30 <FunctorSalad> oh, overread the "as" in "as applicative says"
17:47:34 <FunctorSalad> nvm ;)
17:58:16 <dpratt71> it seems like I've seen this before, but I can't remember the resolution: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26322#a26322
17:58:58 <ezyang> dpratt71: Use Cabal 
17:59:06 <ezyang> or hide one of those packages with ghc-pkg hide 
18:02:27 <geheimdienst> thanks a bunch, i'm having the same problem (with Control.Monad.Error) but couldn't get an answer the other day
18:03:22 <cheater99> benmachine: i don't get it :p
18:05:51 <etate> hey guys, i'm trying to install hsp-0.5.2 on ghc-6.12.3 but it fails with: ghc: could not execute: trhsx, has anyone encountered this problem?
18:08:00 <monochrom> perhaps install hsx: http://hackage.haskell.org/package/hsx
18:09:21 <etate> monochrom: hsx is installed, I did a cabal install hsx before-hand
18:09:55 <etate> monochrom: also, running trhsx from the command line works
18:10:39 <etate> running: which trhsx outputs "/home/etate/.cabal/bin/trhsx"
18:13:18 <dpratt71> ezyang: sorry, didn't see your response right away; this error occurs when I try to load something in ghci
18:13:36 <ezyang> Yeah, ghc-pkg hide is probably what you want 
18:14:12 <dpratt71> ezyang: ok, how do I decide which one to hide?
18:16:08 <ezyang> If you don't know, probably transformers 
18:16:14 <ezyang> since mtl is what comes preloaded 
18:16:52 <dpratt71> you mean hide monads-fd, yes?
18:17:23 <ezyang> oh, yeah, that's what I meant 
18:17:45 <dpratt71> ok, thanks
18:33:13 <FunctorSalad> is there any good reason why we can't runghc arbitrarily-named files?
18:34:34 <ezyang> ezyang@javelin:~$ cat foo main = print "bar" ezyang@javelin:~$ runghc foo "bar" 
18:34:34 <FunctorSalad> hmm now it works
18:34:40 <FunctorSalad> must have been something else...
18:34:40 <ezyang> haha 
18:34:46 <FunctorSalad> compiling it, probably
18:35:03 <FunctorSalad> (as an executable without a module decl)
18:36:25 <Jafet> I wonder if you can runghc /dev/stdin...
18:36:29 <Jafet> Bah.
18:36:47 <ezyang> you can just runghc... 
18:36:56 <FunctorSalad> heh
18:37:08 <FunctorSalad> I'd rlwrap it
18:37:41 <Jafet> Oh, you can just runghc
18:42:51 * hackagebot roguestar-engine 0.4.0.1 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-engine-0.4.0.1 (ChristopherLaneHinson)
18:42:53 * hackagebot roguestar-gl 0.4.0.1 - Sci-fi roguelike (turn-based, chessboard-tiled, role playing) game  http://hackage.haskell.org/package/roguestar-gl-0.4.0.1 (ChristopherLaneHinson)
18:42:55 * hackagebot rsagl 0.4.0.1 - The RogueStar Animation and Graphics Library  http://hackage.haskell.org/package/rsagl-0.4.0.1 (ChristopherLaneHinson)
18:43:13 <gwern> I don't remember roguestar being turn-based
18:43:17 <gwern> must've changed since I last played
18:44:12 <Blitzkev> ok I'm totally new to haskell, can someone show me why http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26323#a26323 yields Not in scope: `getArgs'
18:44:26 <ezyang> import System.Environment 
18:44:40 <ezyang> though looking at something like cmdargs might not be a bad idea 
18:46:31 <Axman6> Blitzkev: to use non Prelude functions, you have to import the library which defines them, which is System.Environment, like ezyang said
18:46:37 <Jafet> Let's bet on how long before the channel takes it upon itself to learn the kid some monads
18:46:56 <Blitzkev> ah, I figured it was something like that but with something so simple it's harder to google than ask
18:46:57 <Blitzkev> thanks
18:47:18 <Axman6> also, why not use the replicate function?
18:47:26 <Axman6> :t replicate
18:47:26 <lambdabot> forall a. Int -> a -> [a]
18:47:38 <clanehin> gwern: it's always been turn-based, but like most roguelikes, the CPU moves instantly
18:47:56 <gwern> well, that's one way to model it, I guess
18:48:52 <clanehin> gwern: but the only other option I know of is real-time
18:49:16 <ddarius> clanehin: You should play Valkyria Chronicles.
18:52:04 <clanehin> ddarius: does it do something special, other than atks of opportunity?
18:52:28 <ddarius> I don't know what "atks of opportunity" is.
18:52:47 <clanehin> ddarius: attacking on someone else's turn, in response to a trigger
18:53:08 <gwern> ooh, I always hate those
18:53:08 <ddarius> clanehin: I don't recall, but I don't think so.
18:53:55 <clanehin> ddarius: usually used to make people take extra damage from, e.g. building a canoe during combat
18:54:22 <gwern> I hate them because they make using a swarm of weak units less viable
18:54:45 <gwern> what's the point of dumping 4 or 10 attacks on a powerful unit if it gets to strike back instantly and destroy each attacker?
18:55:35 <clanehin> Also I spammed CIA-bot with 600 patches, all-in-all, a good day.
18:55:41 <ddarius> gwern: In Valkyria Chronicles, only some units counter-attack and the tanks (obviously) don't counter-attack with their main weapon.
19:23:22 <gwern> > 2000000 * 1000000
19:23:23 <lambdabot>   2000000000000
19:23:44 <Veinor> .. what'd you expect?
19:23:54 <gwern> I expected 4000000000000
19:23:56 <Blitzkev> 200000000001
19:23:58 <gwern> good to know
19:24:31 <djahandarie> You could probably make it happen with floating points
19:24:46 <gwern> let us never speak of floating point
19:28:17 * djahandarie looks down in shame
19:29:25 <BrianHV> newbie q: I'm going through RWH, and I'm looking at newtype.  is there a way to automatically derive every typeclass from the original type, so that I can treat it identically in every way except being able to use it interchangably with the original type?
19:30:37 <ddarius> BrianHV: With a GHC extension, mostly yes.
19:32:50 <BrianHV> is it considered risky or socially awkward to use GHC extensions?  or is GHC standard enough now that it doesn't matter?
19:33:13 <ddarius> BrianHV: It depends on the extension, but most people use GHC extension pretty freely.
19:33:52 <BrianHV> all right, thanks
19:34:10 * BrianHV goes back to figuring out what makes typeclasses cooler than traits
19:35:01 <ddarius> BrianHV: The idea of "concepts" that the C++ standards committee was contemplating was directly based on Haskell type classes.
19:36:40 <blackh> BrianHV: The Haskell standards committee is way behind common usage, so GHC extensions are very commonly used.  Some of them are indispensable.
19:36:43 <BrianHV> I didn't even realize they were contemplating that.  that's cool, I guess
19:37:13 <rj248842> can anybody point me to the source code for the standard list functions?  I think it's a prelude module called data.list (and I'm a newbie, so I'm sure I've got the terminology wrong there...)  thanks.
19:37:14 <BrianHV> blackh: good to know.
19:37:47 <ddarius> blackh: Considering that the Haskell standards committee hasn't existed for most or all of the past decade, that's not too surprising.
19:38:04 <ddarius> @where report
19:38:05 <lambdabot> http://www.haskell.org/onlinereport/
19:38:06 <blackh> Yes, there's just one guy and his cat is sick at the moment.
19:38:23 <ddarius> Less guys and cats than that.
19:38:26 <etate> no one can help? :(
19:38:56 <Saizan> @source Data.List
19:38:56 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
19:39:39 <Saizan> etate: do you have trhsx installed?
19:40:02 <etate> Saizan: yes, which points to /home/etate/.cabal/bin/trhsx
19:40:51 <etate> Saizan: though trying: cabal install trhsx fails with "failed to load interface for prelude"
19:40:54 <BrianHV> RWH chapter 6 has some lines like "case D undefined of D _ -> 1".  I don't think it's explained what "of" is doing there.  can someone help me out on that?
19:41:02 <Saizan> and /home/etate/.cabal/bin/ is in your $PATH? not using ~ ?
19:41:31 <Saizan> BrianHV: of is part of the case expression syntax
19:41:33 <ddarius> BrianHV: It's just syntax.  It separates the scrutinized expression from the branches.
19:41:45 <etate> Saizan: yeah in my path it shows as: /home/etate/.cabal/bin .. launching from the command line it works
19:41:49 <ddarius> BrianHV: Same thing 'then' and 'else' do in an 'if' expression.
19:42:36 <BrianHV> oh... right.  it's been a few days, and I got confused by seeing it all on one line.  thanks. :)
19:43:42 <etate> Saizan: it just fails when install hsp-0.5.2, btw i'm using the happstack source from darcs
19:45:17 <etate> is there some way i can set the path that GHC uses to execute an external program
19:45:37 <dons> depends which external program
19:45:50 <dons> cpp? ld? 
19:46:11 <Saizan> i think thrsx is used via the {-# OPTIONS .. #-} pramga directly in the source files
19:46:20 <Saizan> so you could put the absolute path there
19:46:30 <etate> dons: no, i'm trying to install happstack and it fails whilst installing hsp-0.5.2 because apparently ghc cannot execute trhsx
19:47:40 <etate> Saizan: where does GHC look by default? in PATH?
19:48:12 <gwern> where else would it look?
19:48:14 <Saizan> etate: yeah
19:48:21 <gwern> maybe you let cabal install it somewhere useless like in .cabal
19:48:51 <etate> gwern: right, its in .cabal/bin... but I added that to the PATH environment variable
19:48:57 <dons> etate: do you have trhsx in your path?
19:49:12 <etate> dons: trhsx is in ~/.cabal/bin
19:49:14 <dons> check that 'which trhsx' works
19:49:24 <etate> dons: yep it works
19:49:38 <dons> rerun cabal configure ; cabal build now?
19:51:41 <etate> dons: it says "At least the following dependencies are missing: hsp >= 0.5.2 && <0.6"
19:51:49 <etate> dons: when running cabal configure happstack.cabal
19:51:56 <etate> (in the happstack dir i mean)
19:52:04 <gwern> etate: hsp is a library, is it not? trhsx is an executable I thought
19:52:19 <Saizan> gwern: ?
19:52:27 <etate> gwern: yeah, trhsx is part of hsx
19:52:45 <gwern> Saizan: you don't build-depend on executables, but libraries
19:53:01 <Saizan> gwern: yeah, but that's irrelevant here
19:53:05 <dons> etate: so when you cabal install hsp what happens?
19:53:15 <dons> what does : ghc-pkg list hsp    show?
19:53:32 <etate> dons: it fails with "ghc: could not execute: trhsx"
19:54:18 <etate> /usr/local/lib/ghc-6.12.3/package.conf.d and /home/etate/.ghc/x86_64-linux-6.12.3/package.conf.d
19:54:40 <Saizan> etate: did you export the change to PATH ? i.e. is it visible if you open a fresh shell?
19:54:57 <Saizan> (assuming you changed it just now, and not before)
19:54:57 <etate> Saizan: yep
19:55:30 <etate> wait i was opening a tab, trying to open a different shell now
19:56:02 <etate> nope, same error
19:56:11 <Saizan> anyhow, try "cabal unpack hsp", then enter the directory, grep for trhsx in the src/ and put the absolute path in place of just trhsx
19:56:39 <Saizan> and then "cabal install" if it still errors out then it's not a PATH problem
19:56:54 <Saizan> also, you could try running trhsx by hand
20:03:29 <etate> Saizan: grepping the source reveals no trhsx
20:03:30 <robertmassaioli> hi everyone, I was just wondering if somebody knew if there was a 'cabal uninstall' command in the works?
20:03:49 <jmcarthur> there's always ghc-pkg unregister
20:03:55 <jmcarthur> or ghc-pkg hide
20:05:01 <Saizan> HSP/HJScript.hs:{-# OPTIONS_GHC -F -pgmFtrhsx #-}
20:05:01 <Saizan> HSP/XMLGenerator.hs:{-# OPTIONS_GHC -F -pgmFtrhsx #-}
20:05:06 <Saizan> etate: ^^^
20:05:24 <etate> Saizan: oh man :D
20:06:02 <etate> Saizan: so it would look like this: {-# OPTIONS_GHC -F -pgmF/home/etate/.cabal/bin/trhsx #-} ??
20:06:29 <Saizan> etate: i'd assume so, i've not used -pgmF much myself
20:07:05 <ddarius> Or as Saizan also suggested, you could just run trhsx over the source files ahead of time.
20:07:20 <blackh> robertmassaioli: I don't know of anything. You could do it if you have a bit of spare time. It would certainly be nice to have.
20:07:26 <blackh> I don't think it would be difficult at all.
20:07:35 <monochrom> oh haha "prelude for the rest of us" http://hackage.haskell.org/package/prelude-plus 
20:07:48 <blackh> Well... having said that - it requires a bit of understanding of how cabal's internals work, which is not entirely straightforward.
20:08:00 <etate> ddarius: i'll try doing that now
20:08:03 <blackh> But the task is relatively simple - call ghc-pkg to unregister it, and then clean up all the files
20:08:31 <jmcarthur> well, and making sure it won't break things that depend on it
20:09:51 <ddarius> jmcarthur: Which is the hard part.-
20:09:59 <robertmassaioli> blackh: it would still be worth looking at
20:10:06 <blackh> That's not so hard. Cabal has all that info.
20:10:30 <robertmassaioli> blackh: Yeah I think I will atleast look it and poke around. Thanks.
20:10:44 <blackh> robertmassaioli: I think the reason no-one has done it yet is just that it's never got to the top of anyone's priority list.
20:11:13 <blackh> robertmassaioli: Ask dcoutts.  He is the maintainer of cabal and can be found on here in the UK timezone.
20:12:50 <Saizan> blackh: the problem is that cabal doesn't really keep track of where the files get installed
20:13:07 <ddarius> And also things can get installed independently of cabal.
20:13:19 <FunctorSalad> monochrom: I had read that package description, but didn't get it
20:13:35 <Saizan> yeah, it doesn't even keep track of what :)
20:13:41 <FunctorSalad> it would imply that the Prelude is too obscurant and that this one is somehow more accessible
20:14:22 <blackh> Hmm
20:14:23 <FunctorSalad> *why* doesn't it, anyway
20:14:30 <Mathnerd314> there's Data.Map.insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a but no Data.Map.updateWith :: Ord k => (a -> a -> Maybe a) -> k -> a -> Map k a -> Map k a. Alternatives?
20:15:40 <etate> ddarius: nope still no luck, i ran trhsx on all files that required it :/
20:15:46 <ddarius> Mathnerd314: Um, does returning Nothing remove the element?
20:15:51 <robertmassaioli> if anybody else is interested: http://hackage.haskell.org/trac/hackage/ticket/234
20:15:54 <Mathnerd314> ddarius: yes
20:16:09 <Saizan> robertmassaioli: heh, you beat me to it
20:16:09 <ddarius> @hoogle alter
20:16:09 <lambdabot> Data.IntMap alter :: (Maybe a -> Maybe a) -> Int -> IntMap a -> IntMap a
20:16:10 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
20:16:10 <lambdabot> Control.Applicative class Applicative f => Alternative f
20:17:01 <Saizan> etate: did you also remove the old files and made sure the new ones don't have the {-# OPTIONS_GHC line?
20:18:18 <etate> Saizan: hmm now the error that occurs is: openBinaryFile: permission denied
20:18:27 <etate> when i run trhsx on the files
20:19:13 <Saizan> hah
20:19:49 <etate> Saizan: could it be that I run the install file as root, and roots PATH variable doesn't have /.cabal/bin ?
20:20:04 <etate> Saizan: well actually I'm using sudo instead of su
20:20:16 <Saizan> etate: you should never run cabal install with sudo
20:21:09 <etate> Saizan: if i don't run it with sudo i get cabal: dist/: permission denied
20:21:09 <Saizan> if you want to do global installation use cabal install --global --root-cmd=sudo, but user installations are recommended
20:21:32 <Saizan> etate: that's because you used sudo before.
20:21:54 <etate> Saizan: okay, so how do I start from scratch? :D
20:22:13 <Saizan> etate: well, first thing "sudo rm -fr dist" 
20:23:19 <etate> Saizan: I have no idea where dist is
20:24:01 <etate> Saizan: if i delete ~/.ghc and ~/.cabal will that not suffice?
20:24:02 <Saizan> etate: it's created by cabal in the package's directory while building
20:24:40 <Saizan> etate: it's unrelated.
20:25:53 <Saizan> http://code.haskell.org/~Saizan/hsp-0.5.2.tar.gz <- i've run trhsx for you
20:27:12 <blackdog> crud, it's almost ICFP time and i haven't got a team. anyone looking for another member?
20:28:29 <Saizan> when does it start, exactly?
20:28:38 <etate> Saizan: 12:00GMT
20:29:17 <blackdog> blackh: you competing this year?
20:30:09 <blackh> blackdog: Not this year - I've got too much to do at the moment, but I'll be into it next year.
20:30:41 <blackdog> blackh: heh, if you wait till you don't have too much to do you'll never enter:)
20:35:06 <FunctorSalad> remind me not to mention "lambda expression", "composeability" etc again outside the FP havens :|
20:35:21 <Axman6> what happened?
20:36:04 <FunctorSalad> people can be disingenious... it's true that some academic stuff produces no useful results, but they abuse this to just whack you with that label whenever you even mention the L-word
20:36:04 <Saizan> i think it's composability, btw
20:36:44 <blackdog> yes, especially when it's an excuse to dismiss it without addressing the substantive points
20:36:52 <FunctorSalad> Axman6: uh, I was giving "... | xargs -n1 lambda x echo hai x" as an example how lambda could be incorporated into bash
20:36:57 <Saizan> ah, you tried to sell lambda abstractions in #bash ?:)
20:37:05 <FunctorSalad> someone rewrote it to a loop
20:37:15 <FunctorSalad> (as if this specifically was my actual problem)
20:37:42 <FunctorSalad> I said "but having the body as a first-class object can be useful", they said "bs" etc etc
20:37:46 <etate> Saizan: oh my.. It was all caused because I used sudo cabal install :(
20:38:04 <etate> Saizan: now it works!! :)
20:38:04 <FunctorSalad> Saizan: #linux, thought we had slightly better diplomatic relations to that one :D
20:38:07 <blackdog> FunctorSalad: eesh, you were pushing FP in #bash???
20:38:33 <blackdog> ah
20:38:44 <Saizan> etate: nice :)
20:38:47 <FunctorSalad> blackdog: nop in #bash I got yelled at for suggesting automatically growing array-based collections
20:38:59 <FunctorSalad> "rainbow fantasy land" etc
20:39:06 <etate> Saizan: thanks for the help!
20:39:10 <blackdog> don't get me wrong, it's a nice addition, but you're choosing your audience very bravely.
20:39:31 <Jafet> Whatever happened to haskell-shell
20:39:38 * blackdog is suddenly reminded of sir humphrey's tone when saying "very courageous, minister..."
20:39:42 <FunctorSalad> I didn't mean to proselytize there at all; I often find myself reaching for lambda intuitively
20:40:03 <Saizan> etate: np
20:40:57 * etate always thought GHCi was a haskell shell
20:41:08 <Saizan> i wish i used the shell more, so i could be motivated to work on some haskell-shell-alike
20:41:41 <blackdog> FunctorSalad: yeah, it's frustrating to reach for the appropriate tool and find it's not there.
20:41:45 <FunctorSalad> blackdog: I hadn't even suggested them as a new shell feature or anything, just mentioned them to explain something else
20:41:59 <FunctorSalad> (the growing-array thing)
20:42:14 <FunctorSalad> something about reading a stream into a variable
20:42:22 <FunctorSalad> (doesn't matter)
20:43:08 <FunctorSalad> etate: I think it isn't very far from a usable shell
20:43:30 <FunctorSalad> maybe add string-by-default and some careful word splitting, dunno
20:44:12 <Jafet> class Pipe a where (|) :: ...
20:44:17 <FunctorSalad> and rename all the changeWorkingDIrectory stuff to cd and so on
20:44:26 <FunctorSalad> that *is* a serious problem for use as a shell
20:44:58 <FunctorSalad> Jafet: (|) is reserved IIRC
20:45:04 <FunctorSalad> list comprehensions
20:45:06 <Jafet> Darn
20:45:37 <etate> FunctorSalad: theres always :cd
20:45:38 <FunctorSalad> maybe it'd just be an arrow
20:45:59 <FunctorSalad> etate: yes, but also all the other stuff in the System hierarchy ;)
20:47:14 <gwern> haskell is too restricted
20:47:21 <gwern> how do you do 'c++ foo.cx' in the shell?
20:47:53 <gwern> I'll give you a hint, 'run "c++ foo.cx"' is not an acceptable answer :)
20:49:02 <Saizan> cpp "foo.cx" would already be quite acceptable, c++ foo.cx would require some sophisticated parsing, but could be done
20:49:13 <FunctorSalad> don't get me wrong, if I went into a "real men's" channel like these and started preaching, I could understand someone saying "bs"
20:49:30 <FunctorSalad> but come on, basic lambda, and because I actually needed it many times...
20:49:44 <gwern> Saizan: and once you've started the sophisticated parsing to take 'c++', why not go further
20:50:08 <Saizan> gwern: further where?
20:50:28 <gwern> to not need quotes around args, eg.
20:50:39 <Saizan> (c++ wouldn't be the hard part, making foo.cx parse as a string literal would)
20:50:48 <gwern> mandatory spaces around infix operators, so you parse 'gnome-volume-control' the right way
20:51:01 <gwern> and so on
20:51:12 <FunctorSalad> btw another kinda-lambda would be to just bash -c and use the pos parameters as the bound vars, I suppose
20:51:14 <Saizan> i thought "c++ foo.cx" example already covered both of those :)
20:51:58 <gwern> just executable names force a lot of syntax changes
20:52:45 <FunctorSalad> "<gwern> haskell is too restricted" <-- yes, I'm thinking about a new syntax too
20:52:47 <Saizan> btw, i don't mean to push this into haskell, it'd be horrible in a proper language
20:52:53 <FunctorSalad> without really making haskell unsafe
20:53:47 <FunctorSalad> maybe just quote the *haskell*?
20:54:12 <FunctorSalad> I mean, everything would desugar to a haskell program, but it'd look like a shell prog with embedded haskell
20:54:37 <Saizan> mh, could work
20:54:52 --- mode: ChanServ set +b palomer!*@*
20:54:52 --- kick: palomer was kicked by ChanServ (User is banned from this channel)
20:55:06 <Axman6> heh
20:56:03 <Saizan> and the haskell could have embedded shell :)
20:56:19 <FunctorSalad> hmm his ban was decided in the smoke-filled backroom? :o
20:56:29 <gwern> FunctorSalad: that's a sensible approach
20:56:29 <gwern> but as ever the devil is in the details
20:56:31 <FunctorSalad> by the cabal cabal or something
20:56:35 <danharaj> God damned celtics.
20:56:44 <danharaj> Their basketball is as shoddy as Ruby programming.
20:56:50 <gwern> FunctorSalad: I'm more interested in that he got back in
20:56:54 <gwern> not much of a bam
20:57:45 <Saizan> (topic
20:58:03 <FunctorSalad> I guess you'd want a haskell-splice-into-one-word and same into many words, as  a start
20:58:08 <FunctorSalad> like lisp's , vs. ,@
20:58:39 <FunctorSalad> the former would have to produce an IO a, the latter IO [a], a showable
20:59:13 <FunctorSalad> though you'd want to avoid string serialization/deserializations if both the function and the splice are actually haskell
21:00:34 <gwern> the problem with haskell as a shell is that the task looks so big and intimidating
21:01:16 <blackdog> danharaj: why you gotta be a hater? maybe in that project, it makes sense to monkeypatch to make 1 + 1 == 'banana'
21:01:35 <FunctorSalad> gwern: hmm does it? the core seems simple enough, and commands could be added as you go
21:01:56 <gwern> FunctorSalad: oh, you can hack something together easily enough
21:02:09 <gwern> FunctorSalad: no shortage of primitive haskell shells
21:02:26 <gwern> but something as conceptually good and solid as xmonad?
21:02:31 * FunctorSalad has only found hashell, and it's bitrotten
21:02:59 <gwern> I mean, we even have a shell framework
21:03:10 <gwern> shellac
21:03:19 <FunctorSalad> yeah, didn't count it
21:05:52 <FunctorSalad> gwern: hmm haven't thought about the design issues for a serious system shell like bash is
21:06:09 <FunctorSalad> just a syntax for haskell that's more convenient for what you do with bash
21:07:05 <Jafet> The last thing you want to do is invent a strongly typed bash. Imagine how more annoying that would be compared to the already annoying bash
21:07:39 <ezyang> I mean, you might argue that shell scripting is annoying precisely because it isn't typed. 
21:07:52 <ezyang> Who came up with the abominations of sed and awk? 
21:07:53 <cdsmithus> Jafet: sorry if I missed context here... but, I use GHCi for essentially shell-script level tasks all the time.
21:08:08 <FunctorSalad> the types would be great for longer scripts. I don't care about them much on the commandline
21:08:30 <FunctorSalad> where any advantage of staticality is lost
21:09:16 <FunctorSalad> but even without types, haskell is still handy
21:10:08 <FunctorSalad> ezyang: sed isn't bad
21:10:24 * ezyang shudders 
21:10:30 <FunctorSalad> it's intentionally as concise at possible
21:10:57 <cdsmithus> Hmmm, I've been waiting 2 hours for GHC to finish linking the HTTP package... :(
21:10:59 <gwern> with interpreters, compiletime is runtime
21:11:00 <ezyang> I guess it would work better for me if it actually resembled regexes 
21:11:03 <FunctorSalad> (I've only ever used oneliners, mind you)
21:11:19 <Jafet> I wish sed could be more concise!
21:11:23 <FunctorSalad> ? sed consists of perfectly cromulent posix regexes
21:11:31 <FunctorSalad> in certain positions I mean
21:11:31 <Jafet> Their calculator scripts are so verbose
21:11:47 <FunctorSalad> (line address specifications, and the args to s)
21:12:10 <FunctorSalad> (and you get extended regexes with -E, which cuts down on the \madness)
21:12:21 <cdsmithus> Any reason the linker would require a LOT more memory with GHC 6.12 versus 6.10?
21:13:03 <FunctorSalad> ezyang: e.g. sed -Ee 's/regex1/regex2/'
21:13:11 <blackh> cdsmithus: You could try gold.  It SEGV'd for me on Ubuntu 10.04 though so I had to switch back to ld.
21:13:27 <FunctorSalad> or '/regex/d' as an example of a line address
21:13:31 <blackh> cdsmithus: gold is excellent and has (in the past) worked with GHC
21:13:39 <cdsmithus> blackh: Oh, this is Ubuntu 10.4, though! Hmm...
21:13:45 <FunctorSalad> (most commands take an address or two)
21:13:57 <blackh> cdsmithus: It may be ghc 6.12 that gold doesn't work with - not sure which.
21:14:09 <blackh> Actually the resulting executable segvs.
21:14:14 <cdsmithus> Ah
21:14:15 <FunctorSalad> (the d deletes the matching line)
21:14:16 <blackh> It might have been fixed.
21:14:25 <blackh> I tried with ghc 6.12.1
21:14:38 <blackh> Anyway, if you can make it go, gold is great - it's *much* faster and uses a lot less memory than ld.
21:14:39 <FunctorSalad> actually I once considered a Sed monad for haskell ;)
21:14:47 <cdsmithus> That sounds hard.  Maybe I'll leave it linking all night. :)
21:15:04 <FunctorSalad> s :: Regex -> Regex -> Sed ()
21:15:13 <FunctorSalad> hmm or maybe it should return something
21:15:27 <absentia> nice... patch applied (ghc): Add new LLVM code generator to GHC. (Version 2)
21:15:31 <cdsmithus> Oh wait... it's just linking Setup.lhs.... wow
21:16:31 <blackh> cdsmithus: All I did was 'sudo apt-get install gold' and everything worked, then it broke later
21:16:33 <FunctorSalad> you'd want to modify 's' into something that returns the captures as the monadic value, I suppose
21:16:39 <FunctorSalad> then you can do whatever you want with them
21:16:43 <cdsmithus> Okay, I'll give it a shot
21:17:48 <blackh> cdsmithus: I was using a virtual server (Linode) with 300 M and my application is huge with 120 files in it.
21:18:03 <danharaj> I think we should add something like monkey patching to Haskell
21:18:11 <danharaj> except when GHC detects it, it deletes your harddrive instead.
21:18:18 <FunctorSalad> Sed would be something similar to a lazy parsing monad plus [string] writer, I think
21:18:35 <FunctorSalad> (parsing without backtracking)
21:18:49 <cdsmithus> Linking Setup ...
21:18:51 <cdsmithus> Trace/breakpoint trap
21:18:55 <cdsmithus> Darn.  worth a shot though
21:19:01 <FunctorSalad> or at least I think sed never does backtracking
21:19:05 <FunctorSalad> (on the line level)
21:19:41 * hackagebot heist 0.2.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.2.1 (DougBeardsley)
21:21:33 <cdsmithus> Hmm... that still seems like a fairly major regression.  I know no one uses cmputers with 512 MB of RAM any more, but GHC 6.10 was usable, and GHC 6.12 is not. :(
21:23:46 <FunctorSalad> "As soon as GHC plus its “fellow citizens” (other processes on your machine) start using more than the real memory on your machine, and the machine starts “thrashing,” the party is over."
21:43:58 <BMeph> Regexps are like a slave, begging his master for more of the whip.
21:51:37 <Jafet> Other way round, human!
21:51:38 <kniu> type mismatch: expected "A regexp", got "Regexps"
21:52:00 <Niccus> regexes are into s&m?
22:38:25 <fhobia> is there a way to specify numbers in binary in haskell?
22:42:13 <dons> fhobia: only indirectly.
22:45:20 <Axman6> o/ dons 
22:45:32 <Axman6> did you get me message from lambdabot?
22:46:23 <peter__> i'm encountering a problem when uninstalling winhugs
22:46:40 <peter__> is this problem solved?
22:47:00 <peter__> the uninstaller is for a 16bit machine
22:50:59 <sshc> How do I see which cabal packages I have installed?
22:51:29 <sshc> I plan to include a script that downloads and installs these packages on a live cd.
22:52:17 <aavogt> you can get something from ghc-pkg list
22:53:10 <aavogt> though that doesn't say which ones are only required as dependencies... perhaps cabal install is smart enough to notice that redundancy
22:53:24 <sshc> aavogt: Can I install each of these in a local directory?
22:54:29 <aavogt> there are only a couple files ghc looks at to check where libraries might be installed
22:55:25 <peter__> does anyone know how to uninstall winhugs?
23:24:55 <ski> Saizan_ : only read a little bit about it ..
23:32:31 <Saizan_> ski: ah, ok, i'm a bit puzzled by it not being able to solve a constraint like "X1 X = app X Y" but i don't know much about higher order unification
23:33:38 <ski> `X1' is uninstantiated there ?
23:34:30 <ski> it seems to me it should have solutions `X1 = _ \ app X Y' as well as `X1 = X \ app X Y', at least (iirc the syntax for abstractions correctly)
23:35:47 <Saizan_> yeah, it's uninstantiated
23:37:40 <ski> (but depending on whether `X' and `Y' can be related, there can be more solutions .. perhaps it just doesn't like this (probably) incomplete situation ?)
23:37:55 <ski> what is the context ?
23:39:18 <napping> That should match
23:40:01 <napping> wait, open terms might be a problem
23:40:13 <Saizan_> the LF context?
23:40:43 <napping> What if you try to match X Y \ X1 X = X Y \ map X Y
23:40:49 <ski> yes, in what problem you're trying to solve does this `X1 X = app X Y' unification problem occur ?
23:41:49 <napping> I haven't found much good information either, but I have seen a variety of things recently that claim various restricted problems are more tractable
23:42:19 <napping> And one case is "higher order matching", which seems to mean at least one side is a closed term
23:42:20 <ski> (Saizan_ : .. iow, where are the variables in the query bound, and are they bound using universal or existential (or abstraction) ?)
23:42:37 <ski> napping : L-lambda unification, i think
23:42:55 <napping> Pity conal left, his thesis was on this stuff.
23:43:06 <ski> (.. is one restriced problem which is tractable)
23:43:37 <napping> So, has anyone used Lava?
23:43:38 <Saizan_> term : type. app : term -> term -> type. eq : term -> term -> type. refl : eq X X.
23:43:46 * ski mostly knows about L-lambda unification from lambdaProlog
23:43:56 <Saizan_> %solve eq (X1 X) (app X Y).
23:44:12 <lpsmith> ok, how do I set my .cabal/config up to track a version of the documentation index for each version of GHC i have installed?
23:44:18 <Saizan_> so existential, like in a prolog query
23:44:26 <ski> Saizan_ : try universally quantifying the query over `X'
23:44:39 <napping> Ah, I think I see the problem - what if X contained occurences of Y?
23:44:55 <ski> napping : see above :)
23:45:38 <napping> that's not an explanation
23:45:56 <Saizan_> mh, i wonder what the syntax is for that :)
23:46:22 <ski> napping : hm, actually, i misread you as saying "what if Y contained occurences of X", sorry
23:46:44 <ski> (please elaborate on your thought)
23:47:25 <napping> If Y is existentially bound, you might worry that it contained occurances of a free X
23:47:56 <napping> Make up some syntax like Y^X to abstract over it, and you can say X1 = \v -> map v Y^X(v)
23:47:57 <Saizan_> ski: ok, universally quantifying over X works :)
23:48:20 <Saizan_> btw, lambda abstraction is [x] ..
23:48:33 <Saizan_> i.e. the identity function is [x] x
23:48:47 <napping> If you treat Y like a free variable and worry that X might contain occurances of it, there might be no way to construct a X1 that digs it back out
23:49:21 <ski> ok
23:49:35 <J-roen> :r
23:49:43 <J-roen> Sorry, did it again...
23:50:46 <kmc> Ok, modules loaded: Main.
23:50:55 <J-roen> :D
23:51:08 <ski> napping : hm, `Y^X' being `Y' abstracted wrt `X', or vice versa ?
23:54:19 <napping> that's supposed to be abstracting Y over X
