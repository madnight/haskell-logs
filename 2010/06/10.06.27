00:00:43 <ddarius> dancor: Oh, to answer your earlier question, it is called strength in category theory.
00:01:09 <ddarius> (or a strength, usually it is called σ)
00:05:21 <calbert> What are my options for typing a variable length list, for which I want the length to be part of the type or data?
00:06:18 <calbert> Something like Word8, Word16, etc; but with them all under some sort of umbrella type?
00:06:28 * hackagebot graph-utils 0.3.6 - A simple wrapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.6 (HiromiIshii)
00:06:51 <ddarius> Hiromi's name reminds me of a girl I met named Hitomi.
00:07:23 <ivanm> calbert: there's the integral class, but that's about it AFAIK
00:08:09 <Jafet> I think he means something like data (Num n) => ListWithLength a n = ListWithLength n [a]
00:08:18 <Jafet> s/Num/Integral/
00:08:37 <calbert> But can I specify that the list must have that length somehow?
00:08:41 <Jafet> And whatever else needs to be changed to make that compile
00:08:58 <Axman6> only if your functions do, and you don't export the constructor
00:09:04 <Jafet> calbert, you would hide the actual constructor and make all functions of ListWithLength enforce it
00:09:13 <calbert> Ah.
00:09:15 <calbert> That I can do.
00:09:16 <calbert> Cool.
00:09:17 <calbert> Thank you.
00:11:12 <Saizan> alexyk: it does get in the HEAD first, from the ticket it seems like that'd happen after JaffaCake reviews the new patches
00:14:10 <kamatsu> hm
00:14:22 <kamatsu> maybe i should write a compiler for a logic language into haskell type system?
00:14:45 <kamatsu> it seems like haskell has a pretty decent first-order logic language in its type system 
00:15:04 <ddarius> It's actually a kind of crappy first-order logic language, but it is a logic language indeed.
00:15:20 <kamatsu> how is it crappy, aside from syntactically?
00:15:31 <ddarius> It's quite a bit more restricted than Prolog.
00:15:41 <kamatsu> termination?
00:15:54 <ddarius> Not just that.
00:16:02 <ddarius> It has to be deterministic for the most part.
00:16:09 <kamatsu> ah, true
00:16:30 <kamatsu> hm
00:17:15 <kamatsu> i wonder if there is a way to trick the type checker
00:17:27 <ddarius> It's interesting that C++ has a pure, lazy functional language in its type system and Haskell has a deterministic logic language (though type families add a functional language)
00:17:30 <wli> What kinds of nondeterminism are bad? Hmm.
00:18:45 <wli> I guess overlapping instances gives some nastiness.
00:19:52 <kamatsu> if we could make constraints more powerful (constraint families) i would be completely happy with Haskell's type system for day to day use
00:20:26 <ddarius> kamatsu: Did you look at the Chameleon paper I mentionded a couple of weeks ago?
00:20:32 <kamatsu> I mentioned it to TacticalGrace ages ago and he said that the idea had been tossed around alot but no one has really investigated all the edge cases.
00:20:47 <kamatsu> nope? link?
00:21:33 <ddarius> kamatsu: http://www.itu.dk/people/masu/chameleon/download/haskell.html#fds  Also check out the rest of that page.
00:21:33 * hackagebot speculation 0.0.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.0.0 (EdwardKmett)
00:22:02 <edwardk> now that that is out there, i need benchmarks, to convince people to use it ;)
00:22:35 <ddarius> edwardk: Have you even done a microbenchmark to show (to yourself) that it improves anything at all?
00:23:06 <edwardk> ddarius: a little one off a few versions back, that isn't compatible with the current api, but yeah
00:23:31 <edwardk> i did a quick test like 2-3 weeks back when the paper in question came up on reddit
00:24:08 <ddarius> I was surprised that no one responded to you one way or another.
00:24:16 <edwardk> yeah
00:25:59 <edwardk> now i need to figure out generic versions of specFoldl' and specFoldr'
00:26:14 <edwardk> i can't just use the usual foldl' in terms of foldr trick
00:26:38 <edwardk> because the resulting intermediate values are functions, and hence, incomparable
00:27:25 <Axman6> huh, i wonder what's wrong with my code
00:29:07 <Axman6> can anyone see why i would be getting the error here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26598#a26598
00:30:11 <Axman6> the two versions of the code i wrote after that one were based on it, and they work fine, and this one used to o.O
00:30:12 <ddarius> edwardk: Perhaps add a WithoutSpeculation newtype (?)
00:30:51 <edwardk> ddarius: ah that just does what i do with Maybe?
00:32:00 <edwardk> i'll add a WrappedFoldable and something for despeculating
00:33:43 <Axman6> no one can see why i might be getting this error with this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26598#a26598
00:34:06 <ddarius> edwardk: Yes.
00:36:07 <ddarius> edwardk: Are there any generic predictors or perhaps predictor combinators you could add?
00:37:52 <edwardk> ddarius: not sure, they are very much specialized to your particular problem domain
00:40:08 <keep_learning> kindly tell me what is wrong with this code filter ((/=0).mod 2) [1..10] . I am trying to do some thing similar to filter (\x-> mod x 2/=0) [1..10] 
00:40:27 <keep_learning> what is wrong is with function composition
00:40:31 * ddarius wonders if a probability monad could be used in a predictor function "compiler"
00:40:35 <Axman6> > map (mod 2) [1..10]
00:40:36 <lambdabot>   [0,0,2,2,2,2,2,2,2,2]
00:40:43 <Axman6> > map (`mod` 2) [1..10]
00:40:44 <lambdabot>   [1,0,1,0,1,0,1,0,1,0]
00:40:52 <edwardk> ddarius: hrmm
00:41:11 <Axman6> keep_learning: also, ((/=0).(`mod` 2)) == odd
00:41:24 <Axman6> filter odd [1..10]
00:41:27 <Axman6> > filter odd [1..10]
00:41:28 <lambdabot>   [1,3,5,7,9]
00:42:58 <Axman6> @src odd
00:42:59 <lambdabot> odd = not . even
00:43:21 <Axman6> @src even
00:43:22 <lambdabot> even n = n `rem` 2 == 0
00:43:34 <c_wraith> aww, I wanted it to be not . odd
00:43:41 <chrisdone> what's rem?
00:43:46 <c_wraith> remainder.
00:43:48 <Axman6> @src (==)
00:43:49 <lambdabot> x == y = not (x /= y)
00:43:52 <chrisdone> ah
00:43:56 <Axman6> @src (/=)
00:43:57 <lambdabot> x /= y = not (x == y)
00:44:13 <c_wraith> It's specified in a way such that it matches modern hardware, so it tends to be faster than mod.
00:44:25 <c_wraith> at least for types that are implemented as primitives
00:44:26 <chrisdone> ah nice
00:44:34 * Axman6 didn't know that
00:44:48 <chrisdone> Haskell optimisation tips 24/7 in the #haskell IRC channel!
00:45:22 <TimB1> perhaps someone can help a Java->Haskell newbie?
00:45:26 <Axman6> they do give different results however
00:45:35 <Axman6> TimB1: not if we don't know the problem
00:46:02 <c_wraith> yes, rem and mod are different.  Be sure you know which you want, and only use rem if it's actually correct :)
00:46:15 <TimB1> when programming GUIs, there is often a selection of objects with different types, e.g. in a Tree
00:46:19 <edwardk> ddarius: added and uploading
00:46:37 <TimB1> how is this problem solved in Haskell?
00:46:56 <Axman6> by making a tree type? i'm not sure i understand the question
00:47:00 <c_wraith> TimB1, generally with an Algebraic Datatype
00:47:40 <Axman6> data Tree a = Node a [Tree a]
00:47:47 <c_wraith> axman, the question was "how do you do polymorphism between various control types"
00:47:47 * hackagebot speculation 0.0.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.0.1 (EdwardKmett)
00:48:01 <c_wraith> you kind of have to read between the lines to see the question, though. :)
00:48:02 * ddarius recommends http://research.microsoft.com/en-us/um/people/daan/download/papers/divmodnote.pdf 
00:48:08 * Axman6 doesn't deal with GUIs
00:49:24 <edwardk> i even armwrestled into place the Typeable/Data instances for them
00:49:35 <ddarius> TimB1: If you are talking about something like a control tree (e.g. window contains panels contains textfields) then by providing a uniform interface (like the Control class in C#) you can just make a tree.
00:50:26 <edwardk> hrmm i suppose i should expose another version of spec that just assumes its RHS is unevaluated. spec' ?
00:50:34 <edwardk> that'll speed up the specFolds a bit
00:50:50 * Axman6 would really appreciate some help with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26598#a26598 :(
00:51:34 <Axman6> i don't use V.head or V.tail without first checking if the vector is null :(
00:52:30 <ddarius> Axman6: Yes you do.
00:52:36 <ddarius> Axman6: ETOOMANYBANGS
00:52:44 <Axman6> heh, yeah
00:53:08 <ddarius> If you remove the ! on y, t, and c', it will work.
00:53:28 <Axman6> ah right, of course
00:55:25 <ddarius> Axman6: Also, trust GHC to get the easy stuff and only worry about the stuff that could actually cause a problem.
00:56:48 <ddarius> So, for example, you don't need the ! on vec because it is always forced.  Given the ! on c', you don't need one on t and y.  (But in this case you don't want it on c'.)
00:57:49 * hackagebot graph-utils 0.3.6.1 - A simple wrapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.6.1 (HiromiIshii)
00:58:11 <ddarius> If you push the where into a let in the second guarded expression, then you should only need a ! on sm and c.
00:58:34 <Axman6> the thing is, that if the compiler is too smart for its own good, c will always be zero, because algebraically it is
01:01:04 <ddarius> Axman6: Then either that's fine and a great optimization or it changes semantics and thus won't be done.
01:01:57 <Axman6> well its not fine, this algorithm is designed to reduce computation errors, and making that assumption voids the point of the algorithm
01:02:19 <elitheeli> Hey, so is there a trick to getting :break to work in GHCi? I just installed the latest haskell binary build for Mac, GHCi v 6.4.1, when I run :break it says unknown command.
01:02:31 <ddarius> Axman6: If making that assumption doesn't change the output, then it's fine.  If making that assumption does, then it won't be made.
01:02:57 <Axman6> elitheeli: uh, that's nowhere near the lastest version. we're up to 6.12.3 at the moment, and there is a MAc version
01:03:05 <elitheeli> how do I update to that
01:03:26 <elitheeli> I literally just reinstalled all of the haskell stuff to try to update to the latest
01:03:35 <Axman6> http://darcs.haskell.org/download/download_ghc_6_12_3.html#macosxintel
01:03:47 <Axman6> where did you get it from?
01:04:03 <ddarius> Use this: http://hackage.haskell.org/platform/mac.html
01:04:04 <Axman6> because that is an extremely old version of GHC
01:04:28 <elitheeli> that's a good question
01:04:41 <ddarius> Unless you -really- need the absolute latest version of GHC.
01:04:55 <elitheeli> ddarius: I *want* something that has :break in it
01:05:08 <Twey> Hehe, 6.4.1
01:05:12 <ddarius> Then use the Platform described in my link.
01:05:25 <elitheeli> better than the darcs.haskell.org one?
01:05:35 <Axman6> when i started using using haskell two and a half years ago, 6.6.x was the latest version
01:05:47 <Axman6> i think, possibly 6.8
01:05:55 <elitheeli> interesting
01:06:01 <elitheeli> I must have found a very old link
01:06:13 <ddarius> elitheeli: It's slightly older (6.12.1) but it is guaranteed to work with the collection of libraries in the Platform.
01:06:22 <elitheeli> sounds good
01:06:51 <ddarius> When I started using Haskell 5.4 was about to be released.
01:07:47 <edwardk> ddarius:  bug in the version of specFoldr' in hackage. i'll upload the fix after i get done drawing pretty diagrams for how spec g f a works
01:07:51 * Axman6 is really curious where elitheeli managed to find something so old
01:08:00 <elitheeli> lemme try to find where that was
01:08:11 <ddarius> edwardk: Are your diagrams going to be much different from the ones in the paper?
01:08:15 <edwardk> nah
01:08:20 <edwardk> just ascii art versions
01:08:33 <elitheeli> Axman6: somehow I ended up here: http://www.haskell.org/ghc/download_ghc_681.html#macosxintel
01:08:42 <elitheeli> not exactly sure why I didn't notice the date
01:08:45 <elitheeli> or how I got there
01:09:00 <c_wraith> that's still newer than 6.4
01:09:20 <c_wraith> was that just a typo?
01:09:21 <elitheeli> yes it would seem that way
01:09:24 <elitheeli> nope
01:09:28 <elitheeli> Glasgow Haskell Compiler, Version 6.4.1, for Haskell 98, compiled by GHC version 6.4.1
01:09:54 <ddarius> Ah, bootstrapping, how we love you so.
01:10:20 <elitheeli> wait -- where does Haskell install itself to? When I $ where ghc, I get /usr/bin/ghc and /usr/local/bin/ghc
01:10:38 <Axman6> the platform installs in /usr/bin
01:10:40 <ddarius> It depends on how you install it.
01:11:42 <edwardk> it'd be nice to add something that calculated the hit rate of a given speculator and turned it on or off based on time savings
01:12:36 * ddarius really needs to stop knitting for tonight (or this morning technically.)
01:15:58 <elitheeli> ddarius: there's a ton of ghc stuff in /usr/local/bin, can I just destroy that stuff?
01:16:38 <Axman6> well, run each ghc, and make sure you know which is the latest one
01:16:50 <elitheeli> yay, okay, I'm on 6.12 now
01:16:53 <elitheeli> thanks bugs
01:16:57 <elitheeli> by bugs I mean guys
01:17:02 <elitheeli> that's a weird typo
01:17:06 <elitheeli> I hope you guys aren't bugs
01:17:07 <elitheeli> goodnight
01:17:42 <Jafet> Haskell will survive nuclear war
01:18:00 <ddarius> edwardk: Is there a way you can do something like: data WithSpeculation f a = WithSpeculation (Int -> a) (f a); instance Speculative f => Foldable (WithSpeculation f) where foldr ... (WithSpeculation predictor f) = speculativeFoldr predictor f
01:18:23 <ddarius> I.e. to get speculation in existing Foldable algorithms.
01:18:37 <edwardk> hrmm
01:19:16 <edwardk> that is a rather interesting prospect
01:19:35 <edwardk> the problem is that guesses the element, not the sum
01:20:00 <edwardk> so it'd probably have to be tweaked a bit
01:20:55 * hackagebot speculation 0.0.2 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.0.2 (EdwardKmett)
01:22:15 <edwardk> er not sure it can be tweaked, sicne you're speculating the value of the fold to a point, not elements
01:22:32 <edwardk> and you don't know the type you'll be folded over with
01:23:34 <ddarius> Why a `seq` f a as opposed to f $! a
01:23:47 <edwardk> because i never think of $! =)
01:26:17 <Twey> :t foldr seq
01:26:18 <lambdabot> forall a b. b -> [a] -> b
01:26:51 <Axman6> > foldr seq () [1..100]
01:26:52 <lambdabot>   ()
01:26:58 <Axman6> > foldr seq () [1..100000]
01:27:00 <lambdabot>   ()
01:27:02 <Axman6> > foldr seq () [1..100000000]
01:27:07 <lambdabot>   mueval-core: Time limit exceeded
01:27:39 <Jafet> > foldr (flip const) () [1..100000]
01:27:40 <lambdabot>   ()
01:28:03 <ddarius> > foldr (flip const) () [1..100000000]
01:28:06 <lambdabot>   mueval-core: Time limit exceeded
01:28:10 <ddarius> > foldr seq () [undefined]
01:28:11 <lambdabot>   *Exception: Prelude.undefined
01:28:17 <ddarius> > foldr (flip const) () [undefined]
01:28:18 <lambdabot>   ()
01:28:41 <Axman6> how do you specify which version of a hackage package you want to install?
01:28:56 <ddarius> Axman6: Just include the version number in the name, foobar-1.4
01:28:58 <Axman6> say i want a version less than 0.3
01:29:02 <Axman6> ah, cheers
01:29:26 <Saizan> "foo < 0.3" also works
01:29:53 <ddarius> as well as foo-1.* and all the other such notation you see in .cabal files presumably.
01:29:57 <Axman6> urgh, all the zeromq-haskell packages seem to be broken >_<
01:31:08 <Axman6> what a shame, i really wanted to play with it
01:31:23 <edwardk> i wonder if i can nicely adapt the cheesy speculative lexer from the paper
01:31:38 <ddarius> edwardk: To your crazy monoid thing you mean?
01:32:05 <edwardk> well, into an example of a speculative fold
01:32:15 <ddarius> I really need to read all of the paper and look at some of their predictors.
01:33:00 <edwardk> ddarius: page 11 or so has some motivating benchmarks
01:36:48 * ddarius goes to bed.
01:36:49 <edwardk> it would also be interesting to play with abuses of STM 
01:36:56 <edwardk> i.e. to obtain the rollback semantics of the paper
01:37:27 <edwardk> speculate with the guess, but in the check compare the guess to the argument, and retry with the actual argument if they fail
01:52:47 <andreo> there is a function: fff :: String -> IO String
01:53:05 <andreo> How can i write: iterate fff "start"?
01:54:03 <c_wraith> you need iterateM
01:54:04 <edwardk> something like: iterate (fff >>) (return ())
01:54:08 <edwardk> or that
01:54:11 <c_wraith> @hoogle iterateM
01:54:12 <lambdabot> No results found
01:54:17 <c_wraith> ...  if it existed. :)
01:54:22 <andreo> thank you
01:54:41 <edwardk> @type \f -> iterate (f >=>) 
01:54:42 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> (a -> m c) -> [a -> m c]
01:54:50 <edwardk> er nope
01:55:05 <Saizan> ?ty \f -> sequence_ . iterate (f =<<) . return
01:55:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m a) -> a -> m ()
01:55:15 <andreo> iterateM does not exist :(
01:56:08 <c_wraith> iterateM is pretty trivial to write yourself.
01:56:10 <Saizan> mh, sequence_ has a fairly weird type when applied to an infinite list
01:56:22 <edwardk> hrmm i should rethink specSTM, right now if anything causes the transaction to rollback it'll retry with the original value
01:56:34 <andreo> c_wraith: all Data.List functions are trivial :)
01:58:53 <edwardk> @type let iterateM f a = do a' <- f a; liftM (a':) (iterateM f a')
01:58:54 <lambdabot> <no location info>:
01:58:55 <lambdabot>     not an expression: `let iterateM f a = do a' <- f a; liftM (a':) (iterateM f a')'
01:59:14 <Saizan> ?ty \f -> sequence . iterate (f =<<) . return
01:59:15 <edwardk> @type let iterateM f a = do a' <- f a; liftM (a':) $ (iterateM f a') in iterateM
01:59:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m a) -> a -> m [a]
01:59:16 <lambdabot> forall t (m :: * -> *). (Monad m) => (t -> m t) -> t -> m [t]
01:59:34 <Saizan> though that's fairly useless/wasteful in IO
01:59:48 <Saizan> you'll never get to see the list :)
01:59:52 <edwardk> yep
02:00:07 <edwardk> that was going to be my next point. that a real iterateM should be done in an mlist
02:00:54 <c_wraith> heh.  I hadn't thought about monads where forever actually means forever.
02:01:34 <Saizan> instance Monad DeBeers where ..
02:01:41 <c_wraith> ok, I'm trying to decide if I don't understand the semantics MonadCatchIO is supposed to provide, or if Snap's instance for it is broken.
02:01:46 <edwardk> another option would be for iterateM to return [m t] -- where each item in the list is an action that repeats your action n times
02:02:00 <edwardk> ?ty \f -> iterate (f =<<) . return
02:02:01 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
02:02:15 <edwardk> that is then well posed
02:02:33 <c_wraith> bracket should *always* execute its cleanup action, right?
02:02:58 <c_wraith> The generalization MonadCatchIO provides shouldn't invalidate that?
02:03:11 <Saizan> oh, my sequence thing actually duplicated the effects, right? i wasn't paying attention to that.
02:03:21 <edwardk> gah does anyone know if catchSTM rolls back?
02:03:41 <edwardk> Saizan: yeah hence my slightly more careful version
02:05:14 <c_wraith> Hrm.  Looks like bracket's docs in MonadCatchIO only refer to Control.Exception.
02:06:10 <c_wraith> And Control.Exception's bracket isn't actually explicit that the cleanup action will always be called.  Though it implies it.
02:06:35 <Saizan> c_wraith: i'd protest if it doesn't
02:06:53 <c_wraith> I think Snap's instance is broken.  But it's not clear to me why, so far.
02:07:34 <c_wraith> Part of the complication is that MonadCatchIO implements bracket in terms of catch.
02:08:12 <Saizan> it's hard to spot from the code?
02:08:40 <c_wraith> Oh, there's the problem.
02:08:48 <c_wraith> MonadCatchIO's code is actually wrong.
02:09:00 <c_wraith> The way it implements bracket doesn't work.
02:09:10 <c_wraith> http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/0.2.2.0/doc/html/src/Control-Monad-CatchIO.html#bracket
02:10:00 <c_wraith> That will run the handler if an exception is thrown
02:10:37 <c_wraith> It won't necessarily run the "after" action if an exception isn't thrown, because >>= isn't guaranteed to work that way.
02:10:51 <c_wraith> ick.
02:11:26 <Saizan> you got a fairly weird >>= :)
02:11:39 <c_wraith> Not really.  MaybeT suffices.
02:11:51 <c_wraith> Well, MaybeT IO suffices
02:12:00 <Saizan> yeah, two levels of "exceptions" though
02:12:14 <Saizan> with catch catching only one
02:12:28 <Peaker> Yeah that doesn't sound wrong
02:13:12 <c_wraith> yeah, there are too many error cases.
02:13:20 <Peaker> is there any way for bracket to guarantee the "after" runs?
02:13:40 <c_wraith> Not if it's implemented in terms of catch.
02:13:46 <c_wraith> It would have to be added to the typeclass
02:13:57 <edwardk> hrmm. i can catch an error in STM, but how do i throw one?
02:14:15 <edwardk> i was able to catch a 'fail' but i don't see a throwSTM for arbitrary exceptions
02:14:30 <c_wraith> Where instances of it could have access to the monad transformer internals.
02:15:07 <c_wraith> it's still possible it might not be implementable
02:15:19 <c_wraith> For some monad transformers, anyway
02:15:46 <Peaker> is there a transformer for STM?
02:15:48 <Saizan> i think i'd use it like "bracket before after (tryMaybe action) >>= maybe mzero return"
02:16:02 <Peaker> I guess that would destroy its point
02:17:20 <chrisdone> transformer to what?
02:19:03 <Peaker> Yeah, it would defeat the point, nm :)
02:20:02 <c_wraith> Heh.  the MonadCatchIO package provides an instance for "MonadCatchIO m => MonadCatchIO (MaybeT m)"
02:20:20 <c_wraith> Somebody really didn't think through what "bracket" should do.
02:20:58 <chrisdone> @hoogle bracket
02:20:58 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:20:58 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:20:58 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:21:11 <chrisdone> c_wraith: is bracket part of the MonadCatchIO class?
02:21:26 <c_wraith> No, the class has block, unblock, and catch
02:21:46 <c_wraith> But you can't implement bracket from those, for arbitrarily transformed IO
02:33:07 <c_wraith> I'm not sure bracket makes any sense in general anyway...  ListT IO?  Wouldn't this try to do the after action 0+ times for each init?
02:33:18 <c_wraith> err, for each before?
02:36:05 <c_wraith> It seems like bracket almost deserves its own typeclass.  MonadBracketIO. :)
02:37:07 <Saizan> or, you define a semantics that doesn't conflict with backtracking/escaping transformers and then you've to be careful when you use it
02:38:05 <c_wraith> At the very least, the documentation for it should warn that the current version doesn't work with any transformers that don't have linear control flow.
02:38:44 <c_wraith> well, that *bracket* doesn't work without that.  I think everything else in the library is fine as-is.
02:39:20 <Saizan> yeah, where "doesn't work" means it doesn't try to be smart about that
02:39:29 <Saizan> finally is the same, off course
02:39:32 <c_wraith> yeah.
02:39:43 <c_wraith> I just did a check.  finally and bracket are potentially broken
02:39:47 <c_wraith> the rest are fine
02:40:01 <c_wraith> well, the three versions of bracket. :)
02:41:54 <Saizan> now i wonder when ListT IO's finally should run the after
02:42:11 <c_wraith> I don't know if there's a good answer for that.
02:44:06 <c_wraith> maybe when runListT returns?
02:45:41 <dobblego> I'm giving a talk on "How to get started with Haskell" tomorrow night -- in the list of literature, I intend, LYAH, YAHT and RWH -- anything else?
02:46:35 <c_wraith> @unmtl ListT IO Int
02:46:35 <Ke> Yet Another Haskell Tutorial?
02:46:36 <lambdabot> IO [Int]
02:47:31 * Saizan wouldn't recommend YAHT
02:47:36 <dobblego> Ke, yes I have that
02:47:41 <dobblego> Saizan, why come?
02:48:09 <Ke> dobblego: just checking my adaptive acronym decoding
02:48:42 <cwb> dobblego: Just literature or also other resources?
02:48:45 <Saizan> i found it fairly confusing and off the point in multiple places
02:48:57 <dobblego> cwb, anything that would help really
02:49:30 <cwb> dobblego: Consider including http://tryhaskell.org/
02:50:01 <dobblego> cwb, thanks
02:50:57 <Saizan> haskellwiki, part of the wikibook, all about monads, functional pearls maybe
02:56:42 <Phyx-> hmm, which books to take with me on vacation..
03:16:28 <triyo> Is there a neat way to do function composition when dealing with return types of Either?
03:17:10 <ivanm> triyo: using the either function?
03:17:17 <ivanm> or if you care about Right values only, use fmap
03:17:25 <ivanm> > fmap succ (Right 3)
03:17:26 <lambdabot>   Right 4
03:17:27 <ivanm> @type either
03:17:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:18:15 <c_wraith> @type (left, right)
03:18:16 <lambdabot> forall (a :: * -> * -> *) b c d (a1 :: * -> * -> *) b1 c1 d1. (ArrowChoice a, ArrowChoice a1) => (a b c -> a (Either b d) (Either c d), a1 b1 c1 -> a1 (Either d1 b1) (Either d1 c1))
03:19:06 <c_wraith> err, those were unreadable
03:19:30 <triyo> I see, thanks guys
03:20:13 <c_wraith> > left (+1) $ Right 5
03:20:15 <lambdabot>   Right 5
03:20:23 <c_wraith> > left (+1) $ Left 5
03:20:24 <lambdabot>   Left 6
03:20:55 <triyo> applicative could be used here too right?
03:21:02 <dobblego> yes
03:21:33 <chrisdone> dobblego: where are you doing your evangelism?
03:21:49 <dobblego> Brisbane Functional Programming Group
03:21:56 <triyo> great, I think I'm a grip on things slowly but surely 
03:21:57 <chrisdone> cool
03:22:11 <triyo> *getting a grip
03:22:29 * Saizan_ read that as evangelion, twice
03:22:43 <chrisdone> that's what i said
03:22:54 <chrisdone> :p
03:23:46 <ivanm> dobblego: so, you coming to AusHack?
03:23:59 * ivanm hasn't noticed dobblego's name as one of those that have registered...
03:25:15 <chrisdone> xmonad and compositing http://i.imgur.com/0EkBL.jpg -- awesome. the currently focused window is 100% opacity
03:25:21 <petermarks> If I have a type constructor Foo :: * -> * -> *, I can make Foo x and instance of Functor (provided it obeys the laws), but is there any way to make Foo with its second argument an instance of Functor? My arguments are in the wrong order, I want to partially apply Foo with its second argument to give me a * -> * constructor.
03:25:54 <Heffalump> petermarks: not without a newtype wrapper
03:26:01 <dobblego> ivanm, I won't be sorry -- I am having surgery again 12 July
03:26:07 <ivanm> chrisdone: is that xmonad or awesom, make up your mind! :p
03:26:11 <ivanm> dobblego: :(
03:26:15 <ivanm> in sydney?
03:26:20 <dobblego> no Brisbane
03:26:23 <ivanm> *nod*
03:26:28 <ivanm> what's this one for?
03:26:30 <chrisdone> ivanm: it's both xmonad and awesome :p
03:26:38 <dobblego> a reconstruction of my wrist, from squash
03:26:39 <petermarks> the problem with a newtype is that it leads to a lot of wrapping and unwrapping
03:26:45 <ivanm> chrisdone: why are you running two WMs?
03:26:48 <Heffalump> petermarks: agreed
03:26:55 <ivanm> dobblego: oh, so not the old problem? :p
03:26:57 <chrisdone> ivanm: i ain't
03:27:20 <dobblego> ivanm, no that is fixed -- a spinal injury that will take about a year to heal -- hence the desire to get the wrist injury done now
03:27:25 <chrisdone> @google xmonad inside gnome
03:27:27 <lambdabot> http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_in_Gnome
03:27:27 <lambdabot> Title: Xmonad/Using xmonad in Gnome - HaskellWiki
03:27:29 <ivanm> dobblego: *nod*
03:27:32 <petermarks> Heffalump: that makes me sad
03:27:59 <petermarks> thx
03:28:04 <ivanm> petermarks: well, there are limitations in every language unfortunately :s
03:28:39 <petermarks> I'll try the newtype and see how it goes
03:35:04 <Peaker> > succ . Right 3
03:35:05 <lambdabot>   Right 4
03:35:38 <benmachine> > Right <$> Right Right
03:35:40 <lambdabot>   Overlapping instances for GHC.Show.Show
03:35:40 <lambdabot>                              (b -> ...
03:35:42 <benmachine> aw
03:35:45 <benmachine> (obv)
03:35:55 <benmachine> > Right <$> Right Right ()
03:35:56 <lambdabot>   Couldn't match expected type `() -> f a'
03:35:56 <lambdabot>         against inferred type `Dat...
03:36:07 <Peaker> > Right . Right Right $ ()
03:36:08 <lambdabot>   Couldn't match expected type `a -> a1'
03:36:08 <lambdabot>         against inferred type `Data....
03:36:09 <benmachine> > Right <$> Right $ Right ()
03:36:10 <lambdabot>   Right (Right (Right ()))
03:36:17 <benmachine> > Right <$> Right (Right ())
03:36:19 <lambdabot>   Right (Right (Right ()))
03:36:37 <benmachine> > Left <$> Right (Right ())
03:36:38 <lambdabot>   Right (Left (Right ()))
03:36:48 <benmachine> what am I doing and why I can't really remember
03:40:27 <GatoGoshine> join
03:40:35 <GatoGoshine> hey
03:40:50 <GatoGoshine> i am new to IRC 
03:41:06 <GatoGoshine> any bod out ther 
03:41:29 <rrc7cz> can somebody give me an example of how they're using monads in a non-parsing, non-transforming context? I'm trying to think of a place (if any) they would be useful in your typical web/business app focused mostly on crud/validation/workflow
03:41:42 <Itkovian> GatoGoshine: Yes. But please, try to type English. IRC /= SMS
03:42:13 <Twey> rrc7cz: Ummm… IO?
03:42:34 <GatoGoshine>  English.IRC /=SMS
03:42:35 <Twey> Most of the popular Web frameworks are based entirely on a monad or two
03:42:56 <Twey> (e.g. Snap, Happstack)
03:43:02 <Twey> Mostly State
03:43:12 <GatoGoshine> itKovian
03:43:19 <GatoGoshine> ?
03:43:39 <benmachine> Itkovian: they missed a total of two letters and both of them were kinda phonetically superfluous :P
03:43:44 <rrc7cz> Twey: I'm still trying to wrap my head around why an IO monad is "safe". Right now I understand it as: you make side-effect free fns, then explicitely pass the state around. I understand why this is better than the implicit/hidden altering of global state
03:43:52 <benmachine> or at least not vital syllables
03:44:12 <Itkovian> benmachine: true
03:44:13 <dobblego> rrc7cz, the IO monad does nothing -- it's IO (the type constructor) that matters
03:44:15 <Itkovian> but still
03:44:15 <GatoGoshine> am i speaking english
03:44:30 <benmachine> GatoGoshine: yes
03:44:33 <Itkovian> GatoGoshine: rule #2. Don;t take people too seriously.
03:44:37 <benmachine> heheh
03:44:45 <benmachine> rrc7cz: Maybe is good for error propagation
03:44:55 <GatoGoshine> [:) 
03:45:23 <Twey> rrc7cz: The IO monad is a convenient way of constructing IO values, which are pure values that the runtime interprets as an impure, imperative program
03:45:25 <rrc7cz> I enjoy Brian Beckman's talks on the subject, explaining how they allow you to build these components and piece them together like Legos, but as I learn about them I can only see parsers/transformers/etc benefiting; I can't think of where is a typical crud/validating business app this would be useful
03:45:27 <GatoGoshine> yeah tel mwa  abt Haskell
03:45:47 <GatoGoshine> whai s it used for 
03:46:00 <rrc7cz> Twey: but how does this help anything?
03:46:17 <benmachine> rrc7cz: what do you mean by transformers, anyway?
03:46:29 <Twey> rrc7cz: It allows us to write pure code that ultimately has impure effects.
03:46:50 <rrc7cz> benmachine: mapping input to output, but having composable components, each providing a specific transformation
03:46:54 <Twey> rrc7cz: Maybe is also a popular example of a monad: it allows us to propagate an error condition down a series of computations
03:46:56 <benmachine> ah
03:47:06 <rrc7cz> benmachine: for example, being able to compose increment, decrement, square, etc
03:47:28 <rrc7cz> benmachine: of course you can do that with normal fun comp since the in and out have the same type sig
03:47:32 <benmachine> the thing about Monads is they allow you to define fairly general functions that then operate on all sorts of data types
03:47:32 <GatoGoshine> does any one know about  Haskell
03:47:33 <Twey> That's really more of a task for composition than monads.
03:47:38 <rrc7cz> benmachine: but that's kinda what I'm thinking of as transformers
03:48:03 <GatoGoshine> haskell any one?
03:48:10 <benmachine> rrc7cz: a composition of components that map input to output sounds like something I would call a "program"
03:48:23 <benmachine> i.e. goodness knows what else a programmer ever does
03:48:39 <benmachine> but maybe I am being pedantic :P
03:48:44 <benmachine> anyway I should be somewhere else
03:48:50 <benmachine> so I'll leave you to Twey
03:50:06 <c_wraith> Huh.  I tried to go to bed.  Then, as I was trying to relax and get to sleep, I realized where my infinite type error was coming from, got back up, and fixed it.
03:50:06 <Twey> benmachine: Multiple inputs ;)
03:50:18 <Twey> c_wraith: That's always fun ☺
03:52:15 <zygoloid> last night in my sleep i figured out a way to use a GADT and a rank-2 type to pass around an indexed collection of instances
03:52:27 <alexdong> I'm a haskell n00b. I'm reading the "Real World Haskell" book and trying out the examples. Will anyone here tell me why I get "wc.hs:77:4: parse error on input `where'" for following code? 
03:52:27 <alexdong> isPalindrome x
03:52:27 <alexdong>     | x == []       = True
03:52:28 <alexdong>     | length x == 1 = False
03:52:28 <alexdong>     | otherwise a == b && isPalindrome (init (tail x))
03:52:28 <alexdong>     where a = head x
03:52:29 <alexdong>           b = last x
03:52:31 <zygoloid> this morning i'm not sure i remember how it was supposed to work
03:52:51 <Saizan_> alexdong: don't paste code in channel in the future
03:53:04 <Saizan_> alexdong: use a site like hpaste.org or pastebin.com
03:53:07 <pastorn> @where paste
03:53:08 <lambdabot> http://hpaste.org/new
03:53:34 <zygoloid> alexdong: you're missing an = from the otherwise guard
03:53:43 <alexdong> @Saizan_ I tried to use hpaste but the indentation there doesn't look right. 
03:53:43 <lambdabot> Unknown command, try @list
03:53:56 <Saizan_> don't use @ either :)
03:54:03 <zygoloid> alexdong: otherwise is just a synonym for True, so it still needs an = after it.
03:54:14 <Saizan_> alexdong: that probably means you're using tabs, and you should avoid those.
03:54:37 <Saizan_> alexdong: you should set your editor so that it expands tabs to spaces
03:55:13 <alexdong> Saizan_, yes, I'm using vim and I've set tabs to spaces. I actually manually indent them in hpaste but it still doesn't look right. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26601
03:55:58 <alexdong> zygoloid, that works. fantastic.  That's so obvious when you point it out but ... 
03:56:46 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26601#a26602 <- maybe your browser screws up textareas? i don't know :)
03:57:49 <alexdong> no idea. 
04:01:34 <GatoGoshine> hey
04:01:42 <GatoGoshine> hey
04:03:13 * hackagebot speculation 0.1.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.1.0 (EdwardKmett)
04:03:18 <edwardk> hrmm i think i might remove the Speculative class, i don't actually have any hard to speculate containers so far. perhaps i can reintroduce it if i go to make a specFoldMap
04:04:04 <ivanm> edwardk: I'm reading through that description, and I'm still not sure what it means by "speculative parallelism"
04:04:05 <ivanm> :s
04:04:18 <GatoGoshine> i need a chanell where i can dicuss novice level haskell
04:04:45 <ivanm> GatoGoshine: this channel ;-)
04:05:09 <edwardk> ivanm: spec :: Eq a => a -> (a -> b) -> a -> b -- when you call spec g f a, it speculates that the value of a is g. then computes f g in parallel with forcing 'a', if you guessed right it gives you that answer, otherwise it computes f a
04:05:16 <ivanm> the other channels are either advanced, off-topic, or specialised for a particular library/framework/distribution/etc.
04:05:26 <GatoGoshine> whats is the msin purpose of haskell
04:05:30 <edwardk> so you gain parallelism by speculating on what the argument to the function will be
04:05:43 <ivanm> GatoGoshine: to program ;-)
04:06:12 <ivanm> edwardk: why not use == to test if they're equal?
04:06:32 <GatoGoshine> ok... give me task that haskell would be besfore
04:06:36 <chrisdone> that wouldn't be speculative
04:06:38 <edwardk> ivanm: i do -- after i compute f g. it may take a long time to evaluate the value of 'a'
04:06:52 <ivanm> or is a unevaluated, so whilst you're evaluating a you're evaluating "f g" just in case a == g ?
04:06:56 <edwardk> look at the diagram
04:07:00 <edwardk> its on the main page
04:07:20 <ivanm> *nod*
04:07:35 <ivanm> so best case is shorter, worst case is longer to using seq/deepseq?
04:07:36 <edwardk> the little boxy ascii art timelines might serve as a better description ;)
04:07:42 <GatoGoshine> *nod***...
04:07:48 <edwardk> yeah
04:08:11 <edwardk> the next trick is we then use this on arbitrary containers to compute folds with estimates
04:08:18 <GatoGoshine> i what to make haskell talk to flash 
04:08:27 <GatoGoshine> actionscript 
04:08:28 <ivanm> GatoGoshine: the main advantages of using Haskell is that you typically have a higher assurance of correctness in your code due to the purity and strong static typing with the same level of conciseness found in popular dynamic languages such as python
04:08:42 <ivanm> GatoGoshine: there is no actionscript or flash bindings for Haskell AFAIK
04:08:55 <ivanm> wait, I lie; there's an swf library
04:08:57 <ivanm> @hackage swf
04:08:57 <lambdabot> http://hackage.haskell.org/package/swf
04:08:57 <edwardk> GatoGoshine: then you're probably going to need to talk back and forth over a socket. there are no direct haskell <-> actionscript bindings
04:09:19 <ivanm> that appears to be for making swf files
04:09:45 <GatoGoshine> great now we are getting some where
04:10:06 <ivanm> well, yeah, but where are you wanting to go?
04:10:25 <ivanm> GatoGoshine: Haskell is turing complete, so you can theoretically write anything in it that you can write in other turing complete languages
04:10:48 <ivanm> there is no one specific field that it is primarily good for (like say R is good/designed for stats)
04:11:09 <ivanm> it also has a smaller selection of libraries than languages like Python or Perl, but it's getting there
04:11:49 <kdvh> Whats the format for using multiple type classes in the class constraint?
04:12:04 <ivanm> kdvh: (Foo a, Bar a) => ...
04:12:24 <kdvh> ivanm: thought so, wasnt sure, thanks
04:12:27 <ivanm> np
04:13:42 <GatoGoshine> ivanm that mean i could use hskl to compile swf at runtime
04:15:22 <GatoGoshine> ivanm  : can you explain turing complete 
04:16:01 <bremner> can compute anything that anything else (reasonable) can
04:16:35 <GatoGoshine> not clear
04:17:09 <bremner> well, try wikipedia then
04:17:53 <GatoGoshine> is "turning complete" a standard concept ? 
04:18:03 <ivanm> GatoGoshine: if you want to convert Haskell code into swf code, then you need to write your own Haskell ->swf transformation program/library/compiler backend
04:18:16 <bremner> GatoGoshine: yes, if you spell it correctly
04:18:31 <ivanm> if you just want a DSL to generate swf, then that's a lot easier
04:18:32 <bremner> see also, Alan Turing, famous homosexual.
04:18:51 <ivanm> bremner: well, he's not famous for being a homosexual
04:19:15 <bremner> he is a bit, but OK, I was trolling a bit.
04:19:21 <ivanm> that's like saying Putin is a famous ABBA fan ;-)
04:19:31 <Jafet> "Are you Turing-hard?"
04:19:40 * ivanm changes his example at the last minute to avoid invoking Godwin's Law
04:19:51 <bremner> a painter?
04:20:29 <bremner> GatoGoshine: 1) don't PM me. 2) none of your business.
04:20:31 <ivanm> yeah, I was trying to avoid that wannabe artist
04:20:35 <Jafet> bremner, a devout teetotaler!
04:20:36 <tensorpudding> Turing is famous for being a homosexual because it factored in somewhat in his suicide
04:20:48 <Jafet> Unlike his gin-swagging british counterpart
04:20:48 <tensorpudding> slash possible murder?
04:20:53 <kdvh> they forced him to get hormone treatments
04:20:55 <kdvh> he wasnt happy
04:21:37 <GatoGoshine> is anybody gay ?
04:21:44 <chrisdone> keep it on topic and relevant
04:21:51 <GatoGoshine> sorry i mean happy 
04:21:55 <bremner> or move to #haskell-blah
04:22:07 <GatoGoshine> about haskell
04:22:28 <chrisdone> any mods about?
04:22:36 <tensorpudding> he's less famously gay than some people who are practically only notable for that fact
04:22:56 <GatoGoshine> so can i compile a dmg from haskell
04:22:59 <ivanm> please don't bring that discussion/argument up again
04:23:11 <tensorpudding> a dmg is not an executable format
04:23:21 <ivanm> GatoGoshine: see the cabal-macosx library/tool on hackage
04:23:25 <ivanm> @hackage cabal-macosx
04:23:26 <lambdabot> http://hackage.haskell.org/package/cabal-macosx
04:24:16 <GatoGoshine> ok ..
04:24:28 <tensorpudding> can GHC produce Mach-O?
04:24:44 <ivanm> tensorpudding: if you write the library/tool to do that, sure! :p
04:24:55 <GatoGoshine> ivanm : how long have you been doing haskell
04:25:00 <tensorpudding> hmm, so it produces ELF on OSX?
04:25:13 <ivanm> ummm.... 3.5 years IIRC
04:25:23 <ivanm> tensorpudding: tbh, I have nfi
04:25:51 <GatoGoshine> no  haskell coding ?
04:26:17 <ivanm> GatoGoshine: 3.5 years IIRC
04:27:19 <GatoGoshine> is the aweb site    with apps that ar written in haskell
04:27:21 * hackagebot speculation 0.2.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.2.0 (EdwardKmett)
04:27:30 <ivanm> GatoGoshine: sense, your question makes none
04:27:50 <ivanm> but if you mean a website with a list of software written in haskell, there's hackage
04:27:51 <ivanm> @where hackage
04:27:52 <lambdabot> http://hackage.haskell.org/package/
04:28:07 <edwardk> there, no more Speculation class. if i come up with a more compelling example of a type that can be much more efficiently specFolded than it can through the cheesy list conversion i'll switch back
04:28:09 <ivanm> which is the haskell equivalent of CPAN, CRAN, etc.
04:28:24 <ivanm> edwardk: mmmmm..... cheesy lists...
04:28:27 <GatoGoshine> now you have just past my first test .... 
04:28:38 * ivanm has jarlsberg in the fridge and is thus happy
04:28:50 <ivanm> GatoGoshine: oh, I didn't sign up for any tests
04:28:51 * ivanm leaves
04:29:01 <tensorpudding> jarlsberg is an okay cheese
04:29:07 <GatoGoshine> you are officially ......
04:29:39 <ivanm> tensorpudding: well, it's rather expensive here, but was on sale at the shops yesterday so I stocked up
04:30:34 <GatoGoshine> Ivanm : have you everdone object-C
04:33:17 <GatoGoshine> ivan
04:33:46 <Jafet> @protontorpedo
04:33:46 <lambdabot> so why would one prefer haskell to say clisp or smalltalk?
04:34:22 <ivanm> @. elite protontorpedo
04:34:23 <lambdabot> z0 tH3rE I$ n0 DA+484sE, MOnI+0Rin9 sYz73/\/\, W38 BrowzeR, WEb5eR\/eR, or 5(|-|3dUlIng z$Yt3/\/\ in HASx3Ll?
04:34:44 <GatoGoshine> Object-C vs Haskell
04:34:49 <GatoGoshine> ><?
04:35:10 <Jafet> Round Two, FIGHT!
04:35:14 <tensorpudding> @. vixen nixon
04:35:15 <lambdabot> oh, but only if, right?
04:35:18 <ivanm> GatoGoshine: Objective-C is only worth it if you're a follower of the cult of Apple
04:35:38 <ivanm> and no, I've never used it, so I can't compare it
04:35:56 <GatoGoshine> i currently only have macs
04:36:26 <tensorpudding> Objective C is nice, if you have a Mac
04:36:42 <tensorpudding> GNUstep is functional though
04:36:45 <GatoGoshine> let actionScript  = Haskell [ object-c]
04:36:46 <ivanm> GatoGoshine: but do you want to write software just for macs or for other OSs as well?
04:36:52 <ivanm> tensorpudding: oh, right, forgot gnustep
04:36:56 <ivanm> is that still around? :p
04:37:02 <ivanm> GatoGoshine: that makes no sense
04:37:04 <tensorpudding> But it lags behind Cocoa 
04:37:06 <kdvh> trying haskell after being used to OO languages is weird :/
04:37:16 <ivanm> and if you want to write actionscript, then go write it or else use a DSL to write it for you
04:37:24 <tensorpudding> Yeah, and there is an effort to make a modern fancy desktop environment based on it, called Etoile
04:37:29 <ivanm> kdvh: because you have to unlearn your bad habits! :p
04:37:36 <tensorpudding> Objective-C and Smalltalk programs intermingling
04:37:39 <ivanm> tensorpudding: etoile looked cool last I saw it, I must admit
04:37:53 <tensorpudding> Too bad it is very beta yet.
04:38:01 <ivanm> hasn't had a release since march last year though...
04:38:07 <tensorpudding> The libobjc runtime is broken at current
04:38:08 <GatoGoshine> ivanm i thought you where more of a relaxed kind of  gay 
04:38:08 <ivanm> (according to wikipedia)
04:38:19 <ivanm> GatoGoshine: my sexuality has nothing to do with it
04:38:31 <kdvh> ivanm: its more a case of "why isnt this feature available in Java?" etc
04:38:32 <ivanm> and no, I am not homosexual
04:38:35 <tensorpudding> In any case, GNUstep lags Cocoa by a lot, and most stuff isn't cross-compatible
04:38:44 <ivanm> kdvh: see functionaljava and scala
04:38:47 <GatoGoshine> sorry  gay = guy 
04:38:55 <GatoGoshine> my bad
04:39:18 <GatoGoshine> ivanm i thought you where more of a relaxed kind of  guy 
04:39:32 <ivanm> 1) what made you think I was relaxed, 2) what makes you think I'm no longer relaxed?
04:39:56 <tensorpudding> the ivanm abides
04:40:37 <GatoGoshine> " that makes no sense" ---- > [1..]
04:40:49 <ivanm> well, your question didn't make sense
04:40:53 <ivanm> > [1..]
04:40:55 <ivanm> ;-)
04:40:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:41:41 <GatoGoshine> foldr (*) 1[1..]
04:42:17 <tensorpudding> > let fibs = 0:1:[a+b | (a,b) <- zip fibs (tail fibs)] in fibs
04:42:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:42:37 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:42:39 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:42:45 * ivanm prefers the non-comprehension version
04:42:55 <tensorpudding> ah, zipWith
04:43:59 <GatoGoshine> Ivanm  is lamdabot some sort of engine that keep processing my code 
04:44:19 <GatoGoshine> ?
04:44:20 <tensorpudding> > let sieve [] = [], sieve (x:xs) = x : sieve [y | y <- xs, mod y x /= 0] in sieve [1..]
04:44:21 <lambdabot>   <no location info>: parse error on input `,'
04:44:32 <tensorpudding> > let sieve [] = []; sieve (x:xs) = x : sieve [y | y <- xs, mod y x /= 0] in sieve [1..]
04:44:36 <lambdabot>   mueval-core: Time limit exceeded
04:45:09 <GatoGoshine> let me = [1...]
04:45:20 <tensorpudding> > let me = [1..] in me
04:45:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:45:53 <GatoGoshine> let me = [1..10]
04:46:07 <GatoGoshine> me
04:46:34 <GatoGoshine> lamddabot: me
04:46:52 <tensorpudding> this isn't GHCi, you need to put a > in front of it
04:46:55 <Tarrasch> Hello guys, I'm using Ubuntu 10.04 and am trying to install wxHaskell, by now I've installed it and can compile my program under ghci, but I get the error I'm missing some c++ object files when I try to run some functions from ghci. Any ideas?
04:47:25 <GatoGoshine> >
04:47:31 <GatoGoshine> >me
04:47:39 <GatoGoshine> >let me = [1..10]
04:47:42 <GatoGoshine> >me
04:47:46 <tensorpudding> there needs to be a space too
04:47:52 <tensorpudding> > -- like so
04:47:53 <lambdabot>   not an expression: `-- like so'
04:47:55 <Tarrasch> Btw, I'm using a very common OS, I'm surprised this lacks click-and-play install opportunities. Btw. Do you think the haskell gtk-library is easier to use?
04:48:16 <GatoGoshine> > let me = [1..10]
04:48:17 <lambdabot>   not an expression: `let me = [1..10]'
04:48:40 <GatoGoshine> >  [1..10]
04:48:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:48:47 <tensorpudding> with lambdabot you need to use let..in
04:49:06 <bremner> GatoGoshine: perhaps you would like to /query lambdabot 
04:49:29 <tensorpudding> 'let' will bind the variables, and the part after 'in' is an expression, possibly involving those variables, that lambdabot will evaluate
04:50:48 <GatoGoshine> let 
04:51:46 <GatoGoshine> tensorpudding: ok thats enough haskell fro the day .... do you think so ?
04:52:12 <GatoGoshine> my bain needs rest
04:52:31 <GatoGoshine> []
04:54:31 <tensorpudding> You should try a tutorial first, I recommend the one Learn You A Haskell
04:54:34 <tensorpudding> @where lyah
04:54:34 <lambdabot> http://www.learnyouahaskell.com/
04:58:40 <ksf> Tarrasch, can you paste the error?
04:58:42 <ksf> hpaste.org
04:59:57 <ksf> last time such a thing happend there were broken pkgconfig entries...
05:00:13 <sohum> Axman6:  why does your hackathon form not accept my email address?
05:07:13 <Tarrasch> ksf - Loading package wxcore-0.12.1.6 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
05:07:24 <Tarrasch> But I can compile with ghc I noticed
05:07:42 <Tarrasch> And I guess using ghci isn't of such high importence
05:08:03 <edwardk> hrmm, now the trick is how to build: specTraverse :: (Traversable f, Eq a) => a -> (a -> STM b) -> f a -> STM (f b)
05:08:55 <ksf> what's <$ spelled? fconst?
05:09:08 <edwardk> @type (<$)
05:09:09 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
05:09:25 <edwardk> it doesn't have a prefixed name
05:09:26 <ivanm> ksf: methinks it's spelt `<' and then `$'
05:09:30 <ivanm> ;-)
05:17:05 <bobzhangatthu> anyone knows how to caculate a region in Emacs like OCaml? Thanks
05:17:17 <ivanm> huh?
05:17:46 <bobzhangatthu> I mean evaluate the selected region?
05:18:01 <ski> bobzhangatthu : possibly you really want to ask in #ocaml or maybe #emacs ?
05:18:04 <bobzhangatthu> en
05:18:12 <bobzhangatthu> emacs
05:19:42 <tensorpudding> I don't think you can load a region into GHCi in Emacs
05:20:10 <bobzhangatthu> yeah, i did not find any? but it is very of use, right?
05:20:12 <tensorpudding> C-c C-l in haskell-mode loads the buffer into an inferior GHCi though
05:20:44 <tensorpudding> rather, it sends the file that the current buffer is editing
05:21:00 <tensorpudding> so it will prompt you to save any changes in that buffer
05:21:01 <bobzhangatthu> en, but I just wanted to test a part of the code, not all
05:21:23 <tensorpudding> It probably has to do with how GHCi handles code.
05:21:50 <tensorpudding> You can't always insert bare Haskell code into GHCi and expect it to work
05:21:50 * ksf always loads full files into ghci
05:22:07 <ksf> there's imports and whatnot that I want to have on the prompt
05:22:14 <tensorpudding> for instance, you can't declare datatypes, typeclasses, or set variables without using a let binding
05:23:13 <bobzhangatthu> I know, I came from OCaml. It's very useful to calculate just some part of code,not all?
05:23:18 * ksf recommends xmonad and a second terminal for running ghci
05:23:25 <ksf> you can then switch easily and hit :r in ghci
05:23:34 <ksf> (after saving your changes in vim)
05:23:35 <tensorpudding> other languages that use a "send region to inferior process" function presumably have some means to send each line verbatim to the interpreter, which works in a language like Python, Ruby or OCaml
05:24:18 <tensorpudding> I've gotten used to liberally using comment-region to block out the parts of code I don't want to run, and doing C-c C-l
05:24:37 <bobzhangatthu> en, but it's really dull
05:24:59 <tensorpudding> So in short, it kinda sucks, but I don't think it's a lack of skill with the haskell-mode people so much as an inherent shortcoming in GHCi
05:26:00 <kdvh> is there a way to permenantly replace 'Prelude' in GHCi? I am sick of having to do :set prompt every session
05:26:11 <ivanm> yes
05:26:14 <ivanm> kdvh: ~/.ghci
05:26:19 <tensorpudding> I'm not knowledgeable enough about how GHC works to say why this restriction in the behavior of GHCi exists.
05:26:35 <kdvh> thanks
05:26:53 <ksf> the ghc api can either compile whole modules (including data decls) or eval expressions in a context
05:27:08 <ksf> the latter of which is the ghci prompt
05:27:14 <ksf> it's basically a do-block.
05:27:42 <ksf> (literally, last time I looked ghci prepends "it <- " to every expression)
05:27:46 <ivanm> tensorpudding: well, ghci isn't a "real" REPL in the sense of lisp, etc.
05:29:05 <Jafet> Read-execute-print-loop
05:29:32 <Phyx-> hmm too bad you can't pass a record selection function as argument to a function, which then updates the field using the passed argument
05:29:52 <sdlhaskell> hi guys.
05:29:59 <ksf> Phyx-, fclabels.
05:30:40 <sdlhaskell> Does anyone of you know how to install SDL bindings fpr haskell on windows? I am sitting here for 90 minutes and it wont work. I'Ve installed mingw, msys, copied the SDL-dev libbs & include files to my mingw/include and mingw/lib
05:30:47 <tensorpudding> GHCi is a pretty good interpreter overall, though
05:30:50 <sdlhaskell> but using cabal install SDL wont work
05:31:11 <pastorn> sdlhaskell: paste your error somewhere
05:31:33 <bobzhangatthu> en, each time I comment some parts of my code, I really want this feature
05:31:46 <Phyx-> ksf: oooh thanks, will check that out, would significantly clean up my code
05:32:20 <ksf> commenting out much stuff shouldn't be necessary. at least not when you're not duing major refactorings.
05:32:27 <sdlhaskell> hmm how do I copy text out of msys =X
05:34:31 <sdlhaskell> pastorn,  here a screenshot of the error message :)
05:34:43 <sdlhaskell> http://img249.imageshack.us/img249/8520/unbenanntcml.jpg
05:35:10 <ksf> wut
05:35:14 <ksf> how did you manage to do that
05:35:32 <Phyx-> sdlhaskell: for the record, you click on the window icon, edit-> mark, select the text and press enter
05:36:05 <sdlhaskell> if I omit --extra-include-dirs and --extra-lib-dirs  then I get the error that SDL.h couldnt be find
05:36:14 <sdlhaskell> whcih is in mingsw's include/SDL directory
05:36:18 <sdlhaskell> Phyx-, oh ty
05:36:50 <sdlhaskell> I dont get it why this cant simply work. I mean...it is just the installation of sdl bindings for haskell
05:37:19 <Phyx-> @type M.!
05:37:19 <ksf> aaah now I get it.
05:37:20 <lambdabot> parse error on input `M.!'
05:37:29 <pastorn> sdlhaskell: it should be in windows/sys*something*/
05:37:38 <sdlhaskell> sorry?
05:37:41 <ksf> sdl on windows has the gall to register its own main function, expecting the user do use SDL_main
05:37:42 <Phyx-> @hoogle Map k v -> k -> Maybe v
05:37:42 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
05:37:43 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
05:37:43 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
05:37:46 <ksf> which hsc2hs doesn't know.
05:38:32 <sdlhaskell> pastorn, WHAT should be in C:\windows\system ?
05:39:11 <sdlhaskell> ksf, I am not compiling any program actually, I am just trying to install the sdl bindigns for haskell
05:39:30 <Phyx-> sdlhaskell: cabal compiles from source
05:39:39 <sdlhaskell> =/
05:39:43 <sdlhaskell> ok tell me what to do
05:39:44 <ksf> but hsc2hs is compiling a .c file to get a hold of #defines etc.
05:40:17 <ksf> it generates a big main function with a lot of printfs which output haskell code with macros expanded.
05:40:35 <pastorn> sdlhaskell: some sdl stuff
05:40:42 <pastorn> no wait
05:40:42 <sdlhaskell> SDL.dll is in there
05:40:44 <pastorn> that was glut
05:40:49 <pastorn> sorry
05:40:52 <sdlhaskell> SDL.dll was already in windows/system
05:41:12 <Phyx-> ksf: is there no flag for hsc2hs to specify the name of the main function?
05:41:25 <ksf> sdlhaskell, you can try to run the command that failed without -lSDLmain and lSDL
05:41:36 <sdlhaskell> ksd
05:41:39 <ksf> hsc2hs doesn't need to call anything from that.
05:41:49 <sdlhaskell> the only comman I tried was: cabal install [...]
05:41:50 <ksf> Phyx-, possibly...
05:42:12 <sdlhaskell> I am just trying to install thesdl bindings via cabal
05:42:16 <ksf> it says "command was:" there in the error
05:42:17 <sdlhaskell> cabal install SDL
05:42:38 <sdlhaskell> I didnt type anything except the first line
05:43:01 <ksf> ...the build process is broken on windows.
05:43:14 <sdlhaskell> $ cabal install SDL --extra-include-dirs="C:/MinGW/include/SDL" --extra-lib-dir
05:43:14 <sdlhaskell> s="C:/MinGW/lib" 
05:43:19 <sdlhaskell> oops sry
05:43:31 <sdlhaskell> $ cabal install SDL --extra-include-dirs="C:/MinGW/include/SDL" --extra-lib-dirs="C:/MinGW/lib"
05:43:33 <sdlhaskell> thats all I did
05:43:34 <sdlhaskell> this line
05:44:03 <ksf> yes, and cabal executed a couple of commands, one of which failed, which it outputs.
05:44:05 <sdlhaskell> I am wondering why should I use a portable graphics lib if it is impossible to install it on  another platform than linux
05:44:26 <Phyx-> you're confusing a couple of things...
05:44:47 <ksf> sdl is, indeed, of questionable code quality.
05:45:06 <Phyx-> I generally agree that there's a couple of haskell libs that have only been tested or work on unix systems
05:45:42 <sdlhaskell> Phyx-, sure but in practice: I cant install sdl bindings fpr haskell within 2h
05:46:01 <edwardk> ugh. specTraverse or qualified imports and traverse? i have a whole bunch of these and specFor_ looks a little ugly
05:46:07 <ksf> yes, and I told you why.
05:46:37 <ksf> there's ways to fix it, but I'm quite sure someone else already stubled across the same problem, as there got to be people using sdl on windows
05:47:00 <edwardk> sdlhaskell: sdl and cabal don't get along on windows
05:47:08 <sdlhaskell> hm
05:47:22 <sdlhaskell> edwardk, hm okay, how do I do it then?
05:47:44 <edwardk> dunno. i've never gotten it to work. check the interwebs. I know I've seen at least one howto out there
05:47:44 <sdlhaskell> I am pretty new to haskell and I've only installed stuff via cabal till now
05:47:50 <Phyx-> hmm, is it common in haskell to declare all typesigs before all bindings? I think the most common one is typesig immediately followed by the binding right?
05:47:50 <ksf> sdlhaskell, http://jpmoresmau.blogspot.com/2010/05/haskell-sdl-on-windows-check-hacking.html
05:48:17 <ksf> sdlhaskell, the next time I'm going to send a lmgtfy link...
05:48:32 <Phyx-> lmgtfy?
05:48:41 <ivanm> Let Me Google That For You
05:48:44 <Phyx-> ah
05:48:45 <sdlhaskell> let me google that for you, makes him feel inferiour
05:48:45 <geheimdienst> "let me google that for you"
05:48:46 <ivanm> @google lmgtfy
05:48:47 <lambdabot> http://lmgtfy.com/
05:48:48 <lambdabot> Title: Let me google that for you
05:49:09 <Phyx-> @google let me bing that for you
05:49:10 <lambdabot> http://www.letmebingthatforyou.com/
05:49:10 <lambdabot> Title: Let me Bing that for you!
05:49:13 <Phyx-> lol
05:49:39 <ksf> Phyx-, http://tinyurl.com/5wf7s4
05:49:43 <andreo> @google django
05:49:44 <lambdabot> http://www.djangoproject.com/
05:49:44 <lambdabot> Title: Django | The Web framework for perfectionists with deadlines
05:50:03 <Phyx-> ksf: yeah, i know it
05:50:13 <Phyx-> just not the abbreviation
05:50:17 <Phyx-> @where SrcSpan
05:50:18 <lambdabot> I know nothing about srcspan.
05:50:22 <Phyx-> @url SrcSpan
05:50:22 <lambdabot> I know nothing about srcspan.
05:50:31 <ksf> @hoogle SrcSpan
05:50:31 <lambdabot> No results found
05:50:54 <Phyx-> it's a Internal GHC structure, which hoogle usually doesn't index :S
05:52:24 <jix> is there a way to insert messages (as markers) into the heap profile from the running haskell code?
05:53:04 <ksf> not from the running, but the source code
05:53:13 <ksf> {-# SCC "heyThere" #-}
05:53:44 <ksf> also, don't forget to use -auto-all to get annotations for top-level bindings for free
05:54:02 <ksf> (/me wishes it would do let and where bindings as well)
05:54:19 <jix> i don't want to add a cost centre
05:54:29 <jix> i want to have a time marker
05:54:34 <ivanm> ksf: and -caf-all!
05:54:51 <ksf> what do you mean with time marker?
05:54:58 <jix> so i know at what point of the heap profile something happened
05:55:14 <ivanm> ksf: AFAIK, it doesn't automatically do let and caf bindings for you because it doesn't know what to call them (-caf-all uses random unique names that don't mean much)
05:55:36 <ksf> but wheres and lets have names
05:55:48 <ivanm> are they unique though?
05:56:08 <ivanm> for starters, pretty sure it's possible to have a let and a where for the same function with the same name
05:56:10 <jix> a bit like Debug.Trace but not outputting to stderr but into the heap profile
05:56:11 <ksf> well, uniquify them by using the surrounding's scopes name.
05:56:34 <ksf> and I think SCCs are allowed to overlap
05:56:48 <ivanm> jix: not sure if that's possible
05:57:03 <ivanm> ksf: that's probably possible, but requires someone to implement it :p
05:57:10 <ivanm> also, by default it'd probably be too noisy
05:57:23 <ksf> jix, maybe you want threadscope?
05:58:00 <jix> ksf: i haven't looked ad threadscope... but basically i'm quite happy with the heap profile... but it would be better if i don't have to guess what part is running at what time
05:58:31 <ksf> theadscope is going to tell you that
05:58:55 <jix> i'll have a look at it then
05:58:56 <ksf> ...I think.
06:02:38 <jix> hmm it seems research.microsoft.com is down?
06:03:07 <ksf> that's impossible, iss has zero downitme!
06:03:12 <tensorpudding> must be those IIS webservers
06:03:13 <ksf> !!11
06:03:25 <tensorpudding> rest assured that Haskell's website uses webservers of a better caliber
06:03:56 <ivanm> jix: for some reason some machines aren't able to access it
06:04:03 <Jafet> Don't fret, the ISS is still in orbit
06:04:05 <ivanm> jix: for example, I can't view it at home but I can at uni
06:04:18 <tensorpudding> I should hope the ISS doesn't go down!
06:04:44 <ivanm> jix: http://downforeveryoneorjustme.com/research.microsoft.com
06:05:13 <jix> ivanm: heh i tried from home and uni both didn't work
06:05:37 <ivanm> there was even a discussion on the haskell reddit about it
06:05:51 <ivanm> and an older one dibblego and I had on forums.whirlpool.net.au
06:05:54 <ivanm> it seems rather random
06:06:12 <ivanm> jix: for some reason, wget can get it, but browsers can't; it appears to be some proxy thing that causes it
06:06:13 <jix> well i found what i was looking for in the google cache...
06:06:19 <jix> ivanm: i can't even ping
06:06:45 <geheimdienst> research.microsoft.com works nicely for me
06:06:56 <ivanm> jix: neither can I, but wget works
06:07:02 <jix> oh
06:07:03 <drbean> @hoogle undefined
06:07:04 <lambdabot> Prelude undefined :: a
06:07:04 <lambdabot> Control.Exception UndefinedElement :: String -> ArrayException
06:07:04 <lambdabot> Control.OldException UndefinedElement :: String -> ArrayException
06:07:07 * ivanm wonders if it's a IP6 thing...
06:07:28 * geheimdienst could be the human proxy. you tell me via irc what you're looking for, i tell you via irc what the page roughly is about
06:07:32 <ivanm> bah, ping6 just says "Unknown host"
06:07:57 <drbean> @hoogle defined
06:07:58 <lambdabot> Prelude undefined :: a
06:07:58 <lambdabot> Control.Exception UndefinedElement :: String -> ArrayException
06:07:58 <lambdabot> Control.OldException UndefinedElement :: String -> ArrayException
06:10:01 <ManateeLazyCat> ivanm: Australia gov install GFW?
06:10:24 <ivanm> ManateeLazyCat: not yet, and we have a new PM so it might be canned (at least the compulsory version) \o/
06:12:30 <ManateeLazyCat> ivanm: Two three thing to filter GFW, 1) Change DNS to 8.8.8.8 (Google's DNS server). 2) Use https://encrypted.google.com/ 3) Install a proxy client to support https. (Such as YourFreedom).
06:12:42 <ManateeLazyCat> s/filter/fighting
06:13:06 * ivanm -> sleep
06:13:23 <ivanm> ManateeLazyCat: eh, there'll probably be easier ways than that ;-)
06:13:34 <ManateeLazyCat> ivanm: Better?
06:13:34 <Jafet> That's surprisingly easy...
06:13:47 <Jafet> Given that Google is officially supposed to comply with the blockade.
06:13:55 <ivanm> well, hopefully better
06:13:58 <ivanm> Jafet: exactly
06:14:29 <ksf> I think the chinese govt knows that a firewall that isn't based on whitelisting is circumventable in any case.
06:14:32 <ivanm> but the guy responsible for it has admitted that it'll be possible to circumvent it, and there's already groups teaching the elderly how to do so in case they want to commit euthanasia
06:15:15 <ManateeLazyCat> ksf: It's will limit economy if use WhiteListing.
06:15:30 <ksf> yep.
06:15:58 <ksf> and afaiu the chinese basically have their own versions of all the web2.0 sites, so the reasons to go outside aren't that big
06:16:06 <ManateeLazyCat> ksf: In China, have many security Team develop tools to fighting GFW.
06:16:22 <Zao> Just submit form 9001-B in triplicate to your local government declaring which hosts you need access to. It's simple and will only take a few weeks to process.
06:17:37 * ManateeLazyCat China gov develop supercomputer cluster to running GFW. 
06:18:14 <ksf> you just can't bleeding do deep packet inspection on encrypted channels
06:19:18 <Zao> ksf: Build a gigantic server network that will mitm any SSL connection, and force lusers to accept their certificates or gtfo.
06:19:29 <ManateeLazyCat> ksf: Yes, so China gov filter don't allow you access encrypted resource, such as https site, proxy tools... etc.
06:19:46 <Zao> That would allow you to use https and such, as long as you're willing to accept inspection.
06:20:08 <Zao> Better than a blanket ban of any encryption, IMO.
06:20:12 <Zao> Somewhat.
06:20:20 <Jafet> Zao, you'd have to intercept every public-key infrastructure, which is absurd.
06:20:26 <ksf> encryption is destinguishable from random binary data?
06:20:47 <tensorpudding> Banning encryption in entirely is pretty much a killer to online commerce
06:20:48 <Zao> ksf: I thought the context was https?
06:21:05 <ksf> one of the contexts, yes.
06:22:13 <ksf> at least the chinese seem to be able to route properly, in contrast to the pakistani.
06:22:53 <ManateeLazyCat> ksf: You can come to China to experience GFW. :)
06:22:53 <Zao> Hehe.
06:23:18 <Zao> ManateeLazyCat: I would expect that a brief visitor gets a special pipe through the GFW.
06:24:01 <ManateeLazyCat> Zao: You can't, anyone. :)
06:24:44 <shajen> (a -> b) -> (c -> a) -> (d -> c) -> d -> b
06:24:56 <shajen> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:25:12 <shajen> no
06:25:20 <shajen>  (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c and (a -> b) -> (c -> a) -> (d -> c) -> d -> b
06:25:24 <shajen> is it equal ?
06:25:34 <ksf> @djinn  (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
06:25:34 <lambdabot> f a b c d = a b (c d)
06:25:44 <ksf> @djinn (a -> b) -> (c -> a) -> (d -> c) -> d -> b
06:25:44 <lambdabot> f a b c d = a (b (c d))
06:25:46 <jix> in 2008 using an encrypted vpn to get behind the GFW did work in china...
06:25:47 <ksf> nope.
06:26:11 * ManateeLazyCat Don't use ISP DNS server, don't use China-mail, don't use China-IM (such as QQ), don't send any message without encrypted.....
06:26:35 <ksf> ...well, depending on a, that is.
06:26:46 <ksf> a could very well make them equivalent.
06:26:46 <ManateeLazyCat> jix: It was the Chinese government's acting.
06:27:03 <ksf> by applying its second argument to the first.
06:27:25 <b0fh_ua> I want to group a list in a way, so ["a","b","c","d","e"] -> [["a","b"],["c","d"],["e"]]. So it will transform list of strings into list of pairs of strings, and keep the last string w/o corresponding pair as is.
06:27:36 <b0fh_ua> is there something ready to use from standard libraries?
06:27:37 <shajen> @djinn (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
06:27:38 <lambdabot> f a b c d = a b (c d)
06:28:51 <ksf> ...what I meant is that the first one can become the second with a sufficient a and the a of the second being id.
06:29:00 <ksf> in general, they're distinct.
06:29:49 <shajen> :t (.)(.)
06:29:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
06:30:28 <flippo> ManateeLazyCat, you can't access https?  Does it work if you change the port?
06:30:52 <ManateeLazyCat> flippo: I need use proxy access https.
06:31:17 <ManateeLazyCat> flippo: Otherwise GFW will redirect you to http version. such as https://www.google.com to http://www.google.com
06:31:46 <flippo> That's more extreme than I realized.  That must make it hard to buy things overseas.  (And unsafe domestically.)
06:32:08 <ManateeLazyCat> flippo: Yep. 
06:32:09 <Jafet> It's already unsafe to buy many things in China, let alone on the internet..
06:34:38 <ManateeLazyCat> In China has develop a project named scholarzhang (http://code.google.com/p/scholarzhang/wiki/README), that confusion GFW and don't need Proxy.
06:40:10 <shajen> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:40:11 <lambdabot> f a b c d = a (b c d)
06:43:18 <ryanakca> Is it possible to rewrite cycle using fold? The exercise lists it among the functions to rewrite using fold if possible. I don't want to embark on an impossible journey...
06:43:33 <shajen> @djinn (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
06:43:34 <lambdabot> f a b c d e = a b c (d e)
06:44:51 <Tomsik_> shajen: go away from my #haskell, go back to #ii :p
06:45:13 <Axman6> #ii?
06:45:20 <Baughn> There isn't a type-family variant for newtypes?
06:45:31 <Cale_> ryanakca: well...
06:46:13 <Cale_> You can write fix using foldr, and then write any recursive function in terms of that :)
06:46:55 <Tomsik_> ryanakca: I've got an idea how to do that, lemme write it down
06:47:05 <ksf> Baughn, data families
06:47:12 <ryanakca> Tomsik_: Thanks
06:47:17 <ksf> you choose between data and newtype in the instances, not the decl.
06:47:30 <Cale_> You could write (++) in terms of foldr and cycle in terms of that:  cycle xs = let ys = foldr (:) ys xs in ys
06:49:40 <Cale_> You could do this:  cycle xs = foldr (\y ys -> xs ++ ys) [] [1..]
06:49:48 <Cale_> But that's a little cheesy too
06:50:28 <Baughn> ksf: Oh, I see.
06:50:44 <ryanakca> Cale_: Could you pastebin that first one with indentation? I'm new to Haskell and the 'xs in ys' isn't clear to me... would the 'in ys' be on a new line?
06:51:37 <ksf> not necessarily
06:51:41 <Cale_> Yes
06:51:42 <ksf> in can be both.
06:51:49 <Cale_> line up the 'in ys' with the 'let'
06:51:50 <ksf> ...as long as it's not less indented.
06:52:05 <Cale_> let ... in ...
06:52:52 <Cale_> It'd be the same as  cycle xs = ys where ys = foldr (:) ys xs
06:52:53 <ryanakca> Cale_:  OK, thanks :)
06:52:54 <shajen> @djinn (b -> c) -> (a -> b) -> a -> c
06:52:54 <lambdabot> f a b c = a (b c)
06:53:15 <Cale_> except that the 'where' in that case attaches directly to the definition of 'cycle'
06:53:31 <Cale_> It's not part of the expression on the right hand side of the = sign
06:54:33 <Tomsik_> (\x -> foldr (\_ a -> x++a) [] [1..]) [1,2,3,4]
06:56:23 <verdelyi> can someone help me out how to catch read's "no parse" exception? My current code: http://codepad.org/ErsVGaS8
06:57:16 <ClaudiusMaximus> :t reads
06:57:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:57:37 <Saizan> verdelyi: you could s/return f/return $! f/
06:57:43 <ryanakca> Tomsik_: Thanks. So lambdas can take more than one argument? (\_a -> x ++ a) ?
06:58:16 <Saizan> verdelyi: but for read it's more appropriate to use reads and pattern match on the result, or use readIO if you're in IO
06:59:02 <Tomsik_> ryanakca: yeah, it's like in real lambda calculus
06:59:06 <verdelyi> Saizan: I'm actually using getOpt to read some int from the command line and want to spit out anything other than "no parse" if the input is incorrect
06:59:09 <Tomsik_> I mean, it's a shortcut notation
07:00:02 <ryanakca> Ah. I haven't yet gotten to lambda calculus... I'll probably get to it at some point in my University years :)
07:00:09 <Saizan> ryanakca: the space between _ and a is important
07:00:32 <Baughn> Saizan: With a bit of type-family hackery, I've gotten the type signatures down to things like "singleton :: a -> Table a -> Table a". =3=
07:00:32 <ryanakca> Saizan: Oops, thanks
07:00:32 <tensorpudding> Lambdas are easy to use without knowing too much about the Lambda calculus
07:00:48 <Saizan> Baughn: nice
07:00:56 <ksf> they're just functions, after all.
07:01:07 <verdelyi> Saizan: anywas your suggestion works, and I'm gonna experiment with reads and readIO so thatnks
07:01:10 <Baughn> Saizan: Er, though that's obviously replace, not singleton
07:01:35 <Saizan> Baughn: Table is a type family?
07:01:47 <Baughn> newtype Table a = Table (Schema a)
07:01:51 <Baughn> Schema is a type family
07:02:09 <Baughn> (I need the wrapper so I can define things like a Monoid and Functor instance for it)
07:02:09 <verdelyi> Saizan: but I have to ask what does $! mean? It's pretty hard to google on that
07:02:20 <Saizan> ?src $1
07:02:21 <lambdabot> Source not found. Do you think like you type?
07:02:22 <Saizan> ?src $!
07:02:22 <lambdabot> f $! x = x `seq` f x
07:02:41 <verdelyi> hmm ok
07:03:03 <Baughn> verdelyi: Basically, "evaluate x before calling f"
07:03:15 <Saizan> not necessarily before
07:03:22 <Tomsik_> strict application it is
07:03:38 <Baughn> *Usually* before.
07:03:45 <Baughn> We can get into the details later. ;)
07:03:51 <pastorn> > let x = undefined in const 1 $ x
07:03:52 <lambdabot>   1
07:03:54 <pastorn> > let x = undefined in const 1 $! x
07:03:56 <lambdabot>   *Exception: Prelude.undefined
07:04:03 <pastorn> there we go :)
07:04:27 <Baughn> verdelyi: Keep in mind that $! does not force the function call itself to be evaluated, it just means that if it ever is, x will be evaluated first.
07:04:39 <Baughn> verdelyi: And the evaluation is still only to weak-head normal form.
07:04:54 <Cale_> It's really "Make sure that x is evaluated before anything can pattern match on the result of f x"
07:05:10 <verdelyi> but what does this have to do with exception catching?
07:05:31 <Jafet> > let x = [undefined] in const () $! x
07:05:32 <lambdabot>   ()
07:05:49 <Baughn> verdelyi: Exceptions are thrown when values are evaluated. But using it like that is kind of a hack.
07:05:54 <Cale_> verdelyi: If your exception was thrown by a call to error, then you need to make sure that the expression containing the call to error is actually evaluated inside the catch.
07:06:13 <Baughn> Oh, wait, no, that isn't the hack.
07:06:17 <Cale_> verdelyi: My policy is generally not to catch errors thrown by error, but rather just not to throw them in the first place.
07:06:19 <ksf> ...and that's why exceptions in pure code are pure evil.
07:06:31 <Baughn> Calling evaluate inside unsafePerformIO so you can catch errors in pure code /from/ pure code, /that/ is the hack.
07:06:58 <Cale_> Think of error as being a way to say "if this is ever needed, the program can just die, because the assumptions which it was founded on are incorrect"
07:07:02 <Saizan> Baughn: that means i'd have to newtype if i want to use some other indexing schema, right?
07:07:16 <verdelyi> it's harder to catch an input error than I thought
07:07:18 <Baughn> Saizan: Yesh. Hmm.
07:07:25 <Cale_> Just don't use error
07:07:39 <Cale_> verdelyi: What kind of input error are you talking about?
07:07:53 <Saizan> Cale_: read
07:08:07 <Cale_> Oh, if you need to catch the failure, don't use read
07:08:15 <Cale_> use reads, and pattern match on the result
07:08:19 <ksf> > let safeRead = fmap fst . listToMaybe . read in safeRead "abc" :: Int
07:08:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:08:21 <lambdabot>         against inferred type ...
07:08:23 <Cale_> an empty list means no parse
07:08:26 <ksf> > let safeRead = fmap fst . listToMaybe . read in safeRead "abc" :: Maybe Int
07:08:27 <lambdabot>   Ambiguous type variable `b' in the constraint:
07:08:27 <lambdabot>    `GHC.Read.Read b'
07:08:27 <lambdabot>      ar...
07:08:42 <Cale_> ksf: reads
07:08:48 <ksf> > let safeRead = fmap fst . listToMaybe . reads in safeRead "abc" :: Maybe Int
07:08:48 <Cale_> (I think you want)
07:08:49 <lambdabot>   Nothing
07:08:52 <ksf> yep.
07:08:53 <verdelyi> Cale_: ok, here is what I'm talking about: http://codepad.org/rgnqwObH the "read arg::Int" can throw an error. I want to catch that and print a readable error message
07:08:56 <ksf> > let safeRead = fmap fst . listToMaybe . reads in safeRead "12" :: Maybe Int
07:08:57 <lambdabot>   Just 12
07:09:01 <Baughn> Saizan: I think this is about as good as it gets. I suppose I could do the newtyping and stuff automatically in some TH code, but it wouldn't buy you much.
07:09:04 <ksf> should be in the stdlib.
07:09:37 <Cale_> verdelyi:  case read arg of [(Just x, "")] -> ... success ...; _ -> ... failure ...
07:09:43 <Cale_> er
07:09:47 <Cale_> verdelyi:  case reads arg of [(Just x, "")] -> ... success ...; _ -> ... failure ...
07:10:13 <Baughn> Saizan: No, wait.. how's this:
07:10:17 <verdelyi> Cale_: ok, thx, reads seems to be better
07:10:24 <Cale_> ksf: You'd probably want to ensure the snd of the pair is empty too
07:10:51 <ksf> yep
07:11:14 <Baughn> Saizan: A createNamedIndex variant that lets you pick an arbitrary other name for the index. Under the covers, it creates an (empty) ADT with that name, and uses that for the type-family indexing.
07:11:22 <ksf> usually I just use read or read* with fmap fst . head, though, because all the input is pre-parsed.
07:11:47 <Baughn> Saizan: So instead of Table Person, you get Table PersonFoo, or Table Figment, or whatever
07:12:01 <Saizan> Baughn: i don't think i feel the need to hide the indexes behind a type family actually, but you're the user :)
07:12:19 <Baughn> Saizan: No, you are. I'm the coder. :P
07:12:37 <Baughn> Saizan: It increases type safe..ty...
07:12:39 <Baughn> Yowch.
07:12:49 <Saizan> how so?
07:12:49 <Baughn> I've got replace :: a -> Table a -> Table a.
07:13:02 <Baughn> Which works great, /so long as there is a single schema per type/.
07:13:16 <Baughn> Well, type simplicity I should say.
07:14:26 <Baughn> The error messages are good, it's really obvious how it's supposed to work.. all good things, at the cost of a newtype if you want more indexes.
07:14:29 <Baughn> I think I'll go with this for now.
07:15:08 <Saizan> what error messages does this improve?
07:15:42 <Baughn> That's the theory. Hang on, let me get this compiling so I can test it.
07:16:00 * Baughn has incidentally reached four lines on the LANGUAGE pragma.
07:17:02 <Saizan> you know you can do better than that.
07:17:16 <ksf> -Wunused-extensions?
07:18:15 <Baughn> Unrecognized flag?
07:18:21 <verdelyi> Cale_: just fyi, reads doesn't put "Just" into the result, only the value, and I have to explicitly specify the type
07:18:33 <Saizan> actually, a type family is going to cause problems wrt. type instantiation..
07:18:39 <AqD|Home> I just finished my own "lines" func!!
07:18:45 * AqD|Home hugs everyone in the room
07:19:22 <Saizan> oh, i guess it's fine with the newtype wrapper
07:19:41 <AqD|Home> it looks elegant and short.... but the original lines in ghc looks quite complex for some reason.....
07:20:23 <ksf> tadada football's going home.
07:23:59 <AqD|Home> hmm but i can't use it to split readFile :(
07:24:30 <Baughn> @hoogle a (Maybe b) -> Maybe (a b)
07:24:30 <ksf> @src lines
07:24:30 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:24:31 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
07:24:31 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:24:31 <lambdabot> Source not found. You untyped fool!
07:30:08 <jix> i implemented writing debug traces into the heap profiling log
07:30:19 <jix> now i only need a viewer that supports them
07:34:35 <Phyx-> hmmm ever since my laptop fell my harddrive has been busy alot.. but it passes the smart tests with no change..
07:36:37 <p_l|backup> btw, some people might be interested - AMD started a fund for companies that want to use their Fusion chips, that includes software
07:41:04 <verdelyi> is there a way to produce platform-independent color terminal output? Like OK in green, ERROR in red etc.
07:41:55 <p_l|backup> verdelyi: how much platform independance are you looking for? And are you willing to simply use curses? (curses is the easiest way)
07:42:22 <verdelyi> p_l|backup: should work on bash and windows console/powershell (maybe mac)
07:42:42 <Baughn> Curses would cover linux and mac
07:42:52 <p_l|backup> Baughn: windows as well, with PDcurses
07:42:59 <Baughn> verdelyi: Color output isn't a function of your shell (bash), but your terminal emulator (xterm or whatever).
07:43:16 <Baughn> plediii_: Sure, if hscurses can use that one
07:43:18 <p_l|backup> also note that powershell might not allow color despite it
07:43:53 <p_l|backup> windows console does support it, though rather limited
07:43:59 <verdelyi> p_l|backup: powershell allows color (at least I could did it)
07:44:11 <verdelyi> write-host -foregroundcolor red
07:44:15 <Phyx-> i use colors and powershell here fine
07:44:48 <p_l|backup> What I meant is that powershell might be running in different console than normal windows one
07:45:33 <verdelyi> so it's not that simple like "putStrLn "text" red"?
07:45:50 <p_l|backup> though I guess that if your app will require console subsystem then it will launch console emulator
07:46:25 <verdelyi> p_l|backup: I don't want to overcomplicate it, it's just a compiler and I wanted fancy colors in the output
07:47:19 <p_l|backup> verdelyi: well, you could read through sources of pdcurses to find correct strings for windows, on *nixes you got terminfo
07:47:47 <danharaj> anyone else watching the world cup?
07:47:58 <verdelyi> p_l|backup: ok, thanks
07:48:13 <geheimdienst> danharaj, is that the sailing thing?
07:48:16 <geheimdienst> </troll>
07:48:19 <danharaj> haha
07:48:29 <danharaj> terrible officiation this game
07:48:50 <danharaj> it's like if our runtime system were written in python
07:51:57 <ClaudiusMaximus> @hackage ansi-terminal
07:51:58 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
07:58:14 <Baughn> Saizan: So yeah, useful error messages.
07:58:22 <Baughn> Saizan: singleton :: TableCreated a => a -> Table a
07:58:51 <Baughn> Saizan: singleton "foo" --> No instance for (TableCreated [Char])
07:58:56 <Baughn> That should be pretty clear. :)
07:59:08 <verdelyi> ClaudiusMaximus: thx
07:59:19 <Baughn> Saizan: (The TH function writes the instance, of course)
08:01:35 <Saizan> Baughn: ah, ok, i was thinking more of error messages involing key types
08:02:02 <Baughn> Yeah.. haven't gotten quite that far in my interface writing.
08:02:12 <alexyk> while compiling with head, I got this:
08:02:14 <alexyk> SpecConstr
08:02:14 <alexyk>     Function `lgo{v s84t} [lid]'
08:02:15 <alexyk>       has two call patterns, but the limit is 1
08:02:15 <alexyk>     Use -fspec-constr-count=n to set the bound
08:02:15 <alexyk>     Use -dppr-debug to see specialisations
08:02:19 <alexyk> -- huh?
08:04:14 <Saizan> sounds like something fishy is going on, SpecConstr is an optimization pass
08:06:33 * hackagebot speculation 0.3.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.3.0 (EdwardKmett)
08:06:50 <edwardk> now with dozens more combinators
08:08:38 <geheimdienst> uh guys ... is it correct that on debian stable there's no package for cabal?
08:08:49 <geheimdienst> i mean, wtf?
08:09:42 <Saizan> old debian is old
08:09:54 <orlandu63> there is no cabal port for freebsd either
08:10:05 <geheimdienst> yeah but "old" as in "predates cabal"? unbelievable
08:10:08 <orlandu63> freebsd recommends every haskell library be ported to their ports system
08:11:07 <orlandu63> is debian like that?
08:11:11 <Jafet> You're planning to use cabal-install on a... farm of aging sparc workhorse servers?
08:11:38 <exDM69> I'm looking for a milli-microsecond precision clock that should be unaffected by system time, timezone, etc. Are there alternatives to Data.Time.Clock?
08:11:38 <Jafet> Your mother-in-law's 486?
08:12:09 <Baughn> exDM69: What do you need it for?
08:12:11 <Jafet> Some systems don't keep milli-microsecond precision of any kind
08:12:19 <Jafet> Therefore what you ask for is inherently unportabe
08:12:21 <geheimdienst> no, i'm an arch user and very happy with it ... there's just this dude on #xmonad who uses debian stable and can't find random packages. turns out, he's using xmonad 0.7 which is ancient, and has no cabal installed
08:12:22 <Baughn> Right. Like PCs, for most purposes..
08:12:22 <exDM69> Baughn: measuring network round trip time
08:12:26 <Jafet> s/e$/le/
08:12:34 <Baughn> exDM69: And you need microsecond precision?
08:12:39 <exDM69> found a package called clock, that seems to be good
08:12:48 <exDM69> Baughn: milliseconds are fine
08:14:50 <Baughn> exDM69: THen getCurrentTime should do.
08:15:23 <exDM69> Baughn: that gets messed up if the system time zone is changed
08:15:31 <exDM69> or the time adjusted
08:15:41 <exDM69> cronned ntpdate job or whatever
08:15:51 <Baughn> exDM69: Why would the system time zone affect it?
08:16:08 <Baughn> As for the latter, that's why you use *ntpd*, not ntpdate
08:16:23 <edwardk> preflex: xseen saizan
08:16:23 <preflex>  saizan was last seen on freenode/#haskell-blah 1 minute and 1 second ago, saying: silly parens.
08:16:30 <edwardk> hah, well that was easy
08:16:43 <Jafet> How is absolute time relevant to measuring network rtt, anyway?
08:17:10 <edwardk> Saizan: around?
08:17:27 <Baughn> exDM69: You don't put ntpdate in a cron job. You just don't. It only exists to set the clock at bootup.
08:17:29 <exDM69> Baughn: getCurrentTime is affected by the timezone, isn't it?
08:17:46 <Baughn> exDM69: Check its return type, then ask me again.
08:17:48 <Saizan> edwardk: yup
08:18:34 <exDM69> Baughn: it's UTCTime
08:18:41 <edwardk> Saizan: playing around with http://github.com/ekmett/speculation/blob/master/Control/Concurrent/STM/Speculation.hs -- i conjecture that i should be able to use the same Codensity STM trick to make a 'traverseSTM' that deals with speculation
08:18:55 <Baughn> exDM69: Right.
08:19:04 <edwardk> the one we worked out forever ago for the Codensity STM oracle trick
08:20:13 <edwardk> since it comes down to basically the same codensity time travel trick
08:20:29 <edwardk> specBySTM' in there does the retrying
08:20:56 <Baughn> exDM69: (You realize the implications, right?)
08:21:06 <exDM69> Baughn: and what if I change my system time while my program runs?
08:21:21 <Baughn> exDM69: Then it'll give you wrong results. Don't *do* that.
08:21:31 <Baughn> exDM69: Use NTPd and skew the system clock instead.
08:22:37 <romildo> Hi.
08:23:32 <Saizan> edwardk: i'm not sure what a speculation enabled traverseSTM should do though :)
08:24:40 <edwardk> Saizan: heh, well, the idea is to be able to comply with the rollback semantics mentioned in the paper http://research.microsoft.com/pubs/118795/pldi026-vaswani.pdf
08:24:51 <exDM69> Baughn: well isn't using getTime Monotonic (from System.Posix.Clock) better because it isn't affected by the system clock?
08:27:28 <edwardk> traverseSTM :: (Traversable f, Eq a) => (Int -> STM a) -> (a -> STM b) -> f a -> STM (f b)
08:28:04 <edwardk> er (Int -> STM b)
08:28:13 <romildo> I am writing a "read state error" monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26604#a26604
08:28:14 <romildo> ghc is showing the following error: Util/RSE.hs:6:12: Parse error in pattern,  and I am not seeing what is wrong. Any help?
08:29:05 <alexyk> Cale: how did you suggest to do Map.toAscList with builder again?
08:29:14 <alexyk> and whats builder?  :)
08:30:06 <p_l|backup> Baughn: ... I need some advice on reactive programming in multithreaded environment. Namely, how the hell to get *some* order without crazy locking
08:30:40 <alexyk> how do we search #haskell logs?
08:30:53 * p_l|backup is trying to transplant that to Common Lisp
08:31:07 <edwardk> there needs to be a MonadSTM somewhere
08:32:13 <mauke> romildo: x y is not a valid pattern
08:32:27 <mauke> where x = runRSE and y = k
08:33:12 <romildo> of course, it should be RSE instead of runRSE. Thanks.
08:54:22 <Saizan> edwardk: i think i'd need a "specSTMSTM :: Eq a => STM a -> (a -> STM b) -> STM a -> STM b"
08:54:48 <edwardk> Saizan: hrmm
08:55:19 <edwardk> not sure how that would work
08:57:25 <Saizan> "traverseSTM g f xs = flip unC return $ traverse (\a -> C $ \k -> specSTM (g undefined) (k =<<) (f a)) xs" -- naively got here, but that requires Eq (STM a)
08:59:40 <edwardk> Saizan: hrmm
09:00:03 <edwardk> Saizan:  well the thought at the time was to use codensity instead of stm and then backtrack during retry
09:00:58 <edwardk> using the machinery in needRef from here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg69730.html
09:01:33 <edwardk> but replacing the needRef plumbing with bowels of specSTMBy'
09:01:37 <Saizan> i'm using "newtype Codensity f a = C { unC :: forall r. (a -> f r) -> f r }" in the line above
09:01:48 <edwardk> oh =)
09:02:15 <Saizan> so, yeah, with a specialized specSTM it should work out
09:02:27 <edwardk> if you're using specSTM there, can't there be a join or something?
09:02:39 <edwardk> or can i just make the comparison monadic?
09:03:03 <edwardk> (a -> a -> STM Bool)
09:03:19 <Saizan> that'd work for the Eq a => part
09:04:44 <Saizan> though you'd end up parallelizing (f a) which is a STM action, so probably not so useful?
09:05:12 <Saizan> or, well, i'm not sure what should we parallelize here..
09:05:34 <Saizan> the field inside the traversable?
09:05:43 <Saizan> and not the application of f to it?
09:07:02 <edwardk> well in general if we look at speculating specSTM :: Eq a => a -> (a -> STM b) -> a -> STM b -- we speculate during specSTM g f a the evaluation of a with the evaluation of f g. if that a turned out to be wrong, we just roll back that transaction and try it again with f a
09:07:18 <edwardk> so no two transactions are happening simultaneously there
09:07:23 <Saizan> right
09:08:09 <edwardk> now i haven't gone through the details of the speculation rules in http://research.microsoft.com/pubs/118795/pldi026-vaswani.pdf , but my impression was they weren't all that tricky
09:08:27 <Saizan> but during a traverse you've (a :: a) (f :: a -> STM b) (g index :: STM b)
09:08:55 <Saizan> you mean the huge wall of inference rules in figure 2?:)
09:09:02 <edwardk> yeah
09:09:38 <edwardk> options i suppose:
09:10:00 <edwardk> we could make specSTM :: Eq a => a -> (a -> STM b) -> a -> IO b
09:10:08 <edwardk> that would let us fork to get additional STM tasks
09:12:27 <edwardk> did you see the code in Data.Foldable.Speculation for now i'm doing the other folds?
09:12:32 <edwardk> er for how
09:12:58 <edwardk> none yet are in STM, but they might provide a framework
09:13:22 <edwardk> hah i thought the wall of inference rules drove you off ;)
09:13:47 <edwardk> did you see the much easier combinators in data.foldable.speculation ?
09:14:05 <Saizan> yup, i started from there actually
09:14:11 <edwardk> ah k
09:15:05 <Saizan> "mf a (Acc n b) = let n' = n + 1 in Acc n' (specBy' cmp (g n') (f a) b)" <- much easier to speculate over the tail/accumulator when it's pure :)
09:15:14 <edwardk> =)
09:15:39 <edwardk> they started out a bit uglier, i only just moved them into using Foldable.foldr
09:15:55 <edwardk> but overall the flavor is the same
09:16:27 <edwardk> so your codensity block above, does that compile?
09:17:21 <edwardk> modulo index considerations, etc.
09:18:34 * ddarius refreshes the speculation hackage page to see how how the version number went.
09:18:41 <edwardk> hahaha
09:19:13 <edwardk> i ripped out the Speculative class and implemented variants on all the Foldable combinators
09:19:16 <ddarius> 0.0.2 -> 0.3.0
09:19:46 <edwardk> working with Saizan now to get an STM friendly speculative traverse
09:21:13 <edwardk> thinking about shuffling namespaces around a bit, at least merging the Control.Concurrent.STM.Speculation back into Control/Concurrent.Speculation
09:22:21 <Saizan> edwardk: this compiles http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26605#a26605
09:22:58 <edwardk> that looks pretty much like what i'm after. i'll add the fiddly index bitgs
09:23:20 <Saizan> s/undefined/g undefined/ for more relevance
09:23:42 <Saizan> and fill in the Eq (STM a) instance ;)
09:24:04 <edwardk> well, i already made specBySTM take an (a -> a -> STM Bool) instead
09:24:08 <edwardk> so that is easier ;)
09:27:38 <edwardk> i should also do STM variants of the various combinators in Data.Foldable.Speculation that take monads
09:27:50 <edwardk> :w
09:30:28 <Berengal_> Why is it so hard to do raster graphics these days?
09:30:39 <shajen> @djinn (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
09:30:40 <lambdabot> f a b c d = a b (c d)
09:30:41 <jix> is there some preprocessor define that is set if profiling is active?
09:30:44 <edwardk> at some point i should probably benchmark this lib to make sure it actually can speed things up in some cases ;)
09:30:54 <AqD|Home> is it bad to use a lot of non-tail recursions despire they're cleaner??
09:30:56 <shajen> @djinn  (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:30:57 <lambdabot> f a b c d = a (b c d)
09:31:11 <AqD|Home> like a simple myreverse (x:xs) = myreverse xs ++ [x]
09:33:10 <AqD|Home> hmmm
09:33:14 <AqD|Home> night
09:33:45 <Saizan> edwardk: that'd be cool :)
09:35:13 <Saizan> AqD|Home: since haskell is a lazy language if you can produce your result incrementally tail recursion is actually worse for performance
09:36:06 <Saizan> AqD|Home: though in the case of reverse your definition has a quadratic running time, while the optimal solution is linear
09:36:20 <Saizan> ?src map
09:36:20 <lambdabot> map _ []     = []
09:36:20 <lambdabot> map f (x:xs) = f x : map f xs
09:36:39 <Saizan> ^^^ a proper use of non-tail but rather guarded recursion
09:37:03 * Baughn longs for dependent types
09:39:54 <tensorpudding> Agda is just a cabal install away...
09:40:11 <Baughn> Correction.
09:40:13 * Baughn longs for dependent types in haskell
09:40:27 <zygoloid> she?
09:40:35 * Saizan is not sure if Baughn would like to code up an universe
09:40:48 * Baughn would enjoy that
09:40:48 <Saizan> though Coq's typeclasses might fit instead..
09:41:42 <shajen> @djinn  (a -> b -> c) -> a -> b -> c
09:41:42 <lambdabot> f a = a
09:41:55 <Saizan> nice verb there.
09:43:21 <edwardk> Saizan: technically guarded corecursion, no?
09:44:05 <edwardk> hrmm the (a -> a -> STM Bool) -- shouldn't be necessary for the comparison
09:44:38 <edwardk> ah
09:44:41 <Saizan> edwardk: i guess it depends on which fixpoint we use :)
09:44:44 <edwardk> your signature wants something like
09:45:20 <edwardk> specBySTM' :: (STM a -> STM a -> STM Bool) -> STM a -> (STM a -> STM b) -> STM a -> STM b
09:45:36 <edwardk> hence the need for Eq (STM a)
09:45:48 <Saizan> yeah
09:46:24 <edwardk> so if we replace all the STM a's in there with a's you get my current signature
09:46:43 <edwardk> with the addition of the STM on the Bool
09:46:49 <edwardk> which i'm more than happy to add in
09:47:20 <Saizan> mh, though i'm not sure how sharing would work out than
09:47:22 <edwardk> i'm somewhat terrified of when all these effects will happen ;)
09:47:23 <Saizan> *then
09:47:24 <edwardk> yeah
09:49:25 <romildo> I am needing some help on finishing the catchError method of the "read state error" monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26606#a26606
09:49:56 <edwardk> Saizan: would it make more sense to tackle something like: foldrSTMBy :: Foldable f => (b -> b -> Bool) -> (Int -> STM b) -> (a -> b -> STM b) -> b -> f a -> STM b -- as a starting point?
09:50:44 <romildo> The error I am getting on line 35 is:
09:50:46 <romildo>    Couldn't match expected type `Either e1 (a, s)'
09:50:46 <romildo>            against inferred type `RSE r s e a1'
09:50:46 <romildo>     In the expression: h e
09:50:51 <romildo> Any help?
09:53:24 <Saizan> edwardk: i guess it'd be easier to compare to the pure version
09:54:29 <b0fh_ua> Hello! Can somebody please explain what may be wrong with the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26607#a26607 ?
09:54:31 <Saizan> romildo: you've to use "runRSE (h e) r s" there
09:58:01 <Saizan> b0fh_ua: add {-# LANGUAGE NoMonomorphismRestriction #-}
09:58:47 <romildo> Saizan, when catching an error in this monad, the idea is to continue with the same state available immediately before the error happened, right?
09:59:21 <romildo> Saizan, thanks for pointing it out.
10:00:31 <Saizan> romildo: yep
10:04:49 <mreh> I don't understand this: "(b, c) = f (a, c)"
10:04:53 <b0fh_ua> Saizan: thanks, that helped. Can you please explain what actually did it fix?
10:04:59 <mreh> how it can be a valid expression
10:06:25 <mreh> I suppose they point to different c's
10:07:41 <mreh> but this is in the context of ArrowLoop, in which case it doesn't do much useful
10:09:29 <edwardk> Saizan: hrmm i think it might be easier if we just wrote a specCodensitySTM
10:11:46 <edwardk> i.e. specCodensitySTM g f a = Codensity $ \k -> (f g  >> if a == g then ..) `catchSpeculation` f a
10:14:06 <edwardk> motivated by the fact if i know the comparison has no side effects i know when the side effects have to occur
10:14:52 <Saizan> mreh: no, they are the same c, it's a circular definition
10:15:43 <edwardk> not entirely true
10:16:07 <edwardk> needRef (Ref slot) = Oracle $ \k -> (writeTVar slot Nothing >> k False) `orElse` k True -- reuses the continuation twice
10:16:32 <edwardk> same there
10:16:52 <Saizan> that line was for mreh :)
10:16:59 <edwardk> hahaha
10:17:52 <ManateeLazyCat> What's your favorites music-mplayer UI? I'm design UI of my multimedia player....
10:18:06 <ManateeLazyCat> Better give me name and screenshot. :)
10:19:01 <companion_cube> ManateeLazyCat: mpd+ncmpcpp, but it's not a very friendly UI...
10:19:37 <Saizan> about foldrSTMBy, are we going to run the transaction corresponding to the tail up front and only speculate on the evaluation of its result? otherwise i think we need something fancier than specCodensitySTM i think
10:19:48 <ManateeLazyCat> companion_cube: Yes, mpd is cool, but i can't mplayer video. :)
10:20:12 <companion_cube> hey, you talked about music :þ
10:20:13 <edwardk> hrmm
10:20:36 <duairc> I'm likely doing something wrong with this code, but I don't really understand. Could somebody explain this error to me? https://gist.github.com/0201e8710f6fc2fbbf7a
10:20:56 <ManateeLazyCat> companion_cube: Yes, i want know a exist music-player UI for consult.
10:21:26 <ManateeLazyCat> companion_cube: This is different thing. :)
10:21:48 <companion_cube> then i can't help you, i use mpd and mplayer :)
10:21:52 <Saizan> b0fh_ua: the MonomorphismRestriction forces a definition with no formal parameters that would have a typeclass context to have a monomorphic type, which makes the typechecker try to find a matching instance on the spot, failing as you've seen
10:22:36 <ManateeLazyCat> companion_cube: I have test mplayer with gtk2hs, works well, http://farm5.static.flickr.com/4007/4708981380_d59262b82d_b.jpg
10:22:46 <ManateeLazyCat> companion_cube: Now i want build a frontend for mplayer
10:22:47 <kosmikus> duairc: the signature of typeName contains only "a", but not "m". using typeName therefore does not uniquely determine "m", hence the error. your fundep is the other way round.
10:23:16 <companion_cube> ManateeLazyCat: there are already several of those, no ?
10:23:34 <ManateeLazyCat> companion_cube: But mine is full haskell. :)
10:24:21 <ManateeLazyCat> companion_cube: http://code.haskell.org/gtk2hs/gtk/demo/embedded/
10:24:44 <ManateeLazyCat> companion_cube: I have add Mplayer.hs demo to make mplayer works with gtk2hs.
10:25:28 <ManateeLazyCat> companion_cube: Before i build frontend for mplayer, i want get a cool UI layout.
10:25:55 <companion_cube> well, since i don't use UI... :)
10:26:16 <duairc> kosmikus: That was silly of me, thanks!
10:26:18 <ManateeLazyCat> companion_cube: My UI is speical, Friendly UI + keyboard control ... :)
10:27:12 <ManateeLazyCat> companion_cube: BTW, i can't understand why mpd don't support video. I like mpd's C/S design.
10:27:35 <companion_cube> it could hardly support video without changing its name
10:27:52 <companion_cube> that may be a good enough reason for the team :D
10:28:42 <ManateeLazyCat> companion_cube: Infact, mplayer's "-slave" option is enough for C/S design. :)
10:28:55 <edwardk> hrmm you may be right
10:29:13 <b0fh_ua> Saizan: not clear still. but okay
10:29:16 <edwardk> trying to think what it would mean to have to retry after we started k result
10:29:42 <ManateeLazyCat> companion_cube: I use Emacs as mplayer's UI now, but Emacs don't support multi-thread, i don't want Emacs freeze me when it's scan music directory.
10:30:38 * companion_cube does not see why using emacs that much -_-
10:30:53 <ManateeLazyCat> companion_cube: EMMS.
10:31:15 <ManateeLazyCat> companion_cube: http://www.emacswiki.org/emacs/EMMS
10:31:28 <companion_cube> emacs is definitely not a text editor, but rather an OS in lisp
10:31:52 <ManateeLazyCat> companion_cube: If you like, you can try my http://www.emacswiki.org/emacs/anything-emms.el , search music for play.
10:32:12 <companion_cube> no thanks, i try not to use emacs
10:32:13 <ManateeLazyCat> companion_cube: Emacs is Single-Thread OS, i hate it.
10:33:15 <Saizan> b0fh_ua: e.g. if you define "f = show" the inferred type would be Show a => a -> String, but since f doesn't have parameters (i.e. it's not f x = show x) then the MR kicks in, and the "Show a" must go. if somwhere else in the module you've "f True" then the typechecker will decide f :: Bool -> String, and it'll be able to resolve Show Bool, if you haven't used f at all the type variable will remain unspecified
10:33:21 <edwardk> Saizan: can you sanity check something: the logic i have right now keeps me from catching anyone else's speculations... but they should never be able to reach me, no? if they are a child speculation they get caught
10:34:07 <edwardk> with the codensity noise that might not be the case, but with the basic specBySTM do you think i being too paranoid?
10:34:07 <Saizan> b0fh_ua: which leaves GHC asking for an instance of Show that'd work for a generic 'a', which doesn't exist and it'll fail
10:34:17 <Saizan> b0fh_ua: it's a fairly arbitrary restriction.
10:34:37 <zygoloid> is there a take/drop/splitAt equivalent for splitting relative to the end of a list?
10:35:26 <Saizan> edwardk: what do you mean by too paranoid?
10:35:27 <zygoloid> (underlying problem: i want to strip some known suffix from a string if it's present)
10:35:37 <ddarius> zygoloid: You could reverse, split, reverse, but working relative to the end of a singly linked list is not a good idea.
10:36:00 <zygoloid> ddarius: the string is short and i don't really care about efficiency
10:36:12 <edwardk> i mean if you look at the Speculation Exception i use, i wrap an Int and get paranoid that the speculation i'm catching is the same one i expect to have thrown
10:36:35 <Saizan> edwardk: ah, ok, guessed right :)
10:36:39 <edwardk> but since I'm the only source of exceptions, and any nested exceptions are handled...
10:36:47 <ddarius> zygoloid: Then reverse, split, reverse, should work well enough, and you can probably omit that last reverse if you don't mind your code being slightly less obvious.
10:37:02 <ManateeLazyCat> companion_cube: What player features would you most want?
10:37:06 <ddarius> Also, the FilePath functions might be able to do what you want.
10:37:10 <companion_cube> ManateeLazyCat: none
10:37:17 <Saizan> edwardk: yeah, that seems superflous
10:37:28 <ManateeLazyCat> companion_cube: none?
10:37:48 <companion_cube> well, i'm happy with mplayer command line
10:37:49 <edwardk> Saizan: can you pull from a git repo?
10:38:58 <zygoloid> ddarius: thanks. i've gone with splitAtR n = (reverse *** reverse) . splitAt n . reverse
10:39:33 <Saizan> edwardk: git pull <remote> <branch>
10:39:36 <ManateeLazyCat> companion_cube: Friendly playlist +++ binding many keystroke for mplayer command, do you like?
10:40:30 <edwardk> Saizan: git@github.com:ekmett/speculation.git
10:40:43 <b0fh_ua> Saizan: cool, thanks. That's clear now
10:40:45 <edwardk> that at least gets us up to speed with the same version of Codensity, etc.
10:41:15 <edwardk> Control/Concurrent/Speculation now contains the basic spec combinators, STM versions, and probably broken Codensity STM versions
10:44:41 <ManateeLazyCat> companion_cube: Thanks for you suggestions.... :)
10:46:23 <edwardk> going deeper on the original paper to see what they do for 'rollback freedom' analysis
10:46:52 <Saizan> edwardk: isn't specCSTM g f a = Codensity $ \k -> specSTM g (\a -> lowerCodensity (f a)) a >>= k ?
10:47:27 <edwardk> yeah i think so
10:47:37 <edwardk> in which case codensity buys us nothing
10:47:44 <edwardk> at least at this level
10:49:03 <edwardk> i just finished unraveling the fact that i never wanted the exception to close over the entire continuation as you were saying that =)
10:49:16 <edwardk> er never wanted the catch handler
10:49:47 <edwardk> so i'm going to lobotomize things a bit. I'll keep the specByCSTM combinators, but will rewrite them in terns of the basic specBySTM combinators
10:50:03 <edwardk> and i'm going to kill the unique id assignment in my Speculation exception
10:51:38 <Saizan> makes sense
10:52:02 <Saizan> then we'll be roughly where i've started :)
10:52:13 <edwardk> hah. i'm slow ;)
10:58:40 <edwardk> ok, repushed with those changes
10:59:47 <Saizan> ok :)
11:01:07 * ManateeLazyCat Found gdk_x11_drawable_get_xid is better way to embedded x11 program, more stable than GtkSocket.... haha...
11:02:58 <edwardk> hrmm, if you have the paper handy, i'm wondering if STM is the right model at all for the kinds of variables that are nicely speculated
11:03:14 <edwardk> section 3.2 seems to describe a very different set of semantics
11:03:32 <edwardk> i wonder if a suitable Applicative could be defined that would support their static analysis directly
11:05:47 <chrisdone> @quote medfly
11:05:47 <lambdabot> medfly says: Haskell is zero maintenance because you can't get anyone to maintain it. (:
11:05:59 <chrisdone> that backfired
11:06:08 <chrisdone> @vixen say something sweet, quick!
11:06:08 <lambdabot> Do you think you would pass a Turing test?  I have.
11:06:35 <alise> Is it possible to bind tighter than function calls? I think it isn't. i.e., to have (a#b c) be ((a#b) c).
11:06:43 <alise> If it is possible, what precedence should I use?
11:06:45 <Saizan> edwardk: something with regions? anyhow i'm not in the right shape to follow this atm :)
11:07:11 <edwardk> alise: not arbitrarily. there are some builtins that do like {}'s in the record syntax, ~ and @, etc.
11:09:47 <zygoloid> alise: what do you want to bind so tightly? maybe there's another way
11:09:59 <alise> zygoloid: there is indeed :)
11:10:01 <alise> and i figured it out
11:10:02 <alise> thanks anyway
11:11:40 <Wolfspaw> Hi guys, good afternoon. Im reading "Learn you a haskell" and i have a doubt about one part. Explained and code here:
11:11:48 <Wolfspaw> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26608#a26608
11:12:26 <edwardk> Saizan: actually i think we're okay overall. we ultimately provide the same consistency guarantees as section 3.2, just by another mechanism
11:12:52 <Botje> Wolfspaw: uh, you left out a parameter
11:13:07 <zygoloid> Wolfspaw: the parentheses are only required to apply the entire function to 8.9
11:13:39 <zygoloid> Wolfspaw: another way of writing it is: let fn = sum . replicate 5 . max 6.7 in fn 8.9
11:14:03 <Wolfspaw> hm, i got it! thanks xD
11:15:56 <alise> is higher or lower tighter for precedence?
11:16:24 <aavogt> higher is tighter
11:16:47 <alise> thanks
11:17:08 <danharaj> you can remember it by the broken rhyme
11:17:15 <danharaj> or the alliteration of "lower is looser"
11:17:34 <alise> which broken rhyme?
11:17:39 <danharaj> higher/tighter
11:17:40 <alise> oh, higher is tighter
11:18:47 <alise> Why do where clauses only apply to one pattern matching clause?
11:19:23 <shajen> @djinn (b -> c) -> (a -> b) -> a -> c
11:19:24 <lambdabot> f a b c = a (b c)
11:19:30 <aavogt> because     f a b c = ... where x = (expression with a b c in scope); f _ _ _ = ... 
11:19:31 <shajen> @djinn b -> c -> (a -> b) -> a -> c
11:19:31 <lambdabot> f _ a _ _ = a
11:20:04 <aavogt> alise: it's rather arbitrary, but it would be a bit less useful if where belonged to multiple equations
11:20:11 <alise> aavogt: Okay, then. What should I do if I want to have a where over multiple equations?
11:20:16 <alise> Avoiding it would make the code significantly uglier.
11:21:06 <aavogt> you can use pattern guards
11:21:11 <danharaj> I was about to say
11:21:13 <aavogt> a case expression
11:21:41 <danharaj> alise: pattern guards are really nice, they basically let you pattern match in guards, instead of just boolean tests.
11:22:17 <alise> danharaj: But, also, not what I want.
11:22:22 <alise> I just want a variable bound. :P
11:22:45 <Botje> | Just foo <- lookup bar env
11:23:07 <danharaj> alise: It is what you want. Instead of having multiple equations, you can have one equation with each pattern match being a guard, so your where clause scopes over all of them.
11:23:28 <alise> danharaj: foo x | x == Bar = ...
11:23:31 <alise> that seems a bit ... stupid
11:23:49 <danharaj> foo x | Bar <- x = ...
11:23:58 <noteventime> alise: Since you want it to range over multiple equations it seems that it could not depend on any the parameters of the function, can't you just bind it top-level?
11:24:06 <alise> danharaj: Well, okay.
11:24:10 <alise> Actually, that might be better for this...
11:24:20 <alise> Can they have variables, though?
11:24:24 <alise> foo x | Bar y <- x = ...
11:24:34 <alise> noteventime: It depends on one parameter of the function.
11:24:57 <noteventime> Then perhaps make it a toplevel function?
11:25:08 <dafis> alexyk: sent review
11:26:00 <alise> noteventime: Nah... it'd be more verose than not binding it.
11:26:07 <alise> danharaj: Can't do that. It's pattern-matching a GADT.
11:26:13 <alise> Type stuff won't go unless I use proper pattern matching.
11:29:54 <noteventime> alise: Perhaps an outer function to bind the variable and then an inner function for pattern matching the GADT
11:30:29 <alise> noteventime: It's already in a where clause; that'd be a large doubly-nested where clause. Plus a three-times-nested where clause for the short thing I'm putting in the where I'm talking about.
11:30:31 <alise> In short, AIEEEEEEEEEEEEEE
11:30:42 <noteventime> Haha
11:30:43 <noteventime> Ouch
11:31:36 <alise> Actually, only two nestings, but still.
11:31:40 <alise> Just tried it. Aieee, my eyes.
11:31:46 <ddarius> I've used thrice nested wheres before.
11:31:59 <alise> ddarius: Yeah ... but you're crazy ...
11:39:53 <b0fh_ua> Guys, can somebody please help me with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26609#a26609. I want to not return list of ResponseParam objects, instead I want to update initMap with some function. How do I do that with Parsec?
11:43:00 <dafis> b0fh_ua, use the state?
11:43:58 <b0fh_ua> dafis: I'm not sure how to do this way, because I still need to consume entire input and not product any result except that Map
11:44:39 <b0fh_ua> probably manyTill is not good soluition, but I don't know how to force Parsec to consume all input and invoke a function on each successfully parsed chunk
11:46:00 <dafis> b0fh_ua, at the start, setUserState initMap, then let every parser update the state, at the end return the updated map via getUserState
11:49:56 <int80_h> I'm trying to install haskell platform, and I have two versions of ghc installed. How do I tell configure to look at the proper one?
11:50:11 <int80_h> or do I just need to uninstall the old ghc?
11:50:52 <b0fh_ua> dafis: so instead of manyTill use recursive call to self and update state?
11:50:57 <dafis> int80_h, does ./configure --help list a configure option for the compiler to use?
11:51:10 <shajen> @djinn (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
11:51:11 <lambdabot> f a b c d = a b (c d)
11:51:17 <dons> int80_h: i think it is --with-ghc or some such
11:51:22 <shajen> @djinn (a1 -> (b -> c)) -> a1 -> (a -> b) -> a -> c
11:51:22 <lambdabot> f a b c d = a b (c d)
11:51:29 <shajen> hurray
11:51:31 <dons> int80_h: assuming you're using the linux src installer?
11:51:35 <dons> go djinn!
11:51:55 <Phyx-> "djinn" reminds me of golden sun...
11:51:58 <dafis> b0fh_ua, Yes, but you must make sure to break out properly when the parser fails
11:51:58 <int80_h> dafis: oh crap, I see it needs 6.12.1 and I just spent the last 4 hours installing 6.12.3
11:52:16 <int80_h> dafis: I thought it was looking at the 6.8 one, didn't read close enough
11:52:40 <int80_h> dafis: do you think 6.12.3 is that much different from 6.12.1?
11:53:24 <dafis> int80_h, not much, a few bug-fixes, the platform might or might not work with it
11:53:58 <edwardk> yay an hour later i finally figured out (non-STM) speculative foldrByM
11:55:38 <dafis> edwardk, I don't know what speculative foldrByM is meant to be, but it sounds cool
11:55:43 <edwardk> dafis =)
11:56:00 <dafis> edwardk, short explanation?
11:56:11 <edwardk> foldrByM :: (Foldable f, Monad m) => (m b -> m b -> Bool) -> (Int -> m b) -> (a -> b -> m b) -> m b -> f a -> m b -- where the first two functions are used to 'guess' intermediate answers
11:56:21 * geheimdienst founds a boy-band named Speculative FoldrByM
11:56:41 <edwardk> the first function is used to compare intermediate monadic results (i.e. did i get back the same list) and can usually just be (==)
11:57:12 <edwardk> the second is a hopefully better than blind user-supplied guess at what the answer of folding over the last n terms of the container will be
11:57:47 <edwardk> folding then proceeds to evaluate using the (fast) guesses, and retries the intermediate states when the guesses were wrong
11:58:06 <dafis> edwardk, awesome
11:58:19 <edwardk> as an example you could build a monadic lexer, which tried to guess based on a limited about of context what state it was in
11:58:34 <edwardk> but which will never give a different answer than the original non-speculative lexer
11:59:00 <dafis> edwardk, awesomer and awesomer
11:59:22 <edwardk> take a look at the description for spec in http://hackage.haskell.org/packages/archive/speculation/0.2.0/doc/html/Control-Concurrent-Speculation.html 
11:59:29 <edwardk> the package has evolved quite a bit since last night though
12:02:41 <dafis> edwardk, Wow!
12:03:03 <alexyk> dafis: thanks for the review!
12:03:09 <edwardk> =)
12:03:42 <dafis> alexyk: You still need to clean the code up before publishing :)
12:03:46 <edwardk> i've been geeked about this approach for 2-3 weeks now, but couldn't get anyone to care about it at all. so i finally just decided to start writing a library
12:04:04 <alexyk> dafis: I consider it a work in progress :)
12:04:44 <dons> dafis: oh, you did a review of alexyk's code?
12:05:33 <dafis> edwardk, I don't see myself using it in the foreseeable future, but I just *have* to read the sources and figure out how you do it. When's the next release scheduled?
12:05:47 <edwardk> in an hour or so ;)
12:05:55 <dafis> dons: Just looking at which bangs help and which don't
12:06:04 <edwardk> http://github.com/ekmett/speculation
12:06:21 <edwardk> is relatively current, modulo, the foldrM and foldrSTM code
12:06:29 <dafis> edwardk, thx
12:07:03 <dons> dafis: good work.
12:07:19 <edwardk> http://github.com/ekmett/speculation/blob/master/Control/Concurrent/Speculation/Internal.hs is how i cheat and inspect thunks for evaluatedness.
12:07:30 <alexyk> dafis: the current head of mapfold branch added an attempt to disintern the dcaps graph before writing.  However, that suddenly blows up and sinks the box.  Can you please see what I'm possibly missing?  it's all in the small driver program, sc.hs itself.  That doesn't incorporate your latest changes yet.  Tag cafe7
12:08:01 <dafis> alexyk: Will look
12:08:52 <alexyk> For now I had to add an option where the ByteString<=>Int dictionary is "none" and then the int dcaps is written, which works through; but strange how the already loaded dictionary leads to explosion.
12:11:23 <alexyk> back later...
12:12:15 <dafis> edwardk, looks deceivingly simple at the first glance
12:12:35 <edwardk> dafis that is the goal =)
12:13:22 <edwardk> http://github.com/ekmett/speculation/blob/master/Data/Foldable/Speculation.hs is where i put it to work so far
12:14:09 <edwardk> i'm currently trying to plumb through STM based speculative folds, traversals, etc with rollback into there
12:14:18 <edwardk> I have the folds working, traversals are next
12:16:28 <dafis> edwardk, just for the awesomeness of it or have you a practical need?
12:16:52 <edwardk> dafis: i wanted to try out some speculation inside of my ad engine
12:17:20 <dafis> edwardk, any results already?
12:17:26 <edwardk> not yet
12:17:29 <edwardk> still writing this lib
12:20:18 <int80_h> haskell platform is giving me the following error "configure: error: The OpenGL C library is required"
12:20:33 <int80_h> I googled this, and it seems there's no solution mentioned for debian lenny
12:21:06 <int80_h> is this a known issue? something I might be doing wrong? I tried installing things that looked like OpenGL libraries, plus dev libraries.
12:22:21 <dons> int80_h: missing the opengl dev headers, i'm guessing. 
12:22:29 <dons> look at what the haskell-platform package in apt depends on
12:22:43 <dons> int80_h: http://packages.debian.org/sid/haskell-platform
12:26:43 <ManateeLazyCat> It's strange, gdkx.h under /usr/include/gtk-2.0/gdk (with pkg-config --cflags gtk+-2.0), and gdk_x11_drawable_get_xid has define in gdkx.h file. But i got error "Cannot find a definition for `gdk_x11_drawable_get_xid' in the header file."... so strange... I forgot something? 
12:28:43 <augur> haskelliers: are partial functions really partial, or are they total over a different domain?
12:29:35 <aavogt> does that matter if you can't enforce that you only use that different domain?
12:29:56 <augur> good question!
12:30:49 <zygoloid> augur: both!
12:31:14 <augur> i think that answers my deeper question on the relevance of totality vs. partiality
12:31:16 * ManateeLazyCat Should work, but why can't work? I must be missing something ...
12:34:00 * ManateeLazyCat Tonight is crazy night... 
12:34:40 <augur> why are you speaking in actions
12:39:06 <monochrom> because in monadic mood. actions.
12:40:08 <triyo> I have a Show instance for my Data Type that has quite a few Maybe constructor fields. My show function implementation looks very messy with-all the pattern matching and all http://gist.github.com/455122
12:40:36 <triyo> I'm sure there is a better way to write this.
12:41:07 <mreh> (*)  (0_0)<-  ->  ~o0
12:41:39 <geheimdienst> > (*) (0_0)<- -> ~o0
12:41:40 <lambdabot>   <no location info>: Parse error in pattern
12:41:56 <mreh> can you tell what it is yet?
12:44:57 <triyo> anyone? :)
12:45:51 <aavogt> triyo: use maybe
12:45:53 <aavogt> the function
12:46:11 <geheimdienst> triyo, you know, i'm kind of having the same problem. when you have a huge-ass record, you maybe can't initialize it all at once but have to do it in stages, which means there's loads of Maybes in there :-(
12:46:11 <ManateeLazyCat> triyo: maybe "" (...) ...
12:46:26 <mreh> don't use Show either I suppose, that's supposed to be used with Read
12:46:37 <ManateeLazyCat> triyo: use 'maybe', you will merge *two* lines in *one* line.
12:47:22 <ManateeLazyCat> triyo: If is me, i will use "deriving Show" . :)
12:47:22 <mreh> nested maybes
12:47:45 <mreh> he clearly wants to make it into a nicely formatted string
12:47:48 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26611#a26611
12:48:38 <mreh> not nested maybes, but a nested function that will reduce it down further
12:48:47 <triyo> I have a applicative parser that builds a TodoEntry, I'd like to have a Show instance that stringify's the process
12:49:37 <ManateeLazyCat> triyo: My suggestion, newtype your filed type, then write Show instance for those newtype, after then, you just need write "deriving Show" for TodoEntry. :)
12:49:48 <triyo> stringify's the process, I mean bring it back into its string representation. 
12:51:22 <ManateeLazyCat> triyo: Then you don't need write everything in "Show TodoEntry", and easy to maintain. :)
12:51:53 <triyo> ManateeLazyCat: thanks for that suggestion, that sounds much neater.
12:54:11 <ManateeLazyCat> triyo: IMO, when my filed has similar type, such as "Maybe String", "Maybe Double", i will give it's sense name, example: TodoEntry {milestone :: Milestone, action :: Action, users :: Users ...}, then i can know what's when i first read those type.
12:55:14 <ManateeLazyCat> triyo: Otherwise, when you mix your "Maybe String" with other "Maybe String", you need spend time to distinguish the difference.
12:55:25 <triyo> thanks, I'll give them meaningful names 
12:55:52 <triyo> Also, another question. If I have a Data Type with many Maybe fields, its somewhat of a pain to stipulate every time Nothing explicitly for the fields I wish to ignore on occasions. Is the solution to create alternative constructors. 
12:56:09 <ManateeLazyCat> triyo: I have those code.
12:56:31 * ManateeLazyCat pasted "Maybe library" at http://paste2.org/get/894875
12:56:33 <ManateeLazyCat> triyo: Above.
12:56:53 <ManateeLazyCat> triyo: Looks ?>=> >?>=> ?>= >?>=
12:57:19 <ClaudiusMaximus> triyo: data Foo a = Foo0 | Foo1{ x :: a } | Foo2{ x :: a, y :: a } | Foo3{ x :: a, y :: a, z :: a }  -- should work if the common named fields have the same type
12:58:03 <triyo> great thanks
12:58:05 <ManateeLazyCat> triyo: Oh, you mean "alternative constructors.", i misunderstand.
12:58:08 <aristid> :t (~>)
12:58:09 <lambdabot> Not in scope: `~>'
12:58:15 <aristid> lambdabot: you are a forgetful beast.
12:58:16 <monochrom> deriving Show
12:58:28 <aristid> @hoogle ~>
12:58:28 <lambdabot> No results found
12:59:05 <ClaudiusMaximus> if you leave fields uninitialized, at least GHC sometimes gives useful error messages at runtime when you access them
12:59:26 <Twey> It gives compile-time errors
12:59:32 <ManateeLazyCat> triyo: http://paste2.org/get/894875 have some useful code for handle Maybe branch. :)
12:59:59 <triyo> thanks for the code
13:00:00 <ClaudiusMaximus> Twey: compile-time warnings, runtime exceptions
13:00:37 <Twey> Ah, aye
13:01:07 <Twey> ManateeLazyCat: Er, half of this stuff is reduplication (and specialisation) of standard library functions.
13:01:08 <ClaudiusMaximus> by useful i meant "includes source code location"
13:01:23 <ManateeLazyCat> Twey: Which one?
13:03:10 <Twey> ManateeLazyCat: maybeAlternative = flip fromMaybe, maybeApply = flip fmap
13:03:13 * hackagebot speculation 0.5.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.5.0 (EdwardKmett)
13:04:51 <Twey> maybeApplyM = maybe (return Nothing) (return . Just), though that one's a bit pointless in most cases
13:05:11 <edwardk> now to tackle the thousand pound gorilla, traverseSTM
13:06:38 <Taejo> is a commutative monad one where do {x <- a; y <- b; f x y} = do {y <- b; x <- a; f x y} ?
13:06:52 <edwardk> Taejo: that would be the idea
13:06:59 <Twey> Some of these later ones have even been written as straight synonyms of standard functions
13:12:44 <Twey> maybeBranch = const id `maybe` const id
13:12:51 <ManateeLazyCat> Twey: maybeApplyM m f = maybe (return Nothing) (liftM Just . f) m
13:12:55 <Twey> (damn you, lower-order polymorphism)
13:13:09 <Twey> :t maybe (return Nothing) (return . Just)
13:13:11 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> m (Maybe a)
13:13:20 <ManateeLazyCat> Twey: maybeApplyM :: Monad m => Maybe a -> (a -> m b) -> m (Maybe b)
13:13:30 <ManateeLazyCat> Twey: Different. :)
13:13:31 <Twey> Ah, yeah — extra transformation, sorry
13:15:38 <ManateeLazyCat> Twey: I prefer to write some function to make "Maybe a" at first place, then i can write "foo MaybeFoo $ \bar -> ..." don't need parentheses. :) 
13:18:01 <Twey> ManateeLazyCat: I think reversing the association of $ would serve you better
13:18:20 <Twey> Then you can write: foo $ flip fmap $ \bar ->
13:19:14 <ManateeLazyCat> Twey: I try to avoid use flip in my API code. :)
13:19:28 <ManateeLazyCat> Twey: But library code okay.
13:20:04 * Twey scratches his head.
13:20:13 <ManateeLazyCat> Twey: When i write flip everywhere, i need spend time to think code sequence, i want view code on the fly... 
13:20:49 <ManateeLazyCat> :t const id `maybe` const id
13:20:50 <lambdabot> forall a a1. Maybe a1 -> (a -> a) -> a -> a
13:20:56 <ManateeLazyCat> maybeBranch :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
13:21:07 <ManateeLazyCat> Twey: Another different. :)
13:21:13 <TimB2> I have a question about missing type inheritance (I have Java background): when you write a GUI library, you might call a user function after a double click in a list. Then you want to pass him the selected object. But what type could you use for that?
13:22:10 <TimB2> ah I guess now I have an idea
13:22:34 <deech> Hi all, I just started getting the following error when loading the network package in GHC. Can anyone help debug? : GHCi runtime linker: fatal error: I found a duplicate definition for symbol
13:22:34 <deech>    my_inet_ntoa
13:22:34 <deech> whilst processing object file
13:22:34 <deech>    /home/deech/.cabal/lib/network-2.2.1.7/ghc-6.10.3/HSnetwork-2.2.1.7.o
13:22:34 <c_wraith> TimB2, generally a function.
13:22:44 <ManateeLazyCat> TimB2: We use gtk2hs for Haskell GUI.
13:24:14 <ManateeLazyCat> Twey: Thanks for your help, my code clearer now. :)
13:25:05 <jimmyjazz14> is there a way to generally curry a function that is in the form ((String, Int), Float) -> x
13:25:13 <benmachine> :t curry
13:25:14 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:25:16 <jimmyjazz14> I know "curry . curry" will do that
13:26:03 <jimmyjazz14> basically what I am trying to do it build up a function that takes n parameters 
13:26:28 <jimmyjazz14> I'm not even sure its possible to be honest
13:26:45 <aavogt> you'll need one (or more) typeclasses
13:27:02 <benmachine> you might be able to do something evil with OverlappingInstances
13:27:05 <benmachine> or Typeable
13:27:07 <benmachine> but, shrug
13:27:42 <aavogt> I doubt typeable would be fruitful
13:28:08 <aavogt> because it gets you value-level representations of types, and there's no way to go back to types from there...
13:29:06 <jimmyjazz14> basically I have something of a generic object I am trying to create a constructor for...
13:29:17 <jimmyjazz14> one would use code a bit like: ("test" ==> str) +++ ("test2" ==> int)  +++ ("test3" ==> float)
13:29:20 <ddarius> aavogt: There is a way.
13:29:27 <Twey> ManateeLazyCat: That's an issue to solve by practice, not by writing loads of redundant code
13:29:36 <benmachine> aavogt: I was thinking about Data really
13:29:45 <benmachine> gmap-sort-of-thing
13:29:53 <aavogt> @hoogle typeOf
13:29:54 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
13:29:54 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
13:29:54 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
13:30:16 <aavogt> ddarius: I mean specifically TypeRep -> some type
13:30:45 <ManateeLazyCat> aavogt: I think you can do that.
13:30:56 <aavogt> in which case you need another typeclass that basically inverts Typeable
13:31:07 <benmachine> you can't exactly do that
13:31:29 <aavogt> so perhaps I was a bit hasty to say it's impossible
13:31:58 <benmachine> but if you know what types to expect you shoudl be able to implement behaviour for each
13:32:39 <aavogt> hmm, I don't see how you can undo typeOf though
13:33:00 <aavogt> I see benmachine
13:33:13 <benmachine> using cast, mainly
13:33:25 <benmachine> you can't move information from the value level to the type level
13:33:41 <benmachine> but cast allows you to cheat a bit
13:34:13 <ManateeLazyCat> aavogt: class Typeable a => Foo a where, Foo define common, when you want special action, use "case Foo".
13:34:47 <aavogt> ManateeLazyCat: explain further
13:34:49 <ManateeLazyCat> benmachine: Yeah, when you use typeable with cast, you need careful Nothing branch.
13:35:38 <ManateeLazyCat> aavogt: In gtk2hs, we can cast back. From child to parent. :)
13:44:26 <JasonFelice> So, where is this 'locale' package that the 'old-locale' docs refer to?
13:45:54 <aavogt> ManateeLazyCat: there you cast to a known type, here I'm asking whether you can do some value level calculations which will determine the resulting type
13:47:47 <ManateeLazyCat> aavogt: YOu can't determine value.
13:48:02 <ManateeLazyCat> aavogt: I need sleep now. bye. :)
13:48:27 <aavogt> most programs involve determining values
13:49:28 <TimB2> bye
13:49:48 <dons> JasonFelice: its a joke. there is no 'locale' package.
13:49:50 <dons> just old-locale
13:51:44 <mmagee>  /msg NickServ identify //pazzword?
13:52:42 <jimmyjazz14> regarding my earlier question I have the following code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26612#a26612
13:53:00 <jimmyjazz14> notice the bottom where I create a constructor for my GenericObject type
13:53:28 <jimmyjazz14> the problem is the need to add the "fields3" to curry the function
13:53:36 <jimmyjazz14> is there a better way to do this?
13:55:37 <Phyx-> huh
13:56:05 <Phyx-> i have a sudden case of dejavu from your question jimmyjazz14 
13:56:19 <jimmyjazz14> Phyx-: why is that?
13:56:45 <Phyx-> i could swear someone asked the exact same thing a few days ago
13:59:06 <jimmyjazz14> heh weird
14:04:20 <jimmyjazz14> Phyx-: Happen to know if they got an answer?
14:16:57 <elitheeli> When did intercalate get added to List?
14:17:26 <elitheeli> I have ghci 6.12.1, it can't find List.intercalate
14:18:00 <JasonFelice> elitheeli: You want Data.List
14:18:07 <jbapple> @hoogle intercalate
14:18:07 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
14:18:08 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:18:08 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
14:18:13 <elitheeli> Ohh ok
14:18:21 <elitheeli> will that conflict with normal list?
14:18:27 <elitheeli> or is it a superset or something?
14:19:06 <Somelauw> What does op mean?
14:19:12 <Somelauw> I have some code:
14:19:14 <Somelauw> a)prim (:) [] 5 
14:19:14 <Somelauw>    where 
14:19:14 <Somelauw> prim op bas 0 = bas
14:19:14 <Somelauw> prim op bas n = op n (prim op bas (n-1))
14:21:49 <Somelauw> Are there any haskell experts?
14:26:24 <dafis> Somelauw, op is the name of the first argument passed to prim, in the above case, op will be bound to (:)
14:27:37 <dafis> @let prim op bas 0 = bas; prim op bas n = op n (prim op bas (n-1))
14:27:38 <lambdabot>  Defined.
14:27:48 <dafis> > prim (:) [] 5
14:27:50 <lambdabot>   [5,4,3,2,1]
14:28:00 <dafis> @type prim
14:28:01 <lambdabot> forall t1 t. (Num t1) => (t1 -> t -> t) -> t -> t1 -> t
14:28:15 <dafis> > prim + 0 5
14:28:16 <lambdabot>   Overlapping instances for GHC.Show.Show
14:28:16 <lambdabot>                              ((t1 -...
14:28:29 <dafis> > prim + 0 5 :: Int
14:28:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:28:30 <lambdabot>         against inferred type ...
14:28:32 <aavogt> @src foldr
14:28:32 <lambdabot> foldr f z []     = z
14:28:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:28:39 <dafis> > prim (+) 0 5 :: Int
14:28:40 <lambdabot>   15
14:30:03 <Phyx-> :t prim
14:30:04 <lambdabot> forall t1 t. (Num t1) => (t1 -> t -> t) -> t -> t1 -> t
14:30:16 <Phyx-> uh.. ok...
14:30:41 <Phyx-> ah, it was just defined
14:30:43 <Phyx-> heheh
14:34:44 <Somelauw> Arrgh, I see
14:34:57 <Somelauw> It returns [5,4..0].
14:35:09 <Somelauw> But it is done in a complex way.
14:49:05 * hackagebot bird 0.0.2 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.2 (MattParker)
14:53:39 <ddarius> How does one determine that a type extension is "wildly popular?"
14:54:13 <pizza_> if someone other than themselves is using it
14:56:53 <benmachine> might be interesting to download hackage and parse some pragmas
14:59:36 <edwardk> ddarius: i'd usually say 'if i use it
14:59:44 <edwardk> but then i realized i think i use almost all of them
15:00:27 <edwardk> "Hello World" is greatly in enhanced with PackageImports and UndecidableInstances
15:04:12 <ddarius> edwardk: We can use you for determining "wildly unpopular" extensions.
15:04:24 <edwardk> ddarius: awesome
15:06:38 <edwardk> things i don't use (any more): UnicodeSyntax, RecordPuns, NoMonoPatBinds, PostfixOperators, UnknownExtension String, RegularPatterns,  XmlSyntax, and, as of yet, NewQualifiedOperators
15:07:10 <benmachine> I use UnknownExtension String all the time >_>
15:07:16 <edwardk> =)
15:07:38 <edwardk> oh, and i cry whenever i have to use Arrows. it is sad
15:08:14 <edwardk> IncoherentInstances, while occasionally a necessary evil, have also been known to make me throw up in my mouth from time to time
15:09:47 <edwardk> is criterion still the sort of gold standard for benchmarking these days?
15:10:39 <ddarius> edwardk: What about linear implicit parameters?
15:11:20 <edwardk> ok, those are also off my christmas card list
15:11:52 <ddarius> What is UnknownExtension String?
15:12:21 <edwardk> it is in the constructor list in Language.Haskell.Extension -- presumably as room to grow for cabal ;)
15:13:50 <benmachine> or for error messages, perhaps
15:20:14 * hackagebot speculation 0.4.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.4.0 (EdwardKmett)
15:20:16 * hackagebot speculation 0.5.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.5.1 (EdwardKmett)
15:20:52 <geheimdienst> so edwardk uploaded 0.5.0, then 0.4.0, then 0.5.1
15:21:03 <pizza_> seems pretty stable
15:21:05 <geheimdienst> looks like the 0.5.0 release was speculative
15:21:05 <edwardk> geheimdienst: fatfingered the autocomplete =)
15:21:24 <edwardk> besides, this fills in the gap in the numering scheme for posterity ;)
15:21:42 <geheimdienst> i like the theory of speculatively releasing better. i'll believe that if it's all the same to you
15:21:43 <geheimdienst> ;-)
15:26:49 <edwardk> i just need to figure out the right set of things to benchmark that won't show too much bias =)
15:27:34 <geheimdienst> it's called rightitude bias if you are too biased towards benchmarking the right things
15:27:41 <seric> dancor: here?
15:28:43 <ddarius> edwardk: I recommend not really trying and instead benchmarking extreme cases and "whole-program" cases.
15:29:46 <edwardk> ddarius: *nods*
15:34:57 <Phyx-> :t ()
15:34:59 <lambdabot> ()
15:35:29 <dafis> :t (.) . (.) . (.)
15:35:30 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
15:36:19 <dafis> :t (.)
15:36:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:42:41 <emet> does anyone do web development with haskell?
15:43:22 <aristid> emet: there's even a few channels for it
15:43:32 <aristid> emet: #haskell-web #happs #snapframework
15:44:23 * hackagebot bird 0.0.3 - A simple, sinatra-inspired web framework.  http://hackage.haskell.org/package/bird-0.0.3 (MattParker)
15:44:45 <dafis> how's that for timing?
15:45:02 <Wolfbytes> hey random internet poeple I was wondering do you guys think haskell would be an alright second programming languange ?
15:45:51 <dafis> Wolfbytes, yes, very much so
15:46:14 <arw_> Wolfbytes: haskell feels like "the first one" for most, even more experienced programmers.
15:46:14 <dafis> but would you expect a different opinion in #haskell?
15:46:49 <geheimdienst> also, haskell's irc channel clearly is unbelievably top-notch
15:47:31 <Wolfbytes> lol well my other options are C and NASM I heard that its best to get some functional programming skills early on so...
15:47:55 <dafis> Wolfbytes, what's your first language?
15:47:56 <benmachine> Wolfbytes: what was the first?
15:48:03 <kniu> can implicit parameters be bound in do notations?
15:48:07 <Wolfbytes> perl
15:48:11 <kniu> like do {?x <- something; ...}
15:49:10 <dafis> Wolfbytes, I'd say get some functional experience before C
15:49:27 * geheimdienst wrote a tiny bit of javascript the other day, and got furious. nothing works! any variable can be anything! the compiler is as unhelpful as possible. you might think it's not even there.
15:49:57 <mauke> geheimdienst: that's not a problem if you only write correct code
15:50:08 <mauke> clearly you are at fault
15:50:16 <arw_> Wolfbytes: i would say that it doesn't really matter whether you pick c/asm or haskell first. both will teach you entirely different things.
15:50:30 <geheimdienst> oh i see. clearly it's my fault for being human.
15:50:39 <mauke> yes!
15:51:00 <dafis> mauke: I thought that was the parents' fault
15:51:14 <arw_> Wolfbytes: but learning haskell first might be beneficial because you learn to appreciate types. types in c and assembler are unsuitable for that.
15:51:47 <mauke> C will teach you about manual resource management
15:52:38 <mauke> and fear
15:52:47 <mauke> but mostly resource management
15:53:10 <dafis> and pointers
15:53:37 <mauke> pointers are only two steps away from Perl references
15:53:46 <geheimdienst> i see learning C as a historical exercise. you learn how things were done back then. understanding how things came to be is helpful for understanding today's approaches. however, you don't learn language in which you would actually want to program anything (some niches aside)
15:55:57 <arcatan> still C is definitely part of the the repertoire of a well-versed programmer
15:56:32 <stepcut> why are there so many JSON libraries on hackage, and which one should I use?
15:58:05 <bjartur> isn't there some elegant way to do:
15:58:19 <bjartur>        let res = brains (read $ args !! 0) (read $ args !! 1) (read $ args !! 2)
15:58:37 <mauke> what is args?
15:59:07 <bjartur> args :: [[char]]
15:59:28 * hackagebot speculation 0.6.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.6.0 (EdwardKmett)
15:59:31 <geheimdienst> map read $ take 3 args ?
15:59:32 <bjartur> args <- getArgs -- inside an do
15:59:54 * geheimdienst trembles in anticipation of the gurus ripping apart his code
15:59:54 <stepcut> GetOpts ?
16:00:37 <dons> [a,b,c] <- map read `fmap` getArgs
16:00:55 <dons> brains a b c
16:00:57 <stepcut> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/System-Console-GetOpt.html
16:01:03 <edwardk> dons: though that forces you to have exactly 3 args
16:01:12 <mauke> dons: ... of the same type
16:01:17 <Wolfbytes> thanks for the info guys ima go ask around a bit before I make my choice but thanks for the help
16:01:18 <edwardk> (a:b:c:_) <- map read `fmap` getArgs
16:01:52 <geheimdienst> wolfbytes, have a look at LYAH, it's a pretty good haskell tutorial. you could just start and see how it goes ;-)
16:01:53 <geheimdienst> @lyah
16:01:54 <lambdabot> Unknown command, try @list
16:02:00 <geheimdienst> @give lyah
16:02:00 <lambdabot> Maybe you meant: dice gsite time
16:02:02 <benmachine> @where lyah
16:02:03 <lambdabot> http://www.learnyouahaskell.com/
16:02:06 <geheimdienst> thanks
16:02:21 <bjartur> @edwardk why is the underscore there?
16:02:22 <lambdabot> Unknown command, try @list
16:02:25 <Wolfbytes> geheimdienst: thanks ill do that
16:02:26 <geheimdienst> @do_what_i_mean_dammit lyah
16:02:26 <lambdabot> Unknown command, try @list
16:02:42 <bjartur> to catch the rest of the list?
16:03:10 <edwardk> @tell Saizan it looks like the 'right' answer for how to write a mapSTM (traverseSTM) would be to have the guess return the tail of the contents of the foldable, but that isn't necessarily shaped like an (f a) so it would have to give it as a list that could be threaded back in if needed/compared with the tail of the entries
16:03:10 <lambdabot> Consider it noted.
16:03:17 <edwardk> bjartur: yep
16:05:19 <bjartur> the third part of the tuple needs to be of a different type
16:05:50 <int80_h> lambdabot's configuration file makes reference to a password.rc file. But I don't see it anywhere. Can someone point me to what one would look like?
16:16:58 <kniu> oooh, segfault.
16:17:13 <dafis> kniu: how?
16:18:25 <FauxFaux> Haha, I thought this was ##c++, that'd've been a wierder exclamation.
16:19:25 <bjartur>  :j #linux
16:24:33 <kniu> using HDBC, 
16:24:37 <kniu> first disconnect,
16:24:40 <kniu> then commit
16:24:45 <kniu> crashes ghci.
16:25:25 <kniu> driver is PostgreSQL.
16:25:36 * benmachine blames the FFI in vague ways
16:26:10 <inetic_> hi there, I'm trying to do something like this: "x <- newIORef foo1; writeIORef x foo2" where foo1 and foo2 both belong to class let's say Foo. The compiler chokes on it because the actual types of foo1 and foo2 are different. How can I achieve this? I mean, to achieve that I can put anything into x as long as it's of class Foo. I come from OO world and obviously missing something here. 
16:28:48 <dafis> inetic_: IORefs are typed, so you can't put values of different types in. You can achieve something like that with an existential wrapper type for Foo values
16:29:38 <dafis> like data AnyFoo = forall a. Foo a => AnyFoo a; and then put AnyFoos in the IORef
16:30:26 <inetic_> dafis: that forall syntax, isn't it an extension?
16:30:50 <dafis> inetic_: Yes, so what?
16:31:44 <inetic_> dafis, just wondering, that's another thing that isn't too clear to me, should I use extensions? is there like a rule on when I should use one and when not?
16:32:08 <benmachine> inetic_: it basically depends on who you want to be able to run your code
16:32:17 <dafis> inetic_: the rule is, use one if you need one
16:32:27 <benmachine> inetic_: and also, some extensions might make the type system weaker in some ways, or stronger in tohers
16:33:15 <inetic_> yes, so I have heart that it might be dangerous to use some of them
16:33:48 <inetic_> dafis, thanks for the answer, I'm gonna use that
16:33:51 <dafis> inetic_: indeed, some are dangerous
16:34:08 <benmachine> not exactly "dangerous" :P
16:34:18 <benmachine> I mean, UndecidableInstances might make the typechecker loop
16:34:26 <benmachine> it won't wipe your homedir or anything
16:34:43 <benmachine> IncoherentInstances imo gives people weird ideas about what type classes are for
16:34:46 <benmachine> and how they work
16:34:57 <benmachine> that's actually like changing the language rather than adding to it
16:35:29 <dafis> benmachine: yes, dangerous in the sense of "won't do what you expect"
16:35:47 <inetic_> dafis, benmachine , i see
16:37:06 <kniu> hm
16:37:31 <kniu> for HDBC, what kind of syntax does fetchRow accept?
16:37:53 <kniu> I tried (prepare db "select * from myTable;" >>= fetchRow),
16:37:57 <kniu> but it didn't return anything.
16:48:41 * hackagebot speculation 0.7.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.7.0 (EdwardKmett)
16:49:14 <bjartur> k:l
16:49:34 <edwardk> removed the SpeculationException machinery, now it just uses STM retry
16:49:49 <edwardk> much cleaner, simpler, easier to read, and more likely to do the right thing if you deadlock
16:50:01 <edwardk> if you deadlock at all while speculating... stop speculating ;)
16:54:59 <pizza_> you may be at 1.0 before bedtime
16:55:24 <ddarius> pizza_: Not likely.
16:55:32 <ddarius> He may be at 0.38.0 though.
16:56:52 <pizza_> hehe
16:56:56 <edwardk> ddarius: hahahaha
16:57:14 <edwardk> pizza_: if you look at the commit times, i'm pretty much going on 38 hours without sleep ;)
16:58:05 <edwardk> it is at least getting progressively more polished
16:59:26 <ddarius> edwardk: Or your perception of "more polished" is slowly becoming less accurate.
16:59:37 * ddarius likes to consider all possibilities.
17:06:01 <mreh> bum, I can't do "sequence" for any functor
17:06:33 <dafis> mreh: you can do it for all Functors which are Monads
17:08:06 <mreh> unfortunately, that's not an available option :(
17:08:21 <magicman> Or Applicative.
17:08:47 <mreh> hmmmm
17:09:00 <mreh> I need to email Henrik
17:09:14 <edwardk> mreh: you can sequenceA_ Applicatives
17:09:16 <mreh> I don't suppose it's hard to make a Functor Applicative
17:09:26 <edwardk> mreh: depends on the functor =)
17:09:49 <mreh> well in Yampa, there's this notion of parallel switching
17:10:17 <mreh> Henrik/Hudak/Hooever chose to implement it with the Functor interface, which is fine
17:10:52 <mreh> but rather makes my job hard when trying to sequence a monadic computation through all of them
17:11:27 <mreh> the plan is to make the whole guts of Yampa signal functions monadic
17:11:45 <mreh> for the sake of modularity
17:12:21 <mreh> we could have different Yampa flavours too
17:14:51 <mreh> :t sequenceA_
17:14:52 <lambdabot> Not in scope: `sequenceA_'
17:14:58 <mreh> :t sequenceA
17:14:58 <lambdabot> Not in scope: `sequenceA'
17:15:04 <magicman> :t Control.Applicative.sequenceA_
17:15:05 <lambdabot> Not in scope: `Control.Applicative.sequenceA_'
17:15:15 <aristid> :t Data.Foldable.sequenceA_
17:15:16 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Applicative f) => t (f a) -> f ()
17:15:18 <dafis> @hoogle sequenceA_
17:15:18 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
17:15:20 <aristid> i win!
17:16:50 <mreh> foldable?
17:17:35 <dafis> mreh: e.g. []
17:18:04 <mreh> @src Data.Foldable.Foldable
17:18:05 <lambdabot> Source not found. I am sorry.
17:18:56 <dafis> :i Data.Foldable.Foldable
17:19:21 <magicman> I think of it as types that have a toList function for it, though the actual definition is different.
17:19:21 <mreh> hmm, seems reasonable, not too much to ask of a Yampite
17:19:47 <dafis> class Data.Foldable.Foldable t where
17:19:47 <dafis>   Data.Foldable.fold :: (Data.Monoid.Monoid m) => t m -> m
17:19:47 <dafis>   Data.Foldable.foldMap ::
17:19:47 <dafis>     (Data.Monoid.Monoid m) => (a -> m) -> t a -> m
17:19:47 <dafis>   Data.Foldable.foldr :: (a -> b -> b) -> b -> t a -> b
17:19:47 <dafis>   Data.Foldable.foldl :: (a -> b -> a) -> a -> t b -> a
17:19:48 <mreh> @instance Foldable
17:19:48 <lambdabot> Maybe you meant: instances instances-importing
17:19:49 * hackagebot cassandra-thrift 0.0.2 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.0.2 (KirkPeterson)
17:19:49 <dafis>   Data.Foldable.foldr1 :: (a -> a -> a) -> t a -> a
17:19:51 <dafis>   Data.Foldable.foldl1 :: (a -> a -> a) -> t a -> a
17:19:53 <dafis>         -- Defined in Data.Foldable
17:19:54 <ddarius> :t Data.Foldable.toList
17:19:55 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
17:19:55 <dafis> instance Data.Foldable.Foldable [] -- Defined in Data.Foldable
17:19:57 <dafis> instance Data.Foldable.Foldable Maybe -- Defined in Data.Foldable
17:19:59 <magicman> Though you can use the functions in Foldable to define toList, so it's not *too* weird of a thought.
17:20:39 <interferon> it would be really nice to have a haskell refactorer...."Extract Module..." "Convert to Applicative Style..." "Lambda Lift"
17:20:54 <ddarius> interferon: You mean like HaRe?
17:20:55 <ddarius> @where hare
17:20:56 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
17:21:16 <interferon> i could never get it working
17:21:28 <interferon> seemed like it was out of maintenance
17:21:29 <mreh> that makes me think of clef palates
17:21:32 <mreh> cleft *
17:22:36 <danharaj> What's a good place to learn about System F_\omega and the denotational semantics of types like Algebraic Datatypes?
17:22:39 <ddarius> No Lisp here.
17:22:39 <interferon> what haskell library should i look at to generate simple line-graphs as pngs?
17:22:40 <danharaj> Beyond Pierce.
17:23:07 <ddarius> interferon: You might be interested in the sparklines package.
17:24:07 <dons> interferon: probably gnuplot, Chart, or sparklines.
17:24:49 <interferon> Chart seems nice, but requires Gtk, which is kind of a pain on os x
17:25:11 <ddarius> There should also be a package for Google's chart thing.
17:25:44 <ddarius> http://hackage.haskell.org/package/GoogleChart
17:25:56 <mreh> interferon: I would think it would be simpler to draw your own and convert them to PPM
17:26:08 <interferon> mreh: that might be fun
17:26:14 <dons> the sparklines package is quite easy. see e.g. http://jlouis.github.com/combinatorrent/
17:26:21 <mreh> it depends on how simple we're talking
17:26:25 <m3ga> Axman6: please check your email :-)
17:26:32 <dons> those little graphs are from the sparklines package
17:26:37 <mreh> interferon: if you really want I can send you a library that writes PPMs
17:26:49 <interferon> sparklines is a little too simply
17:26:51 <mreh> or whatever that standard is called
17:26:58 <interferon> i used to use the line graphs from the ruby package gruff
17:26:59 <interferon> *simple
17:29:50 <interferon> i am still surprised by the "if it compiles, it works" phenomenon
17:30:04 <interferon> i could provide lots of arguments why that maxim shouldn't hold true....but it does
17:30:20 <JasonFelice> interferon: You can use the GD wrapper as well.
17:31:14 <mreh> "it works, but sometimes in ways you don't expect", how's that?
17:31:32 <mreh> semantic errors are still commonplace
17:32:05 <dafis> yep, typoing - for + won't be caught by the type checker
17:32:15 <mreh> and partial functions are allowed
17:32:32 <c_wraith> clearly we need different types for addable numbers than for subtractable numbers. :)
17:33:00 <ddarius> c_wraith: Those exist.
17:33:13 <interferon> that's true, but when i'm pulling apart parts of an application and reassembling them...it all works in the end
17:33:15 <mreh> how amusing
17:33:44 <mreh> interferon: :)
17:33:54 <ddarius> interferon: There are a few vector graphics like graphic libraries that you may be interested in as well.
17:34:32 <mreh> isn't it test first's motto, "compile frequently, and often" or something
17:34:37 <mreh> to hell with that
17:35:07 <interferon> ddarius: svg stuff?
17:35:11 <mreh> I want to code 36 hours straight without running the compiler once!
17:35:13 <hpc> i like to ghci often, to play with behavior as i create it
17:35:14 <ddarius> Some of it, yes.
17:35:16 <interferon> mreh: type-driven development
17:35:32 <interferon> ddarius: cool, i'll look into that.  do you know of any particular packages?
17:36:18 <pizza_> the ability to type properly has always been an important programming skill
17:39:00 <ddarius> interferon: Cairo is the usual one, but that needs gtk, so probably not much help.  I don't know exactly what Chalkboard or graphics-drawingcombinators outputs.  There hps generates postscript files and HPDF for pdf.  gloss might be interesting.
17:39:31 <mreh> to get "(Functor col, Monad m) => m (col a) -> col (m a)" I'll need Foldable and applicative
17:39:36 <mreh> correct?
17:39:45 <clanehin> anyone else noticed ghc+ld (linking phase) getting really slow/working the HD hard?  I'm seeing this on two debian boxes recently.
17:39:57 <mreh> hmm
17:39:57 <ddarius> Ah, it looks like gloss doesn't have something to render to a file.
17:39:57 <magicman> The GD library has a png output function (which is the png output function that sparklines uses).
17:40:15 <magicman> Dunno if GD is more or less an issue than using gtk2hs.
17:40:34 <mreh> clanehin: linking is slow, what are you compiling?
17:40:50 <clanehin> uh, right now it's roguestar, but the other day it was gitit.
17:41:03 <mreh> big apps?
17:41:10 <clanehin> moderate, yeah
17:41:24 <mreh> how slow are we talking?
17:41:39 <mreh> gtk2hs, big lib, took about 30 mins for me
17:41:59 <ddarius> @hackage wumpus-core
17:42:00 <lambdabot> http://hackage.haskell.org/package/wumpus-core
17:42:07 <clanehin> locking up the UI for a minute or two, on my web server it crashed consistently during the link from using too much memory, which isn't normal
17:42:13 <dons> clanehin: nope.
17:42:18 <dons> haven't seen it.
17:42:58 * ksf still can't believe TH doesn't come with an eval.
17:43:52 <ddarius> import hint
17:44:02 <clanehin> fair enough, I might try installing an older version of ld later
17:44:29 <dons> ksf: you want runtime eval?
17:44:52 <ksf> well kinda runtime, compile-time runtime.
17:45:04 <ksf> I want to evaluate parts of a TH splice
17:45:11 <dons> you can compute at compile-time via TH.
17:45:50 <Baughn> You can call mueval from TH, for that matter
17:46:08 <ksf> I'm a bit worried about scope and such
17:46:08 <Baughn> ..or hint, I suppose it should be
17:46:09 <dons> its a multi-stage model, after all, so lifting and splicing proceeds in multiple (compile-time) stages.
17:46:55 <Baughn> Instance selection and such is always compile-time, right?
17:46:59 <dons> hs-plugins' eval, which was the first runtime 'run' uses TH as its surrounding meta-programming model, just providing a 'run' mechanism.
17:48:34 <ddarius> eval is "just a function."  The only time it becomes more than that is when you want transparent propagation of e.g. the lexical environment.  Usually, though, that's a pretty bad idea.
17:50:05 <interferon> and also a "Make Points-Free" refactoring...
17:50:24 <ksf> type inferrence for TH terms would be great, too.
17:50:33 <c_wraith> speaking of hint, I just got confirmation from daniel that he'll release a new version with one of my patches in it.  That relieves one of the blockers for my current project.
17:50:51 <dons> well, slightly magical function, Exp -> a
17:51:43 <ksf> ...or even Exp -> Maybe a and sufficiently lazy not to eval things if you only match the head.
17:51:45 <mreh> interferon: @pl comes out with some real monstrous stuff
17:52:24 <ksf> yep, the TH ast is way too verbose to sanely transform semantically
17:52:36 <ksf> first thing I did was to remove all InfixEs
17:52:57 <interferon> i guess i should look into contributing to leksah
17:53:41 <dons> ksf: providing a mapping from TH to a TH-Core type, that was normalized, would be nice. e.g. a form of TH that works on Core after optimizations. and then fed back in for re-typing
17:53:43 <ksf> the next thing will most likely be transforming pattern-bindings into value bindings and a case over a tuple
17:57:59 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26614#a26615 <- I'd like to tell the type-checker that *all* instances of Table must be instances of TableCreated; it should be illegal to create a Table that isn't and, therefore, unnecessary to add the constraint everywhere. Is that possible?
17:58:12 <Baughn> Adding a constraint to the newtype did nothing.
17:58:45 <ksf> you can do an existential
17:59:09 <ksf> data types can't carry contexts, but the fields can.
17:59:25 <Baughn> Oh, of course..
17:59:36 <Baughn> Though an existential seems somehow wrong, here. Oh well.
17:59:54 <dafis> Baughn: Why?
17:59:56 <Baughn> (Also, I have to know - is that code readable?)
18:00:18 <dafis> Baughn: No, lacks whitespace
18:00:43 <ksf> newtype Foo a where (Baz b, a ~ b) => Foo :: b -> Foo a 
18:00:56 <ksf> hopefully that typechecks
18:00:57 <hpc> what's "type instance"?
18:01:17 <ksf> hpc, google "fun with type functions"
18:01:43 <ksf> AND THE MOST IMPORTANT THING TO FIX IS LINKING SPEED
18:02:12 <Baughn> dafis: It implies carrying a dictionary around along with the value, which should be unnecessary because all values of Table should have a known type that allows the dictionary to be looked up
18:02:45 <Baughn> hpc: A fun little extension. Pretty easy to use, actually..
18:02:57 <ksf> who knows why ld is keeping and keeping reading stuff from disk
18:03:03 * hpc reads
18:03:20 <Baughn> type family Foo a; type instance Foo Int = Char; id :: Foo Int -> Char
18:04:08 <Baughn> Basically, type-families are to parametric polymorphism as type-classes are to.. um, functions with type variables? I'm not sure.
18:04:59 <ksf> there's a great deal of overlap with fundeps, but not completely.
18:05:07 <ksf> neither is a strict subset of the other.
18:05:20 <Baughn> They're very different to /use/, anyhow
18:05:31 <ksf> yep
18:05:53 <ksf> and type families are more idiomatic for most stuff, at least imho
18:05:54 <Baughn> Java and Prolog are both turing-complete, too..
18:06:17 <Baughn> Yeah, the code I'm working on would've been a /lot/ simpler with type families, but they aren't quite flexible enough (yet?).
18:06:28 <Baughn> s/with/with just/
18:06:54 <interferon> any built-in way of formatting a number with commas (fn "4444" => "4,444")?
18:07:03 <ksf> it's mostly matching on contexts that is lacking
18:07:54 <ksf> not in the base libaries afaik
18:08:01 <ksf> there might be something on hackage, though
18:08:11 <ksf> probably in some financial-stuff thing
18:10:57 <ksf> I *would* install hint if ghc-paths' Setup.hs would finish linking
18:11:21 * Baughn is now at five lines of language pragma including, dear lord, seven major ones
18:12:16 <Baughn> I might as well just use -fglasgow-extensions.
18:13:32 <ksf> can I tell cabal to use runhaskell instead of compiling Setup.hs?
18:13:43 <Baughn> You can do so manually.
18:14:01 <ksf> good idea
18:14:01 <Baughn> runghc Setup.hs {configure --user,compile,install}
18:15:02 <ddarius> ksf: The worst thing is when it is followed by: Configure failed: can't find foobar.h
18:15:09 <ddarius> And then you get to do it all over again.
18:15:30 <Baughn> But this is odd..
18:15:36 <ksf> done.
18:15:40 <ksf> this is insanity.
18:15:40 <Baughn> I added the existential, but it still refuses to work. :/
18:15:55 <Baughn> data Table a where Table :: TableCreated a => Schema a -> Table a
18:16:01 <ksf> how can ld fail so badly to link in an appropriate amount of time?
18:16:12 <ksf> it's a one-file package, after all...
18:16:25 <Baughn> "Could not deduce (TableCreated a) from the context (Show (Table a), Show a)
18:16:55 <dafis> Baughn: code?
18:17:11 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26616#a26616
18:18:18 <dafis> Baughn: the context TableCreated a is made available by pattern-matching
18:18:38 <Baughn> dafis: Well, yes, but every single one of the constructors has it
18:18:44 <dafis> so, show (Table thing) = ...
18:19:13 <Baughn> Hum. That worked.
18:19:40 <Baughn> Now I just need to figure out how to make a strict GADT field
18:19:41 <ksf> that's actually a cool way to hide typeclasses
18:20:08 <Baughn> I got this working yesterday, but I want simple error messages if it kills me. :P
18:20:30 <dafis> Baughn: put a bang on the constructor's argument type?
18:20:33 <ksf> gragh.
18:20:51 <ksf> the type variables in the head of a gadt decl always confuse me.
18:20:54 <Baughn> dafis: No good. Unexpected strictness annotation, no matter /where/ I put it.
18:20:59 <ksf> I always think they're in scope...
18:21:16 <Baughn> Good point. *replaces it with :: * -> **
18:22:42 <ksf> or call it Table longtellingname, as such things propagate through the typechecker and add documentation.
18:22:55 <Baughn> That's what I'm doing
18:23:17 <Baughn> Or.. no, not
18:23:28 <Baughn> For an ADT Foo, you get Table Foo.
18:23:46 <Baughn> The point is to get good error messages if you mix up the types
18:24:16 <Baughn> Having toList :: Table val -> val is nice
18:24:25 <Baughn> -> [val]
18:26:13 <dafis> Baughn: data MyGADT a where
18:26:13 <dafis>     Strict :: !Int -> MyGADT Int
18:26:18 <dafis> works here
18:26:49 <Jefskell> How do I get the length of an Array in haskell? Thanks.
18:27:19 <dafis> Jefskell, bounds
18:27:26 <dafis> @type bounds
18:27:27 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
18:27:38 <dons> look at the docs for  the array package, http://hackage.haskell.org/packages/archive/array/0.3.0.1/doc/html/Data-Array.html#v%3Abounds
18:27:58 <dafis> and then rangeSize
18:28:41 <Baughn> dafis: I could have sworn it failed to work last I tried...
18:28:46 <Jefskell> Oh, I see. Thanks.
18:29:20 <Baughn> Or, it did, but I guess I didn't try that particular form. !(Schema a)
18:29:35 <Jefskell> dafis++
18:39:25 <ksf> (WontCompile
18:39:26 <ksf>          [GhcError{errMsg =
18:39:26 <ksf>                      "Not in scope: type constructor or class `Char'"}])
18:39:34 <ksf> I get the feeling I'm going to see a lot of those.
18:39:54 <dafis> wot? Char not in scope???
18:40:25 <dafis> {-# LANGUAGE NoIMplicitPrelude #-} ?
18:40:47 <ksf> nope, hint.
18:40:56 <ksf> I think I should at least import the prelude.
18:41:21 <dafis> probably a good idea
18:41:24 <ksf> this is where TH integration would be great
18:43:35 <ksf> ...and I need to import GHC.Base, too, because TH is qualifying ++ to GHC.Base.++
18:43:58 <aavogt>   '(Prelude.++)   doesn't work?
18:44:03 <ksf> this amounts to a hack of gargantuan porportions
18:44:25 <ksf> It's spliced from a module where the prelude is imported
18:44:37 <ksf> ...and TH resolves to the base backage stuff is defined in.
18:44:55 <ksf> which works fine unless you're not ghc...
18:57:57 <mreh> Amtrak ripped off bind for their logo
18:58:23 <Cairn> hello
18:58:31 <ksf> well, tbh, I could grep the ast I want to eval for package names
18:58:32 <ksf> later.
18:58:54 <dafis> Cairn: Hello
18:59:16 <ksf> now you scared him.
18:59:27 <dafis> I didn't mean to
19:00:03 <ksf> hopefully you've learnt your lesson.
19:00:06 <ksf> be nice, next time.
19:00:23 <mreh> :t liftA2 (:)
19:00:24 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f [a] -> f [a]
19:00:48 <mreh> :t foldr . liftA2 (:)
19:00:49 <lambdabot> forall a. ([a] -> a) -> [a] -> [[a] -> [a]] -> [a]
19:01:30 * mreh gurgle
19:04:02 <mreh> :t Data.Foldable.foldr . liftA2 (:)
19:04:03 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => ([a] -> a) -> [a] -> t ([a] -> [a]) -> [a]
19:04:28 <mreh> nah, this is wrong
19:04:39 <dafis> mreh: whatcha want?
19:04:53 <mreh> sequence for an arbitary functor
19:05:03 <mreh> liftA2 (:) is the wrong thing
19:05:59 <mreh> I see it as some kind of fold, with a binding operator
19:06:05 <mreh> i.e. >>=
19:06:22 <mreh> but to what function?!
19:07:42 <dafis> mreh: what would sequence [('a',1), ('b',2)] be?
19:07:43 <mreh> if anyone knew I was up at 3am doing haskell, they would break off all contact
19:07:59 <dafis> mreh: it's 4am here :)
19:08:03 <mreh> @instance monad
19:08:03 <lambdabot> Maybe you meant: instances instances-importing
19:08:08 <mreh> @instance Monad
19:08:09 <lambdabot> Maybe you meant: instances instances-importing
19:08:15 <mreh> @instances Monad
19:08:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:08:31 <mreh> (a,) is not a Monad
19:08:43 <dafis> mreh: But a Functor
19:09:20 <dafis> fmap f (a,x) = (a, f x)
19:09:31 <mreh> uhuh
19:10:35 <mreh> you need an operation to sequence
19:10:57 <dafis> mreh: besides, Writer m is isomorphic to (m,), so if m is a Monoid, it's a Monad
19:17:51 <dafis> mreh: I think you *need* Applicative, then it's sequence [] = pure [], sequence (fa : fas) = liftA2 (:) fa (sequence fas)
19:59:48 <ksf> yep functors alone aren't powerful enough to say that
19:59:56 <ksf> ...there's no order you could impose
20:00:42 <ksf> and the proper name for that function, btw, is "chain"
20:03:12 <dafis> ksf: Workers of the World, Unite. You have nothing to lose but your chains!
20:03:26 <dafis> chain is an improper name
20:22:04 <Jefskell> How do I write my own "Show" function, so  that I change how my data structures are printed to stdout?
20:23:18 <ksf> if there already is a Show instance for that type, you have to use a newtype wrapper.
20:24:53 <Jefskell> ksf: It's my own data type, so I don't think it already has a Show instance. 
20:25:18 <ksf> then write instance Show MyDataType where show x = ...
20:25:19 <dafis> Jefskell, so instance Show YourType where show thing = ...
20:25:44 <dafis> or, better in some respects, defines showsPrec rather than show
20:26:57 <Jefskell> I may need to read a bit more about classes
20:29:31 <ddarius> Jefskell: If you don't care too much about what the output looks like you can (usually) just add "deriving Show" to the end of the data declaration.
20:30:05 <sshc> Which module contains functions for accessing command line paremeters?
20:30:48 <dafis> sshc: System.Console.GetOpt
20:30:51 <applicative> do you want getArgs etc
20:30:54 <ksf> Environment
20:31:10 <ksf> er System.Environment
20:31:22 <sshc> ksf, dafis: Thanks!
20:32:01 <Jefskell> ddarius: I was using "deriving Show", but now I need a little more control over the format of the output.
20:33:33 <applicative> Jefskell, there's no mystery for simple cases, as they said, you just define show for your type X after saying 'instance Show X'
20:34:59 <applicative> date MyInt = MyInt Int   instance Show MyInt where  show (MyInt x) = "HAHAHAHA, it's a MyInt" ++ show x
20:35:10 <applicative> data, not date....
20:37:11 <applicative> show (MyInt x) = "Ladies and gentlemen, I give you:  MyInt " ++ show x
20:41:05 * applicative just heard an eerie voice saying 'LANGUAGE NoMonomorphismRestriction"
20:41:36 * applicative was worried til he realized he'd triggered the obnoxious Mac 'say' function...
20:42:33 <ddarius> Did it correctly articulate "NoMonomorphismRestriction" ?
20:42:59 <applicative> ddarius, yes, it was a feminine voice and it said it right, 
20:43:01 <Saizan> hah, i thought they were spirits urging you to fight for NMR to get into haskell2011
20:43:09 <ddarius> Impressive.
20:43:48 <applicative> it got worse when she was instancing Monad blah blah, but she can say "monad" just fine
20:44:01 <ddarius> I don't think there is any implementation that doesn't allow you to turn off the monomorphism restriction except for the ones that don't implement it to begin with.
20:44:37 <kniu> which has higher precedence, (.) or (>>=) ?
20:44:42 <evanbd> Hello
20:44:45 <dafis> (.)
20:44:46 <applicative> kniu, is this a trick question
20:45:15 <kniu> I think the question is pretty clear.
20:45:19 <kniu> thanks, dafis.
20:45:35 <evanbd> So I have a cabal package installed from hackage (glome-hs); I think it has a bug in it.  What's the simplest way to make a patch and rebuild it, in such a way that it all plays well with cabal?
20:45:57 <Saizan> kniu: btw, :info also reports fixity and precendence, in ghci
20:46:00 <applicative> kniu, if you ask ghci with    :info (.)  it gives th
20:46:05 <kniu> oh
20:46:06 <applicative> like Saizan said
20:46:07 <kniu> didn't know that.
20:46:58 <evanbd> (Or, more generally: is there a page explaining how to do things like that?)
20:47:07 <Saizan> evanbd: cabal unpack glome-hs; cd glome-hs-*; <edit>; <optionally bump version>; cabal install
20:47:41 <evanbd> Saizan: thanks
20:47:43 <dafis> evanbd: version bump (append .1) recommended
20:48:18 <Saizan> yeah, even if in this case it's an executable, so it doesn't really matter
20:48:35 <dafis> oh, didn't know that
20:49:04 <dafis> what's it for?
20:49:20 <andyjgill> Hey, does anyone know what type functions are typically called?
20:49:24 <Saizan> glome-hs? it's a ray tracer apparently
20:49:30 <dafis> ah, ray-tracer
20:49:33 <evanbd> Actually, never mind, the bug would be in GlomeTrace
20:49:50 <andyjgill> Type functions, associated type functions, associated type synonyms, or what?
20:50:05 <Saizan> andyjgill: i think they are called type families now
20:50:08 <evanbd> There's a bug somewhere in its handling of CSG differences
20:50:08 <dafis> andyjgill, type families?
20:50:31 <evanbd> I'm using it to render machine tool paths
20:50:36 <andyjgill> Sigh. Cut and paste pending...
20:50:52 <applicative> evandb, awesome
20:52:03 <edwardk>  ok, dumb question what module is the randomly-haskelly-named change-working-directory function in?
20:52:31 <evanbd> applicative: Hopefully :)  I have to find time to actually finish writing the toolpath generation code as well.  And then figure out some remaining obnoxious issues related to the CNC mill I'm using being ancient.
20:52:55 <edwardk> System.Posix.Directory?
20:52:58 <ddarius> edwardk: Go to sleep.
20:53:06 <edwardk> ddarius: i did. i;m awake again
20:53:10 <evanbd> (It fully expects to be reading its g-code programs off punch tape, and gets annoyed when the computer at the other end of the RS-232 cable doesn't act like a tape reader.)
20:53:13 <ddarius> edwardk: Oh. Good.
20:53:55 <dafis> edwardk, Yes, System.Posix.Directory
20:53:56 <wli> setCurrentDirectory
20:54:05 <wli> System.Directory.setCurrentDirectory
20:54:06 <p_l|backup> evanbd: add random jams?
20:54:34 <pustaka> is there anyone wants to help me? im new to haskell
20:54:53 <pustaka> when i tried run a code from winGHCI it displayed
20:54:55 <pustaka> <interactive>:1:7:
20:54:55 <pustaka>     Ambiguous occurrence `return'
20:54:55 <pustaka>     It could refer to either `Main.return', defined at latihan.hs:4:0
20:54:55 <pustaka>                           or `Prelude.return', imported from Prelude
20:55:42 <pustaka> what's the problem here? I've typed it exactly the same as in the sample code in the programming in haskell book
20:55:45 <applicative> pustaka, you would have to hide the standard "return" if you want to define your own
20:55:55 <pustaka> how i do that?
20:55:58 <dafis> pustaka: you can a) import Prelude hiding (return), b) use return qualified, c) name your function differently
20:56:19 <applicative> dafis, sounds like there's a simpler explanation.  is hpaste.org up?
20:56:46 <evanbd> p_l|backup: Current annoyance: I have not yet deciphered the manual enough to know how to provide it with tool length offsets and fixture offsets while also feeding it programs that don't fit in its memory.  (AKA anything > 10 KB.)
20:56:46 <applicative> yeah, pustaka, paste the module that went wrong on hpaste
20:56:52 <ddarius> edwardk: So how long were you awake before you did go to sleep?
20:57:09 <shachaf> pustaka: See http://www.cs.nott.ac.uk/~gmh/book.html
20:57:47 <edwardk> ddarius: no idea. about typical for a weekend for me
20:59:11 <edwardk> trying to get a 'cabal test' to automatically run hpc for me so i can see coverage of a test suite for speculation
20:59:17 <ddarius> edwardk: Does your wife ever say anything or has she given up?
20:59:29 <edwardk> she was at work all day today ;)
21:01:51 <edwardk> hrmm what would be the best way to get the current path to hpc from inside of a Setup.lhs?
21:02:42 <ddarius> edwardk: Use the Paths module, assume it is in a standard place, and have it be configurable?
21:02:59 <ddarius> (Alternatively, perhaps Cabal has some kind of program discover function predefined.)
21:03:10 <edwardk> i was curious if it was something that cabal knew about
21:03:28 <ddarius> It might be.
21:03:40 <dafis> yes, cabal has a program search function
21:03:56 <edwardk> dafis: ooh shiny, how do i use it? =)
21:04:21 <dafis> ah, *that* I don't know, would have to do some reading for that
21:04:49 <dafis> maybe specifying it in the build-tools stanza is enough
21:04:53 <applicative> pustaka, i see what went wrong, in the parser chapter he uses 'return' without fitting it into the typeclass monad
21:05:35 <edwardk> findExecutable :: String -> IO (Maybe FilePath) looks promising
21:05:54 <dafis> edwardk, indeed
21:06:10 <applicative> pustaka, he's warming you up for the more general use of 'return' that is built into the Prelude and so on.  It's a little confusing, but pedagogically reasonable I guess
21:07:00 <dafis> edwardk, that's what cabal ultimately uses
21:07:36 <pustaka> applicative, you mean I cannot run the sample code?
21:09:10 <applicative> pustaka, i think you'd have to write " import Prelude hiding (return) " up toward the top of the module
21:09:41 <applicative> but shachaf points out that the code on the site will run without difficulty.  I am just guessing that you are dealing with the parsing chapter.
21:09:59 <pustaka> yes it is
21:10:02 <pustaka> chapter 8
21:10:36 <applicative> yeah, i can't find my copy but i see it in the powerpoint on the site.   it makes sense, but i see it would be fatally confusing without a teacher present...
21:10:46 <shachaf> pustaka: The version of the code that will actually work is at <http://www.cs.nott.ac.uk/~gmh/Parsing.lhs>.
21:11:36 <pustaka> shachaf, :p I really new to haskell, what is lhs file? and how i run it on winGHCI
21:11:39 <applicative> he is defining return in connection with the parsers, but return already exists.  he is getting you ready for the more general 'return' that already exists in standard Haskell.  
21:12:00 <applicative> it's fine, it's literate haskell.  the lines starting > are real code everythign else is comment
21:12:08 <shachaf> pustaka: I'd guess that "ghci file.lhs" would work.
21:12:16 <dafis> pustaka, lhs is a 'literate' haskell file
21:12:26 <applicative> its the reverse of the usual where -- makes a comment.  More or less.  
21:12:51 <edwardk> yay i have a hack finally running hpc
21:12:56 <shachaf> Or you can copy the code in it to your own file. :-) The main difference is that some functions are defined inside instances.
21:13:50 <edwardk> now, sadly, it also needs a --srcdir with the bits and pieces from the wrong package -- so it is dead to me, but it was a nice idea
21:14:33 <edwardk> i suppose i could merge the test/benchmark suite into the main speculation package, but its always annoying when folks do that. it drags in a ton of spurious build dependencies
21:14:56 <applicative> pustaka, yeah, ghci reads it, i just pasted it and named it 'parsing.lhs'     the 'l' signals to the compiler to strip off everything but the 'birdtracked' lines
21:15:37 <pustaka> thanks, I'll try it again
21:15:52 <dafis> edwardk, make a separate test/benchmark package which depends on speculation
21:16:02 <dafis> for private use only
21:16:06 <edwardk> dafis: the problem is i can't then give it a --srcdir
21:16:12 <edwardk> for hpc purposes
21:16:56 <edwardk> i suppose i'll just add them to the main package and hide them behind flags
21:17:11 <dafis> hmmm inconvenient
21:17:51 <edwardk> i was just hoping to keep the simple 'base, parallel, stm' dependencies i had, this drags in containers, test-framework-*, QUickCheck, HUnit, criterion, etc.
21:18:47 <dafis> I think there's work on making cabal support conditional testing-dependencies
21:19:00 <dafis> but it's not yet in, afaik
21:21:30 <lpsmith> preflex,  seen ddarius
21:21:30 <preflex>  ddarius was last seen on #haskell 18 minutes and 1 second ago, saying: It might be.
21:23:58 <jimmyjazz14> is it at all possible to generalize the following function to work on list of functions of any size: apply2 [a,b] a1 b1 = [a a1,b b1]
21:24:25 <applicative> haha ziplists!!
21:24:59 <ddarius> lpsmith: ?
21:25:49 <applicative> but anyway, why not zipWith ($)
21:26:02 <lpsmith> ddarius, so I finally did get Jones and Gibbons breadth-first labeling working with the codensity monad.
21:26:09 <lpsmith> sort of
21:26:51 <dafis> applicative, methinks they want to pass the arguments not in a list
21:27:05 <applicative> then it's hopeless!! 
21:27:08 <jimmyjazz14> applicative: dafis yeah
21:27:10 <dafis> so it would be a function of variable arity
21:27:29 <applicative> only evil hacks can help you jimmyjazz14
21:27:37 <lpsmith> ddarius, You have to be careful about how you do the lifting,   I don't (yet?) see how to get rid of the use of the lazy state monad's >>= in the definition of fresh
21:27:38 <edwardk> erm does anyone remember how to make the building of an entire executable in cabal dependent upon the presence of a flag?
21:27:42 <dafis> applicative, I think oleg has done it
21:27:44 * applicative is not serious
21:28:02 <jimmyjazz14> Text.Printf does it 
21:28:04 <jimmyjazz14> right?
21:28:07 * applicative knew oleg would be mentioned
21:28:22 * applicative would like to point out oleg is a printf master
21:28:56 <edwardk> Buildable: False
21:28:59 <dafis> jimmyjazz14, right, printf does it, and you could try to mimick it
21:29:39 <jimmyjazz14> I'm looking at this now http://okmij.org/ftp/Haskell/vararg-fn.lhs
21:31:13 <lpsmith> ddarius, I still can't say that I entirely understand the CbN CPS transform, though :)
21:31:42 <applicative> the discussion of printf and scanf in the type families paper is much clearer by dint of the addition of Peyton Jones' lucidity
21:32:39 <applicative> http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
21:33:04 <BMeph> applicative: Not to mention, writing on paper restricts SimonPJ's ability to (literally) hand-wave difficult problems away... ;)
21:33:18 <applicative> jimmyjazz14, but i don't know if it'd help with your problem..
21:33:37 <applicative> BMeph, their different virtues cover for their different vices?
21:34:31 <applicative> no i see, i thought it was Oleg v. SimonPJ as opposed to SimonPJ in print vs. in speech
21:34:45 <pizza_> does anyone know a clear, simple explanation of how to implement 'show' for one's own type? i can't quite figure out which contortions Haskell wants me to go through to print the damn thing
21:34:45 <jimmyjazz14> applicative: I'll give it a look
21:35:28 <Saizan> pizza_: you just have to produce a String
21:35:46 <applicative> jimmyjazz14, i'm no expert, like these others are, but i found it much clearer than anything else by oleg Id seen, and this issue comes up in the last chunk on printf
21:36:06 <Saizan> pizza_: e.g. instance Show Bool where show True = "True"; show False = "False"
21:37:06 <ddarius> lpsmith: Have you ever read Reynold's "Definitional interpreters for higher order languages"?
21:37:07 * BMeph is glad applicative "saw wat i did ther"... :)
21:37:26 <Axman6> instance Show MyType where show _ = "SURPRISE!" works
21:38:05 <lpsmith> ddarius,  not in depth, no,  I kind of skipped to the equations for the CbN CPS transform
21:38:39 <lpsmith> ddarius, err
21:38:57 <ddarius> lpsmith: It's a good read for other reasons.  Probably not the best read for formalized versions of the CPS transform, mostly due to antiquated syntax.
21:39:03 <pizza_> Saizan: now my 'deriving Show' and 'instance Show' are duplicating instance declarations
21:39:08 <lpsmith> Wrong Reynolds paper.   The correct answer is no,  I don't think I've ever read it
21:39:10 <lpsmith> maybe
21:39:33 <edwardk> does anyone remember the version of GHC that added dynamic pointer tagging?
21:39:38 <Saizan> pizza_: well, sure, you've to pick one, you can't have both
21:39:46 <ddarius> edwardk: 6.8?
21:40:01 <edwardk> ddarius: sounds good to me
21:40:07 <lpsmith> edwardk, I'm thinking it was earlier than 6.8
21:40:30 <Saizan> pizza_: anyway, it might make more sense to leave deriving Show there and just define a separate prettyprint function 
21:40:35 <edwardk> lpsmith: well 6.8 will work as a conservative bound for me. i have so many other dependencies i won't build that far back anyways ;)
21:40:43 <lpsmith> heh
21:40:54 <dafis> either 6.8 or 6.6, I'm almost sure it was not in 6.4
21:41:04 <edwardk> adding code to remove my dynamic pointer tagging hacks if you're not using GHC so this stuff could be portable
21:41:56 <dafis> edwardk, and there aren't many ghcs older than 6.8 around anyway
21:42:03 <Saizan> edwardk: don't put ghc in build-depends to check that!
21:42:04 <pizza_> Saizan: but i'd like to inspect my type in ghci :/
21:42:18 <pizza_> er, instances of it
21:42:29 <lpsmith> dafis,  time to dust off GHC 4 :-P
21:42:29 <edwardk> Saizan: i'm not, just adding a couple of __GLASGOW_HASKELL__ checks using CPP
21:42:43 <ddarius> edwardk: Yeah, 6.8.
21:42:53 <lpsmith> Actually I mostly used Hugs until GHC 5 came out
21:43:04 <Saizan> pizza_: you can do that, just apply the prettyprint function explicitly
21:43:08 <dafis> lpsmith, that was before my time, I didn't meet Haskell before 6.2
21:43:28 <ddarius> edwardk: What are you going to replace the code with?
21:43:31 <pizza_> Saizan: this is the best answer Haskell has? seriously?
21:43:42 <jimmyjazz14> pizza_: ":t" in ghci is very handy
21:44:00 <pizza_> jimmyjazz14: i know, sorry, i meant values
21:44:14 <lpsmith> dafis, yeah,  I went through a phase in high school when I really hated all the languages I knew at the time,  which led me to Haskell
21:44:29 <ddarius> @quote ugly.printers
21:44:30 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
21:44:35 <ddarius> @quote uglyprinters
21:44:35 <lambdabot> Philippa says: I'm fed up of writing uglyprinters for values inside an interpreter
21:44:45 <dafis> pizza_, comment out the "deriving Show" and use your own Show instance
21:45:22 <pizza_> yup, figured that out; still doesn't work. works as a separate function though
21:45:42 <dafis> lpsmith, highschool was Apple Pascal for me :)
21:46:26 <lpsmith> Yeah,  Turbo Pascal and  C/C++ for me
21:46:31 <dafis> took about ten years ere I touched a computer again
21:47:13 <Saizan> pizza_: you mean how could haskell not let you define the same function for the same type in two unrelated ways and pick the most aesthetically pleasing according to the situation?
21:47:27 <Saizan> pizza_: you could use a newtype though
21:47:28 <applicative> now now ...
21:47:31 <ddarius> Middle school was QBASIC, x86 assembly, C/C++.  High school was C++, more assembly, Scheme, Prolog, Smalltalk, Java.  At some point I learned Javascript.
21:47:53 <ddarius> Haskell was at the very end of high school.
21:48:26 * applicative used a pencil in high school
21:48:30 <ddarius> (These lists are not comprehensive except, perhaps, the first.)
21:48:41 <Saizan> s/pick/automatically pick/ -- :)
21:48:52 <ddarius> applicative: I didn't actually use any of those languages in high school itself except C++ and Java.
21:48:56 <wli> Getting surpassed by people drastically my junior is hard to deal with.
21:48:58 <lpsmith> Elementary school was basic and pascal,  middle school was object pascal and assembly,  high school was C/C++ and then the search,  which lead me to Modula-3, ML, and Haskell
21:49:07 <jimmyjazz14> I was barely mastering crayons by high school
21:49:16 * dafis rejoices that Saizan spelled aesthetically correctly
21:49:42 * applicative thinks he spells esthetically esthetically
21:49:54 <lpsmith> Though I never got very good at ML or Haskell while I was in high school,  that came between my freshman year of college
21:49:59 <dafis> applicative, NOT funny!
21:50:09 * applicative apologizes
21:50:17 * dafis accepts
21:50:23 <pizza_> Saizan: no, i mean isn't the point of Show to avoid writing a custom prettyprinter ?
21:50:39 <ddarius> Show is not for pretty printing.
21:50:40 * BMeph used CP/M in high school! Still isn't as old as augustss, though. ;)
21:50:47 <applicative> pizza_, why would that be the function of show
21:50:48 <dafis> pizza_: then write your Show instance so that it looks fine
21:50:56 <aavogt> BMeph: and you'll never be
21:51:23 <pizza_> applicative: i don't know, what is the point of it?
21:51:26 * p_l|backup only got to use old software through emulators...
21:51:40 <applicative> pizza_, show is a function from, say, ordered pairs of integers, to strings.
21:51:42 <dafis> pizza_, the point of Show is to display values
21:51:58 <applicative> very valuable if you want to deal with things like pairs of integers, and other abstracta
21:52:02 <pizza_> oh, how non-pedantic of me to not say exactly that
21:52:12 <dafis> preferably in a way that makes it easy to parse the representation
21:52:49 <aavogt> is Show really about serialization? It's rather inefficient most of the time that way
21:52:59 <dafis> that's what deriving Show gives you
21:53:09 <pizza_> a headache?
21:53:20 <jimmyjazz14> pizza_: I've generally looked at deriving Show and Read as being used for debugging and cheap serialization 
21:53:37 <dafis> aavogt, not very efficient, but it's rather easy to write the parsers
21:53:42 * aavogt thinks it's more about being a somewhat human-readable format for serialization
21:53:45 <ddarius> Right now Show is massively overloaded and is used variously for textual serialization, debugging display and pretty-printing.  These purposes are in conflict leading to a variety of issues.  Luckily, we do have classes for each of these purposes now.  Unluckily, people still don't use them.
21:54:01 * applicative finds this mysterious, take away show and we have no contact with numbers, for example.
21:54:33 <jimmyjazz14> pizza_: I generally avoid using show for anything but debugging and cheap serialization
21:54:38 <aavogt> applicative: you have contact with numbers oO?
21:54:48 <pizza_> ddarius: possibly because newbies find the Gentle Introduction to Haskell, which shows 5 versions of how to implement Show, none of which happen to work out of the box
21:55:01 <applicative> aavogt, yes, i use their names
21:55:35 <applicative> aavogt, for each of them, I use  (show it)
21:56:17 <aavogt> ddarius: which is the class for pretty printing?
21:56:25 <applicative> in early versions of Haskell, 'show' had another name, i can't remember
21:56:57 <ddarius> applicative: It was part of the Text class.
21:57:14 <applicative> right, that's it, the class had a different name. 
21:58:17 <ddarius> aavogt: The most conveniently available would be the HughesPJ pretty printer library.  Which I thought had a class associated with it, but I don't see it in the documentation.
21:58:25 <jbapple> Why is it that GHCi can "read" GADTs just find, but standalone deriving can't derive Read for GADTs?
21:58:29 <jbapple> *fine
21:58:48 <aavogt> @hoogle Text
21:58:48 <lambdabot> module Data.Generics.Text
21:58:49 <lambdabot> module Test.HUnit.Text
21:58:49 <lambdabot> Text.Html text :: String -> HtmlAttr
21:58:50 <jimmyjazz14> pizza_: have you looked at http://learnyouahaskell.com?
21:59:00 <jimmyjazz14> pizza_: its more fun
21:59:57 <jbapple> I guess the type sig would be tricky
22:01:01 <applicative> pizza_, i still feel we're not getting clear on  your problem.  It is certainly true that some of the standard Show instances are pretty ugly... anything involving records for example...
22:01:08 <ddarius> aavogt: There's this at least: http://hackage.haskell.org/package/prettyclass
22:01:14 <ddarius> Based on HughesPJ
22:01:16 <pizza_> it's frustrating trying to learn haskell knowing other languages; i know what i want to do but can't find good, straight-forward syntax examples of non-trivial stuff; some of the "haskell for c programmers" was useful
22:01:58 <applicative> pizza_, i have a suspicion that with Show, haskell really is superior
22:02:06 <pizza_> i have a list of tuples, i want to print them out. i can write a function to do so. but i cannot figure out the syntax to make it the "default" "show" for my type
22:02:19 <aavogt> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/prettyclass-1.0.0.0
22:02:22 <pikhq> pizza_: The thing is, Haskell works so radically differently from other languages that it really does just take a lot of time until anything nontrivial becomes clear.
22:02:29 <aavogt> ddarius: that one isn't too popular
22:02:33 <applicative> pizza_ what do you want them to look like?
22:02:48 <pizza_> i already have the function to construct the appropriate string
22:02:53 <ddarius> aavogt: None of them are.  As I said, people aren't using them or equivalents.
22:03:12 <applicative> > zip "abc" [1,2,3]
22:03:13 <lambdabot>   [('a',1),('b',2),('c',3)]
22:03:30 <ddarius> That said, a Pretty class, is not as useful as Show or Binary.  Pretty-printing things doesn't compose quite as well.
22:03:30 <pizza_> yes, i know you guys know how to write silly functions, i do too
22:03:31 <applicative> pizza_ , that's too ugly?
22:03:49 <pizza_> applicative: re-read what i said please
22:04:02 <ddarius> pizza_: There is already an instance for lists of tuples, you can't "override" it with your own.
22:04:09 <applicative> I was just exhibiting the show instance for pairs
22:04:47 <Pseudonym> My Pretty class, that I trot out every now and then, contains the precedence argument like showsPrec
22:04:57 <pizza_> applicative: ok, can you should me the actual "show" part?
22:05:02 <Pseudonym> Precisely because it otherwise doesn't compose well.
22:05:04 <applicative> you can just write newtype Pizza_Pair = (Char, Int) or whatever, then instance Show Pizza_Pair where whatever
22:05:34 <ddarius> This isn't really any different from Python or Java, say, where you also can't override toString for an existing type but you can provide your own toString for your own types.
22:05:38 <pizza_> hmm that's what i have, let me pastebin it
22:05:44 <applicative> the standard show instance for (Char, Int) is derived of course, but it's clear what it is
22:06:21 <ddarius> Pseudonym: Even then, the output of pretty printing a collection of disparate things is likely not going to be that pretty.
22:06:58 <applicative> notice that the standard machinery give *infinitely many* show instances, for tuples, lists, strings, etc etc.
22:07:03 <aavogt> @hackage IPPrint
22:07:03 <lambdabot> http://hackage.haskell.org/package/IPPrint
22:07:12 <aavogt> @hackage ipprint
22:07:13 <lambdabot> http://hackage.haskell.org/package/ipprint
22:07:43 <aavogt> ddarius: but the default show is unreadable for things that take up more than a single line
22:08:22 <aavogt> not that Show should be changed, but that you can do slightly better
22:08:26 <ddarius> aavogt: Easy of (human) reading is not its top priority.
22:08:29 <applicative> pizza_, the universe of things that 'the default show' can deal with is immense, an unbelievable garden of internal relations, functors etc etc
22:08:32 <ddarius> aavogt: Agreed.
22:08:51 <aavogt> applicative: functions not so well
22:09:10 <applicative> of course not!!
22:09:28 <applicative> but pairs of lists of pairs of a bool and an int and ...
22:09:35 <ddarius> aavogt: I might choose a different way to pretty print my trees if they are going to printed out in the context of being elements of a Map v. on their own.
22:09:39 <Saizan> pizza_: are you perhaps trying to define your own instance for something defined with the "type" keyword? which is called a type synonym
22:09:58 <aavogt> though there could be support for showing functions compactly if the compiler was involved
22:10:26 <aavogt> (so rather than printing out a lookup table which you can do now)
22:10:34 <applicative> it's like showing an infinite list
22:10:44 <ddarius> aavogt: That would be fine if we got rid of the Read class and it didn't break referential transparency (which it likely would.)
22:10:46 <pizza_> i must be doing something else silly /me looks
22:10:53 <applicative> it is something for the Gods only
22:11:10 <aavogt> ddarius: overlapping instances break referential transparency?
22:11:37 <ddarius> applicative: God invented the natural numbers, the rest was the work of man.  Thus streams, N -> X are not of God only.
22:11:40 <applicative> aavogt, what do you envisage as 'showing a function'
22:11:44 <aavogt> so long as you know which ones exist, things are still predictable with them
22:12:05 <Saizan> pizza_: i ask because you can't define a separate instance for type synonyms, you need "newtype" instead
22:12:40 <applicative> the truth table for 'or' or 'and', I guess that's showing, but it doesn't tell you what to do with the tabulated truth values
22:12:42 <aavogt> applicative: so you can have    (read . show) f x = f x
22:13:27 <aavogt> without enumerating the domain of f
22:13:28 <ddarius> You can only print out a lookup table for some domains.
22:14:27 <applicative> a lookup table doesn't isolate the function, even when the domain is finite, even when it's Bool
22:15:02 <aavogt> applicative: how not?
22:15:23 <applicative> there are various functions from the socalled lookup tables to the function that is supposedly embodied in them
22:15:57 <applicative> how do i know which to use?
22:16:22 <aavogt> you can tell the difference between them?
22:16:25 <Saizan> you'd need to show two conflicting ones to make your argument more convincing
22:16:55 <applicative> have to work on it, just a sec
22:17:02 <Saizan> though laziness is easily lost with the naive tabulation, i guess
22:17:43 <ddarius> Saizan: Indeed.  There are (as always) issues with bottom.
22:17:53 <aavogt> you couldn't tabulate with _ ?
22:18:43 <aavogt> I suppose that show function would be rather nasty then
22:19:12 <applicative> so the whole truth about 'and' is in
22:19:19 <applicative> > [((x,y), x && y) | x <- [True, False], y <- [True, False]]
22:19:20 <lambdabot>   [((True,True),True),((True,False),False),((False,True),False),((False,False...
22:19:49 <aavogt> you need to check undefined too
22:20:02 <applicative> to hell with undefined.
22:20:21 <applicative> I am in utopia, haven't you noticed?
22:20:44 <aavogt> dystopia
22:21:09 <aavogt> where all values are _|_
22:21:09 <Saizan> so, without bottoms, where's the ambiguity?
22:22:22 <applicative> you are presupposing something like the lookup function
22:22:40 <aavogt> Saizan: is there ambiguity with bottoms if you're willing to try with undefined (and catch the exception when it you needed the value)?
22:22:50 <ddarius> applicative: Indeed that is exactly what is happening and it works fine.
22:23:14 <applicative> but now, let us ask about the table for 'lookup :: (Bool, Bool) -> Bool'
22:23:35 <applicative> is the whole truth about lookup contained in the lookup table for it?
22:23:44 <ddarius> lookup' :: Eq a => [(a,b)] -> a -> b
22:24:32 <applicative> I was thinking of the one with Maybe, but omitted it, since I had a palpable searchable domain
22:24:36 <Saizan> aavogt: i don't think so, though it'd get more complicated with less flat types i imagine
22:24:54 <aavogt> there is a different lookup function for serializing lookup (or take the typeclass route)
22:25:26 <applicative> the game of considering the function to reside in something like a lookup table has to come to an end with something like a lookup function that is not regarded in this way
22:25:43 <applicative> the point was already labored by Frege in the 1880s
22:27:00 <Saizan> yeah, you need a machine where you'll run your code at some point, i don't think that's been much of a problem
22:30:47 <applicative> the machine does bring the point out pleasantly, but one is already given pause by e.g. the set theoretic reduction of 'functions' and 'relations' to 'sets of ordered pairs' ... what about the relation 'is an element of'?
22:31:30 <aavogt> you need axioms somewhere
22:32:03 <applicative> no, you need to make sure that not everything in the sentence is a name
22:32:38 <applicative> 'show' gives us the canonical name. 
22:35:01 <applicative> similarly, i can define ($) f x, as f x, but i can't explain the role of whitespace with $
22:36:03 <applicative> i propose a lookup table in which we show what is meant in Haskell by whitespace!
22:36:29 * Saizan wonders if there's some technique to automatically rewrite "generate and filter" algorithms into "propagate and distribute" ones
22:37:03 <applicative> when i have this table, then i will really understand!
22:37:07 <Pseudonym> Saizan: Not if the goal is to automatically parallelise non-parallel code.
22:37:41 <Saizan> Pseudonym: the goal is to get a nicer reason in the case no solution is found
22:38:18 <Pseudonym> My honours thesis was about automatically folding "tests" into "generators".
22:38:50 <Pseudonym> Which turned out to be useful on many toy programs, but make no difference on real applications, because people just don't write code like that.
22:39:02 <Pseudonym> I think it worked better on database query systems.
22:40:13 <Saizan> well, i have "listToMaybe . filter test . sequence candidates" currently :)
22:40:43 <pizza_> can someone explain the bone-headed mistake i'm making? http://gist.github.com/455474
22:41:11 <Saizan> pizza_: you've to pattern match on the WordGram constructor
22:41:19 <Pseudonym> show (WordGram w) = ...
22:41:25 <Pseudonym> And, BTW...
22:41:32 <applicative> try   show (WordGram
22:41:38 <Pseudonym> 1) the type is called WordHGram and the constructor is called WordGram
22:41:39 <applicative> these guys are too fast for me...
22:42:03 <Pseudonym> 2) Unless you're planning to extend WordHGram, "newtype" is probably better than "data" here.
22:42:13 <pizza_> Pseudonym: yes i know, i was unclear if the type should be the same or different than the constructor
22:42:16 <pizza_> ok
22:42:24 <Pseudonym> Looks like you just want a compiler-checked typedef.
22:42:29 <Zao> pizza_: A ctor may have the same name as the type.
22:42:39 <applicative> you can call them the same, it's different namespaces as they say
22:42:44 <Pseudonym> And, indeed, this is a common idiom.
22:43:13 <applicative> Pseudonym, but it wasn't formerly, in older manuals there's always MkWordGram...
22:43:23 <Saizan> and you should use "show n" rather than "show(n)", parentheses are used more like in lisp than in C
22:43:35 <Pseudonym> applicative: Which makes a certain amount of sense under some circumstances.
22:43:45 <Pseudonym> Like if you want to hide the constructor in a module.
22:44:16 <Saizan> or if you want to avoid confusion when teaching ADTs :)
22:44:23 <Pseudonym> But yeah, I haven't seen that convention in a while.
22:44:29 <applicative> Psuedonym, yes, either way has trouble
22:44:41 <Peaker> I hide a lot of my constructors
22:44:54 <pizza_> and there was much rejoicing
22:44:56 <Pseudonym> I sometimes call my newtype constructor something different from the type name if I want to visually enforce construction only through a smart constructor.
22:45:10 <Pseudonym> Another useful idiom:
22:45:23 <Pseudonym> newtype Foo = Foo { unFoo :: Some Type }
22:45:39 <Peaker> Followed by: inFoo f = Foo . f . unFoo
22:45:45 <Peaker> inFoo2 f = inFoo . f unFoo
22:45:46 <Peaker> oops
22:45:53 <Peaker> inFoo2 f = inFoo . f . unFoo   -- plus all the type signatures
22:46:14 <Peaker> Maybe even: withFoo f = unFoo . f . Foo ; withFoo2 = ...
22:46:31 <edwardk> i've become more partial to getFoo or runFoo than unFoo =) the camelcase is so jarring on unFoo =)
22:46:38 <Peaker> I hate duplicating all this newtype boilerplate, but I hate TH too.. I want to use a TH macro to generate this that yairchu made but I'm not sure it works with all GHC versions
22:46:49 <Pseudonym> runFoo makes sense if it's a monad.
22:46:57 <Peaker> edwardk, You should make a strong effort to not care about such things :)
22:47:02 <Pseudonym> getFoo makes sense if it's Plain Old Data.
22:47:10 <Pseudonym> If it's something in between...
22:47:13 <Peaker> I like "unFoo" always so I don't have to remember/guess
22:47:20 <Peaker> If you want, you can make a runFoo alias
22:47:23 <edwardk> Peaker: i tried. sadly, it still makes me twitch;)
22:47:26 * applicative is using class Newtype following Conor McB. without much success
22:48:28 <edwardk> so what do i have to do to get criterion to spit out all its vaunted pretty charts under ghc 6.12.1 on linux?
22:48:49 <edwardk> i can get a csv, but everything i ask it to do it complains about not supporting on this platform
22:49:11 <applicative> what platform is it supported on?  not on a mac, ....
22:49:19 <Peaker> applicative, what's "class Newtype"?
22:49:20 <kniu> is there a program that
22:49:36 <kniu> looks at your haskell program, sees repeated code, and suggests abstractions?
22:49:49 <Peaker> kniu, hlint does a bit of that
22:50:03 <Peaker> (sees some common patterns and tells you to use library functions that do it"
22:50:06 <edwardk> i have a bad penchant for abusing generalized newtype deriving and Iso with newtypes ;)
22:50:17 <edwardk> to avoid having to use fmap MyNewType all over the place
22:50:23 <Peaker> Now that newtype-deriving is known to be problematic, will it be rejected?
22:50:38 <edwardk> Peaker: i hope not, it is damn useful, even with the hacks =)
22:50:54 <Peaker> maybe there's a weaker construct that gives most of the benefits without the dangers?
22:51:01 <applicative> Peaker, I was just studying some things from Haskell-Cafe he wrote.  Here's an ugly module http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26628#a26628
22:51:05 <Peaker> I didn't understand the danger yet
22:51:33 <kniu> well, if I write something like "let f = foo bar baz; g = foo bar" will it be smart enough to suggest "let f = g baz" ?
22:51:50 <Peaker> applicative, Yeah that's a nice idea! Then all I need is an auto-deriver for the instances
22:51:57 <Peaker> applicative, thanks for that :)
22:52:27 <applicative> here's the message, http://www.haskell.org/pipermail/haskell-cafe/2009-December/070019.html  it links some older pre-type family things
22:52:27 <Peaker> I wish Haskell had even implicit auto-instances for various classes (e.g: Typeable, this Newtype class)
22:52:29 <kniu> that's more what I'm looking for, since some of these functions I'm writing seem rather hard to refactor for me, even though I do see lots of repeated code in them.
22:53:20 <edwardk> hrmm is there a good way to get your custom cabal testHook to run the build if it hasn't been done yet?
22:53:42 <Peaker> kniu, paste some code, #haskell is a nice program to do it :)
22:54:20 <edwardk> clearly ala should be split into two functions so you can say 'a la' ;)
22:54:46 <applicative> edwardk, we can arrange for this hack....
22:55:28 <applicative> la = () , etc
22:56:54 * hackagebot speculation 0.8.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.8.0 (EdwardKmett)
22:57:42 <applicative> edwardk, you are completely out of control!
22:57:58 <c_wraith> Also, shouldn't you take a nap or something?
22:58:10 <applicative> hackage needs a rest
22:58:14 <edwardk> applicative: hah
22:58:32 <edwardk> well i know i'll get little chance to work on this over the next 3 days or so
22:58:39 <edwardk> so i wanted to make some good headway
22:58:58 <Phyx-> edwardk: you pulling an all nighter too huh
22:59:09 <c_wraith> he's pulled an all-weekender
22:59:10 <edwardk> Phyx-: nah i got a couple of hours of sleep
22:59:34 <Phyx-> oh, I haven't yet...
22:59:58 <edwardk> c_wraith: it led to a few combinators: http://hackage.haskell.org/packages/archive/speculation/0.7.0/doc/html/Data-Foldable-Speculation.html
23:00:36 <edwardk> and now i can just 'cabal test' to check code coverage for my er.. well all but empty test suite
23:00:54 <edwardk> i also need to write some benchmarks now that i have criterion working
23:06:57 <Phyx-> i <3 tuples
23:07:18 <Peaker> I have a whole lot of newtype boilerplate that I need to replace with "class Newtype"
23:07:30 <Peaker> (significantly smaller instance boilerplate..)
23:11:39 <edwardk> there is another hack that works well with getting in and out of newtypes
23:13:01 <edwardk> class Iso a b where iso :: f a -> f b; osi :: f b -> f a; instance Iso a a where iso = id; osi = id; then you can use generalized newtype deriving to add instances for Iso (whatever the contents arg) to get in and out of your newtype
23:13:30 <edwardk> which has the benefit of working through containers (as long as you know the container is polymorphic in its contents, and isn't something like Set)
23:14:58 <kniu> Peaker, very well.
23:15:00 <kniu> @hpaste
23:15:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
23:15:13 <Peaker> edwardk, I hate overlapping instances
23:15:29 <Peaker> edwardk, Would I need them here?
23:15:32 <Peaker> edwardk, for Iso?
23:15:45 <Peaker> Maybe not, if it's just an instance for "a" "a"
23:15:47 <edwardk> Peaker: well, these only come about through generalized newtype deriving and aren't ever created by you ;) so oddly you can get them even without turning on the extension
23:16:04 <Peaker> edwardk, Maybe there's no overlap though
23:16:16 <edwardk> there is technically because when you go and define something like
23:16:33 <kniu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26629
23:16:58 <edwardk> newtype AD s a = AD (s a) deriving (Iso (s a)) -- the instance that results is Iso (s a) (AD s a) -- which overlaps the underlying Iso a a -- but does so in a consistent way, they have the exact same definition!
23:17:23 <edwardk> so while they appear to be overlapping, they are just the same instance given broader scope
23:17:49 <edwardk> Iso just witnesses the isomorphism, no extra dictionaries are made, removed or harmed in the process
23:19:20 <Peaker> edwardk, Why does it overlap? (s a) /= (AD s a)
23:19:37 <Peaker> The newtype wrapper means it's a different type, doesn't it?
23:19:45 <Peaker> so the instance doesn't overlap
23:20:22 <edwardk> the newtype wrapper means it has a different type, but they have the same underlying representation. so yes it overlaps, but it is just the same dictionary being passed in both cases
23:35:16 <Jefskell> How much slower are programs run interactively (though ghci) compared to compiled programs?
23:38:42 <kniu> holy netsplit, batman!
23:38:55 <Zao> Jefskell: Depends on how hard you optimize the non-interactive ones.
23:40:36 <dons> Jefskell: about 30x on average
23:40:55 <dons> Jefskell: ghc -O2 ftw.
23:41:12 <ivanm> dons: read through my arguments about rewrite vs rename yet?
23:44:20 <Jefskell> dons, thanks. 
23:47:54 <Phyx-> wow, i need a new font.... i spend 30mins looking for a bug because 1 and i look alike
23:48:38 <Peaker> hehe
23:55:02 <Axman6> Phyx-: try Anonymous (Anonymous Pro)
23:55:06 <Axman6> or*
23:55:13 <ivanm> hey Axman6 
23:55:16 <Axman6> o/
23:56:28 <Phyx-> hm, Anonymous? *looks it up*
23:56:50 <Axman6> i use it everywhere
23:57:37 <Phyx-> cool, i'll give it a try
23:57:44 <quuxman> Can cabal install libraries based on the module path, as opposed to the package name?
23:57:49 <quuxman> or at least search for them?
23:58:04 <quuxman> @hoogle Text.Templating.Heist
23:58:04 <lambdabot> No results found
23:58:40 <quuxman> (in this case it's pretty obvious, as it's in the 'heist' module :-P)
