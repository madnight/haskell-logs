00:04:00 <triyo> In haskell I can't pattern match on type like so ...  myFunc (Just (String s)) = s .... as String is not a constructor, right?
00:06:11 <ihckt> triyo: correct.
00:06:12 <kmc> right
00:06:22 <kmc> though you are free to declare something silly like «data Foo = String Int»
00:06:27 <kmc> now String is a data constructor
00:06:37 <ksf> if you hide the current definition, first.
00:06:57 <kmc> not necessary
00:07:10 <kmc> because types and data constructors have different namespaces
00:07:27 <kmc> this declares a new constructor «String :: Int -> Foo» which has nothing to do with the type named String
00:07:35 * ksf wonders whether they can clash anyways or he's imagining things in the morning.
00:07:43 <kmc> try it
00:07:50 <ksf> naaaah
00:07:57 <kmc> of course any users of your code would be justified in wanting to beat you with sticks
00:08:36 <triyo> ok, so I'm trying to create a print function that will Pattern match on Maybe's constructors but needs to extract the value from field and do something to the value depending on the type. Hope this make sense..
00:08:48 <kmc> it's a nice convention that if a constructor and a type share a name, that constructor is for that type and is the only constructor for that type
00:09:00 <kmc> triyo, you can't make a function that does different things depending on the type
00:09:04 <kmc> you'd have to make a type class
00:10:44 <kmc> the regular kind of polymorphism (parametric polymorphism) is for doing the same thing to values of different types
00:11:02 <kmc> if you have a function «Maybe a -> Bool» you know it can't care what type «a» actually is
00:11:05 <triyo> right
00:11:33 <kmc> this is a useful property; for example we can surmise that there are only a few interesting functions of that type
00:12:29 <kmc> adding a type class constraint to the type now lets you do certain operations in a type-specific way
00:12:36 <kmc> showing, comparison, equality, addition, etc.
00:13:06 <kmc> the extreme case is the Typeable type class, which lets you do run time type queries and safe casts
00:13:28 <kmc> so once you see Typeable on a function, you lose all parametric guarantees
00:13:40 <triyo> I wont go the Typebale route
00:14:09 <triyo> I'll go the parametric  polymorphism route 
00:14:16 <triyo> thx
00:14:20 <kmc> with a type class?
00:14:43 <triyo> right, that will work no problem, I just had a look.
00:14:47 <kmc> that's called "ad-hoc polymorphism", by contrast with parametric polymorphism
00:15:24 <kmc> though you can think of Haskell's ad-hoc polymorphism as parametric polymorphism + a system of implicit function arguments
00:15:36 <kmc> so it's nearly sugar
00:17:32 <triyo> Ad-hoc is like "overloading" in Java right?
00:18:06 <kmc> Java's overloading is an example of a language feature providing ad-hoc polymorphism
00:18:08 <ksf> ad-hoc as in "blast static typing, we're going to do that anyway"
00:18:19 <kmc> ad-hoc can be fully static though
00:18:35 <kmc> the language feature providing ad-hoc polymorphism in Haskell is not very much like the language feature providing ad-hoc polymorphism in Java
00:20:08 <Saizan> i think typeclass polymorphism is actually distinct from the ad-hoc one
00:21:42 <aleator> ST is rattling my brain, help anyone? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26511#a26511
00:22:43 <Saizan> aleator: don't use $
00:22:44 <c_wraith> aleator, $ doesn't work with runST
00:22:56 <aleator> What?
00:23:18 <c_wraith> $ only works with rank-1 types
00:23:23 <c_wraith> runST has a rank-2 type
00:23:53 <aleator> Well. I always learn something new :)
00:23:59 <Saizan> and why are you inserting the Gen in a STRef ?
00:24:34 <aleator> I don't want to keep passing it and need just a single gen. The idea is to port some old code using monadrandom to mwc.
00:24:51 <Saizan> use ReaderT (Gen s) (ST s) then
00:25:14 * ManateeLazyCat pasted "broadcast channel" at http://paste2.org/get/890320
00:25:15 <ManateeLazyCat> Saizan: I have use TChan build broadcast-channel (like above), thanks for your suggestion! :)
00:26:27 <aleator> Saizan: Umm. I'm not really familiar with this, but since gen needs to be made inside st, how do I get it into the reader?
00:27:42 <Saizan> e.g. runST $ runReaderT op =<< initialize (I.fromList s)
00:27:44 <kamatsu> argh, whenever i try and do serious modelling in haskell i tend to fall back to my OO habits.
00:27:48 <Saizan> well, without the $
00:28:10 <kmc> kamatsu, sometimes you actually do want objects, and there are some decent ways to get them in Haskell
00:28:17 <Saizan> actually you can use a monad that hides the 's' too, so you don't have to care about it
00:28:26 <Saizan> ManateeLazyCat: np :)
00:28:31 <kmc> without even using type classes and existentials and all that
00:29:07 <kamatsu> kmc: what I'm trying to model is a solar system. So, we have stars, and planets. I'm not doing a real gravitational simulation, so I set it up  so that each celestial body knew the object about which it was orbiting
00:29:29 <kmc> sounds object-oriented to me
00:29:35 <kamatsu> yeah
00:29:47 <kamatsu> is there a way to represent this nicely in an immutable data graph?
00:29:58 <kamatsu> or should I go and do some OO Haskell
00:30:21 <kmc> well the first step of doing OO in Haskell is to remember that records can contain functions and actions
00:30:25 <ManateeLazyCat> kamatsu: When you write Haskell code, forgot everything about OOP. ;-)
00:30:32 <kmc> so you don't need to invent new types everywhere you need a new behavior
00:30:39 <kmc> as is the case in some (the more poorly designed) OO languages
00:30:53 <kmc> now doing it immutably seems like a different question
00:31:28 <kmc> what kind of container are all the objects in?
00:31:34 <kamatsu> a list.
00:31:40 <kmc> ah
00:32:02 <aleator> Saizan: How do I do that actually? (I'm still brainfrozen at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26511#a26512)
00:32:23 <ManateeLazyCat> Saizan: Before TChan, i want to use "TVar (share state) + List (listener)" to implement broadcast channel. Now dupTChan do those automatically and i got better framework, sweet. :)
00:32:24 <kmc> how about:  data Body = Body { position :: Pos, update :: Pos -> [Body] -> Pos }
00:32:34 <kmc> update gets this body's position and the list of other things
00:32:42 <kmc> and it's free to be a different function for each body
00:32:45 <Saizan> aleator: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26511#a26513
00:32:58 <kmc> so it could select one thing to orbit, or several, or do something else entirely
00:33:10 <kamatsu> hm
00:33:49 <kmc> btw
00:33:50 <kamatsu> but how would it know that it was orbiting the same body between update calls?
00:34:08 <kmc> one of the DPH papers uses a gravitational simulator as a running example
00:34:13 <kmc> it's quite neat
00:34:36 <kmc> kamatsu, it knows because that information is baked into the function for "update"
00:34:44 <kmc> which is a different function for each body
00:34:47 <kamatsu> sure
00:34:55 <kamatsu> but how can it identify the body from the list provided?
00:35:04 <kmc> oh, that's elided ;)
00:35:12 <kmc> presumably by a name field or something
00:35:23 <kamatsu> right, so, for performance, perhaps replace it with a Map
00:35:26 <kmc> maybe you want type Universe = Map String Body
00:35:26 <kmc> yes
00:35:52 <kmc> now maybe you don't need this generality
00:35:58 <kmc> if all your objects orbit exactly one object
00:36:18 <kamatsu> ah, it's a tree then
00:36:26 <kmc> in which case a Java or C++ transliteration would have only one class
00:36:32 <kamatsu> CenterOfTheUniverse { orbiters: [bblah] }
00:36:39 <kmc> ok
00:36:55 <kamatsu> that might be the best approach
00:37:20 <kamatsu> oh yeah, i've seen that DPH demo, it was cool
00:37:23 <kmc> but if your Java or C++ code would have subclasses, then it's very painful to do that with fake subtyping in Haskell, and much easier to just shove the methods into the record
00:37:33 <kmc> in which case your Haskell type represents not an OO class but an OO interface
00:38:22 <kamatsu> and each implementation is a function
00:38:26 <kamatsu> each "class"
00:38:55 <aleator> Saizan: Thanks. I'm still bit confused, but atleast it works now.
00:41:11 <quuxman> @src map
00:41:11 <lambdabot> map _ []     = []
00:41:12 <lambdabot> map f (x:xs) = f x : map f xs
00:43:25 <kmc> map f = foldr ((:) . f) []
00:43:53 <Saizan> aleator: yeah, your original problem was caused by the predicative nature of haskell polymorphism, so since ($) :: forall a b. (a -> b) -> a -> b and runST :: (forall s. ST s c) -> c, to typecheck (runST $) you'd have to instantiate the type variable 'a' in ($)'s type to "forall s. ST s c", but that'd require impredicative polymorphism, since the latter type has a forall in it.
00:44:28 <quuxman> I'm writing some basic functional stuff for JavaScript. This has to have been done already... anybody know of a good library?
00:44:46 <ManateeLazyCat> Saizan: Why not upload your hbuild to hackage? It's really useful.
00:44:48 <Saizan> aleator: the problem is that there are several technical problems in the way of type inference for impredicative types, so they are not currently supported
00:46:24 <Saizan> ManateeLazyCat: so you use it for inferring build-depends?
00:46:40 <ManateeLazyCat> Saizan: Yes.
00:46:52 <ManateeLazyCat> Saizan: I'm get your hbuild from darcs.
00:47:00 <aleator> Saizan: Thanks. I'll go and read a bit about this. 5 years of working with haskell daily and I still get to do this :)
00:47:45 <quuxman> I was surprised and irritated to find that in jQuery, "$.map" is equivalent to (=<<)
00:47:51 <Saizan> aleator: type systems are a large topic :)
00:48:19 <ManateeLazyCat> Saizan: I always try to use many new libraries, and i will remove some libraries sometimes, so i use your hbuild inferring build-depends. :)
00:49:24 <Saizan> ManateeLazyCat: i see :) though it was supposed to be a build system too.
00:50:29 <ManateeLazyCat> Saizan: I guess you will upload to hackage just when it perfect. ;-)
00:51:29 <kmc> quuxman, why irritated?
00:52:24 <quuxman> kmc: because I wanted plain old map. I found a functional JavaScript library though: http://osteele.com/sources/javascript/functional/
00:52:39 <kmc> ah
01:05:21 <aleator> Yay. mwc-random actually did improve my programs efficiency by almost exactly 100%
01:19:13 <Martijn> Good morning
01:20:15 <otto_s> Morning.
01:23:15 <Martijn> I'm looking for tutorials on the Fix datatype. Does anyone know any?
01:23:42 * ksf thinks there should be something like idle eval that eagerly evaluates left over thunks when the system is idle
01:23:53 <ksf> ...to save memory, that is.
01:25:08 <ski> so it should evaluate `iterate succ 0' to save memory ?
01:25:54 <ksf> no, not really.
01:26:22 <ski> how to determine what to evaluate ?
01:26:39 <ksf> supero does similar decisions, doesn't it?
01:26:57 * ski doesn't know
01:27:21 <ksf> if everything fails, you could just try different thunks and see whether they become smaller or bigger after n steps
01:27:28 <ski> sometimes, it could be nice to have the RTS replace an evaluated value with the originating thunk ..
01:27:49 <ksf> ...and do those that become smaller fast first, and give up on those that don't get smaller after a certain n
01:27:52 <ksf> (or blackhole)
01:28:12 <ksf> that's true.
01:28:42 <ski> (.. sortof like a weak pointer)
01:29:08 <int-e> but where do you store that information and when do you throw it away?
01:30:18 <ski> one could have a new datatype, with an extraction function to get the thunk, and increment a count on each GC, until some bound is reached
01:35:43 <SailorReality> [ xs | concat(xs)<-[1,2,3]]
01:36:03 <SailorReality> why doesn't that produce [ [[1]],[[2]],[[3]]] 
01:36:40 <ksf> because it's a syntax error?
01:36:51 <SailorReality> why 
01:36:52 <ksf> you can't have functions in patterns
01:37:22 <SailorReality> but concat(xs)<-[1,2,3] is a boolean expression isnt it
01:37:29 <Saizan> no
01:37:57 <ksf> > [ [[x]] | x <- [1,2,3] ]
01:37:58 <lambdabot>   [[[1]],[[2]],[[3]]]
01:38:11 <SailorReality> im trying to do subset of all sets
01:38:32 <Saizan> > filterM (const [False ..]) [1,2,3]
01:38:34 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
01:38:42 <SailorReality> lol thanks
01:38:53 <Cale_> > combinations [1,2,3]
01:38:54 <lambdabot>   Not in scope: `combinations'
01:38:59 <Cale_> oh, right
01:39:30 <Saizan> "filterM (const [False ..])" is more brain damaging anyway :P
01:39:47 <Cale_> er, it's subsequences anyway
01:39:53 <Cale_> > subsequences [1,2,3]
01:39:54 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
01:40:00 <Cale_> there we are :)
01:40:18 <Cale_> But yeah, I like filterM (const [True, False])
01:40:37 <wto> that definately looks more magical :D
01:40:46 <Cale_> It's probably the clearest possible implementation of that function, once you know what filterM is :)
01:41:09 <SailorReality> i like code that's impossible to read and looks really difficult
01:41:13 <Cale_> It says "for each element in the list, no matter what it is (const), take it or leave it"
01:42:15 <Cale_> (and do that in all possible ways)
01:44:12 <Martijn> Sorry to repeat my question. I'm hoping someone can help me. :-) I'm looking for tutorials on the Fix datatype. Does anyone know any?
01:44:25 <Palmik> Hmm... the first version seem to work, but what is wrong with the second one? http://codepad.org/o9v4vZlA
01:45:25 <int-e> 'subsequences' has better memory usage properties than the filterM_ version though, and works on infinite lists ...
01:45:53 <Saizan> Martijn: data Fix f = Fix (f (Fix f)) ? 
01:47:32 <Saizan> Palmik: a pattern like (x:xs) (btw, you lack parentheses there) only matches non-empty lists.
01:47:51 <Saizan> Palmik: in fact null (x:xs) will always be false.
01:48:02 <Palmik> gives sense, thanks :)
01:48:53 <Saizan> to do it with a guard you'd have to "sumItems xs | null xs = 0 | otherwise = head x + sumItems (tail xs)" but that's very poor style
01:49:02 <Martijn> Saizan: Yes. I intend to write a blog post explaining it but I would like to see what is already out there.
01:49:43 <Palmik> Saizan, yep, I will probably stick with the first version, thanks :)
01:50:13 <Martijn> Saizan: I have only found http://blog.plover.com/prog/springschool95-2.html so far. I thought there was a haskellwiki page as well but I can't find it.
01:50:38 <Saizan> http://knol.google.com/k/edward-kmett/catamorphisms# <- Mu here
01:51:25 <Saizan> http://comonad.com/reader/2009/recursion-schemes/ <- for context and other uses
01:52:41 <Martijn> Thanks!
01:54:34 <Martijn> Ah I found the haskellwiki page: http://www.haskell.org/haskellwiki/Indirect_composite
02:05:50 <aleator> I'd like Data.Unboxed.Vector to be NFData. What would be smart way to do this?
02:06:24 <ksf> just stub the instance
02:07:10 <aleator> ksf: Thanks. That is enough?
02:07:20 <Saizan> since it's unboxed seq is enough i think
02:07:40 <Saizan> so rnf x = seq x ()
02:07:57 <ksf> meh. fail.
02:07:57 <ksf> just implement the interface ;)
02:09:08 <Martijn> NFData is a nice example of a class that could be derived
02:10:57 <Saizan> Data.DeriveTH.makeNFData
02:12:45 <aleator> Has anyone hacked a list-comprehension like thingy for vector yet? Seems like nice place to learn of quasiquotes
02:13:23 <cwb> Is there a neat way to supply a tuple of values as arguments to a function?
02:13:40 <Starfire> :t uncurry
02:13:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:15:20 <cwb> Starfire: How does it generalise to N arguments?
02:15:39 <Starfire> It doesn't.
02:16:12 <cwb> So I'm out of luck if I have a tuple of say 7 values that I want to pass to a constructor?
02:16:15 <Martijn> Not in Haskell anyway
02:16:35 <Martijn> cwb: No, you can write an uncurry7 if you like.
02:16:50 <Saizan> or you can pattern match directly
02:16:54 <Starfire> I wouldn't really call \(a,b,c,d,e,f,g) -> C a b c d e f g or something as being 'out of luck' in that case.
02:17:23 <Saizan> (a 7 tuple is kind of an abomination btw!)
02:17:24 <cwb> Sure, that's fair. Thanks!
02:17:34 <byorgey> if you have a 7-tuple you had no luck to begin with.
02:18:02 <Martijn> :-)
02:21:34 <cwb> Yeah, I take your point; a more general question then: I've got a "profile" type with 7 fields which I read from a DB. Some fields may not exist so values are all Maybes. Some values have defaults, some don't. I end up with a set of Maybe values which if any one is Nothing, I return Nothing, else I return Profile a b c d e f g. Any thoughts on how I might do that best?
02:21:38 <Tomsik> unless you're working in R^7
02:24:55 <Starfire> cwb: You could use Applicative.
02:26:15 <Starfire> cwb: Profile <$> a <*> b <*> ... , where a :: Maybe a, b :: Maybe b etc.
02:27:08 <cwb> Starfire: Never used those before, so I'll read up on them now. Thanks for the suggestion!
02:27:28 <ksf> cwb, have a look at the typeclassopedia for applicatives
02:27:33 <ksf> @where typeclassopedia
02:27:34 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
02:28:22 <ksf> and if you want to dig deeper into it, the paper describing the utrecht parser is a very decent example
02:29:14 <cwb> ksf, thansk!
02:32:42 <aleator> hmm.. Moved my program to vector and mwc-random and I'm 2.8 faster than before but still 2 times slower than python..
02:33:04 <Saizan> something is wrong
02:33:18 <Saizan> profile!
02:33:41 <aleator> Yep. Currently getting all cabals that didn't come with profiling again.
02:34:16 <ksf> editing .cabal/config to enable profiling is the very first thing I do each time I nuke it.
02:34:22 <aleator> Is 6.12 much faster than 6.10
02:34:41 <aleator> ksf: Yeah. Mine too. But often I just forget.
02:38:48 <aleator> hmm.. It's still spending 50% of the time in mwc-random..
02:41:14 <Sadache> I am looking for a Haskell modules browser that I can use when I am offline.
02:42:35 <ksf> just use your favourite browser and point it to your local haddock index?
02:43:25 <Sadache> ksf: interesting, I'll try that out
02:43:56 <Sadache> ksf: Actually I use emacs and sometimes I open Leksah for browsing packages
02:44:08 <Martijn> Sadache: http://www.mail-archive.com/haskell-cafe@haskell.org/msg54646.html
02:44:56 <Sadache> and I was wondering if there is any extension to emacs to have some auto completion or documentation
02:45:01 <triyo> I've written a simple parser using parsec, can I create an instance of Read and leverage my parse function(s)? So that one could use 'read' function lie so .... read "@FIXME(bob): do something..." :: FixMeEntry
02:45:29 <Martijn> triyo: yes, of course
02:46:20 <triyo> ok good, thanks Martijn. Is that common practice in scenario as such?
02:46:57 <Martijn> triyo Not really, it's usually considered good practice to only have derived instances for Read
02:47:28 <Martijn> but not everyone agrees on this
02:49:36 <triyo> Hmm, I read that I think in RWH.
03:01:10 <Tomsik> how did the gates in icfp work?
03:06:58 <mreh> xargs would be exactly like a lambda expression if I could use variable scoping
03:08:42 <mux> yeah, xargs is like the functional counterpart of 'for' loops in shell
03:09:02 <mux> what did you mean by variable scoping though?
03:09:42 <mreh> injecting a symbol into a sub-expression, like a series of commands piped together
03:10:05 <mux> you can do that with most xargs(1) I know of using -i or -I flags
03:10:46 <mreh> the shell parses the pipes as being higher precedence than xargs
03:11:06 <mreh> can I use brackets to dictate the precedence?
03:11:18 <mux> if I understand what you're doing correctly, yes
03:12:05 <mreh> well, I want to "map" a sed command to a whole list of files
03:12:28 <mreh> so I've got to put the filename on both sides of a >
03:13:11 <mux> find . ... | (xargs -i% sed ... % > %.new) or something, should work
03:13:21 <mreh> on a higher level I'm replacing every tab with 8 spaces
03:13:27 <mreh> in a source tree
03:13:39 <mux> as usual, use -print0 and xargs -0 if filenames can contain spaces
03:14:07 <mreh> i find xargs -0 ignores the newlines when you pipe in a list of files from an "ls" or "find"
03:14:23 <mreh> and processes the whole input as a single file name
03:14:30 <mux> xargs -0 delimits filenames by the ascii zero character, it's only supposed to be used with find ... -print0
03:14:39 <mux> it's a hack
03:16:21 <ksf> IFS!
03:24:02 <mreh> mux: that command redirects all the output to a file named "%"
03:24:25 <mreh> > has lower precedence than xargs itself
03:24:26 <lambdabot>   Not in scope: `has'Not in scope: `lower'Not in scope: `precedence'Not in sc...
03:24:36 <mreh> @botsmack
03:24:36 <lambdabot> :)
03:25:45 <mreh> the terminal doesn't like: "find . | grep .hs$ | xargs -I% (sed 's/\t/        /' % > %)"
03:26:02 <mreh> my bash-fu is weak
03:27:22 <FauxFaux> sed -i
03:27:53 <mreh> bash: syntax error near unexpected token `('
03:27:57 <cwb> Starfire, ksf: Thanks for your Applicative suggestions; I'll need to do a bit more reading and playing but it solved my problem.
03:28:26 <FauxFaux> mreh: xargs -I{} sed -i 's/\t/   /' {}
03:29:13 <mreh> FauxFaux, how do I then redirect the output for each file back into the file itself
03:29:34 <mreh> I'm sure the haskell spec uses eight spaces for a tab
03:30:00 <mreh> it has an identity crisis
03:31:45 <triyo> Can someone pls give me (noobie) a bit of hand with this http://gist.github.com/451292 
03:31:53 <mux> mreh: looking back, there's no way what I said would work; I'd use the -i flag of sed to avoid having to do a shell redirection
03:32:38 <triyo> I am trying to parse a value between parenthesis and then split the value into two parts. Though both parts are optinal hence the use of optionMaybe 
03:33:20 <mreh> triyo: read is only used to parse Haskell expression
03:33:22 <triyo> Give is that both priority and timeSpent are optional fileds.
03:33:40 <mreh> no haskell expressions
03:33:48 <mreh> how to express this
03:33:58 <mreh> Haskell types?
03:34:31 <triyo> so I could get "(H 3.2)" or "(H)" or "(3.2)"
03:35:10 <triyo> So I wish to parse the 'H' as a Maybe Char and 3.2 as Maybe Double
03:35:19 <mreh> what's the error exactly? no-parse or something similar?
03:36:46 <Jafet> Well, read can parse anything that is defined in an instance of Read
03:36:52 <Jafet> Not that you should use read
03:37:04 <triyo> mreh: there isn't really an error if everything if both fields are defined. However, if I leave out the 3.2 of course, it will through an excetion and return (Just 'H', Just *exception: no parse found...)
03:37:21 <triyo> Jafet: I
03:37:36 <triyo> I'd like to through away the read part all together
03:38:35 <Jafet> Whatever parser framework that is, it probably has a primitive for Double
03:38:42 <Jafet> Otherwise you can use reads
03:39:02 <triyo> I'm using Parsec
03:39:26 <triyo> I see a float function under Token module I think
03:41:10 <blackdog> (return $ guard True >> return 1) :: Monad m => m (Maybe Int)
03:41:15 <blackdog> @pl (return $ guard True >> return 1) :: Monad m => m (Maybe Int)
03:41:15 <lambdabot> return (guard True >> return 1) :: Monad m => m (Maybe Int)
03:41:29 <blackdog> is there a better way of expression that?
03:41:46 <blackdog> (assuming i have arbitrary types for True and 1)
03:41:50 <blackdog> expressing that, even
03:47:48 <aleator_> Well. Darn it. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26515#a26515 I'm being beaten by python 2.3 times over, with no real ideas anymore.
03:48:13 <SailorReality> lol python 2.3 times over. ..u made a pun
03:48:48 <aleator_> :)
03:49:02 <aleator_> Or rather :[
03:49:13 <ksf> that's a lot of allocs there
03:49:32 <aleator_> that comes from mwc-random
03:49:44 * ksf would assume that mwc-random gets inlined and unboxed
03:50:32 <ksf> maybe just a single strictness annotation to force the random value will fix stuff
03:50:57 <aleator_> Hmm.. Lets try
03:51:16 <Saizan> maybe mwc-random needs to be compiled with -O2
03:51:33 <danharaj> -O9000
03:51:41 <ksf> cabal-install should do that automatically
03:52:10 <aleator_> I did actually put that in .cabal file to be extra sure..
03:53:16 <Saizan> which?
03:54:13 <aleator_> -O2
03:54:45 <Saizan> which .cabal file, mwc-random's?
03:56:10 <aleator_> Yep
03:56:34 <aleator_> Also on my compile command, since I wasn't so familiar with what cabal does
04:02:14 <aleator_> How does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26515#a26517 even allocate anything?
04:12:31 * hackagebot xml-prettify 0.1.0.1 - Pretty print XML.  http://hackage.haskell.org/package/xml-prettify-0.1.0.1 (DavidRosenberg)
04:14:38 <roconnor> aleator_: what monad is it being used with?
04:19:33 * hackagebot statechart 0.0.0 - Compiles Rhapsody statecharts to C.  http://hackage.haskell.org/package/statechart-0.0.0 (TomHawkins)
04:24:42 <Palmik> Hmm, :/ what is wron with this? http://codepad.org/ogLohpxx when I try to use it, it reports this error http://codepad.org/s1c0HvaU
04:25:52 <o-_-o> main = do concat (map print [1,2,3]) -- why is this wrong ?
04:26:00 <ksf> heightTree $ Node "x" Empty Empty
04:26:11 <ksf> heightTree (Node "x" Empty Empty)
04:26:18 <ksf> heightTree . Node "x" Empty $ Empty
04:26:22 <ksf> one of those
04:26:39 <ksf> ...but heightTree only takes one argument, not 4 as you did.
04:26:43 <roconnor> o-_-o: use mapM_ print [1,2,3]
04:26:55 <o-_-o> roconnor, ah...thanks
04:26:58 <roconnor> @type mapM_
04:26:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:27:08 <roconnor> @type mapM
04:27:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:27:24 <roconnor> mapM is also useful in some other simular situations
04:27:40 <roconnor> o-_-o: acutally
04:27:47 <roconnor> more accurately what you want to do is 
04:27:56 <roconnor> sequence (map print [1,2,3])
04:28:02 <roconnor> @type sequence
04:28:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:28:06 <ksf> and obviously, the constructor Node is not of the type Tree a, but has a functional type, which is reflected in the error
04:28:52 <roconnor> o-_-o: sequence takes a list of monad actions and sequences them producing a list of outputs
04:28:56 <Palmik> ksf, ok, thanks
04:28:59 <roconnor> @type sequence_
04:29:00 <ksf> it doesnt' take too long to be able to zen those kinds of errors to the exact error location
04:29:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:29:09 <roconnor> sequence_ does the same thing but throws out the output
04:29:23 <roconnor> then mapM_ is shorthand for sequence composed with map
04:29:28 <roconnor> @type mapM_
04:29:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:29:31 <roconnor> @src mapM_
04:29:31 <lambdabot> mapM_ f as = sequence_ (map f as)
04:29:34 <roconnor> @src mapM
04:29:34 <lambdabot> mapM f as = sequence (map f as)
04:30:04 * roconnor kinda feels like he is talking into the void
04:32:33 <Jafet> @. vixen quote roconnor
04:32:34 <lambdabot> uhuh
04:35:33 <orlandu63> roconnor: thanks, that wasn't directed to me but it was quite helpful
04:35:43 <orlandu63> (to me)
04:44:46 <mokrzu> hi, i'm reading chapter about modules from LYAH and i wonder is it necessarry to know all this functions to learn further haskell? i'm filing stack on this chapter, it's good idea to skip it and back later ? 
04:48:06 <byorgey> mokrzu: you can probably skip it if you want.
04:48:43 <benmachine> it's pretty handy to know the standard library though!
04:48:51 <benmachine> but I guess that can come later
04:50:31 <o-_-o> thanks roconnor
04:51:24 <o-_-o> roconnor, I know it was late response but I read it all the same, I keep getting distracted at work :-(
04:53:44 * hackagebot Agata 0.2.1 - Generator-generator for QuickCheck  http://hackage.haskell.org/package/Agata-0.2.1 (JonasDuregard)
04:55:25 <mokrzu> ok, thanks for advice, it's just little boring to test every functions istead of learning new things like data types etc.
05:00:47 * hackagebot ad 0.45.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.45.0 (EdwardKmett)
05:15:07 <roconnor> o-_-o: :) ok
05:16:46 <ivanm> @ask edwardk hang on, you would prefer to use Data.Graph over FGL? :/ (even better: go forth and roll your annotated library! :p)
05:16:47 <lambdabot> Consider it noted.
05:18:36 <ivanm> wow, simon marlow had to pay out of his own pocket to fix a GHC bug?
05:18:43 * ksf would like fgl to come with better documentation
05:18:57 <ivanm> ksf: we're going to add more docs to the new version
05:19:03 <ivanm> since the paper, etc. are out of date
05:19:10 <orlandu63> @src iso
05:19:11 <lambdabot> Source not found. :(
05:19:15 <orlandu63> @type  iso
05:19:16 <lambdabot> Not in scope: `iso'
05:19:28 <ivanm> orlandu63: what is this "iso" you're looking for?
05:19:30 <ksf> heck it doesn't hurt to draw some ascii art over the definition of preorder traversal, much less so with those cryptic TLAs
05:19:58 <ivanm> orlandu63: this what you want? http://hackage.haskell.org/packages/archive/fclabels/latest/doc/html/src/Data-Record-Label.html#iso
05:20:10 <ksf> preoder? graphs? /me thinks /me is confused
05:20:32 <ivanm> if so, it's a class method, with default implementation of iso (Lens a b) = osi (b <-> a)
05:20:45 <ivanm> ksf: well, when you convert it to a tree of node relationships
05:21:07 <ivanm> no, wait, now _I'm_ not making sense :s
05:21:29 <ksf> even merely spelling out those acronyms would increase fgl's quality drastically.
05:21:53 <ivanm> ksf: right, that's one of the things we're doing
05:22:02 <ivanm> it's going to make code more verbose, but in a good way IMHO
05:22:02 <orlandu63> ivanm: yes, thank you
05:22:24 <ksf> you could also inline nice graphviz examples 
05:22:26 <orlandu63> i should use hoogle more often
05:22:46 <ksf> ...though ascii is more acessible on a sourcecode level.
05:22:53 <ksf> can graphviz render to ascii?
05:22:58 <ivanm> orlandu63: I used hayoo, actually
05:23:02 <ivanm> ksf: ummm... not really
05:23:06 <ivanm> but there are apps that can
05:23:24 <ivanm> perl, for example, has a library that has both ASCII and graphviz backends
05:23:31 <ivanm> in general, an ASCII backend probably wouldn't work
05:23:56 <ivanm> I thought haddock supported images though; I seem to recall xmonad docs having them at one stage... >_>
05:23:59 <ksf> one definitely wouldn't want to do big graphs with it.
05:24:53 <ksf> the same goes for every package, btw. it wouldn't hurt if the definitions of foldl and foldr came with nice images
05:24:56 <wto> !quote
05:24:58 <wto> oops
05:25:06 <Jafet> @quote wto
05:25:07 <lambdabot> No quotes match. Maybe you made a typo?
05:25:19 <Jafet> That's the most polite error message I've ever seen
05:25:23 <wto> Jafet: I meant to write it in another channel actually
05:25:30 <ivanm> ksf: yeah
05:25:47 <ksf> though we could probably use yet more haddock syntax, then, to specify additional stuff that you have to unfold to see
05:26:56 <ivanm> yeah, having more markup than just italics would be nice
05:27:15 <ivanm> IIRC, someone proposed a GSoC to use pandoc markup for haddock; did that go anywhere?
05:27:45 <ksf> and I think we should finally split the prelude 
05:28:23 <ksf> import Prelude (); import Prelude.Function
05:28:29 <ksf> ...and get ($),(.) etc.
05:30:33 <ksf> nesting.
05:30:58 <ksf> you can't e.g. have a bullet list point that includes multiple paragraphs.
05:34:17 <roconnor> ksf: you should be able to split the prelude yourself I think
05:34:28 <ksf> hmmm yes.
05:34:34 <exDM69> is there a way to wait for incoming messages on many Chan's? (Control.Concurrent.Chan that is)
05:34:41 <ksf> I think my refactoring-foo might just be sufficient.
05:34:41 <roconnor> ksf: let us know how it works out ;)
05:34:56 <sdr> I am using haskell-mode on emacs and I am using cabal install as a compile command
05:35:05 <sdr> and I have two question
05:35:07 <benmachine> exDM69: spawn a thread for each one!
05:35:21 <benmachine> exDM69: and have them write to a single MVar or something
05:35:27 <benmachine> or another Chan, indeed
05:35:35 <sdr> 1: can't I set it once for to be my command to compile istead of writing it every time
05:35:43 <exDM69> benmachine: no I need it exactly the other way around
05:35:44 <zenzike> Hi all. I'm playing with criterion and trying to benchmark some functions that calculate primes. The trouble is that the order in which I evaluate the benchmarks seems to make a big difference in terms of how the algorithms rank between themselves.
05:35:53 <zenzike> I've got some code here, any suggestions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26518#a26518
05:36:19 <sdr> 2: isnt there a way to set the base directory to the place where the cabal file is so that I dont have to renavigate to the dorectory each time I want to compile?
05:36:20 <exDM69> benmachine: I could multiplex messages in the channel tho
05:36:27 <zenzike> (that's just a couple algorithms, in my shootout I have quite a few more)
05:36:52 <benmachine> exDM69: you can also use dupChan or something to make broadcast channels if that would help (although again it sounds like the wrong way around for you)
05:37:26 <exDM69> benmachine: yeah, dupChan is one-to-many where as I'm looking for many-to-one
05:37:48 <sdr> anyone uses emacs at all here?
05:39:29 <ivanm> sdr: quite a few people do
05:40:58 <sdr> and what do most people use?
05:41:25 <danharaj> Probably emacs, but there's probably no clear majority.
05:41:32 <Jafet> ed!
05:41:38 <danharaj> I use notepad++
05:42:26 <zygoloid> @karma notepad
05:42:27 <lambdabot> notepad has a karma of 62
05:42:40 <benmachine> @karma c
05:42:40 <lambdabot> c has a karma of 2
05:42:51 <aleator> roconnor: It is used with ST monad.
05:42:52 <benmachine> we need to talk about c-- more than we talk about c++ I think
05:43:04 <zygoloid> it's kinda surprising we talk about c++ more than c--
05:43:19 <nixness> @karma vim
05:43:20 <lambdabot> vim has a karma of 5
05:43:31 <zygoloid> @karma haskell
05:43:31 <nixness> @karma awesomeness
05:43:31 <lambdabot> haskell has a karma of 60
05:43:32 <lambdabot> awesomeness has a karma of 0
05:43:39 <danharaj> @karma neckbeard
05:43:39 <lambdabot> neckbeard has a karma of 0
05:43:39 <zygoloid> notepad > haskell
05:43:47 <zygoloid> @karma lambdabot
05:43:47 <lambdabot> lambdabot has a karma of 0
05:43:48 <nixness> @karma list comprehensions
05:43:49 <lambdabot> list has a karma of 0
05:43:55 <danharaj> @karma @karma
05:43:55 <lambdabot>  @karma has a karma of 0
05:43:57 <nixness> @karma lambda
05:43:58 <lambdabot> lambda has a karma of 0
05:44:04 <nixness> @karma karma
05:44:04 <lambdabot> karma has a karma of 1
05:44:16 <zygoloid> @karma xs
05:44:16 <danharaj> @karma karma karma karma chameleon
05:44:17 <lambdabot> xs has a karma of 0
05:44:17 <lambdabot> karma has a karma of 1
05:44:20 <nixness> @karma zygoloid
05:44:21 <lambdabot> zygoloid has a karma of 5
05:44:36 <zygoloid> \o/
05:44:51 * nixness spreads his awesomeness on this chan like butter on bread!
05:45:08 <nixness> what's up people :) new haskell learner stranded in magrathia
05:45:12 <ivanm> what awesomeness?
05:45:27 <nixness> @whatis awesomeness
05:45:28 <lambdabot> I know nothing about awesomeness.
05:45:29 * ronwalf is tempted to start a "Simon Marlow EC2 Reimbursement Drive"
05:45:31 <nixness> hmm :p
05:45:43 <ivanm> and I assume you mean "magrathea"...
05:45:51 <ksf> roconnor, what about   Data.hs  IO.hs  List.hs  Monad.hs  Numeric.hs  Serialise.hs
05:46:04 <ivanm> ronwalf: heh, yeah
05:46:05 <nixness> ivanm: yup, that assumption is sound
05:46:11 <ksf> IO, List, Monad (incl. fmap) and Serialise (Read/Show) are quite obvious
05:46:20 <sdr> @karma emacs
05:46:21 <lambdabot> emacs has a karma of 6
05:46:27 <nixness> @karma vim
05:46:28 <lambdabot> vim has a karma of 5
05:46:31 <nixness> damn!!!!
05:46:37 <nixness> I looooove vim so much!
05:46:37 <ksf> there's a bit of fuzziness between Data and Numeric, though
05:46:40 <nixness> @karma vim
05:46:41 <lambdabot> vim has a karma of 5
05:46:43 <nixness> haha
05:46:45 <Jafet> Why don't you guys go watch some football
05:46:49 <nixness> :p my love isn't enough!
05:47:21 <danharaj> Jafet: you mean listen to bees?
05:47:35 <ksf> oh, I missed the misc ones.
05:47:41 <ivanm> Jafet: do you mean soccer football?
05:47:45 <ivanm> or rugby football?
05:47:49 <ivanm> or gridiron football?
05:47:50 <ivanm> :p
05:48:04 <Jafet> I personally like phutball
05:48:17 <ivanm> is that the vietnamese variant?
05:48:27 <nixness> http://www.liveleak.com/view?i=ca0_1276336723
05:48:31 <zenzike> Jafet: people are still playing football?
05:49:31 <nixness> zenzike: if you use vim, can you tell us how much you like it?
05:49:47 <benmachine> I like vim
05:49:52 <nixness> @karma vim
05:49:53 <lambdabot> vim has a karma of 5
05:49:56 <Jafet> zenzike, that depends on what you mean by "still", I suppose.
05:49:58 <zenzike> nixness: erm, it's nice
05:50:04 <nixness> zenzike: what's nice, now?
05:50:15 <zygoloid> \vim -> vim++ [1,2,3]
05:50:17 <zygoloid> @karma vim
05:50:18 <lambdabot> vim has a karma of 6
05:50:18 <nixness> @karma vim
05:50:19 <lambdabot> vim has a karma of 6
05:50:22 <nixness> yay!
05:50:25 <benmachine> nixness: http://www.viemu.com/a-why-vi-vim.html this made a lot of sense to me
05:50:28 <zenzike> nixness: it's a step up from gedit ;)
05:50:44 <nixness> I love it, I wanted its karma to beat emacs, that's all :D
05:50:54 <zenzike> oh, i see
05:50:56 <nixness> we're tied now
05:50:58 <zenzike> vim vim vim
05:51:01 <ksf> hmm it isn't possible to say import Prelude hiding (module Prelude.IO), is it?
05:51:17 * ksf thinks it should be when there's an explicit module export.
05:51:20 <nixness> me and vim are like vim and vim with this chocolaty vim on top
05:51:25 <nixness> #karma vim
05:51:29 <nixness> @karma vim
05:51:30 <lambdabot> vim has a karma of 6
05:51:34 <ksf> vim++
05:51:37 <nixness> soon it will happen!
05:51:39 <ksf> vimscript--
05:51:46 <zenzike> sometimes, vim, I, vim, use vim
05:51:54 <zenzike> how does karma work anyway?
05:52:08 <ksf> you write "ksf" followed by "++"
05:52:16 <zenzike> is it just the number of people who trigger the word?
05:52:18 <ivanm> zenzike: anytime lambdabot sees you put two plus signs after something, that something gets an extra karma point
05:52:25 <ksf> yes
05:52:29 <ivanm> if theres two minus signs, that something loses a karma point
05:52:31 <ksf> c++ is an exception
05:52:38 <nixness> I think people have to talk to each other about vim, ivanm and zenzike, so that it would get more karma
05:52:39 <ivanm> or else you use @karma+ foo and @karma- foo
05:52:49 <nixness> ksf: isn't vim nice?
05:52:49 <zenzike> nixness: vim++
05:52:54 <Jafet> nixness: you find such great personal fulfillment in causing the arbitrary score of the name of a program marketed as a text editor as tracked by a dumb IRC bot that was intended to track the virtual reputation of user names to be higher than the score of the name of a program marketed as a competing text editor?
05:52:59 <zenzike> @karma vim
05:53:00 <lambdabot> vim has a karma of 8
05:53:02 <ivanm> stop karma whoring you lot!
05:53:03 <zenzike> wooo
05:53:25 <benmachine> Jafet: fsvo marketed
05:53:33 <bremner> #haskell-blah lives for these important discussions.
05:53:36 <nixness> Jafet: would it have hurt to have written "vim" in your message to me?
05:53:37 <ksf> @karma emacs
05:53:37 <lambdabot> emacs has a karma of 6
05:53:38 <nixness> :D
05:53:42 <nixness> @karma vi
05:53:42 <lambdabot> vi has a karma of 0
05:53:43 <nixness> @karma vim
05:53:44 <lambdabot> vim has a karma of 8
05:53:49 <danharaj> enough of that
05:53:51 <nixness> nice, now I can rest
05:53:55 <theorbtwo> emacs++
05:54:04 <nixness> theorbtwo: you meant vim, surely
05:54:12 <Jafet> We can play football in this channel. Penalty kick.
05:54:17 <Jafet> Who's first?
05:54:26 * nixness waves
05:54:27 <nixness> me me!
05:54:46 <ivanm> Jafet: what's on second?
05:54:47 <ivanm> :p
05:54:56 <theorbtwo> >cycle "emacs++ "
05:55:23 <theorbtwo> > cycle "emacs++ "
05:55:25 <lambdabot>   "emacs++ emacs++ emacs++ emacs++ emacs++ emacs++ emacs++ emacs++ emacs++ em...
05:55:35 <theorbtwo> @karma emacs
05:55:36 <lambdabot> emacs has a karma of 7
05:55:56 <ivanm> theorbtwo: lambdabot doesn't read her own output
05:56:02 <nixness> @karma nixness
05:56:02 <theorbtwo> ivanm: Apparently not.
05:56:03 <lambdabot> You have a karma of 0
05:56:06 <zygoloid> preflex: karma emacs
05:56:06 <preflex>  emacs: 22
05:56:12 <zygoloid> > cycle "vim++ "
05:56:13 <lambdabot>   "vim++ vim++ vim++ vim++ vim++ vim++ vim++ vim++ vim++ vim++ vim++ vim++ vi...
05:56:15 <zygoloid> preflex: karma vim
05:56:15 <preflex>  vim: 90
05:56:17 <danharaj> you guys don't know when to let it go do you.
05:56:24 <ivanm> danharaj: obviously not
05:56:34 <nixness> danharaj: yeah, I got bored myself (vim vim vim)
05:56:56 <ivanm> nixness: just saying "vim" doesn't do anything
05:57:02 <ksf> w
05:57:06 <ksf> O:q
05:57:12 <ksf> oops
05:57:16 <ivanm> heh
05:57:22 <zygoloid> ksf: i guess the reason you can't write "import Prelude hiding (module Prelude.IO) is that how modules are implemented in terms of other modules is an implementation detail, which shouldn't be exposed...
05:57:59 <benmachine> zygoloid: the export list of module Prelude.IO is exposed
05:58:03 <benmachine> just hide everything in that
05:58:17 <ksf> well the other possibility would be to look at the export list of Prelude.IO and filter everything.
05:58:23 * ksf thinks it's a great idea
05:58:23 <benmachine> it's basically a set operation
05:59:06 <zygoloid> benmachine: what if Prelude were implemented by writing: "putStrLn = Prelude.IO.putStrLn" etc. Should those get hidden?
05:59:13 <benmachine> zygoloid: sure why not
05:59:20 <ksf> it's those small things that make a language really kind.
05:59:59 <zygoloid> benmachine: so i could write: import Prelude hiding (module Data.Traversable) and hide foldr etc?
06:00:01 <ksf> I think everything that matches in name and type sig should be hidden.
06:00:02 <danharaj> I think Haskell could benefit from C++'s namespacing
06:00:05 <zygoloid> actually... i really like that!
06:00:17 <zygoloid> ksf: remove the type sig restriction and count me in :)
06:00:32 <Jafet> danharaj, that's because you don't understand C++'s namespacing
06:00:44 <ksf> zygoloid, I actually planed to make a Prelude.List, so you can go import Prelude hiding (module Prelude.List)
06:00:47 <danharaj> Jafet: This is the part where you explain C++'s namespaces
06:01:04 <zygoloid> danharaj: they don't work, due to Koenig lookup.
06:01:11 <Jafet> They come with a lookup algorithm that is so novel it is named after a person on the C++ committee
06:01:24 <danharaj> I was talking about the namespace and using keywords :|
06:01:35 <ksf> zygoloid, I think what you want would be import Data.Traversable overriding (module Prelude)
06:01:46 <Jafet> You could add them to Haskell. Then we would busy ourselves writing Haskell namespace tutorials.
06:02:19 <danharaj> At most they'd be a paragraph in a modules tutorial
06:02:32 <danharaj> it's essentially the same thing as importing exporting qualified and hiding.
06:02:41 <danharaj> Except within a file.
06:02:51 <benmachine> import Prelude ∖ Prelude.IO
06:02:59 <benmachine> ugh it took me forever to find that symbol
06:03:13 <zygoloid> benmachine: i think it's the semantics not the syntax which is the issue
06:03:16 <Jafet> It's... a backslash?
06:03:27 <zygoloid> it's a special Maths Backslash
06:03:27 <benmachine> Jafet: it isn't
06:03:28 <ksf> import qualified Data.Map as Map exposing (Map)
06:03:28 <danharaj> it's the set complement slash :p
06:03:29 <benmachine> yes
06:03:38 <Jafet> Showoff
06:03:38 <danharaj> er
06:03:39 <benmachine> cf. ∖ \
06:03:39 <danharaj> minus*
06:03:45 <benmachine> set difference
06:03:49 <ksf> ...which could be a shorthand for import qualified Data.Map as Map; import Data.Map (Map)
06:03:50 <benmachine> or subtract
06:03:52 <benmachine> or whatever
06:03:54 <danharaj> same difference
06:03:56 * danharaj rimshot
06:04:05 <benmachine> :P
06:04:23 * zygoloid exposes ignorance, what does "rimshot" mean in this context?
06:04:25 <Jafet> Can template haskell write import commands?
06:04:40 <ksf> it should
06:04:51 <Jafet> The semantics would be interesting.
06:05:29 <danharaj> Does Template Haskell have a standard definition, or is it mostly just a GHC thang?
06:05:32 <zygoloid> Jafet: as what type of splice? they're not declarations
06:05:49 <ksf> it's an addendum to H98
06:05:50 <ivanm> @wn rimshot
06:05:51 <lambdabot> No match for "rimshot".
06:05:57 <ksf> which prolly means that it's proper H2010
06:06:00 <Jafet> It has a standard definition that satisfies no one
06:06:08 <ivanm> zygoloid: 
06:06:08 <ivanm> > Then to rub salt into the wound, once you've gone to great lengths of
06:06:08 <ivanm> > licencing and including your special unique snowflake webfont, you
06:06:08 <ivanm> > publish through the Apple iBookstore and then the typographically
06:06:08 <ivanm> > ignorant lout of a user goes and sets the whole thing to "Verdana".
06:06:08 <ivanm> >
06:06:09 <lambdabot>   <no location info>: parse error on input `,'
06:06:10 <lambdabot>   <no location info>: parse error on input `of'
06:06:10 <lambdabot>   <no location info>: parse error on input `,'
06:06:10 <lambdabot>   <no location info>: parse error on input `then'
06:06:10 <ivanm> > So people complaining about fonts not being supported "my way" are
06:06:11 <lambdabot>   Not in scope: data constructor `So'Not in scope: `people'Not in scope: `com...
06:06:12 <ivanm> > basically stating that they the author are more important than the
06:06:13 <lambdabot>   Not in scope: `basically'Not in scope: `stating'Not in scope: `that'Not in ...
06:06:14 <ivanm> > readers. Which is, of course, a load of bollocks. If you're so
06:06:16 <lambdabot>   <no location info>: parse error on input `,'
06:06:16 <ivanm> > important that your work must never be compromised by being displayed
06:06:17 <lambdabot>   Not in scope: `important'Not in scope: `that'Not in scope: `your'Not in sco...
06:06:18 <ivanm> > in Comic Sans, don't publish it.
06:06:19 <lambdabot>   <no location info>: parse error on input `in'
06:06:20 <ivanm> >
06:06:22 <danharaj> someone squelch him
06:06:22 <ivanm> > For what it's worth, I haven't been able to replicate the problem that
06:06:24 <lambdabot>   <no location info>: parse error on input `,'
06:06:24 <ksf> @ops
06:06:24 <ivanm> > the author on Ars Technica has encountered. Which means one of us is
06:06:24 <lambdabot> Maybe you meant: docs oeis pl
06:06:25 <lambdabot>   <no location info>: parse error on input `of'
06:06:26 <ivanm> > doing it wrong.
06:06:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:06:28 <ivanm> >
06:06:30 <ivanm> > Alex
06:06:31 <lambdabot>   Not in scope: data constructor `Alex'
06:06:32 <ivanm> >
06:06:37 <ivanm> > PS: I'm not really on a crusade against Comic Sans. It's just that the
06:06:38 <lambdabot>   Not in scope: data constructor `PS'Not in scope: data constructor `I'm'Not ...
06:06:38 <ivanm> > poor little font has become cliché, in the same genre of "fonts that
06:06:39 <lambdabot>   <no location info>: parse error on input `,'
06:06:40 <ivanm> > are so overused that they're tired" as Papyrus and other fonts that
06:06:42 <lambdabot>   <no location info>:
06:06:42 <lambdabot>      lexical error in string/character literal at end o...
06:06:42 <ivanm> > are distributed with Windows or Mac OS X. They're there for free, so
06:06:43 <lambdabot>   <no location info>: parse error on input `,'
06:06:44 <ivanm> > people use them. Everyone thinks they'll be unique and use Papyrus on
06:06:45 <lambdabot>   Not in scope: `people'Not in scope: `use'Not in scope: `them'Not in scope: ...
06:06:46 <ivanm> > their wedding invitations, just like everyone else. It's getting to
06:06:47 <lambdabot>   <no location info>: parse error on input `,'
06:06:48 <ivanm> > the point that to be truly unique, you'll use Times New Roman or
06:06:49 <lambdabot>   <no location info>: parse error on input `,'
06:06:50 <ivanm> > Helvetica. Because Helvetica, is the new Helvetica.
06:06:51 <lambdabot>   <no location info>: parse error on input `,'
06:06:52 <ivanm> whoops, sorry
06:06:54 <ivanm> the copy/paste obviously failed :s
06:06:55 <Jafet> This is why I stopped watching TV
06:06:56 <ivanm> zygoloid: http://instantrimshot.com/
06:06:58 <ksf> someone kick him, for justice's sake.
06:07:02 <ivanm> my most humble apologies to you
06:07:07 <danharaj> ivanm--
06:07:08 <danharaj> ;)
06:07:19 <ivanm> IT WAS A MISTAKE!
06:07:23 <ivanm> zygoloid: http://instantrimshot.com/
06:07:26 <danharaj> THE ONLY WAY TO TEACH A PUPPY
06:07:28 <danharaj> IS TO KICK IT
06:07:35 <ivanm> ^^ that's what I meant to paste
06:07:39 <benmachine> heheheh
06:07:42 <ivanm> but I obviously didn't copy it like I thought I had
06:08:17 <zygoloid> ivanm: you should switch to an IRC client with accidental paste prevention :)
06:08:26 <ivanm> but I like xchat!
06:08:43 <ksf> JUST BLEEDING DON"T HIT ENTER
06:08:52 <ksf> DOUBLE_APOSTROPHE!!!
06:09:04 <benmachine> ksf: sometimes the text contains newlines?
06:09:10 <Jafet> ksf, next time swap capslock, don't remove it
06:09:16 <ivanm> what's the point of DOUBLE_APOSTROPHE ?
06:09:17 <danharaj> ksf understands the need for utmost control, so he holds down shift when he caps locks :p
06:09:24 <ksf> benmachine, xchat's input field is multi-line
06:09:37 <ksf> first line ctrl-enter
06:09:38 <ksf> second line
06:09:52 <danharaj> hmm
06:09:57 <ivanm> in this case, the input text contained a whole bunch of newline chars
06:10:19 <danharaj> ivanm: you should feel guilty for confusing lambdabot.
06:10:20 <ivanm> ctrl-enter doesn't seem to do anything here
06:10:24 <ivanm> danharaj: I do
06:10:32 <danharaj> ivanm++
06:10:53 <ivanm> though this is also partially payback for her going offline the other day :p
06:11:01 <ksf> I can absolutely and positively say that xchat doesn't send _anything_ if it doesn't get a keyboard-enter.
06:11:15 <danharaj> ksf: Did you coq verify this.
06:11:21 <ivanm> ksf: yeah, I know
06:11:44 <ivanm> I just did a C-v + enter, thinking I had copied that url from firefox
06:11:47 <ksf> basically, there's not enough asbestos in the universe to protect chat client authors who don't implement such things to prevent accidents.
06:11:48 <zygoloid> > fix((0:).(1:).(zipWith(+)<*>tail))
06:11:48 <ivanm> obviously it hadn't copied
06:11:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:12:04 <ivanm> ksf: "such things" ?
06:12:16 * ksf always uses the mouse for copy+paste
06:12:33 <ksf> even for the c-v buffer.
06:12:53 <ksf> ...it's just a right drag away.
06:13:07 <ivanm> except I prefer to keyboard rather than use my mouse
06:13:16 <Jafet> This obviously calls for a coq-verified IRC client input buffer
06:13:16 <benmachine> I never got the hang of mouse copypaste
06:13:33 <ksf> I do use keyboard pasting inside a single vi instance
06:13:34 <benmachine> Jafet: would it verify everything you said as objectively true
06:14:40 <ksf> what xchat could do but doesn't is make the input field say three-lined as soon as it contains multiline stuff.
06:15:12 <ksf> ...you can't even drag to resize it.
06:18:06 <ivanm> waern: how does one include images into haddock docs?
06:20:05 * edwardk waves hello.
06:20:06 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:20:08 <wli> Hold the right button and drag to copy, click the middle button to paste.
06:20:10 <ivanm> hey edwardk 
06:20:13 * benmachine waves back
06:20:23 <ivanm> wli: you mean left button?
06:20:53 <benmachine> the thing that always annoyed me about select-copy: something I often do is select existing text before pasting, so that it is replaced
06:21:01 <benmachine> how do I easily paste-replace with mousecopy?
06:21:13 <wli> Sorry, hold the left button and drag to copy, click the middle button to paste.
06:21:13 <edwardk> ivanm: heh, re: Data.Graph it simply made my dependency profile slimmer ;)
06:21:22 <ivanm> heh, fair enough
06:21:31 <edwardk> i already needed containers for IntMap, etc.
06:21:51 <edwardk> and its topSort function does exactly what i need in 2 lines of code
06:21:59 <edwardk> modulo the quadratic inefficiency concerns
06:25:31 <keep_learing> could some one plase tell me  wha t is wrong with this code http://pastebin.com/bRWSyJZB
06:25:37 <keep_learing> i am getting ocmpiler error
06:25:50 <ivanm> what's the error?
06:26:05 <ivanm> keep_learing: note that you don't say what to do for empty lists
06:26:13 <ivanm> oh, wait, yes you do, but it's wrong
06:26:13 <keep_learing>  Occurs check: cannot construct the infinite type: a = Maybe a     When generalising the type(s) for `secondfromlast' 
06:26:21 <benmachine> keep_learing: in your second guard, you try to return p
06:26:24 <ivanm> keep_learing: "(p:ps)" means that its a list with at least one value
06:26:26 <benmachine> but p isn't of the type Maybe a
06:26:33 <ivanm> right, it should be "Just p"
06:27:12 <keep_learing> ivanm thank you
06:27:16 <keep_learing> it worked 
06:27:45 <benmachine> keep_learing: also, using pattern matching is better than repeatedly recalculating the length
06:27:56 <ivanm> keep_learing: better version: http://pastebin.com/K13d9caX
06:28:01 <ivanm> pattern matching > guards
06:28:15 <ivanm> benmachine: I just marked the first half of 110 exams at the beginning of this week
06:28:32 <ivanm> at least half (prob. more like 3/4) tried to do some kind of pattern matching in guards :s
06:28:46 <benmachine> fun!
06:29:00 <ivanm> e.g. an either example: "foo const val | const == Right = ... "
06:29:16 <wli> No PatternGuards?
06:29:18 <benmachine> heh
06:29:26 <ivanm> benmachine: I blame the lecturer using PatternGuards in the bits of the assignment code they were given but not meant to look at
06:29:40 <ivanm> wli: I think them seeing PatternGuards was the problem
06:29:50 <ivanm> they're first year CS + Eng + commerce students
06:30:26 <wli> Did they not notice it didn't compile?
06:30:40 <ivanm> wli: _exam_
06:30:45 <ivanm> as in, written on paper
06:30:50 <ivanm> as in, didn't have a compiler to test it on
06:31:25 <benmachine> yeah, because the ability to write code without the presence of a computer is totally an important skill >_>
06:31:51 <danharaj> mathematicians do it all the time <_< >_>
06:31:56 <ivanm> benmachine: unfortunately, it's the only way to test how good an individual is
06:32:06 <ivanm> it was open book, and they could bring in anything they liked short of a computer
06:32:41 <benmachine> ivanm: i.e. everything except what they would actually want? >_>
06:32:44 <ivanm> benmachine: note also that it wasn't a Haskell course per-se; the idea was to teach them the basic concepts behind programming (recursion, etc.)
06:32:50 <ivanm> benmachine: heh, yeah
06:32:59 <benmachine> *give* them a computer with a compiler and nothing else, imo
06:33:00 <ivanm> benmachine: because with computers they can communicate with one another
06:33:07 <benmachine> and no plugs in
06:33:13 <benmachine> or something
06:33:14 <keep_learing> kindly tell me why pattern matching is better than using guards ? 
06:33:21 <ivanm> and this way it sees how much of their coding effort was brute forcing through errors rather than knowing what the syntax means
06:33:40 <benmachine> keep_learing: well, using length in a guard, the length function is only going to pattern match anyway
06:33:44 <ivanm> keep_learing: in this kind of stuff its clearer what you're doing
06:33:49 <ivanm> especially since length can be expensive
06:33:58 <ivanm> especially if you keep doing it over and over again like you do
06:34:12 <ivanm> guards are good for cases where you'd use nested if/else in other languages
06:34:21 <benmachine> ivanm: I suppose so, but I just think when one of the things people like most about haskell is type errors being caught for you
06:34:36 <ivanm> benmachine: arguably that's an implementation issue ;-)
06:34:39 <keep_learing> yes thats why i use guards   like        if n else
06:34:41 <benmachine> having them not caught for you is removing a major language feature that you will *always* have in the real world
06:34:59 <ivanm> benmachine: and that kind of stuff is more for when you make a logic error or something, not try to do something stupid like "const == Right" :p
06:35:01 <wli> Well, use (Int, [t]) then to keep the length handy.
06:35:17 <benmachine> ivanm: mm, ok I guess
06:35:23 <ivanm> actually, if you want to calculate the length, you could then just do a drop
06:35:30 <benmachine> I suppose if you mark sensibly you can get a good idea of if people have the right idea
06:35:48 <ivanm> wli: but calculating the length will require at least 2 traversals; doing the recursion explicitly will require 1
06:35:57 <ivanm> benmachine: right, and we were told to mark easy
06:36:05 <ivanm> so most marks were lost for absolutely stupid stuff
06:36:15 <benmachine> mm
06:36:40 <kosmikus> keep_learing: compare "f (x : xs) = someFun x xs" and "f xs | not (null xs) = someFun (head xs) (tail xs)". The former is better because it does not make use of partial, i.e., potentially failing, functions like head and tail. it reduces the risk of making mistakes.
06:36:40 <lambdabot> kosmikus: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:36:51 <wli> Hmm, if it can be done singlepass then storing the length is useless.
06:37:05 <ivanm> benmachine: another example: they were given functions with stupid names and told to explain what it does (as in the point of the function, not a line-by-line description) and give a better name (the names used were rick, astley and rolling)
06:37:47 <ivanm> benmachine: the `rolling' function was basically "rolling p = dropWhile (not . p)"; it was amazing the number of students who saw the guards in there and answered that it was either dropWhile or filter
06:37:50 <wli> Heh, rickrolling.
06:38:01 <danharaj> Pattern matching is used to match on the structure of a value, whereas guards are used to match on logical criteria not captured by the type's structure.
06:38:30 <ivanm> wli: his "solutions to last years exam" on the course website was a link to the youtube video :p
06:38:33 <ivanm> danharaj: yup
06:38:35 <wli> And PatternGuards?
06:38:53 <benmachine> ivanm: mm, I've often thought studying mistakes people make must be quite illuminating sometimes
06:39:09 <ivanm> wli: the lecturer used patternguards in the pre-done bits of the assignment to save him writing an extra function to do the pattern matching in
06:39:13 <benmachine> ivanm: is marking interesting in general? or is it mostly oh no not this again
06:39:20 <ivanm> which Axman6 (another tutor) and I thought was a mistake
06:39:27 <ivanm> benmachine: marking is a right royal PITA
06:39:28 <danharaj> wli: I always forget what pattern guards are even though I use them. :p
06:39:33 <ivanm> it's the biggest down side to tutoring
06:39:38 <benmachine> noted
06:39:52 <ivanm> if they make an _interesting_ mistake, it's interesting
06:39:55 <wli> I've found grading to be just a lot of work and not a whole lot of reward.
06:39:59 <ivanm> but most of them make the same ones over and over again
06:40:15 <danharaj> I have helped my grad friends grade.
06:40:25 <danharaj> I don't know how I got suckered into it.
06:40:28 <ivanm> it doesn't help that the exams are similar year to year, so some students memorised the answers and churned out the one they'd memorised for a similar answer from a previous year
06:40:34 <ivanm> danharaj: did they pay you?
06:40:44 <ivanm> wli: well, the pay is good... (at least here)
06:41:00 <danharaj> ivanm: It may have been worth some sort of unspoken cred, like being able to grab one of their teabags if I wanted a drink :p
06:41:31 <ivanm> $35/hr, and the three of us who did exam marking claimed 13 hours each (which equated to just over 7 min/exam, which is actually a tad under IMO but the lecturer couldn't give us any more)
06:41:47 <ivanm> danharaj: hmmm.... nah, a teabag isn't worth it
06:41:48 <ivanm> ;-)
06:42:13 <danharaj> ivanm: For shame. I am drinking some jasmine black tea right now.
06:42:18 <danharaj> anyway
06:42:21 * tibbe is really liking the increased interest in containers and performance on haskell-cafe
06:42:27 <gwern> @remember SimonMarlow This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26. 
06:42:28 <lambdabot> It is stored.
06:42:29 <edwardk> preflex: xseen malc_
06:42:29 <preflex>  malc_ was last seen on freenode/#haskell 7 hours, 15 minutes and 26 seconds ago, saying: Twey: thanks
06:42:32 <danharaj> I would say patternguards are matching on the structure of values that are not the arguments to the function.
06:42:41 <gwern> @flish
06:42:43 <danharaj> They let you pattern match on auxillary values.
06:42:56 <ivanm> danharaj: right
06:43:01 <gwern>           64029 MB total memory in use (1000 MB lost due to fragmentation)
06:43:06 <danharaj> of course, the ghc manual does not say that.
06:43:07 <gwern> well, what's a gig between friends?
06:43:10 <danharaj> Instead they give an example.
06:43:28 <edwardk> gwern: hahahahaha
06:43:42 <ivanm> danharaj: it saves you writing auxiliary functions
06:43:59 <ivanm> so it's more of a "helper/saves some time+effort" extension that "something new and cool" like MPTCs, etc.
06:44:45 <danharaj> ivanm: I think it is crucial to the beauty of Haskell. Pattern matching treats function arguments as special, pattern guards extend pattern matching to other values you might be using, increasing the uniformity of the language.
06:44:56 * ivanm -> land of nod
06:45:00 <ivanm> danharaj: yeah
06:45:03 <ivanm> anyway, g'night all
06:45:06 <danharaj> nite
06:47:16 <danharaj> I haven't used view patterns.
06:47:44 <danharaj> Are they basically pattern matching on type isomorphisms?
06:48:01 <danharaj> (or I guess more generally homomorphisms)
06:48:17 <Axman6> foo x | Just y <- x = blah | otherwise = caseForNothing
06:48:17 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
06:48:18 <edwardk> danharaj: view patterns are just 'functions in patterns'
06:48:36 <edwardk> danharaj: foo (fst -> a) = ... instead of foo ~(a,_) = ...
06:48:37 <Axman6> oh right, those are pattern guards
06:48:54 <edwardk> danharaj: it can avoid having to name temporaries
06:49:06 <tibbe> edwardk: Good point about the language extensions required for an adaptable container library
06:49:08 <danharaj> edwardk: What about 'views'? What are those? Because I haven't found a nice terse definition.
06:49:20 <Axman6> edwardk: does this work? foo (lookup x -> Just y) = ...?
06:49:41 <tibbe> edwardk: I think key strict is right then
06:49:51 <edwardk> danharaj: they were originally defined by wadler, the current viewpattern syntax is a quick hack that gets you part of the way there. Wadler's views 'felt' like real constructors
06:50:00 <edwardk> Axman6: yep!
06:50:04 <Axman6> nice
06:50:30 * Axman6 dislikes the idea og doing computation on the left of a = apart from pattern matching
06:50:43 <edwardk> tibbe: *nods*
06:51:00 <Jafet> Axman6 embraces the ~
06:51:06 <benmachine> > let repeat x (repeat x -> y) = x : y in repeat 'c' repeat
06:51:06 <edwardk> Axman6: well, they can be quite useful to avoid artificial continuation passing style/case transformations
06:51:07 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
06:51:17 <Axman6> hmm?
06:51:42 <edwardk> Axman6: and the ability to avoid having to name all your temporaries and to backtrack and try other alternatives because you haven't yet crossed the = all add up to a fairly powerful tool
06:52:08 <danharaj> edwardk: Ok, I am looking at Wadler's paper again, and I think it's like this: A view is a type isomorphism used so that you can talk about one type as if it were another.
06:52:35 <edwardk> danharaj: yeah, whereas view patterns are a convenient hack that get you most of the benefits modulo the sugar
06:52:55 <zygoloid> gwern: which bug is that?
06:53:14 <danharaj> Man, views are a fantastic idea!
06:53:31 <edwardk> danharaj: f# and scala have very nice view support because they need it, to provide pattern matching on traditional OOP objects.
06:53:55 <edwardk> danharaj: i used to think so, but they violate a few intuitions
06:54:03 <danharaj> edwardk: Such as?
06:54:11 <edwardk> danharaj: foo (Bar a b c) = Bar a b c -- is no longer safe
06:54:20 <edwardk> danharaj: because it can lose information on the way
06:54:43 <edwardk> danharaj: the view doesn't necessarily capture all of the information about the object/thunk/what have you in question.
06:55:00 <zygoloid> edwardk: then it's not a type isomorphism?
06:55:39 <danharaj> edwardk: What if, let's say we were in an environment where we can do proofs, we demanded a proof that our view is an isomorphism?
06:55:59 <edwardk> zygoloid: sadly there is no way to prove it is an isomorphism in a haskell like language.
06:56:28 <edwardk> and even the toy examples, like polar coordinates for complex numbers aren't truly isomorphic due to information lossed in floating points
06:57:31 <edwardk> now, there are variations on view sugar provided by other platforms. i.e. f# provides partial view patterns, which basically work by returning a 'Maybe', and so you can match on them without ruling out the application of other patterns
06:57:45 <danharaj> That's not an example I find particularly compelling. I'm thinking of views as a way to separate the representation of a datatype and the structure exposed to the user. Like natural numbers.
06:58:36 <edwardk> danharaj: *nods*
07:00:38 <edwardk> danharaj: http://research.microsoft.com/pubs/79947/p29-syme.pdf describes views as implemented in f#
07:01:09 <danharaj> I should learn C/F# sometime.
07:01:34 <edwardk> let (|Polar|) (x : complex) = (x.magnitude, x.phase)
07:01:34 <danharaj> I wonder how much cross-pollination the GHC people and the F# people have as part of microsoft research.
07:02:09 * arcatan immediately thinks C/F# as a quotient group.. what would that mean?
07:02:10 <edwardk> then you can define partial views with (|Foo|_|) or views that return multiple constructors (|Foo|Bar|Baz|)
07:02:36 <edwardk> danharaj: very little
07:02:56 <edwardk> danharaj: f# is however much ocaml don syme can cram into the CLR ;)
07:03:03 <danharaj> hahaha
07:03:26 <danharaj> I bet spj and don syme have offices at opposite ends of a hallway
07:06:12 <danharaj> hmm
07:07:08 <danharaj> I wonder if views could allow constructors like List to specialize for certain types without breaking parametricity? Like specializing String to a more efficient implementation.
07:08:01 <ksf> I think the question is whether there are any f# developers who use f# for another reason that working with .NET in the first run.
07:08:57 <ksf> ...much like closure, and to a great extend also scala
07:09:10 <ksf> *clojure
07:10:10 <BMeph> I thing it's amusing to compare the two men's Wikipedia entries. Don Syme's looks like a stub, but isn't so labelled.
07:12:24 <danharaj> I think someone should write a wiki page for Simon Marlow
07:14:17 <yrlnry> You would be able to do it yourself, if only Wikipedia weren't locked down so tightly.
07:14:50 <danharaj> Wikipedia has a weird system of fascism
07:14:56 <danharaj> I do not wish to dirty my hands.
07:16:08 <byorgey> danharaj: spj and don syme's offices are just down the hall from one another.
07:16:19 <yrlnry> Hi, Brent.
07:16:22 <yrlnry> How's England?
07:16:26 <byorgey> hi yrlnry 
07:16:34 <gwern> yrlnry: only need to register to make articles
07:16:35 <yrlnry> ← Dominus
07:16:38 <byorgey> it's great!  I'm having a lot of fun here so far
07:16:42 <yrlnry> gwern: that was sarcasm
07:16:45 <byorgey> yrlnry: yes, I remember =)
07:17:01 <danharaj> hmm
07:17:04 <gwern> that was sarcasm? nyorun... :(
07:17:22 <yrlnry> I don't remember anything about your most recent blog post, except that it sounded like your work was really interesting.
07:17:57 <danharaj> so does the LLVM backend for ghc replace C-- or does it go Haskell -> Core -> STG -> C-- -> LLVM (or whatever the pipeline is)
07:18:00 <byorgey> so far it's been a lot of hacking on GHC, implementing a smarter constraint-solver
07:18:10 <yrlnry> Oh, that's right.
07:18:18 <byorgey> I'm working on another blog post about my other project while I'm here, which is even more interesting =)
07:18:21 <danharaj> byorgey: godspeed. Fight the good fight :p
07:18:48 <byorgey> danharaj: hehe, thanks
07:19:02 <danharaj> I am actually impressed by GHC in many ways.
07:19:15 <danharaj> Not only its capabilities, but its code, and the community surrounding it.
07:19:23 <byorgey> hacking on GHC isn't as hard as you might think, provided of course that SPJ is sitting next to you so you can ask him lots of questions ;)
07:19:40 <Blkt> good day everyone
07:19:47 <byorgey> yrlnry: how's philly?
07:20:05 <danharaj> byorgey: more importantly, asking questions of you. e.g. "What the hell is that?" and "?????"
07:20:09 <danharaj> ;D
07:20:28 <byorgey> oh, yes, there was some of that too, although he's a lot more polite about it than that =)
07:20:34 <yrlnry> byorgey: Hot and humid.
07:20:49 <byorgey> sounds about right.
07:21:09 <yrlnry> Did your wife come with you or did she stay here?
07:21:20 <byorgey> I'm definitely enjoying the English summer.  everone here is complaining about how hot it is this week, it's been a blistering 75F or so
07:21:53 <byorgey> yrlnry: thankfully she came along
07:21:53 <zygoloid> byorgey: this'll be the one nice week this year, you realise :)
07:22:02 <gwern> byorgey: oh how terrible
07:22:10 <zygoloid> byorgey: had a chance to go punting yet?
07:22:19 <byorgey> oh, I know, I don't mind the rain so much either
07:22:31 <byorgey> no punting yet, but that's on the to-do list
07:23:03 <gwern> what is punting in this context? it's an overloaded word
07:23:17 <zygoloid> gwern: pushing boats down the river Cam with big sticks :)
07:23:29 <gwern> that sounds silly
07:23:48 <byorgey> it IS silly, which I think is the point =)
07:24:22 <applicative> It's best if you're wearing incredibly elegant clothes
07:24:38 <zygoloid> bring a punnet of strawberries and some champagne for the 'real' experience :)
07:25:41 <zygoloid> byorgey: we should have some kind of cambridge haskellers pub trip while you're here
07:25:48 * byorgey will keep these suggestions in mind
07:25:57 <danharaj> just make sure not to try to hack ghc after the pub
07:26:07 <byorgey> zygoloid: that would be fun!
07:26:42 <eldragon> for this tonight, Iran could be probably EMP-detonated
07:31:59 <benmachine> zygoloid: aw I've already gone home :(
07:32:05 <benmachine> had it been but two weeks ago
07:33:09 <zygoloid> benmachine: you were here too? damn :(
07:33:19 <Axman6> @tell blackh I tried to email you about AusHac, but the emailed bounced! If you can pm me another email address, i can forward the message to you (we have a new signup for that's necessary if you want access to the UNSW wireless) [Sign up
07:33:20 <lambdabot> Consider it noted.
07:33:26 <Axman6> damn it!
07:33:35 <benmachine> zygoloid: I go to the university, I'm pretty sure I mentioned it >_>
07:33:56 <benmachine> are you graduating this year or something?
07:33:57 <Axman6> @tell blackh I tried to email you about AusHac, but the emailed bounced! If you can pm me another email address, i can forward the message to you (we have a new signup for that's necessary if you want access to the UNSW wireless) [Sign up's here: http://axman6.wufoo.com/forms/aushac-2010-sign-up-20/]* sorry for the double post!
07:33:57 <lambdabot> Consider it noted.
07:34:03 <zygoloid> benmachine: duh, yeah, you have a website at the srcf dontcha :)
07:34:09 <benmachine> yes
07:34:23 <zygoloid> i graduated a few years ago, but still live here
07:34:26 <benmachine> oh right
07:34:40 <benmachine> oh I thought you had an srcf thing too
07:34:43 <benmachine> or do you somehow magically
07:35:04 <zygoloid> used to, but not for a long time now
07:35:08 <benmachine> oh right
07:38:59 <triyo> Could someone point me to some good examples that demonstrate good use of Parsec lib? I'm new to parsec, well haskell for that matter, and my parser code looking like dogs breakfast.
07:39:33 <Axman6> parsec maps quite nicely from BNF i've found
07:39:44 <triyo> BNF?
07:39:48 <Axman6> but as for good examples, not sure where to nook
07:39:50 <Axman6> look*
07:40:17 <sclv> ?go bnf
07:40:17 <lambdabot> Maybe you meant: google googleit do
07:40:20 <sclv> ?google bnf
07:40:21 <lambdabot> http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form
07:40:21 <lambdabot> Title: Backus–Naur Form - Wikipedia, the free encyclopedia
07:40:23 <danharaj> except left recursive grammars
07:40:29 <Axman6> Backus Naur Form
07:40:41 <Axman6> bleh, took too long checking spelling :P
07:41:17 * ManateeLazyCat Ho Wow! dupTChan....
07:41:50 <sclv> I'm happy with my own parsers, but I'm not sure how properly idiomatic they are.
07:42:18 <sclv> I like to write 'em incrementally and by exploration rather than going for a formal spec.
07:43:03 <sclv> generally, if you want it, parsec has a combinator to help you do it already...
07:43:27 <sclv> especially if you take advantage of its nifty expression parser, and its tokenizing
07:44:29 <sclv> I assume you've seen the original documentation (even though somewhat dated?) : http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:45:35 <triyo> What is the easiest way, using parsec to, get the "last occurrence" of ...  p <- between (char '(') (char ')')
07:45:59 <triyo> I want to get the last set of parans in a given str input
07:46:34 <sclv> as in "(stuff)(otherstuff)(laststuff)" and you want laststuff?
07:47:05 <zygoloid> p <- last <$> many (between (char '(') (char ')')), maybe?
07:47:26 <triyo> sclv: right
07:48:03 <sclv> zygoloid has the right idea -- you need to parse them all, and just take the last.
07:51:24 <triyo> ok, let me try give more detail which will help. Lets say I wish to Parse this given string "@FIXME(bob, joe): cosmetic :: Add loading image for ajax calls (H 0.5)"
07:51:57 <Axman6> kamatsu: thanks for filling out that form so quickly :)
07:52:38 <triyo> Rules are as follows: @FIXME(user-list*): tag* :: action (priority* hours*)
07:53:11 <kamatsu> Axman6: i don't need wifi access, i already have it
07:53:15 <triyo> So a valid min input could also be"@FIXIME: do something"
07:53:55 <Axman6> kamatsu: ok, i'll try and remember that
07:54:12 <triyo> zygoloid: that looks good however that will consume all the params along the way until last, right?
07:54:27 <Axman6> i'm guessing benl and chak won't need it either
07:57:22 <Itkovian> nobench's compress timed on the commandline using time yields consistently lower times than using criterion :-/
07:58:03 <kamatsu> you would be correct
07:58:16 <kamatsu> any other unsw people?
07:58:17 <kamatsu> jeremy apthorp
07:58:41 <Axman6> ok, i think i should add this to the form
07:59:45 <byorgey> triyo: I don't understand what getting the last of something has to do with your example.
08:00:57 <Axman6> kamatsu: anything else you can think of adding to the form?
08:01:06 <kamatsu> nope
08:01:11 <Axman6> or changes you think should be made?
08:01:26 <ksf> triyo, that grammar looks regular, you shouldn't have any problems
08:01:28 <kamatsu> nah, she'll be right
08:01:38 <Axman6> i've added a option asking if people need wireless or not
08:01:41 <ksf> what you shouldn't try to do, though, is not parse the whole thing in one go and put it into a data structure
08:01:55 <ksf> if you've got the whole list, you can call last on it to get the last element
08:02:05 <byorgey> double negatives aren't not confusing
08:02:35 <ksf> you just _cannot_ leave out anything while parsing. it's a strict left-to-right-until-the-end thing.
08:03:15 <Axman6> AST++
08:03:39 <triyo> byorgey: my "action" part needs a termination somewhere. Its either the eof or the open paran '('. question is what happens when action part has parans.
08:03:57 <ksf> no it doesn't.
08:04:08 <ksf> it terminate on the first character that can't be an action description
08:04:21 <byorgey> yeah, don't worry about that, parsec will take care of that for you =)
08:04:54 <ksf> _don't_ do a grammar that allows @BR()KEN(grammar, that, is, bad, for, you)
08:05:04 <byorgey> oh, wait, I see what you are saying
08:05:16 <byorgey> that sounds evil
08:05:45 <triyo> ksf: so in my case it is what if the (H 0.5), the last paran, in my example is optinal
08:05:49 <ksf> if it's possible to unambiguate such a beast, then chances are it's not cheap. parsing goes up to NP-complete before becoming undecidable...
08:05:53 <byorgey> @FIXME(bob): foo :: add (more) (parens) (H 0.5)
08:05:54 <lambdabot> Unknown command, try @list
08:06:01 <byorgey> like that?
08:06:37 <triyo> exactly :)
08:06:57 <byorgey> triyo: is this a grammar you are making up, or it's some existing data you have to parse?
08:07:03 <triyo> I don't have to make my life that difficult I guess. I could rule out the parans in action perhaps?
08:07:25 <triyo> byorgey: making up the grammer
08:07:40 <ksf> Command <$> (tok '@' >* many alpha) <*> parens (alpha `sepBy` ',') <*> ( tok ':' *> optional (anyChar `manyTill` eof))
08:07:47 <byorgey> actually, it should be OK anyway
08:07:50 <ksf> ...or something like that.
08:08:00 <triyo> wow
08:08:09 <ksf> it's ok to be ambiguous at the end, but never do that at the beginning.
08:08:40 * triyo to shy to show his version
08:08:48 <ksf> you usually want such a grammar to be strictly regular
08:09:08 <triyo> ksf: right, only at the end
08:09:41 <ksf> oh, and you shouldn't make that eof optional...
08:10:13 <ksf> I think parsec's many is greedy, though, so it should'nt be much of a problem anyway.
08:10:24 <triyo> ksf: ok, if you could please explain to me how your above one-line works.
08:10:34 <zygoloid> ksf: that only parses upto and including the tags, right?
08:10:35 <triyo> what is tok?
08:10:45 <djahandarie> @hoogle tok
08:10:45 <lambdabot> module Text.Parsec.Token
08:10:46 <lambdabot> module Text.ParserCombinators.Parsec.Token
08:10:46 <lambdabot> Language.Haskell.Lexer data Token
08:10:48 <ksf> match a single character and return it
08:10:55 <ksf> dunno how parsec calls that
08:11:05 <byorgey> I think it's called  char
08:11:12 <byorgey> if you import the right module
08:11:16 <triyo> yes it is
08:11:18 <triyo> its char
08:11:18 <triyo> thx
08:11:26 * ksf uses tok in his parser because it supports more token types than chars...
08:11:58 <ksf> and you want "some alpha `sepBy` ','", I think.
08:12:14 <djahandarie> ksf, what else does it support?
08:12:28 <ksf> there's two implementations, right now.
08:12:30 <triyo> why ',' thought?
08:13:11 <ksf> one requires tokens to be usable as key for any gmap, the other one uses DiscreteOrdered from Data.Ranged.
08:13:20 <byorgey> `sepBy` (char ','), surely
08:13:31 <ksf> yep
08:13:40 <byorgey> actually I think there's an exported  comma :: Parser Char
08:13:47 <byorgey> so you can just say  `sepBy` comma
08:13:58 <benmachine> clearly we need -XOverloadedChars
08:14:10 <ksf> ...I switched to discreteordered because dealing with unicode points as tokens without supporting ranges begs for problems.
08:14:37 <byorgey> and -XOverloadedBool, and -XOverloadedLists, and...
08:14:53 <ksf> I've got my own IsChar class...
08:15:18 <ksf> ...to make one parser run on both Word8 and Char
08:15:46 <benmachine> neat
08:16:02 <wavewave> hello, I have an issue. please help me.
08:16:18 <ksf> I even did data PctEncoded c = Pct {unPct :: Int} | Chr {unChr :: c} to keep things sane
08:16:26 <triyo> ok, I finally understand the code, thanks ksf
08:16:36 <wavewave> I have a bad dependency problem of cabal
08:17:14 <triyo> ksf: only question, what is meant to go in place of Command in your example?
08:17:24 <wavewave> I typed 'cabal upgrade Cabal' and it installed some new versions of libraries.
08:17:25 <ksf> your data type constructor
08:17:39 <ksf> data Command = Command String [String] (Maybe String)
08:17:39 <benmachine> wavewave: usually install is preferred to upgrade
08:17:46 <wavewave> Now all my programs are not compiled. 
08:17:57 <triyo> ksf: oh I see, thats very cool
08:18:05 <wavewave> benmachine: I now realize it. :-(
08:18:08 <ksf> applicative indeed is.
08:18:31 <wavewave> I do not know even where to start.. 
08:18:37 <benmachine> wavewave: pastebin the output of ghc-pkg check?
08:18:38 <ksf> does parsec by now ship with an applicative instance?
08:18:58 <benmachine> ksf: parsec3 has always had one, but people didn't always like parsec3
08:19:04 <triyo> ksf: only applicative I have used so far are very simple examples
08:20:32 <ksf> path_absolute b = tok' '/' *> (option ((:) <$> segment_nz b <*> many (tok' '/' *> segment b)) [])
08:20:32 <ksf> ...to quote the URI RFC.
08:21:31 <ksf> the nice thing about applicative syntax is that it maps 1:1 to EBNF, modulo the stuff needed to say how the parsed chars should be combined to the result
08:21:56 <danharaj> left recursion :(
08:22:03 <danharaj> I wish parsec could automagically factor it out
08:22:17 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26520
08:22:18 <ksf> I'm going to outlaw it any time soon in yoctoparsec
08:22:34 <wavewave> benmachine: this is the result of 'ghc-pkg check'
08:22:47 <byorgey> danharaj: it can in some limited circumstances, see chainl
08:22:49 <triyo> I see no applicative support in parsec 3.0.1
08:22:50 <ksf> and finally start to use an explicit kleene star to be able to compile, not just interpret the thing.
08:23:12 <triyo> RWH show how to define your own instance..
08:23:13 <benmachine> wavewave: eeeek
08:23:35 <applicative> wavewave, yipe
08:23:40 <ksf> recursion in grammars is overvalued.
08:23:52 <benmachine> wavewave: you could try doing cabal install --reinstall on all the affected packages, or you could just scream and reinstall from scratch
08:24:00 <wavewave> MSSMScan, LHCOAnalysis, Computation are my libraries... 
08:24:14 <wavewave> hmm. 
08:24:26 * byorgey would just start over from scratch
08:24:28 <applicative> wavewave, what version of ghc are you using
08:24:39 <eldragon>  what about a GIANT DESERTIC WAR of US-Israel-Germany-SaudiArabia vs Iran-Pakistan-Syria-Turkey ? hahahaha, the war could be bigger and bigger for a chispa.
08:24:50 <byorgey> you'll be happy to know that soon 'cabal upgrade' will be deprecated or made to do something sane, or something like that
08:25:04 <Axman6> wtf?
08:25:11 <Axman6> @where ops
08:25:11 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
08:25:53 <ksf> germany vs. turkey? dream on.
08:26:08 <Phyx-> is @where ops the equivalent of displaying a bat signal in the sky?
08:26:11 <applicative> ksf, that would be *very* ugly
08:26:20 <byorgey> Phyx-: yes, yes it is.
08:26:30 <Jafet> @remember Phyx- is @where ops the equivalent of displaying a bat signal in the sky?
08:26:30 <lambdabot> Nice!
08:26:40 <byorgey> it's a big lambda symbol though
08:26:40 <wavewave> benmachine: I have an error when I reinstall syb-with-class
08:26:46 <Phyx-> lol
08:27:02 <Jafet> It has nondeterministic semantics.
08:27:10 * applicative remembers some mysterious syb-with-class problem
08:27:21 <benmachine> wavewave: which is?
08:27:52 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26521#a26521
08:28:05 <wavewave> benmachine: this is error message. 
08:28:06 <ksf> ...not to mention that turkey is a nato member.
08:28:13 <ksf> it'd be suicide.
08:28:14 <wavewave> applicative: ghc-6.12.1
08:28:53 <djahandarie> Lol eldragon has only said two things and they have both been completely random
08:28:58 <wavewave> why does this kind of things happen?
08:29:14 <byorgey> eldragon: do you have a favorite poem?
08:29:23 <djahandarie> @vixen Do you have a favorite poem?
08:29:23 <lambdabot> good question
08:29:29 <applicative> wavewave, i see, if it were older i had an idea what might be causing it.
08:29:40 <benmachine> wavewave: do you install stuff globally or locally?
08:29:48 <wavewave> locally.. 
08:30:06 <benmachine> hmm
08:30:20 <wavewave> benmachine: ghc is on /usr/local/bin
08:30:27 <benmachine> you might be able to salvage something then by killing local installs of GHC packages (which should be installed globally)
08:30:33 <benmachine> I don't know
08:31:20 <wavewave> benmachine: hmm..
08:32:01 <wavewave> until I typed cabal upgrade Cabal, I didn't have any problem. 
08:32:10 <wavewave> ah... 
08:32:25 <benmachine> by killing, I mean ghc-pkg unregister
08:32:28 <benmachine> not just deleting files
08:32:31 <applicative> wavewave, can you unregister the new Cabal?  That can't be the problem though....
08:32:48 <wavewave> how to unregister?
08:32:57 <applicative> what does ghc-pkg list say
08:32:57 <wavewave> ghc-pkg unregister Cabal?
08:33:05 <applicative> yes
08:33:06 <ezyang> Never ever ever "cabal upgrade FOO" 
08:33:10 <applicative> but give the number
08:33:18 <applicative> so first study ghc-pkg list
08:33:30 <ezyang> I suspect nuking .cabal from orbit is the easiest thing to do now. 
08:33:31 <applicative> then find the new Cabal that got installed, and maybe whatever else
08:33:56 * applicative is with ezyang, that's comparatively easy.
08:34:16 <aristid> i'm trying to use recursive do with lists, but for some reason it does not seem to work: do x <- [1,2,3] ++ y'; y' <- 0; x
08:34:32 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26522#a26522
08:34:45 <wavewave> this is the output of ghc-pkg list
08:35:15 <wavewave> ezyang: Then, cabal developer should erase the command 'upgrade' :-(
08:35:27 <ezyang> wavwave: Yeah, dcoutts has been meaning to do that. 
08:35:32 <applicative> wavewave, yeah....
08:35:37 <djahandarie> Yeah.....
08:36:07 <Phyx-> wavewave: but to be honest, it does warn you not to use it
08:36:11 <applicative> wavewave, well, at least the global stuff seems completely sound, or am I wrong
08:36:23 <Phyx-> well, atleast here upgrade is dissabled
08:36:32 <Phyx-> oh that's without arguments
08:36:34 <Phyx-> carry on
08:36:35 <Phyx-> :)
08:36:36 <wavewave> by the way, what do parentheis and brace mean in the result of ghc-pkg list?
08:36:47 <applicative> it means its hidden
08:36:49 <int-e> () is hidden. {} packages are broken
08:36:50 <eldragon> byorgey, i've not poems
08:36:54 <eldragon> http://www.haaretz.com/news/diplomacy-defense/saudi-arabia-we-will-not-give-israel-air-corridor-for-iran-strike-1.295672  <-- but Saudi Arabia did give him all, the airspace and the base, not?
08:36:55 <wavewave> Phyx-: Really, I didn't see the warning. 
08:36:59 <applicative> yeah, broken
08:37:10 * djahandarie sighs
08:37:13 <applicative> you hide with ghc-pkg hide foo  
08:37:29 <wavewave> what does 'hiding' mean?
08:38:02 <applicative> it means that ghc will go for another package with the same modules
08:38:05 <aristid> nevermind, i need to use mdo
08:38:12 <int-e> wavewave: ghci wont load those packages, and ghc --make won't find them. cabal doesn't care either way
08:38:33 <wavewave> I see...
08:38:46 <applicative> like an older version of the package.  you should know about it, it's a temporary expedient to cover conflicts, most familiarly the different monad transformer libraries.  
08:39:27 <applicative> or the different versions of parsec.  you hide Parsec 3 while compiling with Parsec 2  -- sounder minds will correct me if i'm wrong
08:39:45 <wavewave> applicative: Now I understand it.. thanks.
08:39:57 <applicative> ghc-package unregister declares it to be nonexistent
08:40:33 <wavewave> applicative: so in this case, should i reinstall all braced packages ?
08:41:37 <applicative> i think benmachine or ezyang will have better wisdom.  too bad dcoutts isn't here...
08:41:38 <int-e> wavewave: did you try  ghc-pkg check ?
08:41:39 <wavewave> I think this is caused by array-0.3.0.0
08:41:58 <benmachine> wavewave: it might be caused by array-0.3.0.1
08:42:17 <wavewave> int-e: yes.. you can see http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26520
08:42:27 <wavewave> benmachine: I agree!
08:42:47 <wavewave> benmachine: so what can I do? ghc-pkg unregister array-0.3.0.1 ?
08:43:32 <benmachine> wavewave: maybe. if that's installed locally I'd do that
08:43:46 <applicative> its local
08:44:03 <wavewave> benmachine: by the way, unregister = uninstall?
08:44:11 <int-e> wavewave: ah, you probably reinstalled binary, deepseq, and those other packages with the same package version, so there's no quick way to fix it. (where by "you" I mean you or cabal-install, probably the latter.)
08:44:15 <benmachine> wavewave: no, unregister doesn't delete any files
08:44:26 <int-e> wavewave: so I think you have to rebuild the rest now, too
08:44:27 <benmachine> wavewave: it just removes the package from the database, so ghc no longer knows it exists
08:44:29 <applicative> wavewave it's still there.  
08:44:32 <ezyang> wavewave: Under normal circumstances, they're not really distinguishable. 
08:44:54 <wavewave> Then, to remove files, what should I do?
08:45:07 <benmachine> rm :)
08:45:08 <applicative> wavewave, then the best thing is to start over.
08:45:31 <applicative> you can rm them but what about all the pkg things all over.  
08:46:30 <wavewave> i did it with --force.
08:47:08 <applicative> wavewave, did it say what depended it?  All the broken packages?
08:47:29 <wavewave> ghc-pkg: unregistering array-0.3.0.1 would break the following packages: haskell98-1.0.1.1 iteratee-0.3.5 ListLike-1.0.1 text-0.7.1.0 strict-0.3.2 parallel-2.2.0.1 hslogger-1.0.10 deepseq-1.1.0.0 bytestring-lexing-0.2.1 binary-0.5.0.2 HTTP-4000.0.9 Cabal-1.8.0.6 containers-0.3.0.0 HStringTemplate-0.6.3 strict-concurrency-0.2.3 (use --force to override)
08:47:38 <wavewave> that's wha it said.. 
08:47:55 <int-e> yay, more broken packages.
08:47:59 <benmachine> probably all of those packages will have to be either unregistered or reinstalled
08:48:10 <Phyx-> isn't it just better to just delete everything and reinstall?
08:48:17 <applicative> hmm, some of those arent broken
08:48:44 <benmachine> well, they are now :x
08:49:02 <applicative> Phyx-, et al, does wavewave have so many packages that it's not practical to nuke local .cabal and .ghc?
08:49:14 <int-e> (delete everything = remove /home/wavewave/.ghc/x86_64-linux-6.12.1 and all its subdirectories. those are user installed packages, so ghc will continue to work.)
08:49:19 <wavewave> hmm now installing my library is reinstalling those packages. 
08:49:40 <dpratt71> when you have a function defined in terms of Monads, is there a way see the effective type signature for a particular instance of Monad? does that make sense?
08:49:49 <Phyx-> applicative: i can't imagine, that's why I think it might be easier just to nuke it and start over like someone mentioned
08:50:17 * applicative would start over, but he loves watching cabal install compile.....
08:50:24 <int-e> dpratt71: you mean, in Monad m => ..., replace m by some concrete monad?
08:50:35 <dpratt71> int-e: yes
08:50:46 <wavewave> Phyx- : Nuking it is okay for me, but I first want to know whether there is a cure without doing that. 
08:51:21 <sclv> :t mapM
08:51:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:51:30 <sclv> :t mapM (undefined :: a -> [b])
08:51:31 <lambdabot> forall a b. [a] -> [[b]]
08:51:35 <int-e> @unmtl StateT (ReaderT IO)
08:51:36 <lambdabot> err: `StateT (ReaderT IO)' is not applied to enough arguments.
08:51:41 <int-e> @unmtl StateT (ReaderT IO) a
08:51:41 <lambdabot> err: `StateT (ReaderT IO) a' is not applied to enough arguments.
08:51:42 <wavewave> okay.. now my package seems working! Thank you all!!
08:51:55 <benmachine> @unmtl StateT s (ReaderT r IO) a
08:51:55 <sclv> you can always just pass in a dummy argument that fixes the type of the monad, like above
08:51:56 <lambdabot> s -> r -> IO (a, s)
08:52:18 <int-e> benmachine: thanks.
08:52:58 <dpratt71> ok, I'll try to sort that out, thanks guys
08:53:45 <applicative> @type \f -> Just 1 >>= f
08:53:47 <lambdabot> forall t b. (Num t) => (t -> Maybe b) -> Maybe b
08:53:59 <applicative> @type \f -> [1,2,3] >>= f
08:54:00 <lambdabot> forall t b. (Num t) => (t -> [b]) -> [b]
08:54:23 <applicative> dpratt71, theres some dimwitted specification examples
08:55:11 <applicative> @type \f -> Just (1::Integer) >>= f
08:55:13 <lambdabot> forall b. (Integer -> Maybe b) -> Maybe b
08:55:40 <benmachine> :t let f = mapM in const f (f (:[]))
08:55:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:55:46 <benmachine> hmm
08:57:17 <sclv> heh. works in ghci -- using the monomorphism restriction for fun and profit :-)
08:58:04 <Phyx-> :t ForeignPtr
08:58:05 <lambdabot> Not in scope: data constructor `ForeignPtr'
08:58:14 <Phyx-> :src ForeignPtr
08:58:21 <Phyx-> @src ForeignPtr
08:58:21 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
08:58:37 <Phyx-> @src FunPtr
08:58:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:04:25 <eldragon> http://www.jewishtimes.com/index.php/jewishtimes/news/jt/national_news/iran_sanctions_bill_grants_obama_waiver_not_exemption/19400  <-- White House exceeds the border of its sovereignty.
09:11:39 <zygoloid> @where ops
09:11:39 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
09:11:58 <allbery_b> mrf?
09:12:12 --- mode: ChanServ set +o Igloo
09:12:36 --- mode: Igloo set +b *!*@84.79.67.254
09:12:42 --- kick: eldragon was kicked by Igloo (eldragon)
09:15:30 <gwern> member _ Tip = False
09:15:34 <gwern> member x t = x ‘seq‘ member’ t Û Ö member’ Tip = False
09:15:46 <gwern> wouldn't member' in the where clause be dead code since it's already matched against Tip?
09:16:48 <aristid> gwern: do you use a weird character set?
09:16:54 <gwern> PDF does
09:17:01 <aristid> gwern: or do you use german umlauts as operators?
09:18:32 <aristid> pdf?
09:24:48 <wavewave> benmachine, applicative, int-e, Phyx- : I finally nuked it :-(
09:24:54 <benmachine> aw
09:25:57 <wavewave> had other dependency issues.... practically, it is reinstalling everything.. 
09:25:59 <b0fh_ua> Hello! I need something like : when :: (Monad m) => Bool -> m a -> m a. So when used with lists, if condition evaluates to true, then second argument is returned, otherwise return []
09:26:05 <b0fh_ua> is it possible somehow?
09:26:28 <ddarius> when' p m = guard p >> m
09:26:39 <benmachine> that requires MonadZero m though
09:26:42 <benmachine> er
09:26:43 <benmachine> MonadPlus
09:27:20 <ksf> cabal isn't (yet) meant to be a distribution, I expect a nuke about one or two times per ghc version
09:27:21 <b0fh_ua> so no library function for now?
09:28:07 <ksf> b0fh_ua, never hesitate to write your own
09:28:11 <BMeph> :t unless
09:28:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:28:30 <BMeph> @src when
09:28:30 <lambdabot> when p s = if p then s else return ()
09:28:35 <b0fh_ua> ksf: well, I would't like to reinvent the wheel )
09:28:37 <ksf> ...as long as they're easy to locate.
09:28:38 <BMeph> @src unless
09:28:38 <lambdabot> unless p s = if p then return () else s
09:28:57 <byorgey> b0fh_ua: you could try looking in the IfElse package.
09:28:57 <Phyx-> @src guard
09:28:58 <lambdabot> guard True  =  return ()
09:28:58 <lambdabot> guard False =  mzero
09:29:06 <ksf> there's a difference between re-writing when and reimplementing say utf8 decoding.
09:29:19 * hackagebot graph-utils 0.3.5 - A simple wapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.5 (HiromiIshii)
09:29:54 <b0fh_ua> byorgey: I tried - but nothing really suitable
09:30:00 <byorgey> ok.
09:30:05 <mreh> x `seq` x always looks a bit weird
09:30:19 <b0fh_ua> they want to use m () always 
09:30:32 <ksf> in all my years, the only one I came up with that'd be worthy of inclusion in the std libs would be option :: Alternative f -> f a -> a -> f a
09:31:31 <djahandarie> Would something like '\x -> mappend mzero x' be transformed to a noop??
09:31:44 <ddarius> Not in general.
09:32:09 <djahandarie> What would be a case where it would?
09:32:48 <ddarius> djahandarie: I think you meant mempty as opposed to mzero, but any time the optimizer can optimize it to a no-op.
09:33:20 <djahandarie> Oh, yeah, that's what I meant
09:33:55 <djahandarie> So it 'knows' that Monoid law?
09:34:52 <ddarius> No.
09:35:04 <ddarius> It inlines and knows the semantics of Haskell.
09:35:23 <djahandarie> So it'd have to inline all the way in order to know if it can actually make that optimization or not
09:35:29 <djahandarie> i.e., it'd depend on the instance
09:35:35 <ddarius> The monoid laws are not required to hold and don't hold for all instances.
09:37:31 <djahandarie> Isn't it bad if the laws don't hold for an instance though?
09:37:45 <ddarius> To varying extents, sure.
09:38:16 <benmachine> djahandarie: if it knows the type of x in that instance, it can inline the instance definition and then work out what exactly was going on
09:38:38 <djahandarie> When would it be okay to define an instance of Monoid which doesn't satisfy the laws?
09:38:49 <benmachine> when no-one finds out
09:39:08 <djahandarie> Isn't it... not a Monoid if you do that? :P
09:39:30 <ddarius> djahandarie: The only reasonably case I can think of is when you intend to satisfy the monoid laws "up to" some less stringent notion of equality.
09:39:51 <djahandarie> Hmm
09:39:55 <ddarius> djahandarie: Nevertheless there are instances that simply don't.  I believe the () instance still doesn't satisfy the monoid laws.
09:40:37 <djahandarie> > mappend () (mappend () ()) == mappend (mappend () ()) ()
09:40:38 <lambdabot>   True
09:40:57 <djahandarie> > mappend () mempty = ()
09:40:58 <lambdabot>   <no location info>: parse error on input `='
09:41:00 <djahandarie> > mappend () mempty == ()
09:41:01 <lambdabot>   True
09:41:11 <benmachine> > mappend undefined mempty == ()
09:41:12 <lambdabot>   True
09:41:19 <djahandarie> Ah
09:41:20 <benmachine> ^ this is the bit that upsets people generally
09:41:44 <djahandarie> Wouldn't making it strict solve that?
09:41:48 <edwardk> benmachine: there are lots of monoids that behave strangely in the presence of undefined though
09:41:51 <ddarius> djahandarie: Yes.
09:41:57 <benmachine> djahandarie: it would, but it would also make it strict
09:42:05 <ddarius> djahandarie: I've suggested just that before on the mailing list.
09:42:06 <benmachine> which people may or may not want
09:42:17 <edwardk> ddarius: i think that cure is worse than the disease ;)
09:42:22 <djahandarie> God damn, strictness is always causing problems
09:42:24 <ddarius> edwardk: I don't agree.
09:42:44 <ddarius> djahandarie: It's not strictness or non-strictness.  It's the mixture that creates power and complexity.
09:43:09 <BMeph> Is there a name for the different algebras one can make from a given set?
09:44:50 <djahandarie> Wouldn't it just be "an algebra over X" where X is a set?
09:44:51 <ddarius> BMeph: Your question doesn't make sense.
09:44:56 <edwardk> bmephs: universal algebras with a common set? =)
09:45:18 <edwardk> BMeph: seems fairly concise ;)
09:45:33 <dpratt71> I wish I had a better intuition for type unification in Haskell; non-trivial cases tend to confuse me greatly
09:45:44 <djahandarie> edwardk, throw some greek letters in there then it'll be good
09:45:47 <ddarius> dpratt71: Learn Prolog.
09:46:06 <epicbeardman_> hi, I'm writing a module implementing a continued fraction type, and I'm having some problems with real -> CF conversion.
09:46:06 <edwardk> djahandarie: you could get fancy and call the set the carrier, so they would be universal algebras with a common carrier ;)
09:46:12 <wli> Actually I like Mercury better than Prolog.
09:46:20 <epicbeardman_> Could someone check this out? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26523#a26523
09:46:22 <dpratt71> ddarius: that sounds like the start of a 'now you have two problems' joke
09:46:33 <wli> Static typing in Mercury helps a bit.
09:46:34 <edwardk> dpratt71: hahah
09:46:44 <epicbeardman_> the error I get is an `ambiguous type variable t in constraint'
09:46:49 <ddarius> dpratt71: That sounds like you don't know Prolog, so you should learn Prolog.
09:46:54 <edwardk> i do agree that mercury's types make it a lot more fun than prolog
09:47:11 <BMeph> dpratt71: You should set it up so we can @quote you... ;)
09:47:28 <sclv> urgent and key news with regards to language popularity: http://chronicle.com/blogPost/The-Trustworthiness-of-Beards/22581/
09:47:34 <ddarius> Silly BMeph and thinking @quotes need to reflect reality.
09:47:44 <dpratt71> heh
09:47:51 <djahandarie> There is no @quote
09:48:17 <BMeph> ddarius: On another note: Have you heard of any projects to use Maude and Clean together? It looks interesting as a concept... :)
09:48:35 * dpratt71 goes off to learn Prolog
09:48:50 * wli has never heard of Maude.
09:49:11 <dpratt71> (just so he can understand "ap zip tail")
09:49:13 * BMeph things wli should fix that...
09:49:34 * BMeph meant "thinks, not things, really.
09:49:46 <edwardk> @type zip
09:49:47 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
09:49:48 <edwardk> @type ap zip
09:49:49 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
09:49:51 <sproingie> thinking of Maude, you forgot everything else
09:49:55 <edwardk> @type tail
09:49:56 <lambdabot> forall a. [a] -> [a]
09:49:58 <edwardk> @type ap zip tail
09:49:59 <lambdabot> forall b. [b] -> [(b, b)]
09:50:00 <edwardk> done ;)
09:50:11 * ddarius returns to work.
09:50:11 <wli> I'm probably under too much stress to try to learn Maude or something.
09:50:44 <dpratt71> edwardk: it's the "ap zip" part that I'm struggling with
09:50:48 <Gracenotes> ap is the weird one. and really, it's just ap f g = \x -> f x (g x). at least in this instane.
09:51:10 <edwardk> @type ap
09:51:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:51:23 <djahandarie> Yeah, that'll help :P
09:51:27 <sproingie> isn't ap usually used infix?
09:51:42 <sproingie> might be clearer that way
09:51:49 <c_wraith> usually.  especially if you call it <*>
09:51:51 <edwardk> go to unify m (a -> b) with [c] -> ([d] -> [(c,d)])
09:51:51 <Gracenotes> or <*>
09:52:05 <c_wraith> I've used ap prefix when it requires less punctuation, though.
09:52:13 <dpratt71> the type of zip has to be unified with "m (a -> b)", right?
09:52:21 <edwardk> then to get the right shape you need to see the right hand size as (->) [c] ([d] -> [(c,d)])
09:52:25 <edwardk> so m = (->) [c]
09:52:27 <Gracenotes> one way to think about (r->) function instances is to mentally replace 'm' with 'r ->'
09:52:34 <edwardk> a = [d]
09:52:39 <edwardk> and b = [(c,d)]
09:52:58 <edwardk> then substitute those answers into m a -> m b
09:53:13 <djahandarie> Is there an actual reason why it needs to be ((->)r) in type signatures rather than just (r->) ?
09:53:29 <Gracenotes> no type sections :|
09:53:35 <edwardk> ((->) [c] [d]) -> ((->) [c] [(c,d)])
09:53:37 <djahandarie> Yeah -- why are there no type sections? :P
09:53:41 <edwardk> flip the arrows back into something natural
09:53:54 <edwardk> ([c] -> [d]) -> [c] -> [(c,d)]
09:53:58 <edwardk> @type ap zip
09:53:59 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
09:54:05 <Gracenotes> not widely enough used I suppose
09:54:06 <edwardk> which is alpha equivalent to that
09:54:11 <dpratt71> edwardk: so simple :)
09:54:49 <Gracenotes> programming language design doesn't have to be brutally consistent
09:54:50 <djahandarie> You can use the term alpha equivalent in the context of types?
09:54:57 <aristid> > (zip`ap`(tail.tail)) [1..]
09:54:58 <lambdabot>   [(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10),(9,11),(10,12),(11,13),(1...
09:55:08 <edwardk> dpratt71: its driven by the fact that m :: * -> *, but (->) :: * -> * -> *   --- well technically ?? -> ? -> *, so to match up the types m has to consume both (->) and its first argument during unification
09:55:13 <epicbeardman_> Why does f x = (floor x):(toC (x-(floor x))) have ambiguous types in the constraint?
09:55:28 <edwardk> @type toC
09:55:29 <lambdabot> Not in scope: `toC'
09:55:36 <epicbeardman_> err, f x = (floor x):(f (x-(floor x))) 
09:55:51 <Gracenotes> integers aren't floorable
09:56:09 <epicbeardman_> I expect to give it reals.
09:56:20 <aristid> :t let f x = (floor x):(f (x-(floor x))) in f
09:56:21 <lambdabot> forall a b. (Integral a, Integral b, RealFrac a) => a -> [b]
09:56:24 <MadHatterDude> God damn this type system... It promises so much but strikesi n the spur of creativity.
09:56:36 <aristid> :t floor
09:56:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:56:41 <Gracenotes> but, generally, there isn't any type that can both be an argument to floor and a result of it
09:56:43 <MadHatterDude> I think I might need some help here...
09:56:45 <Gracenotes> at least in the prelude
09:56:50 <aristid> :t fromInteger . floor
09:56:51 <lambdabot> forall a a1. (Num a, RealFrac a1) => a1 -> a
09:57:04 <aristid> MadHatterDude: ^
09:57:10 <aristid> oh
09:57:10 <epicbeardman_> Gracenotes: actually, I get the same problem if I just convert to Integer instead of using floor
09:57:19 <aristid> epicbeardman_: there, you need fromInteger
09:57:24 <Gracenotes> so there isn't any type of x that satisfies (x-floor x) in the commonly used numerical types
09:57:28 * edwardk is sad and must now break all the types in his pretty 'ad' library
09:57:36 <djahandarie> edwardk, :-(
09:57:42 <dpratt71> edwardk: thanks for the explanation; I don't grok it all, yet, but I will eventually (I hope)
09:57:48 <edwardk> djahandarie: all in the name of speed ;)
09:57:54 <djahandarie> \o/ Speed!
09:58:35 <epicbeardman_> aristid: that didn't seem to work. The actual code I am using is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26523#a26523
09:58:39 <Gracenotes> epicbeardman_: so (floor x) gives you an integral type from a real type, you want the result to be real. so do realToFrac
09:58:48 <edwardk> djahandarie: as it is right now the way i pass in functions looks something like grad :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> f a
09:59:16 <edwardk> djahandarie: but this means that the function must use the dictionary provided to do pretty much anything with the contents of AD s a
09:59:24 <aristid> Gracenotes: wouldn't fromInteger work too?
09:59:31 <edwardk> djahandarie: this is good from a safety perspective, but bad from a performance perspective
09:59:34 <epicbeardman_> Gracenotes: that doesn't seem to work, either.
09:59:36 <Gracenotes> aristid: it would
09:59:44 <edwardk> so the first fix is to separate out the infinitesimal from the mode
09:59:49 <Gracenotes> :t \x -> (x - realToFrac (floor x))
09:59:50 <lambdabot> forall a. (RealFrac a) => a -> a
09:59:51 <epicbeardman_> the actual code I am using is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26523#a26523
09:59:59 <MadHatterDude> I am implementing a monadic parser system akin to Parsec, but I cant get my input feeder class to do as I want.
10:00:08 <aristid> epicbeardman_: where's "recip"?
10:00:22 <epicbeardman_> aristid: Fractional
10:00:27 <edwardk> grad :: (Traversable f, Num a) => (forall s. f (AD Reverse s a) -> AD Reverse s a) -> f a -> f a -- which can still be quantified if i need multiple modes
10:00:39 <aristid> epicbeardman_: oh, lol thought it was a function of yours :D
10:00:58 <edwardk> then the second step is to move the 'f' inside of the gradient, because in many places it is faster to manipulate taylor series/etc of matrices than matrices of taylor series
10:00:58 <aristid> epicbeardman_: try xf = fromInteger (floor x)
10:01:16 <MadHatterDude> Here's my code
10:01:17 <MadHatterDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26524#a26524
10:01:24 <Gracenotes> realToFrac likely goes through the same code as fromInteger anyway, because of defaulting
10:01:30 <djahandarie> edwardk, do you plan on using this for something?
10:01:37 <epicbeardman_> aristid: wtf, that didn't work and now it does... maybe I didn't :r
10:01:39 <epicbeardman_> thanks
10:01:48 <edwardk> grad :: (Traversable f, Num a) => (forall s. AD f Reverse s a -> AD Id Reverse s a) -> f a -> f a -- with suitable aliases to call AD Id "ADScalar" or something
10:02:19 <Apocalisp> What do you call a binary operation together with an element that commutes across that operation?
10:02:28 <edwardk> djahandarie: taylor models, soling ODEs, a shinier better version of hnn, estimating confidence intervals around results given them around inputs, etc.
10:03:17 <edwardk> Apocalisp: commutes or distributes?
10:03:31 <pchiusano> edwardk: commutes
10:03:35 <djahandarie> HNN as in that neural network library?
10:03:43 <Gracenotes> commutative magma?
10:03:43 <Apocalisp> z * x = x * z, for all x
10:03:45 <edwardk> so e * x = x * e where e is an example of that element?
10:03:54 <devid_> hi guys, im having a hard time installing SDL on my ghc... im kind of stuck with the error "* Missing header file: SDL.h" and dont know how to fix that (cabal install SDL wont work either, but thats another story (fscked up tmp dir path))
10:03:55 <Apocalisp> edwardk: Yes
10:04:11 <edwardk> Apocalisp: you'd say that e is an element of the center of the monoid
10:04:12 <Gracenotes> is there another name for a commutative magma? :/
10:04:18 <edwardk> or of the center of the magma
10:04:31 <Gracenotes> oh, not commutative for all elements, just a single one.
10:04:41 <pchiusano> wait, isn't magma not associative?
10:04:44 <Gracenotes> mumbling something about reading comprehension
10:04:52 <edwardk> pchiusano: correct. associativity gives you a semigroup
10:05:02 <edwardk> add a unit and you get a monoid
10:05:05 <Apocalisp> OK, so what we're looking for is semigroup with a center.
10:05:07 <pchiusano> Apocalisp forgot to mention this is a semigroup, together with distinguished element
10:05:21 <Apocalisp> yeah, sorry
10:05:22 <pchiusano> where the distinguished element is commutative wrt the semigroup op
10:05:43 <djahandarie> A semigroup is a type of magma though isn't it?
10:05:46 <Gracenotes> well is it associative? does it matter?
10:05:47 <edwardk> fair enough, then the commutative elements are part of the center of your semigroup. elements in the center commute with all other elements.
10:06:03 <edwardk> djahandarie: definitely
10:06:29 <djahandarie> Wait -- wouldn't a commutative magma just be an abelian group?
10:06:34 <pchiusano> edwardk: so the "center" can contain multiple elements?
10:06:39 <edwardk> pchiusano: yep
10:06:55 <Gracenotes> djahandarie: lacks associativity, identity element, inverses, I think
10:07:00 <edwardk> pchiusano: a semigroup is commutative (or Abelian) when the center of the semigroup is the entire semigroup ;)
10:07:20 <pchiusano> edwardk: what if the center is just a single element
10:07:21 <Apocalisp> Cancellative semigroup with non-empty center?
10:07:28 <edwardk> pchiusano: that is fine too
10:07:37 <pchiusano> is there a name for that structure?
10:07:58 <edwardk> pchiusano: or anything in between, the center is just a subset of the elements it can be empty or the full set or anything in between
10:08:24 <pchiusano> edwardk: i see
10:09:06 <delusion42> Anyone willing to help me out with a monadic iteratee implementation with? I'm stuck on making a Monad instance for something: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26525 
10:09:13 <djahandarie> Wow I definitely need to get work done, and I'm in here instead
10:09:13 <edwardk> well, you don't talk about the semigroup as something interesting, you just say that elements of the center are central. or you can say that the semigroup is centerless if it doesn't have any elements in its center, though that terminology is ambiguous
10:09:31 <edwardk> because when you talk about groups they are centerless if the only member of their center is their identity (which must by construction be central)
10:10:30 <pchiusano> edwardk: i see
10:11:22 <pchiusano> edwardk: what would be a good name for a typeclass where the semigroup has a single central element?
10:11:27 <edwardk> pchiusano: perhaps just enrich your data type for describing your semigroup with a 'central :: a -> Bool' flag that tells you if the element is in the center?
10:11:48 <pchiusano> edwardk: no, we need to know what the actual value is
10:11:58 <pchiusano> at the center
10:12:21 <benmachine> centre :: [a]?
10:12:38 <benmachine> or Set a I suppose but that requires Ord a
10:12:39 <edwardk> you could follow benmachine's idea and enumerate them
10:12:44 <djahandarie> @hoogle abelian
10:12:44 <lambdabot> No results found
10:12:58 <djahandarie> @hayoo abelian
10:12:59 <lambdabot> Unknown command, try @list
10:13:00 <pchiusano> yeah, the only thing is, for this application it doesn't really make sense to have multiple items at the center
10:13:08 <noteed> djahandarie: I'm here *and* I get work done (well a bit slowly as I've a bit too much rum in my blood right now :) )
10:13:23 <benmachine> pchiusano: what *is* the application?
10:13:23 <edwardk> pchiusano: then probably something horribly verbose like 'singularlycenteredsemigroup' ;)
10:13:35 <djahandarie> noteed, heh, I guess I'm just not good at multitasking
10:13:51 <pchiusano> edwardk: hehe
10:14:38 <pchiusano> benmachine: the application is that the central element represents a strategy for handling "holes" in the data
10:15:09 <pchiusano> basically, what to replace the holes with
10:15:21 <Apocalisp> MonocentralSemigroup a
10:15:55 <zygoloid> sounds like an AlmostMonoid
10:16:14 <edwardk> zygoloid: it is, pretty much
10:16:17 <olsner> Semioid?
10:16:25 <pchiusano> zygoloid: yeah it is almost the same as a Monoid (Maybe a)
10:16:26 <zygoloid> MonoidWithDodgyIdentity
10:16:43 <edwardk> you might get away with 'PreMonoid' ;)
10:16:47 <Apocalisp> UnicentralSemigroup a
10:16:51 <pchiusano> but not quite because None is not the identity
10:17:05 <edwardk> with the observation that it has a single center that is only commutative, not an identity
10:18:00 <pchiusano> edwardk: hmm, PreMonoid...
10:19:39 <edwardk> pchiusano: though the name premonoid is also fairly overloaded in literature and is used sometimes to just refer to a semigroup
10:20:01 <pchiusano> edwardk: oh okay
10:20:03 <Apocalisp> boom
10:20:04 <pchiusano> meh
10:20:06 <Apocalisp> Trace Monoid
10:20:19 <edwardk> its not used very often and semigroup is much more accepted as a name for what it would connote
10:20:20 <pchiusano> Apocalisp: trace monoid?
10:20:31 <Apocalisp> That's what this structure is called in literature. A trace.
10:20:33 <djahandarie> We already abuse terminology all the time, a little more can't hurt. ;)
10:20:43 <delusion42> Anyone willing to help me out with a monadic iteratee implementation? I'm stuck on making a Monad instance: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26525 
10:20:54 <Apocalisp> http://en.wikipedia.org/wiki/Trace_monoid
10:21:29 * ksf how to parse (abc|ab(c|d))* with zero lookahead and backtracking while still being able to distinguishing between the first abc and the second abc?
10:21:32 <pchiusano> Apocalisp: hmm, that doesn't seem like the same thing...
10:21:51 <edwardk> Apocalisp: nah a trace monoid is actually a full fledged monoid
10:22:08 <Apocalisp> Trace Semigroup then
10:22:10 <ksf> wait no (abc)*|(ab(c|d))*
10:22:39 * wli would do the usual state machine affairs.
10:22:45 <pchiusano> Apocalisp: nope, http://en.wikipedia.org/wiki/Trace_semigroup doesn't exist, therefore it isn't real!!! :)
10:22:50 <Apocalisp> Yeah, a trace monoid actually is a monoid.
10:23:13 <Apocalisp> I vote TraceSemigroup
10:23:24 <Apocalisp> I'll add the wikipedia entry for it
10:23:29 <pchiusano> hehe
10:23:42 <pchiusano> I'm not sure tracesemigroup is accurate either...
10:24:00 <edwardk> pchiusano: well, you could just abuse the terminology and call it a CenteredSemigroup
10:24:21 <edwardk> with the fact that center :: CenteredSemigroup => a -- gives you back some element of the center.
10:24:44 <ksf> let's write that (Foo <$> many (toks "abc")) <|> (Bar <$> many ((\x y -> xs ++ [y]) <$> toks "ab" <*> (tok 'c' <|> tok 'd')))
10:24:58 <BMeph> A Pointed Semi-Group? ;p
10:25:03 <ksf> ...for the sake of saying why distinguishing between the abcs is important.
10:25:11 <pchiusano> edwardk: yeah
10:25:26 <ksf> abcabcabc shoud yield [Foo,Foo,Foo] while abcabcabd should yield (Bar,Bar,Bar)
10:25:47 <edwardk> BMeph: that actually is pretty good
10:25:57 <ksf> the problem with the usual state machine notions is that they care about matching, and matching only.
10:25:58 <pchiusano> PointedCentralSemigroup??
10:26:05 <edwardk> a pointed set is just a set with a distinguished element.
10:26:17 <edwardk> you don't need the fact that the center is commutative per se if this is for what i think it is
10:26:28 <jmcarthur> what distinguishes this element?
10:26:35 <jmcarthur> that it's commutative?
10:26:40 <jmcarthur> i haven't read the scrollback
10:26:47 <edwardk> jmcarthur: they're using it to mark missing values in a reducer
10:26:49 <ksf> that one is shoved into Bar and the other into Foo
10:26:50 <triyo> RWH introduces Applicative parsing examples. Does newer parsec versions have built-in support for applicative parsing or do I have to use the ApplicativeParsec.hs from RWH?
10:26:54 <jmcarthur> ah
10:27:17 <pchiusano> edwardk: it needs to be commutative so that the lifted version's operation is still associative
10:27:18 * hackagebot progression 0.4 - Automates the recording and graphing of criterion benchmarks  http://hackage.haskell.org/package/progression-0.4 (NeilBrown)
10:27:23 <jmcarthur> so it's a special value that isn't supposed to arise in any other way?
10:28:03 <jmcarthur> well, now i see why it's a semigroup and not a monoid
10:29:04 <pchiusano> edwardk: i can explain during our next meeting, but basically, when lifting a reducer to Alignable, we want the operation of the reducer to still be associative
10:29:20 <ksf> wait you're all actually speaking about a different thing, it isn't me that can't make sense of your answers, at all...
10:29:28 <edwardk> pchiusano: yes, but you don't lose associativity even if its not commutative
10:29:35 <pchiusano> if the distinguished element doesn't commute, then that won't hold
10:29:53 <Dashkal> triyo: I don't know the answer to your question, but I would suggest browsing the haddock for the newer versions of parsec
10:30:18 <edwardk> envision such a semigroup where you're using these to track the indexes of the elements that are missing. you don't want commutativity
10:30:47 <pchiusano> edwardk: yes you do...
10:30:57 <edwardk> pchiusano: (in that case)
10:30:57 * ksf needs to wrap his head around where to put those lifted functions in that continuation mess pretending to be a state machine...
10:31:12 <pchiusano> edwardk: consider some op, + and distinguished element z
10:31:41 <pchiusano> now suppose we lift that to list
10:31:59 <zygoloid> ksf: is there a MonadFix Parsec instance?
10:32:15 <edwardk> pchiusano: so far so good
10:32:37 <pchiusano> we want (a `lifted +` b) `lifted +` c = a `lifted +` (b `lifted +` c)
10:32:44 <ksf> ...because I can, in fact, parse than thing into indistinguishable abc's and apply the Foo/Bar later.
10:32:50 <ksf> zygoloid, I have no idea
10:32:50 <edwardk> pchiusano: sure
10:33:01 <zygoloid> ksf: if you have MonadFix you can apply the Foo/Bar lazily
10:33:09 <pchiusano> edwardk: now suppose a b and c are [1], [1,2], and []
10:33:16 <interferon> @src (<*>)
10:33:17 <lambdabot> Source not found. Take a stress pill and think things over.
10:33:46 <edwardk> then its equivalent to [unit 1, z] `lifted +` [unit 1, unit 2], `lifted +` [z,z]
10:33:50 <interferon> @src (<$>)
10:33:51 <lambdabot> f <$> a = fmap f a
10:33:55 <edwardk> you need associativity, but where does commutativity enter?
10:34:03 <pchiusano> edwardk: on the left side you get [1 + 1 + z, 2 + z + z], on the right you get [1 + 1 + z, z + 2 + z]
10:34:22 <edwardk> yep
10:34:30 <pchiusano> if z doesn't commute you are hosed
10:34:37 <ksf> zygoloid, I'm not worried about writing a grammar, I'm worried about my own parser implementation.
10:34:39 <pchiusano> and the lifted + doesn't associate
10:34:42 <edwardk> z _may_ commute, but it doesn't have it
10:34:45 <edwardk> er have to
10:34:57 <ksf> ...and I don't think I'm going to have Monad, in the first place.
10:35:10 <pchiusano> edwardk: right, if you want the lifted version to associate, z has to commute
10:36:04 <edwardk> it associates, you get [1 + 1, z + 2] <+> [z, z]  or [1,z] <+> [1 + z, 2 + z] -- both of which yield the same [1 + 1 + z, z + 2 + z] regardless of the commutativity of z
10:36:40 <edwardk> the commutativity just lets you slide them all to one side or the other, which you may not need at all
10:36:58 <sshc> cabal used to take a few seconds to start up, but it doesn't anymore
10:37:05 <sshc> I wonder what changed?
10:37:09 <edwardk> i.e. if the actual indices of where the z's happened is important, not just how many of them occurred
10:37:31 <pchiusano> edwardk: not totally following...
10:38:06 <edwardk> trying again =)
10:39:04 <zygoloid> pchiusano: your statement was wrong. on the left side you get [1 + 1 + z, z + 2 + z].
10:39:49 <zygoloid> (you get [1 + 1, z + 2] `lifted +` [] == [1 + 1 + z, z + 2 + z])
10:39:51 <edwardk> using your example of [1], [1,2], [] where you want ([1] <+> [1,2]) <+> [] == [1] <+> ([1,2] <+> [1]), and where you replace missing values with z the result doesn't need commutativity to retain associativity  --- what zygoloid said ;)
10:40:15 <sshc> How do I install a cabal package entirely within a subdirectory?  How will I register / set GHC to know about them?
10:40:23 <pchiusano> zygoloid: damn you are right!
10:40:43 <zygoloid> sorry ;-)
10:40:44 <edwardk> pchiusano: that was what i was trying to say with my 'it associates' line ;)
10:41:13 <edwardk> pchiusano: then all you need is a pointed semigroup
10:41:17 <pchiusano> i totally goofed up my little calculation
10:41:33 <edwardk> and no talk of center need arise
10:42:10 <pchiusano> and it's a good thing, because I wasn't looking forward to having UniquelyCenteredSemigroup in my code!!!!\
10:42:12 <zygoloid> on the subject of fun groupy things, is there a name for a field augmented with dimensions?
10:42:28 <edwardk> zygoloid: vector space? =)
10:42:36 <sshc> What do I pass to ghc-pkg register?  
10:43:08 <zygoloid> edwardk: i don't /think/ it's a vector space. what i'm thinking of is, say, reals with SI units
10:43:16 <edwardk> zygoloid: ah
10:43:29 <zygoloid> so it's a group under multiplication (modulo the zero), and an indexed set of additive groups
10:43:41 <edwardk> zygoloid: technically each set of units _does_ form a vector space over your basic numerical type there though as well. ;)
10:43:45 <pchiusano> edwardk and zygoloid thanks for the help :) PointedSemigroup it is
10:44:00 <c_wraith> Wow.  an integer overflow bug in GHC's allocator.  nice.
10:44:03 <zygoloid> heh, true :)
10:44:34 <edwardk> zygoloid: http://github.com/bjornbm/dimensional-vectors has some unit code
10:44:42 <zygoloid> @hackage dimensional
10:44:42 <lambdabot> http://hackage.haskell.org/package/dimensional
10:44:45 <edwardk> but its not as sexy as, say, the support in f#
10:44:48 <zygoloid> ^^ there's an implementation of same here
10:45:46 <edwardk> zygoloid: ah wasn't aware he'd posted it to hackage
10:46:27 <gwern> c_wraith: I'd be curious where it came from. someone in the 90s using Int because 'who would run haskell with 60GB of ram?'
10:46:43 * edwardk is stuck trying to come up with a bunch of vector-space-like operators if he decides to commute the traversable container over his ad wrapper.
10:46:53 <c_wraith> gwern: it probably is pretty much that.
10:47:56 <sshc> I copied over .cabal from another user, but ghc on the new user isn't recognizing the packages that I copied.  How do I get GHC to know about them?
10:48:53 <c_wraith> sshc: that info is stored in .ghc
10:48:55 <edwardk> i'd need scalar multiplication *^ :: Traversable g => a -> f g a, and something similar for f g a -> f Id a -- for scalar ad variables, which since those types won't unify means two different operators
10:49:03 <c_wraith> sshc: try copying .ghc over, too
10:49:20 <edwardk> er wow those types are messed up
10:49:23 <zygoloid> sshc: i think ghc-pkg register is the other way to fix that
10:49:44 <sshc> c_wraith: Thanks!  I'll copy over .ghc
10:50:02 <sshc> zygoloid: How would I use ghc-pkg register?  I'm not sure which "filename" to pass to it
10:51:11 <zygoloid> not sure. copying .ghc seems like a better thing to try first anyway ;-)
10:51:37 <edwardk> (*^^) :: (Traversable f, Mode m, Num a) => a -> AD s m f a -> AD s m f a -- and (*^) :: (Traversable f, Mode m, Num a) => AD s m Id f a -> AD s m f a -> AD s m f a
10:52:15 <edwardk> er one more try: (*^) :: (Traversable f, Mode m, Num a) => AD s m Id a -> AD s m f a -> AD s m f a
10:53:14 <sshc> I think I've somehow broken my cabal set up.  Building cabal-install-0.8.2..     <command line>: cannot satisfy -package-id process-1.0.1.2-8b5308cb23fbdc3c2df27e298550937f:        process-1.0.1.2-8b5308cb23fbdc3c2df27e298550937f is shadowed by package process-1.0.1.2-654a7160e85e0455305ff447fa3c7eb1       (use -v for more information)
10:53:19 <zygoloid> sshc: ghc-pkg recache looks relevant too
10:54:54 <sshc> zygoloid: Thanks.  I'll run that too
10:55:19 <sshc> zygoloid: As a separate issue, I can't install cabal-install
10:55:24 <sshc> zygoloid: Or many other packages either
10:57:31 <sshc> zygoloid: ghc-pkg check: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26526#a26526
11:02:14 <andrewsw> hi, I have pprintFoo :: Foo -> IO () and would like to send that output to lpr, any advice?
11:03:02 <andrewsw> maybe just redirect to a file and then do System.system "foo_out | lpr"?
11:03:25 <andrewsw> it looks like messing around with pipes and processes is maybe a little much/complicated
11:04:40 <sclv> can you convert pprintFoo :: Foo -> String
11:04:48 <sclv> then you don't need to mess with pipes
11:04:56 <sshc> How do I fix GHC's packages?
11:05:19 <sshc> There are a lot of dependency problems.
11:05:37 <sclv> sclv: or rather, you do need to mess with pipes, but in a very simple way.
11:06:22 * ksf would make a temporary file
11:06:40 <andrewsw> sclv: I've fiddled very briefly with things like System.Process.runInteracticeProcess, but it just seems to much for such a simple task
11:06:53 <ksf> the nice thing about that approach is that you have a file that you can point the user to.
11:06:55 <sclv> some people also find it convenient to use hsh: http://hackage.haskell.org/packages/archive/HSH/2.0.3/doc/html/HSH.html
11:07:28 <ksf> there should be a safe mkTempFile function, somewhere.
11:07:51 <andrewsw> ksf: makes sense.
11:08:42 <andrewsw> hmmm... withTempFile and hDuplicateTo might be just the trick.
11:09:02 <ksf> I even tend to print with cat foo > /dev/lp0, sometimes. that is, when cups refuses to work.
11:09:24 <ksf> (/me is a proud owner of an age-old Postscript level 1 printer)
11:09:46 <ksf> 140000 pages down and still running.
11:09:58 <andrewsw> nice
11:11:13 <gwern> ksf: you've printed 140,000 pages?
11:11:20 <ksf> it takes ages to render the postscript and occasionally runs out of memory, in which case I have to use laserjet emulation, but in general the only thinkable replacement for that gem would be a darn expensive colour laser.
11:11:24 <ksf> nope, not me.
11:11:31 <ksf> I'm it's retirement home.
11:11:51 <ksf> it spend a fulfilled life of printing accounting printouts at some company or the other.
11:12:20 <ksf> epson epl-7500
11:13:17 * sproingie leaves #python for another year
11:14:21 <sproingie> the contrasts are amazing.  #haskell is probably the best thing about the haskell community.  #python may well be the worst thing for its.
11:15:04 <olsner> really? I would've thought it was Python itself...
11:17:29 <sshc> Can anybody help me solve GHC's dependency problems?  Can I reinstall cabal and all of its packages?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26526#a26526
11:17:32 <zygoloid> i've generally found python to be a pretty good fit for its niche
11:17:55 <BMeph> olsner: So, #python is the embodiment of fear? ;)
11:18:12 <andrewsw> ksf: System.Directory.openTempFile, hDuplicateTo to redirect stdout, then my Foo -> IO (), then System.system "lpr " ++ the filepath from openTempFile works a treat. thanks
11:18:18 <sclv> sshc: I'd nuke it all and do a fresh reinstall of everything.
11:18:29 * Phyx- really doesn't get why people like python
11:18:46 <gwern> so that makes 4 people in the last 24 hours that we've advised nuke their ghc because of dep problems
11:18:59 <djahandarie> Heh
11:19:07 <sclv> oddly enough I've never had to do so myself.
11:19:10 <djahandarie> gwern, does that mean it's working? :P
11:19:11 <Phyx-> gwern: I just did it a few days ago myself, my config file got corrupted
11:19:32 <sclv> But then I play nice, only install with cabal, and never unregister
11:19:42 <zygoloid> Phyx-: python's great for when you want to write a quick script that's a bit too complex for shell and a bit too trivial to write a Program
11:19:51 <duairc> Is there a function f :: Int -> String in the standard library such that f 4 = "004", f 40 = "040" and f 400 = "400"? Basically, is there a builtin way of padding zeroes to numbers?
11:19:52 <sclv> I think I learned my lesson with a bytestring mess way back when i was just getting started.
11:20:00 <gwern> djahandarie: I'd say it's more like 'it's not working'
11:20:07 <sproingie> i like python for quick web one-offs
11:20:17 <tommd> preflex: seen dons
11:20:18 <preflex>  dons was last seen on #haskell 14 hours, 24 minutes and 18 seconds ago, saying: we could just rule out anything but the latest stable. that would be fun.
11:20:28 <Phyx-> zygoloid: hm ok. guess that's one use for it
11:20:31 <gwern> duairc: I doubt it. just use show $ dropWhile (=='0')?
11:20:37 <djahandarie> gwern, I was talking about the evil plan
11:20:43 <zygoloid> plus to be fair python's builtin string handling stuff is a lot better than haskell's.
11:21:02 * zygoloid votes for a split :: String -> String -> [String] in the Prelude
11:21:07 <gwern> duairc: wait, never mind, I misread you
11:21:15 <sproingie> zomg yes
11:21:29 <sproingie> i was kind of amazed i had to get something off hackage for that
11:21:29 <gwern> duairc: your function isu nderspecified. how *many* zeroes should it be padded out to?
11:21:33 <sclv> duairc: you want a padIt :: a -> Int -> [a] -> [a]
11:21:57 <duairc> gwern: Yeah, you're right, I was just using that as an example. sclv: Yes, that's what I want. I guess I'll just write that myself.
11:21:58 <sshc> sclv: Okay.  But, how do I nuke everything? :)
11:22:02 <gwern> zygoloid: split has too many corner cases. no one could agree. I gave up
11:22:05 <sshc> I'm using Archlinux
11:22:16 <duairc> What corner cases does split have?
11:22:52 <sproingie> handling empty strings is one
11:22:59 <jmcarthur> :t printf
11:23:00 <lambdabot> forall r. (PrintfType r) => String -> r
11:23:09 <gwern> duairc: I deleted them from my mind. google for the old discussions and look at Data.Split if you really want to know
11:23:27 <sclv> padIt p i xs = reverse $ take i $ reverse $ (++ repeat p) $ reverse xs
11:23:38 <burp> replace $ by . ;)
11:23:55 <gwern> @pl padIt p i xs = reverse $ take i $ reverse $ (++ repeat p) $ reverse xs
11:23:56 <lambdabot> padIt = ((reverse .) .) . flip ((.) . take) . (reverse .) . (. reverse) . flip (++) . repeat
11:24:00 <jmcarthur> > printf "%03d" 4 :: String
11:24:01 <lambdabot>   "004"
11:24:07 <jmcarthur> > printf "%03d" 40 :: String
11:24:08 <lambdabot>   "040"
11:24:12 <jmcarthur> > printf "%03d" 400 :: String
11:24:13 <lambdabot>   "400"
11:24:17 <SonOfLilit> Hello
11:24:21 <sclv> haha or that
11:24:24 <sshc> sclv: Removing the packages ghc and cabal doesn't seem to fix the problems
11:24:32 <sshc> cabal-install, rather
11:24:36 <sshc> and reinstalling them
11:24:41 <SonOfLilit> What would be a good way to introduce myself to Category Theory?
11:24:43 <djahandarie> I wasn't there for the discussion, but I imagine... what to do with the delimeters (condense, remove, keep to the left, to the right, condense them), and what to do with blanks
11:24:55 <sproingie> SonOfLilit: take this icepick here ...
11:25:02 <gwern> SonOfLilit: read through apfelmus and sigfpe's blogs?
11:25:09 <sclv> sshc: right, because you still have your libraries directory
11:25:16 <sclv> you need to find that and clean it out too
11:25:31 <sshc> sclv: I installed most of everything by cabal install --global
11:25:32 <jabb> what's the method for writing a game which could potentially have thousands of different mutable states (enemies' pos, camera, etc)?
11:25:40 <djahandarie> SonOfLilit, if you have experience in Haskell there is a nice article on the wiki which introduces CT based on that
11:25:44 <SonOfLilit> I'm pretty good at math but not mathematician-level, and know some rigor and generalization from my engineering mat courses but never took a proper math course for mathematicians
11:25:46 <jmcarthur> jabb: they needn't be mutable ;)
11:25:49 <sproingie> jabb: ohh that's tricky.  FRP seems to be the hot topic for that
11:25:49 <sshc> sclv: WHere is the libraries directory?
11:25:56 <Remy> Hello. I am looking for a way to derive Gadts. Could someone pointme in the right direction?
11:26:11 <jmcarthur> i'm a frp guy, but i'm making a game with a state monad right now
11:26:12 <sclv> sshc: check /usr/local/lib/ghc-6.X
11:26:25 <jabb> I was considering a state monad
11:26:36 <SonOfLilit> djahandarie: define "experience in Haskell" please
11:26:37 <jmcarthur> using a state monad for a game is at worst nicer than doing a game in an imperative language ;)
11:26:38 <sproingie> there's no shame in a big Game monad
11:26:50 <SonOfLilit> btw
11:26:55 <sproingie> all your state is in one big tree in any imperative language anyway
11:26:56 <djahandarie> SonOfLilit, there is always "Category Theory for the Working Mathematician" if you have a strong background in that
11:27:00 <sproingie> you're just more explicit about it with a Game monad
11:27:02 <jabb> I've just gotten into haskell a few days ago. My brain is frying after a 48 hour crash course trying to get a grasp on monads.
11:27:04 <SonOfLilit> "don't yet" is an ok answer to my question
11:27:05 <jmcarthur> frp is theoretically much nicer, but we haven't very good frp libraries yet, IMO
11:27:07 <djahandarie> SonOfLilit, well, if you understand Monads and Functors and stuff
11:27:19 <sshc> sclv: Thanks!
11:27:29 <sproingie> jabb: try the MSDN Channel 9 series on haskell, as well as the lecture on monads
11:27:30 <sclv> hope it works :-)
11:27:33 <dons> kosmikus: around?
11:27:54 <djahandarie> SonOfLilit, don't learn category theory if you don't have a strong basis in something else. Category Theory abstracts things, and you can't learn the abstractions without knowing the things ;)
11:28:01 <jmcarthur> jabb: don't try to understand monads generally. just learn specific ones at a time. you will catch on to the more general idea as you go
11:28:10 <jabb> I think I've got a good handle on them. But more info always helps, thanks. :P
11:28:12 <Remy> Where do I go to for deriving GADTs ?
11:28:14 <jmcarthur> *specific ones one at a time
11:28:19 <sshc> sclv: The packages actually seem to be in /usr/local/lib
11:28:34 <sproingie> jabb: i'd avoid any monad tutorial from before 2005 or so
11:28:35 <sshc> sclv: binary-0.5.0.2       dataenc-0.13.0.2               hashed-storage-0.4.6  hslogger-1.0.7        libmpd-0.4.1              network-2.2.1.7          etc...
11:28:44 * BMeph votes for every person who wants something "in the Prelude" to have to personally hand-truck an edited version of the Perlude to every computer with GHC installed...
11:28:45 <sshc> sclv: Should I mkdir old and mv * old/ ?
11:28:52 <dons> kosmikus: lhs2TeX problems.  $ lhs2TeX -o hello.tex hello.lhs ; lhs2TeX: user error (File `polycode.fmt' not found in search path however /home/dons/.cabal/share/lhs2tex-1.15/polycode.fmt is there, and /home/dons/.cabal/share/lhs2tex-1.15 is in the path.
11:29:04 <dons> any other lhs2tex-ers around?
11:29:04 <jmcarthur> i'd avoid any monad tutorial
11:29:30 <sclv> sshc: try just deleting/renaming package.conf.d
11:29:31 <chipmonkpyro> hey a friend of mine is asking me a question about haskell
11:29:41 <jabb> I found "You Could Have Invented Monads" helpful
11:29:46 <chipmonkpyro> can it do a fast inverse square root?
11:29:46 <dskippy> jabb: There are a couple of good chapters on Monads in "Real-World Haskell" which is a great book at any rate. But I agree with jmcarthur to just learn one at a time. Don't try to get the whole thing at once.
11:29:47 <sproingie> a monad is a type class that defines a few operators, and those operators sort of have a common idea to them, which you'll get after using a bunch of different monads
11:30:12 <sclv> ?faq can haskell do a fast inverse square root
11:30:12 <lambdabot> The answer is: Yes! Haskell can do that.
11:30:24 <int-e> sproingie: also the type class by itself is useless
11:30:30 <sclv> @botsnack 
11:30:31 <lambdabot> :)
11:30:31 <jmcarthur> we never did snarkify @faq
11:30:41 <sproingie> ?faq can haskell do a triple-axel triple-toeloop?
11:30:42 <lambdabot> The answer is: Yes! Haskell can do that.
11:30:44 <chipmonkpyro> how would you do it?
11:30:51 <chipmonkpyro> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26527#a26527
11:30:57 <chipmonkpyro> thats the c equivalent apparently
11:31:00 <sshc> ?faq Can Haskell do this?
11:31:01 <lambdabot> The answer is: Yes! Haskell can do that.
11:31:02 <dskippy> ?faq can Haskell play hockey?
11:31:02 <lambdabot> The answer is: Yes! Haskell can do that.
11:31:09 <dskippy> Sweet!
11:31:17 <jmcarthur> chipmonkpyro: there's always the direct translation
11:31:20 <sproingie> int-e: not useless, it describes the overall shape of a monad.  just too abstract to grok til one's used a few different ones
11:31:21 <SonOfLilit> djahandarie: I never wrote a custom monad, and never used a functor that isn't a function or a monad
11:31:22 <jabb> I tried to write my own transformer last night. Failed on the lift method. :(
11:31:26 <int-e> sproingie: in the sense that there aren't any useful functions of type Monad m => a -> m b for any b.
11:31:29 <SonOfLilit> I know the concepts, though
11:31:45 <chipmonkpyro> i dont know c so can you translate for me?
11:32:07 <chipmonkpyro> he bet me 100 bucks haskell couldnt do it :p
11:32:20 <jmcarthur> lol
11:32:25 <sclv> for a hundered dollars, i'd learn a little c :-)
11:32:27 <sproingie> being turing complete it can do anything you throw at it given enough cpu and ram
11:32:43 <jmcarthur> ew, casts float to integer
11:32:49 <benmachine> chipmonkpyro: the question is, how fast
11:32:51 <sclv> this is the famous carmack inverse
11:33:00 <benmachine> yes
11:33:06 <jabb> yeah
11:33:07 <sclv> http://en.wikipedia.org/wiki/Fast_inverse_square_root
11:33:19 <c_wraith> It predates carmack.  There's actually a pretty good page researching the history of it
11:33:27 <benmachine> the version I have reads
11:33:28 <benmachine>         t.i  = 0x5f3759df - ( t.i >> 1 );               // what the fuck?
11:33:33 * BMeph thinks that people's having problems trying to code a game in Haskell after a week of "learning" it says more about the other languages they know than about Haskell...
11:33:46 <benmachine> I think the comment makes it faster
11:33:55 <lispy> BMeph: what is this in ref to?
11:34:01 <lispy> benmachine: haha
11:34:02 <int-e> sproingie: I guess my point is that you almost never work with monads in full generality (because, what's the point?) - you usually have more restrictions translating to additional operations.
11:34:17 <lispy> benmachine: if they really cared about performance they'd throw in a duff's device for good measure too ;)
11:34:20 <chipmonkpyro> can you do fast inverse square root in haskell is basically my question
11:34:22 <djahandarie> SonOfLilit, you can try http://en.wikibooks.org/wiki/Haskell/Category_theory
11:34:37 <benmachine> lispy: /me melts brain
11:34:37 <mauke> chipmonkpyro: give me a second, I'll try to translate that C code to haskell
11:34:52 <sproingie> that you might not be able to do in pure haskell
11:35:04 <lispy> Hmm...I bet we could code up a duff's device in Haskell via continuations
11:35:06 <sproingie> doesn't it rely on bitwise ieee float representation?
11:35:10 <FunctorSalad_> int-e:  hmm, there are important monad-general functions, but they've mostly all been done I guess (mapM, sequence, liftM* and so on)
11:35:15 <djahandarie> SonOfLilit, and then http://blog.sigfpe.com/2010/03/partial-ordering-of-some-category.html
11:35:17 <sshc> You could use the ST monad
11:35:19 <ksf> oh I know that function
11:35:23 <benmachine> chipmonkpyro: you can easily use the C function from haskell, if that counts
11:35:28 <sclv> c_wraith: right. I just meant that it was famously known as the carmack inverse.
11:35:32 <ksf> curtesy of id software.
11:35:59 <sclv> If we named mathy things after the people who actually invented them, then all our terminology would go poof!
11:36:07 <ksf> getting the bits out of the float and in again might prove tricky
11:36:36 <c_wraith> time for unsafeCoerce!
11:36:50 <chipmonkpyro> so can it be done or not >.>
11:36:53 <ksf> nope
11:36:55 <sclv> yes
11:37:01 <mauke> yes, just ignore me
11:37:03 <sclv> but i'm not going to bother
11:37:07 <int-e> unsafeCoerce C :: Haskell? Oh wait, that's called FFI.
11:37:12 <c_wraith> :t unsafeCoerce :: Int# -> Float#
11:37:13 <lambdabot> Not in scope: `unsafeCoerce'
11:37:13 <lambdabot> Not in scope: type constructor or class `Int#'
11:37:13 <lambdabot>     Not in scope: type constructor or class `Float#'
11:37:16 <ksf> I tried that, hit a bug, and got the reply "well that's an unsafe use of unsafecoerce" in the trac
11:37:18 <jmcarthur> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26527#a26528  maybe?
11:37:34 <c_wraith> heh?  Well, almost every use of unsafeCoerce is unsafe. :)
11:37:43 <ksf> and you'd want to cast to Word32
11:38:00 <lispy> sclv: like Bernouli's Rule?  Oh, most people know it as L'Hopital's(sp?) since he bought the IP from Bernouli :)
11:38:01 <gwern> c_wraith: I dunno. haskell compiled from coq/agda or whatever uses unsafeCorces so liberally it probably outweighs every other usage
11:38:02 <int-e> c_wraith: bad idea - you may mess up the code generator that way (mixing different kinds of registers, IIRC).
11:38:03 <sclv> you can just unsafeCoerce the Int to the Float, and then get the primitive, no?
11:38:04 <sproingie> unsafeCoerce is unsafe.  icanhazhaskell?
11:38:15 <ksf> it might work on primitive types, though.
11:38:52 <c_wraith> I'd *hope* unsafeCoerce works on primitive types of the same size...
11:39:02 <mauke> ok, now I need some test values
11:39:03 <jmcarthur> i wouldn't rely on it. i don't like my code
11:39:05 <Phyx-> @type intercalate
11:39:06 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:39:17 <dons> kosmikus: fixed. no read permissions to the lhs2TeX share directory
11:39:24 <BMeph> lispy: I mean to imply that spending a week on a language isn't enough time to "really" learn it, and the person is simply copying the same program, just making syntax adjustments.
11:39:57 <lispy> BMeph: I 100% with you.  I was just wondering what prompted you to say it?  Was there a high profile blog post or something?
11:40:03 <jmcarthur> i don't like unsafeCoerce for anything that isn't just manual type unification... and i've never had to do it myself, although i have seen it done
11:40:49 <int-e> Ah right, I should've known. Couldn't match kind `#' against `*'
11:41:28 <mauke> chipmonkpyro: http://codepad.org/CEFwpy0i
11:41:42 <jmcarthur> probably the "best" way to translate that would be to use Ptrs with castPtr or some other ugliness like that
11:41:42 <chipmonkpyro> does it work?
11:41:51 <mauke> chipmonkpyro: does the output look ok?
11:41:58 <jmcarthur> ah, like that
11:42:36 <jmcarthur> that is probably slower than the C version though
11:42:57 <mauke> don't care, it does exactly what the C code does
11:43:08 <mauke> hence answering the question "can Haskell do this?"
11:43:09 <BMeph> lispy: "jabb"'s comment a half-hour ago: ":25] <jabb> what's the method for writing a game which could potentially have thousands of different mutable states (enemies' pos, camera, etc)?"
11:43:26 <jmcarthur> yup
11:43:39 <jmcarthur> i agree with the implementation
11:43:39 <lispy> BMeph: and you pointed him/her at the Frag source right? :)
11:43:57 <sclv> mauke: nice. very straightforward.
11:44:33 <jmcarthur> it's better than mine
11:44:58 <sclv> jmcarthur: yours works fine, I think, if you switch shift to shiftR
11:45:02 <jmcarthur> chipmonkpyro: enjoy your $100
11:45:13 <sclv> but mauke's is more principled
11:45:17 <jmcarthur> sclv: ah! i didn't bother looking it up, so i wasn't sure
11:45:24 <jmcarthur> sclv: right. that's why mauke's is better
11:45:57 <BMeph> I've noticed the behavior many times in the past few months - heard about this new language Haskell, so want to write a game in it after learning it in a few days...
11:46:01 <sclv> although in a principled smackdown between unsafeCoerce and unsafePerformIO/castPtr...
11:46:16 <dskippy> mauke: Why use CTypes and unsafePerformIO?
11:46:18 <BMeph> lispy: (see my last coment, above.)
11:46:33 <Phyx->  does anyone here know the unicode character for bottom?
11:46:36 <sclv> dskippy: it means the translation is very direct
11:46:39 <jmcarthur> dskippy: it's more faithful to the C version
11:46:39 <dskippy> mauke: Oh wait I know why you used C types. the shift.
11:46:47 <mauke> sclv: unsafeCoerce relies on ghc internals, the unsafePerformIO is actually safe there, and the castPtr works as long as the C version works :-)
11:47:01 <mauke> dskippy: what?
11:47:13 <jmcarthur> the shift isn't really the reason at all
11:47:43 <sclv> mauke: I agree. The fact that the representation of CInt and CFloat ties together is almust just dumb luck.
11:47:50 <dskippy> mauke: This code is doing some bitwise operations. I thought maybe that was the reason to require CTypers since they need to have the same bit structure to work.
11:48:19 <mauke> yes, but shiftR doesn't rely on the internal structure
11:48:29 <dskippy> mauke: Ah.
11:48:31 <jmcarthur> dskippy: well, this has the advantage that whatever pros and cons the C version has, the haskell version also has, so it's to spec
11:48:41 <jmcarthur> dskippy: haskell's Float and Int types are not required to be like C's
11:48:57 <dskippy> jmcarthur: Sure. You're trying to convert exactly.
11:49:38 <ccasin> I often want a monad combinator like "when" but for MonadPlus so it can compute an actual value, like this:
11:49:40 <wli> Use CInt and CFloat?
11:49:40 <ccasin> whenP :: MonadPlus m => Bool -> m a -> m a
11:49:41 <dskippy> mauke: jmcarthur: I imagine this is pretty easy to write in pure Haskell without unsafeIO or pointers or CTypes and likely not much slower? Am I wrong here? 
11:49:46 <ccasin> Am I missing something in the stdlib?
11:49:55 <jmcarthur> dskippy: the cast is the hard part
11:50:31 <jamwt> hey all.. long time programmer, just been getting serious about haskell for the last 6-9 months
11:50:32 <dskippy> Ah. Hm.
11:50:53 <jmcarthur> ccasin: i don't think you are missing anything. i agree that should be put in though
11:51:03 <jamwt> I wrote a short program called "Angel", which is a daemontools replacement (service management/restarts)
11:51:06 <jamwt> http://github.com/jamwt/Angel
11:51:11 <BMeph> ccasin: Looks like you're missing some explanation in the IRC channel... ;)
11:51:27 <jamwt> very much interested in feedback anyone has, b/c I'm still feeling out idioms, etc
11:51:52 <jmcarthur> jamwt: any particular portion of code?
11:51:59 <jamwt> esp in http://github.com/jamwt/Angel/blob/master/Angel/Job.hs , couldn't find a good way to break up that `supervise` monad
11:52:05 <jmcarthur> i'm willing to review a small part, but i need to work ;)
11:52:15 <delusion42> Anyone willing to help me out with a monadic iteratee implementation? I'm stuck on making a Monad instance: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26525 
11:52:23 <ccasin> jmcarthur: thanks, good to know I'm not crazy
11:52:25 <monoidal> ccasin: for () there's guard
11:52:33 <jamwt> jmcarthur: done a fair bit of ML, so I'm relatively comfortable where pure functions are involved
11:52:40 <jmcarthur> jamwt: i don't see a monad there. do you mea the supervise function?
11:52:43 <jmcarthur> *mean
11:53:07 <ccasin> monoidal: yes, sadly I actually want to compute things.  This comes up a lot (for me) when working with the maybe monad
11:53:25 <jamwt> jmcarthur: maybe I did
11:53:32 <jamwt> it's IO ()
11:53:54 <jmcarthur> jamwt: IO is a monad. a function that gives an IO action as a result is not
11:54:01 <gwern> > 86400 / 65536
11:54:02 <lambdabot>   1.318359375
11:54:21 <jamwt> jmcarthur: yep, makes sense
11:54:49 <Palmik> Hi guys... I have this code, which seem to work fine, but when I try to alter it using Maybe and Just instead of using error, I get error :D http://codepad.org/29PlhRcj could you look at it please? This is the error I get http://codepad.org/prj2n5X8 it seems like I'm tring to pass more then one argument ot the Just, but it's wrapped in parenthesis
11:55:04 * wli just can't stop missing ML modules in Haskell
11:55:12 <jmcarthur> jamwt: eep. that is indeed a very complex function
11:55:32 <jamwt> yes, I agree :-)
11:55:46 <jamwt> while it works, it ain't pretty 
11:55:53 <jmcarthur> jamwt: IO is difficult to refactor for the same reason that many imperative programs are, but fortunately a lot of the refactoring knowledge you may have from imperative languages also applies here
11:56:37 <monoidal> Plamik: you've got where direction = getDirection... so direction :: Maybe [Direction]
11:56:40 <monoidal> *Palmik
11:56:59 <gwern> :t maybe
11:57:00 <monoidal> and you're adding Maybe [Direction] using (++)
11:57:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:57:14 <jmcarthur> jamwt: in haskell we fortunately at least have a separation between the concepts of evaluation and execution, so you can capitalize on that sometimes to clean things up. i'm not sure how much that helps here though
11:57:26 <gwern> > maybe False (isEven) (Just 9)
11:57:27 <lambdabot>   Not in scope: `isEven'
11:57:31 <Palmik> monoidal, will try to adjust the code
11:57:37 <jmcarthur> you seem to have already capitalized on that fairly well
11:57:38 <Palmik> thanks
11:57:43 <jamwt> jmcarthur: I did try
11:57:50 <jamwt> originally, this was all one huge funciton
11:58:01 <jamwt> and I split out the parts in the `where`
11:58:03 <BMeph> ccasin: What are you computing? Can't you just use 'whenP = (>>).guard'?
11:58:19 <jamwt> but couldn't find a natural place to break the body up even more
11:58:35 <jamwt> some b/c of scoping reasons, it seemed
11:58:45 <jamwt> with the atomically stuff
11:58:53 <jamwt> (STM work)
12:00:50 <ccasin> BMeph: oh, wonderful - I misunderstood guard.  Thanks (and also monoidal, who I misunderstood)
12:00:54 <jmcarthur> jamwt: honestly, i think some syntactic cleanup would be the best start, and may be all you can do with it (without some domain knowledge that i don't have, that's all i can really say, i think)
12:01:01 <harej> What are haskell programmers called?
12:01:09 <p_l|backup> haskellers ?
12:01:10 <monoidal> Palmik: try case getDirections ((Point2D (x2, y2)):(Point2D (x3, y3)):points))) of Nothing -> Nothing; Just d -> Just (direction:d)
12:01:11 <wli> Haskellers
12:01:11 <jmcarthur> haskellers? haskellites?
12:01:20 <jmcarthur> i normally say haskellers
12:01:24 <jamwt> jmcarthur: yeah.. well, thanks for looking it over
12:01:27 <delusion42> hasks ;P
12:01:30 <sclv> "real programmers"
12:01:44 <sclv> developers over the category of hask
12:01:46 <jamwt> jmcarthur: I'm still trying to master those syntactic conventions too, like indentiation with do blocks, etc
12:01:57 <monoidal> Palmik: which you can also write using fmap
12:02:19 <jamwt> seems like they'll often be started far left of the `do`, which would be great b/c I hate how far over everything is pushed right now
12:02:44 * wli hasn't noticed syntax being an issue since 1998 or so.
12:02:47 * BMeph fancies "Haskelliers"
12:02:59 <EvanCarroll> Why doesn't this work, let a = ( case a of { True -> False } )
12:03:01 <EvanCarroll> a True
12:03:02 <jmcarthur> jamwt: yead, it's hard to read squished all the way over there
12:03:02 <sclv> you don't want to use otherwise in case
12:03:06 <sclv> otherwise is for guards
12:03:09 <jamwt> yup
12:03:13 <sclv> change it to a "_"
12:03:28 * BMeph likes "Haskellians" as a second choice
12:03:30 <wli> case alternatives can take guards too
12:03:32 <jamwt> I'm principally a python programmer, so I care about these things :-)
12:03:49 <jmcarthur> *yeah
12:03:52 <monoidal> otherwise in a case is a bit strange, it matches to a variable called "otherwise" and shadows otherwise = True
12:03:55 <djahandarie> EvanCarroll, maybe you are looking for a x = case x ...
12:03:57 <mauke> EvanCarroll: because False is not a function
12:03:58 <sclv> log can also be floated out to the where clause
12:04:00 <jmcarthur> heh
12:04:32 <wli> case whatever of { Left p | myCheck p -> True | otherwise -> False ; Right q | myCheck2 q -> True | otherwise -> False }
12:04:48 <sclv> two line do blocks can be written inline like: log "thing" >> doThing
12:05:07 <mauke> do log "thing"; doThing
12:05:15 <jmcarthur> err
12:05:26 <jmcarthur> do { log "thing"; doThing }
12:05:31 <mauke> too verbose
12:05:33 <jmcarthur> you can't use ; without {}, can you?
12:05:37 <mauke> sure you can
12:05:46 <jmcarthur> @undo do log "thing"; doThing
12:05:47 <lambdabot> log "thing" >> doThing
12:05:49 <jmcarthur> oh
12:05:51 <Palmik> monoidal, hmm... I do not quite get that... why is not the Just enought?
12:05:56 <jmcarthur> i never use ;
12:06:25 <monoidal> Palmik: you have to check if recursive call of getDirections returned Nothing or Just x
12:06:39 <EvanCarroll> djahandarie++ #tanks
12:06:42 <EvanCarroll> thanks*
12:06:54 <monoidal> Palmik: and if it is Nothing, you have to pass it
12:07:08 * jmcarthur wonders if #tanks exists and who goes there ;)
12:07:22 <sclv> jamwt: you probably also want an ifEmpty combinator :: String -> a -> a -> a
12:07:23 <monoidal> Palmik: when using "error", the exception is automatically passed up recursion stack
12:07:27 <Palmik> monoidal, aah, that gives sense :) But it seems rather ugly
12:07:28 <djahandarie> jmcarthur, it's only a command away ;-)
12:07:49 <monoidal> Palmik: you can use fmap to do it nicely (or monads)
12:08:23 <Palmik> monoidal, I'm not that far yet, but I'm looking forward to them already :D
12:08:24 <monoidal> Palmik: for example, try: do x <- Just 5; y <- Just 4; return (x+y) will return Just 9
12:08:55 <jamwt> sclv: instead of the case statement?
12:08:57 <monoidal> Palmik: and if you change one of the Justs to Nothing, it will give you Nothing as the whole result
12:09:02 <jmcarthur> > liftA2 (+) (Just 5) (Just 5)
12:09:03 <lambdabot>   Just 10
12:09:07 <jmcarthur> > liftA2 (+) (Just 5) Nothing
12:09:08 <lambdabot>   Nothing
12:09:11 <jmcarthur> :D
12:09:21 <jamwt> that makes sense
12:09:46 <jamwt> sclv: I tried floating log to the where clause, seemed to recall it not working.. I thought it was some odd scoping thing
12:09:49 <jmcarthur> yeah i find that it's usually pretty nice to factor out case statements when i can
12:09:49 <jamwt> I'll try again though
12:09:50 <monoidal> Palmik: you can shorten your code
12:10:15 <jamwt> jmcarthur: yeah, I'm all for combinators when I see 'em
12:10:20 <jamwt> still getting used to the pattern though, but I dig it
12:10:51 <monoidal> Palmik: getDirections ((a,b,c):points) = let d = getDirections points in case d of Nothing -> Nothing; Just x -> Just ((getDirection a b c):d)
12:11:05 <monoidal> you don't have to match on coordinates if you don't use them
12:11:49 <Palmik> monoidal, hmm, nice :D
12:11:53 <monoidal> that can be written as fmap ((getDirection a b c):) (getDirections points)
12:12:19 <monoidal> fmap takes a function a -> b and "lifts" it into Maybe a -> Maybe b
12:12:24 <edwardk> harej: I'm partial to "Gods among men," but Haskellers is good too
12:12:36 <monoidal> in general, it works also on lists (like map) and other "containers" (called functors)
12:12:46 <Palmik> monoidal, hmm... that might come in handy :)
12:13:02 <Palmik> thanks :)
12:13:43 <BMeph> I like "Haskellians" because it's suggestive of "Hask-aliens" which somewhat tips the hat to Lisp's "alien technology" blurb.
12:15:37 <mauke> Haskelhoffs
12:16:32 * hackagebot yesod 0.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.3.1 (MichaelSnoyman)
12:16:57 <jmcarthur> don't haskell the hoff
12:21:01 <gwern> xmonad is 3 years old now
12:21:41 <tommd> Humm, must be no good - we need to find something newer.
12:23:00 <gwern> let's all switch to awesome
12:26:20 <sclv> areo
12:27:54 <brad_larsen> Are there any languages out there that allow one to easily define new list-like functions/syntax, e.g. <a, b, c, d>?
12:27:59 <Dashkal> someone should write haskell bindings to KDE's plasma :P
12:28:09 <brad_larsen> that is, with a particular start & stop token, and a separator token.
12:28:47 <kmc> Coq does
12:29:02 <kmc> let's write a new window manager in Agda
12:29:30 <brad_larsen> kmc: do you have more information on what new list-like ops in Coq look like?
12:29:34 <kmc> so
12:29:35 <kmc> no*
12:29:38 <brad_larsen> ok
12:29:50 <djahandarie> Do not try and use Coq if you're trying to do something practical.
12:29:59 <jmcarthur> agdawm
12:30:18 <sclv> I think this would typically be done with a preprocessor
12:30:33 <sclv> camlp4, e.g.
12:30:37 <brad_larsen> bah, preprocessors ;-)
12:30:37 <tafryn> Why would adding 'import qualified Data.Map as M' to a module cause ghc to throw an 'undefined reference to...' error?
12:30:41 <sclv> or quasiquotation
12:30:53 <edwardk> brad_larsen: you can do so in various schemes/lisps
12:30:55 <gwern> tafryn: because Map is in contaIners and you aren't using --make?
12:31:30 * gwern is just guessing
12:31:50 <tafryn> gwern: That appears to be it.
12:32:21 <kmc> if you run ghc by hand, you should almost always use --make
12:32:28 <kmc> it should probably be the default mode
12:32:42 <djahandarie> It definitely should be, I always forget to specify that
12:32:46 <tafryn> Is there a way to do by hand what --make does automatically?
12:33:01 <kmc> yes
12:33:14 <kmc> you have to know your dependencies, and build them all with ghc -c
12:33:19 <kmc> then you have to know what packages you need
12:33:31 <kmc> and build it with like ghc -o myprog foo.o bar.o -package mtl -package acme-now
12:34:15 <edwardk> or just learn to love cabal and never run ghc directly again. ghci maybe ;)
12:34:25 <kmc> one use case would be integrating ghc into an existing makefile system
12:34:34 <tafryn> So I'd need to do something like 'ghc -package map main.hs'?
12:34:41 <kmc> -package containers
12:34:45 <gwern> no, Data.Map is in containers, I said
12:34:52 <tafryn> Ah.
12:34:54 <kmc> a package holds a set of modules
12:35:02 <kmc> the name of the package and the names of the modules need not be related
12:35:24 <djahandarie> I'd say they should be *related*, just not the same. :P
12:35:30 <mauke> also, the package name is in the symbols
12:35:35 <kmc> packages are listed at http://hackage.haskell.org/packages/archive/pkg-list.html
12:35:50 <mauke> if you want to demangle symbol names, we have a bot for that
12:36:51 <tafryn> Why does ghc leave the intermediate files around after compilation?
12:37:02 <kmc> the .hi files?
12:37:04 <ksf> can I get the Dec out of a VarI I reified?
12:37:04 <gwern> in the name of efficiency
12:37:08 <tafryn> .hi and .o
12:37:08 <mauke> because it might need them later
12:37:12 <kmc> in case you need to link more stuff against those files
12:37:18 <ksf> it seems to be deliberately set to Nothing
12:37:38 <gwern> tafryn: if it bothers you, I have an open ghc bug asking for a flag which causes ghc to remove its intermediates
12:37:53 <tafryn> gwern: Where do I sign up?
12:37:58 <gwern> it's on the trac
12:38:00 <ksf> @hoogle Info -> a
12:38:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:38:00 <lambdabot> Prelude id :: a -> a
12:38:01 <lambdabot> Data.Function id :: a -> a
12:38:32 <djahandarie> @hoogle Info
12:38:32 <lambdabot> module System.Info
12:38:32 <lambdabot> Language.Haskell.TH data Info
12:38:32 <lambdabot> Language.Haskell.TH.Syntax data Info
12:38:59 <sclv> I appreciate the unsafeCoerce function. Very helpful
12:39:02 <kmc> you can also make it output files in Haskell AST, Core, STG, Cmm, C, assembly, LLVM, etc
12:39:05 <sclv> s/function/suggestion
12:39:09 <mreh> have we got an efficient *and* lazy way to shuffle a list?
12:39:21 <kmc> @google oleg perfect shuffle
12:39:22 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
12:39:25 <ksf> ...or is there a special moon phase I need to wait for so that the Nothing becomes a Maybe?
12:39:35 <gwern> oleg's shuffle is perfect, but is it efficient or lazy?
12:39:43 <mreh> kmc: don't I have to load the whole list into a tree
12:39:49 <kmc> i don't know
12:39:50 <gwern> also, oleg's shuffle should be up on hackage
12:40:00 <mreh> gwern: I've done it if you want it
12:40:04 <gwern> thought so
12:40:08 <djahandarie> @hoogle shuffle
12:40:08 <lambdabot> No results found
12:40:12 <djahandarie> Damn, I swear that was it
12:40:25 <djahandarie> http://hackage.haskell.org/package/random-shuffle-0.0.2
12:40:34 <djahandarie> Hoogle needs to stop sucking
12:40:38 <ksf> TH is _seriously_ underdocumented
12:40:41 <mreh> +1
12:40:44 <kmc> yes
12:40:51 <kmc> also underimplemented
12:40:57 <ksf> that, too.
12:41:17 <tafryn> gwern: Slated for milestone 6.16.1 :(
12:41:41 <gwern> tafryn: vote with your cc
12:44:20 <dv-> why does hackage take minutes to load?
12:44:32 <kmc> i'm having probs too
12:44:33 <ksf> @hoogle Name ->
12:44:33 <lambdabot> Parse error:
12:44:33 <lambdabot>   --count=20 "Name ->"
12:44:33 <lambdabot>                     ^
12:44:35 <ksf> @hoogle Name -> a
12:44:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:44:35 <lambdabot> Prelude id :: a -> a
12:44:35 <lambdabot> Data.Function id :: a -> a
12:44:43 <ksf> that's not helpful.
12:44:52 <dv-> It's been this way since that hacking thing was resolved
12:44:55 <dv-> It's ass slow
12:45:00 <ksf> @hoogle Language.Haskell.TH.Name -> a
12:45:00 <lambdabot> Parse error:
12:45:00 <lambdabot>   --count=20 "Language.Haskell.TH.Name -> a"
12:45:00 <lambdabot>                      ^
12:45:56 <orlandu63> @hoogle TH
12:45:56 <lambdabot> module Language.Haskell.TH
12:45:57 <lambdabot> Text.Html th :: Html -> Html
12:45:57 <lambdabot> Text.XHtml.Frameset th :: Html -> Html
12:46:10 <ClaudiusMaximus> @hoogle Name -> a +template-haskell
12:46:11 <lambdabot> Language.Haskell.TH ConE :: Name -> Exp
12:46:11 <lambdabot> Language.Haskell.TH VarE :: Name -> Exp
12:46:11 <lambdabot> Language.Haskell.TH.Syntax ConE :: Name -> Exp
12:46:44 <ClaudiusMaximus> @hoogle shuffle +random-shuffle
12:46:44 <lambdabot> Could not find file:
12:46:44 <lambdabot>     random-shuffle
12:46:45 <lambdabot> Searched:
12:48:12 <ksf> the web interface isn't returning anything for Name -> a +template-haskell
12:52:21 <mreh> lots of allocation doesn't necessarily mean a function has blown the stack right? it could all be heap allocation
12:52:50 <kmc> yeah
12:53:11 <kmc> stack overflow would happen with pattern-matches which are deeply nested at runtime
12:53:33 <kmc> case (case (case ... of ...) of ...) of ...
12:54:20 <sshc> I'm trying to configure a local cabal package by running ./Setup.hs, but it's not seeing any packages I have installed locally (not with --global flag) installed as the same user.
12:55:16 <sshc> How do I set up cabal (./Setup.hs) to recognize the packages that I've locally installed?
12:57:10 <benmachine> sshc: Setup.hs configure --user
12:57:12 <benmachine> iic
12:57:14 <benmachine> *iirc
12:57:33 <ninechars> ksf: I got a pretty good grasp of it from reading the original and followup papers (which are quite readable) and the couple of tutorials linked from the wiki; for API docs there's a bit of it as comments in the code (which don't show up in the html docs) if you click the 'source' links
12:57:39 <ninechars> (you may or may not have already known all of this)
12:57:50 <sshc> benmachine: That worked, thanks!
12:58:21 <benmachine> sshc: notice that all the Setup.hs subcommands have their own --help as well :)
12:58:35 <sshc> Warning: This package indirectly depends on multiple versions of the same    package. This is highly likely to cause a compile failure.  
12:58:48 <sshc> One package requires parsec-2.1.0.1, and another requires parsec-3.1.0
12:59:09 <ksf> hmm do you know when and if the Dec Field of VarI is not Nothing?
12:59:10 <sshc> There doesn't seem to be anything I can do about this
12:59:18 <sshc> Can I ignore it?
12:59:23 <sclv> sshc -- for parsec that doesn't generally matter
12:59:28 <ksf> I was hoping to be able to get at the definition of stuff by its name...
12:59:37 <sshc> sclv: Okay
12:59:45 <Saizan> sshc: you can just continue with "cabal build && cabal install --only"
13:00:18 <sclv> anything you build using user packages can of course itself only be installed as a user package
13:00:30 <mreh> :t iterate
13:00:31 <lambdabot> forall a. (a -> a) -> a -> [a]
13:00:31 <sshc> Can I hide this warning, since what it's warning about apparently isn't an issue in this case?
13:01:06 <illissius> ksf: it has this in the comments:  -- Nothing for lambda-bound variables, and  -- for anything else TH can't figure out -- E.g. [| let x = 1 in $(do { d <- reify 'x; .. }) |]
13:01:21 <illissius> i don't know anything more than that :)
13:01:35 <ksf> I'd be content with top-level decls, but it doesn't work
13:03:37 <ksf> ...I was hoping to get around data-reify by using it, but it seems that's not quite possible.
13:04:16 <sshc> Huh.  ./Setup.sh build (which doesn't have a --user flag) is failing: Setup.hs: can't find source for Command in ., dist/build/autogen
13:04:23 <ksf> ...the problem with data-reify being that it wrecks havoc on the typing I'm trying to do.
13:04:28 <mreh> uh-oh, the games industry has started advertising on television for programming courses
13:04:35 <mreh> off-topic
13:05:07 <Saizan> sshc: --user has to be given only to configure
13:05:15 <ksf> otoh, I could generally write all the expressions in quotations.
13:05:23 <aristid> mreh: i doubt that will be very successful
13:05:24 <Saizan> sshc: do you have the source for Command in those directories?
13:05:25 <sshc> Saizan: I see
13:05:34 <ksf> (which would be rather ugly, I think)
13:05:35 <benmachine> mreh: uhoh?
13:05:38 <illissius> ksf: i haven't done all that much with TH yet so... :\
13:05:53 <illissius> I also looked at data-reify once I think and couldn't figure out wth it did
13:06:39 <sshc> Saizan: I have Command.hs along with every other source file
13:07:09 <Saizan> sshc: in a subdir?
13:07:45 <sshc> Oh, there was a typo in the filename.
13:08:40 <heiz> Hi! Does anyone know any examples of using Language.Haskell.Preprocessor?
13:08:41 <djahandarie> Is there something for handling an unreliable handle? (i.e., getting disconnected/reconnecting, making sure messages get to the destination, etc)
13:09:00 <sshc> The LINE pragma seems to cause GHC's line counting to be off by one
13:09:12 <sshc> Saizan: Thanks for your help!
13:09:22 <Saizan> sshc: np :)
13:11:50 * ksf considers getting rid of applicative and doing a custom quoted syntax
13:12:10 <ksf> ...which nicely resolves _all_ recursion etc. problems.
13:12:41 <Saizan> basically, you're going to make a new yacc rather than a new parsec?:)
13:12:54 <ksf> that was the plan all along.
13:13:31 <ksf> ...at least providing the option to compile at compile-time, that is.
13:13:53 <kmc> just write a supercompiler instead ;)
13:14:20 <ksf> you've got a point, there.
13:14:30 <ksf> I should go and see what supero does to my code.
13:14:31 <sshc> What are the standard regex libraries used?
13:14:35 <heiz> Does anyone know any examples of using Language.Haskell.Preprocessor?
13:14:43 <Saizan> use epic which has directed partial evaluation :)
13:15:03 <ksf> but I don't think it can do any of the more fancy transformations
13:15:41 <ksf> ...and doing them is crucial to prevent backtracking and lookahead
13:15:59 <Saizan> heiz: no, though if you have a specific problem we could try to help
13:16:15 <ksf> that is, there won't be a parsing function to call if they're not done
13:16:54 <ksf> and I need access to the grammar if I want to do those on explicit kleene stars, which are necessary to make the code finite.
13:17:22 <ksf> (infinite deterministic automata isn't a term I think)
13:18:24 <Gracenotes> @pl \x -> maybe x id (f x)
13:18:24 <lambdabot> ap (flip maybe id) f
13:18:54 <Gracenotes> oh. *headdesk*
13:19:10 <Gracenotes> fromMaybe <*> f is nicer
13:22:43 <Gracenotes> on the note of squeezing every last drop out of syntax, if I have to write another \x -> x { y = f (y x) }... :/
13:22:51 <sshc> Which regex library behaves most similarily to the regex of vim?
13:23:59 <mauke> feature or syntax wise?
13:24:47 <Twey> Gracenotes: You need more fc-labels
13:26:14 <sshc> mauke: Both.  Out of the regexes, I'm most familiar with vim's.  I'm probably going to learn posix regex and use rege-posix.
13:26:28 <mauke> posix is like the worst of all worlds
13:26:46 <mauke> syntax-wise, I know nothing that's really similar to vim
13:27:13 <mauke> it's like a huge superset of posix "basic" regexes
13:27:53 <sshc> mauke: How is posix bad?
13:27:57 <mauke> for features, you probably want something that imitates perl
13:28:14 <sshc> mauke: Which regex would you suggest I use?
13:28:55 <mauke> sshc: two incompatible regex standards, weird matching behavior, limited feature set
13:29:13 <mauke> I don't know the available libraries in Haskell
13:29:25 <mauke> most of them suck (probably)
13:29:40 <sshc> mauke: cabal list regex reports:
13:30:05 <sshc> mauke: regex-base regex-compat regex-dfa regex-parsec regex-pcre regex-pcre-builtin regex-pderiv regex-posix regex-posix-unittest regex-tdfa regex-tdfa-utf8 regex-tre regex-xmlschema regexpr
13:30:28 <sshc> mauke: regexpr is "regular expression like Perl/Ruby"
13:30:37 <mauke> well, which is it?
13:31:15 <mauke> first question: how many of those can cope with '\0' in the pattern?
13:33:10 <andreo> i've installed HDBC package (cabal install HDBC). Why does 'import Database.HDBC' fail?
13:33:13 <andreo> Prelude> :module Database.HDBC
13:33:13 <andreo>  
13:33:13 <andreo> <no location info>:
13:33:16 <andreo>     Could not find module `Database.HDBC':
13:33:19 <andreo>       it is not a module in the current program, or in any known package.
13:33:22 <andreo>  
13:34:15 <lispy> andreo: for pastes over 2-3 lines it's best to use a pastebin.  As for your question, I'm not sure
13:34:38 <lispy> andreo: have you told ghci to load the package hdbc?
13:34:53 <lispy> andreo: if you type, ghc-pkg list hdbc, is it listed?
13:34:58 <max_atreides> andreo: :m +Database.HDBC
13:35:31 <max_atreides> andreo: oh, nevermind
13:36:29 <Twey> Second question: how many of those can match ‘concat $ concatMap (replicate 100) ["a?", "a"]’ before the heat death of the universe?
13:36:49 <andreo> ghc-pkg list HDBC
13:36:50 <andreo> /var/lib/ghc-6.12.1/package.conf.d
13:36:50 <andreo> /home/andreo/.ghc/i386-linux-6.12.1/package.conf.d
13:36:50 <andreo>    HDBC-2.2.6
13:36:51 <billyrong> to use cabal, should I use apt-get install cabal-install? (ubuntu 10.04) thx!
13:36:53 <andreo>  
13:37:18 <andreo> lispy: installed
13:37:20 <Twey> billyrong: To use cabal-install (which provides the ‘cabal’ command), yes
13:37:40 <mauke> Twey: that's much less interesting because you'd never write such a pattern
13:38:44 <jabb> I'm always worried I'll cause a stack overflow when using a lot of recursion in Haskell -_-
13:38:44 * Twey . o O ( ["a?", "a"] >>= concat . replicate 100 )
13:38:56 <mauke> but part 2 of that question would be the pattern "(([ab]{0,999}){0,999}){0,999}"
13:39:02 <mreh> jabb: I tend to suck it and see
13:39:20 <mreh> jabb: you get a feel for it, but you always miss one now and then
13:39:45 <mreh> do you need reassurance?
13:39:54 <jabb> no :P
13:40:11 <mreh> jabb: okay then! :D
13:40:20 <jabb> except maybe for main loops
13:40:39 <billyrong> thank you Twey. 
13:41:07 <Twey> billyrong: Cabal itself, which is a Haskell library, is distributed with GHC these days.
13:42:44 <billyrong> Twey, but before I ran that apt-get cmd, Cabal was not recognized as a cmd, not cabal is recognized as a cmd
13:44:12 <Twey> billyrong: Cabal proper is a Haskell library.  It doesn't provide an application with which to invoke it.
13:44:26 <Twey> billyrong: It's what gets used when you ‘runhaskell Setup.hs’.
13:45:20 <keep_learning> kindly tell me what is wrong with this code http://pastebin.com/2b4ns1sk . I am trying to add a  string s to a list of string and return the string  
13:45:59 <mauke> keep_learning: you can't use ++ on Maybe
13:46:27 <billyrong> Twey: so in "cabal install MissingH", cabal is a front-end that talks with Cabal proper?
13:46:27 <keep_learning> so i have to remove Maybe
13:46:29 <mauke> also, that function looks a lot like intercalate
13:46:40 <Twey> billyrong: Yes, amongst other things
13:46:52 <Twey> billyrong: The ‘cabal’ command is provided by cabal-install, not by Cabal.
13:46:56 <Twey> It's confusing.  We know.
13:47:04 <keep_learning> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html problem 7 
13:47:09 <Twey> mauke: Yet *mutter*
13:47:15 <keep_learning> i am trying to solve this problem 
13:47:24 <keep_learning> i was not able append a char with string 
13:47:49 <keep_learning> so i append string with string 
13:47:59 <pchiusano> question - is it possible in haskell to define instance (Functor f, Functor g) => Functor (f g) where fmap = fmap fmap
13:48:12 <mauke> keep_learning: intersperse :: a -> [[a]] -> [a]
13:48:19 <mauke> you're not supposed to use chars or strings
13:48:33 <mauke> pchiusano: f g is a kind error
13:48:47 <benmachine> @hackage TypeCompose
13:48:47 <lambdabot> http://hackage.haskell.org/package/TypeCompose
13:48:48 <keep_learning> mauke yes but first i am trying with
13:48:54 <keep_learning> strings 
13:49:22 <keep_learning> i just replace those part with String 
13:49:23 <pchiusano> mauke: okay, say i define type Compose f g x = f (g x)
13:49:26 <billyrong> Twey, thx. And when I 'cabal install MissingH', MissingH was installed under /home/billyrong/.cabal/lib/MissingH-1.1.0.3. What should be the proper path for a package please?
13:49:55 <pchiusano> mauke: then say instance (Functor f, Functor g) => Functor (Compose f g) where fmap = fmap fmap
13:50:07 <mauke> pchiusano: that overlaps with Functor f
13:50:16 <Twey> billyrong: I advise leaving it installed for your home user, because it makes it easier to work with stuff and clean up if you need to
13:50:22 <mauke> f (g a) is a special case of f a
13:50:24 <Twey> Er, your normal user
13:50:33 <benmachine> mauke: no it doesn't because of the newtype
13:50:37 <Twey> If you really need it installed system-wide, pass the --global flag
13:50:48 <benmachine> oh, wait
13:50:51 <benmachine> you said type
13:51:04 <pchiusano> oh, yeah, i guess i'd have to say newtype
13:51:07 <Twey> But generally it's better to just add ~/.cabal/bin to your path and work out of that directory
13:51:08 <benmachine> you need newtype Compose f g x = Compose { deCompose :: f (g x) }
13:51:17 <pchiusano> then would that work?
13:51:45 <mauke> TIAS
13:51:47 <benmachine> pchiusano: http://hackage.haskell.org/packages/archive/TypeCompose/0.7.0/doc/html/src/Control-Compose.html
13:52:48 <pchiusano> benmachine: cool
13:53:06 <pchiusano> it is too bad you have to newtype though
13:53:10 <billyrong> Twey:thanks a lot for the help. I started learning Haskell 2 wks ago and it's interesting. Like this channel also.
13:53:39 <pchiusano> haskell could really use first class modules
13:53:48 <Twey> +1
14:02:02 <mreh> whassat?
14:06:32 <mauke> keep_learning: what
14:07:20 <monoidal> what is a good cabal library to start with FRP?
14:07:24 <keep_learning> what is the difference between a->[[a]] -> [a] and Char-.[String]->String
14:07:42 <monoidal> keep_learning: it's a special case for a = Char
14:07:48 <keep_learning> yes 
14:08:36 <dskippy> keep_learning: A function of the second type would not work on numbers. A function of the first type, for example, would.
14:09:33 <keep_learning> dskippy, thank you
14:09:42 <keep_learning> mauke, thank you
14:10:07 <c_wraith> the advantage to having a more specific type is that it can use operations allowed by knowing more about the type you're working with.
14:11:30 <dskippy> keep_learning: And using type class restrictions on the type variable 'a' is half way between that in a way.
14:11:33 <SonOfLilit> I'm getting a segfault when trying to run frag
14:12:06 <dskippy> keep_learning: Eq a => a -> [[a]] -> [a]   works for almost all way, just so long as 'a' is of type class Eq.
14:12:45 <aristid> @hoogle a -> [[a]] -> a
14:12:46 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:12:46 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:12:46 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
14:12:58 <keep_learning> dskippy, means this can be applied to Num also
14:13:11 <SonOfLilit> sorry, segfault :P
14:13:23 <SonOfLilit> anyone had anything to say to me while I was away?
14:13:51 <gwern> SonOfLilit: we ignored you utterly
14:13:57 <dskippy> keep_learning: Yeah it can.
14:14:16 <keep_learning> dskippy, now its more clear 
14:14:23 <keep_learning> dskippy, thank yoy 
14:14:31 <keep_learning> dskippy, thank you
14:14:37 <dskippy> keep_learning: No problem.
14:14:59 <sshc> % cabal install array base bytestring hpc old-time syb
14:15:01 <sshc> Resolving dependencies...
14:15:03 <sshc> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
14:15:15 <monoidal> you shouldn't install base
14:15:37 <gwern> sshc: do you enjoy reinstalling ghc that much? 4 or 5 of those packages would break your install
14:15:58 <sshc> monoidal: cabal upgrade reports that base can be upgraded
14:16:06 <sshc> remove base from the list works fine
14:16:08 <monoidal> base is upgraded by upgrading ghc
14:16:09 <sshc> removing
14:16:10 <jmcarthur> cabal upgrade is teh dumb
14:16:23 <aristid> sshc: cabal upgrade says that it is unsafe...
14:16:29 <Itkovian> Is anybody porting criterion to e.g. Java, or does anybody know of such an effort?
14:16:43 <gwern> cabal uphrade is a liar
14:16:50 <sshc> Can I upgrade "Cabal"?
14:16:51 <SonOfLilit> so: anyone have any tips on figuring out why frag crashes?
14:17:01 <jmcarthur> sshc: "Below is the list of packages that it would have tried to upgrade."  <-- doesn't mean it's a good idea. that's why it's disabled
14:17:09 <gwern> sshc: yes
14:17:54 <sshc> Even though base can't be upgraded, it shouldn't cause Cabal to crash with an unhelpful error message
14:18:00 <jmcarthur> don't upgrade cabal packages without a reason, is the advice i follow now
14:18:11 <kurt_> hi, does anyone know of a good way for a function to apply a global property of a list to each element in the list?  For example, if I have some function f that is supposed to be applied to the entire list, how would I define a function g that applies it element-wise?
14:18:18 <kmc> :t map
14:18:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:18:36 <monoidal> > map (+1) [7,3,6]
14:18:36 <lambdabot>   [8,4,7]
14:18:40 <kmc> err, are you trying to go the other way?
14:18:59 <kmc> you want ([a] -> [b]) -> a -> b ?
14:19:03 <jmcarthur> kurt_: what is the type of the function you need?
14:19:13 <kmc> yes, that's always a good first question to ask yourself :)
14:19:20 <kmc> :t \f -> head . f . pure
14:19:21 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => (f a1 -> [a]) -> a1 -> a
14:19:51 <kurt_> err...not quite what I was looking for - I want the result of the function f (which should take the entire list), then multiplied element-wise to each element in the list
14:19:59 <jmcarthur> @djinn ([a] -> [b]) -> a -> b
14:19:59 <lambdabot> Error: Undefined type []
14:20:03 <jmcarthur> oh right
14:20:18 <jmcarthur> kurt_: what is the type you need?
14:20:45 <sshc> > let{yourMap :: (a -> b) -> [a] -> [b]; yourMap _ [] = []; yourMap f (x:xs) = f x : yourMap xs} in yourMap (*3) [1..5]
14:20:47 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
14:20:54 <jmcarthur> kurt_: you mean something like this?  \xs -> map (f xs *) xs
14:21:30 <kmc> kurt_, what's the type of the function you need?
14:21:50 <sshc> > let{yourMap :: (a -> b) -> [a] -> [b]; yourMap _ [] = []; yourMap f (x:xs) = f x : yourMap xs} in yourMap (*3) [1..5]
14:21:51 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
14:22:00 <sshc> > let{yourMap :: (a -> b) -> [a] -> [b]; yourMap _ [] = []; yourMap f (x:xs) = f x : yourMap f xs} in yourMap (*3) [1..5]
14:22:01 <lambdabot>   [3,6,9,12,15]
14:22:31 <travisbrady> I'd like all string literals in my source code to be ByteStrings, I've seen {-# LANGUAGE OverloadedStrings #-} but I can't tell what else I need to do to make that work.
14:22:46 <BMeph> kurt_: Would you mind being a little more vaguely abstract, please? ;þ
14:22:56 <c_wraith> travisbrady: you need to import Data.ByteString.Char8
14:22:57 <jmcarthur> travisbrady: use the extension and then use your string literals as if they were bytestrings?
14:23:15 <c_wraith> Data.ByteString.Char8 has the IsString instance the extension needs
14:23:27 <jmcarthur> oh the extension is syntactic? that's lame
14:23:37 <jmcarthur> s/syntactic/a preprocessor/
14:23:38 <travisbrady> c_wraith: and do I need to import it unqualified?  typically I do "as S"
14:23:52 <c_wraith> You only need the instance.  Doesn't matter how you import it
14:23:54 <kmc> jmcarthur, how so?
14:23:54 <kurt_> sorry I'm thinking about what the type signature would be... 
14:24:05 <jmcarthur> oh, so it's not just a preprocessor
14:24:11 <sshc> % cabal install base
14:24:11 <sshc> Resolving dependencies...
14:24:11 <sshc> cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
14:24:16 <kmc> jmcarthur, it makes "foo" :: (IsString a) => a
14:24:23 <kmc> much like 3 :: (Num a) => a
14:24:31 <jmcarthur> kmc: i was thinking the extension would be able to refer to that type class without requiring an import
14:24:32 <monoidal> sshc, base is a special package, you should not upgrade it
14:24:38 <kmc> i think it can
14:24:42 <kmc> but you need to import the instance
14:24:46 <Saizan> sshc: that might have to be reported as a bug, but anyway you can't cabal install base
14:24:48 <kmc> just like you can't use 3 as an Int if Prelude isn't in scope
14:24:59 <jmcarthur> i guess it makes sense
14:26:22 <sshc> Saizan: Where do I report it?
14:26:26 <c_wraith> travisbrady: really, that should be all there is to it.  Add the LANGUAGE pragma.  import the instance.  Use string literals in places where their type can be inferred as ByteString, or explicitly annotate their types.
14:26:50 <travisbrady> c_wraith: is this ghc version dependent?  
14:26:51 <kurt_> the type signature is rather complicated I think :/ .... g :: Integer -> Integer -> ([Integer] -> Integer -> (Integer, Float) -> Integer) -> Float
14:27:30 <c_wraith> travisbrady, to some extent, but I know that extension works fine in 6.10 and 6.12, and probably older versions too
14:28:00 <monoidal> kurt_: how do you want to use it?
14:28:08 <Saizan> sshc: see "The bug tracker" paragraph here http://hackage.haskell.org/trac/hackage/
14:28:20 <jmcarthur> kurt_: can you generalize that at all?
14:28:25 <travisbrady> c_wraith: does this look right? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26529#a26530
14:28:51 <jmcarthur> kurt_: if you can express g's type more polymorphically it should be easier to derive an implementation
14:29:38 <c_wraith> travisbrady, it's defaulting to String.    You need to either annotate the type explicitly, or use the value in such a way that its type is inferred.
14:30:18 <jmcarthur> looks like that should be unifying with ()
14:30:30 <c_wraith> jmcarthur, main doesn't need to be IO ()
14:30:32 <jmcarthur> which i believe will fail the constraint
14:30:39 <c_wraith> It just needs to be IO something
14:30:47 <jmcarthur> huh
14:30:49 <jmcarthur> i didn't know that
14:30:54 <kmc> yeah it's annoying
14:31:03 <jmcarthur> i usually put a type signature on it
14:31:06 <kmc> because a typo might give you main :: IO (IO ())
14:31:08 <travisbrady> c_wraith: ahh, that did it.  thank you
14:31:19 <monoidal> when main is IO a for a /= (), is the result ignored?
14:31:23 <kmc> think so
14:31:23 <c_wraith> travisbrady, you're welcome
14:31:33 <ddarius> monoidal: The type suggests very strongly that it is.
14:31:38 <kmc> imo it should be a warning, like the new "unused result in do" warning
14:31:40 <kurt_> actually, sorry the type signature for g should just be g :: [a] -> a -> b
14:31:41 <kmc> maybe it is already
14:31:41 <sshc> Some packages are failing to install: <command line>: cannot satisfy -package Cabal-1.8.0.2: 
14:31:44 * kmc should use -Wall more
14:31:44 <sshc>     Cabal-1.8.0.2-72f6eafc7def741b28f6ec75d2686d14 is unusable due to missing or recursive dependencies:
14:31:47 <sshc>       directory-1.0.1.0-10fc46e61b67ff4a83f3e553454d003c process-1.0.1.2-8b5308cb23fbdc3c2df27e298550937f
14:31:56 <ddarius> monoidal: Arguably the "runtime system" that "executes" the IO action bound by main could have magic introspective powers.
14:32:04 <monoidal> well, yes
14:32:14 <kurt_> but part of the function definition involves calling a function f that should return the same result for each element in [a] - it's a global property of the list
14:32:22 <jmcarthur> main :: IO Void
14:32:25 <c_wraith> it should be IO Int, obviously, for the sake of program return values. :)
14:32:25 <jmcarthur> ;)
14:33:04 <jmcarthur> kurt_: g :: [a] -> a -> b   -- that's not possible unless you're fine with it not terminating
14:33:41 <jmcarthur> kurt_: what that says is that g should take a list of any type, another value of that type, and should be able to return a value of any type
14:33:44 <kmc> yes, no way to just make up a value of type «b»
14:33:57 <monoidal> kurt_: you mean something like if f xs y = y * sum xs then g [1,2,3] = [1*6, 2*6, 3*6]?
14:34:02 <kmc> without any inputs of type «b» and without any detail on which type «b» actually is
14:34:15 <kurt_> jmcarthur: oh right, oops :/ I actually do just mean [Integer] -> Integer -> Float
14:34:26 <jmcarthur> kurt_: if it's supposed to take a function that needs to be in the type too
14:34:38 <jmcarthur> kurt_: heh, i think we are dancing around the issue a bit
14:34:48 <travisbrady> Anyone know the fastest way to split a ByteString into a tuple if you know the length ahead of time?  Should I just use break?
14:34:51 <jmcarthur> kurt_: what is the problem you are trying to solve? can you paste code on hpaste.org?
14:35:11 <monoidal> kurt: if the first argument is always equal to the whole list just do partial application and use map
14:35:26 <kurt_> monoidal: yes, that's something like what I mean
14:35:35 <monoidal> kurt_: like
14:35:48 <monoidal> > let xs = [1,2,3] in map ((sum xs)*) xs
14:35:48 <lambdabot>   [6,12,18]
14:36:27 <napping> tridactyla: sounds like it
14:36:33 <monoidal> > let applyglob f xs = map (f xs) xs in applyglob (\xs a -> sum xs * a) [1,2,3]
14:36:34 <lambdabot>   [6,12,18]
14:36:36 <napping> travisbrady, rather.
14:36:42 <monoidal> kurt_: ^
14:37:35 <ddarius> @pl \f xs -> map (f xs) xs
14:37:36 <lambdabot> (map =<<)
14:39:17 <sshc> Saizan: I'm trying to reset my password by http://hackage.haskell.org/trac/hackage/reset_password, but I'm not getting any emails
14:39:46 <c_wraith> why doesn't hayoo know about Ghc.ConsoleHandler?  It's in base!
14:40:18 <devid_> i try to install SDL via "cabal install SDL", but it fails because SDL.h is missing (now i have thousands + linkings but nothing working).. can someone give me a hint whats wrong?
14:40:19 <c_wraith> oh.  because the package doesn't contain anything unless configured on windows
14:40:52 <lispy> devid_: sounds like you need to install the SDL package for your OS first
14:41:12 <devid_> i thought i already did this
14:41:18 <devid_> and gcc is already working
14:41:38 <c_wraith> devid_, if you're on a debian-derived system, did you install the -dev package for sdl, too?
14:41:43 <lispy> devid_: if sdl.h is on your system, then next step is to figure out where cabal is looking for it.
14:42:01 <lispy> devid_: I think that's something like, cabal install -v sdl
14:42:28 <kurt_> ok, to make things clearer: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26531
14:43:20 <greb> hi
14:44:08 <greb> so, haskell.org reverted to the usage of the old logo?
14:45:00 <kmc> kurt_, why don't you pass another parameter to kmax
14:45:09 <kmc> so  that it remembers the whole string
14:45:16 <kmc> also r isn't changing between successive calls
14:45:22 <kmc> so why don't you just pass (kmax ks r) there
14:46:04 <benmachine> greb: unintentionally I believe
14:46:12 <kau> Hello!
14:46:13 <kmc> haskell.org got haxored
14:46:18 <kmc> and so they reverted to a backup
14:46:21 <kmc> which was apparently old?
14:46:26 <kmc> hello kau
14:46:38 <sshc> kmc: Really?
14:46:45 <kmc> ya
14:47:02 <sshc> More information please!
14:47:37 <kmc> sshc, http://www.reddit.com/r/haskell/comments/cbkkb/wwwhaskellorg_wiki_mailing_list_server_has_been/
14:47:40 <devid_> hm i can just find sdl-config somewhere along the output
14:47:48 <devid_> btw im on win7 using cygwin/msys
14:47:51 <sshc> Thanks
14:47:54 <sshc> What is the syntax for typeclasses in "data" definitions again?
14:48:12 <greb> kmc: thanks for the info
14:48:35 <kmc> sshc, you probably don't want to put a type class constraint on an ordinary data type
14:48:42 <kurt_> kmc: that's what I had been doing in a previous version...I was hoping there was a way to avoid the redundancy, since those two parameters would always be called with the same value :/
14:48:54 <kmc> kurt_, so you'll recompute the value instead?
14:48:55 <kurt_> (initially)
14:48:56 <kmc> doesn't that seem worse?
14:49:05 <kmc> or do you mean redundancy syntactically?
14:49:11 <kmc> that can be fixed with "where"
14:49:55 <sshc> kmc: Yes.  I'm just curious what the syntax is.
14:50:26 <kurt_> really? I was thinking if I used where to store the value of cbarmax, it would have the same behavior as it currently does
14:50:41 <sshc> "data (Class i) => Constructor i = ..." or "(Class i) => data Constructor i = ..."?
14:50:51 <ddarius> sshc: The former.
14:50:54 <kmc> kurt_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26531#a26534
14:51:24 <sshc> 'k.
14:52:05 <kmc> «data (Class a) => Type a = Ctor a» and «data Type = forall a. (Class a) => Ctor a» are both valid in GHC
14:52:09 <kmc> the latter is an existential type
14:53:09 <kmc> kurt_, you can use "let" similarly
14:53:23 <kmc> and it can be easier to understand
14:54:07 <kau> Do you know how to make a Read instance for a GADT?
14:54:39 <kmc> kau, same as any type
14:54:50 <kmc> or do you mean specifically *deriving* a Read instance for a GADT?
14:54:53 <kau> I'm trying but it won't compil because of the different return types of my GATD
14:54:59 <kmc> ah
14:55:04 <benmachine> you need StandaloneDeriving if you want to derive one
14:55:08 <kau> no, i can do it by hand
14:55:21 <kmc> right, it makes sense that you can't Read certain types of GADT
14:55:38 <benmachine> the type that comes out can't depend on the value of the string
14:55:40 <kau> i use StandaloneDeriving but the automatic deriving doesn 't compil
14:55:52 <kmc> suppose your GADT represents typed syntax for a programming language
14:56:01 <kau> that's the case ;)
14:56:05 <kmc> then in «read :: String -> T a», the caller gets to choose 'a'
14:56:27 <kau> i do i come around this
14:56:43 <kmc> i think what i'd do is
14:56:49 <kmc> make an existential wrapper
14:56:53 <kau> is there examples out there of a Read for a little language made with a GATD?
14:56:57 <kmc> data SomeT = forall a. SomeT (T a)
14:57:09 <kurt_> ok, thanks for the help. :)
14:57:18 <kmc> you can write read for SomeT
14:57:30 <kau> Wooh i'm not at the existancial step yet ;)
14:57:41 <kmc> (which will fail if the term doesn't typecheck)
14:57:43 <kmc> and then you can write read for (T a) such that it fails at run time if there's a type mismatch
14:57:56 <kmc> by doing a runtime type coercion with Typeable or such
14:58:07 <kmc> so it's a little hairy :)
14:58:12 <kau> mmh
14:58:25 <travisbrady> Is there a way to read a Float from a bytestring w/o using a library?  I hoogled but only found unsafeCoerce
14:58:31 <kmc> haha
14:58:44 <benmachine> Typeable wouldn't do it would it? unless your Typeable instance for the GADT was decidedly evil
14:58:48 <kmc> you want to read digits?
14:58:54 <benmachine> travisbrady: unsafeCoerce is not what you want :P
14:59:06 <kmc> unsafeCoerce is Hoogle's comedy answer
14:59:10 <benmachine> heheh
14:59:56 <kau> my GATD is like "data Obs a where"
14:59:58 <benmachine> travisbrady: without using a library - but you kind of need a library to have bytestrings in the first place, don't you?
15:00:11 <kau> with some function returning Obs Int, Obs Bool and so on
15:00:22 <travisbrady> benmachine: I do yes.  Sorry, I meant a library outside of the stdlib
15:00:25 <kau> And        :: Obs Bool -> Obs Bool -> Obs Bool
15:00:35 <kau> Plus       :: (Num a) => Obs a -> Obs a -> Obs a
15:00:36 <kau> etc.
15:00:58 <kmc> travisbrady, by stdlib you mean Haskell Platform?
15:01:33 <travisbrady> kmc: No, I mean the libraries listed here: http://cvs.haskell.org/Hugs/pages/libraries/
15:01:47 <kmc> you're using Hugs?
15:01:58 <kmc> hmm or not
15:02:02 <kmc> i've never seen this page before
15:03:05 <benmachine> travisbrady: that's not... standard, as far as I know
15:03:36 <travisbrady> benmachine: woops, wrong link
15:03:45 <alar> I'd recommend dirty tricks with Ptrs
15:04:01 <travisbrady> benmachine: Meant to paste this one http://www.haskell.org/ghc/docs/6.12.2/html/libraries/
15:04:02 <kmc> travisbrady, what format is the float in?
15:04:02 <alar> just you'd do it in C
15:04:05 <benmachine> oic
15:04:26 <kmc> alar, that doesn't help if it's ASCII-encoded decimal, which is what I think of when I hear "read"
15:04:40 <greb> travisbrady:  you could look into the source data-binary-ieee754 on hackage
15:04:50 <alar> kmc: I supposed that Float is in IEEE binary format
15:05:37 <alar> if it is decimal - than I'd try to "read" it
15:06:04 <alar> so, travisbrady: your task is underdefined
15:06:18 <travisbrady> :t read
15:06:19 <lambdabot> forall a. (Read a) => String -> a
15:06:26 <cwinter> [A[A[B
15:07:13 <travisbrady> alar: assume I've got 'blah = "3.0"::ByteString' and I'd like to have 3.5::Float
15:07:14 <alar> > read 1.95 ::Float
15:07:15 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
15:07:15 <lambdabot>    arising from the l...
15:07:23 <alar> > read "1.23" ::Float
15:07:25 <lambdabot>   1.23
15:07:56 <alar> > read (unpack ("3.0"::ByteString)) ::Float
15:07:57 <lambdabot>   Not in scope: `unpack'Not in scope: type constructor or class `ByteString'
15:08:48 <alar> @hoogle unpack
15:08:49 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
15:08:49 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
15:08:49 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
15:09:05 <alar> > Data.ByteString.pack "XPEH"
15:09:06 <lambdabot>   Not in scope: `Data.ByteString.pack'
15:11:22 <travisbrady> alar: I can unpack them, yes.  But I've heard there is a serious performance penalty for doing so.
15:11:36 <alar> yes, there is
15:11:45 <alar> but I don't know how serious
15:12:05 <kmc> serious
15:12:08 <alar> @hoogle read
15:12:09 <lambdabot> Prelude read :: Read a => String -> a
15:12:09 <lambdabot> Text.Read read :: Read a => String -> a
15:12:09 <lambdabot> module Text.Read
15:12:11 <kmc> it defeats the purpose of bytestring
15:12:19 <kmc> but if you are only unpacking small bits of them
15:12:24 <kmc> it seems all right
15:12:35 <kmc> in the best of all possible worlds
15:12:44 <alar> kmc: I'm not sure about performance of "read"
15:12:48 <kmc> the list produced by unpack gets fused with the iteration done by the parser
15:13:01 <kmc> and so it's not actually created in memory
15:13:21 <kmc> travisbrady, why this limitation on what libraries to use? there are several ByteString parser libraries on hackage
15:13:23 <alar> It might be even worse than all our "penalties"
15:13:46 <kmc> it should be easy to implement, anyway
15:13:48 <kmc> and then you can profile
15:13:56 <travisbrady> kmc: it's an artificial requirement.
15:14:03 <kmc> for a class?
15:16:12 <jbapple> I asked this yesterday, but I figured I would ask again since there was a post to the libraries list about speeding up containers -- has anyone tested 4-ary, rather than binary, tries?
15:16:39 <jbapple> For IntSet, I mean
15:19:23 <kmc> did kau leave? i have a GADT reading example
15:20:09 <ivanm> kmc: looks like it
15:20:14 <travisbrady> kmc: haha, no, i'm long out of school.  Just a programming exercise
15:20:14 <kmc> :/
15:20:18 <kmc> ok
15:20:30 <ivanm> 10 minutes ago
15:23:27 <kmc> it only uses five extensions ;P
15:24:06 <kmc> clojure's tries are 32-ary iirc
15:26:49 <jbapple> kmc: I expect that pointer chasing is the major cost in trie lookup
15:27:01 <kmc> yes
15:27:09 <kmc> it blows your cache
15:27:09 <jbapple> If tried are too wide, I'm sure array/node copying would become a time problem
15:27:15 <jbapple> and perhaps a space problem
15:28:28 <jbapple> I posted an hpaste the other day showing that Set Int can be faster than IntSet for certain sets
15:28:41 <jbapple> (that make a so-called "centipede" trie)
15:29:01 <ivanm> jbapple: :o
15:29:50 <kmc> clojure's trie nodes are also packed clevely
15:29:52 <kmc> cleverly*
15:29:55 <kmc> as are judy nodes
15:30:17 <jbapple> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26499
15:30:24 <jbapple> kmc: Do you know what the trick is?
15:30:26 <kmc> a sparse region of keyspace won't have 32 words in each node
15:30:47 <kmc> jbapple, not specifically.  some kind of bit masking and Hacker's Delight trickery
15:31:01 <ivanm> jbapple: any idea why IntSet performs badly there?
15:31:22 * ivanm thought IntSet was just Set with specialised Int operations and pragmas...
15:31:32 <jbapple> ivanm: Yes - Set Int chases ~ 5 pointers, while IntSet chases ~32
15:31:33 <kmc> no, the guts are totally different
15:31:42 <kmc> IntSet is a trie of the bits in the int
15:31:49 <ivanm> jbapple: hmmm...
15:31:55 <kmc> Set uses only comparison between elements
15:31:59 <ivanm> what kind of timing difference we talking about here?
15:32:02 <jbapple> kmc: yeah, the clojure author was hand-wavey in the talk I watched
15:32:07 <kmc> me too
15:32:09 <kmc> probably same talk
15:32:12 <kmc> but i think the source is avaliable
15:32:18 * ivanm doesn't have criterion installed here atm so can't run it himself
15:32:25 <danharaj> was this literal hand-wavey or metaphorical
15:32:34 <kmc> mullet-wavey
15:32:41 <kmc> btw there's now a "hashmap" library on hackage
15:32:43 <jbapple> ivanm: IntSet is 2x as slow on the centipede set
15:32:48 <kmc> that uses IntMap and Map together
15:32:48 <jbapple> and 2x as fast on a random set
15:32:59 <kmc> centipedes? in my data structure?
15:33:10 <ivanm> what's the centipede set?
15:33:12 <jbapple> hashing should mostly solve the problem, since it will randomize the keys
15:33:16 <ivanm> wikipedia doesn't know about it...
15:33:22 <ivanm> doesn't that mean it doesn't exist? :p
15:33:27 <jbapple> It's called elems in the code I pasted
15:33:29 <kmc> 0:[2^i | i <-[0..(bitWidth-2)]]  -- this one?
15:33:33 <kmc> ah yes
15:33:45 <jbapple> and it's graphed in the paper about containers that was posted on libraries and reddit
15:33:46 <ivanm> jbapple: oh, powers of 2?
15:33:58 <jbapple> ivanm: That's just the rep I chose
15:34:10 <kmc> the trie does badly here because only one node is cut off at each bit position
15:34:17 <jbapple> It's any set that can't be path-compressed but isn't very wide
15:34:19 <kmc> but comparison is easy
15:34:43 <MadHatterDude> Help me out here:
15:34:49 <jbapple> One problem with hashing is that one is no longer storing an ordered tree
15:34:49 <ivanm> jbapple: to be a really good comparison though, should you use the one vector for all tests and deepSeq it before passing it to your benchmarks?
15:35:17 <ivanm> MadHatterDude: well, your problem is is that you're not stating what your problem is
15:35:17 <ivanm> :p
15:35:18 <MadHatterDude> newtype Parser s st v
15:35:29 <jbapple> as to looking at the clojure source, I'd prefer to understand the trick as prose as well. Code has such a high density of information, it can go wrong
15:35:32 <jbapple> Too easily
15:35:35 <MadHatterDude> instance Monad (Parser s st) where ... 
15:35:40 <ivanm> jbapple: yeah
15:35:44 <jbapple> See, FI, Data.Set, which uses incorrect constants for balancing
15:35:47 <MadHatterDude> instance MonadState (Parser s st) st where ...
15:35:47 <ivanm> MadHatterDude: a paste somewhere might be better/easier
15:35:49 <ivanm> @hpaste
15:35:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:35:57 <MadHatterDude> And the monadstate doesnt work...
15:35:58 <ivanm> *sigh*
15:36:00 <jbapple> ivanm: vector is strict
15:36:01 <ivanm> @where hpaste
15:36:02 <lambdabot> http://hpaste.org/
15:36:07 <ivanm> jbapple: in the contents as well? cool
15:36:29 <ivanm> @hoogle MonadState
15:36:29 <lambdabot> No results found
15:36:41 <MadHatterDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26535#a26535
15:36:43 <Saizan> MadHatterDude: wrong order
15:36:51 <jbapple> ivanm: I don't know if it's strict in contents. Perhaps not, but I expect so, since I used an unboxed vector
15:36:56 <Saizan> MadHatterDude: instance MonadState st (Parser s st) where ..
15:37:04 <ivanm> jbapple: *nod*
15:37:08 <MadHatterDude> God damnit!
15:37:33 <billyrong> newbie question: after a successful 'cabal install MissingH', ghc complains "Failed to load interface for `MissingH'". thanks!
15:37:42 <jbapple> Another problem with hash tries is the time it takes to hash
15:38:20 <jbapple> I don't remember, do the hashtries on Hackage hash one "letter" at a time?
15:38:42 <Saizan> billyrong: MissingH is the package name, the modules it provides are listed here http://hackage.haskell.org/package/MissingH
15:40:18 <billyrong> Saizan:thx, am trying...
15:42:57 <kmc> jbapple, which, the "hashmap" package?
15:43:11 <kmc> it just uses a Hashable class to get an IntMap key
15:44:21 <alar> how can I say "import this module and reexport everything from it"?
15:44:36 <jbapple> kmc: yes, that one
15:46:02 <c_wraith> alar: that's pretty easy.  put "module Foo" in the export list of the module you're writing.  Don't forget to import it.
15:46:24 <kmc> alar, module Foo(module Bar) where; import Bar
15:46:36 <alar> cool
15:46:41 <alar> thanks!
15:46:53 <Phyx-> if i'm not mistaken, that will then also not export anything from Foo itself
15:46:55 <Phyx-> itself*
15:47:22 <kmc> yeah
15:47:24 <c_wraith> Where's the full guide for writing foo.cabal files?
15:47:28 <kmc> you can do module Foo(module Foo, module Bar)
15:47:42 <jbapple> kmc: Very clever!
15:47:43 <Phyx-> kmc: yeah i know, just making sure he knows :)
15:47:51 <kmc> putting a module in its own export list exports everything that would be exported with no export list
15:48:15 <Phyx-> c_wraith: what do you mean?
15:48:23 <zygoloid> kmc++ i did not know that
15:48:39 <c_wraith> All I can find is the user's guide for cabal.  That doesn't appear to cover actually *writing* the cabal files
15:48:40 <kmc> i think the Haskell module system is pretty good, for what it aspires to be
15:48:56 <kmc> that is, i can't think of many minor problems, only major ones that would restructure large parts of the language
15:49:19 <benmachine> c_wraith: cabal init?
15:49:24 <kmc> i.e. first-class modules, parametrized modules, better instance control (which would involve making classes and instances more first-class)
15:49:37 <c_wraith> benmachine, cabal init doesn't cover conditional stuff
15:49:43 <Phyx-> c_wraith: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
15:49:52 <c_wraith> ...  still doesn't cover conditional stuff
15:49:57 <c_wraith> Where's the advanced cabal docs?
15:50:41 <benmachine> the user's guide has everything afaik
15:51:08 <benmachine> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#configurations
15:51:26 <Phyx-> c_wraith: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
15:51:30 <Phyx-> ah, got beaten to it
15:51:42 <c_wraith> thanks.  I also found it. :)
15:51:42 <syzygic> hello everyone
15:51:59 <kmc> hi syzygic 
15:52:01 <billyrong> test.hs has "import MissingH.List". both "ghc test.hs" and "ghc test.hs -package MissingH" returned with error "Failed to load interface for `MissingH.List'"? THX!
15:52:03 <srobertson> I'm getting link errors using 'ghc' (6.12.2) on code which uses Data.Vector. 'ghci' runs the code fine. hints?
15:52:23 <benmachine> srobertson: are you using ghc --make?
15:53:00 <benmachine> billyrong: what are you looking for and how are you finding out which module it's in?
15:53:25 <srobertson> benmachine: wow, that was a *good* hint. :)
15:53:39 <benmachine> srobertson: I really don't know why it's not the default
15:53:48 <benmachine> it might as well be called ghc --magically-fix-all-my-problems
15:53:50 <benmachine> >_>
15:53:55 <Saizan> billyrong: the api probably changed in the meanwhile, try with Data.List.Utils
15:53:56 <syzygic> I have a quick question about deepseq and trying to time a computation (and I have an easy example this time :)
15:54:14 <zygoloid> ghc --dont-fail-for-reasons-which-you-understand-and-i-dont
15:54:27 <billyrong> benmachine: i am trying the code at the bottom of this page http://www.freesoftwaremagazine.com/articles/haskell ......
15:54:42 <billyrong> Saizan: thx, I am trying...
15:55:15 <syzygic> I have a function mean, which computes the mean of elements in a [Double]
15:55:26 <syzygic> and I want to time this computation, without calling the show function
15:55:48 <jbapple> kmc: actually, now that I think about it, hashing won't solve the centipede problem for strings
15:56:18 <jbapple> (or anything else you hash in "letters" or pieces)
15:56:26 <jbapple> unless you hash the whole string up front
15:56:44 <jbapple> which I suppose takes no longer than a trie search
15:56:52 <syzygic> I tried enclosing let meanOver2 = deepseq (mean as) `seq` (mean as) / fromIntegral 2
15:56:58 <syzygic> in some getCurrentTimes
15:57:03 <jbapple> But you lose sortedness
15:57:06 <syzygic> but all thte time is spent in showing meanOver2
15:57:26 <jbapple> and thus fast split, which not becomes O(n)
15:57:30 <jbapple> *now
15:57:39 <benmachine> billyrong: the function used from MissingH there is contains, which was replaced by isInfixOf
15:57:52 <benmachine> billyrong: I think isInfixOf is in Data.List
15:59:45 <tromp_> :t interact
15:59:46 <lambdabot> (String -> String) -> IO ()
15:59:50 <billyrong> benmachine: thank you so much, i'd have wasted more time on this!
16:01:21 <billyrong> Saizan: I think Data.List.Utils is the right module, but the sample code I played with is out of date and benmachine pointed to a diff function...thank you 
16:02:15 <triyo> I think I'm going blind. What is wring with this:    MyType <$> (char '@' *> many alphaNum) <*> parens (alphaNum `sepBy`char ',') <*> ( char ':' *> optional (anyChar `manyTill` eof))
16:03:04 <zygoloid> i want to write: "instance (Foo a, m ~ FooType a) => Foo (m a)" where FooType is one of Foo's associated types. but GHC doesn't like that. is there a workaround?
16:03:06 <triyo> Couldn't match expected type `[Char]' against inferred type `Char'    Expected type: ParsecT   String u Control.Monad.Identity.Identity String   Inferred type: ParsecT  String u Control.Monad.Identity.Identity Char
16:03:25 <triyo> In the first argument of `sepBy', namely `alphaNum'
16:03:41 <Saizan> triyo: what's the type of sepBy?
16:03:48 <zygoloid> i guess tou want many alphaNum not just alphaNum?
16:03:59 <triyo> sepBy
16:04:00 <triyo>   :: (Stream s m t) =>
16:04:00 <triyo>      ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
16:04:13 <zygoloid> i'm guessing MyType :: String -> [String] -> ...
16:04:40 <triyo> data MyType = MyType String [String] (Maybe String)
16:04:50 <zygoloid> yeah. you want many alphaNum.
16:06:07 <triyo> true, thanks, I missed many. However I get now: Couldn't match expected type `Maybe String' against inferred type `()' on the lat bit
16:06:25 <triyo> In the second argument of `(*>)', namely
16:06:54 <triyo> I think I want optionalMaybe there instead...
16:06:59 <benmachine> triyo: parsec has a silly definition of optional imo
16:07:06 <benmachine> import optional from Control.Applicative
16:07:15 <Saizan> optional returns ()?
16:07:28 <jbapple> kmc: But hashing can take a long time to get to "No". For instance, if I have a set containing only "a", and I want to see if (replicate (10^6) 'z') is a member, it takes WAY too long
16:07:42 <benmachine> :t Text.Parsec.optional
16:07:43 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m ()
16:07:45 <triyo> optional :: (Stream s m t) => ParsecT s u m a -> ParsecT s u m () go figure
16:07:45 <jbapple> (If I'm hashing the whole string)
16:07:46 <triyo> :)
16:07:54 <benmachine> :t Control.Applicative.optional
16:07:56 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
16:07:59 <kmc> makes sense jbapple
16:08:07 <benmachine> generality ftw
16:08:19 <kmc> hashes are very strict
16:08:33 <jbapple> kmc: Maybe some kind of incremental hash (hash the first letter, then the next two, then the next 4) would work
16:08:43 <kmc> so maybe another flavor of hashmap could take [Int] as the hash
16:08:50 <triyo> so I'm after the applicative  optional of course... silly parsec
16:08:56 <kmc> and leave it up to the particular data structure how much to incorporate at each stage
16:09:04 <jbapple> kmc: Sorry, what?
16:09:05 <kmc> of course for char strings you can use a character trie directly
16:09:23 <jbapple> What do you mean "incorporate"?
16:09:35 <kmc> into the hash
16:09:49 <kmc> like you said, first letter, then next two, then next four
16:09:59 <zygoloid> any type families experts? how do you work around the restriction on superclass equalities?
16:10:07 <kmc> zygoloid, example?
16:10:07 <jbapple> kmc: I think I see
16:10:14 <kmc> jbapple, so this would be my decision when implementing Hashable
16:10:25 <zygoloid> "instance (Foo a, m ~ FooType a) => Foo (m a)" where FooType is one of Foo's associated types
16:10:36 <jbapple> @hoogle Hashable
16:10:37 <lambdabot> No results found
16:10:43 <kmc> http://hackage.haskell.org/packages/archive/hashmap/1.0.0.2/doc/html/Data-Hashable.html
16:10:51 <kmc> i'm supposing that now hash :: a -> [Int]
16:11:07 <jbapple> I see.
16:11:17 <jbapple> kmc: I'd still be worried about centipede sets
16:11:22 <triyo> benmachine: I switched to applicative option and hidden the parsec ver and all seems well now.
16:11:25 <kmc> yeah
16:11:26 <jbapple> I'd have to think some more about the possibility
16:11:29 <kmc> well, there's no free lunch
16:11:35 <jbapple> and split is still lousy
16:11:49 <kmc> zygoloid, that's not allowed?
16:11:53 <benmachine> kmc: I'm getting free lunch tomorrow
16:11:55 <jbapple> What?!? No free lunch?!?
16:12:00 <benmachine> so there
16:12:03 <kmc> heh
16:12:09 <kmc> yeah in academia there is frequently free lunch
16:12:09 <jbapple> I am LIVID. I was told there would be free lunch on this channel.
16:12:11 <zygoloid> kmc: no, due to the ~ in the context.
16:12:18 <kmc> ah zygoloid
16:12:24 <jbapple> wait, is this #free-lunch?
16:12:25 <kmc> perhaps you can use an equality class instead?
16:12:42 <jbapple> brb, lunch
16:13:07 <zygoloid> kmc: class Eq a b; instance Eq a a; instance (Foo a, Eq m (FooType a)) => ...?
16:13:10 <zygoloid> i'll give it a go
16:13:14 <kmc> yeah
16:13:21 <kmc> oleg had some article about this which went into more detail
16:13:36 <kmc> there are some tricky hacks required to prevent GHC from reducing out the Eq context too soon
16:14:43 <djahandarie> tricky hacks--
16:14:53 <benmachine> tricky hacks++ 
16:14:58 <kmc> @karma hacks
16:14:58 <lambdabot> hacks has a karma of 0
16:15:13 <danharaj> clever programming----
16:15:34 <illissius> is there any way to type-level compose an ((->) a) and an ((->) b) into an `(a -> b ->)`?
16:15:46 <djahandarie> @karma- this god damn confusing karma plugin
16:15:47 <lambdabot> this's karma lowered to -3.
16:15:54 <djahandarie> fff
16:16:03 <kmc> newtype Compose f g x = Compose (f (g x))
16:16:06 <kmc> it's only isomorphic though
16:16:25 <kmc> @karma c
16:16:25 <lambdabot> c has a karma of 2
16:16:40 <djahandarie> testingThisJunk++
16:16:44 <djahandarie> @karam testingThisJunk
16:16:45 <lambdabot> Maybe you meant: karma karma+ karma-
16:16:50 <djahandarie> @karma testingThisJunk
16:16:51 <lambdabot> testingThisJunk has a karma of 1
16:17:02 <djahandarie> I guess there is just a special case for C or so
16:17:16 <alar> @karma C++
16:17:17 <lambdabot> C++ has a karma of -4
16:17:28 <sproingie> @karma chameleon
16:17:29 <lambdabot> chameleon has a karma of 4
16:17:29 <kmc> well both c++ and c-- are discussed here with some frequency
16:17:43 <alar> @karma C--
16:17:44 <lambdabot> C-- has a karma of 3
16:17:52 <sproingie> @karma C
16:17:53 <lambdabot> C has a karma of 2
16:18:01 <alar> @karma ++C
16:18:01 <lambdabot> ++C has a karma of 0
16:18:10 <benmachine> C--++
16:18:14 <djahandarie> lol
16:18:15 * benmachine wonders what that does
16:18:17 <djahandarie> @karam C--
16:18:17 <lambdabot> Maybe you meant: karma karma+ karma-
16:18:20 <djahandarie> God damn
16:18:22 <sproingie> i think you need parens
16:18:23 <djahandarie> @karma C--
16:18:23 <lambdabot> C-- has a karma of 4
16:18:26 <djahandarie> Nope
16:18:34 <sproingie> C--++--++
16:18:36 <djahandarie> It worked (as expected?)
16:19:00 <benmachine> @karma C
16:19:01 <lambdabot> C has a karma of 2
16:19:06 <sproingie> @karma c--++--
16:19:07 <lambdabot> c--++-- has a karma of 1
16:19:15 <benmachine> ok that makes sense
16:19:31 <ivanm> you have to do @karma+ and @karma- for C
16:19:47 <sproingie> special-cased?
16:19:55 <sproingie> @karma notepad
16:19:55 <lambdabot> notepad has a karma of 62
16:20:01 <djahandarie> Heh
16:20:13 <djahandarie> @karma GHC
16:20:14 <lambdabot> GHC has a karma of 0
16:20:15 <ivanm> sproingie: yeah, I believe so, because of people saying C++ and C-- all the tiem
16:20:25 <djahandarie> @karma Cmm
16:20:25 <lambdabot> Cmm has a karma of 0
16:20:28 <djahandarie> @karma Hugs
16:20:29 <lambdabot> Hugs has a karma of -1
16:20:31 <djahandarie> Haha
16:20:35 <lpsmith> aww
16:20:39 <lpsmith> Hugs++
16:20:42 <lpsmith> Hugs++
16:20:48 <lpsmith> @karma Hugs
16:20:48 <lambdabot> Hugs has a karma of 1
16:20:51 <lpsmith> yay!
16:20:54 <bnonym> Hugs--
16:20:55 <bnonym> Hugs--
16:20:58 <bnonym> justified!
16:21:02 <sproingie> now now
16:21:16 <mauke> preflex: karma C
16:21:16 <preflex>  C: 148569
16:21:19 <lpsmith> haskell wouldn't be here today without hugs
16:21:25 <mauke> preflex: karma hugs
16:21:26 <preflex>  hugs has no karma
16:21:26 <lpsmith> well, what it is today
16:21:42 <kmc> Hugs has several cool extensions not in GHC
16:21:44 <lpsmith> hugs was very important in an easy-to-use environment to get people started
16:22:03 <kmc> i really wish Hugs could run GHC
16:22:13 <djahandarie> It'd be really nice if GHC had nice error messages
16:22:14 <lpsmith> why?
16:22:15 <kmc> imo a self-hosting compiler should always be paired with a simple C-based interpreter that can run it
16:22:15 <monoidal> is Hugs actively maintained?
16:22:28 <ivanm> monoidal: don't think so
16:22:33 <lpsmith> less and less so since GHCi came out
16:22:37 <monoidal> last stable release was 3 yrs ago
16:22:49 <djahandarie> I think some people push to it every once in awhile
16:23:01 <lpsmith> I personally stopped using hugs within a week or two after GHCi was available
16:23:05 <ivanm> with ghci, hugs main advantage is that it has a smaller footprint than GHC
16:23:14 <ivanm> in terms of file size taken up, etc.
16:23:20 <ivanm> oh, and porting is easier since it's written in C
16:23:21 <dons> not memory use though
16:23:49 <lpsmith> I mean,  Mercury has something like GHC,  vaguely, at least in terms of user experience
16:23:55 <lpsmith> but never had anything like Hugs
16:24:01 * sproingie hugs lpsmith 
16:24:14 <lpsmith> lol :)
16:24:15 <sproingie> who can't love a language called hugs
16:24:19 <kmc> a tiny portable interpreter that doesn't even do type checking could be useful for some things
16:24:49 <sproingie> woo someone could implement my -XNoTypeChecking suggestion :)
16:25:07 <lpsmith> I really do not think that Haskell would have gained as much traction if GHC was the only way to use the language
16:25:44 <kmc> -XIt'sProbablyFine
16:25:55 <lpsmith> sproingie, only problem is with Haskell,  type checking is not optional, as it affects the meaning of the program via typeclasses and whatnot
16:26:10 <sproingie> lpsmith: i make joke :)
16:26:17 <lpsmith> ahh :)
16:26:27 <monoidal> what is a good runnable introduction to FRP?
16:26:40 <sproingie> frag ;)
16:26:49 <lpsmith> SML you can ignore types,  and treat it as a dynamically typed langauge.
16:27:16 <sproingie> you'd end up with something like a really restricted lisp
16:27:17 <wli> That kind of defeats the point of SML.
16:27:24 <monoidal> reactive? Yampa? elerea?
16:27:30 <danharaj> If you want to use lisp, use lisp.
16:27:33 <danharaj> Right tool for the right job.
16:27:38 <sproingie> the yampa arcade paper is pretty decent
16:28:05 <danharaj> Or better yet, write an EDSL that copies lisp but pretend it doesn't to frazzle some neckbeards.
16:29:46 <sproingie> i never could make the leap to FRP myself.  discrete events just don't want to fit into continuous functions, at least not in my simple little brane
16:29:53 <sproingie> CHP might be a possibility
16:29:55 <epicbeardman_> danharaj: use <> instead of (), that'll throw 'em off.
16:30:40 <mauke> <cons>1 <nil/></cons>
16:30:44 <zygoloid> [$notLispHonest| (...) |]
16:31:01 <zygoloid> mauke: oh dear god my eyes i think you broke them
16:31:11 <sproingie> mauke: <cons><car>1</car><cdr><nil/></cdr></cons>
16:31:33 * zygoloid tries to figure out how to get irssi to block XML
16:32:27 <sproingie> you could write programs in xslt
16:32:30 <lpsmith> so the cdr of nil is nil,  or an error?
16:33:22 <zygoloid> sproingie: don't joke about that, i once knew someone who wanted to make the 'ultimate extensible language' as a collection of xslt which generated C
16:33:42 <epicbeardman_> zygoloid: no COBOL?
16:33:47 <sproingie> xml the ultimate
16:34:38 <epicbeardman_> XML: failing at being a human-readable and machine-readable format since 1996
16:35:29 <sproingie> it's better than EDI
16:35:31 <Gracenotes> hey, it does namespacing pretty well
16:35:46 <epicbeardman_> yeah, verbosity, too.
16:36:10 <zygoloid> XSLT: making Java look terse since 2007
16:36:22 <epicbeardman_> zygoloid: zing!
16:38:01 * Baughn pokes the type-checker with a poker. A red-hot one.
16:38:06 <kmc> danharaj, or rename your Scheme implementation because everyone knows Scheme is useless academic nonsense
16:38:21 <kmc> but dynamic languages are cool now, so this Racket language sounds pretty nice
16:39:45 <Baughn> Times like this, I can almost understand *why* they're cool. Returning the right value is easy, explaining to GHC that it's /always/ the right type is.. harder.
16:40:13 <bremner> heretic
16:41:04 <Baughn> Quite.
16:41:29 <Baughn> But I'm in trouble specifically /because/ I decided to try making a type-safe database, so I'll just have to keep fighting. :P
16:42:56 <Veinor> unsafeCoerce!
16:45:37 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26536 <- So, anyway, help?
16:45:50 <Baughn> The type-checker has me in a choke-hold, and I can't seem to get out
16:46:06 <kmc> that's a lot of extensions :D
16:46:18 <Baughn> Don't I know it.
16:46:43 <Baughn> Oh! But I think DeriveDataTypeable is unneeded.
16:46:50 <Baughn> That's sure to simplify things.
16:46:58 <kmc> dynamic types are indeed sometimes useful, but it makes sense to embed them in a statically typed language
16:47:07 <kmc> as Haskell, C#, and many others do
16:47:16 <Baughn> Anyway, right now I don't need dynamic typing.
16:47:30 <Baughn> All the information required is statically available, I just need to find a way to explain what I want.
16:48:41 <Saizan> Value is flawed
16:49:07 <Saizan> make a type function to map Map to Maybe and MultiMap to []
16:49:10 <Saizan> then you're fine
16:49:23 <Baughn> Saizan: I did that earlier. It didn't work either.
16:49:30 <Baughn> I'll show you, let's see..
16:51:18 <Saizan> mh, i can see the problem of making the parameter appear in the type of lookup
16:51:22 <Baughn> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26539#a26540 <-- Still no good.
16:52:12 <ivanm> Baughn: heh, Axman6 and tibbe are currently working on similar things
16:53:22 <Baughn> ivanm: Do you know if they're having any more success?
16:53:33 <Saizan> Baughn: you'd need to make k a parameter of that too, but you can't do it with type functions, only with fundeps
16:53:38 <ivanm> well, they're going via type families inside the class
16:53:55 <ivanm> and Axman6's approach is to have a vector backend with a mapping between key type and Int
16:53:59 <ivanm> oh, and not allowing deletions
16:54:05 <ivanm> so his approach is _very_ specialised
16:54:16 <ivanm> I think tibbe's was more like yours, and he was having some success
16:54:43 <Baughn> Saizan: I thought type functions were supposed to be a superset of fundeps?
16:54:58 <ivanm> not quite
16:55:04 <zygoloid> until we get superclass contexts i think they're a subset?
16:55:10 <Saizan> Baughn: that might be true if you don't use OverlappingInstances
16:55:14 <ivanm> I can't recall what, but there's some things you can do with MPTCs  + fundeps you can't do witih type families IIRC
16:55:29 <Baughn> I see
16:55:32 <ivanm> (or so people tell me)
16:55:48 <ivanm> the converse also applies (fundeps don't play nice with GADTs, etc.)
16:56:06 * ivanm -> uni
16:56:09 <ivanm> bye all
16:56:49 * Baughn shall now read a 15-page paper in lieu of actual documentation
16:57:34 <danharaj> It's better than documentation that thinks a single example is as good as real documentation.
16:58:51 <Saizan> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26539#a26541
16:59:03 <Saizan> danharaj++
16:59:12 <Saizan> unless is some trivial thing
17:00:32 <Baughn> Saizan: ..that simple.
17:00:43 <Baughn> Saizan: But you're not fooling me that easily. /I will still read the paper/.
17:01:01 * Baughn is not too happy with magic, anyway
17:01:34 <Saizan> assuming it typechecks :)
17:01:47 <Baughn> It does. It works, too. :)
17:01:59 <Baughn> Once I understand /why/, I can get on to the /other/ functions.
17:02:05 <Baughn> Insertion is going to be fun.
17:02:36 <Saizan> btw, it's common to use :*: for products rather than :+: which is used for sums
17:02:50 <Baughn> Yes, I thought about that a little while ago.
17:04:43 <sshc> A package requires QuickCheck >=2.1.0.3, but I already have 1.2 installed.  Will installing the more recent version break my GHC install?
17:05:03 <Baughn> It shouldn't
17:05:10 <danharaj> geeze at that hpaste
17:05:23 <Baughn> danharaj: Hm?
17:05:31 <danharaj> You know you're hardcore when your language pragma is as long as any top level declaration in your code.
17:05:58 <kmc> back in my day we just used -fglasgow-exts
17:06:14 <Saizan> UndecidableInstances, OverlappingInstances, TypeFamilies, FunctionalDependencies -- these are the only fancy ones
17:06:17 <Baughn> danharaj: If I was hardcore, I wouldn't need to have Saizan fix it for me.:P
17:06:35 <kmc> it doesn't help that every extension name in the new scheme is 500 characters long
17:06:39 <Baughn> Saizan++, by the way
17:06:46 <Saizan> cheers :)
17:06:47 <ddarius> kmc: Yes, but we also used to use -fglasgow-exts just to get LiberalisedTypeSynonyms
17:06:57 <kmc> yeah
17:07:22 <kmc> that's how the insidious liberal agenda gets you
17:07:36 <kmc> it's a slippery slope
17:07:47 * ddarius has used forall as an identifier in code.
17:08:22 <Saizan> well, as long as it's not in a type..
17:08:39 * Baughn wishes he could say "m@(Map x xs :*: ms)" in an instance head
17:08:52 <Baughn> (I can't, can I?)
17:09:29 <Saizan> you can't
17:09:44 <ddarius> Saizan: I don't think it was, but I might have done that too.
17:13:34 <jbapple> kmc: With lists, you have to chase (length xs) pointers anyway, so the savings might not be so great
17:14:01 <jbapple> But with bytestrings and arrays, you might save a lot of chasing
17:32:21 <kmc> > [() | x <- "abc"; let 'z' = x]
17:32:22 <lambdabot>   <no location info>: parse error on input `;'
17:32:27 <kmc> > [() | x <- "abc", let 'z' = x]
17:32:29 <lambdabot>   [(),(),()]
17:33:54 <orlandu63> > [() | x <- "abc", let z = x]     
17:33:55 <lambdabot>   [(),(),()]
17:34:00 <orlandu63> why did you quote z?
17:34:15 <orlandu63> oh wait ' is a valid character
17:34:16 <kmc> trying to use pattern-match failure to reject cases from a list comprehension
17:34:17 <orlandu63> nevermind
17:34:18 <geheimdienst> > [() | x <- "abc", let '''z''' = x]
17:34:19 <lambdabot>   <no location info>:
17:34:19 <lambdabot>      lexical error in string/character literal at chara...
17:34:31 <geheimdienst> > [() | x <- "abc", let '½' = x]
17:34:31 <lambdabot>   [(),(),()]
17:34:33 <Baughn> orlandu63: 'z' is literal syntax for Char
17:34:34 <geheimdienst> woah
17:34:54 <kmc> so it looks like "let" works the same in list compr. as anywhere else, which is to say it makes lazy irrefutable binds
17:34:57 <Baughn> orlandu63: z' is a valid name, yes, but 'z isn't.
17:35:14 <CakeProphet> !help
17:35:21 <geheimdienst> @cake
17:35:22 <lambdabot> Unknown command, try @list
17:35:27 <kmc> > cake
17:35:28 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:35:29 <orlandu63> Baughn: i see
17:35:39 <geheimdienst> thanks kmc. you are my cake prophet
17:35:49 <kmc> anyway you can do it thus
17:35:53 <CakeProphet> !help
17:35:56 <kmc> > [ () | 'z' <- "abc" ]
17:35:56 <lambdabot>   []
17:36:00 <kmc> CakeProphet, what do you think that will accomplish?
17:36:08 <geheimdienst> cakeprophet, try @list
17:36:11 <kmc> but i wanted to do some matching without some list-monad binding
17:36:12 <CakeProphet> @list
17:36:12 <gwern> @unlet
17:36:13 <lambdabot>  Defined.
17:36:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:36:23 <CakeProphet> geheimdienst:  ah. thanks.
17:36:46 <CakeProphet> perhaps lambdabot should link to that.
17:37:29 <kmc> what do you mean?
17:37:56 * kmc settles for the hack of «Just v <- [w]»
17:46:26 <mreh> does the state monad enforce evaluation order in the same way IO does?
17:46:38 <mreh> seeing as it has that functional dependency
17:46:49 <ddarius> mreh: Neither enforce evaluation order.
17:50:50 <AnAdorableNick> mreh: You can think of the IO monad as a series of actions that take an initial "real world / universe" value, and returns another one that is possibly changed, as well as another value, which may possibly be "()".
17:52:32 <AnAdorableNick> mreh: You can think of the IO monad as a series of actions that take an initial "real world / universe" value, and returns another one that is possibly changed, as well as another value, which may possibly be "()".
17:52:58 <AnAdorableNick> mreh: The future actions depend on the result of the "real world" value from previous actions, or from the initial real world state
17:53:01 <mreh> AnAdorableNick, I'm with that so far
17:53:08 <danharaj> It's good to be back with the flock again.
17:53:27 <mreh> I just got netsplit, so anything else I missed
17:53:43 <AnAdorableNick> Nope.
17:53:55 <mreh> IO a = (a, RealWorld)
17:54:08 * c_wraith confuses the story
17:54:15 <c_wraith> @src IO
17:54:15 <lambdabot> Source not found. Wrong!  You cheating scum!
17:54:27 <c_wraith> aww, I thought \bot knew that once
17:54:28 <mreh> shoo!
17:54:36 * ddarius very much dislikes the "state-passing" view of IO.
17:54:44 <AnAdorableNick> ddarius: Why?
17:54:47 <c_wraith> @src ST
17:54:48 <ddarius> c_wraith: It did.
17:54:48 <lambdabot> newtype ST s a = ST (STRep s a)
17:54:58 <c_wraith> was it removed to prevent confusing beginners?
17:55:04 <ddarius> c_wraith: Perhaps.
17:55:20 <AnAdorableNick> What had it originally printed?
17:55:38 <c_wraith> GHC's implementation of the IO type.  Don't worry about the details
17:55:46 <ddarius> AnAdorableNick: It doesn't generalize.  It doesn't really explain.  And it leads to a philosophical quagmire if you do try to do those things with it.
17:55:47 <AnAdorableNick> mreh: Of course, there needs to be some way of supplying the initial real world value
17:55:58 <mreh> unsafePerformIO
17:56:26 <dcoutts_> nooo!
17:56:32 <mreh> :D
17:56:35 <dcoutts_> ;-)
17:56:43 <danharaj> > unsafeCoerce 5 :: String
17:56:44 <lambdabot>   Not in scope: `unsafeCoerce'
17:56:52 <danharaj> darn. I wanted to explode the universe.
17:57:00 <ddarius> danharaj: That'd be just a mite of a security hole.
17:57:08 <danharaj> pff
17:57:26 <dons> we use type-based sandboxing, so you dont get to do that.
17:57:27 <AnAdorableNick> On my system it returns an empty string
17:57:31 <ddarius> Perhaps geordi allows you to do that.
17:57:41 <danharaj> breakEverything
17:58:18 <danharaj> I think a good litmus test for a beginner to see if they understand Haskell's type system is to show them the signature of unsafeCoerce and see how they react.
17:58:18 <mreh> question is: in the State monad, can I evaluate an expression that happens after another, first
17:58:29 <danharaj> If they don't double back, flinch, scream, start crying, and run away, they are not ready.
17:58:35 <ddarius> "The solution to all my problems!"
17:58:48 <danharaj> ddarius: Oh god.
17:58:51 <ddarius> danharaj: Or they are C programmers.
17:59:09 <danharaj> ddarius: Still not ready ;)
17:59:27 <ddarius> unsafeCoerce is a fun function.
18:00:20 <ddarius> Though I guess it's technically not a function.
18:00:26 <ddarius> (In most implementations.)
18:01:19 <AnAdorableNick> mreh: If the later expression depends on some past expression, such as the state, then the first will need to be evaluated first
18:04:25 <dcoutts_> ddarius: unsafeCoerce is a perfectly reasonable function so long as it is defined as const undefined :-)
18:04:35 <sproingie> @type unsafeCoerce
18:04:36 <lambdabot> Not in scope: `unsafeCoerce'
18:04:47 <ddarius> dcoutts_: If it were defined that way, it would be reasonable.
18:05:01 <ddarius> @hoogle unsafeCoerce
18:05:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:05:19 <dcoutts_> @djin  a -> b
18:05:20 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
18:05:22 <danharaj> I hate how bottom inhabits every type
18:05:23 <sproingie> well it is unsafe
18:05:24 <ddarius> It has to be an important function.  It gets a module all to its ownr.
18:05:35 <dcoutts_> @djinn a -> b
18:05:35 <lambdabot> -- f cannot be realized.
18:05:56 <sproingie> i unsafely spit on your so-called proofs
18:05:59 <dcoutts_> djinn uses a no-_|_ model
18:06:07 <danharaj> good on djinn
18:06:39 <sproingie> when i hit _|_ i was unsafely coercing at least four times a day
18:06:53 <dcoutts_> danharaj: we should have a pure System-F subset of Haskell with no _|_
18:07:18 <dcoutts_> but you'll have to give up recursive let and write everything with folds and unfolds
18:07:30 <sproingie> you just have to prove everything you write in it terminates, that shouldnt be so hard
18:07:50 <danharaj> sproingie: We need richer types to make that tractable.
18:07:54 <dcoutts_> pure System-F is always terminating
18:07:58 <jabb> can a list comprehension be finite?
18:08:16 <gwern> jabb: why not? alternately, what the heck do you mean?
18:08:21 <jabb> haha
18:08:26 <sproingie> [x <- [1]]
18:08:30 <Saizan> > [x + 1 | x <- [1..3]]
18:08:31 <lambdabot>   [2,3,4]
18:08:43 <Bynbo7> > [(a,b) | a <- [1,2,3], b <- "abc"]
18:08:45 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
18:09:01 <Saizan> if all the generators are finite it'll be finite
18:09:02 <sproingie> comprehend over a finite list and the comprehension will always be finite
18:09:08 <dcoutts_> danharaj: actually we don't need richer types
18:09:15 <sproingie> saizan put it better
18:09:36 <dcoutts_> danharaj: but we'd get a less expressive term language
18:10:16 <Axman6> would :!: be a valid data constructor?
18:10:30 <dcoutts_> yes
18:10:34 <jabb> http://ideone.com/wJvWy times out :(
18:11:10 <Saizan> the idea is that with richer types you've more interesting structures to fold over, so more functions can be written as folds, or maybe just more easily
18:11:16 <danharaj> dcoutts_: I though sproingie was talking about system F with some sort of guarded recursion.
18:11:54 <nwolf> hey guys, could anyone point me to a way to convert a DWORD to an Int value?
18:12:05 <danharaj> :t DWORD
18:12:06 <lambdabot> Not in scope: data constructor `DWORD'
18:12:27 <Axman6> > let fibs = 0:1:[a + b | (a, b) <- zip fibs (tail fibs)] in fibs
18:12:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:12:31 <danharaj> er, rather is DWORD an instance of Integral?
18:12:36 <nwolf> danharaj: with DWORD i mean a sequence of bytes, like "00 01 00 00"
18:12:37 <dcoutts_> danharaj: if you're using straight System F then you don't need anything extra, it's already strongly normalising
18:12:47 <Axman6> > let fibs = 0:1:[a + b | (a, b) <- zip fibs (tail fibs)]; evenFibs = [x | x <- fibs, even x, x <= 4000000] in evenFibs
18:12:49 <nwolf> that stands for... 256
18:12:51 <lambdabot>   mueval-core: Time limit exceeded
18:12:55 <Axman6> o.O
18:13:02 <Axman6> wait, are there any even fibs?
18:13:12 <jabb> yeah
18:13:13 <Axman6> apart from 2
18:13:14 <c_wraith> 2, 8 etc
18:13:14 <jabb> 2 8
18:13:18 <jabb> 34
18:13:19 <Axman6> yes, ok
18:13:24 <c_wraith> every third fib should be even
18:13:26 <Saizan> list comprehensions don't know that :)
18:13:33 <Axman6> aye
18:13:44 <Axman6> > let fibs = 0:1:[a + b | (a, b) <- zip fibs (tail fibs)]; evenFibs = [x | x <- fibs, even x, x <= 4000000] in take 4 evenFibs
18:13:46 <lambdabot>   [0,2,8,34]
18:13:52 <danharaj> dcoutts_: Right, but if we wanted to add a more general recursion scheme where we have to prove our recursion is well founded, I think we need richer types to make proving things more tractable.
18:14:10 <dcoutts_> danharaj: right
18:14:14 <Axman6> > let fibs = 0:1:[a + b | (a, b) <- zip fibs (tail fibs)]; evenFibs = [x | x <- fibs, even x] in takeWhile (< 4000000) evenFibs
18:14:16 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578]
18:14:40 <Axman6> > let fibs = 0:1:[a + b | (a, b) <- zip fibs (tail fibs)]; in takeWhile (< 4000000) . filter even $ fibs
18:14:42 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578]
18:14:56 <dcoutts_> danharaj: then you start going down the dependently typed route, or alternatively instead of richer types use proofs on the side
18:14:57 <jabb> cool bot
18:15:11 <Axman6> > let fibs = 0:1:zipWith (+) fibs (tail fibs); in takeWhile (< 4000000) . filter even $ fibs
18:15:12 <jabb> so x <= 4000000 as a filter in list comprehension is...?
18:15:13 <lambdabot>   [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578]
18:15:20 <Axman6> yes
18:15:37 <Axman6> filter p xs = [x | x <- xs, p xs]
18:15:38 <jabb> ahh right
18:15:46 <jabb> it keeps going through the infinite list
18:15:56 <jabb> it doesn't stop, d'oh me
18:15:56 <danharaj> dcoutts_: I think it is probably better to use dependent types, so that types can carry information relevant to proving. What do you think?
18:17:01 <danharaj> He who laughs last, thinks longest.
18:17:10 <dcoutts_> danharaj: maybe, I'm not sure we know yet, I don't think we've built big enough programs to really know how it works out
18:17:31 <danharaj> dcoutts_: Fair enough point. But why should reality stop us from having opinions :p
18:17:40 <dcoutts_> danharaj: try both! :-)
18:17:40 <ddarius> monochrom is knowledgeable about the alternative approaches.
18:22:19 <danharaj> nwolf: DWORD is a type synonym for Word32, Word32 is an instance of Read, so you can use the read function.
18:22:21 <danharaj> :t read
18:22:22 <lambdabot> forall a. (Read a) => String -> a
18:22:57 <danharaj> nwolf: Why are you working with the win32 api anyway? you either have balls are a streak of masochism.
18:23:04 <danharaj> or*
18:23:35 <nwolf> danharaj: i'm actually parsing a 24bits bitmap file, to split the RGB files
18:23:51 <danharaj> nwolf: Fair enough.
18:23:56 <nwolf> unfortunately, for that i need the image width, that's stored on a dword 
18:24:05 <nwolf> *rgb channels
18:24:30 <nwolf> but thanks, i'll take a look at that!
18:24:34 <Saizan> maybe go with binary or cereal
18:26:42 <danharaj> A Haskell cereal would have lambda shaped marshmallows.
18:27:31 <Veinor> om nom nom
18:29:08 <pelotom> n00b question: how do I write a main function that reads lines from input until EOF?
18:32:47 <gwern> pelotom: from std in?
18:32:49 <gwern> getContents
18:32:56 <pelotom> yeah
18:33:54 <pelotom> that returns a full string, I just want to read input 1 line at a time
18:34:11 <dibblego> how does one invoke lambdabot's unlambda plugin?
18:35:08 <geheimdienst> pelotom, try getLine: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#v%3AgetLine
18:35:33 <napping> pelotom: if you are happy using getContents, then just apply lines
18:35:46 <gwern> or interact!
18:35:53 <geheimdienst> ("lines" is a function from prelude)
18:35:59 <c_wraith> main = fmap lines interact
18:36:12 <pelotom> ahh, ok, that's what I needed :)
18:36:16 <pelotom> thanks folks
18:36:21 <ddarius> c_wraith: That's a type error.
18:36:22 <Axman6> :t interact
18:36:23 <lambdabot> (String -> String) -> IO ()
18:36:24 <ddarius> :t interact
18:36:25 <lambdabot> (String -> String) -> IO ()
18:36:27 <c_wraith> oh
18:36:30 <c_wraith> right.
18:36:31 <c_wraith> so it is
18:36:36 <c_wraith> main = interact lines
18:37:01 <ddarius> c_wraith: Still a type error.
18:37:03 <gwern> I like interact a lot
18:37:06 <Axman6> main = interact (map foo . lines)?
18:37:14 <geheimdienst> c_wraith, uh, what exactly would that program do?
18:37:23 <ddarius> processLines f = interact (unlines . map f . lines)
18:37:27 <c_wraith> if it worked?  Nothing. :)
18:37:45 <napping> pelotom: lazy IO doesn't hold up so well if you want to work with files, but I the abstraction works pretty well for stdin/stdout
18:37:51 <geheimdienst> ok good. side-effect-free then. yay!
18:37:57 * wli usually likes to fart around with readline but probably needs to learn the haskeline or whatever API at some point, assuming it can do the equivalent.
18:38:00 <ddarius> :t fmap lines getContents
18:38:01 <lambdabot> IO [String]
18:38:10 <c_wraith> I was thinking interact' :: Show a => (String -> a) -> IO ()
18:38:10 <napping> geheimdienst: produces some one-character result per line, of course
18:38:36 <napping> geheimdienst: surely you can deduce the type of foo from knowing (map foo . lines) :: String -> String ;)
18:38:40 <geheimdienst> :t interact'
18:38:40 <pelotom> napping: I will be using stdin with a huge input
18:38:41 <lambdabot> Not in scope: `interact''
18:38:51 <c_wraith> geheimdienst, I was making something up
18:38:53 <napping> wli: there's also rlwrap
18:39:09 <geheimdienst> because that interact' might be handy at times ...
18:39:20 <napping> pelotom: you can indeed maintain constant memory usage with getContents
18:39:54 <pelotom> napping: sweet
18:40:03 <wli> Some kind of crude command interpreter (even if it doesn't allow any structured language or whatever) is common enough I want stuff like dorking with the prompt and keeping some idea of whether I'm continuing multiline input or whatever.
18:40:22 <aavogt> wli: haskeline doesn't do multiline editing
18:40:35 <aavogt> readline does apparently
18:40:41 <napping> pelotom: hmm, if you are quite new I should warn you to be careful about integer variables - ask the channel if you are getting leaks
18:41:24 <napping> wli: invoking your program through rlwrap is the cheapest way to get history and line editing.
18:41:43 <napping> It's quite an increment to get smart completion, or any semantically aware multiline stuff
18:41:44 <aavogt> I mean where the input command contains actual \n
18:42:16 <napping> for that matter, I can't think of any command line tool that actually lets one edit multiple lines of input at once (besides curses-style editors)
18:42:26 <wli> aavogt: readline doesn't do so in a good way but basically the multiline affair I'm on about is remembering in my own code that I'm getting some follow-on to the whatever the previous line was (it's always in a dumb fashion).
18:42:38 <napping> now, changing the prompt when you are inside an incomplete construct is quite common
18:43:03 <wli> napping: zsh is the uber-example but there are dumb far-less-functional sorts of things like what you just said
18:43:18 <napping> what does zsh do with multiple lines?
18:43:39 * hackagebot cuboid 0.13 - 3D Yampa/GLUT Puzzle Game  http://hackage.haskell.org/package/cuboid-0.13 (PedroMartins)
18:44:20 <napping> A suppose a toolkit could let you have multiple lines of "current input", and feed it back to the program to see if it's complete whenever you hit enter
18:44:24 <napping> might be interesting
18:45:52 <c_wraith> alexyk, awesome bug you uncovered in ghc. :)
18:45:58 <napping> Hi alexyk. What are you working on?
18:46:15 <wli> napping: It's kind of like nesting of line ownership or something.
18:46:34 <wli> napping: Incomplete constructs break into a new level of nesting.
18:46:34 <gwern> c_wraith: one could argue that so rare a bug isn't very awesome
18:46:56 <pelotom> integer variables lead to leaks?
18:47:15 <napping> wli: yes, but you can only actually edit one line at a time
18:47:28 <wli> napping: So anyhow yeah it's like the "multiple lines of current input." 
18:47:55 <gwern> c_wraith: I do like that we have a dollar amount on how much it cost to find, though
18:47:58 <napping> in particular, you can handle it just by getting a string from getLine, then deciding what prompt to print before you request another line of inpjut
18:48:01 <gwern> that's funny
18:48:23 <gwern> I also wonder - does amazon actually have a couple servers sitting around with 80 gb of ram slotted into the motherboard?
18:48:33 <wli> napping: Scrollback through command history has to do things like dump all the lines associated with that history element onto the editing arena.
18:48:44 <gwern> or are those instances split somehow over many smaller computers
18:49:14 <napping> wli: ah, that's different. That would take a bit closer integration. Most things I've seen just have you repeat the lines one by one
18:49:20 <c_wraith> gwern: I meant more awesome as in "that's a kind of hilarious bug.  Both in concept, and in actually running into it."
18:49:29 <wli> napping: zsh does it the smart way I've said
18:49:38 <napping> To get that you'd have to mess with the most recent history entry.
18:50:48 <wli> napping: I'm pretty sure the structure is kept intact over a rather broad spectrum of data structures but zsh's code is horrible (why do shell writers write such terrible code?) so I can't be sure.
18:51:51 <napping> wli: ah, it doesn't actuall add the construct to history until the whole thing is done - so you can get the same effect in haskeline easily (the public API doesn't let you easily edit history)
18:53:24 <wli> napping: Sounds cool to get zsh-level editing if it's possible; I'd almost need to have a command language to interpret to have something to do it with.
18:59:48 <delusion42> Would a kind soul take a peek at a MonadTrans instance for a simple iteratee type and tell me where I'm going wrong? (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26542 if so)
19:02:41 <Axman6> @tell ivanm http://www.reddit.com/r/haskell/comments/cis3d/aushac2010_the_first_australian_haskell_hackathon/
19:02:41 <lambdabot> Consider it noted.
19:03:42 <pelotom> how would I do a regex find/replace on a string?
19:03:46 <alexyk> c_wraith: did I?  I didn't hear from Simon yet
19:03:55 <pelotom> I tried this: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.regex
19:03:58 <alexyk> napping: data mining Twitter graphs
19:04:03 <pelotom> but it doesn't seem to find the module
19:04:28 <pelotom> Could not find module `Text.Regex.Posix':
19:05:02 <napping> pelotom: the comments suggest you might need an extra package. What distribution of haskell are you using?
19:07:05 <pelotom> I GHC 6.12.1
19:07:47 <pelotom> I have*
19:07:48 <napping> are you using the platform release, something from your linux distribution, or the plain ghc installer?
19:08:16 <napping> pelotom: here is hackage: http://hackage.haskell.org/packages/hackage.html
19:08:18 <pelotom> I just built GHC from source
19:08:38 <pelotom> I tried installing the platform but it failed due to some OpenGL library problem
19:09:00 <napping> okay, then no reason not to just use cabal (if it was a distribution package you might want to try to get libraries through your package manager)
19:09:21 <napping> searching in hayoo says Text.Regex.Posix comes from the regex-posix package
19:09:45 <napping> so just try "cabal install regex-posix" (or "cabal install --user regex-posix" if you don't want to install system-wide)
19:10:16 <pelotom> don't have cabal
19:10:33 <napping> no? hmm, how do you bootstrap it again?
19:11:10 <pelotom> I downloaded the GHC source, configured and make installed... I'm not sure how it compiled
19:11:28 <napping> well, then you have Cabal proper, but not the handy installer utility
19:11:53 <pelotom> d/oh
19:12:21 <c_wraith> alexyk, he posted on -cafe about it
19:12:28 <napping> that means you can still use the "runghc Setup.hs configure; runghc Setup.hs build; runghc Setup.hs install" to build packages
19:12:31 <napping> http://hackage.haskell.org/package/regex-posix
19:12:51 <napping> here's the regex-posix page. you could try downloading and building that, but I'm not sure you'll have all the deps
19:13:19 <geheimdienst> i think the best path would be to get cabal first (cabal-install)
19:13:19 <alexyk> c_wraith: ah ok, thx
19:13:21 <napping> ah, here we go: http://haskell.org/haskellwiki/Cabal-Install
19:13:56 <napping> instructions are there for getting the cabal tool - they have a handy bootstrap.sh which fetches its few dependencies
19:15:48 <pelotom> k, running bootstrap.sh now
19:16:41 <delusion42> Has anyone had problems with simple iteratee implementations skipping stream elements as a side-effect of lift? :( I think I'm missing someting. (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26542 if so)
19:18:51 <napping> wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26543#a26543
19:19:05 <napping> unfortunately, haskeline doesn't handle history entries containing newlines very gracefully
19:19:21 <wli> napping: ooh neat
19:19:34 <bcw> hi all. what books would you recommend to learn Haskell?
19:19:54 <napping> perhaps better Pref would help
19:20:21 <napping> anyway, that's all the logic your program needs to get zsh style behavior, if the console library handles it's end of the job
19:21:17 <bcw> (i'm coming from a mostly imperative programming background, but i do already know a little about Haskell and some other languages like Prolog)
19:21:44 <kmc> bcw, LYAH and RWH are the most popular
19:21:45 <pelotom> napping: that worked, I got the regex package, thanks!
19:21:45 <kmc> @where RWH
19:21:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:21:47 <napping> haven't used any myself. what have you looked at online
19:21:47 <kmc> @where LYAH
19:21:48 <lambdabot> http://www.learnyouahaskell.com/
19:22:00 <napping> pelotom: great. cabal install is quite handy
19:22:01 <kmc> RWH comes free online and also in paid dead-tree or ebook form
19:22:25 * wli wishes he had something to write about
19:22:53 <pelotom> aaaand it failed to load some system library for posix parsing
19:23:34 <Axman6> bcw: start with LYAH. might seems childlike, but it is a very good introduction to the main concepts of programming haskell
19:23:40 <Axman6> seem*
19:23:42 <bcw> kmc, ok, thanks.  i have read LYAH already, and some of RWH, and even the wikibook.org  version.  but i'm having a hard time wrapping my head around the monad and other more advanced concepts, none of these books seem to explain it well.
19:23:44 <napping> wli: haskeline editing with multi-line history entries is very bad, but you see the logic
19:24:11 <Axman6> Monad isn't hard, it's just misunderstood. monads are a hell of a lot easier to use than understand
19:24:37 <geheimdienst> yes, just start writing something. the understanding will come
19:24:37 <kmc> bcw, maybe you've run into "the monad tutorial fallacy"
19:24:39 <pelotom> they're just a monoid in the category of endofunctors, what's the problem?
19:24:39 <kmc> @where burrito
19:24:39 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:24:40 <kmc> bcw, ^^^^
19:25:02 <bcw> Axman6, ok. thanks as well,
19:25:13 <bcw> kmc, maybe so
19:25:26 <kmc> some of the better monad tutorials are 
19:25:27 <kmc> http://haskell.org/haskellwiki/Monads_as_containers
19:25:31 <kmc> http://haskell.org/haskellwiki/Monads_as_computation
19:25:34 <napping> bcw: what pelotom says. It's abstract nonsense, analogies are not so helpful, the interesting question is what things are instances
19:25:46 <napping> bcw: IMO, some of Wadlers original papers are still the best introduction
19:25:46 <kmc> i'd recommend starting by defining your own Maybe-like type, and the Monad instance for it
19:25:56 <geheimdienst> pelotom, i prefer to think about them as burritoid in the category of endofunctors
19:26:03 <kmc> don't worry too much about "what monads really are", just look at the types in the class and how you'd implement it for your type
19:26:13 <aavogt> look at laws
19:26:34 <kmc> the laws are clearest stated in terms of (>=>)
19:26:46 <kmc> (a >=> return)  ===  (return >=> a)  === a
19:26:59 <kmc> (a >=> (b >=> c))  ===  ((a >=> b) >=> c)
19:27:12 <kmc> which happen to be the laws for a category, too
19:27:14 <bcw> kmc, i will read those articles.  thanks again
19:27:30 <napping> bcw: http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#essence
19:27:31 <kmc> that is, the monad laws boil down to "m satisfies the Monad laws iff (Kleisli m) satisfies the Category laws"
19:27:38 <pelotom> and that category is the kleisli category
19:28:09 <geheimdienst> kmc, thanks for clearing that up ;-)
19:28:27 <pelotom> hehe
19:28:30 <bcw> i have no idea what most of the terms being talked about here mean...
19:28:48 <kmc> yeah
19:28:59 <pelotom> bcw: don't worry about it, if you spend a lot of time learning them you might enjoy the process but it won't make you a better programmer in the end
19:28:59 <kmc> "what's a monad", "what's a kleisli category" are traps for beginners
19:29:13 <andrewsw> bcw: you're not alone. just keep reading. some of it will make sense eventually (Or so I understand)
19:29:27 <pelotom> or maybe it will, who knows
19:29:32 <bcw> ok, thanks for the encouragement all
19:29:40 <kmc> just think about the functions in the type class "Monad", and how to use them, and how to define them for some simple types (Maybe, (Either e), lists, etc.)
19:29:46 <delusion42> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26543#a26543 Anyone? Anyone? I'm probably annoying people by now by continuing to spam it ;P
19:30:06 <napping> well, some of the universiality stuff can help at least understanding *why* things work
19:30:19 <kmc> bcw, and if you have more specific questions, don't hesitate to ask here
19:30:26 <delusion42> bcw: it might help if you forget about the Monad typeclass stuff altogether and just try to make a simple monad (e.g., for a Maybe-like type) just using normal functions and type declarations
19:30:31 <kmc> questions about code are more likely to be useful than questions about intuition
19:30:41 <kmc> because intuition doesn't map very well between people
19:30:54 <napping> delusion42: um, that seems to be my paste about haskeline?
19:31:13 <delusion42> napping: whoah, cut & paste error, sorry.  I meant: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26542 =)
19:31:18 * edwardk waves hello,
19:31:27 <kmc> hi edwardk
19:31:41 <napping> I was confused a bit, because I still had the paste open and thought the link wasn't working for a bit
19:31:43 * edwardk finally gives up and decides to write a 'pretty' linear algebra library
19:31:49 <delusion42> napping: hehe
19:31:57 <bcw> i don't have many specific questions right now. i really need to do some reading that isn't cut up like IRC, since it's been a while since I've used Haskell anyway
19:33:10 <napping> bcw: the point of all the math talk, I guess, is that a "monad" is an idea in it's own right, which might be handy to apply at times, but explanations by analogy tend to be incomplete
19:33:38 <bcw> yes, i see that much
19:33:49 <edwardk> What I want is something that looks like a pure linear algebra library, but which secretly uses mutation behind your back. Track each matrix as an IVar of its pure result and the expression tree. Evaluate transitively as needed purely, but if you don't force the tree, then various combinators can run your linear algebraic expression using mutation behind the scenes
19:34:43 <napping> delusion42: your run function looks suspicious
19:34:58 <delusion42> napping: oh?
19:34:59 <edwardk> that way you get the ability to have things like dot products, etc that return scalar values, and the ability to have it use mutation-heavy blas/lapack primitives, and the ability to have an API that feels like you're just manipulating pure values.
19:35:08 <napping> I don't even see how it's well typed - looks like the body is built by applying ContT
19:35:22 <napping> wait, wtat is it supposed to do?
19:35:31 <kmc> yeah, it's not that there are good analogies for monads; "monad" itself is a good analogy for lots of things
19:35:40 <delusion42> napping: it's just supposed to advance the iteratee one step given a stream input
19:35:41 <napping> I do no expect a run<Monad> function to include <Monad> in the result type
19:35:54 <napping> that's more like a "throw away exisitng input stream and replace with anoter"
19:36:03 <delusion42> napping: IterM is a monad, I just didn't show instance
19:36:08 <delusion42> napping: Ah, hrm.
19:36:34 <napping> runIterM should have a type like IterM el m a -> Stream el -> m a (or maybe (m a, Stream el)), or I will be very confused
19:36:50 <napping> not to say a function like this one might not be useful elsewhere
19:36:59 <napping> is it mean to be something like a "skip one input" function?
19:37:04 <delusion42> napping: Okay, I'll take a look at it. What's there works just right for everything so far unless there's a lift involved, and then the stream gets off-by-one (per lift invocation)
19:37:16 <delusion42> napping: No, it's certainly not, so I'm probably missing something.
19:37:34 <napping> lift looks just fine. It will run some M stuff without modifying the stream
19:37:38 <geheimdienst> bcw, i recommend to start writing a little code. the understanding will come. if i had first of all tried to understand things theoretically from books, i would have long gone crazy
19:37:57 <napping> presuming your monad instance is sensible
19:38:05 <delusion42> napping: except for the fact that i can do (return ()) in one spot and (lift $ return ()) in the same spot and have completely different results in the witnessed stream
19:38:11 <bcw> geheimdienst, yeah, i'll do that too
19:38:20 * hackagebot generators 1.0.3 - Actually useful monadic random value generators.  http://hackage.haskell.org/package/generators-1.0.3 (LiamOConnorDavis)
19:38:40 <delusion42> well, the monad instance uses runIter, so if there's something obviously wrong about that, it might explain it. It doesn't explain how everything else seems to work 'as expected', though.
19:38:41 <napping> delusion42: then I suspect your bind
19:38:45 <aavogt> sounds pretty cynical
19:38:47 <napping> oh, runIter is weird
19:38:51 <napping> it throws away the input stream!
19:39:08 <edwardk> hrmm anyone here interested in hashing out a design for that library?
19:39:09 <napping> post the monad instance
19:39:11 <delusion42> ...how does it do that? it's applying k to it
19:39:16 <delusion42> napping: ok
19:39:31 <napping> it throws away the stream the ContT got, so funny stuff will happen if it's sequenced with other stuff
19:39:48 <napping> why do actions get the whole Stream to mess with anyway?
19:39:56 <ivanm> edwardk: which library?
19:39:58 <bcw> i'm off to read for a while, be back when i have questions
19:40:08 <bcw> (and write some code, probably)
19:40:13 <edwardk> ivanm: designing a new linear algebra blas/lapack binding
19:40:16 <napping> a traditional resumption monad would just have (el -> m (IterM ..)) in the "ask for input" case, but I could see this helping performance
19:40:25 <ivanm> edwardk: I take it you don't like hmatrix?
19:40:42 <napping> edwardk: ooh, I messed around a bit with something like that once
19:40:45 <delusion42> napping: this isn't using ContT though...although it is holding onto a continuation for the iteratee stuff
19:40:47 <napping> in C, though
19:40:58 <delusion42> it's fed stream elements via the enumerator elsewhere
19:41:01 <napping> delusion42: resumptions are a wee bit simpler.
19:41:19 <ivanm> edwardk: IIRC there's another blas bindings library on hackage
19:41:22 <napping> data Resumption x a = Done a | Ask (x -> Resumption a) -- processes that can get items of input, or just make results
19:41:23 <delusion42> napping: okay, monad instance is up
19:41:24 <edwardk> ivanm: i want something faster, cleaner, and without gpl entanglements. i talked to the hmatrix guys and they are willing to switch it over to bsd and split out the gsl bits, but i think a cleaner lib can be build using very dirty tricks
19:41:31 <edwardk> ivanm: yes, both are very straightforward
19:41:34 <ivanm> hmmm...
19:41:48 <napping> edwardk: that is, building up an expression tree and trying to optimize a bit before actually running
19:42:13 <edwardk> napping: that is exactly it. =) though you need to do some dirty tricks there as well, because things like dot products return scalars that are going to be outside of the expression tree
19:42:30 <wli> edwardk: We're going to NIH GSL? The numerical linear algebra could get hairy.
19:42:32 <edwardk> napping: so i think ideally you need to have an expression that is either evaluated or unevaluated using dirty ivar-like tricks
19:42:38 <ivanm> edwardk: would you be using vector or a custom type?
19:43:16 <napping> delusion42: yeah, that's very fishy
19:43:41 <edwardk> ivanm: i would be using something i can hand off to blas directly. there is a possibility that i can provide a thin vector <-> dense blas vector transformer, but i want the arity of the vector encapsulated in the type
19:43:42 <napping> bind always pipes the thing hidden into a Done into the next expression, and return always makes a Done with an empty stream
19:43:52 <wli> edwardk: Actually I think there's a lot of it that could get very hairy very quickly but the numerical linear algebra is the workhorse stuff people are going to trip over first.
19:43:58 <napping> so in particular (stuff >> (return () >>= more stuff)
19:44:14 <edwardk> wli: i plan on pawning off much of the actual algorithm work on blas/lapack
19:44:17 <napping> will do something like truncate the input stream when you hit the return () (even if we pretend everything else will work)
19:44:29 <delusion42> napping: that's how the iteratee tutorial does it, or at least i think so 
19:44:33 <ivanm> edwardk: hmmm... have you talked with roman about this?
19:44:37 <ivanm> hey TacticalGrace
19:44:39 <edwardk> wli: what i want is something that looks like you're tossing around pure matrices, but which internally uses the very dirty imperative matrix routines
19:44:50 <delusion42> napping: let me post the version for pure iteratees that i based this one on
19:44:52 <napping> delusion42: no.
19:45:01 <edwardk> ivanm: not yet, it has quite a bit different design goal than vector,
19:45:49 <edwardk> wli: i've also had the privilege/terror of doing a lot of work with lapack in the past
19:45:50 <ivanm> well, if you ask him nicely you might be able to convince him to try and get lapack and blas operability stuff into vector, <shameless plug>maybe at AusHac or something</shameless plug>
19:45:53 <napping> delusion42: if nothing else, return might be (ContT $ \stream -> Done x stream)
19:45:57 <napping> so you don't lose the input
19:46:05 <wli> edwardk: That might actually be faster than GSL's C depending on how smart you are about marshalling Fortran arrays.
19:46:08 <delusion42> napping: do you mean ContM?
19:46:13 <edwardk> ivanm: that sounds like a pretty terrible idea actually. =) the types for blas/lapack are dreadfully limited.
19:46:20 <napping> sure, the constructor
19:46:26 <ivanm> well, some kind of conversion stuff or whatever
19:46:52 <ivanm> edwardk: reason I'm suggesting this is that I found it a pain that hmatrix used its own type; we need to halt this dreadful type profileration for common underlying types!
19:47:00 <ivanm> or at least have common ways of working with them
19:47:57 <napping> delusion42: wait, iteratees should not be getting access to the entire stream anyway
19:48:09 <delusion42> napping: they don't, a stream is just one element at a time
19:48:10 <napping> delusion42: it really should be ContM (el -> m ...) and Done a
19:48:16 <edwardk> ivanm: well, what i want is something i can provide nice guarantees about the resulting computation from. i can't get there with hmatrix's or vector's lack of shape information in the type. type proliferation in this case, is going to happen
19:48:20 <napping> delusion42: but you pass an entire stream into the thing inside ContM
19:48:33 <edwardk> premature standardization is like premature optimization ;)
19:48:43 <ivanm> heh, fair enough
19:48:51 <napping> delusion42: the whole point of the iteratee approach is that the source of values need never be materialized as a data structure (even through unsafe laziness tricks)
19:48:53 <delusion42> napping: then the tutorial seems to be wrong and/or i can't suss out what was meant by "the monad instance for IterM is basically the same as for the pure version"
19:49:04 <delusion42> napping: i realize that
19:49:04 <napping> what they mean is you do like this
19:49:04 <ivanm> edwardk: you mean something like how arrayList is?
19:49:20 <delusion42> napping: a stream is just a single element here, i promise; the enumerator passes a character at a time from a file handle for example
19:49:34 <napping> oh, so it is
19:49:49 <delusion42> napping: let me put up a sample enumerator too 
19:49:49 <napping> well, then you don't need to hide one inside the Done, I think
19:50:07 <edwardk> ivanm: arrayList?
19:50:16 <ivanm> or is it listarray?
19:50:17 <napping> now I'm very confused why it's not just runIter (ContM k) stream = k stream
19:50:19 <ivanm> @hoogle listarray
19:50:20 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
19:50:20 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
19:50:23 <edwardk> listarray =)
19:50:27 <ivanm> whatever it is
19:50:33 * ivanm has obviously tutored too much Java
19:50:37 <napping> hmm, that's for when you try to feed a value into a thing that doesn't need to hold lit
19:51:17 <napping> what is the Empty case for, again?
19:51:37 <edwardk> ivanm: the reason this came up was i realized i can invert some of the wrappings of types in my AD library -- if i had a decent linear algebra library, and be able to work with taylor series/automatic differentiation of matrices.
19:51:48 <edwardk> ivanm: which can then let me use blas routines internally
19:51:55 <ddarius> None of the extant ones suffice?
19:52:05 <delusion42> napping: i'm still trying to figure that out; i think it's a leftover from the pure version?
19:52:19 <delusion42> napping: this is from the iteratee step by step tutorial from the monad reader 16
19:52:47 <delusion42> napping: if you're willing, the pure version of the monad instance is up there now; the idea was that it was supposd to be pretty similiar to the monadic version.
19:52:49 <edwardk> but that plumbing won't work with the existing bindings, or if it does, would be dreadfully inefficient. since they either try to pretend everything is pure and copy their hearts out, or they go all out imperative and cost me access to any pretty functional reasoning tools
19:52:58 <ivanm> ddarius: IIUC, they would suffice but he figures he might as well write something better
19:53:02 <edwardk> ddarius: fraid not. i spent the whole day trying out the other libraries
19:53:16 <ivanm> similar to bos' functional yak shaving that gave us mwc-random, statistics and criterion
19:53:17 <ivanm> ;-)
19:53:38 * hackagebot eprocess 1.5.0 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.5.0 (FernandoBenavides)
19:53:53 <edwardk> ivanm: yeah, i've been on a similar small modular code reuse kick. hence the proliferation of small packages out of me of late
19:54:17 <ivanm> except for a comonadic one? :p
19:54:30 <edwardk> ivanm: nah, that one is boring to me ;)
19:54:44 <edwardk> though, amusingly i do almost have a 'comonads' package for hackage ready
19:54:59 <delusion42> napping: i think in this implementation empty is just to differentiate from EOF and is used for the monad's return, since eof is treated specially by the "IterM el m a -> m a" function
19:55:06 <edwardk> which will be just the fiddly comonadic bits out of category-extras which don't require crazy type extensions
19:55:09 <delusion42> Empty*
19:55:19 <edwardk> i.e. a small enough core that it could be standardized without pain
19:55:27 <ivanm> and IIRC, in bos' case it was more along the lines of "I need to benchmark text; there aren't any good benchmarking libraries so I'll write one.  To write one, I'll need a good statistics library; there aren't any so I'll write one.  For a statistics library, I'll need a good PRNG; I don't like any that are already out there so I'll write one"
19:56:06 <ivanm> edwardk: what are you classifying as a "crazy" type extension?
19:56:16 <napping> delusion42: I'm confused. EOF and Elem are enough to tell iteratee whether the data source is exhausted. It's Cont vs. Done that tells the enumerator whether the iteratee is satisfied
19:56:36 <edwardk> ivanm: heh, well i wanted a general purpose scientific computing library with nice bounds and hard guarantees that the answer lied within the bounds, that let me to want to use taylor models, which use my ad library, and which then need an interval arithmetic library, which then needs decent fixed precision arithmetic with known rounding
19:56:48 <delusion42> napping: he has a function to take the last step explicitly, for enumerator composition
19:56:51 <ivanm> heh
19:57:22 <delusion42> napping: i.e., the function is what sends the terminating EOF
19:57:30 <delusion42> napping: although i'm sure that explains the presence of Empty
19:57:46 <edwardk> which then needs support for ieee rounding modes or working hmpfr bindings, and now to the fact that it is much more efficient (by 1-2  orders of magnitude!) for me to work with taylor series/models of matrices rather than matrices of taylor series/models.
19:58:06 <edwardk> but then i lose a goodly portion of that efficiency if i use any of the existing blas bindings
19:58:12 <delusion42> napping: it's used in e.g. soe iteratees stay in the same Cont state when there's no input
19:58:21 <edwardk> or i get a horrible API. neither is a design choice i'm willing to make
19:58:53 * wli lacks vision/competence/wherewithal or something
19:59:31 <delusion42> napping: just added the length iteratee to show how it's being used
19:59:38 <wli> I've been dithering on grinding out my own multiple-precision-from-scratch and linear-algebra-from-scratch stuff for aeons and never even gotten started on any of it.
20:00:10 <edwardk> wli: i wasn't willing to design multiple precision from scratch, but i was willing to wrap hmpfr in something that offered a fairly haskelly API
20:00:25 <edwardk> http://hackage.haskell.org/package/fixed-precision
20:01:20 <edwardk> pi :: Fixed Down Double -- gives you a 53 bit mantissa'd pi rounded down. sin pi :: Fixed Near $(bits 1024) -- gives you a 1024 bit mantissa'd value, rounded to the nearest representable value, etc.
20:01:47 <edwardk> unfortunately it relies on hmpfr working, and there appears to be a bug in their bindings at the moment that I'm not smart enough to track down
20:03:42 <edwardk> wli: one of the reasons why i'd like a nice blas/lapack api is then i could mutate it to work with mpack to support Numeric.Fixed
20:05:02 <edwardk> the end result would be a fairly nice set of libraries that can work together to do scientific computing, with automatic differentiation, etc. with proper error bounds in haskell
20:05:44 <napping> delusion42: seems like the lift is the tricky part
20:06:03 <edwardk> but if i don't overcome those huge constants first, it'll never be more than a toy
20:06:09 <napping> Doen doesn't allow "m" behavior, and Cont demands input
20:06:33 <wli> Not sure what huge constants you mean.
20:06:52 <delusion42> napping: awesome =) that was my intuition
20:06:57 <edwardk> wli: well, compared to using directly AD'd fortran code for instance.
20:07:19 <delusion42> napping: i was hoping to figure out a way to execute the 'skipped' action or somesuch before returning the result of the lift
20:07:19 <edwardk> wli: or using COSY Infinity, which supports taylor models directly in a more imperative setting
20:07:37 <edwardk> wli: the haskell code that i have would be an order of magnitude or two slower.
20:07:58 <edwardk> wli: hence why i want to do everything i can to reduce that difference to a small constant factor without losing the pretty api.
20:08:13 <delusion42> napping: it could also just be my trying to make the representation more simple; the tutorial had a newtype wrapper Iteratee el m a = Iteratee { runIter :: m (IterInternal ...) } 
20:08:26 <napping> oh, yeha
20:08:31 <delusion42> napping: so you can have an iteratee express computation without needing input
20:08:36 <napping> exactly
20:08:44 <delusion42> napping: so i think in my attempt to avoid the newtype wrapper, i made lift impossible to write?
20:09:09 <napping> more or less. You can't lift things into Done because it can't have m, you cant lift nicely into Cont because it eats input
20:09:21 <napping> you try to hack around a bit with stuffing an unused input into done
20:09:34 <napping> and I guess that's where you make up Empty, for when you don't really have input
20:09:37 <delusion42> napping: gotcha. Done originally carried (m a) instead of a, but that caused other problems ...
20:09:46 <napping> like being able to bind
20:09:52 <napping> I think the newtype is the best way to go
20:10:10 <delusion42> napping: okay, it's starting to make sense; i took it for syntactic clutter that was only going to confuse me when i first started going through this
20:10:13 <napping> then you just have Done a | Cont (Item el -> Iteratee el m a), where Iterateee is the newtype hiding the m
20:10:18 <delusion42> napping: thanks muchly for your help :)
20:10:34 <napping> I think an alternate solution is to add a third constructor for the places you have m actions
20:10:54 <delusion42> napping: ah, a DoThenDone or somesuch
20:14:42 <napping> here, check this
20:15:40 <delusion42> napping: awesome; thanks very much.
20:15:59 <napping> I suspect the newtype will be more efficient, though
20:16:04 <delusion42> *nod*
20:16:07 * wli is unlikely to get anything done of any kind while in distress
20:17:10 <wli> (including learning)
20:18:56 * gwern is tempted to tell wli to get out of the dress if it's so uncomfortable, but guesses few would appreciate the wordplay
20:21:11 <ivanm> gwern: *groan*
20:22:24 <wli> Given how badly my appearance has declined the imagery won't sit well either (reversing that is unlikely to happen until some sort of miracle occurs too)
20:22:50 <gwern> all the more reason to disrobe
20:24:57 <napping> delusion42: I added an example and main
20:26:33 <napping> delusion42: actually, constructor tagging is good up to 3 constructors even on 32 bit, and three constructors avoids going through the wrapped monad unecessarily, so it might be faster in some cases
20:29:16 <napping> alexyk: is performance acceptable?
20:29:58 <napping> It will be fast enough if you have been building -fvia-dons
20:30:21 <wli> I wonder if I can figure out how to get lhs2TeX to cooperate with getting multiple literate haskell source files integrated into one document.
20:30:32 <napping> what's the trouble?
20:30:44 <napping> header and footer getting in the way of \include{} from the master file?
20:30:47 <ivanm> wli: not sure if you can get them into one document
20:30:51 <ivanm> preflex: seen kosmikus
20:30:51 <preflex>  kosmikus was last seen on #haskell 13 hours, 54 minutes and 11 seconds ago, saying: keep_learing: compare "f (x : xs) = someFun x xs" and "f xs | not (null xs) = someFun (head xs) (tail xs)". The former is better because it does not make use of partial, i.e., potentially failing, functions like head and tail. it reduces the risk of making mistakes.
20:31:00 <ivanm> wli: ^^ the person to ask ;-)
20:31:13 <alexyk> napping: in ocaml yes :) in haskell, when it works, too :) in clojure kind of slow
20:31:13 <alexyk> -fvia-dons is a valid option?
20:31:13 <alexyk> or it tries to get ahold of dons to rewrite your program for you?
20:31:15 <wli> napping: Trailing/leading garbage shows up when they're included as per the instructions in the doc file.
20:32:03 <napping> alexyk: the latter. He seems to do fine looking through generated assembly till performance is acceptable
20:32:42 <alexyk> napping: after I make sure it works correctly in all three langs, Haskell's dons' :)
20:32:44 <napping> well, not that it's an actual option, but if you can get dons to tune your stuff it will probably end up decent
20:33:28 <napping> I guess as long as you avoid String you can expect decent performance
20:34:01 <alexyk> he promised to take a look next week
20:34:12 <wli> Since I've got 2 Haskell source files and 1 LaTeX source file should I go with something like pastebin?
20:34:38 <napping> wli: you might also try processing the master file with lhs2Tex and using %input directives. Not sure if that pulls in literate code or not
20:38:00 <wli> I may have literally gotten it to work or something.
20:43:49 <wli> Master LaTeX file: http://pastebin.org/357470 Haskell file 1 (Main.lhs): http://pastebin.org/357476 Haskell file 2 (Fibs.lhs): http://pastebin.org/357477
20:48:51 <wli> Don't ask me how or why, but multiple modules lhs2TeX'd into one master LaTeX file has suddenly started working for me.
20:48:56 <napping> wli: you processed them independently?
20:49:08 <wli> napping: not quite
20:49:13 <monochrom> @remember alexyk -fvia-dons is a valid option?
20:49:13 <lambdabot> Done.
20:50:02 <napping> Ah, I see polycode.fmt has only once dirrective
20:51:00 <wli> napping: I used this makefile: http://pastebin.org/357490
20:51:33 <delusion42> napping: missed those last messages; thanks again!
20:53:06 <napping> wli: I assume the ReadOnlyOnce thing somehow prevents problems with repeated definitions. I don't see any latex that has to go in the preamble
20:54:21 <djahandarie> @pl \a b c d e f -> asks blah >>= mapM_ (\z -> z a b c d e f)
20:54:22 <lambdabot> (((((((((((asks blah >>=) . mapM_) .) . flip) .) . flip) .) . flip) .) . flip) .) . flip . flip id
20:54:27 <djahandarie> God damn it
20:54:28 <wli> napping: I'm mostly clueless. It wasn't working that I could tell a few days ago (and I was complaining) and now it mysteriously works.
20:55:42 <wli> napping: Hmm, seems to have to do with the mylhs2tex that I have sitting around, too.
20:56:00 <djahandarie> @pl \a b c d e f -> mapM_ (\z -> z a b c d e f) =<< asks blah
20:56:01 <lambdabot> flip flip (asks blah) . ((flip . ((flip . ((flip . ((flip . (((=<<) . mapM_) .) . flip) .) . flip) .) . flip) .) . flip) .) . flip . flip id
20:56:07 <djahandarie> Well that was even worse
20:56:47 <ivanm> very rarely does @pl produce nice results
20:57:05 <ivanm> unless you're aiming it at something specific and you know which variables to include/exclude
20:57:26 <ivanm> at least it isn't using Caleskell though :p
20:58:01 <djahandarie> I'm just trying to create a function which takes all its parameters then maps it over a list of functions all in some ReaderT monad
20:58:20 <djahandarie> But I don't want to list out all the variables on both sides
20:58:22 <Cale> How many is all?
20:58:32 <aavogt> use TH
20:58:37 <djahandarie> 6 in this case but it could grow
20:58:57 <aavogt> with 6 vars you probably break even
20:59:27 <napping> wli: the guide describes one way to do things
21:00:49 <napping> which includes making that mylhs2tex thing
21:01:09 <Cale> :t \a b c d e f -> mapM_ (\z -> z a b c d e f) =<< asks blah
21:01:10 <lambdabot> Not in scope: `blah'
21:01:13 <Cale> :t \a b c d e f -> mapM_ (\z -> z a b c d e f) =<< asks ?blah
21:01:14 <lambdabot> forall t t1 t2 t3 t4 t5 (m :: * -> *) b r. (MonadReader r m, ?blah::r -> [t -> t1 -> t2 -> t3 -> t4 -> t5 -> m b]) => t -> t1 -> t2 -> t3 -> t4 -> t5 -> m ()
21:01:16 <wli> napping: Yeah, it wasn't working a while ago. Now it started working.
21:01:33 <napping> I have no idea where \ReadOnlyOnce is defined
21:01:58 <napping> oh, maybe hardcoded
21:02:37 <napping> Ok, I see
21:02:45 <Cale> hmm...
21:02:50 <napping> Generated code includes a LaTeX version of include guards around the definitions emitted
21:03:05 <napping> so it's okay to \include multiple files generated from runs of lhs2TeX
21:03:45 <wli> It's probably not going to be possible to figure out why anything went wrong.
21:03:49 <Cale> djahandarie: I think the fact you have that many parameters is an indication that you need to define some proper datatypes.
21:04:01 <napping> but you will get extra in each file anyway
21:04:22 <Cale> djahandarie: If all these functions uniformly take such a large set of parameters, it's probably worth it to define a record type which bundles them together.
21:04:30 <djahandarie> True
21:05:01 <djahandarie> They don't really have much in common besides that all of those functions use them though...
21:05:08 <aavogt> @type \blah -> $(let n = 5 in do vs <- replicateM n (newName "x"); lamE (map varP vs) [| asks blah >>= mapM_ (\z -> $(foldl appE [| z |] (map varE vs)) ) |] )
21:05:09 <lambdabot> parse error on input `$'
21:05:13 <djahandarie> And not all of the functions actually use them, some of them just go ahead and discard them
21:06:53 <djahandarie> And using records would make each of those functions quite a bit messier
21:07:03 <aavogt> that TH gives type:      (r -> [t -> t1 -> t2 -> t3 -> t4 -> m b]) -> t -> t1 -> t2 -> t3 -> t4 -> m ()
21:07:19 <djahandarie> TH scares me
21:07:40 <aavogt> maybe you don't break even in terms of code length by about 20 or  so?
21:08:02 <aavogt> I left out the  MonadReader m r =>
21:09:20 <kamatsu> if i want to write 3d games in haskell, should I learn openGL?
21:09:27 <kamatsu> it seems so horrible, especially in haskell :/
21:09:55 <kamatsu> i noticed IrrHaskell on hackage, but couldn't find much more info than that
21:09:55 <ivanm> probably
21:10:13 <ivanm> there might be an SDL binding; not sure
21:10:24 <kamatsu> there is
21:10:52 <kamatsu> i've used it, but to do 3d in SDL you're back down to GL anyway 
21:11:04 <napping> um, yes. If you want to do 3d games in Haskell the only existing bindings are to opengl
21:12:10 <napping> hmm, maybe there are some higher level bindings. I don't know what Ogre or Cal3d invovle
21:13:10 <kamatsu> ah, ogre i like
21:13:14 <kamatsu> there are ogre bindings?
21:13:22 <napping> seem like some kind of scene graph things
21:13:28 <napping> hogre on hackage
21:13:33 <napping> never used it
21:20:25 <kamatsu> sadly they don't encompass all of ogre
21:20:30 <kamatsu> i could extend them
21:21:49 <kamatsu> i'll  check out the irrlicht bindings first
21:23:45 <ivanm> napping: the scenegraph package is currently unmaintained
21:23:55 <ivanm> blackdog decided he had better things to do ;-)
21:26:30 <kamatsu> if irrlicht is no good, i might just write the graphics layer in C and FFI into haskell
21:28:47 <Cale> C++ bindings tend to be extra work because you have to make sure the C++ exports a C interface.
21:30:51 <blackdog> ivanm: whert?
21:31:04 <blackdog> don't think i ever had anything to do with scenegraph...
21:31:18 <ivanm> oh? I must have gotten you mixed up with someone else
21:31:19 <ivanm> sorry
21:32:13 <ivanm> ahhh, you're Mark Wotton, the scenegraph guy is another aussie called Mark Wassell
21:32:19 <ivanm> hence my confusion
21:32:20 <ivanm> ;-)
21:32:25 <blackdog> ah, right
21:32:47 <blackdog> i'm sure he's a top bloke too :) you should probably just call us both Bruce to save confusion
21:33:39 <kamatsu> this here is the wattle, the emblem of our land, you can stick it in a bottle, you can hold it in your hand
21:34:13 <ivanm> blackdog: lol
21:34:15 <ivanm> kamatsu: Amen!
21:34:25 * Axman6 points kamatsu and blackdog towards http://www.reddit.com/r/haskell/comments/cis3d/aushac2010_the_first_australian_haskell_hackathon/ for some necessary upvotes to get more people to come to AusHac
21:34:40 <ivanm> anyone know how to calculate the minimum bounding boxes for postscript files?
21:35:15 <blackdog> kamatsu: let's leave out rules 1,3,5 and 7. we're not barbarians, after all.
21:37:13 <blackdog> Axman6: don't we already know all the haskell hackers in australia?
21:37:23 <Axman6> maybe we do, maybe we don't
21:37:38 <Axman6> can't hurt to let any we don't know about know
21:37:43 <Axman6> english++
21:38:01 <blackdog> ah, the unknown unknowns
21:38:13 <blackdog> never could work out why cheney got bollocked for that statement
21:38:23 <blackdog> makes perfect sense to me.
21:40:34 <ivanm> Axman6: any idea who down-voted it?
21:48:18 <blackh> It was me.
21:48:18 <lambdabot> blackh: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:48:23 <blackh> Only joking.
21:48:40 <ivanm> you're lucky...
21:49:48 * hackagebot x11-xim 0.0.1 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.1 (YoshikuniJujo)
21:50:03 <blackh> Axman6: I got your message. I'm re-registered.
21:50:32 <ivanm> "xim of X11 graphics" sounds weird
21:51:47 <blackdog> ivanm: probably not his first language
21:53:19 <ivanm> yeah, I guessed that
21:53:32 <ivanm> not many people start off programming with Haskell
21:53:33 <ivanm> :p
21:54:47 * wli has figured out his huge literate programming document creation issue and has no literate programs or code-using documents to create.
22:00:23 <pradtf> greetings!
22:00:57 * hackagebot hmatrix-gsl-stats 0.1.1.3 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.1.3 (VivianMcPhail)
22:01:40 <blackdog> oh, gold: http://reference.wolfram.com/mathematica/guide/FunctionalProgramming.html
22:01:54 <blackdog> i don't think it's even possible to be as smart as wolfram thinks he is...
22:02:57 <Axman6> blackh: thanks :)
22:02:57 <c_wraith> finally practical!  that's what we were waiting for!
22:03:25 <ivanm> blackdog: heh
22:03:30 <Axman6> i find FP in mathematica to be hilarious
22:03:46 * ivanm waves idly in pradtf's general direction
22:03:54 <blackh> Axman6: I fixed my mail server too. The trouble is, it's running Debian and nothing ever works in Debian.
22:04:11 <ivanm> Axman6: of course, jdh used that to attack lisp...
22:04:12 <ivanm> ;-)
22:04:21 <Axman6> blackh: ha
22:04:23 <ivanm> (no, seriously, I recall reading that he did)
22:04:55 <kamatsu> http://www.horde3d.org <-- appears simple and has a C API
22:05:08 <kamatsu> shouldn't be too hard to write haskell bindings
22:05:43 <kamatsu> someone is already writing some it seems
22:10:30 <ivanm> pradtf: I got your message
22:18:38 <pradtf> any recommendations regarding an irc chatroom to learn about ircing?
22:22:17 <ivanm> pradtf: maybe #defocus
22:23:07 <kmc> what's to learn
22:24:02 <kmc> or better put: what sort of thing do you want to learn about irc?
22:54:11 <kamatsu> what's the best way for me to learn opengl? in particular on a Linux environment
22:56:27 <dons> via the nehe tutorials?
22:57:04 <dons> http://hackage.haskell.org/package/nehe-tuts
22:57:31 <kamatsu> oh, cool, they've been ported
22:59:34 <napping> I'm not sure it's worth bothering with the Haskell bindings
22:59:44 <napping> they are thin enough to offer no particular advantage over just using C
23:00:19 <napping> and OpenGL docs are disorganized enough without having to deal with nonstandard names at the same time
23:00:52 <kmc> you're talking about Haskell's OpenGL library?
23:01:10 <kmc> or about OpenGLRaw?
23:01:29 <napping> either
23:01:47 <kmc> err they're not at all the same on this point
23:03:14 <adu> hi kmc
23:03:18 <kmc> hi adu
23:03:26 <adu> how are you today?
23:03:30 <napping> Well, if anything the sugar makes it harder to follow information that's out there
23:03:31 <kmc> pretty good :)
23:03:35 <adu> :)
23:03:56 <kmc> OpenGLRaw is an autogenerated FFI binding.  the reason to use it over writing your own FFI imports is obvious
23:04:18 <kmc> OpenGL is not a particularly thin wrapper
23:04:21 <napping> I'm thinking just of learning OpenGL
23:04:21 <adu> autogenerated? by what?
23:04:39 <adu> napping: then learn with C
23:04:40 <kmc> i don't know
23:04:51 <napping> Yeah, that's what I'm suggesting
23:04:57 <kmc> i agree that the OpenGL package takes extra learning above the C API, and that the sugar is not always well documented
23:05:05 <kmc> but i think you gain something from it
23:05:06 <napping> once you know OpenGL it may be handy
23:06:01 <kmc> i learned OpenGL in Haskell and it was extra work, yes
23:06:04 <kmc> Python might be a good choice
23:06:05 <napping> once you are writing programs complicated enough that you don't want to write them in C, then maybe try it out
23:06:20 <kmc> napping, you mean any program that uses a non-trivial data structure?
23:06:26 <napping> pretty much
23:06:45 <kmc> when i TA'd into graphics, i recommended Python for students with no particular leanings one way or another
23:06:54 <napping> which will get you all the way through e.g. the nehe tutorials, or a thick OpenGL book
23:06:58 <napping> How well are they documented?
23:07:07 <kmc> a lot of people tried to learn C++ for that class with poor results
23:07:18 <napping> C++?
23:07:20 <napping> why not C?
23:07:29 <kmc> C++ has data structure libraries?
23:07:39 <napping> the only data structure you should need to use to learn OpenGL proper are arrays
23:07:57 <kmc> right, i'm assuming you actually want to do interesting things with OpenGL
23:08:18 <napping> now, there's plenty of graphics / simulation stuff that uses all sorts of fun things
23:08:47 <kmc> some of them tried to learn C and failed similarly.  if you only know Java, it's not reasonable to learn how to do low-level memory-unsafe programming *and* to learn the OpenGL API in ten weeks
23:09:09 <napping> hmm, why even bother with pointers?
23:09:29 <napping> but yeah, if you don't know C to begin with, that might tip the balance
23:09:39 <kmc> again, I think Python is a reasonable choice
23:09:51 * hackagebot gt-tools 0.1.4.1 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.1.4.1 (MikhailPobolovets)
23:09:52 <kamatsu> i know 
23:09:55 <kamatsu> *I know C
23:09:57 <kamatsu> and i hate python
23:10:04 <napping> okay, then just start with that
23:10:05 <nealar> is there "tagged monad transformer" lib: http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html on hackage?
23:10:08 <kamatsu> should I just learn with C? or try to learn with haskell?
23:10:10 <napping> nehe tutorials, or whatever
23:10:12 <kamatsu> i know haskell well
23:10:16 <napping> learn the basic calls and stuff with C
23:10:23 <adu> kamatsu: learn OpenGL?
23:10:26 <kamatsu> yeah
23:10:34 <adu> kamatsu: learn with C
23:10:38 <napping> OpenGL is a little gnarly, best to stick with the language it's actually documented for
23:10:54 <adu> i think its a lot gnarly
23:11:00 <napping> See, there's an implicit rendering state you mutate with a bunch of state-setting functions, mixed in with calls to things that actually request drawing
23:11:00 <kmc> actually *kind of* documented ;P
23:11:25 <napping> and none of it is documented very clearly, like what state needs to be set up before what calls and so on
23:11:29 <kmc> anyway if you use Haskell and OpenGLRaw, the C docs should be very relevant
23:11:55 <kmc> kamatsu, i learned OpenGL with Haskell.  i think it was more work, more fun, happier code
23:12:10 <Saizan> nealar: i don't think so, it'd be nice to have
23:12:12 <kamatsu> did you learn with OpenGLRaw or did you use the wrapper straight away?
23:12:21 <adu> the rest you can learn with glEnable() bit flipping and various other methods
23:12:41 <adu> kamatsu: I learned with C and PyOpenGL
23:12:56 <kamatsu> adu: sorry, i was talking to kmc
23:13:07 <kmc> i used the wrapper
23:13:09 <adu> PyOpenGL was soo confusing, especially when it comes to DrawArrays
23:13:26 <napping> I failed to learn much with the OpenGL binding, and ended up learning with C and the big red book, and nehe, and other random web tutorials
23:13:32 <kmc> that said it's important to know how to use OpenGL from C and C++
23:13:33 <nealar> @seen sigfpe
23:13:34 <lambdabot> Unknown command, try @list
23:13:37 <adu> the only way to make the arrays in python was to use numpy
23:13:38 <kmc> for performance and integrating with existing code
23:13:54 <napping> there's the usual cost of doing heavily imperative stuff in Haskell as well
23:14:04 <kmc> what cost is that?
23:14:05 <nealar> list
23:14:08 <nealar> @list
23:14:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:14:11 <napping> slightly chunky syntax
23:14:26 <kmc> if you're doing record updates, maybe
23:14:30 <kmc> and there's library sugar for that now
23:14:42 <nealar> @users
23:14:42 <lambdabot> Unknown command, try @list
23:14:54 * Axman6 wishes @users still worked :(
23:14:59 <napping> My main claim is that the OpenGL docs are bad enough you don't want to compose the problem of understanding them with the problem of matching bound names to original names
23:15:23 <kmc> napping, i agree except that i'd say "you should know what you're getting into" rather than "don't do it"
23:15:41 <kmc> after all if you get stuck you can use OpenGLRaw
23:15:53 <nealar> @lusers
23:15:53 <lambdabot> Unknown command, try @list
23:16:00 <kamatsu> see, my problem is i don't really want to learn openGL, but I am forced to due to the lack of fast graphics libraries for haskell
23:16:05 <Saizan> preflex: seen sigfpe
23:16:05 <preflex>  Sorry, I haven't seen sigfpe
23:16:07 <napping> I guess I just don't see the benefit of switching until you are doing interesting stuff
23:16:09 <kmc> what do you actually want to do?
23:16:10 <Saizan> preflex: seen dpiponi
23:16:10 <preflex>  dpiponi was last seen on #haskell 106 days, 7 hours, 1 minute and 26 seconds ago, saying: Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
23:16:36 <napping> then, sure
23:16:43 <nealar> preflex: lusers
23:16:44 <kmc> yeah i mean if you are just rendering a square, it doesn't matter much what language you use
23:17:51 <napping> I'm thinking like the 20s in the nehe tutorials or something
23:18:10 <kamatsu> kmc: I am developing a game, and currently i've just been using Gloss' game mode to render some 2d vector graphics, but I want to move to 3d graphics, especially seeing as Gloss is more designed for little simulations rather than game.
23:18:30 <kamatsu> (it's getting a little bit slow now)
23:18:31 <napping> actually, there's no reason not to do both
23:18:49 <napping> if you already have an interesting thing you can start adding openGL stuff to it
23:19:05 <kamatsu> the problem is i have to replace the entire graphical layer
23:19:11 <kamatsu> due to the way gloss works
23:19:24 <kamatsu> so i can't incrementally move over to gl
23:19:37 <napping> how does gloss work?
23:20:07 <kamatsu> you construct a Picture value each frame and it renders it for you
23:20:35 <napping> hmm, docs say it uses openGL under the hodd
23:20:39 <kamatsu> yes
23:20:46 <kamatsu> but you can't get in to the openGL it's using 
23:20:49 <kamatsu> it's entirely pure
23:22:04 <kamatsu> it's designed mostly for simple graphical output for use in teaching first years
23:22:08 <napping> maybe that could be changed
23:22:09 <kamatsu> at my university
23:22:22 <napping> it should be a quick hack to let you inject some raw thing
23:22:31 <kamatsu> but, to what end?
23:22:35 <kmc> i mean OpenGL has implicit state
23:22:40 <kamatsu> I don't want to use a 2d vector graphics output
23:22:48 <kamatsu> i was just using it for prototyping
23:23:16 <napping> well, once anything creates an openGL context all your calls go there
23:23:32 <napping> so if there was simply an IO callback for every frame you could do a little of your own drawing on the side
23:23:50 <kamatsu> benl isn't going to put IO into Gloss
23:24:02 <kamatsu> the first years don't know IO and he's not inclined to teach it to them
23:24:15 <kamatsu> if i put it in, i'd be maintaining my own fork of Gloss
23:24:21 <napping> sure, but if you explain what you are trying to do he might suggest how you could hack up a private copy
23:24:39 <kamatsu> I don't think it is really worth it
23:24:51 <kamatsu> I don't want 2d vector graphics, so i basically want to rewrite the entire graphics layer anyway
23:24:53 <napping> seems like you might be able to add a callback argument to simulateInWindow by changing about 2 lines
23:24:58 <kamatsu> sure
23:25:12 <kamatsu> but there is no reason for me to use any of Gloss' infrastructure
23:25:30 <napping> the idea is, you let Gloss do it's thing, and then you can overwrite some of it after that, as you move parts of the drawing over
23:25:42 <napping> well, I was assuming you had something complicated built already that you wanted to keep
23:25:47 <napping> or at least port incrementally
23:25:52 <kamatsu> i have a complicated model that i am keeping
23:26:03 <kamatsu> the rendering side is very simple and can be thrown out at any time
23:26:13 <kamatsu> i don't want to keep Gloss
23:26:43 <napping> hmm, how does the viewport switching work?
23:26:47 <kamatsu> the problem is there aren't any nice high-level libraries that wrap openGL for haskell
23:27:12 <kamatsu> except for things like Gloss or DrawingCombinators which are specifically for 2d graphics
23:27:41 <napping> you don't like the packages for various engines?
23:27:44 <napping> haven't used any myself
23:27:46 <kamatsu> there's also Yampa and LambdaCube but that stuff seems a bit too hard for me to understand
23:27:49 <kamatsu> napping: such as?
23:27:55 <napping> the ogre bindings, for one
23:28:02 <kamatsu> napping: very incomplete?
23:28:26 <napping> irrhaskell?
23:28:30 <kamatsu> doesn't build
23:28:41 <kamatsu> seems to be designed for ancient irrlicht
23:28:44 <napping> dunno what cal3d is
23:28:54 <kamatsu> skeleton animation, i don't need that
23:30:07 <Axman6> kamatsu: are you still talking about using horde3d? looked like an interesting projecty
23:30:10 <Axman6> -y
23:30:12 <napping> sounds like it's time to do your own thing in openGL then
23:30:36 <kamatsu> Axman6: That would be cool, except horde3d doesn't have billboard sprites which seems to be a bit of an oversight
23:30:54 <kamatsu> Axman6: the incomplete bindings i found wouldn't even build, so i'd have to write my own
23:31:02 <kamatsu> Axman6: seems like a better value proposition to extend hogre than use it
23:31:26 <napping> I think it would be quite easy to hack up Gloss a bit two let you run the current gloss renderer and the new one side-by-side as you build it
23:31:56 <napping> what sort of graphics are you going for anyway?
23:32:02 <kamatsu> napping: what do you mean?
23:32:19 <napping> what are you trying to draw?
23:32:27 <kamatsu> at the moment, just planets and stars
23:32:33 <kamatsu> later on, other things
23:32:47 <napping> actually, that shouldn't be so bad with raw openGL, at least to start with
23:32:55 <napping> you can keep the objects in display lists and stuff
23:33:10 <kamatsu> this would require me to learn openGL
23:34:46 <dskippy> I have a data type that has several constructors. I want it to be of type class Ord. I would to only have to differentiate the ordering if two values are of the same constructor, because the constructors all have an implicit ordering as if I'd derived Ord. But my constructors take values so it's more complicated. Is there a better way to do this than just writing all cases out?
23:35:38 <napping> you only want an order different from the derived Ord if the constructors are the same?
23:36:40 <dskippy> Yes.
23:36:47 <dskippy> Napping, basically like this:
23:36:53 <napping> well, one trick I use sometimes is just calling compare on a pair of tuples constructed from things you want to compare, to get a lexicographic order
23:37:11 <napping> doesn't quite do what you want
23:37:39 <dskippy> data HankRank = ... | FullHouse CardRank | FourOfAKind CardRank | StraightFlush CardRank
23:38:04 <napping> um, you can't just derive on that?
23:38:30 <napping> hand first, then card sounds right to me
23:38:54 <dskippy> So I'd like to just write something like "compare (FullHouse r1) (FullHouse r2) = compare r1 r2" and similar for all others. But allow it to be assumed all straight flushes beat any four of a kind.
23:39:10 <napping> that's what you should get with the derived Ord
23:39:28 <napping> values compared first by constructor, then by lexicographic order on constructor arguments
23:39:45 <napping> (that is, compare arguments left to right, using their Ord)
23:40:24 <dskippy> Oh really? Wow. I'm so impressed I wouldn't have bothered trying that.
23:41:12 <napping> if you do want a custom one, rather than making n^2 patterns to get the basic order down, you could make one function ranking suits and compare on that first
23:41:18 <dskippy> But I do have some that are lists of cards. For example HighCard is just a list. I suppose I could just rewrite my data to make this work though.
23:41:23 <napping> wait, nvm, you get that anyway
23:41:46 <napping> well, if the list is in sorted order it will work out as well
23:41:57 <napping> List are compared in lexicographic order as well
23:42:03 <napping> isn't that what you want for high-card?
23:42:36 <napping> if you must write by hand, wildcard patterns work fine
23:42:57 <napping> ... compare (LowestConst ...) (LowestConst ...) = <compare>
23:43:05 <napping> ... compare (LowestConst _) _ = LT
23:43:16 <napping> ... compare _ (LowestConst _) = GT
23:43:33 <napping> and so on for the next lowest - trying patterns in order makes it work out
23:43:42 <dskippy> napping: Yeah I think this might all just work assuming I sort the cards.
23:43:54 <dskippy> Wow, pretty awesome.
23:44:09 <napping> for full house, is there some rule about comparing the triple or pair first?
23:44:29 <napping> hmm, is there a canonical order on the suits?
23:44:44 <danharaj> wikipedia probably knows
23:45:05 <dskippy> napping: No because all that matters is the tripple.
23:45:27 <dskippy> napping: No, suits are not of type class Ord in poker.
23:46:07 <kamatsu> sigh
23:46:15 <kamatsu> hogre examples run but give crazy results
23:46:31 <dskippy> Thanks a bunch napping. I'm excited to rewrite this.
23:46:33 <kamatsu> so, thats off the cards now too
23:47:02 <kmc> dskippy, if they're different ctor you have an ordering on the ctor.  if they're the same, then there's a way to turn each one into a list for lexical ordering, right?
23:47:06 <napping> seems like it might work
23:47:45 <dskippy> kmc: napping has answered my question but thanks.
23:47:54 <kmc> i'm suggesting an alternative solution
23:48:06 <kmc> which may or may not be better
23:48:27 <dskippy> I think it's easier to do the other way, yeah.
23:48:50 <napping> well, there's no obvious reasoning not to just make that list for lexical ordering be the actual constructor arguments
23:48:51 <kmc> well hear me out for one second
23:48:56 <kmc> anyway you can write the second function
23:49:11 <kmc> orderBy (TwoPair higher lower extra) = [higher, lower, extra] etc.
23:49:17 <kmc> that's only one case per hand type
23:49:25 <dskippy> It's possible, however, that all poker hands sorted from largest to smallest, are the better hand given a hand rank if they are > in Haskell.
23:49:38 <dskippy> I think you need to account for Ace being high and low though.
23:50:10 <kmc> then you can use toConstr from Data.Data to compare by constructor
23:50:15 <kmc> and if they are the same, call this orderBy function
23:50:44 <napping> dskippy: just do that when you build the hand
23:51:05 <dskippy> kmc, I don't think this beats putting the stuff in the constructors and deriving Ord.
23:51:18 <napping> if you only store the highest rank for straights you are fine
23:51:27 <dskippy> My data definition is essentially TwoPair highpairrank, lowPairRank, etc
23:51:38 <dskippy> napping: Right. I am.
23:51:39 <napping> I guess two straights with the same cards in different suits are a tie?
23:52:08 <danharaj> yes.
23:52:16 <dskippy> napping: However, it's possible I can save a bit of work by just storing the hand sorted greatest to smallest and then the hand rank.
23:52:37 <napping> that works two - you are falling back on the list lexicographic order, so it will be fine either way
23:52:41 <dskippy> Oh no, that doesn't work.
23:52:54 <napping> just need to make sure you sort it properly when the ace is low, so you won't be able to just call sort there
23:53:09 <napping> but then you wouldn't be able to do that to recognize the straight anyway, so it's not really extra work
23:53:29 <dskippy> [10, 3, 3, 4, 4,] [9, 5, 5, 6, 6]
23:53:41 <dskippy> Those two hands disprove the very simple solution I proposed.
23:53:46 <napping> right, you'll have to order it property
23:53:53 <napping> you can't just sort all the cards
23:54:11 <dskippy> I can't just say "These are both two pair, check the ordering. Because the 10 kicker is less significant than the pairs.
23:54:17 <napping> but, TwoPair {highPair :: CardRank, lowPair :: CardRank, oddCard :: CardRank}
23:54:23 <napping> then the derived order is fine
23:54:50 <dskippy> So I'll stick with my TwoPair highPairRank lowPairRank wholeHand and use your derving Ord suggestions.
23:55:06 <napping> or, you could make a list that's in the order of importance
23:55:10 <dskippy> After I rewrite this a tiny bit to make deriving Ord actually work based on the rules you detailed.
23:55:33 <napping> I assume to recognize the hand you took it appart into the pieces - pair of X, pair of Y, odd Z, so then you might as well just put them back together in a working order
23:55:33 <dskippy> napping: Yeah, I think that gets a little hair for my tastes.
23:55:56 <napping> I've never seen tied hands
23:56:01 <byorgey> you like the taste of hair?
23:56:01 <kmc> if you need to use the derived order only sometimes, you can newtype
23:57:21 * kmc remembers doing this in Perl ages ago to cheat at Yahoo poker
23:57:49 <dskippy> napping: Yeah possibly, but I need to know the hand rank and it's pretty easy to just put the ranks in the constructor. Relying on a constraint like "All two-pair hands are ordered such that the highest pair cards are first" is really less clean than relying on Haskell's type system.
23:58:24 <napping> dskippy: I was assuming you'd have separate constructors to label the hands
23:58:34 <napping> just if you wanted the associated data to always be a list of the actual cards
23:59:02 <dskippy> I really just want the ordering of hands with respect to each other.
23:59:18 <napping> like, TwoPair [Card] | FullHouse [Card] etc
23:59:29 <dskippy> Yeah.
23:59:30 <napping> though a more decomposed representation is more secure
23:59:42 <napping> and you can set up a nice quick-check property for the card recognizer
