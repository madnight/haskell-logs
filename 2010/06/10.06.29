00:27:51 <Dashkal> kmc: intType = mkType (toFSValue intType) (Just (show :: Integer -> String)) (typeOf (undefined :: Integer)) "Integer"
00:28:18 <Dashkal> Only the toFSValue intType part is actually required for type safety.  THe rest of that is for show, ==, and error messages.  Phew
00:28:24 <kmc> :)
00:28:30 <kmc> i don't think you'd need that many signatures
00:28:44 <kmc> in my last interpreter i resorted to a bit of TH to get rid of this boilerplate
00:28:49 <Dashkal> ghci was complaining about ambigious a without them.
00:28:53 <kmc> ah
00:29:04 <kmc> i replaced 12 very straightforward boring lines of code with an incomprehensible 12-line macro
00:29:07 <kmc> that's a victory right? ;)
00:29:30 <blackdog> kmc: heh. so frustrating...
00:29:51 <blackdog> is the interface reasonable? just hide the macro somewhere :)
00:29:54 <kmc> yeah
00:29:59 <Dashkal> Yeah, the balance between boilerplate and clever ends when I can't read the types anymore :P
00:30:08 <kmc> ah, well, the types in TH are very simple ;)
00:30:12 <kmc> might could do it more easily with CPP than TH, really
00:30:19 <blackdog> i've always found TH a massive pain in the arse
00:30:25 <c_wraith> I wish I could have quotes with type Q Dec
00:30:33 <blackdog> i keep feeling that i'm missing some ah-ha moment
00:30:42 <kmc> sometimes you want fancy AST metaprogramming, and sometimes you just want to unceremoniously glue strings together
00:30:53 <kmc> TH is a massive pain in the arse
00:31:06 <kmc> i'm no expert but i've lost all hope for the ah-ha moment
00:31:13 <kmc> there are some parts of it that GHC doesn't implement that would make it nicer
00:31:16 <Saizan> c_wraith: can't you?
00:31:17 <blackdog> i'm still generating C and Haskell with string concatenation in Hubris
00:31:24 <blackdog> it's bloody horrible, but i can't find a better way
00:31:34 <c_wraith> Saizan: all I could figure out from quotes was Q Exp
00:31:48 <Saizan> c_wraith: [d| data Foo = Foo |]
00:32:03 <c_wraith> Oh.  That's the problem with not learning them properly
00:32:23 <blackdog> that's the other one that screws me - i had a list comprehension getting interpreted as a splice
00:32:32 <Saizan> that's Q [Dec] actually, but anyway :)
00:32:51 <c_wraith> yeah, the language gets a lot more whitespace-sensitive when -XTemplateHaskell is on
00:33:01 <blackdog> which gets reported as a lexical error :)
00:33:11 <blackdog> anyway
00:33:13 <blackdog> hometime :) later.
00:36:36 <Dashkal> Oh hell.  I didn't think of [a].
00:50:20 <Dashkal> hmm, hoogle isn't showing me anything.  Is there no abstraction on lookup tables? m k v -> k -> v
00:50:45 <kmc> you mean by type class?
00:51:06 <Dashkal> I'm looking for a generalized lookup method
00:51:12 <kmc> generalized how
00:51:30 <Dashkal> works on [(k, v)] and Data.Map k v
00:51:38 <anode> I want to learn about partitions
00:51:51 <anode> partitions of sets
00:51:55 <kmc> Dashkal, that wouldn't fit the form of ¬´m k v -> k -> v¬ª
00:51:58 <kmc> anode, in Haskell?
00:52:11 <Dashkal> make that maybe v
00:52:27 <anode> in hasekell or C
00:52:35 <kmc> well, what about them?
00:52:51 <kmc> Dashkal, anyway, i don't know of anything commonly used.  to do it nicely you want a more general type than ¬´m k v¬ª;  for example neither [(k,v)] nor IntMap is of that form
00:53:00 <kmc> and the machinery to provide that more general type is newer and less standard
00:53:02 <anode> how I could use them and write them algorithmically
00:53:15 <kmc> what do you want to use them for?
00:53:29 <anode> honestly, just learning
00:53:43 <Dashkal> meh, suppose I can just stick with alists for now then.  I do need the ordered property of that kind of list for what I'm doing (it's the variable stack when the interpreter runs)
00:54:13 <Dashkal> s/list/lookup table/
00:54:26 <kmc> anode, well, there's no standard set library in C
00:54:34 <kmc> in general any kind of high level data structure like this is a real pain in C
00:55:04 <kmc> anode, you know the mathematical definition of a partition?
00:55:36 <anode> kmc: yes
00:55:49 <anode> or atleast the given conceptt
00:56:13 <kmc> in Haskell we have this type Data.Set.Set which is pretty useful
00:57:45 <tensorpudding> also Edison has sets too
01:27:25 <ezyang> I'm rereading the "Type-level programming" thread on haskell-cafe, and a statement made me think of something: "if you know the actual type at compile-time, you don't need dependent types." If I understand this correctly, this also means you don't get the static assurance guarantees with dependent types? 
01:27:50 <ezyang> In which case, why would you want dependent types for software engineering (I think I have a reasonable feel for why they might be useful in theorem proving.) 
01:28:38 <Amadiro> Good evening. I remember when I read "Real World Haskell", it used a neat system where readers could make annotations to each paragraph. Does anyone happen to know what kind of software was used for that, or happens to know a similar software? I could use a system just like that. I thought about just setting up a wiki, but that seems like overkill.
01:29:01 <ezyang> Amadiro: Does the RWH website not say? 
01:29:10 * ezyang doesn't know offhand, but could probably ask dons 
01:29:12 <Amadiro> ezyang, no, not as far as I could see.
01:29:55 <Amadiro> I'll have a look at their blog, maybe they commented on it there.
01:33:16 <Amadiro> "...the comment system has been one of the best small hacks Iíve ever written."
01:33:24 <Amadiro> Seems to be something self-made.
01:33:39 <ezyang> ah, ok. 
01:33:48 <Amadiro> Maybe they published it somewhere.
01:33:50 <ezyang> It would be certainly nice if it were released. 
01:36:31 <Amadiro> ezyang, I found the blog post where he describes the system and the underlying technologies, but he does not write anything in that regard. I assume he did not release it publicly.
01:36:51 <Amadiro> Guess I'll just set up a wiki.
01:38:44 <ezyang> blegh, MonadIO being in mtl is annnoying 
01:41:55 <dons> Amadiro: mail bos, he can send you the code. i'm thinking of rewriting it on top of gitit this summer, as a paper publication mechanism.
01:42:17 <ezyang> sweet! 
01:42:41 <dons> upload latex, have it rendered to a commentable draft page, etc. 
01:42:56 * dons -> bed
01:43:00 <ezyang> good night! 
01:43:06 <Amadiro> dons, Ah, neat. I think I'll go with the wiki for now, though, because his current solution seems pretty much just as heavyhanded, and I need to set up a wiki for the project anyway. So I guess I'll use your rewrite for the next thing I'll need it for :)
01:43:27 <Amadiro> dons, thanks for the info & good night.
01:57:58 <alpha> let test = map (*) [0..10], how do I now multiply every element in the list with say 3? "map (3) test" does not work
01:58:20 <exDM69> alpha: how about map (*3) [0..10]
01:58:38 <exDM69> or in a more simple fashion map ((*) 3) [0..10]
01:58:48 <dafis> alpha: map ($ 3) test
01:59:07 <dafis> or map (flip id 3) test :)
01:59:13 <alpha> exDM69, yes that should work but I am now doing it for learning so I would like to use test as a partial function :)
01:59:42 <alpha> dafis, thanks. What does "$" do?
02:00:08 <exDM69> alpha: $ is function application f $ x == f x
02:00:32 <dafis> alpha: function application, ($) f x = f x, it just has a low fixity and helps reduce parentheses
02:00:33 <alpha> exDM69, ah cool. cheers
02:01:21 <exDM69> $¬†reduces parentheses but adds funny compiler error messages when trying to use it with the ST monad :)
02:01:44 <dafis> exDM69: not in the newer GHCs
02:02:11 <dafis> since 6.10, iirc, ghc deals fine with runST $ do ...
02:02:49 * dafis wonders: or was it even 6.8?
02:04:10 <exDM69> dafis: I think that I had the problem with 6.10.4 still
02:04:16 <alpha> why do I need to do a flip on id? isn't "flip id == id"?
02:04:24 <exDM69> havn't tried 6.12.* with runST $¬†do ..
02:05:21 <dafis> exDM69: I just compiled such a thing with 6.8.3, no complaint
02:05:56 <dafis> alpha: no, flip id is different from id
02:06:01 <exDM69> strange, wonder which version was it that I had the "type is less polymorphic than expected" error
02:06:26 <dafis> alpha: flip id 3 sin = sin 3, id 3 sin = 3 sin, doesn't make sense
02:08:11 <dafis> exDM69: better to play it safe anyway, hugs would certainly choke on it
02:08:28 <dafis> and what other compilers do, who knows
02:08:42 <alpha> so "let test = map (*) [0..10]" adds the multiplication to the right, is it someway to make it apply the multiplication to the left (okay, * is commutative but if it were not then it would matter)?
02:09:12 <ivanm> alpha: (flip (*))
02:09:15 <ivanm> @type flip
02:09:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
02:09:30 <dafis> > let test = map (flip (-)) [1 .. 10] in map ($ 4) test
02:09:31 <lambdabot>   [3,2,1,0,-1,-2,-3,-4,-5,-6]
02:09:41 <alpha> ivanm, thanks
02:09:43 <dafis> alpha: ^^
02:09:44 <ivanm> np
02:09:49 <Starfire> That type for flip is a bit surprising.
02:09:51 <alpha> oh, haskell works in here? coolt
02:10:15 <dafis> Starfire: it's a lambdabot special
02:10:25 <ivanm> damn Caleskell :@
02:10:27 <ivanm> @type P.flip
02:10:28 <lambdabot> Couldn't find qualified module.
02:10:33 <ivanm> @type Prelude.flip
02:10:34 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:10:43 <ivanm> Starfire: ^^ there we are
02:10:52 <dafis> that's what you usually get
02:12:20 <dafis> ivanm: say, do you think a package of element-strict containers would be generally useful?
02:12:34 <ivanm> dafis: you mean unboxed containers?
02:12:40 <ivanm> dafis: I think that's what adaptive lists, etc. are for
02:13:00 <dafis> I just hacked IntMap to be element-strict for alexyk's Twitter mining, gave a significant speedup
02:13:42 <dafis> ivanm: not unboxed, just a bang on the contents type
02:13:44 <Starfire> I recently spent some time trying to understand the ((->) a) instance for Functor, but I couldn't come up with any use cases for it. Anyone care to enlighten me?
02:14:02 <ivanm> dafis: yeah, you want adaptive-style containers then
02:14:13 <ivanm> a few people have independently started working on adaptive maps
02:14:26 <ivanm> Axman6, tibbe and someone else...
02:14:32 <dafis> anything on hackage?
02:14:38 <ivanm> dafis: not yet AFAIK
02:14:49 <ivanm> Starfire: sure, lemme refresh what it does first
02:14:56 <ivanm> but I _think_ it's just function composition
02:14:58 <Starfire> Though I guess writing stuff like (fmap.fmap.fmap) f g can be fun. :P
02:15:02 <ivanm> @srf (->a) fmap[
02:15:02 <lambdabot> Source not found. My mind is going. I can feel it.
02:15:04 <ivanm> @srf (->a) fmap
02:15:04 <lambdabot> Source not found.
02:15:09 <ivanm> @srf ((->)a) fmap
02:15:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:15:38 <dafis> ah, well, I won't bother then until somebody shouts
02:15:39 <Starfire> Yeah, pure == id and fmap == (.) for ((->) a)
02:16:03 <dafis> @src ((->) a) fmap
02:16:03 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:16:39 <dafis> @src filter
02:16:39 <lambdabot> filter _ []     = []
02:16:39 <lambdabot> filter p (x:xs)
02:16:39 <lambdabot>     | p x       = x : filter p xs
02:16:39 <lambdabot>     | otherwise = filter p xs
02:17:21 <Starfire> > (fmap fmap fmap) (* 10) (+) 1 1
02:17:22 <lambdabot>   20
02:18:08 <dafis> :t fmap fmap
02:18:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
02:18:24 <dafis> :t fmap fmap fmap
02:18:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:18:57 <ivanm> Starfire: gah, I can't even find where it's defined! :s
02:19:15 <Starfire> ivanm: Control.Monad.Instances has it
02:19:32 <ivanm> then why does base export it? :s
02:19:42 <dafis> ivanm: it doesn't
02:19:47 <dafis> it's that bot
02:19:52 <ivanm> oh, wait, Functor is defined _twice_ ? :o
02:20:01 <ivanm> why is it in C.M.I and Data.Functor? :s
02:20:23 <ivanm> dafis: I'm looking at the docs right here!
02:20:29 <dafis> ivanm: braino, of course *base* exports it, I thought of Prelude (and the instance)
02:24:04 <Starfire> The Monad instance for ((->) a) is even more cryptic.
02:24:22 <dafis> Starfire: why?
02:24:30 <Starfire> I can't understand where it would be useful.
02:24:41 <dafis> Starfire: reader monad
02:25:27 <dafis> Starfire: and cool stuff  like square = join (*)
02:25:41 <Starfire> Hmm.
02:25:42 <ivanm> that's more important than any silly reader monad!
02:25:54 <ivanm> (which has its own instance completely independent of ((->) a) anyway)
02:26:37 <dafis> ivanm: so the type checker doesn't confuse too many people
02:26:49 <Starfire> Hmm, I didn't realize that Reader is essentially the same thing.
02:27:03 <ivanm> Starfire: so is State
02:28:12 <dafis> ivanm: no, reader doesn't allow to change the environment, or am I confused?
02:28:24 <byorgey> @src Reader
02:28:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:28:34 <ivanm> dafis: no, it doesn't
02:28:46 <ivanm> well, you can set a sub-reader for recursive calls IIRC using ask
02:28:49 <ivanm> @hoogle ask
02:28:50 <lambdabot> Control.Monad.Reader.Class ask :: MonadReader r m => m r
02:28:50 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
02:28:50 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
02:28:57 <byorgey> using 'local'
02:29:02 <dafis> ivanm: I think local
02:29:02 <ivanm> byorgey: ahh, right, that one
02:29:04 <byorgey> 'ask' is for retrieving the environment
02:29:19 * ivanm has never used Reader
02:29:22 <ivanm> well, I used RWS...
02:29:32 <byorgey> yes, 'local' is nice at times -- it's basically like using a State monad that unwinds the state changes when you come back up the call stack
02:30:04 <ivanm> I was considering using Reader + local for recursive calls, but then coulodn't work out how to do something with it so I gave up
03:01:35 <alpha> is foldr just as fast as foldl?
03:01:55 <byorgey> alpha: that question doesn't really make sense out of context
03:02:09 <byorgey> it depends on the combining function which is more appropriate
03:02:54 <alpha> byorgey, if I am to sum the elements of a list (sum' = foldl (+) 0  ) then I could also use foldr, would the foldr solution be just as fast?
03:03:12 <kmc> to talk about performance of a function in haskell you have to talk about how the result is being used
03:03:18 <kmc> because of laziness
03:03:24 <byorgey> in that case, it would probably be slower because it would be unnecessarily lazy
03:03:30 <kmc> in general you shouldn't use foldl; you should use foldl' or foldr
03:03:32 <byorgey> alpha: also, you ought to use foldl' instead of foldl
03:03:47 <kmc> foldl' forces evaluation of the accumulating parameter after every step
03:03:55 <byorgey> alpha: see http://haskell.org/haskellwiki/Foldl_as_foldr
03:04:00 <danharaj> I wonder how well JHC forces strict unnecessary laziness?
03:04:11 <alpha> cheers guys
03:04:19 <byorgey> wait, no, not that page
03:04:25 <byorgey> http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
03:04:29 <byorgey> this one
03:04:48 <kmc> also, http://cale.yi.org/index.php/Fold_Diagrams
03:04:52 <kmc> but it seems to have disappeared
03:04:53 <kmc> very sad :/
03:06:41 <Peaker> Not #haskell's timezone is it?
03:06:52 <kmc> foldr is great for lazy consumers because ¬´foldr f z¬ª simply returns the original list with every (:) replaced as f, and the ending [] replaced as z
03:07:05 <kmc> that's also why foldr is more "natural"
03:07:33 <kmc> so if your function f can start producing data before its right hand arg is fully evaluated
03:07:40 <danharaj> 'lazy consumers' aka Americans
03:07:45 <danharaj> :D
03:07:50 <kmc> danharaj, zing
03:08:03 <kmc> then the result of the foldr can be traversed lazily, just like the original list
03:08:50 <kmc> lazy data is part data structure and part control flow structure
03:10:07 <Peaker> I'm using a ByteString->ByteString persistent database (Berkeley DB) and using phantom types to get type safety back with something like:  data DBRef a = DBRef { key :: ByteString } deriving (Binary) ; read = fromJust . decode . lookup . key
03:10:22 <Peaker> Actually, "read" requires a Database argument to use with lookup
03:10:29 <Peaker> read db = fromJust . decode . lookup db . key
03:10:41 <danharaj> I wonder how hard it would be to write a fold that recursively splits the list and then evaluates the fold in parallel. Only works for associative operations, but then again, you ought to use a tree if you want to specify the parentheses.
03:11:14 <Peaker> Now, I would like to have a more convenient deserialization that doesn't decode into a DBRef, but into something like: Accessor { ref :: DBRef, db :: Db }
03:11:44 <Peaker> But "Data.Binary" provides get/put which have no context or parameterization at all :-(
03:11:47 <kmc> could the accessor be just a partial application of "read"?
03:11:58 <Peaker> kmc, well, it needs to be able to set too
03:12:17 <Peaker> kmc, There's actually a "new" that puts an initial value with the key into the DB, and "read" and "write"
03:12:26 <kmc> danharaj, that's a big part of the language Fortress
03:12:27 <Peaker> kmc, So accessor is something you can use all 3 operations with
03:12:32 <Peaker> (2)
03:12:35 <Peaker> oops :)
03:12:57 <Peaker> Anyway, I'm thinking of creating a new Binary-like class to resolve these issues, not sure yet if that's a good idea or exactly what it should be
03:13:05 <kmc> see also http://vimeo.com/6624203 danharaj
03:13:33 <Peaker> A Binary class that allows some context to flow in -- so I can deserialize a DBRef to an accessor, and not just into a context-less DBRef (which may even be used wrong)
03:13:40 <Peaker> (wrong as in with the wrong Db argument)
03:15:12 <Peaker> kmc, I contradicted myself too much there, so I'll describe Accessor again:  There's    new :: Binary a => Db -> a -> IO (DBRef a)    which makes up a random bytestring key, makes sure it's populated with a value, then returns a (DBRef a) as "proof" that it is populated with "a"
03:15:33 <kmc> so you're making an IORef-like interface?
03:15:37 <Peaker> Yep
03:15:40 <Peaker> But persistent in a Db
03:15:56 <Peaker> So I have:   read :: Binary a => Db -> DBRef a -> IO a    and   write :: Binary a => Db -> DBRef a -> a -> IO ()
03:16:07 <kmc> so the key and value types must be the same?
03:16:20 <kmc> what's the initial value from "new"?
03:16:34 <Peaker> In the underlying Db, yeah, both ByteStrings.  The DBRef is about allowing any (Binary a) type to be put in there
03:16:43 <Peaker> The initial value is the "a" given to new
03:16:55 <Peaker> it puts it in the Db to guarantee a DBRef is always pointing to a valid/existing value
03:17:05 <Peaker> (There's no "del" and the ByteString key isn't exposed)
03:17:21 <kmc> oh
03:17:27 <Peaker> DBRef is an abstract type
03:17:44 <Saizan> and what's the problem with Binary?
03:17:46 <Peaker> Meant to provide an IORef-like interface for type-safe access to serialized values in a Db
03:18:01 <Peaker> Well, the problem is the "Db" args to read/write
03:18:09 <Peaker> If I give the wrong Db there -- I lose the type safety
03:18:15 <Peaker> So I'd want DBRef or some wrapper to have the Db in it
03:18:22 <Peaker> But then Binary can't [de]-serialize it
03:18:41 <Peaker> And I can't pass any context to Binary's get (e.g the Db) so it can deserialize it
03:18:50 <Peaker> Definitely can't pass context to the instance itself :)
03:19:57 <Peaker> If I had instead of   get :: Get a    something like:   parameterizedGet :: Db -> Get a     it could have an instance for (a=Accessor) that just uses the context arg to populate the Db in the accessor
03:20:13 <Peaker> (Of course "Db" would be generalized to whatever context or such)
03:20:41 <Peaker> Saizan, kmc: Am I making sense?
03:20:43 <Saizan> well you could pass contexts into an instance using the reflection package
03:22:03 <Peaker> Oh, big paper to read now :)
03:22:29 <Peaker> How does it work in a couple sentences? :)
03:22:59 <Saizan> you're not making too much sense though, Accessor would be a pair of a key and the associated db?
03:23:23 <Peaker> Yeah, or   Accessor a = Accessor { ref :: DBRef a, db :: Db }
03:23:29 <Peaker> Accessor cannot have a Binary instance
03:23:50 <Saizan> Db is actually an handle to something that's mutable?
03:23:54 <Peaker> Yeah
03:24:06 <Peaker> Well, it's the handle to the Database that contains all the mutable keys
03:24:14 <Peaker> DBRef is an immutable reference to a mutable key in a mutable database
03:24:40 <Peaker> (The database is only mutable in the sense of containing mutable (key,value) pairs
03:25:22 <Saizan> and i guess you've some random reason for Accessor to be [de]serialized
03:25:31 <Saizan> using get/put directly
03:27:02 <Peaker> Well, my data structures refer to each other via DBRef in the Db
03:27:26 <Peaker> If I deserialize them, I get DBRefs in them which are almost type safe. Not type safe because if "read" is used with them it may be given the wrong Db
03:28:24 <Saizan> so the goal of this is to have to worry about giving the right db only at the deserialization point, not later
03:30:16 <seric> what does "<$>" stand for?
03:30:18 <Peaker> Saizan, Yep
03:30:25 <Peaker> Saizan, Or maybe at a point very near it
03:30:42 <Saizan> anyhow the reflection package works by generating a type that represents a reference to a value, so that instances referring to that type have access to the value, the nice thing is that it's all generic and automatic, but it uses higher-rank types :)
03:30:49 <byorgey> seric: it is another name for fmap
03:30:51 <Peaker> Saizan, I guess I could have something the translates a datatype that contains a DBRef to one that contains an accessor by parameterizing the ref type
03:30:58 <seric> byorgey: oh, thank you
03:31:09 <Saizan> Peaker: yeah, i was thinking about that too
03:31:37 <Peaker> data SomeReferrer r = SR { .... ; someRef :: r (SomeReferrer (r or DBRef here?)) }
03:32:06 <Peaker> hmm I'll go toy with this idea
03:36:29 <danharaj> kmc: Fortress looks like it could gain a lot from being pure :p
03:38:03 * byorgey makes lambda-fish and chips (fried Haddock and Nehalem)
03:43:05 <triyo> How do I check if Either is a Left or a Right in a similar fashion to Maybe isJust
03:43:30 <ivanm> triyo: you can write isRight and isLeft functions
03:43:46 <danharaj> triyo: isRight/Left pattern match on Either, and return the obvious values.
03:43:51 <ivanm> however, just about any time you use isJust you're better off using maybe, fromMaybe or explicit pattern matching
03:43:56 <patrykz> try Data.Either.either
03:45:12 <ivanm> though I often define something like: either' l r = either (Left . l) (Right . r)
03:46:13 <byorgey> ivanm: either' = (+++)
03:46:22 <byorgey> @type (+++)
03:46:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
03:46:54 <ivanm> byorgey: oohhh, didn't know about +++
03:47:19 <byorgey> it's dual to (***)
03:47:33 <byorgey> there's also (|||) which is dual to (&&&)
03:47:40 <Jafet> :t (****)
03:47:41 <lambdabot> Not in scope: `****'
03:47:46 <anode> in dijkstras graph algorithm, why is a sum from one path to another, including paths that are inaccessable?
03:48:15 <anode> a sum kept *
03:48:23 <ivanm> byorgey: "dual" ?
03:48:38 <ivanm> anode: sorry, I don't understand your question
03:48:45 <ivanm> @type (|||)
03:48:46 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
03:48:50 <ivanm> @type (&&&)
03:48:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:49:01 <ivanm> ||| == either ?
03:49:43 <byorgey> ivanm: yes
03:49:58 <triyo> Hmm, I have a function guard, and the local var that holds the Either value is the one I wish to determine if it is specifically a Left in the guard. 
03:50:07 <byorgey> ivanm: dual in the sense that (a,b) and Either a b  are dual
03:50:19 <Jafet> anode: in the classic ("quicheless") exposition of the algorithm, the graph is completely connected with edges of infinite weight
03:50:41 <danharaj> mmm quiche
03:50:46 <byorgey> triyo: you could use a pattern guard
03:50:47 <ivanm> triyo: any particular reason for not using an explicit pattern match or a case statement?
03:50:51 <ivanm> (with pattern matching)
03:51:05 <byorgey> triyo: foo x y z | Left n <- x = ...
03:51:16 * ivanm is still trying to recover from the horror that was 70+ exams where students tried to do pattern matching in guards :s
03:51:24 <triyo> ivanm: I have a few different cases that don't go so nicely with the case/of
03:51:25 <ivanm> byorgey: which requires the extension
03:51:39 <danharaj> ivanm: Hey that's a perfectly reasonable thing to do. Pattern guards are delicious.
03:51:43 <anode> Jafet: if you were to try an use the algorithm for well, a map, everything would not be connected though, right?
03:51:46 <ivanm> and IMHO it was the lecturer using pattern guards in the provided code for the assignments that gave rise to those abominations in the exam :s
03:52:20 <ivanm> danharaj: not saying they're not, just that he should have pointed that out, and usually for beginners (no idea what triyo's haskell proficiency is like) using extensions is usually something to be avoided IMHO
03:52:46 <ivanm> triyo: and you can't use the either function to take care of both Left and Right cases at the same time?
03:53:15 <Jafet> anode, edges are added with infinite weight to make it connected
03:53:41 <triyo> ivanm: hmm, you quite right, I can use either, small change. I'll go the either function route.
03:53:48 <danharaj> ivanm: I think some extensions are indispensable for users of all levels. There are others that I agree with you on, for example, I don't think anyone should touch UndecidableInstances willy-nilly.
03:54:17 <ivanm> danharaj: but they should be carefully metered out and explained, rather than just "or you could use pattern guards"
03:54:33 <danharaj> pff, fascist.
03:54:34 <danharaj> ;)
03:54:52 <Jafet> Here is your weekly ration of view pattern coupons
03:54:53 <ivanm> danharaj: pattern guards provide a nice syntactic sugar; so they're not that essential to teach to people just starting out (as opposed to MPTCs if a new user needs them)
03:55:00 <ivanm> Jafet: heh
03:55:44 <danharaj> ivanm: I think pattern guards sugar some cases where the unsugared way is so kludgy that a beginner would get completely frustrated with it. Best to avoid pain and sorrow, imo.
03:56:01 <ivanm> could be
03:56:04 <anode> Jafet: that doesn't make much sense to me.. Sorry. Why exactly would you add unecessary edges if you have say, 7 nodes, a->{b->e,c-f>,d->g}, for what reason would you want to connect them?
03:56:05 <ivanm> in this case, I don't think so ;-)
03:56:23 <Jafet> anode, so that the algorithm works
03:56:38 <anode> are you implying that it doesn't work without them?
03:56:48 <anode> a distance would still be found
03:56:50 <Jafet> It's like dirac delta, best to quietly mutter "wtf?" and move on
03:57:05 <anode> what is dirac delta?
03:57:06 <danharaj> ivanm: Also I think pattern guards are an aesthetically pleasing extension. I think it was an oversight that wasn't noticed for haskell98.
03:57:17 <Jafet> It does, if you use a different algorithm
03:57:35 <danharaj> http://en.wikipedia.org/wiki/Dirac_delta_function
03:57:46 <anode> danharaj: yeah, a figured..
03:57:49 <danharaj> If you ask a physicist, it's a function. If you ask a mathematician, it's a distribution.
03:58:07 <danharaj> anode: I hope you know where our allegiances lie ;)
03:58:29 <anode> what do you mean?
03:58:39 <anode> I guess you mean mathemticians :D
03:58:50 <ivanm> danharaj: oh, I'm not exactly disagreeing; I'm just saying that usages of such extensions should be prefixed with "this is an extension" and possibly a discussion of what the usage of such an extension entails
03:58:52 <dafis> danharaj, I always call it the convolution identity :)
03:59:08 <anode> you guys are really smart
03:59:09 <danharaj> dafis: Sounds like something an engineer would say.
03:59:16 <danharaj> anode: No anode, we just know useless things.
03:59:21 <danharaj> 'useless' :p
03:59:30 * dafis is insulted *engineer*
03:59:31 <anode> they're very useful!
03:59:52 <dafis> danharaj: B* algebras
03:59:57 <danharaj> anode: If anyone asked me if anything I enjoyed learning about was applicabel in the real world, I would throw an eraser at them.
04:00:13 <danharaj> Yes, I have an eraser on hand. There is a blackboard behind me.
04:00:16 <anode> I could probably say the same... :(
04:00:27 <arcatan> hmm, what's the relation between pattern guards and view patterns
04:00:33 <anode> patterns
04:00:38 <danharaj> dafis: Eww. ;)
04:00:43 <mreh> what's wrong with learning abstract things, they still apply
04:00:51 <mreh> you sound ashamed
04:01:00 <kmc> http://www.youtube.com/watch?v=k8Iidlj5GzM
04:01:05 <dafis> danharaj: don't like topological vector spaces?
04:01:07 <anode> probably took a ot of shit from lamepeople
04:01:10 <anode> s/ot/of
04:01:15 <kmc> video is related
04:01:16 <danharaj> dafis: Analysis of all flavors is my mortal enemy.
04:01:46 <anode> dafis: if B* Algebras like A* algorithms?
04:01:52 <anode> is *
04:02:00 <dafis> anode: No, not in the least
04:02:08 <anode> I see
04:02:14 <danharaj> anode: No, it is a kind of object in a field called functional analysis. Which is inhabited by devils and witches.
04:02:32 * dafis is not a witch :)
04:02:39 <anode> what is a devil?
04:02:42 <danharaj> Burn for your lies!
04:02:47 * danharaj shoots dafis with fire from his finger
04:02:47 <anode> demon?
04:02:54 <dafis> anode: a figment of christian imagination
04:02:58 <mreh> I love the Polka's weird Al does
04:03:00 <anode> oh, I see
04:03:11 <mreh> how did that apostrophe get in there?
04:03:15 <mreh> damn things
04:03:52 <mreh> is it ironic that all pop music can be made into a Polka?
04:03:55 <danharaj> dafis: I think it is worth being a theist just to make the joke "I believe in God- up to isomorphism."
04:04:48 <dafis> danharaj: a) theist /= christian, b) God created me an atheist, it would be blasphemy to change that.
04:05:38 <mreh> Warning: the most vocal opinions in here are often not representative of the majority
04:05:55 <danharaj> Warning: Set phasers to troll.
04:05:55 <kmc> warning
04:05:56 <dafis> mreh: how do you know?
04:06:04 <Grey_Fox> we're talking about religion in a haskell channel?
04:06:14 <ivanm> and we're talking about haskell dependencies in -blah!!!
04:06:23 <danharaj> All hail Lambda, and her propher, lambdabot.
04:06:23 <kmc> what a country
04:06:25 <ivanm> have the two channels been switched without me noticing? :s
04:06:33 <ivanm> @wn propher
04:06:35 <lambdabot> No match for "propher".
04:06:35 <mreh> It's my fault about the latter
04:06:41 <mreh> wrong channel open
04:06:46 <danharaj> prophet*
04:06:48 <dafis> ivanm: today's opposites day
04:07:03 <ivanm> is it? really?
04:07:06 <danharaj> no, he's just on Bizarro Earth.
04:07:07 <mreh> no
04:07:07 <kmc> no.
04:07:10 <mreh> lol
04:07:19 <danharaj> Where Haskell is a strict imperative side effecting language.
04:07:21 <mreh> maybe we're saying that because it is opposites day
04:07:33 <danharaj> And C is a pure lazy declarative language.
04:08:13 <Jafet> http://www.dilbert.com/fast/1989-05-03/
04:08:54 <dafis> :D
04:10:19 <Ke> =o)
04:12:04 <kmc> "Fortress features include: - Implicit parallelism - Transactions - Flexible, space-aware, mathematical syntax - Static type-checking (but with type inference) - Definition of large parts of the language in its own libraries"
04:12:10 <kmc> hmmmmmmmm
04:17:47 <paulvisschers> I'm having a small problem with type synonym families: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26669#a26669
04:17:55 <Ke> I glanced at fortress, but it had something I really did not like and I never looked at it again
04:19:07 <paulvisschers> the projection function I want to make doesn't work, because I can't pattern match on a type synonym family (I assume because there not bi-jective)
04:19:20 <dafis> paulvisschers, no way to determine r1 and r2, I think
04:19:39 <paulvisschers> does anyone know a way of making this work without resorting to type classes?
04:19:48 <dafis> yes, they're not injective, that's the problem
04:20:04 <dafis> paulvisschers, data families?
04:20:34 <ivanm> yeah
04:20:45 <ivanm> see the "Fun With Type Families" paper (or whatever it's called) by SPJ et. al.
04:20:57 <dafis> paulvisschers, or a GADT?
04:20:59 <ivanm> they give an example of a Graph class that needs to use data families rather than type families
04:21:47 <paulvisschers> dafis, ivanm: but data families require extra constructor wrapping right?
04:21:55 <ivanm> yup
04:22:21 <dafis> paulvisschers, there's no such thing as a free pattern-match
04:22:35 <paulvisschers> ivanm: Can I undo that wrapping later, so that the library user won't notice it?
04:23:07 <ivanm> paulvisschers: uhhh.... not sure
04:23:10 <ivanm> don't think so
04:24:21 <paulvisschers> ok thanks ivanm and dafis
04:24:56 <ivanm> paulvisschers: the idea is with data families is that you don't care about the internals, just how to use it IIUC
04:27:07 <paulvisschers> ivanm: I need users to create the actual projections though
04:30:32 <paulvisschers> ivanm: I'll just stick to a type class for now
04:53:33 <jkramer_> Ahoy
04:54:02 <jkramer_> Is there a standard function in Prelude that lets me flip the elements of a tuple? Like: (a, b) -> (b, a)
04:54:10 <jkramer_> Can't find anything via hoogle
04:55:21 <arcatan> probably not
04:55:50 <jkramer_> Ok, thanks
05:01:55 <dafis> @type snd &&& fst
05:01:55 <lambdabot> forall a c. (a, c) -> (c, a)
05:08:20 <otto_s_> @type Right ||| Left
05:08:21 <lambdabot> forall b a. Either b a -> Either a b
05:09:48 * hackagebot bktrees 0.3 - A set data structure with approximate searching  http://hackage.haskell.org/package/bktrees-0.3 (JosefSvenningsson)
05:16:51 * mreh really wishes swap was in the prelude
05:19:06 <mreh> :t uncurry $ flip (,)
05:19:07 <lambdabot> forall a b. (a, b) -> (b, a)
05:19:12 <mreh> nice
05:20:13 <mreh> what is "," infix or magic?
05:20:25 <dafis> mreh: it's probably not in the prelude because there are so many cool ways to produce it
05:20:27 <mreh> :t a , b
05:20:28 <lambdabot> parse error on input `,'
05:20:41 <mreh> lets see how many!
05:21:00 <dafis> mreh: (,) is the constructor, with the parens
05:21:22 <dafis> and it's built-in special syntax, like []
05:21:34 <mreh> :t (a,)
05:21:35 <lambdabot> parse error on input `)'
05:21:37 <mreh> right
05:21:41 <mreh> :t (,) a
05:21:42 <lambdabot> forall b. b -> (Expr, b)
05:22:02 <dafis> mreh: yes tuple sections aren't yet in the language
05:22:10 <davidc_> BONUS: ping?
05:22:37 <kunt> hi
05:22:44 <mreh> nice name
05:22:49 <mreh> what's up?
05:22:53 <dafis> but there's a LANGUAGE pragma for TupleSections
05:22:59 <kunt> just spamming everyone for luls and dc's
05:23:02 <kunt> DCC SEND DURR#DURR#DURR#DURR#DURR 0 0 0
05:23:12 <mreh> woah!
05:23:16 <mreh> how did he do that?!
05:23:25 <davidc_> :P
05:23:30 * kunt luls
05:23:43 <mreh> are you going to behave?
05:23:52 <kunt> no im done now had my fun
05:23:56 <kunt> ttfn :)
05:24:50 <arcatan> @djinn (a, b) -> (b, a)
05:24:50 <lambdabot> f (a, b) = (b, a)
05:25:01 <arcatan> not very cool, but autogenerated!
05:25:08 <dafis> @pl \(a,b) -> (b,a)
05:25:08 <lambdabot> uncurry (flip (,))
05:25:29 <davidc_> BONUS: let me know when you get online/back, I'd like to talk about launching another LYAH or LYSE like book :)
05:25:30 <davidc_> cheers
05:28:46 <jkramer_> Is there a lib for formatting data nicely, like (s)printf, but safe?
05:29:08 <jkramer_> I actually just want to print some 0-padded numbers
05:29:58 <dafis> jkramer_, Text.Printf, but it's not quite safe
05:30:34 <jkramer_> Yeah, that's why I'm asking :)
05:30:44 <dafis> you could of course write your own padding function
05:31:21 <davidc_> jkramer_: dzen has some good padding stuff but I don't know if it's safe
05:31:23 <jkramer_> Yup, I just thought there might be a lib doing that. But I'll roll my own then
05:31:39 <dafis> padleft n x xs = let l = length (take n xs) in replicate (n-l) x ++ xs
05:32:16 <jkramer_> Thanks
05:32:30 <dafis> padright n x xs = take n (xs ++ repeat x)
05:42:37 <Twey> jkramer_: There's printf-th on Hackage
05:42:57 <Twey> It takes the string you give to printf and uses it to provide compile-time type-checking of the arguments
05:45:05 <triyo> Silly question, but I'm still a bit of a haskn00b
05:46:50 <triyo> If I have a function that takes a Either ParseError Xxxx .... and I need the ParseError (parsec ver) converted to my own Error type... whats the best way to do this
05:46:50 <triyo> ?
05:47:53 <triyo> So I wish to abstract away the parsec error using my own Error type.
05:48:17 <dafis> triyo: write convertError :: ParseError -> YourError
05:48:58 <triyo> Oh I see, just a simple convert function
05:50:57 <sstoday> request uri =Request {rqURI = uri,
05:50:58 <sstoday>                       rqMethod = GET,
05:50:58 <sstoday>                       rqHeaders = [],
05:50:58 <sstoday>                       rqBody = ""}          
05:51:00 <sstoday>         
05:51:03 <sstoday> simpleGet uri ok error= 
05:51:07 <sstoday>                     do resp <- simpleHTTP req
05:51:10 <sstoday>                        either error   
05:51:13 <sstoday>                          (\r -> 
05:51:16 <sstoday>                                case rspCode r of
05:51:19 <sstoday>                                  (2,_,_) -> ok )
05:51:22 <sstoday>                          resp
05:51:25 <sstoday>                     where req=request urii
05:51:28 <sstoday>                           urii =fromJust $ parseURI uri
05:51:35 <sstoday> I am getting an    Ambiguous type variable `a' in the constraints:
05:51:38 <sstoday>       `Data.String.IsString a'
05:51:41 <sstoday>         arising from a use of `request' at src/Main.hs:58:30-41
05:51:44 <sstoday>       `HStream a'
05:51:46 <sstoday>         arising from a use of `simpleHTTP' at src/Main.hs:52:31-44
05:52:17 <sstoday> I know how to specify the type explicitly and it works, but it doesn't seem normal to me
05:52:21 <ville> sstoday:  http://hpaste.org
05:52:42 <dafis> sstoday: that comes with overloaded Strings
05:52:58 <triyo> why use hpaste when in haskell everything can fit in on one line ;)
05:53:39 <dafis> triyo: I think you can do that even in Python
05:53:41 <sstoday> but request rqBody is a string, so there is no ammbiguity
05:54:01 <dafis> sstoday: are sure?
05:54:04 <ville> triyo: Yeah, readibility be damned.
05:54:21 <sstoday> dafis: http://hackage.haskell.org/packages/archive/HTTP/3000.0.0/doc/html/Network-HTTP.html
05:54:31 <triyo> you can tell that to your perl friends. ;-)
05:55:01 <sstoday> and it works fine without explicit types in other functions
05:56:35 <Axman6> sstoday: you know people have been banned from many a channel for pasting less code than that right? don't do it
05:56:36 <dafis> sstoday: data Request a = ... rqBody :: a
05:57:33 <dafis> so with overloaded Strings, rqBody = "" can be any type in the IsString class
05:57:44 <dafis> e.g. ByteString or Text
05:57:52 <Axman6> or String
05:57:57 <dafis> or that
05:58:00 <Axman6> >_>
05:59:05 <sstoday> Axman6: no i didnt know that, and why would it be so bad?
05:59:22 <dafis> sstoday: because it's a pain to read it here
05:59:23 <Axman6> because it's a massive pain in the arse
05:59:52 <Axman6> we're not here to read your code, we're here to talk. use a paste website and give us the link, and those who want to read it can
06:00:02 <sstoday> Axman6: ok fine, this is a better approach than the threatening kind of approach
06:00:20 <sstoday> Axman6: you don't need to black mail, just explain reasons you know...
06:00:25 <Axman6> i wasn't being threatening at all, i was giving you advice
06:00:30 <Axman6> ...
06:00:34 <Axman6> you're new to IRC aren't you
06:00:42 <sstoday> Axman6: yes
06:00:54 <sstoday> Axman6: just for haskell
06:01:04 <Axman6> well now you know, and you won't forget :)
06:01:46 <Axman6> sstoday: there aren't many things people get annoyed with, but pasting large amounts of code (generally > 4 lines) and asking to ask a question are the most common
06:01:50 <sstoday> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26671#a26671
06:02:33 <sstoday> here, in first example I get ambigious type, in second I dont. Worse, I get it when I use request function...
06:03:11 <sstoday> Axman6: ok thank you for the advice. Didn't know that...
06:03:21 <dafis> sstoday: in the second, you use decode, that fixes it to ByteString
06:03:27 <dafis> (Lazy, iirc)
06:04:01 <sstoday> dafis: what does it fix? decode has nothing to do with the type of request!
06:04:02 <dafis> sstoday, in the first, there's no function which determines the type of the request
06:05:23 <sstoday> dafis: there is something I am missing. The type of reqBody is String, it isnt ambigous, even leaving request function alone compiles fine
06:05:30 <Axman6> sstoday: yes, but decode takes a specific type, and because you've used decode, the compiler has done type inference and realised that the a must be the type decode accept (Lazy ByteString?)
06:06:11 * Zao foralls.
06:06:24 <dafis> sstoday: rqBody need not be a String, it could be Text or ByteString
06:07:09 <sstoday> decode takes the response body and not the request body.and there is no type variable in either...
06:07:23 <dafis> simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
06:07:34 <dafis> and respBody has type ty
06:07:59 <sstoday> ah, I was checking the wrong type then http://hackage.haskell.org/packages/archive/HTTP/3000.0.0/doc/html/Network-HTTP.html
06:08:04 <dafis> so when you feed respBody into decode, you determine ty
06:08:58 <sstoday> I saw no type variable in the definition of Request on that page
06:09:46 <dafis> sstoday: what does ghc-pkg list | grep HTTP give?
06:09:55 <dafis> is there a HTTP-4000?
06:10:40 <sstoday> dafis: I was looking through the HTTP-3000.0.0 docs. My bad i did a google search blindly
06:11:21 <dafis> sstoday, google is a bit slow sometimes :)
06:11:43 <sstoday> and since there is no type variable there, it drove me insane. Actually I use the last version of HTTP but was looking into the documetation of the wrong version (3000)
06:11:56 <dafis> sstoday: when google turns up a package name, always go directly to hackage
06:13:51 <sstoday> thankyou dafis, I thought I am going crazy!
06:14:16 <dafis> You think, therefore you are
06:14:24 <dafis> (going crazy)
06:14:44 <Jafet> @vixen you drive me crazy!
06:14:45 <lambdabot> nope, i'm sane
06:15:57 <Botje> haha
06:16:01 <Botje> \bot++
06:16:18 <dafis> @karma bot
06:16:19 <lambdabot> bot has a karma of 0
06:16:51 <turb> DCC SEND "startkeylogger" 0 0 0
06:17:00 <turb> DCC SEND "startkeylogger" 0 0 0
06:17:04 <turb> olol
06:17:30 <joga> way to go
06:18:20 <geheimdienst> u 15 teeeh h4xx0rz d00d
06:18:28 <McManiaC> http://npaste.de/aE/ ‚Üê am I missing anything here?
06:18:34 <McManiaC> havent worked with the FFI in a while
06:20:06 <dafis> McManiaC, from which header do they come?
06:20:18 <Saizan> you'd need to also pass the .c or .o file where those are defined, i think
06:20:24 <McManiaC> cleargreen.h
06:20:49 <dafis> foreign import ccall "cleargreen.h &cleargreen"...
06:21:11 <dafis> IIRC, I haven't used FFI in a while either
06:22:16 <McManiaC> ah okay
06:22:26 <McManiaC> thx :)
06:22:31 <dafis> Oh, and perhaps you have to pass the .o file on the command line too
06:22:43 <dafis> trial and error will tell
06:23:40 <McManiaC> I only had to pass the .o on the "--make" command
06:24:01 <tafryn> Where is getChar defined?
06:24:30 <dafis> tafryn: System.IO
06:24:40 <dafis> but it's exported from the Prelude
06:24:52 <geheimdienst> @hoogle getChar
06:24:52 <lambdabot> Prelude getChar :: IO Char
06:24:53 <dafis> so it's always available
06:24:53 <lambdabot> System.IO getChar :: IO Char
06:24:53 <lambdabot> System.IO hGetChar :: Handle -> IO Char
06:32:01 <Axman6> ha, i made it into a paper!
06:32:25 <dafis> Axman6: How? did you score a goal?
06:32:42 <dafis> or have you beaten a student?
06:32:58 <dafis> or have you discovered a great new theorem?
06:33:07 <Axman6> no, like a haskell paper. the one about the improvements that have been made to the containers package
06:33:20 <Axman6> TernaryTrees is my package
06:33:35 <dafis> Ah, nice.
06:34:09 <mjk> ÊµãËØï‰∏≠Êñá  test chinese
06:34:12 <Axman6> hey, my lookup code is pretty good apparently
06:34:20 <dafis> btw, Axman6, ivanm said earlier you've worked on - what did he call them - adaptive containers
06:34:45 <dafis> when I asked about element-strict containers
06:34:48 <geheimdienst> We employ a simple implementation of cryomorphobalonical panfunctors as introduced by Axman6 [2009] ...
06:35:38 <Axman6> dafis: yeah i've done a bit of work on them, haven't had much time though :(
06:35:57 <dafis> so I guess no hackage release in sight?
06:36:06 <Axman6> possibly after AusHac
06:36:26 <zygoloid> cryomorphobalonical panfunctors? fried sausage?
06:36:39 <dafis> I don't know whether you're familiar with alexyk's twitter thing,
06:36:40 <Axman6> i'm thinking of using them in a fast Map structure library i'd like to write
06:36:48 <zygoloid> fried reconstituted frozen sausage, at that?
06:37:04 <dafis> he's pushing Haskell pretty much to the limits
06:37:42 <Axman6> doing what?
06:37:55 <byorgey> @remember geheimdienst We employ a simple implementation of cryomorphobalonical panfunctors as introduced by Axman6
06:37:55 <lambdabot> Okay.
06:37:58 <dafis> I thought maybe a different container type would give a boost, making IntMap element-strict gained 15% for me on his sample data
06:38:13 <CalJohn_> I have an error with respect to GHC finding the profiling libraries for parsec 3: /topic
06:38:13 <lambdabot> CalJohn_: You have 1 new message. '/msg lambdabot @messages' to read it.
06:38:55 <CalJohn_> http://pastebin.com/HGriRzAi <-- sorry, the paste is here
06:38:56 <geheimdienst> kinda strange how "pan" is a kitchen object and a greek prefix
06:38:56 <byorgey> Axman6: analyzing like 5 bazillion jigabytes of twitter logs
06:38:56 <zygoloid> you know what they say, extract maps you of the cryomorphobalonical panfunctor into the charobalonical pyrofunctor
06:38:58 <dafis> Axman6, he's calculating social capital (whatever that is) from some 35 days of twitter data, about 3.5 million users
06:38:59 <CalJohn_> does anyone have any insight?
06:39:00 <wli> Pushing Haskell to the limits how?
06:39:14 <Axman6> wow
06:39:18 <wli> Where's he getting the data from?
06:39:27 <dafis> CalJohn_, did you build parsec for profiling?
06:39:33 <Axman6> though, sounds like something haskell could do (if you can keep memory usage under control)
06:39:39 <byorgey> zygoloid: of course, that's just the Yoneda lemma
06:39:39 <CalJohn_> dafis: yes, cabal install -p 'parsec >= 3'
06:39:49 <geheimdienst> caljohn_, you could have a look at ghc-pkg check for starters
06:40:23 <dafis> Axman6: don't know where he got the data from, a full run takes > 60GB RAM,
06:40:30 <Axman6> heh
06:40:41 * Axman6 's server needs more RAM
06:40:51 <byorgey> wli: limits in terms of resident memory usage, apparently.  It tickled a bug in the memory manager that cost Simon Marlow $26 to fix, because he had to rent a machine big enough to test it on =)
06:40:52 <CalJohn_> geheimdienst: I have three problems apparently, the related one is "dependency "parsec-2.1.0.1-ea096577115d95b0cfde0225e2011564" doesn't exist"
06:40:53 <dafis> he unearthed a bug in GHC's memory allocator (overflow) that cost SimonM 26 dollars for an EC2
06:41:06 <Axman6> byorgey: ha
06:41:24 <Axman6> that shoud be paid for by the IHG
06:41:40 <byorgey> it was probably paid for by Microsoft =)
06:41:46 <Axman6> i hope so
06:42:11 <mreh> is it my imagination or can I not have type signatures in an instance declaration
06:42:23 <byorgey> mreh: you cannot.
06:42:24 <geheimdienst> caljohn_, but that ea09... package is not the same that in your pasted message was the problematic one
06:42:55 <danharaj> microsoft research doesn't have machines with that much ram available to researchers? :p
06:43:10 <geheimdienst> i don't really know, i usually use cabal to reinstall lots of packages until ghc-pkg doesn't mope anymore :-)
06:43:10 <danharaj> or perhaps it takes paperwork.
06:43:13 <dafis> Axman6: and besides the memory, he also pushes the data structures (Maps, IntMaps, ByteStringTries) pretty far
06:43:41 <Axman6> he's not the one who wrote that paper on containers is he?
06:43:58 <dafis> So I'm curious whether shiny new things are on the horizon
06:44:02 <companion_cube> danharaj: no, microsoft research has such machines, but half of the ram is already used by windows :√æ
06:44:14 <dafis> Axman6: no, that was Milan Straka
06:44:44 * geheimdienst thinks ec2 is the best possible thing for these kinds of one-off efforts
06:44:48 <dafis> companion_cube, but GHC HQ runs linux :)
06:44:51 <Axman6> i hope shiny new things are on the horizon
06:44:57 <Saizan> CalJohn_: tried rerunning configure?
06:45:46 <CalJohn_> Saizan: http://pastebin.com/pENHVVTs <- when I do, I now get this message
06:46:14 <alpounet> byorgey, nice blog post
06:46:16 <CalJohn_> (I noticed I didn't have profiling libraries before and so I've installed them)
06:46:22 <alpounet> i played with similar stuffs few months ago
06:46:28 <geheimdienst> caljohn_ i guess that's a good hint what configure is telling you
06:46:52 <dafis> CalJohn_, ghc-pkg check, unregister broken packages and reinstall 
06:47:00 <Saizan> dafis: there's nothing broken here
06:47:07 <dafis> but better use cabal install than runhaskell Setup
06:47:50 <dafis> Saizan: not if plates and parsec aren't yet installed
06:48:30 <Saizan> CalJohn_: the previous error was because you installed a new parsec3 which got a different ABI version and have overwritten your old parsec3, so the old ABI version Cabal knew about isn't available anymore
06:49:22 <dcoutts> sigh, bring on the nix-style package store
06:49:25 <Saizan> CalJohn_: but! you got a different problem now, your parsec3 got built against bytestring-0.9.1.7, but you're also using ghc which wants bytestring-0.9.1.6, this is not necessarily a problem though
06:50:14 <geheimdienst> could rebuilding parsec saying "== 0.9.1.6" fix the problem? then ghc and parsec would be built against the same version
06:50:39 <CalJohn_> I've just been amending the .cabal file to add explicit versions, now i think my only problem is parsec
06:50:44 <Saizan> CalJohn_: i'd try a) just continue with Setup build  b) if (a) fails then unregister parsec-3, cabal install parsec-3.* --constraint="bytestring-0.9.1.6" -p and restart from Setup configure for plates
06:51:01 <CalJohn_> but hackage seems to imply that parsec 3.0.0 always requires bytestring 0.9.1.7
06:51:29 <CalJohn_> Saizan: ok, I have a meeting now, but i'll be back in a little while and I'll give that a try
06:51:34 <Saizan> no, it's just that cabal-install picks the latest bytestring you've installed i think
06:51:47 <CalJohn_> thanjks
06:51:55 <Saizan> CalJohn_: for your sanity you might want to unregister bytestring-0.9.1.7
06:52:09 <dafis> good advice
06:52:39 <dafis> bytestring is one of the packages it's not good to have multiple versions of
06:53:33 <byorgey> alpounet: thanks
06:54:36 <sshc> I'm wondering how I would implement an ordered container that expands on both ends, but never shrinks.  There are always exactly two pointers, and each can only move leflt or right by one.  Wheneven a pointer moves before the beginning or after the end, a value is added to that side of the list and is set to a fixed default value.
06:54:54 <Saizan> yeah, where those packages are those which are a transitive dependency of ghc or the other bunch of packages that can't be reinstalled/upgraded
06:55:01 <Saizan> unless you're not using them
06:55:26 <geheimdienst> sshc: 1. allocate all the memory in the world 2. set left pointer to 0, right pointer to ffffffffffffff 3. done
06:55:45 <geheimdienst> granted, this is skipping a few steps, but i guess it's a good prototype
06:55:57 <Saizan> geheimdienst: don't you want to set them to the middle?:)
06:56:49 <dafis> sshc: double ended queue?
06:56:54 <geheimdienst> no, i'm optimizing. all that growing and moving pointers might become a bottleneck. i'm going straight to the maximum state before crashing
06:57:20 <Axman6> sshc: why not use a Seq?
06:58:23 <nocko>  /part
07:00:39 <sshc> dafis: The implementation of dequeue doesn't seem efficient for this
07:01:45 <dafis> sshc: so you want read access in the middle? then what about Seq? 
07:01:47 <zygoloid> sshc: what traversal operations do you want on your container?
07:01:48 <sshc> I should have also mentioned that I only access and modify values that are pointed to by each of the two pointers.
07:02:01 <zygoloid> sshc: that sounds like a pair.
07:02:18 <dafis> zygoloid: space optimised:)
07:03:15 <dafis> sshc: what do you want to do with it and how big will it become?
07:03:34 <dafis> a pair of mutable arrays might be an option
07:06:18 <sshc> dafis: It could only become a few dozen elements, or it could grow to about 15,000 elements, or even more.
07:06:28 <sshc> I could work with Seq, but is there a more efficient solution that doesn't offer random access?
07:07:21 <dafis> sshc: what kind of access do you need? If you only ever look near the ends, a deque is pretty efficient
07:07:56 <dafis> if you want random access, a quasi-deque with one or two mutable arrays could be good
07:08:29 * hackagebot graph-utils 0.3.7 - A simple wrapper & quasi quoter for fgl.  http://hackage.haskell.org/package/graph-utils-0.3.7 (HiromiIshii)
07:08:57 <byorgey> sshc: sounds like you want a triple of Seqs
07:09:30 <byorgey> that way you have fast access to both ends, and to the elements at the "seams" in between the Seqs
07:09:47 <byorgey> basically, a doubly-zippered Seq =)
07:10:55 <dafis> a queque
07:11:09 <byorgey> does that make sense?  I could describe it in more detail if it doesn't
07:11:41 <byorgey> I think it should be called a dequequequeue
07:12:05 <dafis> byorgey, makes perfect sense, only I haven't the foggiest whether it's good for sshc's problem
07:12:21 <dafis> 'cause I don't know what that is
07:12:53 <byorgey> sshc's specification made sense to me
07:13:39 * geheimdienst is watching the discussion closely. zippers have been mentioned already. we have only minutes to spare til the customary "best would be a monad or a few".
07:13:48 <dafis> well, 'e said it's only accessed via two pointers at the ends
07:14:03 <dafis> yet, a deque wouldn't be appropriate
07:14:14 <dafis> what am I missing?
07:14:18 <jmcarthur> so... does anybody here actually have ghc *working* on 64 bit snow leopard?
07:14:24 <byorgey> the two pointers aren't necessarily at the end
07:14:34 <jmcarthur> the platform claims that it works, but my experiences differ
07:14:36 <byorgey> they are "fingers" into the middle of the data structure
07:14:39 <byorgey> that was my understanding
07:15:01 <byorgey> IF they move past the end, the sequence is extended with default values
07:15:09 <dafis> byorgey: right, *that* was what I was missing
07:15:56 <dafis> so I award you the Robin Hood prize for hitting the bulls-eye with the first shot
07:16:21 <byorgey> hehe, thanks
07:16:45 <byorgey> the trick is to stand back and watch others spray arrows everywhere before taking a carefully considered shot ;-)
07:17:10 * hackagebot hackport 0.2.7 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.7 (LennartKolmodin)
07:17:29 * jmcarthur tries with macports
07:22:07 <mreh> ((=<<) . ) . return . f
07:22:09 <mreh> > ((=<<) . ) . return . f
07:22:10 <lambdabot>   No instance for (GHC.Show.Show (f (f1 (m a -> m b))))
07:22:10 <lambdabot>    arising from a use...
07:22:19 <mreh> :t ((=<<) . ) . return . f
07:22:20 <lambdabot> forall a (m :: * -> *) b (f :: * -> *) (f1 :: * -> *). (Monad m, Functor f, Monad f, SimpleReflect.FromExpr (f1 (a -> m b)), Functor f1) => f1 (f (m a -> m b))
07:22:41 <geheimdienst> lambdabot: thanks for making that clear
07:22:46 <mreh> I've got the pointsfree blues
07:22:46 <jmcarthur> gah
07:22:57 <mreh> I was just trying fmap for myself
07:23:10 <jmcarthur> the haskell platform page says you can use macports to install it but doesn't mention that the macports version is not up to date (of course, what should i have expected?)
07:23:32 <sshc> Sorry, I had to part for a bit.  
07:23:37 <jmcarthur> looks like the macports version at least has patches for 64 bit snow leopard
07:24:09 * geheimdienst thinks between the Platform, distro packages, and cabal packages, it's quite difficult these days to tell what to install and what will work :-(
07:24:14 <sshc> byorgey: Are you suggesting I use a triple of Dequeues or Seqs?
07:24:20 <jmcarthur> wat. it won't build anyway because gmp is 32 bit....
07:24:32 <sshc> byorgey: And yes, you understood me correctly
07:24:34 <dafis> sshc: tripe of Seqs
07:24:42 <dcoutts> geheimdienst: ideally the distros provide the platform
07:25:12 <geheimdienst> what's it with this "gmp"? it seems every day there's someone new in here who has trouble linking against gmp
07:25:14 <byorgey> sshc: yes, that's right
07:25:37 <jmcarthur> works great on my linux box, but not that i want to do something on mac i'm having more trouble
07:25:41 <jmcarthur> *now that
07:25:42 <byorgey> sshc: the first "pointer" is to the first element of the second Seq, and the second pointer is to the first element of the third
07:25:44 <sshc> dafis: Okay.  Why not a triple of Dequeues?
07:25:51 <geheimdienst> dcoutts, agreed. however getting apple to do anything should be impossible ...
07:25:58 <byorgey> sshc: you can move the "pointers" by transferring elements between the Seqs
07:26:03 <danharaj> gmp has terrible portability.
07:26:06 <dafis> sshc: 'cause Seq provides fast access at both ends
07:26:10 <dcoutts> geheimdienst: oh sure, but we provide binaries for OSX
07:26:25 <jmcarthur> dcoutts: they don't work for me
07:26:31 <AAIBB^> winGHCi is just there to execute scripts? When i try doing hello world in Prelude> it returns errors
07:26:34 <dafis> and if you used a deque, you'd have to reverse when the pointer moves over the split
07:26:41 <dcoutts> jmcarthur: do you know why?
07:26:58 <jmcarthur> i can't install any cabal packages. it complains about trying to do 32 bit stuff on a 64 bit system
07:26:58 <sshc> If I understand them correctly, dequeues more efficiently operate on the ends?
07:26:59 <byorgey> sshc: what's a Dequeue in this context?  Is there a particular package you're referring to?
07:26:59 <dcoutts> jmcarthur: is it the macports interference thing?
07:27:05 <sshc> byorgey: Yes
07:27:21 <jmcarthur> dcoutts: i did have an old macports installation on here. does that cause problems with the binary?
07:27:26 <sshc> byorgey: http://hackage.haskell.org/package/dequeue-0.1.5
07:27:40 <byorgey> ok, I wasn't aware of that package
07:27:42 <dcoutts> jmcarthur: some people report problems with iconv from macpors clashing
07:27:50 <jmcarthur> grr
07:27:51 <sshc> And since the two pointers are ends of two of the internal containers, wouldn't dequeue be better?
07:27:52 <dcoutts> jmcarthur: I wasn't aware there was any 32/64bit problem
07:28:12 <byorgey> sshc: my basic idea was just to use a triple of some sort of linear which give you fast access to to their ends
07:28:13 <jmcarthur> it could have something to do with me previously having the macports ghc on here
07:28:26 <jmcarthur> i'll just wipe out my macports stuff and try from scratch
07:28:40 <mreh> was "lift" considered too weird a name for fmap?
07:28:41 <sshc> byorgey: I see.  So a dequeue would work great
07:29:09 <byorgey> sshc: yes.  although if I understand correctly, both dequeue and Seq give you O(1) amortized push and pop from the ends
07:29:28 <byorgey> but perhaps you know of some other reason why dequeues would actually be faster.
07:30:46 <sshc> byorgey: The two pointers can also point to the same value, by the way.
07:31:09 <dkirk> i installed latest platform last night (6.12.1), works fine on my Macbook
07:31:14 <byorgey> sshc: sure, and they can switch sides, I'm guessing?
07:31:20 <dafis> sshc: and that would be easier with Seqs than with the deques, I think
07:31:22 <sshc> byorgey: Yes.
07:31:28 <jmcarthur> dkirk: good to know. do you have macports too?
07:31:33 <byorgey> sshc: so you might need a bit more bookkeeping.
07:31:41 <sshc> dafis: Why do you think it would be easier?
07:31:46 <sshc> byorgey: Okay.
07:32:04 <dkirk> no, i hate it because it wants to reinstall everything with it's own build, even though everything's already installed by apple
07:32:05 <byorgey> sshc: in any event whether you need a bit of extra bookkeeping data or not, I wouldn't advise just using a base triple of things
07:32:18 <jmcarthur> dkirk: i hate it too
07:32:23 <byorgey> sshc: package it up inside an abstract data type that provides the operations you want
07:32:36 <byorgey> a *bare triple
07:32:38 <sshc> byorgey: Yes, I was planning to do that.
07:32:43 <byorgey> right, cool
07:32:43 <sshc> Thanks for your help!
07:32:46 <byorgey> sure!
07:32:55 <dafis> sshc: because the deque is implemented by two lists, if bothe ends are the same, you'd have to take care of one empty list
07:33:08 <dafis> just a gut feeling, though
07:33:24 <mreh> ($) = pure?
07:33:34 <byorgey> but surely the dequeue package also hides all the internals of the implementation as well.
07:33:35 <jmcarthur> const
07:33:42 <mreh> hmm
07:33:45 <jmcarthur> > pure "foo" 7
07:33:46 * mreh thinks
07:33:46 <lambdabot>   "foo"
07:34:04 <CalJohn_> Saizan: I don't know if you're still around but I followed your advice of unregistering things, and now I have the following problem: http://pastebin.com/VAaP6BNT
07:34:09 <mreh> I'm talking about pure in Pointed that is
07:34:12 <mreh> same thing right?
07:34:17 <jmcarthur> mreh: same thing
07:34:51 <jmcarthur> wiping macports didn't help
07:35:09 <jmcarthur> i wiped macports, uninstalled ghc, then reinstalled it using the binary package
07:35:12 <mreh> I get it
07:35:24 <jmcarthur> trying to update cabal-install gives me a lot of errors for each dependency
07:35:55 <dafis> CalJohn_, could there be a bytestring package in your user database?
07:36:20 <Saizan> CalJohn_: you shouldn't have installed a bytestring-0.9.1.6 in your user db
07:36:22 <jmcarthur> "32-bit absolute addresses is not supported for x86-64"  "cannot do signed 4 byte relocation"  "suffix or operands invalid for `push'"
07:36:24 <jmcarthur> etc.
07:36:38 <dafis> CalJohn_, apparently you have two versions of bytestring-0.9.1.6, that is bad
07:36:38 <Saizan> CalJohn_: you've to ghc-pkg unregister --user bytestring-0.9.1.6
07:37:33 <jmcarthur> hmm
07:37:55 <geheimdienst> jmcarthur, this might give you clues http://hackage.haskell.org/trac/ghc/ticket/3400
07:37:58 * jmcarthur wonders if he's using some cracked up version of cabal-install or something that didn't get removed or something
07:38:00 <geheimdienst> (don't know)
07:39:36 <triyo> I'm trying to extract the String representation of the parsec's ParseError type. Use of show function performs escaping. like so .... "\"attr\" (line 1, column 3):\nunexpected
07:40:05 <lpsmith> hey, how am I supposed to set the portability:  header in a file?  is there some kind of standard text to put there?
07:40:44 <dafis> lpsmith: portability: non-portable (GHC extensions) :)
07:41:49 <dafis> triyo: you want it unescaped?
07:42:07 <triyo> dafis: right
07:42:24 <dafis> triyo: what should happen with \n, \t etc?
07:43:02 <triyo> dafis: well when called via print fucntion its should actually process \n\t in my terminal as expected. 
07:43:58 <jmcarthur> eh i give up for now
07:45:13 <dafis> triyo: so you must leave those in peace, you could remove escaped double quotes if the annoy you, but as for the rest, leave as is, don't confuse the Show instance of String with what putStrLn will do
07:46:10 <triyo> but when I invoke print function, surely it should print the pretty ver?
07:47:02 <dafis> triyo: if you want to output Strings, use putStr(Ln), not print
07:47:34 <triyo> dafis: oh you are right, just gave it a try ;)
07:47:44 <dafis> triyo: print = putStrLn . show
07:50:56 <McManiaC> how do you avoid warnings like "... shadows the existing binding ..."?
07:51:01 <McManiaC> with -Wall
07:52:23 <dafis> McManiaC, don't shadow bindings
07:52:25 <ManateeLazyCat> Storing text in error message will constitute a space leak?
07:52:35 <dafis> or pass -fno-warn-name-shadowing
07:53:08 <dafis> ManateeLazyCat, might, or might not
07:53:53 * ManateeLazyCat pasted "fromUTF" at http://paste2.org/get/897047
07:53:54 <ManateeLazyCat> dafis: In gtk2hs, we have function fromUTF like above, use to peek String from C function.
07:54:16 <ManateeLazyCat> dafis: In old version, just error information, haven't add illegal string in error message.
07:54:36 <ManateeLazyCat> dafis: But it's to track where the problem when some binding function is wrong.
07:55:07 <ManateeLazyCat> dafis: So i add all text in error message, but i'm afraid this action will cause a speak leak.
07:56:20 * ManateeLazyCat pasted "fromUTF" at http://paste2.org/get/897048
07:56:20 <ManateeLazyCat> dafis: Above is old version, just error message.
07:57:21 <ManateeLazyCat> dafis: Have any way to avoid space leak and add "string" in error message? 
08:01:49 <dafis> ManateeLazyCat, the two-byte and three-byte things only give errors when there are too few bytes left, that can't give a space leak (and, btw, they should check whether the second/third byte are valid in a multibyte character). So the only possible space leak is when the first byte is invalid
08:03:21 <dafis> then don't embed the entire string in the error message (who wants to read War and Peace in an error message), but the first few bytes, let errstr = take 20 err; errlen = length errstr in errlen `seq` error (...)
08:04:39 * geheimdienst would like to read War and Peace in an error message, preferrably syslogged to /var/log/messages
08:04:57 <AAIBB^> how come [ list !! x | x <- [1..10] ] does not work
08:05:19 <geheimdienst> > let list = [1,2,3] in [ list !! x | x <- [1..10] 
08:05:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:05:26 <geheimdienst> > let list = [1,2,3] in [ list !! x | x <- [1..10] ]
08:05:27 <lambdabot>   [2,3,*Exception: Prelude.(!!): index too large
08:05:34 <geheimdienst> > let list = [1,2,3] in [ list !! x | x <- [0..2] ]
08:05:35 <lambdabot>   [1,2,3]
08:05:42 <geheimdienst> seems to work ...?
08:06:05 <AAIBB^> yeah it must have been a typo thanks
08:06:22 <AAIBB^> needed brackets around x^2
08:06:30 <geheimdienst> also not that your indexing started at 1, not 0
08:06:33 <AAIBB^> yeah
08:06:37 <AAIBB^> thank you
08:06:40 <geheimdienst> *note
08:06:41 <geheimdienst> :)
08:06:50 <ManateeLazyCat> dafis: Because we use fromUTF for downstream library peek UTFString, i add entrie string is for print meaningful debug information, if just print first few bytes, it's less helpful....
08:06:53 <AAIBB^> can i use the windows gui instead of the ghci.exe
08:07:14 <bremner> what windows gui is that?
08:07:51 <AAIBB^> i cant copy paste in ghci.exe. but win 
08:08:03 <AAIBB^> winGhci.exe does allow that
08:08:54 <bremner> AAIBB^: ok, I was just curious, don't actually know anything about Windows. Sorry.
08:09:34 <dafis> ManateeLazyCat, I doubt that more than a few hundred bytes from the first error on are needed, but anyway, force the string, case length str of { 0 -> error "WTF?"; l -> error ("invalid ... " ++ str) }
08:09:35 <AAIBB^> sure
08:10:57 <AAIBB^> how can i put multiple statements on the same like ie the ; equivalent in R 
08:11:17 <ManateeLazyCat> dafis: Can you give me improve version? Thanks. :)
08:11:17 <ezyang> AAIBB^ do {foo ; bar } 
08:11:43 <dafis> ManateeLazyCat, ? improved version?
08:11:46 <ManateeLazyCat> dafis: If still not perfect, i will revert this patch avoid latent speak leak.
08:12:03 <lpsmith> Did GHC get a segmented stack that can't be overflowed at somepoint in the recent past?
08:12:06 <dafis> try it out
08:12:09 <triyo> dafis: does doing a => show [a]  ... call the show function on all its list elements?
08:12:21 <dafis> ManateeLazyCat, try it out
08:12:28 <ManateeLazyCat> dafis: Thanks.
08:12:58 <sshc> What function does the keyword "default" serve?
08:13:26 <dafis> triyo: ? a => show [a] is not valid syntax
08:14:03 <dafis> triyo: to show a list, call show list, to apply show to all list elements, map show
08:14:17 <AAIBB^> whats the default command for cancelling calculation
08:14:29 <geheimdienst> > show [42, 37, 13]
08:14:30 <lambdabot>   "[42,37,13]"
08:14:32 <dafis> sshc: In some cases ambiguous types are resolved by defaulting
08:14:47 <ManateeLazyCat> Today, some encoding issue confuse my file-manager, now i use decodeString force all encoding to UTF8 (it's ugly).
08:14:55 <dafis> sshc: report, section 4.3.4
08:15:08 <triyo> What I mean is that if I say ....... show [a] .... Will the list recursivelly look for Show instances for list elements in order to participate in the show call?
08:15:23 <ManateeLazyCat> And perfect way need i develop a "haskell encoding detector" before decode string.
08:15:32 <dafis> AAIBB^: on *nix, ctrl-c, on windows ctrl-z?
08:15:39 <AAIBB^> ah lovely thank you
08:16:33 <byorgey> triyo: actually, not necessarily
08:16:39 <dafis> triyo: the list elements all have the same type, so the instance is only looked up once
08:16:40 <Mathnerd314> I need a function of type m [a] -> (a -> m b) -> m [b] or thereabouts... (m being the IO monad)
08:16:47 <triyo> > show [(+2), (+3)]
08:16:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:16:48 <lambdabot>    arising from a use of `...
08:16:53 <byorgey> triyo: there is a showList function which can give special behavior for showing lists
08:17:16 <byorgey> triyo: for example this is used for the Show instance of String, which is the same as [Char], but it doesn't just call show on each Char
08:17:17 <soupdragon> does sound travel ad 320 m/s?
08:17:40 <soupdragon> what if you're in a car driving 100 m/s and then does hte sound come from the front at 420 and from the back at 220??
08:18:09 <AAIBB^> soupdragon: roughly 330 m /s yes
08:18:53 <byorgey> soupdragon: no, it still travels at the same speed.  this is why really fast jets can catch up with their own sound waves and create a sonic boom
08:18:55 <lpsmith> is it possible to overflow GHC's stack at this point without running totally out of memory?
08:19:16 <soupdragon> so air has a fixed stiffness?
08:19:29 <soupdragon> related (inversely) to the speed of sound?
08:19:29 <dafis> Mathnerd314,  \mlist fun ->mlist >>= mapM fun
08:20:04 <dafis> lpsmith, don't know ask SimonM
08:20:27 <AAIBB^> no, there is a semi fixed speed of sound.. consider speed of sound the speed of waves moving in water surface.. if you move your hand faster then the waves move, then you will never encounter your own waves
08:21:27 <arw_> AAIBB^: not quite. the waves generated at the "front" of your finger will exert pressure on the back parts of your finger.
08:22:15 <c_wraith> Is it possible to move faster than sound underwater without cavitation?  That changes things severely
08:22:17 <arw_> AAIBB^: supersonic airplanes are triangular for that reason, the whole plane must fit inside the cone shaped by the soundwaves originating from the planes tip.
08:22:21 <AAIBB^> true true but not really what i was getting at 
08:23:02 <sshc> Is the "back" of a dequeue the left end or the right end?
08:23:42 <zygoloid> sshc: is the left end of a dequeue the front or the back?
08:23:51 <dafis> sshc: depends whether you look from above or below
08:24:33 <dafis> sshc: in other words, arbitrary choice
08:24:38 <sshc> I'm only reading the documentation for http://hackage.haskell.org/packages/archive/dequeue/0.1.5/doc/html/Data-Dequeue.html#v%3ApushFront
08:24:46 <sshc> Oh, I see
08:26:00 <lpsmith> dafis,  a bit of experimentation suggests that _maybe_ ghc-6.12.1 abolished stack overflows forever.   That would be nice
08:28:57 <Saizan> lpsmith: how so?:)
08:29:59 <lpsmith> Saizan, well, on /r/haskell a novice posted a bit about haskell and tail recursion,  using the standard fact example with the standard laziness bug
08:30:25 <lpsmith> And I was having trouble getting either the natural recursion or the tail recursion examples to overflow the stack on 6.12
08:30:56 <lpsmith> So,  I'm being a little optimistic,  but if GHC-6.12 did move to a segmented stack,  and can allocate new stack segments as needed,  that's pretty sweet.
08:30:56 <dafis> Saizan: at least, foldr (+) 0 [1 .. 10000000] doesn't give a stack overflow in 6.12, while it did in 6.10
08:31:05 <soupdragon> why are people so obssesed with tail recursion???
08:31:16 <lpsmith> tail recursion is important, even in haskell
08:31:24 <soupdragon> :(
08:31:27 <dafis> soupdragon, because in strict languages, it's important
08:31:45 <soupdragon> The compiler optimized certain progarms into strict ones
08:31:48 <lpsmith> even in haskell, it's important,  it's just not quite the same as a strict language
08:31:50 <soupdragon> so haskell has a strict subset inside it
08:31:59 <soupdragon> and nobody seems to make the distinction
08:32:01 <soupdragon> it SUCKSS!!!!!!
08:32:26 <lpsmith> and if you fix the laziness bug,  you get the same advantages of tail recursion
08:33:12 <Saizan> dafis: does it just grow the stack arbitrarily? how is the memory use?
08:33:37 <dafis> Saizan: pretty huge
08:33:42 * geheimdienst points out that tail recursion is not the same as fail recursion
08:33:48 <dafis> I killed ghci at 600MB
08:33:50 <Saizan> dafis: ok, that makes sense then
08:33:58 <Saizan> they just lifted the limit.
08:34:10 <Saizan> i'm not sure that's a wise choice..
08:34:18 <lpsmith> you don't set a 600MB stack initially
08:34:25 <lpsmith> at that point you use a segmented stack
08:34:33 <lpsmith> too much waste otherwise
08:34:40 <lpsmith> (and potential memory fragmentation)
08:35:10 <dafis> lpsmith: on the other hand, a limit on stack size might be useful too
08:35:12 <lpsmith> so if it's allocating 600MB of stack space,  it's just about got to be a segmented stack now, or something like it
08:35:16 <lpsmith> yeah maybe
08:35:18 <lpsmith> I don't think so
08:35:40 <lpsmith> I enthusiastically approve of the change
08:35:46 <lpsmith> but maybe :)
08:36:02 <soupdragon> so does anyone know about the stiffness of air/
08:36:03 <soupdragon> ?
08:36:05 <Saizan> dafis: i get an overflow when compiled.
08:36:12 <soupdragon> what I don't see is why the speed of sound would be constand
08:36:16 <dafis> lpsmith: if it starts thrashing madly, it might as well die
08:36:20 <soupdragon> doesnt wind turbulances and such ruin it??
08:36:29 <lpsmith> dafis: thats what ulimit is for!
08:36:37 <lpsmith> not ghc's runtime
08:36:39 <AAIBB^> guys please help out.. why does > 2*2 ; 2*4 ; 2 * 10 give errors
08:36:43 <AAIBB^> what is the correct syntax
08:36:45 <dafis> Saizan: aha
08:36:46 <soupdragon> actually I don't really beleieve sound propagates through the air
08:36:58 <soupdragon> AAIBB^ what are you trying to compute?
08:37:12 <AAIBB^> im just trying to do multiple calls to my function on the same line
08:37:15 <lpsmith> although I started thrashing,  maybe I should reduce my ulimit
08:37:17 <AAIBB^> just checking some numbers
08:37:25 <AAIBB^> i want the output to be directly under each other
08:37:26 <tromp_> use (,,)
08:37:32 <zygoloid> AAIBB^: > [2*2, 2*4, 2*10]
08:37:42 <AAIBB^> seriously
08:37:51 <soupdragon> AAIBB^, you can't have that in GHCi it doesnt support it
08:38:02 <soupdragon> well you could use pretty print
08:38:06 <soupdragon> HughsPJ or somethnig
08:38:08 <tromp_> or mapM_ print [...]
08:38:58 <AAIBB^> okay now i get [ answer 1 , answer 2 , answer 3 ] and the break off is ugly. can i have each answer starting on a new line
08:40:14 <lpsmith> Saizan, I don't get a stack overflow with 6.12.3 either interpreted or compiled
08:40:34 <lpsmith> I am consuming lots of memory though
08:40:56 <Jafet> Trying to intentionally produce stack overflows with trivial programs? Boggle.
08:41:47 <geheimdienst> > 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
08:41:48 <Saizan> lpsmith: with foldr (+) 0 [1 .. 10000000]? i've 6.12.2 though
08:41:48 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:41:48 <lambdabot>    `GHC.Num.Num t' arising f...
08:41:52 <lpsmith> Jafet, well, the point is to see if it's possible any more.   My current belief (well, hope really) is 6.12 is now a segmented stack and stack overflows are a thing of the past
08:41:52 <geheimdienst> > 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
08:41:53 <lambdabot>   Context reduction stack overflow; size = 20
08:41:54 <lambdabot>  Use -fcontext-stack=N to incre...
08:42:01 <geheimdienst> i gotta stack overflow
08:42:02 <lpsmith> Saizan, no, not quite that expression
08:42:49 <zygoloid> lpsmith: inside haskell code, GHC checks for stack overflow and reallocates the TSO if it's about to overflow.
08:43:03 <Jafet> lpsmith, I have stack overflows regularly with 6.12.1
08:43:03 <byorgey> AAIBB^: try tromp's suggestion,  mapM_ print [blah, blah, blah]
08:43:29 <zygoloid> lpsmith: however i imagine the RTS imposes a limit to prevent unbounded overflow
08:43:40 <dafis> lpsmith, Saizan: I get stack overflows for the compiled code with 6.12.20100521 too
08:43:48 <lpsmith> zygoloid, but that's new behavior in 6.12, no?
08:45:41 <zygoloid> lpsmith: i've not really looked at the RTS behavior pre-6.12 in any depth
08:45:43 <AAIBB^> thank you
08:45:47 <AAIBB^> you are the best
08:45:58 <lpsmith> zygoloid, fair enough :)
08:46:27 <lpsmith> The RTS shouldn't impose a limit to prevent an unbounded stack
08:48:50 <Jafet> Wait, are you talking about stack overflow exception or stack space overflow?
08:49:25 <lpsmith> It should be up to the operating system to limit the memory assigned to the process
08:49:25 <lpsmith> @let triangle n = foldr (+) 0 [1..n]
08:49:26 <lpsmith> triangle (10^7), at least when compiled,  worked for me, (GHC-6.12.3_
08:49:27 <lpsmith> well, the parameter was passed in via ghci
08:49:27 <lambdabot>  Defined.
08:52:25 <soupdragon> Does anyone know about this
08:52:29 <soupdragon> "I have two children, one of whom is a son born on a Tuesday. What is the probability that I have two boys?"
08:52:36 <soupdragon> it's annoying me because I thik the answer is 50%
08:52:38 <soupdragon> but he says it's not
08:52:49 <zygoloid> soupdragon: the answer is not 50%.
08:52:55 <notabel_work> soupdragon: look up dependent probability
08:52:57 <soupdragon> I think it is
08:52:59 <burp> what is the a-priori probability?
08:53:06 <burp> 50% in nature?
08:53:10 <zygoloid> burp: let's assume so.
08:53:11 <burp> for boy/girl? guess not
08:53:12 <burp> ok
08:53:13 <notabel_work> burp: not really relevant
08:53:42 <soupdragon> two children, A (50/50 boy girl) and B (50/50 boy girl). A of B (pick A WLOG) is a son - so B has 50/50 chance left...
08:54:02 <lpsmith> Jafet,  well,  a good runtime will allocate another chunk of stack on stack space overflow.   A bad runtime will throw an exception :)
08:54:03 <soupdragon> when I update ym inforamation about A I don't have any denpencen to update about B
08:54:16 <zygoloid> soupdragon: what is the probability that you have /two/ sons born on a tuesday? how does that affect things?
08:54:24 <zygoloid> (think inclusion-exclusion principle)
08:54:36 <geheimdienst> two sons on a tuesday? what kind of riddle is that
08:54:41 <burp> is it 1/3?
08:54:49 <danharaj> less than three sons on a threesday
08:55:05 <soupdragon> zygoloid: OH........   so when he says "one of which is born on a tuesday" that implies /....THE OTHER SON WAS NOT BORN ON THAT DAY?
08:55:20 <zygoloid> soupdragon: no. it implies that at least one of the sons was born on a tuesday
08:55:20 <soupdragon> so it's actually a reading comprehension problem - not a mathematics one
08:55:20 * geheimdienst marvels at danharaj's masterful understanding of probability
08:55:40 <soupdragon> yes I think danharaj cracked it
08:55:44 <Ke> what is the correlation between tuesday and gender?
08:55:46 <dafis> soupdragon the 'Tuesday' is a red herring
08:56:19 <dafis> Ke: more girls are called Tuesday than boys
08:56:24 <geheimdienst> i think we all agree that the probability of the original riddle is 50%
08:56:28 <zygoloid> soupdragon: consider the event space. 25% have no sons. 50% have one son. 25% have two sons. in the middle case, there's a 1/7 chance that son was born on a tuesday.
08:56:28 <lpsmith> I'm not entirely sure,  but I think roconnor would agree with my assessment regarding stack overflows :)
08:56:36 <zygoloid> geheimdienst: i don't agree, because it's not
08:56:46 <burp> draw a probability tree diagram :>
08:56:47 <lpsmith> preflex,  seen roconnor
08:56:48 <preflex>  roconnor was last seen on #haskell-blah 2 hours, 8 minutes and 37 seconds ago, saying: maybe bookmarked is better
08:57:27 <soupdragon> 25% have no sons. 50% have one son. 25% have two sons <--- I agree with that
08:57:29 <dafis> zygoloid: Tuesday is entirely unimportant
08:57:36 <burp> dafis: I agree
08:57:38 <zygoloid> in the final case, there's a 2 * (1/7 * 6/7) chance that one boy was born on tuesday, and a 1/7 * 1/7 chance that both were. that makes a total of 1/2 * 1/7 + 1/4 * (2 * 1/7 * 6/7 + 1/49)
08:57:42 <zygoloid> dafis: i disagree.
08:57:44 <burp> it's just in that sentence to confuse ;)
08:57:49 <zygoloid> no, it's really not.
08:57:54 <soupdragon> wait
08:57:56 <dafis> burp: and it's successful
08:57:57 <soupdragon> This is too confusing for me
08:58:01 <soupdragon> can we considre this one: Suppose that Mr. Smith has two children, at least one of whom is a son. What is the probability both children are boys?
08:58:04 <soupdragon> which is said to be simpler
08:58:04 <soupdragon> ?
08:58:08 <soupdragon> because I am actualy totally lost
08:58:11 <Phyx-> dafis: it's not, it's a day closer to friday than monday
08:59:19 <burp> soupdragon: what do you say? 50% for that?
08:59:26 <dafis> soupdragon: that's exactly the same riddle as the previous
08:59:31 <burp> if it's not 50% it must be 1/3 ;)
08:59:42 * geheimdienst read the question like this: i flip a coin, it comes up heads, now i'll flip it again, what's the probability of heads vs. tails. geheimdienst therefore thought the answer was simply 50%
08:59:52 <soupdragon> yes it's always 50%
09:00:08 <dafis> burp: conditional probability for two boys, given one child is a boy is ~1/3
09:00:35 <tromp_> in the sense of at least one
09:00:35 <burp> dafis: that's what I thought about
09:00:52 <dafis> geheimdienst, no, you flipped a coin twice, afterwards you tell your mate that one of the flips was a head
09:01:03 <geheimdienst> "I have 10 children. 9 of them are sons. What's the probability child #10 is a son?"
09:01:23 <tromp_> that doesnt sound like at least 9
09:01:42 <dafis> geheimdienst, 1/11
09:01:43 <shapr> hoi tromp_ !
09:01:44 <zygoloid> geheimdienst: 1/11.
09:01:49 <tromp_> hi, shae
09:01:58 <dafis> give or take the actual probability of boys vs girls
09:01:58 <geheimdienst> dafis, yes i can understand that. the way you describe it agrees with what zygoloid said (25% 50% 25%)
09:02:05 <danharaj> It's like the reverse of the gambler's fallacy :p
09:02:13 <zygoloid> geheimdienst: there're 11 different equiprobable ways of getting at least 9 sons
09:02:20 <zygoloid> but the Tuesday thing matters too
09:02:22 <soupdragon> O_O
09:02:37 <soupdragon> what the hell!
09:02:39 <dafis> geheimdienst, except if with child #10 you meant the tenth born
09:02:45 <soupdragon> you're saying that if I flip 10 coins and get heads every time
09:02:46 <ManateeLazyCat> IMO, Google Chrome's sandbox is "separate process + permission control", more feature?
09:02:57 <soupdragon> the probability that the next coin I flip being tails is HIGHER than 50%?
09:03:02 <zygoloid> soupdragon: no.
09:03:07 <geheimdienst> by "child #10" i meant "the remaining child"
09:03:14 <tromp_> ok, with 10 children, and at least 9 boys born on tuesdays, what is prob of 10 boys?
09:03:15 <soupdragon> wait
09:03:17 <dafis> soupdragon, no, you flip ten times, then count
09:03:27 <notabel_work> soupdragon: no, you're confusing the ordering information
09:03:29 <soupdragon> can you turn the problem of martin gardner into a formal statement
09:03:42 <geheimdienst> i think dafis has me convinced that this reading of the question is right
09:03:42 <soupdragon> can there be a haskell program whch expresses this ----> Suppose that Mr. Smith has two children, at least one of whom is a son. What is the probability both children are boys?
09:03:58 <zygoloid> soupdragon: suppose that we have two random variables, A and B, each uniform in the range 1..14.
09:03:59 <soupdragon> because I have a feeling my prbolem is reading comprehension ...
09:04:14 <soupdragon> and I can read haskell but not this english sandwhich stuff
09:04:16 <zygoloid> soupdragon: what is the probability that both are 7 or less, given that one of them is 1
09:04:24 <zygoloid> (/at least/ one of them is 1)
09:04:33 <danharaj> It is pretty tricky to extract all the relevant information correctly from a scenario to do probability/statistics to it.
09:04:40 <soupdragon> all I know about random variables is that they don't act like numbers
09:04:42 <danharaj> Intuition fails.
09:04:49 <soupdragon> guys do you think I am just too stupid to understand it
09:05:11 <dafis> > filter ((>= 2) . length . filter id) $ filterM (\_ -> [True,False]) [0 , 1, 2]
09:05:11 <zygoloid> soupdragon: no, it's genuinely surprising and weird, and your intuition will point you the wrong way.
09:05:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
09:05:12 <lambdabot>    arising from the literal `0'...
09:05:26 <dafis> > filter ((>= 2) . length . filter id) $ filterM (\_ -> [True,False]) [True, True, True]
09:05:27 <lambdabot>   [[True,True,True],[True,True],[True,True],[True,True]]
09:05:32 <geheimdienst> "Mr. Curry has 1 child, a son. What is the probability his next child will be a son?" <-- i somehow misread the original riddle to be this one. this here is 50-50, right?
09:05:39 <Snark> I have failed to parse something like "id = {value}," with parsec
09:05:44 <geheimdienst> (modulo the tuesday thing)
09:05:51 <tromp_> given 10 people in #haskell, at least 9 of which understand monty hall, what is prob all 10 do?
09:06:01 <Snark> the problem is the value can contain things like { } and ,
09:06:03 <dafis> tromp_ 0
09:06:05 <soupdragon> 100%
09:06:05 <danharaj> 100% - this is #haskell
09:06:09 <soupdragon> LOL
09:06:10 <geheimdienst> ... what is the probability the 10th guy is a goat ...
09:06:14 <soupdragon> haha
09:06:32 <tromp_> on the internet, nobody knows you're a goat
09:06:49 <byorgey> Snark: Quoting is Hard
09:06:50 <geheimdienst> so one thing i didn't get: why are there 11 equiprobable ways to have 10 children?
09:07:03 <dafis> geheimdienst: yes if it wold have been said that the first child is a boy, the probability would be 50%
09:07:23 <dafis> geheimdienst: 10 ways for 1 girl and 9 boys
09:07:26 <zygoloid> there are 196 options. of those, 27 have a boy born on Tuesday. of those, 13 have two boys. the probability is 13/27.
09:07:31 <dafis> one way for ten boys
09:07:37 <zygoloid> without the tuesday information the probability is 1/3. that's the surprise.
09:07:39 <byorgey> Snark: do the values have structure, or are they just arbitrary strings?
09:07:59 <bnonym> tromp_: no, on the internet, everybody is a goat
09:08:05 <danharaj> I like basic probability because a lot of it can be solved by composing filters and folds :)
09:08:31 <soupdragon> did anyone turn the problem in haskell code?
09:08:40 <soupdragon> I would read the code an maybe understand ;x
09:08:55 <danharaj> soupdragon: construct a list of all possible ways to have 10 children
09:08:56 <tromp_> print (13%27)
09:09:00 <burp> haha
09:09:00 <soupdragon> 10??
09:09:02 <soupdragon> I only want 2
09:09:04 <dafis> > filter ((>= 2) . length) $ filterM (\_ -> [True, False]) [0,1,2]
09:09:05 <lambdabot>   [[0,1,2],[0,1],[0,2],[1,2]]
09:09:28 <geheimdienst> dafis: roger that. so it hinges on the word in "the ___ child is a boy". if ___ = "first", then we're in the "flipped a coin, now i'll flip it again = 50%" case. if ___ = "one" we're in the case "flipped two coins, told you about one of them = 1/3" case
09:09:34 <dafis> three children with at least two boys
09:09:39 <burp> as I said, draw a probability tree
09:09:57 <dafis> geheimdienst, exactly
09:10:14 <monochrom> most problem statements are sloppy
09:10:20 <Snark> byorgey, they have some mild structure
09:10:21 <soupdragon> can you make it formal?
09:10:45 <Snark> byorgey, example : Interpolation {$p$}-adique
09:11:00 <Snark> which I got through as "{Interpolation {$p$}-adique},"
09:11:14 <geheimdienst> monochrom, the world is a sloppy problem statement. it's up to you to extract the relevant bits of information and not get confused by the irrelevant ones
09:11:37 <zygoloid> can people please stop claiming the Tuesday thing is irrelevant. it's the crux of the problem.
09:12:07 <dafis> zygoloid: Noooooo
09:12:16 <Jafet> I could never get the hang of Tuesdays.
09:12:20 <burp> who has the higher degree? :P
09:12:23 <burp> fight
09:12:24 <dafis> It's just there to confuse people
09:12:35 <dafis> of course, that's the whole point
09:12:36 <burp> I vote for confusion
09:12:37 <zygoloid> @let child = [(isBoy, dayOfBirth) | isBoy <- [True, False], dayOfBirth <- [0..6]]
09:12:38 <lambdabot>  Defined.
09:12:50 <zygoloid> @let space = [(a, b) | a <- child, b <- child]
09:12:52 <lambdabot>  Defined.
09:13:06 <monochrom> geheimdienst: that does not justify adding more sloppy problem statements
09:13:11 <AAIBB^> how do i display a range of a list
09:13:21 <zygoloid> @let eitherIsTuesdayBoy ((True, 1), _) = True; eitherIsTuesdayBoy (_, (True, 1)) = True; eitherIsTuesdayBoy _ = False
09:13:22 <lambdabot>  Defined.
09:13:32 <dafis> zygoloid: I have two children, one is a boy and wears a blue sweat-shirt today
09:13:47 <dafis> what's the probability that both children are boys?
09:13:48 <zygoloid> @let bothAreBoys ((True, _), (True, _)) = True; bothAreBoys _ = False
09:13:50 <lambdabot>  Defined.
09:13:50 <Snark> AAIBB^ : reverse $ drop n1 $ reverse $ drop n2 list ;-)
09:14:11 <burp> dafis: um, that's hardÖ one has to count the number of possible colors :p
09:14:20 <Snark> byorgey, ^  that's how I solved my problem... ugly...
09:14:35 <dafis> burp: only eight bits for clothes
09:14:38 <burp> ok ;P
09:14:39 <geheimdienst> monochrom, i meant the problem statements are probably meant as an exercise to get you good at guessing the right reading. which is what you'll have to do in the real world.
09:14:44 <soupdragon> im reading this code
09:14:46 <zygoloid> > length [0 | x <- space', eitherIsTuesdayBoy x, bothAreBoys x] % length [0 | x <- space', eitherIsTuesdayBoy x]
09:14:48 <lambdabot>   13 % 27
09:14:49 <AAIBB^> hmm even worse.. i have [ 011010101010101010010010101 ] and i want to view the 10-20th place
09:14:50 <zygoloid> dafis: ^^ you were saying?
09:15:01 <AAIBB^> nah i have ''101010100101101010101'
09:15:27 <zygoloid> @let eitherIsBoy ((b1, _), (b2, _)) = b1 || b2
09:15:29 <lambdabot>  Defined.
09:15:29 <monochrom> no, the world is different from most sloppy problem statements
09:15:37 <zygoloid> > length [0 | x <- space', eitherIsBoy x, bothAreBoys x] % length [0 | x <- space', eitherIsBoy x]
09:15:38 <lambdabot>   1 % 3
09:15:41 <dafis> zygoloid: that the 'Tuesday' is an entirey irrelevant piece of information with the sole purpose of confusing people
09:15:48 <zygoloid> dafis: i /just/ proved that it's not.
09:15:55 <burp> you didn't
09:16:02 <burp> you just build it into it
09:16:09 <burp> that's does not prove it's necessary 
09:16:16 <zygoloid> it gives a different answer
09:16:21 <dafis> @let isPrime n = n < 4 || odd n
09:16:21 <monochrom> sloppy problem statements miss information, even lie. the world doesn't miss information and doesn't lie.
09:16:22 <lambdabot>  Defined.
09:16:27 <dafis> > isPrime 9
09:16:28 <lambdabot>   True
09:16:31 <geheimdienst> zygoloid, why is tuesday relevant? what are these 196 cases you mentioned?
09:16:38 <dafis> there, I proved that 9 is prime
09:16:48 <zygoloid> dafis, burp: lambdabot just said, the answer with the tuesday assumption is 13%27. the answer without is 1%3.
09:17:00 <soupdragon> dafis, I don't agree
09:17:03 <burp> dafis: thanks
09:17:08 <soupdragon> dafis, I think there was an error in your program
09:17:09 <geheimdienst> dafis, very good
09:17:15 <dafis> zygoloid, lambdabot ssays what you tell him to say
09:17:26 <zygoloid> geheimdienst: each person is either male or female, and born on day 0..6. 14 combinations for each person, independently
09:17:29 <AAIBB^> dafis; pretty clear here that its 50% chance. But behavioural and emperically minded economists or biologists would disagree with me
09:17:33 <soupdragon> People who don't understand that a proof requires a correct argument
09:17:50 <zygoloid> dafis: please take a step back here and examine the calculation i've done. then try to present an argument that it's wrong, or accept that it's right.
09:18:01 <AAIBB^> if i have 1000 kids, and the first 999 are male, what is the chance that the next one is a male as well ? Still 50%.
09:18:03 <zygoloid> i'm more than happy for you to say that my calculation is wrong, but please at least look at it
09:18:17 <burp> your calculation based on what you think is right, is right
09:18:33 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] ; filter [ (a,b) | (a,b) <- space, a == "boy" || b == "boy" ]
09:18:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:18:38 <zygoloid> burp: same to you. please identify the error, or stop claiming there is one.
09:18:43 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in filter [ (a,b) | (a,b) <- space, a == "boy" || b == "boy" ]
09:18:44 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
09:18:44 <lambdabot>         against inferred ...
09:18:45 <burp> zygoloid: I could say the same
09:18:47 <geheimdienst> roger, so we have 14*14 = 196 ways to spread 2 children over 7 days
09:18:51 <zygoloid> burp: present an argument then.
09:18:51 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in filter [ (a,b) | (a,b) <- space, assert (a == "boy" || b == "boy") ]
09:18:53 <lambdabot>   Not in scope: `assert'
09:18:55 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in filter [ (a,b) | (a,b) <- space, guard (a == "boy" || b == "boy") ]
09:18:56 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
09:18:56 <lambdabot>         against inferred ...
09:19:00 <zygoloid> burp: why should the day be irrelevant?
09:19:15 <dafis> zygoloid: will you stay around? I have to buy some stuff or I'll starve tonight. And I'll have to inspect your reasoning in detail. Both will take some time.
09:19:15 <burp> my problem is that I don't understand why it should be relevant :|
09:19:20 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in filter [ (a,b) | (a,b) <- space, if (a == "boy" || b == "boy") then [()] else [] ]
09:19:22 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
09:19:22 <lambdabot>         against inferred ...
09:19:32 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in [ (a,b) | (a,b) <- space, (a == "boy" || b == "boy") ]
09:19:34 <lambdabot>   [("boy","boy"),("boy","girl"),("girl","boy")]
09:19:34 <zygoloid> dafis: sure, i'll be here for the next three hours or so.
09:19:36 <ManateeLazyCat> > isURI "http://www.google.com"
09:19:38 <lambdabot>   Not in scope: `isURI'
09:19:51 <soupdragon> O_O
09:19:51 <ManateeLazyCat> How to load Network.URI?
09:19:55 <burp> yeah, let's all think about this more :>
09:19:57 <zygoloid> burp: yes, it's counterintuitive. but probability is full of counterintuitive results.
09:20:15 <dafis> zygoloid: if I don't manage, tomorrow?
09:20:17 <tromp_> the tuesday almost identifies which one (elder/younger) is said to be a boy
09:20:24 <zygoloid> burp, dafis: here's an easier explanation of why it's relevant...
09:20:29 <soupdragon> if you have two children (space) and one is known to be a boy, the other one is probably a girl
09:20:38 <soupdragon> LLOL WHAT that doesn\t make any sense
09:20:50 <zygoloid> suppose person X has two children. one of them is Simon Peyton Jones. what is the probability that both are boys?
09:21:08 <zygoloid> unless you know about the Peyton Jones family tree, that is /clearly/ 50%.
09:21:13 <monochrom> perhaps the other is also Simon Peyton Jones <run>
09:21:16 <dafis> soupdragon, if one specific is known to be a boy, for the other it's a coin-flip
09:21:43 <zygoloid> the point is, the more you narrow down the choice of boy, the more independent the two genders become and the closer to 50% the answer is.
09:22:04 <soupdragon> zygoloid ooh
09:22:08 <soupdragon> that explains the tuesday thing
09:22:11 <zygoloid> right.
09:22:14 <soupdragon> I still don't get this one though:
09:22:15 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in [ (a,b) | (a,b) <- space, (a == "boy" || b == "boy") ]
09:22:16 <lambdabot>   [("boy","boy"),("boy","girl"),("girl","boy")]
09:22:24 <soupdragon> do I interpret this as saying there is 2/3 chance of a girl
09:22:30 <danharaj> yes.
09:22:50 <tromp_> consdier this version: i have two children, one is a boy called "Tuesday". what's the prob the other is a boy?
09:22:58 <soupdragon> 50%
09:23:25 <zygoloid> soupdragon: yes, that's right. there are three different, equally likely, two-child families with at least one boy. one of those has two boys, the other two have one boy and one girl.
09:23:29 <tromp_> not if i call them both tuesday:)
09:23:54 <burp> "I have two children, one of whom is a son born on in April. What is the probability that I have two boys?"
09:23:56 <burp> what about this?
09:23:57 <danharaj> "A boy called Tuesday" sounds like a movie.
09:24:11 <zygoloid> burp: just under 50%.
09:24:15 <burp> or "I have two children, one of whom is a son born in 1950. What is the probability that I have two boys?"
09:24:21 <geheimdienst> danharaj, what's the probability of that movie being made?
09:24:32 <Jafet> That sounds like a cross between Citizen Kane and Forrest Gump.
09:24:34 <burp> these are all datesÖ
09:24:59 <zygoloid> burp: for the 1950 one, we can't assume uniformity any more
09:25:05 <monochrom> I have two children, one is called May, one is called June.
09:25:17 <burp> zygoloid: ok, yes
09:25:18 <zygoloid> (not that we could for the April one either, but days of the week are basically uniform)
09:25:24 <tromp_> is May born in June?
09:25:32 <zygoloid> did June give birth to May?
09:25:44 <danharaj> "I have two random turing machines with n states and m symbols. One of them is a halting turing machine. What is the probability that both my turing machines halt?"
09:25:47 <danharaj> :D :D :D
09:25:51 <soupdragon> wait: what
09:25:53 <Jafet> zygoloid, oh dear
09:26:18 <soupdragon> this is insane
09:26:24 <soupdragon> probability is a lie
09:26:32 <danharaj> no, statistics is a lie.
09:26:40 <zygoloid> probability is surprising truth.
09:26:43 <geheimdienst> it sure is counterintuitive and very easy to get tripped up
09:26:45 <monochrom> yeah, didn't you hear? there are lies, damn lies, and probability
09:26:56 <tromp_> 78.1% of all statistics is made up oin the spot
09:27:02 <soupdragon> wait so if our family has two children and the YOUNGEST Is a boy
09:27:09 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in [ (a,b) | (a,b) <- space,a == "boy" ]
09:27:11 <lambdabot>   [("boy","boy"),("boy","girl")]
09:27:12 <soupdragon> the probaiblity is 50%
09:27:16 <monochrom> it is not so much "counterintuitive" as "people just presume"
09:27:20 <zygoloid> any long-term watcher of Let's Make A Deal know that probability is surprising
09:27:21 <soupdragon> but if one of the two is a boy and we are not told which
09:27:27 <soupdragon> > let space = liftM2 (,) ["boy","girl"] ["boy","girl"] in [ (a,b) | (a,b) <- space, (a == "boy" || b == "boy") ]
09:27:28 <lambdabot>   [("boy","boy"),("boy","girl"),("girl","boy")]
09:27:34 <geheimdienst> soupdragon, scroll back :) i talked with dafis about that just a few minutes ago
09:27:34 <soupdragon> this is interesting...
09:27:51 <soupdragon> how to we know that ("boy","boy") is to be counted once rather than twice?
09:27:58 <soupdragon> because ("boy","boy") contributes two boys
09:28:05 <monochrom> people just presume "one of them is boy" equals "first born is boy"
09:28:14 <tromp_> i dont
09:28:16 <soupdragon> but the second could be a boy
09:28:19 <ddarius> monochrom: I doubt that.
09:28:42 <zygoloid> soupdragon: do you know about the inclusion-exclusion principle?
09:28:57 <soupdragon> yes I do
09:29:31 <zygoloid> ok. so we know there's at least one boy. so either the first child is a boy (in which case there's a 50% chance of two boys)... or the second child is a boy (in which case there's a 50% chance of two boys)
09:29:41 <monochrom> if people didn't presume, they would carefully simulate, like all of you do with those haskell code above, then they would find out what it entails, then they would learn, and then it would be intuitive.
09:29:43 <soupdragon> wait
09:29:50 <soupdragon> you can't say either the first or the second is a boy
09:29:53 <soupdragon> that misses the chance of both being boys
09:30:05 <zygoloid> yes, we've counted the case where they're both boys twice.
09:30:07 <danharaj> either...or... is ambiguous
09:30:17 <soupdragon> are we supposed to count it twice or not :(
09:30:18 <zygoloid> so we need to subtract that off
09:30:21 <soupdragon> maybe like
09:30:27 <soupdragon> we should get real families and count this
09:30:35 <zygoloid> soupdragon: ok, do you know what P(x) really means?
09:30:40 <soupdragon> not really no
09:31:03 <soupdragon> @hoogle random
09:31:04 <tromp_> the subtlety can be made apparent by comparing: "one is a boy" with  "the one i have in mind is a boy"...
09:31:04 <lambdabot> package random
09:31:04 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
09:31:04 <lambdabot> module System.Random
09:31:10 <zygoloid> roughly, we have some set U which is our universe. x is then really {u | u <- U, x u}
09:31:36 <zygoloid> soupdragon: and finally P(x) is |x| / |U|
09:31:59 <zygoloid> where |x| is the 'measure' of x. let's just say it's the number of elements in x.
09:32:51 <zygoloid> so we're imagining a universe where we have two children. this universe has four elements, (Boy, Boy), (Boy, Girl), (Girl, Boy), (Girl, Girl).
09:33:13 <zygoloid> conditional probability is about imagining a smaller universe
09:33:23 <burp> http://science.slashdot.org/story/10/06/28/2221252/The-Tuesday-Birthday-Problem
09:33:31 <zygoloid> we're told that one is a boy, so we're reduced to a universe with three options (no (Girl, Girl))
09:33:38 <danharaj> ew slashdot
09:33:58 <burp> there is an extensive explanation
09:34:00 <chrisdone> ‚âàbi
09:34:03 <chrisdone> woops
09:34:29 <zygoloid> so P(two boys | at least one boy) = 1 / 3 (we get this directly from the measure of the relevant sets)
09:35:29 <danharaj> The tuesday problem depends on how many days there are in a week :D
09:36:31 <tromp_> specifically , on the prob that the description can apply to both children
09:36:35 <Jafet> Funday, boozeday
09:37:24 <soupdragon> http://pastie.org/1023642.txt
09:37:26 <soupdragon> this says 33%
09:37:55 <zygoloid> the inclusion-exclusion bit is: P(at least one boy) = P(A is boy \/ B is boy) = |{A is boy \/ B is boy}| / 4 = (|{A is boy}| + |{B is boy}| - |{A is boy /\ B is boy}|) / 4 = (2 + 2 - 1) / 4 = 3/4
09:38:50 <zygoloid> soupdragon: that's the correct answer :)
09:40:07 <monochrom> perhaps there are only 6 days in a week because due to religious reasons giving birth is not allowed on Saturday or something :)
09:40:24 <soupdragon> so when we say one is a boy
09:40:29 <soupdragon> we discount the girl/girl situation
09:40:43 <zygoloid> soupdragon: exactly.
09:40:53 <soupdragon> now we can either say
09:41:03 <soupdragon> (A) that leaves boy/girl, boy/boy
09:41:04 <soupdragon> or
09:41:18 <soupdragon> (B) that leaves one boy one girl or both boys
09:41:21 <soupdragon> afaict... both are correct
09:41:38 <soupdragon> yet they lead to different answers
09:41:40 <zygoloid> in (A), what's happened to girl/boy?
09:41:56 <ddarius> soupdragon: No they don't.
09:42:22 <soupdragon> oops
09:42:24 <ddarius> Because if boy/girl means {boy, girl} (= {girl, boy}) that possibility has higher probability.
09:42:25 <soupdragon> I actually wrote A wrong
09:42:35 <soupdragon> (A) that leaves boy/girl, girl/boy, boy/boy
09:42:43 <soupdragon> ddarius oh good point!
09:42:55 <soupdragon> the chance of having one girl and one boy is higher than having two boys
09:43:00 <soupdragon> omg it's so simple now
09:44:47 <burp> zygoloid: ok I'm convinced now ;)
09:45:26 <burp> this is even worse than monty hall ;)
09:47:18 <ddarius> A good way to demonstrate the Monty Hall problem to someone who is resisting the idea and believes either approach is equally likely is to simulate it, but optimize it on the basis that they always stay.
09:47:54 <ddarius> At that point it is just choosing one option out of three and it is immediately obvious that the probability is 1/3rd and thus the alternative is 2/3rds.
09:48:09 <geheimdienst> i've understood monty hall once i thought about it like this: i have 1000 doors, you pick one, now i open 998 doors and leave only your and the prize door closed. guess what.
09:48:28 <soupdragon> so what is the value of probability
09:48:31 <geheimdienst> even better: "now i show you 998 doors that are empty"
09:48:37 <soupdragon> like suppose I had an intuitive understanding of probability
09:48:40 <soupdragon> what would that mean?
09:48:52 <ddarius> soupdragon: It would mean you made good decisions given good information.
09:49:07 <soupdragon> that sounds very valuable.
09:49:17 <danharaj> good information is hard to come by.
09:49:25 <ddarius> It is a lot more valuable than the common alternative of making bad decisions given good information.
09:51:16 <ddarius> Best decisions with the given information.
09:53:14 <tromp_> generic version: 2 children, at least one is boy with property P.  probability both are boys is (2-p)/(4-p), where P is probability of having prperty P
09:53:38 <tromp_> think the 2nd last P shld be p :)
09:54:03 <chrisdone> use a different letter
09:54:36 <monochrom> (2-P(P))/(4-P(P))
09:55:49 <monochrom> finding good information is another skill to hone for
09:56:27 <EvanCarroll> wtf doesn't X11 en_US have Lambda defined in the Compose DB
09:56:39 <chrisdone> it does
09:56:45 <chrisdone> it's probably spelled wrongly
09:56:51 <ezyang> EvanCarroll: There are plenty of XCompose on crack 
09:56:51 <chrisdone> lamdba
09:57:02 <chrisdone> or lamda
09:57:03 <monochrom> going meta, judging the quality of a piece of information is again a decision skill and benefits from probability and/or probability intuition. "is it likely that monochrom lies? how likely? how much is the risk?"
09:57:29 <ezyang> ‚Äúmonochrom always tells the truth. all hail monochrom.‚Äù 
09:57:39 <geheimdienst> evancarroll, it might also be case-sensitive and you need to say lambda or something
09:57:45 <chrisdone> ezyang uses unicode, all hail ezyang
09:58:14 <chrisdone> the xmodmap name is spelled wrongly
09:58:32 <geheimdienst> (in fact i'm pretty sure it's case sensitive. Aacute is √Å and aacute is √°)
09:58:35 <EvanCarroll> geheimdienst: it isn't in there at all so far as i can see
09:59:25 <EvanCarroll> E486: Pattern not found: Œª 
09:59:31 <EvanCarroll> no joy
10:02:25 <geheimdienst> x keyboard layouts have always been a topic that scare and confuse me
10:02:54 <theorbtwo> ...and pretty well everybody else, too.
10:03:12 * Hunner <3's xkb maps
10:03:14 <EvanCarroll> writing a custom compose is fairly simple, I'm just very shocked that they're missing.
10:03:32 <geheimdienst> evancarroll, isn't there some variant for that. for example, i use the layout de with the variant nodeadkeys which makes ¬¥ and ^ print immediately instead of waiting for a letter to compose onto
10:04:00 <EvanCarroll> yea, but who wants to change a layout. This has nothing to do with a layout, I just want to get a single character.
10:04:02 <geheimdienst> so there must be some variant with greek symbols that you can overlay onto the us layout ... right?
10:04:11 <Jafet> "Putting the grr in altgr"
10:04:22 <geheimdienst> no, layout is one thing, the variant is a different thing
10:04:46 <EvanCarroll> yes. you can compose ` and ^ onto a character if it is in your compose db.
10:04:51 <EvanCarroll> But, that has nothing to do with nodeadkeys
10:05:10 <EvanCarroll> deadkeys, are just a key that you can use as an alternative keyboard modifier.
10:05:13 <Jonno_FTW> hello I am trying to install lambdabot, and I get the error:  Could not find module `System.Posix.Signals':
10:05:15 * edwardk_ waves hello.
10:05:16 <Jonno_FTW>       It is a member of the hidden package `unix-2.4.0.2'.
10:05:23 <edwardk_> hrmm
10:05:31 <EvanCarroll> usually AltGr (Right Alt on US 104key)
10:05:50 <theorbtwo> My laptop runs us layout with a compose key on caps-lock.  Dead keys are similar to compose key, and then one of the two keys to compose, but not quite.
10:06:06 <theorbtwo> EvanCarroll: That isn't true; a true US layout has two Alt keys and no AltGr key.
10:06:07 <geheimdienst> what? the normal "de" layout has dead keys. if i say "XkbLayout de XkbVariant nodeadkeys" in my xorg.conf, then i get "de" with no dead keys
10:06:07 <edwardk_> i realize that applicatives have a canonical composition that always makes sense, but is there an instance Applicative m => Applicative (StateT s m) ? -- i find myself needing it
10:06:12 <EvanCarroll> everyone should be using Linux International Keyboard w/ Alt+Gr dead
10:06:33 <EvanCarroll> theorbtwo: no, alt+gr is just the right alt. the keymap has it mapped to left alt by default
10:07:00 <edwardk_> (even if it doesn't exist, can it exist?)
10:07:06 <geheimdienst> all i'm saying is, there must be some variant you can bolt onto your "us" layout which gives you greek symbols, e.g. for right-alt combinations or something
10:07:36 <Hunner> Hmm. The de neo layout is fancy
10:07:42 <theorbtwo> No, altgr (not alt+gr) is the alternate graphic key, for producing different symbols.  The Alt key is for shortcuts.  A true US keyboard (not a US international) has two alt keys and no altgr key.
10:08:09 <theorbtwo> US on a 103 key, with the 103rd key (between shift and z) being compose is my favorite layout.
10:08:40 <EvanCarroll> theorbtwo: I have a "true US" keyboard, with a keylabeled Alt, it works fine under my AltGr dead key layout
10:08:42 <theorbtwo> If you have a compose key, you don't need an altgr.
10:08:45 * geheimdienst uses the menu key, which is one useless sucker, as the compose key
10:09:04 <theorbtwo> EvanCarroll: Yes.  You have a US keyboard but use a us international layout.
10:09:43 <EvanCarroll> right -- I'm not sure I follow... Doesn't this layout just map right-alt to alt-gr?
10:09:48 <EvanCarroll> s/alt-gr/altgr
10:10:46 <Taejo> it doesn't *just* do that -- it also makes altgr *do* something
10:10:51 <Taejo> but yes, it does that
10:10:59 <theorbtwo> EvanCarroll: Yes, quite.
10:11:59 <Hunner> EvanCarroll: try `xmodmap -pm`
10:12:23 <Hunner> Do you have a Mode_Switch or Alt_R?
10:13:09 <EvanCarroll> mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)
10:13:39 <randomwords> I'm on ubuntu and I want to do a clean install of the haskell platform (due to broken packages). What do I need to remove?
10:15:37 * geheimdienst doesn't like keyboard layouts exactly because of this. xmodmap makes him nervous through confrontation with random incomprehensible things. what on earth is an "ISO_Level3_Shift", for example.
10:16:43 <Hunner> It's a shift that moves up 3 levels instead of 1 (there are 8 levels)
10:17:52 <Apocalisp> How can I combine several readers into one monad?
10:18:22 <ezyang> Apocalisp: ReaderT 
10:18:36 <ezyang> though you might want some sort of tagging so you don't drown in a sea of lifts 
10:18:51 <edwardk_> anyone re the applicative stateT?
10:19:14 <Apocalisp> ezyang: Thanks, that might be what I want.
10:19:50 <edwardk_> i can probably come up with a workaround if need be, but it'd still be useful ;)
10:20:15 <darklust> DCC SEND LOLOLOLOLOLOLOL
10:21:01 <Phyx-> ooo.. k....
10:21:52 <geheimdienst> hunner, thanks a lot. that one sentence of explanation actually was more helpful than the manpages and half dozen websites i've been reading about xkb
10:33:32 <alexyk> 1:32 EST: the lull minute.  Haskellers stuff their faces.
10:33:43 <alexyk> ...and burp
10:35:16 <alexyk> anybody pimped their ghci with this: http://hackage.haskell.org/trac/ghc/ticket/2362?
10:36:25 <BMeph> A burp flood...Beware! =8*O
10:36:29 <burp> o0
10:36:31 <burp> what happened?
10:37:14 <alexyk> burp: the people finished their lunches, and burped
10:37:22 <burp> ah, I see
10:37:36 <alexyk> burp: but you're in EU, so it's probably supper for you
10:38:22 <alexyk> what does this synatx mean: fmap (dcaps !) tr -- ?
10:38:45 <alexyk> the ! part?
10:38:50 <geheimdienst> @hoogle !
10:38:50 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
10:38:50 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
10:38:50 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
10:38:51 <c_wraith> ! is a normal infix function
10:38:51 <alexyk> after a space? 
10:38:56 <alexyk> ah ok
10:39:02 <alexyk> bang confusion
10:39:25 <alexyk> (this is from dafis' strictification of the twitter stuff)
10:40:39 <alexyk> haskell's gaining on ocaml!  gotta play banjo pursuit music!
10:42:06 <alexyk> so I need a system of strictification.  I'm unwilling to spend half my time worrying about whether my FP is in addition strict enough to work.  I'd rather do OCaml then throughout.  Who can defend the extra need to strictify, or, instead, can a large data-structure-heavy program be written in a fully lazy way?
10:42:30 <alexyk> i.e., how can lazyness be an advantage in large data compute?
10:42:37 <alexyk> when all of the data is used?
10:42:49 <akosch> when i try to install ghc on my system i get: ghc-pkg: mkTextEncoding: invalid argument (Invalid argument)
10:43:30 <akosch> am i missing something?
10:44:54 <BMeph> akosch: Possibly, but we definitely are. Would you mind telling us 1) what system this is, and 2) How are you installing ghc on it? :)
10:45:31 <akosch> BMeph: this is a fairly old machine, with an unsupported distro :)
10:46:01 <alexyk> given the lazyness, is there any meaningful way to time things inside a Haskell program, from point A to B?  How is it done
10:46:03 <alexyk> ?
10:46:20 <akosch> BMeph: i've downloaded the ghc binary distribution from the ghc site (ghc-6.12.3-i386-unknown-linux-n.tar.bz2)
10:46:52 <tromp_> u can time progress within IO monad
10:46:54 <akosch> BMeph: configure was missing a few things, but i could install them
10:46:55 <Ke> alexyk: in IO you can obviously get tomes
10:47:09 <alexyk> Ke: tomes?
10:47:10 <Ke> alexyk: but there are also profile capabilities
10:47:12 <akosch> BMeph: and i get the above error during make install
10:47:16 <Ke> alexyk: time
10:47:25 <alexyk> Ke: how?
10:47:42 <alexyk> yeah, I'm in IO
10:47:45 <Ke> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/time-1.1.4/doc-index.html
10:48:14 <alexyk> thx
10:48:19 <Ke> unix extensions have some things that might be more convenient for you
10:48:22 <Dashkal> Is there a way to get at a TyCon for []?
10:49:38 <Ke> alexyk: like http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-Time.html
10:49:51 <BMeph> akosch: You may want to try an earlier version, like 6.12.1
10:50:03 <akosch> BMeph: ok, thanks
10:50:21 <alexyk> Ke: goodgood
10:50:21 <BMeph> akosch: Sure - good luck...
10:52:31 <dafis> zygoloid, here?
10:53:55 <dafis> preflex: seen zygoloid
10:53:56 <preflex>  zygoloid was last seen on #haskell 1 hour, 12 minutes and 16 seconds ago, saying: in (A), what's happened to girl/boy?
10:57:18 <dafis> @tell zygoloid You're right, but (mumble something about unwarranted assumptions)
10:57:19 <lambdabot> Consider it noted.
10:57:36 <dafis> alexyk: ping
10:57:59 <alexyk> hi dafis!  your IntMap runs faster in less RAM
10:58:06 <alexyk> 18 minutes total, under 40 GB
10:58:08 <BMeph> I wonder: can't you use TH somehow to re-create the function-wise import? Types/classes wouldn't work, but the functions (and non-function values) should be fine.
10:58:09 <dafis> alexyk: :D :D
10:58:15 <alexyk> without subsequent disinterning though
10:58:24 <alexyk> I do it as a separate step
10:58:40 <alexyk> dafis: very close to ocaml's 15 minutes
10:58:47 <dafis> alexyk: any problems in the separate step?
10:59:03 <dafis> alexyk: close is not enough
10:59:33 <alexyk> dafis: didn't do it yet :)  I'm intrigued with your disintern version with fmap and trieIB.  How is it using *forward* dictionary to invert?
10:59:59 <alexyk> dafis: this one: disintern2 dic dcaps = let !tr = trieIB di  in fmap (dcaps !) tr
11:00:13 <alexyk> s/di /dic /
11:01:58 <dafis> alexyk: tr: Username -> ID; for all names, look up the dcaps of the ID, put that in the place where the ID was, bingo Username -> dcaps
11:03:27 <alexyk> dafis: aha! interesting.  Should be the same amount of work for the full dictionary and full dcaps.  But may vary for smaller dcaps and bigger dictionary, like you noted.
11:05:27 <alexyk> somnium: you here?! :)
11:05:59 <alexyk> it's Haskell of NJ, you know?
11:06:20 <akosch> BMeph: same error with the older version...
11:06:51 <alexyk> akosch: I wouldn't be surprised, perhaps rollback to 6.10 is needed
11:07:09 <dafis> what's akosch's problem?
11:07:14 <randomwords> I'm on ubuntu and I want to do a clean install of the haskell platform (due to broken packages). What do I need to remove?
11:07:43 <akosch> dafis: i get "ghc-pkg: mkTextEncoding: invalid argument (Invalid argument)" on make install from ghc
11:07:57 <BMeph> akosch: Hmm, I was afraid of that. If you don't mind, would you hop over to #ghc and let folks there know as well? They should know more specific questions to ask about your setup.
11:07:58 <alexyk> dafis: he tries to install on an ancient steam-powered box, and encodings./locales looks effed up
11:08:12 <dafis> akosch: soounds bad
11:08:26 <zygoloid> dafis: hi
11:08:27 <lambdabot> zygoloid: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:46 * alexyk scared somnium back into #clojure
11:08:58 <akosch> thanks anyway guys, i'll try in #ghc
11:09:14 <dafis> zygoloid: hi. After eating and thinking a bit, your reasoning is perfectly valid
11:10:02 <dafis> it is based on unwarranted assumptions like mine and burp's but admittedly on lesser assumptions
11:10:22 <dafis> I blame it on hunger and lack of sleep :)
11:10:41 <dafis> should have recognised the underspecifiedness sooner
11:11:33 <BMeph> Reasoning? Do people still use that here? ;)
11:11:42 <dafis> the point is, we know nothing about the rules of the game, so the probability could be 1, 1/, 13/27, 1/3, 0
11:12:55 <dafis> 1, 1/2, 13/27, ...
11:13:32 <alexyk> BMeph: nah, only seniority counts. :)
11:13:57 <dafis> but, as indicated above, your assumptions are better
11:14:27 <BMeph> akosch: Just trawling through old GHC boards, it looks like you have an odd setup for iconv, so that should be your first place to look.
11:14:31 <dafis> alexyk: seniority as in age?
11:14:42 <alexyk> dafis: only in Haskell age!
11:14:46 <dafis> then I'm pretty high up the ranks :)
11:14:49 <alexyk> 1 Haskell year = 100 dog years
11:14:56 <alexyk> = 10 Java years
11:15:00 <alexyk> = 3 Clojure years
11:15:30 <alexyk> = 1.5 Scala years...
11:15:54 <dafis> alexyk: then I'm still pretty old, but less than if age counted
11:16:26 <mux> is there a package somewhere that automates some of the stuff involved when you implement a web API?
11:16:43 <dafis> alexyk: how many C years?
11:16:43 <mux> or should I just use HTTP?
11:18:23 <alexyk> dafis: good question.  I'd say  7.  C is harder than Java. if you don't consider maven (shudder)
11:19:13 <geheimdienst> shell script years?
11:19:19 <duairc> https://gist.github.com/db2c9fdf982ff7269916 Hey, I'm getting this error message. Why can it not match the types? Surely they're compatible.
11:19:24 <alexyk> dafis: you can't be more senior than our faculty: http://www.cs.dartmouth.edu/~doug/
11:19:24 <geheimdienst> oh right that's not even a real language 
11:19:39 <alexyk> he supervised the creation of sed, and how uses Haskell
11:20:05 <alexyk> geheimdienst: depends on the shell.  zsh can as well be 2
11:20:12 <alexyk> just try to remember its assoc array
11:20:44 <dafis> alexyk: not that vintage :)
11:20:57 <dafis> (and not that good :( )
11:22:04 <alexyk> dafis: so you're a young man and all's ahead yet! :)
11:22:33 <dafis> alexyk: I'm younger than my father, so yeah
11:22:49 <geheimdienst> i've always thought of bash as a huge mess of string substitution with a chaotic syntax. i mean, it doesn't even have real variables. if you forget the "" around a bash variable, it kinda works, then falls apart spontaneously if their value happens to contain a space
11:22:56 <geheimdienst> can't speak to zsh however
11:23:29 * monochrom hates all quoting and escaping
11:23:56 <dafis> monochrom, can I quote you on that?
11:24:00 <monochrom> haha
11:24:06 <geheimdienst> "while ...; if ... then return; done" works but "ls | while ...; if ... then return; done" doesn't
11:24:13 <dafis> ewww
11:24:16 <geheimdienst> lots of silly warts like that
11:24:22 <dafis> vade retro  satanas
11:24:23 <alexyk> geheimdienst: zsh is smarter there, but it's still a shell.  I'd prefer all shells were Ruby-based... um, no.  Not Haskell shells, sorry.  :)
11:24:34 <monochrom> that's what you get for "everything is plain text"
11:24:55 <dafis> I can has shell with types?
11:25:13 <geheimdienst> i think plaintext is not at fault here. my haskell source code is also plaintext.
11:25:48 <dafis> geheimdienst, tell that to the average VB coder
11:25:49 <geheimdienst> ruby is at least a programming language. and it has a mostly well-thought-out syntax
11:25:50 <monochrom> that is also a fault, cf. all the complexity of layout rules
11:25:55 <alexyk> dafis: disintern1 is saving a stringified dcaps, still under 40 GB!
11:26:05 <alexyk> your IntMap kicked some ass
11:26:11 <araujo> @where hashell
11:26:12 <lambdabot> haskell.org/hashell
11:26:14 <araujo> yay!
11:26:15 <lambdabot> araujo: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:26:20 <araujo> ouch heh
11:26:24 <geheimdienst> @where hsh
11:26:24 <lambdabot> http://software.complete.org/hsh
11:26:24 <dafis> alexyk: separate run or with the mining?
11:26:48 <alexyk> dafis: same run, I was lazy to write yet another driver for what I already integrated into sc :)
11:26:56 <joga> the while above won't work without "do" and you can do the redirection to while if you use parens
11:26:58 <alexyk> and I hated main run work and disintern blow up
11:26:58 <dafis> alexyk: time?
11:27:04 <duairc> Sorry to, ugh, nag, but did anybody see my message above about the error I was getting?
11:27:12 <alexyk> dafis: finishing soon :)
11:27:39 <dafis> duairc, overlooked it, hang on a minute
11:27:52 <alexyk> with your Haskell shells, a Haskell OS is not far!  :)
11:28:10 <mauke> joga: why use parens?
11:28:20 <joga> mauke, hmm, nevermind, I guess they're not needed there
11:28:43 <mauke> the problem is that the 'return' doesn't work
11:29:12 <joga> I didn't notice the return
11:29:39 <alexyk> Haskell OS: pure disk writes.  Disk guarded by monads.
11:30:07 <alexyk> (should the mind of a programmer be in ST monad?)
11:30:15 <joga> mauke: but shouldn't 'break' be used there?
11:30:24 <dancor> do you really think a GC lang is good for an OS
11:30:29 <joga> anyway, off topic I guess
11:30:49 <alexyk> dafis: 20 min 44 secs
11:31:07 <dafis> duairc, can't figure it out without code, sorry
11:31:26 <alexyk> dafis: I use the version of IntBS which stores IntMap first and read only that
11:31:42 <duairc> dafis: Okay, I'll post the code then. The only thing I can think of is that it might have something to do with the Rank 2 type
11:31:55 <dafis> alexyk: and ocaml 15? booh
11:32:51 <dafis> alexyk: how long took the run (without disinterning) previously?
11:32:55 <alexyk> dafis: well, ocaml handles string maps
11:33:09 <alexyk> dafis: I'm wary to rewrite in Tries
11:33:16 <alexyk> so it's not quite comparable anywayts
11:33:32 <alexyk> we write out ints  in 18 mins
11:33:42 <akosch> my issue is solved
11:33:54 <akosch> my locale setup was messed up
11:33:54 <alexyk> fully compatible with ocaml would intern, mine, disintern; or do strings throughout
11:34:03 <dafis> alexyk: nevertheless, how long did the previous version take?
11:34:05 <alexyk> akosch: I thought so
11:34:09 <alexyk> dafis: 18 mins
11:34:31 <dafis> alexyk: I mean, before the strict IntMap
11:34:49 <dafis> you said 18 mins for the strict IntMap
11:34:51 <akosch> i actually got a working ghc on this old piece of junk :)
11:35:00 <dafis> akosch: great
11:35:16 <alexyk> dafis: longer, like 22 minutes and going into swap at times
11:35:19 <alexyk> then dying
11:35:50 <dafis> alexyk: so the IntMap hacking bought some 20% or so?
11:36:15 <dafis> (plus some 30% memory reduction)
11:36:20 <alexyk> at least; and at least 7 GB under, safe from swap and sweet peace of mind
11:36:37 <djahandarie> It'd be cool if you could type in haskell expressions into Google
11:36:46 <alexyk> dafis: but, if we go that routem OCaml is entitled to a better hash table, too.
11:36:59 <dafis> djahandarie, you can, just don't expect reasonable answers
11:37:11 <djahandarie> dafis, :P
11:37:25 <djahandarie> It'd be cool if Google could evaluate haskell expressions* :P
11:37:30 <geheimdienst> djahandarie, if it's just function signature's you're looking for, you can hoogle. also, have you looked at google code search or the other guys who offer code search ...
11:37:34 <dafis> alexyk: But not from me :)
11:37:36 <geheimdienst> @hoogle a -> [a]
11:37:37 <lambdabot> Prelude repeat :: a -> [a]
11:37:37 <lambdabot> Data.List repeat :: a -> [a]
11:37:37 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:38:17 <djahandarie> geheimdienst, nah, I know about that stuff, just felt like that it'd be cool if Google evaulated Haskell
11:38:29 * BMeph high-fives akosch...
11:40:04 <dafis> djahandarie, ghci can do that
11:40:27 <alexyk> dafis: I think we're good for now, let the shootout begin! :) I'll publish it and we'll see what happens.
11:40:29 <djahandarie> I know that too -_-
11:40:37 <djahandarie> So can lambdabot
11:40:41 <djahandarie> But none of those are Google
11:40:42 <dafis> djahandarie, I know you know
11:40:58 <BMeph> @google djahandarie 
11:40:59 <lambdabot> http://bash.org/?870063
11:41:00 <lambdabot> Title: QDB: Quote #870063
11:41:17 <alexyk> @google BMeph
11:41:19 <lambdabot> http://www.youtube.com/user/BMeph
11:41:19 <lambdabot> Title: YouTube - BMeph's Channel
11:41:28 * BMeph WINS!
11:41:29 * alexyk oh no
11:41:31 <BMeph> \o/
11:41:55 <alexyk> later guys
11:41:56 <djahandarie> @google (\x -> x*230) 10
11:41:57 <lambdabot> http://www.youtube.com/watch?v=1yd3DBATS8E
11:41:58 <lambdabot> Title: YouTube - Squat 230kg (507lbs) for 10 reps! - RAW
11:42:02 <djahandarie> Haha
11:42:02 <dafis> @google alexyk
11:42:04 <lambdabot> No Result Found.
11:42:10 * BMeph should set up that channel, to Rick-roll for the first vid...
11:42:14 <alexyk> yay :)
11:42:20 <djahandarie> @. google > (\x -> x*230) 10
11:42:20 <lambdabot> Plugin `compose' failed with: Unknown command: ">"
11:42:23 <djahandarie> Damn
11:42:25 <alexyk> let's keep it that way
11:42:57 * alexyk you can be a cat programming haskell on the internet
11:43:14 * alexyk time to catch some birdies
11:43:16 <mreh> suggestions for an Applicative implementation for an associative list?
11:43:20 <geheimdienst> im in ur interwebs, programin haksell
11:43:21 <dafis> don't cats program in lolcode?
11:43:24 <adu> "ceiling Cat watching you unsafePerformIO!"
11:43:27 <djahandarie> @. google run (\x -> x*230) 10
11:43:30 <lambdabot> http://www.cmog.org/dynamic.aspx?id=158
11:43:30 <lambdabot> Title: 2300¬∞ at The Corning Museum of Glass
11:43:32 <mreh> they took lambda cats down
11:43:33 <alexyk> dafis: lolhaskellz!
11:43:35 <djahandarie> ftw
11:43:42 <geheimdienst> dafis, cats do visualbasic or shell scripts, normally
11:43:56 <mreh> damn scriptkitties
11:43:58 <dafis> geheimdienst, or perl, accidentally
11:44:00 <alexyk> bbl...
11:44:15 <geheimdienst> cats emit machine code directly
11:44:39 <adu> geheimdienst: that's not machine code, that's called purring
11:45:16 <geheimdienst> morse code possibly
11:45:39 <adu> i wonder if anyone has made a purr execution machine
11:46:00 * geheimdienst is still sad that the lambdacats are no more
11:46:27 <adu> pur-purrr-mao = goto line 210
11:46:37 <arw_> not that hard. 1 interrupt for the can opener. no further commands possible.
11:47:02 <mauke> preflex: quote dcoutts
11:47:02 <preflex>  <dcoutts> kolmodin and I considered implementing lolcode in the small step semantics style, including how to simulate lolcode io purely
11:47:39 <djahandarie> How'd you get that exact quote with just his name? :P
11:48:01 <geheimdienst> i'd decode that at a lower level. a purr is a sequence of on/offs basically. from there, it's NRZ or something
11:48:32 <mauke> djahandarie: easy, that's the only quote under his name
11:48:43 <BMeph> preflex: quote mauke
11:48:43 <preflex>  <mauke> IN SPACE, NO ONE CAN HEAR YOU VACUUM
11:49:01 <BMeph> A gem, truly...
11:49:01 <geheimdienst> @quote mauke
11:49:02 <lambdabot> mauke says: the first rule of fix club is "the first rule of fix club is "the first rule of fix cl...
11:49:16 <djahandarie> Hahaha
11:49:20 <BMeph> I lol'd
11:49:26 <BMeph> preflex: quote mauke
11:49:27 <preflex>  <mauke> I'm going to write a lib33t.so just so you have to link with gcc -l33t
11:49:37 <adu> preflex: quote adu
11:49:38 <preflex>  no quotes found for adu
11:49:41 <geheimdienst> bmeph, the first rule of fix club is: you don't lol about fix club
11:49:49 <geheimdienst> why does preflex have a database independent of lambdabot's
11:49:54 <adu> @quote adu
11:49:55 <lambdabot> Olin_Shivers says: Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills
11:49:55 <lambdabot> appear to be limited to downloading bitmaps off of netnews?
11:49:56 <geheimdienst> preflex quote geheimdienst
11:49:57 <preflex>  no quotes found for geheimdienst
11:50:00 <BMeph> mauke: you should make that lib!
11:50:10 <djahandarie> @quote djahandarie
11:50:10 <geheimdienst> @quote geheimdienst
11:50:10 <lambdabot> geheimdienst says: #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
11:50:11 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
11:50:18 <adu> that's not even my quote!?!
11:50:25 <djahandarie> Haha
11:50:26 <mauke> it contains "adu"
11:50:27 <djahandarie> Both about monads
11:50:42 <geheimdienst> yeah olin_shivers said that
11:51:04 <BMeph> "grADUate students"...
11:51:16 <dafis> @google olin_shivers
11:51:18 <lambdabot> http://en.scientificcommons.org/olin_shivers
11:51:27 <mreh> @arr
11:51:27 <lambdabot> Drink up, me 'earties
11:51:37 * djahandarie got a totally different google result than that
11:51:41 <djahandarie> I think @google lies
11:51:42 * pikhq writes a new monad tutorial
11:51:45 <djahandarie> @google Olin Shivers
11:51:46 <pikhq> "Monads are like monads.
11:51:47 <lambdabot> http://www.ccs.neu.edu/home/shivers/
11:51:47 <pikhq> "
11:51:47 <lambdabot> Title: Olin Shivers
11:51:59 <djahandarie> Ah nevermind, it was the caps
11:52:01 <pikhq> "Where (>>=) = (>>=), and return = return"
11:52:06 <djahandarie> pikhq, I think that's already been done :P
11:52:13 <pikhq> djahandarie: Aaaw.
11:52:34 <geheimdienst> pikhq, great idea. when will your tutorial of monoids in the category of endofunctors come out?
11:52:45 <BMeph> I'm still impressed with the Monad haiku.
11:52:48 <djahandarie> @quote monads.are.like.monad.tutorials
11:52:49 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
11:53:04 <djahandarie> @quote monochrom.monads
11:53:05 <lambdabot> No quotes match. You type like i drive.
11:53:07 <BMeph> @quote commute
11:53:07 <lambdabot> No quotes match.
11:53:09 <djahandarie> God damn it lambdabot
11:53:12 <djahandarie> @quote polymorphic
11:53:13 <lambdabot> ghc says: Inferred type is less polymorphic than expected
11:53:18 * djahandarie sighs
11:53:32 <Hunner> @quote monochrome.monads
11:53:32 <lambdabot> No quotes match. I've seen penguins that can type better than that.
11:53:54 <geheimdienst> @quote monochrom.monad
11:53:54 <lambdabot> No quotes match. Where did you learn to type?
11:54:01 <geheimdienst> @quote monad
11:54:01 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
11:54:18 <dafis> lambdabot's insult database isn't too large, is it?
11:54:47 <BMeph> @quote gwern
11:54:48 <lambdabot> gwern says: fur makes everything better
11:54:50 <geheimdienst> "No quotes match. You know, my insults database is really not big enough for you."
11:55:01 <geheimdienst> @quote
11:55:01 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
11:55:08 <geheimdienst> @quote .
11:55:09 <lambdabot> Data.Numbers.Primes says: The number 6 is a good value to pass to this function.
11:55:16 <geheimdienst> o rly
11:55:34 <dafis> geheimdienst, yes, it's damned fast
11:55:52 <dafis> imagine 327*2^23456789012345-1
11:56:03 <dafis> that might take a bit longer
11:56:08 <sinelaw> @quote life
11:56:09 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life is much happier now
11:56:23 <adu> monads are like burritos 
11:56:43 <Hunner> I thought monad tutorials are like burrito tutorials
11:56:46 <dafis> adu: a burrito is a small burro, right?
11:56:46 <geheimdienst> @quote monads.like
11:56:46 <lambdabot> No quotes match. stty: unknown mode: doofus
11:56:52 <geheimdienst> @quote monad.like
11:56:53 <lambdabot> No quotes match. There are some things that I just don't know.
11:56:57 <geheimdienst> @quote monad.*like
11:56:58 <lambdabot> medfly says: I wanted to use xmonad and yi, just to be cool like that, but to write javascript.
11:57:07 <adu> dafis: no, its like a taco, only softer
11:57:22 <dafis> :(
11:57:29 <adu> and rounder
11:57:38 <dafis> wtf is a taco, btw?
11:57:42 <mreh> > reverse "tacocat"
11:57:43 <lambdabot>   "tacocat"
11:57:47 <adu> i feel like the last hour should have been in #haskell-blah
11:57:53 <geheimdienst> come to think of it, everything in this channel is softer and rounder
11:57:58 <adu> lol
11:58:16 <geheimdienst> @google tacocat is a palindrome
11:58:18 <lambdabot> http://icanhascheezburger.com/2007/11/12/tacocat-is-a-palindrome/
11:58:18 <lambdabot> Title: TACOCAT IS A - Lolcats 'n' Funny Pictures of Cats - I Can Has Cheezburger?
11:58:20 * Hunner has a non-softer-and-rounder BMI
11:58:53 <adu> ICANHAS stdio.h?
11:59:01 <dafis> duairc, have you sorted out your type problem?
11:59:16 <burp> "These kind of problems require competence in both English and Maths which is why so few people get them right."
11:59:22 <burp> reply: "Mostly they require competency in psychology, so you can figure out how the twit posing the problem is deliberately trying to mislead you by using ambiguous English and claiming on the basis of their poor communication skills to be clever."
11:59:23 <burp> so true :D
11:59:48 <duairc> dafis: No, I'm still poking at it though. I'm certain it has something to do with the Rank 2 type... that isn't really something I understand
12:00:10 <adu> wow, I just learned that berp is spelled with a 'U'
12:00:38 <dafis> duairc: you could try replacing the ($) by parentheses, ($) used to not like higher rank types
12:00:53 * hackagebot precis 0.5.0 - Diff Cabal packages.  http://hackage.haskell.org/package/precis-0.5.0 (StephenTetley)
12:01:14 <dafis> duairc, though I can't really tie that to the error message
12:01:27 <geheimdienst> woah, that sounds interesting ... "summarizes api changes between cabal packages"
12:01:44 <duairc> dafis: Wow, that would have been magic if it worked, but unfortunately it didn't :(
12:01:57 <duairc> My code's a bit... invovled, I'll try to come up with a minimal example
12:02:12 <dafis> okay
12:04:38 <burp> "Take an abstract mathematical problem, invent a pseudo-real-world context, rephrase the problem very sloppily and ambiguously in plain English then laugh smugly when people get the wrong answer." haha
12:04:39 <travisbrady> Would a tree zipper be appropriate to store/manipulate Doubles and their incremental sum?
12:05:37 * geheimdienst is in favor of trying the simplest possible thing first and getting more clever as needed.
12:05:47 <geheimdienst> i mean, arrays, lists, linear search
12:06:52 <geheimdienst> that kinda thing
12:16:06 <alexyk> hey solidsnack!  why do you have JSONb depend on base < 4?
12:16:23 <solidsnack> alexyk: Uhmm...
12:16:28 <solidsnack> alexyk: No reason.
12:16:30 <solidsnack> Just a minute
12:16:43 <alexyk> solidsnack: I had to rebuild just to run under the new ghc head 6.13.xxx
12:16:48 <alexyk> and it works if you drop < 4
12:16:53 <solidsnack> Okay.
12:17:06 <solidsnack> alexyk: Are you on Github?
12:17:11 <alexyk> solidsnack: yep
12:17:19 <solidsnack> I could just patch it but if you make the patch and all that then you can get credit.
12:17:35 <solidsnack> Of course, I will thank you in the commit log either way.
12:17:36 <alexyk> solidsnack: why not, I'll forkya
12:18:17 <alexyk> solidsnack: I'm your first follower too!
12:18:25 <solidsnack> Cool.
12:20:05 <solidsnack> Wow, I describe a much more ambitious test suite in my README than I have actually published.
12:20:52 <alexyk> solidsnack: should I update version to 1.0.2 in the same .cabal file or you'll do it later or keep at 1.0.1?  how is it related to hackage?  if 1.0.1 is pushed, we have to bump, no?
12:21:21 <micahjohnston> can you implement a type class for another type class?
12:24:39 <solidsnack> alexyk: I will do the version bump.
12:25:12 <alexyk> ok
12:25:14 <solidsnack> Or, hey, you can do it.
12:25:42 <solidsnack> alexyk: To answer your other question, version has to be bumped for Hackage's sake.
12:25:59 <duairc> dafis: I have a minimal example now: https://gist.github.com/db2c9fdf982ff7269916
12:26:26 <alexyk> solidsnack: pull request sent
12:26:59 <alexyk> "for hackage's sake, lets remember the children!" :)
12:27:12 <duairc> dafis: And just as I sent that I realised a much better way of solving this problem
12:27:38 <dafis> duairc: nice
12:27:43 <alexyk> solidsnack: too late, you have to bump the version btw
12:27:55 <solidsnack> Okay.
12:30:11 <Taejo> did everybody who posts to haskell-cafe just get job-spammed, or are they being somewhat selective
12:30:37 <alexyk> Taejo: did Syed write you too? :)
12:30:42 <Taejo> yep
12:30:46 <alexyk> let's all go work in the City of London!
12:30:53 <alexyk> we'll have a Haskell commune
12:31:06 <dons> there's some aggressive recruiting going on for good haskellers at  the moment.
12:31:11 <alexyk> with Syed as our spiritual leader
12:31:23 <dons> 'cause you got the skills to pay the bills.
12:31:32 <alexyk> dons: I wouldn't go from Portland OR to London!  Air is bad
12:31:47 <dons> heh
12:31:58 <tommd> dons: Hackathon news?
12:32:11 <dafis> Taejo: he even posted to beginners@
12:32:13 <tommd> I'm looking for an excuse to work on DRBG and crypto-api more
12:32:17 <dons> tommd: ah interesitng.
12:32:34 <alexyk> "I'm very impressed by your credentials: you're subscribed to a haskell list!"
12:32:35 <dons> tommd: mid-jully
12:33:07 <tommd> great
12:33:22 <alexyk> why do all British recruiting agencies have pretentios, faux-aristorcatic names like "carringtonfox.com:?
12:33:45 <alexyk> why not "dirtyflyingpig.com"?
12:33:49 <dafis> alexyk: how's a .com faux-aristocratic?
12:33:51 <alexyk> I'd rather talk to the latter
12:33:55 <Taejo> I think my recent postings to haskell-cafe are rather underwhelming
12:34:02 <alexyk> dafis: I mean the prefix
12:34:05 <randomwords> When I try to make the haskell platform on ubuntu I'm getting the following error 'Could not find module `Control.Monad'' Seemd odd. any ideas?
12:34:23 <dafis> alexyk: I'd rather not, dirtyflingpig.com might be an alias for harrop
12:34:42 <dafis> f*lying*
12:34:43 <alexyk> dafis: no, that's the flying pig which ate the flying frog
12:35:04 <alexyk> and got dirty form all the F# bloody mess
12:35:04 <dafis> ah, so let's hold it in honour
12:35:28 <dafis> first time I notice F# looks like a swear word :)
12:35:41 <dafis> in certain circumstances
12:35:43 <alexyk> dafis: coincidental :)
12:35:53 <dafis> all the more amusing
12:36:14 <alexyk> "show me F# code already!"
12:36:49 <alexyk> "I don't care about algoritms-schmalgorithms or computational theory, we need F# code here!"
12:37:06 <dafis> randomwords, no ideas, *very* odd
12:37:27 <solidsnack> alexyk: Now I remember why I have the constraint.
12:37:35 <alexyk> solidsnack: why?
12:37:35 <randomwords> dafis: I think have debris from an old install - Idealling I'd just delete everything and start again, but I don't really know where everything lives
12:37:43 <solidsnack> Hackage rejects my upload because I don't specify the version of base totally.
12:37:56 <solidsnack> alexyk: I will fix it here, just a minute.
12:37:59 <dafis> solidsnack, a few flags?
12:38:09 <alexyk> solidsnack: then bump it to < 5, we'll drag it ahead of head
12:38:28 <alexyk> or flags are better if they solve it without cap
12:38:29 <dafis> randomwords, I've no idea either where yum/apt/whoever puts stuff
12:38:52 <sshc> How do I hide Prelude's definition of a function in a module?
12:39:03 <duairc> import Prelude hiding (function)
12:39:07 <dafis> sshc: import Prelude hiding (stuff)
12:39:16 <randomwords> dafis: thanks anyway
12:39:16 <alexyk> dafis: your pig is different, btw, it's an .xxx site rather than Harrop :)
12:39:38 <dafis> alexyk: so at least it's SFW
12:39:47 <alexyk> :)
12:40:15 <solidsnack> alexyk: Okay, pushed.
12:40:42 <monochrom> @quote monochrom monad.*computation
12:40:42 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
12:41:07 * hackagebot JSONb 1.0.2 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.2 (JasonDusek)
12:41:42 <dafis> solidsnack, shouldn't it be JSON*d*?
12:41:56 <geheimdienst> jsnob?
12:42:49 <dpratt71> the other day I was looking at a presentation (slide deck) that discussed (among other things) the suitability of Haskell for hard-core game programming
12:43:08 <dpratt71> (and now I can't find it)
12:43:54 <aristid> oh, python has primitive monad comprehensions that they call generator expressions
12:43:56 <aristid> interesting
12:44:23 <Trevion> dpratt71: Tim Sweeney's slides from 4 years ago?
12:44:34 <geheimdienst> dpratt71, yeah the sweeney popl thing maybe
12:44:34 <geheimdienst> http://webcache.googleusercontent.com/search?q=cache:vEhsoTFOx4sJ:www.cs.princeton.edu/~dpw/popl/06/Tim-POPL.ppt+sweeney+game+programming+haskell&cd=1&hl=da&ct=clnk&client=opera
12:44:51 <geheimdienst> it mentions haskell a bit
12:45:14 <sshc> How do I enable irrefutable patterns with GHC?
12:45:32 <Trevion> sshc: ~pat
12:45:33 <dpratt71> Trevion, geheimdienst: you are (collectively) the man!
12:45:35 <dpratt71> thanks
12:45:41 <dcoutts_> sshc: irrefutable patterns are standard Haskell98
12:45:53 <sshc> Oh.
12:45:55 <solidsnack> dafis: Why?
12:45:59 <sshc> I thought they were an extension.
12:46:20 <solidsnack> dafis: It uses *b*ytestrings.
12:46:29 <dafis> solidsnack, how do you pronounce JSON?
12:46:39 <monochrom> "johnson"
12:46:43 <solidsnack> dafis: jay-SON
12:46:44 <geheimdienst> jason
12:46:47 <dafis> solidsnack, and what's the author's name?
12:46:48 <dons> dafis: responded to your nice email.
12:46:50 <Trevion> dpratt71: http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf would seem to be a PDF version.  Someone reiterates his talk poorly every couple of years, usually with more exclamation points and less dat.a
12:46:56 <solidsnack> dafis: Oh, haha.
12:47:08 <solidsnack> Yeah, I deliberately do not say JAY-son
12:47:11 <sshc> GHC is parse failing at "map (\~(Pattern, etc) -> aoeu)"
12:47:20 <geheimdienst> ... and spells his name without the e ...
12:47:20 <cheater99> you say jayson
12:47:37 <geheimdienst> monochrom, how did you come up with johnson
12:47:51 <geheimdienst> that has edit distance 3 to json
12:48:13 <sshc> Do irrefutable patterns work in lambdas?
12:48:21 <solidsnack> dafis: I could call it MyBigCowboyHatJSONParserGoMe
12:48:22 <dafis> sshc: in a lambda abstraction, you need a space (or paren) between \ and ~
12:48:35 <dafis> (or \ an !, for that matter)
12:48:37 <solidsnack> dafis: I think it's unsavory to name stuff after yourself.
12:48:51 <solidsnack> Someone else will do it, after you're dead, if you're really that good.
12:48:55 <solidsnack> Like Turing Machines.
12:49:05 <sshc> dafis: I see.  What affect would ! have?
12:49:18 <monochrom> by thinking outside the box
12:49:19 <Trevion> sshc: introduces strictness
12:49:25 <dafis> solidsnack, yes, I'm just being a bit silly right now, 34 hours without sleep
12:49:36 <sshc> Trevion: Elaborate?
12:49:38 <dafis> sshc: bang pattern, for strictness
12:49:39 <solidsnack> dafis: Why so little sleep?
12:49:47 <dafis> opposite of ~, in a way
12:50:10 <sshc> Putting a space in between the two characters worked; thanks.
12:50:20 <dcoutts_> Trevion: a ! wouldn't make any difference in that position of course
12:50:37 <sshc> Where can "!" be placed?
12:50:40 <Trevion> dcoutts_: since you already have to get to whnf to do the pattern match
12:50:57 <dcoutts_> Trevion: right
12:51:30 <dafis> solidsnack: don't know I just can't find may way to the bedroom
12:51:43 <dcoutts_> sshc: it can be used on any pattern, like ~
12:51:50 <Trevion> sshc: It _can_ be placed anywhere.  It's only _useful_ a few places... it forces evaluation to weak head normal form.
12:51:56 <dafis> there's so much good stuff in #haskell, there's alexyk's thing to tweak, ...
12:52:01 <Trevion> Which I'm sure someone else can explain better than me.
12:52:07 <sshc> > !3
12:52:08 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
12:52:21 <sshc> > let x = 3 in !x
12:52:23 <lambdabot>   <no location info>: parse error on input `!'
12:52:30 <dcoutts_> sshc: no, in patterns, not expressions
12:52:37 <sshc> Seems like it can't be placed anywhere.
12:52:47 <Trevion> any pattern, my bad.
12:52:47 <dcoutts_> sshc: he meant anywhere in a pattern
12:52:52 <Trevion> > let !x = 3 in x
12:52:52 <lambdabot>   3
12:53:03 <Trevion> >let x = 1 / 0 in 4
12:53:05 <sshc> I see.
12:53:11 <Trevion> > let x = 1 / 0 in 4
12:53:11 <dcoutts_> > let !x = undefined in 3
12:53:12 <lambdabot>   4
12:53:13 <lambdabot>   *Exception: Prelude.undefined
12:53:18 <sshc> Where can ~ be used?
12:53:24 <geheimdienst> > let x = undefined in 3
12:53:25 <sshc> In the same places?
12:53:25 <lambdabot>   3
12:53:29 <geheimdienst> > let !x = undefined in 3
12:53:30 <lambdabot>   *Exception: Prelude.undefined
12:53:36 <Trevion> > let !x = 1 / 0 in 4
12:53:37 <lambdabot>   4
12:53:42 <sshc> > let ~x = undefined in 3
12:53:43 <lambdabot>   3
12:53:49 <dcoutts_> sshc: ! and ~ can be used as a prefix operator on any pattern
12:53:52 <geheimdienst> > let !~x = undefined in 3
12:53:53 <lambdabot>   <no location info>: parse error on input `!~'
12:54:03 <monochrom> > (\ ~(x:xs) -> "scores!") []
12:54:03 <geheimdienst> > let ~!x = undefined in 3
12:54:04 <lambdabot>   <no location info>: parse error on input `~!'
12:54:04 <sshc> > let !x = 1 `div` 0 in 4
12:54:05 <lambdabot>   "scores!"
12:54:06 <lambdabot>   *Exception: divide by zero
12:54:35 <monochrom> > 1/0
12:54:36 <lambdabot>   Infinity
12:54:49 <monochrom> is why let !x=1/0 in 4 works
12:54:55 <sshc> > (\ (x:xs) -> "scores") []
12:54:56 <lambdabot>   "*Exception: <interactive>:1:130-149: Non-exhaustive patterns in lambda
12:55:04 <sshc> > (\ ~(x:xs) -> "scores") []
12:55:06 <lambdabot>   "scores"
12:55:21 <sshc> Shouldn't that last one fail, since the irrefutable pattern match failed?
12:55:30 <dcoutts_> no, because it's irrefutable :-)
12:55:37 <dcoutts_> you didn't use x or xs
12:55:44 <Taejo> > (\ (x:xs) -> "scores") []
12:55:44 <sshc> > (\ ~(x:xs) -> "scores" ++ xs) []
12:55:45 <lambdabot>   "*Exception: <interactive>:1:134-153: Non-exhaustive patterns in lambda
12:55:46 <lambdabot>   "scores*Exception: <interactive>:1:134-160: Irrefutable pattern failed for ...
12:55:57 <dafis> alexyk: ping
12:55:59 <monochrom> see haskell98 report for real meaning of "irrefutable" and "fail"
12:56:01 <sshc> Oh. It only fails if I use xs
12:56:04 <alexyk> dafis: ping
12:56:06 <Taejo> I think irrefutable is a bad name -- "lazy pattern match" might be more sensible
12:56:07 <alexyk> pong
12:56:12 <sshc> > (\ ~!(x:xs) -> "scores" ++ xs) []
12:56:13 <lambdabot>   <no location info>: parse error on input `~!'
12:56:16 <monochrom> never reason by names
12:56:17 <sshc> > (\ ! ~(x:xs) -> "scores" ++ xs) []
12:56:17 <Taejo> it delays pattern matching as long as possible
12:56:18 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
12:56:21 <alexyk> (goal for Spain)
12:56:41 <dafis> alexyk: can you pack up the new stuff with the strict IntMap so dons can pull it?
12:56:51 <monochrom> except they can't say "lazy" because they don't want to confine to lazy
12:56:59 <alexyk> dafis: uno sec
12:57:34 <Trevion> There's no decent Haskell-C++ FFI is there?
12:57:55 <geheimdienst> i guess there's no decent anything-c++ ffi ...
12:58:28 <alexyk> dons: dafis: can be pulled from branch: newintmap
12:58:31 <dcoutts_> Trevion: have to go via C symbols
12:58:46 <dafis> alexyk: superduper
12:58:53 <monochrom> > take 5 ((\ ~(x:xs) -> "scores" ++ xs) [])
12:58:55 <lambdabot>   "score"
12:58:59 <Trevion> dcoutts_: that's what I figured, thanks.
12:59:12 <dons> see qthaskell for an example preprocessor
12:59:22 <dcoutts_> or indeed wxhaskell
12:59:37 <dcoutts_> sshc: iirc, \ ~Pattern -> ...   is the same as \x -> let Pattern = x in ... 
12:59:42 <dafis> dons: seen the branch of alexyk's stuff above?
13:00:45 <dons> url? 
13:01:27 <moonlite_> hackage down?
13:01:33 <dons> nope
13:01:34 <Trevion> How does Ptr t interact with the GC?
13:01:37 <dons> ooh
13:01:46 <dons> moonlite_: maybe...
13:01:53 <dons> Trevion: gc has to follow it.
13:02:09 <Trevion> Does the GC move pointed-to things?
13:02:16 <alexyk> dons: emailed
13:02:29 <moonlite_> Good anyways, i need to do other stuff than download whatever it was i thought i should download
13:02:36 <dons> yep, unless you get a pinned ptr allocated.
13:02:39 <monochrom> hackage seems down. in general you can try http://downforeveryoneorjustme.com/
13:02:45 <dons> moonlite_: hmm
13:02:46 <dons> odd
13:02:49 <dcoutts_> Trevion: the GC cannot follow Ptrs
13:03:06 <dcoutts_> Trevion: they can point anywhere, e.g. outside the GC heap
13:03:16 <moonlite_> monochrom, hah, i'll remember that site
13:03:19 <dcoutts_> Trevion: you might want a ForeignPtr
13:03:54 <dons> dcoutts_: is that right? what about pointers inside the heap?
13:04:02 <dons> to boxed haskell things.
13:04:18 <dcoutts_> dons: ForeignPtr to heap object has two bits
13:04:28 <dcoutts_> dons: the bit the GC follows and the Ptr
13:04:53 <dcoutts_> and because you can get a Ptr, then it mean the heap object must be pinned
13:05:03 <monochrom> eh? hackage is back.
13:05:12 <dons> ah, yes, the internal ForeignPtrContents stuff
13:05:17 <dcoutts_> dons: right
13:05:24 <monochrom> perhaps hackage went out for a gc lunch
13:05:51 <dcoutts_> dons: so yes ForeignPtr is one of the few cases where we have raw pointers to the interior of heap objects, but the GC doesn't follow those raw pointers
13:06:16 * dcoutts_ will publish his ByteString tech report after he hands in
13:07:14 <dons> so there's some smart constructors for Ptr, that ensure you can't be too stupid
13:07:35 <monochrom> haha, smart software ensures human not too stupid
13:08:15 <dons> e.g. mallocForeignPtr*
13:11:11 <aristid> monochrom: smart software ensures grammar good
13:11:26 <monochrom> haha
13:11:42 <geheimdienst> smart software ensures lolcats be maked
13:11:46 <alexyk> is there a way to use ByteString in ghci so I don't have to pack all literals?  E.g. when looking up ByteString keys in a Map?
13:12:04 <alexyk> Can I tell it that "xxx" literals are now ByteString?
13:12:07 <geheimdienst> let loo = lookup . pack ?
13:12:33 <alexyk> geheimdienst: well maybe...
13:12:44 <monochrom> let selfDocumentingMeaningfulIdentifierForLookupAfterPack = lookup . pack
13:12:46 <geheimdienst> i agree :) it might be a bit simplistic
13:13:01 <dons> alexyk: -XOverloadedStrings
13:13:05 <geheimdienst> monochrom: sel<tab>. done. what's the problem
13:13:08 <alexyk> "mommy can I go to the loo?"
13:13:08 <dons> alexyk: then it will auto-pack based on the context
13:13:30 <alexyk> dons: can ghci be told that with {- -"- -} ?
13:13:37 <dons> Prelude> :set -XOverloadedStrings 
13:13:37 <dons> Prelude> "literal" :: Data.ByteString.Char8.ByteString
13:13:37 <dons> Loading package bytestring-0.9.1.5 ... linking ... done.
13:13:38 <dons> "literal"
13:13:51 <alexyk> nicee
13:14:03 <monochrom> sel<tab> is suboptimal if every identifier starts with sel
13:14:10 <geheimdienst> unbelievable. i swear, in the 4 mins since the question, dons has implemented the new flag and pushed a ghc update
13:14:34 <alexyk> dons: still have to :m +Data.ByteString.Char8 first?
13:14:41 <Veinor> is there a point to Mu?
13:15:09 <Veinor> actually, what package is Mu in? I can't find it using Hayoo
13:15:10 <dons> alexyk: yeah, to bring in the IsString instance
13:15:26 <c_wraith> Veinor: It lets you create infinite types, if that's something you really need to do
13:15:47 <Veinor> which package is it in?
13:16:08 <alexyk> dons: Loading package bytestring-0.9.1.7 ... linking ... done.  Am I ahead of the author? :)
13:16:18 <monochrom> Mu is not in any package
13:16:23 <Veinor> ah
13:16:36 <monochrom> In many academic papers.
13:16:51 <c_wraith> @kind Mu
13:16:52 <lambdabot> (* -> *) -> *
13:17:22 <geheimdienst> import qualified Many Academic Papers (Mu) as mu
13:17:23 <c_wraith> > Just . Just . Just . Just $ Nothing :: Mu Maybe
13:17:24 <lambdabot>   Couldn't match expected type `L.Mu Data.Maybe.Maybe'
13:17:24 <lambdabot>         against inferr...
13:17:31 <monochrom> It unifies many recursive data types so the paper can talk about all of them at once.
13:17:39 <alexyk> c_wraith: sounds like zen mantra
13:18:01 <travisbrady> Can anyone point me at the time complexities for the functions in Data.Tree.Zipper?  The comments make no mention.
13:18:39 <geheimdienst> alexyk, sounds more like a chuck norris fact. "Chuck Norris can talk about all recursive data types. At once."
13:19:02 <monochrom> haha
13:19:37 <geheimdienst> we might at this point discuss who the chuck norris of haskell is
13:20:07 <c_wraith> why debate?  If it's about crazy type hackery, Oleg wins
13:20:53 <dons> alexyk: you're using ghc head.
13:20:59 <alexyk> dons: yep
13:21:09 <dons> i'm building the newintmap branch now
13:21:16 <alexyk> dons: cool
13:21:59 <dons> needs a .cabal file :)
13:22:18 <monochrom> I nominate oleg and dons for chuck norris of haskell
13:22:25 <dons> yikes
13:23:19 <dons> you're using lots of libs. good. how does that work in ocaml?
13:24:02 <geheimdienst> "dons can tell if your program halts. he beats the boops out of it until it confesses."
13:24:18 <c_wraith> was that supposed to be "loops"?
13:24:21 <alexyk> dons: in ocaml I have a make file :)
13:24:26 <geheimdienst> "dons can run an infinite loop. in a little over 10 seconds."
13:24:30 <alexyk> but ocaml has a nice ocamlfind lib
13:24:44 <kmc> Veinor, Mu isn't about writing new exotic types... many of the types you can write with it are quite mundane (e.g. lists) and could be written more straightforwardly
13:24:46 <geheimdienst> i kinda like the sound of it ... beat the boops out ...
13:24:52 <alexyk> ocaml's omake is in fact awesome when works
13:25:10 <alexyk> you can compile C and LaTeX with omake and no deps, it'll figure them out
13:25:11 <dons> alexyk: but are there libs for e.g. json, tokyocabinet etc?
13:25:11 <kmc> but sometimes you want to specify the recursive structure without tying the knot, in order to produce other things, e.g. generic traversals
13:25:21 <kmc> see people.cs.uu.nl/andres/Rec/MutualRec.pdf for a fancy version of this
13:25:24 <alexyk> dons: indeed there are
13:25:49 <alexyk> dons: and pretty good ones.  But generally Haskell got much, much more libs.
13:26:08 <alexyk> there's no google protocol buffers for ocaml, while there's one for haskell
13:26:15 <alexyk> so I had to settle on json
13:26:28 <alexyk> (the original clojure writes protobufs)
13:26:30 <dons> yeah, we got protocol buffers, and the facebook guys released the haskell thrift ones
13:27:25 <dons> alexyk: you should replace -funbox-strict-fields with {-# UNPACK #-} on strict fields of simmple types
13:27:26 <alexyk> I tried to get Chris Kukliewicz to make a map extension to store Map in protobufs compatible with clojure's, but he posed N conditions, in true MIT manner :)
13:27:36 * dons needs to work out how to send alexyk patches
13:27:46 * kmc has used protobuf in C++ and Python and found it a bit lacking
13:27:53 <alexyk> dons: git?
13:28:18 <alexyk> kmc: the key feature of protobufs is they are mergeable
13:28:23 <dons> -K1G seems wrong
13:28:25 <alexyk> you merge two protobuf maps, you get a map
13:28:28 <dons> you shouldn't use  that much stack
13:28:35 <alexyk> dons: pulled it out of ocaml's rear
13:28:36 <kmc> merge by concat you mean?
13:28:50 <alexyk> kmc: by fields
13:28:51 <dafis> dons: The sample ran fine here with the default stack
13:29:21 <alexyk> dons: the default stack overflowed on teh big run; may not be needed on sample
13:29:35 <alexyk> dons: I didn't do any -funbox at all yet
13:29:50 <dons> just pass -funbox-strict-fields -O2 every time you compile :)
13:30:01 <Veinor> can't spell -funbox without fun!
13:30:04 <alexyk> dons: should I try again with that?
13:30:16 <dafis> alexyk, dons: the sample doesn't need those huge numbers
13:30:22 <djahandarie> Veinor, can't write LISP without defun :-(
13:30:30 <dons> should data/sample/users100K.dic.hsb.zip be in the repo?
13:30:33 <alexyk> clojure took fun out of defn
13:30:37 <dafis> something like -A512M (or even 256M) should suffice
13:30:45 <alexyk> yep
13:30:50 <dons> mmm
13:31:08 <Veinor> djahandarie: :(
13:31:15 <alexyk> but on the big run, -A3G lead to degradation and collapse while -A5G finished
13:31:17 <dons> alexyk: $ ls data/sample 
13:31:17 <dons> dments100K.int.hsb.zip  dments100K.str.hsb.zip  dreps100K.int.hsb.zip  dreps100K.str.hsb.zip
13:31:20 <dons> no users file
13:31:38 <alexyk> dons: 1 sec
13:33:21 <alexyk> dons: was lost in a merge, let me regenerate and add, a few mins
13:39:12 <alexyk> dons: added
13:44:40 <alexyk> dons: fixed a bug too, now should compile again, pull now
13:45:56 <alexyk> dafis: let's see how -funbox speeds us up!
13:46:13 <dons> running
13:46:18 <alexyk> yay!
13:46:36 <seric> dancor: are you there?
13:46:42 <dafis> alexyk: don't expect miracles, but a few percent shouldbe expected
13:46:55 <dons> ./sc data/sample/dreps100K.int.hsb.zip data/sample/dments100K.int.hsb.zip      30.90s user 1.24s system 99% cpu 32.385 total
13:48:03 <dafis> dons: give it a little allocation area or it'll garbage collect like crazy
13:48:18 <dons> ok.
13:48:22 <dafis> I mean, it finished in under 30 secs on *my* box
13:49:10 <alexyk> dons: you gave it the users100K... too right?  time's just now showing it
13:49:10 <dons> looks like serializing is costly.
13:49:23 <dons> alexyk: yeah, all the files.
13:49:34 <dafis> dons: yes very costly
13:49:35 <dons> dafis: ah, 50% gc using only default flags
13:49:58 <alexyk> dons: yep, and I compress as I go; OCaml can't compress as it goes, so it just dumps.  I don't compare exactly; would have to make it call a compressor from itself.
13:50:44 <dons> does the parallel collector help, i wonder?
13:50:51 <dons> i'll add a .cabal file to make this easier
13:51:06 <alexyk> dons: ok
13:51:11 <wli> Marshalling is marshalling. Serialization is locking.
13:51:15 <alexyk> unboxing jumps a bit faster it seems
13:52:01 <alexyk> on x86_64, what size is Int?
13:52:15 <dafis> alexyk: 8 bytes
13:52:24 <dons> > sizeOf (undefined :: Int)
13:52:25 <lambdabot>   Not in scope: `sizeOf'
13:52:26 <BMeph> I wonder: what would an Emacs written in Clojure be like...?
13:52:39 <dcoutts_> wli: well, serialisation is to make something linear, so both are legitimate uses
13:52:40 <tommd> > Foreign.Storable.sizeOf (undefined :: Int)
13:52:41 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
13:52:42 <alexyk> dafis: so I might switch from Float to Double as I'm using Int mostly and a few Floats
13:52:43 <tommd> grrr
13:53:11 * dons does some profiling.
13:53:23 <dafis> alexyk: since we now need much less memory, we should have enough space for Double
13:53:41 <Twey> BMeph: Nais
13:53:52 <dafis> alexyk: might be a bit faster, too
13:53:54 <dons> dafis: have you benchmarked bytestring-trie ?
13:53:55 <alexyk> dafis: yep, I'll do the switch as numerically I see differences from ocaml/clojure, if only a bit.
13:53:59 <dons> i don't think i've ever seen numbers
13:54:01 <Twey> Especially if it had backwards-compatibility with elisp.
13:54:02 <dafis> dons: no
13:54:20 <dons> mtl also raises warning flags :)
13:54:33 * dons hacks
13:54:36 <dafis> alexyk: is there a download with bytestringtrie?
13:55:03 <alexyk> dafis: never did that.  Interned right away.  
13:55:24 <alexyk> so it's in IntBS.hs, and interning is done in saveGraph.hs
13:55:40 <alexyk> when converting a tokyocabinet source into the binary dump
13:56:04 <earthy> alexyk: Int is 64 bits on x86_64, CInt 32 bits.
13:56:27 <earthy> (yes, that may be confusing)
13:56:29 <alexyk> dafis: it would be fair-er to do an ininterned version too... but too much rewriting
13:56:35 <alexyk> earthy: thx
13:58:00 <dons> alexyk: so i have a local git repo, and i can record patches. how should i publish them?
13:58:47 <alexyk> dons: fork me on github instead of cloning, add my original as upstream, then push to yours and do pull request
13:59:03 <alexyk> @google github fork upstream
13:59:05 <lambdabot> http://help.github.com/forking/
13:59:05 <lambdabot> Title: Help.GitHub - Forking a project
13:59:12 <dons> ah
13:59:21 <dons> sigh darcs is so much easier :)
13:59:43 <Raynes> It's a three step process.
13:59:52 <tommd> step 1: read the documentation
13:59:53 <Raynes> Well, 4 step.
14:00:16 <Raynes> Click fork, clone your forked repo, make changes, push to your forked repo, hit pull request.
14:00:18 <Raynes> So 5 steps. ._.
14:00:27 <earthy> git has patch mailing, doesn't it?
14:00:31 <Raynes> But still, I've had more trouble eating chocolate cake.
14:00:35 <Raynes> Yes, you can do that too.
14:00:48 <dons> dafis: running with full profiling
14:00:51 <Raynes> But forking and pull requests is the typical workflow for github.
14:00:53 <dons> will see what we shall see
14:01:06 <dons> Raynes: but you're locked into gihub. wihch is annoying for a supposedly decentralized tool
14:01:09 <Raynes> Doesn't work out well for really large and popular projects though.
14:01:18 <Raynes> For example, Rich Hickey hates pull requests and takes patches instead.
14:01:31 <Raynes> dons: Well, you don't *have* to do it like that.
14:01:33 <alexyk> marshalling just grabs the box by the monads.  screen hangs and a poor chap running java is heard lamenting somewhere
14:01:35 <wjt> i don't suppose anyone's got some cabal/cpp goop kicking around to make things that use Pango (for instance) build against both the pre-cabalization version and the post-cabalization version of gtk2hs (which changed the module name), do they?
14:01:54 <Raynes> dons: Github just gives you a pretty interface over things.
14:03:09 <dons> looks like i need to get more ram in my next machine
14:03:10 <dcoutts_> wjt: you should be able to use the macros that Cabal defines
14:03:47 <dcoutts_> wjt: #if MIN_VERSION_pango(x,y,z)
14:03:58 <wjt> dcoutts_: oh hmm, because MIN_VERSION_pango just won't be defined, so will be false
14:04:06 <wjt> dcoutts_: good point, thanks :)
14:04:27 <dcoutts_> wjt: it'll always be defined if your package uses cabal, doesn't matter that gtk2hs did not use cabal
14:04:33 <dafis> dons: how much have you now?
14:04:33 <Raynes> dons: You are kind of right though. People don't use Github just for project hosting. They typically use it as an actual *tool* to aid in the development process.
14:04:44 <alexyk> dons: I'm glad to push Haskell to the Web Graph age :)
14:04:57 <alexyk> next step: hoogle for the web
14:05:36 * RayNbow has just discovered http://hackage.haskell.org/package/ansi-terminal and is filled with joy
14:05:45 <dcoutts_> wjt: take a look at dist/build/autogen/cabal_macros.h
14:06:27 <wjt> dcoutts_: but there wasn't previously a separate pango package, so I'm going to need a flag, I think
14:07:17 <dcoutts_> wjt: ah that's true, for the module imports you can base it off the gtk version, in the .cabal file you'll need a configuration flag
14:07:30 <wjt> sounds good. thanks :)
14:07:57 <dcoutts_> wjt: so that you can depend on the pango, conditional on the gtk package version
14:09:33 <eevar_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26676#a26676 -- euler 10. am I doing something stupid here? -- know a good algo/impl would run in ~5 sec for 2M elements, while this takes 3.6s for 10K
14:09:52 <ddarius> dons: Shae does have all that Cell hardware lying around somewhere.
14:10:50 <ddarius> eevar_: Well, you aren't using a good algorithm...
14:11:30 <sbpaul> what's the web framework a really lazy person should use
14:11:52 <ddarius> sbpaul: Maybe you can try bird?
14:11:56 <eevar_> ddarius: ok. that's all, or am I doing it wrong as well?
14:12:00 <dafis> eevar_, you're using a darned slow algorithm to produce the primes
14:12:17 <sbpaul> http://www.birdbaths.com/bird-baths/cast-stone-bird-baths/haskellbirdbath.cfm
14:12:19 <sbpaul> that isn't it, is it
14:12:45 <sbpaul> @hoogle bird
14:12:45 <lambdabot> No results found
14:12:47 <ddarius> @hackage bird
14:12:47 <lambdabot> http://hackage.haskell.org/package/bird
14:12:51 <dafis> eevar_, the summing is okay
14:13:13 <sbpaul> does it have database handling stuff
14:13:16 <dons> alexyk: did you ever try judy yet?
14:13:29 <sbpaul> like, interfaces or its own, like happs
14:13:32 <alexyk> dons: no, it would be a big rewrite
14:13:45 <alexyk> monadic
14:13:48 <dons> yeah, i see.
14:14:08 <alexyk> so far the 3 are similar, except ocaml's imperative hashtbl, but it looks "similar"
14:14:15 <alexyk> as it's not monadic
14:14:27 <ddarius> sbpaul: It doesn't appear to do any database stuff.  I presume you are just to use whatever you like.
14:14:34 <sbpaul> lovely
14:15:02 <dons> the hashtbl is faster? or slower? or ?
14:15:06 <sbpaul> i want to write the definitive haskell web framework
14:15:15 <sbpaul> do any of you know about this thing - it's like "the web mind" or something
14:15:27 <sbpaul> you literally just describe permissions, layout, and database structure
14:15:41 <mreh> is there a caveat attached to evalRandIO? I've got a non-terminating program
14:16:01 <mreh> is it that old, your random generator is stuck at the end of an infinite data structure thing
14:17:30 <alexyk> dons: mixed results vs. pure; http://eigenclass.org/R2/writings/finite-map-benchmarks
14:18:05 <alexyk> Fasthashtbl is best when there's no deletes, which is our case; but Ternary fares well as well.  I''d have to compare those in ocaml...
14:18:22 <alexyk> the fair-er would be to make ocaml use functional map
14:18:26 <dons> but you've not seen those results yourself yet?
14:18:34 <alexyk> dons: only Hashtbl
14:18:43 <alexyk> I started with standard libs
14:19:11 <alexyk> I wish there was a way to write Haskell so that I can replace Ord Map by Trie by IntMap by Judy
14:19:16 <alexyk> there gotta be a monad for that
14:19:46 <dons> mm
14:19:54 <yitz> alexyk: use edison
14:20:25 <ddarius> alexyk: You just use make a class for the operations you need lifting the pure ones into monadic ones.  It'd be butt ugly though for the pure data structures.
14:20:51 <ddarius> I agree with you as far as between different pure data structures (and different impure data structures).
14:20:52 <yitz> alexyk: why are the buckets in hashset/map a set/map and not a list?
14:21:42 <alexyk> yitz: where?
14:22:36 <yitz> data Hashset a = HS (IntMap (Set a))
14:22:54 <yitz> instead of HS (IntMap [a])
14:23:25 <yitz> and HM (IntMap [(k,a)])
14:23:30 <alexyk> yitz: you mean in the current code?
14:23:35 <dafis> yitz: Milan Straka's paper?
14:23:38 <yitz> yes
14:23:46 <yitz> in the paper
14:23:57 <Dashkal> ok, I've managed to pretty badly fubar my ghc package database (I was downloading and installing packages by hand).  How do I nuke the database so I can just install the platform?
14:24:49 <c_wraith> rm -r ~/.ghs ~/.cabal
14:24:58 <c_wraith> If you never used cabal-install, the latter might not exist
14:25:19 <yitz> c_wraith: but a working GHC is still needed, with the basic packages
14:25:23 <Dashkal> I have the latter but not the former...
14:25:34 <jbapple> I had wondered the same thing about the buckets
14:25:36 <Dashkal> I'll quite happile obliterate the entire thing and start from scratch if I have to
14:25:50 <dcoutts_> Dashkal: if you've been installing all packages globally you may need to just start again with a fresh ghc installation
14:26:10 <jbapple> I read a paper recently that claimed that the fastest hashtables use list buckets (with move-to-front)
14:26:10 <Dashkal> dcoutts_: That's more or less what I'm after.  Where is the system DB?
14:26:41 <yitz> jbapple: sounds plausible
14:26:47 <jbapple> Although google's hash tables are apparently very good, and they use quadratic probing, which I guess won't be efficient for IntSet-based hash containers
14:27:01 <dcoutts_> Dashkal: ghc-pkg list will tell you, but the only way to reconstruct the global db if you've really fubared things will be to reinstall ghc
14:27:22 <jbapple> (move-to-front is also not purely functional)
14:27:43 <ddarius> jbapple: Zobel's paper?
14:27:55 <jbapple> ddarius: One of, I think. Let me check.
14:28:03 <yitz> jbapple: well you could move-to-front on insert, at least.
14:28:24 <jbapple> ddarius: Askitis and Zobel, I think
14:28:35 <Dashkal> dcoutts_: Do you know offhand how to get ghc-pkg to cough up it's database location then?  That --help output is huge.  I'll be happy to start from zero here.  I just want to make sure the existing install doesn't interfere with the new, fresh one.
14:28:40 <jbapple> (BTW, have you seen Askitis's web page. It's . . . . unique)
14:28:47 <dcoutts_> Dashkal: ghc-pkg list will tell you that
14:28:53 <Dashkal> danke
14:29:02 <jbapple> ddarius: Askitis & Sinha, on HAT-tries
14:29:12 <Apocalisp> @hoogle m a -> (a -> m Bool) -> (a -> m b) -> m b
14:29:13 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:29:13 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:29:13 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:29:27 <yitz> dcoutts_: ghc ought to come with a way to restore the original base libs and pkg db
14:29:56 <dcoutts_> yitz: the original package db ought to be read only and the global one ought to be in /var/lib
14:30:16 <dcoutts_> yitz: so that you can mask the global one with new packages but never modify it
14:30:30 <dcoutts_> a split global package db
14:30:33 <Dashkal> That would be pretty handy at a time like this
14:30:42 <yitz> dcoutts_: agreed about the read-only part. /var/lib will be platform-dependent of course.
14:31:09 <dons> dafis: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26677#a26677
14:31:14 <dons> alexyk: profiling data for you.
14:31:23 <ddarius> jbapple: Zobel's original paper on such hash tables was in a particular context, but it is likely the results generalize to many, more common contexts.
14:31:26 <dons> natFromInt looks suspicious
14:31:29 <alexyk> dons: coolcool
14:31:51 <dcoutts_> yitz: you mean /var/lib on unix, somewhere else on windows etc, yeah
14:31:52 <yitz> dcoutts_: that should actually be trivial with multiple pkg dbs, no? just have one more core db which is the read-only factory default settings.
14:32:09 <dcoutts_> yitz: it should be reasonably straightforward, yes
14:32:25 <yitz> dcoutts_: even on unix it varies. everyone has their own religious philosophy about those things.
14:32:46 <dcoutts_> yitz: I suspect there's some bits in ghc and cabal where they assume global == single db
14:33:27 <yitz> dcoutts_: ok. just need to hunt those down i suppose. just try it and see how it breaks :)
14:33:34 <dcoutts_> yitz: :-)
14:33:49 <dcoutts_> yitz: in cabal it's the PackageDbStack stuff
14:34:02 <dons> alexyk, dafis heap-by-type: http://i.imgur.com/g70UF.png
14:34:07 <dons> the [] and (,) look suspicious
14:34:07 <dafis> dons: very suspicious
14:34:25 <dons> beautiful saw-tooths
14:34:47 <yitz> dcoutts_: i'd be more worried about the ghc part, but that's probably also not too bad.
14:35:05 <Apocalisp> @type let whileM test action = test >>= \v -> if v then action >> whileM test action else return () in whileM
14:35:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m ()
14:35:07 <alexyk> dons: pretty
14:35:13 * dons inlines in IntMap
14:35:18 <Apocalisp> Anything like that in standard libs?
14:35:34 <alexyk> what are [] and (,)?
14:35:38 <seric> @type fmap
14:35:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:36:03 <dcoutts_> yitz: my guess is the ghc/ghc-pkg bit is easier, it's got all the infrastructure for handling and merging multiple dbs, it'd hopefully just be changing the defaults and meanings of a couple flags
14:36:20 <yitz> sounds good
14:36:20 <dafis> dons: why do you think (,) and [] look suspicious, the dcaps map that is built is IntMap [(Int,Float)], so it's natural that they take more and more
14:36:55 <dons> oh, just that they are bad types
14:36:58 <dafis> alexyk: [] is lists, (,) pairs
14:37:09 <dons> use a specialized array, etc. that will not use so much overhead
14:37:20 <alexyk> dafis: so this is their allocation?
14:37:21 <dons> s/suspicious/typical/
14:37:25 <dcoutts_> yitz: we should really organise a core infrastructure hackathon :-)
14:37:26 <dons> alexyk: yeah
14:37:27 <yitz> dcoutts_: otoh the cabal code is younger and easier to maintain
14:37:39 <yitz> dcoutts_: sounds fun.
14:38:02 <dcoutts_> yitz: at the usual hackathons everyone works on fun hackage libs, not enough volunteers for the core bits
14:38:30 <dcoutts_> the first haskell hackathon was actually a ghc hackathon
14:38:34 <alexyk> dons: but IntMaps do grow as we scan, they preserve the stats.  The alg needs them to grow.
14:38:38 <yitz> dcoutts_: let's call them cabalomorphisms or something
14:38:45 <dcoutts_> yitz: heh heh
14:39:17 <alexyk> dons: dafis: need to go off the 'net for a few hours, please email
14:39:22 <dons> sure.
14:39:31 <dons> we know the types though, so a specialized pair type will have less overhead
14:39:49 <alexyk> dons: thanks a bunch for trying it! ttyl
14:41:03 <dafis> dons: data P = P {-# UNPACK #-} !Int {-# UNPACK #-} !Float, how much memory will that save over (Int, Float) ?
14:41:19 <dons> dafis, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26681#a26681
14:41:20 <dons> cabal file
14:41:34 <dons> dafis: two pointers + infos + more.
14:41:42 <dons> and guarantee strictness too
14:41:44 <dafis> dons: muchas gracias
14:41:54 <dcoutts_> dafis: it's fairly simple to count, there's one word for the constructor itself, then one word for each field
14:41:59 <jbapple> ddarius: Which paper is that?
14:42:15 <dcoutts_> dafis: non-strict fields are pointers to other constructors
14:42:41 <dcoutts_> dafis: so it's 3 + 2 + 2 vs 3, see why?
14:42:55 <dafis> dons: and what about a specialised strict list instead of ordinary should bring us down further, too?
14:43:07 <dons> yeah, maybe just use the adaptive-containers list 
14:43:13 <dons> since it will already specialize for Float,Int pairs
14:43:53 <jbapple> dcoutts_: Can you explain the arithmetic there in more detail? (3+2+2 etc.)
14:44:04 <dafis> dcoutts_ yes, didn't know whether there's further info needed somewhere
14:44:20 <dcoutts_> jbapple: 3 for (,) itself, 2 for Int, 2 for Float
14:44:46 * dons tries adaptives
14:44:48 <dcoutts_> jbapple: since it's 1 for each constructor and 1 for each field
14:45:15 <dcoutts_> so an Int heap object is 2, one for the heap object overhead and one for the payload
14:45:48 <jbapple> dcoutts_: So it's one for the Int constructor *and* an additional one for the pointer to that Int in (Int,Float)?
14:46:18 <dcoutts_> right, an Int field is 1 for the pointer to the Int and then 2 for the Int heap object
14:46:29 <dons> Data/Adaptive/Tuple.hs:1276:30:
14:46:29 <dons>     Warning: Ignoring unusable UNPACK pragma on the
14:46:30 <dons>              second argument of `PairCharInteger'
14:46:36 <dons> interesting. those worked previously...
14:46:42 <dcoutts_> where as if it's an UNPACKed Int, then it's just 1 for the Int#, no pointer and no heap object overhead
14:47:00 <dcoutts_> dons: did it, or did it just not complain that it was unusable?
14:47:13 <jbapple> dcoutts_: Makes me want to write ML :-)
14:47:21 <dcoutts_> dons: you've never been able to use UNPACK on polymorphic fields
14:47:47 <dons> dcoutts_: they're not polymorphic. these are those specialized type instance data types
14:47:53 <dcoutts_> jbapple: isn't it the same in ML? This issue is not related to strictness
14:47:56 <dons> and its complaining about nested unpacking
14:48:11 <dons> oh, Integer!!
14:48:16 <dons> that's all. just that its a sum type.
14:48:24 <dcoutts_> dons: ah yes, sigh
14:48:41 <jbapple> dcoutts_: It isn't? Then why does Int need two words?
14:48:50 <dolio> jbapple: It's related to polymorphism.
14:49:02 <dcoutts_> dons: I wonder if we could swizzle Integer into a single constructor pair type, like ForeignPtr
14:49:26 <jbapple> dolio: Is it for GC?
14:49:29 <dcoutts_> jbapple: you mean a Int heap object? because all heap objects have a one word descriptor for the GC.
14:49:36 <dons> yeah. i think it would be worth doing (general data representation changing for sums)
14:49:55 <jbapple> OK, well, I'm back then :-)
14:49:59 <roconnor> there are too many "Gauss's Lemma"
14:50:00 <dcoutts_> jbapple: or are you talking about the special representation some ML compilers use for the special case of Int?
14:50:15 <jbapple> dcoutts_: I was not
14:50:34 <dcoutts_> jbapple: some use a 31bit Int and use a tag bit, but then they have to have a separate boxed 32bit Int type
14:50:43 <jbapple> roconnor: "Few but ripe" :-)
14:51:13 <dolio> jbapple: I'd have to think about what all would be affected, but the overall point is that all types with kind * in GHC have a uniform representation so that polymorphic functions and the like can treat them all the same.
14:51:24 <roconnor> Cale: does the "content" of a polynomial sound familiar to you?
14:53:11 <yitz> roconnor: the wikipedia disamb page lists only 3 gauss's lemmas.
14:53:22 <roconnor> :)
14:53:40 <yitz> roconnor: however, it links to another page that lists nearly 100 other things named after gauss.
14:53:49 <dons> dcoutts_: i think cabal is disrespecting -rtsopts
14:53:58 <dafis> dons: re natFromInt, I would more or less expect that without profiling that's compiled to a no-op and only the auto-all prevents that from happening here
14:54:04 <dcoutts_> dons: how so?
14:54:10 <ddarius> yitz: There are only so many bits in the world.
14:54:29 <dons> well, with the profiling way, i can't seem to get it to use that flag to link
14:54:38 <dons> dafis: yes, that might be it.
14:54:45 <dcoutts_> dons: what are you doing exactly?
14:55:04 <dafis> dons: so perhaps fork the strict IntMap out to a separate package
14:55:16 <dons> trying to build a profiling executable with ghc head, and ensuring -rtsopts is passed when linking
14:55:20 <dolio> jbapple: And that works at a code-generation, level, I think. map :: forall a b. (a -> b) -> [a] -> [b] has identical code for all a and b. Doing unpacking for [Int] and such would require generating custom code for map :: (Int -> Int) -> [Int] -> [Int] and so on.
14:55:49 <zeta-> I've just tried to install Criterion to a build of Head ghc -- It fails because syb specifies base<4.3
14:55:51 <zeta-> Is this unnecessarily strict or is it known to not work? would base <5.0 be possible?
14:56:13 <dolio> Which is what stuff like adaptive tuple does by hand, using type families.
14:56:41 <dcoutts_> dons: and how are you calling cabal, or using the .cabal file to get it to use -rtsopts ?
14:57:20 <dons> cabal configure ; cabal build; currently -rtsopts passed as ghc-options: ... in the .cabal
14:57:38 <dons> i wonder where  that flag is supposed to be passed
14:57:44 <dafis> dons: or, for simplicity, first compile without auto-all, there are perhaps too few SCCs in the sources, but it should tell us whether there's something sfishy going on with natFromInt&co
14:57:44 <jbapple> dolio: This is all very familiar to me now. Thanks for the explanation. I'm kind of embarrassed to have forgotten it :-)
14:58:25 <dcoutts_> dons: you can see what cabal is doing with cabal build -v, I'd certainly expect it to pass all flags in ghc-options to ghc when linking executables. e.g. just like it does for -threaded
14:58:39 <dons> yes, it should be like -threaded
14:58:42 <dcoutts_> dons: there are no special filters
15:00:56 <ddarius> jbapple: "In-memory hash tables for accumulating text vocabularies" available here: http://ww2.cs.mu.oz.au/~jz/Papers.html  Also "Performance in practice of string hashing functions" is a good read.
15:01:36 <ManateeLazyCat> dcoutts_: I'm looking for how to propagate event on widget, and found three relate functions: gtk_propagate_event, gtk_widget_event, gtk_main_do_event. Do you know better solution?
15:02:08 <dcoutts_> ManateeLazyCat: sounds very low level, what are you actually trying to do?
15:03:10 <ManateeLazyCat> dcoutts_: I have multi-process framework like Chrome, i need send key to child process to handle key.
15:03:19 <Trevion> Is there a standard way to convince GHC on Windows to use a mingw besides the one it installs?
15:03:26 <ManateeLazyCat> dcoutts_: Wait, i give your screenshot.
15:03:39 <dcoutts_> ManateeLazyCat: I don't think a screenshot will help
15:04:14 <ManateeLazyCat> dcoutts_: YOu will better to know what i'm doing. :)
15:04:14 <dcoutts_> Trevion: the ghc user guide lists all the flags for using different tools, like the C compiler, assembler, linker etc.
15:04:50 <dcoutts_> Trevion: of the form -pgmX for various X
15:05:51 <ManateeLazyCat> dcoutts_: Simple, i send DBus key message to child process widget, then i can't handle key press through onKeyPress signal. Because key is happened on parent process widget, not child widget.
15:06:35 <ManateeLazyCat> dcoutts_: So i want to propagate key event on child widget after child process receive DBus key signal from parent process.
15:06:38 <dcoutts_> ManateeLazyCat: but you can call the same action as would happen
15:06:47 <Trevion> Is there a .ghc file similar to the .ghci file?
15:07:15 <dcoutts_> Trevion: no, and I don't recall if there's an env var or not
15:07:25 <dcoutts_> ManateeLazyCat: trying to insert artificial events sounds like a bad design
15:07:26 <ManateeLazyCat> dcoutts_: Yes, in textBuffer, i can build same action, but in WebKitGTK+ widget, i can do that.
15:07:58 <Trevion> Meh.  Sounds like symlinking ghc's mingw directory is the best solution.  I was hoping for something less hacky.
15:08:21 <dons> dcoutts_: http://stackoverflow.com/questions/3144722/how-can-i-build-cabal-install-on-eeepc-701-ubuntu-netbook-remix-1-6-lucid
15:08:25 <dons> another cabal question.
15:08:32 <ManateeLazyCat> dcoutts_: I need control key press from top-to-bottom, from ParentProcess-To-ChildProcess.
15:09:22 <dcoutts_> dons: I wish people would not report bugs via stackoverflow. That one is the usual one about the linker using too much memory and the kernel killing it.
15:09:58 <dcoutts_> dons: it's because ghc uses "split objs" by default and this makes the linker use a lot of memory
15:10:12 <dcoutts_> dons: because e.g. libHSbase.a contains over 10,000 .o files
15:10:37 <dcoutts_> the linker isn't designed for that style, it has too high a per-.o overhead
15:11:00 <dcoutts_> dons: and the eeePc of course does not have much ram
15:11:29 <dcoutts_> it's possible to build ghc without split objs, that's what gentoo does for low-memory systems
15:11:40 * dcoutts_ notes this problem will go away with shared libs
15:11:59 <ManateeLazyCat> dcoutts_: Looks http://farm5.static.flickr.com/4137/4747331678_441d6eb8ec_b.jpg , up is webkit browser, down is editor. All those sub-module is running in child process. In editor, i can use some APIs emulate insert key after i receive key message from DBus. But WebKitGTK+ haven't open APIs let me do some *insert key* event. So i need propagate key event on WebKit widget in child process.
15:13:01 <dcoutts_> ManateeLazyCat: I see, then yes investigate the low level event stuff in gtk, good luck!
15:13:46 <dcoutts_> ManateeLazyCat: or invoke widget signals instead, that's slightly higher level
15:13:55 <dcoutts_> ManateeLazyCat: neither are bound by gtk2hs
15:13:57 <dcoutts_> afaik
15:15:09 <dcoutts_> dons: are you answering that one, or am I?
15:16:14 <ManateeLazyCat> dcoutts_: invoke widget signals instead?
15:17:24 <dcoutts_> ManateeLazyCat: yes, there is a difference between windowing events and widget signals (one is a response to the other, and you can have signals that do not correspond to windowing events)
15:17:42 <dcoutts_> ManateeLazyCat: the gtk docs describe this in more detail
15:19:20 <ManateeLazyCat> dcoutts_: I know what you mean, if i don't use Window Event, i can control everything. I have framework to filter keymap in different level, something like: GlobalKeymap -> PageViewKeymap -> PageModeKeymap -> WidgetKeymap.
15:20:13 <ManateeLazyCat> dcoutts_: So i need filter key event on the top of Window.
15:20:19 <SonOfLilit> Hello
15:20:26 <ManateeLazyCat> dcoutts_: Then i dispatch event to low-level module.
15:20:27 <SonOfLilit> I am having a VERY strange issue
15:20:32 <SonOfLilit> my tests regularly fail
15:20:48 <SonOfLilit> and when I run the same code myself with identical params, it succeeds
15:21:08 <dafis> SonOfLilit, quickcheck tests?
15:21:12 <SonOfLilit> I even set a breakpoint and fed the same function the exact same data
15:21:14 <SonOfLilit> yes
15:21:22 <SonOfLilit> and it gave the correct result
15:21:42 <SonOfLilit> but then I :continue'd and te function gave a different result
15:21:51 <SonOfLilit> referential transparency broken?
15:23:06 <SonOfLilit> or is there another explanation?
15:23:36 <ManateeLazyCat> dcoutts_: Thanks for your suggestion, i will ask same question on #gtk+ to find best way...
15:23:48 <dafis> SonOfLilit, so, when you use the function normally in ghci, it works, but when you run it through quickcheck, it gives a different answer?
15:24:12 <SonOfLilit> indeed so
15:24:24 <dafis> baffling
15:24:28 <SonOfLilit> even with the quickCheck-generated data
15:25:04 <dafis> pure functions?
15:25:28 <kmc> all functions are pure unless you're playing tricks
15:25:48 <hpc> well, IO functions aren't pure
15:25:59 <kmc> what's an "IO function"?
15:26:08 <kmc> a function which returns an IO action is a pure function like any other
15:26:29 <roconnor> kmc: an IO function is a function with your Kliesli googles on
15:26:32 <kmc> yeah
15:26:36 <kmc> i broke mine
15:26:37 <hpc> ah
15:26:37 <dafis_> kmc: yes, but let's not split hairs now
15:26:59 * roconnor finds his googles useful
15:27:02 <kmc> yes, precision has no place in a discussion of programming languages
15:27:04 <kmc> ;P
15:27:10 <kmc> anyway don't mean to derail with pedantry
15:27:14 <SonOfLilit> so
15:27:15 <SonOfLilit> yes
15:27:16 <kmc> so usually when something this weird happens to me
15:27:16 <SonOfLilit> all pure
15:27:20 <kmc> it boils down to a stupid typo
15:27:24 <SonOfLilit> like?
15:27:36 <kmc> like you're QuickChecking foo' but running foo by hand
15:27:50 <kmc> do you have reasonably short code you can hpaste?
15:28:30 * ManateeLazyCat Looks i'm exploring in unknown space, research low-level gtk+ event....
15:28:42 <monochrom> I cannot reproduce your problem.
15:28:58 <kmc> i have to go now but i can take a look later
15:31:03 <SonOfLilit> well, gtg for tonight
15:31:07 <SonOfLilit> I'll debug this tomorrow
15:38:46 <dcoutts_> dons: http://stackoverflow.com/questions/3144722/how-can-i-build-cabal-install-on-eeepc-701-ubuntu-netbook-remix-1-6-lucid/3145285#3145285
15:41:00 <Dashkal> xcthulhu: There you are.  I wanted to thank you for your help with my pet language interpreter.  I have a working prototype.  Now I'm adding static typing.
15:41:27 <ddarius> That eeePc has more ram than my laptop...
15:41:40 <shapr> How much ram does your laptop have?
15:41:59 * ManateeLazyCat When i link my project (74 module), ghc eat too much memory....
15:42:44 <ddarius> I'm wrong.  The eeePc has as much ram as my laptop has.
15:42:45 <monochrom> why do people not build haskell platform instead?
15:43:08 <svk_> Hey, I'm getting an "ambiguous module name" for Control.Monad.State between mtl-1.1.0.2 and monads-tf-0.1.0.0 .. any suggestions on how this sort of thing might be resolved?
15:43:36 <svk_> The unregister command seems to indicate that unregistering either package would break something
15:43:43 <AnAdorableNick> svk_: You can hide either package
15:43:45 <dafis> svk_: ghc-pkg hide monads-tf or mtl
15:43:48 <geheimdienst> svk_, i had a similar thing and used ghc-pkg to hide the monads-tf thing
15:43:51 <AnAdorableNick> svk_: I'd hide the latter package.
15:44:03 <geheimdienst> or you can write a .cabal file and say build-depends: mtl
15:44:11 <monochrom> 0. hide one of the two.  1. use myproject.cabal so you explicitly list packages you use
15:44:17 <svk_> Hm, okay, is that a one-time system-wide thing or something I need to do for every compilation?
15:44:19 <ManateeLazyCat> ski: sudo ghc-pkg hide monads-td
15:44:32 <geheimdienst> (writing a cabal file is easy, you just need to run cabal init and it will ask you a few questions)
15:45:05 <monochrom> ghc-pkg hide is one-time and not referentially transparent.  myproject.cabal is referentially transparent.
15:45:06 <ddarius> "What is your mother's maiden name?  Where have you lived for the last five years?  Which schools have you attended?"
15:45:17 <McManiaC> darcs can be used on both, linux and windows, correct?
15:45:23 <svk_> Thanks, hiding seems to have fixed it
15:45:32 <ddarius> McManiaC: Of course.
15:45:33 <McManiaC> dont have a windows here atm to try it
15:45:34 <McManiaC> :>
15:45:51 <geheimdienst> ddarius: "How many sons do you have? Were any born on a Tuesday?"
15:46:29 <monochrom> "do you have criminal records?"
15:46:57 <dafis> what crime could records commit?
15:47:01 <pizza_> "well, I bought Thriller"
15:47:17 <monochrom> memory leak crimes
15:47:36 <mreh> how could the program output freeze without any cpu cycles?
15:47:46 <dafis> monochrom, ah, such records, I was thinking of black vinyl
15:47:54 <mreh> I need scenarios
15:47:58 <geheimdienst> waiting on input? from standard in or something?
15:48:20 <dafis> mreh, blocked waiting on an MVar
15:48:21 <geheimdienst> waiting on a thread that is waiting on the first thread
15:48:28 <mreh> well, I am using HGL...
15:48:44 <mreh> all I did was change a dep
15:48:51 <dafis> mreh: does moving the mouse over the window help?
15:49:08 <mreh> dafis: nope
15:49:36 <dafis> mreh: what dep did you change
15:49:54 <mreh> dafis: Yampa
15:50:06 <mreh> okay admitedly I had changed some code in Yampa, so it's more likely to be that
15:50:10 <mreh> but Yampa is completely pure
15:50:47 <mreh> aside from "reactimate", but that's only getting a StdGen
15:50:51 <monochrom> some infinite loops exhibit that behaviour. even when in pure functional code.
15:50:54 <dafis> hrrmpf, Yampa, that's none of my acquaintances
15:51:22 <deech> Hi all, a question was asked on the list about reading Haskell code. One of the hardest things for me is visualizing the transformations and the debugger is no help. Is there a tool that will spell it out or is that something I have to do manually?
15:51:58 <monochrom> there is a website for that. I forgot the url.
15:52:32 <deech> Is this a good way of learning? 
15:53:10 <mreh> deech, if you want to learn how a haskell program is executed, and dry run them yourself, read about graph reduction
15:53:10 <monochrom> yes, the website was designed for learning
15:53:53 <deech> mreh: Where would I read about graph reduction in Haskell?
15:54:21 <mreh> @google haskell wiki graph reduction
15:54:22 <lambdabot> http://en.wikipedia.org/wiki/Graph_reduction
15:54:22 <lambdabot> Title: Graph reduction - Wikipedia, the free encyclopedia
15:54:25 <mreh> nope
15:54:31 <mreh> there's a good page on the haskell wiki
15:54:57 <mreh>  @google lies
15:54:58 <mreh> http://en.wikibooks.org/wiki/Haskell/Graph_reduction
15:55:00 <ddarius> @google site:haskell.org "graph reduction"
15:55:02 <lambdabot> http://www.haskell.org/haskellwiki/GHC_optimisations
15:55:02 <lambdabot> Title: GHC optimisations - HaskellWiki
15:55:08 <mreh> see
15:55:28 <mreh> every haskell implementation known to man uses lazy evaluation I think
15:56:12 <ddarius> For an accomodating notion of "lazy"
15:56:14 <kmc> couldn't lazy evaluation be described as in-place or mutating graph reduction?
15:56:21 <deech> Thanks!
15:57:04 <mreh> isn't that tautologous?
15:57:51 <mreh> monochrom, did you remember?
15:58:06 <mreh> a clue maybe?
15:59:44 <ddarius> kmc: Graph reduction is an implementation of lazy evaluation.
16:00:21 <ddarius> (Not just non-strict semantics.)
16:00:56 <monochrom> What did I remember?
16:01:22 <mreh> monochrom, oh, you were talking to deech
16:01:26 <mreh> some website
16:01:47 <monochrom> I still can't remember and I still can't find it after some simple googling.
16:02:40 <mreh> when will the haskell learning end
16:02:52 <ddarius> mreh: When you stop.
16:02:54 <monochrom> when the learner dies
16:02:57 <dafis> mreh: over my dead body
16:03:06 <monochrom> heh indeed
16:03:18 * mreh despairs
16:03:40 <mreh> I only wanted to do something useful!
16:03:57 <monochrom> that's an orthogonal question
16:04:32 <monochrom> like, look, you haven't learned *everything* about the natural numbers, but you are already doing something useful with them, aren't you?
16:04:59 <mreh> I frequently overstep my mark
16:05:15 <ddarius> When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
16:05:45 <mreh> problems can be overcome
16:05:57 <monochrom> give a man a haskell program, and he has a problem for a day. teach a man haskell, and he has problems for life.
16:06:17 <monochrom> @remember ddarius When a programmer has a problem and says "I'll use regular expressions," they have two problems.  When the programmer says "I'll use Haskell," they have a lifetime of problems.
16:06:17 <lambdabot> It is forever etched in my memory.
16:06:50 <dafis> mreh: a good answer to a problem poses two new problems
16:06:51 <ivanm> :o
16:07:09 <mreh> at least the night of fruitless debugging are over
16:07:17 <monochrom> anyway there is a rather small subset of haskell such that if you learn it you can do a lot of useful things already. you just have to find such a subset.
16:08:34 <mreh> it's a shame it's uncountable
16:08:44 <monochrom> > sum [4,4,5,0,8,9,6]
16:08:46 <lambdabot>   36
16:08:48 <mreh> but we can work with the definition of the set
16:09:16 <mreh> monochrom: doing your groceries?
16:09:24 <monochrom> That is very little to learn, but very useful when I marked exams and needed to add marks.
16:10:05 <ddarius> monochrom: Learning Lisp or J would have been better.
16:10:07 <monochrom> If you want to code up a "guess the animal" game, there is also fairly little to learn.
16:10:33 <mreh> when I master Yampa, the sky is the limit
16:10:45 <mreh> heck, I'm writing Yampa
16:10:49 <ddarius> That's a pretty shallow limit.
16:10:52 <monochrom> You just need strings, if-then-else, how to define functions, getLine, putStrLn, main.
16:11:17 <monochrom> when I learn natural numbers, œâ is the limit
16:11:24 <mreh> ddarius: bring me back some sky then :)
16:11:38 <Baughn> For a type family Foo, how can I make GHCi tell me what the type of Foo a is?
16:11:40 <ddarius> I have quite a bit of it sitting in my room.
16:11:49 <Baughn> (I mean, other than Foo a...)
16:12:09 <mreh> @wn sky
16:12:11 <lambdabot> *** "sky" wn "WordNet (r) 2.0"
16:12:11 <lambdabot> sky
16:12:11 <lambdabot>      n : the atmosphere and outer space as viewed from the earth
16:12:11 <lambdabot>      v : throw or toss with a light motion; "flip me the beachball";
16:12:11 <lambdabot>          "toss me newspaper" [syn: {flip}, {toss}, {pitch}]
16:12:33 <ddarius> Baughn: You can probably trick it into reducing by creating a type error.
16:13:09 <Baughn> Ah.. I guess that will do.
16:14:05 <lispy> mreh: Wait, so you can say "sky me the beachball"?  I've never heard that usage
16:14:13 <McManiaC> how would you guys build a multithreaded application with some state? a simple reader-monad to a mvar? the state monad doesnt seem to fit into that kind of applications?
16:14:24 <ddarius> lispy: Yet more proof that the language WordNet covers is not English.
16:14:45 <Baughn> ddarius: No, actually, that doesn't work. :/
16:15:02 <mreh> "sky" is australian isn't it?
16:15:30 <lispy> McManiaC: TVars are nicer to work with for concurrency I believe
16:15:33 <Trevion> Hmm.  If I'm using printf from Text.Printf and I do something like 'do printf "%c\n" 'c' ; return ()' GHCi complains at me about lacking an instance of PrintfType for (m a) ... is there a good way around that besides appending :: IO () to all my printf calls?
16:15:48 <lispy> McManiaC: and I seem to recall  them having less contention and thus better performance
16:16:14 <lispy> McManiaC: But, are you adding threads to get concurrency or parallelism?
16:16:28 <McManiaC> concurrency
16:16:44 <McManiaC> (not exactly sure what the difference is, tho :) )
16:16:56 <lispy> McManiaC: http://haskell.cs.yale.edu/haskellwiki/Parallelism_vs._Concurrency
16:18:01 <Boney_> mreh: I live in Melbourne, I've never heard 'sky' used as a verb.
16:18:06 <mreh> if you program in an imperative language, please disregard this example
16:18:22 <mreh> Boney_ it's Tazmanian
16:18:35 <mreh> s/example/article/
16:18:35 <McManiaC> yeh, so concurrency as I said lispy :)
16:18:40 <Boney_> oh,  that's a different country.
16:18:50 <mreh> Boney_, j/k :)
16:19:08 <lispy> McManiaC: in that case, if I were you I'd start with  STM
16:19:12 <McManiaC> okay
16:19:29 <lispy> McManiaC: http://www.haskell.org/haskellwiki/Software_transactional_memory
16:19:31 <McManiaC> but the reader approach seems reasonable?
16:19:33 <Boney_> mreh: heh.
16:20:17 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26685#a26686 <- Okay, so I have yet another type family-related mystery type error.
16:20:22 <lispy> McManiaC: perhaps.  I would probably need to know more to make that call :)
16:20:35 <lispy> McManiaC: I'm not a concurrency expert, BTW
16:20:44 <McManiaC> okay :)
16:20:57 <sbpaul> @wn trigganomics
16:20:57 <lambdabot> No match for "trigganomics".
16:21:01 <sbpaul> figures
16:21:13 <sbpaul> trigganomics from blocks where clips is poppin and the coppers watch when the shit is droppin, drama mic pop off, and homicides not solved, plus we hard to kill, reppin where bodies is real
16:21:21 <wagle> anyone seen this? GHCi runtime linker: fatal error: I found a duplicate definition for symbol
16:21:21 <wagle>    get_current_timezone_seconds
16:21:21 <wagle> whilst processing object file
16:21:21 <wagle>    /usr/local/lib/time-1.2.0.2/ghc-6.10.4/HStime-1.2.0.2.o
16:21:33 <mreh> this is a haskell channel, for discussing haskell
16:21:39 <lispy> McManiaC: There is also a good chance that Haskell has a library for what you want to do.  Such as Orc/CHP/etc
16:21:45 <sbpaul> mreh: my young people in the flip business, in click digits, see pigs sittin in mad vehicles on heated strip, peepin for d's and e's with empty clips  
16:22:29 <mreh> > cycle "brap "
16:22:30 <lambdabot>   "brap brap brap brap brap brap brap brap brap brap brap brap brap brap brap...
16:22:49 <sbpaul> np: Message to Bears - Funny Shape For a Crocodile
16:23:01 <hpc> @src cycle
16:23:02 <lambdabot> cycle [] = undefined
16:23:02 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:23:03 <geheimdienst> > cycle "nom "
16:23:04 <lambdabot>   "nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom no...
16:23:15 <McManiaC> lispy: ok, gonna take a look :)
16:23:18 <hpc> cycle = fix (join ++)?
16:23:26 <sbpaul> > cycle ",.;:'`':;."
16:23:27 <lambdabot>   ",.;:'`':;.,.;:'`':;.,.;:'`':;.,.;:'`':;.,.;:'`':;.,.;:'`':;.,.;:'`':;.,.;:...
16:23:31 <mreh> > "om " ++ cycle "nom "
16:23:32 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
16:23:43 <sbpaul> let's try it with unicode
16:23:53 <sbpaul> > cycle "„éô„éë„çΩ„ç¶„çï„çâ"
16:23:54 <lambdabot>   "\13209\13201\13181\13158\13141\13129\13209\13201\13181\13158\13141\13129\1...
16:23:57 <sbpaul> bastard
16:24:30 <hpc> it would have been amusing to give it latin1 and have it accidentally build unicode
16:24:55 <lispy> McManiaC: Orc is for scripting a set of concurrent requests (that can fail/timeout/etc) and CHP I can't remember a quick description of :)
16:25:00 <geheimdienst> > "tr" ++ cycle "ol"
16:25:02 <lambdabot>   "trolololololololololololololololololololololololololololololololololololol...
16:25:55 <McManiaC> > 'f' : cycle 'u'
16:25:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:25:56 <lambdabot>         against inferred ty...
16:25:58 <McManiaC> :D
16:26:20 <McManiaC> > 'f' : cycle "u"
16:26:21 <lambdabot>   "fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu...
16:26:33 <McManiaC> :P
16:26:53 <sbpaul> > take 7 $ cycle "f" ++ take 12 $ cycle "u"
16:26:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:26:54 <lambdabot>         against inferred ty...
16:26:55 <sshc> > 'f' : repeat 'u'
16:26:57 <lambdabot>   "fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu...
16:26:59 <sbpaul> ummm
16:27:06 <sbpaul> > take 7 . cycle "f" ++ take 12 . cycle "u"
16:27:07 <lambdabot>   Couldn't match expected type `[a]'
16:27:07 <lambdabot>         against inferred type `GHC.Types...
16:27:11 <sshc> ^ more effecient!
16:27:12 * sbpaul sighs
16:27:13 <hpc> > 'f' : fix (:'u')
16:27:14 <lambdabot>   Couldn't match expected type `[a]'
16:27:15 <lambdabot>         against inferred type `GHC.Types...
16:27:31 <hpc> > 'f' : fix ('u':)
16:27:32 <lambdabot>   "fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu...
16:27:41 <sbpaul> > (take 7 (cycle 'f')) ++ (take 12 (cycle 'u'))
16:27:41 <lambdabot>   Couldn't match expected type `[a]'
16:27:42 <lambdabot>         against inferred type `GHC.Types...
16:27:50 <mreh> :t cycle
16:27:50 <lambdabot> forall a. [a] -> [a]
16:27:55 <mreh> :t repeat
16:27:56 <lambdabot> forall a. a -> [a]
16:28:11 <hpc> @src repeat
16:28:12 <lambdabot> repeat x = xs where xs = x : xs
16:28:14 <hpc> @src cycle
16:28:15 <lambdabot> cycle [] = undefined
16:28:15 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:28:16 <sbpaul> > (take 7 (cycle 'f')) : (take 12 (cycle 'u'))
16:28:16 <lambdabot>   Couldn't match expected type `[a]'
16:28:17 <lambdabot>         against inferred type `GHC.Types...
16:28:21 <sbpaul> ok why isn't this working
16:28:23 <mreh> @vixen how's the signal to noise ratio?
16:28:24 <lambdabot> however you want
16:28:43 <lispy> ?vixen since when have you been easy going?
16:28:44 <lambdabot> when? now? later?
16:28:44 <mreh> smart ass
16:29:30 <Zeiris> Are there any standard lirbaries/packages for running state machines?
16:29:52 <mreh> Arrows!
16:30:20 <mreh> that's not a suggestion
16:30:24 <mreh> but they'd be good
16:30:55 <sbpaul> > take 12 (cycle "f")
16:30:56 <lambdabot>   "ffffffffffff"
16:31:12 <sbpaul> > take 7 (cycle "f") ++ take 12 (cycle "u")
16:31:13 <lambdabot>   "fffffffuuuuuuuuuuuu"
16:31:17 <sbpaul> didn't i just do that
16:31:31 * Zeiris doesn't get how arrows can be used to implement state machines, like network protocols and stuff. Oh well, time to read more papers.
16:32:13 <mreh> Zeiris: Arrows are just an interface, that doesn't say anything about how they work
16:32:49 <hpc> State = Arrow (,), doesn't it?
16:33:23 <geheimdienst> > let f = (take . cycle) in f 7 "f" ++ f 12 "u"
16:33:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:33:24 <lambdabot>         against inferred type ...
16:33:47 <geheimdienst> > let f = (take . cycle) in f "f" 7
16:33:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:33:48 <lambdabot>         against inferred type ...
16:33:55 <geheimdienst> :t take.cycle
16:33:56 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
16:33:56 <lambdabot>       Expected type: [a] -> Int
16:33:56 <lambdabot>       Inferred type: [a] -> [a]
16:33:56 <c_wraith> how do I mark multiline code blocks in haddock
16:34:13 <sbpaul> np: Message to Bears - Plane Over Evening Sky
16:34:27 <geheimdienst> > let f = (take . (. cycle) in f "f" 7
16:34:28 <lambdabot>   <no location info>: parse error on input `in'
16:34:32 <geheimdienst> > let f = (take . (. cycle)) in f "f" 7
16:34:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:34:33 <lambdabot>         against inferred type ...
16:34:46 <geheimdienst> > let f = ((take . ). cycle) in f "f" 7
16:34:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:34:47 <lambdabot>         against inferred type ...
16:35:21 * geheimdienst has weak pointsfree-fu, and his technique of randomly sprinkling in parens has not born fruit
16:35:48 <geheimdienst> @pl \a b -> take a $ cycle b
16:35:49 <lambdabot> (. cycle) . take
16:36:00 <geheimdienst> @pl \b a -> take a $ cycle b
16:36:00 <lambdabot> flip take . cycle
16:36:10 <BMeph> ...darn, was gonna type that... :)
16:38:02 <geheimdienst> of the many things that freak me out about haskell, one is that normal style seems to have one order and pointsfree seems to have the reversed order for some reason
16:39:39 <orlandu63> that depends on where the points lie in the pointful version of a function
16:39:59 <geheimdienst> @pl \a b -> take a $ cycle b
16:40:00 <lambdabot> (. cycle) . take
16:40:00 <hpc> sections of (.) are freaky, no matter how you slice it
16:40:12 <Twey> fmap ‚ô•
16:40:15 <geheimdienst> ^^ orlandu63, i was referring to this in particular
16:40:21 <Twey> flip fmap cycle . take!
16:40:34 <lispy> geheimdienst: yeah, data flow switches depending on the composition operator, but overtime I think you get used to it
16:40:40 <geheimdienst> > (flip fmap cycle . take) 7 "u"
16:40:41 <lambdabot>   "uuuuuuu"
16:40:54 <Philonous> > let f = (+); (+) = (*) in f 2 3
16:40:55 <lambdabot>   6
16:40:59 <lispy> geheimdienst: like (>>=) vs. (=<<)
16:41:36 <Twey> > (flip fmap take $ flip fmap cycle) 7 "u"
16:41:37 <lambdabot>   "uuuuuuu"
16:41:42 <hpc> (=<<) is a nice throwback to function application
16:41:43 <BMeph> > flip take . cycle $ 'f' 7
16:41:44 <lambdabot>   Couldn't match expected type `t -> [a]'
16:41:44 <lambdabot>         against inferred type `GHC....
16:41:56 <BMeph> > (flip take . cycle) 'f' 7
16:41:57 <lambdabot>   Couldn't match expected type `[a]'
16:41:57 <lambdabot>         against inferred type `GHC.Types...
16:42:08 <BMeph> > (flip take . cycle) "f" 7
16:42:09 <lambdabot>   "fffffff"
16:42:13 <hpc> :t (($)$($))
16:42:14 <lambdabot> forall a b. (a -> b) -> a -> b
16:42:35 <Axman6> that's the ABBA operator
16:42:39 <BMeph> :t (.)$(.) -- stripper opr
16:42:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
16:43:00 <orlandu63> heh
16:43:07 <geheimdienst> :t ( . )$( . )
16:43:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
16:43:30 <geheimdienst> big-boobed stripper operator
16:43:36 <hpc> that looks like a freaky sort of fmap/applicative
16:43:40 <Twey> > (on ap (flip fmap) take cycle) "u" 7
16:43:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:43:44 <Twey> Aw
16:44:02 <pizza_> :t ap
16:44:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:44:50 <geheimdienst> :t fmap
16:44:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:46:03 <hpc> :t (fmap `on` fmap)
16:46:04 <lambdabot> forall b (f :: * -> *). (Functor f) => (b -> b) -> (b -> b) -> f b -> f b
16:46:11 <sbpaul> np: Message To Bears - Pretend To Forget
16:46:17 <Trevion> :t (.)
16:46:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:46:20 <geheimdienst> hpc, thanks for making that clear
16:46:26 <Trevion> orly.
16:46:45 <hpc> :t (pure `on` fmap)
16:46:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> (a -> b) -> f a -> f b
16:47:01 <dafis> @tell dons dafis would appreciate being kept informed
16:47:02 <lambdabot> Consider it noted.
16:47:03 <hpc> :t pure
16:47:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:47:34 <hpc> oh, dur
16:47:37 <hpc> :t fmap fmap
16:47:38 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:47:45 <hpc> that's what it is
16:48:26 <geheimdienst> you mean fmap fmap is ap? because i don't think that's quite right
16:48:50 <hpc> i didn't mention ap
16:48:52 <Twey> No, ap was completely the wrong thing to do there
16:49:06 <hpc> i thought that would take applicative to accomplish, but forgot the (.)=fmap relationship
16:51:04 <Twey> Oh, maybe not
16:51:29 <Twey> > (ap ($ take) ($ cycle) $ flip fmap) 7 "u"
16:51:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:51:30 <lambdabot>         against inferred type ...
16:51:36 <Twey> Ack
16:51:41 <hpc> :t (<*>)
16:51:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:53:07 <Twey> Oh
16:53:13 <Twey> I think I'm getting monomorphed
16:53:29 <Eduard_Munteanu> Hi.
16:53:29 <geheimdienst> (last words of the haskell programmer)
16:53:54 <Eduard_Munteanu> Just missed a Haskell joke? :)
16:54:12 <geheimdienst> twey said: Oh, I think I'm getting monomorphed
16:54:17 <BMeph> Eduard_Munteanu: Just..."i c wat u did ther"... ;)
16:54:25 <Eduard_Munteanu> :))
16:54:41 <Twey> Eduard_Munteanu: It's okay ‚Äî the joke didn't exist until you came into the room and looked for it.
16:54:51 <Eduard_Munteanu> Heisenjoke :P
16:55:09 <geheimdienst> #haskell‚Ñ¢ -- Where you always, no matter when you come in, just missed the joke
16:55:15 <brachiel> Twey: Schrˆdinger?
16:55:30 <Eduard_Munteanu> Or that.
16:55:37 <Eduard_Munteanu> Rather that.
16:55:38 <geheimdienst> no, schr√∂dinger's joke is one that might or might not be dead yet
16:56:02 <hpc> this joke is simultaneously funny and not funny until someone reads it?
16:56:16 <Eduard_Munteanu> That's more like it.
16:56:18 <brachiel> how did it turn out in the end?
16:56:22 <hpc> yes
16:56:39 <Eduard_Munteanu> Once you get entangled with its humor you get to tell.
16:57:36 * hpc collapses at the pun
17:03:58 <BMeph> hpc: Kid, you got potential... ;)
17:05:01 <hpc> you're interfering with my vibe
17:10:09 <hpc> #haskell, where quantum mechanics puns are the most boring joke in the room
17:11:29 <soupdragon> I don't get quantum mechanics
17:11:33 <soupdragon> how do they know h
17:11:39 <geheimdienst> and quantum jokes would be the epitome of funnytude in what rooms exactly?
17:11:40 <soupdragon> and why do they think it's random 
17:11:48 <soupdragon> I mean maybe you just need to measure the actual position of the electron
17:12:06 <soupdragon> but I probably need to learn about 5 years more physics to even understand the question I am asking here
17:12:25 <hpc> it's a hell of a lot of math
17:12:38 <monochrom> and a hell of a lot of subtle experiments
17:12:40 <soupdragon> yeah the math is mad lol 
17:12:51 <monochrom> the observations are madder
17:12:52 <soupdragon> I read about it in Penroses book
17:13:00 <soupdragon> they use differential operators instead of numbers
17:13:19 <hpc> there's a company/research group/lab/something
17:13:25 <soupdragon> e^(d/dx)
17:13:27 <soupdragon> stuff like that
17:13:29 <travisbrady> I've written a fold operation that takes quite a few parameters that are currently bundled up in a tuple.  Should I be using the State monad?  Making a new data type to hold all the state?
17:13:40 <hpc> that's attempting to make a quantum-entangled mass that is visibly large
17:13:45 <soupdragon> travisbrady: what data type is it for ?/ and show the function
17:13:48 <geheimdienst> you can get by just fine if you just know schr√∂dinger's cat and heisenberg's uncertainty principle. 
17:14:04 <soupdragon> oh I heard about atht like if you entagle enough photons you can make more precise measurments
17:14:11 <soupdragon> like an electron microscope but even better
17:14:18 <geheimdienst> "is there a problem officer?" -- "do you know how fast you were going?" -- "i have no idea, but i know exactly where i was" ...
17:14:28 <soupdragon> sounds cool I want to see photos of molecules at the level of atoms
17:14:47 <travisbrady> soupdragon: this is a fold over stdin where I'm incrementing the values in a Data.Map and  doing a few other sums and such.
17:15:09 <soupdragon> travisbrady, oh sounds a lot different to the sort of fold I know about
17:15:09 <hpc> IBM has a picture of their logo printed with 40 or so carbon atoms, iirc
17:16:09 <hpc> it looks kinda like this: http://www.cite-sciences.fr/english/ala_cite/exhibitions/nanotechnologies/images/diapo01/08-stm15.jpg
17:16:31 <hpc> oh, found it: http://www.futuretimeline.net/subject/images/nanotechnology-future-uses-ibm-1989.jpg
17:16:42 <soupdragon> hpc but that's a computer graphic
17:17:16 <hpc> it has to be
17:17:23 <hpc> at that scale, pictures are monochromatic
17:17:34 <soupdragon> http://www.nature.com/nature/journal/v440/n7082/images/nature04586-f2.2.jpg
17:17:44 <soupdragon> they were able to design protiens, I think - which fold into these shapes
17:17:47 <hpc> and the space between atoms is significant
17:18:00 <hpc> haha
17:18:13 <hpc> <3 the happy protein
17:19:05 <hpc> speaking of which, i heard human chromosome molecules are visible to the naked eye
17:19:07 <hpc> is this true?
17:19:38 <McManiaC> is there any documentation on how to use the darcs API?
17:19:48 <soupdragon> hpc, I doubt it.... don't they have to fit inside a cell?
17:20:00 <hpc> it folds, i think
17:20:09 <soupdragon> hpc, maybe they are visible to the naked eye through a microscope.... I mean they are HUGE compared to the DNA they're made up
17:20:11 <soupdragon> of..
17:20:23 <soupdragon> but I think they are microscropic
17:20:27 <soupdragon> at least human cromosomes
17:20:40 <benmachine> they fit inside cells, and cells are invisible
17:21:01 <hpc> that would make sense
17:22:04 <soupdragon> hpc it might well be truth though I don't know
17:22:32 <Eduard_Munteanu> geheimdienst: lol, I have to remember that.
17:32:24 <eugenn>  >2+1
17:32:35 <eugenn> > 2+1
17:32:36 <lambdabot>   3
17:34:11 <kmc> here are some human chromosomes: http://en.wikipedia.org/wiki/File:HumanChromosomesChromomycinA3.jpg
17:34:19 <Aeswwer> [1..10]
17:34:56 <Aeswwer> whats the coolest thing in haskell these days?
17:34:56 <akosch> where can i find the pkg-config package?
17:35:14 <kmc> Aeswwer, hard to say, what do you find cool?
17:36:18 <eugenn> > cycle "cool"
17:36:19 <lambdabot>   "coolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolcoolco...
17:36:21 <soupdragon> 5 mu meters?
17:36:29 <soupdragon> do chromosomes have buddha nature?
17:36:32 <kmc> 5 micrometers yes
17:36:58 <Aeswwer> idk math/comp sci things
17:37:15 <sshc> What causes "hClose: illegal operation (handle is finalized)"?
17:37:20 <blackdog> soupdragon: mu.
17:37:23 <kmc> if you unfolded one it'd be really long but only a few nm thick
17:37:51 <kmc> Aeswwer, since you already specified Haskell that doesn't narrow it down much
17:37:58 <kmc> what do you already know?
17:38:00 <Aeswwer> lol
17:38:15 <Aeswwer> just anything
17:39:09 <monochrom> knows how to be vague
17:39:24 * kmc doesn't quite understand this game
17:39:26 <ddarius> monochrom: I don't believe you.
17:39:48 <Aeswwer> i'll look at anything
17:40:15 <eugenn> @quote terrific
17:40:15 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:40:27 <monochrom> don't believe me. believe your scroll buffer
17:40:37 <soupdragon> wayt a mu meter is smaller than an n meter?
17:40:45 <eugenn> no
17:40:55 <kmc> ¬µ = 10^-6
17:40:57 <eugenn> mu is ten to the minus six
17:40:58 <kmc> n = 10^-9
17:41:26 <monochrom> "mu meter" is micrometre
17:41:49 <monochrom> or ¬µm
17:42:28 <kmc> or sometimes "micron"
17:42:52 <kmc> 1 ns ~ 1 foot
17:43:06 <monochrom> I just find speaking like "GH compiler" odd
17:43:14 <kmc> 1 ¬µs ~ 1/5 mile
17:44:09 <Aeswwer> ai?
17:44:53 <eugenn> @quote spanish
17:44:53 <lambdabot> shepheb says:  I've got a Spanish test at 11:30 that I should be studying for now instead of reading proggit.
17:45:10 <kmc> the distance from carteret, new jersey to weehawken, new jersey is about 107 ¬µs
17:45:59 <eugenn> @quote speed
17:45:59 <lambdabot> JohnyBoy says: so have a nice goodspeed
17:46:05 <monochrom> you remind me of Gracehopper
17:47:00 <kmc> you can read proggit and study for spanish at the same time using https://chrome.google.com/extensions/detail/plpjkjplknknmhfhkjgcfgofclmlnine
17:47:40 <eugenn> @quote impressive
17:47:41 <lambdabot> ddarius says: "simples" is an impressive typo [for symbols]
17:47:53 <monochrom> not sure that is "learn spanish as written by people" or "learn spanish as generated by computer"
17:48:25 <kmc> they use mostly the same vocabulary
17:48:29 <kmc> which is the hard part
17:48:32 <kmc> if you're a programmer ;P
17:49:14 <sshc> What causes "hClose: illegal operation (handle is finalized)"?
17:49:23 <monochrom> No, I think computer gets the vocabulary wrong, too.
17:49:28 <kmc> sshc, what are you doing?
17:49:45 <monochrom> But I guess I only know of anecdotal hilarious examples.
17:49:55 <sshc> kmc: I'm running a Haskell program
17:50:00 <kmc> err ok
17:50:03 <sshc> kmc: Apparently, I have a mistake somewher in my code.
17:50:10 <kmc> i'm running a C program, what causes "Segmentation fault"? ;P
17:50:34 <kmc> sshc, this smells to me like lazy IO gone wrong
17:50:34 <monochrom> i'm running a java program and I still get "hClose: illegal operation (handle is finalized)"
17:51:00 <kmc> impressive
17:52:38 <Aeswwer> what tutorials/books can people recomend for understanding the zen of haskell
17:52:41 <alexyk> I get the same in any language!  print "hClose..."
17:52:47 <Aeswwer> good excercizes
17:52:59 <sshc> kmc: I could explain to you what a segfault is and what can cause it, even though there are plently of causes, but I'm still pretty clueless.
17:53:02 <kmc> Aeswwer, what do you mean by "the zen of haskell"
17:53:28 <kmc> Aeswwer, what do you know already?
17:54:19 <Aeswwer> using haskell the way its ment to be
17:54:35 <kmc> ok
17:54:39 <Axman6> Aeswwer: http://blog.tmorris.net/20-intermediate-haskell-exercises/ not sure if this helps, but i found it useful
17:54:41 <kmc> that's an interesting and evolving thing
17:55:09 <kmc> we really do need to know your current skill level before we can recommend resources
17:55:33 <monochrom> tonight is night of vagueness competition
17:56:02 <monochrom> "hi what is the latest cool thing about hClose?"
17:56:29 <aavogt> handle closures!
17:57:13 <sshc> What causes hClose to fail with "illegal operation (handle is finalized)"?
17:58:04 <aavogt> sshc: have you hGetContents'd?
17:58:10 <sshc> aavogt: Yes.
17:58:26 <sshc> I'm not calling hClose directly.
17:58:41 <sshc> It's apparently hClose that is crashing, because of the error message.
17:58:47 <aavogt> then you can't close the handle since hGetContents does it (at some unknown time in the future)
17:59:00 <kmc> did you try ghci debugger?
17:59:10 <kmc> it can sometimes give stack traces for exceptions
17:59:27 <Aeswwer> dont worry about being to advanced
17:59:40 <aavogt> grepping sources has been more helpful in my experience
17:59:58 <aavogt> kmc: the ghci debugger can't step through compiled (with -O or something) code
18:00:01 <kmc> Aeswwer, i'm not going to give you any advice until you give me some indication of your present skill level
18:00:16 <c_wraith> Err.  I have a type signature "kindaLift :: (m a -> n a) -> X m -> X n", and it's telling me that "a" is a rigid type variable when I try to apply the function passed in.
18:00:31 <kmc> if you don't want to that's cool, i'm sure others will help you
18:00:40 <c_wraith> Why does it think a is a rigid type variable?  I think it's polymorphic...
18:00:40 <xcthulhu> Hey, does anyone know if there's a cool embedding of a fragment of the lambda calculus into the BCK combinator algebra?
18:00:48 <xcthulhu> Or linear logic.  Either one is cool
18:01:00 <monochrom> (forall a. m a -> n a) -> X m -> X n
18:01:02 <aavogt> because m and n fix it
18:01:08 <Aeswwer> come on I want to see some alien technology
18:01:24 <kmc> c_wraith, perhaps you wanted the rank-2 type (forall a. m a -> n a) -> X m -> X n ?
18:01:39 <c_wraith> monochrom, I tried that, and...  Then it told me that m and n were rigid type variables.
18:02:25 <kmc> Aeswwer, http://www.reddit.com/r/haskell/
18:02:26 <aavogt> X is kind  (* -> *) -> *
18:02:30 <monochrom> then it is safe to bet your code makes no sense
18:02:31 <kmc> most interesting Haskell links end up here sooner or later
18:02:46 <eugenn> @quote reach
18:02:46 <lambdabot> dons says: ihope reaches level 4 hacker
18:03:47 <xcthulhu> Right.  No love for the BCK or BCI combinators in #haskell :(
18:04:47 <c_wraith> Oh, I wasn't looking at line numbers.  It was complaining about a different line
18:04:59 <monochrom> haha
18:05:15 <monochrom> just add moar "forall"
18:05:17 <ddarius> xcthulhu: We use them all the time.
18:05:33 <monochrom> no, don't add blindly, you should reason it out
18:06:04 <c_wraith> monochrom, I clearly needed it in another function with almost the same type signature...  But that didn't change the error message.  hmm
18:07:42 <c_wraith> mutually recursive functions with rank2 type. yay.
18:07:46 <kmc> hehe
18:07:59 <monochrom> > let {f :: (a->a) -> (Bool, ()); f g = (g True, g()) } in f id  {- this errs -}
18:08:01 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
18:08:01 <lambdabot>         against inferred type ...
18:08:09 <ddarius> xcthulhu: BCK would be affine.  At any rate, googling will find you want you want.
18:08:12 <monochrom> > let {f :: (forall a. a->a) -> (Bool, ()); f g = (g True, g()) } in f id  {- this is ok -}
18:08:13 <lambdabot>   (True,())
18:08:34 <monochrom> If you know why forall is needed here, you're ready.
18:09:01 <monochrom> Your kindaLift is likely doing something along the same line.
18:09:16 <Cale> B is composition (.), C is flip, K is const
18:09:16 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:33 <kmc> that's a complete basis?
18:09:37 <ddarius> kmc: No.
18:09:45 <c_wraith> I can see why those need forall where they do, and why my code does too.  I don't see why it still doesn't compile.
18:09:46 <Cale> Also need W x y = x y y
18:10:14 <xcthulhu> ddarius, Really?  I can't really find anything...
18:10:17 <kmc> and this has something to do with substructural logic?
18:10:19 <Cale> which is join
18:10:47 <ddarius> kmc: Yes.
18:10:54 <Cale> So, all those functions are hanging around :)
18:11:00 <monochrom> perhaps things just get more complicated in practice
18:11:15 <kmc> indeed they are some of @pl's favorites
18:11:18 <xcthulhu> kmc, BCK is not a complete basis.  And yeah, this has to do with substructural logic
18:11:53 <Cale> I think that B, C, K, W are terrible names.
18:11:55 <kmc> C and K are structural axioms?
18:12:01 <Cale> Well, K is all right
18:12:08 <Cale> K for Konstant
18:12:37 <ddarius> xcthulhu: http://research.microsoft.com/~gmb/Papers/thesis.pdf
18:12:52 <Cale> But who uses B for composition?
18:12:58 <ddarius> Cale: Germans.
18:13:10 <geheimdienst> Bomposition
18:13:10 <xcthulhu> It's sort of complicated, but I am developing an Isabelle/HOL theory system for hilbert style axiom systems for various logics, and the pithiest way to prove thing in these systems is to give programs and convert to combinators
18:13:39 <xcthulhu> BCI is a nice calculus because it's the simplest system I can think of that has the deduction theorem
18:13:50 <aavogt> http://www.dict.cc/deutsch-englisch/befolgen.html maybe?
18:14:25 <ddarius> That thesis that I linked xcthulhu to might actually discuss some of these naming questions as well.
18:14:44 <xcthulhu> ddarius, sweet.  You the man
18:15:13 <kmc> this is like how every CS student learns that the operations on semaphores are P and V which stand for Dutch words
18:15:19 * xcthulhu feels bad now for doubting #haskell
18:15:28 <kmc> but they don't generally learn that Dijkstra made up the word for P
18:16:02 <Axman6> heh
18:16:43 <derdon> wow, still some geeks awake =)
18:16:44 <xcthulhu> kmc, Some of the names for the combinators date all the back to Schoenfinkel.  I recall that B stands for something German.  Other combinators are due to Curry
18:16:55 <Cale> xcthulhu: What role would C play in the deduction theorem?
18:17:16 <derdon> xcthulhu: correct. B is for "Bratwurst"!
18:17:28 <kmc> i really wish that instead of "currying" we'd ended up with the term "sch√∂nfinkelization"
18:17:39 <c_wraith> monochrom, kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26691#a26691
18:17:45 <kmc> @let sch√∂nfinkelize = curry
18:17:46 <lambdabot>  Defined.
18:17:51 <kmc> @let unsch√∂nfinkelize = uncurry
18:17:52 <lambdabot>  Defined.
18:18:16 <xcthulhu> Cale, C's type postulates transitivity for ->
18:18:32 * BMeph prefers F to K...
18:18:47 <Cale> xcthulhu: Isn't that B?
18:19:12 <xcthulhu> Cale, Hehe.  You're right.
18:19:38 <xcthulhu> C allows for one to permute hypotheses
18:19:39 <Cale> B is composition, I is identity, together, you have a category-like setup
18:20:27 <kmc> c_wraith, can you boil this down some more?
18:21:01 <c_wraith> kmc: Not without creating a brand new example.
18:21:09 <kmc> that's often valuable
18:21:34 <xcthulhu> Cale, the deduction theorem, at least the one that I tend to like, asserts that "Gamma u {p} |- q <==> Gamma |- p -> q"
18:21:44 <c_wraith> I don't write type constructors that take kinds other than * of my own free will, anyway. :)
18:21:49 <Eduard_Munteanu> > unsch√∂nfinkelize map
18:21:50 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b, [a]) -> [b])
18:21:50 <lambdabot>    arising f...
18:21:54 <xcthulhu> C's type is "(p -> q -> r) -> (q -> p -> r)"
18:21:56 <Eduard_Munteanu> :t unsch√∂nfinkelize map
18:21:57 <lambdabot> Not in scope: `unsch'
18:21:57 <lambdabot> Not in scope: `??'
18:21:57 <lambdabot> Not in scope: `nfinkelize'
18:22:10 <kmc> boo :t
18:22:11 <Eduard_Munteanu> Anyway, that would've sucked.
18:24:11 <kmc> c_wraith, or you could describe what you're trying to do
18:24:24 <kmc> does a rank-2 type make sense intuitively?
18:24:26 <xcthulhu> Cale, So the C combinator allows you to extract a very rudimentary sequent calculus from your axiom system, using multi-sets
18:25:34 <c_wraith> kmc: yes, a rank 2 type makes sense.  I'm trying to write a function that converts a TemplateState m to a TemplateState (t m) for so monad transformer t.  But with slightly more general types.
18:25:51 <kmc> ah
18:26:00 <kmc> so ¬´liftTS lift¬ª would be the one specialized to transformers?
18:27:04 <kmc> TemplateMonad is itself a monad transformer?
18:27:06 <c_wraith> Yes
18:27:37 <c_wraith> I don't really understand the data types.  I'm just trying to work with what's there.
18:30:00 <c_wraith> I'm currently working on a greatly simplified example
18:33:01 <kmc> me too
18:33:07 <kmc> i'm starting to understand it
18:33:40 <c_wraith> well, I got a totally different error I don't understand from a simple case. :)
18:33:43 <c_wraith> let me paste that
18:34:15 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26693#a26693
18:34:27 <kmc> yeah i get something like that too
18:35:32 <kmc> i have a feeling that somewhere you'll need a ¬´forall a. n a -> m a¬ª
18:35:51 <kmc> since X is used in an argument position within Y
18:36:11 <ddarius> BMeph: You getting corrupted by that seditious Jay?
18:37:24 <c_wraith> kmc: my mental model must be missing something, because it looks reasonable to me...
18:37:41 <BMeph> ddarius: No...but I'd like to be! :)
18:38:04 <kmc> so liftY gets a ¬´Y m¬ª and must return a ¬´Y n¬ª
18:38:18 <djahandarie> It has to return it? ;-)
18:38:31 <kmc> a ¬´Y m¬ª takes an ¬´X m¬ª, and a ¬´Y n¬ª takes an ¬´X n¬ª
18:38:56 <kmc> so the ¬´Y n¬ª returned by liftY must itself be able to take an ¬´X n¬ª
18:39:15 <kmc> then it has to pass that to the original ¬´Y m¬ª, which wants an ¬´X m¬ª
18:39:35 <kmc> so you have to convert ¬´X n¬ª to ¬´X m¬ª
18:39:56 <c_wraith> Oh.  That makes a semblance of sense.  let me read it a few more times.
18:40:39 <c_wraith> yeah, I see it now
18:40:41 <BMeph> That reminds me of mapCont...
18:40:46 <c_wraith> thanks for explaining it
18:40:56 <BMeph> ...or is it Cale that reminds me of it? ;)
18:40:59 <Eduard_Munteanu> Well, of course forall a. x a -> ... can take x x a
18:42:56 <aavogt> you mean   x (x a) ?
18:43:11 <Eduard_Munteanu> aavogt: yes,
18:43:43 <Eduard_Munteanu> s/,/./
18:45:56 <kmc> c_wraith, so something like this maybe: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26693#a26694
18:46:50 <kmc> basically, when types appear in argument positions, conversions and subtyping and everything else tends to go the opposite way
18:47:04 <kmc> which is called "contravariance"
18:47:40 <kmc> this is related to the question of why rank-2 types themselves are more powerful than rank-1 types
18:47:45 * BMeph wonders if it's too late to convince the HASP folks to rename Habit as "Brooks", thus making three programming languages named for Curry!
18:47:59 <kmc> which is that polymorphism has a dual meaning in a contravariant position
18:48:08 <kmc> dual to the covariant meaning
18:51:13 <kmc> what i called "Iso" there is actually the definition of equivalence of predicates
18:51:36 <kmc> and i probably should have called name fl as "sym", being one third of the proof that it's an equivalence relation
18:51:41 <Eduard_Munteanu> Hm, I'm just reading on rank 2 types, isn't 'forall' implicit?
18:52:03 <kmc> any variables not otherwise quantified get an implicit forall at the very outside of the type
18:52:07 <kmc> which is rank-1 polymorphism
18:52:29 <kmc> rank-2 lets you write types like ¬´(forall a. a) -> ()¬ª
18:52:34 <mtnviewmark> is   map fromEnum [a..b]   guaranteed to be equal to   [fromEnum a .. fromEnum b]  ?
18:52:36 <kmc> which is not the same as ¬´forall a. (a -> ())¬ª
18:52:49 <kmc> which is itself equivalent to the Haskell98 type ¬´a -> ()¬ª
18:53:15 <aavogt> > map fromEnum [1.1 .. 9] == [fromEnum 1.1 .. fromEnum 9]
18:53:16 <lambdabot>   True
18:53:17 <kmc> a function with a rank-2 type is a function which demands that one of its arguments is itself polymorphic
18:53:25 <anode> I'm realy getting into algorithms :)
18:53:43 <anode> graphing especially
18:54:06 <Eduard_Munteanu> kmc: well, if you write f :: a -> b, isn't the argument polymorphic?
18:54:18 <Eduard_Munteanu> Though the theorem isn't true. :/
18:54:27 <kmc> no, you can instantiate that for example to Char -> Bool
18:54:35 <kmc> in which case the argument is monomorphic
18:54:37 <aavogt> mtnviewmark: that doesn't have to be the case for an arbitrary Enum instance
18:54:51 <Eduard_Munteanu> kmc: ah. I see.
18:54:51 <kmc> ¬´forall a. Maybe a -> ()¬ª will accept Nothing, Just 3, or Just 'x', but ¬´(forall a. Maybe a) -> ()¬ª will only accept Nothing (and various undefined values)
18:55:17 <xcthulhu> Eduard_Munteanu, It is.  However, things like "fst :: (a,b) -> a" are not polymorphic is the sense of "a -> b"
18:55:17 <kmc> because the function demands that its argument has type ¬´Maybe t¬ª for *all* t, not just some specific one
18:55:30 <mtnviewmark> well, I realize that one could define such a Enum instance - I'm just wondering if the report requires that as an "Enum law"
18:55:53 <Eduard_Munteanu> kmc: oh, so you mean '(forall a. a) -> ()' is some sort of '-> ()' with one argument.
18:56:14 <kmc> ¬´(forall a. a) -> ()¬ª is a type of the form ¬´T -> ()¬ª
18:56:22 <kmc> for T = ¬´forall a. a¬ª
18:56:34 <ddarius> A good way to understand these things is to make the type abstraction/application explicit.
18:56:53 <Eduard_Munteanu> Hm.
18:57:24 <mtnviewmark> default for enumFromTo in Prelude is enumFromTo x y   =  map toEnum [fromEnum x .. fromEnum y]
18:57:24 <kmc> ¬´(forall a. a) -> ()¬ª demands that the caller provide a fully polymorphic value
18:57:28 <mtnviewmark> > enumFromTo x y   =  map toEnum [fromEnum x .. fromEnum y]
18:57:29 <lambdabot>   <no location info>: parse error on input `='
18:57:37 <ddarius> A good way to get an intuitive understanding of why certain higher-rank/existential types have the effect that they do is to consider the types from a game theoretic perspective.
18:57:41 <kmc> ¬´forall a. (a -> ())¬ª allows the caller to choose any specific type 'a' that she likes
18:57:43 <mtnviewmark> but I suppose it could be overridden
18:57:46 <Eduard_Munteanu> kmc: oh.
18:58:03 <ddarius> (Also helps understand contravariance, and particularly contravariance's effect on types.)
18:58:20 <Eduard_Munteanu> kmc: so this really matter when you have another polymorphic function as the caller.
18:58:30 <kmc> not necessarily
18:59:12 <kmc> it's a difference between "for any t, i'll give you a function that works on t", and "here's a function that works so long as your *arguments* don't depend on t"
18:59:22 <Eduard_Munteanu> ddarius: I attended a talk on such stuff, although I'm not really into it.
18:59:45 <kmc> with rank-2 types we allow a function to demand that its argument is polymorphic, perhaps is a polymorphic function
19:00:18 <ddarius> kmc: Another way to look at it is: (forall a. a) -> () means the function gets to choose a and forall a. a -> () means the caller gets to choose a.
19:00:23 <kmc> yeah
19:00:43 <Eduard_Munteanu> :t id id
19:00:44 <lambdabot> forall a. a -> a
19:01:39 <kmc> Eduard_Munteanu, let's say i'm writing an interpreter for a dynamically typed language
19:01:43 <Eduard_Munteanu> I'll need to read up a bit more on that page.
19:01:49 <kmc> and i'd like to make a list of all the Haskell numerical operators that i want to expose to my language
19:01:59 <dolio> And (exists a. a) -> () means the caller gets to choose an a, and exists a. a -> () means the function gets to choose an a.
19:02:13 <ddarius> dolio: Indeed.
19:02:15 <aavogt> @type let f :: (forall a. a -> a) -> b -> b; f x = x x x in f id
19:02:16 <Eduard_Munteanu> kmc: yes...
19:02:16 <lambdabot> forall b. b -> b
19:02:45 <Eduard_Munteanu> aavogt: oh!
19:02:55 <ddarius> The duality between exists and forall is especially intuitive, in my opinion, from the game theoretic perspective.
19:03:05 <Eduard_Munteanu> I think I get what aavogt means.
19:04:04 <aavogt> ddarius' suggestion is good. I don't think that explanation comes up often... but Rank2Types don't either
19:04:12 <kmc> or rather let's say i want to write evalOp :: Op -> Value -> Value -> Value
19:04:29 <kmc> which takes one of these Haskell numerical operators and applies it to my dynamically typed values
19:05:11 <kmc> we can't expand that type as ¬´forall a. (Num a) => (a -> a -> a) -> Value -> Value -> Value¬ª
19:05:34 <kmc> because you could call that function with e.g. ((/) :: Double -> Double -> Double) as the first arg, and yet one of the Values turns out to wrap an Int
19:05:51 <kmc> you want evalOp to require that its argument is itself polymorphic over all numerical types
19:06:15 <aavogt> maybe examples are clearer if the application doesn't mean you need some indirection to get  `exists'
19:06:15 <kmc> hence, evalOp :: (forall a. (Num a) => a -> a -> a) -> Value -> Value -> Value
19:06:35 <aavogt> oh, I misunderstand
19:06:39 <kmc> this example is a bit involved, but it's one of the occasions where i've run into rank-2 types, outside of standard library modules that already use them
19:07:25 <aavogt> code that is polymorphic in things like MonadIO m =>    can use rank-2 types if you want to put values containing that type in some data
19:07:30 <Eduard_Munteanu> kmc: I think I understand it.
19:07:34 <kmc> cool :)
19:07:37 <ddarius> It's easy to get higher rank types with home-brew first-class module systems.  Indeed, this is essentially what happens with constructor classes.
19:07:41 <Eduard_Munteanu> kmc: thanks.
19:08:09 <aavogt> so that you can liftIO where you put the value in the record, rather than taking it out
19:30:01 <mtnviewmark> memoizing lists is brain twisting!
19:30:18 <mtnviewmark> even though I wrote it - I still can't quite believe it works
19:44:50 <Lajla> alexyk, will you help me write a Scheme compiler in Haskesp?
19:45:48 <soupdragon> what is Haskesp
19:46:29 <Lajla> soupdragon, haskell written in S-expressions
19:46:36 <soupdragon> ewwww
19:46:39 <Lajla> I guess they thought Shaskell sounded stupid.
19:46:45 <Lajla> soupdragon, you dare to defy S-exprssions?
19:46:48 <Lajla> What is this blasphemy!
19:46:49 <soupdragon> the idea sounds stupid no matter what you call it
19:46:51 <geheimdienst> shaskell shmaskell
19:46:55 <soupdragon> I think s-expressions are brillian
19:46:56 <Lajla> It is the ultimate way to describe program flow.
19:46:57 <soupdragon> t
19:47:05 <soupdragon> Lajla; check this out
19:47:13 <geheimdienst> @remember soupdragon	the idea sounds stupid no matter what you call it
19:47:13 <lambdabot> I will never forget.
19:47:20 <Lajla> soupdragon, sure.
19:47:37 <soupdragon> hm
19:47:44 <Lajla> You have been logged by the secret service.
19:47:47 <soupdragon> @type liftA2
19:47:48 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:48:32 <soupdragon> (-> (-> (-> ((-> a (-> b c)) (f a)) (f b)) (f c))
19:55:01 <Lajla> soupdragon, it is not an S-expression
19:55:08 <soupdragon> what
19:55:27 <sshc> > printf "%d" (3::Integer)
19:55:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:55:32 <lambdabot>    `GHC.Show.Show a'
19:55:34 <lambdabot>      a...
19:55:46 <Lajla> soupdragon, it is not.
19:55:48 * sshc looks up documnetation
19:56:04 <soupdragon> k
19:56:06 <Lajla> soupdragon, any way, Shaskell sounds like a pretty good idea.
19:56:12 <Lajla> Haskell in S-expressions -> macros.
19:56:18 <Lajla> All languages should adopt it.
19:56:26 <Lajla> It makes code so transparent and readable.
19:56:35 <soupdragon> sorta gave up when you went with "that's not an S-expression.. NO ITS NOT"
19:57:35 <Lajla> soupdragon, well, (-> a b c) would be enough
19:58:21 <Lajla> In fact (-> (-> a b c) (f a) (f b) (f c)) would be umambigous
19:59:08 <soupdragon> yeah don't let me get you down I was just saying my opiniono
19:59:40 <Lajla> soupdragon, but where do you stand on the issues?
19:59:42 <Lajla> Tax cuts?
20:00:08 <soupdragon> yeah truth is I have no freaking clue what you meant by "that's not an s-expression" and don't really want to press the issue incase you get irritated with me
20:01:39 <BoyTito> would ya'll be able to clarify what \x -> x 'a' means?
20:01:41 <Lajla> soupdragon, I would never.
20:01:59 <Lajla> BoyTito, it's a lambda abstraction
20:02:08 <soupdragon> BoyTito, it is a function which takes a function as its parameter and feeds the single character 'a' into it
20:02:14 <Lajla> It's basically 'the function that takes a single argument, and returns that argument applied to the character 'a'.
20:02:33 <Lajla> soupdragon, my explanation also gave the return value of the function
20:02:37 <Lajla> That means that I wn
20:02:40 <Cale> > (\x -> x 'a') toUpper
20:02:40 <Lajla> Victory is mine. \o/
20:02:41 <lambdabot>   'A'
20:02:45 <BoyTito> so I would need to feed an argument into that only takes the argument 'a'?
20:02:52 <soupdragon> Lajla  that meant to be funny or something
20:03:05 <BoyTito> ohhh
20:03:08 <Cale> > (\x -> x 'a') fromEnum
20:03:09 <Lajla> BoyTito, well, that can take the argument 'a'
20:03:09 <lambdabot>   97
20:03:10 <BoyTito> thank you so much
20:03:14 <Gracenotes> it can even take many options, the first of which is 'a'
20:03:25 <Gracenotes> and do partial application. it makes no difference to the function
20:03:28 <Cale> > (\x -> x 'a') (:"bcd")
20:03:29 <lambdabot>   "abcd"
20:03:36 <Cale> > (\x -> x 'a') (:) "bcd"
20:03:37 <lambdabot>   "abcd"
20:03:55 <Lajla> > (\x -> x 'a') (: " string")
20:03:56 <lambdabot>   "a string"
20:04:01 <BoyTito> so if i were to say (\x -> x 1) then it would be a function that took in numbers instead?
20:04:05 <Cale> yeah
20:04:11 <Cale> :t (\x -> x 'a')
20:04:12 <lambdabot> forall t. (Char -> t) -> t
20:04:14 <Cale> :t (\x -> x 1)
20:04:15 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
20:04:29 <Gracenotes> you could also write it as ($1) and become a rich man
20:04:51 <Gracenotes> er. that's just a shortcut of notation though.
20:05:10 <alexyk> what gives CPU time of the process execution?  so I can benchmark when certain points are reached?
20:05:12 <BoyTito> oh nice
20:05:25 <Lajla> alexyk, help me with my compiler.
20:05:29 <Lajla> I will hug you for it.
20:05:46 <alexyk> Lajla: I have other fish to fry at the moment...
20:05:58 <Lajla> alexyk, then fry and eat me.
20:06:14 <Lajla> For to live I cannot without thee at my side!
20:06:40 <Lajla> O alexyk, whenever I yonder and yeak towards the stars, I dream of nothing but for thee to be mine.
20:06:57 <alexyk> Lajla: flattering as it is, there's enough Dutchmen/women to fill that elevated position!
20:07:21 <Lajla> alexyk, how'd you know I'm Dutch?
20:07:30 <alexyk> Lajla: it shows, doesn't it?
20:07:41 <Gracenotes> +1 for using thee in the objective case, although it's informal
20:07:51 <Lajla> Gracenotes, and intimate.
20:07:56 <Lajla> As I would address a lover.
20:07:57 <Gracenotes> oh my
20:08:02 <Lajla> I know my shit.
20:08:08 <alexyk> "yeak"
20:09:11 <alexyk> fleaks and yeakc
20:09:27 <Lajla> O alexyk, why art thou far from me, return to me, to where thine heart forever longs.
20:10:22 <alexyk> Lajla: aren't you supposed to be holding the dykes with all your fingers?
20:10:44 <Lajla> alexyk, Nah, they're quite slender.
20:10:44 <Gracenotes> wh
20:11:12 <alexyk> Lajla: saving the lower lands?
20:11:34 <Lajla> alexyk, ja eik√∂ ole sun pakko puhua suomea mulle?
20:11:42 <Lajla> alexyk, they do fine without me.
20:11:51 <Lajla> Besides, I just live here.
20:11:54 <Lajla> Wasn't born here.
20:12:28 <kmc> s-exprs don't describe program flow at all
20:12:32 <kmc> not by themselves
20:13:46 <kmc> you have to know what all the special forms mean for your particular language (CL, Scheme, other Lisp flavors, etc.)
20:14:07 <kmc> people say Lisp has almost no syntax -- well, it's true, if you consider it a language for describing cons cells rather than programs
20:14:44 <Lajla> kmc, you also have to know what functions mean.
20:14:56 <Lajla> The trick is that technically the program defines its own environment at the top level.
20:14:58 <Lajla> Or at a lower level
20:15:15 <Lajla> Essentially all you need to take for granted is 'define', 'if', 'lambda' and 'set!'
20:15:53 <jabb_> are there any good books for designing large projects in haskell, and how to structure it?
20:15:57 <geheimdienst> note to self: do not "just have a look at" #haskell at 5 in the morning. the conversation accumulated there will blow your mind to the high heavens.
20:16:18 <cheater99> kmc: what are s-exprs?
20:16:30 <geheimdienst> jabb_ there was a stackoverflow topic just the other day, let me get that for you
20:16:39 <geheimdienst> http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell
20:17:01 <geheimdienst> should have 2-3 links
20:17:24 <jabb_> thanks
20:17:50 <kmc> cheater99, http://en.wikipedia.org/wiki/S-expression
20:17:58 <cheater99> thanks!
20:18:32 <m3ga> While reading the Arrows paper by John Hughes i came a cross a statement that really struck home "depend on the programmer using an additional combinator similar to Prolog's 'cut' operator do declare that a parser need never backtrack beyond a certain point". Does parsec have something like this?
20:18:52 <sshc> IS there a standard function that returns the index at which x `isPrefixOf` list is True?
20:19:12 <alexyk> so, how do I time when certain points in the execution are reached?
20:20:13 <Lajla> cheater99, they are alpha and the omega.
20:20:50 <Lajla> cheater99, they can do anything despite their simplicity.
20:20:53 <Lajla> They can bake cake.
20:20:58 <geheimdienst> > cake
20:20:59 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:21:09 <sshc> Apparently not.
20:21:38 <alexyk> > bake
20:21:39 <lambdabot>   Not in scope: `bake'
20:21:43 <Lajla> > (\x -> x x)
20:21:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:21:50 <Lajla> I knew it.
20:22:00 <sshc> > genericLength $ concat cake
20:22:01 <lambdabot>   1393
20:22:02 <alexyk> > eat cake
20:22:03 <lambdabot>   Not in scope: `eat'
20:22:14 <geheimdienst> > nom
20:22:15 <lambdabot>   Not in scope: `nom'
20:22:25 <kmc> that's like saying XML can do anything
20:22:35 <sshc> > eat cake
20:22:36 <lambdabot>   "Yum!"
20:22:49 <geheimdienst> how exactly is that possible
20:22:52 <geheimdienst> @undef
20:23:00 <geheimdienst> @unlet
20:23:01 <lambdabot>  Defined.
20:23:03 <c_wraith> > eat "Junkfood"
20:23:04 <lambdabot>   "Yum!"
20:23:05 <geheimdienst> > eat cake
20:23:06 <lambdabot>   "Yum!"
20:23:11 <Lajla> kmc, not as well as S-expressions
20:23:13 <c_wraith> > eat 3
20:23:15 <lambdabot>   "Yum!"
20:23:15 <Lajla> SXML -> XML
20:23:18 <pizza_> > eat eat
20:23:18 <monochrom> plain text file can do anything
20:23:19 <lambdabot>   "Yum!"
20:23:23 <Lajla> It is the alpha and the omega.
20:23:23 <geheimdienst> why was that undefined just a minute ago
20:23:38 <pizza_> > eat undefined
20:23:39 <lambdabot>   "Yum!"
20:23:45 <geheimdienst> :t eat
20:23:46 <lambdabot> forall b. b -> [Char]
20:23:49 <geheimdienst> @src eat
20:23:49 <lambdabot> Source not found.
20:24:13 <geheimdienst> @let nom = eat
20:24:14 <lambdabot>  Defined.
20:24:18 <geheimdienst> > nom cake
20:24:19 <lambdabot>   "Yum!"
20:26:08 <pizza_> @src nom
20:26:08 <lambdabot> Source not found. My mind is going. I can feel it.
20:26:23 <geheimdienst> dude, i defined that just, like, 3 lines up
20:26:50 <FunctorSalad> what exactly is a plain text file in that context?
20:26:52 <pizza_> @dude
20:26:52 <lambdabot> unexpected end of input: expecting number
20:26:58 <sshc> > eat pizza
20:27:00 <lambdabot>   "Yum!"
20:27:06 <geheimdienst> > eat my shorts
20:27:07 <lambdabot>   Not in scope: `my'Not in scope: `shorts'
20:27:08 <kmc> ones and zeros can do anything
20:27:12 <kmc> they are the omega and the alpha resp.
20:27:21 <sshc> @dude 42
20:27:21 <lambdabot> 42 => 42
20:27:37 <pizza_> it all makes sense
20:27:57 <FunctorSalad> kmc: of course. I assumed this must be about convenience :)
20:28:14 <geheimdienst> pizza_, no it doesn't. not on this channel. not at this time.
20:28:15 <sshc> > eat . nom . eat $ pizza
20:28:17 <lambdabot>   "Yum!"
20:28:25 <sshc> > nom . nom . nom $ pizza
20:28:26 <lambdabot>   "Yum!"
20:28:41 <geheimdienst> > pizza
20:28:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:28:54 <geheimdienst> @src pizza
20:28:54 <lambdabot> Source not found. My brain just exploded
20:29:25 <pizza_> @let pizza = pizza
20:29:26 <lambdabot>  <local>:5:0:
20:29:26 <lambdabot>      Multiple declarations of `L.pizza'
20:29:26 <lambdabot>      Declared at: <loca...
20:29:27 <tensorpudding> @src eat
20:29:28 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:29:34 <tensorpudding> > eat
20:29:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [GHC.Types.Char])
20:29:36 <lambdabot>    arising ...
20:29:46 <geheimdienst> who defines all this strange stuff. i just did an unlet and lambdabot already contains all these things again
20:29:47 <sshc> The source of pizza is... finger nail clippings!
20:30:23 <geheimdienst> "a feast is a feast", zoidberg says
20:30:51 <pizza_> > cycle "ni! "
20:30:52 <lambdabot>   "ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni! ni...
20:30:59 <orlandu63> eat and nom are both const "Yum!" i think
20:31:15 <kmc> @nixon
20:31:15 <lambdabot> I can take it. The tougher it gets, the cooler I get.
20:31:24 <kmc> @nixon
20:31:25 <lambdabot> I don't know anything that builds the will to win better than competitive sports.
20:31:26 <geheimdienst> yes but where do they come from? it's not like Prelude has eat defined
20:31:28 <cheater99> what does this mean? GHC +RTS is great for seeing if you're spending too much time doing GC.         i assume gc is garbage collection, but what's rts?
20:31:42 <sshc> geheimdienst: Are you sure?
20:31:44 <geheimdienst> runtime system
20:31:46 <djahandarie> geheimdienst, @let and @unlet are temporarily stored in a file L.hs
20:31:51 <sshc> geheimdienst: I thought they were easter eggs!
20:31:53 <kmc> cheater99, http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html
20:31:56 <kmc> ./myprogram +RTS -s
20:31:59 <djahandarie> geheimdienst, I think those other two are defined elsewhere
20:32:06 <orlandu63> @hoogle eat
20:32:07 <lambdabot> Data.ByteString.Internal create :: Int -> (Ptr Word8 -> IO ()) -> IO ByteString
20:32:07 <lambdabot> Data.ByteString.Internal createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
20:32:07 <lambdabot> Data.ByteString.Internal createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
20:32:12 <orlandu63> @hoogle nom
20:32:13 <lambdabot> Control.Exception.Base noMethodBindingError :: Addr# -> a
20:32:13 <lambdabot> Control.Exception data NoMethodError
20:32:13 <lambdabot> Control.Exception NoMethodError :: String -> NoMethodError
20:32:18 <sshc> :D
20:32:42 <cheater99> thank you kmc
20:32:47 <geheimdienst> cabal install lolcode-dsl
20:33:00 <geheimdienst> then you'll have nom defined
20:35:21 <kmc> "-xc (Only available when the program is compiled for profiling.) When an exception is raised in the program, this option causes the current cost-centre-stack to be dumped to stderr. This can be particularly useful for debugging: if your program is complaining about a head [] error and you haven't got a clue which bit of code is causing it, compiling with -prof -auto-all and running with +RTS -xc -RTS will tell you exactly the call stack 
20:35:21 <kmc> at the point the error was raised."
20:35:25 <kmc> :O did not know this
20:35:43 <aavogt> it's not that helpful, kmc
20:35:53 <kmc> it sounds helpful
20:35:55 <kmc> what's the catch?
20:36:01 <pizza_> > head []
20:36:02 <lambdabot>   *Exception: Prelude.head: empty list
20:36:09 <cheater99> Make sure that your refactorings will cause type errors until complete. << why would i do that?
20:36:25 <aavogt> cheater99: then you know when they are complete
20:36:39 <kmc> typically half-refactored code is broken nonsense
20:36:42 <cheater99> what if they're not complete but don't cause type errors?
20:36:50 <kmc> then it probably doesn't work
20:36:57 <aavogt> kmc: the catch is that you have to compile everything with profiling, and interpreting the output is tricky
20:36:57 <pizza_> then you don't know when you're done
20:36:57 <cheater99> why do i want to avoid that?
20:37:02 <cheater99> ok
20:37:06 <kmc> why do you want to avoid your code not working?
20:37:06 <cheater99> how do i avoid that?
20:37:16 * kmc is confused
20:37:23 <cheater99> kmc: no, what pizza_ said
20:37:42 <kmc> because when you're not done refactoring, your code almost certainly doesn't work
20:37:53 <kmc> (otherwise you'd be done, and ready to start another refactor)
20:38:29 <kmc> it's definitional, if there's a sane working state halfway through, you should consider it two refactorings
20:38:29 <cheater99> we are talking about the hypothetical situation where i am not getting type errors but the code does not work, i.e. it does not do what it did before the refactor
20:38:58 <cheater99> and i asked why i should avoid it, to which pizza_ answered me
20:39:05 <cheater99> and now the question is how to avoid it
20:39:07 <FunctorSalad> cabal: There is no package named lolcode-dsl. Perhaps you need to run 'cabal
20:39:20 <FunctorSalad> geheimdienst fooled us
20:39:24 <pizza_> don't listen to me, i'm just a bot
20:39:43 <FunctorSalad> (I guess that's part of what geheimdiensts do)
20:40:16 <geheimdienst> i made that up. obviously no one in their right mind would actually make or use a package with a lolcode dsl ...
20:40:26 <geheimdienst> oh wait, i would
20:40:38 <kmc> cheater99, maybe you rename a type or constructor first thing
20:40:43 <aavogt> name shadowing is refactoring-safe so long as you never shadow a name that has the same type?
20:40:53 <kmc> and so references to the old names become errors
20:41:09 <ddarius> @hackage speculation
20:41:09 <lambdabot> http://hackage.haskell.org/package/speculation
20:41:39 <kmc> if you have well defined boundaries of an API providing "primitives" and other code using those primitives
20:42:04 <kmc> then if you refactor the API and change its types, you can usually be sure that user code is fully synchronized with the changes if it compiles
20:42:27 <aavogt> I guess not if your 'refactorings' get to change both f and x in   x <- f
20:42:41 <kmc> this mostly works because in Haskell our types are a bit more varied than "void f()"
20:42:59 <kmc> it's also a reason to use newtype/data over type when practical
20:42:59 <aavogt> (changing the pattern being where you change the types where x is actually used)
20:43:01 <ddarius> () -> (), my favorite type
20:43:30 <kmc> it sucks to refactor and have one argument confused with an unrelated argument because they both happen to be represented by Int
20:43:59 <cheater99> what's newtype?
20:44:02 <cheater99> and data?
20:44:16 <kmc> data is how you declare new data types in Haskell
20:44:25 <kmc> you should run into it early in any tutorial
20:44:29 <monochrom> > unsafePerformIO
20:44:30 <lambdabot>   Not in scope: `unsafePerformIO'
20:44:33 <kmc> "newtype" is a special variant of "data" that's more efficient in some cases
20:44:36 <monochrom> fortunately
20:44:37 <cheater99> aha
20:44:38 <kmc> and also has various restrictions
20:44:40 <cheater99> gotcha
20:44:44 <kmc> and slightly different semantics w.r.t undefined values
20:45:05 <kmc> "type" on the other hand just gives a new name to an existing type
20:45:12 <kmc> it creates a transparent synonym, little more than a macro at type level
20:45:24 <kmc> so it provides no additional safety
20:45:39 * kmc wishes for Hugs's scoped type synonyms in GHC
20:46:11 <FunctorSalad> ddarius: why? illustrates the 'undefined' mess?
20:46:44 <ddarius> BMeph: Incidentally, I've never actually gotten around to reading Boquist's thesis.
20:46:55 <Ziphilt> hello all
20:46:57 <FunctorSalad> let's see, we have undefined, const undefined, const (), and \() -> ()?
20:47:04 <kmc> hi Ziphilt
20:47:14 <delusion42> Can someone help me figure out how to derive the type of (fmap fmap fmap)? I can get (fmap fmap) okay, but I'm kinda stuck and am looking for a hint.
20:47:15 <Ziphilt> i was curious if something like variable interpolation was an existing feature in haskell
20:47:37 <kmc> :t fmap fmap
20:47:37 <aavogt> interpolation into strings?
20:47:38 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
20:47:46 <Ziphilt> yes, aavogt
20:48:01 <ddarius> @where haskerl
20:48:01 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:48:17 <delusion42> kmc: so i'm trying to unify f1 (a->b) with (c -> d) -> g c -> g d, i think
20:48:19 <FunctorSalad> PrintfTH is not exactly interpolation, but at least it statically checks number and type of args
20:48:25 <FunctorSalad> (@ Ziphilt )
20:48:32 <kmc> delusion42, so you're applying something of type ¬´g (a -> b) -> g (f a -> f b)¬ª to something of type ¬´(c -> d) -> h c -> h d¬ª
20:48:39 <FunctorSalad> there are a few templating packages in hackage, but haven't used any yet
20:48:42 <aavogt> Ziphilt: there's nothing builtin or in the libraries that come with ghc that's exactly like that
20:48:55 <kmc> yeah
20:49:09 <Saizan> Text.Printf ?
20:49:19 <Ziphilt> hm
20:49:26 <FunctorSalad> why'd you ever use that over .TH except in ghci? ;)
20:49:27 <aavogt> with printf you don't name the variable in the format string
20:49:31 <kmc> so you have to unify ¬´g (a ‚Üí b)¬ª with ¬´(c ‚Üí d) ‚Üí (h c ‚Üí h d)¬ª
20:49:38 <FunctorSalad> (to save typing)
20:49:43 <Ziphilt> i seem to be getting a similar answer to something i asked about some feature in lisp
20:49:46 <kmc> as you said
20:49:47 <Saizan> aavogt: ah, true
20:49:48 <aavogt> FunctorSalad: you can use TH in ghci
20:49:52 <delusion42> kmc: right -- and that's where i'm stuck. can I let g === (->)?
20:49:57 <delusion42> or am i thinking about that the wrong way?
20:50:01 <kmc> close
20:50:06 <FunctorSalad> aavogt: yes, but the non-TH version spares you the $()
20:50:19 <FunctorSalad> (and set -XT...H...)
20:50:20 <kmc> ¬´g = (‚Üí)¬ª would be a kind error
20:50:50 <kmc> so i think the unification you need is ¬´g = (‚Üí) (c ‚Üí d)¬ª
20:50:56 <aavogt> Ziphilt: ghc does have -XQuasiQuotes, which you can get you syntax like     [$int| $x abc ... 123 $ $  $var2 |]
20:51:05 <delusion42> kmc: hmm
20:51:14 <kmc> or if you allow type sections, ¬´g = ((c ‚Üí d) ‚Üí)¬ª
20:51:18 <Ziphilt> ddarius, haskerl still confuses me
20:51:30 <Ziphilt> how much is it a joke and how much is it serious?
20:51:35 <delusion42> kmc: can you say a little bit more about the kind error that would occur? afaik there's no way to actually see kinds e.g. within ghci
20:51:39 <kmc> :k (->)
20:51:40 <lambdabot> ?? -> ? -> *
20:51:46 <delusion42> oh =P
20:51:49 <kmc> it works in ghci too
20:51:58 <kmc> for these purposes, you can pretend that both ?? and ? are *
20:52:11 <kmc> basically (‚Üí) is a 2-ary tycon whereas g is 1-ary
20:52:14 <kmc> being a Functor
20:52:30 <delusion42> ok, i think it's clicking. let me mess around with it a bit more. thanks!
20:52:32 <kmc> :D
20:52:52 <aavogt> Ziphilt: where you, or a library has defined a function from the String inside the | |] to some data that represents haskell syntax
20:52:52 <cheater99> what is an 'algebraic data type' in haskell context?
20:53:27 <Saizan> btw, [$foo| ... |] ~~ $(foo "..."), no? i never realized how simple it is to do without QQs in expressions
20:53:30 <kmc> cheater99, a type declared with "data"
20:53:35 <cheater99> ok
20:53:41 <cheater99> why is it called algebraic?
20:53:52 <kmc> cheater99, "algebraic" refers to the fact that these types are "sums of products"
20:53:59 <Ziphilt> aavogt, maybe it's your wording, but i got nothing out of what you just said
20:54:04 <kmc> consider ¬´data T = Foo A B | Bar C¬ª
20:54:17 <kmc> in certain theoretical contexts we'd write this as ¬´T = (A*B) + C¬ª
20:54:18 <cheater99> i assume you call | a sum there?
20:54:20 <kmc> yes
20:54:22 <cheater99> ok
20:54:32 <aavogt> Ziphilt: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/template-haskell.html#th-quasiquotation
20:54:53 <cheater99> i'd write that T = (AxB) |_| C
20:54:59 <cheater99> probably
20:55:17 <kmc> it's significant that it's a "tagged" or "discriminated" union
20:55:31 <kmc> there are several concepts in programming languages of untagged unions, and each one is different from what Haskell provides
20:55:41 <Ziphilt> aavogt, thanks for trying, i think that stuff is significantly deeper than i can go in haskell, for now at least
20:55:57 <Ziphilt> i hope to learn template stuff some time
20:56:30 <cheater99> i'm not sure what you mean there kmc
20:56:50 <kmc> by curry-howard isomorphism, you can also write it ¬´T = (A ‚àß B) ‚à® C¬ª
20:57:02 <kmc> i mean that if you have a value of type T, you know whether it has a Foo or a Bar constructor inside
20:57:09 <kmc> and you can pattern match out on the two cases
20:57:20 <kmc> which makes it different from the set-theoretical idea of union
20:57:40 <kmc> elements of (A ‚à™ B) don't come tagged with a flag saying whether they came from A or B
20:57:55 <aavogt> Saizan: looks like it. But a big point of [$foo|   is that you don't have to escape the String.
20:58:06 <kmc> C's ¬´union { A a; B b; }¬ª is an unsafe untagged union
20:58:31 <kmc> if you put in an A and take out a B, your program "goes wrong" in the unpredictable way that types are supposed to prevent
20:58:50 <kmc> there are other type systems where there's a safe untagged union
20:59:04 <kmc> meaning that the only operations you can do on ¬´A ‚à™ B¬ª are those which would be valid for either A or B
20:59:17 <kmc> this is a bit like parametric polymorphism, but doesn't have a direct equivalent in Haskell to my knowledge
20:59:25 <cheater99> i don't know what C union is
20:59:33 <kmc> cheater99, it's like struct except the fields share bits
20:59:42 <kmc> so it's only as big as the biggest field
20:59:49 <kmc> if you write to one field it will clobber the others
20:59:53 <cheater99> i used |_| which is a separate-union
21:00:00 <aavogt> safe untagged unions are like typeclasses, no?
21:00:06 <pikhq> It's one of the basic tricks of C polymorphism.
21:00:07 <cheater99> ok, i know what you mean
21:00:11 <kmc> ah
21:00:16 <kmc> right, i forgot about that symbol
21:00:25 <cheater99> square, not round
21:00:29 <kmc> i thought it was just your way of representing ‚à™ in ASCII
21:00:29 <pikhq> aavogt: More like a type with multiple constructors.
21:00:29 <kmc> sorry
21:00:53 <kmc> aavogt, a bit
21:01:02 <aavogt> pikhq: then wouldn't that be taggged?
21:01:04 <kmc> but type classes aren't types, and are open, and other stuff
21:01:09 <cheater99> it's like {i}_1^n x {A_i}_1^n
21:01:40 <cheater99> and then just the ... what's the word
21:01:45 <cheater99> just the diagonal taken.
21:01:47 <pikhq> C's type system doesn't map nicely directly onto Haskell's.
21:02:01 <FunctorSalad> "safe untagged"? 
21:02:08 <kmc> it maps very nicely onto Foreign.C.Types ;)
21:02:20 <alexyk> nobody knows how to measure CPU time??
21:02:24 <FunctorSalad> ok, by knowing statically which it is I guess
21:02:25 <pikhq> kmc: Well, yes.
21:02:30 <kmc> alexyk, can you be more specific about what you want?
21:02:32 <FunctorSalad> (as with tycls'es)
21:02:54 <FunctorSalad> alexyk: /usr/bin/time? ;)
21:03:06 <alexyk> kmc: I think it's quite clear: at certain points in a program record elapsed CPU time of the process.
21:03:29 <kmc> FunctorSalad, by requiring that operations on (A ‚à™ B) are valid for both A and B
21:03:35 <FunctorSalad> ps -p mypid -o etime
21:03:36 <FunctorSalad> or so
21:03:36 <cheater99> what does it mean that you write pure code in haskell?
21:03:37 <kmc> it's discussed in TaPL a bit i think
21:03:44 <cheater99> you don't use monads in your code?
21:03:46 <kmc> cheater99, no
21:03:51 <FunctorSalad> kmc: aha
21:03:52 <kmc> cheater99, maybe that you don't use the IO monad
21:04:00 <cheater99> how do you write non-pure code in haskell?
21:04:08 <cheater99> just IO?
21:04:08 <alexyk> FunctorSalad: rather as a call form within Haskell?  I'm not really eager to chase pids
21:04:16 <kmc> cheater99, you can't really write a non-pure function unless you cheat bigtime
21:04:25 <cheater99> isn't IO such a 'cheat'
21:04:29 <kmc> no cheater99 
21:04:39 <kmc> a function of type ¬´A ‚Üí IO B¬ª is a pure function like any other
21:04:43 <kmc> it returns an IO recipe
21:04:49 <kmc> which may or may not be executed in the future
21:05:20 <kmc> we separate evaluation from execution and in doing so we get purity of essence^Wfunctions, even those which compute how to do IO
21:05:42 <kmc> alexyk, in Haskell you do indeed have to be more specific.  for example, by "points in a program" do you mean evaluation of certain values, or certain steps of execution?
21:06:17 <kmc> are you looking for something like "printElapsedCPUTime :: IO ()", or is it more like "unsafePrintWhenIGetEvaluated :: a -> a"
21:06:30 <alexyk> kmc: steps
21:06:35 <FunctorSalad> alexyk: I'd look in the 'unix' pkg
21:06:40 <dibblego> is there a tool to convert between .hs and .lhs?
21:07:01 <FunctorSalad> but sometimes I'm not sure why I should bother to look up the haskell binding when I already know how to get what I want with rawSystem
21:07:04 <FunctorSalad> except performance
21:07:25 <kmc> alexyk, i'll whip up a little recipe for you, sec
21:08:06 <aavogt> dibblego: ghc can probably be convinced to 'unlit' (the flag having a name something like that)
21:08:17 <dibblego> aavogt, ah right thanks
21:08:21 <kmc> alexyk, can you just use System.CPUTime.getCPUTime?
21:08:51 <alexyk> kmc: if there's such a thing, then sure! :)
21:08:52 <enferex> I have a  myFunc :: Int -> [Int]  The latter basically counts down from Int and returns values for each iteration into an array.  Problem being, how can I recursively do this, when I need to keep passing the list back to the routine.  It seems more like I need to do Int -> [Int] -> [Int]
21:08:55 <kmc> there is
21:08:59 <kmc> alexyk, 
21:09:04 <alexyk> coolcool
21:09:15 <kmc> on Linux it seems to give resolution of 10 ms
21:09:21 <kmc> this is platform dependent but can be checked
21:09:40 <kmc> enferex, maybe you need to define a helper function
21:09:44 <kmc> though i'm confused about what you're doing
21:09:50 <kmc> you could show us your code on hpaste
21:10:23 <FunctorSalad> system "ps -p $PPID -o etime,cmd"
21:10:31 <FunctorSalad> @alexyk 
21:10:31 <lambdabot> Unknown command, try @list
21:10:41 <FunctorSalad> quick and nasty ;)
21:10:51 <enferex> kmc: thanks
21:10:52 <FunctorSalad> the ,cmd is just there for diagnosis
21:11:09 <FunctorSalad> 'system' from System.Process
21:11:39 <alexyk> FunctorSalad: thx!
21:11:48 <kmc> :k (‚Üí)
21:11:48 <lambdabot> Not in scope: type variable `???'
21:11:51 <kmc> :/
21:11:54 <FunctorSalad> alexyk: don't know how robust this is tbh
21:12:00 <kmc> > (\() ‚Üí ()) ()
21:12:01 <lambdabot>   ()
21:12:06 <kmc> :t (\() ‚Üí ()) ()
21:12:07 <lambdabot> parse error on input `???'
21:12:17 <FunctorSalad> (whether $PPID will always be the invoking haskell... just tried it with ghci)
21:12:20 <kmc> seems :t has more trouble with Unicode than @run does
21:13:32 <cheater99> kmc: ok, so when the code is executed it isn't pure then?
21:14:05 <delusion42> kmc: took me a bit, but i grok the type of (fmap fmap fmap) now. thanks again =)
21:14:25 <kmc> cheater99, this isn't a very well-defined question, to me
21:14:43 <kmc> if someone is giving you advice "write pure code" what they probably mean is "avoid the IO monad"
21:14:51 <cheater99> ok
21:14:53 <kmc> i think that's a much clearer way to say it, and i would avoid the former
21:15:02 <kmc> monads in general aren't "impure"
21:15:19 <djahandarie> Is there even a formal definition of pure or side-effect?
21:15:37 <kmc> i mean you can implement the Maybe monad in three lines of bog standard pure Haskell code
21:15:58 <pikhq> djahandarie: Not as such.
21:16:10 <pikhq> It's an intuitive and fairly clear notion.
21:16:43 <kmc> djahandarie, various people have given an operational semantics to Haskell's IO values
21:16:52 <kmc> for example the original Concurrent Haskell paper has formal semantics
21:17:00 <FunctorSalad> djahandarie: a related less vague property is that you can substitute occurences of a value with the RHS of a its definition
21:17:01 <kmc> so that defines what effects are, within a narrow scope
21:17:28 <dolio> People have given precise definitions of "pure".
21:17:35 <dolio> But using IO counts as pure.
21:17:41 <dolio> Arguably, at least.
21:17:52 <kmc> a fairly precise definition of "pure function" is that the return value is determined solely by the input
21:18:00 <kmc> except this ignores side effects that the program can't see, but the programmer can
21:18:35 <tessier> kmc: Just like in algebra. Anyone with high school math should be able to grok that.
21:18:55 <tessier> kmc: Then tell them that functions can operate with more than just numbers as range/domain and you are on  your way.
21:19:02 <kmc> how many high schoolers actually grok algebra?
21:19:11 <monochrom> functions can operate on humans
21:19:13 <kmc> i know that i understood calculus much better having been exposed to higher-order functions previously
21:19:26 <kmc> since differentation and integration are HOFs
21:19:26 <tessier> Anyone who goes on to more advanced maths?
21:19:33 <kmc> tessier, and how many is that?
21:19:48 <tessier> kmc: A lot in my high school. Most people had at least trig by the time they graduated.
21:20:10 <monochrom> are you in russia or something?
21:20:27 <kmc> i think this is not standard for US public schools as a whole
21:20:37 <tessier> Algebra was freshman year. Then geometry IIRC. Then Algebra II. Then trig. AP students took algebra in jr high and bumped everything up and ended with calc.
21:20:40 <Saizan> you mean that trig is not standard material in US high schools?
21:20:44 <tessier> I went to school in Tehachapi, CA
21:20:45 <tessier> USA
21:20:57 <kmc> Saizan, i mean that people don't actually understand it when they're done
21:21:04 <monochrom> there is a gap between "school teaches X" and "people know X"
21:21:18 <Saizan> ah, j
21:21:20 <Saizan> *k
21:21:33 <kmc> one aspect of this is that each year of maths in american school is about 80% a review of the previous year
21:22:08 <monochrom> the more realistic expectation is "I'm so glad the X exam is over! I will now forget everything about it!"
21:22:26 <monochrom> people seriously declare and implement that
21:22:42 <dolio> Yep.
21:23:29 <kmc> yeah
21:23:34 <FunctorSalad> monochrom: I think they just mean 'page it out', not truly 'forget'
21:23:45 <kmc> nobody explains to you why you should actually care
21:23:47 <FunctorSalad> you quickly relearn it if you need to
21:23:57 <kmc> FunctorSalad, that only works if you learned it deeply the first time
21:24:05 <kmc> rather than bumbling through on trial and error
21:24:11 <FunctorSalad> hmm yeah that was what I pictured
21:24:50 <monochrom> people psychologically associate pain with memory of X. they will resist relearning or recalling.
21:25:32 <_Ray_> Hey. Reading a PDF, trying to understand monads. Why is does Set require the things it contains to implement Ord, and is thus not a functor?
21:25:45 <monochrom> just observe your coworkers. "oh no, this project needs algebra! I have forgotten all that! LOL! let's get FunctorSalad to do this part!"
21:25:46 <kmc> _Ray_, because of how Set is implemented
21:25:50 <kmc> as a balanced binary search tree
21:26:24 <_Ray_> Ah :)
21:26:27 <kmc> _Ray_, basically it's difficult to make an efficient container of things which are totally opaque.  you need to be able to compare them, hash them, something
21:26:27 <dolio> Lots of people brag about being bad at math.
21:26:28 <aavogt> because Set isn't a set if there's no way to get rid of duplicates you put in there
21:26:35 <kmc> efficient searchable container, i mean
21:27:02 <_Ray_> Thank you :)
21:27:38 <_Ray_> (I'm reading the Typeclassopedia article on Monad.Reader)
21:27:44 <kmc> that's a good article :)
21:27:56 <aavogt> kmc: I guess the constraint of 'efficient' stops you from putting the duplicate-elimination when you take things out of the set
21:28:43 <kmc> well i'd say anything calling itself a set had better support the "member" predicate
21:28:52 <kmc> and even disregarding efficiency, that right away requires Eq
21:29:12 <kmc> you only need Ord if you care about efficiency, i think
21:29:21 <dolio> Yes.
21:29:25 <kmc> and you can do better with more
21:29:30 <kmc> e.g. a hash trie
21:29:32 <aavogt> kmc: member :: Ord a => a -> Set a -> Bool
21:29:49 <aavogt> without the corresponding constraint on  concatMap
21:30:03 <kmc> yeah
21:30:12 <kmc> since you can use the list monad with Prelude.elem
21:30:18 <kmc> this is in some sense possible
21:31:01 <dolio> You can actually just take Set a = a -> Bool.
21:31:14 <dolio> Then to build sets, you use the decidable equality Eq provides.
21:31:15 <Saizan> if you want to do without constraints on (>>=) or return you can use Codensity Set, but then you'll filter duplicates only at the end, makind the Set part mostly useless
21:41:41 <CuMmYeYeZ> jigaboo jigaboo
21:41:43 <CuMmYeYeZ> where are you?
21:41:51 <CuMmYeYeZ> i standing behind the woodpile watching you
21:41:57 <tensorpudding> @where ops
21:41:57 <CuMmYeYeZ> jigaboo jigaboo come out now
21:41:58 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
21:42:06 <CuMmYeYeZ> "but ize fraid of the mescan man way down south"
21:42:11 <CuMmYeYeZ> you know it, i'll show it
21:42:17 <CuMmYeYeZ> stick your black head out and ill blow it
21:42:21 <_Ray_> So just to get this straight, when I lift a function to some monad, I'm returning a function that does the same, but carries along the context that the monad provides? (In fmap :: (a -> b) -> (f a -> f b))
21:42:27 <CuMmYeYeZ> but the naacp can't keep you away from little old nigger hating me
21:42:34 <CuMmYeYeZ> tired of the negroides?
21:42:36 <CuMmYeYeZ> then join our forum
21:42:42 <CuMmYeYeZ> c h i m p o u t . c o m/forum
21:42:48 <kmc> _Ray_, for sufficient values of "context" yes
21:43:12 <CuMmYeYeZ> i am not racist
21:43:13 <CuMmYeYeZ> i am mexican
21:43:19 <CuMmYeYeZ> c h i mpout is not white supremacist
21:43:22 <CuMmYeYeZ> we are anti-negro
21:43:23 <kmc> hilarious
21:43:27 <CuMmYeYeZ> we welcom all non-negroes
21:43:41 <CuMmYeYeZ> we have jewish mods
21:43:53 <CuMmYeYeZ> and the site is run by people of various human races
21:43:55 <CuMmYeYeZ> chinese
21:43:55 <CuMmYeYeZ> white
21:43:57 <CuMmYeYeZ> japanese
21:43:58 <tensorpudding> (fmap f) is a function that operates operates on the values in a functor without worrying about the actual functor structure, so to speak
21:44:02 <CuMmYeYeZ> we even welcome gay people
21:44:11 <CuMmYeYeZ> join our humanistic alliance against the feral negro beast
21:44:20 <CuMmYeYeZ> c h i m po ut . c o m/ forum
21:45:01 --- mode: ChanServ set +o Heffalump
21:45:07 <kmc> _Ray_, unfortunately i think questions like "is this the right intuition for monads" are not too useful
21:45:11 --- kick: CuMmYeYeZ was kicked by Heffalump (CuMmYeYeZ)
21:45:11 <kmc> you're welcome to ask though
21:45:28 <tensorpudding> Heffalump: if you could be so kind, he's in -blah also
21:45:40 <Heffalump> not sure if I have ops there, but I'll try
21:45:42 <_Ray_> kmc, yeah, I was told today everyone seems to have their own small interpretation of what monads are, to haskell
21:45:44 <kmc> but the answer will usually come down to selecting some word from your intuition (here "context") and requiring that it take on the meaning of "anything defined as part of the monad"
21:46:05 <Heffalump> nope, sorry, I don't
21:46:16 <tensorpudding> oh darn
21:46:57 <Heffalump> looks like there's only 8 people on the list there
21:47:20 <kmc> _Ray_, yeah, you read this article?
21:47:21 <kmc> @where burrito
21:47:21 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
21:47:42 <_Ray_> Ah, nah, but it's the article I was told about, he specifically mentioned a burrito xD
21:48:00 <FunctorSalad> _Ray_: but it may just be a shadow of the knowledge they formed, not really the 'trick'
21:49:22 <kmc> _Ray_, one important thing to see is that the Monad interface by itself is not useful for anything concrete
21:49:35 <kmc> to do anything concrete you need primitives provided by your specific monad
21:49:55 <FunctorSalad> part of it is like motor knowledge, almost (not introspectible or verbally communicable)
21:50:14 <kmc> i think it's very much like most of math
21:50:19 <FunctorSalad> (it=being fluid with a given abstract concept)
21:50:21 <kmc> but people don't expect programming concepts to be like that
21:50:21 <FunctorSalad> mhm
21:50:36 <kmc> when most concepts you encounter in most languages are trivial syntactic variations on things you've seen before
21:51:47 <kmc> and so the class Monad isn't essential to any of the specific uses of monads
21:52:01 <kmc> it's not essential to IO, or to nondeterminism, or to parsing, or to state-passing, etc
21:52:27 <kmc> the reason we have a type class instead of a bunch of unrelated functions is to reuse knowledge, as well as actual code (e.g. Control.Monad)
21:53:25 <_Ray_> ah, interesting :)
21:53:55 <kmc> otherwise you have a language where IO, exceptions, parsing, transactional concurrency, etc. all get their own special case constructs
21:54:00 <kmc> and you have a lot more to learn
21:54:10 <kmc> and that's basically how most languages work, so of course Haskell should be different ;)
22:16:30 <alexyk> is there a way to query the total RAM used by a program at a given point?
22:17:01 <wagle> given a haskell program, with a bunch of imports, how do you figure out where its getting "Para" from?
22:17:49 <cizra> alexyk: top?
22:18:00 <alexyk> from within process
22:19:53 <cizra> alexyk: something in /proc/self/maps?
22:20:09 <alexyk> cizra: hmm, maybe
22:20:28 <kmc> wagle, ghc -ddump-minimal-imports
22:20:28 <cizra> alexyk: Get top source, figure out how it does it?
22:20:33 <kmc> then look at ModuleName.imports
22:20:55 <alexyk> perhaps :)
22:21:10 * kmc learned something today
22:23:13 * pizza_ offset kmc by forgetting something he used to know today
22:23:25 <wagle> unfortunately, i lack easy access to how the plugin is compiled
22:23:54 <FunctorSalad> wagle: or :info
22:24:02 <FunctorSalad> (ghci / ghc -e)
22:24:26 <kmc> oh ghc -e accepts ghci commands?
22:24:27 <kmc> did not know that
22:24:34 <FunctorSalad> :)
22:24:53 <FunctorSalad> you need one -e for each line though
22:26:34 <wagle> FunctorSalad: tried that...  no joy..  its a gitit plugin..  its magic (sufficiently advanced technology wrt to me)
22:26:59 <wagle> i'll poke around for a while
22:28:44 <cizra> I'd very much like this feature in GHC: run it with a certain command line argument, supply a function :: [String] -> [String] in command line, it gets executed with lines of input and output gets dumped to stdout.
22:28:59 <cizra> Ruby has this kind of command-line argument usage.
22:29:05 <cizra> -n or whatever it was
22:29:34 <kmc> yeah that's an old perlism
22:30:18 <kmc> ghc -e 'interact (unlines . f . lines)'
22:30:47 <cizra> *nod* Currently I often avoid Haskell shell scripts, because it's too much trouble to create a file.
22:30:51 <cizra> ghc: on the commandline: unrecognised flag: -e
22:31:16 <kmc> it says that if you give no arg, for some reason
22:31:30 <kmc> but e.g. ¬´ghc -e 'print ()'¬ª should work
22:32:53 <cizra> OK.. next step, can I specify imports on command line? Stuff them to -e?
22:35:19 <kmc> is the name mangling used by GHC documented anywhere?
22:35:31 <kmc> i know preflex can unmangle it but i've never seen docs or source to do so
22:35:41 <kmc> preflex, zdec unixzm2zi4zi0zi0_SystemziPosixziFiles_getSymbolicLinkStatus_closure
22:35:41 <preflex>  unix-2.4.0.0_System.Posix.Files_getSymbolicLinkStatus_closure
22:57:02 <digitteknohippie> anyone know of any existing projects to make an rss newsfeed ticker aggregator application in haskell?  and if not, i'm keen to get started on making one.  methinks my most ambitious project yet, especially since *oogle is being stubborn to help me on this.
22:57:14 <digitteknohippie>  is there an rss newsfeed ticker aggregator application in haskell? 
22:59:11 <cizra> digitteknohippie: Have you checked Hackage?
23:06:18 <digitteknohippie> thnx cizra, i had not, and am now finding loads of leads.  thnx. :)
23:20:01 <kmc> digitteknohippie, sounds like a good project
23:20:57 <kmc> i recommend massive concurrency
23:21:07 <kmc> spawn a thread for every feed you follow; let them sleep most of the time
23:21:14 <kmc> have them all write to a common chan
23:23:25 <kmc> http://book.realworldhaskell.org/read/extended-example-web-client-programming.html is about downloading podcasts
23:23:30 <kmc> which are rss feeds
23:25:02 <jabb_> this doesn't read lines, it just sits there probably being lazy: http://codepad.org/rQMUJyBm :P
23:27:43 <kmc> on my system it tries IPv6 and dies with "connection refused" (because i'm trying to connect to the IPv4 netcat)
23:27:50 <kmc> dunno if this is related to your problem
23:29:39 <kmc> i give it an IPv4 address and it echos until i hit \n twice in a row
23:29:43 <kmc> then it crashes with "init: empty list"
23:31:40 <jabb_> hmm
23:31:45 <jabb_> what are you using?
23:34:20 <Saizan> jabb_: nothing related to lazyness can be your problem there
23:34:28 <Saizan> jabb_: but, are you on windows?
23:35:11 <kmc> i'm on Linux, connecting to netcat as the server
23:35:20 <Saizan> anyhow, i think hGetLine is not doing what you think it's doing due to \r\n vs. \n or similar issues
23:35:20 <kmc> IPv4 to 127.0.0.1
23:35:30 <Saizan> and it probably strips the \n itself
23:36:39 <Saizan> and the ipv6 vs. ipv4 thing is some problem with getAddrInfo iirc, which connects on only one rather than both or something like that..
23:37:09 * Saizan not a network expert
23:40:00 <jabb_> Saizan: changing SysIO.putStr to SysIO.putStrLn make it work
23:40:14 <anode> dude, how is there a package for every sinlgle algorithms known to man in haskell?
23:40:20 <anode> taking all the fun away :(
23:41:01 <jabb_> also setting stdout's buffering to no buffering work
23:41:16 <kmc> anode, do we have Shor's algorithm yet?
23:41:19 <jabb_> works*
23:41:22 <kmc> could use QIO or quantum-arrow
23:42:03 * kmc is continually amused that there is a haskell webapp framework named "salvia"
23:42:56 <anode> kmc: probably... if you take away a lot of stuff that is still being researched, there is a package for almost every algorithm D:
23:42:58 <cheater99> kmc: what are some good haskell webapp frameworks?
23:43:28 <kmc> cheater99, happstack is the most popular
23:43:42 <cheater99> happstack isn't even complete. how can it be popular?
23:43:58 <kmc> don't ask me
23:43:58 <aavogt> complete is arbitrary
23:44:05 <kmc> and "most popular" is relative
23:44:12 <kmc> haskell is not a popular language for web dev
23:44:23 <kmc> snap is new and supposed to be fast
23:45:11 <kmc> there's plenty of others
23:45:22 <kmc> i don't know what's good; it's not my specialty
23:45:36 <cheater99> thanks, i'll have a look
23:46:23 <kmc> i don't think Haskell is a terrible choice for web apps, but i doubt it will ever be popular
23:46:46 <kmc> web companies that want to use FP for fancy backend data processing have had no trouble integrating that with traditional frontends
23:47:27 <kmc> web apps are a perfect setting for using whatever language you want, and often many of them
23:51:38 <cheater99> you've never worked with more complicated web apps then
23:51:40 <cheater99> they are hell
23:51:48 <cheater99> mostly because of side-effects!
23:51:52 <dons> hmm
23:51:53 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:52:04 <cheater99> dons, have you ever used drupal?
23:52:20 <dons> yup
23:52:32 <cheater99> it does absolutely *everything* via side-effects
23:52:36 <cheater99> it's like a magical crackpot
23:52:49 <dons> yup, suxors.
23:53:28 <cheater99> yep :<
23:54:10 <cheater99> hey, if i have a function in haskell, and suddenly i need to pass a variable that's like 5 calls above
23:54:18 <cheater99> is there some automatic way to factor that into the call chain?
23:54:23 <dons> you're doing it wrong.
23:54:29 <Jonno_FTW> ^
23:54:40 <cheater99> i'm coming up with a synthetic problem
23:54:47 <cheater99> i'm not looking at code that does that
23:55:11 <cheater99> just wondering what sort of refactoring possibilities i have with haskell
23:55:20 <byorgey> cheater99: you can take a look at http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
23:55:30 <byorgey> I don't know if it can do that refactoring in particular
23:55:36 <cheater99> thanks
23:55:39 <cheater99> looking
23:56:54 * hackagebot ghc-mod 0.4.3 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.4.3 (KazuYamamoto)
23:57:33 <cheater99> Implementation of our HaRe prototype progresses nicely, and HaRe now supports about a dozen small refactorings such as renaming identifiers, moving/introducing/inlining definitions, and so on. 
23:57:43 <cheater99> why is it that everything in haskell is a prototype?
23:57:51 <cheater99> that's a bit off-putting.
23:58:29 <c_wraith> cheater99, for the most part, things done in haskell are still being done by people who have specific needs, and aren't doing anything more than cursory evaluation of other needs.
23:58:39 <kmc> citation needed
23:58:44 <c_wraith> And they're aware of this, so they label their project a prototype
23:59:02 <kmc> Parsec isn't a prototype.  it's "industrial strength"!
23:59:19 <c_wraith> parsec also isn't the majority of hackage, for instance
23:59:39 <kmc> cheater99, Haskell is aligned both with academia and open source, both communities that emphasize "release early and often" rather than polish
23:59:53 <dons> hence the IHG
