00:00:04 <adnap> *identity
00:00:11 <kmc> * is not a variable
00:00:21 <kmc> * is the name of a specific set of types
00:00:34 <kmc> it's like asking how you say that Int and Int are the same in Int -> Int
00:00:37 <kmc> but, one level higher
00:00:43 <kmc> Int is a set of values (a type)
00:00:46 <kmc> * is a set of types (a kind)
00:00:48 <edwardk> there are other sets of types, that can't be used in places that want a type of kind *. in particular 'unboxed' data types, etc.
00:01:09 <kmc> you may be misled by the use of * as a 'wildcard' in other contexts
00:01:18 <adnap> So, Bool, Int, Char are all types of kind *
00:01:26 <edwardk> adnap: yes
00:01:40 <edwardk> even (forall a. Maybe a)   has kind *
00:01:46 <adnap> Why is Maybe of kind * -> * again?
00:01:48 <kmc> as is (Maybe Int), (Either Char String), (IO Bool)
00:01:50 <edwardk> but Maybe has kind * -> *
00:02:09 <kmc> adnap, because there are no values of type Maybe.  there are values of type Maybe Bool, or Maybe Char, or Maybe (Maybe (Either Char String))
00:02:24 <kmc> so Maybe isn't a type -- it's a constructor which takes a type and gives a type
00:02:27 <edwardk> because Maybe is lonely and needs another type to take care of it and help bear its values.
00:02:47 <adnap> And the values of (Maybe Bool) are (Just True), (Just False), and (Nothing), right?
00:02:52 <kmc> yes
00:03:01 <SubStack> I hate CArrays so much
00:03:05 <kmc> (and some partially-defined values, if you want to get technical)
00:03:06 * SubStack just wants a list already
00:03:16 <adnap> And those are all of another kind, *, right?
00:03:20 <kmc> no
00:03:22 <kmc> values don't have kinds
00:03:24 <kmc> values have types
00:03:26 <kmc> types have kinds
00:03:31 <edwardk> adnap: but without some other type to fill in, even the very quantification that you don't care what that type is, Maybe itself has no values
00:03:35 <kmc> types are sets of values, and kinds are sets of types
00:03:37 <adnap> Er, I meant type!
00:03:52 <kmc> * isn't a type though
00:03:59 <adnap> Wait
00:04:00 <edwardk> adnap: not quite
00:04:11 <edwardk> Maybe Bool has kind *, that is true
00:04:12 <kmc> (Just True), (Just False), and Nothing all have type Maybe Bool.  Maybe Bool has kind *
00:04:18 <SubStack> aha, this other fft library uses regular Arrays, which aren't completely ridiculous
00:04:18 <edwardk> but Just True has _type_ Maybe Bool
00:04:25 <kmc> but it's false to say that Nothing has kind *.  it's not even a well-formed statement
00:04:26 <edwardk> but being a term has no kind
00:04:29 <adnap> If Maybe takes type and produces types, what is an example of a type that maybe produces?
00:04:31 <alexyk> does RTS start a GC at some point which just gets stuck?  I have a huge data mining app which finally started working, then sits pretty at 90% of the data, 100% CPU, no change in RAM
00:04:36 <kmc> adnap, (Maybe Char)
00:04:39 <kmc> is a type Maybe produces
00:04:42 <edwardk> you might see it better like
00:04:44 <kmc> it's an application of Maybe to argument Char
00:04:49 <edwardk> Just True :: Maybe Bool :: *
00:04:55 <adnap> Wait, I think I get it.
00:04:58 <edwardk> where each :: separates a level in the tower
00:05:21 <alexyk> i.e. is GHC's GC suddenly hits you and all stops?
00:05:23 <adnap> Are (Maybe Char) and (Maybe Bool) types of the same kind?
00:05:24 <alexyk> does
00:05:26 <BMeph> SubStack: Just thing of CArrays as mutable, freaky unboxed arrays...STFUArrays! :)
00:05:29 <kmc> adnap, yes
00:05:31 <kmc> *
00:05:34 <kmc> is their kind
00:05:41 <kmc> any type which has values has kind *
00:05:47 <kmc> and * is not a wildcard, or a variable or anything
00:05:50 <kmc> it is a single, specific kind
00:05:52 <adnap> So * is something like Bool or Char, and the other * is something like (Maybe Bool) or (Maybe Char).
00:05:54 <edwardk> adnap: Maybe Char :: *, Maybe Bool :: *, Either Int Char :: *, all have the same kind
00:06:01 <kmc> right
00:06:15 <kmc> well, sort of right
00:07:11 <adnap> What is an example of a type that has kind * -> * -> *.  You said State, right?
00:07:12 <Saizan> in the sense that given Maybe :: * -> *, you can use Char as the unique argument of kind * and you'll get Maybe Char as the result of kind *
00:07:14 <kmc> "Float is something like 4 or 2, and the other Float is something like 2.0 or 1.4142"
00:07:21 <kmc> in sqrt :: Float -> Float
00:07:41 <kmc> it's not true as written -- Float isn't 2, obviously, 2 is one of the elements of Float.  but i think what you meant is correct
00:08:02 <kmc> adnap, Either
00:08:03 <kmc> @kind Either
00:08:04 <lambdabot> * -> * -> *
00:08:09 <kmc> Either takes two types and produces a type
00:08:11 <kmc> @kind Either ()
00:08:12 <lambdabot> * -> *
00:08:12 <kmc> @kind Either () ()
00:08:13 <lambdabot> *
00:08:19 <Saizan> just like with ord :: Char -> Int you can give it 'a' as the argument of type Char, and get back 97 as the result of type Int
00:08:22 <kmc> @kind Either Maybe Char
00:08:23 <lambdabot>     `Maybe' is not applied to enough type arguments
00:08:23 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
00:08:25 <kmc> @kind Either (Maybe Char)
00:08:26 <lambdabot> * -> *
00:08:30 <edwardk> adnap: newtype State (s :: *) (a :: *) = State (s -> (a, s)) -- State has kind * -> * -> *
00:08:51 <kmc> «Either Maybe Char» is a kind error, because Either expects a type of kind * as its first arg, but Maybe has kind * -> *
00:09:01 <adnap> edwardk: I get it!
00:09:14 <edwardk> adnap: congrats =)
00:09:16 <kmc> adnap, here's an exercise.  suppose that «T Maybe Maybe» is a valid type, that has values.  what is the kind of T?
00:09:18 <adnap> edwardk: You have to define the state type, and the value type, right?
00:09:25 <edwardk> adnap yes
00:09:28 <adnap> edwardk: Then you get the State type.
00:09:49 <edwardk> try kmc's exercise =)
00:10:07 <adnap> kmc: (* -> *) -> (* -> *) -> *
00:10:14 <edwardk> adnap: =) good job
00:10:21 <adnap> Woo!
00:10:25 <edwardk> adnap: there are a lot of interesting kinds out there
00:10:32 <c_wraith> @kind RWST
00:10:33 <edwardk> and they do get used
00:10:33 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
00:10:43 <edwardk> @kind StateT
00:10:44 <lambdabot> * -> (* -> *) -> * -> *
00:10:54 <adnap> Man, I'm never going to be "done" learning Haskell! XD
00:10:55 <BMeph> @kind Mu
00:10:56 <lambdabot> (* -> *) -> *
00:10:58 <c_wraith> though edwardk's libs tend to include even more exciting kinds. :)
00:11:18 <edwardk> c_wraith: hah i've never used more than 30 *'s in a single kind!
00:11:21 <c_wraith> adnap, I'm not sure anyone will ever be done learning Haskell. :)
00:11:44 <adnap> c_wraith: I guess I just have to write programs, learn haskell, write programs, learn haskell, etc.
00:11:52 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Functor-HigherOrder-Composition.html has probably the longest in anything public though ;)
00:12:08 <adnap> Normally, I could learn C++, write programs, write programs, write programs, etc.
00:12:14 <Saizan> adnap: yeah, you've to evaluate it lazily
00:13:08 <adnap> Okay, so now let me go back to the newtype State.
00:13:12 <triyo> Morning guys n girls. Anyone seen this error before when strating ghci? ghc: internal error: loadObj: failed to mmap() memory below 2Gb; asked for 724992 bytes at 0x40000000.
00:13:47 <triyo> Looks like a memory address alloc fail
00:14:15 <edwardk> adnap: if you decide you like playing with kinds there are whole languages based on the notion of types of types of types of types of ....
00:14:31 <edwardk> triyo: linux?
00:15:08 <triyo> hehe, in context of ghc, I wish it was linux. Its a Mac OS X 10.6.3 x86_64
00:15:15 <adnap> edwardk: Hm...
00:15:27 <adnap> edwardk: I'm just trying to figure out Monads at the moment.
00:15:31 <edwardk> triyo: you may have just used up all the low memory your system has available, are you running anything particularly intensive?
00:15:33 <triyo> edwardk: I built from source last night
00:16:06 <edwardk> triyo: ah, then good luck. ;) sadly i don't have a mac these days so i'm probably not the right guy to ask
00:16:18 <edwardk> adnap: a noble endeavor =)
00:16:21 <kmc> adnap, actually, I found C++ almost as "deep" as Haskell in terms of stuff to learn
00:16:29 <adnap> edwardk: I also have to read a History textbook, but Haskell is so much more fun!
00:16:53 <kmc> adnap, difference being in C++ you are learning a lot of quirks and to some degree flaws
00:16:59 <edwardk> adnap: combine the two: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf ;)
00:17:00 <kmc> in Haskell you're learning a very deep consistent theory
00:17:07 <adnap> edwardk: lol
00:17:09 <kmc> as well as some quirks in how that theory makes it into a real language
00:17:12 <triyo> edwardk: Its ok, thx. Its about the same answer I got from most of the people on the channel regrading this topic. 
00:17:22 <kmc> anyway C++ was fun to learn but not fun to use.  Haskell is both
00:17:52 <adnap> kmc: I like how when I write Haskell, I end up getting straight to the algorithm.
00:18:10 <kulin> c++ was fun to learn?
00:18:36 <kmc> yeah
00:18:39 <kmc> brainfuck was fun to learn
00:18:46 <c_wraith> haha
00:18:46 <edwardk> adnap: i suppose my favorite part is that i can get right into the algorithm, and say what i want to say, but then the types suggest good directions to generalize the algorithm
00:18:52 <kulin> ive only ever used the bare minimum of c required for classes
00:19:10 <kmc> it's fun to learn how to work in a bizarre restricted environment
00:19:27 <kmc> C++ gives you a lot of opportunities to use those problem-solving skills
00:19:33 <kmc> easy problems become difficult
00:19:37 <kmc> boring problems become challenging
00:19:39 <adnap> edwardk: I also like how easy it is to generalize things compared to other languages.  In other languages, they have things like "Design Patterns" which involve tons of boilerplate.
00:19:44 * edwardk is another strange duck on the channel in that he likes to use C++ when appropriate as well.
00:20:04 <kulin> i would use c if i was writing a driver maybe, i think that is it
00:20:10 <triyo> edwardk: a little search in bug db led me to an existing bug report:  http://hackage.haskell.org/trac/ghc/ticket/3109
00:20:11 <kmc> adnap, Haskell has some of those too... difference being, we don't elevate them to the status of dogma and write books about them ;)
00:20:23 <kmc> Haskell can be pretty boilerplatey compared to very dynamic languages
00:20:36 <kmc> you can't just trivially iterate over the fields of a record and do some runtime type conversion
00:20:40 <edwardk> adnap: in the world of functional programming we have one real design pattern, finding things that other people would call design patterns and boiling them down into some sort of combinator or macro that we can then reuse, so we never have to hear the words 'design patterns' again ;)
00:21:11 <kulin> haskell also has other certain qualities which make it easier to write correct code, such as strong typing
00:21:27 <adnap> edwardk: Yeah, that's cool too.  It's hard to boil a class heirarchy down to a macro in an imperitive language!
00:21:28 <edwardk> in general if you find that you're doing something over and over in haskell, it is a sign of a language or understanding flaw. the former, someone will come along and correct, the latter, is up to you ;)
00:21:33 <Peaker> Linking cabal-install on this laptop has been taking more than an hour, arrg!  Shouldn't have tried to install ghc-6.12.3 today
00:23:56 <adnap> I'm still trying to work on writing C++ programs that use my Haskell functions.  I'm learning this graphics rendering API, which is written in C++, but I want to write all of the underlying logic that determines what will be rendered in Haskell.
00:24:07 <kmc> adnap, Haskell is an imperative language (too)
00:24:16 <adnap> kmc: That's true.
00:24:18 <kmc> and lack of expressiveness isn't some fundamental property of imperative languages
00:24:24 <kmc> it's a design flaw of Java and C++ specifically
00:24:43 <kulin> have you guys used miranda?
00:25:03 <adnap> kmc: I guess the do notation is an example of how you can have expressiveness in an imperitive way.
00:25:14 <ksf> kulin, you forgot to mention that it's a trademark.
00:25:18 <ksf> you will be sued for millions.
00:25:29 <kulin> man that sucks
00:25:32 <adnap> kmc: But the do notation is really sugar for a function representation, so which is it?
00:26:08 <adnap> *functional
00:26:25 <ksf> expressions > statements, in every way.
00:26:50 <Peaker> ksf, Missing instance Ord for Paradigm.
00:27:27 <Peaker> Possible fix: Add the basis for the measurement to the context (IRCChannel #haskell)
00:28:05 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26116#a26118
00:28:18 <ksf> can anybody check than on multicore against the current entry?
00:29:34 <kmc> adnap, the answer is that "imperative programs" are just another of the many data types we use functional programs to manipulate
00:29:52 <kmc> that's the power of Haskell's approach in particular, compared to other functional languages
00:30:18 <kmc> effects aren't a side property of applying functions; they're first-class values themselves
00:30:35 <kmc> this is about much more than just the separation of pure from impure code
00:30:55 <kulin> i dunno about that
00:31:03 <kulin> doMagic :: IO ()
00:31:20 <kulin> the side effect isnt really the value
00:31:26 <kmc> yeah it is
00:31:32 <kmc> doMagic is a recipe for doing something
00:31:34 <kmc> presumably, some magic
00:31:47 <adnap> And you can have a list of magic! [IO ()]
00:31:56 <kmc> yes
00:32:03 <adnap> And map a function over it!
00:32:25 <adnap> map f [IO ()]
00:32:35 <kulin> but its not really like IO>PutRabbitInHat>GetAudience>RemoveRabbitFromHat
00:32:39 <kulin> its just IO ()
00:32:42 <Peaker> (map . fmap) aToB [IO a]
00:33:13 <Peaker> (map . result . fmap) aToB [i -> IO a]
00:33:17 <Saizan> it might be obvious but, can you write a small step evaluator using HOAS?
00:34:01 * ksf doesn't get how needlessly holding on to data is a valid gc benchmark
00:34:45 <kulin> if anything, side effects are like a context that you enter
00:35:36 <ksf> side-effects are exactly what they are, the output of a state transducer.
00:36:13 <kulin> right
00:36:31 <edwardk> i'm debating about the right api for comparing intervals
00:36:44 <edwardk> i'm thinking about providing two sets of ord-like combinators
00:36:58 <edwardk> <! and <? which stand for 'certainly' and 'possibly'
00:37:09 <kmc> kulin, sure, the type of an effect does not tell you everything about the value
00:37:15 <edwardk> and then perhaps exporting two more functions, named certainly and possibly
00:37:16 <kmc> neither does the type Int tell you whether the number is prime
00:37:26 <Axman6> a lecturer of mine and his PhD student are working on interval arithmetic
00:37:59 <kmc> so i stand by my claim
00:38:07 <kmc> but on a practical level, it would be nice if IO were more fine-grained
00:38:23 <c_wraith> ST is a nice start
00:38:24 <kmc> so that you could have better bounds on the particular sorts of effects used
00:38:32 <edwardk> with certainly :: Precision a => (forall b. Ord a => b -> b -> Bool) -> Interval a -> Interval a -> Bool
00:38:50 <edwardk> which would let you say certainly (<=) x y
00:38:55 <kulin> im not sure that monads are a reduction from deciding if an int is a prime
00:38:56 <edwardk> or possibly (>=) x y
00:38:58 <c_wraith> But more splinters of IO that support a subset of the functionality *would* be nice.
00:39:50 <kulin> i defer to your knowledge which is greater than mine, and i love monads, but i think while they are a much superior way of handling side effects than any other language has done so far, they are still a bit of a hack
00:40:07 <c_wraith> have you been reading Conal's writing? :)
00:40:37 <kulin> me? i dont know conal, im a newbie with haskell is all
00:44:31 * ksf can't decide whether to make sockets, files and pipes different types or a sum type
00:44:57 <wli> Sum.
00:45:00 <ivanm> agreed
00:45:16 <ksf> hmm sockets have a lot in common with pipes, but files are kinda different
00:45:23 <ivanm> unless you can envisage some other type of type you may wish to treat in  a similar manner (in which case use different types and a typeclass)
00:45:36 <ivanm> ksf: if they have a lot of common operations, a sum type
00:46:01 <ksf> at the utmost they all have an enumerator and sink function
00:47:10 <ksf> and they're all created in vastly different ways
00:48:54 <kulin> we dont get to define 'deriving' for custom typeclasses?
00:49:00 <ksf> the main differences being whether you can seek them, and whether they can be the start/endpoint of a splice.
00:50:05 <ksf> also, with pipes and sockets fionread makes sense but not with files.
00:51:02 <Saizan> kulin: no, but you can write a TH macro for it, see the "derive" package on hackage
00:53:23 <kulin> oh TH is pretty awesome
01:01:04 <ksf> is it possible to open a file by device id and inode?
01:04:08 <edwardk> ah neat the 'certainly (<=) and possibly (/=) code came together nicely
01:06:28 <byorgey> edwardk: actually, we still haven't worked out the math for that =P
01:06:28 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
01:06:38 <edwardk> heya byorgey
01:06:48 <edwardk> for which?
01:06:52 <byorgey> edwardk: it's extremely non-obvious what to do when dealing with a transformation that doesn't preserve angles
01:06:59 <byorgey> for the functional convex-hull thing
01:07:00 <edwardk> byorgey: =(
01:07:22 <byorgey> maybe I will send you an email later describing what we know to see if you have any ideas
01:07:30 <edwardk> k
01:07:35 <byorgey> but after the Haskell Symposium deadline =)
01:07:40 <edwardk> i ultimately figured out an easier model for what i wanted
01:07:47 <edwardk> but its evil and axis aligned
01:08:46 <byorgey> hehe, I see
01:09:21 <danharaj> what's the problem?
01:09:24 <byorgey> the road to non-compositionality is paved with good intentions =)
01:09:49 <edwardk> another interesting observation there are only 8 well behaved functions of (forall b. Ord b => b -> b -> Bool)
01:10:02 <edwardk> which makes it very easy to pass around those functions and use them like constructors
01:10:16 <Peaker> @src Ordering
01:10:16 <lambdabot> data Ordering = LT | EQ | GT
01:10:24 <edwardk> 2^3
01:10:59 <edwardk> i needed a set of those values, and its nicer to pass (<=) than it is to pass [LT,EQ]
01:11:03 <byorgey> edwardk: neat, what do you use functions of that type for?
01:11:15 <edwardk> possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool
01:11:24 <edwardk> lets me say 'possibly (<=)' 
01:11:35 <edwardk> and similarly 'certainly (/=)'
01:11:45 <edwardk> for when talking about interval arithmetic
01:11:50 <byorgey> ah, cool
01:11:54 <Peaker> What does "possibly" mean?
01:12:18 <Peaker> Isn't every Ord relationship possible unless declared impossible? :)
01:12:27 <ivanm> edwardk: hmmm, (==), (/=), (>=), (<=), (>), (<), const (const True) and const (const False) ?
01:12:36 <edwardk> possibly (<=) x y says that the value which is being abstracted over by the interval x could be smaller than the value which is being abstracted over by the interval y.
01:12:43 <edwardk> ivanm: yeah
01:12:52 <byorgey> danharaj: given a vector space V with scalars S, imagine representing a "functional bouding region" by a function V -> S
01:13:22 <byorgey> danharaj: which, given a vector, tells you how far you have to go along that vector to find a perpendicular hyperplane which completely encloses the region in question
01:13:29 <danharaj> byorgey: 'functional bounding region'? what do you mean?
01:13:36 <danharaj> (d'oh)
01:13:44 <byorgey> =)
01:14:06 <byorgey> the question is how to transform the functional bounding region along with the region itself
01:14:08 <edwardk> Peaker: i'm using intervals to represent uncertainty about some potentially knowable quantity
01:14:21 <byorgey> i.e. if you apply some projective transformation to the region, and you want a new bounding function
01:14:50 <edwardk> which is why i had to go off and write a whole bunch of code to deal with ieee floating point rounding modes, etc. over the last day or so
01:15:08 <edwardk> since i want to round down on the low estimate and up on the high estimate
01:15:20 <edwardk> and properly convolve the two when doing other operations
01:15:23 <danharaj> byorgey: have you solved the problem for simply linear transformations?
01:15:38 <byorgey> danharaj: no
01:15:52 <edwardk> byorgey: the linear case we did on the board at hac-phi
01:16:02 <byorgey> edwardk: it was wrong though
01:16:05 <byorgey> danharaj: it's not hard if you restrict to only uniform scalings, rotations, and translations
01:16:06 <edwardk> oh?
01:16:08 <byorgey> the problem is shears
01:16:15 <byorgey> things that don't preserve angles
01:16:30 <byorgey> the problem is that you want to talk about PERPENDICULAR hyperplanes
01:16:36 <byorgey> but perpendicularity isn't preserved
01:16:44 <danharaj> that is a predicament
01:16:46 <edwardk> ahhh
01:17:13 <edwardk> you're screwed ;)
01:17:22 <danharaj> byorgey: I am not exactly sure what you mean by a hyperplane enclosing a region
01:17:32 <byorgey> edwardk: hehe, thanks for your vote of confidence  =)
01:17:32 <edwardk> you need a better implicit surface rep =P
01:18:00 <edwardk> byorgey: pick up a copy of http://www.amazon.com/Introduction-Implicit-Surfaces-Kaufmann-Computer/dp/155860233X
01:18:02 <byorgey> danharaj: sorry, maybe I should have said that the region lies entirely to one side of the hyperplane
01:18:28 <wli> What kinds of implicit surfaces are going around?
01:18:31 <edwardk> it should give you a laundry list of other implicit surface formulations
01:18:33 <danharaj> byorgey: ah, so the tangent hyperplane to the convex hull at the point where it intersects the argument vector, I guess?
01:18:42 <byorgey> danharaj: yes, exactly
01:19:03 <byorgey> edwardk: ok, thanks for the link
01:19:27 <danharaj> byorgey: (well not exactly, because the convex hull doesn't have to be smooth. Exactly almost everywhere :p)
01:19:38 <edwardk> byorgey: it may not be exactly what you need but it is at least a source i've read through
01:19:48 <byorgey> danharaj: well, sure =)
01:20:22 <edwardk> byorgey: i'm used to things like your shear not being a problem, because we can handle them with things like SDFs
01:20:43 <edwardk> but i guess TANSTAAFL applies
01:21:04 <edwardk> you got a lot of neat properties, the price is giving up shearing and projective transformations
01:21:30 <edwardk> you might be able to get somewhere close using an SDF though
01:21:38 <byorgey> what's an SDF?
01:21:46 <edwardk> signed distance formula
01:22:38 <edwardk> given a point in the space tells you a (potentially conservative) radius from that point to the nearest object.
01:22:45 <danharaj> byorgey: Are you building convex hulls from only finitely many points? Also what other constraints are there on your specification?
01:22:48 <edwardk> it gives you a bubble in which no object lies around your point
01:23:26 <byorgey> danharaj: I'm not really building convex hulls from points at all
01:23:43 <danharaj> oh, where are your surfaces coming from?
01:23:56 <byorgey> danharaj: this is for the new version of the diagrams library, it's for representing bounding regions of diagrams in order to position them relative to one another
01:24:05 <edwardk> if you represented each object as an SDF then to do your composition operation you could go way out on a ray (doubling distances as needed so you can always do it logarithmically), and find a bubble , then pull it in, and do the same for the other side. 
01:24:18 <edwardk> you might need to do some cleanup, etc.
01:24:29 <byorgey> edwardk: hmm, interesting
01:25:04 <edwardk> byorgey: haskell source: http://sebastiansylvan.spaces.live.com/blog/cns!4469F26E93033B8C!173.entry ;)
01:25:22 <edwardk> though i haven't checked to see how sane their SDF implementation is
01:26:46 <byorgey> edwardk: nice, thanks
01:27:35 <edwardk> of course the devil is in the details, getting the algorithm right, etc.
01:27:44 <byorgey> the other possibility is to just ditch shears and projective transformations.  I don't know how much users would miss that.
01:27:54 <edwardk> true
01:27:58 <edwardk> i would be sad
01:28:08 <edwardk> no flashy trees ;)
01:28:15 <byorgey> would you be sad in practice, or in theory?
01:28:17 <byorgey> oh, I see =)
01:28:25 <danharaj> woah, I didn't know about diagrams.
01:28:28 <edwardk> i have a demonstrated use case!
01:28:34 <edwardk> =)
01:31:49 <danharaj> byorgey: are all your diagrams two dimensional, or are there plans for positioning 3d elements?
01:32:12 <byorgey> danharaj: in the new version you can use *any vector space you like* =)
01:32:33 <byorgey> 4d diagrams? no problem!
01:32:41 <danharaj> Don't make me use Hilbert space.
01:33:10 <byorgey> well, you'd need to code up your own primitives and your own rendering backend
01:33:23 <byorgey> but it's nice and modular so that's not hard t odo
01:33:43 <byorgey> but the standard library will definitely provide 2D and 3D primitives at least
01:34:07 <danharaj> Are there plans for a GUI editor that generates diagrams?
01:34:22 <danharaj> That would be sweet I would high five that person however much they want.
01:34:28 <byorgey> hehe
01:35:00 <byorgey> there are definitely plans for a GUI editor where you can edit the diagram code and have it auto-update the diagram in another window
01:35:25 <byorgey> if you mean something that actually lets you manipulate the diagram itself, like inkscape or something, I don't know
01:35:55 <danharaj> well, one step at a time.
01:36:08 <danharaj> Your ideas are way more sensible.
01:36:42 <byorgey> it's an embedded DSL so actually editing the Haskell code itself is the whole point =)
01:38:16 <danharaj> I think I'll have to get diagrams and start playing with it, thinking about your problem.
01:40:27 <ksf> http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html
01:40:32 <ksf> yeah that's how it's supposed to be.
01:44:03 <Peaker> I wish "mtl"/"transformers" were split up to tiny packages for each transformer
01:44:09 <Peaker> then we could have competing implementations of ListT, StateT, etc
01:44:18 <Peaker> without having to dump an entire package for a single broken transformer
01:49:19 <c_wraith> yeah, I'm running into details I don't understand about Hint.  If you tell it to load a module, does it not honor that module's imports?
01:50:59 <Saizan> if the module is compiled it won't bring its imports in the toplevel scope
01:52:08 <c_wraith> hmm.  That's worth noting, but it's not what's going on here.  Not exactly, anyway.  I'm using cabal.  the compiled files are nowhere near the source.
01:52:44 <c_wraith> But...  let me double-check the errors.  You may have given me an idea
01:53:18 <c_wraith> Looks like all the things it's complaining about are the types in the signature of the function I'm trying to execute.
01:53:59 <c_wraith> Do those types need to be loaded?
01:56:41 <c_wraith> This isn't an error I understand...   WontCompile [GhcError {errMsg = "module `Text.Templating.Heist' is a package module"}]
01:58:30 <Saizan> if you're using all the flags obtained by the code i linked to you earlier they also contain paths to the .hi and .o files produced by cabal build
01:58:43 <c_wraith> I'm not using that yet
01:58:52 <akosch> does anyone know a good book to learn php from? (sadly i'm forced to use it in my job)
01:59:04 <Saizan> however i think that error is complaining about you trying to :load a module that it's installed
01:59:48 <c_wraith> Hmm.  I suspect that means I should be passing it in a different way...
02:07:30 <ManateeLazyCat> Hmmm... looks build temporary DBus client is costly, i build "temporary DBus client" when user press key, after 5 seconds testing, it paralysed the DBus system 
02:08:39 * ManateeLazyCat pasted "Build temporary DBus client." at http://paste2.org/get/875655
02:08:50 <ManateeLazyCat> Above code is build temporary DBus client.
02:09:43 <ManateeLazyCat> When user press key, build a new temporary DBus client to send signal, after signal send successful, close connection.
02:11:28 <ManateeLazyCat> So the process like this "key-press -> build client -> send signal -> close client", if user press key always, current process will be paralysis ....
02:18:33 <c_wraith> Anyway, this is the real error I'm trying to figure out how to solve:  WontCompile [GhcError {errMsg = "Not in scope:\n  type constructor or class `Text.Templating.Heist.Types.TemplateState'"},GhcError {errMsg = "Not in scope: type constructor or class `Snap.Internal.Types.Snap'"},GhcError {errMsg = "Not in scope: type constructor or class `Snap.Internal.Types.Snap'"},GhcError {errMsg = "Not in scope: `site'"}]
02:18:51 <c_wraith> That's complicated enough I probably should provide code.
02:19:04 <ivanm> wow
02:22:36 <Twey> ManateeLazyCat: Don't do that, then ;)
02:23:14 <ManateeLazyCat> Twey: I just don't want to use global DBus client.
02:23:49 <ManateeLazyCat> Twey: Before i try this, my previous solution is build *one* DBus client and keep connection. 
02:24:41 <kfmfe04> hi, I just started learning Haskell - how would I write a function that takes [a] and returns [a] where I sum the first 3 elements, and then the next 3, and so on... ...so if I do my3sum [1..5] I should get [6,9,12]
02:25:34 <Twey> kfmfe04: Easiest way is to make use of Data.List.Split.chunk.
02:25:44 <c_wraith> If it's adding elements, it can't just take [a].  There's an extra requirement.
02:25:45 <Twey> f = map sum . chunk 3
02:25:45 <Axman6> well, how do you think you'd start?
02:25:54 <Peaker> no no, he wants   map (take 3) . tails
02:26:02 <Peaker> > map (sum . take 3) . tails $ [1..5]
02:26:03 <lambdabot>   [6,9,12,9,5,0]
02:26:08 <Axman6> Twey: i don't think you're helping the learning process ;)
02:26:09 <Axman6> you too Peaker 
02:26:20 <ManateeLazyCat> [1,2,3,4,5,6,7,8,9] -> [[1,2,3],[4,5,6],[7,8,9]] -> (map sum) 
02:26:22 <Blkt> good day everyone
02:26:28 <Botje> kfmfe04: you should split your problem into subproblems
02:26:39 <Axman6> Botje: exactly
02:27:06 <Twey> I did ☹
02:27:06 <Botje> first you want to split your list ([a]) into a list of lists ([[a]]), where each list is the tail of the previous list
02:27:23 <Botje> so [[1..5],[2..5],[3..5],[4..5],[5..5]]
02:27:32 <Botje> then, filter out the ones that have less than three elements
02:27:38 <kfmfe04> so maybe I want to transform [1..5] into [[1..3],[2..4],[3..5]] first?
02:27:45 <c_wraith> hmm.  patch-tag seems kind of broken
02:27:49 <Botje> and then sum the first three elements of each such list
02:27:51 <Botje> kfmfe04: yeah.
02:28:03 <Botje> that works too
02:28:28 <kfmfe04> ok - lemme try that - ty all
02:29:00 <Botje> good luck!
02:31:28 <Kaidelong> botje: sounds like you really want scan (+) 0 . scan (+) 0 . reverse
02:32:09 <Kaidelong> oops
02:32:20 <Peaker> Kaidelong, that's a weird way of doing it :)
02:32:31 <Peaker> Kaidelong, Less modular, imo (mixing the grouping with the operation)
02:33:07 <Kaidelong> it's not "scan" anyway
02:33:09 <ukl> hello #haskell.  I'm trying to install yi at the moment; but first I wanted to clear up the year-old cabal-mess in my home directory to start fresh (and using debian libghc6-*-dev packages whenever possible) -- I just did 'mv .cabal .cabal-old', is that enough to gain freshness?
02:33:19 <Kaidelong> scanl I believe
02:33:27 <ukl> (I think I might have missed something ghc-pkg'ish)
02:33:49 <Kaidelong> Peaker: looking at the problem, it's the first thing that occured to me
02:33:57 <Peaker> ukl, Nope, .cabal is the package sources/tarballs/listings.  .ghc is the package registry
02:34:02 <Botje> Kaidelong: the power of functional programming is that you can divide your problem without paying for it
02:34:26 <ukl> Peaker: oh, fine. So I'll 'mv .ghc .ghc-old', too.
02:34:40 <Kaidelong> although I was wrong about it, it's not a solution
02:35:39 <Peaker> ukl, You might want to install ghc-6.12.3 :)
02:35:48 <Kaidelong> is there a standard unfold function?
02:35:52 <Peaker> ukl, I install it in /usr/local, and I typically remove all mentions of ghc from /usr/local first
02:35:56 <Kaidelong> IE
02:36:05 <Kaidelong> a -> Maybe a -> [a]
02:36:10 <Kaidelong> err
02:36:23 <Kaidelong> a -> (a -> Maybe a) -> [a]
02:36:36 <ManateeLazyCat> ukl: install ghc-6.12.3, and install gtk with "cabal install gtk2hs-buildtools && cabal install gtk"
02:36:38 <Kaidelong> I get the feeling you could make one from some kind of monad function?
02:36:47 <ManateeLazyCat> ukl: Then install "cabal install yi"
02:37:00 <ukl> Peaker: I rely on debian's ghc packages at the moment... hmm they won't do?
02:37:19 <ManateeLazyCat> ukl: Which version your ghc package in debian?
02:37:24 <ukl> 6.12.1
02:37:31 <ManateeLazyCat> ukl: That's okay.
02:37:35 <Peaker> ukl, I don't like Debian's packages, but you can use them
02:37:51 <ManateeLazyCat> ukl: ghc-6.12.2 can't works with newest gtk2hs.
02:38:25 <Peaker> I hate Gtk+ :P
02:38:26 <ManateeLazyCat> ukl: Except 6.12.2, all ghc that above 6.10.4 will be okay.
02:38:42 <ukl> ManateeLazyCat: thanks for the hint
02:38:46 <ManateeLazyCat> ukl: I recommend you install gtk2hs-0.11 and don't use gtk2hs-0.10
02:39:24 <ManateeLazyCat> Peaker: LIke QT? Or GUI hater? :)
02:40:06 <Peaker> ManateeLazyCat, I hate Qt too. I don't hate GUI's
02:40:21 <Peaker> ManateeLazyCat, I just hate poorly designed widget sets like those, and Winforms, etc.  I like the iPhone/Android UI's
02:40:23 <Kaidelong> :t let unfold f acc = case (f acc) of {Nothing -> [] ; Just x -> unfold x f) in unfold
02:40:24 <lambdabot> parse error on input `)'
02:40:41 <Kaidelong> :t let unfold f acc = case (f acc) of {Nothing -> [] ; Just x -> unfold x f in unfold
02:40:42 <lambdabot> parse error on input `in'
02:40:47 <Kaidelong> :t let unfold f acc = case (f acc) of {Nothing -> [] ; Just x -> unfold x} f in unfold
02:40:48 <lambdabot> parse error on input `f'
02:40:57 <Kaidelong> ugh
02:41:08 <ManateeLazyCat> Peaker: So you should hate gnome or kde, and not Gtk+ :)
02:41:08 <Kaidelong> :t let unfold f acc = case (f acc) of {Nothing -> [] ; Just x -> unfold x f} in unfold
02:41:09 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> Maybe t
02:41:10 <lambdabot>       Expected type: t -> (t1 -> Maybe t) -> [a]
02:41:10 <lambdabot>       Inferred type: (t1 -> Maybe t) -> t1 -> [a]
02:41:17 <Kaidelong> ok, so that doesn't work
02:41:31 <Kaidelong> oh, swapped parameters
02:41:47 <Peaker> ManateeLazyCat, Pretty much all of Gtk+/Qt's widgets are crap, IMO
02:41:56 <Kaidelong> :t let unfold f acc = case (f acc) of {Nothing -> [] ; Just x -> unfold f x} in unfold -- last one
02:41:57 <lambdabot> forall t a. (t -> Maybe t) -> t -> [a]
02:42:02 <Peaker> ManateeLazyCat, If I use Gtk+ to open a window and then render all the widgets myself into it, why use Gtk+?
02:42:23 <Kaidelong> anyone know a better way to do this?
02:42:34 <Peaker> @type unfold
02:42:36 <lambdabot> Not in scope: `unfold'
02:42:39 <Peaker> @hoogle unfold
02:42:39 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
02:42:40 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
02:42:40 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
02:43:00 <ManateeLazyCat> Peaker: What do you mean? 
02:43:29 <Peaker> ManateeLazyCat, I should hate Gtk+/Qt and not just KDE/Gnome because the widgets that form the foundation for all GUIs in Gtk+/Qt are crappy
02:43:34 <Kaidelong> Peaker: there is no unfold. I'm presuming it's because there is some operation for monads that behaves like it... keeps showing the contents until it is zero
02:43:46 <ManateeLazyCat> Peaker: I think you just like Android's behaviour design, exactly, you like it's widget behaviour.
02:44:24 <ManateeLazyCat> Peaker: I think it's design problem, you can also use GTK+ build widget that like iPhone or Android.
02:45:19 <Peaker> ManateeLazyCat, I only had really short glimpses of Android/iPhone, and I liked what I saw (Android not as smooth..).  IMO: A) All screen changes should animate, not flicker.  B) Tear effect/unsmooth scrolling is unacceptable (rules out most widgets automatically)  C) Keyboard is superior to mouse for most purposes and should be usable to access useful features  D) Overlapping windows is stupid  E) Screen space should be used, not display large gray areas
02:45:22 <ukl> Hmm 'cabal install yi -fgtk' yields http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26119#a26119
02:45:33 <Peaker> ManateeLazyCat, What parts of Gtk+ would you use at all if you design something like iPhone?
02:45:55 <Peaker> ManateeLazyCat, Probably you would use Cairo for drawing, and get the low-level input events from Gtk+, and you'd ignore all Gtk+ widgets because they all suck
02:46:35 <ManateeLazyCat> Peaker: Clutter
02:46:55 <ManateeLazyCat> Peaker: I think Clutter integrate with GTK+ framework will do same effect like Android did.
02:47:19 <Peaker> ManateeLazyCat, So Clutter is an attempt to modify Gtk+ widgets so they don't completely suck?
02:48:13 <Peaker> ukl, try to install transformers directly
02:49:40 <ukl> Peaker: ok
02:50:27 <ManateeLazyCat> Peaker: So you just don't gtk+'s default widget and widget behaviour
02:51:00 <ManateeLazyCat> Peaker: Like smooth scroll etc... it's a design problem of widget author.
02:51:15 <ManateeLazyCat> Peaker: You still can use gtk+ build same effect with your own widget.
02:51:23 <Saizan> ukl: you want --constraint="data-accessor-monads-fd == 0.2"
02:52:50 <ManateeLazyCat> Peaker: Yes, animate scroll is cool, but in programmer view, it's waste time to watch animate. :)
02:52:59 <ukl> Saizan: thanks -- with 'cabal install yi'? (yields: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26119#a26120 )
02:53:38 <Saizan> ukl: yup, --constraint="data-accessor < 0.2.1.3" too
02:53:59 <ManateeLazyCat> Peaker: Like "Overlapping windows" problem, i think it's WM's design problem, not gtk+
02:54:04 <ukl> Saizan: There is no available version of data-accessor-monads-fd that satisfies
02:54:05 <ukl> ==0.2
02:54:35 <ukl> oh sorry, wrong command
02:54:45 <ukl> Saizan: it works thanks a lot
02:55:23 <Saizan> ukl: np
02:58:27 * ManateeLazyCat pasted "Build temporary DBus client." at http://paste2.org/get/875716
02:58:27 <ManateeLazyCat> Finally, above code fix my "temporary DBus client" problem. unsafePerformIO should be ok since i won't change tempClient after it create.
03:02:08 <c_wraith> great.  hayoo just went poof again
03:03:08 <kulin> when you create a module with sub modules you can expose the sub modules from some common module and all the functions from the sub modules appear to be in the namespace of the exposing module, is there a way to do it so that in the end user code, they only import the one module which exposes the other, but they still need to use some sort of qualifier?
03:04:19 <c_wraith> the sub-module relationship isn't important.  Any module can export anything it has in scope.  If it was imported from somewhere else, that's fine.
03:04:34 <kulin> ie: module Food (module qualified Food.Pie as Pie)
03:05:13 <ManateeLazyCat> Peaker: Clutter is new UI that develop by Intel (MeeGo), integrate with gtk+ for support 3D animated. :)
03:05:14 <c_wraith> I don't think I've seen that.  Probably nothing like that available.
03:05:46 <kulin> that is unfortunate, the module system for haskell is really not finished
03:06:32 <kulin> that + the inability to set levels of visibility for exposed functions really makes life difficult
03:06:45 <ManateeLazyCat> kulin: Yes, if two sub-module have some function conflict, i think you need qualifier.
03:07:06 <c_wraith> the module system is flat.
03:07:15 <c_wraith> Don't be misled by naming conventions
03:07:26 <kulin> ya
03:08:00 <ManateeLazyCat> kulin: In my project, i always this this rule to format funciton name : "moduleInfix + functionName" then i always got unique function name, don't need qualifier . :)
03:08:13 <kulin> but there are features it should have, which is the ability to import a single module yet maintain qualified namespaces withen it or the ability to set methods as protected / private / public
03:08:35 <ManateeLazyCat> kulin: Like OOP ?
03:08:40 <ManateeLazyCat> :)
03:08:40 <Bigglotron> w... wwwwwwwwww
03:08:41 <c_wraith> private and public already exist.  what would "protected" possibly mean?
03:08:54 <Bigglotron> protected private and public
03:08:59 <ManateeLazyCat> I think protected is unnecessary.
03:09:02 <kulin> sort of like oop, but i want protected to mean not exposed in the library but exposed to the library (for quickcheck)
03:09:04 <Bigglotron> next you'll ask for a jvm implementation
03:09:21 <ManateeLazyCat> kulin: If you don't export some function/type, it's private.
03:09:57 <c_wraith> The .Internal convention does quite well for allowing quickcheck while still restricting the main interface
03:10:26 <ManateeLazyCat> kulin: Well, every language has it's own rule, you can't review haskell with Java rule. :)
03:10:31 <Bigglotron> what about goto guys wheres goto in haskell
03:10:39 <c_wraith> ContT :)
03:10:53 <Bigglotron> missing feature alert
03:11:02 <kulin> i guess you can poke fun
03:11:09 <kulin> but it would be helpful to have protected
03:11:18 <kulin> and the fact you need a convention to deal with its lack sort of says something
03:11:24 <c_wraith> kulin, you still haven't defined semantics for it.
03:11:32 <c_wraith> I can't think of *any* coherent semantics it could have.
03:11:44 <kulin> it would not be exposed from the library but would be exposed to other modules in the library
03:12:22 <c_wraith> That introduces a concept of "libraries" into the language.  There's no such concept at the moment.
03:13:44 <c_wraith> I don't disagree that the current module system is somewhat lacking.  But I don't think some sort of partial access is something we want.
03:14:02 <kulin> its what i want :)
03:14:30 <ManateeLazyCat> kulin: Maybe you can talk this in #ghc, let ghc guys help you implementation it. :)
03:14:32 <c_wraith> also, you *really* shouldn't make your library link against quickcheck.
03:14:50 <kulin> ya im sure they care what i think
03:14:55 <c_wraith> your quickcheck properties shouldn't be in the "library"
03:15:00 <kulin> probably a fraction more than you guys :)
03:16:46 <c_wraith> I really wish I could understand what's wrong with my code.  I feel like it's something really simple...  Just one missing line.
03:16:50 <kulin> well it depends on what you mean by property i guess, the actual checks were written in RealModule.QuickCheck or something like that
03:16:56 <kulin> but the things they test are in RealModule
03:17:45 <kulin> oh well i cant win this arguement and i dont even mean to argue, was just hoping for an easier time exposing code
03:17:49 <c_wraith> I'm talking about packages.
03:18:00 <c_wraith> what else could libraries be?
03:18:07 <ManateeLazyCat> c_wraith: Walk outside a moment, sometimes you got into a dead end. :)
03:18:54 <c_wraith> ManateeLazyCat, I don't think so.  This isn't that sort of problem.  It's a "what part of the interface do I not know about?" problem.
03:19:04 <Peaker> ManateeLazyCat, I agree with what you said ("Gtk+ widget behavior sucks, not the concept of Gtk+ widgets") but Gtk+ is an implementation. As a concept, it isn't interesting to reuse its infrastructure
03:19:17 <Peaker> ManateeLazyCat, I doubt any work based on Gtk+ will be any good, UI-wise
03:19:34 <Peaker> ManateeLazyCat, and I designed my own widget set, which goes for a functional implementation, rather than OO
03:19:59 <ManateeLazyCat> Peaker: Infact, i build my own widget with Haskell/gtk2hs . :)
03:20:35 <Peaker> ManateeLazyCat, If you're only going to use widgets you wrote, and not the crappy ones from Gtk+ itself, what do you gain by not writing your own widget framework?
03:20:42 <Peaker> ManateeLazyCat, And having a nicer design for the widgets?
03:21:28 <ManateeLazyCat> Peaker: Well, i'm build DBus/multi-processes GTK+ framework for build SoftOS. :)
03:21:46 <kulin> what makes a widget framework functional?
03:22:39 <ManateeLazyCat> Peaker: If you see gtk+ widget, you will found those are very basic widget to keep gtk+ simple enough.
03:23:10 <ManateeLazyCat> Peaker: Then gtk+ won't too heavily like QT.
03:23:31 <ManateeLazyCat> Peaker: IMO, some widget is awesome, like sourceview or treeview widget.
03:23:52 <Peaker> ManateeLazyCat, I disagree, I think they suck. I tried using TreeView for a viewer of a huge db with lazy-loading. It was a nightmare
03:23:54 <ManateeLazyCat> Peaker: Infact, like Android's UI, I think it's not new code for build everything.
03:24:13 <Peaker> ManateeLazyCat, I don't think Android used any Gtk+ widget code (at least not for the parts I saw)
03:24:19 <ManateeLazyCat> Peaker: How many item in treeView ?
03:24:25 <dafis> c_wraith: Can I take a look at your code? Maybe a new pair of eyes can spot it
03:24:48 <Peaker> ManateeLazyCat, Basically infinite :)
03:24:52 <c_wraith> dafis: if patch-tag was functional, I'd point you at the whole thing.  But the web frontend to it seems dead.
03:24:54 <Peaker> ManateeLazyCat, The idea is that it should lazily present them
03:25:08 <ManateeLazyCat> Peaker: I have use TreeView with GIO build a file-manager, very fast.
03:25:10 <dafis> c_wraith, hpaste?
03:25:32 <c_wraith> dafis: it's a little too complicated to fit there nicely.  I guess I can just put in the hint-related stuff.
03:25:34 <ManateeLazyCat> Peaker: Perhaps something wrong with your TreeView code.
03:26:26 <dafis> c_wraith: Oh, and explain what the problem is, I've just come on #haskell
03:27:07 <jystic> @pl g x = maybe pass return (f =<< x)
03:27:07 <lambdabot> g = maybe pass return . (f =<<)
03:27:19 <c_wraith> The problem is that when loading a file with Hint, I get an error message saying the types in the signature of the function I'm trying to load aren't in scope.
03:27:22 <ManateeLazyCat> Peaker: Infact, you just need animate make widget more humanity, example animate smooth scroll, i think it's just use some OpenGL render this animate, i think all developer won't use OpenGL render text in sourceview or treeview, right?
03:27:33 <c_wraith> Here's the code that runs Hint: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26122#a26122
03:27:52 <c_wraith> The error message is "WontCompile [GhcError {errMsg = "Not in scope:\n  type constructor or class `Text.Templating.Heist.Types.TemplateState'"},GhcError {errMsg = "Not in scope: type constructor or class `Snap.Internal.Types.Snap'"},GhcError {errMsg = "Not in scope: type constructor or class `Snap.Internal.Types.Snap'"},GhcError {errMsg = "Not in scope: `site'"}]"
03:28:37 <ManateeLazyCat> Peaker: So the core gtk+ widget is not crap, you just need some advanced toolkit (like Clutter) to render animation. 
03:28:39 <c_wraith> Here's the code that calls "loadSnap"  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26123#a26123
03:29:08 <Peaker> ManateeLazyCat, So I need an alternative implementation of Gtk+ that doesn't suck :-)  I agree. I think the Gtk+ APIs are much better than its implementation, but they still are far from what I'd like
03:29:17 <ukl> ManateeLazyCat: you recommended using gtk2hs 0.11 earlier; but from what I see in yi.cabal, that's not possible (gtk==0.10.* is build-depend'ed) -- or were you referring to some other yi version (svn, git, somewhere not in hackage)?
03:29:27 <Peaker> ManateeLazyCat, The core Gtk+ widget *is* the way it looks&feels.  Everything else is peanuts
03:29:34 <c_wraith> There's no real reason to paste the code that it's trying to load, as it's just html twiddly stuff.  I will specify that the file has a function with this signature - site :: TemplateState Snap -> Snap ()
03:30:34 <c_wraith> If I change the calling code to just load Site ( site) directly, as in the commented-out lines, it works just fine.
03:30:38 <ManateeLazyCat> ukl: I don't know the status of yi, but gtk2hs-0.11 will save your many problem to install, because gtk2hs-0.11 is fully cabalised, gtk2hs-0.10 need some `configure ... make` ugly thing.
03:31:07 <ManateeLazyCat> ukl: If yi release version can't work, you can try development version, i don't know much about yi.
03:31:18 <c_wraith> Clearly, there's something I'm missing about initializing Hint.  But I have no clue what.
03:31:30 <ManateeLazyCat> ukl: Even yi failed with new APIs of gtk2hs-0.11, i think it's really easy to fix. :)
03:32:48 <ManateeLazyCat> Peaker: Well, GTK+ is in evolution, Android/iPhone is too new, it's UI need hardware to support it. 
03:32:50 <Peaker> ManateeLazyCat, I see what you're saying as basically: "Gtk+ core (the APIs?) is good, even if the implementation of it (The behavior and look of the widgets) is not good"
03:33:03 <ManateeLazyCat> Peaker: Yes.
03:33:27 <Peaker> ManateeLazyCat, But I don't think the APIs are that good. And even if they were. Why not implement them myself, given that their existing implementation sucks?
03:33:30 <ManateeLazyCat> Peaker: GTK+ not just build widget, it have handle many cross-platform detail.
03:33:44 <Peaker> I don't want the same UI as iphone/etc for a PC, I just think UIs for PC's have been crap for a long time -- and the iPhone kind of served as a testament to that
03:33:51 <Peaker> ManateeLazyCat, What details for example?
03:34:15 <jystic> @pl f b = readDouble b >>= return . fst
03:34:15 <lambdabot> f = (fst `fmap`) . readDouble
03:34:16 <ManateeLazyCat> Peaker: So my point is, it's unnecessary to re-build everything, you just need write new toolkit to got good behaviour. 
03:34:30 <ManateeLazyCat> Peaker: You can read the documentation of glib and gio.
03:35:28 <ManateeLazyCat> Peaker: Example, gio is cross-platform APIs to handle files/directories/"application startup" etc. That's mean i don't write duplicate code for different platform once i use gio APIs.
03:35:59 <ManateeLazyCat> Peaker: Glib is like gio, but it's more general.
03:36:11 * ManateeLazyCat Infact, is gio like glib, not glib like gio. :)
03:37:04 <Peaker> ManateeLazyCat, I wrote a new toolkit, a functional ones, and I think it will end up much nicer than Gtk+ :)
03:37:41 <ManateeLazyCat> Peaker: So we don't need re-build underlying architecture of gtk+ if we just want some new widget behaviour.
03:38:01 <ManateeLazyCat> Peaker: All haskell code?
03:38:04 <Peaker> ManateeLazyCat, I have no use for its architecture, I already said I think it kinda sucks, GHC is a better architecture :)
03:38:07 <Peaker> ManateeLazyCat, Yeah
03:38:20 <ManateeLazyCat> Peaker: Any screenshot?
03:39:02 <Peaker> ManateeLazyCat, Nope, I can make one some other time, if you want
03:39:06 <_Cactus_> hi
03:39:25 <ManateeLazyCat> Peaker: Of course, fully functional GUI toolkit is cool.
03:39:36 <_Cactus_> I'm trying to use Gtk2HS, but control the main loop myself. My problem is, mainIteration always seem to return True
03:40:07 <ManateeLazyCat> Peaker: BTW, how do you handle low-level detail of different platform.
03:40:09 <ManateeLazyCat> ?
03:40:12 <Peaker> ManateeLazyCat, I have something like: Widget k = (RequestedSizeRange, Size -> (Image, EventMap k))
03:40:15 <Peaker> ManateeLazyCat, (no monads in sight)
03:40:32 <Peaker> ManateeLazyCat, I will use a rendering/input framework that is already cross-platform
03:40:32 <_Cactus_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=26124
03:40:34 <ManateeLazyCat> Peaker: I guess you still use some FFI code ?
03:40:40 <Peaker> ManateeLazyCat, currently exploring rendering in a web browser
03:40:41 <_Cactus_> ^ here's a very simple program demonstrating the problem
03:40:53 <Peaker> ManateeLazyCat, Nope, if not web, I'll use cairo bindings or OpenGL or SDL
03:41:20 <ManateeLazyCat> Peaker: What's the browser kernel?
03:41:37 <ManateeLazyCat> Peaker: Webkit?
03:41:41 <mpiechotka> Hello. Does anyone knows where is Monad instance of BehaviorG  from reactive package?
03:42:01 <Peaker> ManateeLazyCat, The browser? Why care about it?
03:42:04 <ManateeLazyCat> _Cactus_:  Add mainGUI at last line of "main"
03:42:06 <Peaker> ManateeLazyCat, I just render TO the browser
03:42:14 <Peaker> ManateeLazyCat, The web is already "portable"
03:42:15 <_Cactus_> ManateeLazyCat, but that's exactly the opposite of what I want:)
03:42:39 <ManateeLazyCat> Peaker: You still use cairo?
03:42:40 <_Cactus_> ManateeLazyCat, I want to manually call mainIteration whenever I feel like it
03:42:54 <ManateeLazyCat> _Cactus_: Why you need that?
03:43:06 <_Cactus_> ManateeLazyCat, because I want to tunnel it into Elerea
03:43:32 <ManateeLazyCat> _Cactus_: So you need some multi-threaded with gtk2hs? 
03:43:37 <Peaker> ManateeLazyCat, I don't use it yet -- I used SDL but the Haskell bindings didn't work well on OSX
03:43:40 <_Cactus_> ManateeLazyCat, no
03:43:53 <_Cactus_> ManateeLazyCat, actually I think I need exactly what mainIteration is, according to the documentation
03:44:24 <_Cactus_> ManateeLazyCat,  and it works except its return value is bogus
03:45:02 <ManateeLazyCat> _Cactus_: In your code, it's infinite loop.
03:45:12 <T_S_> Does any one know of a library that defines scalar/vector/matrix addition and multiplication for Data.Vector instances? Prefer not to reinvent the wheel.
03:45:24 <_Cactus_> ManateeLazyCat: yes but please imagine the last line is 'unless finished loop'
03:46:03 <_Cactus_> ManateeLazyCat: in that case, it should be equivalent to mainGUI
03:46:15 <_Cactus_> ManateeLazyCat: but it's not because every call to mainIteration returns True
03:46:28 <ManateeLazyCat> _Cactus_: So you want render window after your "loop" finish?
03:47:36 <ManateeLazyCat> Peaker: IMO, if you want to build some cross-platform GUI toolkit, you always need some FFI code, more or less.
03:47:51 <ManateeLazyCat> Peaker: Infact, you use Haskell build OS-kernel. :)
03:48:03 <ManateeLazyCat> s/Infact/Except
03:48:06 <Peaker> ManateeLazyCat, Of course I use FFI, indirectly, e.g: to Cairo, via the Cairo Haskell bindings
03:48:57 <ManateeLazyCat> Peaker: From your talk, you not just un-happy with gtk+ default widget behaviour, you also un-happy with gtk+ framework?
03:49:03 <Peaker> ManateeLazyCat, Yes
03:49:56 <ManateeLazyCat> Peaker: Ok, if so, you still need glib and some render backend (like Cairo)
03:50:11 <ManateeLazyCat> Peaker: Then use Haskell build your own GUI framework. :)
03:50:12 <Peaker> ManateeLazyCat, I'd love to use something like GLUT/OpenGL instead, if GLUT wasn't so crappy
03:50:20 <Peaker> ManateeLazyCat, Yeah that's what I'm doing
03:50:38 <Peaker> ManateeLazyCat, Might be using HTTP server + Javascript to have the web browser be my terminal
03:51:11 <ManateeLazyCat> Peaker: IMO, OpenGL just useful when you want some cool animate, i guess you won't want OpenGL render 2D text. :)
03:51:36 <Peaker> ManateeLazyCat, I can animate reasonably with all of these, probably
03:52:02 <ManateeLazyCat> Peaker: Sometimes, 3D render is unnecessary and ineffective. :)
03:52:27 <Peaker> ManateeLazyCat, OpenGL has good performance pretty much everywhere..
03:52:39 <Peaker> ManateeLazyCat, maybe we can take this to #-blah?
03:53:11 <ManateeLazyCat> Peaker: Example, if you just need render some file in editor widget, i think Cairo is much faster than OpenGL.
03:53:26 <ManateeLazyCat> Peaker: No, it's not blah, i think it's feature of #haskell. :)
03:53:42 <ManateeLazyCat> Peaker: Most haskellers don't use GUI.
03:53:50 <ManateeLazyCat> use haskell build GUI program.
03:53:51 <Peaker> ManateeLazyCat, I don't think Cairo will render text significantly faster than OpenGL+FTGL
03:54:02 <ManateeLazyCat> Peaker: Cairo + Pango
03:54:12 <ManateeLazyCat> Peaker: Pango is good library for render text.
03:54:40 <Peaker> ManateeLazyCat, Why do you think it will be faster than OpenGL+FTGL?
03:56:51 <ManateeLazyCat> _Cactus_: If you want show window after you finish loop, i recommand you don't use widgetShowAll before your loop, then use forkIO/MVar running your loop, after catch *finish signal* from MVar, then use widgetShowAll show window.
03:57:33 <ManateeLazyCat> _Cactus_: From this point, you don't need control main iteration, you just need enable "--threaded" flag with ghc and use unsafeInitGUIForThreadedRTS instead initGUI
03:58:22 <ManateeLazyCat> _Cactus_: When you catch signal from MVar (your loop threads), use "postGUIAsync" post any gtk+ code to gtk+ main thread.
03:58:33 <Guest42356> hmm doesnt cairo also usually use opengl as its backend? it can ouput to framebuffer or xcb, but obviously not on windows or linux.
03:58:55 <Guest42356> umm s/linux/osx/
03:59:23 <ManateeLazyCat> Peaker: Because Cairo is less calculation with 2D render.
04:00:17 * ManateeLazyCat pasted "gtk2hs concurrent library" at http://paste2.org/get/875777
04:00:18 <ManateeLazyCat> _Cactus_: If you don't know how to write multi-threaded code with gtk2hs, look above, my concurrent library for gtk2hs. 
04:01:14 <ManateeLazyCat> Peaker: My suggestion is, use Cairo + Pango render 2D, and use OpenGL render animate, of course, you need mix those in your framework.
04:01:26 <ManateeLazyCat> Peaker: I need dinner now, soon back, good to talk with you . :)
04:02:57 <dafis> c_wraith: sorry, nothing leapt to my eyes either :(
04:14:51 <ManateeLazyCat> _Cactus_: If you still have problem, paste your code to gtk2hs list.
04:15:03 <ManateeLazyCat> Bye all. :)
04:21:46 <c_wraith> dafis, well, thanks for looking
04:27:40 <Amagineer> Is there a way to get ghci to show an IO Float?
04:28:14 <dafis> (>>= print)
04:28:58 <Amagineer> Thanks
04:29:22 <dafis> Amagineer, you can't show IO whatever, but you can print out the whatever value it produces because in ghci, you're in IO
04:30:00 <Axman6> or you can use x <- f; x
04:30:03 <Amagineer> Right, of course
04:30:34 <dafis> So, you pass the result of the action to print, either via (>>=) or per do-notation
04:31:00 <Amagineer> Yeah, I was trying to do that with a function, but it kept yelling at me
04:31:18 <Amagineer> Either way, that worked
04:31:19 <Amagineer> Thanks
04:39:45 <Axius> What is required to run haskell?
04:39:56 <FauxFaux> Haskell.
04:40:01 <mauke> a compiler or an interpreter
04:40:05 <ivanm> @where platform
04:40:05 <lambdabot> http://hackage.haskell.org/platform/
04:40:09 <dafis> Axius: An implementation and a programme :)
04:40:15 <ivanm> Axius: ^^ that's probably the easiest way to install Haskell
04:40:17 <Saizan> Prelude> return True :: IO Bool
04:40:18 <ivanm> @where lyah
04:40:18 <lambdabot> http://www.learnyouahaskell.com/
04:40:18 <Saizan> True
04:40:21 <ivanm> @where tryhaskell
04:40:21 <lambdabot> http://tryhaskell.org/
04:40:27 <Saizan> no need to use (>>= print) in ghci.
04:40:29 <ivanm> Axius: ^^ and here's two online tutorials
04:40:38 <Axius> ghc is ok?
04:40:44 <ivanm> yes
04:40:51 <ivanm> GHC is the de-facto Haskell implementation
04:41:03 <dafis> the only generally usable atm
04:41:13 <ivanm> right
04:41:30 <dafis> there are exciting others, but they're not (yet) production-ready
04:41:38 <Axman6> Axius: GHC is more than ok
04:41:40 <ivanm> and hugs is no longer maintained
04:43:09 <Axius> ok, I will install ghc.
04:45:35 <Amagineer> Saizan: Without (>>= print) ghci yells at me with 
04:45:35 <Amagineer> <interactive>:1:0:
04:45:35 <Amagineer>     No instance for (Show (t -> IO Float))
04:45:35 <Amagineer>       arising from a use of `print' at <interactive>:1:0-6
04:45:35 <Amagineer>     Possible fix:
04:45:35 <Amagineer>       add an instance declaration for (Show (t -> IO Float))
04:45:36 <Amagineer>     In a stmt of a 'do' expression: print it
04:45:55 <mauke> you're trying to print a function
04:46:23 <kfmfe04> how do I write an average function?  let a = [1..10]      ( sum a ) / ( length a )     doesn't seem to work - do I have to do an Haskell equivalent of a cast?
04:46:26 <Amagineer> Hmm, that's odd, it shouldn't be taking arguments
04:46:36 <Peaker> @type genericLength
04:46:37 <lambdabot> forall b i. (Num i) => [b] -> i
04:46:45 <mauke> > let a = [1..10]   in   ( sum a ) / ( length a )
04:46:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
04:46:46 <lambdabot>    arising from a use o...
04:46:54 <Amagineer> Oh, wow
04:46:58 <Amagineer> *facepalm*
04:47:00 <Amagineer> It is
04:47:07 <mauke> kfmfe04: the problem is that the types of / and length don't match
04:47:08 <Peaker> > let a = [1..10]   in sum a / fromIntegral (length a)
04:47:09 <lambdabot>   5.5
04:47:26 <Peaker> @type genericLength
04:47:28 <lambdabot> forall b i. (Num i) => [b] -> i
04:47:31 <Peaker> > let a = [1..10]   in sum a / genericLength a
04:47:32 <lambdabot>   5.5
04:47:38 <mauke> use fromIntegral to convert integer values to anything else
04:48:06 <Peaker> > let avg = liftA2 (/) sum genericLength   in avg [1..10]
04:48:07 <lambdabot>   5.5
04:48:33 <kfmfe04> > fromIntegral( length a )
04:48:34 <lambdabot>   Couldn't match expected type `[a]'
04:48:34 <lambdabot>         against inferred type `SimpleRef...
04:48:49 <i_am_neuron> Folks, hammered by type ambiguity error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26125#a26125 Can't really see what's ambigous about this snippet. Help anybody?
04:48:51 <mauke> kfmfe04: first you need an 'a'
04:48:54 <kfmfe04> fromIntegral( length [1..10] )
04:48:55 <dafis> kfmfe04, but if it's a long list, sum xs / fromIntegral (length xs) is bad
04:49:07 <mauke> dafis: why?
04:49:24 <kfmfe04> is it because the implementation is a linked list?
04:49:32 <dafis> mauke: because the entire list must be in memory
04:49:41 <dafis> and it must be traversed twice
04:49:56 <dafis> kfmfe04, yes
04:51:51 <kfmfe04> > ( sum [1..10] ) / fromIntegral( length [1..10] )
04:51:53 <lambdabot>   5.5
04:52:50 <mauke> :t (\(s, n) -> s / fromIntegral n) . foldl' (\(s, n) x -> s `seq` n `seq` (s + x, n + 1)) (0, 0)
04:52:51 <lambdabot> forall b. (Fractional b) => [b] -> b
04:53:47 <Axman6> > let ave xs = ave' 0 0 xs where ave' t n (x:xs) = ave' (t+x) (succ n) xs; ave' t n [] = t / n in ave [1..10]
04:53:48 <lambdabot>   5.5
04:53:52 <Axman6> > let ave xs = ave' 0 0 xs where ave' t n (x:xs) = ave' (t+x) (succ n) xs; ave' t n [] = t / n in ave [1..1000]
04:53:53 <lambdabot>   500.5
04:53:57 <Axman6> > let ave xs = ave' 0 0 xs where ave' t n (x:xs) = ave' (t+x) (succ n) xs; ave' t n [] = t / n in ave [1..10000000]
04:54:04 <lambdabot>  Terminated
04:54:12 <Axman6> > let ave xs = ave' 0 0 xs where ave' !t !n (x:xs) = ave' (t+x) (succ n) xs; ave' t n [] = t / n in ave [1..10000000]
04:54:15 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
04:54:20 <Axman6> :(
04:55:36 <mauke> i_am_neuron: my guess: cast doesn't know which type to cast to
04:55:46 <aristid> > (\(s, n) -> s / fromIntegral n) . foldl' (\(s, n) x -> s `seq` n `seq` (s + x, n + 1)) (0, 0) [1,2,3,4]
04:55:49 <lambdabot>   (10,1.0)
04:56:03 <aristid> > ((\(s, n) -> s / fromIntegral n) . foldl' (\(s, n) x -> s `seq` n `seq` (s + x, n + 1)) (0, 0)) [1,2,3,4]
04:56:05 <lambdabot>   2.5
04:56:16 <aristid> > (1+2+3+4)/4
04:56:17 <lambdabot>   2.5
04:56:25 <mauke> i_am_neuron: why are you using cast there?
04:57:50 <i_am_neuron> mauke: In short: Wrap type wraps values of (Protocol a) with different a's, so that I can place them in one list (this list is passed to doRun). I want to extract back the wrapped value using cast
04:58:01 <mauke> i_am_neuron: cast doesn't extract values
04:58:09 <Axius> I get this error when I open ghci: Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: 
04:58:13 <dafis> i_am_neuron, I'd try a GADT for Wrap
04:58:32 <i_am_neuron> dafis: GADT?
04:58:36 <dafis> then you can get the dictionary by pattern matching
04:58:37 <mauke> dafis: would that make any difference?
04:59:00 <dafis> i_am_neuron, data Wrap where Wrap :: Protocol a => IO a -> Wrap
04:59:09 <Saizan> i_am_neuron: you can't just say "cast is back to what it was" you've to try to cast it to specific types hoping you get one that matches, so your design might be quite flawed there
04:59:11 <mauke> I'll take that as a "no"
04:59:11 <ivanm> Axius: how did you install GHC?
04:59:19 <ivanm> and what OS are you using?
04:59:35 <mauke> Saizan: it's more flawed in that the type *never* match
04:59:40 <mauke> so cast will always fail
05:00:04 <dafis> i_am_neuron, then make it forkAccept (Wrap a) = forkIO (listen a)
05:00:06 <Saizan> dafis: that's the same exact type as the Wrap in the paste
05:00:14 <Saizan> mauke: what do you mean by never?
05:00:52 <mauke> Saizan: cast :: Wrap -> Maybe (IO a)
05:01:04 <mauke> result is guaranteed to be Nothing
05:01:09 <Axius> ivanm: now it's working. I had to install gmp-4.2.4-i486-1.
05:01:29 <ivanm> Axius: yeah, I was going to suggest that, was just checking what OS/distro you were using
05:01:59 <Axius> ivanm: I use Slackware.
05:02:07 <ivanm> aha
05:02:11 <dafis> Saizan, yes, but pattern matching on a GADT makes the contexts available, that used not to be the case with ordinary existential types. Maybe that has changed in recent versions of GHC, in which case, it would really make no difference
05:02:14 <i_am_neuron> mauke: I actually would like to use cast :: (Protocol a) => Wrap -> Maybe a
05:02:15 <Saizan> mauke: ah, k
05:02:19 <ivanm> so, yeah, there's probably no official packages :p
05:02:26 <ivanm> (for GHC, etc.)
05:02:45 <Saizan> dafis: as far as i remember it always worked for existential types
05:02:54 <mauke> i_am_neuron: that's not what your code says
05:03:00 <mauke> i_am_neuron: and that still won't work
05:03:22 <dafis> Saizan, I might have misremembered
05:03:25 <Axius> ivanm: I've used a slackbuild package.
05:03:35 <mauke> dafis: if the contexts weren't available, existentials would be useless
05:03:37 <i_am_neuron> mauke: why it won't work?
05:03:39 <Heffalump> dafis: I think it always worked too
05:03:57 <mauke> i_am_neuron: because cast does not extract or convert or anything
05:04:13 <mauke> i_am_neuron: it checks whether the types are exactly the same, otherwise it returns Nothing
05:04:27 <Saizan> you won't get the context for cases like "data Class a => Foo a = ..."
05:04:51 <ivanm> Heffalump: did my response to your comment on my post answer your query sufficiently?
05:04:54 <dafis> Saizan, Heffalump: You're right, 'twas for constraints without forall.
05:05:08 <mauke> that's not existentials
05:05:47 <Heffalump> ivanm: sort of, though I don't think -hide-package is that much of an imposition, and uglifying code (by changing module names) to work round the problem would be even worse
05:05:47 <dafis> mauke: yes
05:05:57 <ivanm> Heffalump: right
05:06:07 <ivanm> Heffalump: but I wanted to pre-empt people that would bring that objection up
05:06:24 <ivanm> (to show that I realise it's a problem, etc.)
05:06:24 <i_am_neuron> mauke: How to make two different types same then?
05:06:30 <mauke> i_am_neuron: you don't
05:06:36 <mauke> why do you think you need to do that?
05:08:43 <i_am_neuron> mauke: when (Protocol a) => Wrap (IO a) holds, for each instance of Wrap type checker infers different a. I'm placing those wraps in one list, and then I would like to use (different) inferred a's again, no matter what is a, important is that (Protocol a) holds
05:08:52 <i_am_neuron> mauke: isn't it something I can do with cast?
05:09:06 <mauke> yes, that isn't something you can do with cast
05:09:18 <i_am_neuron> Oh
05:09:34 <mauke> <dafis> i_am_neuron, then make it forkAccept (Wrap a) = forkIO (listen a)
05:12:36 <mauke> @let x === y = cast x == Just y
05:12:39 <lambdabot>  Defined.
05:12:46 <mauke> > () === ()
05:12:47 <lambdabot>   True
05:12:54 <mauke> > () === "hi"
05:12:55 <lambdabot>   False
05:13:48 <yitz> > () === False
05:13:49 <lambdabot>   False
05:13:59 <mauke> > True === False
05:14:00 <lambdabot>   False
05:14:28 <yitz> > False === ()
05:14:28 <lambdabot>   False
05:14:34 <dafis> > [] === asTypeOf [] [()]
05:14:35 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:14:35 <lambdabot>    `Data.Typeable.Typeable a...
05:15:06 <yitz> > cast () :: Maybe Bool
05:15:07 <lambdabot>   Nothing
05:15:07 <Gracenotes> it is morning
05:15:09 <Gracenotes> wooooo
05:15:10 <Gracenotes> > Nothing === Nothing
05:15:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:15:11 <lambdabot>    `Data.Typeable.Typeable a...
05:15:24 * Gracenotes kicks his irc client
05:15:28 <yitz> @src cast
05:15:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:15:50 <i_am_neuron> mauke: this seems to work (some other errors pop up, but first one is gone), but it looks like I need not the classes to be instances of Typable, right (cast is gone)?
05:15:59 <mauke> > (Noything :: Maybe Int) === (Nothing :: Maybe String)
05:16:00 <lambdabot>   Not in scope: data constructor `Noything'
05:16:05 <mauke> > (Nothing :: Maybe Int) === (Nothing :: Maybe String)
05:16:06 <lambdabot>   False
05:16:11 <mauke> i_am_neuron: right
05:16:13 <chrisdon`> mauke: your accent coming through?
05:16:16 <nostrand> hi, do Vector have support for matrices?
05:16:18 <ulfdoz> aw
05:16:25 <yitz> > cast 1.5 :: Maybe Int
05:16:26 <lambdabot>   Nothing
05:16:36 <yitz> > cast 1.0 :: Maybe Int
05:16:37 <lambdabot>   Nothing
05:16:50 <mauke> > 1.0 === 1
05:16:51 <lambdabot>   False
05:16:57 <yitz> heh
05:17:03 <chrisdone> > 1/1 == 1
05:17:04 <lambdabot>   True
05:17:09 <chrisdone> phew
05:17:16 <mauke> > 1/1 === 1
05:17:17 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Bool.Bool)
05:17:17 <lambdabot>    arising from a use o...
05:17:22 <mauke> huhu
05:17:24 <Twey> BOB?  Sounds more like Network Security Sam
05:17:35 <mauke> > 1.0 === (1 :: Double)
05:17:36 <lambdabot>   True
05:18:07 <Gracenotes> === isn't that interesting after all... it only returns Just if the TypeReps are the same, and unless there's funny business going on in built-in Typeable instances...
05:18:20 <chrisdone> :t (===)
05:18:21 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
05:19:05 <mauke> javascript and php have it, and now we do too!
05:19:33 <Gracenotes> that's because usually their == is *more permissive* than their === :P
05:19:39 <Gracenotes> it seems the opposite way around here!
05:19:50 <mauke> don't confuse me with facts!
05:20:33 <Gracenotes> it is 6000°C on the sun's surface
05:20:49 <chrisdone> Gracenotes: on average?
05:20:55 * dafis wishes a few of those degrees were here
05:20:58 <mauke> Gracenotes: http://mauke.ath.cx/stuff/img/lol,internet/baby-degrees.jpg
05:21:29 <chrisdone> that picture makes me both happy and sad
05:21:38 <mauke> .oO( sappy? )
05:21:39 <chrisdone> microwaves have always reminded me of the movie Cube
05:21:55 <chrisdone> since that whole death by radiation wave scene
05:22:05 <chrisdone> (or was that Cube Zero?)
05:25:07 <Gracenotes> chrisdone: arguably it went downhill after the first one
05:27:04 <chrisdone> Gracenotes: kind of like The Matrix
05:30:10 <Gracenotes> chrisdone: precisely. in both cases, starts off with an interesting and action-filled quasiparable, moves onto badly explained action-filled sequel, and ends in one long session of backstory wankery
05:30:35 <chrisdone> Gracenotes: well put
05:31:59 <ivanm> preflex: seen tomberek
05:32:00 <preflex>  tomberek was last seen on #haskell 7 days, 2 hours, 11 minutes and 29 seconds ago, saying: copumpkin.. what about coq?
05:32:57 <mauke> preflex: quote
05:33:03 <preflex>  <tm604> i write php when I'm angry, why waste the rage?
05:35:09 <bremner> Gracenotes: better than the 3 episode star wars backstory wankery :)
05:38:59 <ivanm> @tell tomberek I think I've got the mapping functions sorted; see the latest version in the repo
05:38:59 <lambdabot> Consider it noted.
05:45:09 <T_S_> @nostrand Vector (Vector a) ) get you the structure. is that all you need?
05:45:10 <lambdabot> Unknown command, try @list
05:45:37 <interferon> are there any haskell parsers for objective-c, maybe packaged with a C parser?
05:46:28 <michael|> Like a parser written in objective-c to parse haskell or a parser written in haskell to parse objective-c?
05:46:28 <sc> hi all.  are there any haskell parsers for .obj wavefront?
05:46:47 <interferon> michael|: the latter
05:46:53 <interferon> sorry for the ambiguity :)
05:47:24 <sc> \quit
05:48:28 <ivanm> interferon: not that i know of
05:48:38 <ivanm> language-c only covers C99 AFAIK
05:49:15 <michael|> interferon: not seeing any either
05:49:26 <interferon> i wonder how hard it would be to write one. since it's a superset of C, i could probably use a lot of the combinators in Language.C
05:49:40 <ivanm> IIRC, language-c uses happy and alex to generate the prser
05:49:42 <ivanm> *parser
05:49:46 <interferon> ah
05:50:10 <interferon> what's the advantage of that over parsec?  does it simply predate parsec's creation?
05:54:04 <Heffalump> interferon: parser generators are older technology, probably more robust and faster, particularly for difficult grammars, but more annoying to use
05:54:40 <interferon> hmm, is there a library of parsec combinators for C?
05:55:20 <Axman6> maybe you want Language.C?
05:57:30 <Zao> Axman6: Supposedly uses happy/alex/magic to parse stuff.
05:57:37 <chrisdone> Heffalump: also language-agnostic, which can be nice
05:57:39 <Zao> See above.
05:59:38 <i_am_neuron> Folks, I want to have the same function name in the data type and in the class that is implemented by this data type: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26129#a26129 (instead of transport and eTransport I want to use just transport). Is it possible to combine those two functions somehow while keeping the current semantics?
05:59:38 <i_am_neuron> I.e. it works now, I just want to get rid of eTransport
06:00:07 <ivanm> i_am_neuron: define one in a separate module and import qualified
06:00:19 <Heffalump> chrisdone: except that you still need to write the actions.
06:00:20 <ivanm> apart from that, no
06:00:44 <ivanm> i_am_neuron: you may wish to consider providing a better/different name than eTransport instead
06:01:03 <i_am_neuron> ivanm: yeah, I want it to be 'transport'
06:01:07 <i_am_neuron> :)
06:01:09 <ivanm> because the fact that you want to use the same name suggests to me that there might be too much coupling between your class and your data type
06:02:34 <Eelis> interferon: i don't know about C, but for C++ there's Boost.Spirit
06:02:35 <chrisdone> Heffalump: but it's a small except compared to Parsec
06:02:49 <Eelis> interferon: oh sorry, i thought you said "parser combinators", not "parsec combinators"
06:03:00 <interferon> np
06:03:24 <chrisdone> Heffalump: plus, it means you can have someone working on the grammar only without caring about how the AST is generated
06:03:36 <nostrand> T_S_: it would be nicer with multi-indexed arrays :P
06:04:46 <interferon> well, looks like i have a project now :)
06:05:23 <interferon> C and objective-c parser combinators
06:05:36 <interferon> though i would probably be better off with regexen for my current project :)
06:07:27 <Axman6> no! put in the effort, so everyone can benefit!
06:08:02 <chrisdone> communist!
06:09:57 <Axman6> chrisdone: and profit!
06:10:08 <chrisdone> socialist!
06:12:26 <Twey> Haha
06:14:37 <tamiko> Hi, is there an easy way to change the behaviour of show :: (Show a) => a -> String or is there a different version of it: I would like to have the following behaviour: show "blubb" == "blubb", not "\"blubb\"".
06:15:02 <Twey> tamiko: Sure there's a different version: ‘id’
06:15:06 <chrisdone> usually that involves writing your own class
06:15:07 <Twey> > id "blubb"
06:15:07 <lambdabot>   "blubb"
06:15:15 <Twey> > id "blubb" == "blubb"
06:15:16 <lambdabot>   True
06:15:50 <Twey> I think we should proscribe the use of ‘show’ to embed non-String values in String output
06:16:00 <Twey> That would prevent this sort of confusion
06:16:16 <tamiko> Twey: Yes, that's true :-D - I have to be a bit more specific. One moment.
06:16:18 <Twey> Suggest printf or something instead
06:16:18 <chrisdone> but i often want show :: String -> String
06:16:25 <Twey> :t show
06:16:26 <lambdabot> forall a. (Show a) => a -> String
06:16:34 <Twey> :t show :: String -> String
06:16:34 <lambdabot> String -> String
06:17:41 <Twey> :t text
06:17:41 <lambdabot> String -> Doc
06:17:50 <chrisdone> usually this kind of custom show is useful for serialising and such
06:18:09 <Twey> How is it useful for serialising?
06:18:10 <chrisdone> you want myShow 1 = "1", myShow "hello" => "hello", e.g. for toSqlValue
06:18:22 <Twey> No?
06:18:28 <chrisdone> Nein?
06:18:37 <Twey> toSqlValue "hello" = "'hello'"
06:18:46 <chrisdone> mhm
06:19:19 <Twey> There's no sane serialisation format where it makes sense to have serialise "5" == serialise 5
06:19:32 <chrisdone> nope
06:19:50 <T_S_> nostrand: gotcha. i haven't seen that, but i haven't looked much either. i'm looking for scalar,vector,matrix addition and multiplication. haven't seen that either so i am coding up a rough and ready version.
06:21:46 <Twey> Also, ‘putStrLn $ "foo " ++ show bar ++ " baz " ++ show quux ++ " arthur."’ is just horrible.
06:22:46 <nostrand> T_S_: hmatrix maybe?
06:22:47 <chrisdone> toXml 5 => "5", toXml "5" => "5"
06:22:53 <tamiko> Ok. Second try: I have something like this: http://dpaste.com/206723/  - The output of "blubb: " ++? ( :: InfoP a) is fine. The problem ist that "blubb: " ++? ( :: InfoP String) has additional brackets because of the lifting of show.
06:22:59 <Twey> ‘printf "foo %{bar} baz %{quux} arthur." [("bar", bar), ("quux", quux)]’ is much nicer, and also more flexible (lovely for point-free)
06:23:30 <chrisdone> not compile-time verified though
06:23:37 <chrisdone> printf functions are lame
06:23:43 <Twey> chrisdone: Fair, but loses information, and you still don't want toXml to be id for strings, since you need to do escaping of various characters
06:24:08 <mauke> printf functions are great
06:24:09 <Twey> printf is lame, but it's not hard to create something better
06:24:16 <Twey> Also, you can get compile-time verification with TH
06:24:28 <Twey> (there's a printf that does compile-time type checking on Hackage)
06:24:39 <mauke> I think there are at least two
06:25:01 <nostrand> T_S_: you probably want to do those things with BLAS, not in Haskell
06:25:04 <Twey> Something like Python's % with type-checking would be lovely.
06:25:57 <kfmfe04> T_S_: R would also be a good choice
06:26:13 <Twey> Or Octave…
06:26:44 <nostrand> or Fortran (>= 90)
06:27:10 <Twey> Really?
06:27:51 <kfmfe04> btw, does Haskell have an Array type (as in contiguous memory)?
06:27:59 <aristid> kfmfe04: yes
06:28:47 <Twey> It has many
06:28:50 <nostrand> Twey: yeah, it's not that bad
06:29:24 <kfmfe04> which one is most popular/well-supported?
06:29:26 <Twey> I think you'd have as much luck using hmatrix as FORTRAN, surely.  It doesn't provide the visualisation facilities these others do.
06:29:35 <aristid> Twey: python's .format is better than the %
06:29:47 <yitz> haskell has a number of pretty-printers. printf is the only one that's not type-safe.
06:29:54 <Heffalump> kfmfe04: unboxed arrays are what GHC provides by default. vector is the new kid on the block, with cool optimisation stuff.
06:30:30 <Heffalump> given your desire for contiguous memory, make sure you do look for unboxed structures, otherwise you'll end up with a contiguous block of pointers to non-contiguous data
06:30:37 <chrisdone> Twey: the point was really it's convenient to have a show function that doesn't escape strings if you're going to escape the output for a given text format anyway. it lets you have: toXml = escape . show
06:30:41 <Twey> aristid: What's the difference?
06:31:05 <Twey> chrisdone: But you only need to escape strings…
06:31:15 <kfmfe04> Heffalump: tyvm - just found this http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial  but will also look for unboxed structures
06:31:19 <chrisdone> Twey: how do you know that?
06:31:34 <chrisdone> Twey: what is the value of show X?
06:31:39 <Twey> chrisdone: Because < and > don't occur in numbers, booleans, &c.
06:31:49 <Twey> chrisdone: That's a different type, with its own toXml
06:31:56 <mauke> > show 100000000000000000000000000000000000000.0
06:31:57 <lambdabot>   "1.0e38"
06:31:59 <yitz> ShowS is an excellent pretty-printer for most purposes. Or even just concat sometimes.
06:32:05 <T_S_> @nostrand et al: looking at Vector as a doppelganger for use of dph and repa down the road. i have tried hmatrix and it is very nice, but i dont think it or blas support parallel sparse matrices. pls. correct me if this is wrong. 
06:32:05 <lambdabot> Unknown command, try @list
06:32:13 <Twey> You don't want to do escaping on everything, even the stuff that can't possibly contain invalid characters
06:32:17 <Twey> That's a waste of processing power
06:32:28 <mauke> Twey: I do, actually
06:32:31 * chrisdone underscores convenience
06:32:48 <nostrand> T_S_: with parallell you mean?
06:33:12 * hackagebot language-python 0.3.2 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.3.2 (BerniePope)
06:33:13 <yitz> Personally I've never found a use case where the type-unsafety and C-style line noise of printf were worth it. But I suppose it's a matter of taste.
06:33:18 <Twey> If the values happen to be identical to their Haskell representations, or easily derived thereby, then you can use show
06:33:28 <Twey> If they aren't, then you need another function
06:34:08 <T_S_> @nostrand: thinking smp at the moment, yeah, but might need distributed memory later.
06:34:08 <lambdabot> Unknown command, try @list
06:34:22 <Axman6> T_S_: lose the @
06:34:25 <yitz> And as hackagebot has commented as part of our conversation, there are also many excellent specialized pretty-printers.
06:34:43 <Twey> aristid: Ooh, found it.
06:34:44 <chrisdone> Axman6: lol. please excuse the twitter generation
06:34:45 <nostrand> T_S_: there are parallell implementations of BLAS afaik
06:35:00 <mauke> yitz: what about: printf "%20s  %20s  %s\n" size mTimeStr name ?
06:35:26 <T_S_> Axmand: thx, i guess nostrand is not a bot :-)
06:35:27 <yitz> mauke: yuck. can't read it. :)
06:35:39 <mauke> yitz: why not?
06:35:44 <yitz> line noise
06:35:48 <mauke> ... right
06:35:52 <Twey> aristid: I feel that positional arguments to a format string should never be used.  You never know if another language might have them the other way around.
06:35:53 <Axman6> T_S_: try typine this in your IRC client: ax<tab>
06:35:55 <mauke> lern2haskell
06:35:55 <yitz> but yeah, it's fine
06:36:27 <Twey> It's better than: take 20 size ++ "  " +
06:36:28 <chrisdone> it's readable but the decoupling is a problem
06:36:29 <Twey> Er
06:36:39 <chrisdone> Twey: is it?
06:36:41 <aristid> Twey: exactly.
06:36:42 <T_S_> Axman6: you have a good noob detector :-) thx
06:36:48 <Axman6> indeed ;)
06:36:55 <Axman6> i've been detecting noobs for a long time
06:36:59 <aristid> Twey: that's an advantage of python's .format
06:37:01 <chrisdone> what about: take n?
06:37:02 <yitz> mauke: but i wouldn't use it personally. take 20 is fine with me. only slightly longer, much cleaner.
06:37:02 <Axman6> since i was one :o
06:37:06 <Twey> It's better than: take 20 size ++ "  " ++ take 20 mTimeStr ++ "  " name ++ "\n"
06:37:11 <Twey> That's horrible
06:37:13 <Twey> aristid: What?
06:37:14 <T_S_> Axman6: noobdar?
06:37:17 <mauke> yitz: 20 is the minimum width, not a limit
06:37:25 <mauke> try again
06:37:33 <nostrand> T_S_: scalapack uses pblas which is a parallell blas =)
06:37:34 <yitz> mauke: hah! see - it
06:37:37 <Twey> aristid: No, the PEP cites the ability to mix positional and keyword arguments as the primary motivator behind .format()
06:37:46 <yitz> s been years since i used those :)
06:37:50 <aristid> Twey: language 1: "{0} {1}".format(...), language 2: "{1} {0}".format(...)
06:38:00 <chrisdone> concat [take n size,"  ",take x mTimeStr,"  ",name]
06:38:01 <chrisdone>   where n = 20; x = 20
06:38:06 <mauke> chrisdone: printf "%.*s" n str
06:38:11 <aristid> Twey: the formats are positional, but the language problem you cited is solved
06:38:17 <T_S_> nostrand: is that wrapped for haskell anywhere?
06:38:17 <Twey> aristid: Ah, right… that's not much better, though
06:38:17 <mauke> chrisdone: but this is about padding
06:38:28 <Twey> aristid: Yeah, fair enough, though then you have non-descriptive names
06:38:31 <chrisdone> mauke: s/take/pad
06:38:39 <nostrand> T_S_: i think you just can replace blas with plbas so i guess it would work =)
06:38:46 <chrisdone> the real problem is the decoupling
06:38:47 <mauke> chrisdone: where is pad defined?
06:38:55 <aristid> Twey: well, it's at least better than printf
06:38:56 <chrisdone> mauke: where is printf defined?
06:39:00 <mauke> chrisdone: Text.Printf
06:39:07 <chrisdone> someone had to write it then? omg
06:39:29 <mauke> chrisdone: comes with base
06:39:41 <chrisdone> so?
06:39:55 <mauke> so someone already wrote the code, and it's installed everywhere
06:40:10 <chrisdone> mauke: someone already wrote php and it's installed everywhere
06:40:18 <mauke> not here
06:40:27 <chrisdone> it's irrelevant
06:40:51 <mauke> if you want to argue about which version is cleaner, it matters
06:41:20 <chrisdone> i don't think an import statement mattters that much
06:41:23 <T_S_> nostrand: so you think it would run under hmatrix?
06:41:38 <nostrand> T_S_: hey, i just guessing here ;)
06:41:45 <mauke> chrisdone: it doesn't matter much, but which import statement are you talking about?
06:41:56 <T_S_> nostrand: guessing allowed
06:43:28 <nostrand> T_S_: i'm under the impression that you can choose whichever BLAS-implementation you want
06:44:01 <chrisdone> mauke: i don't consider "it's already written" a compelling argument for clean design
06:44:17 <mauke> chrisdone: the alternative is "you have to write it yourself"
06:44:24 <chrisdone> mauke: so?
06:44:51 <T_S_> nostrand: ill look into it thx
06:44:57 <yitz> > let minW n = take n . (++ replicate n ' ') in unwords [minW 20 size, minW 20 mTimeStr, name] -- still better than that printf thing in the eyes of this addicted Haskell programmer
06:44:57 <lambdabot>   Not in scope: `size'Not in scope: `mTimeStr'Not in scope: `name'
06:44:59 <mauke> that makes it a lot harder to argue that it's more readable/simple/whatever than printf
06:44:59 <nostrand> T_S_: perception.inf.um.es/~aruiz/darcs/hmatrix/hmatrix.pdf looks really nice =)
06:45:22 <mauke> yitz: that's pretty much terrible
06:45:35 <mauke> yitz: and it doesn't even do the same thing as the printf code
06:45:37 <yitz> mauke: a chacun son gout
06:45:54 <yitz> mauke: that's because I still don't remember exactly how to read the thing
06:46:00 <mauke> step 1: before posting a solution that doesn't use printf, make sure it actually works
06:46:18 * hackagebot supero 3.0 - A Supercompiler  http://hackage.haskell.org/package/supero-3.0 (NeilMitchell)
06:46:33 <yitz> mauke: true, but that would require doing man printf
06:46:59 * yitz yawns
06:47:07 <mauke> step 2: check if the solution is cleaner than the printf version
06:47:32 <yitz> mauke: clean = inverse number of line-noise characters
06:47:34 <dafis> step 0: clarify what you mean by 'cleaner'
06:47:36 <mauke> if you're going to post clean code that doesn't work, I'll give you an even better solution: ""
06:47:43 <mauke> doesn't get much cleaner than that
06:47:50 <yitz> mauke: yay! sold.
06:47:52 <dafis> I think opinions differ on that
06:48:28 <mauke> yitz: printf "%20s  %20s  %s\n" size mTimeStr name has two spaces between each item
06:48:32 <yitz> mauke: someone once said the same thing when i did a really nice Quine in Haskell here :)
06:48:32 <byorgey> ooh, supero release
06:48:42 <yitz> "" is the shortest quine
06:49:01 <mauke> yitz: your minW is wrong because it cuts off longer strings
06:49:23 <mauke> it also pads on the right
06:49:58 <chrisdone> mauke: as i said above the problem is the decoupling, so i'm not sure how providing an alternative makes it less of a problem
06:50:20 <mauke> what do you mean by decoupling?
06:50:33 <dafis> > let pad w s = replicate (w - length s) ' ' ++ s
06:50:34 <lambdabot>   not an expression: `let pad w s = replicate (w - length s) ' ' ++ s'
06:50:48 <dafis> @let pad w s = replicate (w - length s) ' ' ++ s
06:50:49 <lambdabot>  Defined.
06:50:51 <chrisdone> i mean decoupling
06:51:09 <mauke> between what?
06:51:12 <dafis> pad 20 "huh, was that so difficult"
06:51:16 <dafis> > pad 20 "huh, was that so difficult"
06:51:17 <lambdabot>   "huh, was that so difficult"
06:51:26 <mauke> > pad 20 "fff"
06:51:27 <lambdabot>   "                 fff"
06:51:50 <chrisdone> mauke: the format string and the values
06:52:17 <mauke> how is it a problem?
06:52:25 <T_S_> nostrand: i have seen that and tried it. will check on your interesting pblas suggestion. overall though is see no reason not to code optimization routines in haskell as long as the matrix-vector calcs are snappy. i did something similar with python/petsc/tao a while ago. the python called wrapped petsc/tao routines.  
06:52:57 <yitz> mauke: ah, ok. pad left. leave longer strings alone. got it.
06:53:21 <dafis> @type pad
06:53:22 <lambdabot> Int -> [Char] -> [Char]
06:53:28 <dafis> yitz: ^^
06:53:34 <dafis> already defined
06:53:38 <chrisdone> it's a problem because there is no guarantee of congruity
06:54:09 <mauke> chrisdone: it's a feature because you can see the shape of the output just by looking at the format string
06:54:23 <mauke> intercalate "  " [pad 20 size, pad 20 mTimeStr, name] ++ "\n"
06:54:34 <mauke> ^ I have to actually use my brain to decipher that
06:55:05 <chrisdone> mauke: i agree, that's a problem too
06:55:25 <mauke> or this one, from a real program: printf "\\x%02x" n
06:55:43 <chrisdone> i don't think lack of guarantee is a feature
06:55:58 <chrisdone> it's a problem
06:56:26 <mauke> anything better than "\\x" ++ pad 2 '0' (showHex n "") ?
06:56:31 <chrisdone> mauke: amusingly in this case i have no idea what that means, so i "have to use my brain" 
06:57:29 <yitz> mauke: right, that one comes up all the time
06:57:33 <mauke> I think you should learn more about printf
06:57:49 <mauke> yitz: it came up at least once
06:57:57 <chrisdone> mauke: irrelevant
06:58:20 <chrisdone> i'm not arguing that it's not more convenient to read, lack of guarantee is the problem. this is the last time i'll iterate this point
06:58:38 <nostrand> T_S_: ok =)
06:58:46 <mauke> lack of guarantee doesn't matter in practice
06:58:54 <chrisdone> if you say so
06:59:20 <mauke> well, in my experience
06:59:44 <mauke> printf parameter mismatches is simply not the kind of bug I'd write
07:00:52 <chrisdone> mauke: out of interest, do you experience problems with subtly incorrect format string syntax that doesn't signal an error?
07:01:06 <mauke> my point is: printf exists in many languages (C, Perl, Haskell, Python, ...), and sometimes it's a really good solution for a problem
07:01:10 <mauke> you should at least know the basics
07:01:19 <yitz> > let padHex n | n < 16 = ('0' :) . showHex n | otherwise = showHex n in foldr (padHex . fromEnum) "" "This is a ShowS version."
07:01:19 <lambdabot>   "5468697320697320612053686f77532076657273696f6e2e"
07:01:31 <mauke> chrisdone: no
07:01:35 <yitz> mauke: and yes, it assumes you won't have to truncate.
07:01:43 <chrisdone> i knew it in C but i haven't used it for years or encountered code with it
07:01:51 <chrisdone> (easy to forget)
07:02:20 <Cale> I usually have to go look up the documentation whenever I see a printf that has anything more complicated than %i in it. ;)
07:02:37 <mauke> hah, bad example
07:02:44 <tamiko> What have I done? :-D (I've solved my issue with the IncoherentInstances - LanguageExtension  - I know, this is ugly.)
07:02:46 <mauke> %i is one of the worse format specifiers
07:03:03 <yitz> agreed. I used it in C. Hardly ever in Python. Never in Haskell. Just my own style. When I encounter printf in your Haskell code, I won't complain, I'll just go to the man page and refresh my memory.
07:04:01 <Klump3n> golly
07:04:25 <mauke> chrisdone: you've made me think. do you have an example of incorrect format string syntax that doesn't error?
07:04:36 <i_am_neuron> Folks, still desperately need help with existential types. I can wrap the value of the inferred type in an aux data type, but can't unwrap it, getting "less polymorphic than expected" error message. Here's the whole code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26130#a26130
07:05:03 <yitz> Cale: as demonstrated earlier, I stuck at %s. Only reason I remember that one is because it was used so much in Python 2.
07:05:34 <Cale> i_am_neuron: You have to remember that when you wrap up a value in an existential, you are essentially "forgetting" all or part of its type. Its type represents all your permissions for working with that value.
07:05:38 <yitz> s/I/I'm/
07:05:46 <byorgey> i_am_neuron: yes, you are not allowed to unwrap an existential wrapped like that.
07:06:14 <byorgey> you can get out the IO a, run it, and do Foo-ish things with the 'a' value that is returned
07:06:18 <Cale> uw can't have type  forall a. (Foo a) => Wrap -> IO a
07:06:34 <byorgey> but you can't ever actually get your hands on the type 'a' anymore.
07:06:45 <Cale> because that means that *any* instance of Foo is allowed where all you have is *some* instance of Foo
07:07:57 <i_am_neuron> byorgey: Uh. Strangely, I have nearly the same code in two places in my main codebase (pastie is just an example to demonstrate the problem), and I could extract it like this in one place, whereas can't in another. Can't see any difference between them though. What would be the right way, anyway?
07:08:09 <chrisdone> mauke: hm, i don't know. i suppose that doesn't make sense. the bigger problem is writing one thing and meaning another and not finding out until runtime
07:08:10 <chrisdone> mauke: i use regular expressions for everything in other languages but it's convenient enough in haskell to use parsec. if i need to parse something pretty complex the parser gets bigger, but it may or may not be a good thing it's not in regexes anyway at that point. i've personally had subtle regex characters wrong here or there had it bite me in the ass later, and i think i'm pretty good with regexes, or maybe i'm just not as good a
07:08:10 <chrisdone> programmer as you. i wouldn't say no to a compile-time checked regex or printf
07:08:15 <byorgey> i_am_neuron: you can unwrap it as long as you immediately do something with it.
07:08:38 <byorgey> i_am_neuron: if the type of the result does not mention the existentially quantified type.
07:08:53 <mauke> chrisdone: compile time checked printf is trivial, just use $(printf "...") instead of printf "..."
07:09:08 <chrisdone> i know
07:09:27 <byorgey> i_am_neuron: so probably you should combine the unwrapping with whatever else you were going to do with the unwrapped value next, all into one function
07:09:28 <Cale> i_am_neuron: uw (Wrap ioa) = fmap doFoo ioa
07:09:47 <byorgey> yes, that would give you an IO String
07:09:57 <yitz> oh noes TH
07:10:12 <mauke> you could write a continuation based uw
07:10:44 <yitz> mauke: is there a regex package in Lisp that does fancy macro things?
07:10:48 <mauke> uw :: Wrap -> (forall a. (Foo a) => a -> b) -> b
07:10:51 <yitz> i would guess
07:11:07 <yitz> ditto printf
07:11:07 <mauke> hmm, wait
07:11:10 <mauke> needs more IO
07:11:27 <mauke> yitz: dunno about printf, lisp has its own FORMAT function
07:11:31 <Cale> i_am_neuron: In this specific case, I would recommend replacing the Wrap datatype with  data Wrap = Wrap (IO String),  since the only thing you've left yourself to do to the result of the IO action is to apply doFoo to it anyway.
07:11:59 <i_am_neuron> Cale: this is just a toy example I've extracted to help localize the issue
07:12:02 <Cale> yeah
07:12:04 <mauke> yitz: the only lisp regex package I know is http://www.weitz.de/cl-ppcre/#create-scanner2
07:12:33 <Cale> i_am_neuron: I'm just pointing out that existentials are often silly if the classes or types involved are simple enough.
07:13:14 <Cale> Records of functions are often much simpler to work with.
07:13:24 <Cale> (and they don't require any extensions)
07:14:53 <blalb> anyone here use patch tag.com for code hosting?
07:16:46 <blalb> and if so, has it been working for you recently?
07:19:04 <yitz> blalb: i would like to support them. haven't had a need yet though. why, have you been having problems?
07:19:37 <blalb> it wont recognize my login
07:19:50 <blalb> my repo also seems to be gone
07:20:09 <blalb> and acct creation isnt working now
07:20:23 <blalb> not sure if its only me or some global problem
07:20:35 <i_am_neuron> Cale: Here's the real code snippet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26130#a26131 Still can't see why having 'start' and 'run' functions is too restrictive for the type checker.
07:22:15 <i_am_neuron> Cale: not that for forkAccept he seems to do the same easily
07:22:24 <i_am_neuron> Cale: not -> note
07:23:29 <Cale> i_am_neuron: It's because there's no guarantee that p is of the right type to apply r to
07:23:58 <Cale> r is a function which takes parameters of some type which you know is an instance of Protocol
07:24:11 <Cale> p is a value of some type which you know is an instance of Protocol
07:24:15 <byorgey> blalb: hmm, I went to patch-tag and tried to sign in, and I just get a blank page
07:24:18 <Cale> There's no guarantee that those are the same type
07:24:32 <ivanm> Cale: see the ugliness I had to use to get GHC to accept label mapping in the new-style FGL: http://code.haskell.org/FGL/fgl/Data/Graph/Inductive/Graph.hs :s
07:24:46 <dafis> i_am_neuron, you'd need to make it data Runner = Runner (forall a. Protocol a => a -> whatever)
07:24:55 <blalb> thanks byorgey, that makes me feel a bit better. at least it isnt just me
07:25:25 <byorgey> blalb: what happens for you if you click "Public Repositories"?
07:25:41 <i_am_neuron> dafis: this is how it looks like now: data Runner = forall a . (Protocol a) => Runner (a -> IO ())
07:25:58 <Cale> ivanm: Hopefully typeclass synonyms will help tidy that up
07:26:09 <Cale> i_am_neuron: okay, so I guessed right
07:26:15 <ivanm> Cale: nah, the new type checker in 6.14 should help fix it
07:26:18 <Cale> i_am_neuron: Do you see the problem?
07:26:22 <ivanm> since we can shift the constraint stuff to the type class level
07:26:34 <dafis> i_am_neuron, and that's your problem, you need the runner to work with *all* protocols, not only with one
07:26:56 <blalb> byorgey: i get a blank page
07:27:01 <byorgey> blalb: ok, me too
07:27:37 <alexyk> can ghc-generated executable hit a GC doldrums?  I've made it work for processing Twitter data day by day; Clojure does all 35 days OK, while Haskell does the first 30 days faster yet then just sits in a 100% CPU loop, no RAM usage change around 47 GB.
07:27:54 <i_am_neuron> Cale, dafis: I see. So it seems like 'a' in Runner gets some value after type inference, and used later. Is this correct?
07:28:23 <byorgey> hmm, does Thomas Hartman hang out on here?
07:28:41 <alexyk> or, if -fvia-C better GC-wise?
07:28:42 <Cale> i_am_neuron: It's some specific type which is an instance of Protocol.
07:28:53 <i_am_neuron> And instead I need Runner to hold a type variable, that is sorta reinitialized (sorry for beginner's wording) for every instance of Runner
07:29:01 <Cale> i_am_neuron: But we have forgotten which one exactly.
07:29:22 <i_am_neuron> Cale: clear now
07:30:33 <Cale> i_am_neuron: dafis' suggestion was that you make it polymorphic
07:30:51 <i_am_neuron> After doing this I'm getting "Illegal polymorphic or qualified type"
07:31:15 <dafis> i_am_neuron, {-# LANGUAGE Rank2Types #-}
07:31:20 <Cale> i_am_neuron: If the Runner were to contain a polymorphic function that was able to work with any instance of Protocol, (at least that part of) your program would be fine
07:31:22 <dafis> I think
07:31:48 <alexyk> btw Haskell is not that much faster than Clojure
07:31:58 <alexyk> on the 10 GB data
07:32:15 <alexyk> JVM is not bad, it turns out
07:32:48 <alexyk> but, of course, it's a newbie program subject to improvement
07:32:49 <Cale> alexyk: It's gotten a lot better.
07:33:06 <Cale> At least, since the days when I used the JVM :)
07:33:31 <alexyk> Cale: the good thing, you give it -Xmx55g and you know it'll stay there :)
07:34:21 <alexyk> so processing giant Maps I am; are Tries any better RAM-wise for a long run emlarging them?
07:34:26 <alexyk> enlarging
07:34:29 <alexyk> gradually
07:36:52 <byorgey> blalb: I just sent an email to the patch-tag-users mailing list
07:37:06 <i_am_neuron> dafis: Ah, damn, this backfires: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26130#a26132 I have a place where I'm passing concrete type to Runner's constructor
07:38:39 * hackagebot network-multicast 0.0.6 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.6 (AudreyTang)
07:38:51 <MigoMipo>  Trying to learn Haskell, got " test1.hs:5:33: parse error on input `=' " with http://tullinge.pastebin.com/1JWGAYuG, how should it be written instead?
07:39:45 <nostrand> MigoMipo: use only one where
07:40:28 <nostrand> MigoMipo: and indent all where-clauses so they align
07:40:44 <dafis> MigoMipo, the two partition' must be indented to the same level
07:41:36 <dafis> MigoMipo, and partition' is a local function, so you mustn't give a global type signature for it
07:42:41 <Gracenotes> I find indenting with whitespace is better than indenting with tabs in haskell, not to mention
07:42:43 <yitz> alexyk: could be. it depends on the data. you would have to experiment.
07:42:57 <dafis> i_am_neuron, sorry, no immediate ideas
07:43:05 <Gracenotes> and I forget what the rules are when you combine them for some reason
07:43:07 <benmachine> yeah, tabs tend to confuse the layout machine
07:43:10 <yitz> tabs! tabs! oh, horror!!
07:43:13 <benmachine> ghc -fwarn-tabs
07:43:16 <Gracenotes> s/whitespace/spaces/
07:43:28 <mauke> tabs don't confuse the parser
07:43:33 <mauke> they might confuse you, though
07:43:36 <benmachine> heh
07:43:42 <dafis> benmachine, I want -ferror-tabs
07:43:44 <yitz> mauke: they confuse me even more than printf
07:43:51 <mauke> oh hoh
07:43:58 <benmachine> dafis: -fwarn-tabs -Werror :)
07:45:31 <dafis> benmachine, yes, but I would have to pass -fno-warn-type-defaults (and possibly a few other -fno-warn-benign-stuff)
07:46:07 <benmachine> heh
07:47:15 <benmachine> -fno-boring-warnings
07:47:31 <dafis> benmachine++
07:50:40 <Twey> They're nested wheres, nostrand
07:51:05 <Twey> Gracenotes: The rules for combining them are basically this: http://www.emacswiki.org/pics/static/TabsSpacesBoth.png
07:53:15 <tab> the tabs user looks so much cooler :)
07:55:50 <benmachine> heh
07:57:58 <Twey> Haha
07:58:24 <Twey> But the spaces user is a Man in Black!  Can't get much cooler than that.
07:59:57 <chrisdone> when Google Maps came out I felt like a MiB
08:00:20 <dafis> chrisdone: Why?
08:00:59 <chrisdone> dafis: haven't you seen it? at the end where he zooms in
08:01:15 <chrisdone> when did MiB come out? 98 or something?
08:01:27 <chrisdone> 1997, god damn
08:02:09 <dafis> chrisdone: I saw it once, a hundred years ago. Don't remember much of it.
08:02:39 <dafis> Nice, but not very memorable
08:05:02 <dv-> indeed
08:05:26 <gio123> l
08:11:30 <alexyk> if a program running doesn't respond to Ctrl-C, is it hosed?  I tried to profile the stuck executable, now it becomes stuck earlier, and doesn't Ctrl-C... will it leave a prof dump when kill'ed?
08:11:32 <byorgey> gio123: are you a bot?
08:12:21 <dafis> alexyk: when it's killed, it won't
08:12:35 <alexyk> dafis: with any signal?
08:12:47 <gio123> no
08:12:48 <gio123> :)
08:12:59 <gio123> passed turing test
08:13:00 <gio123> ?
08:13:01 <dafis> alexyk: Well, I've only tried 9 and 15
08:13:19 <mauke> what are 9 and 15?
08:13:40 <mauke> also, why do people insist on using unportable signal numbers instead of names
08:13:44 <dafis> alexyk: if it reacts to 15 at all, it doesn't generate a .prof
08:13:53 <dafis> mauke: SIGKILL and SIGTERM
08:14:09 <byorgey> gio123: ok, I just notice every now and then you just say a single letter, or someone's nick, it seemed a bit odd =)
08:14:54 <dafis> mauke: because I can remember the numbers, but not the names :)
08:15:16 <gio123> i am tetsing whether i am online
08:15:26 <gio123> i am using web client and it sucks
08:16:29 <mauke> dafis: the only one I can remember is 9
08:16:41 <mauke> dafis: and you know different systems use different numbers, right?
08:16:45 <hpc> gio123: use a lambdabot command, like @nixon
08:16:53 <gio123> ok
08:16:58 <hpc> you will get a response that way too, to check your ping
08:18:01 <dafis> mauke: I can remember 15 because it's top's default offering and yes, I know that the numbers aren't necessarily portable
08:19:00 <keep_learning> i am trying to add a list and wrote a program but getting lots of error
08:19:02 <keep_learning> http://pastebin.com/EydudNK8
08:19:05 <keep_learning> here is the code
08:19:11 <keep_learning> kindly tell me 
08:19:12 <alexyk> is there any significant GC imrovement in 6.12 vs 6.10?
08:19:23 <keep_learning> what is wrong with this code
08:20:00 <dafis> keep_learning, (p:ps) is a pattern that matches non-empty lists
08:20:05 <Gracenotes> also - guards needs booleans to live
08:20:27 <jmcarthur> keep_learning: you are confusing patterns and guards, i think
08:20:43 <jmcarthur> you are using [] in a guard as if it is a pattern
08:20:46 <Gracenotes> there are two main haskell ways for branching off into code, patterns and guards
08:20:55 <keep_learning> jmcarthur
08:20:57 <keep_learning> yes
08:21:26 <jmcarthur> keep_learning: instead of using guards you should be saying something like:   sum [] = 0; sum (p:ps) = ...
08:21:39 <keep_learning> so if i use length (p:ps) ==0 
08:21:52 <keep_learning> i can use this
08:21:54 <keep_learning> ?
08:22:18 <jmcarthur> you could, but i wouldn't do that
08:22:22 <dafis> keep_learning, don't use length list == 0, use null list
08:22:23 <Gracenotes> length (p:ps) is never 0
08:22:33 <Gracenotes> not under any circumstances
08:22:51 <keep_learning> k 
08:22:56 <Gracenotes> there are two things a list can be. either an empty list, or a list with an element attached to the rest of the list
08:23:08 <keep_learning> thank you dafis
08:23:12 <Gracenotes> so when you're breaking down a list, using recursion, you just need to look at both cases
08:23:22 <Gracenotes> that is all
08:24:25 <jmcarthur> @check \p ps -> length (p:ps) /= 0
08:24:26 <lambdabot>   "OK, passed 500 tests."
08:24:33 <jmcarthur> ^^ it's never going to be 0
08:24:45 <jmcarthur> that doesn't prove it, but i claim it anyway
08:25:19 <jmcarthur> Sadache: issues?
08:28:16 <dafis> Gracenotes, jmcarthur: length [1 :: Integer .. 2^64] == 0 -- but don't wait for it
08:29:42 <jmcarthur> dafis: on a 32 bit machine that wouldn't need such a wide range. it would even finish in reasonable time
08:30:02 <Gracenotes> oh, does the Haskell platform specify that overflow means wrap-around?
08:30:09 <Gracenotes> er, Haskell Report
08:30:12 <jmcarthur> dafis: then again, the result is 0 because Int sucks, not because the list is 0 length
08:30:26 <jmcarthur> Gracenotes: it only specifies that Int must have at least 30 bits
08:30:42 <jmcarthur> dunno about wraparound
08:30:51 <jmcarthur> but most machines wraparound anyway
08:31:05 <Gracenotes> my amazing optimizing compiler relies on the fact that I don't need to wrap-around ints, instead removing the user's home directory in the case of such an event
08:31:12 <dafis> Gracenotes, but wrap-around is most convenient, so it's a good bet that that's what's done
08:31:28 <hpc> Gracenotes: s/home/boot/ and you might be getting somewhere
08:32:14 <dafis> jmcarthur, right, length list doesn't necessarily return the length of the list
08:34:47 <mauke> dafis: that's not what happens in C, though
08:35:21 <dafis> mauke: implementation defined, iirc
08:35:27 <mauke> undefined
08:35:30 <Gracenotes> maybe if you turn the optimization up to 11
08:35:40 <mauke> gcc sometimes finds it most convenient to assume certain numeric properties (x > 0 && n > 0 ==> x + n > 0) in order to optimize code
08:36:17 <mauke> this can break code that relies on wraparound
08:37:29 <Gracenotes> for signed types though
08:38:00 <Gracenotes> er. I think that property might be trivially true for unsigned actually. at least if you use >=
08:38:16 <mauke> unsigned types wrap around (in C)
08:38:24 <mauke> it's only signed overflow that's undefined
08:45:13 <dafis> mauke: C99 standard, appendix H.2.2: "An implementation that deﬁnes signed integer types as also being modulo need not detect integer overﬂow, in which case, only integer divide-by-zero need be detected." I interpret that as implementation-defined rather than undefined
08:46:19 <mauke> I'd like to see a conforming C99 implementation
08:47:24 <dafis> mauke: So do I
08:47:53 <dafis> Sadache: Waht's up?
08:48:03 <dafis> s/WahT/What/
08:48:13 <dafis> s/T/t/
09:04:58 <XniX23> could anyone who read the haskell road give me some feedback?
09:09:55 <yitz> XniX23: the rwd?
09:15:10 <XniX23> yitz: whats rwd?
09:15:36 <yitz> XniX23: i'm trying to figure out what you meant by "the haskell road".
09:16:27 <etpace> How can I deduce the right value for infixl/r? I want say f a * g b * h c = (f a) * ((g b) * ((h c))), that is, its "weaker" than function application but it binds "all the way" to the right
09:18:24 <mauke> etpace: all operators are weaker than function application
09:18:33 <mauke> binding to the right is infixr
09:18:41 <XniX23> yitz: its a book
09:18:52 <etpace> aha
09:19:40 <mauke> hmm, function application is like infixl 10
09:20:08 <yitz> mauke: i think it's even defined as that somewhere. Report maybe?
09:20:40 <yitz> mauke: whereas :: is -1
09:21:40 <mauke> then what's -> ?
09:22:03 <mauke> record update is postfix 11
09:23:01 <yitz> > @type \f x -> f $ x :: String
09:23:02 <lambdabot>   <no location info>: parse error on input `@'
09:23:10 <yitz> @type \f x -> f $ x :: String
09:23:10 <lambdabot> forall a. (a -> String) -> a -> String
09:23:51 <yitz> mauke: ok, so -2
09:24:46 <yitz> mauke: wait, :: bound tighter than ->
09:24:57 <yitz> so -> is -2
09:33:06 <Twey> -> binds more tightly than ->
09:33:24 <Twey> Er
09:33:28 <Twey> Than ::
09:33:36 <Twey> Or you'd have to write foo :: (a -> b -> c) lest it be interpreted as (foo :: a) -> b -> c ☺
09:38:00 <JasonFelice> I'm working on getting Graphics.GD to work on Win32.  I've fixed compile errors, now I'm getting SEGV.  How do you debug such a thing?
09:38:13 <JasonFelice> gdb shows no stack frames.
09:41:19 <benc__> anyone want to help me figure out what I have done to my cabal install?
09:42:45 <benc__> i just had this misbehaving cabal 0.6 and so I did a cabal install and now have cabal-install version 0.8.2
09:42:53 <benc__> that tells me this:
09:42:54 <benc__> $ cabal install random-fu
09:42:54 <benc__> cabal: ?: does not exist
09:42:59 <benc__> for pretty much everything
09:44:21 <dv-> are you running the right cabal executable? (in ~/.cabal/bin)
09:44:43 <gwern> haha. that's an interesting error emssage
09:44:57 <benc__> i am
09:45:27 <benc__> that string "cabal-install version 0.8.2
09:45:32 <benc__> was a cut-and-paste from its --version
09:46:39 <benc__> i get same error for "update" but not for "help" -- help gives me a reasonable looking help message
09:48:11 <benc__> oh thats not a ?
09:48:19 <benc__> its hex 0x9a
09:49:25 <JasonFelice> Is hex 0x9a that weird WinCP 1521 open quote?
09:49:28 <kmc> this is a known mysterious bug
09:50:49 <benc__> (this is on osx, btw)
09:50:56 <benc__> mmm known mysterious bug
09:52:21 <JasonFelice> I can't get to my Linux box atm, someone willing to help me isolate if my SEGV is isolated to Windows or is another kind of issue?
09:52:46 <benc__> kmc: so any hints on making it go away?
09:53:00 <kmc> unfortunately no benc__ 
09:53:03 <benc__> ok
09:53:08 <kmc> i tried unsuccessfully to track it down a while back
09:53:18 <benc__> well then the earlier version of cabal is giving this different error message
09:53:25 <benc__> (to pop the stack to where i started)
09:53:56 <benc__> $ cabal install random-fu
09:53:56 <benc__> Resolving dependencies...
09:53:56 <benc__> cabal: Couldn't read cabal file "./storable-record/0.0.2/storable-record.cabal"
09:54:50 <benc__> (to pop the stack even more, all I want is a normally-distributed random floating point value ;)
09:58:16 <drautzburg> Is anybody here familiar with Paul Hudak's Euterpea System?
10:10:17 <b0fh_ua> Hello! With Parsec, how do I match the string "prefix_123" and extract "123", and skip "prefix_suffix" where suffix is not numeric? I tried : string "access_" >> TP.many TP.digit - but this matches also "access_count"
10:11:01 <Lemmih> b0fh_ua: TP.many1 ?
10:11:34 <danderson> and wrap the whole thing in 'try' if you want to try alternatives when you get a non-numeric suffix
10:11:53 <kmc> b0fh_ua, it shouldn't match "access_count", but it will match "access_" and leave "count" as the remaining unparsed string
10:12:23 <kmc> to require that the entire input is parsed, you can end with eof
10:12:38 <b0fh_ua> kmc: in fact if it doesn't match, I need it to fail parsing
10:12:40 <b0fh_ua> ah, okay
10:13:24 <b0fh_ua> kmc: excellent, thanks )
10:15:38 * ezyang was confused and thought rank-2 types produced existentials 
10:19:02 <jbapple> (forall e . C e -> r) -> r ?
10:26:21 <c_wraith> anyone around with hint experience?  I'm running into a problem I don't really understand, and could use some review from someone who knows the system.
10:27:25 <gwern> c_wraith: you didn't hpaste your error yesterday either
10:28:14 <c_wraith> I did, but it was quite a lot later than when I first asked the question.
10:28:22 <c_wraith> Like...  about 3 hours later.
10:28:54 <c_wraith> Now I can point you at the code itself, too!  http://github.com/chowells79/homepage/tree/master/src/
10:29:38 <c_wraith> and the error message is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26136#a26136
10:29:39 <gwern> and the error?
10:29:55 <gwern> runtime?
10:30:11 <c_wraith> Oh, running that code will require building heist from git.  mightybyte just applied my patches to it so that code will compile.
10:31:00 <c_wraith> yeah, it's a runtime compile error.  the fun of embedding a compiling interpreter! :)  That's the result of requesting "/" on a web server running that code.
10:32:42 <gwern> c_wraith: this is perhaps obvious, but why are so few modules being loaded?
10:33:32 <c_wraith> gwern: it should be the equivalent of using :load in ghci.  I can :load Site and everything works how I'd expect
10:34:05 <gwern> c_wraith: unless you've looked at the ghci code, I wouldn't be so sure
10:34:23 <gwern> c_wraith: the obvious thing to do is to take the module mentioned in the error and include it in the loaded modules list
10:34:31 <c_wraith> gwern: so obvious I tried it.
10:34:51 <gwern> and?
10:34:54 <c_wraith> It just resulted in error messages saying those modules were in installed packages, and couldn't be loaded.
10:35:12 <c_wraith> looking at the docs more closely showed that the loaded module list has to be *source* files.
10:38:05 <gwern> c_wraith: I think maybe setImports is better than loadModules
10:38:43 <c_wraith> I tried using setImports.  I don't remember how that didn't work.
10:39:22 <c_wraith> let me check...
10:40:04 <gwern> yeah, I use setImportsQ in mueval
10:40:13 <gwern> I only loadModule any specified .hs files
10:40:26 <c_wraith> NotAllowed "Could not find module `Data.Templating.Heist':\n  Use -v to see a list of the files searched for."
10:40:51 <c_wraith> err, that would be my fault
10:40:54 <c_wraith> as that's not what the module is
10:41:07 <gwern> heh. had me confused for a moment
10:41:50 <c_wraith> Ok...  Exact same compile error.
10:42:46 <c_wraith> after inserting  <<setImports [ "Snap.Types", "Text.Templating.Heist" ]>> on line 32 in HintSnap
10:43:21 <c_wraith> oh..  loadModules does a reset
10:43:30 <c_wraith> let me try moving it to *after* the loadModules
10:43:54 <inetic> hi, I'm confused about the "show :: String -> String" implementation, until now I believed its implementation is just the "show :: [a] -> String" where a is a String. But that should mean that the command 'putStrLn $ show "hello"' should output "['h','e','l','l','o']" but it outputs "hello". I myself was trying to differentiate between the types [a] and [Char] where a is anything but Char, but didn't know how, can someone plese explain?
10:44:23 <c_wraith> No change moving the setImports to after the loadModules
10:44:24 <inetic> "where a is a String" -> "where a is a Char"
10:44:49 <c_wraith> @src Show
10:44:49 <lambdabot> class  Show a  where
10:44:50 <lambdabot>     showsPrec :: Int -> a -> ShowS
10:44:50 <lambdabot>     show      :: a   -> String
10:44:50 <lambdabot>     showList  :: [a] -> ShowS
10:45:01 <c_wraith> initec: It's because Char overrides showList
10:45:25 <c_wraith> I don't know of any other type that doesn't use the default implementation of showList
10:45:42 <shajen> i have a file like this http://wklej.org/id/350165/ how can i read it ?
10:46:21 <gwern> c_wraith: odd. maybe you better take this to daniel; I think this should work with hint++ghc 6.10, but I've never used it under a more recent ghc
10:47:09 <inetic> c_wraith, sorry, I don't get it, in the source you showed me, there is no mention of Char
10:47:17 <c_wraith> gwern: hmm.  the email listed as the hint maintainer doesn't appear to be him.  What's the best way to reach him?
10:47:18 <dafis> c_wraith: and if you include Site in the setImports list?
10:47:48 <ezyang> inetic: String = [Char] 
10:47:53 <ezyang> > ['a', 'b', 'c'\] 
10:47:54 <lambdabot>   <no location info>: parse error on input `\'
10:47:59 <ezyang> > ['a', 'b', 'c'\ 
10:48:00 <lambdabot>   <no location info>: parse error on input `\'
10:48:04 <ezyang> fudge fingers today 
10:48:10 <ezyang> > ['a', 'b', 'c'] 
10:48:11 <lambdabot>   "abc"
10:48:18 <ezyang> :t 'a' 
10:48:19 <lambdabot> Char
10:48:20 <ezyang> :t "a" 
10:48:21 <lambdabot> [Char]
10:48:25 <c_wraith> ....  interesting.  if I include "Site" in the setImports, the error message changes.
10:48:52 <c_wraith> to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26136#a26138
10:49:05 <c_wraith> Note that it found the name site
10:49:28 <c_wraith> I might be more confused than ever, now.
10:49:37 <inetic> ezyang, yes, that's what I don't understand, 'show [1,2]' shows [1,2] but 'show ['a','b']' shows "ab" instead of ['a','b']
10:50:22 <ezyang> inetic: So, Show has a special function for showing lists of a 
10:50:36 <ezyang> which c_Wraith mentioned above 
10:50:44 <ezyang> its default is to just do the [foo, bar, baz] 
10:50:53 <ezyang> but Char has it overloaded 
10:52:16 <dafis> shajen: what do you mean "read it"? It's not valid Haskell syntax, so if you want to get a list of lists of Int from it, you'd have to write a (very simple) parsing function
10:52:32 <shajen> ok but how
10:52:52 <ezyang> inetic: Does that help? 
10:52:56 <inetic> ezyang, yes, and my question (probably not clearly stated before) is: how do I do the overloading, I had been tryint to make instances of my function foo which takes [a] as an argument, then I tried to add an instance of [Char] but ghc was complaining that the two instances overlap
10:53:39 <ezyang> right, so you can't (by default) rewrite existing instances, since there's not a way to make the old instance "go away" 
10:53:56 <ezyang> I forget if NoImplicitPrelude makes the other not appear 
10:54:29 <ezyang> The other difficulty is that an instance [a] will /always/ overlap with an instance a, since a = [a] 
10:54:44 <c_wraith> inetic, note that the whole "showList" thing is explicitly to *avoid* overlapping.
10:55:44 <dafis> shajen: for example, parseLL :: String -> [[[Int]]]; parseLL str = case dropWhile (/= '[') str of { cs -> case reads cs of { [(l1, rest)] -> l1:parseLL rest; _ -> [] } }
10:55:47 <c_wraith> it means that your Show instance for [a] isn't overlapped by an instance for [Char].  rather, the Show instance for Char does strange stuff.
10:56:36 <inetic> hmm, i don't see how showList is implemented in show (if so), maybe if I saw the source, could you please recommend where I can find it?
10:57:10 <ezyang> @src Show 
10:57:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:57:25 <c_wraith> ...  how did you make \bot error on that?
10:57:55 <ezyang> no idea... 
10:58:03 <dafis> @src showList
10:58:04 <lambdabot> Source not found. You untyped fool!
10:58:13 <ezyang> Maybe source view is broken 
10:58:16 <ezyang> @src fmap 
10:58:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:58:19 <dafis> Objection! I'm a typed fool!
10:58:29 <c_wraith> I *just* did @src Show, and it worked fine
10:58:35 <c_wraith> scroll up a couple pages
10:58:46 <ezyang> oh hey you did! 
10:59:00 <chrisdone> hey!
10:59:13 <c_wraith> chrisdone, you know something about hint, right?
10:59:23 <chrisdone> no
10:59:23 <yitz> ping Cale
10:59:51 <c_wraith> Hmm.  what did you use for tryhaskell, then?  mueval?
10:59:57 * Philippa just read the slides for http://www.galois.com/blog/2010/05/27/tech-talk-categories-are-databases/ - disappointed there's not more talk about things like natural transformations
11:00:01 <chrisdone> mhm
11:00:05 <c_wraith> ah, ok.
11:00:09 <Philippa> wondering if there's a paper or something forthcoming :-)
11:00:19 <ezyang> Philippa: I think there already was a paper 
11:00:28 <c_wraith> Philippa, there's a video of the presentation up now.
11:00:29 <ezyang> also, the talk video is up \o/ 
11:00:43 <ezyang> http://www.uoregon.edu/~dspivak/cs/SD.pdf 
11:00:54 <Philippa> c_wraith: yeah, I'm assuming it doesn't include worked examples not in the slides though?
11:01:19 <c_wraith> that is doubtful.  I guess you want the paper ezyang linked to
11:01:39 <Philippa> *nod* - taking a peek. I think I've skimmed it before
11:01:40 <ezyang> I was at the talk; natural transformations were briefly discussed as schema migrations 
11:01:57 <Philippa> ezyang: yeah, I figured out that's what they are for myself :-)
11:02:04 <ezyang> Cool :-) 
11:02:16 <Philippa> I just wanted to see some worked examples of what that tells you about how to perform them
11:02:27 <c_wraith> wait, was that talk in pdx?  ezyang, are you in pdx?
11:02:38 <inetic> c_wraith, ezyang, I've found the source, hopefully I'll get it :-), thanks for your time
11:02:48 <ezyang> c_wraith: Yep, interning at Galois. 
11:03:05 <ezyang> inetic: I've always found Show kind of willfully obtuse 
11:03:09 <c_wraith> then...  why are you inside on such a nice day?  (don't ask me the same.) :P
11:03:24 <yitz> inetic: showList is a method. so you can implement it differently for each type. if you don't, it takes the default method definition.
11:03:33 <ezyang> (Briefly: I biked 8 miles yesterday, so I'm taking the day off) 
11:03:38 <Philippa> you don't have to be inside to be on IRC these days, anyway
11:04:01 <c_wraith> it's so bright out there I wouldn't be able to read an LCD screen
11:04:05 <inetic> yitz, I see, thanks
11:05:11 <benc__> frrr
11:05:22 <benc__> hackage db doesn't work with cabal 0.6 and cabal 0.8 doesn't work with my laptop
11:05:54 * benc__ starts deleting package descriptions from local hackage index
11:06:21 <ezyang> benc__: Sounds like it's time to delete your Cabal and start over. 
11:06:30 <dafis> benc__, whut, hackagedb doesn't work with cabal-0.6?
11:06:34 <benc__> ezyang: I removed the three versions of storable-record
11:06:37 <benc__> ezyang: and it works
11:06:41 <ezyang> whoo 
11:06:48 <benc__> seeems to not like whats in there
11:06:56 <benc__> with the error message i pasted hour ago
11:07:24 <benc__> assuming i've not screwed up something else
11:07:32 <benc__> so much random hacking at things to make things happen
11:07:49 <c_wraith> ... Wait.  I just noticed something.
11:08:11 <benc__> ezyang: this:
11:08:12 <benc__> $ cabal install random-fu
11:08:12 <benc__> Resolving dependencies...
11:08:12 <benc__> cabal: Couldn't read cabal file "./storable-record/0.0.2/storable-record.cabal"
11:08:23 <dafis> benc__, it doesn't like what's in there because it shouldn't be in there
11:08:23 <ezyang> lol 
11:08:24 <benc__> i get it for 0.0.2, 0.0.2.1 and 0.0.2.2
11:08:30 <benc__> dafis: heh
11:08:38 <dafis> I thought that had been fixed, though
11:08:49 <benc__> i've done a bunch of updates in the last 3h
11:08:58 <benc__> so it should have pulled down whatever is latest
11:09:24 <c_wraith> gwern, dafis: the fully-qualified names the compile error is complaining about are *not* the names used in my code.  They're the module names the types are actually defined in, neither of which is a public module.  I think that's related.
11:10:08 <benc__> cabal install always seems to be such an adventure forme
11:12:33 <dafis> benc__, specifically, the "Tested-With:         GHC==6.8.2 && ==6.10.4 && ==6.12.1" makes cabal choke
11:12:52 <benc__> ok
11:13:06 <c_wraith> I'm certain that's related.  I think this might be a case hint has never had to deal with before.
11:13:32 <benc__> dafis: removing them from db seems to work for me so far ;)
11:13:35 <c_wraith> let me mangle my local versions of heist and snap-core some more...
11:13:40 <benc__> now it seems i need to upgrade my ghc
11:13:45 <benc__> to make primitive build
11:14:09 <dafis> benc__, yes, if there are no other malformed cabal files in the db, that works :)
11:14:16 <benc__> dafis: yeah seems to be the case
11:14:50 <dafis> benc__, back to earlier, why doesn't cabal-0.8 work on your box?
11:15:40 <benc__> that was the ? error.
11:15:45 <benc__> i pasted hour ago maybe
11:15:50 <benc__> wait a sec
11:16:18 <benc__> $ cabal install foo
11:16:19 <benc__> cabal: ?: does not exist
11:16:23 <benc__> that error for pretty much everything
11:16:37 <benc__> although help works and list gives a segfault
11:17:18 <benc__> where the ? is hexcode 0x9a
11:17:41 <benc__> kmc syaid its a known bug
11:18:21 * benc__ spins the macports wheel and sees what version of ghc he ends up with
11:18:23 <dafis> benc__, then that's probably true
11:18:46 <c_wraith> If this works...  I don't know what the solution is.
11:19:34 <dafis> c_wraith, will you know what the solution is if it doesn't work?
11:22:32 <c_wraith> dafis: I'll be totally clueless if it doesn't work.  If it does work, I'll at least know what the problem is.
11:22:58 <c_wraith> of course, first I have to hack .cabal files and reinstall lots of stuff
11:23:24 <dafis> good luck
11:24:56 <c_wraith> Woo!  it may have worked!  (turns out I also upgraded my snap version in such a way as to break the action.  Now I need to fix real compile errors.)
11:25:16 <zygoloid> is there a nice composable way to write Storable instances? (using Binary instances maybe?)
11:26:06 <shajen> why unwords readFile "file" dont work?
11:26:20 <ezyang> zygoloid: storable? 
11:26:25 <zygoloid> ezyang: Foreign.Storable
11:26:39 <ezyang> zygoloid: I mean, the hackage package :-) 
11:26:50 <dafis> shajen, readFile "file" is IO String, unwords needs a String
11:26:53 <ezyang> storable-record is the full name 
11:27:01 <shajen> dafis: how to convert it?
11:27:10 <hpc> you don't convert it
11:27:15 <ezyang> > unwords <$> return "foo bar" 
11:27:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:27:16 <lambdabot>         against inferred ty...
11:27:48 <hpc> > words <$> return "foo bar"
11:27:49 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Base.String]))
11:27:49 <lambdabot>    arising from a use...
11:27:59 <hpc> > words <$> Just "foo bar"
11:28:00 <lambdabot>   Just ["foo","bar"]
11:28:38 <dafis> shajen, Not. But you can get at it inside the IO action; do { txt <- readFile "file"; let { wds = words txt }; print (something with wds) }
11:28:52 <hpc> shajen: how much do you know about IO?
11:29:53 <kmc> shajen, http://haskell.org/haskellwiki/Introduction_to_IO
11:30:10 <c_wraith> huh.  it's strangely half-working-only...  But the problem is in how hint handles types defined in hidden modules and re-exported from non-hidden modules.
11:30:44 <shajen> i want to read from file list and run function with this list as argument
11:31:07 <kmc> do { x <- readFile "file"; return (unwords x) }
11:31:16 <kmc> though there are more concise ways like the <$> operator described above
11:31:22 <zygoloid> ezyang: thanks, looks interesting (though the haddocks could do with an example of how it's supposed to be used!)
11:31:49 <kmc> the closest thing you'll find to a way to convert (IO T) to T is the <- within a "do" block
11:32:01 <kmc> but that's not really an accurate description of what's going on
11:32:13 <kmc> shajen, you can't convert IO String to String because they're not even remotely similar types
11:32:28 <ezyang> fair enough 
11:32:52 <shajen> ok but how can i convert list from file to normal list
11:33:11 <ezyang> Hey guys, I'm reading the Tagless paper, and when they present their solution in 1.3, which is just represent the language with ordinary functions, I can't but help to feel like they're, ehm, cheating slightly. 
11:33:11 <aristid> @undo do { x <- readFile "file"; return (unwords x) }
11:33:12 <lambdabot> readFile "file" >>= \ x -> return (unwords x)
11:33:14 <kmc> "IO String" does not represent "string from a file"
11:33:24 <aristid> @pl readFile "file" >>= \ x -> return (unwords x)
11:33:25 <lambdabot> unwords `fmap` readFile "file"
11:33:28 <kmc> it represents "recipe which *would* give you a string"
11:33:54 <aristid> lambdabot: you could use <$> for nicer syntax
11:34:23 * ezyang imagines a tutorial/comic on IO that involves chefs passing around recipes to figure out what meal they want to make, and then ending in dinner. 
11:35:25 <ezyang> i.e. "Well, if ze diner thinks zat the dish is too hot, we will serve him cold cucumber soup (brandishes the cold cucumber recipe) before we continue zis meal!" 
11:35:38 <kmc> so you can't convert an IO String to a String any more than you can convert a recipe to a cake
11:36:09 <kmc> you "convert" by running the action
11:36:17 <kmc> and since "main" is the only action which actually gets run
11:36:30 <kmc> you typically do this by gluing together smaller actions using "do", or (>>=) etc.
11:37:18 <Philippa> ezyang: what's wrong with representing the language as functions? If you want to pattern-match on them for some reason then you can instantiate that with a datatype as appropriate
11:37:39 <Philippa> the point is that you basically never actually need to do that
11:38:26 <ezyang> Philippa: I mean, sometimes having an AST in memory is useful, no? 
11:38:44 <hpc> ezyang: that comic sounds like something BONUS would use
11:38:50 <Philippa> yeah, but having the polymorphic 'constructor' call tree is just as good
11:39:21 <quasimodo_> hi
11:39:26 <kmc> hi quasimodo_ 
11:40:06 <quasimodo_> can somone tell me if it is possible to create one instance of a type class for all instances of another type class
11:40:09 <quasimodo_> ?
11:40:10 <Philippa> ezyang: if you've got that, you can instantiate it per whatever you want to take back out - in other words, with your preferred coalgebra. You get 'constructors' because there's a /final/ coalgebra, hence the paper title
11:40:34 <ezyang> Philippa: Oh I see; I haven't gotten that far in the paper yet! :-) 
11:40:41 <dafis> quasimodo_, like instance Foo a => Bar a where ?
11:40:52 <quasimodo_> exactly
11:40:52 <ezyang> hpc: We should make it happen :-) 
11:40:59 <quasimodo_> does this work?
11:41:08 <dafis> quasimodo_, yes and no.
11:41:09 <ezyang> quasimodo_: Yes, but it tends to result in overlapping instances 
11:41:28 <ezyang> and *usually* if that were the case, the requirement would have been encoded in the original formulation of the typeclass 
11:41:32 <dafis> quasimodo_, it means you can't have any other instances without much fuss
11:41:55 <ezyang> erm, the other way around 
11:42:03 <ezyang> since this means Foo is striclty more powerful than Bar 
11:42:08 <ezyang> *possibly 
11:42:24 <quasimodo_> hm
11:43:00 <ezyang> Typed fold function over a typed term! Impressive! 
11:44:01 <quasimodo_> but only if i want to create an seperate Bar instance for a type that is already an instance of foo, right?
11:44:23 <ezyang> "some of our claims are more obvious in Haskell" :^) 
11:47:52 <dafis> quasimodo_, instance Foo a => Bar a where ... means you have an instance declaration for Bar matching all types. If you try to call a method of Bar on a type which is not an instance of Foo, you'lle get a compile error
11:47:54 <quasimodo_> oh, i think i overread something :)
11:48:35 <dafis> But if you try to declare *any* further instance of Bar, you'll have an overlapping instance
11:48:37 <quasimodo_> oh
11:48:57 <dafis> and overlapping instances are dangerous territory
11:49:24 <dafis> which must be specifically entered via a language extension
11:51:02 <dafis> @quote overlapping instances
11:51:02 <lambdabot> No quotes for this person.
11:51:18 <dafis> @quote quicksilver overlapping instances
11:51:18 <lambdabot> No quotes match. Do you think like you type?
11:53:20 <quasimodo_> yes, i read about that
11:55:33 <alexyk> is there a lib function: x:_ -> Just x, [] -> Nothing?
11:55:50 <dafis> alexyk, listToMaybe
11:55:54 <alexyk> kk
11:56:44 <dafis> Data.Maybe
11:57:14 <monochrom> isn't haskell exciting? :)
11:57:27 <kmc> @hoogle [a] -> Maybe a
11:57:27 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
11:57:27 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:57:27 <lambdabot> Prelude head :: [a] -> a
11:57:33 <i_am_neuron> I'm using forkIO to spawn a new lengty computation (actually, listen to a socket in a separate thread), but the main process dies immediately after the thread spawn. Is it normal?
11:57:43 <kmc> i_am_neuron, all threads die when "main" dies
11:57:56 <i_am_neuron> How to prevent this?
11:58:03 <aristid> alexyk: more general would be Data.Foldable.foldr ((<|>) . pure) empty
11:58:05 <i_am_neuron> Something like join()
11:58:16 <Zao> Wait on a few mvars.
11:58:26 <monochrom> The end of the doc of Control.Concurrent has examples.
11:58:27 <kmc> i_am_neuron, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26139#a26139 here's my recipe for it
11:58:43 <kmc> if you use spawn instead of forkIO
11:58:48 <alexyk> aristid: interesting
11:58:58 <kmc> then the result you get back is an action
11:59:01 <quasimodo_> dafis: can i declare further instances of Foo?
11:59:02 <kmc> which will wait for the thread you just spawned
11:59:12 <aristid> :t Data.Foldable.foldr ((<|>) . pure) Control.Applicative.empty
11:59:13 <lambdabot> forall (f :: * -> *) a (t :: * -> *). (Alternative f, Data.Foldable.Foldable t) => t a -> f a
11:59:29 <kmc> i.e.
11:59:30 <i_am_neuron> kmc: I see, looks nice, though a bit hackish
11:59:39 <kmc> do { x <- spawn a;  do other stuff;  x }
11:59:41 <dafis> quasimodo_, yes, it's only Bar that's problematic
11:59:42 <kmc> you can get the result back too
11:59:45 <kmc> hackish how? ;P
12:00:03 <i_am_neuron> kmc: this mvar is not really necessary, i.e. you don't store anything there
12:00:08 <kmc> no
12:00:12 <kmc> i store the result of the forked computation
12:00:15 <kmc> which might be meaninful
12:00:17 <quasimodo_> ok, than thanks for the help :)
12:00:29 <i_am_neuron> kmc: aha, I see. I thought it's merely a syncronization primitive
12:00:39 <kmc> this way you can fork off e.g. an asynchronous HTTP request and get the result later
12:00:49 <dafis> i_am_neuron, it would be useful as such already
12:00:55 <i_am_neuron> kmc: exactly my task. Thanks a ton
12:00:58 <kmc> yes, you might use this at type IO ()
12:01:06 <kmc> in which case the MVar stores Either SomeException ()
12:01:12 <kmc> anyway
12:01:22 <kmc> there are real libraries on hackage to solve this problem
12:01:22 <i_am_neuron> :)
12:01:33 <kmc> like async and threads
12:01:59 <kmc> and which do more than my little example
12:03:43 <monochrom> I have embraced the unification of synchronization and communication. They are the same. So MVar used as "merely sychronization primitive" is not hackish. In fact, the opposite: artificial division between synchronization and communication is hackish.
12:04:38 * dafis nods
12:06:07 <kmc> MVar () is a bit like Maybe ()
12:06:27 <kmc> for which i also find use on occasion
12:08:43 <alexyk> how do I smartly write a function: x (Just y) -> max x y; x Nothing -> x --?
12:09:49 <dafis> alexyk, maybe x (max x)
12:10:07 <alexyk> ah, that's what it's for exactly
12:10:15 <kmc> :t \x -> maybe (const x) (max x)
12:10:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
12:10:16 <lambdabot>     Probable cause: `max' is applied to too many arguments
12:10:16 <lambdabot>     In the second argument of `maybe', namely `(max x)'
12:10:26 <kmc> :t \x -> maybe x (max x)
12:10:27 <lambdabot> forall b. (Ord b) => b -> Maybe b -> b
12:10:53 <kmc> ah i see
12:10:58 <clanehin> const if you're using either
12:12:23 <c_wraith> :t maybe `ap` ?f
12:12:24 <lambdabot> forall b a. (?f::b -> a -> b) => b -> Maybe a -> b
12:12:33 <shajen> what functions give from [a,b,0,c,0,d,e] -> [[a,b],[c],[d,e]] ?
12:12:54 <c_wraith> :t ap maybe
12:12:55 <lambdabot> forall b a. (b -> a -> b) -> b -> Maybe a -> b
12:13:21 <aavogt> > a == 0
12:13:22 <lambdabot>   False
12:13:44 <kmc> shajen, that's a very strange thing to do
12:13:52 <aavogt> > groupBy (\a b -> a == 0) [a,b,0,c,0,d,e]
12:13:53 <lambdabot>   [[a],[b],[0,c,0,d,e]]
12:13:58 <aavogt> > groupBy (\a b -> b == 0) [a,b,0,c,0,d,e]
12:13:59 <lambdabot>   [[a],[b,0],[c,0],[d],[e]]
12:14:18 <clanehin> shajen wants generics words
12:14:28 <clanehin> *generic
12:14:34 <kmc> there's the "split" package on hackage
12:14:45 <dafis> > groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,d,e]
12:14:46 <lambdabot>   [[a,b],[0],[c],[0],[d,e]]
12:15:00 <shajen> >splitAt 5 [1,2,3,4,5,6,7,8,9,10] 
12:15:04 <shajen> > splitAt 5 [1,2,3,4,5,6,7,8,9,10] 
12:15:05 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
12:15:06 <c_wraith> > ap maybe max 5 $ Just 10
12:15:07 <dafis> and then filter (\(x:_) -> x /= 0)
12:15:07 <lambdabot>   10
12:15:25 <c_wraith> > ap maybe max 5 $ Just 3
12:15:26 <lambdabot>   5
12:15:31 <c_wraith> > ap maybe max 5 $ Nothing
12:15:32 <lambdabot>   5
12:15:51 <clanehin> > filter (/= 0) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,d,e]
12:15:52 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
12:15:52 <lambdabot>    arising from the lite...
12:16:01 <dafis> shajen: But there are such functions defined in the split package: http://hackage.haskell.org/package/split
12:16:06 <c_wraith> woo!  I found a real-life use of the S combinator. :)
12:16:21 <clanehin> I don't know what lambadbot is about with that
12:16:26 <aavogt> clanehin: missing head
12:16:50 <aavogt> > filter (/= [0]) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,d,e]
12:16:51 <lambdabot>   [[a,b],[c],[d,e]]
12:17:12 <dafis> > filter (/= [0]) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,0,d,e]
12:17:12 <clanehin> aavogt: thx
12:17:13 <lambdabot>   [[a,b],[c],[0,0],[d,e]]
12:17:20 <aavogt> > filter ((/=) 0 . head) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,0,d,e]
12:17:21 <lambdabot>   [[a,b],[c],[d,e]]
12:17:32 <dafis> > filter ((/= 0) . head) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,0,d,e]
12:17:33 <lambdabot>   [[a,b],[c],[d,e]]
12:18:12 <dafis> aavogt, you're too fast for this old man :(
12:18:47 <aavogt> any  probably looks safer
12:18:57 <alexyk> dafis: like this:
12:18:59 <aavogt> > filter (any (/= 0)) $ groupBy (\a b -> (a == 0) == (b == 0)) [a,b,0,c,0,0,d,e]
12:18:59 <lambdabot>   [[a,b],[c],[d,e]]
12:19:01 <alexyk> > let x = 3 ; y = Just 4 in maybe x (max x) y
12:19:02 <lambdabot>   4
12:19:45 <alexyk> dafis: old man being the bot? :)
12:20:02 <dafis> alexyk, no, I
12:20:24 <clanehin> use take 1 blah /= [0]
12:20:29 * hackagebot storable-record 0.0.2.3 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2.3 (HenningThielemann)
12:20:39 <dafis> aavogt, groupBy doesn't put any empty lists in its result, so head is safe there
12:20:51 <aavogt> hence the "looks"
12:21:03 <aavogt> dafis: it's more work when reading the code
12:21:05 <alexyk> dafis: maybe usage correct?  ^^
12:21:43 <dafis> aavogt, what is more work, head?
12:22:07 <clanehin> head is a lot of work down the road, because I get an error and I have to grep for it
12:22:28 <clanehin> and burn brain cells whether I've proved its safe or not
12:22:30 * hackagebot ad 0.44.3 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.44.3 (EdwardKmett)
12:22:30 <aavogt> to have to check/remember that group never puts any empty lists in the list
12:22:47 <dafis> alexyk, which maybe usage, I didn't see it
12:24:43 <dafis> alexyk, Ah, just saw it, yes, correct
12:25:43 <alexyk> kk
12:29:37 <djahandarie> edwardk, do you ever use category-extras in your other packages?
12:30:18 <edwardk> djahandarie: quite a bit, though i admit, the sheer size of it is why i need it refactored ;)
12:30:48 <edwardk> djahandarie: i try not to use it much in what i upload to hackage because people dont' appreciate the huge dependency
12:30:56 <djahandarie> I think the only place I've seen it used is in FRP
12:31:23 <djahandarie> If you were to refactor it what would you be taking out?
12:31:35 <edwardk> djahandarie: not taking anything out, just splitting it several ways
12:32:05 <edwardk> functors, monads, comonads, categories, recursion-schemes, and then the hairier versions of each go into a -extras version of each of those for instance.
12:32:44 <djahandarie> I see
12:32:59 <edwardk> so importing comonads provides you the definitions you'd expect, but importing comonad-extras would give you the complicated definition of cofree suitable for use with the recursion-scheme-extras definition for g_bicata or something
12:33:33 <djahandarie> You should write an "intro to using category-extras" post
12:33:35 <danharaj> has the type system yet given up and died on you edwardk?
12:33:50 <edwardk> several times ;)
12:34:31 <danharaj> One day GHC will just say "Error: WHAT IS THIS I DONT EVEN"
12:34:36 <djahandarie> Haha
12:34:53 <Twey> Hahaha
12:34:57 <edwardk> danharaj: it has given the 'my brain has exploded' error message a few times ;)
12:35:06 <edwardk> i took it as a complement
12:35:10 <edwardk> er compliment
12:35:16 <Twey> edwardk: Wow, how'd you manage that?  :þ
12:35:28 <dolio> Lazy match against existentials.
12:35:35 <edwardk> Twey: something involving colimits and the fact that some existential escaped a let binding
12:35:40 <Twey> Heh, nice
12:36:45 <edwardk> i still remember when dolio threw up his hands at me and said, 'why don't you just replace category-extras with your code' -- little did he know the can of worms he was opening ;)
12:37:16 <dolio> Well, it turned out better for me than trying to replicate all the stuff you've done.
12:37:24 <edwardk> hah true =)
12:41:04 <Twey> Haha, I mistyped ‘rankntypes’ in Google (as ‘randntypes’) and it gave me a suggestion: ‘Did you mean: randy types’
12:41:47 <edwardk> i do not know what possessed me to think that writing interval arithmetic code in haskell would be fun.. gah too many corner cases
12:42:18 <jmcarthur> edwardk: yeah i started that once and quit very quickly
12:42:22 <edwardk> ad code for cos is 1 line. interval code for cos is 13
12:42:35 <edwardk> jmcarthur: well, i have all the rounding code in, so i might as well finish it ;)
12:42:56 <edwardk> jmcarthur: the instance for Floating is hellish though
12:42:57 <danharaj> don't you mean...
12:43:04 <danharaj> 'edge' cases :p
12:43:33 <edwardk> danharaj: edges are easy, its the corners that get you ;)
12:43:50 <danharaj> what kind of interval has a corner :p
12:45:00 <edwardk> Well, usually an 'edge case' is right when you are at one extrema or another in your input, some phase transition is occurring. a corner case is when a bunch of stuff conspires against you. ;)
12:45:17 <danharaj> I was making a pun god :D
12:45:38 <jmcarthur> danharaj worships the pun god
12:45:48 <danharaj> puns for the pun god
12:45:53 <edwardk> we have a lot of corner cases in interval arithmetic. i.e. cos has to deal with subsuming a full cycle, various reflections, etc. all sorts of rounding mode flips, etc.
12:46:09 <edwardk> danharaj: i realized =)
12:46:54 <shajen> main2 file = do text <- readFile file return text
12:47:04 <shajen> why it dont work?
12:47:25 <dafis> shajen, it must be on two lines
12:47:38 <shajen> i have
12:47:48 <dafis> the binding, text <- readFile file on the first
12:47:52 <shajen> when i past it was done
12:47:56 <illissius-> main2 file = do { text <- readFile file; return text }
12:48:12 <djahandarie> Also, that is the same as... main2 file = readFile file
12:48:38 <dafis> and the second, return text, on the next, so that the first 'r' of return is aligned with the first 't' of text
12:48:56 <shajen> i get http://wklej.org/id/350264/
12:49:12 <dafis> shajen, do you know about indentation/the layout rule?
12:49:22 <shajen> no
12:49:52 <mauke> shajen: why are you trying to print a function?
12:49:53 <djahandarie> shajen, you aren't showing us the code that is actually erroring.
12:50:32 <shajen> mauke: no... where?
12:50:45 <shajen> djahandarie: ok
12:50:52 <mauke> shajen: you didn't tell us where
12:51:02 <djahandarie> shajen, line 1? :P According to that error message
12:51:05 <mauke> and "no" doesn't answer "why"
12:51:09 <dafis> shajen, that's what the error is saying
12:51:11 <jmcarthur> a corner case is when you have two intersecting edge cases ;)
12:51:32 <djahandarie> The topology of cases
12:51:44 <djahandarie> I have a Mobius case
12:52:48 <djahandarie> Topology is surprisingly very close to category theory
12:52:55 <shajen> oh i forget about argument :|
12:52:57 <shajen> sory :)
12:53:06 <dolio> It's not that surprising, is it?
12:53:12 <edwardk> jmcarthur: euclidean problem geometry: for every two edges in a problem, either they are parallel or they meet at a corner case.
12:53:27 <djahandarie> dolio, well, what was suprising was how close it was, not that it is just close
12:53:31 <edwardk> the projective geometry is more realistic though: for every two edges in a problem, there exists a corner case ;)
12:53:36 <krey> can anyone tell me what join is for Cont?
12:53:42 <krey> I mean explain it
12:54:01 <shajen> i'm not good in haskell and also in english :)
12:54:19 <dolio> djahandarie: I mean category theory grew out of topology.
13:04:34 <alexyk> if an executable bails with "stack overflow", what are the reasons in Haskell?
13:05:06 <dafis> alexyk, you've built a too large thunk somewhere, probably
13:05:39 <alexyk> dafis: how can I know where?
13:06:14 <dafis> alexyk, profiling, looking at the code, or letting somebody else look at the code
13:06:23 <alexyk> dafis: ok :)
13:06:40 <hpc> a good place to start is recursive algorithms
13:06:59 <hpc> see if you can make them tail-recursive or strict
13:07:23 <dafis> folds are a common source for stack overflows
13:07:46 <hpc> they are also the easiest to fix; change foldl to foldl', for example
13:13:20 <alexyk> I already have only fodl', but I walk huge Maps and those are done with Map.foldWithKey; dunno how those do
13:14:12 * alexyk throws in a quick -K5G after already cozy -A10G
13:15:01 <dafis> alexyk, Map.foldWithKey might be too lazy
13:15:48 <dafis> alexyk, perhaps you have to pass it a stricter version of the folding function
13:15:53 <alexyk> dafis: I tried to employ foldrWithKey in 6.12, but my big server has only 6.10 at the moment, so I had to settle on that one
13:16:32 <dafis> alexyk, foldWithKey === foldrWithKey
13:16:46 <alexyk> dafis: hmm, I thought it's the good one
13:17:13 <dafis> I meant, instead of foldWithKey f, use foldWithKey stricterf
13:18:13 <dafis> where stricterf x y z = x `seq` y `seq` z `seq` f x y z or so
13:19:41 <alexyk> dafis: ok
13:21:25 <ryo_hazuki> heyho guys... i googled around a bit but coudn't find good examples for bottom-up dynamic programming in haskell
13:21:43 <ryo_hazuki> so i thought it would be nice to have examples on hpaste (my favorite resource)
13:21:45 <ryo_hazuki> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26144
13:22:11 <ryo_hazuki> please feel free to add examples to the paste, it would probably help a lot of people =)
13:23:53 <kmc> i think it's easiest to understand DP as memoized recursion
13:24:00 <kmc> and use e.g. data-memocombinators to abstract that part out
13:24:23 <ryo_hazuki> woudn't that be the top-down approach of dp?
13:24:49 <kmc> i'm not sure
13:25:01 <ryo_hazuki> as the memocombinators provide functions for memoizing the function calls/results
13:25:01 <kmc> does bottom-up allow you to solve a different set of problems?
13:25:30 <ryo_hazuki> bottom-up allows to solve the subproblems of a problem (if it fits the substructure)
13:26:02 <ryo_hazuki> and up on those results you solve a specific problems by (for example) adding all results to the problem you were looking for
13:26:06 <alexyk> hpaste suggests git to clone it from code.haskell.org! not darcs minds you!  treason!
13:26:08 <ryo_hazuki> thats the way i undertood it
13:26:12 <illissius-> anyone know when ghc 6.14 is expected, what'll be in it, and/or where I can find out? I didn't find much at the ghc+developer wikis
13:26:49 * alexyk thinks the 2010 fashionable features are beige.  6.14 will have beige options and glass back.
13:27:13 <Veinor> 6.14 will disable RTS options by default
13:27:19 <Veinor> you'll have to compile with --enable-rts
13:27:34 <alexyk> Veinor: how is it helpful?
13:27:44 <aavogt> it will also compile with --make by default
13:27:55 <Veinor> it closes a security hole
13:28:00 <ryanakca> Can someone help me figure out "The type signature for `direction' lacks an accompanying binding" for http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26145#a26145 (I'm doing problem #11 on http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html)
13:28:01 <alexyk> ah ok
13:28:10 <Veinor> with setuid and CGI scripts
13:28:14 <illissius-> Hmm, I guess if there's some kind of webdarcs or something I'll find a changelog there?
13:28:38 <Veinor> ryanakca: you typoed directions into direction
13:29:08 <ryanakca> Veinor: Ah, how foolish of me. Thanks
13:29:16 <Veinor> that also won't compile, though
13:29:32 <Veinor> instead of Maybe [Direction] you just want [Direction]
13:29:35 <tensorpudding> it doesn't really close a hole to make RTS optional instead of default
13:29:36 <Veinor> and you want to return [] instead of Nothing
13:29:45 <gwern> punning on the empty list?
13:29:48 <Veinor> tensorpudding: well, it makes that hole not there by default
13:29:52 <ryanakca> Veinor: Ah, thanks
13:29:54 <Veinor> gwern: punning?
13:30:04 <tensorpudding> the hole has been moved
13:30:04 <gwern> Veinor: like lisp making [] = false
13:30:27 <tensorpudding> nil?
13:30:27 <Veinor> gwern: kind of, I guess
13:30:39 <Veinor> tensorpudding: this is true
13:30:58 <Veinor> I mean it means there's no safe way to do multicore setuid processes
13:32:31 <tensorpudding> nil is pretty weird
13:32:33 <gwern> that's not really surprising
13:34:27 <aristid> why is Bool no Monoid?
13:34:58 <jbapple> Veinor: that sounds like an important problem. I think it would be worth filing a bug about it
13:35:02 <c_wraith> because there are two instances that make equal sense.
13:35:40 <tensorpudding> what would mappend be?
13:35:53 <Veinor> tensorpudding: && or ||
13:35:54 <gwern> obviously it'd be and!
13:36:03 <aristid> no, it would be ||
13:36:08 <Veinor> or even xor
13:36:09 <gwern> or is just nuts. as well crack your egg from the big end
13:36:09 <tensorpudding> Which one?
13:36:20 <Veinor> tensorpudding: exactly!
13:36:34 <tensorpudding> It's like saying Int should be a monoid.
13:36:41 <tensorpudding> Should mappend = (*) or (+)?
13:36:48 <gwern> tensorpudding: well, except we do have a lib using newtypes to give us int as a monoid
13:36:48 <aristid> there should be the convention that the unwrapped monoid is additive
13:37:00 <Twey> :t Sum
13:37:01 <lambdabot>     Ambiguous occurrence `Sum'
13:37:01 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
13:37:01 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
13:37:02 <edwardk> tensorpudding: i would argue for (+), with a separate multiplicative monoid for (*)
13:37:17 <tensorpudding> You could newtype Bool and make it an (&&) monoid as well as a (||) monoid
13:37:25 <magicman> ?type Any
13:37:26 <lambdabot> Bool -> Any
13:37:31 <magicman> ?src Any
13:37:31 <lambdabot> Source not found. My pet ferret can type better than you!
13:37:36 <gwern> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html#t%3ASum and  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html#t%3AProduct
13:37:42 <magicman> newtype Any = Any Bool
13:37:43 <aristid> :t Data.Monoid.Sum
13:37:44 <lambdabot> forall a. a -> Control.Monad.RWS.Sum a
13:38:13 <edwardk> tensorpudding: the reason being that you can extend the (+) monoid more, by making it into a group, or the basis for a ring, etc. but that the (*) monoid can only become a group on Ints /= 0 
13:38:47 <aristid> it would also be in line with the Alternative/MonadPlus instances for Maybe and []
13:38:53 <tensorpudding> I agree with the newtyping
13:39:36 <edwardk> that and you can convert between the monoid and multiplicative monoid, using cute newtypes like newtype Log a = Log a and newtype Exp a = Exp a ;)
13:39:48 <edwardk> but i agree in general that the choice is ambiguous
13:39:51 <ezyang> How does GHC kmnow when to link statically versus link dynamically? 
13:39:54 <edwardk> there are lots of monoids on Int
13:40:02 <gwern> ezyang: you tell it to not link statically
13:40:27 <ezyang> gwern: What's the flag? 
13:40:31 <ezyang> -dynamic? 
13:40:36 <gwern> -dynamic, I think
13:40:40 <gwern> but everything has to be -dynamic
13:40:43 <gwern> like profiling
13:41:05 <ezyang> gwern: Oh, so I can't pick and choose libraries to load dynamically? 
13:41:10 <gwern> don't think so
13:41:31 <ezyang> blah. That would have been kkind of neat. 
13:42:06 <gwern> ezyang: you should be pissing yourself in glee that there's any dynamic linking!
13:42:15 <gwern> when I started haskell, dynamic linking was a distant dream
13:42:42 <ezyang> gwern: I'm a brash young-un with no conception of the dream :-) 
13:42:49 <gwern> my sergeant oft said, before his head got blown off by an unsafePerformIO, that he'd give his left nut or his pack of cigarettes to be able to dynamically link anything!
13:43:28 <tensorpudding> I didn't know that GHC statically linked anything.
13:43:52 <gwern> tensorpudding: you've never noticed the huge binaries you get when you import, say, the ghc api?
13:44:35 <tensorpudding> file says that they're dynamically-linked
13:44:53 <tensorpudding> everything that I've built using ghc --make, anyway
13:44:56 <gwern> file is no doubt fooled by the libc dynlink or something
13:45:18 <gwern> for example look at xmonad
13:45:22 <c_wraith> it links c libs dynamically
13:45:25 <gwern> [04:44 PM] 2Mb$ ldd xmonad-i386-linux  linux-gate.so.1 =>  (0xb76fb000) libXft.so.2 => /usr/lib/libXft.so.2 (0xb76cf000) libXinerama.so.1 => /usr/lib/libXinerama.so.1 (0xb76cc000) libXext.so.6 => /usr/lib/libXext.so.6 (0xb76bb000) libX11.so.6 => /usr/lib/libX11.so.6 (0xb758c000)
13:45:34 <gwern> plenty of dyn links, but all the haskell? static
13:45:38 <monochrom> There are at least four monoids associated with Bool: &&, ||, ==, /=
13:45:59 <ezyang> What are dynlinks? 
13:46:25 <tensorpudding> huh
13:46:58 <c_wraith> we're talking about haskell libs
13:47:09 <ezyang> Well, /I/ was talking about C libs 
13:47:16 <gwern> 'file' doesn't care. if it sees any dyn links, it's a dyn linked executable
13:47:48 <ezyang> gwern: Were you referring to linking with Haskell modules, when you spoke of the dynamic linking dream? 
13:47:52 <gwern> of course
13:47:58 <gwern> we deal with c libs as little as possible
13:48:08 <ezyang> Ok, this is why I thought it was no big deal :-) 
13:48:26 * ezyang is currently knee-deep in FFI code, so the c libs are the interesting thing 
13:48:29 <monochrom> this is like "strictness". people just binarily say "strict" "nonstrict", forgetting that things like [()] has infinitely many shades of strictness.
13:49:10 <tensorpudding> So you need to specifically request -dynamic?
13:49:58 <gwern> so mote it be
13:50:15 <tensorpudding> When did GHC get the ability to use it
13:50:39 <monochrom> 6.12.x
13:51:02 <tensorpudding> So it's not actually used by any packages.
13:51:08 <tensorpudding> many*
13:51:09 <kniu> I'm trying to make sense what "dependent sums" and "dependent products" are, from this wikipedia article: http://en.wikipedia.org/wiki/Intuitionistic_type_theory
13:51:39 <kniu> how come the type of a function is a "product"?
13:51:52 <Twey> monochrom: Infinitely many?
13:52:11 <monochrom> dependent product has special case: type-level lambda
13:52:47 <kniu> and why say the type of a tuple is (sigma n. Vec(R, n)) when you can say (pi n. (n, Vec(R, n)))?
13:52:59 <monochrom> the choice of the names "sum" and "product" are inspired but don't take it seriously
13:53:41 <kniu> okay.
13:54:14 <monochrom> And to be more precise, I should say: functions of type [()]->() have infinitely many shades of strictness. For every natural n, you can write a function that is strict down to exactly n cons cells of the input list.
13:56:27 <ryo_hazuki> i hope someone will contribute his snippets on this paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26144
13:56:45 <monochrom> Mathematicians are poor choosers of names, probably on par with the marketting people. They take inspiration from a narrow area, likely what they learned as kids. So everything is a "product", everything else is a "sum". There was a time they called monads "triples" just because 3 things are involved.
13:57:39 <monochrom> (But of course, everything not resembling a "product" or a "sum" is going to resemble a "triple" because 3 components are involved.)
13:58:07 <kniu> huh.
13:58:27 <kniu> can I get a definitive reference about this stuff?
13:58:41 <kniu> also, there's this site: http://www.rbjones.com/rbjpub/logic/cl/tlc004.htm
13:58:52 <kniu> no mention of dependent sums at all.
13:58:59 <kniu> what gives?
14:01:19 <monochrom> ryo_hazuki: http://www.haskell.org/haskellwiki/Dynamic_programming_example
14:02:36 <edwardk> or worse you get things like monads, so named because somebody wanted to name something an operad because his mom was an opera singer, and thought monads should sound similar ;)
14:03:01 <ryo_hazuki> monochrom: is that an bottom-up approach?
14:04:04 <monochrom> Yes.
14:06:51 <ryo_hazuki> thanks, good night everyone
14:10:46 <Baughn> @seen cale
14:10:47 <lambdabot> Unknown command, try @list
14:10:52 <Baughn> ,seen cale
14:11:05 <sinelaw> preflex, seen Cale
14:11:05 <preflex>  Cale was last seen on #haskell 6 hours, 37 minutes and 59 seconds ago, saying: At least, since the days when I used the JVM :)
14:12:06 <Baughn> sinelaw: One day, I will remember. And on that day the world shall meet its doom.
14:12:44 <sinelaw> Baughn, it's highly unlikely to correlate with the world meeting its doom
14:12:55 <sinelaw> unless the doom is simply you remembering that
14:13:35 <Baughn> sinelaw: Well, I figure the heat death of the universe probably counts as a doom
14:18:56 <gspr> Could someone shoot me a few pointers as to what tools/techniques I should be looking for to do the following? Let's for simplicity say I'm going to construct a tree in a way determined by an RNG, and suppose that the tree will contain so many nodes that copying it whenever it gets new nodes appended to it is completely out of the question. (I'm guessing I'd like to construct the tree in a stateful manner, and that I'd like the nodes to be mutable
14:18:57 <gspr>  during construction somehow). Suppose also that I want to save some (let's say statistical) information about the tree as it's being built. From what I can gather with my limited Haskell experience, this latter requirement is what the writer monad is about. Am I right? And as for the construction of the tree: Does anyone have any pointers to things I should study?
14:23:37 <sshc> What is the name of the function in Data.Map that returns a list of the values in a map paired with a given key?
14:24:36 <sshc> thisFunction (M.fromList [(1, "foo"), (2, "bar"), (1, "quux")] 1 == ["foo", "quux"]
14:24:56 <Lemmih> sshc: There is no such function.
14:25:17 <Lemmih> sshc: There can only be a single value for each key.
14:25:41 <sshc> Lemmih: What is the behaviour of adding multiple values with the same key?
14:25:43 <Lemmih> sshc: You can map keys to lists of values, though.
14:25:58 <ezyang> Anyone know how I can fix this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26147#a26147 
14:26:13 <Lemmih> sshc: New values will overwrite the old ones.
14:27:08 <aavogt> > M.fromList [(1, "foo"), (2, "bar"), (1, "quux")]
14:27:09 <Lemmih> ezyang: Why are you trying to load ghc-prim manually?
14:27:09 <lambdabot>   fromList [(1,"quux"),(2,"bar")]
14:27:10 <sshc> > show$ Data.Map.fromList [(1, "foo"), (2, "bar"), (1, "quux")]
14:27:10 <lambdabot>   Not in scope: `Data.Map.fromList'
14:27:33 <ezyang> Lemmih: Well, I wasn't. 
14:27:41 <aavogt> > M.fromListWith (++) [(1, "foo"), (2, "bar"), (1, "quux")]
14:27:42 <lambdabot>   fromList [(1,"quuxfoo"),(2,"bar")]
14:27:45 <sshc> Huh.  I guess you're right.
14:27:46 <ezyang> I was trying to load a .so file I'd compiled 
14:28:00 <sshc> I'm not sure how I thought I remembered that.
14:28:02 <jmcarthur> gspr: well, there's almost always more than one way to do things. what kind of statistical information about the tree are you collecting? is the information lazy or strict? are you constructing the tree all at once or are you adding nodes to it one at a time? also, you do realize that even adding a node to a tree doesn't result in the whole tree being copied, right?
14:28:07 <sshc> THanks.
14:28:22 <wunki> just out of curiosity, does haskell source-code with Unicode characters still compile? Like → instead of ->?
14:28:24 <ezyang> (updated with what I was really trying to do) 
14:28:31 <ezyang> wunki: Yes, but you need an extension 
14:28:44 <wunki> ezyang: an extension for GHC?
14:28:59 <jmcarthur> gspr: oh, i missed that you said you wanted the nodes to be mutable during construction, but most of my questions still apply i guess
14:28:59 <ezyang> yes. 
14:29:05 <ezyang> I don't remember off-hand what it was 
14:29:27 <jmcarthur> gspr: oh, wait, that was an idea of how to do it that you had, not a specification. nevermind :)
14:29:32 <wunki> ezyang: http://hackage.haskell.org/package/base-unicode-symbols-0.2
14:29:52 <Lemmih> ezyang: Why are you trying to load a .so file?
14:30:33 <ezyang> Lemmih: Because I want to use that library from ghci 
14:30:34 <gspr> jmcarthur: yeah :)   The statistical information could be (for example) the number of nodes of a certain type that have been added so far, or the number of nodes after every N'th step of construction
14:30:44 <ezyang> but an underlying C library that it uses only has a static library available 
14:30:49 <gspr> jmcarthur: I'd probably like that information to be lazy (which means writer is nice, right?)
14:30:54 <ezyang> So I was trying to see if I could hack around that 
14:31:13 <ezyang> UnicodeSyntax 
14:31:20 <ezyang> wunki 
14:31:28 <gspr> jmcarthur: I absolutely want to construct the tree one at a time
14:31:40 <Lemmih> ezyang: You can register the library with GHC?
14:31:47 <jmcarthur> okay, that was the most critical question i think
14:31:55 <ezyang> hmm, I guess I could do that 
14:32:08 <jmcarthur> gspr: as you add nodes will you always be starting from the root of the tree, or are you going to be keeping a "current location"?
14:32:29 <gspr> jmcarthur: Yes, I should be keeping a current location
14:32:35 <jmcarthur> aha!
14:32:43 <ezyang> woot, that worked 
14:33:11 <gspr> jmcarthur: that would be the only place the tree is allowed to grow (but again, it should grow according to some values drawn from an RNG I have to keep with me)
14:33:40 <jmcarthur> gspr: do you know what a zipper is?
14:33:47 <gspr> jmcarthur: Btw, I realize my questions are very vague and probably have hundreds of answers, but if you have some buzzwords to throw me that would be great :)
14:33:58 <gspr> jmcarthur: I recently read about them at the good math, bad math blog, yes
14:34:12 <jmcarthur> gspr: yeah vague questions are tough to work with ;)
14:34:17 <ezyang> Baw, no it didn't. "Loading package abcBridge-0.1 ... can't load .so/.DLL for: abc (libabc.so: cannot open shared object file: No such file or directory" 
14:34:23 <jmcarthur> gspr: do you see how zippers might apply here?
14:34:59 * ezyang only has a libabc.a file T_T 
14:35:32 <gspr> jmcarthur: Yes, vaguely. I think my biggest problem is that I am struggling to get to grips with how to update structures in haskell. Your idea is good though - I certainly shall refresh my memory on zippers
14:35:43 <gspr> (I have never actually played with them before, just read a bit)
14:35:45 <gspr> thanks man :)
14:36:33 <jmcarthur> gspr: also, it sounds to me like the kind of information you want to log is strict. *if* you are going to use a monad, a State monad where the state is the log, the current tree, and the RNG might be nice
14:37:01 <jmcarthur> monads, of course, are not ever *necessary*, but they can help sometimes, depending on context
14:37:07 <gspr> jmcarthur: That's reaffirming to hear - it's exactly what has been stirring in my head the past hours :)
14:38:03 <jmcarthur> gspr: i'm going to leave in 5 minutes or so. any more questions before i go?
14:38:19 <gspr> I feel that structures that are best created "step-by-step" as this are what always throws me back to imperative languages... gonna beat it this time! :)
14:38:24 <gspr> jmcarthur: No, thank you very much :)
14:38:32 <jmcarthur> gspr: oh, i meant the current state of the tree *zipper*, not of the tree proper
14:38:49 <gspr> oh, ok, that's NOT what I was thinking
14:38:59 <jmcarthur> gspr: also keep in mind that often you don't have to create structures step by step. you can instead use laziness :)
14:39:32 <gspr> Hmmm... yes... I must get my brain accustomed to that soon!
14:40:15 <jmcarthur> gspr: in fact, if the RNG entirely determines the structure of the tree and you never move the "hole" around, you can probably use laziness here, as well, although without specifics i can't say for sure
14:40:27 <jmcarthur> instead of a zipper, i mean
14:40:37 <gspr> I see what you mean I think
14:40:47 <jmcarthur> so in effect it would appear that your code create the entire structure at once, but it doesn't really :)
14:40:50 * gspr points his nose towards zippers
14:40:58 <gspr> yes, I see
14:41:28 <jmcarthur> alright, i'm out of here. good luck, gspr!
14:42:00 <gspr> jmcarthur: thanks again :)
14:51:47 <dons> Cale: here's one for you: http://stackoverflow.com/questions/3034004/learning-haskell-maps-folds-loops-and-recursion 
14:51:59 <dons> tryhaskell -- dumping imperative programmers in the FP deep end since 2010.
14:53:32 <jesusabdullah> I did not know about tryhaskell!
14:55:13 <victoreremita> that sum function the guy at stackoverflow made is really interesting
14:55:15 <victoreremita> :p
14:58:43 <Sgeo> @hoogle [a] -> (a,a,a,a)
14:58:43 <lambdabot> Test.QuickCheck four :: Monad m => m a -> m (a, a, a, a)
14:59:32 <Sgeo> Any help here?
14:59:51 <Sgeo> I guess I could make my own
15:01:49 <zygoloid> > let partialSums xs = [x + s | x <- xs, s <- partialSums (tail xs)] ++ [0]; sum = head . partialSums in sum [1..10]
15:01:50 <lambdabot>   55
15:02:26 <zygoloid> bah, who says there's no way to implement sum with a list comprehension
15:03:14 <dons> you needed external functions.
15:03:20 <dons> aka head.
15:05:50 <zygoloid> dons: hold on while i knock up a Num [a] instance ;-)
15:09:25 <dons> zygoloid: haha
15:37:30 * hackagebot ad 0.44.4 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.44.4 (EdwardKmett)
15:38:53 <krey> does anyone know if there's a way to pattern match inside lambda expressions?
15:38:58 <krey> (multiple patterns)
15:39:12 <ezyang> \(Foo b) -> ? 
15:39:49 <krey> something like (\ (Just x ) -> something ... (\ Nothing -> something else
15:40:15 <ezyang> ah, I see. 
15:40:18 <ezyang> sort of. 
15:40:21 <ezyang> \x -> case x of 
15:40:24 <krey> no
15:40:27 <krey> trying avoid case
15:40:30 <krey> :S
15:40:39 <ezyang> then, aiui, no. 
15:40:57 <ezyang> though there may be combinators that help 
15:40:58 <krey> :(
15:41:06 <ezyang> like instead of (Just a) (Nothing), just use maybe 
15:41:48 <dons> if you need to case inside a lambda, use a 'where' or 'let'
15:42:09 <Twey> ‘where’ in a lambda?
15:42:13 <Twey> Can't do that…
15:42:31 <Twey> Oh, you mean ‘where’ the whole function and give it a name?
15:45:09 <dons> yeah
15:45:26 <Gracenotes> for some reason I've thought "case of" to replace "\x -> case x of" would be a nice bit of syntactic saccharine
15:45:56 <Gracenotes> just because I tend to write code that uses explicit case statements a fair amount, actually..
15:45:57 <illissius-> i've read a proposal for that somewhere on the wiki
15:46:13 <illissius-> (or some other place)
15:47:14 <illissius-> there was also one to make pattern-matching lambdas composable
15:47:23 <aristid> Gracenotes: it'd be like an operator section for case
15:47:45 <krey> how does pattern matching 'work' anyway?
15:47:55 <krey> is it rewritten into 'case'?
15:48:10 <Philippa> it is, yes
15:48:11 <Gracenotes> yeah, it's a transformation in the source
15:48:25 <Gracenotes> f (x:xs) (Just y) is written into nested case statements
15:48:42 <Gracenotes> it is at the heart of the lazy evaluation engine
15:50:41 <zygoloid> illissius-: it's on the haskell' trac: http://hackage.haskell.org/trac/haskell-prime/ticket/41
15:52:17 <Gracenotes> not sure how useful for pointfree code it would be (for composing, not within the branches themselves)
15:52:36 * hackagebot hoopl 3.8.3.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.3.0 (NormanRamsey)
15:55:26 <Gracenotes> ((. show) . (++)) . case of { True -> "empty "; False -> "non-empty " } =<< null   ← useless code
16:02:05 <ivanm> preflex: seen dibblego 
16:02:06 <preflex>  dibblego was last seen on #haskell 5 days, 2 hours, 34 minutes and 41 seconds ago, saying: @type join fmap
16:02:35 <ivanm> @tell dibblego this looks like the problem we've been having for a while: http://www.reddit.com/r/haskell/comments/cekfe/trouble_accessing_haskell_pages_at_microsoft/
16:02:35 <lambdabot> Consider it noted.
16:06:47 <Saizan> oh, it's true, it works in "incognito"
16:07:16 <zygoloid> seems to be cookie-related
16:09:24 <ivanm> yeah, dibblego and I were discussing this way back
16:09:29 <ivanm> we thought it might have been related to our ISP because we were using the same one at the time
16:09:39 * ivanm digs up that forum thread on it
16:10:21 <ivanm> http://forums.whirlpool.net.au/forum-replies-archive.cfm/1311734.html
16:14:07 <dibblego> ivanm, thanks
16:14:07 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
16:25:23 <krey> is there any way for a lambda expression to be recursive?
16:25:34 <djahandarie> Fixed point operator
16:25:46 <krey> trying to define recursive functions within the Identity monad
16:27:01 <krey> djahandarie: care to explain?
16:27:10 <ivanm> krey: look up the Y Combinator
16:27:26 <ivanm> krey: in Haskell, you can't explicitly have a lambda function call itself
16:27:34 <ivanm> so what you do is build the recursion into the RHS
16:27:39 <ivanm> e.g. using the fix function
16:27:45 <ivanm> @type fix
16:27:46 <lambdabot> forall a. (a -> a) -> a
16:27:52 <ivanm> > fix show
16:27:53 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:27:54 <krey> oooh
16:28:01 <krey> I have to use fix
16:28:02 <krey> I see
16:28:03 <krey> :S
16:28:04 <ivanm> lemme see if I get this right
16:28:10 <djahandarie> > fix (1:)
16:28:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:28:42 <krey> fix (\rec n -> if n == 0 then 1  else n * rec (n-1)) 5
16:28:48 <krey> > fix (\rec n -> if n == 0 then 1  else n * rec (n-1)) 5
16:28:49 <lambdabot>   120
16:28:52 <djahandarie> Yep
16:28:58 <ivanm> yeah, that's what I was trying to remember how to do
16:29:01 <lowasser> Man, GHC HEAD has some sweet threading improvements 
16:29:03 <krey> :D
16:29:18 <krey> I don't really get how it works
16:29:24 <djahandarie> @src fix
16:29:24 <lambdabot> fix f = let x = f x in x
16:29:27 <krey> I really ought to expand it sometime
16:29:40 <mauke> > let rec n = if n == 0 then 1 else n * rec (n-1) in rec 5
16:29:41 <lambdabot>   120
16:29:42 <krey> but the copy is burned into my brain :)
16:29:44 <djahandarie> Or fix f = f (fix f)
16:30:00 <kmc> :t let fix f = f (fix f) in fix
16:30:01 <lambdabot> forall t. (t -> t) -> t
16:30:04 <krey> so
16:30:11 <kmc> i think the two aren't actually equivalent in Haskell
16:30:13 <krey> I have to use this type of recursion
16:30:14 * kmc ponders
16:30:15 <ivanm> djahandarie: I have the sneaking suspicion that using an explicit let avoids some memory leaks or something
16:30:27 <djahandarie> Maybe
16:30:34 <ivanm> kmc: possibly because it won't take the base case into account properly?
16:30:50 <kmc> well, that's tricky
16:31:12 <kmc> one thing it took me a long time to see is that the recursion in "fix" is not (usually) directly responsible for the recursion in your algorithm
16:31:30 <krey> kmc: I'm listening
16:31:39 <kmc> the recursion in "fix" is just in order to get a "self" argument, the thing you named "rec" above
16:31:46 <kmc> then you can call it 0 or more times
16:31:50 <kmc> which is how the base case is established
16:32:06 <kmc> that's not true of every use though
16:32:07 <kmc> like
16:32:13 <kmc> > fix ((0:) . scanl (+) 1)
16:32:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:32:22 <kmc> here the thing you're taking a fixed point of is a list
16:32:34 <kmc> or rather, the result of taking the fixed point is a list
16:32:38 <kmc> but usually it's a function
16:32:47 <krey> yes
16:32:49 <kmc> and in strict languages even more so
16:33:03 <krey> just like the fix (1:) example
16:34:02 <kmc> yeah
16:34:15 <kmc> lowasser, cool, which improvements and are they documented anywhere?
16:34:38 <lowasser> man, I dunno, I'm just getting 2-3x improvement over 6.12.1
16:34:55 <kmc> sweet
16:35:02 <kmc> did you look at Core?
16:35:12 <lowasser> it's the same, I'm pretty sure the changes are in the RTS
16:35:23 <kmc> cool
16:35:33 <kmc> hmm you could use threadscope too
16:35:41 <lowasser> yeah, I have been
16:38:27 <krey> thanks for the help guys, time to 'fix' my code :P
16:46:04 <lowasser> huh, 6.12.1 really sucks at parallelism
16:46:18 <lowasser> or something, I'm getting almost no parallel usage of the 4 processors
16:46:40 <kmc> are you using pure parallelism, concurrency, DPH, or something else?
16:46:40 <lowasser> whereas HEAD is getting huge bonuses
16:47:23 <lowasser> mostly pure parallelism, with a teensy bit of concurrency that's really just parallelizing a pure computation that's nonetheless wrapped up with IO
16:47:38 <lowasser> ("pure computation" = "deterministic")
16:47:41 <kmc> fair enough
16:48:20 <lowasser> it's really stunning just how much more parallel it is =D
16:48:29 <kmc> what does +RTS -s say on 6.12.1
16:48:53 <lowasser> on what subject?
16:48:58 <kmc> are you having a lot of sparks fizzle?
16:49:09 <lowasser> there's only 22 sparks, and all get converted
16:49:29 <lowasser> I think it might be that 6.12.1 sucked at parallel GC?
16:49:41 <robertmassaioli> I just read a paper that jokingly called the operator (>=>) "fish", does it have a propper name? :)
16:50:29 <lowasser> let me put up some threadscope graphs somewhere
16:50:36 <kmc> it's composition in the Kleisli category of a monad
16:50:43 <kmc> (except with the arguments swapped)
16:50:55 <aavogt> doesn't sound like a proper name
16:51:06 <danderson> so, flipped composition in the Kleisli category of a monad
16:51:06 * aavogt sticks to "fish"
16:51:12 <danderson> probably why it's nicknamed "fish"
16:51:15 <danderson> much more catchy
16:51:40 <aavogt> or maybe call it an arrow
16:51:52 * hackagebot UMM 0.2.2 - A small command-line accounting tool  http://hackage.haskell.org/package/UMM-0.2.2 (UweHollerbach)
16:51:55 <aavogt> in ... category blah...
16:52:03 <robertmassaioli> danderson and aavogt: yeah I like the sound of fish too :)
16:52:19 <robertmassaioli> kmc: yeah but does it have a short name though?
16:52:31 <kmc> none that i know of
16:52:50 <robertmassaioli> kmc: fair enough. Thankyou. :)
16:53:03 <illissius-> fish and backfish?
16:53:26 * robertmassaioli decides that he will stick with fish and backfish is just too cool not to say.
16:53:41 <kmc> haha
16:53:46 <lowasser> kmc: http://code.haskell.org/containers-pqueue/regexdna2.eventlog.png 6.12.1 http://code.haskell.org/containers-pqueue/regexdna2HEAD.eventlog.png HEAD
16:53:56 <kmc> :t (<=<) >=> (<=<)
16:53:56 <lambdabot> forall b (m :: * -> *) c. (Monad m) => (b -> m c) -> (b -> m b) -> b -> m c
16:54:19 <illissius-> hmm
16:54:31 <aavogt> it's a school
16:54:32 <kmc> weird lowasser
16:54:37 <lowasser> yeah, i know right?
16:54:47 <robertmassaioli> wow...they are three amazing fish.
16:55:19 <illissius-> let (<['-'<]) = (+) in 1 <['-'<] 2
16:55:23 <illissius-> > let (<['-'<]) = (+) in 1 <['-'<] 2
16:55:25 <lambdabot>   <no location info>: Parse error in pattern
16:55:28 * robertmassaioli goes back to read paper some more
16:55:29 <illissius-> damn
16:55:38 <kmc> so on 6.12.1 it looks like many of the sparks get converted to threads on the fourth HEC
16:55:48 <kmc> but why they wouldn't migrate to unused HECs, i have no idea
16:56:05 <kmc> anyway i'm glad that HEAD does better and not worse ;)
16:57:05 <Gracenotes> > let (>-*>) = (++" fish") . unwords . take 4 . words in map (>-*>) cake
16:57:06 <lambdabot>   ["One 18.25 ounce package fish","One can prepared coconut fish","Three slas...
16:57:48 <Gracenotes> > let (>-*>) = (++" fish") . unwords . take 4 . words in drop 2 $ map (>-*>) cake
16:57:50 <lambdabot>   ["Three slash four cup fish","Four large eggs. fish","One cup semi-sweet ch...
16:58:02 <Gracenotes> :/
17:11:20 <gwern> @wn chevron
17:11:23 <lambdabot> *** "chevron" wn "WordNet (r) 2.0"
17:11:23 <lambdabot> chevron
17:11:23 <lambdabot>      n 1: V-shaped sleeve badge indicating military rank and service;
17:11:23 <lambdabot>           "they earned their stripes in Kuwait" [syn: {stripe}, {stripes},
17:11:23 <lambdabot>            {grade insignia}]
17:11:25 <lambdabot>      2: an inverted V-shaped charge
17:15:44 <djahandarie> What was that language survey thing that got linked in here a couple times?
17:17:32 <Saizan> you mean the shootout contest?
17:21:05 <djahandarie> Nah, it was the one that asked a bunch of questions.
17:23:56 <Gracenotes> ah foun it
17:24:02 <kmc> http://therighttool.hammerprinciple.com/
17:24:24 <kmc> e.g. http://therighttool.hammerprinciple.com/items/php
17:24:31 <Gracenotes> and you too kmc \;.
17:25:14 <mdmkolbe> Where does the haddock documentation talk about the "Stability" and "Portability" fields I see at the top of source files?  (e.g. at the top of http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Cont.html )  I just want to make sure I'm documenting my library correctly.
17:27:42 <djahandarie> Ah thanks kmc (and Gracenotes :P)
17:31:46 <edwardk> finally have the intervals working well enough to calculate cosine
17:33:10 <edwardk> now i just need to slog through the other transcendental function
17:33:13 <edwardk> er functions
17:35:58 <edwardk> now the question is, should i define sqrt of an interval to return both values? or should i go with sqrt x = exp (log x / 2) -- which gives only the principal root
17:37:06 * hackagebot graphmod 1.2.2 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.2 (IavorDiatchki)
17:37:40 <edwardk> iavor is my hero
17:47:45 <krey> can anyone please explain how to join continuations?
17:48:05 <edwardk> krey: as in Cont r (Cont r a) -> Cont r a ?
17:48:22 <krey> yep
17:48:35 <aavogt> @djinn (((a -> r) -> r) -> r) -> r
17:48:35 <lambdabot> -- f cannot be realized.
17:48:55 <kmc> arrrr!
17:49:01 <edwardk> @type \ m -> Cont $ \c -> runCont m $ \a -> runCont a c 
17:49:02 <lambdabot> forall a r. Cont r (Cont r a) -> Cont r a
17:49:06 <edwardk> done!
17:49:08 <kmc> @unmtl Cont r (Cont r a) -> Cont r a
17:49:08 <lambdabot> Cont r (Cont r a) -> Cont r a
17:49:15 * hackagebot bson 0.0.2 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.0.2 (TonyHannan)
17:49:17 <kmc> nice edwardk 
17:49:47 <kmc> @type Cont
17:49:47 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
17:50:02 <edwardk> krey: the gist of it is, that in intuitionistic logic, ~~~a -> ~a holds, even though ~~a -> ~a doesn't
17:50:19 <edwardk> there is a nice presentation of that idea by wadler, one sec. let me dig it up
17:50:42 <kmc> @type \(Cont m) -> Cont $ \c -> m $ \(Cont a) -> a c
17:50:43 <lambdabot> forall a r. Cont r (Cont r a) -> Cont r a
17:50:52 <sshc> What is the monomorphism restriction?
17:51:09 <sshc> What does it restrict?
17:51:11 <edwardk> sshc: a great evil foisted upon mankind in the name of efficiency
17:51:31 <sshc> What does it restrict?
17:51:35 <kmc> sshc, values bound at top-level by a pattern bind (i.e. not a function bind) are restricted to have monomorphic type
17:51:55 <kmc> actually not just top level iirc
17:51:57 <kmc> in H98 if you put "x = 3" in a file with nothing else
17:52:06 <kmc> then x :: Integer or some semi-arbitrary default
17:52:12 <kmc> rather than x :: (Num a) => a
17:52:15 <edwardk> sshc if you write foo = (f 1, f 2) where f = (2 *) -- the f in there is restricted by the monomorphism restriction to have one type rather than be used polymorphically by the surrounding foo
17:52:34 <edwardk> it is useful because it can improve sharing
17:52:44 <yazdmich> im guessing im lost
17:52:48 <edwardk> it is harmful because occasionally you need to write a type signature to get it to piss off ;)
17:53:14 <kmc> > let x = (f (1 :: Integer), f (2 :: Double)) where f = (2*) in x
17:53:15 <lambdabot>   (2,4.0)
17:53:18 <yazdmich> i was looking for lamdabot
17:53:31 <kmc> ^^^^ that will fail in a vanilla H98 interpreter
17:53:34 <kmc> yazdmich, you've found her
17:53:43 <sshc> Is hugs H98?
17:53:49 <krey> edwardk: wow logic, i can do logic, well some logic at least
17:53:57 <kmc> > text $ map pred "ij-!zb{enjdi"
17:53:58 <lambdabot>   hi, yazdmich
17:54:03 <krey> edwardk: but how is that going to help me with joining continuations?
17:54:06 <edwardk> krey: http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/not-not-ml.pdf references the devil's bargain mentioned by wadler, one sec while i dig up the original.
17:54:07 <kmc> sshc, it has a H98 mode and an extensions mode
17:54:16 <kmc> hugs has a few cool extensions GHC doesn't, actually
17:54:25 <edwardk> a continuation passing style can be seen (almost) as ~~a    -- return uses a -> ~~a
17:54:32 <kmc> as do jhc and uhc
17:55:16 <edwardk> bind takes ~~a -> (~~a -> b) -> ~~ b, and join :: ~~(~~a) -> ~~a
17:55:39 <kmc> GHCi is mostly H98 if you start it with no arguments
17:55:44 <kmc> it will accept a few extensions even then
17:56:08 <sshc> I thought GHC was H2010 now
17:56:23 <edwardk> krey: http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf section 4 talks about the excluded middle
17:56:50 <Saizan> btw, the monomorphism restriction applies only to variables with a typeclass context
17:56:55 <krey> edwardk: i assume this all relates to the (in)famous curry-howard isomorphism
17:57:04 <edwardk> krey: yep.
17:57:08 <krey> edwardk: but can't I do continuations without that?
17:57:17 <yazdmich> im guessing this channel is for programming nerds? (nerd = not even remotely dorky)
17:57:33 <edwardk> krey: well, sure. you asked for someone to explain it. i was trying to argue for why it existed ;)
17:57:40 <krey> :D
17:57:46 <JoeyA> Hello
17:57:59 <kmc> yazdmich, sure
17:57:59 <yazdmich> i am an aspie learning objective c myself
17:58:03 <krey> edwardk:  I believe its existence now! but can you explain its concept?
17:58:11 <kmc> sshc, there's a few bits of H2010 that still aren't implemented in GHC, afaik
17:58:32 <kmc> anyway i expect there's a desire not to change the set of programs accepted by GHC-with-no-args
17:58:36 <edwardk> krey: well, it comes down to the fact that you can get rid of three -> r)s and replace them with 1 ;) 
17:58:41 <yazdmich> well ive found the bot so goodbye
17:58:48 <kmc> that was odd
17:59:15 <krey> also bind takes ~~a -> (~~a -> b) -> ~~ b ?
17:59:34 <krey> not ~~a -> (a -> ~~b) -> ~~ b ?
17:59:34 <Saizan> ~~ a -> (a -> ~~ b) -> ~~ b
17:59:42 <edwardk> krey: you have it right
17:59:48 <edwardk> i let my comonads addle my brain ;)
17:59:51 <sshc> kmc: What flags can be passed to GHC to enable what parts of H2010 GHC *does* support?
18:00:06 <edwardk> ~~a -> (~~a -> b) -> ~~ b is easy ;)
18:00:15 <kmc> i don't know if there's a single flag yet :/
18:00:35 <kmc> the list of extensions to H98 is at http://www.haskell.org/pipermail/haskell/2009-November/021750.html
18:00:39 <aavogt> stuff like -XNoNPlusKPatterns
18:00:44 <kmc> each of those is or should be a -X flag
18:00:53 <kmc> HierarchicalModules is on by default
18:01:05 <kmc> cool, PatternGuards made it
18:01:28 <kmc> by default ghc accepts it but gives a warning
18:01:45 <kmc> RelaxedDependencyAnalysis is by default too, i think
18:02:32 <kmc> so i guess i'm incorrect in saying each of them "should be" a -X flag
18:02:54 <krey> edwardk: what should I know before I attempt to understand the CHI?
18:03:08 <krey> edwardk: typed lambda calc, category theory?
18:03:29 <kmc> curry-howard doesn't have much to do with category theory, in any standard treatment i've seen
18:03:34 <kmc> you can dig deep and connect them, i'm sure
18:04:15 <kmc> it helps to know typed lambda calculus and also formal logic, since the result is that the two are the same ;)
18:04:58 <medfly> category theory is everywhere!
18:06:13 <krey> it's gonna take me ages to learn all that
18:06:31 <krey> but then, i's gonna be epic (surjective)
18:06:59 <krey> (right-cancellative)
18:07:08 <Saizan> well, they are formal systems with just an handful of rules, nothing too big :)
18:08:30 <krey> Saizan: I 'gave up' trying to understand lambda calc at about the Church-Rosser Theorem
18:10:23 <Saizan> oh, but you can understand CHI without any deep knowledge of any of the theorems, it worked for me at least
18:10:43 * Saizan is not even use what Church-Rosser says
18:10:50 <mauke> I think of lambda calculus as just another programming language
18:10:59 <mauke> am I missing much?
18:11:32 <Saizan> ah, strong normalization
18:12:42 <edwardk> krey: actually you can just tackle the curry howard isomorphism by looking at types and pretending they are propositions
18:12:53 <edwardk> @type fst
18:12:54 <lambdabot> forall a b. (a, b) -> a
18:13:11 <edwardk> that is the proposition that (a and b implies b)
18:13:14 <edwardk> @src fst
18:13:14 <lambdabot> fst (x,_) =  x
18:13:17 <edwardk> that is the proof
18:13:20 <edwardk> done ;)
18:13:31 <krey> edwardk: pretty funky
18:13:42 <mauke> @type undefined
18:13:42 <lambdabot> forall a. a
18:13:46 <edwardk> @djinn a -> (a -> r) -> r
18:13:46 <lambdabot> f a b = b a
18:13:49 <mauke> that is the proposition that everything is true
18:13:53 <mauke> @src undefined
18:13:53 <lambdabot> undefined =  error "Prelude.undefined"
18:13:59 <mauke> that is the proof
18:14:01 <edwardk> that is return for Cont, or the proposition that a implies that (a implies r) implies r
18:14:24 <edwardk> feel free to work them out with truth tables if they make you feel better ;)
18:14:38 <mauke> @type uncurry
18:14:39 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:14:50 <Saizan> you've to use intuitionistic logic though.
18:14:52 <krey> edwardk: of, I don't need truth tables, I trust you guys :)
18:15:00 <kmc> a proof of "a implies b" is a function that takes a proof of a and returns a proof of b
18:15:05 <ryanakca> Could someone help me figure out why lowestY doesn't return only one point in the list? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26153#a26153
18:15:07 <kmc> a proof of "a and b" is a pair of (a proof of a, a proof of b)
18:15:21 <edwardk> the trick is you're limited to an 'intuitionistic' logic, so some of the tools you're used to from logic don't hold.
18:15:31 <krey> like?
18:15:32 <kmc> a proof of "a or b" is Either a proof of a, or a proof of b (and we'd better say which, using Left or Right)
18:15:52 <edwardk> try to write a function from ((a -> r) -> r) -> a that works for all r.
18:16:00 <edwardk> in classical logic ~~a -> a
18:16:21 <edwardk> in intuitionistic logic that doesn't hold.
18:16:31 <Blkt`> could anyone explain me how does it work in theory the simulation of state via functions only?
18:16:31 <krey> oh
18:16:36 <mauke> ryanakca: probably because lowestY [d] ++ drop 1 ds
18:16:45 <edwardk> you can of course write such functions for particular choices of r
18:16:47 <krey> I can only do classical logic
18:16:58 <edwardk> krey: s/can only do/have only done/ ;)
18:17:07 <krey> :)
18:17:17 <ryanakca> mauke: Ah, I'm guessing I want lowestY ([d] ++ drop 1 ds) instead of (lowestY [d]) ++ drop 1 ds ?
18:17:17 <mauke> ryanakca: and lowestY [d] is [d], so that line can be simplified to [d] ++ drop 1 ds
18:17:25 <mauke> oh, ok
18:17:34 <mauke> [d] ++ better written as d :
18:17:54 <ryanakca> I see, thanks
18:17:55 <Saizan> krey: if you already understood CHI you'd know that you can already do intuitionistic logic :)
18:18:03 <krey> edwardk: if a is true and r is false
18:18:23 <krey> edwardk: then ((a -> r) -> r) -> a is false
18:18:25 <krey> right?
18:18:33 <kmc> Blkt`.  sure.  an action which produces a value of type t and also reads and updates a state of type s
18:18:43 <kmc> can be modeled as a function of type s -> (t, s)
18:18:47 <kmc> @unmtl State s t
18:18:47 <lambdabot> s -> (t, s)
18:18:49 <ryanakca> mauke: Also, is there a way to combine EQ and LT into one line (I tried (EQ || LT) -> blah) but that failed.
18:18:55 <edwardk> krey: anything implies True, so Foo ~ a when a is True, is True
18:19:04 <edwardk> er Foo -> a when a is True is True
18:19:08 <kmc> Blkt`, it takes an old state, and produces a pair of (result value, new state)
18:19:10 <mauke> ryanakca: well, you could use _ in this case
18:19:13 <ryanakca> s/blah)(.*)/blah\1)/
18:19:20 <ryanakca> mauke: Ah, true, thanks
18:19:43 <Blkt`> kmc: so basically I throw back the resulting state from the transition I caused invoking the function?
18:20:09 <kmc> i'm not entirely sure what you mean
18:20:12 <Blkt`> kmc: it is roughly like IO Monad, isn't it?
18:20:18 <kmc> only a little bit
18:20:21 <kmc> we haven't used monads at all yet
18:20:46 <kmc> you can wrap up these «s -> (t,s)» functions in a new type, and declare that type as a monad, and you get a little nicer syntax for it
18:20:48 <kmc> but that's not essential
18:20:55 <krey> edwardk: omg, very tired, cna't even do logic any more
18:21:05 <krey> edwardk: bedtimes, nnight
18:21:42 <Blkt`> kmc: but I have to carry around the computation the state I got back
18:21:44 <Blkt`> I mean
18:22:00 <kmc> > let act = State (\s -> (show s, 1+s)) in runState (replicateM 5 act) 0
18:22:01 <lambdabot>   (["0","1","2","3","4"],5)
18:22:12 <kmc> there's the sugar at work
18:22:33 <kmc> letting us reuse the very general library function "replicateM" to string together these state-transforming functions
18:22:33 <Blkt`> let's say f calls g that in turn calls h, h :: s -> (t,s), if g :: a -> t I lose the state, don't I?
18:22:47 <kmc> right
18:23:01 <kmc> every function that might change the state needs to return a "new" state
18:23:07 <kmc> (even if it doesn't always change the state)
18:23:11 <Blkt`> I get why that freaking IO [Int] keeps getting in the way in my project...
18:23:13 <alexyk> this thing looks up in a nested map and eats 12% of time: getUserDay user day = M.lookup user >=> M.lookup day -- why?
18:23:29 <alexyk> is >=> expensive??
18:23:43 <kmc> that would depend on the monad
18:23:45 <kmc> for Maybe, not so much
18:23:45 <aavogt> $ costs more
18:23:48 <kmc> haha
18:24:00 <kmc> :t let (€) = ($) in (€)
18:24:00 <lambdabot> forall a b. (a -> b) -> a -> b
18:24:11 <aavogt> alexyk: the M.lookup is probably more expensive
18:24:40 <kmc> Blkt`, passing around states explicitly can get annoyingly verbose, which is why we often use this State monad
18:24:57 <kmc> but that's essentially sugar
18:24:59 <kmc> it's not like the IO monad, where you're getting something fundamentally new
18:25:14 <alexyk> kmc: sounds like you have sales experience :)  "depends on your monadic package"
18:25:18 <kmc> hehe
18:25:23 <kmc> monads are not, for the most part, about adding new capabilities to the language
18:25:33 <kmc> they're about recognizing common patterns in things we could already define
18:25:43 <kmc> and providing general libraries based on those common patterns
18:25:51 <kmc> IO (and ST and STM) are exceptions to this rule
18:25:54 <alexyk> so it's just lookup then, unavoidable
18:25:57 <Blkt`> kmc: my problem is keeping the state for System.Random stuff, and my GHC doesen't import Control.Monad.State I don't know why...
18:26:16 <kmc> Blkt`, did you see http://hackage.haskell.org/package/MonadRandom
18:26:37 <kmc> what happens when you try that import?
18:26:50 <Blkt`> I did, but opted for System.Random (more examples around)
18:26:56 <kmc> ok
18:27:09 <Blkt`> I'd be glad to use it instead
18:27:21 <kmc> MonadRandom is probably simpler here
18:27:22 <Blkt`> but I'm not yet used to cabal, hackage and all of it
18:27:38 <kmc> $ cabal install MonadRandom
18:28:26 <Blkt`> kmc: failed to parse output of 'ghc-pkg dump'
18:29:13 <kmc> :/
18:30:13 <kmc> i don't know what to do about that error
18:31:41 <Blkt`> I'll handle that tomorrow, 3.30 am here
18:31:44 <Blkt`> good night people
18:31:49 <Blkt`> thanks kmc 
18:32:01 <kmc> 'night
18:38:08 <blackdog> can we shorten "filter (\x -> length x == length (nub x))" ?
18:38:25 <blackdog> am submitting a letter to the editor, and i want it as cryptic as possible
18:38:38 <aavogt> kmc: that error has to do with the wrong versions of cabal/ghc together
18:38:52 <aavogt> which can probably be resolved by upgrading one or the other
18:39:07 <aavogt> blackdog: is there an Ord instance?
18:39:13 <blackdog> aavogt: yep.
18:39:56 <blackdog> full program is main = unlines . reverse . sortBy (comparing length) . filter (\x -> length x == length (nub x)) . lines <$> getContents >>= putStrLn
18:40:25 <blackdog> looking for a sorted list of all words with non-repeating characters
18:41:56 <aavogt> @type on length `ap` nub
18:41:57 <lambdabot>     Couldn't match expected type `[a] -> c' against inferred type `Int'
18:41:57 <lambdabot>     In the first argument of `on', namely `length'
18:41:57 <lambdabot>     In the first argument of `ap', namely `on length'
18:42:06 <aavogt> @type on (==) length `ap` nub
18:42:06 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:42:40 <blackdog> where does ap come from?
18:42:55 <ivanm> Control.Monad IIRC
18:42:56 <applicative> Control.Monad
18:43:01 <aavogt> use <*> if you only keep the Control.Applicative import
18:43:01 <ivanm> @hoogle ap
18:43:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
18:43:02 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
18:43:02 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
18:43:49 <aavogt> @type foldr
18:43:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:44:01 <blackdog> @type on (==) length <*> nub
18:44:03 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:44:06 <aavogt> @type foldr (all . (==))
18:44:07 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Bool'
18:44:07 <lambdabot>     In the first argument of `(.)', namely `all'
18:44:07 <lambdabot>     In the first argument of `foldr', namely `(all . (==))'
18:44:07 <blackdog> beautifu
18:44:43 <ivanm> @type (==) `on` length <*> nub
18:44:44 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
18:44:44 <lambdabot>     In the first argument of `(<*>)', namely `length'
18:44:44 <lambdabot>     In the second argument of `on', namely `length <*> nub'
18:44:50 <ivanm> yeah, I was afraid of that
18:45:18 <aavogt> @type map (all (==))
18:45:19 <lambdabot>     Couldn't match expected type `Bool'
18:45:19 <lambdabot>            against inferred type `a -> Bool'
18:45:19 <lambdabot>     In the first argument of `all', namely `(==)'
18:45:30 <edwardk> woot, intervals handles tan correctly now
18:45:33 <aavogt> @type map (all . (==))
18:45:33 <lambdabot> forall a. (Eq a) => [a] -> [[a] -> Bool]
18:45:44 <blackdog> well, it's only a little shorter, but it's a lot less clear, so i think we're good.
18:45:49 <edwardk> 2-3 transcendental functions down, a dozen to go 
18:47:05 <aavogt> @type map (all . (==)) `ap` (zip . repeat)
18:47:06 <lambdabot>     Couldn't match expected type `a -> b'
18:47:06 <lambdabot>            against inferred type `[[a1] -> Bool]'
18:47:06 <lambdabot>     Probable cause: `map' is applied to too many arguments
18:47:38 <aavogt> @type \x -> zipWith ($) $ map (all . (/=)) x (repeat x)
18:47:39 <lambdabot>     Couldn't match expected type `[[a]] -> [b -> b1]'
18:47:39 <lambdabot>            against inferred type `[[a] -> Bool]'
18:47:39 <lambdabot>     In the second argument of `($)', namely
18:47:52 <aavogt> @type \x -> zipWith ($) (map (all . (/=)) x) (repeat x)
18:47:53 <lambdabot> forall a. (Eq a) => [a] -> [Bool]
18:48:21 <aavogt> @type zipWith ($) <$> map (all . (/=)) <*> repeat
18:48:22 <lambdabot> forall a. (Eq a) => [a] -> [Bool]
18:48:32 <aavogt> @type and . zipWith ($) <$> map (all . (/=)) <*> repeat
18:48:33 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
18:48:33 <lambdabot>     In the first argument of `(.)', namely `and'
18:48:33 <lambdabot>     In the first argument of `(<$>)', namely `and . zipWith ($)'
18:48:52 <aavogt> @type (and . zipWith ($)) <$> map (all . (/=)) <*> repeat
18:48:53 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
18:48:53 <lambdabot>     In the first argument of `(.)', namely `and'
18:48:53 <lambdabot>     In the first argument of `(<$>)', namely `(and . zipWith ($))'
18:49:10 <aavogt> @type fmap and . zipWith ($) <$> map (all . (/=)) <*> repeat
18:49:11 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:49:28 <applicative> blackdog, less clear? scrap the (>>=)  -- main = join $ putStrLn . unlines . reverse . sortBy (comparing length) . filter(\x -> length x == length (nub x)) . lines <$> getContents
18:49:36 <aavogt> @check \x -> (fmap and . zipWith ($) <$> map (all . (/=)) <*> repeat) x == (nub x == x)
18:49:36 <lambdabot>   "Falsifiable, after 1 tests:\n[()]\n"
18:50:04 <aavogt> =(
18:50:40 <blackdog> currently sitting on this: main = unlines . sortBy (comparing ((*(-1)) . length)) . filter (on (==) length <*> nub) . lines <$> getContents >>= putStrLn
18:50:54 <blackdog> but the join trick is cute.
18:51:17 <jesusabdullah> What does join do?
18:51:26 <jesusabdullah> @type join
18:51:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:51:39 <jesusabdullah> crap, over my head :C
18:52:04 <blackdog> hey, dude, i heard you like monads, so i put a monad in your monad so you can bind while you're returning
18:52:19 * blackdog probably mangled that meme
18:52:58 <mauke> (*(-1))? negate too simple for you?
18:53:05 <blackdog> didn't think of it
18:53:23 <blackdog> damn, and i've sent it in now
18:54:11 <mauke> :t sortBy (flip $ comparing length)
18:54:12 <lambdabot> forall a. [[a]] -> [[a]]
18:54:13 <blackdog> http://www.smh.com.au/opinion/column-8/column-8-20100613-y60t.html if anyone's interested
18:54:35 * applicative felt like was just getting started.   If we do it right we can replace all the (.)'s and the (<$>) with fmap, ...
18:54:44 <mauke> blackdog: do you know interact?
18:54:54 <blackdog> i've seen it, but didn't think of it
18:55:03 <blackdog> does that help here? you need to sort over the whole list
18:55:03 <aavogt> @check \x -> (liftA2 (.) (any . (==)) delete) x == (nub x == x)
18:55:04 <lambdabot>   Couldn't match expected type `[[a]] -> GHC.Bool.Bool'
18:55:07 <applicative> mauke, that makes it clearer though
18:55:44 <mauke> main = interact $ unlines . soryBy (flip $ comparing length) . lines
18:55:45 <blackdog> applicative: i think it's ok to make it clearer if you're making it shorter too
18:55:46 <applicative> your program is main = interact (unlines . reverse . sortBy (comparing length) . filter(\x -> length x == length (nub x)) . lines)
18:56:20 <sshc_> ghci isn't recording my command history.  How do I fix this?
18:56:36 <applicative> or rather main = interact $ unlines . sortBy (comparing ((*(-1)) . length)) . filter (on (==) length <*> nub) . lines
18:56:40 <blackdog> mauke: that's not right, you're not eliminating the dupel
18:56:41 <blackdog> dupes
18:56:42 * JoeyA wishes it did too.
18:56:51 <aavogt> @check \x -> (liftA2 (zipWith ($)) (map (liftA2 (.) (any . (==)) delete)) repeat) x == (nub x == x)
18:56:51 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
18:57:13 <aavogt> @check \x -> (liftA2 (fmap or . zipWith ($)) (map (liftA2 (.) (any . (==)) delete)) repeat) x == (nub x == x)
18:57:13 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
18:58:20 <aavogt> @check \x -> (liftA2 (fmap (not . or) . zipWith ($)) (map (liftA2 (.) (any . (==)) delete)) repeat) x == (nub x == x)
18:58:20 <lambdabot>   "OK, passed 500 tests."
18:58:44 <aavogt> @check \x -> (liftA2 (fmap (not . or) . zipWith ($)) (map (liftA2 (.) (any . (==)) delete)) repeat) x == (nub x == (x::[(Bool,Bool,Bool)]))
18:58:45 <lambdabot>   "OK, passed 500 tests."
18:59:02 <aavogt> too late blackdog
19:00:49 <applicative> wow, quite a few words in /usr/share/dict/words fit the bill e.g. dermatoglyphics
19:01:04 <sshc> ghci isn't recording my command history.  How do I fix this?  Could it be caused by using :cd in .ghci?
19:01:07 <blackdog> applicative: yep, that's the source i used too
19:02:23 <blackdog> i was kinda chuffed that the best one was actually a real word - there are a lot of proper names in there
19:03:19 <blackdog> sshc: is it recording anything in ~/.ghc/ghci_history ?
19:03:37 <aavogt> maybe it's not allowed to write that file?
19:04:27 * JoeyA just did mkdir ~/.ghc, and it worked
19:04:38 <JoeyA> that is, it started recording history
19:04:53 <sshc> blackdog: .ghc doesn't exist
19:05:13 <JoeyA> sshc: mkdir ~/.ghc
19:05:17 <JoeyA> That'll fix you up
19:05:20 <blackdog> res acu tetigisti
19:05:23 <sshc> Aha!  Creating .ghc worked.  Thanks JoeyA!!
19:05:24 <aavogt> I suppose that issue is infrequently run into, because any user-installs of libraries create that directory for you
19:05:46 <JoeyA> The thing that annoys me most about ghci's command line (editline, perhaps) is how it handles long lines.
19:05:55 <JoeyA> It doesn't wrap them, it just doesn't show the beginning.
19:06:21 <JoeyA> or the end, when you go back.  So when you need to look at a previous line, the end is chopped off rather than on the next line.
19:06:24 <aavogt> which ghc do you use?
19:06:55 <sshc> JoeyA: Works for me.
19:06:56 <kmc> jesusabdullah, join is (>>= id)
19:07:11 <kmc> or if you prefer, \m -> do { x <- m; x }
19:07:26 <kmc> run an action to get another action, then run that
19:07:46 <kmc> with the usual caveat that the metaphor of "running actions" works great for monads like IO and State, and less well for some others
19:07:47 <JoeyA> GHC 6.10.4, on Ubuntu.  However, I had to install something to get it to even handle arrowing back and forth correctly, IIRC.
19:08:03 <Gracenotes> JoeyA: same here
19:08:07 <aavogt> @type Mu
19:08:07 <lambdabot> Not in scope: data constructor `Mu'
19:08:12 <Gracenotes> the long-line thing is really very annoying
19:08:15 <aavogt> @type out
19:08:15 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
19:08:22 <kmc> @src Mu
19:08:22 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:08:27 <Gracenotes> it's hurt my productivity (lol) in many cases
19:08:45 <aavogt> @type fix (out =<<)
19:08:46 <Gracenotes> it worked fine with readline
19:08:46 <lambdabot> forall (m :: * -> *). (Monad m) => m (Mu m)
19:09:05 <kmc> :t in $ fix (out =<<)
19:09:06 <lambdabot> parse error on input `in'
19:09:07 <kmc> :t In $ fix (out =<<)
19:09:08 <lambdabot> forall (m :: * -> *). (Monad m) => Mu m
19:09:30 <aavogt> @type fix (return . In)
19:09:31 <lambdabot> forall (m :: * -> *). (Monad m) => m (Mu m)
19:11:01 * blackdog means rem acu tetigisti, of course. *wipes brow, gives thanks no latin scholars were paying attention*
19:11:40 <aavogt> preflex: seen copumpkin
19:11:40 <preflex>  copumpkin was last seen on #haskell-blah 6 days, 18 hours, 15 minutes and 37 seconds ago, saying: * copumpkin goes poof
19:13:10 * applicative thinks: "He is not dead, but sleeping"
19:13:16 <dons> hehe. citing one of steve yegee's rants in my thesis
19:13:37 <dons> in order to prove 200+ pages of evidence that he's wrong ;)
19:13:42 * dons does evil laugh
19:19:18 <ivanm> dons: :o
19:19:29 <ivanm> dons: so, waddaya think of the arguments I made on that wiki page?
19:24:05 <edwardk> woot: all transcendentals implemented except for asin and acos
19:24:07 <ryanakca> Is it possible to use guards within where? Ex: grahamScan on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26154#a26154
19:25:04 <interferon> trying to install yi and getting the error message seen here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26119
19:25:10 <interferon> anyone know how to resolve this?
19:26:13 <mauke> ryanakca: sure
19:27:02 <ezyang> interferon: Try installing an earlier version of data-accessor-monads-fd? 
19:27:11 <gwern> interferon: well, start with darcs yi first of all?
19:27:41 <interferon> ezyang: how can i specify the version cabal should install?
19:27:58 <interferon> gwern: why is that?
19:28:20 <Saizan> interferon: --constraint="data-accessor-monads-fd == 0.2" --constraint="data-accessor < 0.2.1.3"
19:29:34 <interferon> Saizan: easy enough.  that worked
19:29:55 <blackdog> dons: which assertion of yegge's do you think is wrong?
19:30:23 <blackdog> wouldn't be the one about requiring dynamic typing to evolve systems, would it?
19:36:51 <gwern> interferon: yi uses so many packages and releases so rarely that I've found it unprofitable to try to help anyone not using darcs
19:37:18 <gwern> blackdog: look at xmonad. evolves just fine
19:37:33 <dons> blackdog: type systems limit programmer expression
19:37:40 <dons> :)
19:37:50 <dons> puppets and marionettes etc
19:37:52 <kamatsu> wow
19:37:57 <kamatsu> for once i agree with jon harrop
19:37:58 <kamatsu> Phantom types are not "overly complicated". – Jon Harrop Apr 19 at 18:01
19:38:34 <kamatsu> i guess in the static vs. dynamic war, he's on our side
19:38:51 <dons> he's in no man's land, i think.
19:39:07 <ryanakca> mauke: Why do I get a parse error on line 53 then?
19:39:07 <dons> "I've had a bit more of a chance to play with phantom types now, and I'm 
19:39:07 <blackdog> gwern: i think the argument was evolving programs without shutting them down
19:39:25 <jbapple> @remember dons type systems limit programmer expression
19:39:25 <lambdabot> Done.
19:39:26 <dons> quite confused." -- Harrop 2004 08
19:39:36 <mauke> ryanakca: what's exact error?
19:39:50 <gwern> do f# or ocaml have phantom types?
19:39:58 <jbapple> gwern: yes
19:40:02 <blackdog> but i'm not going to put up much of a fight there. most of that stuff gets handled at the sysadmin level anyway - nobody loads new code into rails apps without redirecting requests somewhere else first.
19:40:04 <gwern> blackdog: and what do you think you do when you edit xmonad.hs and mod-q?
19:40:09 <ryanakca> mauke: gs.hs:52:13: parse error on input `where'
19:40:11 <dons> yegge makes a great guy fawkes for dynamic typing. burn him with fire!
19:40:20 <kmc> do Java, C#, and C++ have phantom types?
19:40:23 <kmc> methinks they all might
19:40:25 <mauke> ryanakca: your indentation is weird
19:40:26 <jbapple> gwern: Yarron Minsky (sp?) has talked about their use at Jane St. in some of his talks
19:40:35 <mauke> ryanakca: try indenting line 53 more
19:40:37 <kmc> certainly in C++ there's no requirement you use a template parameter within the template
19:40:40 <gwern> is a great guy fawkes better than a straw man?
19:41:03 <blackdog> gwern: i'm not actually sure. can you replace anything in the xmonad system, or just the bits that have been designed to be replaceabel?
19:41:32 <gwern> blackdog: offhand, I think you can't move between ghc versions
19:41:37 <ryanakca> Ah, 8 spaces instead of 4 spaces indentation fixed it
19:41:45 <ryanakca> Thanks
19:41:52 <blackdog> oh, more dumb questions; is there a mapMaybeM, or an idiomatic way to get it?
19:42:03 <kmc> blackdog, what's the function?
19:42:03 <dons> gwern: see the yi paper -- its not built with a replaceable architecture, except for the plugin state.
19:42:05 <mauke> ryanakca: better idea: start a new line after 'where'
19:42:11 <blackdog> i want something of type "(a -> m (Maybe b)) -> [a] -> m [b]"
19:42:17 <gwern> what's the type sig, kenneth
19:42:36 <kmc> :t \f -> (catMaybes <$>) . mapM f
19:42:37 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f (Maybe a)) -> [a1] -> f [a]
19:42:41 <blackdog> mayMaybe gives me (a->Maybe b) -> [a] -> [b] which is almost there
19:42:41 <kamatsu> @hoogle (a -> m (Maybe b)) -> [a] -> m [b]
19:42:42 <lambdabot> No results found
19:42:53 <blackdog> kamatsu: i did consult the oracle first, of course:)
19:42:55 <gwern> dons: what do you mean? we can replace the keybindings, the hooks, the layouts... what else is tehre to replace?
19:43:01 <jbapple> @hoogle unfoldM
19:43:01 <lambdabot> No results found
19:43:34 <dons> gwern: those are all plugin components. you can't e.g. replace something in Operations.hs
19:43:37 <ryanakca> mauke: Thanks
19:43:47 <dons> gwern: it is a "partially extensible app" by the paper's definition.
19:43:54 <kmc> blackdog, is that the one you wanted?
19:44:01 <blackdog> kmc: i guess that's the closest i'll get. might just define that as mapMaybeM locally
19:44:02 <jbapple> @djinn (a -> m (Maybe b)) -> [a] -> m [b]
19:44:03 <lambdabot> Error: Undefined type []
19:44:04 <blackdog> yep.
19:44:12 * kmc considers now the variant (a -> Maybe (m b)) -> [a] -> m [b]
19:44:23 <dons> not "fully extensible"' as not all code can be replaced dynamically while preserving state (additionally, there are parts in the X server we can't get it, which is interesting)0
19:44:41 <kmc> :t \f -> sequence . catMaybes . mapM f
19:44:41 <lambdabot>     Couldn't match expected type `Maybe (m a)'
19:44:42 <lambdabot>            against inferred type `[b]'
19:44:42 <lambdabot>       Expected type: [a1] -> [Maybe (m a)]
19:44:47 <dons> for the user, it feels like a fully extensible app though. since the important stuff survives
19:44:52 <dons> and the code most likely to change is easy to change
19:44:58 <kmc> :t \f -> sequence . catMaybes . map f
19:44:59 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> Maybe (m a)) -> [a1] -> m [a]
19:45:31 <gwern> dons: well, we can replace any unused exports like mouseDrag; if anything in Operations is used in a keybinding, we can write a local version and use that in a custom keybinding, so I must be missing something in my mental model
19:46:43 <ivanm> dons: so, waddaya think of the arguments I made on that wiki page?
19:47:06 * ivanm is currently adding Haddock documentation to the new + improved FGL (or whatever it's going to be called)
19:47:34 <gwern> ivanm: you will be crushed like a grunting pig beneath the steel belly of a 20 ton tank!
19:47:41 <ivanm> :o
19:48:47 <applicative> ryanakca, you don't have to have a where blah = blip where blip = fizzzz;  you can just have where, and the two definitions aligned, like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26154#a26155
19:49:55 <kmc> :t Refl
19:49:56 <lambdabot> Not in scope: data constructor `Refl'
19:50:29 <kmc> why is -XGADTs not -XGeneralizedAlgebraicDataTypes?
19:50:32 <ryanakca> applicative: Ah, lovely, thanks
19:50:34 <kmc> i feel we really dodged a bullet there
19:51:11 * ezyang says "YESSS!!" 
19:51:42 <mauke> kmc: they couldn't decide whether it should be Generalized or Generalised
19:51:43 <aavogt> and why not -XMPTCs
19:51:49 * kmc says "Using CTCP ACTION to convey speech acts is profoundly backwards"
19:52:06 <kmc> mauke, no doubt
19:52:11 <mauke> and why MultiParamTypeClasses and not MultiParameterTypeClasses?
19:52:12 * gwern disagrees
19:52:21 <kmc> MultipleParameterTypeClasses
19:52:26 <gwern> ducks on a param
19:52:37 <kmc> UnliftedForeignFunctionInterfaceTypes
19:52:45 <kmc> GlasgowHaskellCompilerForeignImportPrimative
19:52:52 <mauke> Primitive
19:52:57 <kmc> right, that
19:53:14 <kmc> -XExclamationPointPatterns
19:53:36 <applicative> ryanaka, I think you had a _ for the last case in the last line, but want "otherwise" .   Hlint has good advice for you by the way, I stuck them on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26154#a26156
19:54:35 <gwern> -XSupernaturalHashPoundSymbol
19:54:50 <aavogt> ghc comes with a pound of hask?
19:54:59 <mauke> do ho ho
19:55:08 * applicative tries -XNoSupernaturalHashPoundSymbol
19:55:13 <gwern> aavogt: mu!
19:55:15 <kmc> £Hask
19:55:56 * ivanm wonders if dons is ignoring him... >_>
19:55:59 <aavogt> gwern: traficking?
19:56:25 <gwern> does aavogt has the Hask nature?
19:56:43 <aavogt> "Your -XMagicHash is a controlled substance"
19:57:03 <ezyang> aavogt: Does it go in Control.Substance? 
19:57:41 <gwern> but what are the functors for the category of Schedule I terminal objects?
19:58:01 <kmc> hehe
19:58:16 <aavogt> paraphernalia?
19:58:28 <kmc> baking soda is a functor from cocaine to crack
19:59:08 <gwern> but if used to cut it, it's an injective (and not bijective) mapping
19:59:10 <kamatsu> kmc: what definition of functor? If it was a categorical functor, doesn't it have to include the cocaine and crack?
19:59:25 <kmc> someone needs to come up with a new functor-ish thing and call it a "Substance"
19:59:31 <kmc> maybe that should be the new name for Applicative
19:59:57 <Cale> kmc: I like it
20:00:05 <danharaj> unsafeCoerce should be renamed to badPun
20:00:18 <gwern> ick no, Substance is overloaded as it is
20:00:25 <kmc> and cast to sophisticatedWittyComment?
20:00:48 <kmc> also danharaj i like your suggestion because it's a bad pun ;P
20:00:54 <kmc> @remember danharaj unsafeCoerce should be renamed to badPun
20:00:54 <lambdabot> Okay.
20:00:59 <kmc> or maybe a good pun even
20:01:03 <Cale> Have you seen the crazy names of things from set theory? They've given up and just started naming stuff after animals.
20:01:12 <Cale> http://en.wikipedia.org/wiki/Mouse_%28set_theory%29
20:01:15 <danharaj> kmc: Like a Haskell programmer, I work on all kinds of levels.
20:01:16 <kmc> i remember seeing some topology that had spiders and foams
20:01:27 <danharaj> or perhaps even, all levels of kinds.
20:01:34 <Cale> There are also beavers, premice, and some stuff I don't remember
20:01:44 <Saizan> so set theory is the new ubuntu?
20:01:45 <Cale> Also, there's something called zero hand grenade.
20:02:00 <kmc> large cardinals?!?
20:02:13 <kmc> 50 ft. tall catholic priests
20:02:14 <gwern> danharaj: I work on many levels too. unfortunately because there is an infinity of levels below good taste, most of my work is in bad taste
20:02:21 <Cale> heh
20:02:24 <kmc> almost everything is bad taste?
20:02:44 <applicative> Inaccessible Cardinals, Princes of the Church!
20:02:45 <gwern> kmc: objects in good taste have measure zero...
20:02:52 <gwern> kmc: actually, you don't need to be a priest to be a cardinal. little known fact
20:03:08 <gwern> kmc: it's possible for non-priests to become pope
20:03:09 * kmc did not know
20:03:14 <kmc> i knew that actually
20:03:17 <kmc> any Catholic male, right?
20:03:22 <ivanm> Cale: for functions like insert, etc., in your opinion would they be better off as Node -> Graph -> Graph or Graph -> Node -> Graph (for folding, etc.) ?
20:03:23 <gwern> because knowledge is power!
20:03:33 <ivanm> gwern: really?
20:03:37 <ivanm> I thought they had to be a priest
20:03:40 <gwern> kmc: adult too, iirc, in good standing
20:03:42 <ivanm> and in practice at least a pope
20:04:03 <kmc> http://animalnewyork.com/2010/06/ive-got-your-pope-now-give-me-your-money/ (related, off-topic, video is hilarious and NSFW)
20:04:15 <gwern> ivanm: well, knowledge is power because if we had enough knowledge we could construct maxwell's demon, and extract energy from a system
20:04:29 <gwern> pace the information-theoretic interpretation of thermodynamics
20:04:43 <ivanm> no, the "it's possible for non-priests to become pope" bit
20:05:05 <gwern> would it help if I said it again?
20:05:08 <gwern> actually, you don't need to be a priest to be a cardinal. little known fact
20:05:13 <gwern> it's possible for non-priests to become pope
20:05:14 <Cale> ivanm: That one's hard to say, are you more likely to insert the same node into many graphs, or insert many different choices of node into the same initial graph?
20:05:26 <ivanm> yeah
20:05:34 <aavogt> gwern: in fact you an just be a bird
20:05:37 <Cale> ivanm: I think I'm leaning toward Node -> Graph -> Graph
20:05:38 <applicative> a pope must be 'bishop of Rome', and thus a priest
20:05:42 <ivanm> I'm thinking of mapAccum kind of stuff though
20:05:45 <ivanm> Cale: fair enough
20:05:55 <Cale> ivanm: because endofunctions are nice
20:06:09 <gwern> applicative: I think the bishop of rome accompanies the pontiffship
20:06:10 <Cale> So insert x :: Graph -> Graph, which is good
20:06:16 <ivanm> yeah
20:06:23 <ivanm> gwern: yeah
20:06:23 <gwern> pope = bishop of rome, bishop of rome = pope
20:06:41 <gwern> (the pontifex? the words are used so rarely I'm not sure of the right one)
20:06:53 <kmc> pontifex maximus
20:06:57 <blackdog> kmc: that's hilarious
20:06:59 <kmc> greatest bridge-maker
20:07:02 <applicative> gwern, I think it does, but I think bishop x |- priest x   and ~ priest x |- ~ bishop x
20:07:06 * hackagebot intervals 0.1.0 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.1.0 (EdwardKmett)
20:07:08 * hackagebot intervals 0.1.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.1.1 (EdwardKmett)
20:07:15 <kmc> edwardk, you've outdone yourself
20:07:29 <edwardk> kmc: =)
20:07:29 * applicative is amazed
20:07:30 <gwern> applicative: you speak with a forked tongue white devil
20:07:35 <ivanm> kmc: because he did two releases of the same package in close succession?
20:07:50 <kmc> yeah
20:07:56 <edwardk> i found the bug before hackagebot made the announcement ;)
20:08:07 * applicative is running diff on 0.1.0 and 0.1.1
20:08:09 <gwern> edwardk: if you keep this up, you'll be able to beat my mueval release ANN record of 7 or 8 versions
20:08:09 <danharaj> sounds like an extreme sport
20:08:11 <edwardk> (i'd forgotten to export the actual _type_ for the Intervals)
20:08:21 <danharaj> "fix the package before hackagebot notices"
20:08:36 <ivanm> ugh, tomberek writes weirdly formatted code
20:08:40 <ivanm> danharaj: lol
20:08:45 <edwardk> ok, this is released because it is the first version that actually doesn't have any 'undefineds' in it
20:08:51 <edwardk> it probably still has bugs
20:08:57 <edwardk> anyone feel like helping me squash them?
20:09:05 * ivanm passes edwardk a mallet
20:09:07 * danharaj grabs a mallet
20:09:22 <jbapple> edwardk: I found a bug -- the cabal file has no description
20:09:31 <gwern> one of the funnier things in _Ah! My Goddess_ was Skuld running around with her hammer squashing computer bugs
20:09:36 <edwardk> jbapple: hah fair enough. i'll add something ;)
20:09:38 <ivanm> jbapple: that was quick!
20:09:44 <jbapple> :-)
20:09:56 <jbapple> also patch-tag is down
20:09:58 <danharaj> does he win a prize?
20:10:14 <jbapple> My very own interval!?!
20:10:22 <edwardk> jbapple: that may make browsing the code a bit difficult ;)
20:10:38 <gwern> jbapple: you win the usual No-Prize
20:10:52 <gwern> if you are unfamilair with no prizes, wikipedia will edumacate you
20:11:26 <danharaj> Haskellers should at least get () prizes.
20:12:16 <jbapple> _|_-prizes
20:12:33 <gwern> (wow, this [[Master Keaton]] anime really did its research. who back in the early 90s knew about hard objects like ceramnic or hardened steel being able to completely shatter windshields?)
20:12:53 <jbapple> That would probably just devolve into jokes about butts, like "Chasing Bottoms"
20:13:12 <aavogt> haha, jbapple
20:13:40 <jbapple> @where chasing bottoms
20:13:40 <lambdabot> I know nothing about chasing.
20:13:47 <gwern> jbapple: but we already have chasingbottoms...
20:13:56 <gwern> @vixen oh, surely you do?
20:13:56 <jbapple> @where chasingbottoms
20:13:57 <lambdabot> yeah
20:13:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/streams/ChasingBottoms/
20:14:15 <jbapple> gwern: yes, that is the pun to which I was referring.
20:14:25 <edwardk> jbapple: ok, i've added a short "wtf is an interval' spiel to the top of the description in the repo version of it
20:14:30 <kmc> i gotta get a copy of this movie
20:14:55 <ivanm> @ask tomberek should we make singleton :: LNode g -> g (since a singleton Context can't have any edges anyway) ?
20:14:56 <lambdabot> Consider it noted.
20:16:40 <ivanm> edwardk: including "why you should use this library" ?
20:16:49 <gwern> and with strange eons / even IE may die
20:17:16 <edwardk> ivanm: well, this library, for me is a stepping stone to building taylor models ;)
20:17:29 <ivanm> heh
20:17:55 <ivanm> my point is that you shouldn't really produce one-off libraries just to make your logic easier; you should write them to help other people as well
20:17:58 <edwardk> ivanm:  but, well, its useful to be very pedantic about error bounds coming out of long floating point operation chains
20:18:02 <edwardk> Prelude Numeric.Interval> pi :: Interval Double  ==> 3.141592653589793 ... 3.1415926535897936
20:18:30 <edwardk> Prelude Numeric.Interval> sin pi :: Interval Double ==> -3.8285686989269494e-16 ... 2.8362728848865485e-16
20:19:15 <edwardk> ivanm: well, its the kind of library that people have tried to write, but haven't been willing to tackle all the pedantic corner cases needed to get it to work
20:19:25 <kmc> edwardk, how are you computing pi?
20:19:35 <kmc> and sin
20:19:36 <jbapple> This seems like something that would benefit greatly form the sort of esoteric floatingpoint tricks in glibc or netlib libraries or the gnu scientific library
20:20:00 <edwardk> kmc: those are using the underlying platform's floating point operations, just with adjusted rounding modes.
20:20:02 <jbapple> in particular, code like "x `fmod` pi2" is something to be feared
20:20:08 <edwardk> pi is manually calculated to provide the lower and upper bound
20:20:32 <edwardk> jbapple: this is _using_ the various esoteric floating point tricks in glibc ;)
20:20:37 <edwardk> that is what fmod is all about ;)
20:20:37 <kmc> ok
20:20:48 <kmc> so you use e.g. Double's implementation of sin
20:20:50 <edwardk> i had to export it from numeric-extras so i could provide it ;)
20:20:58 <edwardk> kmc: yeah, with forced rounding modes.
20:21:09 <kmc> but pi is special (hardcoded?) to have a bound on the approximation
20:21:28 <edwardk> since the constant for pi that comes with haskell has an unspecified rounding
20:21:32 <kmc> yeah
20:21:50 <edwardk> so i manually construct a pair of doubles that have the right rounding to get conservative lower and upper bounds
20:22:04 <edwardk> (and the same with the floats)
20:22:34 <jbapple> edwardk: those libraries are filled with dozens of fancy tricks. This file seems a bit short to be incorporating all of them. I know Haskell is expressive, but still :-)
20:22:42 <kmc> this means that the Floating instance for (Interval a) is nonparametric in a, right?
20:23:11 <edwardk> jbapple: there are 2 other packages, numeric-extras and rounding ;)
20:23:26 <jbapple> And clever floating point arithmetic is often not easy to modularize
20:23:37 <edwardk> jbapple: numeric-extras exports a number of glibc goodies that i need, rounding provides the control over the rounding mode.
20:24:26 <edwardk> my point earlier regarding fmod is that fmod is actually a glibc function, so it was ironic you were pointing to it as an example of something esoteric that could benefit from glibc magic ;)
20:25:03 <jbapple> but even glibc functions sometimes avoid fmod where function-specific analogues provide much more precision
20:25:43 <edwardk> jbapple: well, in this case i need to know how things line up with 2*pi, so i can know if i have a window that subsumes an entire cycle of cos
20:25:55 <edwardk> so i can't really think of a better model than appealing to fmod. ;)
20:26:33 <edwardk> and i appear to be in good company, the approach taken by boost::interval and sun's interval library both boil down to fmod to find the cycle and divvy it up from there
20:27:14 <edwardk> now, i appear to have a bug in cos, somewhere, but that is a separate concern ;)
20:27:40 <jbapple> edwardk: oh, I'm not saying it's easy -- what I'm getting at is that people spend years getting these things right. One FP library for C spend a year on a cluster just building a proper fmodpi function with <1 ulp accuracy
20:28:19 <jbapple> This seems like a great use of the FFI
20:28:22 <edwardk> jbapple: sure. but since there isn't one right now, i figured i should take a stab at providing a starting point for discussion
20:28:30 <jbapple> ok, fair enough
20:28:35 <applicative> yipe -- foreign import ccall unsafe "math.h fmod" 
20:28:47 <edwardk> feel free to provide a nice little fmodpi function ;)
20:29:10 <edwardk> applicative: hahaha
20:29:38 <jbapple> I'll see if I can find it tomorrow.
20:29:41 <edwardk> jbapple: also keep in mind that all i need is a conservative lower and upper bound on it
20:29:58 <edwardk> jbapple: i don't care about a little slop up or down, just that i _only_ slop up or down
20:30:37 <edwardk> applicative: did you mine through numeric-extras?
20:31:06 <applicative> yeah, i was looking for gruesome ccalls and there they were, not in the interval module
20:31:08 <edwardk> jbapple: i've isolated one bug but can't figure out what i'm doing wrong
20:31:25 <kyagrd> is patch-tag website working now?
20:31:31 <kyagrd> having trouble logging in
20:31:42 <applicative> it seems like a lamba-maniacal type might have something to say about the 'dependency problem' mentioned in the Wikipedia article on interval arithmetic
20:31:53 <applicative> lambda-maniacal
20:32:06 <applicative> kyagrd, it has seemed down to me too. 
20:32:49 <edwardk> jbapple: my main goal for these is to be able to generate taylor models which are basically snubbed off taylor polynomials with an interval attached to bundle up all the lower order terms
20:33:10 <applicative> where is this 'Numeric.Rounding'?
20:33:15 <edwardk> jbapple: they provide much MUCH tighter bounds than using intervals directly
20:33:19 * hackagebot intervals 0.1.2 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.1.2 (EdwardKmett)
20:33:21 <applicative> wait, don't answer that....
20:33:22 <edwardk> applicative: on hackage under 'rounding'
20:33:38 <edwardk> applicative: that is where the real evil lies
20:34:32 <aavogt> edwardk: you check (and change) the rounding mode for every operation?
20:34:41 <applicative> i see it now, God help us
20:35:11 <applicative> foreign import ccall unsafe "rounding.h merff"    merff :: CInt -> CFloat -> CFloat  -- merff indeed
20:35:14 <edwardk> aavogt: set and reset
20:35:45 <edwardk> moded 'erf' (error formula) for floating points 
20:35:53 <aavogt> any idea how much that costs, relative to say CReal?
20:36:23 <edwardk> aavogt: CReal invokes a lot of machinery and has a pretty uncertain memory footprint, so its hard to say
20:36:25 <kmc> CReal is really slow
20:36:37 <Gracenotes> it's magical
20:36:41 <kmc> there are faster real-arithmetic libs
20:36:48 <edwardk> but i should win pretty handily over CReal
20:37:19 <Gracenotes> arbitrary fixed precision is a bit easier than arbitrary unfixed precision
20:37:42 <edwardk> this will be ~5-6 times slower than forcing the cpu into 'round up' mode and then doing sign flip tricks, but it plays nicer with other code using floating points
20:37:47 <Gracenotes> (and more performant, even if the former isn't lazy)
20:38:42 <danharaj> does haskell have a way of playing with SIMD instructions for float crunching?
20:38:46 <edwardk> so expect to pay a factor of 20 over the raw floating point ops at the bare minimum
20:39:10 <danharaj> well, I mean GHC in particular.
20:39:52 <edwardk> hrmm i appear to have a bug in of all things 'sin 1'
20:40:04 <edwardk> something about that quadrant of cos is screwy
20:40:04 <danharaj> wut
20:40:17 <edwardk> Prelude Numeric.Interval> sin 1 :: Interval Double ==> 0.8414709848078963 ... 0.2664114616932643
20:40:22 <edwardk> the interval is empty
20:40:23 <kyagrd> who should we email for patch-tag?
20:40:27 <edwardk> it has the right lower bound
20:40:39 <edwardk> kyagrd: thomas hartman, no idea what his email is though
20:40:59 <kyagrd> oh there is google groups that might be the place
20:42:05 <gwern> danharaj: I've never heard of ghc using simd I think
20:42:18 * applicative avoids floating points by using  module HReal  where  ...  data Peano = Zero  | Succ Peano ; type Cantor = Peano -> Bool
20:42:28 <danharaj> gwern: I think so too, I see some proposals for it.
20:55:26 <edwardk> ok. the bug appears to be outside of this module, Numeric.Rounding gives very different answers for rounding up and down cos 2.570796326794896
20:58:10 <edwardk> which points to the bug being that glibc doesn't handle the !@*#() rounding modes
20:58:20 <edwardk> http://sourceware.org/bugzilla/show_bug.cgi?id=3976
21:02:41 <danharaj> edwardk: Did you really expect someone else to not lie to you?
21:02:49 <edwardk> danharaj: =/
21:03:07 <edwardk> danharaj: this unfortunately takes this from a fun weekend project to glibc hell
21:07:31 <edwardk> what irks me is that i can just call fcos myself and get the right rounding ;)
21:08:17 <danharaj> I have a feeling your stuff won't work at all on windows.
21:08:26 <edwardk> danharaj: it won't
21:08:30 <danharaj> lovely.
21:08:59 <edwardk> there exist windows equivalents to setting the fpu control word
21:09:46 <danharaj> http://msdn.microsoft.com/en-us/library/e9b52ceh(VS.80).aspx?ppud=4
21:09:48 <danharaj> this, yah?
21:09:59 <edwardk> yeah
21:11:30 <danharaj> hmm, hasn't the x87 been superceded by... I want to say SSE?
21:11:40 <edwardk> danharaj: it has.
21:12:30 <edwardk> theoretically the command to set rounding mode should affect all libc operations, regardless of implementation, in practice, the glibc guys, as usual, flip the bird to anyone with esoteric requirements
21:13:04 <danharaj> edwardk: Didn't you know, being free software means being free of obligations to your users.
21:13:43 <blackdog> danharaj: of course. if it breaks, you get to keep both halves
21:13:44 <edwardk> i blame the culture fostered there by drepper
21:14:36 <danharaj> edwardk: I still have huge grudges against that bastard goat from when I tried to play with C/++ using open source tools on Windows.
21:16:18 <edwardk> so at this point my rounding library is as good as the underlying libc ;)
21:16:26 <danharaj> heh :p
21:16:30 <ezyang> +1 
21:16:55 <danharaj> The next logical step is to make a libc that doesn't suck goat balls.
21:17:09 <edwardk> danharaj: i'm not willing to shave that yak tonight ;)
21:17:57 <edwardk> i was hoping to find better ieee routines in libosl or something but i'm not finding any yet
21:20:33 <edwardk> danharaj: ah looks like libosl doesn't have it in scope either
21:21:48 <edwardk> what is truly sad is i can rip out support for the rounding modes, but all i do is cripple the code's ability to be used for real scientific hard bounds
21:23:52 <edwardk> sun has a lib: http://www.sun.com/download/products.xml?id=41797765
21:24:02 <edwardk> er oracle i guess these days
21:25:29 <edwardk> ah woot http://lipforge.ens-lyon.fr/www/crlibm/ which is lgpl
21:25:33 <danharaj> I would actually trust microsoft's libc to not suck.
21:25:42 <edwardk> danharaj: good luck with regards to this ;)
21:26:00 <danharaj> edwardk: It is you who needs all the luck :p
21:26:14 <danharaj> edwardk: You are the wizzard playing with dark magicks
21:26:49 <mxc> why does: import Prelude hiding (lookup, (:)) case a parse error on the :
21:27:00 <edwardk> there does not appear to be an ubuntu package for crlibm though
21:27:38 <danharaj> edwardk: Enjoy shooting yourself in the foot as you try to disentangle arcane build formulae and the whispers of lost souls.
21:28:00 <mxc> oh, nevermind, i get it
21:28:01 <mxc> sry
21:28:13 <edwardk> danharaj: now that is either a very mixed metaphor or an intro to a stephen king novel
21:28:35 <danharaj> Well I was going for the whole wizzard theme, moving towards lovecraftian elements.
21:28:47 <danharaj> also, wizzard [sic]
21:28:48 <edwardk> with a bit of gunslinger mixed in =)
21:29:18 <danharaj> yes, I suppose the appropriate action would be to shatter your mind against the cobblestone path of madness.
21:29:33 <edwardk> already have ;)
21:29:57 <danharaj> The mixing of abstract and concrete concepts in the metaphor is *deliberate*. I am so awesome.
21:30:13 <edwardk> so it looks like my best plan of attack is to remove the dependency on Numeric.Rounding from intervals, which simplifies the code a lot
21:30:25 <edwardk> and then just accept the fact that its inexact
21:30:36 <kniu> Can you do type inference with dependent types?
21:30:43 <edwardk> kniu: in general no
21:30:47 <kniu> dang.
21:31:04 <edwardk> kniu: ben pierce has some papers on various approaches to do so locally in an ad hoc manner
21:31:19 <edwardk> but overall that is kind of the reason why haskell exists at the point in the design space that it does
21:32:00 <danharaj> I like writing my types down- well most of them, anyway.
21:32:26 <kniu> will Haskell one day have -XDependentTypes?
21:32:38 <edwardk> kniu: if it does it'll be -XAgda ;)
21:32:45 <danharaj> That is a far more drastic extension than anything done so far.
21:35:57 <jmcarthur> i think if you bring the type system any farther along than haskell you are better off asking for program inference than type inference ;)
21:36:13 <danharaj> heh :p
21:36:15 <jmcarthur> that is, write a type and the implementation is inferred for you. of course, i'm half kidding
21:36:30 <edwardk> jmcarthur: we call those 'tactics' ;)
21:36:45 <jmcarthur> edwardk: they are not entirely hands-free yet ;)
21:37:18 <jmcarthur> of course, they may never be
21:38:01 <kniu> It would be interesting, though, if we program "top down" by writing specifications instead of programs.
21:38:48 <Artelius> kniu: heard of the seL4 project?
21:38:54 <kniu> yeah.
21:39:14 <Artelius> we'd love it if all you had to do was write specs
21:39:38 * hackagebot intervals 0.1.3 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.1.3 (EdwardKmett)
21:39:44 <Artelius> Ah, maybe one day
21:39:51 <edwardk> uploaded a final bug fix before i go and turn off rounding modes completely =(
21:40:47 <danharaj> edwardk: You cannot give up!
21:40:58 <danharaj> edwardk: Don't believe in yourself. Believe in me who believes in you.
21:41:06 <edwardk> danharaj: hah
21:41:31 <danharaj> Yours is the library that will pierce the heavens.
21:41:43 <edwardk> danharaj: well, the support for rounding modes was really just so that someone might try to use this for scientific computing. the version without it should be able to be used with creals', etc to the same end
21:42:25 <danharaj> Do you intend on revisiting rounding modes some other time?
21:42:38 <danharaj> or maybe at least just yell at the glibc neckbeards to fix their stuff?
21:42:50 <edwardk> danharaj: perhaps. my goal right now is to support taylor models. the rounding stuff is a nice to have
21:43:19 <danharaj> mmm
21:43:43 <edwardk> this actually greatly simplifies the code for Interval
21:44:00 <danharaj> and what is the ultimate aim of... modelling Taylor Models?
21:44:25 <edwardk> danharaj: mostly vetting the correctness of my automatic differentiation library ;)
21:44:32 <danharaj> sweet.
21:44:39 <danharaj> and the aim of that is, I presume, take over the world.
21:45:13 <John__> hi
21:45:19 <John__> what's 'the point' of haskell
21:45:28 <John__> for lisp it's AI
21:46:09 <edwardk> danharaj: hrmm, ripping out the rounding mode code actually liberalized a TON of the types there
21:46:31 <dons> John__: http://donsbot.wordpress.com/2009/01/24/what-is-haskell-good-for/
21:46:48 <dons> John__: alternatively, http://www.sdtimes.com/blog/post/2009/07/27/Everyonee28099s-talking-about-Haskell.aspx
21:46:55 <danharaj> edwardk: But isn't the whole point to make the typechecker seize every time it sees your code?
21:47:07 <edwardk> John__: haskell is amazing at using types to help you reason about parallelism, to handle a lot of ad hoc things like polymorphism in a less ad hoc way, and at giving you tools to reason about problems and compose them out of a ton of recyclable bits and pieces.
21:47:20 <John__> dons: Well that has some things it can be used for.
21:47:29 <John__> dons: I want to know it's strengths, I can do all that in python.
21:47:31 <Cale> John__: Haskell is a general purpose language (for that matter, lisp is as well)
21:47:39 <dons> John__: see the second article then.
21:48:00 <dons> there's no single 'thing' for a general purpose language. but parallelism, safety and domain specific languages are sweet points
21:48:01 <Cale> It's good at lots of stuff which isn't easily qualified as a specific type of application
21:48:13 <danharaj> John__: Haskell is a general purpose language, it is supposed to be used in a wide variety of areas. The advantages it has over other general purpose languages like C and C++ is that it is easier to reason about, has powerful tools for writing concise and correct code, and an expressive type system.
21:48:26 <John__> Hmm, I see.
21:48:28 <danharaj> amongst other things.
21:48:31 <John__> It's not widely used, though, is it?
21:48:33 <dons> its a bit of a fallacy to say the point of lisp is AI for example. that's not really correct since 1990.
21:48:37 <John__> I mean, no company really uses it.
21:48:46 <Artelius> John__: Actually there are quite a few
21:48:58 <danharaj> John__: It depends on what you mean. Compared to C, no language is 'really used'.
21:49:12 <edwardk> John__: there are quite a few companies that use haskell, it depends on what market you're in
21:49:15 <John__> dons: Well, I'm learning Lisp so I can experiment with AI/Genetic programming, the good guys at #lisp pointed me in the right direction of some books there.
21:49:23 <Artelius> Galois to name one, they use it for reliability
21:49:27 <dons> John__: we have an industrial backing group, a commercial users workshop, and a reasonable collection of commercially produced libraries.
21:49:33 <John__> danharaj: Well java is used more than C.
21:49:34 <dons> John__: well i'd say parallelism then.
21:49:44 <dons> John__: parallel programming of multicores is something haskell does very well
21:49:51 <John__> dons: Hmm, ah yeah, thanks.
21:49:57 <dons> the other thing is correct software. haskell makes it easier to build correct things
21:50:04 <John__> Ah yeah.
21:50:07 <dons> the company i work for relies on haskell for that characteristic
21:50:26 <SubStack> languages that everybody uses tend to suck, since they lag the state of the art by 10 or 20 years
21:50:38 <kmc> or 70 years
21:50:50 <dons> for parallelism, we have a lot of support, here's a summary, http://www.reddit.com/r/programming/comments/cdaha/why_functional_programming_matters_john_hughes/c0rtmkg
21:50:51 <kmc> i hear C++ will get lambda sometime next year
21:50:52 <John__> SubStack: Hah, yeah, that's possible.
21:50:59 <danharaj> http://book.realworldhaskell.org/
21:51:16 <SubStack> kmc: I also hear that c++ lambda will suck
21:51:22 <kmc> i think the "Lisp is for AI" thing is pretty old
21:51:26 <kmc> that may be why Lisp was invented
21:51:30 <Artelius> Haskell faces the traditional chick-and-egg problem; programmers don't learn Haskell cause few people hire (and also due to the big learning curve), few people hire cause it's hard to find programmers. But it's an awesome language!
21:51:32 <kmc> i'm not sure it's why you should care about Lisp today
21:51:50 <dons> Artelius: i don't think that's true. lots of people learn haskell.
21:51:51 <kmc> by that token, Haskell is for research, and C is for porting UNIX
21:51:53 <danharaj> There's a reason to care about Lisp? :p
21:51:59 <dons> its not really tied to the job market, as far as i can tell.
21:52:00 <SubStack> people learn languages just to get hired?
21:52:14 <danharaj> SubStack: Most programmers are programming to make a living, so yes.
21:52:17 <kmc> Artelius, conversely, if you do hire Haskell programmers, you know that they're capable of learning on their own and motivated enough to do so
21:52:22 <dons> now, if you're good at haskell, you can get hired.
21:52:27 <dons> but you need to be very good.
21:52:27 <John__> Haskell isn't that popular, though - shouldn't it be more popular among amateurs?
21:52:31 <SubStack> danharaj: I guess I just see this as ridiculous since I don't want to get hired
21:52:39 <John__> I mean, among professionals obviously not because there aren't many jobs.
21:52:42 <danharaj> John__: How long do you think a language takes to become mainstream?
21:52:42 <dons> it has a large open source community, in comparison with similar languages
21:52:47 <edwardk> dons: i've received quite a few job offers since learning haskell actually ;)
21:52:56 <dons> edwardk: indeed. it is a distinguishing feature
21:52:57 <John__> danharaj: Well Python is main stream and younger than haskell, isn't it?
21:52:57 <kmc> completely separate from any merits of the language, are the merits of people who will learn a language for reasons other than monetary gain
21:53:41 <danharaj> John__: Python also has a completely different approach to programming. You have to look at the area Haskell is contending in. Haskell is in the same arena as behemoths like C and C++, not languages like Python and Ruby.
21:53:48 <Artelius> dons: Lots of people learn haskell, but far more people learn Java
21:54:00 <John__> danharaj: Well, lisp is more popular than haskell.
21:54:04 <danharaj> John__: Not to say Python and Ruby don't matter, they are just completely different markets.
21:54:09 <kmc> John__, by amateurs you mean people writing Haskell code not for pay?
21:54:12 <Artelius> and the fact that Haskell is as popular as it is, IMO, is testament to what a fantastic language it is
21:54:13 <John__> According to: http://www.langpop.com/
21:54:16 <danharaj> John__: Lisp is older than the dinosaurs ;p
21:54:46 <mxc> @src Data.Map.alter
21:54:47 <lambdabot> Source not found. Are you on drugs?
21:54:51 <John__> Even Pascal, scheme, fortran are.
21:55:04 <John__> This is not to say I don't like haskell, I haven't really tried it.
21:55:06 <danharaj> John__: I don't know if that site is reliable in any way. I'll have to take a look at it.
21:55:08 <John__> It's probably excellent.
21:55:13 <kmc> i think it's well attested throughout every realm of human activity that popularity and quality do not have an especially strong correlation
21:55:22 <kmc> and so it's still a valid interesting question to ask 'why is Haskell not more popular'
21:55:30 <dons> John__: so why are you in #haskell ?
21:55:34 <kmc> but if others engage that question with its technical merits
21:55:40 <kmc> then you are likely to end up talking at cross purposes
21:55:45 <John__> dons: Scroll up.
21:55:52 <John__> dons: Just wanted to have a chat, really.
21:55:59 <dons> ah i see.
21:56:17 * dons notes #haskell is the 3rd largest programming language irc channel. :-)
21:56:27 * SubStack is using haskell to control an underwater ROV
21:56:34 <John__> Interesting. Is #python the biggest?
21:56:38 <danharaj> John__: For example I see one of that site's datasets is books published. That is a spurious metric IMO. Java is a heavily commercialized language with a lot of snake oil instruction. It has a lot more books than C, but that's because C has a few canonical references.
21:56:51 <dons> and the 3rd largest reddit channel.
21:56:57 <dons> oh, we're 2nd largest, after #python.
21:56:58 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
21:57:08 <kmc> Java has lots of books about "design patterns"
21:57:16 <John__> dons: ahh, I see
21:57:17 <kmc> which are libraries that you have to type in by hand
21:57:33 <John__> A question could be how java became so popular.
21:57:38 <SubStack> kmc: awesome way of thinking about it
21:57:52 <dons> SubStack: `control an underwater ROV' really? 
21:57:52 <kmc> Java is an enormous business success and fills a hugely important social role, no matter how much we may dislike it technically
21:57:53 <danharaj> John__: Java had a large amount of corporate backing and millions dumped into it.
21:57:54 <dons> sounds very cool
21:58:11 <John__> kmc, danharaj: ahhh, I see
21:58:11 <Artelius> Yeah, Java is also easy to sell to middle management
21:58:22 <John__> Artelius: go on
21:58:28 <kmc> it brings good and bad programmers closer to the same level, prevents the bad ones from doing too much damage, and generally makes it easier to pump out boring software as a repeatable process using interchangeable workers
21:58:42 <dons> btw, the deadline for submitting talks to the commercial users workshop is tuesday
21:58:46 <Artelius> "Platform independence!" And explaining OO using real-world examples. Like cars.
21:58:51 <kmc> and this is fine, i support this, most of the software in the world is boring and many of the programmers in the world are happy to do that
21:59:02 <John__> kmc: haha, I see
21:59:09 <dons> http://cufp.org/2010-call-presentations
21:59:12 <John__> Artelius: haha
21:59:14 <dons> i'll see a bunch of you there.
21:59:14 <SubStack> dons: yep, for a contest down in Hawaii with homemade circuit boards and everything
21:59:20 <dons> SubStack: nice
22:00:07 <SubStack> dons: right now I'm building a nifty opengl dashboard on top of the control stuff so I can graph the frequency decomposition from the hydrophone
22:00:12 <Artelius> How Java became the language of choice for smartphones we may never know :)
22:00:19 <kmc> it's not
22:00:24 <kmc> very few Java apps for iPhone
22:00:42 <Artelius> I don't think of the iPhone as a smartphone
22:00:44 <danharaj> I am amused that that popularity site John__ linked is so heavily influenced by delicious.com being included in the dataset.
22:01:06 <kmc> Artelius, because it sucked a lot less than previous smartphones?
22:01:33 <John__> danharaj: not really, you can control how much influence is placed on where, it seems
22:01:35 <kmc> Java is a big deal in many areas but i wouldn't call it *the* language of choice for much of anything
22:01:57 <kmc> it tends to have viable competitors
22:01:57 <Artelius> yeah yeah
22:02:08 <Artelius> there's Symbian C++ and Obj-C to compete with
22:02:24 <kmc> and JavaScript and ActionScript
22:02:50 <danharaj> To be fair, actionscript is a terribad language.
22:02:53 <kmc> sure
22:02:55 <Artelius> but it's still big enough that ARM create that Jazelle stuff
22:03:00 <kmc> yeah
22:03:07 <kmc> it is big, no question
22:03:13 <kmc> you can write iPhone apps in Haskell
22:03:16 <kmc> and soon Android apps as well
22:03:20 <kmc> (but don't tell Apple ;P)
22:03:30 <John__> Lol, android
22:03:31 <danharaj> Or Steve Jobs will haunt you in the night when you sleep.
22:03:32 <Artelius> Ooh tell me more
22:03:39 <kmc> which?
22:03:39 <John__> Does google have to try and get in _everywhere_?
22:03:43 <kmc> John__, pretty much
22:03:44 <Artelius> iPhone
22:03:52 <kmc> http://projects.haskell.org/ghc-iphone/
22:04:25 <Artelius> Is doing this even legal :D
22:04:37 <kmc> which?
22:04:42 <John__> kmc: They've failed at *pretty much* everything but their search engine. All the other successful stuff was other companies ideas that they bought. Google Earth, for instance, or youtube.
22:04:53 <kmc> John__, text ads?
22:05:01 <kmc> you know, the thing that gives them the vast majority of their revenue
22:05:08 <John__> Uhh
22:05:12 <kmc> also i don't see how you can call Android a failure
22:05:19 <John__> that comes included in *search engine*
22:05:19 <danharaj> John__: An essential part of being a successful technology company is successfully capitalizing new technologies and ideas, even if they weren't yours to begin with.
22:05:23 <kmc> uh no
22:05:28 <kmc> i don't see why
22:05:31 <John__> except for adsense, which is 40% of their revenue
22:05:36 <kmc> unless you count only the text ads served on google.com itself
22:05:48 <John__> adwords is the one they have on google.com
22:05:52 <John__> adsense is on other peoples sites
22:06:00 <John__> and I did say prettty much.
22:06:43 <Artelius> How did a "What's the 'point' of Haskell?" turn into Google bashing? Hehe
22:07:24 <John__> Artelius: heh
22:08:30 <Artelius> btw John__: learn Haskell
22:08:44 <John__> Artelius: Maybe when I've finished learning lisp
22:08:52 <kmc> heh
22:09:02 <Artelius> You can't learn all of lisp ;)
22:09:04 <kmc> i feel like Lisp is something you can finish learning in a day, yet never finish learning
22:09:24 <Artelius> Exactly
22:10:47 <danharaj> Lisp is a thing?
22:11:02 <Artelius> It is a common thing.
22:11:04 <danharaj> I thought Lisp had as many dialects as the Flying Spaghetti Monster has noodles.
22:11:04 <kmc> yeah
22:11:09 <kmc> it's a toolkit for building new languages
22:11:15 <Artelius> Truly.
22:11:18 <kmc> "Lisp" might mean "Common Lisp" which is a well-defined thing
22:11:26 <kmc> with a spec and everything
22:11:33 <kmc> a spec whose index is the length of the full Scheme spec ;)
22:11:43 <kmc> or it might mean "the Lisp family" which is a less well-defined thing
22:11:59 <danharaj> I guess I should learn Scheme one day.
22:12:01 <kmc> but is understood by most people as "that weirdo parentheses language that all the smug assholes use"
22:12:16 <danharaj> kmc: That is my definition >_>
22:12:22 <Artelius> What is Haskell understood my most people as?
22:12:26 <Artelius> *by
22:12:32 <kmc> if you think of a great new way to do something today, you're a genius and you become rich and famous
22:12:44 <kmc> but if you point out that you've known a better way for 50 years, you're a smug asshole and everyone ignores you
22:12:49 <danharaj> Artelius: That language that is hard and- god what's the point who cares.
22:13:01 <kmc> Haskell is understood as "Monads, lol"
22:13:18 <Artelius> Aye
22:13:31 <zakwilson> Haskell is understood?
22:13:32 <danharaj> kmc: Maybe because time has shown it isn't so great after all ;)
22:13:49 <vipex> what reason you guys move from common (c, pascal, etc) programming style to haskell?
22:14:03 <kmc> more fun, less bullshit
22:14:17 <kmc> it's a very good fit with things i'm interested in (programming language design and implementation)
22:14:23 <Artelius> I don't program in Haskell, I just study it for fun :P
22:14:23 <danharaj> vipex: I was tired of hobby programming being more akin to punching myself in the dick while gargling battery acid.
22:14:48 <kmc> i first learned Haskell because somebody told me "if you like psychedelic drugs, you'll probably like Haskell"
22:14:57 <vipex> ha
22:15:04 <kmc> there was considerable overlap between the two hobbyist groups at my school
22:15:25 <vipex> somebody here migh come from traditional programmer?
22:15:49 <kmc> ?
22:15:53 <akosch> vipex: what do you mean by traditional?
22:15:58 <c_wraith> I may have programmed a tradition once.
22:16:16 <danharaj> My first language was C++
22:16:17 <vipex> hmmm forgot what they named... c, pascal etc?
22:16:26 <Artelius> Procedural?
22:16:30 <danharaj> vipex: Dinosaurs
22:16:32 * danharaj rimshot
22:16:35 <vipex> lol
22:16:41 <vipex> procedural + oop
22:16:46 <kmc> i think the category you're looking for is "languages other than Haskell"
22:16:50 <akosch> vipex: i've started with assembly, is that traditional? ;)
22:17:23 <kmc> i don't know what's traditional anymore
22:17:25 <vipex> any language that force you think like machine think i mean :)
22:17:29 <kmc> oh
22:17:40 <kmc> a lot of us have C, C++, and/or assembly experience
22:17:50 <kmc> i think it's traditional these days for uni students to learn Java
22:17:53 <kmc> which is pretty far from that world
22:18:03 <kmc> and a lot of them basically think of a computer as a machine for executing Java source code
22:18:18 <Artelius> It's so depressing.
22:18:19 <akosch> kmc: yeah, virtual machine in a virtual machine in a...
22:18:21 <danharaj> A generation of worthless programmers.
22:18:27 <danharaj> </inflammatory on purpose>
22:18:37 <danharaj> It's java all the way down.
22:18:41 <Artelius> er
22:18:41 <Artelius> up
22:18:41 <vipex> imperative that is, lol 
22:18:49 <Artelius> from nowhere :P
22:18:49 <kmc> Haskell is an imperative language
22:19:00 <Artelius> Shush!
22:19:02 <kmc> this whole idea of mutually exclusive "paradigms" is ridiculous
22:19:33 <vipex> C, Java, Pascal, Ada, and so on, are all imperative languages --> haskell wiki
22:19:49 <vipex> Haskell is functional lang 
22:19:59 <kmc> yes, Haskell is a functional, imperative language
22:20:00 <Artelius> Paradigms are generally independent of programming languages
22:20:09 <akosch> vipex: well you can choose what style you program in
22:20:11 <kmc> it supports both styles, not only individually but deeply integrated
22:20:17 <Artelius> New programming languages arise to facilitate the application of new paradigms
22:20:20 <danharaj> kmc: I think the overlap of imperative and declarative is pretty slim, no?
22:20:29 <kmc> not as i see it
22:20:44 <kmc> "declarative" vs "imperative" is a better contrast though
22:21:03 <kmc> i don't have anything against people who learn Java and then get a career punching out repetitive Java programs for 40 hours a week and go home to their wife and kids or hobby model airplanes or sex parties or whatever
22:21:13 <danharaj> damn I do
22:21:16 <kmc> programming doesn't have to be an all-consuming intellectual spiritual quest for everyone
22:21:16 <danharaj> I want in on those sex parties.
22:21:21 <danharaj> This is true.
22:21:25 <vipex> hmm... why should chose imperative style using haskell ? :p
22:21:26 <Dashkal> How about those who do Java to pay the bills then play with more interesting languages in their spare time?
22:21:45 <danharaj> vipex: Higher order functions and a type system that doesn't blow monkey balls makes imperative programming really easy.
22:21:46 <Artelius> They can always have Hope.
22:22:06 <Dashkal> Actually, it's PHP now.  Not seeing much Java work.  I cry at work...
22:22:24 <danharaj> ugh, godspeed man.
22:22:27 <akosch> Dashkal: i have to do php for money, but don't feel like a jerk... :)
22:22:29 <zakwilson> A PHP project prompted me to finally learn Haskell.
22:22:31 * Dashkal sheds a tear for type safety
22:22:40 <Artelius> lol
22:23:04 <kmc> higher order functions aren't a Haskell-specific feature though
22:23:07 <kmc> they're in every good language
22:23:13 <kmc> just not two specific popular languages
22:23:19 <kmc> so people still think of them as exotic
22:23:33 <akosch> kmc: not really
22:23:37 <dolio> Three, at least.
22:23:41 <zakwilson> http://pastebin.com/KHmuhmRF <-- said project involved fixing this
22:23:45 <akosch> kmc: in python they are pretty common (decorators)
22:24:14 <vipex> i just start learning haskell (now am reading Real World Haskell)... it's intersting. wondering you guys really use them on real applications?
22:24:23 <vipex> use haskell*
22:24:50 <aavogt> akosch: decorators only go at top level though, right?
22:24:50 <Axman6> @remember A PHP project prompted me to finally learn Haskell.
22:24:50 <lambdabot> It is forever etched in my memory.
22:24:57 <Axman6> @remember zakwilson A PHP project prompted me to finally learn Haskell.
22:24:58 <lambdabot> It is forever etched in my memory.
22:25:07 <Axman6> @forget A PHP project prompted me to finally learn Haskell.
22:25:07 <lambdabot> Done.
22:25:14 <akosch> aavogt: yeah, it's kinda constraining
22:25:35 <kmc> vipex, yes
22:25:36 <djahandarie> Hm, could anyone further golf fix$(0:).scanl(+)1
22:26:02 * hackagebot species 0.3 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3 (BrentYorgey)
22:26:09 <vipex> kmc: what kind of application you're done?
22:26:17 <aavogt> @help oeis
22:26:18 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
22:26:27 <aavogt> @oeis 1 1 2 3
22:26:28 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
22:26:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:26:30 <darkf> what's the best explanation of monads? :-)
22:26:36 <danharaj> @oeis 1 1 1 1 1 1
22:26:36 <lambdabot>  The simplest sequence of positive numbers: the all 1's sequence.
22:26:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:26:57 <kmc> vipex, compilers, interpreters, debuggers, graphics, bioinformatics, networking, (soon) mobile gaming
22:27:07 <aavogt> djahandarie: I think there's a library for looking up from oeis
22:27:09 <akosch> darkf: http://en.wikipedia.org/wiki/Monad_%28functional_programming%29
22:27:13 <vipex> somebody here using http://snapframework.com/ ? might you could advice me make it working on windows?
22:27:18 <danharaj> the wiki page IMO is balls.
22:27:20 <Artelius> darkf: depends on the individual. Read a few, find which makes sense
22:27:26 <aavogt> @quote neo
22:27:26 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
22:27:27 <jmcarthur> vipex: #snapframework 
22:27:34 <kmc> darkf, i like  Cale's "Monads as computations" and "Monads as containers" on the haskell.org wiki
22:27:39 <kmc> darkf, and also Typeclassopedia
22:27:48 <vipex> darkf: monads is an IO framework for haskell --> am right?
22:27:55 <darkf> alright, thanks all :-)
22:27:59 <darkf> vipex: it does a lot of things AFAIK
22:28:07 <kmc> vipex, no
22:28:21 <vipex> ?? i read like that
22:28:22 <lambdabot>  i read like that
22:28:29 <danharaj> Monads don't do anything. Monad is a definition that a structure can satisfy, like Monoid or Group.
22:28:53 <kmc> vipex, IO is one particular application of monads in Haskell
22:28:54 <vipex> jmcarthur: thanks
22:28:58 <kmc> and a somewhat unusual one
22:29:25 <kmc> if you just want to learn how to do IO, it's best to ignore monads at the start
22:29:27 <darkf> and unforunately hard to learn :-)
22:29:33 <kmc> and follow a practical guide like http://haskell.org/haskellwiki/Introduction_to_IO
22:29:45 <aavogt> it's the only one you really need to use
22:29:55 <kmc> and please don't concern yourself with "what *is* a monad, really" until you understand type classes
22:29:58 <jmcarthur> not hard to learn, IMO. it's just imperative programming
22:30:14 <kmc> because analogies aside, "Monad" is just the name of a particular type class in the standard library
22:30:24 <jmcarthur> although i do observe a lot of confusion between execution and evaluation among beginners
22:30:48 <kmc> yeah
22:30:51 <vipex> ok
22:30:57 <kmc> in Haskell, evaluation and execution are distinct
22:31:14 <kmc> evaluation is what happens when you apply functions to arguments and pattern-match on the result, causing computation to occur
22:31:26 <kmc> execution is what happens when you take a "recipe" for performing IO and hand it off to the runtime system to be performed
22:31:37 <Artelius> Monads are a way to "create" state in a supposedly stateless language like Haskell
22:31:46 <aavogt> take readFile for instance...
22:31:47 <danharaj> let's not get into cooking metaphors, or we will end up with burritos.
22:31:52 <kmc> Artelius, that's one particular application, yes
22:31:56 <kmc> that's not what they're about in general
22:32:01 <jmcarthur> oddly, i had no problem with the idea, but it may have been due to my experience with the Io language, which has metaprogramming out the wazoo
22:32:25 <kmc> i could also say "Monads are a way to define grammars for parsers" or "Monads are a way to write lock-free transactional concurrent programs" or "Monads are a way to generate LLVM code"
22:32:36 <Artelius> kmc: we have to lie to teach
22:32:41 <darkf> but I come from imperative land, so it's extra hard ;)
22:32:44 <danharaj> Artelius: More like, threading a state argument through a bunch of computations on state has the structure of a monad, so you might as well use a monadic interface to take care of the bookkeeping for you.
22:32:46 <kmc> Artelius, i disagree
22:32:47 <jmcarthur> Artelius: i disagree
22:33:03 <Axman6> @tell dons I have some good news for you: http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all (notice the "Haskell GHC #3" in 76th position is where we were yesterday)
22:33:04 <lambdabot> Consider it noted.
22:33:04 <Artelius> I disagree too :(
22:33:10 <jmcarthur> kmc: lies! Monads are a way to build web pages!
22:33:10 <Artelius> part of me disagrees, that is
22:33:41 <kmc> Artelius, in this case, I don't think it clouds the story too much to throw in phrases like "For example" or "(among others)"
22:33:50 <danharaj> Axman6: Can you explain that benchmark to me? It is about threads, but the best running programs are single-cored?
22:34:01 <kmc> present the use cases you want, without implying that one particular use case is privileged over others
22:34:12 <vipex> haha
22:34:33 <Axman6> danharaj: because the actual problem isn't really well suited to running on multiple cores. if each thread did some actual work, it would be a lot better.
22:34:36 <djahandarie> I don't know why monads are hard to learn for folks, considering how simple they are.
22:34:48 <vipex> ok i don't wanna think in description what monads is... :)
22:34:56 <kmc> vipex, how much Haskell do you know?
22:34:59 <jmcarthur> danharaj: a bunch of threads passing around a single token, so only one is ideally ever active at a time
22:35:09 <danharaj> that is a stupid benchmark.
22:35:10 <danharaj> :|
22:35:11 <vipex> kmc: very noob
22:35:11 <kmc> djahandarie, it doesn't help that every time a beginner asks here about monads, there's a huge argument about philosophy of education ;)
22:35:12 <Artelius> I prefer to teach without making false statements actually
22:35:14 <jmcarthur> i disagree
22:35:16 <kmc> vipex, then don't worry about it yet
22:35:32 <Axman6> danharaj: indeed, but its supposed to show how good at threading the implementation is
22:35:34 <kmc> vipex, despite the hype, monads are a fairly advanced topic in Haskell.  there's a lot of prerequisites and general familiarisation
22:35:39 <danharaj> jmcarthur: What is the merit of this benchmark?
22:35:42 <vipex> agree, i don't wanna confusing my head with strangers think at first :)
22:36:03 <jmcarthur> danharaj: try building a web server where each request is handled by a pthread and you will appreciate the benchmark
22:36:06 <kmc> :)
22:36:39 <Artelius> but sometimes it's far easier on the student to tell a half-truth and revise it later
22:36:42 <Jafet> @quote monads.are
22:36:43 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
22:37:03 <lispy> classic lispy right there
22:37:03 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
22:37:05 <jmcarthur> i don't think a student ever needs to be told a half truth
22:37:32 * djahandarie suddenly sees the wisdom in kmc's statement
22:37:47 <jmcarthur> heh
22:37:56 <vipex> oh, so monads also a safed guard protection to do paralleism in haskell? like atom / locking in common?
22:37:57 <darkf> perhaps I should learn the extensive type system first :P
22:38:02 <danharaj> Anyway this benchmark is strange.
22:38:08 <jmcarthur> vipex: don't worry about monads ;)
22:38:09 <danharaj> Haskell is using *less memory* than C???
22:38:11 <kmc> vipex, i thought you were going to learn more first ;)
22:38:21 <jmcarthur> danharaj: you should have seen when C was using pthreads!
22:38:23 <mjk> how display chinese string in haskell? 
22:38:33 <danharaj> jmcarthur: What was it like?
22:38:37 <vipex> ok ok :D
22:38:39 <jmcarthur> danharaj: haskell threads a *much* more lightweight than what's available in most other languages
22:38:43 <jmcarthur> *are
22:38:44 <mjk> for example: putStr ""
22:38:57 <kmc> vipex, monads allow you to overload the equivalent of the semicolon operator in C
22:39:12 <lispy> mjk: starting with ghc 6.12 it can do encoding/decoding of locales
22:39:22 <Jafet> > "中文"
22:39:24 <lambdabot>   "\20013\25991"
22:39:25 <kmc> and they place that idea of sequential actions in a proper first-class functional setting
22:39:28 <lispy> mjk: otherwise, you will likely need to use the utf8-string packgae
22:39:42 <danharaj> What the hell is java doing that makes it take up 300 megabytes :o
22:39:46 <kmc> vipex, this ability is useful for lots of things: IO, state, parsers, concurrency, nondeterminism, logic programming, code generation, error handling, etc.
22:39:58 <darkf> sounds fun
22:40:01 <mjk> can you give me a example?thanks
22:40:04 <kmc> it's not about any one of those things
22:40:27 <vipex> ok let me finish read the book for now lol
22:40:27 <kmc> the word "monad" is the name we give to a sort of common pattern/structure that shows up throughout those very different domains
22:40:37 <Axman6> > text "中文"
22:40:37 <lambdabot>   中文
22:40:55 <kmc> it's the name for an API with many different implementations, each corresponding to one of those "domains" of programming
22:41:06 <kmc> anyway, all in due time ;)
22:41:48 <jmcarthur> danharaj: i've seen naive web servers crash at around 70 connections due to the memory overhead from pthreads
22:41:59 <Artelius> Actually - Thanks, to everyone who's said that you don't need to lie to teach. You've given me renewed hope and confidence in students.
22:42:10 <danharaj> jmcarthur: these threads must be attached to concrete blocks.
22:42:23 <jmcarthur> danharaj: they take more memory because they are entirely new tasks according to the OS, plus the take more CPU due to context switching
22:42:46 <kmc> Artelius, perhaps we are idealists
22:42:50 <jmcarthur> they need their own stacks and everything, and their stacks tend to be large
22:42:56 <vipex> kmc: ok
22:42:59 <kmc> and skewed by the fact that most people have no desire to learn Haskell, and nobody is forcing them to
22:43:00 <Axman6> things i've learnt from the thread-ring benchmark: using multiple cores when you have threads that communicate a lot is a bad idea. put threads that need to communicate on the same core. also, haskell threads are fast, but you have to know how to use them
22:43:02 <jmcarthur> haskell green threads also have their own stacks, but they can grow dynamically
22:43:43 <ivanm> Axman6: really? making them use different cores affects performance?
22:43:44 <jmcarthur> Artelius: i've been lied to by teachers before, and it always burns later
22:43:46 <danharaj> Axman6: Hmm, I want to say that is because of cache effects, but you probably understand it better?
22:43:47 <ivanm> how come? per-core caching?
22:43:50 <Axman6> ivanm: very much so
22:43:55 <djahandarie> vipex, a monad is a typeclass that comes predefined for you. A typeclass is something which guarentees certain things about a type. Namely, if your type is a monad, you are guarenteed functions such as ">>=" and "return".
22:44:02 <Artelius> kmc: I'm an idealist too. But I was starting to lose faith in my ideals.
22:44:23 <darkf> djahandarie: so what does bind do? :-)
22:44:26 <Axman6> not sure. but if you have threads that need to communicate all on the same core, i believe they'll all run in the same OS thread, which makes the communication much faster
22:44:35 <Axman6> this is pure speculation, but seems reasonable to me
22:44:39 <ivanm> hmmmm, that sounds likely as well
22:44:46 <ivanm> as does caching
22:44:49 <kmc> Artelius, luckily, this is The Internet, where you can wall yourself off in a sub-sub-sub-community that has exactly the same ideals as you
22:44:58 <ivanm> Axman6: I wonder if this happens in e.g. erlang as well
22:44:59 <danharaj> now how do we go around improving the other benchmarks?
22:45:11 <danharaj> Some of them are particularly egregious resource hogs compared to C.
22:45:16 <djahandarie> vipex, so if someone makes a new type which is a monad, they need to say what ">>=" and "return" do. They could really make it do anything if they wanted, but they'd be looked down upon if they made it do the wrong thing.
22:45:22 <kmc> "communication" here refers to updating variables in shared memory, right?
22:45:23 <ivanm> djahandarie: profile + improve
22:45:32 <Axman6> kmc: MVars, yeah
22:45:42 <kmc> so caching might come into play
22:45:53 <Axman6> quite possible
22:45:57 <kmc> if each core has its own L1 cache
22:46:07 <djahandarie> vipex, that's as far as Haskell enforces anything about a "Monad". Just that the type needs >>= and return.
22:46:09 <kmc> as is i believe typical
22:46:25 <Axman6> anyway, by putting all the threads on the same core, I made the program 10 times faster
22:46:44 <kmc> :D
22:46:51 <kmc> Haskell is 10 times more respectable
22:46:55 <Artelius> I mean, damn!
22:47:13 <Axman6> sharing them out seems like it should make things faster, but it's not actually a concurent program, so spreading them out just introduces far more overhead
22:47:24 <vipex> djahandarie: trying understanding those words, thank you
22:47:46 <Artelius> But if we couldn't stomach concurrency we probably couldn't stomach Haskell either.
22:48:04 <mjk> lispy: which module is "decoding" and "encoding"?
22:48:13 * hackagebot intervals 0.2.0 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.0 (EdwardKmett)
22:48:21 <djahandarie> vipex, sure. I think that was the most confusing part for me... knowing what Haskell actually enforced itself about monads. The functions >>= and return are suppose to do specific things, but those aren't enforced by Haskell, just by whoever makes the functions.
22:48:37 <edwardk> now with none of the wonderful rounding-mode control that it had before :_(
22:48:40 <danharaj> victory over the glibc tyrants edwardk?
22:48:43 <kmc> they're supposed to work together in a way satisfying certain laws
22:48:48 <edwardk> danharaj: admitted defeat
22:48:49 <kmc> otherwise it is pretty open-ended what they can do
22:49:07 <danharaj> edwardk: There will be a time for vengeance. Perhaps on a blog about how much they suck!
22:49:09 <Axman6> edwardk: not sure if its at all related, but you might find this interesting: http://en.wikipedia.org/wiki/Kahan_summation_algorithm
22:49:11 <djahandarie> vipex, and here is a good article explaining those functions: http://www.haskell.org/haskellwiki/Monads_as_containers
22:49:17 <lispy> mjk: which version of ghc?
22:49:23 <mjk> 6.12.1
22:49:47 <vipex> djahandarie: reading
22:49:58 <kmc> vipex, are you familiar with type classes?
22:49:59 <danharaj> Some of the alternative programs for Haskell in the shootout are much better, why are they rejected?
22:50:04 <kmc> in Haskell
22:50:13 <Axman6> it was on reddit today, i reckon it should be used in things like vector to make operations like sum and average more accurate (what's the point of boasting being good at number crunching if you can't boast accuracy too)
22:50:14 <edwardk> Axman6: cute =)
22:50:14 <vipex> monads as xxx --> so they will another monads as blabla :)
22:50:19 <jmcarthur> edwardk: don't feel bad for yourself. i wrote 670 lines of haskell over this weekend that doesn't do anything but define types and some relationships among them
22:50:27 <lispy> mjk: in that case, when you use non-binary IO, it does it automatically based on the locale in your environment
22:50:31 <edwardk> jmcarthur: that sounds like my usual gig ;)
22:50:50 <jmcarthur> ha
22:51:15 <vipex> kmc: am reading books bout haskels... just in description i got for now, not yet go with GHCi :)
22:51:23 <Jafet> edwardk, the infamous java trap...
22:51:41 <kmc> yeah
22:51:42 <vipex> i'm with alot definitions in haskell for now
22:51:53 <kmc> start there
22:52:03 <kmc> because "Monad" is just the name of a particular type class
22:52:23 <kmc> and it's pointless to get an intuition for what that class means, before you can understand the precise definition
22:52:26 <mjk> lispy: if use str<-getLine,putStr str, ghc can display chinese string,but if direct putStr ".....", ghc can't display
22:52:55 <vipex> ok
22:53:03 <edwardk> jmcarthur: i now have the interval lib working without the rounding, but sadly, it shows its inexact nature all too well once you take rounding away =(
22:53:23 <lispy> mjk: oh.  I'm not sure what is going wrong there.  What encoding did you use with the putStr "..." version?
22:54:01 <lispy> mjk: "\nnnn" should work if you know the code, but so should putting the character directly if the encoding is right
22:54:08 <Axman6> mjk: you might have to resort to using a program that does: main = getStr >>= print to print out the string with the chinese characters escaped
22:55:14 <jmcarthur> edwardk: floating point sucks anyway
22:55:17 <djahandarie> God I wish "return" wasn't called "return"
22:55:24 <vipex> how haskell handling large raw strings data? is a way accessing memory buffer or what
22:55:49 <Axman6> vipex: you use ByteStrings
22:56:01 <Axman6> which are basically memory butters with a far nicer interface
22:56:03 <SubStack> djahandarie: you can always call it pure instead
22:56:03 <danharaj> djahandarie: Prefer unit?
22:56:20 <djahandarie> I know I can call it other stuff but the point is no one else does
22:56:29 <mjk> lispy: I want to display a prompt string, use "\nnnn" is langwierig:)
22:56:39 <SubStack> Everyone else is to blame! I hate it when that happens.
22:56:53 <SubStack> as often I am right and everyone else is wrong
22:57:01 <jmcarthur> Text!
22:57:26 <kmc> vipex, Haskell has a distinction between bytes and characters
22:57:36 <kmc> the latter being unicode codepoints
22:57:54 <SubStack> vipex: the binary monad is good for that type of stuff
22:58:05 <kmc> the standard String type is just a linked list of Char, which supports all Unicode and is very convenient, but not very space or time-efficient
22:58:49 <kmc> the basic ByteString is a compact efficient representation of a sequence of bytes, not characters
22:59:04 <vipex> hmm, so String in haskel had it default twice in size since String are unicode?
22:59:11 <kmc> twice what?
22:59:23 <kmc> the actual in-memory use of a Haskell String is much bigger than in C
22:59:25 <kmc> much more than twice
22:59:26 <vipex> ok ByteString looks what I mean :0
22:59:28 <Axman6> is (:) for strings basically equivalent to struct char_t { wchar c; char_t * tail;};?
22:59:30 <kmc> for reasons other than unicode
22:59:34 <ManateeLazyCat> I'm plan to develop a Hook module to inject code in runtime, example, when i run function `Foo :: IO ()`, it will execute FooHook (TVar [IO ()]) after execute "Foo", and i can modified FooHook in runtime. So have a exist library do this or any suggestion to  improve my design? Thanks!
22:59:44 <SubStack> Axman6: people write code that way in c?
22:59:44 <vipex> twice = 2 bytes
22:59:48 <Artelius> Unicode is NOT a 16-bit format
22:59:56 <kmc> vipex, it's unspecified how Char is represented in memory
22:59:57 <mxc> unicode-16 is
22:59:59 <vipex> 1byte = asci code, 1 byte = unicode mask
23:00:00 * ManateeLazyCat Hook is useful to extension core with user's customize setup.
23:00:07 <Artelius> You mean UTF-16?
23:00:10 <Axman6> vipex: Strings are by more than twice the size though. there's the overhead of pointers etc as well
23:00:11 <mxc> yes :(
23:00:15 <kmc> vipex, it could use utf-8, utf-16, utf-32, or any other encoding
23:00:18 <mxc> thats what I get for being a smartass
23:00:23 <danharaj> utf-blargh
23:00:31 <kmc> you're not supposed to access individual bytes of a Char or care about its concrete representation
23:00:32 <djahandarie> Ah yes utf-blargh
23:00:52 <Axman6> Chars are just characters
23:01:00 <Axman6> SubStack: why not?
23:01:04 <mxc> GeneralizedNewtypeDeriving and associated type synonyms dont seem to play well
23:01:16 <mxc> but i feel like they should
23:01:18 * djahandarie goes to bed
23:01:29 <kmc> vipex, so basically: String is simple but inefficient Unicode text; ByteString is compact byte buffers, something like "text" or "compact-string" off Hackage is compact Unicode text
23:01:46 <vipex> ok got it
23:01:57 <kmc> though, laziness makes it hard to make broad claims about performance
23:02:02 <kmc> because in fact String could be a very efficient type
23:02:10 <kmc> if you are "streaming" lots of data from a producer to a consumer
23:02:17 <Axman6> Text being the preferred way to deal with text of all types (because its fast, efficient, and respects locales)
23:02:24 <kmc> then the compiler might optimize it out entirely, into some jumps between the two
23:02:48 <kmc> basically, Haskell lists (including strings) act both as data structures and control-flow structures, depending on how you use them
23:02:55 <kmc> and indeed the same is true for most composite types in Haskell
23:02:56 <ManateeLazyCat> vipex: If you don't use any FFI APIs that need String, i recommend you use Text or ByteString instead String always. 
23:03:16 <edwardk> danharaj: actually it looks like installing crlibm might not be so terrible, but the problem is that the resulting package couldn't be installed by cabal unless the end user already had it installed
23:03:54 <vipex> ok thanks for the hints
23:04:10 <Axman6> anyway, learn haskell first before worrying about such things vipex :P
23:06:06 * ManateeLazyCat I guess most haskeller just use String when need by some FFI code (such as gtk2hs) ... :)
23:06:36 <ManateeLazyCat> Text always my first choose. :)
23:06:59 <kmc> String isn't a good fit with FFI either
23:07:02 <edwardk> i have yet to find a problem where Text was the right solution =/
23:07:17 <kmc> with most C libraries, Char8 ByteString would be much faster
23:07:18 <Axman6> heh
23:07:25 <vipex> Axman6: Just wanna figure is haskell perform good as common compiler do in any parts :)
23:07:34 <kmc> haskell doesn't perform
23:07:35 <vipex> btw what FFI though?
23:07:37 <kmc> it's just a specification
23:07:47 <Axman6> vipex: do you mean is haskell good for making compilers?
23:07:47 <kmc> GHC is a particular Haskell compiler that produces pretty fast code
23:07:59 <Axman6> vipex: its what allows you to call C functions from Haskell
23:07:59 <kmc> vipex, FFI is the mechanism for calling C functions from Haskell (and vice versa)
23:08:05 <edwardk> I can't mmap it, I can't quickly index into it, I can't slice it, the internals are hidden (or were), the memory footprint is twice that of a utf-8 encoded bytestring, etc...
23:08:07 <kmc> vipex, if you are reading Real World Haskell, there's a good chapter in there
23:08:08 <ManateeLazyCat> vipex: Example, you binding Haskell to some C library, such as gtk+ library
23:08:17 <kmc> seriously though, can't we just make everyone speak English
23:08:25 <kmc> then we won't need all this Unicode stuff
23:08:29 <ManateeLazyCat> vipex: FFI is interface between Haskell and other language.
23:08:36 <edwardk> the one theoretical advantage is that it recurses less than a utf8 encoded bytestring to decode a given code point
23:08:44 <Rotaerk> kmc, no if we did that, god would punish us again like at the tower of babel
23:08:57 <Rotaerk> and then we'd all speak new languages and have to reencode them in unicode
23:09:01 <Rotaerk> which'd suck
23:09:08 <vipex> yes I know about that :)
23:09:09 <kmc> fine then, can't we just write everything in IPA
23:09:20 <kmc> and use some wacky codepage
23:09:52 <kmc> also makes it hard to read text written by someone with an accent different from yours :)
23:11:14 <vipex> yeah lol
23:11:22 <ManateeLazyCat> I hope someday, all C library use unicode since memory is so cheap today....
23:11:34 <Artelius> But UTF-bleargh?
23:11:35 <vipex> sorry my english btw :)
23:11:58 <systemfault> There's no more fixed size unicode formats.
23:12:06 <systemfault> They're all UTFs
23:12:09 <Artelius> UTF-32 is fixed size
23:12:15 <kmc> UTF-128
23:12:25 <ManateeLazyCat> I hate some library (such as Gtk+) mix UTFString and String, hard to binding, i even need read C source code to decide how to binding some code.
23:12:34 <Jafet> Before that happens, all C library writers will have to learn to use unicode first
23:12:39 <SubStack> I hate CArrays
23:12:47 <SubStack> so hard to get data in and out
23:12:58 <danharaj> Unicode sucks.
23:13:04 <kmc> C programming is hard
23:13:06 <kmc> let's go shopping
23:13:10 <ManateeLazyCat> danharaj: Why?
23:13:15 <danharaj> Why not?
23:13:17 * benmachine hugs kmc 
23:13:29 * SubStack buys kmc a silly hat at the mall
23:13:40 <ManateeLazyCat> danharaj: Because have other "language" and not just English or Latin
23:13:48 <kmc> SubStack, can i get a pretzel?
23:13:59 <Jafet> I hear one of the malls overflowed again today.
23:14:00 <ManateeLazyCat> danharaj: If not use Unicode, it's trouble to convert between different language.
23:14:04 <SubStack> kmc: if you want, but I'm getting a cinamon roll
23:14:21 <danharaj> ManateeLazyCat: so we should try to encode all possible written human language in a single datatype. How is that sensible?
23:14:22 <systemfault> danharaj must be american :P Americans think they're the only civilized nation on the planet ;)
23:14:41 <Dashkal> danharaj: So you can express more tahn one language in a single document?
23:14:54 <Dashkal> without needing wacky <language = fr> constructs
23:15:00 <kmc> again, let's just make everyone speak English
23:15:06 <kmc> or German
23:15:15 <Dashkal> I'd vote Japanese
23:15:22 <systemfault> Japanese is cooler :)
23:15:22 <kmc> no, too many characters
23:15:26 <dolio> Let's do all our math in English, too.
23:15:27 <kmc> gotta fit within one byte
23:15:30 <danharaj> Dashkal: Are such constructs nearly as wacky as what you need to do to encode and decode unicode? Or decide casing for unicode? Or actually inputting unicode?
23:15:43 <SubStack> all characters in 5 bits
23:15:58 <SubStack> that should be enough for anybody
23:16:10 <kmc> wouldn't it be great if a bunch of people had thought really hard about these issues for 20+ years
23:16:10 <Dashkal> If you want simple encoding, use a 32 bit encoding.  personally, I just use preexisting libraries and use utf8
23:16:17 <kmc> and published some kind of recommendation or specification
23:16:19 <ManateeLazyCat> danharaj: If use unicode, you don't need care the difference between languages.
23:16:23 <Dashkal> Then I don't have to deal with it
23:16:36 <SubStack> different cases is just a distraction
23:16:38 <ManateeLazyCat> danharaj: Otherwise, some encode problem will make you crazy.
23:16:48 <Dashkal> But still, if you really dislike unicode.  Ignore it and stick with codepages
23:16:59 <ManateeLazyCat> So unicode is *right* thing to handle human language and international program.
23:17:04 <kmc> i dislike pizza, i think i'll shoot myself in the balls insead
23:17:27 <systemfault> We're starting to have non-english CCTLDs too.. Unicode is important.
23:17:48 <ManateeLazyCat> systemfault: I agree with your point. Not just English in this planet.
23:18:02 <systemfault> Yes ;)
23:19:04 * ManateeLazyCat Sometimes dislike Hollywood movie, always think American is *only* important nation in this planet.
23:20:29 <systemfault> And when I say american.. I always have the classic southern white redneck in mind.
23:21:40 <dolio> You third graders are always so quick to judge us fifth graders.
23:21:55 <kmc> america, fuck yeah
23:22:00 <kmc> coming again to save the motherfucking day, yeah
23:22:18 <systemfault> s/save/fuck :)
23:22:24 <kmc> Unicode is pretty complicated because it tries to be all things to all people
23:22:31 <kmc> but that's really important for it to be useful
23:22:32 <systemfault> True :(
23:22:35 <edwardk> danharaj: looks like hmpfr and libmpfr will work
23:22:44 <vipex> wondering is GHC could produce a .DLL / .so?
23:22:46 <systemfault> MS was right at the beginning with UCS2
23:22:53 <danharaj> edwardk: Congrats.
23:22:56 <danharaj> (maybe)
23:22:58 <edwardk> danharaj: i just need to export a decent numerical type built around mpfr using my reflection library
23:23:00 <ManateeLazyCat> kmc: But better than you coding-page.
23:23:01 <vipex> how you guys maintaince modular modules?
23:23:18 <kmc> it's not like a programming language, where many languages can be developed independently and coexist profitably
23:23:32 <edwardk> hmpfr-reflected or something
23:23:41 <kmc> there's a big network effect to getting all the text in the world encoded the same way
23:23:50 <ManateeLazyCat> kmc: Because human language is complicated than programming-language. :)
23:24:09 <kmc> vipex, modularity at the source level and how your program actually links are pretty unrelated questions
23:24:25 <vipex> tell me more
23:24:37 <ManateeLazyCat> kmc: How cheap with memory? I think you need cost more if always convert from this encoding to another.
23:24:44 <Jafet> lazycat: wait till you program in ada 95
23:24:49 <vipex> how we perform modularity in haskell in a good way
23:24:59 <kmc> vipex, you should read Real World Haskell
23:25:07 <kmc> recent GHC can produce .so, which is useful for specific things
23:25:16 <kmc> but that's totally independent of the Haskell module system
23:25:43 <vipex> am not finish reading RWH :D 
23:26:11 <edwardk> hrmm i need a good package name for a package that takes the contents of hmpfr and puts a pretty 'reflection' based api on it
23:26:28 * ManateeLazyCat Unicode is very important for non-English language, but i think most English-speaker will think Unicode is unnecessary... 
23:26:44 <edwardk> its not really hmpfr-reflection, i'd just say 'mpfr' but that seems a bit weird given the main module's name
23:26:47 <kmc> i'm an english speaker but i love all the weird symbol characters in Unicode
23:27:03 <danharaj> edwardk: what do you mean by reflection?
23:27:04 <ManateeLazyCat> Anyone has suggestion with my Hook design (TVar [IO ()]) ?
23:27:31 <edwardk> danharaj: http://hackage.haskell.org/packages/archive/reflection/0.3.0/doc/html/Data-Reflection.html provides tools for turning terms into types
23:27:43 <danharaj> that is some deep magic.
23:27:55 <edwardk> the code in hmpfr looks a lot like standard Num, etc. methods
23:27:58 <edwardk> except
23:28:01 * ManateeLazyCat Maybe someone has better solution... :)
23:28:04 <edwardk> they all take Rounding and Precision parameters
23:28:23 <danharaj> ah so you reflect those parameters into types?
23:29:14 <edwardk> but if I made newtype Real r p = Real MPFR -- and defined instance (Reifies r Rounding, Reifies p Precision) => Num Real where ...
23:29:41 <edwardk> danharaj: exactly
23:30:30 <edwardk> then you could call something like reifySettings Down (bits 32) (....) where ... was some computation that used those settings
23:31:19 <kmc> cool edwardk
23:31:28 <danharaj> hmm, documentation for Data.Reflection is ... sparse ;)
23:31:31 <Axman6> whoot! managed to speed up the  fannkuch-redux benchmark
23:31:37 <edwardk> danharaj: heh well there is a paper
23:31:43 <Jafet> Apply miniolegs
23:31:51 <Axman6> not as much as the thread-ring one, but still a considerable amount
23:31:53 <Jafet> Er, milliolegs
23:32:07 <danharaj> Axman6: What's your factor speedup?
23:32:14 <danharaj> edwardk: Pff, for us mortals please.
23:32:25 <Axman6> 1m52.889s -> 1m20.319s for n = 12
23:32:28 <edwardk> danharaj: it was one of my many projects that i needed for something else, so i put it out there in case anyone else needed it ;)
23:32:51 <Axman6> > (60+52.889)/(60+20.319)
23:32:52 <lambdabot>   1.4055080367036443
23:32:53 <edwardk> the main API consists of 'reify' and 'reflect'
23:33:01 <edwardk> which do exactly what their types say =P
23:33:08 <danharaj> pff
23:33:20 <ManateeLazyCat> I saw SPJ release new paper about DPH, so how the status of DPH in ghc?
23:33:29 <kmc> i was thinking of another design
23:33:48 <edwardk> reify (+ 2) (reflect <*> pure 1) == 3 ;)
23:33:53 <kmc> f x = ... bunch of mpfr code ... where MpfrOps { .. } = getOps myMode myPrec
23:34:41 <edwardk> kmc: i don't like that version because you wind up with something that can't be used as haskell numeric types
23:34:47 <kmc> yeah
23:34:51 <edwardk> kmc: that is very MLish
23:34:54 <kmc> yeah
23:35:00 <roconnor> @src cycle
23:35:00 <lambdabot> cycle [] = undefined
23:35:01 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:35:02 <kmc> using records and wildcards like scoped opens of parametrised modules
23:35:24 <Axman6> why isn't cycle [] = []?
23:35:49 <kmc> it'd be the only finite return value
23:35:49 <SubStack> @src cycle
23:35:50 <lambdabot> cycle [] = undefined
23:35:50 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:36:08 <Jafet> Clearly it should have taken NonEmptyList
23:36:11 <SubStack> oh blarg
23:36:25 <danharaj> or returned a Maybe
23:36:43 <Axman6> anyone think that there should be a non empty list type defined by default somewhere?
23:36:48 <edwardk> i love that it goes out of its way to check, and then gives an undefined anyways ;)
23:36:53 <edwardk> Axman6: there is
23:36:55 <roconnor> Axman6: ciruclar lists have no nil element
23:36:58 <edwardk> Cofree Identity ;)
23:37:03 <edwardk> er
23:37:04 <Axman6> >_<
23:37:05 <edwardk> Cofree Maybe
23:37:16 <Axman6> Cofree?
23:37:22 <edwardk> Cofree Identity is also non-empty, but it also doesn't terminate ;)
23:37:31 <edwardk> data Cofree f a = Cofree a (f (Cofree f a))
23:38:06 <edwardk> a * f (a * f(a * f( .....
23:38:28 <Jafet> If we remove the special case of cycle [], then cycle [] is _|_
23:38:33 * Axman6 prefers nice names for such things... like Stream
23:38:44 <edwardk> when f is Maybe, you get Cofree a (Just (Cofree b (Just (Cofree c Nothing))) --etc
23:39:05 <edwardk> Axman6: I used Stream for it in my ad lib, but its not always stream-like
23:39:09 <Jafet> And taking a gross leap of faith, _|_ is undefined
23:39:12 <roconnor> > fix ([]++)
23:39:16 <lambdabot>   mueval-core: Time limit exceeded
23:39:40 <edwardk> Axman6: consider Cofree ((->)b) -- which is the type of a Moore machine
23:39:50 <Axman6> oh?
23:39:52 <edwardk> (a, b -> (a, (b -> ...))
23:39:55 <kmc> yeah the equation for [] is just giving a nicer operational semantics to the same denotation
23:39:59 * Axman6 has been doing moore machines in hardware
23:40:10 <danharaj> edwardk: How the deuce did you manage to get category-extras to typecheck?
23:40:29 <edwardk> danharaj: practice practice practice ;)
23:40:59 <edwardk> danharaj: heh did you trip over the category-extras cofree definition or something?
23:41:20 <danharaj> edwardk: I once looked at a page *near* your library and I was afraid to look further.
23:41:32 <danharaj> edwardk: For I sensed the gaze of Shub Niggurath beyond the next hyperlink.
23:42:02 <edwardk> danharaj: it was yog sothoth actually
23:42:05 <edwardk> but close =)
23:42:11 <danharaj> heh
23:42:14 <danharaj> edwardk: Have you played with charity? It seems like something that would tickle your fancy.
23:42:30 <edwardk> danharaj: yes, but i er.. well don't really like it ;)
23:43:16 <danharaj> edwardk: Not enough sugar, or was it not esoteric enough ;p
23:43:50 <edwardk> i find that working entirely explicitly with constructors or destructors like you have to in charity leads to a very unnatural development style
23:44:00 <tensorpudding> what's the name of the extension you need for newtype instances?
23:44:11 <edwardk> GeneralizedNewtypeDeriving
23:46:05 <danharaj> edwardk: It looks like you are building another language inside of Haskell in the spirit of Categorical Programming Language.
23:46:56 <edwardk> danharaj: as usual it was just a bunch of tools i needed for my own purposes ;)
23:47:16 <danharaj> edwardk: Yeah right, you have the type equivalents of nuclear weapons in there.
23:47:42 <edwardk> danharaj: they are for self defense!
23:48:06 <danharaj> I suppose any arms race with the GHC people can only benefit mankind
23:48:09 <danharaj> instead of reduce it to ashes.
23:48:28 <sshc> Is it possible to place a "where" clause after guards?
23:48:40 <edwardk> sshc: yes, but it covers all the guards
23:48:48 <ManateeLazyCat> sshc: Yes.
23:48:56 <edwardk> sshc: so you can't use names you bind within the guard
23:49:38 <sshc> edwardk: If it covers all the guards, wouldn't I be able to use those names within the guards?
23:49:51 <sshc> The "where" clause is indentend on the same level as the guards, but it parse fails
23:49:57 <sshc> "parse error on input `where'"
23:49:57 <edwardk> sshc: yes you can use the names from thw where clause within the guards
23:50:02 <edwardk> hpaste?
23:50:11 <edwardk> i use them all over the place, so i think you have another problem
23:50:40 <ManateeLazyCat> edwardk: I found i can write like this : "let foo | ... | ... | ... " . :)
23:50:51 <Axman6> anyone know anything about the supero package?
23:51:03 <sshc> edwardk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26158#a26158
23:51:29 <Axman6> it's completely lacking in documentation
23:52:59 <ManateeLazyCat> sshc: Indent your where semantic
23:53:12 <blackdog> Axman6: i think neil has a few papers about it
23:53:13 <sshc> ManateeLazyCat: In which direction, and by how much?
23:53:20 <ManateeLazyCat> indent your "where" sentence
23:53:29 <Axman6> papers smapers, i'm an engineer, i want to know how to use it :P
23:53:31 <ManateeLazyCat> sshc: Right.
23:53:57 <ManateeLazyCat> sshc: You need make "where" at *right* 4 column of "|"
23:54:05 <sshc> ManateeLazyCat: I'm pretty sure the indentation is correct.  
23:54:09 <sshc> In fact, it is correct.
23:54:23 <sshc> My problem was that I had two "where"'s
23:54:36 <ManateeLazyCat> sshc: Oh, remove last where
23:54:42 <sshc> Clearly. ;)
23:54:53 <edwardk> sshc: you have two wheres
23:54:54 <ManateeLazyCat> sshc: Sorry, i haven't noticed that.
23:55:04 <ManateeLazyCat> sshc: You just need *one* where
23:55:46 <edwardk> sshc: where starts a layout rule, so everything that is indented to the same level as the token following the where keyword is in the same where clause
23:56:17 <Veinor> g18
23:56:19 <Veinor> whoops
23:57:18 <edwardk> hrmm i wonder if i could do evil stablename tricks with MPFR as well
23:57:38 <ManateeLazyCat> edwardk: MPFR ?
23:58:12 <edwardk> i.e. just build a tree of MPFR calculations into a tree, and then when you need to generate an answer turn the tree into a graph, and run it
23:58:32 <edwardk> http://www.mpfr.org/
