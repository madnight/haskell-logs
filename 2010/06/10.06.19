00:00:26 <dolio> They were talking specifically about Haskell?
00:00:37 <ski> but they talk about the distinction about when it is decided what a variable is bound to, and when that is actually evaluated
00:01:13 <cjs> Damn, there's no "see inside" on the Amazon copy, either.
00:01:39 <ski> (in haskell, a variable is instantiated to an expression as soon as it is introduced, but this is not necessarily the case in logic programming)
00:02:34 <ski> so, they do talk about the distinction between by-value and by-name (or by-need) evaluation, as well as the instantiation issue
00:03:35 <cjs> But from the intro: "Functional languages encourage the use of higher order programming. Particular examples are monads and currying."
00:03:41 <ski> van Roy has some ideas about when side-effects are preferable, and even if you don't agree with him, it's good to consider his argument
00:03:55 <cjs> Now, hmmm, so what language could he be possibly thinking of there?
00:04:13 <cjs> I more than consider it: I love state.
00:04:22 <ski> well, monads and currying are not only used in Haskell
00:04:40 <cjs> And having written a large, commerically used app in Haskell, damn, I used tons of state.
00:04:58 <ski> (and by side-effects, he appears to mean side-effects which is not controlled by a monad or effect system)
00:05:08 <danharaj> cjs: what app is that? :)
00:05:30 <cjs> The beauty and genius of Haskell is that it simply provides better ways to control and contain (and, basically, keep in a cage) state.
00:05:49 <cjs> danharaj: An automated high-frequency trading system.
00:06:16 <cjs> http://www.starling-software.com/misc/icfp-2009-cjs.pdf
00:06:36 <danharaj> cool
00:07:16 <danharaj> is there a Decimal type in Haskell for business apps?
00:07:16 <cjs> Damn, it was fun, too. Though I'm not sure now if I should have concentrated more on the "making money" side than the "learning Haskell, by hook or by crook" side. :-)
00:07:19 <ivanm> cjs: so if starling software is in hiatus, what are you doing nowadays?
00:07:29 <ivanm> danharaj: as in fixed precision floating point numbers?
00:07:33 <ivanm> don't think so
00:07:37 <cjs> ivanm: I'm on holiday. Not touching any programming whatsoever.
00:07:44 <cjs> Starling burned me out a bit.
00:07:50 <ivanm> fair enough
00:07:54 <ivanm> so what are you doing here then? :p
00:07:56 <cjs> danharaj: Integer is infinite precision.
00:09:19 <cjs> danharaj: Not that you usually need it. Programmers love to think about getting things "right," but it turns out that, from a business point of view, it's often cheaper to get it right most of the time, and just pay of the few unusual cases where somone gets screwed, upset, and complains.
00:10:04 <cjs> ivanm: Well, it's kind of a side effect of not being able to resist logging in to #icfp-contest just to see what's going on. :-)
00:10:10 <ivanm> heh
00:17:30 <BMeph> cjs: Ah, you're the one that jdh holds up as an example of how Haskell is useless as a language for commercial projects. Good to know he's consistent... :D
00:18:27 <cjs> jdh: Wait, is that the Scientific Computing in Caml guy?
00:20:49 <BMeph> cjs: Now the F# expert, yes. ;þ
00:21:20 <ivanm> BMeph: he's also a mathematica expert
00:21:35 <ivanm> and the way he talks he's also a Lisp expert and a general FP expert
00:23:55 <dom1> @type (>>==)
00:23:56 <lambdabot> Not in scope: `>>=='
00:24:14 <dom1> @type ($$)
00:24:15 <lambdabot> Doc -> Doc -> Doc
00:24:26 <dskippy> -> Goose!
00:24:37 <ivanm> dskippy: *groan*
00:24:58 <kmc> re "it's often cheaper to get it right most of the time"
00:25:05 <kmc> i found that finance is an extreme instance of that
00:25:09 <cjs> He's a bit of a crazy dude, but does understand some important stuff, when it comes to actually getting results out of your program.
00:25:28 <kmc> because there's an extreme opportunity cost
00:25:45 <kmc> when you have a magical money-printing machine, you want to turn it on as soon as possible
00:25:47 <danharaj> cjs: just read your pdf. You must have some serious business skillz to be able to convince someone to use a language that you don't know.
00:27:59 <cjs> But I find it amusing. If you want to see what he's saying on any particular day, searching for "jdh troll" works well. However, in the particular comment I'm looking at now (on http://blog.woobling.org/2009/11/functional-programming-and-unreasonable.html ), he claims that using truly pure functional programming isn't useful, and we Haskell dudes more or less (because we hide shit in monads) agree with him.
00:28:28 <Saizan> kmc: i guess there are some checks to avoid it burning too much of said money if it screws up?
00:28:31 <cjs> danharaj: A large part of it was that the client was particularly clueless about IT, and so had no idea what I was getting him in to. :-)
00:30:13 <danharaj> heh, god bless ignorance
00:30:18 <cjs> Saizan: the biggest check is to sit there watching it work every day. That's nothing to do with any particular programming language; it's just the sort of risk management thing you have to deal with when you're using automated systems. The Boeing and Airbus guys have been dealing with that kind of thing for years, and in a much more sophisticated way than we did.
00:30:47 <danharaj> cjs: I find it interesting that Starling Software is located in Japan. Is there an interesting story in that? :p
00:31:06 <cjs> Well, it was sort of a mistake, really.
00:31:56 <cjs> I'm Canadian. I wanted to move to a foreign country and learn another language. Since I've been learning French since I was a kid, I thought that France looked like a good idea.
00:32:07 <ivanm> cjs: apparently darcs is the only purely functional program ever written and those few users it had subsequently dropped it!
00:32:35 <ivanm> oh, right, that was you responding ;-)
00:33:04 <Saizan> cjs: well that makes me retroactively scared about my last flight, if they also follow the "just get the common case right until someone complains" :)
00:33:22 <kmc> it's ridiculous to say a program is "pure functional" because it's written in Haskell, or that it's not because it's not
00:33:42 <kmc> obviously trolls would like to equate them, using "pure functional" as a strawman against Haskell
00:33:48 <cjs> Now, I was living in Vancouver at the time, and France was a lot closer to NYC, so I scooted over there thinking at least it's closer. But the startup I ended up with sent me to Japan, which is also, as it turns out, a foreign country, and I sort of got an invitation from the CEO of the sister company there, and I thought, "Hey. French? Japanese? How much harder can it be?"
00:34:04 <cjs> Ha ha ha!
00:34:45 <kmc> i kind of wish there was less emphasis on purity as a defining feature of Haskell
00:34:52 <kmc> it's made out to be entirely more than it is
00:35:07 <cjs> ivanm: Darcs is a particularly bad example, though. That so-called "patch theory" appears to my untutored eye to be bullshit.
00:35:27 <cjs> Saizan: Isn't that how IT works? :-)
00:35:29 <ivanm> well, the problem is AFAICT that it was never formalised
00:35:38 <ivanm> though it's in the process of being formalised now
00:35:50 <danharaj> cjs: hah, that's quite a turn. Are you still in Japan?
00:36:17 <cjs> Ha! Of course it wasn't. This is what happens when you believe a physicist knows anything about mathematics.
00:36:22 <cjs> danharaj: Yup.
00:36:51 <cjs> It turns out to be a country so interesting and weird that, well, let's just say I'll never have to drop LSD again.
00:36:52 <danharaj> Yeah, when I read that darcs was written by a physicist I knew the details weren't *quite* worked out yet :D
00:37:03 <cjs> danharaj: Hee hee!
00:37:13 <ivanm> cjs: too true, unforunately :(
00:37:14 <danharaj> cjs: but if you don't drop lsd in the middle of tokyo, you will never know what double lsd is like!
00:37:48 <cjs> Yeah, but do I really need this on *top* of learning Haskell?
00:37:55 <kmc> shrooms were legal in japan until recently
00:38:31 <kmc> also i agree with danharaj's suggestion.  psychedelic tour of world cities
00:38:32 <cjs> kmc: That was actually rather a few years ago it became illegal.
00:39:29 <cjs> I mean, I spent *hours* trying to convince my trader guy that an automated trading system is a classic and beautiful research project for FRP.
00:39:45 <cjs> That might have something to do with why I'm unemployed right now. :-)
00:40:03 <danharaj> Well now you have facts to back up your smooth talk :p
00:53:13 <p_l> cjs: btw, did you know japanese before going to Japan? :D
00:54:00 <cjs> Well, not exactly. :-)
00:54:18 <wli> Must've been nice.
00:56:34 <cjs> I do remember, having more or less just got here, wandering into this department-store-type-thing named Muji (basically, a sort of a Japanese Ikea), looking at the tags, and wondering why an English word like "futon" was written in hiragana rather than katakana.
00:59:44 <cjs> Ooo! "Ironically, while Git is implemented mostly in C it uses a largely purely functional model (everything but references is immutable), whereas darcs initially chose a mutable data model, which was part of the issues that plagued version 1. Git (at it's core) is much more pure than darcs. "
01:00:45 <p_l> cjs: Git is actually more of a write-only storage system
01:00:56 <kmc> yeah
01:01:07 <kmc> it's a write-only content-addressable filesystem, and a VCS implemented on top of that
01:01:14 <p_l> it is very similar to how Bell Labs' Venti works
01:01:55 * BMeph could use a Venti Chai Latte right about now...
01:02:06 <cjs> I am embarassed to say that, as a Bell Labs fan from about the early 80s on, I don't know what Venti is.
01:02:21 <ivanm> cjs: IIRC, it's starbucks-speak for "large"
01:02:34 <cjs> But I'm a git fan these days. It just so invites me to abuse it. :-)
01:02:36 * ivanm digs up that comic strip
01:02:44 <ivanm> oh, wrong venti :p
01:02:50 * ivanm thought cjs was responding to BMeph
01:02:52 <cjs>  /brick ivanm
01:02:59 <p_l> cjs: Venti is from circa 2000
01:03:57 <wli> I never liked the hashing vs. disk locality.
01:04:16 <p_l> cjs: it's a content-addressable block storage server used in Plan9, especially in cooperation with Fossil filesystem (which is a log-structured FS with snapshotting - it can dump snapshots into Venti then fallback on the data in Venti)
01:04:17 <cjs> Ah, came out in Plan 9 in 2002. That was, well, sad to say, "after my time," as it were.
01:04:48 <coonsta> I'm using Network.HTTP.Browser; despite setDebugLog Nothing it logs the request and response headers to stdout. Does anybody have any experience with this?
01:05:09 <cjs> Damn!, though, that starts to make me sad. What ever happened to the idea of log-structrured file systems?
01:06:07 <cjs> Having myself, being a BSD guy, lived through so many years or even decades of "will Margo's LFS ever be ready for production use?"
01:06:13 <p_l> cjs: little known and hampered by available storage systems
01:06:28 <p_l> mind you, there are several ones that are in production, including one in Windows
01:06:54 <cjs> p_l: Really?
01:07:15 <p_l> cjs: really
01:07:39 * wli is a relatively orthodox believer in such things as B+ trees and R trees and so on.
01:07:40 <cjs> What I meant to say was, tell me more.
01:07:41 <BMeph> p_l: NO WAI! ;)
01:08:06 <p_l> Log-Structured stuff was added to NT somewhere around v6.0 or v5.2, contained inside NTFS volumes (it's also part of the transactional FS support)
01:08:10 <p_l> BMeph: YA RLY
01:08:31 <cjs> Because of course we've got such things in RDBMSes, and have had for a long time, but I can't figure out why this sort of, by now very old technology, isn't mainstream and used for everything.
01:08:51 <p_l> cjs: maybe because typical workload doesn't fit a LFS?
01:09:37 <p_l> only SSDs make them fit normal storage patterns
01:09:38 <cjs> Yeah, but we had workloads, back in the day, that totally did. A Usenet news spool, for example.
01:10:08 <p_l> I know that in Japan, NTT made some production quality LFS
01:10:12 <p_l> (available for linux)
01:10:40 <p_l> but NTT has various interesting projects, some with interesting naming schemes for something with corporate backing :D
01:10:57 <cjs> Actually, SSDs make things yet more interesting yet. There are some guys doing some interesting stuff related to that. Unfortunately, and probably for commercial reasons, they're working behind MySQL, but the new (and truly different) log storage model is very interesting.
01:11:34 * p_l ponders if this would elevate MySQL from "toy" categorization in his mind
01:12:26 <cjs> p_l: NTT? Really? I guess I must be in the wrong world or something, because most of the BSD stuff I've seen came out of IIJ, and the database stuff out of Fujitsu (or a small part of it, and that was a storage engine for Postgres, which is a good thing).
01:12:30 <danharaj> If you don't think Haskell is a toy than you shouldn't hink MySQL isn't a toy.
01:13:07 <wli> There are problems with that comparison.
01:13:09 <p_l> danharaj: it was caused by bad experiences with MySQL, and I still stick to Postgres
01:13:35 <danharaj> p_I: Oh, don't get me wrong, you're fully entitled to think MySQL sucks :p
01:14:10 <cjs> p_l: No. I can understand why a program might accept "February 29th" as a date in a non-leap year. I can even understand how, if your programmers are lazy, or stupid, or just time-constrained, how they might consider "February 30th" to be a valid date. But in what world is "February 0th" ever correct?
01:14:30 <p_l> cjs: oh?
01:15:23 <cjs> The basic issue is that the MySQL guys, and by extension the Ruby ActiveRecord guys and so on, have no fucking clue what a DBMS is.
01:15:47 <p_l> cjs: don't get me started on "opinionated" AR guys
01:15:52 <kmc> haha
01:15:59 <kmc> datetime libraries are hard, let's go shopping
01:16:06 <cjs> It's an inference engine. You give it facts, and ask questions, and from the facts it has it infers new ones.
01:16:39 <cjs> kmc: Mmm. Right. But will we ever get it correct? Haskell's had the best I've seen so far.
01:16:58 <danharaj> Are there any Ruby library developers who know what they're doing? </set phasers to troll> :D
01:16:59 <wli> I don't think the calendrics issue is so much a matter of RDBMS's as it is programming.
01:17:17 <ulfdoz> nevertheless, an embedded postgresql would be fine.
01:17:20 <fabjan> yeah, how does the weird datetime support in myswl make it an inference engine instead of a dmbs?
01:17:28 <lpjhjdh> so I accidently got two copies of the same package installed globally, can I somehow specify which one to hide?
01:17:52 <kmc> cjs, really?
01:17:55 <kmc> i found it pretty bad
01:18:05 <kmc> unless there's some extra library i didn't find
01:18:06 <wli> It's the old freshman programming problem of rejecting malformed input in an orderly fashion instead of (a) corrupting your dataset or (b) dumping core or (c) something worse.
01:18:18 <Saizan> lpjhjdh: different versions, hopefully?
01:18:25 <lpjhjdh> Saizan: no :(
01:18:42 <kmc> well, maybe Feb 0 should be accepted and normalized to Jan 31
01:18:45 <kmc> but it should never be stored
01:19:05 <kmc> preferably, you store in some simple uniform format like julian days
01:19:06 <Saizan> lpjhjdh: mh, you could try deleting the file manually from the package db directory and recache
01:19:09 <danharaj> Dates should be dependent types :p
01:19:29 <cjs> danharaj: Ha ha ha! The Ruby libraries (which I know all too well) are very amusing.
01:19:50 <lpjhjdh> Saizan: ah, thanks
01:20:12 <danharaj> cjs: In what ways? :)
01:20:38 <p_l> danharaj: some are brilliant, some are opinionated :P
01:20:51 <lpjhjdh> Saizan: so just wipe out the file under package.conf.d?
01:22:14 <cjs> kmc: It's one of the few, or perhaps even the only, that distinguishes between the concepts of DiffTime and NominalDiffTime.
01:23:19 <cjs> danharaj: Well, it's mostly just they way they always get things wrong through lack of any forethought whatsoever.
01:23:21 <Saizan> lpjhjdh: yeah, that will not just hide it though
01:23:49 <cjs> And the way I'm constantly monkeypatching them to get shit working. *Sigh*.
01:24:08 <xenoblitz> ppl is it possible to have a single function with different arities using type classes? (I need it to overload an embedded language construct)
01:24:32 <lpjhjdh> Saizan: ok, if I recache should that fix it?
01:24:44 <cjs> wli: You're quite correct. But it seems that freshmen forget or ignore that idea after only a few years.
01:25:58 <lpjhjdh> Saizan: blarg, broken packages, okay, I think I can hack it into submission.  Thanks :)
01:26:20 <kmc> xenoblitz, in essence, yes
01:26:22 <kmc> it's a common trick
01:26:34 <xenoblitz> kmc: any link perhaps? =)
01:26:41 <kmc> hmm Text.Printf does it but it's a big example
01:26:44 <kmc> i think oleg wrote something on it
01:26:49 <kmc> i'll make a tiny example right now :)
01:26:57 <xenoblitz> kmc: wow thanks =)
01:27:44 <danharaj> cjs: I think monkeypatching is a terrible idea, but apparently it's the only way you can make functioning applications in Ruby :d
01:28:53 <cjs> danharaj: Wow, I had to look at your statement twice, thinking, how did something I would say get there without me typing anything? :-)
01:29:35 <cjs> kmc: BTW, I'm waiting on your example too, if that's going to make you work any harder.
01:29:42 <kmc> ;P
01:29:44 <triyo> I have a function A with signature ... FilePath -> IO [String] and function B with signature ... String -> IO TodoEntry . What is the most idiomatic way I could compose these functions in Haskell?
01:29:55 <kmc> :t (>=>)
01:29:56 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:30:06 <cjs> (I know how to do it, but I'm far from convinced that I know how to do it nicely.)
01:30:16 <Saizan> mapM B <=< A
01:30:38 <triyo> [String] of function A will be feed, one at a time, into function B.
01:30:38 <kmc> now neither am i ;P
01:31:29 <cjs> Darn!
01:32:17 <ivanm> @type (<=M)
01:32:18 <lambdabot> Not in scope: data constructor `M'
01:32:19 <ivanm> @type (<=<)
01:32:20 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
01:32:48 <ivanm> Saizan: what's that, (.) inside a monad?
01:34:04 <cjs> ivanm: Isn't that just syntax to separate the two different conditions?
01:34:25 <ivanm> @src (<=<)
01:34:25 <lambdabot> Source not found. There are some things that I just don't know.
01:34:27 <ivanm> bah
01:34:51 <kmc> damn example isn't working
01:34:53 <Saizan> ivanm: yeah
01:34:53 <ivanm> @type \ f g x -> do { x' <- g x; f x }
01:34:54 <lambdabot> forall t (m :: * -> *) t1 b. (Monad m) => (t -> m b) -> (t -> m t1) -> t -> m b
01:34:55 <kmc> and i'm busy actually :/
01:35:05 <Saizan> http://gist.github.com/444714 <- i like doing varargs via GADTs
01:35:05 <ivanm> @type \ f g x -> do { x' <- g x; f x' }
01:35:06 <lambdabot> forall t (m :: * -> *) t1 b. (Monad m) => (t1 -> m b) -> (t -> m t1) -> t -> m b
01:35:25 <Saizan> i don't claim that it's particularly nice though.
01:35:32 <ivanm> heh
01:35:53 <cjs> ivanm: I liked the second one better than the first. :-)
01:36:15 <ivanm> cjs: out of what I did? seeing as how my first one had a bug in it (x rather than x')...
01:36:22 <xenoblitz> kmc: thanks all the same
01:37:33 <Phyx-> hmm.. Do you think the user will notice a 2.5gb memory leak?
01:37:42 <Phyx-> maybe i can write it off as a feature.. :P
01:37:46 <danharaj> ivanm: The typechecker catches the bug :p
01:38:17 <ivanm> yup
01:38:32 <ivanm> type driven development is thus proven! :p
01:39:27 <cjs> Phyx-: The problem with the leaks is that they keep growing.
01:39:37 <xenoblitz> maybe there is a simpler way to do what I need ... I simply need these two functions: if' :: Expression -> Then -> a -> Else -> a -> a; if' :: Expression -> Then -> a -> a
01:40:00 <danharaj> space leaks are my biggest beef with lazy evaluation
01:40:06 <ivanm> @type guard
01:40:06 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:40:15 <ivanm> xenoblitz: ^^ this kinda looks like your second one
01:40:18 <cjs> Sure, you upgrade your i7 from 6 GB to 12 GB of memory, because it's cheap. But a true leak will alwyas drive you into swap, eventually.
01:40:22 <ivanm> @type when
01:40:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:40:40 <ivanm> ^^ actually, make it that one
01:40:57 <ivanm> > guard True :: [()]
01:40:57 <lambdabot>   [()]
01:41:02 <ivanm> > guard False :: [()]
01:41:03 <lambdabot>   []
01:41:41 <danharaj> hmm... I wonder if a 'eager-by-need' evaluation strategy could work, where the RTS evaluates thunks in parallel, but doesn't wait on evaluations that aren't needed.
01:41:52 <cjs> More seriously, having dealt with this a lot in my life, the problem with large heaps is that the GC takes a long time to collect them. So even if you don't care how much memory you're using in terms of just memory se que, you still take a (noticable) performance hit.
01:42:30 <xenoblitz> ivanm: yeah but i wish to allow for a language construct with an if with either a then or a then and an else... the first one is a special case of the second, but the user need not know
01:42:55 <ivanm> xenoblitz: sounds suspiciously like imperative programming to me
01:43:16 <xenoblitz> ivanm: no no I am embedding a language in haskell and i wish to have a nicer language, that's all
01:43:16 <ivanm> you could possibly do some kind of hack to overload some if' function
01:43:19 <ivanm> e.g. how printf works
01:43:45 <xenoblitz> ivanm: I am looking at it right now but I can't figure it out yet, need to stare a little more at it
01:43:53 <danharaj> is 'case ... of' really that much of a burden in comparison to if then else?
01:44:31 <xenoblitz> danharaj: yeah since I don't plan to have variables and what not
01:45:28 <danharaj> but if then else is just casing on a Bool expression!
01:46:23 <xenoblitz> danharaj: I could use a case of but to implement it as a construct I would still need to have a function with different arity (so does not solve my problem)
01:47:14 <danharaj> fair enough
01:49:34 <cjs> xenoblitz: Actually, the most beautiful thing of all is a language with no syntatic "if" construct whatsoever. That was perhaps the most beautiful thing about Smalltalk.
01:50:32 <xenoblitz> cjs: I agree... but implementing a scripting without an if statement would make most programmers go "I'm not gonna use it"
01:50:32 <kmc> yeah
01:50:41 <xenoblitz> cjs: *scripting language
01:50:44 <kmc> Haskell's 'if' is a totally unnecessary wart
01:51:05 <kmc> xenoblitz, i'm sorry you have to design to the lowest common denominator :/
01:51:13 <xenoblitz> kmc: yeah I agree... it made it impossible for me to declare a function called if without the if' :P
01:51:19 <danharaj> Design to yourself and just act really confident and arrogant.
01:51:27 <danharaj> and use plenty of buzzwords.
01:51:33 <danharaj> *make up your own buzzwords*
01:51:39 <kmc> haha
01:51:40 <cjs> xenoblitz: Funny, you know, I hardly ever use "if" in Ruby. Just || or &&.
01:51:50 <kmc> make up new words for existing concepts
01:52:02 <kmc> like "goroutines" and "delegates"
01:52:08 <danharaj> oh I just had a spark of insight
01:52:17 <danharaj> I am going to formulate a joke
01:52:17 <xenoblitz> hehe
01:52:21 <danharaj> relating Python and Snake Oil
01:52:26 <cjs> kmc: I'm glad to hear you say that, because Haskell was the exception that made me break my rule that I will never, ever really like a language with a syntactic "if".
01:52:52 <kmc> heh
01:52:53 <cjs> danharaj: You mean, "buzzwordize"?
01:52:54 <scriptdevil> I have a huge problem learning haskell :( I fall in love with it and then I suddenly jump a buncha chapters. Encounter a word like GADT and then totally lose hope. Later, again fall in love and cycle :(
01:53:35 <cjs> scriptdevil: Keep in mind that GADTs are still extensions. You don't need to know or use those to know or use Haskell.
01:53:37 <xenoblitz> i wish haskell had no if and no real keywords and used functions instead... such that I could hide for example if or even overload it...
01:53:55 <cjs> xenoblitz: You're living in Smalltalk dreamworld.
01:53:56 <xenoblitz> would be awesome for embedding languages in it
01:54:01 <kmc> you can always ditch the embedded-language idea
01:54:04 <kmc> and just write a parser
01:54:21 <danharaj> embedding the abstract syntax will be really easy in Haskell
01:54:22 <xenoblitz> kmc: i wish but its part of my msc :P
01:54:32 <danharaj> and parsing concrete to abstract is really easy in Haskell
01:54:36 <kmc> Haskell syntax is not the best for EDSLs even though that's one of the big Haskell niches
01:54:39 <scriptdevil> cjs: Yeah. That is where I trip. I start reading about some obscure feature. I am not a Math student. So some papers get me lost.
01:54:47 <kmc> xenoblitz, you could also use quasi-quoting
01:54:58 <kmc> to integrate a parsed non-embedded language with embedded code
01:55:13 <kmc> scriptdevil, most of us aren't math students i think
01:55:22 <cjs> Think about the Lisp vs. ML sort of thing. I used to be so completely on the side of the Lispers, due to the theoretical beauty of data being code and code being data and so on, but it turns out that, though I disapprove of this in theory, Haskell, with all of its syntax, is really, really nice.
01:55:25 <cjs> Sweet, even.
01:55:46 <kmc> scriptdevil, i think you recognize the problem though ;)
01:55:50 <kmc> if you stop jumping ahead you can make progress
01:55:59 <xenoblitz> kmc: you lost me at quasi-quoting... but seriously is there a link anywhere with a simpler example than the printf example as I still can't figure it out
01:56:26 <danharaj> It would not be a big step to strip Haskell of all its syntactic sugar, leaving one beast of a lambda calculus, and then using something like TH to build up the syntax.
01:56:27 <kmc> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
01:56:31 <kmc> xenoblitz, ^^^^
01:56:32 <scriptdevil> kmc: :D Yeah. I just downloaded an erlang book and realized that I was mentally converting it to haskell. So I just rm -red that directory and I am staring at Real world haskell now :P
01:56:32 <cjs> scriptdevil: Don't worry about it. There's all sorts of obscure shit the academics do, because it's also a research language, but that doesn't mean that way behind them there isn't all sorts of useful stuff for you (and for me, by the way).
01:56:45 <xenoblitz> kmc: thanks!
01:57:09 <kmc> and http://www.amateurtopologist.com/2010/01/12/variadic-functions-in-haskell/ xenoblitz
01:57:27 <cjs> For example, I'm embarrassed to admit, though I know the monad thing in and out, I still don't use arrows. But I'm still better off than I used to be in Ruby or Java or whatever.
01:57:32 <scriptdevil> cjs: :) That did put some more hope :D
01:57:43 <kmc> nobody uses arrows ;P
01:57:55 <cjs> kmc: John Hughes does!
01:58:25 <danharaj> arrows are snake oil
01:58:32 <danharaj> no offense to sexy researchers
01:58:39 <kmc> the obscure academic shit becomes practical really fast
01:58:44 <cjs> scriptdevil: It's just something you have to get used to and accept. If you're a Haskell programmer, most likely most of the people who understand at all what you do are much smarter than you.
01:58:44 <xenoblitz> kmc: thanks again =)
01:58:51 <kmc> faster than the programming world is generally used to
01:58:52 <cjs> At least it's better than the other way around.
01:59:08 <kmc> to the world at large, first-class functions are obscure academic shit, and they date to 1936
01:59:23 <Gracenotes> they become practical if someone actually finds them
01:59:33 <danharaj> That's because, unlike real engineers, programmers have been neglecting the mathematical foundation upon which their work makes sense.
01:59:41 <scriptdevil> cjs: :D Yeah. Code that Don produces kinda blows me off at times :P
01:59:59 <danharaj> Logic and Type Theory are to programming what Differential Equations are to Engineering
02:00:00 <kmc> yes, it's better than the other way around
02:00:48 <cjs> Really? I suppose it's because I'm a bit from the old days (i.e., first assembly: 6502), but Dons, while smart, seems to me to do just the right thing, which is, but shouldn't be, anything special.
02:00:49 <kmc> btw xenoblitz quasiquotes are documented at http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/template-haskell.html#th-quasiquotation
02:01:30 <cjs> Anyway, I need to go out drinking now. (An unusual thing for an ICFPPC weekend.) Have fun!
02:01:41 <kmc> enjoy cjs
02:01:46 <danharaj> cjs: Don't drink and derive (typeclasses)
02:02:34 <xenoblitz> kmc: ah template haskell =)
02:02:42 <xenoblitz> kmc: I'll check all the links out, thanks
02:02:44 <kmc> anyway, i think a lot of the type-theoretic extensions in GHC are really useful for getting shit done
02:03:02 <danharaj> I like how GHC's extensions are very clean
02:03:03 <kmc> and i think the less-used extensions are not so much fancy type trickery
02:03:26 <danharaj> compared to extensions to other languages
02:03:29 <kmc> but just sugar people don't generally like
02:04:38 <kmc> rank-2 types and existentials are used prominently in the standard library for practical things
02:04:46 <kmc> it's unfortunate that they're not standard
02:06:22 <danharaj> It'd be nice if existentials had more sugar.
02:06:31 <danharaj> And maybe looked more like they do in, say, Pierce?
02:06:53 <kmc> yeah
02:08:08 <kmc> http://www.mail-archive.com/haskell-cafe@haskell.org/msg58249.html
02:08:31 <kmc> "first-class existentials are still desirable because introducing a new type for every existential is annoying. It's comparable to having to write a new class for every combination of argument and result types to mimic first class functions in Java"
02:08:42 <kmc> ice burn on GHC ;P
02:08:58 <danharaj> heh :p
02:11:07 <danharaj> it should be a GSoC
02:11:20 <kmc> i wonder how deep the changes would be
02:11:34 <kmc> System Fc doesn't have existentials afaik
02:11:40 <danharaj> hmmm
02:11:48 <Phyx-> hmm that's odd..
02:11:51 <danharaj> Would we need typeclasses if we had full existentials?
02:11:58 <kmc> but maybe they could be desugared
02:12:02 <kmc> into what's used today
02:12:16 <kmc> danharaj, define "need"
02:12:22 <kmc> we don't really truly need type classes at all
02:12:34 <kmc> but they are mostly orthogonal to existentials
02:12:55 <kmc> type classes are about implicit arguments whose values are inferred from types
02:13:16 <danharaj> Ok bear with me, it's 5 am and I haven't read that chapter in Pierce in forever. But existentials ala Pierce define an interface, no?
02:13:38 <kmc> yeah
02:14:01 <danharaj> So instead of implicitly passing dictionaries, we can box types in existentials.
02:14:12 <danharaj> So I guess when I say 'need' I mean, typeclasses can be desugared into existentials
02:14:21 <xenoblitz> kmc: so if I understood correctly, the entire idea is the instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) part
02:14:23 <danharaj> And I am not sure?
02:14:54 <kmc> type classes and existentials both define "interfaces", in a vague use of the word
02:15:20 <kmc> not in a precise technical sense
02:15:40 <danharaj> Well, interface is an oop buzzword.
02:15:43 <kmc> i don't see what existentials buy you in desugaring typeclasses
02:16:07 <kmc> sure, and interfaces were a key idea in abstract data types, before the OOP people declared that they had the One True Way to do abstract data types
02:16:13 <kmc> (although they can't actually agree on what that way is)
02:16:33 <kmc> anyway how do you propose to use existentials in desugaring type classes?
02:17:18 <kmc> if a value is packaged together with a type class instance in such a way that the underlying type is forgotten
02:17:22 <kmc> then what you already have is an existential
02:17:28 <danharaj> So we look at a class definition, and it tells you the signature a dictionary of functions must satisfy in order to create an instance fro the class.
02:17:35 <kmc> you can desugar the dictionary field of the existential into an explicit dictionary
02:17:47 <kmc> that's orthogonal to the existentials feature; it's the same as the standard typeclass desugaring everywhere
02:18:16 <kmc> btw, the simplest way to create an "interface" in Haskell is neither existentials nor type classes
02:18:23 <kmc> it's just a plain old record
02:18:40 <kmc> data Shape = Shape { move :: (Int, Int) -> Shape; draw :: IO () }
02:18:50 <kmc> that's an interface
02:19:03 <kmc> implementations are just values; they don't need to be of distinct types
02:19:05 <kmc> in fact they can't be
02:19:21 <danharaj> Well, what about something like show :: forall a. (Show a) => a -> String
02:19:33 <kmc> the idea that new behaviors must always be represented by new types is a carryover from the less-expressive OOP languages
02:19:37 <kmc> and leads to overuse of type classes in Haskell
02:19:47 <kmc> ok
02:21:06 <ezyang> records containing functions are indeed some of the most powerful things you can do. 
02:21:23 <kmc> likewise records containing actions
02:22:02 <danharaj> kmc: So that uses typeclasses, but there is a relationship to the existential type {X, X -> String} (notation from Pierce).
02:23:26 <kmc> exists x. x -> String
02:23:35 <kmc> in UHC syntax
02:23:40 <danharaj> I like Pierce's notation, actually :p
02:24:24 <kmc> can you elaborate on what the relationship is?
02:24:40 <kmc> "show" is one specific value
02:24:42 <danharaj> the way to translate typeclasses and instances to existentials is, for a function that takes a polymorphic type with typeclass constraints, instead you build the existential from the argument and the dictionary provided by the instance declaration.. I think
02:24:50 <kmc> Â«exists x. x -> StringÂ» is a type containing many values
02:25:04 <kmc> do these values relate at all?
02:26:11 <kmc> the desugaring you describe is a superfluous use of existentials
02:26:53 <kmc> you might as well make the dictionary an extra function argument
02:27:10 <kmc> you don't gain anything by the existential type-hiding, because the source-language construct (polymorphism with class constraints) doesn't hide types that way
02:27:24 <kmc> and it's going to be problematic too
02:27:40 <danharaj> kmc: what sorts of problems?
02:28:33 <kmc> so in what you describe
02:29:23 <kmc> an arg of type Â«aÂ», where Â«Show aÂ» is in the context, gets desugared to an arg of type Â«exists t. (t, t -> String)Â»
02:29:25 <kmc> right?
02:29:43 <kmc> not the same as Â«exists t. t -> StringÂ» which is a totally useless value
02:29:56 <danharaj> yeah
02:30:12 <danharaj> but, that function accepts more arguments than the typeclass one
02:30:16 <danharaj> that is a problem.
02:30:30 <kmc> yes
02:30:41 <kmc> so what's the advantage over desugaring to simply Â«(t, t -> String)Â»
02:31:02 <kmc> where t now gets universally quantified in the ordinary way?
02:31:46 <kmc> if you use that desugaring, you will have a problem with methods like (==)
02:31:56 <kmc> (a, a -> a -> Bool) -> (a, a -> a -> Bool) -> Bool
02:32:01 <kmc> which dictionary do we use?
02:32:14 <kmc> with the existential desugaring, the problems get worse
02:32:32 <danharaj> ah true, when you have higher arity things get sticky
02:32:53 <kmc> (exists a. (a, a -> a -> Bool)) -> (exists b. (b, b -> b -> Bool)) -> Bool
02:32:55 <danharaj> so typeclasses are pretty much orthogonal
02:33:10 <kmc> now it's impossible to even choose one of the two dictionaries arbitrarily
02:33:20 <kmc> because the first dictionary won't accept b, and the second dictionary won't accept a
02:33:37 <kmc> you've hidden the types a and b, and in doing so made it impossible to assert that they're equal
02:34:19 <kmc> btw if you haven't read http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:34:22 <kmc> it is very slightly relevant
02:34:24 <danharaj> kmc: I have read that
02:34:25 <kmc> and a good post anyway
02:34:40 <danharaj> kmc: So what things can existentials do that can't be reasonably done with records of functions?
02:34:43 <danharaj> (or typeclasses)
02:35:13 <kmc> well, if you allow higher-rank polymorphism, then you can always get rid of existentials with a continuation-passing style
02:35:36 <kmc> Â«exists a. T aÂ» becomes Â«(forall a. T a -> r) -> rÂ»
02:35:44 <kmc> whether this is reasonable is a matter of opinion ;)
02:35:58 <danharaj> :p
02:36:07 <danharaj> How true is the other direction?
02:36:16 <kmc> higher-rank polymorphism to existentials?
02:36:28 <danharaj> how often can you translate (forall a. T a -> r) -> r to (exists a. T a)?
02:36:51 <danharaj> well when I put it that way
02:36:53 <danharaj> >_<
02:37:11 <danharaj> But maybe things get stickier when you have even higher rank?
02:37:33 <kmc> well that's just a particular example of a higher-rank type
02:37:42 <kmc> there are other even rank-2 types not of that form
02:37:54 <pastorn> on *nix i want to poll for how long it's gone since i last checked?
02:37:57 <danharaj> well my imagination isn't rank-2 :p
02:38:06 <kmc> also i'm not sure how you do that conversion even
02:38:10 <pastorn> i want to get something like :: IO MicroSeconds
02:38:14 <danharaj> So the cps transform is... well it looks injective, but it's not surjective.
02:38:18 <kmc> since you last checked what?
02:38:49 <danharaj> since he last checked how long it's gone since he last cehcked since...
02:38:56 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/old-time/System-Time.html#v%3AgetClockTime
02:39:01 <kmc> getClockTime, diffClockTimes
02:39:31 <pastorn> kmc: cool, thanks :)
02:39:48 * pastorn avoids Data.Time like the plague
02:41:10 <danharaj> resolution past milisecond is implementation dependent
02:41:51 <kmc> so, a common use-case for existentials in Haskell is an open sum type
02:41:57 <illissius> is the 'TypeCast a b' magic from Oleg's stuff exactly equivalent to 'a ~ b', or is there some difference? I tried replacing one for the other and it still compiled, and appeared to behave the same way
02:42:01 <kmc> like Control.Exception
02:42:24 <kmc> illissius, Â«instance TypeCast a aÂ» ?
02:42:45 <danharaj> (what is the alt+ for those brackets)
02:42:55 <kmc> no idea
02:43:06 <kmc> > map ord "Â«Â»"
02:43:06 <lambdabot>   [171,187]
02:43:18 <danharaj> Â½â
02:43:26 <kmc> :/
02:43:32 <kmc> i type them with Compose
02:43:32 <danharaj> Â«
02:43:36 <kmc> nice
02:43:37 <danharaj> Â»
02:43:42 <kmc> Compose < <
02:43:48 <danharaj> I needed a trailing 0 on my numbers.
02:43:54 <danharaj> er
02:43:56 <danharaj> leading 0
02:43:57 <illissius> kmc, was that a question or an example of a difference? I don't understand these things yet well enough to tell :)
02:44:11 <kmc> illissius, i was asking if that's how the TypeCast in question works
02:44:18 <kmc> i'm not familiar with the particular Oleg article
02:44:24 <kmc> do you have a link?
02:46:10 <danharaj> GHC has impredicative types an extension right?
02:46:16 <illissius> kmc: http://okmij.org/ftp/Haskell/poly2.hs here's one (I've seen it used in a variety of places)
02:46:22 <illissius> the TypeCast stuff specifically is at the end
02:46:27 <kmc> danharaj, yes.  it's going away though
02:46:38 <kmc> danharaj, in favor of explicit wrappers, like the current situation with existentials
02:47:29 <danharaj> kmc: Bleh. So, aren't impredicative types more complicated to implement? Was the demand for them big enough that the GHC people thought it was worth it?
02:47:42 <kmc> i'm not sure why they implemented it
02:47:58 <kmc> they are taking it out because of the complexity of maintaining that implementation
02:48:01 <illissius> kmc: the article itself is http://okmij.org/ftp/Haskell/poly2.txt
02:48:06 <danharaj> fair enough.
02:48:34 <kmc> illissius, that's some deep magic
02:48:48 <illissius> yeah.
02:48:59 <kmc> i'm not sure what TypeCast' and TypeCast'' are for
02:49:01 <illissius> but, as far as I can tell, does the same thing as ~
02:49:08 <kmc> it probably does
02:49:09 <illissius> part of the implementation of TypeCast as far as I can tell
02:49:16 <kmc> yeah but why are they needed
02:49:23 <illissius> no idea! :D
02:50:17 <kmc> it's from HList
02:50:43 <kmc> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-TypeCastGeneric1.html is the simple version
02:50:49 <illissius> anyway I assume ~ wasn't around and this does the same thing, but due to not understanding it I'm also not sure
02:51:16 <kmc> but has some weird caveat that the constraints get simplified away
02:51:39 <illissius> oh, that's it?
02:51:45 <kmc> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/src/Data-HList-TypeCastGeneric2.html
02:51:47 <illissius> ok then
02:51:57 <kmc> is obviously some kind of hack to get around that caveat
02:52:01 <kmc> and i have no idea how it works
02:53:42 <kmc> it's described in Appendix D of the HList paper
02:54:06 <kmc> if you want to understand ~ then you can check out the System Fc paper
02:54:25 <kmc> in Fc, (s ~ t) is actually a *kind*
02:54:31 <kmc> and types of that kind are evidence of equality
02:55:41 <illissius> hmm, sort of like `data SameType a b where Same :: SameType a a` at a higher level?
02:56:21 <kmc> which is a bit odd, because you can still pattern-match them out of constructors
02:56:22 <kmc> yes
02:56:48 <kmc> the advantage of doing it at type level is that the kind system they introduce is logically sound
02:57:07 <kmc> whereas Haskell types aren't -- you have unrestricted recursion; you can prove any fact trivially
02:58:18 <danharaj> one must wonder why we insist on having sound kinding but we treat terms like second value citizens with the albatross of bottom hanging around their necks :p
02:58:36 <chrisdone> i downloaded haskell-mode 2.7.0 and for some reason the behaviour for TAB is to insert spaces rather than indenting the current line according to the cycle. anyone else get this?
02:59:21 <kmc> yeah, in Fc each constructor holds some number of types and some number of terms
02:59:36 <kmc> which makes sense, i guess it's the same in plain old F with algebraic data
02:59:43 <kmc> because polymorphism is more explicit everywhere
03:01:29 <illissius> kmc: I'd say "I see" but in reality I only have a vague sense :); I think this stuff is a bit higher up on the learning curve for me (currently trying to understand the rest of the Oleg magic from that article I linked)
03:03:20 <JN> why don't they make this haskell stuff easier
03:04:12 <kmc> that would take all the fun out of it ;P
03:04:23 <kmc> how would we be smug, elitist language hipsters then
03:04:30 <danharaj> Kolmogorov complexity :p
03:05:39 <kmc> part (and only part) of why Haskell seems hard is just that there's a higher ceiling
03:05:55 <JN> what's the remainder
03:06:03 <kmc> various other bits
03:06:18 <kmc> i mean, i could give other theories for why haskell is hard
03:07:03 <kmc> but the reason System Fc, GADTs and Oleg hackery are hard
03:07:24 <kmc> is that people just don't bother in other languages
03:08:12 <kmc> nobody is doing PHP theory at that level
03:08:38 <danharaj> Haskell is hard because programming correctly is hard.
03:08:49 <danharaj> We don't abide to that freewheeling cowboy programming round these parts.
03:08:52 <JN> ok. so how can I learn how to program correctly. in haskell.
03:08:53 <kmc> so does that mean Haskell is harder than PHP, or does it mean there are additional things in the Haskell-universe which might or might not be relevant to any given user
03:08:56 <danharaj> We follow the Church of Church.
03:09:11 <Phyx-> PHP has a theory?
03:09:16 <danharaj> (my greatest pun yet)
03:09:28 <kmc> i think Haskell is harder than PHP, quite a bit harder, but not because of that stuff
03:09:50 <kmc> JN, practice
03:10:04 <kmc> reading books and papers and code and talking here
03:10:07 <kmc> but mostly practice
03:10:17 <JN> how can I practice without being bored to death by toy examples, or overwhelmed by complex examples
03:10:27 <kmc> by sucking it up and doing the toy examples anyway
03:10:38 <danharaj> Stuff like GADT seems hard until you come across a project where Â«hard thingÂ» is exactly the right tool for the job. Then it seems easy.
03:10:40 <kmc> we can give you advice on what to try
03:10:52 <kmc> if you think there's a gap like that
03:11:09 <kmc> if the toy examples are boring *and* easy, try something more involved
03:11:26 <kmc> if the toy examples are boring but hard, you'll have to learn to deal with that
03:11:54 <kmc> there's always room for improving the teaching, but Haskell will never be a "jump right in" language
03:12:23 <Twey> And thank goodness for that
03:12:30 <kmc> and i think that's true even if everyone learning Haskell were learning it as a first language
03:12:50 <JN> why thank goodness.  why is "jump right in" not a good quality
03:13:10 <kmc> JN, because there's a half-serious motto around here which is "avoid success at all costs"
03:13:39 <JN> well, you don't have to try so hard at it
03:13:50 <kmc> also because you can't write correct programs by jumping in and not knowing what you're doing
03:14:06 <kmc> and the point of Haskell is to make all programs a bit harder to write, and to make incorrect programs /much/ harder to write
03:14:34 <danharaj> kmc: and since we avoid success at all costs, it turns out writing most programs becomes much easier :)
03:14:36 <kmc> it's funny when people argue against static types by saying "they limit what the programmer can do"
03:14:46 <kmc> of course they do, that's the whole f*#%king point
03:15:30 <JN> I'm a proponent of strong typing.. I think haskell's strong typing and higher level type inferencing is awesome.. (coming from a Java developer)
03:15:56 <ManateeLazyCat> Have any Haskell mail-client? I'm looking for mail-client backend, it's better if write by Haskell. :)
03:17:22 <danharaj> JN: Our snake oil is better than Java's snake oil.
03:17:33 <kmc> you can tell it's better, because nobody uses it
03:17:44 <kmc> most people are dumb, most people don't use Haskell, ergo people who use Haskell are smart
03:18:18 <kmc> my logic is flawless
03:18:21 <JN> I am not most people... ergo I am not dumb
03:18:24 <JN> (mine too)
03:18:39 <kmc> well, that would match expectation
03:18:48 <kmc> everyone thinks that most people are dumb, but everyone knows that they're the exception
03:19:22 <JN> ambiguous
03:19:46 <JN> for each person a, a thinks that most people are not dumb, but a knows that a is the exception
03:20:48 <danharaj> doxastic logic is tremulous ground.
03:20:50 <ManateeLazyCat> Which mail-client do you use? 
03:21:09 <ivanm> ManateeLazyCat: there's the beginnings of an imap library on hackage IIRC
03:21:23 <ivanm> see also HaskellNet
03:21:34 <ivanm> and hsemail
03:21:46 <ivanm> there's also an mbox library
03:22:40 <ManateeLazyCat> ivanm: Thanks... I will look  ....
03:23:38 <ManateeLazyCat> ivanm: Hmmm, HaskellNet looks great.
03:23:39 <kmc> ugh, email
03:23:44 <kmc> stone-age technology
03:23:59 <kmc> but at least it's not fucking facebook
03:24:06 <ivanm> heh
03:24:09 * Phyx- likes kmc's rant
03:24:11 <ivanm> kmc: you prefer google wave, do you?
03:24:16 <kmc> which rant Phyx-
03:24:24 <kmc> ivanm, no i prefer complaining
03:24:29 <ivanm> heh
03:24:31 <Phyx-> kmc: about facebook
03:24:37 <kmc> oh
03:24:37 <ManateeLazyCat> ivanm: I don't need mail-backend, i can build my own mail-backend with Haskell. :)
03:24:40 <kmc> one line is a rant now?
03:24:43 <ManateeLazyCat> ivanm: Base on HaskellNet.
03:25:15 <Phyx-> kmc: It was in anticipation of more
03:25:33 <Phyx-> so go on :)
03:25:37 <kmc> i got nothin'
03:25:41 <Phyx-> :|
03:26:07 <ivanm> awwww....
03:26:10 <kmc> email sucks because it's too simple and totally decentralized
03:26:16 <ivanm> kmc: surely you can do better than that!
03:26:17 <kmc> facebook sucks because it's too complicated and totally centralized
03:26:36 <Phyx-> and leaks like BP's leaking oil
03:26:37 <ManateeLazyCat> I hate Google Wave, too slow.
03:26:39 <ivanm> kmc: I take it you don't pretend to be rational or consistent in your ranting?
03:26:56 <ManateeLazyCat> kmc: I love mail and like it's *too* simple.
03:26:59 <ivanm> brb
03:27:13 <danharaj> irc is where it's at
03:27:17 <kmc> my options are to get forged messages where bank of america is trying to sell me nigerian viagra
03:27:20 <danharaj> also, smoke signals
03:27:38 <kmc> or to get zombie-poked in mafia farm wars
03:28:12 <kmc> danharaj, i enjoy irc and aim and gchat much more than email or fancy newfangled social networking
03:28:22 <kmc> except that store-and-forward doesn't work right
03:28:39 <kmc> the difference from email is mostly social, not technological -- you're expected to think a bit more before you hit 'send'
03:28:47 <kmc> if i sent email like i send irc then maybe i wouldn't care
03:29:14 <ManateeLazyCat> Wow, HaskellNet include Atom and RSS? I don't need parse those myself, sweet.... :)
03:29:55 <kmc> ivanm, what's irrational / inconsistent?
03:30:17 <ManateeLazyCat> HaskellNet + Google Reader is perfect solution for RSS/Atom client solution. :)
03:31:34 <ivanm> kmc: you hating email for being decentralised, but hating facebook for being centralised
03:31:48 <danharaj> no,
03:31:54 <danharaj> for being *too* decentralised
03:32:00 <danharaj> and *too* centralised
03:32:05 <kmc> thank you danharaj
03:32:27 <kmc> even on a single axis i can prefer the middle ground
03:32:30 <kmc> and really it's a many-dimensional space
03:32:36 <ManateeLazyCat> ivanm: Do you know other RSS/Atom library except HaskellNet? 
03:32:47 <ManateeLazyCat> ivanm: I found http://hackage.haskell.org/package/feed
03:32:50 <kmc> i'm pointing out that email and facebook are two distant points in this space which are bad in different ways
03:33:22 <ivanm> ManateeLazyCat: ummm, there's probably other RSS libraries
03:33:31 <ivanm> isn't there one called rss ?
03:33:57 <ManateeLazyCat> ivanm: Have better one ?
03:34:10 <ivanm> nope; but I don't use any of them
03:34:12 <ManateeLazyCat> ivanm: http://hackage.haskell.org/package/rss for generate feed.
03:34:21 <ivanm> I found that mail stuff by looking through the hackage package listing ;-)
03:34:32 <ivanm> but doesn't RWH have a chapter which includes doing rss stuff?
03:34:43 <kmc> feed parsing yeah
03:34:57 <ManateeLazyCat> ivanm: I found some library at "cabal list feed"....
03:35:20 <ivanm> *shrug*
03:35:30 * ManateeLazyCat Even have feed2twitter ... 
03:35:45 <ivanm> ManateeLazyCat: you're probably better off looking directly at the full hackage package listings and searching for rss, feed, etc.
03:36:06 <ManateeLazyCat> ivanm: Looks http://hackage.haskell.org/package/feed is best one.
03:36:32 <ManateeLazyCat> ivanm: Okay, i will do that.
03:37:38 * ManateeLazyCat Use http://www.google.com/reader/atom/feed/ fetch any feed, then i just need parse atom. Haha... 
03:39:41 * ManateeLazyCat Editor, file-manager, webkit-browser, pdf-viewer, mplayer-client, rss/atom-client, mail-client, irc-client, terminal .... Haha ... Continue!
03:40:08 <ManateeLazyCat> Dinner time, back soon. :)
03:42:49 <SonOfLilit> Hello
03:42:49 <SonOfLilit> I'm writing a 4-in-a-row AI
03:42:49 <SonOfLilit> I'm getting to the stage where I need to shuffle around a lot of board states
03:42:49 <SonOfLilit> and I though
03:42:49 <SonOfLilit> t*
03:43:14 <SonOfLilit> (BoardState nextPlayer heights boardArray) looks very much like a monad to me
03:44:06 <kmc> how so?
03:45:24 <SonOfLilit> so I tried to define it, and I realised that a monad needs a parameter and my state should actually be the parameter
03:45:25 <SonOfLilit> so what's the monad itself?
03:45:25 <SonOfLilit> am I simply looking for the list monad and don't know it, or is there actually room for a new monad?
03:45:46 <SonOfLilit> maybe what I'm looking for is a "minimax monad"
03:45:56 <kmc> yeah
03:46:09 <kmc> so you want something different from the plain old (State t) monad?
03:46:39 <danharaj> You should be able to do something with the list monad.
03:46:47 <SonOfLilit> I'm not sure
03:46:48 <SonOfLilit> I'm looking for combined features of List, Maybe and State
03:46:48 <SonOfLilit> with some extra sugar for auto-player-reversal a-la-minimax
03:47:07 <SonOfLilit> maybe I need a list wrapping a maybe wrapping a state?
03:47:17 * hackagebot blaze-html 0.1 - A blazingly fast HTML generation library.  http://hackage.haskell.org/package/blaze-html-0.1 (JasperVanDerJeugt)
03:47:50 <kmc> if you want a stack that complicated
03:47:55 <kmc> then i think it will be easier to define a new monad
03:47:57 <kmc> at least to start out
03:48:06 <kmc> if you then recognize it as a transformer stack, great
03:48:16 <danharaj> I'm not sure why you need state?
03:48:36 <kmc> just work out what return and (>>=) would do on your type
03:48:40 <danharaj> Searching a gametree is a perfect fit of List, is it not? Where are you threading state?
03:49:31 <kmc> iirc the old paper "why functional programming matters" uses minimax as an example
03:49:35 <kmc> though i think it's not monadic
03:49:49 <SonOfLilit> I never wrote a monad myself yet, so I'm not well versed in the ideas and practice...
03:49:50 <SonOfLilit> what I'm really missing and trying to get is that the monad would remember which moves lead to each of the board positions it is storing
03:50:01 <SonOfLilit> so that when I reach a position where I evaluate the board, I can then say "these moves were good, select the first one"
03:50:07 <danharaj> oh, I see
03:50:20 <kmc> you can also write some code without the monad instance, maybe you'll recognize a "design pattern" and that'll tell you what >>= should do
03:50:35 <kmc> i.e. if you didn't know about the Maybe monad
03:50:44 <danharaj> I think you should take kmc's advice, sometimes, a little bit of exploratory coding helps you identify the real structure.
03:50:48 <kmc> you'd recognize a lot of Â«case x of Nothing -> Nothing; Just y -> case z of ...Â»
03:51:01 <kmc> and that's a clue to what (>>=) should do for Maybe
03:52:40 <danharaj> What you could do is actually define the game tree.
03:52:53 <danharaj> Since Haskell is lazy, it won't actually instantiate the whole thing
03:53:17 <SonOfLilit> >>= should... apply every possible move to the current list of positions. And remember which move leads to which position, so that I can then ask for an evaluation of the current board positions and get back a response like "these are the moves with the best score for you right now"
03:53:39 <kmc> SonOfLilit, the remembering bit sounds like Writer
03:53:49 <kmc> @unmtl WriterT w [] a
03:53:49 <lambdabot> [(a, w)]
03:53:55 <SonOfLilit> so I want a... list of (MovePosition, BoardState)?
03:54:02 <kmc> not sure
03:54:11 <kmc> @unmtl ListT (Writer w) a
03:54:11 <lambdabot> ([a], w)
03:54:59 <SonOfLilit> iirc, Writer sounds way off, but I probably don't, so I'll go read
03:55:29 <kmc> well you can build a stack of moves as you traverse
03:56:05 <kmc> you need to do so only for the "current" nondeterministic branch
03:56:06 <SonOfLilit> sounds too generic. the writer keeps a stream, I just want one piece of extra data per >>=
03:56:09 <SonOfLilit> right?
03:56:21 <kmc> which means it's important to get the order of the transformers right
03:57:12 <SonOfLilit> perhaps adding lastMove :: Int to my BoardState will suffice, and then I can work with existing monads
03:57:15 <SonOfLilit> I'll try
03:57:30 <kmc> both Reader and Writer are restricted forms of State
03:57:36 <_Cactus_> hi
03:57:50 <c_wraith> should I sleep or should I hack?
03:58:03 <ManateeLazyCat> c_wraith: Sleep :)
03:58:07 <kmc> hack
03:58:09 <kmc> hi _Cactus_ 
03:58:24 <danharaj> I am eschewing sleep to--- this morning as well.
03:58:36 <c_wraith> it's 4 am.  one of those ambiguous times.  meh, I do my best coding while intoxicated between 2 and 4 am. :)
03:58:39 <danharaj> Anyone who has been in this channel for the past three hours probably noticed my coherency decreasing gradually.
03:58:41 <_Cactus_> is there a library to enumerate all total pairings of a paired graph?
03:59:00 <_Cactus_> by paired I mean bipartite, sorry:)
03:59:30 <c_wraith> not intoxicated.  might as well sleep, I guess.
04:00:39 * _Cactus_ looks up the correct terminology
04:01:32 <_Cactus_> ok so what I want is to enumerate all _perfect matchings_ of a given bipartite graph
04:03:05 <cheater99> is there a way to implement this point-free? maximum' (x:xs) = max x (maximum' xs)  
04:03:44 <kmc> :t foldr1 max
04:03:45 <lambdabot> forall a. (Ord a) => [a] -> a
04:04:36 <kmc> cheater99, assuming your base case is [x] and not []
04:04:46 <kmc> not clear what it would be for [], unless you have Bounded
04:05:10 <FunctorSalad_> how is that thing different from Prelude.maximum?
04:05:26 <FunctorSalad_> :t maximum
04:05:27 <lambdabot> forall a. (Ord a) => [a] -> a
04:05:33 <_Cactus_> hmm
04:05:40 <_Cactus_> looks like I need Data.Algorithm.Munkres
04:05:43 <FunctorSalad_> > maximum [] -- partial too
04:05:45 <lambdabot>   *Exception: Prelude.maximum: empty list
04:06:22 <kmc> FunctorSalad_, i assumed it was intended to be exactly the same
04:11:54 <Sadache> hello everyone
04:12:01 <kmc> hi Sadache
04:12:25 <Sadache> is it safe to do unsafePerformIO for doing a web get request?
04:13:06 <Sadache_> knowing that: Web get request can be lazily done since it doesnt change the external world
04:13:11 <Sadache_> can be cached
04:13:32 <aristid> Sadache_: i think you should really avoid unsafePerformIO.
04:13:46 <cheater99> kmc: ?
04:14:13 <Sadache> but the get verb has very close semantics to a safe computation in my opinion
04:14:28 <cheater99> ah
04:14:31 * cheater99 looks up foldrl
04:15:18 <_Cactus_> cheater99: it's not foldl, its foldr1
04:15:27 <_Cactus_> s/foldl/foldrl/
04:15:28 <_Cactus_> aargh :)
04:15:33 <cheater99> ah
04:15:37 * cheater99 is only waking up
04:16:48 <kmc> @src foldr1
04:16:48 <lambdabot> foldr1 _ [x]    = x
04:16:48 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
04:16:48 <lambdabot> foldr1 _ []     = undefined
04:17:06 <kmc> Sadache, that's an interesting question
04:17:34 <kmc> unsafePerformIO was introduced for FFI
04:17:55 <kmc> for making foreign calls which need imperative marshalling but are actually pure functions
04:18:04 <kmc> and i suppose you can think of some GET requests the same way
04:18:04 <Peaker> it makes sense for composition of IO actions too, though
04:18:11 <Sadache> kmc: interesting
04:18:16 <Peaker> A composition of impure primitives can form a pure operation
04:18:41 <Peaker> (e.g: The underlying impure IO stuff used by GHC to form the pure functions)
04:19:38 <FunctorSalad_> a modulefull of wrongs does make a right in haskell land? ;)
04:19:52 <kmc> Sadache, thank you for posing this question :)
04:20:00 <kmc> heh
04:21:40 <kmc> lots of GET requests are not pure of course
04:22:00 <FunctorSalad_> wouldn't lazily reading a web response have the same issues as hGetContents & company?
04:22:06 <kmc> yes
04:22:13 <kmc> i think that's a different question though
04:22:26 <FunctorSalad_> what was the special issue here then?
04:22:52 <kmc> unsafePerformIO vs unsafeInterleaveIO
04:22:59 <kmc> though i suppose the former has most of the problems of the latter
04:23:00 <Sadache> i am sorry seems i have a bad conection
04:23:00 <FunctorSalad_> I was assuming Sadache just means to do unsafePerformIO to fetch more of the stream, but the whole thing would still be wrapped in IO, like hGetContents is
04:23:17 <FunctorSalad_> (or unsafeInterleaveIO)
04:23:46 <Sadache> FunctorSalad_: I want actually to get rid of IO for when I dont need it
04:23:48 * hackagebot hstatistics 0.1.0.3 - Statistics  http://hackage.haskell.org/package/hstatistics-0.1.0.3 (VivianMcPhail)
04:24:00 <Peaker> lazy IO is against Haskell spirit, unless you truly use it as if you really don't care *at all* when the effects happen - which means you barely ever use it at all
04:24:11 <Peaker> (You can't use it with "withFile", for example, only with a leaked openFile)
04:24:26 <FunctorSalad_> I guess how clean it is depends on whether you abstract from stuff like bandwidth usage :)
04:24:30 <Sadache> like for the get request
04:24:49 <kmc> Sadache, why do you want to get rid of IO?
04:24:59 <FunctorSalad_> (when exactly your bandwidth is used would depend on eval order)
04:25:23 <kmc> how much Haskell experience do you have?
04:25:26 <Sadache> FunctorSalad_: except if I dont inline the function
04:26:59 <Sadache> if i dont inline the function that performs unsafeIO to a url, and have proper semantics to this function, I guess I can get rid of IO for get requests
04:27:42 <kmc> Sadache, i'm not sure why you want to, though
04:27:59 <kmc> in particular the "proper semantics" become much more complicated as soon as you do
04:28:05 <kmc> more complicated and implementation-dependent
04:28:46 <Sadache> I want to make web get requests as native as normal functions for a web framework
04:29:02 <kmc> IO functions are normal functions
04:29:09 <kmc> that return IO actions
04:29:13 <kmc> they are pure functions, in fact
04:29:18 <Sadache> like get "www.twitter.com/sadache" I can treat the result out of a monad
04:29:29 <kmc> that's not a pure value of cours
04:29:55 <Sadache> yes but I dont want to use monadic code for writing transformers of web get requests
04:29:56 <kmc> what happens when you tweet? the value changes
04:30:19 <Sadache> kmc yes, but that doesn't matter
04:30:27 <kmc> Sadache, you said "native"... do you mean you want a native feel to Haskell, or native to some other perhaps embedded language you're developing?
04:31:17 <kmc> Sadache, you said "native"... do you mean you want a native feel to Haskell, or native to some other perhaps embedded language you're developing?
04:31:17 <Sadache> kmc: both, I just want to treat the result without being inside an IO Monad and without the do syntax
04:31:24 <kmc> ok
04:31:30 <kmc> well that's not native Haskell feel at all
04:31:36 <kmc> it will be harder to use and it will confuse every Haskell programmer
04:32:11 <Sadache> kmc: interesting, why is that?
04:32:22 <kmc> because Haskell separates execution and evaluation
04:32:30 <kmc> it's a fundamental part of how Haskell works
04:32:38 <FunctorSalad_> Sadache: I still don't see how you have proper semantics if we include the timing of the communication
04:32:39 <kmc> and you're mixing them together for what sounds like trivial syntactic reasons
04:32:43 <FunctorSalad_> (even with noinline)
04:33:32 <kmc> Sadache, i'm guessing you're avoiding IO because you think it's cumbersome.  the solution is to learn better ways to work with IO.  for example, the "do" syntax is never necessary, and often you'll find some higher-order monadic function to do what you would do in many lines of "do" block
04:33:48 <Sadache> FunctorSalad_: I assume that the function wouldnt be called for a change in the same request. 
04:33:57 <Sadache> kmc: I know of that
04:34:38 <FunctorSalad_> Sadache: I can relate to not wanting monadic code for absolutely everything, but you might just make convenience combinators that take monadic input instead
04:34:42 <FunctorSalad_> like in TH
04:35:03 <FunctorSalad_> :t appE
04:35:04 <lambdabot> Not in scope: `appE'
04:35:06 <FunctorSalad_> :P
04:35:16 <kmc> IO is not just a box to put "impure" things in.  it's imperative programming done right, as first-class values.  you want to throw that out and shoehorn imperative programming into the world of beta-reduction of functions, which is a poor fit for imperative code -- in any language, but more so in Haskell with its non-strict semantics
04:35:28 <FunctorSalad_> I should define an xchat command for invoking ghc -e ':type bla'
04:35:35 <kmc> heh
04:35:42 <xenoblitz> kmc: I think I almost managed to make my if overloaded over one or two inputs but am getting an error which I am not understanding: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26371#a26371
04:36:05 <FunctorSalad_> Language.Haskell.TH.appE
04:36:05 <FunctorSalad_>   :: Language.Haskell.TH.Lib.ExpQ
04:36:05 <FunctorSalad_>      -> Language.Haskell.TH.Lib.ExpQ
04:36:05 <FunctorSalad_>      -> Language.Haskell.TH.Lib.ExpQ
04:36:24 <Sadache> kmc: I hate lifting three times because there happen to be a maybe inside IO with another monad
04:36:31 <FunctorSalad_> err and pipe it through a dequalifying sed
04:36:57 <kmc> Sadache, maybe you can hpaste some code and we can help clean it up
04:36:57 <Sadache> kmc: but I understand the issue
04:37:08 <kmc> or, maybe you have to put up with a little ugliness in Haskell too
04:37:11 <kmc> it's not perfect ;)
04:37:27 <kmc> i think your cure is worse than the disease
04:37:31 <kmc> though it's quite interesting
04:37:34 <FunctorSalad_> someone made "idiom brackets" for autolifted application too
04:37:42 <FunctorSalad_> dunno why they're called like that
04:37:46 <Sadache> kmc: I am trying to imagine how a web framework should look like
04:37:54 <kmc> Sadache, perhaps you want your framework to be more declarative
04:38:02 <FunctorSalad_> (| f x y z |) = f <$> x <*> y <*> z or something like that
04:38:03 <kmc> don't make requests, describe how requests could be made
04:38:09 <kmc> of course, that's what the IO monad does in the first place...
04:38:20 <kmc> Sadache, how much Haskell experience do you have?
04:38:25 <FunctorSalad_> as a preprocessor or quasiquoter, this is
04:38:30 <Sadache> and to my experiene web frameworks for today are about data transformation, from different sources
04:38:56 <FunctorSalad_> pureTransform <$> fetchStuff?
04:38:57 <_Cactus_> if I have two nodes u, v :: Data.Graph.Graph, and I know path u v == True, how do I get an actual path?
04:38:57 <FunctorSalad_> :)
04:39:00 <Philonous> FunctorSalad_: Applicative arrows are also called idions
04:39:01 <kmc> did you look at some of the existing Haskell web frameworks?
04:39:04 <Sadache> FunctorSalad_: so you suggest doing a EDSL ?
04:39:04 <Philonous> idioms*
04:39:06 <FunctorSalad_> Philonous: I see
04:39:18 <Sadache> kmc: yes
04:39:20 <FunctorSalad_> Sadache: maybe. I don't know the whole context :)
04:39:59 <kmc> Sadache, btw, i'm not asking how much experience you have because i think the answer is one way or the other
04:40:09 <kmc> i think it will help me understand better where you're coming from
04:40:31 <Sadache> in a web framework reprsenting a get request as doing IO makes the framework foreigner to web in the first place
04:40:34 <kmc> in a lot of channels they just assume anyone who wants to do something slightly strange is a stupid noob who doesn't know better
04:40:37 <kmc> and that's annoying
04:41:13 <Sadache> kmc: the problem is that I dont know the answer to your question
04:41:30 <FunctorSalad_> kmc: agreed :(
04:41:45 <Sadache> I've been following haskell for years now. I did some haskell code. I am an experienced web developer
04:41:59 <kmc> what have you written in Haskell?
04:42:11 <FunctorSalad_> (then when you explain how your q doesn't make you an idiot, you're accused of pointless arguing, academicism etc)
04:42:41 <Sadache> kmc: mostly pure code. I use haskell for modeling and trying ideas mostly
04:42:41 <kmc> right FunctorSalad_.  when you were probably asking the question in the first place because it's a complicated situation that needs explanation
04:43:54 <kmc> what sorts of ideas?
04:44:56 <Sadache> solutions to problems I have in other languages
04:45:03 <Sadache> like c# f# and java
04:45:15 <kmc> mhm
04:45:39 <kmc> i decided i should quit my C++ job after i redid two weeks of C++ work in about an hour in Haskell
04:45:44 <kmc> by accident
04:45:49 <kmc> while answering a question here
04:45:57 <pastorn> haha
04:46:12 <kmc> it wasn't even something Haskell is particularly good at
04:46:25 <pastorn> kmc: what was it?
04:46:48 <kmc> basically, converting between Â«Map String DynamicÂ» and an actual record
04:46:54 <kmc> i had to use TH
04:46:58 <pastorn> oh, ok
04:47:08 <pastorn> is there even meta-programming in C?
04:47:27 <kmc> in C++ you can use this bizarre meta language called "templates"
04:47:32 <kmc> it is nothing like C++ of course
04:47:38 <kmc> then again C++ would also be a bad metalanguage for C++
04:47:50 <kmc> anyway, it's only a metalanguage by accident, and so it lacks some essential features
04:47:51 <pastorn> yeah, i've seen some code using templates...
04:47:56 <kmc> like inspecting the names of some fields of a struct...
04:48:03 <pastorn> i don't remember the library name, though
04:48:12 <kmc> also C++ syntax is so f'd up that you pretty much can't write external metaprogramming tools
04:48:23 <pastorn> oh, boost
04:48:30 <kmc> boost isn't a library
04:48:31 <L3thal> kmc quite it but there is no haskell jobs
04:48:31 <pastorn> i saw parsing code written with boost
04:48:32 <kmc> any more than gnu is
04:48:37 <kmc> L3thal, i have a Haskell job now
04:48:47 <L3thal> kmc nice
04:48:50 <kmc> i agree there are very few
04:49:34 <Twey> Lucky
04:49:45 <kmc> well, so far i've done mostly sh and make and C
04:49:51 <kmc> because the "Haskell job" is to make GHC target Android
04:50:00 <Twey> Cool!
04:50:01 <kmc> but there will be more Haskell coding down the road
04:50:11 <Twey> Wait
04:50:21 <Twey> Are you with iPWN?
04:50:24 <theorbtwo> kmc: Cool.
04:50:32 <kmc> yeah Twey
04:50:44 <silver> oh I want haskell on android!
04:50:48 <Twey> Nice
04:50:55 <cheater99> why
04:50:56 <theorbtwo> Ah, as an apps mfgr, not google, or phone mfgr?
04:51:00 <cheater99> what is the point of that?
04:51:03 <Twey> Looks like they're really taking off, thenâ¦
04:51:10 <kmc> cheater99, of which?
04:51:30 <kmc> iPwn has written a game in Haskell, and wants to sell it on iPhone and Android
04:51:33 <cheater99> haskell running on android
04:51:37 <kmc> and yes before you mention it i've heard of the Apple EULA
04:51:48 <silver> I have access to the various android phones on my work
04:51:50 <Twey> cheater99: Um, it means that you can write mobile apps in Haskell :Ã¾
04:51:56 <cheater99> why would you?
04:51:56 <silver> so I want to code something for them in haskell
04:52:02 <Twey> Why wouldn't you?
04:52:04 <kmc> cheater99, why would you write any app in Haskell?
04:52:08 <Twey> Usual arguments for Haskell apply
04:52:18 <kmc> it's a pretty good language
04:52:22 <cheater99> i don't know, does the typical android phone have 4096 cpu cores?
04:52:25 <kmc> for a lot of things
04:52:45 <silver> cheater99, no, and what's your point?
04:52:46 <Twey> You think that concurrent/parallel programming is the only advantage of Haskell?
04:52:54 <kmc> cheater99, if multicore is the only reason to use Haskell then i'm not sure how it survived 10+ years
04:53:02 <cheater99> i think it's the one that actually gets people interested in it
04:53:04 <Ke> if there is no dynmic linkind for arm yet ==> fatal
04:53:06 <kmc> because nobody had a decent multicore implementation until a few years ago, as far as i know
04:53:14 <silver> cheater99, false for me
04:53:15 <kmc> Ke, i already have proof-of-concept working
04:53:18 <Twey> Ke: We survived for years without dynamic linking :Ã¾
04:53:20 <cheater99> you are not people
04:53:30 <silver> part of them
04:53:31 <theorbtwo> Especially relability; haskell is pretty good at writing software that will either work or not compile, and I expect people to be terribly annoyed when their apps crash on them.
04:53:35 <Twey> cheater99: The expressiveness and power of the language itself are far more interesting than parallelism
04:53:38 <cheater99> not a significant enough one
04:53:46 <Twey> Parallelism is just a happy side-effect.
04:53:49 <silver> so collect statistics
04:53:51 <theorbtwo> Until quite recently, multicore wasn't something that many people cared about.
04:53:52 <silver> and you'll see
04:54:05 <kmc> Ke, you don't need dynamic linking of Haskell to Haskell
04:54:12 <cheater99> silver: i can exclude you without losing generality :p
04:54:17 <kmc> that might start to matter if you had lots of Haskell apps on your phone
04:54:19 <theorbtwo> Expressiveness, static typing with a useful type system, those are what drew people to Haskell, largely.
04:54:37 <theorbtwo> Dynamic linking of haskell to the phone's core libraries is probably more important.
04:54:47 <kmc> theorbtwo, the situation on Android is weirder
04:54:51 <kmc> since the platform is natively Java
04:54:55 <kmc> (though not standard JVM)
04:54:59 <kmc> the public APIs are mostly Java-only 
04:55:05 <kmc> and all apps are launched via Java
04:55:05 <theorbtwo> Ah.  Hm.
04:55:10 <kmc> so your Haskell code is a shared library invoked via JNI
04:55:18 <kmc> and which has to make JNI calls back to get stuff done
04:55:32 <Twey> Doesn't that limit portability somewhat?
04:55:33 <theorbtwo> Now it seems like a far more interesting port.
04:55:39 <Twey> Wouldn't it be better to compile to Java bytecode?
04:55:49 <silver> is it possible?
04:55:51 <theorbtwo> Twey: That's OK, it doesn't have to be terribly portable, the point is to make Android apps.
04:55:54 <Ke> Twey: survived as a marginal academic language on the desktop
04:55:55 <kmc> Twey, it would be much slower i suppose
04:56:15 <Twey> No more than people are used to with Java-based Android apps, surely
04:56:16 <kmc> anyway, providing compiled Haskell code as a monolithic .so works in GHC since a long time ago
04:56:22 <wli> If this is the ARM I've heard of it already does, or otherwise the CPU assists somehow by natively executing some JVM instructions or something.
04:56:26 <kmc> though i'm not sure it's officially supported -- some tricks needed
04:56:31 <pastorn> kmc: how about .hs ==> .clj ==> .class ==> .dalvik-lulz?
04:56:39 <SonOfLilit> Say
04:56:39 <SonOfLilit> I want compareFirsts :: (a,b) -> (a,c) -> Ordering
04:56:39 <SonOfLilit> what's the point free way of getting it, if any?
04:56:42 <kmc> wli, i don't know if Dalvik uses that.  it's a totally different VM
04:56:46 <kmc> :t comparing fst
04:56:47 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
04:56:51 <kmc> hmm
04:57:07 <kmc> do you need the more general type
04:57:18 <theorbtwo> wli: I thought so too, until quite recently.  Turns out the java acceleration thingy never worked terribly well; it's not enough faster to be worth it, and was extremely closed-source.
04:57:18 <kmc> pastorn, could do
04:57:27 <Twey> I don't think you can get that (non-trivially)
04:57:37 <Twey> I'm guessing from the name that Ord was intended
04:57:39 <kmc> yeah, you're using fst at two different types
04:57:50 <kmc> so it's not the same fst
04:57:58 <kmc> so any doubling combinator won't work, unless it's higher-rank
04:58:08 <Twey> Oh, wait â the b/c.  Sorry.
04:59:27 <cheater99> there's a good reason or two for java being on phones
05:00:05 <kmc> yeah compiling Haskell to JVM or Dalvik would have better binary portability
05:00:11 <kmc> that's the same on desktops and servers of course
05:00:18 <kmc> personally i think binary portability is overblown
05:20:51 <SonOfLilit> Hello
05:21:03 <kmc> hi
05:21:23 <SonOfLilit> I'm tryig to write a point-free compare for 2-tuples that compares their fsts
05:21:48 <SonOfLilit> compareFsts :: (Ord a) => (a,b) -> (a,c) -> Ordering
05:21:56 <SonOfLilit> is it possible? how can it be written?
05:22:02 <Phyx-> test
05:22:04 <Phyx-> > id 4
05:22:06 <lambdabot>   4
05:22:09 <Phyx-> hmm
05:22:42 <kmc> SonOfLilit, and (Ord a) => (a,b) -> (a,b) -> Ordering is not good enough?
05:23:00 <kmc> @pl \(a,b) (c,d) -> compare a c
05:23:01 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
05:23:15 <kmc> @type (`ap` snd) . (. fst) . (const .) . compare . fst
05:23:15 <lambdabot> forall a a1 b. (Ord a1) => (a1, b) -> (a1, a) -> Ordering
05:23:39 <kmc> :t (const .)
05:23:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> a)
05:26:28 <aristid> :t compare `on` fst
05:26:29 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
05:26:47 <aristid> SonOfLilit: would that be acceptable?
05:27:37 <kmc> :t comparing fst
05:27:38 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
05:27:54 <aristid> @hoogle comparing
05:27:54 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:31:15 <kmc> SonOfLil1t, did you get your answers?
05:31:36 <akosch> "Could not find module `Distribution.Simple' " - isn't that provided by ghc itself?
05:32:02 <ivanm> akosch: no, it's provided by Cabal
05:32:06 <kmc> it's provided by the Cabal package
05:32:10 <kmc> which iirc still ships with GHC
05:32:18 <akosch> ivanm: thx
05:32:26 <kmc> 'This module isn't called "Simple" because it's simple. Far from it. It's called "Simple" because it does complicated things to simple software.'
05:32:27 <kmc> hehe
05:32:29 <ivanm> kmc: right, but if you're adding Cabal deps...
05:32:35 <ivanm> kmc: heh
05:32:47 <ivanm> I thought it was because it was a simplified approach...
05:33:16 <kmc> i think the things that aren't Simple don't end up in Cabal at all...
05:33:20 <kmc> like Gtk until recently
05:33:28 <akosch> hm, cabal package is missing Data.Map
05:34:01 <kmc> that's provided by 'containers'
05:34:26 <akosch> kmc: i've tried installing that one, but it's missing Distribution.Simple :)
05:34:27 <ivanm> kmc: not quite; some packages want more fine grained control for their Setup.hs so they don't use Simple
05:34:40 <ivanm> IIRC, pandoc is one, because it runs the compiled version to build its man pages, etc.
05:34:52 <ivanm> akosch: huh?
05:35:01 <ivanm> akosch: containers ships with GHC; you're not meant to install it yourself
05:35:25 <akosch> ivanm: strange
05:35:26 * FunctorSalad_ thinks cabal should allow unambiguous prefixes of the command name
05:35:31 <FunctorSalad_> cabal i pony etc
05:35:39 <FunctorSalad_> ok that's ambiguous but anyway
05:35:43 <ivanm> FunctorSalad_: heh
05:35:56 <SonOfLil1t> kmc: I didn't
05:36:00 <FunctorSalad_> maybe just hardcoded ones then
05:36:02 <SonOfLil1t> my net connection is horrible today
05:36:13 <FunctorSalad_> (i=install, n=info)
05:36:21 <SonOfLil1t> did you get my question about compareFsts?
05:36:27 <kmc> yes
05:36:35 <kmc> @pl \(a,b) (c,d) -> compare a c
05:36:36 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
05:36:40 <kmc> @type (`ap` snd) . (. fst) . (const .) . compare . fst
05:36:40 <lambdabot> forall a a1 b. (Ord a1) => (a1, b) -> (a1, a) -> Ordering
05:36:47 <kmc> @type comparing fst
05:36:48 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
05:36:53 <kmc> SonOfLil1t, ^^^^
05:37:19 <SonOfLil1t> what's @pl do?
05:37:35 <ivanm> @help pl
05:37:35 <lambdabot> pointless <expr>. Play with pointfree code.
05:37:40 <ivanm> @where pointfree
05:37:40 <lambdabot> I know nothing about pointfree.
05:37:42 <kmc> converts code to 'pointless' i.e. pointsfree code
05:37:44 <ivanm> @where pointless
05:37:45 <lambdabot> I know nothing about pointless.
05:37:49 <ivanm> @google pointfree haskell
05:37:50 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
05:37:50 <lambdabot> Title: Pointfree - HaskellWiki
05:37:52 <ivanm> SonOfLil1t: ^^
05:37:56 <SonOfLil1t> awesome
05:38:07 <SonOfLil1t> @type comparing
05:38:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:38:19 <SonOfLil1t> comparing is what I was missing ;)
05:38:22 <SonOfLil1t> :)*
05:38:40 <SonOfLil1t> @hoogle comparing
05:38:40 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:38:54 <ivanm> @type (compare `on`)
05:38:55 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
05:39:10 <ivanm> ^^ I prefer this variant, especially when I'm also doing ((==) `on`)
05:40:17 <kmc> @type on
05:40:18 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:41:02 <Philonous> I wonder whether it's a good idea to have "class Constr1 c where constr1 :: a -> c a -> c a; deConstr1 :: c a -> Maybe (a , c a)" so I can write my list-functions datatype agnostic. 
05:42:31 <kmc> that only works for things with a list-like shape, yes?
05:42:32 <akosch> ok, reinstalling ghc fixed things
05:43:00 <Philonous> kmc: Yes, especially newtypes of lists (but also stuff like finger trees )
05:43:25 <kmc> yeah
05:43:37 <kmc> okay so it's really not the same problem as SYB
05:43:40 <kmc> there is this ListLike class
05:43:46 <Philonous> Really? 
05:43:46 <kmc> @hoogle ListLike
05:43:46 <lambdabot> No results found
05:43:57 <kmc> http://hackage.haskell.org/package/ListLike
05:44:23 <kmc> also Foldable and Traversable
05:44:44 <Philonous> Oh nice. Why is it, that, whenever I write some helper functions, there is already a full-fledged package for it... 
05:44:53 <SonOfLil1t> @hoogle on
05:44:54 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:44:54 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
05:44:54 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
05:45:07 <Philonous> Yes, but I wanted to work on the first element of the structure.
05:45:25 <Philonous> kmc: Thanks!
05:48:02 <SonOfLil1t> is there a 'minus' for compare?
05:48:27 <SonOfLil1t> i.e. sortBy (minus cmp) == reverse . sortBy cmp
05:48:37 <akosch> what package provides array-0.3.0.0?
05:49:01 <SonOfLil1t> but without the need to evaluate the whole list
05:49:02 <SonOfLil1t> sort*
05:49:10 <Zao> SonOfLil1t: Mapping GT to LT and vice versa?
05:49:11 <xenoblitz> Can someone help me with this type-classes-related error pls? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26372#a26372
05:49:16 <Philonous> @hoogle Ordering -> Ordering
05:49:16 <lambdabot> Prelude pred :: Enum a => a -> a
05:49:16 <lambdabot> Prelude succ :: Enum a => a -> a
05:49:16 <lambdabot> Prelude id :: a -> a
05:50:02 <xenoblitz> Sorry the link is actually http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26372#a26373
05:50:30 <mauke> SonOfLil1t: flip cmp
05:50:56 <kmc> :t (EQ `compare`)
05:50:57 <lambdabot> Ordering -> Ordering
05:51:07 <kmc> > map (EQ `compare`) [LT, EQ, GT]
05:51:08 <lambdabot>   [GT,EQ,LT]
05:52:56 <mauke> > map (toEnum . (fromEnum maxBound -) . fromEnum) [LT, EQ, GT]
05:52:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:52:57 <lambdabot>    `GHC.Enum.Bounded a'
05:52:57 <lambdabot>    ...
05:53:25 <mauke> > map (toEnum . (2 -) . fromEnum) [LT, EQ, GT] :: [Ordering]
05:53:26 <lambdabot>   [GT,EQ,LT]
05:58:07 <SonOfLilit> is there a way to say $^n?
05:58:08 <SonOfLilit> as in, f.f.f.f...f $ args
05:58:08 <SonOfLilit> arg*
05:58:54 <dom1> foldr (.) (repeat f) ?
05:58:55 <Heffalump> @type \n -> foldr (.) id . replicate n
05:58:55 <lambdabot> forall b. Int -> (b -> b) -> b -> b
05:59:12 <mauke> :t \f n -> (!! n) . iterate f
05:59:12 <lambdabot> forall a. (a -> a) -> Int -> a -> a
05:59:33 <Heffalump> mauke's is better
06:00:28 <ivanm> but the types are different!
06:00:31 <ivanm> :p
06:00:47 * ivanm wonders why lambdabot chose b for Heffalump but a for mauke 
06:02:18 <kmc> :t (!!) . iterate
06:02:19 <geheimdienst> lambdabat just messaged me: omg, ivanm is on to me
06:02:19 <lambdabot>     Couldn't match expected type `[a]'
06:02:19 <lambdabot>            against inferred type `a1 -> [a1]'
06:02:19 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
06:02:42 <SonOfLilit> heh
06:03:03 <pielgrzym> I'm really new to haskell, and I've just read http://learnyouahaskell.com/ (which is an awesome tutorial). I'm trying to make such thing: arguments = ["key1", "val1", "key2", "val2"] and convert it into argList = [("key1","val1"), ("key2","val2")] :) I'm quite err, lost ;)
06:03:28 <ople> xmonad.hs:67:166:
06:03:28 <ople>     No instance for (LayoutClass SimplestFloat a)
06:03:28 <ople>       arising from a use of `|||' at xmonad.hs:67:166-206
06:03:28 <ople>     Possible fix:
06:03:28 <ople>       add an instance declaration for (LayoutClass SimplestFloat a)
06:03:28 <ople>     In the second argument of `($)', namely
06:03:28 <ople>         `tiled ||| Full ||| Grid ||| simplestFloat'
06:03:31 <pielgrzym> how can I check for current index in say lamba inside filter function?
06:03:43 <Heffalump> pielgrzym: don't try to check for current index
06:03:56 <Heffalump> well, if you really wanted to, you could use zip [0..] to add indexes to the list
06:04:00 <Heffalump> but in this case that'd be the wrong solution
06:04:11 <Heffalump> write a pattern-matching definition that takes two elements from the list at a time
06:04:39 <pielgrzym> Heffalump: ah, didn't think of that :) thanks :))
06:04:42 <SonOfLilit> pielgrzym: f (a:b:rest) = (a, b): f rest
06:04:57 <pielgrzym> SonOfLilit: hah, damn it was soo easy :D
06:05:01 <SonOfLilit> of course, f [] = []
06:05:11 <kmc> i would say f _ = []
06:05:22 <kmc> to catch the odd case
06:05:28 <SonOfLilit> for some reason, I find it much easier lately to recurse than to iterate - or even fold
06:05:28 <kmc> on the other hand, maybe you want an error if the list has odd length
06:05:58 <Philonous> But having keys and values interleaved in one list seems like a rather brittle approach to begin with
06:06:15 <SonOfLilit> kmc: I think one would always want that to be an error, wouldn't you?
06:06:26 <pielgrzym> Philonous: it's the way cmus it passing stuff for a custom script/app that will display current song playing
06:06:36 <kmc> SonOfLilit, depends.  the zip functions silently cut off excess list
06:06:48 <pielgrzym> Philonous: I could write my implementation in python but I thought it's a nic case to try out haskell
06:06:49 <Philonous> pielgrzym: Yeah, than it can't be helped.
06:07:00 <Philonous> then*
06:07:03 <pielgrzym> :)
06:07:05 <kmc> ople, did you have a question?
06:08:02 <kmc> @pl let f (a:b:xs) = (a,b):xs; f _ = [] in f
06:08:02 <lambdabot> const []
06:08:06 <interferon> maybe not the ideal venue for this question but does anyone have recommendations for software for writing technical books?
06:08:11 <kmc> @pl let f (a:b:xs) = (a,b):xs in f
06:08:11 <lambdabot> ap ((`ap` tail) . (. head) . ((:) .) . (,) . head) tail
06:08:17 <kmc> interferon, LaTeX
06:08:45 <interferon> kmc: do you use raw latex?  or LyX-ish things?
06:08:46 <kmc> and by recommendation i mean de facto standard
06:09:02 <kmc> i use raw latex
06:09:15 <kmc> with a few custom macros
06:09:19 <kmc> but i've never written a book ;P
06:09:55 <kmc> @pl let f ys = case ys of { (a:b:xs) -> (a,b):xs; _ -> [] } in f
06:09:55 <lambdabot> (line 1, column 23):
06:09:55 <lambdabot> unexpected "{"
06:09:55 <lambdabot> expecting variable, "(", operator, ";" or "in"
06:10:34 <kmc> @pl let f ys@(~(a:b:xs)) = if null ys then [] else (a,b): f xs in f
06:10:34 <lambdabot> (line 1, column 9):
06:10:34 <lambdabot> unexpected "@"
06:10:34 <lambdabot> expecting pattern or "="
06:10:42 <interferon> so publishers are generally receptive to latex files?
06:10:43 <kmc> ffs
06:10:54 <kmc> interferon, no idea, but i think it more likely you'd send pdf
06:11:06 <kmc> certainly any competent publisher of technical books would have plenty of authors using latex
06:11:36 <kmc> it's ubiquitous in maths, CS, physics, and some other disciplines
06:11:49 <kmc> now if by technical books you mean AOL 4.0 For Dummies
06:11:51 <kmc> then maybe not
06:12:42 <interferon> :) no aol for dummies
06:15:35 <SonOfLilit> interferon: I don't think you'd send pdf
06:15:44 <Phyx-> aol?
06:17:23 <SonOfLilit> because their graphics guys would definitely want to play with it, and wouldn't feel like retypin everyting just for fun
06:17:23 <SonOfLilit> but they'd all probably be very happy that you use LaTeX, because it is very nice to work with and has a lot of market share in the tech publishing market
06:17:23 <SonOfLilit> (you can open books on the last page, they tend to have a page about how they were typeset)
06:17:39 <SonOfLilit> and it's close enough to ascii that they could easily convert if their system strongly disagrees with LaTeX
06:17:54 <interferon> SonOfLilit: that's a good point about checking existing books
06:18:00 <kmc> er the last part is doubtful
06:18:00 <SonOfLilit> (but they'd probably use something that has an auto-converter)
06:18:07 <kmc> especially if you're using lots of figures etc
06:18:19 <kmc> LaTeX can be arbitrarily complicated; it's Turing-complete
06:18:38 <kmc> i know that a lot of journals accept LaTeX source and reformat according to their stylesheet
06:18:48 <roconnor> @index comparing
06:18:49 <lambdabot> bzzt
06:18:57 <roconnor> @hoogle comparing
06:18:57 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:20:11 <SonOfLilit> usually tech books with that page either say "LaTeX" or "Formmaker"
06:20:11 <SonOfLilit> (I think that's what it is called)
06:20:11 <SonOfLilit> (a mac gui program for typesetting)
06:20:29 <pielgrzym> ok, here goes my dumb definition for the function that would eat a list and crate a list of pairs: pairify :: [[Char]] -> [([Char])]  - does it seem correct?
06:20:54 <mauke> pairify :: [a] -> [(a, a)]
06:21:10 <SonOfLilit> Why not just write String?
06:21:10 <pielgrzym> mauke: I want to be sure they are strings :)
06:21:19 <pielgrzym> ah, didn't know that :D
06:21:24 <mauke> pielgrzym: why?
06:22:03 <SonOfLilit> pielgrzym: you can do that check elsewhere
06:22:12 <pielgrzym> mauke: good question. it just occured to me the arguments taken by the script will always be strings right?
06:22:28 <SonOfLilit> e.g. (pairify arr :: [String, String]) when you call it
06:22:39 <SonOfLilit> right
06:22:41 <pielgrzym> mauke: I mean the argums <- getArgs will always be a list of strings?
06:22:50 <SonOfLilit> :type getArgs
06:22:58 <SonOfLilit> @type getArgs
06:22:59 <lambdabot> Not in scope: `getArgs'
06:23:08 <SonOfLilit> @type getArguments
06:23:09 <lambdabot> Not in scope: `getArguments'
06:23:16 <SonOfLilit> @hoogle getArgs
06:23:16 <lambdabot> System.Environment getArgs :: IO [String]
06:23:23 <SonOfLilit> There you go ^^^^
06:23:25 <pielgrzym> ok, so for the beggining: pairify :: [a] -> [(a, a)] is fine, right?
06:23:27 <SonOfLilit> promised to be strings
06:23:39 <pielgrzym> great :) so no string check then
06:23:41 <SonOfLilit> yes
06:23:53 <mauke> pielgrzym: yes, but why do you want to limit pairify?
06:24:06 <pielgrzym> mauke: now I don't want to ;)
06:24:06 <mauke> it works on any list structure
06:24:40 <pielgrzym> now give me a couple of minutes to boil my brain so I can produce those, errr, like 3 line of code ;)
06:24:58 <pielgrzym> no hint yet, please ;)
06:27:52 <ivanm> geheimdienst: huh?
06:30:21 <SonOfLilit> bbl, delicious food :)
06:31:58 <xenoblitz> hmmm I can't figure out what I'm missing! Damn you type-classes.
06:32:34 <ivanm> xenoblitz: what are you trying to do?
06:32:35 <ManateeLazyCat> For make type-class Foo pass type-check, i build FooWrap : "data FooWrap = forall a . Foo a => FooWrap a". But i need write Wrap for *every* type-class, such as FooWrap, BarWrap, BlaWrap.... So how to define Wrap make it wrap *all* type-class?
06:33:16 <xenoblitz> my code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26372#a26373 I'm getting a complaint of a missing instance but I don't know what to do, or how to define it for that matter
06:34:24 <xenoblitz> I can explain more if needed if its not clear (hope it is)
06:39:24 <nothingmuch> cjs: also, his example is so detached from reality... i mean... wtf? ghc doesn't count? it's about the only compiler project that has actually been aking consistent progress for years that I can think of, isn't that successful?
06:39:37 <HugoDaniel> today i woke up very inspired
06:39:46 <HugoDaniel> inspired to write HASKELL and to change the world
06:40:50 <nothingmuch> world peace plz kthx
06:41:46 <pielgrzym> I know this is wrong, but could someone point me into a right direction: http://wklej.org/id/353177/
06:42:39 <pielgrzym> first question - is this valid: pairify (key:[]) = (key,a):pairify  
06:42:57 <pielgrzym> to put a blank a type inside the tuple it we use a single elem list?
06:43:35 <pielgrzym> so if list = [1] it will return (1,0), for list = ["lala"] it will return ("lala","")?
06:44:31 <xenoblitz> pielgryzm: I am not sure I understand what you wish to do =/
06:44:46 <xenoblitz> sorry *pielgrzym
06:44:53 <burp> [a,b,c,d] -> [(a,b),(c,d)] I think
06:45:15 <pielgrzym> ha! it works!!
06:45:21 <pielgrzym> pairify (key:[]) = (key,key):pairify []
06:45:27 <pielgrzym> pairify (key:val:rest) = (key,val):pairify rest
06:45:38 <pielgrzym> oh, God! this feels like orgasm ;)
06:45:39 <kmc> you can write (key:[]) as [key]
06:45:45 <mauke> pairify [] = []  -- missing
06:45:48 <xenoblitz> i don't think you need the extra pairify []
06:45:59 <pielgrzym> mauke: it was in the paste page :) 
06:46:12 <xenoblitz> pairify (key:[]) = (key,key)
06:46:14 <kmc> and yeah, no reason to call pairify [] when you already know the answer
06:46:23 <pielgrzym> kmc: good point
06:46:24 <kmc> pairify [key] = [(key,key)]
06:46:54 <pielgrzym> and how can I make pairify [key] = [(key, the-null-value-for-the-key-type-here)]
06:47:04 <mauke> pielgrzym: what null value?
06:47:10 <xenoblitz> pielgrzym: yeah made a mistake in that one, what kmc said goes :)
06:47:12 <ivanm> undefined ?
06:47:29 <ivanm> @type \ a -> map (flip (,) a)
06:47:30 <lambdabot> forall a a1. a1 -> [a] -> [(a, a1)]
06:47:30 <burp> do you have a nullable-type class? :>
06:47:30 <pielgrzym> mauke: so if list = [1] it will return (1,0), for list = ["lala"] it will return ("lala","")?
06:47:32 <ivanm> pielgrzym: ^^
06:47:41 <mauke> pielgrzym: what null value?
06:47:43 <ivanm> pielgrzym: there is no such thing in general
06:47:46 <xenoblitz> well you can't if you want it to be polymorphic
06:47:47 <pielgrzym> aah
06:47:47 <ivanm> unless you define a new type class
06:47:48 <pielgrzym> ok
06:48:10 <xenoblitz> yeah you need a typeclass for that
06:48:13 <pielgrzym> mauke: I mean I'd like it to return 0 for numeric types, "" for string/char types
06:48:21 <pielgrzym> now I see it!
06:48:24 <mauke> pielgrzym: and for everything else?
06:48:28 <ivanm> pielgrzym: what would be the default for Char?
06:48:32 <ivanm> '' is not a valid character
06:48:33 <pielgrzym> hmmmmm
06:48:35 <kmc> thank all the gods of history that Haskell does not have "null"
06:48:35 <ivanm> '\0' ?
06:48:35 <pielgrzym> you got me :D
06:48:41 <mauke> your choices are: duplicate the lone element; take another argument to use in that case; drop the lone element; use a typeclass like Default
06:48:41 <ivanm> kmc: sure it does
06:48:43 <ivanm> @type null
06:48:43 <lambdabot> forall a. [a] -> Bool
06:48:44 <ivanm> ;-)
06:48:46 <kmc> hehe
06:48:55 <pielgrzym> :)
06:49:08 <kmc> Monoid also provides a "default" value
06:49:13 <kmc> > mempty :: Int
06:49:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
06:49:14 <lambdabot>    arising from a use of...
06:49:15 * ivanm assumes kmc was referring to \0 on the end of C strings
06:49:17 <kmc> > mempty :: [Char]
06:49:17 <lambdabot>   ""
06:49:36 <kmc> right, it doesn't have it for Int because the answer could be either 0 or 1 depending
06:49:38 <kmc> > mempty :: All
06:49:39 <lambdabot>   All {getAll = True}
06:49:43 <kmc> > mempty :: Sum
06:49:44 <lambdabot>   Ambiguous occurrence `Sum'
06:49:44 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
06:49:57 <kmc> > mempty 'x'
06:49:58 <lambdabot>   ()
06:50:15 <ivanm> :o
06:50:17 <kmc> ???
06:50:19 <Silvah> @instances Monoid
06:50:19 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:50:26 <pielgrzym> stop, you scare me :P
06:50:27 <ivanm> @type mempty 'x'
06:50:28 <mauke> (), (a -> b)
06:50:28 <pielgrzym> hehe
06:50:28 <lambdabot> forall t. (Monoid (Char -> t)) => t
06:50:39 <FunctorSalad_>  @instances? is that reborn?
06:50:43 <ivanm> mauke: yeah, appears to be that
06:50:49 <ivanm> FunctorSalad_: "reborn"?
06:50:49 <FunctorSalad_> or was it just that nobody used it :)
06:50:56 <ivanm> probably that
06:50:57 <FunctorSalad_> thought it had fallen into disrepair
06:51:25 <pielgrzym> but I can't do this: pairify [key] = (key,""):pairify [], since it will conflict with the type, right?
06:51:31 <mauke> pielgrzym: right
06:51:55 <mauke> import Data.Default; ... pairify [key] = (key, def) : []
06:52:18 <pielgrzym> so it wouldn't be such a bad idea to limit funtionst type to [String] -> [(String, String)] and do the  (key, ""), right?
06:52:33 <pielgrzym> mauke: what does default do?
06:52:55 <mauke> how am I supposed to answer that
06:53:58 <pielgrzym> mauke: sorry :P
06:57:22 * ManateeLazyCat pasted "Wrap code" at http://paste2.org/get/883940
06:57:23 <ManateeLazyCat> I have above code, i can use "data Wrap a where Pack :: a -> Wrap a" Pack any instance of type-class, but i can't use "applyWrap :: Wrap a -> (a -> b) -> b", it miss match. How to improve above code to make it works?
06:57:23 <ManateeLazyCat>  
06:59:04 <ManateeLazyCat> Or impossible for my idea?
06:59:43 <ManateeLazyCat> I don't want write too much Wrap define for *every* type-class, i just want *one* Wrap. 
07:00:07 <ivanm> ManateeLazyCat: won't work
07:00:14 <ivanm> you can't create a constructor at the type level
07:00:33 <ivanm> wait...
07:00:49 <ivanm> ManateeLazyCat: why not just use "data Wrap a = Pack {unwrap ::  a} ?
07:00:53 <ivanm> that seems to be what you want
07:01:00 <ivanm> or even just "data Wrap a = Pack a"
07:01:09 <ivanm> are you trying to use a GADT or something?
07:01:21 <Silvah> Identity?
07:02:11 <ManateeLazyCat> ivanm: Example, I have "data PageBufferWrap = forall a . PageBuffer a => PageBufferWrap a" and "data PageViewWrap = forall a . PageView a => PageViewWrap a", and PageBuffer and PageView are type-class, i want build a *AnyWrap* for all type-class, but i mismatch.
07:02:34 <ivanm> ManateeLazyCat: methinks you're mixing up type classes with data types
07:02:43 <kmc> ManateeLazyCat, did you read http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:02:48 <ivanm> you're trying to treat a data type as a type class
07:03:04 <ivanm> ManateeLazyCat: try writing a type class with wrap and unwrap functions
07:03:25 <ivanm> e.g. "class Wrap w where wrap :: a -> w a; unwrap :: w a -> a "
07:03:35 <mauke> that reminds me of Data.Dynamic
07:04:22 <ivanm> mauke: for some reason, that to me sounds like something you can arbitrarily say at almost any point in a Haskell code discussion ;-)
07:04:39 <Twey> Heheh
07:07:29 <ManateeLazyCat> ivanm: Hmmm, "wrap :: a -> w a", but how to write "unwrap :: w a -> a" ? Tyepable.cast ?
07:07:54 <ManateeLazyCat> "wrap :: a -> w a" is easy.
07:08:06 <ivanm> why is unwrap hard?
07:08:49 <triyo> Could someone please help me understand how Parsec optionMaybe function works?
07:08:51 <ManateeLazyCat> ivanm: Wait, i need write some code for test your solution. 
07:09:27 <mauke> :t Text.Parsec.optionMaybe
07:09:28 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m (Maybe a)
07:09:39 <triyo> I have something like this... everythingBeforeDblColon <- optionMaybe (manyTill anyChar $ string "::")
07:09:54 <ivanm> triyo: it will try to parse it; if it fails it rolls back and returns Nothing
07:10:01 <ivanm> if it succeeds, it returns Just value
07:10:10 <triyo> I still get a Either Left (err) result and not a Maybe
07:10:12 <ivanm> @src optionMaybe
07:10:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:10:25 <dancor> note that it will return Nothing on "a:b::"
07:10:28 <ivanm> triyo: when you run the overall parser, maybe
07:10:47 <ivanm> triyo: but inside the actual Parsec monad, it will be Maybe, not Either
07:10:49 <mauke> dancor: whoa, why?
07:11:13 <ivanm> mauke: insufficient backtracking? *shrug*
07:11:22 * ivanm points out that in polyparse it would work... :p
07:11:42 <dancor> let me cehck
07:12:12 <mauke> optionMaybe (try (manyTill anyChar (try (string "::"))))
07:12:57 <dancor> > parse (optionMaybe . manyTill anyChar $ string "::") "." "a:b::c"
07:12:58 <lambdabot>   Not in scope: `parse'Not in scope: `optionMaybe'Not in scope: `manyTill'Not...
07:13:16 <triyo> mauke: I could have sworn I tried the try function and it didnt work, but it works now... thx 
07:13:19 <dancor> mauke: because (string "::") will start to consume the single ":" and then fail
07:14:08 <triyo> the try actually does make it work 100%
07:14:26 <triyo> combined with the optionMaybe
07:14:42 <ivanm> in polyparse, you get try for free!
07:14:51 <dancor> yes: parse (optionMaybe . manyTill anyChar . try $ string "::") "." "a:b::c"
07:14:58 <mauke> ivanm: how do I do <|> in polyparse?
07:15:04 <ivanm> what does that do?
07:15:12 <ivanm> @type (<|>)
07:15:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
07:15:16 <ivanm> ahhh
07:15:19 <ivanm> f `onFail` g
07:15:28 <mauke> a <|> b tries a first; if it fails without consuming any input, it does b
07:15:39 <ivanm> there's also oneOf
07:16:15 <mauke> if onFail is <|>, how do I do (try a <|> b)?
07:16:35 <ivanm> oh, wait
07:16:37 <triyo> ivanm: thanks, point taken about polyparse... I'm still learning haskell and parsec seems to be the most covered one on books, tutorials, etc.
07:16:46 <ivanm> to get the exact same behaviour, you have to do something like this: commit f `onFail` g
07:17:14 <ivanm> triyo: yeah
07:18:08 <ivanm> triyo: but I found polyparse quite nice; it's rather simplistic in that there are fewer built-ins, but you have currently 3 different parsers available, two of which are almost drop-in replacements for each other (the only difference is the output when you run the parser)
07:18:37 <ivanm> see the parageraph beginning with "If you are familiar" here: http://www.cs.york.ac.uk/fp/polyparse/#how
07:18:48 <triyo> cool, thx for the link
07:19:18 <ivanm> I use polyparse for graphviz (mainly because I inherited it already using polyparse); however, I much prefer it because i _have_ to do a lot of backtracking, etc.
07:20:05 <ivanm> even as something as simple as thinking that "if you have an opening bracket, then you must have a closing bracket"; I've had to override the default behaviour of polyparse because I needed even more backtracking capabilities because of what could be _inside_ the brackets
07:20:23 <ivanm> (and I could do alternate parsers for the inside, because the structure they represent are completely different)
07:20:35 <Philonous> I want to build an interface for Streams that are mergable (merge :: Ord a => s a -> s a -> s a),  should I rather user newtype wrappers for the relevant types (e.g. [a]) and write a Monoid instance or make a new class? 
07:21:55 <ManateeLazyCat> ivanm: I can't understand "class Wrap w where wrap :: a -> w a; unwrap :: w a -> a " how to help with my problem. 
07:22:40 <ivanm> ManateeLazyCat: you're currently trying to do "(Pack a) = f a"; instead, use "f . unwrap"
07:23:52 <Philonous> Ah never mind, newtypes it is
07:24:20 <ManateeLazyCat> ivanm: I have a bit confusion how to write "instance AnyWrap PageBuffer where" since PageBuffer is class....  
07:24:36 <ivanm> ManateeLazyCat: PageBuffer is a _class_ ?
07:24:42 <ivanm> I thought you said it was a data structure
07:24:44 <ManateeLazyCat> ivanm: yes.
07:24:59 <ivanm> and you can't make classes instances of another class!
07:25:04 <ManateeLazyCat> ivanm: "class Typeable a => PageBuffer a where" and "data PageBufferWrap = forall a . PageBuffer a => PageBufferWrap a"
07:25:32 <ManateeLazyCat> ivanm: Yes, that's why i'm confusion with your "class Wrap ..."
07:25:55 <ivanm> well, you were trying to write a data structure as a class...
07:26:08 <ivanm> since you had something like "data Wrap a where Pack :: a -> Wrap a"
07:26:17 <ivanm> unless you were trying to use a GADT, that isn't valid
07:27:23 <ManateeLazyCat> ivanm: In http://paste2.org/get/883940 , Pack is ok, but pageViewGetBufferWrap should return "forall a . PageBuffer a => IO (Wrap a)"
07:27:56 <ivanm> ManateeLazyCat: are you using GADTs?
07:28:00 <ManateeLazyCat> ivanm: Yes.
07:28:08 <ivanm> then why didn't you say so? :p
07:28:22 * ivanm has no idea how to use GADTs...
07:28:44 <ManateeLazyCat> ivanm: I suppose you has know that since you saw the define "data Wrap a where Pack :: a -> Wrap a"
07:28:44 <ManateeLazyCat>  
07:28:46 <ManateeLazyCat> :)
07:30:06 <ivanm> ManateeLazyCat: right, but I asked that a few times already and you said nothing ;-)
07:30:15 <ivanm> hence why I thought you were trying to write a class
07:30:21 <ManateeLazyCat> ivanm: Ok, my fault. 
07:30:43 <ManateeLazyCat> ivanm: compiler is confusion when i do "applyWrap :: Wrap a -> (a -> b) -> b"
07:31:22 <ivanm> ManateeLazyCat: I've never used GADTs, but can you do pattern matching on one like that?
07:31:52 <EvanR> is there an algorithm that simulates arrays with O(1) lookup? im trying to understand how necessary hardware support here is
07:32:29 <Heffalump> EvanR: I don't understand your question
07:32:44 <Grey_Fox> EvanR: I think the word you're looking for is data structure.
07:32:57 <EvanR> i would like to define a data type which is an array of N values. the operation is to take an index and get the value with O(1)
07:33:21 <SockPupMex> If you are looking for some hot black vagina after you get done with some haskell programming
07:33:25 <SockPupMex> look no farther
07:33:25 <EvanR> Grey_Fox: well i was thinking of lambda calculus
07:33:26 <Twey> Don't *think* that's possibleâ¦ but hey, what do I know âº
07:33:26 <SockPupMex> http://www.blackvaginafinder.com/
07:33:48 <ManateeLazyCat> ivanm: My idea is, use "Pack" wrap PageBuffer instance to Wrap, example "wrapPageBufferInstance :: forall b . PageBuffer b => IO (Wrap b)"
07:34:18 <EvanR> Twey: so arrays are 'cheating' ?
07:34:22 <ManateeLazyCat> ivanm: Such as "pageViewGetBufferWrap" in http://paste2.org/get/883940 , since pageViewGetClient return "IO (Wrap b)"
07:34:29 <Twey> EvanR: In a manner of speakingâ¦
07:34:40 <EvanR> if that is possible then how useful is our model of computation
07:34:41 <SockPupMex> the only thing is that black vagina is more likely to rot and or smell bad
07:34:44 <EvanR> is it grounded in reality
07:34:49 <ManateeLazyCat> ivanm: I was think i can use "applyWrap :: Wrap a -> (a -> b) -> b" with "(a -> b)" to apply (Wrap a)
07:34:52 <SockPupMex> as negroes have a little bit of trouble with vitamin d
07:34:57 <SockPupMex> and metabolism related to it
07:35:09 <SockPupMex> it makes that ghetto cooch a vertitable petri dish
07:35:26 <Ke> unexpected spambot
07:35:28 <fryguybob> @where ops
07:35:28 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
07:35:30 <Twey> EvanR: It's grounded in reality more than the imperative model, which is grounded in hardware
07:35:37 <SockPupMex> more proof that Haskell programers should watch out and not commit beastiality
07:35:37 <ivanm> ManateeLazyCat: well, I have no idea
07:35:40 <ivanm> sorry
07:35:42 <SockPupMex> with these africoons
07:35:55 --- mode: ChanServ set +o mauke
07:35:55 --- kick: SockPupMex was kicked by mauke (SockPupMex)
07:35:55 --- mode: mauke set +b *!*@189.214.151.190.cable.dyn.cableonline.com.mx
07:35:57 <ManateeLazyCat> ivanm: Never mind, maybe compiler can't understand my idea. :)
07:36:05 <EvanR> Twey: Grey_Fox: also i have to put more limitations, otherwise you can just have index values which are paired with values, they key concern really is being able to add a number to an index and get that other index
07:36:18 <ivanm> mauke: thanks
07:36:28 <EvanR> equivalently, add indexes
07:36:41 <FunctorSalad_> is it possible to become root in a running ghc program?
07:36:52 <Twey> EvanR: Ord key => [(key, val)] doesn't give O(1) lookupâ¦
07:36:55 <FunctorSalad_> or do you have to su a copy of yourself
07:37:09 <EvanR> Twey: no, but if you have the index, you could define lookup as doing snd on it
07:37:38 <ivanm> FunctorSalad_: don't think it's possible without su or sudo being run inside the app
07:37:43 <ManateeLazyCat> My idea simple is "Wrap class instance 'a' to 'Wrap a', then use class methods '(a -> b)' to apply 'Wrap a' "
07:37:45 <EvanR> also equivalently, given the array and a number, you get an value
07:37:52 <Twey> EvanR: Oh, containing the value within the index?
07:37:53 <FunctorSalad_> (tbh I don't know if it's possible in linux at all)
07:37:55 --- mode: mauke set -o mauke
07:38:00 <jedai> Ok, I'm lost here, there must be something I fundamentally don't understand about shells... I'm trying to get darcs to use emacs and not vi so I set EDITOR in .zshrc and source it, check $EDITOR is set to the right value with echo then start darcs record... and get vi
07:38:07 <FunctorSalad_> ivanm: ok... why not
07:38:10 <EvanR> Twey: yes, if the array is just a set of index value pairs
07:38:12 <EvanR> then its trivial
07:38:13 <FunctorSalad_> (I mean "why not do it" :))
07:38:16 <EvanR> but you cant do index arithmetic
07:38:26 <Twey> Well, you can
07:38:27 <ivanm> FunctorSalad_: because how else are you going to automagically get root privileges?
07:38:36 <Twey> succ . fst
07:38:39 <Philonous> FunctorSalad_: setuid?
07:38:48 <jedai> But then if I try > EDITOR='emacs -nw' darcs record, it works what is the difference between those two situations ?
07:38:53 <EvanR> Twey: but that doesnt give you the next pair
07:39:02 <ManateeLazyCat> jedai: Try set EDITOR to emacsclient.
07:39:14 <Twey> jedai: Did you forget to use âexportâ in your .zshrc?
07:39:33 <Twey> Merely setting the value won't propagate it to launched processes
07:39:58 <Twey> You need to âexport EDITOR='emacsclient -nw'â
07:40:10 <Twey> Or else âEDITOR='emacsclient -nw'; export EDITORâ
07:40:33 <FunctorSalad_> Philonous: hmm the program is supposed to be ran by users (read: me) who have an active sudo-root ticket... so in principle it should be ran as root (not through setuid) in the first place, I just want to include the sudo wrapper ;)
07:40:41 <ManateeLazyCat> jedai: Use emacsclient, you don't need start new Emacs when you do darcs record.
07:41:04 <Twey> (âemacsclient -c -nwâ behaves a bit more like âemacs -nwâ)
07:41:52 <FunctorSalad_> reading $0 is the way to go for that I assume
07:41:54 <jedai> Twey: Oh yes, I always forgot that (I had just changed a bunch of variables that shouldn't get exported), thanks :)
07:41:58 <FunctorSalad_> (to know yourself)
07:42:16 <FunctorSalad_> or getProgName or what it's called in the hs lib
07:42:17 <jedai> ManateeLazyCat: Thank you for the suggestion, I'll do that (with Twey twist on it)
07:42:51 <ManateeLazyCat> jedai You need add "(server-start)" in your .emacs when you want use emacsclient 
07:43:22 <jedai> ManateeLazyCat: That I know ;)
07:43:24 <ManateeLazyCat> jedai: Then every time you use emacsclient, it will lookup for running emacs server to avoid lauch new emacs.
07:44:05 <jedai> ManateeLazyCat: I just very rarely reconfigure my shell rc and recently got a new computer
07:44:24 <FunctorSalad_> it's a bit tricky to always keep a hidden emacs frame running ot1h, but not "lose" possibly unsaved data in invisible instances otoh
07:44:39 <ivanm> ManateeLazyCat: there's also emacs daemon...
07:44:55 <FunctorSalad_> maybe one should write a function that instead of quitting, insists that all buffers are closed and then hides the frame
07:45:08 <FunctorSalad_> ivanm: screwed up the gtk settings for me :p
07:45:10 <Twey> jedai: My $EDITOR is 'emacsclient -c -nw --alternate-editor="emacs -nw"'
07:45:21 <Twey> So if there's no running emacs instance, it'll create one
07:45:40 <ivanm> FunctorSalad_: :o
07:45:42 <ManateeLazyCat> jedai: Like Twey's smart EDITOR, that's better. :)
07:45:52 <FunctorSalad_> ivanm: I mean in the emacs, not systemwide
07:45:56 <ivanm> eh, I use nano for $EDITOR
07:45:57 <FunctorSalad_> (wrong UI theme)
07:46:00 <ivanm> FunctorSalad_: ahhh
07:46:03 <jedai> That's pretty nifty :)
07:46:15 <ivanm> FunctorSalad_: I had something similar; had to make sure it didn't get started till after X started or something like that IIRC
07:46:20 <jedai> b
07:46:37 <aristid> Twey: do you also have an environment variable for an X11 editor
07:46:39 <aristid> ?
07:46:39 <ManateeLazyCat> ivanm: I just open one emacs and do everything in it, just so angry when Emacs crash. ;-)
07:46:47 <Twey> FunctorSalad_: I have to do âXMODIFIERS='' emacs --daemonâ
07:47:07 <Twey> If I want to use emacs in X
07:47:09 <FunctorSalad_> Twey: ivanm : hmm, iirc I just started emacs --daemon from a konsole
07:47:12 <Twey> (though I rarely do)
07:47:17 <FunctorSalad_> (running in X obviously)
07:47:34 <ivanm> FunctorSalad_: well, in gentoo there's an init script for it
07:47:40 <Twey> aristid: I don't generally edit in X, but you can just remove both â-nwâs there to get a graphical emacs
07:47:51 <ivanm> (there are some problems with it, mainly because gnus doesn't like desktop-mode :s)
07:48:02 * ManateeLazyCat Emacs's dynamic binding make it not safe enough....
07:48:06 <aristid> Twey: i guess it would be an improvement over the stupid nano default :D
07:48:24 <ManateeLazyCat> ivanm: I have better code than desktop-mode.
07:48:51 <ManateeLazyCat> ivanm: windows.el and revive.el
07:49:10 <Twey> aristid: It falls back to emacs -nw if there's no DISPLAY anyway.
07:49:13 * ManateeLazyCat pasted "save/restore windows layout." at http://paste2.org/get/883990
07:49:33 <ManateeLazyCat> ivanm: Looks above.
07:49:38 * ManateeLazyCat pasted "windows.el" at http://paste2.org/get/883991
07:49:47 * ManateeLazyCat pasted "revive.el" at http://paste2.org/get/883992
07:49:52 <ivanm> might have a look at them later on
07:50:04 <ivanm> it's time I went to the land of nod
07:50:05 <ivanm> g'night all
07:52:01 <ManateeLazyCat> ivanm: You don't need lookup those .el file, i have add in link.
07:52:40 <ManateeLazyCat> ivanm: Smarter than desktop-mode, configuration file at http://paste2.org/get/883990
07:56:46 <ManateeLazyCat> Looks it's impossible wrap *any* type-class instance and unpack instance without Typeable something....
07:57:56 <ManateeLazyCat> But it's ok that write new Wrap type for every type-class, like my current code "FooWrap for Foo class, BarWrap for Bar class, BlaWrap for Bla class".... 
07:58:08 <aristid> ivanm: why do you use nano? oO
07:58:30 <aristid> oh, he's gone
07:58:33 <ManateeLazyCat> aristid: ivanm has sleeping . :)
07:58:49 <aristid> ManateeLazyCat: yes, i noticed too late
07:59:23 <ManateeLazyCat> aristid: Let lambdabot leave message to him. :)
08:00:36 <aristid> ManateeLazyCat: not so important
08:01:33 <ManateeLazyCat> I also have to go, bye all. :)
08:11:28 <soupdragon> does anyone else do physics simulation in haskell
08:11:29 <soupdragon> ?
08:15:34 <aristid> soupdragon: anyone else? you are doing it?
08:15:48 <soupdragon> yeah
08:16:55 <Feuerbach> soupdragon: have you seen hpysics?
08:17:00 <soupdragon> ye
08:17:01 <soupdragon> yes
08:17:07 <ClaudiusMaximus> soupdragon: i did one thing with elastic collisions http://claudiusmaximus.goto10.org/cm/2010-03-12_bowntz.html
08:17:13 <Feuerbach> it's abandoned though
08:17:31 <soupdragon> ClaudiusMaximus: cool!
08:18:08 <soupdragon> I like the sound
08:18:17 <SonOfLilit> hi
08:19:18 <soupdragon> is Andrew Coppin ?
08:19:20 <soupdragon> here
08:19:45 <soupdragon> arst
08:22:49 <dancor> is there a func to search PATH for a binary?  not sure what modules to look in..
08:23:10 <pastorn> @hoogle getEnv
08:23:10 <lambdabot> System.Environment getEnv :: String -> IO String
08:23:10 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
08:23:29 <pastorn> dancor: was that what you were looking for?
08:23:30 <dancor> pastorn: but i would have to write the logic to search
08:23:37 <pastorn> dancor: yeah...
08:23:42 <pastorn> @hoogle directory
08:23:42 <lambdabot> package directory
08:23:42 <lambdabot> module System.Directory
08:23:42 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
08:23:43 <dancor> i was wondering if someone had already
08:23:55 <pastorn> oh... there's a 'getDirectoryContents' or similar somewhere
08:24:20 <jmcarthur> ugh, the OpenGL package lacks a lot little things
08:24:24 <soupdragon> ClaudiusMaximus: I like this music Cathedral_Algorithms
08:24:37 <Phyx-> > (\(f::(forall a. a -> a)) -> (f 1, f "hello")) id
08:24:38 <lambdabot>   (1,"hello")
08:24:49 <pastorn> dancor: it's not that hard... just use getDirectoryContents or whatever, then just 'map (elem whatImLookingFor) dirContents'
08:24:50 <dancor> oh i solved my problem a different way
08:24:53 <dancor> ok
08:24:54 <SonOfLilit> sdf
08:25:00 <jmcarthur> e.g. no way to set a scalar uniform unless you do something ugly like make it a 1D texture coordinate even if it has nothing to do with textures
08:25:01 <pastorn> dancor: not exactly, but anyway
08:25:04 <Phyx-> :t (\(f::(forall a. a -> a)) -> (f 1, f "hello")) 
08:25:05 <dancor> right
08:25:05 <lambdabot> forall t. (Num t) => (forall a. a -> a) -> (t, [Char])
08:25:27 <pastorn> jmcarthur: you wanna set Matrix as uniforms?
08:25:36 <jmcarthur> pastorn: what?
08:25:49 <pastorn> just setting a uniform is easy (almost)
08:26:03 <jmcarthur> i'm not complaining about ease
08:26:08 <jmcarthur> i'm complaining about completeness
08:26:19 <pastorn> jmcarthur: ah... well, you'll need OpenGLRaw
08:26:22 <jmcarthur> yeah
08:26:28 <pastorn> and in some cases you need to do unsafeCoerce
08:26:34 <pastorn> (i did when i was playing with it)
08:26:36 <jmcarthur> but i just mean little things. like there are missing type class instances and stuff
08:26:50 <pastorn> jmcarthur: yeah, i know
08:27:00 <jmcarthur> no unsafeCoerce. i'd rather just fix OpenGL
08:27:14 <jmcarthur> which i'm doing as i see issues arise, i guess
08:27:19 <pastorn> jmcarthur: do whatever you need to do and just make a list of the missing stuff
08:27:30 <jmcarthur> i'll do one better. i'll make patches ;)
08:27:39 <ClaudiusMaximus> soupdragon: thanks
08:28:11 <pastorn> well, i couldn't do that, i'd rather just work around everything, to completely see all the aspects of the missingness
08:28:46 <jmcarthur> i really doubt a patch for one issue is going to fix other unrelated issues
08:28:57 <Riviera> wt7
08:29:03 <Riviera> sorry :/
08:32:12 <Athas> Is the full POSIX API wrapped in some set of Haskell libraries?
08:33:09 <Peaker> When I tried toying with RankN types some (for use of ST, actually), I encountered weird type problems (e.g: A difference between  (f . g) x  and f (g x)).  People here said it is because a type variable cannot capture a polytype. Doesn't this mean Rank2/RankN types are not really practical?
08:33:25 <Peaker> Or are there good-enough workarounds/proposed solutions for these kinds of problems?
08:33:34 <ksf> openNonBlocking <> openWrite <> openCreate <> openAppend
08:33:52 <ksf> that's the nice part. the ugly part is the insane amount of boilerplate necessary to get that interface.
08:34:05 <ksf> (where <> is mappend)
08:34:36 <Peaker> why not    open (NB <> W <> C <> A)?
08:36:04 <ksf> because that'd requrire hennigisms.
08:36:12 <ksf> *henningisms
08:37:21 <aavogt> Peaker: what's wrong with the workaround of using () instead of . $ ?
08:37:54 <Feuerbach> Athas: there's "unix" package. I am not sure how full it is. Do you miss something concrete?
08:37:56 <aavogt> if you want functions to combine those higher rank polymorphic functions/values  you need to give a type signature
08:38:16 <Peaker> aavogt, Breaks the whole idea of capturing code re-use with functions like (.). This problem isn't limited to (.)
08:38:28 <ksf> Athas, depending on what you call "The POSIX api", yes.
08:38:34 <Peaker> aavogt, Using () instead of (.) is basically duplicating (.)s code at the caller
08:38:54 <aavogt> well apparently you can't have both
08:39:08 <aavogt> in terms of type inference for higher rank polymorphism
08:39:12 <Peaker> Both code re-use and Rank-* types? :)
08:39:26 <Peaker> aavogt, Would this really work if the types were specified explicitly?
08:39:33 <Peaker> It doesn't seem like a type-inference problem
08:39:34 <aavogt> yes, but that's not practical
08:40:00 <ksf> and then there's c2hs which insists on mapping enums to the Enum class, which is bad
08:40:08 <ksf> ...I've got CInt, CLong etc, not Int.
08:40:49 <geheimdienst> http://www.total-knowledge.com/~ilya/mips/ugt.html
08:40:50 <Peaker> @type (.)
08:40:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:40:57 <geheimdienst> sorry, wrong channel :-(
08:40:59 <Peaker> aavogt, How can I even specify the type of (.) with the "b" in the type being a polytype? I can't use forall to do this
08:41:05 <jmcarthur> pastorn: do you know if the OpenGL package supports multitexturing? or do i need to use OpenGLRaw for that?
08:41:15 <pielgrzym> createText pair:rest = if (fst pair) == (snd pair) then (...) - whats wrong with this line? how can I compare assuming the function has type createText :: [(a, a)] -> String ?
08:41:42 <Athas> Feuerbach: well, something like posix_openpt and ptsname.
08:41:47 <Athas> (Generally, the tty stuff.)
08:42:01 <Peaker> pielgrzym, The precedence of function application ("createText pair") is higher than that of infix ("pair:rest")
08:42:08 <Peaker> pielgrzym, you have to use: createText (pair:rest) = ..
08:42:10 <aavogt> Peaker: you can say    (.) :: (forall b. Num b => b -> c) -> (forall b. Num b => a -> b) -> a -> c
08:42:22 <Peaker> pielgrzym, Also, you can say: createText (x, y):rest = ...
08:42:25 <Peaker> pielgrzym, instead of using fst/snd
08:42:46 <jmcarthur> pastorn: n/m i found it
08:42:48 <aavogt> but maybe that requires a separate definition of (.)
08:42:50 <pielgrzym> Peaker: aaaah
08:42:54 <Peaker> aavogt, I don't think that would work, these aren't the same "b"s there
08:43:09 <aavogt> Peaker: they are both any instance of Num
08:43:24 <jmcarthur> why the hell is activeTexture in Graphics.Rendering.OpenGL.GL.CoordTrans
08:43:25 <aavogt> ex. created with fromIntegral
08:43:42 <ksf> .o( ... )
08:43:44 <Peaker> aavogt, I guess you could write a specific (.) that can translate between different Num types
08:43:50 <ksf> O_RDONLY is defined to 0, here.
08:43:55 <Peaker> aavogt, but it'd be specific to Num in more than just the specialized type signature
08:44:03 <Peaker> @type (.) :: (forall b. Num b => b -> c) -> (forall b. Num b => a -> b) -> a -> c
08:44:04 <lambdabot>     Couldn't match expected type `forall b. (Num b) => b -> c'
08:44:04 <lambdabot>            against inferred type `a -> b'
08:44:04 <lambdabot>     In the expression:
08:44:17 <ksf> which inevitably makes it a member of every flagset passed to open, which kinda defies the term "read_only_"
08:44:50 <aavogt> I can see TH or another preprocessor generating these somewhat sensibly
08:44:50 <Peaker> aavogt, It's really not (.) if there's a fromInteger . toInteger  in there
08:45:15 <Peaker> aavogt, or do you mean without fromInteger/toInteger? Because if you don't do that, then the Num instance doesn't help you
08:45:18 <ksf> ...they actually mixed an enumeration and bitmask in the same bitfield.
08:45:38 <aavogt> Peaker: I mean this is defined as regular function composition
08:46:05 <Peaker> aavogt, then it won't work, those aren't the same "b"s, might as well write forall b1. ... in one place, and forall b2. ... in another
08:46:40 <Peaker> @let (.) :: (forall b2. b2 -> c) -> (forall b1. a -> b1) -> a -> c ; (f . g) x = f (g x) 
08:46:41 <lambdabot>   TypeOperators is not enabled
08:46:50 <aavogt> Peaker: I know they are different
08:46:55 <aavogt> but they are both Num
08:46:59 <Peaker> @type let (.) :: (forall b2. b2 -> c) -> (forall b1. a -> b1) -> a -> c ; (f . g) x = f (g x) in (.)
08:47:00 <lambdabot> forall c a. (forall b2. b2 -> c) -> (forall b1. a -> b1) -> a -> c
08:47:04 <aavogt> which means you can go from one to the other
08:47:10 <aavogt> *any Num
08:47:18 <Peaker> aavogt, why does the Num instance help?
08:47:33 <Peaker> aavogt, if we're using regular composition (ignoring Num methods)
08:47:39 <aavogt> because you're only allowed to use methods in Num
08:48:23 <aavogt> this is composition restricted to polymorphic types restricted to Num only
08:48:35 <Peaker> I see -- I don't think this is the right solution here though
08:48:48 <aavogt> right, just use parens instead
08:49:06 <Peaker> aavogt, I translate that to "Just duplicate (.)s code everywhere you use it" :)
08:49:19 <Peaker> (.) happens to be simple, but this happens with other functions too
08:49:40 <aavogt> right, and for those functions you have the alternative I suggested
08:50:07 <aavogt> where the function is more restricted, but at least you don't need any signatures at the caller
08:50:23 <Peaker> :-(  Is there any proposal on how to solve this correctly in the future?
08:51:26 <aavogt> as I understand it, it's a type inference problem
08:52:59 <Peaker> aavogt, It doesn't seem so to me.. Because even with explicit type signatures everywhere, you can't really make general functions that work with polytypes
08:53:14 <Peaker> as they would work if their code was duplicated to where the polytype is
08:53:40 <aavogt> there's a restriction there to make type inference work?
08:53:59 * aavogt is only hypothesizing
08:54:33 * ksf never liked the gnu libc, and it's getting worse and worse.
08:54:39 <Peaker> A class restriction? I don't think classes are (or should be) involved
08:54:39 <aavogt> it'd be better to discuss how these things actually work with somebody like edwardk
09:06:47 <ksf> does anybody want to learn template haskell?
09:07:38 <Axman6> i do... 
09:07:51 <Axman6> but not for another week, once i finish exams
09:07:51 <ksf> that's great, I've got the perfect exercise for that.
09:07:57 <ksf> no worries.
09:10:43 <Axman6> ksf: what's the exercise anyway?
09:11:36 <soupdragon> This binary star system shows the approximate time reversibility of gravity http://pastie.org/1011504.txt
09:11:54 <geheimdienst> O RLY
09:12:21 <soupdragon> also it explodes at the end
09:13:03 <ksf> Axman6, generating such stuff: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26375#a26375 
09:13:10 <ksf> ...modulo the c2hs stuff.
09:14:05 <ksf> if the C enum is sane, those functions and the instance should be competely defined by it.
09:14:29 <ksf> ...including all names, modulo the BitSet type, but that's an ugly spot in c2hs, anyway.
09:14:47 <Axman6> bleh, show me tomorrow, browser +  a VM isn't a good mix
09:14:58 <wli> soupdragon: More symplectic integration?
09:15:01 <_Cactus_> ksf: hmm.. I might want to take a shot at this sometimes next week
09:15:34 <soupdragon> wli well it's the same stuff - I still don't know what went wrong with the double pendulum
09:15:38 <soupdragon> gravity seems to work okay though
09:15:52 <soupdragon> the 'idle' procedure is very neat imo
09:16:56 <ksf> _Cactus_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26375#a26376   is the module that belongs to the code
09:17:44 <_Cactus_> and what's the input to the generator?
09:17:47 <wli> soupdragon: I think there are conservation issues.
09:17:53 <SonOfLilit> Hello
09:17:54 <_Cactus_> ksf: a C .h?
09:18:02 <ksf> if you both want to do it, we're going to have a fight to the death.
09:18:08 <Phyx-> lol
09:18:11 <ksf> yes
09:18:19 <ksf> or rather an Enum instance
09:18:22 <wli> soupdragon: Like mgy isn't a conservative field.
09:18:27 <soupdragon> hm
09:19:03 <_Cactus_> ksf: oic so only the bottom half of the file woudl have to be generated
09:19:07 <_Cactus_> the upper half is written by hand
09:19:13 <ksf> yes
09:19:28 <soupdragon> I wonder if that is the rpbolem!
09:19:44 <ksf> I don't think it's possible to splice into .chs files, anyway.
09:19:47 <wli> soupdragon: I think things may need to be based on Lie symmetries of the ODE or something.
09:20:02 <SonOfLilit> I'm trying to debug my program
09:20:40 <wli> soupdragon: The pendulum sort of treats gravity like an external driving force.
09:20:48 <SonOfLilit> there is an exception (invalid index in array) and I want to know what are the parameters of some function that gets called in the call stack leading to this exception
09:20:52 <SonOfLilit> how do I do that?
09:22:04 <Axman6> try Debug.Trace
09:22:14 <Axman6> :t Debug.Trace.trace
09:22:14 <lambdabot> forall a. String -> a -> a
09:22:32 <SonOfLilit> I'd really rather use the debugger
09:22:35 <soupdragon> but the single pendulum seemed to work
09:22:54 <wli> soupdragon: Maybe it'd come out better if it were done like Newtonian gravity (e.g. binary stars) except modelling a tiny pendulum on the surface of a huge spherical body so the field is nice and conservative.
09:23:11 <Axman6> what is with people wanting to use the debugger all of a sudden? no one uses the debugger
09:23:33 <Peaker> I wish I could use a Haskell debugger.. many times :(
09:23:33 <soupdragon> hey edwardk I used your differentiation for hamiltonian :(
09:23:55 <soupdragon> the idle procedure http://pastie.org/1011504.txt
09:23:57 <soupdragon> it's neat
09:26:04 <SonOfLilit> Axman6: because recompiling the code sucks. And inserting trace statements sucks more, they are very "interruptive" and you need to change all your code around them
09:26:27 <ski> edwardk : SYN ACK
09:27:08 <silver> I use debugger :S
09:27:50 <SonOfLilit> (in ruby, I once implemented a trace statement that didn't interrupt almost anything: class Kernel; def p!(msg) print msg + ": " + self; self; end; end. It was possible to stick it anywhere without modifying the surrounding expressions, which made it awesome for debugging)
09:28:09 <SonOfLilit> silver: so do you know the answer to my question?
09:28:10 <ksf> trace does the same
09:28:26 <SonOfLilit> ksf: but you have to change everything around it
09:28:31 <ksf> ...except if you want to output data, that has to be an instance of show or something of course
09:28:39 <ksf> define "everything"
09:28:47 <SonOfLilit> @type trace
09:28:48 <lambdabot> Not in scope: `trace'
09:28:54 <soupdragon> trace = id
09:28:55 <ksf> :t Debug.Trace.trace
09:28:57 <lambdabot> forall a. String -> a -> a
09:29:00 <soupdragon> doh
09:29:26 <SonOfLilit> mm
09:29:36 <ksf> foo x = x * x --> foo x = trace "foo" x * x
09:29:37 <SonOfLilit> I might have been using it wrong (by adding a message)
09:30:24 <Axman6> SonOfLilit: trace is just: trace msg x = unsafePerformIO (purStrLn str >> return x)
09:30:25 <SonOfLilit> oh, no
09:30:25 <SonOfLilit> that is exactly what I mean
09:30:25 <SonOfLilit> what if you want to trace x*x?
09:30:25 <SonOfLilit> you need to:
09:30:35 <ski>   foo x = trace "foo" $ x * x
09:30:37 <ksf> trace' x = trace (show x) x is usefull, too.
09:30:53 <soupdragon> trace "foo" $ x * x = trace "foo" x * x
09:30:54 <ksf> trace "foo" (x * x)
09:31:03 <shapr> I'm meeting ddarius in Birmingham AL, yay!
09:31:04 <SonOfLilit> foo x = x * x --> foo x = let foo' = x*x in trace ("foo: " ++ foo')
09:31:19 <ksf> that's a type error.
09:31:20 <Axman6> wtf?
09:31:23 <shapr> Anyone else from #haskell want to meet in Birmingham AL next weekend?
09:31:25 <Axman6> why would you do that?
09:31:25 <ksf> foo' isn't a string
09:31:37 <SonOfLilit> show*
09:31:40 <ksf> and soupdragon, you've got the precedence of " " wrong.
09:32:26 * ski wonders how strings have precedence
09:32:31 <ksf> then do trace' s x = trace (s ++ ": " ++ show x) x
09:33:56 <aristid> @src trace
09:33:57 <lambdabot> trace string expr = unsafePerformIO $ do
09:33:57 <lambdabot>     hPutStrLn stderr string
09:33:57 <lambdabot>     return expr
09:34:36 <aristid> @undo trace string expr = unsafePerformIO $ do hPutStrLn stderr string ; return expr
09:34:36 <lambdabot> trace string expr = unsafePerformIO $ hPutStrLn stderr string >> return expr
09:34:47 <aristid> @pl trace string expr = unsafePerformIO $ hPutStrLn stderr string >> return expr
09:34:47 <lambdabot> trace = (unsafePerformIO .) . (. return) . (>>) . hPutStrLn stderr
09:34:53 <aristid> lol.
09:37:08 <soupdragon> wli - but if you use the exact same hamiltonian to derive the equations explicitly it works out
09:37:23 <soupdragon> maybe I should try those equations in the sim to see what happens...
09:40:43 <Peaker> @type (unsafePerformIO .) . (. return)
09:40:43 <lambdabot> Not in scope: `unsafePerformIO'
09:46:43 <ksf> btw, what would be a good module name for that set type? Foreign.C.Set? Data.BitFoo.Set?
09:49:23 <FunctorSalad_> . o O ( haddockfs )
09:49:25 <jmcarthur> okay, now i'm reminded why i had been using OpenGLRaw instead of OpenGL until now
09:49:42 <FunctorSalad_> cd System/IO/; cat hPut
09:49:43 <FunctorSalad_> ;)
09:49:48 <SonOfLilit> found my bug :)
09:49:58 <SonOfLilit> it was a logic bug
09:50:25 <SonOfLilit> I changed something from being last round's to next round's and treated it as last round's
09:50:52 <ksf> FunctorSalad_, wanna write a 9p-based rpc layer that works transparently inter and intra-process?
09:51:32 <FunctorSalad_> ksf: 9p refers to the thing with the cute bunny I suppose, and I heard it uses filesystems a lot.... then you lost me ;)
09:51:37 <geheimdienst> what's the difference between 9p and fuse? any clear advantages?
09:51:51 * geheimdienst doesn't know 9p very much
09:51:56 <ksf> fuse is linux-only and not network transparent.
09:52:02 <FunctorSalad_> oh, 9p isn't plan 9?
09:52:09 <ksf> (well ok, 9p is basically plan9-only)
09:52:15 <geheimdienst> 9p is the filesystem protocol for plan 9, or something
09:52:22 <geheimdienst> ksf, yeah i was gonna say that :-)
09:52:24 <ksf> but unlike nfs, it's not at all insanity to mount something over the internet.
09:52:39 <FunctorSalad_> is linux " a plan9"? there seem to be packages for most of the stuff
09:52:43 <p_l> 9p & 9p2000 <--- network protocol version of Plan9's IO API
09:52:44 <ksf> the way to mount 9p filesystems under linux is fuse, though.
09:52:47 <geheimdienst> ok so the network thing is an advantage
09:52:59 <ksf> there's plan9 from user space, yes.
09:53:19 <geheimdienst> yeah, they've ported tools and other things from plan9 to linux
09:53:23 <ksf> fuse is a c api, 9p has a wire protocol
09:53:29 <ksf> ...a very, very cool wire protocol.
09:53:46 <geheimdienst> what's so cool about it?
09:53:46 <p_l> that I heard is wicked fast on RDMA interfaces :P
09:53:58 <ksf> 9p2000 is inferno
09:53:59 <p_l> geheimdienst: simplicity and flexibility
09:54:26 <ksf> and then there's 9p2000.u , which extends 9p with some unix-style filemode features.
09:54:41 <p_l> ksf: it was 9p -> Styx (in Inferno) -> 9p2000 (Plan9 4ed and current Inferno)
09:54:43 <FunctorSalad_> "mode"?
09:55:08 <ksf> ...I don't remember the details right now
09:55:26 <FunctorSalad_> I mean "what is a file mode"? ;)
09:55:39 <FunctorSalad_> not the thing chmod ch's I assume
09:55:46 <FunctorSalad_> these are "permissions" after all ;)
09:56:01 <ksf> ah, setuid etc.
09:56:31 <Peaker> I hate unix "permissions".
09:56:31 <geheimdienst> it would kinda suck when you have a volume here, then mount it from the other machine and all the executable flags are gone
09:56:46 <gwern> FunctorSalad_: maybe it's about special files. eg device files
09:56:55 <Peaker> Mistakes from the 60's linger on...
09:57:30 <ksf> symlinks, devices, pipes, and sockets.
09:57:37 <ksf> plan9 doesn't need those
09:57:51 <geheimdienst> sounds interesting
09:57:54 <gwern> nazi science sneers at sockets!
09:58:28 <ksf> also included is a way to transmit errno
09:58:33 <ksf> http://ericvh.github.com/9p-rfc/rfc9p2000.u.html
09:58:37 <p_l> well, sockets are what happens when you graft organs between wildly different species... :P
09:59:16 <p_l> IIRC socket API actually has roots in TOPS-20
10:00:16 <geheimdienst> please tell me they didn't stick with errnos in plan9. it's the worst idea to muddle regular results and failure indications into the same int
10:00:32 <mauke> errno is all about using a different int
10:01:10 <p_l> geheimdienst: I don't remember exactly, they did however wildly expand signaling. Oh, and there's no mmap() nor threading
10:01:21 <p_l> at least not preemptive threading
10:01:40 <geheimdienst> mauke, you're right of course. silly.
10:01:52 <pastorn> it's kind of funny how someone as influential in language design as Rob Pike doesn't know haskell
10:02:21 <geheimdienst> still, errnos have the same problem as error return values. forgetting to check them is just too damn easy
10:02:31 <geheimdienst> (my 2 cents)
10:02:53 <ksf> ...and exceptions are evil
10:03:02 <ksf> anyway, c doesn't have them.
10:03:03 <p_l> geheimdienst: at some point you have to decide between simplicity of implementation or powerful condition system
10:03:07 <gwern> is pike all that influential? the whole plan 9 ecosystem never really seemed to amount to anything, and I am dubious abot go's prospects
10:03:30 <pastorn> gwern: http://golang.org/
10:03:48 <pastorn> oh, didn't read the last part of what you said there :)
10:03:48 * p_l hit a stumbling block in C++ FFI in exceptions
10:04:37 <FunctorSalad> at least errnos are ints ;) why are exit codes *bytes* anyway?
10:04:49 <gwern> FunctorSalad: because everything is bytes in the end
10:05:09 <FunctorSalad> gwern: "why is an exit code just a single byte" :p
10:05:17 <gwern> premature optimization
10:05:20 <p_l> FunctorSalad: would you prefer a C string?
10:05:29 <FunctorSalad> p_l: int
10:05:31 <ksf> FunctorSalad, for the same reason linux doesn't parse utf8-marks before #!?
10:05:55 <FunctorSalad> legacy?
10:06:06 <ksf> it's "int main", not "char main"
10:06:14 <Peaker> ksf, Exceptions are just the wrong solution to a true problem. C has the true problem without the wrong solution.. that might be better than having the wrong solution
10:06:30 <ksf> yep
10:06:45 <ksf> if you need the whole int range, pass a *int
10:06:47 <FunctorSalad> hmm I meant shell command exit codes
10:06:56 <FunctorSalad> the once you can read with $?
10:06:57 <FunctorSalad> ;)
10:07:27 <ksf> FunctorSalad, I know
10:07:33 <ksf> ...and C says they're ints.
10:08:51 <ksf> in fact, it might have been cleaner to make the whole c stdlib never return values but pass buffers by reference
10:09:01 <FunctorSalad> so bash does a final modulo 256 or so?
10:09:18 <ksf> or, rather, fix c to support multiple return values.
10:09:27 <gwern> (I say they're badgers and I say to hell with it)
10:09:41 <Saizan> Peaker: is the right solution known?
10:09:46 <illissius> not know much about haskell's exceptions -- are they somehow different? or are they also a wrong solution?
10:10:06 <ksf> yes, they are.
10:10:27 <FunctorSalad> how are exceptions "wrong"?
10:10:43 <ksf> for one, there shouldn't be any in pure code
10:10:47 <ksf> (modulo bottom)
10:10:50 <Peaker> Saizan, IMO explicit sum types (e.g: Either) with monadic binds for automatic error propagation are the right solution
10:11:13 <ksf> and those other exceptions are too un-explicit.
10:11:39 <FunctorSalad> ksf: in haskell, I agree about (impure) exceptions... you and Peaker were talking about exc's in general earlier
10:11:43 <Peaker> FunctorSalad, Exceptions are "wrong" in many ways, depends on language context. Different reasons in C++, Java, or Python
10:12:11 <ksf> ...when opening a file or socket, one should'nt have to have to resort to catching exceptions to catch a non-existing file or already bound socket.
10:12:25 <ksf> it's not like that'd be unusual circumstances.
10:12:52 <Peaker> I don't like statements like "exceptions are for exceptional situations".. You can't really define "exceptional" it amounts to hand-waving
10:13:08 <ksf> if you want to have quick and dirty code, (Right foo) <- bar is the way to go.
10:13:29 <Peaker> FunctorSalad, Do you know Python?
10:13:36 <ksf> an out of memory exception upon opening a file is exceptional. the file not existing is not.
10:13:40 <FunctorSalad> Peaker: barely
10:13:46 * ski has used `Either Integer' (or maybe it was `Either [Integer]' ?) as exceptions
10:14:18 <ksf> there's a fuzzy zone, of course, like EMFILE
10:14:31 <ski> (where those situations weren't "exceptional", i.e.)
10:14:48 <Feuerbach> FunctorSalad: re return status, it's not bash, it is waitpid(2) which returns only lowest 8 bits of actual return status
10:14:57 <Peaker> FunctorSalad, well, C++ would do too.  In both languages, anyone can pretty much throw any exception (in C++ this breaks a lot of the static guarantees you had in C, or have in C++-without-exceptions) anywhere.  When you catch an exception -- there is no way to specify the semantics you want accurately
10:15:00 <FunctorSalad> Peaker: but you aren't suggesting just cluttering the "ideal-case branch" with case distinctions?
10:15:17 <FunctorSalad> Feuerbach: thanks, didn't know :)
10:15:25 <Peaker> FunctorSalad, no, I am suggesting other abstractions (e.g: Either's monad instance) to do that for you
10:15:30 <mauke> I think it's _exit
10:15:30 <ksf> Peaker, the main difference is that there's classes of errors that should always be handled, and those where only a tiny subset of programs is interested, i.e. could recover, from such an error
10:16:08 <FunctorSalad> Peaker: ok, that seems like (data-ified instead of jumping) exceptions in the broadest sense to me ;)
10:16:31 <FunctorSalad> (the bind instance will "jump" out of the rest of the computation indeed)
10:16:34 * ksf tried to go with control-monad-exception and actually it's great, but it exploded into my face as soon as it hit iteratees.
10:16:58 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26378#a26378 <- we accept bets on if NEList satisfies the monad laws, assuming the non-empty condition holds.
10:16:59 <ksf> ...so I'm falling back to manual handling, for now.
10:17:07 <Peaker> The whole "try ... except" clause has really bad semantics. In C++: try { ... } catch(SpecificException) really doesn't catch only what you think it does. It may accidentally catch that exception type originating from any call that happens to occur anywhere in the stack, even unrelated to what you sought. Unless every function has *precisely* specified exception specs that are truly adhered to, rather than just propagating all exceptions mindlessly, at whic
10:17:07 <Peaker> h case you're not really using "exceptions" as such (whose whole idea is mindlessly propagating)
10:17:58 <_Cactus_> what about Lisp's condition system?
10:17:58 <illissius> interestingly Qt manages to do a whole API without any exceptions (and no one seems to miss them)... contrast to Java
10:18:08 <FunctorSalad> ok sorry I have to run, bbl ;)
10:19:31 <roconnor> @bot
10:20:50 <Peaker> FunctorSalad, I see the difference between Either and exceptions as 2 things: A) Avoiding a silly false dillema between returning Nothing or Left and "throwing". Whether it's interpreted as a return value or an "exception" is up to the caller, which is nicer.  B) The exception semantics are well-specified in the type, and there's no mindless exception propagation going on, but explicit propagation, which is more likely to be correct.  Explicit & automated, 
10:20:50 <Peaker> rather than implicit for automation
10:20:50 <Peaker> FunctorSalad, ok
10:20:50 <Peaker> tl;dr;IMO -- the thing that's wrong with exceptions is implicit propagation. Explicit (yet automated) propagation is the "right" way
10:20:50 <Peaker> esp. with untyped exceptions as in C++/Python/etc
10:20:50 <lambdabot> :)
10:25:47 <kamatsu> i'm thinking, does lazy evaluation eliminate most use cases of (e.g lisp) macros?
10:26:17 <mauke> many of them
10:26:28 <Peaker> First-class IO actions eliminate some more
10:26:33 <kamatsu> right
10:26:54 <p_l> kamatsu: IMHO not, because in my opionion lazy-evaluation != code templates
10:26:55 <kamatsu> i can't really think of any macro in lisp that i really miss in haskell
10:26:56 <Peaker> light-weight DSL syntax eliminates yet more
10:27:13 <p_l> it's the DSL stuff that is equivalent of macros, if any :)
10:27:28 <kamatsu> p_l: what DSL stuff, exactly? Template Haskell etc.?
10:27:29 <Peaker> Lisp macros are about syntactic transformations to allow new syntax.  Instead, a flexible syntax + powerful semantic transformers provide an alternative for pretty much any purpose
10:28:01 <ksf> you only need TH to go from the value to the type level
10:28:16 <ksf> ...which of course only works compile-time.
10:28:35 <ski> defining new constructs with non-trivial binding scopes is non-trivial without macros
10:29:07 <kamatsu> ski: example?
10:29:09 <ksf> oh, and to do some of the more fancy semantic transformations, I think
10:29:16 <ksf> ...at least until we get supercompilation
10:30:25 <ski> kamatsu : e.g. an iteration-macro like <http://mumble.net/~campbell/scheme/foof-loop.txt>
10:31:32 <kamatsu> ski: couldn't that basically just be transformed into something with a lambda?
10:31:55 <ski> kamatsu : not easily, since the bindings don't nest linearly
10:32:15 <kamatsu> hm, i see
10:32:18 <ski> another example might be `[f x y | x <- xs | y <- ys]'
10:33:03 <kamatsu> i dunno, i started with lisp
10:33:15 <ski> (and of course, pattern-matching macros .. but since pattern-matching is integrated into Haskell, this is only valid if you want to add new forms of patterns)
10:33:16 <kamatsu> but something always felt `wrong' with syntax->syntax transformation
10:33:35 <ski> (s/valid/relevant/)
10:34:04 <kamatsu> what i would love is for agda's mixfix syntax to be integrated into haskell somehow
10:34:16 <kamatsu> it would make DSLs way more awesome
10:34:35 <ksf> modulo their whitespace/parenthesis handling
10:34:44 <kamatsu> ksf: what's wrong with it?
10:34:51 <ksf> [ [ 1 + 2 ] - 3 ] is ugly
10:35:04 <serega> hi there
10:35:10 <ksf> it should be possible to say [[1 + 2] - 3]
10:35:11 <kamatsu> but 1+2 could be an identifier
10:35:21 <kamatsu> or [[1 could  be an identifier
10:35:24 <ski> it would be nice if one could define new binding constructs, possibly integrated with a system similar to MetaML to distinguish between code and values
10:35:46 <ski> (there was a paper about "MacroML" which was about this, to some extent)
10:35:49 <ksf> [[ shouldn't be a valid identifier, that is, forbid parenthesis, brackets etc. directly nesting.
10:35:55 --- mode: ChanServ set +o mauke
10:35:55 --- mode: mauke set -b *!*@189.214.151.190.cable.dyn.cableonline.com.mx
10:36:07 <ksf> that is, the syntax needs some fine-tuning.
10:36:28 <kamatsu> ksf: you could solve the problem simply by saying that changing from bracket to any other id character is the same as putting a space
10:36:34 <kamatsu> so [a and [ a is equivalent.
10:36:57 <kamatsu> similarly alphanum to punctuation
10:36:58 <ksf> but you might want to define [| or something
10:37:02 <kamatsu> a+b -> a + b
10:37:11 <kamatsu> okay, so define it as alphanum vs punctuation
10:37:31 <kamatsu> i think it's unusual and not too bad if we say that you can't define something like:
10:37:34 <kamatsu> [i blah i]
10:37:37 <ksf> [|[| would be a legal identifier, so you'd need to write [| [| to have two times [|
10:37:47 <serega> I have quite simple question, but don't even know how to google it correctly :) Consider I have a function someFunc :: a -> b -> c -> d  and want to pass it to the 'map' function to apply elements of a list as the SECOND parameter of the someFunc. Should I consctruct a boilerplate lambda or there are more elegant ways?
10:37:55 --- mode: mauke set -o mauke
10:38:02 <kamatsu> ksf: true, but i don't see how you could fix that.
10:38:03 <ksf> so just bleeding disallow multiple [ or ( or { in one ident.
10:38:17 <kamatsu> ah, that would work
10:38:18 <mauke> then how do I define [[ ]]?
10:38:25 <ksf> mauke, you don't.
10:38:27 <ksf> use [| |]
10:38:33 <ski> serega : are the other arguments given, or should the result be a list of functions, each expecting them ?
10:38:45 <serega> they're given
10:39:01 <kamatsu> ksf: this doesn't solve the general case:
10:39:03 <kamatsu> "begin foo end"
10:39:07 <kamatsu> "beginbegin foo endend
10:39:15 <ski> serega : then i think a lambda (or a new local name) is clearest in this case
10:39:21 <kamatsu> i suppose no one would want to write it that way
10:39:25 <ksf> yes, but it's only the [ cases that are ugly.
10:39:31 <serega> ski, thank you
10:39:58 <ski> i.e. `map (\b -> someFunc a b c)' or `map otherFunc' with `otherfunc b = someFunc a b c' in a `where'- or `let'- clause
10:40:02 <kamatsu> okay, i accept your suggestion, ksf
10:40:04 <ksf> and unbalanced parenthesis should be forbidden, too, so no [ _ )
10:40:15 <kamatsu> why?
10:40:26 <ksf> I'm not so sure anymore.
10:40:33 <kamatsu> i had one in agda where it was a << b ] c
10:40:34 <ksf> that's range syntax...
10:40:40 <kamatsu> there was a reason for writing it like that
10:41:20 <ksf> yeah I suppose they're ok
10:41:32 <kamatsu> what about:
10:41:34 <kamatsu> (a,b)
10:41:42 <kamatsu> the comma still requires spaces.
10:41:45 <mauke> I like to define [ as drop and ] as take
10:41:56 <kamatsu> (a , b)
10:42:25 <ksf> one could define a class of symbols that may only be used infix
10:42:43 <ksf> so a and b can't have , at their outsides.
10:43:07 <mauke> or embrace the ambiguity
10:43:13 <ksf> erm non-nested, that is. which is what would make that ambigious.
10:43:13 <mauke> allow everything
10:44:01 <ksf> can agda handle varags?
10:44:11 <ksf> that is, [_,_,...]?
10:44:20 <Philonous> serega: For the case where you want the second parameter you can only use flip. 
10:44:34 <Philonous> serega: Sorry, you can _also_ yous flip
10:44:38 <Philonous> use*
10:45:21 <serega> Philonous, wow, I'll check that too. Thanks
10:47:06 <ski> Saizan : that's a strange monad
10:47:56 <ski> Philonous : one can use `flip' if the second parameter is given - however the opposite was the case, here
10:49:09 <Philonous> ski: Err, yeah. serega: Never mind what I said. It doesn't apply
10:49:12 <ski> Saizan : i can't seem to provoke it to break a monad law, but it does break left-distribution &c. of `MonadPlus', i think (assuming the "obvious" instance)
10:52:18 <Saizan> ski: ah, well there's no mzero either, but i do need something like mplus
10:54:26 <ski> the "obvious" definition of `(>>=)' for non-empty lists would be
10:54:33 <ski>   NEList [x] >>= f = f x
10:54:46 <ski>   NEList (x:xs) >>= f = NEList (unNE (f x) ++ unNE (NEList xs >>= f))
10:54:52 <Saizan> yeah
10:55:13 <ski> is there any reason why you're discarding alternative solutions from all-but-the-last element in the input ?
10:55:24 <Saizan> i'm using this weird one because i think it'd help getting a small-step evaluator out of my LC interpreter
10:56:34 <Saizan> so when i do something like liftM2 (+) (eval e1) (eval e2) i don't want the cartesian product
10:57:21 <Saizan> well (+) is not right, i'd have a constructor there
10:57:35 <ski> what does the alternative solutions represent ?
10:57:37 <Saizan> it's an AST -> (AST,Env) interpreter
10:57:46 <ski> the evaluator is nondeterministic ?
10:57:47 <Saizan> the steps in the evaluation
10:57:51 <ski> mhm
10:58:24 <ski> (i'd probably try with some `Writer' variant for getting a "trace" of the steps)
10:58:41 * ski ponders that
10:59:03 <ski> .. possibly it isn't that easy
11:00:15 <DrTeggy> 'Cartesian' with a capital 'C', just like the capital 'B' in 'Boolean'.  ;-)
11:00:30 <ski> hm, i think this is an interesting problem
11:01:31 <Saizan> i thought about writer, but it wasn't clear what was the best way to deal with the evaluation context so that you could wrap it around the stepped subexpression when logging
11:01:46 <ski> (DrTeggy : not "ProfTeggy" any longer ?)
11:02:01 <DrTeggy> 'Peyton-Jonesian' ... Hmm
11:02:37 <DrTeggy> ski, it's me, and yes, I'm still a professor ;-)
11:03:12 * ski recalls ProfTeggy talking about monads in relation to database queries in the past
11:04:15 <DrTeggy> ski, the connection between monads and databases is still on our radar
11:04:16 <markus3> hi! i\m having a strange problem with ByteString: when i load my program in ghci, it loads it fine, but when i raun the main function it says "ghci runtime linker: fatal error: I found a duplicate definition for sumbol _fps_reverse"...
11:04:41 <markus3> what can i do with it? is it a bug or something?
11:05:00 <DrTeggy> Much more than ever, actually
11:05:35 <ski> any paper you'd recommend, for a mostly newbie to this ?
11:05:57 <DrTeggy> /
11:06:21 <ski> Saizan : btw, are you doing sequential or parallel reductions ?
11:06:25 <Saizan> markus3: does it work when you compile?
11:06:31 <Saizan> ski: sequential
11:06:51 <DrTeggy> ski, see www.ferry-lang.org
11:07:03 * geheimdienst would prefer if the paper explained it in lambdacat form. im in ur detabase nomin ur monids, etc.
11:08:01 <markus3> it compiles, but when running, it says "Data.ByteString.tail: empty ByteString"...
11:08:31 <markus3> I know what that means -- I have to check for emptyness, but are tehy related?
11:08:35 <markus3> they
11:09:19 <DrTeggy> Back to watching the World Cup. Take care, folks.
11:09:24 <aavogt> > tail [] -- like this
11:09:24 <lambdabot>   *Exception: Prelude.tail: empty list
11:09:52 <pastorn> markus3: what are you doing with your bytestring? parsing from them?
11:10:07 <markus3> something like that yes
11:10:13 <markus3> counting words
11:11:30 <pastorn> markus3: how do you do this?
11:12:03 <emilmeln> I wonder if ReaderT (StateT IO) can be replaced with (ReaderT IO)?
11:12:11 <emilmeln> Like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26380
11:12:18 <pastorn> emilmeln: it can with exessive use of local :)
11:12:42 <emilmeln> I mean, with IORefs in environment data.
11:12:55 <emilmeln> For me, is makes no difference...
11:12:58 <pastorn> emilmeln: that just seems nasty
11:13:11 <pastorn> if it's something that you modify you should use StateT
11:13:12 <aavogt> emilmeln: I've done that before
11:13:31 <markus3> I read a bunch of files to bytestrings, then split them up by spaces, then add the word to a trie and replace the word with an Int (for that word)
11:13:33 <pastorn> emilmeln: otherwise it's just confusing (sure, it works, but it's confusing)
11:13:48 <pastorn> emilmeln: why don't you want to have StateT ReaderT IO?
11:13:50 <markus3> and then I calculate a frequency map for the words
11:14:19 <aavogt> pastorn: readerT and stateT commute
11:14:29 <pastorn> aavogt: i know this
11:14:33 <ski> Saizan : hm, small-step ? so you only reduce one step at first, and then to reduce more, you have to call again ?
11:14:38 <aavogt> @unmtl ReaderT r (StateT s m) a
11:14:38 <lambdabot> r -> s -> m (a, s)
11:14:44 <pastorn> @hoogle null
11:14:44 <lambdabot> Prelude null :: [a] -> Bool
11:14:44 <lambdabot> Data.ByteString null :: ByteString -> Bool
11:14:44 <lambdabot> Data.IntMap null :: IntMap a -> Bool
11:14:54 <pastorn> ^^^ markus3: using it?
11:15:06 <emilmeln> pastorn: I've seen much use of readerT + stateT over IO (XMonad is the prime example), but if we are anyway ended up in the IO monad, why bother?
11:15:33 <EvanR> keeping state is not an IO activity
11:15:46 <pastorn> emilmeln: why do you need IORef?
11:15:48 <EvanR> unless you keep the state in a database or file or something
11:15:51 <markus3> no not yet, but I was going to.. but what about the fatal error? 
11:16:07 <andreo> I compile my program: ghc -o gen gen.hs
11:16:08 <andreo>  
11:16:13 <pastorn> markus3: you should probably use null...
11:16:14 <andreo> and get an error:
11:16:15 <andreo> gen.o: In function `sO3_info':
11:16:15 <andreo> (.text+0x25): undefined reference to `containerszm0zi3zi0zi0_DataziMap_insertWith_closure'
11:16:15 <andreo>  
11:16:23 <aavogt> andreo: use --make
11:16:41 <EvanR> by using IO as state, you require all parts of the program that use the state to be IO
11:16:49 <EvanR> even if they dont do any input or output
11:16:55 <pastorn> markus3: since you can't really pattern match on an empty ByteString, like you can with a String (f "" = baseCase) you'll have to resort to null
11:16:59 <andreo> aavogt: thank you
11:17:05 <Cale> emilmeln: I basically never StateT over IO, because IO already has lots of facilities for state.
11:17:10 <pastorn> markus3: just do a null check in all places where you do tail
11:17:44 <pastorn> Cale: yeah! pure functions are for dickwads
11:17:58 <Cale> pastorn: heh, what?
11:18:05 <pastorn> nevermind :)
11:18:05 <aavogt> you're already using IO...
11:18:06 <emilmeln> EvanR: How can I retrieve components of a State transformer over IO without ended up in the IO monad?
11:18:32 <Saizan> ski: the idea is that i'll call the modded eval once and it'll give me the list of the steps a small-step evaluator would have gone through
11:18:34 <pastorn> emilmeln: elaborate...
11:18:36 <emilmeln> Cale: This is precisely what I'm talking about :)
11:18:40 <markus3> pastorn: hmh.. ok, but what about using the program in ghci?
11:18:46 <ski> ok
11:19:03 <markus3> the fatal error about more than one definition for a symbol?
11:19:04 <pastorn> markus... put thus null checks in there
11:19:06 <EvanR> outside the monad you have the raw state anyway
11:19:12 <pastorn> if you still get an error, paste it
11:19:17 * ski is attempting to write something along these lines as well, to see what stumbing-blocks arise
11:19:24 <markus3> ok
11:19:38 <triyo> Is there a way to use getContents and getArgs in a main function? I'd like my program to be able to receive arguments via unix pipe or via explicit command arguments.
11:19:55 <EvanR> make an abstraction
11:20:20 <pastorn> triyo: there's a library for argument handling
11:20:36 <Cale> emilmeln: You can write polymorphic actions: (MonadState MyState m) => m a, which then wouldn't be permitted to use IO and would manipulate your state, but doing that is somewhat rare, and usually breaks whatever abstraction you've wrapped around your transformed monad.
11:20:45 <c_wraith> triyo: why wouldn't it be possible?
11:21:10 <triyo> c_wraith: because I'm a newbie and not to sure if anything is possible at this stage ;-)
11:21:12 <emilmeln> pastorn: in (StateT S IO a), we can't get the state without involving IO.
11:21:20 <EvanR> triyo: anything is possible!
11:21:22 <pastorn> triyo: http://hackage.haskell.org/packages/archive/parseargs/0.1.3/doc/html/System-Console-ParseArgs.html
11:21:29 <Cale> emilmeln: hm?
11:21:52 <Cale> emilmeln: You can force the type to be (MonadState S m) => m a
11:21:58 <aavogt> hmm, how does that compare to cmdargs and getopt, pastorn?
11:22:06 <Cale> Which will mean that the action can't use IO
11:22:54 <pastorn> triyo: hmm... maybe that doesn't do any reading from stdin...
11:23:23 <emilmeln> Cale: Yes, but I'm talking about m being IO (by design).
11:23:32 <aavogt>  main = do { stdin <- getContents; args <- getArgs; ...pick which one to use... }
11:24:05 <triyo> aavogt: Hehe, I was just gonna ask if something simple as that would work
11:24:15 <pastorn> emilmeln: but if your state modifying functions has the type signature that cale gave then they can't do io
11:24:27 <pastorn> (or maybe they can...)
11:24:29 <pastorn> ?
11:24:47 <aavogt> no they can't
11:24:49 <emilmeln> No, they can't. No MonadIO m constraint.
11:25:01 <monochrom> what is meant by "involving IO"? does Â«return () :: IO ()Â» "involve IO"?
11:25:07 <markus3> pastorn: both errors dissapeared -- thank you!
11:25:18 <pastorn> markus3: cool :)
11:25:20 <c_wraith> monochrom, sure.  the result type is in IO
11:25:41 * hackagebot hamlet 0.3.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.3.0 (MichaelSnoyman)
11:25:57 <Cale> emilmeln: Right, I'm just saying you can use such a polymorphic action as a StateT S IO action, but because of its type signature, it's not allowed to do IO.
11:26:40 <aavogt> you could just as easily substitute the m with Identity
11:27:21 <aavogt> which should be some concern if that Monad can do IO
11:28:33 <emilmeln> So, wait... If I made such a stack (State over IO), i can't get the state without ending up in IO, can I?
11:28:58 <aavogt> @unmtl StateT s IO a
11:28:58 <lambdabot> s -> IO (a, s)
11:29:14 <aavogt> see that? The resulting state is inside the IO
11:29:25 <monochrom> I see, the question was why not replace Â«StateT s IO aÂ» by Â«IO aÂ». My answer: sure you can do that if you like, I don't mind, but note there is lots of code rewrite.
11:30:09 <emilmeln> No, of course no refactoring in that way.
11:31:21 <monochrom> Â«ReaderT (IORef MyStuff) IO aÂ» is quite a bit more convenient than Â«IORef MyStuff -> IO aÂ» even though logically equivalent.
11:33:32 <ksf> the other way is unsafePerformIO . newIORef $
11:33:54 <emilmeln> I've read up somewhere that using many stacked monads comes at it's own price.
11:34:02 <EvanR> ksf: thats a cool pattern!
11:34:16 <pastorn> ksf: don't forget {-# NOINLINE funName #-}
11:34:44 <pastorn> emilmeln: that's why you have Control.Monad.RWS
11:35:22 <pastorn> emilmeln: but it's true, GeneralizedNewtypeDeriving can't handle stacks deeper than 2 (?) monad transformers
11:35:54 <emilmeln> pastorn: It's good, but in case of intensive IO monads the Writer component usually going into the file (as log).
11:36:00 <mauke> pastorn: wtf?
11:36:18 <pastorn> mauke: try it
11:36:44 <pastorn> emilmeln: then i'd put a handle to the file inside a Reader
11:36:59 <pastorn> or just the filepath there and use appendile
11:37:01 <pastorn> *appendFile
11:38:03 <pastorn> mauke: iirc. i couldn't do all the monad instances for ReaderT StateT IO (MonadReader, MonadState, MonadIO), but using RWST it all worked perfectly (using () as writer)
11:38:05 <emilmeln> pastorn: It works, with 4 nested readers
11:38:31 <pastorn> mauke: do == derive
11:38:35 <pastorn> emilmeln: huh?
11:38:42 <emilmeln> newtype X a = X (ReaderT Env (ReaderT Env (ReaderT Env (ReaderT Env IO))) a)
11:38:53 <emilmeln> Ouch...
11:38:56 <emilmeln> Sorry
11:39:04 <Saizan> ski: i've proved the laws in agda btw http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26381#a26381
11:39:13 <pastorn> emilmeln: ReaderT r (Reader r' a) <-- this won't work...
11:39:28 <pastorn> unless you mess with MonadTrans
11:39:48 <pastorn> emilmeln: but that's just silly...
11:40:14 <ManateeLazyCat> I have finish poppler (PDF viewer) APIs binding at https://patch-tag.com/r/AndyStewart/poppler/home , i'm writing demo to test APIs. If you interested it, please help me test it.
11:40:36 <ManateeLazyCat> I will release it at hackage after test completely.
11:41:14 <emilmeln> maybe ReaderT r (Reader r') a
11:41:38 <pastorn> emilmeln: vaddevva
11:41:39 <emilmeln> ... and it works.
11:41:56 <pastorn> emilmeln: yeah, but then you have to use (lift ask) to get the inner
11:41:59 <pastorn> which is stupid
11:42:07 <pastorn> oh, now i remember
11:42:30 <pastorn> you can't have MT (ReaderT r (Reader r')) a
11:42:39 <pastorn> then lift will get confused
11:45:38 <monochrom> How should I comment out lines in an xxx.cabal file?
11:46:00 <ManateeLazyCat> monochrom: -- ?
11:46:26 <monochrom> Oh haha yes, I'm blind, thanks.
11:49:59 <jbapple> I am curious about two things regarding Data.Set.balance: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/src/Data-Set.html#line-785
11:50:38 <jbapple> 1. Data.Set uses Ints for size, but balance multiplies these sizes by positive Ints and then compares them 
11:50:43 <jbapple> This could lead to overflow
11:50:57 <emilmeln> Is there any way to pass to cabal-install --hyperlink-source Haddock option in configuration file?
11:51:18 <EvanR> :t undefined
11:51:18 <lambdabot> forall a. a
11:51:58 <jbapple> 2. I think [delta] and [ratio] don't actually successfully balance the tree. How can we be sure there is no pathological case where the tree becomes very unbalanced?
11:52:01 <FunctorSalad> emilmeln: not that I knew, but there ought to be!
11:52:28 <sinelaw> greetings
11:52:34 <hpc> @src undefined
11:52:35 <lambdabot> undefined =  error "Prelude.undefined"
11:52:37 <FunctorSalad> someone be bold
11:52:57 <FunctorSalad> it can't be that hard to enable a flag that's in 'cabal haddock' already for 'install'
11:53:56 <emilmeln> Also, when generating docs, cabal-install doesn't generate class instances.
11:54:38 * FunctorSalad has a conjecture...
11:54:56 <FunctorSalad> nobody but the core developers dare fix something in cabal... because of its name ;)
11:55:12 <FunctorSalad> you can't just walk into a cabal after all...
11:55:16 <FunctorSalad> o_O
11:55:24 <mauke> so a man walks into a cabal
11:55:41 * sinelaw just learnt that the logarithmic function serves is a functor  from the abelian group of reals under multiplication, to the abelian group of positive reals under addition
11:55:47 <sinelaw> that's pretty neat.
11:55:54 <FunctorSalad> hey you over there, we're starting a cabal, wanna join? ;)
11:56:08 <sinelaw> reals under multiplication = isomorphic to positive reals under addition
11:56:29 <aristid> sinelaw: logarithmic transformation?
11:56:35 <FunctorSalad> sinelaw: the group structure is not enough to capure is essence
11:56:47 <FunctorSalad> you need the topology too :)
11:56:59 <sinelaw> aristid yes
11:57:23 <FunctorSalad> without continuity there are many homomorphisms unless I'm very confuesd
11:57:24 <soupdragon> confusing way to say that  log(xy)=log(x)+log(y)
11:57:27 <FunctorSalad> *confused
11:58:32 <sinelaw> soupdragon also commutation, associativity
11:58:51 <FunctorSalad> ? these are not properties of a homo:)
11:59:01 <sinelaw> :\
11:59:55 <FunctorSalad> why? :(
12:01:25 <illissius> @src error
12:01:25 <lambdabot> error s = throw (ErrorCall s)
12:02:39 <sinelaw> :/
12:02:51 <sinelaw> (man without nose and crooked mouth)
12:03:46 * sinelaw is programming in BuzzwordLanguage (aka Java)
12:04:11 <sinelaw> :_(
12:04:19 <EvanR> @src undefined
12:04:19 <lambdabot> undefined =  error "Prelude.undefined"
12:04:35 <EvanR> @src throw
12:04:35 <lambdabot> throw exception = raise# exception
12:04:44 <EvanR> @src raise#
12:04:44 <lambdabot> Source not found. Take a stress pill and think things over.
12:04:48 <aristid> :t throw
12:04:49 <lambdabot> Not in scope: `throw'
12:04:54 <aristid> @hoogle throw
12:04:54 <lambdabot> Control.Exception throw :: Exception e => e -> a
12:04:54 <lambdabot> Control.OldException throw :: Exception e => e -> a
12:04:54 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
12:04:57 <EvanR> fail
12:05:03 <aristid> :t Control.Exception.Throw
12:05:04 <lambdabot>     Not in scope: data constructor `Control.Exception.Throw'
12:05:08 <illissius> :t fail
12:05:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
12:05:10 <aristid> EvanR: no, fail is a method of Monad
12:05:23 <aristid> :t Control.Exception.throw
12:05:24 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
12:05:58 <EvanR> a method of all instances of Monad
12:11:59 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:12:12 <soupdragon> lol
12:12:14 <orlandu63> what
12:12:26 <sinelaw> heh
12:12:33 <soupdragon> If anyone has a GHC or Hugs please join my forum I need moderators: www.haskell.org
12:12:41 <EvanR> cycle SnIpErZ
12:12:45 <EvanR> there, now hes trapped
12:12:46 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:12:47 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:12:47 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:12:48 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:12:50 <soupdragon> lol
12:12:50 <EvanR> wait
12:12:52 --- mode: ChanServ set +o monochrom
12:12:53 <sinelaw> > cycle SnIpErZ
12:12:54 <lambdabot>   Not in scope: data constructor `SnIpErZ'
12:12:57 <sinelaw> > cycle "SnIpErZ"
12:12:57 <lambdabot>   "SnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIpErZSnIp...
12:12:59 <sinelaw> > cycle "SnIpErZ "
12:13:00 <lambdabot>   "SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ Sn...
12:13:09 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.ccIf anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.ccIf anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:13:10 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:13:11 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:13:11 --- mode: monochrom set +b *!*@host81-132-34-201.range81-132.btcentralplus.com
12:13:11 <SnIpErZ> If anyone has an xbox or modern warfare 2 please join my forum I need moderators: http://xboxbeasts.co.cc
12:13:12 --- mode: ChanServ set +o Igloo
12:13:13 <EvanR> i didnt mean it
12:13:13 <Phyx-> where the ops at
12:13:14 <sinelaw> > cycle "SnIpErZ "
12:13:15 <lambdabot>   "SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ SnIpErZ Sn...
12:13:15 <EvanR> lol
12:13:17 <sinelaw> oops
12:13:19 <sinelaw> it actually works!
12:13:29 --- kick: SnIpErZ was kicked by Igloo (SnIpErZ)
12:13:33 <sinelaw> thanks.
12:13:52 <sinelaw> that bot actually repeats his message whenever the nick is used?
12:14:21 <EvanR> only if you use a cyclic haskell function on it
12:14:49 <emilmeln> heh, cycle is spammer's favorite function.
12:15:20 <aavogt> forever is probably better
12:15:25 <EvanR> yeah and they probably resort to primitive for loops or something to accomplish it ;)
12:15:56 <FunctorSalad> forever = sequence . cycle . robotmonkey, no? ;)
12:15:58 <emilmeln> @t forever . cycle
12:15:58 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:16:00 <aristid> > cycle "Buy potatoes! "
12:16:01 <lambdabot>   "Buy potatoes! Buy potatoes! Buy potatoes! Buy potatoes! Buy potatoes! Buy ...
12:16:10 <FunctorSalad> (robotmonkey=(:[]))
12:16:30 <sinelaw> @thanks
12:16:30 <lambdabot> you are welcome
12:16:33 <EvanR> > repeat "SnIpErZ"
12:16:34 <lambdabot>   ["SnIpErZ","SnIpErZ","SnIpErZ","SnIpErZ","SnIpErZ","SnIpErZ","SnIpErZ","SnI...
12:17:05 <aristid> > intercale " = " $ repeat "0"
12:17:06 <lambdabot>   Not in scope: `intercale'
12:17:11 <aristid> > intercalate " = " $ repeat "0"
12:17:12 <lambdabot>   "0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 = 0 ...
12:17:48 <tromp_> > (0 == 0) == (0 == 0)
12:17:50 <lambdabot>   True
12:18:07 <emilmeln> repeat "^_^ "
12:18:12 <emilmeln> > repeat "^_^ "
12:18:13 <lambdabot>   ["^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^ ","^_^...
12:18:29 <sinelaw> the true use of haskell
12:19:23 <aristid> sinelaw: making infinite smiley sequences?
12:20:10 <sinelaw> aristid yeah
12:20:28 <aristid> > cycle "\o/ "
12:20:29 <lambdabot>   <no location info>:
12:20:29 <lambdabot>      lexical error in string/character literal at chara...
12:20:42 <aristid> > cycle "\\o/ "
12:20:43 <lambdabot>   "\\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/ \\o/...
12:20:50 <aristid> hmm that's wrongish
12:21:32 <emilmeln> lambdabot: Are you ready for Turing Test?
12:21:44 <EvanR> > print "no"
12:21:45 <lambdabot>   <IO ()>
12:21:51 <sinelaw> @vixen are you ready for the Turing Test?
12:21:51 <EvanR> see
12:21:51 <lambdabot> yes, i am
12:21:53 <pastorn> > cycle "OM! N"
12:21:54 <lambdabot>   "OM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! NOM! ...
12:22:02 <kmc> > text . concat . replicate 16 $ "\o/ "
12:22:02 <lambdabot>   <no location info>:
12:22:03 <lambdabot>      lexical error in string/character literal at chara...
12:22:06 <kmc> > text . concat . replicate 16 $ "\\o/ "
12:22:07 <lambdabot>   \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/ \o/
12:22:08 <sinelaw> @vixen ok, question number one. do you love your parents?
12:22:08 <lambdabot> i wouldn't say i do love...
12:22:36 <EvanR> @vixen what is the square root of two
12:22:36 <lambdabot> let's don't talk about that
12:22:45 <soupdragon> @vixen what is the square root of three?
12:22:46 <lambdabot> i don't know, what?
12:23:03 <EvanR> im convinced
12:23:06 <emilmeln> It's like those "perpetum" mobiles, with real people inside.
12:23:34 <Tomsik> Yeah, it's like a talking with any guy from humanities, EvanR 
12:23:50 <EvanR> lol
12:24:15 <emilmeln> sharp!
12:24:32 <emilmeln> lambdabot: Do you like Haskell?
12:25:08 * hackagebot text-json-qq 0.1.1 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.1.1 (OscarFinnsson)
12:25:42 <aristid> @vixen Do you like Haskell?
12:25:42 <lambdabot> church is my favourite computer scientist.
12:25:56 <c_wraith> @vixen why do you hate curry?
12:25:56 <aristid> glorious church.
12:25:56 <lambdabot> i'm not a hater
12:25:59 <winxordie> the church of church
12:26:12 <EvanR> knights of the easter calculus
12:26:16 <EvanR> +n
12:27:26 <emilmeln> @vixen What's your opinion about SkyNet?
12:27:26 <lambdabot> isn't it obvious?
12:27:38 <EvanR> @vixen no
12:27:38 <lambdabot> i didn't think so
12:28:10 <EvanR> these things never produce real answers
12:28:32 <emilmeln> He neatly avoided this confusing question :)
12:28:43 <ksf> hey getopt supports tar-like options
12:28:56 <aavogt> hey getopt is verbose
12:29:27 <ksf> emilmeln, she.
12:29:29 <ksf> she's a she.
12:29:43 <ksf> @vixen a/s/l?
12:29:43 <lambdabot> 19/f/California
12:30:12 <Lemmih> Wasn't she 19 a year ago?
12:30:27 <EvanR> clearly lying
12:30:33 <ksf> ssssh don't question the age girls give you
12:30:45 <EvanR> unless its 19
12:30:56 <emilmeln> Oh my...
12:32:41 <sinelaw> @vixen how old were you last year?
12:32:42 <lambdabot> 19, you?
12:32:50 <sinelaw> "19" too
12:32:58 <aristid> @vixen how old will you be next year?
12:32:59 <lambdabot> 19, you?
12:33:07 <Rayne> haha :D
12:33:07 <EvanR> @vixen 2+2
12:33:07 <lambdabot> eh?
12:33:16 <sinelaw> @vixen fix fix
12:33:16 <lambdabot> You should add me to your buddy list!
12:33:24 <ksf> that's below her intellect.
12:33:30 <ksf> she's making fun of you.
12:33:40 <EvanR> @vixen what year is it
12:33:40 <lambdabot> let's don't talk about that
12:34:16 <ksf> see she's actually using her omniscense to see what you're going to do this summer and taking appropriate action.
12:34:35 <sinelaw> @vixen what am I going to do this summer?
12:34:36 <lambdabot> i don't know, what?
12:34:47 <sinelaw> ok ELIZA, stop pretending
12:34:57 * sinelaw zips back to work
12:34:59 <ksf> she also knows how to hide her abilities.
12:35:34 <EvanR> so the turing test can be passed with a suitably intelligence support system that explains away the weirdness
12:35:39 <EvanR> intelligent
12:36:08 <Tomsik> @vixen do you like curry in your meals?
12:36:09 <lambdabot> sure, i like you so far
12:36:16 <ksf> EvanR, why are you mentioning intelligence?
12:36:31 <monochrom> Cabal is rather nice.
12:36:35 * EvanR turns off ksf 
12:36:46 <monochrom> Of course GHC dependency chasing also rocks. :)
12:36:53 <ksf> hey bots have feelings, too
12:37:04 * ksf locks up EvanR inside a monad
12:37:18 --- mode: monochrom set -o monochrom
12:37:21 <emilmeln> runEvanR
12:37:24 <emilmeln> > runEvanR
12:37:25 <lambdabot>   Not in scope: `runEvanR'
12:37:25 * EvanR uses unsafePerformIO to escape
12:37:39 <sinelaw> CTRL+C
12:37:47 <aristid> @let runEvanR = const $ error "Crash!"
12:37:48 <lambdabot>  Defined.
12:39:42 * ManateeLazyCat pasted ""undefined reference to" error" at http://paste2.org/get/884295
12:39:43 <ManateeLazyCat> When i test my demo program at https://patch-tag.com/r/AndyStewart/poppler/snapshot/current/content/pretty/demo , i got above problem , it's looks strange, Any idea?
12:42:57 <ManateeLazyCat> flex @seen dcoutts 
12:53:29 * ksf thinks getopt should support user errors
12:53:46 <ksf> ...that is, enable the fold to write to the output error list.
12:54:20 <Saizan> is there a way to make haskell-mode's *haskell* buffer take less then 1/2 of the window by default?
12:54:24 <Saizan> *than
12:54:30 <ManateeLazyCat> ksf: Do you know how to fix my problem at http://paste2.org/get/884295 ?
12:54:52 <ksf> ManateeLazyCat, -lpoppler?
12:55:21 <ManateeLazyCat> ksf: The new library i finish at http://patch-tag.com/r/AndyStewart/poppler/home
12:55:25 <ksf> that is, add pkgconfig-depends: poppler
12:55:43 <ksf> which will test for poppler using pkg-config and insert all the right flags etc.
12:55:44 <ManateeLazyCat> ksf: I have add.
12:56:08 <ManateeLazyCat> ksf: I think just need "pkgconfig-depends: poppler >= 0.14.0, gobject-2.0, glib-2.0, cairo >= 1.2.0, gdk-2.0, gdk-pixbuf-2.0, pango"
12:56:35 <ManateeLazyCat> ksf: Problem is compile poppler library is fine, just have ld error when i compile my demo program.
12:56:48 <ksf> what does 'pkg-config poppler --libs' say?
12:57:07 <ManateeLazyCat> -L/usr/local/lib -lpoppler  
12:57:08 <ManateeLazyCat>  
12:57:28 <ksf> then it *should* work...
12:58:56 <ksf> ha!
12:59:13 <ksf> poppler is a c++ library, according to the mojibake readelf -s outputs
12:59:30 <ksf> so all the names are mangled.
12:59:32 <ManateeLazyCat> ksf: poppler has glib library.
12:59:42 <ManateeLazyCat> ksf: But is .cc file.
13:00:18 <ksf> ...but then you need to use pkgconfig-depends: poppler-glib
13:00:35 <ksf> % pkg-config poppler-glib --libs
13:00:35 <ksf> -lpoppler-glib -lgdk-x11-2.0 -lgdk_pixbuf-2.0 -lpangocairo-1.0 -lpango-1.0 -lcairo -lgobject-2.0 -lgmodule-2.0 -lglib-2.0
13:01:15 <ManateeLazyCat> ksf: Thanks, i try.
13:02:11 <ksf> ...and my favourite vikings are winning, that's good news.
13:02:32 <ManateeLazyCat> ksf: Works, thanks.
13:02:38 <ksf> no bother
13:03:19 <ManateeLazyCat> ksf: After i test complete, i will release poppler package, then we can use Haskell build PDF viewer! :)
13:05:22 <ski> Saizan : ok
13:05:50 <ManateeLazyCat> Saizan: What do you mean "less 1/2 window"?
13:06:18 <ksf> ManateeLazyCat, just out of curiosity: do chinese watch the football championship?
13:06:31 <ManateeLazyCat> ksf: Yes.
13:06:42 <ManateeLazyCat> ksf: But i know you mean. :)
13:06:45 <gwern> do the chinese even have a national soccer team?
13:06:55 <ksf> it's called FOOTBALL
13:07:16 * ski ponders whether to reduce-under-lambda / allow unbound variables, or not ..
13:07:18 <ManateeLazyCat> Ok, your guys mean "Chinese Footbal Team is suck". you got, 
13:07:50 <ManateeLazyCat> The truth We have "national team", but suck...
13:08:08 <ksf> I'd never say that. the only team that is not worthy to kick a ball is the dutch one.
13:08:10 <ManateeLazyCat> I perfer to watch NBA, and never Chinese footbal game.
13:08:54 <gwern> ksf: I thought the dutch were famous for their soccer?
13:09:04 <ksf> they're way better at spitting.
13:09:28 <ksf> and no, they're famous for their cheese, weed and wooden shoes.
13:09:34 <ksf> also, canals and windmills.
13:10:00 <ksf> which is all fine, just their "football" is unworthy to be called football.
13:10:26 * gwern wonders if ksf is a neutral expert on this matter
13:10:36 <ManateeLazyCat> ksf: China's soccer team can not even qualify in Asia, but China is the world's most populous country, do not you think irony?
13:11:06 <Phyx-> ksf: oi!
13:11:14 * Phyx- points ksf to his .nl host
13:11:20 <gwern> ManateeLazyCat: maybe the chinese have better things to do
13:11:23 * Phyx- hits ksf with his wooden shoe
13:11:44 * gwern as an American regards soccer as a good game for kids
13:11:50 * ksf dodges with a traditional-style steakburger
13:11:50 <ManateeLazyCat> gwern: Why Japanese and Korea can do better? And Chinese can't?
13:12:09 <gwern> ManateeLazyCat: even japan and korea have their faults
13:12:23 <ksf> probably because there's no crazed youth in china who play soccer all day long?
13:12:33 <Phyx-> ksf: to be honest, I'm one of the very few you'll find who doesn't care at all for soccer 
13:12:35 <ManateeLazyCat> gwern: But much better than Chinese.
13:13:07 <ManateeLazyCat> ksf: Youtube can't access in China if you don't know how to around GFW.
13:13:20 <ksf> Phyx-, I'm an ex-handball player myself, and don't care much for football. but there's no club but st. pauli and no enemy but bavaria and oranje.
13:14:17 <Phyx-> lol
13:14:19 * ManateeLazyCat I just watch NBA recently, no time watch football....
13:15:13 * ski double-checks the channel-name; the "-blah" part must have gotten invisible ..
13:15:19 <ManateeLazyCat> ksf: Misread, youth
13:15:24 <ksf> It's good to caress one's stereotypes and feindbilds[1]. you never know when you need them     [1] /me introduces that as an english term because even dict.leo.org doesn't have a translation
13:15:32 <ManateeLazyCat> ksf: Yes, have much people play soccer.
13:15:53 <ksf> in clubs or just for fun?
13:16:03 <ManateeLazyCat> ksf: Have club
13:16:06 <aristid> ksf: saying "feindbild" also makes you sound more intellectual.
13:16:30 <Phyx-> ski: your client is truncating it
13:16:39 <ski> i knew it !
13:16:40 <ksf> germany playing world-class football largely depends on even the smallest villages having clubs, I thing.
13:17:30 <ManateeLazyCat> ksf: In China, most people play pingpong. 
13:17:31 <arw_> and on the big clubs getting loads of cash through ads and tv licenses
13:17:55 <arw_> so they can just buy the good players
13:18:05 <ManateeLazyCat> ksf: You can see have many kids play pinpong everywhere...
13:18:06 <arw_> instead of needing to find and train them
13:18:42 <ksf> or selling t-shirts saying "worldcupchampionbeaterrescuer"
13:18:51 <ManateeLazyCat> gwern: I think pingpong is your "better thing" :)
13:19:03 <gwern> no, that was back in the 70s or whatever
13:19:09 <gwern> who even started that anyway
13:22:19 <ksf> danes don't loose
13:22:39 * ksf is feeling skandinavian cheers rolling up from the north
13:22:41 <bremner> thats not what the swedes tell me
13:23:01 <bremner> oops. -> -blah with me.
13:23:36 <ksf> cheers to denmark from the lost states!
13:24:55 <ksf> arw_, buying players doesn't buy you a good national team.
13:25:15 <ksf> just have a look at england.
13:27:47 <ManateeLazyCat> Saizan: Can't you use command "split-window-vertically" ?
13:28:27 <Peaker> hmm.. is it me or do curried functions allow for a different kinds of polymorphism than non-curried ones?  e.g:  (forall a. a -> (forall b. b -> c)) is different from: (forall a b. (a, b)) -> c
13:29:08 <ManateeLazyCat> Peaker: Nested-Tuple, wait, i have some example code.
13:29:14 <Saizan> ManateeLazyCat: when i do C-c C-l on a freshly open .hs file, the *haskell* buffer is opened to take half of the vertical space, i'd like it to take just one third by default
13:29:30 <Saizan> ManateeLazyCat: i know i can change its size in various ways manually
13:30:57 * ManateeLazyCat pasted "curry polymorphism function code." at http://paste2.org/get/884338
13:30:58 <ManateeLazyCat> Peaker: Looks above.
13:31:40 <ManateeLazyCat> Saizan: Wait me second, i write elisp code for you. 
13:33:33 <Peaker> ManateeLazyCat: what's that about?
13:34:10 <Peaker> I was just wondering if when we have higher-ranked types, we get a fundamental difference between curried and uncurried forms
13:34:58 <ManateeLazyCat> Peaker: Sorry, i misunderstand, my code is show how to mix polymorphism function.
13:35:22 <Peaker> also, I am wondering if with the higher-rank extensions we can express the type:  forall a c. forall-impredicative-polytype b => (b -> c) -> (a -> b) -> a -> c     it seems to me that explicitly specifying that each of the given funcs has "b" as polymorphic is only an approximation of this type
13:36:04 <ManateeLazyCat> Saizan: You want your popup window always "thrid" or just *haskell* buffer?
13:36:04 <Peaker> Also, if we use an uncurried (.) we can do: (.) :: forall a c. (forall b. (b->c), (a->b)) -> a -> c) -- it doesn't seem we can represent this type in Haskell with a curried func
13:39:14 <illissius> it's really uncanny how other people mention problems in #haskell at approximately the same time as I'm encountering them
13:39:58 <ksf> Phyx-, http://www.youtube.com/watch?v=rY25bXvj1R0
13:39:59 <monochrom> because #haskell is the union of parallel universes.
13:40:36 <winxordie> monochrom: I think Murray Gell-Man would hate you for that.
13:40:45 <Phyx-> "The crisis of Infinite Haskell worlds"
13:41:04 <monochrom> with fixed points
13:41:21 <Saizan> ManateeLazyCat: just *haskell*
13:41:22 <Phyx-> ksf: as it so happens... I'm boiling honing macaronni atm :P
13:41:23 <winxordie> The Y combinator and the Superstrings.
13:41:26 <winxordie> An instant classic.
13:41:38 <monochrom> The Y String. <duck>
13:42:01 <ski> ManateeLazyCat : no curried `forall's in there, from what i can see ..
13:42:03 <ksf> (Y) ?
13:42:06 <winxordie> I prefer the Y-tensor.
13:42:07 <Phyx-> rofl
13:42:49 <Phyx-> ksf: lol, i don't get the super squirel
13:43:02 * Phyx- wishes he understood german
13:43:21 <ski> Peaker : `(.) :: forall a c. (forall b. (b->c), (a->b)) -> a -> c)' is wrong, the inner quantifier should be `exists', there
13:43:44 <ski> Peaker : what do you mean by `forall-impredicative-polytype b => ' ?
13:44:31 <ksf> Phyx-, http://karthik3685.files.wordpress.com/2008/01/skunk.jpg
13:44:40 <ksf> yeah skunks aren't squirrels
13:45:00 <ksf> and super skunk admittedly smells _way_ better.
13:45:07 <Phyx-> heh
13:45:20 <ski> Peaker : afaics, curried `forall's doesn't give you anything
13:45:42 * ManateeLazyCat pasted "function-for-Saizan" at http://paste2.org/get/884356
13:45:43 <ManateeLazyCat> Saizan: Bind "C-c C-l" with above fucntion 
13:46:10 <Saizan> ManateeLazyCat: thank you very much :)
13:46:13 <ski> (except possibly if you could match on `foo -> bar', where `bar' is a polytype, in `instance' declarations)
13:46:14 <ManateeLazyCat> Saizan: I set default height with 15, change to your height. :)
13:46:20 <Peaker> ski: Well, it seems like curry/uncurry is merely an asthaetic thing until you introduce higher-rank polymorphism
13:46:48 <ManateeLazyCat> Saizan: You have help me much about Haskell, as a emacser i try my best to help you. :)
13:46:52 <Peaker> ski: So I was wondering if that's true
13:47:12 <ksf> Phyx-, http://translate.googleusercontent.com/translate_c?hl=en&ie=ISO-8859-1&sl=de&tl=nl&u=http://www.free-lyrics.org/Joint-Venture/141913-Holland.html&prev=_t&rurl=translate.google.com&usg=ALkJrhi5uaq9tz_qOB8H60hB-2DrZO8zIQ 23068675 done  http://translate.googleusercontent.com/translate_c?hl=en&ie=ISO-8859-1&sl=de&tl=nl&u=http://www.free-lyrics.org/Joint-Venture/141834-Blau-Und-Blau.html&prev=_t&rurl=translate.google.com&usg=ALkJrhhu53Ybo13qbGWkD-LFnEIvhqF
13:47:12 <ksf> POg
13:47:16 <Peaker> ski: by forall-impredicative-polytype b  I mean a type variable "b" that captures a polymorphic type rather than a monotype
13:47:16 <ksf> zomg
13:47:28 <Phyx-> what a good case for tinyurl..
13:47:29 <Phyx-> :P
13:47:29 <ksf> ah.
13:47:44 <ksf> cut out half, that's too much of my status bar in there.
13:47:50 <ski> Peaker : it is true that you can't express `forall a c. (exists b. (b -> c,a -> b)) -> (a -> c)' without currying the function, yes
13:47:55 <Peaker> ski: I didn't mean the foralls are curried -- but that the function I want to type is curried
13:48:04 <Peaker> ski: great, thanks
13:48:07 <ManateeLazyCat> Saizan: In my function, 15 mean how many lines in *haskell* buffer, not pixel. :)
13:48:13 <Peaker> ski: isn't that a big reason to use uncurried form?
13:48:18 <Peaker> ski: when introducing higher-rank polymorphism?
13:48:20 <monochrom> haha 15 pixels
13:48:21 <Phyx-> ksf: lol
13:49:12 <ski> Peaker : by "curried `forall's" i meant your `forall a. a -> (forall b. b -> c)' vs. `forall a b. a -> b -> c'
13:49:23 <Peaker> ski: ah
13:49:29 <Peaker> ski: that's also valuable knowledge :)
13:49:42 <ski> (i just made up the term on the spot)
13:50:01 <ksf> google translate is utterly incapable.
13:50:06 <ski> hm, actually, you said `(forall a b. (a, b)) -> c' as second example
13:50:13 <ski> which is something else, entirely
13:50:18 <ksf> ...the title is "holland", and that's what's meant, not "netherlands"
13:50:34 <ski> Peaker : maybe you meant `(exists a b. (a,b)) -> c', here too ?
13:50:39 <Peaker> ski: I think I did
13:50:58 <Peaker> ski: actually that was just an example to illustrate why I thought curried/uncurried forms mattered, but you answered that already 
13:51:20 <ManateeLazyCat> ksf: Google translate use statistics.... :)
13:51:39 <ski> Peaker : higher-rank polymorphism is mostly for having polymorphic *arguments* to functions (and arguments to function arguments, &c.)
13:51:55 <ski> Peaker : none of the examples above did do that
13:52:27 <ManateeLazyCat> Peaker: I use nested-tuple as argument of polymorphism function.
13:53:22 <ManateeLazyCat> Peaker: Such as "foo :: (a,(b,(c,d))) -> IO ()" and "bar :: (a,(b,c)) -> IO ()"
13:53:31 <Peaker> ski: what really bothers me now is that when I enabled higher-rank types I can suddenly no longer trust the substitutions I always could: f (g x) -> (f . g) x   and I wish I could
13:53:47 <Peaker> ManateeLazyCat: why do you do that?
13:54:08 <Peaker> ski: It feels very wrong that that kind of equivalence is broken
13:54:38 <ski> Peaker : but yes, if you allow non-predicativity, then if you have `T -> forall a. U a', and pass that as argument to `forall x y. (x -> y) -> ...', then that can be different from passing `forall a. T -> U a'
13:54:39 <Peaker> ski: so the "exists b." thing for (.) is an attempt (perhaps misguided) to resolve this issue
13:55:20 <Saizan> ManateeLazyCat: yeah, i guessed that :)
13:55:28 <ski> Peaker : do you have an example of what you mean by not being able to trust substitutions ?
13:55:47 <ManateeLazyCat> Saizan: Works now? Or still have problem?
13:56:26 <ski> (Peaker : and is `f (g x) -> (f . g) x' a type there, or a rewrite rule of expressions ?)
13:56:42 <Peaker> ski: it's a manual rewrite in my text editor, that surprisingly fails :)
13:56:57 <ski> (ok, a rewrite rule, then :)
13:57:08 <ski> gimme the types
13:57:13 * ManateeLazyCat Long time haven't write elisp code, perhaps 1 year or more, i can't remember....
13:57:20 <Peaker> ski: I am not entirely certain about exactly the conditions under which this happened to me.. 
13:57:57 <Peaker> ski: I can try to reproduce it -- basically I had to convert use of (.) to explicit chaining "f (g x)" all over the place when I added higher-rank polymorphism to use ST
13:58:01 <EvanR> is ghc fully lazy?
13:58:21 <bremner> EvanR: what do you mean?
13:58:23 <Peaker> ski: I am a little confused by higher-rank polymorphism still :)
13:58:33 <ksf> EvanR, ghc (and haskell, by spec) is non-strict
13:58:45 <ksf> ...which is distinct from lazy.
13:58:45 <cheater99> anyone know where the name 'space cadet keyboard' comes from?
13:59:00 <EvanR> so no
13:59:05 <ksf> yes.
13:59:14 <ksf> but supercompilation might bring us nearer.
13:59:17 <ManateeLazyCat> Peaker: Look "keymap" in http://paste2.org/get/884338 , you will found every polymorphism function has different "input argument" and "output argument"
13:59:24 <ksf> at least in the eval-under-lambdas way.
13:59:29 <EvanR> whats supercompilation
13:59:45 <c_wraith> executing as much of the program at compile-time as possible.
13:59:47 <ksf> a cool aspect of partial evaluation
14:00:03 <ksf> that is, the thing that's partial evaluation and not mere constant propagation.
14:00:07 <gwern> 'Thanks for the info about /dev/urandom, I found a useful Perl program in there.
14:00:19 <gwern> cheater99: it came from mit
14:00:32 <cheater99> no, it came from symbolics
14:00:43 <ksf> it would, for example, eliminate almost all use cases of ghc rules
14:00:54 <gwern> cheater99: which is mit for all intents and purposes
14:00:57 <ksf> so stream-fusion would fuse even without fiddling.
14:01:06 <cheater99> well, was
14:01:15 <Peaker> ManateeLazyCat: do you use higher-rank polymorphism there?
14:01:28 <Peaker> ski: do you expect what I described about (.) to not happen?
14:01:31 <gwern> ksf: yeah, but RULES were a lot easier to add than partial evaluation, as evidenced by us having the former for years and not the latter
14:01:51 <ksf> I'm not arguing against them
14:02:11 <ksf> cf. e.g. head . sort = minimum
14:02:25 <ksf> or other non-obvious stuff.
14:03:07 <ski> Peaker : hm, at least previously `runST $ ...' didn't work in GHC, because `...' was passed monomorphized to `($)'
14:03:13 <ksf> but the cool thing is that supercompilation will fire in many cases where it'd be just inefficient (in terms of manhours) to write RULES
14:03:16 <ManateeLazyCat> Peaker: I don't know what's the "higher-rank polymorphism", i make a polymorphism define like this : "fun :: forall a b . (ActionInputArgs a . ActionOutputArgs b) => a -> IO b" 
14:03:23 <gwern> 'Where it got ugly (a.k.a. "fun") was that the permissions on the device files were wide open (I'm not a UNIX guru, but I seem to recall that this should not be the case), so that anybody could rshell into any SPARC there and cat  random crap into /dev/audio, thereby killing the poor thing. Furthermore, /dev/tty* was permissioned writeable for everybody too: You could cat bogus error messages to the user's shell tools before crashing the computer ...
14:03:23 <Peaker> ski: how was that fixed?
14:03:27 <ski> i
14:03:29 <gwern> ... ("system going down for black mass, please log off. Hail Satan!"1)'
14:03:30 <ski> i'm not sure
14:03:40 <Peaker> ManateeLazyCat: you don't need to explicitly write the "forall a b." there do you?
14:03:58 <ski> (i can't seem to provoke the error in GHC atm, now)
14:04:01 <ManateeLazyCat> Peaker: So the class ActionInputArgs pick any value from Environment, and ActionOutputArgs to write back to Environment.
14:04:03 * ski tries earlier version
14:04:11 <Peaker> ski: maybe you can try to use: runST . forever $ ... ?
14:04:17 <ksf> gwern, that's the point where you should leave the root password empty so people would feel guilty when abusing it.
14:04:17 <EvanR> ksf: RULES?
14:04:35 <ManateeLazyCat> Peaker: Then *any* type use instance to build polymorphism function argument.
14:04:51 <gwern> I vaguely remember some paper on doing partial evaluation using typeclasses
14:04:57 <gwern> I don't remember how that could even work
14:05:20 <ski> hm, in older GHC, i indeed get "Inferred type is less polymorphic than expected" error, with `runST $ ...'
14:05:22 <Peaker> ManateeLazyCat: but this "forall" would be implied even if you didn't write it?
14:05:24 <ManateeLazyCat> Peaker: Since i use nested-tuple (a,(b,c)), you just need write instance for a, b and c, then we can match-type for any nested-tuple 
14:05:36 <ksf> EvanR, http://tinyurl.com/34nunhg
14:05:37 <Peaker> ski: in new ghci it fails to do: "runST . forever $ ..."
14:05:56 <ManateeLazyCat> Peaker: Infact, i need forall in "data Action = forall a b . (ActionInputArgs a, ActionOutputArgs b) => Action {actionFun :: a -> IO b}"
14:06:00 <EvanR> ksf: you bastard!
14:06:08 <Peaker> ManateeLazyCat: for the existential, ah
14:06:15 * ksf grins wickedly
14:06:26 <Peaker> ski: but it succeeds to use: "runST (forever $ ...)"
14:06:33 <ManateeLazyCat> Peaker: Action is type wrap polymorphism function to pass type-check.
14:06:34 <Peaker> ski: This is extremely worrying to me
14:06:49 <ManateeLazyCat> Peaker: Otherwise, different polymorphism function is mismatch.
14:06:51 <ski> Peaker> :t runST . forever
14:06:55 <Peaker> ski: as to the practicality of real-world use of higher-ranks (though I admit I am not fully understanding things)
14:07:36 <Peaker> ski: Yeah.. "m" cannot be instantiated to be (forall s. ST s) at least not automatically
14:07:44 <ManateeLazyCat> Peaker: Maybe have better solution than mine, i just know Nested-Tuple to implement polymorphism function.
14:08:11 <ski> ManateeLazyCat : as far as i can determine, you're not talking about (proper) higher-rank polymorphism at all
14:08:32 <ManateeLazyCat> ski: I even don't know what's the "higher-rank polymorphism".
14:08:41 <ksf> just curious: does lmgtfy always use a black cursor or does it actually detect me using X or such?
14:09:07 <ksf> it's even doing the cursor shadow thing!
14:09:43 <gwern> no doubt that's just css hackery
14:10:17 <ski> (though your `(==>) :: forall a b . (ActionInputArgs a, ActionOutputArgs b) => Text -> (a -> IO b) -> (Text, exists a b . (ActionInputArgs a, ActionOutputArgs b) *> a -> IO b)' is in some sense related to higher-rank polymorphism, but for `exists' rather than for `forall', i guess)
14:11:09 <ski> ManateeLazyCat : if you have `foo :: (forall a. ..a..) -> ...', then `foo' is a function with higher-ranked type : because `forall' occurs in the argument type
14:11:40 <ksf> http://webcache.googleusercontent.com/search?btnG=1&pws=0&q=cache%3Almgtfy.com+Dear+God%3A+make+it+stop
14:12:50 <ski> Peaker : so what type error do you get with `runST . forever' ?
14:12:56 <ski> "Inferred type is less polymorphic than expected" ?
14:13:00 <ManateeLazyCat> ski: That's the higher-rank polymorphism? I have use it everywhere, but i don't know what's it, i just understand it and write code along with my feeling.
14:13:06 <hpc> ksf: diabolical!
14:13:22 <ski> ManateeLazyCat : in <http://paste2.org/get/884338>, you use it nowhere, at least
14:13:24 <Peaker> ski: yes
14:13:48 <ManateeLazyCat> ski: BTW, i have seen many people talk keyword "exists", what's the different "exists" and "forall" ?
14:13:52 <ski> ManateeLazyCat : note that `(==>) :: forall a b . (ActionInputArgs a, ActionOutputArgs b) => Text -> (a -> IO b) -> (Text, Action)' is not a higher-ranked type signature
14:14:19 <ski> ManateeLazyCat : what's the difference between "every cat is blue" and "some cat is blue" ? :)
14:14:21 <ManateeLazyCat> ski: Can you write a *simple* higher-ranked type signature?
14:14:33 <ManateeLazyCat> ski: I see.
14:14:56 <EvanR> ski: is the someone equivalent to 'at least one cat is blue' ?
14:15:03 <ski> ManateeLazyCat : one of the simplest examples of a higher-ranked type is that of `runST' : `runST :: forall a. (forall s. ST s a) -> a'
14:15:05 <EvanR> s/someone/second one/ o_O
14:15:17 <ski> EvanR : sure :)
14:15:20 <ManateeLazyCat> ski: Nested forall?
14:15:20 <EvanR> ok
14:15:33 <ski> ManateeLazyCat : not merely nested
14:15:39 <Peaker> ski: how can (runST . forever) be made to work?
14:15:58 <Peaker> without re-implementing (.) in-place here
14:16:05 <ski> e.g. `forall a. [a] -> forall b. (a -> b) -> [b]' would not be a (proper) higher-ranked type
14:16:41 <ski> ManateeLazyCat : the important part re higher-rankedness in `runST :: forall a. (forall s. ST s a) -> a' is that the `forall s.' occurs in the *argument* of the function type
14:17:21 <ski> ManateeLazyCat : if we take `runSTBool :: (forall s. ST s Bool) -> Bool; runSTBool ma = runST ma', then this is *still* higher-ranked
14:18:34 <ski> Peaker : i'm not really sure why `runST $ ...' works in GHC now, but apparently whatever fix they use doesn't work in the more complicated example `runST . forever $ ...'
14:18:57 * ski ponders it
14:20:27 <Peaker> @type runST . forever
14:20:28 <lambdabot>     Couldn't match expected type `forall s. ST s a'
14:20:28 <lambdabot>            against inferred type `m b'
14:20:28 <lambdabot>       Expected type: m a1 -> forall s. ST s a
14:20:35 <Peaker> @type runST $ return ()
14:20:36 <lambdabot> ()
14:20:39 <ManateeLazyCat> ski: My function use forall before "=>", but higher-rankedness use "forall" as funciton argument, right?
14:20:40 <Peaker> @type (runST $)
14:20:41 <lambdabot> forall a. (forall s. ST s a) -> a
14:21:00 <ski> @type (runST Prelude..)
14:21:01 <lambdabot> forall a a1. (a1 -> forall s. ST s a) -> a1 -> a
14:21:10 <ski> @type (runST Prelude.. forever)
14:21:11 <lambdabot>     Inferred type is less polymorphic than expected
14:21:11 <lambdabot>       Quantified type variable `s' escapes
14:21:11 <lambdabot>     In the second argument of `(GHC.Base..)', namely `forever'
14:21:31 <Peaker> ski: :t (runST $) fails here, with: "Cannot match a monotype with `forall s. ST s a'"
14:21:43 <ski> ManateeLazyCat : yes, you only use `forall' at the "top level" of your type signatures
14:22:19 <ManateeLazyCat> ski: What's the biggest advantage of higer-rank polymorphism function, can you explain it simply?
14:22:33 <ski> Peaker : that's probably `ImpredicativeTypes' in lambdabot
14:22:36 <ManateeLazyCat> more simple example?
14:23:08 <Peaker> ski: I enable it and it still happens
14:23:50 <ski> ManateeLazyCat : normally, if you try to pass a polymorphic function, say `foo' as *argument* to another function, say `bar', then you can still only use `foo' as a monomorphic function inside the definition of `bar'
14:23:53 <Peaker> ManateeLazyCat: in the case of ST, for example, it guarantees that the caller cannot choose an "s", but must allow for all "s"
14:24:36 <Peaker> @type (\sho -> (show [1,2,3], show 'x'))
14:24:37 <lambdabot> forall t. t -> (String, String)
14:24:46 <Peaker> @type (\sho -> (sho [1,2,3], sho 'x'))
14:24:47 <lambdabot>     Couldn't match expected type `Char' against inferred type `[t]'
14:24:47 <lambdabot>       Expected type: Char -> t1
14:24:47 <lambdabot>       Inferred type: [t] -> t2
14:25:02 <Peaker> @type (\(sho :: forall a. Show a => a -> String) -> (sho [1,2,3], sho 'x'))
14:25:03 <lambdabot> (forall a. (Show a) => a -> String) -> (String, String)
14:25:28 <Peaker> ManateeLazyCat: "sho" is mono-typed in the early examples and poly-typed in the latter
14:25:49 <ski> ManateeLazyCat : it can be used to be able to let the callee decide to call the argument function at several different instances of the polymorphic function argument
14:27:30 <ski> ManateeLazyCat : it can also be used for abstraction, not saying in the type of the function `bar' which instance of the polymorphic argument `foo' you want to use .. also, that way the caller is required to pass a polymorphic function `foo`, so can't depend on the actual instance wanted by `bar'
14:27:55 <monochrom> > let {user :: (forall a. a->a) -> (Bool,Char); user f = (f True, f 'x')} in user id
14:27:56 <lambdabot>   (True,'x')
14:28:45 <monochrom> > let {user :: forall a. (a->a) -> (Bool,Char); user f = (f True, f 'x')} in user id
14:28:46 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:28:46 <lambdabot>         against inferred type ...
14:29:00 <monochrom> (against inferred type Char)
14:29:29 <monochrom> <3 RantNTypes
14:29:49 <ManateeLazyCat> ski: Can you recommend me some link for study deeply? i'm interested higher-rank polymorphism.
14:29:50 * ski rants `n` types
14:30:53 <ski> ManateeLazyCat : i can't recall any link on the top of my head .. maybe the GHC docs points to some papers ?
14:31:17 <EvanR> is there a haskell type with no values? is there a value with no type?
14:31:17 <ReinH> Hi folks. I need a function Int -> String that returns the base 3 notation for a given number. 
14:31:21 <ReinH> Google has been less than helpful
14:31:43 <EvanR> :t showIntegerAtBase
14:31:44 <lambdabot> Not in scope: `showIntegerAtBase'
14:31:56 <ski> @type showIntAtBase
14:31:56 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:32:19 <ReinH> where can I find this? http://haskell.org/hoogle/?hoogle=showIntegerAtBase shows no results
14:32:26 <EvanR> i spelled it wrong
14:32:29 <ReinH> oh ha!
14:32:32 <Zao> hayoo maybe?
14:32:34 <ReinH> I should read :)
14:33:04 <mauke> :t showIntAtBase 3 intToDigit 123
14:33:05 <lambdabot> String -> String
14:33:08 <mauke> > showIntAtBase 3 intToDigit 123 ""
14:33:09 <lambdabot>   "11120"
14:33:15 <ReinH> beaut, thanks :)
14:33:16 <ski> @type showIntAtBase 3 intToDigit `flip` ""
14:33:17 <lambdabot> forall t. (Integral t) => t -> String
14:33:17 <ski> > (showIntAtBase 3 intToDigit `flip` "") `map` [0..9]
14:33:18 <lambdabot>   ["0","1","2","10","11","12","20","21","22","100"]
14:33:55 <mauke> EvanR: type with no values? not really, all types contain bottom
14:34:00 <mauke> does that count as a real value?
14:34:20 <EvanR> > isReal undefined
14:34:21 <lambdabot>   Not in scope: `isReal'
14:34:34 <sinelaw> :t bottom :: ()
14:34:35 <lambdabot> Not in scope: `bottom'
14:34:39 <sinelaw> oops
14:34:50 <sinelaw> :t undefined :: ()
14:34:50 <lambdabot> ()
14:34:57 <Tarrasch> Has anyone finished the work task in the book "The Haskell School of Expression" where you are supposed to add features to the paddleball-game? I'm trying hard but I keep failing and failing. Do anybody have possibility to give me their solutions?
14:35:22 <ski> EvanR : `{-# LANGUAGE EmptyDataDecls #-}' and `data Void'
14:35:27 <sinelaw> Tarrasch i didn't read that book. homework?
14:35:44 <Tarrasch> sinelaw, No, personal study
14:35:49 <ski> @djinn a -> Not a -> b
14:35:49 <lambdabot> f a b = void (b a)
14:35:56 <mauke> Void has only bottom values
14:35:56 <EvanR> @src Void
14:35:57 <lambdabot> Source not found. Are you on drugs?
14:36:00 <sinelaw> Tarrasch did you try Real World Haskell?
14:36:03 <mauke> EvanR: data Void
14:36:13 <SonOfLilit> Hello
14:36:15 <sinelaw> EvanR: Are you on drugs?
14:36:17 <ski> @djinn (Either a b -> Void) -> (a -> Void,b -> Void)
14:36:17 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
14:36:19 <Tarrasch> sinelaw, No 
14:36:20 <SonOfLilit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26385#a26385
14:36:28 <SonOfLilit> can anyone explain this strange error?
14:36:33 <sinelaw> Tarrasch may be worth taking a look at.
14:36:35 <sinelaw> @where rwh
14:36:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:36:44 <sinelaw> Tarrasch ^^^^
14:37:25 <mauke> there's a way to define Void without using extensions, btw
14:37:38 <Tarrasch> sinelaw, hmm, do they have any examples where they are using reactive animations with "Incremental Sampling"?
14:37:52 <sinelaw> Tarrasch no, i don't think so. are you using YampA?
14:37:55 <sinelaw> Yampa, that is
14:38:09 <EvanR> mauke: how
14:38:23 <Tarrasch> sinelaw, nope, I use the one book's own EL 
14:38:25 <ManateeLazyCat> Tarrasch: Also, in "The Haskell School of Expression", has a GUI library, you can use "cabal install gtk2hs-buildtools && cabal install soegtk" to install it.
14:38:31 <sinelaw> Tarrasch ah ok
14:38:36 <mauke> newtype Abyss = Gaze Abyss
14:38:52 <sinelaw> mauke: meh
14:39:14 <EvanR> that means theres no way to construct the one value
14:39:21 <Tarrasch> ManateeLazyCat, I'm not having trouble to run the examples or use the provided tools, it's the tasks themselfes that are too complicated for me (shamefully :-/)
14:39:36 <ksf> but that's distinguishable from other bottoms.
14:39:45 <mauke> EvanR: what one value?
14:39:51 <sinelaw> @src undefined
14:39:51 <lambdabot> undefined =  error "Prelude.undefined"
14:39:57 <EvanR> the infinite applications of Gaze
14:39:59 <ManateeLazyCat> Tarrasch: Yes, i know, just give you information about "SOE". :)
14:40:06 <sinelaw> @src error
14:40:06 <lambdabot> error s = throw (ErrorCall s)
14:40:07 <mauke> EvanR: fix Gaze 
14:40:10 <sinelaw> @src throw
14:40:10 <lambdabot> throw exception = raise# exception
14:40:10 <EvanR> oh
14:40:10 <mauke> easy
14:40:13 <Tarrasch> ManateeLazyCat, ok, thanks :)
14:40:15 <sinelaw> @src raise
14:40:15 <lambdabot> Source not found. You type like i drive.
14:40:26 <EvanR> then, that value
14:40:41 <c_wraith> raise != raise#
14:40:44 <mauke> then what does 'fix Gaze' do?
14:40:45 <sinelaw> @src raise#
14:40:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:41:00 <c_wraith> yes, well, and the # typically indicates a primitive. :)
14:41:03 <EvanR> returns to you a value of type Abyss
14:41:17 <sinelaw> c_wraith yeah i knew. just to answer your comment :) i'm silly.
14:41:27 <ManateeLazyCat> ski: Thanks for you tips, i will read some pagers about higher-rank polymorphism, looks pretty powerful...  
14:41:34 <mauke> > fix id
14:41:38 <lambdabot>   mueval-core: Time limit exceeded
14:41:41 <c_wraith> > fix error
14:41:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:41:45 <EvanR> lame
14:41:45 <mauke> actually it doesn't return :-)
14:41:50 <EvanR> fix is too strict
14:41:52 <ski> @tell Peaker if you look at `runST . forever', we have `runST :: forall a. (forall s. ST s a) -> a' and `forever :: forall m a b. Monad m => m a -> m b'. we instantiate to get `runST :: (forall s. ST s y) -> y',`forever :: forall s. ST s x -> ST s y' (the latter generalized on `s'). now i think the problem is that `(.)' really wants `forever :: (forall s. ST s x) -> forall s. ST s y', but probably GHC won't infer this
14:41:53 <lambdabot> Consider it noted.
14:42:09 <c_wraith> fix is exactly as strict as it needs to be.
14:42:25 <EvanR> let x = 1:x in x
14:42:31 <EvanR> > let x = 1:x in x
14:42:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:42:34 <EvanR> > let x = x in x
14:42:35 <sinelaw> > fix (\x -> x*x - 3*x + 3)
14:42:38 <lambdabot>   mueval-core: Time limit exceeded
14:42:38 <lambdabot>   mueval-core: Time limit exceeded
14:42:40 <mauke> > fix (1 :)
14:42:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:42:43 <ManateeLazyCat> I wonder how much advanced technology hide in paper?
14:42:51 <sinelaw> > fix (\x -> x*x + 3*x + 3)
14:42:54 <lambdabot>   mueval-core: Time limit exceeded
14:43:06 <sinelaw> > fix (\x -> x*x + 3*x )
14:43:06 <EvanR> mauke: so back to what i was saying, theres no way to construct the one value
14:43:09 <lambdabot>   mueval-core: Time limit exceeded
14:43:12 <sinelaw> zero, dammit
14:43:28 <mauke> EvanR: what "one value"?
14:43:33 <ski> EvanR : there is no value in `Void' to construct, not counting bottom
14:43:37 <EvanR> Gaze Gaze Gaze Gaze Gaze ...
14:43:44 <mauke> if you do count bottom, what's there to construct?
14:43:50 <Tarrasch> > cycle "Gaze"
14:43:51 <lambdabot>   "GazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGazeGa...
14:43:53 <EvanR> ski: data Abyss = Gaze Abyss
14:44:00 <ski> EvanR : no
14:44:00 <mauke> EvanR: no, that's wrong
14:44:03 <ski> s/data/newtype/
14:44:06 <ski> that's important
14:44:09 <mauke> that actually contains distinguishable values
14:44:18 <SonOfLilit> I'm really stuck with that error I posted
14:44:24 <EvanR> hrm, now im seeing a difference between single data and newtype
14:44:28 <SonOfLilit> can anyone please look at it? :)
14:44:47 <EvanR> what is it
14:45:11 <ksf> SonOfLilit, that's not a strange error
14:45:12 <ManateeLazyCat> Sleep now, bye all (05:45 am)
14:45:18 <ksf> look at your type signatures
14:45:31 <ksf> one says (Score, Int), the other (Score, BoardState)
14:45:31 <SonOfLilit> I did
14:45:37 <ksf> those aren't the same.
14:45:41 <SonOfLilit> what, where?
14:45:45 <SonOfLilit> I'll look agai
14:45:47 <SonOfLilit> n*
14:45:59 <ksf> generateSortedMoves and reverseScore
14:46:22 <SonOfLilit> correct
14:46:25 <SonOfLilit> thank you
14:46:41 <SonOfLilit> I was looking over it like only an author of a blatant error can
14:47:10 <mietek> Is there another way to pattern match ('f' : 'o' : 'o' : bar) ?
14:47:17 <ski> EvanR : with `data Abyss = Gaze Abyss', `_|_' is (semi-)distinguishable from `Gaze _|_' .. using s/data/newtype/ instead, there's no difference
14:47:23 <mauke> mietek: sadly, no
14:47:37 <ski> > let foo ('f' : 'o' : 'o' : bar) = bar in foo "foobar"
14:47:37 <lambdabot>   "bar"
14:48:29 <ski> > let foo foobar | Just bar <- stripPrefix "foo" foobar = bar in foo "foobar"
14:48:30 <lambdabot>   "bar"
14:48:47 <ski> > let foo (stripPrefix "foo" -> Just bar) = bar in foo "foobar"
14:48:48 <lambdabot>   "bar"
14:48:52 <ski> mietek : ^
14:49:19 <ski> the middle one uses pattern guards, the latter one uses view patterns
14:49:24 <mietek> Whoa.
14:49:25 <ski> of course you can also do
14:49:29 <mietek> I had no idea about those.
14:49:44 <ski> > let foo foobar = case stripPrefix "foo" foobar of Just bar -> bar in foo "foobar"
14:49:45 <lambdabot>   "bar"
14:50:07 <ski> (but then you can't fall-though to another equation, in case the matching fails)
14:50:18 <ski> @type stripPrefix
14:50:19 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
14:51:47 <ski> EvanR : iow, with `newtype', the data constructor `Gaze' is strict; with `data', it isn't
14:52:14 <EvanR> so data effectively makes thunks, and newtype constructors dont
14:52:18 <ski> right
14:52:43 <ski> matching on a `newtype' constructor is operationally a no-op ("O(0)")
14:52:53 <ksf> newtypes are guaranteed not to exist at runtime
14:52:58 <ski> (and wrapping a `newtype' constructor as well)
14:53:00 <ksf> but, semantically, they're still there
14:53:05 <mietek> > let x = fromJust . stripPrefix in let foo (x "foo") in foo "foobar"
14:53:06 <lambdabot>   <no location info>: parse error on input `in'
14:53:21 <ksf> which is why mauke is wrong, his void type is distincly different from the real void type.
14:53:40 <ksf> THERE ARE NO OPERATIONAL SEMANTICS!
14:53:40 <mauke> ksf: prove it
14:53:44 <ski> note btw, that `data Abyss = Gaze !Abyss' would also work as a `Void' type .. in this case
14:53:45 <ksf> QED
14:54:11 <mauke> what
14:54:17 <ksf> THERE ARE NO OPERATIONAL SEMANTICS!
14:54:26 <mauke> I don't even know what that means
14:54:36 <EvanR> there is no spoon
14:54:54 <ksf> data and newtype are a runtime difference, but there's no runtime in Proper Semantics(tm)
14:55:06 <mauke> so?
14:55:15 <SonOfLilit> @pl format (sc, st) = Just (sc, lastMove st)
14:55:15 <lambdabot> format = uncurry ((Just .) . (. lastMove) . (,))
14:55:20 <ksf> the only Real Void Type(tm) is data Void;
14:55:25 <mauke> can you write code that behaves differently wrt Void vs Abyss?
14:55:26 <ski> EvanR : but matching on a `data' constructor still forces the value (and the argument, if the constructor was strict in it); while matching on a `newtype' constructor doesn't force
14:55:31 <mauke> or at least could behave differently?
14:55:43 <ksf> see, you're arguing operationally, again.
14:55:48 <EvanR> ski: thats confusing
14:55:56 <ksf> it's not about how stuff behaves, but what it means.
14:56:06 <ski> EvanR : i.e. if you do `case fix Gaze of Gaze _ -> ()' that'll terminate with `newtype', but not terminate with `data', regardless of whether the argument is strict or not
14:56:16 <mauke> ksf: a value is the operations you can perform on it
14:56:28 <mauke> if you can't observe a difference, there is none
14:57:19 <ksf> sure I can see a difference between Abyss and void. That contemporary haskell implementaitions can't is unimportant.
14:57:34 <mauke> what difference do you see?
14:57:43 <ksf> one has a constructor, the other doesn't.
14:57:46 <EvanR> void is a value of type Void?
14:57:47 <mauke> meh
14:57:50 <ski> (imo, `EmptyDataDecls' ought to also enable `case blah of {}' .. this could possibly be useful with GADTs, as well)
14:58:13 <ski> EvanR,ksf : `void :: forall a. Void -> a' :)
14:58:22 <mauke> ksf: put them in their own module, don't export constructors
14:58:24 <ski> @djinn Void -> a
14:58:25 <lambdabot> f = void
14:58:36 <EvanR> ski: i.e. const?
14:58:45 <ski> no
14:58:55 <EvanR> :t seq
14:58:56 <lambdabot> forall a t. a -> t -> t
14:58:58 <EvanR> hrm
14:59:01 <EvanR> :t const
14:59:02 <lambdabot> forall a b. a -> b -> a
14:59:12 <EvanR> :t id
14:59:13 <lambdabot> forall a. a -> a
14:59:31 <EvanR> :t error
14:59:32 <lambdabot> forall a. [Char] -> a
14:59:44 <ski> morally, we have `void v = case v of {}' (assuming `data Void') .. but that's not valid syntax
15:00:13 <EvanR> > void 5
15:00:14 <lambdabot>   Not in scope: `void'
15:00:14 <Saizan> even if the constructor is there the denotational semantics tell you that matching on it doesn't distinguish between "undefined" and "Constr undefined", they both successfully match "Constr x", so it's not an artifact of implementations
15:00:25 <ski> `void' is the case/fold operation on `Void', just as `either' is the corresponding one on `Either
15:00:28 <ski> '
15:00:30 <ski> @type either
15:00:30 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:00:46 <ski> EvanR : you can only pass expressions of type `Void' to `void'
15:00:57 <EvanR> ah right
15:01:09 <ski> (and only `@djinn' knows about `void', in lambdabot)
15:01:51 <ski> `either' takes two function arguments, corresponding to the two branches that you have when matching on `Either a b'
15:02:07 <ski> `void' takes zero function arguments, corresponding to the zero branches that you have when matching on `Void'
15:02:55 <EvanR> why doesnt 'returns nothing' IO actions have type IO Void
15:03:04 <ski> they could have ..
15:03:17 <EvanR> () is kind of, something
15:03:20 <ski> .. but then one'd have to insert `void' where appropriate
15:03:31 <ski> there are arguments both for and against
15:03:41 <ski> i.e.
15:03:43 <Saizan> when i see "IO Void" i interpret it as an action that never returns
15:03:44 <ski> @type forever
15:03:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:03:50 <ski> could have had type
15:04:01 <ski>   forever :: Monad m => m a -> m Void
15:04:01 <Saizan> while IO () as an action that does return with no interesting result
15:04:44 <ski> EvanR : .. right, i was assuming that when you said "returns nothing", you really meant "doesn't (monadically) return"
15:04:58 <EvanR> no, like this
15:05:00 <EvanR> :t when
15:05:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:05:07 <ski> that's quite another thing
15:05:12 <ski> you can't use `Void' there
15:05:18 <EvanR> why
15:05:33 <ski> because `when False blah' is `return ()'
15:05:46 <ski> it monadically returns when you pass `False'
15:06:00 <pielgrzym> hi :) I'm doing this tutorial: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
15:06:09 <EvanR> it returns either way, but in neither case returns a value of significance
15:06:10 <ski> so the return type can't be `Void', since that would only work if it never (monadically) returned
15:06:22 <EvanR> main :: IO Void
15:06:23 <pielgrzym> I've made the simple bot (and I'm shocked how less effort it takes to create one in haskell than in python...)
15:06:40 <ski> EvanR : "returns without a value of significance" is very different from "not returning at all"
15:06:46 <pielgrzym> could someone explain me this line: eval h x | "!id " `isPrefixOf` x = privmsg h (drop 4 x)
15:06:53 <pielgrzym> eval takes arguments h x
15:06:58 <EvanR> we are equating returning with having a return value
15:07:03 <pielgrzym> the pipe is doing what exactly?
15:07:29 <EvanR> if all the types matched up, no return value wouldnt be a big deal
15:07:31 <ski> pielgrzym : the `| "!id " `isPrefixOf` x' is called a "guard", and specifies a boolean condition under which this equation is chosen
15:07:43 <pielgrzym> ski: aaaaah
15:07:57 <ski> pielgrzym : if `"!id " `isPrefixOf` x' returns `False', the next equation (or guard) will be tried instead
15:07:59 <pielgrzym> ski: indeeed :/ damn, I read about guards yesterday and manage to forget this :/
15:08:12 <pielgrzym> ski: thanks a lot! :)
15:09:36 <ski> pielgrzym : btw, using pattern guards, which we gave an example of 20 minutes ago, you could write that as `eval h x | Just foo <- "!id " `stripPrefix` x = privmsg h foo'
15:10:22 <ski> (that might be considered clearer .. if you get what pattern guards does, and are willing to enable that language extension)
15:10:51 <pielgrzym> ski: it's kinda hard for me to understand the Maybe monad and this Just thingie :/ altough I just wrote a small app that uses patterns a lot to process arguments and return a nice string into a fifo :)
15:11:19 <EvanR> see? newbs get confused when Maybe is emphasized as a monad
15:11:23 <ski> EvanR : yes, returning in the context of functional programming means returning with a value
15:11:30 <EvanR> first thing is first its a data type
15:11:37 <ski> pielgrzym : no `Maybe' monad used in there at all
15:11:47 <ski> just ordinary matching (and a pattern guard)
15:12:06 <pielgrzym> EvanR: well, I didn't understand it when I didn't know it's a monad either ;) I just did some investigation ;P
15:12:16 <pielgrzym> ski: I see :)
15:12:56 <ski> pielgrzym :  "!id " `stripPrefix` x  returns `Nothing' if `x' doesn't begin with `"!id "', and returns `Just foo' when it does, in which case `foo' is the rest of `x'
15:13:25 <EvanR> ski: you could say a string is a list of chars. but there is this weird thing called empty list, which is valid and useful. there can also be 'no value' of type Void
15:13:28 <ski> pielgrzym : so, we match the result of this with the pattern `Just foo', so if the result was actually `Nothing' that match fails, and the next equation will be tried
15:13:50 <dMazz> Monads for teh win!
15:14:23 <ski> EvanR : how is the empty list weird ? ;)
15:14:28 <EvanR> ski: no chars
15:14:40 <Sadache> i am looking for a simple api for doing web requests (get,post,put....) in Haskell
15:14:42 <EvanR> null space
15:14:49 <ski> EvanR : also, the empty list is still a value. and the value `()' is still a value, even if it isn't interesting
15:15:00 <ski> otoh, there *is*no* valud of type `Void'
15:15:24 <ski> so "there can also be 'no value' of type Void" is false
15:15:27 <cheater99> anyone know where the name 'space cadet keyboard' comes from?
15:15:34 <pielgrzym> ski: hmmm
15:15:50 <EvanR> yes, we regularly use the concept of zero value, empty list, a structure taking up zero space, might as well have a function return literally nothing
15:15:52 <mle> cheater99: the mod keys
15:15:53 <ski> pielgrzym : have you see `case' yet ?
15:15:54 <tensorpudding> From the real space cadet keyboard?
15:15:56 <mle> hyper super, etc
15:16:06 <EvanR> ski: expand your mind ;)
15:16:25 <pielgrzym> ski: case statement? yes :) although I haven't used it yet :)
15:16:41 <ski> EvanR : i'm just pointing out that "empty" value is very different from "can't be any value at all"
15:16:49 <cheater99> mle: i don't see the connection
15:17:16 <EvanR> ski: yes, the second one is the breakthrough we need to get to the next level ;)
15:17:25 <EvanR> like when they discovered zero
15:17:25 <cheater99> mle: can you elaborate?
15:17:50 <ski> pielgrzym : having `eval h x | Just foo <- "!id " `stripPrefix` x = privmsg h foo' and then `eval h x = ..other cases..' is similar to `eval h x = case "!id " `stripPrefix` x of Just foo -> privmsg h foo; _ -> ..other cases..'
15:19:53 <ski> EvanR : very loosely speaking, in terms of bits : a value of type `Bool' takes `1' bit; a value of type `(a,b)' takes `m + n' bits, provided values of type `a' and `b' take `m' and `n' bits; a value of type `()' takes `0' bits; but a value of type `Void' takes `-infinity' bits
15:20:21 <ski> (but then there cannot actually be any valued of type `Void', so the `-infinity' there doesn't matter)
15:20:44 <EvanR> -infinity bits
15:21:23 <EvanR> i wonder how compressible would be
15:22:01 <ski> > logBase 2 (genericLength ([minBound .. maxBound] :: [Ordering]))
15:22:01 <lambdabot>   1.5849625007211563
15:22:04 <ski> > logBase 2 (genericLength ([minBound .. maxBound] :: [Bool]))
15:22:05 <lambdabot>   1.0
15:22:07 <ski> > logBase 2 (genericLength ([minBound .. maxBound] :: [()]))
15:22:08 <lambdabot>   0.0
15:22:28 <cheater99> mle: still alive? :)
15:22:30 <EvanR> this sort of extrapolation is dangerous ;)
15:22:33 <ski> > logBase 2 `map` [3,2,1,0]
15:22:34 <lambdabot>   [1.5849625007211563,1.0,0.0,-Infinity]
15:22:39 <EvanR> watch out for 0^0
15:23:14 <ski> EvanR : :) i was just trying to give you a feel for how `Void' is very different from `()'
15:23:30 <EvanR> ski: yes with a difference of +infinity bits
15:23:39 <EvanR> you people are insane
15:23:48 <ski> ty
15:24:52 <gwern> cheater99: you ever see the inside of a space module? ever see the space cadet keyboard? familiar with the derogatory phrase 'space cadet'?
15:24:59 <gwern> it's crystal clear
15:25:20 <gwern> sheesh
15:25:59 * BMeph always wondered why his module was full of space...well, he knows now.
15:26:08 <absz> Does anybody know a way to print an MVector (from the "vector" package)?  Unsafely is fine, as I just need this for debugging
15:26:11 <gwern> BMeph: because that's how you indent :)
15:26:20 <cheater99> gwern: no, what is a 'space cadet'?
15:26:58 <BMeph> absz: Think VERY carefully about what you're asking... ;)
15:27:18 <absz> I know, I know :)
15:27:43 <BMeph> absz: For example, an MVector depends on the "M" you're dealing with... :)
15:27:56 <absz> Alternatively, a way to copy its values into a list/non-multable vector would be fine
15:28:08 <gwern> good grief
15:28:12 <gwern> lead a horse to water...
15:31:08 <cheater99> A person who tends to space out often. He or she does not respond when directly spoken to. The space cadet is not necessarily a person of low intelligence or a heavy drug user, but rather one who is so easily lost in reverie that he or she loses all awareness of the surrounding physical world.
15:31:18 <cheater99> still don't see any sort of connection with a keyboard.
15:31:43 <gwern> I no longer have the heart to explain. take your questions to #lisp
15:31:53 <mreh> cuss?
15:32:12 <cheater99> you started explaining, why don't you finish it?
15:32:57 <gwern> because I am a bad teacher who can only be bothered for apt pupils
15:33:01 <gwern> which you are not
15:33:33 <mle> cheater99: yes, sorry
15:33:43 <EvanR> this conversation sounds hilariously and distantly related to someones actual keyboard
15:33:45 <mle> cheater99: the key labels suggest space to some people
15:34:00 <cheater99> mle: hm?
15:34:16 <mreh> I need a snappy name for my Signal Functions that automatically distribute RandomGenses to the points in a signal function network
15:34:23 <cheater99> mle: oh, that comment about finishing was for gwern ;-)
15:34:30 <gwern> mreh: 'scatter'?
15:34:31 <mreh> maybe.... noise -> noise'
15:34:31 <cheater99> mle: let me have a thought about that
15:34:58 <gwern> mreh: you know, 'broadcast' was originally a gardening term for scattering seeds widely - 'broad-cast'
15:35:16 <mreh> it doesn't distribute them randomly
15:35:31 <gwern> nor did gardeners
15:35:57 <mreh> I'm sure broadcast is an FRP/Yampa thing already actually
15:36:38 <mreh> yeah, distributing input to a collection of signal functions
15:37:03 <cheater99> demultiplex.
15:37:19 <mreh> it's going to do the same as noise and noiseR and the others, so maybe a prime so I don't break legacy code
15:38:08 <heatsink> gwern: Channels were originally troughs of running water.  So did they use channels for broadcasting?
15:38:29 <gwern> I think one just throws them
15:38:41 <monochrom> They used channels for broadcasting diseases.
15:38:44 <gwern> have you never seen peasants with pouches casting seeds with their hands?
15:38:55 <EvanR> diseases called primetime
15:39:13 * heatsink has never seen a peasant
15:39:37 <c_wraith> I've cast seeds.  I may have even considered a peasant child at the time.
15:39:55 <gwern> heatsink: 'and let them eat cake' eh
15:40:00 <mreh> uh oh, were becoming #farming
15:40:03 <heatsink> heh
15:41:03 <monochrom> @type cast
15:41:03 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:41:24 <EvanR> is that a typesafe cast?
15:41:32 <mauke> it's not a cast at all
15:41:33 <c_wraith> Kind of.
15:41:39 <monochrom> > let seed = True in cast seed :: Maybe Bool
15:41:39 <lambdabot>   Just True
15:41:45 <monochrom> > let seed = True in cast seed :: Maybe Char
15:41:46 <lambdabot>   Nothing
15:41:53 <monochrom> safe cast seed
15:41:54 <heatsink> It's typesafe as long as you don't define a bad instance of Typeable
15:42:04 <c_wraith> yeah.  typeable is kind of fragile.
15:42:36 <monochrom> I think it's ok.
15:43:36 <dons> guys. nostrademons has outdone himself. http://pastebin.com/raw.php?i=6kfwTsB0
15:43:47 <dons> a haskell webserver in a few dozen lines :}
15:44:08 <mreh> what does it do?
15:44:17 <dons> serves web pages
15:44:29 <monochrom> A monad law is required to ensure Â«let m = blahblah in do { ...; m; ...}Â» is unsurprisingly the same as Â«do { ...; blablah; ...}Â».
15:44:49 <ivanm> dons: so, no need for snap, etc.? :p
15:44:56 <dons> oh boy
15:44:58 <dons> and view-source:http://localhost:8000/
15:45:00 <dons> ... for fun
15:45:30 <c_wraith> that appears to be using IOCCC tricks
15:45:33 <mreh> what wepages does it serve?
15:45:42 <dons> awesome ones
15:45:51 <gwern> so, it's a short webserver and a quine too?
15:46:06 <dons> not quite. run it and see.
15:46:20 <mreh> i bet it serves a very simple page
15:46:29 <mreh> can't see any markup
15:46:46 <dons> ... you have to run it to find out.
15:46:47 <coonsta> there's a <pre>...</pre>, so some ASCII art of some kind
15:46:53 <dons> ghci A.hs 
15:46:55 <dons> main
15:47:01 <dons> go to localhost:8000
15:47:07 <ivanm> dons: doesn't appear to be valid HTML though
15:47:10 <ivanm> ;-)
15:47:13 <dons> your not valid html
15:47:26 <dons> haters always hating. ;)
15:47:29 <EvanR> your stupid
15:47:30 <ReinH> Hi folks. After reading the Monadic Parsing in Haskell pdf, I was wondering if there any extant libraries for monadic parsing in Haskell?
15:47:32 <ivanm> but I'm not serveable!
15:47:36 <pielgrzym> I've just stepped in to part 4 of this nice tutorial: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and I'm totally lost. Can I boil down a monad to something like a sophisticated type template? 
15:47:45 <EvanR> ReinH: no, none
15:48:07 <ivanm> ReinH: as in parsec, polyparse, attoparsec, etc.?
15:48:07 <EvanR> ReinH: just kidding
15:48:17 <ReinH> ivanm: yes, as in those :)
15:48:22 <heatsink> Not evan on hackage.haskell.org
15:48:23 <ivanm> what's the utrecht one? uuparsing-lib or something?
15:48:27 <dons> ReinH: many.
15:48:33 <c_wraith> safari doesn't like it much.
15:48:36 * ReinH gratefully accepts the rebuke
15:48:45 <c_wraith> it's not served as text/html, so it doesn't render it as text/html
15:48:47 <dons> ReinH: parsec, parsimony, etc.
15:48:47 <ReinH> I figured there were, I just don't get much from my normal search algorithm
15:48:49 <mreh> dons: is that an egg?
15:48:51 <monochrom> Text.ParserCombinators.ReadP is monadic parsing and comes with GHC.
15:49:00 <ivanm> monochrom: no it doesn't
15:49:04 <ivanm> oh, wait, sorry, you're right
15:49:06 <mreh> maybe it's a cylon
15:49:09 <monochrom> It is in base.
15:49:10 <gwern> pielgrzym: well, Monad is a typeclass, and typeclasses are sort of like templates
15:49:10 * ivanm thought monochrom wrote Parsec there
15:49:16 <ReinH> ha ha http://hackage.haskell.org/packages/archive/pkg-list.html#cat:parsing
15:49:18 <ivanm> monochrom: I need to learn to read ;-)
15:49:22 <gwern> pielgrzym: unless you mean in like a c++ sense
15:49:24 <dons> http://stackoverflow.com/questions/3077207/choosing-a-haskell-parser/3077256#3077256 <-- ReinH 
15:49:26 <ReinH> that will do :)
15:49:31 <ReinH> dons: oh, even better :D
15:49:32 <ivanm> mreh: decorated easter egg aka pysanky
15:50:06 <pielgrzym> gwern: I meant the c++ sense, that is a data type capable of accepting any initial type as an input
15:50:25 <mreh> I think that would have come last in the egg decorating competitions of my childhood
15:50:32 <mreh> :D
15:50:34 * gwern shrugs. I dunno what that means
15:50:35 <EvanR> pielgrzym: like this one
15:50:45 <EvanR> @src []
15:50:45 <lambdabot> data [] a = [] | a : [a]
15:51:29 <pielgrzym> gwern: let's say I meant c++ template ;P I just suck at explaining ;P
15:51:36 <ivanm> dons: any particular reason you didn't mention uu-parsinglib?
15:52:16 <pielgrzym> EvanR: basically this is a list right? and it can be in two 'versions' - empty and filled with type [a], right?
15:52:59 <EvanR> pielgrzym: it can be empty or some a followed by a list of a
15:53:15 <EvanR> the point being that a is any type
15:53:49 <EvanR> @src Maybe
15:53:50 <lambdabot> data Maybe a = Nothing | Just a
15:53:53 <pielgrzym> EvanR: this is Maybe for, right? If for example I don't know if function won't produce nothing and might produce a, right? Then I give funct' :: Int -> Maybe Int for example, right?
15:53:57 <EvanR> that one should make more sense
15:54:17 <EvanR> pielgrzym: yes
15:54:33 <EvanR> return Nothing or Just 3
15:54:58 <dons> ivanm: its not widely used? probably should get an honorable mention though, since it has some serious users
15:54:59 <pielgrzym> EvanR: so what this Nothing actually is? in learnyourselfahaskell.com they said there is no null value in haskell
15:55:11 <dons> ?src Maybe
15:55:11 <lambdabot> data Maybe a = Nothing | Just a
15:55:16 <EvanR> Nothing is one of two constructors for type Maybe
15:55:22 <monochrom> @quote array
15:55:22 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
15:55:24 <dons> its a data type that distinguishes valid results from invalid ones.
15:55:46 <gwern> pielgrzym: Nothing is not a null value. you will never be given an Int and discover it's a Nothing
15:55:58 <ivanm> dons: arguably polyparse isn't widely used either (only 7 packages use it)
15:56:14 <ivanm> though the fact that one of them is haxml means it is installed a fair amount
15:56:25 <dons> good point.
15:56:29 <pielgrzym> gwern: by discover you mean I will get an error in my app or something exeption-like?
15:56:46 <dons> it scares me that if I wrote a review of one hackage package per day, it would take me 6 years to complete.
15:57:32 <luite> so write reviews of 10 packages per day instead
15:57:33 <monochrom> IMO it's a waste of time to ponder "what is ___?"  Too much philosophy and too little programming.
15:57:39 <mreh> what if you did one every two days?
15:57:59 <ivanm> @remember dons it scares me that if I wrote a review of one hackage package per day, it would take me 6 years to complete.
15:57:59 <lambdabot> Nice!
15:58:03 <EvanR> pielgrzym: Nothing is just another constructor that takes no arguments. think 3, 'a', and []
15:58:08 <heatsink> What if you did one on the first day, two on the second day, four on the third day, ...
15:58:14 <ivanm> dons: and that's not taking into account the fact that extra packages are going to be uploaded ;-)
15:58:15 <gwern> dons: what scares me is that hackage is that large and it's still nowhere near being complete to the point where one can assume there's is something on hackage for one's task
15:58:49 <monochrom> What if we put dons in a time loop... :)
15:59:32 <jbapple> This is a possible bug in Data.Set, but I don't know if I can trigger it for smallish sets: http://hackage.haskell.org/trac/ghc/ticket/4143
15:59:46 <ReinH> which pretty print library do people actually use?
15:59:49 <jbapple> So far, the smallest set I can trigger it on is maxBound`div`2 + 1 in size
15:59:56 <ReinH> Language.Haskell.Pretty ?
16:00:05 <mreh> could there be some kind of peer review process in a future Hackage? 
16:00:16 <mreh> like a thumbs-up thumbs-down
16:00:19 <ivanm> ReinH: typically, yeah
16:00:35 <gwern> ReinH: I use 'Show'
16:00:37 <ReinH> mreh: some sort of trust network
16:00:40 <jbapple> If I can trigger it for sets of size maxBound`div`4 + 1, then I think it is more likely that such a Data.Set could fit in memory
16:00:41 <ivanm> ReinH: it is admittedly not the best, but when I needed one I couldn't find any convincing argument to help me pick from any of the others
16:00:48 <ReinH> gwern: right, we want to look at the shape of some complex lists
16:00:50 <dons> we've got a group working on Hackage 2.0 this summer
16:00:51 <ivanm> gwern: except that isn't a pretty-printing library... ;-)
16:00:51 <Phyx-> is HaRe still actively maintained?
16:00:52 <ReinH> lists of tuples of ...
16:00:57 <ivanm> Phyx-: kinda
16:01:01 <ReinH> so getting cheap indentation and layout is useful
16:01:04 <heatsink> dons: What will be new?
16:01:12 <gwern> Phyx-: not that I know of
16:01:15 <ivanm> Phyx-: they keep extending it for new papers
16:01:19 <heatsink> Not shutting down when building documentation?
16:01:29 <monochrom> haha
16:01:33 <ivanm> and they're thinking about getting it using a new parser
16:01:41 <ivanm> but they're not sure which one yet last I heard (January)
16:01:53 <mreh> oooh, automatic checking of dependencies!
16:01:54 <Phyx-> heh, well, that's one way to "support" a project
16:02:03 <ivanm> heatsink: or not bulding documentation whenit fails to build?
16:02:05 <ksf> I think it's about time we start voting on hackage packages, though, to move some of them to the attic.
16:02:17 <ivanm> Phyx-: it's basically a reasearch subject they revisit every now and again
16:02:25 <mreh> Email, Subject: Your package just broke
16:02:30 <ivanm> IIRC, they're grants are now to explicitly research stuff with erlang
16:02:43 <ivanm> so they can't spend _all_ their time on HaRe :p
16:02:46 <gwern> aw
16:02:51 <Phyx-> aw
16:02:54 <ReinH> wait, retarded question, how do I obtain/import the Haskell.Library.Pretty? I can't find it in cabal...
16:03:18 <ksf> dons, what do you think about setting up a http://www.public-software-group.org/liquid_feedback instance
16:03:19 <heatsink> One useful thing hackage could do is keep track of packages that have working maintainer addresses
16:03:19 <ksf> ?
16:03:20 <mreh> ReinH: are you trying to install it with cabal?
16:03:23 <monochrom> I have a cunning plan. "New techniques of using Erlang to implement HaRe"
16:03:28 <ReinH> mreh: I'm trying to install it, full stop :)
16:03:35 <heatsink> As in, the maintainer responds to e-mail from the hackage server, so they'll probably respond to other e-mail
16:03:38 <gwern> heatsink: how would you do that?
16:03:53 <gwern> heatsink: I mean, how would you do that in a non-annoying way
16:03:57 <mreh> ReinH, the name space doesn't have much to do with distribution, the unit of distribution is the package
16:04:01 <jbapple> heatsink: I, for one, took my email address off of the package I put on hackage -- too much spam
16:04:07 <ivanm> ReinH: it comes with GHC
16:04:10 <ksf> heatsink, even packages with defunct maintainer adresses might work and be useful.
16:04:13 <mreh> so many different packages could have things in that namespace
16:04:13 <ivanm> ReinH: and it's in the pretty library
16:04:16 <jbapple> heatsink: I put up a link to the google code hosting project instead
16:04:17 * hackagebot Encode 1.3.2 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.2 (OtakarSmrz)
16:04:27 <ivanm> monochrom: lol
16:04:32 <ReinH> ivanm: that's what I thought, so why wouldn't import Pretty work?
16:04:40 <ksf> a package should be automagically slated for keeping if it's used by some popular one
16:04:52 <alise_> Is there a better way to write the Kleene star than the following? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26386
16:04:54 <ivanm> ReinH: because you need to do "import Text.Pretty" or whatever it is
16:05:00 <ReinH> hmm
16:05:04 <ivanm> ReinH: the library is pretty; the modules you need aren't ;-)
16:05:08 <ReinH> ivanm: :)
16:05:25 <heatsink> Hmm.  Having e-mail on the webpage itself is a deterrent.
16:05:34 * ksf has a look at alise_'s code and decides its' abstract nonsense
16:05:37 <Phyx-> boy, if read on it's own, ivanm's sentence can be taken completely out of context :P
16:05:47 <ksf> alise_, what do you want to do?
16:05:50 <Phyx-> so with a new hackage do we get a new pony package? :P
16:05:56 <ivanm> Phyx-: yeah, I read that after I wrote it... :s
16:06:17 <alise_> ksf: It's just the definition of the Kleene star.
16:06:26 <ivanm> Phyx-: I hope not :s
16:06:27 <alise_> ksf: And for god's sake, this is Haskell! Have you all LOST the spirit of abstract nonsense?
16:06:32 <ivanm> heatsink: huh?
16:06:43 <ivanm> you don't want people to be able to contact you if there's a problem with your package?
16:06:45 <heatsink> ivanm: As jbapple said, it attracts spam
16:06:46 <Phyx-> ivanm: why not? wasn't pony the hello world of hackage?
16:06:50 <ksf> the kleene star, imnsho, is a primitive, not a derived expression...
16:06:59 <ivanm> heatsink: oh, then you obfuscate the email
16:07:01 <ReinH> ivanm: sorry for the noobish questions, please help me help myself :) If I have the hackage docs[1], how can I figure out the module to include? [1]http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.3/doc/html/Language-Haskell-Pretty.html#1
16:07:09 <alise_> ksf: I don't think you know what you're talking about.
16:07:13 <ivanm> Phyx-: but do we really need another?
16:07:19 <alise_> ksf: Please examine: http://en.wikipedia.org/wiki/Kleene_star#Definition_and_notation
16:07:28 <Phyx-> ivanm: sure, an animated one! upgrades :P
16:07:28 <heatsink> ivanm: Yes, that could be done
16:07:36 <ivanm> ReinH: that's the wrong one...
16:07:41 <ReinH> ivanm: doh...
16:07:51 <ivanm> ReinH: that's the pretty-printing of Haskell AST ;-)
16:07:56 <monochrom> Kleene star is abstract nonsense. <duck>
16:08:01 <ivanm> ReinH: http://hackage.haskell.org/package/pretty
16:08:05 <ReinH> ivanm: lol...
16:08:07 <ksf> you can define it recursively in terms of a n indeponent semiring, but that's usually not what you want, as you can't analyse a recursive haskell definition
16:08:11 <ivanm> so you want "import Text.PrettyPrint"
16:08:31 <mreh> quack </duck>
16:09:02 <monochrom> @type iterate
16:09:03 <lambdabot> forall a. (a -> a) -> a -> [a]
16:09:05 <ksf> and in the case of defining it recursively, one would usually have a more concrete algebra than something with lists.
16:09:08 <heatsink> ReinH: The module name is the title of the HTML page.  You may also need to compile against package when you compile.
16:09:20 <uorygl> ksf: I don't think "indeponent" is a word that people usually words.
16:09:21 <alise_> ksf: In this case, I'm only interested in the string case.
16:09:24 <uorygl> s/words/use/
16:09:27 <heatsink> May also need to include the package when you compile.
16:09:39 <alise_> The function I have called "star" is what I want, that is unquestionable; I only ask if it can be implemented more simply.
16:09:47 <uorygl> I mean, literally, it means "not putting away".
16:09:52 <Saizan> alise_: your code should be equivalent to "star xs = concat $ iterate (flip (zipWith (++)) xs) xs"
16:10:07 <ksf> alise_, in that case, yes, it's a good definition
16:10:13 <alise_> Saizan: I suppose by some definition that is simpler. :-P
16:10:13 <ksf> ...just not quite general.
16:10:23 <alise_> ksf: That's all right. I'm not using it in an overly abstract way.
16:10:26 <monochrom> > let star x = iterate (x ++) [] in star "child"
16:10:27 <lambdabot>   ["","child","childchild","childchildchild","childchildchildchild","childchi...
16:10:38 <monochrom> I hope that helps.
16:10:49 <alise_> monochrom: Nope; that takes [a], not [[a]].
16:11:07 <alise_> star ["ab","cd"] = ["", "ab", "cd", "abab", "abcd", "cdab", "cdcd", ...]
16:11:19 <monochrom> I see. Then it's harder.
16:11:27 <alise_> Indeed.
16:11:55 <monochrom> @type iterateM
16:11:55 <lambdabot> Not in scope: `iterateM'
16:12:00 <ReinH> I just found the wrong pretty print library. Thanks all
16:12:13 <Saizan> mg
16:12:14 <geheimdienst> > let star x = iterate (++x) "tro" in star "lo"
16:12:16 <lambdabot>   ["tro","trolo","trololo","trolololo","trololololo","trolololololo","trololo...
16:12:44 <Saizan> alise_: each call to v_n will return a singleton list, right?
16:13:16 <alise_> Saizan: Only if length xs == 1, which is not a given.
16:14:02 <ksf> alise_, btw, [[]] = []
16:14:12 <Saizan> *Main> v_n [[1,2,3],[4,5,6]] 2
16:14:13 <Saizan> [[1,2,3,1,2,3]]
16:14:15 <monochrom> > [[]] == []
16:14:16 <lambdabot>   False
16:14:56 <ksf> > [[]]
16:14:58 <lambdabot>   [[]]
16:15:02 <ksf> bugger
16:15:10 <hpc> >concat [[]]
16:15:12 <geheimdienst> i mean, if [[]] was [], then a list with one element in it, namely the empty string, would be indistinguishable from an empty list ...
16:15:15 <hpc> > concat [[]]
16:15:16 <lambdabot>   []
16:15:32 <hpc> geheimdienst: no
16:15:35 <geheimdienst> > concat [[[[]]]]
16:15:36 <lambdabot>   [[[]]]
16:15:39 <hpc> [] :: [a]
16:15:43 <hpc> [[]] :: [[a]]
16:15:48 <monochrom> > concat []
16:15:49 <lambdabot>   []
16:15:56 <monochrom> heh, fixed point!
16:16:06 <alise_> ksf: [[]] =/= [].
16:16:12 <alise_> Even for the algorithm.
16:16:16 <ksf> so, to wrap up: yes, [a] unifies with [[a]] but that's not the same value...
16:16:22 <alise_> [[]] ++ ... =/= [] ++ ..
16:16:23 <alise_> *...
16:16:34 <Saizan> *Main> take 5 $ star ["ab","cd"]
16:16:34 <Saizan> ["","ab","abab","ababab","abababab"]
16:16:43 <Saizan> alise_: your star doesn't match your example ^^^
16:17:52 <uorygl> > [[]] == []
16:17:53 <lambdabot>   False
16:17:59 <alise_> saiam: Huh, I broke it by using zipWith.
16:18:12 <alise_> v_n xs n = [x ++ y | x <- v_n xs (n-1), y <- xs]
16:18:13 <alise_> Silly me.
16:18:18 <heatsink> @check (\n -> take n ([[]] ++ repeat []) == take n ([] ++ repeat []))
16:18:18 <alise_> Is there a nicer way to write that comprehension, though?
16:18:19 <lambdabot>   "OK, passed 500 tests."
16:18:42 <edwardk> preflex: xseen ski
16:18:42 <preflex>  ski was last seen on freenode/#haskell 54 minutes and 53 seconds ago, saying: ty
16:18:43 <uorygl> "It's a bit strange how lambdabot gives QuickCheck results in quotation marks."
16:18:48 <Phyx-> > 
16:18:49 <lambdabot>   not an expression: `'
16:19:02 <heatsink> > "OK, passed 500 tests."
16:19:02 <uorygl> "Are those scare quotes?  Is lambdabot being sarcastic?"
16:19:03 <lambdabot>   "OK, passed 500 tests."
16:19:04 <alise_> uorygl: it does an evaluation, iirc.
16:19:09 <alise_> Same reason it indents.
16:19:40 <orlandu63> @check ("OK, passed 500 tests." == "OK, passed 500 tests.")
16:19:41 <lambdabot>   "OK, passed 500 tests."
16:20:47 * ivanm heads off
16:20:50 <ivanm> bye all
16:20:56 <Saizan> alise_: liftM2 (++) (v_n xs (n-1)) xs -- with the list monad
16:21:27 <ksf> alise_, and you might be concerned about ++ being ineffective due to re-building the spine of the lhs argument
16:22:12 <ksf> (++) <$> (v_n xs (n-1)) <*> xs
16:22:14 <Philonous> > let star m = concat $ iterate (((++) <$> m) <*>) [[]] in star ["a","b"]
16:22:15 <lambdabot>   ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","...
16:23:11 <alise_> The culmination of all this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26387
16:23:19 <alise_> The least efficient implementation of regular expressions ever.
16:24:03 <alise_> Hey, wait; *** = v_n.
16:24:17 <ksf> :t (***)
16:24:18 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:24:22 <ksf> that name is taken...
16:24:24 <alise_> star :: [[a]] -> [[a]]
16:24:24 <alise_> star xs = concatMap (xs ***) [0..]
16:24:30 <alise_> ksf: Who cares about arrows, this is a hack :P
16:25:15 <alise_> Okay, star isn't actually that because it doesn't work like that.
16:25:17 <alise_> That's the one flaw. :P
16:26:26 <Saizan> alise_: i'd go with "star xs = concat $ iterate (liftM2 (++) xs) [[]]" because the integer indexing feels ugly :P
16:26:32 <alise_> oh, because I had *** 0 as [], not [[]]
16:26:43 <alise_> Saizan: But the integer indexing is used elsewhere (to do x{y}).
16:27:03 <alise_> Revised: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26388
16:28:14 <alise_> Sorry, I lied, none of this works: the infinite stuff means it never gets to the alternatives of infinite things.
16:29:03 <Saizan> you need another ordering then, with a fairer liftM2
16:29:21 <Saizan> see the Omega or LogicT monads, or just write your own
16:29:58 <alise_> Or just give up on it as a five minute's hack :)
16:30:06 <aristid> @src liftA2
16:30:06 <lambdabot> liftA2 f a b = f <$> a <*> b
16:35:04 <pielgrzym> I can't figoure why the http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot examplary bot with monads doesn't compile :/
16:35:09 <pielgrzym> I keep getting error:
16:35:16 <pielgrzym> Ambiguous type variable `b' in the constraint:
16:35:21 <pielgrzym> Exception b' arising from a use of `catch' at altbot.hs:26:17-61
16:35:36 <pielgrzym> the line 26: loop st    = catch (runReaderT run st) (const $ return ())
16:35:43 <pielgrzym> could someone enlight me?
16:35:54 <Saizan> it's written using the old Control.Exception API
16:36:20 <Saizan> change (const $ return ()) to (\(SomeException _) -> return ()) and it'll work
16:36:26 <pielgrzym> Saizan: thanks :)
16:38:21 <Gracenotes> maybe the page should be edited. :x
16:38:39 <Saizan> i guess so
16:38:50 <dons> pielgrzym: oh, changes in the Exception module
16:39:00 <dons> pielgrzym: replace Control.Exception with Control.OldException
16:39:18 <pielgrzym> dons: yup :) works fine now :)
16:40:01 <Saizan> actually that codes make no sense
16:40:33 <pielgrzym> ok, what I basically learned is that in some totally magical way we do not need to pass the handler into all those nifty io functions because it uses a magical asks thing that is part of even more magical Reader monad :) so monads basically encapsulate some stuff?
16:40:54 <pielgrzym> Saizan: you mean the dummy exeption?
16:41:27 <Saizan> the "loop" will terminate anyhow, disconnect will run anyhow, the only difference is that the program will shut down with no output rather than printing the exception
16:41:48 <geheimdienst> pielgrzym, i think of these monads like an object in other languages. when you call one of the object's methods, it can work with all the object's properties
16:42:00 <geheimdienst> (gurus, is that an okay explanation?)
16:42:05 <Saizan> pielgrzym: except it's not magical at all
16:42:05 <heatsink> Computations in the reader monad have an implicit parameter
16:42:42 <c_wraith> the reader monad *feels* magical, until you realize that you're actually manipulating functions behind the scenes, not primitive values.
16:42:58 <heatsink> pielgrzym: If I have a Reader String String, it contains a function of type String -> String
16:43:21 <pielgrzym> geheimdienst: and those monad constructors might resemble something like class inheritance?
16:43:39 <pielgrzym> heatsink: aaah, it makes sense now :)
16:44:00 <pielgrzym> Saizan: I bet it is :P
16:44:24 <Saizan> please don't try to draw analogies with OO, it'll only confuse yourself further :)
16:44:37 <pielgrzym> ok :)
16:45:05 <ski> (Saizan : btw, were you doing by-value or by-name ?)
16:45:17 <Saizan> (ski: by-need actually)
16:45:54 <pielgrzym> soo, the thing: type Net = ReaterT Bot IO means basically that Bot monad will be equipped with all the Reader magic related to IO right?
16:46:00 <Saizan> pielgrzym: newtype ReaderT r m a = ReaderT (r -> m a) -- so it's nothing more than actually getting that Handle as a function argument :)
16:46:14 <Saizan> pielgrzym: the only difference is that it gets applied for you
16:46:23 <jbapple> http://hackage.haskell.org/trac/ghc/attachment/ticket/4143/ : Now a bug for sets as small as 3/8 * maxBound
16:46:39 <Gracenotes> the Bot is the extra state in the IO monad
16:46:54 <Saizan> pielgrzym: Bot is not a monad
16:47:00 <Gracenotes> uh extra argument
16:47:34 <Gracenotes> when you run the Net monad, you pass it the Bot data structure, and all code in that monad will have access to it
16:47:46 <pielgrzym> until I touched those monads I thought I get it :D now my brain is scrambled :D
16:47:56 <pielgrzym> Gracenotes: aaaaaaaaah
16:49:02 <edwardk> jbapple ouch converting to integer?
16:49:20 <ski> edwardk : SYN ACK
16:49:31 <jbapple> edwardk: "ouch"?
16:50:18 <edwardk> jbapple: wondering if there is a less painful way, like checking to see if it is > maxBound / 4 then dividing through by 4 before comparing sizes
16:50:29 <edwardk> jbapple: way cheaper than round tripping through integer
16:51:23 <jbapple> edwardk: Maybe
16:51:41 <jbapple> edwardk: I'm more focused on how small a test case I can generate first
16:51:47 <edwardk> jbapple: *nods*
16:52:03 <pielgrzym> could someone point me to a page that explains 'type' keyword? data I (think) understand
16:52:12 <edwardk> jbapple: also the same bug will apply to Data.Map
16:52:19 <jbapple> edwardk: With all the boxing going on, a 3/8 * maxBound Data.Set may still be so large that the patch is rejected
16:52:28 <Gracenotes> pielgrzym: if it helps.. maybe.. here is code I wrote a while ago that directly compares Reader and extra function argument. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26390#a26390
16:52:41 <jbapple> edwardk: And I am concerned that there may be other, more subtle overflow bugs
16:52:47 <ski> pielgrzym : `type' only introduces synonyms, so after `type String = Name', `Name' means the same as `String' in types
16:52:51 <edwardk> jbapple: hence why i was looking for something that just turned into a quick comparison against a constant and a couple of shifts
16:53:05 <jbapple> edwardk: For Data.Map, the requisite size may be even smaller, since the values may take up space as well
16:53:06 <pielgrzym> ski: ah, this was easy :)
16:53:20 <ski> pielgrzym : `data' (and `newtype') constructs new types, but `type' only names an existing type (possibly parameterized)
16:53:36 <edwardk> jbapple: well, the 3/8ths thing just comes from the size of 'delta' and/or 'ratio' no?
16:53:45 <pielgrzym> ski: now it makes sense :)
16:53:53 <jbapple> edwardk: Yes, it is partially a function of those
16:54:04 <ski> pielgrzym : e.g. after `type Env a = [(Name,a)]', `Env Int' means the same as `[(Name,Int)]', i.e. `[(String,Int)]'
16:54:13 <jbapple> edwardk: You'd probably want ceil(maxBound/4), but I'm not sure
16:54:33 <edwardk> or more likely a function of maxBound and ratio and/or delta
16:54:54 <edwardk> that way it can be adapted to things like the trie from edison that use the same bounded balance model
16:55:03 <pielgrzym> so this: type Net = ReaderT Bot IO means: take the magic constructor ReaderT that wraps the Bot data type over IO (supplying Bot with all the IO stuff or other way around?) and hook it to the Reader monad and finally call it Net. ?
16:55:06 <ski> (pielgrzym : and when i say "after" i don't mean that you can't use `Env' above that `type' synonym definition in your module .. because you can)
16:55:18 <jbapple> edwardk: Edison's trie uses BB?
16:55:28 <jbapple> I thought it was just a straight trie
16:55:42 <pielgrzym> ski: ah, you can use parameters :) it's like a template, right?
16:55:47 <ski> pielgrzym : yes, in this case you will probably use that as `Net String', meaning `ReaderT Bot IO String' (or any other type than `String')
16:55:55 <Saizan> pielgrzym: no, it simply means apply ReaderT to the two argument Bot and IO and call it Net
16:56:20 <edwardk> jbapple: there is at least one ternary search tree of bounded balance in there
16:56:29 <Saizan> all the other stuff is things you infer, which i'm not sure are entirely correct :)
16:56:33 <pielgrzym> Saizan: ok :) and ReaderT does what then?
16:56:59 <Saizan> ReaderT does nothing
16:57:20 <edwardk> jbapple: http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1.3/doc/html/src/Data-Edison-Assoc-TernaryTrie.html
16:57:23 <ski> pielgrzym : just as `Maybe' can't be used as `foo :: Int -> Maybe', but can be used as `foo :: Int -> Maybe String', you (usually) want to use `Net' (i.e. `ReaderT Bot IO') with an (extra) argument
16:57:29 <Saizan> it's a type constructor, so its application to some other types is just another type
16:57:40 <ski> @src ReaderT
16:57:40 <lambdabot> Source not found. My mind is going. I can feel it.
16:57:41 <jbapple> edwardk: It appears to use 6
16:57:52 <pielgrzym> ski: kinda type currying, right?
16:58:00 <jbapple> edwardk: so the bugs might be even smaller
16:58:01 <ski>   newtype ReaderT rho m a = ReaderT {runReaderT :: rho -> m a}
16:58:15 <ski> pielgrzym : yes, `ReaderT' is a curried type (constructor)
16:58:29 <pielgrzym> ski: :)
16:58:47 <jbapple> Int should be considered a bug until proved otherwise
16:58:53 <edwardk> jbapple: yeah, hence why i was saying you may want to use a function of the ratio and delta as well as maxBound ;)
16:58:55 <pielgrzym> newtype ReaderT r m a what are r,m,a?
16:58:58 <ski> jbapple :)
16:59:13 <pielgrzym> aaah
16:59:15 <ski> pielgrzym : just any parameters, like in `type Env a = [(Name,a)]'
16:59:21 <pielgrzym> hmm
16:59:38 <ski> only in this case they are parameters of a type defined using `newtype', rather than `type'
16:59:45 <jbapple> edwardk: I'm not really focused on fixing Edison bugs
16:59:58 <jbapple> I'm not sure that it's used very much
16:59:59 <edwardk> jbapple: compare max sizeL sizeR vs. maxBound / max delta ratio -- and if its higher then divide the other by the ratio (or delta), otherwise multiply by the ratio/delta
17:00:03 <ski> (and the `m' parameter there must be a type function, like `IO' or `Maybe', but not like `Int' or `String')
17:00:05 <jbapple> and I don't think it has been maintained for a while
17:00:06 <ski> @kind String
17:00:06 <lambdabot> *
17:00:08 <ski> @kind Maybe Int
17:00:09 <lambdabot> *
17:00:11 <ski> @kind Maybe
17:00:12 <lambdabot> * -> *
17:00:13 <ski> @kind IO
17:00:14 <lambdabot> * -> *
17:00:17 <pielgrzym> The reader monad transformer. Can be used to add environment reading functionality to other monads.
17:00:25 <ski> see ? `Maybe' and `IO' are type functions
17:00:25 <pielgrzym> hm
17:00:34 <edwardk> jbapple: sure, but i know i've stolen the bounded balance code from there for at least 2-3 modules, so a general solution would be nice ;)
17:00:44 <jbapple> edwardk: Out of context, I have no idea what that arith code above means
17:00:49 <jbapple> Where should they be compared?
17:00:53 <ski> `Int :: *' means that `Int' is an ordinary type that has values
17:01:02 <jbapple> Also, I'm loathe to insert more complicated Int code when it was already broken
17:01:06 <pielgrzym> ski: ah, I get it :) m is a kind of constructor function, right?
17:01:21 <jbapple> So, unless it's REALLY clear that it's right, I think we ought to be VERY wary
17:01:30 <ski> `Maybe :: * -> *' means that `Maybe' is an "incomplete" type (function), which wants a parameter, before it produces a proper type, which can have values
17:01:37 * hackagebot Encode 1.3.3 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.3 (OtakarSmrz)
17:01:38 <edwardk> join, merge, rotateL, rotateR, balanced
17:01:43 <pielgrzym> ski: now I get it :))))
17:01:43 <ski> so `Maybe Int :: *' has values like `Nothing' and `Just 42'
17:01:53 <ski> @type ReaderT
17:01:54 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
17:01:56 <ski> er
17:01:59 <ski> @kind ReaderT
17:02:00 <lambdabot> * -> (* -> *) -> * -> *
17:02:12 <ski> ^ so `ReaderT' is a *higher-order* type function :)
17:02:36 <edwardk> jbapple: yes, but the counter argument is that unless we can be very sure that people are dealing with sets of that size, we should be very wary of killing performance and memory footprint by spewing integers all over for the gc to clean up as well
17:03:06 <ski> (it takes three arguments, say `r',`m',`a', where `m' must itself be a type function like `Maybe' or `IO', while `r' and `a' should be ordinary types, like `Maybe String' and `IO Bool')
17:03:08 <jbapple> edwardk: I still have no idea what you mean. Just listing some function names doesn't really help here. This is a tricky comparison. What is "other" that I divide by ratio? What do you mean divide by "ration (or delta)"?
17:03:34 <ski> pielgrzym : so, the "kind" of a type is sortof the type of a type
17:03:38 <pielgrzym> ski: could those ordinary types be like plain String or Char or etc.?
17:03:43 <ski> sure
17:03:50 <edwardk> jbapple: instead of calculating delta * sizeL <= sizeR -- if one of them is large you can use sizeL <= sizeR / delta
17:03:57 <pielgrzym> ski: makes sense :)
17:04:12 <edwardk> jbapple: that is all i meant above
17:04:17 <ski> `Maybe String' and `IO Bool' and `[String]' and `[(Bool,[Int -> Char])]' are just more complicated examples
17:04:29 <ski> @kind ReaderT
17:04:30 <lambdabot> * -> (* -> *) -> * -> *
17:04:36 <ski> @kind ReaderT String
17:04:37 <lambdabot> (* -> *) -> * -> *
17:04:39 <ski> @kind ReaderT String Maybe
17:04:40 <lambdabot> * -> *
17:04:46 <ski> @kind ReaderT String Maybe Bool
17:04:47 <lambdabot> *
17:04:49 <jbapple> edwardk: What about rounding?
17:05:13 <edwardk> jbapple: what about it? you're talking about hundreds of millions of items.
17:05:15 <pielgrzym> ski: and in this context it takes Bot type and the type function IO and waits for another type to be curried, right?
17:05:22 <edwardk> jbapple: and bounded balance is approximate anyways
17:05:22 <ski> yes
17:05:46 <jbapple> edwardk: What do you mean "approximate anyways"?
17:06:06 <pielgrzym> ski: I can't see in the code where exactly is this extra missing type curried 
17:06:08 <jbapple> I mean, I understand that for larger trees, a longer path here or there is negligable
17:06:25 <ski> pielgrzym : note that `type Net = ReaderT Bot IO' *could* have been defined as `type Net a = ReaderT Bot IO a', except that then you won't be allowed to use `Net', except when applying it to an argument
17:06:29 <pielgrzym> ski: I mean later on. since it's mandatory that it needs to exist right?
17:06:34 <jbapple> But the other code (and the papers) assume inputs of bounded balance
17:06:41 <jbapple> This could make other functions incorrect
17:06:45 <jbapple> and could cascade
17:07:02 <jbapple> I don't know, but that's why I think it's best to be safe
17:07:14 <edwardk> the guarantees are already quite loose you only need the delta to be just over ~3.745. It is 4. so you retain the properties even if a few parts per million wind up on the wrong side of the split
17:07:18 <pielgrzym> ski: ah, this was in the curry part of learnyourselfahaskell :)
17:07:20 <ski> pielgrzym : so, if the latter definition was used, you couldn't say `foo :: String -> ReaderT Bool Net Char' (i.e. you couldn't pass `Net' as an argument to some other type function)
17:07:47 <edwardk> jbapple: not much deep is going on in that structure ;)
17:07:55 <ski> pielgrzym : note that `foo :: String -> ReaderT Bool Net Char' makes *sense* regardless of whether you use `type Net = ReaderT Bot IO' or `type Net a = ReaderT Bot IO a'
17:08:12 <pielgrzym> yup
17:08:14 <pielgrzym> :)
17:08:14 <jbapple> edwardk: I disagree that the properties are maintained. Or at least, I am not convinced
17:08:38 <ski> pielgrzym : it's just that in the latter case, that usage of `Net' is not allowed, because of restrictions in what the type system can infer/check
17:08:52 <pielgrzym> aah
17:08:53 <jbapple> If you read some of the older BB papers, there are examples of trees that can get out of balance and can't be rebalanced (at the top)
17:08:55 <pielgrzym> now I get it
17:09:00 <ski> pielgrzym : in both cases can you say `bar :: Char -> Net Bool', though
17:09:20 <jbapple> And I think the papers on the subject show that there is some depth there, even if hidden
17:09:28 <pielgrzym> we give this extra type like empty here: run :: Net () the extra parameter (a) is () right?
17:09:36 <ski> yes
17:09:39 <edwardk> ok, quantify the error real fast. you have at least (maxBound :: Int / delta) elements. rounding error when dividing by 4 instead of multiplying by 4, lets give you 16 elements to be way high on the estimate. you have an effective ratio of 4 - 16 / 500,000,000
17:09:39 <jbapple> Simple structures with simple invariants sometimes require care to get the right bounds
17:09:47 <edwardk> > 4 - 15/500000000
17:09:48 <lambdabot>   3.99999997
17:10:03 <edwardk> that is higher than 3.745 -- the overall imbalance of the tree does not blow up ;)
17:10:22 <jbapple> edwardk: That's fine, on this tree. But other operations could leave the tree in an unbalanced state
17:10:23 <ski> pielgrzym : instead of `()' you could have any type you like there
17:10:45 <ski> (as far as the well-formedness of the types themselves are concerned)
17:10:58 <jbapple> edwardk: Tarjan has a preprint discussing an example with RB trees - a company he worked for build a DB that rebalanced only on insert, not delete
17:10:59 <jbapple> It blew up
17:11:14 <pielgrzym> ski: but in this particular example this extra type is useless, right? I mean I could write run :: Net String and it would change nothing?
17:11:30 <edwardk> i think you're panicking all out of proportion to the problem. notice that the delta used is actually too small for the ratio present for formal reasoning anyways
17:11:42 <jbapple> edwardk: I'm not saying you're necessarily wrong, that BB trees will necessarily fail. I just think care is called for
17:11:52 <ski> pielgrzym : well, if you say `run :: Net String', then that means that when running the `Net'-action `run', you get a `String' result
17:11:54 <jbapple> edwardk: I am in no way panicked. 
17:12:14 <edwardk> and i'm just saying that your proposed cure is worse than the disease ;)
17:12:37 <jbapple> edwardk: Yes, I had noticed that infelicity. I am considering looking for any bug caused by that
17:12:42 <ski> pielgrzym : in the `run :: Net ()' case, it means that when you run the `Net'-action `run', you get a `()' result (i.e. an "not interesting" result) .. and probably some effects happen that is the main point
17:13:14 <jbapple> edwardk: My cure is: use Integers until we can be confident that we won't produce a new error with Ints
17:13:15 <pielgrzym> ski: I get a String result in program memory? like I would reserve a placeholder for a String, right?
17:13:21 <ski> pielgrzym : so, definitely, `Net ()' and `Net String' are *different* types (meaning differnt things) .. it's just that both are *possible* types
17:13:26 <edwardk> jbapple: the worst case out of the current constants is you get a slightly more lopsided tree than expected, and it benchmarks better than the formally valid constants
17:13:52 <pielgrzym> ski: one more thing really bothers me
17:13:56 <jbapple> edwardk:  The cost is either run-time (if we can't find a smart Int solution) or brain-time (to think up a smart Int solution)
17:14:12 <ski> pielgrzym : look at `getLine :: IO String' vs. `putStrLn :: String -> IO ()'; in one case you get a `String' result back when you run the `IO'-action, in the other case, you get a `()' result back
17:14:30 <ski> pielgrzym : `Net' is just another monad, like `IO'
17:14:33 <edwardk> or a caveat not to use it for any sets/maps with more than a few hundred million elements ;)
17:14:39 <jbapple> edwardk: I'm not sure what you're arguing against now
17:14:47 <mreh> why can't I just do all random actions by splitting off a newStdGen in unsafePerformIO?
17:14:47 <pielgrzym> the puzzling "-- Convenience.": io :: IO a -> Net a \n io = liftIO - what the heck it does? :)))
17:14:53 <edwardk> i'm arguing against the impact of the Integer solution.
17:14:59 <ski> (and the main point that `Foo String' is different from `Foo ()' holds regardless of whether `Foo' is a monad or not)
17:15:01 <jbapple> edwardk: And for what instead?
17:15:04 <zeta-> Is it possible to search hackage for names of functions exported by packages?
17:15:06 <zeta-> I've just written a function to return a row from Pascal's triangle, and wondered if there is one in a library.
17:15:24 <geheimdienst> zeta-, do you know hayoo?
17:15:25 <mreh> zeta- try hoogle
17:15:30 <ski> pielgrzym : `liftIO' is an overloaded function that works on lots of monads
17:15:48 <edwardk> and for spending some brain time on finding one that doesn't need to use Integer or to just label the implementation with the maximum size it can be practically used for, so that in the pathological case, at least the end user is informed
17:15:58 <geheimdienst> hayoo searches lots more packages than hoogle ...
17:16:03 <zeta-> geheimdienst: no :-(
17:16:11 <ski> pielgrzym : presumably, the point of that definition is just to restrict the overloaded `liftIO' to a special case, in which we here only want to use it (and maybe also to get a shorter name ?)
17:16:17 <pielgrzym> ski: and using  IO a -> Net a we just provide a 'symlink' to this magic function for our monad Net, right?
17:16:30 <pielgrzym> ski: hmmm
17:16:39 <edwardk> jbapple: have you worked out what the memory footprint would be for any set/map that actually tripped this limit?
17:16:41 <jbapple> edwardk: Then you aren't disagreeing with me. I think if you look at my messages above, you will see that I am not arguing against an Int solution. I am arguing only that we be very careful with an Int solution not to introduce new bugs.
17:17:24 <ski> pielgrzym : yes, one could just as well use `liftIO' instead of `io' .. but if one has type error, typically one get better errors if one uses more specific types (like `io' is given)
17:18:05 <pielgrzym> ski: ah, cool :) it's easier to track the faulty type definition, right?
17:18:44 <zeta-> mreh:  geheimdienst is it a web-site or utility?
17:18:45 <edwardk> jbapple: fair enough, i just don't see where the proposed fix I mentioned above is going to cause any problems. and i realize that my saying that does nothing to assuage your fears ;)
17:18:54 <jbapple> edwardk: Let's see - 3/8 * 2^31 = 3 * 2^28 values. How much extra room is used by the Set? Roughly 3 pointers for each element?
17:19:05 <geheimdienst> zeta-, here you go http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:19:09 <pielgrzym> ski: thanks for explaining stuff :) gotta sleep with it ;)
17:19:45 <ski> pielgrzym : better in the sense of giving more information in the type error, and usually most important : that the error is detected close to the actual mistake, rather than possibly far away -- when one gets a type error one doesn't understand; a typical response is to give explicit type signatures to things, to enable the type checker to pinpoint the error better
17:19:56 <zeta-> geheimdienst: 8-) thanks!
17:20:05 <geheimdienst> you're welcome
17:20:13 <jbapple> edwardk: It's fine that you don't see it. But this bug has been latent for years. I am only arguing for care. I think it is also ill advised to say something should work because we can't see why it wouldn't.
17:20:29 <edwardk> Bin = Size * a * Set a * Set a -- so a minimum of 48 bytes for each node, plus any memory to store the element, which since it is a set, has to be unique, so 16 bytes for tag and fwding pointer, plus 8 for the payload. so 24 + 48 = 72 bytes per element
17:20:58 <ski> pielgrzym : the type checker only detects a mismatch between places A and B in your code, it doesn't know which is the actual error; but if you specify your *intended* types at both A and B places, the type checker can often determine which of them doesn't match with what you expected
17:21:11 <pielgrzym> ski: :)
17:21:19 <ski> (pielgrzym : meaning either that it has found your error .. or that you expected the wrong thing :)
17:21:29 <edwardk> > 72 * 2^28
17:21:30 <lambdabot>   19327352832
17:21:36 <ski> pielgrzym : ok, i'll shut up now ;)
17:21:50 <edwardk> jbapple: so you need 19 gigs of memory just to see the problem
17:22:29 <pielgrzym> ski: I have to think this stuff over :) haskell due to it's pureness is very, hmm, abstract :)
17:22:50 <jbapple> edwardk: And you can't address that much memory with 32-bit machines (usually)
17:23:00 <edwardk> jbapple: that was already assuming a 64 bit machine
17:23:06 <edwardk> the problem can't be seen on a 32 bit machine
17:23:18 <ski> pielgrzym : well, the same basic type issues exist in any language with parametric types and type inference (like SML and OCaml) .. it applied regardless of whether the language is pure or not :)
17:23:21 <jbapple> But on 64-bit machines, Int is 64 bits, right?
17:23:26 <pielgrzym> ski: I find haskell like a funnel that you configure to shape things rather than a machine like usual imperative languages tend to resemble :)
17:23:31 <edwardk> you just can't make a set large enough in memory. those constants get cut in half but even if you play games your process won't see more than 3 gigs of memory
17:24:07 <pielgrzym> ski: yeah, I never tried those ;) wasn't amazon.com a lisp app some time ago?
17:24:11 <edwardk> so the problem can't be experienced on a 32 bit machine at all. and you need a 19 gig data structure to start to see it on a 64 bit machine. its hard to argue for it as a bug worth killing performance on much more practically sized structures ;)
17:24:29 <ski> pielgrzym : are you familiar with any other functional languages ? (like OCaml,SML,Erlang,Clean,Scheme)
17:24:41 <jbapple> edwardk: I don't know any other way to say "I am not arguing against an Int-based solution"
17:24:44 <geheimdienst> (... javascript ...)
17:24:47 <geheimdienst> ;-)
17:24:52 <pielgrzym> ski: nope :)
17:24:59 <pielgrzym> geheimdienst: javascript functional? :P
17:25:00 <ski> ok
17:25:01 <edwardk> jbapple: sure. =)
17:25:11 <ski> pielgrzym : it can be used in a functional way
17:25:21 <edwardk> jbapple: i accept that. i just wanted to say why i think any real solution needs to be Int based ;)
17:25:36 <pielgrzym> ski: recently I've seen an article one can force python to behave like that too :)
17:25:56 <ski> yeah .. but Python doesn't really encourage it
17:25:59 <jbapple> edwardk: I am also not arguing against a careful analysis showing that the problem can't come up in practice
17:26:07 <pielgrzym> ski: hehe, it sure does not :)
17:26:21 <jbapple> Is GHC's Int 64 bits on 64-bit machines ?
17:26:44 <edwardk> jbapple: oh, heh yep
17:26:47 <jbapple> edwardk: (And by "practice", I mean "at all", because of bit lengths)
17:26:48 <ski> you can code functional in Java too (<http://functionaljava.org/>) ..
17:26:51 <edwardk> jbapple: we LLP ;)
17:26:55 <edwardk> er we're LLP
17:27:15 <jbapple> So, if your 72 byte estimate on node size is correct, this may not be anything to worry about
17:27:18 <jbapple> LLP?
17:27:27 <jbapple> longlong pointer?
17:27:27 <ski> Linear Logic Programming ?
17:27:29 <edwardk> jbapple: so you can't construct a tree that exhibits the problem
17:27:32 <jbapple> limited liability person?
17:27:41 <ski> (window 136
17:27:49 <ski> Locable Legitimistic Palaeotypic ?
17:28:02 <Saizan>  /window 136 ?
17:28:10 <ski> (typo :)
17:28:13 <jbapple> LLP lined pockets?
17:28:29 <edwardk> er sorry ILP
17:28:34 <Saizan> (i hope you got a typo is in the number too :)
17:28:38 <jbapple> integer linear programming?
17:28:38 <edwardk> integer long and pointer are all 64 bit in haskell
17:28:42 <jbapple> ok
17:28:46 <Saizan> s/is//
17:28:48 <ski> (Saizan : actually not ;)
17:29:02 <geheimdienst> infused literal prognostication
17:29:08 <edwardk> even though the underlying OS usually uses a different memory model (LP or LLP)
17:29:23 <geheimdienst> intrinsic lolcat premonition
17:29:28 <BMeph> "Rumor has it" that Eich deliberately make a Scheme engine with C-like syntax, which is how Javascript came to be.
17:29:30 <edwardk> jbapple: so the problem can't occur in a 64 bit os either
17:29:37 <jbapple> unless Data.Set used <  16/3 words per element
17:29:46 <jbapple> or I find a smaller example to exhibit the bug
17:30:05 <edwardk> the bug occurs at int overflow.
17:30:14 <jbapple> Though I think any example would be 1/8 * maxBound or larger
17:30:15 <Saizan> (ski: insane :)
17:30:28 <ski> (guilty as charged)
17:30:46 <Saizan> BMeph: i was actually thinking of making an Haskell with a python-like syntax
17:31:11 <monochrom> hrm python-like syntax
17:31:16 <edwardk> so your only hope of causing it will be on a 32 bit machine.
17:31:29 <BMeph> Saizan: "Pykell"? ;)
17:31:38 <geheimdienst> hasthon
17:31:40 <monochrom> (\ x : return (x+1)) ?
17:31:50 <edwardk> because pointers have smaller range than 64 bit ints on any real 64 bit platform, giving you ~16 bits of slack
17:32:05 <BMeph> edwardk: What about a 64-bit machine with 32-bit compiler toolchain?
17:32:27 <Saizan> BMeph: the amusing part would be that e.g. x += 1 would just shadow the old x
17:32:51 <edwardk> BMeph: doesn't matter, we use 64 bit ints regardless of underlying 64 bit memory model, and a 32 bit toolchain on a 64 bit machine can only address the same 2-3 gigs of memory
17:32:59 <Saizan> and that for loops would need a return value, i guess
17:33:12 <edwardk> 4 gigs, with the top gig or two to the kernel, 
17:33:32 <jbapple> >2 ^ 60
17:33:37 <jbapple> > 2^60
17:33:39 <lambdabot>   1152921504606846976
17:33:47 <edwardk> BMeph: you can address 32 gigs of memory with PAE, but only 4 gigs per process
17:34:07 <jbapple> what's after tera? peta? What's after that?
17:34:13 <arw_> exa
17:34:23 <Rotaerk> I prefer yoda
17:34:34 <edwardk> BMeph: and in a 64 bit machine you can still only address 4 gigs per 32 bit process (minus the gig wide flat map that exists for kernels)
17:35:02 <jbapple> so, If you had > 1 exabyte of addressable memory, it might be possible to trigger this bug on a 64-bit machine :-)
17:35:07 <edwardk> jbapple: keep in mind you can't address more than 2^48 bits with the bus.
17:35:09 <arw_> Rotaerk: 640 Yodabyte for everyone enough should be.
17:35:16 <Rotaerk> :P
17:35:50 <edwardk> because not all 64 bits of address space are mapped to physical pins
17:36:07 <edwardk> there isn't a CPU out there with a real 64 bit address bus
17:36:17 <arw_> edwardk: yes, but your program won't usually use physical adresses, and your virtual address space may be larger
17:36:31 <edwardk> http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24593.pdf jbapple p 130
17:36:47 <edwardk> arw_: sadly the TLB can't index it. you can't map it even virtually
17:37:43 <jbapple> In any case, the example bug I uploaded I changed to Int16 for easy testing
17:37:47 <edwardk> the top 16 bits even in a virtual address are all 0s or all 1s
17:38:13 <jbapple> You know what's strange, I have 6G of RAM + VM, but I'm on 32 bit OS
17:38:14 <jbapple> hm
17:38:26 <arw_> edwardk: ugly... almost sounds like evil hacks from old 8086-days...
17:38:44 <edwardk> jbapple: PAE on a 32 bit OS lets you address 32 gigs over the whole machine, even if you can only map 4 gigs per process
17:40:47 <edwardk> jbapple: so back to fitting it into memory, we have 36 bytes per entry assumng we need to supply storage or 24 bytes per entry if we can make a self-referential set using, say, a free monad over Set, like Free Set Int to avoid paying for most if any of the entries by recycling parts of the set.
17:41:22 <zeta-> geheimdienst: Looks like there is code for SI unit, language binding and probability distribution. Well Pascal is quite famous :-)
17:41:24 <zeta-> I'll see if someone is interested in adding my function to their library...
17:41:41 <edwardk> 24 is still bigger than 8. even if you run on bare metal
17:44:06 <jbapple> edwardk: I think I agree. Will you add a note to the bug report? http://hackage.haskell.org/trac/ghc/ticket/4143
17:44:53 <chrisdone> good evening
17:45:07 <edwardk> jbapple: sure
17:45:11 <jbapple> There are a couple of other ways I think the bug could be triggered. One is if someone later adds lazier or more space-efficient ways to construct Sets
17:46:04 <monochrom> "bare metal" reflects how ignorant programmers are of hardware and how delusional they are in thinking they know hardware. It is semiconductors, not metals, that do the hard work.
17:46:16 <jbapple> I don't think there are such ways now
17:46:32 <jbapple> monochrom: there, there. It's ok
17:48:14 <Saizan> hey, they make memristors out of titanium dioxide, does that count as metal?
17:48:26 <aavogt> no, that's a ceramic
17:49:04 <jbapple> edwardk: Another way that it might get broken is if the constants are changed
17:49:45 <arw_> monochrom: last i checked, the most common semiconductor was a metal...
17:50:02 <monochrom> is that silicon?
17:50:17 <dancor> bare logic
17:50:53 <arw_> monochrom: yes.
17:51:07 <aavogt> that's an interesting definition of metal
17:51:10 <monochrom> silicon is not a metal
17:51:35 <dancor> bare metalloid
17:51:37 <monochrom> of course, IANAC disclaimers etc
17:51:41 <edwardk> jbapple: they'd have to change by a factor of 4-5 though
17:52:13 <edwardk> jbapple: and we explicitly keep Data.Set strict because laziness in it can cause so many other problems
17:52:49 <jbapple> edwardk: I think so, yes.
17:53:19 <edwardk> jbapple: comment added
17:53:23 <jbapple> None of these things seems imminent to me. I just think this is a bug waiting to happen.
17:53:42 <monochrom> I do grant you that if I had the money I would get a shiny pocket mirror made of bare silicon and use it to impress girls.
17:54:11 <dancor> monochrom: so what's a cooler phrase than "bare metal"
17:54:38 <dancor> bare idiosyncracies of cpu and bus
17:54:39 <arw_> monochrom: ok, so its bare metalloid then...
17:54:50 <edwardk> jbapple: i think it might be worth commenting in the source code next time someone goes in there to patch it. dons mentioned something on the -cafe the other day about how data.set etc. are as they are for largely historical reasons and are in need of a dedicated performance minded maintainer
17:55:40 <dolio> Huh, it causes runtime exceptions?
17:55:46 <dolio> I thought Int just silently overflowed.
17:56:09 <hpc> > (maxBound :: Int) + 5
17:56:10 <lambdabot>   -9223372036854775804
17:56:14 <hpc> nope
17:56:20 <hpc> er, yes
17:56:39 <dancor> > 1000 :: Int8
17:56:39 <Saizan> return [True, False]
17:56:40 <lambdabot>   -24
17:57:49 <djahandarie> > succ maxBound :: Int
17:57:50 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:57:50 <jbapple> dolio: the exception is from a call to "error" when rotating
17:57:56 <dolio> Ah.
17:58:09 <jbapple> it's an exception at run time, rather than an exception in the GHC runtime :-)
17:58:23 <djahandarie> > pred (maxBound+1) :: Int
17:58:24 <lambdabot>   *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
17:58:27 <djahandarie> Hehe
17:58:44 <edwardk> pred is smart, - is not ;)
17:58:49 <edwardk> er +1
17:58:58 <dolio> Well, if there were overflow checks, they'd throw runtime exceptions, too.
17:59:04 <dolio> As pred and succ do.
18:00:14 <dancor> i had to wire cyclicSuccessor once
18:00:49 <dancor> s/wire/write/
18:00:57 <dancor> wiring up my programs
18:02:52 <dolio> Perhaps you were programming in 2D.
18:05:33 <orlandu63> what is the point of fix? to make not lazy?
18:07:57 <cheater99> it's for currying
18:16:34 <aavogt> orlandu63: fix is for writing recursive functions, rather than depending on some bindings being recursive
18:17:00 <aavogt> nobody has to use it, so maybe that means it's pointless
18:18:00 <aristid> terrible, terrible code: http://pastebin.com/raw.php?i=6kfwTsB0
18:18:44 <hpc> i approve
18:20:27 <aavogt> haskell src exts can't parse it
18:20:49 <aavogt> hmm, I downloaded the wrong one
18:21:59 <hpc> @pl fix x
18:21:59 <lambdabot> fix x
18:22:38 <hpc> @pl let x = f x in \f -> f x
18:22:39 <lambdabot> ($ fix f)
18:23:00 <hpc> bleh
18:23:22 <aavogt> that's still bad http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26391#a26391
18:26:25 <hpc> wow, overloading number literals
18:29:06 <djahandarie> fix is nice for golfing
18:29:44 <aavogt> > fix succ
18:29:44 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:30:26 <dancor> > fix succ :: Int8
18:30:30 <lambdabot>   mueval-core: Time limit exceeded
18:30:46 <aavogt> too strict
18:31:00 <dancor> > fix succ :: Bool
18:31:04 <lambdabot>   mueval-core: Time limit exceeded
18:31:15 <dancor> ya
18:31:39 <dancor> > fix (+ 1) :: Int8
18:31:43 <lambdabot>   mueval-core: Time limit exceeded
18:32:02 <aavogt> though maybe that's a property of the data type here
18:32:11 <orlandu63> can someone show me a practical use of fix?
18:32:35 <dancor> orlandu63: http://www.vex.net/~trebla/haskell/fix.xhtml
18:34:54 <dolio> If you have a function memo :: (a -> b) -> (a -> b) that memoizes a non-recursive function, you can combine it with fix to automatically build a memoizing recursive function.
18:35:37 <orlandu63> > fix (0:)
18:35:38 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:35:56 <dolio> @type let memo :: (a -> b) -> (a -> b) in fix . memo
18:35:57 <lambdabot>     The type signature for `memo' lacks an accompanying binding
18:35:57 <lambdabot> Not in scope: `memo'
18:36:00 <dancor> > [0,0,..]
18:36:02 <lambdabot>   <no location info>: parse error on input `..'
18:36:13 <hpc> :t null
18:36:14 <lambdabot> forall a. [a] -> Bool
18:36:35 <hpc> > fix (return . null)
18:36:36 <lambdabot>   [False]
18:36:42 <orlandu63> i see
18:36:43 <hpc> ha!
18:37:59 <hpc> :t (fix . $)
18:38:00 <lambdabot> parse error on input `$'
18:38:05 <hpc> :t (fix . ($))
18:38:10 <lambdabot> forall a. (a -> a) -> a
18:38:33 <hpc> dolio: ^
18:39:48 <aavogt> :t fix
18:39:49 <lambdabot> forall a. (a -> a) -> a
18:39:55 <dancor> :t (. ($))
18:39:56 <lambdabot> forall b a b1. ((a -> b1) -> b) -> (a -> b1) -> b
18:40:55 <orlandu63> @pl (. ($))
18:40:55 <lambdabot> id
18:41:03 <dancor> i wonder if any other restrictions of (id) are 7 chars or less
18:41:22 <ski> orlandu63 : not sure whether <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> counts as a practical use
18:42:05 * ski wonders what's up with the very narrow text area in the annotation there ..
18:43:16 <dolio> > let memo :: Int -> (Int -> b) -> Int -> b ; memo i f = ((listArray (0,i) $ map f [0..i]) !) ; fib me 0 = 0 ; fib me 1 = 1 ; fib me n = me (n-1) + me (n-2) in fix fib 30
18:43:20 <lambdabot>   mueval-core: Time limit exceeded
18:43:27 <dolio> > let memo :: Int -> (Int -> b) -> Int -> b ; memo i f = ((listArray (0,i) $ map f [0..i]) !) ; fib me 0 = 0 ; fib me 1 = 1 ; fib me n = me (n-1) + me (n-2) in fix (memo 40 . fib) 30
18:43:28 <lambdabot>   832040
18:46:03 <aavogt> preflex: seen monochrom
18:46:04 <preflex>  monochrom was last seen on #haskell 52 minutes and 21 seconds ago, saying: I do grant you that if I had the money I would get a shiny pocket mirror made of bare silicon and use it to impress girls.
18:48:00 <aavogt> monochrom: it might be nice to add to http://www.vex.net/~trebla/haskell/annote-STArray.xhtml http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26392#a26392
18:48:50 <aavogt> asTypeOf (or other helper functions like it) are a rather convenient alternative to -XScopedTypeVariables
18:50:26 <aavogt> sometimes it's better since you get to leave off parts of the type that can be inferred
18:51:10 <ski> @let tabulate :: Ix i => (i, i) -> (i -> e) -> Array i e; tabulate ix f = array ix (graph f `map` range ix)
18:51:12 <lambdabot>  Defined.
18:51:22 <ski> @let memo :: Ix i => (i,i) -> (i -> e) -> (i -> e); memo ix f = (tabulate ix f !)
18:51:23 <lambdabot>  Defined.
18:51:30 <ski> > let (memo (0,40) -> fib) = \n -> case n of {0 -> 0; 1 -> 1; _ -> fib (n-1) + fib (n-2)} in fib 30
18:51:31 <lambdabot>   832040
18:53:50 <aavogt> interesting view pattern
18:55:30 <ski> for some strange reasons, the outer brackets in `(memo (0,40) -> fib)' seems to be required
18:55:44 <ski> i suspect it is a quirk that this actually happens to work
18:56:34 <ski> but imo, it would be nice to extend it so that one could write `(memo ix -> fib) 0 = 0; (memo ix -> fib) 1 = 1; (memo ix -> fib) n = fib (n-1) + fib (n-2)'
18:56:46 <ski> (where `ix' is some free variable)
18:57:29 <ski> .. one could allow `ix' to be any expression, as long as it is the same expression in every equation
18:57:36 <aavogt> perhaps the parentheses are required to be consistent with patterns in case (where a couple -> in a row is a bit confusing)
18:58:23 <ski> i suspect the above behaviour wasn't considered, when implementing view patterns .. and that it just "happens" to work
18:59:20 <ski> (because `x = ...' is not a function binding, but a value binding, just like `(x,y) = ...' -- and just like in `f x = ...', `x' is a pattern binding !)
18:59:34 <ski> (er, s/pattern binding/value binding/)
19:00:21 <ski> (iow, i suspect they just reused the same code for `x' in `x = ...' and `(x,y) = ...' as for `x' in `f x = ...')
19:31:43 <titaniumdecoy> asInt2 :: String -> Int
19:31:43 <titaniumdecoy> asInt2 xs = foldr step 0 xs
19:31:43 <titaniumdecoy>             where step acc x = trace (show x) 0
19:31:52 <titaniumdecoy> why does this print zeroes?
19:32:09 <titaniumdecoy> i am trying to inspect each char of a string in reverse
19:32:20 <BMeph> titaniumdecoy: Because UR DOIN IT RONG!!!11!!1!11!1!1ichi!!1
19:33:44 <monochrom> because it is obviously designed to print zeroes
19:33:56 <monochrom> @type foldr
19:33:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:34:16 <monochrom> or rather you misunderstood foldr
19:35:12 <monochrom> in that type signature, "b" is for accumulation, "a" is for list content. evidently, you should write step x acc = trace (show x) 0
19:35:48 <titaniumdecoy> huh
19:36:00 <titaniumdecoy> so the step function takes its arguments in the reverse order of foldl?
19:36:50 <monochrom> I don't know. I don't compare foldl and foldr. I also don't bother remembering. I look at the types again every time I use them.
19:37:13 <titaniumdecoy> asInt2 xs = foldr step 0 xs
19:37:13 <titaniumdecoy>             where step x acc = trace (show x) 0
19:37:22 <titaniumdecoy> why does this print '1' instead of 5,4,3,2,1?
19:37:32 <titaniumdecoy> shouldn't it be traversing the list backwards?
19:38:48 <monochrom> because of details of lazy evaluation. some Â«traceÂ» calls are thrown away after done once.
19:39:12 <titaniumdecoy> can i use seq to force it to be evaluated?
19:39:46 <monochrom> at the first call, computer sees Â«step x acc = trace (show x) 0Â». at the second call onwards, the computer sees Â«step x acc = 0Â».
19:40:12 <monochrom> seq does not change this because "it" is already forced as is.
19:40:26 <titaniumdecoy> is there a way around this?
19:40:52 <monochrom> use a compiler that does not do lazy evaluation.
19:41:53 <BMeph> > foldr f z [a,b,c,d,e]
19:41:53 <lambdabot>   f a (f b (f c (f d (f e z))))
19:42:01 <titaniumdecoy> thx all
19:43:43 <BMeph> "Lazy: Having a pronounced tendency not to do unnecessary work." -- Excellent defn, there. :)
19:43:44 <orlandu63> > foldl f z [a,b,c,d,e]
19:43:45 <lambdabot>   f (f (f (f (f z a) b) c) d) e
19:45:45 <monochrom> hahaha
19:47:19 <ReinH> hi folks. Anyone mind taking a look at this wiki page and helping me translate section 3 into QuickCheck 2 compatible code? http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
19:49:15 <aavogt> ReinH: isn't it enough just to comment out the coarbitrary?
19:50:00 <ReinH> hmm, Arbitrary Char is already defined
19:52:33 <aavogt> ReinH: if you don't want a newtype of Char with that (possibly different?) instance, you can use   forAll instead:
19:52:51 <aavogt>  quickCheck (forAll (choose ('\32', '\128')
19:53:13 <aavogt>  quickCheck (forAll (choose ('\32', '\128')) $ \x -> x == x)
19:53:47 <ReinH> hmm
19:53:48 <ReinH> thanks
20:29:37 * hackagebot dbus-core 0.8.3 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.3 (JohnMillikin)
20:33:38 * hackagebot anansi 0.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.1 (JohnMillikin)
20:50:01 <ReinH> Ok, one possibly silly question. How can I get my emacs haskell-mode ghci to find modules in other files in the same directory. command line ghci finds them.
20:51:27 <ReinH> hmm, I think my question is here: http://osdir.com/ml/haskell-cafe@haskell.org/2009-04/msg00868.html
20:51:40 <ReinH> there's got to be a better mailing list web viewer
20:53:25 <ReinH> huh, apparently I can just touch a cabal file
20:53:30 <ReinH> fair enough
20:58:47 * hackagebot bindings-glib 0.1.3 - Low level bindings to GLib.  http://hackage.haskell.org/package/bindings-glib-0.1.3 (MauricioAntunes)
21:11:52 * hackagebot bindings-fann 0.0.2 - Low level bindings to FANN neural network library.  http://hackage.haskell.org/package/bindings-fann-0.0.2 (MauricioAntunes)
21:11:53 <TwYsTeD> Romans 10:9-10 because, if you confess with your mouth that Jesus is Lord and believe in your heart that God raised him from the dead, you will be saved. For with the heart one believes and is justified, and with the mouth one confesses and is saved. 
21:11:58 <TwYsTeD> John 3:16 "For God so loved the world, that he gave his only Son, that whoever believes in him should not perish but have eternal life. 
21:23:59 <danharaj> Was that christian spam?
21:24:23 <p_l> danharaj: christian variant of fanatism, I guess
21:24:31 <p_l> the mild and moderate version
21:25:21 <dolio> The real question is: how does he choose his bolding scheme for each quote?
21:40:15 <Veinor> For some reason I'm unable to brain right now
21:40:29 <Veinor> hwo do I print a list of strings as, say, ["foo", "bar"]?
21:42:00 <aavogt> mapM_ putStrLn
21:42:04 <Veinor> oh wait, that's what print will do
21:42:10 <Veinor> I was confused by ghci
21:42:22 <Veinor> :t mapM_
21:42:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:42:26 <aavogt> oh, I can't interpret questions either
21:43:03 <Hunner> what's with the _? is that a common postfix for something?
21:43:57 <Veinor> :t mapM
21:43:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
21:44:08 <Veinor> :t sequence
21:44:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:44:11 <Veinor> :t sequence_
21:44:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:54:48 <BMeph> Just curious, but are there any moderators for -in-depth?
22:04:02 <Bigcheese> does haskell-platform not include ghc?
22:08:19 <BMeph> Bigcheese: Au contraire, HP is the GHC answer to other language's "Batteries Included". :)
22:08:44 <ivanm> Bigcheese: the unix tarball doesn't include GHC though
22:08:49 <Bigcheese> Ah
22:09:04 <ivanm> since you can get a generic unix tarball off the ghc site
22:09:22 <Bigcheese> I'm trying to use cabal, but ghc doesn't see any of the packages I add with it.
22:09:24 <BMeph> So, does anyone recognize why I'd get this message when trying to run the ASCII-art paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26395
22:10:01 <Bigcheese> Or more accuratly, 'runhaskell Setup.hs configure' doesn't
22:10:03 <ivanm> Bigcheese: as in cabal-install ?
22:10:11 <ivanm> Bigcheese: do you have GHC? is it on the PATH?
22:10:26 <Bigcheese> yes, which ghc returns /usr/bin/ghc
22:10:33 <ivanm> BMeph: do you have hte network library installed?
22:10:54 <ivanm> Bigcheese: do "runhaskell Setup.hs clean" and then try configuring it again
22:10:58 <ivanm> and paste the errors up somewhere
22:11:17 <Bigcheese> k
22:13:11 <BMeph> ivanm: I have the Platform installed, so yes. :)
22:13:40 <ivanm> BMeph: weird...
22:13:54 <ivanm> BMeph: how did you try running it?
22:14:01 <ivanm> I just downloaded it and then did "runhaskell Foo.hs"
22:14:57 <dolio> dons or dcoutts: ping?
22:15:27 <Bigcheese> http://codepad.org/627MQiW9
22:15:48 <Bigcheese> The problem being that after doing 'cobal install readline' it still thinks it needs readline.
22:16:38 <ivanm> Bigcheese: try doing just "cabal install" in that directory
22:16:47 <ivanm> Bigcheese: but I have the sneaking suspicion that there might be breakage in your system
22:16:48 <BMeph> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26395#a26396
22:16:52 <ivanm> what does "ghc-pkg check" say?
22:17:47 <ivanm> BMeph: you don't have any other files in that directory?
22:17:53 <ivanm> you don't have any broken packages?
22:18:09 <Bigcheese> ivanm: cool, that worked. Thanks.
22:18:12 <ivanm> also, with that weird slash, am I correct in assuming that you're using windows?
22:18:13 <ivanm> Bigcheese: np
22:18:37 <BMeph> ivanm: I have a ton of other files in that directory, and as far as I know, none of my packages are broken.
22:19:02 <BMeph> ivanm: Also, yes, I am using Windows Vista. =8*O
22:19:03 <ivanm> maybe try doing it in a different directory
22:19:07 <ivanm> with nothing else in it
22:19:16 <ivanm> BMeph: I found the lhs bit the weirdest bit :s
22:20:20 <BMeph> ivanm: You too, eh? ;)
22:21:01 <BMeph> ivanm: Anyhow, it seems to be working. I imagine I must have a file named "Network" in my Haskell directory; I'll check for it. :)
22:21:26 <ivanm> BMeph: right, that's what I was hinting at
22:21:27 <ivanm> ;-)
22:28:53 <danharaj> what was the name of that thing on Windows that is supposed to be like Cygwin except with mingw as a base?
22:28:56 <danharaj> (Yes that was vague)
22:29:25 <ivanm> I forget...
22:30:25 <danharaj> ah
22:30:28 <danharaj> takeoffgw
22:30:53 <ivanm> yeah, just about to say that
22:31:18 <danharaj> I really want haskell platform to be based on it
22:31:40 <danharaj> it'll probably help resolve all the little "fuck you, user" bugs I get trying to build some library bindings.
22:35:09 <om-foxy> any hackage maintainers about?
22:35:32 <om-foxy> dons: bummer about Wilkinson, eh :)
22:37:22 * hackagebot hstatistics 0.1.0.4 - Statistics  http://hackage.haskell.org/package/hstatistics-0.1.0.4 (VivianMcPhail)
22:40:02 <p_l> danharaj: msys.
22:40:06 <p_l> danharaj: there's also SUA
22:40:52 <danharaj> p_I: I was thinking of takeoffgw, but thanks.
22:47:53 <BMeph> danharaj: I really think MinGW is what it's called. :)
22:48:55 <dons> om-foxy: sigh
22:49:20 <dons> om-foxy: we claim dignity, but i may be waving an NZ flag next week. :-)
22:49:29 <om-foxy> dons: heh
22:49:47 <om-foxy> dons: did you get to watch the match in us?
22:50:17 <dons> just highlights online.
22:50:29 <om-foxy> dons: almost all the rugby is on Sky here :(
22:50:41 <dons> my guess is england is making up for their soccer team.
22:50:54 <om-foxy> dons: LOL
22:51:30 <dons> will wake up early to watch the nz game tomorrow.
22:51:49 <om-foxy> dons: its going to be a late night at GMT+12
22:52:02 <dons> 7am here.
22:52:15 * dons -> home. nytol. 
22:52:30 <ReinH> I can't define an instance Show for a type can I?
22:52:33 <ReinH> for instance: https://gist.github.com/420c8d9c735e455338c3
22:52:52 <ReinH> I want show for Circuit to be defined as showCircuit
22:53:12 <ReinH> but it complains that Circuit is a type synonym
22:53:24 <ReinH> I guess I need a real data constructor?
22:54:41 <om-foxy> ReinH, you could define that for which Circuit is a synonym as Show
22:55:24 <om-foxy> instance thereof
22:56:29 <ReinH> om-foxy: I'm sorry, I don't follow
22:56:40 <ReinH> what is "that for which Circuit is a synonym"?
22:57:05 <om-foxy> type Circuit = Foo In Out
22:57:07 <om-foxy> instance Show (Foo In Out) where
22:58:30 <titaniumdecoy> is there a way to test for more than one constructor in a LET?
22:58:31 <titaniumdecoy> let Right n = asInt xs
22:58:31 <titaniumdecoy> what if (asInt xs) returns a Left?
22:58:57 <ReinH> om-foxy: ok, I think that makes sense. So if Circuit is: type Circuit = (Address, [Gate], Address)
22:59:05 <om-foxy> type Circuit = (Address, [Gate], Address)
22:59:06 <om-foxy> instance Show ((Address,[Gate].Address)) where
22:59:11 <ReinH> riight
23:00:19 <ReinH> om-foxy: I'm sorry, I'm not sure how to write the where clause for that
23:01:27 <ivanm> ReinH: any particular reason for wanting to use Show for this?
23:01:48 * ivanm is a firm believer in not using Show for pretty-printing purposes
23:02:22 <om-foxy> where
23:02:24 <om-foxy>     show (a1,[],a2)      = "(" ++ show a1 ++ "-" ++ show a2 ++ ")"
23:02:25 <om-foxy>     show (a1,x:xs,a2)  = "(" ++ show a1 ++ "[" ++ show x ++ "," ++ show xs ++ "]"++ show a2 ++ ")"
23:02:27 <om-foxy> ivanm's observation aside :)
23:02:38 <ivanm> heh
23:02:44 <ReinH> ivanm: so show x is not semantically appropriate for (the string representation of x)?
23:03:06 <ivanm> ReinH: Show and Read are meant to read and parse in String representations of the code
23:03:34 <ivanm> it's not too bad if you make sure your Read instance reads what your Show instance does
23:03:35 <ReinH> ivanm: some context may be helpful: these circuits have string representations that I need to output.
23:03:53 <ivanm> ReinH: so use a printCircuit function or something
23:04:13 <ReinH> ivanm: right, ok, that's what I've been doing
23:04:19 <ivanm> then keep doing that
23:04:23 <ReinH> it just seemed simpler if circuits could show themselves
23:04:36 <ReinH> and I didn't/don't understand why that's not desirable
23:04:41 <ivanm> ReinH: you mean when debugging in ghci?
23:04:56 <ReinH> ivanm: are Show and Read for something like marshalling?
23:04:57 <ivanm> ReinH: let me give you an example about why this behaviour is desirable
23:05:03 <ReinH> as opposted to just toString()
23:05:17 <ivanm> ReinH: yeah, kinda
23:05:33 <ivanm> OK: the de-facto graph structure library is (currently) fgl
23:05:44 <ivanm> it comes with two implementations by default
23:05:49 <ivanm> one has a Show instance, the other doesn't
23:05:53 <ReinH> there is theoretically a Read for circuits, making the string representation isomorphic
23:06:01 <ivanm> the one that _does_ have a Show instance uses it to pretty-print the graph...
23:06:10 * ReinH following
23:06:16 <ivanm> which is useful, except in practice means it's a PITA to debug graph code
23:06:34 <ReinH> because you always see the string representation
23:06:38 <ReinH> not the components
23:06:40 <ivanm> because you can't just "save" the current state by printing it out, saving it somewhere and then pasting it back in and using it
23:07:03 <ivanm> ReinH: if you have a proper Read instance that can parse in the Show output, it's not too bad
23:07:09 <ReinH> right
23:07:15 <ivanm> but in that case, you should define your own type rather than using a 3-tuple
23:07:16 <ReinH> ok, that makes sense
23:07:37 <ivanm> and even still, there's still the usual assumption that Show outputs valid Haskell code
23:07:45 <ReinH> ah ha
23:07:45 <ivanm> so you don't have to actually use Read if you don't want
23:07:52 <ReinH> makes sense
23:08:15 <danharaj> http://namebinding.wordpress.com/about/
23:08:21 <danharaj> this is the most specific blog I've seen yet
23:08:29 <ivanm> e.g. "print $ Just (Right 3.5)" will print (without quotes) "Just (Right 3.5)"
23:08:32 <ivanm> which is the actual code value
23:08:54 <ivanm> danharaj: looks like it was for a thesis
23:09:21 <ReinH> ivanm: makes sense
23:09:21 <ivanm> the problem with that kind of blog is that they're so specific you stop updating them once the reason for starting that blog (thesis, GSoC, etc.) are over
23:09:37 <ivanm> ReinH: just to give you some perspective about why I'm so obsessed with this:
23:09:48 <ivanm> I now manage the graphviz library, that as part of it will print and parse Dot code
23:09:57 <ReinH> ivanm: so I want to have conversion methods to and from a circuit specification string
23:10:03 <ReinH> I thought Show and Read would be appropriate
23:10:09 <ivanm> when I inherited it, it was using Show for printing and polyparse for parsing
23:10:41 <ivanm> this meant that debugging was harder, and when I went to go and do more advanced stuff I had problems because the Show instance wasn't smart enough, or the Show instance was pre-defined for that type, etc.
23:10:46 <ReinH> nod
23:11:09 <ReinH> ivanm: could you suggest another pattern for convertToString convertFromString type behavior?
23:11:12 <ivanm> ReinH: if you have your own data type, then it's arguable that using Show and Read is OK if show . read == id
23:11:19 <ReinH> nod
23:11:27 <ivanm> especially if you only have the one type
23:11:28 <ReinH> if there's an isomorphism
23:11:32 <ivanm> right
23:11:54 <ReinH> that makes sense, but I am worried (slightly) about the non-Haskell nature of the output
23:12:02 <ivanm> however, I have the sneaking suspicion that you're going to regret it down the track when you need to do some extra debugging
23:12:25 <ReinH> for instance, a vague equivalent in Ruby would be the semantic nature of to_s and to_str: to_s is "has a string representation" and to_str is "this thing is a string, damn it"
23:12:30 <ivanm> as it will make it harder to interact with your code and "save" debugging sessions (e.g. you need to edit some code and reload it in ghci, which means you lose all the stuff you did just before it)
23:13:00 <ReinH> so things like integers have to_s but not to_str
23:13:10 <ivanm> ReinH: if the String representation is going to be complex, use real pretty-printing and parsing libraries
23:13:24 <ReinH> nod
23:13:27 <ReinH> not that complex at all
23:13:28 <ivanm> and have actual toString and fromString functions (whatever you want to call them)
23:13:38 <ReinH> but I see the benefit
23:13:42 <ivanm> if they're not complex and this is a toy problem, you might be OK
23:14:04 <ivanm> but if you're going to keep maintaining and expanding upon this down the track, I can almost guarantee this is going to come back and bite you later on
23:14:21 <ReinH> ivanm: I've implemented Show on some things where it made more sense. This might be hitting a complexity boundary where I would not want to do so.
23:14:42 <ivanm> right; pretty, etc. are usually better in that regard than Show is
23:14:52 <ReinH> nod
23:15:00 <ReinH> thanks for explaining that to me
23:15:03 <ivanm> (note that using ShowS rather than String for intermediate values will help improve efficiency)
23:15:12 <ReinH> I'd rather know than run about blindly
23:15:12 <ivanm> np
23:15:35 <ivanm> ReinH: from what you were saying about ruby, it sounds like values have default pretty-printing methods, etc.
23:15:37 <ReinH> which reminds me that I should write Read for those things that have Show
23:15:44 <ivanm> with the Haskell approach, you can customise them
23:15:53 <ReinH> ivanm: ruby has #inspect, which is similar
23:16:05 <ivanm> ReinH: another reason for not using Show and Read: Read instances can be a pain to write by hand ;-)
23:16:19 <ReinH> for Ruby classes with a literal constructor, obj.inspect will be Ruby code that can evaluate into the object
23:16:22 <ReinH> for instance
23:16:24 <ivanm> it gets a little better if you're willing to forgo compatability and make it GHC-specific and use ReadP rather than ReadS
23:16:26 <ReinH> [1,2,3].inspect #=> "[1, 2, 3]"
23:17:01 * ivanm goes to grab something to eat
23:17:08 <ReinH> but it's also common in Ruby to define inspect on objects where this doesn't hold, for simpler repressentation in debugging output, etc
23:17:28 <ReinH> whereas #to_s is used for "give me the string representation of this thing"
23:19:52 <ivanm> ReinH: see, in my case for graphviz, I've used a custom pretty-printing class because I have to treat some things differently than the defaults
23:20:16 <ivanm> more so for parsing than printing (e.g. how to properly parse floating-point numbers with all the weird possibilities Dot code allows)
23:23:34 * hackagebot ige-mac-integration 0.0.0.1 - Binding to the ige-mac-integration library.  http://hackage.haskell.org/package/ige-mac-integration-0.0.0.1 (HamishMackenzie)
23:24:04 <ivanm> hamishmack: wow, that has to be one of the most un-englightening descriptions I've seen for a Haskell package ;-)
23:25:02 <ivanm> hamishmack: also, your darcs repo doesn't seem to exist...
23:25:15 <hamishmack> Have requested the repo
23:25:40 <ivanm> fair enough
23:25:54 <hamishmack> and the description in cabal file is "ige-mac-integration helps integrate Gtk applications with the native Mac desktop and make it feel more like a Mac application."
23:26:02 <hamishmack> not sure where the other one comes from
23:26:08 <ivanm> yeah, I saw that
23:26:26 <ivanm> Synopsis
23:26:33 <hamishmack> ah yes
23:26:56 <hamishmack> I copied it from the GtkSourceVIew package
23:27:23 <ReinH> ivanm: do you have a good example of an instance of Read handy?
23:27:34 <ivanm> how to do it manually?
23:27:40 <ivanm> you OK making it GHC-only?
23:28:03 <ReinH> ivanm: yes
23:28:18 <ivanm> see how I do the Read instances for Context and Edge here: http://code.haskell.org/FGL/fgl/Data/Graph/Inductive/Graph.hs
23:28:30 <ReinH> ivanm: reading, ty!
23:28:33 <ivanm> note that readP = readS_to_P
23:28:35 <ivanm> np
23:29:06 <ivanm> ReinH: that there is basically duplicating what the "real" Read instance would look like if GHC could currently derive it, which it can't due to usage of TypeFamilies
