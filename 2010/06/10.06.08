00:01:50 <roconnor> one time computations?
00:01:54 <roconnor> hmm
00:02:01 <roconnor> maybe I'm wrong
00:47:42 * hackagebot derivation-trees 0.7.1 - Typeset Derivation Trees via MetaPost  http://hackage.haskell.org/package/derivation-trees-0.7.1 (JeanPhilippeBernardy)
01:16:24 <PeakerLaptop> Does monads-fd have a dvcs repo to contribute to?
01:18:43 <PeakerLaptop> base 4 was in GHC 6.10 or just GHC 6.12?
01:19:23 <Botje> 6.10
01:19:39 <gio123> ski
01:19:55 <PeakerLaptop> Is it reasonable to start using a base >=4 && <5 requirement on packages?
01:20:01 <PeakerLaptop> Or are core packages still trying to support base 3?
01:20:23 <PeakerLaptop> an old monads-fd I was looking at has a "base" requirement without specifying which
01:24:51 <PeakerLaptop> I wish all packages on hackage had a mandatory DVCS host field -- somewhere you can send patches
01:25:00 <Zao> /dev/null
01:25:58 <byorgey> PeakerLaptop: yes, it's quite reasonable to use  base >=4 
01:25:58 <PeakerLaptop> I want to use the new monads-fd/transformers but fclabels wants an old monads-fd that wants an old transformers
01:26:05 <byorgey> PeakerLaptop: althouhg I would use <4.3 rather than <5
01:26:29 <byorgey> PeakerLaptop: base-3 is going to be deprecated soon, all packages ought to start moving away from it
01:26:36 <PeakerLaptop> byorgey, the PVP's narrow version deps are so problematic, as you need to upload new versions of packages just to fix that narrow range to be wider later
01:26:58 <PeakerLaptop> I think versions in cabal-install really really ought to be replaced by import/export signatures matchup
01:27:12 <danharaj> probably a good idea
01:27:24 <byorgey> sure it's a good idea, but we don't have that yet =)
01:27:26 <danharaj> Versions are only a proxy for what is actually intended to be matched.
01:27:52 <Starfire> PeakerLaptop: fclabels-0.4.2.1 should use a recent monads-fd.
01:28:13 <byorgey> in the meantime, I think it's much better to have to upload a new version to bump some dependencies now and then, rather than having things break because they said they would work with a newer version of a package and they don't.
01:28:33 <PeakerLaptop> Starfire, I cloned fclabels from github, it's version field says 1.0.0 and it still depends on old monads-fd
01:28:38 <danharaj> It seems things like to break when updates happen very often in haskeland.
01:28:39 <danharaj> :p
01:28:56 <PeakerLaptop> byorgey, it's not very scalable and causes dependency hell too
01:29:11 <Starfire> PeakerLaptop: monads-fd-0.0.* ?
01:29:15 <PeakerLaptop> Starfire, Yeah
01:29:29 <ksf> we should seriously consider starting a journal.
01:29:45 <tibbe> does this make sense from a strictness perspective:
01:29:45 <Starfire> The one in hackage depends on monads-fd (>=0.0 & <0.2)
01:29:46 <tibbe>   let !u' = u+1
01:29:46 <roconnor> ksf: I'm in
01:29:51 <tibbe>   return $! Unique u'
01:29:51 <roconnor> ksf: what are we talking about?
01:29:54 <ksf> suggested name for the organising body: HGRP. Haskell Group of Reviewing Peers.
01:29:57 <PeakerLaptop> Starfire, ah, I hope the github one isn't out of date
01:30:05 <tibbe> Unique is strict in u', but u' is already evaluated
01:30:09 <Botje> tibbe: might as well do return $! Uniqute $! u + 1
01:30:15 <Botje> -t
01:30:43 <tibbe> Botje: but if Unique is a newtype I shouldn't need the extra $! after return
01:30:52 <tibbe> Botje: or do I?
01:31:48 <ksf> I think mostly about peer review and assembling quality papers
01:32:09 <Botje> correct
01:32:17 <Botje> so just return $ Unique $! u + 1
01:32:39 <ksf> starting off with "if it's here, someone actually reproduced those benchmarks and checked that they say what is claimed they say"
01:34:02 <tibbe> Botje: ok
01:34:03 <tibbe> thanks
01:34:06 <scree> > length (return $ undefined)
01:34:07 <lambdabot>   1
01:34:14 <scree> > length (return $! undefined)
01:34:15 <lambdabot>   *Exception: Prelude.undefined
01:34:58 <ksf> roconnor, the general thing is that we need more academically respected open access peer review journals.
01:35:25 <ksf> open access doesn't mean a thing if you have to publish at acm to get a job.
01:37:26 <danharaj> this network likes to split, no?
01:37:31 <PeakerLaptop> So, the newest fclabels on Hackage make me stuck on an old transformers :-(
01:37:46 <ksf> irc does, in general
01:38:00 <ksf> at least if you've got enough servers
01:38:06 <PeakerLaptop> Even though I know how to fix all packages involved, there's no easy way to send the patches and have reasonable certainty any would be expected
01:38:22 <ksf> things improved vastly with the new ircd, though.
01:38:23 <PeakerLaptop> Maybe if .cabal files could specify dependencies from some web source -- I could point it at my forks
01:39:35 <Starfire> PeakerLaptop: You can always loosen up the fclabels deps from the .cabal file if you have a custom version installed?
01:40:07 <PeakerLaptop> Starfire, Can't, if I use that to use a new transformers version, nobody else would be able to install my package, because they will indirectly depend on old transformers
01:40:31 <PeakerLaptop> Also fclabels changed it's interface
01:40:45 <danharaj> did you mail the maintainer?
01:41:42 <Starfire> PeakerLaptop: Are you using a version of transformers that's newer than the one on hackage?
01:44:46 <PeakerLaptop> Starfire, no.. I want to use the newest one from Hackage (0.2.*) but fclabels depends on an old monads-fd, which depends on transformers (0.1.*)
01:46:54 <Starfire> It appears that the github version has a newer interface, but depends on older packages, whereas the hackage version is older, but has apparently been patched to depend on a newer monads-fd.
01:47:28 <PeakerLaptop> Sent him a github message
01:48:27 <PeakerLaptop> Starfire, the newest on Hackage, according to my recent "cabal update" is fclabels-0.4.2 which depends on monads-fd 0.0
01:48:33 <PeakerLaptop> 0.0.*
01:51:58 <Starfire> PeakerLaptop: http://hackage.haskell.org/package/fclabels -- The newest hackage version should be 0.4.2.1
01:59:11 <PeakerLaptop> Starfire, ah, whoops, thanks
02:00:38 <PeakerLaptop> cool, got new transformers :)
02:02:31 <Starfire> But it does appear that the hackage version doesn't contain the newest updates.
02:08:35 <Itkovian> This should be cleanup up: http://haskell.org/haskellwiki/Jobs
02:08:41 <Itkovian> still has a job from 2008
02:09:34 <danharaj> Haskellers and time travellers are overlapping groups.
02:11:21 <Gracenotes> @hoogle showVersion
02:11:21 <lambdabot> Data.Version showVersion :: Version -> String
02:40:52 <robertmassaioli> preflex: seen dons
02:40:52 <preflex>  dons was last seen on #haskell 4 hours, 39 minutes and 8 seconds ago, saying: anthonix_: look in Data.Bit
02:41:16 <robertmassaioli> preflex: seen robertmassaioli 
02:41:17 <preflex>  robertmassaioli was last seen on #haskell 25 seconds ago, saying: preflex: seen dons
02:43:54 <pastorn> @src returnA
02:43:54 <lambdabot> returnA = arr id
02:43:56 <pastorn> ah
02:44:00 <pastorn> @type returnA
02:44:01 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
02:44:17 <pumpkin> Abba!
02:44:17 <pastorn> @type arr
02:44:18 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
02:44:23 <pumpkin> Arr matey
02:44:28 <pumpkin> Shiver me timbers
02:44:29 <pastorn> pumpkin: :D
02:44:33 <pumpkin> Allo
02:44:35 <pastorn> allu
02:44:45 <pastorn> are you un-applied?
02:44:53 <pastorn> you haven't reached co-* yet...
02:45:01 <pumpkin> I'm in a mcdonalds in Amsterdam 
02:45:03 <pumpkin> And yep
02:45:15 <pastorn> pumpkin: APPLY YOURSELF!
02:45:20 <pumpkin> Lol no
02:45:22 <pastorn> haha
02:45:30 <pumpkin> I'm gonna go walk around a bit
02:45:42 <ClaudiusMaximus> what's the quickest/easiest way to get a PNG into an OpenGL texture from Haskell?  (i don't mind converting it before-hand to PPM or something else)
02:46:02 <pastorn> ClaudiusMaximus: SDL supposedly have fiddy different texture loaders
02:46:45 * ClaudiusMaximus dislikes SDL even more than GLUT...
02:46:53 <pastorn> ClaudiusMaximus: SDL-image
02:46:55 <PeakerLaptop> ClaudiusMaximus, why?
02:47:08 <pastorn> isPNG :: FilePath  -> IO  Bool
02:47:14 <pastorn> load :: FilePath  -> IO  Surface
02:47:16 <PeakerLaptop> ClaudiusMaximus, SDL at least has a complete keyboard input mapping and anti-aliased fonts (via SDL-ttf)
02:47:19 <pastorn> looks awesome to me
02:47:30 <PeakerLaptop> I hate that OS X makes SDL difficult
02:47:48 <exDM69> PeakerLaptop: it also tries it's best to make my computer look like it looked back in 1995
02:48:01 <ClaudiusMaximus> well, i just had nightmares with SDL years ago (from C), maybe it's improved
02:48:09 <exDM69> PeakerLaptop: if you start your game/app with SetVideoMode, you're doing it wrong
02:48:20 <exDM69> you should not change video modes at all in most cases
02:48:37 <arw_> especially nowadays where everybody has a one-resolution tft
02:48:49 <PeakerLaptop> exDM69, It's a misnamed function, it basically opens a window
02:48:49 <pastorn> ClaudiusMaximus: just follow the white rabbit: http://hackage.haskell.org/package/SDL-image
02:48:58 <PeakerLaptop> exDM69, and if it's full-screen, then "setVideoMode" does make sense
02:48:58 <exDM69> PeakerLaptop: and possibly changes the video mode
02:49:01 <ClaudiusMaximus> k
02:49:15 <PeakerLaptop> exDM69, Why is this a problem? Games generally DO set full screen with their own video mode
02:49:22 <arw_> PeakerLaptop: whether it only opens a window depends on the underlying layer.
02:49:23 <exDM69> PeakerLaptop: if you want something fullscreen you should just make it fullscreen and not touch the video mode
02:49:43 <exDM69> PeakerLaptop: games should not do that. and thankfully it's not that common any more
02:49:45 <arw_> PeakerLaptop: it does different things on windows, linux/X, linux/svga etc.
02:50:02 <PeakerLaptop> exDM69, Anyhow, SDL lets you detect the current mode, doesn't it?
02:50:23 <exDM69> PeakerLaptop: the proper way to go fullscreen in X is to use extended window manager hints (windows has something similar)
02:50:32 <exDM69> what SDL does is plain wrong
02:51:52 <PeakerLaptop> exDM69, Well, for non-GL graphics, scaling is non-trivial, so I guess games in that mode are kind of hard-coded to some number of pixels
02:52:28 <PeakerLaptop> exDM69, But you are right, SDL should offer a way to keep the existing video mode and go full-screen or get a correct-aspect-ratio window.  But in other aspects SDL is great
02:52:34 <PeakerLaptop> Whereas GLUT sucks in almost every aspect :)
02:52:59 <exDM69> PeakerLaptop: SDL is a bit better than GLUT, it's also very portable and very stable and runs on pretty much anything
02:53:18 <PeakerLaptop> bad implementation: Keys like "shift+tab" (at least in GLUT Linux) don't get reported as events.  Takes over the mainloop, and installs a really crappy one (no reactor/fds).  Ugly state-ful interface
02:54:05 <exDM69> PeakerLaptop: but the API is just so 20th century, it just gets in the way if you want to do anything slightly more advanced (special opengl contexts, multiple windows, multiple displays)
02:54:13 <PeakerLaptop> I tried switching a GUI toolkit I worked on from SDL to GLUT, and it was kind of nightmare-ish.. Esp. 2d graphics with OpenGL suck
02:54:53 <mreh> PeakerLaptop: I was just about to try and understand them
02:54:56 <exDM69> too bad opengl is pretty much your only option if you want real-time performance and nice graphics
02:54:59 <mreh> :(
02:55:21 <PeakerLaptop> I used graphics-drawingcombinators for less painful 2d graphics with GL
02:55:26 <PeakerLaptop> But it lacks cropping, which I needed
02:55:37 <mreh> PeakerLaptop, have you blogged about this?
02:55:44 <PeakerLaptop> mreh, No, I am too lazy to blog
02:55:49 <mreh> I need to see some code that worked, I'm getting segmentation faults
02:56:36 <PeakerLaptop> exDM69, http://www.libsdl.org/cgi/docwiki.cgi/SDL_GetVideoInfo?highlight=(\bCategorySDLVideo\b) -- lets you get the "best" video mode
02:57:04 <exDM69> PeakerLaptop: I do know that, I am very familiar with the SDL API and also it's implementation on different platforms
02:57:55 <PeakerLaptop> exDM69, ah, so if you use that -- will that just use the existing video mode?
02:58:01 <mreh> do I need to stick Graphics.DrawingCombinators.render in a callback?
02:58:09 <PeakerLaptop> mreh, That's what I did
02:58:16 <PeakerLaptop> mreh, Seg faults where?
02:58:33 <mreh> PeakerLaptop, when I call render
02:58:39 <mreh> but I don't think I'm suppose to call it
02:59:10 <exDM69> PeakerLaptop: it will try to detect the video mode and then it sets that the old fashioned way
02:59:26 <exDM69> PeakerLaptop: the result is that all SDL apps open on the wrong display on my dual head setup
02:59:27 <ClaudiusMaximus> ... i think what i'll end up doing is using a script to convert png via ppm+pgm to raw rgba bytes, and load that into my program with hGetBuf or whatever it's called.. same as i do in C..
03:00:17 <mreh> ClaudiusMaximus, there's pngload on hackage
03:00:36 <mreh> we really badly need someone to bind libavcodec, lord knows I'll try
03:00:39 <exDM69> PeakerLaptop: if you use extended window manager hints and let the WM do the job, it's done right (also more simple to code)
03:00:40 <PeakerLaptop> mreh, http://github.com/Peaker/lui/blob/glut/src/Example.hs
03:00:47 <mreh> PeakerLaptop I love you
03:01:09 <PeakerLaptop> mreh, heh :)
03:01:32 <ClaudiusMaximus> mreh: looks great, thanks!
03:01:38 <PeakerLaptop> mreh, specifically: http://github.com/Peaker/lui/blob/glut/src/Example.hs#L187
03:02:00 <PeakerLaptop> mreh, and http://github.com/Peaker/lui/blob/glut/src/Graphics/UI/LUI/Run.hs#L17
03:03:03 <mreh> PeakerLaptop, what's the purpose of the translate?
03:04:08 <PeakerLaptop> mreh, I wanted my coordinate system to be (0,0) top left to (1,1) on bottom right
03:04:17 <PeakerLaptop> Or maybe it ended up (2,2) on bottom right by accident :)
03:05:03 <PeakerLaptop> mreh, you can probably ignore the translate
03:09:02 <ivanm> preflex: seen tomberek
03:09:03 <preflex>  tomberek was last seen on #haskell 1 day, 23 hours, 48 minutes and 33 seconds ago, saying: copumpkin.. what about coq?
03:09:10 <aristid> i found that sequence neatly generalises to Applicative
03:09:32 <aristid> @let sequenceA = foldr (liftA2 (:)) (pure [])
03:09:34 <lambdabot>  Defined.
03:09:49 <aristid> and by extension obviously replicateM too
03:09:56 <Gracenotes> this is a true fact
03:09:56 <quicksilver> aristid: see Data.Traversable
03:09:59 <Gracenotes> :o
03:10:04 <quicksilver> (they generalise beyond [], too)
03:10:12 <aristid> @let replicateA = (fmap.fmap) sequence replicate
03:10:14 <lambdabot>  Defined.
03:10:32 <aristid> quicksilver: why should i see Data.Traversable?
03:10:42 <quicksilver> aristid: because that is the library that contains sequenceA
03:11:20 <quicksilver> generalised not only from Monad to Applicative, but also generalised from [] to Traversable.
03:11:33 <aristid> quicksilver: woot
03:12:24 <aristid> :t (sequence .) . replicate
03:12:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:14:15 <aristid> quicksilver: and traverse is a generalised mapM
03:20:53 <aristid> :t (***)
03:20:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:21:02 <aristid> @src (***)
03:21:02 <lambdabot> f *** g = first f >>> second g
03:25:44 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25990#a25990 -- why would this cause the CPU to go to 100% and stack overflow?
03:25:51 <mreh> it's GLUT
03:26:15 <aristid> :t traverse pure
03:26:16 <lambdabot> Not in scope: `traverse'
03:26:43 <ClaudiusMaximus> mreh: no display callback?
03:26:51 <mreh> ClaudiusMaximus, oh
03:27:55 <zygoloid> mreh: are you reloading the png every time the main loop goes idle?
03:28:10 <mreh> zygoloid: haha, yes
03:28:11 <zygoloid> (no idea why it would stack overflow...)
03:29:41 <zygoloid> sounds like you want a haskell debugger. i should get back to writing one :)
03:37:19 <robertmassaioli> zygoloid: to interject; that sounds like an excellent plan :)
03:39:26 <zygoloid> so far all i have is a ptrace wrapper :-/
03:39:32 <PeakerLaptop> zygoloid, You were writing a Haskell debugger? Awesome.. How does it work?
03:40:12 <PeakerLaptop> I really wish I could get some traceback indicating which pieces of code are running, the evaluation stack, the lazy nesting stack, ...
03:41:38 <sioraiocht> dcoutts: ping?
03:42:08 <zygoloid> PeakerLaptop: it won't be able to show the lazy nesting stack (at least not at first, but i have some plans involving searching the heap to reconstruct it), but it'll show the evaluation stack
03:42:19 <sioraiocht> alternative, dcoutts_ =p
03:43:10 <zygoloid> i also want to be able to search the heap for a retainer path for a given object, to help identify space leaks
03:44:00 <PeakerLaptop> zygoloid, That would be awesome. It would be great to even be able to compile a super-slow version of the program that has these properties
03:44:59 <PeakerLaptop> zygoloid, working on GHC itself?
03:45:03 <Blkt> it is probably the third of fourth time I ask this here, but could anyone explain me what's wrong with "fromIntegral ((43.5*n+3*(n-(mod n 5)))/4)" in a function declared as having type "(Num a) => Actor -> Int -> a" (the actor being used in the guard)?
03:45:20 <PeakerLaptop> @type mod
03:45:21 <lambdabot> forall a. (Integral a) => a -> a -> a
03:45:31 <Twey> Ick
03:45:34 <Twey> Space, people, space
03:45:39 <PeakerLaptop> Blkt, You have to decide whether n is Integral or a Double/float
03:45:49 <PeakerLaptop> Blkt, Using "mod" on n means its Integral
03:45:55 <PeakerLaptop> Blkt, Multiplying it by 43.5 means it isn't
03:46:02 <Blkt> oh my god...
03:46:04 <zygoloid> PeakerLaptop: not at the moment. at some point i'd like to have optional debug information added to the info table for heap objects
03:46:31 <Blkt> PeakerLaptop: does a fromIntegral near the mod solves the problem?
03:46:34 <ketil> > fromIntegral (4/2) 
03:46:35 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:46:35 <lambdabot>    `GHC.Real.Fractional t'
03:46:35 <lambdabot> ...
03:46:42 <PeakerLaptop> Blkt, What do you want "n" to be?
03:46:57 <Blkt> n has to be Int
03:47:01 <PeakerLaptop> @type \n -> fromIntegral (n * 0.5)
03:47:02 <lambdabot> forall a b. (Fractional a, Integral a, Num b) => a -> b
03:47:08 <Twey> 43.5 * n + 3 * (fromIntgral n - fromIntegral (mod n 5))) / 4
03:47:13 <PeakerLaptop> I don't think any type can be both Fractional/Integral
03:47:28 <PeakerLaptop> Blkt, Then you have to use "43.5 * fromIntegral n"
03:47:34 <PeakerLaptop> Blkt, to convert the Int to the type of 43.5
03:47:52 <PeakerLaptop> Blkt, and you also have to use fromIntegral on the result of (n - n `mod` 5)
03:47:59 <Blkt> I'd rather change the declaration if it's enaugh and having Haskell do the dirty work
03:48:04 <Bigglotron> Hey, uh, is there a standard way to do matrices in Haskell?
03:48:31 <PeakerLaptop> @type \n -> (43.5 * fromIntegral n + 3 * fromIntegral (n - n `mod` 5)) / 4
03:48:32 <lambdabot> forall t a. (Fractional t, Integral a) => a -> t
03:48:55 <Blkt> PeakerLaptop: thanks for the help
03:49:02 <PeakerLaptop> Blkt, Haskell, unlike other languages, doesn't do implicit type coercions. You cannot use  Int * Double
03:49:34 <PeakerLaptop> You have to explicitly say whether you want to floor/truncate/ceil/round the Double, or whether you want to convert the Int to Double
03:49:52 <Blkt> I noticed that, a few other people tried to explain it to me, but I keep stumbling on that kind of errors
03:49:53 <PeakerLaptop> Using type-families, we can have type-coerced arithmetic, but I think explicit conversions are better
03:50:08 <Blkt> really?
03:50:14 <PeakerLaptop> Yeah:
03:50:22 <Blkt> you mean for performance resons or other?
03:50:30 <PeakerLaptop> For correctness reasons
03:50:40 <PeakerLaptop> Implicit conversions are error-prone/buggy
03:50:49 <Twey> And intrinsically arbitrary
03:51:18 <Blkt> so having something like (Fractional a, Integral a, Num b) => a -> b should be avoided?
03:51:24 <Twey> How do you convert a Float to an Int?  Round up?  Round down?  Banker's rounding?
03:51:45 <Twey> Blkt: Having something that is both a Fractional and an Integral should be avoided
03:52:01 <Twey> I'm pretty sure those classes are meant to be mutually exclusive
03:52:26 <Blkt> I see
03:52:39 <PeakerLaptop> Twey, I think the implicit conversions try to go from Int to Double and not the other way around
03:52:47 <Blkt> it sounded odd to me, but now I get why
03:53:02 <PeakerLaptop> Actually you end up with a Double that needs to be put with an Int it will typically choose some arbitrary conversion
03:54:06 <jpcooper> hello
03:54:44 <jpcooper> I've been thinking about different ways for the calculation of a card game tree along with its probabilities. It's taking huge amounts of memory. Could anyone give me some suggestions on how to store the tree on disk while the calculation is being done?
03:55:24 <jpcooper> and maybe some guides to optimisation which could be relevant?
03:58:05 <alip> is there a nicer way to do : maybeval <- iofunc ; let val = fromJust maybeval ?
03:58:22 <jpcooper> alip, yes
03:58:28 <sioraiocht> alip: (Just x) <- iofunc
03:58:30 <jpcooper> fmap
03:58:49 <jpcooper> sorry, that's bollocks. Listen to sioraiocht 
03:58:50 <sioraiocht> :t fromJust
03:58:51 <lambdabot> forall a. Maybe a -> a
03:59:10 <sioraiocht> jpcooper: I take it you are not fussed bout the "Nothing" case?
03:59:21 <jpcooper> yeah that would work and "val <- fmap fromJust iofunc" would work
03:59:34 <alip> thanks
03:59:54 <jpcooper> you might want to look into Control.Applicative as well
04:00:03 <sioraiocht> yeah, all depends on your application
04:00:11 <jpcooper> "val <- fromJust <$> iofunc" would be equivalent
04:04:52 <Twey> ‘Just val <- ioaction’ is nicer, though.
04:07:21 <jpcooper> it is
04:25:50 <freiksenet> what is the correct way to write forall a. Show a. Eq a?
04:26:07 <zygoloid> freiksenet: forall a. (Show a, Eq a) => ...
04:26:08 <freiksenet> so basically I want a to be of typeclass Show and Eq
04:26:14 <freiksenet> zygoloid: thanks
04:28:46 <freiksenet> would it be possible to derive type with such constructor as Show and Eq?
04:29:04 <freiksenet> for instance I have data Foo = forall a. Show a => Bar a
04:29:17 <freiksenet> it seems that I can't do deriving (Show)
04:29:53 <freiksenet> do i need to declare an instance of show for Foo or is there a way to autoderive it as with Haskell-98 types?
04:31:35 <Gracenotes> freiksenet: data Foo a b = Foo a b deriving (Show) will automatically derive an instance (Show a, Show b) => Foo a b where ...
04:32:35 <Gracenotes> requiring Bar's a to always be Show is a bit more complicated...
04:32:58 <Gracenotes> and it can usually be specified per-function
04:34:37 <freiksenet> hm, ok thanks
04:39:27 <mreh> eek, I feel like I'm programming in the 70s
04:40:08 <ketil> mreh: what, are you drawing flowcharts?  UML?
04:40:24 <mreh> ketil: using openGL
04:40:48 <medfly> unfortunately, this is 2010
04:41:46 <Jafet> Take comfort in the fact that most programmers today still do not know their way around compiling a directed acyclic word graph
04:42:19 <benmachine> freiksenet: why can't you do deriving Show?
04:43:03 <mreh> someone needs to marry a drawingcombinators and a window toolkit
04:43:13 <mreh> like wxFruit
04:43:18 <freiksenet> benmachine: cause I need to use GADT or existential type in one place
04:44:08 <benmachine> freiksenet: try standalone deriving
04:44:20 <freiksenet> benmachine: what do you mean?
04:44:49 <benmachine> freiksenet: give me a sec I'll get the GHC manual page for it
04:45:03 <freiksenet> thanks :)
04:45:14 <benmachine> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/deriving.html#stand-alone-deriving
04:45:29 <benmachine> "Unlike a deriving declaration attached to a data declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem."
04:45:49 <freiksenet> thanks )
04:53:28 <tester-007> Hello   it seems I've found a bug. Not quite sure though as I'm a beginner in Haskell.
04:53:56 <Botje> okay, can you put a test case online?
04:54:41 <tester-007> buildList genFnc baseLst baseLstLen n 
04:54:41 <tester-007>          | baseLstLen >= n = take n baseLst
04:54:41 <tester-007>          | otherwise       = buildList genFnc (baseLst ++ [genFnc baseLst baseLstLen]) (baseLstLen + 1) n
04:54:41 <tester-007> factorAux lst n = (last lst) * n
04:54:41 <tester-007> factor m = buildList factorAux [1] 1 m
04:54:54 <Zao> (pastesites rule)
04:55:11 <tester-007> Which pastesite, please?
04:55:13 <freiksenet> benmachine: so I tried to use those, but I still get an "ambigous type" error. Here is my code https://gist.github.com/2ab2c1de561e0497cfbf
04:55:32 <Zao> hpaste or any
04:55:50 <geheimdienst> http://hpaste.org
04:56:06 <tester-007> Okay, sorry, just a sec.
04:56:26 <benmachine> freiksenet: paste the error as well
04:56:44 <freiksenet> benmachine: updated with error
04:57:05 <freiksenet> I don't get where those a1 and b2 comes from :|
04:58:39 * hackagebot uri 0.1.5 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.5 (JaroslavGridin)
04:58:45 <quicksilver> well they're from the generated instance.
04:58:51 <quicksilver> but what you ask for can't possibly work
04:59:05 <quicksilver> the Eq instances would need to compare existentials of different types
04:59:10 <quicksilver> not possible without type info.
04:59:46 <tester-007> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25991#a25991
05:00:20 <freiksenet> ok, I see
05:00:41 <Gracenotes> freiksenet: oh, I misread your type... which made me think you were learning Haskell. heh.
05:00:46 <Botje> tester-007: your computation is getting forced to use Int instead of Integer
05:00:57 <freiksenet> Gracenotes: np :)
05:01:15 <Botje> tester-007: in the otherwise clause of buildList, replace n by fromIntegral n
05:01:29 <freiksenet> Gracenotes: I am learning it, though :]
05:01:33 <Botje> and maybe give an explicit type for factor
05:01:37 <Botje> (factor :: Int -> Integer)
05:01:53 <Gracenotes> so am I, when it comes to some of the typier extensions...
05:01:53 <tester-007> Botje: I get the same results if I use explicit type info with Integer
05:02:27 <Botje> tester-007: even if you add the fromIntegral  n ?
05:02:49 <tester-007> Botje: just trying that
05:03:29 <Botje> hmm, it still does that
05:04:02 <tester-007> Botje: yes, just got the same result with fromIntegral
05:04:26 <tester-007> The same stuff works fine for the Fibonacci series
05:04:34 <tester-007> even for very large numbers
05:04:35 <Botje> your n is being constrained by the take function
05:04:37 <Botje> :t take
05:04:37 <lambdabot> forall a. Int -> [a] -> [a]
05:05:22 <tester-007> it does work fine for the Fibonacci series
05:05:35 <tester-007> no multiplication in it though
05:05:38 <Botje> hmm, no, actually
05:05:42 <Botje> it's constrained by factorAux
05:05:47 <Botje> or is it
05:05:49 <Botje> bleh
05:06:17 <tester-007> Botje: I used a lambda function before I tried factorAux, same result
05:06:49 <Botje> myeah, hang on
05:06:53 <Botje> it's a bit warm here :_
05:08:50 <zygoloid> tester-007: genFnc is forced to type Num a => a -> a -> a, since it multiplies its arguments
05:09:21 <zygoloid> tester-007: inside buildList, baseLst's elements and baseLstLen are forced to the same type by the usage of genFnc
05:09:33 <zygoloid> (sorry, genFnc :: Num a => [a] -> a -> a)
05:10:03 <zygoloid> baseLstLen is forced to the same type as n by the >=. and n is forced to Int through the use of take.
05:10:09 <zygoloid> therefore the result is a list of Int.
05:10:26 <zygoloid> change take to genericTake (from Data.List) and you should get an Integer version.
05:11:14 <Botje> tester-007: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25991#a25992
05:11:29 <quicksilver> or just annotate all the signatures with Integer
05:11:39 <quicksilver> buildList :: ([Integer] -> Integer -> Integer) -> [Integer] -> Integer -> Integer -> [Integer]
05:11:42 <quicksilver> (and the rest)
05:11:43 <zygoloid> quicksilver: that'll give a type error
05:11:55 <zygoloid> but at least it'll identify 'take' as the culprit
05:12:06 <quicksilver> right, I fixed 'take' ages ago
05:12:12 <zygoloid> :)
05:12:38 <quicksilver> actually buildList is sufficient, the rest are forced by that
05:12:52 * zygoloid wonders whether the mark of a True Haskell Master is having one's own Prelude
05:14:15 <tester-007> quicksilver: it does work, thank you ... it's a subtle quirk for me
05:14:29 * geheimdienst thought the mark of a True Haskell Intermediate is having one's own monad tutorial
05:15:39 <mdmkolbe1> @seen dblhelix
05:15:39 <lambdabot> Unknown command, try @list
05:16:15 <mdmkolbe1> Huh?  http://code.haskell.org/lambdabot/COMMANDS says there is a @seen command
05:16:33 <geheimdienst> !seen dblhelix
05:16:34 <Botje> preflex: seen dblhelix
05:16:35 <preflex>  dblhelix was last seen on #haskell 26 days, 3 hours, 42 minutes and 45 seconds ago, saying: * dblhelix plans to look into test-framework today
05:16:42 <geheimdienst> ;)
05:17:24 <zygoloid> mdmkolbe1: it was disabled because it caused issues
05:17:40 <mdmkolbe1> ok, thanks
05:23:06 <tester-007> quicksilver: Would you be kind to explain me what's wrong with 'take'?
05:23:59 <tester-007> It's Int -> [a] -> [a], why does it constrain buildList to Int?
05:26:03 <nominolo> Int is fine because a list with maxInt elements cannot be represented in (addressable) memory
05:26:23 <zygoloid> tester-007: i explained above how that constraint is propagated to your result
05:26:35 <opqdonut> nominolo: with laziness, sure
05:26:43 <zygoloid> tester-007: it's the: "last lst * n" which moves the constraint from the indices to the list elements.
05:26:49 <opqdonut> especially since length doesn't hang on to the fron of the lsit
05:27:04 <opqdonut> of course, getting that length will take a while :)
05:27:13 <nominolo> sure, you could index into infinite lists, but that's not worth the performance cost in the common case (IMO)
05:27:58 <tester-007> zygoloid: if it's (last lst) * n, what has it got to do with take?
05:28:25 <zygoloid> tester-007: take is what forces n :: Int.
05:28:38 <zygoloid> last lst * n forces the resultant list to be the same type as n.
05:29:35 <tester-007> take's type info says Int -> [a] -> [a], Int stands for the number of elements you want to take, not the type of them
05:29:37 <mreh> pngload library reads in images the wrong way round
05:29:54 <mreh> that's annoying
05:30:22 <mreh> I'd index an image like any co-ordinate system
05:30:42 <zygoloid> tester-007: right. take forces n to be type Int. last lst * n forces last lst and n to be the same type. therefore last lst must be of type Int.
05:31:16 <tester-007> zygoloid: I've tried (last lst) * (fromIntegral n) with take ... it works fine
05:31:31 <zygoloid> yes, it would.
05:31:36 <tester-007> so I guess it has nothing to do with take
05:31:39 <zygoloid> wrong.
05:31:48 <zygoloid> if you changed take to genericTake it would work fine too.
05:32:18 <tester-007> ah ... you are right    getting confused
05:32:47 <quicksilver> nominolo: it's quite possible - if not particularly common - to stream a list with > 2^32 elements on a 32 bit machine
05:33:12 <quicksilver> nominolo: however, obviously you wouldn't call 'length' or 'take' on such a list
05:33:22 <quicksilver> you might conceivably call 'drop 'though.
05:33:31 <nominolo> quicksilver: right, but it's not hard to build a custom function for this  use case
05:34:01 <nominolo> quicksilver: or dropWhile or sth, yup
05:35:18 <mreh> ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e -- wut? a j e is the result!
05:35:43 <mreh> :t ixmap
05:35:44 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
05:36:38 <mreh> ooh
05:36:46 <dafis> mreh: No, (ixmap bds fun ar) ! i is ar ! (fun i)
05:37:31 <mreh> I just want to transpose the array, so fun = swap
05:39:30 <Botje> fun :)
05:55:55 <dcoutts_> sioraiocht: pong
05:56:15 <sioraiocht> dcoutts_: ! quesetion about chunk sizes
05:56:22 <dcoutts_> @arr!
05:56:22 <lambdabot> Swab the deck!
05:56:37 <sioraiocht> Have you ever had to justify your choice of chunk size
05:56:41 <sioraiocht> and if so, how?
05:57:24 <dcoutts_> sioraiocht: yes and by using benchmarks
05:57:53 <sioraiocht> dcoutts_: okay.  Ralf has a strong distaste for this method, but I think I have come up with a more pleasing way for him, at least
05:58:04 <dcoutts_> sioraiocht: however I think the post-ante rationale was bogus :-)
05:58:14 <dcoutts_> sioraiocht: heh heh
05:58:15 <sioraiocht> The locality/page size stuff?
05:58:23 <sioraiocht> Seems a little too specific
05:58:30 <sioraiocht> I see bos uses MASSIVE chunk sizes
05:58:40 <sioraiocht> I was thinking something on the order of 1k
05:59:19 <dcoutts_> sioraiocht: ByteString uses 4k and 32k iirc, the latter for reading from files
05:59:43 <sioraiocht> dcoutts_: yeah, the big problem is that you lose rope benefit with such huge chunks
05:59:49 <dcoutts_> sioraiocht: it makes sense to have a large IO size and a smaller general size
05:59:50 <sioraiocht> well, 4k might be reasonable
05:59:57 <sioraiocht> dcoutts_: yes, I agree with that
06:00:01 <sioraiocht> okay
06:00:26 <dcoutts_> sioraiocht: what kind of justification does Ralf want?
06:00:46 <dcoutts_> surely it has to be an empirical one
06:00:58 <sioraiocht> Well, he is displeased that in trees, using a chunked approached only decreases the memory overhead of pointers by a constant factor
06:01:12 <sioraiocht> he wants justification that the factor is a reasonable reduction
06:01:23 <sioraiocht> but, to me, no matter how you calculate it, you have to justify it with benchmarks
06:01:25 <dcoutts_> oh but that's not the main reason
06:01:28 <dcoutts_> it's the speed
06:01:30 <sioraiocht> right
06:01:31 <dcoutts_> not the size
06:01:37 <dcoutts_> though smaller is faster
06:01:47 <sioraiocht> but also it's pointer chasing, right
06:01:50 <mreh> @arr!
06:01:50 <lambdabot> Keelhaul the swabs!
06:02:01 <dcoutts_> sioraiocht: yes
06:02:22 <dcoutts_> sioraiocht: it's the 300 cycle main memory costs
06:02:25 <mreh> @vixen Keelhaul the swabs!
06:02:25 <lambdabot> Any way you want it, baby!
06:03:29 <dcoutts_> sioraiocht: so it's both memory latency (links/pointers to data not in the cache) and bandwidth (data density)
06:04:04 <dcoutts_> and a little bit of per-chunk overheads in terms of cycles
06:04:30 <sioraiocht> you maintain a fair few pointers with finger trees, but you chase relatively few
06:04:32 <sioraiocht> oh okay
06:04:32 <sioraiocht> cool
06:04:33 <mreh> Keelhaul the men who keelhauled the swabs!
06:04:45 <sioraiocht> Thank you, you have given me Ralf defense material
06:04:49 <sioraiocht> :)
06:04:51 <dcoutts_> sioraiocht: make Ralf read "What Every Programmer Should Know About Memory"
06:04:55 <sioraiocht> heheh
06:04:59 <dcoutts_> http://people.redhat.com/drepper/cpumemory.pdf
06:05:11 <sioraiocht> cheers
06:05:24 <sioraiocht> *adds to thesis citations*
06:05:44 <dcoutts_> sioraiocht: it's a good read and there's a useful point there, which is that while data density and flat arrays are good, linked structures are still ok
06:06:12 <dcoutts_> if either the links are few and far between, or if the links point to data that's also in the data cache
06:06:12 <sioraiocht> EXCELLENT
06:06:25 <sioraiocht> cheers!
06:06:42 <dcoutts_> so a linked list that's set out in memory linearly is not actually that bad in terms of latency
06:06:50 <sioraiocht> right
06:06:54 <dcoutts_> though it's not ideal in terms of data density (bandwidth)
06:11:41 <dcoutts_> sioraiocht: what constant factor performance improvement is enough justification for Ralf do you think?
06:11:54 <sioraiocht> not sure
06:12:15 <sioraiocht> I think if I can reason anything
06:12:17 <sioraiocht> he would be happy
06:12:22 <dcoutts_> I see
06:12:22 <sioraiocht> you've given me lots of justification ;)
06:12:27 <dcoutts_> good good
06:12:54 <sioraiocht> He's more concerned with the paper being convincing than being convinced himself
06:13:34 <dcoutts_> heh heh
06:18:52 <tibbe> dcoutts_: could you weigh in on Thomas question about the test interface type and the modulePath type?
06:19:02 <tibbe> dcoutts_: I don't see a great solution in sight
06:21:37 <alip> i have a value and a count and i want to create a list of length count with all values of the list equal to value.. something like [value] * count in Python
06:22:34 <dafis> alip: replicate
06:22:51 <dafis> :t replicate
06:22:52 <lambdabot> forall a. Int -> a -> [a]
06:23:01 <Zao> @src replicate
06:23:02 <lambdabot> replicate n x = take n (repeat x)
06:23:11 <alip> dafis: thanks! don't know how i missed that :)
06:23:13 <Twey> replicate 5 "value"
06:23:15 <Twey> > replicate 5 "value"
06:23:16 <lambdabot>   ["value","value","value","value","value"]
06:23:19 <Zao> @src cycle
06:23:20 <lambdabot> cycle [] = undefined
06:23:20 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:23:28 <Twey> > cycle []
06:23:29 <lambdabot>   *Exception: Prelude.cycle: empty list
06:23:41 <Twey>  @src lies about errors ☺
06:23:44 <djahandarie> Yeah
06:25:37 <tafryn> Zao: So something like take count $ cycle value would work for dafis?
06:26:18 <Zao> tafryn: cycle [value], but that uses ++ and is thus evil.
06:26:30 <Zao> I'd just use replicate or take repeat.
06:26:46 <tafryn> Zao: Why is ++ evil?
06:27:02 <ivanm> Zao: actually, in GHC cycle is cheap
06:27:11 <ivanm> since it uses a circular list reference (or something)
06:27:19 <dafis> Zao: But cycle uses (++) right associatively, thus it's not really evil
06:27:23 <ivanm> tafryn: in general, doing long_list ++ [value] is expensive
06:27:34 <ivanm> dafis: it doesn't use ++ at all in GHC!
06:27:41 <Zao> Of course, anything that is said to be "evil" is not unconditionally such.
06:27:48 <Zao> Any such statement should come with a list of guidelines.
06:27:54 <Zao> As provided by my peers above :D
06:27:57 <ivanm> @google vacuum cycle
06:27:58 <lambdabot> No Result Found.
06:28:01 <ivanm> grrr...
06:28:14 <ivanm> pretty sure there was a vacuum visualisation of cycle that demonstrates this...
06:28:27 <zygoloid> the definition of cycle above is fine.
06:28:32 <ivanm> then again, it could have been on moonpatio which is down :(
06:28:36 <zygoloid> (it creates a cyclic list)
06:28:39 <ivanm> zygoloid: but inefficient
06:28:43 <zygoloid> ivanm: nope.
06:28:46 <Nola> why does haskell put everything at global/module scope
06:28:46 <Nola> <Nola> oh
06:28:52 <Zao> (++) emits the same emotional response in me as (!)
06:28:52 <dafis> ivanm: Yes, but not everything is GHC, I talked about the source lambdabot gave. Prseumably som implementation uses that.
06:28:53 <Nola> ?
06:29:17 <zygoloid> ivanm: given a length n list, it constructs n cons cells.
06:29:21 <ivanm> dafis: sure, but in practice Haskell == GHC 99% of the time ;-)
06:29:35 <ivanm> zygoloid: memory-wise, I'm pretty sure GHC's variant is better
06:29:46 <dafis> Zao: what's wrong with (!)? Did you mean (!!)?
06:29:58 <Zao> dafis: Whatever the list indexing one is.
06:30:07 <Zao> dafis: I use it so rarely, I forget the spelling.
06:30:13 <dmwit> The standard says nothing about memory. The compiler is perfectly within its rights doing something efficient or something inefficient with either implementation.
06:30:14 <dafis> ivanm: Very true. I haven't used anything else in a long time :)
06:30:28 <dmwit> So if you're trying to make statements that include non-GHC compilers, you're hosed.
06:30:59 <dafis> Zao: That's good. But you might remeber array (or Map) indexing :)
06:31:27 <ivanm> humph, looks like the actual definition ghc uses is the one above
06:31:30 <dafis> remember :(
06:31:36 <ivanm> must be some later optimisation that does the referencing stuff
06:31:46 <ivanm> dafis: actually, M.! is also evil
06:31:59 <zygoloid> ivanm: what referencing stuff? the definition above already builds a cyclic data structure
06:32:06 <zygoloid> note that xs' is defined in terms of itself.
06:32:40 <ivanm> zygoloid: can't remember the details, but IIRC in hugs or whatever it's actually copied; in GHC it gets transformed into the end of the list pointing to the beginning of the list
06:32:50 <dafis> ivanm: Only if you don't know for sure that it's in the Map.
06:33:02 <ivanm> dafis: right
06:33:14 <Nola> haskell has really archaic namespacing thats pretty far behind all other languages
06:33:28 <ivanm> dafis: but I've had cases where I went "I know it's in there so I'll just use !", then do some later refactoring elsewhere and waddaya know, I get a case where it isn't in the Map
06:33:35 <Nola> well, all the major ones
06:33:38 <ivanm> Nola: "all"?
06:33:48 <ivanm> Nola: first of all, prove it's worse
06:33:56 <Nola> ivanm: Yeah, pick anything... Javascript has superior namespacing
06:34:00 <ivanm> Nola: secondly, people can't agree on a better one ;-)
06:34:06 * ivanm _hates_ Java's namespacing
06:34:13 <Nola> It's better by a very simple criteria
06:34:19 <dafis> ivanm: Yes, like with 'head', you've got to be very careful when using Data.Map.!
06:34:19 <ivanm> really, per-package module namespacing? that's a right royal PITA
06:34:20 <zygoloid> ivanm: it has to be copied, unless GHC can prove that nothing else has a reference to it
06:34:26 <ivanm> dafis: exactly
06:34:31 <k23z__> so are you guys working with the category of categories yet ?
06:34:40 <Nola> javascript namespacing always works regardleess of what you want to do
06:34:40 <ivanm> zygoloid: huh? why does it have to be copied?
06:34:44 <ivanm> k23z__: I have no reason to
06:34:45 <Nola> you dont "pick and choose" how to write the chode
06:34:47 <ski> k23z__ : ?
06:34:51 <k23z__> just kidding
06:35:01 <dafis> zygoloid: huh?
06:35:04 <zygoloid> ivanm: because otherwise someone with a reference to the original list would see it change!
06:35:09 <ivanm> Nola: I have never used javascript (well, OK, a few hacks in a uni project) so I don't know how its namespacing works
06:35:17 <Nola> ie in Haskell, you pick and choose not to name-something a certain way, not to include a certain set of things in a certain file, etc
06:35:24 <ivanm> zygoloid: OK, the _cyclic_ version of that list
06:35:30 <ivanm> I don't know how it's actually implemented
06:35:36 <ivanm> I'm trying to remember a past discussion here ;-)
06:36:13 <Nola> ivanm: the JS namespacing is just that an object can have another object
06:36:27 <ivanm> wtf?
06:36:44 <Nola> wtf what specifically?
06:36:44 <dafis> ivanm: Just what I wanted to say!
06:37:00 <dafis> Nola: wtf are you talking about?
06:37:17 <ivanm> Nola: what does "an object can have another object" even _mean_?
06:37:30 <ivanm> dafis: about how javascripts namespacing is better than Haskell's
06:37:37 <Nola> I am making the point that even JS super-simplistic "totally lacks namespaces" is even more capable than haskells module system :)
06:38:03 <soupdragon> Nola, yeah it's pretty bizarre they fucked up modules so badly
06:38:04 <ivanm> Nola: you can't state that foo's namespaces are better than Haskell's if it won't work in Haskell
06:38:08 <quicksilver> or, rather, you're not making that point
06:38:10 <EvanR-work> js namespacing is the same as haskell but without a module system
06:38:11 <soupdragon> Nola, especially being am ML derivative
06:38:14 <quicksilver> because you're not explaining why you think it's better
06:38:16 <dafis> ivanm: Yes, I know that, but what does 'an object can have another object' mean and how does it relate to namespacing?
06:38:26 <ivanm> dafis: exactly what I want to know!
06:38:45 <Nola> EvanR: what do you mean
06:38:51 * ivanm should hit the sack
06:39:03 <Jafet> I see Nola has found a new place full of people to annoy.
06:39:16 <ivanm> Nola: don't bitch about how bad Haskell's namespace is unless you can come up with a viable alternative
06:39:25 <soupdragon> uh
06:39:30 <soupdragon> anyone can come up with an alternative
06:39:40 <soupdragon> decent module systems have been around forever
06:39:44 <ivanm> oh really? I can't
06:39:56 <EvanR-work> i dont see what people have against haskells module namespace
06:39:57 * hpc actually likes Haskell's module system
06:40:00 <ivanm> but are they _viable_
06:40:07 <mreh> how do I make a Bitmap into an Array
06:40:17 <ivanm> EvanR-work: main objection I know of is mtl vs transformers
06:40:24 <ivanm> mreh: depends on how you've defined Bitmap
06:40:27 <EvanR-work> ._.
06:40:37 <mreh> Data.Bitmap
06:40:44 <ivanm> EvanR-work: in that they export/expose the same modules
06:40:46 <kamatsu> the only gripe i have with haskell's module system is that often writing lhs you end up with circular imports if you want to put your code in a meaningful place within the latex documents.
06:40:47 <ivanm> mreh: which library?
06:41:03 <ivanm> kamatsu: I'll pay that
06:41:06 <kamatsu> this could be resolved with better lhs tools though
06:41:08 <EvanR-work> ivanm: people can mess up their namespace regardless of the framework
06:41:13 <mreh> ivanm, bitmap
06:41:15 <ivanm> EvanR-work: true
06:41:41 <EvanR-work> question is have you run in any problem when designing your own
06:41:56 <ivanm> EvanR-work: this situation doesn't occur in Java for example because of package-specific "module" names, but that's the sole saving grace of Java's package system IMHO
06:41:56 <EvanR-work> modules
06:42:17 <ivanm> EvanR-work: I've been bitten by mtl vs transformers, and resolving circular deps can be a pain
06:42:21 <EvanR-work> packages just sounds like a second level module system
06:42:38 <ivanm> but the former is work-aroundable, and the latter would be true in any module system AFAIK
06:42:58 <kamatsu> ivanm: java supports circular deps?
06:43:06 <ivanm> mreh: AFAIK there's no easy way
06:43:16 <ivanm> kamatsu: I highly doubt it
06:43:41 <ivanm> kamatsu: with java I was referring to module name clashes not occurring due to the url prefixes used in their class names
06:43:55 <quicksilver> ivanm, kamatsu : yes, java supports circular dependencies
06:43:59 <ivanm> which makes them more verbose and IMHO libraries not really looking like they interact
06:44:01 <ivanm> quicksilver: :o
06:44:02 <quicksilver> although not all tools have always coped well with them.
06:44:16 <kamatsu> ivanm: circular deps are definitely allowed in Java.
06:44:47 <Twey> @karma java
06:44:47 <lambdabot> java has a karma of -8
06:44:52 <ToRA> quicksilver: java can statically, dynamically you can't have a class initialiser circularly depend on itself (which might be a slightly orthogonal issue to the discussion)
06:44:55 <Twey> I quite like the URL prefixes.
06:45:05 <Twey> Qualified imports might be nice.
06:45:08 <ivanm> kamatsu: why did you ask me if you already knew? :p
06:45:17 <quicksilver> as a namespacing system, the thing that annoys me most about haskell/import is that you can't re-export a qualified module with qualification.
06:45:28 <ivanm> Twey: you mean as in explicitly importing a specific package?
06:45:32 <quicksilver> as a 'module system' - well it simply isn't one
06:45:34 <kamatsu> ivanm: my question mark wasn't intended to make it a question
06:45:35 <ivanm> quicksilver: hmmm...
06:45:39 <ivanm> kamatsu: ahhh
06:45:40 <kamatsu> ivanm: sorry for the confusion
06:45:45 <ivanm> heh
06:45:55 <Twey> ivanm: E.G. importing javax.swing as swing
06:45:56 <mreh> pngload loads my images squished :(
06:46:09 <ivanm> Twey: hmmm...
06:46:20 <kmc> ivanm, graphviz rocks :D
06:46:25 <ivanm> kmc: thanks! :D
06:46:31 <kamatsu> @karma haskell
06:46:31 <lambdabot> haskell has a karma of 59
06:46:33 <Nola> the Haskell namespacing problems were designed to be that way on purpose
06:46:44 <Nola> also record syntex was purposefully designed to be bad
06:46:45 <Twey> Nola: They were designed to be problematic?  ;)
06:46:48 <Twey> Haha
06:46:49 <Nola> yes
06:46:54 <Twey> To avoid success, I guess?  :þ
06:46:55 <ivanm> Twey: if you have url prefixes, then it means that "extension" libraries (e.g. vector-algorithms extends vector) don't end up integrating nicely
06:46:55 <kamatsu> Why would you design something to be problematic?
06:46:58 <Nola> nope
06:47:06 <ivanm> Twey: and they of course assume you have your own URL to use as a prefix
06:47:07 <Nola> The reason is because functional programmers are still trying to find 'f'
06:47:07 <djahandarie> @karma category theory
06:47:07 <lambdabot> category has a karma of 0
06:47:11 <djahandarie> lol
06:47:13 <djahandarie> @karma "category theory"
06:47:13 <lambdabot> "category has a karma of 0
06:47:15 <Nola> They want the one single f function which is correct.
06:47:18 <djahandarie> Damn :P
06:47:22 <kmc> Haha
06:47:24 <Twey> Nola: Haha
06:47:24 <EvanR-work> Nola: arent you the one from a few months ago who was keen on learning haskell and ran away when he heard about record access namespacing
06:47:28 <ivanm> Nola: record syntax was designed as a _compromise_ because the definers couldn't agree on how to do it
06:47:34 <Nola> So if you allow "better records" it will stop people from using "universally perfect names"
06:47:36 <ivanm> it wasn't designed to be actually _bad_
06:47:38 <kmc> this is funny trolling
06:47:47 <kamatsu> kmc: i too am amused
06:47:57 <Twey> kmc: I think it's humour :þ
06:48:02 <kamatsu> @karma categorytheory
06:48:02 <lambdabot> categorytheory has a karma of 0
06:48:09 <kamatsu> @karma categoryTheory
06:48:09 <lambdabot> categoryTheory has a karma of 0
06:48:11 <kamatsu> aww
06:48:12 <kmc> :þ
06:48:15 <kamatsu> how do I give something karma?
06:48:20 <kmc> haskell++
06:48:21 <Twey> categoryTheory++
06:48:27 <kmc> @karma c
06:48:28 <kamatsu> categoryTheory++
06:48:28 <lambdabot> c has a karma of 1
06:48:30 <Twey> ivanm: Well, most anybody who's anybody does
06:48:31 <kmc> @karma C
06:48:31 <lambdabot> C has a karma of 1
06:48:36 <Twey> ivanm: You can get free URLs, too
06:48:37 <ivanm> mreh: maybe check using roel's inverse dep hackage mirror to see if there are any libraries that wrap around bitmap, but I doubt it
06:48:41 <wlangstr1th> categoryTheory++
06:48:43 <EvanR-work> C++
06:48:46 <kamatsu> kmc: what about all the people that mention "C++" ?
06:48:53 <Twey> @karma C
06:48:53 <lambdabot> C has a karma of 1
06:48:53 <kamatsu> surely it's been mentioned more than once.
06:48:58 <EvanR-work> (C)++
06:48:59 <Nola> Ie, due to the broken record system, you have to do a much better job at perfect abstraction of all your data getters, so that  "things of this type has an age", etc is universal in the typeclass system
06:49:01 <ivanm> Twey: I don't have a website
06:49:09 <geheimdienst> @karma c++
06:49:09 <lambdabot> c++ has a karma of -3
06:49:09 <Twey> Probably not on a line of its own
06:49:10 <Nola> thats on purpose
06:49:12 <ivanm> Twey: I did register miljenovic.yi.org a while back but have never used it
06:49:14 <Nola> same for the modules
06:49:16 <geheimdienst> @karma c++
06:49:16 <lambdabot> c++ has a karma of -3
06:49:22 <Twey> ivanm: Well, you can use that
06:49:24 <kamatsu> c++--
06:49:25 <mreh> don't forget all the mention of c--
06:49:26 <geheimdienst> c++
06:49:26 <ivanm> Nola: where are you pulling this load of BS from?
06:49:29 <geheimdienst> @karma c++
06:49:29 <lambdabot> c++ has a karma of -4
06:49:37 <mreh> lulz
06:49:37 <Twey> ivanm: You don't need an actual website, just a domain
06:49:38 <geheimdienst> c++
06:49:40 <geheimdienst> @karma c++
06:49:40 <lambdabot> c++ has a karma of -4
06:49:44 <ivanm> Twey: so, if I suddenly get my own proper website, then everyone using my code has to change their imports to match?
06:49:48 <mreh> hah
06:49:55 <kamatsu> c++++
06:49:59 <Twey> ivanm: No, you can carry on using that domain
06:50:01 <kamatsu> @karma c++
06:50:01 <lambdabot> c++ has a karma of -3
06:50:01 <ivanm> @karma lambdabot
06:50:01 <lambdabot> lambdabot has a karma of -3
06:50:05 <kamatsu> aww
06:50:06 <kamatsu> lambdabot++
06:50:08 <ivanm> kamatsu: use @karma+
06:50:11 <wlangstr1th> c++--
06:50:15 <geheimdienst> @karma+ c++
06:50:15 <lambdabot> c++'s karma raised to -3.
06:50:15 <Twey> It's just to ensure uniqueness (by passing the responsibility onto DNS registries)
06:50:18 <ivanm> and @karma-
06:50:27 <geheimdienst> @karma- c++
06:50:27 <lambdabot> c++'s karma lowered to -4.
06:50:27 <kamatsu> ahh
06:50:32 <mreh> @karma c
06:50:32 <lambdabot> c has a karma of 1
06:50:40 <EvanR-work> @karma+ c
06:50:40 <lambdabot> c's karma raised to 2.
06:50:41 <ivanm> Twey: which means you get some really weird and wonderful prefixes then, which down the track might not really match what is happening
06:50:43 <wlangstr1th> @karma categoryTheory
06:50:43 <lambdabot> categoryTheory has a karma of 3
06:50:50 <mreh> c--
06:50:50 <djahandarie> Maybe a lot of people mention c-- here also
06:50:54 <mreh> @karma c
06:50:54 <lambdabot> c has a karma of 2
06:51:08 <kamatsu> so the balance between c++ and c-- reflect in C's karma?
06:51:16 <mreh> it doesn't work like that :)
06:51:19 <Twey> ivanm: It's just for uniqueness purposes… it doesn't matter what's ‘really happening’
06:51:21 <ivanm> Twey: also, unless you have some over-reaching organisation or you start a unique URL specifically for that project, it means that it's harder to pass maintainership of a project on to someone else
06:51:28 <djahandarie> @karma ghc
06:51:28 <lambdabot> ghc has a karma of 0
06:51:29 <Twey> ivanm: I'm not sure I understood your point about ‘extension libraries’
06:51:30 <ivanm> (which is why Id on't like usint patch-tag or something similar)
06:51:50 <Twey> ivanm: THat's true
06:52:01 <ivanm> Twey: atm, vector-algorithms lives within the Data.Vector.Algorithms "sub-namespace" of Data.Vector
06:52:08 <fryguybob> it will take more than c-- to balance the universe against the evil of c++.
06:52:18 <ivanm> making it obvious that it's a sub-part of the Data.Vector "ecosystem"
06:52:31 <geheimdienst> ghc has karma 0? i guess that means she is chaotic neutral
06:53:06 * ivanm sends himself off to bed before he ends up under-sleeping again
06:53:15 <EvanR-work> c++ lawful evil, php chaotic evil
06:53:26 <ivanm> I'm going to the L4 talk (which will hopefully have Haskell in it) tomorrow, so I want to make sure I'm awake for that ;-)
06:53:30 <djahandarie> @karma php
06:53:30 <lambdabot> php has a karma of 2
06:53:30 <ivanm> g'night all!
06:53:33 <djahandarie> haha what
06:53:37 <EvanR-work> php--
06:53:37 <Twey> ivanm: And com.example.Vector vs. com.example.Vector.Algorithms doesn't do that?
06:53:42 <kmc> @karma weed
06:53:42 <lambdabot> weed has a karma of 333
06:53:43 <geheimdienst> g'night ivanm
06:53:46 <ivanm> djahandarie: probably from some non-haskell channel
06:53:49 <EvanR-work> @karma php--
06:53:49 <lambdabot> php-- has a karma of 0
06:53:57 <ivanm> Twey: but vector-algorithms is by someone else
06:53:57 <Twey> php--
06:54:03 <djahandarie> @karma lambdabot
06:54:03 <lambdabot> lambdabot has a karma of -2
06:54:07 <djahandarie> lol...
06:54:09 <ivanm> @karma+ lambdabot 
06:54:09 <lambdabot> lambdabot's karma raised to -1.
06:54:14 <Twey> ivanm: So com.someone.else.Vector.Algorithms
06:54:16 <kmc> http://therighttool.hammerprinciple.com/items/php
06:54:28 <ivanm> Twey: and thus the matching-up isn't as obvious
06:54:43 <Twey> « The thought that I may still be using this language in twenty years time fills me with dread » — hahaha
06:54:44 <djahandarie> LOL at number 1 on that list kmc
06:54:51 <tab> @karma+ everyone
06:54:51 <lambdabot> everyone's karma raised to 5.
06:54:54 <kmc> yeah djahandarie 
06:54:59 <Twey> ivanm: I don't see why… the package part of the namespace still matches
06:55:01 <kmc> don't admit to knowing anything you don't want to do
06:55:11 <jkingkong> Hmm, I'm getting a stack space overflow even with a strict foldl'
06:55:21 <kmc> http://en.wikiquote.org/wiki/Rasmus_Lerdorf
06:55:28 <ivanm> Twey: another consideration: URL-based modules are more verbose :p
06:55:46 <ivanm> jkingkong: at a guess, you have a long list and you're keeping that list around rather than doing a single pass through it
06:55:49 <EvanR-work> java is all about verbosity
06:55:52 <ivanm> that's it, I'm off
06:55:55 <Twey> ivanm: We're talking about *Java* here
06:55:59 <Twey> Haha, 'night
06:56:19 <arw_> url-based modules are useless, because automatic downloading of dependencies is out of the question anyways.
06:56:26 <soupdragon> http://www.e-pig.org/darcs/Pig09/test/Syntax.pig
06:56:27 <soupdragon> great
06:56:35 <soupdragon> now I know how to talk to the pig
06:56:43 <jkingkong> ivanm: Ok I'll look into it, do you have a small example of this by any chance?
06:57:53 <jkingkong> ivanm: oddly enough, I get the stack overflow even on a list with one element.
06:58:20 <benmachine> jkingkong: infinite loop, perhaps?
06:58:36 <benmachine> perhaps you mean to recurse on the tail of the list and are recursing on the whole list instead
06:58:40 <benmachine> or something
06:58:58 <EvanR-work> verify all the sub functions
06:59:14 <jkingkong> hmm probably an infinite loop
06:59:20 <jkingkong> one of these sub functions is culprit
06:59:27 <jkingkong> i've just never seen this before, haha
06:59:43 <jkingkong> i was pretty careful about tail recursion
06:59:48 * geheimdienst doesn't know what all the package fuss is about, but it would be cool if you could give cabal pkg names in import statements: import xmonad-contrib/XMonad.Layout.Something
06:59:52 <jkingkong> but it still shouldn't overflow on one element
07:00:07 <EvanR-work> > let x = x in x
07:00:08 <dafis> jkingkong: code?
07:00:11 <lambdabot>   mueval-core: Time limit exceeded
07:00:28 <alar> is there a possibility of making "instance A x=> B x" and not getting overlap with existing instances of  B? instances of A are defined for Word8,Word16,etc.
07:00:39 <EvanR-work> > let x = 1:x in x
07:00:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:00:45 <Taejo> > takeWhile (not . null) . iterate (drop . drop) $ "abcdef"
07:00:46 <lambdabot>   Couldn't match expected type `[a]'
07:00:46 <dafis> geheimdienst: {-# LANGUAGE PackageImports #-}?
07:00:46 <lambdabot>         against inferred type `[a1] -> [...
07:00:59 <Taejo> > takeWhile (not . null) . iterate (tail . tail) $ "abcdef"
07:00:59 <lambdabot>   ["abcdef","cdef","ef"]
07:01:10 <djahandarie> Lol, for a second I think lambdabot evaluated that to a GHC pragma
07:01:10 <Taejo> > map head . takeWhile (not . null) . iterate (tail . tail) $ "abcdef"
07:01:10 <lambdabot>   "ace"
07:01:13 <djahandarie> thought*
07:01:22 <geheimdienst> dafis, i can't believe it. thanks!
07:01:24 <dcoutts_> dafis: that's not intended for general consumption
07:01:36 <dcoutts_> geheimdienst: not recommended
07:01:48 <geheimdienst> how so?
07:02:16 <benmachine> alar: not really, there's the OverlappingInstances extension but it results in ew
07:02:21 <dcoutts_> geheimdienst: that extension is not intended to encourage people to go doing package-qualified imports
07:02:39 <dcoutts_> geheimdienst: it's there for special ghc-only hacks like base 3 depending on base 4
07:02:44 <benmachine> @quote quicksilver.*overlapping
07:02:45 <lambdabot> No quotes match. Just try something else.
07:02:51 <benmachine> @quote quicksilver overlapping
07:02:51 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
07:02:51 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
07:02:59 <dcoutts_> geheimdienst: the package .cabal file is where you specify the package deps
07:03:33 <soupdragon> '“But that’s just GADTs!” say the Haskell cool kids' -- finaly... someone who understands how cool I am
07:03:41 <benmachine> alar: you can make a newtype though, say newtype This x = This { unThis :: x }; instance (A x) => B (This x)
07:03:50 <kmc> haha soupdragon
07:03:51 <kmc> from where?
07:04:03 <soupdragon> http://research.microsoft.com/en-us/um/people/akenn/coq/semlunch.pdf
07:04:26 <kmc> base 3 depends on base 4?
07:04:28 <kmc> what a country
07:04:36 <geheimdienst> hm, okay. i guess if you want to use a "drop-in replacement" pkg for something, it would be annoying if you had to edit each single import statement. once in the cabal file is easier
07:06:00 <benmachine> kmc: well, the newer base 3s are just compatibility packages really, aren't they
07:06:05 <benmachine> so it kind of makes sense
07:07:07 <geheimdienst> kmc, it's reasonable to have a new version of something which can also emulate the behavior of the old one
07:07:43 <dayz> hi
07:07:48 <djahandarie> Morning
07:07:59 <noteed> dcoutts_: for #503 patch, as it appears, multiple long options are all reported in the --help output
07:08:20 <dayz> is this theorem true? "EX a b. f(a) < f(b) --> f(a) > f(b)" given f : real => real?
07:08:21 <dcoutts_> noteed: oh, lets fix that
07:08:34 <noteed> dcoutts_: but on the other hand, unambiguous prefix of an option is recognized
07:08:39 <dayz> somehow my theorem prover proves it to be true, but I can't quite see how.
07:09:00 <dayz> what could a and b be instantiated by?
07:09:15 <noteed> dcoutts_: so if we only list the plural, the singular (since it is just an 's' removed) is recognized too
07:09:24 <soupdragon> dayz, what's f?
07:09:33 <benmachine> dayz: perhaps there are no a and b for which f(a) < f(b), or something?
07:09:36 <dayz> soupdragon, just a function variable
07:09:45 <soupdragon> dayz, let a = b
07:10:03 <benmachine> or, yeah, that
07:10:05 <dayz> soupdragon, if a = b, the premise won't hold, right?
07:10:10 <soupdragon> dayz, yes, exactly
07:10:19 <benmachine> and neither does the conclusion
07:10:20 <dcoutts_> noteed: see Distribution/GetOpt.hs usageInfo function, where it calls fmtShort and fmtLong
07:10:58 <kmc> yeah, this is what i mean by rebranding: http://racket-lang.org/
07:11:01 <kmc> used to be PLT Scheme
07:11:07 <kmc> "Scheme? lame! only weirdos use that"
07:11:13 <kmc> now it's a hip new dynamic language
07:11:14 <Botje> from planet to racket, makes sense :)
07:11:25 <kmc> suitable for hitting on ruby chicks down at the local starbucks
07:12:00 <soupdragon> nice to see R6RS being adopted *snerk*
07:12:10 <zachk> kmc where the heck are you that you have ruby chicks at a local starbucks? 
07:12:13 <noteed> dcoutts_: ok, I'll limit the printing to only one option
07:12:13 <dayz> soupdragon, but then does that mean the conclusion could be arbitrary since a can be b. i.e. the theorem EX a b. f(a) < f(b) --> f(a) > f(b) + 1, etc.?
07:12:19 <geheimdienst> what kind of local starbucks has a significant number of ruby chicks, pray tell?
07:12:21 <Botje> keep up, soupdragon, it's now R6RR :)
07:12:56 <alar> benmachine: then I have to 1. make newtypes for my integrals, 2. propagate all existing instances to those newtypes: Read,Show, Binary,etc., 3. write my own instances for newtypes
07:13:20 <fryguybob_> kmc: under "people" they have a link to http://untyped.com/.  That's like the opposite of http://www.well-typed.com/.
07:13:24 <kmc> haha
07:13:35 <dcoutts_> Botje: does it count down? RS, RR, RQ, ... AA ?
07:13:58 <fryguybob_> @karma- untyped
07:13:58 <lambdabot> untyped's karma lowered to -1.
07:13:59 <benmachine> alar: GeneralizedNewtypeDeriving makes some of that easier
07:14:12 <benmachine> alar: you only need one newtype, though
07:14:23 <mreh> can I gain any performance from an unsafeFreeze of a Storable array?
07:14:40 <dcoutts_> fryguybob_: when we started up the untyped.com people asked if our name was in any way a reaction to theirs, we had to admit we honestly didn't know they existed :-)
07:14:43 <alar> benmachine: one newtype for each of integer types
07:14:48 <benmachine> alar: nope
07:14:58 <fryguybob_> dcoutts_: lol
07:15:03 <benmachine> the newtype is parametrised
07:15:13 <kmc> Racket has a statically-typed variant too
07:15:14 <quicksilver> dayz: correct.
07:15:17 <benmachine> MyNewType Word8
07:15:20 <benmachine> MyNewType Word16
07:15:28 <benmachine> they all share the same instances
07:15:30 <alar> hm
07:15:30 <quicksilver> dayz: EX a b. f(a) < f(b) ---> False 
07:15:33 <quicksilver> dayz: also holds.
07:16:24 <alar> then I'll probably throw away some of the copypaste
07:16:40 <alar> and fix the behavior of standard Binary instances
07:16:52 <benmachine> "fix"?
07:17:03 <alar> @karma+ benmachine
07:17:03 <lambdabot> benmachine's karma raised to 6.
07:17:08 <benmachine> :O 6
07:17:30 <dayz> quicksilver, right. thanks
07:18:03 <alar> standard instances are for BE numbers, i have to use LE, making newtype(s) is the easiest way
07:18:27 <benmachine> ah I see
07:21:27 <jkingkong> can I pattern match in a let block? (i.e. let (a,b) = foo c d in ...)
07:21:55 <dafis> jkingkong: sure.
07:22:19 <dafis> jkingkong: It's a lazy pattern match, though.
07:22:45 <jkingkong> i have let (a,b) = foo c d in (a,b) `seq` ...
07:22:52 <jkingkong> so that it's strict
07:22:56 <benmachine> hmm
07:22:58 <dafis> jkingkong: So you can even do let (a, b) = foo a c in ...
07:23:04 <geheimdienst> if i called that "destructuring", would you have understood me? cause i always thought pattern matching was more like "|" and stuff
07:23:11 <fryguybob_> Is there a way to restrict a data constructor to only be used in pattern matching (outside of the declaring module)?
07:23:30 <jkingkong> maybe, i'm not up to snuff on the nomenclature, admittedly
07:23:49 <benmachine> geheimdienst: |?
07:25:04 <benmachine> case is the most common place you see pattern matching
07:25:07 <hpc> data Blah = Foo | Bar | Baz, i think
07:25:11 <hpc> oh
07:25:12 <benmachine> and functions which are basically case statements
07:25:20 <benmachine> hpc: that kind of makes sense I guess
07:25:22 <hpc> cases and lambdas
07:25:32 <benmachine> well lambdas are irrefutable patterns
07:25:35 <benmachine> like let
07:25:35 <dafis> jkingkong: " let (a,b) = foo c d in (a,b) `seq` ..." might be better case foo c d of (a, b) -> ...
07:25:46 <benmachine> ^ true
07:26:13 * geheimdienst confused pattern matches and guards. geheimdienst is a moron. sorry.
07:26:16 <jkingkong> dafis: noted, thanks
07:26:46 <dayz> quicksilver, so does that mean EX a b. f(a) < f(b) --> f(b) > f(a) is trivial?
07:26:55 <jkingkong> although, I'm not sure I understand why it's better
07:26:59 <dayz> or even, EX a b. f(a) < f(b) <--> f(b) > f(a)
07:27:23 <dayz> since a and b can always have the same instantiation
07:28:39 <dafis> jkingkong: it's better because the 'let' version first makes the binding explicitly lazy and then removes that laziness by the 'seq'
07:29:05 <dafis> jkingkong: better say directly that you want a strict pattern match
07:29:15 <quicksilver> dayz: yes. EX formulae with all variables mentioned on the left of a --> are not very interesting.
07:29:33 <quicksilver> dayz: all you have to do is show one single instantiation which yields false (on the left of the -->)
07:29:47 <dayz> quicksilver, how about <-->?
07:29:59 <jkingkong> dafis: I see, I didn't even realize the "case" construct was strict like that
07:30:00 <dayz> same, right
07:30:08 <quicksilver> well <--> is just sugar for two arrows one each way
07:30:18 <quicksilver> so my comments apply if all the variables are mentioned on both sides.
07:31:49 <fryguybob_> Specifically, I would like to be able to write:  let a :% b = 2 % 4 in (a, b)  without being able to write  let a :% b = 2 :% 4 in (a, b).
07:32:24 <benmachine> fryguybob_: view patterns might help?
07:32:48 <fryguybob_> benmachine: ok
07:41:14 <dayz> quicksilver, then is EX a b. f(a) < f(b) --> EX a b. f(a) > f(b) also trivial?
07:42:41 <fryguybob_> benmachine: Like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25993#a25993 ?
07:43:15 <jkingkong> say I want to alias a bunch of expressions to be used in another expression, but I don't want to do it lazily, what's the best way to do this?
07:43:18 <dafis> dayz: Yes.
07:43:20 <benmachine> fryguybob_: something like that, yeah
07:43:35 <jkingkong> so case exp of alias -> works
07:43:44 <jkingkong> but it's kinda cumbersome if you have lots of expressions
07:43:55 <kmc> "let" or "where"
07:44:01 <kmc> with a bang pattern
07:44:10 <kmc> > let !(a,b) = undefined in ()
07:44:11 <lambdabot>   *Exception: Prelude.undefined
07:44:17 <kmc> > let (a,b) = undefined in ()
07:44:18 <lambdabot>   ()
07:44:31 <kmc> this is sugar for
07:44:38 <kmc> > let x@(a,b) = undefined in x `seq` ()
07:44:39 <lambdabot>   *Exception: Prelude.undefined
07:44:48 <jkingkong> ah ok great thanks
07:44:56 <kmc> -XBangPatterns
07:45:10 <kmc> this is the special case of a bang pattern (at the outside of a pattern)
07:45:18 <jkingkong> i need to enable that extension? or is it bundled by default
07:45:21 <kmc> it means something somewhat different inside the middle of a pattern
07:45:32 <kmc> if you're using GHC you have to enable it
07:45:32 <jkingkong> i see
07:45:38 <jkingkong> ok thanks
07:45:39 <quicksilver> jkingkong: in 'case exp of alias ->', is alias a plain variable?
07:45:43 <quicksilver> jkingkong: (or a pattern)?
07:45:52 <jkingkong> just a plain variable
07:45:56 <jkingkong> or patter i guess
07:46:01 <quicksilver> then you are confused about lazines.
07:46:04 <jkingkong> depending on what exp evaluates to
07:46:05 <kmc> in that case the "case" is already lazy
07:46:09 <kmc> err
07:46:11 <quicksilver> case exp of var -> ... is identical to let var = exp
07:46:13 <kmc> > case undefined of x -> ()
07:46:14 <lambdabot>   ()
07:46:19 <kmc> > case undefined of x@(_,_) -> ()
07:46:19 <lambdabot>   *Exception: Prelude.undefined
07:46:32 <jkingkong> so if foo a b returns a tuple
07:46:42 <quicksilver> there is no 'extra' laziness in let var = exp
07:46:46 <jkingkong> case foo a b of (x,y) -> is lazy?
07:46:54 <kmc> jkingkong, no
07:46:54 <quicksilver> it's precisely as lazy as using exp directly.
07:46:58 <kmc> case e of x -> ...
07:46:59 <kmc> is lazy
07:47:02 <jkingkong> ah that's what i thought
07:47:02 <kmc> where 'x' is a single variable
07:47:08 <kmc> doesn't matter what e is, or what type it has
07:47:09 <quicksilver> jkingkong: that's why I asked if alias was a plain variable.
07:47:10 <hpc> > case undefined of (x, y) -> ()
07:47:11 <lambdabot>   *Exception: Prelude.undefined
07:47:11 <jkingkong> i think i misunderstood somebody earlier today in this channel
07:47:23 <kmc> but: case e of (C x y ... ) -> ...
07:47:27 <kmc> will evaluate e to WHNF
07:47:32 <hpc> > case (undefined, 5) of (x, y) -> ()
07:47:33 <lambdabot>   ()
07:47:34 <kmc> in order to match against the constructor C
07:47:38 <kmc> and (,) is just one example of that
07:47:49 <dcoutts_> (unless C is a newtype)
07:47:59 <kmc> yeah
07:48:10 <jkingkong> i see thanks for clearing that up
07:48:13 <kmc> :)
07:55:28 <smarmy> what changes if C is a newtype?
07:55:53 <kmc> then the constructor does not exist at runtime
07:57:12 <smarmy> ah
07:57:21 <kmc> > case undefined of Dual _ -> ()
07:57:22 <lambdabot>   ()
07:57:28 <kmc> > case undefined of Just _ -> ()
07:57:28 <lambdabot>   *Exception: Prelude.undefined
08:09:01 <alar> it seems that I can even hide standard definitions and write "newtype Word16 = W16 Data.Word.Word16"!
08:09:16 <alar> although i would not recommend myself doing so
08:10:04 <hpc> yes, that would be bad
08:10:11 <MacMagnus> do you think haskell is a though language to learn?
08:10:33 <hpc> MacMagnus: only if you try and code in it right away before grasping all the concepts
08:10:57 <hpc> you will bump up against all sorts of walls you didn't expect and don't understand
08:11:07 <smarmy> MacMagnus: the more you already know, the harder it will be
08:11:23 <smarmy> you must empty your cup, young one
08:11:37 <hpc> much to learn, you still have, young padawan :P
08:11:44 <MacMagnus> hehe
08:11:46 <geheimdienst> hpc, well no, for some people it might work. personally, i couldn't stand reading for hours and hours while not doing anything. i never learned any language that way
08:11:52 <EvanR-work> MacMagnus: its pretty easy
08:12:14 <MacMagnus> i cant read for hours, and remember everything...
08:12:24 <hpc> geheimdienst: obviously you can't learn by just reading, but i don't count stuff like having a ghci window open and messing around with Maybe and Either as "programming"
08:12:28 <EvanR-work> do incremental tests and play around in the interpretr
08:12:32 <EvanR-work> > head [1,2,3]
08:12:33 <lambdabot>   1
08:12:36 <EvanR-work> > tail [1,2,3]
08:12:37 <lambdabot>   [2,3]
08:12:56 * geheimdienst got started messing with his xmonad config file. a good way to slowly build up understanding. plus it's cool when you look at the file and each day understand more of the syntax than before
08:13:18 <EvanR-work> MacMagnus: the interpreter is great, it even lets you incrementally progress through complex IO actions and save intermediate results
08:13:43 <EvanR-work> i processed large files at work like this, without awk ;)
08:13:57 <smarmy> ghci is my desktop calculator
08:14:07 <EvanR-work> @quote posh
08:14:07 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
08:14:16 <hpc> smarmy: same, although i gave it an IRC interface :P
08:14:31 <dons> ivanm: http://haskell.org/haskellwiki/Libraries/WhenToRewriteOrRename
08:14:39 <MacMagnus> i use ghci too :) what i dont understand now, is why "let properNames = filter (`notElem` [".", ".."]) names" works how it works...
08:14:39 <dons> trying to summarise the points here so we can reach a policy consensus
08:14:57 <smarmy> it just needs a thorough units conversion library to be the best calculator ever
08:15:18 <Botje> MacMagnus: what part don't you get?
08:15:52 <EvanR-work> MacMagnus: it acts like a "let x = y" in the middle of do block
08:16:20 <EvanR-work> which also explains why webpage <- httpGet "google.com" also works
08:16:26 <MacMagnus> Botje: notElem is infix, so it should accept parameters from the left... but "filter" takes a function that takes from the right?
08:17:02 <smarmy> MacMagnus: it's: let properNames = filter (\x -> notElem x [".", ".."]) names
08:17:03 <hpc> EvanR-work: i didn't realize x <- function worked; nifty!
08:17:09 <EvanR-work> heh
08:17:16 <EvanR-work> i know right
08:17:41 <alar> @hoogle httpGet
08:17:42 <lambdabot> No results found
08:17:46 <EvanR-work> made it up
08:18:00 <Botje> MacMagnus: it's a section
08:18:18 <Botje> (`notElem` [...]) is the same as (\x -> x `notElem` [...])
08:18:26 <EvanR-work> MacMagnus: functions always 'take parameter on the right'
08:18:37 <EvanR-work> unless its in ``
08:18:41 <geheimdienst> i don't get it, httpGet would obviously be URL -> IO Something. what's the big deal with x <- httpGet ...?
08:18:49 <MacMagnus> ok, a lambda function?
08:19:17 <MacMagnus> EvanR-work: yes... :)
08:19:58 <Botje> geheimdienst: in GHCI, you're working in an implicit IO monad
08:20:07 <Botje> geheimdienst: try putStrLn "hallo"
08:21:18 <MacMagnus> well, thanks :)
08:23:01 <BMeph> If you really want to get the feel for the "IO-ishness" of GHCi, try: "mapM print [1..10]" and figure out why you see what it does...:)
08:23:21 <geheimdienst> botje, putStrLn "hallo" prints "hallo". yes of course. but i still don't get what the nifty thing is about x <- httpGet "http://..." ... :-(
08:23:39 <hpc> geheimdienst: do putStrLn x
08:23:43 <MacMagnus> this is from the "real world haskell"... paths <- forM properNames $ \name -> do what does it do? it goes through properNames recursively, applying the lambda function \name -> do to each of the lists content, and stores the result in pahts? but what does the lambda do?
08:23:46 <Botje> it downloads that url and puts the contents in a variable called x
08:23:53 <Botje> you can then play around with x
08:24:20 <hpc> geheimdienst: it has all the nice benefits of <- in a .hs file, only in the interactive interpreter
08:25:19 <geheimdienst> bmeph, it prints 1..10 each on its own line, then gives me return value, which is an array with 10 times () because print's return type is IO ()
08:25:34 <smarmy> MacMagnus: the lambda could do anything :)  it gets called for each name, takes the name as input, and does "something interesting" with it, for some value of "interesting"
08:26:45 <BMeph> geheimdienst: ..."and mapM's return type is then IO [()]." :)
08:27:33 <smarmy> MacMagnus: in the example you cited, the five lines following the \name -> do are part of the lambda function
08:28:09 <MacMagnus> smarmy: ah, yes... right :) but what is "name"? :) i dont understand lambdas...
08:28:17 <hpc> would it be possible to change the 'active monad' that GHCi runs in?
08:28:22 <quicksilver> hpc: no.
08:28:23 <hpc> say, from IO to []
08:28:28 <quicksilver> hpc: it's a dirty hack.
08:28:33 <hpc> because that would be fun
08:28:35 <quicksilver> and only works because IO itself is a dirty hack.
08:28:36 <smarmy> MacMagnus: \name -> ... is  a function that takes a value as input, calls it name, and then executes ..., where ... can refer to name
08:28:48 <quicksilver> (the implementation of, not the abstract notion of)
08:29:04 <smarmy> MagMagnus: it's just a function like any other, and higher-order, meaning you can pass the function to other functions
08:29:37 <smarmy> MacMagnus: in this case, the function is being passed to forM, which calls it with each value in the properNames list
08:29:47 <BMeph> MacMagnnus: Just remember "lambda" = "(anonymous) function". :)
08:30:39 <MacMagnus> hm :) ok, thanks... but smarmy, what is the result of "topdir </> name" then? :)
08:30:53 <Twey> > (\arg1 arg2 -> arg1 + arg2 / 2) 3 5
08:30:53 <lambdabot>   5.5
08:31:22 <BMeph> quicksilver: Don't forget to mention "IO /= =I/O, although I/O is done in IO." ;)
08:31:52 <Twey> Well, everything is I/O really.
08:32:09 <smarmy> MacMagnus: </> is a function that, if i recall, that returns the first argument (a path) with the second argument removed (the last dir/filename in the path) removed
08:32:27 <smarmy> MacMagnus: i didn't look that up, though....
08:32:34 <hpc> smarmy: so </> is the Haskell version of 'cd ..'?
08:32:45 <smarmy> MacMagnus: in this case, more like the haskell version of dirname
08:32:49 <hpc> oh, er, nvm
08:32:53 <nff> isn't it the concatenation of a path separator, rather?
08:32:56 <geheimdienst> macmagnus, that takes what's in the variable "topdir", adds a "/" at the end, and then adds what the variable "name" contains
08:33:08 <nff> right.
08:33:08 <geheimdienst> smarmy, i'm 99% sure it's not that ...
08:33:09 <smarmy> geheimdienst: thank you
08:33:11 <smarmy> my bad
08:33:12 <geheimdienst> ;-)
08:33:18 <smarmy> need to look this stuff up before i speak
08:33:21 <smarmy> heh
08:33:53 <smarmy> i should be working, anyway :)  somebody smarter than me speak...
08:33:55 <geheimdienst> macmagnus you could also say topdir ++ "/" ++ name (on linux, mac, etc.). on windows you would need to say topdir ++ "\" ++ name
08:34:05 <Twey> Not necessarily a </>… it's platform-dependent: that's the point
08:34:06 <geheimdienst> </> does the right thing for you on all platforms
08:34:07 <MacMagnus> ah, yes.
08:34:09 <Twey> Er
08:34:13 <Twey> Not necessarily a '/'
08:34:16 <hpc> windows lets you use '/'
08:34:21 <Twey> hpc: It doesn't
08:34:23 <hpc> and oldass macs use ':'
08:34:26 <Twey> Some Windows apps do translation
08:34:35 <Twey> But the Windows subsystem requires backslashes
08:34:37 <hpc> Twey: ah, that would be it, probably
08:34:57 <MacMagnus> thanks :) i think i understand the example in the book now
08:37:11 <zygoloid> Twey: you've got it backwards. the lower-level stuff accept \ or /. the higher-level stuff tend to reject / as a separator
08:37:44 <zygoloid> (but it depends exactly which lower-level stuff; iirc the support is not completely uniform)
08:38:19 * zygoloid looks for the oldnewthing post where this was explained
08:38:24 <Twey> zygoloid: I don't think so… the API doesn't (stuff like fopen()), I'm pretty sure, and cmd.exe doesn't, but explorer.exe does
08:39:34 <zygoloid> cmd.exe doesn't accept it for backwards-compatibility with DOS 1.0, where command-line switches didn't require a space after the command name
08:40:07 <zygoloid> fopen does accept either iirc. explorer sometimes gets confused as to whether you're talking about a UNC path
08:41:14 <zygoloid> but fopen isn't the lowest level anyway ;)
08:41:17 * fryguybob_ thinks fopen calls OpenFile
08:41:23 * geheimdienst doesn't have windows, but is pretty sure you still can do stuff like dir/s and cd.. without the space
08:42:39 <zygoloid> The CreateFile documentation says: "Note  File I/O functions in the Windows API convert "/" to "\" as part of converting the name to an NT-style name, except when using the "\\?\" prefix as detailed in the following sections."
08:44:58 <Ke> sadly the use of '/' in filenames is common on windows
08:45:45 <fryguybob_> Ke: I've never seen that.
08:46:57 <geheimdienst> wouldn't that conflict with using "/" for command line switches?
08:47:09 <zygoloid> geheimdienst: not very often, no.
08:47:15 <Ke> geheimdienst: most people don't use cmd on windows
08:47:39 <zygoloid> plus it only makes a difference if you want to miss the space out after the command name, or want to use a file path starting in /.
08:47:59 <zygoloid> in the former case, add a space; in the latter case, add a drive letter :)
08:49:05 <geheimdienst> what i meant to say is, afaik "/" is not legal in a windows filename :-) whatever the reasons, but probably the command line switch thing is among them
08:49:22 <zygoloid> yep. it's one of the dozen or so reserved characters
08:49:51 <gio123> k
08:50:18 <Ke> interesting, I fail again
08:50:31 <maltem> As hackage is to be redesigned now, random thought: Would it make sense to have a notion of a "project", such that the interface subsumes e.g. cairo, glib etc. in one gtk2hs "project"?
08:50:33 <zygoloid> http://msdn.microsoft.com/en-us/library/aa365247(v=VS.85).aspx
08:51:12 <zygoloid> maltem: i guess we'd want projects and packages to have a many-to-many relationship?
08:51:28 <dcoutts_> maltem: I don't think so, but it does make sense to have links to complementary or alternative packages
08:51:44 <maltem> zygoloid, not sure if it should be many-to-many or one-to-many
08:52:26 <aavogt> some libraries are logically one unit, but they are split up on hackage
08:52:53 <dcoutts_> so the package pages for such packages should link to the other related packages
08:53:20 <maltem> dcoutts_, my motivation is that it would then be cleaner to submit a couple of rather small packages that belong together, and are split up ony because that's easier wrt the build system
08:53:45 <dcoutts_> cleaner in what respect?
08:55:01 <geheimdienst> couldn't you make an empty package that depends on the bunch of small packages?
08:55:16 <maltem> one entry for one library in the list, rather than thelibrary-core, thelibrary-examples, thelibrary-some-backend
08:55:21 <dcoutts_> geheimdienst: yes but it's not very useful, you cannot depend on such packages
08:55:25 <maltem> I guess it's no big deal
08:55:46 <dcoutts_> maltem: oh well that "big package list" interface isn't very good anyway
08:55:56 <zygoloid> dcoutts_: what would go wrong if you depended on an empty package?
08:56:09 <dcoutts_> zygoloid: well you cannot import any modules from it
08:56:18 <dcoutts_> since it does not export any
08:56:23 <zygoloid> oh, i see.
08:56:30 <maltem> dcoutts_, heh, actually I like it, because searching through that page is still more efficient than most "search" web interfaces
08:56:36 <hpc> it wouldn't need to have depends
08:56:49 <hpc> it would work like the metapackages of apt, etc
08:57:07 <hpc> where you do apt-get openoffice or whatever and get everything
08:57:11 <dcoutts_> hpc: it makes sense as a meta-package, just not as a dependency
08:57:19 <dcoutts_> e.g. haskell-platform is a meta-package
08:57:51 <zygoloid> i suppose if someone cared enough, we could extend cabal to support packages exporting other packages' modules?
08:58:07 <dcoutts_> it would need help from the compilers
08:58:23 <hpc> that wouldn't add any benefit anyway
08:58:29 <aristid> i always use :m + in ghci to load module
08:58:33 <hpc> if you have a metapackage, you have the sub-packages
08:58:35 <aristid> but that gets them unqualified
08:58:40 <zygoloid> hpc: you don't understand the problem.
08:58:42 <aristid> can i somehow load them qualified?
08:58:52 <hpc> aristid: import qualified?
08:58:57 <aristid> for example when i load Data.Foldable or Control.Category
08:58:57 <zygoloid> hpc: when cabal builds something, only the modules provided by its direct dependencies are visible
08:58:59 <aristid> hpc: in ghci?
08:59:03 <hpc> aristid: yes
08:59:20 <zygoloid> hpc: so depending on a metapackage doesn't allow you to use modules provided by its dependencies
08:59:30 <aristid> > import qualified Control.Category
08:59:30 <aristid> <interactive>:1:0: parse error on input `import'
08:59:31 <hpc> aristid: er, nvm; didn't work
08:59:31 <lambdabot>   <no location info>: parse error on input `import'
08:59:31 <aristid> no.
08:59:44 <hpc> > import Control.Category
08:59:44 <lambdabot>   <no location info>: parse error on input `import'
08:59:51 <dcoutts_> aristid, hpc: I think 'import' in ghci is new in 6.12.2
09:00:03 <aristid> dcoutts_: is there an alternative in older ghci?
09:00:12 <dcoutts_> aristid: no, just :m + 
09:00:16 <aristid> :/
09:00:17 <hpc> dcoutts_: i just did it in 6.12.1
09:00:22 <Saizan> "import" in ghci doesn't support qualified anyway, i think
09:00:24 <zygoloid> dcoutts_: import has been around since at least 6.8
09:00:28 <zygoloid> (in ghci)
09:00:47 <aristid> import works, yeah
09:00:47 <dcoutts_> hpc: ohh, it just doesn't support qualified
09:00:51 <aristid> but not with qualified :/
09:01:06 <aristid> that's a PITA
09:01:15 <dcoutts_> zygoloid: really? I thought it was much newer
09:01:38 <zygoloid> it definitely works in ghci 6.8.3 on this box
09:01:39 <Saizan> aristid: write an .hs with the imports as you want them an load it :)
09:01:43 <aristid> what's the difference between Category and Functor? btw?
09:01:45 <dcoutts_> zygoloid: fair enough
09:01:50 <aristid> Saizan: haha
09:02:27 <aristid> @src (<$)
09:02:27 <lambdabot> (<$) = (<$>) . const
09:02:52 <hpc> :t fmap . const
09:02:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
09:02:53 <benmachine> aristid: they're different things? what's the similarity?
09:03:04 <Ke> zygoloid: would you happen to know why I have recollection of having huge problems with filenames with / in them, any other system that produces them?
09:03:09 <aristid> benmachine: . from Category and fmap from Functor seem similar
09:03:26 <benmachine> aristid: well, Prelude.. is a specialisation of both
09:03:28 <Saizan> aristid: it's easier to say what common to them: Category.(.) and Functor.fmap can be both specialized to Prelude.(.), but that's it.
09:03:33 <benmachine> but they're different functions otherwise
09:03:35 <zygoloid> http://hackage.haskell.org/trac/ghc/ticket/2362 <-- import qualified in ghci bug
09:03:51 <aristid> ah.
09:04:08 <benmachine> Categorys have kind * -> * -> *
09:04:43 <benmachine> there is a similarity between . and fmap
09:05:31 <benmachine> if you had Functor (cat a) and Control.Category.id, you can define Control.Category..
09:05:47 <zygoloid> Ke: dunno. i have a vague memory that old versions of the MS C++ compiler didn't like #includes with / in.
09:06:18 <benmachine> or wait
09:06:21 * benmachine confuses self
09:06:25 <benmachine> something like that, anyway
09:09:20 <aristid> MonadPlus is not quite the intersection of Monad and Alternative?
09:09:42 <benmachine> it has its own laws
09:09:48 <benmachine> but no-one can quite agree what they are :P
09:09:57 <Saizan> @where typeclassopedia
09:09:57 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:09:59 <benmachine> generally it's agreed that you have the monoid
09:10:11 <benmachine> and often people agree that mzero >>= k = mzero
09:10:16 <aristid> benmachine: i think they should be defined so that MonadPlus can be simply the intersection of Alternative and Monad
09:10:23 <aristid> because that would be beautiful
09:10:33 <benmachine> aristid: but if you want mzero >>= k = mzero, you need to involve >>=
09:10:40 <aristid> hmmm
09:10:43 <aristid> true
09:10:53 <benmachine> aristid: why would you need a class to be the intersection, anyway?
09:10:54 <jmcarthur> i disagree. if you just want alternative semantics then just use alternative
09:10:57 <aristid> so MonadPlus is always more than that.
09:11:05 <benmachine> (Applicative m, Monad m) => m
09:11:11 <benmachine> eeer Alternative
09:11:15 <fryguybob_> Ke: Windows pre-NT?
09:11:20 <aristid> jmcarthur: what if you also want Monad? but it's true, i was on a wrong path
09:11:39 <aristid> benmachine: well, class intersections would be neat syntactic sugar
09:11:39 <Ke> fryguybob_: from what I read it has almost always been forbidden
09:12:11 <benmachine> aristid: there's a proposal called context aliases which might interest you
09:12:12 <Ke> and I never used linux before NT
09:12:19 <aristid> benmachine: where?:)
09:12:47 <benmachine> aristid: on the wiki I think
09:12:55 <aristid> Ke: NT as in _you_ had NT, or as in NT was released?
09:13:08 <Ke> aristid: I had NT
09:13:13 <Ke> aristid: ie. XP
09:13:32 <aristid> Ke: XP is the first widely used NT :D
09:14:00 <Ke> wasn't win2k too
09:14:03 <Saizan> benmachine: with Functor (cat a) and Control.Category.id you can define Control.Arrow.arr, but not (>>>)
09:14:35 <benmachine> Saizan: yeah, I think I was thinking that with arr and . you could define fmap
09:14:43 <benmachine> and then with fmap and id you could define .
09:14:53 <benmachine> and then I got my fmaps confused and tried to define . with .
09:15:54 <aristid> benmachine: http://www.haskell.org/haskellwiki/Context_alias
09:15:59 <benmachine> right
09:16:06 <Saizan> benmachine: with fmap and id you could define . ?
09:16:25 <benmachine> er, arr
09:16:33 <benmachine> fmap and id = arr
09:16:39 <benmachine> arr and . = fmap
09:16:45 <benmachine> arr and id and . = arr
09:16:53 <benmachine> but that doesn't quite work :P
09:17:18 <Saizan> arr = arr seems right :)
09:17:36 <benmachine> it typechecks!
09:17:39 <benmachine> so it must work
09:18:37 <aristid> @hoogle .:
09:18:37 <lambdabot> No results found
09:18:37 <thoughtpolice> hehe
09:18:58 <aristid> :t (.:)
09:18:59 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:19:05 <aristid> yay, it's not lost!
09:19:06 <thoughtpolice> i remember seeing 'instance FromString CompactString where fromString = fromString -- surprise, not an infinite loop!' in LHC :)
09:19:37 <aristid> @pl would greatly benefit from (.:) = fmap.fmap
09:19:37 <lambdabot> (line 1, column 33):
09:19:37 <lambdabot> unexpected "="
09:19:37 <lambdabot> expecting variable, "(", operator or end of input
09:19:47 <thoughtpolice> always gotta love seemingly circular definitions
09:20:12 <thoughtpolice> (although actually that seems particularly annoying in a couple ways because it's not sure at what scope 'fromString' comes from.)
09:20:22 <thoughtpolice> only more of an argument to use qualified imports where-ever possible
09:21:04 <hpc> :t on
09:21:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:27:25 <aristid> @src on
09:27:25 <lambdabot> (*) `on` f = \x y -> f x * f y
09:27:28 <aristid> ^ hpc
09:27:39 <pastorn> wait wat?
09:27:52 <hpc> aristid: i know, i was trying to find a basis of comparison for fmap.fmap
09:27:57 <pastorn> they NAME an infix argument to *
09:28:01 <pastorn> that's just naughty
09:28:18 <aristid> pastorn: i think it's nice, because it illustrates the usage nicely.
09:28:30 <aristid> * stands for an arbitrary BINARY operator
09:28:30 <pastorn> but it's true, an anonymous 2-ary oprator usually goes by "*"
09:28:45 <Jafet> Yes, kids, Haskell is a functional programming language!
09:28:59 <sproingi1> that one confused me for a long time
09:29:07 <aavogt> pastorn: that defines on, not *
09:29:30 <aristid> on f g x y = g (f x) (f y)
09:29:32 <aristid> would work too
09:29:36 <fryguybob_> What is the fixity of * in that?
09:29:49 <aristid> fryguybob_: infix :P
09:30:22 <aavogt> > (\(*) x -> x * x * x * x) (/) 2
09:30:22 <lambdabot>   0.25
09:30:25 <pastorn> :p
09:30:27 <fryguybob_> aristid: I mean the level, it gets the default level right?
09:30:28 <pastorn> the best fixity
09:30:43 <pastorn> aristid: wouldn't you agree
09:30:45 <mreh> fryguybob_, function application is always lower predence than an infix operator
09:31:09 <mreh> do I mean higher?
09:31:14 <aristid> pastorn: ofcoursity
09:31:22 <fryguybob_> mreh, right, but if you had two named infix functions on the lhs?
09:31:48 <aavogt> > (\(*) (+) x -> x * x * x + x) (/) (*) 2
09:31:49 <lambdabot>   1.0
09:32:22 <benmachine> I believe the default fixity is infixl 9
09:32:28 <aavogt> > 2 / (2 / (2 * 2))
09:32:28 <lambdabot>   4.0
09:32:44 <aavogt> > ((2 / 2) / 2) * 2
09:32:44 <lambdabot>   1.0
09:32:47 <aristid> > (2 / 2 / 2) * 2
09:32:48 <lambdabot>   1.0
09:32:54 <hpc> > 2/2/2*2
09:32:55 <lambdabot>   1.0
09:33:09 <aristid> aavogt: so it keeps the global fixity?
09:33:26 <sproingi1> dont fixity what aint brokity
09:33:27 <aavogt> does it?
09:33:47 <aristid> > (\(*) (+) x -> x + x * x * x) (/) (*) 2
09:33:48 <lambdabot>   1.0
09:33:48 <benmachine> > let (*) = (+) in let (+) = const in 4 + 6 * 8
09:33:49 <lambdabot>   12
09:33:50 <aavogt> > (\(*) (+) x -> x + x * x * x) (/) (*) 2
09:33:51 <lambdabot>   1.0
09:33:54 <aristid> aavogt: itdoes
09:34:04 <benmachine> > let (*) = (+) in let (+) = const in 4 + (6 * 8)
09:34:04 <lambdabot>   4
09:34:07 <benmachine> > let (*) = (+) in let (+) = const in 4 + 6 * 8
09:34:08 <lambdabot>   12
09:34:17 <benmachine> the fixity gets overwritten
09:34:22 <aavogt> default is infixl
09:34:26 <benmachine> infixl 9
09:34:26 <fryguybob_> benmachine: ok
09:34:42 <aristid> hmmm
09:34:45 <sproingi1> how'd i get myself banned from #haskell-in-depth?  i dont think i've even talked there for months
09:34:48 <aristid> now i'm confused
09:34:51 <aavogt> > let (*) = (+); infixr 1 *; (+) = const in 4 + 6 * 8
09:34:52 <lambdabot>   4
09:35:06 <pastorn> class Render a where
09:35:09 <pastorn>     render :: Size -> a Image
09:35:17 <pastorn> is that good for a terminal graphics library?
09:35:27 <pastorn> or should it be render :: a -> Size -> Image
09:35:39 <pastorn>  (the Size being the bounds it would have to abide to)
09:35:51 <benmachine> pastorn: that kinda depends on your data types
09:35:54 <benmachine> what Image is
09:36:06 <pastorn> benmachine: it's Graphics.Vty.Image
09:36:13 <Saizan> sproingi1: are you identified?
09:37:06 <sproingi1> Saizan: ahh, thats it
09:37:13 <sproingi1> guess i have to /part before i can /nick
09:37:32 <pastorn> you make them from strings and combine them to bigger ones with <-> and <|> (vertically and horizontally) to make bigger ones
09:37:56 <benmachine> a -> Size -> Image sounds more straightforward
09:38:03 <Saizan> sproingie: there's also /ns identify <nick> <password> btw, to identify to another nick 
09:38:07 <monochrom> "a picture is worth a thousand <->s and <|>s"
09:38:13 <pastorn> once you're satisfied you use pic_for_image :: Image -> Picture, and then that is "printed" to the terminal
09:38:17 <aristid> :t (<->)
09:38:18 <lambdabot> Not in scope: `<->'
09:38:22 <aristid> @hoogle <->
09:38:22 <lambdabot> Text.Html (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
09:38:22 <lambdabot> Text.XHtml.Table (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
09:38:25 <pastorn> aristid: http://hackage.haskell.org/package/vty
09:38:29 <sproingie> Saizan: ah didnt know about that one.  thanks :)
09:38:54 <aristid> pastorn: oh, <|> wasn't mean as in Alternative?
09:39:09 <pastorn> anyway, i want to make a typeclass, Render, like Show, but i thought that you want to know how big your printing area is
09:39:33 <pastorn> so it needs a Size argument (data Size = Size Word Word)
09:39:35 <aavogt> when do you say how large it is?
09:39:35 <aristid> > return 1 >>= [2]
09:39:36 <lambdabot>   Couldn't match expected type `t -> m b' against inferred type `[a]'
09:39:45 <aristid> > return 1 >> [2]
09:39:45 <lambdabot>   [2]
09:39:56 <pastorn> aavogt: i have this:
09:39:58 <pastorn> class Render a where
09:40:00 <pastorn>     render :: Size -> a Image
09:40:02 <pastorn> whoop
09:40:07 <zygoloid> which is a better name for fmap.fmap, <$$> or <<$>> ?
09:40:13 <pastorn>     render :: Size -> a -> Image
09:40:16 <aristid> zygoloid: .:
09:40:17 <sproingie> .
09:40:18 <pastorn> aavogt: ^^
09:40:28 <zygoloid> aristid: that's inconsistent and inextensible
09:40:32 <aristid> sproingie: no, . is fmap
09:40:44 <aristid> zygoloid: .. is reserved for the language :/
09:40:46 * zygoloid doesn't like (.) = fmap
09:40:50 <sproingie> oh.  too bad .. doesnt work
09:40:54 <pastorn> so my actual question is, from a library users standing point; shhould i flip a and Size?
09:41:19 <sproingie> zygoloid: why not?  doesnt it turn into simple composition for functions anyway?
09:41:32 <aristid> zygoloid: hmmm. <$$> might lead people to think it's like <**> is to <*>
09:41:40 <zygoloid> sproingie: sure, but i find it confusing when it's used for something other than composition.
09:41:42 <aristid> :t (<**>)
09:41:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
09:41:53 <aavogt> @hoogle $$
09:41:53 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
09:41:53 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
09:41:53 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
09:42:05 <aavogt> @hoogle $$$
09:42:05 <lambdabot> No results found
09:42:22 <zygoloid> @type flip (<*>)
09:42:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
09:42:25 <aristid> zygoloid: on the other hand <$$> is easier to type than <<$>>
09:42:37 <zygoloid> i assume <**> is the /other/ obvious operation of that type :)
09:42:43 <aristid> zygoloid: <**> is not FLIP <**>
09:42:49 <aristid> EMPHASIS wrong
09:43:06 <aristid> zygoloid: <**> would be flip (<**>) if not for the action order
09:43:07 <zygoloid> @type \af ax -> flip ($) <$> ax <*> af
09:43:07 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b) -> f a -> f b
09:43:12 <sproingie> zygoloid: ok sure i can see it being abused
09:43:17 <pastorn> fakk it
09:43:21 <aavogt> which functions are themselves flipped?
09:43:25 <zygoloid> aristid: that's what i meant by "the /other/ obvious operation of that type"
09:43:25 <aristid> @src <**>
09:43:25 <lambdabot> (<**>) = liftA2 (flip ($))
09:43:35 <pastorn> if noone's willing to help me i'll just go with my intuition
09:43:39 <aristid> @src liftA2
09:43:40 <lambdabot> liftA2 f a b = f <$> a <*> b
09:43:50 <aristid> zygoloid: oh ok:)
09:44:03 <benmachine> :t (<$>)
09:44:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:44:17 <zygoloid> pastorn: how is it most likely to be partially-applied?
09:44:18 <benmachine> it's not possible for <$$> to be analogous to <**>
09:44:20 <aavogt> pastorn: what do you get out of using a class instead of functions like those pretty-printing libraries?
09:44:31 <benmachine> I like <$$>
09:44:42 <pastorn> aavogt: not corrupting the namespace
09:44:53 <zygoloid> benmachine: <$$> :: f (a -> b) -> a -> f b?
09:44:55 <aavogt> in what way?
09:45:06 <benmachine> zygoloid: oh, I guess so, but also, no
09:45:08 <pastorn> you'll call 'render' quite often
09:45:19 <benmachine> I don't think the association is very strong because <**> isn't a very good name
09:45:30 <pastorn> aavogt: say that you're making a terimanal based chess program
09:45:35 <aavogt> pastorn: as in, why must all your widgets have different types?
09:45:40 <pastorn> then you'll want to print the board
09:46:04 <aavogt> the set of primitives isn't going to be extended by users of the library, right?
09:46:07 <pastorn> then, for rendering a piece you'll want this typclass for donig so:
09:46:51 <pastorn> 'render (Size 2 1) (whiteQueen)' =~= "Qw"
09:47:11 <pastorn> but then you would also want to call it from the top level like this:
09:47:18 <aavogt> that doesn't justify why you need a typeclass
09:47:24 <pastorn> render terminalDims chessBoard
09:47:35 <pastorn> aavogt: it sort of does
09:47:50 <pastorn> not corrupting the namespace is a great cause for a typeclass
09:47:58 <pastorn> or are you saying that Show is a mistake?
09:48:17 <aavogt> you've missed my point that all the things you render are built up from a small set of primitives
09:48:45 <aavogt> that the user of the library only combines, rather than creating new types
09:48:49 <pastorn> aavogt: so? each little part will still, in some way or the other, give cause to an Image
09:49:54 <pastorn> aavogt: anyway, the user is free to ignore the Size argument in their implementation of the typeclass
09:50:02 <aavogt> http://hackage.haskell.org/packages/archive/pretty/1.0.1.1/doc/html/Text-PrettyPrint-HughesPJ.html
09:50:14 <pastorn> anyway, what i was thinking was that you'd use it like this
09:50:49 <aavogt> you don't need typeclasses if all your operations are over the same type
09:51:16 <pastorn> chessRowImage boardRow = foldr (<|>) emptyImage (map (render (Size 2 1)) boardRow)
09:51:38 <pastorn> aavogt: wait... wut?
09:51:52 <pastorn> they will be of different types....
09:52:02 <pastorn> *over*
09:52:23 <aavogt> or the data type can contain a   runder function
09:52:56 <pastorn> aavogt: have you ever used Vty
09:52:58 <pastorn> ?
09:53:04 <aavogt> I've looked at it
09:53:10 <pastorn> not enough :p
09:53:21 <pastorn> but i'm not gonna listen to you
09:53:31 <pastorn> you think that Show was a step in the wrong direction
09:53:47 <aavogt> no, show is different
09:53:54 <pastorn> you'd much rather have showInt, showDouble, showString, showChar etc. etc.
09:54:06 <pastorn> no it's really not
09:54:30 <pastorn> it's only that Image has dimensions, so when you generate it you might want to take that into consideration
09:54:34 <c_wraith> I've discovered another reason to hate that String is an alias for [Char].  It leads to really confusing error messages for beginners who wonder why the type checker is complaining that they're trying to unify IO and []
09:54:53 <mux> Expected type: [[[Char]]]
09:55:05 <pastorn> aavogt: hang on, changing the bus now (brb in a little while.... 10 minutes, or 50 (loldunno))
09:56:08 <pastorn> aavogt: but look a little at Graphics.Vty.Picture, then you might see why i consider a Render class a necissitey
09:56:48 <aristid> c_wraith: i wonder if String should even be a list internally
09:56:52 <ezyang> Hey goes, does a monad along the lines of data EitherUnknown a b c = Fail a | Pass b | Unknown c; instance Monad (EitherUnknown a b) where ... make any sense? 
09:57:30 <aavogt> this is  Monad (Either (Either a b))
09:57:56 <ezyang> Oh, that's true. 
09:57:58 <aavogt> how do you fail nicely here?
09:58:03 <benmachine> ezyang: Unknown is a weird name
09:58:22 <ezyang> aavogt: What do you mean? 
09:58:26 <benmachine> aavogt: fail = error, sorted
09:58:54 <aavogt> ezyang: though I lied if you consider bottoms
09:58:57 <ezyang> benmachine: Hm; something like Intermediate? 
09:59:10 <benmachine> yeah, I think that'd be better
09:59:17 <zygoloid> ezyang: you need to make sure that (>>) associatively combines the Fail and Pass values, but there's a few reasonable Monad instances for that type
09:59:51 <benmachine> zygoloid: I'd imagine it'd be quite hard not to associatively combine them
09:59:53 <ezyang> zygoloid: I want Fail and Pass to have the semantics of Either e; that is, once I pass or fail I short circuit the rest of the computation 
09:59:56 <benmachine> unless you could look at the values
10:00:42 <ezyang> I'm pretty sure that's associative 
10:00:47 <benmachine> it is
10:01:05 <ezyang> Cool. Any recommendations against rolling my own monad class and using Either Either? 
10:01:16 <benmachine> Either Either sounds ugly to me
10:01:21 <ezyang> me too 
10:01:24 <benmachine> Left (Right a) etc.
10:01:30 <benmachine> however
10:01:39 <benmachine> if a = b, then Either (Bool, a) would do
10:02:19 <quicksilver> ezyang: that looks unlikely to me.
10:02:41 <quicksilver> ezyang: you're likely to get the sane instance by making the 'Pass' result the parameter of the monad.
10:02:58 <quicksilver> Unless 'Pass' has 'Exit' semantics, and 'Unknown' has 'Continue Computation' semantics
10:03:03 <quicksilver> in which case it does make sense.
10:03:05 <ezyang> quicksilver: What you just said. 
10:03:08 <benmachine> yeah I think that's the idea
10:03:21 <quicksilver> right. Yes, that's a monad.
10:03:25 <ezyang> To give a sample use-case, calculating satisfiability 
10:03:29 <quicksilver> two differ kinds of exit criterion
10:03:40 <quicksilver> but from the point of view of the monad laws they are both exits
10:05:24 <jkingkong> oh i should have mentioned this much earlier but the cause of the stack overflow arose from trying to compare two Data.Maps with (==)
10:05:35 <jkingkong> for future reference
10:05:36 <ezyang> Now, if I'm still using Intermediate as the name, I need to figure out a new name for the monad 
10:05:49 <ezyang> PassFail? PassFailComp? TristateComp? 
10:05:53 <ezyang> :-) 
10:06:01 <benmachine> Eieither
10:06:11 <benmachine> this makes sense in my head
10:07:41 <Jafet> The EIEIO monad
10:10:41 <kmc> if you have multi-way exit, why not use continuations?
10:10:43 * BMeph has a cow!
10:13:35 <caxapok> hi. (i'm from russia. sorry for my english, please.) I'm learning haskell (2 days yet). So, when I in the 'ghci' enter ':t 5', ghci answer me: '5 :: forall t. (Num t) => t'. I don't know what is 'forall t.', 'Num t', and symbol '=>'. Thanx.
10:14:26 <ezyang> caxapok: Numbers are a little special 
10:14:58 <dons> no one moves from haskell to clojure, going by the 'state of clojure' graphs
10:15:12 <dons> nor lisp, nor scheme
10:15:22 <dons> but a stack from java and scala
10:15:28 <dons> sorry, ruby
10:16:17 <kmc> caxapok, read "5 has type t, for any t which is in the type class Num"
10:16:21 <caxapok> ezeike: I'm that 't' is any type. So, 'forall t' is for all type t. But what mean '(Num t) => t'. => is deffer -> ?
10:16:21 <Jafet> I see haskell is regaining success
10:16:29 <kmc> => is different from ->, yes
10:16:37 <kmc> -> is used to built function types
10:16:51 <kmc> => attaches constraints to a type
10:16:57 <caxapok> kmc: THANX. I understand. )))
10:17:06 <kmc> the issue here is that we want to be able to use 5 as either an Int or a Double or a Float etc.
10:17:12 <kmc> but we can't let it be just any type whatsoever
10:17:17 <kmc> 5 :: Char -> Char would make no sense
10:17:38 <kmc> so we constrain it to types which are members of this "Num" type class
10:17:47 <kmc> a type class is just a set of types; Num is the set of all "numeric types"
10:18:34 <kmc> dons, what's the "state of clojure" graph?
10:18:52 <caxapok> kmc: "Num is the set of.." -- cool! big thanx for description this.
10:19:03 <kmc> :)
10:19:08 <_minoru> еху
10:19:17 <_minoru> всем красноглазегам из России - привет
10:20:04 <caxapok> _minoru: вау, и тут русскиу есть. А почему на русском #haskell не сидите (Rusnet)? Я зашет туда, а там все молчат. Я сюда попёр...
10:20:42 <_minoru> ну, у нас секретный план по захвату запада
10:20:56 <kmc> "#haskell.ru: Russian speakers. Seems that most of them migrated to Jabber conference (haskell@conference.jabber.ru)."
10:21:00 <kmc> "#haskell_ru	 Russian speakers again, in UTF-8. For those, who prefer good ol' IRC channel with a lambdabot."
10:21:18 * fryguybob_ sees the secret plan
10:21:30 <_minoru> caxapok, вообще, если что, мы координируемся в haskell@c.j.r, заходи
10:21:42 <caxapok> ок
10:23:20 <MacMagnus> stupid question: what does "$" do? :)
10:23:25 <kmc> @src ($)
10:23:25 <lambdabot> f $ x = f x
10:23:35 <kmc> it's just function application, but as an infix operator
10:23:39 <sclv> it has a low precedenc is the key thing
10:23:40 <kmc> so it's useful for syntactic reasons
10:23:44 <kmc> also as a higher-order function:
10:23:44 <mauke> I can't read russian but "ну, у нас секретный план" looks like "hi, i has sekret plan"
10:23:48 <zygoloid> MacMagnus: it's used to avoid parentheses. f x $ g y == (f x) (g y)
10:23:49 <kmc> > map ($ 3) [succ, pred]
10:23:50 <mauke> what is my brain trying to tell me?
10:23:50 <lambdabot>   [4,2]
10:24:00 <EvanR-work> lol
10:24:12 <_minoru> fryguybob_, I prefer japanese when talking with lambdabot
10:24:17 <EvanR-work> can never trust those russian
10:24:25 <kmc> what a country
10:24:36 <fryguybob_> _minoru: I prefer unicode snowman.
10:24:40 <MacMagnus> zygoloid: ah, thx :)
10:25:27 <djahandarie> > text "今日は"
10:25:28 <lambdabot>   今日は
10:25:39 <hpc> :t text
10:25:40 <lambdabot> String -> Doc
10:26:25 <alip> @src length
10:26:25 <lambdabot> Source not found. You type like i drive.
10:26:27 <djahandarie> > text "私はラムダボツです"
10:26:28 <lambdabot>   私はラムダボツです
10:26:28 <kmc> @let _ ☭ _ = "Пролетарии всех стран, соединяйтесь!"
10:26:30 <lambdabot>  Defined.
10:26:40 <djahandarie> What?
10:27:03 <djahandarie> My font doesn't even have that symbol
10:27:05 <EvanR-work> > 3 ☭ []
10:27:06 <lambdabot>   "\1055\1088\1086\1083\1077\1090\1072\1088\1080\1080 \1074\1089\1077\1093 \1...
10:27:11 <EvanR-work> > text $ 3 ☭ []
10:27:12 <lambdabot>   Пролетарии всех стран, соединяйтесь!
10:27:16 <EvanR-work> haha
10:27:23 <benmachine> djahandarie: hammer and sickle, it seems
10:27:23 <_minoru> djahandarie, he refers to Soviet Union
10:27:29 <benmachine> don't know wha the text is though
10:27:33 <djahandarie> Heh
10:27:34 <mauke> U+262D (e2 98 ad): HAMMER AND SICKLE [☭]
10:27:35 <jesusabdullah> ????!?!?!?!!?1
10:27:35 <kmc> "workers of the world unite"
10:27:39 <benmachine> oh right
10:27:41 <mauke> what the crap
10:27:43 <djahandarie> lmao
10:27:46 <jesusabdullah> oshit that IS a hammer/sickle o_o
10:27:48 <kmc> proletarii etc.
10:27:59 <mauke> my terminal shows a black smiling face
10:28:02 <EvanR-work> working unicode fonts for the win
10:28:16 <mauke> ... restarting fixed it
10:28:17 * jesusabdullah thought he had unicodes
10:28:19 <jesusabdullah> oh well :(
10:28:24 * jesusabdullah is too lazy to fix
10:28:26 <djahandarie> I'm stuck in putty/windows atm so I haven't bothered figuring out a good font here
10:28:27 <_minoru> text "賢いね"
10:28:27 <kmc> mauke, your terminal's marxism has been influenced by black nationalism
10:28:30 <EvanR-work> xterm is all you need ;)
10:28:44 <mauke> djahandarie: DejaVu Sans Mono
10:29:01 <djahandarie> mauke, that's what I use on my home PC
10:29:06 <Amadiro> Does anyone happen to know if GHC has an option to warn me about unused variables?
10:29:13 <mauke> U+263B (e2 98 bb): BLACK SMILING FACE [☻]
10:29:15 <djahandarie> Suppose I could get it here as well...
10:29:17 <djahandarie> Haha
10:29:19 <mux> dejavu is a nice all around font imo, but I like consolas/inconsolata much better for monospace
10:29:20 <djahandarie> I see that one
10:29:31 <kmc> Amadiro, it does
10:29:34 <maltem> Amadiro, -Wall will do that (among other things)
10:29:39 <Amadiro> Ah, thanks.
10:29:51 <kmc> btw occasionally it is wrong
10:29:53 <EvanR-work> gnu unifont
10:29:58 <kmc> and will say nothing was used from a module when this is not true
10:30:03 <kmc> but maybe this bug was fixed in 6.12?
10:30:09 <djahandarie> @let ☻ = ☺
10:30:09 <lambdabot>   Parse error: VarSym "\9787"
10:30:16 <djahandarie> @let _ ☻ = ☺
10:30:16 <lambdabot>   Parse error: Equals
10:30:26 <kmc> @let (☻) = (☺)
10:30:27 <lambdabot>  <local>:26:6: Not in scope: `☺'
10:30:32 <djahandarie> Oh heh
10:30:38 <djahandarie> Would need quotes
10:30:49 <kmc> > "☻" == "☺"
10:30:50 <lambdabot>   False
10:30:56 <djahandarie> Racist!
10:31:02 <benmachine> lol
10:31:05 <kmc> > "☻" > "☺"
10:31:06 <lambdabot>   True
10:31:07 <egor_tensin> hah
10:31:09 <djahandarie> Bahaha
10:31:11 <mauke> kmc++
10:31:11 <EvanR-work> lmao
10:31:17 <_minoru> lambdabot, 少しだけ俺様と会話をして下さい
10:31:21 <egor_tensin> pretty right, lol
10:31:28 <EvanR-work> ☻ looks white on my screen
10:31:34 <jesusabdullah> It looks like all question marks for me
10:31:39 <jesusabdullah> It's actually kinda awesome
10:31:42 <jesusabdullah> Like, I see
10:31:43 <kmc> @vixen 少しだけ俺様と会話をして下さい
10:31:44 <lambdabot> yeah, why not?
10:31:47 <jesusabdullah> lambdabot, ???????????????????????
10:31:47 <lambdabot> Unknown command, try @list
10:31:47 <egor_tensin> EvanR-work: your screen does not like blacks?
10:31:48 <djahandarie> lol
10:31:59 <jesusabdullah> you there! ?????????????????
10:31:59 <EvanR-work> egor_tensin: and ☺ is black
10:32:01 <jesusabdullah> hehehe
10:32:01 <benmachine> egor_tensin: reverse video
10:32:16 <mauke> so I heard you like question marks
10:32:21 <mauke> ?¿;՞؟፧᥅⁇⁈⁉≟⸮㉄꘏꛷﹖？󠀿⍰⩻⩼⳺⳻︖
10:32:21 <lambdabot> Unknown command, try @list
10:32:23 <egor_tensin> ok, quite weird
10:32:27 <kmc> i guess technically ☻ is "filled face" and "☺ is "outline face" or whatever
10:32:37 <kmc> and so color depends on context
10:32:38 <_minoru> djahandarie, 日本語はもう何年間？　又、日本語能力試験は何級？
10:32:41 <egor_tensin> i mean, from racism point
10:32:42 <kmc> like any glyph
10:33:39 <djahandarie> _minoru, 何級? Geometric series? O.o
10:34:03 <_minoru> djahandarie, I refer to Japanese Language Profiency Test
10:34:10 <djahandarie> Ah JLPT
10:34:22 <djahandarie> I can only speak some Japanese
10:34:37 <mauke> me too ("desu")
10:34:57 <djahandarie> I was actually in Japan about 2 weeks ago
10:34:58 <benmachine> what does that even mea
10:34:59 <benmachine> n
10:35:11 <mauke> that is the question
10:35:18 <benmachine> what's the answer
10:35:40 <djahandarie> benmachine, "desu" has two meanings... one is a copula, the other is "please kill me because I'm a white foreigner"
10:35:49 * benmachine giggles
10:35:50 <benmachine> noted
10:36:05 <benmachine> black foreigners don't say it?
10:36:08 <jesusabdullah> a cupola?
10:36:12 <jesusabdullah> :S
10:36:13 <djahandarie> Absolutely not, that'd be very rude.
10:36:36 <djahandarie> jesusabdullah, a word used to link a subject and a predicate...
10:37:08 <mauke> it's commonly used to link a desu and another desu
10:37:25 <benmachine> :P
10:37:45 * maltem likes how arigatou (?) resembles alligator
10:38:28 <desu> don't link me with someone else D:
10:39:02 <benmachine> not even two copies of yourself?
10:39:38 <djahandarie> maltem, that'd be アリゲーター　or arigeetaa :P
10:40:00 <mauke> only if you follow the english pronunciation
10:40:05 <djahandarie> maltem, or "wani" in japanese...
10:40:10 <djahandarie> And hi desu
10:40:38 <desu> Hi djahandarie
10:40:40 <billy> new comer, test
10:40:42 <desu> Long time no see D:
10:40:51 <djahandarie> Uhhuh
10:41:06 <desu> How's it hanging?
10:41:26 <pastorn> aavogt: i won't be having any more interwebz today, we'll have to discuss what constitutes the need for a typeclass later
10:41:29 <kmc> hi billy
10:41:30 <pkrumins>  
10:41:36 <djahandarie> desu, dunno, fine, was in Japan earlier. :P
10:41:48 <pastorn> aavogt: (i'll just have this for another 10 minutes)
10:42:18 <billy> how do i load Char module from within ghci, thx
10:42:32 <Twey> Huh
10:42:42 <Twey> Until billy, I thought this was ##japanese I was reading
10:42:43 <djahandarie> billy, import Data.Char should work fine
10:42:43 <kmc> :m + Char
10:42:46 <dafis> billy: either :m +Data.Char or import Data.Char, both work
10:42:47 <djahandarie> billy, or you could do :m + Data.Char
10:43:16 <djahandarie> Twey, I've made that mistake so many times, except the opposite way around because people keep talk about programming in ##japanese
10:43:21 <djahandarie> talking*
10:43:25 <Twey> Hehe
10:43:32 <desu> djahandarie, ah, sounds fun :P
10:43:39 <Twey> But they don't speak with nearly as much authority as in #haskell :þ
10:43:44 <billy> thx a lot djahandarie and dafis, I missed the "Data." part
10:43:46 <mauke> @let desu x = fmap x
10:43:48 <lambdabot>  Defined.
10:43:52 <djahandarie> Haha
10:44:38 <benmachine> billy: Char and Data.Char both exist, but I think Data.Char has more stuff
10:44:41 <desu> Lol
10:44:48 <gwern> Char is restricted by the Report
10:44:55 <gwern> is it not?
10:45:15 <benmachine> probably
10:45:30 <mauke> transfinite chars plz
10:45:50 <benmachine> ∞
10:46:01 <kmc> > "∞" > "7"
10:46:02 <lambdabot>   True
10:46:36 <djahandarie> lol
10:47:15 <c_wraith> Huh.  Text.XML.Light parses *anything* into an xml tree.
10:47:30 <benmachine> that sounds fun
10:47:39 <kmc> @check \x y -> (x > y) == ((>) `on` show) x (y :: Int)
10:47:40 <lambdabot>   "Falsifiable, after 24 tests:\n-1\n-2\n"
10:48:05 <djahandarie> :t on
10:48:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:48:06 <billy> benmachine - thx. i was trying to get toUpper
10:48:17 <kmc> @check \x y -> (x > 0 && y > 0) ==> (x > y) == ((>) `on` show) x (y :: Int)
10:48:18 <lambdabot>   No instance for (Test.QuickCheck.Testable
10:48:18 <lambdabot>                     (Test.QuickCh...
10:48:32 <aavogt> > "12" > "9"
10:48:32 <lambdabot>   False
10:49:56 <djahandarie> > "88" > "79"
10:49:57 <lambdabot>   True
10:50:25 <Phyx-> > id
10:50:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:50:26 <lambdabot>    arising from a use of `...
10:50:31 <Phyx-> :(
10:50:35 <Phyx-> still not back
10:50:45 <benmachine> hm?
10:50:49 <djahandarie> > id 1
10:50:50 <lambdabot>   1
10:51:05 <Phyx-> benmachine: it used to print out the shape of the functions
10:51:16 <Phyx-> like id it would print () -> ()
10:51:52 <benmachine> > id :: () -> ()
10:51:53 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
10:51:53 <lambdabot>    arising from a use of...
10:51:55 <benmachine> oh
10:52:01 <hpc> > show id
10:52:02 <benmachine> I guess there's a new instance
10:52:02 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:52:02 <lambdabot>    arising from a use of `...
10:52:10 <benmachine> due to Num (a -> b)
10:52:18 <djahandarie> Hm
10:52:18 <benmachine> or something
10:52:20 <hpc> > show (id :: () -> ())
10:52:20 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
10:52:20 <lambdabot>    arising from a use of...
10:52:36 <djahandarie> > ((*) - (**)) 4 5
10:52:37 <lambdabot>   -1004.0
10:53:02 <djahandarie> Hm I think I need to figure out how long it's going to take me to go to Boston
10:53:38 <alip> vty question: I'm running this: http://paste.pocoo.org/show/223268/ after the first update everything is displayed correctly, but when i pass the same characters via command line, weird characters are displayed instead, why?
10:55:00 <djahandarie> 1hr 40 mins... That'd give me 20 minutes to get in my car, get out of it, find the place, etc. hmm
10:55:53 <kmc> djahandarie, coming to Boston Haskell? :)
10:55:54 <McManiaC> is it possible to use the same record field names for two different constructors?
10:56:02 <kmc> McManiaC, of the same data type, yes
10:56:08 <McManiaC> data Foo = Foo { moep :: String } | Bar { moep :: String }
10:56:18 <kmc> McManiaC, they must have the same type
10:56:23 <kmc> and if it's missing for some ctors
10:56:33 <McManiaC> ah
10:56:37 <kmc> then you will get a run-time error on those :(
10:56:57 <hpc> :( runtime errors
10:57:00 <kmc> this is a handy way to avoid some boilerplate but the cure can be worse than the disease
10:57:49 <hpc> records are best used for data with only one constructor
10:58:25 <cwb> BONUS: First of all, thank you for your lovely book -- I'm really enjoying it. I look forward to the upcoming monad chapter!
11:00:28 <cwb> BONUS: Minor typo: In the input-output chapter, you say we used getCurrentDirectory, but the example didn't, and the comment seems to contradict the preceding paragraph. My guess is you meant to use getCurrentDirectory, but didn't update the example/text.
11:00:51 * jesusabdullah wants the monads chapter too
11:01:27 <Phyx-> @src print
11:01:27 <lambdabot> print x = putStrLn (show x)
11:01:36 <Phyx-> @where print
11:01:36 <lambdabot> I know nothing about print.
11:01:47 <benmachine> print is in Prelude
11:02:27 <Twey> Also System.IO
11:02:41 <benmachine> also that
11:02:59 <Phyx-> benmachine: yeah I know, but since prelude is a collection of modules, I wanted to know the *actual* source of it
11:03:08 <BONUS> cwb: ah, right! that's what happened yeah, i used getCurrentDirectory before but then removed it in the code, forgot to remove the reference in the text
11:03:11 <BONUS> thanks for pointing that out
11:04:31 <cwb> BONUS: Glad I could help a bit.
11:07:06 <c_wraith> oh, hey.  I really wanted parseXMLDoc.  It can fail to parse a string.  that's much better.
11:08:03 * edwardk just realized that he's been going about the whole gradient thing all wrong, and there is a much easier solution
11:08:03 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:08:36 <edwardk> preflex: xseen kmc
11:08:36 <preflex>  kmc was last seen on freenode/#ghc 4 minutes and 1 second ago, saying: i found the "Building/Porting" wiki page; anything else i should know?
11:08:43 <djahandarie> kmc, yeah
11:08:46 <edwardk> kmc: 10-20 typically
11:09:51 <edwardk> The problem I was having is that my tower of dual numbers is only tracking a single derivative at each level, but if I want to compute the gradient using forward mode I need n different derivatives for each derivatives... that is just an 'f'-branching stream!
11:10:36 <djahandarie> edwardk, a what?
11:11:13 <edwardk> so if i replace data Tower = Tower [a] -- as an AD mode with just Stream f a = a :< f (Stream f a) -- where f is the shape of the input to my gradients function i can compute a tower of gradients
11:11:43 * djahandarie needs to go figure out what a gradient is
11:11:48 <edwardk> djahandarie: an f-branching stream is also known as a cofree comonad.
11:12:16 <edwardk> the gradient of a function f(x,y,z) = something -- is the vector of partial derivatives of the inputs with respect to the output
11:12:24 <EvanR-work> i would rather a coffee comonad
11:12:30 <EvanR-work> at the moment
11:12:30 <edwardk> it generalizes to the 'jacobian' matrix when you have multiple outputs
11:12:36 <kmc> thanks edwardk
11:12:47 <edwardk> which is the matrix of partial derivatives of each input with respect to each output
11:12:53 * BMeph likes his cofree comonads with sugar and a croissant...
11:14:22 <djahandarie> edwardk, what would a tower of gradients be?
11:15:01 <edwardk> djahandarie: so grad (\[x, y] -> x * y) [1,2] = [2,1]
11:15:39 <edwardk> grad (\[x] -> sin x) [0] = cos 0 = 1
11:15:49 <edwardk> well, what are the second derivatives?
11:16:03 <edwardk> you need a n x n matrix of them.
11:16:13 <edwardk> and then the third derivatives an n x n x n tensor, etc.
11:17:09 <kmc> cofreedom isn't cofree
11:17:22 <edwardk> "automatic differentiation for (co)free" ;)
11:17:24 <djahandarie> So a tower would be like a continuously higher-order tensor of all the derivatives?
11:17:28 <edwardk> yeah
11:17:41 <edwardk> i can represent it using two different forms.
11:18:22 <edwardk> either data Tensors f a = a :- Tensors f (f a) ~ a :- f a :- f (f a) :- f (f (f a)) :- ...
11:18:42 <edwardk> or data Stream f a = a :< f (Stream f ) = a :< f (a :< f (a :< ...))
11:18:57 <edwardk> the latter subsumes the former, you can go from Stream f to Tensors f but not always back
11:19:10 <edwardk> er data Stream f a = a :< f (Stream f a)
11:19:23 <djahandarie> Nifty
11:20:03 <mornfall> That's one angry stream.
11:20:56 <edwardk> mornfall: heh well, mauke make Tensors look sad the other day IIRC withL data f :- a = a :-( f :-( f a )) 
11:21:05 <mornfall> :))
11:21:06 <djahandarie> Heh
11:22:20 <edwardk> anyways it went from mind bendingly difficult to figure out gradients to easy with a shift in perspective.
11:22:29 * edwardk er.. well, boings.
11:23:04 <edwardk> kmc: all set for your talk tonight?
11:23:16 <kmc> i hope so :)
11:23:29 <edwardk> i won't have any recording equipment with me, but i think for the next session after this i'd like to put something in place.
11:23:40 <kmc> makes sense
11:23:50 <cwb> BONUS: s/todo\.xt/todo.txt/ in the input-output chapter.
11:23:52 <kmc> i can put the slides online anyway
11:23:53 <djahandarie> Does that parking lot on the same road ever have free spots?
11:23:57 <kmc> and they're reasonably self-contained
11:24:12 <zygoloid> cwb: crikey, that's a good way to get noticed :)
11:24:14 <BONUS> cwb: aaah, nice
11:24:27 <kmc> i am appreciative of self-contained slides after sleeping through many lectures as an undergrad
11:24:37 <edwardk> heh
11:24:40 <cwb> BONUS: Ooops, I meant that to say substitute todo.xt for todo.txt in the input/output chapter.. Sorry.
11:24:57 <edwardk> i try to make slides that serve both audiences, but it tends to result in something that is fairly wordy 
11:25:07 <BONUS> cwb: yeah, i'm a vim user so i understood :)
11:25:50 <cwb> BONUS: Oh, did it print the whole thing.. ? It only showed up as "s/t" to me..
11:26:16 <BONUS> saw the whole thing, only the part you didn't see had a different background color to me. terminals and irc clients are strange
11:26:34 <noteed> cwb: here your text is blinking
11:26:38 <kmc> yeah
11:27:07 <kmc> people at the talk can hear me explain, and people reading later can google things more easily
11:27:10 <kmc> or ask here ;)
11:27:11 <cwb> Aha.. Sorry, let me see if I can fix that..
11:27:34 <wlangstroth> kmc: I missed it - what's the talk on?
11:27:46 <oingo> any haskell.org administrators around? specifically, bugs.haskell.org?
11:28:01 <kmc> wlangstroth, concurrency
11:28:36 <wlangstroth> I take it the answer is not "use Clojure"? (hehe)
11:28:53 <kmc> forkIO, MVar, Chan, and some tricks you can play with them
11:28:53 <kmc> i hope it's fairly beginner-friendly, although we will hopefully get through a lot of code
11:28:54 <kmc> hehe
11:28:54 <kmc> that might be the answer but it's outside the scope of my talk ;)
11:29:06 <kmc> Haskell and Clojure have pretty similar approaches to concurrency, afaik
11:29:13 <kmc> at least compared to most other languages, where the approach is best summarized as "durr"
11:29:34 <edwardk> wlangstroth: kmc is talking about concurrency, and nirav will be talking about a monad he built that marshals data back and forth to an external SMT solver.
11:29:47 <edwardk> As I have a similar one for a simpler solver, I'm very keen on that talk as well =)
11:29:51 <oingo> well, if there are -- you need to redeploy bugs.haskell.org at once, because you're still compromised and it's being used to attack other networks
11:30:06 <kmc> clojure might not be "pure" in the specific technical sense of Haskell, but if you listen to Rich Hickey talk about value, identity, and state, it's clear that he Gets It
11:30:07 <oingo> if someone could point me at an admin, that'd be super
11:30:23 <kmc> yikes
11:30:31 <edwardk> oingo: try to see if you can ping igloo on #ghc ?
11:30:34 <oingo> thanks
11:30:42 <edwardk> oingo: thanks btw =)
11:30:57 <portnov> @hoogle installHandler
11:30:58 <lambdabot> No results found
11:31:01 <oingo> no problem
11:31:02 <wlangstroth> kmc: immutability is a Good Start
11:31:07 <edwardk> there we go, trac'ing bugs all over the place.
11:31:54 <kmc> both Clojure and GHC Haskell have an emphasis on STM although my understanding is the implementations differ significantly
11:31:59 <kmc> (Clojure's STM has more locking)
11:32:01 <zakwilson> kmc: both have the general approach of "make things immutable", but Haskell doesn't really have a specific answer for concurrent state built-in. Instead, there are several options offered as libraries.
11:32:21 <MacMagnus> the "getFileSize"-function in chapter 9 in "real world haskell" wont compile... how do work around this? :)
11:32:26 <kmc> well, define "built in"
11:32:28 <wlangstroth> that was my understanding too (although I'm just learning Haskell's approach)
11:33:10 <zakwilson> kmc: also, STM isn't the first trick one should pull out of the bag in Clojure, but the last (it's only for synchronized state changes)
11:33:15 <jkingkong> Question: when I put an element in Data.Map with the form (foo [0,0],bar) say, the map reports the element as (,bar). Any ideas on why it's doing this?
11:33:17 <edwardk> zakwilson: we have lots of primitives for dealing with bits and pieces of multithreaded state.
11:33:54 <jkingkong> I don't even no what (,bar) means really
11:33:54 <wlangstroth> Clojure's is like doing all the smart Java concurrency stuff, but as zakwilson puts it, it's the last trick in the bag
11:33:59 <jkingkong> \no/know
11:34:08 <kmc> my operational definition of "built in" for Haskell is the Platform
11:34:08 <kmc> but there are still several options
11:34:08 <kmc> ok zakwilson
11:34:08 <kmc> the same is probably true in Haskell
11:34:10 <kmc> the options are pretty necessary at present imo, because the cost of STM (implemented the way GHC does) is extremely variable
11:34:18 <kmc> sometimes locking is preferable
11:34:31 <wlangstroth> ... like if you're on the JVM
11:34:33 <benmachine> jkingkong: weird Show for foo?
11:34:35 <c_wraith> Haskell's STM is horrible when there's high contention.
11:34:39 <jkingkong> i should say (Foo [0,0], bar)
11:34:56 <djahandarie> c_wraith, as opposed to STM in general?
11:35:00 <edwardk> sadly while lock-free STM is theoretically viable, in practice, the locky version tends to outperform it
11:35:11 <zakwilson> "built in" means, at a minimum that you don't have to download a library. There's one clear Right Way to do it.
11:35:18 <kmc> right
11:35:19 <kmc> STM doesn't imply lockless / optimistic
11:35:30 <c_wraith> djahandarie, The reason haskell's performs so badly under contention is that it uses an optimistic approach.  But that's not a requirement of STM
11:35:36 <jkingkong> benmachine, wow gosh I'm an idiot
11:35:36 <edwardk> zakwilson: many of those are in base and implemented as language primitives.
11:35:40 <jkingkong> as usual
11:35:48 <kmc> zakwilson, you don't need to download a library in Haskell, presuming you already have the Platform
11:35:53 <wli> edwardk: Probably depends on how many CPU's are involved too. I'll bet lockfree starts winning eventually with enough CPU's.
11:35:58 <jkingkong> i thought ghci was doing something weird with XTupleSections or something
11:36:00 <c_wraith> djahandarie, the semantics of STM are independent of the implementation
11:36:01 <kmc> there's no one clear Right Way, there are two or three
11:36:02 <jkingkong> haha
11:36:02 <benmachine> heh
11:36:13 <jkingkong> benmachine:thanks
11:36:14 <zakwilson> Clojure, as I understand it uses a lot of write locks, but doesn't lock reading.
11:36:20 <kmc> also, Haskell has parallelism without concurrency
11:36:20 <kmc> also built into Platform
11:36:21 <benmachine> np
11:36:22 <edwardk> wli: well, lockfree starts winning for _somebody_ with enough CPUs. ;) if it was wait-free...
11:36:54 <zakwilson> kmc: I don't have the Platform. I don't think there was a Linux release last time I updated GHC.
11:36:58 <edwardk> kmc: well, Chan and MVar are right smack dab in base.
11:37:07 <edwardk> kmc: so you don't even need to go out to the platform
11:37:13 <kmc> ah zakwilson
11:37:16 <cwb> noteed: is all the text I type blinking or just the message I sent before?
11:37:27 <kmc> Platform has been around a while now
11:37:33 <kmc> and before that, more stuff was in base
11:37:42 <edwardk> zakwilson: you can get it now, but you need to stop a page before the ubuntu minutiae that links to the wrong package
11:37:43 <kmc> and as edwardk pointed out, Chan and MVar still are
11:38:04 <noteed> cwb, no, just the text after s/t
11:38:17 <cwb> noteed, ok, thanks!
11:38:54 <zakwilson> kmc: I think that's the important difference between Haskell's concurrency and Clojure's. There IS a Right Way in Clojure (atoms, agents and STM) while Haskell offers more options. Both approaches have their merits (Clojure is probably easier to get started with, but Haskell offers more flexability)
11:39:22 <kmc> err that sounds like three Right Ways to me
11:39:27 <kmc> atoms, agents, and STM
11:39:38 <edwardk> STM is an interesting starting point, but the interesting parts are all the things that tend to be left unsaid, i.e. what is your conflict resolution strategy, etc. locks or no locks? there turns out to be a lot of interesting points in the design space. Herlihy has made a bit of a cottage industry out of exploring them
11:39:51 <aristid> @hoogle perm
11:39:51 <lambdabot> module Text.Parsec.Perm
11:39:51 <lambdabot> module Text.ParserCombinators.Parsec.Perm
11:39:51 <lambdabot> System.IO.Error permissionErrorType :: IOErrorType
11:40:23 <kmc> "atoms, agents, and STM" to me sounds very much like "MVar, Chan, and STM"
11:40:28 <kmc> but i'm no clojure expert
11:40:40 <edwardk> kmc: yeah
11:40:48 <kmc> i'm sure there are distinctions
11:41:01 <kmc> but they sound roughly as flexible / Right Way ish
11:41:59 <kmc> there are 3rd-party libraries building on these things in Haskell but i'd assume clojure has the same
11:42:10 <zakwilson> Atoms and agents are not MVars and Chans.
11:42:38 <kmc> how does Clojure provide less flexibility?
11:42:45 <kmc> i don't claim there is a 1-1 correspondence
11:43:34 <zakwilson> I suppose it doesn't, strictly speaking. You could implement new and interesting concurrency control constructs and/or lower-level constructs than what the language gives you, but people don't.
11:44:03 <kmc> what i like about Haskell's concurrency support (and what the talk tonight is about) is how much stuff you can implement in terms of those few primitives
11:44:07 <kmc> the same goes for exception handling, btw
11:44:09 <zakwilson> And my impression is that people do in Haskell. I will admit to knowing Clojure better than Haskell.
11:44:12 <kmc> we'll have a couple examples combining the two
11:44:32 <zakwilson> Will your talk be recorded and put on the web?
11:44:39 <kmc> and i don't know what the situation is in Clojure, but there seems to be a similar emphasis on composability
11:44:44 <kmc> zakwilson, slides at least
11:44:52 <kmc> and they should be comprehensible without the audio
11:44:55 <kmc> you can always ask here ;)
11:45:16 <edwardk> zakwilson: sadly i won't have recording equipment set up before the following meeting
11:45:34 <wlangstroth> Clojure carries over Lisp's emphasis on composability
11:45:54 <wlangstroth> Haskellites would like Clojure's mounting collection of operators
11:46:05 <kmc> edwardk, i'd really like to see a clever adaptive STM implementation that discovers contention and inserts locking
11:46:09 <kmc> i wonder if this is feasible
11:46:17 <kmc> i'd be interested to hear more about this design space of STM implementations
11:46:29 <kmc> i'm not sure that old-school Lisp can be said to emphasize composability
11:46:43 <wlangstroth> kmc: okay, good point
11:46:46 <edwardk> kmc: hrmm, well, let me see if i can find herlihy's material on the topic for you
11:46:49 <kmc> from what i've seen there tends to be a lot of mutation thrown around
11:46:59 <jmcarthur> kmc: you mean instead of using an implementation that uses locking it statically determines where to insert locks selectively?
11:47:03 <kmc> and macros aren't very composable
11:47:06 <zakwilson> I don't think Clojure's reference types (atom, agent and ref) really emphasize composability.
11:47:10 <kmc> jmcarthur, i was thinking dynamically
11:47:15 <edwardk> kmc: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.126.9568 might serve as a starting point
11:47:17 <kmc> you start with the lockless optimistic implementation
11:47:26 <jmcarthur> kmc: oh by profiling?
11:47:37 <kmc> and if you notice two threads contending a lot, you improvise some way for them to get out of each other's way
11:47:52 <kmc> which might be like conventional locks or might be something cleverer
11:48:12 <kmc> basically, you make JITish traces of STM actions
11:48:20 <jmcarthur> ah
11:48:21 <edwardk> kmc: something like a java thin lock, which is expensive to inflate the first time
11:48:23 <kmc> and if one guy is about to enter a trace that you know will conflict with a running transaction
11:48:26 <kmc> you can just delay him
11:48:59 <jmcarthur> so you just mean some generic transaction scheduler
11:49:01 <kmc> thanks edwardk
11:49:27 <kmc> yeah
11:49:43 <kmc> ideally a drop-in replacement for the STM part of GHC's RTS that is cleverer about contention
11:49:50 <jmcarthur> i've explored bringing some schedulers over from the RDBMS world into a haskell stm implementation. haven't gotten anything working yet. it's not quite what you are describing though
11:49:51 <wlangstroth> that's close to what Clojure does (modelled after postgres, if I remember right)
11:50:13 <kmc> cool
11:50:26 <wlangstroth> (but I'm not sure how much anticipation you're implying)
11:50:33 <kmc> i'm not sure either :)
11:50:37 <kmc> just a vague idea
11:50:45 <kmc> which i'm sure has been explored in detail by others already
11:50:53 <kmc> jmcarthur, good idea using the hard work of those DB people ;)
11:51:04 <edwardk> kmc: there used to be a lot more on http://msdn.microsoft.com/en-us/devlabs/ee334183.aspx but sadly microsoft's version of open source is to 'incubate' for a while then pull all the material off the internet
11:51:11 <jmcarthur> yeah, it's a very explored area
11:51:11 <kmc> right :/
11:51:38 <wlangstroth> I'm not sure at this point that Microsoft is holding onto any secrets
11:53:23 <edwardk> jmcarthur: interestingly i tried going the other way. i have some stm based database code lying around ;)
11:53:39 <jmcarthur> edwardk: stm based = optimistic?
11:53:56 <edwardk> but the dbms guys have a huge head start on models and data
11:54:13 <edwardk> yeah optimistic. it was for a column store so the existing rdbms literature was less applicable
11:54:20 <edwardk> and it worked fairly well
11:54:52 <wlangstroth> if you weren't constrained by acid, then optimistic would probably work really well hmmm
11:55:47 <edwardk> wlangstroth: exactly. i was working in a distributed column store. the acid properties are being maintained at a higher level than the individual chunk servers.
11:55:48 <geheimdienst> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
11:55:49 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
11:55:57 <burp> omg
11:56:12 <geheimdienst> ;-)
11:56:14 <geheimdienst> it's from http://uncyclopedia.wikia.com/wiki/Haskell
11:56:19 <edwardk> and for the most part isolation mattered little since i was using snapshots
11:56:26 <BMeph> burp: Yes, what is it? ;þ
11:56:38 <edwardk> @pl fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
11:56:38 <lambdabot> fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
11:56:46 <edwardk> @unpl fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
11:56:46 <lambdabot> fix ((((<$>) <$> ((:))) <*> ((((\ d e -> e >>= d) <$> \ a -> return <$> a) <$> (*)) <$> \ b -> 2 * b)) 1)
11:56:46 <jesusabdullah> I like the haskell/HL box
11:56:58 <edwardk> @pl fix ((((<$>) <$> ((:))) <*> ((((\ d e -> e >>= d) <$> \ a -> return <$> a) <$> (*)) <$> \ b -> 2 * b)) 1)
11:56:58 <lambdabot> fix ((((<$>) <$> (:)) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
11:57:06 <edwardk> aw it is a fixpoint
11:57:38 <wlangstroth> edwardk: nice - I didn't even think of column stores, because I'm always on rdbms
11:57:47 <BMeph> I'd love to see a "Try Habit" site up by next year. Of course, I doubt I'll help it any, but I'd still like to see it.
11:58:49 <jkingkong> is there an easy way to keep track of different variables and such for debugging purposes?
11:59:07 <jkingkong> printing a variable in the middle of a function is obviously not ideal
11:59:43 <BMeph> Oh, just a general request: what would be a good symbol for flipped application that 1) is tolerable to Haskeliers in general; 2) Doesn't make OO programmers run away, screaming warnings of the Old Ones' return? ;)
11:59:47 <edwardk> @type trace
11:59:48 <lambdabot> Not in scope: `trace'
11:59:50 <noteed> jkingkong: there is Debug.Trace.trace
11:59:52 <edwardk> @type traced
11:59:52 <lambdabot> Not in scope: `traced'
12:00:14 <edwardk> @type (<**>) 
12:00:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:00:27 <edwardk> is a flipped ap that also reorders the side effects to keep them l to r
12:00:28 <BMeph> @ty Debug.Trace.trace
12:00:29 <lambdabot> forall a. String -> a -> a
12:00:46 <jkingkong> ah ok
12:00:48 <jkingkong> thanks
12:01:11 <BMeph> edwardk: That last one was for me? :)
12:01:24 <edwardk> BMeph: but one that flops the order of side effects and is equivalent to flip (<*>) doesn't exist and probably shouldn't have a standard name as it violates the 'easy to think about rule' that you can read applicative code with side effects from l-to-r
12:01:35 <edwardk> BMeph: yeah
12:02:19 <byorgey> jkingkong: there is also Hood, which is quite nice
12:03:56 <byorgey> jkingkong: http://www.ittc.ku.edu/csdl/fpg/Tools/Hood
12:04:49 <BMeph> edwardk: That might work. I would want l-to-r effects prop6n anyway - I'm trying to translate William Cook's "On Data Abstraction, revisited" examples into Haskell, and working on the OO bits, I want a notation that I won't confuse with something else, but that my OO-imbibing friends will also recognize. Thanks! :)
12:05:03 <edwardk> ah
12:05:33 <edwardk> then (<**>) is all you need ;)
12:05:35 <wlangstroth> Any of you know if the code for 'Monad Transformers and Modular Interpreters' (1995) has been ported to Haskell other than in HJS?
12:06:19 <wlangstroth> (not really expecting an answer, just a shot in the dark)
12:06:20 <edwardk> wlangstroth: yes. i have much of it in category-extras
12:06:38 <wlangstroth> edwardk: you're my hero
12:06:47 <edwardk> there is code in there for describing distributive laws between monads and pointed functors, and building monads out of their compositions
12:07:17 <marcog> hey, i'm having troubles trying to install xmobar via cabal on hardy; it complains about requiring base 4, so i upgraded ghc to 6.12 from the ghc site and now cabal says "failed to parse output of 'ghc-pkg dump'"
12:07:33 <edwardk> you have to juggle a lot of machinery to make it work though
12:08:01 <wlangstroth> edwardk: that's okay, I just need to see a decent implementation. Thanks.
12:08:10 <sclv> you might need to upgrade your cabal
12:08:32 <marcog> sclv: this is where i get that failed to parse error from
12:08:35 <sclv> which is a bit of a pain given that you just broke the easiest way to upgrade it :-)
12:08:40 <marcog> marcog@marcog:~$ cabal install cabal-install
12:08:40 <marcog> cabal: failed to parse output of 'ghc-pkg dump'
12:08:51 <sclv> you can give it options to use a different version of ghc-pkg
12:08:54 <sclv> and ghc itself
12:09:05 <marcog> it didn't work with the older ghc
12:09:07 <sclv> or you can just hand-compile it (i know, yech)
12:09:16 <marcog> complained about the base 4 dependency
12:09:18 <sclv> also you can just install the platform
12:09:38 <marcog> install the platform??
12:09:56 <sclv> http://hackage.haskell.org/platform/
12:09:59 <sclv> should give you a cabal binary
12:10:20 <sclv> oh wait -- for hardy you need the source installer
12:10:21 <edwardk> wlangstroth: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Pointed-Composition.html is the basic building block for different means of functor composition. that has pointed/copointed functor composition. not sure where the monad stuff went
12:10:47 <sclv> nonetheless, it should handle giving you cabal & the stdlibs with only the pain of a build process
12:10:55 <marcog> sclv: if i compile from source, will i need any dependancies?
12:11:21 <sclv> compiling the platform from source is designed to take place over a vanilla ghc install
12:11:33 <edwardk> wlangstroth: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Extras.html#t%3ADist has the basic Dist for distributive laws and there are three classes in there that provide the forms of distributive laws used by Mark P Jones.
12:11:35 <sclv> so i don't think it even tries to pull in anything from hackage
12:11:50 <marcog> i mean dependancies required to compile the platform
12:12:07 <edwardk> (and two others that only show up when doing similar operations to derive comonads from copointed functor compositions)
12:12:16 <kmc> hmm marcog maybe you can grab a cabal-install tarball off hackage
12:12:41 <edwardk> i mostly abused the Dist machinery in the Control.Morphism code to make higher order recursion schemes
12:12:41 <sclv> marcog -- i think you need a libglut-dev package at least
12:12:53 <sclv> might be a few others -- they'll be obvious from build errors :-)
12:14:07 <sclv> you can also just bootstrap cabal from here: http://www.haskell.org/cabal/download.html
12:14:13 <sclv> but you'll want the platform eventually
12:19:13 <wlangstroth> edwardk: already reading the code - very nice - thanks again
12:22:21 <cwb> Potential bug: random (mkStdGen 99) :: (Float, StdGen) gives me a segmentation fault in ghci on Mac OS X, could I be doing something wrong or should I report this somewhere?
12:22:50 * geheimdienst has to admit that between the platform, cabal packages, and native distro packages, which may all hold conflicting versions, it's easy to be confused what you're supposed to install. especially for newbies -- sorry for the inconvenience, marcog. but the platform is probably a step in the right direction.
12:23:11 <sclv> cwb: sounds like a bad install
12:23:42 <sclv> or bad linking. are you using macports?
12:23:56 <cwb> sclv: Yeah, I used MacPorts, attempting to upgrade now, but otherwise I'll install from source I guess.
12:24:16 * sclv never got macports to work properly
12:24:53 <geheimdienst> cwb, it might also be worth it to look at the output of ghc-pkg check
12:25:03 <sclv> as i recall, the os-x story is still somewhat hairy
12:25:21 <cwb> sclv: Noted, thanks. I'll install from source eventually then.
12:25:40 <sclv> the platform provides a one-click installer as well: http://hackage.haskell.org/platform/mac.html
12:25:52 <aristid> what's the difference between ^ and ^^?
12:26:04 <cwb> geheimdienst: ghc-pkg check gives no output.
12:26:06 <wlangstroth> the Haskell Platform is much easier for os x
12:26:07 <sclv> for 10.5 and intel only, though.
12:26:22 <earthy> it actually works splendidly on snow leopard
12:26:26 <sclv> :t (^)
12:26:26 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:26:30 <sclv> :t (^^)
12:26:31 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:26:38 <sclv> ^^ and that is the difference :-)
12:26:44 <cwb> sclv: Aha, that sounds like a better option then, will use that.
12:26:52 <earthy> unfortunately one has to be aware of the fact that the haskell platform on snow leopard will not build 64 bit binaries
12:26:59 <earthy> but rather 32 bit binaries
12:27:14 <earthy> this is not a large issue... but it is an issue.
12:27:20 <sclv> note that both are only to get you to integral powers
12:27:26 <sclv> and use repeated squaring
12:27:40 <sclv> you need ** for fractional exponentiation
12:28:14 <cwb> earthy: Thanks, that's very useful to know -- have been caught out by that before.
12:29:34 <sclv> > 2 ^ 2
12:29:35 <lambdabot>   4
12:29:40 <sclv> > 2 ^ (-2)
12:29:41 <lambdabot>   *Exception: Negative exponent
12:29:45 <sclv> > 2 ^^ (-2)
12:29:46 <lambdabot>   0.25
12:29:48 <sclv> :-P
12:29:52 <k23z__> > f = \x -> x^2
12:29:52 <lambdabot>   <no location info>: parse error on input `='
12:30:40 <mtnviewmark> gnabing
12:30:46 <mtnviewmark> bah
12:30:56 <noteed> @let f x = x^2
12:30:57 <lambdabot>  <local>:28:0:
12:30:57 <lambdabot>      Multiple declarations of `L.f'
12:30:57 <lambdabot>      Declared at: <local>:...
12:31:05 <mtnviewmark> well that's a fail
12:31:45 <marcog> sclv: can't get past this error when trying to setup the platform: http://pastebin.com/nqbuXCZ7
12:31:59 <marcog> and i do have libgmp3-dev installed
12:32:34 <Saizan> what does config.log say?
12:33:15 <marcog> http://pastebin.com/3pEj6hu9
12:33:29 <marcog> can't see anything useful there
12:36:50 <sclv> either /usr/local/bin/ghc isn't your current ghc or your current ghc is broken
12:37:46 <marcog> sclv: marcog@marcog:~$ /usr/local/bin/ghc --version
12:37:46 <marcog> The Glorious Glasgow Haskell Compilation System, version 6.12.1
12:38:11 <sclv> hmm -- look at this ticket and try the suggested fix http://hackage.haskell.org/trac/ghc/ticket/3794
12:39:25 <marcog> sclv: thanks! one step closer
12:39:27 <sclv> note i found this ticket by looking for the error on line 67 of the paste of yr. config log.
12:40:32 <marcog> ah i missed that
12:42:03 <marcog> busy compiling
12:43:39 <sinelaw> hi
12:48:52 <marcog> sclv: platform installed but i still get the same error when upgrading cabal: http://pastebin.com/mFjqURAf
12:50:28 <sclv> the platform should have installed a new cabal as part of the platform?
12:50:54 <dcoutts> sclv: perhaps you've got an old cabal on your $PATH
12:51:54 <sclv> not me, marcog :-)
12:52:08 <marcog> sclv: seems not http://pastebin.com/b6NSs8UB is what i get
12:52:57 <geheimdienst> the god of haskell sure is giving you a lot of trouble today :-(
12:53:06 <marcog> it is :(
12:53:16 <sclv> marcog: see dcoutts comment above. the platform should install a new cabal. but you might have another cabal sooner on your path.
12:53:32 <sclv> so you need to make sure that you find where the platform put your cabal, and make sure that is the real cabal you use
12:53:42 <mux> the god of haskell is lazy: he will eventually help you, but it must be for an absolutely vital need
12:54:01 <dcoutts> sclv: oops :-)
12:54:13 <sclv> answering prayers is a side effect -- the god of haskell is pure.
12:54:20 <danharaj> pray-by-need
12:54:40 <mux> I would have said miracle-by-need
12:55:08 <marcog> hmm, looking but atm there's only one binary i get in my path
12:55:18 <geheimdienst> the god of haskell is pure and does not have side-effects, hence nobody ever can detect him
12:56:04 <burp> LOL
12:57:19 * fryguybob_ gets up some courage to write some C++ for work...
12:57:29 <marcog> what's the latest version of cabal?
12:57:53 <marcog> it seems i have 0.6.2 binary but 0.8 docs
12:57:55 <marcog> this is odd
12:58:30 <byorgey> marcog: the latest version of cabal-install is 0.8.2, IIRC
12:58:32 <dcoutts> marcog: 0.8.4
12:58:35 <geheimdienst> marcog, you may have 2 versions installed side-by-side, and getting the old one when saying "cabal" at the command line
12:58:42 <byorgey> oh, there's a .4 release now? cool
12:59:09 <geheimdienst> try saying the absolute path, or maybe removing the old one through apt
12:59:17 <dcoutts> byorgey: or maybe I'm getting confused...
12:59:20 <sclv> alternately the platform may have failed to install the new cabal because it lacked permissions to overwrite the old one?
12:59:36 <dcoutts> byorgey: yes, first release was 0.8.0, second 0.8.2, sorry
12:59:37 <byorgey> the latest version of Cabal is 1.8.0.4
12:59:43 <byorgey> that's where the 4 is =)
12:59:49 <dcoutts> aye :-)
12:59:52 <marcog> http://pastebin.com/xtjPmcpa 
13:00:01 <marcog> that cabal binary is 0.6.2
13:00:10 <marcog> no other cabal files on my system
13:00:15 <marcog> and i just updated the db
13:00:25 <wlangstroth> fryguybob_: sorry, dude
13:00:59 <marcog> sclv: this is actually possible
13:01:00 <dafis> marcog: IIRC, cabal-0.6.* doesn't work with ghc-6.12, only with 6.10
13:01:26 <sclv> marcog: also note you can't always trust locate
13:01:36 <sclv> it runs an updatedb process in the background perioically
13:01:43 <sclv> but the newest stuff isnt necessarily there
13:01:43 <dafis> marcog: I suggest removing it, grabbing the 0.8.2 tarbal from Hackage and ./bootstrap.sh
13:01:51 <gwern> anyone know the estimates for GHC 6.14's release?
13:02:10 <marcog> dafis:kk, i'll give that a try
13:02:50 <Phyx-> hmm, are the even numbers always the release versions of GHC and the uneven the developement versions?
13:03:16 <dafis> Phyx-: Yes
13:03:45 <Phyx-> dafis: ah ok :)
13:03:46 <Phyx-> thanks
13:03:58 <Phyx-> was wondering about that for a while now
13:07:50 <user317> is there a way to run quickcheck in verbose mode from the commandline?
13:08:09 <user317> i cant seem to find those options anywhere on the net, and the binary doesn't have a help meny
13:08:21 <marcog> ok, getting some success
13:15:04 <marcog> success!
13:15:07 <Olathe> (^) is slow since it doesn't seq every possible thunk.
13:15:19 <marcog> thanks so much sclv and everyone else :)
13:15:20 <dafis> marcog: :D
13:16:18 * geheimdienst hits the god of haskell over the head with a monad transformer
13:16:31 <geheimdienst> take that, dipweed!
13:16:33 <sclv> glad to help -- getting up and running is always the most painful part of any haskell dev process for me.
13:16:48 <zachk> wouldnt that maybe be the n-God(s) of haskell? 
13:17:00 <sclv> (although, lots of hard knocks and the platform have started to change that -- thanks all who work on it!)
13:17:25 <wli> A monad transformer just blew up in my back yard.
13:17:44 <sclv> Olathe: I'm sure there's some strange corner case where a lazy (^) actually buys you something
13:18:04 <sclv> But I'd also think that the specialize pragmas on it would make it fairly quick for the common cases.
13:18:33 <sclv> since if it specializes to strict types then the strictness analyzer should be able to optimize those specialized versions
13:19:30 <dafis> sclv: Yes, I'd think so too
13:20:17 <dafis> and long ago, I've done some measurements and found it not slower than a fully strict version
13:20:44 <dafis> I can't remember whether it was in the days of 6.2 or 6.4, though
13:20:49 <Olathe> I wish they'd specialize it in GHC's Prelude, then.
13:21:06 <dafis> Olathe: What do you mean?
13:21:26 <Olathe> It's faster when I use my strict implementation.
13:21:33 <dafis> Olathe: A special function for types Int -> Int -> Int etc?
13:21:37 <pocketcoffe> 1,8:)1,12:)1,4:)1,13:)1,11:)1,9:)1 2 CiaoOoOo A TuTTo il ChaN!!!!!!!! 1,9 1,9(:1,11(:1,13(:1,4(:1,12,8 
13:21:37 <pocketcoffe> 1,8:)1,12:)1,4:)1,13:)1,11:)1,9:)1 2 Mo So Qua e nOn Me sKiodO piU'!! 1,9 1,9(:1,11(:1,13(:1,4(:1,12,8
13:21:44 <pocketcoffe> seraaaa
13:21:57 <tensorpudding> @where ops
13:21:57 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
13:22:00 <systemfault> Why does the channel doesn't have mode +c ?
13:22:03 <Raynes> Too much time on their hands.
13:22:06 --- mode: ChanServ set +o monochrom
13:22:06 <tensorpudding> oh too late
13:22:07 --- mode: ChanServ set +o Lemmih
13:22:23 <dafis> Olathe: That surprises me
13:22:30 --- mode: monochrom set +b *!*@89.148.146.*
13:22:36 --- mode: monochrom set -o monochrom
13:23:05 <systemfault> Ops... setting mode +c wouldn't be a bad idea..
13:23:19 <tensorpudding> What does +c mean?
13:23:31 <systemfault> Color filter.
13:23:37 <Raynes> No colors, IIRC.
13:23:38 <systemfault> http://freenode.net/using_the_network.shtml
13:23:50 <Raynes> I don't think there are anything wrong with colors. The problem is spammers.
13:23:53 <zachk> ok what would 3x3 list of lists of all the same item look like in a haskell list comprehension ? 
13:23:56 <Raynes> It would be just as annoying without the colors. :p
13:24:12 <monochrom> what Raynes says. this is just psychological.
13:24:48 <geheimdienst> > [replicate 3 x | x <- replicate 3 42]
13:24:49 <lambdabot>   [[42,42,42],[42,42,42],[42,42,42]]
13:24:54 --- mode: Lemmih set -o Lemmih
13:25:13 <zachk> ty geheimdienst
13:25:18 <Lemmih> Ah, I'm a mere mortal again.
13:25:19 <Zao> > replicate 3 . replicate 3 $ 42
13:25:20 <lambdabot>   [[42,42,42],[42,42,42],[42,42,42]]
13:25:37 <Zao> Is there a function that "squares a function"?
13:25:45 <monochrom> No.
13:25:52 <mux> type error
13:25:54 <dafis> > replicate 3 42 >>= replicate 3
13:25:55 <lambdabot>   [42,42,42,42,42,42,42,42,42]
13:25:57 <Zao> Take from iterate or something?
13:25:57 <geheimdienst> zao, isn't "on" something like that?
13:25:58 <monochrom> But I can square a circle.
13:26:08 <geheimdienst> @src on
13:26:09 <lambdabot> (*) `on` f = \x y -> f x * f y
13:26:11 <Zao> Oh right, types.
13:26:16 <Zao> Damn you, types!
13:26:19 <mux> oh, iterate f x !! 2
13:26:20 <dafis> > replicate 3 42 >>= return . replicate 3
13:26:21 <lambdabot>   [[42,42,42],[42,42,42],[42,42,42]]
13:26:35 <c_wraith> :t \f -> f . f
13:26:35 <lambdabot> forall b. (b -> b) -> b -> b
13:26:36 <mux> but you need iterate' which isn't in the base for that or it'll gobble memory up
13:26:40 <Botje> @pl \f x -> f (f x)
13:26:40 <lambdabot> join (.)
13:26:46 <Botje> ^^
13:26:46 <mux> well, not for !! 2 of course
13:26:51 <Zao> @pl \x -> x . x
13:26:51 <lambdabot> join (.)
13:27:24 <dibblego> @type join fmap
13:27:25 <lambdabot> forall a. (a -> a) -> a -> a
13:28:45 <maltem> @type join liftA2
13:28:45 <lambdabot> forall b c. ((b -> c) -> b -> c) -> ((b -> c) -> b) -> (b -> c) -> c
13:29:58 <maltem> @type join liftA2 (join fmap)
13:29:59 <lambdabot> forall c. ((c -> c) -> c) -> (c -> c) -> c
13:32:05 <c0sine> hey is it okay to give the same name to a type and value constructor?
13:32:26 <c0sine> or is that a bad thing to do
13:32:31 <maltem> c0sine, it's common praxis
13:32:47 <dafis> c0sine: Yes, but only if the type has only one constructor
13:32:47 <c0sine> okay, thank you
13:32:51 <c0sine> oh
13:33:05 <c0sine> well i'm just at a point where they're that simple right now
13:33:46 <c0sine> (in the book)
13:36:13 <Phyx-> does anyone know if the GhcMonad behaves like a Reader or a State monad?
13:37:08 <ezyang> It looks sort of like state + side effects 
13:37:13 <ezyang> http://hackage.haskell.org/packages/archive/ghc-mtl/1.0.0.0/doc/html/Control-Monad-Ghc.html 
13:37:44 <zachk> in ghci what :command do i use to show infix info on an operator? 
13:38:03 <aristid> @pl \f g -> (arr.uncurry) ($) <<< f &&& g 
13:38:03 <lambdabot> (&&&) . (arr (uncurry id) <<<)
13:38:06 <Phyx-> ezyang: hmm, that's odd, since when i modify the HscEnv the modification doesn't show up later in the call path
13:38:13 <c_wraith> zachk, :info (+) for instance
13:39:10 <zachk> c_wraith: what if it just shows the type signature? what infix is it 
13:39:35 <Phyx-> zachk: it shows fixity too
13:39:38 <c_wraith> If it doesn't show anything, it's the default...  Which I believe is infix 4 ?
13:39:53 <benmachine> infixl 9 is the default
13:40:01 <c_wraith> huh.  I was way off. :)
13:40:10 <benmachine> you had "infix" right :P
13:40:33 <djahandarie> Oh hmmm, somehow I neglected to leave time to eat dinner in my plans
13:40:43 <benmachine> whoops
13:40:55 <djahandarie> Haha
13:40:58 * Phyx- throws on his wizard hat and dives into ghc head first
13:41:15 <djahandarie> Phyx-, usually putting on your wizard hat means something else on IRC
13:41:24 <Phyx-> eh?
13:41:25 <Zao> Indeed.
13:41:33 <Phyx-> what would that be?
13:41:43 <BMeph> djahandarie: It's safe, his robe is still in the closet. ;)
13:41:44 <hpc> @where bash.org
13:41:44 <lambdabot> I know nothing about bash.org.
13:41:55 <djahandarie> lol
13:42:03 <BMeph> @google robe "wizard hat"
13:42:04 <lambdabot> http://www.albinoblacksheep.com/text/bloodninja
13:42:04 <lambdabot> Title: Text » Bloodninja
13:42:14 <BMeph> Enjoy... :D
13:42:21 * Phyx- looks
13:42:25 <djahandarie> nsfw
13:43:06 <aristid> @src when
13:43:06 <lambdabot> when p s = if p then s else return ()
13:43:11 <Phyx-> rofl, hahaahahha
13:43:23 <djahandarie> Heh yeah
13:43:30 <djahandarie> fyi :P
13:43:46 <Zao> @src unless
13:43:46 <lambdabot> unless p s = if p then return () else s
13:44:25 <djahandarie> Bah
13:44:40 <djahandarie> Maybe I'll just not go, its like a total of 3.5 hrs of driving anyways :-(
13:44:55 <geheimdienst> for more robe and wizard hat memeage, see http://www.lolcatpics.com/images/wizardcat.jpg and http://blag.xkcd.com/2008/02/27/ballpit-phase-ii/
13:45:22 <djahandarie> edwardk, schedule the next one on a weekend so I can hang out at MIT for the day :P
13:47:32 <edwardk> djahandarie: you almost had this one, but at the last minute there were a bunch of people who signed up on a weekday during the poll
13:47:36 * ksf can't stand that untypedness using fgl implies
13:47:42 <edwardk> djahandarie: make sure to answer the poll about the day though
13:48:15 <ksf> I've got different kind of nodes that can have different kinds and number of out-edges and I can't express those invariants with fgl
13:48:45 <edwardk> djahandarie: if your plans where to make it to boston haskell tonight, we do typically wander over to cambridge brewing company to eat/drink after
13:49:09 <ksf> in fact, most of the tree is a possibly cyclic binary tree with only one node that can have 1..n numbers of out-edges
13:49:16 <edwardk> djahandarie: and there are cookies/pie ;)
13:49:40 <djahandarie> edwardk, main issue is that I have work tomorrow so I can't hang around afterwards
13:50:15 <edwardk> djahandarie: where are you coming from?
13:50:23 <djahandarie> Storrs CT
13:50:26 <edwardk> ah
13:50:39 <ksf> does any of the generics libraries support graphs?
13:50:48 <edwardk> just drink an extra coffee or two in the morning ;)
13:50:53 <djahandarie> Yeah, it's not that far, but not exactly that close either lol
13:51:03 <djahandarie> lol I don't drink coffee
13:51:19 <edwardk> djahandarie: then it should have a very powerful effect tomorrow morning ;)
13:51:57 <Phyx-> hmmm wonder why ghc sometimes reports errors on empty spans. e.g. col 16 to 16 for instance
13:52:19 <djahandarie> I wouldn't drink it tomorrow morning so it'd actually have no effect. :P
13:53:32 <edwardk> i probably should have worked on ersatz this weekend instead of ad, since the former will probably make a lot more sense to folks after nirav gives his talk, but i was obsessed about the other problem =/
13:53:36 <Phyx-> hmm, If I load a module in using the ghc api, do dependency analysis, the module I actually loaded will always be the last one in the dependency graph wouldn't it?
13:53:57 <Phyx-> since unless you have a circular module, nothing you've loaded would depend on it no?
13:55:40 <Phyx-> anyone? :P
13:56:12 <edwardk> phyx not sure, what about mutual dependencies?
13:57:49 <wlangstroth> edwardk: I had no idea there was pomo for programming until I read your blog - "a histomorphism is a generalized catamorphism parameterized by the cofree monad of your functor"
13:58:08 <wlangstroth> awesome
13:58:18 <edwardk> pomo?
13:58:30 <wlangstroth> postmodernist theory
13:58:34 <Phyx-> edwardk: right, I meant that with circular module, should have named it better, I've changed the API to record this module when it first loads it
13:58:34 <edwardk> wlangstroth: hahaha
13:58:35 <kmc> weird for the sake of weird
13:58:46 <Phyx-> unfortunately it forgets it when it exits the function
13:58:54 <Phyx-> setSession doesn't seem to work as I expect it
13:59:06 <edwardk> kmc: yeah i'm familiar, just didn't expect postmodernism to come up in this context ;)
13:59:09 <Phyx-> or the function is called in an odd manner
13:59:30 <edwardk> wlangstroth: there are occasional uses for that level of baroque metatheory, but yeah, its pretty strange ;)
13:59:56 <edwardk> and isn't that a cofree comonad?
14:00:12 <wlangstroth> edwardk: see http://elsewhere.org/pomo
14:00:54 <edwardk> wlangstroth: what is even worse is that i generalized the generalized histomorphism to handle not only the cofree comonad of your functor but arbitrary levels of liftings into codensity comonads of the cofree comonad of your functor...
14:01:16 <edwardk> wlangstroth: yay for generalized abstract nonsense.
14:01:42 <geheimdienst> http://farm1.static.flickr.com/108/377484935_b4ee114483.jpg
14:01:48 <wlangstroth> edwardk: that's what my brain generalizes as "the surface"
14:02:22 <wlangstroth> (a three dimensional blanket that mathematically covers what you just said)
14:02:28 <zachk> why is "data Turn = Turn Int" malformed? 
14:02:38 <kmc> edwardk, and i was just quoting the simpsons ;)
14:03:00 <c_wraith> zachk, it's fine by itself.  check previous lines for errors
14:03:12 <zachk> ahhh yeap just saw that thanks c_wraith
14:03:27 <c_wraith> zachk, though you might want to use a newtype for that.
14:03:55 <edwardk> wlangstroth: much of my time is spent on far more practical pursuits ;) I explored these to see i there was anything to see. ;) Sadly there is, but the definitive 'final' result is in a conference proceeding and not available online.
14:04:41 <wlangstroth> edwardk: whaaat? Out with it - I have access to a university library or two
14:04:45 <edwardk> which is the recursion scheme from the cofree recursive comonad, provided by tarmo uustalu, which effectively subsumes all the others, and oddly has no greek name.
14:04:58 <edwardk> tarmo presented it as MSFP 08
14:05:09 <edwardk> so its just in the proceedings
14:05:10 <yitz> wlangstroth: the definitive result is that actually it's a database.
14:05:18 <wlangstroth> yitz: hahaha
14:05:18 <sclv> cofree recursive?
14:05:49 <edwardk> sclv: its better described in the paper than i can give here, but he encoded it using Mendler style. so sadly the type signature is longer than I can fit in this margin ;)
14:05:59 <wlangstroth> I'm taking Classics - I'll see if I can find a Greek name for it
14:06:00 * benmachine giggles
14:06:09 <sclv> edwardk: gotcha
14:07:02 <edwardk> heading off to boston haskell
14:07:04 <kmc> edwardk, i remember some talk that maybe there's a trick to getting into the room where we're meeting tonight?
14:07:05 <edwardk> later folks
14:07:18 <kmc> er it's not for 2 hours right?
14:07:19 <sclv> cheers!
14:07:21 <wlangstroth> later
14:07:22 <edwardk> yeah just head up to the 8th floor and look forlorn someone will take pity on you ;)
14:07:31 <edwardk> kmc: i want to get food, etc. and i'm an hour away
14:07:35 <kmc> ok just making sure ;)
14:07:40 <kmc> didn't want to miss my own talk
14:07:42 <kmc> see you there :)
14:07:48 <edwardk> see you there =)
14:28:51 <mathijs> Hi all, is it possible to have "monoids that fail"? I have a data structure that I think can be monoidal, but mappend is not always possible.
14:29:59 <dafis> mathijs: if mappend isn't always possible, it's not a monoid
14:30:15 <ziman> how about extending the set with an extra element?
14:30:42 <mathijs> ziman: like Nothing?
14:30:45 <ziman> like, using Maybe X instead of X and then liftingA2 append?
14:30:49 <kyagrd> In haskell Monad class by definition has fail method
14:30:49 <ziman> yes.
14:30:53 <soupdragon> sounds like a category
14:32:11 <mathijs> dafis: well, it's always possible, but the result might be useless. so nothing will fail, but you need to check the result to find out if it obeys to some rules
14:32:39 <mathijs> kyagrd: I'm asking about monoid, not monad. 
14:32:42 <kyagrd> Monoids are subclass of MonadPlus
14:32:51 <kyagrd> (in the ghc extension)
14:33:31 <ziman> yes, that rules out (liftA2 append), which would not provide the "failability" of the append you want to write
14:33:43 <mathijs> yeah, monadplus is next on my list to see if it's useful for this structure... but I thought I first needed a monoid instance before looking at monadplus
14:33:59 <kmc> why is the «(Monoid a) => Monoid (Maybe a)» instance not what you want?
14:34:01 <benmachine> anything that can be made a monadplus can be made a monoid
14:34:40 <mathijs> kmc: doesn't that imply my structure must be Monoid itself first?
14:34:51 <kyagrd> Oh the other way sorry MonadPlus is a subclass of Monoid
14:34:59 <kmc> hmm right
14:35:02 <kmc> but you can do the same thing
14:35:40 <kmc> data MyMonoid = Have MyType | Don'tHave; instance Monoid MyMonoid where ...
14:35:58 <kmc> you can generalize this
14:36:10 <mathijs> while I do see the relation between MonadPlus and Monoid, it's not fully clear. mplus is not always like mappend right?
14:36:30 <kmc> class PMonoid m where { pmempty :: m; pmappend :: m -> m -> Maybe m }
14:36:40 <kmc> then you can write the instance once
14:36:49 <kmc> instance (PMonoid m) => Monoid (Maybe m) where ...
14:36:52 <kmc> but it will overlap :/
14:37:10 <kyagrd> overlapping instances are hell 
14:37:20 <kmc> so perhaps avoid the generality
14:37:25 <kmc> and just make a Maybe-like wrapper for your one type
14:37:42 <mathijs> yeah, that sounds like an idea
14:37:49 <dafis> mathijs: MonadPlus m means you have a general way of making (m a) a monoid for every a, so you can't use anything about a in your instance
14:37:54 <benmachine> mathijs: the main differences are that MonadPlus things are kind * -> * rather than kind *, must be Monad, and also obey laws relating to >>=
14:38:01 <kmc> you can newtype Maybe, if you want a free conversion to/from Maybe for other purposes
14:38:57 <aavogt> that wouldn't be a 'duplicate instance'?
14:39:17 <kmc> which?
14:39:27 <aavogt> the Monoid (Maybe m)
14:39:31 <kmc> yeah, i guess it would be
14:39:33 <kyagrd> I don't quite get what failure of mappend means. Monoid algebra must be closed for mappend.
14:39:46 <aavogt> it's instance is exactly the same as the actual one for Maybe
14:39:58 <ksf> damnit there must be a generics library that supports graphs. it just doesn't seem to be documented
14:40:00 <aavogt> except with a different context, which isn't used when choosing instances
14:40:09 <ksf> after all, they do compilers etc. with that stuff
14:40:31 <mathijs> dafis, benmachine: yeah, before moving "up" a kind, I first wanted to tackle the "lower" Monoid. Like I said, I'm pretty sure it _is_ monoidal by itself, but sometimes the result isn't useful (no failure though, mappending more might "fix" the useless result)
14:40:33 <kmc> how much do they, really?
14:40:49 <kmc> if mappending more might fix it
14:41:04 <kmc> then it sounds like your type just has one more value than you thought
14:41:10 <kmc> (or more than one)
14:42:12 <benmachine> mathijs: if it follows the laws, why not just let it produce useless results sometimes?
14:42:26 <benmachine> what is your type anyways?
14:43:22 <mathijs> also not... lemme try to explain. my type is like a bunch of typing-operations. it might be adding/inserting characters, or removing some. applying all these operations on a document gives a new document. but ofcourse any document can just be descibed as ops leading to that document. So there really is no difference between operations and a document itself(state) ...
14:43:22 <ezyang> Let's suppose I'm in IO. I have a bunch of references. I'd like to, on the type level, prevent a user from using a reference more than once. Is there a way to do this? 
14:43:57 <ezyang> (For example, with file handles, once I closeHandle h I shouldn't be able to readStuff h) 
14:44:23 <seric> hi, is there an "else if" as well available in haskell?
14:44:33 <Saizan> ezyang: you want some encoding of regions, oleg has a few
14:44:46 <ezyang> monadic regions, gotcha 
14:44:53 <zachk> seric: there is a powerful case statement 
14:44:54 <roconnor> if b then x else if c then y else z
14:45:10 <roconnor> but using guards instead looks nicer
14:45:17 <mathijs> so what would be a "invalid" document? suppose the doc says "delete characters 'abc' at position 10, then append 'blah'". this document is invalid if there are no 'abc' characters at position 10. but ofcourse mappending it on top of a document that has the characters will create a valid result once again... hope this clears it up a bit?
14:45:23 <hpc> inside do blocks, there's when and unless
14:45:24 <seric> yeah, I thought about that as well.
14:45:33 <kmc> seric, i sometimes use
14:45:47 <kmc> case () of _ | cond_one -> ... | cond_two -> ... | ...
14:45:55 <hpc> case is amazing though; you should never have to use if-then-else
14:46:05 <kmc> well, you never have to
14:46:07 <benmachine> mathijs: my instinct is, don't handle that in the monoid instance at all
14:46:08 <kmc> but you might want to
14:46:13 <kmc> if/then/else is dumb though
14:46:19 <kmc> it's unnecessary special syntax
14:46:23 <hpc> the indentation of it is idiotic
14:46:25 <benmachine> just let them append, and then work out if it's valid afterwards
14:46:36 <dafis> mathijs: my instinct agrees with benmachine's
14:46:48 <seric> I am totally new to functional programming. so still struggle a little with haskell.
14:46:59 <kmc> ah
14:47:01 <hpc> seric: are you going through a tutorial?
14:47:07 <kmc> Haskell is not the simplest or easiest functional language
14:47:09 <zachk> seric: do you understand pattern matching at all? 
14:47:12 <kmc> however i think it's one of the best :)
14:47:15 <seric> zachk: sure
14:47:38 <Raynes> Haskell will make you see rainbows on the dark side of the moon.
14:47:42 <ddarius> kmc: Which is?
14:47:44 <zachk> seric: its ok to use if then else for awhile, i still do and ive been at it few a years 
14:47:49 <kmc> ddarius, which is the simplest?
14:47:52 <mathijs> benmachine: ok... so I'm trying to use the monoid just to "flatten" history. mappending all operations leads to a document (without any backspacing and retyping). so you say I should just check the end-result to only contain typing ops (no removal) to know it might be a "full" document?
14:47:53 <ddarius> Yes.
14:47:54 <dafis> kmc: Which functional languages do you consider easier than Haskell?
14:47:59 <zachk> @faq can haskell make me see rainbows on the dark side of the moon? 
14:48:00 <lambdabot> The answer is: Yes! Haskell can do that.
14:48:00 <geheimdienst> plus, haskell clearly has the best and most helpful IRC channel with the beautifullest denizens
14:48:00 <kmc> ddarius, depends on your defn. of "functional language"
14:48:03 <seric> zachk: I am forking a great project of dancor and trying to figure out how it works ;-)
14:48:15 <zachk> ahhh
14:48:41 * benmachine is humming pink floyd now
14:48:48 <kmc> mhm
14:48:58 <djahandarie> @pl \a b c d e f -> asks f >>= map ($ a b c d e f)
14:48:58 <lambdabot> (((((liftM2 (>>=) asks . ((map . flip id) .)) .) .) .) .)
14:49:02 <Zao> benmachine: Excellent.
14:49:03 <djahandarie> lol
14:49:06 <kmc> you can learn FP using a simple subset of Scheme
14:49:15 <tommd> Scheme is certainly easier to make a mistake in than Haskell.  So much easier.
14:49:16 <kmc> although all of Scheme is somewhat larger
14:49:20 <kmc> right
14:49:29 <djahandarie> @pl \a b c d e f -> asks g >>= map ($ a b c d e f)
14:49:29 <lambdabot> (((((((asks g >>=) . map . flip id) .) .) .) .) .)
14:49:32 <kmc> similarly Python is regarded as one of the easiest languages to learn
14:49:40 <aavogt> are we properly comparing minimal subsets?
14:49:42 <kmc> and I consider it functional, although it's not leading the pack there
14:49:50 <kmc> likewise JavaScript
14:50:04 <djahandarie> JavaScript is nice, although the lack of tail call optimization is annoying
14:50:15 <hpc> python is easy to learn, but almost impossible to "learn" in the sense of being idomatic to the language
14:50:19 <geheimdienst> does python still have idiotic restrictions like "no statements in lambdas"?
14:50:23 <kmc> yes
14:50:25 <kmc> that's syntactic
14:50:26 <djahandarie> Prototypal inheritence is a pretty nice break from Classical stuff
14:50:32 <kmc> because they made the mistake
14:50:36 <kmc> of not having non-whitespace forms
14:51:00 <kmc> i think static types make the step from not knowing anything to making a small program work harder
14:51:05 <aavogt> kmc: variable scoping in functions
14:51:06 <kmc> and they make the step from there to making a big program work much easier
14:51:53 <aavogt> kmc: do newbies write programs that should work correctly but wouldn't type in haskell?
14:51:59 <kyagrd> Haskell (including popular extensions) has relatively large syntax due to its endless adding extensions
14:52:19 <kmc> if you turn on every GHC extension, yes
14:52:19 <benmachine> I dunno
14:52:24 <benmachine> no loops
14:52:25 <kmc> some of the most-used extensions don't add syntax at all
14:52:26 <soupdragon> aavogt, I think there's a lot of times they intend to - but probalby screw it up for minor reasons
14:52:28 <kyagrd> It is well engineered so it is very succint and readable but its syntax is large.
14:52:30 <ksf> http://journal.ub.tu-berlin.de/index.php/eceasst/article/viewFile/273/258
14:52:36 <benmachine> no switch, no break, no goto :P
14:52:36 * geheimdienst just had the thought that prototype inheritance is somewhat like the proposals for extensible records in haskell :-o
14:52:36 * ksf can't find any source for that
14:52:37 <kmc> some of the ones that do are pretty trivial sugar
14:53:09 <kyagrd> The problem with this situation is that it is a pain to define metaprogramming synatax
14:53:17 <aavogt> soupdragon: exactly... would any of those programs with infinite types work?
14:53:26 <kmc> aavogt, maybe it's that runtime type errors are easier to understand than compile-time type errors, for a very small program
14:53:31 <kmc> "it broke and here's exactly why"
14:53:39 <kyagrd> When the syntax for type system grows the metaprogramming extension the TH has to grow, and TH is hardwired :(
14:53:43 <kmc> versus "i can't convince myself this is fine in every case, here's my failed line of reasoning"
14:54:06 <dafis> kmc: I always found the compiler's "it will break and here's why" very clear
14:54:06 <kmc> GHC's implementation of TH is already missing basic things from H98
14:54:22 <aavogt> I miss n+k patterns every day
14:54:26 <kmc> > map (-7) [1,2,3]
14:54:27 <lambdabot>   [-7,-7,-7]
14:54:30 <kmc> ok that works here;P
14:54:50 <kmc> but otherwise you get a very unhelpful message about "No instance for (Num (a -> b))"
14:54:52 <kyagrd> Yes H98 including patterns and module namespace is already non-trivial to cover up with a type safe metaproramming
14:55:02 <kmc> of course it's non-trivial
14:55:09 <aavogt> kmc: what's missing from TH though?
14:55:15 <benmachine> I think TH has great potential but is decidedly rough around the edges
14:55:16 <kmc> pattern splices
14:55:21 <aavogt> (besides n+k)
14:55:32 <kmc> i don't mean missing from the AST necessarily
14:55:37 <kmc> i mean missing bits of the user interface
14:55:43 <kmc> that make it tremendously more painful to use
14:56:04 <kmc> every time you have a pattern that's not hard-coded you have to drop out of quotation and use the ast dsl
14:56:45 <ddarius> TuxGuitar files are very compact.
14:57:05 <kyagrd> And I wonder how we would deal with TH when pattern guards come in.
14:57:18 <kmc> why do those present a special obstacle?
14:57:19 <aavogt> they are in the TH AST
14:59:13 <aavogt> kmc: I think there's too much choice in the design for   [| \$( .. :: PatQ) -> ... |]
14:59:54 <aavogt> as in, should that be  Q [Pat] in there instead
15:02:20 <dons> icfp accepted paper list up... 
15:04:38 <Botje> that's a lot of papers!
15:09:10 * zygoloid 's least favourite TH interface nasty is Q Dec versus Q [Dec]
15:11:07 <seric> so with a case stm, how would I do sth like this: op `elem` [BEQ, BNE, BID, BNI] and the other case: op `elem` [BLT, BLE]
15:11:25 <zygoloid> you'd think you could write: instanceD context myInstance [d| foo = ...; bar = ...|]
15:11:37 <FauxFaux> Why would you want anything but a BLT?
15:11:44 <kmc> seric, using guards
15:11:46 <zygoloid> but you can't, since [d| gives a Q [Dec] and instanceD takes a [Q Dec]
15:12:05 <kmc> case () of _ | op `elem` [BEQ, BNE, BID, BNI] -> stuff | op `elem` [BLT, BLE] -> stuff
15:12:15 <kmc> but if those are exhaustive then you can write the second guard just as "True"
15:12:21 <kmc> or "otherwise", a convenient alias for True
15:12:25 <seric> kmc: ok, never did that, but looks interesting, thanks
15:12:30 <aavogt> @type Language.Haskell.TH.InstanceD
15:12:31 <ddarius> instanceD' ctx inst = instanceD ctx inst . sequence
15:12:31 <lambdabot> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Type -> [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.Syntax.Dec
15:12:51 <benmachine> ddarius: you need an unsequence
15:12:53 <aavogt> @type liftM3 Language.Haskell.TH.InstanceD
15:12:53 <lambdabot> forall (m :: * -> *). (Monad m) => m Language.Haskell.TH.Syntax.Cxt -> m Language.Haskell.TH.Syntax.Type -> m [Language.Haskell.TH.Syntax.Dec] -> m Language.Haskell.TH.Syntax.Dec
15:13:51 <aavogt> you can also write on the last line:    _ -> ...   instead of more guards
15:14:36 <ddarius> seric: I would avoid using "stm" as an abbreviation for "statement."  In fact, I would avoid abbreviations overall.
15:14:48 <zygoloid> ddarius: instanceD ctx inst =<< (fmap.fmap) return [d| ... |] works
15:14:58 <seric> ddarius: okay. :)
15:15:01 <kmc> :t (fmap.fmap) return
15:15:01 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (m :: * -> *). (Functor f, Functor f1, Monad m) => f (f1 a) -> f (f1 (m a))
15:15:03 <elzurk> going through RWH, I found out about -fwarn-incomplete-patterns. Do I have to always pass that to the compiler?  Can I store that somewhere so that it is automatically used?
15:15:15 <ezyang> elzurk: Cabal 
15:15:19 <ksf> what's the point of advertising something in a paper if you don't release it?
15:15:23 <ezyang> See also -Wall 
15:15:35 <aavogt> wall is crazy
15:15:35 <zygoloid> i can only imagine that [d| used to provide [Q Dec] before the powers that be realised that was silly.
15:15:41 <ksf> personally I doubt the existence of anything that doesn't have at least a binary available.
15:15:43 <zygoloid> and the TH module wasn't updated
15:15:46 <benmachine> seric: stm is particularly confusing because of Control.Concurrent.STM :P
15:15:49 <ezyang> Basically, once you're not playing with the language, you want to go and write a cabal file for your project 
15:15:54 <ezyang> and then cabal configure && cabal build 
15:16:17 <zachk> ok im writing a tictactoe program (no laughter please) and i have the board as a [[Piece]], i have a legalMoves function , now whats the best wait of updating the list of lists? ive written code now for a year that splices in values , but it uses drop take and ++ not very effecient, what should i be using to represent a board 
15:16:43 <ksf> a 2d array?
15:16:46 <benmachine> zachk: do you really need efficiency? :P
15:16:49 <zygoloid> another fun one: "instanceD (cxt []) [t| Storable $type |] defs" doesn't work either
15:16:52 <benmachine> but yeah, an STArray might be suitable
15:16:57 <kmc> zachk, Map (Int, Int) Piece
15:17:01 <kmc> from Data.Map
15:17:03 <elzurk> ezyang: cabal has not been introduced so far, is there a .ghc type file I can add these options to?
15:17:04 <ksf> ...at least you want a two-dimensional index function
15:17:08 <ksf> yep a map is a good idea
15:17:19 <zygoloid> because Storable is a class. even though it would generate EXACTLY the right AST if it worked
15:17:19 <kmc> fast enough, simple interface (simpler than array), updates with sharing between versions
15:18:11 <ezyang> elzurk: I probably would just add an alias for ghc that addes the flags, quite frankly 
15:18:14 <zachk> kmc: thats Data.Map? 
15:18:17 <kmc> yeah
15:18:23 <zygoloid> you also can't write [d| instance Storable $type where ... |] because GHC says $type is a type /variable/ (even though it isn't when i splice in $type)
15:18:39 <elzurk> ezyang: that works, thanks
15:18:41 <kmc> you have 9 things in your structure; efficiency won't matter and would be hard to predict anyway
15:19:07 <aavogt> zygoloid: you can't write duplicate or illegal instances in [d| |] either
15:19:15 <kmc> maybe it matters if you want to evolve tic-tac-toe players using millions of generations per sec
15:19:35 <zygoloid> aavogt: yeah, i ran against that too :(
15:19:53 <aavogt> apparently TH is good enough that we've used it
15:20:10 <benmachine> elzurk: there's a .ghci
15:20:16 <benmachine> if you're interpreting rather than compiling
15:20:55 <zygoloid> TH is the best codegen-at-compile-time system i've ever used. but...
15:21:05 <zachk> TH?
15:21:10 <aavogt> @where TH
15:21:10 <lambdabot> http://www.haskell.org/th
15:21:22 <ddarius> zygoloid: The Meta OCaml stuff and related things looked pretty snazzy.
15:21:25 <aavogt> doesn't TH have a logo?
15:22:05 <aavogt> http://web.archive.org/web/20080302062750/http://www.haskell.org/th/th.png
15:24:21 <ivanm> preflex: seen dons 
15:24:21 <preflex>  dons was last seen on #haskell 22 minutes and 1 second ago, saying: icfp accepted paper list up... 
15:26:00 <ddarius> @hackage language-c
15:26:01 <lambdabot> http://hackage.haskell.org/package/language-c
15:26:03 <ddarius> @hackage llvm
15:26:03 <lambdabot> http://hackage.haskell.org/package/llvm
15:27:04 <kmc> going to boston haskell
15:27:06 <kmc> laters
15:27:52 * ezyang wields unsafeForeignPtrToPtr and cackles evilly 
15:28:24 <ddarius> ezyang: All that would lead to, in most cases, is leaked resources.
15:29:15 <ezyang> ddarius: Quit ruining my unsafeEvil moment! 
15:29:46 <ddarius> ezyang: Start using castPtr a lot.  You'll get the joy of a C programmer.
15:30:14 <geheimdienst> System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou
15:30:23 <geheimdienst> ... is what uncyclopedia says about that
15:30:44 <ddarius> @hoogle reallyUnsafePtrEq
15:30:44 <lambdabot> No results found
15:30:46 <ezyang> ...what page? 
15:30:55 <geheimdienst> ezyang http://uncyclopedia.wikia.com/wiki/Haskell
15:31:35 <geheimdienst> i enjoyed that very much, and it's quite clever. the code examples even work
15:31:52 <geheimdienst> and this is just great: "Lazy programming, a technique used to avoid telling the computer what to do until the program is running, saving developers from needing to code things that won't be used."
15:32:41 <yashton> "Nonfunctional programming"
15:32:55 <hpc> the best part for me was that the code samples actually work
15:34:06 <geheimdienst> yes, and when you paste them here and let lamdabot do its thing, people just go "OMG"
15:34:24 <seric> so I am trying to get this done with the case syntax, probably I do something wrong, someone an idea? http://pastebin.com/ZGPP4vRt
15:35:01 <ezyang> newtype Foo = Ptr Foo is really cute :^) 
15:37:23 <geheimdienst> seric, i think you're confusing 2 things here. there's "case", described here: http://en.wikibooks.org/wiki/Haskell/Control_structures#case_Expressions
15:37:36 <geheimdienst> ... and there's guards, see http://en.wikibooks.org/wiki/Haskell/Control_structures#Guards
15:37:38 <ezyang> Question: if I have newtype Foo = ForeignPtr Foo, can I do { let p = unsafeForeignPtrToPtr fp ; case p of (Ptr fp) -> touchForeignPtr fp }? 
15:38:03 <ezyang> I suspect this doesn't /actually/ work... 
15:38:05 <seric> geheimdienst: thanks for your advice, I am checking
15:38:24 <soupdragon> seric, delete  = case  () of  _
15:38:25 <soupdragon> seric,the change the -> to =
15:38:25 <soupdragon> then it should work
15:38:25 <soupdragon> > fix
15:38:26 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
15:38:26 <lambdabot>    arising from a u...
15:38:41 <hpc> >fix (fix show)
15:38:48 <hpc> > fix (fix show)
15:38:48 <lambdabot>   Couldn't match expected type `a -> a'
15:38:49 <lambdabot>         against inferred type `[GHC.T...
15:38:56 <hpc> > fix (const . fix show)
15:38:57 <lambdabot>   Couldn't match expected type `(b -> a) -> a'
15:38:57 <lambdabot>         against inferred type ...
15:38:57 <geheimdienst> and if you do decide to use "case", then it won't make much sense to say "case () of" because () is an empty tuple
15:39:10 <monochrom> > case () of _ | False -> "0" | True -> "1"
15:39:10 <lambdabot>   "1"
15:40:35 <geheimdienst> yeah dude, but when would you actually use that?
15:40:38 <geheimdienst> ;-)
15:40:42 <aavogt> seric: you can't have a newline ther
15:40:47 <soupdragon> =I've seen it used
15:40:47 <monochrom> The point is it is not wrong.
15:40:53 <geheimdienst> i mean, what he wrote here is not what he meant: http://pastebin.com/ZGPP4vRt
15:41:15 <aavogt> seric: http://pastebin.com/Y3xBehW5
15:41:22 <geheimdienst> yes yes, i said only it doesn't make much sense
15:41:43 <aavogt> yeah, or drop the case () of
15:41:52 <aavogt> since you're allowed to attach guards to equations
15:42:18 <aavogt> http://pastebin.com/3yLKjT0D
15:42:20 <jmcarthur> google at icfp. wat?
15:43:25 <wli> google's looking for functional programmers?
15:43:36 <geheimdienst> monochrom, but thanks for checking. when _i_ am explaining stuff here to newbies it's prone to be a case of the blind leading the blind ;-)
15:43:39 <monochrom> google is looking for publicity
15:43:58 <ivanm> monochrom: good publicity I hope
15:44:13 <seric> aavogt: I then get a parse error on the first ->
15:44:14 <geheimdienst> i guess all those phds have to do _something_ in their 20% time
15:44:19 <wli> monochrom: If so, I suspect they'd go elsewhere besides ICFP for that.
15:44:20 <monochrom> icfp is looking for publicity too, of course.
15:44:22 <ivanm> what with street view cars stealing people's banking records, etc. (if you believe our useless IT minster)
15:44:37 <monochrom> google goes everywhere
15:44:41 <benmachine> geheimdienst: it's usual to underestimate your explaining ability I think; have a little faith :P
15:45:59 <monochrom> If not for some 5-year lock-in between IBM and ACM ICPC, Google would go to ACM ICPC too. Indeed, Google already contacts ACM ICPC contestants by other means, e.g., inviting contestants to the Google campus for tours.
15:46:14 * ksf would've assumed that we have a state of the art graph rewriting system
15:46:14 <aavogt> uh, this works, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26006#a26006 seric
15:46:14 <dh__> @help
15:46:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:46:42 <geheimdienst> benmachine, thanks man
15:46:50 <jmcarthur> wli: they have an experience report :o
15:47:14 <jmcarthur> using haskell in a python project or something like that
15:47:18 <seric> aavogt: I was refering to your second correction without the case () of _
15:47:24 <seric> +f
15:47:30 <aavogt> oh, there you need = instead of ->
15:47:40 <seric> *sigh* sure
15:48:22 <seric> and I can add a   | otherwise transfNothing  right?
15:48:23 <mklappstuhl> hi
15:48:34 <aavogt> seric: sure, but it's redundant
15:48:47 <seric> oh, I see - the other pattern
15:49:19 <yitz> hi mklappstuhl 
15:49:47 <mklappstuhl> im wondering whether i can get this nice syntax highlighting as shown on BONUS' tutorial for my own prompt
15:49:58 <max_atre1des> (learning haskell) - Oh WHY do haskellers like to name their vars with such non-descriptive variables like 'x', 'f', 'g' - i'm not used to that >.<
15:50:17 <aavogt> because descriptive names are hard
15:50:26 <ezyang> And the types often are enough documentation 
15:50:26 <danharaj> f, g are functions
15:50:33 <danharaj> x, y, etc. are variables
15:50:41 <danharaj> It is just mathematical convention.
15:50:52 <aavogt> xs is a list
15:50:57 <aavogt> fs is a list of functions
15:51:00 <yitz> max_atre1des: we're used to functions that are so polymorphic that non-descript math-like variables are the most appropriate. not always, though, of course.
15:51:02 <max_atre1des> danharaj: i figured it's something like that :)
15:51:10 <jesusabdullah> max_atre1des: I agree with you. XD I have more of a python background, so it really messes with me XD
15:51:10 <mklappstuhl> aavogt: descriptive names are hard??!
15:51:25 <danharaj> the more powerful your type system the less descriptive your names have to be.
15:51:25 <jesusabdullah> I think general yet descriptive names are hard
15:51:29 <aavogt> yeah, it's lots of work to come up with them, mklappstuhl
15:51:43 <geheimdienst> mklappstuhl yes absolutely. there's only 2 difficult things in computing, cache invalidation, naming stuff, and off-by-one errors
15:51:44 <monochrom> I bet you see "non-descriptive" names in tutorials and very general library code. In tutorials you have toy examples, why be "descriptive". In general library code the code is too multiple-purpose, there is no "descriptive" choice, it's too generic.
15:51:47 <jmcarthur> danharaj: the more *descriptive* your types are the less descriptive your names need to be
15:51:48 <danharaj> A haskell type gives you more information than the most bloated conventioned C++ name.
15:52:01 <danharaj> jmcarthur: you use 'descriptive' I use 'powerful'
15:52:10 <monochrom> For example, something close to library code:
15:52:12 <danharaj> jmcarthur: a type systems power is the ability to describe terms :p
15:52:12 <jesusabdullah> SEMANTICS
15:52:13 <monochrom> @src (.)
15:52:13 <lambdabot> (f . g) x = f (g x)
15:52:13 <lambdabot> NB: In lambdabot,  (.) = fmap
15:52:30 <monochrom> There is no point "improving" the names f, g.
15:52:31 <geheimdienst> my rule of thumb is: the bigger the scope where you can see the variable, the longer the name
15:52:32 <alexbobp> just be glad we *have* types!  unlike the pythonic stone-agers.
15:52:40 <jesusabdullah> hehe
15:52:48 * jesusabdullah waves around his wooden club
15:52:50 <yitz> is "map theFunction theList = ..." really any better than "map f xs = ..."?
15:52:50 <jesusabdullah> OOG OOG
15:52:52 <alexbobp> geheimdienst: that sounds like a good rule
15:52:59 <jmcarthur> danharaj: well i could just use "string typing" even in a powerful type system
15:53:02 <aavogt> monochrom: outerFunctionToApplySecond . innerFunctionToApplyFirst = ...
15:53:03 <ivanm> OK, mediawiki doesn't like me: how does one do nested lists on the haskell wiki?
15:53:20 <aavogt> ivanm: even inside <haskell> tags?
15:53:23 <ivanm> I thought I just had to do *, **, etc.
15:53:26 <mklappstuhl> i get this xs, fs = lists thing and that sounds great somehow but for people coming from other languages it seems to be odd
15:53:28 <ivanm> aavogt: no, not code
15:53:31 <Phyx-> :k Int
15:53:32 <lambdabot> *
15:53:42 <Phyx-> ah, lambdaboy  had kinds
15:53:46 <danharaj> Sure it's odd, but every language has its own idioms and conventions.
15:54:01 <jmcarthur> mklappstuhl: it looks odd until you see it in context. usually you can relate those things to types:  xs :: [a]; fs :: [a -> b]
15:54:05 <jesusabdullah> My idioms are better than your idioms! </troll>
15:54:11 <benmachine> list of lists: xss
15:54:15 <Phyx-> :k [forall a.a]
15:54:15 <lambdabot> *
15:54:17 <yitz> geheimdienst: that's good, but also the opposite for generality - the more general the variable, the shorter the name. balance the two.
15:54:18 <ivanm> but I'm getting stuff like "    *  -  + Foo" rather than just "     + Foo" :s
15:54:30 <benmachine> list of lists of lists: xsss
15:54:39 <benmachine> (it does happen)
15:54:43 <ivanm> jesusabdullah: so, when did you _start_ trolling?
15:54:49 <aavogt> it shouldn't happen though
15:54:51 <jesusabdullah> tssch
15:54:52 <danharaj> three nest programming
15:54:55 <benmachine> pronounced ex-es-es-es
15:54:56 <ivanm> benmachine: yeah, I've always felt uncomfortable doing that :s
15:54:58 <jesusabdullah> a REALLY long time ago
15:54:59 <yitz> benmachine: reminds me of caaadr
15:55:03 <jesusabdullah> ivanm: scroll up dawg
15:55:03 <benmachine> ivanm: I love it it's awesome
15:55:04 <mklappstuhl> any ideas regarding my question (syntax highlighting in ghci)
15:55:04 <monochrom> But notice that "unsafePerformIO" is a very descriptive name.
15:55:18 <jesusabdullah> haha
15:55:31 <aavogt> mklappstuhl: don't use ghci for code... it doesn't let you do very much
15:55:32 <hpc> the most important part of the name is 'unsafe' :P
15:55:38 <aavogt> for writing the code that is
15:55:38 <jesusabdullah> pleaseDontDoThisForTheLoveOfGodButIfYouReallyInsistPerformIO
15:56:02 <benmachine> mklappstuhl: you can get it in text editors, but not in ghci afaik
15:56:04 <Phyx-> lol, would be very annoying if ghc starts presenting you with a EULA when you first use unsafePerfromIO, stating that all warranties will be voided
15:56:17 <benmachine> all warranties will be :: Void
15:56:27 <mklappstuhl> as i said
15:56:38 <aavogt> like it comes with warranties to begin with
15:56:42 <geheimdienst> yitz, but generality doesn't mean you see the variable in a lot of places, does it? map is super-general, but i've never seen its local variables
15:56:42 <jesusabdullah> "fuck it's making me scroll to the bottom *pagedown* *pagedown*"
15:56:42 <yitz> one of the most famous haskell functions is "launchMissiles". fortunately, no one has written it yet afaik.
15:56:46 <Phyx-> so all :: a -> b -> c -> d -> Void
15:56:57 <mklappstuhl> i just wondered since BONUS' tutorials are colored and he uses ghci for some demonstrations
15:57:09 <yitz> geheimdienst: ok, i see what you mean.
15:57:10 <jesusabdullah> That sounds like a fun project
15:57:12 <aavogt> perhaps BONUS would know
15:57:16 <jmcarthur> jesusabdullah: "I think general yet descriptive names are hard" ... i call this idea of being general enough to encompass all possibilities without being so general that you included invalid things "precise," and yes, it's hard to get right sometimes. it's also worth the effort to do some research into getting the right name :D
15:57:43 <ivanm> @tell dons OK, added my arguments to that page
15:57:44 <lambdabot> Consider it noted.
15:58:15 <jesusabdullah> Like, make a Estes rocket stand and wire them up to a microcontroller and trigger launch with a signal from a usb cable
15:58:22 * jesusabdullah rubs his hands together
15:58:24 <jesusabdullah> oh yes
15:58:31 <geheimdienst> mklappstuhl, well if you want to put haskell code on the web with syntax highlighting, there's javascript libraries for that. if you want to get it in ghci, that would be a very different thing
15:58:56 <aavogt> hscolour does both
15:58:59 <geheimdienst> besides that, just about any editor worth its salt will give you highlighting
15:59:10 <mklappstuhl> geheimdienst: i know, thats why im asking if its there for ghci
15:59:36 <jesusabdullah> What if you paid very little salt? Or, even, no salt?
15:59:39 <geheimdienst> try this http://www.haskell.org/haskellwiki/GHCi_in_colour
15:59:53 <jesusabdullah> A friend of mine once tried to argue that he had the highest ratio of creme cheese to bagel because he had no bagel
16:00:06 <jesusabdullah> rioting, but also hilarity, ensued
16:00:16 <geheimdienst> dude, that's a division by zero
16:00:25 <Phyx-> so #haskell is talking about cheese bagels
16:00:34 <Phyx-> and #csharp about pudding
16:00:43 <monochrom> Lies
16:00:59 <jesusabdullah> (In the end we agreed that, unless we assumed bagel-particles stuck to his clothes, that it was undefined and that meant that there was no size, meaning--of course--that his claim was bogus)
16:01:14 * Phyx- has logs to prove it
16:01:23 <jesusabdullah> (I found assuming bagel-particles to be more satisfying.)
16:01:48 <Phyx-> hmm 1am, sleep or code...
16:02:04 <jesusabdullah> or c) read reddit
16:02:05 * ivanm knocks Phyx- out with a two-by-four, thus removing his dilemma
16:02:14 <Phyx-> LOL
16:02:18 <jesusabdullah> >:}
16:02:43 <Phyx-> ivanm: but you introduced a new one, doctor or no doctor :P
16:02:54 <jesusabdullah> you'll be FIIINE
16:03:01 <ivanm> Phyx-: yes, but you won't have that dilemma for a few hours yet at least!
16:03:10 <Phyx-> true :)
16:03:11 <benmachine> Phyx-: move a few hundred miles west, then it'll be 12am again and you can keep coding
16:03:38 * jesusabdullah realizes that 1:00am is really far away from where he is
16:03:40 <Phyx-> lol
16:03:43 <jesusabdullah> where are you, Phyx?
16:03:50 <Phyx-> Netherlands
16:03:59 <mklappstuhl> germany here
16:04:02 <jesusabdullah> Netherlands are farther away than I thought!
16:04:04 <mklappstuhl> 1am too
16:04:07 <jesusabdullah> <--Alaska
16:04:11 <geheimdienst> same for me, it's 1am here
16:04:16 <jesusabdullah> It's 3:00 in the afternoon for me!
16:04:20 <Phyx-> :O
16:04:23 <benmachine> alaska huh
16:04:23 <jesusabdullah> :O
16:04:23 <mklappstuhl> lol
16:04:26 <jesusabdullah> Indeed
16:04:38 <benmachine> what do I know about alaska
16:04:41 <benmachine> snow, oil, sarah palin
16:04:44 <Phyx-> Sarah palin
16:04:46 <jesusabdullah> and polar bears
16:04:50 <Phyx-> ah, beat me to it
16:04:50 <Phyx-> lol
16:04:56 <jesusabdullah> Ah, parah salin
16:05:00 <wli> The state bird being the mosquito, too.
16:05:04 <jesusabdullah> Haha, that too
16:05:08 <benmachine> awesome
16:05:12 <jesusabdullah> You guys know more than I'd expect
16:05:25 <jesusabdullah> mosquitoes are also our main mode of transportation
16:05:31 <benmachine> you have quite low expectations >_>
16:05:36 <jesusabdullah> I guess
16:05:44 <jesusabdullah> That, and I think my home state's not that special
16:05:49 <Phyx-> no no, he's just being realistic :P
16:05:56 <wli> jesusabdullah: I imagine hetero men are probably not too happy up there given the gender ratio, too.
16:06:01 <benmachine> Phyx-: I didn't say they were inaccurate :P
16:06:03 <jesusabdullah> I mean, what do I know about the netherlands?
16:06:07 <jesusabdullah> ...dikes?
16:06:16 <jesusabdullah> (No, that's x country)
16:06:19 <Phyx-> most people would state drugs and hookers but ok, lol
16:06:27 <benmachine> yeah I was going for drugs and hookers
16:06:28 <jesusabdullah> orite, Pulp Fiction
16:06:31 <benmachine> and uhm, euthanasia?
16:06:33 <jesusabdullah> haha
16:06:37 <Phyx-> and windmills
16:06:37 <benmachine> no that's switzerland
16:06:41 <Phyx-> and wooden shoes
16:06:42 <benmachine> or sweden
16:06:44 * jesusabdullah 's memory is jogged
16:06:45 <benmachine> or somewhere :x
16:06:50 <jesusabdullah> and communists!
16:06:53 <benmachine> heh
16:07:05 <benmachine> I hear the far right is doing well in the netherlands at the moment actually
16:07:12 <jesusabdullah> Oh yeah?
16:07:15 <benmachine> or at least, were doing so in the european elections
16:07:18 <benmachine> that's a while ago now though
16:07:26 * jesusabdullah & finding_working_printer >_<
16:07:35 <wli> The more important thing in the EU is how well the Pirate Parties are doing.
16:07:42 <benmachine> heh
16:07:53 <Phyx-> we have elections today
16:07:54 <benmachine> they have like two MEPs don't they?
16:07:55 <Phyx-> in a few hours
16:07:56 <Phyx-> lol
16:08:09 <benmachine> from sweden or somewhere
16:08:40 <Phyx-> wli: lol, wonder how well the pirate party is gonna do today
16:08:47 <mklappstuhl> pirates! :)
16:09:44 <dh__> good evening, how can I find the source code of something with lambdabot ? 
16:09:47 <Phyx-> saw a presentation by dons I think where he compares the rates of haskell packages on haskell to successful somalian pirates hijackings
16:09:56 <Phyx-> dh__: @src
16:09:57 <dh__> I tried @source, but it tells no available.
16:09:57 <benmachine> hahaha
16:10:03 <dh__> @src shows
16:10:03 <lambdabot> Source not found. Sorry.
16:10:12 <benmachine> what does that imply >_>
16:10:28 <Phyx-> @src shows Int
16:10:28 <lambdabot> Source not found. It can only be attributed to human error.
16:10:29 <dh__> @src Html
16:10:30 <lambdabot> Source not found. I am sorry.
16:10:37 <dh__> @hoggle Html
16:10:37 <lambdabot> module Text.Html
16:10:37 <lambdabot> Text.Html newtype Html
16:10:37 <lambdabot> Text.Html Html :: [HtmlElement] -> Html
16:10:45 <benmachine> dh__: sometimes stuff just isn't in there
16:10:58 <benmachine> dh__: you're better off looking on hackage
16:11:06 <wli> Phyx-: Is there a Pirate Party in the Netherlands?
16:11:09 <benmachine> go, ghc-pkg find-module ModuleName
16:11:18 <benmachine> and then @hackage packagename
16:11:25 <Phyx-> benmachine: lol, unfortunately I only saw the slides, don't know the conclusion he made from it :P
16:11:27 <benmachine> and then the ahddocks have source links
16:11:28 <Phyx-> wli: yeah
16:11:41 <benmachine> there are a few of them about aren't there?
16:11:56 <Phyx-> wli: going to http://thepiratebay.org/ reminds you to vote for them today :P
16:11:59 <wli> Phyx-: They seem to be everywhere now. Maybe one should start up in the US, too.
16:12:21 <dh__> @hackage xhtml
16:12:21 <lambdabot> http://hackage.haskell.org/package/xhtml
16:12:33 <dh__> thanks benmachine
16:12:41 <benmachine> yes except that no minor party ever achieves anything in the US >_>
16:12:56 <benmachine> how do you guys not demand electoral reform, I would
16:13:03 <wli> benmachine: Point, though there is Bernie Sanders.
16:13:05 <Phyx-> wli: I agree with most of what they say, certainly not all, but it's a start
16:13:13 <ksf> sometimes I have to conclude that cs research wants to artificially slow the progress of cs.
16:13:24 <wli> benmachine: usanians demand a lot of things and get none of it.
16:13:27 <dh__> benmachine: what is ahddocks?
16:13:29 <ksf> it's all about the source, people.
16:13:41 <benmachine> wli: awesome
16:13:42 <Phyx-> i don't agree
16:13:47 <Phyx-> source is not that important imho
16:13:53 <benmachine> dh__: er, haddocks
16:13:54 <Phyx-> it's information
16:13:56 <danharaj> it's all about ideas.
16:14:07 <danharaj> source is for neckbeards
16:14:18 <monochrom> reproducibility is important
16:14:19 <tommd> Which is why I'm mad as heck that the unemployment rate hit 82% last week.
16:14:24 <ksf> that's like musicians handing out natural language descriptions of their music but keeping the records locked up.
16:14:25 <wli> benmachine: Malefactors of great wealth have a total stranglehold on the US. It's a de facto plutocracy, except to the extent which it's a theocracy (i.e. the plutocrats' foot soldiers).
16:14:39 <benmachine> wli: awesome
16:14:43 <danharaj> ksf: argument by analogy always sucks :|
16:14:47 <Phyx-> ksf: sure, it's up to you to reproduce it
16:14:57 <monochrom> indeed musicians hand out mp3 files and keep the scores locked up
16:15:01 <benmachine> wli: but that's true of most democracies, I guess
16:15:02 <ksf> oh. great.
16:15:06 <benmachine> uhm, "democracies"
16:15:35 <ksf> everyone just needs to push a couple of papers into their computers, using opcodes because noone wants to share an assembler.
16:15:49 <ivanm> monochrom: how many musicians wrote their own music though?
16:15:52 <wli> benmachine: There's a radically different character to the goings-on in the EU and Canada and the US.
16:15:59 <Phyx-> wli: one thing I never did understand, is that running for office in the US take so much money that you end up "owing" alot of people something. or you make alot of empty promises along the way
16:16:00 <monochrom> I don't know.
16:16:17 <benmachine> running for parliament in the UK costs £500
16:16:23 <benmachine> and you get it back if you get a nontrivial number of votes
16:16:24 <Phyx-> ksf: sharing the assembler is not the same as sharing the source of the assembler
16:16:42 <ivanm> benmachine: same here; it's to avoid idiots running with no chance, etc.
16:16:47 <ksf> well, yes. in once case I got binaries
16:16:54 <monochrom> some first-cause argument argues that music must come from either some musicians or some computer.
16:16:59 <ksf> (which don't run on my system due to glibc incompatiblity)
16:17:03 <ivanm> because the government gives you $x (with $x being greater than your fee) towards advertising, etc.
16:17:05 <wli> Phyx-: It's a de facto property qualification.
16:17:08 <benmachine> monochrom: what if it always existed
16:17:10 <ksf> in the other, all I saw was screenshots in a paper.
16:17:23 <ksf> for all I know they could be photoshopped.
16:17:52 <monochrom> If music always existed, the king of france would be bald.
16:18:31 <Phyx-> wli: a downside of the EU way is though that we have alot of dumb parties
16:18:48 <benmachine> monochrom: there aren't any people that are both bald and the king of france, QED
16:18:55 <cyrax> Ohio enacts a transportation statute that impinges on interstate commerce. This statute will be
16:19:04 <benmachine> Phyx-: I don't view that as a downside personally
16:19:09 <Phyx-> wli: like the "Pedophiles" political party
16:19:20 <Saizan> anyone heard of #haskell-blah?
16:19:22 <benmachine> it takes up extra space on the ballot paper oh no :O
16:19:27 <benmachine> Saizan: :( yes
16:19:52 <Phyx-> benmachine: the danger is in that if they get any amount of significant votes, mostly from people who just pick a party at random
16:19:54 <soupdragon> I wonder if there could be a better IRC method than asking people to change channel
16:19:59 <Phyx-> Saizan: it's the off hours :P
16:20:01 <soupdragon> like a command that forced is somehow
16:20:10 <soupdragon> but I can't really imagine such a command
16:20:13 <benmachine> soupdragon: uhm, /kick?
16:20:16 <wli> Phyx-: I had a plot at one point to implement a CPO-STV web app.
16:20:17 <Phyx-> soupdragon: some IRCD have it
16:20:18 <ksf> http://www.cs.le.ac.uk/people/rh122/papers/2006/Hec06Nutshell.pdf
16:20:19 <soupdragon> no that doesn't do it
16:20:22 <ksf> pacman as example!
16:20:26 <ksf> I already love the paper.
16:20:41 <benmachine> Phyx-: you can solve that with a system like AV
16:21:00 <Phyx-> AV?
16:21:06 <Phyx-> wli: what's that?
16:21:09 <wli> benmachine: Ew, AV sucks compared to STV/MMP/etc.
16:21:37 <benmachine> wli: yeah, but we're only getting a referendum on AV so small mercies
16:21:56 <benmachine> Phyx-: alternative vote, ref http://www.electoral-reform.org.uk/votingsystems/systems2.htm#AV
16:22:07 <wli> Phyx-: Single Transferable Vote (STV) by Comparison of Pairs of Outcomes (CPO), which basically does CSSD on all the possible results from STV.
16:22:37 <Phyx-> soupdragon: UnrealIRCD has a "sajoin" command that forces a user into a channel :P
16:23:07 <wli> benmachine: Well, the UK is behind the times anyway. I think a fair amount of Europe has STV/MMP affairs, which are better than AV by a longshot.
16:23:28 <benmachine> wli: we're still doing better than the US sorta :P
16:23:44 <benmachine> anyway I'm going to bed
16:23:56 <Phyx-> wli, benmachine ah
16:23:56 * benmachine z
16:24:02 <wli> benmachine: Yet there have been egregious badnesses like Thatcher.
16:24:21 <Phyx-> "It also does very little to give a voice to those who have been traditionally under-represented in parliament." <-- that's a drawback and a good thing in some ways
16:25:16 <Phyx-> wth... the piratebay has a dating service now?
16:26:51 <ksf> did you by any chance just disable adblock?
16:27:19 <soupdragon> does lambdabot have any way to get the coefficents of a powe series?
16:27:29 <gwern> economists seem to like thatcher
16:27:44 <Phyx-> ksf: it's not presented as an add, it's just an image near the logo on the homepage
16:29:10 <Phyx-> @where ParsedModule
16:29:11 <lambdabot> I know nothing about parsedmodule.
16:29:21 <Phyx-> @hoogle ParsedModule
16:29:21 <lambdabot> No results found
16:29:28 <Phyx-> @google ParsedModule
16:29:28 <lambdabot> No Result Found.
16:29:33 <Phyx-> wth
16:31:30 <wli> Phyx-: The Netherlands already has open party list and I think STV.
16:31:49 <wli> Phyx-: AV in the Netherlands would be retrograde motion of an extreme sort.
16:34:17 <Phyx-> wli: ah ok, shows how much i know about politics :P
16:34:54 <ezyang> Public service announcement: newtype Foo = Ptr Foo makes foreign pointers annoying. 
16:35:39 <wli> Phyx-: CPO-STV is actually algorithmically interesting from the POV that it's probably NP-complete or something horrendous.
16:37:25 <krey> hello, I have an exam in Haskell in a week and am looking for some exam papers for revision
16:37:30 <Phyx-> wli: that's rather odd
16:37:51 <Phyx-> krey: doesn't your course provide you some?
16:38:00 <krey> it does indeed :)
16:38:06 <krey> but I have done them
16:38:12 <krey> and have not done too well
16:38:46 <Phyx-> wouldn't it be better to re-read the literature and then try those exams again?
16:38:51 <yitz> krey: LYAH helpful?
16:39:03 * zygoloid feels the sweet catharsis of having reported all his TH issues on ghc's trac :)
16:39:08 <krey> i love LYAH, it's fantastic!
16:39:09 <Phyx-> that way you'll know that you fundamentally know the answers instead of just learned exam questions
16:39:12 <wli> Phyx-: Well, no one uses it yet, but anyhow. As a voting system it's a rather nifty sort of thing because it resolves the choices in a Condorcet-oriented way, e.g. in the degenerate case of a single seat it becomes a Condorcet method (CSSD/Schulze?) instead of IRV/AV like ordinary STV.
16:39:36 <krey> Phyx: i've read the notes a couple of times, believe me
16:39:53 <krey> Phyx: but the exams are ridiculously hard
16:39:58 <krey> Phyx: need to practise
16:40:26 * Phyx- never realised how structured the political system is
16:40:27 <Axman6> krey: where is this exam?
16:40:30 <wlangstroth> gwern: economists live in a fantasy world of their own creation
16:40:39 <krey> university of oxford
16:40:51 <Axman6> righto
16:40:51 <svk_> Hey, can anyone link some friendly/simple code for parsing expressions using a recent version of Parsec (3.1.0)? The main doc on the home page seems to be somewhat outdated
16:41:41 <wli> gwern: Of course plutcrats' lackeys such as economists love the mole/whatever who implemented their masters' agenda.
16:41:49 <aavogt> svk_: the code should be the same... though maybe the imports and types have changed in places
16:42:09 <aakarsh> hi , I am a haskell newbie but am being plagued by type errors could someone help me http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26008#a26008
16:42:23 <aakarsh> trying to write simple subset function
16:42:28 <svk_> Yeah, I'm mostly past the import confusion I think, but still confused by the typing differences
16:42:29 <altmattr> does anyone know why the time reported in the profiling output is so much less than actual run-time (even considering system calls, etc)
16:42:45 <Phyx-> krey: sorry, all the exams here for introductionary haskell are in dutch
16:43:46 <yitz> aakarsh: you don't put function args in parens in haskell, or separate them by commans. just use spaces.
16:43:53 <svk_> Specifically, the doc says the type of an expression evaluating to an integer should be "Parser Integer", but that doesn't seem to work anymore?
16:43:55 <krey> Phyx-: :-D, maybe if I learn dutch quickly, I can prepare for my exam
16:43:58 <aavogt> @type all . elem
16:43:58 <lambdabot> forall a. (Eq a) => a -> [[a]] -> Bool
16:44:10 <aavogt> @type all . Prelude.flip elem
16:44:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:44:20 <yitz> aakarsh: (foo,bar) is a 2-tuple. that's a different type, you're not using it here.
16:44:28 <aakarsh> yitz: k
16:44:33 <dh__> good evening, is there a way to run functions in the internal packages ? e.g. Text.XHtml.Internals ? 
16:44:38 <wlangstroth> wli: I always saw economists as deluded rather than malicious henchmen. Bernanke doesn't rub his hands together in evil glee enough, I guess.
16:45:16 <yitz> wlangstroth: i know some economists. they don't seem very deluded to me.
16:45:35 <krey> so, no exam papers, anyone? I thought half of you were lecturers/teachers! :(
16:45:43 <wlangstroth> yitz: have you asked them about "utility" (measured in "utes")?
16:46:18 <yitz> wlangstroth: everything is measured by utility functions in econ.
16:46:30 <wlangstroth> yitz: et voila
16:46:35 <aakarsh> yitz: yeah that fixed it , so i guess it was creating tuple
16:46:58 <c_wraith> in ghc 6.10, how do you set the encoding on a handle?
16:47:05 <yitz> aakarsh: good!
16:47:11 <Phyx-> krey: I would say the majority are not :P I'm a student still myself
16:47:19 <yitz> c_wraith: you upgrade to 6.12
16:47:22 <zygoloid> @type flip (all . flip elem)
16:47:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:47:37 <aakarsh> aavogt: all . elem is pretty cool
16:47:42 <c_wraith> yitz: there's definitely a backwards-compatible way to do this.  maybe a 3rd-party lib?
16:47:53 <yitz> c_wraith: install the encodings package, encode it yourself, then write it out as bytes
16:48:00 <c_wraith> that'd do
16:48:01 <c_wraith> ok
16:48:19 <zygoloid> > all (`elem` [1..5]) [1,3,5] 
16:48:19 <lambdabot>   True
16:49:07 <Phyx-> ".GHC uses some evil hacks to simulate global variables " <-- well, atleast the documentation is honest
16:49:12 <djahandarie> @type flip
16:49:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:49:27 <wli> Phyx-: ``Finding the result of a CPO-STV election involves producing results, one at a time, for every possible pair of every possible set of winning candidates.'' <-- various sorts of doing math or something sorts of things are required to filter out as many sets of seat-winners as possible up-front.
16:49:58 <svk_> Hm, so does anyone know of any expression-parsing code using Parsec 3.1.0? I'm sure I might be able to figure things out more easily if I could see some working code
16:50:37 <monochrom> yes, http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
16:51:02 <svk_> Thanks, that looks excellent
16:51:14 <ksf> gragh damn category theory
16:51:17 <Phyx-> wli: various sorts of doing math?
16:52:02 <ksf> there I am, reading up on graph rewriting to rewrite my parser combinators and all I can think of is how the same stuff applies to the parser itself.
16:52:17 <wli> Phyx-: Finding theorems of some form like "only things satisfying condition X can possibly win a seat" and so on.
16:52:29 <Phyx-> ah ok
16:53:12 <Phyx-> but we'll have to continue this another time :) almost 2am, and I keep nodding off
16:53:15 <Phyx-> hehee
16:53:15 <Phyx-> gn everyone
16:53:37 <wli> Phyx-: So you have build up checklists of conditions to rule things out. Maybe also some things to avoid even having to check conditions on things, like "any winning parliament will have some candidate in it" or "no winning parliament will have some candidate in it" so the sets of winners only vary by the remaining seats.
16:54:58 <Phyx-> wli: Think I understand your point, though those two examples sound counter intuitive 
16:55:20 <Phyx-> the second one atleast, the first one is trivial 
16:55:53 <wli> Phyx-: CPO-STV is a sort of fun thing to try to implement because of this.
16:56:27 <svk_> monochrom: Hmm, are you sure that's 3.1.0? It seems to use the names I'm having trouble finding, e.g. "Parser"
16:56:55 <monochrom> It is Parsec 2.
16:56:58 <Phyx-> wli: yeah, it could be fun
16:57:07 <Phyx-> well, gn
16:57:14 <wli> Phyx-: gn
16:57:25 <svk_> Ah, okay, thanks anyway
16:57:34 <monochrom> But should just work with Parsec 3.
16:57:49 <svk_> With no change?
16:58:11 <monochrom> should work with no change.
16:58:27 <svk_> Hm, okay, I must be doing something else wrong then
16:58:54 <monochrom> since parsec 3 has parsec 2 compat layer Text.ParserCombinators.Parsec.* and I only import those.
17:00:25 <svk_> Aha, that seemed to do the trick
17:00:26 <svk_> Thanks
17:01:11 <svk_> I was trying to import the Text.Parsec.* stuff directly
17:02:50 <monochrom> It is interesting that haskell platform 2010 is still at parsec 2.
17:03:32 <lispy> monochrom: I think that's because parsec3 isn't an obvious win over parsec 2 yet
17:03:40 <lispy> monochrom: documentation an performance being notable
17:04:10 <lispy> monochrom: isn't that what people are saying in the thread about renaming libraries?
17:05:21 <monochrom> parsec 2 has non-existent haddock. parsec 3 haddock has actual content.
17:05:57 <monochrom> parsec 3 hasn't shown better speed. that is a problem.
17:06:09 <lispy> was it parsec 1 then that has the pdfs?
17:06:55 <monochrom> Yes. The problem is that the pdf is out of sync with parsec 2.
17:07:41 <ivanm> monochrom: 3.1 has IIRC
17:07:48 <ivanm> (shown better speed)
17:08:01 <ezyang> Question for people who have used foreignptrs: how close to the FFI do you try to start turning ptrs into foreignptrs? 
17:08:06 <monochrom> that is good news
17:09:04 <aristid> i love when google autosuggests even relatively obscure stuff
17:09:25 <aristid> when i started typing monad r... it already suggested monad reader
17:09:31 <ksf> I can't believe it applying futamura projections is actually patented
17:10:02 <aristid> ksf: what is a futamura projection?
17:10:38 <ksf> partually evaluating different special kind of stuff
17:10:48 <hpc> aristid: it takes any technology joke and makes it hilarious
17:10:52 <ksf> like an interpreter.
17:10:55 <hpc> oh wait, that's a futurama projection
17:11:18 <aristid> ksf: ok, judging from your vagueness it's somewhat obscure and complex.
17:11:34 <aristid> hpc: that's what i read first :P
17:11:51 <aristid> ksf: is it a software patent?
17:11:59 <ksf> not very complex, but a bit obscure. but its main characteristic is mind-bending.
17:12:24 <ksf> 1993... I bet there's prior art on partial evaluation before that.
17:12:51 <ksf> and I don't care for software patents, anyway.
17:13:05 <aristid> i think they should be abolished
17:13:18 <aristid> i don't know enough about non-software patents to say much about them
17:13:23 <aristid> but software patents are harmful.
17:13:25 <ksf> as far as I am concerned, if you live in the us you can just go and f...ind a way to convince your government to be sane.
17:13:30 <wli> ksf: Shouldn't it be expiring soon if it's a US patent/
17:13:46 <hpc> patents protect a design from any duplication
17:13:50 <c_wraith> ksf: that issue is in front of the US Supreme court right now.
17:13:54 <hpc> be it straight copying or independent derivation
17:14:10 <hpc> the latter case being what screws over software patents
17:14:12 <c_wraith> ksf: It's quite possible they will reject "business method" patents, which include software patents.
17:14:25 <aristid> hpc: indeed.
17:14:29 <hpc> copyright only protects against the former case
17:14:45 <hpc> (major simplification, but captures the essence of the difference)
17:14:48 <ksf> it's not even a legal question.
17:14:54 <aristid> hpc: i think the rationale was simplifying the thing in court, and it was ok when independent deriving was less common
17:15:02 <aristid> but it happens with software all the time
17:15:08 <ksf> the political reason why patents exist in the first place doesn't apply to them being used for software.
17:16:04 <hpc> also, the flaw with all patents is amplified in software patents, namely the renewal process
17:16:26 <hpc> a small change to a software patent has zero cost to implement after designing it
17:17:17 <ksf> hey, there's an sigfpe post on them
17:17:20 <ksf> http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
17:17:32 <aristid> i totally need a way to read pdfs without printing them.
17:17:48 <yitz> aristid: xpdf
17:17:54 <gwern> evince isn't bad either
17:18:05 <aristid> i can read on my laptop, thank you
17:18:09 <aristid> i mean in a nice way
17:18:22 <aristid> staring at the laptop is just not a nice way to read
17:18:30 <ezyang> Futamura projections are cool. 
17:18:41 <ksf> ...the fifth futamura projection might very well be the ai singularity.
17:18:42 <aristid> ezyang: don't use them! they're patented ;)
17:19:20 <ksf> heck I _do_ have my own prior art, there.
17:19:29 <gwern> ksf: in that case, we're safe - haven't even praticalized the 3rd projection, much less 4th
17:19:42 <ksf> that is, actual software that did partial evaluation way before 1993.
17:19:55 <ksf> it's part of the bleeding human thought process.
17:20:19 <aristid> ksf: now try to see if the courts accept your prior art ;)
17:20:34 <gwern> ksf: humans aren't really software though. we're like soft hardware
17:20:48 <ksf> so what, code is data is hardware.
17:21:37 * gwern downloads the paper on the 4th futamura projection
17:21:44 <gwern> that ought to be pretty mindbending
17:21:53 * ksf wants free acm access
17:22:09 <danharaj> soft hardware
17:22:13 <danharaj> sounds like something out of a koan
17:22:49 <gwern> danharaj: what is the sound of a FPGA flip-flopping?
17:23:24 * Axman6 's FPGA doesn't flip-flop
17:24:00 <gwern> 'We assume that readers are familiar with the basics of partial evaluation, e.g., as presented in the book by Jones et al. [28, Part II].'
17:24:03 <gwern> doh
17:27:37 <ksf> is the tendency towards entropy a side-effect of performance degration due to the universe being metacircular and having to execute its own code?
17:29:05 <ksf> and can we generate infinite power by building an optimizer?
17:29:37 <ksf> .oO( who says you can't space out on code )
17:29:55 <gwern> dude like totally
17:30:12 <danharaj> Which line of code is responsible for my current craving for chinese food?
17:30:32 <gwern> hm, apparently I'm allowed to redistribute this paper on the 4th projection
17:30:42 <gwern> although no doubt the ACM would disagree
17:30:46 <hpc> danharaj: that part's in perl; good luck changing it
17:31:08 <ksf> erm doesn't that contradict itself?
17:31:14 <danharaj> hpc: forget that, put that shit in an infinite loop.
17:31:21 <gwern> I wonder how we get an ACM which is so hostile to FLOSS and Free culture
17:31:21 <hpc> gwern: i would like to read that
17:31:53 <danharaj> I prefer the term "anarcho-neckbeards"
17:32:04 <gwern> ksf: what's even funnier is that right below the authors' notice of noncomercial permission is an ACM copyright and a listed fee of $5
17:33:32 <ksf> well, it appears that the acm agrees when they publish that notice, themselves.
17:33:33 <gwern> hpc: pour vous: http://community.haskell.org/~gwern/p51-glueck.pdf
17:33:44 <hpc> merci
17:33:55 <danharaj> would you like a baguette with that french?
17:34:14 <gwern> pardie, oui!
17:34:55 <ksf> mmmmh spasiba
17:34:57 <danharaj> only if you put on a striped shirt, smoke a cigarette and tell me of your 'philosophie'
17:35:04 <hpc> mon dieu, sacrebleu, chateau, ooh la la, fous de grois?
17:35:14 <gwern> zut alors
17:35:26 <ksf> it's "sacre bleu"
17:35:35 <ksf> "the blue holyness"
17:35:43 <ksf> which alledgedly is the republic.
17:35:43 <gwern> danharaj: I could do that, except I don't indulge in insults to the body
17:35:46 <gwern> silly french
17:36:02 <gwern> ksf: really? I always thought it was a reference to the Virgin Mary, oft depicted in blue
17:36:06 <danharaj> I think of it as more of a dare to the body.
17:36:25 <danharaj> I thought it was just a play on words because blue sounds like dieu
17:36:35 <ksf> well you'd have to ask someone who's french
17:36:36 <danharaj> bleu*
17:36:48 <ksf> which is kinda hard because they don't speak english
17:36:55 <systemfault> ...
17:38:04 <gwern> hm, futamura says there is no fifth projection, 'since there is nothing left to specialize with respect to.'
17:38:33 <danharaj> I thought it was all about generalization
17:38:57 <gwern> augh, I give up. I'll go read the cited papers about partial evalution of C. that ought to be interesting
17:38:58 <systemfault> I think nobody really knows what sacrebleu means..
17:40:02 <ksf> well one might have to generalise again
17:40:54 * mgsloan1 saw "hm, futurama says..."
17:41:15 <gwern> bleh, and neither C partial evaluation thing is online
17:41:29 <ksf> hmmm one obviously can't specialise not-yet-proven-terminating loops.
17:42:30 <ksf> we need yet another floss license that disallows use by persons who don't publish open access.
17:42:59 <tensorpudding> There are too many damn licenses.
17:43:16 <danharaj> I think BSD is pretty simple and straightforward
17:43:17 <ksf> there are too many commercial journals.
17:43:34 <gwern> ksf: just get stallman to update the AGPL :)
17:43:47 <tensorpudding> It makes it harder to choose.
17:44:11 <gwern> 'close the documentation loophole!'
17:44:18 <hpc> tensorpudding: it isn't hard to make your own with some judicial copypasta from the other licenses
17:44:41 <tensorpudding> Then you have to deal with being labelled as an "other license" or "modified X/Y/Z" license
17:45:04 <hpc> or crap like the LYAH license
17:45:11 <hpc> which is long for the sake of longness
17:45:38 <tensorpudding> I can't think of any licenses that weren't short enough that I didn't get bored reading them
17:45:46 <ezyang> Is there a function that does a traditional imperative style assert? Something like Bool -> IO () 
17:45:46 <tensorpudding> err, that were*
17:45:59 <hpc> :t when
17:45:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:46:12 <ksf> gwern, http://www.itu.dk/people/sestoft/pebook/jonesgomardsestoft-a4.pdf
17:46:30 <ezyang> hpc: I see, manually throw the exception yourself 
17:46:35 <gwern> Control.Exception assert :: Bool -> a -> a
17:46:38 <gwern> hum
17:47:01 <ezyang> I want something that will give me the line that the assert was made on. assert will do that, but it's kind of unwieldy to use 
17:47:04 <hpc> :t unless -- would probably be more readable
17:47:04 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:47:19 <tensorpudding> isn't that just an if statement that calls error on the else?
17:47:33 <hpc> tensorpudding: no, it calls return ()
17:47:36 <gwern> ksf: looks interesting
17:47:49 <tensorpudding> talking about the one that gwern used
17:47:58 <tensorpudding> but also I don't know what assert in imperative languages does
17:48:00 <gwern> too bad there's no real way to do partial evaluation stuff in haskell
17:48:29 <ezyang> It takes a boolean, and either terminates, emits a warning, or does nothing, when that boolean is True. 
17:48:35 <ezyang> *False 
17:48:39 <ksf> I'm actually trying to
17:48:46 <hpc> it depends on which compiler/runtime flags are set, in most cases
17:48:48 <ksf> (as I just found out)
17:48:59 <hpc> in Java, assert requires --enable-assert or some such
17:49:15 <ksf> extract your stuff with data-reify, then partially evaluate and generate what's left.
17:49:20 <gwern> sometimes when you have a problem in haskell, you say to yourself, I know, I'll hack on GHC. now you have 2 problems...
17:49:36 <hpc> gwern: poetic
17:49:55 <ksf> the fun of my tasks start where I have to partially evaluate across boundaries of <|>
17:50:12 <ksf> oh, and loops, of course.
17:50:42 <gwern> hpc: just a tired take on the old regexp quip
17:50:52 <ezyang> Right now I have (`assert` return ()) =<< (==) <$> abcNtkCiNum n1 <*> abcNtkCiNum n2 
17:51:05 <ksf> assertions get disabled by default if you enable optimisation, but you can pass a flag to keep them in.
17:51:43 <ezyang> I'm afraid of turning (`assert` return ()) =<< into something prettier in fear of messing up the trace 
17:53:39 <hpc> ezyang: it would be nice if Haskell had "stack trace" output
17:54:53 <ezyang> Yeah, it's in the wrong place. 
17:55:10 <ezyang> It would be convenient for debugging developer error, yes. 
17:55:26 <ezyang> Anyway, the correct thing to do is encode this into the type system, but I suspect it'll be too complicated for mortals to use then. 
17:55:38 <hpc> it would even be nice for debugging evaluation order without having oodles of traces
17:56:27 <ddarius> hpc: See "Omniscient Debugging" and also Buddha and Hat.
17:57:45 <c_wraith> What was the library that transparently forkIOs an action and puts its result into an MVar?
17:58:42 <c_wraith> (except reading the mvar is done behind the scenes, as with unsafeInterleaveIO, so you never actually see the mvar?)
18:00:36 <Axman6> c_wraith: unamb?
18:01:36 <Saizan> IVar ?
18:01:39 <c_wraith> Axman6, no, this is something different
18:02:33 <c_wraith> IVar isn't it either.  People were talking about this lib a couple days ago.
18:03:23 <c_wraith> It really just wraps the create mvar, forkIO, read mvar pattern, in such a way that it won't block until you force the return value
18:04:12 <ddarius> Sounds like some kind of ad-hoc implementation of futures.
18:04:18 <c_wraith> it was.
18:04:21 <kumar> shapr: y0
18:04:41 <c_wraith> In fact, I could probably implement it on like 3 lines. :)
18:04:43 <monochrom> "the future is here" <duck>
18:06:13 <c_wraith> future a = do { x <- newEmptyMVar ; forkIO (a >>= putMVar x) ; unsafeInterleaveIO (readMVar x) }
18:07:11 <c_wraith> Might need to be more subtle to handle various error conditions.  might not!
18:07:18 <danharaj> Is unsafeInterleaveIO actually safe in those lines?
18:07:30 <c_wraith> depends entirely on what a is
18:07:41 <danharaj> sounds sticky
18:07:53 <monochrom> yeah, not for casual use
18:08:40 <monochrom> or paradoxically for casual use only, since only casual use is safe :)
18:09:10 <danharaj> It would be nice if a library could give you safety guarantees.
18:09:26 <soupdragon> how can I do a 2x2 matrix in lambdabot?
18:09:47 <soupdragon> (2 1;1 1)^n
18:10:42 <jesusabdullah> You want to multiply matrices?
18:10:49 <soupdragon> > let f (x,y) = (2x+y,x+y) in (f.f.f.f.f.f.f.f.f.f) (0,1)
18:10:50 <lambdabot>   (165,265)
18:10:51 <soupdragon> > let f (x,y) = (2x+y,x+y) in (f.f.f.f.f.f.f.f.f.f) (1,0)
18:10:52 <jesusabdullah> Does lambdabot have hmatrix?
18:10:52 <lambdabot>   (144,231)
18:11:05 <soupdragon> > 265/231 ::CReal
18:11:06 <lambdabot>   1.1471861471861471861471861471861471861472
18:11:13 <gwern> jesusabdullah: no
18:11:13 <soupdragon> > 165/144 ::CReal
18:11:14 <lambdabot>   1.1458333333333333333333333333333333333333
18:11:18 <soupdragon> doesn't seem to have worked
18:11:34 <jesusabdullah> man I'm lame
18:12:06 <soupdragon> > let f (x,y) = (2x+y,x+y) in (f.f.f.f.f.f.f.f.f.f) (1,1)
18:12:07 <lambdabot>   (199,320)
18:12:12 <jesusabdullah> I can talk intelligently about a lot of the libraries and yet haven't even seriously coded in haskell yet >_<
18:12:15 <jesusabdullah> <--lame
18:13:57 <soupdragon> http://tilings.math.uni-bielefeld.de/Files/maloney7fold.gif
18:14:34 <soupdragon> > (sin(pi/7), sin(2*pi/7), sin(3*pi/7))::(CReal,CReal,CReal)
18:14:35 <lambdabot>   (0.43388373911755812047576833284835875461,0.7818314824680298087084445266740...
18:16:01 <Veinor> soupdragon: what on earth is that?
18:16:13 <Veinor> it looks like penrose tiles
18:16:21 <soupdragon> yes except with 7-fold instead of 5-fold symmetry
18:16:44 <Veinor> neat.
18:17:13 <Axman6> > let f (x,y) = (y,x+y) in iterate f (0,1)
18:17:13 <lambdabot>   [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89)...
18:17:24 <Axman6> > let f (x,y) = (y,x+y) in map fst $ iterate f (0,1)
18:17:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:17:44 <soupdragon> > 320-199
18:17:44 <lambdabot>   121
18:18:39 <gwern> huh. that does look pretty strange
18:19:44 <krey> Axman6: use zipWith (+) for ownage
18:22:47 <jesusabdullah> > zipWith (+) [0,1]
18:22:48 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
18:22:48 <lambdabot>    arising from a use ...
18:23:05 <jesusabdullah> @help
18:23:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:23:11 <jesusabdullah> @list
18:23:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:24:54 <jesusabdullah> TOO MANY
18:24:57 <jesusabdullah> *gives up*
18:25:56 <jesusabdullah> oh
18:26:01 <jesusabdullah> duh
18:26:22 <krey> let fibs = zipWith (+) (0:fibs) (0:1:fibs)
18:26:26 <jesusabdullah> > zipWith (+) [0 1] [1 1]
18:26:27 <lambdabot>   [1]
18:26:29 <krey> fibs = zipWith (+) (0:fibs) (0:1:fibs)
18:26:33 <jesusabdullah> damn!
18:26:36 <krey> > fibs = zipWith (+) (0:fibs) (0:1:fibs)
18:26:37 <lambdabot>   <no location info>: parse error on input `='
18:26:43 <krey> > let fibs = zipWith (+) (0:fibs) (0:1:fibs)
18:26:44 <lambdabot>   not an expression: `let fibs = zipWith (+) (0:fibs) (0:1:fibs)'
18:27:16 <jesusabdullah> > zipWith (+) [0,1] [1,1]
18:27:17 <lambdabot>   [1,2]
18:27:24 <krey> > let fibs = zipWith (+) (0:fibs) (0:1:fibs) in fibs
18:27:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:27:27 * jesusabdullah had been matlabbing earlier today
18:27:30 <jesusabdullah> Nice
18:27:48 <brad_larsen> There are things like QuickCheck that perform random testing of properties of Haskell functions.  Can anyone give me pointers to work that connects a theorem prover with Haskell, with the goal of being able to possibly automatically *prove* that certain properties hold of a function?
18:28:25 <brad_larsen> I am only very vaguely aware of things like SMT solvers.  Somewhat more familiar with SAT solvers.
18:28:45 <brad_larsen> I'm curious about the feasibility of such a tool.
18:29:34 <brad_larsen> (i.e. a Haskell library that would use an automated theorem prover to try to verify QuickCheck-like properties)
18:30:42 <gwern> brad_larsen: I think when you need heavy duty proofs like that you usually write in coq or agda and compile to haskell
18:31:16 <brad_larsen> gwern: yes, I have been meaning to play around with Coq and Agda.
18:31:27 <danharaj> Coq is supposed to have extraction to haskell, no?
18:31:45 <brad_larsen> I'm wondering how feasible it would be to do it all in a Haskell library.
18:31:49 <soupdragon> yes it does
18:32:02 <soupdragon> you can erase the proofs and compile to haskell
18:33:02 <gwern> brad_larsen: but as far as in-haskell goes, quickcheck, hunit, and smallcheck and the type system are our tools of choice 
18:37:16 <brad_larsen> gwern:  Yes yes, I know.  But it sure would be nice if you could write QuickCheck-like properties all in Haskell, and simply run `verifyProperty propertyFoo' and either be told categorically whether or not the property holds (or whether it could not be determined).
18:42:29 <brad_larsen> Can anyone recommend a good intro paper to SMT solvers?
19:02:32 <aakarsh> shouldnt  this work ? zipWith  (\x y -> x ++ y)  "foo" "bar"
19:02:46 <soupdragon> aakarsh let me ask you something
19:02:54 <soupdragon> supposing it worked, what would it do?
19:03:11 <aakarsh> fboaro
19:03:21 <aakarsh> i am gussing
19:03:22 <soupdragon> hmm
19:03:39 <soupdragon> let me say a property of zipWith
19:03:56 <soupdragon> if you have  result = zipWith f a b,  the length of result is equal to the smallest length of a or b
19:04:11 <soupdragon> so you can never get a bigger list than you started with, using zipWith
19:04:14 <aakarsh> ah
19:04:48 <aakarsh> but if they are eq len 
19:04:55 <aakarsh> should sort of work ?
19:05:52 <ddarius> aakarsh: That code is a type error.  It will never work.
19:05:59 <akosch> ++ works only on lists, not single chars, right?
19:06:02 <aakarsh> Couldn't match expected type `[a]' against inferred type `Char'
19:06:10 <ddarius> akosch: Yes.
19:06:10 <gwern> akosch: aye, you may be thinking of :
19:06:10 <aakarsh> k
19:06:43 <JoeyA> > (\x y -> x ++ y)  "foo" "bar"
19:06:44 <lambdabot>   "foobar"
19:06:53 <JoeyA> > zipWith  (\x y -> x ++ y)  ["foo"] ["bar"]
19:06:54 <lambdabot>   ["foobar"]
19:07:27 <JoeyA> > zipWith (\x y -> [x] ++ [y]) "foo" "bar"
19:07:28 <lambdabot>   ["fb","oa","or"]
19:08:34 <aakarsh> i guess the last one is sort of there i just need to join it back
19:08:51 <JoeyA> > zipWith (\x y -> x : y) "foo" [" a", " b", " z"]
19:08:52 <lambdabot>   ["f a","o b","o z"]
19:18:58 <dmwit> > zipWith ($) [f, o, o] [a, b, z]
19:18:59 <lambdabot>   Ambiguous occurrence `f'
19:18:59 <lambdabot>  It could refer to either `L.f', defined at <local...
19:19:06 <dmwit> ?undefine
19:19:10 <dmwit> > zipWith ($) [f, o, o] [a, b, z]
19:19:11 <lambdabot>   Couldn't match expected type `b -> b1'
19:19:11 <lambdabot>         against inferred type `Simpl...
19:19:30 <dmwit> oh
19:19:42 <dmwit> > zipWith fun "foo" [a, b, z]
19:19:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:19:43 <lambdabot>         against inferred ty...
19:20:01 <dmwit> > zipWith (fun . (:[])) "foo" [a, b, z]
19:20:02 <lambdabot>   Ambiguous type variable `c' in the constraints:
19:20:02 <lambdabot>    `GHC.Show.Show c'
19:20:02 <lambdabot>      a...
19:20:08 <dmwit> this joke isn't fun any more
19:20:09 <krey> zipWith ($) is always funs
19:20:37 <dmwit> > zipWith (fun . (:[])) "foo" [a, b, z] :: [Expr] -- okay, one more try
19:20:38 <lambdabot>   [f a,o b,o z]
19:20:41 <c_wraith> you might as well zipWith id for the sake of unreadable code :)
19:21:10 <krey> c_wraith: but how?
19:21:21 <c_wraith> :t zipWith id
19:21:21 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
19:21:27 <c_wraith> :t zipWith ($)
19:21:27 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
19:21:57 <c_wraith> $ is just a special case of id.
19:22:51 <krey> but the types?!
19:22:55 <krey> :t id
19:22:56 <lambdabot> forall a. a -> a
19:23:03 <krey> :t zipWith
19:23:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
19:23:04 <JoeyA> :t fun
19:23:05 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
19:23:55 <aakarsh> how come there isa forall in the type signature ?
19:24:00 <aakarsh> when to we get that
19:24:17 <aavogt> when you enable an extension with ghc
19:24:26 <krey> god hates existential types!
19:24:29 <aavogt> it doesn't mean anything here
19:25:00 <davidL> > zipWith ($) [f,g,h] [a,b,c] :: [Expr]
19:25:00 <lambdabot>   [f a,g b,h c]
19:25:07 <gwern> I don't know why ghc prints those outs when you haven't asked for them
19:25:27 <aavogt> gwern: but somebody has asked that \bot does so
19:25:30 <dmwit> Turning on a particular extension is tantamount to asking for them, I guess.
19:25:46 <gwern> mm, must be a -fglasgow-exts or somewhere
19:25:48 <c_wraith> krey: it's easier to think about ($) and id.  ($) is (a -> b) -> a -> b.  You can add parens without changing the meaning to make it (a -> b) -> (a -> b).  It should be clear, then, that it's a special case of id.
19:30:54 <aavogt> http://www.haskell.org/ghc/docs/6.12-latest/html/users_guide/ghc-language-features.html
19:31:15 <aavogt> supposedly there's an -XPrintExplicitForalls as part of -fglasgow-exts, but ghci doesn't like that one
19:31:59 <krey> c_wraith: that's pretty funky
19:32:25 <aavogt> :k id
19:32:26 <lambdabot> Not in scope: type variable `id'
19:32:47 <aavogt> :k a -> a
19:32:48 <lambdabot> Not in scope: type variable `a'
19:32:48 <lambdabot> Not in scope: type variable `a'
19:32:55 <aavogt> :k forall a. a -> a
19:32:56 <lambdabot> *
19:38:44 <heatsink> :k (->)
19:38:45 <lambdabot> ?? -> ? -> *
19:39:04 <heatsink> :k (# ,, #)
19:39:04 <lambdabot> ? -> ? -> ? -> (#)
19:40:04 <wli> Is there a way to include multiple lhs2TeX -generated LaTeX files in a single LaTeX document?
19:44:38 <dmwit> wli: Well, I guess there's tex's include command. But I take it lhs2TeX generates the document headers and stuff, too?
19:45:06 <wli> dmwit: Yeah, that's where the problem is. The headers/etc. clash.
19:45:23 <wli> dmwit: Not \documentclass -type stuff but other things.
19:46:27 <dmwit> Well, I can think of half a dozen hacky ways to do it. I assume you've already checked the documentation for a -no-headers flag or something.
19:47:10 <wli> Not recently but --help doesn't show such a flag existing.
19:54:28 <wli> dmwit: It's stuff re-included from polycode.fmt
19:55:10 <dmwit> You could redefine all the problematic commands, include the two things, then put the definitions back...
19:55:52 <dmwit> You could have an own post-processing pass where you just cut out the first ten lines (or whatever) of the two files.
19:56:28 <dmwit> You could try to do some half-assed TeX parsing and filter out the objectionable bits.
19:56:45 <wli> I'm not even sure what to cut out at this point. It's been a while since the last time I tried.
19:57:14 <dmwit> hm
19:57:19 <dmwit> I'm underqualified for that part. =P
19:57:41 <wli> It does look like there's a huge amount of boilerplate involved.
19:58:53 <wli> dmwit: 259 lines it looks like
19:58:57 <dmwit> ouch
19:59:19 <aavogt> The document consists of multiple ???les. Can lhs2TeX be used? One option is
19:59:20 <aavogt> A
19:59:22 <aavogt> to use %include rather than L TEX commands to include all ???les in the master ???le.
19:59:34 <wli> dmwit: depends, if it's just trimming the first 259 off and reinserting it only once somewhere appropriate then I'm home free.
19:59:44 <wli> aavogt: What version of lhs2TeX is that?
19:59:58 <aavogt> the most recent one?
20:00:00 * wli has 1.15
20:00:51 <aavogt> read the last section in the manual then
20:01:30 * aavogt can't build lhs2tex due to Cabal incompatibilities
20:03:49 <wli> aavogt: What's the last section in the manual called?
20:03:57 <aavogt> pitfalls
20:04:15 <aavogt> or search for the text I copy-pasted
20:06:00 <wli> aavogt: I think I'm doing what they say but it's not actually working.
20:09:23 <ddarius> > let f x y = f' 1 1 (x+y); f' a b 1 = (a,b); f' a b c = f' (a-q) (b+1) (r+y) where (q,r) = divMod c x in f 8 13 
20:09:29 <lambdabot>   mueval: ExitFailure 1
20:12:58 <wli> aavogt: Yeah, the output/etc. is pathological with the %include 
20:15:37 <aavogt> sorry wli, my limited use of lhs2tex has only been with documents that fit in a single file
20:17:13 <tensorpudding> @pl \(a,b) c -> f a b c
20:17:13 <lambdabot> uncurry f
20:17:21 <wli> aavogt: You mean single-module documents?
20:18:30 <wli> Anyway, using %include instead of \include seems to incorporate the things but with lots of weird side effects.
20:18:47 * wli isn't even sure what %include is.
20:19:56 <aavogt> yes. One module. One file.
20:23:25 <ksf> what do you guys think about building a gui library on top of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.58.7505&rep=rep1&type=pdf?
20:24:03 <dmwit> No document with DOI 10.1.1.58.7505?
20:24:14 <dmwit> I think that would be a lousy GUI. ;-)
20:24:34 <ksf> huh?
20:25:36 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.7505
20:26:51 <dmwit> I have often pondered the possibility that GUI's could be based on lenses or some other bidirectional language.
20:27:58 <aavogt> GUIs that go both ways?
20:28:17 <dmwit> nah
20:28:26 <dmwit> It's a lens between the data in memory and the GUI.
20:28:39 <dmwit> changes to the GUI (i.e. moving the sliders) -> changing the data in memory
20:28:46 <dmwit> changing the data in memory -> changes to the GUI
20:29:20 <aavogt> hmm, except in IO
20:29:35 <ksf> operationally, the gui would be displayed, changes to it could be made, and the updated structure is passed into your program, which outputs a new gui to display
20:30:10 <ksf> you could do ReaderT WriterT or StateT
20:30:20 <ksf> WriterT Reader?
20:30:25 <dmwit> aavogt: in the GUI monad or arrow or whatever (what is this IO trash ;-)
20:30:27 * ksf is too lazy to think about that.
20:30:37 <ksf> I think it doesn't matter.
20:31:05 <aavogt> dmwit: eventually you gotta put it in there :)
20:31:35 <dmwit> ksf: Anyway, cool paper, I've printed it and added it to my reading pile. =)
20:31:45 <mtnviewmark_> I built a system like that in the 90s - in it changing the window composition changed the class def and vice versatile as well
20:33:18 <ksf> in other news, I still have no idea how to best go about rewriting graphs in haskell.
20:36:08 <tensorpudding> sometimes haskell just isn't very fun
20:36:35 <mtnviewmark_> blasphemy 
20:36:44 <dmwit> ksf: Well, there's all kinds of literature on graph rewriting formalisms.
20:36:54 <dmwit> ksf: But nobody knows how to do it bidirectionally, if that's what you're looking for.
20:37:09 <dmwit> Lot's of people are working towards it, though (including me =).
20:38:08 <ksf> I don't even need bidi, I just stumbled across the paper
20:38:26 <ksf> I'd be content with a vanilla rewriting framework
20:38:31 <scotty> I'm just reading about the Read class.  I was wondering, do people commonly serialize things using Read and Show?
20:38:40 <tensorpudding> I find myself wanting class variables
20:38:54 <ksf> fgl feels like coding assembly
20:39:06 <ksf> scotty, depends
20:39:20 <ksf> read is known for utterly unhelpful error messages
20:39:32 <ksf> but it works fine for quick+dirty serialisation
20:39:42 <scotty> ksf: Okay
20:40:02 <ksf> if you need more speed and better space usage, there's data.binary and cereal etc.
20:40:16 <ksf> oh, and a couple of xml libraries.
20:40:18 <scotty> ksf: I haven't read too deeply.  There's just a little bit of info in the Gentle Intro tutorial.
20:40:59 <scotty> ksf: cereal? lol
20:41:24 <scotty> ksf: I see.
20:42:22 <ksf> but then, xmonad serialises its state via show and passes it on the commandline on restart.
20:45:50 <tensorpudding> would it be possible to add quantification over typeclasses?
20:46:43 <scotty> What is this notation?: readsTree s             =  [(Leaf x, t)     | (x,t)      <- reads s]
20:46:52 <scotty> Is it like "where"?
20:46:54 <tensorpudding> scotty: that's a list comprehension notation
20:47:04 <scotty> tensorpudding: Oh!
20:47:05 <tensorpudding> it can be finessed into do notation in the list monad
20:47:19 <tensorpudding> the <- means basically the same thing
20:47:27 <heatsink> tensorpudding: What would you use it for?
20:47:46 <scotty> tensorpudding: I've seen it before.  I just didn't recognize it for some reason.
20:47:48 <heatsink> typeclass quantification I mean
20:47:56 <tensorpudding> it's mostly an idle question
20:48:28 <tensorpudding> but i was configuring my Xmonad, and made a stupid mistake by putting all my different per-workspace layouts in a list
20:48:49 <dmwit> tensorpudding: You can do typeclasses "by hand", and then of course you could quantify over those...
20:48:52 <scotty> tensorpudding: I think because "reads s" will produce a one-element list.
20:48:54 <tensorpudding> the layouts all have different types, but they all belong to a typeclass that allows them to work as layouts
20:50:00 <tensorpudding> so i played around with a heterogenous list type using GADTs and Rank2Types
20:50:35 <tensorpudding> where the typeclass in that instance was Show
20:50:51 <tensorpudding> and then there was a show function that recursed the list, showing each
20:51:36 <heatsink> Would a list of (exists a. Show a => a) be sufficient?
20:51:38 <scotty> Wow, this is so above my head. XD
20:51:39 <tensorpudding> but i thought "writing one of these for each typeclass would be annoying"
20:52:01 <tensorpudding> Hmm, I wasn't thinking about existentials
20:52:46 <tensorpudding> That would streamline things quite a bit
20:53:17 <robertmassaioli> scotty: don't worry sometimes it is a little like this: (image) http://lh5.ggpht.com/_h7TIamoOTk0/S0e_cfSICzI/AAAAAAAAAFY/IekbZD8VjWU/s1600/programmers.jpg
20:54:01 <heatsink> heh
20:54:15 <tensorpudding> It still doesn't solve the issue but it's a bit cleaner
20:57:24 <tensorpudding> Is that exists keyword valid?
20:57:43 <heatsink> no, you need to define a data constructor for it
20:57:44 <gwern> it can be if you want it to be
20:58:25 <heatsink> data Showable = forall a. Show a => Showable a
20:58:59 <heatsink> data Showable where Showable :: Show a => a -> Showable
21:02:15 <heatsink> gwern: Very much enjoyed that Harry Potter fic.
21:02:22 <heatsink> gwern++
21:03:08 <blackdog> heatsink: was that eliezer's?
21:04:53 <heatsink> yea
21:06:41 <ddarius> > let f !x = x in f 3
21:06:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:06:43 <lambdabot>    `SimpleReflect.FromExpr ...
21:06:43 <scotty> I have a question regarding the readsTree function which uses lex on this page: http://www.haskell.org/tutorial/stdclasses.html
21:07:06 <scotty> I don't understand why they use the concatenation.
21:07:53 <ddarius> @let egcd x y = egcd' 1 1 (x+y) where egcd' a b c = if r == 1 then (a-q,b) else egcd' (a-q) (b+1) (r+y) where (q,r) = divMod c x
21:07:55 <lambdabot>  Defined.
21:08:00 <ddarius> > egcd 13 8
21:08:01 <lambdabot>   (-3,5)
21:08:54 <ddarius> > egcd 2 4
21:08:58 <lambdabot>   mueval-core: Time limit exceeded
21:11:10 <ddarius> @undefine
21:16:53 <scotty> kmc!
21:17:00 <scotty> I recognize you!
21:17:34 <kmc> :O
21:17:57 <kmc> that's cool
21:17:58 <scotty> I sometimes use "scott".
21:20:48 <kmc> were you at BHUG?
21:22:04 * kmc is terrible with names
21:22:17 <scotty> I don't know what that is.  I've just seen you on this channel before.
21:22:25 <kmc> ah cool :)
21:22:30 <kmc> BHUG is the Boston Haskell User's Group
21:22:33 <kmc> we had a meeting tonight
21:22:36 <scotty> Cool!
21:22:57 <scotty> I wish there a Haskell group in my city.
21:23:04 <scotty> *was a
21:23:09 <jesusabdullah> which is that?
21:23:31 <scotty> Austin
21:24:03 <scotty> Ooh, there is a Functional Programmers group it seems.
21:27:02 <Peaker> I talk to my coworkers about Haskell whether they want to or not, so we've got a little Haskell group :)
21:27:17 <thaostra> ehh
21:28:42 <scotty> Peaker: Hehe... You should just ask your boss if you can do work in Haskell!
21:29:44 <Peaker> scotty, I already do some small scripts/etc in Haskell.. Was working on replacing our build system in Haskell, ton to somlse.
21:30:16 <scotty> Peaker: Are the coworkers you talk to also programmers?
21:30:54 <Peaker> scotty, Yeah, of course
21:31:11 <Peaker> some of them are also Haskell fans now. Some don't have the energies to read tutorials/etc
21:31:45 <scotty> Peaker: You just have to show them really cool things in Haskell!
21:31:55 <Peaker> scotty, which ones?
21:32:11 <Peaker> my problem with that - is that typically you have to explain all the syntax, type-classes, before you can show any cool code
21:32:16 <Peaker> Well, most cool code
21:32:37 <scotty> Peaker: I thought the quicksort for brevity was cool.
21:32:56 <Peaker> It's nice, but IMO it's not that exciting
21:33:05 <danharaj> it also misses the point of quicksort
21:33:08 <danharaj> the 'quick' part.
21:33:08 <Peaker> It's not much longer to write a similar quicksort in Python
21:33:32 <scotty> Peaker: What about the fibonacci sequence that's defined as an infinite list?
21:33:51 <kmc> there are lots of cool things that don't require type classes, or laziness
21:34:03 <kmc> in that there are lots of cool things in "classical FP" that are not widely appreciated
21:34:15 <scotty> I think infinite lists are pretty cool in general.
21:34:37 <Peaker> scotty, That's also nice, but not that exciting (Python generators do that too)
21:34:54 <kmc> yeah
21:34:56 <Peaker> kmc, well, Python has basic FP stuff, so it won't excite people to show them stuff Python can already do
21:34:59 <scotty> Peaker: I guess the issue is that I went from knowing C++ to learning Haskell.
21:35:03 <danharaj> Peaker: How about the fact that it is statically typed and has real semantics instead of the mess that is python?
21:35:04 <danharaj> :p
21:35:13 <Peaker> If I am to excite Python people, I need to show stuff Haskell can and Python can't
21:35:17 <scotty> danharaj: That's why I never learned Python.
21:35:21 <Peaker> danharaj, Yeah, that's the part I want to show
21:35:28 <Peaker> danharaj, however, that takes a lot of explaining-the-basics first
21:35:30 <kmc> python semantics aren't too bad
21:35:31 <danharaj> Write a language interpreter w/ parsec
21:35:32 <scotty> Haskell is my Python, basically.
21:35:48 <scotty> Haskell is the functional language I chose to learn.
21:35:55 <mtnviewmark> no no no - the way I turned heads a work was by showing a fully implemented REST data service with MySQL backend
21:36:27 <kmc> needs more AJAX and XML-RPC
21:36:39 <mtnviewmark> similar foot print to the Python version of the same service, though even if you don't know Haskell, the code looks more clear
21:37:04 <mtnviewmark> and the fact that it ran 6x faster with no significant performance tuning helped
21:37:24 <mtnviewmark> well, perhaps not XML-RPC....
21:37:29 <mtnviewmark> something JSON based....
21:37:30 <scotty> How can you convince a Python programmer that static typing is important?
21:37:50 <scotty> Surely they write buggy Python.
21:37:54 <kmc> "but i know that i don't make mistakes!"
21:38:01 <kmc> "static types just exist to restrict me!"
21:38:03 <Peaker> mtnviewmark, cool
21:38:05 <kmc> yes, yes they do
21:38:17 <Peaker> scotty, Python programmers are well aware of the disadvantages of dynamic typing
21:38:22 <mtnviewmark> because you show how it expresses the intent of the program clearly
21:38:34 <mtnviewmark> whereas often it is nowhere expressed in the python at all!
21:38:39 <scotty> Wait, is Python interpreted-only?
21:38:41 <Rotaerk> Peaker, not necessarily :P
21:38:49 <Peaker> scotty, I liked Python very much before Haskell, because type systems I knew before Python (C, C++, Java, ..) all stood in my way, so I preferred the bugginess of no types to the restrictiveness of types
21:38:51 <Rotaerk> they might suffer the consequences without realizing
21:38:56 <heatsink> scotty: For practical purposes, yes.  Compiling doesn't make it much faster.
21:38:58 <kmc> scotty, there have been various experimental Python compilers
21:39:01 <mtnviewmark> scotty - generally executed from byte-code
21:39:12 <kmc> it's not in the language spec "Thou shalt be interpreted"
21:39:21 <scotty> So Haskell has the advantage of being fast when compiled!
21:39:30 <kmc> and i don't agree with heatsink
21:39:30 <scotty> Isn't that enough to convince them?
21:39:47 <kmc> i think a good Python compiler could produce much faster code
21:39:53 <kmc> especially if it's online tracing JIT
21:39:58 <mtnviewmark> Peaker - you have expressed my experience exactly -- I was once an early acolyte of Smalltalk (even worked on Apple Smalltalk) 
21:40:05 <kmc> there are already good tracing JIT compilers for JavaScript and Lua
21:40:09 <scotty> Can you call Python functions in C?
21:40:12 <kmc> yes
21:40:24 <kmc> remember, CPython has some critical flaws with regard to concurrency
21:40:33 <kmc> which has nothing to do with the fact that it's an interpreter
21:40:37 <kmc> just fixing that is a huge deal
21:40:42 <Peaker> mtnviewmark, Yeah, the awesome thing about Haskell is types that help rather than annoy
21:40:47 <kmc> (see: stackless python, ironpython, berp, etc)
21:40:48 <mtnviewmark> scotty - speed of execution is often not critical - especially in today's web settings
21:41:03 <Peaker> kmc, CPython wasn't meant to write high-performance programs, so parallelism isn't that important
21:41:25 <scotty> Oh yeah, does Python have all the Parallel libraries that Haskell has?
21:41:34 <kmc> Peaker, ok
21:41:47 <kmc> CPython wasn't meant to be good, so being good isn't that important ;P
21:42:00 <mtnviewmark> The value of dynamic typing was always that it was faster to develop, and more concise to express....
21:42:03 <Peaker> kmc, Not in that aspect, no :)
21:42:07 <mtnviewmark> but Haskell blows that alway
21:42:13 <scotty> Or, in general, does Python have libraries to match Haskell's?
21:42:15 <mtnviewmark> s/l//
21:42:18 <heatsink> kmc: Yeah, jitting could make it much faster.  Psyco demonstrated that you could get ehough useful dynamic information for that.
21:42:24 <Peaker> mtnviewmark, What's Haske? :-)
21:42:25 <kmc> Python has tons of libraries
21:42:29 <kmc> some much better than Haskell equivalents
21:42:31 <kmc> some not
21:42:58 <danharaj> I have heard stories of poorly documented python libraries
21:43:07 <tensorpudding> Why is it that Haddock-generated docs, when there is the type signature for a function where each term is listed on a separate line with a comment to the right, that the comments never line up with the part of the signature they actually refer to?
21:43:13 <kmc> tensorpudding, bug
21:43:16 <kmc> known bug :/
21:43:20 <scotty> Someday I might learn Python.  Maybe I'll be the guy who knows Haskell and doesn't want to read all those Python tutorials. XD
21:43:32 <Peaker> scotty, heh
21:43:33 <mtnviewmark> indeed - but Haskell finally has "enough" libraries - it's over the hump (at least for my real world use)
21:43:36 <heatsink> Does Python have a well-defined semantics?  It looks to me like the language semantics is mixed up with the object model, and the behavior of Python objects is complex and not clearly specified.
21:43:40 <mtnviewmark> fixed in the repo version
21:43:46 <kmc> the behavior of Python objects is not that complex
21:43:49 <kmc> they are mostly just dictionaries
21:44:01 <Peaker> heatsink, I think Python mainly has "operational semantics", sort of like C and other imperative languages. Not denotational semantics
21:44:02 <mtnviewmark> yes, but the full semantics is hard to implement efficiently
21:44:19 <tensorpudding> kmc: it's inexcusable
21:44:22 <heatsink> kmc: Under what conditions am I allowed to assign __class__?
21:44:25 <tensorpudding> Every time I see it I rage.
21:44:32 <scotty> Oh, Python is not purely functional either, right?
21:44:34 <tensorpudding> Because I forget about it
21:44:37 <tensorpudding> and then get confused
21:44:39 <Peaker> mtnviewmark, Python semantics seem to be defined to spite those that want performance :) You must expose __dict__ as a real dict, and stuff that leave compiler writes too little freedom to optimize
21:44:43 <Peaker> scotty, nope
21:44:47 <kmc> "purely functional" is a pretty misunderstood concept iom
21:44:49 <kmc> imo*
21:45:00 <danharaj> declarative is more descriptive
21:45:04 <mtnviewmark> Peaker - exactly - in theory you could whole program analyize those away in most cases
21:45:06 <kmc> heatsink, don't know about thatone
21:45:15 <mtnviewmark> or perhaps only dynamically revert to them when needed
21:45:20 <mtnviewmark> but it would be a major pain
21:45:40 <Peaker> mtnviewmark, It's pretty hard, especially in programs that make use of hetero-containers
21:45:42 * mtnviewmark <- has implemented about half a dozen dynamic language virtual machines commerically
21:45:48 <Peaker> mtnviewmark, (Which is almost all Python programs..)
21:45:52 * mtnviewmark none of them were Python!
21:45:58 <Peaker> mtnviewmark, that sounds cool
21:46:11 <ezyang> I finished my writeup of the tech talk Galois had today "Static Analysis at Mozilla". If anyone wants to help me revise a draft I have of it, lemme know. 
21:46:23 <Peaker> mtnviewmark, Doesn't using hetero-containers (e.g: Lots of __getattr__ calls) make it near-impossible to do whole-program analysis?
21:46:33 * kmc thinks most uses of heterogenous containers in dynamically typed languages are essentially abusing the type system
21:46:38 <mtnviewmark> yes
21:46:57 <heatsink> kmc: It's possible to create an object and then reassign its type.  But only in some circumstances that ensure that the physical data layout is consistent, I forget what they are exactly.
21:46:59 <mtnviewmark> I actually wouldn't attempt it for Python - though I believe some have
21:47:14 <scotty> Does Python make any effort to keep the imperative stuff separate from the functional stuff?
21:47:24 <danharaj> http://teddziuba.com/2008/12/python-makes-me-nervous.html
21:47:25 <mtnviewmark> what functional stuff?? :-)
21:47:27 <kmc> no, neither does Haskell
21:47:30 <kmc> we integrate them tightly
21:47:34 <danharaj> this is my favorite post about python on the whole interwebs
21:47:43 <kmc> which is different from pretending they're the same
21:48:04 <ezyang> cool! 
21:48:13 <scotty> kmc: I read this today in the Tutorial: "The monad cleanly separates the functional and imperative program components."
21:48:24 <kmc> yeah
21:49:05 <kmc> i take issue with that presentation somewhat
21:49:08 * ksf has the nasty feeling that he's over his head into maths.
21:49:09 <kmc> but it's also mostly correct
21:49:11 <ezyang> mix 
21:49:29 <heatsink> The list data type cleanly separates the list and non-list program components.
21:49:42 <danharaj> Monadic IO == side effects are encoded in the type system.
21:49:49 <mtnviewmark> Heh: "Do other Pythonistas drop a Valium before they begin the day?"
21:49:54 <mtnviewmark> Yes, yes they do.
21:50:08 <kmc> heatsink, right
21:50:17 <kmc> danharaj, not really
21:50:36 <scotty> kmc: Can you elaborate on your distinction?
21:50:37 <ksf> can anybody tell me what to read to understand the limits of extracting fixpoints from a kleene algebra written with open recursion?
21:50:38 <mtnviewmark> scotty, i wish that could read "the monad can be used to ...."
21:50:45 <mtnviewmark> unless they were specifically talking about IO
21:50:49 <ksf> (that is, locate those kleene stars)
21:50:59 <scotty> mtnviewmark: It was in the IO section.
21:51:09 <kmc> scotty, the thing to avoid is the myth that functional programming techniques aren't useful in imperative programming, and vice versa
21:51:25 <mtnviewmark> "Twinkle, twinkle, kleene star..."
21:51:26 <kmc> "functions" and "steps to perform" are obviously different things
21:51:36 <danharaj> kmc: why not?
21:51:43 <kmc> just as characters and booleans are obviously different things
21:51:48 <kmc> in this sense, yes, Haskell separates them
21:52:05 <kmc> but that's not to say you couldn't have a useful function that takes a character, and returns a boolean
21:52:21 <kmc> or that you have to separate your thinking into the "character processing" part of your program and the "boolean processing" part
21:52:28 <scotty> Right
21:52:35 <ksf> for once, one could be doing applicative IO.
21:52:36 <scotty> The tutorial demonstrates this.
21:52:47 <ksf> or even pure (lazy) IO.
21:52:50 <scotty> At least, I think it demonstrates what you're getting at.
21:53:12 <ksf> the problem with IO usuall is that you want to have precise control over when things are executed...
21:53:17 <kmc> good imperative Haskell code is full of higher-order functions and actions, algebraic data and pattern matching, laziness, and all the other usual FP tricks
21:53:26 <scotty> sequence_        =  foldr (>>) (return ())
21:53:47 <kmc> this is what makes Haskell actually a good imperative language, and not just a functional language that happens to support imperative programming as a compromise
21:53:54 <kmc> the latter being how it's often presented
21:54:04 <ksf> sequence'_ = foldr (*>) (pure ())
21:54:09 <ksf> you don't need monads to do that.
21:55:39 <scotty> This was just an example provided in the tutorial.  I was just trying to find an example which combines functional and imperative programming.
21:55:54 <kmc> that's a decent example
21:55:59 <kmc> i like it :)
21:56:14 <Peaker> @type foldr (liftA2 (:)) (pure [])
21:56:15 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
21:56:16 <scotty> I'm sure there are more advanced ones, but I doubt I understand those yet!
21:56:26 <scotty> I'm still making my way through the tutorial.
21:56:36 <kmc> danharaj, "side effects are encoded in the type system" makes it sound like every type is a pair of (what's the data, does it have side effects)
21:56:40 <kmc> this is indeed how some type systems work
21:57:04 <kmc> effects are just another Haskell type, they're not encoded specially or attached to other types specially
21:57:06 <ksf> Peaker, hey, I've patented that, already.
21:57:10 <ksf> it's called "chain"
21:57:18 <kmc> anyway i am pretty pedantic about this yes ;)
21:58:31 <ksf> arguably the IO monad could be more strongly typed.
21:58:38 <ksf> that is, there could be more than one of it.
21:59:55 <kmc> yes
22:00:00 <ksf> actually, haskell is the only imperative language there is.
22:00:08 <kmc> to classify effects more precisely
22:00:20 <ksf> if functional languages are those with first-class functions and imperative languages those with first-class actions.
22:00:23 <kmc> putStr :: (MonadIO m) => String -> m ()
22:00:35 <kmc> forkIO :: (MonadConc m) => m a - > m ThreadId
22:00:50 <Peaker> ksf, that's not true.. "Functions" of no args in other languages are actions, and they're usable "first-class"
22:01:05 <kmc> listenOn :: (MonadNet m) => PortID -> m Socket
22:01:12 <Peaker> In Python, I have "first-class actions", Python functions
22:01:18 <Peaker> No first-class functions, maybe
22:01:30 <soupdragon> Piethon
22:01:38 <dmwit> I wonder about declaring exceptions in Haskell.
22:01:49 <ksf> control.monad.exception
22:02:18 <dmwit> Yes, that would be great, except that it's possible to throw exceptions without using that.
22:02:35 <dmwit> Which means that the type (a -> a) doesn't really mean (a -> a), it means (a -> a, maybe throwing some exceptions).
22:02:36 <ksf> but you don't get the typelevel goodness.
22:02:38 <BlueSilver39> I am trying to do something *cool* here 
22:02:49 <BlueSilver39> i am tired of using PHP and Python for web develpment 
22:02:53 <ksf> ...and exceptions in pure code are evil, anyway.
22:02:59 <heatsink> With exceptions and effect types, you'd probably also want subtyping.
22:03:02 <dmwit> (I'm suggesting some extension to GHC or something to enforce that C.M.E is used for all exceptions, or something.)
22:03:07 <Peaker> dmwit, Partiality sucks, yeah
22:03:11 <BlueSilver39> is the mongodb bindings for haskell pretty good?
22:03:13 <dmwit> heatsink: ...probably =/
22:03:50 <ksf> as long as you don't want to get rid of bottom before solving the halting problem I'm fine with that.
22:04:09 <kmc> just prove termination
22:04:12 <ksf> (for practical values of "solving")
22:04:41 <dmwit> I'm uncertain how I feel about exceptions replacing nonterminating code.
22:05:00 <dmwit> (I have no problem with a program spinning at runtime if I happen to write an infinite loop.)
22:05:24 <Peaker> I have a problem with that :P
22:05:27 <Peaker> I want totality
22:05:28 <ksf> I'd rather have it crash
22:05:43 <dmwit> In another language, I might want totality.
22:05:51 <dmwit> But I don't want something so radical in my Haskell. =)
22:06:02 <Peaker> Well, in a sense I want another language :)
22:06:22 <ksf> what about totality in a multithreaded environment?
22:06:42 <Peaker> What about it?
22:06:46 <ksf> I bet deadlock and starvation-freeness is a bugger to proove.
22:06:58 <Peaker> deadlocks are easy - don't have locks
22:07:01 <ksf> livelock, too.
22:07:28 <Peaker> well, have the language use the threads for parallelism with annotations, rather than controlling imperative threads explicitly
22:09:29 <kmc> arguably that's not "multithreaded"
22:09:38 <kmc> if you're talking about the semantics of the language
22:09:50 <kmc> and yes it's hard to prove that multithreaded code is correct
22:09:55 <Peaker> Then I probably don't want "multithreaded"
22:09:56 <kmc> because it's usually not ;P
22:10:10 <kmc> i meant that it doesn't satisfy ksf's premise
22:10:19 <Peaker> FRP makes concurrency easier without livelocks/etc
22:12:29 <kmc> i feel like the relevance of deadlock in real systems is overstated
22:13:00 <kmc> and proving lack of deadlock and starvation-freeness is almost secondary to proving lack of dangerous race conditions
22:13:29 <kmc> and proving that requires you to think hard about what exactly guarantees you are providing
22:21:48 <scotty> > mvLift2 (+) [1,2,3] [4,5,6]
22:21:49 <lambdabot>   Not in scope: `mvLift2'
22:23:16 <scotty> > liftM2 (+) [1,2,3] [4,5,6]
22:23:16 <lambdabot>   [5,6,7,6,7,8,7,8,9]
22:24:47 <Peaker> mvLift2 is funny :)
22:25:51 <scotty> mvLift2 f x y          =  do x' <- x y' <- y return (f x' y')
22:26:08 <soupdragon> @let mvLift2 f x y          =  do x' <- x y' <- y return (f x' y')
22:26:08 <lambdabot> Plugin `eval' failed with: Parse error: Last statement in a do-block must be an expression
22:26:14 <soupdragon> @let mvLift2 f x y          =  do x' <- x ; y' <- y ; return (f x' y')
22:26:15 <lambdabot>  Defined.
22:26:25 <scotty> Whoa
22:26:32 <soupdragon> > mvLift2 (+) [1,2,3] [4,5,6]
22:26:33 <lambdabot>   [5,6,7,6,7,8,7,8,9]
22:26:39 <scotty> :O
22:27:02 <scotty> I didn't know lambdabot could be "taught".
22:27:10 <soupdragon> > (mvLift2 (+) (*2) (+3)) 7
22:27:11 <lambdabot>   24
22:27:27 <soupdragon> > mvLift2 (+) (1,2) (7,3)
22:27:28 <lambdabot>   No instance for (GHC.Base.Monad ((,) t))
22:27:28 <lambdabot>    arising from a use of `e_121273...
22:27:33 <Peaker> > "I am awaiting your teachings, sir scotty"
22:27:34 <lambdabot>   "I am awaiting your teachings, sir scotty"
22:27:40 <scotty> lol
22:27:40 <kmc> @nixon
22:27:40 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
22:27:48 <kmc> @protontorpedo
22:27:48 <lambdabot> what Is writen in haskell that gets work done?
22:27:50 <soupdragon> > mvLift2 (+) (1,[2]) (7,[3])
22:27:50 <lambdabot>   No instances for (GHC.Num.Num [t1], GHC.Base.Monad ((,) t))
22:27:50 <lambdabot>    arising from...
22:28:22 <scotty> Why do you have 
22:28:33 <scotty> "x' <- x" for example?
22:28:47 <scotty> Oh, nevermind.
22:28:53 <scotty> So that it will happen multiple times.
22:29:39 <scotty> Wait
22:29:53 <scotty> x' is a character and x is a list.
22:30:23 <scotty> Well, not a character, but an element of a list.
22:30:33 <soupdragon> in general if you have   x <- x'   then  x' :: m a  and  x :: a
22:30:56 <soupdragon> in this case m is [] and a is Char, so it's  x' :: [Char] = String, x :: Char
22:31:23 <scotty> Yeah
22:31:42 <scotty> So <- is pulling out elements from the list?
22:32:18 <scotty> > (1 : (2 : 3))
22:32:18 <lambdabot>   No instance for (GHC.Num.Num [t])
22:32:18 <lambdabot>    arising from a use of `e_1123' at <int...
22:32:25 <kmc> > 1 : 2 : 3 : []
22:32:26 <lambdabot>   [1,2,3]
22:32:26 <scotty> > (1 : (2 : [3]))
22:32:27 <lambdabot>   [1,2,3]
22:33:06 <scotty> How is <- defined?
22:33:43 <dmwit> do { pat <- m; n } ==> m >>= \x -> case x of pat -> n; _ -> fail "argh"
22:34:07 <dmwit> ...where x is fresh for n and pat, obviously.
22:34:38 <Axman6> scotty: basically do { x <- m; f x} === m >>= \x -> f x
22:37:39 <soupdragon> "Chris Okasaki’s book Purely Functional Data Structures [22] contains a collection of efﬁcient data structures, with concise implementation and nontrivial invariants. Its code appeared as a excellent benchmark for testing the usability of our approach to program veriﬁcation. So far, we have veriﬁed more than half of the contents "
22:38:00 <scotty> "Essentially, each <- is generating a set of values which is passed on into the remainder of the monadic computation. Thus x <- [1,2,3] invokes the remainder of the monadic computation three times, once for each element of the list."
22:38:24 <dmwit> That is specific to the list monad.
22:38:36 <scotty> Yes
22:40:09 <BlueSilver39> any snap users here?
22:40:21 <BlueSilver39> i hate using stufff that hardly anyone else uses heh 
22:40:24 <Axman6> there's plenty in #snapframework
22:40:55 <BlueSilver39> yea not bad
22:41:01 <BlueSilver39> i was expecting 6 at max
22:41:01 <scotty> So, all I understand so far is that >>= carries a value from one monad to the next.
22:42:02 <jesusabdullah> I saw an interesting article on monads about a week ago scotty
22:42:03 <jesusabdullah> hold on
22:42:03 <aakarsh> what does one use to generate tags for haskell
22:42:04 <jesusabdullah> maybe it
22:42:07 <jesusabdullah> ll help?
22:42:42 <dmwit> ?google you could have invented monads
22:42:43 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
22:42:43 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
22:42:43 <scotty> I don't know.  I just started reading the chapter on Monads.  It might take me some time to absorb this.
22:42:44 <dmwit> scotty: ^^
22:42:59 <Axman6> aakarsh: tags?
22:43:18 <aakarsh> i guess something here http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
22:43:31 <aakarsh> need to be able to browse around the haskell code
22:44:01 <jesusabdullah> Yeah, that one dmwit
22:44:10 <jesusabdullah> my google fu was somehow failing :C
22:44:53 <scotty> Okay, I'll try reading that.
22:44:54 <jesusabdullah> scotty: I've seen many a description of What Monads Are, and this was the first one that really made sense to me >_<
22:45:10 <jesusabdullah> BUT, it made a lot of sense!
22:46:53 <jesusabdullah>  /me needs to work through it still
22:53:56 <ksf> scotty, >>= "carrying one value from one monad to the next" is all they're about
22:54:38 <ksf> the quotes meaning that its left and righthand side are both part of the same monad
22:54:44 <scotty> Man, the first solution in that page you posted doesn't make any sense.
22:55:21 <scotty> I think it's wrong.
22:55:34 <soupdragon> which?
22:55:36 <cozachk> is there some sort of Algebra to say descriibe nub and sort and then when compose in that algebra nub with sort its optimized? 
22:55:36 <scotty> ksf: Okay, well then I guess I understood that much.
22:55:41 <soupdragon> show me what's wrong
22:55:43 <ksf> they're all about being able to carry results from one action to the other while (in general) still being unable to extract it
22:56:00 <scotty> soupdragon: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
22:56:22 <scotty> soupdragon: Check out "bind"
22:56:24 <soupdragon> :t let bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) in bind
22:56:25 <lambdabot> forall t t1 t2. (Monoid t2) => (t -> (t1, t2)) -> (t, t2) -> (t1, t2)
22:56:49 <ksf> ...you can extract things from the list monad (via head and tail) and the state monad (via runState), but you e.g. can't do that with the IO monad
22:56:49 <scotty> Isn't bind supposed to be a function of one argument?
22:56:56 <ksf> nope two.
22:56:56 <soupdragon> scotty, (>>=) is bind
22:57:08 <ksf> join only takes one.
22:57:09 <ksf> :t join
22:57:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:57:20 <scotty> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
22:57:27 <scotty> It's supposed to take a function.
22:58:04 <ksf> :t (>>=)
22:58:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:58:14 <ksf> one action to run
22:58:34 <scotty> Oh, I think I see.  It's pattern matching on the argument to f'.
22:58:36 <ksf> one function to pass a value in
22:58:50 <scotty> Bleh
22:59:01 <jesusabdullah> jesus compiling pandoc is raping my poor laptop
23:05:38 <kamatsu> ah, maybe jdh will believe that google do use haskell now that they've submitted a paper to icfp 2010.
23:05:47 <soupdragon> uh
23:05:51 <soupdragon> LOL
23:06:05 <soupdragon> facts ? yeah I'm sure THAT will convince him
23:06:07 <kamatsu> cos, evidently my word as an intern and several other employees is not good enough
23:07:43 <o-_-o> so this clojure thingy is it any good ?
23:07:49 <soupdragon> not imo
23:08:04 <o-_-o> all those brackets scare me
23:08:25 <kamatsu> its a lisp
23:08:32 <kamatsu> i think it's a good lisp
23:08:36 <kamatsu> but you have to like lisps
23:09:39 <kamatsu> afaik it's the only lisp that is modern and supports concurrency features like STM
23:09:56 <kamatsu> and it has the advantage of not being made by Paul Graham for masturbatory purposes.
23:10:07 <kamatsu> instead it was made by Rich Hickey for the same purposes, i guess.
23:10:08 <soupdragon> lol
23:10:11 <o-_-o> so if one have had done some lisp, the one will probably like it ?
23:10:13 <o-_-o> haha
23:10:48 <soupdragon> stuff like clojure irritates me because I think they should have just improved an existing CL compliier
23:10:54 <kamatsu> i see no reason to use Clojure over Haskell, but I do see reasons to use Clojure over Java.
23:11:08 <kamatsu> I think if they improved an existing CL compiler it would be doomed to be completely ignored
23:11:17 <kamatsu> Clojure is popular because of its relationship with the Java ecosystem
23:12:37 <plediii_> is clojure the fulfillment of Steele's dream to drag C++ programmers to lisp?
23:12:49 <kamatsu> i think it's closer than Steele ever got
23:13:26 <kamatsu> If i'm writing for JVM, I use Scala not Clojure, though.
23:13:44 <k23z__> this Steele guy, why is he so "en vogue" ? not like he's done anything than implement a language ...
23:13:50 <k23z__> big deal
23:14:31 <kamatsu> k23z__: he worked on a bit more than just scheme
23:14:50 <o-_-o> hmmm...scala looks nice
23:15:35 <kamatsu> he served on the committees for C, fortran, common lisp, scheme
23:15:46 <kamatsu> and he also co-authored the java language specification
23:15:47 <k23z__> oh, so he's a committee guy , that's great
23:16:22 <kamatsu> alot of the early PLs people were committee people
23:16:39 <danharaj> so he's in part responsible for the lack of tail calls in...
23:16:58 <k23z__> actually Steele annoys me very much
23:17:00 <kamatsu> danharaj: actually, he wrote an article on why it's impossible to have fully abstracted OO without tail calls
23:17:08 <k23z__> I watched one of his talks and I got so annoyed I closed it 
23:17:13 <kamatsu> danharaj: remember his work in Java was done after the language was written
23:17:26 <danharaj> fair enough
23:17:35 <danharaj> I think OO is a bust anyway.
23:18:49 <dmwit> I like busts.
23:18:50 <wli> I second the "OO is a bust" vote.
23:18:53 <dmwit> wait... wrong channel
23:19:59 <danharaj> This may be because the last influence from C++ I had before I migrated to Haskell was Alexander Stepanov, a pretty big critic of OO.
23:23:56 <kamatsu> hm
23:24:10 <kamatsu> I think OO has made mistakes with regards to immutability and inheritance
23:24:31 <kamatsu> but apart from that I like the idea of having some Thing and these Things supporting some Operations on Things.
23:24:42 <kamatsu> but that sort of idea isn't really exclusive to OO
23:26:06 <kamatsu> indeed i do it in haskell all the time
23:26:19 <danharaj> "Always start with algorithms."
23:26:25 <danharaj> I enjoy this maxim in design.
23:26:39 <Zao> I tend to start with data, and then add functionality.
23:27:33 <plediii_> you mean data types?
23:27:41 <kamatsu> I don't really know how I start
23:28:03 <kamatsu> often i pick a module to write
23:28:07 <kamatsu> and write all the LHS first
23:28:17 <kamatsu> then fill in the code with relevant... actual code.
23:28:44 <kamatsu> writing literate programs really helps you get your ideas straight
23:28:59 <danharaj> I haven't tried literate programming yet
23:29:09 <danharaj> but it is the way I would write a mathematical proof, so maybe it is on to something.
23:29:42 <kamatsu> one of my most recent projects, a collaborative document editor, is written entirely in literate haskell
23:30:05 <jesusabdullah> kamatsu: link?
23:30:18 <kamatsu> jesusabdullah: it's not really ready for prime time yet, but here you go...
23:30:26 <kamatsu> github.com/liamoc/opardum-server
23:30:29 * jesusabdullah is used to that
23:30:41 <kamatsu> i'll put it on hackage when it's done
23:31:36 <jesusabdullah> hooray for collaborative document editing
23:31:42 <jesusabdullah> is that you kamatsu, or a collaborator?
23:31:48 <kamatsu> that's me.
23:32:01 <kamatsu> I used to work on the Google Wave team
23:32:05 <kamatsu> so I stole a whole pile of ideas
23:32:19 <jesusabdullah> oh yeah?
23:32:26 <jesusabdullah> I wasn't sure what to make of google wave tbh
23:32:32 <danharaj> kamatsu, funny story about google wave
23:32:36 <kamatsu> i get that alot
23:32:43 <jesusabdullah> It felt like it was a weird mashup of facebook and the googledoc
23:32:48 <kamatsu> facebook?
23:32:52 <jesusabdullah> yeah
23:32:53 <jesusabdullah> of all things
23:32:56 <danharaj> on a forum I go to, we were debating the uses of google wave, and someone honestly suggested using it as a grocery list.
23:32:56 <kamatsu> how so?
23:33:07 <jesusabdullah> Keep in mind, I didn't spend that much time on it
23:33:20 <jesusabdullah> and maybe I'm mixing in some of my memories of buzz
23:33:34 <kamatsu> at Google we used it for meeting minutes, design documents, email replacemenets and group dicussions
23:33:36 <danharaj> buzz sounds more like something like facebook
23:33:39 <kamatsu> yes
23:33:46 <danharaj> kamatsu: those are excellent uses
23:33:50 <jesusabdullah> Yeah, it was a lot like facebook, but...yeah
23:33:51 <jesusabdullah> It would
23:33:53 <jesusabdullah> blegh
23:34:07 <kamatsu> anyway, I stole the patch calculus they use in Google Wave
23:34:09 <jesusabdullah> I think if wave wasn't so similar to the google doc, I would've been less suspicious
23:34:26 <kamatsu> threw out a bunch of ideas that wave has that make it complicated or require big iron that i don't have
23:34:43 <kamatsu> (e.g history )
23:34:45 <jesusabdullah> Is wave still around?
23:34:49 <kamatsu> sure
23:34:51 <kamatsu> wave.google.com
23:35:02 <kamatsu> it's faster and now with less crashes
23:35:06 <jesusabdullah> hmm
23:35:13 <jesusabdullah> I think I knew a guy that had wave invites
23:35:20 <kamatsu> it's open signup now
23:35:22 <kamatsu> afaik
23:35:36 <kamatsu> if not i can invite you, i have a bagillion invites cos i was on the dev team
23:35:44 <jesusabdullah> I think part of the issue too was that it seemed kinda useless with just me and some nerd i don't really hang out with
23:35:44 <kamatsu> the counter says 99, but it doesn't seem to go down
23:36:06 <kamatsu> yeah, i'm pretty sure they've added more email integration now
23:36:08 <jesusabdullah> I'm apparently already in the system
23:36:11 <kamatsu> i know it was high on priorities.
23:36:34 <kamatsu> yeah
23:36:42 <kamatsu> you can add an email address instead of a wave address to a wave
23:36:56 <kamatsu> and it will send them an email with the wave and signup, or direct them to their wave account
23:37:04 <jesusabdullah> well, now it seems like a weird mashup of googledocs and gmail
23:37:37 <kamatsu> it's a mashup of googledocs, gmail, google talk
23:37:48 <jesusabdullah> Yeah
23:37:50 <kamatsu> with a bit of wiki thrown in
23:37:54 <ksf> http://www.cis.upenn.edu/~alur/Jacm09.pdf
23:37:57 <jesusabdullah> and I already have the other three
23:38:08 <jesusabdullah> except I don't really find google talk very compelling
23:38:08 <kamatsu> right, but this gives you the advantage of seamless communication
23:38:18 <kamatsu> when you use it with a large group, it's quite useful
23:38:27 <kamatsu> but sadly it doesn't seem to have enough  traction yet
23:38:29 <jesusabdullah> Right, *if* you can get the large group to go with it :P
23:38:30 <jesusabdullah> Yeah
23:38:53 <kamatsu> in any event, i'm writing this server to be pretty flexible and customizable
23:38:59 <kamatsu> it's configured with Dyre so it's like xmonad
23:39:03 <jesusabdullah> hmm
23:39:06 * jesusabdullah has xmonad
23:39:13 <kamatsu> I have one short term and one long term goal
23:39:17 <jesusabdullah> Haven't done a whole lot customizing it though
23:39:23 <kamatsu> short term goal is for a collaborative code pastebin 
23:39:29 <jesusabdullah> just got it to do the gnome-integration
23:39:37 <kamatsu> long term goal is for a collaborative Falling Sand Game.
23:39:42 <jesusabdullah> ooh
23:39:48 <jesusabdullah> I love falling sand games
23:40:07 <kamatsu> preferably with awesome pressure effects and player characters
23:40:29 <kamatsu> you could even make it into a deathmatch style game with falling sand physics
23:40:32 <kamatsu> it'd be interesting
23:40:38 <Gracenotes> finally, a falling sand game that challenges my graphics card!
23:40:53 <kamatsu> Gracenotes: I didn't say anything about nice graphics
23:41:09 <jesusabdullah> ahaha
23:41:11 <kamatsu> i'm a pretty woeful graphics programmer
23:41:11 <Gracenotes> ಠ_ಠ
23:41:16 <jesusabdullah> I'd better go to bed
23:41:23 <jesusabdullah> gluck kamatsu!
23:41:26 <Gracenotes> night
23:41:29 <kamatsu> night
23:41:41 <Gracenotes> hackage idea: we need a set of cute names for various mundane package management functions like rubygems has
23:41:57 <kamatsu> Gracenotes: they should be conspiratorial (cabal) not cute
23:42:40 <Gracenotes> even better. indeed, there is no cabal.
23:43:45 <Silvah> Cabal is a spoon now?
23:43:55 <dmwit> There is no Cabal!
23:44:19 <dmwit> The Cabal bends you...
23:44:26 <alar> I can see the Fnord!
23:44:43 <dmwit> hah
23:45:04 <Gracenotes> I can't see the Cofnord
23:45:31 <kamatsu> apparently someone did a survey of cusses appearing in code
23:45:38 <kamatsu> Perl had rather high, and Haskell very low
23:45:51 <Zao> How about ncurses? :D
23:46:12 <kamatsu> my hypothesis is that Haskell programmers were all originally british and therefore haskellers say "bollocks"
23:46:21 <kamatsu> which wouldn't be included as a cuss
23:46:35 <Zao> Excellent theory, old chap.
23:46:53 <Gracenotes> darn appears in a ghc source tree I have
23:46:55 <dmwit> My theory is that the cusses get turned into {-# LANGUAGE #-} pragmas.
23:47:04 <kamatsu> haha
23:47:23 <Gracenotes> as does bloody :o
23:47:29 <kamatsu> {-# LANGUAGE DisableTypeChecker #-} is everyone's favorite.
23:47:45 <kamatsu> stop those dastardly compiler errors once and for all!
23:47:50 <dmwit> It's hard to blame Haskell when there's so many Haskells to choose from.
23:48:39 <kamatsu> i tihnk haskell is one of the few languages i've seen that has so many features available via extension pragmas
23:48:55 <danharaj> ghc* :D
23:48:59 <kamatsu> well, yeah
23:49:01 <Silvah> {-# LANGUAGE WriteTheCodeForMe #-} is better ;)
23:49:10 * dmwit notes that there are some programs which would fail to typecheck, but would run fine
23:49:17 <kamatsu> Agda can sometimes do that, if you write the types :P
23:49:37 <kamatsu> dmwit: can't you use UndecidableInstances to get around that?
23:50:27 <kamatsu> dmwit: i'm pretty sure that removes the termination guarantee of the type checker
23:50:43 <Silvah> How could I get the internal representation of a Float?
23:50:56 <dmwit> putStrLn $ if True then "hey" else ("hey", "there") -- kamatsu, here's an example where UndecInst doesn't help
23:51:15 <dmwit> Silvah: What?
23:51:49 <dmwit> Silvah: A value of type Float *is* an internal representation of a Float.
23:52:09 <dmwit> Silvah: You'd better give us a bit more context: what are you trying to do one level up from here?
23:53:00 <Silvah> Yeah, though I need to do some bit twiddling on it, and AFAIK Float is not an instance of Bits.
23:54:34 <Gracenotes> ah. yeah, all the base facilities for manipulating floating point seem to skip bit manipulation
23:54:39 <dmwit> You could write a Bits instance, using the FFI, for instance; but again, what's the context? This reeks of doing things the Wrong Way.
23:54:54 <Gracenotes> (and I'm not sure what half of them do..)
23:55:29 <dmwit> or by unsafeCoercing them into Word16's (or how big are Floats?), doing your bit-manip, and coercing back, just as you would do in C.
23:55:39 * dmwit eagerly awaits the bigger picture
23:56:37 <Zao> dmwit: Don't you have to do your coercing with unboxed types?
23:56:55 <dmwit> Maybe so.
23:57:00 <Zao> (maybe usC does that, I preferably don't want to know)
23:57:00 <dmwit> :t unsafeCoerce
23:57:01 <lambdabot> Not in scope: `unsafeCoerce'
23:57:16 <dmwit> ?hoogle unsafeCoerce
23:57:16 <Zao> I know some lad in here had glorious explosions trying to do it before.
23:57:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:57:32 <Zao> Trying to read Doubles from binary input or something.
23:57:46 <Zao> If a and b are boxed, I'd expect all kinds of awesome explosions.
23:58:01 <dmwit> Really?
23:58:18 <Silvah> I'm porting some piece of C code to Haskell, and there's a function for comparing floats (i.e. checking whether they're nearly equivalent) which involves bit twiddling on type-punned values.
23:58:19 <dmwit> I'd be totally surprised if all the different one-constructor data types actually had different in-memory representations of the constructor.
23:58:52 <sizzler> is it possible to access the members of an opaque struct defined in a FFI binding? like mentioned in sec 1.1 http://www.haskell.org/haskellwiki/FFICookBook
