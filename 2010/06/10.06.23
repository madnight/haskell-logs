00:00:07 <kmc> ¬´data Foo = Foo !T¬ª means that if a Foo is in WHNF, then so is its T field
00:00:11 <kmc> Jafet, why?
00:00:17 <Jafet> Disk access is a few hundred times slower than memory access at least
00:00:37 <kmc> obviously it's not suitable for every task
00:00:53 <kmc> i though this transparency was what Saizan meant by "keeping a conceptually single value partially in memory and partially on disk"
00:01:00 <emilmeln> Hmm, then is seems that lazy bytestrings isomorphic to lists of strict bytestrings (according to internal module).
00:01:16 <kmc> emilmeln, i think tht's right
00:01:24 <kmc> they are chunked
00:01:26 <Jafet> I would say it is not suitable to cncl's task, indeed
00:01:32 <kmc> ok
00:01:37 <kmc> i'm not arguing that either way
00:01:37 <Jafet> But then, only a profiler would know, ultimately
00:03:17 <emilmeln> Then, why they are made lazy bytestring as distinct, abstract data type?
00:03:54 <kmc> so that you don't have to think about the chunk boundaries
00:04:06 <kmc> so it's a drop-in change from strict to lazy and vice versa
00:04:13 <Saizan> well, you need distinct because of the !, you can't put a ! inside [] retroactively
00:04:38 <emilmeln> Ah, of course :)
00:04:40 <aavogt> is there a linear algebra library that works with Rational?
00:04:53 <kmc> we frequently have types that isomorphic but distinct, for usability or abstraction reasons
00:04:55 <emilmeln> They are optimised for L2 CPU cache.
00:09:17 <aavogt> Vec seems acceptable
00:10:17 <emilmeln> I've asked this because of iteratees.
00:11:55 <Axman6> lambdabot!
00:12:00 <kmc> noooo
00:12:11 <Axman6> Cale: lambdabot! she is dead!
00:12:27 <kmc> not dead, just passed out in a gutter somewhere
00:12:58 <Jafet> Sounds typical of the british
00:15:33 * hackagebot uuagc 0.9.27 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.27 (ArieMiddelkoop)
00:15:36 <chrisdone> it works!
00:15:46 <kmc> what's that
00:17:54 <J-roen> What is a good name for a module which _only_ imports and exports a couple of other (sub)modules, e.g. used to improve usability?
00:18:32 <kmc> you mean, a name for the module, or a generic term for that sort of thing?
00:18:39 <J-roen> A generic term
00:19:06 <emilmeln> wrapper module?
00:19:09 <koala_man> that contains no real code, just reduces the number of exported functions?
00:19:36 <J-roen> koala_man: Yes, for example
00:19:37 <Axman6> a meta-module!
00:21:45 <J-roen> A quick search on the web learns me that the term "wrapper module" is indeed already in use for these kind of modules.
00:21:54 <J-roen> Thanks
00:23:41 <emilmeln> wrapper shell script is the same concept.
00:31:47 <robertmassaioli> according to this ticket I should be gettin a .ghc_history file from ghci but I don't; should I be setting something in my .ghci file to turn on command history? Thanks.
00:31:51 <robertmassaioli> http://hackage.haskell.org/trac/ghc/ticket/2050
00:31:58 <robertmassaioli> there is the ticket btw
00:33:41 <Cale> I didn't know it was possible to turn off command history
00:34:32 <robertmassaioli> yeah I know right. I thought that it would come by default too but I don't have a history file and there is no history for me...not even with Ctrl-R
00:34:47 <Cale> What GHC version?
00:35:12 <robertmassaioli> The Glorious Glasgow Haskell Compilation System, version 6.12.1
00:35:58 <emilmeln> robertmassaioli: look at the "~/.ghc/ghci_history"
00:38:26 <robertmassaioli> huh, look at this: 
00:38:27 <robertmassaioli> bash: cd: /home/robert/.ghc: No such file or directory
00:38:39 <robertmassaioli> apparently I don't have a .ghc folder either
00:38:41 <robertmassaioli> one sec
00:39:37 <robertmassaioli> created the folder and, surprise surprise, I have command history again. I wonder how that happened in the first place though...
00:39:48 <robertmassaioli> must have been something I did
00:41:42 * hackagebot uuagc 0.9.28 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.28 (ArieMiddelkoop)
00:46:27 <QinGW> sleeping
00:47:00 <emilmeln> robertmassaioli: you installed packages with cabal-install, and "package.conf.d" directory was created in "~/.ghc".
00:47:16 <emilmeln> i think...
01:08:05 <Saizan> emilmeln: that would make ~/.ghc exists.
01:08:11 <Saizan> *exist
01:09:42 <Saizan> robertmassaioli: you should open a ticket about the fact ghci should create ~/.ghc if it doesn't exist already so that it can save the history in there
01:13:39 <wagle> do hawking io monads evaporate?
01:15:44 <chrisdone> is there already an emacs script to align haskell import lists?
01:16:39 <chrisdone> i.e. something that will do this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26475#a26475
01:17:02 <emilmeln> chrisdone: you might try align-regexp
01:17:55 <chrisdone> sounds good
01:18:57 <tibbe> chrisdone: I'd like to see that, one that also sorts by module name and handles import lists that go over two+ lines
01:19:27 <chrisdone> tibbe: yep! i'll sort it out
01:20:16 <chrisdone> tibbe: at least in my own code, i have this rule where an import list >1 line should be qualified and aliased. it makes the import lists really clean
01:21:06 <tibbe> chrisdone: sounds reasonable
01:21:23 <tibbe> chrisdone: I haven't addressed that particular point in my style guide
01:21:30 <chrisdone> right
01:22:24 <chrisdone> tibbe: here's an example where it really matters: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26475#a26476
01:24:11 <chrisdone> not sure what to do with PackageImports, but my previous post has one way it could be indented
01:24:13 <tibbe> chrisdone: yes
01:26:59 <ivanm> preflex: seen lambdabot
01:26:59 <preflex>  lambdabot was last seen on #haskell 1 hour, 44 minutes and 49 seconds ago, saying: CVS right.
01:32:45 <robertmassaioli> Saizan, emilmeln: I might make that bug report. Maybe there is a good reason that they don't do that already.
01:39:42 <RayNbow> omega = \x -> x x   ;   omega_3 = \x -> x x x    -- does anyone know in which paper these lambda terms were named?
01:44:13 <chrisdone> :t join . join . join
01:44:20 <chrisdone> :(
01:45:16 <cncl> it feels so wrong
01:45:19 <cncl> join . join . join :: (Monad m) => m (m (m (m a))) -> m a
01:45:22 <cncl> ok i feel better now
01:45:35 <roconnor> @cncl-snack
01:48:36 <Botje> O_O
01:48:40 <RayNbow> @botsmack
02:17:01 <tibbe> quiet day today
02:23:01 <mreh> BOO
02:24:39 <mreh> I'm deep in Yampa guts, blergh
02:25:33 <mreh> differentiating between initial and running signal functions doesn't seem to make much sense to me right now
02:26:09 <mreh> surely a signal function that is running is not the special case, but that's how it seems
02:29:36 <toki78> hi, maybe wrong channel........ is there a good tutorial or book about how to copy-protect your software ?
02:30:21 <mreh> toki78: probably the wrong channel, but someone might know how
02:30:25 <mreh> ask in  -blah
02:32:15 <RayNbow> isn't copy-protecting your software more or less impossible?
02:32:17 <eevar2> toki78: lawyers are the best way to go about that. and not buying into the riaa/mpaa/bsa bullshit
02:33:37 <p_l> riaa/mpaa/bsa are legal extortionists. Personally I think good, balanced pricing and care for customer works better than copy protection
02:35:23 <toki78> true, it's not possible, but I would be satisfied, if I knew the algorithms behind serial numbers
02:35:43 <toki78> how do I know, that a Serial number is valid ?
02:35:56 <p_l> toki78: You could use public key cryptography, I guess
02:35:56 <max_atreides> public/private key crypto
02:36:26 <mreh> madness, you'd need to encrypt the software for every sale
02:36:28 <max_atreides> although serial numbers use a simpler algorithms
02:36:33 <p_l> I know that Office XP used serial number in some way as a number from which proper function pointers were calculated
02:37:00 <toki78> i see
02:37:29 <p_l> the addresses in some DLL were scrambled and you needed serial key + activation code to unscramble them
02:37:44 <Zao> You generate the serial number with your private key, and the software contains a public key to verify it.
02:38:42 <mreh> cracked versions appear pretty soon afterwards
02:39:02 <toki78> the public key is for encryption only, right ?
02:39:14 <p_l> serial numbers and similar solutions *do* have use, in the form of actually controlling and managing your install base, but that's usually for software sold to companies, especially in multiple licenses etc. (i.e. you signed a contract that you sell them the software and support for 50 users)
02:39:14 <mreh> decryption
02:39:38 <mreh> both
02:39:45 <mreh> depends which way in the info is going
02:39:47 <p_l> toki78: you can also try to use hw identifier as part of the schema
02:39:51 <max_atreides> ultimately though, in order for your computer to execute a program - the program code must be loaded into memory at one point or another.
02:40:04 <Zao> p_l: Assuming you can determine a sufficiently reliable hardware identifier.
02:40:20 <Zao> p_l: And accept that your customers will be pissed if they ever happen to make that identifier change.
02:40:21 <mreh> if you want only someone to read a message you encrypt it with their public key
02:40:21 <toki78> the protection need not go too deep
02:41:01 <toki78> mreh, yes, and with the public key you cannot decrypt
02:41:22 <mreh> if you want to verify something is from you, you encrypt with your private key
02:41:32 <mreh> they decrypt with your public key
02:41:37 <toki78> I thnik I'll used some kind of online registration system
02:42:03 <mreh> limiting the number of d/ls is something I've seen done
02:42:07 <mreh> not very popular
02:42:25 <toki78> mreh, no you encrypt with the public key and decrypt with the private key
02:42:28 <mreh> and doesn't really stop distribution
02:42:47 <toki78> mreh, what means d/ls ?
02:42:54 <mreh> downloads
02:43:10 <max_atreides> or you can install a rootkit on your client's machine ;-P
02:43:14 <max_atreides> a-la sony
02:43:27 <toki78> good idea :)
02:44:19 <mreh> toki78, it depends on the key algorithm, but you can sign with your private key
02:44:59 <Zao> Just about any decent asymmetric algo will do.
02:45:47 <mreh> anyway, with a resounding call, I went off topic!
02:46:18 <mreh> someone was supposed to teach me RSA as an undergraduate, but failed miserably
02:46:57 <mreh> are those men rich?
02:47:19 <mreh> they had a patent for 17 yers
03:02:39 <p_l> Zao: so you need to provide both a reliable and *specified* identifier (i.e. the customer should have knowledge of what might change it) and a simple, non-controversial way to manage it
03:03:17 <Zao> p_l: Assuming you want to bother with tying it down to an identifier in the first place.
03:03:28 <Zao> In copy protection, everyone loses :D
03:04:21 <ozamosi|netbook> My object oriented self wants to create a plugin interface (a class for plugins to implement, I guess) for my IRC bot to make it more modular. The haskell noob in me tries to explain that it'd be annoying to do, because the plugins will want state. Could someone point me in a direction that would satisfy all of me?
03:04:50 <Jafet> ozamosi, go the enterprise way and use json over fastcgi
03:05:01 <p_l> ozamosi|netbook: do it message-passing style? :P
03:05:40 <p_l> i.e. make the type implemented by plugins specify means of *communication*, and whatever the plugin does internally to keep state is its own thing?
03:16:21 <ozamosi|netbook> p_l: oh, right, I should say thank you. *climbs back down to neverending pages of haddock documentation*
03:30:18 <xenoblitz> Am using GLUT and when I try to compile my code I'm getting two errors which require ColorComponent Float and VertexComponent Float instances, I found something similar here: http://osdir.com/ml/fieldtrip@haskell.org/2009-12/msg00002.html but no solution, anyone met this perhaps? 
03:32:31 <xenoblitz> or at least does anyone know which version of GLUT doesn't give this error so I can install that? thanks
03:34:31 <ivanm> xenoblitz: which version are you using?
03:34:40 <ivanm> maybe try the one in the platform rather than the latest one...
03:34:40 <xenoblitz> i just cabal installed it
03:34:45 <xenoblitz> ah ok
03:35:48 <xenoblitz> hmmm is there a language extension that should be on to make use of empty instance declarations?
03:38:05 <ivanm> xenoblitz: huh?
03:38:13 <ivanm> there is standalonederiving if that's what you mean
03:38:22 <xenoblitz> hmmm thanks let me look it up
03:51:18 <xenoblitz> ivanm: just going to revert to an older version, thanks all the same =)
03:51:29 <xenoblitz> ivanm++
03:51:48 <ivanm> np
03:53:48 <xenoblitz> hmmm don't know if that's the right way to do the ++ xD
03:54:26 <Zao> Considering that lambdabot is AWOL, it probably doesn't matter.
03:54:49 <Twey> Doesn't preflex do karma, too?
03:54:53 <Twey> preflex: karma ivanm
03:54:54 <preflex>  ivanm: 15
03:55:35 <xenoblitz> preflex: ivanm++
03:55:42 <xenoblitz> preflex: karma ivanm
03:55:43 <preflex>  ivanm: 16
03:55:47 <xenoblitz> there we go =)
03:55:52 <ivanm> don't think you need to tell preflex to do it...
03:56:11 <xenoblitz> karma xenoblitz
03:56:18 <xenoblitz> preflex: karma xenoblitz
03:56:18 <preflex>  xenoblitz has no karma
04:02:59 <SailorReality> PHYS325;
04:02:59 <SailorReality> PHYS341;
04:02:59 <SailorReality> PHYS343;
04:02:59 <SailorReality> PHYS381;
04:02:59 <SailorReality> PHYS397;
04:03:00 <SailorReality> PHYS443;
04:03:00 <SailorReality> PHYS449;
04:03:01 <SailorReality> PHYS451;
04:03:01 <SailorReality> PHYS455;
04:03:02 <SailorReality> PHYS457;
04:03:02 <SailorReality> PHYS481;
04:03:03 <SailorReality> PHYS497;
04:03:03 <SailorReality> PHYS501;
04:03:04 <SailorReality> PHYS543;
04:03:17 <ivanm> SailorReality: no, we're not going to help you with your physics homework
04:03:30 <SailorReality> was gonna say, I almot have a degree in physics except for all those courses...would only take 4 years to do too
04:03:39 <p_l> lol
04:04:14 <mjk> monad is very difficult to understand, how to understand it?
04:04:26 <Twey> mjk: Read the Typeclassopedia
04:05:03 <ivanm> mjk: are you just starting out?
04:06:29 <mjk> ivanm: :i can't looked sample tutial to understand moand
04:06:45 <ivanm> mjk: no, are you just starting out with Haskell?
04:07:03 <mjk> so i am trouble
04:07:07 <ivanm> not at all
04:07:14 <ivanm> if that's the case, don't worry about monads
04:07:23 <ivanm> leave them alone until you need them
04:07:44 <mjk> ivanm: yes, I am learning haskell
04:07:56 <danharaj> mjk: what is your native language?
04:07:57 <ivanm> http://random.axman6.com/blog/?page_id=70
04:07:58 <mjk> ivanm: just one year
04:08:06 <mjk> danharaj: chinese
04:08:09 <ivanm> ^^ if you're wanting to do IO, don't worry about monads for now
04:08:23 <danharaj> hmm, I don't think there is a haskell chinese channel.
04:08:36 <ivanm> neither do I
04:08:42 <ivanm> maybe mjk and ManateeLazyCat can start one? :p
04:09:01 <mjk> danharaj: yes,but chinese haskell channel is poor
04:10:02 <danharaj> mjk: That must be frustrating.
04:11:34 <mjk> danharaj: yes,the Tutorials in chinese about haskell is very poor 
04:11:52 <ivanm> wasn't there at least the beginning of a chinese translation of RWH?
04:12:19 <mjk> ivanm: not published for now
04:12:27 <ivanm> no, a community project
04:12:28 <ivanm> mjk: anyway, if you're just a beginner and want to program there's no need to worry about monads
04:14:17 <Jafet> At least he should be educated in the perils of monad tutorials
04:14:23 <danharaj> Burritos.
04:14:27 <Jafet> Those are sometimes the object of worry
04:15:08 <mjk> ivanm: I can understand the basic of haskell, i want to use it to develop a real project, so i want to learn Monad, but can't understand it
04:15:34 <Jafet> Spelling it right, that's a good start
04:15:43 <aristid> mjk: you don't need to understand monads to use IO, they say here.
04:16:04 <ivanm> aristid: well, you don't
04:16:16 <ivanm> mjk: I wrote a few projects in Haskell before understanding moands
04:16:17 <ivanm> *monads
04:16:32 <blackh> mjk: What is your project?
04:16:36 <ivanm> a lot of the Haskell stuff you pick up and learn by doing rather than reading yet another tutorial
04:16:57 <Taejo> :t unfoldr
04:16:58 <aristid> ghci and lambdabot are infinitely useful
04:17:03 <ivanm> (monad tutorials are notorious here, as it seems everyone has to write their own monad tutorial which makes no sense to anyone else)
04:17:07 <aristid> except when lambdabot is down of course
04:17:07 <RayNbow> preflex: seen lambdabot
04:17:07 <preflex>  lambdabot was last seen on #haskell 4 hours, 34 minutes and 58 seconds ago, saying: CVS right.
04:17:11 <Taejo> haha
04:17:16 <danharaj> mjk: Monad is general interface for composition. If m is monad, then :: (a -> m b) is type of monadic value b that depends on value of type a. >>= :: (m a) -> (a -> m b) -> (m b). It let's monadic value depend on previous monadic value.
04:17:40 <Jafet> mjk, http://www.haskell.org/haskellwiki/Monads_as_containers http://www.haskell.org/haskellwiki/Monads_as_computation
04:19:08 <mjk> ivanm:a file comparer,use Gtk2Hs as GUI
04:19:18 <ivanm> actually, dibblego had a decent intro to monads recently
04:19:51 <danharaj> gtk2hs has been mentioned, manateelazycat inbound in t minus 3... 2...
04:20:03 <ivanm> heh
04:20:15 <ivanm> mjk: what do you mean by file comparer?
04:20:18 <Jafet> Must be a chinese thing
04:20:26 <mm_freak> mjk: you don't need to understand monads to use them‚Ä¶  in fact, there isn't a lot to understand anyway‚Ä¶  it's just a theoretical model, which can be used to model certain kinds of computations
04:21:14 <mjk> ivanm: to compare size, content of the files
04:21:18 <mm_freak> if you use monads for IO only, just go ahead and 'do' =)
04:21:32 <ivanm> mm_freak: heh
04:22:31 <max_atreides> mjk: monads let you chain functions that take a value of type 'a' and return a value of type 'm a' 
04:23:57 <max_atreides> that's all there is to it
04:24:05 <Taejo> can view patterns be nested?
04:24:11 <blackh> mjk: If you ask 600 people "What is a monad?" You'll get 600 different answers.  My answer is "a monad is an abstract container, with an operation called >>= that lets you take something out of the container."
04:24:30 <mjk> max_atreides: wap the value?
04:25:04 <max_atreides> mjk: you can chain functions that wrap their values :)
04:25:29 <max_atreides> >>= is just an interface to chain such functions
04:25:36 <dobblego> of those 600, few will be correct
04:25:55 <mjk> :D 
04:28:35 <ivanm> greetings kamatsu 
04:29:36 <max_atreides> mjk: re-implement maybe monad yourself, then re-implement list monad yourself - it will help to see how they are the same
04:30:19 <ivanm> cue dobblego's usual comment about maybe being a list with at most one value
04:30:19 <ivanm> :p
04:30:38 <mjk> max_atreides: I will try, but now I can't do it 
04:32:09 <max_atreides> mjk: maybe and list monads are very simple. Most monad tutorials give you an implementation :)
04:32:16 <ManateeLazyCat> danharaj: I'm dinner... :)
04:32:43 <ManateeLazyCat> danharaj: What's wrong with gtk2hs?
04:34:04 <ManateeLazyCat> mjk: My suggestion, for learn Monad, *forgot* moand first. :)
04:35:01 <ManateeLazyCat> mjk: For real project, you just need know how to use "IO moand" and "Maybe moand", along with your grow, you can study some advanced moand, such as State moand ... etc.
04:35:19 * ivanm hopes ManateeLazyCat means "monad" and not "moand"
04:35:22 <ivanm> @wn moand
04:35:25 <ivanm> duh
04:35:40 <ivanm> hmmm, google doesn't know anything about "moand"
04:35:47 * ivanm was just curious if it really was a word
04:36:05 <ManateeLazyCat> ivanm: My Englishe-Helper stupid sometimes, even remember my typo word. :)
04:36:10 <ivanm> lol
04:36:12 * arcatan moaned
04:36:48 <Taejo> why do people call the IO type "the IO monad" and not "the IO functor"?
04:36:51 <ManateeLazyCat> ivanm: I have english-helper in Emacs, when i type english word, i just need type first character then complete word, like code completion in Eclipse. :)
04:37:15 <ksf> because functors can's sequentialise and IO isn't usually used applicatively
04:37:16 <Twey> Taejo: Because monads > functors?
04:37:16 <dobblego> Taejo, because they want to ensure that beginners never understand what monad means
04:37:57 <ManateeLazyCat> mjk: The only way to learn Haskell is "Practice, Practice, Practice..."
04:38:16 <Taejo> I think it's a contributor to "I want to do IO, I must learn monads"
04:38:39 <Taejo> I have no idea how many times I've said to my friends, "if you want to do IO, you should learn to do IO"
04:38:40 <ksf> heck does one have to be able to write a complier to use one?
04:38:57 <Taejo> that's a nice way to put it ksf
04:39:00 <ksf> does one have to know how to brew beer to drink it?
04:39:00 <Twey> Let's teach newbies applicative IO instead1
04:39:05 <Twey> !**
04:39:13 <Taejo> Twey: no, let's teach them IO
04:39:39 <ivanm> Taejo: because it's used as a monad more than a functor, and monad predates functor (in terms of H98 anyway)
04:40:00 <Taejo> I'm giving a class in August, my plan is to introduce fmap, (>>=), etc. as *IO* combinators first
04:40:13 <ivanm> ksf: well, a lot of people say that every programmer should write their own compiler...
04:40:13 <Taejo> then teach Parsec, and point out that its combinators are the same
04:40:31 <ivanm> Taejo: sounds a bit like the RWH approach, though they don't use parsec 2nd IIRC
04:40:36 <ksf> interpreter, definitely.
04:40:45 <ksf> compiler not so much, but it can be useful
04:40:46 <dobblego> I give a class http://code.google.com/p/haskell-course/
04:41:16 <ktzqbp> Is the convention to separate the cons operator : with spaces?
04:41:20 <ksf> it's easy to generate horrible code, that is.
04:41:33 <ksf> ktzqbp, depends
04:41:47 <ktzqbp> ksf: say, in the body of a function.
04:41:52 <ksf> if you do a simple x:xs then maybe, definitely if you do f x : g xs
04:41:55 <mjk> ManateeLazyCat: ª˘±æ¿ÌΩ‚¡ÀIO and Maybe, µ´ «Œﬁ∑®»Î√≈State
04:41:58 <ManateeLazyCat> mjk: When you first try to learn haskell, don't try to understand what's the monad, *just use it*. Try to understand it after you can use monad adroitly.
04:42:02 <ivanm> ktzqbp: on the RHS, yes
04:42:06 <ivanm> on the LHS, not so much
04:42:16 <ivanm> just to improve readability
04:42:18 <ksf> ...trust your aesthetic instinct
04:42:26 <ktzqbp> Alright, thanks ksf, ivanm
04:42:48 <Twey> ktzqbp: Not usually in patterns‚Ä¶ but personally I strongly prefer to always separate operators with spaces no matter where they appear.
04:42:51 <mokrzu> hello, why in haskell 0.6+0.3=0.89999 instead of 0.9 ?
04:42:51 <ManateeLazyCat> mjk: State Monad is different with "IO moand", we just use function runStateT generally.
04:43:04 <ivanm> mokrzu: because of how numbers are stored in computers
04:43:15 <ManateeLazyCat> mjk: "State Monad" use to *remove* temporary variable in your code block.
04:43:16 <ksf> > 0.6 + 0.3 :: CReal
04:43:22 <ivanm> mokrzu: same thing happens in most languages
04:43:23 <ksf> @bot
04:43:25 <Twey> mokrzu: Same reason as in any language with IEEE floats
04:43:26 <ivanm> e.g. in python it does the same IIRC
04:43:34 <ivanm> ksf: we're down one bot
04:43:42 <ksf> , 0.6 + 0.3 :: CReal
04:43:43 <Twey> But you don't have to use IEEE floats in Haskell.  We have other floating number representations, like CReal.
04:43:46 <ksf> two.
04:43:58 <Twey> ] 0.6 + 0.3 :: CReal
04:44:01 <Twey> Three
04:44:06 <ivanm> In Python, "0.3 + 0.6" returns "0.89999999999999991"
04:44:11 <Twey> Plus the backup bot that was here yesterday makes four :√æ
04:44:13 <ManateeLazyCat> mjk: Wait, i give you some example code.
04:44:21 <ivanm> ksf: oh, we lost lunabot ages ago
04:44:25 <ivanm> preflex: seen lunabot
04:44:25 <preflex>  lunabot was last seen on #haskell 144 days, 4 hours, 21 minutes and 39 seconds ago, saying:  31
04:44:32 <mokrzu> ok, thanks
04:44:33 <Twey> Wow
04:44:33 <ivanm> Twey: which was the third?
04:44:43 <ivanm> Twey: mmorrow is also AWOL
04:44:47 <Twey> I thought ] was lunabot's syntax
04:44:51 <ivanm> preflex: seen mmorrow
04:44:51 <preflex>  mmorrow was last seen on #ghc 156 days, 8 hours, 47 minutes and 5 seconds ago, saying: * mmorrow is rtfm'ing
04:44:56 <ksf> nope ,
04:44:57 <ivanm> Twey: , to start lunabot
04:45:01 <Twey> Hm
04:45:05 <ivanm> but lunabot accepts splices, etc.
04:45:11 <ivanm> all that TH and quasiquoting stuff
04:45:17 <Twey> Aye
04:45:26 <ivanm> mokrzu: note that CReal is very slow compared to using Double, etc.
04:45:45 <ivanm> so most people just stick to Double and not care about that slight loss in precision
04:46:01 <mokrzu> ok
04:46:03 <arcatan> where can i find some information on CReal?
04:46:04 <ivanm> mokrzu: http://docs.sun.com/source/806-3568/ncg_goldberg.html
04:46:10 <ivanm> arcatan: roconnor :p
04:46:29 <ivanm> it's in the numbers package
04:46:36 <ivanm> the "C" is for Computable
04:46:42 <aleator> Which is preferred way of making random numbers? mersenne-random or mwc-random?
04:46:48 <ivanm> http://hackage.haskell.org/packages/archive/numbers/latest/doc/html/Data-Number-CReal.html#t:CReal
04:46:58 <ivanm> aleator: use the latter
04:46:58 <ksf> mersenne is going to be the fastest
04:46:59 <arcatan> ah, thanks
04:47:06 <ivanm> ksf: no, mwc is faster IIRC
04:47:11 <ivanm> from bos' blog post
04:47:17 <ksf> wut?
04:47:44 <mjk> ManateeLazyCat: thank you
04:48:01 * ManateeLazyCat pasted "runTickStateT for explain state moand." at http://paste2.org/get/889131
04:48:03 <ivanm> ksf: http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
04:48:27 <ivanm> mwc-random is pulled out of statistics
04:48:30 <ManateeLazyCat> mjk: In http://paste2.org/get/889131 i have runTickStateT to explain one use of state moand.
04:48:34 <mjk> ManateeLazyCat: I go to there just now
04:48:44 <ksf> how did they manage to be faster than mersenne?
04:48:50 <ksf> (without going into numerics, please)
04:48:52 <ivanm> ksf: IIRC, the haskell implementation of mersenne isn't that great
04:49:01 <ivanm> doesn't do as much optimisations, etc.
04:49:02 <ksf> it's a c binding
04:49:12 <ksf> ...to a highly optimised sse version
04:49:28 <ivanm> ksf: see the "Due to the cheesy implementation" bit in that link
04:49:31 <ManateeLazyCat> mjk: Example, i use "runTickStateT 0 $ forM_ [1..10] $ do index <- tick ..." i can get index of current for loop. 
04:49:46 <ivanm> looks like its partially a threading issue
04:49:56 <ManateeLazyCat> mjk: So you don't need build *temporary variable* for contain index value like C.
04:50:44 <ManateeLazyCat> mjk: We use runStateT *wrap* the code block that need *update state* and we don't need *any* temporary variable.
04:50:45 <aleator> ivanm: Ok. So it is time for me to learn how to use ST then. I guess mwc is impossible to wrap in a monadrandom style?
04:50:49 <max_atreides> mjk: first focus on maybe and list monad ;)
04:51:06 <ivanm> ksf: I also recall something about how the haskell version does a single value at a time, rather than parallel or something like it should
04:51:24 <ivanm> aleator: IIRC, ST is basically the State monad with an extra "sessioN" constructor
04:51:25 <ManateeLazyCat> mjk: State moand give your feeling like "local global variable" (Â±ÄÈÉ®ÁöÑÂÖ®Â±ÄËÆøÈóÆ)
04:51:31 <ivanm> to ensure you don't mix and match ST "sessions"
04:51:35 <ksf> well mersenne has a way larger period
04:51:48 <danharaj> I am glad my irc client handles chinese :p
04:52:13 <ksf> it's 2^19937-1 vs. 2^8222
04:52:41 <ivanm> ksf: see the documentation for mwc-random as well; apparently the algorithm is also faster than mersenne
04:52:43 <mjk> ManateeLazyCat: OK, i will learn it
04:52:58 <ivanm> ksf: and yeah, in some cases you might actually care about that ;-)
04:53:15 <ManateeLazyCat> mjk: Can you understand? Or i explain it with Chinese if you like. :)
04:53:23 <ivanm> aleator: so in the case of mwc-random, I think you can ignore the PromMonad bit
04:54:00 <mjk> ManateeLazyCat: Œ“œ»—ßœ∞“ªœ¬£¨»Áπ˚”–Œ Ã‚£¨Œ“∫Õƒ„¡™œµ
04:54:18 <aleator> ivanm: I already decided that primmonad = st :) 
04:54:39 <ivanm> aleator: not quite; primmonad == ST or IO
04:54:52 <ivanm> aleator: but "ST s a" --> just ignore the s bit
04:54:56 <zygoloid> IO == ST RealWorld though
04:55:01 <ivanm> yeah
04:55:10 <ivanm> all you code will be "ST s Int" or whatever; just leave the s as a type variable
04:55:16 <ivanm> it's some random runtime thingie
04:55:41 <Matt`> I am trying to get my head around category theory as it pertains to Haskell and had a question. Are all functors defined according to the typeclass 'functor' actually all endofunctors?
04:55:46 <aleator> ivanm: That does however mean, that if I can't make a bind operator without saving/restoring mwc state in between, right?
04:56:01 <aleator>  - one "if"
04:56:29 <zygoloid> Matt`: yes. typeclass Functor is for (covariant) endofunctors on Hask.
04:58:02 <ivanm> aleator: you do _everything_ inside ST
04:58:04 <ManateeLazyCat> mjk: http://paste2.org/get/889131 ÊØîÂ¶ÇÊàëÁöÑ "runTickStateT 0 $ ..." ‰ª£Á†ÅÔºå "runTickStateT 0" ‰ºöÂú®Â±ÄÈÉ®ÂàùÂßãÂåñ‰∏Ä‰∏™ÂàùÂßãÂÄº 0, ËÆ©Âêé‰Ω†Âú® runTickStateT ËåÉÂõ¥ÂÜÖÁî® "put 1" ‰ºöÊîπÂèòÂ±ÄÈÉ®ÁöÑÂèòÈáèÂÄº‰∏∫ 1, "value <- get" ‰ºöÂèñÂæóÊúÄÊñ∞ÁöÑÂ±ÄÈÉ®ÂèòÈáèÁöÑÂÄº. ÁÆÄÂçïÁöÑÊù•ËØ¥ State Monad Â∞±ÊòØÂª∫Á´ã‰∏Ä‰∏™Â±ÄÈÉ®ÂèòÈáèÁöÑÂºïÁî®Ôºå get ÂáΩÊï∞Áî®‰∫éÂèñÂæóÂÄºÔºå put Êõ¥Êñ∞ÂÄº. ‰ΩÜÊòØÁî±‰∫é State Monad Âπ∂Ê≤°ÊúâÂÉè C ÈÇ£Ê†∑ÁöÑ‰∏¥Êó∂ÂèòÈáèÁî®‰∫
04:58:16 <ivanm> (or use save/restore; note that I'm kinda guessing here :p )
04:58:26 <zygoloid> ManateeLazyCat: i got a spam the other day which looked just like that :)
04:58:36 <zygoloid> except instead of runTickStateT it said Viagra
04:58:36 <ivanm> is it just me, or is ManateeLazyCat typing gibberish?
04:58:37 <ivanm> :p
04:58:37 <ManateeLazyCat> zygoloid: :)
04:58:41 <ivanm> zygoloid: lol
04:58:53 <Zao> Sufficiently concise at least.
04:59:09 <Zao> I wonder how much the IRC message limitation hurts CJK.
04:59:37 <Zao> Are most glyphs in common use in the 2-byte or 3-byte UTF-8 ranges?
04:59:41 <ManateeLazyCat> zygoloid: ivanm You need install CJK font to render Chinese in your irc client. :)
04:59:53 <zygoloid> ManateeLazyCat: i can see the chinese just fine. ;)
04:59:57 <ksf> .oO( freenode is 7bit-ascii/utf8 hybrid, not cjk
05:00:03 <Twey> A fair amount, especially when it gets cut off halfway through a character as in ManateeLazyCat's message above.
05:00:04 <Zao> I mean, a message that's just 200-some glyphs must be annoying.
05:00:13 <ksf> or whatever encoding that was
05:00:28 <Zao> ksf: CJK is a collective name for Chinese/Japanese/Korean.
05:00:34 <mjk> ManateeLazyCat: Œ“ø¥µΩµƒ «¬“¬Î
05:00:40 <Zao> As for the encoding, recode grokked it just fine from ManateeLazyCat.
05:00:47 <Zao> mjk still spouts gibberish.
05:00:49 <Zao> Likely GB.
05:01:14 <ManateeLazyCat> mjk: You need setup your IRC client, i can see your message correctly. :)
05:01:18 <Taejo> ManateeLazyCat: I can see ÌïúÍ∏Ä,Ê±âÂ≠óÔºåÊº¢Â≠ó just fine, but your message is garbled
05:01:41 <zygoloid> Taejo: interesting. i see your message and ManateeLazyCat's just fine, but mjk's is garbled
05:01:51 <Jafet> Obligatory boggle at people who still use GB (and big5).
05:01:55 <Taejo> ManateeLazyCat: no, I think it's your client (are you perhaps using a local encoding rather than utf-8)
05:01:59 <theorbtwo> I see the same thieng as zygoloid.
05:02:04 <ksf> the last one with the paste2 link was garbled, too.
05:02:11 <ManateeLazyCat> I can see all your message, Taejo mjk 
05:02:41 <ManateeLazyCat> Install a better CJK font, i recommend use "sudo aptitude install ttf-wqy-microhei -y" install WenQuanYi CJK font.
05:02:55 <Taejo> ManateeLazyCat: it's an encoding issue, not a font issue
05:03:02 <theorbtwo> (Now that I've switched machines to one that is using a wider font.)
05:03:05 <Taejo> at least it is for me
05:03:05 <ManateeLazyCat> Taejo: I use utf-8
05:03:13 <Taejo> strange
05:03:22 <theorbtwo> You should generally send utf8 on IRC in this modern era.
05:03:27 <ManateeLazyCat> Taejo: But you still can't see font correctly if you install bad CJK font.
05:03:45 <Taejo> maybe it's XChat's broken utf-8/latin-1 autodetection
05:04:03 <Taejo> ManateeLazyCat: I know the difference between mojibake and bad fonts
05:04:18 <zygoloid> Taejo: afaict both you and ManateeLazyCat are sending UTF-8. not sure what mjk is sending.
05:04:32 <ManateeLazyCat> zygoloid: I guess mjk use Windows XP
05:04:38 <ManateeLazyCat> zygoloid: Maybe gb2312.
05:05:04 <Taejo> ManateeLazyCat's message to mjk came out as latin mojibake for me
05:05:07 <ManateeLazyCat> zygoloid: And my irc client in Emacs can decoding (utf-8 and gb2312) those correctly.
05:05:29 <theorbtwo> Taejo: I'm not using xchat either, I'm using irssi, configured for utf8 and latin1.
05:05:47 <theorbtwo> I don't speak any of CJK, but I can recognize mojibake too.
05:05:55 <ksf> ...freenode is latin1/utf8
05:06:03 <ManateeLazyCat> Taejo: Oh, yes, i use utf-8-unix 
05:06:17 <zygoloid> ManateeLazyCat: you're right. mjk is sending gb2312.
05:06:21 <ksf> if it's not utf8, it must be latin1, so it's mojibake...
05:06:54 <ManateeLazyCat> mjk: You need change your irc client setup.
05:06:58 <zygoloid> Taejo: it sounds like your client is interpreting input as gb2312 and sending text as utf-8.
05:06:59 <Jafet> freenode doesn't give a crap what you send
05:07:09 <Matt`> if that's the case (all 'functors' in Haskell are actually covariant endofunctors), the thing I'm fuzzy on what that means for the `Haskell category.' If a functors maps from a category to itself (i.e. if it's an endofunctor), does the structure imposed by the functor and the 'lifted' functions then become part of the category? In other words, does the structure itself then become an object, and do the `lifted' functions then become
05:07:09 <Matt`> morphisms of Haskell that other functors must accomodate to fulfill the definition of being a functor?
05:07:21 <Jafet> .oO( even if they are not valid IRC commands *cough* )
05:07:27 <zygoloid> Jafet: encondings which have embedded newlines (like UTF-16) aren't gonna work...
05:07:29 <Taejo> zygoloid: since I'm not in China, that would be strange (my system locale is utf-8)
05:08:01 <theorbtwo> It's quite easy to show something isn't utf8, so almost all irc clients should be set to display utf8... so you should send utf8, which almost all irc clients should be able to display.
05:08:42 <ManateeLazyCat> Ok, i try to avoid typing Chinese confusion so many peoples. :)
05:09:08 <Taejo> haha
05:09:58 <Philonous> -- fmap (fmap reverse) -- Matt`: liftet liftet function. 
05:10:04 <Philonous> @type fmap (fmap reverse) -- Matt`: liftet liftet function. 
05:10:05 <ManateeLazyCat> mjk: You can try install Emacs in Windows XP, then you can use erc (M-x erc) or rcirc (M-x rcirc) to send utf-8 message.
05:10:13 <Philonous> Ah, snap, bot's down
05:10:19 <ManateeLazyCat> mjk: Then less confusion.
05:10:57 <Matt`> Or are functors to be thought of as a seperate 'category' that operate on, but are part of their target/src categories?
05:11:09 * ManateeLazyCat I hate WindowsXP default setup with gb2312 that make file can't portable in different OS.
05:11:39 <zygoloid> Matt`: every Functor defines a subcategory of Hask, and any pair of such Functors can be combined to give a new functor (no capital F)
05:12:38 <zygoloid> up to isomorphism, Functors compose to give Functors.
05:13:04 <ManateeLazyCat> mjk: The key of "State Monad" is runStateT, If you still can't understand "State Monad", forgot it, just use it when you have much temporary variable in your code.
05:13:46 <ManateeLazyCat> mjk: First try to use "IO monad", "Maybe Monad" with "do".
05:13:59 <zygoloid> (only up to isomorphism because Functor instances must be unary type constructors, and the type-level lambda /\x -> F (G x) is not a unary type constructor in this sense)
05:14:12 <ksf> ManateeLazyCat, you're not alone, I stumble across broken newlines often enough
05:18:13 <Matt`> zygoloid: thanks for the answer, that makes sense in terms of composition (and only being true up to an isomorphism), but what is realationship of a subcategory to a category (if that question makes sense)? I guess I'm trying to get my head around the following: I define a new functor, what then becomes of the Haskell category? Does it grow to include my new functor, or is a subcategory to be thought of as a related, but distinct
05:18:13 <Matt`> entity?
05:19:43 * hackagebot hmatrix-gsl-stats 0.1.0.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.0.1 (VivianMcPhail)
05:20:20 <ksf> Matt`, as a non-ctian I would say that you can define category theory is Hask, including Hask, which is proven by the existence of haskell compilers.
05:20:25 <ManateeLazyCat> Investigation: Do you like "command completion" feature for temrinal? I mean you can complete terminal command/option like type code in eclipse : popup completion menu. 
05:20:27 <ksf> ...that are written in haskell
05:20:51 <ManateeLazyCat> I plan to rewrite a new terminal with haskell/gtk+ since all terminal gtk+ widget don't support model/view split. 
05:21:22 <ksf> s/is/in
05:21:40 <ManateeLazyCat> In "command completion menu" of terminal, you don't need hit "TAB" many times for switch command/option, all feedback are visible.
05:22:12 <ksf> shells do completition, terminals are dumb
05:22:26 <ManateeLazyCat> ksf: I mean "completion menu" integrate with shell's output.
05:22:54 <ksf> ah
05:23:00 <ManateeLazyCat> ksf: Do you like it?
05:23:20 <ksf> I'm not sure I care, zsh uses the terminal quite good.
05:23:23 <ManateeLazyCat> ksf: You don't need hit "TAB" key to guess what's the next command/option.
05:23:38 <ManateeLazyCat> ksf: It's my new idea when i develop my editor.
05:24:04 <ManateeLazyCat> ksf: I think why not include those feature in terminal? I think this idea will save much time for command complete.
05:24:10 <ksf> I think that'd better be done on the shell level, too.
05:24:29 <ksf> because a terminal is basically a dumb buffer for characters
05:24:32 <Matt`> ksf: thanks for the answer
05:25:01 <ksf> ...it already has all the features you need to display completitions
05:25:34 <ksf> ManateeLazyCat, but there's another terminal/editor-like thing I'd like to have
05:25:35 <ManateeLazyCat> ksf: Yes, just filter shell's output and display those result with gtk+ menu. :)
05:25:46 <ksf> actually, editor.
05:25:49 <ManateeLazyCat> ksf: Listen... 
05:26:31 <ksf> which is a mode in which source (e.g. a lhs2tex) file is displayed rendered with tex, but when you move the cursor somewhere, the original ascii source is displayed
05:26:55 <Zao> ksf: Sounds like the latex-mode in emacs :D
05:27:21 <ManateeLazyCat> ksf: http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png is my multi-threads framework for "completion menu", so no technology for frontend, just need some algorithm to build back-end. 
05:28:39 <ksf> Zao, I've never, ever seen real tex output intertwined with input
05:29:21 * ManateeLazyCat Emacs use *overlay* technology to for "code completion UI", but it's bad when you use CJK language. 
05:29:26 <Zao> ksf: I do not use emacs though, otherwise that would have been a very welcome tool in my toolbox.
05:30:31 <ManateeLazyCat> ksf: You mean will popup tooltip to display ascii source when cursor move to tex? Like Google-Page-Transform ?
05:30:41 <ksf> it'd also kill some of tex features. there'd be no way to do pages, and everything would be paragraph-by paragraph
05:30:57 <ksf> vbox by vbox, that is.
05:31:32 <aristid> i've written a small module to get MonadPlus for IO, comments? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26482#a26482
05:31:33 <o-_-o> if I have something like [[1,2,3],[1,2,3]] how do I make it into [1,2,3,1,2,3] ?
05:31:47 <ksf> I was thinking of having it inline, but the more important issue is to be able to navigate the cursor through the tex file
05:31:47 <ManateeLazyCat> o-_-o: zip
05:32:01 <Zao> o-_-o: concat.
05:32:03 <ksf> I don't know whether that's even possible with tex, at least in general
05:32:22 <ksf> wait I'm spouting nonsense.
05:32:43 <ManateeLazyCat> ksf: No worried, i know you mean, i will consider them in my tex viewer. :)
05:32:55 <ksf> you'd navigate the tex file vbox by vbox, where the source of the active vbox would change do ascii display/edit mode
05:32:58 <Zao> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Prelude.html#v%3Aconcat
05:33:13 <Zao> ( which is  concat = foldr (++) [] )
05:33:30 <ManateeLazyCat> ksf: Truct me, it's those easy to implement. :)
05:33:41 <ManateeLazyCat> s/it's those/those.
05:33:56 * ManateeLazyCat Damn, stupid english-helper, stop typo !
05:35:24 * ManateeLazyCat I will build a better English-Helper in my system, not just correct spell. Correct syntax error in real-time...
05:36:17 <ManateeLazyCat> Zao: Are you Chinese too?
05:36:52 <aristid> ManateeLazyCat: it's probably easier to learn english very well than to write a program to correct the grammar rudimentarily
05:37:16 <Zao> ManateeLazyCat: No.
05:38:10 <ManateeLazyCat> Zao: Japanese? Or Korean?
05:38:51 <Zao> ManateeLazyCat: Swedish.
05:39:23 <ManateeLazyCat> Zao: Wonder your Chinese knowledge. :)
05:39:59 <Zao> ManateeLazyCat: Text and scripts are interesting.
05:40:15 <Zao> My foreign language skills are horrible though, english and very horrible german.
05:40:28 <ManateeLazyCat> I remember I was deceived by a native Argentine, and his Chinese so great.
05:40:51 <ManateeLazyCat> And a French guy.
05:41:10 <aristid> so, comments about my module? it's one of my first haskell modules with more than 10 lines
05:43:00 <ManateeLazyCat> ivanm: Yes, there has a Chinese transform for RWH, but i prefer to read English version. :)
05:44:39 * ManateeLazyCat I do not like the translation version, the original a little more *pure*. :)
05:44:41 <Zao> ManateeLazyCat: The term you are looking for is "translation"
05:45:22 <ManateeLazyCat> Zao: Well, i my English-Helper will output typo when i type so fast. :)
05:45:53 <ManateeLazyCat> Zao: I wrote English message like type code in editor, select from menu. :)
05:46:29 <ManateeLazyCat> Sometimes, I select wrong candidate word. 
05:49:06 <mietek> "We're looking for Senior Developers, especially ones with functional or dynamic object-oriented development experience (e.g., Lisp, Smalltalk, Scheme, Ocaml, SML, Haskell, Ruby, Unlambda, C++/STL/Boost, or advanced use of Python or Perl)."
05:49:32 <mietek> I wonder, is this a warning sign, or the exact opposite?
05:50:05 <fasta> mietek, that depends on who wrote it. 
05:50:10 <aristid> mietek: it does seem a bit random.
05:50:25 <tromp_> who writes that?
05:50:49 <mietek> Either someone who just tries to list anything functional, or someone who's making an in-joke.
05:50:55 <aristid> http://seeker.dice.com/jobsearch/result/10121572/082009FL/portland,%20OR/software-developer
05:51:07 <aristid> google found only one result, and this was it
05:51:45 <tromp_> it all looked sensible, right up to "unlambda"
05:51:54 <fasta> mietek, I don't think the people working at that company are clueless.
05:52:06 <fasta> mietek, so, it is probably just a joke by one of the developers.
05:53:12 <mietek> I certainly don't think they are clueless.
05:53:31 <mietek> It just may happen that the ad description isn't written by a developer.
05:54:25 <aristid> one should reply with "I specialise in Unlambda, and for imperative purposes Brainfuck programming." or so :D
05:55:45 <danr> Is cabal-install included in haskell platform?
05:56:02 <Zao> Normally, I believe.
05:57:17 <byorgey> yes, it is.
05:59:01 <danr> Zao: byorgey: thanks :)
06:02:03 <ksf> mietek, stay away from that job. sane people would have listed lazy-k instead of unlambda
06:17:02 * hackagebot hstatistics 0.2.0.1 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.1 (VivianMcPhail)
06:18:13 <djahandarie> Wow, Lazy K is nice
06:18:32 <ivanm> lazy K?
06:18:47 <djahandarie> Pure version of unlambda
06:18:56 <ivanm> aha
06:18:58 <zygoloid> ezyang: in your latest blog, shouldn't 'abcPrompt' be 'AbcPrompt' etc?
06:19:00 <ivanm> link?
06:19:09 <djahandarie> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
06:21:03 * hackagebot hstatistics 0.2.0.2 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.2 (VivianMcPhail)
06:22:05 <ivanm> wow, the haskell reddit has spam...
06:22:06 <ivanm> hey TacticalGrace 
06:22:23 <TacticalGrace> hey
06:26:43 <blackh> TacticalGrace: Hi there. I've got a couple of functions from the game to play. The licence is GPL - I hope that's not going to be too annoying. One of them rasterizes a list of triangles. Next job is to express them in accelerate.
06:26:54 <blackh> ...to play with.
06:28:25 <TacticalGrace> blackh: Accelerate is BSD3, so will not interfere with GPL
06:29:07 <TacticalGrace> blackh: anyway, it's great that you could get the code for this
06:30:29 <blackh> It seems like quite a nice test case for accelerate. The second function merges some splotchy patterns.
06:45:08 <Athas> How do I access the values of C preprocessor definitions when writing using the FFI?
06:45:15 <Athas> For example, the O_NOCTTY flag.
06:45:44 <blackh> Athas: hsc2hs is how you do it.
06:46:47 <blackh> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/hsc2hs.html
06:52:12 <fasta> blackh, isn't c2hs better these days?
06:53:46 <blackh> I don't know
06:56:30 <fasta> Athas, you might want to use c2hs instead. 
06:57:06 <Athas> fasta: hm.  For this, I will just grab the values from the header files.
06:59:11 <ccasin> +1 for c2hs.  You can use "enum define" to convert macro flags to datatypes
06:59:17 <fasta> Athas, that's only a good solution on the short term. 
06:59:39 <Athas> fasta: well, it's a good solution for standardised POSIX headers, not for arbitrary libraries.
07:00:39 <ksf> Athas, forget what blackh said and use c2hs
07:02:34 <ksf> Athas, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26375
07:03:26 <syzygic> Hello everyone
07:03:42 <ksf> ...what it doesn't show is the removal of the boilerplate functions and instance with $(deriveHasSet ''FileMode)
07:03:53 <ksf> soon to arrive on a hackage server near you.
07:04:04 <syzygic> I have a noobie question between two versions of a program I am trying to parallel.
07:04:36 <syzygic> in one, I use parMap to map a function over a list
07:04:40 <Athas> -- FIXME this doesn't look like boilerplate but a car crash.
07:05:04 <ksf> you can then write yourself a function open :: Set FileMode -> IO () and do open (fileNonBlocking <> fileNoTTYCtrl
07:05:13 <fasta> Athas, in Haskell code? Heh. 
07:05:26 <ksf> yep, the fix is at the very bottom.
07:05:26 <syzygic> in another, I group the list into clusters, and then use parList to apply a function to each chunk
07:05:31 <syzygic> both using rwhnf
07:06:06 <syzygic> at this time, the clustering just makes a bunch of bins of size 1, essentially wrapping the list elements in a list of lists.
07:06:23 <ksf> what is virtually impossible to get rid of is to write the enum definition for the O* flags, as O_RDOnly etc. don't belong to the set.
07:06:36 <syzygic> for some reason, the clustering version is significantly faster than the parMap version.  Is there an easy explanation for this?
07:07:22 <fasta> syzygic, without an exact test case, nothing will happen. 
07:07:50 <syzygic> ok, so I should try to come up with an easy actual example to present?
07:08:21 <syzygic> sorry for just stumbling in with an ill defined question ;)
07:09:09 <fasta> syzygic, yes, something which can be directly loaded into ghci with a shell script to load it. Then if nobody takes the time to try in this channel, you can send that to the mailing list. 
07:09:33 <fasta> syzygic, the shell script is probably not needed in 99% of the cases.
07:09:49 <mm_freak> why does genericTake take an Integral?  Num works as well?  is it so that people cannot use imprecise types?
07:09:58 <blackh> syzygic: There are all sorts of possible things going on, so that's why we really need to see the code.
07:10:03 <syzygic> fasta, thanks
07:10:10 <syzygic> and blackh
07:10:19 <syzygic> yeah, I suspect there is a space leak
07:10:25 <fasta> mm_freak, in Haskell people write what they mean. 
07:10:41 <fasta> mm_freak, it is not "let the machine figure out what I meant". 
07:10:47 <ksf> then they would write "Natural"
07:11:20 <fasta> mm_freak, that is possible, but not the philosophy. 
07:11:50 <mm_freak> fasta: using Integral means:  "i want integer division/modulo and conversion to Integer"
07:12:34 <Nip8888> can i make haskell platform portable?
07:12:37 <fasta> mm_freak, I was referring to the Num part. 
07:13:24 <mm_freak> fasta: i don't know what you mean
07:13:55 <fasta> mm_freak, "Num works as well?", but maybe we should start over and I guessed your question wrongly.
07:14:34 <mm_freak> fasta: ok, let me elaborate:  to implement genericTake the Num class is sufficient
07:14:44 <mm_freak> no need to constrain to Integral
07:15:02 <mm_freak> but Data.List's genericTake has an Integral constraint
07:15:05 <mm_freak> why?
07:15:39 <Igloo> What would  genericTake 2.3 "abcde" be?
07:15:39 <sclv> What is take 1.5 of [1,2] ?
07:15:59 <mm_freak> Igloo: probably the whole list
07:16:21 <mm_freak> yes, but there should be other ways to constrain that, because using Integral makes no sense
07:16:28 <Igloo> Why not?
07:16:31 <ksf> mm_freak, float/double don't even guarantee that you can +1 and get a different value.
07:16:37 <mm_freak> there are integral types in the mathematical sense, which are not Integral in the haskell sense
07:16:40 <Axman6> why not? you can only take an integral number of elements from a list
07:16:44 <sclv> if we had a Natural typeclass that would help.
07:16:45 <mm_freak> integral fields for example
07:16:51 <mm_freak> sclv: i agree
07:17:15 <fasta> mm_freak, What should genericTake (5.0::Double) [1,2,3,4] do?
07:17:38 <fasta> mm_freak, What about genericTake (4.9999999999999999999::Double) [1,2,3,4,5] do?
07:17:40 <mm_freak> fasta: it should be invalid, but not by an Integral constraint
07:18:04 <fasta> mm_freak, by what should it be invalid?
07:18:13 <blackh> Nip8888: Can you re-phrase the question?
07:18:13 <sclv> mm_freak: arguably, since Integral provides conersion to an Integer, then it *does* make sense.
07:18:17 <Igloo> mm_freak: I think what you're really saying is that some of the Integral methods should be in another class
07:18:21 <fasta> Integral basically means "indexable".
07:18:33 <Gracenotes> isn't that Enum? :/
07:18:40 <mm_freak> well, Integral means much more than indexable
07:18:45 <Axman6> take Nothing [1,2,3]
07:18:48 <ksf> using Ix would've been an idea
07:18:57 <fasta> Gracenotes, no, that means that you can go from one to the other element. 
07:18:58 <mm_freak> ksf: yeah, that's a good idea
07:18:58 <Gracenotes> still all base Integrals are Enum afaik
07:19:01 <Axman6> take (Just (-17)) [1,2,3]
07:19:12 <sclv> if Enum used Integers instead of Ints, then arguably Enum would make more sense, true...
07:19:28 <Gracenotes> yeah, it causes incorrectness in several instances..
07:19:31 <Axman6> hey why don't we have a basical type in haskell for unsigned, unlimited precision integers?
07:19:38 <Axman6> Integer without the negatives
07:19:45 <Axman6> basic*
07:19:48 <Nip8888> blackh: i wonder if i could copy the whole directory to my pendrive and use it elsewhere.
07:19:52 <Axman6> basical? wtf
07:20:01 <Gracenotes> I just take 'indexable' as 'enumerable'
07:20:10 <sclv> Axman6: because such a type, if it allows subtraction, is partial.
07:20:13 <ksf> Axman6, because people don't like to use pattern matching to subtract?
07:20:16 <fasta> Axman6, because there would be little to no point?
07:20:22 <Gracenotes> although then again there's no guaranteed order for enumeration.. meh, me mumbles
07:20:25 <ksf> but even then, it makes sense.
07:20:29 <Axman6> i've had plenty of times where i
07:20:32 <Axman6> i'v e wanted it
07:20:38 <ksf> - would be partial and there'd be a way to recurse on it.
07:20:39 <blackh> Nip8888: I think the answer is no, but I'm not sure.
07:20:40 <sclv> There's a Nats package on hackage that does a good job
07:21:03 <Zao> You're Nats!
07:21:03 <fasta> Axman6, in performance terms for large numbers you are not going to win a lot by doing that.
07:21:23 <fasta> Oh, look, we won one bit.
07:21:31 <sclv> the nats package actually is slower in performance, compared to Integer. But it is lazy!
07:21:40 <mm_freak> hmm
07:21:53 <mm_freak> maybe 'take' should just take an Integer =)
07:22:05 <Zao> Isn't there a genericTake?
07:22:14 <mm_freak> Zao: that's what the discussion is about
07:22:23 <sclv> so using it, genericTake (length $ cycle [1]) [1..5] is well defined :-)
07:23:02 <sclv> mm_freak, as opposed to taking something that can be represented as an integer ??
07:23:06 <fasta> mm_freak, if you want a mm_freak_genericTake that does whatever you want, you can easily wrap the other instances. 
07:23:07 <sclv> seriously.
07:23:29 <fasta> mm_freak, but I would probably put a -- WTF comment above it when encountering it ;)
07:23:31 <mm_freak> fasta: that's neither a proposal, nor a complaint‚Ä¶  it's a discussion
07:23:31 <Nip8888> i notice the installation set several envirnment variables. Path for example. if i set the path of another computer, does that means i can bypass the installation?
07:23:34 <geheimdienst> what about this? genericTake (length $ cycle [1]) [1..]
07:24:05 <sclv> geheimdienst: Actually yeah, that should work too.
07:24:19 <mm_freak> sclv: well, i think it's easy to optimize:  if it's a short integer, use takeShort#, if it's a long integer use takeInteger#
07:24:26 <fasta> geheimdienst, that's bottom. 
07:24:33 <sclv> fasta: not with lazy naturals!
07:24:44 <geheimdienst> that was tongue-in-cheek :-) what would it produce, an infinite list?
07:24:46 <Nip8888> if the installation does nothing else but setting environment variable, maybe i can bypass installation?
07:24:58 <sclv> yep, exactly, it would give the whole infinite list back.
07:25:22 <sclv> the whole point of lazy nats is so that you can do things like (length $ cycle [1]) > 5 and get a real answer.
07:25:27 <fasta> sclv, oh, right. 
07:25:46 <fasta> Still, are there any end-user applications that use lazy naturals?
07:25:57 <mm_freak> well, the infinite list would be a bit different
07:26:09 <Zao> Nip8888: Try it and see. I would expect that there's full paths hardcoded in package databases, so you probably want it in the same location on all machinse.
07:26:22 <mm_freak> producing the n'th element would become an O(n) space operation instead of O(1)
07:27:53 <sclv> just checked -- no reverse dependencies on the nat package at the moment
07:27:59 <Nip8888> Zao: thanks. didn't know about hardcoded thing. I'll try.
07:30:23 <sclv> mm_freak: with a smart encoding, log(n)
07:30:47 <mm_freak> sclv: then it's much less lazy
07:31:33 <pastorn> i want to make a numerated list with haddock
07:31:51 <pastorn> does it support it... i can't find it in this document i have here :(
07:31:55 <sclv> ?hackage nat
07:32:10 <sclv> http://hackage.haskell.org/package/nat
07:42:30 <zygoloid> mm_freak: producing the nth element could still be done in O(1) space. the head of the nat gets GC'd along with the head of the list.
07:43:22 * geheimdienst would also like to have his head gc'd sometime
07:44:00 <mm_freak> zygoloid: i wouldn't count on that, unless there is something like Nat fusion or something
07:44:31 <mm_freak> i think we should just try it out
07:46:15 <sclv> zygoloid: I think you're right, but only with a specialized take function
07:46:54 <sclv> or hmm.. maybe not. Take already does (n-1), I think...
07:50:56 <roconnor> @bot-snack
07:51:25 <k77> same people everywhere ;-)
07:53:22 <zygoloid> mm_freak: why would any fusion be required?
07:54:17 <Athas> What's the System.Posix wrapper to fcntl?
07:54:39 <Athas> In general, is there a POSIX<->Haskell dictionary?  I find that the concepts map damn well, but the names... not always.
07:55:24 <zygoloid> (put another way, what is the space you think will be leaked, and who is holding onto it?)
07:56:39 <ksf> Zao, the paths to the database etc. are coded in the ghc shell scripts
07:56:44 <ksf> ...at least on unix
07:57:10 <ksf> there's nothing hidden away where you can't reach it with a text editor.
07:57:11 <Zao> ksf: And package.conf etc?
07:57:38 <Zao> ksf: As he talks about the installer and setting env vars, I assume it's Windows.
07:57:47 <ksf> Zao,  cat `which ghc` and see
07:58:03 <ksf> ghc isn't using env vars afaik
07:58:30 <ksf> and cabal shouldn't do such thigs itself but always use ghc-pkg
07:58:46 * hackagebot criterion 0.5.0.1 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.1 (BryanOSullivan)
07:58:51 <ksf> ...so what might be necessary is to set a proper PATH
07:58:55 <Zao> ksf: The HP adds PATH etc to have ghc findable.
07:58:57 <geheimdienst> i guess cabal needs to find ghc-pkg and such, so PATH would be relevant
08:04:24 <triyo> Using parsec manyTill combinator, how would I end on a last occurrence of a string and not first? So something like .... manyTill anyChar (string ":-:") ... but last occurrence of ":-:"
08:05:11 <dcoutts> ksf: right, cabal just used the PATH to find ghc (though on windows it finds other ghc tools relative to where it finds ghc)
08:05:44 <ksf> triyo, don't use manyTill
08:05:50 <ksf> and bleeding tokenise
08:06:37 <triyo> ksf: so use what exactly instead of manyTill?
08:07:02 <ksf> if you tokenize, you just slurp everythnig but the :-: token
08:07:43 <ksf> or, well, you can do many (anyChar `manyTill` string ":-:") and concat the stuff
08:08:12 <ksf> wait you'd need "someTill" or it's a kleene star of a possibly empty production.
08:08:21 <geheimdienst> you mean it's better to use Text.Parsec.Token?
08:08:38 <ksf> I don't like parsec in the first place, but yes.
08:09:22 <geheimdienst> what's an alternative to parsec?
08:09:41 <geheimdienst> also, i think you could have the manyTill .. (string ..) in a function, then add a "try" that recursively calls the function
08:09:58 <ksf> uulib
08:10:03 <ksf> attoparsec
08:10:06 <ksf> Gf
08:10:32 <ksf> "try" is the reason I loathe parsec
08:10:43 <mm_freak> zygoloid: i'm not sure at all‚Ä¶  i think i'll try it out, when i'm back later
08:11:07 <geheimdienst> thanks for the pointers. sounds nice
08:11:07 <mm_freak> ksf: in attoparsec you need try as well
08:11:21 <ksf> you don't with uulib
08:12:44 <mm_freak> i use attoparsec mostly because it's very fast
08:12:55 <zygoloid> mm_freak: it depends on how genericIndex is implemented. if it counts up, then it'll leak. if it counts down, it should be fine. it really should count down...
08:13:28 <mm_freak> yeah, counting up wouldn't make much sense
08:13:38 <mm_freak> either way
08:15:11 <soupdragon> say I had an command line program (stdin/stdout).. how can you make that into an IRC bot in haskell?
08:15:47 <mm_freak> soupdragon: use netcat?
08:15:57 <ksf> oleg has a nice pipe IO thingie
08:20:55 <djahandarie> Lol, lambdabot is gone again?
08:21:38 <geheimdienst> lambdacats, lambdabot, the list of casualties gets longer and longer
08:21:53 <aristid> Last is the dual monoid of First, right?
08:21:55 <djahandarie> lambdabot is almost as unreliable as c.h.o
08:25:34 <zygoloid> aristid: right.
08:27:41 <aristid> so, i am somehow disappointed by MaybeT, maybe there should also be a FirstT and LastT?
08:28:21 <zygoloid> how would those work? there are multiple monoids for Maybe, but i think there's only one monad.
08:31:28 <aristid> zygoloid: well, the Maybe MonadPlus works like First
08:31:31 <zygoloid> they'd make sense as alternatives for MonadPlus i guess
08:31:37 <zygoloid> hah, yeah. :)
08:31:39 <aristid> zygoloid: the Monad itself would work the same for each
08:32:00 <aristid> and LastT Identity would give you a Last MonadPlus :D
08:34:22 <zygoloid> LastT wouldn't be the dual of FirstT then (since LastT would evaluate all alternatives and FirstT would stop on a Just)
08:35:08 <aristid> zygoloid: yeah, the duality is just for First and Last itself
08:35:26 <aristid> i was just trying to make sure i understand First and Last
08:40:32 <aristid> zygoloid: the whole reason is that i want to use guard and <|> with regular monads
08:43:20 <aristid> hmmm
08:48:02 * hackagebot hstatistics 0.2.0.3 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.0.3 (VivianMcPhail)
08:51:03 * hackagebot hmatrix-gsl-stats 0.1.1.1 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.1.1 (VivianMcPhail)
08:58:05 * hackagebot hmatrix-gsl-stats 0.1.1.2 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.1.2 (VivianMcPhail)
09:01:32 <soupdragon> On this day 40 years ago, Neil Armstrong and Buzz Aldrin became the first humans to walk on the Moon. This was quite an achievement for mankind and a key milestone in world history.
09:01:32 <soupdragon> To commemorate this event the Command Module code (Comanche054) and Lunar Module code (Luminary099) have been transcribed from scanned images to run on yaAGC (an open source AGC emulator) by the Virtual AGC and AGS project. 
09:01:38 <soupdragon> http://googlecode.blogspot.com/2009/07/apollo-11-missions-40th-anniversary-one.html
09:02:02 <soupdragon> it's written in some kind of moon language
09:02:13 <soupdragon> X4	DEC	0B0		#	XFR ORB PARAM.
09:02:13 <soupdragon> VHSQ	EQU	X4		# 0B26	VH SQUARED
09:02:13 <soupdragon> TR2	EQU	X4		#	ADDR. OF 2ND MATRIX FOR MXM
09:02:42 <djahandarie> lol
09:05:36 <bstamour> interesting
09:05:45 <Veinor> ewwwwwwwwwww
09:15:35 <aristid> > runFirstT (let z = True in (guard z >> putStrLn' "z") <|> (guard (not z) >> putStrLn' "!z"))
09:15:35 <aristid> z
09:15:39 <aristid> ^ zygoloid :)
09:16:54 <shivam3013> hidoes an
09:16:59 <shivam3013> yone here know how to code?
09:17:14 <shivam3013> huh
09:17:41 <shivam3013> anyone>
09:21:01 <ogt> hi
09:21:13 <ogt> hi
09:21:20 <ogt> any ops here
09:21:55 <soupdragon> hey
09:22:12 * Baughn just got the type-checker to freeze. Now there's a first.
09:22:13 <jmcarthur> ?
09:22:38 <bstamour> how'd you manage that?
09:23:04 <Baughn> A combination of overlapping instances, undecidable instances, type families and.. oh, I think there's an incoherent instance here, too.
09:23:16 <djahandarie> Eh? I don't think that was soupdragon, his username is usually "quantum"
09:23:16 <bstamour> :S
09:23:52 <bstamour> I've never done anything quite that advanced yet.
09:24:11 <jmcarthur> djahandarie: *her username, methinks
09:24:46 <djahandarie> Blah, gender, who needs it anyways
09:25:12 <pastorn> Baughn: what are you trying to make?
09:25:17 <Veinor> fuckin gender, how does it work
09:25:37 <Baughn> pastorn: Type-safe in-memory relational database
09:25:54 <Baughn> pastorn: With type-level lists for the indexes
09:26:00 <djahandarie> That sounds useful
09:26:08 <pastorn> Baughn: sounds cool :D
09:26:08 <Baughn> If I can make it work. :P
09:26:18 <djahandarie> Baughn, did you see that galios presentation "Databases are Categories"?
09:26:18 <ClaudiusMaximus>  i made type checker exhaust my memory and crash once...
09:26:22 <djahandarie> Or maybe it was the other way around...
09:26:24 <Baughn> djahandarie: Yep
09:26:38 <Baughn> You can thank Saizan for the impetus, I'm just expanding his system a bit. ;)
09:27:36 <Baughn> Lots of type-level hackery, with a sprinkling of TH for flavor.
09:28:32 <djahandarie> If lambdabot were here I'd make her recall that quote
09:36:50 <aristid> seems like the monoids package is defunct :/
09:57:55 <sclv> aristid: huh?
09:58:42 * sclv continues to be amazed by just how freaking *nice* the finally tagless approach is compared to all of its predecessors.
10:01:56 <Palmik> Hmm, what advantages do guards have over if then else?
10:02:27 <zygoloid> Palmik: if/then/else is ugly
10:02:40 <Palmik> zygoloid, ok, fair enought :)
10:02:40 <zygoloid> in haskell'10 you can use pattern matching in guards
10:02:41 <sclv> if you need to neset ite, it gets awful looking, fast.
10:02:44 <sepp2k> Palmik: You can combine them with pattern matching.
10:02:46 <Baughn> Palmik: Any time you want more than two clauses
10:03:01 <Palmik> Ok, thanks guys :)
10:03:14 <Baughn> Palmik: Oh, and pattern guards
10:03:19 <sclv> | a <- maybeA = return a; | otherwise -> fail "no a!";
10:03:33 <zygoloid> guards let you fall through to another case if the guard fails (because you've not crossed the = sign yet)
10:03:54 <zygoloid> eg: foo (x:xs) (y:ys) | x < y = x:foo xs ys; foo xs ys = xs ++ ys
10:04:05 <zygoloid> ^^ you can't do that with an if
10:06:00 <aristid> sclv: "huh"?
10:06:13 <sclv> what did you mean aboud monoids?
10:12:42 <Palmik> zygoloid, hmm, I do not get the "x:foo xs ys" part :D when the guard is matched it always returns the first list... to me, it seem like some kind of recursion, but it's the : what confuses me (I know what the (:) does, but the more I'm confused)... I could not tell what it would do just by looking at it :/
10:14:10 <sepp2k> Palmik:  It prepends x to the result of  foo xs ys
10:15:32 <zygoloid> Palmik: a simpler example then: foo a 0 | a < 5 = 0; foo a b = a + b
10:15:58 <zygoloid> Palmik: here, foo 10 0 == 10, despite the first pattern matching, because the guard fails.
10:15:58 <mokrzu1> hello, can i write in ghci function that have more than one line ?
10:16:48 <sproingie> use braces
10:16:57 <Palmik> zygoloid, yep... it is the weird recursion that confuses me... will have to take a sheet of paper and try it on a paper :D
10:17:15 <BMeph> sclv: edwardk is re-doing the monoids package, since 1) in later versions he dropped some things that other folks wanted back; 2) the latest version doesn't work with 6.12._ (it has an 'arrays-0.2.0.0' dependency)
10:17:36 <Palmik> I guess I'm not used to that kind of tjinkikg yet... to be able to see the result on a first glance
10:17:43 <Palmik> *thinking
10:17:46 <sproingie> actually i've no idea if braces work in the interactive mode.  i only saw them at work for a .ghcirc
10:18:37 <zygoloid> Palmik: that function doesn't do anything obviously useful i'm afraid
10:19:48 <sclv> ah, right. thanks
10:20:03 <zygoloid> (if you change the last case to just "foo xs ys = ys" then it does something a bit more interesting)
10:20:23 <Palmik> Aah, now I know why it does what it does :D
10:20:45 <Palmik> it was just coincidence that it returned the first list :D
10:27:31 <aristid> sclv: this permanent join/part by some people is confusing. anyways, i'm making monad transformers for First and Last :)
10:36:40 <proq> aristid: some of the better irc clients can filter those out
10:38:10 <aristid> proq: yeah, mine can do that too, i just have to enable it.
10:38:45 <proq> pastorn: what arm hardware are you running ghc on?
10:47:19 <djahandarie> JoesphL0t, fix your connection lol
10:47:25 <djahandarie> Or not
10:51:19 * lispy recommends disabling part/join messages :)
10:52:23 --- mode: ChanServ set +o monochrom
10:52:27 <gwern> preflex: seen Cale 
10:52:28 <preflex>  Cale was last seen on #haskell 10 hours, 17 minutes and 41 seconds ago, saying: What GHC version?
10:52:35 <Cale> hi
10:52:42 --- mode: monochrom set +b *!*@64.120.233.114
10:53:10 <syzygic> Is there a good place to read about exactly how far evaluating something to rwhnf takes you?
10:53:32 <tommd> The data declaration?
10:54:05 <gwern> Cale: you were complaining about excess L.hs files? I'm pushing a mueval change to clean them up. it should work, assuming hint/ghc api strictness on loading modules isn't random and peculiar to my machine
10:54:11 <monochrom> connection fixed :)
10:54:18 --- mode: monochrom set -o monochrom
10:55:41 <syzygic> i guess I mean when one says it evaluates to the 'outermost constructor' that means it would stop at a [ or ( but would evaluate a map over a list for example
10:56:13 <c_wraith> syzygic, remember that list constructors are actually : and []
10:56:22 <syzygic> right, ok good
10:56:43 <c_wraith> So evaluating a list to whnf evaluates enough to determine whether it's using the : or [] constructor, but no more
10:57:05 <Twey> (which is why ‚Äònull‚Äô is the cheapest operation on lists)
10:57:34 <syzygic> ok thanks
10:57:41 <gwern> no, the cheapest operation is id
10:57:45 * gwern feels like being contrary
10:57:56 <Twey> Is that an operation?
10:58:04 <Twey> It's certainly not a list operation :√æ
10:58:27 <c_wraith> sure it is.  a unifies with [a'].  :)
10:58:39 <gwern> > id [1,2]
11:00:25 <benmachine> [1, 2]
11:00:50 <gwern> Twey: see!
11:01:01 <Twey> Hehe
11:01:05 <Twey> But you haven't done anything to it!
11:01:34 <Twey> c_wraith: Surely a ‚Äòlist operation‚Äô is one that forms or uses part of the definition of lists
11:01:54 <Twey> Otherwise e.g. ‚Äòconst‚Äô is also a map operation :√æ
11:02:48 <gwern> Twey: I'd say it has part. I mean, look, 1 was part of the input, and was part of the output; 2 was part of the input, and part of the output
11:03:25 <Twey> How does that form or use part of the definition of lists?
11:03:35 <djahandarie> Cale, lambdabot is down again
11:03:53 <Twey> That definition being data [a] = [] | a : [a]
11:05:13 <gwern> hm, gitit is eating 50% of my ram and 100% of a core
11:05:27 <gwern> perhaps I need to improve the performance of my link-archiver plugin
11:14:50 <Cale> gwern: Thanks! That'll prevent the /tmp on lispy's hosting from filling up :)
11:15:11 <Cale> djahandarie: Okay, let me have another look
11:15:16 <lispy> Cale: ?
11:16:01 <djahandarie> link-archiver?
11:16:06 <lispy> Cale: is the link-archiver a lambdabot plugin?
11:16:12 <Cale> lispy: /tmp slowly fills up with small files, one for every expression lambdabot evaluates. On one occasion there were enough of them that I had to use xargs to delete them all.
11:16:20 <Cale> link-archiver, what?
11:16:26 <lispy> Cale: yikes!
11:16:40 <benmachine> Cale is not responding to gwern's most recent message
11:16:44 <lispy> Cale: oh, on my screen the last thing gwern said was that he needed to optimize his gitit link-archiver...
11:16:51 <ksf> wtf the package "encoding" depends on HaXml
11:16:58 <Cale> <gwern> Cale: you were complaining about excess L.hs files? I'm pushing a mueval change to clean them up. it should work, assuming hint/ghc api strictness on loading modules isn't random and peculiar to my machine
11:17:04 <Cale> ^^ that's what I was replying to
11:17:12 <Palmik> !books
11:17:18 <lispy> oh, cool!
11:17:22 <lispy> gwern: thanks!
11:17:23 <djahandarie> Cool
11:17:25 <ksf> ...all I want is a punycode implementation
11:17:27 <djahandarie> > "yeay!"
11:17:36 <lambdabot>   "yeay!"
11:17:36 <Cale> Palmik: wrong channel?
11:17:38 <Cale> :)
11:17:50 <djahandarie> @book
11:17:57 <djahandarie> @where book
11:18:00 <lambdabot> Unknown command, try @list
11:18:06 <lambdabot> I know nothing about book.
11:18:09 <Palmik> Cale, nope, I was looking if there was any bot command with some haskell related book recomendations :)
11:18:10 <djahandarie> Damn
11:18:25 <ksf> Palmik, lyah, rwh
11:18:29 <gwern> wish I could profile ghc api users. I thought the gitit slowdown was due to lack of parallelism, but no, it's already parallel
11:18:32 <ksf> scip, of course
11:18:52 <Palmik> ksf, will look at tham, thanks :)
11:18:52 <djahandarie> @where rwh
11:18:59 <ksf> and then there's some haskell books targeting more academically-inclided people (but are still entry-level)
11:19:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:20:07 <Cale> http://www.haskell.org/haskellwiki/Books
11:20:09 <proq> @transpose
11:20:14 <lambdabot> Unknown command, try @list
11:21:36 <djahandarie> > fix (seq 1)
11:21:40 <lambdabot>   mueval-core: Time limit exceeded
11:21:47 <c_wraith> > fix error
11:21:48 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:23:58 * BMeph greatly enjoys the "sick up" (i.e. SICP) videos...
11:24:47 * hackagebot fastcgi 3001.0.2.3 - A Haskell library for writing FastCGI programs  http://hackage.haskell.org/package/fastcgi-3001.0.2.3 (ChrisDone)
11:25:50 <djahandarie> It kinda bugs me that there need to be "strict versions" of things
11:29:10 <aristid> > error (error "x")
11:29:11 <lambdabot>   *Exception: x
11:30:07 <monochrom> Oh God, they've found a way to pronounce SICP too.
11:31:23 <gwern> 'sicky'?
11:31:50 <soupdragon> SISSIP
11:32:13 <Cale> (IF (SICP x) (RELEASE-THE-HOUNDS x) (WAIT))
11:32:31 <Twey> Haha
11:32:33 <Twey> sic-p
11:32:47 <soupdragon> Poll: Who's read SICP?
11:32:58 * Twey raises a hand.
11:33:13 <Cale> I've read a good portion of it
11:33:28 <mauke> so I heard error is idempotent
11:33:44 <soupdragon> I did it all except the last chapters
11:33:50 <soupdragon> the hard ones ;z
11:33:52 <Cale> > error (error (error "x"))
11:33:53 <lambdabot>   *Exception: x
11:34:05 <Cale> So it would seem?
11:34:10 <Cale> That's odd
11:34:13 <Cale> > fix error
11:34:15 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:35:05 <Cale> It's idempotent, but only finitarily so.
11:35:47 <gwern> soupdragon: I've read up to 1.3...
11:35:49 <c_wraith> > let x = error x in x
11:35:51 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:36:04 <mauke> I like how 'die' is idempotent in Perl because that lets me say: die die die $!;
11:36:07 <gwern> soupdragon: I would have read more except it drives me nuts to write iterative versions of recursive functions
11:36:39 <soupdragon> Iv'eg ot a question
11:36:40 <gwern> and do number theoretic problems
11:36:49 <soupdragon> things like physics and biology are sciences
11:36:50 <djahandarie> No
11:36:54 <djahandarie> Only lazily so
11:36:57 <djahandarie> error is undefined
11:36:58 <djahandarie> so
11:36:58 <soupdragon> and things like mathematics are ________s?
11:37:06 <djahandarie> > error $! error "x"
11:37:07 <soupdragon> what are the name for mathematics??
11:37:07 <lambdabot>   *Exception: x
11:37:08 <djahandarie> > error $ error "x"
11:37:09 <lambdabot>   *Exception: *Exception: x
11:37:12 <mauke> soupdragon: arts
11:37:19 <soupdragon> okay so my follow up:
11:37:25 <soupdragon> Programming: Is it science or arts?
11:37:31 <tommd> It's a craft.
11:37:44 <soupdragon> The death of SICP suggests that programming went from art to science.
11:37:50 <soupdragon> at least in MIT
11:38:16 <tommd> What is being discussed?  "Programming" or "Computer Science"?
11:38:20 <soupdragon> is it to be considered a terrible shame or nescssary progress?
11:38:46 <gwern> don't worry. the free market will eventually grind up the craftsmen and turn them into fertilizer
11:46:08 <jiji> hi everyone
11:46:14 <jiji> I have a stupid question
11:46:19 <jiji> why can
11:46:34 <jiji> why cant we have a polymorphic function with this signature?
11:46:44 <jiji> deContain :: m a->a
11:46:48 <jiji> or can we?
11:47:31 <Saizan> with exactly that signature you can't, because you've no idea how to manipulate a value of type "m a" for any m and a
11:47:50 <jiji> okay why don't we?
11:49:11 <djahandarie> jiji, you can certainly define a *specific* function for a specific type that does that.
11:49:39 <jiji> that I know, but why shouldn't we able to define it generically for all types?
11:49:42 <djahandarie> jiji, if you are using "m" for monad though, what "monad" really means is that you aren't allowed to have that sort of function for your type
11:49:59 <Saizan> because e.g. to pattern match against the argument you'll have to know the concrete type of "m" otherwise you don't know which constructors you can use
11:50:04 <zygoloid> jiji: what should "deContain Nothing" produce?
11:50:43 <jiji> @djahandarie interesting, I see what you mean, but I don't know why I didn't construe it from what I read about monads
11:50:43 <lambdabot> Unknown command, try @list
11:50:55 <chrisdone> how often does hackage do the builds?
11:51:17 <jiji> @Saizan I know that it is not feaible to do it in Haskell because you don't have adequate type machinery to do it right now
11:51:18 <lambdabot> Unknown command, try @list
11:51:23 <aristid> jiji: please don't use an @ at the beginning when talking to people, lambdabot (our bot) gets confused by this.
11:51:28 <jiji> what I am asking is whether this is a bad idea
11:51:56 <jiji> oh sorry 
11:51:57 <jiji> ok
11:51:58 <dschoepe> jiji: it isn't feasible because you don't know how to manipulate an "m a" for an arbitrary m
11:52:00 <aristid> jiji: generally, this is the recommended way of talking to people: "Saizan: I know that it is not feasible..."
11:52:39 <tommd> hum, something tells me we'll need to kick a troll soon.
11:52:45 <jiji> it seems to me they can all be manipulated uniformly though
11:52:55 <dschoepe> jiji: a (total) function of this type is not possible for all monads, like the already mentioned `deContain Nothing'
11:53:14 <jiji> right
11:53:29 <jiji> sorry I am not a troll
11:53:34 <jiji> I am just pretty stupid :(
11:53:47 <dschoepe> I think tommd was referring to IRCSTINKS
11:54:04 <Saizan> jiji: ah, ok, then other things apply, one is what zygoloid said, what "deContain Nothing" should do? another even more important is that we like our polymorphism to be parametric, there are a bunch of nice properties about your programs that you get for free thanks to that.
11:54:46 <mauke> jiji: why do you think 'm a' contains an 'a'?
11:55:10 <jiji> the reason I asked that question was that, more often than not, we want to do something with the contained type, so I was wondering whether there is a generic way of 'decontaining it' 
11:55:15 <Saizan> jiji: e.g. map fusion: "map f . map g = map (f . g)" -- this is guaranteed to be safe by the fact that map has to work uniformly regardless of the type of the elements
11:55:15 <jiji> I don't know
11:55:19 <jiji> that's how I understood it
11:55:19 <zygoloid> jiji: a more interesting question would be, can we write a function with this signature: fmap :: (a -> b) -> f a -> f b
11:55:33 <mauke> jiji: type T a = a -> Int
11:55:43 <zygoloid> jiji: we can't in general extract an 'a' from a 'f a' because 'f a' might be something which doesn't actually contain an 'a'.
11:55:52 <mauke> jiji: what would deContain :: T a -> a look like?
11:55:54 <jiji> right
11:56:05 <jiji> no you are right
11:56:08 <jiji> I understand now
11:56:35 <zygoloid> jiji: and haskell's type system requires our polymorphic functions to be parametric; that is, they must operate uniformly over all types
11:57:01 <zygoloid> this parametricity requirement means we can't even write a function which extracts an element in certain special cases
11:57:02 <jiji> so you mentioned something about monads really meaning that I shouldn't be able to do this
11:57:09 <jiji> can you explain more why so?
11:57:13 <benmachine> zygoloid: what about typeclasses
11:57:26 <soupdragon> jiji, you can write m a -> a for a few m, but not all of them
11:57:26 <dschoepe> jiji: some monads don't allow this, but it's not an universal property of a monad
11:57:32 <zygoloid> benmachine: typeclasses pass in additional things we can use uniformly
11:58:09 <jiji> so the class of those types for which I can write such a function, is it any special, or does it have a name?
11:58:34 <zygoloid> I've seen it called Copointed 
11:58:35 <jiji> is it correct to call them containers?
11:58:36 <mauke> I think you can't write m a -> a for any interesting m
11:58:59 <mauke> talking about monads
11:59:12 <zygoloid> jiji: you can write m a -> a for any m which is a Comonad
11:59:42 <benmachine> mauke: anything that is also a comonad?
11:59:48 <benmachine> e.g. infinite streams
12:00:29 <mokrzu> hi, why function "resort = reverse . sort" works only when i write type declaration for it ? 
12:00:59 <dschoepe> mokrzu: because your type signature is wrong.
12:01:20 <BMeph> Is there a name for..."things" that are both monads and comonads?
12:01:26 <jiji> hmmm, I am dumb LOL, it's even meaning less to do it for a List 
12:01:29 <dschoepe> mokrzu: Or more constructively: what is the type signature you tried?
12:01:41 <mauke> mokrzu: probably because of the monomorphism restriction
12:01:47 <soupdragon> jiji, it works for almost all lists
12:01:50 <zygoloid> BMeph: with what laws relating the two?
12:01:59 <soupdragon> jiji, head :: [a] -> a comes in the standard library
12:01:59 <dschoepe> mokrzu: oh, sorry, I misread your question
12:02:23 <jiji> yeah, but that's ad hoc, i.e., returning the first elemen t
12:02:33 <jiji> from the generic type signature there is no way to infer that 
12:02:41 <sclv> hmm -- so it occurs to me that the ability to tell GHC -- "I'm allocating a bunch of memory here in a tight loop, please don't perform gc again until I exit this block" would be very useful.
12:02:52 <zygoloid> jiji: it also doesn't work for empty lists :)
12:02:59 <jiji> right
12:03:06 <sclv> Doesn't seem like the hardest thing to implement.
12:03:32 <jiji> so let me ask about what led me there
12:03:43 <jiji> I am parsing an XML file with XML.Light
12:03:54 <jiji> I am playing with it in GHCi
12:04:02 <zygoloid> sclv: so if you run out of heap, you just allocate a new block?
12:04:11 <soupdragon> jiji, oh you mean because it could pick the first element, or the last one, or..
12:04:24 <jiji> I cascade it with readFile 
12:04:49 <zygoloid> jiji: incidentally, you can make something very close to m a -> a using SYB. i think you need Data (m a) and Typeable a.
12:04:50 <jiji> so like: do parseXML (readFile "my.xml")
12:04:51 <sclv> essentially, temporarily set the max heap size that triggers a gc to something very very big
12:05:21 <jiji> I get IO String from readFile 
12:05:25 <jiji> which is fine inside a do block 
12:05:33 <jiji> but how can I convert it to just String?
12:05:41 <BMeph> zygoloid: Say something is a functor, an endofunctor, specifically. Is there a name for one which is a monad and a comonad using the same categories?
12:05:45 <mauke> IO a is one of those things that doesn't contain an a
12:05:50 <mauke> there is no way to "convert" it
12:06:00 <jiji> you are right, I understand now why
12:06:10 <zygoloid> jiji: if you want to transform it into an IO a, and you have a function of type String -> a, you can do that.
12:06:21 <mauke> jiji: btw, do you know javascript and XmlHttpRequest?
12:06:30 <jiji> no
12:07:17 <jiji> anyways, thanks everyone for your help
12:07:30 <zygoloid> BMeph: with no additional relations between join, cojoin, unit and counit? not that i know of.
12:07:45 <jiji> the earthquake here probably had to do with my inability to think straight, sorry if my questions were awkward
12:07:47 <zygoloid> BMeph: ask edwardk when he turns up :)
12:08:00 <zygoloid> jiji: canada?
12:08:06 <jiji> yeah
12:08:08 <jiji> toronto
12:08:11 <jiji> it was pretty scary 
12:08:21 <mauke> decontain = unsafeCoerce :: m a -> a
12:08:46 <BMeph> Although not necessarily having the respective correspondent natural transformations be inverses. Hmm, I'll think on it some more, to see if they have any laws relating each other.
12:09:06 <zygoloid> mauke: unsafeCoerce :: m a -> Maybe a actually works for [] and Maybe :)
12:09:49 <mauke> I knew it! Maybe is just a list with at most 1 element
12:13:11 <BMeph> mauke: ...and Peano numbers are just lists of units. Well, with the boilerplate "up to iso" qual.... :)
12:16:10 <Cale> That was quite an impressive earthquake
12:16:39 <gwern> was toronto hurt?
12:16:42 <gwern> or wherever it was
12:17:06 <Cale> Here it didn't shake very hard (Brantford, ON), but the whole house wobbled enough to make me feel uneasy for maybe 30 or 45 seconds.
12:17:18 <Cale> Nothing broken.
12:17:41 <Cale> The epicentre was in Quebec
12:20:04 <Cale> Actually, one of the guys from my dad's old band lives just about where the epicentre was, outside of Gatineau, so we should call him and see how he's doing. :)
12:20:39 <soupdragon> I am scared of earthquakes!
12:22:22 <djahandarie> Let's rename return to unit and not tell anyone
12:22:23 <Cale> I've seen a video where someone's mirror was broken, but I don't think there's any severe damage.
12:22:52 <Cale> I'm happy with the name return.
12:23:21 <micahjohnston> the name return is good
12:23:21 <djahandarie> I'm pretty sure it's one of the things that make monads just terribly terribly confusing
12:23:28 <Cale> nah
12:23:38 <monochrom> every name is fine with me.
12:23:43 <Cale> return v does nothing except to return v
12:23:51 <Cale> It's a fine name :)
12:23:53 <monochrom> no, I lied. every non-enterprise-ready name is fine with me.
12:24:03 <djahandarie> That was the worst definition of anything I've ever heard Cale. :P
12:24:14 <Cale> djahandarie: It's not a definition.
12:24:24 <Cale> To know more about what it does, you have to pick a monad.
12:24:30 <djahandarie> putThisValueIntoAComputationalContext monochrom?
12:24:54 <djahandarie> Cale, then what was it?
12:25:02 <Cale> It's a vague characterisation.
12:25:04 <monochrom> you know some java people actually love that one.
12:25:21 <Cale> The only definition of return is its type signature and the laws which it satisfies.
12:25:41 <djahandarie> Which could certainly be translated into English
12:25:45 <micahjohnston> return makes a monad that returns something
12:25:56 <Cale> micahjohnston: return does not make a monad at all
12:25:57 <monochrom> you have too much faith in natural languages
12:26:04 <micahjohnston> an action
12:26:06 <soupdragon> natural languages are scary!!
12:26:13 <djahandarie> Oh nice, now using the word "return" with two different meanings in the same sentence, that'll help
12:26:30 <monochrom> Yeah, and china came from China.
12:26:31 <Cale> micahjohnston: IO, STM, Maybe, State s, are monads
12:26:51 <monochrom> And Buffalo buffalo buffalo ...
12:27:05 <monochrom> You see the problem with "meaningful" names.
12:27:27 <Cale> djahandarie: But it's nice when the meaning of a piece of code is its disquotation :)
12:27:42 <monochrom> Every "meaningful" name comes with several conflicting meanings. There is no meaningful name.
12:28:10 <micahjohnston> in existing natural languages
12:28:14 <monochrom> There are only cultural references.
12:28:26 <djahandarie> monochrom, I think unit would be "less" conflicting and as a result more meaningful?
12:28:40 <Cale> djahandarie: But think about what return v does in, say, the IO monad
12:28:56 <Cale> It is an action which when you run it, produces the result v
12:29:03 <Cale> That is to say, it returns v
12:29:23 <djahandarie> Cale, then unit = return for the IO instance
12:29:34 <Cale> In a parsing monad, it is a parser which accepts without eating any input, and returns the result v
12:29:35 <djahandarie> The monad concept should not be dependant on the IO monad
12:29:59 <Cale> There are many examples
12:30:27 <Cale> and in every one, you can see the interpretation of return v as an action which "does nothing" (whatever that means), and returns v as its result
12:30:49 <Cale> which means that in a do block,  do u <- return v; f u  is equivalent to f v
12:30:55 <Cale> which is one of the monad laws :)
12:31:00 <monochrom> "unit" gets the idea across in mathematics circles but not in physics circles.
12:31:04 * ksf wants sdist-depends
12:31:22 <djahandarie> monochrom, the most important circle is the programming circle and return just screws itself over there
12:31:29 <Cale> unit doesn't make sense as a name if we're going to use >>= as our other primitive
12:31:39 <djahandarie> Why?
12:31:42 <micahjohnston> actionThatDoesNothingAndReturns
12:31:53 <mauke> let's call it cons
12:31:54 <Cale> unit :: a -> m a and multiply :: m (m a) -> m a
12:32:05 <Cale> if you're going that route :)
12:32:09 <ksf> let's call it point.
12:32:19 <djahandarie> That'd honestly make so much more sense to write it like that
12:32:27 <ksf> and have a typeclass that provides copoint.
12:32:31 <Cale> Or, be moar Greek:  Œ∑ :: a -> m a, and  Œº :: m (m a) -> m a
12:32:52 <ksf> though that usually has all kinds of strange types.
12:33:09 <Cale> But 'return' is the name which makes sense in programs
12:33:15 <ksf> no it doesn't.
12:33:28 <mauke> return is a virtual constructor, that's why 'cons'
12:33:28 <monochrom> The programming circle is divided.
12:33:40 <ksf> it makes sense to people who agree that pascal is "the best language for beginning programmers"
12:33:47 <Cale> ksf: huh?
12:33:49 <Twey> Heheh.
12:33:54 <Cale> When did I ever say that?
12:34:03 <ksf> ...it's just the same sentiment.
12:34:09 <mauke> ksf: strongly disagree
12:34:12 <ksf> oh let's call it something people are accoustomed to.
12:34:14 <Cale> I'm completely disregarding the existence of other programming languages for the sake of this argument
12:34:24 <djahandarie> Cale, I'm not.
12:34:32 <Cale> djahandarie: You should be :)
12:34:39 <ksf> ...trying to carry over their intuitions and badly failing, because return doesn't exit a do statement.
12:34:44 <micahjohnston> the problem is that people try to  make synax of programming languages resemble english's syntax
12:34:54 <ksf> it's just ever so slightly different to be the completely wrong thing to do
12:35:02 <Twey> micahjohnston: No they don't.
12:35:11 <mauke> ksf: sure, but it still makes sense if you don't know other languages
12:35:16 <Twey> Natlang syntax is rubbish for programming.  Remember COBOL?
12:35:19 <Cale> People shouldn't expect one programming language to work so much like another.
12:35:25 <ksf> the question is: return to where?
12:35:39 <djahandarie> Cale, there are existing conventions and it's best to not break them.
12:35:55 <djahandarie> That doesn't need to mean you are bound by the conventions
12:35:57 <Cale> I think this sentiment comes from the fact that many people learn 8 different "skins" for the same programming language, and then expect Haskell to be just like the others :)
12:36:02 <ksf> using "return" is begging to be misunderstood.
12:36:09 <Philonous> Cale Why not? When two concepts are alike, it is confusing to have the terminology differ wildly
12:36:28 <ksf> and imperative return and haskell return _aren't_ the same thing.
12:36:36 <aristid> Philonous: but sometimes, things are NOT alike, and then the terminology may differ
12:36:36 <Twey> The name ‚Äòreturn‚Äô is *intended* to be interpreted as an imperative return, surely.
12:36:43 <ksf> haskell's throw'd be more like it.
12:36:43 <aristid> ksf: it should be 'pure' :)
12:36:47 <Cale> They're not the same thing, but they are also not unrelated.
12:36:48 <ksf> yep.
12:36:48 <Twey> It should.
12:36:59 <djahandarie> Yes pure would be fine as well
12:37:06 <Twey> Cale: How are they related?
12:37:16 <Cale> I'll say it again: return v is always an action which does nothing but to return v when run.
12:37:30 <Cale> It doesn't have the call/cc magic that it does in C.
12:37:32 <ksf> in imperative-land, return does something. always.
12:37:33 <Twey> One exits an imperative procedure, and the other wraps a value in a constructor.
12:37:51 <Cale> The important thing which is different here is that return v is an action on its own
12:38:03 <Cale> Whereas in C, return v is not a value.
12:38:19 <Cale> (it's a statement)
12:38:34 <mauke> in Perl, return is idempotent!
12:38:35 <ksf> I still haven't heard an argument that justifies the misunderstandings that arise.
12:38:36 <djahandarie> Cale, I think you are comparing the technical details rather than the overarching concept?
12:38:36 <mauke> (yay)
12:38:46 <Cale> djahandarie: ?
12:39:00 <mauke> ksf: all you're saying is that people shouldn't learn imperative languages
12:39:07 <djahandarie> Cale,  < Twey> One exits an imperative procedure, and the other wraps a value in a constructor.
12:39:11 <ksf> no I'm not.
12:39:31 <Cale> I'm not sure I agree with either of those characterisations :)
12:39:44 <Cale> Well, the imperative one isn't terrible.
12:40:05 <ksf> I'm saying that we shouldn't try to play to people's intuition when that would mislead them.
12:40:16 <monochrom> Once you enter FP, there is no return.
12:40:47 <Cale> We shouldn't change how we name things just because imperative programmers expect every function definition to be secretly wrapped in call/cc
12:40:56 <ksf> return v is a statement in haskell, too, in the sense that it's Monad m => m a
12:41:03 <Cale> (and for return to call the continuation with a given value)
12:41:31 <ksf> Cale, for all I know the commitee decided on "return" because it looked so jolly similar to C
12:41:38 <Cale> I don't think they did
12:41:57 <ksf> ...I don't know of any other story.
12:42:07 <Cale> I think they decided on that because in any monad which we interpret as a type of computation, it produces the computation which does nothing except to return the given value.
12:42:23 <ksf> that is, yield.
12:42:41 <Cale> return, yield, give, etc, etc.
12:42:50 <ksf> which is action-speak, not denotation-speak
12:43:09 <mauke> it can be both
12:43:11 <Cale> and for that reason, I think it's a perfectly appropriate name
12:43:28 <aristid> is "transformers" much better than "mtl"?
12:43:40 <ksf> aristid, if you don't know, you don't care.
12:43:41 <Cale> Because in the context of Haskell, we are in the business of writing programs.
12:44:01 <aristid> ksf: i stumbled upon MaybeT and MaybeT-transformers
12:44:04 <ksf> but we aren't in the business of returning from functions
12:44:07 <Cale> and essentially every monad we care about has a computational way of looking at it
12:44:15 <monochrom> If I were on the committee: "just" for monad unit. "data Maybe a = Nil | Has a".
12:44:29 <Cale> ?
12:44:32 <ksf> "return v" in the middle of a do-block is highly unintuitive, even if you haven't ever seen an imperative language, before.
12:44:33 <aristid> Cale: pure has the advantage that it coincides with the Applicative name
12:44:44 <Cale> ksf: I thorougly disagree.
12:44:52 <Twey> Cale: If the original, mathematical name for ‚Äòpure‚Äô were ‚Äòreturn‚Äô, I'd agree with you ‚Äî we shouldn't change our terminology because it confuses imperative programmers
12:44:55 <sclv> aristid: if you don't know, stick with mtl :-)
12:44:58 <mauke> ksf: I don't believe that
12:45:09 <Cale> return v in the middle of a do block will do nothing, returning v, but we're not capturing the result, so it's pointless
12:45:11 <aristid> sclv: even if i'm writing my own transformers? :)
12:45:21 <ksf> do that, that, return, that, that
12:45:43 <Cale> Twey: The original mathematical name for return/pure/etc is Œ∑
12:45:44 <Twey> Cale: But AFAIK, ‚Äòreturn‚Äô was given its name precisely to appeal to the imperative intuitions of C-like programmers
12:45:52 <sclv> aristid: depends -- for your own use, or for hackage?
12:45:57 <mauke> ksf: not "return", "return v"
12:46:01 <ksf> ...my mind, at least, searches for something to return from when encountering the meaning of the word "return", and the next thing it finds is the binding scope.
12:46:10 <Cale> Twey: Again, I can't really agree with that
12:46:11 <djahandarie> I think we SHOULD change our terminology because it confuses imperative programmers IF there is an almost-equally good alternative.
12:46:13 <ksf> mauke, typo
12:46:17 <Twey> Since the operation is sufficiently different to break that intuition in many cases, the attempt is a failure and should be dropped
12:46:20 <Twey> Oh?
12:46:22 <Cale> It's not to appeal to the intuitions of imperative programmers.
12:46:23 <aristid> sclv: well so far it's only an intellectual and programming exercise
12:46:48 <Cale> It's to appeal to the intuitions of functional programmers who are writing values that describe computations in an imperative fashion. :)
12:46:49 <mauke> ksf: "return v" could just mean "return v when you're done, no pressure though"
12:46:49 <aristid> i haven't really needed a generalised MonadPlusTransformer so far. but it's written!
12:47:18 <ksf> but it doesn't. in the middle of a do block, it's a perfect noop.
12:47:20 <Cale> return v is the value denoting the computation which returns v
12:47:44 <ksf> in a bind-context, but not in the context in which it is written.
12:47:47 <Cale> ksf: In the middle of a do-block, if you discard the result, of course return v does nothing.
12:48:01 <sclv> its simpler to stick with mtl, I think. you care about transformers if you care about inter-library compat for larger projects -- eventually there'll be some unification process and it'll all sort itself out.
12:48:01 <aristid> sclv: so maybe i'll put it on hackage if that's easy enough
12:48:05 <Cale> ksf: I contend that this is obvious even to beginners
12:48:23 <Cale> (So long as they don't drag expectations in from other languages)
12:48:23 <ksf> anyway, Cale, can you point me to a single mathematical paper pre-haskell that uses return?
12:48:29 <Cale> ksf: no
12:48:33 <ksf> QED
12:48:47 <Cale> Would you want return to be called Œ∑ instead?
12:48:54 <ksf> I've explained exactly that numerous times here on the channel
12:48:58 <Cale> hah
12:49:04 <ksf> because people _do_ get confused.
12:49:07 <monochrom> So have Cales.
12:49:13 <ksf> unit, pure
12:49:15 <ksf> choose one.
12:49:30 <ksf> oh, point.
12:49:31 <sclv> class Pointed where...
12:49:43 <ksf> point :: a -> f a
12:49:45 <aristid> class Pointed f where pure :: a -> f a
12:49:59 <Cale> If you drag expectations in from imperative languages regarding what return does, and ignore what every document on Haskell itself tells you about what the return function gives you, then yes, you'll be confused.
12:50:10 <Cale> But if you do that, return is the least of your worries.
12:50:18 <Cale> return's name is perfectly appropriate
12:50:19 <aristid> Cale: why isn't haskell like the iPhone?!
12:50:32 <monochrom> what is "like the iPhone"?
12:50:36 <Cale> It's just appropriate in a different way from the way in which it's appropriate in imperative languages.
12:50:42 <sclv> class Pointed f where takeAValueAndReturnAPointedValue :: a -> f a
12:50:44 <aristid> monochrom: with the iPhone, you need no manual.
12:50:52 <aristid> in fact, there is no manual
12:51:21 <monochrom> if you have no manual you can't program iPhone
12:51:23 <ksf> yes. in the same sense that "dick" doesn't mean in german what it seems to mean to giggling american teenage girls...
12:51:25 <sclv> class Pointed f where returnNoNotLikeImperativeReturnTheOtherOne :: a -> f a
12:51:28 <djahandarie> Cale, I don't see why we need to battle against human nature for something that only gives us an inkling more of logical purity than other solutions.
12:51:32 <aristid> monochrom: it was merely a joke :P
12:51:38 <monochrom> Yeah!
12:51:41 <Cale> djahandarie: ?
12:51:49 <Cale> djahandarie: Imperative languages are not human nature
12:51:59 <djahandarie> Cale, that isn't what I'm refering to.
12:52:12 <djahandarie> It's the nature to skim over something you may already know
12:52:24 <djahandarie> And the word "return" is something programmers already know
12:52:33 <mauke> not all of them
12:52:35 <Cale> Well, they should be more careful ;)
12:52:36 <sclv> class Functor f where liftSomeFunctionAnyFunctionThisIsParametricSuchThatItOperatesOnTheFunctor ...
12:52:49 <ksf> and if they have to write "point v" at the end of their functions, they might begin to think.
12:52:59 <djahandarie> Cale, you can say that but that doesn't change the fact we are starting a fight in the mind when we don't need to
12:53:03 <monochrom> Programming is against human nature fundamentally.
12:53:13 <tommd> Human nature is to be against things.
12:53:18 <soupdragon> monochrom, really? I thought the opposite
12:53:24 <mauke> they might begin to think you're doing something graphics related
12:53:27 <ksf> human nature is about metaprogramming.
12:53:30 <djahandarie> monochrom, if that's so, maybe it is a neccessary even. Naming this "return" definitely is not.
12:53:35 <djahandarie> evil*
12:53:39 <Cale> There are a dozen or so keywords, and many more function names in Haskell which occur in other languages. We can't expect people to treat them in the same way.
12:54:21 <monochrom> I don't know, maybe you should revoke the "=" symbol first.
12:54:22 <djahandarie> Cale, sure, but you need to understand how a monad works in Haskell to do almost anything useful (or at least to understand what you are doing when you are doing something useful)
12:54:23 <ksf> Cale, but those aren't also used in similar contexts and/or look very, very similar.
12:54:33 <mauke> djahandarie: I disagree
12:54:36 <Cale> We should disregard all the other programming languages when we choose names, and pick the name which is most appropriate internally.
12:54:45 <Philonous> djahandarie: Especially as we have do notation which more often than not is pointed to to reassure people that haskell is not so different after all. And to my knowledge both do notation and return where chosen to appel to C programmers (at least that's what I remember SPJ saying) 
12:54:53 <Cale> djahandarie: I totally disagree with you on that.
12:55:02 <ksf> you can't write a haskell class decl just because you can write a java class decl. but that applies to return, and return doesn't map well.
12:55:05 <Cale> You don't need to know anything about monads to write Haskell code.
12:55:14 <monochrom> Maybe I should troll/sarcasmize with "=" first. "x = 5" in haskell oh-so-different from people's expectations...
12:55:17 <djahandarie> I did have the "useful" qualifier.
12:55:20 <Cale> You don't even need to know anything about monads to do IO.
12:55:33 <djahandarie> Cale, I also said "to understand what you are doing when you are doing something useful"
12:55:45 <mauke> djahandarie: you can write a compiler in haskell without understanding monads
12:55:45 <Cale> Well, maybe.
12:55:56 <mauke> and you can understand how that compiler works
12:56:01 <ksf> Cale, I've seen you arguing that "return" is an acceptable name, but why is it better than any of [pure,point,unit]?
12:56:01 <aristid> Cale: but you need to know that "do" syntax is similar but not quite the same as "normal" imperative syntax: return does something else.
12:56:08 <Cale> djahandarie: If you use the stuff from Control.Monad, you might want to understand it in greater generality, sure.
12:56:19 <Cale> But that's unnecessary for getting work done in the IO monad.
12:56:38 <Cale> Yes, you need to understand that you're putting IO actions together from simpler IO actions
12:56:42 <Cale> and that IO actions are values
12:56:55 <aristid> Cale: do syntax can hide that pretty well
12:56:57 <Cale> But that has nothing at all to do with monads
12:56:58 <djahandarie> Even so, I don't see why we need to build a wall to understanding the "greater generality" just for a bit more logical purity in the language.
12:57:00 <ksf> and that you chain them using bind...
12:57:03 <Cale> that's ordinary functional programming
12:57:06 <ksf> wait we just explained monads.
12:57:17 <Cale> do-notation is a syntax for gluing simpler IO actions together into more complex ones
12:57:33 <aristid> Cale: of course.
12:57:39 <mauke> djahandarie: we're not building anything, Haskell already exists
12:58:02 <djahandarie> mauke, I don't see why there needs to be a wall*
12:58:07 <ksf> there actually seem to be _less_ people arriving here being confused about having to write "else" than the return misconception.
12:58:14 <Cale> djahandarie: The only wall is in your own mind? :)
12:58:41 <mauke> are people confused by 'const'?
12:58:41 <soupdragon> This guy said you could use the human genome to test virus
12:58:43 <Cale> I think there's also possibly a wall in the older reference materials.
12:58:44 * ksf decides that The Way To Go is to call it pure and have return = pure in Control.Monad
12:58:45 <soupdragon> is that true? ??
12:59:00 <Cale> It's really important to stress the value-nature of IO actions when teaching beginners.
12:59:04 <soupdragon> I thought protien folding was so hard they couldn't really do anything with the genome
12:59:19 <Cale> If you don't do that, then it's really confusing and awful.
12:59:39 <Cale> (Particularly for the imperative-infected)
13:00:04 * ksf constantly uses pure in some pointless pieces of code and then curses because there's only a monad instance for that thing.
13:00:27 <ksf> pure is also nice because it applies to lists.
13:00:35 <ksf> ...and maybe.
13:00:38 <Cale> ?
13:00:44 <ksf> and isn't bleeding limited to monads.
13:00:46 <Cale> So does return
13:01:07 <Philonous> Maybe you mean ZipLists ?
13:01:14 <ksf> hmm. I never noticed.
13:01:42 <Cale> The list monad is basically my favourite monad :)
13:01:52 <ksf> anyway, the cognitive difference between f x = pure x, f x = x is greater (imnsho) than f x = return x, f x = x
13:02:01 <ksf> the latter look more alike.
13:02:07 <Cale> > filterM (const [True, False]) [1,2,3]
13:02:09 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:02:20 <aristid> @src filterM
13:02:20 <lambdabot> Source not found. You speak an infinite deal of nothing
13:02:26 <Cale> ksf: I don't see how they're any different
13:02:26 <aristid> :t filterM
13:02:27 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:02:46 <ksf> because f x = x is the function f x which returns x...
13:03:07 <Cale> f x isn't a function here (at least not necessarily)
13:03:09 <Cale> f is :)
13:03:17 <ksf> binding, then.
13:03:27 <monochrom> http://www.haskell.org/haskellwiki/Monad_as_wanker
13:03:39 <Cale> I would say something like "The result of applying f to x is x"
13:04:02 <djahandarie> Cale, that's not what a newbie would say though, which is of great importance
13:04:11 <ksf> yeah but non-mathematicans don't, and only a minority of programmers are mathematicans.
13:04:12 <Cale> djahandarie: Isn't it?
13:04:14 <Cale> hmm
13:04:22 <Cale> Or just "f of x is x
13:04:23 <Cale> "
13:04:32 <djahandarie> I would use "evaluates to"
13:04:32 <Cale> Like in highschool.
13:04:48 <monochrom> "f x = return x" looks like "f x = x" because again of other-languages prejudice.
13:05:02 <Cale> Yeah, I think that's the only reason.
13:05:20 <djahandarie> Who cares what the reason is
13:05:29 <mauke> djahandarie: me
13:05:30 <monochrom> The whole debate is on how much alien prejudice you want to avoid debunking.
13:05:48 <ksf> ... return :: a -> [a] 
13:05:56 <ksf> how do you return something from a list?
13:05:56 <djahandarie> mauke, that was a hypothetical. The reason shouldn't matter.
13:06:08 <mauke> djahandarie: but it does, because it's not universal
13:06:16 <ksf> why is a list an action?
13:06:21 <Cale> ksf: return x is the nondeterministic computation which deterministically returns x
13:06:29 <ksf> I don't think that builds the right monad intuitions.
13:06:36 <Cale> I think it is
13:06:37 <djahandarie> mauke, it's a large percentage.
13:06:38 <mauke> ksf: a list is multiple universes
13:06:45 <ksf> a list is a data type.
13:06:49 <ksf> my prof told me so.
13:06:54 <Cale> ksf: A list is a list of possibilities
13:07:00 <mauke> djahandarie: most imperative programmers don't know Haskell though, so it's a small percentage
13:07:12 <Cale> ksf: To 'run' a list means to pick a value from it (in all possible ways)
13:07:19 <ksf> and why can't I return two possibilities with return x y ?
13:07:20 <djahandarie> mauke, I'm speaking in terms of "people who will be learning Haskell in the near future"
13:07:29 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
13:07:30 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:07:37 <Cale> ^^
13:07:51 <mauke> ksf: because two possibilities is not pure
13:07:51 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- return 6; return (x,y,z)
13:07:53 <lambdabot>   [(1,4,6),(1,5,6),(2,4,6),(2,5,6),(3,4,6),(3,5,6)]
13:07:53 <ksf> it's a metaphor that breaks way too easily.
13:08:10 <ksf> mauke, so why aren't you calling return pure ? =)
13:08:16 <mauke> :-)
13:08:23 <Cale> > do x <- return 1 `mplus` return 2; y <- return 3 `mplus` return 4; return (x,y)
13:08:24 <lambdabot>   No instance for (GHC.Show.Show (m (t, t1)))
13:08:24 <lambdabot>    arising from a use of `M8217...
13:08:30 <Cale> > do x <- return 1 `mplus` return 2; y <- return 3 `mplus` return 4; return (x,y) :: [Integer]
13:08:32 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
13:08:32 <lambdabot>         agains...
13:08:36 <Cale> > do x <- return 1 `mplus` return 2; y <- return 3 `mplus` return 4; return (x,y) :: [(Integer,Integer)]
13:08:38 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
13:08:41 <Cale> there :)
13:09:00 <ksf> gosh that's more verbose than java
13:09:00 <Cale> You're looking for mplus, anyway :)
13:09:08 <ksf> and more repetition than brainfuck
13:09:38 <Cale> :t do x <- msum . map return $ [1,2,3]; y <- msum . map return [4,5]; return (x,y)
13:09:40 <lambdabot> forall a (m :: * -> *) a1. (Num a, MonadPlus m, Num (m a1)) => [(a, m a1)]
13:09:42 <Cale> oops
13:09:44 <Cale> :t do x <- msum . map return $ [1,2,3]; y <- msum . map return $ [4,5]; return (x,y)
13:09:45 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m, Num a, Num a1) => m (a, a1)
13:10:07 <Cale> msum . map return is something I usually define as "option"
13:10:21 <aristid> :t msum . map return
13:10:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
13:10:22 <djahandarie> Wouldn't it make more sense as fmap?
13:10:27 <Cale> what?
13:10:41 <djahandarie> msum . fmap return
13:10:41 <Cale> Oh, well, you could use fmap
13:10:46 <aristid> Cale: how about this: option = Data.Foldable.foldr (mplus . return) mempty
13:10:49 <Cale> But it's still only the list functor
13:11:00 <Cale> aristid: You could do that
13:11:06 <djahandarie> Wouldn't it work for any MonadPlus?
13:11:07 <Cale> I think Foldable is ugly though
13:11:15 <aristid> Cale: why?
13:11:24 <Cale> Too many methods for one class.
13:11:45 <aristid> i ignore the non-foldr methods
13:11:53 <aristid> foldMap and fold are just confusing
13:12:09 <Cale> They're not confusing...
13:12:18 <aristid> Cale: why are they there?
13:12:21 <ksf> option p x = p <|> pure x
13:12:28 <ksf> name's already taken.
13:12:34 <aristid> :t Data.Foldable.foldMap
13:12:35 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
13:12:38 <Cale> aristid: Because the point of Foldable is to work with structures which are not lists.
13:12:45 <ksf> ...that thing should really, really be in Control.Applicative
13:12:53 <aristid> Cale: Data.Foldable.foldr works just as well with these
13:12:54 <Cale> aristid: and which might have a different natural way of associating the data
13:12:57 <Cale> (think trees)
13:13:19 <Cale> But at the same time, Foldable wants to pretend that everything is a list
13:13:23 <Cale> which is ugly
13:13:34 <Cale> Either define toList
13:13:38 <aristid> Cale: so you'd split it up?
13:13:48 <Cale> Or do the monoidal composition business
13:13:53 <Cale> Yeah.
13:14:06 <Cale> In fact, toList is enough
13:14:18 <Cale> Why isn't it:  class Foldable t where toList :: t a -> [a]
13:14:30 <aristid> Cale: why do you prefer toList over foldr?
13:14:30 * ksf wonders how to distinguish between <|> and </>, that is, commutative and non-commutative choice
13:14:52 <aristid> ksf: / is not symmetric
13:14:59 <ksf> yes, and that's good.
13:15:09 <aristid> that's how you can distinguish
13:15:11 <Cale> aristid: Because while foldr is rather general, why not just turn the thing into a list so that all the functions which work on lists will work?
13:15:20 <ksf> otherwise virtually all rfc-grammars would be ambiguous.
13:15:27 <ksf> ...I meant on a typeclass level.
13:15:27 <djahandarie> Cale, toList sort of indicates some sort of order
13:15:35 <Cale> djahandarie: So does foldr
13:15:37 <aristid> djahandarie: foldr does as well
13:15:38 <monochrom> </> is nice symbol desing
13:15:46 <aristid> Cale: foldr might be more efficient for some algorithms
13:15:46 <monochrom> s/desing/design/
13:16:00 <Cale> aristid: Actually, it can be made exactly as efficient
13:16:09 <Cale> aristid: Just define toList in terms of build
13:16:14 <Cale> and you'll get list fusion
13:16:48 <aristid> Cale: so msum . toList will be just as efficient as F.foldr (mplus . return) mempty?
13:16:48 * ksf is really proud of himself, he understood enough of abstract algebra to know what non-commutative indempotent semiring means.
13:16:55 <Cale> yes
13:16:55 <soupdragon> http://lambda-the-ultimate.org/classic/message8514.html
13:16:57 <soupdragon> XD
13:17:03 <Cale> because msum is a foldr
13:17:20 <Cale> and the foldr/build rule will apply and collapse out the intermediate list construction
13:17:40 <aristid> Cale: i didn't know that ghc can optimise this away
13:18:07 <Cale> aristid: Well, for now it's pretty limited
13:19:06 <ksf> wikipedia claims kleene is pronounced /Ààkle…™ni/
13:19:12 <ksf> does anyone actually do that?
13:20:20 <mauke> no, wikipedia says that's how he pronounced it
13:20:22 <BMeph> We should change the way lists and arrays work. When people see [2], they want to know which array is being accessed. It's confusing! ;√æ
13:20:44 <Cale> ksf: I do...
13:20:46 * BMeph not-so-surreptitiously hive-fives Cale
13:20:57 * Cale covers BMeph in bees
13:21:36 * BMeph gently puts the bees in hives -- and the circle is complete!
13:22:35 <aristid> i declare that Objective-C ist just like MaybeT IO.
13:22:46 <soupdragon> prove it by implementing it
13:23:22 <geheimdienst> as socrates said, code speaks louder than words
13:23:29 <geheimdienst> (scnr)
13:24:20 <fxr> yeah that's why we have got lot's of trash 
13:24:44 <chrisdone> BMeph: you're covered in beeees!
13:25:01 <chrisdone> BMeph: http://www.youtube.com/watch?v=Xs-tl6GBOBo
13:25:58 <soupdragon> I like my coffee like I like my bees
13:26:26 <chrisdone> :D
13:26:43 <aristid> soupdragon: ok. (let putStrLn' s = liftIO (putStrLn s) in runMonadPlusT (mzero >>= return . (+1) >>= putStrLn' . show)) :: IO (Maybe ())
13:26:46 <ksf> hmmm it should be class Applicative f => Failure f where fail ...
13:26:51 <aristid> now if that isn't conclusive proof.
13:26:58 <ksf> (provinding a string and no-string variant)
13:26:59 <aristid> oh i should also show the output
13:27:05 <BMeph> geheimdienst: Last I heard, Socrates said: "I drank WHAT?!?" ;)
13:27:08 <aristid> > (let putStrLn' s = liftIO (putStrLn s) in runMonadPlusT (mzero >>= return . (+1) >>= putStrLn' . show)) :: IO (Maybe ())
13:27:09 <aristid> Nothing
13:27:09 <lambdabot>   Not in scope: `runMonadPlusT'
13:27:28 <aristid> MonadPlusT Maybe is like MaybeT
13:27:30 <ksf> which would be the base class of </>, <|> and also for pattern failures in do-syntax
13:27:44 <aristid> hmm
13:27:50 <aristid> there's no mzero for MaybeT
13:27:53 <soupdragon> oh I get what you mean now
13:28:08 <ksf> I don't like "empty" in Alternative
13:28:13 <chrisdone> ksf: why
13:28:34 <aristid> soupdragon: yeah, in objective-c, objects can be nil, and any method on these does nothing
13:28:35 <ksf> sounds like [] or Map.empty, not an alternative.
13:28:48 <ksf> I know it's meant to mean "match the empty sting", but...
13:29:06 <aristid> ksf: how about: epsilon
13:29:12 <ksf> in fact, the internal constructor in my parser that corresponds to empty is called Fail
13:29:18 * BMeph thought that both [] and Map.empty were the Alternative definitions of "empty" for those types...
13:29:40 <aristid> ksf: epsilon is hugely popular in parsing literature, and everywhere else, too
13:30:04 <aristid> BMeph: is Map an Alternative?
13:30:15 <ksf> and then a physicist comes along and wonders why people are talking about flux compensation coefficients.
13:30:35 <ksf> it could be
13:30:55 <ksf> ...but union isn't sane for maps, anyway, that'd always be </>
13:31:05 <ksf> and there's no typeclass for unionWith
13:31:06 <beroal> hello. Is there a definition of MaybeT in some library in Hackage?
13:31:16 <monochrom> eta for monad, epsilon for alternative.
13:31:17 <kmc> yes, the package is named MaybeT
13:32:01 <kmc> if you call it epsilon, people will complain "why can't those egghead mathematician Haskellers use ordinary common-sense names"
13:32:14 <monochrom> like empty
13:32:23 <aristid> kmc: is </> like (:) for you?
13:32:23 <kmc> and if you call it empty, people will complain "why do those Haskellers confuse our intuition by using ordinary common-sense names"
13:32:34 <ksf> so we rename fail to empty?
13:32:40 <soupdragon> um delete fail
13:32:44 <monochrom> I recommend null
13:32:50 <aristid> fail _ = mzero
13:32:59 <soupdragon> "why can't those egghead mathematician Haskellers use ordinary common-sense names" -- this is whawt you WANT to hear
13:33:05 <kmc> why?
13:33:15 <soupdragon> because it means you aren't pandering to simpletons
13:33:37 <ksf> aristid, nope
13:33:47 <ksf> </> has the same type as <|>
13:33:48 <geheimdienst> yes yes, is much better to bury simple things under piles of difficult words, just for the bragging rights
13:33:56 <ksf> it's just not commutative.
13:34:00 <kmc> if you're not pandering to simpletons, then you're playing into stereotypes
13:34:03 <soupdragon> like geheimdienst
13:34:05 <aristid> ksf: but Map union is commutative?
13:34:05 <ksf> :t (:)
13:34:06 <lambdabot> forall a. a -> [a] -> [a]
13:34:08 <monochrom> something about "if both the left wing and the right wing hate you, you know you're correct"
13:34:13 <kmc> haha
13:34:24 <ksf> aristid, when there's duplicate keys?
13:34:25 <kmc> vote Ron Paul
13:34:34 <aristid> ksf: hmm... true
13:34:42 <ksf> that's the reason for unionWith
13:35:13 <aristid> ksf: but looking at it, <|> is almost never commutative...
13:35:17 <aristid> it isn't for list
13:35:23 <aristid> nor for Maybe
13:35:29 <aristid> nor for Map
13:35:43 <ksf> maybe it's time to become explicit about such things
13:35:46 <ksf> it is for Set
13:36:09 <ksf> basically you're fucked as soon as you carry keys _and_ values 
13:36:15 <aristid> ksf: Set isn't applicative afaik
13:36:19 <ksf> and it's for lists seen as sets.
13:37:26 <ksf> maybe we should feed all of hackage into a genetic algorithm evolving to same semantics while reducing code duplication and have a look at what typeclasses it comes up with
13:38:08 <aristid> and use the autogenerated names from then on.
13:38:26 <monochrom> it will evolve the idea of having committees. then it will just go for design by committee.
13:38:30 <ksf> it's not so much that it'd be bad design to use <|> non-commutatively, but you might have a type that has both choices.
13:38:40 <mauke> chrisdone: http://mauke.ath.cx/stuff/img/lol,internet/bthreads/1215591408613.jpg
13:38:54 <ksf> like parsec, where x <|> y = try x </> y
13:39:27 <benmachine> neither of those commute, though, right?
13:39:44 <chrisdone> mauke: splendid√©
13:40:05 * ksf wouldn't know why right now
13:40:26 <aristid> ksf: ah, so if people use Alternative, they're totally safe, but </> can be used for efficiency?
13:40:30 <benmachine> I'm thinking of the case where both parsers would succeed but produce different things
13:40:36 <ksf> yes.
13:40:44 <ksf> although </> might be the only option
13:41:14 <ksf> benmachine, right
13:41:44 <mauke> http://sial.org/tmp/v-for-venndetta.png
13:41:46 * benmachine doesn't find </> in hoogle
13:41:57 <aristid> benmachine: because it's not a standard op
13:41:58 * ksf pulled it out of his hat
13:42:01 <geheimdienst> v is for venn
13:42:07 <benmachine> k
13:42:10 <benmachine> ic
13:42:34 <ksf> but it's quite common in parsing to use it for ordered choice.
13:42:40 <ksf> that is, first alternative wins
13:42:45 <ksf> ambiguity is evil.
13:43:34 <ksf> if you don't want to choose, use something :: f a -> f b -> f (a,b)
13:44:05 <ksf> or something :: f a -> f b -> f (Maybe a,Maybe b) , even
13:45:29 <benmachine> Either a b OrBoth
13:45:44 <soupdragon> mauke omg lol http://mauke.ath.cx/stuff/img/lol,internet/bthreads/1175716166563.jpg
14:01:58 <c_wraith> > read "[\"Foo'", \"b43\"]" :: [String]
14:01:59 <lambdabot>   <no location info>: parse error on input `,'
14:02:15 <c_wraith> > read "[\"Foo'\", \"b43\"]" :: [String]
14:02:17 <lambdabot>   ["Foo'","b43"]
14:02:25 <c_wraith> I can type, really
14:03:33 <geheimdienst> ... it's just that you have been making so many lolcats that the lines are starting to blur ...
14:17:38 <soupdragon> Does anyone  like MathJAX
14:17:41 <soupdragon> ?
14:17:47 <soupdragon> Or LaTeX2HTML
14:17:54 <soupdragon> or uummmmm jsMath is too big to use
14:17:57 <soupdragon> it's like 100 MB
14:18:14 <soupdragon> it's so depressing that the hypertext can\t even typeset mathematics
14:18:17 <soupdragon> pitifula
14:18:19 <soupdragon> pitiful
14:18:23 <shivam3013> hey
14:19:03 <geheimdienst> what, seriously? jsmath is 100 megs?
14:19:25 <soupdragon> the prbolem with that is you can't put it on stuff like blogger
14:19:34 <soupdragon> and in general that's just ridiculous
14:20:34 <soupdragon> maybe I should write my own solution
14:20:41 <soupdragon> thats what htey say: If you need something done ..
14:21:18 <geheimdienst> i imagine if you could get the web server to enable gzip compression, that would take much of the pain away. i guess js code would compress fairly well
14:22:18 <geheimdienst> also, google has this thing where they're hosting popular libraries (jquery ...) for you. surely other groups have copied that. so maybe someone is openly hosting jsmath somewhere
14:22:38 <soupdragon> geheimdienst: that sounds interesting
14:23:25 <lispy> geheimdienst: IIRC apache does try to compress things it sends
14:24:07 <shivam3013> hey
14:24:12 <geheimdienst> it definitely can be configured to, any webserver worth its salt can, but i'm not sure if it's on by default
14:24:16 <soupdragon> geheimdienst: does it have jsmath ??
14:24:18 <shivam3013> does anyone want to make a rpg with me
14:24:21 <geheimdienst> my hunch would be it's off by default
14:24:30 <geheimdienst> soupdragon, no ... http://code.google.com/intl/da/apis/ajaxlibs/
14:24:41 <lispy> shivam3013: I would love to, but I'm having trouble finding free time for projects like that
14:24:43 <soupdragon> oh well
14:24:44 <Trevion> Does anyone have much experience with the LLVM bindings on MinGW?
14:24:50 <benmachine> straw poll: who can remember which one is intersperse and which one is intercalate
14:24:52 <geheimdienst> but what i mean is, probably other people do similar things, and with luck someone could be hosting jsmath
14:25:00 <shivam3013> lispy
14:25:02 <mauke> benmachine: I can
14:25:10 <lispy> shivam3013: I'd like to build a rouge-like with Ultima aspects on top of the ogre3d bindings
14:25:10 <shivam3013> lispy?
14:25:13 <Trevion> straw poll: I can, because intersperse used to regularly make me sad
14:25:18 <mauke> intersperse is the other one
14:25:22 <shivam3013> lispy private chat me'
14:25:22 <benmachine> heh
14:25:31 <benmachine> fine, I just fail then :P
14:25:52 <Trevion> intercalate: useful.  Intersperse: if intercalate didn't do what you wanted.
14:25:56 <shivam3013> anyone else want to make a rpg with me?
14:26:07 <benmachine> heheh
14:26:19 <geheimdienst> intercalate is just intersperse + concat
14:26:21 <lispy> shivam3013: you might look at hackage.  Maybe you could join the roguestar project?
14:26:22 <soupdragon> shivam3013: you scare people off when you say "Ill give you bags of money"
14:26:28 <mauke> I put on my robe and wizard hat
14:26:42 <shivam3013> which project?
14:26:44 <kmc> shivam3013, are you writing your rpg in haskell?
14:26:53 <shivam3013> partially maybe.
14:27:01 <lispy> shivam3013: http://hackage.haskell.org/package/roguestar-gl-0.4.0.1
14:27:08 <roconnor> > id$x
14:27:09 <lambdabot>   x
14:27:10 <shivam3013> depends if I get a haskell programmer as a partner.
14:27:38 <shivam3013> k
14:27:39 <shivam3013> g2g
14:27:47 <shivam3013> anyone interested ask me tomorow same time
14:28:00 <Trevion> Same bat time, Same bat...
14:28:30 * lispy suspects shivam doesn't quite understand irc etiquette on freenode :)
14:28:39 <lispy> idling++
14:28:53 <kmc> like not demanding random people PM you
14:29:03 * lispy nods
14:29:25 <jmcarthur> irc etiquette has to be learned
14:29:41 <jmcarthur> if you don't know anybody IRL to teach it to you
14:29:45 <mauke> make ŒªŒªŒª fast
14:30:31 <jmcarthur> when i first got on irc i just idled for a while
14:30:49 <jmcarthur> i thought it was rude at the time, but i didn't have anything to say for that long
14:30:50 <benmachine> repeat 'Œª'
14:30:57 <benmachine> idling <3
14:30:59 <jmcarthur> of course now i know that's not rude at all :P
14:31:34 * benmachine wants lines "foo\n" to return ["foo", ""]
14:31:46 <lispy> jmcarthur: Nah, I still thought you were a jerk ;)
14:32:05 <mauke> benmachine: that would be evil
14:32:12 <benmachine> mauke: how so?
14:32:13 <Lycurgus> depends on the channel. Idling is common, even required (due to low activity) on most
14:32:22 <lispy> benmachine: yeah, lines / unlines are not symmetric
14:32:28 <Lycurgus> but there are those where it's forbidden
14:32:29 <mauke> benmachine: creating fake empty lines
14:32:36 <lispy> > lines "foo\n"
14:32:37 <lambdabot>   ["foo"]
14:32:38 <jmcarthur> aristid: objective-c being like MaybeT IO would be more believable if objective-c had the type safety and separation of execution from evaluation that MaybeT IO has
14:32:40 <benmachine> mauke: depends what you think of as a line
14:32:50 <mauke> benmachine: a sequence of characters terminated by \n
14:32:53 <benmachine> > lines "foo\n\nbar"
14:32:55 <lambdabot>   ["foo","","bar"]
14:33:01 <benmachine> mauke: hmm
14:33:09 <geheimdienst> dude, just call lines and say ++ ""
14:33:11 <benmachine> mauke: so lines "foo" should return [] in your book?
14:33:22 <mauke> benmachine: well, it's a partial line
14:33:27 <benmachine> geheimdienst: no because I want lines "foo\n" and lines "foo" to return different things
14:33:38 <benmachine> of course what I actually want is a different function
14:33:47 <benmachine> but it'd be nice if everyone else just changed to suit my needs
14:34:02 <lispy> benmachine: you're not the only one to want this
14:34:21 <mauke> > let foo = lines . (++ "\n") in [foo "foo", foo "foo\n"]
14:34:22 <lambdabot>   [["foo"],["foo",""]]
14:34:26 <lispy> benmachine: some of versions of darcs before the 1.0 release had subtle bugs because of lines/unlines
14:34:55 <benmachine> mauke: that's pretty clever I guess
14:35:10 <benmachine> slight inefficiency but who cares
14:35:14 <mauke> benmachine: lines "foo" could return [], ["foo"], or an error
14:35:23 <aristid> jmcarthur: i was just saying it because in objective c, all method calls on nil do nothing and return nil
14:36:26 <soupdragon> http://upload.wikimedia.org/wikipedia/commons/4/42/Cudeposition.gif
14:36:48 <soupdragon> look at this cool animation
14:36:49 <ddarius> geheimdienst: (++"") = id :: String -> String
14:37:06 <jmcarthur> aristid: with MaybeT IO, you transform functions to work that way using monadic combinators, but they don't do that by themselves
14:37:14 <Trevion> ddarius: Expensive id
14:38:02 <jmcarthur> aristid: unless of course you main all functions have the form:   MaybeT IO a -> MaybeT IO b -> MaybeT IO c
14:38:08 <geheimdienst> ddarius, yeah, it was nonsense what i said. i meant (lines xs) ++ [""], but that isn't what he wanted either. mauke had it right
14:38:19 <jmcarthur> but i would say that is also different
14:38:48 <jmcarthur> since then you can't run an action and simply use its untransformed result as arguments later
14:39:06 <jmcarthur> have to lift it with return. then you're using combinators again
14:39:47 <aristid> jmcarthur: functions that work on MonadIO (as it ought to be) will work that way immediately
14:40:01 <soupdragon> how does anyone keep having the energy to write the boring bits of programs??
14:40:22 <Trevion> Excellent! I found a pastebin of someone else who had my problem... now if only I knew the solution...
14:40:23 <wli> They don't. They try and fail. Repeatedly.
14:40:24 <aristid> soupdragon: by paycheck?
14:40:29 <lispy> soupdragon: let me know what you find out :)
14:40:30 <kmc> coffee
14:40:48 <jmcarthur> aristid: no they won't
14:40:57 <jmcarthur> aristid: unless you only have pure values already
14:40:58 <wli> Also horrifying linear scan etc. garbage.
14:41:23 <soupdragon> http://upload.wikimedia.org/wikipedia/commons/2/2f/Heightmap_rendered.png
14:41:25 <soupdragon> I need this in haskell
14:41:31 <soupdragon> but I don't feel like writing it :(
14:41:39 <soupdragon> because I've done one of these before
14:41:46 <soupdragon> (not in haskell though)
14:41:48 <aristid> jmcarthur: ok ok my tongue-in-cheek comparison was shaky. i admit defeat! :)
14:41:58 <ddarius> That should just be a call to an OpenGL routine.
14:42:09 <soupdragon> well I also have to load tnhe bitmap
14:42:12 <lispy> soupdragon: does it need to be in haskell or usable from Haskell?
14:42:17 <soupdragon> http://upload.wikimedia.org/wikipedia/commons/5/57/Heightmap.png
14:42:36 <soupdragon> lispy well I want to put a point on it and animate its motion - and maybe move the camera around
14:42:47 <aristid> soupdragon: imagine that you're ACTUALLY just writing generic combinators, and then make a single line to create the heightmap with your nifty combinators :)
14:42:59 <soupdragon> I could probably code it myself but the idea of doing it is very hard -_-
14:43:12 <jmcarthur> soupdragon: you can load the bitmap as a texture using bitmap-opengl
14:43:28 <wli> Why not just use standard surface models?
14:43:31 <soupdragon> okay well I cabal installed it that's a start :p
14:43:42 <lispy> soupdragon: You might take some other implementation, say in C, and create FFI bindings in Haskell so that you can use those functions and implement the animation in your Haskell code
14:44:04 <geheimdienst> uh, soupdragon: you may be interested in this: http://en.wikipedia.org/wiki/Bumpmap
14:44:59 <geheimdienst> i guess your program should really just be: load png, create square, apply png as bumpmap, set camera, render
14:45:23 <ddarius> geheimdienst: I doubt that.
14:45:23 <soupdragon> well the problem is bearing the pain of turning one sentence of instructions into haskell code
14:45:34 <soupdragon> and all the problems along the way
14:45:40 <ddarius> geheimdienst: I'm pretty sure she wants an actual surface.
14:45:58 <soupdragon> well I need a function h : R^2 -> R
14:46:00 <soupdragon> and a 3D rendering of it
14:46:18 <soupdragon> actually that way it means I don't have to load a bitmap until the thing is working...
14:47:21 <geheimdienst> so the height function is the problem?
14:47:43 <ddarius> If you just need something similar to that heightmap, a noise generator can be used.
14:47:53 <ddarius> That height map is probably the output of a noise generator.
14:48:07 <soupdragon> I guess the only thing I actually don't know how to do well is have a camera that you can move around
14:48:27 <ddarius> Again, this is handled by OpenGL for the most part.
14:48:30 <soupdragon> on the other hand I could just place it where the ball is minus its direction
14:48:41 <soupdragon> but that wont work.... because the camera might go through the height map
14:49:17 <jmcarthur> i've been using the OpenGL package for my game. it's been surprisingly decent now that i've gotten more used to its conventions. it still doesn't support a lot of things i need though, so i've forked it and am making my own changes to it specifically for my game
14:49:29 <ddarius> soupdragon: You can have the constraint that the camera is a certain height above the height map.
14:49:31 <geheimdienst> well, i had a class on basic opengl once, and making the mouse control the camera was an intermediate exercise then. it's not difficult. it was maybe 30 lines of c++
14:50:25 <geheimdienst> something like x = left/right, y = up/down, wheel = zoom
14:50:45 <jmcarthur> bumpmaps in opengl is not as trivial as you made it sound :P  plus i don't think a bumpmap is what soupdragon is after
14:51:10 <soupdragon> basically I am making a golf sim except the ball can't get off the ground at all
14:51:14 <soupdragon> it just rolls up and down the hills
14:51:19 <jmcarthur> sounds to me like soupdragon just wants to render a mesh generated from a heighmap
14:51:19 <soupdragon> it's an ex. in my book
14:51:27 * ddarius remembers an old bumpmap demonstration in QBASIC.
14:51:32 <soupdragon> but I can\t be bothered with all the /other/ stuff I just want everything to work magically
14:51:41 <c_wraith> oh.  you really want to render a vector field from a heightmap, too
14:51:43 <soupdragon> cant I just tell haskell "do this and this with a camera here etc.."
14:51:47 <aristid> soupdragon: just skip the visualization and print numbers!
14:52:03 <soupdragon> the problem with printing numbers is that when I read them I can't tell if I got the thing wrong or not
14:52:20 <soupdragon> (I can tell this from experience :P)
14:52:53 <geheimdienst> jmcarthur, what i meant was: before spending days coding, you should take half an hour learning about opengl's bumpmaps and find out if you can use them. directly from your code or as an inspiration
14:52:53 <jmcarthur> soupdragon: why not use a 2D visualization? do a heatmap instead of a heightmap?
14:53:04 <jmcarthur> geheimdienst: opengl doesn't have bumpmaps
14:53:17 <soupdragon> I guess I could just it wouldn't look at nice
14:54:30 <jmcarthur> geheimdienst: bumpmapping with opengl has to be done manually. you tell it how to calculate every pixel based on the bumpmap
14:56:18 <soupdragon> it's like a (tiny) marble rolling in a sink
14:56:31 <jmcarthur> well, for decent bump mapping you have to do that anyway
14:56:40 <soupdragon> might be interesting to model a 'large' one where things like radius and rotational inertia(?) come into it
14:58:07 <kmc> opengl works on the level of meshes
14:58:12 <kmc> not pixels, not bumpmaps
14:58:40 <kmc> however you might be able to fake bumpmaps with shaders
14:58:45 * BMeph would love to see a "Marble Madness" clone in Haskell...
14:58:46 <kmc> especially geometry shaders, which i know nothing about
14:58:57 <kmc> converting a heightmap to a mesh in a naive way is trivial, but probably doesn't look too good
14:59:25 <soupdragon> BMeph, lol I would have to learn some new tricks though
14:59:41 <soupdragon> mmmmmm
14:59:45 <soupdragon> interesting....
14:59:58 <soupdragon> there should be a way to take an 'atlas' of heightmaps and join them all seamlessly
15:00:12 <soupdragon> (to make a marble mddness level)
15:00:24 <soupdragon> but I don't know how to fit bad guys into it
15:00:35 <soupdragon> what is the equation for being attacked by a monster?
15:02:16 <soupdragon> actually even simpler is what happens when you jump off a ramp
15:02:32 <soupdragon> I mean you could start flying (different physics for soaring through the air and rolling..)
15:02:42 <soupdragon> but the question is: When do you stop flying and start rolling again
15:03:09 <soupdragon> in reality there is no distinction
15:03:38 <kmc> you have a constant gravitational force, and you have a normal force which is zero unless you're in contact with the surface
15:03:54 <kmc> in reality this force is a continuous but very steep ramp-up from 0
15:04:02 <kmc> but you'd probably just threshold the distance
15:06:07 <c_wraith> I really like the zip `ap` tail trick
15:06:12 <soupdragon> http://www.comp.leeds.ac.uk/funvis/
15:06:15 <soupdragon> this is interesting
15:06:25 <soupdragon> "This project aims to re-express well-known visualisation algorithms (e.g. volumetric surface extraction) in the functional language Haskell"
15:07:09 <alpounet> @type zip `ap` tail
15:07:10 <lambdabot> forall b. [b] -> [(b, b)]
15:08:01 <geheimdienst> > zip `ap` tail $ [1,2,3]
15:08:02 <lambdabot>   [(1,2),(2,3)]
15:08:07 <geheimdienst> > zip `ap` tail $ [1,2,3,4]
15:08:08 <lambdabot>   [(1,2),(2,3),(3,4)]
15:08:45 <roconnor> @quote aztec
15:08:45 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:09:24 <kmc> :t zip <*> tail
15:09:25 <lambdabot> forall b. [b] -> [(b, b)]
15:09:28 <aristid> > let x = [1,2,3,4] in (zip x) (tail x)
15:09:29 <lambdabot>   [(1,2),(2,3),(3,4)]
15:10:38 <c_wraith> though I'm actually just using ap zip tail, because it's part of a function composition chain
15:12:10 <agocorona> > showString "hi" . showString "people" $ " "
15:12:11 <lambdabot>   "hipeople "
15:12:21 <aristid> :t showString
15:12:22 <lambdabot> String -> String -> String
15:12:32 <aristid> @src showString
15:12:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:12:42 <aristid> > showString "a" "b"
15:12:43 <lambdabot>   "ab"
15:13:06 <geheimdienst> what is that function good for?
15:13:20 <agocorona> it concatenates efficiently
15:13:22 <soupdragon> so does anyone have a really simple opengl test thing like a teapot or whatever?
15:13:31 <aristid> agocorona: how so?
15:13:53 <soupdragon> google for haskell opengl examples doesn't really do anything
15:14:28 <blackh> soupdragon: I'll rustle something up for you.
15:14:34 <agocorona> aristid: because it does not modify the second string (I think)
15:14:38 <soupdragon> really ? that is so kind thank you
15:14:51 <soupdragon> I am having psychological problems getting anything done so this is a big help :p
15:15:08 <aristid> agocorona: strings can never be modified
15:15:27 <agocorona> aristid:  yes. I mean: it does no copy the second string
15:15:45 <aristid> agocorona: how's that different from (++)?
15:15:50 <blackh> |-
15:16:20 <agocorona> aristid: mmmm 
15:17:21 <aristid> showString      :: String -> ShowS
15:17:21 <aristid> showString      =  (++)
15:17:26 <agocorona> aristid:  it¬¥s part of the class Show, and it¬¥s there for efficiency reasons. Don¬¥t ask me why
15:18:22 <blackh> soupdragon: 
15:18:27 <blackh> http://www.haskell.org/pipermail/beginners/2010-February/003654.html
15:18:27 <agocorona> actually: showString       =  (++)
15:18:54 <blackh> If you have any questions, ask away. I've done a lot of OpenGL in Haskell.
15:20:08 <blackh> Actually you probably want to turn off lighting until you get something appearing on the screen.
15:21:07 <kmc> showString is not any more efficient than (++).  it's just the implementation of ¬´shows¬ª for a String
15:21:09 <kmc> :t shows
15:21:10 <lambdabot> forall a. (Show a) => a -> String -> String
15:21:16 <kmc> that is,
15:21:20 <kmc> forall a. (Show a) => a -> ShowS
15:22:07 <kmc> a value of type ShowS represents a string, but is actually a function of type (String -> String)
15:22:08 <soupdragon> I had to add getArgsAndInitialize
15:22:11 <soupdragon> because it was crashing without that
15:22:14 <kmc> and so you concatenate them with (.)
15:22:14 <aristid> String seems to be a special type synonym
15:22:20 <roconnor> showString is not infix by default
15:22:43 <roconnor> and probably more clear than a floating (++) somewher
15:22:50 <int80_h> hello
15:22:54 <kmc> which does no work (even when forced)
15:23:00 <kmc> and then you can convert the whole tree of functions into a string in one go
15:23:06 <kmc> which is more efficient than using (++) everywhere
15:23:11 <monochrom> String is a type synonym but not special
15:23:12 <aristid> roconnor: it's intended to be used in a ShowS context, where show* is a common idiom
15:23:17 <int80_h> lemmih, you around?
15:23:27 <roconnor> and where prefix form is common
15:23:39 <aristid> monochrom: why is it not printed as [Char] in lambdabot and ghci?
15:24:02 <blackh> soupdragon: Oh! Perhaps we could stick your program on the Haskell wiki once you get it displaying something.
15:24:03 <monochrom> because the typeclass Show is designed to cheat. consider the method showList
15:24:08 <monochrom> @src Show
15:24:09 <lambdabot> class  Show a  where
15:24:09 <lambdabot>     showsPrec :: Int -> a -> ShowS
15:24:09 <lambdabot>     show      :: a   -> String
15:24:09 <lambdabot>     showList  :: [a] -> ShowS
15:24:19 <agocorona> kmc: i never used showString, but had the idea that it was efficent., but now looking in the prelude i realize that it is just (++)
15:24:20 <aristid> monochrom: no i mean;
15:24:23 <aristid> :t "a"
15:24:24 <lambdabot> [Char]
15:24:30 <soupdragon> blackh, well I am going to draw a heightmap
15:24:33 <aristid> oO
15:24:34 <int80_h> I understand this is off-topic. I know some haskell developers use archlinux for their haskell enviroment. Is there someone here that set up archlinux as a domU?
15:24:44 <jbapple> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26498#a26498
15:24:45 <aristid> :t show
15:24:46 <lambdabot> forall a. (Show a) => a -> String
15:24:49 <soupdragon> and I think the best thing (simplest) is just to make the camera point at it from a roughly 45 degree angle
15:24:55 <kmc> agocorona, it makes little sense if you read its type as (String -> String -> String).  it makes more sense if you read its type as (String -> ShowS)
15:25:09 <jbapple> Here is an example set of Ints where Data.Set is faster for lookup than Data.IntSet ^
15:25:11 <kmc> and pretend that ShowS is an abstract string-like type with fast concatenation
15:25:12 <aristid> monochrom: ok it seems to be rather inconsistent. see how :t show is a -> String but :t "a" is [Char]
15:25:18 <agocorona> anyway it permits nice looking compositions: > showString "hello " . showString "how " . showString "are " . showString "you"
15:25:35 <blackh> soupdragon: The nehe tutorial is the best one I've come across. No Haskell code on there but it's easy to translate.
15:25:37 <kmc> if you're gluing strings together, I recommend Text.PrettyPrint over any of this
15:25:49 <jbapple> Data.IntSet can follow as many as w branches, where w is the width of your machine word (32 or 64)
15:26:03 <soupdragon> :t forM
15:26:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:26:05 <soupdragon> :t forM_
15:26:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
15:26:13 <c_wraith> ouch.  I'm very unhappy that hint's unsafeSetGhcOption seems to fail on "-hide-all-packages"
15:26:18 <jbapple> Data.Set, OTOH, follows at most  O(lg n) branches, where n is the size of your set
15:26:21 <monochrom> all type synonyms enjoy that kind of inconsistency. explicit type sigs are honoured; if there is no explicit type sig, then it goes with whatever type inference finds.
15:26:36 <kmc> :t "foo"
15:26:37 <lambdabot> [Char]
15:26:40 <jbapple> The set I used is 
15:26:40 <jbapple> > 0:[2^i | i <-[0..30]]
15:26:40 <kmc> :t "foo" :: String
15:26:41 <lambdabot> String
15:26:41 <lambdabot>   [0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
15:26:48 <aristid> > 2^32
15:26:49 <lambdabot>   4294967296
15:26:59 <jbapple> >2 ^31 :: Int
15:27:05 <jbapple> > 2^31 :: Int
15:27:06 <lambdabot>   2147483648
15:27:16 <jbapple> > 2^63 :: Int
15:27:17 <lambdabot>   -9223372036854775808
15:27:23 <kmc> :t tail ("foo" :: String)
15:27:24 <lambdabot> [Char]
15:27:27 <jbapple> On my machine (32 bits)
15:27:33 <aristid> > 2^63 :: Word64
15:27:34 <lambdabot>   9223372036854775808
15:27:40 <monochrom> So ¬´show¬ª gets String because there is a type declaration in the Prelude. And things like (\xs -> 'a':xs) tend to get [Char] because it's inferred.
15:27:42 <jbapple> Data.Set is 2x as fast as Data.IntSet
15:27:43 <kmc> :t id ("foo" :: String)
15:27:44 <lambdabot> String
15:27:48 <jbapple> (for lookup in that set)
15:27:50 <aristid> kmc: see there is some specialness in String
15:28:04 <kmc> aristid, all of the above is consistent with monochrom's general rule
15:28:20 <jbapple> I expect on 64 bit machines, using 0:[2^i | i <-[0..62]]  it will be much worse
15:28:28 <aristid> kmc: it doesn't change the way String behaves, i know
15:28:39 <kmc> in what way are you claiming String is special?
15:28:45 <jbapple> since IntSet will follow ~64 branches, while set will follow ~6
15:29:14 <soupdragon> blackh, do you know the right way to say move the camera back 100 steps and up 20 and point it down a little bit so it can see my surface?
15:29:25 <aristid> kmc: well, no other type synonym is ever shown by the type printer
15:29:29 <soupdragon> http://pastie.org/1016543.txt
15:29:31 <soupdragon> I did that
15:29:33 <soupdragon> but it's invisible
15:29:34 <aristid> :t undefined :: ShowS
15:29:35 <lambdabot> String -> String
15:29:35 <kmc> aristid, that's not true
15:29:37 <soupdragon> so I assume it's behind the camera
15:29:38 <kmc> hmm
15:29:47 <aristid> :t undefined :: String
15:29:47 <kmc> weird
15:29:48 <lambdabot> String
15:29:51 <aristid> kmc: :)
15:30:00 <kmc> i'm sure i've seen others
15:30:13 <aristid> maybe depends on the version of the compiler
15:30:22 <kmc> type T = Maybe Char; x :: T; x = Just 'z'
15:30:26 <monochrom> go to your ghci and ask for type of readFile
15:30:36 <kmc> ghci says "x :: T"
15:30:37 <blackh> soupdragon: I'm not familiar with quads, but it's too big.  Your initial space is from -1 to 1.
15:30:40 <monochrom> explain "FilePath"
15:30:40 <c_wraith> the pretty printer will use type synonyms when they're explicitly annotated
15:30:42 <jbapple> Have tries with 4-way branching been tested for Data.IntSet and rejected?
15:30:57 <kmc> :t undefined :: FilePath
15:30:57 <lambdabot> FilePath
15:31:03 <kmc> so perhaps it is ShowS which is special ;)
15:31:09 <monochrom> :t readFile
15:31:10 <lambdabot> FilePath -> IO String
15:31:15 <agocorona> does Landabot permit IO actions?
15:31:17 <soupdragon> what should I use instead?
15:31:18 <agocorona> > getCurrentDirectory
15:31:19 <lambdabot>   Not in scope: `getCurrentDirectory'
15:31:22 <kmc> agocorona, lambdabot can evaluate IO actions
15:31:24 <kmc> it can't execute IO actions
15:31:29 <kmc> > putChar 'x'
15:31:30 <lambdabot>   <IO ()>
15:31:32 <kmc> > putChar 'x' `seq` ()
15:31:33 <lambdabot>   ()
15:31:39 <blackh> soupdragon: Anything in the range (-1, -1, -1) to (1, 1, 1) is visible in the default co-ordinate space
15:31:43 <jbapple> > return () :: IO ()
15:31:44 <lambdabot>   <IO ()>
15:31:49 <monochrom> There is no type synonym conspiracy.
15:32:08 <soupdragon> i think I need a bit more space than that
15:32:23 <kmc> so why does ShowS get expanded?
15:32:29 <agocorona> > putChar 's'
15:32:30 <lambdabot>   <IO ()>
15:32:30 <blackh> soupdragon: Then you need to scale it
15:32:40 <blackh> I'll have a go with your code
15:32:44 <soupdragon> I wonder what x y and z are
15:32:51 <kmc> agocorona, lambdabot has a (non standard) ¬´instance (Typeable a) => Show (IO a)¬ª
15:32:53 <aristid> > return ()
15:32:54 <lambdabot>   No instance for (GHC.Show.Show (m ()))
15:32:54 <lambdabot>    arising from a use of `M889468827...
15:32:55 <kmc> i.e. it can print IO actions
15:32:55 <soupdragon> http://pastie.org/1016545.txt
15:32:58 <kmc> without executing them
15:33:00 <soupdragon> blackh that's the whole thing
15:33:05 <soupdragon>     translate $ Vector3 0 0 0
15:33:09 <soupdragon> that's the line I am working on right now
15:33:24 <blackh> Trying it...
15:34:20 <monochrom> :t undefined FilePath
15:34:21 <lambdabot> Not in scope: data constructor `FilePath'
15:34:27 <agocorona> > return "hello"
15:34:28 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
15:34:28 <lambdabot>    arising from a use ...
15:34:29 <monochrom> :t undefined :: FilePath
15:34:30 <lambdabot> FilePath
15:34:37 <monochrom> does not expand
15:34:38 <kmc> > return "hello" :: IO String
15:34:39 <lambdabot>   <IO [Char]>
15:34:43 <soupdragon> rotate 20 $ Vector3 0 1 (0::GLfloat) ; translate $ Vector3 (-100) (0::GLfloat) (-20) -- doesn't do anything...
15:34:45 <monochrom> :t undefined :: FilePath -> FilePath
15:34:46 <soupdragon> I tried a bunch of stuff
15:34:47 <lambdabot> FilePath -> FilePath
15:34:52 <aristid> monochrom: FilePath is a type synonym?
15:34:55 <soupdragon> seems a bit futile
15:34:57 <kmc> @src FilePath
15:34:57 <lambdabot> type FilePath = String
15:35:13 <aristid> ok there is some inconsistency there
15:35:22 <kmc> the Show instance for IO actions does not even evaluate them
15:35:24 <kmc> > undefined :: IO Char
15:35:25 <blackh> soupdragon: That's why it's a good idea to look at the NeHe tutorial. Then you go through all that stuff about scaling and positioning the camera
15:35:25 <lambdabot>   <IO Char>
15:35:30 <monochrom> If you have not even heard of FilePath, you are in no position to propose a conspiracy theory.
15:35:35 <kmc> but if it did evaluate the action, it still would not execute it
15:35:53 <kmc> anyway, back later
15:36:10 <monochrom> You are like you have just seen one prime number, 2, and you go about postulation general theorems about prime numbers.
15:37:27 <BMeph> newtype vs. type, perhaps?
15:37:33 <aristid> > let primes = [2,4..] in primes
15:37:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
15:37:39 <aristid> monochrom: ^
15:38:36 <soupdragon> just gives a black screen
15:39:17 <cozachk> cls4teh.win
15:39:59 <soupdragon> well that was a waste of time
15:40:26 <blackh> soupdragon: You give up easily. Hack hack hack....
15:41:48 <blackh> I'll just get it doing something
15:42:34 <aristid> monochrom: but say, why is it not a bit more consistent?
15:42:58 <soupdragon> I found something I can cannabalize
15:43:07 <soupdragon>    BezSurf.hs (adapted from bezsurf.c which is (c) Silicon Graphics, Inc)
15:44:03 <blackh> soupdragon: Well, one thing is that x and z are the "ground" and y is the height co-ordinate.  By default it's viewed side-on
15:45:10 <Cale> blackh: Hey, I'm up at my linux machine, perhaps I can help :)
15:46:08 <Cale> blackh: Are you still working on the hammer adjustment thing?
15:46:35 <c_wraith> ok.  for some reason, the ghc api doesn't like dynamically setting -hide-all-packages
15:46:38 <c_wraith> That makes me really sad
15:46:46 <soupdragon> > (,) <$> [0..3] <*> [0..3]
15:46:47 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
15:46:56 <djahandarie> http://thenextweb.com/apple/2010/06/23/if-true-this-leaked-report-may-leave-apple-att-with-a-lot-of-explaining-to-do/
15:47:00 <djahandarie> Heh
15:47:25 <blackh> Cale: All done now. If you're working today, then I'll see you in iPwn-dev
15:47:48 <Cale> okay, Perhaps I'll go downstairs and use the VM then :)
15:48:05 <jbapple> on my machine, IntSets can slow down by a factor of 4: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26498#a26499
15:48:18 <ivanm> blackh: what, you're going to another hackathon this month as well?
15:48:23 <jbapple> So Data.Set goes from twice as slow as Data.IntSet to twice as fast
15:48:42 <soupdragon> > (,) <$> [0..3] <$> [0..3]
15:48:43 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
15:48:44 <jbapple> (For certain queries with certain sets)
15:49:14 <mtnviewmark> > liftM2 (,) [0..3] [0..3]
15:49:15 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
15:49:19 <soupdragon> > (map (,) [0..3]) <$> [0..3]
15:49:20 <lambdabot>   Couldn't match expected type `a -> b'
15:49:20 <lambdabot>         against inferred type `[b1 ->...
15:49:23 <blackh> soupdragon: I'll leave ya to it, as I think I'd better get on with some work.  The problem is to do with OpenGL settings like materials and so on. I highly recomment the NeHe tutorial.
15:49:45 <soupdragon> > [[0..3]..]
15:49:46 <lambdabot>   No instance for (GHC.Enum.Enum [t])
15:49:46 <lambdabot>    arising from a use of `e_103' at <in...
15:50:01 <soupdragon> @src liftM2
15:50:01 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:50:05 <soupdragon> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:50:05 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
15:50:21 <c_wraith> @. undo src liftM2
15:50:21 <lambdabot> ()
15:50:30 <soupdragon> > (\f m1 m2 -> m1 `map` \ x1 -> m2 >>= \ x2 -> return (f x1 x2)) [0..3] [0..3]
15:50:31 <lambdabot>   The lambda expression `\ x1 -> m2 GHC.Base.>>= ...'
15:50:31 <lambdabot>  has one argument,
15:50:31 <lambdabot>  but...
15:50:37 <soupdragon> > (\f m1 m2 -> m1 >>= \ x1 -> m2 `map` \ x2 -> return (f x1 x2)) [0..3] [0..3]
15:50:38 <lambdabot>   The lambda expression `\ x2 -> GHC.Base.return (f x1 x2)'
15:50:38 <lambdabot>  has one argument...
15:50:49 <soupdragon> how can I get liftM2 that doesn't flatten?
15:51:19 <ivanm> "flatten" ?
15:51:22 <mtnviewmark> doesn't flatten?
15:51:26 <mtnviewmark> you want a list of lists
15:51:46 <ivanm> soupdragon: use an explicit map then, rather than a concatMap like the list monad does
15:52:26 <ddarius> c_wraith: @src (and one other command) are broken so that they can't be composed.
15:52:43 <mtnviewmark> map (\i -> map (\j -> (i,j)) [0..3]) [0..3]
15:52:47 <c_wraith> ddarius, I see
15:52:52 <mtnviewmark> > map (\i -> map (\j -> (i,j)) [0..3]) [0..3]
15:52:54 <lambdabot>   <no location info>: lexical error at character '\FS'
15:53:17 <mtnviewmark> > map (\i -> map (\j -> (i,j)) [0..3]) [0..3]
15:53:18 <lambdabot>   [[(0,0),(0,1),(0,2),(0,3)],[(1,0),(1,1),(1,2),(1,3)],[(2,0),(2,1),(2,2),(2,...
15:53:36 <mtnviewmark> this is made more awkward because you can't use , in a section (without some GHC ext.)
15:54:02 <ddarius> Why do you need a section? (,) i
15:54:17 <mtnviewmark> > map (\i -> map (i,) [0..3]) [0..3]
15:54:19 <lambdabot>   <no location info>: parse error on input `)'
15:54:20 <mtnviewmark> would be cleaner
15:54:22 <mtnviewmark> but doesn't parse
15:54:30 <mtnviewmark> for what (I think) soupdragon wants
15:54:36 <benmachine> :t ((,) i)
15:54:37 <lambdabot> forall b. b -> (Expr, b)
15:54:39 <aavogt> it can parse with extensions
15:54:46 <ddarius> > map (\i -> map ((,) i) [0..3]) "abc"
15:54:46 <lambdabot>   [[('a',0),('a',1),('a',2),('a',3)],[('b',0),('b',1),('b',2),('b',3)],[('c',...
15:54:50 <benmachine> oh, ddarius said
15:54:55 <benmachine> listen to him he knows things
15:55:06 <mtnviewmark> sure
15:55:30 <benmachine> the extension btw is TupleSections, new in 6.12
15:55:59 <Saizan> > map (flip map [0..3] . (,)) "abc"
15:56:01 <lambdabot>   [[('a',0),('a',1),('a',2),('a',3)],[('b',0),('b',1),('b',2),('b',3)],[('c',...
15:56:46 <Trevion> Bah! I was just about to say:
15:56:58 <Trevion> >  map (flip map [1,2,3]) (map (,) "abc")
15:56:59 <lambdabot>   [[('a',1),('a',2),('a',3)],[('b',1),('b',2),('b',3)],[('c',1),('c',2),('c',...
15:57:15 <c_wraith> ok, yeah.  the GHC api rejects "-hide-all-packages" as a flag passed in after initialization.  urgh.
15:57:37 <benmachine> > (,) <$> "abc" <*> [1,2,3]
15:57:39 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
15:57:43 <benmachine> hm
15:57:46 <benmachine> too much concatting
15:57:56 <ddarius> That's liftA2 (,) = liftM2 (,0
15:58:00 <benmachine> > groupBy fst $ (,) <$> "abc" <*> [1,2,3] -- cheating woo
15:58:01 <lambdabot>   Occurs check: cannot construct the infinite type:
15:58:02 <lambdabot>    a = (a, b) -> GHC.Bool...
15:58:05 <Saizan> Trevion: map fusion ftw
15:58:12 <benmachine> > groupBy (equating fst) $ (,) <$> "abc" <*> [1,2,3] -- cheating woo
15:58:13 <lambdabot>   Not in scope: `equating'
15:58:15 <benmachine> :(
15:58:41 <aristid> :t groupBy
15:58:42 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:58:48 <soupdragon> ctrlPoints = [ [ Vertex3 (x/4-1) (y/4-1) (h [x,y]) | y <- [0..8] ] | x <- [0..8] ]
15:58:49 <soupdragon> that works
15:58:53 <soupdragon> but if I double the numbers it breaks
15:58:56 <soupdragon> so annoying..
15:58:58 <cozachk> the by functions act weird sometimes 
15:59:05 <ddarius> benmachine: Cheaters never prosper... except most of the time.
15:59:08 <aristid> > groupBy ((==) `on` fst) $ (,) <$> "abc" <*> [1,2,3]
15:59:09 <lambdabot>   [[('a',1),('a',2),('a',3)],[('b',1),('b',2),('b',3)],[('c',1),('c',2),('c',...
15:59:11 <benmachine> ddarius: :)
15:59:26 <benmachine> @let equating = on (==)
15:59:28 <lambdabot>  Defined.
15:59:32 <benmachine> > groupBy (equating fst) $ (,) <$> "abc" <*> [1,2,3]
15:59:34 <lambdabot>   [[('a',1),('a',2),('a',3)],[('b',1),('b',2),('b',3)],[('c',1),('c',2),('c',...
15:59:38 <cozachk> @src on 
15:59:38 <lambdabot> Source not found. Maybe you made a typo?
15:59:45 <aristid> @let groupOn = groupBy . equating
15:59:46 <lambdabot>  Defined.
15:59:54 <Trevion> @help
15:59:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:00:00 <aristid> > groupOn fst $ (,) <$> "abc" <*> [1,2,3]
16:00:01 <lambdabot>   [[('a',1),('a',2),('a',3)],[('b',1),('b',2),('b',3)],[('c',1),('c',2),('c',...
16:00:25 <Trevion> @type on
16:00:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:00:26 <ddarius> benmachine: Now use program transformation techniques to show the two programs equivalent.
16:00:52 <benmachine> ddarius: they're only equivalent if "abc" isn't swapped with anything containing consecutive duplicates
16:01:04 <benmachine> hence why I called it cheating
16:01:32 <aavogt> @type on
16:01:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:01:40 <aavogt> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
16:01:40 <lambdabot> f a b c _ = a (b c) (b c)
16:01:42 <Trevion> @rock on
16:01:42 <lambdabot> Maybe you meant: docs rc
16:01:48 <mtnviewmark> >  [ [ (i,j) | j <- [0..3] ] | i <- [0..3] ]
16:01:49 <lambdabot>   [[(0,0),(0,1),(0,2),(0,3)],[(1,0),(1,1),(1,2),(1,3)],[(2,0),(2,1),(2,2),(2,...
16:02:01 <c_wraith> @vixen rock on
16:02:01 <lambdabot> hey, we have simular taste in music
16:02:14 <aavogt> well that's not the right definition
16:02:30 <aavogt> it should be   f a b c d = a (b c) (b d)
16:02:32 <aristid> :t const . ap
16:02:33 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m (a -> b1) -> b -> m a -> m b1
16:03:54 <djahandarie> Is there anyway to uh... extend the case syntax?
16:04:03 <ddarius> Hack GHC.
16:04:08 <ddarius> (or implementation of choice)
16:04:20 <Trevion> Extend how?
16:04:24 <djahandarie> lol. Not the answer I wanted to hear :P
16:04:40 <djahandarie> Just add extra logic that I don't want to write out every case statement, but I still want its syntax
16:05:05 <djahandarie> Probably could use TH for this
16:05:09 <ddarius> There's Template Haskell and the related QuasiQuoting stuff.
16:07:35 <aavogt> there is a library with conversions from haskell-src-exts AST -> Expr  conversions
16:07:41 <Trevion> I'm not smart enough to get the llvm bindings working... problems here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26502#a26502 Anyone recognize what I did wrong?
16:08:10 <aavogt> djahandarie: what does the extra logic do? There wouldn't be some way to easily state that stuff within haskell syntax?
16:11:28 <djahandarie> Really simple, I just always want a _ -> return (), but I don't want to have a function wrapping the case because it feels too bulky
16:11:39 <djahandarie> I just want like, myCase or something
16:11:45 <A1kmm> Does anyone know the way to get the value of the -N option given to the Haskell runtime from within a Haskell program?
16:11:53 <A1kmm> (for ghc)
16:12:07 <aavogt> @hoogle numcapabilities
16:12:08 <lambdabot> No results found
16:12:12 <yairchu> shall I try latest GHC before I submit a bug report? (with CPP+"#include" error line numbers are reported wrong)
16:12:16 <aavogt> @hoogle capabilities
16:12:16 <lambdabot> No results found
16:12:27 <djahandarie> I'm pretty sure it is numCapabilities
16:12:38 <aavogt> A1kmm: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/GHC-Conc.html#v%3AnumCapabilities
16:12:38 <djahandarie> in GHC.Conc
16:12:40 <benmachine> yairchu: I think it is usually considered a. good form and b. a pain in the arse
16:12:49 <benmachine> so, up to you :P
16:13:15 <soupdragon> i hate this stuff so frustrating
16:13:19 <aavogt> djahandarie: a _ is a pattern?
16:13:22 <A1kmm> aavogt: Thanks! I spent ages looking for something like that.
16:13:24 <benmachine> only thing I'd say is definitely submit it without trying latest GHC rather than not submit it at all
16:13:48 <ddarius> soupdragon: Become a rubbish collector.  I imagine it is rarely frustrating.
16:14:03 <aavogt> you probably imagine wrong
16:14:06 <benmachine> become a GC
16:14:22 <aavogt> gas chromatograph
16:14:24 <FauxFaux> Rubbish?  Spot benmachine's native country. ;)
16:14:41 <benmachine> by sheer coincidence you are right
16:14:44 <djahandarie> I thought of a better way to do this though
16:14:47 * djahandarie runs off
16:14:55 <aavogt> without sharing
16:15:12 <yairchu> benmachine: thanks. and correction: the bug doesn't seem to be with CPP+include. maybe QuasiQuotes. hmm
16:16:06 <benmachine> yairchu: ooh, are you expecting to get the line number of the thing in the quotation that lead to the problematic code?
16:16:22 <benmachine> sounds tricky
16:16:26 <yairchu> benmachine: nope. line number of normal code
16:16:35 <benmachine> oh right
16:16:38 <benmachine> ah
16:16:50 <fnord123> Hi all. I'm trying to use the llvm library and when I call unsafeGenerateFunction and try to execute a function I'm told: user error (Interpreter has not been linked in.)
16:16:52 <benmachine> maybe splices should insert LINE pragmas?
16:17:11 <orlandu63> > [0,1] + [0,2]
16:17:12 <lambdabot>   No instance for (GHC.Num.Num [t])
16:17:12 <lambdabot>    arising from a use of `e_10102' at <in...
16:17:13 <fnord123> I googled for this error and only found user xarch asking about it on #haskell-fr but he didn't seem to solve it in irc
16:17:24 <orlandu63> > liftM2 (+) [0,1] [0,2]
16:17:25 <lambdabot>   [0,2,1,3]
16:17:27 <fnord123> ldd says all so files are located
16:17:30 <yairchu> benmachine: hmm. it seems that the problem only occurs if you #include in QuasiQuotes.. :)
16:17:38 <benmachine> yairchu: sounds evil :P
16:18:21 <orlandu63> :t liftM2 (+)
16:18:22 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
16:19:46 <BMeph> Hmm, you giot an error while running an 'unsafe...' function. Whoa, how unexpected! ;√æ
16:20:14 <soupdragon> how does anyone not get disappointed with how broken software is?
16:20:22 <soupdragon> all the installers are broke and everything
16:20:33 <wli> It's unclear.
16:20:36 <yairchu> benmachine: it sounds evil, but it's pretty innocent: myHtmlTemplate = [$template|\n#include "templates/default.html"\n|]
16:22:20 <benmachine> yairchu: may I suggest $(fmap template runIO $ readFile "templates/default.html")
16:22:27 <benmachine> er
16:22:31 <benmachine> yairchu: may I suggest $(fmap template . runIO $ readFile "templates/default.html")
16:23:10 <yairchu> benmachine: thanks. didn't know about runIO. sounds evil.. :)
16:23:17 <tommd> @hoogle runIO
16:23:17 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
16:23:18 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
16:23:18 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
16:23:23 <aavogt> probably needs a =<< instead of fmap
16:23:31 <c_wraith> nah, runIO is what makes TH powerful...  frighteningly so. :)
16:23:42 <c_wraith> I know dcoutts doesn't like runIO :)
16:24:08 <benmachine> yairchu: maybe a litle!
16:24:10 <benmachine> tt
16:24:52 <aavogt> c_wraith: reading files, or IORefs?
16:24:54 <c_wraith> And I'm currently trying to abuse runIO even more than usual.  just to give a hint of where I'm going, I use "runIO getArgs"
16:26:25 <int80_h> could someone help me use cabal to install readline? I think it's having trouble finding the readline library. I used --extra-include-dirs, and --extra-lib-dirs to no avail.
16:26:45 <yairchu> I'd consider runIO a security breach. for example it makes a compiling service exposed. no?
16:27:03 <yairchu> int80_h: what's your platform?
16:27:11 <benmachine> c_wraith: evil points to you, sir
16:27:24 <int80_h> yairchu: debian but I am not the sys admin. It's lemmih's machine.
16:27:26 <benmachine> yairchu: well, Setup.hs can already run arbitrary code
16:27:38 <Saizan> int80_h: readline uses a configure script, which probably doesn't respect those flags, but iirc there's some environment variable you can set instead
16:27:47 <aavogt> yairchu: if you can't trust the code you compile, your security is pretty hopeless anyhow
16:27:58 <int80_h> Saizan : ah yes. Okay I think google may help me
16:28:13 <soupdragon> it amazes me
16:29:03 <int80_h> soupdragon: what?
16:31:17 <yairchu> aavogt: well, imagine at some shared hosting service GHC couldn't run because of RAM limits. so let's say they raised limits specifically for ghc processes. now you can make your website processes use more ram if you actually do all the work in ghc during compiling!
16:33:17 <orlandu63> @src (>>)
16:33:18 <lambdabot> m >> k      = m >>= \_ -> k
16:41:40 <int80_h> saizan: I have tried PATH, plus some other enviromental variables. The cabal docs say to use the flags I mentioned above. Any hints, I'm running out of things to try.
16:43:08 <fnord123> BMeph: I'm following Lenart Augustsson's blog where he used unsafeGenerateFunction. I would expect it to link and crash if it fails; but not whine about linking incorrectly. :(
16:45:23 <BMeph> fnord123: Brave man, to follow so closely in augussts' footsteps... :)
16:46:38 <fnord123> BMeph: does he have a particular reputation I should know about? I think he's a great guy and good chat over beers. :)
16:50:10 <djahandarie> @pl \h -> s {blah = Just h}
16:50:11 <lambdabot> (line 1, column 9):
16:50:11 <lambdabot> unexpected "{"
16:50:11 <lambdabot> expecting variable, "(", operator or end of input
16:50:16 <djahandarie> lol
16:51:04 <int80_h> Saizan : I did this "cabal configure --configure-option=--extra-include-dirs=/usr/include/editline --configure-option=--extra-lib-dirs=/lib readline", and got this "cabal: No cabal file found.
16:51:43 <int80_h> saizan : I also tried that w/out the last 'readline', and got same result.
16:52:14 <int80_h> when it says "no cabal file found" what is it looking for?
16:53:47 <benmachine> int80_h: it is looking for packagename.cabal, because you typically use the configure command inside a source directory
16:53:50 <benmachine> I think
16:54:17 <benmachine> so, try using install instead? or if you need control over the configuration, do cabal unpack package; cd package; cabal configure --whatever
16:59:47 <Saizan> int80_h: use "cabal install" not "cabal configure"
17:00:48 <Saizan> iirc it's something like: CFLAGS+="-I/usr/include/editline/ -L/lib/" cabal install readline
17:01:28 <Saizan> my autoconf-fu is weak though
17:04:23 * benmachine reckons CFLAGS= without the +
17:04:32 <benmachine> += is Makefile syntax
17:05:54 <Saizan> anyhow, it seems the configure script is useless, i can install readline with build-type: Simple.
17:06:10 <benmachine> *you* can :P
17:07:19 <Saizan> http://code.haskell.org/~Saizan/readline-1.0.1.1.tar.gz <- now you can too :)
17:08:39 <Saizan> int80_h: untar that package and run "cabal install --extra-include-dirs=/usr/include/editline --extra-lib-dirs=/lib" from within the directory, it should work!
17:12:23 <gs4> anyone ever run into a problem where they install a package via cabal (HXT) but then ghc(i) can't find it?
17:12:24 <int80_h> Saizan : w00t, it's working so far!
17:12:38 <Saizan> we should promote an "extra-libraries awareness day" were we crawl over hackage and remove useless configure scripts :)
17:13:01 <Saizan> gs4: what does "ghc-pkg list HXT" say?
17:13:25 <gs4> Saizan: haha it says there are broken packages :-/
17:13:46 <gs4> Saizan: should i reinstall the broken ones?
17:14:19 <Saizan> gs4: do you have two installations of the same version of the same package?
17:14:41 <gs4> Saizan: dont think so... im trying to reinstall what it says is missing, ill let you know what it says
17:15:04 <gs4> Saizan: nope, that didnt help at all, i'll pastebin the error, one sec
17:15:07 <Saizan> you could scan "ghc-pkg list" to tell
17:15:09 <int80_h> Saizan; it choked in a different place now
17:15:20 <int80_h> compiling dist/build/System/Console/Readline_hsc_make.c failed
17:15:28 <gs4> ghc-pkg list
17:15:35 <gs4> ill try that first, thanks
17:15:44 <gs4> Saizan: if i have dups, should i just kill the old ones?
17:15:49 <Saizan> int80_h: which error?
17:16:01 <int80_h> Saizan it's big I will pastebin it
17:16:37 <benmachine> gs4: it's not always that simple, because some stuff might have been built against the old ones
17:16:50 <benmachine> gs4: and not everything can be rebuilt against the new ones (e.g. core GHC packages)
17:17:12 <int80_h> Saizan: http://www.pastebin.org/355392
17:17:16 <Saizan> gs4: note that i've said "same version", however if by old you mean installed first, those are more likely to be dependencies of other packages you've installed
17:18:10 <gs4> benmachine: there is a user version installed and a global, and all the broken packages are global
17:18:25 <benmachine> hrrrm
17:18:38 <Saizan> gs4: can you paste ghc-pkg list somewhere?
17:18:39 <benmachine> ghc-pkg check should tell you why they are broken?
17:18:44 <gs4> binary and random are the "missing dependencies"
17:18:59 <gs4> even though both are installed globally (and as user, but i just got rid of the user ones)
17:19:10 <benmachine> hmm
17:19:12 <Saizan> int80_h: btw, where do you have readline.h on that system?
17:19:33 <benmachine> gs4: istr when I got this I reinstalled a bunch of stuff but couldn't get the dph libraries back
17:19:34 <Saizan> int80_h: and you might want to run it with -v to get more output
17:19:40 <benmachine> but that's fine because no-one uses dph anyway
17:19:51 <gs4> lol
17:20:08 <gs4> well, the real problem im having is that HXT cant been seen even though its installed
17:20:16 <gs4> Saizan: ill hpaste it, one sec
17:21:22 <gs4> ghc-pkg list: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26507#a26507
17:21:41 <int80_h> Saizan; I just verified that readline.h is in /usr/include/editline
17:24:30 <Saizan> int80_h: btw, i think i was too optimistic about removing the configure script, it's used to generate include/HsReadline.h which is imported by System/Console/Readline.hsc
17:25:07 <int80_h> Saizan : yeah it's complaining about hot being able to find alot of things, after I put in the -v flag
17:25:11 <int80_h> not
17:25:46 <int80_h> Saizan: readline has to be pretty common, and I noticed this has been encountered before. This problem has not been resolved?
17:26:27 <Saizan> int80_h: it's not so common, and in the past readline came with ghc so not many had to build it
17:26:51 <int80_h> ooooh!
17:27:55 <int80_h> Saizan: well thanks for your help. I'm going to pause for now.
17:28:30 <Saizan> i think the CFLAGS thing is the proper solution atm, but i don't remember the details.
17:28:57 <Saizan> gs4: why do you install so many things globally, and also some things root-local?
17:29:37 <Saizan> gs4: anyhow i'd try "cabal install hxt"
17:29:45 <gs4> Saizan: not sure about the root-local; as far as the globals... it just seemed like a good idea? no real reason though that i recall.. :P
17:30:26 <Saizan> it's not a very good idea because it's easier to break your installation that way :)
17:30:38 <gs4> Saizan: haha ok, fair enough :P
17:31:12 <gs4> Saizan: as user, cabal install hxt just tells me its already installed
17:31:23 <benmachine> --reinstall
17:31:32 <benmachine> perhaps
17:31:35 <Saizan> no, wait
17:31:35 <gs4> benmachine: done that a few times.. it has yet to help :P
17:31:43 <benmachine> --reinstall-twice
17:31:49 <Saizan> gs4: ghc-pkg check?
17:31:56 <Saizan> gs4: what does it say?
17:32:06 <monochrom> --reinstall is the cause of the problem in the first place, look at HTTP occuring twice, etc.
17:32:31 <Saizan> ah, i missed that one!
17:32:32 <lispy> Saizan: Is that really such a good test?  Doesn't cabal break that check as a normal part of it doing its job?
17:32:38 <Saizan> you've to unregister HTTP
17:32:49 <gs4> Ah, interesting, ill try that
17:33:00 <Saizan> lispy: ghc-pkg check catches some things.
17:33:05 <gs4> hpaste of ghc-check and install attempt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26508#a26508
17:33:43 <monochrom> Never --reinstall. Just asking for more trouble down the road.
17:33:49 <Saizan> monochrom: that isn't necessarily cause by --reinstall.
17:33:53 <Saizan> *caused
17:34:21 <gs4> Saizan: ok, HTTP is once under global once under user... its there are user because HXT needs user packages as deps
17:34:33 <Saizan> gs4: that's false
17:34:36 <gs4> Saizan: do you recommend i just install HXT globally and remove the local stuff (given hte rest of my stuff is global)?
17:34:47 <Saizan> gs4: an user installation can use global packages as deps.
17:34:50 <gs4> Saizan: so i should --force?
17:35:06 <gs4> Saizan: cabal disagrees with you, but seeing as its broken my system ill side with you if youre sure
17:35:18 <monochrom> You should nuke everything and install fresh.
17:35:38 <Saizan> gs4: ah, if you mean that the current HXT is installed against the user HTTP i can see that
17:35:48 <gs4> Saizan: yeah, exactly
17:36:07 <gs4> Saizan: i could remove both, and reinstall hxt.. if i do it as user will it just use the global one then?
17:36:36 <Saizan> gs4: if cabal installed a local HTTP when installing HXT it'll probably do that again.
17:37:02 <gs4> Saizan: I just remembered why so much stuff is global.. i wanted xmonad global so it'd be in usr/local/bin and whatnot.. hence all the xmonad deps, and after i probably just kept going :P
17:37:27 <gs4> Saizan: next time i set up ghc and friends ill just do it local though
17:37:40 <Saizan> that's because you upgraded some dependency of HTTP in the meanwhile, i bet, so cabal ends up building a fresh HTTP against those
17:37:53 <monochrom> global is fine. base is global. every user package depends on base. you never needed user base.
17:38:00 <Saizan> gs4: so, try unregistering the global HTTP
17:38:34 <monochrom> In any case once you get duplicate packages you're just stuck in a vicious cycle.
17:38:41 <gs4> Saizan: done
17:38:56 <lispy> I wonder how many of our cabal problems would be alleviated by having project specific dependencies instead of having them be in global and user (imagine a separate user cache of libraries per build tree)
17:38:59 <gs4> Saizan: ghc-pkg check still complains, but global HTTP is gone.. should i try that for any other dups?
17:39:16 <Saizan> gs4: are there others?
17:39:18 <monochrom> If you have duplicate packages, cabal will *ignore* all of them. Then cabal will just install them *moar* times.
17:39:37 <gs4> Saizan: looking now
17:39:45 <gs4> monochrom: haha ok
17:40:00 <monochrom> Cabal-1.8.0.2 and Cabal-1.8.0.6 will confuse cabal.
17:40:04 <Saizan> gs4: for some you want the global ones, if they came with ghc
17:40:07 <monochrom> hell, will confuse ghc too
17:40:10 <Saizan> monochrom: false.
17:40:44 <monochrom> http://www.haskell.org/cabal/FAQ.html#dependencies-conflict shows the problem.
17:40:45 <Saizan> you can have a whole bunch of Cabal installations there without a problem, if they have different versions.
17:41:15 <Saizan> monochrom: how is that relevant to Cabal-1.8.0.2 and Cabal-1.8.0.6?
17:41:22 <monochrom> Let C be Cabal.
17:42:17 <Saizan> the problem needs a B-1 installed both in the global and user db to arise.
17:42:21 <monochrom> There was a time you only had 1.8.0.2. You linked some packages against it. Then you added 1.8.0.6. Then you linked some other packages against that. Then you have a new package depending on both.
17:42:47 <Saizan> Then you have a new package depending on both. <- non-sequitur
17:43:23 <monochrom> well ok fine
17:43:49 <gs4> bam, got it... i just unregistered all the broken packages (dph and binary-shared), upon which apparently nothing depending
17:43:53 <gs4> now it works...
17:43:57 <gs4> quite strange
17:44:04 <gs4> thanks a lot for the help guys
17:44:09 <Saizan> np
17:46:25 <gs4> by teh way, random question, what PhD programs do you haskell folk tend to like / be part of? any in the U.S.? (doesn't have to be directly related to haskell, im just curious where the community is)
17:47:04 <bstamour> I use Haskell for my Masters work in Natural Language Processing.
17:47:07 <lispy> gs4: Yes, the US has quite a few places as does europe/uk
17:47:18 <lispy> gs4: unsw in .au is good too
17:47:22 <gs4> bstamour: where?
17:47:29 <bstamour> u of windsor, in Canada
17:47:29 <gs4> lispy: what places in the us are you thinking of?
17:47:33 <c_wraith> I wish I could pin down where in the ghc api rejects setting "hide-all-packages" dynamically
17:48:00 <lispy> gs4: I forget which schools specifically.  I went to Oregon State U. and my MS work was on darcs
17:48:01 <bstamour> Dr. Frost, our resident "natural languages" guy is a big fan of Haskell
17:48:05 <gwern> c_wraith: does what?
17:48:19 <lispy> gs4: portland state u. is also a good haskell place
17:48:24 <gs4> lispy: interesting, thats pretty awesome
17:48:52 <gs4> any on the east coast? :P
17:48:59 <lispy> gs4: I bet UIUC does haskell but I'm not sure
17:49:25 <vilhelm_s> gs4: The programming languages group at University of Pennsylvania (where I am) has several people interested in Haskell.
17:49:41 <lispy> gs4: it's usually better to identify faculty you want to work with and then learn about their universities
17:49:48 <gs4> vilhelm_s: oooh interesting, ill definitely check that out. which group?
17:50:00 <gs4> lispy: any suggestions on how to search then?
17:50:05 <gs4> *them
17:50:16 <lispy> gs4: and to identify faculty, I'd recommend looking at the authors of research that you enjoy
17:50:56 <vilhelm_s> gs4: The "PlClub". :) The faculty are Benjamin Pierce, Stephanie Weirich and Steve Zdancewic.
17:50:57 <gs4> lispy: ah. cant believe i didnt think of that lol. So for instance, look at big programming lang conferences and see what papers look cool, then work my way up?
17:50:59 <lispy> gs4: maybe start with ICFP proceedings and see who seems interesting
17:51:07 <lispy> gs4: yup
17:51:26 <gs4> lispy: Good thinking, thats one i might even make it to this year :P
17:51:44 <gs4> vilhelm_s: awesome, ill be sure to check them out, thanks a bunch :)
17:51:55 <lispy> boston has some haskell presence, IIRC
17:52:05 <lispy> Maybe MIT has some haskellers
17:53:05 <gs4> lispy: thatd be cool
17:53:56 <benmachine> I think I spoke to a MIT haskeller
17:55:22 * Hunner is PSU. There's a lot of haskell people here, students and profs
17:55:50 <Hunner> (Portland, not Penn)
17:56:19 * wli criesss
17:56:22 <gs4> Hunner: haha i made that mistake, thanks for thinking of it :P ill check em out
17:56:34 <lispy> yeah, PSU is a good place for this stuff
17:56:42 <lispy> You'll get exposed to more than _just_ Haskell too
17:57:04 <lispy> (Haskell is just the tip of the FP/FM iceberg)
17:57:07 <Hunner> Galois is here too, and does talks for classes :)
17:57:16 <gs4> ooh, nice :P
17:57:19 <Hunner> And ACM, and other things
17:57:34 <Hunner> One of PSU's profs is doing the Galois Tech Talk on the 29th (Tolmach)
17:57:50 <gs4> wow nice
17:58:27 <andrewsw> Hunner: what's the talk?
17:58:36 * lispy works at Galois
17:58:49 <gs4> lol
17:58:50 <Hunner> andrewsw: http://www.galois.com/blog/2010/06/23/tech-talk-towards-a-high-assurance-runtime-system-certified-garbage-collection/
17:58:51 <gs4> nice.
17:59:03 <lispy> oh yeah, that will be a cool talk
17:59:05 <andrewsw> Hunner: got it, thanks
17:59:12 * Hunner wouldn't mind working at galois, but I'm sure most people here wouldn't :)
17:59:19 <andrewsw> sorry I'll miss it. Moving to pdx July 11...
17:59:45 <lispy> There is also a strong open source community here in PDX
17:59:50 * wli is damned to Hell
17:59:52 <lispy> And there is also the pdxfunc group
17:59:55 <Hunner> There are talks once or twice a month on various topics. Just follow their twitter or blog
18:00:11 * andrewsw <3 pdx, I suspect
18:00:13 <gs4> hm.. so basically, portland is a cool place :P
18:00:14 * Hunner has class on monday nights, which is when pdxfunc is :(
18:00:15 <lispy> and we started putting the talks on vimeo
18:00:44 <lispy> http://vimeo.com/channels/galois
18:00:47 <andrewsw> lispy: excellent!
18:01:56 * lispy <3 PDX
18:05:18 <ddarius> lispy: Boston has a decent amount of Haskell presence and a significant amount of FP presence.
18:05:47 <gs4> ddarius: which schools?
18:06:07 <lispy> Well, they have edwardk so that contributes a lot of presence right there :)
18:06:22 <ddarius> gs4: MIT, Northeastern, Tufts
18:06:57 <Veinor> I know there are a couple FP guys at MIT ;)
18:07:12 <Veinor> wait, edwardk is in Boston too?
18:07:16 <ddarius> Yes.
18:07:40 <Veinor> didn't know that.
18:07:44 <Veinor> more confusion between him and ezyang!
18:08:12 <lispy> gs4: once you find faculty you want to work with, interview them, talk to grad students that work with them and at the university.  Check for cultural fit, happiness levels, enthusiasm, etc
18:08:53 <gs4> lispy: thanks a lot for all the advice :)
18:09:09 <lispy> gs4: np :)
18:10:04 * ddarius might go to ICFP this year.
18:10:12 <c_wraith> ok, I figured out why setting "-hide-all-packages" in hint doesn't do anything.  I think hint can work around that.
18:10:20 <gwern> why?
18:10:28 <gs4> ddarius: did you look at the icfp contest this year?
18:10:32 <c_wraith> it's got to do with internals of the ghc api
18:10:45 <ddarius> gs4: Not until after it started.  I don't really care for programming contests.
18:11:00 <c_wraith> And the fact that the -hide-all-packages flag only works when it's set the very first time initPackages is called internally
18:11:18 * lispy forgot about ICFP and spent the time his time with a lady friend :)
18:11:33 <c_wraith> Which is probably intentional, because using it with :set in ghci would be painful.
18:11:35 <gs4> haha lucky you
18:11:36 <lispy> If I had not forgotten about it, I would have tried to do the problems
18:11:53 <fnord123> for the logs, I'll say I found the fix. I need to call "initializeNativeTarget" before running any Jitted code
18:13:35 <c_wraith> having the ghc source local *really* helps track down these things. :)
18:14:50 <gwern> c_wraith: well, if you're doing anything complex with the ghc api and you don't have the ghc and hint sources handy, you're an idiot
18:15:43 <c_wraith> gwern: I tried to be an idiot!  I wish I could have succeeded! :)
18:16:00 <gwern> c_wraith: you must bleed on the cutting edge so someone may be an idiot some day!
18:17:31 <lispy> gwern: Your quotes seem especially morbid, you must be in a good mood :)
18:17:51 <gwern> lispy: ALL LIFE IS SUFFERING
18:18:11 <gwern> but actually yeah, I had a nice crab feast tonight. crabs are a real pain in the ass to eat, but they're tasty
18:18:19 <lispy> hehe
18:18:41 <gwern> as my great-grandfather always said, you can starve to death in front of a pile of crabs
18:18:57 <blackdog> lispy: you were kind of lucky missing out, then. genuine complexity is fine, but obfuscation is just a pain in the arse.
18:19:03 <aavogt> there are many types of crabs
18:19:13 <gwern> I'm sure
18:19:30 <lispy> blackdog: so much hubris!
18:19:33 <aavogt> I doubt they are all edible
18:19:42 <lispy> blackdog: er wait, you mean ICFP?
18:20:04 <blackdog> lispy: yes:)
18:20:10 <Saizan> c_wraith: do you by chance know where's the code that resolves module/package names to a specific installed package?
18:20:15 <lispy> blackdog: how is hurbris coming along?
18:20:31 <blackdog> lispy: got a heap of changes i haven't pushed yet
18:20:43 <blackdog> just got to sort them out in my copious free time
18:20:56 <c_wraith> Saizan: I found the code that loads all the package inventories, but I don't think that's the same code you're looking for.
18:20:59 <blackdog> mac os hubris should work with the next release of cabal
18:21:17 <gwern> aavogt: if you are morbdily curious, they were http://en.wikipedia.org/wiki/Blue_crab
18:21:39 * lispy really needs to learn the GHC source
18:22:10 <lispy> I'd like to get the GHC RTS running in the google NaCL and have the backend generating code for that too
18:22:27 <lispy> Not enough time for such projects I feer
18:22:29 <lispy> fear*
18:24:20 <gwern> that sounds like years' work
18:24:43 * lispy would also like to build a rogue-like on top of ogre3d, fix some darcs stuff, write a paper about delimited continuations and vcs, and ...
18:25:09 <lispy> Oh, right a nice email client that works like a wiki
18:25:10 <blackdog> lispy: don't forget the lady friend:)
18:25:21 <gwern> lispy: what? how would that work
18:25:25 <lispy> blackdog: going to leave to see her in about 5 minutes :)
18:25:47 <lispy> gwern: Well, I find always want to annotate emails after I've received it, and I would like to be able to bookmark messages
18:26:11 <lispy> gwern: currently, I sometimes reply to myself in the thread with my notes
18:26:28 <gwern> bookmark = just each email having an ID in the url, which gmail does; annotating...
18:26:34 <lispy> gwern: one idea I had was to modify something like thunderbird to feed messages into gitit
18:26:51 <lispy> gwern: Well, I want something I can use at work (eg., gmail won't cut it)
18:27:05 <gwern> lispy: I think it might be better to look into mailbox formats like mh and a new filestore backend
18:28:04 <lispy> gwern: I'll keep that in mind
18:28:27 <lispy> I'm actually quite happy with thunderbird 3 and I've been tihnking I should make an eDSL for generating XUL
18:28:36 <lispy> So that I can start modding it
18:28:40 * lispy out!
18:28:48 <gwern> all hail XUL
18:40:59 <c_wraith> Saizan, I think the code you're looking at is in compiler/main/Packages.lhs
18:41:05 <c_wraith> err, looking for
18:41:14 <c_wraith> take a look at mkPackageState
18:50:05 <Saizan> c_wraith: ah, yeah, that looks like it, thanks!
18:53:58 <EvanR> :t Num
18:53:58 <lambdabot> Not in scope: data constructor `Num'
18:54:17 <EvanR> a type constructor has no type?
18:54:30 <EvanR> er num isnt one
18:54:33 <EvanR> :t Maybe
18:54:34 <lambdabot> Not in scope: data constructor `Maybe'
18:56:22 <EvanR> :k Maybe
18:56:23 <lambdabot> * -> *
18:56:27 <EvanR> :k (,)
18:56:27 <lambdabot> * -> * -> *
18:56:48 <EvanR> :k (->)
18:56:49 <lambdabot> ?? -> ? -> *
18:56:54 <EvanR> o_O
19:00:52 <Saizan> ?? and ? are a GHC extension to deal with unboxed types
19:00:53 <lambdabot> Plugin `compose' failed with: Unknown command: ""
19:01:13 <EvanR> haha
19:01:57 <EvanR> what has kind (* -> *) -> *
19:02:07 <ddarius> :k Mu
19:02:08 <lambdabot> (* -> *) -> *
19:02:16 <EvanR> @src Mu
19:02:16 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
19:02:26 <EvanR> o_O
19:20:00 <Veinor> whoo!
19:20:05 <c_wraith> I wonder if hint's author is getting annoyed by my constant "this is broken" emails.  I included a patch in the most recent one.  That should count for something, right?
19:20:23 <gwern> no worse than I
19:22:17 <c_wraith> Hmm.  What ghc options should I be looking for, anyway?  I know -hide-all-packages, -package, and -X* are significant for the interpreter..
19:22:40 <c_wraith> Thinks like warning levels and optimization levels aren't significant.
19:22:58 <c_wraith> err, *things
19:23:37 <c_wraith> though -Werror could matter, and if I include it, I need the warning control flags.
19:24:53 <c_wraith> But from a high-level viewpoint, are there any other flags that significantly impact interpreter behavior that I should be looking for?
19:40:39 <gwern> Gracenotes: I like to say that C programmers know the cost of everything and the value of nothing; lisp programmers the value of everything and the cost of nothing; and haskellers know nothing
19:41:14 <Gracenotes> how about the type of everything
19:42:04 <gwern> not witty. even c is statically typed
19:42:45 <Gracenotes> eh, bits don't have types. just flavors.
19:53:40 <Lajla> gwern, I like to say to that we lisp programmers are generally better at all things than 
19:53:43 <Lajla> Haskell programmers
19:53:56 <Lajla> This includes hairstyling
19:54:01 <Lajla> Just look at Stalmman
19:54:07 <Lajla> Damned, he makes me unsure about my sexuality.
19:54:19 <gwern> what
19:54:43 <bremner> Lajla: like, whether you ever want to have sex at all?
19:55:04 <Lajla> I enjoy the confusion my sarcasm has wroth here.
19:55:05 <gwern> bremner: it
19:55:09 <gwern> 's funny, stallman is against kids
19:55:14 <gwern> and thus presumably sex
19:55:30 <Lajla> Stallman is actually in favour of abolishing the age of consent I read.
19:55:32 <Lajla> I can agree.
19:55:39 <Lajla> Free as in freedom
19:55:51 <Lajla> Ideailly, let's abolish types and bring back goto
19:55:53 <Lajla> Free as in freedom
19:56:00 <Lajla> the freedom to seriously screw up your code.
19:56:31 <Lajla> Continuation-passing-style Considered Freeer
20:01:15 <lhoersten> $ cabal install datetime
20:01:18 <lhoersten> Resolving dependencies...
20:01:20 <lhoersten> cabal: dependencies conflict: ghc-6.12.1 requires array ==0.3.0.1 however
20:01:22 <lhoersten> array-0.3.0.1 was excluded because ghc-6.12.1 requires array ==0.3.0.0
20:01:25 <lhoersten> anyone know how to fix that?
20:02:56 <gwern> lhoersten: I'd try cabal unpack datetime, and editing the cabal
20:03:33 <lhoersten> it doesn't depend on array =/
20:03:47 <gwern> if the .cabal isn't doing something strange, I'd then proceed very cautiously because the diamond dep problem is at its worst with core packages like ghc or array
20:03:48 <lhoersten> those are ghc conflicts
20:04:16 <lhoersten> i did a 'cabal update cabal-install' and this happened
20:06:08 <Saizan> you mean upgrade?
20:06:12 <lhoersten> yeah
20:06:24 <gwern> what
20:06:28 <gwern> cabal upgrade is supposed to be disabled
20:06:32 <Saizan> well, you should use upgrade at all
20:06:36 <Saizan> *shouldn't
20:06:45 <lhoersten> hmm
20:06:51 <lhoersten> damn - too late now
20:06:58 <lhoersten> that seems unsafe =
20:07:02 <lhoersten> =)
20:07:02 <gwern> yep
20:07:07 <Saizan> lhoersten: anyhow, this FAQ is for you http://www.haskell.org/cabal/FAQ.html#dependencies-conflict :)
20:07:13 <lhoersten>   upgrade      Upgrades installed packages to the latest available version
20:07:21 <lhoersten> they should say in the help "Don't use this!"
20:07:23 <gwern> it may be possible to repair the damage using ghc-pkg
20:07:33 <gwern> but maybe you ought to just reinstall ghc
20:07:51 <gwern> lhoersten: as I said, cabal upgrade is supposed to not even work, and print a warning when invoked 
20:08:00 <lhoersten> i installed it through aptitude I think
20:08:02 <lhoersten> ghc that is
20:08:19 <gwern> because of the diamond dep, and because cabal-install isn't smart enough to work around it
20:08:56 <Saizan> lhoersten: the ghc mentioned in the error is the ghc haskell lib, not the compiler itself
20:09:25 <lhoersten> what's that package name?
20:09:54 <Saizan> lhoersten: anyhow, long story short: check in ghc-pkg list for multiple installations of the same version of the same package, and ghc-pkg unregister until there's only one of them
20:11:27 <lhoersten> i just have one installed it seems
20:11:36 <lhoersten> though cabal
20:11:49 <lhoersten> though I have ghc installed through apt as well so i'm a bit confused about what this is
20:13:28 <Saizan> i'm not talking about the lib ghc itself, any other lib
20:13:39 <gwern> (see, this is why I avoid package managers for haskell stuff. it's just too hard to talk about or keep straight)
20:13:58 <Saizan> http://www.haskell.org/cabal/FAQ.html#dependencies-conflict <- as i said, read this FAQ, it's precisely covering your problem
20:14:48 <lhoersten> Saizan: ah i see - thanks
20:17:38 <lhoersten> Saizan: something this doesn't say is how to look for these overlapping packages
20:17:50 <lhoersten> it talks about user and global... i think I just have user installs
20:18:45 <Saizan> lhoersten: checked "ghc-pkg list" ?
20:18:57 <Saizan> it should give you two lists
20:19:06 <lhoersten> ah didn't know that was an option
20:19:09 <lhoersten> i see
20:23:38 <lhoersten> yeah I messed it up pretty bad =)
20:23:46 <lhoersten> can I just redo my user packages?
20:24:20 <Saizan> you can rm -fr ~/.ghc to forget about them
20:24:38 <lhoersten> k
20:24:42 <lhoersten> thank
20:25:02 <Saizan> np
20:25:12 <lhoersten> that was easy =) problem solved
20:25:41 <Saizan> one of the advantages of only doing user installs :)
20:25:49 <lhoersten> yeah totally
20:26:14 <lhoersten> how the hell did debian solve these problems? they definitely don't track ABIs
20:26:36 <monochrom> they don't "cabal upgrade cabal-install" either
20:27:35 <Saizan> well, debian ships binary packages, so each .deb identifies an unique ABI too
20:27:44 <lhoersten> ah good point
20:28:07 <lhoersten> these are all source packages huh?
20:28:13 <lhoersten> in cabal
20:28:19 <lhoersten> i guess gentoo then =)
20:28:36 <Saizan> hackage gives you source packages, they get built on your machine
20:28:47 <monochrom> "cabal install hahaha" builds from source
20:29:32 <monochrom> whereas deb packages are made to be consistent with each other
20:29:40 <Saizan> however debian just avoids multiple installations of the same package i believe, it doesn't even allow different versions to coexist
20:30:14 <lhoersten> it does if they have the version number in the package name
20:30:18 <lhoersten> the kernel for example
20:30:20 <Saizan> btw, it seems ghc can actually do the right thing about these multiple installations if instructed correctly
20:30:30 <monochrom> uniqueness and chastity solves all problems
20:31:18 <lhoersten> Saizan: anyway I've restored everything now - thanks for your help
20:31:27 <Saizan> np
20:32:15 <Saizan> it's just annoying that it does the shadowing up front, before looking at which packages your source actually needs
20:32:52 <lhoersten> yeah sounds like they are working on it though
20:33:14 <Saizan> which will be mostly a problem for ghci, since for cabal-install installations Cabal can be modified to actually give proper instructions
20:33:46 <lhoersten> interesting
20:33:50 <lhoersten> where are you reading this?
20:34:11 <monochrom> this is becoming alarming. every day 3 people come in to ask this.
20:34:18 <Saizan> i'm writing this right now after having checked ghc's and Cabal's source :)
20:35:38 <Saizan> i guess we'd need to at least modify ghci to give a better error message rather than "module Foo not found", or we could make cabal-install refuse to put you in such a situation..
20:36:01 <lhoersten> that'd be nice =)
20:36:36 <gwern> monochrom: diamond dep is one of the singlest biggest flaws in cabal; it's no surprise that as it becomes used on a widescale and on a timescale where people upgrade stuff that it would manifest more
20:36:37 * Saizan needs to talk do dcoutts
20:37:20 <Saizan> the diamond dep problem is actually another thing.
20:37:22 <Rotaerk> I read that as "donuts"
20:37:28 <lhoersten> i actually knew it was a problem to use but forgot and did it anyway =/
20:37:33 <lhoersten> then I knew a screwed myself
20:38:53 <Saizan> heh
20:39:11 <monochrom> I guess the plan is to measure Haskell success by counting package db corruption problems per day.
20:39:39 <gwern> monochrom: we need a more marketable name than that
20:40:21 <gwern> perhaps 'pdb', pronounced 'peebeebies' - as in, 'haskell does 100k peebeebies more than factor!'
20:40:51 <monochrom> "under the guiding hands of shapr, #haskell has grown to 100 cabal panics per day. we are now just second to #ubuntu, which is 150 kernel panics per day."
20:41:47 <gwern> (peace be upon him)
20:42:52 <gwern> doesn't 'shapr' sound like a god from a bad mythology? 'And then shapr moved upon the waters and shaped all the things in their pairs and loosed them to feed and multiply'
20:55:46 <dons> gwern: is diamond dep a flaw? it seems inevitable. we're the only build systems that  tries to install more than one version of things...
20:55:59 <dons> we could just rule out anything but the latest stable. that would be fun.
20:57:00 <c_wraith> that must include the latest stable version of ghc
20:58:33 <orlandu63> @src subsequence
20:58:34 <lambdabot> Source not found. It can only be attributed to human error.
21:00:41 <Saizan> you could be smarter about which dependencies actually matter for the diamond, but those are muddy waters considering that symbols from C libs aren't versioned
21:07:04 <Mathnerd314> @pl \f -> until ((==) <*> f) f -- my current favorite higher-order function
21:07:04 <lambdabot> until =<< ((==) <*>)
21:07:27 <Mathnerd314> ^ now twice as confusing
21:13:49 <Saizan> too bad until is not an operator
21:14:20 <Mathnerd314> how would that help?
21:15:25 <Saizan> the pl version would look more like ascii art
21:34:11 <enferex> I need a routine that String -> [Char]
21:34:38 <tensorpudding> > id :: String -> [Char]
21:34:38 <lambdabot>   Overlapping instances for GHC.Show.Show
21:34:39 <lambdabot>                              (GHC.B...
21:34:43 <tensorpudding> err
21:34:55 <tensorpudding> > (id :: String -> [Char]) "this"
21:34:56 <lambdabot>   "this"
21:35:31 <tensorpudding> String and [Char] are the same thing
21:38:33 <enferex> tensorpudding: Ahh yes
21:38:37 <enferex> tensorpudding: Thanks
21:53:44 <ManateeLazyCat> I'm looking for neat solution for my "one to multiple" idea. Example X is share state, A, B, C is listener, when X's state change, it will send message to A, B, C for update. So any suggestion?
21:54:19 <ManateeLazyCat> Not like MVar, once A get value, B, C can't update.
21:54:36 <ManateeLazyCat> I want A, B, C will update synchronous when X change.
21:56:41 <ManateeLazyCat> I can build hook list like [A,B,C], when X state change, do a *for* loop for [A,B,C], but i wonder have better solution that don't need [A,B,C]
21:59:31 <siracusa> ManateeLazyCat: A, B, C are different threads?
21:59:32 <ManateeLazyCat> All sleep?
21:59:44 <Saizan> ManateeLazyCat: seen Chan and dupChan?
22:00:17 <siracusa> ManateeLazyCat: Yeah, would also be my suggestion, use a Chan.
22:00:49 <ManateeLazyCat> siracusa: I want looking for a *mechanism* to trigger listener update and don't need add listener to list manually.
22:01:09 <ManateeLazyCat> Saizan: siracusa Thanks, i will try it. :)
22:02:08 <ManateeLazyCat> siracusa: A,B,C, can same threads or different threads with X.
22:02:17 <ManateeLazyCat> siracusa: And different threads is okay.
22:04:40 <ManateeLazyCat> I'm build a "Buffer-to-MultipleView" server/client framework, Buffer is share state and have multiple view listen buffer state and update itself.
22:16:42 * ManateeLazyCat Hmm, dupChan is i want, a broadcast channel....
22:17:46 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26509#a26509  my good-code-inator broke.  Someone make that a lot less dumb for me, please.
22:18:48 <BMeph> c_wraith: Sure thing, but first, you must pay the troll^W toll... ;)
22:19:08 * c_wraith offers some trollhouse cookies
22:19:34 <c_wraith> It works, but it's the least-elegant code I've written in weeks.
22:20:36 <c_wraith> :t groupBy
22:20:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
22:20:52 <c_wraith> So close...
22:23:37 <c_wraith> @hoogle splitOn
22:23:37 <lambdabot> No results found
22:24:31 <c_wraith> I could do it with splitWhen from the split package
22:25:07 <c_wraith> Oh, it drops the element in question.  it wouldn't work either
22:27:21 <siracusa> > groupBy (\_ s -> not $ "-" `isPrefixOf` s) ["-a", "b", "-c", "d", "", "-e", "f"]
22:27:22 <lambdabot>   [["-a","b"],["-c","d",""],["-e","f"]]
22:27:35 <siracusa> c_wraith: Isn't that what you want?
22:27:50 <siracusa> + intersperse " "
22:28:27 <c_wraith> oh.  I was totally overthinking things
22:28:31 <c_wraith> Yes, it's what I want.
22:28:42 <c_wraith> I told you, my good-code-inator is worn out for the day.
22:31:08 <siracusa> > map (intercalate " " . filter (/="")) $ groupBy (\_ s -> not $ "-" `isPrefixOf` s) ["-a", "", "b", "-c", "d", "", "-e", "f"]
22:31:08 <lambdabot>   ["-a b","-c d","-e f"]
22:52:03 <Axman6> > map (intercalate " " . filter (/="")) $ groupBy (\_ s -> not $ "-" `isPrefixOf` s) ["-a", "b", "c","-d","f"]
22:52:04 <lambdabot>   ["-a b c","-d f"]
22:52:04 <lambdabot> Axman6: You have 4 new messages. '/msg lambdabot @messages' to read them.
23:11:01 <SailorReality> http://ca.news.yahoo.com/s/capress/100622/world/eu_vatican_archaeology look at this dick, writing an article about a painting without giving a picture of the painting
23:11:12 <SailorReality> the fuck would I want to read his description of it for
23:11:24 <SailorReality> whoops wrong channel
23:14:56 <malc_> I'm under impression that it's possible to leave a message here, perhaps someone could enlighten me as to how?
23:15:20 <jbapple> @tell malc_ like this
23:15:21 <lambdabot> Consider it noted.
23:16:52 <malc_> jbapple: thank you
23:16:53 <lambdabot> malc_: You have 1 new message. '/msg lambdabot @messages' to read it.
23:25:59 <Twey> malc_: See also /msg memoserv help
23:27:03 <malc_> Twey: thanks
23:36:37 <foldawesome> hey #haskell. I'm on ghc 6.12.1 and when I compile some code with "import Foldable" ghc says it can't find the module. Was Foldable deprecated or something?
23:37:51 <Twey> foldawesome: It's in Data.Foldable
23:38:24 <foldawesome> Twey, thanks.
