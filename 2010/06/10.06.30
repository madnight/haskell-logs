00:00:06 <cheater99> kmc: i'd like it released early and polished already!
00:00:11 <cheater99> dons: IHG?
00:00:12 <kmc> and i'd like a pony
00:00:13 <dons> which says: polish that stuff so we can use it.
00:00:17 <kmc> luckily, it's on hackage
00:00:27 <dons> industrial haskell group, commercial sponsors
00:00:28 <kmc> it's possible that many of these prototypes simply wouldn't be released at all in the COBOL world
00:00:32 <cheater99> dons: yes
00:01:02 <cheater99> dons: if there's one thing that drupal did well it is actually coopting third party developers into Getting Shit Done
00:01:26 <dons> well, co-opting some individuals
00:01:30 <cheater99> you should check out their hackathons, 'dev experience' projects, etc.
00:01:36 <kmc> cheater99, i think the biggest problem here is in identifying what's good versus what's bad, old, bitrotten, incomplete, etc.
00:01:48 <kmc> there is some current work towards improving hackage to assess such things
00:02:02 <cheater99> kmc: that's a level even higher than that
00:02:23 <cheater99> before it can be considered good or bad and rotten or not, it has to actually start doing what it's supposed to
00:02:35 <cheater99> software that's in 0.2.1 stage isn't that
00:02:48 <kmc> so it shouldn't be uploaded at all?
00:03:02 <kmc> i think there's an idea that the code might be useful to someone, even if it's not finished
00:03:04 <cheater99> you're jumping from one extreme to the other
00:03:07 <kmc> i think you'll find that throughout the open-source world
00:03:09 <cheater99> don't be so bipolar
00:03:34 <c_wraith> eh.  0.2.1 actually tends to mean several versions in, on hackage.
00:03:34 <kmc> cheater99, so then you think that "prototypes", whatever that means, should be uploaded, but to a separate category?
00:03:46 <c_wraith> That's quite a lot more advanced than a lot of packages.
00:03:47 <cheater99> you're arguing against points i have never made
00:04:05 <kmc> well i said hackage would soon assess quality
00:04:16 <kmc> and you said "before [that], it has to actually start doing what it's supposed to"
00:04:28 <kmc> which i took to mean you thought prototypes shouldn't be on hackage at all
00:04:33 <kmc> but i can see how i may have misinterpreted
00:05:37 <blackdog> c_wraith: heh, i'm still on 0.0.2 for hubris. maybe i should make a slightly bigger jump in the next release...
00:05:45 <cheater99> no, i was just expressing that there's no point categorizing stuff as good/bad/old if it doesn't work in the first place
00:05:50 <cheater99> it's a futile effort
00:06:02 <kmc> cheater99, "work in the first place" is a relative judgement of course
00:06:03 <cheater99> like categorizing trainwrecks by paint color
00:06:27 <cheater99> sure, you can do that
00:06:34 <kmc> it might work for my purpose and not yours
00:06:41 <kmc> it might work with a small or large amount of modification
00:06:43 <cheater99> but how many people looking at a trainwreck are actually interested if the train was red or blue??
00:06:49 <kmc> your analogy sucks
00:07:26 <kmc> i don't think Hackage is drowning in code which is completely of no value to anyone
00:07:32 <cheater99> i feel a big lack of business perspective on software products in your point of view, kmc
00:07:41 <kmc> most of it does build or did build on some ghc version
00:07:55 <kmc> now if you want to argue for a "display only packages which build on current ghc" option
00:08:01 <kmc> then this is pretty clearly a good idea
00:08:24 <kmc> cheater99, ;P
00:08:26 <cheater99> 'it builds on ghc' does in no way define something of business value at all, i'm not even sure why you bring that up
00:08:31 * hackagebot appar 0.1.1 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.1 (KazuYamamoto)
00:08:48 <cheater99> 'it does exactly what its feature list says' is one
00:08:53 <kmc> hahahaha
00:08:55 <cheater99> way
00:08:59 <kmc> name one software package that does exactly what its feature list says
00:09:07 <kmc> maybe /bin/true
00:09:08 <cheater99> drupal does
00:09:12 <kmc> true - do nothing, successfully
00:09:20 <kmc> yes, drupal is bug free
00:09:43 <blackdog> kmc: CPAN testers is interesting that way - you get a decent amount of feedback about bitrottedness etc
00:09:44 <kmc> cheater99, i missed the part where we went from "works at all" to "business value"
00:09:56 <kmc> yeah
00:10:11 <kmc> there's a SoC going on now about integrating testing into Cabal and i assume we'll see automated test running on hackage at some point
00:10:17 <cheater99> you're riding your high horse and yet there are currently several hundred active drupal developers in london, each earning good money and contributing to the project
00:10:31 <cheater99> there are probably two active haskell developers
00:10:36 <kmc> haha
00:10:43 <kmc> ok, you really are just trolling
00:10:56 <Veinor> it's true
00:11:00 <Veinor> I'm 317 of the people in this channel
00:11:04 <Veinor> kmc is the other 317
00:11:06 <kmc> yeah
00:11:10 <kmc> the rest of you are sock puppets
00:11:12 <Veinor> the question is... which one of us is you? :O
00:11:15 <cheater99> no, i'm just talking about what i feel is missing in the haskell world
00:11:25 <cheater99> you can be in denial, that's your choice
00:11:31 <cheater99> but that does not fix my problem
00:11:34 <kmc> haha
00:11:36 <blackdog> kmc: yeah. your knuckles are starting to hurt, btw
00:11:46 <kmc> yeah you're just telling the hard truth like it is ;P
00:12:05 <kmc> actually i like false better
00:12:09 <kmc> "do nothing, unsuccessfully"
00:12:11 <cheater99> i think you have some sort of issue that makes you look at this conversation like some sort of competition
00:12:27 <Veinor> actually /bin/false is /bin/true
00:12:30 <dolio> There are more than two Haskell developers at Galois alone.
00:12:51 <dons> yow
00:12:51 <cheater99> dolio: that is very good to know
00:13:02 <blackdog> dons: are you subbing for shapr?
00:13:15 <dons> well, there's like 40 of us @ galois, its ridiculous.
00:13:37 <cheater99> you're in london dons?
00:13:47 <kmc> cheater99, btw i'm currently being paid to work on ghc
00:13:52 <dons> no, usa.
00:13:57 <kmc> so hearing that i am one of two people in the world with this status is a bit amusing
00:14:08 <dolio> Also, since GHC is written in Haskell, there are more than two developers merely measuring people who work on it.
00:14:12 <cheater99> how does the predicate 'in london' apply to Galois then?
00:14:17 <dons> kmc: paid, awesome!
00:14:22 <kmc> of course you're right that there aren't many Haskell developers compared to Java developers
00:14:23 <dons> expecting mega patches now
00:14:27 <cheater99> kmc: are you in london?
00:14:28 <kmc> oh no :O
00:14:30 <kmc> cheater99, nope
00:14:38 <cheater99> kmc: then why are you trolling?
00:14:50 * cheater99 shrugs
00:14:52 <kmc> but when you go from "not many" to "probably two" is when you go from observation to trolling
00:15:05 <cheater99> have you even read the whole sentence?
00:15:26 <kmc> oh you meant to apply "in london" to it?
00:15:34 <cheater99> it actually ended in a predicate that defined a small, closed geographical area
00:15:36 <kmc> that is not at all clear
00:15:49 <cheater99> that someone like me can have some insight into
00:15:51 <kmc> why should i care how many haskell developers are in london?
00:15:55 <cheater99> i do
00:16:00 <cheater99> that's good enough for me to talk about it
00:16:05 <kmc> ok
00:16:07 <kmc> but not me
00:16:09 <kmc> so, i'll ttyl
00:16:11 <dons> there's a bunch, thanks to barcap and std. chartered 
00:16:31 <cheater99> dons: what are those?
00:16:39 <dons> banks that use haskell
00:16:42 <dons> in london.
00:16:48 <cheater99> dons: ah
00:16:49 <adu> oh, that reminds me, i'll be in Japan for a month, shall I do some Haskell evanjelism while I'm there?
00:17:03 <dons> adu: go to the tokyo haskell group
00:17:08 <blackdog> adu: they probably don't need it, they're hell of keen:)
00:17:08 <cheater99> go do that
00:17:18 <blackdog> think curt sampson and kazu yamamoto are there
00:17:24 <dons> yup
00:17:27 <adu> ok, I'm not sure where that is, but i'll try and find it
00:17:31 <cheater99> dons: well, see very little movement in the job market for haskell. i tell every recruiter that calls me about it and they'd never even heard of it.
00:17:36 <cheater99> *i see
00:17:49 <dons> you're not getting calls weekly?
00:17:52 <kmc> japan has Tsuru Capital and Starling Software
00:17:55 <cheater99> no
00:17:56 <kmc> the latter might have shut down?
00:18:02 <cheater99> i'm not even getting calls yearly
00:18:08 <dons> maybe not visible enough in the haskell world yet
00:18:17 <kmc> says the most visible of them all
00:18:21 <dons> talk on haskell-cafe@ some more.
00:18:47 <dons> a bunch of recruites follow -cafe@
00:18:48 <cheater99> dons: my problem is that comparing that to a shitty tech like drupal i get about 1/500 the phonecalls
00:18:57 <cheater99> i'm subbed to cafe
00:18:59 <dons> its worth responding there, with good answers
00:19:05 <cheater99> i should start talking there
00:19:17 <kmc> dons, do they follow SO as well?
00:19:19 <dons> if you don't, no one knows your skilss
00:19:21 <adu> i talk here
00:19:33 <dons> kmc: i've had a couple of talk offers from SO, but no jobs
00:19:34 * hackagebot iproute 1.0.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.0.0 (KazuYamamoto)
00:19:43 <dons> job offers have all been via -cafe@
00:19:49 <cheater99> dons: either way, i hope you see what i mean with that comparison
00:20:12 <dons> cheater99: there's jobs, but you need to be recognized as a haskell programmer.
00:20:23 <dons> libs on hackage, answers on -cafe@
00:20:31 <cheater99> i'm still at the 'reading tutorials' stage with haskell
00:20:33 <sbpaul> there are jobs?
00:20:45 <cheater99> but i'm sure i'll have some libs shortly for something small and nice
00:20:46 <sbpaul> there was haskell at my last job
00:20:54 <kmc> imo the best way to get a haskell job is to start your own company
00:20:57 <sbpaul> but my boss thought it was a character from "leave it to beaver"
00:21:03 <cheater99> i have my own company.
00:21:05 <cheater99> i'm a contractor.
00:21:16 <wli> The economy may not be conducive to much.
00:21:59 <kmc> unemployment is a lagging indicator relative to venture capital availability
00:22:10 <cheater99> there are 919 letters in my haskell cafe folder.
00:22:34 <cheater99> so many options, so little time.
00:23:42 <adu> kmc: are you saying unemployment _causes_ venture capital?
00:24:18 <blackdog> makes more sense if you sub "employment"
00:24:57 <kmc> adu, er, no, not in particular
00:25:04 <adu> i think it makes more sense to say that VC cuases a decrease in unemployment
00:25:13 <kmc> i didn't say anything about "cause"
00:25:14 <adu> perhaps delayed
00:25:20 <kmc> correlation != causation
00:25:28 <kmc> i said that one economic indicator would tend to recover before another
00:26:19 <sbpaul> umm
00:26:22 <sbpaul> what's the claim here
00:26:24 <adu> by "cause" i meant to say "come before" which I gather is what you meant by "lagging indicator" I just didn't understand which one you meant came first
00:26:35 <sbpaul> unemployment does not cause venture capital
00:26:42 <blackdog> i think perhaps we have the same as the lisp problem. paul graham can build a kickarse online store in lisp, and make a bunch of money, but still not affect the job market much.
00:26:42 <sbpaul> a lack of productivity decreases general capital
00:26:46 <sbpaul> which decreases available funds for investment
00:26:57 <kmc> i meant that VC availability would come before decreased unemployment.  i didn't make any claim about causation or mechanism
00:27:04 <kmc> they're both related to a hell of a lot of other things
00:27:08 <adu> oh ok
00:27:12 <kmc> and i don't expect a direct causal relationship
00:27:55 <adu> i'm bad with words
00:28:05 <kmc> i may have also used the term "lagging indicator" incorrectly
00:28:16 <adu> :)
00:30:03 <sbpaul> the deployment of venture capital on the other hand
00:30:06 <sbpaul> increases employment
00:30:21 <sbpaul> for obvious reasons
00:30:28 <adu> yes
00:31:32 <cheater99> dons: are there any stats for how much people using haskell make?
00:31:32 <kmc> after some time
00:31:51 <kmc> when the economy starts to recover, does money go to established companies, which are ready to hire immediately, or to new ventures?
00:31:54 <sbpaul> there are cheater99 
00:32:01 <sbpaul> one said 125
00:32:03 <sbpaul> the other 200
00:32:11 <sbpaul> or something close to that
00:32:25 <kmc> http://www.haskell.org/pipermail/haskell-cafe/2010-May/077630.html
00:32:30 <kmc> "Annual compensation will be in the region of USD150k with potential for growth."
00:32:31 <cheater99> 125 what?
00:32:34 <sbpaul> K
00:32:39 <cheater99> k what?
00:32:46 <kmc> kthousand
00:32:51 <adu> lol
00:33:02 <kmc> "finance vs. non-finance" will make a much bigger difference than language
00:33:07 <sbpaul> yes
00:33:08 <aavogt> sample sizes, what are the other qualifications there?
00:33:24 <adu> US $150,000
00:33:38 <kmc> on that note, http://www.youtube.com/watch?v=u6XAPnuFjJc
00:33:53 <cheater99> i can do finance ez
00:33:56 * cheater99 studied maffs
00:34:09 <kmc> the finance industry is not a happy place for technology, unless you really care about money
00:34:09 <sbpaul> http://www.indeed.com/salary?q1=haskell%20programmer&l1=&tm=1 according to this
00:34:10 <wli> Probably most of the differences in economic outlook will boil down to ideology and the economic theories/etc. that go with it.
00:34:12 <sbpaul> haskell programmers make 1
00:34:31 <cheater99> yeah, i just care about money :)
00:34:37 * hackagebot dns 0.1.0 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.1.0 (KazuYamamoto)
00:34:51 <kmc> if you just care about money, you should make haskell your hobby and only that
00:35:02 <sbpaul> money is worthless
00:35:03 <kmc> it's not the easy route to the big bux
00:35:05 <sbpaul> scraps of paper
00:35:09 <kmc> money is a sign of poverty
00:35:09 <sbpaul> that make people do things for you
00:35:17 <ivanm> sbpaul: that has symbolism and a relative meaning in society
00:35:18 <sbpaul> money is a sign of spiritual poverty
00:35:36 <ivanm> ...
00:35:38 <wli> I did an undergrad in math but there are a bunch of advanced topics I can get nowhere with, Malliavin calculus and stochastic differential equations in particular.
00:35:38 * hackagebot multiset-comb 0.2.1 - Combinatorial algorithms over multisets  http://hackage.haskell.org/package/multiset-comb-0.2.1 (BrentYorgey)
00:35:40 <ivanm> I fail to see the correlation
00:35:45 <ivanm> besides, this is -blah territory
00:35:46 <sbpaul> i'm sure you do
00:36:26 <sbpaul> ivanm
00:36:33 <sbpaul> have you ever made a song with water and wine glasses
00:36:41 <sbpaul> you should try it
00:36:43 <ivanm> nope
00:36:47 <ivanm> got better things to do
00:36:53 <sbpaul> better by what metric
00:36:55 <ivanm> (besides, I could never do that trick right)
00:37:03 <ivanm> i.e. things I actually want to do
00:37:11 <sbpaul> based on what
00:37:17 <ivanm> the fact that I want to do them
00:37:22 <sbpaul> that's tautological
00:37:30 <ivanm> not at all
00:37:33 <sbpaul> what makes you derive pleasure from them
00:37:36 <sbpaul> specifically
00:37:48 <ivanm> depends upon which exact thing you're talking about
00:37:55 <sbpaul> not really
00:38:01 <ivanm> besides, we're in a drought here, we shouldn't be wasting water
00:38:07 <wli> Finance seems to involve numerical methods for SDE's and Malliavin calculus problems, so I'm probably out of that game unless I somehow learn it.
00:38:32 <ivanm> besides, I fail to see what wasting water and utilising glassware has to do with spiritual poverty and wealth
00:38:34 <kmc> the software engineering i did in finance did not involve any fancy math
00:38:50 <sbpaul> you might learn someday ivanm
00:38:51 <kmc> it involved low-level networking code, converting between protocols quickly, stuff like that
00:38:54 <Stoneage> in finance you use a lot of maths if you work as a quant
00:39:06 <sbpaul> art is like climbing up an infinite mountain
00:39:10 <Stoneage> software engineers usually don't need fancy stuff
00:39:11 <sbpaul> and you leave a flag there
00:39:15 <sbpaul> to tell people that this is where you were
00:39:18 <sbpaul> where you decided to go
00:39:26 <Stoneage> but quants get more money :)
00:39:31 <ivanm> sbpaul: O..K...
00:39:35 <sbpaul> and then you die
00:39:56 <sbpaul> np: Jordaan Mason - Housewife Part Two
00:39:57 <wli> Hmm, I'm not very up on network protocols but I think that's mostly from lack of trying/etc.
00:40:33 <wli> Somehow I was under the impression coder grunts were being put to the task of numerical analysis.
00:40:39 * hackagebot domain-auth 0.1.0 - Domain authentication library  http://hackage.haskell.org/package/domain-auth-0.1.0 (KazuYamamoto)
00:40:52 <ivanm> first of all, by "spiritual poverty" I thought you were referring to religion
00:40:57 <ivanm> not to "art"
00:40:57 <sbpaul> fuck no
00:41:15 <sbpaul> no, art is a product of 'spirituality'
00:41:18 <sbpaul> sensual understanding
00:41:34 <Stoneage> wli: it depends, let's say that the more maths you know, the less limited you will be in your job
00:41:55 <Stoneage> wli: and the fancy parts do include an awful lot of stochastic calculus
00:42:41 <ivanm> sbpaul: so, because I don't habitually go and put water into glassware and try to make music from it I am thus "spiritually poor"?
00:42:44 <ClaudiusMaximus> i made a zooming fractal thing in haskell instead of sleeping last night.. http://claudiusmaximus.goto10.org/g/julia/mandeljulia_b07.png (haskell+opengl with ffi to a small julia renderer in C)
00:42:49 <sbpaul> that's just an example ivanm
00:43:13 <ivanm> ClaudiusMaximus: cool
00:43:21 <ivanm> ClaudiusMaximus: next time, sleep might be better though :p
00:43:40 * hackagebot species 0.3.0.1 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.0.1 (BrentYorgey)
00:43:41 <ClaudiusMaximus> ivanm: yes, it would :)
00:44:58 <adu> kmc: that was really good
00:46:27 <kmc> ?
00:46:38 <sbpaul> ivanm: http://www.youtube.com/watch?v=wW-Gc3Duq3k <-- shitty performance, brilliant song
00:47:41 <adu> sbpaul: are you Yoda?
00:47:46 <sbpaul> yes
00:47:54 <adu> :) i knew it
00:48:21 <kmc> adu, oh, you meant the video?
00:48:32 <adu> kmc: yes
00:49:04 <kmc> yeah, i enjoyed it a lot
00:49:15 <kmc> interesting topic + cute animation
00:49:27 <adu> it makes me actually proud to work at radioshack
00:49:41 <kmc> haha
00:49:45 <kmc> explain?
00:50:01 <adu> cuz i can do Haskell for fun when i get home
00:51:07 <adu> but anyways, its not for long
00:51:17 <adu> i already put in my 2 weeks notice
00:51:50 <adu> then i got 3 days free, then 4 weeks in Japan
00:53:07 <cheater99> what does the bang sign here do?  let !(prefix, suffix) = makeTwoLists 'a'
00:53:20 <kmc> that's the BangPatterns extension
00:53:25 <kmc> makes it a strict binding
00:53:46 <kmc> «let !p = e in b» is roughly equivalent to «let x@p = e in x `seq` b», for a fresh variable x
00:54:00 <kmc> it means that when the body of the let is forced, this binding will be forced first
00:54:18 <kmc> (not exactly the same meaning as a ! buried deeper within a pattern)
00:54:49 <sbpaul> who wants to have their mind blown
00:55:07 <cheater99> i don't know what @ does
00:55:12 <cheater99> what does @ do?
00:55:18 <sbpaul> cheater99: this http://omploader.org/vNHNqNw
00:55:29 <kmc> «x@p» matches anything that p would match, and also binds the whole thing matched to x
00:55:39 <kmc> x is a var, p is any pattern
00:56:04 <cheater99> ah
00:56:14 <kmc> useful to avoid re-building the thing you took apart
00:56:21 <kmc> (both in terms of syntax and runtime performance)
00:56:28 <cheater99> so x @ ( Int ) for example?
00:56:50 <cheater99> if i want to match an int
00:56:59 <adu> cheater99: have you used lisp?
00:57:03 <kmc> no
00:57:04 <cheater99> nope
00:57:12 <cheater99> why?
00:57:15 <kmc> > let x@(Just y) = Just 3 in (x, y)
00:57:16 <lambdabot>   (Just 3,3)
00:57:17 <kmc> cheater99, ^^^
00:57:21 <adu> cheater99: have you use the c preproc (cpp)?
00:57:29 <cheater99> a tiny little bit
00:57:34 <cheater99> but not too much.
00:58:05 <adu> so f x = treats "x" as a variable, f 2 = ... matches a constant, f x@2 = is like both cases
00:58:15 <cheater99> ah ok
00:58:26 <cheater99> so that's strictly for pattern matching?
00:58:39 <kmc> this @ is part of the grammar of patterns
00:58:39 <cheater99> and to the right of @ i need an actual value?
00:58:43 <kmc> no
00:58:45 <adu> yes x@2 is like a little tiny #define x 2
00:58:51 <kmc> err
00:58:55 <kmc> i'm not sure that's a useful way to think of it
00:59:01 <kmc> the syntax is x@p
00:59:06 <kmc> x is a variable, p is any pattern
00:59:09 <cheater99> me either, but i got what adu meant with the previous examples
00:59:12 <kmc> then x@p is also a pattern
00:59:15 <adu> maybe not, but then again, monads _are_ like burritos :)
00:59:22 <kmc> > let x@y = 3 in (x, y)
00:59:23 <lambdabot>   (3,3)
00:59:25 <kmc> valid, but useless ;)
01:02:38 <cheater99> thx
01:02:49 <adu> yw
01:05:24 <cheater99> hey, is it possible to request cafe to send me messages from a certain time?
01:05:51 <kmc> @google haskell-cafe archives
01:05:53 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
01:05:53 <lambdabot> Title: Haskell-Cafe Info Page
01:05:59 <cheater99> i mean in my inbox
01:06:05 <roboshibby> re
01:06:18 <roboshibby> does haskell have basic control structures like if/else ?
01:06:45 <ivanm> yes
01:06:51 <ivanm> if ... then ... else ...
01:07:08 <kmc> it's not really a control structure
01:07:24 <kmc> Haskell's basic control structure is the function
01:07:25 <cheater99> what is it then?
01:07:34 <kmc> it's an expression
01:07:38 <wli> case statements (if/then/else is case on Bool)
01:07:58 <kmc> :t let if' False x y = y; if' True x y = x in if'
01:07:59 <lambdabot> forall t. Bool -> t -> t -> t
01:08:10 <kmc> roboshibby, "if then else" is in Haskell, but it's a dumb special case which imo should not be there
01:08:15 <kmc> it could be an ordinary function in the std lib
01:08:48 <roboshibby> is haskell like the language io ?
01:08:57 <adu> no
01:09:12 <adu> io is extremely oo
01:09:17 <adu> haskell is purely fp
01:09:37 * ivanm thought roboshibby already knew Haskell, since he's been here often enough before...
01:09:38 <kmc> oo and fp are not opposites
01:09:46 <kmc> but haskell makes no attempt to support oo in particular
01:09:52 <kmc> perhaps that's what you meant by "purely fp"
01:10:03 <ivanm> that's how I interpreted it
01:10:04 <adu> perhaps
01:10:10 <kmc> looks like io is also very dynamic
01:10:12 <kmc> and haskell is very static
01:10:24 <ivanm> well, it's features aren't static
01:10:37 <adu> io is basically SmallTalk without syntax
01:10:41 <ivanm> Haskell would be one of the fastest moving language targets around (that aren't brand new, etc.) AFAIK
01:10:53 <kmc> i meant in the language design sense
01:11:05 <kmc> dynamic types, dynamic binding, code introspection/modification
01:11:38 * wli has utterly failed to keep up with Haskell extensions since probably 2005 or earlier.
01:12:00 <adu> the last one i heard about was type families
01:12:07 <wli> MPTC/fundeps is about the last I remember picking up.
01:12:54 <roboshibby> type families?
01:13:24 <adu> ya, its wierd, almost like type-based switch case
01:13:34 <roboshibby> ??
01:13:47 <adu> i never grokked type families
01:13:49 <roboshibby> interesting, so examples/etc please?
01:13:52 <roboshibby> oh
01:13:54 <roboshibby> poop
01:14:03 <adu> google it
01:14:07 <Saizan> it's not type-case because it's only at the type level
01:14:19 <Saizan> unless you consider typeclasses type-case too
01:14:26 <adu> huh?
01:14:41 <adu> i consider everything that isn't a value, a type
01:14:54 <roboshibby> what about a variable?
01:15:00 <adu> that's syntax
01:15:16 * edwardk is finally free of mindnumbing slide generation and can think about code again.
01:15:19 <adu> variables can denote values or types, depending on context
01:15:20 <kmc> @google haskell type families
01:15:21 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
01:15:21 <lambdabot> Title: GHC/Type families - HaskellWiki
01:15:24 <kmc> roboshibby, ^^^^
01:15:37 <roboshibby> nice
01:15:40 <roboshibby> thank you
01:15:41 <edwardk> @tell cale go upvote the proposal to fix Either in libraries@ ;)
01:15:41 <lambdabot> Consider it noted.
01:15:43 <kmc> roboshibby, also http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-families.html
01:15:59 <Saizan> adu: i mean that the usual notion of type-case is when you can arbitrarily change the behaviour of a value-level function by pattern matching on the type
01:16:08 <Saizan> adu: type families don't give you that
01:16:15 <adu> oh, i think thats the CL meaning, yes
01:16:46 * wli starts wondering if it's safe to move to 6.12.3 yet but isn't sure which cabal packages he's relying on being there (hmatrix?).
01:17:05 <kmc> type families give you nonparametric polymorphic data types, just as type classes give you nonparametric polymorphic values (including functions)
01:17:29 <kmc> it's no surprise that you often want to use the two together, and there is syntactic support for doing so
01:17:47 <roboshibby> oh that's cool kmc
01:17:49 <roboshibby> thanks
01:17:53 <roboshibby> (read the links)
01:19:40 <roboshibby> cabal? lol what a weird name for some code
01:20:30 <ManateeLazyCat> Hmmm, http://farm5.static.flickr.com/4096/4748566880_aefb70879d_b.jpg flash not play synchronous, same as my guess.... 
01:21:00 <roboshibby> what app is taht?
01:21:07 <roboshibby> the one saying mode (browser)
01:21:11 <ManateeLazyCat> roboshibby: http://farm5.static.flickr.com/4137/4747331678_441d6eb8ec_b.jpg
01:21:16 <ManateeLazyCat> roboshibby: SoftOS.
01:21:21 <ManateeLazyCat> roboshibby: ILE
01:21:34 <roboshibby> url?
01:21:51 <ManateeLazyCat> roboshibby: Integrate editor, webkit-browser, file-manager, pdf-viewer.... etc.
01:22:02 <ManateeLazyCat> roboshibby: Stilling in testing.
01:22:09 <ManateeLazyCat> roboshibby: Haven't release....
01:22:10 <roboshibby> oh you're making it?
01:22:15 <ManateeLazyCat> roboshibby: Yes.
01:22:22 <roboshibby> what'll it be good for?
01:22:41 <ManateeLazyCat> roboshibby: I need patch gtk2hs to make it support network gtk+ event...
01:23:02 <roboshibby> why do you call it an OS? it's an app
01:23:17 <ManateeLazyCat> roboshibby: Because it's aim is do everything.
01:23:18 <roboshibby> a program
01:23:42 <ManateeLazyCat> roboshibby: I call it SoftOS, and Linux kernal is HardOS. :)
01:24:05 <roboshibby> why are you making it?
01:24:07 * wli makes the daring move to 6.12.3
01:24:28 * wli is sick of 6.10.4-r1's crippled haskeline version anyway.
01:24:39 * ManateeLazyCat Maybe i can found a perfect way synchronous vide play after use WebKit2 engine....
01:25:14 <roboshibby> ManateeLazyCat: i just dont understand the point to what you're building
01:25:37 <ManateeLazyCat> roboshibby: First, i hate Emacs that don't support multi-threaded and not safe/fast enough, second i want build Haskell/Gtk+ platform make haskeller can hacking his code quickly.
01:25:57 <roboshibby> oh
01:26:02 <roboshibby> where are you from?
01:26:28 <ManateeLazyCat> roboshibby: It's like Chrome framework, any sub-module running in separate process for crash-free, but more general, not just browser.
01:26:49 <ManateeLazyCat> roboshibby: China.
01:27:01 <roboshibby> they let you guys on the internet?
01:27:16 <ManateeLazyCat> roboshibby: I can fighting GFW. :)
01:27:18 <adu> lol
01:27:26 <roboshibby> GFW?
01:27:29 <roboshibby> oh, great fire wall
01:27:41 <ManateeLazyCat> roboshibby: Infact, i plan to add proxy tool in my SoftOS for fighting GFW natural.... :)
01:27:56 <roboshibby> aren't you afraid to be typing this? 
01:28:04 <ManateeLazyCat> roboshibby: No.
01:28:15 <roboshibby> why not? governments like, disappear people now
01:28:23 <adu> my mom is currently looking info proxy tools
01:28:45 <ManateeLazyCat> roboshibby: I think government haven't power track me .... :)
01:28:45 <roboshibby> adu, are people looking up recipes on the web terrorists now or something? lol
01:29:00 <roboshibby> ManateeLazyCat: well i hope you're right. keep up the valient effort friend
01:29:05 <kmc> GFW is intended for, and successful at, keeping 99.9% people in the dark
01:29:08 <roboshibby> valiant
01:29:12 <kmc> they don't necessarily care about the tiny minority who get around it
01:29:20 <adu> ho, she's in one of those contries with large firewalls
01:29:21 <kmc> unless you piss them off specifically
01:29:24 <roboshibby> kmc, yea till doors are kicked in
01:29:33 <ManateeLazyCat> kmc: I doubt 99.9% :)
01:29:46 <jabb_> any good tutorials for global mutable state with monads (writing your own, not using StateT or Reader)?
01:30:00 <kmc> StateT doesn't provide "real" mutable state
01:30:01 * hackagebot rpf 0.2.0 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.0 (KazuYamamoto)
01:30:05 <roboshibby> ManateeLazyCat: is there underground resistance to tyrrany in china?
01:30:05 <kmc> it's just sugar for passing some values around in functions
01:30:11 <kmc> as such, you can understand the source easily
01:30:13 <tensorpudding> it's not just China, anyway
01:30:18 <kmc> and write your own
01:30:23 <roboshibby> tyranny
01:30:56 <ManateeLazyCat> roboshibby: I don't know, i'm just programmer, just fighting for internet freedom... :)
01:31:14 <roboshibby> ManateeLazyCat: well, excellent. keep up the good work
01:31:27 <roboshibby> we all need to be good stewards of high tech and help keep internet free
01:31:44 <roboshibby> being that we're the technically able ones, it's our duty
01:31:46 <kmc> yeah, freedom *buys six iPads*
01:31:58 <roboshibby> ?
01:32:08 <edwardk> kmc: the guy who hit his lifetime limit thing?
01:32:27 <ManateeLazyCat> roboshibby: In China, we have many secret security team develop many tools fighting GFW..
01:32:43 <roboshibby> nice!!
01:32:57 <kmc> edwardk, wasn't referencing anything specific
01:33:12 <kmc> just that iOS is an authoritarian platform
01:33:21 <roboshibby> yea it sux
01:33:30 <kmc> and the entire supposedly free world is fawning over it
01:33:30 <edwardk> kmc: ah http://www.protocolsnow.com/2010/04/17/how-i-went-from-apple-store-newbie-to-lifetime-ban-in-one-week/ is what i was thinking you meant
01:33:31 <eevar2> not sure tech is the way to freedom. politic influence would have more effect imo
01:33:42 <roboshibby> kmc, yea it's insane
01:33:48 <eevar2> anyways, that's probably a -blah matter
01:33:56 <mreh> is there no integration between ghci and cabal? I don't suppose so
01:33:59 <edwardk> preflex: xseen jaffacake
01:34:00 <preflex>  jaffacake was last seen on freenode/#ghc 19 hours, 12 minutes and 22 seconds ago, saying: and x:/ghc-6.12 for the 6.12 branch
01:34:02 <wli> eevar2 has it right on both counts
01:34:03 <sbpaul> http://web.archive.org/web/20061023205046/www.harbour.sfu.ca/~hayward/van/lyrics/losttapes.html
01:34:22 <JaffaCake> edwardk: ?
01:34:53 <edwardk> i wanted to pick your brain for a minute. i need/would like to do something horribly abusive and i don't think i can ;)
01:34:55 <ManateeLazyCat> roboshibby: What's most want feature in my environment? I have some sub-module: editor, file-manager, web-browser, pdf-viewer
01:35:32 <roboshibby> huh?
01:36:08 <ManateeLazyCat> roboshibby: If you want some application, like mail-client, irc-client, i will implement them first... :)
01:39:43 <cizra> ManateeLazyCat: hi there. Are Assistants supported in gtk2hs?
01:40:18 <ManateeLazyCat> cizra: In other repository.
01:40:24 <cizra> ManateeLazyCat: OK
01:40:40 <ManateeLazyCat> cizra: I have finish all gtk+ 2.18.3 APIs in other repository.
01:40:41 <roboshibby> ManateeLazyCat: oh, no thanks. but you should implement those and release softOS
01:40:49 <ManateeLazyCat> cizra: But some binding is wrong need review again.
01:41:32 <ManateeLazyCat> cizra: I'm quite busy at the moment, i will merge those APIs (include gtk+ 2.20) to gtk2hs main repository when i have some spare time.
01:41:55 <cizra> ManateeLazyCat: Oh, I'm in no hurry
01:42:30 <ManateeLazyCat> roboshibby: Well, because my project use some new APIs (https://patch-tag.com/r/AndyStewart/gio-branch/home) that haven't merge in gtk2hs main repository.
01:42:54 <ManateeLazyCat> roboshibby: I might to merge those APIs before i release my softOS, for easy to install by cabal.. :)
01:43:04 <cwb> One of the (cabal installed) modules I'm using does not support profiling: Can I add profiling myself to that module? Or can I exclude only that module from profiling somehow while using -auto-all for the rest of the program?
01:43:32 <roboshibby> ManateeLazyCat: good luck, and stay safe =)
01:43:57 <ManateeLazyCat> roboshibby: Yes, i will release it under GPL-3
01:46:13 <ManateeLazyCat> cizra: Assistant.chs at http://www2.in.tum.de/~simona/gtk2hs-2.18/gtk/Graphics/UI/Gtk/Windows/ , if you hurry, you can help us review it.
01:46:27 <ManateeLazyCat> cizra: All gtk+ 2.18.3 APIs finish in http://www2.in.tum.de/~simona/gtk2hs-2.18
01:47:23 <ManateeLazyCat> cizra: Now just Axel and me work on new APIs, unfortunately we're quite busy now, we will add new APIs faster if someone help us review those APIs.
01:48:29 <ManateeLazyCat> cizra: But for build a stable version, we perhaps just accept new *big* patch after gtk2hs-0.11.1
01:49:52 <cizra> ManateeLazyCat: I'm afraid I don't have the knowledge for reviewing. I'm not too strong in Haskell and I've never touched any FFIs.
01:50:29 <ManateeLazyCat> cizra: Trust me, most APIs binding is pretty easy to understand. :)
01:50:55 <kmc> RWH has a good intro to FFI
01:51:09 <ManateeLazyCat> cizra: The main reason that we build gtk2hs cabal is want more people help us develop/test gtk2hs...
01:52:01 <ManateeLazyCat> cizra: When you add new module in gtk2hs, most binding is similar with other module, you can study many FFI knowledge from gtk2hs self. 
01:52:58 <ManateeLazyCat> cizra: Most APIs is simple that can generate by ApiGen (binding tools in gtk2hs), just few complicated trick function need tweak by hand. 
01:55:35 * ManateeLazyCat I hope my project will bring many haskellers into gtk2hs team ....
02:03:57 <cizra> ManateeLazyCat: Okay.. The problem is, I'm pretty busy myself as well. I'll see if I can find the time.
02:07:09 <cheater99> sbpaul: that's a nice track
02:09:48 * ManateeLazyCat I hope someday we can build gtk2hs binding Wiki, then any FFI expert can review/commit *one* function in 5 mintues, then binding speed will extreme fast....
02:21:23 <m3ga> does anyone have a collection of Parsec best practices?
02:21:52 <ivanm> m3ga: my parsec best practice is to use polyparse :p
02:22:06 * ivanm only has one parsing project though, and he didn't choose the parsing library for it...
02:22:50 <m3ga> and i didn't choose the one for ddc :-)
02:22:57 <ivanm> heh, fair enough
02:23:05 <ivanm> hang on, ddc is using parsec to parse the code? :s
02:23:20 <m3ga> i'm pretty comfortable with Parsec now, but benl32's original hacked-together-in-a-weekend-after-seeing-a-presenation had some problems.
02:23:24 <m3ga> yes, ddc uses parsec
02:23:35 <ivanm> I would have thought it'd use happy + alex
02:23:37 <ejt> I found using Control.Applicative liberally improved my parsec parsers a lot (for what it's worth)
02:23:55 <m3ga> i did originally use happy. it still uses alex
02:24:11 <ivanm> m3ga: I assume you mean a presentation on parsec rather than a presentation on disciple...
02:24:17 <ivanm> (or whatever the language is called)
02:24:52 <m3ga> ivanm: yes, at fp-syd there was a presentation on parsec. ben threw out the happy parser that weekend.
02:25:11 <m3ga> ejt: any examples of Parsec and Control.Applicative?
02:25:55 <m3ga> however, if there was a best-practices document, i wouldn't have had to do all this refactoring :-)
02:26:05 <ivanm> m3ga: *tsk*
02:26:19 <ivanm> AFAIK, for an actual language like that happy + alex would give better performance
02:26:30 <ejt> m3ga: http://github.com/jthornber/xdrgen/blob/master/Data/XDR/Parser.hs
02:26:47 <m3ga> ejt: thanks, i'll take a look.
02:27:07 <ejt> there's more 'do's in there than I'd like, but plenty of applicative stuff too
02:27:13 <m3ga> ivanm: ddc uses alex, so it works as a token parser rather than as a Char parser.
02:27:22 <ivanm> ahhh
02:27:46 <kmc> you can do two-stage lex/parse with Parsec too
02:27:59 <m3ga> so speed shouldn't be vastly different from happy
02:28:09 <m3ga> kmc: exactly, thats what ddc has
02:28:17 <jrockway> wow, sometimes i wonder...
02:28:29 <jrockway> i just spent an hour or so trying to debug a random "Prelude.foldr1: empty list"
02:28:36 <jrockway> debugging didn't turn anything up
02:28:42 <jrockway> then i searched for foldr1 in my code
02:28:54 <jrockway> well, the one place I use foldr1 got passed an empty list...
02:31:39 <ivanm> jrockway: as in directly?
02:31:44 <jrockway> yeah
02:31:53 <jrockway> via a function that performs optional sanity checks on the data
02:32:04 <jrockway> which apparently works fine if there are 0 or 2 records, but not if there is 1 record
02:32:07 <jrockway> oh well, fixed :)
02:32:57 <ejt> jrockway: have you taken out the foldr1 or 'fixed' it another way ?
02:33:29 <ivanm> special casing on empty lists via pattern matching?
02:33:30 <jrockway> the function that calls foldr1 checks to see if a sequence is increasing
02:33:41 <jrockway> which only makes sense if there is more than one element
02:33:45 <kmc> clearly the empty sequence is increasing ;)
02:33:53 <kmc> as is the one-element sequence
02:33:54 <jrockway> so in the 0/1 element case, we skip the increasing-date check
02:34:04 <jrockway> yeah
02:34:21 <jrockway> "not decreasing" anyway :)
02:34:31 <kmc> no i think it's decreasing too
02:35:20 <jrockway> case length data of { 0 -> return (); 1 -> return (); _ -> increasing ... }
02:35:44 <kmc> > let increasing xs = and $ zipWith (<) xs $ drop 1 xs in map increasing [[], [1], [1,2,3], [1,4,2]]
02:35:45 <lambdabot>   [True,True,True,False]
02:37:41 <m3ga> ivanm: thanks for the Polyparse explanation on -cafe. i think i kinda prefer Parsec's behaviour for parsing static data (eg input file), but can see that Polyparse might be better for partial parsing of incomplete data (eg data coming in on a network connection).
02:39:53 <ivanm> m3ga: I find it really nice for parsing Dot code, since i have to backtrack quite often :s
02:40:15 <kmc> preflex, zdec base_GHCziInt_zdfBoundedInt322_closure
02:40:16 <preflex>  base_GHC.Int_$fBoundedInt322_closure
02:40:21 <ivanm> (though I do have plans on how to reduce the number of backtracks by doing partial parsing)
02:40:26 <kmc> anyone know how to interpret this symbol name?
02:40:30 <ivanm> nope
02:40:31 <kmc> i am guessing it is a type class instance
02:40:36 <kmc> for Bounded Int32
02:40:36 <ivanm> I don't even know what zdec is
02:40:41 <ivanm> kmc: what is that from?
02:40:43 <ivanm> core?
02:40:44 <kmc> zdec decodes ghc's name mangling
02:41:19 <kmc> it's from object files
02:41:21 <kmc> via C
02:41:23 <kmc> it's a symbol that base should be providing but isn't
02:41:29 <kmc> in my hacked-up android build system
02:41:54 <m3ga> ivan: yes, always do partial parsing. its a bit counter-intuitive at first, but for speed, you want to avoid backtracking except at the very leaves of your parse tree.
02:42:36 <ivanm> m3ga: well, atm I don't because it was easier to generate that way
02:42:47 <ivanm> but I've got ideas on how to automate the patial parsing...
02:43:49 <jrockway> this database we bought is quite amusing
02:44:01 <jrockway> i just noticed that some of the records have a start date that comes after the end date
02:44:06 <jrockway> hence my sanityCheckData function ;)
02:44:24 <jrockway> i think i am probably the first person to ever use the data for something other than a graph in the GUI
02:44:26 <m3ga> i suspect that its easier to generate because you haven't had much parser experience. the ddc parser is probably my 10th big parser and second one using Parsec.
02:44:39 <ivanm> to an extent
02:44:45 * ivanm digs up the parser generator script he uses
02:45:04 <ivanm> m3ga: http://code.haskell.org/graphviz/Data/GraphViz/AttributeGenerator.hs
02:47:28 <kmc> hmm it seems to be stuff that's "not used" which is not exported
02:47:34 <kmc> i.e. not in the export list, unused instances
02:51:46 <kulin> what is the point of "something.h" in the following, changing it doesn't affect which c files "functionName" is reference from? foreign ccall "something.h functionName" c_functionName :: CInt -> CInt
02:51:49 <ivanm> kmc: unless the class isn't exported, instances are automagically exported...
02:52:47 <kmc> yeah which is why i'm confused
02:57:55 <kulin> does it not matter because i use 'extern "C" { }' in the c files?
02:58:14 * ivanm has no idea, sorry
03:00:21 <kmc> kulin, it often doesn't matter
03:00:42 <kmc> if your haskell compiler is outputting C, it's required to produce a directive «#include "something.h"» in the file it outputs
03:01:09 <kmc> except it seems ghc doesn't anyway
03:01:29 <kmc> c has no module system, you can't really control where a symbol comes from when you use it
03:01:57 <kulin> oh so that is not at all related to the source file anyways, i was trying to match it up to something.h which i was creating
03:03:09 <kmc> i can't come up with a single example where it affects the .hc file produced by ghc
03:11:28 <kmc> "Header files have no impact on the semantics of a foreign call, and whether an implementation uses the header file or not is implementation-defined. However, as some implementations may require a header file that supplies a correct prototype for external functions in order to generate correct code, portable FFI code must include suitable header files."
03:12:08 <kulin> ah i see, thanks
03:12:50 <kulin> so im write to do what i've been doing, but at the same time it doesn't matter :)
03:12:54 <kulin> right, rather
03:14:35 <kmc> it matters for some theoretical haskell compiler that might not exist
03:14:56 <kulin> ya, which my code wont work on for many other reasons im sure
03:15:00 <kmc> probably :)
03:19:42 <kmc> i made the impossible happen
03:19:48 <kmc> maybe this is a sign i should go to bed
03:20:31 <kulin> bed... not fair bringing that up
03:20:38 <kulin> i meant to goto bed 3 hours ago
03:37:46 <Peaker> @hoogle Typeable5
03:37:46 <lambdabot> Data.Typeable class Typeable5 t
03:37:54 <Peaker> @src Typeable5
03:37:54 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:38:13 <Peaker> Is there a nicer idea for a solution than TypeableN?  This problem repeats elsewhere
03:40:33 <ksf> what would be necessary for the TH ast to be typed (that is, TH be typed not only at the splice and reify points)
03:41:16 <aristid> wtf somebody says TH is one of his favorite aspects of haskell
03:41:32 <ksf> yes, I am partly referring to that.
03:41:34 <kmc> i really like that TH exists; i also really like that i rarely have to use it
03:41:52 <aristid> is intoverflow somebody in here?
03:42:03 <aristid> http://intoverflow.wordpress.com/2010/06/30/haskell-features-id-like-to-see-in-other-languages/
03:42:35 <kmc> ksf, you want that instead of «Exp» we have «Exp t» meaning "expression with type t" ?
03:42:47 <ksf> yep
03:42:59 <kmc> MetaML does that
03:43:03 <kmc> the original TH paper contrasts with it
03:43:12 <aristid> can fundeps be fully replaced by type families?
03:43:14 <Jafet> That would lead to (more) interesting self-references (than we have now)
03:43:17 <aristid> if so, will that be done?
03:43:19 <ksf> almost nearly.
03:43:28 <kmc> it eliminates a lot of the use cases for TH, unless you leave a way out, which MetaML does
03:43:59 <ksf> dunno if they could be completely removed in case e.g. contexts for type instances become reality
03:44:22 <ksf> but anyway, in some cases fundeps are the more natural match to the problem domain. not often, but it happens.
03:45:05 <aristid> i've seen packages on hackage that exist in two varieties:
03:45:09 <ksf> at the expense of making transformations of actual haskell source a pain?
03:45:19 <aristid> one using associated types, the other using fundeps
03:45:21 <aristid> that bothers me.
03:46:12 <Saizan> Peaker: kind polymorphism?
03:46:13 <ksf> I would even go so far as demanding that haskell should be specified meta-circular, with a plugin architecture into a partial evaluator.
03:46:30 <aristid> .oO(Perl)
03:46:31 <ksf> "to reduce expressions of that type, ask me)
03:46:38 <ksf> kinda like generics.
03:46:39 <kmc> that article also repeats the idea that Haskell has type-level tags for pure versus side-effecting functions
03:46:41 <Peaker> Saizan, Maybe, I haven't thought about it enough to figure out if it solves the issue completely
03:47:05 <kmc> maybe it's a reasonable description if you're comparing to other languages
03:47:24 <Peaker> Saizan, The problem that really interests me is:
03:47:29 <Peaker> class Newtype a where type Unwrapped a ; wrap :: Unwrapped a -> a ; unwrap :: a -> Unwrapped a
03:48:17 <Peaker> I can't use wrap/unwrap to replace newtypes that pass multiple type vars
03:53:12 <Peaker> The above Newtype class doesn't allow any type params actually, because I can't express something like:  inFirst :: (a -> b) -> First a -> First b    . If I try I get:  Newtype n => (a -> b) -> n -> n   -- where to put "a" "b" ?
03:53:39 <Peaker> If I make the Newtype instance be (* -> *) then I can have (a -> b) -> n a -> n b    but then I can't do it with more type params
03:54:19 <Peaker> Saizan, Even with kind polymorphism, I am not sure I would be able to get:  inNewtype2 :: (a -> b) -> Something a a -> Something b b   for free
03:54:23 <int-e> Peaker: can't you do something like  newtype X a b c = X (a b c); instance Newtype (X a b c) where type Unwrapped (X a b c) = (a b c); ...?
03:54:52 <Peaker> int-e, You can do that, but then the type of   inNewtype f = wrap . f . unwrap   is too restrictive
03:54:58 <mreh> how can I invoke ghci on an executable package?
03:55:15 <int-e> Peaker: ah. right.
03:55:45 <Saizan> Newtype (n a), Newtype (n b) => (a -> b) -> n a -> n b ?
03:56:24 <Peaker> Saizan, I don't think that would work.. (wrap/unwrap) have to be of the same newtype instance
03:56:36 <Saizan> nah
03:56:42 <grubby> 0
03:57:58 <Saizan> inNewtype :: (Newtype n1 , Newtype n2) => (Unwrapped n1 -> Unwrapped n2) -> n1 -> n2 should work, i'd think
03:58:45 <Peaker> Saizan, But I just want to generalize the repeating pattern:  inMyNewType f = MyNewType . f . unMyNewType
03:59:04 <Peaker> Your inNewtype requires another arg (its another pattern)
03:59:17 <Saizan> another arg? where?
03:59:37 <Peaker> Oh, sorry, you have just that, let me try it
04:00:32 <Peaker> I misunderstood your type at first, it does work for this example
04:02:04 <Saizan> principal types ftw :)
04:02:07 <Peaker> :-)
04:02:13 <Peaker> Saizan, thanks, this might just work :)
04:02:23 <yairchu> looks pretty awesome Saizan
04:02:34 <Saizan> np
04:10:38 <Peaker> I am toying with it and now my only problem is ambiguous types...  My newtype class ought to use "data" and not "type" but that forces a new data structure. Fundeps could allow a one-to-one relationship with a non-new data type
04:10:56 <Peaker> Oh, that wouldn't be good here :)
04:12:17 <Peaker> I guess forcing the newtype to be of the same type constructor is only possible with kind polymorphism
04:19:50 <Blkt> good day everyone
04:20:29 <dafis> Blkt: good day
04:20:31 <kmc> morning
04:20:39 <Blkt> hello there
04:21:51 <portnov> evening.
04:29:16 <Peaker> Is the type operator (->) available with NoImplicitPrelude?
04:32:16 <RayNbow> hmm...
04:32:56 <RayNbow> Peaker: doesn't seem like it
04:33:23 <Peaker> It's weird that (->) is allowed to be a regular name when the TypeOperators extension is disabled
04:33:33 <ksf> oh. they _did_ split the prelude in H2010
04:33:36 <RayNbow> hmm... loading a file with just {-# LANGUAGE NoImplicitPrelude #-} in it in ghci...
04:33:39 <kmc> it is Peaker?
04:33:40 <Peaker> If you could just hide/redefine it, then maybe TH could have nicer names
04:33:51 * ksf wonders why it's PreludeList and not Prelude.List, though.
04:34:17 <Peaker> kmc, I don't understand why TypeOperators isn't always on. It seems so unnatural/arbitrary that this specific slice of the namespace is banned in this contextg
04:34:21 <RayNbow> *Main> :t (->)
04:34:21 <RayNbow> <interactive>:1:1: parse error on input `->'
04:34:34 <kmc> i think (->) is syntactically special everywhere
04:34:40 <Peaker> :k (->)
04:34:41 <lambdabot> ?? -> ? -> *
04:34:45 <kmc> it doesn't have the form of a usual type operator
04:34:49 <Peaker> :t (->)
04:34:50 <lambdabot> parse error on input `->'
04:34:53 <RayNbow> oh right
04:35:00 <int-e> ksf: hierarchical modules are a language extension, not part of haskell98
04:35:01 <Peaker> kmc, Why not?
04:35:09 <kmc> doesn't start with :
04:35:19 <kmc> don't type operators need to start with :
04:35:25 <kmc> that being the infix equivalent of "upper case"?
04:35:29 <RayNbow> Peaker: in that case, (->) seems to be work
04:35:55 <Peaker> kmc, You're right yeah, so (->) would be a valid type-variable
04:35:59 <int-e> ksf: eg
04:36:09 <kmc> yeah, you can use (~>) as a tyvar for instance
04:36:11 <Peaker> (upper-case ~= starts-with-:)
04:36:15 <int-e> ksf: eh. in h2010, you wrote. Then I don't understand it either.
04:36:17 <kmc> i think (->) is about as special a thing as you can find
04:36:26 <Peaker> kmc, But it doesn't need to be
04:36:38 <Peaker> kmc, it's a bit ugly that it is unnecessarily special
04:36:55 <kmc> yeah
04:36:56 <theorb> Types aren't values in haskell, though.
04:37:04 <Peaker> theorb, but they are ordinary names
04:37:07 <kmc> you're saying it could be an ordinary type constructor in Prelude
04:37:13 <kmc> which you could hide etc.
04:37:27 <Peaker> kmc, Yeah, I think maybe types/type-var should have reversed naming
04:37:34 <kmc> you could make some fantastically confusing code this way :)
04:38:04 <Peaker> heh
04:38:34 <ksf> if it were a vanilla type constructor, it would have to start with a colon
04:38:51 <theorb> If you make a function (->) a b, you can pass in 1 and 2, but you could never pass in Int and Int.
04:39:01 <theorb> Constructors are values, but types aren't.
04:39:08 <Peaker> Maybe there needs to be a different rule than upper/lower case for operator names
04:39:14 <Peaker> (I mean other than :)
04:39:20 <kmc> theorb, we're talking about «data (->) a b = ...»
04:39:28 <kmc> of course functions aren't data types in Haskell
04:39:30 <ksf> but I think the distinction between constructors and functions should be abolished, anyway. there's smart constructors, after all.
04:39:32 <kmc> but you could treat them like they are
04:39:35 <ClaudiusMaximus> is there a nice generalization of Bresenham's straight line drawing algorithm to sufficiently smooth parametric curves on a sufficiently fine grid?
04:39:42 <Peaker> ksf, You can't pattern match on a function
04:39:58 <kmc> not without extra fancy pattern systems anyway
04:39:58 <Peaker> ksf, It's an important distinction -- whether a module exports pattern-matchers or just values
04:40:00 <Zao> ClaudiusMaximus: Maybe you can generalize something from the circle algorithm?
04:40:11 <ksf> view patterns?
04:40:17 <Zao> Although that abuses symmetry a fair bit.
04:40:56 <ClaudiusMaximus> hm, maybe - my usage scenario is plotting a cardiod
04:41:01 <kmc> ClaudiusMaximus, you need fast performance / integer-only?
04:41:04 <ClaudiusMaximus> *cardioid
04:41:50 <ClaudiusMaximus> kmc: not really, but i want lack of lumps (ie, in any block of 4 pixels, at most 2 are filled)
04:42:19 <kmc> hmm
04:42:22 <ClaudiusMaximus> so maybe i should just plot naively and take away the lumps later
04:42:43 <kmc> i thought bresenham's had output equivalent to naive interpolation
04:43:05 <kmc> it doesn't specially avoid lumps, you just don't get them on straight lines
04:43:07 <Zao> Xian-Wu (or what's his name) has antialiased versions of the Bresenham Line and Circle ones.
04:43:49 <Zao> Xiaolin Wu.
04:45:20 <Jafet> Bresenham's algorithm: take the derivative of the curve, find the axis with the biggest delta, and step through it
04:47:07 <ClaudiusMaximus> ah, that seems a promising angle, Jafet - thanks for the insight
04:47:08 <ClaudiusMaximus> btw, i want aliasing, i'm animating movement across a grid, and i don't want stroboscopes
04:47:41 * ksf thinks an annotated version of the report that lists extensions would be great
04:48:33 <ksf> ...leave out a couple of not so easily parsable things (like formal semantics of case expressions...) and we've got ourselves a really decent reference manual.
04:49:05 <Jafet> claudius, then use Wu's idea -- split the current pixel in a perpendicular line of adjacent pixels whose brightness are divided according to the curve's actual position
04:49:13 <Jafet> If you do it right, it's still fast as heck
04:49:27 <Zao> Jafet: I assume that he's referring to the shimmering of moving antialiased lines.
04:49:41 <Jafet> Oh, missed that
04:49:44 <Zao> As [0.5,0.5] looks distinctly different than [1.0,0.0]
04:49:50 <Jafet> I don't know about that, then.
04:53:22 <duairc> Can you do pattern matching on records in lambdas?
04:53:25 <duairc> \s@({getModifier = m}) -> s { getModifier = f . m }
04:53:30 <duairc> That's apparently invalid syntax
04:53:41 <kmc> you may need an extra layer of parens
04:53:57 <duairc> Around which?
04:54:01 <ManateeLazyCat> duairc: YourType {... = ... , ... = ...}
04:54:08 <kmc> you're missing a constructor too
04:54:17 <duairc> Oh of course
04:54:24 <ManateeLazyCat> duairc: Use \Constructor {...}
04:54:25 <duairc> Thanks!
04:54:32 <kmc> seems i don't need the parens
04:54:32 <dafis> duairc, you'd need \s@Constructor{field=value}
04:54:50 <duairc> Yeah, that works now
04:54:58 <duairc> I'd just forgot the constructor
04:55:44 <ski> > (\(t @ Node {rootLabel = x , subForest = f}) -> (x,f,t)) (Node 0 [])
04:55:46 <lambdabot>   (0,[],Node {rootLabel = 0, subForest = []})
04:55:52 <ManateeLazyCat> duairc: if you just want reference field use "Constructor {filed=value}" ,otherwise use "s@(Constructor {filed=value})"
04:56:24 <ski> > (\(t @ Node {rootLabel,subForest}) -> (rootLabel,subForest,t)) (Node 0 [])
04:56:25 <lambdabot>   Illegal use of punning for field `rootLabel'
04:56:25 <lambdabot>  Use -XNamedFieldPuns to permi...
04:57:28 <ski> > (\t @ Node {rootLabel = x , subForest = f} -> (x,f,t)) (Node 0 [])  -- oh, you're right ..
04:57:29 <lambdabot>   (0,[],Node {rootLabel = 0, subForest = []})
05:51:52 <mreh> waaah, how do I debug something that's been packaged up
05:52:04 <mreh> GHCi complains it cant find any of the modules
05:52:29 <mreh> even when I'm in have the right relative cwd
05:57:01 <AAIBB^> I am trying to select 4 5 6 from [1,2,3,4,5,6,7,8] .. how to ?
05:57:44 <ksf> "select"?
05:57:54 <ksf> there's no values attached to them, so why would you?
05:57:58 <AAIBB^> thank you
05:58:02 <ksf> to test for set membership,
05:58:11 <ksf> > 4 `elem` [1..10]
05:58:12 <lambdabot>   True
05:58:15 <ksf> > 11 `elem` [1..10]
05:58:16 <lambdabot>   False
05:58:40 <zygoloid> @tell dafis [re the Tuesday Boy]: i've done some more thinking, talked it over with a friend, and now i agree with you: the only correct answer is "it depends"
05:58:40 <mreh> easily pleased
05:58:41 <lambdabot> Consider it noted.
05:59:20 <AAIBB^> > 3 'elem' [1..10]
05:59:21 <lambdabot>   <no location info>:
05:59:21 <lambdabot>      lexical error in string/character literal at chara...
05:59:32 <sepp2k> AAIBB^: Maybe you want  takeWhile (<= 6) $ dropWhile (< 4) [1,2,3,4,5,6,7,8]
05:59:35 <AAIBB^> > 3 `'elem` [1..10]
05:59:36 <lambdabot>   <no location info>:
05:59:36 <lambdabot>      lexical error in string/character literal at chara...
06:00:06 <AAIBB^> > 11 `elem` [1..10]
06:00:06 <lambdabot>   False
06:00:30 <ksf> x `foo` y is the same as foo x y
06:00:42 <ksf> some things just look nicer if written infix
06:00:57 <AAIBB^> what is this foo function everyone keeps talking about
06:00:59 <orlandu63> i dont think elem is one of them
06:01:11 <ddarius> > intersect [4..6] [1..8]
06:01:12 <lambdabot>   [4,5,6]
06:01:23 <ddarius> > intersect [4..6] [1..5]
06:01:24 <lambdabot>   [4,5]
06:01:38 <ksf> AAIBB^, http://en.wikipedia.org/wiki/Metasyntactic_variable 
06:02:01 <orlandu63> and http://en.wikipedia.org/wiki/Foobar
06:02:07 <AAIBB^> too bad it wont let me [4,5] `elem` [1..10]
06:02:19 <ksf> :t intersect
06:02:20 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:02:33 <ksf> > [4,5] `intersect` [1..10]
06:02:34 <lambdabot>   [4,5]
06:02:37 <zygoloid> > all (`elem` [1..10]) [4,5]
06:02:38 <lambdabot>   True
06:03:30 <ksf> > lef f x y = (x `intersect` y) == x in f [4,5] [1..10]
06:03:31 <lambdabot>   <no location info>: parse error on input `='
06:03:33 <orlandu63> :t not . null . elem
06:03:35 <lambdabot>     Couldn't match expected type `[a]'
06:03:35 <lambdabot>            against inferred type `[a1] -> Bool'
06:03:35 <lambdabot>     Probable cause: `elem' is applied to too few arguments
06:03:43 <orlandu63> :t not . null . intersect
06:03:44 <lambdabot>     Couldn't match expected type `[a]'
06:03:44 <mreh> :t all
06:03:44 <lambdabot>            against inferred type `[a1] -> [a1]'
06:03:44 <lambdabot>     Probable cause: `intersect' is applied to too few arguments
06:03:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:03:54 <mreh> :t and
06:03:55 <lambdabot> [Bool] -> Bool
06:03:57 <mreh> aah
06:03:58 <ksf> er huh?
06:04:28 <AAIBB^> >all(`elem` [1,2,3,4,6,7,8,9,10]) [4,5] 
06:04:32 <mreh> :t and . fmap
06:04:34 <AAIBB^> this fixes my needs
06:04:37 <lambdabot>     Couldn't match expected type `[Bool]'
06:04:38 <AAIBB^> thank you so much all
06:04:39 <lambdabot>            against inferred type `f a -> f b'
06:04:41 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
06:05:02 <mreh> :t (and .) fmap
06:05:03 <lambdabot>     Couldn't match expected type `[Bool]'
06:05:03 <lambdabot>            against inferred type `f a -> f b'
06:05:03 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
06:05:06 <rfh> using the fact that (undefined,undefined) != undefined, how can i construct a list xys such that zipp (unzip xys) != xys?
06:05:06 <mreh> :t (and .) . fmap
06:05:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:05:26 <Botje> rfh: that sounds like a homework question.
06:05:50 <kmc> rfh, by != you mean "has observably different behavior from"?
06:05:51 <rfh> Botje: self-study, and cant figure it out
06:05:56 <Botje> ah
06:05:56 <mreh> should be easy then :)
06:05:58 <rfh> kmc: not equal to
06:05:59 <kmc> and not, say, in-language equality by Eq?
06:06:16 <zygoloid> rfh: ok, well what's the simplest possible testcase you could try involving (undefined, undefined)?
06:06:23 <kmc> well if you apply the actual (==) operator from Eq to undefined, it will probably throw an exception
06:06:59 <rfh> zygoloid: well, unzip
06:07:02 <AAIBB^> my install does not process `intersect`
06:07:39 <Botje> AAIBB^: it's in Data.List
06:07:43 <zygoloid> rfh: well, first things first, i assume zipp is your own function. i'm guessing zipp == uncurry zip?
06:07:55 <braddunbar> so....I'm a noob, and I'm getting following back from runghc: "foo:1:0: lexical error at character '\DEL' " - have been unable to get anything by googling
06:08:12 <rfh> zygoloid: ya
06:08:16 <kmc> braddunbar, sounds like you've got some garbage character in your source file
06:08:31 <kmc> why foo and not foo.hs?
06:08:36 <zygoloid> rfh: ok, so you're looking for a value for xys where zipp (unzip xys) denotes something different from xys
06:09:07 <braddunbar> kmc: um...not sure, isn't the syntax "runghc <module name>"?
06:09:08 <rfh> zygoloid:indeed
06:09:10 <zygoloid> as kmc points out, this is different from a value of xys where zipp (unzip xys) != xys denotes True
06:09:27 <zygoloid> (indeed, for a well-behaved Eq, there should be no such values)
06:09:36 <braddunbar> kmc: I agree about the garbage character, but have been unable to find it using ":set list" so far
06:09:54 <zygoloid> rfh: ok, so what type does xys need to have?
06:10:01 <kmc> braddunbar, hmm, the manpage agrees with you, but i've always run it on the .hs file
06:10:05 <kmc> do you have a binary file named 'foo'?
06:10:12 <rfh> rfh: infinity?
06:10:21 <rfh> zygoloid: inifinty?
06:10:28 <braddunbar> kmc: don't think so....trying with foo.hs
06:10:51 <braddunbar> kmc: ha!  that's definitely it....someone should update that man page =)
06:11:01 <braddunbar> kmc: thank you
06:11:04 <zygoloid> rfh: i'm not sure what you mean, that's not a type.
06:11:24 <rfh> zygoloid: its recursive
06:11:46 <rfh> Nat = Zero | Nat Zero
06:11:53 <rfh> or Succ Zero
06:12:13 <chrisdone> Nat = [()]
06:12:21 <rfh> Infinity = succ(succ...(zero))
06:12:23 <zygoloid> what i mean is, what type does xys need to have for zipp (unzip xys) == xys to typecheck?
06:12:35 <chrisdone> :t unzip
06:12:36 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
06:12:47 <benmachine> :t uncurry zip
06:12:48 <chrisdone> nice. i've never used unzip for anything
06:12:48 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
06:13:22 <rfh> zygoloid: dont know
06:13:37 <kmc> :t uncurry zip . unzip
06:13:38 <lambdabot> forall a b. [(a, b)] -> [(a, b)]
06:13:48 <zygoloid> rfh: ok. what type does xys need to have in order for it to be possible to pass it to unzip?
06:15:02 <rfh> zygoloid: polymorphic: [(a),(b)] ?
06:15:16 <rfh> mean [(a,b)]
06:15:33 <kmc> could be any particular type of that form, yes
06:16:07 <kmc> it's unzip that's polymorphic, not necessarily the value you pass to it
06:16:23 <rfh> i understand
06:16:38 <zygoloid> rfh: right. so xys needs to be a list of pairs.
06:17:13 <zygoloid> rfh: do you understand what zipp and unzip do?
06:17:18 <rfh> ok, so thats totally valid for any type of pairs
06:17:25 <zygoloid> rfh: right.
06:17:28 <rfh> yes
06:17:58 <Ke> > fix succ
06:17:59 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
06:18:01 <McManiaC> hi, is there a decent documentation for the darcs API?
06:18:13 <chrisdone> haddock, no?
06:18:29 <chrisdone> McManiaC: are you in the project directory?
06:18:34 <McManiaC> haddock is pretty incomplete :S
06:18:38 <rfh> zygoloid:so there is nothing to gain in thinking about the types inside the list because zipp,unzip dont bother
06:18:39 <chrisdone> in what sense?
06:18:42 <cheater99> hi guys
06:18:49 <cheater99> what's $?
06:19:00 <zygoloid> rfh: absolutely right. we know that by parametricity.
06:19:02 <chrisdone> $ is a right-associative function application operator
06:19:07 <chrisdone> @src ($)
06:19:07 <lambdabot> f $ x = f x
06:19:17 <McManiaC> chrisdone: in the sense that very few functions have a description on what they actually do
06:19:20 <McManiaC> :S
06:19:31 <chrisdone> naughty darcs hackers. bad!
06:19:36 <zygoloid> rfh: (in fact that's a much deeper observation than you need in order to solve this problem) :)
06:19:37 <cheater99> how is it different from just f x?
06:19:40 <chrisdone> @smack darcs-developers
06:19:40 <lambdabot> why on earth would I slap darcs-developers?
06:20:00 <chrisdone> cheater99: it's no different in behaviour, it's main use is syntactic ease. consider f (x y) vs f $ x y
06:20:13 <McManiaC> chrisdone: maybe I'm just looking at the wrong libraries
06:20:13 <McManiaC> :>
06:20:30 <cheater99> not sure what the difference there would be, let me write a quick function to test
06:20:53 <kmc> (f x y) is ((f x) y)
06:20:58 <kmc> (f $ x y) is (f (x y))
06:21:04 <benmachine> cheater99: basically, using $ allows us to use fewer parentheses
06:21:15 <kmc> because infix operators bind weaker than function application
06:21:17 <zygoloid> rfh: can you describe what zipp and unzip do? (not as a test, just so i can match my hints to your way of thinking)
06:21:19 <benmachine> and so write prettier code
06:21:20 <kmc> and ($) binds weaker than most infix operators
06:21:39 <kmc> cheater99, it's also useful as a section
06:21:43 <kmc> > map ($ 3) [succ, pred]
06:21:43 <lambdabot>   [4,2]
06:22:07 <cheater99> section?
06:22:11 <kmc> yes
06:22:12 <cheater99> how does that work?
06:22:25 <kmc> (+ x) is shorthand for \y -> y + x
06:22:30 <kmc> (x +) is shorthand for \y -> x + y
06:22:35 <chrisdone> cheater99: try replacing ($ 3) with a lambda abstraction
06:22:39 <kmc> this works for any infix operator in place of +
06:22:50 <kmc> (including ordinary names within backticks)
06:22:52 <rfh> zygoloid: unzip takes a list of pairs and gives back to lists [(a,b)]->([a],[b])
06:23:08 <kmc> > map (* 10) [1,2,3]  -- mapping another section
06:23:09 <lambdabot>   [10,20,30]
06:23:18 <rfh> zygoloid: zipp goes the other way around, in uncurried manner
06:23:21 <kmc> > map (\x -> x * 10) [1,2,3]  -- equivalently, no section
06:23:21 <lambdabot>   [10,20,30]
06:24:38 <kmc> for very small functions, explicit names for the function and/or its arguments are a distraction
06:25:02 <cheater99> chrisdone: i'm not sure what you're saying there
06:25:02 <kmc> (* 10) is a better name than multiplyByTen, and is more readable than \x -> x * 10
06:25:22 <kmc> "multiply by 10" versus "take an argument, call it x, and return x times 10"
06:25:23 <zygoloid> rfh: ok. unzip is pulling apart the pairs it's given, and zipp is putting them back together again. how might that go wrong?
06:25:49 <zygoloid> rfh: put another way, what thing of type (a, b) can't be pulled apart and put back together again?
06:25:52 <kmc> cheater99, i gave you the translation from sections to lambda abstractions already
06:25:52 <AAIBB^> im trying to compute how often sequence ''foo'' occurs in ''bar''.. But i still cant figure out how to select a middle section of bar and compare it to foo
06:25:55 <chrisdone> cheater99: what is a lambda abstraction in haskell?
06:25:59 <cheater99> kmc: yeah
06:26:10 <cheater99> chrisdone: well, i know what a lambda expression is
06:26:27 <kmc> "lambda abstraction" means the same thing as "lambda expression"
06:26:29 <chrisdone> cheater99: they mean the same thing
06:26:37 <cheater99> chrisdone: i'm not sure what a lambda abstraction is or how i'd replace an arbitrary piece of code with it
06:26:38 <cheater99> oh ok
06:26:50 <rfh> zygoloid: i have problems interpreting the "what thing of type (a,b)"
06:26:55 <cheater99> so how would i generally perform the action of 'replacing X with a lambda abstraction'?
06:27:27 <kmc> cheater99, where X is a section, it's simple
06:27:28 <zygoloid> rfh: ok. suppose unzip is given a (possibly infinite) list [(a1, b1), (a2, b2), ...]
06:27:42 <rfh> zygoloid:right
06:27:49 <zygoloid> rfh: can zipp (unzip xys) be anything other than xys in that case?
06:27:53 <chrisdone> cheater99: well, how do you write a function that multiplies a number by itself?
06:28:24 <zygoloid> rfh: (if you want to take it in steps, what is unzip xys? and what does zipp produce on that?)
06:28:28 <cheater99> i would do f x = x * x simply
06:28:47 <chrisdone> cheater99: so how do you write that as a lambda expression?
06:28:56 <kmc> f = ...
06:29:05 <cheater99> or: \x -> x*x
06:29:16 <Jafet> join (*)!
06:29:20 <cheater99> (i guess?)
06:29:29 <cheater99> my lambda calculus is a bit rusty.
06:29:35 <chrisdone> cheater99: so you've replaced one expression with an equivalent lambda expression. good
06:29:42 <cheater99> ok, phew
06:29:44 <rfh> zygoloid: unzip xys will be in this case undfined
06:29:44 <chrisdone> @src ($)
06:29:44 <lambdabot> f $ x = f x
06:30:03 <kmc> «let f x = x * x in f» should be an equivalent expression to «\x -> x * x»
06:30:13 <zygoloid> rfh: why will that be the case?
06:30:18 <chrisdone> cheater99: so how do you replace ($ 3) in map ($ 3) [succ]?
06:30:21 <rfh> zygoloid: based on pattern matching
06:30:22 <cheater99> so yeah, doing ? x for any infix operator ? is just the same as x ? x. ok, i get it
06:30:28 <cheater99> chrisdone: hm
06:30:29 <kmc> no it's not
06:30:34 <kmc> cheater99, i gave you the translation above
06:30:41 <kmc> <kmc> (+ x) is shorthand for \y -> y + x
06:30:42 <chrisdone> let him figure it out
06:30:43 <cheater99> kmc: oh, just a sec, yes, of course
06:30:44 <rfh> zygoloid: haskell tries to go through an infinite list
06:30:46 <kmc> <kmc> (x +) is shorthand for \y -> x + y
06:30:55 <cheater99> thanks for correcting me on that
06:31:06 <rfh> zygoloid: and gives back one value
06:31:14 <zygoloid> rfh: yes, but unzip is lazy. it doesn't need to go to the 'end' of the list before it can start producing results.
06:31:45 <zygoloid> > take 10 $ unzip [(a, b) | a <- [0..], b <- [0..]]
06:31:46 <lambdabot>   Couldn't match expected type `[a]'
06:31:46 <lambdabot>         against inferred type `([t], [t1...
06:32:02 <rfh> zygoloid: hmm indeed, havn't considered that
06:32:24 <zygoloid> > (take 10 &&& take 10) $ unzip [(a, b) | a <- [0..], b <- [0..]]
06:32:26 <lambdabot>   Couldn't match expected type `[a]'
06:32:26 <lambdabot>         against inferred type `([t], [t1...
06:32:30 <zygoloid> ;(
06:32:36 <cheater99> ok so, $ 3 is a function that is shorthand for \y -> y $ 3 and then we calculate [succ $ 3, pred $ 3]    which just evaluates to [succ 3, pred 3] so [4, 2]
06:32:37 <zygoloid> > (take 10 *** take 10) $ unzip [(a, b) | a <- [0..], b <- [0..]]
06:32:39 <lambdabot>   ([0,0,0,0,0,0,0,0,0,0],[0,1,2,3,4,5,6,7,8,9])
06:32:52 <zygoloid> better :)
06:32:53 <kmc> cheater99, yes :)
06:32:54 <rfh> zygoloid: so it produces ([a0,a1,....],[b0,b1,....])
06:32:58 <cheater99> yeah
06:33:00 <zygoloid> rfh: yes.
06:33:01 <cheater99> perfect
06:33:03 <cheater99> thanks guys
06:33:04 <cheater99> :)
06:33:18 <kmc> > zipWith ($) [succ, pred] [7,3]
06:33:19 <lambdabot>   [8,2]
06:34:39 <cheater99> aha
06:35:09 <rfh> zygoloid: and zipp gets the this particular result and will but it together assuming all the elements of [a0,a1,...] have the same type as well as those of [b0,b1,...]
06:36:20 <zygoloid> rfh: yes (in fact, we know that all the elements of [a0,a1,...] must already have the same type because otherwise they couldn't be given as arguments to unzip, and couldn't be in a list together)
06:38:10 <rfh> zygoloid: yes, i understand
06:38:39 <aristid> kmc: that basically cries "Applicative" :D
06:38:52 <aristid> except that the ZipList constructor makes it akward to use :/
06:39:23 <aristid> > runZipList $ ZipList [succ, pred] <*> ZipList [7, 3]
06:39:24 <lambdabot>   Not in scope: `runZipList'
06:39:43 <zygoloid> rfh: ok, so if the input list is of the form [(a1, b1), (a2, b2), ...], then the output must be the same.
06:39:48 <aristid> > getZipList $ ZipList [succ, pred] <*> ZipList [7, 3]
06:39:49 <lambdabot>   [8,2]
06:40:01 <rfh> zyogloid: ya
06:40:20 <zygoloid> rfh: so we want to find an input list which is not of that form. there are basically two different ways of doing that; both involve undefined / _|_. any ideas what they are?
06:41:39 <rfh> zygoloid: what means "/" in "undefined / _|_" ?
06:41:45 <aristid> hmm. if (:) were a class method
06:41:47 <soupdragon> I'm confused
06:41:50 <aristid> and [] used that class
06:41:51 <soupdragon> do molecules vibrate?
06:41:52 <aristid> that would be cool
06:41:59 <soupdragon> how is that not infinite free energy
06:42:39 <Zao> soupdragon: "heat'?
06:42:40 <kmc> because it's not infinite soupdragon
06:42:41 <Ke> because there is no know way of utilizing that energy
06:42:51 <Ke> known
06:42:52 <soupdragon> so it's liike quantum physics?
06:42:57 <soupdragon> in someways
06:43:18 <kmc> you don't need to involve quantum
06:43:31 <kmc> you can't use movements in random unknown directions to do useful work
06:43:43 <kmc> because you don't know where to put the thing those molecules need push against
06:44:00 <djahandarie> Did ##physics just leak into #haskell ?
06:44:16 <zygoloid> rfh: "or". what i really mean is, we should be thinking about _|_ here, rather than "undefined". undefined is a specific binding which denotes _|_.
06:44:19 <kmc> soupdragon, there is an astoundingly deep connection between thermodynamics and information theory
06:44:23 <Ke> what's hte deal with double #
06:44:36 <Ke> the
06:44:37 <zygoloid> ## channels have special freenode blessing
06:44:43 <soupdragon> I don't understand thermodynamics :(
06:44:44 <djahandarie> ...
06:44:46 <soupdragon> or information
06:45:05 <benmachine> I thought ## was random-unofficial
06:45:07 <Jafet> djahandarie, the wavefunction collapsed into a universe where this is the quantum pseudophysics speculation channel
06:45:23 <aristid> Ke: ## is for non-owned channels. #x is the official channel for x. for physics, there cannot be an official channel
06:45:26 <zygoloid> benmachine: hmm, maybe i have it backwards
06:45:32 <djahandarie> Hahaha
06:45:33 <kmc> #physics: blessed by god himself
06:45:38 <kmc> this discussion reminds me of quantum mechanics
06:45:40 <Jafet> I was kidding with you. It's just soupdragon trolling again
06:45:40 <aristid> Ke: however, not all channels abide by that, and some unofficial channels use only a single 
06:45:41 <aristid> #
06:46:09 <djahandarie> It'd make more sense if we were talking about quantum computing :-)
06:46:09 <soupdragon> so what's the connnection
06:46:17 <soupdragon> and does it have to do with brownian motion
06:46:31 <soupdragon> btw when everything is the same temperater what would that temperature be?
06:46:42 <djahandarie> I think someone modeled quantum computing in Haskell
06:46:55 <soupdragon> @go Structure and Interpretation of Quantum Mechanics haskell
06:46:56 <lambdabot> Maybe you meant: google googleit do
06:46:59 <kmc> soupdragon, explaining the connection is beyond my pay grade
06:47:09 <kmc> you've got plenty to read if you wish
06:47:38 <soupdragon> such as
06:47:46 <kmc> information theory, thermodynamics
06:48:01 <kmc> i'm sorry, i can't recommend specific books or papers or articles
06:48:33 <kmc> perhaps MIT OpenCourseware or another school offers a useful curriculum
06:48:43 <danharaj> What is the question?
06:48:56 <kmc> how thermodynamics and information theory relate
06:49:06 <derdon> the question is: what is the question?
06:49:19 <rfh> zygoloid: ok. zipp(unzip [(_|_,_|_)] )->zipp([_|_],[_|_])-> _|_ ?
06:49:37 <danharaj> That's simple: The equation for thermodynamic entropy and the equation for information entropy are the same :p
06:49:45 <soupdragon> lol
06:49:49 * danharaj </flippant>
06:49:55 <derdon> rfh: what's the difference between zip and uipp?
06:49:59 <mreh> I'm trying to load modules into GHCi that have been compiled with cabal build, but for some reason GHCi insists on reading from the src dir and not the build directory
06:50:04 <derdon> rfh: I meant between zip and zipp
06:50:26 <kmc> soupdragon, one bit of intuition i've picked up is that you can get more work out of a system if you know more about it
06:50:28 <rfh> derdon: currying
06:50:40 <derdon> rfh: I see
06:50:42 <mreh> e.g. ghci -idist/build/autogen:src:dist/build/oo/Foo-tmp/
06:50:47 <derdon> mhhh..., curry
06:50:53 <rfh> derdon: zipp=uncurry zip
06:50:59 <kmc> if all you have is some atoms vibrating in random unknown ways, you can't do much of anything
06:51:11 <zygoloid> rfh: no. zipp (unzip [(_|_, _|_)]) -> zipp ([_|_], [_|_]) -> [(_|_, _|_)]
06:51:17 <soupdragon> what if you are maxwells demon
06:51:27 <zygoloid> rfh: _|_ is denotationally a value, so that matches the [(a1, b1)] case we've already decided is ok
06:51:36 <rfh> zygoloid: ok
06:51:39 <kmc> then you're taking in energy equal to or greater than the amount to compensate for your local decrease in entropy
06:51:40 <danharaj> Maxwell's demon has to expend energy to measure the momentae of particles.
06:51:49 <rfh> zygoloid: i see
06:52:15 <mreh> does this relate to haskell?
06:53:10 <zygoloid> rfh: i'll give you a further clue. i said there are two ways we can escape the [(a1, b1), ...] form.
06:53:36 <zygoloid> rfh: one of them (the one you don't want to use) works as follows:
06:54:04 <zygoloid> rfh: [(a1, b1), (a2, b2), ...] is really just syntactic sugar for (a1,b1) : (a2, b2) : ...
06:54:17 <zygoloid> rfh: suppose instead we used (a1, b1) : undefined
06:54:18 <rfh> zygoloid: ya
06:54:30 <chrisdone> is there a GHC message that will warn you that you forgot to include an export list?
06:55:03 <zygoloid> what happens then?
06:55:26 <mreh> huh?
06:57:09 <rfh> zygoloid: unzip only can match a1 and b1 to [a1,...],[b1,...]
06:57:35 <mreh> boohoo
06:59:00 <rfh> zygoloid: but (_|_),(_|_) is not equal to _|_ as assumed
06:59:13 <rfh> in which case the inpute is not valid for unzip
06:59:26 <rfh> because it s not a pair
07:00:06 <zygoloid> rfh: remember that undefined is a value of all types. including pairs and lists.
07:00:14 <zygoloid> rfh: so there's no type error here.
07:00:25 <rfh> zygoloid: i see
07:01:09 <zygoloid> unzip sees (a1, b1) : undefined, and that matches its pattern: unzip (a, b):abs = (a:as, b:bs) where (as, bs) = unzip abs
07:02:10 <rfh> so unzip (a1,b1):undefined:[] = [a1,undefined],[b1,undefined]
07:02:58 <zygoloid> more-or-less, yes
07:03:55 <rfh> the more-or-less points to some irrelevance of my last conclusion to the problem
07:03:56 <zygoloid> actually, unzip is slightly stricter than it needs to be, and you get unzip [(a1, b1), undefined] = (a1:undefined, b1:undefined)
07:04:09 <zygoloid> rfh: you're on exactly the right lines
07:05:00 <zygoloid> the difference between (a1:undefined) and [a1, undefined] is that the latter is a list of two elements. the former is a list of one element. the latter doesn't have a defined length.
07:05:01 <rfh> because the right lines are brought before me :)
07:06:16 <zygoloid> rfh: ok, so what do you think zipp will produce when given (a1:undefined, b1:undefined)?
07:06:20 <rfh> (a1:undefined:[]) should the former be right?
07:06:47 <zygoloid> rfh: yes. but (a1:undefined:[]) == [a1, undefined]
07:08:18 <rfh> zygoloid: how is (a1:undefined ) a list of one element?
07:09:10 <aristid> rfh: it is a list of bottom elements
07:09:25 <aristid> > length (0:undefined)
07:09:26 <lambdabot>   *Exception: Prelude.undefined
07:09:36 <rfh> aristid: element>>s<<
07:09:41 <yitz> rfh: a list of length at least 1, but whose exact length is undefined.
07:09:51 <rfh> yitz: i see
07:10:59 <kmc> yeah, Haskell lists can have weird lengths
07:11:13 <kmc> such as "finite iff the Riemann Hypothesis holds"
07:11:16 <rfh> zygoloid: so laziness will produce at least [a1,...],[b1,...]
07:11:32 <soupdragon> Riemann zeta function
07:11:39 <rfh> let me say assure not produce
07:12:08 <Jafet> Wait till you try to use those lists in agda
07:12:20 * chrisdone waits
07:12:54 <kmc> soupdragon, ok
07:13:33 <soupdragon> ?
07:14:24 <kmc> why did you say 'Riemann zeta function'
07:15:58 <kmc> . o O ( Ζζζζζζζζ )
07:16:12 <zygoloid> rfh: well, unzip actually produces something which can't be expressed in the [a1, ...] notation.
07:17:23 <zygoloid> rfh: but yes, the lists which unzip produces will have first elements a1 and b1
07:17:27 <rfh> zygoloid: so zipp has no valid input?
07:18:02 <zygoloid> rfh: well, it depends what you mean by "valid". the input isn't fully-defined, but it is the right type at least.
07:19:11 <rfh> zygoloid: but is defined enough for zipp to produce the first elements [a1,..],[b1,...]
07:19:52 <zygoloid> yes. zipp will produce (a1,b1): ... and then go wrong.
07:20:08 <zygoloid> where "go wrong" means it'll look at the undefined second elements in the input lists
07:20:39 <zygoloid> > uncurry zip (1:undefined, 2:undefined)
07:20:40 <lambdabot>   [(1,2)*Exception: Prelude.undefined
07:20:51 <rfh> zygoloid: i see. go wrong and gives back undefined, which is not equal to the first input (a1,b1):undefined
07:21:41 <zygoloid> almost. we get: (a1,b1):undefined -> (a1:undefined, b1:undefined) -> (a1,b1):undefined.
07:22:07 <zygoloid> i said there were two ways we could avoid the [(a1, b1), ...] form. one of them is replacing the tail of the list by undefined
07:22:14 <zygoloid> the other is replacing one of the pairs in the list by undefined
07:22:19 <ejt> anyone here used chp much ?
07:24:38 <rfh> zygoloid: (undefined,b1):(a2,b2)->(undefined:a2,b1:b2)
07:25:52 <zygoloid> (a1,b1):undefined:[] -> (a1:undefined, b1:undefined) -> (a1,b1):undefined
07:26:03 <McManiaC> ~(a,b) <- foo -- what is that ~ ?
07:26:08 <zygoloid> McManiaC: lazy pattern
07:27:05 <zygoloid> McManiaC: it means, assume that the pattern matches, but don't actually deconstruct the pair until a or b is forced
07:27:15 <McManiaC> okay
07:27:45 <kmc> > let ~(a,b) = undefined in ()
07:27:46 <lambdabot>   ()
07:27:48 <kmc> > let (a,b) = undefined in ()
07:27:49 <lambdabot>   ()
07:27:53 <kmc> let bindings are lazy either way
07:27:55 <rfh> zygoloid: above you wrote (a1,b1):undefined -> (a1:undefined, b1:undefined) -> (a1,b1):undefined. but its actually (a1,b1):undefined:[] -> (a1:undefined, b1:undefined) -> (a1,b1):undefined. right?
07:28:00 <kmc> > case undefined of ~(a,b) -> ()
07:28:00 <lambdabot>   ()
07:28:01 <kmc> > case undefined of (a,b) -> ()
07:28:02 <lambdabot>   *Exception: Prelude.undefined
07:28:13 <justin_> does haskell have anything like f#'s quotations, also does haskell have any sort of reflection api so that I can get rid of some of the boilerplate associated with serializing models from an html form post?
07:28:14 <aristid> > let ~(a,b) = undefined in ()
07:28:14 <lambdabot>   ()
07:28:19 <aristid> > let ~(a:b) = undefined in ()
07:28:20 <lambdabot>   ()
07:28:48 <zygoloid> rfh: i think both of those are correct.
07:29:00 <kmc> justin_, how do f#'s quotations work?
07:29:17 <zygoloid> rfh: the difference between undefined and undefined:[] is important here.
07:29:22 <kmc> justin_, you may want to read about Template Haskell
07:29:26 <kmc> see http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/template-haskell.html
07:29:28 <rfh> zygoloid: yes i meant that
07:29:36 <kmc> and in particular the last section, if you want to define new quoting syntax
07:30:01 <rfh> zygoloid: undefined:[] is a well-defined list
07:30:05 <justin_> kmc: you can decorate methods with an attribute/or declare quotations programatically to get the AST of a particular piece of code, which lets you do transforms/etc on the ast
07:30:12 <kmc> yes, that sounds like TH
07:30:12 <BMeph> > uncurry zip ([],undefined)
07:30:13 <lambdabot>   []
07:30:16 <BMeph> > uncurry zip (undefined,[])
07:30:17 <lambdabot>   *Exception: Prelude.undefined
07:30:20 <kmc> it's not pretty, but it is very powerful
07:30:56 <BMeph> Don't forget argument strictness, which also effects resolution.
07:31:14 <kmc> justin_, as for datatype-generic programming without metaprogramming, read about Data.Typeable, Data.Data, Scrap Your Boilerplate, Uniplate, multirec, etc.
07:31:32 <aristid> :t uncurry zip
07:31:33 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
07:31:38 <zygoloid> rfh: yes. so of those two reductions, the first one is ok, but the second one violates zipp (unzip xys) == xys (where == is denotational equality)
07:31:41 <kmc> we don't always have to generate code in order to write generic traversals
07:31:59 <aristid> :t uncurry zip . unzip
07:32:00 <lambdabot> forall a b. [(a, b)] -> [(a, b)]
07:34:57 <justin_> kmc: i guess my real question is, would it be possible to make a web framework that handled the model binding for you?  As in I write a method and decorate it's type and a form post would automatically hit my method and populate that methods argument automatically
07:35:58 <justin_> kmc: I'll be reading up on those topics, but I'd like to know how possible my ideal api would be
07:36:12 <kmc> yes, i think it's possible
07:36:42 <kmc> in that what you describe is computable
07:36:48 <kmc> as to how tricky
07:36:54 <kmc> i think it could be accomplished with TH
07:37:03 <kmc> external preprocessors / code generators are another option
07:37:20 <kmc> we have libraries to parse, print, and manipulate haskell code
07:37:47 <rfh> zygoloid: anyway, thank you for your kind patience
07:38:03 <kmc> justin_, much of the marshalling could be accomplished just using type classes
07:40:12 <kmc> you could define the class of function types which can be converted to form handlers
07:40:32 <kmc> in such a way that those functions can have any number of arguments selected from an appropriate set of marshallable types
07:40:35 <justin_> kmc: I'm guessing that this would be a pain to accomplish, all of the frameworks I've looked up for haskell don't have anything like it.  As an example of a non-web based framework that would benefit from a cleaner api like this is the haskell mongodb driver: http://github.com/srp/mongoDB/blob/master/tutorial.md
07:40:57 <justin_> kmc: there's a lot of boilerplate involved in using that mongodb api from the examples they've given
07:41:04 <kmc> yeah
07:41:39 <kmc> there are tradeoffs though
07:42:24 * ksf likes IxSet as database
07:42:25 <kmc> boilerplate is obnoxious but can be easier to understand and provide better static checking than a magical "do what i mean" class / macro / etc.
07:42:36 <ksf> but then I never did any serious large-scale stuff
07:42:43 <kmc> in Haskell we try to have our plate and eat it too
07:42:48 <kmc> using things like inference to get checking implicitly
07:42:51 <kmc> but it only goes so far
07:43:15 <ksf> and I think the storage part of happs doesn't depend on the web stuff
07:43:23 <justin_> kmc: lol, well I'm not really sure I'd want to use it for daily stuff if most of what I'm doing is writing boilerplate that is easily abstracted out in other languages
07:43:47 <kmc> justin_, by "it" you mean Haskell?
07:44:06 <justin_> kmc: yeah, i'm not knocking on haskell I think it's very elegant from the stuff I've read so far
07:44:09 <ksf> if it's just about automating the common away without outlawing rare magic, TH is your friend.
07:44:13 <justin_> kmc: I just can't stand boilerplate
07:44:19 <kmc> neither can i
07:44:23 <kmc> and Haskell is my favorite language
07:44:31 <kmc> which isn't to say there's never any boilerplate
07:44:42 <kmc> it is easier to get rid of boilerplate with quick hacks in very dynamic languages
07:45:06 <kmc> but i think the haskell tradeoff between power, conciseness, and safety is very good
07:45:12 <kmc> how much Haskell do you know justin_?
07:45:41 <justin_> kmc: not a whole lot, I know a bit of F# and am about 30% of the way through don symes haskell book
07:45:50 <ksf> what's that :{ :} syntax they're using there?
07:46:17 <mreh> is there no step-over or step return in ghci
07:46:49 <justin_> kmc: ideally i'd like to move to haskell for my hobby web dev projects, but I can't find a decent framework for it that handles common scenarios
07:47:09 <justin_> kmc: I would consider making one, but it sounds like it would be a pain to create the proper abstractions
07:47:13 <kmc> which book is that justin_
07:47:30 <ksf> ...and if you think you're writing boilerplate, have a look at http://github.com/srp/mongoDB/blob/master/Database/MongoDB/BSON.hs
07:47:39 <kmc> justin_, i expect it would be about as hard as in F#
07:47:59 <justin_> kmc: i didn't mean don syme
07:48:05 <justin_> kmc: I meant donald stewart
07:48:08 <kmc> ah
07:48:09 <justin_> kmc: real world haskell
07:48:11 <kmc> Real World Haskell?
07:48:11 <kmc> yes
07:48:13 <kmc> that's a great book
07:48:34 <justin_> kmc: well, f# has a reflection api
07:48:54 <justin_> kmc: so it's actually pretty easy to setup a framework that deals with model binding (serialization)
07:49:19 <ksf> haskell uses TH for such tasks
07:49:25 <kmc> and SYB and other things
07:49:42 <ksf> data-reify
07:49:43 <kmc> justin_, note that when i said there's a tradeoff between straightforward boilerplate and fancy do-what-i-mean system
07:49:45 <justin_> kmc: I guess i'll just have to continue down the rabit hole till I figure those out
07:49:47 <kmc> i mean there's a tradeoff in the language
07:49:52 <kmc> i.e. both can be realized in Haskell
07:50:00 <kmc> but you may not want to be ultra-clever
07:51:07 <kmc> for example Haskell's Text.Regex.Base has this fancy API which is overloaded all sorts of ways so you just use this one operator and it's supposed to magically figure out what you want
07:51:14 <kmc> which i find an incomprehensible pain in the ass
07:51:19 <kmc> i'd rather just specify what i want by name
07:51:25 <kmc> so, ymmv
07:51:40 <RoaldFre> Guys, I have a question about xmonad. I would like to map a key(combination) to swap keyboard layouts (azerty and dvorak). I would have to remap the "direction" keys (hjkl) to the dvorak equivalent every time I swap layout. This seems like I need to keep a state (as in: the current layout), how would I go about this? (I have some basic haskell knowledge)
07:52:36 <kmc> RoaldFre, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-IORef.html
07:52:46 <kmc> IORefs are mutable reference cells manipulated from the IO monad
07:53:00 <kmc> you can execute IO actions from the X monad
07:53:05 <justin_> kmc: abstractions are pretty hard to get right in any language I think, not using any abstractions makes things to painful to bother with
07:53:10 <ezyang> RoaldFre: Try #xmonad 
07:53:28 <kmc> yeah
07:53:39 <RoaldFre> ezyang: oh, sorry, didn't know
07:53:50 <kmc> you can create your IORefs in main before you call xmonad's main, and pass them to the function which computes your key hooks
07:53:51 <ksf> RoaldFre, I've got a simpler solution: bind one key to change to dvorak, and one key to change to qwerty, which happen to be on the same physical key.
07:53:53 <kmc> justin_, agreed
07:53:55 <ezyang> Although, rereading your question, it could be more widely applicable to #haskell 
07:54:29 <ksf> RoaldFre, I've got a shell alias "aoeu" to switch to qwerty, and asdf to switch to dvorak.
07:54:36 * kmc too
07:55:35 <ksf> oh, and I use hjkl with dvorak, btw.
07:55:43 <roconnor> ksf: do we have deriving Traversable yet?
07:55:49 <triyo> Hm, I'm new to haskell type classing feature. I get this error: Ambiguous type variable `a' in the constraint:       `TagParseable a' .. here is the relevant code snippet: http://gist.github.com/458754
07:55:59 <ksf> isn't data sufficient?
07:56:00 <RoaldFre> ksf: haha, that two-keys option is brilliant :). I would have to do it in xmonad though, and not in the shell, because I cannot live without hjkl on the correct finger positions :)
07:56:24 <kmc> justin_, but there's more dimensions to it
07:56:46 <kmc> Haskell tends to favor abstract but explicit
07:57:08 <Botje> triyo: which code is causing it? cmdtodo?
07:57:08 <kmc> you describe what you want using a set of primitives and combining functions
07:57:16 <kmc> sometimes called a "combinator library" or a "domain-specific language"
07:57:32 <kmc> and hopefully this is a small description because your library is powerful
07:57:47 <ksf> RoaldFre, for real xmonad help, there's #xmonad
07:57:48 <kmc> and since they're ordinary values you can abstract over them, and compute them in various ways
07:58:06 <kmc> but you're still saying explicitly what you want, rather than doing lots of reflection magic
07:58:29 <triyo> Botje: strange, its not giving me a line number.. I'm running it via ghci
07:59:13 <Botje> can you show the full code?
07:59:22 <triyo> sure, one sec
07:59:56 <abuiles> Hi Guys, does someone know why System.Timeout  do not work in Windows ? ( or at least is not working in my machine :( )
08:00:14 <ksf> fmap (rotate (2*pi)) (circle (0,0) 1 <|> triangle (1,1) (2,2) (3,3))
08:00:39 <kmc> abuiles, it uses threads internally; are you building with ghc -threaded ?
08:00:41 <aristid> ksf: what does <|> do on shapes?
08:00:49 <ksf> hmmm
08:01:00 <triyo> Botje: http://gist.github.com/458754
08:01:01 <ksf> guess I should've looked up a shape combinator library first.
08:01:23 <ksf> I would say place them next to each other
08:01:34 <cheater99> if i do `f = \x -> x*x` and `f x = x*x`, then will they compile to the exact same thing?
08:01:40 <ksf> <-> being on top of each other
08:01:58 <Botje> triyo: is the commented-out section giving you trouble?
08:02:13 <roconnor> cheater99: in may cases
08:02:17 <roconnor> in many cases
08:02:21 <roconnor> in most cases even
08:02:35 <triyo> Botje: no, it seems to be the TagParseable class type or its instance
08:02:39 <cheater99> when would they not?
08:02:49 <kmc> cheater99, on the whim of your compiler
08:02:56 <roconnor> (the stupid monomorohpismrestriction may infer different types for those functions)
08:03:08 <kmc> this thing we call "Haskell" makes no guarantees about what anything compiles to
08:03:22 <tafryn> RoaldFre: Since restarting/recompiling xmonad isn't too expensive couldn't you just have one config with azerty keys and another with dvoark keys? Then have a switch function in each that restarts xmonad with the other config. 
08:03:24 <cheater99> ok so function definitions are not just syntactic sugar on top of lambda expressions?
08:03:32 <ksf> ...and that's one of the reason why it should be tared and feathered.
08:03:33 <kmc> they are
08:03:41 <kmc> except there's this monomorphism restriction
08:04:02 <kmc> which is a restriction on "let" bindings, and likewise top-level bindings
08:04:03 <Botje> let me try for a bit :)
08:04:03 <roconnor> cheater99: oh, they are syntatic suger ... except for the monomorphismrestriction thingy
08:04:25 <kmc> that applies when you say "let f = ..." but not "let f x = ....", regardless of what's on the RHS
08:04:41 <roconnor> cheater99: if you give explicit type signatures, then they will be the same.
08:04:44 <cheater99> the what?
08:04:48 <kmc> cheater99, but my point is more that questions about whether things compile to the same exact code are questions about a particular version of a particular compiler with particular settings
08:04:55 <kmc> it's not a question about the language
08:05:25 <cheater99> yes
08:05:26 <cheater99> they are
08:05:29 <cheater99> i know that
08:05:30 <roconnor> kmc: are you sure?
08:05:32 <triyo> Botje: is there nothing obvious wrong? Thought it might be noobie error
08:05:37 <kmc> am i sure about what
08:05:59 <mreh> exciting: "ghc: internal error: evacuate: strange closure type 31668"
08:06:04 <kmc> @ghc
08:06:04 <lambdabot> ghc says: scavenge: unimplemented/strange closure type
08:06:05 <triyo> it seems that the compiler doesn't have enough info to determine what 'a' is meant to be.
08:06:09 <roconnor> kmc: haskell 98 seems to define a lot in terms of program transforamtions.  I'm not sure how strict the report says to interpret these transformations.
08:06:34 <Botje> triyo: if you know which function causes it we can look in detail
08:06:47 <roconnor> kmc: Normally I'd agree with you; however the Haskell 98 report continues to surprise me
08:07:04 <kmc> roconnor, my understanding is that people interpret it mostly as a denotational semantics
08:07:26 <kmc> and the sugars are sometimes described as "The following identity holds:"
08:07:36 <roconnor> that's how people mostly interpret it, but I'm not certain that is acutally what it says :)
08:07:44 <RoaldFre> tafryn: that seems a bit brutal to me. Also, I'd rather not have GHC in my cache all the time when that memory can be put to other use. I think I'll go for the different-key-same-position solution.
08:08:01 <kmc> which seems fairly weak -- an extensional equivalence of programs
08:08:04 <kmc> but, i'm not sure
08:08:06 <kmc> let's call some lawyers
08:08:22 <triyo> Botje: unfortunately, this is the error I get: http://gist.github.com/458770
08:08:42 <RoaldFre> tafryn: sry, I'll swap to #xmonad
08:08:50 <kmc> you could have two xmonad binaries and switch between them without recompiling
08:08:58 <abuiles> kmc:  with -threaded should work ?
08:09:02 <cheater99> thanks guys
08:09:03 <roconnor> kmc: ah you are right.  The H98 report uses the words "semantically equivalent"
08:09:06 <kmc> abuiles, not sure, it's something to try
08:09:08 <kmc> roconnor, where?
08:09:20 <abuiles> kmc: thanks :).. I will check it out 
08:09:25 <roconnor> kmc: 4.4.3.1.Translation
08:09:28 <Botje> triyo: oh. you need to give an explicit type
08:09:39 <kmc> ah yeah
08:10:12 <roconnor> kmc: which I read as "dentoational" semantically equivalent
08:10:31 <roconnor> since the idea of it meaning "operational" semantically equivalent would be absurd, ... right?
08:10:38 <roconnor> ...
08:10:41 <roconnor> stupid abiguity
08:11:24 <kmc> it'd be absurd because the report is mostly silent on operational issues?
08:11:51 <kmc> perhaps Haskell 2012 should be formal semantics specified as an Agda module
08:11:53 <roconnor> ya
08:12:08 <kmc> and then we can rewrite GHC in Agda, prove it's correct, and extract it to Haskell code for efficient compilation
08:12:14 <roconnor> I still think formal H98 IO semantics are doable.
08:12:27 <roconnor> H98 IO isn't very complicated
08:12:32 <roconnor> no threads
08:12:32 <Botje> triyo: so parseTagEntry .... :: Either TagEntryError Foo
08:12:47 <Botje> or, uh, TodoEntry in your case
08:13:06 <danharaj> @src forever
08:13:06 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:13:27 <ezyang> kmc: It'll be grrrrreat! 
08:14:50 <roconnor> @type forever
08:14:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:15:19 <roconnor> @pl \a -> fix (a >>)
08:15:20 <lambdabot> fix . (>>)
08:15:27 <roconnor> @type (fix . (>>)).
08:15:28 <lambdabot> parse error (possibly incorrect indentation)
08:15:29 <roconnor> @type (fix . (>>))
08:15:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:16:34 <djahandarie> @pl \a -> a >> forever a
08:16:35 <lambdabot> ap (>>) forever
08:16:43 <djahandarie> pl should know about fix
08:17:06 <roconnor> djahandarie: what you wrote isn't recursive
08:17:29 <roconnor> @pl (\f -> let a = f a in a)
08:17:29 <lambdabot> fix
08:17:43 <djahandarie> Oh
08:17:49 <djahandarie> Huh
08:17:57 <djahandarie> Oh haha
08:18:33 <roconnor> @pl (\x -> f x x) (\x -> f x x)
08:18:33 <lambdabot> join f (join f)
08:18:53 <roconnor> @pl \f -> (\x -> f x x) (\x -> f x x)
08:18:54 <lambdabot> ap join join
08:18:56 <roconnor> heh
08:19:07 <roconnor> well, that's what you get for not being typable
08:20:11 * roconnor didn't realize that Y = SWW
08:20:18 <djahandarie> @pl let f = (\a -> a >> f a) in f
08:20:19 <lambdabot> fix (ap (>>))
08:22:05 <djahandarie> @. pl undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:22:06 <lambdabot> liftM2
08:22:10 <djahandarie> -_-
08:22:25 <hpc> haha
08:22:45 <djahandarie> @. pl undo \f m1 m2 m3 -> do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
08:22:45 <lambdabot> flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=)) . (((return .) .) .)
08:22:57 <roconnor> liftM3
08:23:00 <djahandarie> :P
08:23:40 <djahandarie> @pl f <$> a <*> b
08:23:41 <lambdabot> f <$> a <*> b
08:23:46 <djahandarie> @pl \f a b -> f <$> a <*> b
08:23:46 <lambdabot> (. (<*>)) . (.) . (<$>)
08:25:52 <hpc> :t liftA
08:25:52 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
08:26:07 <hpc> :t liftA2
08:26:08 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:26:40 <djahandarie> Yeah
08:26:45 <djahandarie> Just wanted to see if pl knew about it
08:26:49 <hpc> isn't there a default instance for applicative from monad?
08:30:40 <RoaldFre> I'm still struggling with my xmonad here. Is there a way to change the definition of a function at runtime? That way I could map something to the key "keyFunc" and I could somehow change the definition of that function at runtime (seems veeeeery unlikely; and I'm probably going about this all wrong)
08:31:58 <djahandarie> RoaldFre, you can't "change the definition of the function" at runtime, but you can make it read off of some state which changes
08:33:16 <RoaldFre> djahandarie: but wouldn't that require it to have an IO type? (I don't think that will fit within the xmonad framework)
08:33:54 <Axman6> not necessarilly
08:34:23 <djahandarie> RoaldFre, xmonad is just really a monad transformer stack
08:34:25 <byorgey> RoaldFre: see my responses in #haskell
08:34:31 <byorgey> er, in #xmonad
08:34:35 <djahandarie> The X monad is StateT + ReaderT
08:34:50 <djahandarie> But yeah go to #xmonad they probably have a nice solution for you ;-)
08:34:58 <triyo> Botje: sorry I was away from my desk. I see what you mean. I see the problem now clearly. However that brings me to the next question then. parseTagEntry in my case is meant to be generic to apply to all instances of TagParsable.
08:35:03 <byorgey> StateT + ReaderT + IO
08:37:01 <ski> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
08:37:01 <lambdabot> ap (. join id) (. join id)
08:37:06 <ski> @pl (\x -> f (x x)) (\x -> f (x x))
08:37:10 <lambdabot> (f . ap id id) (f . ap id id)
08:37:10 <lambdabot> optimization suspended, use @pl-resume to continue.
08:37:23 <ski> @pl \f -> (\t -> t t) (\x -> f (x x))
08:37:23 <lambdabot> join id . (. join id)
08:38:05 <Axman6> @pl (\x -> f (x x)) (\x -> f (x x))
08:38:06 <ski> @pl (\x f -> f (x x f)) (\x f -> f (x x f))
08:38:08 <lambdabot> (f . ap id id) (f . ap id id)
08:38:08 <lambdabot> optimization suspended, use @pl-resume to continue.
08:38:09 <Axman6> @pl-resume
08:38:11 <lambdabot> (ap id . ap id id) (ap id . ap id id)
08:38:12 <lambdabot> optimization suspended, use @pl-resume to continue.
08:38:12 <Axman6> @pl-resume
08:38:17 <lambdabot> (ap id . ap id id) (ap id . ap id id)
08:38:17 <lambdabot> optimization suspended, use @pl-resume to continue.
08:38:19 <ski> @pl (\x f -> f (x x f)) (\x f -> f (x x f))
08:38:28 <lambdabot> Plugin `pl' failed with: thread killed
08:38:30 <ski> @pl (\t -> t t) (\x f -> f (x x f))
08:38:35 <lambdabot> Plugin `pl' failed with: thread killed
08:38:38 <lambdabot> ap id id (ap id . ap id id)
08:38:38 <lambdabot> optimization suspended, use @pl-resume to continue.
08:38:44 <ski> bah
08:40:04 <hpc> ski: does that even typecheck?
08:40:16 <ski> @tell roconnor `\f -> (\t -> t t) (\x -> f (x x))' (or `(\t -> t t) (\x f -> f (x x f))'), not `\f -> (\t -> t t) (\x -> f x x)'
08:40:32 <ski> hpc : not without using cyclic types
08:41:14 <ski> (one can get it to typecheck in Haskell, by inserting conversions to and from a recursive `newtype', though ..)
08:41:37 <lambdabot> Consider it noted.
08:42:09 <ski> hpc : if you have OCaml installed, then starting it with `ocaml -rectypes' enables cyclic types, so one can play with it that way, as well
08:42:24 <hpc> ah, k
08:42:59 <ski> (afaik, there's no corresponding flag for any Haskell implementation)
08:44:56 <ksf> any of ye proofmongers tried idris?
08:45:42 <ksf> it seems to be nicer than agda because it comes with a coq-like theorem prover and nicer than coq because it's actually designed to be a programming language 
08:46:03 <ksf> also, so far I didn't see any unicode. further plus points.
08:46:44 * jmcarthur likes unicode
08:46:54 <jmcarthur> lambdabot!
08:46:56 <soupdragon> more interested in the research papers than actually using it
08:48:40 <kosmikus> ksf: I've tried Idris a while ago. It's extremely promising.
08:48:49 <pastorn> @here pp
08:49:05 <pastorn> can i do ifdefs based on version of base?
08:50:07 <ksf> and considering that it's implemented in haskell, which has haskellline, I would expect the repl to have sane command-line editing.
08:50:08 <kosmikus> pastorn: I think that in Cabal, you can define CPP flags based on version of base, so at least indirectly it should be possible
08:50:42 <kosmikus> ksf: hmm, does Idris have a REPL? I don't remember.
08:51:05 <kosmikus> edwinb: can you answer that? ^^
08:51:09 <ksf> yep, cabal can autogenerate a file with all the package versions and flags used etc.
08:51:19 <aavogt> cabal defines some CPP macros for that purpose
08:51:36 <ksf> kosmikus, yes. I was litearally shocked as I read the tutorial and saw that it's got an interface just like coq.
08:52:02 <kosmikus> edwinb: never mind
08:52:05 <kosmikus> ksf: oh, I see
08:52:25 <kosmikus> I think I only used it in compile mode when I tried it
08:52:31 <ksf> not the agda-style "use emacs or fuck off"-thing.
08:52:48 <kosmikus> :)
08:53:35 * hackagebot speculation 0.8.1.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.8.1.0 (EdwardKmett)
08:55:19 <edwardk> (now with scan* and mapAccum(L|R))
08:56:44 * edwinb feels his ears burning
08:57:19 <edwinb> kosmikus: it does, but I imagine you saw that so said "never mind" ;)
08:57:51 <edwardk> pastorn: if nothing else you can add the -Define to your .cabal file based on the selected version of base
08:58:51 <kosmikus> edwinb: right, I saw that. is it relatively new, or have I just missed it before?
08:59:20 <edwinb> I think it's been there more or less from the start
08:59:40 <edwardk> flag base3\n  description: base 3; default: false; ..... if flag(base3) ghc-options: -DBASE3 else ghc-options: -DBASE4
08:59:46 <edwinb> kosmikus: It doesn't do I/O very well though
08:59:51 <edwardk> er cpp-options
09:00:27 <edwardk> (er with the build-depends: base < 4 and > 4 in each branch as well
09:00:33 <edwardk> er < and >=
09:01:08 <pastorn> edwardk: don't have a cabal file... i want to do it all inside the source code
09:01:19 <edwardk> pastorn: then you're screwed. ;)
09:01:38 <pastorn> fakk
09:01:48 <edwardk> pastorn: perhaps tempkate-haskell hijinks might be able to detect the presence or absence of some feature from base 3
09:02:02 <edwardk> but really, a cabal file isn't that bad ;)
09:02:50 <edwardk> and gets you a better build process anyways (since it can handle ghc-pkg lists that have multiple providers of the same package, etc)
09:02:57 <edwardk> er s/package/module
09:03:16 <aavogt> pastorn: what's the reason your code can't work for base-3 or base-4?
09:03:21 <aavogt> *and
09:03:30 <pastorn> edwardk: all i really want is to do 'import System.IO.UTF8; import Preluted hiding (String->IO-funs)'
09:03:49 <pastorn> aavogt: i use 6.10 for my job...
09:07:07 <edwardk> pastorn:  you could import qualified Prelude, or import Prelude (just the stuff you use)
09:12:57 <hpc> @hoogle TimerCallback
09:13:03 <hpc> lambdabot?
09:14:50 <djahandarie> It'd be nice if MonadIO were in base
09:17:02 <djahandarie> And everything used MonadIO instead of IO ;-)
09:17:40 <hpc> that would certainly make a buttload of openGL stuff easier
09:17:54 <danharaj> MonadIO?
09:18:11 <hpc> a monad that can run IO actions
09:18:15 <djahandarie> danharaj, it would fit any monad built on top of IO
09:18:42 <djahandarie> While currently you need to lift stuff
09:18:48 <hpc> and transform
09:18:56 <aristid> djahandarie: maybe one could write a module that lifts common IO functions?
09:19:55 <triyo> Ok, I still don't understand what is ambiguous in my TagParseable type class. http://gist.github.com/458754 any help, much appreciate it. 
09:21:42 <triyo> I thought 'a' would be replaced by my data type defined in the instance
09:22:10 <triyo> 'replaced' -> rather applied
09:22:15 <djahandarie> aristid, I'm not sure how that'd work in the scheme of things
09:22:51 <aristid> djahandarie: i agree that replacing IO by MonadIO would be good in most cases
09:23:02 <ksf> triyo, what's the exact and full error?
09:23:02 <aristid> (in base)
09:23:08 <aristid> but what if that doesn't happen?
09:23:30 <aristid> i mean, Applicative => Monad is missing too:)
09:23:36 <triyo> ksf: http://gist.github.com/458770
09:23:46 <jmcarthur> a lot of things are poop
09:24:04 <djahandarie> Thank you for those words of wisdom jmcarthur
09:24:15 <jmcarthur> welcome
09:24:19 <djahandarie> :P
09:24:25 <ksf> it's not the class that's ambigious, it's your use of it.
09:24:30 * djahandarie goes to lunch
09:25:14 <ksf> the code you entered just mentioned something solvable with TagParsable, but haskell has no way of knowing what to do unless you have a thing there which has a concrete type.
09:25:53 <triyo> Yes but concrete type comes from the instance definition, well thats at least my intention. 
09:26:13 <ksf> selection doesnt' work that way
09:26:28 <jmcarthur> i do wish more functions were MonadIO m => m a instead of IO a
09:26:35 <ksf> instances are dictionaries attached to types, not the other way round.
09:27:09 <jmcarthur> but that would introduce dependencies on mtl :\
09:27:17 <ksf> you can just add a type signature that fixes the type and things should work out.
09:27:27 <aristid> jmcarthur: wouldn't it be possible to move MonadIO to base?
09:27:45 <jmcarthur> well, sure, but i don't know what the odds are of that happening
09:27:52 <triyo> ksf: in the class definition in place of 'a'?
09:27:57 <danharaj> someone just has to grit their teeth and do it.
09:28:01 <ksf> no, in the code you enter at the prompt.
09:28:02 <danharaj> and show that it works nicely.
09:28:11 <jmcarthur> well, some functions are tougher
09:28:17 <jmcarthur> take bracket, for example
09:28:23 <jmcarthur> you need something like MonadCatchIO
09:28:28 <ksf> if there would be anything wrong with the code in the file ghci wouldn't say that the error is at <interactive>
09:28:31 <jmcarthur> which, as the mailing list recently shows, has had some problems
09:28:53 <aristid> @hoogle bracket
09:28:57 <ksf> > show . read
09:29:05 <ksf> @bot
09:29:08 <jmcarthur> LB is not here
09:29:10 <aristid> :(
09:29:11 <ski> preflex: seen lambdabot
09:29:12 <preflex>  lambdabot was last seen on #haskell 47 minutes and 35 seconds ago, saying: Consider it noted.
09:29:16 <jmcarthur> she pinged out
09:29:31 <triyo> ksf: oh I see, thank you very much!
09:29:53 <aristid> jmcarthur: wasn't the controversy about MonadCatchIO that it has problems with control flow modifying monads?
09:30:41 <jmcarthur> aristid: yeah. my point is that it can be hard to tell where it applies. my point is also that we would have to include more than just MonadIO to get this stuff to work universally
09:30:56 <jmcarthur> aristid: the proposal for MonadCatchIO is to create yet another type class, i think
09:31:28 <jmcarthur> so we'd need at least three to generalize so many IO functions
09:31:46 <jmcarthur> not that it's not worth it. i just don't know that it can ever make it into base
09:32:42 <aristid> jmcarthur: haskell seems to become less of a research language now...
09:33:06 <heatsink> I've a low-level question about GHC
09:33:28 <heatsink> Function calls are fastest when the function is applied to the right number of arguments
09:33:33 <jmcarthur> aristid: yeah :(
09:33:59 <aristid> jmcarthur: you can always fork it though :)
09:34:22 <jmcarthur> aristid: i'd actually started an alternative standard library project, but it's kind of abandoned now
09:34:59 <heatsink> Are polymorphic functions implemented as a function returning a monomorphic function, or a function taking all arguments?
09:36:21 <aristid> jmcarthur: i'm optimistic that haskell can evolve faster than some other languages
09:38:16 <sshc> What can I do to help me find where an infinite loop is occuring?
09:38:45 <sshc> probably infinite recursion, rather.
09:38:45 <RoaldFre> solve the halting problem?
09:39:12 <zygoloid> sshc: you could try attaching gdb and see what's running
09:39:19 <heatsink> sshc: There are some features in GHCi and the profiler that can help.  You can also insert print statements to help narrow down where the problem happens.
09:39:40 <heatsink> sshc: I can give you guidance about where to print things, but I don't know how to use the GHCi or profiler features.
09:39:42 <zygoloid> sshc: are you getting a <<loop>>?
09:40:34 <ksf> I think moving MonadIO to base should go together with renaming it to IO, otherwise people will keep on writing IO () instead of IO m => m ()
09:41:24 <ksf> hmmm. syntax sugar? [- IO -] m
09:41:39 <ksf> single-parameter typeclasses are easily liftable into contexts.
09:41:58 <ksf> ...even if that works only for single occurences.
09:42:08 <ksf> [- IO -] ()
09:42:17 <heatsink> is (:) currently a valid operator at type level?
09:42:27 <heatsink> IO:m
09:43:06 <ksf> yeah
09:43:12 <nejucomo> What does this '#' mean?  (ghc calls it a syntax error, and I don't see it in a Tour of Haskell syntax, nor in Haskell 98 Syntax):  import GHC.Prim (Addr#)
09:43:24 <danharaj> unboxed value, no?
09:43:33 <heatsink> nejucomo: It's a syntactic extension.  It's just part of the name "Addr#"
09:43:37 <jbapple> nejucomo: -XMagicHash
09:43:38 * nejucomo googles for haskell unboxed
09:43:42 <nejucomo> Thanks.
09:43:43 <sshc> zygoloid: There is no "<<loop>>".  I'm cacling a function in ghci, and it freezes, and when I press CTRL+C, ghci crashes with "<stdin>: hLookAhead: hardware fault (Input/output error)"
09:43:48 <ksf> something that resembles the way dependently typed languages do such things. better get people syntactically ready before shoving semantics into their throats.
09:43:54 <sshc> I'm not doing any IO or anything unsafe in the function.
09:44:28 <ksf> sshc, interpreted code doesn't get blackholed
09:44:28 <heatsink> sshc: Are you using input from an IO funtion, for example hGetContents?
09:44:29 <sshc> I'll try using unsafePrint
09:44:30 <ksf> try compiling it
09:44:46 <sshc> heatsink: Nope.
09:44:54 <heatsink> sshc: unsafePrint for debugging is usually called trace, in Debug.Trace
09:45:03 <ksf> nejucomo, it doesn't "mean" a thing.
09:45:14 <sshc> It's "pure", and doesn't do anything unsafe 
09:45:16 <sshc> or any IO
09:45:36 <ksf> you can enable accepting # with -XMagicHash, and GHC uses it to flag primitive types.
09:45:54 <djahandarie> sshc, are you going into swap?
09:45:56 <ksf> ...primitive functions and unboxed values.
09:46:26 <sshc> heatsink: If I give it *any* input, it freezes, which I bet is to to infinite recursion.
09:46:28 <heatsink> fg
09:46:55 <sshc> djahandarie: I really doubt using swap would matter.
09:47:23 <sshc> djahandarie: I'm already using swap, and I'm only using about ¼ of my RAM
09:47:39 <sshc> :t trace
09:47:44 <heatsink> Yeah.  What I generally do is insert 'trace' at the entry points of functions that I suspect are involved in the recursion.
09:48:09 <heatsink> foo a b c = trace "Entering foo" $ {- whatever foo does -}
09:48:22 <djahandarie> Ugh lambdabot is gone lol
09:48:42 <heatsink> Based on whether a statement is printed zero, one, or approximately infinity times, you can infer where the recursive cycle is.
09:48:52 <heatsink> *whether a message is printed
09:50:18 <nejucomo> The GHC6 user guide doesn't mention -XMagicHash anywhere in the section on unboxed primitives.  :-(
09:51:04 <davean> look for MagicHash
09:52:16 <sshc> heatsink: When exactly is the message of trace printed?
09:53:22 <heatsink> sshc: [| trace x y |] prints x before evaluating y
09:53:55 <heatsink> It's a string, formatted the same as putStrLn
09:54:26 <heatsink> printed the same as with putStrLn I mean
09:54:39 <heatsink> Except I think it goes to stderr
10:03:04 <McManiaC> can someone help me defining an MonadWriter instance? what exactly are listen and pass supposed to do?
10:03:14 <heatsink> :t listen
10:04:00 <heatsink> 'listen m' returns two things: m's normal return value, and whatever m writes
10:04:53 <ksf> and I guess pass passes in an initial object to mappend things to
10:05:05 <heatsink> 'pass m' uses the endofunction to modify what m wrote
10:05:51 <ksf> ...just like a functor but on the first of two arguments.
10:07:12 <McManiaC> hmmm
10:10:03 <heatsink> for example, \m -> pass $ do {x <- m; return (x, const mempty)} will turn a computation into one that writes nothing.
10:10:22 <McManiaC> http://npaste.de/aN/ ← does this look valid?
10:13:12 <heatsink> fg
10:13:35 <McManiaC> fg?
10:13:42 <heatsink> It looks typesafe.  I don't know about valid.
10:13:52 <heatsink> I was looking at my terminal window.
10:14:30 * heatsink isn't accusotmed to thinking about transactional memory
10:14:50 <McManiaC> ah ^^
10:15:27 <zygoloid> McManiaC: why are you using a TVar rather than an MVar if you're going to wrap all uses with atomically?
10:17:04 <McManiaC> hm
10:17:21 <McManiaC> no real reason tbh :)
10:36:31 <[Evan]> BONUS: Ping.
10:40:01 <mreh> mathematica channel is empty
10:44:36 <mads-> Hi. I come from JAVA and C++, and know I want to learn haskell. Would you recommend me using Learn You a Haskell for Great Good or Real World Haskell?
10:46:12 <c_wraith> mads-: both.  LYAH is better as a short intro to the language, RWH is better for getting into some practical details in depth
10:46:30 <arw_> mads-: i would not recomment RWH when you have absolutely no prior haskell experience. start with LYAH and other tutorials, then read RWH
10:46:47 <mads-> Cool - sounds like you agree. I will do that then
10:46:55 <mads-> Thanks :)
10:47:44 <zygoloid> also you might want to look through the wikibook: http://en.wikibooks.org/wiki/Haskell
10:47:52 <zygoloid> it's somewhat between LYAH and RWH imo
10:48:06 <sproingie> the wikibook is all over the place
10:48:56 <sproingie> and despite being a wiki, i don't feel comfortable editing large chunks
10:49:02 <zygoloid> yeah, it suffers from a lack of focus
10:49:44 <sproingie> i'm probably going to take a "short lesson" approach tho if i get around to a tutorial
10:50:05 <sproingie> where the lessons revolve around, or at least return to, a single project, one that's actually fin
10:50:08 <sproingie> fun
10:50:14 <sproingie> parsing xpm is not what i consider fun
10:50:20 <c_wraith> aww.  I wanted it to actually be a fin.
10:50:29 <c_wraith> shark design in haskell, for fun and profit!
10:50:38 <sproingie> sharkbait ohh ha ha
10:50:38 <nolrai_portland> Hey so has anyone heard of the blackboard data model? I am thinking about implementing a blackboard based GUI library in haskell, and want to think about how to type anouncements. 
10:50:40 <ksf> all those newbies nowadays have it much too easy.
10:51:06 <ksf> back in my days, the only tutorial available at all was you could have invented monads!
10:51:08 <sproingie> nolrai_portland: i'm under the impression that most signal/slot implementations are rather like blackboard
10:51:29 <sproingie> in that events are broadcast instead of wired directly to callbacks
10:52:14 <sproingie> back in my day the only tutorial around was a Gentle Introduction to Haskell
10:52:33 <nolrai_portland> sproingie: hmm, yeah that sounds like something I should look at.
10:52:37 <sproingie> not really
10:52:45 <sproingie> it was never that gentle
10:52:48 <sproingie> and it hasn't aged well
10:52:50 <ksf> I actually learnt the syntax from the GHC manual
10:53:10 <c_wraith> heh.  I didn't actually think the "gentle introduction" was that bad...  as a casual reference after learning the basics. :)
10:53:19 <jabb> http://codepad.org/UxnXyo2P crashes after awhile, alternatives?
10:53:24 <sproingie> i muddled through it but i think i had more patience then
10:53:45 <nolrai_portland> I meant the signal/slot thing.
10:53:45 <sproingie> the older i get the worse my attention span gets
10:54:06 <ksf> jabb, make the monad strict.
10:54:21 <sproingie> nolrai_portland: oh that.  yah it's a good model to learn.  Qt is based on it, gtk can use it but i don't know that it's exactly ubiquitous there
10:54:31 <ksf> wait
10:54:31 <jabb> ksf: how's that done?
10:55:07 <sproingie> swing and winforms are sort of like that in that you have listeners, except the event and the listener are more strongly typed
10:55:24 <ksf> wth are you doing that tick thing for?
10:55:36 <sproingie> one of the appeals of signal/slot is that it's actually not all that strongly typed.  i think you can get the best of both worlds with typeclasses tho
10:55:45 <jabb> testing
10:56:43 <largos> does anyone know if you can install HP into a specified location on windows? (so that admin access would not be necessary?)
10:56:50 <aristid> 'Arrows' is a really stupid name because in saying what an arrow is I'm forced to use the word 'arrow' in two diferent senses, one for Hughes meaning and one for the usual meaning from category theory. It's like deciding that the prime numbers bigger than 20 are interesting for some reason and then choosing to give them a name, 'the primes'. I'll use capital 'A' for Hughes' sense.
10:56:53 <aristid> quote.
10:56:55 <sproingie> largos: the installer should let you put it anywhere
10:56:56 <ksf> hmmm nope I can't see any way for that to leak memory.
10:57:06 <ksf> jabb, can you define "crash" more closely?
10:57:35 <ksf> also, did you compile with optimisations?
10:57:38 <jabb> ksf: ERROR - Garbage collection fails to reclaim sufficient space
10:57:50 <largos> sproingie: hm.. I'll try again momentarily -- I don't believe it prompted me before requiring admin credentials
10:58:05 <ksf> there's your problem, you're using HUGS.
10:58:13 <jabb> :D
10:59:06 <sproingie> largos: might be the installer demands admin for some reason, like for globally setting file associations.  unfortunately the way UAC works, even if you don't use the credentials, the installer still has to ask for them
10:59:37 <nolrai_portland> spongie: Yeah it seems like you should be able to too.  The tricky part would be allowing new signal types at run time. (but is that really nessary?) 
10:59:42 <ksf> setting PATH?
10:59:54 <largos> ah.. I just ran the ghc installer -- it didn't ask for permissions, but it complained about setting registry keys at the end.
11:00:02 <sproingie> usually what you do is you bundle sub-installers, and only prompt for elevation on the one that actually needs admin
11:00:11 <c_wraith> Hmm.  ThreadId should already be a strict type, right?  running seq on it is only going to cost performance?
11:00:46 <ksf> it might even be unboxed, considering that it's opaque.
11:01:07 <ksf> ...and a seq that does nothing doesn't cost performance, it's just a noop.
11:01:08 <sproingie> largos: yah that's even more annoying, having to go back and "run as administrator" because it didn't properly elevate.  but it's convenient for when you don't need it
11:01:24 <c_wraith> How about an MVar?  Those are also strict, right?
11:01:37 <largos> sproingie: yeah.. I don't think the reg entries are important for me, so I'm just ignoring them
11:01:38 <sproingie> i wonder if there's a way to strip UAC manifests out of an exe?
11:01:39 <c_wraith> (not the contents of the MVar, the structure itself)
11:02:09 <c_wraith> I'm just trying to seq the minimum necessary in this code, to avoid putting unevaluated thunks into an MVar.
11:02:38 <McManiaC> http://npaste.de/aO/ :)
11:02:50 <ksf> c_wraith, do what staring at threadscope tells you to do.
11:02:54 <c_wraith> ...  And yes, I'm putting a list of empty MVars and ThreadIDs into an MVar
11:03:02 <c_wraith> I've never managed to use threadscope
11:03:19 <c_wraith> I bet odds of it working on OS X are slim?
11:04:01 <ksf> why should they be?
11:04:09 <sproingie> there's a shot of it working on ubuntu
11:04:13 <ksf> also, I think you're optimizing prematurely.
11:04:38 <c_wraith> I'm pretty sure threadscope uses GTK
11:04:48 <c_wraith> all told, I want to avoid the gtk on os x mess
11:05:58 <sproingie> http://www.reddit.com/r/haskell/comments/auudx/threadscope_is_now_on_hackage/c0jk7a0
11:06:05 <sproingie> first post is about compiling it on osx
11:06:28 <sproingie> oh not first post, that's a link to the post :p
11:10:46 <c_wraith> Also, I'm running 6.10.4 :)
11:15:11 <alexyk> c_wraith: what are you, some kind of a luddite? :)
11:15:23 <aristid> c_wraith: why are you living behind the moon? :D
11:15:33 <alexyk> is 6.10 coal-powered?
11:15:38 <c_wraith> Pink Floyd made a compelling argument
11:16:22 <c_wraith> ok, I think I've got sufficient strictness in there now.  design question time, instead.
11:16:59 <RoaldFre> conf@(XConfig {XMonad.modMask = modm}) =
11:17:07 <RoaldFre> gah
11:17:17 <c_wraith> I'm writing code that runs an action in a limited fashion:  only one concurrent execution of that action, and a minimum delay between the finish of one run and the start of the next.
11:17:55 <sproingie> sounds like a sort of scheduler
11:18:43 <c_wraith> concurrent requests can be made, they wait on MVars that get populated when the execution finishes.  Requests that come in during the delay period get the saved previous result.
11:19:16 <c_wraith> I'm adding exception-handling.  It's easy to see the correct behavior when the action raises an exception is to throw it to all the waiting threads.
11:19:48 <c_wraith> What's less obvious is if it should cancel the delay period or not...
11:20:47 <c_wraith> Do requests that come in during the delay period after an exception just have the stored exception thrown to them too, or do they kick off a new execution of the action, violating the rule that it's the minimum delay between executions?
11:21:00 <RoaldFre> myKeys conf@(XConfig {XMonad.modMask = modm}) = [...]:  what exactly does the conf@... do? It seems to change the type of the list. Can anyone explain that syntax, or give the term for this so I can google, plz?
11:21:09 <sproingie> not sure if throwing to all the waiting threads is what i'd do, but i don't really know what sort of thing you're doing
11:21:39 <sproingie> i'd say whether an exception immediately kicks off a new task or not is up to your scheduler logic
11:21:51 <sproingie> since another possible action could be to flush all tasks and die
11:21:53 <c_wraith> It's not a scheduler.  It's more an anti-scheduler
11:22:15 <sproingie> well it's queueing up tasks and executing them at a regulated rate, so it's sort of a degenerate scheduler
11:22:34 <sproingie> or a batch processor if you like
11:23:03 <c_wraith> This is something I'm doing because I'm using a library that isn't thread safe.  (that library is called GHC, by the way)
11:24:28 <LDrago> Enter hey
11:25:39 <c_wraith> I want to simulate "actually running the action" for each requesting thread, as closely as possible, without actually running the quite-heavyweight action for every request.
11:25:55 <c_wraith> Hence throwing the exception to all waiting threads
11:26:58 <c_wraith> My question, though, is really about whether the "minimum delay" guarantee should outweigh "error recover"
11:27:21 <c_wraith> ...  Especially when the error recovery isn't guaranteed
11:31:32 <LDrago> c-wraith>
11:40:43 <RoaldFre> What is the exact meaning of the syntax "myKeys = conf@(XCofnig {XMonad.modMask = modm}) = [...]" and how could I "concatenate" two such objects?
11:41:41 <c_wraith> the @ binding just means that it's doing pattern matching according to the right side of the @, but the entire value is bound to the name on the left side of the @ if the match succeeded
11:42:02 <ksf> what do you mean with "object"?
11:42:26 <c_wraith> However, that syntax makes no sense to me, having two '=' characters in the line.
11:42:51 <RoaldFre> oh,  yes, the = after myKeys should not be there, sorr
11:43:10 <c_wraith> So, do you see what I mean about the @?
11:43:25 <RoaldFre> Is the resulting object still a list? (and the @ is o n
11:43:37 <RoaldFre> only there to make an alias for modm?
11:43:43 <RoaldFre> and config
11:43:52 <ksf> conf is an XConfig
11:44:20 <ksf> wait isn't that punnig the wrong way round?
11:44:21 <c_wraith> myKeys is a function that takes an XConfig, and returns a list of something
11:44:23 * ksf is confused
11:45:12 <c_wraith> You can concatenate lists with ++.  I really have no idea what operations are available on XConfigs
11:45:33 <RoaldFre> ah, ok. So if I were to combine two such objects, I would do something like \x -> myKeysA x ++ myKeysB x ?
11:45:57 <c_wraith> yes, that looks approximately right. :)
11:46:31 <ksf> RoaldFre, there's additionalKeys which you can use
11:47:12 <ksf> ...which takes an XConfig and a list of bindings and returns the XConfig extended with those bindings
11:47:49 <RoaldFre> hmm, well,that's exactly what I need 
11:47:59 <ksf> there's a lot of xmonad.hs examples on the net, and if you need specific help there's #xmonad, where people usually know about xmonad specifics
11:48:32 * ksf has myConfig = defaultConfig { terminal = ... , ...} `additionalKeys` [ ... ]
11:49:32 <ksf> ...and not a single @ in the whole file
11:49:59 <djahandarie> I wish the default record syntax were better
11:50:11 <RoaldFre> ksf: thanks!
11:50:38 <ksf> djahandarie, it will be
11:50:43 <wli> djahandarie: There's non-default record syntax?
11:50:49 <Dashkal> Does anybody remember the title of (or have a link to) the paper haskell's type inference system is based on?
11:51:48 <ksf> byorgey is hacking up stuff that will make polymorphic lists etc. trivial to implement, you can expect a flurry of record-library flurry afterwards and then, sometime, it will be in h'.
11:52:01 <djahandarie> ksf, sweet
11:52:02 <ksf> Dashkal, google "hindley-milner"
11:52:16 <nolrai_portland> Hey so if I wanted to implement a publish/suscribe model with MVar how would that look? Or is this alredy solved some where?
11:52:30 <ksf> ...which isn't haskell per se, but you should grok that before diving into haskell-specifics.
11:52:31 <djahandarie> wli, there are other packages which provide alternatives to the h98 stuff
11:53:10 <ksf> we'd all be using HList if it wouldn't explode compile times beyond comparison.
11:53:20 <djahandarie> lol
11:53:21 <ksf> well maybe comparable to stalin.
11:53:21 <Dashkal> ksf: No, that's absolutely perfect.  I'm adding type safety to my pet language and I don't want to live without inference.
11:53:40 <ClaudiusMaximus> nolrai_portland: Control.Concurrent.Chan.dupChan maybe?
11:53:41 <djahandarie> I've heard http://hackage.haskell.org/package/records is pretty nice
11:54:00 <ksf> fc-labels is the most frequently hyped one.
11:54:07 <djahandarie> Yeah
11:54:19 <nolrai_portland> look at Lenses too.
11:54:26 <djahandarie> I think it is Cale that has mentioned the records one a couple of times
11:54:27 <djahandarie> brb
11:54:48 <ksf> Dashkal, implemented in haskell?
11:54:54 <Dashkal> ksf: The language? Yes.
11:55:26 <ksf> ...I dare you to use http://www.cs.st-andrews.ac.uk/~eb/ivor.php as a backend.
11:55:32 <Dashkal> ksf: The difficulty is my type system is open.  Currently using Existentials, though I'm moving the syntax to GADTs now that I understand them.
11:56:05 <Dashkal> That looks intriguing
11:58:05 <nolrai_portland> ClaudiusMaximus: Thanks. Do you know how writeChan and unGetChan are differnt? I don't understand just looking at the code.
11:59:05 <ClaudiusMaximus> Chan is FIFO with writeChan, LIFO with unGetChan
12:00:09 <ClaudiusMaximus> i had a problem with Chan today - the other end took too long to do the processing, enterring a death spiral of excessive ram usage..
12:00:10 <djahandarie> Whoa ksf that looks nifty
12:00:52 <ksf> there's also a language based on it, which looks rather nice
12:01:43 <ksf> http://www.cs.st-andrews.ac.uk/~eb/Idris/
12:02:12 <djahandarie> Haskell is one of the nicest looking languages I know
12:02:48 <djahandarie> Mostly due to using whitespace for most stuff
12:02:50 <ksf> yeah idris is lacking a proper layout mode
12:03:34 <jabb> http://codepad.org/YZm5DbYA
12:03:35 <ksf> ...it uses basically haskell syntax, though, and adding layout seems to be quite easy
12:07:26 <ksf> jabb, the first one can serve as a backing for a monad, the other one only for a monoid
12:07:34 <ksf> (with . as operation and id as identity)
12:08:00 <jabb> so the second can maintain state?
12:08:16 <ksf> hmmm
12:08:27 <ksf> If it can, it's not immidiately obvious.
12:08:41 <ksf> the obvious thing to do is threading a parameter through your recursion.
12:09:10 <ksf>  f x = x + ( f (x - 1) )
12:09:18 <ksf> you can regard "x" as state, there.
12:09:43 <jabb> I'm curious as to what s's purpose is in the tuple return type
12:09:45 <jabb> for the first one
12:09:51 <jabb> a is the new state
12:12:12 * hackagebot authenticate 0.6.3 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.3 (MichaelSnoyman)
12:12:17 <Dashkal> jabb: a is the result of the operation.  s is the new state.
12:12:45 <jabb> ahh, right
12:13:15 * hackagebot neither 0.0.0 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.0.0 (MichaelSnoyman)
12:13:32 <jmcarthur> :o
12:14:06 <djahandarie> lol @ that package name
12:37:10 <nolrai_portland> grr Leksah is not quite useable. close but not there.
12:37:24 <nolrai_portland> I guess back to geany for me.
12:37:28 <ksf> yeah it's lacking yi integration
12:38:20 <mreh> are we getting a new debugger yet?
12:38:35 <mreh> there were rumblings in April
12:38:49 <nolrai_portland> Well I am more encountering that I cant add build dependencys without it crashing.
12:39:03 <mreh> :X
12:40:28 <nolrai_portland> Also we really need to fix the haskell highlighting in sourceview. M.map should not be green.
12:41:33 <mreh> gedit does that too, it must be based on the same rules
12:44:45 <nolrai_portland> mreh: yep. There not even that hard to change, there just some .lang files and easy enough to edit your self, but its a pain to find them.
12:45:36 <nolrai_portland> Why is "M.Map tag (forall a. (Chan a, MVar (Blackboard tag -> a -> IO ())))" a illegal type? 
12:48:33 <ksf> you gotta wrap that existential in a datatype, or not?
12:48:54 <mauke> that doesn't look like an existential to me
12:49:07 <chrisdone> famous last words
12:53:28 <mauke> preflex: seen Cale
12:53:28 <preflex>  Cale was last seen on #haskell 16 hours, 49 minutes and 13 seconds ago, saying: :t (\x -> x 1)
12:57:00 <aristid> :t (\x -> x 1)
12:57:14 <aristid> *cries*
12:58:18 <mreh> ($ 1)?
12:58:36 <kulin> when you use cabal to compile a library with c-sources, is the c statically or dynamically linked? 
12:59:58 <dolio> nolrai_portland: It's an impredicative type. It can be enabled with the ImpredicativeTypes language extension.
13:00:12 <dolio> Although that's going away.
13:02:09 <b0fh_ua> Hi! Is it possible to check IO code with QuickCheck?
13:02:40 <kulin> at the very least you could probably use unsafePerformIO :)
13:02:43 <djahandarie> No, but you can use HUnit
13:02:49 <c_wraith> kulin: run ld on the file
13:02:53 <b0fh_ua> sad :(
13:03:14 <djahandarie> b0fh_ua, usually an IO function can be broken up into a couple pure functions and the IO part
13:03:19 <b0fh_ua> I wrote simple quicksort with IOArray to sort things inplace, and wanted to check it works well
13:03:25 <djahandarie> b0fh_ua, then the pure functions can be tested
13:03:26 <b0fh_ua> djahandarie: not in my case
13:04:00 <Eduard_Munteanu> Hi.
13:04:15 <b0fh_ua> at least I don't know how to escape from IO in IOArray
13:05:04 <ksf> b0fh_ua, well, use ST
13:05:05 <djahandarie> If you really want to you can use unsafePerformIO to test it
13:05:18 <ksf> no you don't want to unsafePerformIO
13:05:24 <b0fh_ua> ksf: can you please explain?
13:05:30 <b0fh_ua> what is ST
13:05:56 <Heffalump> ST is a cut down version of IO where all you can do is manipulate locally defined state
13:05:56 <djahandarie> Ugh, is c.h.o down again?
13:06:12 <Heffalump> which means that it has a safe "run" operation, in contrast to IO
13:06:33 <ksf> b0fh_ua, http://hackage.haskell.org/packages/archive/array/0.1.0.0/doc/html/Data-Array-ST.html
13:06:35 <chrisdone> Heffalump: your @ sign intimidates me :p
13:06:46 <Heffalump> sorry!
13:06:46 <djahandarie> chrisdone, shhh don't make him angry!
13:06:46 <b0fh_ua> sounds good, but still not clear how can I integrate it with QuickCheck
13:06:49 * chrisdone timids
13:06:49 --- mode: Heffalump set -o Heffalump
13:07:00 <Heffalump> someone was spamming this morning and I forgot about it
13:07:05 <Eduard_Munteanu> Guys, I'm having problems defining toPeano here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26727#a26727
13:07:09 <Eduard_Munteanu> Do you think it's doable?
13:07:24 <chrisdone> I was talking about ST today to someone as an example of how Haskell's great for controlling effects
13:07:25 <Heffalump> b0fh_ua: you can turn an ST computation into a pure computation and QuickCheck that as normal
13:07:27 <Eduard_Munteanu> fromPeano works, which is a major step forward wrt what I gave up on last time.
13:07:47 <Heffalump> also, I think QuickCheck does have some stuff for directly testing ST - at least there was a paper about doing that.
13:07:49 <Eduard_Munteanu> The thing is that pesky occurs check happens :)
13:08:11 <b0fh_ua> oh, okay
13:08:20 <b0fh_ua> thank you, will take a look at this
13:09:30 <b0fh_ua> but for now - how can I simply generate lots of random lists? I can feed them to my current IOArray and check if the output matches result of 'sort' function?
13:09:52 <b0fh_ua> may be I can borrow something from quickcheck?
13:09:53 <Heffalump> for now I'd personally suggest just using unsafePerformIO :-)
13:10:02 <Eduard_Munteanu> Well, common sense would tell you can't get type info at runtime unless explicitly provided, but is there any chance toPeano is implementable?
13:10:12 <b0fh_ua> Heffalump: ehm, dunno how to do that either :)
13:10:26 <Heffalump> import System.Unsafe
13:10:32 <Eduard_Munteanu> It seems the other way around works.
13:10:33 <Heffalump> which has unsafePerformIO :: IO a -> a
13:10:53 <djahandarie> Which you definitely do not want to use anywhere in production code
13:11:10 <b0fh_ua> djahandarie: this isn't production, this just for fun :)
13:11:14 <b0fh_ua> and learning
13:11:29 <Heffalump> you need to be confident that the IO a is "morally" pure, i.e. it'll produce the same result each time it's run
13:11:35 <b0fh_ua> so probably I could try it out right now to see if my code looks correct
13:11:37 <Heffalump> and not have any evil side-effects when it is run
13:12:00 <b0fh_ua> Heffalump: it's all about modifying IOArray internals
13:12:09 <djahandarie> b0fh_ua, you won't be learning anything if you use that in your code. The nice thing about Haskell is that it *doesn't* let you do (Monad m) => m a -> a
13:12:13 <Heffalump> what happens to the IOArray afterwards?
13:12:20 <djahandarie> b0fh_ua, I'm not against using it for testing though
13:12:23 <djahandarie> Just making a side comment
13:12:48 <Heffalump> there are situations where it is legitimate in production code
13:12:50 <b0fh_ua> djahandarie: thanks )
13:13:12 <djahandarie> Heffalump, right, but they are almost all handled in packages already made in Hackage
13:13:30 <djahandarie> And usually the only time is for efficiency
13:13:39 <Heffalump> or FFI bindings
13:13:56 <Heffalump> and if you need something like stable names to get observable sharing, the efficiency gain can be huge
13:17:34 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26728#a26728 - that's what I was talking about
13:18:44 <djahandarie> Is there a reason you are using an IOArray?
13:19:05 <Eduard_Munteanu> BTW, are there any options or semantics in which infinite types work?
13:19:08 <b0fh_ua> djahandarie: that's the first mutable array I found, so ... :)
13:19:29 <b0fh_ua> I will try to do the same with ST
13:19:29 <Eduard_Munteanu> like where a = T a does not trigger an error
13:19:34 <davekong> Is there a way to have a pattern for a function that matches a range of numbers?
13:19:46 <djahandarie> b0fh_ua, yeah, STArray would be better suited for this
13:20:26 <davekong> like "f (1..10) = Nil"
13:20:30 <EvanR-work> davekong: guards
13:20:38 <c_wraith> davekong: Not in the pattern, but you can use guards for it:  foo n | n > 10 && n < 20 = n
13:21:21 <EvanR-work> ada style range constraints would be cool
13:22:13 <davekong> OK, thanks
13:22:33 <Eduard_Munteanu> The error I'm referring to is "Occurs check: cannot construct the infinite type: a = Succ a". I thought about using some newtype trickery, but not sure that'll do.
13:24:21 <kpreid> Eduard_Munteanu: newtype does suffice for breaking type-level recursion
13:34:24 <JavaFunccode> !ops a special ]message` to you `from BIKCMP: So assuming that I know how to write cronjobs, bash scripts that change the color of my prompt, and DOS batch scripts, which language should I try learning first?
13:34:26 <Eduard_Munteanu> kpreid: thanks.
13:34:49 <danharaj> was that a spambot on irc?
13:34:57 <tomaw> yes
13:35:16 <Eduard_Munteanu> kpreid: so you think that won't work unless I put in dynamic typing, dependent types etc.?
13:35:46 <kpreid> Huh?
13:36:09 <Eduard_Munteanu> kpreid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26727#a26727
13:36:13 <Eduard_Munteanu> That's what I'm trying to do.
13:36:29 <Eduard_Munteanu> kpreid: toPeano simply won't work. But fromPeano is alright.
13:36:56 <kpreid> right, toPeano won't work
13:37:39 <kpreid> actually, even its type is wrong -- that type is necessarily just increment
13:37:54 <kpreid> I wonder whether you could pull it off using existentials
13:38:12 <kpreid> (forall a. Peano a => a)
13:38:59 <Eduard_Munteanu> kpreid: um, why is it wrong? I can't really specialize it to ().
13:39:21 <kpreid> it's wrong because it's fixed to Succ a
13:39:34 <nolrai_portland> Are you really going for type system peanos?
13:39:44 <kpreid> I recommend looking into existentials.
13:39:56 <Eduard_Munteanu> I know a bit about that. How would it help?
13:40:43 <nolrai_portland> If you just want peano integers they are "data Peano = Zero | Succ Peano"
13:40:46 <Eduard_Munteanu> I guess you mean toPeano :: (forall a. Peano a => a) -> Int -> <something>
13:41:18 <Eduard_Munteanu> nolrai_portland: oh.
13:42:15 <Eduard_Munteanu> Hm, that should avoid unwanted polymorphism... lemme try it.
13:42:54 <kpreid> those are data-level peanos
13:47:13 <Eduard_Munteanu> kpreid: hm, I see. So actually they're like regular values :(
13:47:56 <kpreid> I think you can do it with existentials.
13:47:57 <Philonous> Type level peanos would typecally look more like "data ZeroP; data SuccP a". What is a value of Zero (Succ ()) supposed to mean? 
13:48:17 <Eduard_Munteanu> Philonous: well, that's true.
13:48:26 <kpreid> toPeano :: Int -> (forall a. Peano a => a)
13:48:38 <kpreid> might need a data wrapper
13:49:09 <mauke> s/forall/exists/
13:49:11 <Philonous> And yes, you can reify your value-level peanos using Rank-2-types (or existentials)
13:49:46 <mauke> toPeano :: Int -> (forall a. Peano a => a -> b) -> b
13:49:47 <Eduard_Munteanu> Well, I tried rank-2 on the left hand terms but I can't seem to pass a value to it.
13:49:52 <Philonous> something like reify :: (forall a. Peano a => a -> Int) -> int 
13:50:05 <edwardk_> Philonous: i've seen people use tricks like that to turn them around so they read naturally when you want to say D1 (D2 (D3 ())) ~ $(dec 123)
13:56:14 <roconnor> @index random
13:56:26 <roconnor> @hoogle random
13:56:31 <roconnor> @bot
13:56:41 <roconnor> @
13:56:48 <dolio> @steakfries
13:57:40 <dafis> roconnor: System.Random.random :: (System.Random.RandomGen g) => g -> (a, g) ?
13:59:25 <ddarius> dafis: @botsnack
13:59:43 <dafis> ddarius, quoi?
13:59:51 <dafis> @botsnack
14:00:05 <dolio> The proper response is ":)"
14:00:33 <dafis> dolio: I take your word for it, but what is botsnack?
14:01:19 <pizza_> positive reinforcement
14:01:27 <dolio> botsnack is a command that makes the irrational humans here feel good, as if they've given lambdabot a treat.
14:01:37 <Eduard_Munteanu> mauke: tried defining it like this (part of it): toPeano n f = f (toPeano (n - 1) f), using your suggested type signature
14:01:55 <Eduard_Munteanu> mauke: but it complains: Occurs check: cannot construct the infinite type: b = a -> b
14:02:20 <Eduard_Munteanu> I hope I got your point.
14:02:32 <dafis> dolio: like stroking your monitor when a programme ran unexpectedly fast?
14:03:11 <mauke> toPeano 0 f = f Zero; toPeano n f = toPeano (n - 1) (f . Succ)
14:03:12 <edwardk_> ddarius: puzzle for you =)
14:03:15 <mauke> completely untested
14:03:18 <dolio> Sure.
14:03:30 <dafis> crazy humans
14:03:32 <edwardk_> actually, dolio might find it fun too =)
14:03:37 <dolio> mauke: Looks about right.
14:04:36 <edwardk_> ddarius, dolio: i don't actually know the answer: is there a way to make an Applicative "transformer" for State that gives the same semantics as the Monadic one? i.e. instance Applicative t => Applicative (StateT s t) where ...
14:04:56 <edwardk_> of course one can do it for Monad t => ...
14:05:23 <edwardk_> can you keep an eye out for it?
14:05:38 <edwardk_> er that last line was mistell but appropriate anyways ;)
14:08:16 <nolrai_portland> What happens if you call swapMVar on an empty Mvar?
14:08:24 <c_wraith> it blocks
14:08:56 <nolrai_portland> that makes sense.
14:08:59 <yitz> preflex: seen lambdabot
14:08:59 <preflex>  lambdabot was last seen on #haskell 5 hours, 27 minutes and 22 seconds ago, saying: Consider it noted.
14:09:13 <c_wraith> swapMVar isn't anything special.  It's really just swapMVar m x = do { x' <- takeMVar m ; putMVar m x ; return x' }
14:09:38 <c_wraith> That's why it's documented as having a potential race condition
14:10:06 <nolrai_portland> I want to just replce the value in an MVar regardless of what was there before, do I really have to write that my self?
14:10:38 <dolio> edwardk_: I suspect the answer is "no".
14:10:45 <edwardk_> dolio:  =(
14:10:57 <dolio> But I'm not certain.
14:10:57 <edwardk_> dolio: i was afraid so too
14:11:06 <c_wraith> nolrai_portland, probably.  and depending on how robust you need it to be, you might need to make it complicated.
14:11:08 <dafis> edwardk_: puer a = StateT (\s -> (pure a, s)), StateT phi <*> StateT f = StateT (\s -> let  {(g,s') = phi s; (a,s'') = f s' } in (g a, s'')) ?
14:11:24 <edwardk_> dafis: different semantics
14:11:33 <c_wraith> Involving loops with tryTakeMVar and tryPutMVar
14:11:37 <dafis> edwardk_ didn't check any laws yet, but that's what seems the most likely candidate
14:11:57 <edwardk_> dafis: yeah but stateT is s -> m (a, s) not s -> (m a, s)
14:12:13 <dafis> edwardk_: oops
14:12:28 <edwardk_> the version you supplied is the 'applicative composition' of state with another applicative
14:12:45 <dafis> so perhaps, pure a = StateT (\s -> pure (a,s))
14:13:01 <dolio> pure isn't the problem (<*>) is.
14:13:01 <nolrai_portland> c_wraith: all I want to do is have a Chan that also keeps track of what was last put in the Chan.
14:13:40 <ddarius> The question basically seems like it boils down to whether you can rewrite the body of StateT's (>>=) using only Applicative on the inner functor.
14:13:49 <dafis> dolio: sure, but get the easy thing sout of the way first :)
14:13:57 <c_wraith> nolrai_portland, if you wrap it in a newtype and don't export the constructor, you can simplify a lot by preventing tampering
14:14:31 <dolio> Because you need to get the s out of a 'f (a -> b, s)' and feed it into a 's -> f (a, s)' and then combine the two to get a 'f (b, s)'.
14:14:49 <nolrai_portland> Really? I mean it will still have to handle race conditions from multiple posts.
14:14:50 <dolio> But that's a monadic sort of goal.
14:16:02 <dolio> In f <*> x, what f does partly determines what x is.
14:16:31 <ddarius> edwardk: I'm pretty confident the answer is no.
14:16:31 <c_wraith> nolrai_portland, But if you are careful with the access patterns the functions that work with the abstract data type will have, it will save you a lot.
14:17:17 <nolrai_portland> c_wraith: Ok, then I will. Still feels like somethng someone else has to have writen.
14:17:24 <ddarius> Actually I as considering the wrong problem.
14:19:10 <Eduard_Munteanu> mauke: I tried fixing it, it didn't work directly... but I still have problems: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26727#a26730
14:19:27 <Eduard_Munteanu> mauke: I get "Quantified type variable `a' escapes"
14:19:42 <mauke> Zero a? wtf?
14:19:44 <ddarius> However, I'm even more confident the answer is "no" now.
14:20:05 <dolio> edwardk_: f (a -> b, s) -> (s -> f (a, s)) -> f (b, s) looks pretty clearly like bind, anyway. It'd be pretty surprising to me if it were doable without it.
14:20:09 <mauke> Eduard_Munteanu: are you trying to make type-level or data-level peanos?
14:20:16 <Eduard_Munteanu> mauke: yeah, though that shouldn't be a problem, changed your f Zero to f $ Zero ()
14:20:21 <Eduard_Munteanu> mauke: type-level.
14:20:25 <ddarius> Basically there's no way to get the output state of f into the input state of x in f <*> x.
14:20:44 <mauke> Eduard_Munteanu: then data Zero = Zero; data Succ a = Succ a
14:21:01 * ddarius goes to eat.
14:21:13 <Eduard_Munteanu> mauke: alright, I'm going to change it, it causes too much confusion.
14:21:23 <ksf> Eduard_Munteanu, why aren't you using type families?
14:21:36 <Eduard_Munteanu> ksf: I'm not familiar with those.
14:21:40 <edwardk_> dolio: good point
14:21:51 * Eduard_Munteanu looks it up
14:22:49 <Eduard_Munteanu> Hm, yes, I see how that can be useful.
14:22:53 <ksf> Eduard_Munteanu, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26731#a26731
14:24:29 <ksf> ...undecidableinstances is needed because ghc's termination checker isn't powerful enough to prove that the Mul instance is structurally recursive.
14:24:30 <Eduard_Munteanu> ksf: looks neat, thanks.
14:24:54 <ksf> ...it's bailing out as soon as it sees nested applications, that is.
14:25:48 <pikhq> Shockingly, GHC does not solve the halting problem.
14:25:55 <Eduard_Munteanu> ksf: hm, though it doesn't seem to be able to take an integer into a Peano.
14:26:14 <ksf> how could it?
14:26:20 <ksf> haskell isn't dependently typed.
14:26:30 <pikhq> Eduard_Munteanu: Impossible without TH.
14:26:44 <c_wraith> and TH can only do it at compile time, of course
14:26:46 <Eduard_Munteanu> Well, yes I guessed so, but thought there was some way. And mauke gave me hope :)
14:27:06 <Eduard_Munteanu> c_wraith: yes, I'm only talking about compiletime constants -> Peano
14:27:12 <ksf> but what's there is powerful enough to express concat and <*> on vectors
14:27:19 <pikhq> Eduard_Munteanu: Then TH is for you!
14:27:42 <asm_Php_Sposato> !ops a `special message` to you `from `BIKCMP: Dude you have to own one first to understand, people that hate them haven't owned them. I owned two and flipped them both, luxury eddie bauers one had 20s on it and a TV inside with a ps2 man, flipped them both nearly killed me...But I still fucking love suvs
14:27:47 <Netsco> !ops a `special message` to you `from `BIKCMP: I'd love to have a man as my girlfriend and who would greet me each morning in a new an refreshing way. A spray of hot piss, a dick up the ass, an ass pressed against my face, farts in my face, all the while waking up to a beautiful man on some dim morning sunrise, light shining through the curtains onto his perfectly formed pectorals and the silk sheets layed upon his body reveleaing en
14:28:21 <Eduard_Munteanu> Isn't it technically possible to fit in a runtime type checker that works on infinite types?
14:28:56 <ksf> Eduard_Munteanu, http://www.cs.st-andrews.ac.uk/~eb/Idris/
14:28:59 <c_wraith> sure.  But if you allow infinite types, you end up allowing WAY more than you might expect.
14:29:00 <ksf> or agda. or coq
14:29:20 <Eduard_Munteanu> Oh, I know Agda has dependent types, though that's a bit cheating :)
14:29:38 <ksf> I seriously recommend at least dabbling a bit with any of those before doing serious type-level foo in haskell
14:30:10 <Eduard_Munteanu> ksf: hm, I'll go with Agda, I played a very little bit with it.
14:30:17 <Eduard_Munteanu> and it's Haskell-ish.
14:30:44 <ksf> idris even more so
14:30:49 <dolio> You can write something like 'toPeano :: Integer -> (forall n. Peano n -> r) -> r' in Haskell.
14:30:51 <Eduard_Munteanu> c_wraith: I see. Though I think Haskell could infer that the type isn't really infinite.
14:30:55 <dolio> mauke showed how to do it earlier.
14:31:02 <ksf> and it comes with a coq-like theorem assistant, which is a definitive plus.
14:31:35 <Eduard_Munteanu> ksf: thanks, I'll have a look.
14:31:56 <Eduard_Munteanu> dolio: yeah, didn't work for me, I might refactor my code and try again. Basically you can't pass any useful info in the existential.
14:32:04 <Eduard_Munteanu> i.e. it won't be expressed in the output.
14:32:36 <Eduard_Munteanu> dolio: look at the latest revision here, near the end: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26727#a26730
14:32:58 <ksf> hm min is missing in my code, for non-uniform zips.
14:33:07 <Eduard_Munteanu> The only way that works is if \x -> ... somehow forgets x
14:34:01 <ksf> doing the int to peano thing is trivial with th, btw. just recurse down the int and build up the term
14:34:06 <dolio> Yes. The lambda expression is the scope in which you're allowed to work with the peano numeral.
14:34:27 <Eduard_Munteanu> dolio: oh, lol, that's neat.
14:34:43 <Eduard_Munteanu> Didn't see it that way.
14:35:42 <dolio> So the last line should be "toPeano 3 $ \p -> print p".
14:35:53 <Eduard_Munteanu> dolio: yeah, was just about to try it.
14:36:30 <Eduard_Munteanu> Meh, will have to get rid of the IO from the expressoin.
14:36:44 <Eduard_Munteanu> Will just evaluate that someway else.
14:36:46 <dolio> If you were using GHC's existential quantification in datatypes, it'd be the same way: "case toPeano 3 of { Ex p -> print p }".
14:37:27 <FunctorSalad> Peano n -> r or Peanon n => r?
14:37:43 <FunctorSalad> (I realize the former would make sense too with a proposition GADT)
14:38:13 <dolio> I was going with the GADT singleton family indexed by the type-level peano.
14:38:45 <FunctorSalad> singleton family?
14:39:06 <dolio> data Peano n where { Z :: Peano Z ; S :: Peano n -> Peano (S n) }
14:39:23 <FunctorSalad> ok, I meant that with 'proposition' too
14:39:26 <dolio> Each Peano n contains one well-defined value.
14:39:27 <Eduard_Munteanu> print (toPeano 3 $ \x -> show x)
14:39:30 <Eduard_Munteanu> Yup, works.
14:39:37 <Eduard_Munteanu> dolio, mauke: thanks a lot.
14:39:42 <FunctorSalad> (I called this thing "MaybeTower" once in another context ;))
14:40:00 <FunctorSalad> (using Maybe rather than S)
14:40:01 <Eduard_Munteanu> But now I'm more messed up than before as to how this works :))
14:40:18 <Eduard_Munteanu> I was more comfortable with a "it can't!" :)
14:40:46 <FunctorSalad> Eduard_Munteanu: you're familiar with how a 'case' statement on a GADT can bring type equalities into scope in the bodies of the case-branches?
14:40:47 <mauke> we're constructing types at runtime
14:40:58 <FunctorSalad> that's more or less the secret extra ingredient with GADTs ;)
14:41:05 <Eduard_Munteanu> FunctorSalad: brr no. I read only a bit on GADTs.
14:41:15 <mauke> except it's not really types; more like class dictionaries
14:41:48 <Eduard_Munteanu> mauke: actually I think we're tricking Haskell out of the occurs check :/
14:41:55 <mauke> I remember reading an oleg article containing this technique and thinking it was pretty cool
14:42:00 <Eduard_Munteanu> with the existentials
14:42:03 <FunctorSalad> Eduard_Munteanu: in this case, if you have something of type "Peano n", case on it, and are in the branch for Z, you will have the equation "Peano n ~ Z" in the context
14:42:14 <FunctorSalad> ~ is just =
14:42:21 <dolio> There are no infinite types happening.
14:42:31 <FunctorSalad> (it's a syntax that goes wherever class constraints can go)
14:43:01 <Eduard_Munteanu> I see.
14:43:01 <mauke> Eduard_Munteanu: potentially related: http://okmij.org/ftp/Haskell/types.html#Prepose
14:43:35 <FunctorSalad> (I mean "~ is just equality", not the haskell assignment meaning of =)
14:44:16 <Eduard_Munteanu> FunctorSalad: yeah.
14:46:33 <Eduard_Munteanu> Let me ask something... the rank 2 types here actually make it possible to write something a -> b so that a = Succ a doesn't occur?
14:46:59 <Eduard_Munteanu> Though I think I'll have to digest this a bit.
14:47:17 <roconnor> @type \x -> x x
14:47:41 <Eduard_Munteanu> Church?
14:48:02 <Eduard_Munteanu> (I mean numerals)
14:48:38 <edwardk_> dolio fortunately i think i'm saved by applicative composition being sufficient for my use case ;)
14:48:46 <FunctorSalad> you can use () and Matbe where dolio used Z and S, if that helps
14:48:49 <FunctorSalad> *Maybe
14:48:55 <FunctorSalad> they're just clones to make the intention clear
14:48:58 <FunctorSalad> @ Eduard_Munteanu 
14:49:12 <aristid> roconnor: ghci says x x is not constructable
14:49:14 <FunctorSalad> (or maybe they aren't clones on the value level, but at least on the type level)
14:49:55 <Eduard_Munteanu> Yeah.
14:50:04 <FunctorSalad> the GADT "Peano" consists of proof that the argument type is indeed a tower of Maybes over ()
14:50:09 <FunctorSalad> *proofs
14:50:39 <edwardk_> FunctorSalad: or that the maybes never stop
14:50:50 <edwardk_> being CoNats after all
14:50:54 <FunctorSalad> wouldn't that be an infinite type? :)
14:51:02 <FunctorSalad> the value of the type parameter of Peano, that is
14:51:25 <edwardk_> ah i missed that your Peano had a type parameter
14:51:33 <edwardk_> yes
14:51:36 <edwardk_> then you're fine =)
14:51:38 <FunctorSalad> I meant dolio's
14:53:05 <Eduard_Munteanu> Hm, perhaps rank-2 types are more insightful from a proof perspective.
14:54:39 <sshc> "Use -XTypeOperators to allow operators in types"
14:54:47 <sshc> How would that work?
14:56:16 <dolio> @kind Int :+: Char
14:56:22 <dolio> Oh, right.
14:56:27 <dolio> Anyhow, like that.
14:56:35 <FunctorSalad> data (:+:) a b = ....
14:56:51 <FunctorSalad> maybe that one works without -XTO
14:57:04 <FunctorSalad> (and the latter was just for something more advanced?)
14:57:16 <dolio> Also 'forall (+) :: * -> * -> *. Int + Char ...'
14:57:30 <FunctorSalad> any good reason why we don't allow initialisms like that for -X flags btw?
14:57:47 <FunctorSalad> somebody think of the wrists/shoulders/....
14:58:40 <olsner> many -X flags could have the same initials, and code would break
14:59:08 <olsner> if you want to type less, maybe -fglasgow-exts still works as a -XEverything flag
14:59:09 <FunctorSalad> IIRC they're almost all unique
14:59:19 <FunctorSalad> I entered most of them as emacs yasnippets ;)
14:59:29 <FunctorSalad> glasgow isn't everything
15:00:00 <FunctorSalad> the ambiguous ones could just add extra letters after the initial
15:00:02 <olsner> indeed not, just a subset... a smaller and smaller subset
15:00:15 <FunctorSalad> -XTeHa e.g.
15:00:29 <FunctorSalad> just allow arbitrary initialisms
15:00:36 <FunctorSalad> with error on ambiguity
15:01:17 <edwardk_> FunctorSalad: ah neat idea actually, but i suppose the issue then is that new extensions would break old code
15:01:47 <FunctorSalad> true
15:02:00 <ksf> certain sets would be nice
15:02:04 <olsner> well, ambiguity changes with added/removed extensions... which could result in different compilers requiring different sets of abbreviations since they add different extensions in different orders
15:02:18 <olsner> unless there's a single registry of course
15:02:24 <FunctorSalad> (we could just ban them in cabal's QA check though)
15:02:25 <edwardk_> you should do that with a whole programming language. you're not allowed to introduce a new variable that is a syntactic prefix of one already in scope, but now you can abbreviate names as you type. ;)
15:02:34 <FunctorSalad> (it was more for throwaway a stuff)
15:02:49 <edwardk_> who needs intellisense ;)
15:03:20 <edwardk_> or rather i suppose the not allowed to introduce bit isn't necessary
15:03:22 <ksf> things like type operators, tuple sections, bang patterns, view patterns etc. can be switched on without any problems
15:03:23 <FunctorSalad> I once confused myself by defining some macro in ghci that made :m ambiguous
15:03:45 <ksf> ...at least for ad-hoc code that doesn't go to hackage, there should be -XAllSafe or something
15:04:17 <edwardk_> ksf: hah then in that case, the LANGUAGE initialism bit would just turn on all matching pragmas ;)
15:04:22 <FunctorSalad> edwardk_: hmm no-prefixes isn't enough, is it? as in that :m case
15:04:40 <FunctorSalad> adding :meow when :module was the only macro before... breaks :m
15:04:56 <edwardk_> FunctorSalad: i was concerned about ambiguity of assignment. but yeah, you can still break in that case
15:05:28 <edwardk_> FunctorSalad: write it, i'd use it, at least for a day ;)
15:05:51 <edwardk_> ksf: its called -fglasgow-exts
15:05:51 <ksf> wait no. make that -XQuickDirty
15:05:56 <FunctorSalad> I'll scribble it down on my block of half-pages
15:05:57 <FunctorSalad> or something
15:06:26 <edwardk_> -XKitchenSink. or as FunctorSalad would call it -XKS
15:06:26 <danharaj> Man
15:06:33 <FunctorSalad> :)
15:06:36 <danharaj> if you want to import every extension you should be
15:06:37 <danharaj> ...
15:06:41 <danharaj> -XCommunicated
15:06:41 <edwardk_> or should i call him FS now =)
15:06:44 * danharaj ZING
15:06:49 <FunctorSalad> danharaj: why?
15:07:00 <edwardk_> danharaj: *groan*
15:07:05 <FunctorSalad> edwardk_: hmm I'd have to highlight that, not sure if xchat supports regexes
15:07:09 <FunctorSalad> (for \bFS\b)
15:07:23 <chrisdone> woops
15:07:28 <chrisdone> woop
15:07:39 <olsner> \bFS\b causes netsplits? :P
15:07:46 <Eduard_Munteanu> Heh.
15:08:01 <FunctorSalad> I don't get it
15:08:18 <edwardk_> FunctorSalad: well you'd need \bF(u(n(c(t(o(r?))?)?)?)?)?S(a(l(a(d?)?)?)?)...
15:08:24 <olsner> -XCommunicated?
15:08:34 <nolrai_portland> Whats a good name for a Chan with the added functionality of being abble to non-blockingly querry for the most recently added value?
15:08:43 <danharaj> 4Chan
15:08:43 <FunctorSalad> you're just going with its crypticness, or is it some deeper quip about the irc protocol?
15:08:48 <FunctorSalad> (olsner)
15:08:48 <edwardk_> 2Chan
15:08:56 <Eduard_Munteanu> \b\?
15:09:06 <edwardk_> (if its japanese)
15:09:07 <mauke> PeekChan
15:09:07 <olsner> FunctorSalad: no, it's an actual pun
15:09:07 * hackagebot frisby 0.1 - Linear time composable parser for PEG grammars.  http://hackage.haskell.org/package/frisby-0.1 (ChrisDone)
15:09:10 <Eduard_Munteanu> Okay I think this command ends netsplits :P
15:09:16 <FunctorSalad> edwardk_: :) once wrote a similar RE
15:09:19 <edwardk_> frisby lives
15:09:34 <mauke> you think that's a regex?
15:09:42 <FunctorSalad> Eduard_Munteanu: matches the empty string, but only at word boundaries
15:09:56 <mauke> \cC(?:01|1(?!\d))(?!,(?!01|1(?!\d)|14)\d)(?:,\d\d?)?  <-- this is a regex
15:10:16 <olsner> is that the prime number irregex
15:10:21 <FunctorSalad> some manpage's at first contrived-looking, but on reflection, rather elegant definition ;)
15:10:23 <Eduard_Munteanu> FunctorSalad: ah yes, I was making fun along with olsner 
15:10:25 <mauke> no, the prime number regex is simple
15:10:44 <olsner> hmm, divisability then perhaps? :)
15:11:01 <FunctorSalad> olsner: \bFS\b is a pun?
15:11:11 <FunctorSalad> related to netsplits? *dizzy*
15:11:13 <olsner> FunctorSalad: no, it's just something you said just before the netsplit
15:11:20 <Eduard_Munteanu> FunctorSalad: no but a netsplit happened just after you said it :)
15:11:21 <olsner> I hope :)
15:11:33 <FunctorSalad> didn't notice it
15:11:44 <mauke> (?:(?:[Hh]t|[Ff])tps?://|\bwww\.)[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*(?::[0-9]+)?(?:/(?:[\w\-/%&?=+#~:'@*^$!]|[.,;'](?=\S)|(?:(\()|(\[)|\{)(?:[\w\-/%&?=+;#~:'@*^$!.,;]|(?:(\()|(\[)|\{)[\w\-/%&?=+;#~:'@*^$!.,;]*(?(3)\)|(?(4)\]|\})))*(?(1)\)|(?(2)\]|\})))*)?
15:11:45 <FunctorSalad> (parts are hidden)
15:11:56 <FunctorSalad> makes sense now ;)
15:11:58 <olsner> the thing about the pun was referring to danharaj's pun
15:12:07 <FunctorSalad> \bFS\b
15:12:13 <FunctorSalad> just checking
15:12:26 <dons> hackage stats for Q1 and Q2 2010: http://donsbot.wordpress.com/2010/06/30/popular-haskell-packages-q2-2010-report/
15:12:52 <danharaj> To really get the most out of that pun
15:12:59 <danharaj> you gotta pretend I just took off my sunglasses
15:13:06 <danharaj> when I deliver the punchline.
15:13:45 <FunctorSalad> 3 miles per gallon pun? (or whatever the stereotypical figure for good mileage was in imperial units)
15:13:56 <Botje> mauke: is that your native tongue?
15:14:01 <mauke> yes
15:14:16 <Botje> not a popular language i wager :)
15:14:23 <FunctorSalad> danharaj: haha
15:14:38 <Botje> (yeah okay, it's a regex for URLs, i see that now)
15:14:42 <chrisdone> it's quite theraputic to clean up unmaintained packages
15:14:44 <FunctorSalad> danharaj: it didn't seem deliberate at the time though, more like an afterthought
15:14:49 <FunctorSalad> (the -XC)
15:14:57 <mauke> for bonus points, figure out what /^\s*(?:((?(1)(?(3)(?(2)\2|\3)(\1)|(\S))|\S))\s+)+$/ matches
15:15:01 <chrisdone> dons: thanks, sounds good
15:15:02 <FunctorSalad> chrisdone: for the packages?
15:15:21 <FunctorSalad> wtf I won't even count the parens :p
15:15:39 <FunctorSalad> maybe an indented form would help to make regexes readable too
15:15:46 <mauke> perl has that
15:15:47 <FunctorSalad> (with insignificant whitespace)
15:15:59 <pizza_> it sort of works in perl, but not really
15:16:04 <FunctorSalad> (or even better, whitespace defining groups)
15:16:16 <mauke> sample inputs you should try: "x x", "x x x", "x x xx"
15:16:55 <Botje> i'll stare at it later
15:17:12 <FunctorSalad> . o O ( syntax highlighting that indicates paren level with background shade )
15:17:16 <Botje> random guess: concat of the first two groups?
15:17:17 <mauke> actually, imagine \n at the ends
15:17:22 <mauke> I'm assuming trailing whitespace here
15:17:28 <interferon_> Is there a way to generically diff two objects?  Maybe in syb?
15:17:39 <FunctorSalad> (any editor has that? yes I know it's possible with elisp, given unbounded time)
15:17:48 <mauke> Botje: even better!
15:17:51 <Botje> i'll play with it tomorrow if i remember
15:18:09 <FunctorSalad> interferon_: yeah I once did something like that
15:18:13 <olsner> FunctorSalad: unbounded? shouldn't it be at worst O(n) in the size of the document?
15:18:42 <chrisdone> hackage has a diff library
15:18:43 <pizza_> FunctorSalad: some IDEs have colored scope indication, it's ugly
15:18:57 <pizza_> or rahter, i've never seen one that wasn't
15:19:02 <chrisdone> http://hackage.haskell.org/packages/archive/Diff/0.1.2/doc/html/Data-Algorithm-Diff.html
15:19:24 <FunctorSalad> you just compare the constructors; if they don't match, make a "are different" leaf; if they match, recurse on children and make a pseudo-value like "Foo Differ Differ (Bar (Same 3))"
15:20:20 <FunctorSalad> ("Same" on matching leafs)
15:20:26 <interferon> Yeah it's easy enoughto implement for any given type, but id there a generic Data.Generic.gdiff or something?
15:20:28 <chrisdone> hackage is looking a lot fuller every month
15:20:33 <FunctorSalad> Differ can be annotated with the two values of course
15:20:42 <FunctorSalad> interferon: I meant with syb
15:21:07 <FunctorSalad> gmapQ to obtain the children, and there was some function to obtain the head ctor
15:21:49 <interferon> Ah gotcha
15:23:37 <FunctorSalad> olsner: I meant to write/debug the code
15:23:38 <FunctorSalad> ;)
15:23:44 <chrisdone> FunctorSalad: i packed up the frisby library to use the latest base and extensions http://hackage.haskell.org/package/frisby
15:23:59 <chrisdone> so you can try it :-)
15:24:06 <FunctorSalad> pizza_: hmm aesthetics seem tweakable...
15:24:27 <FunctorSalad> could be a mild luminosity change
15:24:55 <FunctorSalad> and it seems redundant for scope that's indented anyway; I was thinking of it for tight parenthesizes expressions
15:25:07 <FunctorSalad> s/zes/zed/
15:25:40 <olsner> well, you can always break it up and e.g. add temp variables until it doesn't have too many parens to read :)
15:26:02 <FunctorSalad> (like ff::WebDeveloperExtension::Show topology, or so)
15:26:20 <FunctorSalad> shades the site in grayscale according to nesting depth
15:27:20 <chrisdone> does anyone know the difference between the HDBC and hsql libraries?
15:27:31 <chrisdone> i've used them both in the past and i can't remember a distinctive difference
15:27:53 <chrisdone> if they're not distinct i think they need to be merged
15:28:07 <FunctorSalad> chrisdone: pardon, the context for frisby was? as a replacement for REs in haskell?
15:28:07 <chrisdone> people keep asking me what db library to pick and i have no idea
15:28:31 <chrisdone> FunctorSalad: we were discussing PEGs the other day and i mentioned there was a library for doing it in haskell
15:29:08 <FunctorSalad> yeah I remember that we discussed them, but not that I needed a working implementation for something in particular?
15:29:27 <chrisdone> it's just fyi
15:29:33 <FunctorSalad> ok :)
15:29:53 <ksf> frisby doesn't parse regular languages
15:30:02 <ksf> packrat parsers are more expressive
15:30:03 <FunctorSalad> a superset
15:30:15 <ksf> ...and not as nicely minimizable.
15:30:23 <FunctorSalad> and apparently it's fast, hence me calling it a "replacement" :)
15:30:27 <FunctorSalad> ah
15:30:44 <ksf> faster than a top-down parser, yes
15:30:53 <chrisdone> frisby is a packrat parser
15:30:54 <FunctorSalad> alternatively, someone could figure out how =~ works
15:30:57 <FunctorSalad> in the existing regex libs
15:30:59 <FunctorSalad> ;)
15:31:06 * ksf is still interested in whence NWAs will lead us
15:31:10 <olsner> chrisdone: hopefully I'm wrong, but HDBC sounds like a wrapper around ODBC
15:31:30 <chrisdone> are you just going off the name? :P
15:31:32 <ksf> =~ is an insult to applicative functors.
15:31:33 <FunctorSalad> I understand the Bool return type and [[String]] kinda
15:31:34 <c_wraith> fortunately, you're wrong. :)
15:31:46 <FunctorSalad> most of the others are mysterious ;)
15:32:02 <dolio> Is it faster than a good RE parser? I know frisby's (supposed to be) fast for a packrat parser, but that doesn't necessarily imply the former.
15:32:14 <chrisdone> olsner: there is an odbc driver for it, but yeah, it's just similar name. ham / hamster
15:32:23 <ksf> hell I should finally figure out how to incorporate the kleene star in my stuff
15:32:46 <mtnviewmark> thanks qDot for the visit and tour of 510
15:32:46 <FunctorSalad> ksf: what's the connection to applicatives? :O
15:32:55 <mtnviewmark> whoops -  wrong window
15:32:58 <c_wraith> chrisdone, I had no idea hamsters were so tasty
15:33:07 <chrisdone> dolio: it purports to be, but i haven't done benchmarks. maybe that would make a fun weekend project. benchmarking all the parsers for some problems
15:33:44 <FunctorSalad> (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target -- Defined in Text.Regex.TDFA
15:33:45 <ksf> to specify the semantics. there's a big difference between getting back a mess of tuples and lists and packing stuff into a proper ADT intertwined with the actual grammar.
15:34:41 <FunctorSalad>  /exec'ing the :i RegexContext would get me kicked from server
15:34:43 <FunctorSalad> ;)
15:34:54 <chrisdone> The Haskell Language Parser Shootout Game Competition
15:35:24 <olsner> hmm, that could probably be a gsoc project - figure out if either of the database packages are more generic and rewrite the API of the other in terms of that one
15:35:42 <chrisdone> i agree, definitely
15:35:55 <mtnviewmark> I was thinking of benchmarking memoization libraries this weekend
15:36:16 <chrisdone> from what i've seen they provide the same boring imperative interface, both provide transactions, string building methods based on a class, etc.
15:36:30 <chrisdone> it seems in the past the only reason to use one or the other is when a driver written for one of them is well supported
15:37:03 <olsner> in other cases, you could always fall back on john goerzen being more famous than nick rudnick
15:37:06 <ksf> FunctorSalad, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26733#a26733
15:37:09 <chrisdone> lol
15:37:14 <ksf> how's that for a regex interface?
15:37:32 <ksf> (the monad instance most likely won't be in the final thing, though)
15:37:53 <dolio> Does it have complement?
15:38:03 <dolio> And intersection?
15:38:11 <ksf> ...alternatively, it will be restricted to what can be expressed applicatively
15:38:29 <ksf> dolio, complement of character sets, yes.
15:38:40 <sposato_asmOsx> !ops a `special message` to you `from `BIKCMP: 500 Server closed connection without sending any data backn
15:38:41 <dolio> I mean complement of expressions.
15:38:41 <chrisdone> HDBC is vastly more popular than hsql, at least -- so a merging of them might not be so controversial
15:38:53 <ksf> that is, it supports matching on ranges, and you can just exclude.
15:39:37 <netSolarisjava> !ops a `special message` to you `from `BIKCMP: girl, i must be cervical cancer because i'm totally eating your pussy
15:40:15 <ksf> oh, someone's begging for a lifelong ban there.
15:40:32 <danharaj> ksf: they are bots, but they should probably be g-lined
15:40:36 <ksf> dolio, nope.
15:40:47 <chrisdone> well, i'll go through both of them this week and make sure there aren't some glaring differences and then write a proposal to the maintainers of both packages and to the Haskell community to merge and migrate
15:40:55 <ksf> afaiu that wouldn't be regular.
15:41:00 <dolio> That's what I (and I think Cale) want to see in a regex library. Provide combinators for all the nice operations that regular languages are closed under, but are always left out of regex libraries.
15:41:29 <dolio> Instead of adding all sorts of things that make the languages expressed non-regular.
15:41:37 <ksf> I won't go further that what's minimizable with Yoctoparsec. and, most importantly, no lookahead and backtracking.
15:41:47 <danharaj> I think it is lame to call yourself a <foo> library if you don't implement all standard operations efficiently.
15:41:50 <sshc> Is there a way to debug a cabal package with ghci?
15:42:06 <chrisdone> sshc: debug in what way?
15:42:21 <ksf> it's meant to be used for protocols etc. that are designed to be regular, not general parsing or ad-hoc matching.
15:42:44 <Apocalisp> What do you call this functor? type f x = ()
15:42:45 <sshc> Manually calling ghci on the main source file seems inconvenient, since I have to add LANGUAGE pragmas, and hide some packages.
15:42:56 <sshc> add language pragmas to the file itself
15:43:01 <sshc> ANd pass options to ghci
15:43:10 <ksf> Apocalisp, a syntax error.
15:43:13 <sshc> cabal conveniently hides the packages for me
15:43:20 <sshc> And I specified all the options in the cabal file
15:43:35 <sshc> I can ./Setup.hs configure, build, and install, but I'd like to load the main source file in ghci for debugging.
15:43:56 <mauke> language pragmas belong in the source file
15:44:34 <sproingie> add them to the cabal file too so you know what you're depending on
15:44:35 <sshc> mauke: I'm using the "extensions" field in the cabal file
15:44:43 <Apocalisp> ksf: Okay, data F x = Nil
15:44:45 <sproingie> sshc: you use both
15:44:48 <sshc> Oh!
15:44:51 <ivanm> dcoutts says you should use both
15:45:04 <sshc> The other problem is the packages that need to be hidden
15:45:16 <dafis> Apocalisp, a trivial functor
15:45:29 <sproingie> the extensions field in the cabal file is a dependency specification on features of the compiler.  the pragmas in the source actually turn them on
15:45:36 <Apocalisp> dafis: Thanks
15:45:48 <sshc> Should I also keep the ghc-options pragmas in the files too?
15:45:50 * ksf meditates about closedness under complement
15:46:01 <ivanm> sshc: what are you doing with them?
15:46:12 <ksf> actually, yes, that's easy.
15:46:12 <ivanm> only if you really need them for per-file stuff
15:46:17 <sproingie> if they're just language pragmas, no
15:46:24 <sproingie> if they're really ghc-specific options yes
15:46:30 <sshc> sproingie: OPTIONS_GHC pragmas
15:46:38 <ksf> ...and it's not a thing that needs support by the engine, it's a pre-processing step on the grammar.
15:46:39 <sproingie> oh that.  dunno.
15:47:03 <sshc> The pragma contains -Werror -O2 -threaded
15:47:03 <ksf> intersection should fall into the same category.
15:47:05 <sshc> in each file
15:47:12 <sproingie> i've never done that.  of course i've only done a few real simple cabal files
15:47:14 <mauke> -Werror is a bad idea
15:47:20 <sshc> mauke: Why?
15:47:23 <ivanm> sshc: put that in the cabal file
15:47:29 <mauke> because future compiler versions will break your package
15:47:32 <sproingie> newer versions of the compiler add warnings
15:47:35 <ksf> nope, leave it out completely.
15:47:41 <sshc> ivanm: Okay.
15:47:56 <sproingie> -Werror is ok for development, tho i find some errors i just can't ditch
15:47:57 <ivanm> sshc: e.g. 6.12 now makes it an error for some things that it says won't be in future versions of ghc
15:47:57 <mauke> -O2 is not semantically relevant, so it doesn't belong in the source file
15:47:59 <sshc> ksf: No thanks; I'd like to keep my optimizations and I need to -threaded ;)
15:48:01 <mauke> it's a build option
15:48:03 <sproingie> s/errors/warnings/
15:48:06 <ivanm> sproingie: yeah :(
15:48:20 <sproingie> that or i'd need ungodly ugly boilerplate to ditch them
15:48:21 <ksf> you will have people taring and feathering if the package fails to compile for a trivial warning in the future.
15:48:21 <sshc> Should I use -O2 or only -O?
15:48:36 <ksf> cabal sets -O2
15:48:40 <mauke> it does?
15:48:42 <ivanm> sshc: generally people recommend -O becuase -O2 doesn't work too well on some architectures IIRC
15:48:45 <mauke> I thought it defaults to -O
15:48:52 <ivanm> mauke: same
15:48:53 <sshc> ivanm: Really?  I thought they were identical.
15:48:58 <ksf> in any case, that's configurable.
15:49:01 <sshc> ivanm: How are they different?
15:49:07 <sshc> ivanm: Does -O default to -O1?
15:49:10 <sproingie> yes
15:49:13 <ivanm> -O2 does more stuff
15:49:24 <sproingie> does -O3 do any more or is the max -O2?
15:49:30 <mauke> -O3 doesn't exist
15:49:39 <sshc> I see.
15:49:43 <mauke> actually, my packages violate that rule; they specify -O2 in the cabal file
15:49:45 <ivanm> not in GHC, anyway
15:49:46 <mauke> I should remove that
15:49:50 <ivanm> and -O4 is right out
15:49:52 <ivanm> ;-)
15:50:15 <sproingie> -XNaughtyInMySight
15:50:27 <ivanm> yay! someone got the reference!
15:51:07 <dafis> ivanm: iirc, it should've been -O5 is right out
15:51:09 * sshc didn't
15:51:32 <mauke> monty python and the holy grail
15:51:33 <dafis> sshc: Monty Python, Holy Grail
15:52:01 <ivanm> dafis: well, that was when 3 was the number wanted; here 2 is the number wanted
15:52:37 <sproingie> yeah well thou canst countest only to -O2
15:52:57 <bcw> Cale, i'm following still following your tutorial "Monads as containers" on haskellwiki.  i'm doing the exercise (making "Tree a = Leaf a | Branch (Tree a) (Tree a)" into a monad).
15:53:02 <dafis> sproingie, but I've never seen GHC complain about -O3
15:53:04 <ivanm> though shalt not countest to -O1, unless thou immediately proceeds to -O2
15:53:10 <ivanm> dafis: it just turns it into -O2
15:53:18 <bcw> Cale, i notice it says "all monads are functors", but testing with fmap on GHC 6.12.1 says "No instance for (Functor Tree)"
15:53:18 <ivanm> preflex: seen Cale 
15:53:18 <preflex>  Cale was last seen on #haskell 19 hours, 49 minutes and 4 seconds ago, saying: :t (\x -> x 1)
15:53:18 <dafis> ivanm: I know
15:53:30 <ivanm> bcw: they are, but not by default
15:53:33 <mauke> bcw: that's because you didn't define an instance for it
15:53:35 <sproingie> gcc will let you put anything after -O but it only understands 0-3
15:53:36 <dafis> and I've never actually passed -O3 to GHC :)
15:53:37 <ivanm> and Cale doesn't appear to be online
15:53:50 <mauke> bcw: monads are functors, but Monads aren't Functors :-)
15:53:53 <sproingie> -O3 doesnt' turn on very much.  i think it affect c++ more
15:54:00 <bcw> ok
15:54:09 <danharaj> -O4 >_>;
15:54:20 <ivanm> bcw: theoretically, all monads are functors with fmap = liftM, but currently there is no requirement to do so and there's no way to automatically make all monads functors
15:54:32 <mauke> -O500  (I'm a gentoo user)
15:54:41 <sproingie> gcc used to recognize -O10 for some optimizations like tail recursion elimination but i think those went down to -O3
15:54:46 <dafis> sproingie, for GHC itself, 2 is max, -optc-O3 does a bit over -optc-O2, but not very much
15:54:49 <mauke> sproingie: -O2
15:54:51 <Veinor> -Oaleph_null
15:54:52 <mauke> maybe even -O1
15:55:05 <bcw> do I have to define fmap myself then, or will declaring it as a Functor instance work without it?
15:55:09 <Veinor> or possibly -Oomega
15:55:25 <ivanm> mauke: yeah, if only GHC understood crazy CFLAGS...
15:55:25 <ivanm> ;-)
15:55:32 <mauke> bcw: you will have to define it
15:55:33 <dafis> bcw: define it
15:55:37 <mauke> fortunately the code is very short
15:55:45 <bcw> ok. thanks
15:55:46 <ivanm> bcw: "instance Functor Tree where fmap = liftM"
15:55:57 <bcw> right, i'll try that
15:56:06 <sproingie> -Ograhams-number
15:56:06 <dafis> bcw: if you have no better implementation, fmap = liftM will do
15:58:51 <mle> I always liked the sound of -malign-functions
15:59:05 <dafis> mle: why would you?
15:59:14 <mauke> gcc -malign-double
15:59:20 <mauke> because my code is evil
15:59:25 <ivanm> dafis: because the m completely changes the meaning of the first word?
15:59:26 <danharaj> punny
15:59:34 <mle> heh
15:59:41 <sproingie> -vomit-frame-pointer
15:59:45 <mauke> gcc -Larry -Wall
15:59:51 <ivanm> lol
15:59:55 <dafis> ivanm: that was the question, why would one malign functions
16:00:13 <ivanm> dafis: it's meant to be align-functions with an -m prefix...
16:00:34 <sproingie> the m stands for "machine"
16:00:55 <dafis> ivanm: I know, I'm just being silly
16:00:56 <sproingie> -march=briskly
16:01:07 <dafis> sproingie, :)
16:01:16 <ivanm> I've always found even plain ol' -Wall mildly amusing
16:01:30 <sproingie> -WTF
16:01:34 <triyo> is there a trick to exporting class types from another module in different (my own) library?
16:01:38 <ivanm> then there's -funbox-strict-fields
16:01:44 <sproingie> mm funbox
16:01:48 <mauke> -funroll-loops
16:01:50 <triyo> I get cmd2entry' is not a (visible) method of class `Parsable' ..Failed, modules loaded: Types.
16:02:12 <Veinor> fun roll!
16:02:13 <ivanm> triyo: either import the module that defines the instance or if there isn't one write your own
16:02:31 <mauke> ivanm: what
16:02:37 <dafis> triyo: cmd2entry may not be an exported method
16:02:56 <ivanm> oh, whoops, I thought that was a non-instance error
16:03:05 <ivanm> (it's too early...)
16:03:10 * ivanm -> breakfast
16:03:59 <triyo> dafis: what do you mean by "may not be..."?
16:04:24 <triyo> I have a Parsable class type in a lib I wrote...
16:04:31 <mauke> did you export its methods?
16:04:33 <ivanm> triyo: it sounds like whichever module exports Parsable doesn't export cmd2entry
16:04:37 <triyo> In a diff lib I wish to supply a instance
16:04:42 <ivanm> you need to export it like Parsable(..)
16:04:47 <dafis> triyo: e.g. in the class IArray defined in Data,Array.Base, there are some methods that are not exported from Data.Array.IArray
16:05:46 <dafis> triyo: If you wrote it yourself, in what form did you export the class?
16:05:55 <triyo> ok, thanks I'll have a look for ideas. I have Parsable(..) at the top of my module but no luck.
16:06:09 <triyo> what do you mean by "what form"?
16:06:11 <mauke> how did you import it?
16:06:20 <bcw> i've been laughing at these flag jokes since i noticed the first one :D
16:06:43 <dafis> triyo: whether Parsable(..) or Parsable(meth1, meth2) or Parsable, meth1, meth2
16:06:59 <triyo> I exported using Parsable(..)
16:07:36 <dafis> triyo: since you exported it (..), how did you import it (what mauke asked before)
16:08:12 <Baughn> We need some way to specify that a type function is bijective
16:08:12 <dafis> triyo: you need to import it with (..) or explicit listing of the methods to have the methods in scope
16:08:13 <triyo> I imported using the full module name that contains the class type
16:08:19 <bcw> my favorite tech joke comes from C source, rather than flags:  goto hell;
16:08:20 <triyo> ohh :)
16:08:34 <mauke> triyo: stop paraphrasing when we're asking for code
16:08:41 <Veinor> you know what my favorite programming joke is? php! ahahahaha
16:08:44 <dafis> triyo: if you imported the entire module, that should've sufficed
16:09:00 <mauke> bcw: short change;
16:09:01 <sproingie> Veinor: unfortunately it's an unfunny one i'm often forced to participate in
16:09:07 <Veinor> yeah :(
16:09:27 <dafis> bcw: I know that from VB: On Error GoTo Hell :)
16:09:29 <bcw> Veinor, well, "programming php" is my favorite joke book...
16:09:38 <bcw> they can't get their syntax right
16:10:01 <dafis> bcw: syntax ????
16:10:16 <bcw> yes, there's tons of syntax errors in programming php
16:10:28 <dafis> php has syntax?
16:10:52 <bcw> ah, well, maybe not.  but what passes for code in that book doesn't work if you try it
16:11:20 <dafis> bcw: maybe you misread the title and it's a teco book
16:11:32 <dafis> anything works in teco
16:11:45 <dafis> just nobody knows how
16:11:59 <sproingie> the publishing process often mangles source code
16:12:39 <bcw> i've never heard of teco, but sounds like i don't want to hear of it
16:12:46 <triyo> dafis: ahh, its my ghci session via emacs that went wonky 
16:13:02 <triyo> it works fine now
16:13:17 <dafis> sproingie: another possibility is that between the writing and the publishing of the book five new versions of php have been released
16:14:27 <danharaj> I friggin hate pdf's
16:14:37 <dafis> danharaj, why?
16:14:39 <danharaj> adobe reader sucks
16:14:46 <danharaj> and they are bloated compared to .djvu's
16:14:59 <dafis> danharaj, 'kay, what about Okular,xpdf, ... ?
16:15:23 <danharaj> wat
16:15:33 <bcw> other viewers for pdf's
16:15:46 <danharaj> who knows.
16:15:52 <Apes> Tons of alternate pdf viewers
16:16:03 <danharaj> yes, there are many ways to rape a cat.
16:16:11 <sproingie> ...
16:16:31 <bcw> pdf's are better than Word doc's
16:16:40 <sproingie> i dunno, you can reflow a word doc
16:16:48 <dafis> bcw: what's not?
16:17:13 <dafis> sproingie: but it's not in the least pprtable
16:17:22 <dafis> *portable*
16:17:36 <sproingie> tradeoffs.  all right html then.
16:17:46 <enferris> I swear by LaTeX to PDF.
16:17:47 <Apes> You could always save your Word files as .txt instead of .doc
16:17:49 <dafis> at least two thirds of the target audience won't be able to read it
16:17:53 <sproingie> i want a form that's pixel-perfect and still crisp, i'll take pdf every time
16:17:57 <danharaj> two thirds?
16:18:03 <sproingie> i want something for reading, html for me
16:18:23 <dafis> danharaj, *my* target audience :D
16:18:26 <flaps_Loreztabne> !ops a `special message` to you `from `BIKCMP: Fuck all authority figures of any type. Now instead of hearing the song and letting it pass by you I think we should all rise against and do somin about authority..... and they can feel the rage of OUR generation!!!!!!!!!!!!!
16:18:50 <sproingie> can we permaban that gateway?
16:18:54 <dafis> say people, what's with the spambots today?
16:19:25 --- mode: ChanServ set +o mauke
16:19:25 --- kick: flaps_Loreztabne was kicked by mauke (flaps_Loreztabne)
16:19:33 <dafis> mauke++
16:20:25 <dafis> mauke: don't give up Op status too soon
16:20:34 <mauke> why?
16:20:42 <Nullsco> !ops a `special message` to you `from `BIKCMP: My new XBOX 360 controller is one out of ten collector's editions ever made. Handcrafted from a block of pure platinum, the buttons are various precious and semiprecious stones, expertly cut and polished to brilliance by noted Japanese philosopher and artisan Inazo Nitobe. It can operate in wireless mode from over 3km away, and the force feedback is powerful enough to slice through a f
16:20:46 <unixPhp> !ops a `special message` to you `from `BIKCMP: There is very little of value in blogging. There are some real journalists who have an online newsletter, and real writers who post articles independently -- that they happen to be classified as blogs flatters the sycophantic self-indulgent blogosphere at large. Imagine if you serialized your blog and emailed all your friends with it every time you updated it? If they wouldn't welcome s
16:20:48 <BMeph> Where'd lambdabot go?!? :(
16:20:59 <danharaj> the spambots took her
16:21:04 <dafis> mauke: 'cause there just entered another spambot
16:21:07 --- mode: mauke set +q *!*@gateway/web/freenode/ip.*
16:21:08 <danharaj> are you a bad enough dude to save lambdabot?
16:21:18 <pizza_> lol
16:21:23 <mauke> pchiusano, BMeph: sorry :-(
16:21:47 <Apes> What happened to lambdabot?
16:21:51 <Phyx-> i thought lambdabot was invincible
16:22:02 <Phyx-> or... did they use agdabot?
16:22:51 <mauke> dafis: doesn't really matter, it's all done with scripts
16:23:07 --- mode: mauke set -o mauke
16:23:08 <mauke> from my perspective I'm always +o
16:23:29 <Phyx-> lol
16:23:48 <Phyx-> i was just gonna say how you're wearing your shiny @ badge today
16:23:49 <Phyx-> :P
16:25:15 <ddarius> xchat just started interpreting all my keyboard input as '2'
16:25:21 <lispy> something wrong with lambdabot?
16:25:33 <lispy> Anything more than the normal misbehaving I mean
16:25:42 <lispy> ddarius: that's 2 bad
16:25:57 <dafis> lispy: seems contagious
16:26:19 <danharaj> ddarius must encode everything in unary
16:26:30 <_Ray_> Hey, newbie question. How should I read "(<*>) :: f (a -> b) -> f a -> f b", where f is a Functor?
16:27:00 <lispy> f (a -> b) -> (f a -> f b)
16:27:26 <mauke> _Ray_: which part are you having problems with?
16:27:49 <_Ray_> My lack of a parser for Haskell function type declarations :s 
16:27:51 <edwardk> _Ray_: (<*>) is a function that takes an 'f (a -> b)' and gives you back a function that takes an 'f a', and returns an 'f b'. You can treat that as a binary function, that expects two arguments
16:28:11 <lispy> _Ray_: if you look at it the way I wrote it, then you might see that it was a function inside the functor, but then it becomes a function from f a to f b
16:28:13 <mauke> A -> B is the type of functions that take A and return B
16:28:30 <mauke> -> associates to the right
16:28:32 <edwardk> so "foo <*> bar" is the application of that function, foo is expected to have type 'f (a -> b)', bar is expected to have type 'f a'
16:28:59 <_Ray_> So an example would be Maybe (foo -> bar)?
16:29:00 <edwardk> if f was [] (for list), then you'd expect foo to be a list of functions, and bar to be a list of arguments
16:29:05 <edwardk> _Ray_ exactly
16:29:16 <edwardk> er
16:29:17 <edwardk> rather
16:29:49 <edwardk> You'd have foo <*> bar  -- meaning that foo :: Maybe (a -> b)    and bar :: Maybe a -- can be combined to give a Maybe b
16:29:59 <mauke> > Just sqrt <*> Just 2
16:30:12 <edwardk> the definition does the obvious thing in that case. Just f <*> Just a = Just (f a) -- all the other cases evaluate out to Nothing
16:30:23 <mauke>  Just 1.4142135623730951
16:30:53 <_Ray_> I think I get it. Thanks :)
16:31:27 <Veinor> @djinn (a -> b) -> (f a -> f b)
16:31:31 <Veinor> bah
16:31:59 <Veinor> where'd lambdabot go?
16:32:19 * lispy has no idea
16:32:56 <Veinor> 11:46:19*               <-- lambdabot (~lambdabot@li85-105.members.linode.com) has quit (Ping timeout: 276 seconds)
16:33:00 <lispy> The process isn't even running
16:33:13 <Veinor> oh noes
16:33:54 <lispy> Cale: ping
16:34:25 <lispy> preflex: tell Cale is Lambdabot misbehaving?  Is there something I can do to help?
16:34:26 <preflex>  Consider it noted.
16:35:47 <edwardk> hrmm. i wonder if there is a decent 'Speculative' comonad.
16:36:02 <edwardk> i.e. bundle up the value with its guess (and even comparison function)
16:36:28 <edwardk> fmap would just map over each, etc. then when you go to extract it would use spec to compare them
16:36:53 <lispy> edwardk: that's interesting.  I could see it being useful for ranking query results or machine learning problems
16:37:29 <edwardk> lispy: *nods*
16:37:30 <ddarius> edwardk: And duplicate?
16:38:21 <edwardk> ddarius: still wondering on that one what the right semantics would be ;)
16:40:13 <edwardk> i.e. Spec a -> Spec (Spec a) -- should probably do something like take duplicate (Spec cmp g a) = Spec (Spec (const True) g g) (Spec cmp g a) -- where known lifts a value into Spec in such a way that
16:40:23 <edwardk> er drop everything after --
16:40:28 <edwardk> er the second -- =)
16:41:12 <edwardk> duplicate (Spec cmp g a) = Spec (Spec (\_ _ -> True) g g) (Spec cmp g a)
16:41:39 <edwardk> the left hand side says that you get a guess at the guess, where the best guess is the guess itself, and the right hand side is the original
16:41:50 <edwardk> (and i dropped the lifted cmp from that somewhere)
16:41:54 <danharaj> hey, question here. So I've read through Pierce and I think I have a handle on system F with all its variants. I was wondering, how do various ways of specifying datatypes fit in as extensions to system F, like algebraic data types?
16:41:59 <edwardk> one more try =)
16:42:11 <danharaj> Are they just sugar for records?
16:42:27 <edwardk> duplicate (Spec cmp g a) = Spec (cmp `on` extract) (Spec (\_ _ -> True) g g) (Spec cmp g a)
16:43:07 <edwardk> danharaj: one sec. lemme dig up a paper on adding them to pure type systems
16:43:35 <edwardk> danharaj: http://people.cs.uu.nl/johanj/MSc/jwroorda/ -- system f falls into the lambda cube so the results there apply
16:43:43 <danharaj> sweet :D
16:44:11 <danharaj> A lot of this stuff happens at Utrecht, eh?
16:44:16 <edwardk> ddarius: i'm not sure if the comonad laws check out but the definition above has at least the right intuition for me
16:46:55 <edwardk> ddarius: hrmm that above definition seems to neglect the accumulation of the map though
16:47:56 <edwardk> ah contravariant Yoneda lemma to the rescue
16:48:58 <bcw> i'm reading the wikipedia article on TECO now.  i didn't remember it shared history with emacs.  but this teco "program" made me laugh: http://en.wikipedia.org/wiki/Text_Editor_and_Corrector#Example_3
16:49:50 <Twey> Eek.  Looks like a vim command.
16:50:07 <danharaj> Is it possible to have a language such that every legal program halts, but the set of legal programs is not recursively enumerable?
16:50:48 <edwardk> hah the signature of my Spec comonad: data Spec a = forall e. Spec (e -> e -> Bool) e (e -> b) e -- it is the arguments to 'specBy'
16:50:50 <bcw> it's a brainf*ck interpreter, apparently.  implementing one unreadable language with another :)
16:51:02 <Twey> danharaj: Including infinite recursion?
16:51:04 <edwardk> er (e -> a)
16:51:08 <c_wraith> danharaj, depends on your definition of "legal" in the language.
16:51:18 <danharaj> c_wraith: Parses, type checks, compiles :p
16:51:50 <interferon> so i think i understand that arrows are like monads with static information attached to each bind so you can walk through the binds without running the monad itself.  but i'm confused about what tuples, first, second, and swap have to do with that idea
16:51:51 <danharaj> Twey: Think of a language where recursion must be accompanied by a proof that the recursion terminates.
16:52:02 <Twey> danharaj: Agda does that
16:52:04 <kmc> danharaj, sure.  my language is defined as the subset of Java which halts
16:52:16 <danharaj> The follow-up to this question is whether you can write an interpreter for the language within the language.
16:52:19 <Twey> kmc: Hax :þ
16:52:21 <kmc> the legal programs in Agda aren't RE?
16:52:35 <ddarius> edwardk: Is it a left Kan extension.
16:52:37 <kmc> interferon, they're plumbing necessary to implement the arrow syntax
16:52:43 <Twey> I'd imagine they are.  Assuming infinite recursion is allowed.
16:53:08 <edwardk> ddarius: yes, (i'm using the contravariant yoneda lemma after all)
16:53:10 <interferon> kmc: that's all?  and to be honest...i don't really understand the arrow syntax
16:53:23 <kmc> Twey, but when infinite recursion is not allowed, then the type/totality checkers can't reliably judge programs as being sound?
16:53:27 <Twey> s/the arrow syntax/arrows/
16:53:42 <kmc> wouldn't you then define legal Agda programs as "those which pass the checker"?
16:53:43 <danharaj> Twey: I suppose a more reasonable restriction is that programs either halt or are always productive.
16:53:45 <c_wraith> I think any language that can statically prove that its input terminates gives you an easy algorithm for recursively enumerating all possible programs in it.
16:54:13 <c_wraith> err, the input being the program the compiler is compiling.
16:54:29 <Twey> kmc: I was talking about recursion in the language definition
16:54:48 <Twey> Since there are an infinite number of programs, it requires an infinite number of time to enumerate them all
16:54:49 <kmc> oh
16:54:49 <mm_freak> i've forgotten how to use autoconf and automake…
16:54:51 <danharaj> c_wraith: If the language uses proofs, the algorithm might not halt as it searches for a proof for the functional part of the program.
16:54:56 <Twey> Er, amount of time**
16:55:07 <kmc> Twey, that's fine, that's how RE works
16:55:08 <edwardk> newtype PreSpec e = PreSpec (e -> e -> Bool) e e  -- CoYoneda PreSpec e ~ Lan Id Spec e ~ Spec
16:55:17 <c_wraith> danharaj, that's why I asked what your definition of "legal" is.
16:55:20 <mm_freak> someone should port cabal to C++
16:55:23 <kmc> "recursively enumerable" is equivalent to "recognizable by a TM"
16:55:33 <edwardk> er ~ Spec e
16:55:35 <kmc> meaning there is some machine M which halts with a "yes" answer on every legal Agda program
16:55:36 <Twey> Okay… then Agda fits danharaj's second description, but not original request :þ
16:55:46 <kmc> and never on an llegal program
16:55:50 <kmc> illegal*
16:55:58 <kmc> but it's allowed to diverge on legal programs rather than returning "no"
16:55:58 <Twey> mm_freak: Hahaha
16:56:55 <danharaj> kmc: Really? Because it seems to me that the set of all total recursive functions is RE by your definition, but I have been led to believe that it is not.
16:57:22 <edwardk> ddarius: i may have a problem with the outer 'cmp' though. cmp `on` extract has the wrong type. so i was too glib
16:57:27 <kmc> we can't use computability to talk about sets of functions, only sets of strings
16:57:38 <kmc> so you need to pick some encoding for your functions
16:58:06 <danharaj> kmc: I don't think the encoding matters.
16:58:25 <kmc> the set of all (say) Haskell expressions encoding a total recursive function is pretty clearly RE and indeed R
16:58:42 <edwardk> hrmm: duplicate (Spec cmp g f a) = spec (cmp `on` extract) (Spec (\_ _ -> True) g id g) f (Spec cmp g id a) -- looks promising though
16:58:42 <edwardk>  
16:58:49 <Phyx-> test
16:59:05 <Phyx-> hello
16:59:14 <kmc> you can't write an uncomputable function in Haskell
17:00:01 <pizza_> > sum [0..]
17:00:11 <danharaj> kmc: but you can write a partial recursive function in Haskell
17:00:18 <kmc> yeah, that's true
17:00:34 <kmc> but you can bundle your programs with a proof of totality
17:00:38 <kmc> as in Agda or Coq
17:00:56 <danharaj> kmc: then my question is whether you can write the proof checker + interpreter within the language.
17:01:01 <kmc> why does that matter?
17:01:15 <danharaj> kmc: It is a question. Why does it have to matter :D
17:01:19 <kmc> oh
17:01:29 <kmc> but it's not relevant to the question of whether the set of TR functions is RE
17:01:35 <danharaj> oh
17:02:01 <danharaj> no, I am doing a stack trace back to the original line of questioning.
17:02:08 <kmc> which was?
17:02:39 <edwardk> ddarius: oh, neat extend has a nice interpretation
17:03:41 <edwardk> extend h (SpecBy cmp g f a) = SpecBy (cmp `on` extract) (SpecBy (\_ _ -> True) g h g) f (SpecBy cmp g h a) -- but i probably need to just add another constructor for 'Known'
17:04:02 <edwardk> since the left SpecBy is inefficient
17:04:10 <danharaj> kmc: Let's forget it. I'll take a few more days to formulate it more coherently :p
17:05:10 <edwardk> there also appears to be a monad here
17:05:39 <edwardk> though perhaps join won't work
17:06:01 <edwardk> (and amusingly, it is an 'ideal' monad)
17:06:29 <danharaj> kmc: anyway, I am skeptical of your claim that the set of total recursive functions is recursive, because that would mean that a turing machine could decide whether an input function was total.
17:09:26 <kmc> danharaj, no it wouldn't
17:09:55 <kmc> i didn't claim that the set of TR functions is R
17:10:28 <danharaj> kmc: Then I misunderstood you when you said "t01he set of all (say) Haskell expressions encoding a total recursive function is pretty clearly RE and indeed R"
17:10:53 <kmc> well i amended that to include totality proofs by your objection
17:10:58 <danharaj> ah
17:11:11 <edwardk> ddarius: Spec cmpf gf kf af <*> Spec cmpa ga ka aa = Spec (\(a,b) (c,d) -> cmpf a c && cmpf b d) (\(ef,ea) -> kf ef (ka ea)) (af,aa) -- seems to work for Applicative
17:11:34 <kmc> we're rejecting encodings of functions which are total but whose proofs are missing or incorrect
17:11:36 <edwardk> merging a speculated function and a speculated arg into a speculated result
17:11:49 <kmc> so it's not "the set of TR functions"
17:12:03 <danharaj> It's the set of TR functions for which we have a proof that they are total.
17:12:11 <edwardk> this is getting more and more amusing
17:14:48 <danharaj> kmc: If that is correct, then I don't see how that set is recursive, because it requires us to algorithmically assign a proof of totality to every total function, which seems non-recursive to me.
17:14:56 <kmc> no
17:15:00 <kmc> we're just checking the proof
17:15:28 <kmc> { (e, p) | e encodes a function and p proves it is total }
17:15:38 <kmc> i'm saying this set is in R
17:16:27 <kmc> furthermore for any total recursive function f, there exists some (e,p) in that set such that e encodes f
17:16:56 <kmc> iow i assert that every total recursive function has a finite-length proof that it's total recursive
17:17:33 <danharaj> kmc: I think there is an ambiguity in the problem as I specified it. Proof in what system? Because we can always choose an inconsistent system and the statement is trivially true.
17:18:51 <kmc> sure
17:19:17 <danharaj> kmc: So we should assume the system is consistent, yes?
17:19:20 <kmc> i'm still not sure what problem you originally specified
17:19:27 <kmc> this one? <danharaj> Is it possible to have a language such that every legal program halts, but the set of legal programs is not recursively enumerable?
17:20:04 <kmc> hmm if we assume our system is consistent and has decidable proof checking, then it is incomplete
17:20:15 <danharaj> kmc: No that one is silly and trivially true: A language where you specify a regular expression and an input to it. I need to rethink what I actually mean by it.
17:20:29 <danharaj> kmc: The current question is whether the set of total computable functions is recursive.
17:20:47 <kmc> set of encodings of total computable functions?
17:20:50 <danharaj> kmc: And I think we are now considering such functions with proofs attached of totality.
17:20:54 <danharaj> kmc: yes whatever. >_>
17:21:27 <danharaj> kmc: Not entirely true. It doesn't have to be incomplete. It just has to have a non-recursively enumerable set of axioms :D
17:21:32 <danharaj> So proof checking is undecidable.
17:21:39 <kmc> that's why i said "has decidable proof checking"
17:21:46 <danharaj> oh I totally misread
17:21:56 <danharaj> rather didn't read, because I didn't read those words.
17:22:27 <kmc> i don't think you can handwave away the encoding issue
17:22:42 <kmc> because some well-known encodings for functions make totality explicit (Agda) and others don't (Haskell)
17:23:42 <danharaj> kmc: I don't think every total recursive function has an encoding in agda with a proof of totality.
17:23:50 <kmc> yeah
17:23:52 <kmc> i was assuming it did
17:23:58 <kmc> but i think incompleteness says otherwise
17:24:23 <mm_freak> is there a good opengl rendering library for haskell?  i mean something, which is not pre-alpha
17:24:35 <kmc> mm_freak, you mean a higher level library which uses OpenGL?
17:24:56 <mm_freak> kmc: yeah, like what OGRE is for C++
17:25:10 <enferris> So I'm wanting to implement Conway's game of life, to get a little experience using a Haskell graphics library, and I was wondering the the #haskell groupmind has to say about the various GUI libraries available.
17:25:32 <kmc> GUI or graphics?
17:25:33 <enferris> Similar query to mm_freak.
17:25:51 <mm_freak> kmc: doesn't have to be that sophisticated, though, just something, which is easier than using opengl directly
17:26:09 <enferris> Mostly gui, since gol is just cells being black or white.
17:26:09 <mm_freak> i'd like to write a game
17:27:33 <danharaj_> your two main choices of gui library are wxhasell and gtk2hs
17:29:23 <enferris> danharaj_: Do you have any thoughts on their respective strengths and weaknesses?
17:30:17 <danharaj_> enferris: I use windows 7 and it was difficult to build wxhaskell with the haskell platform. I couldn't get gtk2hs to build at all.
17:30:28 <edwardk> ddarius: as i feared i seem to be stomping all over the monad/comonad laws =(
17:30:31 <sproingie> i have a life implementation on hackage.  i used opengl tho, no GUI lib
17:30:35 <danharaj_> enferris: there is also that wx looks native on more platforms than gtk. Also I hate gtk.
17:30:39 <edwardk> ddarius: not observably, but at least spiritually
17:30:51 <sproingie> it's also not interactive except for being able to pause it
17:31:05 <mm_freak> danharaj: what's wrong with GTK?
17:31:24 <danharaj> mm_freak: I hate how it works on windows.
17:32:40 <enferris> sproingie: I saw that on hackage. I've been trying to decide whether I should read it for some guidance, or come up with my own implementation first, and then compare.
17:32:51 <mm_freak> ah, ok
17:33:08 <sproingie> it was really just a project for me to learn some basic opengl
17:33:24 <sproingie> specifically doing tile grids.  it's still quite unfinished in that respect
17:34:07 <sproingie> the CA stuff i mostly got from the brians brain app
17:34:25 <enferris> Cool.
17:34:31 <sproingie> i had a version that had several automata in one including BB but i chopped it out for simplicity's sake
17:34:52 <sproingie> it's pretty simple to turn it back into BB tho, you just change the implementation of rule
17:35:49 <etpace> If I have a ByteString.ByteString, but a function wants Data.ByteString.Interal.ByteString, how do I convert from the former to the latter
17:36:41 <mm_freak> etpace: you don't
17:36:45 <mm_freak> they are the same thing
17:37:22 <mm_freak> in fact, recent versions of the bytestring library don't even give access to *.Internal anymore
17:37:24 <etpace> so how do I stop it complaining about expecting the latter when inferring the former
17:41:38 <enferris> danharaj: Thanks, btw. I will stick with wxHaskell for now.
17:44:11 <sproingie> hm BB is a 3-state automata so i guess you'd need to change more than rule.  my generic version had a CellState type, not just Bool
17:44:28 <sproingie> pared it down so it'd be a GL demo, not a CA demo
17:46:39 <enferris> sproingie: I don't have too many goals for the program, I just want to stay in the habit of writing code during the long slog of finding work.
17:56:30 <edwardk> mm_freak: they don't?
17:57:07 <edwardk> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.7/doc/html/Data-ByteString-Internal.html =)
17:57:17 <edwardk> its Data.Text that doesn't export its internals and is therefore useless to me
17:58:54 <Eduard_Munteanu> wxWidgets left me with a mixed taste while I was working with it in C++.
17:59:25 <Eduard_Munteanu> On one hand it cross-compiles nicely with MinGW, on the other hand it feels rough around its many edges.
17:59:41 <Eduard_Munteanu> Only tried Gtk2Hs in Haskell and it was great.
18:00:40 <Eduard_Munteanu> *GTK.
18:00:57 <edwardk> mm_freak: Data.ByteString.Internal is exported, but its haddocks are hidden
18:01:42 <edwardk> which is a somewhat sad compromise because then hackage generates a broken link
18:05:14 <edwardk> ddarius: boringly the monad for spec seems to just be an initial algebraic encoding of calls to spec ;)
18:26:16 <deech> Hi all, I was looking through Galois' slides on "Engineering Large Projects In Haskell" (http://www.scribd.com/doc/19502765/Engineering-Large-Projects-in-Haskell-A-Decade-of-FP-at-Galois) and slide 43 says they put in type sigs after they are done with design. I was advised to do the opposite. What do you suggest?
18:28:33 <blackdog> deech: it's not really either-or
18:28:49 <blackdog> you should certainly have typesigs by the end, at least on your exported functions
18:29:11 <blackdog> but sometimes nailing them down beforehand helps with design and tracking down inconsistencies in your thinking
18:29:58 <deech> blackdog: and when you are more advanced you can just write code and let the type inferencer do the rest.
18:30:38 <scree> deech: that I certainly think is bad practice
18:30:39 <dolio> I'd probably write signatures first most of the time.
18:30:55 <dolio> When I use Agda, I'm required to do that.
18:31:05 <kmc> i usually write signatures first
18:31:09 <scree> ideally your design phase isn't the same as your coding phase
18:31:22 <deech> Perhaps when the advanced Haskellers at Galois' see some productivity gain by not doing that. 
18:31:38 <yitz> deech: i usually write the types first. occasionally it's helpful to write the implementation first and then look at the type in ghci. it depends on the case - whichever I find easier to express at the moment.
18:31:39 <blackdog> deech: it's more grey than that
18:31:53 <deech> As a relative noob I'll stick with writing type sigs first.
18:31:56 <blackdog> sometimes you want it looser, sometimes you want it tighter. i certainly don't have distinct design and code phases
18:32:04 <kmc> deech, "done with the design" != "done with the code"
18:32:05 <blackdog> or if i do, they're very short and interleaved
18:32:21 <kmc> ideally "design" ends with you writing all the type signatures and relatively little executable cdoe
18:32:37 <blackdog> half of the point of using haskell for  me is that i don't have to do explicit design in a meta-language that I have to then "implement".
18:32:40 <deech> kmc: I see. 
18:33:17 <kmc> nothing's ideal of course
18:33:29 <scree> (presumably all the type signatures = all the type signatures of exported functions)
18:33:48 <deech> kmc: Yeah, no silver bullet.
18:34:20 <scree> @faq can haskell provide a silver bullet?
18:34:27 <kmc> i would guess that the statement from the talk has a more specific context
18:34:29 <kmc> is there video?
18:34:43 <deech> kmc: dunno, it isn't linked.
18:34:51 <deech> I'd love to see it though
18:35:05 <kmc> i like slide 12
18:35:09 <kmc> which system is that?
18:35:28 <kmc> Fc?
18:35:57 <kmc> deech, thanks for the link to slides btw
18:36:08 <kmc> somehow this missed my blog reader
18:36:21 <kmc> i think i get posts when new talks are announced but not when slides go up
18:36:23 <deech> Ok, slide 12 is one I skipped because it looks like hieroglyphics. What is that? And how do I read it?
18:36:34 <kmc> deech, that's a type system specified in formal notation
18:36:43 <kmc> you read it by first reading _Types and Programming Languages_ by Pierce
18:36:57 <deech> Oh, no online tutorials then.
18:37:06 <deech> Why is it useful?
18:37:15 <kmc> it's not that there are no explanations online
18:37:30 <kmc> just that you should read TaPL
18:37:44 <kmc> it's pretty easy to explain the notation; harder to explain what's going on
18:37:51 <kmc> for the former anyway http://en.wikipedia.org/wiki/Sequent_calculus might be useful
18:38:25 <Saizan> deech: do you know any prolog?
18:39:12 <deech> Saizan: Prolog's like that hot girl next door I'm afraid of talking to.
18:39:32 <deech> So no. But I'd like to know it.
18:39:40 <blackdog> deech: you gotta cut that out
18:39:48 <blackdog> don't backtrack
18:39:57 <deech> blackdog: nice
18:40:05 <blackdog> or you'll never be unified
18:40:15 <Saizan> the hot old lady you mean.
18:40:17 * blackdog is not nearly as ashamed of himself as he ought to be
18:40:26 <blackdog> Prolog == MILF?
18:40:51 <Saizan> yeah, you can tell it's not a girl anymore
18:41:32 <kmc> deech, so each of those horizontal lines defines a rule
18:41:35 <Saizan> tough the newer logic languages didn't gain much popolarity
18:41:37 <deech> cool
18:41:49 <kmc> an axiom of the system
18:42:04 <kmc> if all the things above the line hold, the thing below the line holds
18:42:24 <deech> kmc: gottit
18:42:53 <napping> um, I hope you are not trying to read that off the slides
18:43:01 <deech> I assume the symbols (like delta) have some specialized meaning.
18:43:04 <napping> Did someone point you to a proper paper?
18:43:10 <deech> no
18:43:12 <kmc> yeah, if you actually want to read the rules look at the system fc paper
18:43:20 <kmc> http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html
18:43:26 <kmc> i was just explaining the basics of the notation
18:43:36 <napping> Oh, that's more of a "Hey look, there's fancy math that explains why the type system works"
18:43:37 <kmc> this is a pretty complicated system, not a good starting point, that's why i recommended TaPL
18:44:26 <deech> So the paper was released in 2006, does that mean this notation has only been around for 4 years?
18:44:29 <kmc> no
18:44:43 <kmc> why would it mean that?
18:44:46 <Cale> which notation?
18:44:46 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
18:44:52 <kmc> Cale, sequents
18:45:03 <napping> The general lines and |- thing goes back a long time - Gentzen in 1935?
18:45:18 <Cale> yeah sequents are pretty old :)
18:45:22 <deech> I just looked at the abstract, it wouldn't. I thought the paper defined the formal notation. Sorry.
18:46:22 <deech> TaPL, it is and Amazon reviewers seem to agree.
18:46:26 <napping> do those Galois slides say anything about not defining types till later?
18:46:28 <deech> Thanks kmc.
18:46:34 <deech> napping: no
18:47:12 <napping> Ok. I'm pretty sure standard practice is writing down type signatures for most top level functions
18:47:17 <kmc> deech, so e.g. one rule there that you'll see everywhere is App:  given Γ ⊢ e1 : σ2 → σ1, and Γ ⊢ e2 : σ2, we can conclude Γ ⊢ (e1 e2) : σ1
18:47:50 <kmc> what we're doing here is defining one rule regarding a 3-ary relation of the form _ ⊢ _ : _
18:48:03 <Saizan> how unicodey :O
18:48:12 <kmc> «Γ ⊢ e : σ» is read as "in context Γ, expression e has type σ"
18:48:38 <Cale> We are being unicoddled
18:48:43 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:48:50 <kmc> and so the rule there says that if e1 has type σ2 → σ1, and e2 has type σ2, then (e1 e2) has type σ1
18:49:06 <kniu> I'm getting the error
18:49:07 <kmc> all assuming the same "context", which is just a list of what variables are in scope and what their types are
18:49:08 <kniu>    No instance for (Data.Convertible.Base.Convertible SqlValue a)
18:49:12 <kniu>       arising from a use of `fromSql' at <interactive>:1:54-60
18:49:31 <luite> hmm, what was that ⊢ character called again?
18:49:37 <kmc> turnstile
18:49:38 <deech> Oh so it's a function, like f :: (a -> b) -> a -> b
18:49:41 <kmc> in latex \vdash
18:49:42 <luite> ah thanks kmc :)
18:49:44 <kniu> But the documentation makes it seem like fromSql is supposed to take an SqlValue.
18:49:47 <kniu> what gives?
18:49:47 <luite> yeah I knew the latex
18:50:29 <kmc> ⊢ ⊥
18:50:36 <Saizan> kniu: the argument is fine, you've to give a way to determine the type of the result though
18:50:55 <kmc> deech, yeah, App is the rule for typechecking a function application
18:51:00 <Saizan> kniu: the most direct way is to add a type annotation
18:51:36 <kniu> oh
18:51:39 <kniu> silly me.
18:51:43 <deech> kmc: neat. Can Haskell enforce these rules or are they just used in the design phase.
18:52:19 <kmc> deech, the rules used in Haskell are hardcoded by the language spec, though they change when you add extensions
18:52:39 <Saizan> you can build a GADT out of those rules, though i've never written one that deals with contexts in haskell
18:52:40 <kmc> the System Fc paper defines a new language and typing rules, which are suitable as an intermediate compilation stage in a Haskell compiler
18:52:50 <kmc> and indeed are used in GHC
18:53:19 <kmc> writing typing rules formally is useful for design and for communication between theorists, and it's also fairly close to how you'd write the rules in a system like Agda or Coq
18:53:30 <deech> Cool. And I take it I can use these techniques to design other general purpose programs.
18:53:45 <kmc> in which case you can then do machine-checked proofs of useful properties of your language
18:53:56 <kmc> like you can prove that if e1 evaluates to e2, then e1 and e2 have the same type
18:54:04 <kmc> which is called "preservation" and is something you usually want
18:54:28 <kmc> deech, if you are interested in formal machine-checkable proofs of properties of languages and type systems, a good place to start is http://www.cis.upenn.edu/~bcpierce/sf/
18:54:40 <kmc> oh hey byorgey is a coauthor now, cool :)
18:54:50 <Saizan> (i thought that was called subject reduction)
18:55:01 <kmc> hmm
18:55:19 <kmc> Saizan, hmm, apparently both
18:55:23 <kmc> according to my most recent link
18:55:34 <kmc> deech, btw this same bcpierce wrote TaPL
18:55:54 <kmc> deech, not sure what you mean about designing general purpose programs with these techniques
18:56:04 <deech> kmc: wow, I don't remember seeing this on the mailing list. 
18:56:44 <deech> kmc: I wanted to know if I could use this notation to sketch out my own programs away from the computer. 
18:56:57 <kmc> well, it's not really for defining programs
18:56:58 <dolio> Saizan: I think subject reduction is if A evaluates to B, and e : A, then e : B. Or something more along those lines.
18:57:28 <kmc> it's for defining logical systems
18:57:38 * hackagebot hS3 0.5.2 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.2 (GregHeartsfield)
18:57:45 <deech> kmc: I'll read a little more on it. Thanks a lot for the help.
18:57:48 <kmc> you can write, say, the rules of a type system this way, or the rules of evaluation of a flavor of the lambda calculus
18:58:06 <kmc> and so indirectly it relates to programs, in that you might want to implement your type system or your lambda calculus
18:58:40 <kmc> if your program has some kind of logical inference / constraint solving / proof-checking / rule-directed search kind of thing going on
18:58:45 <deech> kmc: in a little while maybe I'll be able to follow some of the more esoteric threads on the list :) 
18:58:45 <kmc> then it might be a useful way to think
18:58:49 <kmc> :)
18:58:52 <dolio> Oh, I guess I'm wrong.
18:59:49 <deech> GTG, thanks again!
19:00:15 <kmc> :) ttyl
19:03:16 <kmc> any way i can make Haddock build a single huge documentation page for every package i have installed?
19:19:33 <djahandarie> Where does the Haskell Platform install stuff on Windows?
19:19:37 <djahandarie> Namely, ghci
19:21:07 --- mode: ChanServ set +o mauke
19:21:07 --- mode: mauke set -q *!*@gateway/web/freenode/ip.*
19:23:07 --- mode: mauke set -o mauke
19:30:22 <tolkad> What's the maximum integer value in haskell?
19:30:29 <Axman6> there is none
19:30:43 <Axman6> it's limited by the amount of memory you have access to
19:31:02 <Axman6> > foldl' (*) 1 [2..10000]
19:31:06 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
19:31:19 <Axman6> > length . show $ foldl' (*) 1 [2..10000]
19:31:21 <lambdabot>   35660
19:31:24 <Axman6> > length . show $ foldl' (*) 1 [2..100000]
19:31:28 <lambdabot>   mueval-core: Time limit exceeded
19:31:46 <tolkad> huh, I guess that could be a problem using haskell
19:31:59 <Axman6> why? 
19:32:02 <tolkad> the time limit that is
19:32:17 <Axman6> that's only in lambdabot
19:32:32 <tolkad> :P I'm kidding
19:35:08 <BellJava> !ops a -special `message to you `from BIKCMP`: I wish that i was Vegeta from dragonball z. Once while stoned i tried to do a kamehameha and im sure my hands got hot. Im planning on picking a fight and while the adrenaline is flowing, im going to turn super saiyan and punish my opposition. Goku is stronger but Vegeta is cooler, im 38 with two kids.... my kids are weaklings, my wife left me and i like the way womans shoes make my cal
19:35:17 <Axman6> things like ghci are quite capable of printing out massive numbers, like 2^43112609-1, the largest known mersenne prime (which is 13MB then printed as text)
19:35:28 <Axman6> @where ops
19:35:29 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
19:36:50 <Axman6> what odd trolling
19:37:21 <tolkad> @where am I
19:37:21 <lambdabot> I know nothing about am.
19:37:29 <Cale> I'm not even sure that's worth a ban
19:37:48 <Axman6> thought i'd bring it to your attention nonetheless
19:38:49 <tolkad> ok so Ima reading http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Introduction
19:39:07 <tolkad> and it says "(Of course, some problems need (theadsafe) mutable boxes, and they're available as a library for when you need that). "
19:39:14 <tolkad> what's theadsafe mean?
19:39:32 <Axman6> means you can use them safely in multiple threads
19:39:52 <tolkad> that would be threadsafe, this says theadsafe
19:40:02 <Axman6> tolkad: i'd suggest one of the more populat haskell tutorials:
19:40:04 <Axman6> where LYAH
19:40:17 <Axman6> it's a wiki, fix it ;)
19:41:12 * Cale fixes
19:41:27 * Axman6 fixed it too :(
19:41:31 <optimality> hey guys, quick question: I'm using Data.ByteString.Lazy.Char8 to read an 8MB file from local disk - the program hangs when I do this, but it runs correctly if I just hardcode the string in (instead of reading from disk).  Any reason readFile would hang?
19:42:13 <Axman6> o.O
19:42:16 <X86Worm> !ops | a -special `message to you `from BIKCMP`: take this short quiz to see if u qualify to meet me: ugly? stupid? mean? ghetto? non english speaking? not from ohio? if u answer yes to any of the above, don't click to meet me cuz i hate all of the above :)
19:42:48 <Axman6> urgh
19:43:08 <Cale> optimality: I can't think of a specific reason.
19:43:23 <optimality> Cale: okay thanks anyways :) back to debugging...
19:43:26 <Axman6> :t readFile
19:43:27 <lambdabot> FilePath -> IO String
19:43:42 <Cale> :t Data.ByteString.Lazy.Char8.readFile
19:43:43 <lambdabot> FilePath -> IO BSLC.ByteString
19:44:19 <optimality> ahh, n/m - it was unrelated
19:44:22 <napping> optimality: how are you hardcoding an 8MB string?
19:44:31 --- mode: ChanServ set +o allbery_b
19:44:31 <monochrom> hahaha
19:44:37 <optimality> napping: I was hardcoding a smaller string :) but I fixed it, it was unrelated :)
19:44:47 --- kick: X86Worm was kicked by allbery_b (X86Worm)
19:44:50 <Wormbell> !ops | a -special `message to you `from BIKCMP`: Sometimes I'm convinced the only reason ipod users are so devoted/obsessed is the fact that Apple treats its customers like shit. You know, the whole abusive spouse paradigm
19:44:52 <optimality> I keep using "let a = f a" in my code
19:44:59 <optimality> which doesn't work for some reason
19:45:05 <napping> why not?
19:45:06 --- mode: allbery_b set +b *!*3cd9e854@*.60.217.232.84
19:45:06 --- kick: Wormbell was kicked by allbery_b (Wormbell)
19:45:35 <Axman6> allbery_b: heh, you blocked almost exactly the opposite of what i was about to suggest you block
19:45:57 <napping> actually, strings are compile to nice code, but I'm not sure how much memory GHC uses to parse them
19:46:01 <allbery_b> actually xchat decided what to block
19:46:30 <allbery_b> unfortunately the two accounts had completely different info aside from being via the web gateway
19:46:35 <Axman6> i was going to suggest blocking *!*@gateway/web/freenode/ip.*
19:46:43 <KB1JWQ> You'll get a lot of false positives.
19:46:49 <allbery_b> but how many real users would that alos kill?
19:46:54 <allbery_b> exactly
19:46:55 <KB1JWQ> Want a hand? :-)
19:46:56 <optimality> okay, so another question :)
19:47:06 <optimality> g a = let a = id a in a
19:47:12 <allbery_b> I think it's only the two already kicked
19:47:16 <optimality> g 5 hangs
19:47:23 <optimality> or g of anything
19:47:27 <napping> ends up as an array and a call to peekCStringLen
19:47:44 <napping> yeah, that is a recursive definition
19:47:55 <allbery_b> optimality: let is recursive.  you're calling id (id (id (id (... 5)...)
19:47:55 <napping> let a = id a in a -> the a in (id a) is the a being defined
19:47:57 <Axman6> optimality: because what you'be written is equivalent to lef g b = let a = id a in a
19:48:08 <napping> just like let l = 1:l in l makes an infinite list
19:48:37 <monochrom> "let a=a in a" is supposed to hang.
19:48:40 <Axman6> optimality: there's two differen's a's there. if you turned on -Wall, you'd get a warning of chadowing
19:48:43 <Axman6> shadowing*
19:48:52 <optimality> okay - I had hoped the names on the LHS of an = in a let weren't visible on the rhs
19:49:09 <monochrom> heh, ocaml would do what you want :)
19:49:11 <Axman6> they'd be a lot less useful if they weren't
19:49:16 <stepkut> how long is getErrno valid after I call an external C function via the FFI ?
19:49:22 <optimality> sml does what I want :)
19:49:26 <allbery_b> yeh, in ML let does that, in haskell let is recursive
19:49:27 <optimality> when is let a = f a useful?
19:49:31 <napping> stepkut: presumably as long as errno is valid
19:49:33 <Cale> optimality: let is always recursive in Haskell
19:49:38 <Axman6> > let l = 1:l in l
19:49:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:49:47 <Axman6> > let l = 1:map (+1) l in l
19:49:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:49:56 <optimality> ahh, cute
19:50:01 <stepkut> napping: yeah.. but it seems that the RTS or something could be calling C things that I don't know about.. so that obviously wouldn't be pratical..
19:50:01 <allbery_b> recursive lists and other data structures are useful in haskell because of laziness
19:50:06 <monochrom> when f is not so strict and therefore a=fa is productive
19:50:06 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:50:07 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
19:50:07 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
19:50:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:50:30 <Cale> You can even do mutual recursion :)
19:50:34 <Axman6> optimality: it's extremely useful, in a lazy language
19:50:53 <napping> stepkut: Ah, you'll have to look up the details of what threads run foreign calls
19:50:55 <Cale> Shadowing definitions is less useful than recursion in general.
19:51:14 <tolkad> > map intersperse "y" ["x","xx","xxx","xxxx"]
19:51:16 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t'
19:51:16 <lambdabot>         against infe...
19:51:22 <dolio> > let even 0 = True ; even (n+1) = odd n ; odd 0 = False ; odd (n+1) = even n in (even 5, odd 5)
19:51:22 <Cale> In fact, I recommend not shadowing definitions ever, if you can avoid it.
19:51:23 <lambdabot>   (False,True)
19:51:24 <napping> stepkut: all Haskell IO is done by the IO manager thread, so that at least shouldn't interfere
19:51:24 <tolkad> > intersperse "y" ["x","xx","xxx","xxxx"]
19:51:25 <lambdabot>   ["x","y","xx","y","xxx","y","xxxx"]
19:51:36 <optimality> Axman6: yeah, I don't take enough advantage of infinite structures
19:51:36 <tolkad> you can't intereperse a character into a string?
19:51:37 <stepkut> napping: k
19:51:44 <monochrom> > let a = (\g n -> if n=0 then 0 else g(n-1)) a in a 5
19:51:45 <lambdabot>   <no location info>: parse error on input `='
19:51:47 <tolkad> intersperse "x" "aa"
19:51:54 <tolkad> > intersperse "x" "aa"
19:51:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:51:55 <lambdabot>         against inferred ty...
19:52:00 <tolkad> I guess not
19:52:01 <monochrom> > let {a = (\g n -> if n==0 then 0 else g(n-1)) a} in a 5
19:52:03 <lambdabot>   0
19:52:03 <Cale> A common convention when you want something that is the modified version of some variable x is to name the variable x' with a ' (read "prime")
19:52:06 <Axman6> "x" is a string, not a character
19:52:13 <tensorpudding> > intersperse 'x' "aaaaaaa"
19:52:14 <lambdabot>   "axaxaxaxaxaxa"
19:52:35 <Axman6> > interleave "x" "ooo"
19:52:36 <lambdabot>   "xooo"
19:52:36 <tolkad> well why can't you intersperse a string in another string?
19:52:43 <tensorpudding> @type ('x',"x")
19:52:44 <lambdabot> (Char, [Char])
19:52:53 <tolkad> > interleave "xxx" "ooo"
19:52:54 <lambdabot>   "xoxoxo"
19:53:03 <Axman6> huh, not the one i was after
19:53:38 <tolkad> > interleave [1,2..99] [2,4,6..200]
19:53:40 <lambdabot>   <no location info>: parse error on input `..'
19:53:58 <Axman6> remove the ,6
19:54:04 <tolkad> > interleave [1,2..99] [2,4..200]
19:54:05 <lambdabot>   [1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18,10,20,11,22,12,24,13,26,14,28,15,...
19:54:21 <dolio> > let (even, odd) = (\(e, o) -> (\n -> n == 0 || not (o $ n - 1), \n -> n /= 0 && not (e $ n - 1))) (even, odd) in (even 5, odd 5)
19:54:22 <lambdabot>   (True,False)
19:54:32 <Axman6> [z..] = enumFrom z, [a..b] = enumFromTo a b, [a,b..c] = enumFromThenTo a b c
19:55:46 <stepkut> is there someway to load .hsc files into ghci ? {-# OPTIONS_GHC -F -pgmFhsc2hs #-} or something ?
19:56:57 <tolkad> > print 5
19:56:59 <lambdabot>   <IO ()>
19:56:59 <kmc> why do you need that, rather than runnnig hsc2hs manually?
19:58:15 <stepkut> kmc: because I am trying to write new functions and I like to develop interactively by loading stuff into ghci and making sure it type checkes as a go. Usually I just do C-c C-r in emacs.. it's very easy. Having to manually go to the command line and invoke hsc2hs would really put a kink in the work flow.. and not the fun kind of kink either
19:58:37 <kmc> heh
19:58:43 <kmc> well you can define new ghci commands
19:58:52 <kmc> and new emacs commands
19:58:59 <kmc> so you could make one to launch hsc2hs (or maybe just "make")
19:59:14 <kmc> or "cabal build"
20:00:22 <stepkut> I would rather just load the .hsc  file into ghci.. with other preprocessers the OPTIONS_GHC -F -pgmF trick works, but ghci doesn't seem to like the fact that the file is named .hsc I think
20:00:43 <kmc> you could rename it to .hs
20:01:06 <stepkut> kmc: but then cabal would probably get confused
20:09:10 <nniro> are .hsc the same as .chs?
20:09:19 <stepkut> no
20:09:39 <stepkut> .hsc is hsc2hs, chs is c2hs
20:10:11 <adu> aren't both slightly different FFI-like things?
20:10:13 <stepkut> c2hs is more powerful and complicated. hsc2hs ships with ghc and is often sufficient 
20:10:29 <stepkut> for something like gtk bindings, c2hs is probably better
20:10:38 <adu> or would "FFI-assistant" be more appropriate
20:10:43 <stepkut> in my case, I just need to import sendfile, and that is it
20:11:11 <sshc> Is it possible to, using the GHC API, create a binary executable that evaluates an arbitrary IO action that I pass to it?
20:11:45 <napping> how would you pass an action to it?
20:11:59 <napping> There are some libraries for dynamic loading, if that's really what you need
20:12:26 <stepkut> sshc: what form would the IO action be in? haskell source code ?
20:13:00 <sshc> stepkut: It'd probably be of type IO ()
20:13:10 <sshc> napping: The same way I pass an action to any other function?
20:13:21 <stepkut> sshc: but how is this information getting passed to the executable in the first place ?
20:13:50 <stepkut> sshc: you want to have one program write a thunk out into a new executable that can be run ?
20:15:21 <sshc> My goal is to create an executable that evaluates an IO action that I've generated when it is run.  This is similar to GHC creating an executable that, when run, evaluates "main".
20:16:02 <sshc> The function might be :: IO () -> FilePath -> IO ()
20:16:48 <napping> There's no direct way to do that
20:17:15 <stepkut> sshc: so the first program generates haskell source code, and then you want to compile it with the GHC API into an executable and run it ?
20:17:34 <sshc> The program creates an *IO Action*.  No source code.
20:17:52 <stepkut> what is an IO Action ?
20:18:23 <kmc> sshc, i doubt it's directly possible
20:18:31 <kmc> because GHC's implementation of IO does not lend itself to introspection
20:18:37 <stepkut> the first program does something like, let myaction = putStrLn "foo" in compileIntoExecutable myaction  ?
20:18:40 <kmc> you could implement the IO monad yourself in a more friendly way
20:18:47 <sshc> kmc: Thanks.
20:19:19 <kmc> also i'm guessing that when you said "evaluates an IO action" you mean "executes an IO action"?
20:19:28 <sshc> Yes
20:20:02 <stepkut> sshc: I still have no idea what you are trying to do. Search for mobile haskell and see if that is what you are talking about..
20:20:31 <kmc> sshc, you want to convert an IO action to a standalone binary, yes?
20:20:39 <kmc> such that running the binary is equivalent to executing the original action
20:20:40 <sshc> kmc: Yes.
20:20:52 <sshc> kmc: Is that possible?
20:20:53 <napping> there are probably easier ways.
20:20:54 <stepkut> sshc: mobile haskell
20:21:03 <kmc> sshc, i stand by my earlier answer, i was clarifying for stepkut
20:21:06 <napping> If you can generate source for the action in Template Haskell you can do that
20:21:30 <kmc> one fairly terrible way to do this would involve forking the process, then one child sets up to run the IO action, dumps its core, and exits
20:21:32 <napping> also, if you only need limited actions you could define a limited set of combinators that you can compile
20:21:40 <kmc> i'm not sure if resuming a process from a core dump file is still a thing on modern Unix
20:21:46 <stepkut> kmc: sounds like scheme/lisp
20:21:56 <napping> you'd have to worry about reopening files at the least
20:21:59 <kmc> sshc, i'm curious why you want to do this
20:22:30 <napping> It's the sort of thing that might be possible to implement, but probably a lot of work (unless this Mobile Haskell thing already has)
20:22:53 <stepkut> mobile haskell has done it, but it was a fork of an old version of GHC (5.x I think?)
20:23:18 <sshc> Mobile Haskell?
20:23:25 <stepkut> with mobile haskell you could have multiple haskell programs running on different servers, and you could have thunks migrate from one server to another. 
20:23:31 <wli> It's possible but not implemented.
20:23:47 <kmc> it would be very difficult to implement starting from standard ghc
20:23:50 <stepkut> there was could that would walk through the memory, bundle up all the thunks, and ship them over to a new process.
20:23:57 <kmc> sshc, yhc represents code using a portable serializable bytecode
20:24:05 <kmc> and there has been some work in serializing  functions this way
20:24:09 <kmc> and i assume it can do IO actions too
20:24:28 <napping> anyway, reflection is generally not done - bad for parametricity
20:24:31 <stepkut> but, it would be just as easy to have it write the thunks to disk and a special app that runs it
20:24:45 <wli> Resuming from coredumps use some OS/etc. conventions to reconstruct state and resume execution from there. It's not that much different from farting around with a coredump with gdb.
20:25:02 <kmc> sshc, do you have a particular use case in mind?
20:25:10 <napping> The other approach is to have a type of descriptions that can be converted into the stuff you want to use
20:25:26 <stepkut> mobile haskell was neat stuff IMO. But not used often enough to warrant maintainance in the mainline I think
20:25:27 <napping> a "project :: Desc -> Usefulthing", rather than "reflect :: UsefulThing -> IO Desc"
20:26:08 <stepkut> you might be able to do it with clean. it has some fancy persistence system where it can save a running program state to disk and then resume later..
20:26:10 <napping> stepkut: might be a bit of a different story now, I suspect debugging support overlaps a lot with the sort of heap walking for serialization
20:27:00 <stepkut> napping: maybe happstack will revive that when the time is right :) Would be useful for map-reduce-ish style queries
20:27:02 <napping> sshc: Doing exactly what you asked for is hard, and there are a number of more limited alternatives that are much easier but don't get the full generality
20:27:12 <sshc> kmc: Yeah, an interpretor I've written for an esoteric language.  Based on the input from source, it creates an IO action.
20:27:23 <napping> stepkut: actually, code migration should be easier than this sort of serialization anyway
20:27:42 <kmc> sshc, ah,  so you could  generate some other type instead
20:27:44 <napping> stepkut: if you can assume the other process already has all the code loaded, you don't need to know how to walk info tables
20:28:03 <napping> sshc: in particular, you are already converting either a string or an AST into an IO action
20:28:11 <stepkut> napping: if you have code migration, then it seems you just write the migration stuff to disk, have the second process start up and then suck in the migration ?
20:28:37 <napping> hmm, maybe
20:28:47 <sshc> napping: AST?
20:28:52 <kmc> abstract syntax tree
20:28:53 <sshc> kmc: Other type for what?
20:29:02 <napping> sshc: why do you need to write stuff out to a file at all?
20:29:09 <kmc> sshc, i'm saying that rather than "compiling" into an IO action you could compile to a different type
20:29:14 <kmc> something you can write to disk
20:29:15 <napping> are you trying to make a compiler, or is this a multiple-stage thing?
20:29:39 <kmc> now a trivial case would be to just write the input, into a file with a shebang or something which invokes your original interpreter
20:29:57 <kmc> but since you're asking this question i'm guessing you want to do more processing before writing something out
20:30:48 <sshc> napping: What do you mean by a multiple-stage thing?
20:31:01 <kmc> anyway you could compile your esolang into Haskell or C or LLVM code, write it out, and invoke an appropriate backend
20:31:24 <kmc> either by outputting source code as strings, or preferably by using the various packages on hackage that allow you to synthesize and manipulate abstract syntax trees of those languages
20:31:47 <kmc> btw, the haskell llvm bindings can also link the just-produced code into the running program, so you can do just-in-time compilation this way
20:31:48 <sshc> If the IO action were executed, the program would be run.  But I want the program to be an executable file.
20:31:55 <sshc> (Just to clarify)
20:32:29 <kmc> so why don't you make your "executable files" simply scripts which invoke the interpreter and bundle in the source
20:32:38 <pikhq> kmc: Actually, it's straight-up JIT'ing. LLVM will freely return a function pointer that goes into its JIT.
20:32:42 <kmc> which properties of "executable files" are the desired ones
20:34:11 <napping> sshc: you only call the function once, right?
20:34:22 <Eduard_Munteanu> Is f :: (forall a. a) -> b equivalent to f :: a -> (exists b. b) ?
20:34:36 <napping> sshc: You read the program once, want to call this magic executable writer, and then just get one executable you run?
20:34:51 <Eduard_Munteanu> I mean logically.
20:34:58 <napping> sshc: you said esolang, so I'm worried you might want to generate a different executable at every function call or something
20:35:20 <napping> Eduard_Munteanu: not at all
20:35:24 <tensorpudding> I'm pretty sure that (const 5) will satisfy the first with b = Int, but it won't satisfy the second
20:35:26 <sshc> napping: Only call the function once from what?
20:35:30 <napping> (forall a . a) is a very strong assumption
20:35:50 <napping> sshc: call the function that makes an executable
20:35:54 <kmc> sshc, here is my trivial compiler:
20:36:16 <Eduard_Munteanu> How should I transform forall into a proper existential quantifier?
20:36:17 <kmc> compile x = putStr ("#!/path/to/interpreter\n" ++ x)
20:36:19 <sshc> napping: The executable file should execute this IO action as the compiler itself executes main.
20:36:39 <kmc> sshc, does my trivial compiler do what you want, and if so, could you explain which properties it's lacking?
20:36:52 <monochrom> compile_c x = putStr ("#!/usr/bin/gcc\n" ++ x) :)
20:37:18 <kmc> Eduard_Munteanu, i'm not sure you can in general
20:37:23 <Eduard_Munteanu> I can't tell where goes the existential part. I guess it's an existential question for me.
20:37:44 <kmc> Eduard_Munteanu, the CPS transformation of «exists a. T a» is «(forall a. T a → r) → r»
20:37:44 <Eduard_Munteanu> kmc: mm, how come they're called existential then?
20:37:53 <sshc> kmc: No.  I want native machine code in the executable, and those scripts don't work on all systems.
20:38:25 <kmc> sshc, define "native machine code".  if i replace the shebang line with a fixed interpreter binary, and store the program source in a constant string in that binary, does that count?
20:38:31 <monochrom> because "contravariantly universal" is so much longer than "existential"
20:38:35 <Eduard_Munteanu> Well I understand it logically.
20:38:40 <dolio> Eduard_Munteanu: (exists a. T a) and (forall r. (forall a. T a -> r) -> r) are isomorphic types.
20:38:55 <dolio> GHC doesn't have a first-class existential quantifier in the type system, though.
20:39:14 <Eduard_Munteanu> dolio: yeah, I'm only trying to reason about it though.
20:39:15 <sshc> kmc: That would work.
20:39:25 <kmc> ok
20:39:30 <napping> Eduard_Munteanu: (forall a . a) is false
20:39:36 <kmc> well that's pretty easy
20:39:44 <stepkut> Haskell needs a fornone :p
20:39:58 <davekong> What is a good Haskell coding style guide?
20:39:59 <Eduard_Munteanu> napping: yeah
20:40:14 <kmc> sshc, and nothing will work on all systems -- what's the actual level of portability you're trying to achieve
20:40:28 <Eduard_Munteanu> It means given any type, it's populated.
20:40:43 <kmc> the script with a #! line could be a lot more portable than a binary
20:40:56 <djahandarie> Teaching Haskell to a 14-year-old ftw
20:41:09 <djahandarie> Already covered functions, currying, and types
20:41:28 <blackdog> djahandarie: could they program already?
20:41:31 <djahandarie> Nope
20:41:35 <blackdog> if not, i guess there's a lot you don't have to unteach:)
20:41:36 <monochrom> indeed a 14-yo does not resist with "but I don't do this at work" every 5 seconds
20:41:37 <djahandarie> Which actually makes it a lot easier
20:41:42 <Eduard_Munteanu> djahandarie: good, make sure he doesn't peek at C code.
20:41:46 <djahandarie> :D
20:41:52 <djahandarie> Get them while they're young
20:42:08 <kmc> sshc, the design space of compilers, interpreters, code translators, etc. is complex and has very slippery boundaries
20:42:20 <kmc> you haven't given us much in the way of design requirements
20:42:20 <sshc> kmc: The important part of the portability is the portability of the ompiler itself.  The compiler wouldn't work at all on some systems.
20:42:26 <djahandarie> I plan on writing a "intro to programming" guide with Haskell at some point. I guess this is just a primer for it ;-)
20:42:32 * djahandarie leaves
20:42:49 <kmc> sshc, i don't understand.  any functioning Haskell system should be able to execute putStr and evaluate (++)
20:43:03 <sshc> kmc: Of course
20:43:04 * monochrom plans to write "intro to everything using haskell" XD
20:43:07 <blackdog> i got kinda depressed reading http://www.benrady.com/2010/06/a-bit-of-heresy-functional-languages-are-overrated.html actually - the idea that functional programming is inherently bizarre and hard to learn is apparently thoroughly entrenched
20:43:29 <sshc> kmc: But it couldn't generate any working binary
20:43:32 <davekong> I know at least one school uses Haskell for their intro to programming class
20:45:04 <kmc> blackdog, i like how linking into the Haskell Report is taken as evidence of "academic shitheaddery"
20:45:37 <djahandarie> Yeah
20:45:41 * djahandarie facepalmed on that
20:45:46 <djahandarie> Whoops I'm suppose to be sleeping
20:45:48 <napping> wow
20:45:51 <kmc> now i forgot to smuggle a copy of the full 90000 page C++ spec out of my last employer
20:45:54 <kmc> so i can't check for sure
20:45:58 <kmc> but i'm guessing you can find much worse
20:46:54 <tensorpudding> the annoying part with Haskell is broken links and ancient, out-of-date documentation in a few places
20:47:26 <Eduard_Munteanu> Mmmm... can someone write out implicit forall quantifiers for me in f :: (forall a. a) -> b and f :: a -> b to compare?
20:47:39 <napping> The OCaml one is really bad. I mean, complaining about the definition of records?
20:47:44 <napping> seriously?
20:47:52 <Eduard_Munteanu> I guess the second is f :: forall a. forall b. a -> b
20:47:56 <kmc> yeah
20:47:57 <tensorpudding> more than one page i've seen that was documented entirely in papers that were dead links.
20:48:07 <kmc> not really worth wasting time thinking about this post though
20:48:13 <kmc> it's clearly a troll
20:48:23 <blackdog> kmc: yeah, it's a little frustrating.
20:48:42 <kmc> lots of people learn Haskell, i see it here every day
20:48:50 <kmc> they're not all fields medalists
20:48:51 <blackdog> i don't understand where this animosity is coming from, most engineers i know don't resent academia.
20:48:55 <Eduard_Munteanu> And the first would be f :: forall a. dontcare b. a -> b ? :)
20:49:06 <dolio> Eduard_Munteanu: f :: forall b. ((forall a. a) -> b)
20:49:14 <kmc> given that evidence the response to "maybe it's just me but i think haskell is impossible to learn" is obvious
20:49:24 <kmc> and it's what many of the comments on that article say
20:50:00 <Eduard_Munteanu> dolio: oh, thanks, I can deduce the rewriting rules for others now I guess.
20:50:04 <tensorpudding> There aren't any "Learn Haskell in 10 steps" books out yet
20:50:23 <Eduard_Munteanu> dolio: did you mean that for my last question?
20:50:26 <dolio> Eduard_Munteanu: You know about how forall and exists work when you're explicitly passing types, right?
20:51:00 <dolio> 'forall a. T a' has inhabitants that look like '/\a -> e', that is, they're functions.
20:51:29 <dolio> And 'exists a. T a' has inhabitants that are pairs. (a, e).
20:51:41 <dolio> a being a type in each case.
20:51:58 <Eduard_Munteanu> dolio: well, never seen exists, but forall sounds reasonable.
20:52:05 <dolio> Eduard_Munteanu: '(forall a. a) -> b' = 'forall b. ((forall a. a) -> b)'
20:52:38 <dolio> 'a -> b' = 'forall a. (forall b. (a -> b))' = 'forall a b. (a -> b)' = ...
20:53:46 <dolio> You can also move foralls past arrows if they're not used. S -> (forall a. T a) = forall a. (S -> T a)
20:53:53 <dolio> As long as 'a' doesn't appear in S.
20:54:00 <Eduard_Munteanu> dolio: thanks, *parsing* 
20:54:36 <dolio> Those aren't the same if you're explicitly passing types, but they're isomorphic. In GHC they work about the same, I think.
20:54:53 <davekong> What is academic shitbaggery?
20:55:20 <dolio> Anyhow, with regard to the explicit forall and exists earlier, (exists a. T a) -> R = forall a. T a -> R is just currying or uncurrying.
20:55:59 <kmc> davekong, apparently, having a formal specification for your language is
20:56:11 <Eduard_Munteanu> So for the first you can actually write a definition because it iterates over inhabited a's, so b is inhabited anyway?
20:56:52 <Eduard_Munteanu> I mean you can write f :: (forall a. a) -> b; f x = x
20:57:19 <dolio> The argument will give you an element of any type, including b.
20:58:24 <dolio> In the explicit passing, you might write that as 'f@b x = x@b'.
20:58:28 <dolio> Using @ for type application.
20:59:09 <Eduard_Munteanu> Hm, didn't try that. So you can actually call that function?
20:59:21 <Eduard_Munteanu> Nvm, lemme try.
21:00:54 <Eduard_Munteanu> Hm, that doesn't do it.
21:01:07 <dolio> What did you try?
21:01:13 <dolio> The @ stuff is my own notation.
21:01:24 <napping> Eduard_Munteanu: the only things of type (forall a . a) are undefined
21:01:34 <Eduard_Munteanu> Aaah, you said explicit types.
21:01:45 <Eduard_Munteanu> Yeah, that makes sense.
21:01:52 <dolio> Yes, GHC doesn't let you do that sort of thing.
21:02:21 <Eduard_Munteanu> Never heard of type application inside of a function either :)
21:02:34 <dolio> Also, if you do the shuffling around of quantifiers I showed, you get: f :: (forall a. a) -> (forall b. b)
21:02:40 <dolio> Which makes sense for f x = x.
21:03:02 <Eduard_Munteanu> dolio: yes. And all other default quantifiers disappear?
21:03:20 <Eduard_Munteanu> Just making sure.
21:04:20 <napping> what other quantifiers?
21:04:30 <napping> free variables are implicitly universally quantified at the type level
21:04:51 <napping> you can simulate type application with explicit annotations
21:05:12 <dolio> Well, you can't simulate all of it.
21:05:22 <stonefoz> ok, new to haskell and functional programing, i was hopeing to find some simpler examples of working programs. haskell.org only seems to list larger apps for reference or I'm just not seeing them.
21:05:23 <Eduard_Munteanu> napping: I meant implicit quantifiers, like in simply a -> b = forall a. b. a -> b
21:05:50 <dolio> Because GHC's inference causes problems that would be solved by explicit type application.
21:06:02 <dolio> When you're dealing with type families and stuff.
21:06:21 <dolio> Annotations won't do you any good there, though.
21:07:39 <Eduard_Munteanu> Types correspond to functors, right?
21:07:49 <Eduard_Munteanu> At least that's what I understand from monads.
21:08:02 <Eduard_Munteanu> *type application
21:08:42 <napping> hmm?
21:08:47 <napping> not an any common way
21:08:56 <napping> type constructors can correspond to functors
21:09:04 <Veinor> stonefoz: what do you mean?
21:09:13 <napping> if you want to do categorical stuff, plain old types like Int are objects
21:09:33 <napping> A type like Maybe is a functor - that has kind * -> *
21:09:43 <napping> other things at type * -> * are maybe not functors
21:09:45 <Eduard_Munteanu> napping: yeah I'm referring to class parameters and applying them to other types.
21:09:56 <stonefoz> xmonad, and yi seem to be the only examples of apps i've found, lots of librarys but not much for examples of small programs
21:09:57 * BMeph spouts the Party Line: TObjects are evil! >:(
21:10:02 <napping> e.g, data Pred a = Pred (a -> Bool)
21:10:10 <napping> not a (covariant) functor
21:10:10 <Eduard_Munteanu> And yeah, it's probably the label that matters (the constructor)
21:10:15 <BMeph> (-T)
21:10:25 <alexyk> evening
21:10:33 <napping> hmm, I'm not sure how exactly you make a model of the higher kinded type stuff
21:10:40 <dolio> Endo a = a -> a is neither a contravariant nor a covariant functor.
21:10:58 <BMeph> alexyk: Hasn't it wrapped around to morning again for you? ;)
21:11:14 <Eduard_Munteanu> I see.
21:11:23 <alexyk> BMeph: non yet :)
21:11:30 <stonefoz> haven't had any luck finding working examples of simpler code, just starting out and sort am getting the haskell way of doing things
21:12:11 <dolio> What kind of simple code are you looking for.
21:12:25 <dolio> A long time ago, people were answering Ruby Quiz questions in Haskell. That's somewhere.
21:12:32 <dolio> Search the wiki for haskell quiz.
21:12:47 <Eduard_Munteanu> stonefoz: have a look on Hackage and pick a smaller project, you can probably read the source online. But you should rather go simpler rather than look into existing codebases.
21:12:57 <Eduard_Munteanu> (like write some code, or see tutorials)
21:13:18 <alexyk> I have a pure function I need to taint with a getCPUTime.  http://paste.pocoo.org/show/232106/ returns a pure SGraph; now I need to add a call to getCPUTime to the end of it, and return an IO (SGraph,[Int]) where the latter is the list of timings, one for each tick.  How do I do that and modify fold?
21:13:26 <Gracenotes> ugh. the rigid type variable error, simple as it is, messes with my head so jarringly
21:13:29 <Eduard_Munteanu> There's also the Euler problems and solutions on the Haskell Wiki.
21:13:53 <stonefoz> the minimal for io, a working example would be great.
21:13:58 <Gracenotes> so it's not that simple after all then. effing make it go away..
21:14:12 <Eduard_Munteanu> stonefoz: main = print "Hello World" ? :)
21:14:33 <napping> Gracenotes: where does that come up? GADTs?
21:15:18 <Gracenotes> no. just simple polymorphic data structure
21:15:41 <stonefoz> yeah, but reading io examples seem to all point to writing a paraser
21:16:02 <Gracenotes> I'm trying to add as many type signatures as I can
21:16:06 <tanob> stonefoz: what about http://book.realworldhaskell.org/ ?
21:16:59 <Eduard_Munteanu> stonefoz: try to structure a small program around 'interact'
21:17:04 <Eduard_Munteanu> @hoogle interact
21:17:06 <davekong> stonefoz: YAHT explains IO fairly early on
21:17:06 <lambdabot> Prelude interact :: (String -> String) -> IO ()
21:17:06 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
21:17:06 <lambdabot> System.IO interact :: (String -> String) -> IO ()
21:17:42 <Gracenotes> I'm sure there's a dumb typo somewhere. I hate this.
21:17:52 <Eduard_Munteanu> For example, take in a string of numbers and convert them to ASCII chars.
21:18:27 <gwern> poor Gracenotes. debugging type issues is worst this late at night
21:18:42 <gwern> fit to make one tear out one's hair. 'dammit it makes sense to me!'
21:18:44 <stonefoz> ruby quiz answers seem to be about what i'm looking for, and I'll look into interact.
21:19:36 <stonefoz> any other language i've picked up has been mostly from examples, making this even more interesting/difficult
21:19:57 <Apes> Does anyone here use vim with haskell?
21:20:02 * kmc does
21:20:04 <gwern> Apes: many do
21:20:12 <Apes> How do you have it set up?
21:20:24 <kmc> no paticular way
21:20:30 <kmc> pretty much worked out of the box
21:20:48 <davekong> Apes: for one you should gran the vim syntax 
21:20:51 <davekong> grab
21:21:14 <davekong> adds highlighting for types etc from prelude
21:21:18 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26757#a26757 my vimrc
21:22:24 <Apes> How do you compile your haskell code? Do you use a seperate console window or do you use !ghc in vim or something else?
21:22:39 <kmc> separate window or separate GNU Screen terminal
21:22:50 <Gracenotes> oh, damn you, Haskell record notation. to hell with you. :(
21:23:18 <gwern> Gracenotes: it's not that bad
21:23:18 <kmc> srsly
21:23:25 <Eduard_Munteanu> Or xmonad set on Mirror Tall :)
21:23:34 <davekong> would be good to have it so that compile errors popped up in :cw like with :make
21:23:55 <Apes> Your vimrc is a bit shorter than I expected, kmc
21:23:57 <gwern> (I like emacs's flymake with haskell)
21:24:05 <kmc> Apes, like i said, i don't do anything fancy
21:24:12 <kmc> i'm sure you can trick it out considerably
21:24:27 <Gracenotes> just because it says emptyOption :: Foo doesn't mean that emptyOption has type Foo. and when you pattern match on "empty" and type "emptyOptions" instead, well, I think I'll express some choice words to my debugging rubber duck
21:25:03 <napping> That seems to be pretty standard notation, really
21:25:10 <napping> the thing that bugs me is not being able to re-use labels
21:25:21 <napping> are there record packages to fix that?
21:25:54 <Gracenotes> it just so happens that what you want to name records often overlaps with the names you'd want to bind with them, because there's no concept of namespacing them
21:26:05 <davekong> Apes: http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
21:26:17 <napping> what you want to name records?
21:26:30 <Gracenotes> in my case, it was a highly dissonant sort of overlapping, a few hertz of programmer suffering apart
21:26:44 <Gracenotes> napping: the fields therein
21:26:50 <napping> name overlapping between fields of different records?
21:27:04 <napping> yeah, I kludges up something with a HasField class to deal with that
21:27:24 <Apes> Thanks for the link davekong
21:27:37 <napping> Made a type level representation of identifiers and some TH stuff so multiple modules could declare the same label without overlap
21:27:45 <napping> without conflicts, that is
21:27:55 <napping> seems to work, for the most part.
21:28:07 <Gracenotes> well that too
21:28:35 <solrize> any idea why cabal-install excludes base-4.2.0.*  because of the "top level dependency base" ?
21:28:50 <solrize> i get dependency lossage trying to install atom
21:28:58 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26758#a26758
21:30:32 <napping> probably should have just used types, like the one Records package on haskell
21:30:36 <napping> on hackage, rather
21:31:04 <napping> but then Module1.Label and Module2.Label are distinct, which doesn't ever seem to be useful
21:31:26 <napping> I can't see a use for records with different fields named by identifiers from different scopes
21:32:24 <blackdog> gwern: tried kazu's ghc-mod? integrates flymake a bit more nicely, i think.
21:43:14 <dobblego> is Purely Functional Data Structures available for the kindle?
21:43:31 <Veinor> what format is it natively in?
21:43:42 <dobblego> PDF and hard-copy
21:44:23 <Veinor> I think amazon does PDF to kindle conversions via e-mail
21:44:57 <dobblego> ah right, I'll give it a shot, thanks
21:51:36 * hackagebot rpf 0.2.1 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.1 (KazuYamamoto)
22:03:26 <kniu> why don't (<-) in do expressions allow for implicit parameter binding?
22:04:06 <kmc> you mean the ?x sort of implicit parameter?
22:04:18 <kmc> you can't bind those with lambda either can you?
22:04:26 <kmc> :t ?x
22:04:27 <lambdabot> forall t. (?x::t) => t
22:04:32 <kmc> :t \?x -> ()
22:04:32 <lambdabot> parse error on input `\?'
22:04:37 <kmc> :t \(?x) -> ()
22:04:38 <lambdabot> Parse error in pattern
22:04:59 <kmc> :t \x y -> do { a <- x; let ?b = a; c <- y }
22:04:59 <lambdabot> parse error on input `c'
22:05:05 <kmc> :t \x y -> do { a <- x; let b = a; c <- y }
22:05:06 <lambdabot> parse error on input `<-'
22:07:43 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
22:07:43 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Jun 07 12:23:51 2010]
22:10:15 <kmc> OT: i want to modify my Compose key to type maths symbols, anyone have a simple ready-baked solution?
22:18:29 <Llyr> Hi. While attempting to compile a very basic script with ghc on Mac OS X, I'm getting the following odd linker error: "ld: warning: -read_only_relocs cannot be used with x86_64". Google turned up nothing - any idea what's going wrong here?
22:20:00 <kmc> does the program work?
22:20:21 <blackdog> Llyr: argh, i've seen that before
22:21:08 <blackdog> http://www.shimweasel.com/2009/09/14/unprincipled-skulduggery-with-ghc-6-12-dylibs-on-mac-os-x
22:21:21 <Llyr> kmc: The program works fine when slightly adapted for ghci. I copied the code verbatim from a haskellwiki thing.
22:21:53 <blackdog> try calling ghc with --verbose
22:23:38 <Llyr> Unrecognized flag, unfortunately. 
22:24:33 * BMeph boggls
22:31:16 <Llyr> Hm. It looks like MacPorts gave me an old version. I'll update and see if that fixes the problem.
22:38:22 <augur> ddarius, ski, you guys awake?
22:38:40 <Cale> Llyr: Any particular reason you're using the macports version of GHC?
22:38:57 <augur> or Cale! :o
22:39:00 <augur> cale is smart
22:39:05 <augur> i could ask cale
22:39:12 <Cale> augur: What would you ask me?
22:39:25 <Llyr> Cale: Not really, except for Learn You A Haskell said that was a good way to get it. Now I'm downloading the .dmg for the Haskell Platform to see if that makes it better.
22:39:48 <augur> i need help understanding a logical symmetry. its not haskell related, but haskell is the closest thing there is on IRC to a proper compsci/logic channel, so..
22:39:58 <Cale> Llyr: You might also just try the .pkg installer from the GHC website.
22:40:32 <Cale> Llyr: You can get that, and then the .tar.gz of cabal-install from Hackage, and run the bootstrap.sh script from that.
22:40:47 <Cale> augur: sure
22:40:49 <Llyr> Cale: Okay. If this haskell platform dmg doesn't work, I'll give that a shot.
22:41:43 <augur> cale: ok, preliminary notation: let M[x := a] mean "M with all occurances of x replaced by a", and let M[x :~ a] mean "M with at least one occurance of x replaced by a"
22:42:03 <Cale> okay
22:42:08 <augur> then there's a symmetry, conceptually, between these two inference rules:
22:42:29 <augur> (oh, also, let just M[x] "M containing an occurrance of x")
22:43:01 <Cale> Okay, I'm familiar with that notation, and the first one, though I've never seen M[x :~ a] before.
22:43:25 <augur> yeah, i needed to invent x :~ a because its not something people normally talk about ;)
22:43:29 <augur> exists x.M   =>   M[x := a]
22:43:43 <augur> M[a]   =>   exists x.M[a :~ x]
22:44:13 <augur> there's also, i think another way of stating the second one, as:
22:44:29 <augur> M[x := a]   =>   exists x.M
22:44:42 <augur> which is, of course the mirror of the first one
22:44:47 <Cale> yeah
22:44:53 <Cale> I was about to suggest that :)
22:45:18 <augur> but the thing is, is it not reasonable to want to be able to say M[a :~ x]?
22:46:32 <augur> or is it that all cases of having M[a :~ x] in the conclusion is a case of having M[x := a] in the premise?
22:48:39 <Cale> There's something a little weird here, there are missing quantifiers, I think
22:48:47 <augur> no, what?
22:49:26 <Cale> M[x := a] => exists x. M[x]
22:49:43 <augur> oh, well, sure, but you could have vacuous quantification, right
22:49:44 <Cale> umm...
22:49:58 <augur> for instance, f(y) is indeed an M with all x's replaced by a's
22:50:07 <augur> there's just no x's so it vacuously replaced all of them
22:50:14 <Cale> If a is some constant
22:50:23 <augur> its trivial that exists x.f(y) is true, so long as f(y) is true
22:50:37 <augur> and, crucially, that your domain is non-empty :p
22:50:53 <Cale> I suppose a is somehow externally quantified here
22:51:01 <augur> a is taken to be a constant symbol
22:51:07 <augur> so no quantification is needed
22:51:27 <Cale> okay
22:52:18 <augur> but is it indeed the case that all rules like ... M[x := a] ... => ... M ... are equivalent to ... M ... => ... M[a :~ x] ...?
22:53:00 <Cale> There's a related thing here, if we want to explore stuff like this...
22:53:50 <Cale> Suppose we take the notation  M[x := S], where S is a set to mean that each x is replaced by one of the elements of S
22:53:53 <augur> and then ofcourse what if i wanted a rule like, M[x,a] => M[a :~ x]? i dont think this could be replaced in the manner above
22:54:25 <Cale> Then exists x. M => exists y. exists z. M[x := {y,z}]
22:54:39 <augur> hmm
22:58:38 <augur> hmm i think i have a real proper understanding now
22:59:34 <augur> i think itll come down to the notion of context-contents
23:00:23 <cheater99> hi
23:00:34 <cheater99> what does it mean when someone says that he's 'in a monad'?
23:00:45 <augur> so like, if we have this notion of being able to treat a formula as a context with a hole and something that fills that hole, then we can reduce this all to the same thing i think
23:00:51 <Cale> augur: I think the first thing you wrote is actually false... :)
23:00:57 <augur> which first thing?
23:00:59 <Cale> exists x.M   =>   M[x := a]
23:01:11 <Cale> this isn't true in general, if a is just supposed to be some constant symbol
23:01:18 <augur> oh, its not false, its just a different direction of proof
23:01:23 <dolio> That's a rule for forall.
23:01:27 <Cale> forall x. M => M[x := a]
23:01:32 <augur> no no
23:01:36 <augur> theyre different proof directions
23:01:39 <Cale> ??
23:01:45 <augur> one is the constructive proof working from axioms to theorems
23:01:56 <Cale> So, exists x.M   =>   M[x := 0] ?
23:02:11 <Cale> What if M is the statement "x > 5"
23:02:15 <augur> the other is a proof by contradiction, working from presumed theorems to contradictions via the analytic tableau
23:02:18 <Cale> exists x. x > 5
23:02:25 <Cale> but 0 > 5 is false
23:02:39 <augur> true, but thats not how analytic tableaux work
23:02:47 <augur> you dont replace the thing by an actual constant symbol
23:02:53 <augur> you replace it by an abstract constant symbol
23:02:55 <Cale> Okay, I don't know what you're talking about then :)
23:03:03 <augur> if you assume that "exists x. x > 5" is true
23:03:15 <augur> then let a (a new previously unused symbol) denote some such x
23:03:19 <augur> then a > 5 must be true
23:03:26 <Cale> Are you referring to some sort of Skolemisation?
23:03:29 <augur> no
23:03:38 <augur> its just analytic tableau proof method
23:03:48 <augur> http://en.wikipedia.org/wiki/Method_of_analytic_tableaux
23:04:09 <augur> http://en.wikipedia.org/wiki/Method_of_analytic_tableaux#First-order_logic_tableau
23:04:19 <augur> actually, it seems it IS a form of skolemization :)
23:04:28 <Saizan> sort of a meta-variable
23:04:38 <Cale> So, exists x. M => exists a. M[x := a]
23:04:45 <Cale> ;)
23:04:52 <augur> well, sort of, yeah
23:05:00 <augur> except its not a quantification in the formulae
23:05:33 <Cale> Yeah, I think I know what you mean anyway :)
23:05:49 <augur> ok so with the contexts
23:06:45 <augur> if we let M{a} mean that we have a think with an "hole" in it where the "a" is, and then an "a" filling it, such that M{ } is then the thing with the hole
23:06:54 <augur> i think this all reduces to the same concept
23:08:07 <augur> and we just need a notion of a context that has one, multiple, or all occurrances "holed" out
23:09:21 <augur> e.g. if we say M{a} = f(a) & g(a,b), then M{ } is either the context f(_) & g(a,b) or the context f(a) & g(_,b)
23:09:58 <augur> but, say, M{!a} means that all occurances are holed out, then M{!a} = f(a) & g(a,b) means that M{ } is the context f(_) & g(_,b)
23:10:53 <augur> and if M{?a} means any number are holed out, then M{?a} is the formula with no holes, M{a}, or M{!a}
23:11:17 <augur> and i think this would push all of the issues onto the premise side
23:11:50 <augur> exists x.M{!x} => M{a} ; M{?a} => exists x.M{x}
23:12:48 <augur> the symmetry of it notation is mission, now, but the symmetry of concept is there, i think. its all just contexts and fillers
23:13:04 <augur> also, /wow/ look at all that me. ill be quiet now.
23:16:11 <mle> augur: ... all this talk about holes might go better if you changed to 'auger'
23:16:25 <augur> ;)
23:16:31 <mle> ^_^
23:16:33 <dolio> I don't really understand what you're going on about, but dealing with all kinds of stuff with variable names and renaming and whatnot is one thing that categorical logic makes simple, which is why it's so nice.
23:16:33 <augur> i can hurt you :)
23:17:17 <augur> i dont know anything about categorical logic, and im fair certain its not really relevant to what im doing :P
23:17:23 <dolio> Perhaps not.
23:17:36 <augur> i will of course now spend hours reading about categorical logic thanks to you
23:18:30 <augur> kneeways, its let about logic so much as it is about certain kinds of rewrite systems
23:18:35 <dolio> Traditional presentations of quantifiers in logic have to spend time talking about name capture when you have rules like 'M[a] => exists x. M[x]'.
23:18:48 <FunctorSalad> the name stuff can be made easy?
23:19:23 <augur> dolio: well, thats sort of only true if you dont have the ability to enforce newness of the variable in a trivial way
23:20:00 <dolio> In categorical logic, formulas with free variables are something like morphisms from contexts, and quantifiers are just adjoint to a certain context change functor.
23:20:00 <FunctorSalad> *tries to remember* a term with free variables corresponds to a function from the product of the var types to the result type?
23:20:18 <augur> if you have a programmatically designed system, its not hard at all to enforce that: just instantiate a new instance of your variable class (which ofcourse has automatically unique names) and you're done.
23:20:44 <dolio> I don't know if that all is relevant to what you're talking about.
23:20:54 <augur> which what
23:20:58 <FunctorSalad> yeah, but doesn't it just relocate the naming problem to specifying the component of the product which you want to q over?
23:22:06 <FunctorSalad> the context change functors you mention are "pullback by a projection from one product to another", no? (taking the simple case where contexts are products... I reckon it's different with dependent types etc)
23:22:28 <FunctorSalad> so you need to specify which component is projected out :)
23:22:39 <augur> whos talking to who D:
23:24:47 <dolio> FunctorSalad: It might depend on how exactly you're setting things up. At least in the type theory area, there are a bunch of almost-but-not-quite-the-same ways of encoding things.
23:25:08 <dolio> Although quantifiers are always adjoints to some pullback-esque functor.
23:25:09 <FunctorSalad> granted, the name problem is deferred to the metalevel while the categorical logic itself remains name-free
23:25:50 <FunctorSalad> dolio: the simple case of product contexts is enough to show what I mean already
23:26:52 <augur> oh thank god you're not talking to me. i dont know shit about category theory x.x
23:27:45 <FunctorSalad> I have one context T*T*T and one T*T.... how do you specify the projection along which to pull back? of course here it will do to say "drop the first/second/third"; I mean you'll essentially have to name the components if things get larger
23:28:04 <FunctorSalad> (like I said, this is in the background logic, not the categorical logic)
23:29:50 <dolio> Well, that amounts to something like de Bruijn indices, which I'm pretty comfortable with.
23:30:18 <augur> de Bruijn indices and notation are both very sexy.
23:33:50 <FunctorSalad> don't get me wrong, this doesn't make categorical logic useless; it's a step forward in that regard from traditional logics, where variable names have "objective existence"
23:34:03 <FunctorSalad> I was just in an implementation frame of mind ;)
23:35:12 <dolio> I believe I saw the advantage of categorical logic summed up as its extending the algebraic approach to quantifiers.
23:35:22 <dolio> Whereas previously that hadn't been done.
23:35:32 <dolio> I'm not sure I'm enough of a guru to explain that, though.
23:36:49 <dolio> I guess, with propositional calculi, you have Boolean or Heyting algebras, and for predicate logics, you have categories with appropriate structure.
23:37:20 <dolio> Something like that.
23:41:27 <FunctorSalad> would it be sensible to pipe a String or lazy BS to an external command's stdin and expect the whole thing to be nonstrict?
23:41:49 <FunctorSalad> (maybe hPut does it nonstrictly automatically, dunno)
23:43:50 <dolio> Non-strict how?
23:45:18 <FunctorSalad> something like this: myPipe (fix show) ("xconsole",["-file","/dev/stdin"])
23:45:37 <FunctorSalad> should actually display something rather than just looping ;)
23:45:47 <dolio> I think so.
23:45:49 <FunctorSalad> *tries it with HSH*
23:49:51 <FunctorSalad> runIO $ (\() -> cycle "oh hai\n ") -|- ("xconsole",["-file","/dev/stdin"])     -- works :)
23:51:16 <dolio> I mean, 'putStr (fix show)' works, so why wouldn't piping it somewhere else?
23:51:37 <dolio> putStr is probably 'hPut stdout' or something like it behind the scenes.
23:52:07 <FunctorSalad> ok, if that is the case then it's no surprise indeed :)
23:52:50 <FunctorSalad> but my worry was more about how evil this is (especially if the String is itself somehow the result of lazy IO)
23:56:48 <Axman6> @src putStr
23:56:48 <lambdabot> putStr s  = hPutStr stdout s
23:57:06 <dolio> @src hPutStr
23:57:06 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:57:18 <dolio> But... I don't...
23:58:41 <vegai> hey
23:58:54 <vegai> I was trying out the ghc package that comes with the latest platform for OS X
