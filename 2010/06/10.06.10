00:06:28 * hackagebot dimensional 0.8.0.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.8.0.1 (BjornBuckwalter)
00:16:37 <digitteknohippie> hi haskell peeps, i just read about python's "anygui", and still dont know my way around haskell toolkits or whatnot at all yet.  are there any haskell equivalents?
00:17:26 <digitteknohippie> like being smart enough to " automatically senses and uses whichever gui toolkit the user has installed on his machine, giving obvious advantages in  universality."
00:19:14 <Peaker> "wx" uses the native toolkit too, whatever that is, doesn't it?
00:19:51 <digitteknohippie> :/   dunno.   i'm an utter noob when it comes to toolkit knowledge.
00:24:58 <Peaker> I just wrote a little textual widgets toolkit, will use the same model for a GUI toolkit if I can figure out how to get nice fonts and sane 2d drawing on OpenGL
00:28:15 <ClaudiusMaximus> @hoogle build2DMipmaps +opengl
00:28:16 <lambdabot> Could not find file:
00:28:16 <lambdabot>     opengl
00:28:16 <lambdabot> Searched:
00:28:27 <ClaudiusMaximus> @hoogle build2DMipmaps
00:28:27 <lambdabot> No results found
00:28:35 <gilbertleung> hi, how can i write "prop s = (unCI . toCI) s == s" in point-free style?
00:29:05 <Peaker> @pl prop s = (unCI . toCI) s == s
00:29:05 <lambdabot> prop = (==) =<< unCI . toCI
00:29:47 <gilbertleung> icic
00:29:49 <Peaker> @unpl (==) `ap` (unCI . toCI)
00:29:49 <lambdabot> ((==) >>= \ e -> (\ c -> unCI (toCI c)) >>= \ d -> return (e d))
00:30:08 <Peaker> @type ((==) `ap`)
00:30:09 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
00:30:39 <noteed> Peaker: use Cairo on a textured quad?
00:30:41 <Peaker> Where (unCI . toCI) :: (a -> a)  and  s :: a
00:30:53 <Peaker> noteed, Cairo uses GL? I want fast blitting/drawing
00:31:06 <ksf> what do you guys think of setting up http://www.public-software-group.org/liquid_feedback for the community?
00:31:07 <ClaudiusMaximus> anyone got an example of using Graphics.Rendering.OpenGL.GLU.Mipmapping.build2DMipmaps for me?  the documentation is.. terse..
00:31:18 <Peaker> And, does it work (including Haskell bindings) on OSX, Windows, Linux?
00:31:20 <noteed> Peaker, no, but you can render it in-memory and map it as a texture
00:31:34 <dcoutts_> Peaker: Cairo does fast compositing, it works on all those platforms
00:31:42 <Peaker> dcoutts_, What is "fast compositing"?
00:31:57 <Peaker> dcoutts_, I thought any non-GL rendering is hopeless in terms of hardware accelerated drawing
00:32:03 <dcoutts_> Peaker: combining bitmaps using various operators
00:32:29 <Peaker> ah, why combine bitmaps and not semantic images (e.g: graphics-drawingcombinators)?
00:32:33 <dcoutts_> Peaker: not true, on X11 it uses the render extension which is usually hardware accelerated
00:32:43 <Peaker> If drawingcombinators had Anti Aliased text and cropping, it'd be perfect
00:33:36 <dcoutts_> I think it uses similar accelerated APIs on Windows and OSX, but you'd have to double check
00:33:40 <ksf> the render extension is a castrated hack
00:33:46 <Peaker> dcoutts_, Thanks, I'll toy with Cairo then
00:33:47 <ksf> I can't believe how they messed up glyph support
00:33:56 <Peaker> ksf, does it have any negative consequences? :)
00:33:59 <Peaker> will my fonts look bad?
00:34:06 <ClaudiusMaximus> well, you could just render at 4x the size to a framebuffer and downscale smoothly for antialiased-everything
00:34:16 <ksf> they will render needlessly slow
00:34:17 <noteed> Peaker: Cairo has excellent font rendering
00:34:27 <ksf> it's not the drawing, but managing.
00:34:40 <Zao> ClaudiusMaximus: Tends to interact badly with hinting.
00:34:51 <ClaudiusMaximus> ah, true
00:35:09 <noteed> Peaker: Cairo + Pango are used by gnome and webkit, iirc
00:35:10 <Zao> You'll end up looking like the OS X smudgefest :D
00:35:11 <ksf> ...which reminds me, I wanted to figure out how to hack proper texture caching into gpipe
00:35:29 <dcoutts_> Peaker: cairo also does nice 2D drawing, as well as the bitmap compositing
00:35:57 <ksf> the nice thing when having shader support while drawing is that you can upload the glyph once and then draw it in thousands of different colours.
00:36:02 <Peaker> Is there any good no-collision hash-library I could use? No need for cryptographic quality, prefer speed instead
00:36:27 <Peaker> noteed, What's Pango?
00:36:43 <noteed> Peaker: http://cairographics.org/samples/
00:36:43 <ksf> Peaker, Data.Hashtable?
00:36:47 <Peaker> dcoutts_, Sounds like a reasonable replacement for GL/SDL then, are the Haskell bindings for Cairo sane?
00:36:55 <Peaker> ksf, Not a hash table, just hash
00:36:58 <dcoutts_> Peaker: the bindings are good, yes
00:37:02 <ksf> ...it comes with one
00:37:04 <noteed> Peaker: Pango is a text layout library usually used in combination with Cairo
00:37:12 <ClaudiusMaximus> Peaker: http://hackage.haskell.org/package/uuid is what i used once
00:37:26 <dcoutts_> noteed: does webkit use cairo too? recent versions of firefox do too
00:37:46 <ksf> iirc webkit is drawing-backend agnostic
00:37:53 <noteed> dcoutts: I wonder if I was not confusing webkit and firefow when I said that
00:38:00 <ksf> gtk-webkit is thus bound to use it.
00:38:19 <dcoutts_> Peaker: cairo comes with a "toy" text API, pango can be used as an extension with cairo to give much more control over text handling/layout
00:38:48 * ksf wouldn't be content with anything less capable than tex when it comes to text
00:38:49 <Peaker> I'll probably only need the "toy" apis at first
00:39:03 <Peaker> Is Cairo tied in any way to Gtk?
00:39:14 <dcoutts_> Peaker: no, gtk uses cairo, not the other way around
00:39:28 <ksf> I think it uses glib, though.
00:39:43 <Peaker> ah, cool
00:39:57 <noteed> Peaker, it uses Glib
00:40:04 <dcoutts_> ksf: don't think it does
00:40:12 <ksf> I would probably use glib too if I were to code C, again
00:40:24 <dcoutts_> ksf: not according to ldd
00:40:25 <ksf> last time I looked it seemed sufficiently cool and light-weight
00:40:36 <dcoutts_> yes, glib is fine
00:42:52 <Peaker> glib has these weirdest typedefs "gint"/etc
00:43:14 <ksf> a lot of c libs have that
00:43:21 <ksf> GLDouble *cough*
00:43:31 <dcoutts_> it's because C can't decide what size anything is
00:44:08 <dcoutts_> and in practice, there are different conventions
00:44:25 <ksf> yeah and because C can't decide we'd rather not be haskell98 than supplying a CLDouble.
00:44:49 <noteed> seems like cairo doesn't use glib but pango does
00:45:11 <yitz> Haskell also can't decide. Int provides "a minimum of 32 bits," for example. I'm not sure what's promised about Float and Double.
00:45:19 <ksf> 31 bits.
00:45:20 <dcoutts_> ksf: the CLDouble thing is because ghc doesn't support it, yes it's a deficiency
00:45:30 <yitz> We do have Int32 etc. though
00:45:37 <dcoutts_> ksf: it used to implement it, but wrong, which was decided was worse
00:45:43 <ksf> ...there's always max and minBound to check
00:45:57 <ksf> it wasn't *wrong*
00:46:08 <ksf> ghc did the same thing as visual c
00:46:11 <yitz> ksf: yes, just like sizeof in C
00:46:12 <dcoutts_> ksf: it was, it did not correspond to C "long double"
00:46:14 <ksf> (alias it to double)
00:46:19 <yitz> well not just like but...
00:46:24 <ksf> in visual c, double == long double
00:46:49 <dcoutts_> ksf: ok, it happened not to be wrong for windows perhaps, it was wrong on other platforms
00:46:59 <ksf> ...you have to know the platform _and_ compiler _and_ compiler flags to produce compatible code.
00:47:07 <Zao> ksf: And moon phase.
00:47:10 <ksf> gcc can do the same, there's a flag.
00:47:16 <yitz> what other platforms is visual c on?
00:47:37 <ksf> which might be useful, e.g. on platforms where long doubles would be abysmally slow.
00:47:43 <Zao> x86, x64, ia64, some arm?
00:47:50 <dcoutts_> ksf: the FFI is supposed to follow the native platform ABI
00:48:04 <yitz> Zao: other than windows i meant
00:48:14 <Zao> I assume that ksf refers to x86/x64 Windows.
00:48:32 <Zao> yitz: You should probably reason about the individual compilers, not VC++ itself.
00:48:44 <ksf> that'd be nice, but I'd prefer having an explicit Quad for enforcing quad precision.
00:48:49 <Zao> As it can target just about anything from EFI images to CE PEs.
00:53:25 <ksf> why isn't CReal the default Floating type/
00:53:26 <ksf> ?
00:54:57 <dcoutts_> ksf: CReal? do you mean CFloat?
00:55:06 <ksf> nope CReal
00:55:15 <ksf> we have Integer as default, too
00:55:58 <ksf> > 1/3 == (1/3 :: CReal)
00:55:59 <lambdabot>   True
00:56:15 <ksf> see it even terminates.
00:56:47 <dcoutts_> ksf: what is CReal?
00:56:57 <ksf> computable real
00:57:51 <dcoutts_> ksf: well then that's easy! because it's not defined in Haskell98 :-)
00:58:00 <ksf> > let big = 2^2^64 in (1/big)*big :: CReal
00:58:04 <lambdabot>   mueval-core: Time limit exceeded
00:58:15 <ksf> > let big = 2^2^8 in (1/big)*big :: CReal
00:58:16 <lambdabot>   1.0
00:58:29 <ksf> > let big = 2^2^16 in (1/big)*big :: CReal
00:58:32 <lambdabot>   mueval-core: Time limit exceeded
00:58:42 <ksf> > let big = 2^2^10 in (1/big)*big :: CReal
00:58:43 <lambdabot>   1.0
00:59:29 <aavogt> > 1/3 == (1/3 + 1e-100 :: CReal)
00:59:30 <lambdabot>   True
00:59:35 <dcoutts_> ksf: which package is it defined in?
00:59:37 <aavogt> ksf: see, it's wrong!
00:59:39 <Peaker> yitz, btw: stdint.h has int32_t, etc
00:59:47 <ksf> aavogt, the eq instance is approximate.
00:59:53 <dcoutts_> ah, numbers
00:59:54 <ksf> ...as is show.
01:00:53 <Peaker> I think "approximate" Eq/Ord betray the semantics.. Float should have its own eq/ord functions with their imprecise semantics
01:00:55 <yitz> Peaker: ok. yeah, my point was that this problem is not limited to C.
01:01:12 <Peaker> I wonder if "gint" has a specific size at all
01:01:17 <Peaker> or if its just defined to be "int"
01:01:39 <Peaker> also, if it has a specified size, how is it better than stdint.h ints that have their size in the name?
01:01:51 <dcoutts_> ksf: so maybe one reason is that comparison operators are not guaranteed to terminate
01:01:54 <yitz> Peaker: wouldn't it be weird if were impossible to say x < y for fp types?
01:02:05 <ksf> they aren't?
01:02:09 <Peaker> yitz, we already can't, really :)
01:02:21 <yitz> Peaker: but we do ;)
01:02:34 <dcoutts_> ksf: the docs say: Note that the comparison operations on CReal may diverge since it is (by necessity) impossible to implementent them correctly and always terminating.
01:02:46 <ksf> oh.
01:03:20 <ksf> then how did that  1/3 == (1/3 + 1e-100 :: CReal) = True happen?
01:03:49 <Peaker> "True, for most practical purposes"
01:04:11 <dcoutts_> Peaker: maybe they changed the impl to terminate but be wrong instead, and forgot to update the docs
01:04:17 <dcoutts_> erm I mean ksf 
01:04:51 <ksf> there's always the possibility to provide two eq's, one guaranteed to terminate.
01:05:17 <Peaker> "probablyEquals"
01:05:19 <dcoutts_> and a special one that returns Maybe ? :-)
01:05:41 <ksf> at least CReal would give false positives instead of false negatives like Float
01:06:33 <Peaker> The uuid package is not installable (on ghc-6.12.1)
01:07:12 <ksf> ok, next topic
01:07:34 <ksf> what do you guys think about installing a http://www.public-software-group.org/liquid_feedback instance for the community?
01:09:28 <Peaker> I really wish I had more time to work also on an export/import signatures for Haskell packages -- and then using that for package selection rather than version deps. Together with some adapter packages, I think version dep hell would be gone
01:09:41 <Peaker> IMO it should be one of the top priorities for cabal-install..
01:10:20 <ksf> it'd be pure hell if there's no way to say that semantics changed while the api stayed the same
01:10:59 <Peaker> ksf, Change the name?
01:11:09 <Peaker> Fully qualified names would become immutable identifiers of semantics
01:11:12 <Peaker> that could be a good thing
01:11:23 <ksf> so we have foo, fooEx and fooExEx?
01:11:25 <ksf> no thanks
01:11:28 <Peaker> Not necessarily
01:11:36 <Peaker> import DirectX8 or import DirectX9
01:12:00 <dcoutts_> Peaker: how is that better than package versioning?
01:12:22 <Peaker> dcoutts_, That's just a suggestion to avoid "Ex", typically you wouldn't have that
01:12:32 <ksf> but I guess a "semantics counter" on versions would be a good thing.
01:12:43 <Peaker> dcoutts_, It is better because as long as you keep the old semantics under some name, you can remain compatible
01:13:18 <Peaker> dcoutts_, Something9.X could typically just be an alias to Something8.X and thus compatible
01:13:30 <dcoutts_> I think a more practical short term solution is to use the PVP and make tools to help use it effectively
01:13:39 <Peaker> And usually you could just add new names with new semantics rather than increasing version number
01:13:44 <ksf> player vs. player?
01:13:56 <dcoutts_> though I agree that longer term, we need to reconsider how modules and packages interact
01:14:01 <Peaker> dcoutts_, I think the PVP is pretty bad workaround, not a solution.  Packages specify version ranges that are often too narrow
01:14:07 <Peaker> There's actually no way NOT to be too narrow
01:14:14 <ksf> Peaker, we have enough name clashes right now, no need to invent new reasons.
01:14:31 <dcoutts_> Peaker: it's a choice between conservative or optimistic
01:14:47 <Peaker> dcoutts_, the import/export signatures would allow your package to continue to work until the export signature actually breaks, until the semantics you want are really no longer available
01:15:05 <dcoutts_> Peaker: that's the limitation of collapsing it down to a single version, rather than a fully detailed interface description
01:15:14 <Peaker> dcoutts_, Well, with signatures you could be more accurate about the dependency, rather than being too-conservative or too optimistic
01:15:24 <Peaker> dcoutts_, "fully detailed interface description" is what I want
01:15:29 <dcoutts_> right
01:15:34 <dcoutts_> you're right
01:15:41 <dcoutts_> that doesn't mean it's an easy problem :-)
01:15:50 <dcoutts_> and people like their version numbers
01:15:58 <dcoutts_> precisely because they are small
01:16:01 <Peaker> I agree it's not necessarily easy, but I think it should be a top priority :)
01:16:13 <dcoutts_> and everyone else uses version numbers, e.g. distro packages
01:16:27 <Peaker> Why not have "cabal makesignatures" that builds import/export signatures based on the way it builds now?
01:16:55 <Peaker> distro packages have a much coarser update granularity, and indeed once every N months they release a new everything to update the deps
01:17:13 <dcoutts_> Peaker: well good, that's the advantage of lots of brains, you can work on the things you think are top priority while I fix other bugs :-)
01:17:47 <dcoutts_> Peaker: the signatures work can initially be used to support the version number approach
01:17:48 <Peaker> dcoutts_, My top priority is another project I'm working on, but this is one of the top things I'd love to try to do
01:17:57 <dcoutts_> by suggesting the right version constraints
01:18:12 <dcoutts_> and detecting when existing constraints are too conservative
01:18:16 <vipex> hi 'im using mirc, what config? chat.freenode.net ports: 6665-6667,7000 is this true?
01:18:16 <Peaker> dcoutts_, Is cabal-install modular enough that you can plug another dep resolver right in?
01:18:26 <dcoutts_> e.g. when new versions of dependencies are released
01:18:27 <dcoutts_> Peaker: yes
01:18:35 <vipex> I can't connect trhough mirc, its now using browser
01:18:51 <Peaker> vipex, There's a #freenode channel
01:19:00 <ksf> and a freenode website
01:19:08 <Peaker> dcoutts_, I'd pay someone to do this, actually :)
01:19:10 <alip> is there a way to define a lambda function that takes no arguments?
01:19:13 <dcoutts_> Peaker: the first part is the tool that extracts the API
01:19:17 <Peaker> (Given that I really want to work on something else)
01:19:22 <ksf> alip, yes, it's called a value.
01:19:26 <dcoutts_> Peaker: we tried to get that as a GSoC project, but it was not funded
01:19:30 <ksf> > let x = 2 in x
01:19:31 <lambdabot>   2
01:19:33 <vipex> ok i'll investigate
01:19:33 <vipex> thanks
01:19:43 <alip> ksf: :) thanks
01:19:47 <Peaker> dcoutts_, Basically an export list of all the mentioned modules, and a "dump-minimal-imports" thing, both with fully qualified names and fully qualified types
01:20:10 <ksf> if you want to ignore an argument, you can use const.
01:20:20 <ksf> let f = const 2 in f 4
01:20:23 <ksf> > let f = const 2 in f 4
01:20:24 <lambdabot>   2
01:20:31 <ksf> > let f _ = 2 in f 4
01:20:32 <lambdabot>   2
01:21:13 <Peaker> Attempting to install cairo tries to install "directory" and "process" and then fails with incompatible Cabal version.. Why is trying to touch core packages?
01:21:33 <vipex> ok now im in :D
01:21:35 <dcoutts_> Peaker: ask it, use --dry -v
01:21:43 <dcoutts_> --dry-run
01:22:25 <dcoutts_> Peaker: note that knowing the exported types is not enough, one needs to know the relationship to the input types
01:22:29 <dcoutts_> modules are functors
01:22:31 <Peaker> Why does it depend on haskell98?
01:22:41 <dcoutts_> it = ?
01:22:48 <Peaker> cairo
01:22:55 <dcoutts_> no good reason
01:22:56 <vipex> hi everybody, i'm experienced pascal programmer... new in haskell :)
01:23:37 <vipex> that's why i'm here now... haskell am comming :D
01:24:26 <vipex> can I ask you something basic? what good haskell IDE running on Windows?
01:24:37 <ksf> remember: = is ==, := is <- and = is something entirely different.
01:24:51 <Zao> Not equals is /=
01:24:59 <digitteknohippie> heh, i have same question as vipex, but for linux.
01:25:06 <ksf> there's leksah
01:25:16 <Zao> Leksah is fun at times, vim with haskell-mode works, emacs with whatever modes it has work.
01:25:20 <ksf> but most people tend to use vi, and some masochists emacs.
01:25:21 <Zao> WinGHCi is nice for interactive.
01:25:35 <Zao> Eclipse has some plugins too.
01:25:42 <Zao> Kind of usable, at times.
01:25:49 <vipex> leksah? for linux  /windows?
01:25:55 <ksf> both iirc
01:26:10 <kynky> there is eclipseFP which has haskell support
01:26:10 <ksf> it's a gtk app and haskell is quite cross-platform
01:26:48 <Zao> Long ago there was Visual Haskell too for VS, but that's rather stale nowadays.
01:26:54 <vipex> ok thanks i'll check it
01:27:19 <vipex> yes i have download em, for VS2005, am using VS2010 :D
01:27:51 <vipex> sadly can't used'em
01:28:22 <vipex> hmm... can I write scalable application server / web based using haskell?
01:28:56 <vipex> i have app-server running e-voucher done using pascal, but i get borred with pascal :(
01:29:53 <dcoutts_> vipex: yep, there are a few web app server frameworks
01:30:01 <vipex> sorry I really newbie in haskell, just today I start read anything bout haskell :D
01:30:13 <vipex> yeah i got 2, which one the best?
01:30:21 <ksf> @faq can haskell serve files fast?
01:30:21 <lambdabot> The answer is: Yes! Haskell can do that.
01:30:30 <dcoutts_> vipex: I suggest learning the basics first :-)
01:30:38 <vipex> turbinado or happstack u think?
01:30:59 <ksf> happstack would be a fast way to fry your brain at this state, I think
01:31:43 <kynky> lyah, yaht, rwh are good resources, also a series of haskell video lectures on net (in english about 20 of them , about 1h30m long each)
01:31:52 <vipex> @dcoutts: sure, i just start collecting everything bout haskel lol
01:31:52 <lambdabot> Unknown command, try @list
01:32:16 <ksf> http://www.haskell.org/haskellwiki/Video_presentations#Introductions_to_Haskell
01:32:21 <vipex> mmm am master OOP, it look i should swap my brain by using haskell :D
01:32:39 * digitteknohippie is taking a second look at learnyouahaskell for great good
01:33:24 <dcoutts_> vipex: if you want a book I suggest "Programming in Haskell". Fastest introduction.
01:33:55 <vipex> dcoutss: i'll find it
01:33:57 * ksf wonders whether learning how to express oo in haskell would be beneficial to coders coming from oo
01:34:14 <dcoutts_> vipex: and after that read "Real World Haskell"
01:34:15 <ksf> fixpoints of records and stuff.
01:34:41 <Peaker>  no :)
01:34:45 <dcoutts_> vipex: but "Programming in Haskell" will teach you the basics the fastest
01:34:46 <kynky> and practise with ghci
01:35:06 <vipex> am googling it
01:35:16 <dcoutts_> ksf: I think those techniques are unappreciated amongst the newer haskellers
01:35:30 <vipex> thank you very well guys
01:35:32 <ksf> and remember to unlearn everything you know about programming, at least for the first month
01:35:41 <dcoutts_> ksf: people use classes instead when records would do better
01:35:49 <ksf> usually conceptual overlap is misleading in some way.
01:35:56 <vipex> hihi ksf: what u mean?
01:36:12 <vipex> change our perspective view / mindset?
01:37:07 <vipex> i have programming over 8 years... haskell seems different think
01:37:33 <vipex> yeah i need something different :))
01:37:34 <ksf> more like switching from driving cars to driving motorcycle.
01:37:42 <dcoutts_> vipex: I switched from Pascal to Haskell about 10 years ago, it was a complete revelation
01:37:47 <ksf> you can carry stuff over, but first you have to learn to drive straight.
01:38:11 <Raynes> ksf: Vice-versa.
01:38:20 <Raynes> ksf: Cars are much safer than motorcycles. ;)
01:38:28 <vipex> ksf: ouh... from hard think to easy think you supposed?
01:38:38 <ksf> yeah but motorcycles are cooler and faster.
01:38:55 <Raynes> ksf: Haskell is a lambo or a hummer.
01:39:03 <ksf> also, they fit into bikesheds.
01:39:05 <vipex> dciutts: interesting we have the same background, i'm delphi actually
01:39:12 <vipex> http://delphiexpert.wordpress.com
01:39:21 <dcoutts_> vipex: yeah, I moved from Pascal to Delphi to Haskell
01:39:21 <Zao> Poor souls :)
01:39:24 <Raynes> People shouldn't throw around the word "expert" so much.
01:39:29 <vipex> dcoutts: * missed spell u'r nick, sorry
01:39:49 <Raynes> I'm an expert in turning on my flashlight during a power outage.
01:39:49 <ksf> just the day before I had a look at some old java code, and I actually saw all those expressions and monads.
01:39:54 <Zao> Raynes: ExpertsExchange much? :)
01:41:00 <ksf> ...and actually thought of . as method composition
01:41:23 <dcoutts_> vipex: one of the biggest productivity improvements I found was that I stopped needing to use a debugger
01:41:25 <vipex> yeah i know, that just my nick old times :D
01:41:28 <vipex> just nick ;)
01:43:03 <mreh> my attoparsec parser only returns a partial result, when the parser should consume the whole ByteString, does anyone know why?
01:43:04 <vipex> hmmm... that i search for
01:43:16 <vipex> a IDE with debugger :D 
01:43:29 <vipex> soo... haskel dosn't need a debugger?
01:44:17 <vipex> interesting...
01:44:23 <vipex> brb...
01:44:47 <Peaker> Cairo's "setup.hs" has been linking in the last 20 minutes....
01:45:07 <kamatsu> :/
01:45:21 <mreh> I'm only using this parser "many1 digit"
01:45:33 <mreh> testing it on a single string of digits
01:46:25 <ksf> it's not being greedy?
01:46:30 <noteed> mreh: I havn't used attoparsed, but don't you need to consume the eof?
01:46:43 <ksf> uu-parsinglib comes with greedy and nongreedy versions
01:47:07 <mreh> noteed: that had crossed my mind
01:47:26 <noteed> mreh: well, look at what's not consumed...
01:47:28 <dcoutts_> mreh: and you need to tell the parser there is no more input available
01:48:27 <mreh> it seems odd because the whole file might contain several parses
01:48:32 <ksf> wtf why does dev-haskell-gtk depend on mtl having the doc useflag?
01:48:33 <mreh> but I'll do it
01:48:34 <dcoutts_> mreh: remember that attoparsec is incremental
01:48:54 <Peaker> It is so easy not to depend on "haskell98" I wonder why anyone does
01:50:31 <Peaker> killed "ld", arg. Will install cairo overnight sometime
01:50:39 <Peaker> Better get a new laptop or write "ld" my own sel
01:50:41 <Peaker> self
01:50:43 <Peaker> sinelaw, hey
01:50:49 <sinelaw> hey
01:51:07 <ksf> yep someone needs to do something about linking
01:51:24 <dcoutts_> shared libs will solve that one
01:51:26 <mreh> some kind of "suceed" parser would be nice
01:51:45 <dcoutts_> mreh: you've not groked the incremental aspect of attoparsec
01:52:18 <dcoutts_> mreh: you supply the input to the parser in chunks
01:52:23 <mreh> dcoutts_: is it analogous to the Maybe monad
01:52:38 <dcoutts_> I don't think so
01:53:01 <dcoutts_> the point is, the parser does not know where the end of the input is until you tell it
01:53:30 <uberjar> why is this channel so large ? 
01:53:36 <uberjar> is haskell just that cool ? 
01:53:39 <Peaker> uberjar, Because Haskell failed to avoid success at all costs
01:53:47 <uberjar> lol
01:53:49 <mreh> uberjar, It's also hard
01:53:53 <mreh> :D
01:54:03 <danharaj> I'm in it for the trolling.
01:54:20 <mreh> tits or gtfo
01:54:35 <Silvah> o.O
01:54:47 <Silvah> WTF?!?
01:54:57 <Peaker> (.) . (.)
01:55:06 <uberjar> ( o  )(  o )
01:55:13 <danharaj> :t (.) (.)
01:55:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
01:55:17 <Silvah> :t (.).(.)
01:55:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:55:53 <mreh> are you confused yet?
01:56:17 <uberjar> so much syntax
01:56:33 <vipex> dcoutts_: what kind of application you'he done using haskell?
01:57:39 <dcoutts_> vipex: not an easy question, I've been using it for everything for more than 10 years
01:58:04 <Silvah> For Shai'tan's sake, what's going on...?
01:58:31 <vipex> i see
01:59:07 <dcoutts_> vipex: I run a Haskell consultancy company, so I use it for commercial stuff. I've also done a lot with low level libraries and programming tools.
01:59:10 <vipex> may u could explain sample of everything you'he made 
01:59:48 <vipex> low level libraries and programming tools? everything using haskell u mean?
01:59:49 <Silvah> Low-level libraries in Haskell...?
02:00:17 <dcoutts_> vipex: yes, all in Haskell
02:00:22 <vipex> yeah i just read NO low level part in haskell :p
02:00:32 <vipex> or am getting wrong here :D
02:01:03 <exDM69> vipex: depends on your definition of "low-level". however there's even an operating system written in haskell
02:01:03 <vipex> dcoutts_: are u germany?
02:01:14 <dcoutts_> vipex: UK
02:01:48 <vipex> what the hell cool Haskell is :))
02:01:58 <uberjar> trolling sounds fun:  Is there a reason I should learn haskell ahead of clojure ?  Both are going to enable me to do functional programming and get my concurrency on.  Clojure has a lot less syntax to memorize and more libraries.  What advantage do I get with haskell besides a smaller memory footprint ?  
02:01:59 <vipex> I should switch to this one soon haha
02:02:45 <vipex> hmmm... let we see my daily case...
02:02:49 <exDM69> uberjar: you get less parens
02:02:58 <uberjar> and more syntax
02:03:01 <vipex> am writing server side app --> yep haskell could do this easy
02:03:04 <uberjar> less parsability
02:03:17 <Phyx-> uberjar: you get to come into #haskell daily
02:03:29 <Phyx-> though that can be seen as a bad thing
02:03:32 <uberjar> you get to link against C libraries
02:03:37 <vipex> and am writing graphics based app --> dunno how easy haskell will handle it
02:03:40 <uberjar> I can see why that would be a big win
02:03:54 <vipex> check some of my work about graphics app: http://seven7sign.com
02:03:58 <exDM69> vipex: haskell will handle it just fine, there's no reason why it shouldn't
02:04:09 <vipex> i wonder if this could easy done by using haskell
02:05:41 <vipex> exDM69: it should be... i just start exploring Haskell :)
02:07:05 * hackagebot clash 0.1.0.2 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.0.2 (ChristiaanBaaij)
02:09:13 <ksf>  setup: ./Graphics/UI/Gtk/General/IconTheme.chs: invalid argument
02:09:37 <ksf> I've seen people here claim that gtk works with 6.12.1...
02:15:22 <mreh> *** Exception: Failed reading: satisfyWith -- ambiguous attoparsec error message T_T
02:16:03 <mreh> I'm not explicitly using satisfyWith
02:16:07 <mreh> trying to track it down
02:16:23 <ksf> looks like the matching primitive
02:16:32 <ksf> and like you're hitting an unexpected eof
02:16:46 <ksf> (so my crystal ball tells me)
02:17:10 <mreh> ksf: I thought that so I tossed in a satisfy
02:17:32 <mreh> the file definitely has enough bytes for the header, but I calculate it's a byte short for the rest
02:17:38 <mreh> hex editing fun
02:17:58 <ksf> ...never try to understand a parsing lib on real data
02:18:32 <mreh> I'm too unmotivated to read the source code
02:19:24 <mreh> could someone write it for me? :)
02:19:44 <mreh> I'll understand it later, honest
02:23:34 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
02:23:34 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Jun 07 12:24:31 2010]
02:23:38 <vipex> hmm found something about "Haskell Server Pages" ... is this true? anybody use it?
02:26:01 <ksf> it's a quite old thing
02:26:27 <vipex> ha... damned :D
02:26:42 <ksf> try http://snapframework.com/docs/tutorials/snap-api
02:27:00 <vipex> what's new regarding server side technology? could u give me a hints?
02:27:36 <FusionGyro> Snap, I'd say: http://snapframework.com/
02:27:53 <FusionGyro> it's frameworky though
02:28:27 <ksf> it's said to be fast, too
02:28:36 <vipex> i figure it
02:28:45 <ksf> at least it's using iteratees and sendfile (for whole files)
02:29:14 <vipex> hmm today too many something new cooking my brain :D
02:30:11 <vipex> even am n'yet touch cabal (it is like github?)
02:30:22 <FusionGyro> more like RubyGems
02:30:31 <FusionGyro> or CPAN
02:30:45 <ksf> and it's called hackage
02:31:18 <ksf> cabal is the packaging libary, cabal-install is the dependency resolver and user executable, hackage is the repository
02:32:01 <vipex> haha dooh what iteratees? for loop iterate? lol just confuse 
02:32:26 <vipex> yep i mean rubygems :D
02:32:42 <ksf> http://okmij.org/ftp/Streams.html
02:33:09 <ksf> ...the usual oleg warning applies.
02:33:35 <FusionGyro> what's the usual oleg warning? :)
02:33:41 <vipex> hmm wondering if snap framework also support windows since i still in front of it
02:35:08 <ksf> make a successfull saving throw against confusion +30 or be devoured by a dragon.
02:35:35 <ksf> it should, unless it's using really, really low-level IO
02:35:39 <mreh> @dice 1
02:35:39 <lambdabot> 1 => 1
02:35:41 <vipex> ok start downloading: cabal... then Haskell it self... hope lucky learning fast
02:36:24 <FusionGyro> you probably want to install the Haskell Platform if you don't already have Haskell and Cabal
02:36:46 <vipex> oh I dunno bout that
02:36:48 <vipex> where is?
02:37:00 <FusionGyro> http://hackage.haskell.org/platform/
02:37:36 <vipex> thanks alot, you guys help me alot erasing Pascal arround the world lol :D
02:38:51 <FusionGyro> np. :)
02:39:36 <vipex> oh before continuing in deep, is haskell output generate single .exe ?
02:40:00 <vipex> how'bout deployment?
02:40:25 <uberjar> yea it can compile to good ole binary executables 
02:40:33 <danderson> haskell doesn't generate output, a haskell compiler does
02:40:39 <danderson> I'm assuming you're using GHC
02:40:45 <vipex> ole? what you mean?
02:41:03 <danderson> by default, GHC produces static binaries, so deployment should be just a matter of copying the executable to the prod machine.
02:41:05 <vipex> yes i mean haskell compiler :p
02:41:05 <FusionGyro> it's short for "old" as in "good old executables"
02:41:23 <vipex> is haskel compiller support native x64 though?
02:41:49 <earthy> vipex: yes. on some platforms.
02:42:09 <vipex> great! i could make fastest server then
02:42:11 <earthy> vipex: i.e., on linux and IIRC windows it does generate 64 bit code
02:42:11 <danderson> depending on the backend used, and on your platform, yes.
02:42:22 <earthy> however, on mac os x it generates 32 bit code
02:43:29 <vipex> Windows x64?
02:44:18 <danderson> that said, what code are you writing that notices the difference?
02:44:58 <vipex> high load server :)
02:45:07 <vipex> something like facebook engine :D
02:46:08 <FusionGyro> by the time your performance problem is the byte width of the machine x64 will be supported on every architecture
02:46:16 <FusionGyro> er, OS
02:47:30 <vipex> yep i know
02:47:40 <FusionGyro> I wouldn't sweat it
02:48:11 <vipex> just currius, twitter using ruby, haskell should well performance over it :)
02:48:18 <tao_> have anybody use hlibev?
02:49:02 <FusionGyro> vipex: I'd assume so, but language is not the only factor in performance, not even necessarily the most important factor
02:49:37 <vipex> you right
02:49:52 <vipex> architecture is the key :D
02:50:08 <uberjar> caching is the key for web-apps
02:50:18 <FusionGyro> for my purposes, 9 times out of 10, Haskell performance exceeds my needs or expectations. Fixing it that last time out of ten is a very different process than with other languages though
02:50:53 <vipex> hmmm...
02:51:23 <FusionGyro> vipex: this is an educational project, right? :)
02:51:42 <robertmassaioli> vipex: twitter made a move to python didn't it?
02:51:44 <uberjar> for 99% of the things I code.. the speed of excution is not really that important. 
02:52:00 <uberjar> for most web-apps the execution speed of the programming language is just not improtant at all
02:52:13 <uberjar> speed of development is more important
02:52:36 <uberjar> if you can get it coded faster because the language makes things easier for you... then you win.
02:52:42 <vipex> FusionGyro: No, i have a plan years agon building self frameworks like SAP does :)
02:52:50 <eevar2> earthy: afaik there's no 64-bit gch for windows
02:52:54 <vipex> some part is hobbies ;)
02:53:03 <vipex> just*
02:53:26 <vipex> robertmassaioli: I don't know bout that
02:53:49 <eevar2> *ghc
02:53:57 <vipex> uberjar: 100% agree
02:54:24 <FusionGyro> twitter has changed platforms a number of times. I don't think it's because any particular platform was itself inadequate so much as it's a hard problem to solve
02:54:40 <vipex> sad, no 64bit GCH for windows? yet
02:54:52 <FusionGyro> again, by the time you need it, it will probably be there
02:55:21 <vipex> sure :)
02:55:54 <vipex> Windows just for development, in real world I put my works on linux /unix server
02:56:22 <eevar2> twitter's using scala, no?
02:56:35 <vipex> Many my Delphi friends moved to FPC (FreePascalCompiler)
02:57:18 <vipex> so far I know, twitter using ruby, dunno if they leave'em :D
02:58:03 <SubStack> I wish ruby had type inference
02:58:11 <SubStack> also javascript
02:58:54 <uberjar> not me.. I <3 Ruby's duck typing
02:59:14 <uberjar> but yeah.. with JS it makes a lot of sense
02:59:55 <Phyx-> dynamicly typed languags < *
03:00:19 <FusionGyro> I think JS would get weird if you added that feature. Or weirder, I should say.
03:00:46 <FusionGyro> OTOH, improving performance would be easier
03:00:58 <vipex> uberjar: I'm being looking new prog-language to bring rock web-apps... first I interest LUA
03:01:17 <vipex> while searching I found Haskell and it's something different
03:01:54 <FusionGyro> Want to get really weird? Ur/Web: http://www.impredicative.com/ur/
03:02:29 <FusionGyro> or (less weird) Seaside: http://www.seaside.st/
03:03:02 <uberjar> seaside is pretty neat.  I don't know anything about haskell for the web yet so no comment.
03:03:27 <uberjar> my "alternative" programming language for the web has been clojure
03:03:29 <Jafet> "We're in ur ur..."
03:03:32 <FusionGyro> Snap is the first framework I've seen that looks like it might be at the right level for me
03:03:38 <uberjar> so far it has kicked majore ass
03:03:51 <FusionGyro> Clojure does rock. But I kind of hate Java.
03:04:12 <vipex> Snap looks like servlet?
03:04:12 <SubStack> been rocking node.js lately
03:04:22 <FusionGyro> vipex: more-or-less, yes
03:04:22 <SubStack> events everywhere!
03:04:24 <uberjar> I kind of hate java too, but I love having SO MANY GOOD LIBRARIES to play with
03:04:31 <uberjar> events ftw
03:04:32 <vipex> clojure? java?
03:04:46 <uberjar> I can't wait until I find a good excuse to play with node
03:04:46 <FusionGyro> Clojure: http://clojure.org/
03:04:56 <vipex> i hate java lol... but yes I have done previously with java but i disn't like'em
03:04:58 <FusionGyro> it's a new, modernized, very kick-ass Lisp variant that runs under the JVM
03:05:21 <vipex> as im new in this community, is threre some wrapper for ExtJS?
03:05:27 <vipex> In Pascal we have it http://code.google.com/p/extpascal/
03:05:28 <FusionGyro> SubStack: I looked at node.js, like the idea but I will wait until things stabilize a bit more before getting invested
03:06:20 <SubStack> FusionGyro: it is pretty unstable still, but lots of crazy stuff happening nonetheless
03:06:27 <vipex> Guys. am looking Haskell powered web-framework, are those (seaside etc) are Haskell powered?
03:06:29 <FusionGyro> that's what I hear
03:06:43 <FusionGyro> vipex: no, those are just weird or cool
03:07:08 <Twey> vipex: Snap is Haskell
03:07:18 <FusionGyro> SubStack: OTOH I kind of hate NoSQL so the motive just isn't there for me. :)
03:07:26 <Twey> Or its big daddy, happstack
03:07:49 <Twey> There's also that Turbinado, though it never made much of a splash
03:07:58 <FusionGyro> and WASH, if you go back far enough
03:08:14 <ksf> node.js?
03:08:20 * SubStack 's personal website is running on happstack ;)
03:08:25 <ksf> haskell _does_ compile to js, you know.
03:08:27 <FusionGyro> http://nodejs.org/
03:08:43 <FusionGyro> it's a V8-engine-based server-side JavaScript uh server
03:08:50 <SubStack> FusionGyro: how is nosql related to node.js?
03:09:31 <FusionGyro> SubStack: they're not directly related, they just seem to both be part of the whole "let's use JS everywhere and evict all these special-purpose languages like PHP and SQL that suck and make life hard!" movement
03:09:43 <SubStack> ah
03:10:04 <Twey> I'm all for evicting SQL and PHP, but JS is not the language I'd choose to replace them >.> 
03:10:29 <mklappstuhl> regarding NoSQL : CouchDB is awesome
03:10:35 <FusionGyro> I'm actually rather fond of both but you have to play to their strengths
03:10:48 <ksf> hmmm apperantly there's a js llvm backend
03:10:51 <Twey> PHP doesn't really have any strengths
03:11:00 <Twey> SQL does, but it could have been done so much better
03:11:01 <SubStack> node's biggest thing is how crazy fast and low memory it is on v8 with non-blocking evented concurrency
03:11:11 <FusionGyro> yeah, CouchDB... same story as node.js for me at the moment. but I'm highly invested in PostgreSQL and the cost of changing my brain on that particular note might be too much. waiting to see though, still open to changing my mind
03:11:22 <SubStack> it's not even real concurrency, all single-threaded
03:11:52 <FusionGyro> if you use PHP as it was intended, strictly for templating and shuffling data to and from the database, I find it pretty tolerable
03:12:02 <FusionGyro> I think if you type 'class' in PHP code, you're probably fucked up. :)
03:12:10 <Twey> Haha
03:12:41 <FusionGyro> but then again my PHP is kind of idiosyncratic and I wouldn't necessarily want a team of developers working with it
03:12:43 <Twey> I don't consider that a strength, when other languages could do it just as well (and the serious stuff, besides)
03:13:10 <SubStack> non-blocking evented haskell would be a neat experiment
03:13:23 <FusionGyro> oh don't misunderstand me. PHP isn't a good language. but as a technology that's widely deployed, if you can play to its strengths without losing your sanity, it's not as horrible as people say
03:14:29 <FusionGyro> it was essential in my failed business because my business partner could read and understand it. Ruby was pushing it. Haskell I think would have probably been out of reach.
03:15:20 <Twey> FusionGyro: Sadly, ‘playing to its strengths’ severely limits what you can actually do
03:15:27 * ksf notices that iteratees are actually state transducers and wonders whether you can determinise and minimise them
03:15:49 <Twey> And even so it's rather flaky — not much in the way of guarantees that your project isn't going to explode
03:16:34 <ksf> SubStack, what do you mean with non-blocking?
03:16:39 <FusionGyro> Twey: true, but it's sufficient for most needs. most webapps (speaking from the experience of my *failed* business) did very little actual work. data in, data out, process a credit card, render a web page
03:16:46 <ksf> I found that epoll/threads are the best way to go
03:17:12 <Twey> FusionGyro: I would never trust PHP with credit-card–processing, for example.
03:17:15 <SubStack> ksf: asynchronous
03:17:28 <nom2782> the PHP language is poorly designed, seeing as it isn;t really designed in the first place.. though for medium sized applications it can still hold up pretty well. you just need to have experienced devs working with it to get acceptable code.. and those are impossible to find in the PHP world :x
03:17:41 <Twey> Heh, yeah
03:17:47 <Jafet1> Online credit card processing is inherently broken anyway, Twey
03:17:49 <Twey> All the experienced devs have left for greener pastures.
03:17:56 <Twey> Jafet: Fair point
03:17:59 <ksf> I don't believe in async IO
03:18:08 <ksf> it's an artifact of C sucking at threading
03:18:08 <Jafet> Twey, except for criminals
03:18:13 <FusionGyro> Twey: have you purchased anything online in the last decade? :) besides, the credit card processing infrastructure is set up to survive most kinds of errors you can make. at least, authorize.net and paypal seem to be
03:18:40 <Twey> FusionGyro: Yeah, but the difference is, if one of those sites leaks my card details, I'm suing.
03:18:57 <Twey> If *I* leak someone's card details, *they're* suing *me*.  :þ
03:19:05 <FusionGyro> haha, true
03:19:34 <FusionGyro> still, it's hard to imagine Rasmus Lerdorf being held responsible for it
03:19:40 <Twey> Haha
03:20:02 <FusionGyro> I can't really picture a lawyer arguing that his notion of types that change type based on the way you use them led to fraud
03:20:09 <FusionGyro> even though it is ridiculous
03:20:31 <theorbtwo> These days, I think almost all credit card processing is really online.
03:20:36 <Twey> ‘Silly coders!  Look, with just these measly three pages of extra code demonstrating considerable knowledge of many of the internals of PHP, you could make it acceptably secure!’
03:21:25 <FusionGyro> I got into a *huge* flamewar on Reddit a week or so ago just for pointing out that it is absurd that PHP-the-language has a config file
03:21:32 <ksf> maybe php is just not horrible enough
03:21:38 <Twey> FusionGyro: Hahaha
03:21:41 <ivanm> OK, ghci is annoying me
03:21:45 <ksf> someone should write php++ to make people leave it.
03:21:52 <ksf> php--
03:21:55 <ksf> (just in case)
03:21:57 <ksf> @karma php
03:21:57 <lambdabot> php has a karma of 0
03:21:59 <Twey> xD
03:22:03 <tensorpudding> What the hell does it mean for a language to have a config file?
03:22:03 <FusionGyro> haha! how could we make it more horrible? we need to add 70 more keywords
03:22:03 <ivanm> I'm trying to hack on pandoc, but the source code there is in a src/ sub-directory
03:22:26 <ksf> ivanm, cd src, then vi
03:22:28 <FusionGyro> make the parsing context-sensitive and hacky
03:22:36 <ksf> open another terminal to do your cabal thing.
03:22:48 <tensorpudding> I suppose if the language is "whatever this binary accepts", and that binary has a configuration file which changes the way the binary accepts data
03:22:51 <Twey> FusionGyro: No no, we need to add more Java-esque functionality that's horribly broken in significant and obvious ways!
03:23:06 <Twey> How about generics… but we don't allow nesting?
03:23:30 <FusionGyro> only if you can create a reduce/reduce conflict in the grammar like with C++ templates
03:23:37 <ivanm> when trying to load it in ghci, it bitches that modules not exposed via cabal aren't exposed by the pandoc package
03:23:41 <ivanm> rather than loading the source file :@
03:24:12 <Twey> class Foo<$Collection> { public function __construct($Collection $integers) { … } }
03:24:29 <FusionGyro> I just threw up in my mouth
03:24:34 <dcoutts_> ivanm: ghci always prefers local files to package modules, if the source files are visible
03:24:47 <dcoutts_> ivanm: but it does not load source files unless you tell it to
03:24:49 <ivanm> dcoutts_: it seems to be because I'm loading it from the project root
03:25:01 <dcoutts_> ivanm: -isrc ?
03:25:01 <ivanm> whereas the source fiels are in a src/ sub-directory
03:25:09 <ivanm> dcoutts_: ooohhh...
03:25:11 * ivanm tries that
03:25:33 <ivanm> dcoutts_: oh, and how do I tell ghci to use CPP?
03:25:39 <ivanm> as in specify CPP flags?
03:25:45 <ivanm> (since it's normally done by Cabal...)
03:25:51 <dcoutts_> -XCPP
03:26:08 * ksf wonders why there's not a flurry of activity getting haskell to run on everything, now that there's llvm
03:26:36 <ivanm> ksf: because LLVM doesn't run on everything?
03:26:40 <dcoutts_> ksf: because the llvm backend is not merged or finished
03:26:43 <ksf> {-# LANGUAGE #-}
03:26:59 <ksf> I never, ever do language options via cabal for exactly that reason.
03:27:05 <ivanm> dcoutts_: and how do I enable/disable a specific flag with that?
03:27:07 <tensorpudding> LLVM hasn't yet become ubiquitous
03:27:16 <ivanm> ksf: it's specifying a compile-time option
03:27:26 <ksf> -DFOO=BAR?
03:27:26 <ivanm> and this isn't my project, so *shrug*
03:27:30 <ksf> iirc it's the same as with gcc
03:27:30 <theorbtwo> ksf: That keeps the options with the piece of software, which is completely sane.
03:27:41 <ivanm> oh, I don't need to specify a flag
03:27:44 <ivanm> yippee!!! :D
03:27:49 <theorbtwo> At the very least, it's significantly more sane.
03:27:53 <dcoutts_> ksf: in theory you're supposed to do both
03:28:12 <ksf> why should I?
03:28:29 <dcoutts_> ksf: to indicate externally what extensions your package uses
03:28:37 <dcoutts_> ksf: it's a kind of dependency
03:28:39 <ksf> I don't care
03:28:49 <ivanm> dcoutts_: we are? :/
03:28:50 <tensorpudding> I wonder if Clang is solid enough that Apple will ditch GCC in the near future
03:28:50 <ksf> if cabal wants to know that, it can grep the source.
03:28:51 <dcoutts_> ksf: we may enforce it one day
03:29:01 * ivanm sidles away hoping dcoutts_ doesn't notice him...
03:29:04 <ivanm> :p
03:29:31 <dcoutts_> ksf: right, it'd do that and then tell you that you forgot to list them
03:30:18 <ksf> while I'm at it: it'd be great to glob and filter in exposed-modules
03:30:42 <dcoutts_> hmm?
03:30:44 <ksf> exposed-modules = filter (`notSubString` "Internal) all-modules
03:31:17 <dcoutts_> is there much point if you still have to list all the modules?
03:31:31 <ksf> maybe do a two-stage thing, where the .cabal is generated from a description
03:31:37 <ksf> the point is _not_ to list the modules
03:31:46 <dafis> dcoutts_: I took "Extensions used only by one module may be specified by placing a LANGUAGE pragma in the source file affected" to mean that extensions used by all modules should only be given in the .cabal file
03:31:47 <dcoutts_> ah but that's not possible in general
03:31:49 <ksf> it's just an unreadable wall of text
03:32:19 <dafis> dcoutts_: Who's responsible for updating the Cabal manual?
03:32:35 <ksf> well you can always be explicit if you can't manage to express it as a filter
03:33:22 <ksf> for the majority of packages though, it'd just be exposed-modules = all-modules and everybody would sigh with relief.
03:33:28 <dcoutts_> dafis: there's a problem with the meaning of the extensions field at the moment, it should be just an external declaration, but the historical behaviour of the "Simple" build system has been to apply those extensions when compiling the code.
03:33:56 <dcoutts_> ksf: but what you're missing is that automatically discovering all-modules is not possible
03:34:34 <ksf> find src -name \*.hs ?
03:34:37 <dcoutts_> and we don't even know when we've not managed to find them all
03:34:41 <ksf> at least that's a good start
03:34:47 <dcoutts_> ksf: they're not necessarily .hs
03:34:58 <ksf> and when stuff doesn't work out, let the users do it manually.
03:35:00 <dcoutts_> and *.hs might be too much
03:35:24 <ksf> it's not necessary to be general, just be concise in the usual cases.
03:35:42 <dcoutts_> furthermore, it means you need to build much of the package just to know what modules are in it
03:35:53 <dcoutts_> that's not really acceptable for things like sdist
03:36:13 <dcoutts_> and then combined with the fact that it cannot be accurate
03:36:18 <ksf> that's where the two-pass thing comes into play
03:36:31 <dcoutts_> ksf: sure, cabal init can make a good guess
03:36:33 <ksf> generate the sdist .cabal from a description
03:36:53 <dcoutts_> and it can tell you when you've definitely forgotten to list a module
03:37:56 <dcoutts_> ksf: so the best we can realistically do is to help people maintain the list correctly
03:38:21 <ksf> imho, there's usually good reasons to keep the vcs sources and sdist sources at different stages
03:38:27 <SubStack> > let (?) b x y = if b then x else y in (1 > 2) ? 5 $ 6
03:38:28 <lambdabot>   6
03:38:31 <SubStack> ^_^
03:38:42 <dafis> dcoutts_: Just to make sure, when I give ghc-options: -O2 in the .cabal file, that flag is passed to ghc for all modules?
03:38:43 <ibid> any community.haskell.org admins here now?
03:38:45 <ksf> xcb e.g. could come with .hs files pre-generated, as the xml descriptions won't change.
03:38:52 <dcoutts_> dafis: yes
03:39:14 <dcoutts_> ibid: you wondering about the planet email address?
03:39:21 <ibid> dcoutts_: yes
03:39:24 <dcoutts_> ksf: that's true
03:39:29 <ibid> dcoutts_: no mail is getting through
03:39:42 <dcoutts_> ibid: have you filed a support ticket?
03:40:01 <dcoutts_> ibid: or ask Igloo
03:40:05 <ksf> the same goes for happy and alex
03:40:12 <ibid> dcoutts_: i didn't try, since if email does not get through, then any ticket will not get filed until the problem is solved
03:40:26 <ibid> dcoutts_: which would be pointless
03:40:44 <sioraiocht> dcoutts_: do you mind reading a paragraph for me real quick?
03:40:44 <dcoutts_> ibid: oh you mean no mail is getting through at all, not just the planet email address
03:40:45 <alip> is there a built-in function to delete just the Nth element of a list?
03:40:52 <ibid> connect to community.haskell.org[72.249.126.23]:25: Connection refused
03:40:52 <sioraiocht> and telling me if you dispute its claim? =p
03:41:00 <ibid> dcoutts_: ^^
03:41:09 <dafis> alip: no
03:41:13 <ksf> alip, you usually don't want to do that
03:41:16 <ibid> dcoutts_: it's not responding to SMTP
03:41:26 <ksf> actually, you never want to do that
03:41:27 <dcoutts_> ibid: thanks
03:41:35 <ksf> lists are meant to be processed in-order
03:41:45 <dcoutts_> sioraiocht: 'k
03:41:48 <ksf> there's maps and sets and stuff for the other cases.
03:41:59 <sioraiocht> The memory layout of a |Rope| improves upon |String|'s both in terms
03:42:00 <sioraiocht> of latency and data density.  The improvement in data density is
03:42:00 <sioraiocht> accomplished by using an array of unboxed words for our chunk.  This
03:42:01 <sioraiocht> is stored in a contiguous region of memory and therefore provides
03:42:04 <sioraiocht> better locality of reference. We also reduce latency by decreasing the
03:42:05 <sioraiocht> amount of pointer indirection in certain circumstances; although the
03:42:07 <sioraiocht> tree structure introduces a fair amount of pointer indirection, the
03:42:09 <sioraiocht> tree structure supports many operations in a way that avoids having to
03:42:11 <sioraiocht> traverse them all. 
03:42:15 <sioraiocht> ugh
03:42:17 <sioraiocht> REALLY SORRY
03:42:19 <sioraiocht> effing IRC clien
03:42:21 <sioraiocht> t
03:42:26 <dcoutts_> sioraiocht: :-)
03:42:31 <dcoutts_> @slap sioraiocht
03:42:31 * lambdabot pushes sioraiocht from his chair
03:42:42 <ibid> Igloo: ping
03:42:43 <SubStack> ropes!
03:42:44 <sioraiocht> @slap limechat
03:42:45 * lambdabot pokes limechat in the eye
03:42:47 * earthy kucht.
03:42:49 <Igloo> ibid: Hopefully fixed now
03:42:50 <sioraiocht> SubStack: Yes...yes indeed
03:42:53 <ibid> Igloo: cool .9
03:43:01 <sioraiocht> anyway dcoutts_, there is is
03:43:28 <ksf> ropes aren't _that_ much better than lazy bytestrings, though
03:43:30 <Igloo> Oh, maybe not
03:43:37 <ibid> still getting Jun 10 13:42:57 flowerpot postfix/smtp[22877]: connect to community.haskell.org[72.249.126.23]:25: Connection refused
03:43:38 <sioraiocht> ksf: agreed
03:43:43 <ksf> or iteratees, fwiw
03:43:48 <Igloo> OK, /now/ it should work  :-)
03:44:07 <sioraiocht> ksf: cheers, at least that awful embarrassment got some feedback =p
03:44:10 <ibid> Igloo: yes, thanks :)
03:45:22 <dcoutts_> sioraiocht: the latency/indirection aspect is a bit wishy washy, isn't it simply the number of indirections that must be followed, amortised over some sequence of operations
03:45:33 <alip> ksf: i see, i have a vty application that has a list of open buffers and the user may close them and open new ones at will.. which data type would fit best in this situation?
03:45:37 <sioraiocht> dcoutts_: yeah...
03:46:08 <sioraiocht> dcoutts_: mrrrr, okay, heheh
03:46:12 <sioraiocht> dcoutts_: cheers =)
03:46:13 <dcoutts_> sioraiocht: e.g. to foldl' . take n, how many indirections are taken
03:46:15 <ksf> a zipper, I guess
03:46:23 <ksf> xmonad does the same
03:46:45 * hackagebot cabal-macosx 0.1.1 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.1.1 (AndyGimblett)
03:46:51 <sioraiocht> dcoutts_: well with take n, a logarithmic number of them
03:46:51 <ksf> also, Data.Sequence
03:47:15 <sioraiocht> dcoutts_: and then with foldl'
03:47:17 <sioraiocht> yes...
03:47:29 <sioraiocht> n 
03:47:29 <sioraiocht> heh
03:47:30 <dcoutts_> sioraiocht: in particular how many new/fresh ones, since to a first approximation you could say that new indirections incur full memory latency and old ones are free (in the cache)
03:47:36 <sioraiocht> right
03:47:36 <sioraiocht> okay
03:47:46 <ksf> bytestrings are going to be more efficient for foldl
03:48:01 <sioraiocht> ksf: definitly, anytime you are doing a purely read operation
03:49:18 <ksf> and iteratees are going to be more efficient for reading _and_ changing, at least if what you want to change doesnt' depend on something at the end of the stream.
03:49:27 <dcoutts_> ksf: the main advantage of ropes over lazy bytestrings is concatenation
03:49:39 <dcoutts_> and splitting
03:49:47 <sioraiocht> indeed
03:49:49 <ksf> they're awfully good at inserting and filtering stuff
03:51:19 <dcoutts_> sioraiocht: going to the talk in 10min?
03:51:22 <quicksilver> a rope is quite similar to a Data.Sequence of strict chunks isn't it?
03:51:37 <dcoutts_> quicksilver: that's what sioraiocht is doing basically
03:51:43 <ksf> afaiu, yes
03:51:49 <sioraiocht> yes
03:52:03 <ksf> finger trees are the right choice for quite a lot of stuff
03:52:12 <tao_> Hello, any hlibev users here?
03:52:25 <quicksilver> in fact, 'rope' seems to be quite poorly defined
03:52:41 <quicksilver> it's just a "tree" where the leaves are strings
03:52:48 <sioraiocht> quicksilver: Yep
03:52:54 <quicksilver> fingertree should be better than binary tree for almost all cases though.
03:53:02 <quicksilver> is there anything binary trees are better at?
03:53:11 <sioraiocht> quicksilver: Esp if you consider balancing costs
03:53:20 <ksf> binary trees can be cache-oblivious
03:53:20 <sioraiocht> quicksilver: Fingertrees make sure they behave themselves
03:53:34 <ksf> I'm not aware of finger trees doing that
03:53:53 <ksf> ...completely disregarding that cache-obliviousness isn't a thing that one could do sanely in haskell
03:54:35 <sioraiocht> ksf: you can't construct an appalling unbalanced finger tree
03:54:52 <quicksilver> ksf: in what fashion are binary trees cache oblivious?
03:55:03 <ksf> you _can_ do them cache-oblivious
03:55:10 <ksf> they're not necessarily.
03:55:21 <ksf> and they have to be well-balanced to do it.
03:55:33 <quicksilver> how does it work? If there is a short explanation.
03:55:41 * quicksilver has googled a paper but it doesn't look short.
03:55:51 * hackagebot fsmActions 0.4.2 - Finite state machines and FSM actions  http://hackage.haskell.org/package/fsmActions-0.4.2 (AndyGimblett)
03:56:22 <ksf> it's making sure that successive memory accesses are distributed such that they minimize cache misses over two differently-sized caches
03:56:43 <ksf> once you have that structure, the actual cache sizes and number of levels don't matter anymore, that's why it's called oblivious.
03:56:53 <vipex> getoutta here guys... thanks for help :) enough for today
03:57:07 <vipex> see u all
03:57:21 <quicksilver> ksf: I believe you but i don't understand. That sounds clever and subtle.
03:57:22 <ksf> in the binary tree case, it's about using van emde boas layout.
03:58:08 <ksf> which is a flat array with a non-trivial index function, and there's even more clever and subtle techniques to enable them to be modifiable.
03:58:56 * quicksilver nods
03:58:59 <ksf> after reading those papers I concluded that to do it properly in haskell, the gc would have to do it.
03:59:07 <quicksilver> clever.
03:59:21 <quicksilver> I just skimmed a MSDN blog post on van emde boas
03:59:30 <quicksilver> ksf++ # learning me new stuff
04:00:54 <ksf> quicksilver, heard about http://www.cis.upenn.edu/~alur/nw.html , yet? ;)
04:01:55 <mklappstuhl> SubStack: very nice introduction to node's basic principles
04:01:58 <mklappstuhl> http://www.yuiblog.com/blog/2010/05/20/video-dahl/
04:07:27 <quicksilver> ksf: I heard people rabitting about them yesterday but I didn't spot the rubies in the mud.
04:08:09 <mreh> how do you test small parsers made with attoparsec? I suppose you can wrap them with an endOfInput parser
04:09:41 <zygoloid> does anyone here know of a correct spec for ELF? the one i found claims that symbol table entries are 16 bytes, but they're evidently 24 bytes :/
04:10:25 <mreh> do these parsers expect to read the null symbol or something?
04:12:26 <quicksilver> zygoloid: 64-bit elf /= 32-bit elf
04:13:11 <zygoloid> quicksilver: yeah, i could well believe it's that. the spec i found claims to cover both, but maybe it's wrong for 64-bit elf.
04:18:05 <Blkt> can I declare a data with some kind of constraint? Like data "Gene = C | D" and "data GeneticString = [Gene]" with GeneticString being a fixed size list?
04:18:28 <Zao> You could use another type than []
04:18:37 <dayz> quicksilver, hi again. The day before yesterday, i asked you about whether EX a b. f(a) < f(b) --> EX a b. f(a) > f(b) would be true. I think you said it's trivially true because the premise can be false. But a false premise is just one particular case; wouldn't one also need to prove whether the conclusion holds if the premise is true?
04:18:47 <Blkt> Zao: I'd prefere to use lists
04:19:03 * Zao eats cake and has it too.
04:19:58 <dafis> dayz: You're having an existential quantification
04:20:29 <dafis> dayz: So all you need is *one* example giving a false premise
04:22:34 <dafis> dayz: but here, it's a bit different, you're having an existential implying an existential (or not)
04:22:51 <dayz> dafis, right. but why is it different?
04:23:33 <dafis> dayz: so you have to either prove that there's no instance of the premise (i.e. forall a b. f(a) >= f (b))
04:24:02 <dafis> dayz: or, from an instance of the premise, derive an instance of the conclusion
04:24:35 <dafis> dayz: which is trivial here, because if f(x) < f(y) then f(y) < f(x)
04:25:04 <dayz> dafis, but would I not need to do the same if the conclusion wasn't an existential?
04:25:28 <dafis> dayz: if you prove there's no instance of the premise, you have ex falso quodlibet
04:26:04 <quicksilver> it also depends how you bracket it
04:26:19 <quicksilver> EX a b. f(a) < f(b) --> EX a b. f(a) > f(b) would normally be interpreted as
04:26:29 <quicksilver> EX a b. [ f(a) < f(b) --> [ EX a b. f(a) > f(b) ] ]
04:26:31 <quicksilver> i.e.
04:26:37 <quicksilver> EX a b. [ f(a) < f(b) --> [ EX c d. f(c) > f(d) ] ]
04:26:42 <quicksilver> I have a feeling that isn't what you meant
04:26:51 <quicksilver> [ EX a b. f(a) < f(b) ] --> [  EX a b. f(a) > f(b) ]
04:26:53 <quicksilver> might be what you meant.
04:26:58 <dayz> quicksilver, that's right.
04:27:12 <quicksilver> well that's absolutely 100% different to the one we were discussing the other day
04:27:20 <quicksilver> I was talking about an outermost EX (on the left)
04:27:37 <quicksilver> an EX "inside" an --> is very different
04:27:55 <dayz> quicksilver, right. why's that?
04:30:19 <dayz> dafis, did you mean if f(x) < f(y) then f(x) < f(y)?
04:30:58 <dafis> dayz: almost. I meant if f(x) < f(y) then f(y) > f(x) but let go of the shift key too early
04:31:15 <dayz> right
04:31:35 <alip> ksf: hmm, how do you remove an element from a Data.Sequence?
04:32:27 <dafis> dayz: re EX inside (-->) vs outside: EX x. [x --> P] means there is (at least) one x, so that [x --> P] holds
04:33:09 <dayz> dafis, sure. but then the outline of the proof is the same right? either proof that the premise can be false or if it's true, the conclusion is also true.
04:33:29 <dafis> dayz: dang, mean EX x. [Q(x) --> P]
04:34:11 <dafis> dayz: so if there's one x for which Q(x) doesn't hold, you're done because [False --> P]
04:34:45 <dafis> dayz: Yes, same outline, but different to fill in
04:35:13 <dayz> dafis, but if it was EX x. Q(x) --> EX x. P(x), then if Q(x) doesn't hold, that's done too, right?
04:36:34 <dafis> dayz: Yes, but if P and Q are related in a relatively obvious manner, that influences what you do
04:37:25 <dafis> in particular, in the example above, P and Q were just a flipping apart
04:38:19 <dayz> dafis, right, but how does it change things?
04:39:32 <dafis> dayz: I've expressed myself badly, sorry. It doesn't change anything fundamental, but the details
04:39:45 <dafis> of how you go about the proof
04:40:36 <dayz> dafis, I think I know what you mean.
04:41:12 <ksf> alip, use splitAt and concat
04:42:07 <ksf> ...unlike lists that's efficient with sequence
04:42:37 <Blkt> is there a way to set some constraints to a data or type definition?
04:43:03 <dayz> thanks
04:43:05 <Blkt> like setting a board as a list of 64 elements?
04:43:35 <ksf> hmmm
04:45:06 * hackagebot hsc3-process 0.2.1 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.2.1 (StefanKersten)
04:45:24 <ksf> nope the recursion scheme is just not in the standard libs
04:45:30 <ksf> I've stumbled across that before
04:46:05 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26061#a26061   <-- that's what's missing.
04:46:29 <ksf> which seems to be iso to StateT s []
04:47:14 <ksf> gosh I would've never have spotted that back in the days I wrote it.
04:47:42 <ksf> ...two years ago
05:02:44 <zygoloid> seems to me that "exists a b. f(a) < f(b) --> f(a) > f(b)" isn't true in general. it's false if f : {} -> X.
05:04:59 <quicksilver> zygoloid: dayz was working in R -> R though
05:05:13 <quicksilver> zygoloid: of course you're right otherwise.
05:23:26 <opqdonut> zygoloid: of course, "in general" you want to know something about the relations > and < to make it true... :)
05:28:41 <zygoloid> opqdonut: yeah. i'm assuming that x < x is false.
05:30:06 <opqdonut> mmh
05:44:08 <b0fh_ua> Hello! Can somebody please advice how to override include directory search path when building glib with cabal?
05:44:44 <b0fh_ua> i'm getting the error: "setup: glib-0.11.0: include-dirs: /usr/local/lib/glib-2.0/include doesn't exist or isn't a directory (use --force to override)". And glib-2.0 headers are in /usr/local/include
05:45:03 <b0fh_ua> probably I could create symlink, but this approach sucks
05:45:34 <gio123> a
05:49:07 <ksf> b0fh_ua, is your pkgconfig path broken?
05:49:45 <ksf> ...assuming that glib has a pkgconfig entry and the people writing the package weren't being too smart for their own good
05:51:41 <b0fh_ua> ksf: pkg-config --cflags glib-2.0 => -I/usr/local/include/glib-2.0 -I/usr/local/lib/glib-2.0/include
05:51:57 <b0fh_ua> for some reason cabal chooses last one which doesn't exist
05:52:17 <b0fh_ua> /usr/local/include/glib-2.0 does exist and contains headers
05:52:33 <ksf> try making an empty directory
05:53:01 <b0fh_ua> ksf: that's very close to making symlink
05:53:24 <ksf> well the other quick fix is to edit your pkgconfig
05:53:57 <ksf> convincing the cabal people that they should'nt choke on spurious include flags might take some time
05:54:55 <ksf> you can, of course, always use --force
05:57:37 <b0fh_ua> ksf: good point, thanks
05:57:46 <b0fh_ua> I'll edit glib-2.0.pc
05:58:05 <b0fh_ua> seems to work :)
05:59:14 <b0fh_ua> probably I will be able to install gtk now
06:06:33 <tao_> does ByteString support unicode?
06:06:39 <tao_> (stupid question)
06:07:15 <dafis> tao_: there's some utf-8 stuff for ByteStrings in utf8-string
06:07:41 <tao_> hmm ok
06:07:42 <tao_> thanks
06:08:40 <dafis> tao_: but basically, ByteStrings are made up of bytes, so unicode stuff isn't what they're made for
06:09:00 <tao_> hmm
06:09:21 <tao_> Ok
06:09:26 <tao_> can somebody help me out there
06:09:30 <tao_> I read this comment: http://stackoverflow.com/questions/1451755/many-types-of-string-bytestring/1451819#1451819
06:09:32 <dafis> tao_: what do you want to do?
06:09:42 <tao_> but I need both compression and networking 
06:09:44 <tao_> and utf
06:09:45 <tao_> 8
06:09:52 <tao_> what should I  use?
06:10:21 <ksf> is there any way to get cabal to pass -dynamic when building executables short of editing the source?
06:15:20 <Axman6> tao_: have you looked at the Text package?
06:16:25 <tao_> hmm.. no
06:16:31 <tao_> I'll look, thanks
06:16:35 <tao_> Data.Text?
06:16:44 <Axman6> yes
06:16:47 <ksf> ...
06:16:58 <Axman6> i'm checking to see if there's a way to turn Text into bytestrings and back again
06:17:12 <ksf> installing libraries fails when I disable vanilla objects
06:17:45 <ksf> .hi files are missing
06:18:10 <dafis> Axman6:not a good one, AFAIK
06:18:12 <Axman6> tao_: yeah Data.Text.Encoding has encodeUtf8 and decodeUtf8
06:18:25 <Axman6> dafis: how so?
06:20:52 <ksf> ...and ghc didn't come with p_dyn enabled
06:20:53 <bastl> Hi. Wasn't there a script that auto-generates  a stub for cabal files ?
06:20:58 <dafis> Axman6: Not particularly fast, I think
06:21:14 <bastl> i found mkcabal on the net, but expected "cabal create" ...
06:21:16 <ksf> so we've got perfectly fine dynamic linking, we just can't use it.
06:21:25 <ksf> bastl, cabal init
06:21:26 <dafis> although, if you en/decode only once, it's okay
06:21:35 <bastl> tx
06:21:52 <bastl> since what cabal version?
06:21:54 <Axman6> dafis: well from what i can tell, ti should only happen once at each end per message
06:21:59 <tao_> i think i will just compress an utf8 string
06:22:06 <tao_> and send it over the netwoek
06:22:12 <tao_> using standar ByteString
06:22:21 <tao_> or is it a bad solution?
06:22:44 <dafis> tao_: seems fine
06:23:09 <yitz> tao_: it's a great solution, as long as you are only treating the utf-8 as a binary stream of bits.
06:25:57 <tao_> yitz: well
06:26:03 <tao_> im making a client-server app
06:26:11 <tao_> client sends command
06:26:11 <tao_> like
06:26:15 <tao_> "PING"
06:26:20 <tao_> and server has to reply
06:26:45 <tao_> But there might be commands like "PUT bla"
06:26:50 <tao_> where bla is utf8 string
06:27:05 <tao_> so as long as I decompress it on the server it should be ok?
06:28:01 <yitz> tao_: if all of the commands are just ASCII, and you don't need to look inside the utf-8 parts, then just treat it as binary, yeah.
06:28:21 <tao_> commands are not neccesary ASCII
06:28:29 <tao_> well, commands are just ASCII
06:28:43 <tao_> but their parameters may include UTF8 stuff
06:29:04 <tao_> Also, can somebody help me with this error please: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26063#a26063 ?
06:29:11 <tao_> I dont get it
06:29:27 <tao_> Which function is expecting [Char]
06:29:46 <Blkt`> what should I do when I don't need to specify exhaustive patterns for a function and still I want it to be complete?
06:30:02 <ksf> "" is not a bytestring
06:30:12 <ksf> but packCString (...) is 
06:30:33 <tao_> OOh
06:30:35 <tao_> silly me
06:30:36 <ksf> you can either use BS.pack "", BS.empty, or enable -XOverloadedStrings
06:30:36 <Zao> ksf: (Unless you use overloaded string extensions, which I assume aren't used.)
06:30:37 <tao_> thanks ksf 
06:30:48 <Axman6> tao_: if you don't understand bytestrings, why are you using things like packCString?
06:30:54 <yitz> tao_: so your client app gets passed some text that is already utf-8 encoded from somewhere else, then needs to put those as params in your protocol?
06:31:44 <ksf> tao_, there's a package called network-bytestring, there's no need to go and cast pointers
06:31:48 <jkramer> Ahoy
06:31:51 <tao_> Axman6: because I have to use ByteStrings. Plus I want to understand them
06:32:04 <yitz> Blkt`: if you want it to be complete, then you do need to specify exhaustive patterns.
06:32:08 <Axman6> but why are you using packCString?
06:32:17 <tao_> um
06:32:20 <tao_> well
06:32:22 <yitz> Blkt`: there are cases you are assuming could never happen?
06:32:28 <tao_> what should I use if not packCString?
06:32:41 <Blkt`> yitz: should never happen
06:32:47 <Axman6> packCString is there (i believe) so that you can pack a string into an array which can be used by C code when using the FFI
06:32:47 <ksf> where did you get that Ptr Word8 from, anyway?
06:32:47 <tao_> yitz: yes
06:33:06 <tao_> Axman6: i am using FFI
06:33:11 <tao_> and it's backwords
06:33:14 <Blkt`> yitz: I have as an argument a list that must not be longer than 6
06:33:17 <tao_> it gives you bytestring
06:33:18 <yitz> Blkt`: so let's say someone changes the code someday, makes a mistake, and the impossible happens. What should your app do?
06:33:22 <tao_> from given CString
06:33:35 <Axman6> what're you using the FFI for exactly?
06:33:39 <tao_> I'm using hlibev, which is FFI
06:33:51 <Blkt`> yitz: I know different data structure would be more adequate, but as a prototype I prefere to keep it "simple"
06:34:06 <jkramer> Is there a data type for time durations/differences? DiffTime looks pretty much like a normal time data type, or can it be used for diffs as well?
06:34:17 <yitz> Blkt`: on easy thing would be to add a case that says error "You can't pass more than six items to this function", and the program will crash in that case.
06:34:42 <yitz> Blkt`: that's not good if your software will be, say, controlling the avionics on an aircraft.
06:34:44 <Zao> f _ _ _ _ = error "not enough cats, build more pylons"
06:35:08 <ksf> tao_, http://github.com/tibbe/event
06:35:09 <djahandarie> jkramer, Data.Time.Clock in the time package has NorminalDiffTime
06:35:16 <djahandarie> NominalDiffTime*
06:35:20 <yitz> Blkt`: so what to do in the "impossible" case depends on how safe your program needs to be, and on how it will be used.
06:35:27 <Axman6> looks like hlibev could use a high level interface
06:35:37 <tibbe> ksf: I'm integrating that code into GHC as we speak
06:35:43 <tao_> ksf: hmm.. ok
06:35:44 <Axman6> tao_: you know the new IO backend to GHC is going to be using libev right?
06:35:53 <EvanR-work> 'impossible cases' arent
06:35:54 <tibbe> Axman6: you'll be able to use normal forkIO and get libev like performance
06:35:56 <tao_> ksf: but i need to use hlibev :/
06:35:56 <yitz> sigh
06:35:59 <djahandarie> jkramer, which you can get from diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
06:36:07 <tao_> Axman6: really?
06:36:11 <djahandarie> jkramer, http://hackage.haskell.org/packages/archive/time/1.2.0.2/doc/html/Data-Time-Clock.html
06:36:20 <tao_> libev is good
06:36:33 <tao_> i've been using it in other languages and it was fast 
06:36:33 <EvanR-work> anything which relies on you doing everything correctly in another part of the program is suspect
06:36:44 <Axman6> yes, there's a lot of work going into it, with some extremely impressive results
06:36:57 <Axman6> (like haskell web servers which crap on things like Apache)
06:37:05 <tibbe> tao_: Axman6: it's actually a reimplementation of parts of libev as libev insists on callbacks and making callbacks from C into Haskell is a bit problematic as Haskell is a GCed language and may move things around.
06:37:23 <Axman6> tibbe: even better :)
06:37:24 <tao_> Axman6: snap-server?
06:37:25 <tao_> indeed
06:37:27 <Axman6> yes
06:37:27 <eevar2> Axman6: crapping on apache isn't that hard, tho
06:37:38 <eevar2> Axman6: nginx is a harder target, tho
06:37:38 <tibbe> tao_: the difference here is that you can use forkIO and pretend that you have one (OS) thread per request
06:37:45 <tibbe> tao_: but you get libev like performance
06:37:52 <tibbe> tao_: better programming model, same performance :)
06:37:56 <ksf> tibbe, please keep those funcitons working on Fd exposed
06:38:09 <tao_> erm
06:38:09 <ksf> ...actually, it's just threadWait* that I need
06:38:10 <jkramer> djahandarie: Thanks, that looks good.
06:38:12 <tibbe> ksf: you mean raw event registration?
06:38:25 <tibbe> ksf: we could expose threadWaitRead
06:38:39 <tibbe> ksf: the current base library doesn't but not for any technical reasons
06:38:45 <yitz> tibbe: linux only?
06:38:55 <ksf> it's what I currently use
06:39:06 <ksf> ...as I'm not using the standard handles
06:39:13 <tibbe> yitz: well, there's already a separate I/O manager for windows as select doesn't support file descriptors other than sockets on that platform
06:39:25 <tibbe> yitz: the new I/O manager is *nix (i.e. Linux, BSD, OS X)
06:39:37 <yitz> tibbe: sounds great!
06:40:06 <tibbe> ksf: I think we want to expose something lower level than Handles in base, something that truly represents a file descriptor and where you can get at the underlying file descriptor
06:40:17 <EvanR-work> *n*x
06:40:21 <ksf> aka Fd?
06:40:31 <EvanR-work> i.e. Benax
06:40:36 * edwardk waves hello.
06:40:38 <ksf> newtype Fd = Fd CInt
06:40:49 <yitz> tibbe: solaris?
06:41:10 * yitz waves back
06:41:12 <tibbe> yitz: does it support one of poll, epoll, kqueue?
06:41:16 <ksf> I'm not counting on splice being in any library soon, so I really have to have that fd
06:41:21 <tibbe> ksf: doesn't work on windows I'm afraid
06:41:31 <tibbe> ksf: sure
06:41:42 <tibbe> ksf: so there should be a platform dependent way to get at the underlying object
06:42:07 <yitz> tibbe: not sure. something really fast though, i'm sure.
06:42:45 <tibbe> yitz: perhaps /dev/poll ?
06:42:45 <ksf> I'm currently linux-only, anyway
06:42:56 <ksf> though the bulk of the code would run on any POSIXy Os
06:43:01 <tibbe> yitz: that, and windows I/O completion ports, are the only mechanisms I'm aware of
06:43:19 <jkramer> Hmm, is there something like NominalDiffTime for LocalTime or will I need to convert all my LocalTimes to UTCTimes first?
06:43:32 <ksf> ...and a third of splice can be replaced by sendfile.
06:43:46 <ksf> no a fourth.
06:44:05 <yitz> tibbe: google solaris kqueue gives a lot of hits about it.
06:45:31 <tibbe> ksf: I plan to add sendfile to network-bytestring
06:45:50 <yitz> tibbe: http://developers.sun.com/solaris/articles/event_completion.html
06:45:54 <tibbe> yitz: so we have kqueue support, unfortunately we cannot enable it by default on OS X as it's a bit broken for everything except sockets
06:45:55 <ivanm> Anyone know who WillNess on the wiki is?
06:46:04 <ivanm> he seems to be making some questionable edits IMHO
06:46:11 <ksf> tibbe, I'm extending iteratees with splice support
06:46:39 <tibbe> ksf: cool
06:46:39 <edwardk> what is a splice?
06:46:41 <yitz> tibbe: it give poll as an example of a legacy library that their event completion framework generalizes and greatly improves performance
06:46:42 <ksf> ...where data doesn't touch userspace automagically when it doesn't have to
06:46:52 <ivanm> e.g. arbitrarily changing the text of humour dialogs that AFAICT came about from old emails, etc.: http://haskell.org/haskellwiki/?title=Humor%2FDialogs&diff=34937&oldid=17311
06:47:04 <ksf> provided chunking works out, that is. one might have to give a few hints about that.
06:47:15 <yitz> tibbe: so you're using something else on os x?
06:47:21 <ksf> edwardk, a generalised sendfile
06:47:38 <ksf> put differently, an interface to kernel pipe buffers
06:47:44 <edwardk> ksf: hrmm, reference?
06:47:49 <ksf> you can zero-copy anything to anything in linux
06:47:49 <ksf> man splice
06:47:51 <edwardk> ah
06:48:06 <tibbe> yitz: yes, it'll be poll which doesn't scale well but can handle more than 1024 fds
06:48:16 <yitz> ok
06:48:19 <tibbe> yitz: the real performance boosts will be on linux and some bsds
06:48:22 <edwardk> ksf: perfect =)
06:48:33 <ksf> the only gotcha is that one might to have to create a pipe to splice e.g. from file to file
06:50:02 <ksf> ...and that's two file descriptors less, then
06:50:02 <ksf> I should probably figure out how to pool them, because stuff is going to blow up into my face sooner or later anyway
06:50:36 <yitz> tibbe: solaris also has poll but of course they don't recommend it anymore. use port_event.
06:51:06 <yitz> tibbe: #include sys/port.h
06:51:16 <yitz> tibbe: sound familiar?
06:51:26 <tibbe> yitz: so we don't have a port_event backend
06:51:43 <tibbe> yitz: someone would have to write one, I think it should be straightforward as the current design works for 5 backends
06:52:14 <yitz> tibbe: so use port for now I guess.
06:52:25 <yitz> s/port/poll/
06:53:26 <tibbe> yitz: yes
06:57:34 <edwardk> ksf: ok. now i get what you're doing. neat =)
06:58:29 <edwardk> so, should you implement the splicing as another constructor in the Iteratee data type, like the Seek is handled? and push it up to the wrapper?
06:59:25 <edwardk> and how does this work if you're not producing/consuming file data?
07:01:51 <ksf> right now it's another constructor in Iteratee, yes, but I'm planning to refactor the whole thing and make it a transformer around Iteratee
07:02:20 <ksf> ...if that works out, that is.
07:04:13 <edwardk> ksf: *nods*
07:04:28 <edwardk> are you just returning the extra constructor with the Fd in it?
07:04:54 <edwardk> saying splice this here?
07:05:16 <ksf> yes, fd, offset, count, and a continuation iteratee
07:05:43 <ksf> actually,     , spliceCont :: !(Int -> m (Iteratee ctl c t m a))
07:05:47 <edwardk> it might not be a bad way to go anyways because different drivers can then do what they need to do, i.e. if they are just sending the data to a file they can really splice, otherwise they can read at user level, etc.
07:05:53 <ksf> ...the m already hints that it should be a transformer
07:06:22 <ksf> that works transparently.
07:06:55 <ksf> if an iteratee would like to splice it says so, otherwise it is fed a chunk. and it always has to provide a continuation that takes a chunk, as fallback
07:07:24 <ksf> both to make the code portable to non-supporting iteratees or OSs, and to be lenient about chunk boundaries
07:07:36 <edwardk> *nods*
07:07:44 <edwardk> complicated but necessary it seems
07:20:52 <yitz> tibbe: for solaris 7, they have /dev/poll i suppose also not supported? http://developers.sun.com/solaris/articles/polling_efficient.html
07:21:35 <tibbe> yitz: it isn't, again someone on solaris would have to write and test a backend
07:22:07 <bastl> I got a weird runtime error when dynamically loading modules with hint: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26068 can someone help with that ?
07:22:58 <zygoloid> bastl: looks like you have two versions of bytestring running at different frame rates? ;-)
07:23:25 <zygoloid> bastl: seriously though, you could try running 'nm' on your .o files and see where eelse that symbol comes from
07:23:53 <bastl> where are those .o files?
07:24:04 <bastl> doh
07:24:48 <tao_> is event library in beta or smth?
07:24:58 <tao_> it's not avaliabe on hackage yet :/
07:26:53 <edwardk> preflex: xseen jmcarthur
07:26:53 <preflex>  jmcarthur was last seen on freenode/#haskell 17 hours, 54 minutes and 20 seconds ago, saying: can't say it would be very useful though
07:27:38 <Axman6> tao_: it's not a library
07:27:55 <jmcarthur> edwardk: well that was good-ish timing i guess. just sat down to check my computer before i head to work
07:27:59 <edwardk> @tell jmcarthur the partial derivative trie contains binomial (n - k) k leaves for a function of k inputs at the nth level of the tree.
07:27:59 <lambdabot> Consider it noted.
07:28:04 <pastorn> @type curry
07:28:05 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:28:05 <edwardk> hah
07:28:13 <jmcarthur> lambdabot: I'M HERE
07:28:17 <edwardk> hah
07:28:22 <pastorn> is pair creation expensive?
07:28:24 <edwardk> well lambdabot has somthing to tell you ;)
07:28:24 <jmcarthur> umm
07:28:24 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
07:28:27 * pastorn is working with arrows....
07:28:50 <edwardk> i just solved the number of elements at each level problem at least
07:29:07 <jmcarthur> huh that results makes sense too
07:29:08 <tao_> Axman6: uhh
07:29:25 <edwardk> it also gives an insight into the savings.
07:29:26 <tao_> 'A Haskell event notification library '
07:29:30 <tao_> that's the description
07:29:40 <Axman6> maybe we're talking about different things then
07:30:15 <Axman6> i thought that the stuff tibbe was working was supposed to be fairly transparent to the user, not really something you use. i could be wrong though
07:30:33 <yitz> tibbe: the python twisted guys say "And BTW, poll on OSX is broken just as badly as kqueue..." http://twistedmatrix.com/trac/ticket/1918#comment:29
07:30:48 <yitz> tibbe: but you've gotten it to work?
07:30:52 <edwardk> jmcarthur: i'd first intended to store the trie using some complicated scheme but then i realized i can probably store each level as a flat vector.
07:31:25 <edwardk> so i wanted to figure out how many elements that vector should have
07:31:51 <tibbe> yitz: we might not have tested it enough, before finalizing the integration into base we'll pick the same default backends as libev
07:32:00 <tibbe> yitz: I think libev uses poll on OS X
07:32:25 <tibbe> Axman6: while the event library could be use as a standalone library it's intended to be integrated into GHC and replace the current I/O manager
07:32:37 <tibbe> Axman6: it's unlikely to be supported as a standalone library in the future
07:32:52 <Axman6> yeah, that's what i thought, and was explaining to tao_ 
07:33:57 <edwardk> jmcarthur: it also means i can encode my trie nicely as data Binomial s a = Binomial a [Vector a] -- using a phantom type s to carry around the information on the fanout
07:34:23 <tao_> tibbe: but it's avaliabe only in git version?
07:34:30 <tao_> btw, is it cross-platform?
07:34:55 <jmcarthur> edwardk: unfortunately i don't really have the time to talk right now. sounds cool, and i'd like to hear about it later
07:35:00 <edwardk> np
07:35:06 <jmcarthur> out
07:36:04 <tibbe> tao_: yes, and it's *nix only
07:37:01 <tao_> ooh
07:37:02 <tao_> :(
07:37:08 <tao_> that's its not goint to work out
07:37:09 <tao_> damn
07:41:27 <chrisdone> is it my computer or has the haskell wiki gone funny?
07:41:40 <chrisdone> i don't mean it's cracking jokes to me
07:41:43 <ksf> haskell.org servers never fail.
07:41:48 <michael|> funny ha-ha or funn..ah, okay
07:41:49 <chrisdone> the background is white
07:42:04 <ksf> it's always been nice.
07:42:42 <emilmeln> Description of "modify" function in the vector library says that modifying will be performed in place "if it's safe to do so". What does this phrase mean: single-threaded usage of the vector, or some internal library magic?
07:42:47 <ksf> must be that lsd finally wearing off.
07:43:34 <ksf> that means that it's going to be modified in-place when fusion kicks in and the library can drop into the ST monad
07:44:29 <applicative> edwardk, are there some obvious conditions on a typeclass f that would allow  me to define something like  lam :: ( f a -> f b ) -> f (a -> b)
07:44:54 <bastl> zygoloid: any idea, why the linker would load an old .o file? It loads bytestring-0.9.1.4.o but I just upgraded to bytestring-0.9.1.6
07:45:36 <ksf> bastl, ghc -v knows
07:46:01 <ksf> most likely because some other package is using the old bytestring
07:46:37 <zygoloid> does anyone know if there are any stability guidelines for the include/rts/*.h files which ship with ghc?
07:46:59 <edwardk> applicative: there are a number of such conditions but nothing really canonical
07:47:20 <edwardk> applicative: that pops up in a lot of GADTs for hoas
07:47:35 <edwardk> and in finally tagless representations that don't even use a gadt
07:47:45 <applicative> edwardk, yeah, I was thinking about hoas 
07:48:58 <applicative> edwardk, of course I can just speak of class Symantics f where  ...   lam :: ( f a -> f b ) -> f (a -> b) ...
07:49:58 <applicative> edwardk, but I was thinking, just of the signature itself, when can I expect such a thing to be available. 
07:50:14 <applicative> edwardk, probably a somewhat muddled questiion
07:50:16 <yitz> it looks like the inverse of a functor
07:51:11 <edwardk> applicative: i understand the question but don't have a good answer
07:51:15 <applicative> yitz, yes 
07:52:02 <edwardk> there is probably something to yitz's observation
07:53:26 <edwardk> i.e. you have a post-image of some functor, lam maps it back into a pre-image. so if f is a Functor, then f has to some how be able to map onto all such functions f a -> f b.
07:53:39 <zygoloid> if it's also an applicative then it sounds like it'd have to be a pretty boring functor
07:53:51 <edwardk> zygoloid: nah those can be quite exciting
07:54:10 <edwardk> the trick is that you don't really want f to be a functor over hask, but to only admit a much more limited domain
07:54:37 <edwardk> those can do things like partial evaluation, pretty print, etc. its just a hoas lambda.
07:56:05 <zygoloid> hmm. if you have (f a -> f b) -> f (a -> b), and also f (a -> b) -> (f a -> f b) plus a -> f a, with the natural laws, i'd think that the structure of f would have to be fixed.
07:56:06 <edwardk> class Symantics f where lam :: (f a -> f a) -> f (a -> b); abs :: f (a -> b) -> f a -> f b; ...; you can make instances of Symantics for pretty printers, evaluators, etc.
07:56:08 <applicative> edwardk, I was secretly trying to restrict lam somehow, but was in a mess with Category (~~>)  => ...
07:56:47 <edwardk> the trick is we usually don't give you f (a -> b) -> f a -> f b ;)
07:57:07 <edwardk> because you might get an f (a -> b) through application
07:58:23 <applicative> for example this type checked.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26069
07:58:37 <applicative> pardon ugliness
08:00:08 <applicative> edwardk, the ugliness is due to the desire for something like l :: (repr a >~> repr b) -> repr (a ~> b)
08:00:47 <quicksilver> edwardk: Symantics?
08:01:06 <quicksilver> is that a contraction of symbolic semantics or something?
08:01:09 <edwardk> quicksilver: portmanteau of syntax and symantics
08:01:14 <edwardk> er semantics
08:01:21 <edwardk> blame cc shan ;)
08:01:33 <edwardk> it comes from the finally tagless partially evaluated paper
08:01:43 <applicative> pretty ugly name
08:01:45 <edwardk> applicative: being pulled away IRL, brb
08:01:56 <tao_> Can I rewrite 'input <- getSomething; let input' = toString input' into 'input <- toString =<< getSomething'?
08:02:03 <edwardk> applicative: yeah, but entrenched now ;)
08:02:09 <edwardk> and slowly growing on me
08:02:21 <alip> what am i doing wrong here? http://paste.pocoo.org/raw/223933/ it hangs after printing the first trace message
08:02:35 <applicative> edwardk, well the topic seems to merit growing on one
08:02:54 <edwardk> quicksilver: if you want to see one in use, check the haskell-cafe for my finally tagless pi calculus
08:03:00 <edwardk> i posted it yesterday
08:03:10 <quicksilver> edwardk: pi calculus brings me out in hives
08:03:20 <edwardk> quicksilver: haha then maybe you should avoid my post ;)
08:03:22 <sclv> tao_ you want fmap, not bind
08:03:29 <sclv> and fmap can also be written <$>
08:03:30 <applicative> same here, but the letter did bring back interest in hoas
08:03:37 <sclv> so you get input <- toString <$> getSomething
08:03:40 <applicative> pi calculus freaks me out
08:04:18 <applicative> tao_ like the familiar    arg <- head <$> getArgs
08:04:34 <sclv> alip: don't shadow your names
08:04:58 <sclv> let ui' = ui {...}
08:05:16 <tao_> oh ok
08:05:17 <tao_> thanks
08:05:18 <sclv> otherwise it ignores the previous ui and just defines the new one recursively in terms of itself
08:05:33 <alip> sclv: oh thanks
08:06:04 <tao_> sclv: what should I import for that?
08:06:19 <tao_> Control.Monad?
08:06:25 <applicative> tao Control.Applicative !!
08:06:56 <tao_> thanks
08:07:00 <applicative> tao Control.Applicative ((<$>),(<*>)) 
08:07:06 <tao_> yeah sorry
08:07:11 <tao_> i better hoogle next time
08:07:42 <applicative> tao_, then you can really go to town.  (I was just being silly with the !!)
08:08:36 <sclv> anyone have a good reference on basic computer algebra to point me to (preferably online).
08:09:12 <sclv> just looking for some pointers on the standard way to perform reasonable simplifications on big expressions.
08:09:13 <ksf> x computers + 0 computer = x computer?
08:09:23 <ksf> they form just a vanilla monoid.
08:09:38 * sclv rolls eyes
08:09:53 <edwardk> sclv: figured out the number of elements in each level of my trie
08:10:12 <sclv> edwardk: I saw. cool! figures there'd be binomial involved.
08:10:17 <applicative> tao_, then you can write things like ( (++) <$> readFile "a.txt" <*> readfile "b.txt" ) >>= writeFile "a+b.txt"
08:10:19 <edwardk> i had the sign flipped above
08:10:29 <tao_> heh :)
08:10:32 <edwardk> its actually: (n + k) choose k
08:10:42 <tao_> hm
08:10:50 <tao_> how can i deal with errors like this: http://pastebin.com/rT5hm61P
08:10:59 <tao_> besides writing Prelude.dropWhile
08:11:26 <edwardk> so members n k = (n + k) * members (n - 1) k `div` n -- also holds giving me a nice recurrence when i flip it around
08:11:28 <sclv> import qualified Data.Bytestring as B
08:11:31 <sclv> is how folks usually do it.
08:12:17 <applicative> tao_ if you won't be using Prelude.dropwhile you can import Prelude hiding (dropWhile)  but then there are all the other BS replicas of Prelude functions
08:12:32 <applicative> tao, I meant, apart from what sclv said.
08:14:04 <tao_> so qualified will five B preferennce?
08:14:29 <tao_> but I actually operate on Strings, so I should do import qualified Prelude?
08:14:30 <sclv> qualified means that everything in the library now needs to be called B.whatever when you use it
08:14:35 <tao_> oh
08:14:35 <tao_> ok
08:14:37 <tao_> got it
08:14:38 <tao_> thanks
08:15:14 <ksf> we need a split prelude
08:15:16 <applicative> tao_, basically you qualify whatever you use least... 
08:15:56 <applicative> ksf, that's a good idea.  import Prelude.Inevitable, import Prelude.FrequentlyStolen
08:16:50 <Jafet> import Preface; import Foreword; import Author'sNote as Yeesh
08:17:15 <applicative> import ListOfDiagrams
08:22:21 <kmc> i don't agree with "qualify whatever you use least"
08:22:36 <kmc> qual. is a good signal to readers that you're using a "non-standard" version of this name
08:23:10 <kmc> if you use BS.tail everywhere and Prelude.tail nowhere you might still qualify BS
08:24:26 <kmc> there are languages where qualified imports are the default and unqualified imports are heavily frowned upon
08:24:38 <ksf> another possibility is to use ListLike
08:25:30 <ksf> using namespace Std;
08:26:03 <kmc> ;P
08:26:08 <Twey> kmc: *nod*
08:26:29 <Twey> ‘import random’ ;)
08:26:49 <kmc> one could argue that Python programming requires more discipline with namespaces because static types would catch most clashes
08:27:10 <ksf> one could argue that dynamic typing is a bad idea in general
08:27:20 <Twey> That's so, but doesn't change the fact that they manage to do well enough with it
08:27:29 * hackagebot delimited-text 0.1.7 - Parse character delimited textual data  http://hackage.haskell.org/package/delimited-text-0.1.7 (StefanKersten)
08:27:31 <kmc> one could argue that, and one would find a sympathetic audience here ;)
08:27:56 <kmc> Python is a great language for programs which are obviously correct
08:28:02 <kmc> which rules out anything longer than about 50 LoC
08:28:29 <chrisdone> most people write code and then observe the result rather than thinking about it regardless of language
08:28:36 <kmc> yeah
08:29:03 <kmc> and i do think dynamic type errors are frequently more helpful than static type errors
08:29:10 <kmc> presuming you actually hit the error in a clean way
08:29:42 <chrisdone> why are they more helpful?
08:30:07 <kmc> because (in the ideal case) you get a precise counterexample
08:30:16 <kmc> "the program actually went wrong, and here's why"
08:30:21 <chrisdone> you get that at compile time?
08:30:27 <sclv> precise counterexamples are misleading
08:30:37 <kmc> no
08:30:40 <sclv> they encourage special case thinking
08:30:56 <kmc> you get it at runtime, which is why i said "presuming you actually hit the error in a clean way"
08:31:31 <kmc> there's also the problem where your root type error is not exception-causing, and you get ill-typed data hanging around in some container for a while, and then your end result exception is useless
08:31:38 <kmc> like "Not an exception: 'z'"
08:31:42 <chrisdone> maybe i just don't have any idea what you mean by a dynamic type error and a static type error
08:31:44 <kmc> great, where did it come from
08:32:07 <kmc> chrisdone, when you run a Python program, sometimes it throws an instance of "TypeError", with a traceback
08:32:12 <kmc> that'd be a dynamic type error
08:32:19 <kmc> "dynamic typing" does not mean "no type system"
08:32:27 <chrisdone> ya think?
08:32:28 <kmc> much as you might hear that hanging out here ;)
08:32:31 <Ke> runtime errors are awesome with modern graphical user environments that are designed to hide any useful error messages
08:32:37 <kmc> haha Ke
08:33:06 <arw_> Ke: or with typical python programs that just present an end-user with a useless stacktrace.
08:33:09 <applicative> kmc, I agree that 'qualify what you use least" is best read as "qualify what is used least"; it depends how deranged your module is....
08:33:22 <chrisdone> what's an example of a python type error?
08:33:37 <kmc> 2 + 'x'
08:33:45 <kmc> TypeError: unsupported operand type(s) for +: 'int' and 'str'
08:34:01 <chrisdone> wat
08:34:02 <kmc> [str(x) for x in 2]
08:34:04 <arw_> when some object does not have the methods you call on it.
08:34:07 <kmc> TypeError: 'int' object is not iterable
08:34:11 <applicative> man, what a savage interpreter that is!
08:34:13 <chrisdone> what's an example of a more helpful error?
08:34:15 <kmc> this is a big difference between Python and Perl
08:34:27 <kmc> Perl will just come up with a contrived way that the operation makes sense, and do it
08:34:35 <thaostra> perl can give..interesting results
08:34:48 <chrisdone> > 2 + 'x'
08:34:49 <kmc> in this case it will interpret 'x' as an int, giving 0, and add it to 2
08:34:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:34:49 <lambdabot>    arising from the literal `2...
08:34:50 <applicative> ... like lambdabot ..
08:35:06 <applicative> > 2 2
08:35:07 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:35:07 <lambdabot>    `GHC.Num.Num t' arising f...
08:35:26 <chrisdone> static types give the same results
08:35:29 <orlandu63> does perl really implicitly convert scalars to arrays?
08:35:30 <chrisdone> you said "dynamic type errors are frequently more helpful than static type errors"
08:35:34 <hpc> applicative: that works when you constrain the types because Num has wonky instances here
08:35:36 <applicative> > 2 'a'
08:35:37 <lambdabot>   2
08:35:38 <emilmeln> Where can I see fusion results? Only in the Core?
08:35:39 <chrisdone> what's an example of one that's more helpful than static errors?
08:35:59 <zygoloid> if there's no type system, a language /can't/ be dynamically typed
08:36:04 <kmc> chrisdone, i don't have an example ready
08:36:12 <chrisdone> "frequently"? :p
08:36:15 <kmc> btw errors about Num frequently *are* misleading to beginners
08:36:22 <chrisdone> beginners are irrelevant
08:36:25 <kmc> that's great
08:36:29 <Blkt> are we?
08:36:34 <chrisdone> for this discussion, yes
08:36:46 <kmc> not as i phrased it
08:36:47 * applicative thinks he must still be a beginner, since he's always in trouble with Num
08:36:47 <hpc> we are avoiding success at all costs, remember
08:36:49 <chrisdone> unless you want to talk about a language's power in terms of how newbies can learn it
08:36:53 <arw_> yes. if you design a language strictly for beginners you get something stupid like BASIC...
08:36:58 <chrisdone> in which case PASCAL is pretty good i hear
08:37:12 <hpc> oh god, PASCAL
08:37:24 <flux> pascal's great!
08:37:28 <hpc> i told my boss i was learning Haskell, he said "PASCAL? are you nuts?"
08:37:34 <thaostra> pascal, basic, php..
08:38:06 <Blkt> I don't mean to talk about language's power in terms of simplicity of learning, but silly error messages are annoying no matter the skill
08:38:20 <chrisdone> it's not silly
08:38:26 <yitz> hi Blkt did you solve your issue about exhaustive patterns?
08:38:28 <chrisdone> it makes perfect sense O_O
08:38:46 <Blkt> btw, Pascal sucks for learning imo
08:38:52 <thaostra> pascal is shite
08:38:53 <flux> well, error messages are hard. maybe once the compiler produces perfect code people get on to the error messages problem?-)
08:39:03 <Blkt> yitz: no I didn't, connection at University kept failing
08:39:15 <chrisdone> GHC's error messages are fantastic
08:39:18 <Blkt> yitz: so I couldn't read the channel
08:39:19 <yitz> Blkt: yeah I saw you drop out :)
08:39:21 <chrisdone> tonnes of suggestions
08:39:25 <kmc> ha chrisdone 
08:39:29 <quicksilver> silly error messages are indeed, annoying.
08:39:36 <quicksilver> GHC's error messages aren't silly, though.
08:39:43 <quicksilver> what they are is "not clever enough"
08:39:49 <kmc> ghc makes some suggestions that are almost always wrong
08:39:52 <quicksilver> but it's extraordinarily hard to make them cleverer.
08:40:00 <kmc> like "Probable fix: add an instance for (Num (a -> b))"
08:40:08 <kmc> for a trivial syntax mistake
08:40:27 <Blkt> they pinpoint the location of the problem very well, but still is hard to find functions to solve it, and they don't help to find it
08:40:40 <thaostra> gcc has some pretty straightforward error messages
08:40:41 <yitz> GHC's error messages presuppose quite a bit of understanding about types and type inference. And sometimes they make you think very hard.
08:41:03 <emilmeln> > let f Nothing = return 0 in f (Just 'a')
08:41:04 <chrisdone> maybe someone could write a newbie layer over GHC errors
08:41:05 <lambdabot>   No instance for (GHC.Show.Show (m t))
08:41:05 <lambdabot>    arising from a use of `M2541286527...
08:41:08 <Blkt> few days ago I was having problems with numeric stuff and it kept telling me "Probable fix: add an instance for (Integral Fractional)" or something like that
08:41:10 <emilmeln> > undefined
08:41:11 <lambdabot>   *Exception: Prelude.undefined
08:41:11 <p_l> thaostra: especially when it's a template error that originates deep in internals of GCC? :D
08:41:13 <chrisdone> ghc -newbie
08:41:20 <jcreigh> in fairness, gcc's job is more straightforward than GHC's job. :)
08:41:24 <thaostra> oh yes, especially =D
08:41:29 <kmc> but not g++'s
08:41:36 <kmc> chrisdone, see helium
08:41:40 <Blkt> ghc --newbie mode => need
08:41:43 <zygoloid> GHC's type error messages are a bit "something went wrong, and here's where i first noticed, now you have to work backwards to figure out how i reached this contradiction"
08:41:48 <thaostra> isn't helium for newbies?
08:41:57 <p_l> it wasn't fun finding that parts of G++ are actually template headers...
08:41:57 <chrisdone> kmc: or not
08:42:02 <kmc> <chrisdone> maybe someone could write a newbie layer over GHC errors
08:42:24 <Blkt> I'd be happy to test it
08:42:53 <quicksilver> GHC developers would happily accept patches to improve the error messages
08:42:57 <quicksilver> no need for a separate newbie mode
08:43:00 <quicksilver> it's just a hard problem.
08:43:02 <quicksilver> Please, try it.
08:43:09 <quicksilver> If you produce something better, we'll all be grateful.
08:43:09 <kmc> right, Helium makes major changes to the language itself
08:43:35 <chrisdone> i think it needs to make assumptions about what you're trying to do that would be annoying if you knew what you were doing
08:43:48 <thaostra> i'm sure any sane developer for an open source compiler will happily accept patches, as it is the spirit of foss
08:43:58 <thoughtpolice> my favorite GHC error: 'my brain just exploded'
08:44:07 <quicksilver> for example, the error message "Probable fix : Add a Num instance for (a->b)" is, inded, not a good suggestion.
08:44:12 <thaostra> thoughtpolice: haha wut
08:44:15 <quicksilver> but on the other hand
08:44:21 <chrisdone> it's a general one
08:44:24 <quicksilver> "Probable fix : Add a Show instance for Foo"
08:44:28 <applicative> quicksilver, the messages are hard to read, but still it's a complete miracle that they do as much as they do.
08:44:28 <quicksilver> is an excellent suggestion.
08:44:42 <quicksilver> What heuristic would you suggestion to disambiguate those two?
08:44:43 <thoughtpolice> thaostra: you can trigger it by tryinig to unpack an existentially quantified constructor in a 'let' binding
08:44:44 <kmc> but not "Add a Show instance for (a -> b)"
08:44:50 <kmc> it gets tricky
08:44:54 <thaostra> ah
08:45:13 <thoughtpolice> i.e. data Foo = Foo (forall a. Show a => a), then trying to do 'let Foo x = ...' in a pattern match
08:45:16 <chrisdone> stuff like this making it easier for newbies can ruin good things
08:45:24 <chrisdone> like monad comprehensions
08:45:34 <quicksilver> well, yes, that was a terrible decision in hindsight
08:45:35 <kmc> thoughtpolice, why is that forbidden?
08:45:39 <quicksilver> and the whole MonadZero debacle
08:45:49 <thoughtpolice> kmc: ask #ghc
08:45:57 <quicksilver> kmc: because let is recursive, and so doesn't introduce a clean scope
08:46:03 <Blkt> quicksilver: how does it work with suggestion? how are they "evaluated"?
08:46:10 <emilmeln> Why non-exaustive pattern produces error location, and undefined doesn't?
08:46:13 <kmc> ok
08:46:21 <quicksilver> kmc: extensials can only be unpacked by case because case has a good boundary between inside and outside
08:46:27 <kmc> emilmeln, because "undefined" is an ordinary value defined in the Prelude
08:46:30 <kmc> so it has one location
08:46:40 <kmc> it could be special-cased though, like "assert"
08:46:58 <quicksilver> chrisdone: still, smart people get things wrong sometimes, especially when they're in committees ;)
08:47:17 <quicksilver> it wasn't as clear then that 'fail' was such a mistake as it is clear now.
08:47:19 <chrisdone> i'm glad i'm not smart enough to get into a committee :p
08:47:33 <thaostra> i'm a little confused as to what monads actually /are/.  yet another haskell tutorial doesn't seem to help me understand them.
08:47:35 * hackagebot CSPM-Interpreter 0.3.0.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.3.0.0 (MarcFontaine)
08:47:43 <zygoloid> i saw a great paper a while back which suggested normalizing a proof of a type error to identify the possible locations of errors in the code
08:47:51 <thaostra> does anyone have a good resource to explain them
08:47:53 <kmc> thaostra, did you read Typeclassopedia?
08:48:03 <thaostra> not yet, but i will look into it
08:48:08 <chrisdone> thaostra: that's completely common. the point of monads eludes newbies no end. Real World Haskell has a chapter dedicated to it
08:48:14 <kmc> thaostra, a monad is simply any type in the "Monad" type class
08:48:15 <emilmeln> kmc: But what about if running program crahses with: *Exception: undefined or *Exception: empty list? This isn't helpful.
08:48:33 <kmc> emilmeln, i agree it's a bad situation.  i explained why it is how it is
08:48:35 <applicative> thaostra, read Typeclassopedia.  Maybe you are worrying too soon?  
08:48:36 * hackagebot CSPM-cspm 0.2.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.2.0.0 (MarcFontaine)
08:48:44 <thaostra> uhm...that's actually what gets me confused, because people seem to only talk about them without explaining them
08:49:07 <kmc> thaostra, well, look at the Monad type class
08:49:08 <kmc> @src Monad
08:49:08 <lambdabot> class  Monad m  where
08:49:08 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:49:08 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:49:08 <lambdabot>     return      :: a -> m a
08:49:08 <lambdabot>     fail        :: String -> m a
08:49:14 <kmc> ignore (>>) and fail for now
08:49:26 <thaostra> i shall look into it
08:49:26 <applicative> thaostra, its not exactly a concrete type, but a general operation on types, here m
08:49:44 <applicative> so an example lists, for any type a there's [a], right?
08:49:55 <thaostra> right
08:50:09 <kmc> thaostra, thre's also http://haskell.org/haskellwiki/Monads_as_computation and http://haskell.org/haskellwiki/Monads_as_containers
08:50:20 <applicative> another is Maybe, for any type a, there's Maybe a   cases being Nothing and Just a
08:50:23 <thaostra> awesome, thanks
08:50:45 <applicative> these are general operations on the types, general functions from type to type.
08:51:12 <chrisdone> thaostra: the basic thing is generalising a common problem. all types of numbers support arithmetic, so we make a class Num with arithmetic methods in it and then define instances for Double, Float, Integer, etc. the Monad class is the same thing, you'll find there are a bunch of things you end up doing that are all basically the same idea of the monad methods
08:51:15 <thaostra> i currently understand the imperative and object oriented paradigm because i come from languages like c and ruby, but this functional programming is just so different
08:51:17 <applicative> another is IO  for type a there's actions that might return things of that type
08:51:36 <kmc> thaostra, "paradigms" are largely a myth
08:51:46 <thaostra> they are just different means to an end
08:52:03 <kmc> thaostra, Haskell has natural ways to do imperative and object-oriented programming too
08:52:18 <thaostra> right, just like ruby can also do functional programming
08:52:19 <emilmeln> But not subtyping.
08:52:19 <applicative> chrisdone, I don't know how much help the Num case is.   The miracle is that the class system introduced for things like Num turned out to be so astonishing as to admit Functor, Monad, etc
08:52:42 <Blkt> kmc: by means of monads and do-comprehension, right?
08:53:06 <droid2> Hi
08:53:48 <kmc> Blkt, well, it's natural to do imperative programming by building values that represent actions to perform
08:54:10 <applicative> thaosta, another example of a general operation on the typesystem is one that, for each type a, makes the type (String,a)
08:54:33 <kmc> Blkt, that's not inherently "monadic"
08:54:34 <thaostra> mhm
08:55:12 <applicative> thaostra, under some conditions, such a general operation on the type system   a --->  Blah a   is called a monad
08:55:18 <kmc> Blkt, what happened was, some people realized that some of the operations for working with IO actions would generalize to a lot of other domains (nondeterminism, partial functions, parsers, logic programming, etc)
08:55:28 <kmc> and "Monad" is the name for the generalization over all of that
08:55:43 <Blkt> I see
08:55:48 <applicative> basically when you can crash  Blah (Blah (Blah a) ) things down to Blah a things
08:55:48 <kmc> in the same way "Num" generalizes all things with a "numeric structure" of addition, multiplication, etc.
08:55:49 <thaostra> hm i think i will need to read the resources listed to have a better understanding
08:55:56 <ksf> and OO has virtually nothing in common with monads
08:56:11 <ksf> you do objects by taking fixpoints of records
08:56:15 <thaostra> what about OO programming
08:56:16 <kmc> but you could define a type and totally new operators for (+) and (*), and never notice that it *could* be an instance of Num
08:56:24 <Blkt> thaostra: Programming in Haskell has been very helpful to me, you should read it
08:56:26 <kmc> similarly people quite frequently define new types and don't notice that they're monads
08:56:50 <Blkt> thaostra: if you didn't
08:56:50 <applicative> thaostra, have you looked at Learn You a Haskell.  It takes things in the right order I think.  ---Hasnt even gotten to monads yet...
08:57:10 <thaostra> yes i have, but it feels stale. dunno why
08:57:19 <ksf> thaostra, http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html
08:58:00 <kmc> note that OO programming in Haskell does *not* imply that you use "class" everywhere
08:58:07 <kmc> it is a common mistake of beginners to overuse type classe
08:58:13 <thaostra> right now ruby is the most enjoyable to program in, but i feel like cross training in other languages
08:58:21 <thaostra> i actually don't use classes that must
08:58:21 <applicative> thaostra, Programming in Haskell is a bit textbookish, but it's good. 
08:58:42 <thaostra> yeah
08:58:53 <Raynes> I never used classes much. Mostly because I didn't have much of a clue what polymorphism was when I was learning Haskell. Was kind of my first real language.
08:59:08 <Raynes> Type-classes, that is.
08:59:12 <chrisdone> thaostra: LYAH is new as lego. the descriptions and tutorials help but in the end, just like trying to figure out what a class is and inheritence and polymorphism in your object oriented studying, you have to write some code and experience the necessity for such a thing
08:59:29 <chrisdone> otherwise it's too conceptual and not concrete
08:59:51 <ksf> lego is quite old...
08:59:57 <applicative> I think fmap is perfectly concrete
09:00:08 <ksf> 1940.
09:00:10 <thaostra> i do write code to understand something new, otherwise there is no point in learning
09:02:21 <thaostra> so why did you learn haskell
09:02:21 <chrisdone> e.g. writing case foo of Just x -> (case bar x of Just y -> Just (y * y); Nothing -> Nothing); Nothing -> Nothing
09:02:21 <chrisdone> is a huge pain in the ass, whereas
09:02:21 <chrisdone> foo >>= (\x -> bar x >>= (\y -> return y * y))
09:02:21 <chrisdone> is much easier
09:02:50 <thaostra> more compact code to be sure
09:02:53 <applicative> thaostra, do you have any trouble reading 
09:02:54 <applicative> > map (+ 1) [2,3,4]
09:02:55 <lambdabot>   [3,4,5]
09:03:06 <applicative> or
09:03:08 <applicative> > map (ord) "abc"
09:03:08 <lambdabot>   [97,98,99]
09:03:25 <applicative> if so you can generalize to 
09:03:31 <applicative> > fmap (ord) "abc"
09:03:32 <lambdabot>   [97,98,99]
09:03:39 <applicative> > fmap (+ 1) [2,3,4]
09:03:40 <lambdabot>   [3,4,5]
09:03:44 <thaostra> so you're printing the ascii values of abc?
09:03:49 <applicative> yeah
09:03:54 <thaostra> ah
09:04:00 <applicative> thats ord maps a Char to Int
09:04:05 <applicative> @type ord
09:04:06 <lambdabot> Char -> Int
09:04:36 <applicative> but once you see the idea of mapping, why not generalize
09:04:47 <thaostra> ruby does something similar like ?a, though other methods and can even be expressed in blocks
09:04:49 <applicative> > fmap (ord) ("abc", 'a')
09:04:50 <lambdabot>   ("abc",97)
09:05:01 <applicative> > fmap (+1) ("abc", 1)
09:05:02 <lambdabot>   ("abc",2)
09:05:09 <ksf> > toUpper . "amazing"
09:05:10 <chrisdone> thaostra: yeah. and you'd probably come up with it yourself at some point as grab the value from just and apply some function to it or return nothing, e.g. applyToJustOrNothing :: Maybe a -> (a -> Maybe b) -> Maybe b
09:05:11 <lambdabot>   "AMAZING"
09:05:12 <emilmeln> Functor type class is obvious and really intuitive, but Monad doesn't.
09:05:19 <thaostra> i really enjoy the power of blocks in ruby, something which python lacks
09:05:38 <applicative> > fmap (toUpper) ("abc", 'a')
09:05:39 <lambdabot>   ("abc",'A')
09:05:54 <hpc> :t toUpper
09:05:54 <lambdabot> Char -> Char
09:06:04 <ksf> toUpper . ("foo",'b')
09:06:06 <ksf> > toUpper . ("foo",'b')
09:06:07 <lambdabot>   ("foo",'B')
09:06:21 <hpc> oh right, because (.) is fmap in lambdabot
09:06:23 <applicative> emilmeln, yes, but I think if you get used to functor first, it's not as hard
09:06:48 <chrisdone> thaostra: but seeing as
09:06:48 <chrisdone> thaostra: Maybe a -> (a -> Maybe b) -> Maybe b
09:06:48 <chrisdone> thaostra: matches up with
09:06:48 <chrisdone> thaostra: m a -> (a -> m b) -> m b
09:06:51 <chrisdone> thaostra: it's more generic to define a Monad instance for the Maybe type instead of having separate functions for every type, just have (>>=), etc.
09:07:00 <emilmeln> applicative: IMO, the Typeclassopedia Way is the best.
09:07:01 <thaostra> the maybe monad?
09:07:07 <chrisdone> thaostra: yeah
09:07:16 <Blkt> applicative: how should I declare a function similar to applyToJustOrNothing that looks out for a precomputed result on an array and if it fails, computes it? (memoization)
09:07:21 <thaostra> i seem to remember the various types of monads
09:07:29 <chrisdone> thaostra: you can see Just :: a -> Maybe a is the same as return :: a -> m a
09:07:37 <thaostra> right
09:07:52 <ksf> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
09:07:52 <lambdabot> f a b =
09:07:53 <lambdabot>     case a of
09:07:53 <lambdabot>     Nothing -> Nothing
09:07:53 <lambdabot>     Just c -> b c
09:07:58 <Blkt> @src applyToJustOrNothing
09:07:58 <lambdabot> Source not found. My brain just exploded
09:08:02 <Blkt> lol
09:08:03 <thaostra> is there some printed book for this like oreilly media?
09:08:16 <ksf> see even a computer can do that one.
09:08:32 <thaostra> i only see a few, and the best appears to be by oreilly
09:08:33 <chrisdone> Blkt: it would be:
09:08:33 <chrisdone> applyToJustOrNothing Nothing f = Nothing
09:08:34 <chrisdone> applyToJustOrNothing (Just a) f = f a
09:08:36 <applicative> Bikt, yipe.
09:09:42 <Blkt> @src Maybe
09:09:42 <lambdabot> data Maybe a = Nothing | Just a
09:09:49 <Blkt> mmm
09:10:25 <chrisdone> @type applyToJustOrNothing
09:10:26 <lambdabot> forall t a. Maybe t -> (t -> Maybe a) -> Maybe a
09:10:39 <chrisdone> > applyToJustOrNothing (Just 5) (\number -> Just (number * 2))
09:10:40 <lambdabot>   Just 10
09:10:41 <applicative> > let applyToJustOrNothing Nothing f = Nothing; applyToJustOrNothing (Just a) f = Just (f a) in applyToJustOrNothing (Just 'a') ord
09:10:42 <lambdabot>   Just 97
09:10:46 <chrisdone> > applyToJustOrNothing Nothing (\number -> Just (number * 2))
09:10:47 <lambdabot>   Nothing
09:11:39 <chrisdone> applicative: i'm trying to show (>>=) here not fmap
09:11:42 <applicative> wait, I'm using a different def. 
09:11:51 <applicative> chrisdone, i see
09:11:53 <thaostra> so if i were to learn and maybe master haskell, how useful would it be for web development or application programming?
09:12:45 <chrisdone> thaostra: this is written in haskell: http://productsforhair.co.uk/
09:12:45 <chrisdone> thaostra: so is this: http://tryhaskell.org and this http://hpaste.org
09:12:53 <chrisdone> thaostra: but in terms of usefulness, it's still green at the moment
09:13:13 <chrisdone> there are *a lot* of new libraries coming out every month for web dev
09:13:35 <thaostra> tryhaskell looks like tryruby. i wonder
09:13:59 <chrisdone> yeah, i shamelessly stole the idea
09:14:01 <applicative> wow, http://productsforhair.co.uk/ is a bit pink.  More pink than green.
09:14:11 <chrisdone> applicative: well i didn't design it :)
09:14:20 <chrisdone> i meant that haskell development is green
09:14:33 <applicative> chrisdone, I grasped all these things. 
09:14:54 <thaostra> you stole the idea of having a web based interactive shell?
09:14:56 <chrisdone> there's a lot going on but no specific framework you could point to as The framework, like Rails or Django
09:15:09 <quicksilver> chrisdone: it bears saying again, though.
09:15:12 <chrisdone> though I'd list Happstack, Snap, FastCGI as the main ones
09:15:12 <quicksilver> chrisdone: it really is very pink.
09:15:20 <chrisdone> quicksilver: haha
09:15:20 <kmc> a lot of people would dispute that Django is *the* framework for Python
09:15:21 <quicksilver> outstandingly pink.
09:15:29 <chrisdone> thaostra: yeah, with interactive tutorial
09:15:34 <quicksilver> fastcgi isn't really a framework
09:15:57 <thaostra> so i'm actually speaking with the person who made tryhaskell? heh
09:16:00 <quicksilver> it's just a way of getting a CGI script to run without startup overhead. Still it's plenty good enough for many cases.
09:16:15 <chrisdone> thaostra: haha yeah. need help?
09:16:17 <applicative> thaostra, chrisdone stole the idea of using a web based shell to hoodwink impressionable youth into a programming language cult.
09:16:34 <chrisdone> applicative: shhhh
09:16:38 <applicative> thaostra, shamelessly!!!
09:16:59 <thaostra> haha. i guess copying is the best way to flatter someone
09:17:10 * ksf pulls down the hood of his dark cabal cloak
09:17:15 <applicative> thaostra,  but fortunately, this is the one true programming language cult
09:17:47 * ksf traces an upside down lambda into the air
09:18:02 <thaostra> i sorta think haskellites are a bunch of cultists/math weenies =P
09:18:03 <chrisdone> thaostra: here we're using common lisp and haskell and php for different web services
09:18:14 <thaostra> bleh php
09:18:18 <chrisdone> you don't have to use haskell exclusively to get great use out of it, but the more the better
09:18:44 * hackagebot sifflet 0.1.7 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-0.1.7 (GregoryWeber)
09:18:44 * applicative wonders whether he will get his dark cabal cloak when he finally uploads something to Hackage
09:19:00 <thaostra> i believe reddit switched from lisp to python for performance reasons
09:19:09 <p_l> thaostra: not true
09:19:10 * applicative thinks, yipe theres one now.
09:19:12 <chrisdone> i'm not sure how true that is
09:19:25 <p_l> thaostra: the reasons were multiple and interlocking
09:19:27 <chrisdone> was it something to do with library support or a library was slow?
09:19:42 <applicative> thaostra, so that's why its so horrible now
09:19:42 <p_l> (OS platform clashing with implementation etc.)
09:19:46 <thaostra> i'm sure performance was one of them
09:19:58 <Blkt> chrisdone: for which company do you work?
09:20:08 <chrisdone> it's a strange notion considering how much faster SBCL is than python
09:20:13 <applicative> chrisdone, dont say
09:20:17 <emilmeln> I thought that CL is substantially faster than Python.
09:20:29 <p_l> chrisdone: I think there were issues between SBCL and FreeBSD at that time
09:20:52 <p_l> it wasn't performance per se
09:20:58 <chrisdone> Blkt: a big research company in italy
09:21:03 <Orion-J> Hi all.  I'm writing a cheminformatics package (similar to OpenBabel) and would like to compile with profiling on, but GHC cannot find the regex-tdfa profiling libraries (even though I installed with them on).  Does profiling work OK with regex-tdfa?  If yes, how should I reinstall regex-tdfa so GHC recognizes the profiling libs?
09:21:30 <p_l> more like "many different issues that wouldn't matter in different circumstances conspiring together"
09:21:33 <Blkt> chrisdone: location? Rome? Milan? I'm italian btw
09:21:41 <applicative> Orion-J what does "gtk-pkg list " say
09:21:43 <p_l> chrisdone: do you take interns? :D
09:21:51 <chrisdone> p_l: ah, i heard something like that. it could've been socioeconomic reasons too, i suppose. like, we need to hire some programmers, lispers is hard
09:22:08 <thaostra> so if you were to use one langauge to manage an your site, what would it be?
09:22:09 <chrisdone> p_l: yeah
09:22:17 <thaostra> *mangage your site
09:22:19 <chrisdone> Blkt: up north
09:22:21 <thaostra> *manage
09:22:31 <chrisdone> thaostra: what's the site?
09:22:39 <Blkt> chrisdone: it's nice to hear there's someone in italy using Haskell and Lisp!
09:22:45 <p_l> thaostra: I'd go for CL. Maybe some services in Haskell. Other than that, Erlang.
09:22:48 <thaostra> can be anything, big or small
09:22:59 <applicative> Orion-J , it may be hidden.  Mine seems not to have come with the Haskell platform.   
09:22:59 <thaostra> erlang seems to scale well
09:23:05 <chrisdone> Blkt: yeah! :D
09:23:29 <chrisdone> thaostra: well my blog is produced by a program written in haskell
09:23:35 <applicative> Orion-J ,sorry, i meant   "ghc-pkg"  
09:23:40 <thaostra> what about perl or ruby
09:23:43 <applicative> Orion-J ,sorry, i meant   "ghc-pkg list"  
09:23:44 <p_l> (the reason behind my preference for CL/Erlang for webapps is due to easy runtime redefinition - I'm not averse to using Haskell, though, just don't know it that well)
09:23:51 <chrisdone> if i want stability and security i'll use haskell no questions asked
09:24:22 <chrisdone> if i want to rapidly pump something out i know my colleague can whip things up in common lisp very easily
09:24:26 <Orion-J>    regex-base-0.93.1    regex-compat-0.92    regex-posix-0.94.1    regex-tdfa-1.1.2 
09:25:06 <chrisdone> p_l: i agree for a web site it needs to support updating of the program code
09:25:40 <chrisdone> when i get round to it i'm thinking of cominbining Snap with hint to compile changed pages and dynamically load them ala .NET
09:25:53 <p_l> chrisdone: For stability I'd probably also check out Erlang OTP, the VM is rock-solid... and it can be easily meshed with other parts (like connecting a Haskell or CL app as an Erlang process)
09:26:35 <chrisdone> yeah i was thinking about how erlang would make a nice server for a game someone i know is working on
09:26:59 <p_l> I considered once using Erlang for interconnect layer and having various parts written in CL and Haskell depending on what I wanted to do
09:27:15 <Orion-J> applicative, just regex-tdfa-1.1.2.  I also reinstalled all its dependencies with profiling on.
09:27:17 <chrisdone> p_l: what's your experience of erlang's stability?
09:28:02 <applicative> Orion-J, curses, I'm clueless.  
09:28:20 <p_l> chrisdone: for now not much, haven't had much chance to tinker with it, however a big chunk of it comes from defensive programming being ingrained in framework and "culture", I'd say.
09:28:43 <chrisdone> p_l: regarding haskell, i've written hmm four long-running services that have never had a runtime error. tryhaskell for example has been running for about two months
09:28:45 <p_l> chrisdone: it really makes it easy though to recover from crashes (the distributed computing support is *sweet*)
09:28:56 <chrisdone> p_l: aye
09:29:00 <p_l> chrisdone: I kinda expect that from Haskell :D
09:29:10 <Orion-J> Thanks applicative.  Just want to know if I should keep beating on this, or fly "blind" without profiling for a while longer.
09:29:12 <chrisdone> catch all exceptions, handle all pattern cases
09:29:42 <chrisdone> p_l: i like that it scales across machines easily
09:29:52 <p_l> I do plan on learning more Haskell but so far I was keeping to CL
09:30:04 <dayz> is the technique for checking whether a term is defined recursively 'curse checking'?
09:30:28 <chrisdone> occurs check?
09:30:43 <dayz> oh right
09:30:43 <dayz> thanks
09:31:26 <p_l> chrisdone: are you per chance working for CREATE-NET?
09:31:28 <chrisdone> p_l: i was a smug lisp weenie about there years ago. the state of lisp's libraries weren't good (like, a stable socket library with documentation) and that's what drove me away. i hear that's really improved
09:31:59 <Blkt> chrisdone: do you know cl-io project?
09:32:02 <p_l> chrisdone: the library situation isn't that bad, but *finding* them is harder
09:32:04 <chrisdone> nope
09:32:20 <sclv> Orion-J you can always really hack things and just unpack the regex-tdfa package into your dev directory :-)
09:32:21 <chrisdone> p_l: hmm. there's no central library place yet? it was cliki last i checked
09:32:22 <p_l> not to mention unchecked treasure troves like CMU AI repo
09:32:32 <p_l> chrisdone: Cliki is in kinda limbo...
09:32:35 <Blkt> chrisdone: you should check it out if you're still interested in socket stuff for Common Lisp
09:32:38 <chrisdone> in what sense?
09:32:43 <chrisdone> Blkt: thanks
09:32:54 <sclv> alternately, if you didn't do a forced unregister before the reinstall, that might might possibly help
09:33:30 <chrisdone> i'm looking forward to hackage2
09:33:36 <p_l> cl-user.net is a directory site, but Cliki needs a big refactoring, and there are tries to get a better package management system going (my big inspiration is Cabal and RubyGems, no matter how many issues other have with them). So far I directed newbies to clbuild.
09:34:13 <chrisdone> hmm. that's what the guy here uses, clbuild. i ran it on my machine to install his server, it was good
09:34:27 <Blkt> chrisdone: errata corrige: iolib
09:34:38 <chrisdone> hehe, ok
09:34:51 <p_l> Blkt: iolib is good on *nix, but badly documented outside of socket api
09:34:51 <Orion-J> sclv, Might eventually do that as a learning experience.   I'm strangely not able to even individually profile tagged functions that do not use anything from the regex-tdfa module.  Basically, will not compile with '-prof'.
09:35:21 <p_l> Blkt: Also, unlike IOlib developers, I do consider a need for usocket-on-iolib compat layer :D
09:35:31 <p_l> (or adding iolib support to hunchentoot)
09:36:01 <chrisdone> one thing i want to do on hackage is embed a little haskell console for that given library, so you can play with it
09:36:22 <sclv> right -- I have indeed compiled regex-tdfa with profiling in the past and profiled things using it.
09:36:22 <Blkt> p_l: I'm not very informed about it, the developer is just a friend of mine irl :D
09:36:37 <Orion-J> chrisdone - "embed a little haskell console for that given library, so you can play with it"  That would be fan-tastic!
09:37:09 <sclv> You might already know this -- but the best way to turn on profiling is to make sure your ~/.cabal/config file has the library-profiling: True line.
09:37:17 <sclv> That way all your packages will always install with profiling
09:37:29 <chrisdone> Orion-J: yeah!
09:40:35 <quicksilver> chrisdone: wow.
09:40:44 <quicksilver> chrisdone: you could extend that and have interactive documentation.
09:41:17 <chrisdone> quicksilver: keep talking
09:42:29 <chrisdone> interactive documentation sounds fascinating
09:43:24 <quicksilver> chrisdone: well the documentaiton could encourage you with examples to try
09:43:28 <quicksilver> chrisdone: and a console in which to try them
09:43:46 <quicksilver> chrisdone: with some preparatory definitions all set up (presumably visible in the explanatory text)
09:43:52 <chrisdone> ahhh good idea!
09:44:18 <quicksilver> suddenly hackage would be part of the 22nd century?
09:44:29 <chrisdone> haha, indeed
09:46:13 <applicative> chrisdone, it might inspire people to install simple illustrative modules with main = blah blah, so we can figure out how to apply the lib
09:46:24 <gs4> hi, anyone have any idea why my program would just stop working past a certain input size? it seems like the input stream just gives up and returns [] if theres too much input
09:46:28 <applicative> chrisdone, I mean, inspire them to include such things
09:47:10 <cwraith> gs4, the only way anyone could answer that is by seeing the relevant code
09:47:21 <applicative> gs4, you can paste it  hpaste.org
09:47:26 <Gracenotes> hm, can the size of one's monad transformer stack affect performance in particular?
09:47:30 <gs4> thanks, will do
09:47:58 <chrisdone> applicative: indeed. i often experiment with a library in ghci after reading the types on hackage, and before deciding it's what i need
09:48:08 <gs4> here it is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26070#a26070
09:48:27 <Gracenotes> given that happstack already has 5 layers.. don't think I'm going to add another one..
09:48:35 <gs4> its done this to me before in another app i was writing too i never figured it out... 
09:48:38 <chrisdone> Gracenotes: i've heard from people in here that it's not so bad, but if it is, you can convert it to CPS-style and get a performance boost. i suppose you need profiling 
09:49:25 <Gracenotes> then again, most of them are newtypes
09:49:26 <sclv> Gracenotes: I wouldn't worry about it until you need to worry about it.
09:49:45 <Gracenotes> always lots to carry around
09:49:56 <chrisdone> Gracenotes: the good news is if you're actually getting a performance hit, you can just define instances as a flat plane rather than a stack
09:50:10 <sclv> Yes bigger monad stacks are slower, but a small constant overhead to dispatch won't be your bottleneck.
09:50:56 <ksf> most stacks are going to consist of newtypes, only
09:51:36 <cwraith> ksf, that's not true.  The transformer's version of >>= will have to call the inner monad's version.  That's overhead.
09:51:39 <ksf> and yes, codensity can help
09:51:48 <ksf> and those can be inlined
09:52:01 <cwraith> that doesn't change the fact that it's doing more work.
09:52:10 <opqdonut> well there's more features
09:52:13 <ksf> which is what happens if you have more features
09:52:42 <chrisdone> start from ContT and love life
09:52:52 <opqdonut> has anybody benchmarked, say RWST versus a combination of ReaderT, WriterT and StateT
09:53:01 <c_wraith> gs4: what function is returning less than you'd expect?
09:53:22 <chrisdone> opqdonut: i haven't seen a benchmark for that but it's an interesting idea
09:53:25 <gs4> ah... nvm for the moment
09:53:33 <gs4> sorry :P
09:53:55 <c_wraith> hey, if you figured it out, great. :)
09:53:59 <gs4> it just worked in ghci so i think its something elsewhere in the code; i should be able to find it
09:54:21 <gs4> i had a problem like what i described a while back when writing a spam filter so i thought it had been that again
09:54:59 <Orion-J> applicative - solved my problem!  regex was also installed in user directory and this is the one that was linked.  After rebuilding, -prof works now.
09:55:04 <gs4> the program would work if i gave it an input file less than a certain size, but if i gave it my whole spam corpus itd just return nothing, it was weird.. maybe a bug in the library at teh time though :P
09:56:02 <Gracenotes> okay, it took me a few minutes, but I unwound the Happstack, er, stack
09:56:08 <Gracenotes> Request -> IO (Maybe (Either Response a, FilterFun Response))
09:57:00 <Gracenotes> if anything, I'd more want to be providing extra arguments than adding layers of filtering...
09:58:18 <sclv> You should feel no compunction about throwing your own reader or state layer on top.
09:58:55 <Gracenotes> oh, I haven't unwound it all the way, it's Request -> IO (Maybe (Either Response a, SetAppend (Response -> Response)))
10:03:54 <nixness> BONUS: thanks a gazillion!!! I love how your book doesn't throw in all what's meant to scare me first, helpful tips second
10:04:35 <ksf> of course not, it waits until you're in its trap.
10:05:13 <nixness> heheh ;) maybe, but once you love something, or falling in love, you tend to think of ways to get out of the trap
10:05:35 <nixness> I
10:05:50 <nixness> I want to make a goal for learning this though
10:05:58 <nixness> it's all pretty insightful and beautiful so far
10:06:22 <nixness> but can I, using the libraries available, build say, a simple PONG game?
10:06:29 <exDM69> what? no-one has made a mongodb binding for haskell yet?
10:06:46 <exDM69> sorry, my bad
10:06:48 <exDM69> found it
10:06:51 <nixness> (if so, give me pointers to what's out there that I could use, thanks!)
10:07:10 <exDM69> the search package pages-button in hackage didn't find it. good old ctrl+f found
10:07:35 <gs4> should be doable with the opengl bindings, they're pretty friendly... that being said, it wont be especially easy since managing state might get tricky.. i havent tried to make any games yet in hs
10:08:05 <illissius`> i guess you could do it with gtkhs as well? (haven't tried)
10:08:08 <XniX23> anyone knows if there is a distro with preinstalled xmonad and dzen?
10:08:17 <exDM69> gs4: good opengl apps avoid state anyway. and there's less of it in opengl 3+
10:08:53 <gs4> exDM69: how would you keep track of gamestate (i.e. paddle and ball positions?) then? i havent worked with opengl in a while really
10:09:27 <exDM69> gs4: basically the opengl state should be modified at once and all data should be kept in GPU buffers and textures
10:09:57 <exDM69> gs4: modify lots of states at once and then do lots of draw commands using that state, repeat
10:10:00 <Blkt> does anyone use Haskell + Emacs on Windows?
10:10:10 <gs4> exDM69: hm.. interesting, ill have to try that sometime
10:10:15 <gs4> Blkt: yep, doing it now
10:10:26 <nixness> Blkt: what's wrong with that?
10:10:39 <exDM69> gs4: haskell is even pretty nice handling raw pointers, which is essential when memory mapping buffers on the GPU
10:10:40 <Blkt> apply: Spawning child process: invalid argument
10:10:51 <jmcarthur> exDM69: there's less of it on an abstract level, but unfortunately the API itself is still very stateful
10:10:56 <Blkt> I keep getting this error and I can't manage to start an interpreter inside Emacs
10:11:14 <gs4> exDM69: if i want to see some code that does all this, are there any reasonably small projects out there that are open source?
10:11:24 <gs4> Blkt: you probably need to add ghci to your path
10:11:49 <nixness> EmacsLisp and haskell walk into a windows machine, the haskell talks to the emacslisp. *close curtain*
10:11:51 <gs4> Blkt: or you can probably manually set the inferior haskell program and give it the full path in your .emacs file, but i dont know the command for that
10:12:13 <Blkt> (setq haskell-program-name "C:/Program Files (x86)/Haskell Platform/2009.2.0.2/bin/ghci.exe")
10:12:14 <exDM69> gs4: I can't really think of one
10:12:19 <Blkt> but I keep getting the error
10:12:26 <exDM69> gs4: you could check out a haskell project called lambdacube
10:12:40 <gs4> exDM69: cool, thanks
10:12:43 <exDM69> gs4: I havn't looked inside, but that might be interesting
10:12:54 <gs4> exDM69: haha, ok, fair enough
10:13:01 <jmcarthur> i'm actually making a purely functional wrapper around buffer objects, etc.
10:13:52 <exDM69> jmcarthur: cool, can I see it?
10:14:00 <gs4> Blkt: you could try taking that out and just sticking ghci's bin folder in your path... seems to work for me, and i could see it having problems with the pathname maybe
10:14:04 <ClaudiusMaximus> i have a few small haskell+opengl projects, they aren't particularly beautiful code though (latest one is: http://gitorious.org/maximus/kjhf , screenshot: http://claudiusmaximus.goto10.org/g/kjhf/kjhf_2010-06-10_pm_5.png )
10:14:07 <jmcarthur> exDM69: unfortunately not yet. not enough progress yet
10:14:23 <gs4> ClaudiusMaximus: nice, thanks
10:14:28 <exDM69> jmcarthur: I've been building one with C++ some time ago, but I abandoned it because writing data structures that represent the graphics pipeline state was too painful in C++
10:14:29 <jmcarthur> exDM69: if it gets anywhere i'll make a bit deal about it
10:14:38 <Blkt> gs4: let me try
10:14:40 <jmcarthur> *big
10:14:55 <ClaudiusMaximus> just the usual GLUT + IORef + record with fields containing the world state
10:15:00 <exDM69> jmcarthur: but haskell might be nice
10:15:30 <jmcarthur> exDM69: well, trying to be *purely functional* is kind of a PITA since i have to make sure things are persistent
10:15:48 <gs4> Blkt: i gotta run, but good luck getting it to work, its definitely doable. Also, check out cygwin if you need a unix cmdline to use cabal and such things from.
10:16:28 <jmcarthur> exDM69: for example, i'm doing something similar to DiffArray to offer fast mutation on buffer objects (when you need it) but still offer the ability to use older versions if you need to
10:17:02 <jmcarthur> i can't imagine that functionality will be used a whole lot, but it's what's necessary to stay pure
10:21:30 <fryguybob> Blkt: I'm not sure the spaces in that path string would work right.  I just have ghci and the bin folder in my path.
10:22:51 <Blkt> fryguybob: it works that way, I just managed to do it
10:23:08 <fryguybob> Blkt: ok
10:23:16 <Blkt> fryguybob: thanks anyway :D
10:34:27 <kmc> with ghc, it's possible to link -fvia-C and -fasm modules into the same program, right?
10:34:30 <wvd> How a -> b -> a is an infinite type?
10:34:40 <kmc> is this true with LLVM as well?
10:34:46 <kmc> wvd, it's not
10:34:58 <kmc> an infinite type is usually expressed by an equation
10:35:02 <wvd> "Occurs check: cannot construct the infinite type: a = [a]", on expr' :: a -> b -> a
10:35:04 <wvd> Oh
10:35:06 <kmc> like «a = Maybe a»
10:35:08 <kmc> is infinite
10:35:14 <kmc> because it would be Maybe (Maybe (Maybe (Maybe ...
10:35:23 <kmc> likewise «a = [a]» is infinite
10:35:58 <kmc> :t let f x = x : x in f
10:35:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:35:59 <lambdabot>       Expected type: [a]
10:35:59 <lambdabot>       Inferred type: a
10:36:21 <zygoloid> a = [a] is actually a pretty interesting type
10:36:42 <kmc> :t In []
10:36:43 <lambdabot> Mu []
10:36:52 <kmc> :t In [In [], In []]
10:36:53 <lambdabot> Mu []
10:37:00 <kmc> :t In [In [], In [In []]]
10:37:01 <lambdabot> Mu []
10:37:16 <wvd> Mmh
10:37:17 <wvd> I see it.
10:37:37 <kmc> so «Mu []» is like an unlabeled rose tree?
10:37:40 <wvd> My accumelator is Char instead of [Char], can't a acc. be a [Char]/String using foldl? I'm giving [] as it's start value.
10:37:51 <kmc> yeah it can
10:37:58 <kmc> :t foldr (++) ""
10:37:59 <lambdabot> [[Char]] -> [Char]
10:38:07 <kmc> :t foldr (:) ""
10:38:08 <lambdabot> [Char] -> [Char]
10:38:23 <wvd>  Ah right
10:38:34 <gwern> '  Judy adapts efficiently to a wide range of populations and data set densities. Since the Judy data structure is a tree of trees, each sub-tree is a static expanse that is optimized to match the "character" or density of the keys it contains. To support this flexibility, in 32[64]-bit Judy there are approximately 25[85] major data structures and a similar number of minor structures. I am going to only describe a few of them so you can infer how ...
10:38:40 <gwern> ... density is synergistic with compression.'
10:38:50 <gwern> 25 datastructures? whew. truly, no one can call judy arrays simple
10:38:54 <gwern> http://judy.sourceforge.net/doc/10minutes.htm
10:39:09 <kmc> the Judy Shop Manual is interesting
10:43:14 <kmc> "In a 64-bit Judy, it would probably require more RAM than exists on this planet to get it to have 8 levels. A binary tree reaches 8 levels with a population of 256. It is truly remarkable to me how much research has been done on binary trees and still being taught."
10:45:03 <jbapple> Well, functional programmers have an excuse
10:45:15 <kmc> oh?
10:45:41 <jbapple> since modifying a tree with high arity in place is much faster than making a new one, even with path sharing
10:46:08 <kmc> yeah
10:46:24 <kmc> but 2 is still probably too low
10:47:04 <jbapple> In his book, Okasaki argues that 4 (IIRC) is ideal
10:47:11 <jbapple> Of course, that was 12 years ago
10:49:24 <kmc> anyone know about combining -fvia-C / -fasm / -fllvm in one binary?
10:49:56 <wvd> How does the compiler know to read it into a Num here? http://codepad.org/JJiIEFLF << read "3" : [] fails in ghci (which is the case on the first element)
10:50:08 <ezyang> I'm reading the FFI spec; has GHC actually implemented cplusplus/dotnet/jvm/stdcall? 
10:50:37 <aavogt> kmc: compile your modules separately, then when you build your main it will reuse the object code from separate codegens?
10:50:39 <ezyang> wvd: Explict type signature I bet. 
10:50:41 <aavogt> at least, that's waht I would try
10:50:51 <wvd> Ah ok
10:51:02 <kmc> aavogt, right, i'm wondering if the object code is compatible
10:51:41 <ezyang> > (read "4" : []) :: (Num a, Read a) => [a] 
10:51:42 <lambdabot>   [4]
10:51:51 <ezyang> > read "4" : [] 
10:51:52 <lambdabot>   [*Exception: Prelude.read: no parse
10:51:57 <ezyang> Note that 
10:52:06 <ezyang> > (read "4" : []) :: Num a => [a] 
10:52:07 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context (GHC.Num.Num a)
10:52:07 <lambdabot>    aris...
10:52:10 <ezyang> is insufficient :-) 
10:52:22 <aavogt> if you go and use the result like list of numbers, it will work out fine
10:52:38 <ezyang> aavogt: Yeah, but now you're giving the inferencer more info :-) 
10:53:07 <aavogt> that type signature there should be inferred, if name the parameter to avoid the monomorphism restriction
10:59:03 <chrisdone> ciao
10:59:50 <gwern> ٩(͡๏̯͡๏)۶
10:59:53 <gwern> shapr is back
11:01:30 <shapr> gwern: greets
11:02:06 <gwern> GREETINGS FELLOW HUMAN
11:02:13 <shapr> How's code?
11:02:28 <ezyang> GREETINGS \o/ 
11:02:34 <shapr> hiya ezyang!
11:02:45 <gwern> I was going to write a clone of Zendo, but have been struck by fear, uncertainty, and doubt as to the best approach
11:03:02 <BMeph> shapr: Haven't you heard? Code is the New Data! ;)
11:03:06 <gwern> should I write a minilanguage using GADTs? or should I just use the ghc api?
11:03:17 <gwern> if I use the ghc api, how should I generate random Haskell code?
11:03:17 <shapr> BMeph: Oh write!
11:03:21 * shapr datas up a new program
11:03:34 <gwern> in bed
11:03:38 <aavogt> BMeph: your a dater?
11:03:44 <shapr> gwern: Can you generate random but legal STG/Core?
11:03:55 <shapr> gwern: Wouldn't TH let you generate random Haskell code?
11:03:55 <gwern> shapr: I think that's too low level for Zendo purposes
11:04:07 <shapr> Ah! Doing inductive gaming?
11:04:12 <gwern> exactement
11:04:41 <shapr> Does this code have the Buddha-nature?
11:04:46 <gwern> in bed
11:04:57 <shapr> Dude, I've been spending a lot of my time in bed lately...
11:05:01 <shapr> I need to get a job.
11:05:08 <gwern> shapr: the domain, for starters, would be [Int]
11:06:23 <gwern> :t unfold
11:06:24 <lambdabot> Not in scope: `unfold'
11:06:28 <gwern> @hoogle unfold
11:06:28 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
11:06:28 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
11:06:28 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
11:06:31 <gwern> @hoogle unfoldr
11:06:31 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:06:31 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:06:31 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
11:06:59 <shapr> gwern: Basically you want an Arbitrary instance that generates Haskell code, yeah? Is there a better option than TH?
11:07:00 <gwern> shapr: unfoldr isn't quite right, but the idea is that each rule is an arg to an unfold
11:07:21 * shapr thinks about that
11:07:43 <shapr> Oh! You want to specify the rules, and then generate code with the buddha-nature automatically?
11:07:46 <aavogt> you need to be careful using the TH AST
11:07:56 <shapr> aavogt: Why so?
11:07:57 <aavogt> since it can represent invalid code
11:08:08 <shapr> That's nifty.
11:08:13 <aavogt> but maybe that's part of the point
11:08:32 <aavogt> shapr: maybe not with invalid syntax, but with invalid types
11:08:55 <shapr> Well, when gwern turns this into a real-time irc game, I want to play it!
11:09:07 <gwern> shapr: I figure if I do it right, I can do it almost anyway. generate a random short [Int] and filter through code fragments until I find one that generates the [Int], or take a fragment and have it generate a [Int]
11:09:41 <gwern> shapr: the 'right' answer will be decided by user-provided rule passing a quickccheck test - user == system
11:10:14 <ezyang> gwern: Low-tech. Run combinational equivalence checking on the two rules. 
11:10:20 <ezyang> :-) 
11:10:45 <aristid> @hoogle uncurry
11:10:46 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
11:10:46 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
11:10:50 <aristid> @hoogle uncurry3
11:10:51 <lambdabot> No results found
11:10:55 <gwern> ezyang: of course it's low-tech. I'm a low-tech guy. I don't want this to turn into a master's thesis or something
11:11:00 <aristid> why's there no uncurry3?
11:11:07 <ezyang> :^) 
11:11:08 <gwern> at least not without getting a master's scholarship or something
11:11:30 <aavogt> @type uncurry . uncurry
11:11:31 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
11:11:51 <portnov> @type curry . uncurry
11:11:51 <gwern> shapr: the template-haskell repo doesn't seem to proviude an Arbitrary
11:11:52 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
11:12:12 <aristid> portnov: curry.uncurry=id
11:12:27 <yitz> @type curry . curry
11:12:28 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
11:12:47 <portnov> aristid: not fully, as you can see from type :)
11:12:51 <shapr> gwern: Ah well
11:12:55 <aristid> portnov: ?
11:13:02 <aristid> portnov: the type is fully compatible with id
11:13:02 <shapr> gwern: C'mon, do you already have your master's?
11:13:13 <portnov> aristid: id :: a -> a (forall a).
11:13:14 <gwern> shapr: no
11:13:17 <aavogt> other way around
11:13:22 <aristid> :t id :: forall a b c. (a -> b -> c) -> a -> b -> c
11:13:23 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
11:13:27 <aristid> portnov: see.
11:13:34 <aavogt> @type [id, curry . uncurry]
11:13:35 <lambdabot> forall a b c. [(a -> b -> c) -> a -> b -> c]
11:13:40 <yitz> @type (.) uncurry uncurry (.)
11:13:40 <lambdabot> forall b c a. ((a -> c, b -> a), b) -> c
11:14:16 <shapr> gwern: My experience hanging around on #haskell ends up with people asking where I got my PhD, er, Master's, er, Bachelor's, er, Who the heck are you anyway?
11:14:23 <portnov> aristid: yes. so (curry . uncurry) is particular case of id.
11:14:44 <portnov> for example:
11:14:45 <aristid> portnov: which can be expressed with curry . uncurry = id
11:14:49 <portnov> > id 5
11:14:50 <lambdabot>   5
11:14:54 <portnov> but:
11:15:00 <portnov> (curry . uncurry) 5
11:15:08 <portnov> > (curry . uncurry) 5
11:15:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> c)
11:15:09 <lambdabot>    arising from a use...
11:15:16 <aavogt> > (curry . uncurry) 5 1 1
11:15:17 <lambdabot>   5
11:15:24 <ezyang> lol 
11:15:37 <ezyang> did we put a function instance on Num? 
11:15:39 <portnov> > (uncurry . curry) 1 2 3
11:15:40 <lambdabot>   1
11:15:44 * hackagebot Annotations 0.1 - Constructing, analyzing and destructing annotated trees  http://hackage.haskell.org/package/Annotations-0.1 (MartijnVanSteenbergen)
11:15:57 <aristid> > 5 1 1
11:15:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
11:15:58 <lambdabot>    `GHC.Num.Num t' arising f...
11:16:00 <ezyang> :t uncurry . curry 
11:16:01 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
11:16:12 <aristid> > 5 1
11:16:13 <lambdabot>   Ambiguous type variable `t' in the constraint:
11:16:13 <lambdabot>    `GHC.Num.Num t' arising f...
11:17:04 <aristid> Data.Tuple is... minimalistic
11:17:36 <yitz> aristid: it's getting a new function: swap
11:18:19 <camio> I'm looking for an old paper that uses continuations to optimize recursive functions into loops. Anyone know the paper I'm talking about?
11:18:49 <aristid> yitz: unfortunately still no uncurry3?
11:19:08 <aristid> @hoogle zip3
11:19:08 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
11:19:08 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
11:19:08 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
11:19:28 <yitz> aristid: actually there are a lot of functions that could have been in Data.Tuple, but instead there are more general versions of them in Control.Arrow
11:19:28 <shapr> camio: Got any other keywords?
11:19:48 <shapr> camio: Are you talking about something more than tail call optimization?
11:20:20 <aavogt> @google Static single assignmen
11:20:20 <lambdabot> http://en.wikipedia.org/wiki/Static_single_assignment_form
11:20:21 <lambdabot> Title: Static single assignment form - Wikipedia, the free encyclopedia
11:21:11 <camio> shapr: I think it is something more than tail call. If the the function f's last value is 1+f(x-1), the algorithm tries to encode this as continuation passing. The algorithm then realises that the continuation needs only store one number. Not sure if that makes sense.
11:21:37 <heeelp> does anyone here know c++ programming?
11:21:47 <ezyang> heeelp: Wrong chan 
11:22:09 <EvanR-work> get the pitchforks and torches!
11:22:14 <camio> heeelp: yes
11:24:02 <ezyang> I think they should have put castVoid and voidCast (Ptr () -> Ptr a and Ptr a -> Ptr ()) into Foreign; it'd be a lot safer than using castPtr 
11:24:30 * ezyang is reading the FFI spec right now 
11:25:47 <camio> aavogt: was your link in response to my question?
11:30:40 * mtnviewmark wonders if shevek_ is the shevek I know from Hackers conf....
11:33:45 <aavogt> camio: have you looked at the references there (or looked for SSA instead of CPS)?
11:36:28 <sinelaw> hey
11:38:11 <ezyang> I wonder how evil it is to dip into TH to get printf style statements 
11:38:34 <EvanR-work> how about Text.Printf
11:39:04 <kmc> isn't the most Haskelly solution to printf just to use a rich type rather than strings as your format specifier?
11:39:23 <seric> just quick question, is the "Learn You a Haskell" guide the best to start with or is there any better?
11:39:29 <kmc> i.e. a proper EDSL rather than a string DSL which is parsed at runtime
11:39:31 <kmc> seric, that's a good one
11:39:33 <kmc> i like RWH too
11:39:35 <kmc> @where RWH
11:39:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:39:48 <ezyang> mc: That's what I thought TH printf gave you :^) 
11:39:51 <ezyang> *kmc 
11:40:03 <kmc> ezyang, sure, by parsing the string
11:40:04 <seric> kmc: i started with both, but kind of feeld left alone with the rwh guide
11:40:10 <seric> *felt
11:40:13 <kmc> but you can do it without the awesome majesty of TH
11:40:43 <ezyang> it's true... 
11:40:44 <kmc> by making a combinator library
11:40:51 <kmc> which is what the TH would / could / does translate into anyway
11:40:58 <ezyang> For now, though "foo " ++ show bar ++ " baz" 
11:41:01 <kmc> :)
11:41:04 <ezyang> :o) 
11:41:05 <seric> kmc: specially since I found some mistakes which are already reported in the comments but apparently not fixed
11:41:21 <kmc> ezyang, what about Text.PrettyPrint
11:41:47 <kmc> personally i think there's room for at least one more good haskell tutorial
11:41:50 <ezyang> The HughesPJ one? 
11:42:01 <kmc> yeah ezyang
11:42:07 <kmc> i might even write one some day :)
11:42:16 <ezyang> that one's, um, unbelievably heavyweight for an error message :^) 
11:42:20 <dafis> seric: I think they've corrected them for the paper edition
11:43:59 <illissius`> hmm
11:44:15 <illissius`> is there a list anywhere of which language extensions TH does/doesn't support?
11:45:36 <aavogt> kmc: they aren't the same since your fancy combinators are in existence at runtime, TH only leaves the code it generates
11:45:55 <aavogt> though with a sufficiently smart compiler, they could be the same
11:47:12 <mdmkolbe1> When uploading a package to hackage, does it auto generate the haddock or does that have to be included in the package?  I tested a package I'm building using the upload&check link, but the preview page didn't show links to the documentation for my library.
11:47:35 <ezyang> mdmkolbe1: It generates teh Haddock docs. 
11:47:42 <ezyang> This, however, requires Hackage to be able to build your package 
11:48:36 <c_wraith> mdmkolbe1, The docs are built by a cron job that runs every 6 hours
11:48:53 <c_wraith> mdmkolbe1, I think the next run is in 12 minutes.  If I've been paying attention properly.
11:53:02 <mdmkolbe1> ezyang, c_wraith: thanks
11:54:49 <mdmkolbe1> how do I specify a dependancy on "either base ==3.* or (base ==4.* and syb=0.*)"
11:55:31 <mdmkolbe1> (in my cabal file of course)
11:57:33 <dafis> mdmkolbe1, use flags
11:57:34 <Saizan> mdmkolbe1: add a flag
11:58:03 <dafis> mdmkolbe1, if flag(base4)
11:58:25 <dafis>      build-depends: Base == 4.*, syb == 0.*
11:58:45 <dafis>        else build-depends: base == 3.*
12:01:22 <aristid> :t map.uncurry
12:01:23 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
12:02:26 <aristid> @hoogle (a -> b1 -> b) -> [(a, b1)] -> [b]
12:02:26 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
12:02:27 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
12:02:31 <noteed> so the next run of haddock on hackage should happen now; great as I want to take a look at that Annotations package
12:04:13 <mdmkolbe1> dafis, Saizan: thanks (the code example was especially helpful)
12:07:32 <aristid> @hoogle [Bool] -> Int
12:07:33 <lambdabot> Prelude length :: [a] -> Int
12:07:33 <lambdabot> Data.List length :: [a] -> Int
12:07:33 <lambdabot> Data.List genericLength :: Num i => [b] -> i
12:07:49 <aristid> :t length . filter id
12:07:50 <lambdabot> [Bool] -> Int
12:08:39 <aristid> :t unzip
12:08:40 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:08:43 <hpc> @check \x -> (filter id x) == (id x)
12:08:44 <lambdabot>   "Falsifiable, after 0 tests:\n[False,False]\n"
12:08:54 <aavogt> noteed: how do you build that package for use? It isn't too difficult to generate the html documentation yourself
12:10:07 <noteed> aavogt: nothing urges :)
12:14:28 <aristid> @pl \n -> print (n, ratio n)
12:14:29 <lambdabot> print . ap (,) ratio
12:14:58 <aristid> :t ap (,)
12:15:00 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
12:15:23 <aristid> :t ap
12:15:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:15:51 <aristid> :t (,)
12:15:52 <lambdabot> forall a b. a -> b -> (a, b)
12:17:00 <aristid> wow, this is mind-bending :D
12:17:27 <dafis> aristid, what is mind-bending?
12:18:00 <aristid> dafis: ap (,)
12:18:04 <aristid> to me at least
12:19:14 <dafis> aristid, yes, ap is pretty cool
12:19:40 <dafis> and the monad instance of ((->) a) is cute, too
12:19:42 <Veinor> @djinn [a] -> [b] -> [(a,b)]
12:19:42 <lambdabot> Error: Undefined type []
12:19:45 <Veinor> >:(
12:20:05 <aristid> dafis: the (->) Applicative makes it worse :D
12:20:17 <aristid> :t ap
12:20:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:20:25 <aristid> ap: you have the wrong type
12:20:27 <aristid> :D
12:20:32 <dafis> aristid, why?
12:20:54 <dafis> aristid, I meant why does the Applicative instance make it worse
12:21:08 <aristid> dafis: because list applicatives are easier
12:21:27 <aavogt> you're being misleading by calling (->) an applicative functor
12:21:28 <dafis> aristid, elaborate?
12:21:45 <Veinor> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
12:21:46 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:21:46 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:21:46 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
12:21:55 <Veinor> hm, it's not zipWith
12:22:07 <aavogt> it is partially applied  (k -> ) that there is an instance
12:22:09 <Veinor> @hoogle (a -> b -> c) -> m a -> m b -> m c
12:22:10 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:22:10 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:22:10 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
12:22:14 <Veinor> liftM2, there we go
12:22:22 <dafis> aavogt, ((->) a) is an applicative functor a fortiori
12:22:42 <dafis> dang, too slow again :(
12:23:09 <aavogt> it's clearer if you write the (illegal) section
12:23:54 <aavogt> infix operators written prefix is a bit strange
12:24:09 <dafis> aavogt, yes, but it's legal :)
12:25:32 <aavogt> explanations don't have to be valid syntax :)
12:25:51 <dafis> True
12:31:19 <aristid> @src (->) pure
12:31:20 <lambdabot> pure = const
12:31:25 <aristid> @src (->) (<*>)
12:31:26 <lambdabot> (<*>) f g x = f x (g x)
12:31:36 <aristid> @src (->) fmap
12:31:36 <lambdabot> fmap = (.)
12:32:24 <aristid> @src (->) (>>=)
12:32:24 <lambdabot> f >>= k = \ r -> k (f r) r
12:33:54 <aristid> @src liftM
12:33:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:34:06 <aristid> @undo do { x1 <- m1; return (f x1) }
12:34:07 <lambdabot> m1 >>= \ x1 -> return (f x1)
12:34:38 <dafis> @unpl m1 >>= \x1 -> return (f x1)
12:34:38 <lambdabot> (m1 >>= \ x1 -> return (f x1))
12:34:41 <BMeph> @src (->) join
12:34:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:35:00 <dafis> @pl m1 >>= \x1 -> return (f x1)
12:35:00 <lambdabot> f `fmap` m1
12:35:27 <aristid> for @pl, liftM=fmap, which does hold for every sane Monad
12:35:37 <aristid> but is not guaranteed by the system
12:36:05 <dafis> aristid, yes I wanted to check whether it generates m1 >>= return . f
12:36:07 <BMeph> Functional programming is object-oriented programming...where the "objects" are functions! >;)
12:37:16 <BMeph> aristid: Au contraire, it is guaranteed, however, it is not enforced. :\
12:37:22 <sinelaw> meh
12:37:33 <rothwell> 'lo. "$ cabal install --user alex" should install alex to my local user account, shouldn't it?
12:37:56 <dafis> rothwell, yes
12:37:57 <ksf> if you are a user it should always do that.
12:38:11 <rothwell> something seems to have... broken... somewhere
12:38:12 * ksf wonders whether that applies to root, too.
12:38:21 <rothwell> it appears to install fine, without an error
12:38:24 <rothwell> but then:
12:38:28 <rothwell> $ ghc-pkg --user list | grep -i alex
12:38:28 <dafis> rothwell, $HOME/.cabal/bin in your path?
12:38:29 <rothwell> $
12:38:35 <rothwell> dafis: it is, yeah
12:38:42 <ksf> alex isn't a package
12:38:48 <ksf> erm no library
12:38:54 <dafis> rothwell, alex isn't a package, it's an executable
12:39:00 * ksf needs to wake up from his nap
12:39:06 <dafis> rothwell, which alex
12:39:15 <rothwell> alex 2.3.3 from hackage
12:39:24 <ksf> it's no _ghc_ package, only packaged by cabal and a hackage package.
12:39:36 <dafis> rothwell, I meant, in a shell, $which alex
12:39:40 <rothwell> oh, right, i wasn't aware there was a distinction
12:39:51 <dafis> /home/rothwell/.cabal/bin/alex
12:39:55 <rothwell> dafis: yeah, that
12:39:59 <ksf> you're right in that there should'nt be one
12:40:00 <kmc> i'm building GHC/IntWord64.hs from ghc-prim on 32-bit ARM
12:40:08 <kmc> this is the library providing 64-bit ops on non-64-bit machines
12:40:13 <kmc> i get this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26072#a26072
12:40:21 <kmc> anyone know what to do?
12:40:26 <dafis> ksf, I meant library, of course :/
12:40:29 <rothwell> how do i depend on alex in a .cabal file correctly, then?
12:40:29 <ksf> ie. cabal-install won't pull in alex or any other dependency because it just doesn't track executables.
12:41:11 <dcoutts> rothwell: specify build-tools: alex
12:41:11 <lambdabot> dcoutts: You have 8 new messages. '/msg lambdabot @messages' to read them.
12:41:19 <rothwell> dcoutts: ah right, thanks
12:41:26 <rothwell> that'd explain these errors then, heh
12:41:41 <dcoutts> rothwell: but what ksf says is also correct
12:41:59 <gwern> hm. I accidentally my whole music collection. good thing pandora.com is still alive so I can listen while my backup (hopefully) restores
12:43:13 <aristid> @pl m1 >>= \x1 -> return x1
12:43:14 <lambdabot> m1
12:43:18 <dafis> kmc: MagicHash?
12:43:20 <aristid> @src ap
12:43:20 <lambdabot> ap = liftM2 id
12:43:26 <aristid> @src liftM2
12:43:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:43:41 <kmc> dafis, got that one, but apparently there's -XUnliftedFFITypes as well
12:43:43 <kmc> which solved it
12:43:48 <alexyk> I have a function with a let val =  ... in expr inner ... where inner ... function.  inner uses val but ghci says it's not in scope.  really?
12:43:53 <aristid> @undo liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:43:53 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
12:44:44 <dafis> alexyk: should be, unless you omitted something (indentation or such)
12:44:50 <kmc> alexyk, correct, "where" binds further out than the "let"
12:45:09 <kmc> "where" binds to the whole equation you're defining
12:45:17 <alexyk> kmc: how do I make inner see val?
12:45:18 <dafis> rot, overlooked the where :(
12:45:25 <kmc> for this reason you can however do "let val = ... where ... in ..."
12:45:29 <kmc> that "where" binds to "val ="
12:45:41 <alexyk> hmm
12:45:45 <kmc> alexyk, why don't you define "inner" in the same "let" block as val?
12:45:48 <dafis> alexyk: or define inner in the let-binding, too
12:45:58 <dafis> Too slow again
12:46:13 <alexyk> kmc: I want it to logically follow the expression
12:46:45 <dafis> alexyk: or bind val in the where
12:47:07 <dafis> expr inner
12:47:10 <dafis>    where
12:47:16 <dafis>       val = ...
12:47:22 <dafis>       inner = ...
12:47:23 <alexyk> hmm ok
12:47:40 <alexyk> I'm disappointed in where's eagerness
12:47:53 <alexyk> or close-mindedness
12:48:52 <alexyk> where does the nothing come from which types as anything, for stubs
12:48:54 <alexyk> ?
12:48:54 <dafis> where's rather open-minded, it serves several guarded alternatives
12:49:16 <dafis> alexyk: ???
12:49:20 <dafis> undefined ?
12:49:29 <alexyk> dafis: that one :)
12:52:15 <alexyk> so if I have a pure function, I can't print progress from it... what to do? silly debugging prints are gone, the meat of computer culture since Fortran?
12:52:36 <dafis> alexyk: There's always Debug.Trace
12:52:39 <sinelaw> alexyk, for debugging use import Debug.Trace
12:52:43 <alexyk> ah
12:52:47 <sinelaw> @type trace
12:52:47 <lambdabot> Not in scope: `trace'
12:52:51 <sinelaw> @hoogle trace
12:52:51 <lambdabot> Debug.Trace trace :: String -> a -> a
12:52:51 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
12:52:51 <lambdabot> module Debug.Trace
12:53:23 <sinelaw> alexyk, i usually define traceId x = trace (show x) x
12:53:34 <sproingie> @src trace
12:53:34 <lambdabot> trace string expr = unsafePerformIO $ do
12:53:34 <lambdabot>     hPutStrLn stderr string
12:53:34 <lambdabot>     return expr
12:53:39 <sproingie> eazy peazy
12:53:58 <alexyk> sinelaw: there's a traceShow there
12:54:01 <alexyk> apaprently
12:54:05 <sinelaw> there is?
12:54:09 <sinelaw> @hoogle traceShow
12:54:09 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
12:54:24 <sinelaw> then traceId x = traceShow x x
12:54:26 <sinelaw> :)
12:54:41 <sinelaw> @pl (\f x -> f x x)
12:54:41 <lambdabot> join
12:54:49 <sinelaw> traceId = join traceShow
12:55:01 <djahandarie> :t join traceShow
12:55:02 <lambdabot> Not in scope: `traceShow'
12:55:14 <alexyk> so that prints a value when it changes?
12:55:19 <djahandarie> :t join show
12:55:20 <lambdabot>     Couldn't match expected type `a1 -> a'
12:55:20 <lambdabot>            against inferred type `[Char]'
12:55:20 <lambdabot>     Probable cause: `show' is applied to too many arguments
12:55:38 <sinelaw> alexyk, it prints whenever the runtime evaluates that value
12:55:51 <sinelaw> nothing "changes" in haskell
12:55:58 <alexyk> sinelaw: how can one use it to print things like "here"?
12:56:05 <sproingie> when its evaluated may be somewhat surprising
12:56:12 <sproingie> though that's half the point of tracing in the first place
12:56:14 <dafis> alexyk: trace "here" (whatever)
12:56:28 <c0sine> i was just reading through algebraic data types on real world haskell and I came across this
12:56:29 <c0sine> data Bool = False | True
12:56:34 <c0sine> shouldn't that be ||
12:56:36 <c0sine> ?
12:56:38 <sproingie> no
12:56:41 <c0sine> i looked up the operators
12:56:45 <c0sine> yeah it compiles just fine
12:56:50 <c0sine> i was expecting ||
12:56:51 <alexyk> dafis: I mean, I need to define whatever so it's immediately evaluated and here is printed; some seq?...
12:56:54 <sproingie> | is syntax of the type system
12:57:00 <sproingie> || is an operator
12:57:07 <c0sine> so that doesn't actually mean "OR" then
12:57:10 <c0sine> I see
12:57:14 <sproingie> well it sort of does
12:57:18 <dafis> alexyk: trace "here" $! whatever
12:57:20 <c0sine> just in that context
12:57:25 <dafis> may or may not be enough
12:57:26 <ksf> it actually means "plus"
12:57:32 <ksf> as in "sum type"
12:57:34 <c0sine> okay that makes sense
12:57:35 <sproingie> it means "this constructor or that constructor".  it's a lot like a grammar in yacc
12:57:47 <ksf> whereas " " means "times", as in "product type"
12:58:14 <c0sine> thanks for the help!
12:58:57 <dafis> alexyk: If plain seq isn't enough, look at the deepseq package
12:59:08 <ksf> > Just 4 <|> Nothing
12:59:09 <lambdabot>   Just 4
12:59:09 <alexyk> kk
12:59:15 <ksf> > Nothing <|> Just 4
12:59:16 <lambdabot>   Just 4
12:59:17 <aristid> @src liftA2
12:59:17 <lambdabot> liftA2 f a b = f <$> a <*> b
12:59:26 <ksf> > Just 4 <|> Just 2
12:59:28 <lambdabot>   Just 4
12:59:47 <c_wraith> I wish Alternative worked like that for lists, too.  :(
12:59:47 <ksf> > [1,2,3] <|> [1,2]
12:59:48 <lambdabot>   [1,2,3,1,2]
13:00:08 <ksf> well it's mplus
13:03:08 <aristid> lol, i had to derive ap from (>>=) for the (a->) instance to understand it
13:03:14 <aristid> by hand, that is
13:03:34 <aristid> i got: ap = \m1 m2 r -> (m1 r) (m2 r)
13:03:35 <dafis> aristid, by hand is always the best way
13:04:14 <oldsalt> hi guys, what is the right way to do this: type b = Map a b ?
13:04:21 <aristid> so ap (,) f r becomes (r,) (f r)
13:04:31 <aristid> or (r, (f r))
13:05:28 <dafis> oldsalt, what are you trying to do?
13:05:44 <oldsalt> i am trying to define some kind of recursive map
13:05:46 <oldsalt> Map
13:06:44 <ceii> so your b type is a map of maps of maps of maps of ... ?
13:06:54 <dafis> newtype Rec = R (Map a Rec)?
13:07:06 <oldsalt> ah, looks good
13:07:11 <oldsalt> i will try this
13:07:20 <dafis> but will it be usable?
13:08:21 <aavogt> it should probably ble   Rec a
13:08:40 <oldsalt> i didn't do much haskell in the last weeks, so i am somehow rusted
13:08:41 <FunctorSalad> it's true that haskell spoils you, isn't it? ;) I just wrote a posting just *asking* about various ways to manually do something resembling typeclasses (without using the word ;)) and I've already been warned that that code will incite further maintainers to murder me
13:08:59 <FunctorSalad> (in C#, on stackoverflow)
13:09:32 <oldsalt> dafis, what do you mean with usable?
13:09:36 <dafis> FunctorSalad, link?
13:10:00 <FunctorSalad> dafis:http://stackoverflow.com/questions/3016436/explicit-method-tables-in-c-instead-of-oo-good-bad
13:10:11 <JoeyA> Why does this yield "Kind mismatch - Expected kind `* -> *', but `Foo' has kind `*'" ? http://codepad.org/dHbIHaEu
13:10:13 <dafis> FunctorSalad, thanks
13:10:49 <FunctorSalad> not even the automaticness of typeclass resolution, I just want an interface but with the type in question in arbitrary positions in the function signatures...
13:10:58 <dafis> JoeyA: A monad must take a type parameter
13:11:07 <dafis> like Maybe, []
13:11:15 <JoeyA> Even if I don't want one?
13:11:19 <JoeyA> Or would that simply not make sense?
13:11:26 <c_wraith> :t return
13:11:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:11:39 <c_wraith> How does that type signature make sense if your monad doesn't take a type parameter?
13:12:24 <FunctorSalad> of "return"?
13:12:36 <c_wraith> yes.
13:13:38 <FunctorSalad> a monad has a parameter by definition
13:13:41 <JoeyA> I'm trying to make a monad out of a type Foo, and the value you'd return is a FooRef
13:13:47 <JoeyA> Similar to STRef, I suppose
13:14:04 <FunctorSalad> the parameter may be an inert mockup, though
13:14:07 <dafis> JoeyA: Why not data Foo a = Foo (a -> [a])?
13:14:10 <FunctorSalad> (phantom)
13:14:11 <benmachine> JoeyA: it doesn't make sense - your definition of return requires s to be a String
13:14:22 <benmachine> but return is required to be polymorphic
13:17:28 <dafis> FunctorSalad, I'm a little disappointed, it was only one commenter, I expected more (they may still come, of course)
13:18:04 <FunctorSalad> dafis: did I promise more? :(
13:18:11 <djahandarie> So, is haskell.org going to be saved from its vintage 90s look?
13:18:39 <dafis> FunctorSalad, no.
13:18:57 <FunctorSalad> it's fine, except some people think that the logo looks like it rolled down a hill and collected dirt on the way
13:19:00 <dafis> One may hope, though
13:19:19 <FunctorSalad> dafis: just posted it a few hours ago, so I expect so :o
13:19:41 <dafis> FunctorSalad, me too :)
13:21:30 * ksf thinks we should write a libc in haskell
13:21:52 <ksf> after having done that, a c to haskell translator.
13:22:51 <solidsnack> Would be cool if Haskell.org was redone in black and green...
13:23:03 <lpsmith> is there a handy way to look up the fixity/precidence of an operator?
13:23:08 <lpsmith> haddock doesn't do it
13:23:10 <ksf> solidsnack, write a css
13:23:14 <dafis> lpsmith, :info
13:23:26 <ksf> I bet people would be willing to include a switch in the pages' code.
13:23:56 <lpsmith> dafis, thanks
13:24:01 <ClaudiusMaximus> all pages are black and green in my browse
13:24:06 <ClaudiusMaximus> +r
13:24:57 <solidsnack> ksf: I will take a look at it; I would need to generate a few new icons, too.
13:25:15 <solidsnack> ksf: It could be exposed as an alternate stylesheet, selectable via a browser menu.
13:25:41 <solidsnack> I know Firefox used to do that but I can't seem to find the option in Chrome.
13:27:16 <alexyk> is there a way to import qualified Data.Map as M -- and at the same time have raw ! -- not M.! -- ?
13:27:31 <solidsnack> alexyk: Import it twice.
13:27:33 <c_wraith> alexk, you can use two imports.
13:27:38 <dafis> alexyk: also have import Data.Map ((!))
13:27:44 <alexyk> ok
13:28:03 <ClaudiusMaximus> :t Prelude.!
13:28:04 <lambdabot> parse error on input `Prelude.!'
13:28:12 <c_wraith> :t (Prelude.!)
13:28:13 <lambdabot> Not in scope: `Prelude.!'
13:28:18 <ClaudiusMaximus> ah, there isn't one
13:28:21 <c_wraith> yep
13:28:35 <ClaudiusMaximus> there's one for Array though iirc
13:28:39 <dafis> It's in Data.Map and Data.Array[.Modifier]
13:28:59 <ksf> why are they thanking us for spamming our nonsense to freenode everytime they do a notice?
13:29:02 <dafis> Not MArray, of course
13:29:06 <ksf> company policy?
13:29:20 <dafis> politeness?
13:29:41 <ksf> are they required to smile at least 7.5 out of 8 working hours?
13:29:45 <Colours> hi! can somebody help me install category-extras, when I try to install it with cabal it gives me this message:
13:29:48 <Colours> cabal: cannot configure category-extras-0.53.5. It requires ghc >=6.9
13:29:51 <Colours> There is no available version of ghc that satisfies >=6.9
13:30:10 <FunctorSalad> ksf: are you referring to the end of the MOTD?
13:30:30 <alexyk> so a simple desire to hPrint stderr something from a function would cause IO-fication of the whole chain of callers from main down, and do-over for the function.  Hmm.
13:30:34 <ksf> to the notice that just went through
13:30:49 <ksf> but yes, it's in the motd, too.
13:30:52 <ksf> I just never read it.
13:30:53 <dafis> Colours: That's the ghc-API package
13:31:11 <dafis> Colours: What does ghc-pkg list say?
13:31:23 <aavogt> alexyk: desire doesn't mean you put a `hPrint stderr' there though
13:31:32 <aavogt> @quote trace
13:31:32 <lambdabot> Babelfish says: And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
13:31:35 <aavogt> @quote trace
13:31:35 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:31:55 <FunctorSalad> ksf: hmm, good question. is freenode even for profit? OT
13:32:04 <ksf> nope, they aren't.
13:32:11 <alexyk> aavogt: I used to print all kinds of progress info, now I have to rethink in terms of trace
13:32:12 <Colours> dafis http://pastebin.com/L2PsLPjY
13:32:17 <ksf> ...they're just big.
13:32:40 <ksf> as irc "networks" consisting of 1 to 3 servers come a dime a dozen
13:33:05 <FunctorSalad> you get bragging rights for running it I guess :)
13:33:25 <JoeyA> benmachine: Thanks.  I made a polymorphic type alias and got it to work, but now I realize there are cases where I would want a polymorphic return.
13:34:01 <alexyk> let's say I have an inner function with a let val.  Where do I stick trace val?
13:34:06 <ksf> and as a community who comes here you get excellent staff support and reasonable guarantees that people won't dcc you rick astley.
13:34:08 <dafis> Colours: Okay, ghc is there, but run ghc-pkg check to see which packages are broken
13:34:44 <Colours> it says HTTP ghc-6.12.2 and bin-package-db-0.0.0.0 are broken
13:34:45 <ksf> on the other hand, those nutjobs forbit any kind of insulting.
13:35:32 <dafis> Colours: For what reasons?
13:36:05 <Colours> well I get dependency "mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177" doesn't exist and dependency "Cabal-1.8.0.4-7685c286e11f3770764c1dc7b54c8a58" doesn't exist
13:36:26 <FunctorSalad> alexyk: the trace message will be printed when the value of the expression is needed
13:37:02 <alexyk> FunctorSalad: so I say trace in its scope?
13:37:16 <FunctorSalad> I don't know in which sense *exactly*, but I kinda picture it as thunks being connected by strings (the textile kind), and the trace fires when its string is pulled ;)
13:37:17 <Colours> (both of those are supposedly installed)
13:37:20 <Colours> should I try reinstalling them?
13:37:38 <FunctorSalad> alexyk: or on the RHS of the '=' in the let
13:37:46 <alexyk> cute
13:37:58 <FunctorSalad> that too will only trace a message if the value is actually needed
13:38:04 <dafis> Colours: Don't try to reinstall Cabal
13:38:14 <alexyk> oh it's needed, and desired
13:38:27 <dafis> Colours: with the mtl, it might help to unregister the package in the user db
13:38:40 <Colours> how do I do that D:
13:38:47 <lowasser> honestly?
13:38:57 <lowasser> your best bet is probably to reinstall ghc, I'd say =P
13:39:06 <lowasser> although that might work
13:39:15 <Colours> luckily I didn't delete the ghc package~
13:39:20 <lowasser> running ghc-pkg unregister --force mtl, and removing whatever other things get broken
13:39:53 <dafis> Colours: ghc-pkg unregister --user mtl
13:40:01 <dafis> Colours: ghc-pkg unregister --user mtl-1.1.02.
13:41:14 <dafis> Colours: But with a borked Cabal, reinstalling GHC may be a necessity
13:41:42 <Colours> : (
13:41:44 <Colours> oh well
13:44:18 <dafis> Colours: unregistered mtl from the user db?
13:44:30 <dafis> What does ghc-pkg check say now?
13:44:44 <Colours> woo hoo only HTTP is broken because of a missing mtl
13:45:14 <dafis> Colours: Oh, and of course unregister HTTP
13:45:28 <Colours> delicious~
13:45:32 <Colours> do I reinstall http/mtl
13:45:37 <Colours> or just leave them unregistered
13:45:41 <dafis> Colours: You'll have to reinstall that, but compared to a complete ghc, it's small fry
13:46:11 <dafis> Colours, now try cabal install category-extras
13:46:12 <Colours> awesome
13:48:59 <dafis> Colours, cabal install category-extras --constraint="base == 4"
13:49:00 <Colours> Registering category-extras-0.53.5...
13:49:04 <Colours> delicious thanks a bunch :3
13:49:16 <Colours> it installed without that I just got a bunch of warnings about base though
13:49:42 <dafis> Colours, ah, okay. if you want to have it, cabal install HTTP
13:50:16 <lispy> ?tell kowey I have no idea if my blog will notify you that I responded to your comment.  The answer was yes.
13:50:16 <lambdabot> Consider it noted.
13:50:21 <dafis> Colours: Yes, no upper bounds on the dependencies
14:02:41 <andrewhavck> I'm fairly new to Haskell, can someone explain to me why this type check fails? http://gist.github.com/433627
14:03:42 <maltem> andrewhavck, you assert to return a list of Quantities, but you don't
14:04:41 <solidsnack> andrewhavck: It returns a list of tuples
14:05:07 <andrewhavck> Ah, I see
14:05:17 <maltem> pro tip ;) : omit the type signature, and use ghci to check what the type really is
14:06:42 <andrewhavck> thanks for your advice
14:07:03 <pastorn> @type loop
14:07:04 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
14:07:13 <pastorn> @src loop (->)
14:07:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:07:26 <pastorn> @src (->) loop
14:07:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:08:45 <monochrom>  @src is not a very diverse repository
14:09:20 <monochrom> or repertoire
14:09:39 <Cale_> The source links in the haddock documentation are another decent option
14:10:22 <monochrom> much more decent
14:10:41 <monochrom> of course, it doesn't link directly to instance code :)
14:10:51 <kmc> is there any way to disable all package.conf files besides the ones listed on  the GHC command line?
14:10:57 <kmc> i can hide all packages  but that doesn't seem to be the same
14:11:07 <kmc> because when i selectively un-hide them, it still looks at the system package.conf
14:14:39 <aristid> :t random
14:14:40 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
14:15:56 <ezyang> Can I get the fd of a handle without doing anything to the handle? 
14:16:25 <ezyang> (assume posix only, etc) 
14:18:27 <jesusabdullah> fd?
14:18:40 <opqdonut> file descriptor
14:18:41 <monochrom> @hoogle Handle -> Fd
14:18:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:18:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:18:41 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:18:46 <monochrom> no :)
14:19:14 <monochrom> @hoogle Handle -> IO Fd
14:19:14 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
14:19:14 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
14:19:14 <lambdabot> Network.BufferType buf_hGet :: BufferOp a -> Handle -> Int -> IO a
14:19:22 <ezyang> monochrom: lies :-) 
14:19:26 <monochrom> I see why
14:19:36 <monochrom> System.Posix.IO.handleToFd
14:19:43 <ezyang> That closes the handle. 
14:19:58 <mklappstuhl> hey, i now that i can use more than one predicdate by seperating them with a comma
14:19:58 <opqdonut> cause using the Fd would corrupt its state
14:20:00 <opqdonut> probably
14:20:21 <mklappstuhl> is there a way to connect them with an OR instead of AND how the comma does
14:20:21 <c_wraith> You can construct a new handle from the FD afterwards, if you need to
14:20:35 <opqdonut> mklappstuhl: not really, no
14:20:39 <opqdonut> what would that even mean?
14:20:40 <ezyang> I want all of the other handles floating around to still be magically wroking 
14:20:47 <ezyang> *working 
14:21:03 <byorgey> mklappstuhl: you could just use a boolean OR operator, ||
14:21:40 <aavogt> @type or
14:21:41 <lambdabot> [Bool] -> Bool
14:22:12 <jmcarthur> man haskell.org has been in some design-hurt since it was brought back from backups (i assume that's why it looks different)
14:23:16 <ezyang> I guess I can import GHC.IOBase and reach into Handle__ for the info 
14:23:23 <kmc> how will we convert ruby users now
14:23:48 <Saizan> jmcarthur: afaiu they just lost the templates in the process
14:24:00 <kmc> mklappstuhl, the predicates you're talking about, do you mean type class constraints
14:24:05 <kmc> i might have missed some context
14:24:26 <Saizan> i think mklappstuhl is talking about list comprehensions
14:24:30 <kmc> ok
14:24:45 <kmc> then yeah || makes sense
14:26:08 <aavogt> or pattern guards
14:26:11 <Saizan> i guess we don't have special syntax for disjunction because it's relatively uncommon and set comprehension doesn't either
14:28:57 <ksf> as we failed avoiding success, I propose that we change our focus to enforcing success, so that we may properly fail that and succeed.
14:29:20 <ksf> one way to go on about that is to pick a language and kill it.
14:29:36 <ksf> I'd say php, but I guess c++ would give us a better fight.
14:30:08 <jmcarthur> so we need to get uber fast?
14:30:42 <c_wraith> Wait until we have good supercompilation before taking on C++
14:30:49 <c_wraith> it's compile times are already in the days anyway
14:30:56 <osfameron> killing PHP would just require being easy to install and manage for shared hosting, and be so easy monkeys can wri... oh wait
14:30:56 <jmcarthur> mmm supercompilation
14:30:56 <zygoloid> ksf: trouble is both php and c++ have niches which we probably don't /want/ haskell to fill
14:31:26 <jmcarthur> c_wraith: how long until we have good supercompilation? :D
14:31:41 <c_wraith> jmcarthur, possibly eternity :(
14:31:45 <jmcarthur> aw :(
14:31:46 <ksf> the only valid niche of c++ is c meta programming, and we can do that just fine.
14:32:33 <c_wraith> supercompilation is such a sexy idea.  Too bad about the difficulty of actually implementing it.
14:32:54 <ksf> how's it coming along?
14:32:56 <jmcarthur> my understanding of it actually doesn't sound all that difficult, but i suppose subtle issues arise
14:33:30 <ksf> is it just a matter of abstract nonsensists wanting to get everything perfect before releasing a single line of code?
14:33:44 <monochrom> pick a language and kill it? I suggest ocaml. easy target. and gets rid of the last persistent opposer.
14:34:03 <ksf> it's not much of a target
14:34:09 <monochrom> oh wait he has moved to f#. ok, I suggest f#.
14:34:11 <ksf> ...that is, it's too small.
14:34:14 <jmcarthur> how about F# while we're at it. it would at least shut harrop up
14:34:31 <arw_> fortran...
14:34:33 <ksf> "If you do FP, do it right"
14:34:34 <byorgey> jmcarthur: no it wouldn't, he'd find another language
14:34:55 <ksf> we could slap at ocaml off-handedly, and give some moral support to clean
14:35:01 <monochrom> well, supposed after we kill f# we will find another language to kill too
14:35:15 <tensorpudding> So violent
14:35:27 <monochrom> so, he moves to X, we kill X.
14:35:31 <jmcarthur> maybe we should make a new word for "kill" that doesn't sound so bad
14:35:36 <ksf> clean doesn't seem to have any ambition on its own, I think it'd make a cute pet.
14:35:39 <Dashkal> perl?
14:35:41 <monochrom> if he moves to Buddha, we will kill Buddha.
14:35:43 <aavogt> it seems rather indirect
14:35:58 <ksf> perl's already quite dead
14:35:59 <monochrom> better word than kill: exterminate
14:36:02 <tensorpudding> I don't know of many examples of a language killing another.
14:36:07 <gwern> if you meet a buddha in the road, kill it
14:36:09 <ksf> that is, it's not dead, it's just not very much alive
14:36:13 <danharaj> Java
14:36:14 <danharaj> kill java.
14:36:14 <Dashkal> oh good.  I hated perl
14:36:15 <tensorpudding> Mostly they die of natural causes.
14:36:19 <Dashkal> Scala is working on that
14:36:25 <monochrom> err, exterminate Buddha
14:36:42 <Dashkal> But I think Oracle will succeed at it
14:37:00 <ksf> and everyone will switch to davik?
14:37:09 <gwern> so, turns out you can undelete files from ext3 after a couple hours
14:37:14 <gwern> you may not get them all back though
14:37:20 <aristid> is there something special about (\a -> zip3 (inits a) (tails a) a)?
14:37:54 <monochrom> you can undelete on most file systems
14:38:01 <aavogt> > tails "123" `zip` "123"
14:38:02 <lambdabot>   [("123",'1'),("23",'2'),("3",'3')]
14:38:03 <aristid> ah, it seems to be somewhat redundant
14:38:38 <jmcarthur> > (\a -> zip3 (inits a) (tails a) a) [1,2,3]
14:38:39 <monochrom> it's royally inefficient to seriously kill a file rather than just dereference it.
14:38:39 <lambdabot>   [([],[1,2,3],1),([1],[2,3],2),([1,2],[3],3)]
14:38:46 <gwern> monochrom: eh, the usual advice for the ext* FSs is to fugeddahboutit
14:39:05 <gwern> the bits may be there but putting them together is the issue
14:39:07 <jmcarthur> there we go. we should "dereference" other languages
14:39:07 <monochrom> as it happens, you can also undelete passwords from RAM
14:39:16 <gwern> (and actually I noticed a lot of files got overwritten)
14:39:21 <danharaj> What does supercompilation do
14:39:25 <jmcarthur> monochrom: and sometimes even from swap :(
14:39:34 <FunctorSalad> there's always shred, iirc in the coreutils
14:39:48 <jmcarthur> shred is not reliable with journaled filesystems
14:40:04 <FunctorSalad> oh?
14:40:23 * hackagebot rpc 0.0.1 - type safe rpcs provided as basic IO actions  http://hackage.haskell.org/package/rpc-0.0.1 (SamAnklesaria)
14:40:31 <jmcarthur> i don't rely on utilities like that. full hard drive encryption is the only way to be sure of anything
14:40:32 <FunctorSalad> hmm if that's true it should come with a giant warning, considering ext3 is what most people are using ;)
14:40:40 <jmcarthur> yes, it should
14:40:41 <arw_> monochrom: every non-braindead program does memset(...,0,...) over passwords
14:41:04 <FunctorSalad> I thought journalling is just about metadata, not data, though
14:41:20 <aristid> jmcarthur: you can encrypt swap with a randomly generated key (which is generated at boot), which is pretty neat i'd say
14:41:25 <jmcarthur> well, i say "journaled" but i mean features that often accompany journaling
14:41:25 <arw_> monochrom: so usually you can only revive cryptographic keys which are intentionally stored, passwords are thrown away after checking validity
14:41:31 <jmcarthur> lemme see if i can find the article i read it from
14:41:39 <jmcarthur> aristid: i do that
14:41:39 <FunctorSalad> (with the actual data not being kept track of in any other place)
14:41:52 <monochrom> Hrm! How do I memset(...0...) over password in haskell? I read the password from getLine... (with echo off, of course)
14:41:56 <jmcarthur> aristid: well, i used to. now i use a static key so i can hibernate securely
14:42:26 <monochrom> I guess my haskell program is braindead.
14:42:30 <thoughtpolice> i've been thinking for a while I should find a way to truecrypt my android phone
14:42:32 <aristid> jmcarthur: i have all my partitions in a LVM which includes swap
14:42:39 <aristid> and the LVM is in dm-crypt
14:43:01 <jmcarthur> FunctorSalad: in the case of ext3 the default is indeed metadata only, but it can also journal data if you choose
14:43:02 <arw_> monochrom: yes, that is a major failing of most garbage collected languages
14:43:03 <gwern> bleh. the ext3 undelete tool couldn't put all the files in their directories, so I have to...
14:43:16 <FunctorSalad> jmcarthur: you learn something new all the time :)
14:43:27 <jmcarthur> FunctorSalad: other journaled filesystems do default to journaling data though (JFX, ReiserFS, XFS, etc. i think all do it)
14:43:33 <monochrom> it would be better if haskell strings had a mutation interface...
14:43:39 <kmc> haha
14:43:40 <FunctorSalad> :D
14:43:43 <opqdonut> :D
14:43:54 <jmcarthur> FunctorSalad: shred also will fail on compressed filesystems, RAID, and NFS
14:44:00 <aavogt> don't they with a little unsafeCoerce?
14:44:06 <arw_> monochrom: the other problem is, in stuff like the JVM you would also have to prevent heap reordering
14:44:22 <FunctorSalad> reminds me of the april fool's joke I found earlier today that RMS sent him a takedown notice over patented emacs concepts
14:44:25 <monochrom> oh yeah, it gets copied at every GC
14:44:49 <monochrom> I guess it really is GC causing the biggest problem
14:45:15 <Dashkal> Where would be a good place to start learning Arrows?  It's my next 'scary' concept.
14:45:40 <gwern> gah! I did lose music - at the very least 5 or 6 _El Ten Eleven_ files
14:45:41 <aavogt> Dashkal: whichever library that uses arrows
14:46:11 <monochrom> learning HXT is a good place to start learning Arrows. http://www.vex.net/~trebla/haskell/hxt-arrow/
14:46:13 <kmc> Dashkal, arrows aren't used very much
14:46:15 <Dashkal> I'm not just looking for API docs, but rather something that helps explain the point.  Why it's useful.  THat kind of thing
14:46:15 <arw_> monochrom: but fear not, you can always write a c function which does the right thing and use that.
14:46:30 <FunctorSalad> until someone produces an example that's not a Kleisli arrow, there's nothing to learn if you know monads *half-kidding*
14:46:48 <FunctorSalad> and CoKleisli ;)
14:46:57 <gwern> oh yeah; I lost like half my music
14:46:58 <gwern> dammit
14:47:07 <FunctorSalad> indeed
14:47:20 <Dashkal> I'm realizing I'm running into issues learning things from api docs.  For example, until this morning reading RWH, I had no idea why foldr is often better than foldl.
14:49:06 <gwern> (looks like I lost about 3 gigs of stuff. oy vey)
14:49:35 <FunctorSalad> Dashkal: a good example arrow is that if M is a monad, the type "newtype Foo a b = Foo (a -> M b)" is an arrow
14:49:39 <gwern> when I've recovered somehow, I'm changing ~/music 's permissions to read-only...
14:49:49 <FunctorSalad> Dashkal: known as Kleisli M
14:50:42 <FunctorSalad> the implementation of Category.(.) will be "Foo g . Foo f = Foo (g <=< f)"
14:51:11 <aavogt> http://www.soi.city.ac.uk/~ross/papers/fop.html
14:51:17 <FunctorSalad> and Arrow.arr will be "arr f = Foo (return . f)"
14:51:22 <Zao> gwern: For great amusement, try hardlinking directories and file managers that do not understand hardlinking.
14:51:25 <Dashkal> 'Category' is still very very nebulous to me
14:51:28 * hackagebot properties 0.0.1 - check quickCheck properties in real time.  http://hackage.haskell.org/package/properties-0.0.1 (AlbertoCorona)
14:51:34 <FunctorSalad> Dashkal: it's superclass of Arrow
14:51:39 <Dashkal> I'm coming in from imperative (dysfunctional if you prefer) programming rather than math
14:51:57 <FunctorSalad> so you kinda need to understand Category first (the typeclass, not the whole theory)
14:52:10 <ddarius> The vast majority of Haskell programmers are coming from imperative programming languages and not math.
14:52:40 <monochrom> me too
14:52:40 <FunctorSalad> yeah, and you don't really need any math to just get these two typeclasses
14:52:45 <Dashkal> *nods*
14:52:49 <monochrom> I came from BASIC.
14:53:07 * mux started with Locomotive BASIC 1.0
14:53:17 <jesusabdullah> I have a math minor <_<
14:53:21 <Dashkal> ok, that newtype wrapper is just a newtype around the bind signature...  I can handle that
14:53:35 <jesusabdullah> but programming's been in ye typical imperative languages
14:53:42 <jesusabdullah> like matlab! >_<
14:53:52 * jesusabdullah has been matlabbing the last few days
14:54:03 <jesusabdullah> (pity me!)
14:54:49 <Dashkal> I do PHP in my day work *shudder*
14:54:57 <Dashkal> Oh how I miss type safety
14:55:54 <monochrom> I am infuriated when a dynamically-typed program for production use actually craps out due to a type error, e.g., a fairly recent version of duplicity.
14:56:21 <monochrom> Completely proves that it should be capitally punished.
14:56:22 <opqdonut> duplicity is a bit flaky...
14:56:44 <Dashkal> I'm dealing with functions that quite happily take arguments of varrying types.  Array? Sure.  integer?  No problem.  Oh, the mean slightly different things
14:56:57 <ksf> Dashkal, imagine wrapping an abstraction around all of haskell.
14:57:05 <ksf> that's the category Hask
14:57:39 <ksf> with a set of functions (->) as morphisms, and (.) as composition
14:58:17 <Dashkal> wow, I actually follow that
14:58:19 <ksf> oh, and types as objects.
14:59:51 <FunctorSalad> mhm, with instance Arrow Foo, Foo is a kind of generalization of (->)
15:00:00 <opqdonut> yep
15:00:45 <FunctorSalad> have the type variables in Control.Arrow been renamed yet? pretty pessimal didactically
15:00:50 <Dashkal> with a notmal function being a -> Identity b?
15:00:55 <Dashkal> normal*
15:00:57 <opqdonut> Arrow Foo kinda means Foo is a CCC (or something) with Hask as a subcategory
15:01:06 <FunctorSalad> Dashkal: exactly
15:01:12 <ksf> Dashkal, http://en.wikibooks.org/wiki/Haskell/Category_theory is quite good
15:01:15 <FunctorSalad> (->) is like Kleisli Identity
15:01:19 <FunctorSalad> up to newtypes
15:01:37 <FunctorSalad> @type first
15:01:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:01:44 <FunctorSalad> I mean these variables
15:02:14 <FunctorSalad> "a" plays a completely different role than b,c and d, I think that confuses many people at first
15:02:20 <FunctorSalad> me, anyway ;)
15:02:54 <ksf> what's the terminal of hask?
15:02:56 <FunctorSalad> write it with an infix type variable like "-->" instead and it will look much better
15:03:06 <Dashkal> if I'm reading that right, a has to be a type constructor that takes two other types?
15:03:13 <alexyk> ghc takes -O3, is it the same as O2?
15:03:14 <Dashkal> lost
15:03:21 <FunctorSalad> ksf: hmmm, depends on how you deal with partiality
15:03:31 <FunctorSalad> it should be the one-element type
15:03:35 <ksf> ()
15:03:41 <FunctorSalad> which is Void or () depending on whether you count bottom
15:04:16 <FunctorSalad> and there's no real initial object in Hask since there's no empty type
15:04:19 <ksf> ...if we are reasoning fast and loose but still morally correct
15:04:49 <FunctorSalad> (initiality of Bar would mean that there's just one function from Bar to A for any A)
15:05:00 <ksf> (  http://www.cs.nott.ac.uk/~nad/publications/danielsson-et-al-popl2006.html  )
15:05:11 <FunctorSalad> which is impossible since all the constant functions are distinct in haskell no matter what the domain is
15:05:22 <ksf> we _do_ have empty types, if we disregard bottom
15:05:35 <FunctorSalad> yes
15:05:36 <ksf> {-# LANGUAGE EmptyDataDecls #-} data Foo
15:05:55 <FunctorSalad> yeah but I can define an infinity of distinct functions of type Foo -> Integer
15:06:00 <FunctorSalad> while it's supposed to be just one
15:06:13 <FunctorSalad> (you can only observe the value by passing undefined as an argument, though)
15:06:21 <Dashkal> Minor question.  How do you pronounce ∘ when reading function composition? f∘g
15:06:30 <ksf> compose
15:06:40 <Dashkal> f compose g.  k, danke
15:06:42 <ksf> but usually my mind doesn't spell it out.
15:06:49 <Dashkal> My mind wants to when reading.
15:06:55 <FunctorSalad> "after" ("nach") in german
15:06:58 <FunctorSalad> dunno if it's used in english
15:07:22 <ksf> I think I think somethnig like "glue"
15:07:49 <aavogt> followed by
15:08:04 <FunctorSalad> isn't that the flip of it?
15:08:04 <ksf> rather "preceded by"
15:08:05 <aavogt> if you like reading right to left :)
15:09:06 <aavogt> I think `at' reads fine too
15:09:09 <Philonous> Dashkal: One of my math profs called that operator "Kringel". I kind of like that.
15:09:12 <aavogt> f at g of x
15:09:21 <FunctorSalad> or you may skip it completely like composition in settings where it has the lead role
15:09:25 <FunctorSalad> *like multiplication
15:09:39 <FunctorSalad> Philonous: :D
15:09:52 <ksf> FunctorSalad, isn't a terminal necissarily unique?
15:09:54 <FunctorSalad> thought that was for a kringel above it
15:10:03 <ksf> you can just say data Term = Term and provide a -> Term
15:10:17 <FunctorSalad> ksf: yeah... the ambiguity I mean is from being unsure what exactly our cat is
15:10:38 <Philonous> FunctorSalad: You mean "~"? He called that "Schlange" 
15:10:50 <ksf> turing-completeness doesn't help.
15:10:55 <FunctorSalad> taking bottom into account, there are many functions Int -> Term, ksf
15:11:03 <ksf> # is "Lattenzaun"
15:11:11 <FunctorSalad> for each Int you can choose either nontermination or returning Term
15:11:15 <ksf> which sounds great if you pronounce c#
15:11:27 <FunctorSalad> Philonous: sometimes there's a little circle above a letter :)
15:11:40 <FunctorSalad> ksf: don't forget the "Dach" aka "Hut" ;)
15:11:56 <FunctorSalad> ^
15:11:58 <ksf> but one could also argue that they're not distinct functions if they only differ in name.
15:12:13 <FunctorSalad> c-lattenzaun?
15:12:19 <FunctorSalad> I'll keep that in mind
15:12:20 <ksf> he also called a stack cellar and a heap waescheleine
15:12:36 <FunctorSalad> always thought a heap was a haufen
15:12:41 <ksf> "if I put something into my cellar, I can only get at the thing I last put in"
15:12:57 <ksf> "whereas a clothing line provides random access"
15:12:57 <jav_> Hi there! I just wrote a postInst hook in Setup.lhs for my cabalized haskell project and it seems to work fine. But if I invoke 'cabal install' in the directory, it seems to ignore the hook (as supposed to running something like "runhaskell Setup.lhs install") ... what am I missing?
15:13:36 <aavogt> jav_: build-type: custom
15:13:39 <aavogt> or something like that
15:13:41 <gwern> phew! looks like duplicity didn't totally screw up - it still had a list of my music
15:14:04 <jav_> aww, of course! thx aavogt 
15:14:22 <mklappstuhl> hey
15:14:27 <mklappstuhl> again :)
15:14:37 <shapr> Hm, that new properties package looks interesting, does anyone know how it works?
15:14:39 <FunctorSalad> maybe cabal should emit a warning if there's a custom Setup.hs but build-type:simple....
15:14:41 <ksf> bottom messes everything up, anyway, so we should just ignore it.
15:14:49 <FunctorSalad> way to go :D
15:15:01 <mklappstuhl> i'm trying to build the fibonacci sequence in haskell and im wondering how i can access specific list items
15:15:04 <aavogt> FunctorSalad: I think it's a valid case to do that
15:15:21 <aavogt> though if the setup.hs isn't the default one, it's a mistake
15:15:24 <ksf> you need to be conal to actually have to deal with bottom, I think.
15:15:34 <systemfault> mklappstuhl: With !! ?
15:15:37 <Philonous> @type (!!) -- mklappstuhl
15:15:38 <lambdabot> forall a. [a] -> Int -> a
15:15:38 <ksf> for everyone else it's just another bug.
15:15:46 <FunctorSalad> there is the moral equivalence, yeah, but I think it just deals with behaviour of bottom that's even uglier than bottom is mathematically
15:15:52 <FunctorSalad> like undefined being != const undefined
15:16:03 <FunctorSalad> IIRC moral equivalence doesn't save you from () having two elements
15:16:33 <FunctorSalad> ("mathematically" as in basic domain theory, where undefined should be equal to const undefined)
15:17:00 * conal perks up, then returns to hacking infinite quadtrees in objective-c.
15:17:11 <FunctorSalad> :)
15:17:43 <zachk> wth is a quadtree anyways ive heard of them in use for hash-life (conways life) 
15:17:56 <zachk> and ive heard of octtrees as well but never grasped the concept 
15:17:59 <FunctorSalad> a tree for storing 2d points
15:18:05 <FunctorSalad> oct is for 3d
15:18:10 <FunctorSalad> since there are eight octants ;)
15:18:28 <conal> a recursive data structure for storing info about space regions.
15:18:39 <ksf> though bucky fuller would whince at the thought of partitioning space with cubes.
15:18:46 <gwern> hashlife is a pretty neat algorithm
15:18:54 <mklappstuhl> systemfault: thanks :) as i read it i remembered :D
15:18:57 <zachk> so a regular binary tree can be thought as of storing points in R^1? 
15:19:10 <conal> zachk: yeah!
15:19:13 <FunctorSalad> quadtrees are defined to make an equal partition at every point right? and kd-trees were the ones who try to be balanced
15:19:40 <zachk> do i need data at the nodes or just on the leafs? 
15:19:48 <FunctorSalad> leafs I think
15:20:03 * zachk imagines this is kinda like surreal numbers 
15:20:08 <conal> warren burton wrote an elegant paper on lazy infinite quadtrees a while back.
15:20:16 <zachk> link? 
15:20:17 * chrisdone only just discovered the -XDisambiguateRecordFields extension
15:20:18 <FunctorSalad> at least if you always cut the remaining region into four equal parts, there's no data at the nodes
15:20:32 <conal> warren did some wonderful work in the '80s.  mostly forgotten i suspect.
15:20:50 <gwern> in CS, we progress by standing on each other's toes...
15:21:04 <conal> ... including denotative/functional (semantically determinate) concurrency
15:21:25 <ezyang> Let's say I have some code that writes to a pipe, and some code that reads from the pipe. What weight concurrency do I need to make these two play nice? Control.Concurrent? 
15:21:35 * ksf wonders whether quinttrees would actually be beneficial
15:21:41 <chrisdone> i gotta take a whole weekend just taking stock of all the latest GHC extensions i haven't seen
15:21:41 <ksf> sierpinski would rejoice
15:21:50 <FunctorSalad> ezyang: c&p System.Process.readProcess
15:21:51 <FunctorSalad> :D
15:21:52 <gwern> @quote weekend
15:21:53 <lambdabot> ndm says: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
15:21:54 <zachk> ksf: why 
15:22:14 <ksf> you can "fill allspace" (in bucky terms) with tetrahedra
15:22:23 <ksf> where five of them make up another one
15:22:49 <FunctorSalad> ezyang: oh, and you may have to compile with -threaded. I don't know when exactly.
15:23:03 <FunctorSalad> I recently did have to
15:23:09 <ksf> the question is whether that's interesting form a cs point of view, it certainly is when you deal with real-world physical systems as the powers distribute _way_ better.
15:23:19 <ezyang> Ah, yeas, this is Control.Concurrent. Thanks! 
15:23:50 <ksf> basically, we're stuck on cartesian coordinate systems since pythagoras or even earlier.
15:24:44 <zachk> how do i tesselate 3-space with tetrahedron 
15:24:55 <zachk> the sierpinksi way? 
15:24:58 <zachk> er no 
15:25:06 <FunctorSalad> ksf: modern math emphasizes the need to work coordinate-freely if possible, but you need them to execute actual calculations...
15:25:45 <FunctorSalad> (not "need", but there's less "artificial" stuff if you forbid yourself from using anything that depends on coordinates rather than just on the abstract structure you're dealing with)
15:26:36 <FunctorSalad> for example, you can pretend that there's a special basis in a R^n, but not in an abstract n-dimensional vector space
15:26:59 <FunctorSalad> (any such space is isomorphic to R^n, but not isomorphic in a unique way)
15:28:19 <Philonous> FunctorSalad: Huh, sure? Doesn't that only hold for R-spaces? 
15:28:40 <FunctorSalad> Philonous: yes. took that as implicit :)
15:29:10 <FunctorSalad> Philonous: type inference from starting to talk about R^n and claiming isomorphy ;))
15:29:46 <Philonous> FunctorSalad: Yes, it's isomorphic iff it's isomorphic ;)
15:30:40 <FunctorSalad> Philonous: not that, I meant that saying that two vector spaces with a different base field are isomorphic would be a type error
15:30:47 <ksf> FunctorSalad, while I'm at it, I'd like a regular tiling of the surface of a sphere.
15:31:14 <ksf> ...or rather approximation of a sphere
15:31:22 <ksf> ...really good approximation.
15:31:39 <dafis> ksf: spherical triangles too simple?
15:32:06 <FunctorSalad> Philonous: (granted, I'm assuming there that we need to use categories of vector spaces where the base field is fixed; but nothing prevents one from taking the disjoint union of all these cats)
15:32:32 * wli has flashbacks to scans of spherical trigonometry books from the 1890's.
15:32:42 <ksf> ...regular implying non-flipping
15:32:43 <Philonous> FunctorSalad: I see what you mean. But is that necessarily the case? I mean R^4 is isomorphic to C^2. Ok, you could introduce subtyping...
15:32:51 <ksf> oh and i'd like to have a decent amount of edges on them
15:33:14 <ksf> think of using it as a board tiling for a game played on a planet.
15:36:16 <FunctorSalad> Philonous: isomorphic as R-vector spaces :) linear maps as I know them are defined in terms of vector spaces over the same field... but as you hint at, if there's a morphism of the base fields m, one can define a "linear m-heteromap" (term made up :)) as a function L with L(x+y)=Lx+Ly ; L(a*x) = m(a)*L(x)
15:36:48 <FunctorSalad> (the m converts scalars)
15:37:42 <FunctorSalad> I don't know if these have an official name
15:38:13 <dafis> FunctorSalad, we always called it an E-linear map if F was a field extension of E
15:38:37 <FunctorSalad> ah
15:38:45 <dafis> (same for rings and modules, of course)
15:39:09 <FunctorSalad> with fields you're a bit limited I guess, since their homomorphisms are all injective
15:39:25 <FunctorSalad> so you could only go to a "larger" base field, not a smaller...
15:39:25 <zygoloid> preflex: seen dons
15:39:25 <preflex>  dons was last seen on #ghc 1 hour, 3 minutes and 5 seconds ago, saying: dcoutts: mail from igouy (of the language shootout) having trouble installing Cabal library
15:39:52 <dafis> right, but it avoids a lot of difficulties you have with rings
15:40:09 <aristid> partial functions considered harmful?
15:40:36 <dafis> aristid, By many, not without reason
15:41:06 <zygoloid> @ask dons Would you accept a patch to bytestring-mmap to allow specifying the offset and length within the file to map?
15:41:07 <lambdabot> Consider it noted.
15:41:21 <dafis> like goto, they have their place, but you should think twice before using
15:41:34 <aristid> dafis: i do wonder how much they are needed.
15:42:01 <FunctorSalad> see "total functional programming"
15:42:13 <FunctorSalad> it has been tried, but it's not easy
15:42:21 <dafis> aristid: One could make all partial functions a -> b total functions a -> Maybe b
15:42:31 <dafis> but it would be inconvenient
15:42:39 <FunctorSalad> (your language would amount to a totality prover, after all)
15:42:56 <aristid> FunctorSalad: agda is total afaik
15:43:13 <FunctorSalad> *nod*
15:43:38 <FunctorSalad> does it help you define recursive functions which aren't structurally recursive?
15:44:02 <FunctorSalad> coq has the "Function" construct for that, but you need to prove stuff
15:44:56 <dafis> whereas in dynamically typed languages, you stuff the proofs
15:45:13 <FunctorSalad> in haskell too, actually, no?
15:45:42 <aristid> in haskell you're free to construct bottom :D
15:45:56 <aristid> i mean there's even a language primitive for it
15:46:51 <FunctorSalad> is it primitive? ;)
15:47:08 <aristid> > let undefined = 1 in undefined
15:47:09 <lambdabot>   1
15:47:18 <aristid> no, it's just in the Prelude
15:47:24 <FunctorSalad> + ghc -e ':info undefined'
15:47:25 <FunctorSalad> undefined :: a 	-- Defined in GHC.Err
15:47:27 <kmc> @src undefined
15:47:28 <lambdabot> undefined =  error "Prelude.undefined"
15:47:31 <kmc> @src error
15:47:31 <lambdabot> error s = throw (ErrorCall s)
15:47:48 <aristid> > let error = 1 in error
15:47:49 <lambdabot>   1
15:47:52 <kmc> @src throw
15:47:53 <lambdabot> throw exception = raise# exception
15:48:08 <aristid> it's nice how few keywords haskell has
15:48:11 <FunctorSalad> let error = "oh god" in undefined -- dynamic scope :D
15:48:44 <FunctorSalad> hmm raise# isn't exactly a keyword, but magic
15:48:48 <kmc> i need terminology to distinguish "looks like an ordinary value, but has magical implementation" from "special as the user sees it"
15:49:00 <kmc> terms like "built-in" or "primitive" can confuse the two
15:49:29 <kmc> as far as standard Haskell is concerned, "error" is the former
15:49:29 <FunctorSalad> "built-in" is confusing, I agree. GHC seems to use 'primitive' for what you meawn
15:49:31 <FunctorSalad> -w
15:49:38 <FunctorSalad> GHC.Prim module etc
15:49:42 <aristid> kmc: you do some programming in agda, didn't you say that? is totality something you can deal with?
15:49:44 <kmc> GHC also uses "primitive" for various specific technical things
15:49:47 <kmc> aristid, only a bit
15:49:50 <kmc> and so far, yes
15:50:11 <kmc> but i haven't done anything substantial
15:50:17 <FunctorSalad> how do you do a non-structural recursion in agda?
15:50:27 <FunctorSalad> (in case you weren't there earlier when I wondered :))
15:50:31 <aristid> i was btw. coming to this question because the monad reader editorial is ridiculing all non-functional non-pure languages
15:50:43 <kmc> by doing structural recursion on a proof that the other recursion terminates
15:50:43 <kmc> i think
15:50:52 <FunctorSalad> ah
15:50:52 <aristid> and i was wondering "but lack of totality is dangerous too, are you ignoring that"
15:51:24 <aristid> kmc: is it a lot of effort?
15:51:33 <kmc> i don't have enough agda experience to say
15:51:34 <FunctorSalad> aristid: which doesn't make all partial languages equally bad ;)
15:52:11 <FunctorSalad> at least "ignoring bottom issues" means that you won't get *conflicting*/wrong answers, just that you may fail to get one
15:52:28 <FunctorSalad> pretty neat application of order theory, I find
15:52:45 <FunctorSalad> (the less-defined-then relation)
15:54:35 <aristid> FunctorSalad: yeah but it becomes a difference of degree instead of a complete and total difference
15:55:04 <FunctorSalad> degree of what exactly?
15:55:20 <FunctorSalad> even if it compiles in a total language it might still be wrong ;)
15:55:25 <aristid> "considering the number of moving parts involved and the embedded software written by people who had never even heard of the Curry-Howard Isomorphism, it amazed him things didn't go wrong with it more often, like a oating point error and maybe some wrong units causing the accelerator to become stuck"
15:55:32 <aristid> this is terribly arrogant
15:56:02 <FunctorSalad> hmm, not to me
15:56:03 <shajen> hi
15:56:10 <shajen> i need some help with haskell
15:56:21 <FunctorSalad> I think it's at least in part a genuine appreciation of how these other people could manage the mess
15:56:31 <dafis> shajen, hi, what can we do for you?
15:56:40 <aristid> FunctorSalad: bottom is an unwanted value that you can't get rid of, so you have the wrong unit, in a way.
15:57:03 <shajen> i need to write AllEnum::[Int]->[Int]
15:57:16 <shajen> it should work like this
15:57:45 <Twey> You can't
15:57:58 <FunctorSalad> btw... monotony (with respect to the definedness relation) is a property that haskell actually satisfies rigorously, isn't it?
15:58:13 <shajen> from list of int it should return list of the number of occurrences of each elemnentu
15:58:15 <Twey> AllEnum is a type constructor (because of the function), so it can't return [Int]
15:58:28 <Twey> Er
15:58:30 <FunctorSalad> unless you use arcane unsafe primitives that look up whether a thunk has been evaluated...
15:58:33 <Twey> because of the capital**
15:58:37 <shajen> dafis: you know how to write it in linear time?
15:58:39 <FunctorSalad> (or that check for 'undefined')
15:58:50 <aristid> shajen: length.group.sort?
15:59:21 <aristid> > length . group . sort $ [3,1,1,2,1,3,3,3,3]
15:59:22 <shajen> how to use it?
15:59:22 <lambdabot>   3
15:59:28 <shajen> ok i try
15:59:30 <aristid> argh
15:59:32 <FunctorSalad> (this montony: if x is less defined or equal to y, then f x is less defined than f y)
15:59:34 <dafis> shajen, linear time would require a *lot* of space
15:59:34 <aristid> > map length . group . sort $ [3,1,1,2,1,3,3,3,3]
15:59:35 <lambdabot>   [3,1,5]
15:59:38 <FunctorSalad> for arbitrary f
15:59:51 <FunctorSalad> and "less defined _or equal_"
15:59:52 <shajen> dafis: i know but i won't work with big list
16:00:26 <dafis> shajen, then O(n*log n) would be fine, wouldn't it?
16:00:27 <Twey> Fold it into a Map, maybe
16:00:33 <dafis> ^^
16:00:45 <shajen> dafis: it's ok
16:00:54 <Twey> I guess that's not linear time, either
16:01:00 <ksf> don't we have a bag type?
16:01:03 <dafis> Or, if you have only a few possible values, an array
16:01:11 <ksf> I bet edison comes with one
16:01:13 <Twey> ksf: Not built-in
16:01:27 <Twey> There's Data.MultiSet on Hackage
16:02:09 <FunctorSalad> @let counts = foldr (\x xs -> insertWith (+) x 1 xs)
16:02:10 <lambdabot>  <local>:5:25: Not in scope: `insertWith'
16:02:17 <FunctorSalad> @let counts = foldr (\x xs -> Map.insertWith (+) x 1 xs) Map.empty
16:02:18 <lambdabot>  <local>:5:25: Not in scope: `Map.insertWith'
16:02:18 <lambdabot>  
16:02:18 <lambdabot>  <local>:5:52: Not in scope: ...
16:02:28 <FunctorSalad> @let counts = foldr (\x xs -> M.insertWith (+) x 1 xs) M.empty
16:02:30 <lambdabot>  Defined.
16:02:34 <FunctorSalad> phew
16:02:51 <dafis> FunctorSalad, don't use foldr to build Maps
16:02:55 <FunctorSalad> > counts [ n % 3 | n <- [0..17] ]
16:02:56 <lambdabot>   fromList [(0 % 1,1),(1 % 3,1),(2 % 3,1),(1 % 1,1),(4 % 3,1),(5 % 3,1),(2 % ...
16:02:57 <dafis> Use foldl'
16:03:05 <FunctorSalad> dafis: agreed
16:03:11 <ksf> it's just a regular intmap, anyway.
16:03:21 <FunctorSalad> wtf happened there ;)
16:03:24 <alexyk> do I really have to write my own fst for (x,_,_)?
16:03:35 <FunctorSalad> oh, % isn't modulo in haskell, right
16:03:43 <FunctorSalad> > counts [ mod n 3 | n <- [0..17] ]
16:03:44 <lambdabot>   fromList [(0,6),(1,6),(2,6)]
16:03:48 <FunctorSalad> yay
16:03:48 <dafis> alexyk: Yes, everybody has to some time
16:03:51 <FunctorSalad> > counts [ mod n 3 | n <- [0..16] ]
16:03:53 <lambdabot>   fromList [(0,6),(1,6),(2,5)]
16:04:02 <shajen> ok, where is group function i what module :>
16:04:02 <dafis> alexyk: but don't call it fst
16:04:14 <Twey> counts = foldl' (M.insertWith (+) `flip` 1) M.empty
16:04:25 <FunctorSalad> dafis: or foldMap... dunno how it compares
16:04:26 <dafis> shajen: Data.List
16:04:31 <alexyk> dafis: yeah... wouldn't it hurt somebody to have a library module full of fst3, fst4, etc.?
16:04:47 <FunctorSalad> theoretically foldMap is allowed to use the associativity of unioning maps, I think
16:04:48 <ksf> there's nthable
16:04:51 <FunctorSalad> (but doesn't)
16:05:12 <Twey> Oh wait
16:05:13 <FunctorSalad> (so it could run the function on the input structure elements in parallel)
16:05:18 <Saizan> (\(x,_,_) -> x) works fine.
16:05:18 <Twey> Needs arguments the other way around
16:05:24 <dafis> alexyk: It's not needed often enough for somebody to write that library :)
16:05:28 <ksf> http://hackage.haskell.org/packages/archive/nthable/0.1/doc/html/Data-Nthable.html
16:05:45 <alexyk> dafis: I don't believe fst3 is not used often enough!
16:05:52 <ksf> the nice thing is that fst etc. works on one to seven-tuples with that.
16:06:02 <FunctorSalad> @let counts2 = foldMap (\x -> Map.singleton x (Sum 1))
16:06:03 <lambdabot>  <local>:6:10: Not in scope: `foldMap'
16:06:03 <lambdabot>  
16:06:03 <lambdabot>  <local>:6:25: Not in scope: `Map.si...
16:06:07 <FunctorSalad> @let counts2 = Fold.foldMap (\x -> Map.singleton x (Sum 1))
16:06:08 <lambdabot>  <local>:6:10: Not in scope: `Fold.foldMap'
16:06:08 <lambdabot>  
16:06:08 <lambdabot>  <local>:6:30: Not in scope: `M...
16:06:11 <FunctorSalad> @let counts2 = Foldable.foldMap (\x -> Map.singleton x (Sum 1))
16:06:12 <lambdabot>  <local>:6:10: Not in scope: `Foldable.foldMap'
16:06:12 <lambdabot>  
16:06:12 <lambdabot>  <local>:6:34: Not in scope...
16:06:15 <FunctorSalad> @let counts2 = F.foldMap (\x -> Map.singleton x (Sum 1))
16:06:16 <lambdabot>  <local>:6:10: Not in scope: `F.foldMap'
16:06:16 <lambdabot>  
16:06:17 <lambdabot>  <local>:6:27: Not in scope: `Map....
16:06:21 <FunctorSalad> @let counts2 = Data.Foldable.foldMap (\x -> Map.singleton x (Sum 1))
16:06:22 <lambdabot>  <local>:6:39: Not in scope: `Map.singleton'
16:06:22 <lambdabot>  
16:06:23 <lambdabot>  <local>:6:56:
16:06:25 <lambdabot>      Ambiguous ...
16:06:25 <dafis> alexyk: most uses are done with pattern matching
16:06:27 <FunctorSalad> @let counts2 = Data.Foldable.foldMap (\x -> M.singleton x (Sum 1))
16:06:28 <lambdabot>  <local>:6:54:
16:06:29 <chrisdone> oh dear
16:06:29 <lambdabot>      Ambiguous occurrence `Sum'
16:06:31 * hackagebot bindings-eskit 0.0.1 - Bindings to ESKit.  http://hackage.haskell.org/package/bindings-eskit-0.0.1 (AndrewMiller)
16:06:31 <lambdabot>      It could refer to either ...
16:06:33 <chrisdone> FunctorSalad: stop failing
16:06:49 <FunctorSalad> chrisdone: how am I supposed to know how Cale imported them ;)
16:06:56 <chrisdone> FunctorSalad: /msg lambdabot 
16:06:58 <FunctorSalad> @let counts2 = Data.Foldable.foldMap (\x -> M.singleton x (Data.Monoid.Sum 1))
16:06:59 <lambdabot>  Defined.
16:07:05 <FunctorSalad> chrisdone: yes, sorry :(
16:07:08 <chrisdone> :p
16:07:15 <alexyk> ksf: how are tuples aware they are Nthable?
16:07:15 <FunctorSalad> but at least we have a happy end now
16:07:24 <FunctorSalad> > counts2 [1,2,3,1,2]
16:07:25 <lambdabot>   fromList [(1,Sum {getSum = 1}),(2,Sum {getSum = 1}),(3,Sum {getSum = 1})]
16:07:44 <Twey> :t foldl' `flip` empty `fmap` flip $ insertWith (+) `flip` 1
16:07:45 <lambdabot>     Ambiguous occurrence `empty'
16:07:45 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
16:07:45 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
16:07:52 <Twey> :t foldl' `flip` M.empty `fmap` flip $ M.insertWith (+) `flip` 1
16:07:53 <chrisdone> lol
16:07:53 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
16:07:54 <chrisdone> sure is fail in here tonight
16:07:56 <FunctorSalad> chrisdone: at least there was no convo interspersed
16:08:00 <ksf> alexyk, they aren't, nthable is aware of tuples
16:08:05 <shajen> ok it work but not like i want :)
16:08:10 <FunctorSalad> @where shipmentOfFail
16:08:11 <lambdabot> I know nothing about shipmentoffail.
16:08:11 * Twey is starting to think `flip` should be given its own operator.
16:08:15 <chrisdone> FunctorSalad: haha
16:08:17 <alexyk> ksf: so how do I use it?
16:08:37 <FunctorSalad> Twey: how'd that work?
16:08:41 <alexyk> @where shipmentofale?
16:08:42 <lambdabot> I know nothing about shipmentofale?.
16:08:45 <dafis> shajen: What exactly do you want?
16:08:52 <chrisdone> (<>) = (`flip`)
16:08:55 <FunctorSalad> @let (<<<>>>) = flip
16:08:56 <lambdabot>  Defined.
16:08:58 <FunctorSalad> ;)
16:08:58 <Twey> Hehe
16:09:00 <shajen> I want the number of occurrences of each tuple element
16:09:02 <ksf> import Data.Nthable; import Prelude hiding (fst,snd)
16:09:04 <aristid> @src (<*>) [9
16:09:04 <lambdabot> Source not found. I feel much better now.
16:09:08 <aristid> @src (<*>) []
16:09:08 <lambdabot> Source not found. You type like i drive.
16:09:14 <Twey> :t foldl' <<<>>> M.empty `fmap` flip $ M.insertWith (+) <<<>>> 1
16:09:14 <FunctorSalad> I mean since flip takes at least 4 args
16:09:15 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
16:09:19 <aristid> @src [] (<*>)
16:09:19 <FunctorSalad> *3
16:09:19 <lambdabot> (<*>) = ap
16:09:25 <alexyk> ksf: ah, ok.  I tremble at hiding fst though :)
16:09:26 <shajen> [3,1,1,2,1,3,3,3,3] -> [(1,3),(2,1),(3,5)]
16:09:30 <FunctorSalad> if you want to produce a nonfunctional value
16:09:37 <FunctorSalad> (heh)
16:09:38 <dafis> shajen: tuple? Used to be a list
16:09:38 <ksf> @src fst
16:09:39 <lambdabot> fst (x,_) =  x
16:09:43 <ksf> you're not missing much
16:10:00 <Twey> FunctorSalad: Currying? :þ
16:10:01 <FunctorSalad> > mappend <<<>>> "foo" "bar"
16:10:02 <lambdabot>   Couldn't match expected type `t -> a'
16:10:03 <lambdabot>         against inferred type `[GHC.T...
16:10:09 <FunctorSalad> > (mappend <<<>>> "foo") "bar"
16:10:10 <lambdabot>   "barfoo"
16:10:17 <FunctorSalad> Twey: you need these ugly parens
16:10:20 <alexyk> is Data.Nthable a standard package in ghc?
16:10:21 <Twey> > mappend <<<>>> "foo" $ bar
16:10:22 <lambdabot>   Not in scope: `bar'
16:10:25 <Twey> Oops
16:10:25 <FunctorSalad> well, not ugly, but need to be typed
16:10:26 <Twey> > mappend <<<>>> "foo" $ "bar"
16:10:27 <lambdabot>   "barfoo"
16:10:29 <shajen> i want to  number of occurrences but also this element
16:10:30 <FunctorSalad> ok
16:10:32 <dafis> shajen: you can get that list from the Map via toList
16:10:34 <Twey> ;)
16:10:50 <chrisdone> FunctorSalad: haha how long have you been using haskell?
16:10:53 <chrisdone> :P
16:10:56 <aristid> are list comprehensions equal in power to Applicative?
16:10:59 <FunctorSalad> chrisdone: :(
16:11:03 <Twey> Hehe
16:11:11 <FunctorSalad> chrisdone: I *do* know one is not required to fully apply a function :(
16:11:12 <Twey> aristid: No o.@
16:11:16 <FunctorSalad> BUT
16:11:22 <dafis> > Data.Map.toList (counts [3,1,1,2,1,3,3,3,3])
16:11:23 * chrisdone pours sugar canes and ice cream down FunctorSalad's shirt to cheer him up
16:11:23 <lambdabot>   Not in scope: `Data.Map.toList'
16:11:31 <aristid> Twey: i mean just looking at the [] instance
16:11:42 <ksf> aristid, comprehensions are monadic
16:11:44 <Twey> aristid: Then no, it's more powerful
16:11:45 <FunctorSalad> it'd only help if "flip" is applied to exactly two args
16:11:47 <shajen> dafis: howto
16:11:48 <ksf> so they're more powerful
16:11:52 <dafis> > Map.toList (counts [3,1,1,2,1,3,3,3,3])
16:11:53 <lambdabot>   Not in scope: `Map.toList'
16:11:56 <FunctorSalad> with one arg, you need prefix notation, which is even more to type
16:12:11 <aristid> > [ x, x + 1 | x <- [1,2,3] ]
16:12:12 <lambdabot>   <no location info>: parse error on input `|'
16:12:16 <Twey> FunctorSalad: Aye
16:12:21 <aristid> what's wrong with this join?
16:12:25 <Twey> But I seem to find myself applying it to two args very often
16:12:36 <Twey> When I want to skip an arg when currying
16:12:39 <FunctorSalad> Twey: hmm good point
16:12:40 <aristid> > join [ [x, x + 1] | x <- [1,2,3] ]
16:12:41 <lambdabot>   [1,2,2,3,3,4]
16:12:56 <FunctorSalad> (actually the fully applied case is probably the rarest, silly me)
16:13:04 <Twey> Yeah ☺
16:13:21 <alexyk> is there a fold adapter which makes things like + need no seed?  like reduce?
16:13:21 <ksf> join for lists is just concat
16:13:23 <FunctorSalad> can be used to put the shorter arg first though ;)
16:13:26 <ksf> and bind is concatMap
16:13:34 <chrisdone> alexyk: foldr1
16:13:35 <FunctorSalad> if you're afraid you will have forgotten what it should be after the long other arg
16:13:37 <aristid> ksf: yeah, but i can't see the join in a list comprehension
16:14:03 <ksf> ...because it's a concatMap
16:14:04 <Twey> ksf: flip concatMap ;)
16:14:09 <alexyk> chrisdone: why not foldl1 which exists?
16:14:29 <Twey> It's not strictly a concatMap, is it?
16:14:29 <aristid> ksf: how to make this fully into a list comprehension? join [ [x, x + 1] | x <- [1,2,3] ]
16:14:29 <chrisdone> alexyk: sure, both exist
16:14:33 <FunctorSalad> alexyk: you should be really sure the list isn't empty
16:14:38 <Twey> Because you can only return at most one item
16:14:41 <FunctorSalad> or it'll rain "user error"s
16:14:45 <alexyk> FunctorSalad: am mighty sure
16:14:52 <FunctorSalad> > foldr1 (+) []
16:14:53 <lambdabot>   *Exception: Prelude.foldr1: empty list
16:14:54 <Twey> (without an external join/concat)
16:15:00 <aristid> Twey: which is why i think it's Applicative only.
16:15:08 <FunctorSalad> hmm, that one wasn't "user error"
16:15:18 <ksf> > concatMap (\x -> [x,x+1]) [1,2,3]
16:15:19 <lambdabot>   [1,2,2,3,3,4]
16:15:23 <chrisdone> it's still an error call
16:15:24 <Twey> aristid: No, it's monadic, just limited to returning a single value
16:15:24 <ksf> dunno I never use them
16:15:25 * FunctorSalad is amused by said "user error"s
16:15:27 <alexyk> do the same logic apply to foldl1 as to foldl'?  is there a foldl1'?
16:15:41 <Twey> Which is probably due to its origins as a generic monad comprehension
16:15:41 <alexyk> wow it exists too
16:15:41 <ksf> > [1,2,3] >>= (\x -> [x,x+1])
16:15:42 <chrisdone> iirc
16:15:43 <lambdabot>   [1,2,2,3,3,4]
16:15:43 <FunctorSalad> it's referring to the "user" of ghc (the developer), isn't it?
16:15:48 <alexyk> :t foldl1'
16:15:50 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:16:11 <alexyk> what a fine way to confuse a python user
16:16:19 <FunctorSalad> how so?
16:16:24 <chrisdone> fold*1 are cute for clever code
16:16:37 <chrisdone> but it's best to avoid partial functions altogether if you can help it
16:16:40 <alexyk> just for fun, they'd wonder why 1 and '
16:17:05 <Twey> Heh
16:17:10 <Twey> Because that's Python ‘reduce’
16:17:12 <alexyk> why not '1
16:17:26 <ksf> because ticks come always at the end
16:17:28 <alexyk> yeah, and in haskell it's called something weird
16:17:36 <aristid> Twey: what can be done with list comprehensions that can't be done with Applicative?
16:17:38 <kmc> in Python it's called something weird ;P
16:17:47 <chrisdone> PRYM
16:18:05 <ksf> python stole it from google, which called it reduce to look better on powerpoint presentations
16:18:18 <kmc> haha
16:18:33 <alexyk> google needs no powerpoint, though
16:18:40 <ksf> "reduce! see, we _reduce_ our costs with that!"
16:18:45 <alexyk> nobody to show it to, really -- VCs?
16:18:53 <Philonous> Also, mapFold sounds rather stupid, for what it's worth
16:19:03 <FunctorSalad> if round parentheses took less physical effort to reach, there'd be a lot less sugar in .hs ;)
16:19:08 <chrisdone> thanks for sharing that with us
16:19:16 <FunctorSalad> they should be where f and j are now or something
16:19:38 <chrisdone> FunctorSalad: could always bind it =)
16:19:50 <kmc> people complain no matter what things are called
16:19:53 <FunctorSalad> chrisdone: where to put f and j then?
16:19:56 <chrisdone> personally i avoid typing two chars at once so i hit CAPS for upper case
16:20:01 <ksf> there's concatStateMap which subsumes concatMap and fold, but I think nobody but me ever needed it
16:20:01 <chrisdone> so Shift+f = (
16:20:07 <kmc> when Haskell uses mainstream terms (e.g. return) it's considered confusing and misleading
16:20:23 <kmc> and when Haskell uses new terms, or terms from math or FP, it's considered confusing and alienating
16:20:47 <kmc> one advantage of "avoid success at all costs" is that the tendency to bikeshed over these issues is slightly reduced
16:20:52 <chrisdone> yeah haskell's like that not nerdy not jocky kid who tries to be everyone's friend
16:20:54 <FunctorSalad> in the first case it's more the misuse of a mainstream term, isn't it ;)
16:21:03 <FunctorSalad> chrisdone: haha
16:21:11 <kmc> yeah, but almost everything in Haskell is subtly different
16:21:24 <kmc> because differences like laziness are pervasive
16:21:25 <ksf> "return" _is_ confusing
16:21:25 <alexyk> chrisdone: that's what the kid thinks, anyway
16:21:41 <kmc> and i do think "return" is a poor choice btw
16:21:45 <chrisdone> he wears a band t shirt but it's Kenny Rogers, and he reads Artemis Fowl, not Dune
16:21:50 <ksf> i'd use pure everywhere if that wouldn't elongenate the context
16:21:56 <kmc> once Applicative / Monad are rationalized, we can use "pure"
16:22:01 <chrisdone> kmc: yeah i thought unit was ok
16:22:02 <kmc> enlarge your context 400%
16:22:04 <FunctorSalad> kmc: reduced bikeshed? in haskell?
16:22:23 <FunctorSalad> thought were already sticking to the ceiling
16:22:27 <FunctorSalad> *we're
16:22:29 <alexyk> make your monad crave for more
16:22:40 <kmc> also, look at C++, where they decided everything should look like C "for familiarity" and have massively more complicated semantics
16:22:57 <ksf> c++ has semantics?
16:23:06 <FunctorSalad> (expressed that badly. I meant to ask how you could possibly have any more bikeshedding ;))
16:23:09 <ksf> I'd like to see a proof of that.
16:23:17 <dafis> c++ -1
16:23:20 <FunctorSalad> :D
16:23:23 <alexyk> succ c
16:23:24 <dafis> @karma c++
16:23:24 <lambdabot> c++ has a karma of -4
16:23:29 <dafis> Uff
16:23:38 <ksf> @karma php
16:23:39 <lambdabot> php has a karma of 0
16:23:41 <FunctorSalad> someone explained here that sql has "shotgun semantics"
16:23:43 <ksf> @karma ocalm
16:23:43 <lambdabot> ocalm has a karma of 0
16:23:43 <shajen> ok i have :)
16:23:45 <shajen> great
16:23:45 <aristid> @src guard
16:23:45 <lambdabot> guard True  =  return ()
16:23:46 <lambdabot> guard False =  mzero
16:23:46 <ksf> @karma ocaml
16:23:46 <lambdabot> ocaml has a karma of 0
16:23:55 <ksf> @karma c
16:23:55 <alexyk> o. so calm
16:23:56 <lambdabot> c has a karma of 2
16:24:12 <alexyk> @karma brainfuck
16:24:12 <lambdabot> brainfuck has a karma of 0
16:24:13 <FunctorSalad> (the syntax tree is shot against a wall and one sees what sticks, or something like that)
16:24:18 <aristid> @let guardA = case x of True -> pure (); False -> empty
16:24:19 <lambdabot>  <local>:8:45:
16:24:19 <lambdabot>      Ambiguous occurrence `empty'
16:24:19 <lambdabot>      It could refer to eithe...
16:24:28 <aristid> @let guardA = case x of True -> pure (); False -> Control.Applicative.empty
16:24:29 <lambdabot>  <local>:8:19:
16:24:29 <lambdabot>      Couldn't match expected type `Expr' against inferred type...
16:24:37 <aristid> @let guardA x = case x of True -> pure (); False -> Control.Applicative.empty
16:24:38 <lambdabot>  Defined.
16:24:38 <kmc> yr. x is free
16:24:42 <kmc> :t guardA
16:24:42 <lambdabot> forall (f :: * -> *). (Alternative f) => Bool -> f ()
16:25:06 <ksf> and we should finally get rid of fail in Monad and make a MonadFail
16:25:14 <kmc> (,) <$> guardA False <*> putStrLn "hello"
16:25:16 <kmc> will still print yes?
16:25:34 <kmc> well i suppose IO isn't alternative anyway
16:25:37 <aristid> :t (,) <$> guardA False <*> putStrLn "hello"
16:25:37 <ksf> and if you want to have non-matching patterns, you have to have an instance of MonadFail.
16:25:38 <lambdabot>     No instance for (Alternative IO)
16:25:39 <lambdabot>       arising from a use of `guardA' at <interactive>:1:8-19
16:25:39 <lambdabot>     Possible fix: add an instance declaration for (Alternative IO)
16:25:45 <FunctorSalad> that pattern seems to be very common, kmc
16:25:52 <chrisdone> kmc: it would have to be an error anyway?
16:25:54 <FunctorSalad> sugar for it might not hurt
16:26:02 <kmc> yeah, the natural semantics for Alternative IO would involve exceptions
16:26:14 <kmc> what i'm getting at is, Applicative doesn't let you do conditional "effects"
16:26:21 <kmc> and it seems like that's mostly where guardA would be useful
16:26:51 <FunctorSalad> (I just meant the "(PREFIXOP) <$> x <*> y" btw, not the issue at hand)
16:27:15 <ksf> that's the very essence of applicatives
16:27:31 <angel_de_vicente> hi all, my first time in IRC, be gentle... :-)
16:27:39 <ksf> alongside with goodies like *> and <$
16:27:44 <kmc> hi angel_de_vicente
16:27:58 <angel_de_vicente> I sent a message to fa.haskell about something that has been bothering me today
16:28:25 <angel_de_vicente> but no replies yet. Can I ask for help in here?
16:28:33 <dafis> angel_de_vicente, sure
16:28:35 <ksf> I don't know, let's check
16:28:38 <ksf> can you type?
16:28:53 <kmc> yes angel_de_vicente :)
16:29:06 <kmc> it is almost impossible to learn Haskell without asking questions here ;)
16:29:19 <kmc> (also what's fa.haskell ?)
16:29:27 <angel_de_vicente> Basically is how to solve f(n) = max(n,f(n/2)+f(n/3)+f(n/4)) with memoization or some other way, so as to do it efficiently
16:29:29 <aristid> oh, guardA seems to be relatively pointless.
16:29:37 <ksf> kmc, a newsgroup
16:29:38 <dafis> kmc: I doubt the Simons asked questions here
16:29:54 <ksf> angel_de_vicente, most stuff happens on the haskell-cafe mailing list
16:30:00 <ksf> you can get at it via gmane, too.
16:30:05 <kmc> if Simon Peyton-Jones did not exist it would be necessary to invent him
16:30:21 <aristid> the join required for using guard wasn't obvious to me :D
16:30:35 <FunctorSalad> @typ guardA
16:30:36 <lambdabot> forall (f :: * -> *). (Alternative f) => Bool -> f ()
16:30:37 <angel_de_vicente> ksf: I think all the haskell-caffe and haskell-beginners stuff gets redirected to fa.haskell
16:30:51 <ksf> ...but not the other way round, does it?
16:30:53 <FunctorSalad> looks like it'd be fine for lists
16:30:54 <kmc> angel_de_vicente, data-memocombinators is a nice memoization library
16:31:08 <aristid> FunctorSalad: how to get the Bool in there?
16:31:08 <FunctorSalad> [] efficiently cuts off the rest of the list-monadic computation, no?
16:31:13 <kmc> or you can fold over inserts to a map, if you want to do it explicitly
16:31:24 <FunctorSalad> aristid: ah, that's the issue? ok
16:32:26 <angel_de_vicente> data-memcombinators... OK, I hadn't heard of that. I will check
16:32:36 <aristid> this proves to me that list comprehensions are monadic with a stupid restriction
16:33:09 <wli> aristid: A lot of people would like monad comprehensions back.
16:33:14 <kmc> you mean that comprehension syntax is a special case of "do" syntax?
16:33:30 <angel_de_vicente> kmc: fold over inserts to a map? (Sorry, I just read the first 100 pages of RWH, so can you give me an example?)
16:33:31 <dafis> kmc: was
16:33:33 <aristid> wli: did they allow for more than one element left to the | ?
16:33:49 <kmc> dafis, it's a special case now, it used to be equivalent
16:34:22 <kmc> angel_de_vicente, what i mean is that you can memoize into a Map (or an IntMap)
16:34:33 <kmc> and pass it along as an "accumulating parameter"
16:34:38 <kmc> and this probably has the structure of a fold, though i'm not sure
16:34:43 <dafis> kmc: yes, in Haskell 1.4, I think
16:34:45 <kmc> anyway data-memocombinators is likely easier
16:35:13 <angel_de_vicente> kmc: OK, I will start then with data-memocombinators then
16:35:25 <aristid> kmc: list comprehensions always use fmap at the outestmost position
16:36:05 <aristid> well, or at least return
16:36:09 <kmc> yeah
16:36:14 <kmc> but you can always convert a do-block into that form
16:36:18 <angel_de_vicente> Thanks for you help (being a newbie, IRC feels weird with all the mixed conversations... it looks like a busy bar on a Saturday Night)
16:36:48 <dafis> angel_de_vicente, Sunday morning, when nobody's sober anymore :)
16:36:48 <kmc> angel_de_vicente, yes, sometimes people here are even drunk ;)
16:37:41 <aristid> kmc: and if you encapsulate the list comprehension in a single join, i think you get the full power back
16:38:02 <kmc> err it's still restricted to []
16:40:04 <aristid> kmc: we can abstract from that :P
16:42:19 <chrisdone> Cale's always drunk, that's how he maintains such lucidity
16:42:35 <chrisdone> @users
16:42:36 <lambdabot> Unknown command, try @list
16:42:39 <chrisdone> @activity
16:42:39 <lambdabot> 8*total 7*private 1*#haskell
16:43:07 <FunctorSalad> ^^
16:43:42 * hackagebot bytestring-trie 0.2.2 - An efficient finite map from (byte)strings to values.  http://hackage.haskell.org/package/bytestring-trie-0.2.2 (WrenThornton)
16:44:07 <FunctorSalad> ^^^^^ I like
16:44:11 <FunctorSalad> (bytestring-trie)
16:44:40 <kmc> yes
16:44:51 <FunctorSalad> I dumped the (inverse of) the dpkg-L output of every package I have installed in there...
16:45:07 <kmc> inverse?
16:45:17 <FunctorSalad> lookup is instant perceptually, deserializing the whole thing from HDD is about 2 seconds
16:45:38 <FunctorSalad> dpkg -L packagename prints a list of packagename:file... my trie maps files to lists of packages
16:45:49 <FunctorSalad> (lists because there may be more than one owner)
16:45:59 <kmc> right
16:46:13 <kmc> i was wondering if by "inverse" you meant "reverse", because that would be a clever way to accelerate the lookup potentially
16:46:31 <kmc> i mean almost every file starts with "/usr"
16:46:33 <FunctorSalad> charwise inverse of every filepath?
16:47:02 <FunctorSalad> I thought tries were designed to take advantage of exactly that kind of data
16:47:14 <FunctorSalad> they generally save a prefix only once, no?
16:47:27 <kmc> at some point the Linux dynamic linker started doing symbol comparison from the end instead of the beginning and this makes a huge difference in the load time of programs
16:47:33 <kmc> C++ programs particualrly
16:47:51 <FunctorSalad> what operation? for string-comparing two paths it makes sense
16:47:55 <FunctorSalad> but trie storage?
16:47:56 <kmc> right
16:48:32 <kmc> the trie stores the path only once, yes
16:48:39 <FunctorSalad> maybe I'm thinking of some special kind of trie... 
16:48:42 <aristid> FunctorSalad: tries would probably bleed because their aren't enough similar prefixes
16:48:54 <kmc> but if it's one character per node, it'll still be four indirections to get past "/usr"
16:49:07 <FunctorSalad> the one where you'd have a node representing "/usr", assuming there is no file that starts with "/us[^r]"
16:49:08 <aristid> hmmm
16:49:21 <FunctorSalad> (two levels skipped)
16:49:36 <kmc> i'm not sure if bytestring-trie skips levels like that
16:49:38 <dolio> Smart tries wouldn't have four indirections for that unless necessary.
16:49:55 <wli> Use a hash trie or something.
16:50:58 <FunctorSalad> kmc: ah, this http://en.wikipedia.org/wiki/Patricia_trie
16:51:06 <dolio> Right.
16:51:24 <kmc> that's what bytestring-trie uses i think
16:52:11 <FunctorSalad> the acronym seems a bit suspicious. thought he named them after his girlfriend
16:52:16 <kmc> hehe
16:52:45 <kmc> hurr computer scientists don't have girlfriends hurrr
16:53:03 <FunctorSalad> :D
16:54:48 <alexyk> is Map.fold as efficient as foldl'?
16:55:07 <dolio> It's probably more like foldr.
16:55:08 <alexyk> kmc: right, they have wives and kids
16:56:20 <kmc> the only guarantee is "O(n)"
16:57:05 <FunctorSalad> alexyk: hmm, Map is a tree internally; it'd traverse the tree
16:57:26 <kmc> it's defined in terms of an internal post-order fold function
16:57:30 <FunctorSalad> folding in parallel with an associative operation might be more efficient
16:57:35 <kmc> which is tail-recursive (meaning not obviously productive)
16:57:53 <alexyk> FunctorSalad: right, so all the List pitfalls don't apply any more right? i.e. no need for foldl' etc?
16:57:53 <kmc> foldr f z (Bin _ kx x l r) = foldr f (f kx x (foldr f z r))
16:58:09 <alexyk> kmc: do you know it by heart?
16:58:34 <FunctorSalad> alexyk: no idea about strictness issues with Map's internal tree
16:59:09 <FunctorSalad> I guess you wouldn't get stack overflows like with foldl and foldr, since the chains are only O(log(n)) long
16:59:30 <FunctorSalad> hmm or maybe that doesn't save us
16:59:35 <kmc> nope
16:59:45 <FunctorSalad> it builds thunks anyway? ok
16:59:50 <dolio> kmc: That looks like some kind of in-order to me.
16:59:59 <kmc> they call it 'post-order"
17:00:04 <kmc> in the comments
17:00:06 <alexyk> does it make sense to do toList with a foldl'?
17:00:08 <dolio> Huh.
17:00:31 <alexyk> *thunky music playing*
17:01:30 <kmc> play that thunky music white boy
17:01:48 * hackagebot Advgame 0.1.2 - Lisperati's adventure game in Lisp translated to Haskell  http://hackage.haskell.org/package/Advgame-0.1.2 (TimWawrzynczak)
17:06:30 <FunctorSalad> foldMap f (Bin' l r) = let { x = foldMap f l; y = foldMap f r } in par x (par y (mappend x y))
17:06:40 <FunctorSalad> seems like that'd be a nice fold for maps as long as your op is associative
17:06:51 <FunctorSalad> maybe foldMap for maps does this, dunno
17:19:07 <mauke> "The easiest way to describe Cell War is that it's the game of Go played with the rules of Conway's Game of Life"
17:20:14 <tensorpudding> damn
17:20:28 <dafis> wot
17:21:42 <theorbtwo> Sounds interesting, mauke.
17:30:24 <gwern> mauke: actually, that does sound kind of interesting. the rules of Life do allow for eyes, I think...
17:32:08 <ezyang> If I have a Haskell module that needs to be statically linked with some other thing, is there a way to load it up in GHCI? 
17:32:27 <gwern> wonder if Wine can handle win16
17:33:58 <gwern> hm, seems so
17:35:04 <mklappst1hl> im wondering: why is learnyouahaskell.com not on this page: http://www.haskell.org/learning.html
17:35:47 <gwern> mklappst1hl: from the looks of it, it's a student-oriented non-editable page which was written years and years ago
17:35:51 <gwern> that's why
17:38:15 <mklappst1hl> okay, there is a pretty prominent link on the german wikipedia article 'haskell'
17:38:43 <mklappst1hl> good night then
17:40:27 <gwern> huh. Cell War is kind of strange
17:45:34 <kmc> lernen Sie eine Haskell?
17:46:18 <aristid> i thin haskell would be neuter, and Sie is too formal for lyah. good night.
17:46:30 <tensorpudding> eine kleine nachthaskell
17:48:44 <aristid> tensorpudding: i think that haskell is not linguistically female.
17:50:39 <tensorpudding> yes she is
17:51:04 <c_wraith> Haskell was quite male
17:51:07 <aristid> in german, girls aren't female either.
17:51:29 <aristid> das Mädchen, das Haskell :P
17:53:19 <gwern> mauke: hm, I dunno. I've played 5 or 10 rounds with the smart AI, and it looks like once you've positioned yourself in the no-evaluation period, it's a pretty straightforward encirclement game
17:53:23 <gwern> strategically
18:01:33 * gwern wins another round handily
18:01:42 <gwern> mauke: yeah, there's definitely something broken in Cell War
18:01:53 <gwern> maybe it's the double-move mechanic
18:01:55 <Veinor> what's Cell War?
18:02:44 <gwern> Veinor: a cross between Life and Go
18:02:49 <Veinor> so I see.
18:03:07 <gwern> http://www.classicdosgames.com/genre/strategy.html[
18:05:00 <alexyk> for Map, update* family assumes the key is present.  What's upsert -- update or insert?
18:05:49 <alexyk> alter I guess
18:07:39 <alexyk> if I have expr ... f where f = ... g ... where g = ..., do I have to have the second where?
18:08:04 <gwern> alexyk: isn't insertWithKey the solution for that?
18:08:11 <dolio> insertWith is an option. I can't remember what alter does.
18:08:42 <alexyk> insert*s all a k->a ... and not Maybe a
18:09:50 <Veinor> alexyk: I don't believe you do
18:09:55 <Veinor> assuming you're doing these on separate lines
18:14:54 <alexyk> :t alter
18:14:55 <lambdabot> Not in scope: `alter'
18:15:04 <alexyk> :t Data.Map.alter
18:15:05 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
18:18:25 <alexyk> ksf: will Nthable screw up performance?
18:23:51 <Veinor> blah, I need to script more.
18:24:06 <Veinor> I want to write an actual Haskell program but I have no clue what I want to write.
18:35:56 <insaneavocado> :r
18:36:12 <kmc> Ok, modules loaded: none.
18:37:38 <freedrull> anyone know of any haskell programs that use SDL bindings for audio
18:38:31 <freedrull> it doesnt look like there are any functions for it: http://hackage.haskell.org/packages/archive/SDL/0.5.3/doc/html/Graphics-UI-SDL-Audio.html
18:41:08 <gwern> bindings, like sdl-mixer or sdl-mpeg?
18:41:11 <gwern> perish the thought
18:52:04 <alexyk> can this be shortened: http://paste.pocoo.org/show/224130/
18:53:39 <alexyk> i.e. factoring out the trailing Map.empty or not
18:54:23 <kmc> @faq can this be shortened
18:54:24 <lambdabot> The answer is: Yes! Haskell can do that.
18:54:42 <kmc> :t M.singleton
18:54:42 <lambdabot> forall k a. k -> a -> M.Map k a
18:57:21 <alexyk> cute!  But I was thinking along the lines, factor out the tailing map and push alternatives into a case, then it all is M.insert key val mapFromAbove
18:57:36 <alexyk> makes sense?
18:58:56 <kmc> oh sure
18:59:14 <kmc> addDay m = M.insert day soc $ fromMaybe M.empty m
19:00:06 <alexyk> o!
19:00:28 <alexyk> superb
19:00:47 <kmc> :)
19:00:50 <alexyk> that'll make my monad cry all night!
19:01:06 * alexyk still interpreting spam subjects in haskell
19:01:10 <kmc> heh
19:09:51 <freedrull> gwern: whats the alternative
19:18:13 <alexyk> I have a Map String (Map Int Float).  How do I implement a lookup getIn m a b, where m is the structure and a is String and b is Int, so that it returns Nothing if any is missing and Just x only if both are present, with Maybe?
19:18:56 <aavogt> can you rephrase that?
19:19:38 <aavogt> @type M.lookup ?b <=< M.lookup ?a
19:19:39 <lambdabot> forall k c k1. (?b::k, Ord k, ?a::k1, Ord k1) => M.Map k1 (M.Map k c) -> Maybe c
19:20:12 <alexyk> aavogt: basically I have a nested map.  I need a deep lookup which takes the map, a path of keys, and needs to short-circuit to Nothing if the path hits a missing key at any point
19:20:21 <aavogt> @type on (<=<) M.lookup
19:20:22 <lambdabot>     Occurs check: cannot construct the infinite type: b = M.Map a b
19:20:22 <lambdabot>       Expected type: b
19:20:22 <lambdabot>       Inferred type: M.Map a b
19:20:27 <kmc> "short circuiting to Nothing" is precisely what the Monad instance for Maybe does
19:20:38 <joeyh> hi, is Either really a functor? Having trouble getting something like this to type check: fmap (+1) (Right 1)
19:20:45 <ezyang> Hey guys, where does the Cabal user guide live? I want to submit a patch. 
19:20:57 <kmc> > fmap (+1) (Right 1)
19:20:57 <lambdabot>   Right 2
19:20:59 <ezyang> joeyh: It is. 
19:21:05 <kmc> joeyh, import Control.Monad.Instances, i think
19:21:06 <aavogt> well you could have asked for the type of the function I wrote
19:21:23 <aavogt> orphans!
19:21:26 <joeyh> kmc: thanks, that was it
19:21:34 <kmc> :t \a b -> M.lookup a >=> M.lookup b
19:21:34 <lambdabot> forall k k1 c. (Ord k, Ord k1) => k -> k1 -> M.Map k (M.Map k1 c) -> Maybe c
19:21:45 <alexyk> aavogt: <=< would compose them monads?
19:22:10 <aavogt> exactly
19:22:19 <alexyk> kmc: my client renders a tadpole devil in between the lookups
19:22:22 <joeyh> I have to say that as a lefthanded person, I find Haskell's right-handedness occasionally disturbing, especially fmap's behavior on Either :)
19:22:45 <alexyk> aavogt: am clueless still how to employ it :)
19:22:55 <kmc> haha
19:23:26 <alexyk> kmc: was it <=< there?
19:23:37 <aavogt> @src (<=<)
19:23:37 <lambdabot> Source not found. I am sorry.
19:23:47 <aavogt> the two are the same, just with arguments flipped
19:23:56 <alexyk> >=>
19:24:02 <alexyk> ok, that's the devil
19:24:10 <alexyk> Colloquy consider it such
19:24:25 <aavogt> the values in the function you create flow in the direction of the arrow
19:24:49 <alexyk> where's the original map's position in the argument list?
19:25:22 <alexyk> i.e. where I apply kmc's lambda
19:25:37 <aavogt> kmc's lambda doesn't name the map
19:25:54 <alexyk> aavogt: so I guess it's in the tail
19:26:48 <aavogt> I dunno if it's a good idea to think of arguments as lists... you can't manipulate them like such without going to quite a bit of trouble
19:27:53 <kmc> mine is points free
19:27:55 <kmc> in the maps
19:28:15 <kmc> :t \a b m -> M.lookup a m >>= \n -> M.lookup b n
19:28:15 <lambdabot> forall k k1 b. (Ord k, Ord k1) => k -> k1 -> M.Map k (M.Map k1 b) -> Maybe b
19:28:37 <kmc> :t \a b m -> do { n <- M.lookup a m; M.lookup b n }
19:28:38 <lambdabot> forall k b k1. (Ord k, Ord k1) => k -> k1 -> M.Map k (M.Map k1 b) -> Maybe b
19:33:27 <alexyk> kmc: so sticking a lookup in a do block activates the Maybe monad somehow? :)
19:34:04 <alexyk> or do I have to have import Data.Maybe and Control.Monad and such in scope
19:34:22 <aavogt> what is this about "activating"?
19:34:33 <kmc> you need the "instance Monad Maybe" in scope but that's in Prelude
19:34:37 <aavogt> the instance for Monad Maybe  should be in the predlue
19:34:46 <kmc> otherwise "do" is just sugar for (>>=)
19:34:47 <alexyk> aavogt: I mean the >>= has to come from the Maybe right
19:34:53 <kmc> and that's just an ordinary typeclass function
19:35:05 <kmc> so it's much like using (+) from Num or whatever
19:35:08 <alexyk> ok
19:35:12 <kmc> it will pick the instance from the types you use it at
19:35:20 <kmc> and if that's ambiguous it will tell you
19:35:40 <kmc> (which is pretty rare; more often you just end up writing code that works in every Monad and the type stays general)
19:36:01 <aavogt> kmc: you do?
19:36:10 <kmc> more often than getting an ambiguity error
19:36:23 * aavogt finds that most functions that work in any Monad are already in Control.Monad
19:36:32 <kmc> it's hard to run into a (show . read) sort of problem with Monad
19:37:33 <aavogt> kmc: right, there's no general   Monad m => m a -> a  function out there
19:38:01 <kmc> unsafePerformAnything
19:39:02 * ezyang was suprised to find more variants of unsafePerform* than he originally thought existed. 
19:40:19 <alexyk> >=> is lovely
19:40:40 <alexyk> a real tadpole with horns
19:41:28 <alexyk> http://giraffian.com/pictionary-files/t/tadpole.png
19:41:41 <alexyk> (hornless)
19:46:03 * alexyk finds hoogling by type sig fascinating
19:53:01 <alexyk> how acceptable is shadowing Maybe names like: case x of { Just x -> ... }?
19:53:26 <aavogt> shadowing makes things confusing
19:53:48 <aavogt> but it's not so dangerous if the types are different
19:54:34 <alexyk> it's annloying to unwrap and come up with names when not needed
19:55:10 <robertmassaioli> um doesn't (<-) have the type (Monad m) => m a -> a because it takes a result out of a monad or did I get that wrong?
19:55:20 <aavogt> what's <-?
19:55:30 <alexyk> is there any syntactic convention to represent Maybe's?  case fatMaybeX of { Just x -> ...}
19:55:30 <aavogt> oh, part of do notation
19:55:32 <robertmassaioli> like in do notation when 
19:55:36 <robertmassaioli> yeah
19:55:48 <aavogt> robertmassaioli: sure, you can think of it that way
19:56:09 <aavogt> but you aren't allowed that type overall
19:56:35 <robertmassaioli> aavogt: I don't think I know enough to say either way. :) How do you mean?
19:56:59 <kmc> <- in "do" is special syntax
19:57:02 <aavogt> I mean you can't end with   x <- y
19:57:08 <kmc> it's actually sugar for a combination of (>>=) and a lambda function
19:57:19 <kmc> and so it doesn't have a well-defined type, as a regular operator would
19:57:50 <aavogt> kmc: why not think of it as a function? It takes a pattern and an expression...
19:58:15 <robertmassaioli> yes it is and I understand what you are getting at now
19:58:42 <FunctorSalad> I don't think you can translate it to a valid expression on its own
19:58:58 <FunctorSalad> what goes in the body of said lambda is the rest of the do block
19:59:00 <danharaj> you can't
19:59:07 <kmc> every monad lets you do «m (m a) -> m a» and «a -> m a» but not necessarily «m a -> a»
19:59:20 <danharaj> the last line in a do block has to be something
19:59:25 <aavogt> @type (>>=)
19:59:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:59:31 <aavogt> it lets you do that though
19:59:50 <aavogt> which is  m a -> a, with restrictions on `a'
20:00:02 <danharaj> that is not m a -> a
20:00:26 <aavogt> that it eventually has to end up back in `m'
20:00:34 <aavogt> danharaj: I don't make sense?
20:00:55 <FunctorSalad> you might be able to express that as a continuation
20:01:05 <robertmassaioli> It has to otherwise you could call an IO function in a pure one and alot of nice stuff would break.
20:01:06 <FunctorSalad> the "eventually has to end up"
20:01:07 <danharaj> aavogt: I think it is misleading.
20:01:15 <kmc> me too
20:01:22 <kmc> as is this idea of "IO function" versus "pure function"
20:01:27 <kmc> you can call an "IO function" anywhere
20:01:35 <kmc> what you get back is an action
20:01:37 <interferon> what does the ST stand for in Control.Monad.ST?
20:01:46 <aavogt> state transformer
20:02:04 <FunctorSalad> m a -> ContT m r a
20:02:11 <FunctorSalad> exists, doesn't it...
20:02:13 <FunctorSalad> ;)
20:02:29 <interferon> aavogt: thanks
20:02:32 <FunctorSalad> @unmtl ContT m r a
20:02:32 <lambdabot> (a -> r m) -> r m
20:02:40 <FunctorSalad> @unmtl m a -> ContT m r a
20:02:40 <lambdabot> m a -> ContT m r a
20:02:48 <FunctorSalad> :p
20:03:02 <FunctorSalad> public service: m a -> (a -> r m) -> r m
20:03:13 <FunctorSalad> and I mixed up the order of params
20:03:13 <aavogt> r?
20:03:21 <aavogt> too much ML?
20:03:22 <kmc> @unmtl ContT m r a
20:03:22 <lambdabot> (a -> r m) -> r m
20:03:25 <FunctorSalad> @unmtl m a -> ContT r m a
20:03:25 <lambdabot> m a -> ContT r m a
20:03:39 <FunctorSalad> @unmtl ContT r m a
20:03:40 <lambdabot> (a -> m r) -> m r
20:03:47 <FunctorSalad> aavogt: why'd ML make you do it?
20:04:05 <FunctorSalad> aavogt: 'r' is the traditional name for the first param of Cont ;)
20:04:06 <aavogt> because type constructors are postfix
20:04:12 <FunctorSalad> probably for "(final) result" 
20:04:17 <FunctorSalad> ah :)
20:04:22 <FunctorSalad> just didn't remember ContT
20:04:39 <aavogt> FooT
20:04:44 <aavogt> IOT
20:05:03 <aavogt> aavogT
20:05:06 <FunctorSalad> folklore is that IOT would be useless
20:05:15 <aavogt> or dangerous
20:05:16 <BMeph> Id IOT...
20:05:16 <kmc> useless *and* dangerous
20:05:16 <FunctorSalad> don't remember why
20:05:29 <kmc> where would this world be without useless, dangerous things
20:05:48 <aavogt> FunctorSalad: because (IOT [] a) undoes side effects
20:06:00 <aavogt> depending on your non-determinism
20:06:06 <aavogt> or something like that
20:06:11 <aavogt> @unmtl IOT [] a
20:06:12 <lambdabot> IOT [] a
20:06:18 <aavogt> @unmtl ListT IO a
20:06:18 <lambdabot> IO [a]
20:06:27 <aavogt> so IOT [] a = [IO a]
20:06:30 <FunctorSalad> kmc: "where'd we be if everyone asked where we'd be and nobody went there to see where we'd be if we went there" -- dunno source
20:06:58 <aavogt> but we get to inspect the `a' when choosing a which results to use... and the IO gets undone
20:08:26 <FunctorSalad> well yes, and ContT r m a means "I knowz an a, but you must promise to only ever use it for the purpose of making an m r"
20:08:56 <FunctorSalad> so "m a -> ContT m r a" is a less wrong way than "m a -> a" to say it ;)
20:09:19 <aavogt> which is just bind
20:10:48 <FunctorSalad> yes ;)
20:11:11 <FunctorSalad> actually tells you more about ContT I guess ;)
20:30:05 <zeiris> Is the "haddock: can't find a package database at E:\ghc\ghc-6.12.1\lib\package.conf.d" some kinda bug in the Haskell Platform? I don't seem to be the only one with it, and don't even have an E drive.
20:30:53 <aavogt> zeiris: but does your haddock documentation build correctly?
20:32:18 <zeiris> No, it fails to produce output with simple parameters. Using -B flag "could not find link destinations" for a bunch of standard types, also no output.
20:37:24 <aavogt> ziman: those missing link destinations are just warnings
20:37:46 <aavogt> at least, with the flags that cabal gives to haddock
20:40:35 <zeiris> I'm executing haddock directly via "haddock MyFile.hs" :[
21:08:01 <alexyk> how can I implement a Map lookup with default using maybe?
21:09:46 <alexyk> ah, findWithDefault
21:09:48 <BMeph> @type maybe
21:09:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:10:16 <alexyk> BMeph: I was thinking of plugging Map.lookup in there somehow or !
21:10:26 <BMeph> @type flip maybe id
21:10:27 <lambdabot> forall a. a -> Maybe a -> a
21:10:43 <kmc> :t fromMaybe
21:10:44 <lambdabot> forall a. a -> Maybe a -> a
21:10:54 <kmc> :t \k -> M.lookup k >=> fromMaybe 3
21:10:54 <lambdabot> forall k c. (Ord k, Num (Maybe c)) => k -> M.Map k (Maybe (Maybe c)) -> Maybe c
21:10:56 <BMeph> @src fromMaybe
21:10:57 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
21:10:58 <kmc> err
21:12:39 <BMeph> :t \k -> flip M.lookup k >=> fromMaybe 3
21:12:41 <lambdabot> forall a c. (Ord a, Num (Maybe c)) => M.Map a (Maybe (Maybe c)) -> a -> Maybe c
21:13:10 <BMeph> :t \k -> M.lookup k (?map) >=> fromMaybe 3
21:13:11 <lambdabot>     Couldn't match expected type `a -> m b'
21:13:11 <lambdabot>            against inferred type `Maybe a1'
21:13:11 <lambdabot>     In the first argument of `(>=>)', namely `M.lookup k (?map)'
21:13:35 <BMeph> :t flip M.lookup (?map) >=> fromMaybe 3
21:13:36 <lambdabot> forall a c. (Ord a, ?map::M.Map a (Maybe (Maybe c)), Num (Maybe c)) => a -> Maybe c
21:14:38 <alexyk> what's (?map) -- ?
21:14:54 <BMeph> alexyk: An implicit parameter
21:15:28 <alexyk> BMeph: s it only for type inference?
21:15:33 <alexyk> is
21:16:37 <Cale> alexyk: In this case. :)
21:16:45 <JoeyA> While working on a monad, I've been encountering scenarios where I can either write a function on a handle (foo :: MyHandle -> Blah) or a function returning a monad (foo :: MyHandle -> MyMonad Blah)
21:17:05 <JoeyA> Should I stick to the latter almost always if I use monads for other things?
21:17:15 <BMeph> :t fromMaybe 3 . flip M.lookup (?map)
21:17:16 <lambdabot> forall t k. (Num t, Ord k, ?map::M.Map k t) => k -> t
21:17:31 * BMeph sighs in relief!
21:17:47 <Cale> JoeyA: Just a point of notation, the word "monad" here would refer to 'MyMonad' itself, and not values of type MyMonad Blah
21:18:01 <Cale> JoeyA: You should usually make your functions pure where you can
21:18:07 <JoeyA> thanks.  What's a good term for the latter function?
21:18:14 <JoeyA> By pure, do you mean the former?
21:19:32 <Cale> yeah
21:19:33 <Cale> Though it really depends on what sort of monad we're talking about here, and what your intention is regarding how the function is used.
21:19:37 <JoeyA> For context, here's my big pile of code:  http://codepad.org/YudTFkNG .  Note how key, index, isRoot, isChild, etc. are plain old functions.  Note how root, children, parent, ancestors, etc. return monadic values.
21:19:53 <BMeph> JoeyA: The latter function is a function. It returns an "action", which is our local name for a monadic value. Also, in this case, by "pure," we mean the former (first) function. :)
21:20:13 <alexyk> > fromMaybe 3 . flip Data.Map.lookup (fromList [(1,2),(3,4)]) $ 1
21:20:14 <lambdabot>   Not in scope: `Data.Map.lookup'
21:20:32 <JoeyA> To me, this seems familiar to a question in object-oriented programming:  whether to use get/set or exposed data members
21:20:42 <alexyk> but it works :)
21:20:57 <BMeph> :t fromMaybe 3 . flip M.lookup (fromList [(1,2),(3,4)]) $ 1
21:20:58 <lambdabot>     No instance for (MonadRandom (M.Map a))
21:20:58 <lambdabot>       arising from a use of `fromList' at <interactive>:1:29-50
21:20:58 <lambdabot>     Possible fix:
21:21:01 <JoeyA> I get the feeling that returning monadic actions is better for encapsulation, as it gives me more flexibility over how the monad can be implemented
21:21:13 <BMeph> :t fromMaybe 3 . flip M.lookup (M.fromList [(1,2),(3,4)]) $ 1
21:21:14 <lambdabot> forall t. (Num t) => t
21:21:22 <BMeph> > fromMaybe 3 . flip M.lookup (M.fromList [(1,2),(3,4)]) $ 1
21:21:23 <lambdabot>   2
21:21:33 <alexyk> yay
21:21:58 <JoeyA> e.g. rather than "brute force" (in the sense of how Data.List works), I might want to build an optimized state machine or something.
21:22:43 <Cale> JoeyA: Well, that could be true, yes. If you feel that you might change the implementation of those things later so that they wouldn't be quite the same as just composing the pure function with return, then you might think about that.
21:23:10 <JoeyA> So basically, "use my own judgment"?
21:23:26 <Cale> yeah :)
21:23:36 <JoeyA> But I'm new to monads.  I don't have it yet :D
21:24:49 <JoeyA> Another thing that occurred to me is that using monadic functions rather than pure ones would make my library easier to use.
21:25:22 <Cale> It's probably best not to focus too much on the fact that your library defines a monad. Being a monad is a nice thing, in that you get all that stuff from Control.Monad for free, but apart from that, it shouldn't influence your decisions about the API too much.
21:26:19 <JoeyA> For instance, to list the fields in an object, it'd be nice to say:  root .> "store" .> "book" #> 0 >>= children >>= key
21:26:55 <JoeyA> However, that won't work because key isn't :: JPRef -> JSONPath String, it's JPRef -> String
21:27:06 <Cale> fmap key
21:27:42 <Axman6> <$>
21:28:29 <Cale> but yeah, maybe you're right about that
21:28:49 <Cale> I suppose it comes down to this: What is a (JSONPath t), abstractly?
21:29:09 <Cale> It seems that it's a way of collecting a bunch of values of type t from a piece of JSON
21:29:52 <JoeyA> Which is reflected pretty clearly in my data definition:  data JSONPath a = JSONPath (JSON -> [a])
21:29:59 <Cale> yeah :)
21:30:11 <Cale> oh, btw, just noticed there are some tab characters
21:30:28 <Cale> watch your editor configuration :)
21:31:24 <Cale> (you'll generally want to switch on whatever option converts tabs to spaces automatically)
21:34:18 <JoeyA> I know, I know.  I just make sure tabs are only at the beginning of lines.
21:34:42 <JoeyA> Anyway, I implemented fmap, and this works:  key <$> (root .> "store" .> "book" #> 0 >>= children)
21:34:53 <aavogt> JoeyA: but then you have to make sure that all leading spaces are tabs
21:35:13 <mtnviewmark> ah - thinking about ways to incorporate JSON like structures into Haskell?
21:35:48 <JoeyA> Actually, my real goal is prototyping a JSONPath implementation in C
21:35:55 * wli somehow never had an issue with tabs at the beginnings of lines, though spaces were annoyances.
21:35:56 <JoeyA> But I'm also learning about monads
21:36:18 <JoeyA> is there a way to put that "key" where I want it?  As in, root .> "store" .> "book" #> 0 >>= children >>= magic key
21:36:20 <mtnviewmark> I just released a Haskell implementation of LLSD (similar to JSON, but richer base types - and multiple serializations - and an IDL that validates inputs and outputs....)   - 
21:36:25 <mtnviewmark> you might want to peek there 
21:36:46 <JoeyA> where magic is compatible with (JPRef -> String) -> (JPRef -> JSONPath String)
21:36:54 <mtnviewmark> http://hg.secondlife.com/llsd/src/tip/haskell/
21:37:10 <mtnviewmark> http://hg.secondlife.com/llsd/src/tip/haskell/Network/Format/LLSD.hs
21:37:25 <mtnviewmark> someLLSD ./ "foo" ./ "bar"
21:37:31 <mtnviewmark> or someLLSD ./ 3
21:37:59 <JoeyA> I thought about using an existing JSON or similar implementation, but decided to write my own code so I'd have more freedom over the data structures.
21:38:02 <mtnviewmark> and things like    someValue `with` "name" .= "bob" `with` "age" .= 34
21:38:56 <JoeyA> @hoogle (a -> b) -> (a -> m b)
21:38:57 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:38:57 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
21:38:57 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
21:39:21 <JoeyA> @hoogle (Monad m) => (a -> b) -> (a -> m b)
21:39:21 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
21:39:21 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
21:39:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:41:02 <Jonno_FTW> @src nub
21:41:02 <lambdabot> nub = nubBy (==)
21:42:02 * JoeyA is a nubBy
21:51:20 <alexyk> I have two Maybe m maps, and know they both can't be Nothing.  I need to merge them thusly: if one is Nothing, return the other; if both are Just a, Just b, do M.unionWith (+) a b -- Map a Int say.  Any clever way to avoid case ladder?
21:52:11 <ezyang> there's only four cases... 
21:52:42 <ezyang> (Just a) (Just b); (Just a) Nothing; Nothing (Just b); Nothing Nothing (error) 
21:52:58 <ezyang> Oh, I see what you're asking. Tuple them up and case on the tuple 
21:53:28 <alexyk> ezyang: am typing as we scroll!  but always wonder about Maybe magic!
21:53:59 <ezyang> well, you could imagine a maybe2 function, but you'd still need to supply four cases 
21:54:08 <alexyk> yeah
21:54:25 <alexyk> I wonder if I can do some liftM2 or such
22:00:24 * ksf thinks the ghc package registry should be split into ways
22:01:07 <ziman> :t M.unionWith (+) `on` maybe Data.Map.empty id
22:01:08 <lambdabot> forall k a. (Num a, Ord k) => Maybe (M.Map k a) -> Maybe (M.Map k a) -> M.Map k a
22:01:31 <ksf> and there should probably be a unified haskell way to do package registrys, not just for ghc
22:02:15 <ksf> as, frankly, it would be quite strange for ghc to keep track of installed binaries, which we should do.
22:03:36 * ksf would like to name that "hortage"
22:05:19 <danharaj> like a separate package manager for haskell stuff?
22:05:35 <ksf> yes
22:05:47 <ksf> although limiting it to haskell might not be a good design choice
22:05:58 <danharaj> I would like *something* for windows.
22:06:06 <danharaj> Getting a sane development environment working is so painful.
22:06:14 <ksf> and I'm thinking more of a storage system than a package manager
22:07:49 <ezyang> I'm writing up a six part series on C2HS (first part is tomorrow); any topic requests? 
22:08:01 <danharaj> "What is C2HS"
22:08:04 <ezyang> Done. 
22:08:13 <danharaj> "Why do I care about C2HS"
22:08:15 <ezyang> In fact, that's basically what the first post is about :-) 
22:08:19 <ezyang> Done. 
22:08:28 <ksf> that is, a filesystem-backed package database that keeps track of runtime dependencies and runtime dependencies only.
22:08:45 <ksf> ...or at least has separate dependency classes.
22:09:11 <ksf> "The Truth about CLDouble"
22:09:30 <BMeph> ksf: I think that a filesystem-based database would be a worse design choice that being Haskell-specific. :)
22:09:36 <ksf> or even "The capital-T Truth about CLDouble"
22:10:07 <ksf> well... unix tends to work on files, not on sql queries.
22:10:22 <ksf> nix has done some things awesomely right.
22:10:30 <alexyk> ziman: cool
22:10:52 <Lajla> Are these monads really so hard as they claim?
22:10:56 <danharaj> nix is our von Neumann oppressor.
22:10:59 <Lajla> Are they harder than continuations?
22:11:06 <danharaj> Lajla: No, they are not.
22:11:13 <ezyang> Lajla: Definitely not. 
22:11:16 <ksf> hmmm one could do a fuse layer to provide a traditional unix hierarchy
22:11:23 <ezyang> (Even though continuations are monadic...) 
22:11:40 <Lajla> danharaj, ezyang answer to which of my two quaestions?
22:12:00 <ezyang> Both 
22:12:03 <Lajla> I like to see continuations as those time machines in primer.
22:12:04 <Lajla> Ahh
22:12:12 <ksf> are there OSs worth supporting that don't support some way of either user-space FSs or union mounts?
22:12:18 <Lajla> Then I shall study them in profound detail and use them for good, never for evil.
22:12:29 <ezyang> Spoken like a true Jedi 
22:12:42 <ezyang> ksf: It depends on your definition of "support" 
22:13:02 <danharaj> Does Windows suit that definition?
22:13:04 <ezyang> You could argue that no operating system worth supporting currently "supports" union mounts. 
22:13:09 <ksf> that is, can be accessed with vanilla open() etc. calls
22:13:10 <ezyang> danharaj: Yes! 
22:13:27 <ksf> linux does.
22:13:31 <ezyang> http://www.fs-driver.org/ 
22:13:32 <ksf> if you install 9pfuse ;)
22:13:46 <ezyang> ah. I won't pass judgment on that, then :-) 
22:13:51 <ezyang> (most union mounts suck.) 
22:14:11 <danharaj> You can't really study monads without getting balls deep in category theory.
22:14:22 <danharaj> Really they are just a uniform description of many, many, kinds of data and computation.
22:14:34 <ezyang> danharaj: I'd say that's pretty false... 
22:14:35 <ksf> it'd be bloody useful for providing a /lib that contains exactly those .so's that some package depends on and no more
22:14:49 <ezyang> ksf: It's true. 
22:15:03 <ezyang> I think some Windows distributions just copy everything all over the place. 
22:15:30 <ezyang> danharaj: In fact, from a computational standpoint, I'd say monads have little to do with CT... 
22:15:34 <ksf> which also gives a nice view on package blockage: yes, you can have them installed side by side, but you can't have a package depend on both of them because their union mounts clash
22:15:56 <danharaj> ezyang: what is our definition of "study monads"? because mine is studying the abstract monadic structure.
22:16:26 <ezyang> I'm appraoching it from a "I wanna write Haskell perspective" 
22:16:40 <ezyang> rather than a "I wanno know what's up with category-extras" 
22:17:07 <danharaj> ezyang: In that case I don't think you really study monads. You become familiar with the monadic structure and then just learn how to use specific monadic libraries.
22:17:16 <ezyang> Sure. 
22:17:23 <ksf> ...doing a haskell-based unix is still something that hits my TODO from time to time.
22:18:02 <ksf> including a c library that uses the ghc runtime as kernel
22:18:15 <danharaj> ksf: God I hope you don't make a haskell unix. Functional programming deserves a better OS structure.
22:18:24 <ezyang> Don't we already have that? 
22:18:37 <ezyang> FFI in the other direction. 
22:18:41 <kmc> unix is hilariously untyped
22:18:55 <ksf> I don't believe in creating a haskell os from scratch
22:19:16 <ksf> and even then you'd want to support things like X etc.
22:19:23 <ksf> POSIX is damn big
22:19:26 <danharaj> I do. I think you have to rethink OS design in the declarative paradigm.
22:19:49 <danharaj> Maybe you won't get anything good at first, but we need to step into those uncharted realms and see what an OS looks like from the declarative POV.
22:20:20 <danharaj> And it should run on the reduceron ;p
22:20:23 <ezyang> danharaj: There's a surprisingly large amount of research/experimental opearting systems. 
22:20:28 <ksf> danharaj, the idea is to write a unix that everybody (including c zealots) is ok to use. when we have the world backing us, we can slowly transition it from the POSIX interface to something better.
22:20:50 <danharaj> ksf: You want to *transition* an OS interface. That sounds impossible.
22:20:55 <ezyang> But there's an incredible amount of work to get things beyond there. 
22:20:58 <kniu> I got a program abort with "foo: <<loop>>" as the error.
22:21:10 <ksf> well not so much transition as supporting both POSIX and something better
22:21:10 <kniu> Is Haskell seriously detecting infinite loops?
22:21:22 <ezyang> knui: Sort of... 
22:21:24 <ddarius> Yep.
22:21:30 <kniu> If so, how does this magic work?
22:21:32 <ksf> heck one's regarded to be a toy os if you don't support posix
22:21:32 <ezyang> Not /all/ of them. 
22:21:37 <ksf> ...best example being windows.
22:21:42 <ezyang> lol. 
22:21:54 <danharaj> That 'toy' os happens to comprise the most popular platform for Haskell.
22:21:59 <danharaj> (I think, I should cite my sources)
22:22:16 <ksf> it happens to have the most platform downloads from haskell.org, maybe
22:22:24 <ezyang> I continue to be surprised by the assertion that the killer application for Haskell is GUI programming. 
22:22:42 <ksf> I'd say more unix people are using it, we just don't see the downloads as they're done through distros.
22:23:06 <Axman6> ezyang: i would too
22:23:12 <danharaj> ksf: Maybe. But at the very least Windows is a serious and legitimate platform for Haskell. It's a bad idea to treat it as a 'toy os' culturally.
22:23:26 <Axman6> zomg, cabal install threadscope seems to be working :o
22:23:28 <ksf> there's a new paper about tree bijections that might prove interesting wrt. guis
22:23:47 <ksf> I'm not convinced that frp is the best way to go, that is.
22:23:53 <ezyang> ksf: linky? 
22:23:53 <ddarius> ksf: That paper seemed pretty... ugly.
22:24:36 <ulfdoz> danharaj: At least with w2k3 and vista, Microsoft has released two serious OS-Variants.
22:24:43 <ulfdoz> s/vista/7/
22:24:54 <danharaj> ulfdoz: yes, well 7 is the one that doesn't suck.
22:25:13 <ksf> was it cufp?
22:25:28 <ksf> its' been submitted to a soon-to be conference, of that I'm sure.
22:27:19 <BMeph> ezyang: It looks to me as if rather, the lack of ease in setting up GUI programming in Haskell is "killing" experimentation with/in it. :\
22:27:56 <Axman6> danharaj: as much
22:27:58 <Axman6> *
22:29:00 <danharaj> Axman6: It is missing a decent command line environment (well, I don't know how powershell works), but as a user OS it is perfectly fine. As a dev OS, it lacks the legions of neckbeards that prop Lunix up.
22:30:11 <ulfdoz> powershell ist actually the long awaited improvement.
22:30:48 <ksf> sigplan.
22:31:36 <ksf> it's even been graphs, not trees.
22:34:29 <ksf> oooooh
22:34:42 <ksf> ddarius, what I linked here back then wasn't the sigplan paper
22:34:55 <ksf> I linked http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.58.7505 , which is about trees
22:35:42 <ksf> the graph paper doesn't seem to be out yet
22:35:53 <danharaj> ooh, I like how Powershell is typed and leverages .NET. That is interesting.
22:36:17 <ezyang> people and their unpublished papers >:-( 
22:36:23 <ezyang> How am I supposed to read them? 
22:36:29 * BMeph smirked when ksf used the phrase "graph paper"...
22:36:40 <kmc> is .NET the sort of thing you can't "use", only "leverage"?
22:37:04 <Bigglotron> blast those neckbeards
22:37:12 <Bigglotron> i can smell them through the internet
22:37:20 <Bigglotron> yeesh, take a shower
22:37:32 * ksf would've expected preprints to be on the net
22:37:43 <ksf> I'd also like to see neil's supercompilation paper
22:37:51 <danharaj> kmc: synonyms pff
22:38:46 <kmc> biz-speak
22:39:00 <Bigglotron> also danharaj 'user experience' is the most broken metaphor in existence for software analysis
22:39:21 <danharaj> Bigglotron: I can smell your neckbeard from all the way over here.
22:39:23 <Bigglotron> usability experts are children in grown up clothes
22:39:39 <kmc> hilarious
22:39:55 <kmc> children in grown-up clothes are usually pretty cute
22:40:05 <danharaj> agreed.
22:40:06 <Bigglotron> yeah so are usability experts
22:40:19 <Bigglotron> they also say the darnedest things.
22:40:29 <p_l> Bigglotron: I wouldn't agree, otoh, there's a lot of *bad* stuff in UX...
22:40:52 <p_l> it's a rather jumbled area
22:40:53 <tensorpudding> Usability isn't entirely subjective though
22:41:16 <kmc> indeed
22:41:20 <Bigglotron> usability is missing the point if you're not in an almighty business environment
22:41:23 <kmc> "usability" and "visual aesthetics" are pretty far apart
22:41:29 <danharaj> usability is missing the point?
22:41:37 <danharaj> Are you kidding? I use computers.
22:41:44 <Bigglotron> outside of business, yeah. i think so.
22:41:58 <Bigglotron> it's really ergo-centric.
22:42:00 <kmc> usability is overrated.  now, leveragability, that's something we can talk about
22:42:01 <danharaj> I would like it that using my computer does not feel like punching myself in the dick and gargling battery acid.
22:42:34 <Bigglotron> no i mean as a whole paradigm. jesus christ.
22:42:56 <danharaj> You are establishing a context that did not exist at the beginning of this thread of discussion.
22:42:56 <tensorpudding> User interfaces suck.
22:43:04 <kmc> users suck
22:43:06 <kmc> get rid of them
22:43:08 <kmc> problem solved
22:43:10 <danharaj> You were the one who brought up 'usability experts' and 'business'.
22:43:26 <kmc> hmm
22:43:30 <Bigglotron> i didn't read this thread of discussion.
22:43:38 <danharaj> Then stop punching me in the dick >:|
22:43:38 <Bigglotron> i was making a completely tangental point.
22:43:40 <tensorpudding> this chat was not built with context switching support for threads, it'll have to be recompiled
22:43:51 <kmc> wouldn't it be fun to go on the Internet and say deliberately provocative and perhaps even unreasonable things in order to get reactions out of people?
22:43:56 <blackdog> kmc: and universities would be fantastic if it weren't for all the bloody students
22:44:02 <kmc> blackdog, tell me about it
22:44:09 <danharaj> kmc: There is a reason why I use terms like 'neckbeard' and 'lunix' :p
22:44:09 <tensorpudding> kmc: Maybe also showing them pictures of a man's distended anus?
22:44:29 <blackdog> tensorpudding: no, that'd be childish. there's no-one like that on the internet.
22:44:30 <kmc> blackdog, though plenty of those really exist
22:44:43 <blackdog> afaict, most people use the internet to exchange scientific data
22:44:47 <tensorpudding> Or linking them to a video of an 80's pop star singing a forgotten Top 40 hit under misleading circumstances?
22:44:59 <kmc> yes, the family friendly version of the shock site
22:45:02 <wli> tensorpudding: Rickroll?
22:45:26 <p_l> blackdog: most people use internet to send spam, pornis second...
22:45:29 <p_l> ;-)
22:45:30 <tensorpudding> It's not actually forgotten, it was in the new Doctor Who unironically.
22:45:37 <Bigglotron> i am a scientist. EXPERIMENTAL RESULTS: sociology is a nondiscipline.
22:45:37 <blackdog> i once got rickrolled three or four times concurrently
22:45:46 <blackdog> it starts to sound oddly beautiful once you get enough polyphony in there
22:45:48 <kmc> isn't everything in Doctor Who already three levels of ironic?
22:46:04 <kmc> SCIENCE: disproved
22:46:06 <tensorpudding> It couldn't have been ironic on the level of rickrolling since that episode predated the meme.
22:46:21 <kmc> if humans evolved from monkeys then why are there still monkeys HMMM?
22:46:49 <tensorpudding> If your parents are dead why are you still alive?
22:46:55 <ksf> kmc, because humans _are_ domesticated monkeys?
22:47:03 <tensorpudding> Humans are not monkeys.
22:47:08 <tensorpudding> They're apes.
22:47:12 <tensorpudding> There's a difference
22:47:21 <kmc> apes are a paraphyletic clade
22:47:26 <ksf> a smaller than to dolphins.
22:47:27 <blackdog> kmc: if the world is round, how come i don't fall off when i walk?
22:47:31 <Bigglotron> humans are reptiles who control the government through voting and not reading
22:48:08 <kmc> err i think i meant 'monkeys are a paraphyletic clade'
22:48:11 <tensorpudding> Reptiles and humans had their last common ancestor in the Paleozoic
22:48:25 <Bigglotron> nope. all alien space reptiles in disguise.
22:48:31 <Bigglotron> even you.
22:48:35 <tensorpudding> Alien reptiles doesn't make sense.
22:48:49 <ksf> tensorpudding, duh.
22:48:55 <Bigglotron> i won't hear your reptile lies.
22:49:01 <ksf> they migrated to space before we evolved.
22:49:26 <Bigglotron> they hide behind the ice wall waiting for the stock market to crash.
22:49:31 <tensorpudding> Okay, so they're migratory
22:49:34 * blackdog guiltily enjoys surreal discussions on #haskell and hopes they don't get exiled to -blah
22:50:22 <tensorpudding> Hmm, so methane-based life on Titan would be pretty intriguing
22:50:54 * mtnviewmark accidentally wags his reptile tongue at tensorpudding...
22:50:59 <Bigglotron> i read a really shitty science fiction short story about that.
22:51:26 <robertmassaioli> what would be interesting is to find a race that tried functional programming before procedual lol. Imagine the subtle differences. :)
22:51:30 <blackdog> so, wrenching things back on topic for just a second: i'm compiling HINT, and the dylib has all of these dependencies on files in /tmp
22:51:36 <blackdog> this is distressing and strange
22:52:04 <jesusabdullah> What is HINT? If you don't mind me asking
22:52:17 * jesusabdullah googles
22:52:38 <jesusabdullah> huh
22:52:40 <blackdog> it's on hackage - haskell interpreter, basically
22:52:43 <blackdog> wrapper for the GHC api
22:53:35 <blackdog> anyway, when i install it, it creates some links to the dylib for cpphs, but instead of referring to the one in /usr/local/lib/cpphs-blahblahblah, it has a link to some long thing in /tmp
22:54:19 <kmc> humans developed the theory of procedural and functional programming at about the same time, but built machines to do the former and not the latter
22:55:18 <danharaj> Hail the coming of the reduceron.
22:56:44 <Bigglotron> i though they built them for the latter but the ones for the former were easier to build well.
22:57:08 <ezyang> I won't blame you for complaining about traffic. 
22:57:11 <ezyang> mix 
22:57:27 <kmc> there have been attempts to build dedicated FP machines throughout the history of computers
22:58:11 <alexyk> how do I convert am Int to a Float?
22:58:25 <tensorpudding> @type fromIntegral
22:58:26 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:58:39 <tensorpudding> is one option
22:58:43 <kmc> "how do I convert A to B" is a bad question
22:58:53 <kmc> it means "what is some function of type A -> B"
22:59:10 <kmc> in this case there's a pretty clear "most natural" function
22:59:11 <alexyk> I need to multiply a bunch of Ints by another bunch of Floats; how do I make ghci shut up?  :)
22:59:28 <kmc> but e.g. in the other direction there are at least 5 natural choices
22:59:37 <kmc> Haskell does not privilege one function of type A -> B over all others
23:01:09 <tensorpudding> some types have only one function
23:01:09 <alexyk> ah, the Int terms go into a fromIntegral (a*b*...) * float1 * float2 ... 
23:01:21 <tensorpudding> like a -> a
23:01:33 <alexyk> "a one function man"
23:02:11 <kmc> well there's at least three values of type (forall a. a -> a) in Haskell
23:02:20 <kmc> but only one is a total function
23:02:24 <tensorpudding> though there are two different possible functions from a -> (), thanks to that pesky bottom
23:02:44 <kmc> yeah
23:02:52 <tensorpudding> i forgot bottom, eh
23:02:52 <kmc> hence the objection that "seq" should be in a type class
23:03:05 <kmc> to warn you of the non-parametricity
23:03:11 <kmc> (this was the case in some language version i think)
23:03:12 <tensorpudding> but technically bottom would return a -> b in the most general sense
23:03:27 <tensorpudding> @type const undefined
23:03:28 <lambdabot> forall a b. b -> a
23:04:48 <tensorpudding> @type const $ const $ const $ const bottom
23:04:49 <lambdabot> Not in scope: `bottom'
23:04:55 <tensorpudding> @type const $ const $ const $ const undefined
23:04:57 <lambdabot> forall b b1 b2 a b3. b -> b1 -> b2 -> b3 -> a
23:09:45 <ksf> kmc, those'd be the same people that would object Typeable _not_ to be a typeclass?
23:10:23 <alexyk> given a list of Maybe Int, how do I add all Justs?
23:10:31 <alexyk> (prettily)
23:10:42 <ksf> ...which would me allow to get rid of unsafeCoerce without exploding contexts everywhere.
23:10:45 <ezyang> catMaybes 
23:10:48 <ezyang> then sum 
23:11:03 <ezyang> > sum (catMaybes [Just 2, Just 4, Nothing, Just 2]) 
23:11:04 <lambdabot>   8
23:11:11 <alexyk> cuute
23:11:25 <danharaj> Maybe is the awesomest monad.
23:12:00 * ezyang is amused that Isabelle the theorem prover is the first result for Isabelle. 
23:12:05 <ksf> wut, ListT (Maybe a)?
23:12:33 <alexyk> @hoogle ListT
23:12:33 <lambdabot> Control.Monad.List newtype ListT m a
23:12:33 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT m a
23:12:33 <lambdabot> Language.Haskell.TH ListT :: Type
23:13:17 <alexyk> ksf: so?
23:13:54 <ksf> ...I'm just saying, because catMaybes is basically join.
23:14:16 <ezyang> oh, that's true. 
23:14:38 <bos> how do people usually typeset haskell code in LaTeX?
23:14:43 <ezyang> > join (ListT ([Just 1, Just 2, Nothing])) 
23:14:43 <lambdabot>   Not in scope: data constructor `ListT'
23:14:46 <ezyang> bah 
23:14:51 <bos> i'm using \package{listings}, but it produces crap output
23:14:52 <ezyang> bos: \begin{verbatim} 
23:14:58 <danharaj> shouldn't catMaybes generalize to any MonadPlus?
23:15:11 <ezyang> Probably... 
23:15:15 <bos> ezyang: see comment re "crap output" :-(
23:15:26 <ezyang> bos: Hm, I must be using a different package 
23:15:54 <ezyang> oh, I am using listings 
23:16:04 <ezyang> But I'm compiling a literate haskell file 
23:16:13 <ezyang> using lhs2Tex 
23:18:15 <ddarius> danharaj: No.
23:18:35 <bos> yay, haskellwiki wins again!
23:18:36 <danharaj> ddarius: Why can't you just drop the zeros?
23:18:47 <danharaj> mzero's*
23:19:09 * ezyang thinks it ought to work 
23:19:12 <ezyang> at the very least, 
23:19:14 <ddarius> danharaj: How do you tell which ones they are?  Also, catMaybe does more than just "drop the Nothings"
23:19:22 <ezyang> > mconcat [[1],[],[3],[],[],[8]] 
23:19:23 <lambdabot>   [1,3,8]
23:19:51 <ksf> is there a combined sequence/map type?
23:19:59 <ksf> I need a searchable lru structure
23:20:17 <alip> i want to turn a list in form [a,b,c,d] into [a,x,b,x,c,x,d], what's the easiest way?
23:20:32 <Cale> intersperse
23:20:33 <ddarius> > intersperse x [a,b,c,d]
23:20:33 <lambdabot>   [a,x,b,x,c,x,d]
23:20:44 <alip> great thanks!
23:20:53 <ksf> well... that is, is there a structure better suited that sequence and hoping that access patterns aren't random.
23:20:54 <ezyang> ksf: Check Edison? 
23:21:04 <danharaj> ddarius: good points
23:21:16 <Cale> ksf: Maybe you could coerce PSQueue into something usable for what you need?
23:21:38 <ksf> queues don't lend themselves well to lru
23:23:05 <ksf> hmmm http://hackage.haskell.org/package/lrucache
23:23:55 <ksf> This gives O(log n) operations on insert, lookup, delete, and pop
23:26:51 <ksf> ...and I seem to finally need to wrap my Fds into handles.
23:27:03 <ezyang> waving the white flag are we? 
23:27:10 <ezyang> remember: once a handle, /always/ a handle 
23:27:14 <ezyang> "no return!" 
23:27:25 <ksf> ...not the vanialla haskell handles.
23:27:39 <ezyang> ah, I see 
23:28:38 <ksf> but I need to discern between sockets, files and file-backed pipes as well as anonymous pipes to cache them properly
23:30:08 <ksf> ...and I should support pairing up fd's into pipe tuples
23:31:06 <ksf> that is, I want to lift createPipe into userspace.
23:32:05 <ksf> otherwise I'd either be creating pipes way too often or run out of fds way too quickly.
23:32:20 <ksf> ...and creating pipes is actually quite expensive
23:34:13 <kmc> ksf, typeOf :: a -> TypeRep not in a class would be pretty bad
23:34:22 <kmc> though not as bad if GHC actually enforced proper results
23:34:37 <kmc> right now the situation with Typeable is quite dangerous
23:35:06 <kmc> you can write an incorrect Typeable instance and suddenly all manner of standard libraries become type-unsafe
23:35:11 * ksf thinks it should be typeOf#
23:36:24 <ksf> and there should be a way to serialize and deserialize _everything_.
23:36:39 <ksf> including partially applied functions, that is.
23:37:02 <ksf> I'm thinking of distributed computing, there, where it'd be nice to send bytecode over the net.
23:37:06 <kmc> what about Data.Unique?
23:38:31 <ksf> I think providing it with a pure interface is morally correct
23:38:54 <ksf> and possibly even denotational if there's no way to compare them for creation order
23:41:18 <ksf> hmmm if the bytecode comes with types and proofs of that type, different implementations could share code safely
23:43:38 <kulin> evening, ive taken linear algebra, but this may be a dumb question despite that, im looking for a module for simple vector math such as addition and multiplication, it seems like package vector is not this, so my question is, which package should i be looking for?
23:44:26 <Zao> kulin: vector-space maybe?
23:44:34 <Bigglotron> i am also interested to know the answer to this question
23:44:34 <Zao> Or vect or Vec.
23:44:47 <Zao> vector-space hurt my brain when I tried it.
23:44:58 <Zao> Depends on intended usage, I guess.
23:46:04 <kulin> ya looks like vec might be more than i want, vect should work nicely, thanks
23:47:23 <alip> how do I split a list with Nx elements into N lists each having x elements?
23:48:05 <Zao> split, recurse on the tail?
23:49:04 <Zao> > splitAt 3 [9001..9010]
23:49:05 <lambdabot>   ([9001,9002,9003],[9004,9005,9006,9007,9008,9009,9010])
23:49:51 <alip> thanks!
23:50:05 <Zao> @src splitAt
23:50:06 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
23:58:51 <kulin> there is no way to make a function that takes a variable number of parameters right?
23:58:59 <Veinor> there is, but it's hacky.
23:59:11 <kulin> ok i wont bother then
23:59:13 <kmc> no, every function takes exactly one parameter
23:59:38 <Veinor> :P
23:59:40 <kmc> however, you can make a single /name/ which is typeclass-overloaded to a family of functions, each of different type
23:59:45 <kniu> hey guys
