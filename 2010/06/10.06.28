00:00:54 <ivanm> quuxman: no
00:01:11 <ivanm> since some libraries (e.g. mtl and transformers) have the same module in them
00:01:32 <Phyx-> well, you could use ghc-pkg find-module
00:01:32 <ivanm> also, if you want say Foo.Bar, should cabal-install install packages that have sub-modules of that (Foo.Bar.Baz, etc.)
00:01:42 <ivanm> Phyx-: of packages that aren't installed yet?
00:01:57 <Phyx-> ivanm: ah, for that.. i got nothing :P
00:02:07 <ivanm> you could use Hayoo!
00:02:19 <Phyx-> why do people recomment Hayoo over hoogle?
00:02:27 <ivanm> because Hayoo indexes hackage
00:02:32 <Phyx-> last time i tried it it was slower :/
00:02:47 <ivanm> but hoogle produces better results for those packages it does index (which is the old extralibs IIRC)
00:03:00 <ivanm> and yeah, hoogle is faster and has command-line and lambdabot versions
00:03:03 <aleator> Anyone want to play "optimize haskell code game"? I'm stumped and about to go shopping for a dunce cap now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26631#a26631
00:03:32 <quuxman> ivanm: speaking of mtl, what do I do about this error? Ambiguous module name `Control.Monad.Trans': it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1
00:03:52 <ivanm> aleator: if you're doing linear algebra, consider using hmatrix as it uses lapack and blas
00:03:56 <ivanm> and should thus be faster
00:04:45 <Phyx-> quuxman: you can do three things, either hide one of the two packages using ghc-pkg hide, use a cabal file to compile instead, or enable the package import pragma and then do like instead of "import Control.Monad.Trans" "import "mtl" Control.Monad.Trans" for instance
00:04:49 <ivanm> anyway, most of your runtime is from another library, and there are thus two possibilities:
00:05:00 <ivanm> 1) you're not using that library properly; 2) that library needs performance tweaks
00:05:25 <aleator> ivanm: Could be, but that used to have rather heavy overheads last time I checked. According to prof the linear algebra is less than 3% of what I do.
00:05:25 <Phyx-> oh, i figured he was trying to compile his own code
00:05:30 <ivanm> quuxman: that last solution of Phyx-'s is strongly discouraged however
00:05:45 <Phyx-> ivanm: non-portability?
00:05:46 <ivanm> aleator: yeah, I didn't see the prof bit before I said that
00:05:51 <ivanm> just that you claimed that numpy was faster
00:05:55 <quuxman> ivanm: hum, well I can't hide one package or the other, because the code I'm using depends on both packages somehow
00:06:00 <aleator> ivanm: I thought so yes :)
00:06:06 <ivanm> Phyx-: it only exists because ghc needs it with the whole base-3 compat stuff
00:06:24 <Phyx-> ivanm: right, but it's terribly handy :P
00:06:33 <quuxman> (I'm just trying to run the code that "snap init" produced)
00:06:41 <quuxman> I should probably be over in #snap
00:06:51 <ivanm> aleator: maybe if you paste the entire prof output up so we could see what's using uniform2...
00:07:52 <aleator> ivanm: Sure. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26631#a26632
00:08:22 <ivanm> OK, it's being used by some uniform instance, and is needed by uniformVector
00:08:53 <ivanm> aleator: maybe start giving names to some of your CAFs to help track it down
00:10:17 <aleator> ivanm: What am I looking for? I know that the algorithm needs exactly 30160 random numbers, which seems to be what is generated. Are there other ways I could have mistaken?
00:10:34 <ivanm> preflex: seen bos
00:10:34 <preflex>  bos was last seen on #haskell 1 day, 10 hours, 48 minutes and 48 seconds ago, saying: i run into build problems almost every time i pull.
00:10:53 <ivanm> aleator: asking bos what you're doing wrong might be the best way of doing this unfortunately :s
00:11:20 <ivanm> preflex: also, you're calling length a lot
00:11:24 <ivanm> that might get expensive
00:11:53 <aleator> ivanm: I'll try if I see him online
00:12:07 <ivanm> well, he's not atm
00:15:22 <blackdog> so, any sydneysiders feel like going to tho taphouse and drinking beer tonight?
00:17:38 <ivanm> blackdog: well, the only other sydneysider that I know of that's online atm is TacticalGrace...
00:18:11 <blackdog> ivanm: TacticalGrace already doesn't sleep more than about thirty minutes a day, i'm pretty suer.
00:18:29 <ivanm> heh
00:18:31 <blackdog> one time, he evaluated _|_ and got an answer 
00:18:40 <ivanm> looks like your out of luck for haskell drinking buddies for tonight then
00:19:33 * hackagebot speculation 0.8.0.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.8.0.1 (EdwardKmett)
00:20:41 <blackdog> ivanm: indeed. i'll just have to drag you all out for AUSHAC
00:57:29 <ivanm> hey m3ga 
01:01:57 <m3ga> ivanm!
01:02:22 <ivanm> m3ga: Axman6 is apparently going to send out mail about fp-syd to people that have registered
01:04:55 <m3ga> ivan: thanks!
01:08:04 <Phyx-> there, collapsible regions implemented
01:08:22 <wli> What do you have in mind by collapsible regions?
01:08:48 <Phyx-> wli: http://blog.zhox.com/2010/06/28/collapsible-regions-video-update-2/
01:10:23 <wli> Phyx-: Haskell integration into VS2010?
01:10:29 <Phyx-> wli: yup
01:25:11 <Axman6> ivanm: i never said i would, but i guess i can
01:26:27 <Zao> Phyx-: Looks awesome.
01:27:48 <Phyx-> Zao: still have a ways to go though, holiday starts next week, then i can take a break from my thesis work and ramp up work on it
01:29:49 <Zao> Now with viemu for 2010 in beta, things are looking rather bright.
01:30:06 <Axman6> viemu?
01:30:32 <Zao> Axman6: vim-like editor keys in VS.
01:30:42 <Zao> Complete with command line, assorted modes, macros, etc.
01:30:55 <Zao> http://www.viemu.com/
01:31:57 <Phyx-> Zao: saw an extension for that on the extensions galary, wonder if it's the same one
01:32:22 <Zao> Phyx-: No.
01:32:37 <Zao> The gallery one is some quick hack, I would not expect it to be as fully featured.
01:32:50 <Zao> After all, viemu has been around for half a decade for earlier VSes.
01:33:08 <Zao> On the other hand, the gallery one is free.
01:33:19 <Phyx-> indeed
01:33:26 <Phyx-> hehehe
01:34:05 <Zao> I'll probably spring for a license of viemu once the 10 build is out of beta.
01:35:13 <Phyx-> you must really like vim :P
01:35:13 <koala_man> apparently I can't use my old license on 10 :/
01:35:18 <ziman> Phyx-, wow.
01:36:17 <Zao> Phyx-: I've monomophized myself for it.
01:36:19 <Zao> +r
01:36:58 <Phyx-> ziman: I'll have some new features in a week or two done also :)
01:37:00 <Phyx-> Zao: hehehe
01:43:39 <vuvuzelaa> bzzzzzzzzzzzbzzzbzbbzzzzz
01:43:40 <vuvuzelaa> zzz
01:43:41 <vuvuzelaa> zzz
01:43:42 <vuvuzelaa> zzzzzz
01:43:43 <vuvuzelaa> zz
01:43:44 <vuvuzelaa> zz
01:45:34 <Zao> Jaggon: Having fun?
02:13:10 <pastorn> trying to make Setup for Cabal
02:13:14 <pastorn> Linking Setup ...
02:13:16 <pastorn> /usr/bin/ld: cannot find -lgmp
02:13:18 <pastorn> collect2: ld returned 1 exit status
02:13:33 <pastorn> anyone know what might be going on?
02:13:59 <Zao> Got libgmp?
02:15:04 <pastorn> maybe not... which version?
02:15:10 <pastorn> (GHC 6.10.4)
02:15:43 <Zao> Whatever is current, probably.
02:15:58 <pastorn> yay
02:27:54 <b0fh_ua> Hello all! Can somebody please advice how do I supply a correct monad for type checking in the example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26634#a26634 ?
02:29:35 <b0fh_ua> in fact I don't even see why do I need a monad there, but runPT requires me to have one
02:29:48 <aavogt> b0fh_ua: add a type signature where you use parseResponse, or make it's type more specific
02:30:28 <aavogt> you should ask ghci what sort of instances for Stream are available
02:30:56 <b0fh_ua> aavogt: okay, seems that Maybe is the choise
02:31:25 <b0fh_ua> hm, or no
02:32:13 <aavogt> looks like you can pick any one you like
02:32:21 <aavogt> instance (Monad m) => Stream [tok] m tok
02:32:45 <b0fh_ua> yeah
02:33:21 <b0fh_ua> thanks )
02:57:24 <triyo> Hmm what is wrong with this line: todoLineParser = (todoTagStr++) <$> manyTill anyChar (string todoTagStr) *> manyTill (noneOf "\n\r") eol
02:57:26 <triyo> Its almost works
02:58:12 <triyo> The problem is that it doesn't use my todoTagStr in the ++
02:58:22 <triyo> Using parsec lib that is
02:59:22 <triyo> I get back this..... "(alen, dave,nadeen):   need a test case for this module" when I should get back:.... "TODO(alen, dave,nadeen):  need a test case for this module" when I should get back"...It doesn't concatenate the todoTagStr
03:02:25 <aavogt> triyo: all your operators are infixl there
03:02:43 <aavogt> you probably want instead      f <$> (g *> h)
03:03:10 <aavogt> which might be prettier as    g *> (f <$> h)
03:03:44 <triyo> aavogt: well spotted, thank you!!
03:04:08 <aavogt> no problem
03:05:46 * triyo thinks that applicative parsing is a lot more fun
03:06:32 <danharaj> Does restricting to predicative polymorphism mean that in a polymorphic term you can only substitute in a monomorphic type, and not polymorphic types?
03:06:42 <danharaj> Or is that even more restrictive?
03:13:38 <mreh> does anyone know Henrik Nilsson's nick?
03:13:55 <mreh> I suppose I could ask
04:08:28 <Saizan> danharaj: that's it, unless you add a hierarchy of universes
04:11:53 <geheimdienst> so, i'm having a little trouble understanding typeclasses and instances in this module here: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-Decoration.html
04:12:17 <geheimdienst> there's a "Shrinker" class which contains only 1 function (String -> [String]) and which is passed to a function (decoration :: (Shrinker s) => s -> ...). with my puny understanding of haskell, i'm now wondering: why not just pass the function in directly? decoration :: (String -> [String]) -> ... then you couldn't you remove the complication of the instance and class?
04:12:43 <geheimdienst> (posting here instead of #xmonad, i figured it's more of a haskell question instead of an xmonad one)
04:13:32 <Zao> geheimdienst: Maybe you want to have arbitrary information associated with your s instance?
04:13:34 <zygoloid> i'm writing an FFI-style interface, and i want to simultaneously support multiple different versions/flavours of a library. the structs are mostly the same between versions/flavours, but the layouts are different (and not all members are present in all versions)
04:13:54 <zygoloid> does anyone have any ideas how i might nicely represent this, so that my client code doesn't need to care which version it's dealing with?
04:14:32 <geheimdienst> zao, how do you mean arbitrary information? what could that be for example?
04:15:31 <Jafet> You're probably better off asking in #xmonad, unless people here know what Shrinker is
04:15:54 <Zao> I would guess that it depends on the context of where it's used.
04:16:06 <Zao> Future-proofing?
04:16:08 <zygoloid> geheimdienst: those two approaches are nearly equivalent. you can implement the decoration :: (String -> [String]) -> ... interface in terms of the class one
04:16:21 <Zao> Multiple implemented classes?
04:16:43 <zygoloid> (and with some Olegian hackery can implement the class-based interface in terms of the String -> [String] interface, but that's non-trivial)
04:17:38 <zygoloid> is the class exported? if not, the class-based one can give additional encapsulation guarantees
04:17:50 <Jafet> zygoloid, let the importer request a range of versions (assuming you've found a way to Ord them)
04:18:23 <geheimdienst> zao, you mean future-proofing as in: a class to contain 1 function doesn't make much sense, but someday we might want to add a couple more functions to the class. right?
04:18:24 <zygoloid> Jafet: yeah, Ord on versions is easy. Ord on flavours is meaningless, sadly, but the struct members don't seem to change between flavours)
04:18:33 <Zao> geheimdienst: Aye.
04:18:34 <geheimdienst> zygoloid, yes it is exported
04:18:46 <Jafet> zygoloid, what's a "flavour"?
04:19:06 <Zao> geheimdienst: Or if you've got some "superclass" of it earlier in the call chain, and feed the same value to this here "decoration" function.
04:19:08 <zygoloid> Jafet: a compile-time #define which affects the way in which the library is built and the available structure members
04:19:25 <duairc> I really, really, really wish MonadTrans provided something I call "lifted" instead of "lift"... then you would only need to make a MonadTrans instance for your monad transformer and it'll magically work with everything (This is what I'm talking about: http://gist.github.com/455707). It think it would require some sort of EvilInstances that may not even exist though.
04:19:48 <zygoloid> Jafet: i will want some of my client code to have multiple versions for different flavours, to deal with this.
04:19:51 <Jafet> zygoloid, oh boy
04:19:53 <Zao> f :: (Shrinker s, Frobnicator s) => s -> ...; f s = decoration s ++ rofl s
04:20:08 <zygoloid> Jafet: yeah, it's "fun"
04:20:13 <Zao> With separate free functions, you'd be shoveling around multiple functions.
04:20:28 <Zao> Or so I guess.
04:20:29 <zygoloid> if i'm prepared to sacrifice type-safety i can get something reasonable working, but that seems unwise
04:20:40 <Jafet> Since C preprocessor directives can affect really anything, I won't suggest without knowing details of your library then
04:20:55 <zygoloid> Jafet: my "library" is the GHC RTS :)
04:21:07 <geheimdienst> i see. thanks guys for the ideas :) helpful as always
04:22:44 <duairc> Could anybody tell me if there's a reason MonadTrans isn't the way I'm suggesting? I'd find it hard to believe it's just that nobody ever thought of it. I think it would require something even worse than OverlappingInstances and UndecidableInstances, but whatever it is I don't see any reason why it would be technically impossible to implement
04:31:06 <ivanm> duairc: without even looking at it, there's the high possibility that it's because no-one ever thought of that
04:31:24 <ivanm> also, I have no idea what your lifted function is meant to do
04:31:40 <byorgey> duairc: try sending a message to haskell-cafe, you're likely to get some thoughtful responses
04:32:09 <byorgey> it's hard to discuss such things over IRC, in my experience
04:32:44 <duairc> Okay, cool, that's a good idea
04:33:01 <Saizan> duairc: have you tried making some instances of your MonadTrans ?
04:33:35 <pastorn> duairc: have you seen -XGeneralizedNewtypeDeriving?
04:33:39 <Saizan> duairc: and check that it gives you a reasonable behaviour
04:35:41 <geheimdienst> zygoloid, about your c struct question: not sure if it's relevant, but i once used a haskell library (wrapping a c lib) that was missing some struct members that had been added at the c level in an update. this caused trouble because random garbage bytes appeared in the area of the struct that c supplied and haskell didn't know about
04:35:47 <duairc> pastorn: Yeah, I have
04:36:03 <duairc> Saizan: I haven't actually tested the code, but for ReaderT, lifted f = ReaderT $ \r -> f (flip runReaderT r)
04:36:14 <geheimdienst> my fix was simply to add 1-2 lines to the haskell to memset(0) all the struct first
04:36:20 <Saizan> duairc: yeah, but ReaderT is the easy one :)
04:36:24 <duairc> :)
04:36:45 <duairc> Well, what's the hardest one and I'll do it? :P
04:36:49 <pastorn> duairc: with ContT (RWST IO a) i don't think there might be anything more you could ever want
04:36:55 <pastorn> maybe ContT on the inside...
04:36:56 <Saizan> duairc: try StateT
04:37:09 <geheimdienst> (hope that made sense)
04:37:29 <Saizan> pastorn: well, then just write in ocaml :)
04:37:38 <pastorn> haha
04:40:15 <duairc> Saizan: StateT is basically the same thing:  lifted f = StateT $ \s -> f (flip runStateT s)
04:41:15 <duairc> ivanm: lifted probably isn't a great name, but it basically gives you a sort of "unlift"
04:42:01 <Saizan> duairc: i don't think that'll typecheck, and anyhow it'll have a fairly unexpected behaviour, the state transformation doesn't get propagated outside.
04:43:21 <duairc> It definitely typechecks
04:43:40 <Saizan> ?type \f -> StateT $ \s -> f (flip runStateT s)
04:43:40 <pastorn> duairc: i don't get it... why do you want this?
04:43:41 <lambdabot> forall s (m :: * -> *) a (m1 :: * -> *) a1. ((StateT s m1 a1 -> m1 (a1, s)) -> m (a, s)) -> StateT s m a
04:44:25 <Saizan> duairc: that signature doesn't fit "lifted :: Monad m => ((t m a -> m a) -> m a) -> t m a"
04:44:51 <Saizan> because of the (.. , s) part
04:44:55 <duairc> Saizan: Okay, yeah
04:46:04 <duairc> pastorn: Because let's say I have a Duairc monad, and then I want to be able to wrap some monad transformer around it, so then I make a MonadDuairc class and I only have to give implementations for Duairc and (MonadTrans t => t Duairc), and it'll automagically work with every monad transformer ever (not just those in mtl)
04:51:38 * hackagebot hdaemonize 0.4.3 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.3 (FrederickRoss)
04:52:14 <pastorn> sounds an aweful lot like GeneralizedNewtypeDeriving... but maybe i'm missing something here...
04:53:17 <Saizan> duairc: same goal, different choice of methods, and it seems to work, but it didn't gain much popolarity http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/Control-Monad-Trans.html , http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
04:54:22 <duairc> Saizan: Okay, cool, I'll have a look at it
04:56:23 <Saizan> pastorn: even with GND you've to make an instance of each MonadFoo class for each primitive transformer
04:56:54 <Saizan> though some would just say that you shouldn't use MonadFoo classes in the first place
04:57:58 <duairc> And just use chains of lifts?
04:58:44 <Saizan> no
05:00:27 <Saizan> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers <- which in short is: hide your trans. stack behind a newtype and expose only a limited set of custom operations that make sense in your specific context
05:04:12 <duairc> Yeah, I would agree with that. I guess what I have in mind is that something where anybody can make a monad transformer FooT, and FooT m is a MonadFoo, and if m is a MonadBar then so is FooT m, and if m is a MonadBaz then so is FooT, etc. And I don't see any way of doing that in general unless the author of FooT knows about every type of Monad* that m could possibly be
05:06:33 <duairc> I guess what would solve this problem would be if you could do something like newtype FooT .. m a = FooT (...) deriving (Monad*)
05:25:20 <mjrosenb> duairc: i've wanted ways to allow typeclases to write their own deriving routines
05:25:25 <hants> is there a wildcard for Dataconstructor Patternmatching like f (_ x) = x ?
05:26:19 <mjrosenb> hants: you can declare that field to have a particular label, then pull it out
05:27:06 <mjrosenb> hants: data Foo = L {f::a} | R {f::b}; g x = f x
05:28:27 <hants> hmm
05:28:29 <hants> thanks!
05:29:05 * mjrosenb tries that to make sure the syntax was sane
05:30:49 <mjrosenb> yup, but f can't be any more polymorphic than Foo :(
05:31:12 <mjrosenb> unless there is some way of explicitly declaring f as having a universal quantifier
05:31:19 <mjrosenb> and that sounds .... difficult
05:32:51 <hants> yes - not as easy as one might think
05:33:50 <mjrosenb> actually, there is no reasonable way for that to work
05:38:23 <tsou> hants: what type would you give to this f of yours?
05:41:54 <hants> f gets (RationalL x) or (IntegerL x) and the like 
05:42:25 <hants> and several arguments of that type
05:42:38 <hants> enumerating all possibilities is quite redundant
05:42:59 <tsou> I mean, if you were the type-inference system, what type would you assign to this f, if all you saw was  f (_ x) = x
05:47:08 <hants> f:: polymorphicConstructor -> a
05:47:25 <hants> ;)
05:47:46 <tsou> hah, i see... :P
05:48:02 <tsou> more like f :: polyConstructorWhoAccepts a -> a
05:48:11 <tsou> i suppose that's why there's no such wildcard :P
05:48:14 <hants> yes thats even better^^
05:48:38 <hants> still it doesnt sound unreasonable
05:49:20 <zygoloid> more like f :: (HasUnaryConstructor a b) => a -> b
05:49:27 <tsou> I think you would need the notion of subtype for this to work
05:49:55 <zygoloid> we already have a notion of subtype, with typeclass constraints and polymorphism
05:49:56 <tsou> and there are no subtypes in haskell :(
05:50:00 <tsou> hmm
05:50:21 <zygoloid> forall a. a is a subtype of every lifted type, for instance
05:50:55 <tsou> I meant in a more native way, so that for example "Just 2" and "Left 4" could be assigned a common supertype
05:51:43 <dobblego> (Functor f) => f Int
05:52:01 <zygoloid> tsou: they have a common supertype of exists f. Num a => f a (though that's not a "real type")
05:52:21 <tsou> zygoloid: aha
05:53:20 <zygoloid> ok, for that to work you need it to be "Right 4" rather than "Left 4", but...
05:54:11 <Zao> "Either is discriminating against left-handed people!"
05:54:24 <zygoloid> :)
05:54:25 <tsou> hah!
05:54:48 <ddarius> Either a b = Sinister a | Dexter b
05:55:23 <zygoloid> let's do political incorrectness properly... Either a b = Black a | White b
05:55:48 <ddarius> type Othello = Either () ()
05:55:58 <zygoloid> Either a b = Female a | Male b
05:56:02 <geheimdienst> Either a b = Bitch a | Male b
05:56:14 <geheimdienst> Either a b = Nigger a | White b
05:56:21 <tafryn> Boo.
05:56:25 <geheimdienst> this is sooo politically incorrect
05:56:32 <zygoloid> geheimdienst: a step too far
05:56:34 * Zao feels ashamed for derailing the channel.
05:56:52 <zygoloid> Either a b = Java a | Haskell b
05:56:54 <glith> Either a b = Functional a | Dysfunctional b
05:56:55 <zygoloid> happy now? :)
05:56:57 <aristid> Zao: this is irc, channels just sometimes derail. nothing you can do about it.
05:56:57 <Zao> There _was_ a -cafe thread on left-handedness and Either though a year or two ago.
05:57:02 <Zao> Quite amusing read.
05:57:03 <geheimdienst> about 4 steps too far ...
05:57:24 <zygoloid> though really it's called Right because it's the type on the right in Either a b
05:57:40 <tsou> zygoloid: yeah... right :P
05:57:42 <zygoloid> (and success needs to be on the right for it to be a sensible Functor)
05:58:19 <geheimdienst> in the US political area, you could take Right to refer to the crazy right-wing fringe
05:58:53 <geheimdienst> so you might think it's offensive that these people represent the right, normal values in an Either
05:59:40 <aristid> geheimdienst: both sides can get pretty crazy in the US, so it's symmetric
05:59:58 <geheimdienst> yes, but Left is an error condition and Right is the happy path
06:00:51 <geheimdienst> (that also was the offensive thing about the Black a | White b that someone wrote earlier)
06:01:40 <tsou> sorry for bringing the talk back to haskell, but in what way does the Left consructor of Either represent a failure and the Right one a success?
06:01:52 <zygoloid> has anyone investigated an alternative prelude with something like: class Functor f where type Fmap f a :: *; fmap :: (a -> b) -> (Fmap f a -> Fmap f b)
06:02:15 <zygoloid> tsou: in the sense that the Monad and Applicative instance "bail out" when they get to a Left
06:02:55 <aavogt> so Left is actually stronger, no?
06:02:59 <geheimdienst> tsou, http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Either.html#t%3AEither says: by convention, the Left constructor is used to hold an error value and the Right constructor is used to hold a correct value (mnemonic: "right" also means "correct").
06:03:15 <geheimdienst> @hoogle data.either
06:03:15 <lambdabot> No results found
06:03:16 <tsou> aha, I see
06:03:27 <aavogt> then again, you have MonadPlus if you want Right to win
06:03:30 <zygoloid> {-# LANGUAGE CPP #-} #define Wrong Left
06:04:00 <geheimdienst> Either a b = One a | TheOther b
06:04:16 * aavogt still takes offence :P
06:04:33 <zygoloid> choices = [One 6, TheOther (dozen `div` 2)]
06:04:38 <mjrosenb> One "get You" `mplus` TheOther "get you"
06:04:58 <geheimdienst> SovietRussia a b = Right a | Left b
06:05:43 <zygoloid> module SovietRussia where data Type = Defines You
06:06:13 <geheimdienst> in soviet russia, you drive ghc crazy
06:07:02 <zygoloid> in soviet oleg, your program checks the type checker
06:07:07 <geheimdienst> i mean, i knew hoogle doesn't find very much, it more or less works only on the "core" package. but it's a bit much that @hoogle data.either returns nothing
06:07:24 <zygoloid> @hoogle Data.Either.Either
06:07:25 <lambdabot> module Data.Either
06:07:25 <lambdabot> Data.Either data Either a b
06:07:25 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
06:07:38 <geheimdienst> @hoogle data.maybe
06:07:38 <lambdabot> No results found
06:07:46 <zygoloid> @hoogle Data.Maybe
06:07:46 <lambdabot> module Data.Maybe
06:07:47 <lambdabot> Data.Maybe data Maybe a
06:07:47 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
06:07:59 <geheimdienst> @hoogle Data.Either
06:08:00 <lambdabot> module Data.Either
06:08:00 <lambdabot> Data.Either data Either a b
06:08:00 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
06:08:02 <Baughn> geheimdienst: Don't forgetin {-# LANGUAGE Russian #-} if you're going to write that sort of code
06:08:32 <geheimdienst> silly. the hoogle web version is case-insensitive, hoogle-lambdabot is case-sensitive
06:08:48 <geheimdienst> http://www.haskell.org/hoogle/?hoogle=data.maybe
06:09:14 <geheimdienst> i mean it's not really useful what it returns, but it's different from lambdabot's results
06:14:00 <Gilly> Does the haskell platform include an XML parser?
06:14:23 <ivanm> not by default I don't think
06:14:26 * ivanm checks
06:14:33 <Baughn> Nope
06:14:45 <Baughn> It includes a library installation program, of course.
06:14:50 <chrisdone> doesn't have an xml parser but has glut support, go figure
06:14:55 <ivanm> there's the xhtml library, that's the closest there is
06:15:06 <ivanm> chrisdone: because it was there from extralibs
06:15:07 <Baughn> That's for /writing/ xhtml, not parsing it
06:15:08 <Gilly> Ok, thanks :) which of those libraries would you recommend, then?
06:15:18 <ivanm> Baughn: *shrug* wasn't sure
06:15:20 <Baughn> I used to use haxml, but it's /slow/.. or was, anyway
06:15:22 <ivanm> Gilly: haxml is the main one
06:15:35 <Baughn> (Slow, by my standards of parsing wikipedia. All of wikipedia.)
06:15:39 <chrisdone> Text.XML is fine for simple tasks
06:15:41 <ivanm> lol
06:15:42 <Gilly> Well, i don't need speed in this case anyway.
06:15:57 <chrisdone> http://hackage.haskell.org/package/xml
06:15:58 <Baughn> ivanm: The hacked-up bytestring parser I cooked up was roughly fifty times faster, anyhow..
06:16:00 <ivanm> it depends on what you want; IIRC there's 3 libraries with differing levels of support
06:16:14 <ivanm> Baughn: well, polyparse now has a bytestring parser
06:16:22 <ivanm> so maybe you can submit a bytestring version of haxml to malcolmw
06:16:34 <Baughn> If I had one. ;)
06:16:37 <Zao> http://www.haskell.org/pipermail/haskell-cafe/2008-March/thread.html#40172
06:16:45 <Zao> There we go, "Doubting Haskell"
06:16:59 <Baughn> The wikipedia dump format is very regular, and not very xml-y; I was cutting it based on /newlines/.
06:17:28 <Zao> Or not. Wrong thread.
06:17:44 <Zao> http://groups.google.com/group/fa.haskell/browse_thread/thread/dbb3502b8b62e75a/b1e0673a38ce3995
06:19:06 <ivanm> Zao: what's the link for?
06:19:32 <Zao> Left-handedness and Left.
06:19:43 <Zao> Covers the fmap rationale and all.
06:19:48 <ivanm> "holding a teraflops in his hand" <-- wtf?
06:19:53 <ivanm> how do you hold a measure of computing power?
06:19:58 <Zao> The initial post is largely rambling.
06:20:03 <Zao> ivanm: A single chip, I assume.
06:20:05 <ivanm> and how does that measure of computing power suddenly become the size of a CD?
06:20:28 <Zao> There was a more interesting thread on this, but I can't find it.
06:20:29 <ivanm> Zao: maybe, but it's extremely poor word choices there
06:21:10 <Baughn> ivanm: Perhaps a single GPU?
06:21:48 <ivanm> how is it "a teraflops" ?
06:21:58 <ivanm> (yes, I'm being picky; I should be sleeping)
06:21:58 <p_l|backup> ivanm: it might be running at the moment
06:22:22 * p_l|backup had seen someone attach a PCIe x16 card by tape instead of slot
06:22:27 <Baughn> ivanm: Very picky. If it's capable of running a teraflop or more when plugged in, that's good enough for me.
06:22:28 <ivanm> :o
06:22:39 <Baughn> p_l|backup: You can do that? I would have thought signal timing would get you.
06:22:41 * ivanm resolves the situation by going to bed
06:22:41 <Zao> "if it's running, you'd better catch it" is the olde adage, so maybe he has just caught it?
06:22:42 <ivanm> g'night all
06:22:43 <Jafet> Baughn, flops is singular!
06:22:52 <Jafet> (Two teraflopses?)
06:22:54 <p_l|backup> Baughn: let me find the link
06:22:54 <geheimdienst> something stirs in me when i read these nonsense plurals like "boxen". puts the writer two points down on my to-be-taken-seriously scale
06:22:56 <Baughn> Jafet: Pickiest.
06:23:09 <geheimdienst> make that: pretentious nonsense plurals
06:23:11 <Zao> geheimdienst: I find boxen suitable for IRC among likeminded.
06:23:19 <Jafet> A single GPU is unlikely to achieve "a teraflops" by any measure, anyway -- probably talking about several multi-core GPUs on a card
06:23:29 * Baughn has several boxen. He uses them to pack mail in.
06:23:31 <Zao> Any serious reasonably permanent context, it's out.
06:23:44 <p_l|backup> Baughn: http://infinityb.yasashiisyndicate.org/ims/b/76e4cb77ef048068808957f3bb9fc98f91b0cc1efdcd2e0ef664121ce5510225
06:24:21 <geheimdienst> it might be cool if you intend it ironically. mocking the know-it-alls who say things like radii or virii or boxen
06:24:31 <geheimdienst> i could get on board with that
06:24:34 <p_l|backup> vaxen? :)
06:25:09 <Baughn> p_l|backup: Posting an infinityb link here? What have you DONE?
06:25:12 <Baughn> You've killed the server!
06:25:12 <Jafet> The radii of virii on the penii
06:25:15 <p_l|backup> ^___^;
06:25:29 * p_l|backup closes the blast doors
06:28:22 <chrisdone> p_l|backup: where's my trylisp?
06:28:49 <Zao> p_l|backup: Is it anything interseting and/or SFW?
06:29:06 <p_l|backup> Zao: a weird computer
06:29:10 <geheimdienst> try clojure: http://tryclj.licenser.net/
06:29:30 <p_l|backup> chrisdone: went secondary to having enough food to survive and having money to pay for tax
06:29:54 <Baughn> Zao: Having spent some time reading your link, I found that its concerns are basically completely obsolete as of.. was it 6.8 or 6.10 that got base-4?
06:29:54 <Jafet> You pay for tax? Strange country
06:29:57 <Baughn> Whoops. ^^;
06:30:03 <p_l|backup> Jafet: building taxes
06:30:24 <p_l|backup> had to presell consulting hours at 1/3rd price :D
06:31:22 <theorbtwo> You know, I took a while trying to figure out why anybody would write numbers in base 4 before realizing that you meant base, version four.
06:31:23 <geheimdienst> remember kids: "vaxen" is silly, "klaxon" is not
06:31:40 <p_l|backup> geheimdienst: and "vixen" is definitely not silly :)
06:32:22 <Zao> theorbtwo: Handy when nibbles are not small enough?
06:34:11 <benmachine> Baughn: 6.10 I think
06:34:26 <benmachine> Baughn: but if you're talking about exception stuff, 6.8 had the extensible-exceptions package
06:34:35 <Baughn> Yes.. I think I'll give the guy a call and ask if he wants to try again. :)
06:36:10 <benmachine> "But in Haskell, you cannot read a file line by line without writing an
06:36:11 <benmachine> exception handler, because end of file is an exception!"
06:36:16 <benmachine> ^ actually, this annoys me too
06:36:45 <Baughn> Of course, it's two minutes of work to write a wrapper where it isn't
06:37:17 <benmachine> sorry, what isn't what?
06:37:45 <Baughn> Where EOF is a return value and not an exception
06:38:08 * benmachine rearranges thoughts
06:38:09 <benmachine> right
06:38:10 <Baughn> ..or just wrap it with try, I guess
06:38:25 <benmachine> it's just a little odd to have an exception for a condition that is going to come up fairly normally
06:38:39 <Baughn> It is, yeah, but the simplicity of wrapping with try means I mostly don't care.
06:39:39 <benmachine> heh
06:39:52 <benmachine> it might be nice to have a stdlib function that iterated over the lines of the file
06:39:56 <benmachine> *a file
06:40:01 <Baughn> Iteratees?
06:40:30 <benmachine> I've never learnt iteratees, I really should
06:40:42 <Baughn> Same. I've just barely glanced at it.
06:42:43 <edwardk_> hrmm. can someone help me make sense out of http://hackage.haskell.org/packages/archive/speculation/0.8.0/logs/failure/ghc-6.12 ?
06:43:10 <geheimdienst> edwardk_, you need more monads
06:43:20 <edwardk_> apparently
06:43:38 <Baughn> edwardk_: Looks like you've got some dependencies that need base-3 and some that need base-4..
06:43:54 <edwardk_> Baughn: my understanding was that that was allowed
06:44:06 <Baughn> It is, but not in the /same package/
06:44:07 <benmachine> base <6 :O
06:44:30 <Baughn> edwardk_: Link to the .cabal file?
06:44:31 <geheimdienst> At least the following dependencies are missing: base >=4 && <6 && <4 && >=4 && <6 && <4 && >=4 && <6 && <4
06:44:34 <edwardk_> benmachine: i grabbed it from another project ;)
06:44:39 <geheimdienst> there's no number that satisfies all of that
06:44:47 <geheimdienst> "<4 && >= 4"
06:44:51 <edwardk_> http://hackage.haskell.org/packages/archive/speculation/0.8.0/speculation.cabal
06:45:01 <Saizan> edwardk_: see the first error
06:45:08 <theorbtwo> geheimdienst: Clearly, you need base-NaN.
06:45:09 <benmachine> lol at <4 appearing three times >_>
06:45:37 <Saizan> edwardk_: the second one is just failed speculation :)
06:45:48 <edwardk_> test-framework is broken due to ... ?
06:45:50 * Baughn is stumped
06:45:51 <edwardk_> that one?
06:45:55 <Saizan> yep
06:45:59 <theorbtwo> Find out which ones are requring <4, figure out if any of them are actually incompatable with base-4, and create modified versions that will work?
06:46:25 <theorbtwo> ...or figure out which ones require <4, and replace them with something more modern.
06:46:28 <Saizan> <4 is added explicitly by the script.
06:46:35 <Saizan> it's not coming from the dependencies.
06:46:37 <edwardk_> Saizan: so that means that any of my package that i upload to hackage with test-framework as an out of the box dependency will be broken? i should then configure my tests and benchmarks behind default: false flags?
06:46:50 <Saizan> the configure is succesful without any --constraint= added
06:47:01 <geheimdienst> but what's the point of having base-3 and base-4 available in parallel, if you can't use them both
06:47:12 <theorbtwo> Saizan: So what in *your* package requires base <4?
06:47:32 <edwardk_> what the heck is putting the constraint in though? i know that is the default or whatever but i have an explicit >= 4 in my code
06:47:49 <Saizan> edwardk_: or mail Ross so that it fixes the package database maybe :)
06:47:59 <edwardk_> Saizan: there is that ;)
06:48:05 <edwardk_> just annoyed at the build failure ;)
06:48:07 <Saizan> edwardk_: just hackage's build script
06:48:20 <Saizan> "setup/setup configure --ghc --user --prefix=/usr/local/tmp/archive/install --haddock-option=--use-contents=/package/speculation-0.8.0 --constraint=base<4 --constraint=parsec<3 --constraint=QuickCheck<2 --verbose" <- the call
06:48:31 <edwardk_> i would write the email if i understood a bit better what was going wrong
06:48:42 <geheimdienst> does it compile locally?
06:48:48 <edwardk_> yeah, works like a charm
06:49:13 <edwardk_> installing it on a fresh machine now
06:49:19 <shaniaki> is there any general way to track the real cause of these dependency mismatches? There is a problem here which seems to be due to a similar reason:
06:49:21 <shaniaki> http://hackage.haskell.org/packages/archive/ForSyDe/3.1.1/logs/failure/ghc-6.12
06:49:30 <Saizan> edwardk_: it's fairly simple, the package db on hackage's machine is corrupt
06:49:32 <shaniaki> with something like:
06:49:36 <shaniaki> Warning: This package indirectly depends on multiple versions of the same
06:49:38 <shaniaki> package. This is highly likely to cause a compile failure.
06:49:40 <edwardk_> Saizan: fair enough
06:50:26 <Saizan> where corrupt probably means that some version of some package got recompiled and produced a different ABI
06:50:33 <edwardk_> i grabbed a log of this chat fragment and i'll send it to him with the email
06:50:51 <edwardk_> in the meantime i'll fix it by making the default value of the flag false
06:52:18 <Saizan> hopefully after Gracenotes' GSoC hackage should have a better story for build reports
06:53:30 <Saizan> shaniaki: this explains the general problem you're having there http://www.well-typed.com/blog/12
06:54:09 <Gracenotes> story isn't too bad for full build reports. anonymous ones are a host of security pitfalls...
06:54:35 <shaniaki> hmm, I saw it actually but since it is an old post and it says: "the good news is that the latest release does solve the problem" I thought that shouldn't be the reason
06:55:06 <Saizan> shaniaki: that sentence applies only to cabal-install
06:55:30 <Saizan> Gracenotes: i guess the most important thing are the docs, though
06:57:31 <theorbtwo> Saizan: *why* do you run "setup" with "--constraint=base<4"?
06:57:43 <shaniaki> aha, so what can I do in order to avoid such problems in Hackage?
06:57:51 <edwardk_> ok, next question, deep cabal mojo. i have 'cabal test' run 'cabal build' whenever the tests aren't built yet, how do i get it to effectively pass '-ftests'
06:57:56 <Saizan> theorbtwo: me?
06:58:55 <Saizan> edwardk_: you've to pass that to configure, afaiu
06:59:05 <edwardk_> or does that mean to do so i need to complain that it wasn't configured with -ftests?
06:59:09 <edwardk_> fair enough
06:59:18 <edwardk_> then in that case, how do i check the flag in my Setup.lhs =)
06:59:45 <Saizan> good question :)
07:00:49 <edwardk_> i'm in a testHook, so i have access to PackageDescription and LocalBuildInfo
07:00:52 <geheimdienst> i might be missing something here, but why not just say --with-ghc-options=-ftests ?
07:03:21 <edwardk_> geheimdienst: that won't work i'm calling build inside Setup.lhs, but i just want to know if i should bother. i.e. if -ftests was run ;)
07:03:37 <Saizan> edwardk_: if you take the "executables" out of PackageDescription, in their BuildInfo there's a "buildable" field, you could check that i suppose
07:03:51 <edwardk_> geheimdienst: http://github.com/ekmett/speculation/blob/master/Setup.lhs
07:03:59 <edwardk_> Saizan: brilliant
07:09:31 <Saizan> shaniaki: you can't do much about that, except complaining to the maintainers until they rebuild the deps to make them work, not sure how scalable that is :)
07:11:17 <shaniaki> :) OK, got it!
07:11:38 <Saizan> shaniaki: once they start using the new hackage server this will all be decentralized and should be smoother
07:13:13 <shaniaki> I actually saw this: http://www.haskell.org/pipermail/cabal-devel/2009-October/005706.html , Do you mean the same thing indicated here?
07:13:58 <shaniaki> Again, it is rather old
07:15:31 <exDM69> Saizan: shaniaki: what will the new hackage server do for the multiple-version-of-same-library issue?
07:16:27 <Saizan> shaniaki: yes, that, developement of the new server has been quite slow due to the lack of manpower
07:17:02 <edwardk_> i'd still like to figure out what flags are set, for instance to disable the running of hpc if the -fhpc flag is turned off
07:17:15 <hpc> augh, ping
07:18:14 <edwardk_> i suppose in the if flag(hpc) section i could say x-hpc: True -- and check for that custom flag in the buildInfo
07:18:21 <shaniaki> exDM69: I would also like to know :D
07:19:07 <Saizan> exDM69: basically build reports and documentation will be PUTed into the server by separate clients rather than built locally, which will be quite more flexible, i'm not sure about the details of who will be in charge, e.g. if the maintainer will be able to send the docs himself or not though
07:19:38 <Saizan> build reports will be collected from all the (consenting) users by cabal-install, i think
07:21:29 <geheimdienst> > let m = fromList [(1, "a"), (2, "b")], (++) m (k, v) = insert k v m in m ++ (3, "c")
07:21:30 <lambdabot>   <no location info>: parse error on input `,'
07:21:45 <geheimdienst> > let m = fromList [(1, "a"), (2, "b")]; (++) m (k, v) = insert k v m in m ++ (3, "c")
07:21:46 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'Couldn't...
07:22:16 <Saizan> > let m = M.fromList [(1, "a"), (2, "b")]; (++) m (k, v) = M.insert k v m in m ++ (3, "c")
07:22:17 <lambdabot>   fromList [(1,"a"),(2,"b"),(3,"c")]
07:22:27 <Saizan> ?type fromList
07:22:28 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
07:22:33 <Saizan> heh
07:22:36 <geheimdienst> wtf?
07:23:00 <geheimdienst> thanks saizan
07:23:05 <Saizan> np
07:23:16 <geheimdienst> when you think it's all pretty clear, a MonadRandom sneaks in
07:23:28 <djahandarie> ?type M.fromList
07:23:29 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
07:23:43 <djahandarie> @hoogle fromList
07:23:44 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
07:23:44 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
07:23:44 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
07:23:58 <zygoloid> urgh, Data.HashTable ;(
07:23:59 <djahandarie> Where is that MonadRandom one coming from?
07:24:01 <geheimdienst> isn't there some function like the (++) i defined? it would be handy at times
07:24:07 <Saizan> a wild MonadRandom appeared!
07:24:18 <geheimdienst> ("i defined" in the sense of "saizan defined")
07:24:23 <zygoloid> djahandarie: lambdabot has a builtin set of imports. some of them are great, some of them... not so much
07:24:35 <djahandarie> zygoloid, I know, but I can't even find that on Hackage
07:24:53 <Saizan> @hackage MonadRandom
07:24:53 <lambdabot> http://hackage.haskell.org/package/MonadRandom
07:24:56 <djahandarie> Oh nevermind
07:24:57 <djahandarie> Yeah
07:24:57 <geheimdienst> djahandarie, http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=monadrandom
07:25:03 <djahandarie> hoogle failing again
07:25:09 * Saizan was lucky
07:25:40 <zygoloid> djahandarie: look at State/L.hs or State/Pristine.hs inside the lambdabot tarball
07:25:45 <geheimdienst> hayoo actually finds stuff. hoogle feels like it's only searching Core ...
07:25:47 <Saizan> geheimdienst: i don't think i've needed that much, and i'd probably use some other operator name :)
07:26:19 <Saizan> hoogle doesn't index all of hackage.
07:26:34 <zygoloid> geheimdienst: what is this (++)?
07:26:37 <geheimdienst> well it would help if you could say: someMap `insert` (foo, bar), but i guess that's not possible how insert is defined
07:26:55 <geheimdienst> > let m = M.fromList [(1, "a"), (2, "b")]; (++) m (k, v) = M.insert k v m in m ++ (3, "c")
07:26:56 <lambdabot>   fromList [(1,"a"),(2,"b"),(3,"c")]
07:27:23 <zygoloid> :( map union would be a better (++). but that's just mappend.
07:27:58 <zygoloid> that looks more like a |>, i think
07:28:03 <djahandarie> > evalRand (getRandomR (1,6) (mkStdGen 10)) 
07:28:04 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
07:28:05 <lambdabot>                    ...
07:28:13 * ManateeLazyCat Oh my, WebKit don't support model/view split like VTE library, I spent so much time wasted bind WebKit API... 
07:28:15 <djahandarie> > evalRand (getRandomR (1,6)) (mkStdGen 10)
07:28:16 <lambdabot>   6
07:28:18 <djahandarie> > evalRand (getRandomR (1,6)) (mkStdGen 10)
07:28:19 <lambdabot>   6
07:28:21 <hpc> @src (++)
07:28:21 <lambdabot> []     ++ ys = ys
07:28:21 <djahandarie> > evalRand (getRandomR (1,6)) (mkStdGen 109231)
07:28:21 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:28:21 <lambdabot> -- OR
07:28:21 <lambdabot> xs ++ ys = foldr (:) ys xs
07:28:22 <lambdabot>   4
07:28:34 <hpc> shouldn't (++) = mappend?
07:28:36 <zygoloid> @type (<>)
07:28:37 <lambdabot> Doc -> Doc -> Doc
07:29:03 <Saizan> (++) = mappend only in lambdabot, but @src is more about the haskell report
07:29:04 <zygoloid> hpc: it was in earlier versions of haskell. i hear base 5 will have (<>) = mappend
07:29:08 <Saizan> except:
07:29:11 <Saizan> @src (.)
07:29:12 <lambdabot> (f . g) x = f (g x)
07:29:12 <lambdabot> NB: In lambdabot,  (.) = fmap
07:29:15 <geheimdienst> > (M.fromList [(1, "a")]) `mappend` (2, "b")
07:29:15 <lambdabot>   Couldn't match expected type `Data.Map.Map t [GHC.Types.Char]'
07:29:16 <lambdabot>         agai...
07:29:28 <geheimdienst> > (M.fromList [(1, "a")]) `mappend` (M.fromList [(2, "b")])
07:29:29 <lambdabot>   fromList [(1,"a"),(2,"b")]
07:29:31 <geheimdienst> woah
07:29:52 <djahandarie> The power of abstractions ;-)
07:30:06 <zygoloid> > M.fromList [(1,"a")] `mappend` M.fromList [(1,"b")]
07:30:07 <lambdabot>   fromList [(1,"a")]
07:30:12 <zygoloid> thought as much
07:30:27 <hpc> you can't do [4,3,2]++1, though
07:30:35 <hpc> that definition of ++ is inconsistent
07:30:36 <Jafet> The power of lots of instances
07:30:40 <geheimdienst> insert 1 "b" $ M.fromList [(1,"a")]
07:30:43 <geheimdienst> > insert 1 "b" $ M.fromList [(1,"a")]
07:30:45 <lambdabot>   Couldn't match expected type `a -> b'
07:30:45 <lambdabot>         against inferred type `[GHC.T...
07:30:56 <hpc> :t insert
07:30:57 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
07:31:03 <geheimdienst> > M.insert 1 "b" $ M.fromList [(1,"a")]
07:31:04 <lambdabot>   fromList [(1,"b")]
07:31:09 <zygoloid> > insert 5 [7,3,9,1]
07:31:11 <lambdabot>   [5,7,3,9,1]
07:31:13 <geheimdienst> so mappend is not quite insert
07:31:15 <zygoloid> > insert 5 [3,9,1,7]
07:31:16 <lambdabot>   [3,5,9,1,7]
07:31:29 <ksf> is there any way at all to call a function that I get passed alongside with the structure I generate code from with TH from said code?
07:31:39 <ksf> either I'm blind or I'm re-investigating a dead end.
07:31:46 <Saizan> geheimdienst: zygoloid's comment was that M.union is mappend
07:31:47 <zygoloid> ksf: parse error
07:31:54 <geheimdienst> > (M.fromList [(1, "a")]) `M.union` (M.fromList [(2, "b")])
07:31:54 <lambdabot>   fromList [(1,"a"),(2,"b")]
07:32:00 <geheimdienst> > (M.fromList [(1, "a")]) `M.union` (M.fromList [(1, "b")])
07:32:01 <lambdabot>   fromList [(1,"a")]
07:32:29 <geheimdienst> yes yes, i was just stating my findings
07:32:34 <ksf> I've got a function that's not spliced, but a real function. I can call it from the code that generates without problems. can I call it from the code that I generate?
07:34:09 <geheimdienst> anyway, thanks guys
07:34:10 <zygoloid> ksf: you want something like: $( (\f -> [| f 42 |]) id ) ?
07:34:19 <ksf> yes.
07:34:37 <zygoloid> if you pass it in by name, then yes. if it's an arbitrary closure, then no.
07:34:38 <ksf> erm no
07:34:59 <ksf> \f -> $( [| f 42 |] )
07:35:05 <edwardk_> ok, all my random cabal issues have been fixed. re-uploading
07:35:51 * geheimdienst would like it if you could say someMap { newKey = newValue }, because a Map is vaguely similar to a record, and you can "update" records that way
07:35:57 <zygoloid> ksf: yes, you can do that. in fact that exact code works.
07:36:28 <edwardk_> geheimdienst: syntactic sugar causes cancer of the semicolon.
07:36:37 <hpc> geheimdienst: so make map a sort of "uber-record"?
07:36:41 * hackagebot speculation 0.8.0.2 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-0.8.0.2 (EdwardKmett)
07:37:28 <djahandarie> Isn't there something that Map could get an instance of, where return/pure = singleton ?
07:37:36 <ksf> then why am I bleeding splicing f in, and writing a partial evaluator?
07:37:55 <djahandarie> It obviously isn't a Monad but it seems like there is something more it can be than just a Monoid
07:38:32 <zygoloid> ksf: but you can't then move the quotation somewhere else: let q f = [| f 42 |] in \f -> $( q f ) doesn't work (even without the stage restriction) because functions aren't TH-liftable in general.
07:38:36 <geheimdienst> hpc, i was just thinking that the record-update syntax is quite easy and natural, and that this would be handy for Maps
07:38:59 <hpc> yeah
07:39:03 <geheimdienst> but i guess you're right. records can be viewed as a special case of Maps
07:39:13 <hpc> that actually looks a lot like perl, strangely enough
07:39:14 <geheimdienst> Map FunctionName -> a
07:39:22 <hpc> $map{"key"}=value
07:39:29 <zygoloid> what you can do is use the name of f: let q f = [| varE $f |] in \f -> $( q 'f )
07:39:39 <zygoloid> $(varE f), sorry
07:39:45 <geheimdienst> yes, but perl is an impure mutable bastard
07:39:53 <hpc> agreed
07:40:13 <hpc> that is one of the only features of perl i like, is the damn powerful maps
07:40:57 <hpc> the other is runtime imports, because of the hilarity that can ensue
07:41:45 <djahandarie> To reword my question... is there some typeclass that only enforces a -> m a ?
07:41:47 <ksf> let's say I have data Exp = Val Int | Op (Int -> Int). 
07:42:38 <geheimdienst> if you don't mind the rambling -- what is the type of the record keys? they behave like functions ... Thing { foo :: String } ---> foo thing. so it's gotta be something like (Thing -> String), i.e. (containerRecord -> valueType)
07:42:40 <djahandarie> Wait that was a dumb question
07:42:51 <ksf> can I do $(mycompiler exp), or do I need $(myCompiler (Op (+))?
07:43:46 <ksf> well that Exp doesn't make sense and doesn't typecheck, but still.
07:43:49 <zygoloid> djahandarie: it's called Pointed.
07:44:43 <hpc> geheimdienst: foo :: Thing -> String, yes
07:44:47 <djahandarie> Oh
07:44:53 <djahandarie> So it wasn't a dumb question :P
07:45:18 <djahandarie> Could Map be an instance of Pointed?
07:45:31 <zygoloid> djahandarie: it requires 'm' to be a Functor. and comes with the law that fmap f (pure x) = pure (f x)
07:45:42 <ksf> are there possible unpointed applicative functors?
07:45:58 <djahandarie> Oh wait
07:46:01 <djahandarie> Yeah it's a Functor already
07:46:28 <zygoloid> djahandarie: Map could be an instance of Pointed if there were some distinguished key for it to use.
07:46:46 <djahandarie> I meant Map k
07:46:48 <zygoloid> ksf: no, applicative functor == pointed functor + <*>
07:47:00 <djahandarie> Yeah
07:47:05 <zygoloid> ksf: or do you mean, could there be an instance of functor + <*> with no pure?
07:47:05 * djahandarie now understands
07:47:35 <zygoloid> ksf: in which case, yes. ((,) a) has a <*> and a <$> but no pure.
07:48:11 <zygoloid> some, but not all, of the applicative laws can be expressed without pure
07:48:22 <hpc> doesn't pure == fmap id?
07:48:30 <zygoloid> hpc: no. fmap id == id
07:48:36 <hpc> oh right
07:49:11 <ksf> fmap = ap . pure
07:49:13 <zygoloid> pure == liftA0, fmap == liftA1, f <$> x1 <*> x2 == liftA2, ...
07:49:51 <djahandarie> You wouldn't be able to define a Pointed instance for ANY Functor, right?
07:50:08 <zygoloid> djahandarie: no, for instance ((,) a) has no Pointed instance.
07:50:20 <djahandarie> Oh heh, you just said that didn't you
07:50:22 * djahandarie sighs
07:51:33 <zygoloid> but of course Monoid m => ((,) m) is a Monad so there's a possible Pointed instance for it
07:51:39 <BMeph> > loeb [insert 5, insert 3, insert 7, inser 1, insert 9]
07:51:40 <lambdabot>   Not in scope: `inser'
07:51:47 <BMeph> > loeb [insert 5, insert 3, insert 7, insert 1, insert 9]
07:51:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
07:52:18 <BMeph> So close... :(...
07:52:59 <hpc> :t loeb
07:53:00 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
07:53:19 <zygoloid> > loeb [head . insert 5, head . insert 3, head . insert 7, head . insert 1, head . insert 9]
07:53:21 <lambdabot>   [*Exception: stack overflow
07:53:24 <hpc> :t fix
07:53:24 <djahandarie> > (M.fromList [(1, "a"), (2, "b")]) `mappend` (point 1)
07:53:25 <lambdabot> forall a. (a -> a) -> a
07:53:26 <lambdabot>   Not in scope: `point'
07:53:41 <hpc> loeb looks like fix, a bit
07:54:04 <zygoloid> it is, a bit
07:54:14 <djahandarie> Would that work if there was an instance Pointed (Map k) ?
07:54:22 <hpc> > loeb [1]
07:54:23 <lambdabot>   [1]
07:54:34 <ksf> zygoloid, now I see the restriction.
07:54:46 <ksf> It's forbidding exactly what I want to do.
07:55:20 <ksf> it almost seems to be a rewrite rule $( [[ -> id  that's allowing my example, in the first place.
07:55:54 <ksf> ...but why aren't functions liftable?
07:56:03 <BMeph> > loeb [const 1 . length, (+2).head]
07:56:05 <lambdabot>   [1,3]
07:56:20 <BMeph> > loeb [const 1, length, (+2).head]
07:56:21 <lambdabot>   [1,3,3]
07:56:38 <BMeph> > loeb [const 1, pred .length, (+2).head]
07:56:39 <lambdabot>   [1,2,3]
07:56:46 * BMeph <3's loeb
07:56:51 <zygoloid> > loeb ([const 1, const 1] ++ map (\n -> (\(a:b:_) -> a+b) . drop n) [0..])
07:56:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:57:36 <djahandarie> Wow, nice
07:57:39 <zygoloid> ksf: functions aren't liftable because you can't take an arbitrary closure and convert it to an expression which generates that closure, in general.
07:58:16 <djahandarie> > ([const 1, const 1] ++ map (\n -> (\(a:b:_) -> a+b) . drop n) [0..])
07:58:17 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> t)
07:58:18 <lambdabot>    arising from a use of...
07:58:33 <ksf> I'd even be content with just sticking it into the ast
07:58:34 <ksf> or even attaching it to a name
07:58:40 <BMeph> > loeb [pred . pred .length, (+2).head, const 5]
07:58:42 <lambdabot>   [1,3,5]
07:59:09 <Jafet> > loeb ([const 0, const (-1)] ++ map (\n -> (\(a:b:_) -> a+b) . drop n) [0..])
07:59:10 <lambdabot>   [0,-1,-1,-2,-3,-5,-8,-13,-21,-34,-55,-89,-144,-233,-377,-610,-987,-1597,-25...
08:00:03 <BMeph> > loeb ([pred . (!!1), const 1] ++ map (\n -> (\(a:b:_) -> a+b) . drop n) [0..])
08:00:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:00:26 <ksf> http://okmij.org/ftp/tagless-final/
08:00:28 <ksf> and then along comes oleg
08:00:35 <ksf> bastard.
08:01:15 <zygoloid> ksf: doing it by name seems reasonable, i gave some code for that above.
08:02:07 <aristid> > loeb [length]
08:02:08 <lambdabot>   [1]
08:02:10 * BMeph would be afraid to read any paper written by Oleg and John C Reynolds; too much head 'sploading potential there...
08:02:21 <aristid> > loeb [length,0]
08:02:22 <lambdabot>   [2,0]
08:02:40 <ksf> I can't give every lamda a name...
08:02:53 <aristid> @src loeb
08:02:53 <lambdabot> Source not found. Wrong!  You cheating scum!
08:02:57 <ksf> and I don't want to suffer the untypedness of that, either.
08:03:06 <zygoloid> > loeb [(0:) . (!!1), (1:) . (!!0)]
08:03:07 <lambdabot>   [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
08:03:48 <aristid> how is loeb defined?
08:03:48 <zygoloid> ksf: why can't you give every lambda a name? the compiler should uniquify the names for you
08:04:24 <ksf> I can, if I write them in quotations
08:04:30 <ksf> in fact, I already did that.
08:04:43 <zygoloid> aristid: loeb = join (fmap . ($)), maybe?
08:04:58 <zygoloid> > join ((<$>).($)) [(0:) . (!!1), (1:) . (!!0)]
08:05:00 <lambdabot>   Couldn't match expected type `[[[t]] -> [t]]'
08:05:00 <lambdabot>         against inferred type...
08:05:02 <zygoloid> :(
08:05:32 <djahandarie> ?type (<$>).($)
08:05:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:05:57 <djahandarie> Huh
08:06:06 <zygoloid> @type (<$>).flip ($)
08:06:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
08:06:12 <geheimdienst> could anyone point me to a list which characters are allowed as infix functions? i was wondering if { is allowed (probably not)
08:06:28 <zygoloid> @type \f -> fmap ($ f) f
08:06:29 <lambdabot>     Occurs check: cannot construct the infinite type: a = f (a -> b)
08:06:29 <lambdabot>       Expected type: f (a -> b)
08:06:29 <lambdabot>       Inferred type: a
08:06:32 <ksf> nope brackets aren't.
08:06:51 <ksf> -- is taken, , , ;, and a couple of otherse.
08:06:51 <aristid> :t loeb
08:06:52 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
08:07:11 <zygoloid> @type \f -> let r = fmap ($ r) f in r
08:07:12 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
08:07:18 <aristid> yay.
08:07:23 <geheimdienst> ksf, but there are operators like --> in my xmonad config for example
08:07:25 <ksf> oh and things starting with : would have to be constructors
08:07:29 <ksf> yes.
08:07:31 <ksf> it's not --
08:07:32 <geheimdienst> so i think comments are really "-- "
08:07:33 <jmcarthur> > let a --| b = a + b in 5 --| 6   -- to confuse people who use haddock
08:07:35 <lambdabot>   11
08:07:41 <aristid> so loeb is like a fix for Functors? :D
08:07:53 <ksf> --<non-operator-char>
08:08:08 <ksf> > 1 --foo
08:08:09 <lambdabot>   1
08:08:13 <jmcarthur> geheimdienst: -- is like a keyword rather than reserved characters
08:08:21 <ksf> > 1 --< bar
08:08:22 <lambdabot>   Not in scope: `bar'Not in scope: `--<'
08:08:30 <hpc> > loeb [length]
08:08:31 <lambdabot>   [1]
08:08:31 <Jafet> <!-- This is -- so fun. -->
08:08:38 <djahandarie> lol....
08:08:48 <jmcarthur> geheimdienst: just like you can have an identifier named case1 but not named case
08:08:50 <aristid> > loeb (Just (const 0))
08:08:51 <lambdabot>   Just 0
08:09:00 <geheimdienst> oh i see
08:09:17 <geheimdienst> thanks a lot, guys
08:10:21 <BMeph> aristid: It's related to cfix, I believe. :)
08:10:57 <aristid> :t cfix
08:10:58 <lambdabot> Not in scope: `cfix'
08:11:05 <aristid> BMeph: cfix does not exist!! :D
08:11:09 <aristid> @hoogle cfix
08:11:09 <lambdabot> No results found
08:11:20 <zygoloid> @type fmap fix (flip (fmap fmap (flip ($))))
08:11:21 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
08:12:22 <BMeph> aristid: See edwardk's cat-extras. 
08:12:41 <BMeph> (Sorry; "category-extras".)
08:12:50 <Axman6> @djinn (Functor f) => f (f b -> b) -> f b
08:12:50 <lambdabot> Error: Class not found: Functor
08:12:54 <Axman6> :(
08:13:26 <jmcarthur> is that function even possible?
08:13:57 <BMeph> jmcarthur: Not only is it possible, it's Popular! ;)
08:14:11 <djahandarie> @hoogle (Functor f) => f (f b -> b) -> f b
08:14:12 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
08:14:13 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
08:14:13 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
08:14:18 <jmcarthur> oh i see a definition above
08:14:29 <aristid> BMeph: cat-extras is a sexier name anyways
08:14:30 <zygoloid> > let (--|)@I#{} = 0 in (--|)+0
08:14:32 <lambdabot>   Not in scope: data constructor `I#'
08:14:51 <jmcarthur> sexy-extras
08:15:13 <djahandarie> sexy-cats
08:15:44 <geheimdienst> cats-musical
08:16:51 <companion_cube> useless-use-of-cats
08:17:06 <zygoloid> general-nonsense
08:17:13 <BMeph> HOW-TO-Herd-cats
08:17:13 <jmcarthur> lolcategory-extras
08:17:16 <geheimdienst> abstract-nonsense
08:17:24 <geheimdienst> herding-cats would be a pretty good name
08:17:39 <aristid> geheimdienst: i like abstract-nonsense for the wonderful allusion
08:18:05 <geheimdienst> you mean that phd thesis we talked about a few weeks about?
08:18:30 <BMeph> Control.Category.Abstract.Zygomorphic.prepromorphism
08:18:59 <jmcarthur> Control.Category.Abstract.Zygohistomorphic.prepromorphism
08:19:29 * BMeph stands corrected! :)
08:19:47 <geheimdienst> don't tell me that is an actual term for something
08:19:51 <companion_cube> what a nice module to "import qualified"
08:19:57 <aristid> it's in Control.Morphism.*
08:19:58 * BMeph starts getting more funny looks than usual, and sits down again.
08:19:58 <aristid> noobs
08:20:05 <jmcarthur> geheimdienst: well, it is, but that doesn't mean anybody has used it
08:20:28 <geheimdienst> ... used it outside the "evolution of a haskeller" essay ...
08:20:40 <jmcarthur> geheimdienst: http://haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
08:21:22 <BMeph> Control.Category.Abstract.Zygomorphic.Zygohistomorphic.prepromorphism
08:21:41 <geheimdienst> guys, you need to get out in the fresh air more
08:21:45 <ksf> "Our initial motivation came from several papers [23, 24, 33, 37] that use em-
08:21:45 <ksf> bedded interpreters to justify advanced type systems, in particular GADTs. We
08:21:45 <ksf> admire all this technical machinery, but these motivating examples do not need
08:21:45 <ksf> it."
08:21:52 <BMeph> Control.Morphism.Abstract.Zygomorphic.Zygohistomorphic.prepromorphism -- better, aristid, jmcarthur? ;)
08:21:56 <djahandarie> If there is a cap on package name length, I think we are about to hit it
08:22:01 <jmcarthur> geheimdienst: what i mean is that the term is meaningful, but it is only used as a joke
08:22:15 <aristid> BMeph: that might be almost acceptable.
08:22:19 <geheimdienst> good. good.
08:22:32 <geheimdienst> Control.Jocular.Morphism...
08:22:40 <ksf> how many milliolegs are necessary to be so good as to be inable to be non-offensive?
08:22:48 <geheimdienst> oh wait, most of haskell would go into Control.Jocular
08:23:27 <jmcarthur> BMeph: needs more levels
08:23:30 <hpc> Control.YouHaveNone
08:23:56 <zygoloid> import qualified Control.Freak (this, that)
08:24:58 * pizza_ laughs
08:25:09 <zygoloid> import Data.Race (unamb)
08:25:45 <BMeph> import qualified Control.Freak (nudge, repeat, unsafeCoerce) -- much better, FSVO "better"... ;)
08:25:45 <geheimdienst> import qualified Control.Morphism.Abstract.Zygomorphic.Zygohistomorphic.prepromorphism as Zygocrap
08:28:30 <aristid> import Caleskell -- suffices
08:49:00 <pozic> I get cabal: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory. What do I need to install to get it to work? 
08:49:52 <geheimdienst> i'd try reinstalling cabal. looks like cabal was installed and later some prerequisites have been updated, which cabal can't find anymore
08:50:17 <pozic> What's the current easiest way to get cabal?
08:50:48 <geheimdienst> i guess, if you installed it through your distro's package manager, do that again :-)
08:52:41 <Axman6> did anyone else get n email from a head hunter from the UK today?
08:52:44 <Axman6> an*
08:53:39 * BMeph raises his hand
08:55:01 <Axman6> had a feeling i wouldn't be the only one
09:00:29 <dcoutts> pozic: no, the problem is you don't have the gmp package installed, you'll get the same from any prog compiled by ghc
09:01:13 <dcoutts> pozic: unless you really do have gmp installed but a newer version than the one you used to compile cabal
09:05:28 <djahandarie> I know that DiffArray is really slow, but is it still O(1) time for an update?
09:06:20 <Jafet> I believe it gets muddled depending on which version you use
09:06:32 <Jafet> (Version of the array)
09:07:31 <Jafet> In other words, most likely to put okasaki in a berserk rage award
09:08:35 <djahandarie> lol...
09:10:35 <djahandarie> You know
09:10:40 <djahandarie> I can't even find the diffarray package
09:24:12 <ManateeLazyCat> Looks, all of modern Web-Browser-Engine haven't implement model/veiw split..... 
09:25:04 <ManateeLazyCat> Hope WebKit2 release, then i can build some way split context and client render....
09:26:59 * ManateeLazyCat Currently, when you split Web Page with two view, you can't *just* render result like TextView for TextBuffer, you need calculate twice with Web Page resource....
09:29:23 <ChickenSalad> So I built a new computer and just downloaded the haskell platform.  This is what I thought I'd try after 3mo without haskell:  Prelude> Control.Monad.forever (putStr "Give me input: " >> getLine).  I can't believe I laughed at myself for that joke  xD
09:29:33 * ManateeLazyCat http://trac.webkit.org/wiki/WebKit2
09:31:12 <geheimdienst> > Control.Monad.forever (putStr "Give me input: " >> getLine)
09:31:14 <lambdabot>   Ambiguous type variable `b' in the constraint:
09:31:14 <lambdabot>    `Data.Typeable.Typeable b...
09:33:00 <aristid> ChickenSalad: what's funny about that?
09:33:40 <pozic> Axman6: what is the name of this headhunter? 
09:33:41 <geheimdienst> #haskell, a place where people use lambdabot to execute your jokes
09:33:46 <ChickenSalad> aristid: Just keeps asking for input.  I haven't used haskell in ages so it's nice to see I remember the syntax  :P
09:34:32 <aristid> uh whatever
09:34:55 <ChickenSalad> aristid: It would take me an hour to get that to compile a year ago haha
09:35:51 <aristid> ChickenSalad: wow, you were bad.
09:36:03 <aristid> but now that you've not used it, your skills seem to have improved.
09:36:26 <ChickenSalad> aristid: So I guess you learned haskell instantly?  That's nice...
09:37:16 <aristid> ChickenSalad: of course. i always learn everything instantly.
09:37:32 <aristid> ask me about zygohistomorphic prepromorphisms
09:38:00 <ChickenSalad> aristid: I love how I still have that memorized; exact spelling and all
09:38:29 <chrisdone> @users
09:38:30 <lambdabot> Unknown command, try @list
09:38:33 <chrisdone> @activity
09:38:33 <lambdabot> 1*total 1*#haskell
09:38:44 <chrisdone> what's that one that shows how many users there are and the average?
09:38:57 <pizza_> @list
09:38:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:39:12 <chrisdone> pizza_: pizza_ of ##c fame?
09:39:35 <chrisdone> hmm. @users is on that COMMANDS file, but here it says unknown command. out of date?
09:39:41 <pizza_> i'm in ##c, yes
09:40:01 <chrisdone> oh. i used to chat to you on ##c under another name, that's all
09:40:41 <pizza_> :)
09:41:08 * edwardk_ waves hello.
09:41:55 <ChickenSalad> :D
09:42:51 <geheimdienst> what kinduva channel is ##c?
09:44:20 <pizza_> mostly insults and endless philosophizing, some C programming
09:44:38 <ddarius> edwardk: Heya
09:44:57 <edwardk> ddarius: been thinking about how i schedule sparks in speculation
09:45:34 <edwardk> spec g f a does exactly the right thing. it runs the 'f g' in the spark so it can be thrown away at the RTS's whim
09:45:41 <edwardk> that much makes me happy
09:45:51 <edwardk> but I can't do that with specSTM
09:46:12 <BMeph> Sounds like #math... ;)
09:46:14 <edwardk> because the main task is an STM action, the thing I have to run in the background is the calculation of 'a'
09:46:20 <tensorpudding> #haskell is on topic less than most programming language channels on Freenode
09:46:57 <edwardk> which _is_ the thing that i absolutely must have to continue the computation -- not the value of 'f g' that is being computed inside the STM monad.
09:47:15 <pizza_> tensorpudding: perhaps, but it needs to work on insulting questioners first
09:47:25 <edwardk> so now, what can happen is that if the spark queue overflows, the wrong part of the computation can get thrown away
09:47:33 <tensorpudding> or it seems as much
09:47:41 <edwardk> and i'm trying to figure out what deep tricks i can play to keep that from happening
09:48:10 <edwardk> ideally i'd like to 'background' the current stm calcuation, and continue running the pure computation in the foreground.
09:48:32 <edwardk> but it is tricky to do anything with IO when inside STM because the semantics of when everything goes to hell is a bit flaky
09:48:53 <edwardk> does that make sense?
09:48:56 <ddarius> edwardk: I actually have to leave like right now.
09:49:02 <edwardk> ddarius: fair enough =)
09:50:24 <edwardk> i'm curious if i can get the semantics i want by using par and seq in particularly twisty ways but it isn't coming to me
09:51:16 <edwardk> or even trying to hand off my RealWorld to the spark! and getting it back by forcing the result.
10:08:29 <jmcarthur> edwardk: what is the type and semantics of specSTM?
10:09:36 <edwardk> jmcarthur: well
10:09:42 <jmcarthur> well, found the type http://www.youtube.com/watch?v=Y00P1hta4yo
10:09:44 <jmcarthur> oops
10:09:47 <jmcarthur> what is that?
10:09:54 <jmcarthur> ha fez
10:10:00 <jmcarthur> cool game, but not intentionally pasted here
10:10:08 <jmcarthur> specSTM :: Eq a => STM a -> (a -> STM b) -> a -> STM b
10:10:12 <jmcarthur> that's what i meant to paste :P
10:10:14 <edwardk> jmcarthur: specSTM :: Eq a => STM a -> (a -> STM b) -> a -> STM b
10:10:17 <edwardk> yeah
10:10:32 <jmcarthur> found the docs too
10:10:34 * jmcarthur reads
10:11:38 <edwardk> it turns out this is the only reason i can ever think of to move an STM calculation into a spark where i know i'll rendezvous with it (or at least throwTo it)
10:11:55 <Svinfors> 20:11 < jmcarthur> found the docs too
10:12:26 <jmcarthur> Svinfors: i'm just looking at the haddock on http://github.com/ekmett/speculation/blob/master/Control/Concurrent/Speculation.hs
10:12:43 <djahandarie> jmcarthur, wow that is quite cool
10:13:44 <edwardk> http://hackage.haskell.org/package/speculation-0.7.0 has the same docs
10:13:54 <edwardk> (the more recent versions haven't built yet)
10:17:07 <edwardk> jmcarthur: up to speed yet?
10:17:17 <jmcarthur> up to speed on the spec, reading backlog here now
10:18:07 <edwardk> spec g f a works perfectly (if i do say so myself), but specSTM g f a will not degrade as gracefully under high load
10:19:37 <jmcarthur> edwardk: okay so your concern is that the a spark could get thrown away, destroying your critical path?
10:20:38 <edwardk> well, sparks do get thrown away, it won't destroy my critical path, but it'll continue executing the non-critical bits before rendevzousing wih the calculation of 'a' which hasnt happened at all, and so the STM timeline under load will stretch out even farther
10:21:08 <jmcarthur> edwardk: well, that's what i meant. it will make your critical path take longer
10:21:29 <jmcarthur> edwardk: you're wanting your critical path to be the 'active' computation
10:21:33 <jmcarthur> ?
10:22:15 <edwardk> in a perfect world i'd take the current STM transaction, hand it off to the spark somehow so that it knew that it was still the current maintainer of the transaction, then compute 'a', and once that is computed compare it with g, and kick the transaction if they don't equal, otherwise rendezvous with it.
10:22:45 <edwardk> in practice i'd be happy to just let the stm calculation not start if the spark queue was full, or any of a dozen other workarounds
10:22:52 <edwardk> i'm just not happy with the current behavior
10:22:57 <jmcarthur> yeah
10:23:28 <edwardk> internally there are like a dozen parFoo# primops, i just don't know what they all mean ;)
10:29:35 <zygoloid> edwardk: s/unsafeIsEvaluated/unsafeIsProbablyEvaluated/ ;-)
10:29:56 <zygoloid> (it can give false negatives)
10:30:29 <edwardk> zygoloid: hah
10:30:36 <edwardk> i can change the name yet again ;)
10:30:55 <edwardk> zygoloid: it is proving to be a damn useful little hack
10:32:13 <edwardk> it is also annoying to test because in ghci it always says 'False' ;)
10:32:26 <edwardk> (since bytecode values don't get tagged)
10:33:05 <edwardk> jmcarthur: i think i may be out of luck without hacking the RTS somehow, because the phrasing is that sparks get promoted into threads when run
10:33:17 <edwardk> and so if it was another thread it'd have its own STM machinery
10:33:37 <dons> ?bug
10:33:37 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:34:03 <edwardk> perhaps i could do something like start computing 'a' that doesn't care about the STM queue and see if i can make the spark somehow magically swap thread ids with the other computation or something
10:34:13 <jmcarthur> o_O
10:34:59 <jmcarthur> all i can think of is to not use sparks at all :\
10:35:08 <jmcarthur> which of course would be much less scalable
10:35:16 <edwardk> that would kind of destroy the purpose =)
10:35:20 <jmcarthur> yeah
10:35:40 <edwardk> the stm version works fine, even under decent load, but its just not as good as the fairly awesome pure version
10:35:44 <jmcarthur> oh and it would require a forkIO, so you couldn't just use the whole thing in a single STM transaction either
10:36:06 <edwardk> which won't work, since i need this to happen in a nested context so i can backtrack and retry
10:36:13 <edwardk> and so that speculations can speculate, etc.
10:36:13 <jmcarthur> i figured
10:37:17 <edwardk> i could fix this other ways i suppose, like try to hand tune a 'max speculation depth' parameter
10:37:22 <edwardk> by tracking it in a tvar
10:38:04 <edwardk> speculationDepth :: TVar Int; specSTM then reads it, and bumps it or doesn't speculate
10:38:44 <edwardk> but that sort of local reasoning doesn't encompass global pressure on the spark queue
10:39:09 <edwardk> and the spec depth would probably need to be carried around in a reader wrapped around STM, so the combinators would wind up using a custom speculation monad
10:39:19 <edwardk> though that too has promise
10:39:41 <edwardk> heya shapr
10:39:51 <jmcarthur> doesn't sound pretty either
10:40:16 <Leosirth3> hi
10:40:33 <shapr> y0 edwardk, wassup?
10:40:44 <tommd> Anyone here interested in the crypto infrastructure reworking?
10:40:56 <edwardk> tommd: yes, but i have too many other projects ;)
10:41:06 <shapr> I'm interested in the result :-)
10:41:20 <tommd> I'll be sending out an e-mail soon (ish) wrt semantics... but I'll ask the question here first.
10:41:51 <edwardk> tommd: i have a bunch of imperative implementations of various cryptographic algorithms i could port to haskell (or someone else could) including some fairly esoteric cryptographic hashes, like HAS-V, etc.
10:42:21 <tommd> Should the type class instances (ex for hash: initialCtx, update, and finalize    ex for BlockCipher: encryptBlock, decryptBlock) require exactly one blockSize worth of data? 
10:42:24 <edwardk> tommd: oh, i had a request to refactor tagged a bit, perhaps into Data.Phantom.Tagged and Data.Phantom.Proxy.
10:42:41 <tommd> edwardk: That's me
10:42:47 <edwardk> tommd: and to drop the data-default instance because data-default drags in containers.. which kind of defeats the purpose of having the module.
10:42:52 <edwardk> ah =)
10:43:07 <edwardk> so it is
10:43:32 <tommd> Or perhaps instance should be able to work on non-padded data... or perhaps they should be expected to work on any data that is a multiple of blockSize.
10:43:37 <edwardk> well, another one, from jonas duregard, unless that is you too ;)
10:43:58 <yshavit> Hi all. I'm a procedural/OO programmer by training, but looking into FP. I wrote up a function using Python, actually -- since I already knew it -- and I was wondering if someone could take a look at it from a FP-perspective (that is, language agnostically). The function takes in a tuple (a,b...n) and returns back a list of tuples, each of which is a copy of the input with 0-n of the items replaced by an empty string. http://ideone.com/A7inC
10:44:14 <clanehin_> ok, something's going on b/c I see ghc using 300 MB, calling out to ld which is using another 170 MB, to build an app with < 10,000 locs
10:44:33 <clanehin_> the OOM is killing my login session over this, even if they both need that much RAM, surely not at the same time.
10:44:50 <yshavit> and my apologies in advance if I shouldn't be asking this here... I tried in #python and it sounded like FP-specific questions weren't really right there.
10:44:50 <clanehin_> unless I'm wrong
10:47:49 <shapr> yshavit: Python got me into Haskell, so...
10:47:53 <zygoloid> > forM [1,2,3] (\a -> [show a, ""])
10:47:54 <lambdabot>   [["1","2","3"],["1","2",""],["1","","3"],["1","",""],["","2","3"],["","2","...
10:47:57 <zygoloid> yshavit: ^^ how i'd do it
10:48:57 <electriceloquenc> zygoloid: True and nice, but perhaps not comprehensible to a python programmer
10:49:17 <yshavit> lambdabot: yes, that's my output... and zygoloid, sorry, I didn't get that :)
10:49:18 <geheimdienst> yshavit, welcome to #haskell. this is what always happens. you post 25 lines of code, the gurus meditate for 5 mins, then come up with some oneliner that takes 50 lines of chat to explain
10:49:19 <geheimdienst> :-)
10:49:30 <yshavit> haha, fair enough! I'm here to learn.
10:50:09 <sproingie> @pl forM x (\a -> [show a, ""])
10:50:21 * sproingie pokes lambdabot
10:50:42 <shapr> I think it's dead.
10:50:46 <sproingie> i killed it
10:50:46 <zygoloid> yshavit: lambdabot was evaluating my expression so you can see it's right :)
10:51:20 <zygoloid> yshavit: forM (for the [] monad) is nondeterministically choosing one of (show a) and ("") for each element in the list, then producing all the possible results.
10:54:05 <zygoloid> yshavit: in python: def forM(xs, fs):\n  if not xs: return []\n  x, *rest = xs\n  return [list(f x, *fxs) for fxs in forM(rest, fs) for f in fs]
10:55:04 <zygoloid> yshavit: then forM([1,2,3], lambda a: [a, ""]) should give you what you want
10:55:05 <shapr> I wish we had some out-of-band way to HUP lambdabot 
10:56:02 <zygoloid> yshavit: figuring out the indices you want to remove then removing them feels a bit imperative for my tastes :)
10:57:01 <zygoloid> @src forM
10:58:58 <zygoloid> forM [] _ = return []; forM (x:xs) f = do v <- f x; vs <- forM f xs; return (v:vs)
10:59:45 <sproingie> zygoloid: unfortunately python doesn't let you do a,*b=c
10:59:55 <sproingie> splitty splitty
11:00:53 <zygoloid> sproingie: i was sure i saw an accepted PEP which added that :(
11:01:19 <sproingie> zygoloid: oh maybe later versions do
11:01:26 <zygoloid> well, i've tested 2.6 and it doesn't.
11:01:29 <sproingie> latest version i have here is 2.5
11:01:58 <Veinor> what's the canonical 'good' monad tutorial-like?
11:01:59 * zygoloid tries 3.1
11:02:15 <sproingie> Veinor: You Could Have Invented Monads is pretty good
11:02:23 <yshavit> Veinor: in case that got lost in the netsplit, I was agreeing with you that I don't understand monads :)
11:02:29 <yshavit> I assume they're like nomads but under rot(-1)
11:03:05 <Veinor> yshavit: no, I saw it
11:03:08 <ziman> @quote monads are like
11:03:08 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
11:03:17 <sproingie> Learn You A Haskell doesn't teach you monads at all but it teaches you enough about applicatives that when you do get to monads they'll be trivial
11:03:18 <zygoloid> @quote haiku
11:03:19 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
11:03:23 <zygoloid> @quote monad.*haiku
11:03:24 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:03:37 <medfly> @src fmap
11:03:38 <lambdabot> Source not found. Where did you learn to type?
11:03:39 <ziman> @quote monads.*like
11:03:39 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
11:03:40 <lambdabot> a really bad one
11:03:40 <medfly> :-(
11:03:41 <Leosirth> hi
11:03:59 <zygoloid> @quote lilac monad
11:04:00 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
11:04:04 <sproingie> @quote burrito
11:04:04 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
11:04:24 <Veinor> yshavit: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html if you want to read
11:04:35 <Veinor> ychim does seem like a good tutorial, reading over it
11:04:45 <zygoloid> sproingie: woo, my memory isn't broken. python 3.1 allows x, *xs = ys
11:05:15 <Leosirth> i have a list of tuples where the first element is a char and the second is a string.....there is a function that groups the tuples by the first element merging their string?
11:05:41 <zygoloid> yshavit: another perspective here: http://metafoo.co.uk/practical-monads.txt
11:05:49 <edwardk> jmcarthur: still around?
11:05:52 <monochrom> Like this? zipWith (:)
11:06:10 <jmcarthur> :t groupBy
11:06:11 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:06:16 <monochrom> > zipWith (:) [ ('a', "hi"), ('b', "aloha") ]
11:06:17 <lambdabot>   Overlapping instances for GHC.Show.Show
11:06:17 <lambdabot>                              ([[(GH...
11:06:23 <jmcarthur> edwardk: wow, my lag is 358.7 seconds...
11:06:46 <yshavit> Veinor, zygoloid: I'll load those on my kindle for the commute home :)  Thanks!
11:06:53 <medfly> yeah that's the netsplit ^^
11:06:57 <monochrom> Oh oops, not quite zipWith (:)
11:07:00 <sproingie> when your email lag is shorter than your irc lag ...
11:07:23 <monochrom> > zipWith (:) (unzip [ ('a', "hi"), ('b', "aloha") ])
11:07:24 <lambdabot>   Couldn't match expected type `[a]'
11:07:25 <lambdabot>         against inferred type `([GHC.Typ...
11:07:28 <zygoloid> Leosirth: map (fst . head &&& concatMap snd) . groupBy ((==) `on` fst). sort
11:07:39 * hackagebot yajl 0.2 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.2 (JohnMillikin)
11:07:43 <edwardk> jmcarthur: wanted to pick your brain re vector-static
11:07:44 <monochrom> nevermind
11:07:58 <Leosirth> well i have like [(a, "he"), (a, "llo")] and i what a result like [(a, "hello")]
11:08:30 <edwardk> jmcarthur: i just found myself kind of stuck implementing mostly the same thing
11:08:48 <zygoloid> > map (fst . head &&& concatMap snd) . groupBy ((==) `on` fst). sort $ [('a', "Hello "), ('b', "Goodbye"), ('a', "World")]
11:08:49 <lambdabot>   [('a',"Hello World"),('b',"Goodbye")]
11:09:02 <sproingie> oooh
11:09:05 <sproingie> pretty
11:09:12 <Saizan> > M.toList . M.fromListWith (++) $ [(a, "he"), (a, "llo")]
11:09:13 <lambdabot>   [(a,"llohe")]
11:09:15 * hpc does not grok arrows
11:09:19 <zygoloid> Leosirth: ^^ that will sort by the snd as well as the fst, so you might want to change the sort to (sortBy (comparing fst))
11:09:34 <zygoloid> Saizan: nice :)
11:09:47 <Saizan> wrong order though..
11:09:59 <zygoloid> just use flip (++). no-one will noticve :)
11:10:06 <dafis> > M.toList . M.fromListWith (flip (++)) $ [(a, "he"), (a, "llo")]
11:10:08 <lambdabot>   [(a,"hello")]
11:10:15 <Veinor> does M.fromListWith guarantee ordering?
11:10:20 <Leosirth> well thanks all, i don't care about sorting
11:10:34 <Saizan> > M.toList . M.fromListWith (flip (++)) $ [(a, "he"), (a, "llo"), (a,"foo")]
11:10:38 <lambdabot>   [(a,"hellofoo")]
11:10:46 <geheimdienst> > M.toList . M.fromListWith (++) $ [(a, "llo"), (a, "he")]
11:10:47 <lambdabot>   [(a,"hello")]
11:10:48 <dafis> Veinor: in what sense?
11:11:20 <zygoloid> Veinor: yes, looks like
11:11:25 <dafis> Veinor: it inserts the list elements into the set in the order in which they appear in the list
11:11:35 <zygoloid> Veinor: it's implied by the examples. fromList guarantees it takes the last value for a key.
11:11:39 <Veinor> ah, so it is guaranteed then
11:11:46 <dafis> s/set/map/
11:12:16 <dafis> if a key is already present, it combines with f newValue oldValue
11:12:47 <zygoloid> insertWith guarantees that. fromListWith doesn't appear to guarantee that it uses the semantics of insertWith :(
11:13:10 <dafis> zygoloid: I trust the sources
11:13:20 <Veinor> source-diving says it does :)
11:14:36 * zygoloid prefers not to rely on undocumented behaviour
11:14:41 <Leosirth> thanks all again ;)
11:15:57 <Veinor> http://stackoverflow.com/questions/1732348//1732454#1732454
11:16:02 <monochrom> sometimes documentation is in a miserable incomplete state
11:16:44 <monochrom> because programmers rely on "natural language semantics is so obvious to me"
11:17:10 <Phyx-> and because programmers don't like to document
11:17:54 <monochrom> and some programmers even argue that "the name fromListWith is self-documenting, just look at the With part". you know who they are. the programmers who believe in the dogma of "self-documenting identifiers"
11:18:42 * lispy quotes something about a rose and names
11:19:00 <mauke> preflex: seen geheimdienst 
11:19:00 <preflex>  geheimdienst was last seen on #haskell 8 minutes and 14 seconds ago, saying: > M.toList . M.fromListWith (++) $ [(a, "llo"), (a, "he")]
11:19:42 <geheimdienst> it is also silly to "document" the XMonad.Prompt.Workspace module as: "A workspace prompt for XMonad". this doesn't add anything over "self-documenting" function names
11:19:50 * mauke stares at geheimdienst 
11:20:05 <geheimdienst> hi mauke
11:20:08 <geheimdienst> what's going on?
11:20:08 <mauke> hi
11:20:22 <mauke> "virii" is a nonsense plural, "radii" and "boxen" aren't
11:20:45 <medfly> boxen is Dutch no? :/
11:20:50 <mreh> do (sf1, (b0, c0)) <- tf10 (a0, c0) -- how to make circular?
11:20:54 <monochrom> if anything it should be either viri or viruses
11:21:08 <sproingie> i work for an AV company.  we say "viruses"
11:21:15 <sproingie> actually we usually say "malware"
11:21:19 <mauke> monochrom: "viri" is extremely unlikely
11:21:32 <monochrom> use mfix or mdo to make circular. http://www.haskell.org/haskellwiki/MonadFix
11:21:37 <mauke> mreh: mfix
11:21:40 <monochrom> yeah it should be viruses
11:21:45 <mreh> :t mfix
11:21:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:21:48 <sproingie> i took two bii to work
11:22:09 * geheimdienst thinks "radiuses" is normal and "radii" is said only to be pompous
11:22:12 <mauke> "bus" actually comes from "omnibus", meaning "for all [people]"
11:22:15 <dafis> mreh: the new recursive do extension
11:22:19 <monochrom> there are two wii, white and black. :)
11:22:40 <geheimdienst> monochrom, two wusses?
11:22:40 <mreh> ooooh, like in arrow syntax
11:22:41 <mauke> geheimdienst: "radiuses" looks awkward, "radii" is latin
11:23:02 <sproingie> pronounced ray-dee-eye
11:23:03 <monochrom> http://en.wikipedia.org/wiki/Wii
11:23:20 <mauke> did you mean: ra-di-i
11:23:28 <geheimdienst> monochrom, i like the wusses explanation better. i'll believe that, thanks. :-)
11:23:31 <sproingie> not where i come from
11:23:31 <mreh> wii is more like "sheep"
11:23:40 <monochrom> I have never seen "radiuses".
11:23:55 <geheimdienst> http://dictionary.reference.com/browse/radiuses
11:24:12 <mauke> I guess learning Latin as your first foreign language does that to you
11:24:35 <sproingie> i guess proper latin would be "rahd-ee-oos"
11:25:03 <geheimdienst> spoingie, but what's the point of that, other than for bragging?
11:25:06 <sproingie> but the long a sounded better to someone so it stuck
11:26:13 <jmcarthur> edwardk: hey i'm back, sorry
11:26:51 <jmcarthur> edwardk: on vector-static... the reason i abandoned it was because it was so darn tedious and i decided that i didn't really need it
11:27:28 <mauke> preflex: seen jcreigh 
11:27:28 <preflex>  jcreigh was last seen on #haskell 18 days, 2 hours, 46 minutes and 7 seconds ago, saying: in fairness, gcc's job is more straightforward than GHC's job. :)
11:27:48 * hackagebot Vec-OpenGLRaw 0.2.0.1 - Instances and functions to interoperate Vec and OpenGL.  http://hackage.haskell.org/package/Vec-OpenGLRaw-0.2.0.1 (ChristopherLaneHinson)
11:27:48 * geheimdienst thinks it's mostly showmanship behind the push to complicate language
11:27:56 <jcreigh> mauke: yes?
11:28:02 <RayNbow> mauke: Latin was your first foreign language? *blinks*
11:28:18 <mauke> jcreigh: you're the author/maintainer of XMonad.Actions.Submap, right?
11:28:59 * geheimdienst is astonished how preflex says jcreigh was last seen 18 days ago, but shows up in seconds once his name is mentioned
11:29:03 <EvanCarroll> why doesn't this work ? deleteBy (>=) 5 [0..10]
11:29:09 <jcreigh> well, I *think* I'm the author, although I haven't touched xmonad code in years
11:29:11 <mauke> :t deleteBy
11:29:13 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
11:29:40 <jcreigh> is it giving you trouble?
11:29:50 <mauke> jcreigh: I wanted an extension to submapDefault, where the default action gets passed the (KeyMask, KeySym) pair that wasn't found
11:30:14 <Veinor> > deleteBy (>=) 5 [0..10]
11:30:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:30:25 <mauke> @src deleteBy
11:30:26 <lambdabot> deleteBy eq x []        = []
11:30:26 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
11:30:45 <geheimdienst> @doc deleteBy
11:30:46 <lambdabot> deleteBy not available
11:31:01 <Veinor> deleteBy has to have an equivalence relation
11:31:15 <Veinor> >= isn't an equivalence relation
11:31:17 <name> >deleteBy 5 [0..10]
11:31:18 <monochrom> deleteBy is not supposed to work for >=
11:31:30 <geheimdienst> wait wait, you got it wrong:
11:31:37 <name> >deleteBy (==) 5 [0..10]
11:31:39 <geheimdienst> > delete 5 [1,5,2,5,3]
11:31:40 <lambdabot>   [1,2,5,3]
11:31:44 <name> damn
11:31:51 <mauke> > deleteBy (<=) 5 [0..10]
11:31:52 <lambdabot>   [0,1,2,3,4,6,7,8,9,10]
11:32:13 <geheimdienst> now deleteBy extends delete and you can pass in your own function to determine equality
11:32:36 <monochrom> And then, some programmers are in the miserable state of not reading documentation when documentation is crystal clear.
11:32:40 <edwardk> jmcarthur: i started working on something similar for dealing with blas bindings is why it came up
11:32:52 <geheimdienst> about those deleteBy (<) things flying around, i don't even know what that means. i'm pretty sure that doesn't make any sense at all
11:33:15 <geheimdienst> >filter (<= 5) [1,2,3,4,5,6,7,8]
11:33:16 <monochrom> It makes no sense.
11:33:16 <edwardk> jmcarthur: except that unlike vector, i needed to deal with strided array accesses
11:33:19 <geheimdienst> > filter (<= 5) [1,2,3,4,5,6,7,8]
11:33:20 <lambdabot>   [1,2,3,4,5]
11:33:22 <EvanCarroll> why doesn't it work with >= as in my example, it fits the prototype of a -> a -> Bool
11:33:27 <mauke> EvanCarroll: it works fine
11:33:46 <monochrom> I do recommend base to change behaviour of deleteBy, groupBy... every minor version to frustrate abuses.
11:34:10 <jmcarthur> edwardk: ah, so i take it you're doing some matrix math and stuff?
11:34:12 <geheimdienst> evancarroll: you're supposed to pass in a function a->a->Bool that finds out if arg1 is equal to arg2
11:34:20 <geheimdienst> (<=) doesn't make sense for that
11:34:23 <dafis> EvanCarroll, you may be oblivious to the fact that delete(By) only deletes one (or no) element from the list
11:34:27 <geheimdienst> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html#v%3Adelete
11:34:30 <monochrom> > [0,1,2] !! (-3)
11:34:31 <lambdabot>   *Exception: Prelude.(!!): negative index
11:34:40 <monochrom> Why doesn't that work?!!???!!!111!!!
11:34:44 <monochrom> :type (!!)
11:34:49 <mauke> monochrom: because Haskell is inferior
11:34:50 <geheimdienst> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html#v:deleteBy
11:34:50 <monochrom> :t (!!)
11:34:51 <lambdabot> forall a. [a] -> Int -> a
11:34:59 <EvanCarroll> dafis: right, I would have accepted it if it delete any elements, but it didn't delete any in my example.
11:35:00 <geheimdienst> > Why doesn't that work?!!???!!!111!!!
11:35:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:35:02 <monochrom> It sayz it accepts Int!
11:35:06 * jmcarthur wishes it was [a] -> Word -> a or something
11:35:07 <edwardk> jmcarthur: i was getting ready to, mostly so i could change over from matrices of taylor series to taylor series of matrices in my 'ad' code.
11:35:09 <EvanCarroll> deleted*
11:35:16 <edwardk> jmcarthur: http://github.com/ekmett/blase/tree/master/Numeric/BLAS/Raw/ is a _very_ rough sketch
11:35:18 <jmcarthur> aha
11:35:24 <EvanCarroll> back to SO.
11:35:30 <mauke> EvanCarroll: it deleted the first element
11:35:38 <mauke> EvanCarroll: 5 >= 0
11:35:39 <geheimdienst> > "Why doesn't that work?" !! 1 !! 11
11:35:40 <lambdabot>   Couldn't match expected type `[a]'
11:35:40 <lambdabot>         against inferred type `GHC.Types...
11:35:43 <geheimdienst> > "Why doesn't that work?" !! 1
11:35:44 <lambdabot>   'h'
11:35:55 <EvanCarroll> mauke++: ah it did.
11:35:58 <geheimdienst> > ["Why doesn't that work?"] !!1!!11
11:35:59 <lambdabot>   *Exception: Prelude.(!!): index too large
11:36:03 <geheimdienst> > ["Why doesn't that work?"] !!11!!1
11:36:03 <lambdabot>   *Exception: Prelude.(!!): index too large
11:36:09 <EvanCarroll> nifty.
11:36:18 <geheimdienst> > ["","Why doesn't that work?"] !!1!!1
11:36:19 <lambdabot>   'h'
11:36:20 <electriceloquenc> anyone suggest a book to read after "Haskell Road" for getting to know more math/theory related to fp?
11:36:23 <geheimdienst> > ["","Why doesn't that work?"] !!1!!11
11:36:24 <lambdabot>   ' '
11:36:36 <davekong> Does it makes sense that if when running an application CPU usage goes up to 100% the program may hang and not terminate?
11:36:36 <edwardk> Raw.Array ~ Vector without the ability to trim the ends, and the ability to define per type, how it handles raw and pure storage, so i can use the same basic container type for Doubles as I do for AD vars, Raw.Vector ~ Vector with large step sizes.
11:37:00 * geheimdienst succeeds at making monochrom's yell syntactically correct, even a little meaningful.
11:37:05 <dafis> davekong: that may happen
11:37:25 <davekong> dafis: Is there some way to avoid this?
11:37:33 <edwardk> jmcarthur: the idea being that with strided vectors like that i can use blas bindings directly if i can come up with a usable form of 'blas fusion' to keep working with mutable vectors/arrays as long as possible.
11:37:34 <dafis> it's not always easy to determine whether it hangs, though
11:38:01 <dafis> davekong: depends on what actually happens
11:38:18 <edwardk> the devil's advocate in me thinks that i might do better just using stream fusion though and doing it all haskell-side.
11:38:49 <jmcarthur> edwardk: in vector-static i made an Unbox instance for Vec so you could nest unboxed Vecs. since their dimensions are static, you can make a matrix with this. i don't know how blas represents matrices, but maybe they are compatible internally?
11:38:53 <dafis> davekong: for example, it might be stuck in an infinite loop, then kiling it is the only way out
11:39:04 <dafis> s/kiling/killing/
11:39:08 <edwardk> another devil's advocate in me (its crowded in here!) thinks that it may be worth working with a 'script' of what to do to the variables and run it through an interpreter using recovered sharing info
11:39:23 <edwardk> blas has lots of representations of matrices =/
11:39:28 <jmcarthur> aw
11:39:41 <jmcarthur> oh blas does mutation?
11:39:49 <jmcarthur> that's kind of stinky for this
11:39:52 <mauke> no taxation without representation!
11:39:56 <edwardk> not so much
11:39:57 <edwardk> yeah, by default all the combinators mutate
11:40:28 <jmcarthur> hmm
11:40:31 <davekong> dafis: I mean assuming the logic is such that it whould terminate
11:40:33 <edwardk> because it means if i use freezing and thawing, i could just elide the freeze with rewrite rules or by interpreting the operations as a tree
11:40:34 <monochrom> maybe I can whine on haskell-cafe through gmane.
11:41:30 <jmcarthur> edwardk: that seems pretty reasonable unless you need sharing
11:41:31 <edwardk> two thoughts on that, one is to store an ivar or mvar in each matrix, and if you need to get an answer out before you can 'run the whole linear algebra computation, just use boring slow pure matrix ops, maybe binding to blas for each but copying your heart out
11:41:43 <edwardk> that remains 'work safe'
11:41:52 <edwardk> in the sense that it never does more than a pure implementation would
11:41:53 <aristid> monochrom: use something like "Doubts about Haskell" as the title.
11:41:57 <davekong> dafis: I run a fibonacci function for a small value and it works pretty fast then I step n up by one and it seems to hang forever
11:42:07 <monochrom> No, "Doubts about Programmers"
11:42:16 <monochrom> "Doubts about Programmer Intelligence"
11:42:21 <dafis> davekong: overflow possible?
11:42:29 <aristid> monochrom: doubts? everybody knows that programmers are lazy and stupid bastards!
11:42:39 <edwardk> then i could walk back over and recover sharing information from the expression tree and do the bulk of it (i.e. wherever you didn't use a dot product to get out a scalar) using mutation behind your bac
11:42:40 <aristid> they often don't even show up at 8 am.
11:42:43 <davekong> dafis: I should get an error if that happens though?
11:43:15 <dafis> davekong: usually not, normally, overflow is silent wraparound
11:43:25 <dafis> davekong: code?
11:44:35 <edwardk> basically annotate the matrices, etc. with a type level brand, and define some kind of eval  that takes a branded computation and runs it, like i do with AD, using the ivar/mvar (expr-var?) machinery to handle the corner cases we'd like to have where you extract intermediate results like dot products too early
11:44:56 <davekong> dafis: fib 1 = 1; fib 2 = 1; fib n = fib (n - 2) + fib (n - 1)
11:45:04 <jmcarthur> doesn't have the elegance that stream fusion has :(
11:45:05 <davekong> when I ran it with fib 40 it hung
11:45:13 <EvanCarroll> I just ordered another haskell book online, http://www.amazon.com/gp/product/0201342758/ref=oss_product
11:45:18 <davekong> then I compiled with O3 and it takes a few seconds
11:45:22 <edwardk> no, but it can use some very high order rewrite rules ;)
11:45:24 <zygoloid> monochrom: i've used groupBy f in a code golfing contest with a naughty f. saved me something like 10 characters :)
11:45:34 <edwardk> plus stream fusion isn't always a win, it might lose you sharing as well
11:45:40 <EvanCarroll> I'm hoping Haskell: The Craft of Functional Programming (2nd Edition) [Paperback]
11:45:42 <dafis> davekong: it doesn't hang, it just takes a loong time
11:45:43 <mauke> davekong: there is no -O3
11:45:48 <EvanCarroll> is better than RWH for teaching the language
11:45:58 <davekong> well O then
11:46:05 <jmcarthur> edwardk: it *will* lose sharing unless you have an explicit 'force' operation
11:46:09 <mauke> -O2 is your lord and savior
11:46:27 <edwardk> jmcarthur: well, might in the sense that the rules don't always fire ;)
11:46:37 <electriceloquenc> EvanCarroll: based on reviews/heresay or are you guessing?
11:46:40 <davekong> alright thanks guys, just seemed odd to me, it was like as soon as my cpu started howling it would not finish
11:46:41 <jmcarthur> the rules are what causes you to lose sharing
11:46:49 <zygoloid> mauke: in versions of GHC newer than the bible, -On (with n > 2) is treated as -O2
11:46:56 <jmcarthur> when the rules don't fire you might actually retain sharing
11:47:05 <jmcarthur> oh iswym
11:47:07 <mauke> zygoloid: so -O3 still doesn't exist
11:47:34 <edwardk> i'm trying to avoid the construction of said rules. i suppose the same machinery would work for vector-like operations as well, or gpgpu calculations, etc. just build the expression tree and then evaluate it like we do in imperative models like linq
11:47:37 <zygoloid> mauke: -O3 is a synonym for -O2 in the same way that -O2 is a synonym for -f<bunch of stuff>
11:47:45 <jmcarthur> edwardk: what you propose is the only way i can see to do it without making a less pure API or making things very slow
11:47:58 <zygoloid> mauke: but i agree, its behaviour is undocumented
11:48:09 <EvanCarroll> electriceloquenc: no, I'm hoping
11:48:30 <EvanCarroll> electriceloquenc: I really dislike RWH, I'm just hoping that this other book is better.
11:48:31 <zygoloid> mauke: but for what it's worth, -O1 isn't explicitly documented either
11:48:37 <edwardk> with a fall back on the use of a pure model for when you absolutely need to get an answer out, where the fact that that answer has been computed can be observed.
11:48:38 <electriceloquenc> EvanCarroll: what are you hoping to get out of it? What did you dislike about RWH?
11:48:39 <edwardk> holy crap.
11:48:42 <edwardk> i just realized
11:48:44 <edwardk> i already have that
11:48:52 <edwardk> unsafeIsEvaluated! =)
11:48:57 <edwardk> i don't need the mvar, etc.
11:49:29 <davekong> EvanCarroll: I am enjoying "Yet Another Haskell Tutourial" a lot; I also didn't like RWH much, though I guess it may cover more
11:49:45 <jmcarthur> is unsafeIsEvaluated reliable?
11:49:50 <dafis> EvanCarroll, I found Thompson's book quite good.
11:49:59 <zygoloid> edwardk: careful. GC can rewrite pointers as indirections, and unsafeIsEvaluated will always say indirections are not evaluated.
11:50:26 <edwardk> data Vector a = Vector (Expr ...) (RealVector a) -- then during the pure pass just work with RealVector., and then during the follow up pass check if that IsEvaluated
11:50:35 <edwardk> zygoloid: sure.
11:51:01 <edwardk> zygoloid: the answer will be correct regardless it just might lose some sharing info with the stuff that you ran prematurely 
11:51:11 <EvanCarroll> electriceloquenc: I really disliked everything about RWH. I found it to be pretty poor all the way around. -- but that's me. I'm sure the author is smarter than me, but the book is an unorganized mess without sane curriculum
11:51:20 <edwardk> zygoloid: and actually i'm not sure i agree
11:51:33 <edwardk> zygoloid: during forwarding the pointer i have to your value retains its tag.
11:51:45 <zygoloid> edwardk: indirections are always untagged.
11:51:47 <geheimdienst> > uncurry ((++) . (++ "oh")) $ splitAt 1 "mauke"
11:51:48 <lambdabot>   "mohauke"
11:51:56 <zygoloid> the pointer within the indirection is, however, tagged.
11:51:58 <electriceloquenc> EvanCarroll: what side are you interested in? learning the math aspect, practical web programming, ...?
11:52:05 * geheimdienst succeeds gloriously with his silly (++).(++) contraption
11:52:11 <edwardk> zygoloid: pointers to the indirection remains tagged. you don't go round them all up and remove the tags ;)
11:52:12 <EvanCarroll> electriceloquenc: Have you ever read Begining Perl?
11:52:19 <EvanCarroll> electriceloquenc: I'm looking for a direct analog to Haskell
11:52:39 <edwardk> zygoloid: the one inside of it gets tagged as well, and then the tags from that get propagated outwards to anyone who wasn't tagged before during gc
11:52:39 <zygoloid> edwardk: indirections are never tagged. ever. only function and constructor thunks are tagged.
11:52:39 <sproingie> not a thing like it
11:52:42 <edwardk> gc improves my tagging
11:53:06 <EvanCarroll> I think LYAH is about half way to filling the Begining Perl need, now I'm looking for something more towards Programming Haskell.
11:53:08 <edwardk> erm, the tag is in the pointer to the closure, not in the closure
11:53:25 <zygoloid> edwardk: yes. but the tag is not in the pointer to the indirection.
11:53:25 <electriceloquenc> EvanCarroll: ah, yeah, Thompson is much closer to that
11:53:49 <davekong> dafis: You are talking about "Where do I begin?"?
11:53:49 <sproingie> i thought RWH had some really great parts, but it was really uneven
11:54:05 <edwardk> i point to your cons cell, gc comes along and moves you, replacing you with an indirection by overwriting the infotable pointer and writing a forwarding pointer into you. my pointer to you remains tagged.
11:54:15 <edwardk> the pointer i have to you is what i use in IsEvaluated
11:54:19 <dafis> davekong: sorry?
11:54:31 <davekong> dafis: Thompson's book?
11:54:47 <edwardk> i agree that with profiling and some things it can go away, but i don't see the normal process of GC removing my dynamic pointer tag bits
11:54:48 <zygoloid> edwardk: that's what happens if your pointer gets updated. if your pointer doesn't get updated, it's left pointing at an indirection.
11:55:04 <zygoloid> and it's left without tag bits in that case.
11:55:18 <edwardk> yes, but while it is pointing at an indirection i still have the bits in lsbs of it
11:55:27 <EvanCarroll> RWH for me was like a very poor Haskell Cookbook, with Advanced Haskell, with drawn out tiresome examples, receipes of things I didn't care about or couldn't relate to (Adler) or ultimately understand, a half baked introduction to the langauge that assumed begining knowledge, poor challanges that I couldn't do without undue research using wikipedia
11:55:29 <dafis> dacekong: Ah, yes. It's good to learn the basics of the language, but it doesn't lead too far.
11:55:44 <zygoloid> edwardk: if a pointer points to an indirection. its bottom bits are zero.
11:55:47 <dafis> da*v*ekong
11:55:59 <davekong> 14:49:26            dafis | EvanCarroll, I found Thompson's book quite good. 
11:56:02 <edwardk> zygoloid: that really breaks my mental model of things. can you show me where this happens? =)
11:56:21 <edwardk> because how does it know how to find all the references to it to rewrite them
11:56:32 <EvanCarroll> cool, well its on the way, I look forward to it. =)
11:57:01 <zygoloid> edwardk: suppose there are two pointers to expression 'expr'. one of those pointers gets entered, expr is evaluated, and the heap area is rewritten as an indirection.
11:57:15 <zygoloid> edwardk: your 'is it forced?' test on the other pointer will say 'no'.
11:57:17 <edwardk> i mean the usual model is you set up the forwarding pointer, change the tag, then go on your way, by the time you're done copying the semispace you know you've changed over all the pointers to point to the new target
11:57:27 <edwardk> zygoloid: sure
11:57:39 <zygoloid> my GC comment was backwards, sorry about that.
11:57:44 <Cale> EvanCarroll: that reminds me that edwardk and I should work on our book :)
11:57:47 <zygoloid> GC will fix that up and remove the indirection, of course ;)
11:58:04 <zygoloid> if that's what you were disagreeing about then i agree with your disagreeing
11:58:07 <djahandarie> Cale, you and edwardk are writing an introduction book to Haskell? Oh dear
11:58:45 <edwardk> zygoloid: =) my main point was that every time gc comes along you get better tags. my parsing of your statement was that i could get a false negative after having received a correct positive
11:58:47 <Cale> djahandarie: Don't worry, I've successfully taught concepts from Haskell to 11 year old kids ;)
11:58:47 <jmcarthur> edwardk: if you don't mind an explicit 'force' function to introduce sharing you could just do something like this, couldn't you?:  data BlasArray = Exp <exp with internal mutation> <immutable inputs> | Pure <blah blah> ; force (Exp ...) = Pure . unsafePerformIO $ ...
11:58:53 <edwardk> from the same reference
11:59:01 <edwardk> jmcarthur: an explicit force is too much
11:59:17 <Cale> However, I don't think that will be our target audience. :)
11:59:19 <zygoloid> edwardk: ok, then i'm sorry for having adamantly expressed untruths :)
11:59:54 <geheimdienst> i think it needs a special kind of 11-year-old to sit through an explanation of concepts from haskell
11:59:57 <djahandarie> Cale, heh alright. Who will the book be targeting? Practicing mathematicians?
11:59:59 <edwardk> zygoloid: no worries, i was just worried that there was something fundamental about the storage manager that i drastically misunderstood ;)
12:00:01 <jmcarthur> edwardk: i'm not a fan of force functions either. just putting the obvious out there
12:00:07 <geheimdienst> (special in the sense of neckbearded)
12:00:22 <Cale> djahandarie: Well, they should be included, but nothing that fine. :)
12:00:31 <djahandarie> I see
12:00:45 <edwardk> jmcarthur: well, the above model is actually quite elegant. you get two evaluation modes, a pure one which is boring, and then an imperative pass that comes back through using IsEvaluated and observable sharing
12:00:51 <Cale> djahandarie: It should be a presentation that a mathematician would be happy with, and yet it should be comprehensible with no special knowledge, I think.
12:00:52 <jmcarthur> yeah
12:01:02 <edwardk> the IsEvaluated lets the imperative pass recycle all the pure values that were generated
12:01:07 <zygoloid> edwardk: in any case, as you say, both of your uses of it are safe in the case of a false negative, so it doesn't matter :)
12:01:38 <jmcarthur> well, so would the force, but force is uglier
12:01:51 <edwardk> zygoloid: well, even in the event of the forwarding pointer not yet being seen by the other reference, i can cheat. i can just make a call to performMinorGC in before i kickstart the imperative pass ;)
12:02:14 <edwardk> jmcarthur: well, this has no overhead for the pure code except for carrying around the tree that led to the term inside the term.
12:02:24 <zygoloid> edwardk: unless it's an IND_OLDGEN in which case you'll need a full GC ;)
12:02:29 <jmcarthur> yeah
12:02:47 <edwardk> zygoloid: i can ffi out to the full performGC ;)
12:03:09 <zygoloid> edwardk: you could use some vacuum-like technology to read the info table and skip indirections. there might even be a GHC primop for that.
12:03:10 <edwardk> zygoloid: but the odds of it getting old, then randomly being forced are pretty low
12:03:49 <EvanCarroll> Cale: good luck man, if it is a begining book I'd suggest using Begining Perl as a template, and LYAH as a good example.
12:03:59 <edwardk> my worst case scenario is i ever compute everything twice
12:04:09 <EvanCarroll> I'm still soundly convinced that Begining Perl is the absolutely best introduction to any language ever.
12:04:10 <edwardk> once purely and once imperatively
12:04:22 <edwardk> so i'm okay from a pure constant perspective. an approximate solution is enough
12:05:26 <zygoloid> doesn't look like there's anything in GHC.Prim for it, sadly
12:05:33 <edwardk> and i only need compute the pure component insofar as it is actually used. and if i miss one forced component, i may pick it up on the rebound just one or two calculations farther back
12:06:07 <edwardk> zygoloid: yeah it can't really, when it comes down to it the best you could do is unpackClosure, but that doesn't work well at all with unforced thunks
12:07:17 <edwardk> i actually rather like this. =)
12:07:28 <edwardk> so much cleaner than my previous version
12:07:55 <edwardk> i can use it for other idempotent-ish computations as well.
12:09:25 <edwardk> data RNFOnce a = RNFOnce a Ready; instance NFData RNFOnce where rnf (RNFOnce x y) | !evaluated y = rnf x `then` rnf y | otherwise = doNothing ...
12:09:50 <edwardk> gives you a wrapper that will (most of the time) only bother deepSeq'ing once,.
12:10:08 <edwardk> but without any explicit rendezvous
12:10:54 <edwardk> i think i need to factor unsafeIsEvaluated into a separate package or broaden the scope of 'speculation' ;)
12:12:42 <zygoloid> edwardk: i'm planning on releasing a library (eventually) for pulling values apart (kinda a vacuum-on-steriods)
12:12:59 <edwardk> zygoloid: glad to see someone picking up the torch =)
12:13:09 <zygoloid> (just as random fallout from my implementing-a-haskell-debugger project)
12:13:17 <edwardk> *nods*
12:13:46 <zygoloid> would be nice if the GHC memory layout were in any way stable ;)
12:13:48 <djahandarie> Pulling values apart? Doesn't Vacuum just visualize your data?
12:14:13 <aristid> haskell is a toy language with a production-quality compiler!
12:14:25 <jcreigh> haha
12:14:30 <edwardk> i know what little i do know about ghc's bowels from reimplementing the stg for my own project and from working with mmorrow for a while to see about hacking in one of my tracing jits into ghc's bytecode interpreter. the monolithic nature of the surrounding code and its deep reliance on the compiled version for most of its primitives largely nixed that though
12:15:28 <zygoloid> i've definitely got to the point where i'm realising more and more that i know nothing about how it works ;)
12:16:03 <pchiusano> question - what would you call a functor-like thing, but where fmap is not polymorphic in the return type
12:16:18 <pchiusano> think of something that would be suitable for a monotypic container
12:16:34 <geheimdienst> unisex functor
12:16:37 <pchiusano> like bitset
12:16:44 <pchiusano> or bytestring
12:16:49 <Ke> some nice graphical debugget with, trace, ability to do IO operations within program context and interpreter in some nice GUI would be nice
12:17:02 <pchiusano> geheimdienst: is that a real term or did you just make that up? :)
12:17:05 <Ke> -graphical
12:17:11 <edwardk> pchiusano: a restricted functor
12:17:38 <zygoloid> pchiusano: or a record field: data Foo = Foo { bar :: String, ... }; withFoo f foo = foo { bar = f (bar foo) }
12:17:40 * geheimdienst is amazed there's still people in here who take seriously all the nonsense flowing out of his brain
12:17:53 <zygoloid> pchiusano: (withFoo here is a restricted fmap)
12:17:53 <edwardk> pchiusano: http://hackage.haskell.org/package/rmonad
12:18:17 <edwardk> they could very well have built RFunctor with the same machinery
12:18:39 <z28> test
12:18:41 <pchiusano> edwardk: cool
12:18:54 <edwardk> (in fact i had thought they had) =)
12:19:08 <edwardk> anyways it gives you a name with an oleg pedigree that should be enough for anyone. ;)
12:19:27 <pchiusano> zygoloid: is what you are talking about the same thing?
12:19:44 <zygoloid> pchiusano: sure. withFoo :: (String -> String) -> Foo -> Foo
12:19:46 <djahandarie> edwardk, there is an RFunctor in that package
12:19:56 <edwardk> djahandarie: i must have overlooked it
12:20:08 <edwardk> ah i did
12:20:24 <pchiusano> zygoloid: no, that is not quite the same - in the class I am thinking of, you'd give it a Char -> Char
12:20:33 <z28> @help
12:20:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:20:39 <ziman> i'd say you'll need a fundep to determine the type of the transformation function (that is to be fmapped), too
12:20:42 <geheimdienst> zygoloid, that means withFoo applies a function to all the values in a record, right? that would be analogous to Data.Map.map
12:20:52 <zygoloid> pchiusano: why Char -> Char? I choose to think of Foo as a functor over String.
12:20:56 <z28> @run data Foobar = Foobar Int
12:20:57 <lambdabot>   <no location info>: parse error on input `data'
12:21:05 <pchiusano> zygoloid: ohh okay i see
12:21:15 <edwardk> in haskell the model is you define a typeclass "Suitable f a" which says that a is a suitable arg to f. then you defined class Suitable f a => RFunctor f a where fmap :: (Suitable a, Suitable b) => (a -> b) -> f a -> f b
12:21:25 <zygoloid> pchiusano: imagine i had: data GenFoo a = Foo { bar :: a, ... }; type Foo = GenFoo String. then withFoo is exactly GenFoo's fmap.
12:21:33 <zygoloid> (modulo the restricted type)
12:22:00 <pchiusano> zygoloid: gotcha... but i think i like 'restricted functor' better :)
12:22:06 <ziman> edwardk, (Suitable a, Suitable b)  <-- does Suitable not take two arguments?
12:22:22 <zygoloid> pchiusano: sure. i wasn't trying to suggest a name, just pointing out that these things come up a /lot/ :)
12:22:23 <edwardk> ziman: sorry Suitable f a, Suitable f b)
12:22:26 <ziman> (or am i nitpicking on the unimportant?)
12:22:38 <geheimdienst> > data Foo = Foo { bar :: String }
12:22:39 <lambdabot>   <no location info>: parse error on input `data'
12:22:53 <geheimdienst> bah
12:23:02 <edwardk> ziman:er and class RFunctor f where -- doesn't take the Suitable constraint
12:23:24 <pchiusano> zygoloid: yes, I was wondering if there was any typeclass corresponding to that concept, I'll have to look at RFunctor and RMonad
12:23:29 <ziman> edwardk, i see
12:23:41 <edwardk> ziman: if you need it to be completely monomorphic, i.e. you take only Chars' you can get there by using an isomorphism typeclass as the basis for your Suitable
12:23:48 <ziman> edwardk, is there a reason to use Suitable for both a and b, opposed to (SuitableIn f a, SuitableOut f b) ?
12:24:59 <edwardk> class Iso a b where iso :: a -> b; instance Iso a a; instance (Iso Char a, Iso a Char) => Suitable ByteString a, and you can play games with iso to ensure that you always pass out what the bytestring map function expects
12:25:19 <edwardk> (though i prefer the type system-breaking: iso :: f a -> f b)
12:25:29 <edwardk> ziman: simplicity? =)
12:25:48 <ziman> ah, i see, using iso you can cover all suitable types in a simple way
12:27:28 <Jefskell> Is there an O(1) way to concatenate two long lists? 
12:27:43 <mauke> not if they're lists
12:27:50 <edwardk> Jefskell: yes, but you lose fast indexing into the type
12:28:09 <edwardk> Jefskell: google bootsrapped catenable deques
12:28:16 <edwardk> er bootstrapped
12:28:46 <edwardk> Jefskell: they appear near the end of okasaki's thesis and book
12:29:40 <edwardk> @google purely functional data structures chris okasaki thesis
12:29:42 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.3080&rep=rep1&type=pdf
12:29:42 <lambdabot> Title: cache:http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.3080&rep=rep1& ...
12:30:14 <triyo> Hi all, how do I fix this? Couldn't match expected type `Char' ... against inferred type `Either Integer Double' http://gist.github.com/456245 . I think I understand the problem, I am just not to sure how to fix it.
12:30:17 <djahandarie> Has that not been written into a hackage package yet?
12:30:17 <Jefskell> Maybe I could just use sets instead, since I don't need to preserve order. Can you union sets in O(1) time?
12:30:35 <edwardk> djahandarie: "Edison" ;)
12:30:51 <edwardk> djahandarie: i have an implementation around somewhere as well
12:30:57 <triyo> tuples supports diff types right?
12:31:02 <edwardk> but i haven't been willing to go down the edison path. ;)
12:31:43 <djahandarie> Ah
12:32:53 <edwardk> jmcarthur: damnit now i want to go implement that cheesy hack into a nice blas lib ;)
12:33:39 <edwardk> i'm also trying to see if i could use it to do something smarter with 'ad'
12:34:49 <dafis> triyo: what's the intended type and which parser lib are you using?
12:36:07 <triyo> dafis: Using parsec as lib. intended type is a tuple pair of (Maybe Char, Maybe (Either Integer Double))
12:36:21 <triyo> last part id the problem of course
12:36:32 <triyo> *is the problem
12:37:07 <mreh> "Expected kind `?'" ?!%@!
12:37:23 <BMeph> triyo: Not being unfriendly, just obnoxious. Have you considered that...you may be doing it incorrectly? ;)
12:38:03 <edwardk> mreh: what about it: when in doubt just read it as *. it just means it allows some unboxed stuff
12:38:08 <triyo> BMeph: most probably hence looking for a sobering :)
12:38:22 <edwardk> :k (->)
12:38:23 <lambdabot> ?? -> ? -> *
12:38:24 <mreh> ok
12:38:29 <dafis> triyo: dunno whther it changed, but option :: a -> GenParser tok st a -> GenParser tok st a
12:38:47 <edwardk> functions can take unboxed arguments, and return unboxed arguments and unboxed tuples
12:38:57 <dafis> so you have the wrong type (at least for some versions of parsec)
12:38:59 <pastorn> mreh: http://stackoverflow.com/questions/3034264/haskell-weird-kinds
12:40:11 <triyo> dafis: hmm, you are abs right, it hasn't changed, its still option :: a -> GenParser tok st a -> GenParser tok st a
12:40:13 <edwardk> i never did check if you can define any sort of user type with those kinds ;)
12:40:48 <dafis> triyo: optionMaybe
12:42:04 <edwardk> like throw :: forall (e :: *). forall  (a :: ?). Exception e => e -> a
12:42:16 <triyo> dafis: ah that combinator looks more like it, thanks
12:43:16 <Jefskell> edwardk: How can I concatenate lists in O(1) time? I don't think I need "fast indexing into type", though I'm not entirely sure what that is.
12:43:29 <BMeph> So what's the "comma" function do?
12:43:30 <edwardk> Jefskell: you need to use a different container than a list.
12:44:03 <dafis> BMeph: munch a comma
12:44:12 <Jafet> Jefskell, (++)?
12:44:27 * BMeph waits for it...
12:45:09 <pastorn> > (,) "beat" "diz"
12:45:11 <lambdabot>   ("beat","diz")
12:45:18 <triyo> dafis: silly me, instead of option, I was actually looking to use ... optional :: (Alternative f) => f a -> f (Maybe a)
12:45:37 <triyo> for my applicative parser
12:45:50 <dafis> triyo: careful, there's also optional in parsec
12:45:54 <djahandarie> Jafet, that's definitely not O(1) for a linked list
12:45:57 <triyo> hiding :)
12:46:13 <edwardk> Jefskell: http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1.3/doc/html/Data-Edison-Seq-JoinList.html for example
12:46:21 <triyo> hiding parsec's ver that is
12:46:26 <dafis> triyo: 'kay, just warning you before 'ambiguous reference...'
12:46:32 <Jafet> djahandarie, it... is
12:46:49 <Jefskell> Jafet: (++) seems to take O(n) time to concatenate lists, unless I'm doing something wrong. I don't really see why it should take so long...maybe the list data structure doesn't store a pointer to the tail.
12:46:51 <djahandarie> Jafet, no. You need to traverse the entire first list in order to get the tail and append the second list
12:47:04 <Jafet> > ([0..1000000] ++ [0..1000000]) `seq` ()
12:47:06 <lambdabot>   ()
12:47:19 <mauke> Jefskell: if it stored a pointer to the tail, what would it do with it?
12:47:50 <Jafet> (In fact, that code only ever creates one cons.)
12:49:26 <Veinor> Jefskell: the list data structure doesn't store a pointer to the tail, no
12:49:50 <Veinor> also, I really wish that (++) and (!!) were typeclass methods sometimes
12:49:53 <triyo> dafis: sorry, got disconnected. Did you get my last comment?  "hiding parsec's ver that is"
12:50:19 <triyo> btw, it works perfectly now.
12:50:53 <dafis> triyo: yes, got it. I just wanted to warn you before the 'ambiguous reference to ...' compiler message. Nice that it works.
12:51:13 <triyo> thanks for the heads up
12:51:14 <Jafet> class WeirdListsLikeNonemptyOnesButWhichOtherwiseShouldBeDropinReplacementsForTheNormalList where
12:51:26 <Veinor> Jafet: ?
12:51:27 <Jefskell> mauke: I see your point...storing a tail pointer wouldn't speed up the concatenate operation; in haskell the last element cannot be mutated to point to the other list
12:51:43 <triyo> Dam, that looks like Jav naming convection. 
12:51:46 <triyo> *Java
12:51:51 <mauke> Jefskell: exactly
12:52:03 <triyo> *Convention 
12:52:28 <arcatan> in Haskell that would be class Wrd where
12:53:09 <Veinor> class Listlike l where (++) :: l a -> l a -> l a, (!!) :: (l a) -> Int -> a
12:53:11 <Veinor> or something
12:53:46 <djahandarie> MonadPlus?
12:53:58 <Jafet> There is mconcat and index
12:54:36 <dafis> alexyk: have you already done some investigation re disintern?
12:55:03 <alexyk> dafis: not yet, have to do grant proposals...
12:55:14 * BMeph finds using an Int for a list index instead of at least 'Word', was a premature optimization...
12:55:15 <dafis> alexyk: good luck
12:55:24 <alexyk> dafis: but I planend to do a separate disinterning program like you suggested
12:55:37 <alexyk> dafis: I've also added the dictionary to github
12:55:57 <Jefskell> mauke: So when you concatenate two lists, the whole first list needs to be copied, just so that the last element of the first list will point to the second list?
12:55:58 * BMeph would much more prefer a Natural instead, but...it would break too many (bitrotted) programs...
12:56:05 <Veinor> yeah, but my point is I want to use !! and ++ :P
12:56:07 <mauke> Jefskell: yes
12:56:12 <dafis> alexyk: yes, I think I'll manage to start looking this night
12:56:28 <Jafet> Veinor, then define them in terms of mconcat and index
12:56:36 <Jafet> :t (.)
12:56:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:56:53 <Veinor> index?
12:57:13 <Jafet> Maybe it's not called index
12:57:45 <BMeph> 'elementAt', perhaps? ;)
12:57:56 <dafis> Veinor, Jafet: genericIndex?
12:58:22 <BMeph> 'thatOne!' :)
12:58:25 <alexyk> so here's a general question: I have Float results, but they all come from fractions of integers.  I have constants as integers, 0,1, and a couple of multiplications: from Integral (x * y) * a.  It al lends up with some juicy Floats.  OCaml has explicit *. and 1. throughout.  Do I lose any precision with Integral => fromIntegral or not, as I hope?
12:59:01 <BMeph> alexyk: Do you need them to be Floats, or is that...a premature optimization? ;)
12:59:24 <alexyk> I have divisions too I write as / ... it's doing Rational.  BMeph: in fact I have types which are Float; should I keep them as Rational? 
12:59:27 <dafis> alexyk: when the integers exceed the Float precision (23 bits or so), you lose a little precision
12:59:47 <alexyk> dafis: this explains difference with OCaml slightly.
12:59:49 <dafis> but you lose the same precision writing literals in the source file
12:59:57 <mauke> alexyk: why the heck are you using Floats?
13:00:06 <alexyk> mauke: what should I use?
13:00:10 <mauke> Double
13:00:15 <mauke> like ocaml
13:00:21 <BMeph> alexyk: I'd hope that at least you used Double, vice Float.
13:00:25 <Jafet> Floating-point can only represent precision-limited approximations to dyadic rationals, in any case
13:00:40 <dafis> mauke: he uses > 60GB of RAM, Double may be a problem
13:00:57 <mauke> hah, fun
13:01:04 <alexyk> yeah.  I was wondering since Haskell is doing all the right things, and I might perhaps just replace Float in the type by Double
13:01:06 <dafis> mauke: indeed
13:01:10 <BMeph> For that matter, why don't we have a 'Quad' type, especially since so many entry-level processors are available as 64-bit? :\
13:01:16 <alexyk> but Float is OK
13:01:22 <alexyk> for my RAM purposes
13:01:27 <Jafet> You could ask Marlow if he's got spare cycles on the EC2
13:01:40 <alexyk> Marlow sold the EC2 back to Bezos
13:02:12 <Jafet> Falling back to dons
13:02:13 <BMeph> alexyk: Go ahead; I'm sure Jeff won't mind... ;)
13:02:16 <alexyk> at interest with Haskell on it
13:02:33 <Ke> BMeph: Double is 64-bit already, and mostly it's all about integer sizes
13:03:18 <dafis> Ke: a native 128-nit intger type would be nice
13:03:25 <dafis> s/nit/bit/
13:03:44 * dafis growls at his fat-fingers
13:03:57 <BMeph> Ke: Eh, don't mind me, I'm just grumpy that there isn't a(n official) MinGW toolchain for 64-bit processors.
13:04:01 <Ke> gmp is as fast as is relevant for cpu
13:04:19 <BMeph> dafis: I'd just skip to the 256-bit ones anyway... :)
13:04:43 <dafis> BMeph: I'd be with you
13:05:23 <Ke> hmm does sse include 128 bit datatypes
13:05:39 <Ke> larger no, because the registers are 128-bit
13:06:33 <Ke> iirc larrabee has 512-bit registers
13:06:47 <zygoloid> @hoogle Dec -> Q String
13:06:48 <lambdabot> Prelude show :: Show a => a -> String
13:06:48 <lambdabot> Text.Show show :: Show a => a -> String
13:06:48 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
13:07:06 <BMeph> Whoa: "I still remember a student's bitter complaint about being required to find the base 2 logarithm of 32 in an examination where calculators were forbidden..." that's...pitiful and hideous. And very, very sad. :(
13:07:07 <Jafet> larrabee is dead in the vapour
13:07:59 <sproingie> i haz a sad
13:08:05 <soupdragon> wats haskell
13:08:23 <BMeph> dafis: I think there's a crypto module that needed them (Int/Word256)...
13:08:27 <sproingie> beaver's rambunctious neighbor
13:08:32 <jcreigh> Ke: AFAIK, SSE only provides 32-bit and 64-bit floating point operations
13:08:53 <Jafet> Don't forget the peculiar 80-bit width
13:08:57 <sproingie> also the official language of narwhals
13:09:05 <edwardk> sproingie: sadly, i have a coworker who insists on calling me eddie haskell ;)
13:09:05 <dafis> BMeph: Yes, but so far it's not a native type :(
13:09:10 <Jafet> And intel's modern habit of overcompensating for pentium fdiv.
13:09:28 <sproingie> edwardk: do you call him beav?
13:09:42 <edwardk> sproingie: i think i may start ;)
13:10:08 <Jafet> Badger badger
13:10:17 <edwardk> or wally
13:10:26 <sproingie> mushroom mushroom!
13:10:44 <pkrumins> cut it off, i now have this song in my head.
13:10:52 <BMeph> edwardk: Definitely, "Wally"! >;)
13:10:54 <geheimdienst> #haskell gets quite surreal at some times of night
13:10:56 <pkrumins> snake oooo snaaaake
13:11:13 <mreh> @instances MonadFix
13:11:14 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:11:17 * BMeph calls up sproingie...on a banana phone!
13:11:19 <jcreigh> Jafet: 80-bit width FP operations is provided by the x87 FPU instructions, not by SSE instructions.
13:11:24 <edwardk> BMeph: nah, that way lies getting called "Eeeeva" which would be just weird
13:11:32 <mreh> where can I locate these instances?
13:11:48 <edwardk> Control.Monad.Instances?
13:11:48 <jcreigh> There are, in fact, three independent sets of floating point instructions on moden x86 CPUs. (x87, MMX, and SSE)
13:12:00 <Jafet> Oh, ok
13:12:03 <aristid> @instances Applicative
13:12:03 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:12:11 <aristid> lambdabot: wtf
13:12:14 <geheimdienst> mreh, hoogle for them?
13:12:35 <mreh> hoogle can do that?
13:12:57 <Jafet> @hoogle (Applicative a) => a
13:12:57 <lambdabot> Prelude undefined :: a
13:12:58 <lambdabot> Test.QuickCheck.Batch bottom :: a
13:12:58 <lambdabot> Data.Function fix :: (a -> a) -> a
13:13:07 <dafis> mreh: Control.Monad.Fix
13:13:14 <Jafet> If it can, that's not one way to do it
13:13:36 <geheimdienst> mreh, i meant looking for Either, Maybe, ErrorT and so on
13:13:42 <mreh> dafis: looked, i was hoping for StateT
13:13:49 <geheimdienst> @hoogle ((->) r)
13:13:49 <lambdabot> Prelude undefined :: a
13:13:49 <lambdabot> Test.QuickCheck.Batch bottom :: a
13:13:49 <lambdabot> Data.Function fix :: (a -> a) -> a
13:13:59 <mreh> oh, okay :)
13:14:31 <geheimdienst> but you're right, not much luck with weird stuff like ((->) r)
13:15:03 <dafis> mreh: For the instance of StateT, Control.Monad.State would be a natural place to look
13:15:17 <mreh> dafis: yup! found it
13:15:42 <mreh> I suppose because we have no way of naming an instance, we have no way of finding it without inspection
13:16:16 <mreh> why cant Hoogle index these?
13:16:19 <mreh> I bet it can
13:17:14 <dv-> Someone ought to make a Haiku port of ghc
13:18:57 <zygoloid> damn it! C compilation time was one of the reasons i moved to haskell. and now it's /still/ my testing bottleneck
13:20:07 <aristid> zygoloid: you moved to haskell due to ... C compilation time?
13:20:07 <Ke> that was just enexpected
13:20:11 <BMeph> zygoloid: Maybe try Clean. <ducks>
13:20:26 <pizza_> zygoloid: buy faster hardware :(
13:20:29 <zygoloid> aristid: ok, more c++ compilation time...
13:20:46 <zygoloid> one of /many/ reasons ;)
13:20:47 <aristid> zygoloid: oh, C compilation time CAN be pretty bad
13:21:13 <zygoloid> especially with Language.C it seems :)
13:21:15 <Jafet> No rule to make target "your time".  Stop.
13:21:20 <aristid> if you're using a cygwin-based cross-compiler with all files (and temporary files) being stored on a crappy Windows Fileserver.
13:21:47 <aristid> (that's a real situation, not made up)
13:22:11 <zygoloid> > take off "every zig"
13:22:13 <lambdabot>   "every"
13:22:25 <geheimdienst> @src off
13:22:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:22:34 <geheimdienst> > off
13:22:35 <lambdabot>   5
13:22:47 <geheimdienst> where does that come from?
13:23:06 <zygoloid> a mystery!
13:23:30 <geheimdienst> > take on "me"
13:23:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:23:31 <lambdabot>         against inferred type ...
13:23:54 <geheimdienst> lambdabot, i expected you to sing instead
13:24:15 <aristid> > on
13:24:16 <lambdabot>   Overlapping instances for GHC.Show.Show
13:24:16 <lambdabot>                              ((b ->...
13:24:25 <aristid> ah, lol
13:24:39 <aristid> :t take
13:24:40 <lambdabot> forall a. Int -> [a] -> [a]
13:24:42 <geheimdienst> (on is defined somewhere near "comparing" and "sortBy" iirc...)
13:24:52 <mux> in Data.Function
13:24:53 <aristid> geheimdienst: Data.Function
13:25:06 <Phyx-> :t off
13:25:07 <lambdabot> forall t. (Num t) => t
13:25:11 <Phyx-> off
13:25:12 <geheimdienst> @undef
13:25:13 <Phyx-> > off
13:25:14 <lambdabot>   Not in scope: `off'
13:25:17 <Phyx-> aww
13:25:22 <djahandarie> Hm, what would be a good data structure for "auto-completion"? Like when you type in "hel" and it gives you a couple options like "hell" and "hello", etc
13:25:23 <geheimdienst> oh, someone defined it previously
13:25:35 <geheimdienst> and i thought it was special, like cake
13:25:40 <mux> djahandarie: a patricia trie is perfect for that, I think
13:25:42 <Phyx-> :t cake
13:25:43 <lambdabot> [[Char]]
13:25:45 <mux> it remembers every prefix
13:25:47 <Phyx-> the cake is a lie!
13:25:52 <mux> in a tree
13:25:52 <geheimdienst> > cake
13:25:53 <medfly> lambdabot guessed stuff
13:25:53 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:25:54 <medfly> @wh
13:25:55 <lambdabot> Maybe you meant: what where where+ wn
13:26:08 <mux> djahandarie: look at the bytestring-trie package
13:26:41 <djahandarie> mux, okay, cool, thanks
13:26:48 <geheimdienst> djahandarie, are you sure you need a fancy data structure? i thought the ground rule is Do The Simplest Thing That Could Possibly Work™, then optimize when you notice the simplest thing is too slow
13:26:53 <mux> djahandarie: yw
13:27:00 <zygoloid> do we still have that intToBreakfast thing in lambdabot?
13:27:05 <Jefskell> I'm trying to compile a program with ghc, but I'm getting the error "/usr/bin/ld: cannot find -ledison". I installed edison from an Ubuntu package, and edison seems to appear in "/usr/lib/ghc-6.12.1/haddock/", but linking to this directory doesn't change the error message. What am I doing wrong? Thanks.
13:27:08 <geheimdienst> (simplest thing is usually arrays and linear search)
13:27:32 <Jafet> > integerToBreakfast 15
13:27:33 <lambdabot>   Not in scope: `integerToBreakfast'
13:27:39 <geheimdienst> > intToBreakfast
13:27:40 <lambdabot>   Not in scope: `intToBreakfast'
13:28:22 * hackagebot MaybeT-transformers 0.2 - MaybeT monad transformer using transformers instead of mtl.  http://hackage.haskell.org/package/MaybeT-transformers-0.2 (SebastiaanVisser)
13:28:31 <aristid> @let integerToBreakfast = error "You're too fat already."
13:28:32 <lambdabot>  Defined.
13:28:51 <dafis> alexyk: how do I get the mapfold branch without downloading every file by itself?
13:30:29 * mux realizes that reddit has a great Server http field :-)
13:30:46 <mux> Server: '; DROP TABLE servertypes; --
13:32:31 <chrisdone> error: unexpected end of expression, query aborted
13:34:42 <geheimdienst> (also, slashdot still sends futurama quotes in the headers. http://web-sniffer.net/?url=http://slashdot.org )
13:36:24 <mreh> I'd really like an instance of MonadFix for Rand, can I derive it by declaring a newtype wrapper?
13:38:21 <BMeph> Jefskell: Unless you REALLY need apt (or whatever Ubu uses) to control everything in your system, I'd imagine "cabal install EdisonCore" would give better results. :)
13:40:00 <Veinor> "patricia tree"
13:40:04 <Veinor> I love the naems CS has for things
13:40:18 <sproingie> there any ops here who can relieve #haskell-blah of a troll?
13:40:32 <zygoloid> @where ops
13:40:32 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
13:40:54 <Jafet> Woah, that's like a blackwater
13:40:55 <sproingie> ah already got one there
13:40:59 <allbery_b> I don't have bits in #haskell-blah
13:41:11 <allbery_b> (nor do I particularly want them)
13:41:19 <mreh> troll is a bit extreme, misguided maybe
13:41:43 <dcoutts_> hmm, I don't think we've got any op stuff set up there
13:42:03 <geheimdienst> veinor, google the story behind the terms big-endian and little-endian. that's my favorite :-)
13:42:15 * Veinor reaps his zombie children
13:43:23 <c_wraith> mm, children.
13:43:55 <soupdragon> sproingie fuck you
13:44:00 <soupdragon> sproingie you're a troll fuck off
13:44:13 <soupdragon> I've been here much longer than you so shut up
13:44:18 <geheimdienst> if you set sigchild to ignore, you won't get notified when your child dies
13:44:42 <Jafet> I thought we hired a different circus today
13:44:44 * wli has been around long enough to suggest moving it to #haskell-blah
13:45:14 <wli> /msg nickserv info wli if you don't remember
13:46:28 <Phyx-> heh, why all the cussing
13:46:38 <soupdragon> Phyx- because he's accusing me
13:46:52 <mreh> there wasn't going to be any until you said that
13:47:13 <Phyx-> soupdragon: so? deal with it in an orderly manner like adults?
13:47:14 <geheimdienst> guys, please don't spread it to this channel
13:47:29 <monochrom> I am not an op in #haskell-blah. (separate from #haskell settings)
13:47:52 <soupdragon> sproingie: see what  geheimdienst said? that's a good advice
13:47:53 <monochrom> (but who is the troll? let's have troll competition fun :) )
13:48:13 <sproingie> soupdragon: you're still in the wrong channel
13:48:13 <mreh> soupdragon, you're as bad as each other
13:49:58 <mreh> ?preflex
13:49:59 <lambdabot> Unknown command, try @list
13:50:04 <mreh>  preflex
13:50:09 <soupdragon> preflex: be PoppaVic
13:50:09 <preflex>  C is one of those things that expects "miles", rather than "hours".
13:50:11 <mreh> I still can't remember how to use that
13:50:26 <mreh> preflex: seen Cale
13:50:27 <preflex>  Cale was last seen on #haskell 1 hour, 49 minutes and 36 seconds ago, saying: djahandarie: It should be a presentation that a mathematician would be happy with, and yet it should be comprehensible with no special knowledge, I think.
13:51:16 <Cale> Hi
13:51:28 <mreh> yay!
13:51:42 <geheimdienst> preflex: seen geheimdienst
13:51:42 <preflex>  geheimdienst was last seen on #haskell-blah 1 minute and 21 seconds ago, saying: zygoloid, cats sing when they shower http://www.youtube.com/watch?v=V3UPE89TkjY
13:51:44 <soupdragon> I'm reading a paper by Haskell Curry
13:51:46 <geheimdienst> preflex: seen geheimdienst
13:51:46 <preflex>  geheimdienst was last seen on #haskell 3 seconds ago, saying: preflex: seen geheimdienst
13:51:48 <geheimdienst> preflex: seen geheimdienst
13:51:48 <preflex>  geheimdienst was last seen on #haskell 2 seconds ago, saying: preflex: seen geheimdienst
13:52:28 <mreh> Cale, oh sorry, you don't maintain MonadRandom anymore!
13:52:31 <mreh> oops
13:52:37 <mreh> sorry to bother
13:53:12 <Cale> mreh: Oh?
13:53:22 <Cale> mreh: I *can* maintain MonadRandom, if you want
13:53:37 <EvanCarroll> can you define types in ghci?
13:53:49 <mreh> well, it's pretty minor, but I've added an instance for MonadFix to RandomMonad
13:53:57 <Cale> mreh: I was the original author. I put the code on the Haskell wiki. Someone else cabalised it.
13:54:04 <Cale> Oh, cool.
13:54:13 <mreh> it's derived from StateT
13:54:24 <Cale> EvanCarroll: No.
13:55:00 <Cale> EvanCarroll: Another good reason to adopt the practice of keeping an editor window open alongside ghci, and just tapping :r whenever you save your definitions.
13:55:07 <mreh> Cale, shall I send you a patch :)
13:55:16 <mreh> you could probably do it yourself
13:55:25 <Cale> mreh: Just add MonadFix to the deriving?
13:55:33 <mreh> Cale, yeah
13:56:00 <alexbobP> monads are like retrograde wheelbarrows
13:56:01 <Cale> okay, I'll do that
13:57:00 <Cale> EvanCarroll: I really think that we would benefit from adopting a Dr.Scheme-like environment, if not a Mathematica-style notebook environment for code.
13:57:20 <Makoryu> @seen chrisdone
13:57:21 <lambdabot> Unknown command, try @list
13:57:45 <soupdragon> Cale - I tried to make this (prototype) but all the libraries were too broken so I gave up eventually
13:58:45 <chrisdone> Makoryu: ???
13:59:13 <EvanCarroll> I'm not sure what those are, but I'm fairly certain you do, and that you're right.
13:59:26 <Makoryu> chrisdone: I was wondering why the tutorial in tryhaskell.org only responds to certain input if you type it exactly as shown
13:59:46 <Cale> EvanCarroll: Dr. Scheme has a two-paned window, with one pane that shows your code, and another which has a repl in it.
13:59:54 <Cale> With some nice interaction between the two.
14:00:02 <EvanCarroll> sounds cool
14:00:08 <chrisdone> Makoryu: 'cause some people complained that it wasn't strict enough
14:00:20 <Makoryu> chrisdone: Huh
14:00:27 <EvanCarroll> if you showed my code in an editor other than vim, I probably wouldn't use it though
14:00:31 <EvanCarroll> not to be a whiney bitch.
14:00:47 <chrisdone> Makoryu: i.e. when experimenting with different expressions, the tutorial would think they were answering and continuie
14:00:51 <Dashkal> EvanCarroll: xmonad (or any other tiling window manager) works wonders.
14:01:10 <Makoryu> chrisdone: Is it possible to at least compare the parse tree of the input, rather than an exact string match?
14:01:12 <EvanCarroll> yea, I know. I'm not there yet, I'll give xmonad a shot though some day -- I promise.
14:01:13 <Cale> With Mathematica, your program is essentially a document consisting of a vertical arrangement of "cells". Each cell can contain a definition, an input expression, or the resulting output.
14:01:23 <Cale> (Or just text)
14:01:28 <Dashkal> there are others.  I think the newest kde tiles now.
14:01:34 * hackagebot libxml-sax 0.5 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.5 (JohnMillikin)
14:01:39 <chrisdone> Makoryu: no, it happens at the javascript level, it's just a regex. what expression are you thinking of?
14:01:43 <Dashkal> at minimum, open a terminal and size it by hand :)
14:01:52 <Makoryu> chrisdone: The list
14:02:07 <Makoryu> chrisdone: That is, the lottery numbers
14:02:14 <Makoryu> [42,13] or whatever
14:03:08 <chrisdone> actually that one accepts anything
14:03:16 <chrisdone> any Num t => [t]
14:03:23 <Makoryu> Huh
14:03:26 <chrisdone> what are you typing in?
14:03:36 <Makoryu> I added spaces after the commas
14:03:40 <Makoryu> And it wouldn't work
14:03:53 <chrisdone> what exactly did you type?
14:04:00 <Makoryu> I don't remember
14:04:06 <Makoryu> Lemme go check the tutorial
14:04:29 <Makoryu> chrisdone: [42, 13, 22]
14:05:29 <chrisdone> ah, scratch that, it expects a list of numbers but didn't expect spaces
14:05:44 <Cale> EvanCarroll: Actually, I think for Haskell specifically, we could do a whole lot better than vim, or any general purpose text editor. One thing that I think would be nice to have is that any editing operation which causes a layout keyword to be moved should cause the contained block of code to move accordingly.
14:05:45 <chrisdone> just an incomplete regex, i guess
14:06:05 <chrisdone>                  return result.expr.match(/^[ ]*\[[0-9,]+\][ ]*$/) &&
14:06:05 <chrisdone>                      result.type == "(Num t) => [t]";
14:06:08 <chrisdone> i'll update it
14:06:15 <Makoryu> Cale: Like in that experimental Yi fork?
14:06:17 <Cale> (Or perhaps it should be the first non-whitespace character after the layout keyword)
14:06:18 <Makoryu> chrisdone: Thanks
14:06:26 <chrisdone> if you encounter any others, please let me know. if i'm not here, add an issue on the github repo
14:06:27 <Cale> Makoryu: Yes, except that yi does it wrong.
14:06:39 <Makoryu> Cale: I've never used it... merely seen a video of it.
14:07:37 <EvanCarroll> Cale: I'm just saying. I write in VIm. I like my VIm keybindings, I'm interested in other moded editors, but I wouldn't consider a modeless editor without a very powerful and lengthy list of merits.
14:08:25 <EvanCarroll> I'd rather see the prelude dumbed down personally
14:08:51 <EvanCarroll> if everyone uniformally agrees returning Int over (Num a) is archaic, then ffs remove it in a future version.
14:08:56 <Cale> I use vim too, but I don't tend to care so much about the keys. I've used emacs extensively as well. As long as the editor can convert tabs to spaces, and does a not-so-horrible job of syntax colouring, I'm fine :)
14:09:35 <Cale> EvanCarroll: Modifying the Prelude is something which lots of people would like to do, but somehow it never gets done.
14:10:22 <EvanCarroll> Cale: I use 90% of the features of vim. which is probably ten times more than the average vim user., though I understand the whole if it edits text I don't care bit. -- most of this is probably becaues I /don't/ use xmonad.
14:10:36 <EvanCarroll> I use screen with vim tabs, and windows.
14:10:58 <EvanCarroll> it works fairly well, or has allowed me to be productive without a nifty keyboard controlled window manager, like xmonad.
14:11:42 <Cale> EvanCarroll: I think the reason is that there are two competing ways in which to update the language, and they're both in force just enough to make progress difficult. There are the people (like me) who think that we should just change implementations however we like, and worry about standardising particular versions of them later, and there are the people who think that we should standardise changes before we implemen
14:11:42 <Cale> t them.
14:12:02 <EvanCarroll> Cale: it doesn't seem too hard. I'd consider myself fairly haskell-stupid, but I think I could do it. Presumably, there is an .hs file somewhere that the @src-bot reads from, I think I can edit that code and make all Ints type-classed, and delete stupid redundant functions
14:12:06 <Cale> and if you follow both of those rules, nothing ever gets done
14:12:27 <Cale> hm?
14:12:41 <Cale> Oh, it's easy to update the text file which says what @src returns.
14:12:46 <Cale> I'm not talking about that :)
14:12:46 <danharaj> I thought Haskell has always predominantly followed the former route.
14:12:52 <Cale> danharaj: yes
14:13:00 <Cale> danharaj: At least, in principle.
14:13:10 <danharaj> I can only think of Typeclasses as something that was specified before it was implemented.
14:13:16 <chrisdone> Makoryu: der you go http://i.imgur.com/DXi7C.jpg
14:13:23 <Cale> danharaj: But it's *also* following the latter route when it comes to the Prelude, and that's why nothing has changed.
14:13:31 <danharaj> and maybe IO modelled monadically?
14:13:56 <danharaj> Cale: I think modifying a standard library is probably the hardest thing to do in a language that gets real use.
14:14:46 <Cale> I think we should just version number things appropriately, but maybe we need an even bigger versioning abstraction. :)
14:15:07 <Cale> Something like an epoch to which certain sets of libraries belong to on Hackage.
14:15:12 <Jafet> lambdabot has a modified prelude and it works just fine (until you get a type error)
14:15:21 <Cale> Jafet: Well, sort of.
14:15:28 <Cale> It doesn't really have a modified Prelude
14:15:39 <Cale> It just imports the Prelude qualified, and redefines a couple of things.
14:15:52 <Cale> Er, s/qualified/hiding/
14:16:05 <EvanCarroll> Cale: You should fork the prelude.
14:16:07 <Jafet> The point being, those redefinitions are all generalizations
14:16:14 <EvanCarroll> Cale: I'll use it, and that will make one of us!
14:16:23 <Jafet> It's when you break something that a problem arises
14:16:56 <Cale> There were a bunch of people in #alt-stdlib which were interested in doing this, but there hasn't been any talk in there for a month or so now.
14:17:29 <danharaj> The prelude isn't that heavy of a library, why don't people just say "fuck it", write the prelude they want, and we can get together after the fact to pick and choose the good bits.
14:17:30 <Cale> The other problem is that forking the Prelude means forking GHC.
14:17:54 <danharaj> Cale: Is the prelude that tightly integrated into GHC?
14:17:57 <Cale> yes
14:18:08 <Cale> Well...
14:18:23 <Jafet> If types like Int aren't already a clue...
14:18:33 <EvanCarroll> isn't ghc already self forking
14:18:43 <EvanCarroll> what the stuff with Clang? and ghc-lvm
14:18:52 <EvanCarroll> I keep reading about it on reddit
14:19:01 <Cale> ghc changes quickly enough that I think we should be less concerned about code breakage
14:19:14 <Jafet> Those fork the internal back-end.
14:19:35 <Jafet> And clang is unrelated to ghc
14:19:43 <Cale> I think that if people are doing projects where they need a lot of long-term stability in the underlying platform, they'll just pick a version of GHC and stick with it.
14:19:45 <EvanCarroll> ah, yea clang is the gcc-lvm thing
14:19:50 <sproingie> no
14:19:56 <sproingie> clang is the llvm thing without gcc
14:20:11 <sproingie> i.e. a compiler suite that ditches gcc
14:20:15 <pizza_> clang is a C frontend to llvm
14:20:18 <EvanCarroll> right.
14:20:24 <Cale> and if they're continually maintaining their code, the sorts of changes to the Prelude most people are talking about would not be a *huge* deal to handle.
14:20:28 <danharaj> gcc needs to die =[
14:20:37 <sproingie> naw, gcc needs competition
14:20:41 <pizza_> exactly
14:21:00 <sproingie> the competition is already working, and it shows no signs of letting up
14:21:07 <chrisdone> tibbe: !!
14:21:09 <EvanCarroll> the clang stuff is kind of nifty. I don't know enough about gcc to say what isn't possible but not having to include parts of a library that aren't utilized is pretty nifty.
14:21:11 <Cale> I mean, my suggestion that we should change the associativity of ($) is practically the biggest breaking change anyone is suggesting, and even that's really trivial to fix code up for.
14:21:12 <sproingie> clang seems to do objC well enough for most of apple's stuff
14:21:30 <Jafet> You know what they say, only gcc can bury gcc.
14:21:36 <chrisdone> tibbe: http://gist.github.com/453933
14:21:43 <Cale> Well, maybe some possibilities for revamping the numeric hierarchy would break more.
14:22:08 <EvanCarroll> yea, I saw a really good bubble chart somewhere of the hierarchy
14:22:23 <tibbe> chrisdone: cool!
14:22:29 <Cale> EvanCarroll: There's one in the report.
14:22:41 <Cale> EvanCarroll: It's actually fairly well thought-out.
14:22:44 <EvanCarroll> definitly something better demonstrated with a graph than words -- remember that for yoru book.
14:22:51 <Cale> There are just a few super-annoying things about it.
14:23:13 <Cale> Particularly, that Num itself is a subclass of Show and Eq is stupid.
14:23:20 <Cale> and that Num has abs and signum
14:23:26 <Cale> (those should be off in another class)
14:23:50 <Cale> Those two changes would allow a lot of good Num instances to be made in a less hacky way.
14:24:10 <Cale> Particularly the one for functions.
14:24:38 <danharaj> I like those suggestions for type class supertyping by the JHC guy.
14:26:22 <Cale> What we really need are class constraint synonyms, and constraint families.
14:26:47 <Cale> Those are detailed by a paper, I hope they get into GHC soon.
14:27:17 <thoughtp1lice> class constraint synonyms? do you mean something like instance (FooP a, BarP a) => BazP a where ... ?
14:27:42 <thoughtp1lice> that requires UndecidableInstances however, but it's safe unless you do something completely dumb like 'instance BazP a => FooP a where ...'
14:28:05 <Cale> http://www.cl.cam.ac.uk/~dao29/talks/haskell-type-constraints-10-fun.pdf
14:28:27 <Cale> er, oops, that's the talk
14:28:45 <Cale> http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/constraint_families.pdf -- here's the paper :)
14:28:54 <thoughtp1lice> ah, that's what you meant
14:28:59 <thoughtp1lice> sorry, was a bit confused :)
14:29:07 <Cale> the table at the top of page 5 expresses things nicely
14:29:52 <Cale> I *think* that this extension would have the desired effect of the earlier class alias proposals...
14:30:03 <Cale> But I'm not 100% certain about that.
14:30:11 <thoughtp1lice> ah, yes i do like tom's proposals, especially the constraints for type families
14:30:42 <thoughtp1lice> i've been hoping for them to go into GHC since he published his first paper on the matter, it's very nice stuff that would be welcomed :)
14:31:02 <thoughtp1lice> this would also take care of a lot of the issues where you have to jump through hoops to get closed-type families for soundness
14:31:18 <Cale> But we don't just want to get this stuff into GHC, we really want to get it into the Prelude.
14:31:20 <thoughtp1lice> which iirc tom's paper addresses directly in some parts
14:31:30 <Cale> It solves the Monad Set problem.
14:31:55 <Cale> (though there are some other clever ways to manage that now)
14:32:05 <thoughtp1lice> yeah, notably a restricted monad i.e. the rmonad package
14:32:12 <Cale> right
14:32:25 <Jefskell> When I try to compile my program with ghc, I get the error "(.text+0x601f): undefined reference to `__stginit_EdisonCorezm1zi2zi1zi3_DataziEdisonziSeqziJoinList_'". This is my first time importing edison into a program. According to ghc-pkg, EdisonCore is installed. (I installed it using cabal). What am I doing wrong? Thank you.
14:32:41 <Cale> Jefskell: --make
14:32:46 <thoughtp1lice> Jefskell: use ghc --make
14:32:54 <thoughtp1lice> it automatically finds all dependencies and links them for you
14:32:56 <Cale> Jefskell: --make solves most linker errors
14:33:09 <Cale> You could also -package EdisonCore
14:33:11 * dcoutts_ notes again that we should make it the default
14:33:17 <Cale> yes
14:33:20 <Cale> I totally agree.
14:33:23 <Jefskell> Cale: Thanks! That worked. I've been struggling with this for way too long :-)
14:33:39 <Cale> Jefskell: Feel free to ask questions here. :)
14:33:40 <dcoutts_> Cale: there's only one corner case iirc where it clashes with the old meaning
14:35:04 <bcw> i'm reading the "monads as containers" article on haskellwiki, and i think i understand something, but i want to check.  is "m a" something like C++'s template (eg, vector<int>) syntax, in that the "a" or "int" or whatever is just the type of item the monad contains, not a specific instance (like in f :: a -> b)?
14:36:49 * hackagebot wai-extra 0.1.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.3 (MichaelSnoyman)
14:36:51 * hackagebot yesod 0.3.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.3.1.1 (MichaelSnoyman)
14:37:24 <RayNbow> bcw: "m a" corresponds to "m<a>" using C++/Java/C# syntax
14:37:37 <bcw> RayNbow, ok, thanks
14:37:47 <bcw> glad i wasn't confused :)
14:38:16 <Skarmar> Just wondering -- Is there a difference between "import Array" and "import Data.Array", or is one just an alias for the other?
14:38:33 <Cale> bcw: Let me know what you think of the article (I'm the author)
14:38:33 <Zao> The flat one is probably from the days of non-hiearchial modules.
14:38:38 <aristid> Skarmar: Array uses the old and outdated flat module hierarchy
14:39:04 <Cale> Skarmar: Array is Haskell 98 standard, Data.Array is where newer stuff goes.
14:39:40 <bcw> Cale, so far, i think it's good. i've read up to the "if you've understood the above", and i'm now reading it a second time to be sure i do
14:40:26 <Skarmar> aristid, Cale: Thanks. I will start using Data.Array. Does it make sense to start importing Data.List into programs also, to override some of the built-in list methods?
14:40:45 <Cale> Skarmar: Data.List won't override anything
14:41:05 <Cale> Skarmar: Data.List has a lot of really handy stuff in it though.
14:41:19 <hpc> Prelude imports and re-exports Data.List functions, right?
14:41:40 <RayNbow> bcw: btw, it gets trickier though if you want to translate a type like "State s a" to C++/Java/C# syntax
14:42:02 <Botje> State<s,a> ? :)
14:42:16 <Botje> oh wait, you mean because it doesn't curry?
14:42:20 <RayNbow> yes
14:42:25 <Botje> yeah :(
14:42:36 <Cale> State<s><a>
14:42:40 <Cale> or something ;)
14:42:41 <aristid> RayNbow: imagine this: State<s>::type<a>
14:42:47 <Skarmar> I see, thanks. It's great learning all this stuff.
14:43:39 <Jafet> Type("Map").specialize(String)
14:43:51 <tibbe> dons: did you manage to make some sense out of my HasMap example?
14:43:52 * hackagebot wai-handler-webkit 0.0.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-0.0.0 (MichaelSnoyman)
14:44:26 <bcw> RayNbow, well, i didn't think they were exactly the same anyway, just that they had some similarities
14:46:51 <dons> tibbe: just got it. will look at it later today.
14:46:57 <dons> expecting some hacking time tomorrow
14:47:18 <bcw> now i should finish re-reading. i'll come back after i think i understand the article (or have other questions). if you're here, Cale, i'll let you know what i think
14:50:55 * hackagebot concatenative 1.0.0 - A library for postfix control flow.  http://hackage.haskell.org/package/concatenative-1.0.0 (SamAnklesaria)
14:51:15 * ddarius is intrigued.
14:51:28 <EvanCarroll> what is the better framework happstack or snap?
14:51:50 <EvanCarroll> if it is a subjective, and neither is superior that is ok too. (not trolling)
14:51:56 * hackagebot bluetile 0.4.3 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.4.3 (JanVornberger)
14:51:58 <soupdragon> that's just the old trick
14:52:12 <c_wraith> Snap is a lot more modern in design, but it's also a lot less mature.
14:52:16 <soupdragon> and making it Arrow is needless
14:52:46 <sshc> Is "unlines (l:ls) = l ++ '\n' : unlines ls" equivalent to "unlines (l:ls) = *l ++ '\n') : unlines ls" or "unlines (l:ls) = l ++ ('\n' : unlines ls)"?
14:54:59 <ddarius> sshc: Only one of those ways would type check.
14:55:26 * geheimdienst is so proud that he was thinking along the same lines of ddarius
14:56:13 <soupdragon> I'm just wonder what eta_0 = [1,0,0,...] means
14:56:29 <ddarius> In what context?
14:56:40 <sshc> > [1,0,0,...]
14:56:41 <lambdabot>   <no location info>: parse error on input `]'
14:56:43 <sshc> > [1,0,0,..]
14:56:44 <lambdabot>   <no location info>: parse error on input `..'
14:56:49 <zygoloid> > [1,0..]
14:56:50 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
14:56:59 <sshc> > [1,0,0..]
14:57:00 <lambdabot>   <no location info>: parse error on input `..'
14:58:40 <soupdragon> [1,0,0,0...] is of the form [a(t),a_0,a_1,...] where a(t) is in mad-f-shape (continuous functions)and a_0,... are constants
15:00:12 <soupdragon> units of a hypercomplex algebra apparently
15:00:24 <soupdragon> not that I have a clue what that is
15:02:37 <ddarius> soupdragon: Reminds me of a germ.
15:02:38 <sproingie> i was in mad-f-shape when i came home from a party the other day
15:03:25 <ddarius> http://en.wikipedia.org/wiki/Analytic_continuation
15:05:43 <soupdragon> thanks!
15:05:45 <soupdragon> that is coola
15:05:47 <soupdragon> -a
15:15:23 <soupdragon> @check \(x y :: Rational) (n :: Integer) -> x^n + y^n == 1
15:15:24 <lambdabot>   Parse error in pattern at "(n" (column 20)
15:15:54 <EvanCarroll> BONUS: you know there is a styling problem on '_' in the code examples right?
15:16:20 <EvanCarroll> BONUS: http://learnyouahaskell.com/making-our-own-types-and-typeclasses, under "instance Eq (Maybe m) where" doesn't show the wildcard lhs of ==
15:17:20 <soupdragon> > 3^2 - 2^3
15:17:21 <lambdabot>   1
15:17:43 <geheimdienst> > 9^8 - 8^9
15:17:44 <lambdabot>   -91171007
15:17:56 <soupdragon> you never get 1 other than 3^2 - 2^3 :p
15:18:16 * geheimdienst will try each and every number before he believes that
15:18:18 <Cale> Is 6 the difference of two perfect powers?
15:18:35 <geheimdienst> > 4^3 - 3^4 
15:18:36 <lambdabot>   -17
15:18:37 <hpc> > 4^5 - 5^4
15:18:38 <lambdabot>   399
15:18:53 <djahandarie> @check \a -> a^(a-1) - (a-1)^1 == 1
15:18:54 <lambdabot>   "*Exception: Negative exponent
15:18:55 <aristid> > 1^2 - 2^1
15:18:56 <hpc> 2^4 - 4^2
15:18:56 <lambdabot>   -1
15:19:00 <geheimdienst> > 10 ^ eleventy - eleventy ^ 10
15:19:01 <lambdabot>   Not in scope: `eleventy'Not in scope: `eleventy'
15:19:02 <hpc> > 2^4 - 4^2
15:19:03 <lambdabot>   0
15:19:07 <geheimdienst> why doesn't this work
15:19:10 <ddarius> > 1^0 - 0^1
15:19:11 <lambdabot>   1
15:19:16 <hpc> > 2^5 - 5^2
15:19:17 <lambdabot>   7
15:19:24 <djahandarie> Heh ddarius
15:19:47 <hpc> > 2^1 - 1^2
15:19:48 <lambdabot>   1
15:19:51 <aristid> > [ x^y - y^x | x <- [1..], y <- [1..] ]
15:19:52 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
15:20:16 <hpc> haha
15:20:22 <Cale> Needs moar diagonalisation
15:20:37 <davekong> I am getting a compile error with http://codepad.org/kO6mLrNR
15:20:49 <davekong> Can anyone explain why map is expecting a char?
15:20:52 <soupdragon> > [ x^y - y^x | x <- [1..], y <- [1..x] ]
15:20:53 <lambdabot>   [0,1,0,2,1,0,3,0,-17,0,4,-7,-118,-399,0,5,-28,-513,-2800,-7849,0,6,-79,-184...
15:21:01 <soupdragon> there is 6
15:21:39 <soupdragon> > [ (x,y,x^y - y^x) | x <- [4..], y <- [1..x-1] ]
15:21:40 <lambdabot>   [(4,1,3),(4,2,0),(4,3,-17),(5,1,4),(5,2,-7),(5,3,-118),(5,4,-399),(6,1,5),(...
15:21:40 <aristid> > length $ filter id [ x^y - y^x == 1 | x <- [1..], y <- [1..x] ]
15:21:40 <Botje> davekong: you want unlines
15:21:41 <ivanm> OK, I just got an email from someone apparently thinking my emails on -cafe were great, and they want me to send a CV for a job at some London Bank...
15:21:44 <lambdabot>   mueval-core: Time limit exceeded
15:21:51 <aristid> lol
15:21:56 <aristid> > length $ filter id [ x^y - y^x == 1 | x <- [1..1000], y <- [1..x] ]
15:22:00 <lambdabot>   mueval-core: Time limit exceeded
15:22:01 <davekong> Botje: unlines?
15:22:03 <aristid> hmmm
15:22:12 <aristid> > length $ filter id [ x^y - y^x == 1 | x <- [1..100], y <- [1..x] ]
15:22:13 <lambdabot>   2
15:22:13 <geheimdienst> ivanm there were 2-3 people earlier on here who got similar mails
15:22:14 <hpc> > filter (\(x,y,z) -> z == 6) [ (x, y, x^y - y^x) | x <- [1..], y <- [1..x] ]
15:22:18 <lambdabot>   mueval-core: Time limit exceeded
15:22:25 <ivanm> geheimdienst: hmmm....
15:22:28 <Botje> instead of lines
15:22:30 <Cale> http://www.research.att.com/~njas/sequences/A023057
15:22:35 <aristid> that is prove that there only two number pairs with x^y - y^x = 1!
15:22:42 <aristid> -prove+proof
15:22:51 <Cale> ^^ this is an interesting sequence.
15:23:08 <geheimdienst> [ x^(x+1) - (x+1)^x | x <- [0..]]
15:23:13 <geheimdienst> > [ x^(x+1) - (x+1)^x | x <- [0..]]
15:23:14 <lambdabot>   [-1,-1,-1,17,399,7849,162287,3667649,91171007,2486784401,74062575399,239542...
15:23:38 <Cale> http://www.research.att.com/~njas/sequences/A074981 -- actually, this is the more interesting one :)
15:24:17 <geheimdienst> intelligence test: complete this sequence - 023057, 074981, ___
15:25:01 <c_wraith> 0
15:25:05 <davekong> Botje: thanks
15:25:16 <c_wraith> of course, I think 0 is the next number in every sequence
15:25:28 <aristid> c_wraith: 0 points.
15:25:53 <c_wraith> > let myFavoriteSequence = fix (0:) in myFavoriteSequence
15:25:55 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:25:57 <Cale> 098038
15:26:56 <geheimdienst> cale, you realize i just took the IDs of the 2 links you posted, right?
15:27:21 <geheimdienst> so if you'd post some more links to research.att.com, we'd know how the sequence continues
15:27:42 <Cale> http://www.research.att.com/~njas/sequences/?q=A098038
15:28:15 <geheimdienst> > 023057 + 074981
15:28:16 <lambdabot>   98038
15:28:40 <geheimdienst> ok, 3 numbers already. i wonder if i can submit it for inclusion in that sequence database now
15:29:01 <geheimdienst> it would be kinduva meta-sequence since it consists of the IDs of other sequences
15:29:21 <Cale> http://www.research.att.com/~njas/sequences/A104101
15:29:27 <geheimdienst> (a sorely neglected field, imho)
15:29:37 <magicman> The preferred way of updating packages with cabal is "cabal install --reinstall", right?
15:29:43 <soupdragon> http://www.research.att.com/~njas/sequences/?q=0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0%2C0&sort=0&fmt=0&language=english&go=Search
15:29:44 <soupdragon> lol
15:29:50 <soupdragon> @oies 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15:29:51 <lambdabot>  The characteristic function of 0: a(n) = 0^n.
15:29:51 <lambdabot>  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:30:02 <soupdragon> it's not good with the zeros
15:30:08 <dcoutts_> magicman: simply cabal install will do, no need for --reinstall
15:30:19 <magicman> Oh, cool. Thanks :)
15:30:26 <dcoutts_> magicman: --reinstall is only if you want to reinstall exactly the same version as you have installed right now
15:30:33 <magicman> *nod*
15:30:40 <geheimdienst> @oies 023057, 074981
15:30:40 <lambdabot>  Sequence not found.
15:30:54 <geheimdienst> i'm on to something. i've discovered something new.
15:30:56 <ddarius> geheimdienst: http://www.research.att.com/~njas/sequences/A053873
15:30:58 <aristid> @oies 1,2,3,4
15:30:59 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
15:30:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:31:11 <aristid> @oies 1,-1,2,-2
15:31:11 <lambdabot>  Each integer occurs exactly once: interleaved positive and negative integers...
15:31:12 <lambdabot>  [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,1...
15:31:23 <aristid> output wrong?
15:31:43 <Cale> weird
15:31:44 <geheimdienst> @oies []
15:31:44 <lambdabot>  Sequence not found.
15:31:47 <geheimdienst> @oies 
15:31:48 <lambdabot> Plugin `oeis' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
15:31:49 <Cale> Must be a problem with the parser
15:32:12 <geheimdienst> why is there no such thing as the Sequence That Contains No Numbers
15:32:16 <yitz> @oeis 1,(-1),2,(-2)
15:32:18 <lambdabot>  Euler totient function phi(n): count numbers <= n and prime to n.
15:32:18 <lambdabot>  [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,...
15:32:37 <Cale> geheimdienst: Because sequences are functions whose domain is the natural numbers
15:32:40 <ivanm> geheimdienst: it's called the empty set
15:32:44 <ivanm> ;-)
15:32:53 <Cale> geheimdienst: and so every sequence sends 0 somewhere
15:33:04 <Cale> (which is the same as having a first element)
15:33:10 <geheimdienst> @oies const 1
15:33:10 <lambdabot>  Antidiagonal sums of square table A112564 of generalized Flavius Josephus si...
15:33:11 <lambdabot>  [1,2,4,9,19,43,88,207,423,951,2094,4511,9445,22025,45172,93483,205101,435515...
15:33:17 <geheimdienst> o rly
15:33:17 <ddarius> 0 among countably infinite other numbers.
15:33:36 <edwardk1> preflex: xseen dons
15:33:36 <preflex>  dons was last seen on freenode/#haskell 46 minutes and 38 seconds ago, saying: expecting some hacking time tomorrow
15:34:33 <geheimdienst> !seen dcoutts
15:34:39 <geheimdienst> preflex: seen dcoutts
15:34:39 <preflex>  dcoutts was last seen on #ghc 5 hours, 21 minutes and 3 seconds ago, saying: right, it could have been wrong all along and a recent change in mpfr makes that more visible
15:34:50 <dcoutts_> @arr!
15:34:50 <lambdabot> I'll crush ye barnacles!
15:34:56 <geheimdienst> @oies 46, 38, 5, 21, 3
15:34:56 <lambdabot>  Sequence not found.
15:35:00 <edwardk1> @tell dons would something like http://gist.github.com/456448 do to solve your repeated deepSeq woes?
15:35:01 <lambdabot> Consider it noted.
15:35:01 <geheimdienst> @oies 5, 21, 3
15:35:01 <lambdabot>  a(n) = smallest integer k>1 such that n(k^2-1)+1 is a perfect square, or 0 i...
15:35:02 <lambdabot>  [2,5,3,0,2,3,5,2,0,3,7,5,4,11,3,2,4,13,9,7,2,5,19,4,0,5,21,3,11,9,11,14,2,29...
15:35:07 <ivanm> dcoutts_: no, geheimdienst obviously wants dcoutts, not you! :p
15:35:23 * dcoutts_ wanders off to get yet another cup of tea
15:35:53 <geheimdienst> i have the sequence now. i can predict how long dcoutts will be away
15:36:03 <geheimdienst> 11 hours 9 min 11 sec
15:36:17 <bremner> strong tea.
15:36:23 <edwardk1> geheimdienst: it is like timing boss spawns in an MMO ;)
15:37:02 * geheimdienst marvels at the metaphor likening dcoutts' appearances in #haskell to boss spawns in mmos
15:37:34 <edwardk1> geheimdienst: yeah, but won't he be surprised when we all jump him at once ;)
15:37:40 <sproingie> if you kill him he comes back?
15:37:43 * dcoutts_ pencils in the time for his reappearance tomorrow morning...
15:37:49 <Cale> Heh, that would be awesome if a boss spawned according to the smallest integers k > 1 such that n(k^2 - 1) + 1 is a perfect square
15:38:01 <sproingie> LFM #haskell10
15:38:41 <edwardk1> Cale: massive multiplayer, not mathematical multiplayer ;) though i suppose you could raise an entire generation of mathematicians that way
15:38:58 <sproingie> massively mathematical online game
15:39:30 <sproingie> heck some of the stuff on elitistjerks pretty much is just that
15:39:31 <Cale> http://www.research.att.com/~njas/sequences/graph?a=130280 The scatterplot of the log of that sequence has a bit of interesting structure in it
15:39:32 <edwardk1> true, the players aren't necessarily for the mathematical model
15:40:15 <Cale> edwardk1: You should see the stuff that people work out about Pokemon
15:40:37 <edwardk1> Cale: what is bad is i have ;)
15:40:47 <ddarius> Oh god.
15:40:59 <Cale> http://www.toasterlabs.net/wp-content/uploads/Pokemon-Its-Serious-Business.jpg
15:41:42 <geheimdienst> @oies pokemon
15:41:42 <lambdabot>  Sequence not found.
15:42:10 <Cale> http://bulbapedia.bulbagarden.net/wiki/Catch_rate
15:42:27 <dcoutts_> geheimdienst: I presume you wanted to ask me something?
15:43:32 <geheimdienst> no, sorry for bothering you :-) we were just messing with asking preflex when luminaries have last been seen, then plugging the numbers into the sequence search
15:43:56 <dcoutts_> oh right
15:44:01 <soupdragon> Cale the funny thing is that the kids growing up playing these games have intuitive understanding about these equations
15:44:36 <geheimdienst> thanks dcoutts_ for being so considerate :-)
15:44:52 <Cale> brb
15:47:30 <Kaide> so the (*) operator does not short circuit?
15:47:50 <ddarius> It could.  Depends on the instance.
15:47:59 <Kaide> > foldr (*) 1 [-2..]
15:48:01 <lambdabot>   *Exception: stack overflow
15:48:02 <hpc> > 0 * undefined
15:48:03 <lambdabot>   *Exception: Prelude.undefined
15:48:12 <ivanm> > foldr (*) 0 [-2..]
15:48:14 <lambdabot>   *Exception: stack overflow
15:48:20 <ivanm> looks like it doesn't for INT
15:48:23 <ivanm> bah, Int
15:48:47 <Kaide> > foldr (*) 1.0 $ map fromInteger [-2..]
15:48:48 <hpc> or any of the base Nums, likely
15:48:48 <lambdabot>   *Exception: stack overflow
15:48:52 <Cale> It doesn't short circuit for any of the Prelude types
15:49:08 <edwardk1> ivanm: slow down a few billion perfectly good cases for one? sometimes the good of the many....
15:49:23 * edwardk1 helps. 
15:49:29 <ivanm> edwardk1: I didn't say it _should_, just that it doesn't
15:49:36 <edwardk1> newtype ShortCircuit a = ShortCircuit a
15:49:36 <ddarius> No Integer Left Behind
15:49:40 <edwardk1> i leave the rest to you ;)
15:49:41 <ivanm> ddarius: heh
15:49:46 <ivanm> edwardk1: lol
15:49:57 <ivanm> maybe copumpkin's beloved Natural type short circuits
15:50:26 <edwardk1> ivanm: i'm trying very hard not to make a snide comment ;)
15:50:45 <Kaidelong> just seemed interesting to me
15:50:49 <Cale> newtype Circuit a b = Circuit { unCircuit :: a -> (Circuit a b, b) } -- completely unrelated
15:50:54 <ivanm> edwardk1: why bother? just say it!
15:50:56 <Kaidelong> I can't really think of a situation where the short-circuiting would really matter
15:51:05 <ivanm> you'll just cause yourself mental anguish if you don't....
15:51:13 <Cale> Kaidelong: I can.
15:51:20 * ivanm just wants to hear what edwardk1's snide comment is
15:51:37 <dafis> Kaidelong, foldr (*) 1 ([1 .. 100] ++ [0 .. ])
15:51:43 <edwardk1> it was just going to be a bashing of copumpkin by misinterpreting short circuit
15:51:45 <Kaidelong> dafis
15:51:53 <ivanm> edwardk1: go ahead and bash!
15:51:54 <Kaidelong> you could do the same thing by just trying to find 0 in a list
15:51:57 <Cale> Actually, what I often want more than this sort of short circuiting is for the product of an infinite sequence of 1's to be 1
15:52:00 <Kaidelong> except it will terminate if there is no 0
15:52:01 <Cale> Which is harder.
15:52:03 <ivanm> then we can @remember it... :p
15:52:07 <edwardk1> ivanm: man you know how to suck all the fun out of the room ;)
15:52:48 <Cale> (It almost always happens when taking a combinatorial infinite product of formal power series)
15:52:59 <Veinor> Cale: how can you prove that it'll always be 1?
15:53:06 <Kaidelong> but then wouldn't you write your own logic for limits?
15:53:06 <Cale> Veinor: That's exactly the problem
15:53:24 <Kaidelong> as opposed to using infinite lists of rationals
15:53:33 <Cale> Veinor: I might be smart enough to know that it'll always be 1, but it's awkward to convey that information to the computer.
15:53:47 <Cale> Or to get the computer to prove it.
15:54:41 <Cale> The problem can be side-stepped by defining a product which simply assumes that it's the case
15:54:48 <dafis> Cale: data EList a = Nil | Cons a (EList a) | Repeat a
15:54:52 <sshc> Should the smaller map be passed as the first or second argument for Data.Map.(\\)?
15:55:03 <sshc> The first, right?
15:55:37 <Cale> dafis: The trouble is that when you do the convolution, you're forming a sequence of the first elements of each of the power series (which had better be 1, but there's no guarantee)
15:55:50 <dafis> sshc: the first argument is the map whose elements you want to keep (if they aren't present in the second)
15:56:02 <Cale> and so there's no way to replace fix (Cons 1) with Repeat 1
15:56:33 <dafis> Cale: yes, that's hairy
15:56:39 <sshc> dafis: I see.
15:56:49 <sshc> I thought the order was the other way around, but alright.
15:56:51 <Veinor> 'if the first 100 are 1, the rest are too' ;)
15:57:34 <dafis> Veinor: why so many?
15:57:36 <Cale> Veinor: You could actually do a lazy sort of check, where you fail when you get to the first element beyond the constant term which depends on the series which had a non-1 constant term.
15:57:47 <Veinor> was picking a random number.
15:59:11 <edwardk1> Cale: StableNames ;)
15:59:21 <edwardk1> yes, not perfect
15:59:43 <Cale> I'm not even certain how StableNames will help
16:00:14 <edwardk1> given ones = 1 : ones -- you can recover that the tail is the same as the initial node
16:00:25 <Cale> oh, yes...
16:00:30 <edwardk1> and use it to rewrite it into a fixed depth loop
16:00:35 <z28> Still need help with Maybe.  I'm tryingto create an ADT which will hold either an Int or Nothing. I thought this was the right way to describe this: data Splat a = Splat Maybe a
16:00:42 <Cale> However, we're rarely going to get such a nice case here.
16:00:58 <BrianHV> is there a function like takeWhile, but it counts the matching elements rather than returning them?
16:01:01 <dafis> z28: data Splat a = Splat (Maybe a)
16:01:09 <z28> ah
16:01:10 <edwardk1> Cale: i missed the entire beginning of the conversation. i was just piping up in response to what was on my screen at the time ;)
16:01:33 <Cale> Consider something like  product over k >= 0 of 1/(1 - x^k)
16:01:35 <edwardk1> length . takeWhile p 
16:01:38 <dafis> BrianHV: not in the standard libs
16:01:52 <Cale> That is, the generating series for partitions.
16:01:53 <BrianHV> all right.  I'll just do what edwardk1 suggested then. :)
16:01:59 <dafis> I assume length . takeWhile p will be too inefficient
16:02:03 <z28> thx very much dafis
16:02:30 <Cale> All your series are different, but they all have the lucky property of having a constant term of 1
16:02:33 <BrianHV> dafis: probably not for my purposes, but what would be better?
16:02:37 <edwardk1> dafis: not likely, remember the the takeWhile doesn't actually directly return you the list, it just gives you should that gives it back to you oneelement at a time, which is consumed by length
16:03:04 <edwardk1> wow that got scrambled
16:03:16 <edwardk1> BrianHV: length . takeWhile p  should work fine
16:03:27 <z28> dafis:  Is the syntax you gave me documented somewhere.  I figured I had a syntax issue but I couldn't find anything that pushed me in the direction you indicated
16:03:51 <BrianHV> is "p" a haskell convention for a predicate?
16:03:58 <edwardk1> BrianHV: no ridiculously long intermediate lists should be formed. effectively laziness will turn it into one loop (a little bit inefficient)
16:04:02 <dafis> edwardk1, right, forgot that, though if you have a long prefix, it'll still be slower without stream fusion
16:04:02 <pastorn> BrianHV: yes
16:04:05 <ivanm> BrianHV: for the function variable? yes
16:04:09 <Cale> BrianHV: It's more of a lisp convention
16:04:13 <pastorn> BrianHV: usually p :: (a -> Bool)
16:04:15 <pastorn> for some a
16:04:27 <Cale> BrianHV: But yes, the single variable p for a predicate function is common.
16:04:33 <edwardk1> dafis: sure, but its more than adequate until you benchmark and find that you're spending all your time in 'length' ;)
16:04:34 <BrianHV> nice.  thanks all.
16:04:36 <aristid> :t usually
16:04:36 <lambdabot> Not in scope: `usually'
16:04:50 <edwardk1> aristid: =)
16:05:06 <aristid> would be a cool function if it existed
16:05:06 <edwardk1> aristid: i think i might want to use that as a combinator for speculation ;)
16:05:49 <aristid> edwardk1: making up a definition on the spot?
16:05:49 <Cale> usually x = do n <- randomRIO (0,1000); if n > 0 then x else return ()
16:06:08 <edwardk1> Spec.foldr (usually 0) (+) 0 
16:06:34 <edwardk1> aristid: nah, as an estimator, in this case i guess usually = const
16:07:13 <geheimdienst> :t guess
16:07:14 <lambdabot> Not in scope: `guess'
16:07:20 <geheimdienst> :t guessWhat
16:07:21 <lambdabot> Not in scope: `guessWhat'
16:07:25 <aristid> edwardk1: you're actually writing a speculative combinator lib? or is this just a joke? :)
16:07:42 <edwardk1> aristid: http://hackage.haskell.org/package/speculation
16:07:57 <dafis> aristid, it's pretty awesome already
16:07:59 <geheimdienst> :t notInAMillionYears
16:08:00 <lambdabot> Not in scope: `notInAMillionYears'
16:08:12 <geheimdienst> :t getOuttaHere
16:08:13 <lambdabot> Not in scope: `getOuttaHere'
16:08:21 <geheimdienst> none of my speculative combinators exist :-(
16:08:24 <aristid> edwardk1: woah
16:08:39 <Cale> http://i.imgur.com/trSnZ.jpg -- lol
16:08:42 <edwardk1> aristid: written right now, the lengths i'll go for a joke ... ;)
16:08:52 <Cale> For people who can't multiply by 1 ;)
16:09:27 <aristid> Cale: or for people who ask for group rebates
16:09:28 <edwardk1> i also need to write some non foldable combinators, like speculative iterate, etc.
16:09:39 <geheimdienst> do they supply an iphone app that lets me input the number of people, then tells me the dollar amount?
16:10:44 <edwardk1> i suppose what i need is Data.List.Speculation
16:10:53 <edwardk1> so i can have scanl, etc.
16:10:53 <geheimdienst> to be positive, the makers of the sign still assume people can count themselves
16:10:59 <aristid> edwardk1: oh i see why usually = const
16:12:12 <edwardk1> aristid: yeah you provide a guess at what the fold will be after so many values
16:12:17 <Zeiris> Why does deleteBy delete only one element, rather than many?
16:12:39 <edwardk1> Zeiris: short answer: deleteBy means nothing like what you thing it does
16:12:44 <edwardk1> you want filter
16:12:53 <dafis> Zeiris, because for deleting many, we have filter
16:13:07 <Zeiris> Ah, right, so there's no need at all for deleteby. Thanks, heh :)
16:13:22 <geheimdienst> zeiris, check out http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-List.html#v:delete
16:13:24 <Zeiris> Still seems like it does something that's unintuitive for the type signature and name, though.
16:13:36 <edwardk1> delete is designed to hunt and remove the first occurence of something
16:13:46 <edwardk1> it is used to complement functions like "lookup" etc
16:13:58 <edwardk1> which use lists as an inefficient but omnipresent container
16:14:32 <edwardk1> deleteBy is the generalization of that to use your custom test
16:14:53 <edwardk1> of course deleteBy is silly, because it just partially applies its first two arguments
16:14:55 <pozic> Some programming languages don't even allow you to write inefficient code by not providing certain convencience functions. 
16:15:10 <pozic> convenience*
16:15:39 <pozic> (which is a very effective method of pushing people to write less broken software)
16:15:40 <dafis> pozic: you can still write inefficient code
16:15:52 <dafis> it only takes longer
16:15:58 <pozic> dafis: yes, you can, but you don't because it is easier to use one of the other structures.
16:16:06 <pozic> dafis: same as in Haskell.
16:16:25 <pozic> dafis: you can write hacks in Haskell, but you don't because it is more work to do so.
16:16:36 * ddarius will probably finish his hat today except for the pom-pom and weaving in.
16:17:07 <dafis> pozic: I write hacks in Haskell (if they give a good enough speedup)
16:17:41 <sinelaw> edwardk1 did you implement kalman filtering (or other filtering) in haskell?
16:18:38 <orlandu63> > (fmap (+1) (-)) 2 3
16:18:39 <lambdabot>   0
16:18:42 <edwardk1> sinelaw: haven't had a need yet
16:18:43 <orlandu63> what did i just do?
16:18:48 <Lajla> I see brackets
16:19:07 <sinelaw> edwardk1 how would you go about implementing a filter? I need a fast, type-safe linear algebra lib
16:19:22 <edwardk1> sinelaw: i haven't finished writing my blas bindings yet =/
16:19:54 <edwardk1> all i've done so far is identify cases where i can make them fast using dirty hackery
16:20:01 <geheimdienst> > (fmap (+1) (-)) 6 8
16:20:02 <lambdabot>   -1
16:20:11 <sinelaw> edwardk1 keep going then :) j/k, i'll be happy to use it if you recommend 
16:20:52 <edwardk1> sinelaw: it is something i need to make a faster vectored AD implementation, so its definitely on the TODO list.
16:21:00 <geheimdienst> :t fmap (+1)
16:21:01 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
16:21:30 <geheimdienst> :t fmap (+1) (-)
16:21:31 <lambdabot> forall a. (Num a) => a -> a -> a
16:21:53 <sinelaw> edwardk1, k, i'll probably make some naive kalman implementation in the coming weeks
16:21:55 <sinelaw> for my robot
16:21:57 <hpc> :t fmap (+) (-)
16:21:58 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
16:22:19 <edwardk1> however, i have other things queuing up in front at the moment. speculation is coming along, i want to try to get some code coverage and unit tests in there. i need to figure out a workaround to get hmpfr working or i have to give up and write my own multiprecision floating point lib in haskell
16:22:22 <geheimdienst> > fmap (+) (-) 1 2
16:22:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:22:23 <lambdabot>    arising from a use of `...
16:22:25 <geheimdienst> > fmap (+) (-) 1 2 3
16:22:26 <lambdabot>   0
16:22:29 <sinelaw> edwardk1, the image processing is so horribly slow that i don't think the kalman performance will matter much
16:22:42 <edwardk1> sinelaw: =)
16:22:58 <geheimdienst> > ( (+) . (-) ) 1 2 3
16:22:59 <lambdabot>   0
16:23:08 <geheimdienst> omg i'm on to something
16:23:17 <sinelaw> edwardk1 do you have some experience with CV?
16:23:24 <aristid> :t (+) . (-)
16:23:25 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
16:23:29 <Jefskell> The command 'a // [(i, a!i + c)]' is accounting for half my program's run time. Is there anyway to add a number to one cell of an array more efficiently? Thanks.
16:23:29 <edwardk1> computer vision?
16:23:33 <sinelaw> yeah
16:23:45 <aristid> geheimdienst: it probably only works because of the Expr stuff
16:23:51 <geheimdienst> what is that with the (a->a) in there? why is it supposed to take a function?
16:23:53 <edwardk1> a little/ i wrote some chirplet code a decade or so back
16:24:09 <edwardk1> i also used it for headtracking for a 3d holographic computer display system
16:24:34 <edwardk1> but that was mostly using a stereo camera to isolate the person's nose. which was pretty easy ;)
16:24:44 <sinelaw> heh
16:24:58 <sinelaw> i'm using opencv's haar detector for face detection
16:25:00 <sinelaw> it's quite slow
16:25:17 <edwardk1> not familiar with opencv. i am pretty comfortable with haar wavelets though
16:25:18 <dafis> Jefskell, STUArrays?
16:26:04 <edwardk1> (i used to use them for texture compression, image search, etc)
16:26:05 <sinelaw> edwardk1 they build a cascade of haar classifiers 
16:26:21 <sinelaw> eliminating some percentage of false positives at each step
16:26:34 <sinelaw> until you're left only with the object you want
16:26:38 <edwardk1> *nods*
16:27:09 <sinelaw> it's trained by feeding tons of positives / negatives and choosing for each step the classifier that eliminates most negatives / retains most positives or whatever
16:27:32 <edwardk1> yeah fairly typical for this space =)
16:27:40 <sinelaw> anyway, it's pretty slow because you don't know where the face is and its scale
16:27:42 <sinelaw> yeha
16:27:45 <sinelaw> *yeah
16:27:55 <edwardk1> or worse, if one is even present ;)
16:27:59 <sinelaw> right
16:28:22 <sinelaw> i'm considering switching to eigenfaces
16:28:29 <sinelaw> which is PCA basically
16:28:40 <edwardk1> at least you get a sounder theory
16:28:49 <sinelaw> and better performance i think
16:29:09 <sinelaw> i mean speed
16:29:19 <pozic> Are the various CUFP talks intended to be online forever?
16:29:34 <pozic> Or ICFP talks. 
16:30:33 <sinelaw> PCA is rediculously simple
16:30:35 <sinelaw> which is cool
16:31:13 <pozic> A simple theory cannot predict complex sequences.
16:31:15 <soupdragon> why does brownian motion exist??
16:31:30 <soupdragon> pozic yes it can just ask Steven Wolfram
16:31:38 <soupdragon> I'm confused about brownian motion though
16:31:41 <edwardk1> hrmm i wonder if a Data.Set.Speculative that used a bloom filter to give back an initial guess at the answer would be fun
16:31:49 <danharaj> brownian motion is the limit of like, everything.
16:31:52 <pozic> soupdragon: that is generate. 
16:32:03 <pozic> soupdragon: that is not prediction.
16:32:04 <soupdragon> generate = predict
16:32:10 <edwardk1> pozic: how wolfram of you ;)
16:32:27 <sinelaw> soupdragon for one thing, because of the central limit theorem
16:32:28 <danharaj> Isn't it a definition of complex that it cannot be described by a simple theory? ;p
16:32:38 <sinelaw> if i'm getting your question at all
16:33:09 <edwardk1> soupdragon: actually the wolfram model there is 'irreducible complexity' that you can have simple systems that you can't fast forward without stepping through all the intervening steps. in that sense. prediction is that 'fast forward' capability
16:33:18 <Jefskell> dafis: STUArray looks promising. I'll have to read a bit more about monads I guess. Thanks much.
16:33:24 <edwardk1> otherwise you're just argument nomenclature and no useful distinctions can be made
16:34:13 <sinelaw> edwardk1 acutally come to think of it, i can use haar to find the face and then kalman to track it - keep looking for it in a small window of sizes / positions that kalman predicts, unless we loose the face
16:34:29 <edwardk1> what do you need the face for?
16:34:47 <sinelaw> edwardk1: a silly robot that follows people's faces
16:35:08 <edwardk1> i still like my incredibly simple stereo-camera approach, just set up a markov model and find the greatest point of correlation between the two images. done ;)
16:35:09 <c_wraith> Jefskell, You don't need to learn about monads.  Just learn how to use ST.  It's much easier. :)
16:35:15 <soupdragon> okay but what's going on with brownian motion?
16:35:31 <edwardk1> the nose is the closest thing on the face to the screen, and if not, then the robot finds something interesting and starts following it ;)
16:36:12 <sinelaw> edwardk1 where does the markov come in here? 
16:36:16 <edwardk1> it worked pretty well to keep people's faces lined up with the center of the hologram
16:36:39 <sinelaw> soupdragon: can you elaborate? i don't understand what you're asking about brownian motion
16:36:45 <sinelaw> </ELIZA>
16:36:51 <soupdragon> I really don't even know where to start 
16:37:05 <soupdragon> I just don't get it at all
16:38:07 <edwardk1> sinelaw: probably a good starting point for markov random fields: http://www-sigproc.eng.cam.ac.uk/research/reading%20group/material/perez.pdf
16:38:57 <edwardk1> you can hunt for correlation in them, when you have two stereo images, and use them to get a rough depth map for the scene
16:39:12 <edwardk1> depth makes a lot of shape recognition easy ;)
16:39:37 <sinelaw> edwardk1 yeah i know a little about stereographic depth map construction using corellation
16:39:38 <danharaj> edwardk1: taking a hint from our own evolution :p
16:39:47 <SSToday> the following code works fine, just want to know if you have advices about indentation/ idioms http://gist.github.com/456551
16:39:50 <edwardk> danharaj: exactly =)
16:40:00 <sinelaw> soupdragon, the only useful thing I can say is "central limit theorem"
16:40:23 <sinelaw> (certain combinations of random stuff tends to look like normal distribution)
16:40:37 <sinelaw> (under very general conditions)
16:40:54 <edwardk> sinelaw: in my case i already had the camera mounted (plus, getting 3d holographic projection of 3d security camera data made the security guys at places like ADT go gaga) so it was an obvious choice.
16:40:56 <pozic> sinelaw: don't you mean "all"?
16:41:29 <sinelaw> pozic, there are some minimal conditions
16:41:35 <edwardk> plus, having the correlation let me use it for nice 2.5d video conferencing. you looked a little like something out of minority report, but the guy on the other end could tilt the camera view, etc.
16:41:57 <dafis> SSToday, put where on a line of its own, and I'd be surprised if it worked because the case is indented far more than the binding in the line above
16:42:10 <edwardk> pozic: if there is correlation it can break down
16:42:31 <sinelaw> edwardk: do you have a demo / video or something?
16:42:37 <edwardk> pozic: much of what i do for a living involves exploiting the central limit theorem ;)
16:42:51 <edwardk> sinelaw: nah, that all stayed with the company
16:43:05 <soupdragon> so is it true that brownian motion is everything
16:43:16 <edwardk> sinelaw: they used it to run security for the superbowl a little while back though
16:43:16 <monochrom> wrong channel
16:43:28 <sinelaw> edwardk, dunno if you've seen it http://www.youtube.com/watch?v=2ZblWWxeLsY&feature=player_embedded
16:43:32 <sinelaw> if yes, ignore.
16:43:36 <pozic> By the central limit theorem, under certain conditions the sum of a number of random variables with finite means and variances approaches a normal distribution as the number of variables increases. 
16:43:48 <pozic> How wonderfully useless.
16:43:50 <sinelaw> edwardk my goal is to get that to work without playing the video at 5x normal speed :)
16:43:54 <soupdragon> normal distribution? like the primes
16:44:15 <sproingie> isn't that just an oblique definition of "normal distribution"?
16:44:33 <sinelaw> pozic: what's useless?
16:44:35 <edwardk> sinelaw: http://ref.michigan.org/medc/services/serviceprovider/listing.asp?Company=9266 is about all i can google off hand ;)
16:44:40 <pozic> sproingie: yes, AFAIK.
16:44:47 <pozic> sinelaw: the certain conditions part.
16:44:58 <sproingie> it's like saying "throw enough darts and they'll be distributed around the board".  .... okay.
16:45:04 <pozic> sinelaw: AFAIK, they also have to be normal distributions.
16:45:05 <SSToday> dafis: I've just executed it, except if copy pasting changed something. So you suggest putting more on a single line? I was afraid that it's make too much
16:45:31 <sinelaw> pozic: nope
16:45:54 <edwardk> pozic: well, it is quite useful. no they don't need normal distribution, just a distribution and general lack of correlation
16:46:13 <dafis> SSToday, no, not more on one line, just give the where a line of its own, indent the local bindings say two spaces further than the 'w'
16:46:19 <edwardk> pozic: in fact the central limit theorem _tends_ toward holding even in the presence of some correlation
16:46:24 <pozic> edwardk: then you are trowing darts in the space of distributions.
16:47:43 <soupdragon> what does throwing darts metaphor have to do with brownian motion
16:47:51 <danharaj> isn't there a generalization of the central limit theorem that characterizes the limiting distributions under ridiculously weak conditions?
16:47:56 <edwardk> pozic: it comes down to the fact that if you add up a bunch of bad estimators you get a good estimator. and what it says is that the _mean_ of a bunch of independent random variables is normally distributed. which means that you can get an estimate of the mean, regardless of distribution
16:48:29 <sclv> I don't remember the source, but a favorite quote of mine is that the degree of immaturaty of a field can be judged by its reliance on the normal distribution :-)
16:48:32 <edwardk> and know the general shape of the quality of your estimate to much better accuracy than you'd get with blind trust in Chebyshev or based on looking at the kurtosis of the distribution at hand
16:48:37 <edwardk> sclv =)
16:49:11 <sinelaw> it also means that generally most phenomena (such as many sorts of noise)  behave as if normally distributed
16:49:15 <SSToday> dafis: fixed that http://gist.github.com/456551
16:49:38 <sinelaw> because they are often a combination of many random things
16:49:43 <sinelaw> that are generally independent
16:49:51 <SSToday> dafis: thanks
16:49:58 <pozic> But the "tending" is also what makes it theoretically useless.
16:50:25 <sinelaw> pozic: it can tend very quickly sometimes
16:50:27 <edwardk> pozic: well, the mean itself IS normally distrbuted as long as you have independent random variables
16:51:03 <edwardk> 'tends to' just addresses the fact that under minor violations of the premise you only get minor violations of the theoretical result
16:51:12 <sinelaw> pozic: since it's called the "central limit theorem" you can imagine it's not theoretically useless
16:51:29 <dafis> SSToday, the case resp of... is still indented far more than resp <- simpleHTTP..., that's a pretty impressive pasting artifact if the code you have actually compiles :)
16:51:35 <pozic> sinelaw: I worked out the details of the theorem years ago. 
16:51:57 <pozic> sinelaw: that doesn't mean I actually use the theorem, not know the details of it now.
16:52:48 <sinelaw> pozic: it's implicitally used in many contexts where we assume that random signals are normally distributed. I don't know if you're into that stuff
16:53:04 <sinelaw> it makes the assumption plausible
16:53:30 <pozic> sinelaw: I am not in the signal processing business, so I didn't know that.
16:54:09 <sinelaw> fair enough
16:54:26 <Traveler0> Hello
16:54:45 <dafis> pozic: are you versed in calculus?
16:54:58 <sinelaw> edwardk: do you have any idea when Weiner filters are most useful?
16:55:02 <sinelaw> in practice
16:55:03 <soupdragon> http://mathworld.wolfram.com/CentralLimitTheorem.html
16:55:08 <soupdragon> what ..... the ... hell......
16:55:20 <soupdragon> can't read any of this
16:55:36 <Traveler0> I was reading about derivatives and container types and was wondering is there a subtraction type? cause that'd let people do integration over types.
16:55:48 <dafis> soupdragon, try wikipedia?
16:56:01 <pozic> dafis: upto about gradients, yes. 
16:56:03 <edwardk> sinelaw: *cough* slashdot ;)
16:56:28 <edwardk> though a goatse filter might be more important
16:56:40 <dafis> pozic: so you're not familiar with convolutions?
16:56:48 <soupdragon> Traveler0: It cant exist except in theory
16:56:50 <danharaj> soupdragon: sure you can. just one esoteric equation at a time :p
16:57:14 <soupdragon> Traveler0: I mean you can't make elements of it, as a data type, but you can still add it to get cancellation and stuff
16:57:24 <soupdragon> and also [x] = 1/(1-x)
16:57:32 <soupdragon> so there's a negative in that
16:57:33 <pozic> dafis: I know the term and I saw and read its definition multiple times, but I have not applied it in the real world myself. 
16:58:02 <edwardk> sinelaw: well, if i had to apply one, it'd typically be in some kind of radio application where i'm getting background chatter
16:58:04 <pozic> dafis: it is a concept from power series, right?
16:58:09 <dafis> pozic: pity, cause the smoothing properties of convolutions make the CLT quite intuitive
16:58:25 <pozic> dafis: well, power series stole it from calculus.
16:58:30 <edwardk> preferably where i can avoid realtime
16:58:31 <soupdragon> I've seen an animation of convolution
16:58:35 <dafis> because the density of the normal distribution is the ultra-smooth function
16:58:38 <soupdragon> what's that got to do with CLT though?
16:58:44 <soupdragon> and how does it relate to brownian motion?
16:58:57 <Traveler0> I was thinking a sub type could be made like this data Sub a b=forall c.((b+c<->a),c) where <-> is an isomorphism
16:59:10 <sinelaw> edwardk: ok, i just learnt about it's theory, it seems rather elementary but not very practical
16:59:34 <dafis> pozic: convolutions appear in many places, e.g. in integration
16:59:35 <pozic> dafis: I had no issue understanding the CLT at age 12. 
16:59:44 <edwardk> sinelaw: *nods* you're just trying to deconvolve a signal, it'll never be perfect
16:59:54 <sinelaw> pozic: i'm afraid you may have overconfidence in this matter
17:00:16 <danharaj> Understanding the gist of a theorem is not the same as...
17:00:18 <Cale> I've seen the proof of the CLT, and yet I'm still not sure I understand it fully.
17:00:25 <soupdragon> yikes
17:00:36 <soupdragon> as if it wasn't already intimidating enough
17:00:48 <pozic> sinelaw: on an intuitive level it was completely obvious for me at the time, I can remember that.
17:00:50 <sinelaw> pozic: just look at the many generalizations of the theorem in the wikipedia page
17:01:09 <sinelaw> pozic: in probability theory intuition is more misleading than helpful in many cases
17:01:12 <Cale> (I know what it says, and I have some intuition about it, but I'm not a probabilist)
17:01:28 <soupdragon> probabilist is just a funny word
17:01:34 <soupdragon> Cale do you know brownian motion?
17:01:34 <pozic> sinelaw: making things more general does not mean it adds anything interesting.
17:01:55 <sinelaw> pozic: so why are you using Haskell? who needs them typeclasses
17:02:10 <Cale> soupdragon: I know what it is, I know essentially nothing useful about it.
17:02:10 <sinelaw> generalization is for lamers
17:02:14 <pozic> Gauss had one simple idea from which everything followed.
17:02:28 <soupdragon> pozic did you listen to the history of mathematics?
17:02:32 <soupdragon> there was one on Gauss 
17:02:34 <pozic> At least according to a biography of Gauss.
17:02:45 <pozic> soupdragon: I read a few books on a few mathematicians.
17:02:52 <pozic> soupdragon: one of them was Gauss.
17:02:55 <soupdragon> no I mean the bbc radio series
17:03:06 <pozic> soupdragon: no, but that might be interesting.
17:03:10 <soupdragon> yeah it's okay
17:03:13 <sinelaw> pozic: i recommend learning some more math before making such broad judgments
17:03:20 <soupdragon> but I thought he was a bit arrogant and nasty about Gauss
17:03:29 <soupdragon> and I've been studying Gauss
17:03:31 <soupdragon> so it was a shame
17:03:50 <pozic> sinelaw: what do you feel I should be learning?
17:04:11 <sinelaw> pozic: i don't know what you know, but it sounds as if you would benefit by knowing more :)P
17:04:18 <pozic> E.g. I know I am weak in matrix calculus.
17:04:26 <sinelaw> matrix calculus?
17:04:28 <soupdragon> matrix calculus???
17:04:29 <soupdragon> omg
17:04:37 <soupdragon> as if vector and complex calculs werent hard enough
17:04:37 <Cale> A lot of people's conception of mathematics is stuck in the 1700's
17:04:50 <soupdragon> Cale: how could I know if mine was?
17:04:53 <pozic> But that's simply because all the books I opened up didn't care to present clearly.
17:05:06 <pozic> If they cannot take the time to write down things decently, I lose interest. 
17:05:38 <pozic> I have better things to do in my life than to decypher mathematics. They are free to write a decent book and then I can read it and learn something.
17:05:44 <dafis> pozic: that may not be entirely the books' fault
17:05:48 <sinelaw> pozic: do you know what reimann integration is (exactly)? and the generalizations to modern integration theory? complex analysis? hilbert spaces? measure theory? 
17:06:00 <soupdragon> why does everyone feel the need to call pozic out??
17:06:04 <pozic> sinelaw: Riemann*
17:06:07 <sinelaw> pozic: sorry.
17:06:08 <monochrom> A lot of people's conception of writing is stuck in the 1700's.
17:06:18 <pozic> sinelaw:  and yes, I know about all those areas.
17:06:20 <Cale> soupdragon: Well, there's two aspects of it. There's the philosophical aspect, and there's the content.
17:06:34 <pozic> sinelaw: that is, none of those words are new to me.
17:06:45 <pozic> sinelaw: and I have seen the defitions for all of them. 
17:06:48 <sinelaw> pozic: great. i see those as the most enlightening parts 
17:06:50 <BrianHV> is there a function like replicate that can take an [a] instead of an a?  e.g., I want  replicate 3 "asdf" == "asdfasdfasdf".  can't seem to find a match on hoogle.
17:06:52 <pozic> definitions*
17:07:02 <sinelaw> pozic: among the basic theories
17:07:08 <soupdragon> > replicate 3 "asdf"
17:07:08 * geheimdienst sides with pozic
17:07:08 <lambdabot>   ["asdf","asdf","asdf"]
17:07:13 <soupdragon> > replicateM 3 "asdf"
17:07:14 <lambdabot>   ["aaa","aas","aad","aaf","asa","ass","asd","asf","ada","ads","add","adf","a...
17:07:23 <dafis> concat . replicate 3
17:07:33 <BrianHV> dafis: right.  thanks.
17:07:42 <c_wraith> :t Last
17:07:43 <lambdabot> forall a. Maybe a -> Last a
17:07:54 <soupdragon> Cale - so the philosophical aspect is that everyone should be a formalist? :P
17:07:59 <soupdragon> Cale - and what about the content?
17:08:00 <Cale> soupdragon: More modern developments in formal logic (by modern here, I mean stuff that happened around 1910), were responsible for a shifting view in the epistemology of mathematics toward formalist perspectives, where essentially anything is fine as long as you explain the rules clearly.
17:08:06 <soupdragon> do you mean lack of computers?
17:08:25 <Cale> So, yeah, if not being a formalist, having a formalist's acceptance of new ideas at least.
17:08:28 <soupdragon> which things in 1910 specifically?
17:08:38 <sinelaw> pozic: did you get a chance to study them or do you mean just reading the definitions?
17:08:46 <sinelaw> i only got that chance lately
17:08:46 <soupdragon> Cale - so you don't wan another Kronecker :p
17:08:55 <Cale> Well, that was around when the foundations of mathematics became formal.
17:09:01 <pozic> sinelaw: I read a few thousand pages of calculus. 
17:09:31 <Cale> Set theories were developed, and examined in detail, and Gödel's incompleteness theorems provided a negative answer to Hilbert's program.
17:09:36 <pozic> sinelaw: I should have done more exercises, maybe.
17:09:41 <sinelaw> pozic: sounds like a lot. was that a book?
17:09:47 <Cale> and all that
17:09:47 <sinelaw> or several books
17:09:50 <pozic> sinelaw: multiple. 
17:10:03 <Cale> But then, in the 1950's or so, we have the topologists developing category theory
17:10:23 <soupdragon> Cale, oh yeah I have read about the topos theory
17:10:27 <pozic> sinelaw: one was an engineering mathematics book. The other ones gave the mathematical view.
17:10:31 <Cale> and I think many mathematicians haven't even properly noticed yet what a change that's caused in the way that people think about mathematics
17:10:44 <soupdragon> like  they can prove that dx^2 = 0 -> ~~dx = 0 but not dx^2 = 0 -> dx = 0
17:10:50 <sinelaw> pozic: which part did you find most interesting? i just know the basics of stuff and am wondering what to learn next
17:10:53 <pozic> sinelaw: for engineers everything is in low-dimensions.
17:10:58 <soupdragon> so you can add dx^2 = 0 as an axiom and do calculus with nilsquare infintesimal
17:11:05 <Cale> But category theory has completely reshaped the way that we go about the business of mathematics, at least in my opinion.
17:11:08 <pozic> sinelaw: for mathematicians, everything is always generalized. 
17:11:20 <sinelaw> pozic: right, and i like that.
17:11:34 <pozic> sinelaw: I think you should strive to be able to read modern physics papers.
17:11:34 <Cale> The first thing we now do whenever we bump into a new mathematical object is to try to ask what the structure preserving mappings are.
17:11:52 <Cale> (to turn it into a category)
17:11:57 <soupdragon> that's the erlanger program
17:11:58 <soupdragon> ?
17:12:05 <sinelaw> pozic: i'm not very interested in physics. I learnt a little modern physics (quantum / relativity) but lost interest.
17:12:26 <sinelaw> Cale: I like the idea of "natural transformations"
17:12:29 <Cale> I think that's something different, but I might be mistaken
17:12:31 <sinelaw> they pop up everywhere
17:12:38 <soupdragon> maybe that's just restricted to geometry
17:12:40 <pozic> sinelaw: it seems that physics papers contain the most applications of advanced mathematics.
17:12:41 <Cale> yeah
17:12:57 <pozic> sinelaw: in CS there is not _that_ much continuous mathematics. 
17:13:03 <Cale> If it's what I recall it being, it's sort of like a microcosm of this effect.
17:13:23 <edwardk> pozic: or another view of it is that everything is continuous ;)
17:13:34 <sinelaw> pozic: probably physics pushes math to its limits the most currently, but I'm more interested in signal processing which has its own share of math which are quite abstract, nice and pure
17:13:37 <Cale> Group theory is a sort of special case of category theory, and the Erlangen program is about treating geometry in a group-theoretic way.
17:13:40 <edwardk> pozic: http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
17:14:24 <soupdragon> the problem with category theory is it's really hard to learn :/
17:14:35 <Cale> soupdragon: Did I give you Awodey's book yet?
17:14:52 <soupdragon> well I don't think I read that one
17:14:57 <sinelaw> Cale: when you look even at basic calculus / probability theory you can simplify many definitions and properties by talking about functors and natural transformations
17:15:06 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
17:15:41 <sinelaw> e.g. continuous operator = natural transformation on the limit process
17:15:53 <newlambda> I'm trying to decide between Haskell and Clojure. Learning a new language takes time, so I need to pick one. I'd like to hear arguments in favour of opting for Haskell.
17:15:55 <sinelaw> T . lim = lim . T
17:15:56 <sinelaw> :)
17:16:13 <Cale> newlambda: Types are awesome and you should learn about them.
17:16:14 <sinelaw> that means T is continuous
17:16:19 <soupdragon> what's lim?
17:16:36 <sinelaw> soupdragon: i meant a limit
17:16:40 <geheimdienst> newlambda, haskell has obviously the awesomest irc channel
17:16:43 <soupdragon> what is it though
17:16:53 <newlambda> Cale: I assume you mean types in a category theory sense?
17:17:04 <Cale> newlambda: Not even in a category theoretic way
17:17:15 <soupdragon> (Cale that url is dead btw)
17:17:24 <Cale> soupdragon: Oh, sorry, I'll look into why
17:17:41 <monochrom> well you don't have to bring up functors and natural transformations in full strength, but commutativity like T.lim=lim.T, f(x+y)=f(x)+f(y) are always nice.
17:17:48 <sinelaw> soupdragon: for example if you have a sequence of x's, you can say that the limit of the sequence is y if as the index n goes to infinity, x_n gets arbitrarilty close to y
17:17:50 <Cale> soupdragon: is cale.yi.org resolving to 99.247.170.113 ?
17:17:59 <geheimdienst> (no, i downloaded the book just fine)
17:17:59 <newlambda> I would be interested in web app development with apps that do a bunch of very smart things. I'm a little discouraged by the lack of use of Haskell on the web.
17:18:14 <soupdragon> Cale yeah
17:18:28 <Cale> soupdragon: okay, weird. It looks like I have the port forwarded properly too
17:18:32 <soupdragon> Cale - wait 99.247.170.113/share/Category%20Theory%20-%20Awodey.pdf works
17:18:39 <soupdragon> but ping did resolve that domain to that ip
17:18:49 <Cale> soupdragon: Maybe a dns cache wibble
17:18:53 <soupdragon> okay
17:19:10 <Cale> newlambda: There's some new progress in that direction which seems somewhat exciting.
17:19:40 <Cale> http://snapframework.com/
17:20:14 <newlambda> Cale: I was expecting Snap to have a blog sample a la Rails. But the examples shown are trivial.
17:20:15 <geheimdienst> newlambda, i feel haskell gives you the best of static languages, which is the compiler does a whole lot of work checking you, and the best of dynamic languages, i.e. you don't often need to spell out types
17:20:33 <Cale> http://snapframework.com/media/img/pong-bench.png -- responses/second for a simple pong server microbenchmark :)
17:20:37 <p_l|backup> newlambda: while I don't feel much like towards "normal" webapp with Haskell, web services and various backend parts of a webapp? sure
17:20:56 <Cale> newlambda: Yeah, it's really early
17:21:05 <geheimdienst> recently after haskelling i went back to write a tiny bit of javascript, and i got furious that javascript is so unhelpful. it doesn't catch any of the errors i make :-)
17:21:21 <newlambda> geheimdienst: good point
17:21:29 <newlambda> Cale: I undestand
17:22:30 <sinelaw> geheimdienst, newlambda for that reason I started using GWT (Google Web Toolkit) and although Java has its own bag of horrors, it's better than javascript at least in terms of finding out about your errors at compile time
17:22:44 <geheimdienst> but clojure is a decent language too with lots of good ideas. rich hickey is a smart guy who clearly knows his stuff. i guess you have set up yourself for choosing between dating miss america and the runner-up
17:22:47 <sinelaw> and some type safety most of the time
17:23:20 <Cale> newlambda: Probably if you learn Haskell, clojure won't be hard. I'm not certain about the other direction.
17:23:35 <ihckt> ,~
17:23:40 <newlambda> I hear you Cale
17:24:13 <newlambda> Clojure doesn't have any type safety, like Haskell does, right? Purely dynamic?
17:24:18 <geheimdienst> sinelaw, what bugs me about java is 1) it doesn't have closures 2) you have to repeat types over and over again. if you want to change (say) a String to a String[], you have to change that in a million places in the source. in haskell it's much better because of the inference
17:24:22 <Cale> newlambda: right.
17:24:35 <Cale> Haskell forces you to reshape your thinking about how to write programs in certain ways that many other functional programming languages won't do as good a job of pushing you into.
17:24:55 <sinelaw> geheimdienst don't try to convince me java sucks, esp. wrt. haskel. i'm already more than convinced.
17:25:01 <geheimdienst> ;-)
17:25:11 <sinelaw> java really sucks. even c# is better despite the horrible mess of features
17:25:38 <sinelaw> geheimdienst I wish we had haskell -> javascript stuff
17:25:43 <geheimdienst> that is true. especially the last few years, c# has moved much quicker than java in terms of adding stuff
17:25:50 <alexyk> edwardk: dons mentioned you wrote a typed binary package?  what's the name?
17:26:28 <edwardk> alexyk: i had a type level 2s and 16s complement integer arithmetic library, is that what you mean?
17:26:32 <newlambda> oh and for math research?
17:26:44 <Cale> geheimdienst: That's because there are Haskell people working on it secretly.
17:26:53 <Cale> (and VB.net as well)
17:27:05 <alexyk> edwardk: no, something like Data.Binary but which stores types with the data
17:27:37 <alexyk> similar to ocaml's type-desc
17:27:44 <alexyk> (that's me, not dons' :)
17:27:47 <edwardk> ah not me. as in carries it in a hlist so you can deserialize it later safely?
17:28:02 <geheimdienst> cale, you mean erik meijer, right?
17:28:02 <c_wraith> What sort of structure is like monoids, but without associativity laws?
17:28:06 <alexyk> edwardk: something like that
17:28:11 <Cale> geheimdienst: Yeah, for the most part :)
17:28:15 <sclv> its easy enough to roll your own.
17:28:17 <edwardk> c_wraith: unital magma
17:28:26 <sclv> the key bit is a library that lennart, i think, wrote
17:28:31 <newlambda> I know some people love to do math research in C... but I'd prefer something higher level
17:28:46 <sclv> which provides the a serializable typerep
17:28:53 <newlambda> I heard great things about OCaml as well in this regard
17:28:56 <Cale> newlambda: Oh, if you're a mathematics person, you should definitely be programming in Haskell :)
17:28:57 <sclv> then you just serialize type .+. value
17:29:00 <edwardk> sclv: ah the lennart/oleg one?
17:29:01 <sclv> and check it on deserialization
17:29:07 * BrianHV would like to request code review.  the generated HTML is a little funky, but that's not what I'm worried about.  http://gist.github.com/456601
17:29:54 <Cale> BrianHV: you're indenting if/then/else weirdly, but you really should be using guards :)
17:29:54 <newlambda> Cale: I don't know if I'm a math expert, but I do have a PhD in mathematics
17:29:56 <edwardk> BrianHV: the i2c (x:xs) indent_stack = ... case would be more idiomatic with guards
17:29:58 <dafis> BrianHV, first, splitAfter is span
17:30:17 <Cale> newlambda: Well, that's good enough. I only have my BMath :)
17:30:18 <edwardk> i2c (x:xs) indent_stack | null indentstack || ... = ... 
17:30:28 <edwardk>      | fst x == last inden_stack = ...
17:30:30 * geheimdienst tried to work through an ocaml tutorial once, just to get a feel for it, but threw it out when on page 2 it said "oh, utf8 doesn't really work easily"
17:30:39 <Cale> newlambda: If you like category theory, you'll be happy to find that we like stealing ideas from it and specialising them to programming.
17:30:47 <BrianHV> dafis: good to know.  thanks.
17:30:58 <geheimdienst> (and who doesn't like category theory? sigh...)
17:31:12 <BrianHV> Cale, edwardk: ok... will try to rewrite with guards, which I forgot about
17:31:15 <newlambda> I love category theory
17:31:29 <soupdragon> newlambda how did you learn it
17:31:32 <Cale> BrianHV: splitAfter looks like span
17:31:35 <soupdragon> ?
17:31:38 <soupdragon> I would like to but I found it ver yhard
17:31:52 <BrianHV> Cale: yeah, dafis just mentioned that.  but thanks to you too. :)
17:32:00 <sinelaw> i tried awodey's  book but got stuck at page 18
17:32:00 <sclv> edwardk: I think so.
17:32:03 <sinelaw> i'll try again soon
17:32:06 <edwardk> brianhv: otherwise i'd probably replace the (concat . replicate n) "<ul><li>"  ++ values by using concat without parens, etc.
17:32:09 <c_wraith> Hmm, actually..  Is associativity the only monoid law?
17:32:17 <Cale> c_wraith: identity
17:32:22 <Cale> (on the left and right)
17:32:26 <edwardk> c_wraith: unit
17:32:37 <edwardk> c_wraith: just associativity is a 'semigroup'
17:32:38 <c_wraith> Yeah, ick.  It's actually identity that I don't want.  My structure is associative.
17:32:43 <newlambda> soupdragon: in university. The book I like the most on the subject is Awodey's Category Theory
17:32:50 <BrianHV> edwardk: I'll come back to that one after I play with the other changes.  I may need some clarification on that.
17:33:05 <geheimdienst> oh, we were just talking about awodey before you came in
17:33:06 <c_wraith> I do have a distinguished element, it's just not an identity from both sides.
17:33:15 <newlambda> timing :)
17:33:17 <Cale> c_wraith: interesting
17:33:20 <edwardk> (foo . bar) "quux"  vs. foo $ bar "quux" or foo (bar "quux") the latter two are both more readable
17:33:31 <ddarius> newlambda: Nah.  Awodey comes up a lot.
17:33:37 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf -- I put this up :)
17:33:46 <edwardk> c_wraith: "pointed magma/semigroup" ;)
17:33:55 <newlambda> I'll give Haskell a shot
17:34:03 <c_wraith> Cale: I think it's a really useful structure.  It models command line argument parsing. :)
17:34:10 <soupdragon> I'm going to hit that as soon as I finish the chapter of this number theory stuff I am on
17:34:21 <sclv> edwardk: oh wait, not polytypeable. that's something else.
17:34:30 <ddarius> Usually it's handy and possible to add a unit.
17:34:45 <Cale> newlambda: Feel free to ask any questions you might have here, even if you think maybe they're easy. It can be a lot quicker than navigating the documentation.
17:34:55 <Cale> (and people don't generally mind)
17:35:05 <ddarius> But don't ignore the documentation either (!)
17:35:24 <geheimdienst> and first of all, learn you a haskell
17:35:52 <newlambda> Learn you a Haskell the book?
17:35:57 <geheimdienst> exactly
17:36:01 <edwardk> heh, defining scan :: (Monoid m, Eq m) => (Int -> m) -> [m] -> [m] makes me really want to be able to take an answer in an arbitrary seminearring
17:36:02 <Cale> newlambda: Yeah, that's available online :)
17:36:17 <newlambda> Real World Haskell wouldn't be better?
17:36:32 <soupdragon> Real World Category Thoery
17:36:35 <sproingie> RWH is harder to follow
17:36:39 <sproingie> LYAH is gentler
17:37:06 <sclv> alexyk, edwardk: http://hackage.haskell.org/package/typehash
17:37:28 <geheimdienst> Virtual World Category Theory
17:37:32 <Cale> newlambda: Try both
17:37:35 * sproingie should start up on writing LYYARWGH again sometime
17:37:41 <geheimdienst> Unreal World Haskell
17:37:50 <sproingie> MTV's Real World Haskell
17:37:55 <monochrom> Complex World Haskell
17:38:05 <sproingie> Cool World Haskell
17:38:08 <geheimdienst> sproingie, learn you yet another real world guide to haskell?
17:38:12 <newlambda> :)
17:38:14 <ddarius> Every week...
17:38:16 <c_wraith> Computable Real World Haskell
17:38:23 <geheimdienst> Surreal World Haskell
17:38:27 <sproingie> geheimdienst: almost, the G is "gentle"
17:38:32 <dafis> Rational World Haskell
17:38:46 <c_wraith> dafis: what use would that book be here? :)
17:38:47 <sproingie> geheimdienst: but i kinda like "guide" better
17:38:49 <geheimdienst> sproingie, real world gentle haskell?
17:38:50 <dafis> aka Irreal World Haskell
17:39:06 <sproingie> geheimdienst: either way you have to perform severe damage to your tongue to pronounce it properly
17:39:17 <geheimdienst> Real Universe Haskell
17:39:37 <sproingie> i think it'll have to be integrated with tryhaskell tho
17:39:42 <geheimdienst> Real Madrid Haskell
17:40:13 <geheimdienst> Real Discworld Haskell
17:40:20 <soupdragon> lol!
17:40:27 <Pseudonym> @seen shapr
17:40:28 <lambdabot> Unknown command, try @list
17:40:29 <sproingie> except i imagine tryhaskell has no IO
17:40:38 <Pseudonym> shapr, you around?
17:40:38 * geheimdienst 's brain is such that he can't let go of something even if everyone has moved on an hour ago
17:40:45 <geheimdienst> preflex seen shapr
17:40:45 <preflex>  shapr was last seen on #haskell-blah 18 minutes and 44 seconds ago, saying: Not really sure how to write that.
17:40:53 <Pseudonym> Right.
17:41:21 <geheimdienst> newlambda, anyway, for some light reading you should also check out http://www.willamette.edu/~fruehr/haskell/evolution.html
17:41:27 <Pseudonym> http://artofsystems.blogspot.com/2008/04/twasker-desktop-twitter-client-in.html <- Someone needs to help this guy out.
17:41:32 <BMeph> geheimdienst: IOW, you're a meme lackey? ;)
17:42:51 * hackagebot mongoDB 0.6 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.6 (TonyHannan)
17:43:00 <geheimdienst> i can has memes?
17:44:04 <sclv> @bot
17:44:04 <lambdabot> :)
17:44:18 <sclv> @tell alexyk the lennart package I mentioned is here: http://hackage.haskell.org/package/typehash
17:44:18 <lambdabot> Consider it noted.
17:44:32 <pozic> A new kind of Haskell. 
17:45:55 <BrianHV> all right... made some of the suggested changes.  does this look better?  http://gist.github.com/456601  (I don't really know how to indent guards with long conditionals like that)
17:46:00 <geheimdienst> website launched to much fanfare: Wadler Alpha
17:47:23 <monochrom> "Wadler Alpha is a new generation website that writes a complete and new FP paper when you enter a desired title"
17:48:21 <ddarius> The quality of the paper is directly proportional to the quality of the title like this gem: "How to be lazy without even being odd"
17:49:03 <pozic> ddarius: I cannot decide what you thought about the paper.
17:49:29 <geheimdienst> "Each paper is accompanied by a prototype compiler so sophisticated it won't accept any input from users who don't at least have a PhD."
17:49:34 <soupdragon> hehe
17:50:25 <Cale> BrianHV: Okay, the next problem is that you're repeatedly taking the 'last' of indent_stack
17:51:05 <dafis> BrianHV, I have issues with your use of the 'indentStack'. At a first glance, it seems that is is sorted and you always compare with the last element
17:51:18 <Cale> BrianHV: If you're using a list to represent a stack, the top of the stack should be the first element
17:51:30 <BrianHV> aah, interesting.
17:51:42 <Cale> Otherwise, you pay an O(n) performance penalty for all those lasts
17:52:04 <BMeph> BrianHV: Other folks have mentioned it before, but to repeat: NEVER take the length of a list whose length you don't care about!
17:52:06 <Cale> Generally, using length and using last are good signs that something is wrong.
17:52:40 <BrianHV> BMeph: am I doing that?  or are you refering to my use of last?
17:52:41 <BMeph> BrianHV: IOW, instead of (\x -> length x > 0), say (not . null). :)
17:52:45 <BrianHV> oooh
17:53:01 <soupdragon> I liked the F5 paper by graham hutton
17:53:06 <soupdragon> did anyone else read that one
17:53:14 * BMeph raises his hand
17:53:23 <soupdragon> Factorising folds for faster functions
17:53:37 <soupdragon> oh and thisone: What is the meaning of these constant interruptions?
17:54:28 <soupdragon> does anyone have advice on writing?
17:54:30 <dolio> So, is there anything I need to read in my 335 unread haskell-cafe messages?
17:54:41 <soupdragon> like how to write a document that is good to read
17:55:16 <dafis> soupdragon, Begin at the beginning. Then go on until you come to the end. Then stop.
17:55:30 <BrianHV> all right... I reversed my stack and changed my non-empty check.  http://gist.github.com/456601
17:55:31 <soupdragon> that's reading
17:55:42 <geheimdienst> soupdragon, i learned a lot by writing a sentence, then cutting each word that could possibly be cut, and replacing everything with the simplest accurate word
17:55:52 <monochrom> dolio: HaRe announcement, and shameless plug: "whine and solution about programmers not respecting documentations"
17:56:19 <dafis> BrianHV, instead of [x] ++ list, use x:list
17:56:26 <geheimdienst> dafis, don't make it sound simple. that will lead to bad, inconsiderate, bloated writing
17:56:44 <BrianHV> my instinct is to refactor everything of non-trivial complexity into a function.  I'm not sure if that's because I'm new to the language or not.  but e.g., I'm tempted to factor each of those guard conditionals into named functions.  is that a good instinct, or overkill?
17:56:53 <BMeph> dolio: Ooh, ooh! You should have a contact from a london financier headhunter, looking for fresh meat! Don't want to miss out on that... ;D
17:56:56 <BrianHV> dafis: thanks!
17:58:05 <dafis> BMeph: haven't we all deleted that immediately?
17:59:17 <ddarius> dolio: I wonder about that in my no doubt > 10,000 unread messages.
17:59:20 <geheimdienst> brainhv, without having looked at your code, i'd say repetition is bad. if you feel the need to copy-paste a line, consider making a function instead and call it twice. for functions you only every call once: depends. a giant messy blob is difficult to understand, but so is a metric boatload of tiny functions calling each other in confusing ways
17:59:41 <monochrom> "non-trivial complexity" depends on your education
17:59:42 <geheimdienst> s/only every/only ever/
18:00:16 <monochrom> and sometimes depends on your editor window width
18:00:20 <dolio> ddarius: Doubtless there are some things you could have answered better than I did.
18:00:21 <BrianHV> geheimdienst: in this case it's not repetition, or indirection per se.  it would be about changing "null indent_stack || fst x > head indent_stack" into "is_more_indented (fst x) indent_stack"
18:00:49 <dolio> I generally only jump in on the theory end of things, though.
18:00:53 <BrianHV> gilbertleung: IOW, just giving a name to it to hide the complexity
18:01:04 <BrianHV> errr... geheimdienst.  sorry.
18:01:43 <dafis> BrianHV, you could pattern match on the stack too
18:02:00 <geheimdienst> i think that is a good idea, since the function name is_more_indented makes things more readable. it's information not obvious from "null indent_stack || .."
18:02:18 <BMeph> BrianHV: Speaking of hides, I'd definitely pull out "length indent_stack". I'd throw it down and stomp on it, but you may rather stick it in a where clause, since you keep using it so much. ;)
18:02:23 <geheimdienst> as socrates said, code is written once but read many times
18:02:31 <soupdragon> socrates didn't say that :P
18:02:51 <geheimdienst> soupdragon, don't be silly, he did
18:03:00 <elliottt> can anyone tell me which exception gets thrown by ^C?
18:03:03 <BrianHV> dafis: I tried to figure out how to do that usefully in this case, but couldn't come up with anything...
18:03:10 <ddarius> soupdragon: How do you know he didn't say that?
18:03:11 <geheimdienst> elliottt, sigint, i believe
18:03:11 <BMeph> I always thought Socrates said, "I drank WHAT?!?" :)
18:03:33 <elliottt> sorry, which haskell exception :)
18:03:47 <BrianHV> BMeph: only twice... ;)  the one in the empty-list clause I'm not sure how to avoid.  perhaps I could avoid subtracting the list lengths...
18:03:55 <elliottt> i can catch it by catching SomeException, but can't figure out which exception i've got :)
18:05:11 <geheimdienst> it might be an AsyncException UserInterrupt
18:05:22 <dafis> BrianHV, i2c [] stack = ...; i2c ((i,str):xs) [] = (Indent 1,str) : i2c xs [i]; ...
18:06:24 <BrianHV> dafis: oooh, interesting.
18:08:10 <dafis> and i2c ((i,str):xs) (in:ins) | i < in = ... | i == in = ... | otherwise = ...
18:08:59 <BrianHV> that's where it gets tricky, because I have to handle deindenting (unindenting?) more than one level
18:10:02 <BrianHV> although I guess that would still work
18:10:16 <BMeph> Exdenting! :)
18:10:28 <dafis> BrianHV, messed up the comparisons, but you can still use the same logic
18:10:46 <dafis> Outdenting
18:11:03 <geheimdienst> Denting
18:11:58 <geheimdienst> (considerate -- inconsiderate, advisable -- inadvisable, denting -- indenting)
18:14:21 <dafis> formative -- informative
18:20:52 <BMeph> flammable -- inflammable... wait a minute... ;)
18:21:13 <geheimdienst> famous -- infamouse
18:21:15 <geheimdienst> -e
18:21:38 <geheimdienst> although, an infamouse might be a quite innovative input device
18:21:48 <geheimdienst> like a famouse
18:22:39 <BrianHV> dafis: I like the matching approach much better than what I was doing before.  thanks!
18:22:47 <BMeph> Like Danger Mouse's evil twin...
18:26:50 <monochrom> ctrl-c gives you AsyncException, value UserInterrupt if you compile. if you use ghci or runghc, I can't discern the exception type other than SomeException.
18:27:32 * geheimdienst can't believe he got that right. his google-fu is strong today.
18:30:55 <monochrom> it is not AsyncException, IOException, Deadlock, ErrorCall, NonTermination
18:31:45 <c_wraith> in ghci, ctrl-C sends...  Interrupted?
18:31:50 <c_wraith> I was just looking at this code
18:33:02 <geheimdienst> i guess a complication is how ghci reads from the keyboard. if a program would be (say) forking and using readline, that would interfere with the ^C obviously ...
18:33:19 <kmc> in GHCi it's a "GhcException"
18:33:30 <c_wraith>       interrupt_exn = (toException Interrupted)
18:33:38 <kmc> either (\(SomeException e) -> show $ typeOf e) id <$> try (threadDelay 1000000 >> return "foo")
18:33:46 <c_wraith> so, yeah.  toException results in a GhcException?
18:33:58 <Dashkal> kmc: Thanks for the help with my interpreter project over the weekend.  I got a working prototype up :)
18:34:03 <kmc> awesome Dashkal :)
18:34:06 <monochrom> oh ha ok
18:34:47 <ddarius> c_wraith beat me
18:35:00 <ddarius> Er kmc
18:35:12 * ddarius just used forever (return ())
18:36:11 <kmc> (it is sometimes useful that SomeException is not abstract)
18:36:26 <ddarius> It's not supposed to be abstract.
18:36:41 <kmc> yeah
18:37:28 <Dashkal> Is there an example somewhere of an mtl-style monad transformer that's actually a stack of other transformers?  I'd like to make my interpreter a transformer so I can stack it on Identity or IO depending on need.
18:42:17 <kmc> Dashkal, i tried to write you an example and hit a GHC bug :O
18:42:30 <Dashkal> Nice!
18:42:37 <c_wraith> did you make ghc's brain explode?
18:42:43 <kmc> the impossible happened
18:42:48 <Dashkal> The only idea I have so far is to make a state-style transformer that holds the stack over identity as its state.
18:42:53 <ddarius> > 75 * 5 / 16
18:42:54 <lambdabot>   23.4375
18:43:12 <ddarius> > 75 * 3 / 16
18:43:14 <lambdabot>   14.0625
18:43:33 <ddarius> 75 - 28
18:43:39 <ddarius> > 75 - 28
18:43:40 <lambdabot>   47
18:43:52 <BMeph> Dashkal: RWS (is that the right order?) should "help" you out... ;)
18:45:19 <dafis> BMeph, yes it's the right order: Real World Stack
18:46:34 <Dashkal> O.o
18:46:36 <kmc> Dashkal, going to rewrite the example without GHC extensions
18:46:51 <kmc> RWS isn't actually *implemented* as ReaderT . WriterT . StateT is it?
18:47:19 <monochrom> RWS is not implemented as a stack
18:47:33 <monochrom> newtype RWS r w s a = RWS { runRWS :: r -> s -> (a, s, w) }  from source code
18:48:27 <monochrom> But this shouldn't stop you from writing your interpreter as a transformer. Afterall both parsec 3 and hint are like that, just transformers.
18:48:58 <monochrom> And so I can't see the connection between "Is there an example somewhere of an mtl-style monad transformer that's actually a stack of other transformers?" and "I'd like to make my interpreter a transformer so I can stack it on Identity or IO depending on need."
18:49:28 <BMeph> Does anyone on know how to get to Urban Boquist's thesis paper? It seems Chalmers has recently reorganized their site... :\
18:49:37 <monochrom> Without the former you can still just go ahead do the latter. And the former doesn't exemplify the latter anyway.
18:49:54 <Dashkal> monochrom: The connection is my interpreter is implemented as a transformer stack.
18:50:36 <monochrom> I'm sorry I can only read what is actually written.
18:52:21 <monochrom> There is a recent paper doing exactly that, an interpreter being a stack of several transformers, one transformer per feature.
18:52:27 <Dashkal> monochrom: Apologies.  More context would be good.  I've written a simple functional language using a stack of transformers (StateT over ErrorT over ID).  I'd like to omit the ID on the bottom and allow consumers of this code to place whatever monad suits them down there.  In this way I could expose some actions that allow the base monad to peek through.  Or in english: allow IO actions, but only if the stack is built with IO underneath.
18:52:51 <ddarius> BMeph: I could email you a copy.
18:54:21 <BMeph> darius: That would not offend me...
18:54:27 <kmc> Dashkal, something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=26646#a26646
18:54:44 <kmc> Dashkal, two notes about this code
18:55:12 <kmc> 1) the instances as you can see are quite boilerplatey; you could use GHC's GeneralizedNewtypeDeriving to derive them, but then you're in the territory of nonstandard Haskell and (apparently) some bugs as of 6.12.1
18:55:54 <kmc> 2) you could also write (or derive per (1)) instances for MonadState, MonadError, etc.  this is an API design question of what you want to expose to users.  personally i like to hide stacks like this and only expose a few domain-specific primitive actions
18:56:15 <Dashkal> kmc: That's absolutely perfect.
18:56:44 <kmc> e.g., i've used a stack like this for outputting machine code; i expose a primitive action for each instruction to output.  the user doesn't think about states and errors; the state is implicitly accumulating instructions, and the error is implicit when you have e.g. bad operands
18:57:02 <kmc> (maybe i could have used Writer instead of State, though i think i had a fresh-names action as well)
18:57:05 <kmc> Dashkal, :)
18:57:28 <Dashkal> I'm envisioning three base monads in practical use.  ID for a self-contained interpreter a -> b, IO for something that can intereact with the real world, and State a for custom "world" state.
18:57:54 <kmc> if you are interpreting a typical imperative language then ST is also a nice base monad
18:58:04 <Dashkal> ST I need to learn
18:58:28 <Dashkal> My pet language is functional.  non-imerative (so far, monads are coming in a later revision)
18:58:31 <kmc> you know about IORef?
18:59:13 <Dashkal> I knew of it.  *hoogle* ahh, mutable variable.  I've always used State for that purpose.
18:59:24 <kmc> State isn't giving you "real" mutable variables, though
18:59:29 <kmc> it's just sugar for pure functional state-passing
18:59:37 <Dashkal> I've yet to have a case where it mattered
18:59:37 <kmc> IO and ST have real mutable reference cells
18:59:53 <kmc> ST is like a restricted version of IO where you *only* get mutable cells, and not actual IO
19:00:19 <kmc> and in return you get a function essentially «ST a -> a»
19:00:46 <kmc> (except its real type is more complicated because it needs to enforce certain isolation properties)
19:01:00 <Dashkal> Safely and without having to use that oh so lovely backdoor.
19:02:19 <kmc> yeah
19:02:47 <kmc> GHC's implementation of runST and unsafePerformIO are nearly the same
19:03:26 <kmc> the safety-checking in ST is all compile-time, in the type system
19:03:47 <pastorn> wait
19:03:59 <pastorn> oh
19:04:02 * pastorn read it wrong
19:05:12 <pastorn> Dashkal: if you ever write something with GLUT you'll need IORefs
19:05:13 <Dashkal> That reminds me.  For the purpose of understanding purity better, I've been pondering a way to use unsafePerformIO to present a pure interface to a real random number generator backed by /dev/random
19:05:17 <pastorn> since it's callback-based
19:05:41 <kmc> Dashkal, that's dodgy
19:05:48 <pastorn> you want one variable that can change when some io function is called, then have a new value for another io function
19:05:56 <pastorn> (think controller reading / redrawing)
19:06:11 <Dashkal> kmc: I know it is.  That's kind of the point.  If I can do it, and do it correctly, I've got a handle on function purity.
19:06:30 <kmc> i don't think there's a way to usefully involve functions here
19:06:44 <kmc> where do you have a deterministic relationship between input and output?
19:07:27 <Dashkal> ok, random is basically s -> (s', r) right?  If s is opaque, I can do some magic behind the scenes.
19:07:53 <kmc> what if someone copies that state and calls random twice with the same state?
19:08:00 <kmc> you have to be able to produce the same value twice
19:08:20 <Dashkal> how about if s is actually r in disguise
19:08:41 <Dashkal> and s' is the next random number drawn from outside
19:09:11 <kmc> then i pass you the same s and you come up with two different s'
19:09:18 <Dashkal> Actually, I'd want to draw two ahead to be sure s' is always the same for a given s
19:09:39 <Dashkal> and store s' in an IORef or the like
19:09:40 <kmc> then i'll remember two ahead ;P
19:09:51 <kmc> or one million
19:10:00 <Dashkal> The idea is the internal state always draws one ahead of what it's given to the caller
19:10:07 <kmc> i can generate a random number, generate a thousand more, then ask for the second number again
19:10:10 <Dashkal> it has, not it is
19:10:44 <kmc> imo the way to present a pure interface to /dev/random would be a lazy infinite list
19:10:55 <Dashkal> Oh yeah, that's why I wanted to ask that question.  Is there such a thing as a Java WeakReference in haskell?  A reference that invalidates itself when its target is GCd
19:11:11 <kmc> Dashkal, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Mem-Weak.html
19:11:12 <ddarius> Dashkal: In GHC, yes.
19:11:18 <kmc> non-portable
19:11:34 <Dashkal> Use those to hold onto past state values returned.
19:11:40 <Dashkal> Though I like the lazy list better...
19:11:46 <kmc> hmm, that's an interesting idea
19:11:52 <Dashkal> Since you get the same effect
19:11:58 <kmc> yeah, and it's not a function
19:12:03 <kmc> it's only as much of a lie as lazy IO
19:12:07 <kmc> which is still a lie but hey
19:12:30 <pastorn> this sounds like DiffArrays...
19:12:31 <Dashkal> It's a lie, but not one you can get caugh at easily.  Since anything returned is remembered.
19:30:33 <int80_h> I'm trying to install happstack-hamlet, as part of the development version of happstack. It breaks and complains couldn't find Text.Hamlet.Monad. Could someone help me troubleshoot this?
19:31:31 <int80_h> I used the directions from here http://happstack.com/download
19:32:59 <dafis> seems Text.Hamlet.Monad was removed in the 0.3 branch, --constraint="hamlet < 0.3"
19:33:18 <dafis> (as a cabal install flag, that is)
19:34:30 <int80_h> michael@michael:~$ cabal install --contraint="hamlet < 0.3" happstack-hamlet
19:34:30 <int80_h> unrecognized option `--contraint=hamlet < 0.3'
19:35:07 <int80_h> dafis could you advise me on the correct syntax?
19:35:36 <dafis> typo: constraint, with an s
19:36:25 <int80_h> thanks :)
19:36:33 <dafis> de rien
19:52:53 <int80_h> trying to install happstack tutorial and it breaks with the following error: happstack-helpers-0.51 failed during the building phase. 
19:53:17 <int80_h> coudl someone advise? I found mention of this, but nothing pertaining to my situation.
19:54:09 <sshc> Is "foldl" (the non-strict) version ever useful?
19:54:29 <ddarius> sshc: Not really.
19:54:49 <c_wraith> I've used it in cases where it doesn't hurt...
19:54:58 <c_wraith> usually in template haskell code
19:55:09 <int80_h> here's a better error message
19:55:13 <int80_h> Happstack/Data/IxSet/Helpers.hs:13:28: `Indexable' is applied to too many type arguments
19:55:22 <c_wraith> foldl AppE funE [arg1E, arg2E, arg3E], for instance
19:56:06 <c_wraith> since it's building a data structure of linear size anyway, there's no real difference
19:56:13 <alexyk> c_wraith: what is TH, in 5 words? :)
19:56:14 <lambdabot> alexyk: You have 1 new message. '/msg lambdabot @messages' to read it.
19:56:40 <c_wraith> alexyk: compile-time execution to build haskell code
19:56:46 <c_wraith> 6 words, sorry
19:56:59 <alexyk> c_wraith: to doesn't count
19:57:00 <c_wraith> or 7.  maybe I can't count.
19:57:33 <alexyk> c_wraith: "haskell code" is haskell source? it's a preprocessor?
19:57:45 <c_wraith> it's actually the haskell AST
19:57:58 <c_wraith> but yes, it's essentially a preprocessor
19:58:12 <alexyk> ah ok.  macro envy-driven?
19:58:21 <alexyk> or camlp4?
19:59:25 <dons> yow
19:59:52 <dons> how's things, alexyk ?
20:00:17 <c_wraith> It's useful for building things where a generic type isn't easy in the haskell type system, but the code is entirely mechanical anyway.
20:00:29 <alexyk> dons: swell, preparing the fundata1 shootout for the world.
20:00:53 <alexyk> dons: if you want to speed up the Haskell of it, would be great!
20:00:56 <dons> nice. what do the current benchmarks look like?
20:01:10 <dons> i had a poke around husky today, and there's a few things we can do
20:01:19 <dons> but i'm more pondering diving into fixing up containers in general
20:01:37 <dons> but i couldn't tell if i was looking at old code. or up to date stuff
20:01:39 <alexyk> so far it's still crashing before disinterning the result.  Currently Haskell is behind OCaml a bit, not by much.
20:01:47 <dons> mmm
20:01:52 <alexyk> So disinterning had to be done in a separate stage
20:02:01 <dons> has that been reported?
20:02:09 <alexyk> and interning is a preprocessing stage.
20:02:42 <alexyk> dons: crashing as in not respecting -M and killing my box which has too little swap.  Not a bug like GC before I think.
20:03:10 <alexyk> dons: I'll report some things and questions to the ghc list after I post the shootout
20:03:34 <alexyk> dons: the main thing, I can develop this in haskell too
20:03:45 <dons> ah right. but too much memory
20:04:19 <alexyk> dons: I'm sure I'm missing some leaks and it's suboptimal Haskell, so hope folks step up to make it better
20:04:23 <dons> we can beat ocaml, at least that's what the shootout shows. on your Float and Int fields, are you making them strict, and using -funbox-strict-fields ?
20:04:32 <dons> yeah. that's certain.
20:04:39 <dons> (people love to hack on these!)
20:04:48 <alexyk> dons: I make something strict, but not using that -f
20:05:04 <dons> ah, it will change the fields to unpacked ones, making them a bit faster.
20:05:09 <alexyk> I also realied I should have used Double perhaps or keep things Rational
20:05:12 <ddarius> And saving some memory...
20:05:18 <dons> Double# or Float# vs Float
20:05:40 <dons> alexyk: like this, http://stackoverflow.com/questions/3115540/haskell-math-performance-on-multiply-add-operation/3134481#3134481
20:05:47 <dons> see the Vec4 type
20:05:51 <dons> its a 4-double vector
20:07:03 <alexyk> interesting -- but I need a strict IntMap then.  My values hang in the values of it
20:07:11 <dolio> > deleteBy (>=) 5 [1..10]
20:07:12 <lambdabot>   [2,3,4,5,6,7,8,9,10]
20:07:18 <dons> alexyk: oh, the compiler does that for you
20:07:19 <dafis> alexyk: say, what do I need to download to investigate the disinterning?
20:07:20 <dolio> > deleteBy (<=) 5 [1..10]
20:07:21 <lambdabot>   [1,2,3,4,6,7,8,9,10]
20:07:42 <dafis> I'd prefer it if you could make a downloadable bundle
20:08:07 <alexyk> dafis: hi!  so mapfold is obtained from github as follows, after you cloned teh repo:  git fetch origin; git checkout -t origin/mapfold
20:08:28 <alexyk> dafis: I'll merge mapfold into master soon, so it will be the master and default checkout from git
20:08:38 <dafis> alexyk, tried cloning, got fatal: http://github.com/alexy/husky/tree/mapfold/info/refs not found: did you run git update-server-info on the server
20:09:05 <alexyk> dafis: nasty, let me see
20:09:15 <dafis> alexyk: I don't know how git works
20:09:19 <dafis> not a bit
20:09:28 <dafis> I'm a darcs guy :)
20:09:54 <alexyk> dafis: I ind of use the basics of it; I used to use darcs too :)
20:10:01 <alexyk> but github changed things
20:10:16 <alexyk> of course there's patch-tag.com...
20:10:47 <dons> dafis: darcs get == git clone; darcs pull == git pull. everything else breaks.
20:11:30 <dafis> dons: except darcs get usually works, with git clone I often get the above fatal
20:11:37 <alexyk> dafis: what did you try to clone?  it should have been: git clone git://github.com/alexy/husky
20:11:56 <alexyk> then do as above, it'll create a branch mapfold locally and place you there
20:12:08 <alexyk> then git pull # gets the updates for it
20:12:25 <dafis> alexyk: Oh, I had tree/mapfold in the url 'cause I thought I wanted mapfold
20:12:41 <alexyk> dafis: no, that's done after you clone the repo
20:13:18 <alexyk> the repo contains all branches, which are cheap as they are not directories as in darcs; there can be thousands of them
20:13:45 <dafis> cloning now
20:13:49 * alexyk is sitting outside in the NH cool with an UFO
20:14:14 * alexyk observes lightbugs descendng
20:14:17 <ddarius> alexyk: Tell them they still owe me five dollars.
20:15:01 <alexyk> ddarius: to the UFO or the bugs?
20:15:31 <alexyk> dafis: may take a bit as it contains the data files
20:16:09 <dafis> alexyk: yes, 45% now
20:16:52 <alexyk> dafis: I should have deleted the str ones :) int.hsb,zip are the ones to use and the dic.hsb.zip dictionary
20:18:55 <dafis> alexyk: git checkout... says: fatal: git checkout: --track and --no-track require -b
20:19:04 <dafis> means what?
20:19:35 <alexyk> dafis: that's after clone went through?
20:19:38 <hexpuem> anyone bored enough to give some advice?
20:20:10 <dafis> alexyk: yes, clone went through, fetch origin didn't complain
20:21:20 <alexyk> dafis what's your git --version say?
20:21:38 <dafis> git version 1.6.0.2
20:22:01 <alexyk> maybe you had to use -b too; try: git checkout -tb origin/mapfold
20:22:28 <alexyk> mine does -b for -t if branch were not present
20:22:37 <dafis> alexyk: $  git checkout -tborigin/mapfold
20:22:38 <dafis> Branch origin/mapfold set up to track local branch refs/heads/master.
20:22:38 <dafis> Switched to a new branch "origin/mapfold"
20:22:42 <dafis> looks good
20:22:48 <alexyk> goodgood
20:23:32 <trebor78> is this haskell nj?
20:23:49 <alexyk> nj like "Jersey Shore"?
20:23:49 <Lajla> trebor78, what is this 'nj' of which you speak?
20:23:50 <monochrom> what is "nj"?
20:23:57 <Lajla> I was first
20:24:02 <alexyk> I was
20:24:07 <trebor78> NJ = New Jersey
20:24:11 <Lajla> Under the laws of the jungle, I get seven of your wives.
20:24:17 <alexyk> yay! go jezee!
20:24:18 <trebor78> I am in haskell, New Jersey
20:24:27 <Lajla> alexyk, I was, give me seven of your wives.
20:24:31 <monochrom> no, this is not haskell nj
20:24:36 <Lajla> trebor78, haskell is a place?
20:24:37 <ddarius> Haskell, TX, sorry.
20:24:45 <trebor78> I used to use MIRC years ago and haven';t for years and just downloaded the program again the other night
20:24:49 <alexyk> Lajla: your IRC sequencing suffers delusions
20:24:51 <monochrom> haskell org
20:24:57 <Lajla> trebor78, this channel is devoted to a very bad programming languages invented to hate me and haunt me.
20:25:13 <trebor78> Im trying to feel my way through it
20:25:14 <Lajla> trebor78, you should use a client that makes you look cool.
20:25:20 <Lajla> Like Irssi or Xchat
20:25:24 <trebor78> I used to be pretty good at it but I've forgotten
20:25:26 <alexyk> Haskell is the official bird of New Jersey
20:25:36 <alexyk> it east out idiots' brains
20:25:38 <alexyk> eats
20:25:40 <Lajla> Haskell was a guy with a strange forename.
20:25:49 <Lajla> Just like Cluster Lizards.
20:25:57 <Lajla> But he did kill the Gigashadow
20:26:30 <alexyk> Haskell is all about hot babes on the beach
20:26:34 <trebor78> everyone here is from texas?
20:26:39 <dafis> alexyk: but I can't find any of the disinterning stuff, and data/sample contains only the two .bin.zip files???
20:26:43 <alexyk> with their monads
20:26:47 <monochrom> I am from org.
20:26:55 <Lajla> trebor78, yes, if we were not typing, you'd hear our bad accents.
20:26:56 <alexyk> dafis: let me check
20:26:58 <tensorpudding> oh crap, lexx, I didn't think anyone ever watched that show
20:27:07 <Lajla> We all voted for Bush, because he's one of the cool guys, and he wants to bring slavery back, we like that.
20:27:48 <trebor78> I love bush
20:28:01 <trebor78> I met him just before he got out of office
20:28:03 <kmc> posting in this high quality thread
20:28:11 <trebor78> I sat and had breakfast with him
20:28:19 <tensorpudding> it must be trolling tuesday
20:28:34 <alexyk> dafis: should be there: http://github.com/alexy/husky/tree/mapfold/data/sample/
20:28:38 <trebor78> I am former Marine and was invited to the USS intrepid to have breakfast with him on veterans day
20:28:59 <trebor78> I am a vietnam vet
20:29:04 <trebor78> combat decorated
20:29:14 <dons> you guys have any Haskell questions?
20:29:16 <trebor78> honorable discharge.....I'm 55
20:29:22 <dons> we try to stay on topic here.
20:29:27 <alexyk> monochrom: did you grow up in org?  how far's com from there?
20:29:31 <dafis> alexyk: only there's no tree directory :(
20:29:50 <alexyk> dafis: tree is github's artefact
20:30:00 <tensorpudding> we go offtopic a lot but we keep it pertinent to computer science, mathematics, the state of software, or insulting C++
20:30:02 <alexyk> dafis: what does git branch # say?
20:30:37 <alexyk> monochrom: I grew up in .ru and flew to .edu, then worked in .com
20:30:53 <alexyk> (a bio sketch)
20:30:56 <dafis> $  git branch #
20:30:56 <dafis>   master
20:30:56 <dafis> * origin/mapfold
20:31:01 <Lajla> trebor78, don't you love the smell of napalm in the morning?
20:31:07 <alexyk> sorry it's comment :)
20:31:17 <alexyk> dafis: hmm interesting
20:31:29 <Lajla> > map ord "string"
20:31:31 <lambdabot>   [115,116,114,105,110,103]
20:31:47 <alexyk> dafis: what happens if you do: git pull origin mapfold
20:32:06 <trebor78> I can see I am in the wrong place and don't fit in
20:32:06 <Lajla> ord 'c'
20:32:09 <Lajla> > ord 'c'
20:32:10 <lambdabot>   99
20:32:10 <trebor78> sorry to bother
20:32:19 <Lajla> trebor78, we are all racist tuckers here.
20:32:21 <Lajla> Don't get us wrong.
20:32:30 <alexyk> trebor78: no prob, we all like Bush and NJ, thanks for the nostalgia
20:32:44 <monochrom> Lajla: please don't make it worse
20:33:01 <alexyk> Lajla: you owe this channel 69 woves
20:33:02 <dafis> alexyk: pulls in a lot of stuff and now it's here
20:33:03 <alexyk> wives
20:33:08 <alexyk> dafis: good
20:33:17 <Lajla> monochrom, pardon my prima facie lack of appreciation and insight into social conventions.
20:33:32 <Lajla> alexyk, I do?
20:33:37 <alexyk> Lajla: yeah.  Social grace is sine qua non for advanced Haskellers.
20:33:44 <Lajla> I still haven't received my wifes, do you use American Express?
20:34:00 <Lajla> Without what not?
20:34:01 <dafis> alexyk: 'kay seems I can start investigating :)
20:34:04 <alexyk> Lajla: ok, 62 then.
20:34:14 <Lajla> alexyk, what is this latin proverb you quoted.
20:34:25 <alexyk> dafis: cool!  I'm being bitten by mosquitoes and will go inside soon
20:34:36 <alexyk> Lajla: means you gotta watch it
20:35:01 <alexyk> or something
20:35:01 <Lajla> Or should I say: QVOD EST HOC LATINVM PROVERBVM QVOD DICIS.
20:35:36 <Lajla> Latin kind of looks like COBOL code, in a way.
20:35:53 <dafis> Lajla: much more concise
20:35:58 <dafis> and modern
20:36:01 <alexyk> Lajla: what you wrote means, in English, "No standard web pages containing all your search terms were found."
20:36:03 <Lajla> Ahaha
20:36:19 <Lajla> alexyk, could be that none has them all.
20:36:49 <alexyk> "... or, as Romans say, "no results found; try again" :)
20:36:51 <Lajla> It's fairly rudimentary, it says 'What is this latin proverb that [you] say'
20:36:57 <Lajla> Literally
20:36:59 <alexyk> ah ok
20:37:08 <alexyk> Romans liked to shout
20:37:18 <Lajla> Maybe I should've used dicebas, we shall never know.
20:38:13 <alexyk> ok, later guys!  My thoughts will be in NJ with Bush programming Haskellz
20:38:42 <Lajla> alexyk, well, homini sapienti est non suidefenestrare sed in manus urinare.
20:39:00 <alexyk> Lajla: hope it's posix-compliant sed
20:39:32 <Lajla> alexyk, it means 'Smart people shouldn't jump out of windows, rather, they should urinate into their own hands'
20:39:41 <Lajla> It's kind of poetic, don't you think?
20:40:01 <alexyk> kk, later :)
21:01:55 <gilbertleung> hi
21:02:09 <gilbertleung> i'm getting a compile error similar to the following
21:02:30 <gilbertleung> "Couldn't matc expected type `ReaderT' against inferred type `mtl-1.1.0.2:Control.Monad.Reader.ReaderT'
21:02:35 <gilbertleung> *match
21:03:11 <acowley> mtl vs transformers?
21:03:13 <gilbertleung> where the latter type is used in another library, and the "ReaderT" is imported by me
21:03:29 <acowley> can you import from another package?
21:03:29 <gilbertleung> acowley: can you elaborate?
21:03:40 <dons> mmm multiple packages, my guess.
21:03:45 <acowley> Multiple packages export the same names
21:03:53 <acowley> So you want to use PackageImports
21:03:53 <gilbertleung> okay
21:04:08 <kmc> you probably want to build with cabal, and use it to specify what packages to use
21:04:14 <kmc> PackageImports isn't for general consumption
21:04:22 <kmc> it will work though
21:04:27 <acowley> kmc: It makes life tolerable :)
21:04:47 <gilbertleung> what'r PackageImports ?
21:05:34 <gilbertleung> googling... looking at extension descripiton...
21:07:44 <acowley> So you can have things like: import "monads-fd" Control.Monad.State
21:08:08 <acowley> To specify the package to get a module from, as an extra specification beyond the hierarchical name
21:08:34 <gilbertleung> okay
21:08:39 <gilbertleung> i think i get it
21:08:40 <gilbertleung> thanks guy
21:08:42 <gilbertleung> *thanks guys
21:09:51 <Katovatzschyn> Does any know a function that takes a list and randomly re-arranges its elements?
21:11:20 <pizza_> Katovatzschyn: http://en.literateprograms.org/Fisher-Yates_shuffle_(Haskell)
21:11:35 <Katovatzschyn> Thank you pizza_
21:12:28 <c_wraith> Uh, that link is sure misleading.
21:12:39 <c_wraith> It says the algorithm is O(n), but that implementation is O(n^2)
21:13:11 <pizza_> can't vouch for the implementation, just the algorithm
21:13:39 <c_wraith> implementations that use ST can be O(n).  The best I've seen without mutable state is O(n * log n)
21:14:47 <kmc> @google oleg perfect shuffle
21:14:48 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
21:15:08 <dons> its on hackage.
21:35:11 <ManateeLazyCat> Have a function output warning information in "String -> String" and don't like 'error' crash program?
21:37:20 <ManateeLazyCat> unsafePerformIO . putStrLn?
21:37:24 <acowley> trace?
21:38:08 <ManateeLazyCat> @hoogle trace
21:38:09 <lambdabot> Debug.Trace trace :: String -> a -> a
21:38:09 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
21:38:09 <lambdabot> module Debug.Trace
21:40:26 <ManateeLazyCat> :> traceShow "Debug info : ... bla..." 10 
21:40:36 <ManateeLazyCat> > traceShow "Debug info : ... bla..." 10 
21:40:37 <lambdabot>   Not in scope: `traceShow'
21:40:45 <ManateeLazyCat> :m Debug.Trace
21:41:03 * ManateeLazyCat Don't know how to play lambdabot.
21:41:41 <ManateeLazyCat> acowley: Thanks, i will try use traceShow fix my problem.
21:41:49 <Veinor> I don't think you can pull stuff in through lambdabot
21:42:30 <acowley> np
21:52:25 <dafis> dons: have you a few minutes time?
21:53:13 <kmc> so DDC is adopting the custom LLVM output code from GHC, at the same time that GHC is trying to ditch it for the standard llvm package?
21:53:14 <kmc> what a country
21:53:41 <ddarius> Which country?
21:53:46 <kmc> any
21:53:57 <kmc> it's metaphorical
21:54:21 <kmc> anyway i guess it is nice when old code finds a new use
21:54:27 <kmc> like uucp being used to run sneakernets in the 3rd world
21:55:54 <dons> dafis: tomorrow, not right now. you can email me stuff.
21:56:11 <dafis> dons: okay
21:56:12 <p_l|backup> kmc: sneakernets are still wildly underestimated by many
21:57:11 <kmc> yes, they can have very high bandwidth at very low infrastructure cost
21:58:51 <Dashkal> Bleh, I keep running into situations where I want to name a data type and a class the same.
21:58:52 * p_l|backup remembers an example problem in some book that required you to evaluate the bandwidth efficiency of a network link and a St.Bernard with tapes
21:59:16 <Dashkal> I'm playing with ExistentialQuantification and I run into that situation when I name the container and the class of types that it'll hold
21:59:44 <dafis> Dashkal: name the type AnyFoo ?
21:59:54 <kmc> AnyFoo and SomeFoo are popular conventions
22:00:04 <kmc> what are you using existentials for?
22:00:15 <Dashkal> Defining the type system for Fadescript
22:01:01 <Dashkal> I need to hold a value of some type.  The actual haskell value is any instance of the type class FSValue
22:01:16 <Dashkal> the value holder holds onto a FSType object and the value
22:01:41 <kmc> Dashkal, did you read http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ by the way?
22:01:55 <Dashkal> I have not.  Reading
22:03:01 <kmc> Dashkal, most simple interpreters describe values using a simple sum type, not a hierarchy of classes and existentials
22:03:12 <kmc> e.g. data Val = VInt Int | VBool Bool | VFun (Val -> Val) | ...
22:03:33 <ddarius> "What is it Lassie?  Timmy says SYN?"
22:03:35 <Dashkal> That's how I did my first revision
22:03:40 <kmc> existentials are useful for implementing *open* sums, which other modules can add new stuff to
22:03:45 <kmc> that's how Control.Exception uses it
22:03:52 <Dashkal> And I quickly ran into kludge code where some operator was defined for only some of the types
22:04:18 <Saizan> GADTs can solve that
22:04:32 <kmc> that can be a problem; i'm not sure how existentials make it better
22:04:44 <blackdog> i just got asked "what's a good book on functions?" and was momentarily struck dumb
22:04:44 <Saizan> but then you'd end up using existentials for when you don't care about the type
22:05:07 <kmc> the problem of cleanly lifting Haskell operators into an object language with dynamic types is something i've struggled with for a while
22:05:09 <Dashkal> operatorPlus (IntValue i) (IntValue i) = return IntValue (i + i) / operatorPlus _ _ = throwException $ TypeError "integer"
22:05:12 <blackdog> it's a really big topic:)
22:05:27 <Saizan> i suspect your typeclass might be encoding a GADT, like oleg's tagless final technique
22:05:33 <Dashkal> I'm actually walking away from dynamic types into static types with inference
22:05:48 <kmc> Dashkal, then maybe you can manifest those static types in a GADT
22:05:58 <Dashkal> could you expand that acrynomn?
22:06:02 <kmc> Dashkal, but anyway, there are ways to lift those operators with less boilerplate
22:06:06 <kmc> generalized algebraic data type
22:06:09 <Dashkal> danke
22:06:14 <kmc> if you want to read about them, the acronym will be a more useful search keyword
22:06:25 <Dashkal> kmc: Actually, I did write some lifting functions for that purpose
22:07:02 * BMeph thinks that anti-pattern should get a new name: Existench-alls, for their bad code smell! >:\
22:07:24 <Dashkal> The kludge in my eyes was the fact that the argument types were defined at evaluation time.  I want them defined at parse time
22:07:26 * Saizan really doesn't see the fuss about existentials
22:08:09 <Dashkal> and yes, the open sum was intentional.  My java roots are showing
22:08:09 <kmc> Dashkal, then you want to parse typed syntax into a GADT
22:08:29 <ddarius> BMeph: Existentials can be used for good as well as evil.
22:08:39 <Dashkal> I'm quite happy with consumers of this code being able to define new types.
22:09:29 <Dashkal> In this way the game that'll make use of it can have type safety in the various objects it will make available (I don't want players being compared with hitpoints)
22:09:47 <Saizan> Dashkal: http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html <- an example of gadts for representing a language
22:10:27 <Saizan> ah, if you want that flexibility then stick to typeclasses .)
22:10:37 <BMeph> ddarius: Yes, they..."can". But I don't blame them for how they're abused, I just want to clean up after the disaster strikes...
22:11:25 <Saizan> BMeph: do you have an example of such disasters?
22:11:42 <kmc> Dashkal, i think the tricky part of allowing consumer code to add new primitive types is in how you allow it to extend your parser, evaluator, etc.
22:11:47 <kmc> there has been some work in e.g. extensible attribute grammars
22:11:52 <kmc> but it's pretty difficult to do right
22:11:58 * Dashkal nods
22:12:07 <Saizan> Dashkal: if i'm guessing correctly you're doing something much like this http://okmij.org/ftp/tagless-final/course/ , so maybe you can find something interesting there.
22:12:15 * BMeph goes back to reading the "Abstract Types Have Existential Type" paper...
22:12:17 <Dashkal> I'm definitely realizing it's hard to do right.  Revision 2 won't be any more correct than my first.  But it'll be closer
22:12:31 <kmc> i would rather define the language with a fixed, small but general set of types built in
22:12:50 <ddarius> {Dynamic} done.
22:12:52 <kmc> which could still look like defining new types within the language
22:12:59 <Dashkal> I've already done that :P
22:13:22 <kmc> ok
22:13:30 <kmc> but you want users to be able to add new primitive types as well?
22:13:36 <kmc> and new semantics?
22:14:12 <Dashkal> Distinct external types and external provided functions to operate on them
22:14:25 <Dashkal> No new language constructs for contributed types
22:14:44 <kmc> ok
22:14:53 <kmc> that makes things easier, anyway
22:14:53 <dskippy> If I want to make a new type, say "type Hand = [Card]" and then use the GHC extension to all me to create an instance of Ord for Hand, how do I get around the fact that this creates, now, multiple instances of Ord for [Card] ? Should I just uses data instead of type at that point? Just wondering if there's a simpler solution.
22:14:58 <kmc> Dynamic would be the easy way out
22:15:03 <kmc> dskippy, "type" does not create a new type
22:15:11 <kmc> it creates a new, interchangeable name for an existing type
22:15:16 <ManateeLazyCat> dilinger: Use newtype
22:15:20 <kmc> you should use "data" or "newtype" if you want to create a new type
22:15:37 <ManateeLazyCat> dskippy: "type" just alias.
22:16:01 <ManateeLazyCat> dskippy: And you can't do multiple instance for same type, include alias by "type". :)
22:16:11 <Dashkal> dynamic would be, yes.  But I'm not happy with that :P
22:16:23 <ManateeLazyCat> dskippy: Like kmc said, use "data" or "newtype".
22:16:25 <kmc> a hand is not a list of cards.  it's *represented* by a list of cards, yes, but it's conceptually a different thing
22:16:33 <kmc> in Haskell types are not just about specifying representation
22:16:36 <dskippy> Yeah I figured as much.
22:16:38 <dskippy> Thanks.
22:16:41 <kmc> :)
22:16:59 <ddarius> Haskell types do a poor job of specifying representation.
22:17:16 <kmc> yeah
22:17:23 <kmc> they don't at all, if you stick to what's in the spec
22:20:24 <ManateeLazyCat> Have any library convert all other encoding to Unicode?
22:21:24 <kmc> POSIX specifies the C function iconv for this
22:21:37 <kmc> there is a Haskell binding
22:21:53 * ManateeLazyCat pasted "fromUTF" at http://paste2.org/get/896597
22:21:53 <ManateeLazyCat> In gtk2hs, we use 'fromUTF' convert utf-8 to unicode (like above), but fromUTF can't handle other encoding except utf-8.
22:22:11 <kmc> i don't know how to *detect* encoding
22:22:18 <kmc> but once you know the encoding, iconv can convert it to utf8
22:22:27 <ManateeLazyCat> kmc: In Emacs, have library *detect* encoding automatically.
22:24:00 <FunctorSalad> > dpkg -S /usr/bin/chardet                                                                                          
22:24:00 <FunctorSalad> python-chardet: /usr/bin/chardet
22:24:01 <lambdabot>   Not in scope: `dpkg'Not in scope: data constructor `S'Not in scope: `usr'No...
22:24:09 <FunctorSalad> @ kmc 
22:24:23 <FunctorSalad> (one example, anyway)
22:24:48 <ManateeLazyCat> kmc: Now, i just use traceShow replace error at http://paste2.org/get/896597 , for safer convert to unicode. And best way is should be : "detect encoding ==> get source/target encoding ==> do convert"..
22:26:15 * ManateeLazyCat Looking for any library that detect encoding automatically.....
22:26:51 <FunctorSalad> ManateeLazyCat: the one I just pasted ;)
22:27:20 <ManateeLazyCat> FunctorSalad: Interesting.... :)
22:27:39 <FunctorSalad> evidently it works statistically
22:28:31 <ManateeLazyCat> FunctorSalad: IIRC, i know Emacs has a library will detect *many* encoding automatically....
22:29:02 <FunctorSalad> filetype magic does it too to some degree
22:29:09 <FunctorSalad> (the `file' program)
22:29:27 <ManateeLazyCat> kmc: http://farm5.static.flickr.com/4137/4744460827_1c59f5320c_b.jpg has ugly encoding....
22:31:19 <ManateeLazyCat> FunctorSalad: I'm reading the readme of chardet deb package, interested..... 
22:32:01 <ManateeLazyCat> FunctorSalad: Chardet's solution like Emacs's "take a sequence of bytes from unknown character encoding".....
22:34:51 <ManateeLazyCat> We should do Haskell-Chardet ... then we can handle *mix* encoding environment....
22:40:27 <FunctorSalad> the py-chardet is kinda slow, but I don't know whether it's python or sophisticated heuristics...
22:41:16 <ManateeLazyCat> FunctorSalad: Yes, if it's write by C, i will try to binding it, but it write by python... very slow...
22:41:18 <FunctorSalad> the problem can't be solved perfectly, of course
22:41:40 <FunctorSalad> ManateeLazyCat: maybe it could easily be transcribed to hs? ;)
22:41:44 <ManateeLazyCat> FunctorSalad: Yes, no perfect solution for detect encoding.
22:42:03 <ManateeLazyCat> FunctorSalad: Yeah, that's i plan to do....
22:42:36 <ManateeLazyCat> FunctorSalad: Current haskell library not friendly for mix encoding environment....
22:43:12 <ManateeLazyCat> FunctorSalad: Including gio/glib library, current just handle "utf-8 <-> unicode"......
22:43:20 <FunctorSalad> hmm which are your major ones? out of curiosity
22:43:34 <FunctorSalad> one would hope the non-unicode ones are well on the way out ;)
22:43:48 <ManateeLazyCat> FunctorSalad: Haskell/Gtk+ ILE. :)
22:44:01 <FunctorSalad> err, I meant major encodings, sorry
22:44:14 <ManateeLazyCat> FunctorSalad: UTF-8
22:44:35 <FunctorSalad> ah. thought you had more than one "main" one when you said mixed encoding env
22:45:20 <ManateeLazyCat> FunctorSalad: But i will download some book, and some book name use non-utf-8 encoding that confusion my file-manager...
22:47:20 <ManateeLazyCat> FunctorSalad: IMO, automatic detect library is not perfect since it use pick-up some speical "encoding dactylogram" to detect which encoding, but it's will failed sometimes.
22:47:28 <ManateeLazyCat> FunctorSalad: But it's better than nothing... :)
22:48:06 <FunctorSalad> I meant it can't be perfect simply because there are some byte strings which are legal input to more than one decoder ;)
22:48:41 <FunctorSalad> so I reckon you'd approximately calculate which of the decodings is most likely statistically
22:48:58 <FunctorSalad> maybe the libs use your locale for expected char probabilities
22:49:02 <ManateeLazyCat> FunctorSalad: Oh, yes, this is more complicated situation.
22:49:06 <blackdog> http://axisofeval.blogspot.com/2010/06/weekly-notes.html
22:49:33 <blackdog> "as you know, /all/ Haskellers' favourite pastime is to implement an evaluator for the addition of numbers"
22:49:42 <FunctorSalad> btw what's a "dactylogram"? :)
22:49:43 <blackdog> ++ for "number addition gap.
22:50:20 <FunctorSalad> is the byte order mark ("bomb") good or bad btw?
22:50:29 <ManateeLazyCat> FunctorSalad: "encoding dactylogram" mean some *special* character sequence for some encoding.
22:50:42 <ManateeLazyCat> FunctorSalad: Some encoding is design for special language, like gb2312 for Chinese.
22:50:46 <FunctorSalad> (err wait, that one isn't meant to specify the encoding, is it...)
22:50:58 <FunctorSalad> I see
22:51:52 <ManateeLazyCat> FunctorSalad: Because Chinese is unchanged, when we saw a "special character sequence" that just exist in gb2312, then we could detect it's gb2312.
22:52:01 <ManateeLazyCat> FunctorSalad: Much better than *guess*. ;-)
22:52:45 <ManateeLazyCat> FunctorSalad: Yes, encoding is unknown, but Human Language has it's own "dactylogram"... :)
22:53:21 <FunctorSalad> hmm, don't singlebyte encodings like latin-1 use the whole range 0-255? anything would be legal input then, but the dactylogram presumably decodes to some very unlikely sequence in latin-1
22:55:12 <ManateeLazyCat> FunctorSalad: Yes, it's difficult, need *knowledge* to figure out dactylogram, but in principle, it's will give your more exact result....
22:55:35 <c_wraith> I don't think latin-1 contains 256 codepoints.  I'm pretty sure several of them are unused.
22:56:54 * ManateeLazyCat I hope some day I (or someone) will develop we own's "encoding dactylogram detector", it's very useful for editor and file-manager..... 
23:00:01 <ManateeLazyCat> FunctorSalad: BTW, python-chardet is port from firefox ... :)
23:09:11 <Dashkal> Bleh, of course the problem with using Existentials is when I want to derive typeclasses for my AnyValue.  I don't suppose there's syntax I'm unaware of that would let me create two instances of show, one for when the contained value's type implementes show and one for the general case?
23:10:21 <kmc> hmm, very interesting question
23:10:41 <kmc> i can imagine a future extension of Typeable or Dynamic which would do this
23:10:51 <kmc> castToShow :: Dynamic -> Maybe (exists a. (Show a) => a)
23:11:05 <Dashkal> heh, that would be awesome.  oh well.
23:11:19 <Dashkal> Just means my debugging code needs to be smarter
23:11:28 <kmc> would be best if we had first-class classes, and then could reify the whole typeclass namespace
23:11:31 <kmc> anyway
23:11:48 <kmc> you can put your values in records
23:12:08 <kmc> data Value = forall a. Value { vVal :: a, vShow :: Maybe (a -> String) }
23:12:27 <kmc> and when you load them up you know the static type presumably, and can fill in the "type class" methods if they exist
23:13:26 <Dashkal> mmm, that works.  I can stick that in my typeclass as optional methods
23:13:57 <Dashkal> erm, not the typeclass, the value data type and it's constructor functions
23:13:58 <ezyang> Idea: what if you used the type system to enforce that a network protocol is followed correctly by the server and client, and then split up the executables compiled from teh same source base? 
23:14:01 <Dashkal> mkValue, mkShowValue
23:14:19 <ezyang> iirc, there was an OS research paper that did something like this. 
23:14:20 <kmc> ezyang, session types?
23:14:29 <ezyang> kmc: Could be. Looking. 
23:16:51 <kmc> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session-Interleaving.html
23:16:54 <kmc> look at them types
23:18:46 <ezyang> wow, that is fuuugly 
23:19:10 <kmc> i'd like to snark that dependent types would make it sooo much prettier
23:19:18 <kmc> but i honestly don't have the slightest idea what is going on here
23:19:26 <ezyang> kmc: "Ilikely." 
23:19:47 <ezyang> I've got the Gay/Vasconcelos/Ravara paper in front of me; same thing? 
23:20:03 <kmc> i don't know
23:24:18 <Saizan> there's a much simpler session types encoding somewhere
23:25:35 <Saizan> http://www.ccs.neu.edu/home/tov/pubs/haskell-session-types/ <- though maybe you found this while i got disconnected..
23:25:57 * arcatan invokes AbstractFactoryFactory
23:26:24 <blackdog> arcatan: maybe you just need to find the fixpoint.
23:26:44 <ezyang> cool, I'll look at that one. 
23:29:44 <ezyang> "Our embedding takes advantage of Haskell where appropriate, but we rely on no exotic features." I feel... skeptical. 
23:30:33 <Saizan> well, at least when compared to Sackman's one :)
23:31:31 <Saizan> the two papers got submitted to ICFP the same here, so they ended up underlining differences..
23:32:42 <Saizan> iirc "sessions" (the one with more type hackery) supports more use cases
23:33:03 * ezyang nods 
23:33:29 <ezyang> I wonder what it would take to make non-unreasonable type errors for this type of trickery. 
23:33:42 <Saizan> (s/same here/same year/ -- subvocalizing english gets me weird typos)
23:37:36 <ziman> oh my god.
23:38:00 <ziman> those types are... wow :)
23:39:32 * ManateeLazyCat traceShow is good replace for error. Track debug information and don't crash program.... :)
23:41:52 <kmc> ManateeLazyCat, just be aware that your debug information is not printed until the values are actually evaluated
23:42:00 <kmc> which is something Haskell encourages you *not* to think about
23:42:08 <kmc> so it can be pretty subtle
23:42:12 <Liskni_si> does error do anything else?
23:42:18 <ezyang> What do you use for the return type? 
23:42:44 <ezyang> since error :: String -> a 
23:44:04 <kmc> anything else than what?
23:44:44 <ManateeLazyCat> kmc: Yes, sometimes my debug information is far from the *real* place... :)
23:45:18 <ManateeLazyCat> kmc: I always add "function name" in debug information, make it's easier to track... :)
