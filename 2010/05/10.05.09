00:00:01 <Cale> It's more convenient.
00:00:03 <ivanm> Cale: I have it with 0.8.x and with documentation: True in the config file
00:00:07 <FunctorSalad> you need to enable --documentation in ~/.cabal/config
00:00:10 <FunctorSalad> I think
00:00:10 <Cale> ah, hmm
00:00:19 <FunctorSalad> you can also tell it where to put docs there
00:00:34 <FunctorSalad> default is a bit deep into the hierarchy...
00:01:16 <Cale> brb, resetting stupid router
00:01:53 <FunctorSalad> (actually, you need to delete the double hyphen ;))
00:02:12 <FunctorSalad> -- is comment. tricky.
00:02:36 <Cale> Well, that seems sensible enough ;)
00:02:54 <FunctorSalad> for haskell source yes... but for a file containing command-line-options ....
00:03:26 <Cale> Does it really contain commandline options? It looks more like something akin to the .cabal file format
00:04:21 <ivanm> it's variables
00:04:37 <ivanm> I think they use -- for comments because most people using it are haskellers and we're used to -- for inline comments
00:04:45 <Cale> yeah
00:05:00 <FunctorSalad> ivanm: haskell variables?
00:05:14 <FunctorSalad> (corresponding to cabal source)
00:05:15 <ivanm> FunctorSalad: pseudo-haskell, using True, etc.
00:06:10 <FunctorSalad> you might want to just replace 'cabal' with a wrapper script though, since I can't get documentation:True to hyperlink sources
00:06:17 <Cale> It's a little funny that they didn't just go the whole way and make the configuration a .hs file :)
00:06:20 <FunctorSalad> maybe it's fixed now, that was long ago
00:06:44 <FunctorSalad> (a wrapper doing 'cabal haddock --hyperlink-sources')
00:08:02 <FunctorSalad> ivanm: didn't know about the master index either
00:08:19 <ivanm> well, I seem to have one...
00:08:32 <ivanm> Cale: probably because that would make it harder for non-haskellers to use
00:08:54 <FunctorSalad> did you make the haddock dir package-independent to get that?
00:08:55 <ivanm> FunctorSalad: and cabal-install doesn't support hscolour yet because they can't work out the UI for it (in terms of command-line flag, etc.)
00:09:01 <ivanm> nope
00:09:02 <FunctorSalad> I'd think it just clobbers stuff then
00:09:05 <ivanm> it's a default new feature
00:09:09 <FunctorSalad> oooh
00:09:16 <FunctorSalad> shiny
00:09:26 <ivanm> FunctorSalad: yeah, that's basically all it does; hacky script stuff IIRC to combine the various index.html files
00:09:33 <FunctorSalad> ivanm: highlight -Shs is fine too
00:09:56 <FunctorSalad> (just another highlighter)
00:10:11 <ivanm> eh, I've tried highlight's output; it's atrocious
00:10:22 <ivanm> (at least for latex output)
00:10:33 <FunctorSalad> the colour theme can be changed ;)
00:10:33 * hackagebot heaps 0.1 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.1 (EdwardKmett)
00:10:39 <FunctorSalad> vim-dark is ok
00:10:42 <FunctorSalad> for dark
00:10:51 <edwardk> yay hackagebot
00:11:40 <FunctorSalad> ivanm: most themes will happily give you black on black if you have black bg...
00:11:52 <FunctorSalad> not sure if it was that level 'atrocious' ;)
00:11:59 <ivanm> FunctorSalad: not the colour scheme per se
00:12:04 <ivanm> the generated latex code was horrendous
00:12:10 <ivanm> and dind't preserve indentation properly
00:12:31 <ivanm> edwardk: hows your rope stuff going?
00:12:54 <Cale> http://www.youtube.com/watch?v=9AB7yp40fQg :)
00:13:04 <edwardk> ivanm: it is working well enough for its current task =)
00:13:40 <ivanm> edwardk: I'm just wondering how a rope of vectors would work to augment tomberek's FGL instance
00:13:44 <edwardk> i need to go through and refactor the branded version using some tricks i learned by playing similar branding games with graphs for the hnn folks
00:13:47 <FunctorSalad> ivanm: at least it isn't squeamish and panics and dies if there's a wrong character ;) you can highlight strace output with -Sc just fine
00:13:52 <FunctorSalad> (and it helps)
00:14:01 <ivanm> edwardk: *nod*
00:14:04 <edwardk> ivanm: that is pretty much the idea =)
00:14:10 <FunctorSalad> ivanm: didn't even try to reformat stuff
00:14:31 <ivanm> preflex: seen Axman6
00:14:31 <preflex>  Axman6 was last seen on #haskell 16 hours, 54 minutes and 6 seconds ago, saying: righto
00:15:09 <FunctorSalad> (is that fixed in 6.12.2? fatal death on illegal multibyte utf8)
00:15:57 <ivanm> FunctorSalad: oh, that; nope
00:16:43 <ivanm> FunctorSalad: don't know if it happens with the current repo state, but in gentoo there's a problem with criterion: if you build it, ghc will complain that you should use _ <- ... except one of those that have that has a mu character in it, and ghc's error reporting fails because of it :s
00:16:46 <edwardk> can someone else try installing that heaps package so i can stop being paranoid that i uploaded something with a missing file? =)
00:18:03 <ivanm> *sigh* fine
00:18:18 <ivanm> ;-)
00:19:18 <FunctorSalad> real ultimate error. no regeneration.
00:20:08 <ivanm> ugh, it wants to rebuild quickcheck
00:20:25 <FunctorSalad> ivanm: a mu in a latin1 file when in utf8 mode?
00:20:41 <ivanm> FunctorSalad: something like that I think
00:20:42 <arcatan> for me cabal install heaps worked just fine
00:21:03 <FunctorSalad> it's also an issue if you have to read binary data through an interface that doesn't give you the Handle
00:21:15 <FunctorSalad> so it defaults to utf8....
00:21:20 <FunctorSalad> *read or write
00:21:36 <FunctorSalad> like System.Process.rawSystem
00:21:43 <FunctorSalad> (for the parameters)
00:21:51 <FunctorSalad> @ty rawSystem
00:21:52 <lambdabot> Not in scope: `rawSystem'
00:22:49 <FunctorSalad> readProcess :: FilePath -> [String] -> String -> IO String
00:24:34 <ivanm> gah, I wish GHC would stop exposing libraries like bytestring, etc.; maybe use internal forks or something
00:24:51 * dolio rushes to release a library named Heaps.
00:24:59 <ivanm> @slap dolio
00:24:59 * lambdabot pokes dolio in the eye
00:26:39 <ivanm> edwardk: seems to build here
00:33:43 <FunctorSalad> ivanm: c&p? ;)
00:34:03 <ivanm> FunctorSalad: hmmm?
00:34:18 * Cale builds a library named heapS
00:34:32 <FunctorSalad> ivanm: you could rename the current version too (if it's just for local use)
00:35:14 <ivanm> FunctorSalad: the problem is that for things like extensible-exceptions and bytestring which have bugfix releases but cna't be installed as they're boot libraries
00:35:33 <Cale> heh, pollute the hackage namespace with packages named after common misspellings of other package names.
00:35:37 <ivanm> especially for bytestring, since AFAIK it isn't exported through anyting in ghci
00:37:01 <FunctorSalad> ivanm: why would one release sth depending on nonstandard BS (bytestring).... if it makes it de factor ininstallible
00:37:14 <FunctorSalad> (e-e, in this case)
00:37:26 <ivanm> should that be "of"?
00:38:15 <ivanm> FunctorSalad: my point is that bytestring is released with ghc, a bug is found, a fix is made in a point-release.... but we can't install that fixed version since it will cause dependency problems (diamond dependency problem, etc.)
00:39:31 <FunctorSalad> don't see an "of", but "de factor" could lose an 'r'
00:39:43 <FunctorSalad> *a not-yet-"of"
00:40:21 <ivanm> FunctorSalad: oh, does "sth" mean "something" then?
00:41:38 <FunctorSalad> ivanm: yes. that word seems to have a ratio of typing difficulty and frequency urging abbreviation
00:41:53 <ivanm> it does?
00:42:03 <ivanm> I don't have any problems typing it...
00:42:15 <FunctorSalad> *product, not ratio
00:42:31 <FunctorSalad> both are pros, after all
00:42:48 <FunctorSalad> ivanm: I mean speed
00:43:05 <ivanm> hmmmm....
00:44:01 <FunctorSalad> home row->up one-> down two->up two->down->up->down two->up
00:44:36 <ivanm> eh, still don't see the problem
00:44:37 <ivanm> ;-)
00:46:06 <kmc> i don't see the issue, 7 of 9 letters are on the home row
00:46:34 <ivanm> kmc: using dvorak I presume?
00:46:37 <kmc> yeah
00:46:44 <ivanm> show-off ;-)
00:46:52 <kmc> many useful words like "shithead" are entirely on the home row
00:47:28 <ivanm> whereas I can write using just my home row something like "fads" :s
00:48:14 <FunctorSalad> kmc: didn't think I'm *that* clouded yet ;)
00:48:25 <FunctorSalad> (that the sequence I wrote can have 7 letters on home)
00:49:57 <FunctorSalad> while you're at optimizing, shouldn't some best places be reserved for non-self-insert-command keys?
00:51:07 <FunctorSalad> unless you're going to go modal (vim) anyway
00:51:41 <FunctorSalad> modal UIs suck in their own way, but I find the extra keys worth it
00:54:12 <cads> ivanm, do you dvorak?
00:54:24 <ivanm> nope
00:54:32 <FunctorSalad> @botdvorak
00:54:32 <lambdabot> Unknown command, try @list
00:54:41 <ivanm> I've always indented to try, but never got around to it
00:54:56 <ivanm> oh, and using a homophonic keyboard layout then becomes more difficult... >_>
00:55:45 <FunctorSalad> why isn't that closer to botcrack than anything else?
00:55:54 <FunctorSalad> or wasn't that the rule....
00:57:02 <cads> lately I find that often I have to press a few keys to get the right symbol when I'm coding, and sometimes I this even happens to letters, and I've been thinking of getting some keyboard training program, and why not a dvorak training program while I'm at it
00:57:08 <FunctorSalad> @vixen do you know how your command matching procedure works?
00:57:08 <lambdabot> i think i know
00:57:36 <FunctorSalad> @vixen (declarative knowledge)
00:57:38 <lambdabot> love is all you need, you know?
00:57:47 <FunctorSalad> let them eat cake
00:57:48 <cads> ::)D
00:58:23 <cads> @vixen, I don't know about you, but I'm ready for some hot lovin'
00:58:24 <lambdabot> that's okay, i don't know either
00:59:22 <cads> it would be terrible if vixen became a feminist
01:00:25 <Jafet> @. vixen quote
01:00:25 <lambdabot> I define fun
01:06:32 <rajeshsr> :t <$>
01:06:33 <lambdabot> parse error on input `<$>'
01:07:01 <ClaudiusMaximus> :t (<$>)
01:07:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:08:02 <rajeshsr> ClaudiusMaximus, thanks!
01:08:11 <rajeshsr> So what does that actually do?
01:10:30 <kmc> it's an alias for fmap
01:10:34 <rajeshsr> ha, i think i get it! It applies the function after removing the Functor and returns the result with functor applied
01:10:44 <ClaudiusMaximus> > (+1) <$> [1,2,3]
01:10:45 <lambdabot>   [2,3,4]
01:10:53 <Cale> hmm, with documentation: True, and a new haddock, I have a nice documentation tree being generated. I wonder if there's a way to make it not put the version number in the directory path though.
01:10:57 <ClaudiusMaximus> > (+1) <$> Just 42
01:10:58 <lambdabot>   Just 43
01:11:01 <rajeshsr> kmc, ha, ok!
01:11:11 <kmc> rajeshsr, it's the defining function of a Functor
01:11:30 <kmc> and what you say is true conceptually but it's not always possible to actually "remove" the functor wrapping
01:11:49 <DerisionSnort> I am struggling with calculating the average of a list because of Int/Double conversions. The following works, but seems kind of ugly to me. Is there an easier solution?
01:11:49 <DerisionSnort> intToDouble :: Int -> Double
01:11:49 <DerisionSnort> intToDouble a = fromIntegral a
01:11:49 <DerisionSnort> average xs = (intToDouble (sum xs)) / (intToDouble (length xs))
01:11:53 <kmc> e.g. there's no (IO a -> a), but you can still use fmap :: (a -> b) -> (IO a -> IO b)
01:11:58 <kmc> which is part of the usefulness actually
01:12:08 <rajeshsr> kmc, hmm, i don't understand functors much and how distinct they are from monads. So i don't quite get what you mean..
01:12:09 <kmc> DerisionSnort, you might be stuck with that
01:12:20 <kmc> DerisionSnort, except why give it a new name?
01:12:29 <kmc> rajeshsr, every instance of Monad is an instance of Functor
01:12:37 <kmc> (and every monad is a functor, mathematically)
01:12:49 <ClaudiusMaximus> > map length . words $ "intToDouble fromIntegral"
01:12:51 <lambdabot>   [11,12]
01:12:52 <rajeshsr> kmc, ha, ok!
01:13:00 <Cale> Every instance of Monad *should* be an instance of Functor
01:13:03 <rajeshsr> :t ($)
01:13:03 <kmc> some things are functors but not monads
01:13:04 <lambdabot> forall a b. (a -> b) -> a -> b
01:13:07 <DerisionSnort> kmc: Oh, I don't have to specify double, fromIntegral works just fine. Cool!
01:13:08 <kmc> yeah, Cale has a point
01:13:09 <Cale> But if not, then you can consider it a bug
01:13:23 <kmc> @src ($)
01:13:23 <lambdabot> f $ x = f x
01:13:42 <rajeshsr> Cale, ha, ok!
01:14:23 <ClaudiusMaximus> :t \xs -> fromIntegral (sum xs) / fromIntegral (length xs)
01:14:24 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
01:14:42 <rajeshsr> BTW, yesterday i managed to submit Problem A in code jam with haskell! Quite ugly code compared to what Reid came up with!
01:15:48 <rajeshsr> well, in case anyone from yesterday who listened to my problems were there ^! :)
01:15:56 <ClaudiusMaximus> sometimes i let fI = fromIntegral just to save repetitive typing and keep my code shorter
01:16:23 <kmc> yeah
01:16:24 <rajeshsr> ClaudiusMaximus, use a good editor that allows completion for you. May be vim?
01:17:12 <ClaudiusMaximus> rajeshsr: i like to keep most of my code so that i can edit it comfortably in an 80-column term when i break X, too...
01:17:49 <rajeshsr> ClaudiusMaximus, vim can manage that too!
01:18:12 <ClaudiusMaximus> fwiw, i like geany as an editor (apart from the one in Lenny, which is too old to support custom colour themes and the white background hurts my eyes...)
01:19:04 <rajeshsr> ClaudiusMaximus, hmm, cool! I never tried it, but i can't believe it will be as versatile as vim! ;)
01:21:58 <rajeshsr> :t fmap
01:21:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:22:50 <Cale> > let sol n k = testBit (k :: Integer) (n-1) in map (uncurry sol) [(1,0), (1,1), (4,0), (4,47)]
01:22:52 <lambdabot>   [False,True,False,True]
01:23:52 <tomberek> i know because of all the fusion and other effects that it isn't exact, but can we assume that Data.Vector has O(1) indexing?
01:24:13 <rajeshsr> Cale, wow! u in GCJ?
01:24:31 <Cale> rajeshsr: no
01:24:32 <rajeshsr> s/u/you :)
01:24:47 <Cale> (I just looked up the problem)
01:25:34 <rajeshsr> Cale, hmm, ok, Cool!
01:26:08 <rajeshsr> :t testBit
01:26:09 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
01:26:36 <ClaudiusMaximus> hmm, i'm thinking about rewriting 5k lines of C in Haskell so i can add some high-level algorithms, someone stop me
01:26:40 <kmc> gnu compiler for java?
01:26:54 <Cale> > [testBit (5789132 :: Integer) k | k <- [0..20]]
01:26:55 <lambdabot>   [False,False,True,True,False,False,True,True,True,False,True,False,True,Fal...
01:27:07 <Cale> ^^ there's the status of each of the snappers
01:27:49 <Cale> Basically, they just count in binary :)
01:28:34 <dv-> Pff, even apt-get can't install gtk2hs
01:29:03 <tomberek> What do people on here think about Pure?
01:29:09 <Cale> Pure?
01:29:18 <tomberek> yeah
01:29:35 <tomberek> just curious: http://code.google.com/p/pure-lang/
01:30:01 <Cale> Oh, a language. I hadn't heard of it.
01:30:31 <rajeshsr> Cale, Shouldn't we check if last n bits are set? is that your code does?
01:30:38 <ivanm> hey tomberek
01:30:48 <tomberek> hi ivanm.. i got some thoughts
01:30:59 <ivanm> shoot
01:31:25 <tomberek> or at least questions... we know we want a common API for different implementations
01:31:34 <ivanm> right
01:31:51 <tomberek> how will a change in implementation occur?
01:32:09 <ivanm> what do you mean?
01:32:16 <tomberek> IntMapGraph a b -> VectorGraph a b or something?
01:32:26 <ivanm> oh....
01:32:36 <ivanm> I wasn't planning on doing having anything like that
01:32:43 <ivanm> since that'd just be too inefficient
01:33:00 <ivanm> tomberek: the idea is, you choose one implementation and stick with it
01:33:01 <tomberek> or something like fromGraph
01:33:20 <ivanm> e.g. atm you don't switch between Tree and PatriciaTree, do you?
01:33:56 <tomberek> ivanm, no, PatriciaTree is almost always better, but there are times an array version will be better, sometimes worse
01:34:19 <ivanm> tomberek: right; my thinking is that you should pick the best _for your application_ and stick with it
01:34:25 <Cale> rajeshsr: oh, perhaps we should
01:34:46 <ivanm> otherwise, get the lists of Contexts and call makeGr (or whatever it is)
01:34:55 <tomberek> yeah... remake it,, ok
01:34:57 <Cale> That's not much harder
01:35:52 <tomberek> ivanm: what about annotations (edwardk is a fan)
01:35:59 <Cale> > let sol n k = all (testBit (k :: Integer)) [0..n-1] in map (uncurry sol) [(1,0), (1,1), (4,0), (4,47)]
01:36:00 <lambdabot>   [False,True,False,True]
01:36:06 <ivanm> tomberek: what do you mean by "annotations"?
01:36:36 <tomberek> to get a full explanation, he'd have to answer that, but some of his code is here: http://trac.haskell.org/HNN/wiki/CodeDraft
01:37:11 <tomberek> basically, having a way to annotate nodes or edges and have those annotations update as the graph changes
01:37:39 <tomberek> he also branded them so they are typesafe from being used with the wrong graph
01:37:40 <Cale> tomberek: Looking over the documentation, it looks like untyped Haskell (with just slightly uglier syntax)
01:37:51 <Cale> That is, Pure does.
01:38:31 <tomberek> Cale: looks that way, i just came across it myself,
01:38:54 <ivanm> tomberek: that code makes no sense to me (i.e. what it does, what it's meant to represent, etc.)
01:39:47 <tomberek> ivanm: yeah, that's the main detraction.   that it is hard to understand.
01:39:50 <Cale> Oh, and it has built in matrices, and it looks like a bit more support for symbolic computation off the bat.
01:39:51 <ivanm> preflex: seen Axman6
01:39:51 <preflex>  Axman6 was last seen on #haskell 18 hours, 19 minutes and 27 seconds ago, saying: righto
01:40:18 <Cale> Since it only does term rewriting, it can rewrite terms with unbound variables in them.
01:40:21 <ivanm> @tell Axman6 fyi, I'm going to be giving a talk on SourceGraph @ ANU on thursday night
01:40:21 <lambdabot> Consider it noted.
01:40:34 <Cale> So, that's kind of cool.
01:41:11 <tomberek> Cale: it's interesting, there might be interesting ideas found in odd places
01:41:25 <Cale> Oh, also, it isn't pure.
01:41:37 <Cale> Which is pretty funny, given the name.
01:41:40 <ksf> what's up with the wiki?
01:41:42 <ivanm> Cale: lol
01:41:48 <ksf> and why does stuff always break on weekends?
01:41:58 <Cale> You can call arbitrary C functions, and they execute when the evaluator gets to them and reduce to the resulting values.
01:42:06 <ivanm> ksf: because the people who work where the machines are don't work on the weekends
01:42:12 <ivanm> and thus can't fix them if they fall over
01:44:21 <Cale> So it's kind of like, what if we took ML and instead of progressing toward Haskell, we remove the type system, and all the stuff about modules, and make it much more difficult to implement an optimising compiler for it...
01:45:07 <Cale> (by insisting on visible term rewriting)
01:45:25 <rajeshsr> Cale, hmm, that is good!
01:45:53 <rajeshsr> how about writing a full code that prints Case # etc. Just want to know how elegant it can get.
01:45:58 <tomberek> ivanm:MPTC/type families?
01:45:59 <Cale> rajeshsr: sure
01:46:15 <ivanm> tomberek: hmmm?
01:46:32 <rajeshsr> The logic of the code is just this: if k `mod` 2^n == 2^n - 1 then "ON" else "OFF"
01:46:45 <FunctorSalad> Cale: which would be that "brilliant" lang?
01:46:52 <FunctorSalad> ("if we took ML and ...")
01:46:59 <Cale> FunctorSalad: Pure (which isn't pure)
01:47:07 <b0fh_ua> Hello. I am trying to develop some stuff in Haskell, and I currently have several folders with sources in them. What is the best way to compile them all at once, to check the syntax is ok and changes I've made in a module didn't break things in another ones?
01:47:12 <FunctorSalad> Cale: :)
01:47:34 <ivanm> b0fh_ua: are they used together or all separate projects?
01:47:51 <b0fh_ua> ivanm: used together
01:47:51 <ivanm> b0fh_ua: and have you written cabal files for all of your projects?
01:48:05 <b0fh_ua> ivanm: I didn't manage to use cabal for now
01:48:15 <ivanm> b0fh_ua: http://blog.ezyang.com/2010/05/omnipresent-cabal/
01:48:43 <b0fh_ua> ivanm: basically all what I want is to get everything compiled with single command :)
01:48:49 <FunctorSalad> Cale: btw, about homomorphisms... maybe your worries were (rightly) about the fact that extending a function defined on generators to a homo isn't always possible?
01:49:16 <FunctorSalad> Cale: it just always worked in that case because we start out with a homomorphism, restrict it and extend it again
01:49:22 <ivanm> b0fh_ua: well, if directories match up with module names, ghc --make Main.hs
01:50:13 <b0fh_ua> ivanm: they do, but there's no point where all of them are gathered together
01:50:27 <FunctorSalad> otherwise you can't just extend any homomorphism, even on a minimal set of generators... (no monoid homo from Z/2 to Z/3 extends "1 -> 1")
01:50:31 <b0fh_ua> anyway looks like it's worth trying to learn cabal :)
01:50:34 <ivanm> b0fh_ua: then there's no easy way
01:50:38 <b0fh_ua> okay
01:52:03 <tomberek> ivanm: i'm just thinking about what other types of ways we can define the Graph class, perhaps taking advantage of some typing
01:52:17 <dv-> b0fh_ua: ghc --make Main.hs -o Main?
01:52:36 <ivanm> dv-: he already said that it's basically split up arbitrarily
01:53:04 <ivanm> tomberek: yeah, I'm thinking "class Graph g a b" so that the labels are explicit (and making henning happy :p )
01:53:28 <tomberek> pros/cons?
01:53:36 <ivanm> cons: needs an extension
01:54:02 <dv-> ivanm: well if it's one project, make should do it
01:54:18 <ivanm> oh, and will require more ugliness "(Graph g a b) =>" vs "(Graph g) =>"
01:54:29 <ivanm> dv-: it's a whole collection of interrelated projects AFAICT
01:54:46 <FunctorSalad> ivanm: btw I didn't really get what your de-transitivization problem earlier was
01:54:51 <ivanm> pros: lets you limit/restrict the label types to ones that make sense (if you have a need for such a thing)
01:54:51 <FunctorSalad> (what it has to do with types)
01:54:55 <tomberek> that IS uglier,,, what are the pros?
01:55:10 <b0fh_ua> When using cabal, is it possible to find out what are the modules needed to compile my app? From sources, I mean.
01:55:26 <kmc> b0fh_ua, are you using ghc --make ?
01:55:30 <kmc> that's the simple way to build everything
01:55:37 <kmc> 99% of users should always use ghc with --make
01:55:42 <ivanm> FunctorSalad: how to define something that will let me delete/manipulate edges for all instances of this class: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz-Types.html#t%3ADotRepr
01:56:00 <ivanm> b0fh_ua: specify all the modules in a cabal file
01:56:00 <Cale> rajeshsr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25402#a25402
01:56:04 <ivanm> s/a/the/
01:56:10 <Cale> rajeshsr: That's one way
01:56:12 <Jafet> kmc, cabal-install!
01:56:19 <ivanm> you need to do that for packaging purposes as well (so it knows which to include in the tarball)
01:56:31 <kmc> well okay
01:56:35 <kmc> but if you're invoking ghc directly
01:56:40 <kmc> it should almost certainly be with --make
01:56:43 <rajeshsr> Cale, thank you very much!
01:56:45 <ivanm> kmc: he has a few sub-directories whose names don't match hierarchical module names that are all part of the same project
01:56:47 <b0fh_ua> kmc: I am using ghc --make for every file from vim (with haskellmode installed), but that is annoying. I was thinking of creation of simple Makefile to just compile everything and asked here - are there any better way.
01:56:49 <ivanm> i.e. poor planning
01:56:49 <Jafet> It's a wrapper anyway
01:56:53 <ivanm> (AFAICT)
01:57:09 <kmc> b0fh_ua, ghc --make chases dependencies for you
01:57:11 <ivanm> b0fh_ua: you only use --make for the overall program module
01:57:13 <FunctorSalad> ivanm: uh, it has no building methods?
01:57:14 <b0fh_ua> ivanm: you're wrong, directories do match module names :)
01:57:15 <kmc> but only if you arrange your modules correctly
01:57:16 <FunctorSalad> just taking apart
01:57:21 <kmc> which ivanm suggests might be the problem here
01:57:31 <FunctorSalad> or is your issue at hand which builder method to add
01:57:42 <ivanm> FunctorSalad: well, kinda; but I have no idea how I can sanely extend that class to take into account both instances
01:57:52 <ivanm> b0fh_ua: you said they didn't :/
01:58:09 <b0fh_ua> ivanm: sorry, probably I didn't read carefully and gave wrong reply
01:58:14 <ivanm> "they do, but there's no point where all of them are gathered together" <-- implies to me that they aren't all relative to the root
01:58:25 <ivanm> so they're _not_ named properly ;-)
01:58:49 <b0fh_ua> ivanm: no, I meant that there is no single file, which does import (directly or indirectly) all of the modules
01:59:07 <rajeshsr> Cale, wow! That is really elegant!
01:59:15 <b0fh_ua> so I have to compile things file by file
01:59:25 <Cale> rajeshsr: Here's another variation http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25402#a25403
01:59:34 <rajeshsr> Cale, BTW, Do we need that $ in forM_?
01:59:39 <ivanm> b0fh_ua: so it's a library, not an executable?
01:59:43 <FunctorSalad> b0fh_ua: you could *make* a dummy module which imports them all ;)
01:59:45 <b0fh_ua> ivanm: some sort of, yes
01:59:47 <Cale> rajeshsr: Yes, for technical parsing reasons
01:59:53 <FunctorSalad> b0fh_ua: or just use cabal
01:59:57 <ivanm> b0fh_ua: *shrug* write a .cabal file
02:00:05 <ivanm> as I recommended earlier ;-)
02:00:06 <b0fh_ua> FunctorSalad: I thought of doing like this - but it looks ugly :)
02:00:18 <b0fh_ua> ivanm: trying to do so :)
02:00:23 <ivanm> tomberek: anyway, I think the cons are minimal enough not to worry about them
02:00:25 <FunctorSalad> just a bit annoying to add all the deps if it's a trivial script project
02:00:31 <Cale> rajeshsr: actually, the need for that $ has always confused me a bit. You can't use a lambda without parens or a preceding infix operator as a parameter to a function.
02:00:40 <ivanm> as it means we can do stuff directly just considering what the label types are
02:00:46 <rajeshsr> Cale, well, starting a lambda function mean it is function definition till the end, so it is passed as a single parameter?
02:00:47 <FunctorSalad> (hmm... compiler -> parse error -> add to cabal loop? ;))
02:00:51 <Cale> yeah
02:00:56 <b0fh_ua> ivanm: the problem now is I made mistake and didn't record which packages I was used to install
02:01:00 <b0fh_ua> like libcurl etc
02:01:14 <FunctorSalad> b0fh_ua: "cabal init" helps
02:01:20 <b0fh_ua> so is there any way to get list of modules from my sources automatically
02:01:22 <ivanm> b0fh_ua: well, you can by hand check which module each package uses and see which libraries they come from....
02:01:27 <b0fh_ua> FunctorSalad: yup, I did that yet
02:01:32 <ivanm> FunctorSalad: oh? it tracks down dpendencies?
02:01:45 <b0fh_ua> ivanm: oh, that's sad :(
02:01:46 <tomberek> ivanm: ok, so going with class Graph g a b
02:02:00 <FunctorSalad> b0fh_ua: then you will get lots of "hidden" package errors, which in cabal jargon means you must add the package to build-depends: in the .cabal ;)
02:02:07 <FunctorSalad> ivanm: that was a program idea :)
02:02:24 <b0fh_ua> hm
02:02:37 <ivanm> tomberek: do you think we should have sub-repos in the code.haskell.org project directory for fgl-algorithms, etc. from the word go?
02:02:44 <rajeshsr> Cale, hmm, but i really don't get why we need a $ here, given that the function definition will be grouped as a single parameter.
02:02:44 * ivanm wants to set up a repo with history, etc.
02:02:52 <FunctorSalad> though I think they improved the error message
02:02:55 <FunctorSalad> (cabal)
02:03:08 <Cale> rajeshsr: It's not for any really obvious reason
02:03:22 <Cale> rajeshsr: It's some technical point about the difficulty of parsing, I think.
02:03:26 <tomberek> ivanm: i don't think i'm competent enough to give a useful answer
02:03:34 <b0fh_ua> FunctorSalad: oh, nice. looks like cabal build tries to resolve everything from scratch and doesn't rely on installed modules
02:03:57 <ivanm> tomberek: well, I gave three different scenarios we might want to consider in a previous email
02:03:58 <FunctorSalad> b0fh_ua: it does, but fetches and installs them
02:04:03 <rajeshsr> Cale, ha, ok! This behavior is mainly with lambda forms only, right?
02:04:31 <tomberek> ivanm: oh, that... I like sub-directories
02:04:40 <Cale> rajeshsr: lambda, let, if, case, do
02:04:42 <ivanm> good-o
02:05:04 <rajeshsr> Cale, oh, ok! Thanks.
02:05:06 * ivanm makes the repo
02:05:09 <Cale> and, I suppose, function application is in that part of the grammar as well
02:05:36 <Cale> But the reason for that is more obvious
02:05:37 <Cale> :)
02:05:44 <FunctorSalad> btw can we embed haskell into bash? ;) instead of bash into haskell
02:05:55 <Cale> FunctorSalad: You can ghc -e
02:06:15 <FunctorSalad> as long as it's just haskell-to-haskell the progs could pass each other nice serialized haskell values ;)
02:06:35 <Cale> I want a typed filesystem
02:06:53 <Cale> and typed pipes between programs :)
02:07:17 <FunctorSalad> Cale: ghc -e too, but I mean, say, a "foldr" script and so on ;)
02:07:25 <Cale> Why can't I write a function into a file, anyway? ;)
02:07:40 <ClaudiusMaximus> echo "a function" > "a file"
02:07:48 <ClaudiusMaximus> :)
02:07:55 <FunctorSalad> one of the challenges would be a "lambda" command with proper name handling
02:08:26 <Cale> Heh, I should be able to  writeFile "foo" (do ... some program ...), and have it write the (IO t) value into a file, which will act as an executable program :)
02:08:38 <FunctorSalad> Cale: uh, you can just write a shell script to a tempfile, that's more or less a function value
02:08:51 <FunctorSalad> so bash is fp ;)
02:09:07 <Cale> FunctorSalad: well, I have pulled tricks like that a lot
02:09:14 <Cale> Actually, I often do that.
02:09:24 <Cale> In a single shell pipeline even
02:09:55 <FunctorSalad> (and there are bash functions, but they fail when you pass their name to, say, fmap, and fmap doesn't run in the same env...)
02:10:04 <FunctorSalad> hypothetical fmap command :)
02:10:09 <Cale> If I'm afraid of the consequences of something I'm going to do, I'll instead write a command to print the bash commands, and then when I'm satisfied with it, I'll pipe the result to bash
02:10:11 <epssy> I'm trying to use Maybe Int and I can't figure out how to structure it as output; http://pastebin.com/7rqM6sEt this is the error I'm getting.  can some one help or point me to a good explanation of Maybe
02:10:20 <ivanm> tomberek: any idea what kind of version "0103" is meant to be?
02:10:25 <ivanm> 1.0.3 ?
02:10:40 <FunctorSalad> Cale: my current implementation of "lambda" dumps the args to a tempfile, then replaces the first arg with $
02:10:54 <tomberek> huh? 1st release, 3rd minor change?
02:11:08 <ivanm> yeah, that's probably it
02:11:08 <Cale> epssy: Every value of type  Maybe t  is either the literal value  Nothing  or it is a value of the form   Just x   where x has type t
02:11:15 <ivanm> that's the first release tarball martin has on his site
02:11:17 <FunctorSalad> so "$(lambda x echo oh hai the value is x1)" expands to the name of a script: echo oh hai the value is $1
02:11:25 <FunctorSalad> not quite perfect yet
02:11:30 <tomberek> ivanm: oh,,, odd
02:11:38 <Cale> epssy: So if you want a Maybe Int, you either use  Nothing  or something like  Just 5,  Just 7,  Just (-1), etc.
02:11:39 <FunctorSalad> (the substitution is dumb text subst)
02:12:01 <ivanm> tomberek: he kept doing that up to and including "fgl0502" :s
02:12:02 <epssy> cale so why will it not accept some thing like  find x:xs p:xs = Just (1 + find ps xs)  ?
02:12:05 <FunctorSalad> maybe with a bash parser one could do something
02:12:09 <epssy> if it is Maybe Int
02:12:15 <Cale> epssy: You need more parens on the left
02:12:26 <tomberek> ivanm: in that case, i think that is 0.5.0.2
02:12:42 <Cale> find (x:xs) (p:ps) = ...
02:12:49 <systemfault> @src gcd
02:12:49 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
02:12:49 <lambdabot> gcd x y = gcd' (abs x) (abs y)
02:12:49 <lambdabot>    where gcd' a 0  =  a
02:12:49 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
02:12:53 <ivanm> tomberek: nah, 5.0.2 (next version is 5.3)
02:12:57 <ivanm> or else just 5.2
02:13:00 <ivanm> *shrug*
02:13:00 <epssy> cale oh sorry, assume I have that, I'll get you the error I get
02:13:10 <Cale> epssy: But moreover, if find ps xs produces something like Just 6 as its result, you can't add 1 to that, because it's not a number
02:13:19 <epssy> oh
02:13:21 <Cale> epssy: You first have to pattern match the result
02:13:27 <Cale> case find ps xs of
02:13:30 <Cale>   Nothing -> ...
02:13:35 <Cale>   Just n -> ...
02:13:36 <Jafet> Or use monads!
02:13:43 <tomberek> ivanm: well, do we need all his versions, his latest should be enough
02:13:47 <Cale> s/monads/the Maybe monad/
02:13:55 <b0fh_ua> can somebody please explain what am I doing in wrong way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25404#a25404 ?
02:14:07 <ivanm> tomberek: history purposes, since we have no real history of when everything occurred
02:14:21 <FunctorSalad> "<Cale> and typed pipes between programs :)" <-- strong dynamic types would be easy
02:14:22 * ivanm isn't going to do it properly with all the "darcs mv" stuff though
02:14:34 <Cale> b0fh_ua: That Build-depends line looks commented out
02:14:39 <ivanm> tomberek: or, if you don't care, I can just do the latest version
02:14:43 <epssy> Cale I basically need to count how many times find is called which I can do easily if I can return it at Int but that's just not working as Maybe Int ... not  sure how I'd do that in a case
02:15:11 <epssy> or would it be Just n -> 1 + n
02:15:15 <tomberek> ivanm: if you can do it quickly, then ok, I just don't know if it's worth your time.  I think the latest is fine, if it isn't we can fix that later.
02:15:19 <FunctorSalad> (say, just prepend the TypeRep to every value serialization)
02:15:20 <Cale> Just n -> Just (1+n)
02:15:22 <Cale> Probably
02:15:27 <epssy> cale, thanks!
02:15:29 <b0fh_ua> Cale: indeed
02:15:35 <b0fh_ua> I have to wake up :)
02:15:37 <systemfault> @src lcm
02:15:38 <lambdabot> lcm _ 0     =  0
02:15:38 <lambdabot> lcm 0 _     =  0
02:15:38 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
02:15:44 <ivanm> tomberek: not sure if its possible to back-date patches like that though ;-)
02:15:53 <ivanm> tomberek: and yeah, it isn't real history, so there's no real point
02:15:59 <tomberek> ivanm: latest should be fine
02:16:01 <Cale> @src gcd
02:16:01 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
02:16:01 <lambdabot> gcd x y = gcd' (abs x) (abs y)
02:16:01 <lambdabot>    where gcd' a 0  =  a
02:16:01 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
02:16:04 <Jafet> find (x:xs) (p:ps) = liftM succ $ find xs ps
02:16:08 * ivanm did this for graphviz when he took that over, but never actually used that history
02:16:08 <Cale> I hate the first line of that
02:16:14 <FunctorSalad> haha
02:16:20 <FunctorSalad> why?
02:16:28 <Cale> gcd 0 0 is *not* undefined
02:16:28 <systemfault> Cale: What would you prefer?
02:16:34 <systemfault> Cale: A maybe?
02:16:37 <Cale> The gcd of 0 and 0 is 0
02:16:43 <systemfault> Ah ok
02:16:49 <Cale> It's the top of the divisibility lattice
02:16:50 <Jafet> Cale, but 0 doesn't divide anything.
02:16:58 <Cale> Everything divides 0
02:17:11 <c_wraith> including everything greater than 0
02:17:12 <FunctorSalad> I wrote a large paragraph in an elisp function today why there is no stateful cycling closure with cycle length zero
02:17:23 <c_wraith> meaning it's hard to pick one that's the greatest
02:17:24 <Jafet> Well, the GCD is nominally a divisor, and 0 isn't conventionally a divisor of any sort
02:17:35 <Cale> The "greatest" in "greatest common divisor" isn't in the sense of the usual order on integers
02:17:45 <Cale> It's in the sense of the divisibility relation on integers.
02:17:48 <ivanm> tomberek: it just sounds weird saying "FGL library"
02:17:54 <ivanm> ("functional graph library library")
02:18:01 <tomberek> ivanm: Go to the ATM machine
02:18:07 * Jafet assigns ivanm to the TTP project
02:18:28 <FunctorSalad> (sth like haskell's `cycle', but in elisp... no logical extension to the empty list, right?)
02:18:32 <FunctorSalad> > cycle []
02:18:33 <lambdabot>   *Exception: Prelude.cycle: empty list
02:18:36 <ivanm> Jafet: TTP?
02:18:42 <b0fh_ua> excellent, cabal seemed to resolve everything
02:18:43 <Jafet> The TPP Project.
02:18:43 <b0fh_ua> cool
02:18:57 <Jafet> Er, TTP.
02:18:58 <FunctorSalad> maybe nontermination is correct in some sense
02:18:59 <tomberek> ivanm: "will all VIP personnel please enter the conference room"
02:19:00 <ivanm> tomberek: oh, and what's your c.h.o username so you can push to the repo?
02:19:00 <Cale> gcd is the meet in that distributive lattice
02:19:12 <tomberek> ivanm: tomberek
02:19:15 <ivanm> Jafet: oh, it's a self-descriptive TLA?
02:19:18 <ivanm> tomberek: *nod*
02:19:25 <FunctorSalad> Cale: that's a good point :)
02:19:35 <Jafet> Cale, sure, just make sure to describe that in the prelude documentation
02:19:39 <tomberek> ivanm: i'm looking at the Set/Map usage
02:19:45 <FunctorSalad> was too tired to think about division ;) but x /\ x should be x
02:19:48 <ivanm> tomberek: *nod*
02:20:18 <tomberek> ivanm: how about we define those via the type family or a type class?
02:21:02 <ivanm> what do you mean?
02:21:11 <Cale> Also, you want that with respect to ideals, gcd x y is a generator of the ideal <x,y>
02:21:25 <FunctorSalad> yes
02:21:28 <Cale> and so there's another argument for gcd 0 0 = 0
02:21:43 <tomberek> ivanm: instead of using Data.Set and Data.Map, we can use different set-like structures when needed/wanted
02:22:25 <ivanm> tomberek: darcs get code.haskell.org/FGL/fgl/
02:22:26 <FunctorSalad> Cale: ok, convinced, it's absolutely the reasonable extension of gcd
02:22:47 <ivanm> tomberek: still not following where you want to put this
02:22:49 <FunctorSalad> had forgotten about the lattice and how 0 hovers at infinity
02:23:41 <tomberek> ivanm: for neighboorsOut :: g -> Vertex g -> (GraphMap g) (Vertex g) [ALabel g]
02:24:01 <ivanm> tomberek: oh, I didn't realise you were taking that much from my graph.hs file ;-)
02:24:06 <tomberek> so we are not required to use Data.Map
02:24:12 <tomberek> ivanm: ah
02:24:19 <ivanm> tomberek: how about for now we don't make that drastic a change
02:24:33 <ivanm> (then again, I'm not able to really hack on fgl this week; want to fix graphviz up)
02:24:46 <tomberek> ok, i'll poke around..
02:25:14 <tomberek> ivanm: my problem is that I usually can't see design decisions' implications far enough
02:26:12 <tomberek> eg: making arc a data Arc g = Arc (Vertex g) (Vertex g)  or   type Arc g = (Vertex g, Vertex g)
02:26:18 <ivanm> tomberek: we dont' want to scare users away by changing too much too fast!
02:27:21 <tomberek> ivanm: aye,, should we revert to FGL terminology? pre, suc, lab, gmap, mkGraph, etc?
02:28:25 <roconnor> Cale: are we going to fix gcd?
02:28:53 <roconnor> it would be nice if foldr gcd 0 worked nicely
02:28:58 <ivanm> tomberek: I dunno, some of those names are really, really atrocious
02:29:20 <FunctorSalad> does this explain why fields where iterate (+1) has *no* period are said to have char 0? ;)
02:29:35 <tomberek> ivanm: i agree we need to try to make the change easy for users, but I'm also in favor of an overhaul
02:29:51 <ivanm> tomberek: as am I
02:29:52 <FunctorSalad> min (empty set) = max_bound, and it's 0 in divisibility
02:30:15 <ivanm> tomberek: and Cale hates the names ;-)
02:30:20 <roconnor> FunctorSalad: (honestly I think char 0 should be char undefined or infinity)
02:30:23 <FunctorSalad> (typed sets ;) max_bound :: a, empty set :: Set a)
02:30:44 <tomberek> ivanm: how about two approaches to the problem? one that migrates FGL to the new version, and another that begins with something completely fresh, migrating towards something more familiar to FGL users
02:30:54 <FunctorSalad> roconnor: if 0 is the greatest element it makes sense
02:31:13 <FunctorSalad> not sure why you'd use the divides-order
02:31:24 <tomberek> ivanm: that way we see the goal, and it is easier to do the job
02:31:27 <roconnor> FunctorSalad: modulo negative numbers, 0 is the greatest element in the divisibility lattice
02:31:51 <roconnor> FunctorSalad: but this has been debated endlessly before.  I have no idea why people still thing gcd 0 0 is undefined.
02:31:57 <Cale> roconnor: The rest of the unwillingness to change the Prelude worries me, but it's yet another thing which I hope is eventually fixed.
02:32:21 <ivanm> tomberek: you mean two parallel modules in the library?
02:32:32 <FunctorSalad> roconnor: huh? I agreed in the gcd case :)
02:32:35 <ivanm> or we also have an "fgl-next" repo and when we find something we like and agree upon we merge it into mainline?
02:32:46 <FunctorSalad> roconnor: I meant char 0 makes sense for the div order
02:32:47 <Cale> Even including negative numbers 0 is greater in the divisibility lattice
02:32:49 <roconnor> > lcm 0 0
02:32:50 <lambdabot>   0
02:32:55 <roconnor> > lcm 1 1
02:32:57 <lambdabot>   1
02:33:01 <roconnor> > lcm 1 (-1)
02:33:02 <lambdabot>   1
02:33:06 <roconnor> > lcm (-1) (-1)
02:33:06 <lambdabot>   1
02:33:10 <ivanm> tomberek: I think having a separate experimental repo is a good idea
02:33:12 <FunctorSalad> since min \emptyset = greatest element
02:33:13 <tomberek> ivanm: i'm not commited either way, just an idea
02:33:16 * ivanm -> watch Dr Who
02:33:18 <ivanm> bbl
02:33:36 <tomberek> ivanm: whatever way of doing it that you think would be best is fine with me
02:33:39 <roconnor> @check \n -> abs n == join lcm n
02:33:40 <lambdabot>   "OK, passed 500 tests."
02:33:44 <roconnor> @check \n -> abs n == join gcd n
02:33:45 <lambdabot>   "*Exception: Prelude.gcd: gcd 0 0 is undefined
02:34:06 <tomberek> ivanm: that way we can attack the problem on two fronts, and meet in middle
02:34:06 <Grey_Fox> >lcm 2 3
02:34:18 <roconnor> > lcm 2 3
02:34:19 <lambdabot>   6
02:34:27 <FunctorSalad> and char K = min { n : nat+ |  (unsafeCoerce n :: K) == 0 }
02:34:30 <FunctorSalad> :D
02:34:38 <FunctorSalad> which is empty in char 0
02:34:43 <Grey_Fox> > lcm 0 1
02:34:44 <lambdabot>   0
02:34:46 <roconnor> FunctorSalad: yes
02:34:59 <FunctorSalad> roconnor: so, 0 it is if the `min' is over div
02:35:26 <roconnor> FunctorSalad: hmm
02:35:31 <FunctorSalad> for which I haven't confabulated a reason
02:35:35 <roconnor> well it isn't a terrible argument
02:35:36 <FunctorSalad> (why you'd want div)
02:36:24 <roconnor> actually, I guess it is a pretty good argument
02:36:35 <dolio> > lcm 0 0
02:36:36 <lambdabot>   0
02:36:48 <FunctorSalad> aha! :D the homomorphism from Z to K defines an ideal
02:36:52 <FunctorSalad> char is the generator
02:37:38 <FunctorSalad> lazy reason generation succeeded...
02:38:01 * Cale can't seem to help but take it personally when someone says they dislike mathematics.
02:38:08 <tomberek> ivanm: what was the reason to have Graph and FiniteGraph?
02:38:15 <FunctorSalad> Cale: context?
02:38:17 <Cale> I AM MATHEMATICS
02:38:26 <Grey_Fox> FunctorSalad: what's an ideal?
02:38:58 <FunctorSalad> Grey_Fox: hmm... explanation depends on whether you've seen rings
02:38:58 <Zao> Cale: Prove it!
02:39:10 <FunctorSalad> (it makes no sense at all without rings)
02:39:22 <Grey_Fox> well, I haven't really, I've seen groups.
02:40:02 <FunctorSalad> Grey_Fox: ah, then it's the equivalent of a normal subgroup, but for rings (something that can be the kernel of a homomorphism)
02:40:44 <Cale> Grey_Fox: If R is some ring, then an ideal I is a subset of R which is closed under addition, so if a and b are in I, then a + b is in I, and closed under multiplication from the outside, so if a is in I, and r is in R, then r*a and a*r are in I.
02:41:21 <FunctorSalad> which is equivalent to a subset I of the ring such that I is closed under addition, and ... Cale faster
02:42:00 <FunctorSalad> the reason why r can be ANY element is basically because 0*anything is 0
02:42:08 <FunctorSalad> and ideals are kernels
02:42:35 <Grey_Fox> the ideal for arithmetic is just {0}?
02:42:54 <Cale> If I is an ideal of the ring R, then you can form the quotient ring R/I, whose elements are sets of the form r + I = { r + a : a in I }, and whose addition and multiplication go as (a + I) + (b + I) = (a + b) + I, and (a + I) (b + I) = (ab) + I
02:42:55 <Grey_Fox> or, that's one ideal at least
02:43:03 <FunctorSalad> Grey_Fox: {0} is an ideal of Z
02:43:17 <Cale> That's one ideal of the ring of integers -- actually, it's an ideal of any ring.
02:43:33 <FunctorSalad> the other ones are: take a number n; the ideal consists of multiples of n
02:43:37 <Cale> But it's a boring ideal, because quotienting out by it just gives you something isomorphic to the ring again.
02:44:33 <Cale> Yeah, so for instance, the set {...-6,-4,-2,0,2,4,6,...} of even integers is an ideal of Z
02:44:50 <FunctorSalad> Cale: (side remark) with rings I think the homomorphism explanation is actually slightly better for teaching
02:45:02 <FunctorSalad> some people find the "closed under mult by r" arbitrary
02:45:11 <sosman> Trying to figure out parseTime.  "parseTime defaultTimeLocale ("2010 Nov 1 10:00:01") "%Y %b %e %H:%M:%S" :: Maybe UTCTime" give a Nothing result.
02:45:20 <Cale> Well, okay
02:45:45 <FunctorSalad> then say "ah, of course" when you say it's just 0 absorbing stuff :)
02:46:13 <Grey_Fox> FunctorSalad: what's the homomorphism explanation?
02:46:34 <FunctorSalad> that ideals are subrings which are the kernels of some homomorphism
02:46:56 <tomberek> ivanm: what was the reason to have Graph and FiniteGraph?
02:47:47 <FunctorSalad> yet another characterization is that ideals are 1:1 to congruence relations...
02:48:13 <FunctorSalad> and thus the reason we never talk about congruence relation with rings ;)
02:48:27 <FunctorSalad> (the ideal is more compressed data)
02:48:57 <FunctorSalad> but it's a justification why the definition of ideal is not wildly arbitrary
02:50:15 <Cale> Well...
02:50:42 <Cale> Okay, but I suppose it depends on how you define congruence relations
02:50:47 <FunctorSalad> Cale: though it's easier to define ideals from scratch than homomorphisms and kernels first, ok
02:51:16 <Cale> I would normally think of congruence relations as being roughly analogous to principal ideals.
02:51:32 <Grey_Fox> How do I learn all this stuff?
02:51:37 <FunctorSalad> congruence = equivalence such that + and * are respectful for the relation
02:51:38 <Cale> (or at least finitely generated ones)
02:51:46 <Cale> Grey_Fox: Pick up a book on ring theory...
02:51:55 <Grey_Fox> k
02:52:04 <FunctorSalad> Cale: hmm am I mistaken that they correspond exactly to ideals?
02:52:15 <Cale> You might like Artin's Algebra, or perhaps Dummit and Foote
02:52:39 <FunctorSalad> thought the definition was universally the one I just gave
02:52:43 <FunctorSalad> (of congruence)
02:52:52 <Cale> FunctorSalad: Well... how do you define a congruence relation?
02:52:58 <aristid> @src fix
02:52:58 <lambdabot> fix f = let x = f x in x
02:53:08 <FunctorSalad> equivalence such that + and * are respectful for the relation
02:53:13 <Cale> Normally it's something like x is congruent to y if their difference is a multiple of m
02:53:16 <FunctorSalad> maybe throw in negation too :)
02:53:40 <Cale> and that corresponds to quotienting out by the principal ideal generated by m
02:53:51 <FunctorSalad> Cale: ah. I mean the generic meaning from universal algebra or logic or wherever it's from
02:54:01 <FunctorSalad> not the arithmetic one
02:54:25 <FunctorSalad> that + and * map equivalent arguments to equivalent results
02:54:37 <Axman6> ivanm: you were after me?
02:54:37 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
02:54:39 <FunctorSalad> (possibly need negation too)
02:54:43 <Axman6> @messages
02:54:44 <lambdabot> ivanm said 1h 14m 22s ago: fyi, I'm going to be giving a talk on SourceGraph @ ANU on thursday night
02:55:04 <Cale> Yeah, and it's unnecessary, but while you're at it might as well throw in 0 and 1 :)
02:55:34 <FunctorSalad> negation is unnecessary?
02:55:36 <Axman6> ivanm: you have bad timing :( thursday is my SES training night, and this night happens to also be the engineering students association bar night
02:55:52 <FunctorSalad> it is for ring homos or abelian group homos...
02:56:12 <Cale> FunctorSalad: Yeah, since preserving addition will ensure that additive inverses are preserved
02:56:12 <sosman> that's discrimination
02:56:22 <Cale> hmm
02:56:26 <aristid> @pl fix $ \ r f xs -> if null xs then [] else let (h,t) = f xs in h : r f t
02:56:26 <lambdabot> (line 1, column 47):
02:56:26 <lambdabot> unexpected "("
02:56:26 <lambdabot> expecting "()", natural, identifier or "in"
02:56:49 <FunctorSalad> Cale: just worried because closure under + and * is not enough for subrings :)
02:56:51 <aristid> ghci accepts that? oO
02:57:54 <Cale> aristid: @pl doesn't know a lot of syntax
02:58:27 <aristid> hmm so i guess i can do this manually :D
02:58:29 <FunctorSalad> Cale: with that def, the bijection is just: given congruence, the Ideal is the class of zero. Given Ideal, the congruence is x ~ y iff x-y in I
02:59:00 <Axman6> > fix (\ r f xs -> if null xs then [] else let (h,t) = f xs in h : r f t) "hello"
02:59:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
02:59:01 <lambdabot>         against inferred ty...
02:59:08 <Axman6> :t fix (\ r f xs -> if null xs then [] else let (h,t) = f xs in h : r f t)
02:59:09 <lambdabot> forall a a1. ([a] -> (a1, [a])) -> [a] -> [a1]
02:59:21 <aristid> @pl \ r f h t -> h : r f t
02:59:22 <lambdabot> (flip ((.) . (:)) .)
02:59:32 <benmachine> @pl fix $ \ r f xs -> if null xs then [] else head (f xs) : r f (tail (f xs))
02:59:33 <lambdabot> fix ((ap (flip if' [] . null) .) . liftM2 ap (((:) . head) .) . (`ap` (tail .)) . ((.) .))
02:59:36 <Axman6> > fix (\ r f xs -> if null xs then [] else let (h,t) = f xs in h : r f t) (\(x:xs) -> (x,xs)) "hello"
02:59:36 <lambdabot>   "hello"
02:59:41 <Cale> FunctorSalad: yeah
02:59:49 <aristid> @pl \ r f (h, t) -> h : r f t
02:59:49 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (:))) .)
03:00:03 <aristid> wow, @pl can create the worst code ever :D
03:00:15 <FunctorSalad> just mentioned it because I find congruences more convincing as something natural than ideals ;) but they're bulky
03:00:36 <aristid> Axman6: try (splitAt 3) as the first parameter
03:01:07 <aristid> i want to get a pointfree form of chunkWith in chapter 12 of RWH
03:01:27 <FunctorSalad> and the correspondence shows the big importance of algebras where you can shovel everything over to one side
03:01:38 <FunctorSalad> with 0 or something on the other side...
03:02:07 <FunctorSalad> groups and rings yes, monoids fail...
03:02:46 <Saizan> do we have a Fail monoid?
03:03:01 <FunctorSalad> what does it do?
03:03:36 <Saizan> i don't know
03:04:26 * hackagebot tagsoup 0.9 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.9 (NeilMitchell)
03:05:06 <FunctorSalad> Cale: I find it interesting how this even cleaves category theory in two...
03:05:23 <Cale> FunctorSalad: oh?
03:05:42 <FunctorSalad> with many things duplicated in set-based CT and in abelian categories
03:05:48 <Cale> mm...
03:05:59 <FunctorSalad> kernels <-> equalisers etc
03:06:21 <Cale> Are you aware of where the name "ideal" comes from?
03:06:31 <FunctorSalad> (because with a zero you just need one gadget where you need two with sets)
03:06:47 <FunctorSalad> Cale: "Ideal number" I think
03:06:58 <Cale> Early on in ring theory, people would add "ideal elements" or, yeah "ideal numbers" to rings
03:07:22 <Cale> which we'd now recognise as quotients of a polynomial ring by an ideal :)
03:07:37 <FunctorSalad> when they found non-PIDs without having the name yet?
03:08:02 <FunctorSalad> since in PIDs ideals are just... numbers
03:08:17 <FunctorSalad> ignoring unit factors
03:08:38 <FunctorSalad> Cale: iirc it was subrings of C
03:08:45 <FunctorSalad> no abstract nonsense yet ;)
03:09:26 <Cale> Yeah, it was in number fields/rings
03:10:00 <FunctorSalad> Z[i * sqrt(5)]?
03:10:07 <Cale> So, things like Q(x)/<some relations> or Z[x]/<some relations>
03:10:08 <FunctorSalad> was that the non-PID?
03:10:13 <Cale> yeah
03:10:24 <FunctorSalad> (of course there are others, but a simple one)
03:10:44 <Cale> That's not even a UFD, if I recall correctly
03:11:20 <aristid> is it just me or doesn't ghci support the Begin/End keys? (i've been annoyed by this for a while)
03:11:21 <FunctorSalad> might well be
03:11:44 <Cale> (1 + i sqrt(5)) (1 - i sqrt(5)) = 1 + 5 = 6
03:11:47 <aristid> especially when i have ghci in screen, and thus have to type C-a a to get to the beginning of the line :(
03:11:49 <Cale> and 2 * 3 = 6
03:11:54 <FunctorSalad> Cale: hehehe looks familiar
03:12:15 <Cale> and the only units are 1 and -1
03:12:23 <Cale> So those really are different factorisations
03:12:29 <FunctorSalad> I wasn't convinced that they really are different at first :)
03:12:37 <bremner> aristid: I use C-_ as a prefix in tmux; should work in screen too
03:12:49 <FunctorSalad> yeah, must show that they're not unit-equivalent
03:12:57 <Cale> well, 1 + i sqrt(5) and 1 - i sqrt(5) also have the same norm, while 2 and 3 don't.
03:13:25 <FunctorSalad> not sure I'd come up with the norm so quickly
03:13:26 <aristid> bremner: that's not quite satisfactory.
03:13:31 <FunctorSalad> without hints :)
03:13:33 <Cale> er, I'm not sure if that's a valid argument now either
03:13:45 <aristid> bremner: especially considering that _ requires pressing a shift on my keyboard :P
03:14:01 <FunctorSalad> Cale: units have unit norm iirc
03:14:04 <aristid> bremner: not everybody has an english keyboard.
03:14:12 <FunctorSalad> in... Z I guess
03:14:18 <Cale> In every ring of integers?
03:14:38 <Cale> I forget so much algebraic number theory
03:15:01 <ivanm> tomberek: it was because Cale wanted support for infinite graphs
03:15:04 <ivanm> Axman6: :(
03:15:15 <bremner> aristid: same here, but I don't need the prefix very often, compared to basic cursor manipulation. Any C-a is a pessimal choice, anything else is better :)
03:15:21 <FunctorSalad> Cale: I never knew too much of it, but I'm thinking of Z[i*sqrt(5)] ~= some Z-matrix ring
03:15:31 <FunctorSalad> Cale: where the norm is the determinant?
03:15:39 <FunctorSalad> or is that field theory only
03:15:59 <aristid> bremner: i don't normally need C-a for cursor manipulation because i have the Begin/End keys...
03:16:06 <aristid> just ghci doesn't support them :(
03:16:20 <Saizan> aristid: which version?
03:16:28 <aristid> Saizan: 6.10.x
03:16:39 <bremner> aristid: well, sorry, I'm not going to fix ghci for you :)
03:17:05 <Saizan> aristid: ah, maybe you've one with editline, or an early haskeline, later ones do support it
03:17:26 <aristid> Saizan: ah, very good.
03:17:38 <aristid> and as i've just seen, ubuntu 10.04 has ghc 6.12.x
03:17:40 <Saizan> aristid: 6.10.x is when ghci switched from readline to editline to haskeline, not a very good moment!
03:18:42 <aristid> Saizan: 6.10.4 is the precise version
03:19:40 <FunctorSalad> Cale: when algebraically adjoining an x to a field K, the resulting field is like a nxn matrix ring with n the degree of the minimal poly... thought this was done for Z too, but don't ask me why :(
03:20:34 <FunctorSalad> (or whatever horrible thing the replacement for a minimal polynomial is for non-field matrices)
03:21:23 <FunctorSalad> ok, at least in Z we know that the roots of a poly are the same as in C
03:21:54 <FunctorSalad> (except Z may not contain them, obviously)
03:22:41 <Cale> FunctorSalad: Oh, right, the norm of a unit is indeed +-1, but you have to have a careful definition of what the norm is
03:23:52 <FunctorSalad> the determinant in the matrix representation?
03:24:12 <Cale> If K is a finite extension of Q, and sigma_1,...,sigma_n are the embeddings of K in C which fix Q, then you define N_Q^K(a) = sigma_1(a) ... sigma_n(a)
03:24:57 <FunctorSalad> these must be the eigenvalues then ;)
03:25:07 <FunctorSalad> assuming we're thinking of equivalent definitions here
03:25:46 <FunctorSalad> embeddings? not automorphisms?
03:26:08 <FunctorSalad> or it's the same possibly
03:27:04 <FunctorSalad> Cale: I additionally assumed that K is generated by a single element, given Q
03:27:18 <Cale> If K is a normal extension, then they're the same thing
03:27:58 <FunctorSalad> then if it isn't transcendental, it has a minimal poly p, so the ring is K[x]/p, which is just as good as K[Matrix] with Matrix having p as minimal poly
03:28:07 <Cale> and in this case, Q(sqrt(-5)) is normal, since it's closed under taking conjugates
03:28:11 <Cale> (over Q)
03:28:34 <FunctorSalad> but since Z[x] is trickier than K[x] this is just wild speculation
03:29:47 <FunctorSalad> in the field case we just need the single relation specified by the minimal polynomial to know all about the adjoined element
03:30:04 <FunctorSalad> don't know if that's true for Z
03:30:49 <Cale> Yeah, I'm also assuming that Z[sqrt(-5)] is the ring of algebraic integers of Q(sqrt(-5)), which I think is right.
03:31:08 <FunctorSalad> that's over my head :)
03:31:28 <Cale> It's been so long since I've touched this stuff...
03:31:57 <FunctorSalad> I just thought I'd seen these matrix representations with Z too
03:32:06 <FunctorSalad> but can't think of the argument why you can do that
03:32:09 <Cale> But anyway, an algebraic integer is a number having a minimal polynomial that is monic with integer coefficients.
03:32:31 <Cale> Yeah, I don't really know how it relates with matrix representations, that would probably help.
03:32:56 <FunctorSalad> it would help because a matrix is invertible iff the det is invertible
03:33:01 <Cale> (I've only done a little representation theory of groups, and not nearly as much as I'd like to know)
03:33:09 <FunctorSalad> so that'd prove the original thing we had about units
03:33:11 <Cale> mm
03:33:20 <Cale> right
03:33:46 <ivanm> Cale: do you know of any algorithms for removing transitive edges (ala tred)?
03:33:52 <FunctorSalad> but... don't we get it immediately? ;) since the norm is multiplicative
03:33:58 <FunctorSalad> and 1 has norm 1
03:34:02 <Cale> ivanm: Nothing non-obvious
03:34:08 <ivanm> *nod*
03:34:24 <FunctorSalad> at last that proves the direction we need to show that 2 and 3 aren't units
03:34:52 <Cale> FunctorSalad: You also need that the norm is an integer
03:35:24 <FunctorSalad> Cale: oh, right
03:35:46 <Cale> Or greater than 1 or something :)
03:36:29 <FunctorSalad> it should be an integer if it really is a det as I think
03:36:31 <Cale> Yeah, it's pretty easy to see that the usual complex magnitude is larger than 1 for all elements of Z[sqrt(-5)] other than 0, 1 and -1
03:36:32 <FunctorSalad> without knowing
03:36:47 <Cale> and it's multiplicative
03:36:50 <Cale> so that'll do :)
03:37:08 <FunctorSalad> wait, is it just the complex mag.?
03:37:24 <Cale> You can get away with using the complex magnitude as your norm here.
03:37:29 <FunctorSalad> or is that an alternative argument
03:37:31 <Cale> For the purposes of what we're doing.
03:37:33 <FunctorSalad> yes
03:37:37 <Cale> alternative argument :)
03:38:10 <FunctorSalad> is this poly just order 2? x^2+5=0...?
03:38:34 <Cale> I think the real norm is N(a + b sqrt(-5)) = (a + b sqrt(-5)) (a - b sqrt(-5)) = a^2 + 5 b^2
03:38:59 <FunctorSalad> so now if we had a field I'd just say that K[sqrt(-5)] is isomorphic to a 2x2 matrix ring with sqrt(-5) mapping to the right matrix
03:39:13 <FunctorSalad> a matrix with the same poly
03:39:29 <FunctorSalad> maybe the Q(sqrt(-5)) you mentioned helps
03:40:24 <FunctorSalad> translate in that field first and then handle the integer subring... but a bit too exhausted for that now
03:42:55 <roconnor> what is SDL and how does it compare to say gtk?
03:43:16 <alpounet> SDL is more for games
03:43:22 <Ke> sdl offers less abstraction
03:43:25 <FunctorSalad> does SDL even have widgets?
03:43:28 <alpounet> no
03:43:29 <alpounet> it doesn't
03:43:48 <alpounet> gtk is more for desktop applications
03:44:23 <Ke> gtk3 will be awesome
03:44:25 <alpounet> with SDL you blit surfaces onto other surfaces
03:44:35 <alpounet> all the time
03:44:49 <roconnor> ok
03:45:17 <arcatan> you might even PutPixel
03:45:49 * FunctorSalad wonders how many people tried to build an UI on that level :) I assume one underestimates what widget libs already do
03:45:52 <roconnor> say I want write a paint program
03:46:04 <FunctorSalad> (and runs out of steam)
03:46:32 <Entroacceptor> I did write one in Pascal... I had buttons.
03:46:35 <FunctorSalad> but you'd have freedom to build really weird interfaces
03:46:37 <Entroacceptor> long time ago
03:46:48 <Entroacceptor> and that's what games do
03:46:50 <Cale> http://notalwaysright.com/for-the-love-of-god-get-gps-part-2/5345 -- haha
03:47:14 <FunctorSalad> Entroacceptor: and games are notoriously hard to do in your free time ;)
03:47:50 <alpounet> roconnor, then you should probably use gtk
03:48:05 <Cale> FunctorSalad: Edit boxes are so troublesome :)
03:48:24 <alpounet> i'm pretty sure it has the necessary components for drawing pixels / lines / etc
03:49:05 <roconnor> alpounet: I was going to ask, how do a blit a raster using gtk?
03:50:12 <FunctorSalad> I wonder if a seamlessly zooming 2d "map" ("map" like the ones you look up roads on) would be efficient to select items from a huge collection, say, a filechooser
03:50:42 <FunctorSalad> say, /usr and /home would be toplevel colored rectangles
03:50:54 <roconnor> FunctorSalad: have you seen zoomable interfaces?
03:50:57 <FunctorSalad> as you zoom in more details appear
03:51:06 <Entroacceptor> FunctorSalad: but what most people actually try :)
03:51:23 <ClaudiusMaximus> FunctorSalad: like dasher for text entry?
03:51:53 <Cale> FunctorSalad: It can be neat, particularly if you continue that idea into seamlessly zooming directly into the contents of files :)
03:51:54 <alpounet> roconnor, i don't know gtk well enough
03:52:05 <FunctorSalad> ClaudiusMaximus: exactly, except maybe not this weird "zooming" into the right edge, just plain zoom as if you were falling
03:52:06 <alpounet> to answer your question
03:52:24 <FunctorSalad> roconnor: no
03:52:29 <ClaudiusMaximus> roconnor: i managed to *get* a raster from a gtk/cairo surface into a ByteString once, so it's probably possible to do it the other direction
03:53:09 <lewis1711> what's the function to see if an element is a member of a list?
03:53:15 <Cale> lewis1711: elem
03:53:23 <Cale> :t elem
03:53:24 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:53:53 <Cale> (It's often written infix)
03:53:57 <vic_> > elem 56 [1,2,3,4]
03:53:58 <lambdabot>   False
03:53:58 <FunctorSalad> the idea is that the bigger a target, the faster you can move onto it with the mouse... so I think this would be way faster than clicking through a tree view
03:54:06 <roconnor> http://en.wikipedia.org/wiki/Zooming_user_interface
03:54:36 <ClaudiusMaximus> FunctorSalad: but what if you know exactly what you want and where it is, but it's hidden away in some tiny little nook
03:54:42 <FunctorSalad> it would split dirs or flatten dir trees so that there's a sensible number of rectangles at all times
03:54:42 <Cale> http://upload.wikimedia.org/wikipedia/commons/7/73/Eagle_Mode_0.71.0_Linux_source_zoom_1.png
03:55:02 <FunctorSalad> ClaudiusMaximus: then you want an autocompleting text box, not a tree widget :)
03:55:09 <roconnor> http://www.codinghorror.com/blog/2007/05/zoomable-interfaces.html
03:55:23 <FunctorSalad> ClaudiusMaximus: ideally, partial completion :)
03:55:37 <FunctorSalad> w-o-t-s expands to with-output-to-string
03:55:39 <FunctorSalad> in elisp
03:55:39 <FunctorSalad> :)
03:55:44 <lewis1711> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25406#a25406 I'm pretty new to haskell, what am i doing wrong here?
03:55:52 <FunctorSalad> (with PC-complete)
03:56:22 <Cale> lewis1711: If you're going to use it infix, you need to put it in backticks, like `elem`
03:56:37 <FunctorSalad> ClaudiusMaximus: the keyboard is unbeatable for one-way-communication (you know what you want), sure
03:56:47 <Cale> lewis1711: You can do that with any function of (at least) 2 parameters
03:57:49 <Cale> Well, any function name which is normally prefix (starts with an alphabet character)
03:57:51 <lewis1711> ah, I was using 'regular' ticks before. which wasn't working. so I came here
03:57:57 <Cale> ah, okay
03:57:59 <wagle> yay!  my first sieve to typecheck didn't try to diverge
03:58:11 <wagle> try real hard
03:58:36 <wagle> ie, not ghastly slow
03:59:20 <FunctorSalad> ClaudiusMaximus: unless you have the trackball on you but would have to MOVE to reach the keyboard
03:59:23 <FunctorSalad> ;)
04:00:24 <ClaudiusMaximus> :)
04:00:40 <lewis1711> I just spent 30 seconds searching for the backtick on my keyboard. I don't think I've ever used it before.
04:00:42 <jeffz> what do people mean when they refer to a parser as being an "online parser"?
04:00:42 <lewis1711> :)
04:01:17 <FunctorSalad> ClaudiusMaximus: or for even commoner items, a global hotkey...
04:01:39 <ClaudiusMaximus> on my keyboard it's above TAB, but i have to press it twice or  gt ccnts
04:01:40 <FunctorSalad> a bit like a cache hierarchy
04:03:05 <Paya> hi all..is there anyone that can give me a hand with my compilation error(s)? I'm trying to figure out what im doing wrong but i don't have a clue anymore..
04:03:29 <Ke> just pastebin it and...
04:03:35 <Paya> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25407#a25407
04:03:59 <Ke> and the error
04:04:19 <Paya> Syntax error in declaration (unexpected `;', possibly due to bad layout)
04:04:56 <Paya> im not an expert at haskell..just started this a couple of weeks ago so..:(
04:05:47 <Saizan> Paya: can you annotate with the whole error? it should have a line number
04:05:54 <Ke> I can't find any ;
04:06:29 <Paya> ERROR file:.\ Haskell.hs:39 - Syntax error in declaration (unexpected `;', possibly due to bad layout)
04:06:35 <Paya> thats all i get to see
04:06:44 <Saizan> the ; is inserted by the layout desugarer, i guess
04:07:13 <Saizan> Paya: ah, the problem is in your use of the guards above
04:07:21 <Paya> which ones?
04:07:36 <Ke> parser should never give erros about code user did not explicitly insert
04:07:56 <Ke> (besides C macros)
04:08:07 <Saizan> Paya: lines 35 and 36 don't make much sense
04:08:29 <jeffz> Paya: lines 53 and 54 are also strange
04:08:58 <Paya> hmm lemme have a go at them
04:09:11 <Saizan> Ke: true, but this is hugs :)
04:09:16 <Paya> thanks for the guidelines :)
04:10:12 <Saizan> Paya: maybe your editor is inserting | for you when you press enter?
04:10:45 <Saizan> Paya: however, line 85 also needs to be deindented
04:10:58 <Paya> ya i think thats what it did
04:15:09 <Paya> Saizan: which guard you said was wrong?
04:18:24 <ClaudiusMaximus> that was "fun" - froze my system solid - must remember to "make clean" when i change sizeof(struct) until i've fixed the Makefile...
04:19:18 <ClaudiusMaximus> (wouldn't have happened in Haskell...)
04:19:28 <FunctorSalad> forgive my ignorance but shouldn't that be just a segfault?
04:19:37 <FunctorSalad> rather than freeze :)
04:19:47 <Jafet> FunctorSalad, lololol linux
04:19:52 <Jafet> Anyway, ulimit(1)
04:19:53 <FunctorSalad> in principle anyway
04:19:54 <ClaudiusMaximus> well, i obviously triggered some bug in the OpenGL driver
04:20:06 <Jafet> Ah, graphics.
04:20:08 <FunctorSalad> ah, didn't catch that it's opengl
04:20:22 <FunctorSalad> Jafet: linux? different on other oses?
04:20:22 <ClaudiusMaximus> and sound with JACK running at realtime priority...
04:20:31 <Jafet> I thought it had something to do with allocating memory
04:21:10 <FunctorSalad> don't all halfway modern oses strictly forbid processes clobbering the memory of other processes....?
04:21:41 <Jafet> The point is that, allocating memory on linux won't ever fail.
04:21:58 <ClaudiusMaximus> yea, but Linux opengl drivers are in kernel-space as far as i understand it (which is not much)
04:22:00 <Jafet> It's success or _|_.
04:22:01 <roconnor> wait what?
04:22:02 <FunctorSalad> thought the sizes were just somewhat wrong, not huge
04:22:12 <rajeshsr> i get the error: b.hs:10:12: parse error on input `<-'
04:22:18 <rajeshsr> any idea?
04:22:19 <FunctorSalad> just jumped in after "chang esizeof(struct)"
04:22:35 <sosman> Any tips on why "parseTime defaultTimeLocale ("2010 Nov 1 10:00:01") "%Y %b %e %H:%M:%S" :: Maybe UTCTime" returns Nothing please?
04:22:46 <ClaudiusMaximus> Jafet: you can change the overcommit behaviour in recent kernels, so malloc returns NULL instead of blowing up everything
04:22:46 <roconnor> does allocating memory really never fail?
04:22:48 <sosman> I have never used parseTime before
04:23:38 <sosman> And my first attempt at Haskell.
04:23:43 <ClaudiusMaximus> sosman: nor have i, sorry :(
04:23:56 <roconnor> sosman: I'll have a look
04:25:10 <ClaudiusMaximus> FunctorSalad: it made the offsets of other things in a containing struct change, but my Makefile is cack and missed recompiling something that depended on it ==> massive memory corruption
04:25:12 <sosman> roconnor: thanks - to be honest I am still trying to come to grips with the synopsis: "parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t"
04:25:24 <FunctorSalad> Jafet: my thought was just that even if the allocation never fails, then with wrong assumptions about the size of things (and if it wasn't opengl etc), the program would eventually try to write to a nonsense address
04:26:11 <FunctorSalad> (maybe depends on whether the expected size is smaller or larger, don't know the memory layout so well)
04:26:35 <Jafet> Claudius, missing header deps?
04:26:49 <ClaudiusMaximus> Jafet: yep
04:26:50 <arcatan> sosman: format string comes first
04:26:57 <sosman> doh
04:27:19 <FunctorSalad> format string -> format adt?
04:27:24 <bremner> ClaudiusMaximus: "gcc -MM -MG -MF"
04:27:29 <FunctorSalad> (would that be better?)
04:27:33 <Jafet> I prefer a foolproof solution like ccache
04:27:40 <Jafet> ghc --make uses a similar mechanism
04:27:50 <Jafet> (Checksumming inputs to avoid recompiling)
04:28:22 <ClaudiusMaximus> well, "make -C src clean all" doesn't take that much longer, it's only 5k lines...
04:28:25 <FunctorSalad> timestamps are legacy from when it was too expensive?
04:28:59 <jeffz> can anyone tell me what people mean by an "online" parser?
04:29:40 <Jafet> jeffz, an online algorithm is one that can process inputs incrementally. Otherwise I have no idea
04:29:41 <FunctorSalad> jeffz: producing output before the end of input? stab in the dark
04:29:51 <FunctorSalad> (depends on context if that's plausible)
04:30:21 <wli> jeffz: Parsing input that comes in unpredictably like over the network or over a terminal.
04:30:28 <increpare> My mind's in a bit of a fuzz right now, but anyone here managed to get the gtk or wxWidgets libraries working on osx 10.6?
04:30:30 <jeffz> people keep saying parsec is not an online parser, except I have used it to parse infinite streams without consuming the entire stream - does that make it an online parser?
04:30:53 <FunctorSalad> did that change in 3.1?
04:30:54 <wli> jeffz: The implication is that you can't wait for a clear signal that you've received all the input.
04:31:07 <jeffz> FunctorSalad, I only know Parsec 2.
04:31:26 <FunctorSalad> thought anything that returns something of the form "Either Error Result" has to consume the whole input
04:31:30 <FunctorSalad> before output
04:31:49 <FunctorSalad> since the head constructor (Left or Right) depends on whether the whole thing succeeded
04:31:50 <Jafet> Well, you can return an error immediately.
04:31:54 <sosman> arcatan: thanks funny how parseTime couldn't read my mind
04:32:14 <rajeshsr> > gcd 0 0
04:32:14 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
04:32:20 <FunctorSalad> Jafet: or use ListT MyErrorMonad
04:32:31 <rajeshsr> is that a bug? Shouldn't safely assume it to be 0?
04:32:35 <FunctorSalad> my point is I thought parsec returns an Either (or its clone)
04:32:42 <FunctorSalad> @ty parseTest
04:32:43 <lambdabot> Not in scope: `parseTest'
04:32:46 <jeffz> the common case where parsec 2 can be used to parse an infinite stream is that parts of the stream are instantly recognisable, ie a parse result that might be a token + the rest of the stream.
04:32:48 <FunctorSalad> @ty runP
04:32:49 <lambdabot> Not in scope: `runP'
04:32:53 <FunctorSalad> @ty runParsec
04:32:54 <lambdabot> Not in scope: `runParsec'
04:32:54 <Botje> rajeshsr: the d stands for divisor
04:32:57 <Jafet> rajeshsr, that depends on what you consider to be the definition of gcd.
04:33:07 <Jafet> Read Cale's rant a few hours above.
04:33:36 <rajeshsr> Jafet, where can i find it?
04:33:52 <FunctorSalad> Cale's arguments make it pretty uncontroversial for all I know
04:34:07 <FunctorSalad> unless you have a completely different framework of what a gcd is
04:34:26 <rajeshsr> Just now faced the problem, when i used gcd like that. I think it is fair to assume 0, as non-exhaustive pattern errors suck when you thought your code works!
04:34:38 <increpare> @src gcd
04:34:38 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
04:34:38 <lambdabot> gcd x y = gcd' (abs x) (abs y)
04:34:38 <lambdabot>    where gcd' a 0  =  a
04:34:38 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
04:34:49 <FunctorSalad> but the ideal-generator property is essential, IIRC you simply *define* the gcd like that in PIDs which aren't euclidean
04:34:51 <Jafet> It's not a pattern at all -- it's error
04:34:56 <Jafet> Which is admittedly ugly
04:35:14 <rajeshsr> Jafet, ha, so that was intentional!!
04:35:24 <FunctorSalad> (and divisibility is the more natural order since general rings don't even have a total order like Z)
04:35:41 <Jafet> :t gcd
04:35:42 <lambdabot> forall a. (Integral a) => a -> a -> a
04:35:56 <Jafet> Well, perhaps if you generalized it to Num then.
04:36:18 <FunctorSalad> rajeshsr: it's not a hack to avoid errors, it perfectly fits the rules
04:36:57 <rajeshsr> FunctorSalad, you mean? gcd 0 0 is undefined mathematically and haskell follows it?
04:37:13 <increpare> It's a pity the domain can't be specified more precisely at a type-level ;)
04:37:17 <Jafet> rajeshsr, again, define gcd.
04:37:40 <Jafet> > 1/0
04:37:41 <lambdabot>   Infinity
04:37:44 <Jafet> Doh.
04:37:45 <increpare> let Rajeshsr.gcd 0 0 = 0
04:37:49 <Jafet> > div 1 0
04:37:50 <lambdabot>   *Exception: divide by zero
04:37:56 <increpare> > div 0 1
04:37:57 <lambdabot>   0
04:38:10 <increpare> Everyone know's that division's commutative, so that must be a bug in ghci.
04:38:35 <FunctorSalad> rajeshsr: I mean gcd 0 0 = 0 is true according to the most "natural" defs of gcd in cales O / IMHO, that is, the ones that generalize to other mathematical structures
04:39:57 <rajeshsr> FunctorSalad, hmm, so you disagree with ghc's gcd?
04:40:48 <FunctorSalad> (pick one: 1. Greatest common divisor, with "greatest" referring to divisibility order, 2. gcd x y is the generator of the ideal (x)+(y) (this works in any principal ideal domain))
04:41:05 <FunctorSalad> rajeshsr: yes
04:42:28 <rajeshsr> FunctorSalad, hmm, considering the divisibility as a POSET gcd 0 0 = 0 makes sense, right?
04:42:44 <increpare> rajeshsr: why?
04:42:45 <FunctorSalad> Cale: hmm 0 doesn't have a factorization in UFDs does it? that would have even larger scope
04:43:04 <FunctorSalad> rajeshsr: that's what we've been saying all along, sure
04:44:33 <FunctorSalad> ok, granted, 0 seems nonsensical if you define gcd by way of the prime factorization
04:44:35 <rajeshsr> increpare, from the definition of POSET and its behavior. Greatest Lower Bound or something is GCD i guess, not sure though..
04:45:08 <FunctorSalad> (the factorization of 0 would have to be the product of all the primes to infinite power each ;) to be the greatest element for divisibility)
04:45:41 <increpare> rajeshsr: that's a very different concept - I guess you can say that there's an order-preserving relationship between the arguments and result of a gcd, but I don't know if it's enough to change the definition over.
04:45:54 <FunctorSalad> rajeshsr: just the greatest element of the set of divisors
04:46:49 <FunctorSalad> increpare: it's the "min" operation for the divides- order
04:46:56 <FunctorSalad> *max
04:47:00 <rajeshsr> increpare, FunctorSalad was talking about generalizing the idea of GCD which would make sense if you think in terms of POSET
04:48:59 <increpare> rajeshsr: We're getting into tropical geometry here so? :)
04:49:37 <increpare> (okay that's a bit of a stretch)
04:49:56 <FunctorSalad> for the div order, `gcd` is simply the max... using the linear order seems pretty contrived in comparison
04:51:39 <FunctorSalad> that's not a proof, it's supposed to be a reason for defining gcd that way and not the other
04:53:10 <rajeshsr> FunctorSalad, why not call it Greatest Lower Bound, any problem with that?
04:55:26 <FunctorSalad> rajeshsr: GLB is the samer as MIN for just two elements
04:55:33 <FunctorSalad> or any number of elements
04:55:38 <FunctorSalad> *finite
04:55:49 <FunctorSalad> it's just a different concept for infinite sets
04:56:11 <FunctorSalad> (and since it's MIN, you flipped the order there, but ok :))
04:58:06 <rajeshsr> FunctorSalad, hmm, i do not know about infinite sets. But I would think it applies there as well. What changes in infinite sets?
04:59:08 <FunctorSalad> rajeshsr: greatest lower bound of the positive reals is 0, minimum of the positive reals doesn't exist
05:01:45 <rajeshsr> FunctorSalad, hmm! sorry to be too dumb! why is it not 0 for reals?
05:02:02 <rajeshsr> s/reals/positive reals
05:02:15 <FunctorSalad> rajeshsr: 0 just isn't positive by definition
05:02:41 <rajeshsr> you mean MIN should belong to the set, while GLB need not?
05:02:47 <FunctorSalad> right
05:03:07 <bremner> exactly. Open and closed sets is another way of looking at this.
05:04:37 <rajeshsr> ha, ok! it is ringing some bell about axiomatization of real numbers.
05:07:55 <Heffalump> is community down again?
05:08:02 <rajeshsr> :t uncurry
05:08:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:08:26 <rajeshsr> @src uncurry
05:08:26 <lambdabot> uncurry f p = f (fst p) (snd p)
05:08:32 <Heffalump> oh, no, sems to be just being slow
05:25:16 * Baughn wonders who to kill to make Google revert their search layout
05:28:43 <FunctorSalad> will code written by the undead have any special abilities?
05:28:52 <FunctorSalad> misread
05:29:10 <FunctorSalad> "wonders who will kill Google to make them revert..."
05:30:01 <arw> does anybody know anyone who likes the new search layout?
05:30:44 <Baughn> I know several people who have expressed homicidal impulses over it.
05:30:47 <Baughn> Does that count?
05:31:28 <p_l> Baughn: do you think sending newspaper clipping-style threats would help?
05:31:56 <FunctorSalad> my first reaction wasn't exactly positive, but I'm curious why it inspires such righteous wrath
05:32:09 <bremner> it is completely broken in midori
05:32:18 <Saizan> i mostly wonder what the wonder wheel is
05:32:41 <FunctorSalad> that's been there for a while
05:32:46 <FunctorSalad> but dunno either
05:33:17 <FunctorSalad> who knows what direction of 'wonder' though
05:35:00 <nagnatron> I like the new layout and it works fine for me in midori
05:38:03 <ClaudiusMaximus> the search results are now in a column 1/3 the width of my screen so i have to scroll down - annoying
05:52:39 <Entroacceptor> how to actually use runInteractiveCommand?
05:52:55 <Entroacceptor> I got the file descriptors, but reading just blocks
05:53:48 <allbery_b> DIV[ID*="leftnav"] { display: none !important; }
05:55:04 <allbery_b> (CSS to put into a user CSS file to hopefully get rid of the new column in the Google results page)
05:55:08 <dv-> Entroacceptor: this works http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25408
05:55:14 <ivanm> Entroacceptor: I use runInteractiveProcess in graphviz
05:55:18 <ivanm> using code based off Cabal...
05:55:26 <ivanm> @hoogle runInteractiveCommand
05:55:26 <lambdabot> No results found
05:55:31 <ivanm> bah
05:55:41 <portnov> @hoogle ByteString -> [Word8]
05:55:41 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
05:55:42 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
05:55:42 <lambdabot> Data.ByteString head :: ByteString -> Word8
05:56:23 <allbery_b> might need to modify that CSS to only operate on google.com, come to think of it
05:56:59 <Entroacceptor> mmh
05:57:43 <Baughn> allbery_b: Stylish would do it, if you aren't aware of that extension
05:57:49 <Entroacceptor> I'd like event-based reading...
05:58:09 <Baughn> Entroacceptor: "Event-based"?
05:59:04 <ManateeLazyCat> Have any hackage package can get detail information of processes? Like `ps`, but i'm wonder have some Haskell APIs do that. :)
05:59:54 <Entroacceptor> well, the program writes stuff the stdout, and I want to parse that
06:00:36 <Entroacceptor> but it's not all-in-once
06:00:47 <Baughn> ManateeLazyCat: Yours'd be the first. The APIs in question are different for every OS, so.. yeah.
06:01:31 <ManateeLazyCat> Baughn: So have any package for Linux processes?
06:01:37 <Entroacceptor> so I'd like to have some kind of hook in my program when there's a new line to read
06:01:51 <Baughn> ManateeLazyCat: Not that I know of. On linux, it would be relatively easy to write one; read /proc.
06:03:27 <ManateeLazyCat> Baughn: Yes, i can wrap `ps` and format result, just curious have binding for low-level process C function.
06:03:33 <Jafet> You can translate one of the many C or C++ unix monitoring tools
06:03:40 <Axman6> Entroacceptor: have you looked at Attoparsec? it has the ability to read incrementally
06:03:43 <Baughn> ManateeLazyCat: You should not wrap ps. The canonical API is /proc.
06:03:47 <Jafet> Most of the nice ones, like htop, are system specific though
06:04:36 <Xask> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25409 Could please someone help me. How can I get each value from getLine in case 1 to a function called addMusic
06:05:38 <allbery_b> FFI wrapper for libkvm? (library originally developed by Sun but source compatible versions exist for *BSD, OSX, Linux and possibly others)
06:06:46 <ManateeLazyCat> Baughn: /proc API? Can you give me the link about this?
06:07:00 <Jafet> allbery_b, is that a question?
06:07:33 <Baughn> ManateeLazyCat: Depending on how much detail you want, http://en.wikipedia.org/wiki/Procfs might do.
06:07:34 <Jafet> lazycat: proc(5) manpage on linux should get you started
06:07:34 <allbery_b> suggestion for the process information question
06:08:01 <allbery_b> it's about as close as you're going to get to portable, barring something like turning unixtop into a library
06:08:14 <ManateeLazyCat> Baughn: I want every detail, i need build a fully feature process-manager in my gtk2hs program.
06:08:17 <ManateeLazyCat> :)
06:08:18 <Saizan> Entroacceptor: with the current API it's easier to forkIO a thread that just reads the lines and pushes them into a Chan or some similar thing
06:08:30 <allbery_b> ManateeLazyCat: you want a binding for libgtop in that case
06:08:42 <Baughn> ManateeLazyCat: Define "every detail". I doubt you need an event per libc call the program does, or something.
06:09:23 <Jafet> Also have fun doing it on windows.
06:09:41 <Jafet> You could reverse engineer process explorer, maybe
06:09:53 <ManateeLazyCat> Baughn: I don't know the "detail" yet, but i want same feature that other unix process-mintor . :)
06:10:06 <ManateeLazyCat> Jafet: I just care open-source.
06:10:15 <ManateeLazyCat> Jafet: I don't like reverse engineer. :)
06:10:27 <Baughn> ManateeLazyCat: ..then that wikipedia page will probably do.
06:10:30 <ManateeLazyCat> Jafet: That's mean i haven't interested on Windows.
06:10:40 <Jafet> Meh, sometimes working out the subtler details of /proc is tantamount to reverse engineering
06:10:41 <ManateeLazyCat> Baughn: Thank you very much, i read it.
06:10:51 <Jafet> Like when they give you durations in jiffies.
06:11:09 <Baughn> Jiffies.. which used to be variable, and now are 1ms each
06:11:15 <Baughn> Or was it 10ms? >_>
06:11:16 <ManateeLazyCat> Jafet: I'm build a quick search tools in my gtk2hs program, like Mac's "quicksilver" . :)
06:11:28 <Jafet> They're still variable, depending on how your kernel was built
06:11:44 <Jafet> And on the realtime fork I'm not sure how they even work anymore
06:11:58 <ManateeLazyCat> allbery_b: libgtop? Link? Thanks.
06:12:06 <Baughn> Mm. How hard would it have been to give times in decimal seconds?
06:12:17 <allbery_b> @go libgtop
06:12:18 <lambdabot> Maybe you meant: google googleit do
06:12:23 <allbery_b> @google libgtop
06:12:24 <lambdabot> http://library.gnome.org/devel/libgtop/stable/
06:12:24 <lambdabot> Title: Libgtop Reference Manual
06:12:53 <ManateeLazyCat> allbery_b: Hmm, it's a gnome library.
06:13:02 <allbery_b> it's not actually linked to gnome particularly (that, as the manual notes, would be a massive security hole)
06:13:22 <allbery_b> except insofar as it's the engine behind gtop (which *is* part of gnome)
06:13:58 <Jafet> Baughn, most tops do it, with mechanism unknown to me
06:14:22 <ManateeLazyCat> allbery_b: It's depend glib?
06:14:30 <allbery_b> top converts.  I'd guess the real problem is that you'd need to do some form of floating point in the kernel
06:14:39 <Baughn> Jafet: I meant for the kernel. :P
06:14:43 <allbery_b> ManateeLazyCat: yes.  but gtk2hs does too
06:14:55 <Baughn> allbery_b: Not really. It'd basically be fixed-point math.
06:15:03 <ManateeLazyCat> allbery_b: Hah, i can use my gtk2hs knowledge binding this library fast. :)
06:15:14 <Jafet> Well, linux is bloated enough already
06:15:25 <Baughn> allbery_b: With the exported /proc file having a decimal point to tell readers how many significant digits there are
06:15:37 <ManateeLazyCat> Jafet: Need more layout in kernel?
06:16:30 <ManateeLazyCat> allbery_b: Thanks, i will look libgtop deeply, perhaps i need binding it. :)
06:17:23 <ManateeLazyCat> allbery_b: BTW, the tools in gtk2hs can build any glib-base library quickly. :)
06:17:33 <allbery_b> exactly
06:19:42 <ManateeLazyCat> allbery_b: After we fix something in gtk2hs, we can release `gtk2hsBuildTools, glib, gtk ...` package separately, then any glib-base package can use gtk2hsBuildTools and don't need depend any package in gtk2hs.
06:20:30 <ManateeLazyCat> Infact, `tools` in gtk2hs can do that, just we haven't release those packages separately.
06:22:01 <ManateeLazyCat> allbery_b: Have any exist program use libgtop APIs? That's will help how to binding it.
06:23:31 <allbery_b> I don't currently, no.  (haven't actually used it since the early days of gnome when I did a lot of the solaris portability work)
06:24:32 <ManateeLazyCat> allbery_b: BTW, solaris is still support by Oracle?
06:24:46 <ManateeLazyCat> allbery_b: I mean free for community.
06:25:10 <tibbe> dons: please ping me when you're around
06:26:15 <ivanm> ManateeLazyCat: freesolaris is
06:26:19 <ivanm> actual solaris isn't
06:26:38 <ManateeLazyCat> ivanm: Oracle still support FreeSolaris ?
06:26:44 <allbery_b> for the moment
06:26:54 <allbery_b> (it's actually opensolaris)
06:27:00 <ivanm> ManateeLazyCat: dunno what they're going to do with freesolaris
06:27:09 <ivanm> my guess: it's going to magically disappear any time now
06:27:22 <allbery_b> I think the license lets the opensolaris folks fork if needed
06:27:41 <ivanm> oh, right, opensolaris, not freesolaris
06:27:58 <ivanm> allbery_b: yeah, they can, but AFAICT a lot of people were using solaris proper for free rather than opensolaris
06:28:05 <edwardk> ivanm: thanks for checking last night =)
06:28:11 <ManateeLazyCat> Baughn: I have read contents of /proc, most detail, but need do many parse work self, i prefer to binding some C library that have parse those information. :)
06:28:11 <allbery_b> I know (I'm one of them)
06:28:23 <allbery_b> but, well, oracle.  could see that on coming from a mile away
06:28:33 <ManateeLazyCat> ivanm: I like Sun, it's a hero company.
06:28:38 <edwardk> hrmm can anyone think of any list/map/set-like functions that make sense on a heap that i missed in http://hackage.haskell.org/packages/archive/heaps/0.1/doc/html/Data-Heap.html ?
06:28:44 <allbery_b> it's a dead company now, I'm afraid :(
06:28:44 <ivanm> edwardk: np
06:28:51 <ivanm> ManateeLazyCat: the sun has gone
06:29:01 <ManateeLazyCat> ivanm: Yes, sadly.
06:29:01 <ivanm> * gone out
06:29:13 * allbery_b had some friends at sun.  they're bailing like rats from a sinking ship
06:29:32 <ivanm> edwardk: heapSort!
06:29:41 <edwardk> ivanm: hahahaha true enough
06:29:53 <edwardk> heapsort = toList . fromList it is ;)
06:29:53 <ManateeLazyCat> ivanm: I think that no one company has the Sun's courage.
06:29:57 <ivanm> edwardk: I take it toUnsortedList just returns them in some internal order?
06:30:06 <edwardk> ivanm: yeah
06:30:07 <ivanm> courage to lose money? ;-)
06:30:38 <ivanm> edwardk: IIRC there are more efficient methods of doing fromList
06:30:45 <edwardk> ivanm: its just an inorderer traversal of the leaves, which bypasses deleteMin. so toList is O(n log n) and toUnsortedList is O(n)
06:30:49 <ivanm> not sure how well they'll do in Haskell though, since IIRC they're mutable
06:30:54 <ManateeLazyCat> ivanm: Anyway, Sun do much contribution for Open-Source.
06:30:57 <ivanm> edwardk: *nod*
06:31:10 <ivanm> ManateeLazyCat: only because they tried to make money on hardware and support
06:31:17 <edwardk> ivanm: there can be if the list is presorted but since my merge is O(1) here, this fromList is O(n)
06:31:19 <Baughn> ManateeLazyCat: C bindings are easy in Haskell, but still annoyingly complex. You may find that it's easier to parse the data yourself than to write a binding.
06:31:25 <edwardk> so all that changes are constants
06:31:49 <ivanm> edwardk: nope, doesn't have to be pre-sorted IIRC
06:32:02 <edwardk> ivanm: well, in the end you can't beat a fromList in O(n) ;)
06:32:04 <ivanm> edwardk: you chunk it up or something methinks
06:32:10 <ivanm> edwardk: true ;-)
06:32:20 <ManateeLazyCat> Baughn: Yes, if i parse the data with Haskell, i control everything and much safer, but maybe need more time. :)
06:32:37 <edwardk> i was thinking about adding some parallelism to it, but its kind of nice only depending on base for once =)
06:32:38 * hackagebot llvm 0.8.0.2 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.8.0.2 (LennartAugustsson)
06:33:00 <allbery_b> Baughn: libgtop is based on the glib/gtk+ stuff, so the modified c2hs that's part of gtk2hs should do most of the work automatically
06:33:27 <ivanm> edwardk: what kind of heap do you use? just a binary one?
06:33:30 <edwardk> i do have a known size though, so i could use it to chunk up parallel operations
06:33:32 <Baughn> allbery_b: Ha. I've found that, even after running an API through c2hs, you still need a lot of work to make it haskelly.
06:33:33 <ManateeLazyCat> Baughn: Yes, like allbery_b said, gtk2hs's tool do most work for me. :)
06:33:40 <edwardk> ivanm: bootstrapped skew-binomial
06:33:46 <edwardk> ivanm: hence all the O(1)s
06:33:58 <ManateeLazyCat> Baughn: I just need write some middle code for c2hs.
06:34:11 <ManateeLazyCat> Baughn: Then gtk2hs will generate anything for me. :)
06:34:45 <ivanm> edwardk: wait, the faster version of fromList I was thinking of requires you to know the size of the list (since it's meant for arrays)
06:34:57 <ivanm> damn algorithm and data structure classes that are array-centric :@
06:35:12 <ivanm> I mean, come on, using arrays for stacks/lists/queues? that's just crazy!
06:35:25 <ManateeLazyCat> allbery_b: Have you know any other package than libgtop ? I can compare those libraries. :)
06:35:50 <edwardk> take a binomial heap, use a redundant digit representation (skew-binary) to fix the time it takes to insert to O(1), then take the fixpoint over the heap functor itself
06:36:10 <allbery_b> I mentioned portable libkvm earlier
06:36:16 <Baughn> ManateeLazyCat: For comparison, http://hackage.haskell.org/packages/archive/AES/0.2.6/doc/html/src/Codec-Crypto-AES-IO.htmlhttp://hackage.haskell.org/packages/archive/AES/0.2.6/doc/html/src/Codec-Crypto-AES-IO.html is a C/Haskell binding. Have a look. Note how roughly 80% of the code does /not/ deal with the binding itself, but memory management and such.
06:36:37 <Baughn> ManateeLazyCat: gtop would be simpler, I'll admit, but how much?
06:36:49 <ivanm> edwardk: no merge function (unless you called it something different)
06:36:52 <edwardk> the bootstrapping via fixpoint takes merge down to (1). and findMin down to (1). and deleteMin can't be faster than O(log n) without worsening those others
06:36:55 <edwardk> its meld or mappend
06:36:58 <ivanm> oh, meld?
06:37:21 <edwardk> okasaki/brodal called it meld, i kept the name
06:37:36 <edwardk> and i usually use mappend for it anyways
06:37:36 <ivanm> fair enough
06:37:51 <ivanm> maybe just put something in the comments saying it can be called merge (since wikipedia calls it merge)
06:38:07 <edwardk> or i could just add an alias for it like i did with uncons/viewMin
06:38:14 <ivanm> what's the point of that?
06:38:25 <ivanm> edwardk: I think aliases like that are bad; it unnecessarily clutters the API
06:38:26 <edwardk> to do what the end user expects ;)
06:38:33 <verdelyi> it may be a dumb question, but when using TH, how can a type variable be "not in scope"?
06:38:38 <ivanm> edwardk: that reminds me: what's this annotation stuff you wanted in the graph library?
06:38:40 <ManateeLazyCat> Baughn: I think most glib-base library's binding is good for Haskell, because they hide the platform detail.
06:39:06 <verdelyi> I'm trying to put together something like f :: Program t -> Program t and f = id as a first try
06:39:10 <ManateeLazyCat> Baughn: Like gio binding is good for handle files for different OS.
06:39:34 <edwardk> of course since i have intersection, 'union' also makes sense for its name to match the api from Data.Map/Set/etc which i've been using as my overriding goal
06:39:35 <ManateeLazyCat> Baughn: https://patch-tag.com/r/AndyStewart/gio-branch/home
06:39:46 <edwardk> so i should probably just rename it union
06:39:53 <ManateeLazyCat> Baughn: Example, i have file-manager base on gio, it can works on Linux and Windows. :)
06:40:19 <ivanm> edwardk: wow, group and groupBy return a heap of heaps? :o
06:40:27 <Baughn> ManateeLazyCat: Haskell already has OS-independent dir/file operations, though..
06:40:33 <edwardk> i was having fun with those =)
06:40:50 <ivanm> heh
06:40:51 <ManateeLazyCat> Baughn: Yes, i know, but Linux can't work with unicode files.
06:41:03 <ManateeLazyCat> Baughn: I need much decode/encode work on my gtk2hs program.
06:41:04 <Baughn> ManateeLazyCat: ..huh?
06:41:24 <ivanm> edwardk: that reminds me: what's this annotation stuff you wanted in the graph library?
06:41:36 <Baughn> ManateeLazyCat: Oh. It's not so much that linux can't, as that in unix filenames are encoding-less bytestrings.
06:41:38 <ManateeLazyCat> Baughn: Like `fileDoesExist` and `directoryDoesExist` don't support Chinese file.
06:41:47 <allbery_b> I *think* he means that win32 uses utf16 for file and directory *names*
06:41:49 <ManateeLazyCat> Baughn: Yes, that's exact i mean.
06:41:51 <edwardk> ivanm: its actually not something i want in the normal fgl, it is a very different way of building a graph library that i've been playing with
06:41:58 <p_l> ManateeLazyCat: you mean in filenames? that's configuration error in your system.
06:42:06 <ivanm> ManateeLazyCat: if that's because of the unicode IO stuff, they do... if you write them as a list of bytes first
06:42:06 <ManateeLazyCat> Baughn: Because it's bytestring, i always need decode/encode it.
06:42:10 <ivanm> since that matches the POSIX spec
06:42:10 <allbery_b> although most reasonable systems support utf8 encoding
06:42:17 <ivanm> edwardk: care to explain it?
06:42:21 <ManateeLazyCat> Baughn: And worse is, i don't need transform it on Windows.
06:42:32 <ivanm> hey juhp
06:42:36 <edwardk> that has some advantages in terms of memory footprint, garbage collection and in terms of being able to apply a lot of algorithms online
06:42:36 <ManateeLazyCat> Baughn: So i need write different code for different OS.
06:42:46 <juhp> ivanm: hi
06:42:58 <p_l> ManateeLazyCat: actually, iirc you need to transform it anyway on Windows, and Windows actually is messier, because NTFS has three or four different namespaces for filenames
06:43:12 <ivanm> edwardk: as in, explain what you mean by annotated graphs ;-)
06:43:26 <p_l> ManateeLazyCat: each of them of course requires usage of different encodings
06:43:45 <ManateeLazyCat> p_l: That's why i binding gio, i just need get name `String` from gio's APIs, then put this `String` to gtk2hs functions, don't need decode/encode.
06:43:57 <edwardk> sure. the gist of it is that we separate the shape of the graph from the data in the graph. i.e. you view a graph with values of type 'a' decorating each node as a product of (Graph b, NodeValues a b) -- Graph describes the shape of the graph
06:44:10 <ivanm> juhp: coming online a little late, aren't you?
06:44:25 <juhp> yeah... :)
06:44:25 <edwardk> and NodeValues tell you what values are associated with each node, and 'b' is a type level brand that if you can unify it between the graph and the annotation tell you that the annotation is valid for that graph
06:44:26 <juhp> heh
06:44:33 <edwardk> but you can have a LOT of different kinds of annotations
06:44:35 <ManateeLazyCat> Baughn: p_l Use gio binding, i don't need those dirty decode/encode work.
06:44:39 <edwardk> and the product of annotations is an annotation
06:44:40 <ivanm> edwardk: oh, so the graph is just the actual set of values + set of edges, then you have extra lookup maps?
06:44:58 <ivanm> *extra lookup maps for the labels
06:45:13 <Baughn> ManateeLazyCat: Problem then is, how do you deal with a file whose filename is invalid as utf-8?
06:45:14 <edwardk> and you can update the annotations when you change the shape of the graph (assuming the annotation in question supports that partial operation)
06:45:49 <ivanm> edwardk: you're waving around the term "annotations" without saying what they are ;-)
06:46:15 <edwardk> ivanm: sure, but you can represent a lot of things in annotation for. i.e. you can have an annotation like 'Degree b' that when stuck in the (,) (Graph b) comonad describes the values of the indegree and outdegree for each node in the graph.
06:47:12 <ManateeLazyCat> Baughn: If filename is invalid utf-8, gio APIs return Nothing instead (Just filename)
06:47:14 <edwardk> An annotation is a very simple concept. we've separated out the shape from the data you want to tag the graph with, so it can be an array of values of the same size as your node count, or of your edge count, or it can be a map that associates names to nodes to let you look up nodes or edges quickly...
06:47:51 <Baughn> ManateeLazyCat: Aand.. what do you do then?
06:47:53 <edwardk> it can be an array/vector/rope of all of the indegrees and outdegrees of each node, it can be an array/vector/rope of allof the successors and/or predecessors of each node
06:48:30 <edwardk> when you ask for the graph to add a node, delete a node, etc. you change the brand 'b', and it updates all of the wrapped annotations
06:48:30 <mreh> I was thinking, what does right and left have to do with the operational semantics of foldr and foldl?
06:48:41 <mreh> I thought the answer is "nothing"
06:48:51 <edwardk> ivanm: so each annotation can be quite different
06:48:53 <ivanm> edwardk: so you're wrapping the actual graph data structure with another one that stores extra related stuff?
06:49:01 <edwardk> ivanm: yes
06:49:14 * ivanm isn't sure how possible it would be to generalise this notion of "annotation"...
06:49:23 <ivanm> in terms of writing the code for such a graph type
06:49:24 <edwardk> ivanm: this lets the garbage collector age the 'graph' portion of the graph since it isn't mutating every time i fmap over the thing
06:49:29 <ivanm> that gets automatically updated
06:49:33 <edwardk> ivanm: that is where the comonad comes in
06:50:00 <ivanm> e.g. I add an edge; how do I bump (if necessary) the in/out degrees of the respective nodes?
06:50:14 <edwardk> i have a comonad for (,) (Graph b) -- and a bunch of comonadic operations that tell the annotations about what is happening to the graph
06:50:17 <Baughn> ManateeLazyCat: My point is, you'll have to handle broken filenames /some/how. On linux, it'd be relatively simple.. hm, I'm really not sure what on earth you'd do if copying them to a windows system, though.
06:50:19 <ManateeLazyCat> Baughn: I can catch GError `IoErrorInvalidFilename` that return by GIO, then i will build a function to fix this.
06:50:56 <ManateeLazyCat> Baughn: If all filename is utf-8, that's simple.
06:51:00 <edwardk> you define, say, something like: class Transposable f where transposeA :: Graph a -> Ann a -> Ann (Transpose b)
06:51:15 <Baughn> ManateeLazyCat: Big if. :P
06:51:18 <ManateeLazyCat> Baughn: But i'm not sure have some non-standard problem on Windows. :)
06:51:41 <edwardk> and then transpose :: Transposable f => (Graph a, f a) -> (Graph (Transpose a), f (Transpose a))
06:51:56 <edwardk> which uses the transposeA helper from the annotation
06:52:10 <verdelyi> is this a programming error or some feature that is "not yet implemented"? http://pastebin.com/8QXEafvr
06:52:42 <edwardk> instance Transposable Graph where transposeA g _ = ...; instance Transposable Degree where transposeA _ (Degree in out) = Degree out in
06:52:54 <ManateeLazyCat> Baughn: And another advantage of GIO APIs is it handle international information for files, like this screenshot: http://farm5.static.flickr.com/4027/4584389024_782b1e09ee_o.png
06:52:56 <ivanm> verdelyi: an error
06:53:10 <edwardk> when adding a node you get access to the graph itself as a reference
06:53:23 <edwardk> and a fresh type level brand has to be allocated.
06:53:28 <ivanm> which I think is in a different part of the code
06:53:28 <ManateeLazyCat> Baughn: GIO transform "file description" for Chinese, even internal description is same.
06:53:39 <verdelyi> ivanm: any suggestions then? (If I replace t with mkName String it works)
06:53:40 <ivanm> no, wait, I misread the error
06:53:54 <ManateeLazyCat> Baughn: So i think use GIO's APIs is easier for cross-platform.
06:54:11 <verdelyi> ivanm: that Test.hs just calls $(generateWalkers ...) at line 7
06:54:29 <ivanm> verdelyi: I've never used TH though
06:54:43 <ivanm> verdelyi: ummmm.... so line 7 in that error message doesn't refer to line 7 in that paste?
06:54:55 <ivanm> if so, then it makes it harder to diagnose what the error is
06:55:15 <edwardk> data InsertNode a b = InsertNode {-# UNPACK #-} !Int; class Insertable f where insertA :: InsertNode a b -> Graph a -> f a -> f b
06:55:39 <edwardk> etc.
06:55:40 <ivanm> edwardk: methinks thst that way of doing it requires a lot more work and bookkeeping... >_>
06:55:49 <Saizan> verdelyi: i think you've to use an explicit forall to bring the variable in scope
06:55:51 <edwardk> ivanm: yes and no. there are some very nice advantages here
06:56:01 <edwardk> ivanm: one is that you can do online versions of a lot of algorithms
06:56:17 <ivanm> edwardk: I suppose it means you don't have to explicitly cache or re-compute values
06:56:28 <ManateeLazyCat> Baughn: If in local is English, i think GIO will transform "file description" to "plain text, mp3 audio, pdf document.... "
06:56:29 <ivanm> edwardk: "online versions" == "over the internet"?
06:56:32 <edwardk> ivanm: i.e. calculate minimum spanning trees or strongly connected components and leave that in an annotation that updates as you change the shape
06:56:33 <verdelyi> Saizan: you mean the TH syntax version of forall t . Program t -> Program t?
06:56:45 <Saizan> verdelyi: yeah
06:56:56 <verdelyi> Saizan: ok, I'll try that, thanks
06:56:57 <Saizan> verdelyi: there should be a ForallT
06:57:06 <edwardk> which since you only pay for the annotations you use gives the structure a ton of flexibility in how the end user utilizes the graph library
06:57:28 <ivanm> hmmmmm.....
06:57:39 <ivanm> edwardk: I can see the type sigs getting a bit of a mouthful though...
06:58:32 <edwardk> ivanm: and you get the garbage collection benefits since you can store all the contents of your graph in (potentially unboxed arrays/vectors/ropes) so the graph shape itself isn't getting spammed by gc with fmap generating all sorts of 'shed skin; for the garbage collector
06:59:04 <ivanm> edwardk: yeah, but your annotations on the other hand... ;-)
06:59:05 <edwardk> fgl-style graph algorithms are pretty awful from a gc perspective
06:59:27 <edwardk> ivanm: they are a little odd to work with i admit =)
06:59:47 <ManateeLazyCat> Baughn: http://hackage.haskell.org/package/Crypto-4.2.0 have context i need for process?
06:59:53 <ivanm> eh, the graph stuff I've done so far has had the bottlenecks in other parts of the app
06:59:57 <edwardk> but they also let you do things like say things like given Graph b, if you have a Vertex b then that vertex really DOES exist in _that_ graph. its not just some dumb int label
07:00:04 <ivanm> so FGL algs haven't bothered me yet ;-)
07:00:08 <edwardk> same with Edge b
07:00:19 <ivanm> edwardk: but I find the fgl-style of algs more elegant in how you define and use them
07:00:25 <edwardk> so a bunch of Maybe wrapped edge cases vanish
07:00:34 <ivanm> edwardk: wow, how?
07:00:47 * hackagebot darcs 2.4.3 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.4.3 (EricKow)
07:00:58 <ManateeLazyCat> Baughn: allbery_b thanks for help! :)
07:01:06 <edwardk> ivanm: because those are annotations just like any other and share brands ;)
07:01:45 <ivanm> edwardk: I mean how do you guarantee that a specific vertex exists just by the type sig?
07:02:17 <verdelyi> Saizan: seems to work, thanks!
07:02:27 <Saizan> verdelyi: cheers :)
07:02:29 <edwardk> newtype Vertex b = Vertex Int -- is just a dumb newtype wrapper with a phantom type, but the constructor isn't exposed. the only way to get a Vertex with the same brand as a graph is to have asked that graph for it
07:02:56 <ivanm> edwardk: hmmmm......
07:03:02 <edwardk> i.e. something like vertices :: Graph b -> [Vertex b] -- or using an annotation that attaches names to vertices.
07:03:19 <ivanm> and the phantom type serves the same purpose as say STs parametrised type?
07:03:37 <edwardk> something like data Lookup a b = Lookup (Map a (Vertex b)) -- which is an annotation that can listen in on the shape changes in your graph
07:03:50 <edwardk> ivanm: yep! =)
07:03:51 * ManateeLazyCat I love /proc have many useful information. :) 
07:04:00 <ivanm> edwardk: cool...
07:04:08 <edwardk> ivanm: it is more important here because, being a comonad it is easy to get values out of the comonad.
07:04:26 <ivanm> edwardk: so the only way to get a specific vertex is via something like fgl's matchAny function (or an explicit listing)?
07:04:28 <edwardk> and it is easy to wind up with values with the 'wrong brand' inside your comonad (since every functor is strong)
07:04:32 <ivanm> edwardk: what _is_ a comonad?
07:04:48 <edwardk> ivanm: or graph an id when it is inserted and update that id as you change the graph
07:05:23 <edwardk> class Functor w => Comonad w where extract :: w a -> a; extend :: (w a -> b) -> w a -> w b -- flip the arrows around in a monad
07:05:36 <ivanm> :o
07:05:37 <edwardk> (though you need to swap the order of the args
07:05:55 <edwardk> the comonad in question is rather boring =)
07:05:58 <ivanm> @hoogle Comonad
07:05:58 <lambdabot> No results found
07:06:24 <edwardk> instance Comonad ((,)e) where extract (e,a) = a; extend f ea = (fst ea, f ea)
07:06:45 <ivanm> I was wondering if [a] was a Comonad
07:07:00 <edwardk> ivanm: a non-empty list forms a comonad
07:07:02 * ManateeLazyCat I have cool idea, i can use FileMonitor (https://patch-tag.com/r/AndyStewart/gio-branch/snapshot/current/content/pretty/System/GIO/File/FileMonitor.chs) monitor some files under /proc, then i can just update system information when it's changed...... Haha.... :)
07:07:05 <ivanm> edwardk: I assume MonadPlus monads can't be comonads?
07:07:08 <edwardk> extract [] -- fails
07:07:20 <edwardk> ivanm: because extract mzero :: a =)
07:07:29 <edwardk> ivanm: yes
07:07:30 <adamdunkley> Has anyone had any trouble getting haddock to pick up function argument comments properly when constraints are involved? I am getting some quirky behaviour
07:07:46 <ivanm> that makes sense then
07:07:51 <ivanm> adamdunkley: hmmmm?
07:08:08 <Saizan> adamdunkley: dino- was having the same problem yesterday
07:08:11 <ivanm> IIRC there's a bug in 2.6 haddock where comments on function args are off-by-1...
07:08:16 <edwardk> ivanm: anyways the reason i liked the annotation stuff was because it was an unexplored portion of the design space
07:08:22 <ivanm> that might be what you mean
07:08:24 <adamdunkley> ivanm: Ah, that's the bug I am seeing
07:08:26 <ivanm> (2.7 fixes this apparently)
07:08:35 <ivanm> edwardk: yeah
07:08:37 <adamdunkley> I will update
07:08:42 <adamdunkley> thanks
07:08:58 <edwardk> ivanm: and because i needed to do the same thing with ropes for my compiler ;)
07:09:09 <ivanm> edwardk: I just wonder how something like that will fit into my as-yet-still-vapourware generic graph class library
07:09:14 <ivanm> edwardk: heh
07:10:03 <edwardk> ivanm: *nods* i had an hpaste around here somewhere where i demonstrated the approach just by adapting the simple api in Data.Graph as a starting point for discussion
07:10:18 <ivanm> edwardk: yeah, I think that's what tomberek linked me to
07:10:27 <ivanm> except I had nfi what you were trying to do there ;-)
07:10:31 <edwardk> do you have the link? i can confirm one way or the other
07:10:45 <edwardk> does it at least seem less crazy now?
07:10:53 <ivanm> no, don't think I've got it anymore
07:11:00 <ivanm> and yeah, I get what you're talking about
07:11:08 <ivanm> and I agree, it's an interesting area to explore
07:11:29 <edwardk> with ropes i'm doing the same thing by attaching annotations that as you remove chunks or add chunks to the rope update themselves
07:11:41 <edwardk> so it is the same machinery just applied to a 'different shape'
07:12:12 <ManateeLazyCat> Baughn: You're right, write Haskell parser for /proc is simple and safer than binding. :)
07:12:35 <ivanm> @time
07:12:36 <lambdabot> Local time for ivanm is Mon May 10 00:12:11
07:12:39 * ivanm should hit the sack
07:12:41 <ivanm> g'night all
07:12:54 <ManateeLazyCat> Baughn: I just need scan /proc i can get any information i want. :)
07:13:09 <ManateeLazyCat> ivanm: Good night, bye. :)
07:13:27 <Baughn> I don't want to say "told you so", but..
07:13:33 <edwardk> that way i can summarize deltas in file positions, knowledge of macro expansion, etc. as annotations on a rope factoring them out of parsers. i'm thinking with clever library design you can get much the same benefit with factoring out a bunch of algorithms/structures that you need quick access to into annotations on an ever changing graph
07:13:43 <edwardk> night ivanm
07:15:22 <ManateeLazyCat> Baughn: en.wikipedia.org/wiki/Procfs#Linux is i want. :)
07:16:08 <Baughn> Indeed.
07:16:44 <ManateeLazyCat> Baughn: I plan to write some haskell package to parse /proc, anyone has do that?
07:16:58 <ManateeLazyCat> Baughn: Just confirm to avoid duplicate work. :)
07:17:08 <ManateeLazyCat> @package procs
07:17:08 <lambdabot> http://hackage.haskell.org/package/procs
07:17:11 <applicative> apfelmus, how did you build the Hcode editor in Xcode?
07:26:21 <Entroacceptor> arg, found it...
07:26:33 <Entroacceptor> it seems like the program outputs to stderr for some reason ^^
07:27:00 <Entroacceptor> or (inp, out, err, pid) <- runInteractiveCommand is in the wrong order
07:30:44 <ManateeLazyCat> Baughn: Looks some file dump from memory, such as /proc/PID/pagemap.
07:30:45 <ManateeLazyCat> :)
07:32:42 <TheDoctor> Who is behind cufp?
07:33:12 <Axman6> do you need to know to save the world?
07:33:13 <Axman6> again?
07:33:19 <Saizan> daleks?
07:33:36 <ManateeLazyCat> Saizan: Doctor Who?
07:33:51 <Saizan> ManateeLazyCat: yeah :)
07:34:04 <ManateeLazyCat> Saizan: I love daleks, so cute. :)
07:34:28 <ManateeLazyCat> Saizan: Are you my mami? Do you remember that?
07:34:52 <orlandu63> how would one get a contents of a url in haskell?
07:36:59 <TheDoctor> I was referring to cufp.org
07:38:40 * ManateeLazyCat Daleks: destruction, destruction, destruction ...... :)
07:38:54 <TheDoctor> It is "exterminate".
07:39:46 <ManateeLazyCat> void: Oh, i found you, are you doctor?
07:40:24 * ManateeLazyCat I just found TheDoctor this nickname. :)
07:40:40 <byorgey> orlandu63: try the curl library, it's pretty easy to use
07:40:55 <void> ... is there anyone not obsessed with nick names>
07:40:56 <void> ?
07:40:57 <byorgey> @hackage curl
07:40:58 <lambdabot> http://hackage.haskell.org/package/curl
07:41:36 <Saizan> void: i think we just don't know :)
07:41:38 <byorgey> void: what do you mean who is "behind it"?
07:41:53 * ManateeLazyCat lol .... :) 
07:42:31 <void> byorgey: I mean, who pays for it, I suppose.
07:42:59 <void> byorgey: it says sponsored by janestreet, but does that mean they actually control it also.
07:54:18 <ManateeLazyCat> Looks process-monitor can't cross-platform, except write different code for different OS.
07:57:11 * hackagebot heaps 0.2 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.2 (EdwardKmett)
07:58:33 <edwardk> now with the shiny new adjustMin and sort operations
07:59:37 <deech> Hi all, I am trying to compile HaRe. It fails to because it uses "Control.Monad.Identity" which it finds in both transformers and mtl. Should i prefer one over the other?
08:00:02 <orlandu63> byorgey: awesome, thanks
08:01:57 <edwardk> deech: prefer mtl in general for now easiest way is to hide transformers, or use cabal which will take care of that for you
08:03:55 <deech> edwardk: will that break packages which depend on transformers?
08:06:12 <edwardk> deech: the way things work right now you can only link libraries that depend upon one or the other into a given application, but you can have more than one installed.
08:06:34 <deech> edwardk: cool thanks...
08:10:16 <ManateeLazyCat> /proc/PID/stat is enough for simple process-manager. :)
08:12:41 * ManateeLazyCat Reading "man proc" line by line ..... 
08:14:38 <tibbe> @seen dons
08:14:39 <lambdabot> Unknown command, try @list
08:14:45 <tibbe> preflex: seen dons
08:14:45 <preflex>  dons was last seen on #haskell 19 hours, 59 minutes and 34 seconds ago, saying: aavogt: hmm
08:14:50 <ManateeLazyCat> preflex @seen dons
08:14:50 <preflex>  dons was last seen on #haskell 19 hours, 59 minutes and 39 seconds ago, saying: aavogt: hmm
08:24:14 <ManateeLazyCat> Should haven't any utf-8 files in /proc? If so, i don't need GIO APIs, `System.Directory` is enough.
08:25:37 <ulfdoz> ManateeLazyCat: Expect the unexpected, but I'm not aware of a case, where it happened to be.
08:25:47 <FliPPeh> Let's say I have a function ("Int -> Int", maybe square), and in another function (a recursive loop maybe), it get's called 1000000 times
08:26:00 <FliPPeh> Is GHC smart enough to just replace the function call with the value at compile time?
08:26:28 <FliPPeh> Needless to say, always the same value to be squared
08:26:30 <ezyang> In many cases, no, but you can easily memoize it.
08:26:37 <ManateeLazyCat> ulfdoz: I scan files under /proc , looks just ASCII, haven't found ut-8 files.
08:26:50 <ezyang> http://www.haskell.org/haskellwiki/Memoization
08:27:06 <benmachine> FliPPeh: some example code would be helpful
08:27:08 <ManateeLazyCat> ulfdoz: If have utf-8 files, `System.Directory` maybe can't wok with those files.
08:27:20 <benmachine> often what you can do is move the calculation outside the recursion
08:27:26 <FliPPeh> benmachine: There is no example :) I'm just curious
08:27:33 <opqdonut> FliPPeh: it might a) inline the square b) float the square outside the relevant lambda
08:29:26 <benmachine> FliPPeh: well, instead of main = putStrLn (4*4) >> main; you could do main = loop where sq = 4 * 4; loop = putStrLn sq >> loop
08:29:41 <benmachine> for example
08:33:02 <ManateeLazyCat> Under linux, i want list all executive file, i do like this: "echo $PATH ==> pick up directories ==> remove duplicate => scan files in those directores". Have better solution?
08:36:15 <void> ManateeLazyCat: do you want a Haskell solution or bash?
08:36:41 <ManateeLazyCat> void: No, i want build a gtk2hs program like Mac's "quicksilver"
08:36:58 <void> ManateeLazyCat: oh, great, you have now lost me :)
08:37:23 <ezyang> ManateeLazyCat: I don't think that's a bad solution.
08:37:30 <ManateeLazyCat> void: When you input something, it filter with regex, then type RETURN will start that program or running in temrinal.
08:37:45 <ezyang> You might check what XMonad.Prompt does, since it does something similar
08:37:55 <ManateeLazyCat> ezyang: Ok, i will.
08:38:04 <void> ManateeLazyCat: ah, ok, but what is hard about that?
08:38:06 <ManateeLazyCat> ezyang: I just wonder have any secret tips. :)
08:38:16 <Entroacceptor> xmonad uses bash for that, IIRC
08:38:19 <ManateeLazyCat> void: I have many idea.
08:38:26 <void> If he had, they wouldn't be secret.
08:38:26 <ManateeLazyCat> void: Do you use anything.el in Emacs?
08:38:40 <void> ManateeLazyCat: I don't think I do.
08:39:31 <ManateeLazyCat> void: When i type anything, it will search "local files, browser history, execute file, file history, music list, ...." and then start special command with those match candidnates.
08:40:06 <void> ManateeLazyCat: isn't that slow?
08:40:24 <ManateeLazyCat> void: So it's idea is, search anything to match user input, then add many command for different use.
08:40:27 <ezyang> You'll definitely want to index the crap out of it.
08:41:06 <void> So, you can do something like SPJ and recognize it is a name, and show the mail command?
08:41:06 <ManateeLazyCat> void: I will make those search asynchronous, every search thread will *append* information.
08:41:18 <ManateeLazyCat> void: Yes.
08:41:41 <void> ManateeLazyCat: and do you want to make money of this?
08:41:47 <ManateeLazyCat> void: No,
08:41:54 <ManateeLazyCat> void: GPL3
08:42:12 <ManateeLazyCat> void: Infact, this "quicksilver" tools just a *little* sub-module in my project.
08:42:22 <pikhq> ManateeLazyCat: GPL3 != cannot make money.
08:42:22 <pikhq> ;)
08:42:30 <ManateeLazyCat> pikhq: Really?
08:42:43 <void> ManateeLazyCat: ok, if you do it right it could be useful, but I think it is hard to figure out what exactly is useful.
08:43:03 <void> pikhq: name one company that works in that way.
08:43:06 <ManateeLazyCat> pikhq: My aim is use Haskell/Gtk+ build a fast, stable, extension SoftOS for haskeller to hacking.
08:43:33 <ManateeLazyCat> void: I don't think, i have develop same feature in Emacs.
08:43:40 <ManateeLazyCat> void: It's named anything.el
08:43:41 <pikhq> void: *cough*Red Hat*cough*
08:44:08 <void> pikhq: if their software would be perfect, nobody would buy support.
08:44:18 <void> pikhq: the model encourages broken software.
08:44:51 <ManateeLazyCat> void: I use anything.el search "files, buffers, history, brow-list, music, man, snippets, bookmark, info, tags, occur, process, tracker.... " in Emacs.
08:44:54 <void> The "bugs could strike any moment" is the same model as the mafia uses.
08:44:59 <ManateeLazyCat> void: So i know how to implement those in gtk2hs.
08:45:02 <pikhq> void: Most software business models do.
08:45:21 <void> pikhq: which is why I am glad I can program :)
08:45:32 <pikhq> :)
08:46:09 <ManateeLazyCat> pikhq: I have building my project, i can release it soon after gtk2hs release next version.
08:46:25 <ManateeLazyCat> pikhq: I want to make it *free* completely.
08:46:48 <ManateeLazyCat> pikhq: Most important is i want it under GPL3.
08:47:05 <ManateeLazyCat> pikhq: BTW, i really don't know how to get money under GPL3. :)
08:47:46 <siracusa> ManateeLazyCat: Has Axel checked your cabalized versions already?
08:48:23 <ManateeLazyCat> siracusa: Yes, we have finish all package (except gstreamer) at last week.
08:48:28 <deech> Hi all, Hayoo appears to be down. downforeveryoneorjust me confirms.
08:48:28 <pikhq> ManateeLazyCat: Charge money.
08:48:33 <pikhq> It's pretty simple.
08:48:36 <ManateeLazyCat> siracusa: Check gtk2hs repository, i have push all cabal patches.
08:48:37 <pikhq> :P
08:48:53 <siracusa> ManateeLazyCat: Fine, I will do so
08:49:26 <ManateeLazyCat> pikhq: No, this project is my dream, i have studying many years is for it. I want to develop it for money.
08:49:59 <ManateeLazyCat> pikhq: Of course, i'm appreciated if someone want help me. :)
08:50:19 <ManateeLazyCat> siracusa: Just one thing, don't use gtk2hs with ghc-6.12.2
08:50:37 <ManateeLazyCat> siracusa: ghc-6.12.2 has Runtime-System bug that break gtk2hs callback.
08:50:56 <ManateeLazyCat> siracusa: Use ghc-6.10 or ghc-6.12.1 instead.
08:51:00 <siracusa> ManateeLazyCat: Yep, I know this bug
08:51:16 <ManateeLazyCat> siracusa: Looks Simon has fix this bug in 6.12.3, but i haven't time check it yet.
08:51:34 <ManateeLazyCat> siracusa: I have test 6.12.1 with newest gtk2hs, works fien.
08:52:08 <ManateeLazyCat> siracusa: Get gtk2hs code and do "./bootstrap.sh", this script will install everything for you. :)
08:52:22 <ManateeLazyCat> siracusa: You don't need cd sub-dir and do "cabal install" one by one. :)
08:53:12 <ManateeLazyCat> siracusa: If you cant access code.haskell.org, use my mirror repository: https://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror/home
08:53:18 <ManateeLazyCat> siracusa: That's all. :)
08:54:01 <siracusa> ManateeLazyCat: Do I need some extra C libraries except for Gtk+?
08:56:43 <ManateeLazyCat> siracusa: Which OS are you use?
08:56:54 <siracusa> ManateeLazyCat: WinXP
08:57:35 <ManateeLazyCat> siracusa: Unfortunately, Windows just can install core-packages: (glib, pango, cairo, gtk)
08:57:58 <ManateeLazyCat> siracusa: I have seen someone build core-packages on Windows,
08:58:16 <ManateeLazyCat> siracusa: But i'm not sure non-core packages can install correctly.
08:58:35 <ManateeLazyCat> siracusa: Unfortunately, most gtk2hs developer (I and Axel) haven't Windows for test.
08:59:04 <siracusa> ManateeLazyCat: Is the OpenGL support included in glib?
08:59:53 <ManateeLazyCat> siracusa: OpenGL package in gtk2hs is `gtkglext`.
09:00:17 <ManateeLazyCat> siracusa: I have test all cabal packages under Ubuntu/Linux, works fine.
09:00:29 <ManateeLazyCat> siracusa: But i really don't know Windows situation.
09:00:42 <siracusa> ManateeLazyCat: But that worked in earlier versions of gtk2hs on Windows
09:01:02 <siracusa> ManateeLazyCat: Ok, I will try and see what happens :-)
09:01:05 <ManateeLazyCat> siracusa: If you install gtkglext, you need make sure you have `gtk/gtkgl.h` in your path.
09:01:48 <ManateeLazyCat> siracusa: Most problem on Windows is not code break, is header file path problem.
09:02:24 <ManateeLazyCat> siracusa: If you can make cabal find header file in right place, everything should be fine.
09:02:45 <siracusa> ManateeLazyCat: Ok, thanks
09:03:08 <ManateeLazyCat> siracusa: If you have time, please help me test gtk2hs (best is all packages) on Windows.
09:03:31 <ManateeLazyCat> siracusa: It's better if you can send patches to fix gtk2hs with Windows.
09:04:08 <ManateeLazyCat> siracusa: Even better if you can package gtk2hs to .exe file on Windows :)
09:05:17 <siracusa> ManateeLazyCat: Oh, I don't know how to do that, is there a flag to make a .exe package of it?
09:05:33 <ManateeLazyCat> siracusa: Haven't yet.
09:06:10 <ManateeLazyCat> siracusa: Have people help us make gtk2hs works on Mac, and unfortunate for Windows.
09:06:59 <siracusa> ManateeLazyCat: Let me try a normal build, if that works we can talk about creating an installer :-)
09:07:09 <ManateeLazyCat> I'm curious how many gtk2hs user on Windows, much than Linux?
09:07:18 <ManateeLazyCat> siracusa: Ok, thank.
09:07:52 <ManateeLazyCat> I just can promise that make gtk2hs install on Linux.
09:14:12 <ManateeLazyCat> void: Doctor, you can anything.el from my emacs homepage: http://www.emacswiki.org/emacs/AndyStewart
09:14:43 <ManateeLazyCat> void: http://www.emacswiki.org/emacs/Anything have detail "what's anything.el"
09:15:30 <void> ManateeLazyCat: that needs a video.
09:16:07 <ManateeLazyCat> void: Have you use quicksilver in Mac ?
09:16:14 <ManateeLazyCat> void: Or Gnome-Do ?
09:16:17 <void> ManateeLazyCat: and way too many words say what Emacs currently does. Words that can also be used to describe Anything.
09:16:25 <void> ManateeLazyCat: I already said that I didn't.
09:16:40 <void> ManateeLazyCat: Gnome-do? /me installs.
09:16:50 <ManateeLazyCat> void: Yes, i agree http://www.emacswiki.org/emacs/AndyStewart#toc15
09:17:23 <ManateeLazyCat> void: I'm bulid an environment that can do *anything* , not like Emacs. :)
09:18:46 <ManateeLazyCat> void: Just like gnome-do search for you, but give you list for work effective, here has screenshot : http://www.emacswiki.org/emacs/AutoInstall#toc8
09:19:20 <dmwit> Does anybody know the meaning of a Gtk2Hs TimeStamp?
09:19:41 <dmwit> Can it overflow during a program if I start the program at just the right time?
09:19:44 * ManateeLazyCat After reading all "man proc", plan to write a simple Haskell module to parse files under /proc, then i can build a simple-manager".
09:20:30 <ManateeLazyCat> dwon: Maybe you need send your program, looks like gtk2hs's bug.
09:21:04 <ManateeLazyCat> dmwit: Maybe in some code of gtk2hs, that use wrong type return Time.
09:21:46 <dmwit> ManateeLazyCat: yeah... it's what Gtk2 does, though
09:22:02 <dmwit> The gtk documentation doesn't say much about it, either.
09:22:21 <ManateeLazyCat> dmwit: Which functions?
09:22:29 <ManateeLazyCat> s/functions/function
09:22:30 <dmwit> eventTime in gtk2hs
09:23:25 <ManateeLazyCat> dmwit: Events or EventM ? Events was departed.
09:23:52 <dmwit> gtk_get_current_event_time
09:24:00 <ManateeLazyCat> dmwit: type TimeStamp = Word32
09:24:03 <dmwit> eventTime :: HasTime a => EventM a TimeStamp
09:24:12 <ManateeLazyCat> dmwit: Yes, use EventM always.
09:24:20 <ManateeLazyCat> -- | The time (in milliseconds) when an event happened. This is used mostly
09:24:20 <ManateeLazyCat> -- for ordering events and responses to events.
09:24:21 <ManateeLazyCat>  
09:25:01 <dmwit> It seems like I can't rely on it always increasing. OK
09:25:32 <ManateeLazyCat> dmwit: Above documentation is you need?
09:25:48 <dmwit> good enough, thanks =)
09:25:56 <ManateeLazyCat> dmwit: NP :)
09:26:52 * ManateeLazyCat Please let me if have somebody have parse /proc , then i can steal it. :)
09:28:57 * ManateeLazyCat let me know.
09:29:22 * ManateeLazyCat Ooops, typo 
09:50:36 <ManateeLazyCat> Wow, htop is awesome, maybe i can do same thing in gtk2hs. :)
09:51:07 <edwardk> preflex: xseen jbapple
09:51:08 <preflex>  jbapple was last seen on freenode/#haskell 12 hours, 6 minutes and 14 seconds ago, saying: here's a page for fixing haskeline, but I think 6.10 uses the regular readline: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
09:51:37 <ksf> every time I want to do something interesting with types, what I want to do turns out to be too complicated for the type system.
09:53:06 <ksf> ...all I want to do is scatter unsafeCoerces through types because of that bleeding GLdouble, but those Functor and BiFunctor instances keep overlapping in places.
09:53:32 <ksf> ...not that I care, they should behave the same, but not even IncoherentInstances makes ghc select one.
09:54:10 <ksf> I'd use assoc types, but those ignore contexts, too.
09:54:55 <ksf> maybe we should conspire against spj and ignore context while talking with him, I think he'd get the message.
09:59:29 * Saizan refrains from suggesting a newtype wrapper
10:00:12 <ksf> what I still don't know is whether I'm supposed to use GLdouble etc. throughout the whole program, or just when calling gl functions... the first approach works ifffff you don't need exotic classes that happen to have hidden members and aren't defined for GL types.
10:00:13 <siracusa> ManateeLazyCat: I'm missing demos in gtk2hs/demo -- have you removed some?
10:00:32 <ManateeLazyCat> siracusa: I move some demo to it's own directory.
10:00:46 <ManateeLazyCat> siracusa: Looks other non-core packages.
10:01:14 <siracusa> ManateeLazyCat: Ah, I see
10:01:27 <benmachine> ksf: I reckon in the latter case it'd be a good idea to ask the relevant library authors to make an .Internal module or something
10:01:29 <ManateeLazyCat> siracusa: Maybe it's a bad idea, because some demo hard to sort.
10:01:35 <ksf> I can't define instances for VertexComponent Double, either.
10:01:43 <benmachine> which exposes everything you like
10:01:50 <ManateeLazyCat> siracusa: Maybe we need move all demos to a standalone package "gtk2hs-demo"
10:02:34 <ksf> I think the hopengl devs have recieved a fair amount of flak by now, but they're unconvincible.
10:02:57 <benmachine> what exotic classes were you talking about?
10:03:02 <ManateeLazyCat> ksf: gtkglext in gtk2hs?
10:03:31 <ksf> linear algebra packages, in general
10:04:06 <ksf> hmatrix comes to mind.
10:04:14 <benmachine> well, shouldn't they export the stuff necessary for you to make instances?
10:04:29 <ksf> yes... and so should opengl
10:04:39 <ManateeLazyCat> siracusa: Have you install gtk2hs on Windows successful?
10:05:12 <ksf> opengl shouldn't hide the newtype wrapper for GLdouble, either, so one doesn't have to unsafeCoerce to get conversions that aren't way too slow.
10:05:43 <benmachine> I thought the point of the newtype wrapper is that the underlying type isn't guaranteed to be a Double
10:05:50 <benmachine> it's required to be a certain width or something
10:05:53 <siracusa> ManateeLazyCat: No, I won't try today. I once tried to build an old version and it took hours on my system. :-(
10:06:09 <benmachine> so unsafeCoerce and that sort of thing is unportable
10:06:16 <ManateeLazyCat> siracusa: Hours?
10:06:42 <benmachine> but then it wouldn't hurt to expose translation functions that were secretly newtype unwrappers (i.e. compiled away)
10:07:08 <ManateeLazyCat> siracusa: "Wallace, Malcolm" <Malcolm.Wallace@sc.com> This guy have make gtk2hs install on Windows.
10:07:19 <ksf> gpipe uses type families to translate cpu to gpu types
10:07:31 <ManateeLazyCat> siracusa: Maybe you can ask him how to make gtk2hs works on Windows.
10:07:32 <ksf> ...it calls GLdouble "GPU Double"
10:07:38 <siracusa> ManateeLazyCat: Has he build an installer?
10:07:46 <benmachine> that's an interesting approach
10:08:03 <edwardk> ksf: i like that
10:08:05 <siracusa> ManateeLazyCat: Or tried to build one
10:08:11 <ksf> which means "that what I send to the GPU if you give me a double"
10:08:39 <ksf> ...as you can't really make guarantees about those GPU floats, at least not if the card is pre-cuda
10:08:57 <ManateeLazyCat> siracusa: I don't know detail, he just said "I can report that glib, cairo, and pango all build fine for me on
10:08:57 <ManateeLazyCat> Windows now."
10:08:58 <ManateeLazyCat>  
10:08:59 <ksf> rounding modes, odd precision, general non-IEEEness etc.
10:10:54 <ksf> coffee.
10:13:55 <ManateeLazyCat> siracusa: http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00736.html
10:14:17 <ManateeLazyCat> siracusa: The recent list for how to make gtk2hs works on Windows
10:15:06 <ManateeLazyCat> siracusa: Maybe it's a bug of "cabal", and not just gtk2hs's problem.
10:18:32 <ManateeLazyCat> siracusa: Axel said "Malcolm" is a professor that just care how to make `soegtk` works on Windows. :)
10:28:03 * hackagebot carboncopy 0.1 - Drop emails from threads being watched into special CC folder.  http://hackage.haskell.org/package/carboncopy-0.1 (EugenyDzhurinsky)
10:33:05 * hackagebot happstack-helpers 0.51 - Convenience functions for Happstack.  http://hackage.haskell.org/package/happstack-helpers-0.51 (ThomasHartman)
10:34:05 * hackagebot happs-tutorial 0.9.4 - A Happstack Tutorial that is its own web 2.0-type demo.  http://hackage.haskell.org/package/happs-tutorial-0.9.4 (ThomasHartman)
10:46:09 * hackagebot HAppSHelpers 0.11 - OBSOLETE. Please use happstack-helpers  http://hackage.haskell.org/package/HAppSHelpers-0.11 (ThomasHartman)
10:46:11 <kowey> "darcs-2.4.3 failed during the configure step. The exception was: ExitFailure 127" is making Darcs hackers said :-(
10:46:11 <preflex>  kowey: you have 1 new message. '/msg preflex messages' to read it.
10:46:23 <kowey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25412#a25412
10:47:49 <kowey> I'll add that runghc Setup configure, etc seems to work
10:55:13 <Saizan> kowey: it seems to work fine here
10:55:55 <kowey> thanks... in recent news, gh_ reports that dist/setup/setup is an empty file
10:56:55 <kowey> *nice*, I can reproduce this on Ubuntu 10.04 (Lucid Lynx) [which is what gh_ was running too]
10:57:22 <gh_> nice
10:57:24 <Saizan> can ghc compile any files there?
10:57:35 <Saizan> s/files/programs/
10:57:40 <kowey> yeah, I just tried by hand to compile Setup.lhs
10:59:07 <kowey> gh_: it appears I can build darcs outside of the tmp directory
10:59:16 <gh_> hmmm
10:59:34 <gh_> how could i not mention i uncompressed the archive in /tmp ?
10:59:37 <kowey> (I had linked to http://www.haskell.org/pipermail/haskell-cafe/2010-April/076192.html found via Google earlier, but it seemed to be a dead end)
11:05:17 <dmwit> What could a program do that would cause it's controlling shell to exit?
11:05:39 <mauke> kill getppid()
11:05:58 <dmwit> hm
11:06:08 <olsner> write +++ATD do stdout perhaps
11:06:15 <dmwit> I have a gtk program which reliably ends the urxvt I run it from.
11:06:36 <gh_> i confirm it works if the source is outside of  /tmp
11:06:50 <dmwit> But I don't import anything from the System hierarchy anywhere.
11:07:07 <olsner> dmwit: if you start another inner shell in the urxvt before starting, does it still close the terminal or just the shell?
11:07:18 <dmwit> Good idea, let me try.
11:07:20 <ezyang> It could have been imported by a module you use?
11:08:08 <dmwit> hm
11:08:14 <dmwit> Now I can't reproduce the problem at all.
11:09:40 <olsner> hmm, so starting another shell changes the environment (in the broader sense, not just getenv())... one thing to try, run env before and after the inner shell, diff the output
11:10:14 <dmwit> I mean, I can't even reproduce killing one layer of shell.
11:10:17 <dmwit> I'm so confused.
11:14:17 <rajeshsr> is there a function like foldl that gives a list of intermediate values?
11:14:22 <aavogt> scanl
11:14:33 <rajeshsr> aavogt, thanks!
11:15:01 <aavogt> @type foldl
11:15:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:15:10 <aavogt> @hoogle (a -> b -> a) -> a -> [b] -> [a]
11:15:11 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
11:15:12 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
11:15:12 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
11:15:27 <aavogt> rajeshsr: or hoogle can find such functions too
11:16:20 <rajeshsr> aavogt, thats amazing! So giving a type, hoogle lists functions?
11:16:46 <aavogt> if they exist and are indexed
11:16:59 <roconnor> rajeshsr: not as amazing as djinn
11:17:10 <ezyang> @djinn a -> a
11:17:10 <lambdabot> f a = a
11:17:18 <rajeshsr> aavogt, thats obvious!
11:17:33 <ezyang> @djinn (a -> b) -> a -> b
11:17:34 <lambdabot> f a = a
11:17:35 <mauke> @djinn (b -> c) -> (a -> b) -> a -> c
11:17:36 <lambdabot> f a b c = a (b c)
11:17:46 <dmwit> Much more useful than djinn, though.
11:18:13 <roconnor> @djinn (((a -> b -> a) -> b) -> (a -> b) -> a) -> (a -> b) -> a
11:18:13 <lambdabot> -- f cannot be realized.
11:18:15 <rajeshsr> i don't get what djinn is doing!
11:18:28 <roconnor> @djinn ((((a -> b) -> a) -> b) -> (a -> b) -> a) -> (a -> b) -> a
11:18:28 <lambdabot> f a b = a (\ c -> b (c b)) b
11:18:38 <aavogt> is that supposed to be =<< for Cont?
11:18:41 <ezyang> That... is callcc?
11:18:42 <mauke> rajeshsr: generates codes from types
11:18:52 <roconnor> @djinn ((Either a (a -> b)) -> b) -> b
11:18:52 <lambdabot> f a = a (Right (\ b -> a (Left b)))
11:19:25 <roconnor> say you want to know the map function for the continuation monad
11:19:27 <aavogt> @djinn Int -> Int -> Int
11:19:27 <lambdabot> Error: Undefined type Int
11:19:40 <ezyang> @djinn ((a -> b -> r) -> a -> r) -> a -> r
11:19:41 <lambdabot> -- f cannot be realized.
11:19:44 <roconnor> @djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
11:19:44 <lambdabot> f a b c = b (\ d -> c (a d))
11:24:55 <dmwit> :t \f a b c -> f <$> a <*> return b <*> c
11:24:56 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f, Monad f) => (a -> a1 -> a2 -> b) -> f a -> a1 -> f a2 -> f b
11:25:21 <Baughn> @hoogle default
11:25:21 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
11:25:21 <lambdabot> Text.Regex.Base.RegexLike defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt
11:25:21 <lambdabot> Codec.Compression.GZip DefaultCompression :: CompressionLevel
11:25:35 <aristid> @src maybe
11:25:36 <lambdabot> maybe n _ Nothing  = n
11:25:36 <lambdabot> maybe _ f (Just x) = f x
11:25:44 <dmwit> ?hoogle f (a -> b) -> a -> f b
11:25:45 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:25:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
11:25:45 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:27:38 <aristid> :let default' = flip maybe id
11:27:51 <aristid> or was it @let?
11:28:01 <dmwit> the latter
11:28:04 <ddarius> rajeshsr: Djinn is a simple theorem prover for a relatively simple logic.
11:28:06 <aristid> @let default' = flip maybe id
11:28:07 <lambdabot>  Defined.
11:28:24 <aristid> > default' 4 Nothing
11:28:25 <lambdabot>   4
11:28:30 <ddarius> aristid: That's fromMaybe
11:28:31 <dmwit> > fromMaybe 4 Nothing
11:28:32 <lambdabot>   4
11:28:40 <aristid> @src fromMaybe
11:28:40 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
11:28:42 * Baughn wonders if Data.Default should be in the standard library
11:28:44 <rajeshsr> ddarius, oh, ok! so how does that work? any doc on that?
11:28:48 <aristid> ddarius: ah :)
11:31:06 <dmwit> ?instances Applicative
11:31:07 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:31:18 <dmwit> ?instances-importing Control.Applicative Control.Monad.Reader Applicative
11:31:19 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
11:31:43 <ddarius> @google Contraction-free calculi for intuitionistic logic
11:31:43 <dmwit> No ReaderT instance, eh?
11:31:43 <aavogt> @src Const
11:31:46 <lambdabot> http://www.cs.st-andrews.ac.uk/~rd/publications/jsl57.pdf
11:31:46 <lambdabot> Title: Contraction-Free Sequent Calculi for Intuitionistic Logic Author(s): Roy Dyckhof ...
11:31:46 <lambdabot> Source not found. Take a stress pill and think things over.
11:31:57 <ezyang> You know what would be neat? A list of standard typeclasses that you should always see if you can write an instance for your data type.
11:32:21 <dmwit> Well, there's byorgey's excellent Typeclassopedia.
11:32:24 <aavogt> so just filter by kinds?
11:32:57 <ezyang> aavogt: Sure.
11:33:10 <ezyang> dmwit: Yes, that would be a fine start.
11:33:37 <ezyang> bah, Hoogle doesn't support kind search
11:33:50 <aavogt> beyond that, I'm not sure how you could help narrow down the options
11:34:30 <aavogt> that is, don't suggest to write instances of Arrow when your data type takes less than two parameters
11:34:42 <aavogt> though you could wrap your data with a newtype....
11:34:57 <ezyang> Well, a container-directed approach might look at what the data constructors look like.
11:35:43 <dmwit> ?pl \f x -> f `ap` return x
11:35:44 <lambdabot> (. return) . ap
11:36:05 <dmwit> :t \f x -> f `ap` return x
11:36:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
11:36:08 <dmwit> :t (=<<)
11:36:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:36:49 <ezyang> And you could use combinatorial species as another way of generating "fingerprints" for datatypes
11:36:55 <burp> :t runStateT
11:36:56 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:48:06 <Athas> Is there a Read instance for Doubles that accepts both fractional and decimal fraction notation?
11:49:00 <aavogt> > read "1 / 2" :: Double -- so this should work?
11:49:01 <lambdabot>   *Exception: Prelude.read: no parse
11:49:18 <applicative> It doesn't work.
11:49:34 <ezyang> > read "1%2" :: Rational
11:49:34 <lambdabot>   1 % 2
11:49:38 <aavogt> but that's the format you're asking for, Athas?
11:49:50 <dmwit> > read "1 % 2" :: Rational -- ?
11:49:51 <lambdabot>   1 % 2
11:49:53 <dmwit> neat
11:50:22 <applicative> how do you ask for instances of Read?
11:50:28 <applicative> @instances Read
11:50:28 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:50:42 <ezyang> applicative: If Read can infer it from the surrounding code, no need.
11:50:54 <ezyang> Otherwise, bracket expr with (read expr :: TypeYouWant)
11:51:00 <Athas> aavogt: I'm not sure what the whitespace rules should be, but at least "1/2" should work.
11:51:08 <fishey> > read "1/2" :: Double
11:51:09 <lambdabot>   *Exception: Prelude.read: no parse
11:51:13 <applicative> I see, if I use fractional notation where it is a double
11:51:17 <ezyang> Personally, you should run away from read as soon as possible.
11:51:25 <ezyang> > read "1%2" :: Double
11:51:25 <lambdabot>   *Exception: Prelude.read: no parse
11:51:36 <fishey> it may only like decimal form.
11:51:39 <applicative> > read "1/2" + 1.2
11:51:39 <lambdabot>   *Exception: Prelude.read: no parse
11:51:40 <ezyang> > fromRational (read "1%2") :: Double
11:51:40 <lambdabot>   0.5
11:51:55 <fishey> hehe... there we go.
11:51:56 <ezyang> tada!
11:53:48 <applicative> The Num class is such a nightmare.  I'd rather stick to 'data Peano where...'
11:54:13 <dmwit> There's a module for that.
11:54:26 <applicative> I write it all the time...
11:54:49 <aavogt>  module Peano.Player ...
11:55:01 <aavogt> Athas: I guess you have to write that parsing function yourself
11:55:41 <Athas> Yeah, no big deal.  It just isn't the first time I have to do that...
11:56:18 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25413 <-- Surely I'm missing something basic. Why does the second invocation block, here?
11:56:46 <applicative> What is the standard way to do that so that it's easily integrated, do you make a newtype for Double or something and then a Read instance?
11:57:31 <Baughn> ..gah
11:57:41 <Baughn> It doesn't just /block/, it /uses 100% of my cpu/
11:58:28 <aavogt> applicative: then you have to unwrap the newtype to get at the actual Double... it's probably easier to have a free function   readPermissive
11:58:43 <aavogt>  :: String -> Maybe Double
11:59:18 <dmwit> Baughn: You probably shouldn't pass the same invariant to "always" many times.
11:59:36 <dmwit> Baughn: That is probably not what's going wrong here, but just thought I'd mention it...
11:59:37 <applicative> aavogt, I see.  Newtyping seemed like too much work.
11:59:49 <Baughn> dmwit: Eh?
12:00:12 <applicative> @type always
12:00:13 <lambdabot> Not in scope: `always'
12:00:47 <Baughn> dmwit: Wouldn't it be somewhat missing the point of an invariant if I don't reuse it?
12:01:20 <Baughn> ..no, that's not what you mean. Laziness/value reuse shouldn't happen here, though. GHC can't possibly be floating the result of an STM computation.
12:01:34 <dmwit> Baughn: I could be misreading the documentation, but... "...adds a new invariant that must be true... at the end of the current transaction, and at the end of every subsequent transaction"
12:02:34 <dmwit> By my reading, that means that "always" registers some state with the runtime.
12:02:46 <dmwit> But it's easy to test, let's seee. =)
12:02:57 <Baughn> dmwit: That would be.. insane, surely
12:03:22 <dmwit> I agree
12:03:33 <aavogt> applicative: it's about the same work to implement, but I wouldn't go with a newtype for Read instances because there's very little useful code you can reuse because it's polymorphic in  Read a => a
12:03:53 <aavogt> since once you Read it, you have some other type
12:04:23 <aavogt> though perhaps -XGeneralizedNewtypeDeriving could be helpful here
12:04:35 <dmwit> argh, modifyTVar isn't in scope?
12:04:45 <Baughn> Oh, that's mine.
12:05:11 <Baughn> modifyTVar t a = readTVar t >>= writeTVar t . a
12:05:25 <dmwit> I was right, by the way, always does register some state.
12:05:29 <dmwit> Try this:
12:05:31 <seeg> hello
12:05:43 <dmwit> atomically $ always (liftM2 (<=) (readTVar t) (return 5))
12:05:51 <dmwit> atomically $ modifyTVar t (+5)
12:05:58 <dmwit> err
12:05:59 <dmwit> +6
12:06:00 <dmwit> =)
12:06:21 <Baughn> ...
12:06:25 <aavogt> applicative: that is, you could have    sum_read :: (Read a, Num a) =>[String] -> a, which might be nice with newtypes that have different Read instances
12:06:36 <seeg> does anyone know of some algorithm such that for fixed n it finds numbers 1..n - 1 such that they are coprime with n?
12:06:54 <seeg> one way would be [x | x <- [1..(n - 1)], gcd n x == 1]
12:07:00 <seeg> but gcd is O(n) time
12:07:02 <Baughn> dmwit: I see.
12:07:17 <Baughn> dmwit: This is insane, but.. okay, possibly useful. Needs to be better documented though.
12:07:24 <Baughn> I'll just have to use retry instead.
12:07:33 <Baughn> Hm. Wait, check is what I want
12:07:46 * Baughn does a global search for always
12:07:52 <dmwit> Send them a documentation patch -- I bet they'd love it! Send them a patch fixing the "transacional" -> "transactional" typo while you're at it. ;-)
12:08:22 <seeg> i was thinking of a self-adapting algorithm, i.e. we iterate through x in [1..n - 1] but if we find some x such that gcd n x /= 1 then we can automatically skip all  numbers 2*x, 3*x, and so on, no need to compute gcd for them
12:08:24 <Baughn> dmwit: ..although, it doesn't quite explain why my original code spins
12:08:28 <seeg> i was wondering how to do it in haskell
12:08:29 <dmwit> right
12:09:16 <Baughn> dmwit: Poking #ghc. We'll see.
12:09:33 * Baughn does a global search for always. Dear lord. Hope I haven't used it.
12:10:38 <aavogt> @type and . forever
12:10:39 <lambdabot> forall a. [a] -> Bool
12:11:16 <dmwit> > (and . forever $ [True, False], and . forever $ [True, True])
12:11:17 <lambdabot>   (*Exception: stack overflow
12:11:34 <aavogt> > and . forever $ Nothing
12:11:35 <lambdabot>   Couldn't match expected type `[a]'
12:11:35 <lambdabot>         against inferred type `Data.Mayb...
12:11:43 <aavogt> > and . forever $ [Nothing]
12:11:44 <lambdabot>   *Exception: stack overflow
12:12:04 <dmwit> forever xs is morally equivalent to f [] = []; f (x:xs) = repeat x
12:12:07 <aavogt> > and . forever $ []
12:12:08 <dmwit> ...but way less efficient
12:12:08 <lambdabot>   True
12:12:36 <aavogt> I disagree
12:12:38 <dmwit> :t forever
12:12:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
12:13:15 <aavogt> > execWriter $ forever (tell ["oO"])
12:13:16 <lambdabot>   ["oO","oO","oO","oO","oO","oO","oO","oO","oO","oO","oO","oO","oO","oO","oO"...
12:13:46 <aavogt> @quote Morals
12:13:47 <lambdabot> applicative says: {-# MORALS loose #-}
12:13:49 <otto_s_> seeg: factorize n and simply generate naturals below n not containing n's prime factors?
12:13:52 <aavogt> @quote Morals
12:13:52 <lambdabot> applicative says: {-# MORALS loose #-}
12:14:06 <aavogt> @quote Flexible
12:14:06 <lambdabot> EvilTerran says: {-# LANGUAGE FlexibleMorals #-} -- needed for unsafeLaunchMissiles
12:14:19 <dmwit> aavogt: That's a different monad. I was talking only about the list monad.
12:14:34 <ddarius> > forever [1,2]
12:14:35 <lambdabot>   *Exception: stack overflow
12:14:49 <ddarius> forever [] = []; forever (_:_) = undefined
12:14:50 <dmwit> Anyway, I was wrong about that, too.
12:14:55 <dmwit> exactly
12:14:56 <aavogt> it looks pretty useless in the list monad
12:15:11 * triyo got a nosebleed learning monads for the first time.
12:15:26 <aavogt> @quote harder
12:15:26 <lambdabot> edwardk says: The Id monad a little harder to reason with than the Ego monad however
12:16:04 <seeg> otto_s_, suppose i have the list of factors, how to generate the list of x's not containing those factors?
12:16:58 <dmwit> :t filter
12:16:59 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:17:08 <dmwit> one easy, possibly inefficient way
12:18:42 <otto_s_> seeg: take all primes minus the factors of n, and give them exponents from 0 to whatever is small enough.
12:19:13 <triyo> are there docs that show what the functions like mapM,liftM exactly do? I know I can do the :t / :i but I am more interested in how to use the function and what it exactly does.
12:19:42 <aavogt> look at the source, and substitute in the definitions from your favorite monad instance
12:20:19 <aavogt> @src mapM
12:20:19 <lambdabot> mapM f as = sequence (map f as)
12:20:24 <aavogt> @src sequence
12:20:24 <lambdabot> sequence []     = return []
12:20:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:20:25 <lambdabot> --OR
12:20:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:20:27 <otto_s_> seeg: And, by the way, if you only need to count these numbers, there is a way to calculate that directly from the factorization of n, iirc.
12:20:38 <dmwit> ?pl \b x y -> print (b, (x, y))
12:20:38 <lambdabot> ((print .) .) . (. (,)) . (.) . (,)
12:20:46 <dmwit> ?pl \b x y -> print ((b, x), y)
12:20:47 <lambdabot> (((print .) . (,)) .) . (,)
12:21:07 <aavogt> @type  ((print . ) . ) . (,,)
12:21:09 <lambdabot> forall a b c. (Show a, Show b, Show c) => a -> b -> c -> IO ()
12:21:15 <dmwit> :t curry print
12:21:16 <lambdabot> forall a b. (Show a, Show b) => a -> b -> IO ()
12:21:28 <dmwit> :t curry
12:21:30 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:21:38 <dmwit> :t curry . curry
12:21:39 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
12:21:47 <dmwit> :t curry . curry $ print
12:21:49 <lambdabot> forall a b b1. (Show a, Show b, Show b1) => a -> b -> b1 -> IO ()
12:21:53 <seeg> otto_s_, how so?
12:22:06 * aavogt likes the 3-tuple better
12:22:28 <otto_s_> seeg: I don't remember. :)
12:22:49 <otto_s_> ...and maybe I'm wrong with that.
12:24:53 <triyo> anyone here gone through the "Scheme in 48 Hours - Haskell tutorial"?
12:25:12 <Entroacceptor> not yet
12:25:59 <Entroacceptor> I did some excercises
12:27:08 <triyo> I wanted to confirm my understanding around one of the parts
12:27:45 <seeg> otto_s_, that's the totient function, right?
12:28:50 <seeg> otto_s_, ah, ok, i've found it
12:29:01 <seeg> there's a formula if you know the factors and their multiplicities
12:30:00 <otto_s_> seeg: the totient counts the factors, not all non-coprimes.
12:30:48 <otto_s_> seeg: for n=49, your problem has to count 21 in.
12:34:40 <otto_s_> seeg: Oh, I was wrong on that. The totient is what you want. Sry :)
12:38:16 <sshc> Is there a way to hide #!/usr/bin/runhaskell at the beginning of a file from the preprocessor?
12:38:25 <sshc> If it uses cpp?
12:42:32 <dmwit> sshc: head -1 ;-)
12:43:15 <sshc> dmwit: Ah, good solution :)
12:44:55 <dmwit> Actually, I guess it would be "sed 1d", but you're a discriminating hacker, I'm sure you can make it work.
12:48:13 * hackagebot authenticate 0.6.0.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.0.2 (MichaelSnoyman)
12:49:31 <JoeyA> Where do I find the order of operations for built-in, prelude, and additional operators in Haskell?  Google searching didn't lend me much, other than this:  http://www.haskell.org/onlinereport/standard-prelude.html
12:49:39 <dmwit> :i +
12:49:40 <JoeyA> However, I'm trying to find out what fixity <$> has
12:49:44 <dmwit> :i <$>, then
12:49:58 <JoeyA> Thanks
12:51:13 * hackagebot hamlet 0.2.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.2.1 (MichaelSnoyman)
12:55:42 <stepcut> I need a version of the words function from Data.Text which also returns the beginning and end index of where each word appeared in the original Text.. is there a clever way to do this ?
12:55:45 <JoeyA> :i = -- gives syntax error :(
13:06:06 <xerox> JoeyA: you mean :i (==) ?
13:07:05 <kmc> stepcut, you can hack it with Text.Regex i'm sure... might be overkill though
13:07:47 <stepcut> kmc: hmm, I am using splitBy, mapAccumL, and strip* I think..
13:07:51 <kmc> okay
13:08:10 <stepcut> runtime might be horrible though :p
13:10:14 <kmc> at some point it might be simpler to write the recursion yourself
13:13:19 <stepcut> kmc: except Text does not export it's constructors ..
13:13:34 <JoeyA> xerox> No, I meant =
13:14:48 <kmc> ah, right
13:14:57 <kmc> i missed the part where you're using Text and not String
13:15:18 <kmc> you can use "uncons" as a view though
13:15:24 <stepcut> ah
13:15:28 <stepcut> I have this,
13:15:31 <stepcut>     let wordz = Text.splitBy (\c -> c == ' ') txt
13:15:31 <stepcut>         wordzWithStart = filter (not . Text.null . snd) $ snd $ mapAccumL (\cNum wrd -> (let len = Text.length wrd in (cNum + len + 1, ((cNum, cNum + len), wrd)))) 0 wordz
13:15:31 <stepcut>     in wordzWithStart
13:16:05 <MrBlueSky> Anyone know of any simple text based games written in haskell?
13:16:12 <kmc> (\c -> c == ' ') is just (==' ')
13:16:13 <MrBlueSky> I want to read some source
13:16:25 <kmc> MrBlueSky, did you check hackage?
13:16:46 <MrBlueSky> nope, I'll do that then
13:16:50 <stepcut> kmc: I know, I was too lazy to change that
13:17:40 <HugoDaniel> i want to evaluate haskell commands at runtime, much like what lambdabot does, what should i use ?
13:17:53 <HugoDaniel> i can't compile plugins (which have eval) in ghc 6.12 :(
13:18:03 <kmc> HugoDaniel, hint
13:18:11 <kmc> or GHC API directly
13:18:13 <kmc> but hint is simpler
13:18:24 <stepcut> mueval?
13:18:40 <HugoDaniel> oh, i see
13:18:41 <stepcut> http://hackage.haskell.org/package/mueval
13:18:43 <HugoDaniel> and mueval yes
13:18:44 <HugoDaniel> :D
13:18:46 <HugoDaniel> yes
13:18:56 <HugoDaniel> can i make sure that all commands will be ran inside my own monad ?
13:19:05 <HugoDaniel> i mean, i dont want to work directly in IO
13:19:19 <kmc> yeah, you choose which types are visible
13:19:28 <kmc> lambdabot won't execute IO
13:19:30 <HugoDaniel> i have a monad (which i called Stage) that i want to use for it
13:19:31 <HugoDaniel> ah ok
13:19:32 <kmc> it will evaluate IO though
13:19:42 <HugoDaniel> hmm, yes, ok
13:19:44 <HugoDaniel> nice
13:23:31 <temoto> Hello. cabal install leksah tells me that it wants glib >= 0.10 but there is no available version. Even after cabal update. How to fix that?
13:23:57 <luite> install gtk2hs
13:24:13 <luite> http://www.haskell.org/gtk2hs/download/
13:24:27 <temoto> Shouldn't cabal automatically download and install dependencies?
13:24:35 <luite> it's not yet available through cabal, but it should be soon
13:24:41 <luite> at least they're working on it :)
13:27:22 <shapr> Yow!
13:27:24 <shapr> @quote
13:27:25 <lambdabot> maltem says: FactoryFactory factoryfactory = new FactoryFactory(); // satisfactory?
13:28:42 <temoto> luite, thank you.
13:29:35 <shapr> @qute
13:29:35 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
13:29:35 <lambdabot> Haskell
13:30:17 <temoto> luite, not sure what to provide as prefix to configure because default suggestion was /home/temoto/your/path. Could you help?
13:30:23 <c_wraith> @quiteso
13:30:23 <lambdabot> Unknown command, try @list
13:30:35 <c_wraith> edit distance was too far, apparently
13:31:04 <luite> temoto: I usually install it in my home directory, something like /home/luite/haskell/ghk2hs-0.10.1-6.12.2
13:31:13 <luite> where the second version number is the ghc version
13:32:37 <temoto> luite, omg, i'm trying to install it "as user" too, but haven't created anything like separate per-library directories. Wonder if ~/.ghc will do.
13:33:42 <luite> temoto: oh gtk2hs and ghc are usually the only things for which I keep versioned directories
13:33:58 <temoto> luite, why?
13:35:11 <luite> because it doesn't have its own version structure, and I like to be able to have different ghc versions installed simultaneously
13:35:41 <ezyang> I once did something like this for PHP. I should set something up for GHC too...
13:36:36 <luite> it's not a big deal to do gtk2hs manually, but it would be a very welcome improvement if it could be done automatically with cabal :)
13:36:49 <seeg> how could i memoize the totient function?
13:37:13 <seeg> since it could be useful, because totient(a*b) = totient(a)*totient(b) if a and b are coprime
13:37:21 <luite> seeg: you can use Data.MemoCombinators for memoization in general
13:37:21 <rajeshsr> @type (<$>)
13:37:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:37:41 <rajeshsr> @src (<$>)
13:37:41 <lambdabot> f <$> a = fmap f a
13:41:44 <temoto> luite, and how do you use that gtk2hs in separate dir then, for, say, to install leksah via cabal?
13:42:12 <luite> temoto: if you make install, it automatically registers the package with ghc (using ghc-pkg)
13:42:19 <luite> temoto: so you can use cabal packages that depend on it
13:43:00 <temoto> luite, how do you switch between separate versions then?
13:47:27 <luite> temoto: I think ghc-pkg knows which version is installed for which ghc (if it doesn't I've just been lucky :) )
13:48:20 <temoto> luite, so it's one gtk2hs per ghc?
13:48:49 <luite> oh, yes
13:49:05 <luite> in my case
13:49:14 <luite> but you can have multiple versions of a single package installed
14:02:44 <lyndon_> Hi Haskellers, is there something wrong with this defaultable head function? (http://codepad.org/vJzViZuQ) I get the error "cannot construct the infinite type: a = [a]"...
14:02:56 <shapr> Has anyone used net-concurrent? How does it transport values? Do the programs have to be clones of each other?
14:03:12 <mauke> lyndon_: yes
14:03:12 <ezyang> replace the brackets in your pattern match with parentheses
14:03:13 <mrd> lyndon_: [x:_]
14:03:27 <mrd> -> (x:_)
14:03:36 <lyndon_> AH, I can't believe I missed that :|
14:03:56 <lyndon_> Thanks mrd, mauke
14:04:00 <gwern> I do that all the time
14:05:02 <temoto> luite, sorry, but could you point, what could cause such errors? http://paste.ly/1Hx
14:05:27 <lyndon_> I get mixed up with the prolog syntax.
14:06:20 <luite> temoto: hmm, don't know. perhaps you need the darcs version to compile with your ghc version
14:08:02 <rajeshsr> what is the difference between Array and Data.Array?
14:09:01 <temoto> luite, well it's 6.12.1 as yours. But that darcs version is a separate funny story. I executed the line he states on http://haskell.org/gtk2hs/archives/2010/04/21/cabalized-version-of-gtk2hs-now-up-for-testing/ this line: darcs get code.haskell.org:/srv/code/gtk2hs and it wants me to do some kind of ssh authentication :) totally unexpected.
14:09:52 <luite> oh don't know about that, sorry. I haven't tried the new repository yet
14:10:13 <rajeshsr> :t array
14:10:14 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
14:10:19 <rajeshsr> :t Array
14:10:20 <lambdabot> Not in scope: data constructor `Array'
14:11:04 <temoto> luite, so how do you install dependencies and configure on 6.12.1?
14:11:16 <pato> @src filter
14:11:16 <lambdabot> filter _ []     = []
14:11:16 <lambdabot> filter p (x:xs)
14:11:16 <lambdabot>     | p x       = x : filter p xs
14:11:16 <lambdabot>     | otherwise = filter p xs
14:11:41 <temoto> rajeshsr, Array is a type, Data.Array is a module which contains that type and implementation of various functions with that type.
14:11:56 <luite> temoto: I installed it a while ago, used the old darcs repository
14:12:27 <BMeph> rajeshsr: "Array" is a cut-down version of Data.Array, , made for H98-compliant programs. :)
14:12:28 <rajeshsr> temoto, hmm! There also seems a module named Array. That is the reason i asked.
14:12:38 <rajeshsr> BMeph, oh, thanks!
14:14:59 <BMeph> rajeshsr: Sure. BTW, the same goes for List vs. Data.List, and Monad vs. Control.Monad. :)
14:15:21 <temoto> luite, what is old darcs repository?
14:16:10 <rajeshsr> BMeph, oh, i don't know that! So Data.Array provides more functionality than Array, right?
14:17:58 <BMeph> luite: Interesting - when I try to use that repo, it tells me that it isn't valid:darcs failed:  Not a repository: code.haskell.org:/srv/code/gtk2hs ((scp) failed to fetch: code.hask
14:17:58 <BMeph> ell.org:/srv/code/gtk2hs/_darcs/inventory)
14:19:14 <BMeph> rajeshsr: Correct. It sounds funny, but "the original" Haskell did not have hierarchical module names - it was a flat module namespace. Things have grown since then. ;)
14:22:25 <Heffalump> BMeph: what version of darcs?
14:23:30 <Heffalump> temoto: note that doing a darcs get hostname:foo will use ssh, whereas darcs get http://hostname/foo won't
14:23:58 <Heffalump> so the instructions given may have been wrong for anyone without a code.haskell.org account
14:26:16 <temoto> Heffalump, thanks, darcs get http://code.haskell.org/gtk2hs seems to work.
14:29:18 <BMeph> Heffalump: C:\Users\bmeph>darcs --version
14:29:18 <BMeph> 2.3.1 (release)
14:29:41 <Heffalump> BMeph: weird
14:29:53 <Heffalump> oh, perhaps you can't ssh
14:30:22 <BMeph> Heffalump: "Yes I Am!" - oh, right, the darcs behavior...yeah, that too. ;)
14:30:31 <sshc> Which optimization flag is optimized to compile time rather than run time again?
14:33:31 <Heffalump> sshc: -O0 should be fast compiles, slow runs
14:37:12 <aavogt> sometimes optimizations prevent stack overflows
14:48:32 <kulin> is there a way to use an IO monad inside a 'do' list of actions for the STM monad?
14:48:42 <Cale> kulin: no, by design
14:48:51 <kulin> ok
14:48:55 <Cale> kulin: Well, you can construct an IO action and return it from the transaction
14:49:26 <kulin> i'll just have to rethink what I am trying to do
14:49:53 <kulin> I was trying to have an STM map with a bunch of handles, but when I remove a handle from the map, I wanted to close it as well
14:50:03 <ivanm> you typically don't do IO inside anything else
14:50:29 <ivanm> (you _can_ have a monad transformer around IO, but that's usually stuff you do to extend IO)
14:51:31 <aavogt> STMT sounds unlikely
14:51:42 <ivanm> yeah
14:52:04 <ivanm> "Senior Teenage Mutatant Turtles" ? :p
14:52:12 <aavogt> haha
14:52:24 <ivanm> *Mutant
14:52:47 <kulin> i think parallel programming should not be something i have to manage, languages should abstract it out of my hands
14:53:12 <aavogt> have you looked into DPH?
14:53:15 <heatsink> We can do that, as long as you don't care about how fast it runs.
14:53:15 <ezyang> Well, you'll have to use [: :] and not [ ] for DPH :-)
14:53:50 <ivanm> repa!
14:54:19 <Twey> 21?
15:02:38 <mrd> anyone happen to know why the debian packages of hopengl are somewhat out of date in unstable?  not finding any reports on the list or bts.
15:02:44 <ezyang> and they'd get turned into notes
15:03:04 <ezyang> and you could rearrange the interface to have different foci, like if you're working on harmonization or just one line
15:03:12 <mrd> ezyang: meant for blah?
15:03:17 <ezyang> mix!
15:07:22 <gwern> mrd: debian is always out of dae
15:08:41 <mrd> they have ghc 6.12.1 which is only 5 months out of date. fine by me.  hopengl-2.4 is much older than that
15:27:50 <timmaxw2> Suppose I have a module that defines a type called "Foo", but also defines a class called "Foo". That is legal, right?
15:28:05 <mauke> I don't think so, but try it
15:29:15 <alpounet> that's a bad idea anyway
15:29:25 <timmaxw2> GHC complains, so I guess it's safe to guess it's not in the standard
15:29:35 <timmaxw2> Thanks
15:36:10 <ezyang> I wonder what the difference between nested data parallelism and whatever Fortress's approach to implicit parallelism is.
15:37:27 <Axman6> anyone else see http://hackage.haskell.org/package/net-concurrent-0.1.0 ?
15:38:06 <dv-> Yes
15:41:11 <dons> ezyang: iirc. fortress has a form of nested dph, but without automatic lifting/flattenign
15:41:29 <ezyang> ah, ok.
15:41:56 <ezyang> I'm trying to compare the problem approaches by Guy Steele and Simon Peyton Jones, which seem to be attacking the same problem.
15:41:58 <dons> see Chapel also (one of the other DARPA langs)
15:43:58 <heatsink> NESL was targeting a vector machine, so they wanted to flatten and vectorize every primitive operation
15:44:20 * hackagebot augeas 0.2.0 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.2.0 (JudeNagurney)
15:45:40 <heatsink> But I seem to recall there being a fusion step in GHC to group dependent operations into each parallel step
15:46:25 <dons> yep.
15:46:38 <ezyang> One of the points of flattening is to make equitable distribution of work possible.
15:48:11 <ezyang> btw, does anyone know where SPJ stashed the slides for the NEern talk?
15:53:12 <heatsink> Hmm.  How do case statements get vectorized?
15:55:45 <Cale> Probably with mapP
15:57:08 <ezyang> research.microsoft.com hates meeeee
15:57:56 <ivanm> ezyang: as in it won't load?
15:58:08 <ezyang> yeah
15:58:17 <scotthw> hello!  I have two [[Doubles]] and I want to ZipWith the inner lists
15:58:17 <ivanm> that happened to me when I lived at home and I believe it still affects dibblego
15:58:29 <ivanm> actually, it still doesn't like me know, despite having a different ISP
15:58:44 <scotthw> I tried to map a ZipWith, but I cannot get it working...
15:58:47 <ivanm> scotthw: what do you mean?
15:59:00 <scotthw> ivanm: well, I have two lists full of lists
15:59:01 <kmc> :t \f -> map (zipWith f)
15:59:02 <lambdabot> forall a b c. (a -> b -> c) -> [[a]] -> [[b] -> [c]]
15:59:07 <ezyang> I've tried a bunch of servers I have access to and it hates them too
15:59:21 <kmc> :t zipWith
15:59:22 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:59:30 <scotthw> right now
15:59:31 <scotthw> I have
15:59:31 <scotthw> map $ zipWith (-) framesPhases framesPhasesPrev
15:59:35 <kmc> scotthw, that will specialize to ([a] -> [b] -> c) -> [[a]] -> [[b]] -> [c]
15:59:37 <scotthw> but that isn't working
15:59:45 <kmc> try zipWith (map (-))
15:59:49 <kmc> or zipWith (zipWith (-))
15:59:53 <kmc> :t zipWith (zipWith (-))
15:59:55 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
15:59:58 <ivanm> kmc: yeah, about to suggest that
16:00:06 <ivanm> oh, I missed the "two" in your original question
16:00:59 <ivanm> dammit, searching for "spj" doesn't return links about simon peyton jones (looking for the link to his actual homepage) :(
16:01:40 <scotthw> hmm, that didnt quite work
16:01:47 <scotthw> maybe I have the wrong syntax?
16:01:53 <ivanm> ezyang: does wget work for you?
16:01:57 <ivanm> e.g. wget http://research.microsoft.com/en-us/people/simonpj/
16:02:09 <scotthw> OH i think I got it!
16:02:10 <ivanm> because that works for me (just my actual browsers that can't do it)
16:02:15 <scotthw> thanks!
16:02:49 <patch-tag> how do you read a float (or a rational?) value in hdbc? I can't find a convert instance from string to float or similar
16:03:08 <ivanm> read?
16:03:09 <patch-tag> safeConvert (SqlString "2") :: ConvertResult Rational
16:03:26 <patch-tag> Left (ConvertError {convSourceValue = "SqlString \"2\"", convSourceType = "SqlValue", convDestType = "Ratio Integer", convErrorMessage = "Cannot read source\
16:03:27 <patch-tag>  value as dest type"})
16:03:29 <ezyang> nope...
16:03:45 <ivanm> ezyang: interesting....
16:03:52 <ezyang> lemme try another system
16:04:15 <ezyang> oh hey, that did work
16:04:16 <ezyang> wtf
16:04:35 <ivanm> patch-tag: fmap fromRational or something?
16:04:45 <ivanm> (once you've gotten a Double or something)
16:05:50 <heatsink> Oh! The body of a DPH comprehension is not flattened, and there's no way to put an if-then-else in the generator part.
16:05:52 <patch-tag> I guess I can import Safe package, and use readMay to get from string to Float, and then take it from there
16:06:17 <heatsink> So no handling of case statements by the vectorizer.
16:06:48 <ddarius> That shouldn't be correct.
16:07:04 <ezyang> Oh hey http://superuser.com/questions/114633/cant-connect-to-research-microsoft-com-on-home-qwest-dsl-connection
16:07:53 <dmwit> :t reads -- patch-tag ?
16:07:54 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:08:41 <illissius> I'm getting this when trying to use LLVM (installed w/ apt): "Loading package llvm-0.7.1.1 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)"; any ideas? (this is in ghci)
16:08:44 <heatsink> ddarius: You mean the vectorizer does something with case statements?
16:09:26 <illissius> fwiw i'm using a whole ton of c++ stuff and none of it complains about a missing libstdc++, so i assume it's not
16:10:38 <JuanDaugherty> 2,7?
16:10:45 <JuanDaugherty> *2.7
16:11:15 <JuanDaugherty> (because the debian version is hopelessly out of date)
16:11:36 <ezyang> Ok, found it.
16:11:48 <illissius> JuanDaugherty: seems to be 2.6
16:11:51 <illissius> do I need 2.7?
16:12:08 <JuanDaugherty> 2.7 just came out
16:12:12 <illissius> I know :)
16:12:28 <illissius> actually I installed it a few days ago
16:12:30 <illissius> hmm..
16:12:42 <JuanDaugherty> it has some new stuff but I though you meant the official debian pkg which is like 3 years old
16:12:51 <illissius> oh right, so I have both 2.6 and 2.7 in parallel
16:13:02 <illissius> with the 2.7 stuff all suffixed with -2.7
16:13:03 <ivanm> ezyang: :o
16:13:11 <ivanm> hey, I started that thread on whirlpool!
16:13:25 <illissius> JuanDaugherty: I'm using unstable, which is not as out of date :)
16:13:35 <JuanDaugherty> they do have a channel btw, it's on OFTC
16:13:50 <illissius> so you're saying this is a debian question?
16:13:55 <JuanDaugherty> maybe bridged here
16:14:02 <JuanDaugherty> i meant llvm
16:14:05 <illissius> oh
16:14:23 <illissius> google finds nothing which is suspicious
16:15:07 <ddarius> heatsink: Section 6.4 of http://www.cse.unsw.edu.au/~chak/papers/PLKC08.html seems relevant
16:17:46 <dmwit> ?hoogle Eq a => a -> a -> Bool
16:17:47 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
16:17:47 <lambdabot> Prelude (==) :: Eq a => a -> a -> Bool
16:17:47 <lambdabot> Data.Eq (/=) :: Eq a => a -> a -> Bool
16:17:49 <dmwit> err
16:18:00 <dmwit> ?hoogle Eq a => (b -> a) -> b -> b -> Bool
16:18:01 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:18:01 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
16:18:01 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
16:20:05 <dmwit> aww
16:20:11 <dmwit> a `f` b c = undefined -- should be valid Haskell
16:21:04 <Wraithan> is code.haskell.com down?
16:21:18 <dmwit> It's been down a lot recently... so probably, yes.
16:21:24 <Wraithan> Ugh.
16:21:28 <Wraithan> :(
16:21:37 <dmwit> code.haskell.org, I assume you mean
16:21:43 <Wraithan> aye
16:21:46 <Wraithan> I meant .org
16:22:00 <dmwit> sorry man =/
16:22:25 <Wraithan> Where's a big company to sponsor and host mirrors and stuff when you need one
16:24:00 <kmc> :t on (==)
16:24:01 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
16:24:14 <dmwit> Yep, I was just hoping it had a name (like comparing).
16:25:16 <ddarius> :t equating
16:25:16 <heatsink> ddarius: Figure 6 had what I was looking for.  They evaluate the branch condition, create parallel arrays of the inputs to each branch, compute on the parallel arrays, then combine the results into one array.
16:25:17 <lambdabot> Not in scope: `equating'
16:25:21 <ddarius> @hoogle equating
16:25:22 <lambdabot> No results found
16:25:32 <ddarius> dmwit: There should be something called equating somewhere.
16:25:43 <dmwit> I couldn't find it.
16:25:48 <dmwit> I looked in Data.Function and Data.Ord
16:26:04 <dmwit> and Data.Eq
16:26:08 <ddarius> Maybe it used to exist and was (re)moved(?)
16:28:30 <dmwit> This reads like a Dr. Seuss poem now.
16:28:37 <dmwit> connections `hasRotation` rotation = \connection -> any (rotation (direction connection) ==) (map direction connections)
16:29:22 * heatsink can not say such tricky stuff, sir
16:31:03 <Entroacceptor> http://pastie.org/private/42w4pg1446rjutluuyffq <- just quits immediatly, but leaves the spawned process running. What am I doing wrong?
16:31:28 <mauke> quitting immediately
16:32:11 <Entroacceptor> well, the line with hPutStr should quit the client, or shouldn't the other thing wait till eof?
16:32:19 <dmwit> Yep, you've got to explicitly wait for any threads you spawn.
16:32:57 <ivanm> Entroacceptor: there's a waitTillEnds function or or something that takes the pid
16:33:04 <ivanm> @hoogle Pid -> ExitCode
16:33:04 <lambdabot> Warning: Unknown type Pid
16:33:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:33:04 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:33:06 <ivanm> bah
16:33:11 <ivanm> @hoogle runINteractiveCommand
16:33:11 <lambdabot> No results found
16:33:46 <ivanm> Entroacceptor: note that AFAIK runInteractiveProcess is preferred over command as it doesn't need a shell
16:33:55 <ivanm> oh, and you might want some hcloses in there
16:34:14 <Entroacceptor> but I like shells ;)
16:34:41 <ivanm> see also http://ivanmiljenovic.wordpress.com/2009/12/10/command-inputoutput-and-blocking/
16:35:15 <Entroacceptor> ah, thanks
16:36:31 <ivanm> it took me a while to work out why dot, neato, etc. weren't returning anything ;-)
16:37:26 * ivanm heads off to uni
16:45:32 <u_quark> is there an elegant way to write this: `liftM head $ liftM (filter id) $ mapM (\p -> doesFileExist p) filePaths` without checking all the files ?
16:47:20 <dcoutts_> u_quark: in Cabal we have a function something like firstFile, that gets given a list of files to tre
16:47:22 <dcoutts_> try
16:47:22 <ddarius> u_quark: liftM = fmap, fmap f . fmap g = fmap (f . g)
16:47:25 <edwardk> fmap (head . filter id) $ mapM doesFileExist filepaths --
16:47:34 <edwardk> at least cleans up the code ;)
16:47:47 <ddarius> filter id seems like something that is usually silly to do
16:47:52 <edwardk> yeah
16:48:10 <ddarius> head . filter id is a less defined version of or.
16:48:42 <edwardk> fmap or $ mapM doesFileExist filepaths
16:48:50 <ddarius> In fact, head . filter id is always True or undefined, which doesn't seem like something someone would want.
16:49:02 <edwardk> or <$> mapM doesFileExist filepaths
16:49:42 <edwardk> of course i think his point was that he wanted to stop checking files when one said 'yes'
16:49:50 <ddarius> Indeed.
16:50:13 <u_quark> (02:45:01 AM) u_quark: [...] without checking all the files ?
16:50:18 <ddarius> I think there is a library somewhere that does have things like orM and such.
16:50:33 <edwardk> or even a whileM or untilM
16:50:49 <u_quark> tnx all, I will check
16:50:52 <dcoutts_> u_quark: see Cabal's findFirstFile utility function
16:52:00 <dcoutts_> http://darcs.haskell.org/cabal/Distribution/Simple/Utils.hs
16:53:11 <u_quark> yes dcoutts_: tnx
16:57:02 <siracusa> I'm looking for a function Monad m => (a -> m b) -> Map k a -> m (Map k b), is there one somewhere?
16:57:34 <ddarius> :t foldM
16:57:35 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:58:24 <edwardk> siracusa: Data.Traversable.mapM
16:58:38 <edwardk> siracusa has an intance for Map k
16:58:49 <edwardk> @type Data.Traversable.mapM
16:58:50 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:59:02 <edwardk> t = Map k
16:59:35 <siracusa> edwardk: Ah, thanks
17:00:39 <Xask> could someone help me with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25409. What do I have to replace "return" with in order to work?
17:01:06 <Xask> in the last line
17:01:49 <dmwit> return $ ...
17:01:55 <dmwit> Xask: return is just a function
17:02:41 <dmwit> Xask: So that parses as "return" applied to the three parameters (instead of the one it usually takes). =)
17:03:03 <dmwit> Xask: Moreover: that line doesn't actually do anything (unless there's more to main there), and probably will not type-check.
17:03:08 <Xask> I see, thanks a lot I will try it :)
17:03:11 <dmwit> unless addMusic returns a (). =)
17:04:38 <Xask> addMusic is function in in order to work it needs myDatabase (Film track composer year[])
17:04:49 <Cale> Well, unless addMusic produces an IO action, I think dmwit means
17:05:31 <dmwit> If addMusic produces an IO action, then that last line definitely won't typecheck. =P
17:05:48 <Cale> If addMusic myDatabase (Film ...)  is an IO action, then you'd want to run it, rather than returning it.
17:05:56 <Cale> So you wouldn't use return there.
17:06:01 <Xask> indeed
17:06:11 <Xask> what shall I use?
17:06:24 <Cale> Just get rid of the return function altogether
17:06:41 <Cale> return is just a function which produces an IO action that does nothing but return the value you give it
17:06:44 <dmwit> Xask: What's the type of addMusic?
17:06:54 <Cale> That is,  return v,  when run, does nothing, and returns v
17:07:32 <Cale> It's quite possible for the result of an IO action to be yet another IO action, but that's considerably rarer
17:08:28 <Cale> For example,  return getLine  won't immediately ask the user for a line of text. Instead, it will do nothing and return the action which gets a line of text as its result.
17:08:52 <Cale> So it has type IO (IO String)
17:09:25 <dmwit> It's like the difference between "return getChar();" (which returns a character) and "return getChar;" (which returns a function pointer) in C.
17:10:11 <Xask> thanks for the clarification :)
17:10:34 <kmc> a real-world example of nested IO types is asynchronous function calls
17:10:36 <wli> (it's getchar() btw; no camel-case in libc)
17:10:48 <kmc> you might have something like:  Request -> IO (IO Response)
17:11:40 <kmc> used like: do { demandResult <- makeRequest req; otherStuffHere; result <- demandResult }
17:12:14 <sshc> "Couldn't match expected type `bytestring-0.9.1.5:Data.ByteString.Lazy.Internal.ByteString' against inferred type `L.ByteString'"
17:12:33 <sshc> How do I convert L.ByteString to that other type?
17:12:51 <Cale> Yeah, you could write something like:  makeCell = do r <- newIORef 0; return (modifyIORef r (+1), readIORef r)
17:12:52 <sshc> And why does "parse" want that type?
17:13:07 <Cale> and then running it like  (up,get) <- makeCell
17:13:29 <Cale> will give you an  up :: IO ()  and  get :: IO Integer
17:13:48 <Cale> So that get returns the number of times that up has been run
17:14:00 <kmc> yeah
17:14:16 <kmc> i think "return (writeChan ch)" is a nice pattern
17:14:34 <kmc> often the user shouldn't know or care that you're using channels
17:14:41 <kmc> so you hide that by closure
17:17:15 <sshc> How do I convert L.ByteString to bytestring-0.9.1.5:Data.ByteString.Lazy.Internal.ByteString?
17:17:27 <dmwit> mu
17:17:42 <pikhq> , indeed.
17:17:58 <sshc> dmwit: mu?
17:18:50 <kmc> a smart-ass non-answer ;)
17:18:59 <monochrom> I use "return (writeChan ch)" too
17:19:13 <sshc> What is the meaning of it?  5?
17:19:36 <pikhq> sshc: No, that's "go".
17:19:36 <pikhq> Or "itsutsu".
17:20:09 <Cale> sshc:  just means "nothing"
17:20:24 <sshc> Was that in response to me?
17:20:33 <ezyang> MU unasks the question.
17:20:34 <pikhq> Yeah.
17:20:35 <sshc> I wonder why "parse" wants it's last argument to be that strange type
17:20:51 <sshc> pikhq: I can't?
17:20:58 <sshc> pikhq: I can't convert to that type?
17:20:58 <monochrom> My only regret is I have 3 channels to hide, so I give a record of { toX, toY, toZ :: Message -> IO () }. Apart from the field name it is unclear which is which. :)
17:21:10 <Cale> sshc: Maybe things are compiled against a different version of bytestring?
17:21:27 <sshc> Cale: Which "things"?
17:21:32 <Cale> I don't know
17:21:36 <ezyang> ... crazy.
17:21:42 <pikhq> sshc: It is used an an answer to indicate that the question itself was meaningless.
17:21:43 <Cale> Which libraries are you using?
17:21:46 <monochrom> "things" = some of your files
17:21:48 <pikhq> Mostly a Zen Buddhist thing.
17:22:04 <Cale>  [] n      (1) nothing/naught/nought/nil/zero/(pref)
17:22:04 <Cale>       (2) un-/non-
17:22:18 <pikhq> It is also used in Japanese as a very common prefix for words, meaning "no-", "non-"... Sort of thing.
17:22:21 <sshc> pikhq: The question is quite meaningful.  It asks how to convert/cast from one type to another, in addition to specifying what those two types are.
17:22:33 <BMeph> UR DOIN IT RONG!!11!1ein1!
17:22:42 <pikhq> sshc: Take it up with dmwit. :)
17:23:08 <Cale>  [] adj-na,n,vs Pop
17:23:08 <Cale>       (1) unreasonable/impossible/overdoing
17:23:36 <pikhq> Yuh, there's one.
17:23:43 <monochrom> I beg to differ. "How to convert Data.Map.Map to Control.Monad.Identity" is meaningless.
17:24:28 <ezyang> Is recursion a party pooper for DPH?
17:24:36 <Cale> ezyang: Shouldn't be
17:24:49 <ezyang> hm.
17:24:52 <sshc> monochrom: "How do I convert Data.Map.Map to Control.Monad.Identity?" has meaning, but I couldn't think of a sensible solution.  Converting between two ByteString types is much more sensible.
17:24:58 <Cale> sshc: You should avoid having to convert in the first place by simply using the same version of the bytestring library, and then they will be the same type.
17:25:13 <ezyang> I'm looking at SPJ's comment "Lots and lots of functions over lists, and they're all RECURSIVE functions"
17:25:22 <sshc> I also noticed that I have two versions ofByteString librariesinstnalled
17:25:26 * sshc unregisters
17:25:46 <ezyang> and trying to understand if this is a problem with recursive functions
17:26:02 <Cale> ezyang: Is he talking about fusion?
17:26:08 <ezyang> yep
17:26:48 <BMeph> I've noticed a lot of recursive iterative functions, lately.
17:27:00 <Cale> Stream fusion works by turning a bunch of separate recursive functions into a *single* recursive function over a stream, composed with a bunch of simple constant-time things, so that everything compiles into one loop.
17:27:45 <scotthw> is there a mod that will work on doubles?
17:27:53 <BMeph> E.g., "chunk"
17:27:54 <Cale> Basically, you have a function which turns the array/list/whatever into a Stream, say toStream, and a function which goes the other way, fromStream
17:28:07 <Cale> scotthw: Not built-in
17:28:13 <scotthw> ugh
17:28:21 <scotthw> is there something I can just import?
17:28:32 <Viterbi> hey
17:28:44 <Cale> and you replace things like filter p and map f with  fromStream . filter p . toStream  and  fromStream . map f . toStream
17:28:47 <kmc> hi Viterbi
17:28:57 <BMeph> Viterbi: "What do horses eat?" ;
17:29:04 <Viterbi> hmm
17:29:06 <ezyang> ah, and that's easy to fuse.
17:29:11 <Cale> which at first looks like a lot of wasted time since you're converting back and forth between Stream and whatever other type you're using
17:29:12 <Viterbi> carrots?
17:29:31 <Cale> but you can cancel out any toStream . fromStream pairs you come across
17:29:40 <ezyang> ya
17:29:44 <scotthw> You have confused me x10000
17:29:46 <Viterbi> hey, anyone here somewhat comfortable answering a log arithmetic question?
17:30:18 <scotthw> haha, let me take a look at what I can do
17:30:27 <BMeph> Viterbi: "This is IRC; don't ask if you can ask something, just ask." :)
17:30:37 <Viterbi> ;p
17:30:53 <Viterbi> well, im trying to implement a viterbi algorithm basically, but im sort of a retard
17:31:16 <kynky> question will be answered in O(logn)
17:31:29 <Viterbi> anyway, involves a lot of multiplcation, and i'm using log(m) + log(n) to calculate the product of two numbers to avoid underflow
17:31:32 <Cale> scotthw: Well, what should it do? mod x y would be a number between 0 and y which was of the form x - k*y for some integer k?
17:31:46 <kmc> Viterbi, did you see http://hackage.haskell.org/package/logfloat
17:31:54 <mrd> kynky: impressive, you don't even have to read the whole question?
17:31:55 <mauke> Cale: same thing as fmod in C
17:31:56 <sshc> "cabal: cannot configure QuickCheck-2.1.0.3. It requires ghc -any"
17:31:59 <scotthw> right
17:32:21 <Viterbi> so, here is the question. I need to multiple 3 numbers. The first number is already the in this form (log(m) + log(n), so should I just log(first numer) + log(third number), or just add first number + log(third number)
17:32:29 <Viterbi> *multiply
17:32:35 <Cale> So you just want  fmod x y = x - n * y where n = truncate (x/y)
17:32:37 <dcoutts_> sshc: odd, it should not depend on the ghc package
17:32:53 <scotthw> hm, well that's simple
17:33:34 <tomberek> ivanm: howdy
17:33:37 <BMeph> Cale: Doesn't truncate give an Integral number? :)
17:33:43 <Cale> oh, right
17:33:47 <Cale> :t truncate
17:33:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:33:50 <Cale> yes
17:33:59 <mauke> foreign import ccall unsafe "math.h fmod" c_fmod :: CDouble -> CDouble -> CDouble
17:34:01 <Cale> fmod x y = x - n * y where n = fromIntegral (truncate (x/y))
17:34:01 <scotthw> uh, yeah, it just gave me errors, likely because of that
17:34:20 <scotthw> right, easy fix
17:34:34 <Cale> @let fmod x y = x - n * y where n = fromIntegral (truncate (x/y))
17:34:35 <lambdabot>  Defined.
17:34:35 <dcoutts_> sshc: oh, apparently I'm wrong and it does, which is a bit odd.
17:34:42 <Cale> > fmod 5 pi
17:34:43 <lambdabot>   1.8584073464102069
17:34:56 <sshc> dcoutts_: Is anybody else able to install it?
17:34:59 <dcoutts_> sshc: looks like your ghc (the api) package is broken then
17:34:59 <Cale> > fmod (3*pi/2) pi
17:35:01 <lambdabot>   1.5707963267948966
17:35:01 <sshc> dcoutts_: How can I install it?
17:35:03 <BMeph> Cale, scotthw: I would suggest using "properFraction". :)
17:35:15 <Cale> hmm
17:35:15 <dcoutts_> sshc: unbreak your ghc api package, see what ghc-pkg check says
17:35:27 <sshc> dcoutts_: How do I "unbreak" it?
17:35:38 <Cale> BMeph: in what way?
17:35:40 <mauke> > properFraction (5 / pi)
17:35:41 <lambdabot>   (1,0.5915494309189535)
17:35:59 <monochrom> I have QuickCheck-2.1.0.3 installed fine uneventfully. I use ghc 6.10.4, and therefore I have ghc-6.10.4
17:36:00 <dcoutts_> sshc: depends why it's broken :-) see what ghc-pkg check says
17:36:43 <Cale> ah, I see
17:36:47 <sshc> Okay.  pacman's almost finished upgrading
17:37:12 <Cale> @let fmod' x y = v * y where (u,v) = properFraction (x/y)
17:37:13 <lambdabot>  Defined.
17:37:14 <BMeph> Cale: Um, fmod' x y = y* snd . properfunction(x/y), I guess. :)
17:37:18 <monochrom> Oh neato! properFraction does fmod. :)
17:37:28 <Cale> @check \x y -> fmod' x y == fmod x y
17:37:29 <lambdabot>   Not in scope: `fmod''Not in scope: `fmod'
17:37:32 <monochrom> fdivmod :)
17:37:35 <Cale> oh, right, no L.hs
17:37:53 <Cale> > fmod' 5 pi
17:37:55 <lambdabot>   1.858407346410207
17:38:23 <Cale> > fmod' (e^3) pi == fmod (e^3) pi
17:38:24 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
17:38:24 <lambdabot>    arising from a us...
17:38:33 <mauke> exp 3
17:38:34 <Cale> > fmod' (exp 1 ^ 3) pi == fmod (exp 1 ^ 3) pi
17:38:35 <lambdabot>   False
17:38:43 <Cale> > fmod' (exp 3) pi
17:38:44 <lambdabot>   1.2359810016489092
17:38:47 <Cale> > fmod (exp 3) pi
17:38:48 <lambdabot>   1.2359810016489092
17:38:53 <Cale> close enough
17:39:12 <Cale> > fmod (-exp 3) pi
17:39:13 <lambdabot>   -1.2359810016489092
17:39:16 <Cale> > fmod' (-exp 3) pi
17:39:17 <lambdabot>   -1.2359810016489092
17:39:24 <Cale> > fmod' (exp 3) (-pi)
17:39:25 <lambdabot>   1.2359810016489092
17:39:28 <Cale> > fmod (exp 3) (-pi)
17:39:29 <lambdabot>   1.2359810016489092
17:39:35 <sshc> dcoutts_: http://pastebin.com/vE5kELCC
17:39:35 <Cale> okay, should be fine :)
17:39:56 <Cale> > fmod (-exp 3) (-pi)
17:39:57 <sshc> (105 lines)
17:39:57 <lambdabot>   -1.2359810016489092
17:40:00 <Cale> > fmod' (-exp 3) (-pi)
17:40:01 <lambdabot>   -1.2359810016489092
17:40:26 <Cale> I should work out how to get the check plugin to load L.hs at some point
17:40:34 <dcoutts_> sshc: wow, fairly borked. looks like you've managed to unregister most of the original core packages that ship with ghc.
17:41:59 <sshc> dcoutts_: How did that happen?
17:42:07 <sshc> dcoutts_: Or more importantly, what can I do about it?
17:42:48 <dcoutts_> sshc: unless it just looks that way because other packages are shadowing them, check ghc-pkg list, see if there are the same versions of packages in the global and user package dbs.
17:42:53 <BMeph> Fasteest means might be to just re-download. :)
17:43:18 <dcoutts_> sshc: in particular, process, directory and random. If you've got identical versions in both then obliterate the user ones.
17:43:43 <sshc> dcoutts_: http://pastebin.com/wnmsdtsN
17:44:30 <cdsmithus> Do the Haskell police come arrest you if you have a function that takes a Maybe (Maybe ...) as a parameter?
17:44:41 <monochrom> There is no haskell police.
17:44:52 <kmc> it's not insane
17:44:54 <monochrom> Or,  :)
17:44:56 <kmc> you should have a good reason
17:45:00 <kmc> but such reasons exist
17:45:04 <dcoutts_> sshc: ah, you installed them globally, it might not be recoverable
17:45:17 <sshc> dcoutts_: Installed what globally?
17:45:26 <kmc> when you find yourself building complex types out of Either / Maybe / tuples, it's usually a sign that you should define your own type instead
17:45:28 <pikhq> cdsmithus: join can take that as a parameter.
17:45:33 <dcoutts_> sshc: looks like you reinstalled the core libs
17:45:41 <dcoutts_> sshc: some of them anyway
17:45:41 <kmc> > map join [Nothing, Just Nothing, Just (Just 'x')]
17:45:43 <lambdabot>   [Nothing,Nothing,Just 'x']
17:46:12 <mail> http://www.telegraph.co.uk/science/space/7695994/Largest-scientific-instrument-ever-built-to-prove-Einsteins-theory-of-general-relativity.html
17:46:16 <mail> sounds so cool
17:46:43 <pikhq> mail: "prove" and "scientific theory". *sigh*
17:46:54 <pikhq> Why does science reporting suck so much?
17:47:15 <cdsmithus> I'm being a little lazy... I need three options: (1) send unreliably, (2) send reliably, but then forget, or (3) send reliably, and put a Bool in this MVar to say whether it was acked.  Each one has to do incrementally more bookkeeping, so I thought, why not express that in the type!
17:47:22 <sshc> dcoutts_: Is it possible to install QuickCheck?
17:47:42 <ddarius> cdsmithus: Mu Maybe = Natural
17:47:53 <cdsmithus> So my function now takes a Maybe (Maybe (MVar Bool))
17:47:57 <danharaj> They reported e=mc^2 as a distinct theory than GR
17:48:00 <dcoutts_> sshc: yes, either reinstall ghc or find an older version of QuickCheck that does not rely on the ghc package
17:48:15 <pikhq> danharaj: *sigh*
17:48:45 <monochrom> e=mc^2 is just SR. In Haskell, you write m*c^2
17:49:02 <monochrom> but perhaps faster code if you write m*c*c
17:49:10 <sshc> dcoutts_: Why does QuickCheck depend on ghc?
17:49:19 <sshc> (And don't I already have that installed? :P)
17:49:22 <dcoutts_> sshc: I've honestly no idea
17:49:35 <dcoutts_> sshc: you do, but it depends on packages that are no longer registered
17:49:41 <dcoutts_> hence it's borked
17:49:49 <wli> let e = m_0 * c^2 / sqrt ( 1 - (v / c)^2 ) ?
17:49:51 <dcoutts_> and unlike most other packages, it cannot be rebuilt
17:49:59 <monochrom> Yeah!
17:53:24 <ezyang> Does Nested Data Parallelism handle non-structure preserving operatinos?
17:53:36 <ezyang> I... can't really see that being the case.
17:54:00 <sshc> dcoutts_: How do I reinstall all of the packages?  All of the depencies seem broken
17:54:19 <sshc> I can't install cabal-instaltl because it "cannot satisfy -package-id mtl-1.1.0.2-23ca4de7c573fd4df309067199a40634"
17:54:21 <dcoutts_> sshc: I don't think you can unbreak the ghc package without reinstalling ghc
17:54:43 <monochrom> erase ghc. install ghc anew. install packages anew.
17:55:06 <sshc> pacman -R ghc && pacman -S ghc?
17:55:32 <monochrom> or pray that you had a generational file system so you could unroll, replay... to investigate what you did.
17:55:37 <ezyang> I suppose filtering is not a structure preserving transformation
17:55:40 <dcoutts_> sshc: I recommend installing extra packages per-user rather than globally, a tad safer. Easier to blow them away.
17:56:23 <sshc> dcoutts_: When root installs packages without the --global flag, will the installed packages be specific to root?
17:56:34 <dcoutts_> sshc: yes
17:56:45 <sshc> Should I pacman -R cabal-install as well?
17:57:06 <dcoutts_> it's a statically linked program so it's ok as it is
17:57:13 <dcoutts_> it's much harder to break :-)
17:57:21 <sshc> je'e
17:58:24 <edwardk> ezyang: you don't have to preserve the structure, one big goal of dph is to exploit all the fusion operations so many of those intermediate structures just don't exist at all
17:59:06 <edwardk> ezyang: and filter has an efficient stream representation
17:59:19 <sshc> Why doesn't cabal install the newest version of the parsec package by default?
17:59:32 <dcoutts_> sshc: the default version is set as 2.x
17:59:45 <dcoutts_> you can override the default
18:00:02 <edwardk> sshc: because they put a hack in to add a constraint of parsec < 3 unless explicitly overridden
18:00:05 <ezyang> edwardk: I'm vacillating between "Data Parallel Haskell is so cool" and "so... what exactly does this buy us?"
18:00:19 <sshc> I mean, why did they choose to install version 2 by default?
18:00:22 <dcoutts_> edwardk: it's not a hack as such, it's because that is still the recommended version
18:00:25 <edwardk> ezyang: much of the rest of the community is in that same place ;)
18:00:35 <dcoutts_> it's the version in the platform
18:00:50 <edwardk> dcoutts: sadly true
18:00:59 <dcoutts_> we had the same thing for haxml while 1.19 was the unstable version, before 1.20 stable was released
18:02:07 <dcoutts_> edwardk: nobody has made a serious effort to demonstrate that version 3 is an improvement, though I hope that will change
18:02:54 <aavogt> ParsecT?
18:03:16 <edwardk> dcoutts: honestly all i want is to be able to use a program that has the misfortune of needing to link them both
18:03:31 <edwardk> i wind up using parsec 3 fairly extensively, but i also need to use libs that use parsec 2
18:03:33 <dcoutts_> edwardk: ah now that's a different problem
18:03:48 <dcoutts_> we need to be able to specify that some dependencies are private
18:03:52 <edwardk> some of which leak some of the implementation details
18:03:54 <sshc> Why can't hashed-storage find the System module?
18:03:55 <edwardk> Counter-Strike: yeah
18:03:56 <dcoutts_> and thus it's ok to use different versions
18:04:01 <sshc> "Could not find module `System':"
18:04:11 <dcoutts_> sshc: your haskell98 package is broken
18:04:19 <sshc> dcoutts_: I reinstalled ghc already
18:04:22 <sshc> dcoutts_: What can I do now?
18:04:22 <dcoutts_> I'd guess
18:04:34 <dcoutts_> sshc: does ghc-pkg check everything is ok?
18:05:42 <edwardk> that was an odd tab completion =)
18:06:08 <sshc> dcoutts_: http://pastebin.com/CC4YhCAT
18:07:25 <dcoutts_> sshc: I don't know why the random package is still missing after you reinstalled the system ghc package
18:08:23 <aavogt> perhaps the distro is supplying you a broken ghc package
18:08:59 <aavogt> or you're doing something weird with multiple ghc installs
18:09:05 <sshc> I'm using Arch
18:10:50 <ezyang> Would I be lying if I claimed DPH was a way to automatically implement chunking compiler-end?
18:12:07 <aavogt> it's not ready yet, so is there much point in claiming things about it, ezyang?
18:12:38 <ezyang> Well, I'm trying to get a handle on its applicability
18:12:54 <ezyang> and SPJ has said they're looking for guinea pigs...
18:18:05 <danharaj> Does anyone know why parsec reserved and reservedOp are of type Parser () instead of returning a value?
18:18:28 <ddarius> @hoogle reservedOp
18:18:29 <lambdabot> Text.Parsec.Token reservedOp :: GenTokenParser s u m -> String -> ParsecT s u m ()
18:18:29 <lambdabot> Text.ParserCombinators.Parsec.Token reservedOp :: GenTokenParser s u m -> String -> ParsecT s u m ()
18:18:29 <lambdabot> Text.Parsec.Token reservedOpNames :: GenLanguageDef s u m -> [String]
18:18:53 <ddarius> danharaj: What would they return?  The very string you passed in?
18:19:32 <danharaj> I'm not sure why one would use them.
18:20:02 <danharaj> You can't use operator s if you're trying to parse a reservedOp because it rejects it as reserved, and reservedOp doesn't return a string like operator.
18:20:27 <danharaj> ddarius: so the question is, how do you parse an operator and return it when it is reserved?
18:24:17 <ddarius> danharaj: Again, the string it would return is just the string you passed in.  Just return it after parsing if you want it.
18:24:56 <danharaj> What if I am doing something like choice $ map reservedOp foo?
18:25:25 <ddarius> danharaj: Then do choice $ map (\s -> reservedOp s >> return s) foo
18:25:50 <mauke> fondleblort = liftM2 (>>) reservedOp return
18:26:20 <ddarius> Usually reserved operators are part of the syntax.  You don't usually want to parse multiple ones at a location and you don't usually want to behave uniformly after parsing one.
18:28:00 <ddarius> If some operators are just special (say built-in or the only ones you can use as in C) then you probably don't want to use reservedOp and reservedOpNames for them.  You'd just parse them as normal operators.
18:28:33 <ddarius> It's only when the operators are reserved for the -syntax- that reservedOp would make (the most) sense.
18:29:43 <aavogt> @type Text.Parsec.string
18:29:44 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => String -> Text.Parsec.Prim.ParsecT s u m String
18:30:34 <Runar> have we the capability of enforcing monotonicity in the type system?
18:32:03 <jonrafkind> is code.haskell.org dead?
18:34:08 <siracusa> jonrafkind: No, it's down from time to time
18:34:34 <aavogt> it's apache looks comatose
18:35:11 <jonrafkind> is it being whacked?
18:35:20 <aavogt> as in, it's running, but not responding to anything
18:35:47 <aavogt> there has been some discussion on haskell-cafe@haskell.org about what the intermittent issue is
18:37:30 <aavogt> http://www.haskell.org/pipermail/haskell-cafe/2010-May/077305.html
18:39:46 * dcoutts_ restarts apache on code.h.o yet again
18:40:59 <jonrafkind> would it be easier to have a process sends an http request to the server once a minute and if it times out then restart it?
18:41:43 <dcoutts_> we've currently got a cron job that does it occasionally
18:46:25 <gwern> @quote value
18:46:25 <lambdabot> dons says: global state is just another pure value :)
18:46:53 <danharaj> ddarius: Thanks for the explanation.
18:46:57 <gwern> @quote erlis
18:46:58 <lambdabot> No quotes match.
18:47:00 <gwern> @quote Perlis
18:47:01 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
18:47:14 <gwern> we have no Alan Perlis epigrams on lambdabot? unpossible!
18:47:19 <gwern> @quote cost
18:47:19 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
18:47:21 <kmc> @quote stark
18:47:21 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18:47:34 <gwern> @quote AlanPerlis
18:47:35 <lambdabot> AlanPerlis says: A LISP programmer knows the value of everything, but the cost of nothing.
18:48:02 <gwern> we don't even know that :)
18:50:16 <gwern> @quote AlanPerlis
18:50:16 <lambdabot> AlanPerlis says: Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18:52:58 <kmc> C++
18:53:00 * kmc duc s
18:53:02 * kmc ducks even
18:53:20 <fulld> noob question: I am using ghci. how do I quit?
18:53:33 <Pseudonym> :q
18:53:36 <tensorpudding> control+d is how i do it
18:53:44 <Pseudonym> Or ^D, yes.
18:54:03 <Entroacceptor> aww, :wq doesn't work ;)
18:54:13 <tensorpudding> What would it "write"?
18:54:40 <kmc> :m + Foreign
18:54:42 <kmc> peek nullPtr
18:54:45 <kmc> that's how *i* quit ghci
18:55:12 <fulld> nice, I'll have them add that one to the top of the tutorial
18:55:14 <fulld> thanks
18:55:43 <mauke> minBound `div` negate 1 :: Int
18:55:47 <mauke> is how I used to quit ghci
18:56:29 <dmwit> Exceptions exit ghci?
18:56:34 <dmwit> Since when?
18:56:41 <tensorpudding> Heh, peek nullPtr does indeed quit ghci.
18:57:51 <mauke> dmwit: it used to SIGFPE
18:57:59 <dmwit> oh
18:58:16 <ddarius> Why would it SIGFPE?
18:58:56 <mauke> why not?
18:59:04 <dmwit> > (negate (fromIntegral (minBound :: Int) :: Integer), fromIntegral (maxBound :: Int) :: Integer)
18:59:05 <lambdabot>   (9223372036854775808,9223372036854775807)
18:59:08 <dmwit> that's why
18:59:37 <dmwit> Although I agree that FPE seems like an odd SIG to raise.
18:59:56 <ddarius> dmwit: I understand why it would give -an- exception.
19:00:15 <dmwit> Right, it just took me a second to catch up with your objection.
19:00:25 * dmwit freely admits to being a little slower than ddarius =)
19:01:02 <mauke> SIGFPE is what you get for dividing an integer by 0
19:01:24 <tensorpudding> oh shii-
19:02:25 <ddarius> This is when monochrom comes in about meaningful names.
19:03:26 <Pseudonym> Right, I forgot about SA_SIGINFO.
19:03:37 <Pseudonym> It's been a while since I wrote a signal handler.
19:06:31 <tomberek> ivanm: hello
19:07:33 <tomberek> Cale: you around?
19:07:35 <santiago> Haskell Capo Wanted!
19:07:57 <santiago> kmc are you there?
19:08:28 <tomberek> anyone know of a better (i.e. maintained) alternative to 'collections' ?
19:08:43 <kmc> hi
19:09:36 <santiago> Got a problem with recursive imports
19:09:37 <santiago> http://www.pastie.org/953162
19:10:06 <kmc> you can't have cyclic imports
19:10:16 <mauke> http://haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
19:10:17 <kmc> there is a way to do it in GHC, but it's a pain in the ass
19:10:28 <santiago> There are functions that should belong to "Accionistas.hs" and we can't export em because its not allowed in this homework.
19:10:53 <santiago> But they are general functions really useful in other modules
19:10:59 <kmc> if your instructor is giving restrictions like that, she's also probably not happy with this hs-boot trickery
19:11:07 <santiago> So, we put them in misc
19:11:37 <santiago> Of course not
19:11:39 <santiago> :P
19:11:47 <santiago> Help!
19:11:52 <kmc> so you'll probably have to split things up more
19:12:12 <santiago> but if we do that.. we would be repeating code
19:12:34 <ddarius> That's why you don't code under arbitrary restrictions.
19:13:01 <santiago> What can we do? :(
19:13:35 <kmc> split it up more
19:13:37 <dons> tomberek: is there a specific structure you're looking for?
19:13:38 <kmc> make more modules
19:13:55 <dons> there's no well-maintained general advanced collections lib, other than 'containers'
19:14:36 <tomberek> dons: no, i'm talking with ivanm at the moment, and we want a "class Set" or "class SetLike" that is fairly standard in the community
19:14:56 <tomberek> dons: then we found that it doesn't exist, and I'm wondering why
19:15:18 <dons> a standard Set class doesn't exist, afaik
19:15:32 <dons> for some reason back filling the gaps in collections stuff is non-sexy enough that people don't do it
19:15:48 <dons> i assume that's the reason, anyway
19:15:55 <dons> also, classes for collections are hard.
19:16:03 <ddarius> Apparently.
19:16:05 <dons> see what happened in Scala.
19:16:25 <dons> http://drops.dagstuhl.de/opus/frontdoor.php?source_opus=2338
19:16:25 <tomberek> dons: we have libraries for "internetmarke program: Shell command for constructing custom stamps for German Post" but not for something as basic as Sets?!
19:16:51 <dons> tomberek: no, of course we have Set libraries
19:16:54 <ezyang> dons: That's the second time I've seen you quote that paper, I guess I have to add it to my paper queue now :-)
19:16:55 <dons> in the base containers lib
19:17:02 <dons> tomberek: but not a generic class for Set-like things
19:17:17 <ddarius> tomberek: It's easier to make a good concrete implementation than a good interface.  There are concrete implementations of Sets.
19:17:28 <dons> ezyang: not sure if that's the paper, but odersky gave a compelling talk on how fucking hard it is to get a fully generic collections class right
19:17:40 <tomberek> dons:yes. Do you think the community can't get a good interface?
19:17:42 <dons> he worked on the design for years, and had to modify scala a few times to get it to work
19:17:55 <dons> tomberek: i'm sure we can. begin with the Data.Set interface and generalize
19:17:57 <tomberek> dons: can't we build off of and learn from his experience?
19:18:11 <dons> i don't http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Set.html
19:18:11 <tomberek> ok
19:18:25 <dons> i don't think anyone's tried just doing Set.
19:18:28 <cdsmithus> You'd think if it requires advanced type trickery, *more* people would try to do it in Haskell
19:18:31 <dons> usually they aim too big: any containers
19:18:49 <dons> but avoid any advanced type trickery -- performance and a simple API is more important.
19:18:55 <tomberek> dons: I like this guys suggestions: http://hackage.haskell.org/trac/ghc/ticket/666
19:18:59 <dons> and look at Edison.
19:19:15 <dons> http://hackage.haskell.org/package/EdisonCore
19:19:18 <ezyang> dons: Was that presentation at AOSD?
19:19:27 <dons> ezyang: at wg2.8 last year, probably elsewhere
19:19:34 <dons> i think its the same as the above dagstuhl talk
19:19:58 <dons> tomberek: edison is a large, comprehensive set of advanced structures, well designed, but without a maintainer
19:20:18 <cdsmithus> Wow, what a ticket number to have assigned to your suggestion
19:20:28 <tomberek> dons, ezyang, ddarius: is there a current effort to get this figured out?  (cdsmithus, yeah, i know)
19:20:54 <ManateeLazyCat> dons: Do you know any exist Haskell module parse information under /proc ? I'm working on it ...
19:21:11 <dons> not an active one. i'm sure you could quickly gather interested parties. the challenge would be to define the vision and execute to it, without getting distracted
19:21:23 <dons> ManateeLazyCat: no lib i know of. check hackage
19:21:50 <ddarius> dons: I don't even think that's the issue.  It's just a matter of getting it adopted (i.e. used widely.)
19:21:54 <tomberek> dons: that's always the problem, avoiding distraction
19:22:26 <tomberek> ddarius: it seems that something useful enough will become the de facto standard, and then roll it into Haskell-proper
19:22:53 <ddarius> tomberek: Then what has been wrong with Edison (or at least the interfaces it defines) for the past 10+ years?
19:23:33 <dons> ddarius: well, that follows from not getting distracted. its getting harder and harder to build adoption. not enough will to sell your work.
19:24:00 <dons> i'm not sure anything's wrong with edison. the GSoC efforst around it focused on demonstrating performance, which isn't really done yet
19:24:15 <dons> and modernising any odd conventions
19:24:17 <ddarius> dons: The performance is irrelevant for just adopting the interfaces.
19:24:24 <dons> sure.
19:24:32 <dons> needs someone to do it. that's the real problem
19:24:56 <dons> describing the problem, in sufficient detail to issue a call for hackers, seems to work
19:25:33 <dons> and whoever maintains it needs to be committed to getting their stuff adopted
19:25:53 <dons> that level of passion is a rare commodity
19:26:32 <tomberek> dons, ddarius: I am willing to be involved, but I must admit that I'm not Haskell-wise enough to make design decisions of this scale.
19:27:06 <ddarius> Haskell programmers don't seem to feel enough "pain" from not coding to interfaces in these examples.
19:27:17 <dons> maybe issue a call to form a group to address the problem
19:27:19 <dons> see who steps u
19:27:20 <dons> p
19:27:28 <dons> on libraries and haskell-cafe@
19:27:34 <dons> that has been very effective for some problems
19:27:46 <ezyang> I wonder if we can enlist ambitious High Schoolers for the task
19:27:55 <dons> well, grad students anyway :P
19:28:21 <cdsmithus> Or elementary schoolers?  The resulting interfaces will be far more interesting.
19:28:22 <tomberek> dons: Okasaki has offered students of his.
19:28:30 <dons> tomberek: that'd be very good
19:28:59 <dons> guys like kowey can run a project without having to do everything themselves. need someone to lead with energy and vision, but not nec. doing all the work
19:29:29 <dons> i'm not sure what 'solving collections' really means, actually. just ensuring all the core data types are sufficiently well designed and implemented and benchmarked
19:29:30 <ddarius> The amount of (original) coding would be miniscule.  It would mostly be an issue of designing a good interface (which at this point the best bet is probably to simply abstract from the existing ones) and (re)writing libraries against that interface.
19:29:31 <dons> and then adopted
19:29:39 <dons> there we go
19:29:50 <dons> ddarius wants to help
19:30:05 <dons> i'm not sure what happened with the 'rewrite things in AVL trees' GSoC project
19:30:13 <dons> i heard it got good benchmarks, but never saw results.
19:30:15 <cdsmithus> ddarius: more likely, prodding existing package maintainers?  If you build simultaneous copies of the libraries, I see the chances of adoption plummeting
19:30:31 <dons> tibbe is good at writing proposals.
19:30:34 <danharaj> Perhaps it would be instructive to examine C++'s standard template library. The solution is completely unsuitable for Haskell, probably, but seeing what C++'s needs are, how they're met, and why the STL works so well might be fruitful for such a project.
19:30:40 <ddarius> cdsmithus: Not copies of hackage packages or something, just utility functions that are currently written to concrete instances.
19:30:47 <dons> maybe work with him to get the API right, then prod people to tweak their libs
19:30:57 * ManateeLazyCat Oh, i found Text.XForamt , good tool to parse /proc information. :)
19:31:04 <dons> yeah, how did STL succeed, and we can't get something in place
19:31:14 <dons> too many options, not enough pain?
19:31:22 <dons> pain is great in C++ to do it any other way?
19:31:35 <ddarius> dons: I think it is exactly parallel to the record/module system issue.
19:31:36 <cdsmithus> From my perspective, it looks easier to get a few people to change their packages and documentation, than to get a few thousand people to install and use new packages.
19:31:48 <danharaj> dons: As far as I understand, the STL succeeded because A) It was designed by a genius and B) C++'s committee embraced it quickly
19:31:49 <ddarius> (Except that that -would- require some creative coding.)
19:32:00 <dons> ddarius: so too broad a design space
19:32:05 <tomberek> we need a genius... any out there with time?
19:32:13 <ddarius> dons: And not enough problems with the current solution
19:32:19 <dons> yep
19:32:20 <dons> interesting
19:32:28 <danharaj> tomberek: Anyone can be the genius if they want to pour all their talent into it :p
19:32:44 <gwern> I sometimes consider edison to be our stl
19:32:52 <gwern> except no one uses it
19:32:54 <tomberek> danharaj, i already said I'd be happy to work on this.  I need to say that I need help though.
19:32:57 <ddarius> dons: Not so much too broad, as simply no -obviously- good solution, though I don't think it is nearly as bad with a collections interface as with the record/module system.
19:33:06 <ddarius> gwern: Exactly.
19:33:38 <ManateeLazyCat> gwern: Haskell need STL ?
19:33:41 <dons> edison should be the basis. we tried to run a gsoc project based on that assumption
19:33:48 <danharaj> I have never heard of edison.
19:33:48 <dons> so now it needs a maintainer with the leadership to make it work
19:33:55 <gwern> danharaj: have you heard of okasaki?
19:34:11 <dons> all the simple things: tutorials to help people migrate, demos to show performance/ease of use etc.
19:34:19 <dons> make the value proposition compelling so people use it
19:34:21 <danharaj> gwern: I have heard his name about the topic of creating efficient functional datatypes vaguely somewhere around here
19:34:33 <gwern> danharaj: edison = okasaki's book in executable form
19:34:51 <danharaj> Is it bundled with any major compiler set-up?
19:35:06 <gwern> no, it's just 2 packages
19:35:12 <gwern> interface & implementationm
19:35:17 <dons> danharaj: on hackage.
19:35:20 <dons> everything is on hackage.
19:35:34 <ddarius> Again, it's the interfaces we need, not the clever data structures.  Plus any implementation-independent utility libraries.
19:35:35 <tomberek> dons, I will make the tutorials,demos,benchmarks, i'll even code, but the meat-and-potatoes code needs to come from someone like you, a Haskell sage.
19:35:48 <dons> well, the code is already there.
19:35:52 <dons> tuning might be a job for experts
19:35:55 <gwern> ddarius: well, edison already has the interfaces as I said
19:36:10 <danharaj> If Edison works, then it should be part of the standard libraries.
19:36:20 <gwern> not that simple
19:36:25 <dons> but anyone can write a tutorial. i wrote one for vector since no one else would,  http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial doing similar things for edison would help
19:36:29 <mtnviewmark> So the missing item is - a maintainers?
19:36:44 <dons> yes. and other data points
19:36:53 <dons> like benchmarking, compat and migration info, tutorials
19:37:05 <dons> maintainer is #1, showing performance is ok compared with Map/Set et al is #2
19:37:11 <tomberek> Is this a OK mission statement: "To promote the Edison package and make it into the de facto standard for the Haskell community."
19:37:19 <mtnviewmark> Would Edison replace most of the ad hoc packages, like Map and Array and Vector and Foldable, etc?
19:37:20 <gwern> danharaj: not everything should be in the stdlibraries. edison has a lot of datastructures in it. how foten do you use a Banker's Queue?
19:37:21 <dons> then getting libraries@ to say, "yeah, that rocks" is #3
19:37:27 <dons> not vector.
19:37:27 <ddarius> gwern: We only need the EdisonAPI package.  The EdisonCore package is nice, but isn't the problem.
19:37:36 <dons> the purely functions stuff, like Map/Set/Tree/...
19:37:44 <dmwit> gwern: I've reimplemented queue-as-([a],[a]) more times than I like to admit.
19:37:48 <dons> and the separate question of the api class, that ddarius talks about
19:37:53 <gwern> dmwit: :)
19:38:20 <danharaj> gwern: True. But something part of it should be there. Something to set an example of what the interface should be. For example the STL provides a number of idioms for C++ containers. The solution here should do the same for Haskell.
19:38:42 <ddarius> There's nothing wrong with Data.Set and Data.Map.  We don't need a high-tech general Set and Map class.  The problem is that people are coding to the implementations Data.Set/Map and not to an interface.
19:38:54 <gwern> and I don't even know if edison is that fast these days; that's some old code in many respects
19:38:55 <ddarius> s/class/implementation
19:38:56 <dons> that's one problem.
19:39:07 <dons> Map is slower than things in Edison (rumor has it). problem #2
19:39:14 <mtnviewmark> Seems to me that, like the STL, having a viable
19:39:31 <mtnviewmark> Working out of the box implementauon is key to adoption
19:39:41 <danharaj> DDarius is right. It's all about the interface. The C++ STL has very loose implementation guidelines for vendors.
19:39:45 <ddarius> mtnviewmark: We have tons of those.
19:39:47 <tensorpudding> Why is it a problem to be coding to widely available and standard libraries?
19:39:49 <dons> http://blog.gmane.org/gmane.comp.lang.haskell.libraries/month=20060301 <-- inneresting
19:40:44 <dons> Hey felt you could build everything in terms of http://hackage.haskell.org/package/AvlTree
19:41:00 <mtnviewmark> ddarius: That seems like a problem - most users shouldn't have to think about picking an implentation
19:41:04 <ddarius> tensorpudding: Because when you want to change your code to use a more performant/more compact/instrumented version of a set, you can't just do it.  Again, nothing is wrong with Data.Set being the default.  The problem is that once you decide to use it, it is not easy to change, particularly for a third party.
19:41:17 <ddarius> mtnviewmark: They shouldn't even be considering it.
19:41:26 <ddarius> mtnviewmark: Unless they have specific requirements.
19:41:36 <tensorpudding> Why can't a replacement for Data.Set implement a functionally similar API?
19:41:42 <mtnviewmark> Okay so we are in agreement there
19:41:56 <ddarius> tensorpudding: It can, but I can't pass my Data.MySet sets into your Data.Set expecting functions.
19:42:05 <dons> http://hackage.haskell.org/trac/summer-of-code/ticket/1560 <-- summer project to fix collections via AVL trees (implementation, not api issues)
19:42:07 <ddarius> tensorpudding: I could if you just specified SetLike interface.
19:42:25 <tensorpudding> So make Set a typeclass?
19:42:30 <dons> lots of work.
19:42:37 <ddarius> dons: Yes, and, in my opinion, that is not the issue.  It's a nice thing to work on, but not a big problem for most.
19:42:43 <gwern> tensorpudding: the typeclassopedia is not big enough!
19:42:51 <ddarius> tensorpudding: That's a solution and that's what Edison does, but noone uses Edison.
19:43:12 <tensorpudding> Because all their code is linked to something that is standard?
19:43:50 <sshc> Am I using (<|>) correctly?  http://pastebin.com/sR3H3WVM
19:43:52 <tensorpudding> Maybe moving Edison closer to the core of GHC, and slowly migrating the basic container types to deprecation while lauding the benefits of Edison?
19:43:55 <sshc> It's been a while; I suspect indentation might be an issue here.
19:43:57 <dmwit> ?instances-importing Control.Monad.Reader MonadState
19:43:58 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
19:44:06 <ddarius> tensorpudding: Edison used to be distributed with GHC long before Data.Map or Data.Set existed.
19:44:10 <ddarius> tensorpudding: No one used it then either.
19:44:12 <tomberek> again,  mission statement: "To promote the Edison package and make it into the de facto standard for the Haskell community."
19:44:17 <dons> having the api, then showing that all the core stuff in containers were instances would be very compelling
19:44:25 <dons> ddarius: they were in ddata
19:44:31 <tensorpudding> Damn, this thing is from 1999?
19:44:39 <kmc> sshc, if you did this right, the outer "do" would have only one statement, right?
19:44:48 <gwern> tensorpudding: before cabal, it was hard to have many dependencies
19:44:49 <dons> i think edison and ddata are about the same age
19:44:51 <kmc> seems pointless to have the "do" then
19:44:54 <dmwit> sshc: That indentation looks awfully fishy to me.
19:45:08 <tensorpudding> It doesn't help that its name is less official
19:45:13 <gwern> tensorpudding: what, were people going to go wgetting, ./configure && make installing all over the place? no, you'd just code to whatever came with their ghc
19:45:15 <dons> but ddata was shipped with ghc. i'm not sure edison was. (?)
19:45:22 <dons> ddata == Daan's Data
19:45:22 <dmwit> sshc: How about just parser = anotherParser <|> yetAnotherParser
19:45:31 <gwern> dons: I've never seen anything about edison shipping with ghc, I don't think
19:45:39 <kmc> do { x <- m; return x}   ===  m
19:45:40 <dmwit> sshc: one of the monad laws is do { x <- m; return x } === m
19:45:46 <tensorpudding> Data.Set is a terribly obvious name
19:45:46 <dons> pretty sure it didn't.
19:45:55 <dons> i'm guessing ddarius is thinking of ddata.
19:45:59 <sshc> dmwit: Yes, I certainly could have; but I'm trying to figure out why that code didn't work as indented.
19:46:11 <sshc> intended.
19:46:20 <dmwit> sshc: It thinks line 5 begins another line of the block.
19:46:34 <tomberek> i think Data.Set is used and Data.Edison.Coll.Standard set is not is simply because it looks like Data.Set is the standard
19:46:48 <dmwit> sshc: So it becomes do { do { ... }; <|> do { ... } } rather than do { do { ... } <|> do { ... } }.
19:46:53 <tensorpudding> Yes, that is exactly what I meant.
19:47:06 <tomberek> so repackage Edison with short names, make it user friendly, and we're done?
19:47:10 <kmc> sshc, to desugar layout: after each "do", find the next non-whitespace token and remember its column.  insert a { before it.  for every subsequent line, if it starts at the same column, prepend a ;.  if it starts to the left of that column, prepend }; the "do" block is now closed
19:47:14 <gwern> I don't even know how I would go about promoting edison; just benchmarking its analogues to containers doesn't seem like enough
19:47:15 <ddarius> dons: http://www.haskell.org/ghc/docs/5.00/set/sec-data.html
19:47:15 <tensorpudding> Data.Edison sounds like the new shiny fast not-trusted-for-mainstream alternative
19:47:25 <gwern> when I wanted to promote hackage & cabal, it was obvious what to do.
19:47:28 <tensorpudding> Why is it called Edison anyway?
19:47:29 <gwern> not so much here
19:47:38 <tensorpudding> Does it make any difference that it is called that?
19:47:47 <sshc> dmwit: Without reducing that code, how could I indent it properly?
19:47:57 <ManateeLazyCat> I have read http://splonderzoek.blogspot.com/2009/06/rfc-extensible-typed-scanf-and-printf.html great!
19:48:06 <dmwit> sshc: Move the <|> farther to the left or right.
19:48:07 <tomberek> tensorpudding: exactly,, (it's in the docs, Edison is a library of purely functional data structures written by Chris Okasaki. It is named after Thomas Alva Edison and for the mnemonic value EDiSon (Efficent Data Structures).
19:48:09 <ddarius> dons: Edison was part of the old hslibs.
19:48:21 <kmc> is there a standalone tool that desugars layout?
19:48:22 <ManateeLazyCat> I don't need write scanf with Haskell. :)
19:48:22 <kmc> it'd be useful here
19:48:28 <dmwit> sshc: Not so far left as the beginning of the word "parser" and not so far right as the beginning of the word "stuff"... or farther than the word "stuff".
19:48:42 <tensorpudding> I'm sure that the name is clever, I'm just saying that odd names and long paths seem less standardized
19:48:48 <tomberek> yes
19:48:53 <kmc> in fact we should have a pastebin which draws in little ghosted { ; }
19:49:06 <danharaj> I think "Edison" is just as valid as "Haskell" :)
19:49:09 <tomberek> so, ddarius, dons, tensorpuding, others: does it seem like Edison is the way to go?
19:49:12 <ddarius> It perhaps wouldn't hurt to have an Interfaces branch in the namespace.  Interface.Set?
19:49:42 <ddarius> tomberek: I personally don't think so, but any standard interface would be better than none.
19:49:45 <gwern> danharaj: haskell is more valid, because we at least use something related to Curry's work
19:49:55 <tomberek> if so, i'll contact Edison maintainer, and get started.  (ddarius: i like that idea.)
19:50:00 <danharaj> perhaps Data.Interface.Set, Data.Edison.Set (or whatever), and Data.Foo for other container libraries.
19:50:05 <gwern> ddarius: I think Interface.* is horrible ~_~
19:50:14 <gwern> ddarius: what's next, ADT.*? Newtype.*?
19:50:20 <ddarius> gwern: I agree, but I'm not sure of a better name.
19:50:20 <cdsmithus> I'm with tensorpudding about the name thing, honestly.  Cute names and acronyms sound like someone's pet project.  Given a lack of objective standards or knowledge, I'd never used "Edison" over "containers"
19:50:41 <tomberek> ddarius:  that way an import makes sense.  "I want to IMPORT an INTERFACE for SETS. "
19:50:44 <danharaj> The Interface branch standardizes container interfaces, Edison is the standard library for containers, and other libraries can make their own branches.
19:50:55 <tensorpudding> Abstracted interfaces are cool, though
19:50:57 <ddarius> tomberek: Yes.  It's a brute force obvious name.
19:51:15 <tomberek> and it seems fairly standard
19:51:19 <tensorpudding> The problem is how crazy you want to go with abstraction.
19:51:50 <tensorpudding> Maybe being able to switch out data structures is a useful abstraction.
19:51:54 <ddarius> Once we have a standard interface, we need some acceptable defaults which we already for the most part have (there's nothing wrong with having Data.Set and Data.Map and Data.Whatever be the default Set/Map/Whatever.)
19:52:31 <ddarius> In my opinion, it is not important to promote the implementations that Edison provides.
19:53:36 <danharaj> ddarius: I would think that the edison data structures are more self-consistent, and comprise a larger set than Data.Map/Set, but if Edison Set and Data.Set have the same interface, it doesn't really matter.
19:53:38 <cdsmithus> ddarius: I agree with you there.  They might be great!  But I've never had Data.Map and Data.Set not be good enough.  And promoting interfaces makes it easier to play with implementations.
19:54:08 <tensorpudding> Why not make a new version of Data.Set, etc. that is compatible with the Edison API, and call it new-containers or something
19:54:13 <ddarius> danharaj: Exactly.  If I can just switch from Data.Set to Data.Edison.Set, then who cares which is the "main" one.
19:54:55 <ddarius> cdsmithus: As I said earlier, most users don't feel much pain from not coding to interfaces, that's part of why it's so hard to get adoption.
19:55:11 <danharaj> ddarius: I think the important thing is for there to exist a standard library of data structures. Instead of just scattered things like Data.Set, Data.Map, etc. one collection of types to call standard to hold as an example of what other library writers should do.
19:55:26 <tomberek> danharaj: i'll second that
19:55:30 <cdsmithus> Frankly, I think it's also important to keep some "obvious" choice of implementation in place, like we have now.  If Edison has seven choices for a set-like data structure (I don't know if it does), then people will think "Haskell is confusing".  There needs to still be a Data.Set
19:55:45 <danharaj> Something to say "This is how we do things.", is it really important that we have a "This is how we do things"? I think it'll become more important as Haskell becomes more important.
19:56:21 <tomberek> cdsmithus: Data.Edison.Coll.StandardSet
19:56:24 <ddarius> danharaj: Having a collection of defaults for these interfaces is necessary but we already pretty much have it.  If you are in base, you are standard.  We just don't have the interfaces (or no one is using them.)
19:57:10 <ddarius> cdsmithus: Yes.  I've said that several times.
19:57:32 <cdsmithus> ddarius: I think we're in violent agreement here.
19:57:43 <danharaj> ddarius: True. I still think they should be moved into a subtree more specific than "Data" so that it looks like they're intended to be standard. Data.Standard would work just as well as Data.Edison.
19:57:45 <kmc> stab stab stab
19:58:17 <danharaj> Hey kmc, remember when you said I should separate type checking from parsing? You were correct. I'm rewriting it now because it was getting unwieldy :)
19:58:20 <ddarius> danharaj: I would not include "Edison" in the name of the collection of interfaces/libraries.
19:58:31 <cdsmithus> danharaj: I think I disagree.  Data.Standard.Set would be harder to find than Data.Set, in my opinion
19:59:08 <tomberek> I liked ddarius 's idea of Interface.Set , etc.
19:59:17 <danharaj> cdsmithus: Really? If introductions to Haskell noted to beginners "Data.Standard is where you can find useful basic data structures" would it be harder?
19:59:39 <tensorpudding> Data.Structures
19:59:49 <tensorpudding> for all your data structure needs
19:59:51 <danharaj> tensorpudding gets a billion points
19:59:51 <ddarius> This is how I see it.  There should be a Data.Set and an Interface.Set.  People would use Interface.Set for all coding.  When an actual set was actually needed, people would use Data.Set by default if they didn't care.
19:59:52 <danharaj> :D
19:59:59 <cdsmithus> *shrug* it's not a strong feeling either way.  But Data.Set is the obvious place to look for a set data structure
20:00:06 <tomberek> Interface.* for the interfaces and Data.* for implementations
20:00:39 <ddarius> This is much like C# (and many other mainstream OO languages) IDictionary and Dictionary.  Your code takes IDictionaries and the user will use Dictionary most of the time, but could pass in MyInstrumentedDictionary if that's what they needed.
20:01:28 <tomberek> we ARE talking about an OO-like idea here.  But that doesn't mean it's bad or poisonous, it might be useful.
20:01:43 <danharaj> This is just a slight philosophical disagreement then. If I were writing a nonstandard data structures library I would put it in Data.LibraryName.*, and I would like the standard stuff to be structured similarly. All in all it doesn't really matter. Interface.* is the important part, I agree.
20:02:08 <dmwit> ?index readIOArray
20:02:08 <lambdabot> bzzt
20:02:13 <dmwit> ?hoogle readIOArray
20:02:13 <tensorpudding> A new module system would be nice, it would.
20:02:14 <lambdabot> No results found
20:02:52 <cdsmithus> ddarius: Yep, the instrumentation case is, IMO, far stronger than the "substitute an optimized structure" case.  A lot of good abstraction can be had by wrapping types in a type class
20:03:38 <kmc> type classes are often overused
20:03:39 <ddarius> tomberek: Actually, I would really like it if a standard interface had explicit support for OO-like patterns too.
20:03:39 <danharaj> Then again, I think like a C++ person. I would also like the ability to define sub-namespaces in modules and for modules to default to qualified export etc...
20:03:42 <ddarius> kmc: Agreed.
20:03:55 <tensorpudding> The documentation on Edison is verbose and somewhat complex
20:03:59 <ddarius> kmc: That's one of the issues I have with Edison.  I'm not sure if type classes are actually the best solution.
20:04:02 <kmc> maybe the ideal interface for a (mutable) array is not a type class but just a record of "new", "test", "insert", etc. functions
20:04:14 <kmc> Haskell records suck too, but that's a more superficial problem
20:04:18 <tensorpudding> It's talking about equivalence classes.
20:05:34 <danharaj> Would existential types be a reasonable implementation of these theoretical interfaces?
20:05:48 <kmc> in some cases
20:05:59 <tomberek> kmc: can't a type family convert between a type class to record style?
20:06:00 <danharaj> ...but not all, I suppose, and aye, there's the rub
20:06:02 <kmc> sometimes you can avoid existentials by using closure, continuation-passing style, or other tricks
20:06:11 <ddarius> danharaj: Existentials would be reasonably for supporting the OO part, but should not be the main interface.
20:06:12 <kmc> tomberek, possibly? interesting idea
20:06:34 <kmc> and by "sometimes" i mean "always"; i think existentials can always be CPS-transformed to universals in negative position
20:07:13 <danharaj> ddarius: What are the disadvantages of using existentials as the main interface?
20:07:34 <kmc> scary name
20:07:35 <kmc> ;)
20:07:38 <danharaj> heh :p
20:07:46 <tomberek> danharaj: ugly and foreign to newcommers?
20:08:26 <danharaj> tomberek: I found polymorphic types foreign and strange, too. Existentials are treated like they're exotic as a matter of culture IMO
20:08:27 <ddarius> danharaj: Basically binary operations.  For example, set merge usually takes advantage of both sets being the same structure.  It's possible to make a merge function that only uses the external interface, but at the cost of performance and, in some cases, complexity.
20:08:47 <ddarius> Most newcomers would actually be more familiar with existentials I'd think...
20:09:07 <danharaj> ddarius: Ah I see, there is no way to force two instances of an existential to actually be using the same underlying structure.
20:09:13 <ddarius> danharaj: By using an OO-y interface, we would inherent the problems of OO interfaces.
20:09:54 <tensorpudding> Dammit forgot to renice cabal again
20:10:22 <ddarius> However, if everyone is coding to interfaces and sometimes I need to combine libraries that have, for some reason or another, made specific choices.  I now need a way to say, I really don't care what the choice was as long as it follows the interface which is exactly what existentials and OO allow.
20:10:51 <danharaj> The problem is really at library boundaries, where one convention might be used on one side and another on the other side.
20:11:47 <tensorpudding> Why does it take several hundred megabytes of memory to link Haskell libraries?
20:12:29 <danharaj> (Is it a joke? :D)
20:12:30 <gwern> tensorpudding: gnu ld sucks, split objs, and a few other htings like that
20:12:53 <ddarius> tensorpudding: If they were made with --enable-split-objs, the linker chokes on them.
20:12:56 <tensorpudding> Yeah, I definitely noticed an improvement when I was using gold.
20:13:43 <tensorpudding> Though I'm trying to figure out how to have cabal use gold without having to have ld be a symlink to it
20:13:46 <ddarius> I believe ld especially and gold to a lesser extent simply aren't using appropriate structures to scale in that way simply because they didn't think it would be a big issue.
20:14:17 <kmc> imo, interfaces are one of the things traditional OO does pretty well
20:14:31 <tensorpudding> But I don't have nearly as much pain linking C and C++ applications using ld.
20:14:50 <gwern> tensorpudding: I think it may be hardwired
20:15:04 <gwern> se Simple/Program/Builtin.hs
20:15:05 <tensorpudding> I regularly expect that when I start compiling Haskell it will bog my computer down to a halt for the duration.
20:15:13 <tomberek> existentials vs type family : overlaps? pros/cons?
20:15:28 <kmc> not very similar things
20:15:30 <ddarius> kmc: Well most OO systems almost do the right thing by default, and the actual right thing is strongly evangelized.
20:15:32 <kmc> not cleary how to compare them
20:15:43 <ddarius> kmc: Then it is all broken by implementation inheritance, but, oh well.
20:15:46 <kmc> yes
20:15:58 <ezyang> But we should steal the good bits.
20:16:47 <kmc> i think much of the hate for OOP is misdirected.  many OOP principles are useful (in Haskell too).  several popular OOP languages suck in specific ways, and they all encourage mutability to an unhealthy degree
20:17:02 <tensorpudding> On the plus side, I'm learning the virtue of patience.
20:17:05 <danharaj> kmc: I like OOP for data abstraction, hate it for program structure
20:17:09 <kmc> after using C++ or Java, OOP in Python or Lisp or Haskell is a breath of fresh air
20:17:20 <kmc> danharaj, yeah
20:17:24 <cdsmithus> kmc: Equivalently, it's annoying how many people say "OOP" when they really mean "good design".  But, it amounts to the same thing.
20:17:38 <kmc> yeah, it is annoying how OOP takes credit for much more basic ideas like abstract data
20:17:41 <kmc> but so it is with every religion
20:17:50 <danharaj> heh
20:18:04 <danharaj> I like Alexander Stepanov's criticisms of OOP, very cogent. He designed the STL.
20:18:09 <ddarius> kmc: I think most of that feeling of "hate" comes from newer people that have just started looking at Haskell (or FP) because of issues they've had with OOP.
20:18:28 <ddarius> kmc: I think most longer term users of Haskell are pretty clear on the costs and benefits of OO.
20:19:01 <kmc> danharaj, agreed about data vs. program structure.  in a lot of Java projects you have a proliferation of unnatural classes that don't represent any part of the problem domain or data, but exist because classes are the only viable way to structure control flow
20:19:07 <kmc> and it just ends up obfuscating things
20:19:20 <gwern> I like christianity taking credit for virgin births
20:19:32 <danharaj> kmc: I think OOP as program structure emphasizes state as structure, rather than algorithm as structure. That is why I dislike it.
20:19:39 <tensorpudding> Is there prior art in the virgin birth department?
20:19:47 <kmc> hell yes
20:19:55 <ddarius> tensorpudding: There are definitely earlier religions with similar things.
20:20:01 <tomberek> of course, greeks
20:20:03 <gwern> tensorpudding: it was a standard claim by middle eastern rulers
20:20:03 <ddarius> As well as myths and such.
20:20:13 <tensorpudding> eh
20:20:14 <gwern> particularly in mesopotamia
20:20:19 <danharaj> I like the STL because it emphasizes algorithm as structure. I like Haskell because it makes algorithm as structure very clean and easy :)
20:20:27 <gwern> you claimed to be descended of your current sky god by way of a virgin mother
20:21:16 <danharaj> I am sad because I can't think of a solution to DDarius' point about existentials being inefficient for binary operations.
20:21:18 <tensorpudding> Hmm.
20:21:19 * iaefai is the son of a magical sky daddy.
20:21:22 <danharaj> Otherwise they seem so nice.
20:21:36 <ddarius> danharaj: The solution is multimethods or type classes.
20:21:49 <ddarius> Depending on whether you want dynamic or static resolution.
20:21:53 <tensorpudding> It was definitely standard to claim divine origin, but I never thought about the fact that it'd have to be a virgin birth.
20:22:05 <kmc> you can also claim three-way conception
20:22:52 <tensorpudding> Well, do they claim that the maidens seduced by Zeus were virgins after the deed?
20:23:02 * gwern suspects not
20:23:05 <tensorpudding> kmc: Is that when the Holy Spirit gets in on the action?
20:23:13 <danharaj> ddarius: Yet another difficult choice. Philosophically, I think static resolution fits better with the rest of Haskell, maybe?
20:23:43 <danharaj> ddarius: But dynamic dispatch avoids further proliferation of type classes.
20:23:47 <ddarius> danharaj: There isn't much choice.  Encoding multimethods would be ugly.  Definitely not something you want to do for a "standard" library.
20:23:56 <Rotaerk> mary was just a ho who didn't want to get in trouble for cheating
20:23:57 <danharaj> ddarius: fair enough
20:24:00 <Rotaerk> *cough*
20:24:06 <Rotaerk> so she made up a story
20:24:13 <gwern> Rotaerk: and her lover was a roman centurion?
20:24:28 <tensorpudding> They do say that Mary was filled with the Holy Spirit didn't they..
20:24:35 <ddarius> danharaj: Type classes are also a fairly good solution.  For example, equals is a quintessential example of the binary method problem which is handled very well by type classes.
20:24:35 <Rotaerk> gwern, coulda been any number of guys
20:24:51 <tomberek> ok ok ok, enough mythology... where are we in the discussion for this Collections project?
20:25:03 * ddarius is about to go running.
20:25:14 <danharaj> ddarius: Have fun. :)
20:26:39 <cdsmithus> Grr... modifyMVar and runStateT need to work better together.  The tuples are backward
20:26:44 <tensorpudding> It's too easy to be sacrilegious for the sake of humor.
20:27:10 <ezyang> A friend of mine complains that the Haskell community needs to grow up into software engineers :-/
20:27:30 <kmc> yeah
20:27:40 <danharaj> "Software engineers" have ridiculously low levels of quality compared to 'real engineers'.
20:28:09 <danharaj> The amount of rigor that goes into software is laughable compared to, say civil engineering.
20:28:25 <kmc> let's turn all the lambdas on hackage into abstract delegate factory manager factories
20:28:27 <danharaj> In that respect, the Haskell community is closer to being engineers than the software industry.
20:28:59 <tensorpudding> There is a point there.
20:29:02 <kmc> ezyang, my strawman aside, i'm interested to hear what your friend's complaints are
20:29:04 <kmc> more specifically
20:29:22 <tensorpudding> That is, that Haskell is too idealistic and hacking-focused.
20:29:48 <ezyang> kmc: I think API stability and consistency are the main ones.
20:29:59 <kmc> yeah
20:30:03 <ezyang> He doesn't have time to deal with packages deciding to break BC every other release.
20:30:13 <kmc> i think GHC, standard libs, etc. are improving pretty quickly, and that's the downside
20:30:47 <ezyang> We're in the awkward place where things that should be fixed can't be fixed, cuz of BC, but most things can be fixed and break BC.
20:31:23 <danharaj> That is a fair point.
20:31:42 <tensorpudding> Are people joking when they say they want Haskell to not become popular?
20:31:50 <danharaj> Perhaps not :)
20:31:51 <tomberek> yes and no
20:31:52 <ezyang> Not really...
20:32:10 <kmc> Haskell is the ultimate hipster language
20:32:37 <Rotaerk> if haskell became popular, it would sure filter out a lot of bad coders
20:32:54 <kmc> we talk about how it's so much better than the mainstream, and everyone who doesn't see that is deluded
20:33:00 <kmc> at the same time we all secretly hope it stays underground ;)
20:33:02 <Rotaerk> not that you can't write bad code in haskell... but the concepts are too brainy for a lot of people...
20:33:07 <tensorpudding> I'm not saying that Haskell should sell out, but claiming that Haskell should never grow large enough that it does anything useful in the software world is claiming that it has no real purpose to exist outside of didactics and academic foolery.
20:33:21 <kmc> tensorpudding, it's already passed that point
20:33:30 <ezyang> ==kmc
20:33:34 <tensorpudding> That is has changed the software world, or that it has sold out?
20:33:41 <kmc> Rotaerk, i think it's a better filter now, in that quite apart from any inherent property of Haskell, it's a filter just because bad programmers don't bother to learn it
20:33:47 <kmc> the same was true with Python at one point, even though Python is easy as pie
20:33:56 <kmc> Paul Graham wrote an essay about it
20:34:07 <kmc> nobody learns Haskell just to get a job
20:34:17 <Rotaerk> it's not serving as a filter just because bad programmers don't bother to learn it, since the demand for skill in haskell is so low
20:34:32 <tensorpudding> Haskell is weighted by what it is, it's not going to attract people in the same way that Python is.
20:34:33 <ezyang> It's a pretty hard language to get your first program to compile in, I'll admit
20:34:34 <Rotaerk> there has to be demand for haskell programmers in order for the filter to have any effect
20:35:01 <danharaj> Haskell as a first language is probably much easier than trying to learn it after getting stuck in the imperative paradigm.
20:35:07 <tensorpudding> Though there are good signs that FP is becoming mainstream so there is potential for that to change.
20:35:23 <Rotaerk> danharaj, I dunno; imperative is much more intuitive
20:35:31 * ezyang bemoans the fact that MIT teaches FP... in Java. 
20:35:34 <Rotaerk> my dad thinks of programming as "entering a sequence of commands"
20:35:53 <Rotaerk> which isn't quite right but definitely descriptive of imperative
20:36:11 <ezyang> People claim that Java has good damage control properties.
20:36:29 <tensorpudding> I still would say that being Unix-centric is disadvantagous though.
20:36:30 <ezyang> I wonder if this is true for Haskell.
20:36:54 <Rotaerk> haskell is unix centric?
20:38:20 <tensorpudding> You can run it in Cygwin I guess.
20:38:24 <BMeph> Rotaerk: Check the number of hackage packages that depend on the 'unix' package, versus the 'win32' (is there a "win" package?) one.
20:38:38 <dmwit> Haskell is not Unix-centric, but many implementations have a more polished user experience on Unixes.
20:39:02 <tensorpudding> But it's not just the "can it run on Windows" but "is it easy to set up and use on Windows"
20:39:28 <ManateeLazyCat> Word is okay for "unsigned long int" ?
20:39:28 <danharaj> Getting wxhaskell to build on windows was a bitch
20:39:35 <Rotaerk> it's easy to get setup on windows
20:39:38 <ManateeLazyCat> Or Word32 ?
20:39:50 <danharaj> but only because the haskell platform for some reason dropped C++ compilation.
20:39:52 <tensorpudding> The Platform is easy to setup
20:39:52 <ManateeLazyCat> danharaj: Same as gtk2hs, :)
20:39:54 <BMeph> Frankly, I would rather just run it in a VM than use cygwin. I may just be out of touch with current state-of-the-art, but to me, Cygwin always seemed to be combining the worst parts of Unix and Windows.
20:40:00 <tensorpudding> But building packages is less so.
20:40:22 <tensorpudding> Especially ones that are tied to things external to Haskell, like wxhaskell.
20:40:41 <tensorpudding> (does gtk2hs even work on Windows?)
20:41:02 <BMeph> tensorpudding: (Ask ManateeLazyCat about that... ;)
20:41:19 * ddarius started using Haskell on Windows and back when there was much less infrastructure support.
20:41:19 <tensorpudding> Also you ask what the most popular programs written in Haskell are...
20:41:58 <tensorpudding> You have XMonad, which is definitely not Windowsy
20:42:05 <ManateeLazyCat> tensorpudding: AFAIK, gtk2hs can't install on Windows.
20:42:12 * ddarius has, actually, only used Ion on Windows.
20:42:29 <ManateeLazyCat> tensorpudding: But good news, the author of leksah try to help us install gtk2hs on Windows.
20:42:30 * ddarius drips sweat profusely.
20:42:40 <tensorpudding> You can run XMonad in the X11 server on Cygwin or MinGW but that's no fun.
20:42:50 <ManateeLazyCat> tensorpudding: He has send patch for Windows, we need review it.
20:42:53 <tensorpudding> Does Darcs have an implementation on Windows?
20:42:59 <tomberek> yes
20:42:59 <danharaj> yes.
20:43:01 <tensorpudding> ManateeLazyCat: That's good news
20:43:04 <cdsmithus> tensorpudding: Darcs works fine on Windows
20:43:04 <danharaj> Darcs is painless on windows.
20:43:06 <ddarius> tensorpudding: Indeed. It was not much fun with Ion when I did that.
20:43:22 <tensorpudding> Darcs is good news then.
20:43:55 <ezyang> It's really hard to get myself to care about Windows, now that I don't use it anymore.
20:43:59 <tensorpudding> It might be easier to get Windows folk to use Darcs since they're less close to Git
20:44:10 <ezyang> Back then, I'd go to really outrageous lengths to get things working on Windows.
20:44:10 <ManateeLazyCat> tensorpudding: AFAIK, most Windows problem is not problem of gtk2hs, it's problem of Cabal, header file, path... something  on Windows.
20:44:12 <danharaj> Git is a bitch on windows :|
20:44:31 <JoeyA> Are lists in Haskell implemented as doubly-linked?  That is, are last and ++ fast?
20:44:35 <tensorpudding> Though apparently Mercurial is popular on Windows or something.
20:44:39 <scotthw> > map (- 2) [1,2,3,4,5]
20:44:40 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
20:44:40 <lambdabot>    arising from a use of `e_1212345'...
20:44:42 <JoeyA> or does ++ require traversing the entire first list?
20:44:44 <scotthw> why doesnt that work?
20:44:46 <ManateeLazyCat> danharaj: Maybe Windows is bitch? :)
20:44:56 <tensorpudding> JoeyA: they're cons-lists, so not doubly-linked
20:45:08 <JoeyA> > map (+ 2) [1,2,3,4,5]
20:45:09 <lambdabot>   [3,4,5,6,7]
20:45:15 <JoeyA> map (- 2) [1,2,3,4,5]
20:45:18 <Rotaerk> JoeyA, it's basically a singly-linked list; you have to traverse starting at the head
20:45:19 <tensorpudding> @src (++)
20:45:20 <lambdabot> []     ++ ys = ys
20:45:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:45:20 <lambdabot> -- OR
20:45:20 <lambdabot> xs ++ ys = foldr (:) ys xs
20:45:21 <JoeyA> > map (subtract 2) [1,2,3,4,5]
20:45:22 <lambdabot>   [-1,0,1,2,3]
20:45:28 <scotthw> whoa
20:45:31 <cdsmithus> As far as Haskell being hard to compile a first program in, I never have seen that.  I do think a lot of people get tripped up by some of the intermediate stuff, like functors and monoids and the like.  The biggest obstacle seems to be in going from "I can compile basic code" to "I know what people are talking about on those blog posts"
20:45:35 <tensorpudding> as you can see, (++) has to traverse all of the first list
20:45:39 <JoeyA> scotthw> That's because - is also a prefix operator
20:45:44 <JoeyA> - 2 means negative 2
20:45:44 <scotthw> K
20:45:47 <cdsmithus> (Yeah, I know, that was the topic from 5 minutes ago)
20:45:49 <scotthw> right, gotcha
20:45:52 <JoeyA> so you need the subtract operator for that.
20:45:55 <scotthw> I didn't realize that
20:45:58 <Rotaerk> haskell itself isn't too hard, it's the abstract design patterns
20:46:00 <danharaj> Really? concatenation is O(n)?
20:46:04 <danharaj> That seems unacceptable.
20:46:06 <ezyang> cdsmithus: It certainly took me some time to compile my first program, partially because the GHC error messages seemed really opaque.
20:46:25 <ezyang> and it took me a while before I could effectively fix compile errors in constant time.
20:46:32 <JoeyA> I mean, somewhat conceptually, lists in Haskell are singly-linked cons lists.
20:46:37 <ManateeLazyCat> tensorpudding: But i think it's not too hard make gtk2hs works on Windows, just few gtk2hs developer on Windows. :)
20:46:37 <Rotaerk> took me a while to understand monads...
20:46:40 <ezyang> Though, come to think of it, this might be true of most languages...
20:46:41 <Rotaerk> but now they seem intuitive
20:46:42 <JoeyA> My question is, is that how they're really implemented in ghc?
20:46:56 <cdsmithus> JoeyA: Basically, yes.
20:47:03 <tensorpudding> ManateeLazyCat: That's the thing, is that a lot of Haskell developers don't use Windows and therefore aren't keen on working with it.
20:47:24 <cdsmithus> JoeyA: But, modulo a lot of rewriting rules that can kick in and make some things quite fast
20:47:37 <ManateeLazyCat> tensorpudding: Infact, it's not problem of technology, just haskeller don't like Windows . :)
20:47:39 <tensorpudding> I guess I'm a hypocrite saying it, because I don't use Windows either.
20:48:06 <cdsmithus> I don't use Windows... but honestly, that's mostly because a lot of Haskell stuff seemed to break there
20:48:18 <cdsmithus> I tried to start out with Haskell in Windows.  Very painful
20:48:19 <BMeph> I think Haskell is tough to write your first ptogram in...as long as you insist that your first program will always involve drawing something on the screen, accessing something by network protocols, or both. :)
20:48:19 <ManateeLazyCat> tensorpudding: Hehe, unfortunate for Windows users. :)
20:48:44 <cdsmithus> But that was four years ago.  Stuff has changed now with the Windows picture
20:49:08 <ManateeLazyCat> If you want use gtk2hs and don't care which OS, i recommend use Linux.
20:49:28 <danharaj> ManateeLazyCat: No one thinks that way.
20:49:30 <ManateeLazyCat> You will found install gtk2hs is so easy like other Cabal package. :)
20:49:37 <cdsmithus> BMeph: yes, but that's also true for C, for example.
20:50:22 <tomberek> what do you guys think about John Meacham's ideas for class aliases and supertyping?
20:50:32 <cdsmithus> tomberek: link?
20:50:41 * ManateeLazyCat Blah enough, continue to write library to parse /proc ... 
20:50:43 <tomberek> http://repetae.net/recent/out/classalias.html
20:50:46 <danharaj> tomberek: who to the whatnow?
20:50:55 <tomberek> http://repetae.net/recent/out/supertyping.html
20:52:14 <tensorpudding> supertypes, the supersymmetric dual to types
20:52:45 <BMeph> I was mildly interested in Google's "Go" language, but was immediately disinterested when finding out it was *nix-only.
20:52:46 <ManateeLazyCat> cmajflt %lu The number of major faults that the process's waited-for children have made. Who write proc manual?
20:53:03 * ManateeLazyCat I doubt i can't understand "cmajflt" if i don't read documentation. 
20:53:07 <tensorpudding> They didn't port Go to Plan 9?
20:53:26 <ezyang> When SPJ uses +++ in his slides, does he mean +:+ ?
20:53:33 <ManateeLazyCat> BMeph: Go ? I prefer like Haskell. :)
20:54:00 <danharaj> I like type aliases.
20:54:07 <danharaj> er class aliases.
20:54:08 <ManateeLazyCat> BMeph: Just use Go because it's develop by Google ?
20:54:12 <kmc> :>
20:54:41 <BMeph> ManateeLazyCat: I like looking at new languages, especially if they seem to have something interesting to offer. Haskell does. Go, IMNATHO, does not.
20:54:55 <danharaj> Supertypes also seem very reasonable.
20:55:11 <ManateeLazyCat> BMeph: "Go" has any feature that Haskell can't does ?
20:55:26 <deteego> does anyone know if there is a major difference
20:55:30 <deteego> between reactive and yampa?
20:55:39 * ManateeLazyCat I think any other language is dirty after i love with Haskell. :)
20:55:54 <tomberek> it seems there is so much effort on advanced stuff, when the basics are being neglected
20:56:05 <Rotaerk> ManateeLazyCat, I think you broke your english module
20:56:07 <cdsmithus> So, class aliases are basically the non-family part of http://www.cs.kuleuven.be/~toms/Research/papers/constraint_families.pdf ?  Seems quite reasonable.
20:56:07 <BMeph> deteego: Reactive is newer. ;)
20:56:21 <ezyang> tomberek: Remember, the Haskell community is chock full of academics
20:56:23 <dmwit> ManateeLazyCat: Agda...
20:56:29 <deteego> BMeph: apart from that is there a major difference?
20:56:38 <ManateeLazyCat> Rotaerk: Yeah, yeah.. :)
20:56:41 <tomberek> ezyang... true, what about the rest of us?
20:56:53 <ManateeLazyCat> ezyang: Really?
20:57:02 <kmc> Go isn't "developed by Google".  it's developed by some old-school C/UNIX guys who Google purchased^Whired for publicity reasons
20:57:41 <ezyang> ManateeLazyCat: A large portion, at least
20:57:43 <tensorpudding> That's a bit cynical, to say that they were purchased.
20:57:48 <ezyang> The rest of us are off making GUI apps :o)
20:57:57 <kmc> people who, though enormously successful and clever in their own way, have probably never read a book on programming language theory or design
20:58:00 <ManateeLazyCat> ezyang: Yes, that's i want to do.
20:58:07 <BMeph> deteego: I'd have to dig into Yampa, but from what I gather, they should be very similar.
20:58:32 <Adamant> kmc: not that I'm a big fan of 'Go', but I would question that assertion
20:58:36 <ManateeLazyCat> ezyang: Build a Haskell GUI platform make more haskeller hacking on GUIs. :)
20:59:00 <ezyang> ManateeLazyCat: That sounds like hard grubby work and a ticket to an unlimited service contract (on your part)
20:59:18 <ManateeLazyCat> ezyang: Yes, i have build one.
20:59:25 <ManateeLazyCat> ezyang: Any core have finish.
20:59:32 <ManateeLazyCat> ezyang: Just wait gtk2hs release.
21:00:15 <ezyang> Language module rapidly deteriorating!
21:00:18 <BMeph> I sometimes wonder if Haskell's types should be modeled on another language - Oz, maybe. ;)
21:00:24 <ManateeLazyCat> ezyang: Haskell will more poplar if have a general GUIs platform for hacking. :)
21:00:36 <ezyang> The first thing to do is stop hitching your saddle to GTK
21:00:46 <ManateeLazyCat> ezyang: Why?
21:00:46 <ezyang> IMO
21:00:58 <danharaj> because I wouldn't use GTK on windows.
21:01:02 <ManateeLazyCat> ezyang: You know what's it?
21:01:05 <ezyang> precisely
21:01:10 <danharaj> And why would you couple your project to a specific backend?
21:01:22 <danharaj> What if the gtk2hs project just died tomorrow?
21:01:23 <ezyang> But it turns out, cross-GUI abstraction is hard.
21:01:36 <ezyang> It would be a great loss for all of us.
21:01:42 <tensorpudding> Are there Haskell bindings to the native Windows API?
21:01:49 <kmc> yeah
21:01:52 <tensorpudding> so you can use whatever GUI stuff they have
21:01:53 <ManateeLazyCat> danharaj: I don't like Windows, want build a awesome Haskell GUIs platform for Unix. :)
21:01:55 <kmc> in Platform even, iirc
21:01:59 <kmc> that's pretty hairy though
21:01:59 <tensorpudding> MVC or whatever
21:02:15 <ezyang> In that case, you lose.
21:02:16 <ManateeLazyCat> tensorpudding: MVC is evil.
21:02:27 <kmc> what's wrong with MVC?
21:02:33 <ezyang> MVC is a good idea.
21:02:33 * danharaj vomits at the sound of MVC
21:02:44 <ManateeLazyCat> No,
21:02:49 <ManateeLazyCat> I read wrong.
21:03:00 <ManateeLazyCat> I mean MFC is evil.
21:03:05 <danharaj> Well, yes.
21:03:06 <ManateeLazyCat> Sorry, read wrong.
21:03:10 <kmc> hehe
21:03:16 <tensorpudding> I think MFC was what I meant, actually.
21:03:18 <danharaj> But MVC is not really functional idiomatic is it?
21:03:21 <ManateeLazyCat> MVC is awesome.
21:03:27 <tensorpudding> I was talking about the Windows GUI thing
21:03:28 <ezyang> danharaj: If you distill it down
21:03:32 <tensorpudding> not Model-View-Controller.
21:03:35 <p_l> MFC isn't actually "native GUI"
21:03:36 <ezyang> to just the dependency chain
21:03:41 <p_l> last time I checked.
21:03:56 <ManateeLazyCat> danharaj: Infact, Gtk+ don't use MVC, use MV
21:04:06 <ezyang> V <-> C, M <-> C, M <-/-> V, it's good sound advice.
21:04:09 <BMeph> I'm impressed with what Factor's done - it's like a bastard child of Forth and CL... :)
21:04:11 <ManateeLazyCat> danharaj: Gtk+ mix `M` and `C`.
21:04:23 <dolio> I've seen folks argue that FRP is about the same thing as MVC.
21:04:25 <danharaj> ManateeLazyCat: I can't convey to you just how little I care about GTK
21:04:29 <ManateeLazyCat> danharaj: And MV (Model/View) is simpler .:)
21:04:34 <dolio> So, inasmuch as you like FRP, you like MVC.
21:04:50 <danharaj> dolio: Maybe practically, but I think philosophically FRP emphasizes things differently than MVC
21:04:57 <danharaj> MVC is an OOP paradigm.
21:05:06 <ManateeLazyCat> dnolen: Ok, i off.
21:05:09 <kmc> haha danharaj
21:05:28 <ManateeLazyCat> kmc: Need sleep..... :)
21:05:41 <ddarius> JoeyA: Doubly-linked lists would be horrible for a persistent list type.
21:05:59 <tensorpudding> But what is the "native" GUI for Windows anyway?
21:06:01 <dolio> In fact, the first time I heard it, it was a guy pushing an FRP toolkit for JavaScript, but denying that it had anything to do with functional programming, and was just good MVC practice.
21:06:11 <danharaj> tensorpudding: the barebonse win32 api is an evil place
21:06:20 <ManateeLazyCat> kmc: My head is not clear now ...
21:06:30 <danharaj> tensorpudding: I think .NET is the standard nowadays
21:06:32 <tensorpudding> I heard about Winforms, is that the new thing?
21:06:51 <danharaj> Winfroms is part of .NET I think.
21:06:58 <tensorpudding> Maybe we need to make IronHaskell
21:07:12 <danharaj> What would that be
21:07:14 <kmc> there have been several Haskell/.NET interop projects
21:07:21 <tensorpudding> Haskell that runs on .NET, presumably.
21:07:27 <danharaj> ah.
21:07:39 <kmc> some just for FFI calling, some compiling Haskell to CLR
21:07:42 <tensorpudding> An analogue of IronPython
21:07:44 * ManateeLazyCat Anyway i don't like Windows, i don't what happen in it's "black box", i can't fix it if i found a bug.....
21:08:06 <tensorpudding> there's an Ruby on .NET too isn't there?
21:08:11 <kmc> IronRuby
21:08:13 <tensorpudding> Yeah.
21:08:17 <BMeph> danharaj: "IronY" is basically slang for "Y on the CLR VM"
21:08:29 <danharaj> You had to use 'Y' didn't you :)
21:08:37 <tensorpudding> F# is IronCaml
21:08:42 <kmc> hehe
21:08:42 <danharaj> heh
21:08:48 * BMeph agrees!
21:08:49 <ezyang> Hmm.
21:08:57 <ezyang> I need to see the flattened version of quicksort
21:09:03 <ezyang> *dph quicksort
21:09:07 <tensorpudding> Hmm
21:09:14 <tensorpudding> There's no Haskell on the JVM either.
21:09:18 <tensorpudding> Jaskell?
21:09:20 <BMeph> danharaj: I contemplated using "IC" instead of "Y"...but I wanted to be Subtle... :D
21:09:30 <tensorpudding> jhc might already exist
21:09:33 <danharaj> BMeph :p
21:09:56 <tensorpudding> If they ported OCaml to the JVM, they'd have to call it Joe Camel
21:10:14 <ddarius> There is a JoCaml, but it is something else.
21:13:45 <ezyang> Like, I'm failing to see the nested data parallelism
21:14:22 <ezyang> [: sort a | a <- [: lt, gt :] :] desugars to mapP sort [: lt, gt :]
21:14:34 <ezyang> and then... I don't see it >_<
21:15:38 <rl> ezyang: you apply sort in parallel to lt and gt and sort itself contains parallelism
21:16:24 <ezyang> ah, right, sort contains parallelism
21:16:32 <ezyang> that makes this... a kind of messy example, I guess
21:16:51 <rl> ezyang: messy?
21:17:04 <ezyang> I guess it's why SPJ says "instant insanity when done by hand"
21:17:17 <ezyang> rl: I want to look at the flattened version
21:17:27 <ezyang> to get a feel for what vectorization is getting me
21:17:37 <JoeyA> > map f [1,2,3] where f x = 2*x
21:17:38 <lambdabot>   <no location info>: parse error on input `where'
21:18:06 <rl> ezyang: it's messy :)
21:18:21 <ezyang> Blah. Do you have a better thing to do?
21:18:34 <rl> ezyang: you can compile with -dverbose-core2core and then looks at the output of simpifier Phase 3
21:18:35 <ezyang> *to flatten to peek at the structure of the nested data parallelism
21:18:52 * BMeph proselytizes: DPH. Stops time. Tell your friends.
21:19:03 <ezyang> Well, if it's that messy, I don't have high hopes on understanding the output :-)
21:19:08 <ezyang> But I can try that.
21:19:12 <ezyang> Do I need 6.12?
21:19:26 <rl> you need the current head
21:19:35 <ezyang> oh man, yak shaving time
21:19:45 <ezyang> maybe I should do sparse matrices instead...
21:20:04 <ezyang> anyway, compiling GHC is something I've been meaning to do for a while, so I guess I'll spin that up
21:20:17 <illissius> what happens if you have haskell packages (including some of the same ones) installed from both apt and cabal? is one of them invisible? do they live peacefully side by side? which one does it use?
21:20:26 <rl> the quicksort example is in libraries/dph/examples/qsort
21:20:50 <ddarius> illissius: It depends on whether the ones installed with cabal are installed user or global.  The default is user I believe.
21:21:14 <ezyang> rl: Do you recommend darcs or the tarballs?
21:21:43 <illissius> ddarius: well, let's say global then
21:21:52 <rl> ezyang: darcs
21:22:42 <rl> ezyang: but GHC generates a *lot* of code for this
21:22:44 <ddarius> illissius: Then probably whichever was (successfully) installed last has precedence, but that's assuming you only have one GHC.
21:22:46 <ezyang> ha, the test suite is written in Python
21:22:50 <ezyang> rl: How many GB?
21:23:49 <ddarius> illissius: You can use the ghc-pkg utility to look at what is available and will be used.
21:23:55 <rl> ezyang: I mean intermediate code, about 2k lines
21:24:01 <illissius> ddarius: ok, thanks
21:24:05 <ezyang> ...hooboy
21:24:14 <ezyang> Are sparse matrices better?
21:24:22 <rl> yeah
21:25:02 <rl> ezyang: but that code is basically on SPJ's slides
21:25:32 <ezyang> The unflattened version, you mean?
21:25:49 <ezyang> oh!!!
21:25:51 <rl> no, the flattened one
21:25:53 <ezyang> he does use svMul as an example
21:25:56 <ezyang> coolio
21:26:54 <ezyang> But... isn't smMul the function with the nested data parallelism?
21:28:42 <rl> smMul = svMul^
21:28:56 <ezyang> ...
21:28:58 <Cale> rl: Is that before or after the simplifier has eaten it?
21:29:00 <ezyang> whoa, did not realize that
21:29:14 <rl> ezyang: in general, mapP f = f^
21:29:32 <rl> Cale: before and hence after as well :)
21:29:35 <kmc> annoying when videos of talks have the presenter miked but not people asking questions
21:29:43 <ezyang> yeah, I forgot sparse matrix multiplication was just mapping the vector multiplication
21:29:53 <Cale> rl: (I mean about the 2k lines)
21:31:03 <rl> Cale: before, it's much more after (low-level loops and such)
21:31:36 <iaefai> In a haskell editor that is providing the functionality to run the program being edited, would it be reasonable to normally default to cabal, but if it has a runhaskell shebang, obey that instead?
21:31:59 <Cale> ah, okay
21:32:18 <Cale> rl: But you'd also expect that a lot of stuff gets discarded as well
21:33:11 <rl> Cale: yes, but the 2k lines figure is basically before inlining and we inline a *lot*
21:33:20 <Cale> right
21:33:44 <tomberek> Cale: i think you missed a conversation you might be interested in
21:34:36 <BMeph> kmc: Really good presenters are trained (and remember) to repeat the question asked. It's rare, but it happens, sometimes. ;)
21:34:43 <kmc> yeah
21:34:53 <kmc> also some fancy lecture halls have mikes at every seat
21:35:03 <kmc> though i'm not sure if anyone remembers to turn them on when they ask a question
21:35:12 <ezyang> Which version of gmp does GHC use? {2,3,4}
21:36:45 <kmc> none! (optionally, as of recently)
21:37:08 <ezyang> whoa!
21:38:21 * BMeph thinks someone (else!) should do up a DPH write-up of Hashlife...
21:41:55 <JoeyA> @src permutations
21:41:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:45:37 <ezyang> Dist = Distributed, if I understand correctly?
21:47:10 * hackagebot UMM 0.2.1 - A small command-line accounting tool  http://hackage.haskell.org/package/UMM-0.2.1 (UweHollerbach)
21:50:03 <mxc> do you need ot pass GHC a special flag to compile a latex .lhs file?
21:51:54 <mxc> nevermind, didn't realized \begin{code} needs to be on a new line
21:53:25 <SubStack> @pf \((a,b),(c,d)) -> (a + c, b + d)
21:53:25 <lambdabot> Maybe you meant: bf pl
21:53:33 <SubStack> o_O
21:54:36 <dolio> join (uncurry (+))
21:54:50 <dolio> Wait, no.
21:55:05 <SubStack> @pointless \((a,b),(c,d)) -> (a + c, b + d)
21:55:06 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+)))
21:55:10 <SubStack> certainly not that
21:56:07 <dolio> @type (+) *** (+) >>> uncurry (***)
21:56:08 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b, b') -> (b, b')
21:56:17 <dolio> @type uncurry $ (+) *** (+) >>> uncurry (***)
21:56:18 <lambdabot> forall b b'. (Num b, Num b') => ((b, b'), (b, b')) -> (b, b')
21:56:25 <dolio> Boom!
21:56:30 <djahandarie> HEADSHOT
21:57:22 <djahandarie> So yeah, best stay with the pointed version. :P
21:57:33 <dolio> > (uncurry $ (+) *** (+) >>> uncurry (***)) ((a,b),(c,d))
21:57:34 <lambdabot>   (a + c,b + d)
22:00:54 <deteego> hmm, im kinda going through a lot of FRP libraries trying to figure out if something I want to do is possible
22:01:09 <deteego> im basically making a template for binding functions to triggers
22:01:33 <deteego> where you bind a function (which takes the environment of the event as an argument) to a certain event
22:36:50 <deteego> basically I want to do something along the lines of this
22:36:51 <deteego> http://pastebin.com/VJgJqsy5
22:38:21 <deteego> eh make that http://pastebin.com/fPBaKkfd
22:41:45 <kmc> deteego, your "Bindings" type sounds like something from HList
22:42:20 <kmc> though it might be better done these days with data families
22:42:39 <kmc> but, i'm not really sure how that fits into the rest of it
22:42:42 <kmc> or what you're trying to do
22:43:28 <kmc> also, wouldn't it be  data Bindings a b ... z = Bindings a b ... z ?
22:57:51 <mxc> @src foldM
22:57:51 <lambdabot> foldM _ a []     = return a
22:57:52 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:02:27 <Cale> deteego: How about  onKey :: Event -> Char -> t -> (Char -> t -> IO ()) -> IO ()  ?
23:03:21 <Cale> (or you could just leave the t out altogether)
23:06:06 <Cale> deteego: I'm not sure that I understand the use case of these parameters
23:06:28 <Cale> deteego: If they're not going to vary, why not just make them part of the action that you're binding to the event?
23:07:43 <Cale> tomberek: oh?
23:16:41 <tomberek> Cale: yes
23:16:46 <ezyang> Oh noes! "ghc-stage1: internal error: PAP object entered!"
23:17:19 <tomberek> Cale: it was about organizing typeclasses for things like Sets, Collections, etc... the Edison package was suggested
23:20:39 <Cale> tomberek: Yeah, Edison had its own Prelude for that sort of thing
23:28:27 <BMeph> Hmm, reading http://debasishg.blogspot.com/2010/05/laziness-in-clojure-some-thoughts.html makes me think: 1) Clojure may not be as sexy as it looks from afar; 2) Debasish needs to get more experience using laxy structures.
23:32:34 <ddarius> BMeph: One of the lessons to come out of Haskell is that what is needed is a balance between laziness and eagerness and that this balance isn't trivial to achieve although in many practical cases it's not that hard (and how to do it in those cases is another thing that has come out of Haskell.)
23:34:30 <ezyang> Do we have a Handbook for Strictness annotations?
23:35:07 <olsner> apply liberally but in moderation?
23:35:39 <ezyang> For example, dons had a bunch of good rules of thumb for handling strictness with concurrency primitives
23:35:40 <deteego> Cale: http://pastebin.com/raw.php?i=C8zAJHsf
23:35:44 <ezyang> i.e., plz can haz
23:35:49 <deteego> thats an updated example
23:36:26 <deteego> Cale: also I sent an email to the haskell-beginner mailing list better describing why I want it to be such a format
23:41:53 <Cale> deteego: What was the message called?
23:43:03 <Cale> n/m I found it
23:45:39 <Cale> deteego: I still don't really understand why it wouldn't suffice just to bind an arbitrary IO action to each event.
23:46:08 <deteego> Cale: this isn't meant to be IO specific
23:46:16 <deteego> I just used pressing keys as an obvious example
23:46:21 <Cale> er...
23:46:48 <Cale> deteego: What are you trying to achieve with the 'Bindings' thing?
23:47:01 <ezyang> Hm, I wonder what a userspace implementation of sumP would look like, or if it has to be built into DPH
23:47:19 <deteego> Cale: well im kinda new to haskell so you need to give me some leaveway
23:47:20 <Cale> I don't understand from the examples you gave why they're a separate parameter to onKey, rather than just part of each 'testFunc'
23:47:46 <deteego> Cale: because for example, if you want to create another trigger within one of the testFunc functions
23:48:01 <Cale> deteego: Then you would add a couple of parameters...
23:48:13 <Cale> and you would partially apply
23:48:30 <Cale> For example, just make testFunc3 a function of x and z (and a)
23:48:53 <deteego> but then you cant use testFunc3
23:49:04 <deteego> for the onKey function
23:49:09 <Cale> So it would look like   testFunc3 x z a = putStrLn ([a] ++ show x ++ z)
23:49:29 <Cale> onKey Press 'C' (testFunc3 2 "cheese")
23:50:04 <deteego> yes but how would you define onKey to accept that
23:50:35 <deteego> I dont want to create a new onKey definition everytime I attach a function to a trigger that happens to have different bindings
23:50:40 <Cale> onKey :: Event -> Char -> IO () -> IO ()
23:50:51 <Cale> er
23:50:56 <Cale> onKey :: Event -> Char -> (Char -> IO ()) -> IO ()
23:51:03 <Cale> Well, either way.
23:51:20 <deteego> oh wait
23:51:23 <deteego> does the () notation
23:51:23 <Cale> In fact, my first one would actually possibly be better, it just wouldn't match the existing example.
23:51:28 <deteego> mean any number of arguments
23:51:31 <Cale> () means an empty tuple
23:51:49 <Cale> IO () is the type of IO actions which have the empty tuple as their result.
23:52:05 <Cale> (so they do something and don't produce a value)
23:52:15 <deteego> so using IO (), you can submit any number of parameters
23:52:19 <deteego> to a function
23:52:27 <Cale> A value of type IO () is not a function
23:52:40 <Cale> But you can define functions which take some parameters and produce IO () values
23:52:47 <kmc> a value of type "IO ()" is a recipe for doing IO
23:52:51 <kmc> it doesn't have arguments
23:53:11 <deteego> well for example
23:53:12 <deteego> when you do
23:53:14 <deteego> onKey Press 'C' (testFunc3 2 "cheese")
23:53:26 <deteego> how does that fit into onKey :: Event -> Char -> IO () -> IO ()
23:53:34 <kmc> deteego, () is the name of an ordinary type.  it has only one value, also named ()
23:53:35 <deteego> event is Press, Char is C
23:53:38 <kmc> :t ()
23:53:39 <lambdabot> ()
23:53:59 <Cale> If that's the type of onKey, then it means that testFunc3 had better have a type like  Integer -> String -> IO ()
23:54:58 <deteego> ah right
23:55:19 <deteego> so you are submitting a function that has to return IO
23:55:26 <deteego> ok well that issue is fixedd
23:55:29 <Cale> Just an IO action, in this case
23:55:34 <Cale> Not even a function
23:55:37 <deteego> how would I go about doing all the vent based stuff
23:55:43 <Cale> vent?
23:55:47 <Cale> oh, event
23:55:49 <deteego> event*
23:56:01 <deteego> using either Reactive or Yampa (or myself?)
23:56:01 <Cale> Which event based stuff?
23:56:15 <deteego> well the whole onKey stuff
23:56:18 <Cale> Reactive and Yampa don't use this sort of model of defining how things respond to events
23:56:32 <deteego> yeah thats what I thought
23:56:49 <Cale> They don't define things in terms of event handlers like this, because event handlers are not as composable as proper functions.
23:57:50 <deteego> Cale: right so I would have to make my own library for doing such a thing
23:57:50 <Cale> Instead, you would write a function which takes a stream of events, and defines some part of the output or intermediate state directly.
23:58:10 * ManateeLazyCat pasted "/proc library" at http://paste2.org/get/820881
23:58:10 <ManateeLazyCat> I have write some code (above link) to parse information from /proc/pid/stat , anyone help me test?
23:59:21 <Cale> Your overall program becomes a function from a bunch of Events (which are abstract sequences of values that happen at specific times), and Behaviours (which are abstract time-varying values), and produces some other set of events and behaviours describing the output.
23:59:36 <Zao> ManateeLazyCat: This sounds like it's specific to Linux's /proc.
23:59:45 <ManateeLazyCat> Zao: Yes.
23:59:48 <Zao> ManateeLazyCat: As there sure as heck isn't a /proc/pid on FreeBSD.
23:59:54 <Zao> (pids are directly in proc there)
