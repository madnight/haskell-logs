00:00:00 <bitstream0101> i'd expect to see an exception escape initClientSock though
00:00:21 <bitstream0101> as on preceding (connectWithTimeout-wrpaped) invocations, the exception is getting caught just fine via CE.try etc.
00:01:08 <int-e> what exception though?
00:01:54 <bitstream0101> hmm, good question. i'd not inspected it too closely: when it was shown it had just said something along the lines of "connect failed (destination does not exist)"
00:02:00 <bitstream0101> i'll see if i can snag that again
00:06:28 * hackagebot wai 0.1.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.1.0 (MichaelSnoyman)
00:06:30 * hackagebot wai-extra 0.1.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.2 (MichaelSnoyman)
00:06:38 <int-e> my guess is that it will still happen - but it'll take ages. 5 seconds plus 5 times whatever timeout the underlying TCP implementation uses for connects.
00:06:49 <int-e> err, 4 seconds plus that.
00:07:28 * hackagebot hamlet 0.2.3.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.2.3.1 (MichaelSnoyman)
00:07:44 <int-e> *Main> initClientSock "google.com" 81
00:07:45 <int-e> *** Exception: connect: timeout (Connection timed out)
00:08:11 <int-e> after 2 minutes or so? I didn't time it.
00:10:07 <bitstream0101> int-e: ah, interesting.
00:10:29 * hackagebot wai-handler-fastcgi 0.0.0.2 - WAI wrapper around direct-fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.0.0.2 (MichaelSnoyman)
00:11:29 * hackagebot clientsession 0.4.0 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.4.0 (MichaelSnoyman)
00:12:16 <b0fh_ua> Hi there. Where does cabal unpacks it's packages?
00:13:02 <b0fh_ua> I want to find out why editline doesn't build on my host, so I did "cabal unpack" and now wondering where to look for files )
00:13:12 <aavogt> it puts them in your current directory
00:13:16 <bitstream0101> int-e: i'm not seeing that behavior at all; in fact, if i wrap that connect in a CE.catch, and do a fail "onlast" or somesuch in the handler, i never see that failure
00:13:32 <b0fh_ua> oh, shame on me
00:13:33 <bitstream0101> int-e: instead, it just sits there, and i get a memory allocation failed request some time later :(
00:14:08 <bitstream0101> memory allocation failed* error
00:14:39 <int-e> fun :/
00:15:27 <bitstream0101> int-e: that doesn't make sense, though, right? i'm not misunderstanding the expected behavior at least...
00:15:39 <bitstream0101> int-e: i'd be much happier if i was seeing errors like what you described =P
00:17:04 <bitstream0101> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25609#a25611 for the version with debug spam; i get the trace msg on line 11, but the fail invocation seems to do nothing.
00:17:30 <int-e> yes. for what it's worth, I was using ghc 6.10.4 on Linux/x86
00:17:51 <bitstream0101> int-e: ok, cool. thanks for taking a peek at it =)
00:52:44 <djahandarie> @hoogle ([a] -> Bool) -> [a] -> ([a], [a])
00:52:45 <lambdabot> No results found
00:52:50 <djahandarie> :[
00:54:57 <Axman6> huh, i thought that was a function already
00:55:05 <copumpkin> (a -> Bool) is
00:55:06 <copumpkin> :t span
00:55:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:55:08 <djahandarie> Yeah
00:55:18 <copumpkin> you want it to work on inits?
00:55:23 <Axman6> i'm guessing span isn't what you want
00:55:54 <Axman6> > let foo f xs = (filter f xs, filter (not . f) xs) in f even [1..10]
00:55:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
00:55:55 <lambdabot>    arising fro...
00:56:04 <djahandarie> The way I'd want that to work is for it to check the powerset of [a]
00:56:04 <Axman6> > let foo f xs = (filter f xs, filter (not . f) xs) in foo even [1..10]
00:56:06 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
00:57:06 <copumpkin> djahandarie: hmm, and what would the resulting two lists be?
00:57:32 <djahandarie> It would be just like span -- break on the first time the funciton returns true
00:57:47 <djahandarie> Or rather, false
00:58:46 <copumpkin> hmmm
00:59:06 <copumpkin> I don't understand how the powerset fits into the ([a], [a])
00:59:28 <djahandarie> It doesn't, that's what the span' would be feeding to the predicate p
01:00:18 <copumpkin> yeah, but then what does the function return?
01:00:55 <djahandarie> breaks on the first occurence of that matched part of the powerset in the list
01:14:55 <ville> What is the scope of the where -clause? The whole function or something else?
01:15:12 <copumpkin> the expression
01:15:13 <Axman6> yes, i believe
01:15:32 <Axman6> it can see arguments passed to the function that thee where clase is a part of
01:16:13 <kmc_> it's attached to a function alternative (which could have multiple guards)
01:16:20 <kmc_> and scopes over the right hand side of all of that
01:16:58 <ville> ok so it's everything f = <this here> where x = 1
01:18:01 <ville> Can `do' appear only as the first thing after the `=' in a function?
01:18:17 <c_wraith> no.  do isn't really special at all.
01:18:35 <Kaidelong> question about GHCi
01:18:47 <Kaidelong> is a GHCi session "in the IO monad"?
01:18:55 <Kaidelong> so can I do stuff with the left arrow?
01:18:57 <copumpkin> more or less
01:18:59 <copumpkin> yes
01:19:01 <Kaidelong> yay
01:19:06 <copumpkin> it's not quite that simple
01:19:10 <copumpkin> but mostly
01:21:02 <b0fh_ua> Hello! Can someone suggest the function like f :: Int -> [a] -> [[a]], so f 2 "abcdef" = ["ab","cd","ef" ] ?
01:21:17 <Axman6> what's the easiest way to get a lift of Bool values representing the bits of a Word8?
01:22:54 <pastorn> Axman6: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Bits.html#v%3AtestBit
01:22:59 <pastorn> @type testBit
01:22:59 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
01:23:42 <pastorn> \w8 -> map (\n -> testBit w8 n) [0..7]
01:23:47 <pastorn> Axman6: ^^^
01:23:50 <Axman6> ta
01:23:51 <pastorn> i think...
01:23:58 <Botje> b0fh_ua: Data.List.Split has a chunk function
01:24:07 <copumpkin> > (\n -> unfoldr (pure . splitAt n)) 2 "abcdef"
01:24:08 <lambdabot>   ["ab","cd","ef","","","","","","","","","","","","","","","","","","","",""...
01:24:14 <ville> http://codepad.org/7E6ITenN here how would I call g or xxx before the `do' on line 24?
01:24:33 <pastorn> > (\w8 -> map (\n -> testBit w8 n) [0..7]) (45 :: Word8)
01:24:33 <lambdabot>   [True,False,True,True,False,True,False,False]
01:24:44 <pastorn> > reverse $ (\w8 -> map (\n -> testBit w8 n) [0..7]) (45 :: Word8)
01:24:44 <lambdabot>   [False,False,True,False,True,True,False,True]
01:24:57 <pastorn> > reverse $ (\w8 -> map (\n -> testBit w8 n) [0..7]) (65 :: Word8)
01:24:58 <lambdabot>   [False,True,False,False,False,False,False,True]
01:25:13 <Botje> ville: uh, xxx doesn't have any side effects
01:25:27 <Botje> you could use let foo = xxx 2 in do ...
01:25:39 <Botje> but you might as well just put a let inside the do block directly.
01:25:44 <copumpkin> unfoldr . ap ((>>) . guard . not . null) . (pure .) . splitAt
01:25:49 <Botje> what's the higher reason for doing this?
01:25:56 <copumpkin> > (unfoldr . ap ((>>) . guard . not . null) . (pure .) . splitAt) 2 "abcdef"
01:25:57 <lambdabot>   ["ab","cd","ef"]
01:26:02 <copumpkin> > (unfoldr . ap ((>>) . guard . not . null) . (pure .) . splitAt) 2 "abcdefg"
01:26:03 <lambdabot>   ["ab","cd","ef","g"]
01:26:04 <copumpkin> ;)
01:26:10 <ville> Botje: just familiarizing my self with the syntax and what's valid and where.
01:26:29 <djahandarie> I hope you didn't do that entirely out by hand copumpkin, lol
01:26:42 <ville> Botje: I don't particularly understand why the call to xxx on line 23 isn't valid syntax
01:26:51 <Silvah> copumpkin: you're perverted ;)
01:27:19 <copumpkin> it's not that ugly
01:27:24 <Botje> ville: because having two expressions in a function does not make sense
01:27:44 <Botje> .. because expressions don't have side effects
01:27:45 <copumpkin> :)
01:27:56 <ville> Botje: doesn't make sense?
01:28:40 <Botje> ville: if you would allow f = a ; b , it would be exactly the same as f = b, because (in haskell) a cannot have any effect
01:28:50 <Taejo> is it just my email client or do Oleg's emails to haskell-cafe not get threaded properly?
01:29:04 <copumpkin> Taejo: he breaks the threadin
01:29:21 <copumpkin> and doesn't quote who he's replying to sufficiently, so I don't actually know what one of them was in reply to
01:29:23 <djahandarie> Oleg's e-mails are transcendent in more than one way
01:30:50 * Kaidelong looks at the codepad and wonders why "id" is being redefined as "noop"
01:31:14 <c_wraith> :t zipWith id
01:31:14 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
01:32:21 <copumpkin> :t (<*>) `asTypeOf` zipWith id
01:32:22 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
01:32:51 <c_wraith> heh.  same type, very different things
01:33:02 <copumpkin> well, potentially the same thing
01:33:09 <copumpkin> if we'd defined the applicative instance for lists differently
01:33:27 <c_wraith> then it wouldn't have been compatible with the monad instance, though
01:33:35 <copumpkin> yeah, fuck the monad instance
01:33:42 <copumpkin> monads suck anyway
01:33:58 <copumpkin> :)
01:34:49 <ski> ville : `do' (followed by commands) can appear anywhere an expression can (simply because a `do'-block *is* an expression)
01:35:00 <FunctorSalad_> one might also make... a new name :o for the ziplist-apply
01:35:00 <copumpkin> > do 5
01:35:01 <lambdabot>   5
01:35:10 <FunctorSalad_> typeclass mania ;)
01:35:55 <ski> @pl \x -> do x
01:35:55 <lambdabot> do
01:36:02 <FunctorSalad_> or the newtype of course, for when you do need an instance
01:36:25 <FunctorSalad_> ski: :D
01:36:52 <FunctorSalad_> @ty \x -> do x
01:36:53 <lambdabot> forall t. t -> t
01:37:01 <FunctorSalad_> no monadic constraint?
01:37:06 <FunctorSalad_> @ty do
01:37:07 <lambdabot> Empty 'do' construct
01:37:11 <quicksilver> no, that's a ghc bug
01:37:24 <quicksilver> not one they consider very serious, though
01:37:38 <FunctorSalad_> I'd agree
01:38:29 <b0fh_ua> Botje: can't find it in hoogle
01:38:32 <ski> > (`map` [0,1,2,3]) $ \x -> do x^2
01:38:33 <lambdabot>   [0,1,4,9]
01:38:35 <copumpkin> @hackage split
01:38:35 <lambdabot> http://hackage.haskell.org/package/split
01:38:41 <copumpkin> b0fh_ua: ^
01:39:34 <copumpkin> lol, I'm guessing dons changed the haskell subreddit icon
01:40:17 <b0fh_ua> copumpkin: splitPlaces
01:40:18 <b0fh_ua> thanks
01:42:49 <copumpkin> :)
01:42:54 <copumpkin> time for bed, I think
01:51:00 * hackagebot hakyll 2.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.1 (JasperVanDerJeugt)
02:25:11 * hackagebot web-encodings 0.2.6.1 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.2.6.1 (MichaelSnoyman)
02:42:51 <RayNbow> copumpkin: the link you tweeted is unbelievable
02:46:37 <buntfalke> Given I did not specify a type, will GHC generate arbitrary length integer code only, switch at runtime if needed, or decide not to if information available at compiletime ensures it's avoidable?
02:47:49 <ClaudiusMaximus> depends what the 'default' setting for that module is, i don't know what the default default is, or if you end up with an ambiguous type error
02:48:15 <ClaudiusMaximus> :t fromIntegral 5 + genericLength []
02:48:16 <lambdabot> forall b. (Num b) => b
02:48:25 <int-e> the default default is Integer for integral types, and Double for fractional ones
02:49:27 <int-e> @src Integer
02:49:27 <lambdabot> data Integer = S# Int#
02:49:27 <lambdabot>              | J# Int# ByteArray#
02:50:22 <Axman6> > 256 * 4
02:50:23 <lambdabot>   1024
02:50:25 <ClaudiusMaximus> @hoogle default
02:50:25 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
02:50:25 <lambdabot> Text.Regex.Base.RegexLike defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt
02:50:25 <lambdabot> Codec.Compression.GZip DefaultCompression :: CompressionLevel
02:50:44 <ClaudiusMaximus> hm, doesn't hoogle index keywords?
02:51:25 <FunctorSalad_> ClaudiusMaximus: thought it uses a magic haskellwiki page for it
02:51:34 <FunctorSalad_> ("punctuation" aka "keywords" or so)
02:51:40 <FunctorSalad_> @hoogle >>=
02:51:40 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:51:40 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:51:40 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:51:50 <FunctorSalad_> @hoogle --
02:51:51 <lambdabot> No results found
02:52:43 <xenoblitz> Hi guys... can someone help with me a problem I have here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25617#a25617 ... am I trying to do something which is best done in another way?
02:54:53 <xenoblitz> Sorry: forgot some preamble http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25617#a25618
03:02:07 <Axman6> whoot! i just finished my first ever compressor :D
03:03:11 <whald> Axman6: an arithmetic one?
03:03:27 <Axman6> what's a good way to test of two files are the same? (md5 says they are, but another way would be nice)
03:03:33 <Axman6> whald: huffman coding
03:03:57 <whald> Axman6: i'd say diff is a good bet for comparing
03:04:09 <Axman6> using bytes, so it's not particularly efficient (seems to average about 60% file size)
03:04:13 <Axman6> good plan
03:04:28 <Axman6> diff agrees they're the same
03:05:09 <whald> Axman6: cool, now spread the compressor in the warez scene and profit ;-)
03:05:16 <Axman6> heh
03:05:32 <Axman6> it's only taken me about three days of on and off coding too :)
03:06:00 <Axman6> compression is quite efficent... sort of (memory is basically equal to the size of the file, plus a bit)
03:06:15 <Axman6> decompression blows the stack fairly easily, so i need to work on that
03:06:30 <xenoblitz> apologize if I didn't clarify... is it possible to combine GADT with boilerplate notation somehow? Is my problem similar to http://stackoverflow.com/questions/2839713/gadts-and-scrap-your-boilerplate ?
03:07:07 <whald> Axman6: "software is bugs, tied together by garden twine" i read somewhere :-)
03:10:38 <FunctorSalad_> xenoblitz: you could try to write the Data instance yourself; no idea if it'll work
03:11:09 <FunctorSalad_> compile some ordinary ADT which derives Data with -ddump-deriving to get a template
03:12:07 <xenoblitz> FunctorSalad_: thanks I will try that (didn't know about -ddump-deriving)
03:12:45 <FunctorSalad_> xenoblitz: I'm assuming 'boilerplate notation' is syb
03:13:00 <FunctorSalad_> (aka Data.Data and Data.Generics)
03:13:31 <xenoblitz> FunctorSalad_: am referring to boilerplate-removal notation for ADTs as referred to in RWH
03:14:43 <kmc_> hehe
03:14:55 <kmc_> how often is a Java question on SO resolved by "This is possibly a research question"
03:16:08 <xenoblitz> FunctorSalad_: there is probably a better way to do what I am trying to do I guess...
03:16:16 <Axman6> how often does that mean "this has been solved in other languages" >_>
03:17:48 <mreh> how does one cabal install only the documentation? --disable-vanilla and --enable-documentation?
03:18:26 <dcoutts> mreh: hmm, that might work, I've never tried
03:18:40 <mreh> I want to install documentation for the core libraries
03:18:53 <mreh> this is a risky business
03:21:23 <mreh> hmm, GHC tells me "internal error: impossible"
03:21:36 <mreh> cabal install --enable-documentation --disable-library-vanilla base
03:21:46 <kmc_> Axman6, sometimes, no doubt
03:22:02 <kmc_> in this particular case i think other languages solve it by not having GADTs, or not having boilerplate-scrapping, or both
03:22:30 <Axman6> mreh: base is stringly tied to each ghc release, it shoudn't be possible to install with cabal-install (though it may well be)
03:22:31 <mreh> can I part exchange my boilerplate for new?
03:22:54 <mreh> Axman6, I have both a base3 and base4 so I must have done an upgrade then
03:23:03 <Axman6> >_<
03:23:06 <Axman6> you broke something
03:23:21 <mreh> I'm running 6.10.4
03:23:50 <mreh> I think I had to painstakingly reinstall loads of libraries when I upgraded manually
03:24:16 <mreh> I can't even remember why I did it, to take advantage of something in 6.10.4
03:24:57 <xenoblitz> kmc_: so I need to figure out another way is what you are saying :P
03:28:27 <mreh> It would be really nice to have base documentation install and linked into my haddocks
03:28:46 <mreh> but I suppose that means reinstalling every haddock files over the entirety of my package database
03:28:50 <mreh> do we have tools to do this?
03:43:30 <Eelis> does lambdabot support data type definitions?
03:48:08 <Axman6> no
03:50:51 <roconnor> > undefined :: Mu Maybe
03:50:52 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
03:50:53 <lambdabot>    arising from a u...
03:51:42 <Axman6> :t Mu (Just (Mu (Nothing)))
03:51:43 <lambdabot> Not in scope: data constructor `Mu'
03:51:43 <lambdabot> Not in scope: data constructor `Mu'
03:54:04 <SonOfLilit> Hello
03:54:16 <SonOfLilit> Haskell is telling me "main.exe: <<loop>>"
03:54:19 <SonOfLilit> what does this mean?
03:54:29 <ClaudiusMaximus> > let x = x in x
03:54:33 <lambdabot>   mueval-core: Time limit exceeded
03:55:17 <SonOfLilit> would anybody know?
03:55:23 <ClaudiusMaximus> hm, wrong one perhaps, but generally i've got it when defining things that depend on themselves too much (like forgetting a ' on a variable)
03:55:54 <SonOfLilit> so why is it a runtime error?
03:55:55 <ClaudiusMaximus> i think it means the runtime has noticed it's evaluating something that it's already evaluating, so it detects the infinite loop and aborts
03:56:02 <SonOfLilit> (I'll look for such things)
03:57:37 <Kaidelong> there was a good short story about god garbage collecting the universe
03:57:40 <Kaidelong> but I can't find it now
03:58:59 <SonOfLilit> can't haskell at least tell me where it's looping? :/
04:03:30 <zygoloid> Kaidelong: was it a mark-sweep or copying GC?
04:03:54 <Kaidelong> zygoloid: I don't know those terms
04:03:57 <aristid> probably generational mark-and-sweep
04:04:23 <Kaidelong> I was hoping someone would remember the story and be able to link to it because google isn't turning up anything
04:06:17 <ClaudiusMaximus> SonOfLilit: maybe turn on all the warnings when compiling (ie: ghc --make -Wall -fforce-recomp )
04:06:56 <ClaudiusMaximus> SonOfLilit: might offer some hints to a possible cause, like unused or shadowed variables
04:08:13 <aristid> Kaidelong: i did find this: http://www.examiner.com/x-5699-Boxing-Examiner~y2010m5d10-Garbage-Collector-Chris-Aguilar-Protective-eye-on-Manny-Pacquiao-lions-wolves
04:08:43 <Kaidelong> aristid: yeah, google failing you too I see?
04:10:25 <aristid> Kaidelong: they should do less TV and help us find this story.
04:13:33 <FunctorSalad_> kmc_: to be fair, dynamic languages with basic reflection capabilities don't need syb
04:14:08 <FunctorSalad_> kmc_: just saying; I've not changed my mind about types ;)
04:16:32 <FunctorSalad_> ... using "head" is responsible when used on a glob result I suppose ...
04:16:48 <FunctorSalad_> I mean, on each filename
04:16:52 <FunctorSalad_> not on the list of returned filenames
04:16:59 <FunctorSalad_> to look at the first char ;)
04:23:38 <FunctorSalad_> (in other words: there are no empty filenames, right)
04:24:25 <SonOfLilit> I have gone through all warnings and removed them
04:24:42 <SonOfLilit> including one real case where someting was shadowed (but it wasn't in use)
04:24:47 <SonOfLilit> still looping
04:24:54 <Silvah> Hi all ^^
04:29:57 <interferon> what function can i use to split a list into a list of length-n sublists?
04:30:56 <SonOfLilit> my mistake:
04:31:05 <SonOfLilit> instance Solution where show=show
04:33:18 <quicksilver> d'oh :)
04:39:48 <FunctorSalad_> @let chunks n = unfoldr (\a -> case a of { [] -> Nothing; (a0:a1) -> Just (take n a, drop n a) })
04:39:49 <lambdabot>  Defined.
04:40:01 <FunctorSalad_> > chunks 3 [0..20]
04:40:02 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20]]
04:40:17 <FunctorSalad_> oh already left :(
04:40:23 <quicksilver> > transpose $ chunks 3 [0..20]
04:40:24 <lambdabot>   [[0,3,6,9,12,15,18],[1,4,7,10,13,16,19],[2,5,8,11,14,17,20]]
04:40:30 <quicksilver> transpose++
04:40:34 <FunctorSalad_> that exists?
04:40:42 <quicksilver> transpose exists, yes.
04:40:45 <quicksilver> it's very handy.
04:40:46 <abens> Data.List.Split.splitEvery
04:40:47 <FunctorSalad_> (in the stdlib ;))
04:40:52 <quicksilver> Data.List
04:41:17 <companion_cube> :t unfoldr
04:41:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:41:30 * quicksilver favours the definition takeWhile (not . null) . iterate (drop n)
04:41:40 <quicksilver> or , rather
04:41:53 <quicksilver> takeWhile (not . null) . map (take n) . iterate (drop n)
04:43:06 <FunctorSalad_> mine would be more efficient but less readable with breakAt instead of take drop
04:43:25 <FunctorSalad_> err or wait... you don't even have to deconstruct the result
04:43:55 <FunctorSalad_> @let chunkz n = unfoldr (\a -> case a of { [] -> Nothing; (a0:a1) -> Just (breakAt n a) })
04:43:55 <lambdabot>  <local>:9:70: Not in scope: `breakAt'
04:44:06 <FunctorSalad_> @let chunkz n = unfoldr (\a -> case a of { [] -> Nothing; (a0:a1) -> Just (splitAt n a) })
04:44:08 <lambdabot>  Defined.
04:44:23 <quicksilver> > chunkz 2 [1,2,3,4,5]
04:44:24 <FunctorSalad_> > chunkz 3 (show (show (show "")))
04:44:24 <lambdabot>   [[1,2],[3,4],[5]]
04:44:25 <lambdabot>   ["\"\\\"","\\\\\\","\"\\\\","\\\"\\","\"\""]
04:44:27 <FunctorSalad_> ;)
04:44:40 <quicksilver> FunctorSalad_: also, replace (a0:a1) with _
04:44:47 <FunctorSalad_> yeah
04:45:13 <quicksilver> but I still prefer mine.
04:46:43 <FunctorSalad_> hmm depends... mine is totally co and everything :O
04:47:13 <FunctorSalad_> cothings don't see the dark of night often enough...
04:47:25 <quicksilver> well, unfoldr is a bigger hammer, building it up from "simpler" combinators feels nice
04:47:39 <FunctorSalad_> that's true
04:47:44 <quicksilver> also I like the way mine breaks into three parts each of which is identifiably something useful.
04:47:49 <quicksilver> btu it s only an aesthetic point
04:50:32 <FunctorSalad_> @let preZero f x = if x == mzero then mzero else return (f x)
04:50:33 <handonson> Hi. My code dies with "Main.hs: Prelude.tail: empty list" and I can't figure out where this is happening. Can I, say, get the list of functions in my code that depends on tail?
04:50:33 <lambdabot>  Defined.
04:50:37 <FunctorSalad_> @ty preZero
04:50:38 <lambdabot> forall (m :: * -> *) a a1 (m1 :: * -> *). (MonadPlus m, Eq (m a), MonadPlus m1) => (m a -> a1) -> m a -> m1 a1
04:51:00 <FunctorSalad_> that could factor out the 'case' ;) not sure if it's a bogus abstraction
04:51:10 <FunctorSalad_> ("preserve zero")
04:53:00 <SonOfLilit> handonson: you can debug it
04:53:22 <SonOfLilit> call it with :trace from ghci after setting :set -fbreak-on-exception
04:53:23 <FunctorSalad_> @let chunkate n = unfoldr (preZero (splitAt n))
04:53:24 <lambdabot>  Defined.
04:53:40 <FunctorSalad_> > chunkate 2 ['a'..'i']
04:53:41 <lambdabot>   ["ab","cd","ef","gh","i"]
04:53:44 <FunctorSalad_> yay
04:54:01 <SonOfLilit> then :back; :list; repeat; until you find where it gets called
04:55:45 <FunctorSalad_> . o O ( "enchunken" )
04:58:34 <handonson> Wow. Thank you very much, SonOfLilit
05:18:10 <darq> help i dont get it :D *Main> let disc a b c = sqrt((b ** 2) - (4 * a * c))
05:18:10 <darq> *Main> disc 3 1 0
05:18:10 <darq> 1.0
05:18:10 <darq> *Main> sqrt(-11)
05:18:10 <darq> NaN
05:18:39 <darq> why is ghci returning 1.0 ?
05:22:14 <int-e> because that's what sqrt 1 is?
05:22:40 <int-e> 4*3*0 is 0.
05:23:08 <darq> damn:D you are right thx :D
05:27:35 <LeNsTR> (-::
05:29:39 <burp> > sqrt(-11) :: Complex Double
05:29:40 <lambdabot>   (-0.0) :+ 3.3166247903554
05:31:07 * hackagebot wxcore 0.12.1.5 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.12.1.5 (JeremyODonoghue)
05:32:09 * hackagebot wx 0.12.1.5 - wxHaskell  http://hackage.haskell.org/package/wx-0.12.1.5 (JeremyODonoghue)
05:52:14 * hackagebot wxcore 0.12.1.6 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.12.1.6 (JeremyODonoghue)
05:55:15 * hackagebot wx 0.12.1.6 - wxHaskell  http://hackage.haskell.org/package/wx-0.12.1.6 (JeremyODonoghue)
05:59:44 <quicksilver> dcoutts: annoying that there is no changelog on the hackage webpages, isn't it?
06:03:59 <dcoutts> quicksilver: yep, there's a ticket about that :-)
06:04:05 <dcoutts> (as there is about almost everything)
06:04:38 <dcoutts> quicksilver: there's two problems, one there's no way for authors to provide a changelog and two even if there was only a few packages would provide one
06:05:04 <dcoutts> which is why people are interested in doing it automatically
06:06:01 <quicksilver> dcoutts: I don't know if you're right.
06:06:11 <quicksilver> dcoutts: The *vast* majority of package on CPAN have a Changes file
06:06:19 <quicksilver> merely because it's conventional
06:06:46 <quicksilver> maybe there is some tool support which helps encourage it, althouhg I don' tknow what, if so.
06:06:57 <quicksilver> (and, yes, I saw the ticket 299 ;)
06:07:11 <dcoutts> quicksilver: aye, it has to be quick and easy or people will not do it
06:07:24 <dcoutts> but conversely it has to be useful to end users
06:07:31 <dcoutts> or there's also no point
06:07:39 <dcoutts> e.g. darcs changes would not be useful
06:07:47 <dcoutts> though that'd be easy to automate
06:08:50 <dcoutts> quicksilver: allowing changelogs is not so hard, the main thing is making a sensible format
06:09:02 <dcoutts> deciding if the format should be structured or not
06:09:41 <dcoutts> quicksilver: ie we could do with some help
06:11:20 <quicksilver> complaining is so much easier than helping :(
06:11:21 <quicksilver> http://cpansearch.perl.org/src/BINGOS/CPANPLUS-0.9004/ChangeLog
06:11:40 <quicksilver> CPAN doesn't explicitly structure the format, although there is a dominant convention.
06:11:52 <quicksilver> debian has a fairly simple structured changelog format.
06:15:06 <EvanR> >_< how do i 'run' an action of type ReaderT A (Rand B) a
06:15:24 <EvanR> by somehow using both run functions simultaneously
06:16:33 <EvanR> i need a function of type ReaderT r (Rand g) a -> r -> g -> a
06:18:49 <EvanR> all the examples use a transformer over IO, which has no run function of its own
06:21:47 <djahandarie> @pl \x -> (head x, last x)
06:21:48 <lambdabot> liftM2 (,) head last
06:24:06 <EvanR> got it...
06:39:23 <triyo> I need some help pls. I am trying to model a "Tree" of "Tasks", Task being a data type defined as follows... data Task name = Task { name :: String, startDate :: Maybe ClockTime, endDate :: Maybe ClockTime, estHours :: Integer }
06:39:45 <triyo> A "Task" can have a Child "Tasks"
06:40:21 <triyo> Rather, a "Task" can zero or more Child Tasks
06:40:49 <triyo> I am trying to picture this in the Haskell world
06:41:04 <triyo> Do I derive from Tree or...?
06:42:26 <ClaudiusMaximus> you could re-use Data.Tree , or you could add a field children::[Task] and re-write the bits you need
06:42:53 <ClaudiusMaximus> @docs Data.Tree
06:42:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html
06:43:04 <triyo> I am looking at the "you could re-use Data.Tree" option
06:43:16 <triyo> I want to make use of "Traverable", etc.
06:44:03 <ClaudiusMaximus> then something like    type TaskTree = Tree Task   should work?
06:44:48 <triyo> oh I see, use a synonym
06:45:42 <ClaudiusMaximus> could do, or you could just write Tree Task everywhere, depends which you think is clearer
06:45:53 <triyo> ClaudiusMaximus: thanks for your help. I'm getting hang of my learning process slowly but surely.
06:46:20 <ClaudiusMaximus> :)
06:48:19 <triyo> ClaudiusMaximus: is my thing right that going the "Tree Task" route is more desirable here as Tree has implements some handy properties such Traversable, Foldable, Functor, etc?
06:48:59 <triyo> rather than the route to have a childTasks [list]
06:49:19 <triyo> *thing = thinking
06:49:32 <ClaudiusMaximus> yes i think so - not sure what the advantages of the other way is, maybe if you need to maintain invariants one way might be easier than the other?
06:49:55 <ClaudiusMaximus> re-implementing all the classes would be boring
06:50:20 <triyo> exactly my thought.
06:51:41 <byorgey> although ghc 6.12 can auto-derive those classes for you.
06:51:50 <byorgey> but I still agree that reusing Tree is the way to go.
06:52:45 <byorgey> separating things out into small pieces as much as possible, rather than mashing them all together into one mass of spaghetti, is ALWAYS the way to go =)
06:53:06 <ClaudiusMaximus> so that's what i've been doing wrong !
06:53:20 <FunctorSalad_> btw, Traversable implies Foldable and Functor
06:53:22 <triyo> hehe
06:53:29 <ClaudiusMaximus> think i have some code with records with 20+ fields..
06:53:30 <FunctorSalad_> Data.Traversable has the superclass defaults ready for use
06:53:36 <triyo> yes, you get those for free :)
06:53:54 <FunctorSalad_> @ty Data.Foldable.fmapDefault
06:53:55 <lambdabot> Not in scope: `Data.Foldable.fmapDefault'
06:54:07 <FunctorSalad_> or something like that ;) random syllable order problem
06:54:11 <triyo> I noticed that hence I took the Tree route
07:00:09 <icekille> haskell is killing my brain :(
07:00:24 <EvanR-work> good
07:00:31 <EvanR-work> punish that brain
07:00:35 <icekille> why is that good :p
07:01:37 <Botje> icekille: it's like muscles. they have to tear a bit before they can grow
07:01:54 <Botje> brain explosions stretch the skull so that the new brain can be a bit bigger
07:01:59 <Cale> hehe
07:02:41 <Cale> icekille: Really though, feel free to ask any questions you might have here.
07:02:44 <EvanR-work> withConfig :: (Monad m) => (Config -> a) -> (a -> ReaderT Config m b) -> ReaderT Config m b
07:02:54 <EvanR-work> ghc does not like this one
07:03:16 <EvanR-work> cannot construct infinite type
07:03:24 <EvanR-work> a = ReaderT Config m a
07:04:03 <FunctorSalad_> you shouldn't get that error from just entering a type
07:04:22 <FunctorSalad_> only when trying to make a value where there is such a conflict
07:04:27 <EvanR-work> withConfig member action = do config <- ask; x <- member config; action x
07:04:27 <FunctorSalad_> (AFAIK)
07:04:47 <EvanR-work> i havent tried to use it anywhere
07:05:25 <byorgey> EvanR-work: you want  let x = member config  instead of  x <- member config
07:05:31 <EvanR-work> ah
07:05:47 <EvanR-work> it worked!
07:05:52 <EvanR-work> nice error mesages ghc :(
07:06:44 <EvanR-work> withConfig member action = ask >>= action . member
07:06:50 <FunctorSalad_> EvanR-work: welll... apparently it deduced that the do block must be for the monad ReaderT Config m
07:06:58 <FunctorSalad_> then that clashed with the 'member config'
07:07:34 <FunctorSalad_> it didn't give you the outright 'wrong' message because the equation in the error *would* be solvable if you could make "infinite types"
07:07:42 <EvanR-work> i suppose this could be more general, replace Config with Environment, and now i see that this is the local function for Readers
07:07:45 <fasta> I wonder what the point is of announcing a meeting in English on a mailing list and then pointing at a German only website. Either do it both in English, or just don't bother to announce it in English.
07:08:06 <Silvah> Hmmm...
07:08:10 <fasta> FunctorSalad_, I have no idea what the context is, but you can make infinite types.
07:08:20 <fasta> FunctorSalad_, just no implicit ones.
07:08:26 <FunctorSalad_> fasta: up to isomorphism you mean, I guess
07:08:53 <FunctorSalad_> (better said: with the equation being type isomorphism, not equality)
07:09:10 <EvanR-work> there needs to be a 'pedestrian error mode', in my case, the error would have been 'you used <- where you should have used let =
07:09:13 <EvanR-work> '
07:09:19 <FunctorSalad_> a = Maybe a is not allowed, but a ~ Maybe a can be done as "newtype Foo = Maybe Foo"
07:09:29 <fasta> FunctorSalad_, right
07:09:44 <EvanR-work> kind of like in C, you used = where you should have used ==
07:09:48 <FunctorSalad_> fasta: err I forgot the constructor which was kinda my point ;)
07:09:51 <Silvah> >.<
07:09:54 <fasta> FunctorSalad_, equirecursive types is the official name, AFAIK.
07:09:57 <byorgey> EvanR-work: the problem is, that is extremely nonobvious
07:09:59 <FunctorSalad_> newtype Foo = F (Maybe Foo)
07:10:06 <Silvah> Why alex have so poor documentation?!?
07:10:08 <fasta> FunctorSalad_, something you can enable in Ocaml.
07:10:11 <byorgey> EvanR-work: I mean to figure out in general that's why you got an error
07:10:22 <FunctorSalad_> fasta: "equi" would be without the wrapping constructor?
07:10:27 <fasta> FunctorSalad_, right
07:10:28 <EvanR-work> could be a special case heuristic
07:10:29 <Cale> FunctorSalad_: Which is *totally* a bug in the type equality constraints if that still works
07:10:44 <FunctorSalad_> Cale: heh, "~" was metasyntax
07:11:00 <FunctorSalad_> "~" in contexts is equality more or less
07:11:01 <Cale> ah
07:11:12 <Silvah> Uh. I won't bother.
07:11:18 <fasta> Cale, I think someone figured out a bug related to newtypes the last time infinite types were discussed. I think it was Eelis.
07:11:23 <Cale> Yes, but for a while it was treating newtypes as the *same* type as the original
07:11:35 <Cale> (if it still isn't)
07:11:39 <byorgey> it does.
07:11:52 <dpratt71> so thanks to many of you here, I have a very tenuous grasp of existential quantification, at least as it applies to the ST monad...
07:11:54 <Cale> and this allows you to get away with insanely stupid things :)
07:11:54 <byorgey> or rather, newtypes just generate a coercion in the core language
07:12:23 <byorgey> it's not the coercions themselves which are the problem, the problem is that you can do generalized newtype deriving for classes you shouldn't
07:12:26 <EvanR-work> well i avoided even having to define the function. asks member >>= action
07:12:41 <Saizan> fasta: other than that you can make the inliner loop?
07:12:42 <Eelis> fasta: i don't know what an infinite type is, so i doubt it was me :)
07:12:42 <dpratt71> ...so now I want to know: is the ST monad's use of existential quantification "good"?
07:12:43 <philo> allo
07:13:08 <Silvah> @src State fmap
07:13:08 <lambdabot> Source not found. My brain just exploded
07:13:13 <philo> is someone working on the llvm binding for GSOC ?
07:13:22 <dpratt71> I mean, does it represent one of, if not the main reason the language feature exists?
07:13:53 <dpratt71> right now it seems kind of hackish, perhaps because I don't yet understand it well enough
07:13:53 <byorgey> dpratt71: it is one excellent and entirely appropriate use of the language feature, yes
07:13:55 <FunctorSalad_> dpratt71: it can also be used for simple information hiding
07:14:03 <fasta> Eelis, a list is an example of an infinite type, basically when you want to store continuations in data structures you will run into error messages saying "cannot construct the infinite type" kind of error messages.
07:14:05 <Saizan> byorgey: well, another pov is that such coercions are not safe to use
07:14:25 <FunctorSalad_> data AnyMonoid where Foo :: Monoid a => a -> AnyMonoid
07:14:27 <byorgey> Saizan: that is a point of view, which I do not agree with =)
07:14:30 <fasta> Locally being able to say "I know what I am doing" would be useful.
07:14:37 <FunctorSalad_> if you just want some monoid, not important which one ;)
07:15:19 <dpratt71> byorgey: good to know, thanks; FunctorSalad_: is there a good example of that to be found?
07:15:22 <FunctorSalad_> for monoids that's silly, but you can imagine dictionaries or classes which are useful without knowing the hidden type
07:15:26 <byorgey> Saizan: I will actually be working on this and related things this summer at MSR
07:16:16 <dpratt71> FunctorSalad_: I think you may have answered my question before I asked it
07:17:20 <FunctorSalad_> dpratt71: another use is putting different types into a list/map/etc
07:17:34 <FunctorSalad_> (which asks for elements of all the same types)
07:17:35 <Cale> Wait, guys? The ST monad uses existential quantification?
07:17:36 <Silvah> I'm insane...
07:17:44 <Cale> It does not!
07:17:48 <Silvah> newtype LexerState s = LexerState (s -> Addr# -> Int# -> (# s, Addr#, Int# #))
07:17:54 <Silvah> O.o
07:17:54 <Cale> It uses higher rank types.
07:18:08 <Cale> runST's type is a rank-2 type.
07:18:11 <FunctorSalad_> the catch is that you won't be able to recover the specific type, you can just do things that one can do for *any* possible type which might be hidden in the existential
07:18:23 <Cale> But I don't see where existentials come in
07:18:25 <Saizan> byorgey: how do you explain that with "type instance F X = Char; type instance F Y = Int; newtype X = X Y;" now you've enough axioms to derive both "F X ~ Char" and "F X ~ Int" (afaiu)?
07:18:34 <byorgey> Cale: but Haskell doesn't actually have existential types.  and a forall on the left of a -> is like an exists, right?
07:18:40 <FunctorSalad_> so it's like a box which you're only allowed to open if you can deal with anything that may be inside
07:18:43 <FunctorSalad_> or something o_O
07:19:07 <Cale> byorgey: hmm
07:19:21 <Saizan> Cale: forall a. (forall s. ST s a) -> a == exists s. (forall a. ST s a -> a), afaiu
07:19:39 <Cale> Oh, you might actually be right about that.
07:19:46 <Cale> I've never thought of it that way
07:19:56 <Saizan> me neither :)
07:20:06 <quicksilver> existential types are a special case of rank-2 types, yes.
07:21:00 <Cale> quicksilver: But if you turn on the Rank2Types extension, do you get ExistentialTypes as a consequence? ;)
07:21:55 <forrest> I have a very I/O oriented task which I'm trying to do in haskell just to learn the language but I'm way confused.  I have a 38GB binary file I need to split into <4GB pieces.
07:22:00 <byorgey> Saizan: no, I think the system actually does not allow you to derive F X ~ Int
07:22:12 <byorgey> Saizan: although I don't quite remember the exact details at the moment
07:22:27 <byorgey> Saizan: anyway, the system as it currently exists is most certainly broken
07:23:01 <byorgey> Saizan: my point is that the IDEA of implementing things using coercions in the core language is fine.  one just must be very careful to only generate consistent sets of coercions
07:23:12 <Saizan> byorgey: right
07:23:12 <FunctorSalad_> (coq's interactive proof mode gives a vivid pictures of how existentials or sigma-types are like boxes which you can only use by "destroying" them ;))
07:23:27 <byorgey> and one might have to make finer distinctions (e.g. extra kinds) to distinguish things which can and cannot be coerced
07:23:41 <Cale> The bug in the type equality constraints system is really silly
07:23:46 <EvanR-work> this is funny error
07:24:04 <Cale> The paper describing type equality constraints just uses 'newtype' to mean something that it normally doesn't in Haskell.
07:24:10 <EvanR-work> 'could not deduce (RandomGen g) from context ()' 'possible fix: add (RandomGen g) to context'
07:24:16 <FunctorSalad_> if you have an existential as a hypothesis.... you "destruct" it, and now you have a fresh, unknown variable in the hypothesis, and the knowledge that it satisfies the formula in the existential...
07:24:18 <EvanR-work> if it couldnt deduce it, why can it tell me to put it ;)
07:24:30 <byorgey> Cale: how's that?
07:24:58 <Cale> Let me find the paper so I can remind myself :)
07:25:11 <Saizan> EvanR-work: well, at that point _you_ are giving the RandomGen g to it :)
07:25:21 <EvanR-work> Saizan: but it gave it to *me*
07:25:32 <ClaudiusMaximus> :t (getContents, genericSplitAt, withBinaryFile, hPutStr)
07:25:33 <lambdabot> Not in scope: `withBinaryFile'
07:25:33 <lambdabot> Not in scope: `hPutStr'
07:25:33 <byorgey> EvanR-work: it couldn't deduce it in a formal sense; although it deduced that it should be necessary in an informal, meta-level sense
07:25:47 <EvanR-work> ah, sort of like 'you need = here not <-' ;)
07:26:20 <Saizan> "if you want me to typecheck this i need this extra assumption"
07:26:25 <dpratt71> Cale: I stepped away for a minute, but this is where I got the idea that ST takes advantage of existential quantification: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:26:51 <EvanR-work> :t fmap
07:26:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:26:59 <EvanR-work> :t liftM
07:27:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:27:08 <dpratt71> (I came across that trying to understand the 'forall...' business)
07:27:49 <fasta> dpratt71, you can better just read the papers.
07:28:05 <fasta> dpratt71, some wiki parts are written by confused people.
07:28:17 <jmcarthur> wow, i bet my client has been flooding with reconnects a lot today. my bad everybody
07:29:05 <Cale> byorgey: tsk, I can't find it, but I remember seeing a paper where they described the system, and the rule was that newtype in their toy language directly created a type equality between the original type and the new one, which made it a lot more like 'type'
07:29:06 <EvanR-work> i suppose i should use liftM in a monad context and fmap in a functor context
07:29:20 <dpratt71> fasta: not sure what you mean by "the papers", but every time I try to read someone's PhD thesis involving this or that done in Haskell, I come away with a headache :)
07:29:49 <fasta> dpratt71, well, the ones references in the documentation for ST.
07:29:57 <fasta> dpratt71, referenced*
07:30:03 <Cale> dpratt71: That example is inappropriately placed...
07:30:05 <Kaidelong> dpratt71: weren't monads functors?
07:30:19 <Cale> Kaidelong: yes
07:30:19 <Kaidelong> or did I skip over something?
07:30:22 <Kaidelong> ok
07:30:34 <dpratt71> Cale: oh, don't tell me that! I was just starting to think I understood this a bit
07:30:37 <byorgey> Cale: yes, a newtype declaration creates a coercion/equality
07:30:59 <byorgey> Cale: which directly corresponds to the intended runtime semantics of newtypes
07:31:07 <dpratt71> I think "type" should be called "alias"
07:31:08 <FunctorSalad_> but after all traces of typeclasses are gone I assume
07:31:18 <Cale> byorgey: Which is totally inappropriate, as the whole point of newtype is to introduce a new type which is *not* equal to the original type.
07:31:21 <FunctorSalad_> dpratt71: or "syn" to keep with existing terminology
07:31:25 <FunctorSalad_> ("type synonym")
07:31:26 <Cale> (but only has isomorphic implementation)
07:31:29 <handonson> dpratt71, agreed
07:31:32 <Kaidelong> fmap and liftM seem redundant
07:31:39 <FunctorSalad_> Kaidelong: legacy
07:31:39 <dpratt71> (I've decided general ignorance shouldn't prevent me from making suggestions for Haskell)
07:31:51 <Saizan> byorgey: i think the problem is that coercions mess with the static semantics too
07:31:58 <byorgey> Cale: it's different than a type synonym.  Type synonyms are just expanded out by the compiler.  Actual coercion terms must be placed in appropriate places in the core code
07:32:03 <FunctorSalad_> (hmm or is it? anyway, it is because Monad's needn't be declared Functors in haskell)
07:32:13 <FunctorSalad_> even though every monad can be declared so
07:32:29 <FunctorSalad_> but I thought Monad and Functor were both in from the beginning
07:32:32 <byorgey> Cale: so actually, "equality" is the wrong word.  The types are still not equal, you must explicitly coerce between them.
07:32:54 <Kaidelong> FunctorSalad_: no way to make an instance declaration saying that for any monad, liftM is fmap?
07:33:05 <Cale> FunctorSalad_: It's just stupid. Someone on the Haskell committee thought it would be tedious to force people to write Functor instances when they just want a Monad instance.
07:33:14 <FunctorSalad_> byorgey: hmm, the core language must do that, but you don't, usually
07:33:19 <Cale> (and meanwhile we have the ridiculous situation with Num)
07:33:27 <FunctorSalad_> byorgey: having it in context is enough
07:33:43 <FunctorSalad_> Cale: ah
07:33:56 <byorgey> FunctorSalad_: yes, sorry, that's what I meant.  In the core language there must be explicit coercions.
07:33:59 <FunctorSalad_> Kaidelong: nope, proposal is called "superclass defaults" or so
07:34:07 <byorgey> In the source language you have to apply and unwrap the newtype constructor.
07:34:46 <byorgey> Basically, the problem is that using generalized newtype deriving on type classes that don't use their argument parametrically allows the coercions to "leak"
07:34:53 <Kaidelong> FunctorSalad_: it seems like a lot of "generic" programming around classes in haskell is not allowed
07:35:00 <FunctorSalad_> Kaidelong: apparently it's tricky how to do it in full generality in a tidy way
07:35:01 <Kaidelong> in this case I don't really see why it should be the case
07:35:02 <byorgey> you know, I should write a blog post explaining this.
07:35:13 <Cale> The problem isn't with generalised newtype deriving, it's with the paper's interpretation of 'newtype'
07:35:23 <byorgey> Cale: I disagree.
07:35:57 <Cale> You shouldn't be able to derive  A ~ B  from  newtype A = C B
07:36:28 <Cale> and yet that's what their system does
07:36:39 <FunctorSalad_> Kaidelong: don't expect too much in the way of theorem proving from the instance searcher ;) for example, it can't backtrack
07:36:46 <Cale> (at least, if I'm remembering it correctly, it was a while ago that I read this)
07:36:53 <Saizan> byorgey: is GHC constructing the coercion using the provided axioms when making the instance there? because if so then the axioms let you do something unsound :)
07:36:58 <byorgey> Cale: note that what will probably happen to fix this is that there will be two different types of ~, one for syntactic "codes" and one for semantic "types"
07:36:58 <FunctorSalad_> Kaidelong: if the right hand side of the => unifies with what you want, it commits to that instance
07:37:14 <byorgey> Cale: and a newtype declaration will generate the former
07:37:22 <byorgey> which can only be used in certain ways
07:37:45 <Saizan> the former?
07:37:56 <Cale> I guess I just don't understand why we want the former at all.
07:37:57 <byorgey> Cale: so I agree with you that  newtype A = C B  should not give you  A ~ B, if what you mean by that is an unrestricted ability to replace A by B or vice versa anywhere you like.
07:38:15 <Kaidelong> FunctorSalad_: So when it sees the instance definition it immediately tries to find a class instance to apply it to and the compiler complains when it's ambiguous or can't manage it?
07:38:18 <Cale> That's essentially what  A ~ B  means.
07:38:20 <FunctorSalad_> Kaidelong: so you can't have, say, "X1 a => Y a" and "X2 a => Y a" to say that either will do
07:38:38 <FunctorSalad_> Kaidelong: (that's not directly related to your question; just saying it isn't a full-strength theorem prover)
07:38:43 <Cale> If your function gets an  A ~ B  constraint, it's allowed to treat those types as *equal*.
07:38:46 <byorgey> Cale: well, it already doesn't really mean that, because the programmer doesn't have direct control over where the A~B coercion gets applied.
07:39:05 <byorgey> Cale: So as long as the compiler only applied it in places where it is safe to do so, in theory that would be OK.
07:39:12 <byorgey> but as we all know, it doesn't. ;)
07:39:23 <Saizan> ok, so i think we agree :)
07:39:25 <Cale> I suppose if you want to think of this as a theory of implicit conversions...
07:39:39 <byorgey> that's a good way to think of it, I think
07:39:40 <Cale> But I thought we were talking about type equality constraints
07:39:54 <FunctorSalad_> (unless you're Oleg... think he does such things with cleverly indirected overlapping instances)
07:40:04 <byorgey> Cale: no, they aren't the same thing
07:40:05 <Cale> Not some kind of type equivalence :)
07:40:12 <byorgey> I guess using ~ is unfortunate notation.
07:40:13 <Kaidelong> FunctorSalad_: you could have a mechanism to disambiguate those cases, I take it that the type checker just has none instances?
07:40:13 <Cale> What aren't the same thing?
07:40:19 <Kaidelong> err
07:40:22 <Cale> I'm talking about ~ in GHC.
07:40:24 <Kaidelong> none of that implemented
07:40:40 <byorgey> type equality constraints, and these coercion thingys.
07:40:46 <FunctorSalad_> Kaidelong: the example I gave will immediately complain "duplicate instances"
07:41:04 <Cale> Maybe you were talking about something else at the same time?
07:41:09 <FunctorSalad_> Kaidelong: for things that are only somewhat overlapping, you can use overlappinginstances though
07:41:10 <byorgey> It is not the case that newtype A = C B gives you the type equality constraint A ~ B.
07:41:23 <byorgey> it does give you a coercion between A and B in the core language.
07:41:31 <byorgey> which I was also writing A ~ B but should not have been =)
07:41:39 <Cale> byorgey: It at least was in early implementations the case that you could blast through newtypes like that.
07:41:56 <FunctorSalad_> Kaidelong: (the ghc user's guide has some examples in the section on these overlapping instances)
07:42:02 <Cale> (not just in Core, but at the level of GHC Haskell)
07:42:06 <byorgey> if so, then they were broken.
07:42:11 <Saizan> you could say it like this: the type system of System Fc(X) doesn't prevent you from using the axioms generated by newtypes in an unsound way
07:42:18 <byorgey> I don't actually know much about early implementations.
07:42:28 <FunctorSalad_> AFAIK coercions were only included for GADTs
07:42:32 <Cale> I think it may even still be the case, but I'd have to check.
07:42:34 <FunctorSalad_> so newtype must have been different before
07:43:43 <Cale> It's this property that causes generalised newtype deriving to go wrong in conjunction with it -- or perhaps it's just that the compiler has "forgotten" that the newtype is really a newtype by that point in its processing.
07:44:06 <Cale> (and instead is only a Core-newtype which is apparently a weaker condition)
07:44:56 <FunctorSalad_> you could test it empirically ;)
07:45:35 <Saizan> separating "source level types" from "types that denote a runtime representation" in Core seems like it should work
07:45:39 <FunctorSalad_> (with ghc-core)
07:46:23 <Nola> jesus fucking christ haskell 2010
07:46:32 <FunctorSalad_> heh not much to see there
07:46:35 <Kaidelong> I'm struggling to understand why Functor isn't in the context of Monad
07:46:40 <Cale> But yeah, the confusion, at least as far as I was able to work it out, was that 'newtype' in the system they described in the paper doesn't mean what we expect it to in Haskell
07:46:55 <Kaidelong> it seems to break the whole purpose of typeclasses to make a redundant liftM
07:46:56 <Cale> Kaidelong: It's not for any good reason.
07:47:00 <FunctorSalad_> (mostly wrote down what has already happened in the meantime AFAIK... and only the most uncontroversial of it)
07:47:02 <Nola> did they finally allow you to make records with the same names?
07:47:05 <Cale> Kaidelong: Don't try to rationalise it.
07:47:12 <Cale> Nola: Haskell 2010 is boring
07:47:18 <Nola> oh
07:47:24 <Saizan> Nola: no
07:47:36 <FunctorSalad_> but it's still good that the standardization process has picked up again
07:47:38 <Cale> Nola: It's a conservative attempt to standardise some features which already exist.
07:47:45 <FunctorSalad_> can't blame them for starting carefully
07:47:57 <Nola> well phooey on those damn conservatives
07:48:11 <Cale> And, if my way of thinking wins out, I think that's all the standardisation process ever should be.
07:48:20 <Cale> Implement first, ask questions later.
07:48:43 <Nola> Which features. ghc extensions?
07:48:55 <Nola> The meat-meets-the-road
07:49:01 <EvanR-work> :t liftA
07:49:01 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
07:49:02 <Cale> (well, this is not to say we shouldn't reason about the features we implement beforehand, just that it'd be premature to put them into a standards document)
07:49:14 <Cale> Nola: yeah
07:49:35 <Nola> So at the time that it got introduced as an experimental extension was the time to be radical
07:49:40 <Nola> And then find out if it worked
07:50:00 <Cale> I also think we shouldn't be so careful to follow the standard's Prelude. The Haskell98 package is still available for those who want it, and we could do the same for 2010 if it mattered.
07:50:07 <EvanR-work> :liftT
07:50:09 <EvanR-work> :t liftT
07:50:10 <lambdabot> Not in scope: `liftT'
07:50:19 <Cale> Nola: yeah
07:50:21 <Veinor> what's the recommended light, quick XML parser?
07:50:22 <FunctorSalad_> speaking of extensions, I noticed this in the full lang list... "ConstrainedClassMethods"
07:50:27 <FunctorSalad_> thought that wasn't done yet
07:50:30 <Veinor> I don't need the full force of haxml or hxt
07:50:48 <Silvah> What does "A" mean in "Str: DmdType C(C(U(SAA)))LU(L)" (strictness informations in Core)?
07:50:48 <Nola> Cale you're not saying it but you sound pretty pissed off
07:50:55 <Nola> what are you mad about
07:51:11 <FunctorSalad_> ( ghc --supported-languages )
07:51:32 <Cale> Nola: I am a bit pissed off about how the *other* way of doing things (standardise first) is getting in the way of making changes that we'd like to see.
07:51:44 <FunctorSalad_> Cale: it's just quarter-self-ironic righteous rage, not pissed-offness ;)
07:51:50 <Nola> standardise first -- then find out if it works?
07:52:00 <FunctorSalad_> (when we get emotional about abstractions)
07:52:01 <Nola> How is that getting in the way, if this incremental release was the opposite?
07:52:37 <Cale> Nola: Or in this case, don't ever change anything once it's standardised because we don't feel free to change our implementations from what the standards say.
07:52:52 <mxc> anyone here use the thrift bindings?
07:53:23 <dpratt71> Cale: it is an interesting philosophy for a language intended as a grand experiment
07:53:26 <FunctorSalad_> Cale: but the old Prelude would be around for a long time, and in that time you have even more cruft ;)
07:53:39 <Nola> depends on whats getting broken. Sometimes you have to amputate a leg or else the body will gangrene
07:53:39 <FunctorSalad_> (now you have to explain newbies how there are two preludes)
07:53:53 <Nola> And then after a while nobody remembers the change
07:53:55 <Nola> Well 10 years later
07:53:58 <Nola> But it made everything better
07:54:02 <Nola> Breaking changees
07:54:05 <Cale> FunctorSalad_: Yeah, but there are already base package versions.
07:54:38 <gwern> breaking changes win in the long run; unfortunately, we're all dead in the long run
07:54:41 <gwern> "If the individual lived 5 hundred or one thousand years, this clash (between his interests and those of society) might not exist or at least might be considerably reduced.\u000aHe then might live and harvest with joy what he sowed in sorrow; the suffering of one historical period which will bear fruit in the next one could bear fruit for him too."
07:54:48 <Nola> I'm not saying this particular release had important breaking changes
07:54:59 <Nola> but as a coder i get into situations where I *loathe* something
07:55:04 <FunctorSalad_> Cale: yes and I must have gotten that dumb "Data.Data.Data doesn't exist" error 50 times or so with not-yet-adapted packages ;)
07:55:08 <Nola> and I want to break it and feel all worried about pissing somebody else off
07:55:12 <Nola> and build up this complex about the thing
07:55:30 <Nola> Oh god I just want to break this stupid thing and it would fix stuff, do I have to explain this whole situation, please no this is a nightmare
07:55:38 <Nola> They're gonna get pitchforks
07:55:41 <FunctorSalad_> (or something similar... just remember the error message was very misleading)
07:55:42 <Veinor> hm, okay. design question. I want to call out to an external API that requires me to regenerate an API key every four hours
07:55:44 <Nola> It eats at a developer's heart
07:55:45 <gwern> 'Theodotus: What is burning is the memory of mankind. Caesar: A shameful memory. Let it burn.'
07:55:46 <EvanR-work> @hoogle Reader r a -> ReaderT r m a
07:55:46 <lambdabot> No results found
07:55:50 <Nola> worry about who will be mad
07:56:15 <Veinor> so, each time I generate the key, that key is valid for 4 hours, then I have to make a new one. what's the best way to deal with this?
07:56:45 <Cale> Nola: I say we should avoid success at all costs :)
07:57:00 <dpratt71> Cale: it's too late for that
07:57:00 <Veinor> (in order to generate the key, I need to know the user's username, password, and the token which I have to get by calling out to the API)
07:57:03 <Cale> Well, conventional success.
07:57:11 <Cale> It's not at all too late for that.
07:57:44 <gwern> Veinor: hm. sounds hard. how about using a datatype accessed only with an accessor function, and that accessor function under the hood checks the time and gets a new one if need be?
07:57:54 <dpratt71> Cale: I don't know; I hear things about iPhone apps being written in Haskell...
07:58:15 <Cale> There are some companies which use Haskell, but those companies have lots of smart people in them who I'm sure wouldn't have any trouble updating their codebases in a few places to build against a revised prelude.
07:58:44 <Cale> dpratt71: Yeah, I wonder if that's still happening. I heard something about Apple banning it.
07:59:17 <FunctorSalad_> Cale: yeah, nothing more exciting than fixing a few dependencies while you're trying to launch the missiles
07:59:18 <FunctorSalad_> ;-)
07:59:23 <dpratt71> Cale: yes, I heard that, too; it seems many are waiting to find out if they're actually going to enforce it
07:59:38 <Cale> dpratt71: In any case, it's not like there's *way* more Haskell code out there than we can afford to break.
07:59:39 <Veinor> gwern: so I have a WrappedKey type and a getKey that takes a WrappedKey and returns the actual key to use
08:00:09 <Nola> Cale: What stops them from building using a previous ghc and prelude?
08:00:11 <Nola> what's wrong with that.
08:00:33 <Veinor> Nola: security vulnerabilities?
08:00:40 <Veinor> *coughRTScough*
08:01:01 <FunctorSalad_> Nola: was that @ me? I ignored that for the sake of sillyness
08:01:02 <gwern> Veinor: something like that. data WrappedKey = WrappedKey { unwrap :: Key} where unwrap = unsafePerformIO (if getTime - lastTime > 4 then getNewKey else oldkey) - hell I don't know how you would write it but you see what I mean
08:01:03 <Cale> Nola: Nothing, except that if you want to keep making changes to your software, you eventually will want to use newer libraries with it, which will require you to update the code to work against the new base.
08:01:06 <Nola> Well, hard for me to empathize with that cause I don't see Haskell as a language you make big corporate buttfucks with and have maintainence programmers on the job
08:01:10 <dpratt71> Cale: I would tend to believe you, but I wonder why things have not changed where most people seem to agree that the current situation is not optimal
08:01:16 <Nola> Its more for like interesting apps
08:01:20 <FunctorSalad_> (ignored the fact that they don't have to upgrade, that is)
08:01:39 <dpratt71> if it's not for fear of breaking existing code, what is the reason?
08:01:41 <Nola> And people can patch interesting apps
08:01:41 <gwern> dpratt71: it's the old 20/80 rule - 80% of people disagree on what 20% sucks and how to fix it
08:01:50 <Veinor> gwern: I think I'd want to keep state around, actually
08:01:51 <Cale> I actually wonder if we couldn't get things fixed by posting patches to the Prelude to the haskell-libraries mailing list ;)
08:02:00 <Cale> It couldn't be that easy, could it?
08:02:05 <gwern> Cale: no. it couldn't.
08:02:21 <Cale> gwern: Have you tried? :)
08:02:25 <gwern> Veinor: so pack some more data into the record
08:02:30 <FunctorSalad_> you'll split the kingdom in two over the how-should-mappend-be-called problem
08:02:39 <Veinor> so that every time I call unwrap on it if I need to keep a new key I can store that new key back
08:02:39 <gwern> Cale: I don't need to jump off a bridge myself to know it's a bad idea
08:02:46 <FunctorSalad_> ;)
08:02:49 <Cale> FunctorSalad_: I can live with that
08:02:59 <gwern> Veinor: how slow is getting a new key? maybe you could just get a new key all the time
08:03:06 <EvanR-work> liftT :: Monad m => Reader r a -> ReaderT r m a; liftT action = liftM (runReader action) ask
08:03:09 <EvanR-work> what did i just invent
08:03:20 <gwern> a monster!
08:03:26 <gwern> burnitwithfire
08:03:31 <Cale> There are already way too many libraries on Hackage for me. We should slow down and make changes to the language instead :)
08:03:40 <dpratt71> I get the impression, for example, that many people feel that the Monad, Functor, Applicative stuff is pointed the wrong way around, so to speak. Is there not general consensus on that situation?
08:03:48 <sm> yay, a new hakyll !
08:03:51 <sm> morning all
08:04:00 <Veinor> gwern: it's not the slowness of getting a new key so much as them saying that it's a good idea to cache keys
08:04:01 <Cale> dpratt71: It's just that there should be class constraints where there are not.
08:04:12 <Cale> dpratt71: That's actually a really minor issue in my mind.
08:04:18 <gwern> Veinor: caching is only sensible if the action is slow. obviously
08:04:41 <Veinor> well, there's also their backend to worry about
08:04:47 <Cale> dpratt71: A bigger one is the fact that Num is a subclass of Eq and Show (which is just stupid), and that it has abs and signum in it (which should be in their own class)
08:04:50 <gwern> so are they saying 'it's slow and so you should cache it' or 'durr we are cargo cult programmers and needed to cache once and now we're like the cat who touched a hot stove'
08:05:02 <Saizan> Cale: well, if you can gather enough supporters the haskell-libraries route would work :) you should start lobbying
08:05:16 <Veinor> gwern: they're saying 'You should cache the token so that you don't have to get a token for every API call.'
08:05:20 <Cale> dpratt71: There's more that you could do to make nice fancy elaborate changes to the numeric hierarchy, but at minimum, those are really important.
08:05:31 <FunctorSalad_> Cale: want function space Nums? that's a bad idea even if there was no Show constraint
08:05:34 <Cale> another thing which rather annoys me is the presence of fail in the Monad class.
08:05:36 <FunctorSalad_> (IMHO)
08:05:36 <gwern> Saizan: the problem with libraries is that if anyone comments at all, they're opposing you :)
08:05:40 <Cale> FunctorSalad_: Why?
08:05:54 <Saizan> gwern: not if you organize first :P
08:05:58 <FunctorSalad_> Cale: typos that typecheck...
08:06:15 <Nola> all I want is better records
08:06:16 <FunctorSalad_> the anonymous reader is the practical-joke stock here already ;)
08:06:38 <Cale> Nola: Well, a decent system for polymorphic extensible records would be nice.
08:06:39 <FunctorSalad_> now "2 3" typechecks and results in "2" ;)
08:06:50 <FunctorSalad_> assuming fromInteger = const
08:06:55 <Cale> FunctorSalad_: right.
08:07:08 <Cale> FunctorSalad_: Well, perhaps we can put the instance in a separate library.
08:07:21 <gwern> > 2 3
08:07:22 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:07:22 <lambdabot>    `GHC.Num.Num t' arising f...
08:07:24 <FunctorSalad_> Cale: or newtyped
08:07:26 <Cale> But the possibility of that instance shouldn't be excluded.
08:07:30 <Cale> Noooo
08:07:40 <Cale> newtyping that one would be silly
08:07:55 <Cale> Well...
08:08:00 <Veinor> anyway, related question: what's a good, light XML parser?
08:08:11 <gwern> tagsoup
08:08:15 <gwern> xml-light
08:08:41 <Nola> is there a higher-level win32 library than win32
08:08:55 <FunctorSalad_> not a colight one perchance? ;)
08:09:05 <FunctorSalad_> HXT...
08:09:13 <gwern> I wouldn't call hxt light
08:09:19 <Cale> Nola: Most of the effort in constructing bindings to GUI libraries have been on cross-platform things.
08:09:20 <FunctorSalad_> colight
08:09:20 <gwern> good maybe but not light
08:09:29 <Cale> Nola: You can use WxHaskell or Gtk2Hs on windows.
08:10:19 <Nola> the google logo today is a trip
08:10:40 <gwern> whoa. stark
08:10:48 <Nola> its interactive
08:10:51 <jmcarthur> yeah it's nice
08:12:17 <gwern> darn. nothing happens if you eat all teh ghosts
08:12:27 <gwern> is that pure JS? the performance certianly indicates so :)
08:15:10 <Nola> Well, Gtk on windows isn't something you'd really use
08:15:25 <Nola> It's high latency
08:15:36 <Nola> slow, flickery, horrid
08:16:06 <EvanR-work> sort of like most windows guis
08:18:40 <Veinor> remind me, when doing a Build-Depends line, I should do (say) 0.8.* if I'm writing it for tagsoup 0.8, right?
08:23:41 * jmcarthur didn't have a performance issue with google pacman
08:25:14 <sm> awesome! (google)
08:26:19 <jmcarthur> Veinor: looks right to me, if you don't mind requiring Cabal >= 0.6 (i think that's right) to build it
08:27:07 <jmcarthur> Veinor: the x.x.* syntax requires at least that version of cabal, i mean
08:33:43 <thoughtpolice> cabal 1.6 supports the 'pkg == 4.0.*' syntax
08:34:22 <Veinor> hm
08:34:34 <Veinor> is there a nicer way to say return $ f <$> x?
08:34:44 <Veinor> (where x is a list)
08:35:21 <jmcarthur> i can't think of anything
08:35:28 <jmcarthur> maybe in context there could be a better way
08:35:35 <EvanR-work> in a statement of the form x <- asks x, i am effectively shadowing the origin x right
08:35:38 <jmcarthur> but by itself that seems fairly minimal
08:35:38 <EvanR-work> original
08:35:42 <Veinor> yeah, just wondering
08:35:51 <jmcarthur> EvanR-work: unless you are using recursive do notation
08:35:57 <EvanR-work> >_< what
08:36:22 <k23z__> hi, I want to declare a function that will take a char and return a binary function
08:36:22 <jmcarthur> EvanR-work: with recursive do notation both occurrences of x refer to the same thing :)
08:36:23 <EvanR-work> how do you use recursive do notation
08:36:24 <k23z__> I tried this retfun :: Char -> ( (Num a) => a -> a -> a )
08:36:28 <k23z__> but it didn't work
08:36:28 <jmcarthur> EvanR-work: google
08:36:30 <k23z__> how can I do this ?
08:36:42 <EvanR-work> i thouth x <- e was e >>= (\x ->
08:36:59 <jmcarthur> EvanR-work: just google it
08:37:09 <jmcarthur> recursive do notation desugars a bit differently
08:37:23 <aristid> :t return $ f <$> x
08:37:24 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
08:37:24 <lambdabot>     In the second argument of `(<$>)', namely `x'
08:37:24 <lambdabot>     In the second argument of `($)', namely `f <$> x'
08:37:37 <aristid> :t \f x -> return $ f <$> x
08:37:38 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
08:37:53 <aristid> :t \f x -> return . f <$> x
08:37:54 <lambdabot> forall a (m :: * -> *) a1 (f :: * -> *). (Monad m, Functor f) => (a1 -> a) -> f a1 -> f (m a)
08:38:50 <k23z__> aristid, is that for me ?
08:39:14 <EvanR-work> so its an extension with special syntax, so i think im ok. but maybe i should avoid shadowing anyway
08:39:18 <jmcarthur> EvanR-work: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#mdo-notation
08:39:28 <jmcarthur> EvanR-work: yeah i generally try to avoid shadowing
08:40:13 <aristid> k23z__: no it's related to a question from Veinor
08:40:24 <k23z__> ok
08:40:42 <k23z__> so if I want a function that would take a Char and return a binary function how do I do that ?
08:40:59 <jmcarthur> Char -> a -> a -> a
08:41:00 <aristid> f x y z = undefined
08:41:05 <aristid> easy as pie.
08:41:36 <jmcarthur> f = undefined
08:41:36 <aristid> k23z__: but should the function also do something sensible? :D
08:42:23 <k23z__> jmcarthur, doesn't that mean a function that takes a Char , 2 as as parameter and returns an a ?
08:42:30 <aristid> :t const undefined
08:42:32 <lambdabot> forall a b. b -> a
08:42:35 <k23z__> jmcarthur, why is Haskell able to disambiguate that ?
08:42:37 <jmcarthur> k23z__: -> is right associative
08:42:41 <aristid> :t const . const $ undefined
08:42:42 <lambdabot> forall b a b1. b -> b1 -> a
08:42:46 <aristid> :t const . const undefined
08:42:48 <lambdabot> forall a b b1. b1 -> b -> a
08:42:53 <jmcarthur> k23z__: Char -> a -> a -> a  == Char -> (a -> (a -> a))
08:43:08 <k23z__> jmcarthur, and what does a-> (a->a) mean ?
08:43:28 <jmcarthur> k23z__: it means take an a and return a function that takes an a and returns an a
08:43:30 <aristid> a -> (a -> a) is a function that returns a unary function
08:43:38 <aristid> which is the same as a binary function
08:43:52 <k23z__> jmcarthur, I need     ( a->a)->a
08:44:00 <jmcarthur> k23z__: that's not a binary functions
08:44:02 <jmcarthur> *function
08:44:03 <k23z__> jmcarthur, does that mean take 2 a and return an a ?
08:44:06 <jmcarthur> no
08:44:10 <k23z__> jmcarthur, how do I say a binary funtion ?
08:44:13 <k23z__> *function
08:44:16 <jmcarthur> k23z__: that means take a function from a to a and return an a
08:44:22 <aristid> k23z__: (a->a)->a is a function that takes a unary function and returns a value
08:44:31 <jmcarthur> k23z__: a -> a -> a is a binary function, and it's the same as a -> (a -> a)
08:44:32 <EvanR-work> k23z__ whats :: Char -> (a -> b)
08:44:37 <EvanR-work> i.e. Char -> a -> b
08:44:43 <EvanR-work> wants8
08:45:06 <k23z__> ok, let me explain, I want to give a Char and get a binary function
08:45:09 <jmcarthur> right
08:45:12 <jmcarthur> Char -> a -> a -> a
08:45:20 <jmcarthur> it's the same as:  Char -> (a -> a -> a)
08:45:30 <jmcarthur> and the same as Char -> (a -> (a -> a))
08:45:30 <EvanR-work> oh
08:45:31 <k23z__> jmcarthur, can I find the latter more clear
08:45:39 <jmcarthur> and the same as Char -> a -> (a -> a)
08:45:39 <dpratt71> (+) is an example of a binary function...
08:45:40 <k23z__>  Char -> (a -> a -> a)   this one
08:45:46 <jmcarthur> k23z__: it's all the same
08:45:46 <dpratt71> @t (+)
08:45:46 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:45:50 <jmcarthur> literally
08:46:02 <k23z__> jmcarthur, and how do I write the type declaration for a function like this ?
08:46:03 <dpratt71> :t (+)
08:46:04 <lambdabot> forall a. (Num a) => a -> a -> a
08:46:13 <jmcarthur> k23z__: foo :: Char -> a -> a -> a
08:46:36 <aristid> seriously who invented the stupid "snoc" function name?
08:46:57 <k23z__> jmcarthur, and if I want a to be a Num ?
08:47:06 <jmcarthur> k23z__: you add a Num constraint to it
08:47:14 <dpratt71> k23z__: (Num a) => Char -> a -> a -> a
08:47:29 <k23z__> dpratt71, ok thanks
08:47:33 <k23z__> and what is the =>
08:47:45 <dpratt71> k23z__: a constraint
08:47:47 <k23z__> does it mean mean that everything before => are type constraints ?
08:47:50 <jmcarthur> right
08:47:53 <k23z__> dpratt71, what if I want another constraint ?
08:48:03 <jmcarthur> (Foo a, Bar b) => a -> b
08:48:16 <dpratt71> k23z__: what jmcarthur said :)
08:48:25 <aristid> jmcarthur: why are the parens needed there?
08:48:32 <k23z__> jmcarthur aristid dpratt71  great
08:48:33 <k23z__> thanks
08:48:45 <jmcarthur> :t undefined :: Foo a, Bar b => a -> b
08:48:46 <lambdabot> parse error on input `,'
08:48:53 <jmcarthur> aristid: ^^ that's why :)
08:49:15 <jmcarthur> aristid: they are not needed for dpratt71's example though
08:49:19 <aristid> jmcarthur: i know THAT it's not legal without
08:49:25 <k23z__> can I manufacture Haskell code at runtime in a string and then eval() it like I do in Perl ?
08:49:29 <aristid> but i can't make sense of that restriction
08:49:34 <jmcarthur> aristid: oh i dunno
08:49:45 <aristid> heh
08:49:49 <jmcarthur> k23z__: with some work i'm sure you can, but we generally discourage that
08:50:17 <ezyang> k23z__: Yes, but there's usually another way.
08:50:19 <jkingkong> I was wondering if somebody could help me understand some notation in the paper on Implicit Configurations by Oleg at http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf (fourth page, #36)
08:50:22 <aristid> k23z__: even in perl you are asked not do to that. even in perl!
08:50:27 <ezyang> (unless you're Sussman or something)
08:50:40 <jmcarthur> i don't think sussman would encourage it either
08:51:09 <k23z__> :) ok I won't do that then
08:51:09 <jkingkong> on the fourth page of that paper, at the top where he defines the datum AnyModulus, he uses a ForAll symbol and a period. I'm not sure how I would actually implement this in an actual haskell file
08:51:22 <ezyang> jkingkong: ExistentialQuantification
08:51:38 <jmcarthur> jkingkong: what ezyang said, and say  forall a .
08:51:42 <jkingkong> ezyang, ok so that's the keyword i'm missing
08:51:58 <jmcarthur> jkingkong: ezyang gave you the language extension to enable. i gave you the syntax
08:52:29 <jkingkong> ezyang, jmcarthur: thanks I was not aware of this feature in Haskell
08:52:35 <jmcarthur> :)
08:52:42 <jmcarthur> ghc has some awesome extensions
08:52:46 <ezyang> technically GHC :-)
08:52:56 <jmcarthur> i would be less interested in haskell without many of these extensions
08:53:18 <ezyang> it's true.
08:53:24 <jkingkong> haha how exactly is the distinction made, i'm a ghc/haskell noob
08:53:39 <aristid> jkingkong: haskell is what's defined in the standard from 1998
08:53:45 <jmcarthur> jkingkong: haskell is the language specification, ghc is the compiler. ghc also happens to implement some things not in the spec
08:54:34 <k23z__> how do I define a binary function that doesn't do absolutely nothing ?
08:54:42 <jmcarthur> jkingkong: technically, if you enable an extension you are no longer using haskell, but we don't really get so pedantic normally ;)
08:54:45 <k23z__> I mean exactly nothing
08:54:53 <EvanR-work> returns nothing?
08:55:02 <EvanR-work> :: a -> a -> ()
08:55:07 <jmcarthur> k23z__: functions in haskell don't do anything
08:55:07 <jkingkong> jmcarthur: interesting
08:55:10 <aristid> k23z__: first say what it should do, THEN think how you implement it
08:55:29 <jmcarthur> k23z__: but by saying that i'm really just complicating things, sorry
08:55:36 <k23z__> I want the C++ equivalent of function<int (int x, int y)>();
08:55:41 <k23z__> which is absolutely nothing
08:55:43 <jmcarthur> k23z__: but i don't know how to answer your questions properly
08:55:48 <k23z__> it's also UB which is bad.. but uh..
08:55:49 <aristid> k23z__: std::function?
08:55:57 <EvanR-work> k23z__: make it return type ()
08:56:00 <EvanR-work> the only value of which is ()
08:56:04 <k23z__> jmcarthur, you do
08:56:32 <jmcarthur> k23z__: if you say in the type signature that the function returns an int, it must return an int
08:56:44 <jmcarthur> k23z__: if you want it to return nothing useful, make it return () instead or something
08:56:53 <jmcarthur> k23z__: but the type signature will reflect that
08:56:57 <mux> to me, the only functions which really return nothing are functions that simply don't return at all
08:57:07 <EvanR-work> also, if it *may* return something useful, -> Maybe a
08:57:08 <mux> ie forever
08:57:13 <k23z__> mux, so how do I get such a function ?
08:57:27 <k23z__> jmcarthur, so     nothing = ()    ?
08:57:28 <mux> I thought that wasn't what you wanted
08:57:41 <EvanR-work> k23z__: see also Nothing
08:57:42 <mux> you want to return, you just don't want to return anything useful
08:57:42 <EvanR-work> :t Nothing
08:57:43 <lambdabot> forall a. Maybe a
08:58:13 <aristid> EvanR-work: Nothing does something relevant, i.e. it can be distinguised from Just x
08:58:19 <EvanR-work> yes
08:58:29 <aristid> so Nothing doesn't do nothing :P
08:58:37 <EvanR-work> values dont do anything anyway
08:58:45 <aristid> :D
08:58:49 <k23z__> so
08:59:01 <k23z__> nothing :: Maybe -> Nothing
08:59:11 <mux> Maybe is not a type
08:59:15 <k23z__> nothing = Nothing
08:59:19 <EvanR-work> neither is Nothing
08:59:21 <mux> you want Maybe <something>
08:59:26 <EvanR-work> oh oh i got it.
08:59:28 <k23z__> is there a type "Anything" ?
08:59:31 <EvanR-work> data Neither =
08:59:42 <k23z__> EvanR-work, is that a type ?
08:59:45 <EvanR-work> it is now
09:00:24 <k23z__> uh.. well it gives me <interactive>:1:0: parse error on input `data'
09:00:42 <EvanR-work> data Neither a b = Neither ()
09:00:47 <jkingkong> ezyang, jmcarthur: this existential quantification stuff is really magical
09:00:48 <mux> "data Foo =" is invalid; "data Foo" is allowed with a GHC extension
09:00:51 <fasta> k23z__, because ghci is not Haskell with extensions.
09:00:56 <EvanR-work> its a value that is neither an a nor b
09:01:22 <k23z__> EvanR-work, that's pretty cool
09:01:25 <EvanR-work> haha
09:01:27 <aristid> EvanR-work: Either a b is also neither a nor b :)
09:01:38 <aristid> cause it's Either a b
09:01:39 <EvanR-work> its not both a and b
09:01:48 <k23z__> fasta, can I make it have extensions ?
09:02:02 <EvanR-work> mine is both not a and b
09:02:11 <EvanR-work> not a and not b
09:02:20 <fasta> k23z__, the thing is that ghci understands everything you can define in a do-block of the IO monad essentially.
09:02:24 <k23z__> EvanR-work, how did you figure this stuff out ? what is this "data" thing ?
09:02:32 <jkingkong> k23z__: just put {-# OPTIONS_GHC -fglasgow-exts #-} at the top of your .hs file?
09:02:35 <EvanR-work> data is a basic feature of haskell, you need to read more
09:02:40 <jmcarthur> k23z__: are you following any sort of tutorial or anything?
09:02:43 <aristid> k23z__: learn you a haskell will explan "data" too
09:02:46 <jmcarthur> it sounds like you should be
09:02:52 <fasta> k23z__, so, just use Emacs and do C-c C-l to get some kind of interactive development going on.
09:03:10 <jmcarthur> @where lyah
09:03:11 <lambdabot> http://www.learnyouahaskell.com/
09:03:12 <k23z__> jmcarthur, yes sorry, was just trying to translate a piece of functional C++ into Haskell .. I should start reading some stuff
09:03:22 <jmcarthur> k23z__: i recommend the above link for you
09:03:27 <fasta> k23z__, if you use Hugs instead of ghci, you have even faster turnarounds.
09:03:29 <jmcarthur> or maybe...
09:03:34 <jmcarthur> @where rwh
09:03:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:03:48 <jmcarthur> k23z__: you might like that one if you already know other languages (sounds like you do)
09:03:51 <EvanR-work> RWH is probably good enough if you 'know' c++
09:03:59 <fasta> k23z__, but that doesn't understand all the GHC extensions.
09:04:13 <jmcarthur> wait, did i just see somebody recommend hugs?
09:04:29 <fasta> jmcarthur, for a very small niche it is better than ghci.
09:04:55 <mux> people still use hugs? :p
09:05:02 <fasta> mux, I think dons does.
09:05:11 * mux hugs hugs
09:05:20 <fasta> mux, at least, so he said a year ago.
09:07:05 <jkingkong> k23z__: learnyouahaskell.com is cool too
09:07:15 <jkingkong> oh nvm
09:07:17 <jkingkong> mentioned already
09:07:58 <rtaycher> is there a better way to represent a grid in haskell then a List of (x,y) tupples with attributes
09:08:20 <ezyang> rtaycher: Vector of vectors, if it's a dense grid
09:08:30 <EvanR-work> rtaycher: Array of somekind?
09:08:32 <jmcarthur> rtaycher: how will it be used?
09:08:51 <k23z__> jkingkong, the same ?
09:09:21 <k23z__> C++ is a bad language I don't like it
09:09:24 <k23z__> bad badbad
09:09:55 <EvanR-work> c++ refugee
09:10:00 <jmcarthur> it's just... special
09:10:31 <k23z__> haha
09:10:33 <k23z__> special
09:12:41 <EvanR-work> something tells me haskell could replace most use cases of c++ in the industry, except maybe super 3d games (?). but then i think, what about windows GUI programming
09:12:42 <rtaycher> to model a grid based game
09:12:54 <k23z__> jmcarthur, http://www.youtube.com/watch?v=-7Hy7uAb_eU#t=1m20s
09:13:01 <k23z__> haha
09:15:51 <Silvah> >.<
09:16:34 <Silvah> What is the fastest way to write a working and reasonably fast lexer?
09:18:59 <jmcarthur> Silvah: use one of parsec's predefined lexers?
09:19:49 <tromp> does parsec distinguish lexers from general parsers?
09:20:06 <jmcarthur> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Token.html#v%3AmakeTokenParser
09:20:42 <jmcarthur> some predefined ones http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Language.html
09:25:49 <siracusa> Someone here who recently built gtk2hs on a Windows system?
09:25:58 <Silvah> Yeah, I'd use them, but I can't use Parsec :(
09:33:57 <k23z__> err why can't I write in a cae
09:34:02 <k23z__> in a case
09:34:06 <k23z__> '%' -> (`mod`)
09:34:18 <k23z__> I get :21:15: parse error on input ``'
09:34:26 <k23z__> I tried without parenthesis
09:34:51 <siracusa> k23z__: '%' -> mod
09:34:53 <mux> you want just mod, without backquotes nor parens
09:34:54 <k23z__> I got the same on ')'
09:34:56 <monochrom> > (case '%' of '%' -> (`mod`)) 3 3
09:34:57 <lambdabot>   <no location info>: parse error on input `)'
09:35:03 <monochrom> interesting.
09:35:12 <monochrom> just write mod.
09:35:17 <monochrom> > (case '%' of '%' -> mod) 3 3
09:35:17 <lambdabot>   0
09:50:00 <k23z__> monochrom siracusa mux  thanks
09:55:42 <jkingkong> question: what does it mean to have a guard in a typeclass declaration?
09:55:55 <jkingkong> like "class Modular s a | s-> a where modulus :: s-> a"
09:56:04 <jkingkong> i haven't seen that before
09:56:10 <mm_freak> jkingkong: that's a functional dependency
09:56:35 <mm_freak> it says that the type a follows from the type of s, i.e. that there can be only one instance per type s
09:56:35 <jkingkong> mm_freak reading about it now thanks
09:56:41 <jkingkong> ah
10:01:26 * jmcarthur likes type families more than fundeps
10:04:39 <opqdonut> who doesn't
10:05:08 <jmcarthur> i was stating it for jkingkong's sake
10:05:59 <opqdonut> sure
10:15:34 <dpratt71> @where LYATF
10:15:34 <lambdabot> I know nothing about lyatf.
10:15:37 <dpratt71> darn
10:15:51 <Silvah> :src (||)
10:16:12 <Silvah> @src (||)
10:16:12 <lambdabot> True  || _ =  True
10:16:12 <lambdabot> False || x =  x
10:16:21 <Silvah> @src (&&)
10:16:21 <lambdabot> True  && x = x
10:16:22 <lambdabot> False && _ = False
10:16:30 <siracusa> dpratt71: FT = ?
10:16:36 <siracusa> Erm, TF = ?
10:17:08 <dpratt71> siracusa: type family; my weak attempt at humor
10:17:49 <aristid> :t [
10:17:50 <lambdabot> parse error (possibly incorrect indentation)
10:17:54 <aristid> :t (||)
10:17:55 <lambdabot> Bool -> Bool -> Bool
10:18:20 <aristid> looking at the @source, (||) is not a generic as it could be :/
10:19:28 <dpratt71> aristid: how's that?
10:19:57 <aristid> hmm i guess a typeclass would be needed for what i had in mind
10:20:01 <Philippa> Silvah: you still need to write a reasonable lexer from scratch?
10:20:11 <Silvah> Yeah...
10:20:44 <Philippa> what class of language do you need to support? Will regular expressions (in the strict CS sense) do?
10:20:44 <aristid> dpratt71: i wasn't fully considering how strict the haskell type system actually is :)
10:22:25 <dpratt71> aristid: gotcha
10:23:07 <maltem> aristid, there's a boolean package where ||* is a method of a type class Boolean (for boolean algebras)
10:23:23 <maltem> If that's what you were after
10:23:57 <Silvah> Philippa: you mean the class of language according to the Chomsky hierarchy?
10:24:04 <dpratt71> I've wondered if it would be interesting to have a language where the type of values could be an ad-hoc union of other types
10:24:07 <Philippa> correct
10:24:18 <Philippa> obviously you'll need to extract some of the characters too, but no big deal
10:27:02 <tromp> > succ '9'
10:27:04 <lambdabot>   ':'
10:27:15 <tromp> > ['9'..]
10:27:16 <lambdabot>   "9:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DE...
10:27:25 <Silvah> I'm not sure whether it's regular or context-free, so let's assume the second one.
10:28:46 <maltem> I just had a quick look at repa; they seem to have quite a sophisticated "shape" system for arrays, which serves e.g. to discern flat arrays from matrices. Is that shape thing inherent to what repa does?
10:29:33 <c_wraith> maltem: yes.  It's used in operations like fold to determine how to parallelize things
10:30:18 <maltem> Interesting thing, I must say
10:30:26 <aristid> @hoogle ||*
10:30:27 <lambdabot> No results found
10:30:30 <c_wraith> did you read the paper?  it's not long, and pretty readable
10:30:38 <aristid> maltem: which package?
10:30:43 <maltem> c_wraith, I'll have a look
10:30:48 <maltem> aristid, boolean
10:30:51 <maltem> (iirc)
10:33:48 <aristid> maltem: yeah, and it's got an instance for functions
10:34:02 <aristid> :t true
10:34:03 <lambdabot> Not in scope: `true'
10:34:23 <aristid> conal: do you use this package or was it a purely intellectual exercise?
10:34:38 <aristid> http://hackage.haskell.org/package/Boolean
10:34:55 <conal> aristid: i use it for deep dsels
10:35:11 <redocdam> why has there been so much trolling here lately
10:35:11 <aristid> dsels? is that a kind of dsl?
10:35:15 <conal> aristid: particularly for a gpu dsel
10:35:35 <conal> aristid: yeah.  dsel is "domain-specific embedded language"
10:35:35 <conal> an
10:35:35 <conal> d "
10:35:36 <conal> dee
10:35:37 <conal> p
10:35:48 <conal> oops -- client trouble again.  hm.
10:36:14 <conal> aristid: and "deep" roughly means code-generating.
10:36:24 <conal> aristid: as in Pan & Vertigo
10:36:33 <aristid> conal: so you basically use it to generate pixel shaders and such things? (excuse my outdatedness, i know pixel shaders have been replaced by something else but i don't know by what)
10:46:10 <dpratt71> I was looking at Clean for the first time the other day and noticed that the (+) and (*) operators were each defined by their own type class; I think the only other thing in there were the unit values (zero and one, respectively)
10:46:24 <copumpkin> that makes more sense
10:46:28 <dpratt71> do we like how Haskell handles this better? what are the pros/cons?
10:46:43 <copumpkin> Haskell's num class is frankenstein's monster
10:46:54 <dpratt71> copumpkin: I'm starting to sense that
10:46:59 <pikhq> Haskell's num class is a bit poorly thought out.
10:47:08 <pikhq> It kinda works, but it *is* a bit of a wart.
10:47:16 <Cale> The only pro of the way that Haskell does it is that fromInteger is potentially more efficient than an implementation of polymorphic numeric literals in terms of zero and one
10:47:44 <Cale> (and every ring will have a suitable fromInteger anyway)
10:48:06 <pikhq> Hmm. Wasn't Clean one of the many, many Haskell-predecessors, and that one just happened to survive?
10:48:44 <Cale> no
10:48:56 <pikhq> Then my memory is wrong.
10:48:57 <Cale> Clean was contemporary with Haskell
10:48:59 <pikhq> Haskelloid, then.
10:49:08 <Cale> Miranda is a predecessor to both
10:49:16 <pikhq> Ah, right, that was it.
10:49:24 <dpratt71> Cale: I could be wrong, but I didn't think that the unit values related directly to literals
10:49:52 <Cale> dpratt71: Well...
10:50:10 <dpratt71> I just mean the (+) type class defined the (+) operation as well as a unit value (zero)
10:50:20 <jmcarthur> dpratt71: Monoid :)
10:50:21 <Cale> If you didn't have something with fromInteger in it, you would need to build up the meaning of literals from zero and one
10:50:30 <dpratt71> jmcarthur: right
10:51:12 <copumpkin> ghc decomposes large literals too, behind the scenes
10:51:25 <ddarius> dpratt71: In Clean, I believe every method is in a class of its own.  There isn't a way to do Num or Monad, though you can certainly get the same effect.
10:51:42 <dpratt71> Cale: I think that would be somewhere outside the type classes for (+) and (*)
10:52:17 <dpratt71> to be clear (+) and zero in one type class, (*) and one in another, separate type class
10:53:12 <aristid> dpratt71: 0 and 1 would have different type classes?
10:53:45 <dpratt71> aristid: not representing integer values, per se, just "unit"
10:54:13 <aristid> dpratt71: 0  is more generic than integer values already
10:55:05 <Cale> dpratt71: fromInteger's behaviour is entirely determined from those though
10:56:22 <dpratt71> I don't know how it is in Clean, but I would imagine some sort of Num class that defines fromInteger and is also an instance of the (+) and (*) classes
10:57:11 <Cale> That could be done, or you could just stick fromInteger into the multiplicative class, given that that one already is a subclass of the additive one.
10:57:54 <sm> strange.. when I convert a markdown doc to html with hakyll+pandoc, ' is converted to 0x19
10:58:02 <Cale> But yeah, it would make sense to have entirely separate multiplicative and additive classes, together with a Num which was a subclass of both and defined fromInteger
10:58:08 <Cale> (and only that)
10:58:16 <sm> when I use pandoc alone, it's fine. I seem to be using similar pandoc options in both cases
10:58:28 <Cale> and then move abs and signum into their own subclass of Num
10:59:56 <aristid> Cale: that sounds like at least one class too many
10:59:57 <dpratt71> Cale: are you saying that multiplicative is an instance of additive?
11:00:09 <Cale> dpratt71: One could insist on that
11:00:46 <Cale> dpratt71: and insist that (*) distributes over (+) so as to make the result a ring.
11:01:16 <Cale> mm, you'd want the additive class to be for abelian groups in that case, I suppose
11:01:44 <dpratt71> Cale: I see; the whole algebraic structure stuff of which I understand so very little
11:01:48 <aristid> i guess Double won't be part of your beautiful classes :P
11:01:57 <Cale> aristid: right
11:02:18 <aristid> but to be quite precise, Double wouldn't be part of Ord either
11:02:21 <aristid> nor would CReal
11:02:28 <Cale> aristid: Though we'd probably just use the laws as rough guidelines rather than as strict rules.
11:02:28 <maltem> I'd think the point of seperate Additive and Multiplicative would be not to imply any laws, such that the symbols (+) and (*) would be as versatile as possible
11:03:07 <Cale> Well, you'd at least want them both to be monoids.
11:03:08 <dpratt71> maltem: nah, just make a (.) type class for the lawless
11:03:20 <aristid> Cale: just like lawyers say "always" when they mean "usually"? :P
11:03:51 <Cale> Also, we have to work out where negation fits into this
11:04:08 <Cale> (does it go into the Additive class, or is it separate?)
11:04:19 <Cale> There are a lot of possible design choices.
11:04:35 <maltem> Cale, but with monoids, we have to argue about floating-points again
11:04:39 <dpratt71> is it reasonable to imagine a compiler enforcing associativity and commutivity? or is that in the undecidable category?
11:04:50 <Cale> I actually don't care about that nearly as much as I care about simply dropping the Eq and Show class constraints from Num, and separating off abs and signum
11:05:12 <maltem> Maybe special operators for floating-points, as in ML (?), aren't actually that bad
11:05:19 <Cale> maltem: oh, of course, floating point things are exempt :P
11:05:30 <Cale> (as usual)
11:05:47 <Cale> Floating point numbers don't even give us a proper instance of Eq
11:05:58 <Cale> At least, if you expect (==) to be an equivalence relation.
11:06:29 <Cale> > let x = 0/0 in x == x
11:06:30 <lambdabot>   False
11:06:49 <maltem> Well, that's not so much of an organisational problem, because you don't typically use == on floating-points anyway. People do want to add and multiple floats, though
11:07:04 <aristid> > let x = 0/0 :: CReal in x == x
11:07:08 <lambdabot>   mueval-core: Time limit exceeded
11:07:12 <aristid> wtf
11:07:13 <Cale> and Ord?
11:07:35 <maltem> and Ord.
11:07:35 <Cale> One would expect Ord instances to be totally ordered by <=
11:07:55 <aristid> Complex is not in Ord?
11:08:02 <Cale> and that fails for much the same reason
11:08:06 <Cale> aristid: right.
11:08:06 <aristid> @hoogle Complex
11:08:07 <lambdabot> module Data.Complex
11:08:07 <lambdabot> Data.Complex data RealFloat a => Complex a
11:08:40 <maltem> And yeah, the joys of IEEE's NaN
11:08:42 <Silvah> What's the definition of the ordering for complex numbers then?
11:09:08 <Cale> It might be convenient to just give them the lexicographic ordering
11:09:09 <aristid> data (RealFloat a) => Complex a = !a :+ !a
11:09:09 <aristid> what does the ! mean?
11:09:14 <Cale> Strict field
11:09:25 <aristid> interesting
11:09:37 <Cale> It means that when you pattern match the :+ constructor, the left and right parts are evaluated.
11:09:53 <aristid> and when you construct a float?
11:09:58 <Cale> hm?
11:09:58 <aristid> *a complex
11:10:00 <_Ray_> Hey. Is there a way to represent, in Haskell, the fact that I have df/dx = sqrt(x+y+1), and then I have a substitution of u = x+y+1? Don't know if that makes much sense.
11:10:01 <Cale> No.
11:10:28 <ezyang> _Ray_: That sounds like a job for pattern matching
11:10:28 <aristid> Cale: is there a character to get that?
11:10:40 <jmcarthur> _Ray_: sure. you have to make a data structure to represent expressions and then write a function over it
11:10:40 <ezyang> though you might need something more expressive than what Haskell has got built-in
11:10:56 <Cale> aristid: Well, when is the complex number considered to be constructed?
11:11:04 <_Ray_> Right, I am used to doing it in, say, polynomials, where the constructors of the type are well defined, but not in general expressions.
11:11:10 <Cale> aristid: This gives you the closest meaningful approximation to that
11:11:52 <aristid> Cale: so (x :+: y) `seq` foo would "pattern match" it too?
11:12:12 <Cale> aristid: It ensures that when the expression is evaluated far enough that the :+ constructor can be matched on (which is the first point you could meaningfully say that it's constructed and you've allocated memory for it), the real and imaginary components are evaluated as well.
11:12:14 <aristid> (x :+ y) i mean
11:12:24 <Cale> yeah
11:12:49 <aristid> Cale: which means that a Complex can be stored in compact form in memory, right?
11:13:10 <aristid> (assuming the implementation elects to do it)
11:13:59 <Cale> Well, the real and imaginary parts could be stored alongside the constructor tag.
11:14:01 <pikhq> aristid: Actually, just means that you don't get particularly confusing situations caused by the real and imaginary components having different amounts of laziness.
11:14:22 <Cale> But if you do that, you have to be careful...
11:15:10 <Cale> The fields are themselves polymorphic in general
11:15:35 <Cale> :t 6 :+ 7
11:15:36 <lambdabot> forall t. (RealFloat t) => Complex t
11:16:00 <Cale> :t realPart (6 :+ 7)
11:16:00 <lambdabot> forall t. (RealFloat t) => t
11:17:03 <Cale> I'm not sure if GHC will actually specialise the type and unbox the strict polymorphic fields, even if you do tell it to unbox strict fields (which it has a flag for)
11:17:54 <Cale> I'm pretty sure it never does that sort of thing
11:18:12 <jmcarthur> really?
11:18:56 <Cale> It'll unbox monomorphic strict fields
11:19:28 <Cale> If you tell it to either by -funbox-strict-fields or sticking an {-# UNPACK #-} pragma before the field.
11:19:38 <Cale> But I don't think it'll ever unbox polymorphic fields.
11:19:41 <jmcarthur> hmm
11:19:54 <jmcarthur> might be worth me looking into
11:19:58 <Cale> (how do you even do it?)
11:20:15 <jmcarthur> well, ghc doesn't complain if you put {-# UNPACK #-} before a polymorphic field
11:20:17 <Cale> It would require making specialised versions of the type for each type at which it's applied
11:20:18 <Gwern-away> specialize and unbox the specialized versions?
11:20:24 <jmcarthur> yeah
11:20:35 <Gwern-away> actually, isn't that what dons' adaptive containers does?
11:20:37 <jmcarthur> doesn't seem that specializing would be so bad, to me
11:20:37 <Cale> which breaks separate compilation somewhar
11:20:41 <Cale> somewhat*
11:21:11 <Gwern-away> separate compilation be do overrated
11:21:35 <jmcarthur> agreed... assuming i understand that broken english correctly
11:21:40 <mdmkolbe> Has the SYB page moved from http://www.cs.vu.nl/boilerplate/ ?  It seems to be down.
11:22:37 <Cale> Well, it would mean that every time you wanted to use Data.Complex with a new type of component, you might end up recompiling everything in that library.
11:22:47 <Cale> and everything that uses complex numbers elsewhere
11:22:48 <babusri> Can someone give a simple example of vector package usage, where a mutable array of Word8 is used and an array value is changed in place. http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial doesn't have a simple example.
11:23:05 <jmcarthur> yeah i guess the existence of apdaptive-containers is only justified if what you say is correct, Cale
11:23:15 <jmcarthur> *adaptive-containers
11:24:15 <Cale> http://hackage.haskell.org/packages/archive/vector/0.6.0.1/doc/html/Data-Vector-Mutable.html#v%3Awrite
11:24:31 <Gwern-away> Cale: users shouldn't be compiling anyway
11:24:46 <Cale> So:  write myVector 5 16
11:24:54 <Cale> Would write the value 16 at position 5
11:24:56 <jmcarthur> i personally am not very annoyed by long compile times
11:25:04 <Gwern-away> moore's law will save us, too
11:25:07 <jmcarthur> i tend to pipeline compilation with coding anyway
11:25:17 <Gwern-away> more cores for the compiler god!
11:25:18 <Cale> Gwern-away: Separate compilation makes that possible...
11:25:46 <Cale> The users of libraries will have to recompile them arbitrarily often if separate compilation is broken.
11:27:11 <jmcarthur> i'm personally annoyed that module boundaries impose a performance overhead on the compiled result
11:28:20 <jmcarthur> a pretty drastic one for haskell programs
11:28:34 <jmcarthur> considering that it affects tons of optimizations
11:28:44 <Cale> babusri: Is that the sort of example you wanted?
11:28:48 <pikhq> jmcarthur: If it makes you feel better, this is actually a problem for *most* compiled languages.
11:29:02 <jmcarthur> pikhq: yeah, but it's especially big for ghc
11:29:14 <Gwern-away> what's the worst case? you have to compile all deps? so, for the most demanding app I can think of like gitit, that's 40 libs or so
11:29:27 <pikhq> True. What with GHC doing a massive chunk of optimizations and all.
11:29:32 <Gwern-away> Cale: I don't think whole-program is entirely completely serial...
11:30:06 <Cale> Gwern-away: Think about how long it takes to compile all of the libraries which come with GHC
11:30:08 <jmcarthur> yeah, plus specializations could be cached just like .o files are now
11:32:05 <gio123> .
11:32:20 <Silvah> Oh, really?
11:49:06 <babusri> Cale: PrimMonad and PrimState are a bit hard to understand. write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m (). How do I define myVector
11:57:07 <redocdam> jmcarthur: what do you mean by...
11:57:12 <redocdam> 20:26 <jmcarthur> i'm personally annoyed that module boundaries
11:57:12 <redocdam>                   impose a performance overhead on the compiled
11:57:12 <redocdam>                   result
11:57:15 <redocdam> oops
11:57:47 <jmcarthur> redocdam: i mean that many of GHC's important optimizations simply don't apply across module boundaries :(
11:58:24 <jmcarthur> or when they do they do so in different ways than normal
12:00:04 <redocdam> what annoys me is that GHC is converging on LLVM
12:00:25 <SamB_XP> hmmmm?
12:00:33 <redocdam> furthermore I am alos getting sleepless nights over the GCC move to a c++ implementation
12:00:43 <redocdam> C++ is just sneaking in everywhere
12:00:49 <redocdam> Maybe I'll just become a janitor
12:01:17 <mxc> i've agreed with jmcarthur about that everytime he's written it :)
12:01:54 <mxc> since you should be able to pretty simply transform any haskell program into a single module by just qualifying all the identifiers
12:02:54 <redocdam> I didn't think the modules had any other effect than being namespaces
12:03:01 <mxc> unfortunately, they do
12:03:06 <SamB_XP> mxc: I'm thinking it would probably take forever to compile, though
12:03:06 <jmcarthur> they are also compilation units
12:03:14 <mxc> also agree WRT pipelining compilation
12:03:44 <mxc> usually, in my work flow, if i fire off a compilation that will be more than 2 sec, just flip back to my editor and work on something else
12:04:17 <jmcarthur> i'm fine with there being compilation units. i just wish they were independent of modules and that they were much more fine grained
12:04:35 <SamB_XP> oh, and of course it's not possible to mash together your modules like that if you use TH
12:04:49 <redocdam> how would go about getting this fine grained control over compilation units?
12:05:07 <redocdam> specifying moudles that were to be "merged"
12:05:14 <redocdam> or something
12:07:02 <redocdam> oh sorry it's hard to write on this keyboard it's so small
12:07:23 <redocdam> jmcarthur: what do you propose?
12:08:11 <ezyang> Gonna try using uniplate. Which docs should I use?
12:08:47 <jmcarthur> redocdam: i don't really propose anything in particular. it would probably be a lot of work to make such major changes in ghc
12:11:59 <ezyang> Huh. I wonder if the data structure I want to use uniplate on derived Typeable
12:12:48 <ezyang> Nope. Does this mean I lose?
12:28:56 <dpratt71> one of the nice features (IMHO) of the CLR/JVM is that the compilers don't generate native code; the bytecode they do generate is still pretty high-level
12:29:26 <dpratt71> what are the chances Haskell will ever have that kind of system?
12:29:58 <ezyang> LLVM might get you close.
12:30:08 <dolio> YHC compiles to bytecode.
12:30:31 <jcreigh> LLVM is a tad higher level than machine code, but not by much.
12:30:43 <jcreigh> LLVM is basically a CPU as you wish it was. :)
12:30:51 * hackagebot ansi-terminal 0.5.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.5.1 (MaxBolingbroke)
12:32:04 <jmcarthur> i wonder how fast a core interpreter could be
12:32:50 <jmcarthur> maybe with some sort of core bytecode format
12:32:54 <Cale> babusri: Oh, sorry, got up for a bit there
12:33:16 <Cale> babusri: IO is an instance of PrimMonad, so you can just use IO there
12:33:20 <byorgey> and... Hac phi is underway! =D
12:33:29 <dmead> oh yes
12:33:32 <jmcarthur> byorgey: have fun!
12:33:57 <byorgey> jmcarthur: thanks!  too bad you couldn't come.  Maybe you can come next year =)
12:34:05 <jmcarthur> byorgey: i will try to plan on it
12:34:13 <dpratt71> funny, I remember being quite enamored with VB 4 until I found out that it didn't create "real" x86 programs; not quite sure why that was so important to me at the time
12:34:17 <byorgey> we will try to plan things much further in advance next year I think
12:34:20 <Cale> babusri: Presumably, you'd use 'new' to get a new mutable vector
12:35:22 <maltem> Any Repa insiders still around? I want to find the index of the largest element in a Repa array, which would be a trivial fold, if it weren't for Repa's fold being restricted to (a -> a -> a) instead of (b -> a -> b)
12:36:02 <Cale> ghci> :m + Data.Vector.Mutable
12:36:02 <Cale> ghci> myVector <- newWith 10 0
12:36:02 <Cale> ghci> mapM (Data.Vector.Mutable.read myVector) [0..9]
12:36:02 <Cale> [0,0,0,0,0,0,0,0,0,0]
12:36:02 <Cale> ghci> write myVector 5 25
12:36:04 <Cale> ghci> mapM (Data.Vector.Mutable.read myVector) [0..9]
12:36:05 <Cale> [0,0,0,0,0,25,0,0,0,0]
12:36:08 <Cale> babusri: ^^
12:38:42 <Cale> maltem: hmm, perhaps traverse can be used?
12:38:58 <aristid> @hoogle Data.Vector.Mutable
12:38:59 <lambdabot> No results found
12:39:07 <ezyang> Are Scala implicits like Haskell's data families?
12:40:38 <maltem> Cale, looks like that makes me write a loop by hand :) I'll see if traverse is of use
12:41:16 <Cale> maltem: Well, traverse looks like a fold of sorts
12:41:23 <yashton> :t <-
12:41:25 <lambdabot> parse error on input `<-'
12:41:29 <Cale> With weird shape stuff involved
12:41:43 <Cale> yashton: <- is part of the Haskell syntax in various places
12:41:51 <maltem> Hmm, with traverse I still won't be able to return (Double,Int) (the maximum element and its index)
12:42:44 <maltem> Cale: Actually, it's unstructured traversal, that is, the (sh -> a) bit provides random access, afaiu
12:42:51 <Cale> hmm, yeah
12:42:53 <yashton> Cale: I kind of assumed it would be a function, not syntax...
12:43:05 <Cale> yashton: Where are you seeing it?
12:43:21 <Cale> yashton: I can explain its meaning for you in context
12:44:13 <Cale> maltem: ah, okay
12:44:17 <maltem> And I think that if I used toList, I'd be asking a little too much from fusion :)
12:44:21 <yashton> Cale: in IO i see it used to extract values from monads, above you were using it on "myVector <- newWith 10 0"
12:44:46 <Cale> yashton: monads are things at the type level, you mean "to run actions" :)
12:45:01 <yashton> Cale: I thought actions were monads
12:45:14 <Cale> Monads are type constructors which support a given API
12:45:47 <yashton> yashton: so <- is action specific, not monad specific.
12:45:49 <Cale> and the values of the types constructed by those are usually called "actions", "computations", or "monadic values"
12:46:17 <Cale> That is, if  x :: M a,  M is the monad
12:46:25 <Cale> and x is an action in the monad M
12:46:33 <Cale> (whose result has type a)
12:46:44 <yashton> so is Maybe considered an action?
12:46:48 <Cale> No
12:46:52 <Cale> Maybe itself is a monad
12:47:00 <Cale> Just 5  would be an 'action' in that monad
12:47:17 <Cale> (though it's a little funny in the case of Maybe to use the term 'action')
12:47:35 <yashton> from what i've been reading action refers to things like IO that have side effects
12:47:42 <Cale> yeah, usually
12:47:47 <Cale> getLine :: IO String
12:47:49 <Cale> IO is a monad
12:47:52 <dpratt71> Cale: would you really say Just 5 is an action? The 'action' term makes sense for IO, I think, but not all the other Monads
12:47:54 <Cale> getLine is an action in the IO monad
12:48:05 <Cale> dpratt71: Well, to be consistent.
12:48:20 <Cale> dpratt71: I'm just trying to not confuse values and type constructors here
12:48:27 <Cale> Which term we use for the values is another thing :)
12:48:37 <dpratt71> Cale: If I were using a generic term, I might choose 'computation'
12:48:41 <Cale> yeah
12:48:43 <tromp> succ is an actoin in the Reader monad
12:48:50 <Cale> Though even 'computation' is biased :)
12:49:13 <dpratt71> how about 'thingy'?
12:49:24 <Cale> "monadic value" is a good fallback
12:49:38 <Cale> If you don't feel comfortable with any of the other terms
12:49:54 <Cale> yashton: *anyway*...
12:49:54 <yashton> how does a monad represent a computation though? in Maybe and exceptions it represents extra data, in IO it means side effects.
12:50:10 <yashton> i understand the definition of a monad, but i can't see how it can be used.
12:50:45 <dpratt71> "monadic value" is kind of recursive, though; "well, Monads involve...uh...monadic values..."
12:50:53 <Cale> Well, it's best to just think of monads as being like libraries which coincidentally support a particular interface, and because of that, they support a bunch of nice general functions
12:51:18 <yashton> well, i guess that's like knowing the definition of a calculus derivative but not knowing what it can be used for :-)
12:51:24 <Cale> So, you can use Maybe on its own, neglecting the fact that Maybe is a monad, but because it is, you get all the stuff from Control.Monad for free.
12:51:29 <Cale> So, for example:
12:51:37 <Cale> > sequence [Just 5, Just 7, Just 10]
12:51:37 <lambdabot>   Just [5,7,10]
12:51:42 <Cale> > sequence [Just 5, Just 7, Just 10, Nothing]
12:51:43 <lambdabot>   Nothing
12:52:16 <yashton> the chaining makes sense, because if any previous value is Nothing, then the result of the rest is nothing
12:52:37 <maltem> Uh. Now I'm at the point where I'd have to upgrade to GHC head to keep trying out Repa
12:52:46 <Cale> > let dict = zip [0..] (words "here are some words") in do x <- lookup 3 dict; y <- lookup 1 dict; return (x,y)
12:52:46 <lambdabot>   Just ("words","are")
12:52:56 <Cale> > let dict = zip [0..] (words "here are some words") in do x <- lookup 3 dict; y <- lookup 7 dict; return (x,y)
12:52:57 <lambdabot>   Nothing
12:53:02 <aristid> @remember maltem Uh. Now I'm at the point where I'd have to upgrade to GHC head to keep trying out Repa
12:53:03 <lambdabot> It is stored.
12:53:12 <Cale> (if any lookup fails, the result is Nothing)
12:53:50 <maltem> hey this is not a funny situation :p
12:53:52 <jmcarthur> aristid: was that funny?
12:53:59 <Cale> This is why it's convenient that Maybe is a monad; it's because there are often times where you want to do a bunch of possibly-failing computations, and if any of them fails, then the whole thing does.
12:54:30 <aristid> jmcarthur: yes.
12:54:34 <Cale> aristid: Why?
12:54:38 <babusri> cale: Thank you very much.
12:54:42 <aristid> Cale: duh.
12:55:01 * hackagebot ansi-terminal 0.5.2 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.5.2 (MaxBolingbroke)
12:55:24 <Cale> yashton: As another example, the type constructor for lists is a monad, and as a consequence, we get lots of other stuff:
12:55:30 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
12:55:31 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
12:55:43 <Cale> The list monad is good at "choosing things in all possible ways"
12:55:45 <yashton> besides the syntax sugar, what's the difference in say, exception handling, between using a -> ([Char], a) and a -> M a
12:56:10 <Cale> yashton: For which monad M? You gave an example of a monad there.
12:56:37 <k23z__> anyone here interested in Galois theory ?
12:56:37 <Cale> newtype Logger a = L [Char] a
12:56:43 <Cale> instance Monad Logger where
12:56:50 <Cale>   return x = L [] x
12:56:56 <aristid> > sequence [[1,2,3],[4,5]]
12:56:57 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
12:57:05 <yashton> the logger is the example i've seen
12:57:29 <yashton> what is the L in 'L [Char] a' ?
12:57:42 <Cale>   L ws x >>= f = let L ws' y = f x in L (ws ++ ws') y
12:57:43 <dpratt71> right or not, I see the List and Maybe monads as being pretty much the same thing. Maybe is 0..1 things, List is 0..n things
12:57:52 <aristid> yashton: L constructs a Logger
12:58:00 <Cale> yashton: Just a data constructor to let the compiler know that we're using the type being defined
12:58:12 <yashton> oh, right
12:58:15 <Cale> It behaves as a function  L :: [Char] -> a -> Logger a
12:58:32 <Cale> and we can pattern match on the value constructed by it to get the parameters back again
12:58:56 <Cale> Basically, I defined a type which was the same as your type of pairs
12:59:13 <Cale> and some handy functions for composing computations which log values
12:59:33 <Cale> and in terms of those, I get for free all the things in Control.Monad, and elsewhere
12:59:42 <Cale> as well as handy do-notation
13:00:04 <Cale> I could just as well have written the same functions for ([Char],a) values
13:00:37 <yashton> :t in
13:00:38 <lambdabot> parse error on input `in'
13:00:41 <Cale> Well, with the FlexibleInstances extension I could actually turn (,) [Char] into a monad directly
13:00:50 <Cale> let ... in ...
13:01:01 <yashton> ah
13:01:11 <Cale> let <decls> in <expr>  makes the declarations <decls> available for use in the expression <expr>
13:01:13 <dpratt71> k23z__: is that the theory that Haskell can be used for commercial enterprise? ;-)
13:01:20 <yashton> i'm trying to parse your function earlier
13:01:23 <yashton>    L ws x >>= f = let L ws' y = f x in L (ws ++ ws') y
13:01:33 <Cale> Yeah, let me add some parens :)
13:01:42 <yashton> are you defining a new function f after the >>= operator?
13:01:43 <Cale>   (L ws x) >>= f = let { L ws' y = f x } in L (ws ++ ws') y
13:01:46 <k23z__> dpratt71, maybe :P come to #galoistheory to find out
13:01:48 <Cale> I'm defining >>=
13:02:03 <yashton> oh, i thought you were using it
13:02:07 <Cale> (>>=) :: Logger a -> (a -> Logger b) -> Logger b
13:02:13 <yashton> infix :-)
13:02:16 <Cale> yeah
13:02:27 <dpratt71> k23z__: if it involves math and theory, I'm afraid I'd just be a waste of space
13:03:21 <Cale> dpratt71: It's a joke, "Galois Theory" is a branch of mathematics, but "Galois Inc." is one of the commercial enterprises using Haskell ;)
13:03:44 <Cale> dpratt71: heh, maybe you already knew that
13:03:49 <Cale> (missed some context)
13:04:17 <yashton> i can see how the >>= is useful. in C# there is the Nullable<T> class, which implements part of the idea of monads, but there isn't a composition operator, so you spend a lot of time just testing for null
13:04:38 <Cale> yashton: Good, because that can be a bit of a mouthful to try to explain :)
13:05:02 <aristid> yashton: the Maybe monad is also a bit like exceptions
13:05:23 <Cale> yashton: So, in terms of return and (>>=), we can construct lots of other useful functions
13:05:28 <aristid> once you get a Nothing, it immediately leaves the monad
13:05:50 <yashton> Cale: what other kinds of things?
13:05:59 <Cale> yashton: The idea of monads as an abstraction is that many different libraries have functions with the same overall shape as this return and (>>=), and so we should generalise
13:06:08 <Cale> :t sequence
13:06:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:06:21 <Cale> Lots of noise at the beginning there you can ignore :)
13:06:24 <Cale> (Monad m) => [m a] -> m [a]
13:07:02 <Cale> It takes a list of actions, and produces from them a single action which intuitively "runs" them all in turn producing a list of results.
13:07:23 <Cale> What it means to "run" an action will depend on which monad it is and how >>= is implemented, of course.
13:07:24 <yashton> so that would take [Just 7, Just 5] and make Just[7, 5]
13:07:27 <Cale> yeah
13:07:42 <applicative> >  sequence [length, sum . map ord, ord . head] "Socrates"
13:07:43 <lambdabot>   [8,836,83]
13:07:45 <Cale> or two IO actions, and produce an IO action which performs both, giving a list of the two results
13:07:53 <monochrom> example of the Maybe monad simplifying code: http://www.haskell.org/haskellwiki/Dynamic_programming_example
13:08:08 <Cale> or two functions, and produce a function which applies them each to a common value
13:08:17 <Cale> or two parsers, and gives their concatenation
13:08:18 <Cale> and so on
13:08:43 <Cale> actually, s/two/many/ of course
13:10:16 <Cale> yashton: Oh, and of course, in the case of lists, sequence gives the Cartesian product: the list of all ways of picking one element from each list.
13:11:01 <Cale> and that's just sequence ;)
13:12:21 <Cale> There's mapM, zipWithM, foldM, lots of handy compositional operators like (<=<) and so on in Control.Monad, and they're all things you get for free when you recognise that your library happens to be monadic.
13:12:39 <yashton> i see.
13:12:40 <Cale> > replicateM 5 [0,1]
13:12:41 <lambdabot>   [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0...
13:13:02 <Cale> > filterM (const [True,False]) "abcde"
13:13:02 <lambdabot>   ["abcde","abcd","abce","abc","abde","abd","abe","ab","acde","acd","ace","ac...
13:13:17 <yashton> :t filter
13:13:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:13:20 <yashton> :t filterM
13:13:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:13:40 <Cale> So, I'm using the filterM for the list monad
13:14:02 <Cale> with the "condition" that regardless of what the element is, keep it, or drop it
13:14:27 <Cale> (const [True, False]) is the function which produces the list of options [True, False] regardless of its input
13:14:42 <yashton> what's the list monad do compared to lists?
13:14:46 <Cale> and so what filterM does is enumerate all the possible ways of keeping or dropping elements
13:14:54 <Cale> Well,
13:15:14 <Cale> return :: a -> m a, right? And here, m = []
13:15:15 <Cale> So:
13:15:22 <Cale> return :: a -> [a]  in this context
13:15:34 <Cale> return v = [v] -- and it just does the obvious thing
13:15:44 <Cale> and >>= ...
13:15:52 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
13:16:07 <Cale> Now, you might want to think about what a function with that type might do
13:16:33 <Cale> Well, we have a list of values of type a, and a function which, given a value of type a, produces a list of values of type b
13:16:34 <yashton> looks almost like map
13:16:52 <Cale> If we just mapped that function over the list, we'd get a list of lists of values of type b
13:17:04 <Cale> So what should we do from there? :)
13:17:30 <Cale> The most natural thing to do would just be to concatenate them, yeah?
13:17:33 <jkingkong> Question: can you have a type instantiate the Num typeclass but have two items of that type add up to a different type?
13:17:53 <Cale> jkingkong: Not using (+)
13:17:58 <yashton> hmm
13:18:00 <jkingkong> or multiply to get a third type, e.g. two vectors multiply to a get a matrix
13:18:10 <Cale> jkingkong: No, define a separate operator for that.
13:18:36 <jkingkong> Cale: hmmm ok thanks
13:18:47 <Cale> yashton: That is, xs >>= f = concat (map f xs)
13:19:08 <yashton> makes sense
13:19:24 <Cale> yashton: I suppose another thing I should tell you is how to translate do-notation into >>='s
13:19:54 <yashton> for every line in the indentation block
13:19:54 <yashton> do f
13:19:54 <yashton> g
13:19:54 <yashton> h
13:20:03 <Cale> do { x } = x -- base case
13:20:05 <yashton> is equal to f >>= g >>= h
13:20:11 <Cale> not quite
13:20:34 <Cale> We define  x >> y = x >>= const y
13:20:54 <Cale> and then:
13:21:10 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
13:21:20 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
13:21:43 <Cale> do { let { <decls } ; <stmts> } = let { <decls> } in do { <stmts> }
13:22:05 <Cale> So, this means:
13:22:14 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
13:22:15 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:22:18 <Cale> is the same as
13:22:28 <Cale> > [1,2,3] >>= \x -> [4,5] >>= \y -> return (x,y)
13:22:29 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:23:08 <systemfault> Hmm
13:23:33 <systemfault> Noob here... Is there any advantage in using that version versus using Applicative?
13:23:37 <yashton> so when I do x <- [1,2,3] that's say x exists in that list
13:23:38 <Cale> systemfault: no
13:23:42 <yashton> the mathematical operator
13:24:00 <Cale> yashton: Yeah, it's sort of like it's saying "select x from the list [1,2,3]"
13:24:07 <yashton> for some x in A
13:24:20 <yashton> which is why it's used in list comprehensions
13:24:21 <jkingkong> how does one overload operators? e.g. how would i write an operator (*.) say that can multiply a vector to a vector, a vector to a matrix, a matrix to a matrix, etc.
13:24:22 <jmcarthur> generally if you can use applicative instead of monad you are probably better off using applicative since it imposes the fewest restrictions on what types you can apply it to
13:24:40 <Cale> yashton: Yeah, the secret is that list comprehensions and do-notation are very closely related anyway :)
13:24:42 <systemfault> Thanks :)
13:25:24 <Cale> jkingkong: You would use typeclasses, probably multiparameter typeclasses with some functional dependencies.
13:25:36 <jmcarthur> we should take everything Cale says in #haskell, throw it in a book, and call it Real World Caleskell
13:25:54 <Cale> hehe
13:26:07 <dpratt71> Erik put monads in C#, but he used SQL-ish syntax instead of do notation so as not to scare folks
13:26:11 <Cale> I'm supposed to be writing a book with edwardk
13:26:18 <jmcarthur> oh?
13:26:23 <Cale> But we haven't really gotten started on it
13:26:31 <jmcarthur> what about, specifically?
13:26:38 <jkingkong> cale: thanks, i guess it's a problem then if my vector and matrix are separate classes :P
13:26:38 <Cale> Functional programming in Haskell
13:26:48 <hellidunno> Hey there
13:26:49 <jmcarthur> ah, well that's as specific as i should expect i suppose
13:26:50 <Cale> jkingkong: Separate types
13:27:04 <Cale> hellidunno: hello
13:27:13 <hellidunno> What is the use of the function fromIntegral? I don't see the point, it takes an Int and returns an Int ?!!?
13:27:18 <hellidunno> *confused*
13:27:32 <Cale> hellidunno: It takes any integrally-typed value, and produces any kind of number at all
13:27:47 <hellidunno> what is a integrally typed value?
13:27:53 <Cale> Int, Integer, Word32, etc
13:27:54 <jmcarthur> @instances Integral
13:27:55 <lambdabot> Int, Integer
13:27:56 <hellidunno> ok
13:28:01 <jmcarthur> there are more than those two
13:28:07 <hellidunno> and it can produce like "123"
13:28:16 <Cale> and it produces any kind of number
13:28:18 <jmcarthur> > fromIntegral 123 :: Double
13:28:19 <lambdabot>   123.0
13:28:22 <jmcarthur> > fromIntegral 123 :: Rational
13:28:23 <lambdabot>   123 % 1
13:28:24 <hellidunno> ah now I got it
13:28:25 <hellidunno> ty
13:28:27 <Cale> So, for example, Float, or Double, of Complex Double
13:28:30 <Cale> or*
13:28:44 <hellidunno> I didnt add the type sig, so my results were rubbish
13:28:46 <hellidunno> ty :)
13:28:56 <jmcarthur> np
13:29:02 <Cale> Yeah, it determines which conversion to do based on context
13:29:36 <Cale> and ambiguous numeric types just defaulted to Integer or Double, whichever works first (by default)
13:29:53 <roconnor> default defaults
13:29:57 <Cale> :)
13:30:02 <RayNbow> Cale: when you'll write that book with edwardk, will it feature an open beta phase like RWH? :)
13:30:08 <hellidunno> kk
13:30:14 <Cale> RayNbow: That would be interesting. We'll have to see
13:30:33 <Cale> I wish edwardk was actually here, he knows more about what's going on than I do.
13:30:49 <Cale> (He's the one who was approached by the publisher)
13:34:00 <jmcarthur> what level of functional programming and/or haskell will it be catered for?
13:34:30 <roconnor> Cale: are you really writing a book?
13:34:40 <Cale> roconnor: Well, I hope so :)
13:34:51 <aristid> Cale: finally, a book about comonads? :)
13:34:52 <Cale> We haven't really even talked much about it yet.
13:35:02 <aristid> (i admit, that joke was very lame)
13:35:14 <roconnor> what is the subject?
13:35:24 * RayNbow wonders if Cale will be able to combine full time IRCing in #haskell and full time working on a book :p
13:35:40 <jmcarthur> RayNbow: no. we will miss him
13:35:42 <aristid> RayNbow: easy, he'll just copy the chatlogs and call it a book
13:35:46 <Cale> Functional programming in Haskell, but beyond that, we haven't really discussed with any level of clarity what we want to do :)
13:36:17 <jmcarthur> i want to see Cale and edwardk level of clarity
13:36:20 <jkingkong> what would be more impressive is a book called "Imperative Programming in Haskell" :D
13:36:30 <aristid> and don't forget to call monads "warm fluffy things" each time.
13:36:40 <Cale> There's a certain gap in the space of current Haskell books which I'm not sure how to express in words.
13:37:00 <jkingkong> "Imperative Impure Strict Programming in Haskell"
13:37:15 <jmcarthur> "Unsafe Programming in Haskell"
13:37:28 <jmcarthur> ... "With Dynamic Types"
13:37:49 <thetallguy1> I just looked for hasktags on my system and didn't find it.  Has it morphed into something else?
13:37:51 <pikhq> jkingkong: Not as impressive as you think. :)
13:37:54 <aristid> "Stringly typed"?
13:38:14 <pikhq> aristid: String typing is pretty easy to pull off in Haskell, really.
13:38:18 <jkingkong> "Imperative Impure Strict Programming in Haskell w/o use of the Foreign Function Interface" ?
13:38:26 <Cale> jmcarthur: haha, start from the very basics of programming, but use Data.Dynamic *everywhere*
13:38:30 <pikhq> Just a hell of a lot of read and show.
13:38:41 <aristid> jkingkong: the IO monad suffices totally
13:38:47 <jkingkong> haha true true
13:38:49 <pikhq> jkingkong: IO monad does it.
13:38:57 <jkingkong> so it'd be a boring book then
13:39:03 <roconnor> jkingkong: I gave a talk entitled "functional programming imperative"
13:39:03 <jmcarthur> i have never in my life even looked at Data.Dynamic
13:39:14 <jmcarthur> i'm going to do that now
13:39:20 <roconnor> no
13:39:23 <roconnor> don't look at it
13:39:24 <jkingkong> I actually just looked at it
13:39:26 <EvanR-work> lool
13:39:27 <Cale> It might be interesting to have a section or chapter on translating imperative programs into purely functional ones in a systematic way.
13:39:29 <jmcarthur> curiosity about this is getting the best of me
13:39:37 <roconnor> no
13:39:51 <thetallguy1> Look at generics, rather than Data.Dynamic
13:39:52 <jkingkong> is it worse than Data.HashMap?
13:40:06 <jmcarthur> yeah looks worse to me
13:40:30 <dpratt71> Cale: I agree that would be interesting
13:40:49 <jkingkong> cale: agreed
13:40:56 <jmcarthur> fromDynamic :: Typeable a => Dynamic -> Maybe a  -- horrible!
13:40:59 <monochrom> Just take a log of #haskell and look for Cale's lectures to compile a book.
13:41:02 <dpratt71> I find it very hard to explain to people how to go from one style to the other
13:41:11 <EvanR-work> forM [0..expr] $ \i -> forM [0..x] $ \j ->
13:41:18 <dpratt71> go back to the beginning and start over...
13:41:18 <jmcarthur> monochrom: i believe you are now the third person to say that in the last 10 minutes or so ;)
13:41:43 <aristid> jmcarthur: was i the second or the first?
13:41:43 <dpratt71> jmcarthur: well, I thought it; does that count?
13:41:44 <c_wraith> adding immutability to an algorithm isn't hard.  The real challenge is changing how you break code down to make use of custom combinators.
13:41:51 <jkingkong> dpratt71: the "=" symbol in imperative languages throws off everybody's intuition it seems
13:41:55 <jmcarthur> oh my... dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
13:42:01 <jmcarthur> aristid: i said it before you did. you were second
13:42:06 <aristid> :(
13:42:10 <monochrom> We just need to wait for Cale to die, then we will compile "the complete works of Cale". <duck>
13:42:18 <EvanR-work> = -> writeIORef
13:42:30 <dpratt71> jkingkong: indeed; my explanation is that '=' defines a function. period.
13:42:37 <jmcarthur> ah! the worst! dynApp :: Dynamic -> Dynamic -> Dynamic
13:42:47 <babusri> quit
13:42:51 <jmcarthur> dynApp is the most horrifying function i have ever seen in haskell
13:42:52 <dpratt71> I know that's not technically correct, but the intuition is correct, I think
13:42:53 <roconnor> gah
13:42:53 <Cale> dpratt71, jkingkong: The basic trick of it is to take each statement in the imperative program, and initially turn it into a function. Local variables become function parameters, and you represent control flow by just having the functions call each other recursively.
13:42:55 <c_wraith> dpratt71: I'd say it defines a name, rather than a function. let x = 5 in....
13:42:57 <jkingkong> jmcarthur: I confess, I looked at it for less than 4 minutes and gave up
13:43:41 <Cale> dpratt71, jkingkong: once you've done that, you can start to simplify things into a more reasonable form.
13:43:45 <aristid> Cale: and initially use IO everyhwere?
13:43:57 <Cale> no, not necessarily any IO
13:44:10 <jkingkong> c_wraith, dpratt71: I compare it to the "=" symbol in math. If x is equal to something at one point, it's equal to that same thing always.
13:44:11 <dpratt71> c_wraith: I know what you mean, but I'm talking about the intuition; once I though of x = 5 equating to "int x() { return 5; }" things went more smoothly
13:44:13 <jmcarthur> start with a BASIC DSL
13:44:20 <EvanR-work> a lot of 'function calls' in imperative are 'execute io action' commands
13:44:26 <jkingkong> cale: interesting
13:44:29 <Cale> I'm thinking of a pure imperative program which takes some parameters and uses some local state to compute some result
13:45:05 <jmcarthur> i think a fair comparison of OO and functional design might be nice to see in some detail
13:45:06 <Cale> You could also represent I/O crudely by just taking a list consisting of the input as a parameter, and producing a list of output
13:45:13 <Cale> (lazily :)
13:45:25 <aristid> Cale: didn't early haskell programs do that?
13:45:30 <aristid> or is that an urban legend?
13:45:33 <Cale> aristid: Something like that
13:45:37 <EvanR-work> jmcarthur: oo like in 'theory of objects' ?
13:46:00 <Cale> aristid: You can look at the early Haskell specs to see what they did.
13:46:22 <aristid> Cale: i wonder if in the future, IO will cease to be a monad and be something else instead
13:46:47 <roconnor> @wiki IO_Semantics
13:46:48 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
13:47:01 <pikhq_> aristid: If a better abstraction is discovered, then sure.
13:47:08 <EvanR-work> how can IO not be a monad?
13:47:34 <EvanR-work> isnt that like saying list is not a monoid
13:47:46 <EvanR-work> or, ceases to be
13:47:58 <iago> Lazy K does that
13:48:05 <monochrom> that's just semantics
13:48:07 <c_wraith> No, it's like saying "we change the way IO works in such a way that the monadic structure no longer applies"
13:48:17 <Cale> EvanR-work: Well, what he really means is that rather than describing our programs in terms of the IO monad, we'd use some other abstraction to describe the relationship between input and output
13:48:29 <EvanR-work> oh
13:48:52 <Cale> The IO monad will likely always potentially exist, in any language we choose to use.
13:48:53 <RayNbow> aristid, http://haskell.org/definition/haskell-report-1.2.ps.gz  <--  page 69
13:49:04 <EvanR-work> it seems like the most straightforward
13:49:18 <RayNbow> "...a Haskell program has the type:    type Dialogue = [Response] -> [Request]"
13:49:23 <Cale> But who knows, someday we might not use it as the core foundation for input and output.
13:49:48 <c_wraith> EvanR-work: maybe we just haven't found some "obvious" better abstraction.  It's hard to say what will be found in the future.
13:49:49 <EvanR-work> [Response] -> [Request] moves the job of doing IO outside the program basically, which ihave thought about
13:50:14 <EvanR-work> but i got the feeling the pure monadic IO thing was 'so that we can program IO in the language'
13:50:26 <p_l> RayNbow: that looks like the very old I/O support
13:50:27 <c_wraith> executing IO actions is outside the scope of haskell programs, too.  if you ignore unsafePerformIO
13:50:28 <Cale> Another possibility is to describe the input to the program as a bunch of abstract Behaviour and Event values, a la FRP.
13:50:36 <roconnor> EvanR-work: rumour has it that old IO methods was very hard to program in
13:50:40 <Cale> and same goes for the output
13:51:14 <roconnor> EvanR-work: you'd misalling your input and output streams so you'd be waiting for input before the prompt, or worse, be trying to output before reading the input.
13:51:16 <RayNbow> p_l: that's because monadic I/O was introduced in 1.3
13:51:20 <roconnor> misalign
13:51:22 <p_l> roconnor: I had trouble with modern haskell. Future-based I/O of old was impossible
13:51:39 <EvanR-work> roconnor: doesnt seem very intuitive
13:51:43 <aristid> p_l: shouldn't it be possible to transform one into the other?
13:51:46 <RayNbow> so I had to find an older version of Haskell :p
13:51:47 <EvanR-work> for non trivial programs
13:52:29 <aristid> i guess the fact that each system call was in a big data was also a bit of a problem
13:53:18 <EvanR-work> another thing is that whatever nice event based model we come up with can probably be implemented as a layer on top of normal IO, you could call it 'BetterIO' or something. but removing the middle layer doesnt sound smart
13:53:38 <EvanR-work> you could also call it 'GTK+'
13:53:45 <Cale> You could possibly remove the middle layer, and then implement existing IO in terms of it.
13:54:11 <aristid> newMain = translateIO main
13:55:23 <EvanR-work> Cale: it would have to been *really* nice. i mean, the point of a layer is so you can try different top layers withotu rewriting the runtime system
13:56:08 <EvanR-work> so unless its really nice you could just do this new thing as a library
13:57:35 <dpratt71> I remember some time ago someone describing a scenario that the current IO implementation couldn't handle as a consequence of how it was implemented; it was interesting, but I can't remember the details
13:58:02 <aristid> EvanR-work: maybe one problem that would be very attractive to address is the fact that IO is extremely monolithic
13:58:31 <EvanR-work> so break it up into more layers
13:59:52 <dpratt71> I think the scenario may have involved lazily enumerating directories while also lazily reading files
14:00:24 <EvanR-work> aristid: i think i get what you are saying about monolithic, but im not sure why it is bad
14:01:25 <aristid> EvanR-work: as long as we don't know a better alternative, it's hard to argue in any way
14:01:56 <hellidunno> cool MrN
14:02:40 <aristid> hellidunno: ?
14:02:46 <hellidunno> ach nix
14:02:47 <hellidunno> cya
14:02:56 <EvanR-work> seems like the wisdom so far has been to avoid IO at all costs, isolate it and post police tape around it because its volatile and most likely written in an ugly way. but then again, you can set up a situation in 'pure' code that is just as bad
14:03:19 <EvanR-work> except for the random errors
14:03:26 <c_wraith> dcoutts: ping
14:04:34 <EvanR-work> so maybe one can define portions of 'sort of IO' code that is nicer than raw IO and its safer or more functional
14:05:00 <arw> the more i use it, the more i like hoogle. its just like typing "i need a function that does x", only more precise...
14:05:07 <nominolo> preflex: seen byorgey
14:05:07 <preflex>  byorgey was last seen on #haskell 1 hour, 30 minutes and 50 seconds ago, saying: we will try to plan things much further in advance next year I think
14:06:42 <nominolo> preflex: seen jmcarthur
14:06:42 <preflex>  jmcarthur was last seen on #haskell 21 minutes and 37 seconds ago, saying: i think a fair comparison of OO and functional design might be nice to see in some detail
14:06:50 <dcoutts> c_wraith: pong
14:09:39 <jmcarthur> nominolo: yes?
14:10:32 <c_wraith> dcoutts: we're seeing an interesting issue with cabal.  This isn't really a bug, just suboptimal behavior...  the build-depends table in a cabal file has a sort of muddled meaning.  It's intended to be "things to tell the compiler to make visible", but it's also used by cabal install for recursive dependency installation.  The problem is when doing the latter, it can choose versions you don't want, and that tempts one to add the version of those packa
14:10:32 <c_wraith> ges that you do want to the build-depends block also.  Even when that makes no sense at all.   I'm not sure what the exact issue is, or what the solution should be, but it feels like a point where there's more confusion than necessary.
14:11:20 <dcoutts> c_wraith: I'm not quite sure what you mean
14:11:34 <dcoutts> about it choosing versions you don't want
14:11:57 <dcoutts> c_wraith: you can constrain the versions that the package is known to work with
14:12:14 <dcoutts> I'm not sure I get your point about a double meaning
14:12:19 <c_wraith> dcoutts: it's usually a side effect of a package we depend on having an overly-permissive package description.
14:12:51 <dcoutts> c_wraith: what is exactly?
14:13:10 <c_wraith> dcoutts: there are about a million things in this file, let me find a much smaller example.
14:14:16 <nominolo> jmcarthur: you were asking how efficient an interpreter for core could be
14:14:23 <jmcarthur> ah, yes?
14:14:52 <nominolo> jmcarthur: I've been looking into the implementation of the LuaJIT bytecode interpreter
14:15:21 <nominolo> it's written in assembly, but doesn't generaty any code
14:15:28 <nominolo> so it's still a pure interpeter
14:15:47 <nominolo> anyway, i made a small benchmark and compared it to hand-written assembly
14:16:03 <nominolo> the interpreted code was only 7.2x slower than the machine code
14:16:10 <jmcarthur> ah not bad
14:16:25 <nominolo> and an interpreter instruction takes 4-5 clocks on average
14:16:41 <aristid> nominolo: no jit?
14:16:43 <siracusa> dcoutts: Hi! Have you built a recent version of gtk2hs on a Windows system and tested it in GHCi, coincidentally?
14:16:48 <nominolo> this is for simple instructions like add and sub
14:17:04 <dcoutts> siracusa: not recently
14:17:04 <jmcarthur> yeah funny that LuaJIT wouldn't have JIT...
14:17:04 <nominolo> aristid: LuaJIT also has a jit, but it has to start by interpreting
14:17:05 <c_wraith> dcoutts: maybe I should just put together an email about this.  if I send it to -cafe, will you see it?
14:17:19 <dcoutts> c_wraith: perhaps cc me directly
14:17:28 <c_wraith> dcoutts: ok.
14:17:28 <aristid> nominolo: oh i overread the luajit part
14:17:34 <jmcarthur> ah
14:17:38 <copumpkin> omg
14:17:48 <nominolo> aristid: every JIT needs both some sort of interpreter (or simple but fast compiler)
14:17:56 <nominolo> and the actual JIT
14:18:13 <aristid> nominolo: for benchmarks it might happen that the jit does kick in
14:18:14 <copumpkin> we need edwardk's magic JIT for haskell
14:18:15 <nominolo> otherwise start-up cost is really bad
14:18:28 <jmcarthur> edwardk has magic JIT?
14:18:28 <pikhq_> nominolo: Or just making the JIT fast enough that you can compile everything. :P
14:19:04 <aristid> or just compile the code that actually is executed
14:19:19 <nominolo> a lot of code is executed only once or a few times
14:19:27 <nominolo> you don't want to compile that
14:19:59 <nominolo> the point of starting off with an interpreter is to collect some data about the program, so you can speculatively optimise the generated code
14:20:29 <aristid> nominolo: it depends on the speed of compilation
14:20:36 <nominolo> the point of a JIT (at least for statically typed languages) is to optimise across package boundaries or function call boundaries
14:20:54 <nominolo> aristid: yes, but it's hard to get below 100 cycles / instruction
14:21:05 <nominolo> it's usually more
14:21:12 <pikhq_> nominolo: The point of a JIT is to be faster than an interpreter.
14:21:17 <nominolo> (depending on what kind of JIT you're using)
14:21:19 <marcot> Hi.  I'm trying to disable warnings in the build of a package (criterion) which has -Wall in ghc-options in .cabal.
14:21:19 <pikhq_> Everything else is a side benefit.
14:21:43 <marcot> So I'm using --ghc-options='-w' in configure and build Cabal commands.
14:21:50 <marcot> But the warnings are still being shown.
14:22:09 <nominolo> pikhq_: well, maybe
14:22:15 <ezyang> Whoa. Polymorphic functions are natural transformations.
14:22:24 <ezyang> \o/
14:22:29 <dcoutts> marcot: I think in cabal head we switched the order of user flags, so that they go last and override flags from the .cabal file
14:22:41 <nominolo> jmcarthur: anyway, why were you interested in an interpreter for core?
14:22:45 <aristid> ezyang: i guess that's important or something :)
14:22:57 <copumpkin> ezyang: if you stick implicit Identities on pure polymorphic types, at least :)
14:23:27 <copumpkin> :t listToMaybe
14:23:28 <lambdabot> forall a. [a] -> Maybe a
14:23:31 <copumpkin> omg
14:23:56 <copumpkin> @free lifttoMaybe :: [a] -> Maybe a
14:23:57 <lambdabot> $map_Maybe f . lifttoMaybe = lifttoMaybe . $map f
14:24:06 <copumpkin> *list
14:25:13 <ezyang> what's with the dollar signs?
14:25:52 <c_wraith> haskell is all about the $
14:25:53 <nominolo> pikhq_: my thesis is that a JIT can actually beat statically compiled code (even though it has to start off by interpreting stuff)
14:26:25 <copumpkin> nominolo: have you spoken to edwardk about his magic JIT?
14:26:41 <nominolo> copumpkin: yup.  i'm working on a different approach, though
14:26:55 <copumpkin> ah, what's yours?
14:27:02 <copumpkin> you'd have an actual bytecode?
14:27:05 <EvanR-work> dynamic recompilation + dynamic reconfiguration of the cpu ++ ;)
14:27:07 <copumpkin> :P
14:27:35 <nominolo> copumpkin: bytecode yes.  but I'm currently trying to figure out the right machine model
14:27:54 <copumpkin> you mean register vs. stack? or how?
14:27:57 <marcot> dcoutts: So currently the only way to build without warnings is patching the .cabal file?
14:28:10 <nominolo> copumpkin: no GRIN vs. STG or a mix thereof
14:28:14 <copumpkin> oh ok :)
14:28:41 <dcoutts> marcot: sounds like it
14:28:42 <nominolo> GRIN maps quite nicely to bytecode
14:29:30 <copumpkin> are any projects aside from LHC using GRIN?
14:29:51 <nominolo> but current GRIN-based compilers assume whole-program optimisations, I don't want that
14:29:54 <nominolo> UHC
14:29:55 <nominolo> and JHC
14:29:59 <copumpkin> oh
14:30:08 <pikhq_> nominolo: In many cases, yes, a JIT can beat a static compiler.
14:30:19 <systemfault> In theory..
14:30:30 <systemfault> In the real world, it never happens.
14:30:32 <marcot> dcoutts: Ok, thanks.
14:30:55 <pikhq_> systemfault: Ever compared Hotspot and GCJ?
14:30:57 <ezyang> systemfault: I thought the JVM could beat static compilers if you disregarded the warmup time?
14:31:04 <pikhq_> Hotspot kicks GCJ's ass.
14:31:15 <systemfault> pikhq_: GCJ isn't a good example imho..
14:31:40 <pikhq_> It's the only static compiler for Java though.
14:31:43 <pikhq_> :P
14:31:44 <nominolo> systemfault: google for "Dynamo: A Transparent Dynamic Optimization System"
14:31:45 <systemfault> Yeah :/
14:31:50 <systemfault> nominolo: I will :)
14:32:25 <jmcarthur> http://intoverflow.wordpress.com/2010/05/21/announcing-potential-x86-64-assembler-as-a-haskell-edsl/ looks awesome
14:32:34 <nominolo> systemfault: this transparently optimised HPPA RISC *binaries* and managed to get a speedup (~5%) in many cases
14:32:57 <Ke> anyways jit will be even more relevant if x86 keeps diverging and binary programs need to support all flavours
14:33:16 <nominolo> systemfault: it does not map nicely to x86, though, because it's much harder to interpret x86 efficiently
14:35:43 <marcot> I just noticed that there's a flag in criterion.cabal that should make it not show the do-bind warnings, but it's still showing:
14:35:49 <nominolo> so, designing a fast JIT is certainly Hard (tm).  So it pays off more easily for dynamically typed languages, or if your reference is a naively implemented interpreter
14:35:51 <marcot> http://hackage.haskell.org/packages/archive/criterion/0.5.0.0/criterion.cabal
14:36:12 <marcot> I'm using ghc 6.12.1, so if impl(ghc >= 6.12) should be true.
14:36:14 <arjanb> nominolo: you can use GRIN without whole program optimisations if you take the eval and apply functions as builtin primitives
14:36:22 <nominolo> arjanb: right
14:36:28 <nominolo> that's exactly what I'm doing
14:36:34 <marcot> Is there something wrong on criterion.cabal's syntax?
14:36:49 <dcoutts> marcot: that might be the bug about the order getting reversed, you can check if you run cabal build with -v
14:40:29 <marcot> dcoutts: Yes, that's the problem.  It's putting the -fno-warn-unused-do-bind before -Wall, even with the if after the first assignment to ghc-options.
14:40:44 <marcot> dcoutts: Changing the order in .cabal doesn't make it better.
14:42:10 <nominolo> is it sorting the flags?
14:43:49 <dcoutts> nominolo: we've not tracked it down yet, I suspect it's in the GenericPackageDescription -> PackageDescription bit
14:44:00 <dcoutts> or possibly in the parser, it should be easy enough to check
14:44:02 <nominolo> ah, my fault then
14:44:16 <dcoutts> nominolo: I didn't that that :-)
14:44:23 <dcoutts> that/say
14:44:27 <nominolo> :)
14:47:14 <triyo> I wish to use the drawTree of Data.Tree module. signature is: drawTree :: Tree String -> String
14:48:05 <marcot> bos: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25629
14:48:05 <triyo> I have a Tree Task instead of Tree String
14:48:22 <marcot> bos: This would workaround the bug in current cabal.
14:48:29 <ddarius> fmap :: (Task -> String) -> Tree Task -> Tree String
14:48:50 <triyo> ddarius
14:49:08 <triyo> ahh functor of course..
14:49:12 <triyo> :)
14:52:29 <sm> ohh, I'm looking forward to multiple .cabal files in the same directory
14:52:46 <dcoutts> sm: what for ooi?
14:53:00 <sm> dcoutts: so I can re-unify my fragmented source tree
14:53:15 <dcoutts> sm: using subdirs is too annoying?
14:53:27 <sm> I split hledger up into packages.. now I'm symlinking all over trying to get ghci working again
14:53:35 <sm> yes it's harder when developing
14:55:18 <ezyang> there should be a cabal ghci
14:55:33 <dcoutts> there's a ticket for that too
14:55:35 <sm> code which belongs close together in the module space, is far apart in filesystem space.. especially as you go deeper (Hledger.Cli.Commands...)
14:55:39 <dcoutts> it should not be too hard
14:58:28 <pao> how do I "show" an Int to a ByteString?
14:58:28 <lambdabot> pao: You have 1 new message. '/msg lambdabot @messages' to read it.
14:58:37 <pao> @messages
14:58:37 <lambdabot> paulp said 6d 7h 44m 39s ago: the common ancestor of Array and ArrayBuffer is indeed AnyRef, so it told you, but you couldn't hear it.
14:58:41 <k23z__> is fmap the generalization of .  ?
14:59:18 <ezyang> Yes.
14:59:36 <ezyang> Specifically, (.) is an instance of fmap for the reader functor i.e. functions
14:59:57 <jmcarthur> fmap is one possible generalization of (.), yes
15:00:08 <maltem> > fmap (+1) (+2) 3
15:00:08 <lambdabot>   6
15:00:27 <jmcarthur> :t (<<<)  -- another
15:00:29 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:00:30 <pao> > Bytestring.pack . show $ 1
15:00:31 <lambdabot>   Not in scope: `Bytestring.pack'
15:00:45 <pao> > ByteString.pack . show $ 1
15:00:45 <lambdabot>   Not in scope: `ByteString.pack'
15:02:53 <aristid> @hoogle pack
15:02:54 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
15:02:54 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
15:02:54 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
15:03:02 <aristid> :t pack
15:03:03 <lambdabot> Not in scope: `pack'
15:03:13 <aristid> :t Data.ByteString.pack
15:03:14 <lambdabot> [Word8] -> BSC.ByteString
15:03:23 <aristid> > Data.ByteString.pack . show $ 1
15:03:24 <lambdabot>   Not in scope: `Data.ByteString.pack'
15:03:39 <aristid> *scratch head*
15:03:44 <mauke> that's a type error anyway
15:04:14 <aristid> :t Data.ByteString.Char8.pack
15:04:15 <lambdabot> String -> BSC.ByteString
15:10:01 <alexyk> I'm trying to run a main from ghci from RWH, which counts lines in a file.  I seem unable fto just say > main "filename", do I need to do it in IO monad somehow?
15:10:45 <Twey> alexyk: Of course — ‘main’ doesn't take any arguments.
15:10:46 <alexyk> main = interact wordCount where wordCount input = show (length (lines input)) ++ "\n" -- this one
15:11:09 <mauke> alexyk: uh, that main doesn't even use command line arguments
15:11:17 <jmcarthur> systemo reboot time
15:12:04 <k23z__> is LLVM a vm and is GHC built on it ?
15:12:04 <alexyk> that's from RWH!  it curries wordCount input doesn't it?  why can't I say main "blah" then?
15:12:24 <mauke> no, it doesn't
15:12:47 <mauke> you can't say main "blah" because main is not a function
15:12:49 <EvanR-work> main isnt allowed to have type something ->, i thought
15:13:01 <mauke> and if you could, your main would just ignore it
15:13:19 <alexyk> hmm, so main is a special word then here?
15:13:22 <jao> dcoutts_: what's the ticket for the "cabal ghci"?
15:13:24 <mauke> alexyk: no
15:13:53 <dcoutts> jao: http://hackage.haskell.org/trac/hackage/ticket/382
15:14:04 <jao> dcoutts: thanks!
15:15:15 <EvanR-work> main :: IO ()
15:15:17 <alexyk> renaming main to countLines doesn't work either in ghci
15:15:31 <mauke> what
15:15:46 <mauke> alexyk: YOU CAN'T PASS ARGUMENTS TO SOMETHING THAT IS NOT A FUNCTION
15:15:55 * jao was thinking more along the lines of an interactive mode for cabal
15:16:37 <pikhq> alexyk: "main" is not a function, it is a value of type "IO a".
15:16:55 <aavogt> @src IO
15:16:56 <lambdabot> Source not found. Where did you learn to type?
15:16:59 <mauke> IO () in this case
15:17:23 <pikhq> mauke: Not necessarily; main can be of any type matching IO a, IIRC.
15:17:42 <mauke> which part of 'in this case' is unclear?
15:18:00 <pikhq> The part where it was indicated what type main was.
15:18:06 <pikhq> Rather than merely asserted.
15:18:18 <pikhq> Anyways; this is all just pedantry, and not really relevant.
15:18:23 <mauke> uh, we have the source of main
15:18:25 <mauke> we know its type
15:18:44 <pikhq> We do? Didn't realise.
15:18:48 <pikhq> Oh. Sure enough.
15:19:01 <pikhq> main = interact wordCount where wordCount input = show (length (lines input)) ++ "\n"
15:19:17 <pikhq> alexyk: Anyways. main is not a function, so you cannot pass arguments to it.
15:19:26 <alexyk> okok
15:19:40 <mauke> :t interact
15:19:41 <lambdabot> (String -> String) -> IO ()
15:19:48 <mauke> pass function to interact, receive IO ()
15:19:49 <alexyk> I missed the type of interact
15:19:56 <pikhq> What's more, your main there does not have "getArgs" in it, so it can't get any *command line* arguments when executed.
15:20:25 <pikhq> What you have written is a program that does something to stdin and outputs to stdout.
15:20:57 <alexyk> pikhq: that's straight from RWH :)
15:21:11 <pikhq> Yes.
15:31:08 <mreh_> has anyone configured apache to serve up their haddocks?
15:31:54 <mreh> seems like a neat idea, maybe I could run my own hackageDB
15:32:27 <glguy> mreh: Why not just browse them out of your own filesystem?
15:33:03 <mreh> glguy: well I tend to work out of the browser
15:34:37 <mreh> oh, you can
15:51:27 <sm> hmm.. so by default when profiling there is one CAF per module.. is there a trick to show those module names ?
15:51:50 <sm> define an overall SCC annotation in each module perhaps ?
15:52:34 <sm> if "CAF" was a module name by default, I think profiles would be a whole lot clearer
15:53:07 <sm> soon I will love the profile, not fear it..
15:54:18 <sm> ho! wait now.. I'm looking at my "simplified" profile output.. the original has a module column
15:54:36 <monochrom> cool
15:54:51 <sm> I think my idea works though, then that column could be dropped
15:55:49 <sm> no.. no
15:56:14 * sm learns to read the thing as-is
15:56:41 <sm> it's just a drag when wide names break the column alignment
15:59:56 <interferon> is there a function "group :: Int -> [a] -> [[a]]" s.t. for example group 2 [1, 2, 3, 4]  => [[1, 2], [3, 4]] ?
16:00:22 <copumpkin> we get this question once a day
16:01:27 <copumpkin> > (unfoldr . ap ((>>) . guard . not . null) . (pure .) . splitAt) 2 [1,2,3,4]
16:01:29 <lambdabot>   [[1,2],[3,4]]
16:01:35 <copumpkin> ;)
16:01:37 <copumpkin> @hackage split
16:01:38 <lambdabot> http://hackage.haskell.org/package/split
16:07:13 <sm> my profile shows a lot of entries for unidentified items in the Types module, which contains only type declarations
16:07:21 <interferon> copumpkin: that is a ridiculous expression!
16:07:31 <sm> is a data declaration a CAF ? I can't seem to annotate one with SCC
16:07:33 <interferon> ,chunk 3 [1,2, 3]
16:07:57 <interferon> Data.List.Split.chunk
16:08:29 <interferon> copumpkin: thanks!
16:09:12 <kmc> data declarations aren't expressions
16:09:19 <kmc> so i don't think they count as CAFs
16:09:48 <kmc> though it might be nice for example to aggregate all the work done as a result of strictness annotations on a data decl
16:09:53 <kmc> but i don't know a way to do it
16:10:53 <sm> hmm, then I don't understand why this module has entries..
16:11:01 <sm> 100% in fact
16:12:32 <sm> ahh.. it imports other code of course
16:12:35 <sm> thanks kmc
16:12:39 <ehamberg> is there a good way to sort a Data.Map by value and not key? do i need to convert it to a regular list of tuples?
16:12:58 <kmc> :t M.fromList . map (\(x,y) -> (y,x)) . M.toList
16:12:59 <lambdabot> forall k a. (Ord k) => M.Map a k -> M.Map k a
16:13:10 * sm thinks but shouldn't that module be listed then.. ?
16:20:08 <k23z__> can foldr/foldl take as parameter a function eating more than 2 parameters ?
16:20:10 <k23z__> like maybe 3 ?
16:20:57 <kmc> :t foldr
16:20:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:21:19 <k23z__> seems not
16:21:26 <kmc> k23z__, sort of.  if b is (c -> d)
16:21:40 <kmc> :t foldr :: (a -> (c -> d) -> c -> d) -> (c -> d) -> [a] -> c -> d
16:21:41 <lambdabot> forall a c d. (a -> (c -> d) -> c -> d) -> (c -> d) -> [a] -> c -> d
16:22:01 <aristid> kmc: holy shit, can you make an example for that? :D
16:22:03 <kmc> k23z__, also, you can of course use a tuple type for a and/or b
16:22:20 <aristid> :t curry
16:22:22 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:22:29 <aristid> :t uncurry
16:22:31 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:22:36 <kmc> :t foldr (\x f -> (x:).f)
16:22:36 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> [a] -> f [a]
16:22:37 <aristid> :t foldr . uncurry
16:22:38 <lambdabot> forall b a b1. (a -> b1 -> b -> b) -> b -> [(a, b1)] -> b
16:22:42 <kmc> :t foldr (\x f -> (x:).f) id
16:22:42 <lambdabot> forall a. [a] -> [a] -> [a]
16:22:47 <kmc> :t foldr (\x f -> (x:).f) id [] "abcd"
16:22:47 <lambdabot> [Char]
16:22:51 <c_wraith> wait, haskell reddit got a new logo?  when did that happen?
16:22:56 <kmc> (\x f -> (x:).f)
16:23:00 <kmc> :t (\x f -> (x:).f)
16:23:00 <aristid> :t foldr 1. uncurry
16:23:01 <lambdabot> forall a (f :: * -> *). (Functor f) => a -> f [a] -> f [a]
16:23:01 <lambdabot> forall a a1 b c. (Num c) => (a1 -> b -> c) -> [a] -> (a1, b) -> c
16:23:05 <aristid> :t foldr1 . uncurry
16:23:06 <lambdabot> forall a b. (a -> b -> (a, b) -> (a, b)) -> [(a, b)] -> (a, b)
16:23:29 <Cale> > foldr (\x xs -> xs . const x) id [1,2,3] (error "last: empty list")
16:23:30 <lambdabot>   3
16:23:33 <Cale> > foldr (\x xs -> xs . const x) id [] (error "last: empty list")
16:23:33 <aristid> :t foldr . uncurry . (,)
16:23:34 <lambdabot>   *Exception: last: empty list
16:23:34 <lambdabot>     Couldn't match expected type `b1 -> b -> b'
16:23:35 <lambdabot>            against inferred type `(a1, a)'
16:23:35 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
16:26:59 <Cale> > let foldl f z xs = foldr (\x g r -> g (f r x)) id xs z in foldl f z [1,2,3]
16:27:00 <lambdabot>   f (f (f z 1) 2) 3
16:27:58 <Cale> aristid: ^^ how's that for an example? :)
16:28:40 <aristid> Cale: uh :)
16:29:17 <aristid> > f 1
16:29:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:29:18 <lambdabot>    `SimpleReflect.FromExpr ...
16:29:31 <aristid> > f 1 1
16:29:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:29:32 <lambdabot>    `SimpleReflect.FromExpr ...
16:29:35 <aristid> oO
16:29:36 <Cale> hmm
16:29:39 <Cale> > f 1 :: Expr
16:29:40 <lambdabot>   f 1
16:29:44 <aristid> :t f
16:29:45 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:29:50 <aristid> :t f 1
16:29:51 <lambdabot> forall t t1. (Num t, SimpleReflect.FromExpr (t -> t1)) => t1
16:32:58 <danharaj> Is Okasaki's Purely Functional Data Structures good as an instructional book or as a reference? (either/or)
16:33:35 <c_wraith> it's a fascinating read, but the structures are all implemented in haskell already.
16:33:53 <c_wraith> I'm not sure how much you'll get out of it as an instructional book.
16:34:02 <c_wraith> If you're not sure either, start with his thesis paper.
16:34:09 <c_wraith> It has a bit less content, but it's free :)
16:34:42 <danharaj> I'd have to print it out :p I've realized I can't read off computer screens and expect to remember anything.
16:37:59 * ddarius doesn't see how the display medium has that effect...
16:40:35 <copumpkin> what if the medium were a large backlit billboard on the side of a building, with a dying fluorescent backlight that flickered on and off at irregular intervals?
16:48:27 <nlogax> dons: found a little typo here: http://hackage.haskell.org/packages/archive/json/0.3.3/doc/html/src/Text-JSON-String.html#line-259
16:52:33 <sm> ayayay.. I have two types defined in terms of each other, and deriving Eq. Testing for equality is an infinite recursion - http://gist.github.com/409580
16:52:48 <sm> is that usual ?
16:54:04 <sm> and are mutually-recursive types just generally a bad idea in real-world apps ?
16:55:39 <monochrom> No.
16:55:43 <jmcarthur> there's nothing wrong with it
16:56:44 <sepp2k> sm: If the values you check for equality are cyclic, it's normal that you get infinite recursion. Otherwise it's not.
16:56:57 <sm> so you should never derive Eq on all of a mutually-defined group of types
16:57:07 <monochrom> wrong.
16:59:29 <sm> ok, I don't know why that's wrong. But forget deriving - how can I define an equality test for a type which is mutually defined with another type ? is it possible ?
17:00:43 <c_wraith> unless the data structure is infinitely deep, it should be fine.
17:00:52 <monochrom> data Things = None | More Multi deriving Eq
17:00:57 <monochrom> data Multi = Multi Bool Things deriving Eq
17:01:03 <monochrom> b = More (Multi True None) == More (Multi True None)
17:01:11 <monochrom> b does not loop. works.
17:01:23 <c_wraith> I mean...
17:01:35 <c_wraith> > let ones = 1:ones in ones == ones
17:01:39 <lambdabot>   mueval-core: Time limit exceeded
17:01:40 <monochrom> PEBKAC
17:01:49 <c_wraith> that will run forever, and it's not mutually recursive
17:01:51 <dancor> @src sequence
17:01:51 <lambdabot> sequence []     = return []
17:01:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:01:52 <lambdabot> --OR
17:01:52 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:01:53 <c_wraith> it's just infinite
17:02:11 <danharaj> Bisimulation
17:02:19 <danharaj> works for some infinite data.
17:02:45 <monochrom> But perhaps it's a bad idea to be intellectual and rational in real-world apps.
17:03:04 <monochrom> Always blame the language in the real world.
17:04:38 <monochrom> It is the only way to justify blogging your clever tricks to "work around" language/library "limitations" so you gain reputation.
17:05:05 <monochrom> i.e., "this blog fills a much needed gap"
17:06:08 <sm> monochrom, thanks for the example. It seems my two types are somehow not bottoming out in the equality test
17:06:28 <monochrom> PEBKAC
17:06:37 <sm> yes, thank you :)
17:07:29 <monochrom> People have too much self-confidence and lack self-doubt.
17:11:51 * hackagebot HStringTemplate 0.6.3 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.3 (SterlingClover)
17:12:40 <sm> gaah..
17:13:28 <monochrom> For CDN$10000 I offer to debug your code.
17:21:49 <Apocalisp> Is it universally true that any function over a datastructure can be implemented in terms of the catamorphism?
17:22:20 <copumpkin> catamorphism over that datastructure?
17:22:22 <Apocalisp> yeah
17:22:26 <copumpkin> I don't think so
17:22:40 <Apocalisp> can you think of a case where it can't?
17:22:43 <copumpkin> what if you want an iterative algorithm to reach a fixed point?
17:23:34 <danharaj> It is difficult to even define catamorphism for some complicated data structures.
17:23:36 <copumpkin> it seems like a catamorphism only looks at each constructor once (unless you've tied a knot, but then you have more trouble)
17:23:45 <copumpkin> danharaj: like what? it's fairly mechanical, I thought
17:24:19 <Apocalisp> yeah, defining a fold for any polynomial type is totally mechanical
17:24:51 <danharaj> Very few data structures are polynomial.
17:25:02 <danharaj> Sure, most of the familiar ones are, but there are some useful ones that arent'.
17:25:35 <Apocalisp> fair enough, so let's restrict the question to polynomial types
17:26:46 <danharaj> Still not. Take the natural numbers, not every even primitive recursive function is a catamorphism.
17:27:14 <Saizan> Apocalisp: iirc you can't write zip as a catamorphism, assuming you don't also use some other form of recursion
17:27:16 <danharaj> Every recursive function, iirc, can be represented as a hylomorphism, though IIRC
17:27:58 <danharaj> but I am not a reliable witness.
17:28:13 <Apocalisp> yeah, that sounds right
17:28:52 <Apocalisp> I'm writing generic folds and being torn between two ways of handling the recursive case
17:28:56 <Apocalisp> @type foldr
17:28:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:29:04 <ddarius> danharaj: That's correct.  You can implement fix pretty easily using hylos.
17:29:31 <Apocalisp> why not (a -> [a] -> b) -> b -> [a] -> b ?
17:30:14 <danharaj> ddarius: I didn't think about it too deeply, but I guessed that you could think of mu (as in mu recursive function) as an apomorphism and stopped thinking about it.
17:30:53 <Saizan> Apocalisp: (a -> [a] -> b -> b) -> b -> [a] -> b would be the paramorphism, which is in fact enough to get general recursion, so it should be expressive enough
17:31:10 <Apocalisp> yeah, that
17:31:10 <copumpkin> now a challenge for y'all
17:31:18 <copumpkin> write zip as a zygohistomorphic prepromorphism
17:31:25 <Apocalisp> hahaha!
17:31:48 <danharaj> I am intrigued by Hagino's work and I can't wait to get time to really read his paper in depth. So much to do this summer.
17:35:10 <Apocalisp> arright, paramorphisms it is
17:35:20 <Apocalisp> thanks Saizan
17:35:44 <ddarius> Saizan: Paramorphisms don't give you general recursion.
17:35:55 <ddarius> Saizan: You can define paramorphisms with catamorphisms.
17:36:25 <danharaj> If catamorphisms are like induction, wouldn't paramorphisms be like strong induction?
17:36:49 <Saizan> ddarius: i was thinking about that
17:37:14 <Apocalisp> hrm
17:37:22 <ddarius> I believe primitive recursion is more directly represented by paramorphisms but they are of equivalent power to catamorphisms.
17:38:13 <danharaj> Right. I'm just wondering if there's some sort of curry-howard isomorphism kind of thing relating (blahblah)-morphisms to proof techniques.
17:38:19 <Apocalisp> @type \f z xs -> if null xs z else f (head xs) (tail xs)
17:38:21 <lambdabot> parse error on input `else'
17:38:30 <Apocalisp> @type \f z xs -> if (null xs) z else f (head xs) (tail xs)
17:38:31 <lambdabot> parse error on input `else'
17:38:45 <mauke> this is not C
17:38:54 <Apocalisp> @type \f z xs -> if null xs then z else f (head xs) (tail xs)
17:38:55 <lambdabot> forall t a. (a -> [a] -> t) -> t -> [a] -> t
17:38:57 <Apocalisp> ugh
17:39:05 <Apocalisp> too much Scala
17:39:06 <Saizan> ?type let para f z xs = foldr (\a (as,b) -> f a (a:as) b) ([],z) xs in para
17:39:07 <mauke> needs more pattern matching
17:39:07 <lambdabot> forall a t. (a -> [a] -> t -> ([a], t)) -> t -> [a] -> ([a], t)
17:40:40 <Apocalisp> @type let wossname f z [] = z; wossname f z (x:xs) = f x xs in wossname
17:40:41 <lambdabot> forall t t1. (t -> [t] -> t1) -> t1 -> [t] -> t1
17:41:12 <Saizan> that's just "case"
17:41:32 <Saizan> i wonder where i got the idea para ~~ fix
17:41:32 <mauke> Apocalisp: too redundant
17:42:10 <mauke> :t \f z xs -> case xs of [] -> z; y : ys -> f y ys
17:42:11 <lambdabot> forall t t1. (t1 -> [t1] -> t) -> t -> [t1] -> t
17:42:12 <ddarius> danharaj: There is.
17:42:42 <Apocalisp> ok, so I want to implement case in a language that hasn't it
17:43:19 <Apocalisp> (this is for an embedded language)
17:43:44 <copumpkin> :t foldr
17:43:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:44:14 <ddarius> danharaj: Catamorphisms and guarded recursion in general correspond to induction.  Anamorphisms and guarded corecursion to coinduction.
17:45:38 <Apocalisp> @type let w f z [] = z; w f z (x:xs) = f x xs; ow xs = w ((Just .) . (,)) Nothing xs in ow
17:45:39 <lambdabot> forall t. [t] -> Maybe (t, [t])
17:52:53 <Apocalisp> @type let w [] = Left []; w f z (x:xs) = Right (x, xs) in w
17:52:54 <lambdabot>     Equations for `w' have different numbers of arguments
17:52:55 <lambdabot>       <interactive>:1:4-17
17:52:55 <lambdabot>       <interactive>:1:20-47
17:53:00 <Apocalisp> @type let w [] = Left []; w (x:xs) = Right (x, xs) in w
17:53:01 <lambdabot> forall t a. [t] -> Either [a] (t, [t])
17:54:16 <mauke> did you mean: [t] -> Maybe (t, [t])
17:54:50 <Apocalisp> that too
17:55:38 <Apocalisp> @type let w [] = Left (); w (x:xs) = Right (x, xs) in w
17:55:38 <mauke> [t] = fix (Maybe . (t ,))
17:55:39 <lambdabot> forall t. [t] -> Either () (t, [t])
17:58:02 <ezyang> Are GHC's list fusions the same as the fusion laws described by Meijer/Fokkinga/Paterson in "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"?
17:58:35 <ddarius> ezyang: Not quite.
17:58:42 <ezyang> Hm.
17:58:43 <ddarius> @google short-cut deforestation
17:58:44 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646
17:58:56 <ezyang> Bah, Citeseer is down
17:59:33 <ezyang> So is there any relationship?
18:01:39 <Cale> Walter Rudin apparently died yesterday.
18:01:50 * wli also noticed
18:02:47 <ddarius> ezyang: Yes, they are intimately related.  Shortcut deforestation is just a little easier to apply.
18:03:24 <ddarius> ezyang: Also try that link again.
18:03:38 <ezyang> Yeah, got the paper, reading up now
18:04:19 <ezyang> Hmm, I guess f (a <+> as) = a <*> (f as) doesn't give an obvious way to calculate <*>
18:05:37 <ezyang> Slightly relatedly, do I have to do anything to make GHC fuse list operations?
18:06:19 <ddarius> ezyang: Use the library functions that are written with the fusion operators (which is just the standard list library functions) and compile with optimizations.
18:06:50 <copumpkin> I wonder if supero in ghc will really make the fusion rules obsolete
18:07:08 <ezyang> Ok.
18:07:44 <bitstream0101> Okay, I'm four hours into some hair pulling ;). Can anyone think of reasons why the recvLen invocation might not block in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25632 ?
18:08:09 <bitstream0101> The code given works as expected: start the server, connect with the client, client will chill until the server closes the connection.
18:08:14 <aavogt> superhero compiler
18:08:25 <applicative> the email addresses of the authors of the short cut fusion paper are given as  "{andy,jl,simonpj}@dcs.glasgow.ac.uk" , is this a convention or cleverness?
18:08:39 <monochrom> both.
18:08:41 <bitstream0101> ...but with this embedded in the real program, that recvLen doesn't block even though the order of operations is the same between the two :(
18:08:48 <copumpkin> applicative: I've seen several people do that before
18:09:19 <mauke> $ echo {andy,jl,simonpj}@dcs.glasgow.ac.uk
18:10:07 <ezyang> And there's the obvious question of whether or not we can come up with similar fusion laws for other morphisms.
18:10:23 <ezyang> Which I presume I will have an answer for after I finish reading this pair of papers.
18:11:44 <applicative> bitstream0101, what is the problem?
18:11:59 <ddarius> ezyang: Yes we can come up with dual laws for unfolds.  The operations dual to the shortcut deforestation ones are called unfold/destroy
18:12:11 <applicative> bitstream0101, of course, I was hoping for an error message to interpret, a gruesome type violation.
18:12:27 <bitstream0101> applicative: That's the problem, I'm not sure :(. The snippet posted works as expected, but when embedded in another program I'm seeing drastically different behavior.
18:12:39 <ezyang> ddarius: *nod* That sounds reasonable. How about the more exotic ones, like paramorphisms?
18:12:53 <bitstream0101> applicative: hehe. i'm just looking for advice for what might cause recvLen not to block; documentation says it ought to, and the socket is still held open by the server clearly
18:14:14 <ddarius> ezyang: Those are definable in terms of cata, but it would not be hard to derive laws for them and I think some are derived in the barbed wire paper.
18:14:56 <bitstream0101> applicative: in the other scenario, i'll see output that looks like: 'About to recvLen for sz = 4' or somesuch, followed immediately by an EOF exception.
18:15:27 <ezyang> oh! I didn't realize that.
18:22:15 <ezyang> Hmm, ++ written in foldr/build style is kinda clunky
18:22:25 <ezyang> O giess
18:22:29 <ezyang> I guess it makes sense tho.
18:22:51 <copumpkin> openglguy!
18:25:50 <ddarius> ezyang: Really?  It should be not much more than \xs ys -> foldr (:) ys xs
18:26:10 <ddarius> > let (++) = flip (foldr (:)) in "abc" ++ "def"
18:26:11 <lambdabot>   "abcdef"
18:27:27 <k23z__> can I have arrays instead of lists if I want to ?
18:27:40 <mauke> it's your party, you can cry if you want to
18:27:58 <k23z__> mauke, :)
18:28:12 <k23z__> why aren't arrays instead of lists as default in Haskell ?
18:28:15 <siracusa> Is the -threaded option automatically passed to GHCi when a program is loaded?
18:28:23 <k23z__> after all, arrays are much faster
18:28:32 <monochrom> neither is default.
18:28:32 <copumpkin> k23z__: faster at what?
18:28:33 <mauke> k23z__: arrays don't move
18:28:38 <mauke> they have no speed
18:28:48 <k23z__> copumpkin, accessing ?
18:28:57 <monochrom> and false dichotomy and pseudoquestions.
18:29:04 <mauke> k23z__: accessing what?
18:29:05 <danharaj> They are faster at random access, not access.
18:29:09 <aavogt> monochrom: big words
18:29:15 <k23z__> mauke, a particular element
18:29:24 <danharaj> Choose the correct structure for the correct algorithm.
18:29:24 <mauke> k23z__: how about the first element?
18:29:28 <monochrom> not bigger than "default" and "faster".
18:29:28 <mauke> that's pretty particular
18:29:31 <k23z__> mauke, how about the last ?
18:29:37 <k23z__> a random element then
18:29:40 <k23z__> damn, you know what I mean
18:29:42 <copumpkin> k23z__: how about prepending?
18:29:44 <mauke> k23z__: how about prepending elements?
18:29:46 <c_wraith> Q: if I drop my laptop from the top of a biulding, how fast will my arrays move?  A: They remain stationary, because I was running the program on my hosted server.
18:29:47 <mauke> arrays suck at that
18:29:50 <monochrom> neither is default and neither is faster.
18:29:56 <copumpkin> anyway, lists are more elegant
18:29:58 <copumpkin> so we play with them more
18:30:06 <copumpkin> we acknowledge their shortcomings and don't use them for things they're bad at
18:30:09 <k23z__> ok how about a data structure that doesn't have the compromises of lists or those of arrays ?
18:30:12 <mauke> lists are streamable
18:30:18 <k23z__> is there any such data structure ?
18:30:19 <copumpkin> k23z__: nothing is great at everything
18:30:23 <mauke> can't have an infinite array
18:30:31 <mauke> k23z__: Data.Sequence?
18:30:38 <Apocalisp> Data.Sequence kicks ass
18:30:39 <k23z__> mauke, what is it ?
18:30:43 <mauke> a module
18:30:47 <mauke> what did you think it was?
18:30:53 <monochrom> these are really trolling-grade questions.
18:30:54 <k23z__> mauke, an apple
18:30:58 <c_wraith> It's a 2-3 finger tree.
18:31:12 <applicative> bitstream0101, this is too tough for me, alas; i'm still fiddling a bit, but without hope.
18:31:12 <mauke> I'll grade your trolling!
18:31:17 <k23z__> monochrom, err.. wat ?
18:31:18 <copumpkin> mauke: on what scale?
18:31:19 <c_wraith> O(1) access to the front and back, O(lg n) random access
18:31:26 <mauke> copumpkin: 1 .. 10
18:31:34 <danharaj> c_wraith: what's the catch
18:31:36 <copumpkin> > [1..10]
18:31:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:31:49 <aristid> Apocalisp: but Data.Sequence is strict?
18:31:54 <bitstream0101> applicative: no worries, mate. it's hurting me too ;P
18:31:59 <k23z__> mauke, are these sequences described somewhere like.. what they actually are and stuff ?
18:32:00 <bitstream0101> applicative: thanks for taking a peek at it though
18:32:04 <Apocalisp> aristid: Is it?
18:32:05 <mauke> danharaj: your head might explode from the sheer awesome
18:32:09 <k23z__> mauke, link me to some wikipedia page so I can have a look please
18:32:14 <sclv_> hacphi: ekmett now explaining yoneda lemma in haskell.
18:32:18 <sclv_> (surprise)
18:32:21 <aristid> Apocalisp: "Apart from being finite and having strict operations"
18:32:22 <mauke> k23z__: http://haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Sequence.html
18:32:25 <mauke> k23z__: also, rtfm
18:32:33 <k23z__> mauke, no man
18:32:38 <mauke> yes
18:32:42 <k23z__> mauke, I was asking for a page describing them, not the implementation
18:32:47 <monochrom> you've got the link you asked for.
18:32:50 <ddarius> sclv_: Yoneda's lemma is almost trivial in Haskell.
18:32:55 <mauke> that's not the implementation
18:32:59 <mauke> that page is documentation
18:33:10 <Apocalisp> aristid: OK, but a 2-3 finger tree doesn't have to be strict
18:33:21 <k23z__> mauke, it seems they're implemented with finger trees
18:33:32 <mauke> cool story, bro
18:34:03 <k23z__> no bro please
18:34:10 <sclv_> yes
18:34:35 <sclv_> his explanation was ~3 minutes
18:34:50 <sclv_> lots of diagrams hacking going on too
18:34:54 <aristid> Apocalisp: consTree for example uses `seq`
18:35:20 <k23z__> is there any article describing how to go from a recursive algorithm to writing my own call-stack ?
18:35:28 <k23z__> and can someone please link me to it ?
18:35:37 <bro> k23z__: I don't understand the question
18:35:45 <mauke> I don't know but that sounds trivial
18:35:45 <monochrom> hahaha hey bro!
18:36:06 <c_wraith> pumpkin, he's just asking how to manage your own stack explicitly instead of letting the language take care of it.
18:36:13 <mauke> ok, the code transformation might not be obvious
18:36:32 <k23z__> yes... well I was asking just that
18:36:39 <monochrom> is there any purpose or point in this sequence of incoherent pseudo-questions?
18:37:16 <monochrom> or is it just a take-home exam?
18:37:40 <c_wraith> much better nick
18:37:52 <k23z__> monochrom, who are you asking ?
18:38:02 <k23z__> monochrom, who wants to know ?
18:38:05 <monochrom> I'm asking monochrom.
18:38:07 <bropumpkin> sclv_: so you're at hac phi?
18:38:11 <monochrom> monochrom: is there any purpose or point in this sequence of incoherent pseudo-questions?
18:38:20 <bropumpkin> monochrom: fix (I'm asking)
18:39:29 <ddarius> sclv_: Tell him that Yoneda is just a matter of matching up the types.
18:41:48 <ddarius> sclv_: Also ask him to demonstrate how every cocontinuous functor into Set is a left Kan extension along Yoneda.
18:42:05 <ddarius> and vice versa (up to isomorphism)
18:43:43 <mike-burns> I'm working on a library for managing exceptions and run-time errors (I can give more details if you want). Basically I want to be able to take an exception (Control.Exception is where I should concentrate?) and pull out the type, function and module where it happened, and the backtrace.
18:43:54 <mike-burns> What do I have to do to do this?
18:44:17 <aavogt> some people are working to get ghc to do backtraces
18:44:22 <mauke> I don't think that information is in the exception
18:44:25 <ddarius> mike-burns: Exceptions don't carry that information in general so it isn't there to "pull out."
18:44:40 <mike-burns> What are my options for getting at this information?
18:45:10 <ddarius> mike-burns: None.  You can put it into your exceptions if you use your own exception types/monad.
18:45:49 <mauke> or your own 'throw'
18:45:53 <monochrom> long shot: run things inside the ghc api and use its debugger and backtracer.
18:46:14 <monochrom> oh haha someone should implement that as a monad transformer. TracerT
18:46:34 <mike-burns> monochrom: Interesting idea.
18:46:37 <mauke> haha
18:47:01 <monochrom> "how to find other people's IP and backtrace!"
18:47:36 <mike-burns> Is the GHC API documented?
18:47:43 <mike-burns> This long shot is better than nothing.
18:48:02 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/index.html
18:49:10 <danharaj> Not much in some of those modules other than type signatures.
18:49:13 <Cale> mike-burns: What does a backtrace mean?
18:49:22 <monochrom> I also want to point you to a hackage package that exemplifies how to build on top of the ghc api, but its name escapes me...
18:49:46 <mike-burns> Cale: In the least, the line and file in the original source where the error/exception occured.
18:50:01 <mauke> hint?
18:50:08 <monochrom> Yeah, hint!
18:50:19 <applicative> sclv_ what else is going on at hack phi?
18:50:28 * mike-burns looks at hint.
18:51:00 <blackdog> mike-burns: hint is awesome, it saved me much pain with hubris.
18:51:30 <mike-burns> Excellent.
18:51:59 <sclv_> applicative: rumor has it some web stuff tomorrow.
18:52:11 <sclv_> a few folks worrking on games, I think.
18:52:25 <sclv_> Some more people will join us tomorrow as well
18:52:48 <sclv_>  byorgey gave a quick diagrams presentation earlier, and kmett talked about his reverse automatic differentiation package already.
18:53:04 <bitstream0101> I think 'scion' also uses the GHC API extensively
18:53:14 <monochrom> w00t, direct-plugins looks interesting!
18:53:45 <monochrom> (for my plan on using a plugin lib; unrelated to backtracing)
18:56:18 <mike-burns> Is the thing raised by   1 `div` 0   an Exception? Is it a Control.Exception? What is the right terminology here?
18:56:50 <Cale> It's an asynchronous exception. You can catch it using the stuff in Control.Exception, but it's fiddly to do so.
18:56:53 <monochrom> It is something catchable by Control.Exception things, yes.
18:57:22 <Cale> You have to ensure that the evaluation of the expression really occurs inside of the catch.
18:57:23 <monochrom> evaluate ( .... 1 `div` 0 ... ) `catch` ...
18:57:50 <Cale> and so there's evaluate :: a -> IO a
18:57:59 <mike-burns> Ah, I see.
18:58:11 <mike-burns> How else am I supposed to handle it?
18:58:14 <Cale> which evaluates a value into weak head normal form as an IO action
18:58:37 <Cale> You're typically not supposed to handle those exceptions, you're supposed to ensure that they don't occur in the first place.
18:59:47 <mike-burns> How about the isAleadyInUseError from openFile ? How am I supposed to handle that?
19:00:05 <Cale> Oh, that's straightforward, since openFile in an IO action
19:00:11 <monochrom> same Control.Exception framework. It's pretty general.
19:00:12 <Cale> You just wrap it in a catch
19:00:22 <SamB_XP> I have used exception handlers to add additional information to the exceptions resulting from "error" calls...
19:02:00 <monochrom> openFile ... "/dev/null" `catch` ...
19:02:43 <monochrom> or even: (openFile ... "/dev/null" >>= hGetLine ...) `catch` ...
19:02:48 <mike-burns> Well to shed more light on what I'm trying to do: I want to make a Hoptoad (http://hoptoadapp.com/) library for Haskell so Web apps built in Haskell can handle run-time errors better.
19:03:41 <mike-burns> The way these things go in other languages is some hook in the Web framework that normally serves a 500 page first pulls data from the exception and sends it to Hoptoad, then serves the 500 page.
19:04:00 <mike-burns> So I'm trying to mimick that but the exception doesn't seem to have the data that I want.
19:05:37 <mike-burns> I'll concentrate in the GHC APIs and look for something magical.
19:06:38 <Cale> (do h <- openFile "foo" ReadMode; print =<< hGetLine h) `Control.Exception.catch` (\s -> putStrLn $ "Oops! " ++ show (s :: IOException))
19:07:44 <mauke> nice file handle leak
19:08:19 <Cale> h goes out of scope anyway
19:08:39 <monochrom> handles go out of fashion
19:08:53 <mauke> scope is not lifetime
19:09:17 <Cale> Well, the handle will get garbage collected.
19:09:22 <applicative> sclv_, I see. Sounds a bit tough.  Diagrams would be fun, but I can never get the cairo gtk2hs business working on the accursed OS X
19:09:34 * hackagebot jmacro 0.3 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.3 (SterlingClover)
19:09:50 <mauke> Cale: later, maybe
19:10:53 <monochrom> "l8er"
19:10:53 <sclv_> applicative: tough?
19:11:17 <monochrom> "l8er arr m8ey!"
19:14:14 <applicative> sclv_, maybe its not so tough;  I had a notion of going since I'm a few hours drive away.
19:14:44 <sclv_> its great fun
19:15:04 <mike-burns> How many people are at HacPhi this year?
19:15:06 <byorgey> applicative: no need to get cairo gtk2hs working. the new version is polymorphic in the backend.
19:15:13 <bropumpkin> that RJ guy on -cafe sure asks a lot of questions
19:15:21 <applicative> byorgy, excellent
19:15:26 <byorgey> applicative: and there's lots of work that can be done without having a backend at the moment
19:15:54 <applicative> byorgey, yes, there are several strata to it.  I sort of studied a version from a while back
19:16:06 <sclv_> mike-burns: about 12 so far
19:16:11 <mike-burns> Nice.
19:16:26 <mike-burns> Last year's HacPhi was an amazing time; sad to be missing it this year.
19:16:58 <byorgey> mike-burns: we're sad to be missing you too.
19:17:05 <nniro> @src ($=)
19:17:05 <lambdabot> Source not found. Where did you learn to type?
19:17:09 <byorgey> there's always next year.  hopefully.
19:17:15 <mike-burns> Yeah, hopefully!
19:17:22 <monochrom> (induction)
19:17:27 <mike-burns> Ideally I'll be writing more Haskell then.
19:18:45 <applicative> byorgey, did you put a new version of diagrams up?
19:19:08 <byorgey> applicative: no, it's currently being hacked on.
19:19:40 <nniro> monochrom: what is $=? ;P
19:19:57 <byorgey> applicative: not a whole lot to show for it just yet, but there should be a new version at some point in the not-too-distant future
19:21:17 <monochrom> something in hopengl IIRC
19:21:17 <bitstream0101> applicative: Wow, this is pretty crazy. So I've pared things down so the *real* client tries to talk to the fake server, and things work.  I just discovered that I get different recvLen blocking behavior at runtime based on _what gets linked against the executable_. *boggles*
19:21:28 <monochrom> err, something in gtk2hs IIRC
19:22:00 <bitstream0101> ie ghc -o dummyServer dummyServer.hs -package network responds just fine to the client
19:22:22 <bitstream0101> the exact same executable compiled in the context of cabal with a lot of dependencies (even though none are used in the source) has the other bizarre non-blocking behavior
19:23:33 <nniro> I was checking on methods to keep state while using callbacks and came across an openGL guide that was using ($=) and IORef
19:25:52 <hiptobecubic> realworldhaskell is pretty terse
19:25:56 <nniro> I can't recall, was IORef the method to keep state across different threads or that's something else?
19:27:52 <mauke> MVar, TVar?
19:35:01 <applicative> import Graphics.Rendering.OpenGL (($=), GLfloat)
19:38:10 <nniro> oh yeah, it seems the standard multithread variable synchronization module is Control.Concurrent.MVar
19:48:43 <applicative> nniro, newIORef 17 is the old fashioned mutable way of storing 17, then changing 'it'
19:50:56 <applicative> @type Data.IORef.newIORef 17 >>= \x -> (Data.IORef.readIORef x >>= print) >> (Data.IORef.modifyIORef x (+1) >> Data.IORef.readIORef x >>= print)  -- check it out, I can modify 17!
19:50:57 <lambdabot> IO ()
19:51:19 <mauke> no, you can modify x
19:51:30 <applicative> mauke, oh
19:51:40 <bitstream0101> okay, folks, i've narrowed down my bizarre Network.recvLen bug to the inclusion of the -threaded switch.  Does this make sense to anyone? (See http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25633 for details)
19:51:49 <applicative> mauke, x doesn't exist.
19:51:58 <mauke> > x
19:51:59 <lambdabot>   x
19:52:04 <bitstream0101> Network.Socket.recvLen*
19:52:31 <applicative> mauke,  that's one thing i'm not buying from lamdabot, you can't fool me.
19:52:39 <applicative> > x
19:52:40 <lambdabot>   x
19:52:48 <applicative> mauke, anyway, it's always the same
19:52:59 <jmcarthur> > f x
19:53:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:53:00 <lambdabot>    `GHC.Show.Show a'
19:53:00 <lambdabot>      a...
19:53:08 <jmcarthur> :t f
19:53:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:53:21 <mauke> > [f x, x]
19:53:22 <lambdabot>   [f x,x]
19:53:27 <mauke> > [f x y, z]
19:53:27 <lambdabot>   [f x y,z]
19:53:34 <jmcarthur> > foldr f z [a,b,c,d]
19:53:35 <lambdabot>   f a (f b (f c (f d z)))
19:54:27 <nniro> applicative: what's the new fashion? using the ST monad?
19:54:55 <applicative> > foldr f z [a,b,c,d `f` e]
19:54:55 <lambdabot>   f a (f b (f c (f (f d e) z)))
19:55:20 <applicative> nniro, no I just meant it's in old primers
19:55:56 <nniro> ah I see
19:57:50 <nniro> applicative: so it would be the method of choice for keeping state across a callback from foreign to haskell?
20:00:19 <applicative> nniro, I just meant it wasnt anything as up to date as an MVar
20:00:35 <applicative> > take 20 $ intersperse h (repeat a)
20:00:36 <lambdabot>   [a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h]
20:00:56 <bropumpkin> :t interleave
20:00:58 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
20:01:09 <applicative> > h : take 19 $ intersperse h (repeat a)
20:01:09 <lambdabot>   Couldn't match expected type `[a]'
20:01:09 <lambdabot>         against inferred type `[a1] -> [...
20:01:10 <bropumpkin> > interleave (repeat a) (repeat h)
20:01:11 <lambdabot>   [a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,...
20:01:20 <applicative> > h : (take 19 $ intersperse h (repeat a))
20:01:20 <lambdabot>   [h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a]
20:01:42 <applicative> mauke, i think this is not as good as the real thing
20:01:47 <jmcarthur> > cycle [h,a]
20:01:49 <lambdabot>   [h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,a,h,...
20:02:12 <applicative> > 'h' : (take 19 $ intersperse 'h' (repeat 'A'))
20:02:13 <lambdabot>   "hAhAhAhAhAhAhAhAhAhA"
20:02:23 <jmcarthur> > cycle "hA"
20:02:24 <lambdabot>   "hAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhAhA...
20:02:36 <applicative> > 'B' : (take 19 $ intersperse 'H' (repeat 'A'))
20:02:37 <lambdabot>   "BAHAHAHAHAHAHAHAHAHA"
20:02:54 <andrewsw> you for got the W...
20:03:02 <andrewsw> forgot
20:03:06 <jmcarthur> > "BW" ++ cycle "HA"
20:03:07 <lambdabot>   "BWHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA...
20:03:22 <jmcarthur> oh wrong
20:03:23 <applicative> > 'B' : (take 19 $ intersperse 'H' (repeat 'A')) ++ "W"
20:03:24 <lambdabot>   "BAHAHAHAHAHAHAHAHAHAW"
20:03:29 <jmcarthur> lol
20:03:31 <bropumpkin> okay :P
20:03:32 <andrewsw> heh
20:03:36 <jmcarthur> > "BW" ++ cycle "AH"
20:03:38 <lambdabot>   "BWAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH...
20:03:43 <applicative> bropumkin has had enough?
20:03:48 <bropumpkin> yeah, I think so
20:03:49 <jmcarthur> i have
20:04:08 <applicative> me to okay, but it beats SimpleReflect or whatever
20:04:16 <applicative> me too
20:05:45 <sister_functor> this isn't working for me
20:08:03 <applicative> What is the best primer about type families for the cognitively impaired, by the way?  I was making a little progress.
20:08:21 <bropumpkin> they're basically functions on types
20:08:38 <bropumpkin> think of it as a type synonym where you can pattern match
20:08:39 <hiptobecubic> What would be the type of a function that takes a list of numbers and returns the mean? (sum / length) ?
20:08:56 <applicative> [Int] -> Int
20:08:59 <bropumpkin> Fractional a => [a] -> a
20:08:59 <Saizan> hiptobecubic: you've to use fromIntegral there
20:09:19 <Saizan> ?type \xs -> sum xs / fromIntegral (length xs)
20:09:20 <lambdabot> forall a. (Fractional a) => [a] -> a
20:09:28 <applicative> what am i thinking, you see why i want the primer for the impaired
20:09:50 <hiptobecubic> Fractional.... that's what i was missing. How is fractional different from float?
20:10:04 <bropumpkin> Fractional is a set of types that includes Float
20:10:07 <bropumpkin> but also Rational, Double, and others
20:10:23 <applicative> hiptobecubic, it means you can divide crudely ; what else?
20:10:23 <bropumpkin> might as well make it more general if it costs you (basically) nothing to do so
20:10:31 <mauke> :t \xs -> fromIntegral (sum xs) / fromIntegral (length xs)
20:10:32 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
20:10:42 <applicative> :t 3 / 4
20:10:43 <lambdabot> forall t. (Fractional t) => t
20:11:06 <applicative> :t 3 / (3/ 4)
20:11:07 <lambdabot> forall t. (Fractional t) => t
20:11:47 <applicative> :t 3 / (3/ (4:: Float))
20:11:48 <lambdabot> Float
20:12:16 <applicative> > 3 / (3/ (3:: Float))
20:12:17 <lambdabot>   3.0
20:13:32 <runnie> hello
20:14:26 <bropumpkin> allo
20:15:55 <runnie> I'm newbie in Functional Programming.  I have a huge neural network with thousands of neurons and every connection between neurons has its weight. I have to update these weights very often, several thousand times per learning session.  Is FP still applicable here? I mean in fp we can't modify variables and only able to return new variables not changing previous values. Does this mean I have to recreate whole network on every weigh
20:16:50 <bropumpkin> you'd probably represent it differently, or use purely functional mutation :P
20:17:24 <SamB_XP> is there a cabbage for that?
20:17:27 <jmcarthur> runnie: think of it this way. if you mutate every node for each iteration, you are already recreating the entire network. might as well be purely functional ;)
20:18:04 <runnie> so let's say i have two nodes and one connection between them
20:18:31 <runnie> function learn(net) will return new network with altered connection
20:18:45 <runnie> what do you mean by mutate?
20:19:04 <syntaxglitch> on the other hand, if there's a graph-like structure and most updates are to adjacent edges, that sounds like the sort of thing where a zipper works well
20:19:09 <jmcarthur> runnie: mutate == the in-place update you might be used to in imperative programming
20:20:35 <jmcarthur> runnie: if the connection is the only thing changed then the nodes from the original graph will be reused
20:20:47 <jmcarthur> rather than recreated
20:21:02 <syntaxglitch> if updates are scattered through the structure and only a few change per iteration, there's piles of functional data structures for indexed lookup that would work well
20:22:44 <runnie> nope, almost every weight is being updated
20:23:12 <syntaxglitch> runnie, then jmcarthur has the right idea
20:25:30 <applicative> runnie, is it that you want the internal progress of the program to be as much of a mess as the internal workings of the brain?
20:25:55 <EvanR> zipper AI, gotta love it
20:26:32 <syntaxglitch> for maximum authenticity, use genetic algorithms to design your neural network function
20:26:43 <syntaxglitch> it worked for nature
20:26:49 <applicative> runnie, I take it you've seen e.g. http://hackage.haskell.org/package/hnn-0.1
20:27:44 <applicative> I don't see why [[Neuron]] shouldn't be a type.
20:27:45 <runnie> guys, I'm totally newbie to FP and just wondering how you handle big datastructures updates
20:28:04 <mauke> massive sharing
20:29:35 <applicative> runnie, notice that in the module outlined here http://hackage.haskell.org/packages/archive/hnn/0.1/doc/html/AI-HNN-Net.html there are no mutable types.
20:29:40 <Cale> runnie: If you have an immutable binary tree consisting of mappings from keys to values, and you want to "update" it, producing a new binary tree with one element different, the only thing you have to really create is the path from the root to that one element which is different.
20:30:02 <Cale> runnie: Every other subtree is the same as in the original and can be shared.
20:30:05 <jmcarthur> runnie: the basic idea is that you don't really copy anything. you just make new things that refer to old things when possible. for example, if i have a list and i "replace" its head with a different element, then operationally i just create a new list head with the new element, but it points to the tail of the original list
20:30:39 <runnie> this works for list, but how about a huge tree?
20:30:51 <jmcarthur> runnie: it's as Cale explained
20:30:52 <EvanR> well binary tree depth is logarithmic
20:30:52 <Cale> runnie: I just explained how it works for a huge tree :)
20:31:10 <syntaxglitch> trees are usually better, since more can be shared
20:31:28 <Cale> runnie: The path from the root of a balanced tree to any given element has O(log n) nodes in it.
20:31:39 <runnie> yup
20:31:47 <Cale> runnie: Which means that you can do an update or a lookup in O(log n)
20:31:58 <EvanR> which means its faster than updating a list
20:31:59 <wli> n-ary tree depth is O(lg(n)) actually
20:32:02 <jmcarthur> nicely that's the same as you'd get imperatively
20:32:17 <jmcarthur> complexity-wise
20:32:23 <wli> Ugh, n-ary tree depth for trees with k elements is O(lg(k))
20:32:23 <jmcarthur> of course it's a little slower in practice
20:32:33 <Cale> wli: I was about to say :)
20:33:02 <syntaxglitch> a lot of stuff these days is more like O(cache misses)
20:33:09 <sshc> Why isn't version 3 the default version of Parsec?
20:33:10 <Cale> Yeah, in mutable settings people often use hashtables for this purpose
20:33:41 <jmcarthur> yeah. it would be nice to have a formal language to talk about cache behavior in algorithms. anybody know of such language?
20:33:42 <Cale> But computing any hash function for a hashtable with n buckets takes at least O(log n) time as well
20:33:55 * wli would recommend B+ trees or R trees.
20:34:08 <hiptobecubic> Is my implementation of mirror, which turns [1,2,3] -> [1,2,3,3,2,1] sensible? http://vpaste.net/XdHrf?ft=haskell
20:34:10 <jmcarthur> Cale: umm...
20:34:20 <jmcarthur> oh right
20:35:05 <syntaxglitch> Cale, that depends on your definition of hash function
20:35:15 <Cale> hiptobecubic: It works, but I'd have gone with reverse
20:35:16 <runnie> I'm sorry I drop out. Do you suggest to replace tree with hash table?
20:35:34 <Cale> syntaxglitch: any function whose range has n elements takes at least O(log n) time to compute
20:35:36 <EvanR> @quote hash
20:35:36 <lambdabot> No quotes match. Just try something else.
20:35:45 <hiptobecubic> Cale, oh right... well the book hasn't mentioned reverse yet, i'm not sure it's fair game
20:36:04 <syntaxglitch> Cale, okay, I'll buy that one
20:36:14 <Cale> runnie: I'm just talking about how hashtables (which are popular in imperative, mutable settings) compare with trees, which we tend to use in immutable settings.
20:37:23 <Cale> runnie: Computing hashes turns out to be asymptotically as expensive as doing lookups in balanced trees.
20:37:28 <syntaxglitch> As an aside, are hash tables really that popular for "serious" purposes? I was under the impression that stuff doing heavy-duty data storage/searching like an RDBMS use other structures
20:37:53 <jmcarthur> syntaxglitch: an RDBMS is a special case due to storing so much on disk
20:37:59 <wli> RDBMS -type stuff uses external algorithms heavily, and hashing wreaks havoc on disk locality.
20:38:07 <syntaxglitch> jmcarthur, fair enough
20:38:13 <Cale> runnie: Of course, the constant factors are all different, and hashtable implementations are often able to use contiguous blocks of memory for storage of elements which helps with cache locality...
20:38:22 <jmcarthur> syntaxglitch: i do linux kernel development at work. tons of hashing goes on there
20:38:27 <Cale> runnie: But for the most part, the difference is not so large :)
20:38:47 <EvanR> i just observed two polar opposite descriptions of hash table locality
20:38:53 <EvanR> resolve immediately
20:38:54 <jmcarthur> Cale: well, the constant factors get pretty large in comparison, really
20:38:55 <syntaxglitch> jmcarthur, sounds good to me, thanks :)
20:39:14 <ddarius> @hackage repa
20:39:14 <lambdabot> http://hackage.haskell.org/package/repa
20:39:26 <Cale> I guess it depends on what you consider a large difference and what sort of applications you have in mind :)
20:39:28 <wli> Cache locality gets blown away by the randomness for the most part. A lot of the contiguous block of memory stuff is just allocation with manual and potentially difficult memory management (e.g. boot-time allocated things in kernels).
20:40:07 <Cale> wli: Oh? That's interesting.
20:40:10 <jmcarthur> i really wish we had a pure trie with good cache locality
20:40:30 <EvanR> they just need to make caches better
20:40:35 <jmcarthur> HAT-trie is the best i know of, and even it relies on a hash function for part of it o_O
20:40:41 <EvanR> clearly locaity of reference is a sham
20:40:53 <Cale> EvanR: Or *gasp* get rid of caches and let compilers decide how to use that memory.
20:41:36 <EvanR> sounds like an architecture problem
20:41:41 <wli> They call them "hash lists" sometimes to sort of emphasize how they're basically just lists that are chopped up a bit.
20:41:49 <jmcarthur> Cale: surely you don't mean to get rid of caches. do you mean offer explicit control over caches?
20:41:50 <EvanR> we need cache instructions
20:42:18 <Cale> jmcarthur: I mean instead of having caches, just put a bunch of fast addressable memory there.
20:42:38 <Cale> (and let the program do with it whatever it wants)
20:42:43 <jmcarthur> ah, essentially the same thing, but yes i see what you mean. that would have the power of my suggestion without requiring new instructions
20:43:02 <wli> The Seymour Cray philosophy of memory, sure.
20:43:06 <EvanR> yeah, you get control over registers, and main memory, but not the various levels of cache in between. theres a disconnect there
20:43:16 <wli> All SRAM, no cache (or TLB).
20:43:32 <jmcarthur> Cale: wouldn't that burden the OS though? wouldn't it have to flush it whenever a different process wants to use it?
20:43:55 <jmcarthur> seems like with preemptive scheduling and such it might actually be slower that way
20:44:52 <jmcarthur> RAM is the new hard drive is the new tape
20:44:54 <Cale> jmcarthur: I suppose some sort of system for sharing that memory would have to be worked out.
20:45:00 <applicative> runnie, i see alpounet, the guy who started the recent HNN business is in theory present.
20:45:32 <wli> Doesn't sound right wrt. caches, but anyway, most of the cases where giant hashtables are used in-kernel should really be some other data structure that adapts itself to the workload with memory reservation etc. for dynamically allocating indexing metadata.
20:45:42 <EvanR> Cale: virtual cache memory management ;)
20:46:23 <ddarius> There are schemes to put caches under program control for security reasons.
20:46:30 <jmcarthur> wli: i agree in large part
20:46:35 <Cale> Actually, I really like the idea of a processor like the Reduceron or these memristor crossbar arrays that people are thinking about now.
20:47:22 <EvanR> ddarius: yeah dont want those blueray encryption keys to get out
20:47:57 <jmcarthur> ddarius: i think one of my coworkers might be doing something involving that, but i don't know anything about it. know any details?
20:50:07 <Cale> hiptobecubic: I should mention that your version of mirror is actually a good deal slower than it needs to be, but you probably don't want to concern yourself with performance so early on :)
20:50:17 <ddarius> jmcarthur, Cale: http://eprint.iacr.org/2005/280.pdf
20:50:23 <jmcarthur> thanks
20:50:29 <Cale> hiptobecubic: Computing  xs ++ ys  fully takes  O(length xs)  steps
20:50:44 <hiptobecubic> Cale, yes i remember "learn you a haskell" complaining about how ++ has to traverse the entire list
20:50:52 <hiptobecubic> Cale, babysteps
20:51:14 <EvanR> so does reverse
20:51:27 <Cale> Yeah, there's no other way to do (++) -- it's going as fast as it can. But you can try to avoid repeatedly doing (++) :)
20:52:01 <Cale> mirror xs = xs ++ reverse xs  will take the time to traverse xs for the (++), and then the time to traverse it again for the reverse, so it's linear time
20:52:06 <ddarius> jmcarthur, Cale: Actually I think this is the paper I actually read though the other is in the same vein (it is cited by this paper): http://palms.ee.princeton.edu/system/files/p494-wang.pdf
20:52:36 <pastorn> hiptobecubic: if you want a speedup, you can look at DList
20:52:52 <pastorn> hiptobecubic: i think DLists append function is O(1)
20:53:14 <jmcarthur> ddarius: nice thanks
20:53:17 <Cale> pastorn: Yeah, though I think DList is way too heavy for what it is :)
20:53:20 <hiptobecubic> pastorn, just working on making it work, for now
20:53:24 <ddarius> pastorn: DList doesn't have a reverse other than going via lists.
20:53:33 <jmcarthur> pastorn: DList also kills any chance of sharing
20:53:51 <pastorn> four highlights in a row... i must be AWESOME
20:53:54 <jmcarthur> heh
20:54:03 <pastorn> if all weren't telling me that i was wrong...
20:54:11 <jmcarthur> DList is not without its uses, but those uses are usually for its Monoid instance
20:54:23 <pastorn> jmcarthur: true :)
20:54:27 <Cale> mirror [] = []; mirror (x:xs) = x : (mirror xs ++ [x]) will, for each element x, be (++)'ing the rest of the list, xs to something, and so this will take O(n(n-1)/2) = O(n^2) steps
20:54:38 <applicative> pastorn, I was going to say, it's just that your mistakes are more interesting...
20:54:41 <pastorn> hiptobecubic: do you know what the root of all evil is?
20:54:49 <Cale> er, sorry, it'll be (++)'ing the result of mirroring that :)
20:55:02 <Cale> But, still, quadratic time when you add it all up
20:55:02 <hiptobecubic> pastorn, monosodium glutamate
20:55:25 <ddarius> let mirror xs = mirror' xs []; mirror' [] acc = acc; mirror' (x:xs) acc = x:mirror' xs (x:acc) in mirror "abc"
20:55:29 <ddarius> > let mirror xs = mirror' xs []; mirror' [] acc = acc; mirror' (x:xs) acc = x:mirror' xs (x:acc) in mirror "abc"
20:55:29 <lambdabot>   "abccba"
20:56:33 <pastorn> hiptobecubic: it might be premature optimization...
20:56:45 <applicative> ddarius, experiment proves its a zillion times faster
20:56:52 <pastorn> hiptobecubic: what are you building?
20:56:53 <Cale> > let mirror' [] = id; mirror' (x:xs) = (x:) . mirror' xs . (x:); mirror xs = mirror' xs [] in mirror "abc"
20:56:54 <lambdabot>   "abccba"
20:57:35 <jmcarthur> @pl \xs -> xs ++ reverse xs
20:57:35 <lambdabot> ap (++) reverse
20:57:39 <jmcarthur> of course
20:57:41 <hiptobecubic> pastorn, absolutely nothing. i've written about ten functions, ever.
20:57:50 <Cale> (this is the same as ddarius' version, but written slightly differently)
20:57:56 <pastorn> hiptobecubic: cool :)
20:57:57 <jmcarthur> > (++) <*> reverse $ "abc"
20:57:59 <lambdabot>   "abccba"
20:58:22 <pastorn> jmcarthur: quit messing with the newcomers heads
20:58:26 <hiptobecubic> Cale, yes i see that. Not sure i'd have come up with that myself. It's difficult to parse visually when it's all on one line like that
20:58:33 <Cale> hiptobecubic: yeah...
20:58:39 <jmcarthur> pastorn: i'm merely offering a preview of the awesomeness that is to come
20:58:51 <pastorn> jmcarthur: right...
20:58:53 <Cale> hiptobecubic: We essentially replace lists with functions, and since function composition is constant time, it makes things fast :)
20:58:54 <jmcarthur> @src reverse
20:58:54 <lambdabot> reverse = foldl (flip (:)) []
20:59:03 * pastorn thinks jmcarthur is just showing off
20:59:04 <ddarius> > let mirror' = foldr ((.) . (:)) id; mirror = flip mirror' [] in mirror "abc" -- Now you've done it Cale.
20:59:04 <lambdabot>   "abc"
20:59:08 <jmcarthur> @src (++)
20:59:09 <lambdabot> []     ++ ys = ys
20:59:09 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:59:09 <lambdabot> -- OR
20:59:09 <lambdabot> xs ++ ys = foldr (:) ys xs
20:59:29 <pastorn> hiptobecubic: i learned a LOT of using lambdabot + the @src command
20:59:39 <ddarius> @pl (\x xs -> (x:) . mirror' xs . (x:))
20:59:39 <lambdabot> ap ((.) . (.) . (:)) (flip ((.) . mirror') . (:))
20:59:41 <pastorn> s/of/by
20:59:43 <ddarius> Hmm.
20:59:54 <jmcarthur> you lose a lot of brain cells from @pl though
20:59:55 <pastorn> ddarius: isn't it obvious?
20:59:55 <Cale> ddarius: Yeah, not easy to points-free that.
21:00:26 <hiptobecubic> what is @pl doing?
21:00:34 <jmcarthur> @pl \x xs -> x . mirror' xs . x
21:00:34 <lambdabot> liftM2 (.) (.) (flip ((.) . mirror'))
21:00:35 <ddarius> > let mirror' = foldr (\x -> ((x:) .) . (. (x:))) id; mirror = flip mirror' [] in mirror "abc"
21:00:35 <syntaxglitch> hiptobecubic, it makes code more elegant
21:00:36 <lambdabot>   "abccba"
21:00:43 <ddarius> Not horrid...
21:00:45 <jmcarthur> syntaxglitch: except when it doesn't
21:00:47 <Cale> hiptobecubic: Removing explicit parameters from the function, rewriting it as a composite of other functions
21:01:03 <syntaxglitch> jmcarthur, for suitable definitions of "elegant" at any rate
21:01:06 <Cale> It doesn't always make code more elegant, sometimes it makes it hideous.
21:01:11 <pastorn> @pl (\x -> x + 1) -- hiptobecubic
21:01:11 <lambdabot> (1 +)
21:01:13 <hiptobecubic> indeed
21:01:16 <Cale> But sometimes it neatens it
21:01:16 <pastorn> that's a simple example
21:01:21 <jmcarthur> @pl \a b c d -> a b d d c a
21:01:22 <lambdabot> flip =<< ((flip . (flip .) . flip) .) . flip flip id . (ap .)
21:01:25 <Cale> heh
21:01:38 <hiptobecubic> what a feature
21:01:52 <Cale> You can generally expect most cases where a variable is repeated to turn out a bit messy.
21:01:54 <pastorn> @pl f xs = map (\x -> 10 * x) xs
21:01:54 <lambdabot> f = map (10 *)
21:02:00 <pastorn> hiptobecubic: ^^^
21:02:00 <jmcarthur> @pl \f g x -> f (g x) x
21:02:00 <lambdabot> flip flip id . liftM2
21:02:04 <jmcarthur> @pl \f g x -> f (g x)
21:02:04 <lambdabot> (.)
21:02:06 <applicative> well, Cale and ddarius are tied mirroring 'it' where length it = 1872768
21:02:21 <pastorn> jmcarthur: flip (.) ?
21:02:23 <ddarius> applicative: We're writing the same code.
21:02:25 <Cale> applicative: That's because we really wrote the same program
21:02:35 <jmcarthur> pastorn: where?
21:02:45 <pastorn> oh, sorry, didn't see x being used twice...
21:02:48 <Cale> (and the compiler is smart enough to know that) :)
21:02:58 <ddarius>  @pl needs a better (perhaps just extended) set of basis combinators
21:03:28 <pastorn> ddarius: true... it should learn about applicative
21:03:32 <pastorn> for true madness
21:03:38 <Cale> hiptobecubic: Anyway, the trick as I see it is that if you have to do a lot of concatenation, you can switch from using lists directly, to using functions which add a bunch of elements to the beginning of another list.
21:03:51 <hiptobecubic> Cale, right
21:03:52 <Cale> hiptobecubic: id becomes the analogue of the empty list
21:03:59 <Cale> (x:) is the analogue of [x]
21:04:04 * syntaxglitch suggests feeding @pl Data.Aviary
21:04:06 <jmcarthur> pastorn: it already uses ap and return. it's mostly there anyway
21:04:07 <Cale> and (.) is analogous to (++)
21:04:09 <syntaxglitch> That ought to improve things
21:04:21 <jmcarthur> heh
21:04:39 <pastorn> hiptobecubic: have you had any previous programming experiences?
21:04:45 <applicative> Cale, yes, I see; yours seemed more esoteric at first sight
21:04:57 <hiptobecubic> pastorn, hobbyist c++, python, perl
21:05:22 <hiptobecubic> perl is nasty
21:05:27 <ddarius> It's a monoid homomorphism from the free monoid into the set of it's endofunctions.
21:05:40 <pastorn> hiptobecubic: wait till you get to monads...
21:05:46 <applicative> ddarius, is that a statement about perl?
21:05:52 <pastorn> (scary stuff)
21:05:58 <Cale> applicative: No, it's a description of the trick I described
21:06:45 <jmcarthur> pastorn: now who's scaring people?
21:06:54 <jmcarthur> really though, monads aren't scary
21:07:00 <pastorn> i know
21:07:02 <jmcarthur> its reputation is much worse than reality
21:07:07 <applicative> hiptobecubic, don't let these guys throw nasty words like monads at you. I'm calling one of the ops, or whatever they call them.
21:07:09 <pastorn> @type callCC
21:07:10 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:07:22 <pastorn> @type getCC
21:07:23 <lambdabot> Not in scope: `getCC'
21:07:27 <hiptobecubic> I'm now writing something that determines if a list is a palindrome or not. eg, ismirror $ mirror [a]  should be True
21:07:32 <pastorn> lambdabot: bad bot!
21:07:37 <jmcarthur> :t callCC
21:07:38 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:07:56 <jmcarthur> a disgusting and amazing function
21:08:01 <Cale> pastorn: getCC isn't in the libraries :(
21:08:16 <hiptobecubic> Is it not legit to mix guards and "where" ?
21:08:28 <Cale> hiptobecubic: Depends on how you mix them
21:08:37 <Cale> hiptobecubic: 'where' scopes over multiple guards
21:08:45 <Cale> foo x | y > 0 = ...
21:08:46 <hiptobecubic> http://vpaste.net/XXyen?ft=haskell
21:08:52 <Cale>       | y <= 0 = ...
21:08:55 <Cale>   where y = ...
21:09:26 <Cale> You have a - just before your 'where' there
21:09:46 <hiptobecubic> Cale, yeah ignore that. left over from commenting it out. fixed
21:10:04 <Cale> and... you probably want  odd . length $ xs
21:10:17 <Cale> er, length' sorry :)
21:10:26 <Cale> Or just  odd (length' xs)
21:10:52 <pastorn> hiptobecubic: you can't use / to divide there, use the function div instead
21:10:54 <pastorn> :t div
21:10:55 <lambdabot> forall a. (Integral a) => a -> a -> a
21:11:02 <hiptobecubic> odd of length of xs? no dot?
21:11:10 <pastorn> that way you don't get a floating number
21:11:30 <Cale> hiptobecubic: If you want to use function composition, then you can't compose  odd  with  length' xs
21:11:37 <Cale> You need to compose odd with length'
21:11:40 <Cale> and then apply it to xs
21:11:45 <hiptobecubic> oh i see
21:11:47 <hiptobecubic> ok
21:11:47 <Cale> So you could write (odd . length') xs
21:11:53 <Cale> Or odd . length' $ xs
21:12:00 <hiptobecubic> yes
21:12:36 <hiptobecubic> i'm still getting used to not calling functions with (), so which parameters get passed to what still gets me sometimes
21:13:00 <Cale> The one most important rule about precedence is that function application binds tighter than any infix operator
21:13:21 <bitstream0101> hiptobecubic: it'll feel very natural once you get used to it, and then you'll miss "whitespace application" in other languages ;P
21:13:23 <Cale> So when you write  x y z + w * 4
21:13:33 <Cale> it means (x y z) + (w * 4)
21:13:43 <hiptobecubic> Cale, ok
21:13:47 <syntaxglitch> hiptobecubic, just keep in mind that in Haskell all functions take a single argument
21:13:58 <Cale> Oh, that's also a good thing to know :)
21:14:01 <jmcarthur> ((x y) z) + (w * 4), to be precise
21:14:18 <Cale> When you write f x y z, it really means ((f x) y) z
21:14:27 <hiptobecubic> yes i am aware of currying
21:14:30 <Cale> okay :)
21:15:23 * syntaxglitch had the opposite problem, of overusing exterior parens... haskell isn't scheme, as it turns out
21:16:24 <shapr> stepcut suggested I make a new language called fshapr
21:16:58 <Adamant> instead of foldr'ing things, you can shapr things
21:17:31 <shapr> Right!
21:18:01 <syntaxglitch> shapr: yes, exactly
21:18:06 <Adamant> I don't like how my data structures are structured. they need re-shapring. :)
21:18:13 <shapr> Yeah!
21:19:27 <spahn> I will design an anti-functional programming lagnuage!!  Side effects!  Nothing but side effects ---- AND globals, oh how it will have globals, ALL the time!
21:19:40 <syntaxglitch> spahn, isn't that called C?
21:19:43 <shapr> Like, assembly?
21:19:59 <spahn> Porbram flow so snarled that you not only can't prove it correct, you can't even prove the correctness of any adjacent pair of statements!
21:20:01 <spahn> BWHAHHAHAH
21:20:14 <syntaxglitch> ah, befunge, then
21:20:27 <pastorn> hiptobecubic: i have some minor suggestions for you... make length' :: [a] -> Int
21:20:28 <syntaxglitch> or worse, malbolge
21:20:39 <pastorn> hiptobecubic: and this should be your halflength:
21:20:45 <pastorn> where halfLength xs = div (length' xs) 2
21:21:03 <Adamant> I feel like pulling a Shatner and yelling SPAHHHNNNNNNNNN!!!!!!!!!!!!!!!
21:21:19 <hiptobecubic> pastorn, that returns the wrong answer for odd length lists
21:21:28 <pastorn> huh?
21:22:00 <hiptobecubic> div 5 2  doesn't return 2.5, which is half the length of 5
21:22:00 <pastorn> hiptobecubic: could you please describe the desired behaviour of ismirror'?
21:22:33 <hiptobecubic> pastorn, i think you undrstand ismirror'. Are you counting on odd lists not mattering because of the first guard?
21:23:09 <pastorn> ehm... i don't understand it at all... the version you pasted doesn't make a lot of sense :(
21:23:36 <hiptobecubic> Well ismirror' should do the same thing as ismirror, which does work as written
21:24:06 <pastorn> | odd (length' xs) = false; | otherwise = ismirror xs
21:24:12 <pastorn> that's all you need :)
21:24:17 <pastorn> *False
21:24:42 <ville> == ?
21:24:55 <hiptobecubic> pastorn, the "second way to do it" probably shouldn't just use the original function behind the scenes
21:25:22 <Xilon> Having some trouble getting my head around dealing with state (conceptually). Any good tutorials on writing long-running stateful/interactive applications?
21:26:01 <pastorn> Xilon: you got haskell sickness?
21:26:22 <applicative> hiptobecubic, did you reverse "drop (halfLength xs) xs' ?
21:26:32 <pastorn> i had that... the concept of changing variables was really difficult when i had to learn java :/
21:27:08 <ville> guess he means stateful Haskell programs
21:27:26 <applicative> hiptobecubic, i mean in the definition of ismirror'
21:27:50 <Xilon> It's not so much the changing of variables (immutability), more about managing the state, and separating IO is probably making it harder.
21:28:28 <pastorn> Xilon: do you want to know how to use the State functions in haskell?
21:28:34 <pastorn> (the State monad)
21:29:24 * hackagebot rangemin 2.2.0 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.2.0 (LouisWasserman)
21:29:43 <applicative> @unmtl State s a
21:29:43 <lambdabot> s -> (a, s)
21:33:19 <pastorn> hiptobecubic: i fixed your function :)
21:33:21 <pastorn> http://vpaste.net/KEYkX?
21:33:21 <hiptobecubic> What is the difference between Int and Integer
21:33:28 <pastorn> hiptobecubic: Int is 32 bits
21:33:40 <pastorn> Integer is a BigNum (takes as much space as it needs)
21:34:30 <Xilon> Hmm I just realised the problem has more to do with IO (and separating it from the other code) rather than state. I guess I'll just try writing a random app yet again :P
21:34:37 <applicative> @unmtl State (money, reputation) (wine, women, song)
21:34:37 <lambdabot> money -> reputation -> (wine, women, song, money, reputation)
21:34:40 <pastorn> > 9999999999 :: Int
21:34:41 <lambdabot>   9999999999
21:34:46 <pastorn> oh shi-!
21:34:48 <hiptobecubic> pastorn, your fix is just like my first try, just a little cleaner
21:34:50 <pastorn> > 999999999999 :: Int
21:34:51 <lambdabot>   999999999999
21:35:00 <hiptobecubic> > 9999999999999999999999999
21:35:01 <lambdabot>   9999999999999999999999999
21:35:03 <pastorn> > 999999999999999999 :: Int
21:35:04 <lambdabot>   999999999999999999
21:35:08 <pastorn> > 99999999999999999999999999999999 :: Int
21:35:08 <lambdabot>   -8814407033341083649
21:35:11 <pastorn> > 99999999999999999999999999999999 :: Integer
21:35:12 <lambdabot>   99999999999999999999999999999999
21:35:15 <pastorn> there we go
21:35:17 <hiptobecubic> i see
21:35:34 <pastorn> i guess lambdabot uses 63+sign bits Int
21:36:13 <pastorn> Xilon: have you played around anything with monad transformers?
21:36:17 <copumpkin> not a dedicated sign bit
21:36:22 <applicative> hiptobecubic, I emended the syntax for ismirror' http://vpaste.net/5jW8O?
21:36:23 <copumpkin> two's complement
21:36:42 <copumpkin> > maxBound :: Int -- would've been sufficient to figure that out btw ;)
21:36:43 <lambdabot>   9223372036854775807
21:36:47 <pastorn> Xilon: if you use monad transformers you can make a monad for both using State and IO :)
21:36:50 <copumpkin> > minBound :: Int -- would've been sufficient to figure that out btw ;)
21:36:51 <Xilon> No, I don't think I'm at that level yet. I haven't actually written an interactive application yet.
21:36:51 <lambdabot>   -9223372036854775808
21:36:56 <hiptobecubic> pastorn, well my point was that the first way does it with recursion and the second way does it by cutting the list in half, reversing the second half, and then applying ==
21:37:19 <pastorn> hiptobecubic: you never said that :)
21:37:38 <hiptobecubic> pastorn, No i supposed i didn't
21:37:42 <hiptobecubic> suppose*
21:38:04 <pastorn> Xilon: you should start by just using Control.Monad.State to compute something simple :)
21:38:21 <Xilon> Haskell's actually the first language I had to actually learn before doing anything. The others I could just learn by hacking. Oddly enough it seems a lot simpler syntactically
21:40:04 <dolio> Int is at-least-30 bits.
21:41:59 <applicative> Int is a drag, import Data.Peano instead
21:46:50 <pastorn> Xilon: i whipped up a small example for you :)
21:46:53 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25634#a25634
21:47:37 <pastorn> Xilon: if you want you can replace line 22 and 23 with "modify (+1)"
21:51:06 <Xilon> pastorn: Thanks, that seems simple enough.
21:52:01 <applicative> pastorn, why am i getting a type error?
21:52:43 <Xilon> The difficulty I'm having is mostly with IO though, since there's only one place were IO can happen (in the monad). I'm just trying to figure out how to manage IO operations in different places.
21:52:56 <pastorn> applicative: you must suck
21:53:01 <pastorn> which line?
21:53:11 <applicative> Couldn't match expected type `Int'  against inferred type `((), Int)'  ... in definition of 'e
21:53:20 <pastorn> oh, sorry
21:53:29 <pastorn> chonge that runState to execState
21:53:29 <Cale> Xilon: You can construct IO actions from anywhere. They're values and you can pass them around just like anything else.
21:54:21 <Xilon> Cale: Yep, but if you do them anywhere then those parts get "tainted" with IO, so it's a matter of separating IO and computation.
21:54:38 <Cale> Xilon: Well, yeah, typically, we tend to structure our programs so that we have some "user interface" of some sort written in IO, and then whatever it is that our program is doing is pure.
21:54:42 <Xilon> I'm probably overcomplicating it, it just seems a bit difficult to pass around the data everywhere.
21:55:04 <pastorn> Xilon: that's why you use StateT IO
21:55:13 <Cale> pastorn: eh?
21:55:26 <Cale> I would almost never recommend StateT IO myself ;)
21:55:40 <Cale> IO already has lots and lots of state.
21:55:50 <Cale> You can use an IORef instead.
21:55:52 <pastorn> Cale: well, to learn how to get stuff running, StateT IO is awesome
21:56:41 <Xilon> The problem I have with separating IO and computation is scalability. It seems if you have a lot of IO interaction in different parts of an application, it can be quite difficult. I suppose I shouldn't worry myself with that at this point though :P
21:56:43 <Cale> Xilon: Don't worry about passing so many parameters. Just remember that you can bundle them into datatypes as you see fit.
21:56:55 <Cale> Xilon: Use IO for input and output
21:57:15 <Cale> There's only one part of any application that really does input and output -- the user interface.
21:57:23 <applicative> pastorn, yes execState
21:57:33 <applicative> @type execState
21:57:34 <lambdabot> forall s a. State s a -> s -> s
21:57:42 <applicative> @type runState
21:57:43 <lambdabot> forall s a. State s a -> s -> (a, s)
21:58:58 <Cale> Xilon: If you're familiar with model-view-controller, it's the boundary between the model (the pure stuff that you're doing) and the view and controller (the IO) that you want to pay attention to :)
21:59:24 <Xilon> Cale: Yes, and data stores. From what I understand IO actions can only be run from main, so if I had a crazy application that retrieved data from a DB, did some computations, used the results to retrieve something from LDAP, then do more computations, etc, each time I'd have to somehow come back to main.
21:59:31 <root_> hi there
21:59:50 <Cale> Xilon: Well, yes, but all the computation it does with that input would be pure.
22:00:07 <bawwws> i have a problem with using title for windows management specially in manageHooks
22:00:11 <bawwws> can sum1 help me out?
22:00:24 <bawwws> oops
22:00:26 <Cale> bawwws: xmonad?
22:00:26 <bawwws> swrong
22:00:28 <bawwws> yah
22:00:32 <bawwws> wrong room
22:00:34 <bawwws> lol
22:01:00 <Cale> yeah, it's okay, lots of people know xmonad here too, but I'm not all that familiar. I can help if nobody else is around though.
22:01:27 <bawwws> awesome thnx
22:01:34 <bawwws> im going to check xmonad first
22:02:42 <Cale> Xilon: So the part of your program which decides which LDAP query to make based on the rows from the database would be a pure function from a bunch of rows to a query
22:02:53 <Cale> Xilon: (for instance)
22:03:03 <byorgey> has anyone here used haddock 2.7.2?  I just installed it, and now when I run 'cabal haddock' I just get the output 'Running Haddock for diagrams-core-0.1...\ncabal:'
22:03:11 <byorgey> and nothing actually happens, as far as I can tell
22:03:22 <Cale> Xilon: You'd just use IO to hook the pieces together and actually get things done in the end :)
22:04:02 <byorgey> oh, never mind, I forgot to clean first.
22:04:31 <bawwws> i guess no one is in #xmonad
22:04:41 <Cale> Yeah, I just checked and I've been using 2.7.2 with no problems
22:04:58 <Cale> bawwws: What's your question?
22:05:00 <bawwws> any ways, is there a way to manage terminal emulator?
22:05:15 <bawwws> like if had a workspace "coding"
22:05:33 <bawwws> and i open up a file with 'vim'
22:05:44 <bawwws> i want it to swithc it to "coding"
22:06:17 <bawwws> im using 'isInfixOf' function
22:06:21 <Cale> So, you want xmonad to watch what you're doing inside your terminal?
22:06:29 <pastorn> Xilon: hmm... writing something a bit more complicated here :)
22:06:30 <bawwws> to see if the WM_NAME consist of vim
22:06:39 <Cale> okay
22:06:42 <bawwws> yah
22:07:09 <Cale> (I don't actually use xmonad myself, but I can read the documentation and I know Haskell reasonably well :)
22:07:38 * hackagebot snap-core 0.1.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.1.1 (GregoryCollins)
22:08:38 * hackagebot snap-server 0.1.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.1.1 (GregoryCollins)
22:08:48 <Xilon> pastorn: It's just a hypothetical. In the real world it might be easier to structure the application better. I'll just start small for now :P
22:09:20 <bawwws> well ppl have been suggesting that i need to use 'title' to figure out if the window name is vim
22:09:32 <Xilon> bawwws: That's probably the easiest way
22:09:40 <Xilon> If not the only way :P
22:10:07 <Xilon> You just need the shell to set the term window's title
22:10:14 <wagle> i seem to remember 2-3 title-like-things from tcl's view of the window
22:10:15 <Cale> okay, so you probably want something like  title =? "vim" --> doShift coding
22:10:39 * hackagebot heist 0.1.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.1.1 (GregoryCollins)
22:10:43 <Cale> er, uncertain about associativity there, maybe you should write (title =? "vim") --> ...
22:10:44 <tensorpudding> Does vim not set WM_CLASS?
22:11:10 <Xilon> tensorpudding: vim doesn't "own" a window, the terminal does.
22:11:17 <wagle> oh terminal window?  nm..  i know nothing
22:11:20 <tensorpudding> Oh, you're not using gvim.
22:11:40 <tensorpudding> Doing that isn't going to work in all terminals, though.
22:11:41 <Cale> Oh, right, you want to use isInfixOf
22:11:42 <spahn> http://rcrowley.org/2008/03/03/functional-programming-in-c.html
22:11:43 <Cale> So...
22:11:45 <spahn> NEAT
22:11:54 <bawwws> yah gvim works using className
22:12:00 <spahn> that makes goofy languages like haskell obselete
22:12:08 <spahn> haskell: now even more obselete than lisp!
22:12:49 <Cale> (fmap ("vim" `isInfixOf`) title) --> ...
22:12:50 <tensorpudding> How can Haskell be more obsolete than a language that predates it by decades?
22:12:52 <bawwws> right now i have this: [(fmap ( c `isInfixOf`) title) --> doF (W.shift "3:code") | c <- vimTerm]
22:13:09 <Cale> okay
22:13:09 <bawwws> where vimTerm =["vim", "vim:"]
22:13:21 <Cale> that looks fairly sensible
22:13:23 <bawwws> but it still opens in the same workspace
22:13:28 <Cale> hmm
22:13:45 <spahn>  <tensorpudding> How can Haskell be more obsolete than a language that predates it by decades?
22:14:05 <spahn> because it's technically inferior to its anteceedent
22:14:11 <bawwws> well i think 'title' uses _NET_WM_NAME
22:14:30 <tensorpudding> They do say that ALGOL 68 was significantly better than many of its successors.
22:14:38 <Xilon> spahn: I stopped reading when I spotted "STL", it's C++ not C... If the author can't tell the difference, I doubt it's a good article.
22:15:41 <Cale> spahn: Function pointers are not the same thing as first class functions.
22:15:50 <spahn> Xilon you can still do the same thing in c - functional programming  - just use function pointers and structs
22:16:35 <Cale> spahn: You can, in C, explicitly build your own closures, and carry out a bunch of stuff that the compiler ought to be doing for you.
22:16:36 <pastorn> Xilon: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25635#a25635
22:16:43 <applicative> Xilon, he told the difference a little later.
22:16:45 <glguy> anything you can do in C you can do in plain assembly language
22:16:48 <Cale> spahn: But just using function pointers isn't the same.
22:17:06 <shapr> Yay! Heist and the rest of the Snap Framework is up on hackage!
22:17:10 <bawwws> Xilon: do i need to set vim's window a name?
22:17:13 <Grey_Fox> How to functionally program in C: There's a program called "glasgow haskell compiler", written in C!
22:17:26 <dolio> No there isn't.
22:17:30 <tensorpudding> GHC isn't written in C.
22:17:34 <Cale> Grey_Fox: Only a little bit of GHC is written in C.
22:17:36 <shapr> Grey_Fox: Trolling?
22:17:40 <Cale> Mostly it's written in Haskell
22:17:47 <pastorn> <3 <3 <3 hugs <3 <3 <3
22:17:50 <Cale> (and specifically, GHC Haskell :)
22:18:03 <Grey_Fox> ok, it's bootstrapped with C
22:18:04 <tensorpudding> There's a really big difference for readability and clarity comparing C to assembler, even if the wrapper is pretty thin
22:18:11 <Grey_Fox> C is involved in the process
22:18:15 <Xilon> bawwws: No, you just need your shell to set the term's window title to the command you run (e.g. the title would be "vim foo.hs"). I'm guessing the title is already set though
22:18:17 <tensorpudding> So is Perl.
22:18:28 <shapr> Grey_Fox: There's even machine code in there somewhere!
22:18:37 <tensorpudding> Though it's in the part of GHC that no one uses.
22:18:50 <pastorn> speaking of Perl... anyone know how the work on Pugs is going?
22:18:51 <Cale> spahn: First class functions have the property that they automatically carry along the values of any local variables which are in scope in the place where they are defined.
22:19:07 <shapr> Grey_Fox: I think the C code is used for bootstrapping on new arches.
22:19:23 <shapr> Grey_Fox: GHC requires GHC to build!
22:19:24 <Cale> spahn: Function pointers obviously can't do that, and you end up going to a lot of trouble to simulate it if you try to program in a functional style in C
22:19:35 <pastorn> i tried to get it installed once... everything broke down :(
22:19:42 <shapr> pastorn: C?
22:19:47 <shapr> oh, pugs
22:19:49 <Cale> (so much so that you're probably better off just giving up and writing a compiler for your new functional language)
22:21:10 <spahn> you have no idea what you're talking about
22:22:07 <glguy> spahn: if you aren't here to learn please consider moving on
22:22:56 <Cale> Well, I've been programming in functional languages for around 8 or 9 years or so, and in imperative languages including C and C++ going back maybe another 8 or 9 years before that
22:23:10 <bawwws> wow
22:23:14 <bawwws> you must have C down
22:23:15 <bawwws> lol
22:23:22 <Cale> That's not enough to know everything, sure.
22:23:25 <bawwws> i <3 C
22:23:36 <Cale> But I'd like to think that I have some idea of how these languages work ;)
22:25:57 <bawwws> hmmm i think i got the solution to my problem
22:26:02 <bawwws> thnx for the help
22:26:03 <bawwws> :D
22:27:48 <spahn> you'd better adjust your thinking
22:27:50 <Cale> spahn: Consider this simple example. One of the simplest functions at the heart of the functional programming style is the function called 'map' which takes as its parameter a function f, and produces a function which operates on lists of values of whatever type f wants -- just applying f to each of the elements of the list.
22:28:00 <Cale> So, for instance:
22:28:09 <Cale> @let square x = x*x
22:28:10 <lambdabot>  Defined.
22:28:15 <spahn> bbl
22:28:24 <Cale> Fine.
22:28:35 <blackdog> Cale: didn't wanna say it while he was still here, but seriously: how do you stay so patient?
22:28:45 <Cale> blackdog: :)
22:29:06 <pastorn> Xilon: looked at the paste?
22:29:09 <Xilon> Cale: While not pretty, it's possible to use map in C :P
22:29:42 <blackdog> it's bundling up the environment which is the problem usually, isn't it?
22:29:51 <Cale> blackdog: There are two possibilities. Either he knows better and he's trolling because he just wants to irritate people, in which case, being irritated would only give him satisfaction. Or, perhaps he just really doesn't know better, and I might be able to tell him something useful.
22:29:53 <dino-> I was thinking something like that too, blackdog. And glad you're here, Cale. You've taught me a lot of things.
22:30:00 <blackdog> more or less necessitates a GC
22:30:00 <Cale> blackdog: yeah
22:30:01 <bitstream0101> Cale: Still, very patient ;P
22:30:26 <Cale> Xilon: It's possible to write map, but the example I was going to use eventually was  map (map square)
22:30:35 <Cale> Xilon: Try writing that one in C ;)
22:30:42 <Cale> (it's awkward as hell)
22:30:47 <pastorn> Xilon: when using an IO function from within a monad transformer block (like StateT) you need to put 'lift' in front of your IO functions
22:30:50 <Xilon> pastorn: Yeah, but Person is trapped in IO
22:31:02 <pastorn> Xilon: of course :)
22:31:40 <jmcarthur> @quote troll
22:31:40 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
22:31:43 <jmcarthur> @quote troll
22:31:43 <lambdabot> qwe1234 says: stfu, troll.
22:31:44 <pastorn> Xilon: http://howdyworld.org/io-monad.jpg
22:31:46 <Cale> blackdog: and regardless of what I say to him, there are ~600 other people in this channel who can hear me say something which might be of use regardless
22:31:46 <Xilon> Cale: Yeah, I wouldn't recommend FP in C... Tried it once.
22:31:46 <jmcarthur> @quote troll
22:31:46 <lambdabot> qwe1234 says: stfu, troll.
22:31:49 <jmcarthur> meh
22:32:01 <dons> There it is! The first release of the Snap web framework for Haskell. Damn fast, multicore ready, did I say fast? http://is.gd/ck0qK
22:32:30 <dolio> I thought 'troll' seemed far more likely.
22:32:37 <blackdog> Cale: true enough. still, i admire the length of your fuse.
22:33:07 <dolio> It's too laughable to say that C makes Haskell obsolete for functional programming.
22:33:16 <bitstream0101> dons: But is it fast?
22:33:18 <jmcarthur> dons: well, it has a very pretty web page, that's for sure :)
22:33:34 <Cale> dolio: Well, yes, but if you don't know any Haskell, maybe you don't know that.
22:33:37 <dons> they're using libev underneath, and have some fine numbers
22:33:48 <Xilon> dolio: He didn't say "for functional programming", now that's a bold statement
22:33:59 <blackdog> dons: libev directly, or using bos/tibbe's stuff?
22:34:12 <Cale> dolio: (and while that's a pretty bad basis to be making claims like that, people say dumber things with more conviction all the time :)
22:34:15 <dons> libev, they're moving to haskell-event
22:34:47 <jmcarthur> dolio: either way, i'm with Cale in that taking being patient with a troll is more likely to end well for us and bad for the troll :)
22:34:58 <jmcarthur> *in that being patient
22:34:58 <pastorn> dons: this looks much nicer than the hoogle style ;)
22:35:00 <pastorn> http://snapframework.com/docs/latest/snap-core/Snap-Types.html
22:35:10 <dolio> Well, you could also just not respond at all.
22:35:12 <pastorn> is the style here all css stuff?
22:35:19 <dons> oh my
22:35:21 <blackdog> dons: just looking at the benchmarks...
22:35:29 <blackdog> poor little rails in the corner
22:35:29 <dons> nice css for haddocks
22:35:45 <dolio> Am I the only one getting Internal Server Error?
22:35:55 <dons> some heavy weights in the dev team
22:36:21 <dons> 20k + conn/sec rock it out yall
22:36:33 <pastorn> dons: check the source code as well... looks really pretty :D
22:36:35 <blackdog> I would have thought you could get a more meaningful comparison with things like Twisted et al,though
22:36:43 <pastorn> haha
22:36:45 <pastorn> 'runSnap'
22:36:46 * glguy likes how the snap css for haddock isn't compatible w/ safari
22:36:50 <pastorn> very good function name :D
22:36:59 <dolio> Ah, apparently it blows up when you attempt to view it in Konqueror.
22:37:08 <dons> safari is for lamers
22:37:22 <dino-> dons: Did you just say "y'all" without the apostrophe? :o
22:37:24 <glguy> i'll make a mac usre of you yet
22:37:26 <blackdog> and people with iPhones?
22:37:30 <pastorn> dons: you spelled it wrongly; it's "lamerz"
22:37:42 <dons> its a word in some dialect
22:37:44 <pastorn> blackdog: Opera is free
22:37:52 <glguy> "free"?
22:38:01 <dons> glguy: FREEDOM!
22:38:18 <gcollins> glguy: haddock produces awful markup and it is like pulling teeth to get it to look right anywhere
22:38:23 <blackdog> they may take our Flash, but they'l never take our freedom
22:38:26 * pastorn starts humming to Aretha...
22:38:44 <glguy> you can rip my freedom out of my cold dead... ooooh shiny!
22:38:50 <bitstream0101> haha
22:39:10 <pastorn> http://www.youtube.com/watch?v=wc0bmBRyxK4
22:39:19 <Cale> They make take our Flash, they may take our freedom, but they'll never take our smug sense of superiority!
22:39:49 <dons> gcollins: you ROCK
22:39:58 <gcollins> aww thanks
22:40:32 <byorgey> gcollins: congrats! looks nice =)
22:40:35 <gcollins> dons: maybe now i'll have time to fix the bugs in the osx installer
22:40:46 <dons> hehe
22:41:00 <gcollins> byorgey: thanks -- wish i could be at hac phi this year :(
22:41:13 <gcollins> send my regards to joyia
22:41:23 <jmcarthur> gcollins: this stuff looks rockin'
22:41:26 <gcollins> (did i spell that right?)
22:41:29 <dons> i'm loving the benchmarks of late. snap, blazeHTML
22:41:30 <byorgey> gcollins: yeah, wish you could be here too!
22:41:31 <dons> kicking butt
22:41:39 <byorgey> gcollins: thanks, I will.  yes, you did spell it right!
22:42:02 <gcollins> you guys were so nice to me last year -- best people
22:42:23 <gcollins> dons: i was really surprised to see us beating apache for fileserve, i still think there's something wrong with our apache config
22:42:52 <dons> oh apache
22:42:55 <gcollins> the benchmarks are not the most scientific unfortunately :(
22:43:16 <dons> httperf is about as good as it gets though
22:43:34 <pastorn> gcollins: what? using time is not sufficient?
22:43:42 <gcollins> :)
22:43:54 <gcollins> re: libev it's actually slightly slower than the native haskell stuff in our testing (a surprise), but doesn't have the annoying limitation of 1024 open file descriptors
22:43:54 <dons> glguy: http://hackage.haskell.org/package/snap-core-0.1.1 cerela
22:44:03 <dons> cereal. glaois.
22:44:21 <dons> bytestring-mmap ftw!
22:44:38 <gcollins> i think we're using cereal for the builder?
22:44:48 <gcollins> but the dependency could be dead actually
22:44:52 <bitstream0101> i like cereal.
22:44:55 <gcollins> me too
22:45:04 <bitstream0101> i used it extensively in halfs v2
22:45:21 <gcollins> sorry i take it back, we use it
22:45:21 * dons likes a stackload of galois projects are in there. open source policy works
22:45:30 <gcollins> dons: it's the best stuff :)
22:46:38 <dolio> Is the snap website hosted by snap?
22:47:09 <gcollins> yes
22:47:14 <gcollins> source code on our github page.
22:47:24 <pastorn> oh! i found this:
22:47:26 <gcollins> it's a mess
22:47:26 <pastorn> "Tabs are illegal"
22:47:26 <dolio> Ah. Well, snap doesn't like what Konqueror is sending to it, then.
22:47:32 <pastorn> gcollins: <3 <3 <3 <3 <3 <3 <3
22:47:36 <dolio> "bad 'accept encoding' header"
22:47:53 <gcollins> dolio: uh oh
22:47:59 <gcollins> which browser are you using
22:48:06 <gcollins> sorry
22:48:07 <gcollins> just say
22:48:11 <gcollins> s/say/saw
22:48:12 <dolio> Konqueror 4.4.2
22:48:56 <gcollins> can you send me the value of the header? we parse that field according to spec but it's possible we did it wrong or we should be more lenient
22:50:09 <gcollins> pastorn: tabs suck
22:50:16 <blackdog> gcollins: it does look very sweet, my carping aside:) might have a hack at getting a site up tonight, Erik's been hassling me to talk about web stuff in haskell at FP-Syd anyway:)
22:50:21 <dolio> I'm not sure how I would figure out what it's sending.
22:50:42 <gcollins> if you have netcat installed you can "nc -l -p 12345" and visit "localhost:12345"
22:50:50 <pastorn> gcollins: i'm looking at your style guidelines
22:50:56 <gcollins> pastorn: we stole them from tibbe
22:50:58 <gcollins> mostly
22:50:58 <pastorn> under Hanging Lambdas, the function foo
22:51:15 <gcollins> has a bug?
22:51:20 <pastorn> why not just write do { a <- alloca 10; .... }
22:51:32 <pastorn> what's wrong with do notation?
22:51:48 <BMeph> Are reflection and encapsulation at odds? Or is there a subtle difference in their definitions that allows a system to technically apply both at once?
22:52:12 <gcollins> pastorn: alloca is a "with" function and takes a lambda argument
22:52:22 <pastorn> oh, ok
22:52:27 <pastorn> it all looks very >>= too me
22:52:58 <dolio> gcollins: Accept-Encoding: x-gzip, x-deflate, gzip, deflate
22:53:13 <gcollins> and we're refusing that?
22:53:19 <gcollins> hm
22:53:24 * gcollins checks
22:54:04 <pastorn> gcollins: your style guidelines says "You may or may not indent the code following a “hanging” lambda"
22:54:14 <pastorn> which is all a bit too vague for me...
22:54:46 <blackdog> gcollins: might also be a good idea to have something like the "you're riding rails!" page in the template, just to make it stupidly easy...
22:55:28 <pastorn> blackdog: linky?
22:55:42 <gcollins> blackdog: i don't follow
22:56:26 <dolio> gcollins: By contrast, firefox sends "Accept-Encoding: gzip,deflate", so presumably it's the spaces in the comma-separated list, or the x-foo ones.
22:56:30 <copumpkin> @hoogle alloca
22:56:31 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
22:56:31 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:56:31 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:56:32 <blackdog> gcollins: oh, when you create a rails app, you get a page that says "congrats, you have a rails app! Here are some links to things you might do to continue developing" or something like that
22:57:40 <copumpkin> are we talking about snap?
22:57:45 <blackdog> copumpkin: yeah
22:57:59 <blackdog> am i talking to the wrong person?
22:58:09 <copumpkin> it looks nice :) but something struck me as soon as I looked at the first tutorial page
22:58:10 <gcollins> dolio: could be the "-" character
22:58:21 <gcollins> blackdog: we'll get there
22:58:27 <dons> gcollins: you're on front page of news.ycombinator
22:58:32 <gcollins> weird.
22:58:50 <dons> and programming.reddit.com
22:59:10 <dons> pity its not a monday morning -- way more traffic then
22:59:15 <gcollins> it's ok
22:59:29 <gcollins> it's hac phi :)
22:59:29 <dons> you can watch the server handle a reddit-izing
22:59:43 <gcollins> i'm not too worried about that
22:59:48 <dons> me neither
22:59:56 <copumpkin> oh does snapframework.com run on snap?
23:00:00 <Axman6> dons: which story are you talking about?
23:00:00 <gcollins> yep
23:00:02 <dons> ycombinator + reddit in optimal conditions prob. worth about 10k hits
23:00:10 <copumpkin> gcollins: you should write that on your page! :)
23:00:11 <dons> per day
23:00:18 <gcollins> copumpkin: that's a good point :)
23:00:22 <copumpkin> y'all need one of those lame badges
23:00:25 <dons> through more cores at it
23:00:28 <copumpkin> "proudly hosted on snap" or something
23:00:43 <dons> we put snap in your snap
23:02:04 <copumpkin> xzibit approves
23:02:16 <dons> oh snap
23:02:20 <gcollins> dolio: found your konqueror bug
23:02:27 <gcollins> patching & regression testing now
23:02:37 <Axman6> we put snap in your snap so you can oh snap while you snap
23:02:43 <Axman6> snap!
23:02:49 <dolio> Which was it? Or something else entirely?
23:02:52 * copumpkin snaps Axman6's neck
23:02:58 <copumpkin> O:-)
23:03:26 <dons> gcollins: does this release use the multicore io manager dispatch ?
23:03:50 <gcollins> you mean, with bos/tibbe's event lib?
23:03:51 <gcollins> no
23:03:58 <dons> no, the variant you were working on
23:04:05 <gcollins> you can link with libev by passing a -f flag
23:04:13 <gcollins> but i think you need darcs head of hlibev
23:04:24 <dons> that let it dispatch accept's on multiple cores
23:05:02 <gcollins> oh yeah
23:05:04 <gcollins> we do what
23:05:07 <dons> sweet
23:05:15 <gcollins> we forkIO numCapabilities accept loops
23:05:25 <dons> yeah.
23:05:28 <Axman6> nice
23:06:02 <Axman6> woah woah woah, those benchmark numbers look pretty damn impressive
23:06:30 <dons> damn straight, you knew it was coming, given the event numbers
23:06:36 <dons> gcollins: twitter likes you, http://twitter.com/#search?q=haskell
23:06:44 <Axman6> yeah
23:06:49 <Axman6> dayum though
23:07:03 <gcollins> dons: the feeling isn't mutual :)
23:07:09 <gcollins> although i work at a "social media" startup
23:07:14 <dons> heh
23:09:00 <dons> snap makes me happy
23:09:12 <Axman6> I hate webdev, and i'm excited
23:09:15 * copumpkin retweets too
23:09:20 <Axman6> high performance, fook yeah!
23:09:45 <mxc> gcollins - nice font selection on snapframework.com
23:10:02 <mxc> nice design in general
23:10:08 <hydo> Nice everything on snapframework.com ...
23:10:12 * dons is happy that perf. knowledge is widespread now
23:10:14 <hydo> Nice and clean.
23:10:28 <gcollins> thanks -- i didn't do much of the design work myself but will gladly take credit on behalf of james
23:10:30 <Axman6> yeah, its sexy
23:11:21 <hydo> I hope it's not -too- good... the framework, I mean.  I don't want to spend the weekend having to refactor $pretty_big_webapp.
23:11:48 <hydo> Though, it does look like it would be relatively easy.
23:11:56 <dons> up mods for snap, http://www.reddit.com/r/programming/comments/c6xmn/the_first_release_of_snap_a_haskell_web_framework/
23:12:01 <dons> http://www.reddit.com/r/programming/comments/c6xoj/snap_a_really_fast_haskell_web_framework/
23:12:18 <dons> http://news.ycombinator.com/item?id=1369852
23:12:54 <copumpkin> the hackage reddit link isn't so interesting to the general /r/programming community
23:13:01 <gcollins> true
23:13:01 <alexsuraci> how does snap compare to wai, as a server?
23:13:09 <gcollins> we haven't tested
23:13:12 <mxc> i like the haddock skin
23:13:12 <mxc> ]
23:13:15 <gcollins> snap-core is analogous to wai
23:13:16 <alex404> Anyone know why darcs would no longer work on my repository due to running out of stack space?
23:13:27 <copumpkin> dumb programmers don't want a list of properties from the cabal file :P they want a pretty website hosted on the same framework
23:13:32 <alex404> As in, why it's chewing up all the stack space all of a sudden?
23:13:34 <dons> heh
23:13:35 <alexsuraci> ah, ok. i just launched a site that uses wai yesterday. actually mostly a recode, was using hack before.
23:13:54 <alexsuraci> http://darcsden.com/
23:14:13 <copumpkin> alexsuraci: ooh, looks nice :)
23:14:18 <alexsuraci> (or for a bit more to look at, http://darcsden.com/alex )
23:14:21 <alexsuraci> copumpkin: thanks :)
23:14:31 * gcollins is really pleased to see so much haskell web activity lately
23:14:57 * dons joins #snap
23:14:59 <hydo> alexsuraci: How do you like wai, just in general?  I'm using Hack at the moment as well.  Looking at alternatives.
23:15:20 <copumpkin> alexsuraci: I think you have some extraneous text in your signup form though: http://snapplr.com/xq3f
23:15:49 <gcollins> dons: #snapframework
23:15:50 <dons> alexsuraci: cool that' you're using wai,
23:16:02 <copumpkin> nowai
23:16:11 <dons> why not #snap ??
23:16:16 <gcollins> um
23:16:16 <dons> we run this town.
23:16:18 <gcollins> hahahah
23:16:20 <alexsuraci> hydo: I haven't run any benchmarks so I can't really say, but the transition wasn't too painful, just a tad bit more involved
23:16:20 <copumpkin> it does seem easier to remember
23:16:29 <alexsuraci> copumpkin: you mean the "again" text?
23:16:29 <gcollins> no particular reason
23:16:36 <copumpkin> alexsuraci: yep
23:16:36 <gcollins> that's just where we've been hanging out
23:17:14 <alexsuraci> copumpkin: yeah I need to fix that, thanks for the heads-up. it should be aligned like the "optional, one per line" bit for the textarea, maybe I'll just put it to the right though.
23:17:34 <copumpkin> alexsuraci: I'm using a relatively recent webkit build, if that helps
23:17:41 <copumpkin> (in safari)
23:18:17 <dons> sweet. links #1 and #3 on news.ycombinator.com
23:18:17 <copumpkin> GOOGLE WAVE: NOW THE GENERAL PUBLIC IS FREE TO NOT USE WHAT TECH INSIDERS HAVEN'T BEEN USING FOR MONTHS
23:18:22 <alexsuraci> it looks the same here, looks like it's just a casualty of the template system transition (another tech I replaced; hstringtemplate -> hsp/hsx)
23:18:31 <dons> you'll get some traffic
23:18:37 <copumpkin> (shamelessly stolen from TacticalGrace's retweet)
23:18:50 <Kaidelong> copumpkin: very true
23:18:55 <copumpkin> gcollins: are you monitoring traffic? does it have traffic monitoring capabilities?
23:18:58 <alexsuraci> darcsden was around for a while but I recently gutted it and replaced pretty much all of the core technologies it uses. took about four days, staying up til 5 am. ;)
23:19:06 <Kaidelong> the horrible thing is that I'd use wave if other people actually used it
23:19:07 <gcollins> copumpkin: google analytics, that's it
23:19:12 <gcollins> and it's logging in combined format
23:19:15 <copumpkin> gcollins: ah cool
23:19:17 <hydo> Kaidelong: haha same here.
23:19:19 * BMeph thinks it ought to be #ohsnapframework
23:19:23 <Kaidelong> perhaps google should try to do gmail-to-gmail things as waves
23:19:25 <copumpkin> gcollins: see any spike in traffic?
23:19:25 <gcollins> :)
23:19:27 <Axman6> copumpkin: ha. i feel proud i was the one who introduced him to the non use of wave :P
23:19:33 <copumpkin> lol
23:19:39 <gcollins> copumpkin: not really looking yet -- trying to fix konq bug
23:19:50 <copumpkin> you can convince analytics to give you traffic for the current day
23:19:53 <dons> yeah ,focus on that.
23:19:56 <dons> traffic will be fine
23:20:08 <copumpkin> lol yeah, I wasn't pressuring
23:20:10 <copumpkin> just curious
23:20:27 <dons> ~7k / day is my guess for today.
23:21:05 <alexsuraci> i must be the only one here who uses wave ;)
23:21:26 <alexsuraci> seems to be great for coordinating client work at least
23:22:14 <JoeyA> Is nubBy left-biased?
23:22:25 <Axman6> @src numBy
23:22:25 <lambdabot> Source not found. You speak an infinite deal of nothing
23:22:29 <Axman6> @src nubBy
23:22:29 <lambdabot> nubBy eq []             =  []
23:22:29 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:23:48 <JoeyA> oh, I thought nub removed adjacent duplicates.
23:23:57 <Axman6> no
23:24:08 <JoeyA> @hoogle (Eq a) => [a] -> [a]
23:24:12 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
23:24:12 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
23:24:12 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
23:24:12 <Axman6> > nub [1,2,3,4,1,1,2,3]
23:24:13 <lambdabot>   [1,2,3,4]
23:24:45 <JoeyA> I thought there was a function that did that, similar to the uniq command in Unix.
23:25:13 <Axman6> map head . group does that
23:25:23 <JoeyA> oh right, group.  Thanks
23:25:32 <Axman6> > map head . group $ [1,2,3,2,2,2,3,2]
23:25:33 <lambdabot>   [1,2,3,2,3,2]
23:26:21 <alexsuraci> copumpkin: fixed the "again" bit (and that darcsden :: darcsden title, heh)
23:29:03 <copumpkin> alexsuraci: cool, I'll sign up in a bit :)
23:29:27 <alexsuraci> hydo: by the way, one thing about wai that had me stuck for a while was that it only binds on ipv6 on freebsd. hack might too, not sure. just a heads up; you'll want to use http://[::1]:xxxx/ for testing.
23:31:22 <hydo> alexsuraci: ugh! and also wtf?  wtf because i'm in the final stages of moving to fbsd for my ws and servers and it's weeeeerd that you felt compelled to mention that.
23:31:41 <hydo> you are psychic, methinks.
23:31:45 <alexsuraci> oh, and darcsden's source is at http://darcsden.com/alex/darcsden , nice and cabalised. you'll need couchdb though, running on 4895 (I may change that)
23:31:55 <alexsuraci> hydo: haha, glad it helped then. ;)
23:32:08 <alexsuraci> i just switched to freebsd myself
23:34:36 <glguy> alexsuraci: what was only binding on ipv6?
23:35:22 <alexsuraci> glguy: wai was. http://127.0.0.1:portnum/ would fail, but http:/[::1]:portnum/ worked.
23:35:25 <copumpkin> alexsuraci: omg it's GPL :P
23:35:42 * copumpkin ostracizes alexsuraci 
23:35:43 <glguy> What is wai?
23:35:49 <spahn> we have "monads" too, they're called immutable objects
23:36:06 * glguy finds it on hackage
23:36:10 <copumpkin> spahn: what prompted you to say that?
23:36:12 <dons> glguy: on hackage
23:36:27 <dons> from author of yesod et al
23:36:34 <alexsuraci> copumpkin: yeah i'm not a fan of gpl myself, for libraries at least.
23:36:52 <spahn> I don't see any advantage of using a "functional " language rather than applying functional principles in an OO paradigm
23:37:01 * glguy doesn't see network code in Wai
23:37:11 <copumpkin> spahn: I'm still not sure what you're responding to. And you seem to have a few misunderstandings
23:37:12 --- mode: ChanServ set +o dons
23:37:16 --- mode: dons set +b *!*b@*.49.23.98.dynamic.ip.windstream.net
23:37:16 --- kick: spahn was kicked by dons (bored)
23:37:18 --- mode: ChanServ set -o dons
23:37:21 <alexsuraci> glguy: sorry, it's in wai-extra: http://hackage.haskell.org/package/wai-extra
23:37:24 <Kaidelong> spahn: fundamentally the distinction between "declarative" and "imperative" is hollow
23:37:39 <alexsuraci> SimpleServer to be exact
23:37:43 <copumpkin> well, that was simple
23:37:46 <dons> i read the logs. that guy is 100% trying to steal our attention.
23:37:47 <Kaidelong> all algorithms can be represented as abstract state machines, whih are declarative
23:38:09 <copumpkin> dons: oh, he'd come here before?
23:38:31 <Kaidelong> ah I see he got kicked
23:39:12 <alexsuraci> copumpkin: actually come to think of it darcs is GPL, wouldn't that require darcsden to be GPL anyway?
23:39:28 <copumpkin> alexsuraci: depends
23:39:55 <Kaidelong> alexsuraci: the copyright holder is always allowed to re-liscence their product anyway, just not retroactively
23:40:04 <alexsuraci> right
23:40:12 <glguy> alexsuraci: What operating system are you using that wai-extras' run doesn't listen on ipv4?
23:40:28 <BMeph> Hmm, FSM in CPS...sounds both frightening and intriguing... :)
23:40:47 <alexsuraci> glguy: FreeBSD. might affect other *BSDs, but I don't know. I'd heard happstack had the same problem but they got around it.
23:41:07 * hackagebot snap-core 0.1.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.1.2 (GregoryCollins)
23:41:17 <glguy> Does FreeBSD not support embedding IPv4 addresses and connections in IPv6 addresses and sockets?
23:41:27 <glguy> i.e.   ::ffff:192.168.0.1
23:42:02 <alexsuraci> glguy: sorry, don't know enough about it to answer that. New to BSD myself.
23:43:06 <alexsuraci> glguy: a cursory glance here indicates it does support it: http://www.freebsd.org/doc/en/books/handbook/network-ipv6.html
23:43:09 <glguy> The way that listenOn is implemented it expects that behavior due to the way it makes the common mistake of taking the "head" of the results from getAddrInfo
23:46:06 <glguy> snap's http server is IPv4 only?
23:47:39 <Kaidelong> there is a pressing need for IPv6 anyway?
23:47:42 <pastorn> oh snap!
23:47:55 <gcollins> glguy: as of right now, yes -- making it otherwise would not be a quantum leap but we haven't had the need
23:47:55 <glguy> No, but you basically have to go out of your way not to support it at this point
23:49:24 <gcollins> glguy: i agree but i've read enough complaints about happstack and wai only binding to ipv6 addresses that i decided to sidestep the headache for now
23:50:07 <glguy> gcollins: only binding to IPv6 is often because people call head on the getAddrInfo output
23:50:24 <glguy> and then proceed to only bind to the resulting IPv6 addrino
23:50:27 <gcollins> glguy: i will gladly accept any patches you might write :)
23:50:59 <gcollins> to be honest i am personally pretty ignorant about ipv6, haven't deployed it ever
23:51:47 <glguy> gcollins: I'll fix it if I ever have a use for snap
23:52:00 <glguy> but otherwise I just want ot make sure people in the channel know that head of getAddrInfo isn't what you want
23:52:16 <glguy> neither is Network.listenOn
23:52:26 * gcollins nods
