00:01:23 <tomberek> how can i learn more about constraint terms?
00:12:28 <ketil> Anybody know why ghc-pkg hide doesn't hide the package from cabal?  'Setup configure' still wants to compile against the hidden version, causing a conflict later on.
00:13:28 * FunctorSalad wonders how far you could take TH AST-builder combinators that look almost like real haskell
00:13:41 <FunctorSalad> seems like it'd lower the barrier to getting started with TH
00:14:00 <kmc> why would that be preferable to quoting?
00:14:23 <FunctorSalad> hmm, more control?
00:14:44 <FunctorSalad> say, you want to generate the fundep clause programmatically
00:16:27 <FunctorSalad> you could have a typeclass for, say, data declarations, with method data_ and the instances corresponding to one with a class constraint clause, one without one, etc
00:16:40 <FunctorSalad> instead of always having to specify the empty context to the DataD ctor
00:18:40 <FunctorSalad> kmc: at least in elisp recently I found that constructing forms using plain functions (that operate on formal expressions) can be less confusing than backquote
00:18:51 <FunctorSalad> if you have more that one level of nesting
00:19:00 <kmc> cool idea
00:19:24 <FunctorSalad> (I think highlighting of backquote level would work too, though :))
00:22:42 <JuanDaugherty> what is the current situation wrt to any haskell ide? Is the one where you can compile and symbols are xref'ed to their definitions?
00:22:50 <JuanDaugherty> *there one
00:23:09 <Axman6> i've never felt any need for an IDE for haskell
00:23:22 <blackdog> Axman6: what a tremendously helpful answer:)
00:23:31 <Axman6> thanks :)
00:23:32 <Axman6> :P
00:23:36 <JuanDaugherty> no, a negative response is still useful info
00:23:47 <JuanDaugherty> if confirmed
00:23:50 <blackdog> JuanDaugherty: there's leksah, but it's still in the early stages
00:23:51 <Axman6> i also haven't heard any news on the progress of leksah
00:23:59 <kmc> last i checked it would only auto-complete keywords
00:24:06 <blackdog> I find Emacs with ghc-mod quite useful - you get on-the-fly syntax checking
00:24:07 <Axman6> :\
00:24:33 <apolon> i am a haskell super-newbie, but the yi project seems very intriguing -- making emacs in haskell :)
00:24:40 <apolon> could be the ultimate ide ever
00:25:14 <Axman6> it's somewhat more than emacs in haskell, it's also got vi bindings, and a few others
00:25:14 <kmc> many a beginner is of this opinion
00:25:15 <apolon> i wonder why it never got off the ground
00:25:16 <blackdog> apolon: long way away yet
00:25:23 <JuanDaugherty> well that was the hope about 4 years ago or so
00:25:24 <blackdog> emacs is huge
00:25:25 <kmc> then they realize yi won't even build
00:25:36 <Axman6> heh
00:25:40 <kmc> it is a cool project but it needs much love
00:25:46 <apolon> :"(
00:25:55 <JuanDaugherty> after a while when Zarkwand doesn't show up the natives get restless
00:25:59 <Axman6> the idea's nice, but i think it's mostly seen as reinventing the wheel
00:26:26 <apolon> but hey -- we do need to reinvent the emacs wheel!!  come on -- it's made of emacs lisp!!!
00:26:47 <apolon> how disgusting is that
00:26:52 <blackdog> apolon: it's still the best thing out there, unfortunately
00:26:57 <Axman6> speaking of reinventing the wheel, i'd quite like to see the xc scheme project rewritten in haskell. i have a feeling getting 90% of the functionality should be almost trivial
00:27:16 <blackdog> xc scheme?
00:27:20 * kmc types "cabal install yi" and watchen das blinkenlights
00:27:27 <kmc> it is compiling a lot of useful stuff
00:27:40 <JuanDaugherty> also, unless I'm mistaken, leksah is almost as old ad yi
00:27:47 <blackdog> righto. completely wrecked. g'night all.
00:27:47 <JuanDaugherty> *as
00:28:09 <Axman6> it's like 5:30 o.O
00:28:14 <apolon> blackdog: i know.  it's what i always use.  but it's sad to realize that emacs doesn't have a future, unless it is rewritten _fundamentally_
00:28:37 <JuanDaugherty> why is that apolon ?
00:29:02 <Axman6> blackdog: http://wiki.freaks-unidos.net/xc#introduction
00:29:12 <Axman6> basically bc rewritten and made better
00:29:19 <apolon> JD: http://www.emacswiki.org/emacs/WhyDoesElispSuck
00:29:30 <JuanDaugherty> k
00:30:15 <apolon> the end of the page is evidently the most informative
00:31:13 <JuanDaugherty> i'm guessin the age of the average haskeller is 23.
00:31:49 <JuanDaugherty> half or so, say that of the average lisp or squeaker
00:35:19 <clarkb> dcolish:
00:35:28 <apolon> @let y x = x (y x)
00:35:29 <lambdabot>  <local>:1:9:
00:35:29 <lambdabot>      Ambiguous occurrence `y'
00:35:29 <lambdabot>      It could refer to either `L....
00:35:37 <JuanDaugherty> though the age of most of the name contributors about a decade more
00:35:51 <JuanDaugherty> *avg age
00:36:23 <Axman6> :t let y x = x (y x) in y
00:36:24 <lambdabot> forall t. (t -> t) -> t
00:36:37 <Axman6> > let y x = x (y x) in y (const 1)
00:36:38 <lambdabot>   1
00:37:49 <apolon> > let y x = x (y x) in y (\x -> x)
00:37:53 <lambdabot>   mueval-core: Time limit exceeded
00:37:56 <kmc> wow, yi built!
00:37:57 <apolon> yay!!
00:38:10 <Axman6> :t let y x = x (y x) in y (1:)
00:38:11 <lambdabot> forall t. (Num t) => [t]
00:38:19 <Axman6> > let y x = x (y x) in y (1:)
00:38:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:38:39 <Axman6> > let y x = x (y x) in y ((1:). map (+1))
00:38:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:38:52 <apolon> >let y x = x (y x) in y (\x -> y x)
00:39:38 <apolon> > let y x = x (y x) in y (\x -> y x)
00:39:39 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
00:40:09 <apolon> one thing that's always bugged me: why can't I turn off the occurs check?
00:41:07 <kmc> i doubt infinite types would play well with other things like inference
00:41:27 <kmc> i can't say for sure what the problem is, but it's far from obvious, to me, that allowing them would be okay
00:41:37 <apolon> sure, but why can't you disable it just when you want to?
00:42:11 <apolon> also, pure hindley-milner inference doesn't care about recursive types -- they are just unification equations, that's all
00:42:20 <FunctorSalad> JuanDaugherty: ghci and through it the haskell-mode already has goto-definition, but only for loaded stuff, not for imported, I think
00:42:23 <kmc> it's true
00:43:40 <FunctorSalad> adding completion to haskell-mode would be a very low-hanging fruit since ghci already does it...
00:44:00 <FunctorSalad> at least for someone who knows how to best add a completion function in emacs ;)
00:44:03 <JuanDaugherty> thanks FunctorSalad, sort of the complete scope of the source though was what was described
00:44:26 <JuanDaugherty> and uh yeah
00:44:32 <JuanDaugherty> I was thinking of slime
00:45:01 <JuanDaugherty> and the various other ide's that do do
00:45:04 <ivanm> FunctorSalad: IIUC, the comint-mode stuff that haskell-mode uses doesn't work with ghci's tab-completion :s
00:45:28 <FunctorSalad> ivanm: yep. I wondered why it doesn't use whatevery M-x term uses, instead
00:45:34 <FunctorSalad> that seems to be in "raw mode"
00:45:44 <ivanm> yeah
00:46:01 <apolon> does anybody know if there's a usable gtk frontend to yi?
00:46:03 <FunctorSalad> in fact, M-x term asks you for a program, I'll just try 'ghci' ;)
00:46:15 <JuanDaugherty> emacs or eclipse would seem like the right place short of the NIH, it has to be haskell based yi/leksah type deals
00:46:39 <FunctorSalad> ivanm: works
00:46:55 <ivanm> FunctorSalad: but does C-c C-l work? ;-)
00:46:57 <FunctorSalad> it'd just need integration with the haskell-mode
00:47:27 <FunctorSalad> comint mode feels soooo clunky somehow ;)
00:47:33 <FunctorSalad> not sure why
00:48:45 <apolon> why isn't there a cabalized gtk2hs anyway?
00:48:50 <kmc> they're working on it
00:49:28 <ivanm> apolon: first of all, gtk2hs predates Cabal + Hackage
00:49:39 <ivanm> secondly, it's a set of inter-mingled libraries
00:49:50 <ivanm> thirdly, c2hs didn't use to play nicely with Cabal
00:49:57 <ivanm> now they seem to have solved these problems however
00:50:32 <FunctorSalad> can one have a less intimidating haddock covering just gtk now? ;)
00:50:37 <apolon> i see
00:50:53 <FunctorSalad> (not all the other packs)
00:51:59 <apolon> well for some reason I can't build gtk2hs from source
00:52:26 <FunctorSalad> darcs trackdown cabal install *grin*
00:52:51 <ivanm> apolon: with ghc 6.12?
00:53:02 <apolon> yep
00:53:11 <FunctorSalad> darcs version?
00:53:20 <apolon> 2.4.1
00:53:42 <FunctorSalad> err, I mean you need a recent source of gtk2hs, not the stable 0.10
00:54:09 <apolon> it asked me for a password when i tried to follow instructions on their page
00:54:29 <ivanm> apolon: yeah, there's a patch to get it to work with 6.12.1 (and then you need to edit a line of the source for a fix with 6.12.2)
00:54:42 <ivanm> FunctorSalad: I've gotten stable gtk2hs working on 6.12.2...
00:55:06 <apolon> wait, my ghc is 6.12.1, not .2
00:55:14 <ivanm> even easier then
00:55:14 <FunctorSalad> apolon: darcs get http://code.haskell.org/gtk2hs
00:55:18 <FunctorSalad> shouldn't ask for a pass
00:55:37 <FunctorSalad> ivanm: hmm maybe it's a new stable ;)
00:55:45 <ivanm> FunctorSalad: nope
00:55:49 <FunctorSalad> the one I mean fails with a Make error early
00:55:57 <ivanm> trofi and I got the ebuilt to patch it
00:55:59 <ivanm> ;-)
00:56:07 <apolon> ok, so i shouldn't update ghc to 12.2?
00:56:09 <FunctorSalad> in some line involving ghc-pkg action
00:56:24 <ivanm> apolon: you can, you just need to edit one line in a source file then
00:56:31 <ivanm> (if you're still building for a release)
00:57:24 <apolon> darcs copying patches...
00:57:40 <FunctorSalad> apolon: that'll take a long time
00:57:43 <ivanm> here's dcoutts' patch: http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00484.html
00:57:50 <FunctorSalad> there's 'darcs get --partial' too
00:57:55 <ivanm> FunctorSalad: are they still using darcs-1?
00:57:59 <FunctorSalad> not sure what exactly it does
00:58:14 <FunctorSalad> ivanm: hmm dunno
00:58:33 <ivanm> --partial doesn't get removed patches, etc. IIRC
00:58:44 <ivanm> --lazy (in darcs-2) just gets a copy of pristine IIRC
00:58:45 <apolon> it's almost halfway done
01:00:03 <ivanm> is it just me, or is the description of haskell's type system here not quite right? http://james-iry.blogspot.com/2010/05/types-la-chart.html
01:00:47 <ivanm> e.g. isn't FFI part of the Haskell98 (revised) standard?
01:01:08 <ivanm> and calling "GHC Haskell"s type system "impure" because of unsafe* is just crazy
01:02:47 * hackagebot repa-examples 1.1.1.0 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-1.1.1.0 (BenLippmeier)
01:03:00 <ksf> gragh. if people like to be standards nazis, they should at least do it properly.
01:03:09 <ivanm> ksf: hmmm?
01:03:13 <ivanm> Axman6: ^^
01:03:16 <kmc> i don't agree
01:03:30 <ksf> yet another package that won't compile due to GLDouble being a newtype is scenegraph, due to hmatrix
01:03:42 <kmc> adding unsafeCoerce to the language is a big deal
01:03:48 <ivanm> huh?
01:03:52 <Axman6> o/ i
01:03:56 <Axman6> o/ ivanm*
01:04:00 <ivanm> ksf: what does scenegraph have to do with hmatrix?
01:04:02 <ivanm> hey Axman6
01:04:09 <ksf> it uses it
01:04:13 <kmc> of course that y axis there is not a single axis
01:04:14 <apolon> ok, it got all the patches now
01:04:16 <ivanm> does it? oh...
01:04:18 <kmc> but i see the point
01:04:23 <ivanm> kmc: yeah
01:04:28 <ivanm> but i think ksf is talking about something else ;-)
01:04:34 <ivanm> greetings m3ga
01:04:34 <apolon> how do i apply the patch now?
01:04:42 <ivanm> apolon: it's already in the darcs repo
01:04:46 <kmc> i was not-agreeing with you ivanm
01:04:50 <ksf> ...if at least I could do standalone newtype deriving.
01:04:54 <kmc> also, Haskell's type system does not have "strict, statically enforced wall between side effecting expressions and non-side effecting ones"
01:04:54 <ksf> ...but stuff isn't in scope.
01:04:55 <ivanm> kmc: oh
01:05:02 <m3ga> ivanm: howdy!
01:05:14 <ivanm> ksf: well scenegraph is apandoned...
01:05:22 <kmc> impure functions in Haskell have type no different from pure ones
01:05:25 <ksf> somehow, people like to break stuff for no good reason at all.
01:05:26 <xenoblitz> am trying to install darcs on Haskell Platform 2009.2.0.2 but am getting the error  * Missing header file: curl/curl.h * Missing C libraries: curl, curl, any ideas?
01:05:35 <kmc> it's just that you almost never run into them as an ordinary user
01:05:35 <ksf> another example is CLDouble
01:05:41 <ivanm> ksf: and the problem is probably that hmatrix had an backwards-incompatible API change but scenegraph doesn't use versioned dependencies
01:05:54 <ivanm> xenoblitz: install curl or disable building with curl
01:06:05 <xenoblitz> ivanm: thanks will try that
01:06:09 <ksf> the problem is that hmatrix doesn't come with an instance for Field Double
01:06:12 <ksf> er GLDouble
01:06:23 <Philippa> kmc: a -> IO b is an 'impure function', or at least isomorphic to one and commonly referred to as such
01:06:23 <ksf> ...and it hides the functions of Field
01:06:24 <ivanm> xenoblitz: it does kinda imply that you have to install curl though ;-)
01:06:33 <kmc> Philippa, not really
01:06:36 <ksf> ...as OpenGL hides the constructor of GLDouble
01:06:47 <xenoblitz> ivanm: yeah duh! I kinda thought cabal would take care of that... my bad
01:06:47 <kmc> Philippa, it's an important part of the semantics of Haskell that evaluation and execution are separate
01:06:59 <ivanm> xenoblitz: you mean cabal-install?
01:07:10 <Philippa> kmc: that doesn't break the isomorphism though, it just means it's got to be called a particular way
01:07:23 <ivanm> note that cabal-install is not a package manager and only deals with cabalised packages (and can only do dependency stuff for packages on hackage)
01:07:25 <ksf> ivanm, I was thinking of reviving it, but I'm also investigating lambdacube
01:07:35 <kmc> Philippa, i don't disagree
01:07:54 <xenoblitz> ivanm: oh... sorry for the newbie question but I thought curl was a haskell package
01:08:03 <Philippa> then be less anal :-) You wouldn't tell someone off for describing a function as taking two parameters, would you?
01:08:17 <ivanm> xenoblitz: there is one, which just binds to the curl C library
01:08:18 <kmc> Philippa, depending on the context
01:08:24 <kmc> it is a pretty big deal here
01:08:27 <ivanm> and the error does say "missing C libraries" ;-)
01:08:41 <kmc> it's not as though this is some trivial issue of nomenclature
01:08:43 <xenoblitz> ivanm: yeah... curse my laptop for coming with vista... hehe
01:08:52 <xenoblitz> ivanm: how can i disable curl when installing darcs?
01:09:05 <ksf> ivanm, regarding back-wards incompatible changes, it's opengl's fault, which changed GLDouble from a type alias to a newtype
01:09:08 <Philippa> it's much the same as far as whether that separation of pure from impure exists and is enforced by the type system
01:09:17 <ivanm> xenoblitz: ummm.... --flags=-curl I think, but then it uses an awfully old version of the haskell http library instead :s
01:09:25 <ivanm> xenoblitz: are you using windows perchance?
01:09:31 <ivanm> oh, wait, you said you are
01:09:38 <Axman6> xenoblitz: i have a very strong feeling darcs needs curl to operate for anything other than locally
01:09:38 <xenoblitz> ivanm: yeah vista... can I install curls somehow?
01:09:39 <ivanm> xenoblitz: I think there's binary installers for windows on the darcs homepage
01:09:48 <Philippa> to put it another way: give an example of how that phrasing is dangerous or misleading to someone who's at least loosely aware of the isomorphism in play?
01:09:52 <xenoblitz> ivanm: hmmm let me see
01:09:54 <ivanm> Axman6: technically it doesn't, --flags=http or some such
01:10:03 <Axman6> righto
01:10:05 <ivanm> ksf: ahhhh, I thought you were blaming hmatrix
01:10:19 <ivanm> ksf: it should have had an upper bound on the opengl dep though...
01:10:28 <kmc> Philippa, if you're aware of the isomorphism then you already understand that a function of type (a -> IO b) is not really an impure function
01:10:45 <xenoblitz> ivanm,Axman6: yeah there is a binary! silly me... thanks guys :)
01:10:54 <ivanm> no worries
01:10:54 <ksf> I'd rather have the opengl devs think about how much stuff they break before making such changes
01:11:09 <ivanm> Axman6: but that brings in http-3000, which nothing else uses nowadays AFAIK
01:11:27 * ksf considers forking a opengl-nonewtype
01:11:31 <Philippa> it is, just up to isomorphism rather than equality. unsafe* aside, it's the only notion of impure function Haskell supports
01:11:44 <ivanm> ksf: ... or update scenegraph
01:12:21 <ksf> I'd either have to move from hmatrix to something that supports gldouble, or make hmatrix support gldouble
01:12:27 <kmc> and up to isomorphism, Either () a is the same as Maybe a.  but i'd be annoyed with someone who used the types interchangeably when teaching to beginners
01:12:38 <kmc> it's likely to cause confusion
01:12:48 <ivanm> ksf: you can't just convert to/from the newtype and the value it wraps?
01:12:54 <Botje> kmc: Either () a has one value more than Maybe a, no?
01:13:04 <kmc> Left undefined
01:13:06 <kmc> it's true ;P
01:13:16 <Botje> so does it still count as isomorphic?
01:13:20 <kmc> no
01:13:24 <ksf> I'd have to wrap the whole Field typeclass, and its methods aren't exported
01:13:28 <kmc> Philippa, i think it's really essential to understand that evaluation and execution are separate
01:13:33 <Botje> okay, i didn't understand it wrong then :)
01:13:52 <Philippa> yet I'd be similarly annoyed with someone who insisted on talking explicitly about the curried view and never ever just saying n-ary function. So long as you know "impure functions are separated out" you can happily reason about them. Less true of Either () a / Maybe a (and we'll ignore the spare _|_, shall we?)
01:14:03 <kmc> and i think pointing out that putStrLn is a pure function is a good way to emphasize this
01:14:12 <kmc> to emphasize that its application has no side effect
01:14:21 <kmc> which really is an important part of the semantics, and not just a bit of notation
01:14:41 <Philippa> yes. But the right thing to do is present both views, not to deny the notion of 'impure function'
01:16:39 <Philippa> you're going to do all the legwork either way, may as well offer the opportunity to take advantage of that isomorphism and clear up a little conceptual clutter
01:17:05 <kmc> the "impure function" treatment is a lot more cluttered
01:17:12 <ksf> ivanm, do you know why scenegraph is abandoned?
01:17:12 <Philippa> otherwise you end up in zomg scary monads territory
01:18:01 <Philippa> not really, it describes the language embedded via the monad which is a style of language that many programmers /already understand/. Never underestimate the value of legitimately reusing knowledge
01:18:36 <kmc> then people will expect that evaluating an (IO a) value will have some effect
01:19:12 <Philippa> right up until you tell them "impure functions in Haskell behave like this". IOW, you give them the delta, don't just tell them it's identical to what they've done before
01:19:42 <kmc> what's the point? the delta is more complicated and confusing than explaining how it "really works"
01:19:46 <Philippa> and that's something you're going to have to explain either way, that's the essential complexity
01:19:48 <kmc> i have had little trouble with the latter approach here
01:19:51 <kmc> and have used it many times
01:20:10 <Philippa> and I've had little trouble with the former
01:20:39 <kmc> "zomg scary monads" is a problem of introducing the type class, the extra generality, and the scary name
01:20:44 <apolon> hm, I still can't build gtk2hs
01:20:47 <kmc> most people have little trouble understanding what an "IO recipe" is
01:20:53 <kmc> and how evaluating it isn't the same as executing it
01:22:35 <Philippa> *nod*. But IME people who've already done imperative programming have little trouble understanding it as an "IO function" or an "IO program" either. Evaluation vs execution is no harder with that view
01:22:57 <Philippa> I'm not saying your approach is intrinsically bad: I'm saying mine isn't either
01:23:26 <apolon> how do I build the local copy of the darcs repository?
01:23:42 <FunctorSalad> iirc you start with autoreconf
01:23:48 <Philippa> and in the meantime? Talking in terms of the isomorphism is a hell of a lot easier for discussing the relevant features with people who aren't haskellers because you get straight to the meat of what it lets you do, no extraneous concepts involved
01:23:49 <FunctorSalad> then ./configure
01:24:04 <Philippa> for the purposes of that article, evaluation vs execution is irrelevant detail
01:24:38 <FunctorSalad> @ apolon was that
01:24:39 <apolon> can't exec libtoolize
01:25:05 <apolon> no such file
01:25:06 <FunctorSalad> hmm is that part of autoreconf?
01:25:07 <apolon> or directory
01:25:09 <FunctorSalad> no idea
01:25:37 <apolon> Use of uninitialized value $libtoolize in pattern match (m//) at /usr/bin/autoreconf line 186.
01:26:20 <FunctorSalad> what you're *not* supposed to do is to cabal install by hand, unless this is the new cabalized version already?
01:26:28 <FunctorSalad> (which I haven't tried)
01:26:55 <apolon> well autoreconf isn't working
01:27:23 <glguy__> I think that it interesting to look at an instance of the continuation monad as the "double negation" monad http://www.galois.com/~emertens/doubleneg/mymonad.html
01:27:24 <FunctorSalad> no idea if the current darcs is the cabalized version
01:27:37 <FunctorSalad> then the build procedure will be different :)
01:27:47 <FunctorSalad> look at the INSTALL file?
01:27:53 <apolon> that doesn't help
01:28:45 <apolon> is there specific file which can be autoconf'd?
01:30:40 <Baughn> kpreid: http://lesswrong.com/lw/26x/open_thread_may_2010/1z4w <-- Have this. Hm. I didn't realize you read lesswrong. :)
01:32:05 <apolon> there's still some bug with autoreconf
01:32:18 <Baughn> @seen kpreid
01:32:18 <lambdabot> Unknown command, try @list
01:32:21 <FunctorSalad> apolon: someone who knows what the current state of the gtk2hs build system is will be more helpful than me ;)
01:32:28 <FunctorSalad> as I said, it's in change right now
01:33:55 <apolon> ok, thanks FS
01:34:08 <apolon> I think now i will get it eventually
01:34:23 <FunctorSalad> sure your autoreconf is ok? that error message seems suspicious
01:34:36 <FunctorSalad> or does autoreconf error in its own file if the input is wrong
01:35:19 <apolon> i didn't have libtool (why didn't apt-get install it automatically?")
01:35:24 <apolon> now autoconf works
01:35:30 <apolon> but which file do i run it on?
01:35:42 <apolon> configure.ac.stale?
01:35:57 <FunctorSalad> no argument, last time I checked
01:36:13 <apolon> autoreconf: `configure.ac' or `configure.in' is required
01:36:39 <FunctorSalad> hmm... I have a configure.ac there
01:36:51 <apolon> hm... ok i'll copy it
01:36:55 <FunctorSalad> but can't pull the latest version for some reason
01:37:02 <FunctorSalad> (of gtk2hs)
01:37:21 <apolon> geez
01:37:41 <apolon> now it's missing a bunch of cabal files
01:38:03 <FunctorSalad> maybe check out the mailing list for what is currently going on
01:38:38 <FunctorSalad> maybe it *is* cabalized now, not make-based
01:39:23 <apolon> if it is, can it be installed with one command?
01:43:18 <FunctorSalad> my INSTALL file says which version of autoreconf and automake you need, btw
01:43:22 <FunctorSalad> maybe that's the error
01:44:12 <apolon> apparently it HAS been cabalized: http://haskell.org/gtk2hs/
01:44:18 <ivanm> apolon: only in darcs
01:44:27 <ivanm> (which you got)
01:45:20 <apolon> that's great
01:45:36 <apolon> but the source wasn't building anyway
01:46:50 <apolon> so is it such a bitch to build the cabalized version?  if yes, how do I build the older one?
01:47:12 <ivanm> ummm, there's some bootstrapping script you need IIRC
01:47:18 <ivanm> preflex: seen ManateeLazyCat
01:47:18 <preflex>  ManateeLazyCat was last seen on #ghc 16 hours, 3 minutes and 11 seconds ago, saying: Igloo: Thanks for explain, maybe we need write notes in gtk2hs homepage to avoid users install 6.12.2 (even it's really bad).
01:48:45 <apolon> apparently, the bootstrap needs the add-ons (cairo,glib,gtk,pango..) to be installed first
01:53:25 <glguy__> Neat OS X trick, hold down ⌥ when you click the wireless menu to get details about the network you are connecting to
01:54:01 <sioraiocht> huh, thanks glguy__ =)
01:54:35 <Axman6> glguy__: i do wish it showed the IP address though
01:55:19 <glguy__> Axman6, I use the iStat Pro widget which, among other things, shows that
01:55:43 <Axman6> i'm really disappointed that iStat Menus is now a paid app :(
01:55:49 <Axman6> an overpriced one at that
01:57:48 <quicksilver> Axman6: that's the apple way :) Overpriced applications which are thin wrappers around provided API calls. XCode + interface builder + apple docs + 25 lines of original code = $25.
01:58:35 <Axman6> no it's not, most apps for macs are quite reasonably priced. this one is quite overpriced for what it does. it should be no more than $7
01:58:44 <Axman6> they'd make more money if they dropped the price too
01:59:11 <jlouis> morning
01:59:56 <Axman6> o/ jlouis
02:01:42 * glguy__ discovers that option-brightness option-volumeup and option-exposé (function keys) bring up control panels
02:02:15 <glguy__> hopefully there is no single key press I can do that will be particularly destructive
02:02:19 <glguy__> I'm searching them all now
02:03:42 <ivanm> Axman6: see, whereas I can't recall the last time I actually bought software
02:03:53 <Axman6> there is an instareboot i think (bypasses the 'your computer will shut down in X seconds" window)
02:03:56 <ivanm> (the copy of VIsta, etc. that came with my laptop don't count)
02:04:15 <ivanm> probably a game I bought as a gift for someone or something... >_>
02:04:21 <Axman6> ivanm: you're an evil man then, you should support your fellow developers ;)
02:04:33 <ivanm> Axman6: I do! I write libraries for them to use!
02:04:47 * ivanm points out that he is a CSer/mathematician, not a "programmer"
02:04:48 <Axman6> how does that help them feed their kids?
02:05:23 <ivanm> Axman6: you're trying to tell me they really slaved away at those apps for that huge amount of time?
02:05:36 <Axman6> yes
02:05:36 <ivanm> little utility apps that you write to scratch an itch should be free IMHO
02:05:59 <ivanm> Axman6: if it does take them that long to do, then I'm glad I don't use Obj-C :p
02:06:06 <Axman6> well written and polished apps are worth a small amount of cash imo
02:06:55 <ivanm> Axman6: and I refuse to pay for virtual items; if I do buy software I expect a physical item
02:06:56 <DigitalKiwi> glguy__: your tail is getting longer
02:07:06 <DigitalKiwi> or is that not a tail and you're just rowdy
02:07:07 <glguy__> that’ll happen
02:09:07 <koala_man> ivanm: like a t-shirt?
02:09:33 <ivanm> koala_man: I meant more a CD or something so that I can re-install that program without proving that yes, I did pay for it
02:09:48 <ivanm> (of course, DRM on said CDs makes that harder to do easily as well...)
02:10:24 <koala_man> isn't having that cd the same as proving that yes, you did pay for it?
02:10:52 <koala_man> would it be different from having a paper disc with a license key on it?
02:10:58 <ivanm> koala_man: I meant in the sense that with windows licensing, etc. its a PITA to reinstall
02:11:05 <Axman6> isn't having a licence key the same, without wasting those materials making the CD and box and shipping it and all that nonsense?
02:11:06 <ivanm> (since you have to un-register, re-register, etc.)
02:11:49 <koala_man> ah, I haven't tried that. last time I reinstalled, I pirated windows so I wouldn't have to flush the rest of my system with the oem restore
02:12:01 <ivanm> heh
02:12:15 <ivanm> koala_man: exactly, and people wonder why people pirate
02:13:07 <ivanm> Axman6: and if the company goes bust and you can't download it anymore (or their online activation site is no longer there)?
02:13:13 <ksf> wth I'm getting linker errors
02:13:43 <Axman6> ivanm: and your CD snaps/gets scratched/gets lost?
02:13:49 <Axman6> its all the same
02:14:14 <ivanm> Axman6: store it carefully in a secure place
02:14:16 <ivanm> make backups
02:14:17 <ivanm> etc.
02:14:32 <Axman6> make a backup of the software in a secure place...
02:14:36 <koala_man> I've had tons of CDs in secure places that rotted after less than 5 years
02:14:49 <Axman6> there's no difference, you're just wasting much more resources than need to be
02:14:55 <ivanm> Axman6: oh, so itunes will let you do that for your iphone/ipad apps?
02:15:00 <ksf> ...looks like it's not finding symbols that are part of non-exposed modules
02:15:07 <Axman6> yes, it does that for you
02:15:20 <ivanm> better solution: only use FLOSS software that people will mirror/fork if the main site goes down!
02:15:38 <ksf> yeah, that's it.
02:15:43 <ksf> how can such a thing be?
02:15:43 <ivanm> Axman6: I was under the impression you had to re-download them again to install on a new phone if you upgrade...
02:15:51 <Axman6> no
02:16:09 <apolon> is anybody here familiar with grapefruit?
02:16:22 <Axman6> yes, they're delicious
02:16:23 * ivanm doesn't like the taste of grapefruit...
02:16:34 <apolon> but do they compile with containers-0.3.0.0?
02:16:37 <apolon> cabal: dependencies conflict: gtk-0.10.5 requires containers ==0.3.0.0 however
02:16:37 <apolon> containers-0.3.0.0 was excluded because grapefruit-frp-0.0.0.0 requires
02:16:37 <apolon> containers >=0.1 && <0.3
02:17:15 <ivanm> apolon: probably will, just hack the cabal file
02:17:26 <ksf> with a bit of luck it compiles with >=0.3
02:17:26 <apolon> thx will do
02:17:36 <apolon> wait
02:17:40 <ivanm> but I find it strange that gtk explicitly needs containers 0.3
02:17:56 <ivanm> IIRC, 0.3 _removed_ stuff, didn't add anything
02:18:04 <apolon> isn't there a command-line version switch so that I don't have to download it explicitly?
02:18:31 <ivanm> ummm.... not sure if you can override deps on the command line
02:18:38 <ivanm> apolon: cabal unpack grapefruit-frp
02:18:40 <apolon> no????
02:18:52 <ivanm> you can _stricten_ deps, but I don't think you can loosen them
02:20:18 <Entroacceptor> why not?
02:20:22 <Entroacceptor> feels like a missing switch
02:20:32 <Entroacceptor> just a 'try to compile anyway'
02:20:32 <apolon> i concur
02:21:10 <ksf> I thought cabal was a build system on steroids, not a package manager?
02:21:11 <apolon> woah!  what does this mean
02:21:12 <apolon> containers-0.3.0.0 was excluded because grapefruit-frp-0.0.0.0 requires
02:21:12 <apolon> containers >=0.1 && <=0.3
02:21:21 <ksf> a build system should be able to do such things
02:21:26 <ivanm> nope, you can specify _additional_ constraints
02:21:27 <ivanm> that's it
02:21:41 <ivanm> ksf: Cabal is a library for building, etc.
02:21:52 <ivanm> not a build system
02:22:06 <ivanm> as for cabal-install; if you want it, I'm sure dcoutts accepts patches!
02:22:40 <apolon> I have a question
02:22:45 <ksf> I don't want such things.
02:22:58 <Entroacceptor> that's good, I have an answer
02:23:02 <ivanm> apolon: you're in luck, the asking of questions is half price today!
02:23:13 <apolon> why does 0.3 <= 0.3.0.0 evaluate to False
02:23:23 <apolon> i mean the other way around
02:23:32 <ksf> I want a 2.5D scenegraph library with gl drawing and mouse click support
02:23:45 <Entroacceptor> fractal dimensions?
02:23:46 <ivanm> apolon: because there's a difference between Version [0,3] and Version [0,3,0,0]
02:23:53 <ksf> nope, two and a half
02:23:58 <ivanm> > compare [0,3] [0,3,0,0]
02:23:59 <lambdabot>   LT
02:24:31 <ksf> that is, the camera always looks straight down the z axis
02:24:59 <ivanm> > "0.3" `compare` "0.3.0.0"
02:25:00 <lambdabot>   LT
02:25:31 <ksf> ...though full 3d support might be useful for debug purposes. it's not needed in general, though.
02:25:44 <apolon> > compare [0,3,0,0] [0,3]
02:25:45 <lambdabot>   GT
02:25:53 <ksf> ...which simplifies e.g. raycasting to select an object _way_ easier.
02:26:05 <apolon> doesn't 3/10 = 300/1000 ?
02:26:42 <Axman6> apolon: it uses lexagraphic comparison (string comparison)
02:26:46 <ivanm> apolon: except versions aren't numbers
02:26:54 <ivanm> Axman6: no it doesn't
02:26:59 <Axman6> so "0300" > "03"
02:27:02 <ivanm> it compares [Int]
02:27:10 <apolon> Building grapefruit-frp-0.0.0.0...
02:27:10 <apolon> [ 8 of 16] Compiling Internal.Signal  ( src/Internal/Signal.hs, dist/build/Internal/Signal.o )
02:27:10 <apolon> src/Internal/Signal.hs:59:4:
02:27:10 <apolon>     Illegal polymorphic or qualified type: forall era'. signal era' val
02:27:10 <apolon>     Perhaps you intended to use -XImpredicativeTypes
02:27:11 <apolon>     When checking the class method:
02:27:13 <apolon>       osfSwitch :: SSignal era (forall era'. signal era' val)
02:27:15 <apolon>                    -> signal era val
02:27:17 <apolon>     In the class declaration for `Signal'
02:27:17 <Axman6> yes, in the way that strings are compaqred
02:27:18 <ksf> a famous example of 2.5d is parallax scrolling, and also doom, though in a different way
02:27:32 <ivanm> Axman6: true
02:27:35 <ksf> (doom having no real notion of height)
02:27:48 <ivanm> apolon: use a paste site for long pastes
02:28:07 <apolon> where is the paste site?
02:28:13 <Axman6> @where hpaste
02:28:13 <lambdabot> http://hpaste.org/
02:28:20 <apolon> @where hpaste
02:28:20 <lambdabot> http://hpaste.org/
02:28:36 <ksf> doom could actually said to be 2.75d, if wolfenstein is 2.5d
02:28:41 <apolon> 500 Internal Server Error
02:28:41 <apolon> 58030 14: unable to open database file
02:29:19 <Entroacceptor> and duke3d would be 2.83d?
02:32:45 <apolon> so how do you use hpaste?
02:33:22 <apolon> also, is grapefruit dead?
02:33:23 <arcatan> it seems to be broken
02:35:24 <ivanm> apolon: you get a new paste, put the stuff you want to paste in the window, click paste/submit (whatever the button is called) and then paste the link to the paste here
02:35:59 <Saizan> ivanm: except when the database is locked and you've to look for another pastebin
02:36:05 <Saizan> such as pastebin.com
02:36:07 <ivanm> or that
02:37:27 <apolon> like this? http://pastebin.com/Z3SacMh6
02:37:47 <ksf> grapefruit is an academic project
02:38:17 <ksf> producing something one can use never seemed to be their priority
02:38:22 <Axman6> hmm, what's supposed to be so hard about pthreads?
02:38:35 <ksf> lock-based programming?
02:38:47 <Axman6> what if you have no real need for locks?
02:39:10 <apolon> hm... do you know of anything that is almost as cool but can be used at the same time?
02:39:14 <idnar> Axman6: then why use threads?
02:39:22 <Axman6> concurrency
02:39:39 <ksf> if you don't need to synchronize, just use processes
02:39:42 <idnar> I can't think of a situation offhand where you wouldn't need threads, but you couldn't use processes
02:39:51 <Axman6> handling multiple connections at once. the choices are using fork or pthreads
02:39:55 <ksf> pthreads and processes are nearly the same thing under linux, anyway.
02:40:07 <ksf> or epoll
02:40:08 <idnar> processes have the advantage that you can't accidentally screw it up
02:40:21 <idnar> but yeah, for handling multiple connections, I would use neither
02:40:25 <Axman6> this is supposed to be using only POSIX API's i think
02:40:31 <Jafet> c10k?
02:40:33 <Axman6> anyway, OS X doesn't have epoll
02:40:34 <idnar> select()/poll() then
02:40:35 <ksf> then use select
02:40:43 <idnar> OS X has kqueue, I think?
02:40:50 <idnar> since it's a BSD
02:41:01 <ksf> Axman6, google for "tibbe event"
02:41:02 <Axman6> it needs to run on linux too ;)
02:41:09 <Axman6> this is in C
02:41:12 <idnar> Axman6: then use libevent or something
02:41:14 <ksf> you're going to find a github repo
02:42:29 <ivanm> @google tibbe event
02:42:31 <lambdabot> http://github.com/tibbe/event
02:42:31 <lambdabot> Title: tibbe's event at master - GitHub
02:42:40 <Axman6> anyway, what we've got to do (this is an assignment) is create a LDAP TCP proxy, that allows connections via IPv4 (and possibly 6), and connect to an IPv6 LDAP server. i have a feeling that using threads could make this quite easy
02:42:59 <Jafet> Are you talking about pthreads or Thread?
02:43:12 <ivanm> Axman6: you are aware of the homework help policy of this channel, aren't you? :p
02:43:12 <apolon> sooooo all this FRP + GUI business doesn't really exist???
02:43:17 <Jafet> (One is not scalable, the other may not be scalable)
02:43:24 <ivanm> apolon: FRP is still a moving target atm
02:43:46 <Axman6> ivanm: yes, that we don't give out answers. i'm was asking for oppinions in general, and giving the specific use case, not asking for help ;)
02:44:10 <Axman6> Jafet: pthreads... i'm not sure what you're referring to by thread
02:44:33 <ivanm> Axman6: _sure_ you were
02:44:34 <ivanm> ;-)
02:44:52 <Axman6> i'm quite confident my friend and i can do this assignment on our own
02:45:03 <apolon> ivanm: in the scientific sense or the implementational sense?
02:45:38 <ivanm> apolon: kinda both; IIRC conal is still working out the best way of doing it
02:45:55 <ksf> conal has been awfully quiet as of late
02:45:59 <apolon> and why didn't they at least finish implementing a GUI toolkit based on FRP as it is currently defined?
02:46:52 <Jafet> Whoops
02:46:54 <ivanm> apolon: different people are doing it
02:47:17 <Jafet> Is Marlow's 2000 HTTP server paper still relevant? You may want to read it
02:47:28 <apolon> ok, but the fact is, if i have to revert to pre-6.12 versions of everything in order to just have a look at grapefruit, that is _seriously_ lame!
02:47:33 <Axman6> ksf: didn't he get a job somewhere?
02:47:42 <ksf> dunno
02:47:51 <apolon> ivanm: which people are actively doing it?
02:48:01 * ksf is passively doing it
02:48:13 <ivanm> apolon: the FRP GUI? no idea
02:48:26 <Jafet> Axman6, if you want to accept many connections, pthread per connection is a poor choice, especially for linux
02:48:35 <tibbe> someone googled me :)
02:48:38 <ksf> ...and I'm leaning towards elerea
02:48:43 <ksf> for the simple reason that it _works_
02:48:45 <tibbe> I monitor google searches for my name ;)
02:48:51 <Axman6> Jafet: what makes it a poor choise over fork?
02:49:05 <Jafet> Hmm, I guess you could do worse, like use fork.
02:49:14 <Axman6> yeah, the other choice is fork
02:49:17 <Jafet> I assume you also mean fork(2), not forkIO
02:49:20 <apolon> ksf, how's elerea?
02:49:35 <ksf> unsafePerformIOy and working
02:49:36 <apolon> (it wasn't in the lists I saw)
02:49:38 <Axman6> the assignment asks for fork(2), but the lecturer has said that pthreads are ok
02:49:47 <ksf> it's got a similar interface as reactive
02:49:53 <ksf> ...applicative, that is
02:50:13 <Jafet> Axman6, so the point of the assignment is actually to use POSIX forking or threading?
02:50:39 <ksf> and unlike reactive it doesn't re-invent all of newtonian physics+modern math in its implementation
02:50:44 <Axman6> it's a networking assingment, the main point is to make a proxy. but one of the tasks is to use some sort of concurrency
02:51:03 <Axman6> Jafet: if you're really interested, i can give you the assignment url
02:51:12 <ksf> Axman6, beware of premature excellence.
02:51:31 <Axman6> ksf: too late, i'm already excellent :(
02:51:35 <Axman6> :)
02:51:46 <`0660> Axman6, why wouldn't you just use fork?
02:51:57 <Axman6> because i don't like fork
02:52:00 <apolon> one of the elerea's listed features is: "has absolutely no formal foundations"
02:52:03 <`0660> i think it would be an excellent way to solve this problem
02:52:17 <Axman6> i've used fork before, and haven't used pthreads, and i'd like to learn something new :)
02:52:23 <`0660> especially if they are expecting it
02:52:29 <`0660> ok :)
02:52:47 <ksf> apolon, check out the examples
02:52:49 <Axman6> i think the idea of fork is kind of cool, though somewhat clunky
02:54:22 <apolon> omg, Frag looks sooooo awesome......
03:00:14 <Jafet> Hmm. Does it look too good to be real? Will it shake the field of video games? Is it the end of the world for impure programming?
03:02:47 <hants> how do you install frag? via cabal?
03:03:46 <apolon> eh, just watchced the video, not that impressive.  would be cool if it was multiplayer though
03:05:32 <apolon> but it's about time someone ported quake to haskell!
03:07:56 <Cale> apolon: It's not really that fun to play, but it's a rather decent proof of concept, which I think is all that it was ever trying to be
03:09:00 <apolon> yeah, i guess it was only that
03:09:03 <Philippa> apolon: porting Quake 1 wouldn't even be that hard. Complete with QuakeC
03:09:18 <ksf> lambdacube has a bsp loader by now
03:09:30 <apolon> lambdacube?
03:09:40 <ksf> @hackage lambdacube-engine
03:09:40 <lambdabot> http://hackage.haskell.org/package/lambdacube-engine
03:09:46 <apolon> barendregt's cube of typed lambda calculi? :P
03:10:21 <apolon> oh, i see.  looks nice!
03:10:23 <ksf> iirc there's another 3d engine with cube in its name
03:11:34 <Jafet> http://sauerbraten.com
03:11:56 <Jafet> The only thing not nice about that engine is, it's literally all cubes (try making a sphere in it)
03:12:24 <ksf> reminds me of tomb raider
03:13:10 <apolon> well i think i'm finished learning haskell for today.  thanks a lot everybody!
03:13:33 <arcatan> I've learned all the Haskell.
03:13:35 <ksf> I've also seen shots of a game where all geometry was made out of single-coloured ellipsoids (pre hardware-3d times)
03:13:40 <ksf> don't recall the name
03:14:28 <ksf> both, in their own way, make for playable world that aren't a pain to look at
03:17:16 <ksf> *the day I stopped worrying and decided against an r-tree*
03:18:45 <ksf> then, regarding guis, there's this: http://www.cuddletech.com/edje/docs/html/edje_book.html
03:19:04 <ksf> I'm genuinely surprised how denotional edje is
03:19:52 <ksf> otoh, it shouldn't come as a surpsire as it's the twentieth or so gui lib that the enlightenment guys did
03:20:16 <Axman6> huh, how did not know about asprintf until today?
03:22:11 <Jafet> Because it's useless
03:22:46 <Axman6> useless?
03:23:21 <kulin> if i have: instance Ord a => Ord (EitherKey a b) where
03:23:31 <kulin> what do i do to also state that b should be of typeclass Ord?
03:24:26 <Axman6> (Ord a, Ord b)
03:24:42 <kulin> hah of course, didnt try that :)
03:24:58 <Axman6> though, i don't see how you're going to be able to implement compare (Left a) (Right b)
03:25:10 <kulin> LT
03:25:13 <kulin> and GT if other way
03:25:46 <Axman6> fair enough
03:26:02 <Axman6> so Left < Right for all values. makes sense i guess
03:26:59 <kulin> ya, its just an arbitrary choice on my part, i just need it to work for Data.Map and it needs Ord for the tree (i'm guessing)
03:28:16 <quicksilver> you can just use deriving Ord to get that arbitrary choice automatically made :)
03:28:41 <kulin> well i need the eq to not be as arbitrary
03:28:45 <Axman6> don't you then have to redefine Either though?
03:29:06 <kulin> because (Left a) = (Both a b)
03:29:33 <kulin> well the full type is: data EitherKey a b = BothKeys a b | LeftKey a | RightKey b
03:30:08 <quicksilver> kulin: it might matter if your Eq conflicts with the automatic Ord, yes.
03:30:15 <quicksilver> but will it?
03:30:30 <kulin> I'm not sure, and I dont want to leave it to chance
03:30:44 <kulin> this type is sort of nonsense
03:30:57 <quicksilver> :)
03:31:03 <ksf> that's (Maybe a, Maybe b)
03:31:05 <ksf> well, nearly
03:31:16 <quicksilver> well the automatic eq instance would be the obvious one
03:31:23 <quicksilver> i.e. you have to be the same constructor and the same values
03:31:26 <quicksilver> is that what you want?
03:31:29 <kulin> nope
03:31:49 <ksf> you want leq and req, too, I think
03:32:08 <quicksilver> I actually don't know if it matters if a synthetic Ord instance doesn't agree with Eq, for the purpose of using Data.Map
03:32:15 <ksf> that is leq (BothKeys l _) (LeftKey a) = l == a
03:32:16 <kulin> I want for you to do "lookup (LeftKey 1) m" and find a value which was set with "insert (EitherKey 1 4) 5 m"
03:32:19 <quicksilver> probably not; since Data.Map never uses ==
03:32:49 <quicksilver> I'm wrong. Data.MAp does use ==. Of course it does.
03:33:01 <ksf> Eq = not > && not <
03:33:02 <quicksilver> I was misled by the constraint not appearing, but that's because it's implied by Ord.
03:33:36 <kulin> leq?
03:33:42 <ksf> eq on the left side
03:33:53 <quicksilver> still I'm pretty sure Data.Map is designed for structural equality.
03:34:04 <ksf> or do you actually want to have two maps?
03:34:08 <quicksilver> it might have an invariant which breaks with this weaker equality.
03:34:26 <quicksilver> certainly it needs the Ord instance to be total
03:34:37 <quicksilver> and it will overwrite 'equal' keys.
03:34:42 <kulin> what I am doing is equivalent to maintaining two maps
03:34:56 <kulin> its just that Data.Map.delete should never leave the map in a bad state with my way
03:34:59 <ksf> e.g. what happens if you lookup LeftKey 1 and you have BothKeys 1 2 and BothKeys 1 3 in the map?
03:35:00 <kulin> which is all I am after
03:35:26 <kulin> that cant exist in my map
03:35:30 <kulin> but i'm not sure
03:36:05 <ksf> you could have a look at gmap and see if some combination does what you want
03:36:15 <quicksilver> ksf has a good question.
03:36:23 <quicksilver> would you have BothKeys 1 2 == BothKeys 1 3 ?
03:36:39 <quicksilver> hmm no this isn't going to work. definitely not.
03:36:47 <quicksilver> 'BothKeys 1 9' needs to work for 1 and 9
03:36:54 <quicksilver> that means it has to be in the map in two places?
03:37:02 <quicksilver> which side of 'BothKeys 5 5' does it go?
03:37:08 <kulin> what?
03:37:14 <kulin> you guys are overthinking a hack way too much
03:37:22 <quicksilver> that's what we do here.
03:37:32 <ksf> never, ever hack data structures.
03:37:58 <ksf> if ever, do it in the fastest way that has the exact semantics you need
03:38:02 <quicksilver> let me restate my question more carefully though kulin
03:38:12 <ksf> but never, ever, make a data structure with the wrong semantics
03:38:14 <quicksilver> 'BothKeys 1 9' has to work for both LeftKey1 and RightKey 9, correct?
03:38:24 <kulin> yes
03:38:37 <quicksilver> so how will the Ord instance compare it with BothKeys 5 5 ?
03:38:56 <kulin> if left key is found (or i might change it to right) it just sorts off that and ignores the second
03:39:01 <ksf> it doesn't know that both are ints
03:39:10 <kulin> the whole point is that there is a primary id in this map (in my case a sessionid) and an alternate id
03:39:23 * ksf thinks you want two maps
03:39:32 <quicksilver> in that case, kulin , RightKey 9 won't work.
03:39:43 <kulin> two maps would work just as well for this, but i would need to maintain both maps, which i dont want to do
03:39:48 <quicksilver> LeftKey 1 will find it, but RightKey 9 won't because it will be 'in the wrong place'
03:39:54 <ksf> write lookupSession and lookupAlternate functions, get the semantics straight, worry about implementation later
03:40:02 <quicksilver> it's been sorted by its first key
03:40:22 <kulin> oh i see what yer saying quicksilver
03:40:41 <kulin> the map backend is stored in some tree so who knows where this is ending up
03:40:51 <kulin> for some reason i was thinking it did an O(n) search
03:40:54 <kulin> which it doesnt obviously
03:41:01 <ksf> it's log(n) or even better
03:41:07 <kulin> ya
03:41:34 <kulin> well its no biggy to change it to two maps
03:41:40 <ksf> in any case, I recommend abstracting away the data structure(s) that back your usage
03:41:43 <kulin> just seems so weird that there isnt a standard module for this
03:42:02 <ksf> nothing sucks more than having to go through 100 files and change a function.
03:42:03 <kulin> i feel that this would be perfectly abstract if it worked
03:42:16 <kulin> EitherKey is a pretty generic concept
03:42:42 <ksf> gmap comes with an Either instance
03:43:56 <ksf> another approach is having one map SessionID -> Session and another AltId -> SessionID
03:47:37 <kulin> Oh well I guess 4am is gonna have to be my stopping time, I'll checkout GMap later, thanks ksf and quicksilver
03:47:55 <quicksilver> I do agree that recipes for combining maps would be nice
03:48:05 <ksf> gmap does that
03:48:08 * quicksilver nods
03:48:23 <ksf> the only thing keeping it from being perfect is a type family to select instances
03:49:38 <quicksilver> "The type-level syntax for creating maps is currently unwieldy. This will improve significantly in the next version" ... he wrote in 2008 :-(
03:49:40 <ksf> like here: http://webcache.googleusercontent.com/search?q=cache:n7YDPTYhfosJ:hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D24320+hpaste+data.gmap.auto&cd=1&hl=de&ct=clnk&gl=de&client=firefox-a
03:50:17 <ksf> the thing that worries me is MapOf Char = EnumMap Char
03:50:35 <ksf> as type families won't support Enum a => MapOf a = EnumMap a
03:51:02 <quicksilver> well, neither should they, that's an overlapping family waiting to happen.
03:51:02 <ksf> but then families are open.
03:51:22 <quicksilver> it's annoying but it's necessary the way things are right now
03:51:27 <Gooffy> hi, folks!
03:51:27 <Gooffy> in articles about GADT i often see mention that ones can be used for static ensuring binary trees's balance. but unfortunately, i can not found any examples or papers about this technique, only safeList and so on. Can anyone give a link to related work? thanks :)
03:51:29 <ksf> yeah you're right, Int is enum.
03:51:35 <xenoblitz> i am trying to cabalize a small project of mine using cabal init but I keep getting "setup.exe: ghc-pkg.exe: unrecognized option `--no-user-package-conf'" when I attempt to update cabal-install... anyone?
03:51:42 <quicksilver> ksf: so is double :) :-(
03:52:38 <quicksilver> Gooffy: sounds like the kind of thing people say but it's fiddly and uncomfortable in practice so they don't do it
03:52:45 <quicksilver> I've not seen it done at least
03:52:47 <xenoblitz> if it helps (probably) I am using ghc 6.8.3
03:53:08 <ksf> yes, it does.
03:53:24 <ksf> Now I'm able to say "bleeding use an up to date version" ;)
03:54:05 <Gooffy> quicksilver: oh, thanks :) maybe you may notice any another interesting practical example of using GADTs ?
03:54:07 <xenoblitz> ksf: i wish! but my project fails to compile with any other version of ghc higher due to its dependence on gtk2hs 0.9.13
03:54:39 <ksf> there's been lots of pain+problems with cabal-install and windows
03:54:56 <ksf> you can write your foo.cabal manually, though.
03:55:25 <ksf> ...though newer versions of cabal-install might compile with 6.8
03:55:45 <xenoblitz> ksf: was hoping not to do that as its my first time... I was gonna see the output to get a good idea of how to write a good cabal package
03:56:05 <xenoblitz> ksf: i tried to update but it keeps getting stuck when it tries to use ghc-pkg... any idea what that is?
03:56:19 <ksf> that's ghc's package manager
03:56:38 <ksf> the one that does the actual package registering and lookup and everything
03:57:29 <xenoblitz> ksf: so there is no way I guess... I have to update ghc and rewrite my code?
03:57:39 <xenoblitz> or do it manually
03:57:51 <ksf> just do it manually
03:57:55 <ksf> there's not a lot you can do wrong
03:58:04 <ksf> ...assuming you read the docs, that is.
03:58:23 <xenoblitz> okey will give it a shot... btw... what's the standard license used?
03:58:43 <ksf> hackage is largely BSD3
03:58:49 <xenoblitz> ok thanks I will look it up
04:00:18 <ksf> which is mostly due to people who otherwise would prefer gpl realise that a broader industrial involvment currently serves haskell better than openness at all costs
04:00:27 <ksf> lgpl makes sense, too, of course.
04:00:36 <ksf> ...at least on linux, that is.
04:01:18 <xenoblitz> unfortunately I am really green when it comes to licenses and what is correct to use and whatnot
04:01:43 <ksf> oh, btw, we should have a cabal flag to force dynamic linking for lgpl packages
04:02:13 <Jafet> This is the best time to indoctrinate your plastic brain with a particular intellectual property idealogy
04:02:36 <ksf> in a nutshell, bsd gives the most freedom to developers, whereas gpl gives the most freedom to the code
04:02:54 <aavogt> the best way to convince people some way is to write software with said licence
04:02:55 <Saizan> xenoblitz: which version of cabal-install are you using?
04:03:04 <ksf> bsd allows incorporation into closed source, gpl forbids it, and lgpl allows closed source to dynamically link to your code
04:03:12 <aavogt> cf. pandoc
04:03:29 <ksf> cf. readline...
04:03:37 <xenoblitz> Saizan: i am using ghc 6.8.3 and simply downloaded the cabal exe from its website
04:03:39 <Jafet> And WTFPL gives the finger
04:03:46 <xenoblitz> Saizan: hope that answers your question
04:04:19 <ksf> heh. I planed on writing the JGFL
04:04:22 <Saizan> xenoblitz: cabal --version , though i guess it's a recent one
04:04:33 <ksf> which is bsd cross-bred with the free beer license
04:04:45 <xenoblitz> Saizan: 1.6.0.2
04:05:05 <ksf> where the authors reserve the right to refer to anyone who sends beer or does other actions deemed appropriate for a jolly good fellow as a "jolly good fellow"
04:06:11 <ksf> another interesting license I came across is the enlightenment one, which is bsd with attribution but compatible with gpl
04:06:23 <ksf> ...requiring you to give attribution only if you don't distribute source.
04:07:11 <Saizan> xenoblitz: i'd try "cabal install Cabal"
04:07:43 <xenoblitz> Saizan: I think its breaks as well... let me try
04:07:51 <ksf> we could make such a thing the default choice, whith attribution going to "The Haskell Community (haskell.org)"
04:09:36 <Jafet> You forgot the obvious...
04:09:41 <Jafet> ... attribution to "The Cabal".
04:09:54 <ivanm> preflex: seen sinelaw
04:09:54 <preflex>  sinelaw was last seen on #haskell 19 days, 15 hours, 8 minutes and 48 seconds ago, saying: hi all
04:10:07 <xenoblitz> Saizan: same error :( want me to hpaste?
04:10:10 <ksf> The Hackage Cabal?
04:10:33 <ivanm> there is no such secret shadowy organisation known as the Haskell Cabal!
04:10:43 <ivanm> dcoutts said so himself!
04:10:44 <ivanm> ;-)
04:11:12 <Saizan> xenoblitz: it was a shot in the dark, i wouldn't know how to help, i'm not even sure if that version of cabal-install supports 6.8.x
04:11:19 <xenoblitz> er... hpaste.org seems to be down
04:11:23 <Saizan> or Cabal, maybe
04:11:43 <ivanm> Saizan: dcoutts tests Cabal up to 6.2 IIRC
04:11:48 <xenoblitz> Saizan: thanks I will do it manually as ksf suggested earlier
04:12:09 <Saizan> ivanm: i think that's outdated information :)
04:12:23 <ivanm> Saizan: that he tests it? it isn't!
04:12:35 <Saizan> the 6.2 part
04:13:28 * ksf considers everything requiring <=6.6 as bitrotten, and everything <= 6.8 as most likely bitrotten
04:13:57 <ksf> although there's pleasant surprises, sometimes
04:14:07 <Jafet> Them puny bits
04:14:12 <ivanm> Saizan: well, 6.4 then
04:15:05 <xenoblitz> er where can i read about licences without having to go into all the details... I mean I just want to share  something without it being exploited without reference to me somehow... that's all ... is BSD3 what I need?
04:15:05 <ksf> and hopefully compatiblity will raise again with uhc coming out
04:15:27 <ksf> what do you mean with "exploited"?
04:15:47 <ivanm> xenoblitz: short version: BSD3 says you can do whatever you want with this as long as you attribute that I wrote it originally but don't say that I endorse what you've done
04:15:47 <xenoblitz> ksf: used
04:15:55 <ivanm> MIT is the same but drops that no-endorsement bit
04:16:26 <ksf> used as in run, used in another project, or...?
04:16:36 <ivanm> GPL-{2,3} says you can do whatever you want as long as you attribute me _and_ if you make any changes you have to make the source available as well (so that your users can do whatever they want with your code)
04:16:50 <ivanm> BSD3/MIT can go in proprietary code; GPL can't
04:16:58 <ksf> (where "attribute" in both cases means "leaving the copyright headers intact")
04:17:20 <xenoblitz> mehhh i hate legal mumbo-jumbo when i write code :(
04:17:41 <ivanm> ksf: and the LICENSE file
04:17:42 <Jafet> ivanm, only if you distribute the changed code
04:17:44 <ksf> if in doubt, do gpl, you can always re-license later
04:17:45 <Jafet> (Or binary)
04:17:52 <ivanm> Jafet: right
04:18:08 <ivanm> I was simplifying it though
04:18:51 <xenoblitz> so as a student who just wants to share something and get credit what is suggested?
04:19:00 <xenoblitz> GPL3 or  BSD3?
04:19:04 <ksf> if you want credit, you can't use gpl
04:19:11 <ivanm> ksf: huh?
04:19:14 <ksf> that'd be BSD4 (four clauses), then
04:19:39 <ivanm> ksf: "get credit" == "you have to acknowledge that its mine and not strip off the copyright statements"
04:19:40 <xenoblitz> may I head-slam my desk now?
04:19:57 <xenoblitz> lol
04:20:01 <ivanm> xenoblitz: do you want to let it go into proprietary projects?
04:20:13 <Jafet> First you make sure that your institute won't try to claim it, as some do.
04:20:24 <ivanm> Jafet: AFAIK, if you're a student you own your work
04:20:29 <xenoblitz> Jafet raises a good point
04:20:31 <Jafet> In which case, you try to get a pseudonym on hackage (haha)
04:20:32 <ksf> they can't if you didn't sign away your first-born
04:20:42 <xenoblitz> well my university does have "royality" issues
04:20:44 <Jafet> ivanm, in most places, fortunately
04:20:48 <ivanm> then again, I just read on thedailywtf.com today where some professor basically got students to fulfil a contract he made to make a website...
04:21:05 <xenoblitz> sigh
04:21:11 <xenoblitz> I am at a loss
04:21:15 <ksf> I bet that's against some law or the other
04:21:31 <xenoblitz> I am at a loss
04:21:34 <ivanm> ksf: yup, but you have to be able to catch them out (and in this case it was because the student took the web site down...)
04:21:35 <xenoblitz> seriously lol
04:21:41 <xenoblitz> I might not even release then
04:21:51 <ivanm> xenoblitz: it's that simple: do you care if people use your code in a proprietary project?
04:22:10 <ivanm> if that's OK, use BSD3/MIT; if not, use GPL-{2,3}
04:22:32 <xenoblitz> ivanm: I don't as long as they acknowledge me but don't hold me responsible...
04:22:33 <ksf> the second question is: if you're ok with proprietary usage, do you want to be mentioned in the about dialog?
04:22:41 <Jafet> Note that it's simple because ivanm is simplifying it
04:22:54 <ksf> that's BSD4, then.
04:23:09 <ivanm> except people recommend against BSD4
04:23:24 <ivanm> ksf: typically you get mentioned in an about box or someplace even if you don't use BSD4
04:23:39 <ivanm> and you should still get mentioned in the LICENSE file, etc.
04:24:05 <ivanm> Jafet: well, yes, there are a few other things involved with GPL, but that's the main difference between permissive and copy-left licenses IMHO
04:24:22 <xenoblitz> acknowledge for me doesn't mean I get an about dialog... its more that some ppl don't say the did it and that's all... I think I'm overblowing this given the nature of what I wish to share anyway
04:24:35 <ivanm> xenoblitz: either one will give you that
04:24:36 <Jafet> I don't think you can do anything about the programmers who aren't courteous enough to credit your work, so release it under as liberal a license as with which you are comfortable.
04:25:01 <ivanm> it might not be _prominent_, but there's no license that forces them to state in a splash screen "this uses the foo library by xenoblitz"
04:25:12 <xenoblitz> i guess BSD3 seems to be the way to go
04:25:14 <Jafet> I also think the worst thing you can do to your career is to start it by not letting other programmers work with your code, for any reason.
04:25:23 <ksf> xenoblitz, they may not do that in any case
04:25:29 <Jafet> Well, other than malfeasance.
04:26:19 <ksf> ivanm, there's a couple of them
04:26:32 <ivanm> ksf: OK, no common/popular license
04:26:33 <xenoblitz> no its ok for me... I mean I don't care if ppl use it... i just wish that they know it was originally mine since i'm using it for my research... so ppl don't say I copied something when its me in the end... plagarism and whatnot
04:26:35 <ksf> ...at least if you don't use the code under gpl
04:26:45 <ksf> freetype and enlightenment do such a thing
04:26:45 * kpreid waves to Baughn.
04:26:45 <lambdabot> kpreid: You have 1 new message. '/msg lambdabot @messages' to read it.
04:27:16 <ivanm> ksf: hmmm?
04:27:32 <Baughn> kpreid: Now that I think of it, perhaps the AI *should* have a notion of the player. The goal is for the player to have fun, not necessarily for the AI to win..
04:27:40 <ksf> freetype is dual-licensed under a bsd-like attribution license and the gpl
04:27:53 <ksf> the enlightenment license is bsd with attribution iff the source isn't distributed
04:27:56 <Jafet> I don't think you should care about plagiarism either. Your development copy is always more advanced than their release copy.
04:28:04 <Jafet> Baughn, that's why games have difficulty levels...?
04:28:07 <ivanm> ksf: oh, so if you want to use it in a proprietary project you have to be obvious about it?
04:28:21 <ksf> xenoblitz, the best insurance against such things is hosting your code on github or such.
04:28:21 <koala_man> Jafet: unless they've worked on it
04:28:25 <p_l> Jafet: not all of them, some of them dynamically scale difficulty
04:28:28 <ksf> ivanm, exactly.
04:28:38 <Jafet> p_l, well, that just means they set it for you.
04:28:39 <xenoblitz> or wait until i finish and then release?
04:28:59 <ivanm> ksf: I quite like that solution actually...
04:29:08 <p_l> Jafet: some use a combination of preset difficulty and dynamic adaptation (Homeworld is a nice example)
04:29:17 <ksf> the only thing to take care about is attribution explosion, though.
04:29:23 <Jafet> koala_man, then they would have had to know it inside out, and those people don't plagiarize
04:29:43 <ksf> that's why I mentioned attributing to "The Haskell Cabal" by default, not individual authors or companies or such
04:30:23 <ivanm> ksf: that dual-license removes one of my problems with proprietary software (that who knows which BSD licenses they've used)
04:30:25 <Jafet> It still explodes if people don't like that default, ksf
04:30:32 <p_l> Jafet: dynamic scaling can sometimes cause cheating to backfire, btw
04:30:37 <Jafet> So there is a social aspect to it
04:30:39 <ksf> well if galois wants to have their own attribution noone can stop them, anyway, but at least it won't be a mile-long list of authors.
04:30:45 <Jafet> p_l, elaborate?
04:31:13 <p_l> Jafet: I made one of the missions in Homeworld 2 nearly unwinnable by modifying my fleet composition.
04:31:20 <ksf> Jafet, well, we don't have any attribution right now for all the stuff I know about.
04:31:35 <Baughn> Jafet: I'm not entirely sure how to write useful difficulty levels into the frankenstein monster of an AI I'm working on now
04:31:36 <Jafet> p_l, so much the better
04:31:47 <Baughn> Jafet: I've already had it deliberately crash the game to win.
04:31:50 <p_l> Jafet: the effect was that enemy forces were so powerful they accomplished *their* objective faster than I could arrive
04:32:00 <Jafet> Baughn, sounds useful!
04:32:07 <ksf> maybe require to include a list of packages and versions.
04:32:24 <Baughn> Jafet: I fixed it, though. Game crashes now count as a loss.
04:32:28 <Jafet> p_l, that actually happened with a game I played (as a natural consequence of levelling up, not cheating)
04:32:56 <Baughn> Jafet: (Could have made it neutral, but this way the AI might deliberately /prevent/ crashes, which could be useful)
04:33:11 <p_l> Jafet: well, I didn't modify the parameters of the units, I just made it so that I had *huge* fleet at the beginning of the mission... and HW always computes the size of enemy fleet relative to yours
04:33:22 <Jafet> I wonder how you get the program to be aware of how it may crash.
04:33:31 <Baughn> In retrospect.
04:33:45 <Jafet> Ah, machine learning?
04:33:45 <Baughn> It's still haskell. The crash doesn't segfault it or anything; the AI has time to save its state.
04:34:15 <Jafet> That's a wonderful metafeature
04:34:39 <Baughn> Jafet: An unholy mess of markov networks, genetic algorithms, goal-structured belief systems, bayesian networks and ad-hoc injunctions
04:34:41 <xenoblitz> Baughn: seems to be a nice project :) anything I can see? (am working on AI as well)
04:35:18 <Baughn> xenoblitz: http://lesswrong.com/lw/26x/open_thread_may_2010/1z1p <-- My standard response.
04:35:22 <Jafet> Add an ANN metaheuristic and it will be properly incomprehensible
04:35:45 <Baughn> Jafet: I forgot, eurisko-style metaheuristics too.
04:36:01 <ksf> Baughn, randomly disable some stuff and select levels with a fitness functions by letting them play against each other
04:36:09 <Jafet> Note that the remakes of Elite were criticized because they used proper Newtonian dynamics instead of flightsim-like controls.
04:36:13 <Baughn> Jafet: I recently had to add a size limit injunction to it, as it was growing out of all reason. ^^;
04:36:39 <Jafet> ksf, beware, that produces rubbish if you let it go on too long
04:36:43 <Baughn> Jafet: Ah, well, no newtonian dynamics here, don't worry.
04:36:55 <ksf> Jafet, well, you only need a max of 10 levels or so
04:36:58 <Jafet> Baughn, just commenting on your fun vs realism comment
04:37:02 <ksf> more or less evenly distributed
04:37:11 <Baughn> Jafet: I happen to think einsteinian physics is fun.
04:37:23 <Jafet> That opinion is relative.
04:37:37 <Baughn> Jafet: Anyway, the player doesn't control thigns at that low a level. "Go to mars" is about the smallest-granularity order you  can give.
04:37:37 <ksf> produce an ordering of 100 or so and then manually bisect them for the lower bound
04:37:47 <Jafet> Unless you're talking about the Einstein in Red Alert 2 who invents time travel and things
04:37:58 <Baughn> No. General relativity.
04:38:19 <Jafet> Which model of it?
04:38:22 <Baughn> Or at least a good fascimile. The original is, of course, not solvable.
04:38:25 <abberaman> What does "Constraint is no smaller than the instance head" mean? (from ghci)
04:38:41 <aavogt> it means you need undecidable instances!
04:38:47 <ksf> abberaman, in a nutshell, that you could write the instance the other way round, too
04:38:56 <ivanm> Jafet: and in 1 wasn't it?
04:39:00 <Baughn> Jafet: I'm not sure yet. I'm still reading physics texts.
04:39:08 <ksf> which would lead to an infinite loop in the typechecker and thus is forbidden by default
04:39:10 <Jafet> ivanm, er, yeah
04:39:17 <abberaman> hmm, so I should just set XUndecidable... and forget about it?
04:39:19 <p_l> Jafet: one of the issues in BC3k were fights between publisher wanting "arcade physics" vs. author who used Newtonian physics (down to side-effects of computer position correction with verniers)
04:39:24 <ksf> abberaman, depends
04:39:27 <ivanm> hmmm... does RA3 have einstein?
04:39:42 <ksf> if you have Foo a => Bar a and never, ever write Bar a => Foo a you're fine
04:40:23 <ksf> the main issue with red alert is a pathfinder that isn't A*
04:40:23 <Jafet> Baughn, be sure to demo it with a black hole or two
04:41:00 <Jafet> All these strategy war games are about precise micromanagement
04:41:08 <Baughn> Jafet: It won't look as pretty as you'd hope. The visuals are meant to be what an actual commander might see, not what you'd get from a camera.
04:41:09 <Jafet> The pathfinder is yer mouse
04:41:19 <ksf> and economy, if you're lucky.
04:41:33 <Jafet> Like starcraft, if they had a better pathfinder it probably wouldn't be a national sport
04:41:42 * ksf likes spring
04:41:48 <quicksilver> abberaman: it means that the compiler can't immediately see inference will terminate.
04:41:49 <p_l> a good 4X is usually more about economy than pathfinding :)
04:41:57 <quicksilver> abberaman: if you happen to know it will, you can use undecidable.
04:41:58 <abberaman> I have "class Algebra a where algAdd :: a -> a -> a ..." and then later "instance (Num a) => Algebra a where algAdd = (+) ..."
04:42:01 <ksf> http://springrts.com/
04:42:14 <ksf> I think total annihilation had a*
04:42:22 <Jafet> Baughn, a commander would want to see camera footage!
04:42:29 <Jafet> Even if it's a few weeks old
04:42:31 <ksf> and it'd still be the best rts ever weren't it for spring.
04:42:42 <Jafet> What's special about A*?
04:42:50 <Jafet> Other than perhaps efficiency
04:42:59 <Baughn> Jafet: Of a black hole? Or a fight where distances average several hundred million kilometres?
04:43:10 <Baughn> Jafet: With ships being a few hundred meters, tops?
04:43:14 <p_l> Baughn: don't forget the engagement range
04:43:18 <Baughn> Jafet: A camera view /isn't useful/.
04:43:36 <Baughn> Better get a kind of schematic view instead.
04:43:39 <Jafet> Baughn, well that teaches the player to design ships with fisheye lenses
04:43:58 <quicksilver> abberaman: well that makes an instance for all possible types a
04:44:06 <quicksilver> abberaman: and adds the constraint that they must be Num
04:44:19 <ksf> Jafet, that it always finds the optimum path if there's one.
04:44:19 <quicksilver> abberaman: it effectively disallows any other instances than that one; is that what you want?
04:44:22 <Jafet> I wonder how space combat works if you can fire electromagnetic beams. I can't think of any way to detect those.
04:44:34 <ksf> red alert used a simple "walk towards the target" "finder"
04:44:45 <Baughn> Jafet: They wouldn't normally be powerful enough to do much.. I think....
04:44:55 <Jafet> ksf, where did you get this information from?
04:45:06 <Baughn> Jafet: But given that the US air force is now working on positronium-powered grasers, I'm no longer very sure of such an assertion. ^^;
04:45:07 <Jafet> (Other than playing and noticing...)
04:45:20 <ksf> ever had your mammoths stuck in a corner of some mountains?
04:45:22 <Jafet> Baughn, x-ray satellites!
04:45:31 <abberaman> I want anything that's a Num to also be an instance of my new class, then I define another instance that isn't a Num
04:45:45 <Jafet> ksf, no. But then I haven't played red alert (1) much
04:45:50 <quicksilver> abberaman: then that overlaps.
04:46:00 <ksf> if there's a U and a unit is right on top of it and send below it, it will drive into the U and then backtrack
04:46:11 <ksf> I think RA at least backtracked
04:46:15 <quicksilver> abberaman: the compiler can never know that your "another instance" won't be made an instance of Num in a file it hasn't yet read.
04:46:18 <Baughn> Jafet: Well, still, I suspect missiles will be the mainstay weapon.
04:46:21 <ksf> other games of that era didn't.
04:46:43 <p_l> Baughn: till you introduce macross cannon style weaponry, I bet.
04:46:53 <abberaman> ah, ok. so since I know that I will never make it an instance of Num I can add the XUndecidableinstances ?
04:47:03 <ksf> the problem with a*, though, is that it's easy for units to move a bit unrealistic, as a* has perfect knowledge of the map
04:47:10 <Baughn> p_l: Base physics does not allow those. If you choose to play with one of the expansion packs, then sure.
04:47:19 <Jafet> ksf, ah. I remember now. I think RA2 does basic (heuristic) pathfinding. The fun thing is, it uses the map terrain, so they have more knowledge than ... yeah
04:47:38 <ksf> so if you want realistic fog of war, you have to augment the a* with an explore heuristic.
04:47:47 <quicksilver> abberaman: you should need XOverlappingInstances as well
04:47:48 <Baughn> And why is fog of war realistic?
04:47:49 <Jafet> There is probably an undiscovered data structure that dynamically tracks shortest path in a growing graph
04:47:55 <Baughn> I mean, has nobody heard of *satellites*?
04:47:58 <p_l> Baughn: depends on how it is implemented.
04:48:01 <Baughn> We should at least know the *terrain* in advance.
04:48:06 <quicksilver> abberaman: I am of the opinion that OverlappingInstances is evil.
04:48:18 <ksf> huh. that's a big topic.
04:48:19 <Jafet> Baughn, all tournament players know all the maps by heart
04:48:22 <p_l> Baughn: don't forget that satellites have at least few hours latency
04:48:30 <p_l> (usual)
04:48:34 <ksf> firstly, you might want to have gameplay reasons to have the map unexplored by default
04:48:36 <Baughn> p_l: Terrain does not change that fast.
04:48:36 <Jafet> Also, RA2 lets you build satellite uplink
04:48:40 <ksf> (which isn't fog of war per se)
04:48:57 <p_l> Baughn: terrain not, but there's not much use for terrain-based fog of war
04:49:08 <ksf> then you might have dynamic terrain, so stuff that's in the fog of war might actually change without you knowing about it
04:49:16 <abberaman> quicksilver: what would you do, make Int, Float, Rational, etc all instances separately ?
04:49:37 <Jafet> Meh, you always know which of your soldiers is picking their nose. These games don't even pretend to be realistic
04:49:42 <ksf> POV-based fog of war can be fun
04:50:06 <ksf> you have to realise that it might be way easier to shoot down a sattelite than to bring one into orbit...
04:50:14 <Jafet> ksf, most games have fixed terrain
04:50:19 <Jafet> So that's moot
04:50:22 <p_l> dynamic terrain you say... I got an idea of "mutable" world where there's an explicit even horizon for units and terrain that isn't observed by you can completely change
04:50:44 <Jafet> ksf, unless you play dwarf fortress 2, but that makes you a masochist
04:50:45 <abberaman> I don't quite understand why they overlap.. naively, it seems like there's no problem until I try to make AnotherClass an instance of Num
04:50:56 <abberaman> (which I won't)
04:50:58 <ksf> soldiers are required to report any medical condition to their superiors.
04:51:01 <Jafet> abberaman, the compiler can't really verify that you won't.
04:51:19 <Jafet> You could, for example, do it in another module.
04:51:21 <quicksilver> abberaman: you mean AnotherType , not AnotherClass :)
04:51:24 <ksf> or that someone else does it
04:51:30 <ksf> remember, typeclasses are open.
04:51:36 <quicksilver> abberaman: the problem is about separate compilation and polymorphism.
04:51:37 <Jafet> And that's final!
04:51:53 <quicksilver> abberaman: you may have a polymorphic use of AddAlgebra in one module
04:51:58 <quicksilver> that will get reduced to a Num constraint
04:52:09 <quicksilver> (because the Num a => AddAlgebra a instance is in scope)
04:52:19 <quicksilver> and then you will be unable to apply that polymorphic function to AnotherType
04:52:26 <quicksilver> because there is no Num instance for AnotherType.
04:52:29 <Baughn> Jafet: "Dwarf fortress 2"? -_-;
04:52:58 <ksf> in general, proper viewing distance etc. is a great gameplay factor
04:53:04 <p_l> there's not even 1.0 yet!
04:53:13 <Baughn> I'd know!
04:53:36 <ksf> in e.g. balanced annihilation there's a lot of units that can shoot farther than they can look, so they either need reconnaisance or radar backup.
04:53:41 <abberaman> ok, so the correct thing to do is make Int, Float, etc instances separately...
04:54:22 <Jafet> The space commander of the real future will probably be a bit fat, strapped to a chair permanently, connected to a sensory suit, and fed from an IV
04:54:38 <quicksilver> abberaman: unfortunately, probably so.
04:54:38 <ksf> and write poetry.
04:54:47 <quicksilver> abberaman: you're not the only one to feel the pain of this...
04:55:01 <quicksilver> abberaman: it would be a bit better if AddAlgebra "came first"
04:55:08 <quicksilver> abberaman: then it could be a superclass of Num. that works better.
04:55:18 <quicksilver> but you can't make it a superclass of Num, now, because Num has already been written.
04:55:20 <Jafet> It might be more effective to hang them upside down, but then you would need to attach a morality implant
04:55:42 <abberaman> ok, at least I understand a little what's going on. Thanks!
04:59:50 <FliPPeh> I've head many teams for making use of multiple cores.. multithreading, concurrency and parallelism - now what exactly is the difference between them?
05:00:46 <bremner> well, your heading the teams, you tell us.
05:00:51 <quicksilver> people aren't very consistent or accurate with those terms, FliPPeh
05:01:15 <FliPPeh> terms*
05:01:17 <FliPPeh> :(
05:01:31 <FliPPeh> s/head/heard, s/teams/terms
05:01:34 <quicksilver> the traditional pure CS definition is that parallelism is deterministic.
05:01:51 <quicksilver> i.e. the solution is well-defined, it's just you're breaking up the work.
05:02:22 <quicksilver> concurrency is non-deterministic - multiple processes execution with unpredictable periods of 'blocking' and some attempt to synchronise.
05:03:29 <quicksilver> multithreading is normally used to mean multiple threads in a single 'process' - so there might only be one real CPU, so it might never run in parallel.
05:03:47 <quicksilver> although of course there might be more than one CPU, so there might be some genuinely concurrent execution going on.
05:03:50 <quicksilver> FliPPeh: does that help?
05:03:51 <opqdonut> concurrency tends to emphasize communication, parallelism emphasizes distribution of work
05:04:05 <opqdonut> multithreading is just a technique
05:04:06 <FliPPeh> So parallelism and concurrency are a subset of multithreading?
05:04:11 <quicksilver> no
05:04:14 <Jafet> Multithreading is just doing one thing, before, after or at the same time as another.
05:04:19 <quicksilver> multithreading is an implementation technique
05:04:29 <FliPPeh> Meant that :)
05:04:39 <quicksilver> it's used to describe something OS-level or process-level.
05:04:46 <FliPPeh> Thanks for that explaination :)
05:05:10 <quicksilver> most operating systems have supported multithreading for a very long time, even though multiple actual CPUs or cores has been quite rare until more recently.
05:07:25 <p_l> most operating systems tend to have blocking APIs which promote usage of multithreading.
05:09:29 <p_l> (which sprouts monsters like console-kit-daemon that needs 64 threads for what is basically 99% idling)
05:09:40 <arw> and those that have async apis are incompatible with each other, so threads is the easiest portable method
05:09:50 <anakreon> Hello list. I have a list ["a", "b", "c"] and want to convert it to ["a->b", "b->c"]. How can this be done with a fold?
05:10:01 <anakreon> With recursion it is easy.
05:10:21 <Botje> anakreon: zipwith
05:10:26 <p_l> arw: unless you arrive on system that has the most common APIs available only as async. ones (with sync. variants being emulated by waits(
05:10:47 <opqdonut> > let x = ["a","b","c"] in zipWith (\x y -> x ++ "->" ++ y) x (tail x)
05:10:48 <lambdabot>   ["a->b","b->c"]
05:11:31 <applicative> opqdonut is way too fast...
05:11:45 <opqdonut> oh, I felt slow writing that :)
05:12:01 <anakreon> Thanks
05:12:04 <opqdonut> usually someone beats me to these
05:12:23 <applicative> i was busy trying it in my private discussion with lambdabot
05:13:21 <benmachine> > zip`ap`tail $ ["a", "b", "c"]
05:13:22 <lambdabot>   [("a","b"),("b","c")]
05:13:50 <quicksilver> p_l: although, efficiency concerns aside, a good threaded API is probably easier to use than an async one
05:13:51 <Botje> http://en.wikipedia.org/wiki/Serialization#Haskell # huh. Binary is missing.
05:14:05 <quicksilver> p_l: keeping track of all the async things you are waiting for is annoying book-keeping.
05:14:15 <quicksilver> I like the haskell choice to use soft threads for this.
05:14:39 <aavogt> > (zipWith (++"->"++) <*> tail) ["a","b","c"]
05:14:40 <lambdabot>   <no location info>: parse error on input `)'
05:14:43 <dobblego> @type zipWith (,)
05:14:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:14:56 <aavogt> too bad such sections aren't allowed
05:15:16 <aavogt> > (zipWith ((++"->")++) <*> tail) ["a","b","c"]
05:15:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
05:15:17 <lambdabot>        ...
05:15:33 <quicksilver> @pl \a b -> a ++ "->" ++ b
05:15:33 <lambdabot> (. ("->" ++)) . (++)
05:15:39 <quicksilver> nice. (not)
05:16:01 <aavogt> @type (++("x"++))
05:16:02 <lambdabot> ([Char] -> [Char]) -> [Char] -> [Char]
05:16:19 <quicksilver> @type (++)
05:16:20 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:16:33 <quicksilver> aavogt: beware non-standard ++s and non-standard monoid instances, I think.
05:17:08 <aavogt> oh, that one works because of    Monoid b => Monoid (a -> b)
05:17:12 <quicksilver> my ghci says The section `"x" ++' takes one argument, but its type `[a]' has none
05:17:24 <quicksilver> right.
05:18:09 <benmachine> @pl \a b -> concat [a,"->",b]
05:18:09 <lambdabot> (join .) . (. (("->" :) . return)) . (:)
05:18:18 <benmachine> right.
05:18:48 <applicative> @type zip <*> tail
05:18:49 <lambdabot> forall b. [b] -> [(b, b)]
05:18:49 <aavogt> @type (++("x"++)) . const
05:18:50 <lambdabot> [Char] -> [Char] -> [Char]
05:19:09 <aavogt> > let f = (++("x"++)) . const in f "a" "b"
05:19:11 <lambdabot>   "axb"
05:19:48 <aavogt> > let f = (++("x"++)) . (++) in f "a" "b"
05:19:49 <lambdabot>   "abxb"
05:20:27 <byorgey> @quote zip`ap`tail
05:20:27 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:21:12 <applicative> hah.  I hadn't known zip `ap` tail   I am joining its cult
05:21:25 <idnar> @quote zip`ap`tail
05:21:26 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:21:26 <aavogt> what would you think of permitting sections like   (++"->"++)   for associative ++?
05:21:29 * Saizan burns some lambdas as n offering
05:21:37 <idnar> oh, someone already did that
05:21:42 <idnar> apparently I'm blind
05:21:52 <quicksilver> aavogt: I think it's quite cute but the compiler doesn't know things are associative.
05:22:04 <byorgey> idnar: zip`ap`tail has smote you
05:22:05 <quicksilver> aavogt: arguably the best representation we have of associativity is Monoid m =>
05:22:10 <applicative> It would have to be associative to make sense?
05:22:23 <quicksilver> it could be purely syntactic
05:22:29 <aavogt> oh right, infix{l,r,} doesn't say it's associative
05:22:46 <quicksilver> (#c##) a b === a # c ## b
05:23:05 <quicksilver> with whatever parsing a # c ## b would normally have based on # and ##'s infix{l,r} decs.
05:23:21 <aavogt> with appropriate ambiguities
05:23:38 <aavogt> does somebody want to open a ticket with ghc?
05:23:42 <Saizan> what if ## is meant to be a postfix operator?:)
05:23:48 * quicksilver smites Saizan
05:24:46 <aavogt> quicksilver: or it's  c#  in an unboxed tuple...
05:25:19 <aavogt> @type (,'x',)
05:25:20 <lambdabot> parse error on input `''
05:26:00 <aavogt> poor \bot hasn't seen the glory of -XTupleSections
05:28:44 <applicative> > (,) 1 2
05:28:44 <lambdabot>   (1,2)
05:29:01 <applicative> why don't sections work, if that does?
05:29:19 <Jafet> (,) is a constructor.
05:29:20 <aavogt> because (,) is the constructor?
05:29:30 <Jafet> > (,1) 2
05:29:31 <lambdabot>   <no location info>: parse error on input `1'
05:29:32 <applicative> I see
05:31:06 <aavogt> > ((,) 1) 2
05:31:07 <lambdabot>   (1,2)
05:31:45 <applicative> (,) 1 2  is the real name; (1,2) is sugar, so there'd need to be separate sugar for a direct (,1) 2
05:32:15 <aavogt> and there is
05:32:24 <applicative> Yes, as I meant to say
05:34:44 <roconnor> @src fix
05:34:44 <lambdabot> fix f = let x = f x in x
05:35:00 <applicative> now I want list sections [,2,3] 1
05:35:36 <aavogt> hah
05:35:42 <opqdonut> gaaah :D
05:35:49 <applicative> [1,,3] 2
05:35:57 <aavogt> > (:[2,3]) 1
05:35:58 <lambdabot>   [1,2,3]
05:36:09 <opqdonut> oh, but those are subsumed by infix sections: (1::3::5:[]) 2 4 ;)
05:36:22 <aavogt> you need more spaces
05:36:31 <opqdonut> yeah ok
05:36:56 <applicative> How do they work?  I can't keep up with all the sugar...
05:37:26 <opqdonut> I meant the proposed sections like (++"a"++)
05:37:32 <Jafet> This is a specific use case of placeholder arguments
05:37:44 <Jafet> opqdonut, that's not a section...
05:38:02 <aavogt> $_
05:38:05 <opqdonut> Jafet: ?
05:38:20 <opqdonut> sure, it isn't now, but it's a proposed feature
05:38:24 <Jafet> :t (++"a"++)
05:38:25 <lambdabot> parse error on input `)'
05:38:33 <Jafet> I thought that was valid...
05:38:50 <opqdonut> (#x##) => (\a b -> a#x##b)
05:38:57 <aavogt> http://hackage.haskell.org/trac/ghc/ticket/4052
05:39:04 <aavogt> please cc yourselves :)
05:39:18 <benmachine> :t ("a" ++ "b" ++) -- it always puzzled me why this didn't work
05:39:19 <lambdabot>     The operator `++' [infixr 5] of a section
05:39:19 <lambdabot>         must have lower precedence than that of the operand,
05:39:19 <lambdabot>           namely `++' [infixr 5]
05:39:39 <opqdonut> yeah
05:39:50 <aavogt> monochrom would say that's because you didn't read the language definition
05:39:53 <benmachine> I guess it would mean (("a" ++ "b") ++) which could be surprising
05:40:10 <opqdonut> of course that's what it would mean
05:40:25 <opqdonut> oh, infixr
05:40:35 <opqdonut> what about an infixl?
05:40:36 <aavogt> benmachine: no, it would mean    \x -> "a" ++ "b" ++ x
05:40:42 <opqdonut> :t (1 + 2 +)
05:40:42 <lambdabot> forall t. (Num t) => t -> t
05:40:45 <opqdonut> see, that works
05:40:50 <aavogt> which is associated to the right
05:40:53 <opqdonut> perfectly sensible heuristic there
05:40:53 <aavogt> opqdonut: huh?
05:41:01 <opqdonut> infixl vs. infixr
05:41:09 <benmachine> oh I suppose that makes sense
05:41:15 <opqdonut> :)
05:41:26 <aavogt> :t (+ 1 + 2)
05:41:26 <lambdabot>     The operator `+' [infixl 6] of a section
05:41:27 <lambdabot>         must have lower precedence than that of the operand,
05:41:27 <lambdabot>           namely `+' [infixl 6]
05:41:32 <benmachine> then the error message is a lie :P
05:42:39 <Saizan> it gives you only one way to solve, rather than both :)
05:42:55 <benmachine> it gives you only one way to solve and says it's the only way
05:43:06 <opqdonut> yeh
05:43:35 <applicative> > (+ 1 * 2) 4
05:43:35 <lambdabot>   6
05:43:37 <aavogt> > (2) 3
05:43:38 <lambdabot>   Ambiguous type variable `t' in the constraint:
05:43:38 <lambdabot>    `GHC.Num.Num t' arising f...
05:44:25 <applicative> > (* 1 + 2) 4
05:44:26 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
05:44:26 <lambdabot>      must have lower prece...
05:44:48 <aavogt> if numeric litterals can be functions... how do you write sections with them?
05:45:05 <Jafet> This is verging into the realm of the syntactic -- maybe it's better to use TH for it?
05:45:09 <benmachine> :t 1 `3` 4
05:45:10 <lambdabot> parse error on input `3'
05:45:12 <benmachine> :(
05:45:22 <quicksilver> that's interesting.
05:45:36 <quicksilver> well, not very interesting :) but slightly.
05:45:37 <Jafet> 3 is unary!
05:45:38 <aavogt> there's no TH in here
05:45:45 <Jafet> (Church encoding)
05:45:54 <quicksilver> another hiccup of `` being lexical-level
05:46:07 <opqdonut> ah
05:46:09 <quicksilver> there used to be TH in here before mmorrow and lunabot vanished.
05:46:10 <aavogt> it's also type level... :)
05:47:54 <aavogt> Jafet: how would you use TH for this problem anyhow?
05:48:25 <aavogt>   [$t| ++ x ++ |]   gets expanded to     (\a b -> a ++ x ++ b)
05:48:47 <whald> is there a way to cause ghc to abort whenever it encounters a NaN (besides manually adding assertions all around)?
05:49:08 <Jafet> Something like that, shortened as a macro
05:49:09 <aavogt> whald: write a different Num instance
05:49:15 <Jafet> And no, I don't use TH
05:49:30 <aavogt> Jafet: so CPP then?
05:49:33 <Jafet> You can make the CPU abort ghc, perhaps
05:49:47 <quicksilver> I don't think GHC has a way to turn on signalling NaNs
05:49:57 <Jafet> Or maybe a special preprocessor pass that uses TH
05:49:57 <whald> aavogt: something like DebugFloat which has these assertions at a central place?
05:50:05 <Jafet> But that's an implementation detail
05:50:35 <Jafet> It's probably least painful to write a different Fractional instance, per aavogt
05:50:51 <aavogt> whald: right,  a    newtype DebugDouble = DebugDouble Double, with instances of the appropriate classes that throw errors when the values are NaN
05:51:09 <aavogt> > sqrt (-1)
05:51:10 <lambdabot>   NaN
05:51:16 <whald> thanks, everyone this sounds reasonable
05:52:19 <aavogt> if your functions are written   (Fractional a, ...) => a -> a -> a... , you can switch between the DebugDouble and Double without changing that function
05:53:06 <Jafet> :t (/)
05:53:07 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:54:24 <whald> aavogt: this won't sacrifice performance when using ghc?
05:54:27 <aavogt> manual -XGeneralizedNewtypeDeriving might be interesting if performance while debugging mattered
05:54:36 <Jafet> whald, it probably will.
05:55:09 <Jafet> If you care about performance that much, use your FPU
05:55:20 <aavogt> as in,  unsafecoerce :: DebugDouble -> Double  (and the inverse)  for all methods that can't fail
05:55:41 <whald> Jafet: so i'll rather stay with my "type Flt = {Float, Double, DebugFloat}" and using Flt throughout the code then
05:55:58 <Fanael> :t unsafeCoerce
05:55:59 <lambdabot> Not in scope: `unsafeCoerce'
05:56:00 <Jafet> I was thinking of your NaN check
05:56:11 <Cale> Fanael: a -> b
05:56:16 <Jafet> @quote generalisation
05:56:16 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
05:56:20 <edwardk> whalf: ick
05:56:23 <edwardk> er whald
05:56:28 <Cale> lol
05:56:47 <whald> edwardk: what's ick?
05:56:59 <edwardk> whald:  "type Flt = {Float, Double, DebugFloat}" and using Flt throughout the code then
05:57:00 <aavogt> whald: oh maybe being polymorphic may be slower, it depends on which optimizations happe
05:57:03 <Jafet> @hoogle ick
05:57:03 <lambdabot> Text.Html clickmap :: String -> Html
05:57:03 <lambdabot> Text.XHtml.Frameset clickmap :: String -> Html
05:57:03 <lambdabot> Text.XHtml.Strict clickmap :: String -> Html
05:57:19 <edwardk> aavogt: sprinkling specialize pragmas though should fix any speed issues
05:58:24 <edwardk> foo :: Floating a => a -> a -> a means that if you ever want to use your algorithm at multiple levels of precision, or even with full CReals you have the option!
06:05:18 <applicative> the ghc users guide section on specialize pragmas is a little opaque
06:06:49 <ajcc> go fix it?
06:06:49 <FliPPeh> I love Haskell, I want it to replace C so it can be of use for my future programming tasks in this C-oriented world.
06:07:41 * ajcc loves Haskell and C, that's why Haskell is so nice to work with
06:08:05 <FliPPeh> C is fine, but multithreading is a b*tch with it
06:08:12 <ajcc> no it's not
06:08:46 <FliPPeh> :/
06:09:01 <FliPPeh> You have multiple, possibly incompatible threading libaries
06:09:12 <koala_man> even singlethreading is a bitch in C
06:09:16 <FliPPeh> Some work only on windows, some work everywhere. With C++ it's the same thing :/
06:09:23 <aavogt> you mean monad libraries
06:09:36 <ajcc> you have w32-api and pthreads, that's two
06:10:16 <ajcc> writing abstractions is a big part of writing C anyway
06:10:35 <applicative> edwardk, the monoids library has some nice illustrations of {-# SPECIALIZE ...  :)
06:10:37 <FliPPeh> Lot's of #ifdef'in
06:10:44 <ajcc> FliPPeh: yes, and that's hard?
06:10:51 <FliPPeh> Nah, it's not
06:11:00 <edwardk> applicative hrmm. i don't remember =)
06:11:17 <FliPPeh> But it's just incomparable to the haskellish "forkIO"
06:11:32 <FliPPeh> (to me).
06:11:36 <FliPPeh> Important to say that
06:11:37 <quicksilver> if you have to maintain your own #ifdefs to handle multiple threading models that puts more of the burden of testing on various configurations onto you.
06:11:58 <quicksilver> It's obviously more comfortable to have a portable threading model where the burden of testing is in the first instance on the library/runtime provider, like GHC.
06:12:00 <applicative> http://hackage.haskell.org/packages/archive/monoids/0.1.25/doc/html/src/Data-Generator.html  -- after the definition of reduce come a million specializations
06:12:15 <edwardk> oh yeah, i was on an optimization kick that day =)
06:12:52 <edwardk> that and that routine is the workhorse of the whole library
06:13:09 <quicksilver> cruelty to horses!
06:13:34 <aavogt> @quote 666
06:13:34 <lambdabot> No quotes match. My pet ferret can type better than you!
06:13:46 <ksf> @quote pony
06:13:46 <lambdabot> dforsyth says: "under no circumstances would i fuck a dude, but if there was a nuclear bomb to my dick, theres no way id fuck a dude with a ponytail"
06:14:04 * quicksilver blinks
06:14:13 <ksf> do I have to understand that?
06:14:17 <djahandarie> ...
06:16:11 <FliPPeh> @quote twitter
06:16:11 <lambdabot> No quotes match.
06:16:31 <applicative> I have a ponytail.  I'm offended.
06:16:52 <osfameron> it seems rather offtopic
06:16:55 <applicative> how do we get rid of obnoxious quotes
06:17:06 <osfameron> s/nuclear bomb/monad/ ;-)
06:17:12 <Saizan>  @forget
06:17:37 <applicative> @forget pony -- ?
06:17:37 <lambdabot> No match.
06:18:25 <ksf> hmmm I _could_ do a ponytail just ever so slightly towards the back of my head.
06:19:03 <ksf> @forget dforsyth "under no circumstances would i fuck a dude, but if there was a nuclear bomb to my dick, theres no way id fuck a dude with a ponytail"
06:19:03 <lambdabot> Done.
06:19:11 <ksf> @quote pony
06:19:12 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:19:28 <djahandarie> ...
06:19:47 <djahandarie> @quote thisdoesntexist
06:19:48 <lambdabot> No quotes match. Where did you learn to type?
06:19:55 <djahandarie> lol, bug?
06:19:58 <ksf> @quote pony
06:19:59 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:20:02 <Saizan> gah, i thought i had fixed that.
06:20:07 <aavogt> somebody has to @flush?
06:20:17 <aavogt> or is that not involved at all here?
06:20:32 <Saizan>  @flush it's orthogonal
06:20:38 <djahandarie> So I wonder how that lambdabot rewrite is going. :P
06:21:15 <ksf> why doesnt' lambdabot autoflush, anyway?
06:21:38 <ksf> she can safe regular snapshots if you want to reverse...
06:23:56 <Fanael> :>
06:24:07 <quicksilver> ksf: I imagine if you contribute a patch to flush every N minutes, cale will apply it.
06:25:55 <ksf>  your mother patches socks...
06:27:04 <quicksilver> no doubt.
06:27:30 <ksf> but i'd be willing to patch the todo file, if there were one.
06:27:47 <applicative> why would cale want to be applying a patch to flush every N minutes; doesn't he have better things to do with his time?
06:28:11 <ksf> like, listen to whining why the patch doesn't get accepted?
06:28:28 <Fanael> Is there any way to write "mallocArray memorySize >>= \mem -> memzero mem >> return mem" without that stinky lambda?
06:28:57 <ksf> either with do syntax, or by leaving out that memzero
06:29:04 <ksf> ...memory is initialized to 0
06:29:09 <Cale> applicative: heh
06:29:16 <Axman6> @pl mallocArray memorySize >>= \mem -> memzero mem >> return mem
06:29:16 <lambdabot> liftM2 (>>) memzero return =<< mallocArray memorySize
06:29:33 <Axman6> hmm, that's not too bad actually
06:29:44 <Axman6> wait, it's using two different monads, not happy
06:29:51 <Cale> Depends if it's  applying (a patch to flush every N minutes) or applying (a patch to flush) every N minutes.
06:30:41 <Fanael> Is memory really initialized to 0?
06:30:44 <applicative> I was thinking the latter would be too much to ask
06:31:14 <ksf> I'm almost certain I read that somewhere
06:31:15 <Axman6> Fanael: should be
06:31:23 <ksf> ...being surprised that that's the case
06:31:46 <Fanael> I checked that right now - it is not, unfortunately.
06:31:55 * ksf votes for writing "read" "reat"
06:32:08 <ksf> or, better, reed read read
06:33:18 <applicative> In the original "mallocArray memorySize >>= \mem -> memzero mem >> return mem" are there two monads?
06:33:30 <ksf> nope
06:33:32 <ksf> it's all IO
06:33:43 <benmachine> you aren't there using the fact that functions are a monad
06:33:44 <ksf> that liftM2 (>>) is Monad ((->) a)
06:34:02 <benmachine> you could also do (>>) <$> memzero <*> return
06:34:46 <benmachine> but that would be still quite ugly
06:35:12 <applicative> in paradise, they will write (|memzero >> return|)
06:35:18 <benmachine> hold on, can we make something of x >> return y = y <$ x
06:36:04 <ksf> :t (<$)
06:36:05 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:36:10 <benmachine> mallocaArray memorySize >>= ap (<$) memzero -- I think
06:36:23 <benmachine> :t ap (<$) putStrLn
06:36:24 <lambdabot> String -> IO String
06:36:58 <benmachine> of course whether that's readable or not depends on how used to (<$) and ap-on-functions you are
06:37:16 <benmachine> I understand it fine but I have a particular fondness for that pattern
06:37:22 <benmachine> other people may not
06:44:09 <EvanR-work> looking at ContT, i see warnings about not misusing, so what are some cases where you would want to use it?
06:48:18 <applicative> wait, is this the same:    (>>) <$> memzero <*> mallocArray memorySize
06:48:43 <pastorn> EvanR-work: breaking out of big blocks?
06:49:05 <pastorn> or are you talking about ContT in particular?
06:49:11 <EvanR-work> so like break
06:49:13 <EvanR-work> or goto
06:49:14 <sioraiocht> My brain just exploded.
06:49:15 <sioraiocht>     I can't handle pattern bindings for existential or GADT data constructors.
06:49:15 <sioraiocht>     Instead, use a case-expression, or do-notation, to unpack the constructor.
06:49:20 <sioraiocht> thank you, GHC
06:49:39 <pastorn> EvanR-work: i can recommend reading the article on the Cont monad on wikibooks
06:49:41 <pastorn> it's good
06:50:38 <EvanR-work> ok
06:51:05 <pastorn> sioraiocht: can haz paste?
06:51:14 <sioraiocht> sorry
06:51:27 <sioraiocht> it was just a where cluase for a Stream
06:51:29 <EvanR-work> lets say i have a traditional 'main loop' in a game, it does IO to get input, applies it to the game, runs the game, and does IO to draw graphics, and repeats. would it be better to use a continuation instead?
06:51:41 <opqdonut> probably not
06:51:41 <sioraiocht> Stream next s0 = stream ....
06:52:34 <Fanael> So, if I want do get rid of this lambda, I can either use that pesky do-notation or make the code unreadable using applicative functors. The choice is hard...
06:52:48 <pastorn> EvanR-work: i am thinking of putting my ContT into my IRC bot monad
06:53:04 <pastorn> EvanR-work: i in main i have forever mainLoop
06:53:23 <EvanR-work> right
06:53:37 <pastorn> but if i threw a ContT into there i could have a command that could trigger my bot to die
06:53:43 <EvanR-work> yes
06:53:46 <pastorn> efficiently breaking out from within forever
06:53:50 <EvanR-work> i solved that by usint untilM instead of forever
06:53:56 <EvanR-work> uing
06:53:58 <EvanR-work> ?
06:54:01 <EvanR-work> using
06:54:06 <pastorn> @type untilM
06:54:07 <lambdabot> Not in scope: `untilM'
06:54:09 <pastorn> :(
06:54:10 <EvanR-work> its not real
06:54:12 <pastorn> @type until
06:54:13 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
06:54:22 <pastorn> @type forever
06:54:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
06:55:05 <pastorn> EvanR-work: then you could place you 'k' in a reader, and using that to get out :)
06:56:22 <EvanR-work> since i have events, i suppose the way id 'get out' is by someone using the halt event, and that is interpreted specially at the output stage
06:56:45 <EvanR-work> the window manager halt event already does that
06:57:08 <EvanR-work> these dont seem to be very sophisticated strategies, which doesnt seem very haskelly ;)
07:00:23 <EvanR-work> pastorn: so its justified to replace a main loop with a callCC
07:04:31 <benmachine> applicative: no, due to operator precedence
07:04:35 <pastorn> EvanR-work: no, you should use callCC before going into the mainloop
07:04:54 <benmachine> wait
07:04:55 <benmachine> no
07:04:58 <benmachine> I misunderstood
07:05:21 <benmachine> applicative: in that one you're memzeroing before you malloc, I think
07:05:27 <seeg> hello
07:05:27 <benmachine> *possibly* a bad idea
07:05:43 <benmachine> applicative: no it just doesn't typecheck I think
07:05:51 <JuanDaugherty> yello seeg
07:05:58 <pastorn> @type runReader
07:05:59 <lambdabot> forall r a. Reader r a -> r -> a
07:06:04 <pastorn> @type runContT
07:06:04 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
07:06:11 <pastorn> ok, let's see...
07:06:25 <seeg> i'm trying to solve project euler problems in haskell, i did couple in python but went back because i think it's a good idea to learn a new language
07:06:39 <seeg> so i'm doing this one: http://projecteuler.net/index.php?section=problems&id=5
07:06:51 <pastorn> @type runRWST
07:06:52 <lambdabot> forall r w s (m :: * -> *) a. RWST r w s m a -> r -> s -> m (a, s, w)
07:07:09 <seeg> basically it can be done on paper, you just multiply the prime numbers which have highest multiplicities
07:07:53 <whald> > 0/0
07:07:54 <lambdabot>   NaN
07:07:58 <whald> > 1/0
07:07:58 <lambdabot>   Infinity
07:08:09 <benmachine> > 2 * 3 * 2 * 5 * 7 * 2 * 3 * 11 * 13 * 2 * 17 * 19
07:08:10 <lambdabot>   232792560
07:08:48 <seeg> yeah, but how to program it in haskell
07:09:06 <seeg> so far i have factors function which gives a list of factors with multiplicities
07:09:29 <pastorn> main = runContT $ callCC \k -> runRWST mainLoop k initState
07:09:34 <pastorn> EvanR-work: ^^ something like that
07:09:45 <pastorn> EvanR-work: then ask =~= break
07:10:12 <EvanR-work> RWST?
07:10:21 <pastorn> ReaderWriterStateTransform
07:10:28 <pastorn> all in one :D
07:10:32 <EvanR-work> hah
07:10:36 <zygoloid> > let minDivBy = foldr lcm 1 . enumFromTo 1 where lcm a b = (a * b) `div` gcd a b in minDivBy 10
07:10:37 <lambdabot>   2520
07:10:41 <zygoloid> seeg: ^^ that's how i'd do it
07:11:04 <pastorn> EvanR-work: my MIRKK-monad is RWST BotReader () BotState IO a
07:11:05 <benmachine> @unmtl RWST r w s m a
07:11:05 <lambdabot> r -> s -> m (a, s, w)
07:11:14 <zygoloid> hmm, lcm is in Prelude too, didn't know that :)
07:11:21 <zygoloid> > let minDivBy = foldr lcm 1 . enumFromTo 1 in minDivBy 10
07:11:22 <lambdabot>   2520
07:11:29 <benmachine> @unmtl ReaderT r (WriterT w (StateT s m)) a
07:11:30 <lambdabot> r -> s -> m (a, w, s)
07:11:33 <benmachine> close enough
07:11:43 <edwardk> @src lcm
07:11:44 <lambdabot> lcm _ 0     =  0
07:11:44 <lambdabot> lcm 0 _     =  0
07:11:44 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
07:12:01 <EvanR-work> pastorn: and anywhere in the runRWST you can exit, or restart?
07:12:02 <zygoloid> > map (\n -> foldr lcm 1 [1..n]) [1..20]
07:12:03 <lambdabot>   [1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,1...
07:12:12 <seeg> zygoloid, nice, just need to understand this...
07:12:16 <pastorn> EvanR-work: whenever you use k
07:12:31 <pastorn> you will go to the line after callCC in your main function
07:12:33 <EvanR-work> ah
07:12:41 <EvanR-work> trippy
07:12:52 <pastorn> EvanR-work: yes, so you probably want to do
07:13:02 <zygoloid> seeg: well, the answer is the lowest common multiple of [1..n]
07:13:16 <pastorn> get >>= \s -> (asks exit) s
07:13:54 <pastorn> oh, sorry
07:13:54 * zygoloid wonders whether there's a newtype wrapper for an lcm Monoid, as there is for Sum and Product
07:14:11 <pastorn> that's unnessesary, you get that by using runRWS either way...
07:14:21 <benmachine> zygoloid: it'd be a bit of a forest if you had one for every associative operation ever
07:14:43 <EvanR-work> pastorn: so no matter what s is, you exit the continuation
07:15:01 <zygoloid> benmachine: not all of them, just the monoids in the Prelude :)
07:15:10 <pastorn> EvanR-work: i that's correct
07:15:27 <pastorn> i haven't actually used MonadCunt for anything yet
07:15:35 <pastorn> but the wikibooks article, read it
07:15:37 <benmachine> how freudian
07:15:39 <EvanR-work> MonadCunt eh
07:15:41 <benmachine> @hoogle a -> a -> a
07:15:41 <lambdabot> Prelude asTypeOf :: a -> a -> a
07:15:42 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
07:15:42 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
07:15:43 <pastorn> exactly
07:15:44 <JuanDaugherty> lol
07:16:10 <pastorn> brainfuck bonanza
07:16:34 <EvanR-work> i guess s is important if you want to continue the bot later
07:16:47 * benmachine wonders if seq is associative
07:16:53 <benmachine> I guess it is?
07:17:00 <pastorn> EvanR-work: yeah, i was thinking of using that as a restart mechanism
07:17:14 <pastorn> perhaps in conjunction with some dynamic haskell loading stuff
07:17:26 <Cale> benmachine: yes
07:17:27 <pastorn> so i could dynamically reload my bot without losing any connections
07:17:49 <EvanR-work> pastorn: does your runRWST have to liftIO whenever it does commands
07:18:00 <pastorn> yes
07:18:10 <pastorn> EvanR-work: but i only use that in two places
07:18:16 <pastorn> readMSG and writeMSG
07:18:24 <pastorn> so it's cool
07:18:25 <benmachine> doesn't have a right identity though, hmph
07:18:26 <EvanR-work> i suppose you could hide that in your low level IO stuff, which returns the appropriate type so you dont have to lift
07:18:37 <pastorn> yes
07:18:42 <pastorn> hang on, i'll show you
07:18:46 <benmachine> (obviously, in retrospect)
07:18:49 <Cale> benmachine: If either a or b is _|_, it's easy to see that a `seq` b `seq` c is _|_ no matter how you associate it. If neither is _|_, it's easy to see that it's c, again, no matter how it's associated.
07:18:53 <EvanR-work> but maybe then youll have to lift even more at the low level socket layer
07:19:29 <benmachine> I guess you can identity any associative binary operation with a Maybe, but that might be overkill
07:19:42 <Cale> heh
07:19:42 <benmachine> (yes, I just used identity as a verb)
07:20:32 <applicative> benmachine, sorry, yes my applicative nonsense came from misparsing some @pl advice
07:20:52 <benmachine> zygoloid: reading through :browse Prelude, I concede there actually aren't that many associative binary operations
07:21:20 <quicksilver> benmachine: not this one.
07:21:29 <pastorn> EvanR-work: http://bitbucket.org/pastorn/madeleine/src
07:21:31 <benmachine> quicksilver: hm?
07:21:31 <quicksilver> benmachine: _|_ `seq` Nothing would still have to be _|_, not Nothing, surely?
07:21:35 <Cale> benmachine: what?
07:21:46 <pastorn> i don't know if that version there compiles... having a little hg trouble at the moment
07:21:54 <pastorn> EvanR-work: look in Base.hs and Main.hs
07:22:21 <quicksilver> erm, I meant that the other way around I think
07:22:37 <benmachine> quicksilver: well, your mappend pattern-matches the constructor first, and only seqs if both are Justs
07:22:46 <quicksilver> oh, ok
07:22:54 <benmachine> but like I said, overkill
07:23:16 <benmachine> Cale: I meant, ones that don't already have a Monoid instance/newtype
07:23:25 <Cale> ah, okay
07:23:29 <applicative> Fanael 's problem is a little clearer in the form    readFile "a.txt" >>= \contents -> putStrLn contents  >> return contents
07:23:38 <Cale> I suppose that perversely you have things like (==) and (/=)
07:23:48 <Cale> (well, that's not so terrible :)
07:24:14 <benmachine> mm
07:24:22 <EvanR-work> pastorn: ok
07:24:30 <EvanR-work> exactly what i was thinking
07:24:51 <pastorn> oh right, listen and write were my names :)
07:24:56 <EvanR-work> this style is interesting, your application is a named stack of monad transformers
07:25:03 <Cale> There's max and min
07:25:08 <EvanR-work> everything returns that type
07:25:13 <Cale> Do they have newtype wrappers?
07:25:17 <benmachine> I don't believe so
07:25:24 <Cale> Yeah, seems not
07:25:26 <pastorn> EvanR-work: GeneralizedNewtypeDeriving is AWESOME
07:25:26 <benmachine> they don't have identities though unless you do the Maybe thing
07:25:56 <pastorn> EvanR-work: MIRKK is MonadState, MonadReader and MonadWriter (if i want to)
07:25:56 <Cale> Of course, it only works for types with a least or greatest element
07:26:18 <pastorn> EvanR-work: oh, and it's MonadIO
07:26:52 <pastorn> if i change it to ContT (RWST BR () BS IO) a then i can get an instance of MonadCont for it
07:26:55 <Cale> But you could have an instance which had a Bounded context
07:26:57 <EvanR-work> so effectively we have a c program that can do anything anywhere? :)
07:27:02 <benmachine> maybe there actually should be a Semigroup class
07:27:12 <pastorn> EvanR-work: pretty much
07:27:16 <EvanR-work> hehe
07:27:20 <benmachine> seems like there are at least... two things which would go in it
07:27:25 <Cale> heh
07:27:31 <benmachine> <_<
07:27:36 <Cale> I suppose
07:27:55 <Cale> There are cases where semigroups are actually the right place to abstract to.
07:28:15 <EvanR-work> pastorn: the cont state reader writer IO combination should be a standard type, maybe called 'typical scripting language' or something
07:28:26 <pastorn> haha
07:28:35 <pastorn> make your own library
07:28:37 <pastorn> EvanLib
07:28:43 <pastorn> and import it EVERYWHERE
07:28:57 <EvanR-work> liberate yourself from the confines of purity
07:29:13 <Cale> I remember a talk by Pippinger (I think) about the complexity of addition where semigroups came up in some way.
07:29:14 <pastorn> EvanR-work: well, it's still pure :)
07:29:20 <EvanR-work> uh huh
07:29:22 <Cale> It was a long time ago that I saw it.
07:30:56 <Cale> http://www.archive.org/details/Nicholas1987 -- should be here, but my connection is acting up a bit
07:32:11 <Cale> Nice, they have an ogg version: http://ia341335.us.archive.org/1/items/Nicholas1987/Nicholas1987.ogv?Nicholas1987/Nicholas1987.ogv
07:35:43 <benmachine> oh hey Sets are Foldable but not Traversable
07:35:50 <benmachine> I'd often wondered what was one but not the other
07:36:09 <Cale> That's an oversight, I think.
07:36:24 <benmachine> Traversable has a Functor superclass
07:36:30 <Cale> oh, right
07:36:39 <Cale> tsk, that problem again
07:36:55 <Cale> We can hope for the constraint family future in which it's solved :)
07:40:43 <quicksilver> Cale: if you made sets traversable, would you 'collapse' sets when elements became equal?
07:40:53 <quicksilver> seems like you'd have no choice
07:41:03 <quicksilver> but that breaks some of the theorems about traversable
07:42:05 <interferon> If a module doesn't export a symbol, can other modules still access it with a fully-qualifies name or is it truly private?
07:42:24 <quicksilver> it's truly private.
07:42:31 <quicksilver> the workaround is to have a .Internals module which does export it
07:42:40 <interferon> Great. Thanks
07:42:42 <quicksilver> but not export it from the 'public' modules.
07:42:46 <Jafet> Heh, workarounds before you ask for them
07:43:01 <interferon> Jafet: :)
07:43:12 <interferon> Actually im happy about that behavior
07:43:38 <interferon> What's my best option fir a Haskell gui on os x?
07:43:47 <Cale> quicksilver: Basically, I would imagine that the behaviour would be the same as if you'd converted back and forth from ordered lists.
07:44:44 <interferon> Are there Haskell-Swing bridges?
07:45:18 <Jafet> If best means ugliest
07:45:51 <quicksilver> Cale: basically traverse doesn't currently change the size of a structure as measured by length . toList
07:46:01 <quicksilver> Cale: under your proposal it would.
07:46:09 <quicksilver> Cale: dunno if that's an important invariant but it is one :)
07:46:43 <quicksilver> @type length . Data.Foldable.toList
07:46:44 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Int
07:46:47 <tromp> so why wld you collpase
07:47:07 <quicksilver> because you have to; you can't have two equal elements in a set.
07:47:10 <Cale> quicksilver: But the same goes for fmap
07:47:21 <tromp> a set implementation can still have duplicates?!
07:47:25 <Cale> quicksilver: and I think we want Set to be a Functor :)
07:47:29 <aristid> Cale: how did you change ++ and these things for lambdabot? did you change the prelude?
07:47:29 <quicksilver> tromp: no, that's what what "set" means.
07:47:41 <Cale> aristid: no, I just imported the Prelude hiding them
07:47:44 <tromp> set means a certain interfface
07:48:10 <Cale> aristid: and then defined them locally
07:48:11 <quicksilver> tromp: set means you can't have duplicates.
07:48:25 <quicksilver> {1} \union {1} is just {1}
07:48:35 <aristid> Cale: ah. will you change ++ when <> is out? :)
07:48:47 <Cale> hm?
07:48:54 <aristid> :t (++)
07:48:55 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:49:21 <quicksilver> > S.singleton 1 `S.union` S.singleton 1
07:49:21 <aristid> Cale: i was told that <> will be the "official" operator for mappend
07:49:22 <lambdabot>   fromList [1]
07:49:30 <tromp> yes, and {1,1} = {1}, so you can have the first representation too
07:49:32 <Cale> aristid: huh, interesting
07:49:42 <benmachine> aristid: I've heard some people wanting that but I don't know if it's actually happening
07:49:48 <quicksilver> Cale: http://hackage.haskell.org/trac/ghc/ticket/3339
07:49:53 <Saizan> tromp: we're talking about what you can see from the interface anyway
07:50:10 <aristid> :t {1}
07:50:11 <lambdabot> parse error on input `{'
07:50:33 <tromp> so if the interface has set difference, you just have to make sure that {1,1} \\ {1} = {}
07:51:02 <quicksilver> sets don't admit the possibility of duplicate elements, this is a semantic point
07:51:07 <quicksilver> I couldn't care less how it's implemented.
07:51:20 <fax> it's usually implemented as a tree
07:53:02 <Cale> quicksilver: Well, to be fair, the question of whether an element is duplicated in a set or not is not even a question you can really ask ;)
07:53:23 <fax> {1,2,3} is quite nice syntax
07:53:24 <Cale> Sets are values which are completely determined by which elements belong to them, and nothing else.
07:53:40 <ksf> otherwise it'd be a bag
07:53:42 <ksf> ...or list
07:53:57 <benmachine> hmm
07:54:04 <quicksilver> Cale: except, as I pointed out, you can 'observe' the number of elements in a set by length . toList (or some other way)
07:54:09 <benmachine> "Let's wrap this up in two weeks, this time for sure :-)" - 8 months ago
07:54:15 <benmachine> oh well :P
07:54:20 <quicksilver> Cale: and that's the observation which shows an invariant changes
07:54:26 <benmachine> sets do have cardinality
07:54:29 <quicksilver> it might not be an important invariant, sure :)
07:54:42 <aristid> in my noobish ways, i was recently wondering about the Maybe monad. does it support short-circuiting? i mean, it could just stop when a Nothing is reached, right?
07:54:53 <quicksilver> but it is currently one that fmap and traverse preserve
07:54:54 <benmachine> I suppose you can't render a set empty though
07:54:54 <Cale> aristid: and it does
07:55:07 <quicksilver> so I think we'd be losing 'something'
07:55:10 <tromp> toList is problemetic for sets. shld equal sets give equal lists?
07:55:35 <ksf> they probaly do
07:55:39 <tromp> then you need to have Ord
07:55:41 <Jafet> aristid, "stop"?
07:55:50 <Cale> aristid: Which you could say is because of laziness, or you could say that it's because the evaluator is unwilling to evaluate underneath a lambda
07:55:55 <aristid> Jafet: guess why i prepended "noobish ways" :P
07:55:58 <Jafet> Might still do computation if you seq or IO
07:55:58 <quicksilver> it's not just toList that's problematical
07:56:04 <Jafet> But I defer to Cale on that
07:56:05 <quicksilver> it's the whole Foldable + Traversable classes
07:56:10 <quicksilver> they all impose order on the elements
07:56:12 <Fanael> Does it, really? (>>=) is left-associative, Nothing >>= Nothing >>= Nothing would cause to match all these Nothings.
07:56:16 <aristid> Jafet: no IO in a Maybe monad, right?
07:56:18 <Cale> When you have something like   Nothing >>= \v -> ... more stuff ...
07:56:27 <benmachine> Nothing >>= f = Nothing
07:56:28 <quicksilver> so to be semantically consistent we need equal sets to expose a consistent order
07:56:29 <benmachine> this is true for all f
07:56:31 <Fanael> Or I got this wrong?
07:56:41 <Jafet> aristid, you could have a MaybeT I guess
07:56:44 * quicksilver might have meant 'expose' not 'impose'
07:56:50 <aristid> Jafet: was talking about pure Maybe:)
07:57:00 <Cale> Fanael: That doesn't typecheck
07:57:01 <tromp> if you omit toList, then foldable/traversable should be fine with duplicates in implementation, not visible through set interface
07:57:02 <Jafet> Then there's seq
07:57:35 <Cale> There's no way to evaluate the 'more stuff' part in my example, because it's underneath an un-applied lambda
07:57:47 <Cale> and the evaluator just doesn't do that
07:58:07 <tromp> oops, foldable can show presence of duplicates
07:58:24 <Fanael> I see... Let's pretend that I meant Nothing >>= \_ -> Nothing >>= \_ -> Nothing.
07:58:25 <Cale> So we'd need a value v of an appropriate type to apply that function to if we wanted evaluation there to proceed, but the 'Nothing' gives us none
07:58:28 <tromp> was thinking of some functor instead
07:58:52 <Cale> Fanael: The evaluator never evaluates underneath a lambda which isn't applied to a value yet.
07:59:16 <benmachine> Fanael: it doesn't left-associate then because the lambda extends as far right as possible
07:59:45 <benmachine> -> is infixr -1 :P
07:59:47 <Fanael> Okay, so I didn't write anything ;)
07:59:57 <aristid> what happens if you use mapM?
08:00:09 <aristid> :t mapM
08:00:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:00:29 <aristid> hmm yeah i guess it will immediately return Nothing
08:00:44 <aristid> so is there any reason not to use the Maybe monad? :)
08:01:14 <Cale> aristid: Maybe Maybe is unsuited to the task you're performing?
08:01:31 <aristid> .oO(joy through capitalization)
08:02:07 <Cale> aristid: The fact that Maybe is a monad is important only when you have a bunch of functions with Maybe results and you want to chain them together in such a way that the whole thing fails (with Nothing) if any of the intermediate operations produces Nothing
08:02:11 <quicksilver> tromp: you can't omit toList
08:02:21 <quicksilver> tromp: all the functions in Foldable are basically equivalent :)
08:02:44 <quicksilver> tromp: and traversabl has the same issue
08:02:48 <Cale> (or maybe not functions, but just Maybe values)
08:02:57 <fax> wish we had type faces
08:03:10 <aristid> Cale: which is quite cool.
08:03:12 <fax> just lower, Camel and UPPER is not enough
08:03:17 <quicksilver> tromp: consider mapM (\_ -> putStrLn "Hello"); that would expose duplicates :)
08:03:22 <fax> we need mathbb, mathcal, ...
08:03:38 <Cale> fax: unicode...
08:03:43 <fax> I should have said Title
08:03:47 <quicksilver> fax: I belive I would find qualified names much more readable if they were in a smaller typeface and subscript
08:03:56 <quicksilver> fax: I might not find them abhorrent, then
08:04:12 <quicksilver> transpose_{\mathsf{Data.List}}
08:04:14 <quicksilver> or something.
08:04:20 <fax> yeah that would be a lot nicer
08:04:32 <fax> there is so much room for improvement
08:04:42 <tromp> you're right. folds expose duplicates. maps cant though
08:04:55 <quicksilver> tromp: maps dont' but mapM (traverses) do.
08:07:54 <quicksilver> tromp: and they also expose the order, of course.
08:10:37 <dpratt71> I believe that there is (or can be) a .ghci file for issuing an initial set of commands to ghci on start; where might I find (put?) this on a Windows system (Haskell Platform)?
08:15:26 <fryguybob> dpratt71: c:\users\[username]\AppData\Roaming\ghc\ ?
08:15:44 <fryguybob> dpratt71: what version of windows?
08:16:16 <dpratt71> 7; I'll check there
08:16:45 <fryguybob> dpratt71: My ghci_history is there on 7.
08:19:12 <siracusa> When trying to install wx package, I get an error: `setup.exe: wx-config: runGenProcess: does not exist (No such file or directory)' but wx-config is on the path, I can call it in the console.
08:21:41 <dpratt71> fryguybob: thanks; it appears to locate it in the root of $HOMEDRIVE\$HOMESHARE here
08:22:17 <jbapple> Did everyone see this: http://focalize.inria.fr/ ? "a programming environment to develop certified programs. The environment is based on a functional programming language with object-oriented features. The language allows the programmer to write formal specifications and proofs of the program in a unified and consistent setting."
08:22:41 <dpratt71> which results in the somewhat obnoxious behavior of pointing to a different location depending on whether I logged in while connected to the domain
08:22:46 * dpratt71 *sigh*
08:23:23 <fryguybob> dpratt71: Humm that's too bad.
08:23:57 <Saizan> dpratt71: ghci also loads the .ghci in the current working directory if it finds one, so it might be that?
08:24:21 <dpratt71> Saizan: you might be on to something there...
08:24:43 <dpratt71> ...I didn't find it where fryguybob did, so I just assumed
08:25:42 <dpratt71> Saizan: yep, it was the current directory
08:26:05 <chrisdone> jaspervdj: can you merge my snerge on the blazehtml fork kthx
08:27:07 <chrisdone> jaspervdj: also when are you going to put blaze on hackage?
08:27:25 <Saizan> dpratt71: .ghci is not created by default, you only make one if you need it
08:28:02 <jaspervdj> chrisdone: yesterday I made a planning together with meiersi and tibbe
08:28:13 <chrisdone> jaspervdj: what planning?
08:28:25 <jaspervdj> chrisdone: blazehtml google summer of code
08:28:25 <aristid> hmm interesting, there's an important difference between (:) and lisp/scheme cons: the latter allow for the second parameter not being a list
08:28:26 <copumpkin> omnom
08:28:39 <chrisdone> jaspervdj: how much work remains to be done on it?
08:29:09 <pikhq> aristid: That'd just a consequence of Lisps being dynamically typed.
08:29:11 <quicksilver> aristid: right, because lisp/scheme is not typed
08:29:26 <quicksilver> aristid: however haskell lets you define your own cons cell if you wish
08:29:36 <aristid> quicksilver: with tuples or datas?
08:29:40 <quicksilver> aristid: data AristidMagic a b c = Cons something somethingelse
08:29:51 <pikhq> A static type system is the only reaon that (:) only takes an "a" and a "[a]".
08:30:01 <pikhq> Rather than an "a" and a "b".
08:30:02 <chrisdone> Common Lisp and Scheme both have types, the former supports strict type annotations too
08:30:07 <quicksilver> you can come up with appropriate a,b,c,something,somethingelse to encode any particular pattern of usage in a lisp program
08:30:10 <jaspervdj> chrisdone: not much in terms of code, but quite a lot in terms of design and optimization
08:30:20 <aristid> pikhq: yeah it must be that way when you start thinking about it
08:30:25 <chrisdone> CONS just happens to be a pair that's used for lists
08:30:30 <aristid> i was somehow still unaware before i tried it out
08:30:57 <quicksilver> aristid: indeed, (,) is a fully polymorphic cons cell
08:31:08 <quicksilver> > (1,(2,(3,(4,()))))
08:31:09 <lambdabot>   (1,(2,(3,(4,()))))
08:31:10 <chrisdone> jaspervdj: right. do you think the outer API will remain fairly stable? because I need to use it in actual projects and would like to promote others to use it
08:31:16 <quicksilver> aristid: arguably that's like a LISP list.
08:32:00 <aristid> quicksilver: the problem is that every "list" of different length has a different type this way (?)
08:32:09 <jaspervdj> chrisdone: the combinators probably will
08:32:11 <chrisdone> jaspervdj: speed isn't a big concern for me, it's already 100 times faster than Text.Html. but the style of writing HTML is useful to me
08:32:27 <jaspervdj> chrisdone: the monadic notation will also stay
08:32:27 <quicksilver> aristid: the "problem" :)
08:32:28 <chrisdone> jaspervdj: that's OK then
08:32:33 <jaspervdj> chrisdone: the types may vary though
08:32:45 <aristid> quicksilver: you can't use fold* this way :)
08:32:50 <quicksilver> aristid: you can regularise those types with type classes, that's that HList does
08:32:53 <chrisdone> :/
08:33:00 <aristid> quicksilver: HList?
08:33:12 <aavogt> @where hlist
08:33:13 <lambdabot> http://homepages.cwi.nl/~ralf/HList
08:33:52 <jaspervdj> chrisdone: and indeed, I seem to have forgotten the method attribute
08:33:57 <aristid> thx aavogt
08:34:12 <chrisdone> jaspervdj: hehe, i thought it was funny as it was one of the first ones I typed out
08:34:17 <quicksilver> HList uses its own type but it's useful to understand that it really *is* nested tuples
08:34:25 <quicksilver> it's just a set of very clever typeclasses over nested tuples
08:35:05 <quicksilver> also, I don't think HList is honestly recommended for practical use; I think it's a very powerful proof of concept.
08:35:07 <Jafet> Someone draw a comparison to cons lists here
08:35:08 <quicksilver> some may disagree.
08:35:25 <quicksilver> cons lists is where we started, Jafet
08:35:35 <quicksilver> aristid was asking about lisp
08:35:49 <Jafet> I hope we don't end at HList, or other things that cause vague fear in me
08:35:59 <quicksilver> we have already ended at HList, I believe.
08:36:00 <quicksilver> :)
08:36:06 <jaspervdj> chrisdone: also, I'm using a metacode way to generate attributes/tags
08:36:09 <aristid> Jafet: yeah we're already there
08:36:22 <chrisdone> jaspervdj: what do you mean?
08:36:42 <chrisdone> jaspervdj: some script for generating the tag/attr list?
08:37:10 <dpratt71> this is weird; I didn't have a "...\Roaming\ghc" directory at all; once I created it, ghci_history showed up; it doesn't try to load .ghci from there, though
08:37:17 <dpratt71> it *does* look for ghci.conf, though; what's that for?
08:37:54 <chrisdone> Jafet: is there a problem with a heterogenous list? the type system ensures access to it is homogenous?
08:37:56 <fryguybob> dpratt71: I just tried it and ghci.conf works
08:38:16 <chrisdone> or at least well typed with some generic interface
08:38:26 <Jafet> Yes, but I have an annoying habit of not using things I don't understand the implementations of
08:38:41 <jaspervdj> chrisdone: yeah, util/GenerateTags.hs
08:38:52 <dpratt71> fryguybob: thanks; as it happens, I just Bing-ed ghci.conf and got a detailed answer
08:39:09 <chrisdone> Jafet: that sounds like an impractical philosophy :p
08:39:25 <chrisdone> jaspervdj: ah, ok.
08:39:51 <dpratt71> all good now, thanks fryguybob, Saizan
08:40:08 <fryguybob> dpratt71: Thank you!, now I have :hoogle :D.
08:43:37 <sioraiocht> Ihave been pulling my hair out over a 2 letter bug for like, 2 hours
08:43:52 <sioraiocht> I had too much faith in the type checker, it owuld seem
08:43:53 <sioraiocht> =p
08:43:58 * BMeph wants to know what kind of car Jafet gets, if he ever does... ;)
08:44:15 <Jafet> I dislike cars for other reasons
08:44:23 <Jafet> Anyway, I'm usually the passenger.
08:44:26 <BMeph> Jafet: Do you have a car, or do you just bike everywhere? :)
08:44:26 <chrisdone> BMeph: maybe something like those made on Scrap Heap Challenge
08:45:12 <aristid> Jafet: cars aren't that hard to understand :)
08:45:28 <Jafet> Some parts are.
08:45:38 <Jafet> Ask Toyota.
08:45:39 <BMeph> Jafet: Technically, if you're a passenger, doesn't that mean that you're using the driver?
08:45:43 <winxordie> car maybe, but cdr's pretty hard to get
08:45:59 <aristid> winxordie: ;)
08:46:08 * BMeph cues the rimshot for winxordie 
08:46:09 <aristid> winxordie: full-cycle back to lists \o/
08:46:17 <djahandarie> Toyota should switch all their systems to Haskell. :-)
08:46:17 <winxordie> hehehehe
08:46:21 <chrisdone> winxordie: my other car is a cdr
08:46:24 <fryguybob> I was waiting for the cdr...
08:46:40 <Jafet> I bet you couldn't use a car analogy in #lisp.
08:47:01 <BMeph> chrisdone: You should make bumper stickers saying that. I'll make the T-shirts... ;)
08:47:16 <djahandarie> Haha
08:47:17 <winxordie> I'd buy that shirt.
08:47:25 <djahandarie> I'd buy the bumper sticker. :P
08:48:05 * BMeph wants to tell his boss that he tried to get to work, but his cdr wouldn't start...
08:51:51 <fryguybob> "I can't make head or tails out of car and cdr" ?
08:52:20 <djahandarie> lol
08:52:22 <aristid> HList's hAppend is cool stuff.
08:55:23 <aristid> oh wait. when i think about it, HList looks suspiciously similar to boost.fusion
08:59:17 <aristid> it's a bit unelegant how haskell doesn't support numbers in types :/
08:59:54 <jmcarthur> yeah :(
09:00:04 <jmcarthur> but you can create type level numerals at least
09:00:09 <Jafet> It's very inelegant to do it like C++ does
09:00:50 <mathstuf> "numbers in types" as in something like "Matrix2d"?
09:01:04 <jmcarthur> mathstuf: no, types parameterized by numbers
09:01:14 <jmcarthur> mathstuf: for example, Matrix 2 2
09:01:19 <mathstuf> ah
09:02:55 <augur> anyone read any of barker or shan's work on continuations in natural language? they have some very interesting type-theoretic stuff that seems like it'd be good fun for the haskell community
09:03:16 <aristid> jmcarthur: Matrix (hSucc (hSucc hZero)) (hSucc (hSucc hZero)) :D
09:04:31 <aavogt> except you can have type N3 = HSucc (HSucc HZero)...
09:04:57 <jmcarthur> aristid: i was using some sugar, is all
09:04:58 <aavogt> provided somebody else has written those, or the code to generate them, it isn't too awkward
09:05:07 <jmcarthur> yeah it's not
09:05:12 <aristid> aavogt: that feels like preprocessor metaprogramming in c++ :P
09:05:33 <jmcarthur> you can even define a type level operator to string them together to make multidigit numbers
09:05:35 <aavogt> you can do preprocessor metagprogramming in haskell too :)
09:05:51 <Jafet> aavogt, succ (succ 0) /= 3
09:06:06 <aristid> jmcarthur: oh sure, but it's still not quite elegant :)
09:06:12 <aavogt> Jafet: true
09:06:32 <aavogt> I changed my mind about HZero or HOne
09:06:44 <aristid> Jafet: clearly N3 refers to the number 2.
09:07:01 <aavogt> it's the third number
09:07:22 <aavogt> jmcarthur: or wait until you may use quasiquotes in types....
09:07:31 <aristid> type N1 = HZero :)
09:08:45 <gwern> augur: don't continuations get used for backtracking parsing of sentences?
09:09:03 <augur> gwern: they mgiht!
09:09:27 <augur> barker is using them for quantification, however.
09:11:07 * gwern wonders how that works
09:11:26 <augur> gwern: which what?
09:11:27 <jmcarthur> aristid: it's not as pretty as something like type level numeric literals might be, but i wouldn't call it any less elegant
09:11:37 <jmcarthur> it's the same code structure that would implicitly be there with sugar, anyway
09:11:39 <gwern> contiuations for quantification
09:12:47 <aristid> jmcarthur: i'm not sure Succ/Zero is the optimal internal representation.
09:12:55 <augur> gwern: oh, well, natural language has insitu quantifies, right. "john met someone yesterday", not "someone(x)[john met x yesterday]"
09:13:24 <jmcarthur> aristid: it's pretty ideal for many kinds of proofs
09:13:55 <augur> in Chomskyan syntax, you'd just let "someone" be the same syntactic type as "john", and then you'd do quantifier raising to displace it, leaving the variable behind to be bound by the quantifier after raising.
09:14:41 <aristid> jmcarthur: forgive me for thinking in more "practical" terms :)
09:15:29 <augur> but maybe you dont want that, so barker lets "someone" be the appropriate type for quantification, then there are rules that relate the syntactic structure with the types such that "john met someone yesterday" can be generated even tho from the proof side, "someone" is combining with "john met NP yesterday"
09:16:40 <aavogt> aristid: and efficiency at compile-time isn't terribly important
09:17:51 <jmcarthur> aristid: the whole point of putting things like this is the type system is to prove things about them, so i don't see how this is impractical at all
09:17:57 <aristid> aavogt: uh yes it is. i'm way too accustomed to seemingly eternal compile times :)
09:18:00 <Jafet> aavogt, we must remember that aristid uses C++
09:18:09 * gwern was about to make a c++ joke. dangit
09:18:22 <Jafet> It isn't a joke!
09:18:28 <danharaj> jmcarthur: Impractical, maybe not, but it's yet another way in which dependent types are faked instead of just having dependent types.
09:18:46 <gwern> Jafet: I think c++ is a joke
09:18:47 <aristid> jmcarthur: is it harder to do the same things with "native" integer parameters?
09:18:49 <gwern> do you disagree?
09:18:56 <Jafet> If so, it's rather unfunny
09:19:07 <gwern> it's of the physical comedy kind
09:19:18 <Jafet> Ah, like blackadder.
09:19:27 <gwern> 'when you fall into a sewer, that's humorous. when I get a papercut, that's a tragedy'
09:19:32 <gwern> or however that quote goes
09:19:35 <jmcarthur> danharaj: i agree, but on the other hand dependent types invalidate some of the other nice properties that haskell has, like type inference
09:19:44 <jmcarthur> i do wish agda would come along, though
09:20:07 <Jafet> "Faked"? Dependent typing is a theoretical capability
09:20:19 <Jafet> You have it or not
09:20:21 <aavogt> aristid: you too can have long compile times with excessive use of hlist
09:20:26 <aavogt> * in haskell
09:20:37 <jmcarthur> aristid: you would end up doing the same things and probably with the same performance
09:20:38 <aristid> aavogt: i bet.
09:20:52 <jmcarthur> *largely the same performance
09:20:53 <aavogt> but mostly if you let the compiler infer types
09:21:10 <danharaj> Jafet: There are type system extensions, and things like this where you manually lift values to types, that would be subsumed by dependent typing.
09:21:25 <aavogt> if you get your editor to write them in, compile times are somewhat improved
09:21:26 <danharaj> jmcarthur: True.
09:21:29 <aristid> jmcarthur: sure? when doing Matrix operations for example you might well do arithmetic operations with the parameters, no?
09:21:52 <Guest36401> Hi all, can anyone tell me where i can get some help on my homework? Im kind of stuck on a question and just need a bit of help. Is there are forum that can help me out or ...?
09:21:58 <jmcarthur> aristid: but you can't prove anything about it unless you are doing the math more abstractly than just native ints
09:22:51 <aristid> jmcarthur: you could use something like Integer, which is conceptually equivalent to Succ/Zero (if you ignore the additional feature of signedness)
09:22:52 <chrisdone> Guest36401: you can ask here, or on the haskell-beginners mailing list
09:22:55 <jmcarthur> aristid: for example, say i have a matrix multiplication function. the types would have m, n, and p for the dimensions, not 2, 3, and 4 (or whatever)
09:23:09 <jmcarthur> aristid: m, n, and p would have to work, too
09:23:29 <chrisdone> Guest36401: what's your question?
09:23:32 <Jafet> Somewhat obligatory http://ideone.com/1A3qD
09:23:35 <aristid> jmcarthur: i don't quite understand what you mean
09:24:00 <jmcarthur> aristid: i mean that polymorphism would mean you don't necessarily have concrete numbers
09:24:01 <chrisdone> Jafet: haha what the hell
09:24:11 <aristid> Jafet: ah, that's very easy to read :)
09:24:15 <jmcarthur> aristid: so you need something easier to prove with *in general*
09:24:59 <aristid> jmcarthur: ah i guess i partially understand.
09:25:35 <jmcarthur> aristid: the only way i know of to prove something about every possible input to a function over native int would be to apply the function to every possible int, but if it's a recursive definition of nat instead then you could just prove a base case and p(n)->p(n+1)
09:26:53 <aristid> jmcarthur: and with hSucc you can just say hSucc param?
09:26:53 <Guest36401> chrisdone: ive basically got a database where i can add movies into, let users rate the movie etc.
09:27:04 <chrisdone> Guest36401: mmmhm
09:27:19 <Guest36401> 1 sec ill type you the code that ive already got
09:27:46 <Guest36401> rateFilm
09:27:50 <Guest36401> whoops
09:27:56 <jmcarthur> aristid: there must be a working example i'm unaware of
09:28:43 <aristid> jmcarthur: you've convinced me that something more "structured" than native integers are needed :)
09:29:11 <jmcarthur> aristid: if you are interested in this stuff you should check this out: http://adam.chlipala.net/cpdt/
09:29:14 <aristid> well, maybe not needed. but useful for some things
09:29:36 <Guest36401> chrisdone: i think its better if i do the mailinglist for now..cause i think this doesnt work properly if i type in all the code here
09:29:45 <Guest36401> thanks for helping out tho!
09:29:52 <jmcarthur> aristid: it's involved, but goes through everything step-by-step, and you'll come out with a much better understanding of the kinds of things that can be done to prove things using a powerful type system
09:30:08 <chrisdone> Guest36401: http://hpaste.org/
09:30:08 <siracusa> Guest36401: You can use hpaste to paste your code
09:30:14 <chrisdone> ah crap
09:30:21 <chrisdone> http://paste.lisp.org/
09:30:46 <siracusa> Oh, hpaste is down
09:30:52 <chrisdone> k i'm off ciao
09:31:36 <aristid> jmcarthur: not sure.
09:31:54 <Twey> Huh… Cabal thinks it's newer than itself.
09:32:06 <Twey> cabal-install, anyway.
09:32:18 <benmachine> maybe it IS
09:32:24 <jmcarthur> aristid: it's just a suggestion. i don't know how experienced you are with functional programming yet. it may be better to just stick with haskell a bit longer, i dunno
09:32:57 <dcoutts_> Twey: hmm?
09:33:05 <jmcarthur> aristid: but i do promise that guide is not so hard to follow if you don't speedread too much
09:33:18 <aristid> jmcarthur: well most of my experience in functional programming is actually c++ templates... i haven't seriously looked at haskell until very recently.
09:33:25 <Twey> dcoutts_: Every time I ‘cabal update’, cabal-install tells me that there's a newer cabal-install available and that I should install it.
09:33:37 <jmcarthur> aristid: you're in for a treat then :)
09:33:54 <gwern> hah. chrisdone is dead to 4chan! Dead! http://dis.4chan.org/read/prog/1238891994
09:34:02 <dcoutts_> Twey: but you think it is wrong?
09:34:05 <gwern> '
09:34:05 <gwern> I trolled him so hard (by accident) that he lost faith in humanity
09:34:11 <aristid> jmcarthur: yeah yeah, though i still think c++ is better than its reputation :P
09:35:14 <jmcarthur> aristid: c++'s reputation is too mixed for me to say anything about its reputation, but my personal opinion of c++ is not very high. i will admit that its badness is exaggerated though
09:35:34 <Twey> dcoutts_: cabal update, see message, upgrade to 0.8.2, cabal update, see message, ‘upgrade’ to 0.8.2, cabal update, see message…
09:36:03 <Saizan> Twey: cabal --version ?
09:36:10 <dcoutts_> Twey: what does cabal --version say?  I suspect it's just that you've got an older cabal installed earlier on the $PATH
09:36:29 <Twey> Oh, that's weird.
09:36:38 <Twey> Got it, thanks.  ☺
09:37:11 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/670
09:37:34 <dcoutts_> it's an easy ticket I think, if anyone wants to have a go
09:37:41 <Guest36401> anyone that can help me out please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25374#a25374
09:37:46 <dcoutts_> should help remove confusion like what Twey just bumped into
09:38:34 <Twey> Damn
09:38:38 <Twey> Still can't install happstack
09:38:48 <Twey> I was hoping that would be fixed by now :-\
09:38:57 <quicksilver> changeFilm = doGuest36041'sHomework ?
09:38:59 <aristid> jmcarthur: i'm really impressed by haskell though. it's got some rough corners but it's really got an impressive level of abstraction
09:39:34 <Guest36401> ya is homework but im stuck on it..i can explain it in english but dont really know how to code it
09:39:53 <djahandarie> aristid, now check out template haskell
09:39:53 <jmcarthur> aristid: i'd say haskell roughest spots are library-level :(
09:40:01 <jmcarthur> *haskell's
09:40:09 <djahandarie> Guess Haskell is a LANGUAGE not an IMPLEMENTATION
09:40:09 <aristid> djahandarie: i don't think i'm ready for that.
09:40:16 <djahandarie> s/Guess/Guys/*
09:40:26 <gwern> no, haskell is an imeplementation. it's whatever ghc hq says it is
09:40:39 <jmcarthur> djahandarie: did anybody say anything that implies otherwise?
09:40:42 <djahandarie> Well I'll keep on using my other compilers
09:40:48 <ddarius> jmcarthur: Haskell's abstractions are library-level as well.
09:40:50 <gwern> if they say our modules must be formatted in goatse, then we'll grit our teeth and bend our code over
09:41:21 <jmcarthur> ddarius: i interpreted "level of abstraction" as "abstraction abilities"
09:42:29 <ddarius> Most of Haskell's "abstractability" doesn't come from (particularly-unique-to-Haskell) features.
09:42:50 <jmcarthur> right, but haskell is a mixing pot of them
09:43:45 <aristid> ddarius: well, i think much of it comes from the consistent purity.
09:43:53 <jmcarthur> the real hero is the lambda calculus and various ways of typing it
09:43:59 <jmcarthur> and *purity*
09:45:59 <aristid> few languages are really pure
09:46:06 <ddarius> jmcarthur: There you go.
09:46:07 <Saizan> is it wadler that has a superman t-shirt with a lambda instead of an S?
09:47:24 <aristid> jmcarthur: i wonder how important laziness is, though. it seems to make purity more viable, but i wonder if it's necessary.
09:47:44 <ddarius> aristid: It's not necessary in theory.
09:48:03 <jmcarthur> aristid: not necessary, but leaves enough leeway to do very powerful things
09:48:41 <jmcarthur> aristid: for example, it would not at all be worth it to compose recursive higher order functions instead of explicitly writing out a recursive function if it wasn't for laziness
09:48:48 <djahandarie> More powerful than a turing machine!
09:49:04 <djahandarie> It can solve the halting problem!
09:49:15 <jmcarthur> aristid: and par relies on it a lot, too, for example
09:49:25 * djahandarie spreads misinformation
09:49:30 <jmcarthur> (since haskell is non-strict, not just lazy)
09:49:37 <monochrom> > let x=x in x
09:49:41 <lambdabot>   mueval-core: Time limit exceeded
09:50:52 <monochrom> (that halted the conversation)
09:52:46 <tohava> Question, let's say I have a value v of some type t which has several named fields, one of them being named f and containing a value x
09:53:15 <tohava> I wish to create a new value v2 which exactly the same as v, but with the value of f being y instead
09:53:20 <tohava> (i.e. the rest of the fields have the same values, how do I do this?_)
09:53:31 <monochrom> v2 = v{f=y}
09:53:57 <aristid> monochrom: we're all stuck mentally evaluating your expression :)
09:55:17 <aristid> > fix show
09:55:18 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:56:39 <jmcarthur> monochrom: didn't look like it halted to me
09:57:00 <monochrom> termination is in the eyes of the beholder
09:57:28 <ddarius> Special relativity says so.
10:01:01 <tromp> > fix error
10:01:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:01:41 <aristid> > fix undefined
10:01:42 <lambdabot>   *Exception: Prelude.undefined
10:01:48 <aristid> :t error
10:01:49 <lambdabot> forall a. [Char] -> a
10:02:11 <aristid> > putStr "test"
10:02:12 <lambdabot>   <IO ()>
10:02:43 <xerox> > putStr "<IO ()>"
10:02:44 <lambdabot>   <IO ()>
10:03:31 <aristid> <interactive>:1:0:
10:03:31 <aristid>     No instance for (Show (IO ()))
10:03:48 <aristid> Caleskell seems to have Show (IO ()) :)
10:04:30 <tohava> Another question, is it possible to have two types t1 and t2, with a named field called f in both of them?
10:04:51 <tohava> I can think of a very complicated way to do it with type classes and manually writing the "field getter" function
10:04:55 <tohava> but is there a better way?
10:06:01 <c_wraith> aristid: that's actually smallcheck that has that instance.  \bot just has it imported
10:06:08 <c_wraith> > return 5 :: IO Int
10:06:09 <lambdabot>   <IO Int>
10:06:31 <aristid> c_wraith: ah.
10:07:22 * c_wraith fires up another criterion pass, just to see if the numbers from yesterday are still happening
10:08:09 <xerox> what is criterion?
10:08:17 <c_wraith> bos's benchmarking tool
10:08:22 <c_wraith> it's really nice
10:08:27 <FliPPeh> How hard would it be to write an equation solver in Haskell? Something like "4x -8 = 0" -> "x = 2" ?
10:08:29 <xerox> ah I remember now
10:08:35 <FliPPeh> I've always wanted to do that :)
10:08:50 <ddarius> FliPPeh: It depends on the equations.
10:08:58 <ddarius> A linear equation like that would be easy as pie.
10:09:08 <FliPPeh> Probably square ones
10:09:12 <FliPPeh> Or x^4
10:09:18 <FliPPeh> Could be messy I suppose
10:09:26 <c_wraith> if it's polynomial of degree 2, you can solve it directly.
10:09:47 <c_wraith> If it's arbitrary polynomial, you can use newton-rhapson iteration in a root solver
10:10:11 <uorygl> It does depend on whether you want exact solutions or approximate ones.
10:11:16 <c_wraith> I guess you can solve polynomials up to degree 4 directly.
10:11:32 <c_wraith> But the equations for solving a 4th-degree polynomial directly are HUGE.
10:11:42 <c_wraith> I remember a poster in the math library.... ;))
10:11:42 <koala_man> is FRP still considered interesting? many of the resources seem to have died out
10:12:15 <jmcarthur> still interesting, yes
10:13:40 <koala_man> what's an updated package for that?
10:14:21 <uorygl> Cale: if you're willing, I'm ready at any time.
10:14:54 <jmcarthur> koala_man: reactive is the most interesting semantically and yampa has the best-working implementation, IMO
10:15:21 <jmcarthur> i have issues with all the FRP libraries i know of though
10:19:43 <siracusa> Are there no precompiled binaries for Gtk2Hs and GHC 6.12.1?
10:20:05 <dcoutts_> siracusa: not that I know of
10:21:33 <dcoutts_> siracusa: on the mailing list, some people have been trying out building some
10:22:33 <siracusa> dcoutts_: Ok. Maybe you can help me with another Gtk problem, I tried this http://dpaste.com/191258/ to get tree columns in a treeview. I want the second to get streched, but always the third gets streched.
10:22:40 <jmcarthur> there is for arch linux
10:22:51 <siracusa> * three colums
10:23:03 * twink always uses Ferrari's difference of squares.
10:24:56 <redocdam> dons: you pay that $5
10:26:14 <dcoutts_> siracusa: does the cellRendererSetFixedSize make any difference? are you sure the third is getting more space? is the column itself perhaps not getting more space and there's just blank space after the column?
10:27:06 <dcoutts_> siracusa: is the column itself set to expand to take available space?
10:28:10 <strobedream> :t list?
10:28:11 <lambdabot> parse error (possibly incorrect indentation)
10:28:47 <siracusa> dcoutts_ : The fixed size setting doesn't change anything. The doc says cellLayoutPackStart _ _ True makes the column to get expanded, but it doesn't.
10:29:42 <siracusa> dcoutts_: The third column takes all the space up to the end of the treeview if I resize the window.
10:31:12 <dcoutts_> siracusa: what are you using for treeViewColumnPackStart/End ?
10:31:28 <dcoutts_> how are you adding the columns into the tree view
10:32:10 <siracusa> Im using treeViewAppendColumn
10:33:24 <siracusa> dcoutts_: I also use `treeViewColumnSetMaxWidth col3 30' but no difference
10:33:34 <dcoutts_> siracusa: not sure then, ask on the mailing list
10:33:44 <siracusa> Ok
10:41:10 * hackagebot test-framework 0.3.0 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.3.0 (MaxBolingbroke)
10:41:12 * hackagebot test-framework-hunit 0.2.5 - HUnit support for the test-framework package.  http://hackage.haskell.org/package/test-framework-hunit-0.2.5 (MaxBolingbroke)
10:41:14 * hackagebot test-framework-quickcheck 0.2.5 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.2.5 (MaxBolingbroke)
10:41:16 * hackagebot test-framework-quickcheck2 0.2.6 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.6 (MaxBolingbroke)
10:51:40 <EvanR-work> what is a monomorphic type
10:52:01 <xerox> one without type variables
10:52:45 <EvanR-work> "variables bound by a lambda expression are always monomorphic"
10:53:58 <tohava> Can I pattern match purely against a constructor name, without dependence on the number of parameters?
10:54:11 <tohava> (I.e. something like f (ConstructorName _*) = 8
10:55:07 <dcoutts_> tohava: yes, f (ConstructorName {})
10:55:20 <dcoutts_> by treating the constructor as a record
10:55:32 <dcoutts_> and not matching on any fields
10:57:25 <olsner> oh, that's neat! I thought you could only use record syntax on data types defined as record types
11:03:04 <tohava> I wish to pattern match against the name of a constructor, and only the name, how I do that?
11:03:05 <tohava> i.e.
11:03:17 <tohava> data Bubu = Bubu Int Int Int Int Int
11:03:24 <tohava> f Bubu _* = "bubu"
11:03:35 <tohava> (Such that if Bubu has multiple constructors, I can distinguish between them)
11:03:43 <EvanR-work> dejavu
11:03:52 <EvanR-work> Vuvu
11:03:55 <Phyx-> lol
11:04:36 <tohava> EvanR-work: I had a disconnection
11:04:45 <tohava> EvanR-work, did someone answer it in the previous time I asked?
11:04:54 <EvanR-work> yeah
11:04:57 <Phyx-> 19:54:36 < dcoutts_> tohava: yes, f (ConstructorName {})
11:04:58 <Phyx-> 19:54:49 < dcoutts_> by treating the constructor as a record
11:04:58 <Phyx-> 19:55:01 < dcoutts_> and not matching on any fields
11:05:27 <tohava> Phyx-, thanks, sorry for the disconnection
11:08:03 <aristid> jmcarthur: is your first name jake?
11:10:13 <Phyx-> tohava: it's ok, we all disconnect :)
11:10:59 <Phyx-> 19:52:14 < EvanR-work> "variables bound by a lambda expression are always monomorphic" <- I assume you mean in some kind of typed lambda calculus?
11:12:08 <EvanR-work> Phyx-: i mean lamda in hsakel
11:13:00 <EvanR-work> (k -> f k), k is monomorphic?
11:13:11 <EvanR-work> (\k ->
11:13:27 <jmcarthur> aristid: yeah, why?
11:14:05 <vixey> Which Galois connections come up in functional programming?
11:14:40 <jmcarthur> EvanR-work: looks polymorphic to me
11:15:01 <jmcarthur> EvanR-work: unless f is monomorphic
11:15:02 <aristid> jmcarthur: found you on a blog comment, then
11:15:05 <Phyx-> EvanR-work: I would say that depends on f, if f is polymorphic then k would be aswell. if f monomorphic (+(1::Int)) then k is monomorphic
11:15:08 <jmcarthur> ah where?
11:15:08 <aristid> http://stephenmann.net/2009/07/17/cool-haskell-function/
11:15:11 <EvanR-work> 'things bound by lambdas always have monomorphic types'
11:15:17 <EvanR-work> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Using_the_Cont_monad
11:15:51 <jmcarthur> EvanR-work: err...
11:16:11 <jmcarthur> EvanR-work: i think that means that you won't be able to unify a lambda bound variable to more than one type in that scope
11:16:25 <EvanR-work> hrm
11:16:36 <jmcarthur> i don't think they really mean it's going to be statically known as Int or something
11:16:39 <EvanR-work> but thats always the case
11:17:07 <jmcarthur> EvanR-work: consider this (it won't work):
11:17:32 <jmcarthur> > join (***) id ('foo', 5)
11:17:32 <lambdabot>   <no location info>:
11:17:33 <lambdabot>      lexical error in string/character literal at chara...
11:17:38 <jmcarthur> oops
11:17:42 <jmcarthur> > join (***) id ("foo", 5)
11:17:43 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:17:43 <lambdabot>    arising from the literal ...
11:17:54 <jmcarthur> > join (***) id ("foo", ())
11:17:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:17:55 <lambdabot>         against inferred ty...
11:18:00 <aristid> :t (***)
11:18:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:18:01 <jmcarthur> there, that's the error i meant to get
11:18:28 <jmcarthur> :t join (**)
11:18:28 <lambdabot> forall a. (Floating a) => a -> a
11:18:33 <jmcarthur> :t join (***)
11:18:34 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:19:18 <EvanR-work> ehm
11:19:19 <jmcarthur> basically join (***) is making id unify to the same type on both sides instead of remaining fully polymorphic
11:19:28 <jmcarthur> whereas this works:
11:19:35 <jmcarthur> > (id *** id) ("foo", ())
11:19:35 <lambdabot>   ("foo",())
11:19:56 <aristid> :t join
11:19:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:20:00 <jmcarthur> basically the same principle. once a type has been unified you can't really unify it to some other type
11:20:10 <aristid> @src join
11:20:10 <jmcarthur> aristid: in this case join has this type:
11:20:11 <lambdabot> join x =  x >>= id
11:20:25 <jmcarthur> :t join :: (a -> a -> b) -> a -> b
11:20:26 <lambdabot> forall a b. (a -> a -> b) -> a -> b
11:20:47 <EvanR-work> @src (***)
11:20:48 <lambdabot> f *** g = first f >>> second g
11:20:53 <EvanR-work> @src (>>>)
11:20:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:20:57 <jmcarthur> :t (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)  -- and (***) has this one
11:20:58 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:21:16 <c_wraith> It's fun to think of id as having the type Monad m => m a -> m a, and watching that get unified with >>=
11:21:31 <jmcarthur> with >>= ?
11:21:31 <aristid> > join [1,2,3]
11:21:32 <lambdabot>   No instance for (GHC.Num.Num [a])
11:21:33 <lambdabot>    arising from a use of `e_1123' at <int...
11:21:36 <jmcarthur> :t (>>=)
11:21:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:21:40 <aristid> > join [[1,2],[3]]
11:21:41 <lambdabot>   [1,2,3]
11:22:01 <c_wraith> jmcarthur: well, as the second arg to >>=.  I kinda hit enter early there.
11:22:05 <jmcarthur> ah
11:22:12 <jmcarthur> err
11:22:16 <jmcarthur> still not right though
11:22:19 <aristid> > join (Just Nothing)
11:22:20 <lambdabot>   Nothing
11:22:44 <jmcarthur> c_wraith: do you mean (>>= something)?
11:22:45 <aristid> > join Nothing :: Maybe Maybe Int
11:22:45 <c_wraith> m a -> m a getting unified with b -> m c
11:22:46 <lambdabot>   Kind error: `Data.Maybe.Maybe' is applied to too many type arguments
11:22:52 <aristid> > join Nothing :: Maybe (Maybe Int)
11:22:52 <jmcarthur> oh
11:22:53 <lambdabot>   Nothing
11:22:57 <jmcarthur> more polymorphic
11:23:22 <aristid> what is the idiomatic use for join?
11:23:36 <jthing> Well 'Formal spesification of languages' finally arrived.. (successor to the 'denotational semantics' book.)
11:23:37 <jmcarthur> aristid: many things, really
11:23:59 <aristid> without ghci or lambdabot i'd be so lost.
11:24:05 <vixey> I want that
11:24:33 <aristid> jmcarthur: how can i remember where to use it?
11:25:51 <baguasquirrel> aristid, it's useful whenever you have a nesting of monads
11:25:53 <quicksilver> aristid: you will know.
11:26:03 <quicksilver> aristid: if you have Maybe (Maybe a) and you want Maybe a :)
11:26:10 <quicksilver> there's really only one thing you can do...
11:26:24 <Phyx-> is there a haskell code formatter that preserves comments?
11:26:29 <quicksilver> actually join isn't needed that often in practice - normally you use >>= or do notation. (which effectively have joins inside them)
11:26:29 <baguasquirrel> incidentally, concat == join
11:26:41 <aristid> :t concat
11:26:43 <lambdabot> forall a. [[a]] -> [a]
11:26:43 <quicksilver> Phyx-: haskell-src-exts has one I believe.
11:26:49 <aristid> baguasquirrel: only for lists:)
11:26:58 <aristid> even Caleskell isn't going that far
11:27:03 <baguasquirrel> right
11:27:07 <vixey> concatMap f == join . fmap f
11:27:11 <Phyx-> quicksilver: i'll take a look, thanks
11:27:50 <aristid> vixey: concatMap == (>>=)
11:28:14 <c_wraith> no, concatMap = (=<<)
11:28:27 <aristid> sry
11:28:32 <aristid> :t (>>=)
11:28:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:28:38 <aristid> :t concatMap
11:28:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:28:51 <aristid> :t flip concatMap
11:28:52 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
11:29:05 <aristid> :t join . fmap
11:29:06 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
11:29:06 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
11:29:06 <lambdabot>     In the second argument of `(.)', namely `fmap'
11:29:08 <vixey> ∑:3 = happyCat
11:29:34 <benmachine> :t join . fmap join
11:29:35 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m (m (m a)) -> m a
11:29:54 <aristid> :t join . join
11:29:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
11:30:07 <vixey> :t (=<<) join
11:30:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m (m b)) -> m b
11:30:23 <aristid> i need a break :D
11:33:06 <mathstuf> hmm
11:33:21 <aristid> > join . join $ Nothing
11:33:22 <lambdabot>   Nothing
11:33:23 <mathstuf> shouldnt static linking automatically pick up link directories from ~/.cabal ?
11:33:33 <aristid> > join . join $ Just Just 4
11:33:34 <lambdabot>   Couldn't match expected type `t -> m (m (m a))'
11:33:35 <lambdabot>         against inferred ty...
11:33:40 <aristid> > join . join $ Just Just Just 4
11:33:41 <lambdabot>   Couldn't match expected type `(a1 -> Data.Maybe.Maybe a1)
11:33:42 <lambdabot>                  ...
11:33:49 <aristid> > join . join $ Just Just Nothing
11:33:50 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a1 -> m (m (m a))'
11:33:51 <lambdabot>         a...
11:34:04 <aristid> > join . join $ Just Nothing
11:34:06 <lambdabot>   Nothing
11:34:20 <aristid> lol.
11:34:29 <aristid> > join . join $ Just (Just Nothing)
11:34:30 <lambdabot>   Nothing
11:34:38 <aristid> > join . join $ Just (Just (Just Nothing))
11:34:39 <lambdabot>   Just Nothing
11:34:42 <aristid> > join . join $ Just (Just (Just 4))
11:34:43 <lambdabot>   Just 4
11:34:46 <mauke> > join . join . Just . Just . Just $ 4
11:34:48 <lambdabot>   Just 4
11:35:11 <aristid> hmm sorry for spamming
11:35:24 <aristid> got carried away
11:38:06 <mathstuf> nvm, figured it out
11:38:29 <Mathnerd314> @type Nothing
11:38:30 <lambdabot> forall a. Maybe a
11:38:33 <Mathnerd314> @type undefined
11:38:34 <lambdabot> forall a. a
11:38:41 <Mathnerd314> they're so similar...
11:38:51 <mauke> :t Just undefined
11:38:52 <lambdabot> forall a. Maybe a
11:39:12 <Mathnerd314> > Just undefined == Nothing
11:39:13 <lambdabot>   False
11:40:05 <Mathnerd314> > fail "" == Nothing
11:40:06 <lambdabot>   True
11:40:38 <mauke> :t [Nothing, Just undefined, undefined]
11:40:39 <lambdabot> forall a. [Maybe a]
11:40:47 * hackagebot 4Blocks 0.1 - A tetris-like game (works with GHC 6.8.3 and Gtk2hs 0.9.13)  http://hackage.haskell.org/package/4Blocks-0.1 (AndrewCalleja)
11:40:49 * hackagebot gsasl 0.3.1 - Bindings for GNU SASL  http://hackage.haskell.org/package/gsasl-0.3.1 (JohnMillikin)
11:41:03 <Ke> @type fail
11:41:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:42:45 <Phyx-> @type
11:42:46 <lambdabot> <no location info>: not an expression: `'
11:42:47 <Phyx-> @type fox
11:42:49 <lambdabot> Not in scope: `fox'
11:42:51 <Phyx-> @type fix
11:42:52 <lambdabot> forall a. (a -> a) -> a
11:45:15 <zygoloid> > fix error
11:45:16 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:45:19 <zygoloid> > fix fail
11:45:20 <lambdabot>   ""
11:46:02 <djahandarie> > fix fix
11:46:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:47:14 <aristid> i still like "fix show" most
11:47:18 <aristid> > fix show
11:47:19 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:47:24 <jlouis> Saizan: I am still perplexed that I can't get even close to the CPU usage etorrent has
11:47:37 <aristid> > fix cycle
11:47:40 <lambdabot>   mueval-core: Time limit exceeded
11:47:55 <zygoloid> aristid: but show wasn't broken
11:48:11 <aristid> zygoloid: broken?
11:48:13 <jlouis> Saizan: this commit http://github.com/jlouis/combinatorrent/commit/53f657ed8b798ef39e563da30fabb4b7beb7c20b does not help much either :/
11:48:18 <Phyx-> > fix (read.show)
11:48:22 <lambdabot>   mueval-core: Time limit exceeded
11:48:29 <aristid> :t read.show
11:48:30 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:48:41 <aristid> :t fix (read.show)
11:48:42 <lambdabot> forall a. (Read a, Show a) => a
11:48:44 <benmachine> > fix (fail . show)
11:48:45 <lambdabot>   No instance for (GHC.Show.Show (m a))
11:48:46 <lambdabot>    arising from a use of `e_1' at <in...
11:48:58 <benmachine> > fix (fail . (show :: Maybe () -> String))
11:48:59 <lambdabot>   Nothing
11:49:17 <benmachine> > fix (fail . (show :: Either () () -> String))
11:49:18 <lambdabot>   No instance for (Control.Monad.Error.Class.Error ())
11:49:18 <lambdabot>    arising from a use ...
11:49:24 <benmachine> bzzt
11:49:30 <aristid> > fail Nothing
11:49:31 <lambdabot>   Couldn't match expected type `GHC.Base.String'
11:49:31 <lambdabot>         against inferred typ...
11:49:41 <aristid> > fail :: Maybe Int
11:49:42 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
11:49:43 <lambdabot>         again...
11:49:48 <vixey> epic fail
11:49:51 <benmachine> > fail "Nothing" :: Maybe ()
11:49:51 <aristid> :(
11:49:52 <lambdabot>   Nothing
11:50:34 <mathstuf> does anyone know of any wrappers to make a CGI script into an fcgi script for Haskell?
11:50:34 <aristid> > fail "List" :: [()]
11:50:36 <lambdabot>   []
11:50:41 <mathstuf> i tried using the FastCGI module
11:50:46 <ezyang> mathstuf: IIRC, the CGI and FastCGI modules should be interchangeable
11:50:52 <mathstuf> but HaXR only prints to stdout
11:52:12 <mathstuf> i have a perl fcgi wrapper that i use for gitweb, but it doesnt seem to be all that applicable to any cgi module
11:52:37 <aristid> ezyang: i love the list of operators in your recent blog posting: http://blog.ezyang.com/2010/05/name-conflicts-on-hackage/
11:52:44 <ezyang> aristid: Thanks!
11:53:12 <Phyx-> @type fix (\f -> const (maybe (f ()) f Nothing))
11:53:13 <lambdabot> forall b. () -> b
11:53:48 <Saizan> jlouis: that's trying to adjust to the optimal chunk size?
11:55:02 <Phyx-> hmm that's odd
11:56:56 * hackagebot 4Blocks 0.2 - A tetris-like game (works with GHC 6.8.3 and Gtk2hs 0.9.13)  http://hackage.haskell.org/package/4Blocks-0.2 (AndrewCalleja)
11:57:56 <jlouis> Saizan: yes, but the real problem is that attoparsec concatenates small chunks into 16 kilobyte blocks with concat
11:58:11 <jlouis> for strict bytestrings, that is a bad idea
11:58:25 <jlouis> 46% of all allocation is in the receiver because of that
11:59:11 <jlouis> I don't think i'll let that adjusting code promote from next for a while anyway
12:02:23 <mathstuf> ezyang: im not using either of those
12:02:31 <mathstuf> HaXR does its own cgi server thing
12:04:17 <djahandarie> jlouis, even the reworked version does?
12:05:34 <siracusa> I get the warning `module Prelude deprecated' - does it mean when hiding Prelude imports, I should hide the imports from e.g. Data.Function directly?
12:05:37 <aristid> @pl zipWith ($) (cycle [f,id])
12:05:37 <lambdabot> zipWith id (cycle [f, id])
12:06:02 <dcoutts_> siracusa: read the rest of the message
12:06:21 <vixey> zipWith ($) . cycle . (:[id])
12:06:45 <Saizan> jlouis: oh, that sounds nasty
12:07:07 <aristid> funny how ($) can be replaced with id
12:07:14 <jlouis> djahandarie: attoparsec 0.8.0.2
12:08:05 <vixey> ($) f x = f x
12:08:10 <vixey> <=> ($) f = f
12:08:17 <vixey> <=> ($) = id
12:08:58 <jlouis> Saizan: on the positive side though, the erlang version uses much much more memory
12:09:21 <aristid> vixey: except for the more restrictive type of ($)
12:09:35 <aristid> so i think ($) is useful because it is more restrictive.
12:09:58 <vixey> I don't personally see it as relevant
12:10:08 <dcoutts_> siracusa: make sense now?
12:10:46 <aristid> vixey: so you'd use id?
12:11:03 <Saizan> jlouis: where's this concatenation in attoparsec's code?
12:11:18 <tensorpu`> ($) is a fair amount in real code.
12:12:11 <Saizan> jlouis: ah, so more than the 16mb combinatorrent seems to be fixed at?:)
12:12:27 <jlouis> yes
12:12:34 <jlouis> 30-40 mb
12:12:45 <jlouis> quickly increasing if you add more
12:13:05 <jlouis> its file manager is also dumb like hell so that is the reason
12:13:11 <vixey> The reason $ is useful is because of its precidence
12:13:25 <vixey> precedence*
12:13:29 <jlouis> Saizan: +++ in attoparsec is 35% alone
12:13:53 <siracusa> dcoutts_: Yeah, I just fixed base >= 4.0 but now it complains about base-4.0.0.0 was excluded, it wants base -any :-S
12:14:18 <dcoutts_> siracusa: oh, that's odd. you should have base 4 installed
12:14:59 <dcoutts_> siracusa: in fact that sounds like something is broken
12:15:09 <dcoutts_> as if base-4 was corrupt/missing
12:16:07 <dcoutts_> siracusa: does ghc-pkg check report anything wrong? what exactly was the error message from cabal?
12:16:50 <siracusa> dcoutts_: No, I already found the problem
12:17:13 <dcoutts_> siracusa: what was it?
12:17:45 <siracusa> dcoutts_: The dependency was base < 4.1 but 4.2 is installed
12:18:01 <dcoutts_> siracusa: ah ok
12:18:11 <dcoutts_> the error message could have been better I guess
12:18:22 <dcoutts_> if it'd talked about needing an installed version
12:18:43 <dcoutts_> and the installed versions didn't match the constraint
12:20:10 <siracusa> dcoutts_:  So the Prelude will not be included in future releases of GHC anymore?
12:20:13 <aavogt> dcoutts_: on a related note, the template-haskell version is also fixed for a given ghc
12:20:21 <aavogt> http://hackage.haskell.org/trac/hackage/ticket/675
12:20:33 <dcoutts_> siracusa: base-3 will not, the Prelude is immortal :-)
12:20:45 <aavogt> or at least the major version is
12:20:52 <dcoutts_> aavogt: I'm not sure that's right
12:21:22 <siracusa> dcoutts_: But base 4 will?
12:21:30 <dcoutts_> siracusa: yep
12:21:43 <dcoutts_> aavogt: but I've not looked at the details.
12:22:33 <Saizan> jlouis: mh, i guess the idea is that most of the time the bytestring on the left should be empty
12:22:44 <siracusa> dcoutts_: That's strange, what's the reason for it?
12:23:28 <dcoutts_> siracusa: shipping both base-3 and 4 is a transitional measure, we are encouraging everyone to move to base 4
12:23:51 <dcoutts_> siracusa: that's why we added the deprecation message for all code using base-3
12:24:06 <aavogt> dcoutts_: somebody here got segfaults after trying to install template-haskell-2.4 on ghc-6.10 I believe
12:27:56 <EvanR-work> > let f 1 = 2 in f 1
12:27:57 <lambdabot>   2
12:28:03 <EvanR-work> > let f undefined = 2 in f undefined
12:28:04 <lambdabot>   2
12:28:09 <EvanR-work> :o
12:28:38 <mauke> > let f defined = 2 in f undefined
12:28:39 <lambdabot>   2
12:28:46 <EvanR-work> haha
12:29:59 <aavogt> > let 2 + 2 = 5 in 2 + 2
12:30:00 <lambdabot>   5
12:30:44 <EvanR-work> > let x = x+1 in x
12:30:48 <lambdabot>   mueval-core: Time limit exceeded
12:31:02 <vixey> > let (2+1) + 2 = 5 in 3 + 2
12:31:03 <lambdabot>   <no location info>: Parse error in pattern
12:32:01 <Phyx-> hrm, is there any situation where you'd want to use the fix point function fix over say, a recursive let binding?
12:32:52 <aavogt> > let (n+1) + 2 | 2 <- n = 5 in 3 + 2
12:32:53 <lambdabot>   5
12:33:15 <dcoutts_> aavogt: so I was under the impression that minor upgrades were possible, so perhaps the problem is that the version constraints on that template-haskell package version are just wrong, but maybe you're right that even trivial changes are impossible without rebuilding ghc itself. We should ask the ghc devs.
12:34:11 <djahandarie> > let x = a in x
12:34:12 <lambdabot>   a
12:34:17 <djahandarie> > let x = a+1 in x
12:34:18 <lambdabot>   a + 1
12:34:43 <djahandarie> > let x = a+1 in x + 1
12:34:45 <lambdabot>   a + 1 + 1
12:34:47 <djahandarie> lol
12:35:31 <benmachine> Phyx-: fix doesn't do anything that recursive let can't, but could sometimes be less verbose I suppose
12:35:41 <djahandarie> Cale, where did you get that Expr stuff from anyways?
12:35:42 <aristid> > a
12:35:43 <lambdabot>   a
12:35:47 <aristid> :t a
12:35:48 <lambdabot> Expr
12:35:51 <benmachine> Phyx-: it's like, why would you ever use lambda instead of defining a local function?
12:36:01 <benmachine> djahandarie: see the show package on hackage
12:36:24 <aristid> benmachine: if it improves the reading flow, why not?
12:36:42 <djahandarie> Ah, I see.
12:37:01 <djahandarie> > reduce $ a + 1 + 1
12:37:02 <lambdabot>   a + 1 + 1
12:37:12 <Saizan> the Expr stuff is from the SimpleReflect package
12:37:22 <djahandarie> > reduce $ 1 + 1
12:37:23 <lambdabot>   2
12:37:24 <tensorpudding> There are plenty of good reasons for defining lambdas, but fewer in languages that have partial application.
12:37:26 <djahandarie> Odd
12:37:41 <Phyx-> benmachine: yeah, I was just wondering what's the point of it. guess some just prefer it
12:37:42 <aavogt> dcoutts_: minor changes to template-haskell seem to be possible
12:38:03 <benmachine> aristid: exactly :P
12:38:13 <djahandarie> Oh its a foldr
12:38:17 <tensorpudding> Lambdas are preferrable when a pointfree form is too unreadable
12:38:20 <djahandarie> > reduce $ 1 + 1 + a
12:38:21 <lambdabot>   2 + a
12:38:44 <aristid> :t 1 + 1
12:38:45 <lambdabot> forall t. (Num t) => t
12:38:50 <benmachine> Phyx-: basically fix allows you to make a recursive anonymous function
12:38:59 <siracusa> > reduce $ 1 + a + 1
12:39:00 <lambdabot>   1 + a + 1
12:39:56 <jlouis> Saizan: currently, I think a handrolled parser is the fastest. You know exactly how large the ByteString should be so you just fill it up by moving a Ptr over it
12:40:16 <jlouis> Saizan: it is what Conjure does aas well
12:41:29 <Phyx-> benmachine: right, forgot about that case, thanks
12:44:23 <Saizan> jlouis: ah, makes sense, i wonder if one could abstract that into a library
12:45:34 <ezyang> Watching the talk SPJ gave in Northeastern earlier this week. Really sad I couldn't have been there in person :-/
12:45:36 <jlouis> Saizan: I am quite sure you can.
12:45:47 <jlouis> ezyang: url?
12:46:07 <jlouis> ezyang: ah, youtube
12:46:13 <ezyang> ya
12:46:20 <ezyang> http://pls.posterous.com/simon-peyton-jones-on-data-parallel-haskell
12:46:30 <jmcarthur> youtube is sucking
12:48:51 <EvanR-work> is it not possible to defined fix without recursion
12:49:14 <Saizan> a ByteString implemented with ByteArray# instead of ForeignPointer Word8 would make allocation less expensive?
12:50:09 <EvanR-work> let fix = (\f -> (\x -> f (x x)) (\x -> f (x x)))
12:50:20 * hackagebot network-protocol-xmpp 0.3.1 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.1 (JohnMillikin)
12:50:20 <Saizan> that doesn't typecheck in haskell
12:50:25 <vixey> EvanR-work: you can use a data type
12:50:27 <Saizan> but you can use a newtype to do so
12:50:58 <jmcarthur> yeah but the type is recursive
12:51:31 <EvanR-work> why doesnt it type check
12:52:07 <EvanR-work> fix :: a -> (a -> (a -> ...
12:52:35 <EvanR-work> :t fix
12:52:36 <lambdabot> forall a. (a -> a) -> a
12:54:07 <EvanR-work> :t const 0
12:54:08 <lambdabot> forall t b. (Num t) => b -> t
12:59:09 <jlouis> Saizan: anyway, I got some other important things done today, like the snubber. It should improve speeds considerably for torrents
12:59:15 <ezyang> SPJ's a really excellent talk giver
12:59:29 <jlouis> ezyang: oh yes, he is extremely good at it
13:00:48 <edwardk> Saizan: didn't it used to be implemented that way?
13:02:51 <Saizan> edwardk: no idea, but from what i've read the current implementation uses ForeignPointer mostly to be portable
13:03:02 <edwardk> ah
13:13:49 <shapr> I wish cabal install would tell me ALL the pkg-configs that are missing when a package fails to install.
13:16:03 <shapr> Heck, I wish it would tell me which debs to install as well.
13:18:05 <shapr> What hackages would I use to solve a dependcy chain for my college courses?
13:18:55 <shapr> Anybody awake?
13:19:05 <shapr> GOOD MORNING #HASKELL!
13:19:10 <nus> ACK
13:19:14 <EvanR-work> screw the deps
13:19:14 <shapr> RST
13:19:17 <c_wraith>  channel owne spam!
13:19:18 <EvanR-work> take whatever whenever
13:19:24 <c_wraith> *owner
13:19:31 <shapr> nus: Just teasing :-)
13:19:48 <nus> shapr, right, no ACK w/o SYNs (-:
13:19:55 <fryguybob> @quote cabal
13:19:55 <shapr> c_wraith: Wah, I'm not owner anymore. Last I checked it was dons.
13:19:55 <lambdabot> mmorrow says: i tried to cabalify cayenne, but cabal bested me.
13:20:03 <c_wraith> I imagined that being in a very john cleese voice.
13:20:04 <shapr> hiya fryguybob!
13:20:08 <JuanDaugherty> anybody have a link to the current status of FFI?
13:20:32 <c_wraith> Has the FFI changed at any time recently?
13:20:34 <jlouis> shapr: !
13:20:46 <jlouis> @boing shapr
13:20:46 <lambdabot> Maybe you meant: join ping
13:21:02 <nus> @join shapr
13:21:02 <lambdabot> Not enough privileges
13:21:13 <nus> heh
13:21:27 <EvanR-work> @return shapr
13:21:28 <lambdabot> Unknown command, try @list
13:21:40 <nus> > return shapr
13:21:41 <lambdabot>   Not in scope: `shapr'
13:21:50 <seeg> how to make a list of unique factors of a number in haskell?
13:21:57 <JuanDaugherty> (assume something different about the 2010 one)
13:22:07 <seeg> i mean, for 8 it should be something like [1, 2, 4, 8] and not [1, 2, 2, 2]
13:22:24 <tromp> that's divisors, not factors
13:22:25 <seeg> ah, ok, never mind :)
13:22:28 <c_wraith> seeg: how efficient do you want to be?
13:22:42 <seeg> c_wraith, well, pretty efficient
13:22:53 <c_wraith> And do you want divisors or factors?
13:22:58 <seeg> divisors
13:22:59 <c_wraith> divisors is a one-liner
13:23:01 <JuanDaugherty> (like using c-- or something)
13:23:08 <EvanR-work> > (\x -> nub . filter (\a b -> mod a b == 0) [1..x]) 18
13:23:08 <lambdabot>   The lambda expression `\ a b -> GHC.Real.mod a b GHC.Classes.== 0'
13:23:09 <lambdabot>  has two...
13:23:11 <c_wraith> It's a simple list comprehension
13:23:35 <ezyang> Oh man, data families!
13:23:38 <tromp> that's not very efficient for divisors (2^42)
13:23:46 <ezyang> Amazing!
13:23:49 <jmcarthur> ezyang: what about them?
13:23:50 <jmcarthur> ah
13:23:54 <jmcarthur> yes data families rock
13:23:54 <EvanR-work> > (\x -> nub . filter (\d -> mod 18 d == 0) [1..x]) 18
13:23:55 <lambdabot>   No instance for (GHC.Real.Integral [a])
13:23:55 <lambdabot>    arising from a use of `e_1180118...
13:24:12 <EvanR-work> :(
13:24:13 <ezyang> jmcarthur: I got to that point of SPJ's talk
13:24:18 <jmcarthur> ah
13:24:19 <ezyang> Oh wow. Just wow. :^)
13:24:21 <jmcarthur> i haven't yet
13:24:27 <c_wraith> EvanR-work: you can do this with one comprehension. :)
13:24:33 <jmcarthur> but i imagine i probably know about most of the things he will say in the talk
13:24:35 <EvanR-work> i never remember that those exist
13:24:36 <c_wraith> EvanR-work: and without needing nub
13:24:50 <seeg> how about unique_factors n = [p | p <- [1..n], n `mod` p == 0]
13:24:54 <fryguybob> ezyang: I'm not there yet don't spoil it.
13:25:01 <fryguybob> :D
13:25:05 <kmc> which SPJ talk?
13:25:15 <jlouis> kmc: http://www.youtube.com/watch?v=NWSZ4c9yqW8
13:25:33 <EvanR-work> > [p | p <- [1..18], 18 `mod` p == 0]
13:25:34 <lambdabot>   [1,2,3,6,9,18]
13:25:36 <c_wraith> seeg: that's divisors, but yes
13:25:55 <c_wraith> seeg: that's not especially efficient, but it's simple, and good enough for homework. :)
13:26:10 <seeg> yeah, but i need efficient
13:26:22 <c_wraith> how efficient?
13:26:28 <EvanR-work> i know prime factors is different from divisors, but are 'just factors' different from divisors
13:26:28 <seeg> this would be for numbers of order of 10^7
13:26:40 <c_wraith> that algorithm is fine for numbers that size
13:27:09 <c_wraith> I was thinking more like the 2^42 example :)
13:27:29 <seeg> c_wraith, ah, ok
13:27:32 <EvanR-work> isnt computing factors for large numbers impossible
13:27:50 <ezyang> An efficient algorithm for doing so is not known.
13:27:52 <p_l> EvanR-work: not impossible, just requires time?
13:27:54 <jmcarthur> > [p | p <- [1..10^7], 10^7 `mod` p == 0]
13:27:55 <c_wraith> EvanR-work: it's slow, but the simplest algorithms are trivial
13:27:58 <ezyang> But that's different from impossible.
13:27:58 <jmcarthur> oops
13:27:58 <lambdabot>   mueval-core: Time limit exceeded
13:28:04 <jmcarthur> > last [p | p <- [1..10^7], 10^7 `mod` p == 0]
13:28:05 <EvanR-work> effectively impossible ;)
13:28:07 <lambdabot>   mueval-core: Time limit exceeded
13:28:12 <seeg> what about argaval kayal-saxena algorithm?
13:28:15 <jmcarthur> i guess even that doesn't prove anything
13:28:23 <seeg> i've read something about it some time ago
13:28:24 <jmcarthur> just shows that you can go to the end of the list
13:28:31 <c_wraith> > last [p | p <- [1..10^7], 10^7 `mod` p == (0 :: Int)]
13:28:35 <lambdabot>   mueval-core: Time limit exceeded
13:28:40 <ezyang> I forget if there is a probabalistic polynomial quantum algorithm for factoring numbers
13:28:49 <c_wraith> Aw, Int is several times faster, and still not fast enough...  for lambdabot
13:28:54 <jmcarthur> > last [1..10^7]
13:28:55 <lambdabot>   10000000
13:29:19 <c_wraith> > last [p | p <- [1..10^7], 10^7 `rem` p == (0 :: Int)]
13:29:22 <lambdabot>   mueval-core: Time limit exceeded
13:29:30 <Mathnerd314> wouldn't it be 5?
13:29:32 <c_wraith> Hmm.  I thought rem was faster for Int
13:29:43 <c_wraith> No, it'd be 10000000
13:29:56 <Mathnerd314> oh, p is not prime :p
13:30:03 <c_wraith> I'd use k, yes. :)
13:30:09 <jmcarthur> > first [p | p <- [10^7,10^7-1..1], 10^7 `mod` p == (0 :: Int)]
13:30:09 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
13:30:25 <kmc> ezyang, Shor's algorithm, right?
13:30:30 <jmcarthur> i suck at something
13:30:50 <jmcarthur> > head [p | p <- [10^7,10^7-1..1], 10^7 `mod` p == (0 :: Int)]
13:30:51 <lambdabot>   10000000
13:30:53 <jmcarthur> that's what
13:31:16 <Mathnerd314> @type first
13:31:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:31:17 <ezyang> kmc: I think that's it.
13:31:19 <c_wraith> I think mueval's just slow.  That loop should be plenty fast
13:31:35 <c_wraith> ..  Once it deforests the intermediate list
13:31:53 <c_wraith> I guess you need -O2 for that optimization, though?
13:31:54 <ezyang> Our last week of lectures in my computation/complexity class is on quantum computers, and they're pretty exciting.
13:31:57 <Mathnerd314> > head [p | p <- reverse [1..10^7], 10^7 `mod` p == (0 :: Int)]
13:32:04 <lambdabot>   mueval: ExitFailure 1
13:39:31 <ezyang> oh hai edwardk
13:39:38 <edwardk> heya
13:39:59 <ezyang> (I think you're in the talk video)
13:40:11 <edwardk> talk video?
13:40:19 <edwardk> which one?
13:40:36 <c_wraith> spj's
13:40:47 <ezyang> The one at Northeastern
13:40:56 <edwardk> ezyang: your earlier question: Shor's algorithm
13:40:57 <c_wraith> I'm listening to it now
13:41:00 <edwardk> oh neat there was video ;)
13:41:03 <c_wraith> While programming in haskell!
13:41:08 <seeg> nah, this algorithm for divisors is too slow
13:41:08 <edwardk> yeah, i spoke up a few times
13:41:35 <edwardk> i also came up to him afterwards and explained that i thought the algorithm used to generalize map should work for the pointer comonad. ;)
13:41:42 <edwardk> er to parallelize
13:42:10 <edwardk> he very diplomatically invited me to hack up the translation ;)
13:42:23 <ezyang> :^)
13:42:31 <kmc> seeg, are you running it in compiled code with ghc -O2?
13:42:33 <edwardk> its not hard, but not very general
13:43:48 <ezyang> when you say generalize map, do you mean the algorithm to use g and g^ to form g^^?
13:43:49 <edwardk> the other thing that came up after the talk was a decent motivation for why workstealing isn't in competition with the ideas from dph but is something that can work in concert
13:43:56 <edwardk> yeah
13:44:01 <seeg> kmc, yes
13:44:02 <edwardk> rather
13:44:07 <edwardk> the algorithm to generate g^ from g
13:44:11 <edwardk> since g^^ is never needed
13:44:21 <ezyang> right-o
13:45:12 <edwardk> you should be able to generate a similar fragment g', such that g' = extend g for the pointer comonad
13:45:13 <ezyang> Also on a speculative note, I wonder if there's an underying theory to fusion that can be used to make it robust, or if it's just going to rely on the accretion of tricks of many years
13:45:25 <seeg> > [p | p <- [1..76514635], mod 76514635 p == 0]
13:45:29 <lambdabot>   mueval-core: Time limit exceeded
13:45:34 <seeg> yeah, too slow
13:45:36 <edwardk> well, its using stream fusion these days
13:46:03 <kmc> seeg, running it here doesn't show it's too slow
13:46:26 <edwardk> which is just unfoldr/destroy fusion with some tricks to expose more opportunities and eliminate nested recursion
13:47:09 <seeg> i've seen some guy do a mathematica code and he uses Divisors function, and he wrote that it takes him about 1 second to compute number of divisors of triangle numbers from 1 to about 12500
13:47:15 <seeg> triangle number of n is just sum[1..n]
13:47:38 <seeg> while with this code this one number only takes about 5 secs
13:47:50 <EvanR-work> division is slower than addition
13:48:19 <aristid> EvanR-work: under which circumstances?
13:48:40 <EvanR-work> mathematica, im sure
13:48:48 <seeg> the task is to find the smallest triangle number with at least 500 divisors
13:48:57 <seeg> i've computed it in python but it took me couple of hours
13:49:11 <seeg> so i'm wondering how to do it fast
13:49:22 <EvanR-work> just use the mathematica algorithm for finding divisors
13:49:29 <EvanR-work> im sure its not a secret code
13:49:42 <edwardk> yeah but mathematica is tricky because it has access to the symbols, and likes to drop in tons of special cases in their reasoning. so i wouldn't be surprised if wolfram needed divisors of a triangle number one day, and so he set a guy in to add a special case for it ;)
13:50:22 <edwardk> probably has the first million of them or so lying around precomputed somewhere ;)
13:50:23 <c_wraith> seeg: you might do better by building numbers with 500 divisors and working from there :)
13:51:50 <seeg> yeah, but some guy wrote a 2-liner in j and it takes 0.14 secs...
13:51:57 <seeg> foo=:[: */ 1: + [: +/"1 =@q:
13:52:01 <seeg> {.(500 < foo"0 t)#t=:+/\>: i.13000
13:52:06 <seeg> just to understand this gibberish :D
13:52:26 <seeg> the fist line is supposed to give the number of divisors
13:52:54 <nus> hmm, what's 13000
13:53:42 <winxordie> about 10000 + 3000?
13:53:49 <seeg> 13000 is the upper limit
13:53:56 <seeg> because the answer is about 12000
13:55:59 <uorygl> Hmm, it can't take long to find the number of divisors of a number.
13:56:52 <uorygl> Factor it, then use the factorization to calculate the number.
13:57:04 <benmachine> once you have a list of primes you can find factors very very quickly
13:58:49 <seeg> nah, ok, i'll think about it
13:59:14 <c_wraith> there's a complete list of primes on hackage :)
13:59:22 <uorygl> I hope you're not generating a number, calculating the number of divisors, and then checking whether it's triangular.  :)
13:59:44 <uorygl> A complete list of primes?  Gee, there must be dozens.
13:59:50 <Mathnerd314> c_wraith: which one?
13:59:55 <ezyang> What's the oeis function...
13:59:58 <Mathnerd314> *which package
14:00:06 <BMeph> @oeis 2 3 5 7
14:00:07 <lambdabot>  The prime numbers.
14:00:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:00:08 <benmachine> uorygl: I didn't say complete :P just up to the square root of whatever you want to factorise
14:00:12 <ezyang> :-)
14:00:26 <uorygl> I think I saw a theorem once proving there are at least 11 prime numbers...
14:00:31 <c_wraith> @hackage primes
14:00:31 <lambdabot> http://hackage.haskell.org/package/primes
14:00:38 <uorygl> This would be an awesome function: oeis :: Int -> [Integer]
14:01:00 <c_wraith> sadly, it must be Int -> IO [Integer]
14:01:04 <kmc> not if you cheat
14:01:07 <kmc> http://hackage.haskell.org/packages/archive/oeis/0.2.2/doc/html/Math-OEIS.html
14:01:13 <benmachine> gianthuge lookup table?
14:01:21 <uorygl> Not if you use a gianthuge lookup table.
14:01:21 <lispy> unsafePerformOEIS
14:01:21 <ezyang> unsafePerformIO I bet
14:01:23 <c_wraith> unsafePerformLookup
14:01:28 <benmachine> or just safelyUnsafePerformIO
14:01:30 <ezyang> jinx
14:02:50 <Mathnerd314> @type unsafePerformIO
14:02:53 <lambdabot> Not in scope: `unsafePerformIO'
14:03:26 <Mathnerd314> @type System.IO.Unsafe.unsafePerformIO
14:03:27 <lambdabot> forall a. IO a -> a
14:04:15 <Mathnerd314> how "unsafe" is unsafePerformIO? can you crash your program with it or something?
14:04:23 <tensorpudding> Yes.
14:04:43 <c_wraith> You can also write programs that lie
14:05:18 <kmc> Mathnerd314, you can use it to write unsafeCoerce :: a -> b
14:05:30 <kmc> by using a polymorphic IORef
14:05:44 <kmc> though i'm not convinced this is a "fundamental" problem with allowing side-effecting evaluation
14:05:52 <kmc> it's a problem as things currently stand
14:05:55 <tensorpudding> You can make programs that abort with errors without using unsafeFoo directly
14:06:29 <tensorpudding> Though I imagine that you can't create a function like error without using some unsafe-fu
14:06:30 <c_wraith> I'm mostly concerned with programs that fail because the optimizer believes your tye signature
14:06:32 <uorygl> Polymorphic IORef.  That's sort of a cruel idea.
14:06:50 <c_wraith> hmm.  type signature
14:06:50 <kmc> but with unsafeCoerce you can make a crash much worse than error
14:07:10 <kmc> you make the language memory-unsafe, and you can introduce silent corruption leading to silently wrong behavior
14:07:13 <kmc> and maybe a crash down the line
14:07:14 <c_wraith> yeah, unsafeCoerce () () results in a segfault
14:07:56 <tensorpudding> Well yeah, Haskell makes it pretty impossible to segfault without using unsafe-fu
14:07:56 <kmc> mostly, unsafePerformIO allows you to write programs where the order and indeed existence of effects depends on the whims of compiler optimization
14:08:06 <uorygl> Is it like this? {do (x :: forall a. IORef a) <- newIORef undefined; writeIORef x (); (str :: String) <- readIORef x; putStrLn str}
14:11:12 <kmc> uorygl, yes but that doesn't type check
14:11:30 <uorygl> Why not?
14:12:51 <kmc> because forall a. IO (IORef a) and IO (forall a. IORef a) are different types
14:12:53 <kmc> i think that's why
14:13:28 <uorygl> Mm.  If I put the latter type signature on x instead, would it work?
14:13:34 <kmc> try it
14:13:38 <kmc> but it's really not supposed to be possible
14:13:45 <kmc> because it would be memory-unsafe, as noted
14:13:58 <uorygl> Wait, I did put that type signature on x.
14:14:12 <uorygl> @type do {(x :: forall a. IORef a) <- newIORef undefined; writeIORef x (); (str :: String) <- readIORef x; putStrLn str}
14:14:13 <lambdabot> Not in scope: type constructor or class `IORef'
14:14:13 <lambdabot> Not in scope: `newIORef'
14:14:13 <lambdabot> Not in scope: `writeIORef'
14:14:17 <uorygl> Bah.
14:14:36 <kmc> let r = unsafePerformIO $ newIORef undefined in writeIORef r () >> readIORef r >>= putStrLn
14:15:19 <kmc> uorygl, right.  there's a mismatch because newIORef undefined :: forall a. IO (IORef a)
14:15:48 <kmc> but you're using it as if newIORef undefined :: IO (forall a. IORef a)
14:19:43 <Mathnerd314> > unsafePerformIO "print x"
14:19:44 <lambdabot>   Not in scope: `unsafePerformIO'
14:20:10 <Mathnerd314> > System.IO.Unsafe.unsafePerformIO (print "x")
14:20:11 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
14:20:22 <jmelesky> is it possible to define circumfix operators in Haskell?
14:20:39 <pkrumins> what's a circumfix operator?
14:21:07 <Cale> jmelesky: Not really
14:21:14 <jmelesky> pkrumins: an operator that surrounds a value
14:21:29 <c_wraith> It's been faked before
14:21:41 <c_wraith> But it's really just defining two infix operators that are designed to work together
14:22:02 <Mathnerd314> one could define a prefix operator that did stuff and a postfix operator that translated to a no-op
14:22:03 <jmelesky> e.g. in <<< "an argument" >>>, the angle brackets are probably a circumfix operator
14:22:10 <Cale> Or something like a rather polymorphic function and a data constructor which occurs as a parameter to it
14:22:23 <Mathnerd314> @type (>>>)
14:22:24 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:22:31 <jmelesky> bah. bad example
14:22:47 <jmelesky> <thestart< "an argument" >theend>
14:23:00 <jmelesky> @type (<thestart<)
14:23:01 <lambdabot> parse error on input `)'
14:23:22 <Cale> How about something traditional, like |x-y| for the absolute value of the difference between x and y
14:24:50 <Mathnerd314> @let (|)=id in |x-y|
14:24:50 <lambdabot>   Parse error: Bar
14:24:50 <jmelesky> Cale: or just |x| for the absolute value of x. yeah, that's the sort of thing i'm talking about.
14:24:56 <Mathnerd314> > let (|)=id in |x-y|
14:24:57 <lambdabot>   <no location info>: parse error on input `|'
14:25:06 <tensorpudding> | is not valid syntax
14:25:21 <c_wraith> use || instead.  no one needs it. :)
14:25:37 <Mathnerd314> > let (||)=id in ||x-y||
14:25:38 <lambdabot>   <no location info>: parse error on input `||'
14:25:38 <jmelesky> i don't know there's much need for it, but i can see it being useful for EDSLs
14:25:40 <Cale> Even so, you won't be able to get that to parse
14:25:45 <Mathnerd314> > let (||)=id in || x - y ||
14:25:46 <lambdabot>   <no location info>: parse error on input `||'
14:26:05 <dmwit> Well, there's Agda...
14:26:09 <Cale> Infix operators have to go between things (or else be operator sections)
14:26:10 <benmachine> you could abuse quasiquotes but that wouldn't be pretty
14:26:35 <Mathnerd314> dmwit: yeah, Agda has "mixfix" :-)
14:26:56 <jmelesky> benmachine: quasiquotes are really a special case of circumfix operators, right?
14:27:08 <benmachine> jmelesky: I guess so
14:27:16 <benmachine> the syntactic overhead is pretty heavy though
14:27:21 <Cale> To the extent that they're operators at all
14:27:36 <benmachine> well, they could compile into application of an operator?
14:27:42 <Cale> yeah
14:27:42 <benmachine> maaaybe ish
14:27:59 <Cale> In particular spaces and not in geneal
14:28:02 <Cale> general*
14:28:37 <jmelesky> dmwit, Mathnerd314 : hadn't seen mixfix before. that's pleasantly flexible
14:32:47 <jmelesky> huh. looks like perl 6 has circumfix operators. i suppose that figures
14:33:01 <benmachine> hah
14:33:15 * hackagebot Bitly 0.0.5 - A library and a command line tool to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.0.5 (SergeyAstanin)
14:33:15 <mauke> perl 5 has circumfix operators
14:33:35 <jmelesky> mauke: oh?
14:33:43 <jmelesky> user-defined ones?
14:33:45 <mauke> no
14:40:21 <hpc> circumfix?
14:41:10 <guerrilla> how would i get Happy to give me more useful parse error message than just the offending token and its position?
14:41:19 <sm> wow, http://stackoverflow.com/questions/tagged/haskell traffic eems to have picked up
14:41:25 <sm> seems
14:41:30 <guerrilla> something more like "expected someSymbol"
14:42:08 <fryguybob> sm: End of semester homework due?
14:43:09 <sm> fryguybob: mind-numbing client project due..
14:43:44 <lispy> Has anyone here encountered the macports vs. oxs iconv linker issues on osx?
14:43:52 <lispy> I'm looking for someone who knows how to work around it
14:43:52 <sm> oh I see, that's a reason
14:47:03 <gwern> most of those stackoverflow questions seem like things that would've been trivially answered here
14:48:17 <ivanm> gwern: well, someone asked $ vs $! here; took us a while for them to even get the point of $ let alone the differences
14:48:29 <ivanm> (they were trying to have . act as $ as well :s )
14:50:27 <Axman6> lispy: try asking in #macports, they're fairly familliar with most of the common issues
14:51:08 <gwern> ivanm: that's not too unreasonable
14:51:28 <ivanm> well, my point is that it wasn't answered trivially here ;-)
14:51:29 <gwern> ivanm: $ and . long trouble me. if I were simplifying haskell synax, that'd be one of the first things to go
14:51:39 <ivanm> .... except you can't ...
14:51:48 <kmc> they're not syntax
14:52:02 <ivanm> hint: the types are wrong!
14:52:03 <jmcarthur> why would you get rid of . and $ ?!
14:52:04 <gwern> spare me your captious faultfinding!
14:52:12 <gwern> jmcarthur: one or the other, choose
14:52:20 <jmcarthur> but they are different things!
14:52:23 <ivanm> gwern: I choose both (which the definition of or allows)!
14:52:31 <nus> heh
14:52:34 <ezyang> I would be very sad if . went away
14:52:37 <thevoid> @type map
14:52:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:52:42 <Cale> ezyang: me too
14:52:43 <gwern> ivanm: natural language requires inclusive or to be explicit
14:52:47 <gwern> usually
14:52:48 <jmcarthur> i would change the associativity of ($) though
14:52:55 <Cale> (.) is by far the infix operator that I use more than any other
14:52:59 <ivanm> gwern: I beg to differ
14:53:10 <gwern> ivanm: 'you can have ice cream or cake'
14:53:11 <ivanm> Cale: yes, but we're talking about Haskell, not Caleskell :p
14:53:21 <ivanm> gwern: I have ice cream _with_ cake
14:53:22 <benmachine> even then
14:53:23 <Cale> ivanm: Even in Haskell
14:53:36 <ivanm> Cale: yeah, I know; you just use it even more in Caleskell
14:53:50 <fax> hi haskell
14:53:53 <tensorpudding> I use (.) a good bit, but I doubt it's the single largest.
14:53:54 <nus> $(.).(.)$
14:53:55 <ivanm> point-free ftw!
14:54:06 <gwern> :t $(.).(.)$
14:54:07 <lambdabot> parse error on input `$'
14:54:12 * gwern didn't think so
14:54:14 <jmcarthur> this is why we have either/or and neither/nor to use instead of just or and nor
14:54:16 <ivanm> @type ($(.).(.)$)
14:54:17 <lambdabot> parse error on input `)'
14:54:21 <ivanm> yeah
14:54:42 <ezyang> I don't think double-ended infix partial applications are allowed...
14:54:52 <ezyang> > (+2+) 3 4
14:54:52 <gwern> we should just drop all that english and use nand
14:54:53 <lambdabot>   <no location info>: parse error on input `)'
14:54:53 <ivanm> jmcarthur: exactly! with either/or being xor!
14:55:21 <gwern> 'you can have cake nand ice cream'
14:55:29 <ivanm> ezyang: do you have nothing better to do than churn out blog posts or something? :p
14:55:47 <ezyang> ivanm: It was my new years resolution. 3 blog posts a week.
14:56:01 <ezyang> I've failed to manage this once, and I should write a bonus post some time to make up for it
14:56:05 <ezyang> IT's... hard.
14:56:15 <gwern> 3? that's silly
14:56:30 <gwern> if I have 1 new essay or article for my personal wiki, I feel I'm doing awright
14:56:55 <ezyang> Yeah. There's definitely a tension between quantity and quality
14:57:27 * gwern turns. looks like the spirit was willing - cocks sunglasses - but the mind was weak
14:58:47 <ezyang> But sometimes I manage to write good stuff in bounded time, so I'll happily churn out trash :o)
14:59:07 <ezyang> Sturgeon's law or something
14:59:20 <gwern> sturgeon's law only applies to many independent producers
14:59:36 <benmachine> I can't write except under pressure >_>
14:59:53 <gwern> benmachine: I hear you can hire people to yell at you a la Rocky
14:59:54 <benmachine> so the tension works semi-backwards for me
14:59:57 <benmachine> haha
14:59:59 <benmachine> awesome.
15:00:02 <ezyang> gwern: Perhaps.
15:01:19 <gwern> ezyang: I think the onus is on you to show that writing quality by a single author is more akin to pulling balls from an urn with replacement, rather than pulling from an urn without replacement :)
15:02:37 <ezyang> gwern: :^)
15:03:02 <gwern> or... like flipping a coin, rather than exercising a muscle or mining ore
15:03:07 <gwern> if those analogies work better for you
15:03:26 <fax> what's a fun thing I could spend some time doing in haskell
15:03:26 <ezyang> They're two analogies with different conclusions
15:04:09 <gwern> fax: I keep a TODO list :) http://community.haskell.org/~gwern/wiki/TODO.page
15:04:22 <gwern> (some of it may be applicable to you)
15:05:04 <gwern> fax: oh, and there's the haskell proposals subreddit
15:06:44 <applicative> fax, what sort of thing do you like?  text, images, crazy data structures....
15:06:51 <ezyang> It's also a lot harder to do long, continuous projects as an MIT student, while blogging is more of a low committment, try lots of things endeavor
15:07:48 <gwern> ezyang: if I were an MIT student, I think I'd be suffernig a constant inferiority complex
15:08:16 <gwern> 'yes, I passed that test, but did I put a car on a roof or blow an industry up lately? I don't *think* so'
15:09:27 <fax> I don't know
15:09:27 <gwern> I sometimes wonder how many students get accepted to MIT but decide to be a big fish in a small pond instead
15:09:44 <Amagineer> Is there some way to grab the current CPU usage information, and if so what is said method?
15:10:33 <ezyang> gwern: Yes, but being around all those smart people rubs off a little, which is nice :-)
15:10:37 <gwern> Amagineer: "/bin/sh -c uptime" :)
15:11:06 <Amagineer> Er, I meant some function/monad/doodad that I can use inside of some haskell code.
15:11:19 <Amagineer> I figure that was implied seeing as this is #haskell
15:11:35 <benmachine> "- A personal death clock" -- gwern you are all kinds of evil
15:11:41 <gwern> the distinction between haskell and non-haskell code is overrated
15:11:53 <gwern> benmachine: dude there is nothign evil about _memento mori_
15:12:01 <benmachine> I do want your direction sensor belt though
15:12:10 <gwern> benmachine: imagine how much less time I would waste on IRC if I had a huge honking clock TICKING DOWN MY LIFE
15:12:14 <benmachine> please go commercial with that I will buy seven
15:12:21 <benmachine> hmm
15:12:29 <gwern> benmachine: oh, it's already commercial, I just don't like the current provider
15:12:30 <benmachine> hourglasses are more traditional I think
15:12:34 <benmachine> oh
15:12:37 <benmachine> compete!
15:12:39 <benmachine> I will buy eight
15:12:45 <gwern> they charge like 100$
15:12:50 <gwern> and who knows how long it will last
15:12:52 <benmachine> daaang
15:13:13 <gwern> @wn memento mori
15:13:16 <lambdabot> *** "memento" wn "WordNet (r) 2.0"
15:13:16 <lambdabot> memento
15:13:16 <lambdabot>      n : a reminder of past events [syn: {souvenir}]
15:13:16 <lambdabot>      [also: {mementoes} (pl)]
15:13:16 <lambdabot> No match for "mori".
15:13:20 <gwern> stupid wordnet
15:13:22 <applicative> Amagineer, here's a start maybe from base?  http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/System-CPUTime.html
15:13:27 <ezyang> Oh, Lifetimer
15:14:33 <c_wraith> well.  everything about the code I just wrote strikes me as wrong.
15:14:37 <gwern> applicative: cputime doesn't help you
15:14:47 <gwern> applicative: they want system load; intrinsically unportable
15:14:54 <applicative> i see
15:15:23 <siracusa> @wn "memento mori"
15:15:23 <lambdabot> *** "memento mori" wn "WordNet (r) 2.0"
15:15:23 <lambdabot> memento mori
15:15:23 <lambdabot>      n : a reminder (as a death's head) of your mortality
15:15:31 <applicative> don't people need to judge it sometimes?
15:15:53 <gwern> c_wraith: 'when two programmers meet to criticize their programs, both are silent.' --alan perlis
15:16:41 <benmachine> I have been writing some particularly evil code recently
15:16:58 <c_wraith> I'm abusing fail in the list monad just because all the pattern matching I'm doing would be a remarkable pain to explicitly cover every case for.
15:17:18 <c_wraith> There's only one success case in a massively nested structure.
15:17:23 <applicative> benmachine, is it the end or the means that is evil
15:17:29 <benmachine> applicative: a little of both, natch
15:17:50 <c_wraith> But because some of the nesting is via newtypes that don't have their wrappers exposed, I can't actually just build a single pattern-match for it
15:18:10 <benmachine> the basic principle is a server that forks and execs itself when it detects its executable has changed
15:18:19 <benmachine> without dropping any connections
15:18:32 <benmachine> but this involves deconstructing and serialising the Socket data type
15:18:37 <benmachine> and, um, dropping a connection
15:18:39 <benmachine> (but nicely)
15:18:58 <fax> anything good
15:19:03 <fax> I don't know
15:19:36 <gwern> benmachine: I'm desultorily learning asm now, though, so maybe in the future when I find some cheap digital compass I'll be able to make something
15:20:08 <benmachine> gwern: :D
15:20:45 <benmachine> it can't be that complicated, right? >_>
15:21:15 <gwern> you would think not, but I'm still boggling over how to define the length of a string constant
15:21:25 <gwern> and over addressing RAM in general
15:21:42 <benmachine> oh dear oh dear
15:21:46 <benmachine> can't you C-- or something?
15:22:02 <gwern> what's the point of C? I'd be wtfing just as much, and everyone knows C
15:22:07 <gwern> asm is hardcore
15:22:20 <benmachine> I like that attitude
15:22:29 <gwern> when you write in asm, brothers know
15:22:34 <benmachine> if people can understand what you're doing you're not doing it hard enough
15:22:59 <kmc> haha
15:23:17 <Adamant> I kinda figured gwern already knew asm.
15:23:34 <benmachine> he seems to know most things.
15:23:41 <benmachine> (see? it's working already!)
15:23:54 <Adamant> or is this a parody of something else I have no context clues about
15:23:56 <Berengal_> I feel bad for not knowing asm
15:24:04 <ivanm> benmachine: yeah, because he read about them all in wikipedia ;-)
15:24:07 <Berengal_> And now I'm trying to learn groovy... My standards have fallen :(
15:24:07 * gwern wonders why anyone would think I know asm
15:24:31 <gwern> Berengal_: is groovy still growing? I haven't heard too much - clojure and scala seem to've stolen its buzz
15:24:32 <Adamant> gwern: probably because it's not really hard to learn.
15:24:47 <benmachine> I once helped a friend write a C program that was basically a static const char array being cast to a function pointer and then executed
15:24:48 <ivanm> Adamant: just hard to use?
15:24:51 <benmachine> does that count
15:25:00 <Berengal_> gwern: I don't know. I just started looking at it
15:25:14 <Adamant> at least, I figure more folks have learned asm than category theory :P
15:25:15 * ivanm once wrote a C program but doesn't want to talk about it
15:25:29 <gwern> Adamant: probably yeah
15:25:32 <Apocalisp> asm is for pussies
15:25:40 <Apocalisp> B4 3F CD 21
15:25:46 <lbc_> c is nothing but a bunch of asm macros anyway
15:25:49 <c_wraith> seriously, is there any pattern for doing a bunch of pattern matches (that can't be a single expression) in a row, that doesn't depend on abusing fail?
15:26:01 * gwern torrented a new asm book, 'assembly language step by step'. it seems pretty decent
15:26:03 <Adamant> ivanm: it's not hard to use. it's hard to get anything done in.
15:26:03 <benmachine> nested case?
15:26:07 <Berengal_> c_wraith: view patterns?
15:26:10 <benmachine> or, those
15:26:13 <ivanm> Adamant: that's what I meant
15:26:17 <Adamant> it's also hard to anything done it correctly :P
15:26:20 <c_wraith> oh.  Hmm.  Those could be what I want.  I should learn them
15:26:22 <Adamant> ivanm: yup
15:26:33 <newsham> > int fact(int n) { int x = 1; while(--n) x *= n; return x; }  printf("%d\n", fact(5));
15:26:34 <Berengal_> Or just case over a function...
15:26:34 <lambdabot>   <no location info>: parse error on input `x'
15:26:36 <ivanm> Adamant: "also hard to anything done" ?
15:26:41 <gwern> get
15:26:43 <Berengal_> case deconstruct foo of ...
15:27:07 <Adamant> ivanm: depends on how high you set your sights and how much time you have :P
15:27:20 <newsham> libc: "nothing but a bunch of asm macros"?  which asm macro captures registerization?
15:27:26 <c_wraith> This would be 4 nested case statements, each of which would have the exact same "_ -> ..." clause
15:27:31 <ivanm> Adamant: I meant that English wasn't very goodly
15:27:45 <c_wraith> I feel nesting case statements there is a very idea.
15:28:02 <c_wraith> err, very poor idea
15:28:06 <benmachine> c_wraith: accidentally the whole adjective
15:28:07 <Adamant> ivanm: I went to government-run schools :P
15:28:11 <Berengal_> c_wraith: Write that nested case in a function, and pattern match on the function instead
15:28:18 <ivanm> Adamant: so did I for primary school
15:28:38 * ivanm heads off
15:28:39 <ivanm> bye all
15:28:42 <benmachine> government-run schools are the best
15:28:47 <c_wraith> Berengal_: the match isn't just constructors.  Two of the levels are abstract data types.
15:28:58 <benmachine> in every sense other than literally
15:29:22 <benmachine> c_wraith: so you could do _ -> fallback; and then where fallback = at the bottom
15:29:28 <benmachine> c_wraith: or, view patterns
15:29:37 <c_wraith> eh.  fallback is just []
15:29:43 <Berengal_> c_wraith: Feel free to map the results of deconstructing those abstract data types into your own concrete one which you can pattern match on
15:29:48 <benmachine> then that's not really much overhead, stop whining :P
15:30:00 <c_wraith> It's the ugliness that's the problem, not the runtime
15:30:13 <Berengal_> Do you have some example code?
15:30:20 <c_wraith> sure
15:30:25 <benmachine> you could Data.Generics.everywhere a function that un-did the abstract type
15:30:28 <c_wraith> one minute
15:30:30 <benmachine> and then pattern match on the result
15:32:11 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25377
15:32:12 <Berengal> (I don't really like abstract data types. Well, they're good, but at the very least people should define a "deconstruct result" type you can pattern match on)
15:32:42 <c_wraith> really, the abstract type in here is just a newtype
15:33:10 <kmc> yeah.  views are a good idea with abstract types
15:33:19 <c_wraith> But unwrapping that doesn't help so much, as I still need do the list find
15:33:29 <benmachine> c_wraith: why not Maybe instead of list?
15:33:33 <kmc> maybe the situation will improve as a) more people become familiar with view patterns, and b) the feature gets refined a bit more
15:33:40 <c_wraith> Because the result is a list anyway.
15:33:51 * Berengal 's internet is too slow to even open hpaste. Stop clogging up the tubes people!
15:34:10 <c_wraith> I don't care about the difference between "it was formatted wrong" and "it was formatted right with no content"
15:34:21 <benmachine> oic
15:35:14 <fax> I don't think I should have learned haskell because I don't have anything to do with it
15:35:17 <benmachine> I don't think the fail-abuse version is too bad
15:35:32 <benmachine> fax: you just lack creativity :P
15:35:39 <c_wraith> Despite wrapping everything in list constructors just to abuse fail with bind?
15:35:45 <gwern> fax: 'as long as we have a single program, we will never lack for programs to write' --alan perlis (paraphrase)
15:36:11 <benmachine> c_wraith: conceptually it's a bit eek, but it's not hard to understand what's going on
15:36:20 <benmachine> oh hey, would pattern guards help here?
15:36:30 <Berengal> Learning Haskell makes you miserable
15:36:35 <benmachine> well they are very similar to view patterns in this case probably
15:36:41 <newsham> learn you a haskell for great miserable
15:36:43 <hpc> Berengal: only when coding in languages not Haskell
15:36:44 <newsham> ?
15:36:55 <gwern> @quote sad
15:36:56 <lambdabot> erg0t says: <erg0t> y te re inserta su pija gorda, arrugada, engrasada y esponjosa
15:36:58 <Berengal> hpc: And when's that not the case?
15:37:04 <benmachine> learning haskell makes me happy
15:37:07 <hpc> haha
15:37:18 <gwern> @quote happy
15:37:19 <lambdabot> Korollary says: Can't you pretend that you've never heard of any of this and keep hacking happy java?
15:37:24 <benmachine> because I don't code for anyone other than myself
15:37:25 <gwern> (that's more like it)
15:37:50 <hpc> to be had, my job has me doing Perl, so the feelings of "why can't I use Haskell" and "thank god it isn't Perl" cancel out
15:38:02 <benmachine> heh
15:38:03 <Berengal> You know the quote about how Java people or Python people don't claim their language is the best for everything, but Lisp (and Haskell) people do?
15:38:13 <benmachine> no
15:38:20 <benmachine> we're right though!!
15:38:20 <hpc> because it is true :P
15:38:22 <Berengal> Well, there's a quote that sais that
15:38:25 <Berengal> says*
15:38:28 <kmc> at least Perl actually supports powerful abstraction
15:38:33 <kmc> you'll go mad trying to use it, but it's there
15:38:38 <Berengal> Anyway, the people at work *do* think java is the best language for everything :(
15:38:42 <benmachine> hah
15:38:45 <dcoutts_> I'd like to note that Well-Typed are hiring
15:38:46 <hpc> wow
15:38:55 <kmc> dcoutts_, interesting
15:38:57 <dcoutts_> http://blog.well-typed.com/2010/05/well-typed-are-hiring/
15:38:58 <newsham> dcoutts: hiring for what type of work?
15:38:58 <p_l> Berengal: Python people maybe not, but Java people instead *enforce* their notion by making it "the only language"
15:39:05 <benmachine> you know what's awesome about never doing professional programming? I don't even know java
15:39:21 <c_wraith> Hmm.  View Patterns look *really* close to what I want.  But they don't appear to support the kind of nesting I want, either.
15:39:23 <benmachine> newsham: well-typed work presumably
15:39:25 <hpc> what's awesome about Perl is you can do shell scripting in it
15:39:27 <theorbtwo> If you're constantly thinking "thank god it isn't Perl", then perhaps you should try learning to use perl more effectively.
15:39:38 <dcoutts_> newsham: to be a Haskell consultant
15:39:47 <Berengal> p_l: Indeed. The "single platform" is the reason Java is the only language. And it seems they think PHP and VB are the only alternatives, but they are (rightly) crap.
15:39:49 <gwern> dcoutts_: I've been in #haskell for years! obviosuly I qualify for your well-typed position
15:39:53 <hpc> but as a general programming language, it is fairly weak
15:40:06 <theorbtwo> What's awesome about perl is that you can do powerful and fairly fluent metaprogramming in it.
15:40:36 <dcoutts_> gwern: we will consider all serious applicants
15:40:44 <p_l> ... oh god, now I wish I spent last three years getting my Haskell skills to high level...
15:40:47 <gwern> :)
15:40:51 * hackagebot happstack-facebook 0.23 - A package for building Facebook applications using Happstack  http://hackage.haskell.org/package/happstack-facebook-0.23 (JeremyShaw)
15:40:51 <newsham> dcoutts: am I reading this right?  aprox 37500 lb/yr (250 days at 150lb/day) ?
15:41:00 <benmachine> c_wraith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25377#a25378 hmm?
15:41:00 <kmc> hehe lb
15:41:07 <p_l> (regarding well-typed offer)
15:41:11 <theorbtwo> Perl is rather misunderstood because it is fairly old, and still evolving.
15:41:14 <hpc> the only really cool feature of Perl i have seen is using "my %params = @_;"
15:41:40 <c_wraith> whoa.  didn't realize you could nest view patterns.
15:41:45 <gwern> dcoutts_: I have no formal CS credentials; I would be amused to see whether that meant I wasn't a serious applicant
15:41:46 <c_wraith> That's truly ugly! :)
15:41:57 <c_wraith> However, I do think it's semantically cleaner.
15:42:16 <newsham> hpc:   def func(*args) :
15:42:44 <benmachine> c_wraith: well, you can de-ugly it a little, of course
15:42:55 <hpc> newsham: python?
15:43:01 <newsham> yes
15:43:04 <hpc> i like it
15:43:05 <dcoutts_> newsham: that's the daily rate, I'm not sure that we can guarantee a particular number of days work, but it is intended to be up to full time (but we'll consider people who want less than full time)
15:44:04 <newsham> dcoutts: I'm just suprised that its so low.  imagine trying to live in london on that :)
15:44:05 <benmachine> I'm only like three years from finishing my degree, I could totally do it then
15:44:08 <Peaker> I just saw SPJ's talk on NDP, he's a great speaker
15:44:20 <alpounet> yes he's good at giving talks
15:44:44 <Peaker> He was a bit unprepared w.r.t comparison with the dynamic work theft approach
15:45:29 <gwern> newsham: I think the idea is that you live somewhere cheap
15:45:36 <dcoutts_> newsham: as a small company it's hard to make guarantees, we hit a rather higher rate than that last financial year
15:45:40 <ezyang> dcoutts_: Quadruple your productivity with an army of student interns! <http://blog.ksplice.com/2010/03/quadruple-productivity-with-an-intern-army/>
15:45:46 <ezyang> :-)
15:45:50 <dcoutts_> heh :-)
15:45:51 <newsham> dcoutts: good to hear.  I was getting worried for you.
15:46:15 <p_l> newsham: £200 a month is everything I need to cover rent, council tax and most of electricity bills...
15:46:18 <gwern> newsham: for example, you could live handily in south korea on that, I think
15:46:26 <dcoutts_> newsham: but obviously we cannot guarantee someone that we'll hit the same, so we split it as baseline + profit share
15:46:35 <newsham> *nod* makes sense
15:46:42 <gwern> > 3 * (150 * 7)
15:46:43 <kmc> p_l, where do you live for that?
15:46:43 <lambdabot>   3150
15:46:48 <newsham> your company does a bit of ghc dev work yes?
15:46:53 <dcoutts_> yep
15:46:56 <p_l> kmc: renting a cheap room in Aberdeen
15:47:12 <gwern> > 3 * (150 * 5)
15:47:13 <newsham> gwern: in north korea you'd be king!
15:47:13 <lambdabot>   2250
15:47:31 <fax> > 9 * 25 * 10
15:47:32 <lambdabot>   2250
15:47:37 <kmc> scotland eh
15:47:42 <gwern> newsham: no, south korea. 3 weeks, 5 days, 150 a day; and that's 3.8m won a month, which is pretty decent
15:47:50 <kmc> is it cold as balls there?
15:47:54 <p_l> kmc: it's a three bedroom flat shared with 3 people.
15:47:59 <newsham> i live in a very pricey place
15:48:02 <p_l> kmc: not really, but it can be.
15:48:10 <newsham> i live fairly cheaply if you dont count the mortgage
15:48:23 <p_l> kmc: though Aberdeen is at shore, so the temperature doesn't drop too low
15:48:34 <gwern> newsham: in comparison, an ESL teacher fresh from the USA could expect to make ~2m won a month, and that's considered enough to let them save ~1000USD a month (although they get free housing)
15:49:03 <p_l> kmc: usually I encounter much colder weather in Poland.
15:49:38 * gwern is always a little surprised that so few software devs seem to live in low-cost foreign countries and telecommute
15:50:07 <kmc> i'm surprised more people don't live as traveling hobos and telecommute
15:50:15 <gwern> 'technomads'
15:50:27 <newsham> software devs sometimes have wives and kids and other anchors
15:50:33 <winxordie> robo-Erdos?
15:50:34 <mle> hmm, what are your bandwidth options like when telecommuting from nowhere though?
15:50:40 <newsham> that might not want to be nomadic
15:50:42 <gwern> I think the problem is luggage. I can just about fit my clothes into my footlocker and that's it
15:50:56 <gwern> mle: from south korea? better than in the US...
15:51:02 <winxordie> I personally think everything important should be stuffable into a suitcase.
15:51:03 <kmc> hell yes
15:51:13 <blackdog> gwern: i've thought about that for a long time
15:51:27 <blackdog> stars just never quite line up right
15:51:41 <gwern> (my footlocker is 27 pounds, which blows a decent chunk of the usual airline 70 pound limit. :(
15:51:47 <blackdog> btw, anyone else doing the google code jam today?
15:51:53 <Adamant> gwern: more people do it that you think
15:51:54 <gwern> blackdog: what exactly? I'm thinking about doing esl in south korea
15:52:06 <winxordie> blackdog: I've been thinking about doing the jam.
15:52:08 <fax> oh I had a look at it but I don't have the motivation to play
15:52:08 <gwern> Adamant: probably, but as many as I would expect?
15:52:23 <Adamant> gwern: dunno what your expectations are :p
15:52:27 <blackdog> gwern: i've always had enough freelance work to be able to live wherever - it's more family, friends, my girlfriend...
15:52:39 <p_l> the airline weight limit is 32 kg per *piece*, and depending on stuff like frequent flyer status you can easily get cheap extra piece...
15:52:48 <blackdog> winxordie: do it, we need a haskell posse
15:52:50 <blackdog> 12 minutes
15:52:51 <blackdog> :)
15:52:53 <winxordie> hehe
15:52:55 <Adamant> also, for big enough countries, you can get pretty decent price differentials just by moving to different areas in the country.
15:53:06 <winxordie> I don't know if I can code fast enough in haskell blackdog :(
15:53:16 <blackdog> whoops, 7 minutes
15:53:17 <gwern> mm. the US seems pretty consistently expensive, outside of the metropolises which are really expensive
15:53:48 <blackdog> gwern: i was surprised by how cheap portland and NY were, actually
15:53:56 <Adamant> gwern: depends on your definition of expensive, but where I live right now is dramatically cheaper than, say, the Silly Valley.
15:53:59 <blackdog> which makes me suspect sydney is just horrifically expensive in comparison
15:54:14 <gwern> blackdog: NY? Cheap? where were you looking?
15:54:15 <BMeph> says: @hoogle something
15:54:35 <Adamant> NY State isn't that expensive as opposed to the environs around NYC and NYC proper.
15:54:36 <blackdog> gwern: clothes were very cheap
15:54:43 <blackdog> food is cheaper than i expected
15:54:44 <gwern> oh clothes @_@
15:54:58 <blackdog> in sydney, tech books are rarely under $100
15:55:14 <gwern> Adamant: given how big the boroughs are, and that long island is considered part of NYC as far as cost goes, you've basically said 'out in the hick boondocks upstate NY is cheap'
15:55:18 <blackdog> still, we got hell of beaches:)
15:55:31 <blackdog> gwern: I was in Manhattan and Brooklyn
15:55:35 <gwern> Adamant: and I do mean hick boondocks - I have a friend from upstate NY whose last name is 'Hicks'
15:56:00 * gwern always found that really funny, actually
15:56:01 <Adamant> gwern: everything is boondocks to a NYC resident. read the 'New Yorker' cartoon :P
15:56:35 <gwern> Adamant: as a LIer I'm hardly one to talk. silly flyover people, not realizing their unimportance
15:56:36 <Adamant> also, if you live in NYC, yes, you will think the US is expensive.
15:57:20 <Adamant> some other areas are pretty close to NYC in price, but the overwhelming majority isn't.
15:58:26 <kmc> "hicksville" is a town on long island
15:58:42 <kmc> i don't think all of long island is comparable cost to NYC
15:58:56 <kmc> even rockaway (within the city itself) is much cheaper
15:59:16 <gwern> kmc: you've got NYC on the west end pushing things up, you've got the hamptons on the east end pushign things up...
15:59:50 <gwern> (although god bless the hamptons for blowing money on wine and goat cheese. where would the rest of us get our delicious goat cheese if not for them?)
16:00:01 <kmc> i prefer my goats un-cheesed
16:01:13 <gwern> clearly you've never had good goat cheese
16:01:40 <gwern> ambrosia of the gods!
16:02:03 <pikhq> gwern: So, ambrosia then?
16:02:11 <gwern> not nectar
16:02:23 <gwern> don't let people confuse them. ambrosia is solid, nectar liquid
16:03:05 <aavogt> it's also a salad made with marshmallows
16:03:34 <gwern> a later innovation of the teutonic barbarians
16:03:44 <gwern> mere metics in the greek culture
16:04:30 <gwern> I wonder if wordnet knows that term?
16:04:32 <gwern> @wn metic
16:04:33 <lambdabot> *** "metic" wn "WordNet (r) 2.0"
16:04:33 <lambdabot> metic
16:04:33 <lambdabot>      n : an alien who paid a fee to reside in an ancient Greek city
16:04:39 <gwern> atta boy!
16:05:59 <kmc> gwern with the vocab today
16:06:07 * gwern is *always* about the vocab, foo
16:08:08 <Adamant> I would make jokes about Herman the German, but given the current geopolitical situation it doesn't seem advisable.
16:09:32 <Entroacceptor> not?
16:09:38 <Entroacceptor> did I miss something again?
16:11:10 <Adamant> Entroacceptor: trying to avoid potential unpleasantness in case modern-day Greeks and Germans start arguing about stuff that is very much off-topic :P
16:11:31 <kmc> didn't germany buy greece anyway
16:11:45 <Adamant> kmc: instigator
16:11:57 <hpc> i thought it was America's fault
16:12:03 <kmc> you mean amerikkka
16:12:08 <hpc> heh
16:12:09 <Adamant> hpc: it's always America's fault.
16:12:10 <kmc> sorry, i'll stop
16:12:17 <Adamant> Rule #1 of geopolitics
16:12:31 <gwern> Adamant: incidentally, I include england and hence america among descendants of teutons
16:12:41 <hpc> America: the cause of and solution to all of earth's problems
16:12:48 <gwern> kmc: no no, it's "Amerika" one-k
16:12:54 <kmc> hpc, fuck yeah
16:13:13 <Adamant> gwern: I was talking about the really Kraut-y ones, not us junior-grade krauts
16:13:24 <gwern> sourkrauts
16:13:39 <Adamant> liberty cabbage, you Kaiser-lover
16:14:17 <gwern> pow! right in the kaiser
16:14:56 <hpc> mayonnaise salad, Yank :P
16:16:08 <kmc> "mayonnaise salad" sounds like the most disgusting food
16:16:16 <hpc> it truly does
16:16:19 <Adamant> hpc: you have offended mah honnouh by referring to me as uh Yankee, suh
16:16:21 <tensorpudding> What is mayonnaise salad?
16:16:30 <hpc> it is pure disgustingness
16:16:35 <tensorpudding> It surely isn't sauerkraut.
16:16:47 <Adamant> I thought it was an ambrosia
16:16:54 <hpc> sauerkraut makes me think of mayonnaise for some reason
16:17:00 <hpc> and it sorta looks like salad
16:18:18 <Adamant> it could be worse. it could be lutevisk.
16:22:38 * hpc googles
16:22:46 <hpc> great googly moogly!
16:22:50 <Adamant> hpc: what is seen, cannot be unseen.
16:23:15 <Adamant> just don't eat the stuff and you'll be fine in the long run, though :P
16:23:39 <Adamant> (I've got folks from Scand-land, I can make fun of it)
16:24:29 <hpc> eh, it's like an obscure version of haggis
16:24:36 <hpc> completely fair game for anyone to make fun of
16:26:36 <tensorpudding> Hmm, treated with lye, that sounds like fun.
16:26:53 <tensorpudding> Can't imagine how they thought of doing that.
16:29:04 <Adamant> there are some pretty weird food processing techniques.
16:29:42 <Adamant> like eating coffee beans that have passed through a civet's intestine and been shit out. they charge extra for this.
16:30:24 <gimpyastronut> Hallo
16:30:28 <kmc> hi gimpyastronut
16:30:41 <gimpyastronut> It's good to be here.
16:32:12 <gimpyastronut> I was just wondering if you or someone could describe what's good with Haskell. I had it installed at one point in the past, but got rid of it, because I didn't know what it was for and AVG (Linux) reported it was virus-infected.
16:32:24 <kmc> haha
16:32:48 <gimpyastronut> So what is Haskell for?
16:32:50 <tensorpudding> AVG is available for Linux?
16:32:55 <gimpyastronut> Yes
16:33:00 <kmc> gimpyastronut, it's a sophisticated programming language
16:33:11 <gimpyastronut> What is it good for?
16:33:13 <AmunRa> Hello! What do I need to read up to expose Haskell to C?
16:33:20 <kmc> gimpyastronut, writing software that works the first time
16:33:30 <kmc> AmunRa, the FFI chapter in _Real World Haskell_, for starters
16:33:35 <mauke> preflex: ? ffi
16:33:35 <preflex>  http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
16:33:39 <gimpyastronut> Mmm sounds good so far.
16:33:39 <kmc> if you've already read that, maybe the FFI spec
16:33:44 <kmc> gimpyastronut, http://haskell.org/
16:34:07 <kmc> gimpyastronut, http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
16:34:14 <gimpyastronut> TNX kmc. I'll check it out, but in the meantime what sort of things have you used Haskell for?
16:34:14 <AmunRa> yeah, that chapter is good but it really mostly deals with interfacing C with Haskell, rather than exposing haskell to C
16:34:32 <tensorpudding> It's a pure, lazily-evaluated functional language.
16:34:40 <kmc> gimpyastronut, personally: writing compilers, interpreters, debuggers, graphics, bioinformatics, IRC bots, etc.
16:34:44 <gimpyastronut> I'm familiar with FORTRAN, Ada (GNAT) and others.
16:34:49 <kmc> it's a general purpose language.  it's good for most tasks
16:35:00 <gimpyastronut> Bioinformatics sounds good.
16:35:27 <gimpyastronut> Well, thanks, I'll check it out and give it another try.
16:35:33 <tensorpudding> Fortran and Ada are pretty much the opposite of Haskell.
16:35:47 <tensorpudding> Well, not Ada, Ada does have strong typing.
16:35:48 <Adamant> well, not exactly.
16:35:50 <Adamant> yeah.
16:35:51 <kmc> gimpyastronut, its biggest industrial uses (http://haskell.org/haskellwiki/Haskell_in_industry) involve creating domain-specific languages for things like embedded systems programming, hardware design, financial modeling
16:35:56 <gimpyastronut> What language is closest to Haskell.
16:36:00 <kmc> gimpyastronut, Haskell
16:36:01 <kmc> ;)
16:36:02 <Adamant> ML
16:36:09 <Adamant> Miranda
16:36:16 <gimpyastronut> :)
16:36:21 <kmc> gimpyastronut, among languages people use today, SML, OCaml, and F#
16:36:22 <tensorpudding> Languages close to Haskell include Objective Caml, Standard ML, Miranda, and even less popular languages
16:36:26 <AmunRa> Clean
16:36:33 <gimpyastronut> Wow.
16:36:39 <kmc> gimpyastronut, Haskell has a lot of uncommon features
16:36:50 <kmc> and it's best not thought of as "FooLang with the addition of bar"
16:36:52 <kmc> as so many other languages are
16:36:57 <gimpyastronut> Well, thanks for all the input, I'll give it another try.
16:37:00 <kmc> :)
16:37:00 <tensorpudding> It's in the ML family of languages.
16:37:02 <kmc> @where rwh
16:37:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:37:03 <kmc> @where lyah
16:37:04 <lambdabot> http://www.learnyouahaskell.com/
16:37:09 <kmc> gimpyastronut, ^^^ the two most popular resources for beginners
16:37:13 <theorbtwo> Interesting that you said it's the opposite of FORTRAN, but is very much like F#.
16:37:34 <theorbtwo> I thought F# was fortran, plus CLR?
16:37:34 <Adamant> basically, it's one of the languages where if you haven't done something really similar before, you're gonna need to sit down and learn a lot.
16:37:40 <Adamant> no
16:37:45 <newsham> f# is from ocaml
16:37:46 <Adamant> it's more related to OCaml
16:37:54 <theorbtwo> Ah.
16:38:01 <gimpyastronut> Never heard of F#, but have C# -- don't really like it since I can do things simpler in a combination of other languages and then link them.
16:38:02 <JoeyA> How would I read a line with two integers in Haskell?  Would I want to say (in a do block) line <- getLine, then use a function to read the numbers from the line?
16:38:08 <Adamant> basically a ML/OCaml stuffed into the CLR context
16:38:17 <tensorpudding> Fortran is mostly OCaml stripped of some syntax, plus CLR, and a different system for handling imperative programming.
16:38:26 <tensorpudding> err, F#!
16:38:27 <newsham> joeya: that would work.  you could also use parsec
16:38:31 <mauke> JoeyA: map read . words
16:38:32 <kmc> JoeyA, [x,y] <- map read . words <$> getLine
16:38:40 <kmc> <$> from Control.Applicative
16:39:04 <gimpyastronut> So far it sounds like Haskell has a lot in common with C++.
16:39:08 <kmc> hahaha
16:39:10 <kmc> not at all
16:39:14 <tensorpudding> Haskell is very different than C++.
16:39:16 <gimpyastronut> Oi veh.
16:39:27 <gimpyastronut> Now I'm a bit more confused.
16:39:30 <fax> haskell is where C++ programmers go to die
16:39:31 <kmc> gimpyastronut, I suggest you learn Haskell
16:39:35 <tensorpudding> Though C++ templates are somewhat similar to the way Haskell handles polymorphic types.
16:39:39 <kmc> and don't worry about comparing it to this or that
16:39:42 <kmc> until you understand it well
16:39:43 <JoeyA> What is <$> ?
16:39:46 <gimpyastronut> [laughing]
16:39:49 <kmc> JoeyA, a synonym for fmap
16:39:51 <newsham> ?src <$>
16:39:52 <mauke> JoeyA: fmap
16:39:52 <lambdabot> f <$> a = fmap f a
16:39:53 <fax> what kmc said is the best possible advice about learning a programming langauge
16:39:54 <kmc> :t (<$>)
16:39:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:40:06 <fax> Just leave everything you know behind
16:40:15 <tensorpudding> gimpyastronut: There is a decent possibility you've never used a language similar to Haskell before.
16:40:21 <kmc> fax, i'm not sure.  if you know Perl it is useful to see Python as "Perl with nicer syntax", or if you know Java it's useful to see C# as Java with some missing features added
16:40:25 <gimpyastronut> lambdabot, that looked similar to APL.
16:40:28 <kmc> a lot of languages are just variations on a theme
16:40:33 <newsham> in kmc's example, <$> applies the pure function (map read . words) to the result of the impure action getLine
16:40:39 <gimpyastronut> tensorpudding, that seems to be the case.
16:40:46 <Peaker> gimpyastronut, one of the most important Haskell ideas, is that Haskell has "functions".. as in, the mathematical notion of functions (computational maps from domains to ranges). Most programming is done with functions -- and not using sequences of effects. This has a whole lot of useful advantages
16:40:47 <kmc> Haskell is just really different from most languages people have seen before
16:40:47 <mauke> s/nicer/terrible/
16:40:48 <theorbtwo> gimpyastronut: Any given feature of haskell is probably similar to a feature in at least one other language.
16:41:02 <theorbtwo> The likelyhood that you know this other language isn't great.
16:41:07 <aristid> kmc: well, haskell really has conceptual similarities to c++ templates, although it has the advantage of not being an accident.
16:41:16 <Peaker> gimpyastronut, What most languages call "Functions" are not similar at all to mathematical functions
16:41:23 <theorbtwo> However, haskell takes a reasonably unique combination of them.
16:41:31 <tensorpudding> There are many languages that implement functional programming primitives but few languages that make functional programming the standard paradigm.
16:41:41 <theorbtwo> It's a bit lik the old joke of blind men describing an elephant.
16:41:49 <Adamant> this is probably one of the cases where analogies are less useful than experience.
16:41:53 <gimpyastronut> theorbtwo, but the real issue between the languages I use, is, how easiest I can express an idea.
16:41:54 <newsham> C, C++, Java are romance language.  lisp, perl and python are still european.  Haskell's chinese.
16:41:56 <JoeyA> What module is <$> defined in?
16:42:06 <newsham> Control.Arrow?
16:42:14 <lispy> :hoogle <$>
16:42:19 <mauke> <kmc> <$> from Control.Applicative
16:42:21 <lispy> ?hoogle <$>
16:42:21 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:42:26 <newsham> applicative :)
16:42:26 <AmunRa> aristid, C++ template metaprogramming is effectively purely functional :-)
16:42:28 <tensorpudding> Haskell and ML are more similar to the Lisp family than to the Algol family.
16:42:36 <Adamant> newsham: Lisp would be like Hungarian, if the Huns had build a long lasting empire :P
16:42:40 <gimpyastronut> I've even used Maxima to express tensor computations and then exported them to FORTRAN.
16:42:41 <aristid> AmunRa: yes, in a sick and twisted way :)
16:42:43 <lispy> lisp is more like sanskrit
16:42:45 <JoeyA> a.out: Prelude.read: no parse
16:42:49 <theorbtwo> gimpyastronut: You will find expressing ideas in haskell terribly difficult for a while, after which it will be terribly easy.
16:42:52 <Adamant> yeah, better analogy
16:43:00 <gimpyastronut> I'm familiar with LISP/Prolog.
16:43:10 <kmc> LISP/Prolog?
16:43:10 <AmunRa> aristid, as you would expect from C++ of course (still the language I spend most time on)
16:43:14 <newsham> adamant: so python, perl and ruby are dialects of finnish?
16:43:16 <mauke> IMO d(perl,lisp) < d(haskell,lisp)
16:43:19 <tensorpudding> Recursion is used in Haskell in replacement of iteration.
16:43:35 <tensorpudding> It's even more common than it is in Lisps.
16:43:43 <kmc> python and perl are like a lot of other languages
16:43:46 <Adamant> well, ones that aren't Scheme.
16:43:47 <aristid> tensorpudding: fortunately it's usually abstracted. it'd be tiresome to always do manual recursion
16:43:48 <Peaker> I agree with mauke
16:43:52 <newsham> to iterate is illiterate
16:43:53 <kmc> Finnish is like nothing else except Estonian ;)
16:43:58 <tensorpudding> Though it's not explicit, because of the use of higher-order functions.
16:44:00 <theorbtwo> kmc: Well, to be fair, a lot of other languages are like perl, I think.
16:44:24 <newsham> kmc: finnish, estonian and hungarian are all magyar languages
16:44:38 <tensorpudding> If you're familiar with Common Lisp/Scheme, there are some common features. They both utilize closures and higher-order functions.
16:44:39 <theorbtwo> I'll freely admit to being a partisan here.
16:44:40 <Peaker> gimpyastronut, Haskell is pretty good at the "how easy to express an idea" measurement -- but there are other interesting measurements ("how likely the type system is to catch errors", "how easy will it be to change code later") which Haskell excels at
16:44:43 <gimpyastronut> Yes, I've used TurboProlog for compiling, but written programs in LISP and then used LISP to translate them to Prolog for TurboProlog. That really puts your mind into a different frame when you need an iterative loop with only recursion available to you.
16:44:46 <newsham> "finno-urgic"
16:45:05 <akosch> newsham: "finno-ugric" is more like it :)
16:45:13 <kmc> but imo closures and higher-order functions are so fundamental
16:45:19 <tensorpudding> Lisp does have iteration though.
16:45:19 <kmc> that this should be like saying "they both utilize integers"
16:45:24 <tensorpudding> At least, CL
16:45:29 <kmc> however, it's not, because C++ and Java have flawed designs
16:45:42 <kmc> so people think that first-class functions are strange and exotic
16:46:00 <theorbtwo> gimpyastronut: Like lisp, haskell is heavily into passing around functions, rather then only more mundane sorts of values.
16:46:17 <hpc> it has an entire name even, continuations
16:46:27 <gimpyastronut> tesnorpudding, I'm not familiar with LISP iteration. The way I did it, was to first nail down the exit-condition, then use the control of backtracking to save on stack-space.
16:46:32 <theorbtwo> Like C, it is typed.  Unlike C, the types tend to just work.
16:46:49 <tensorpudding> Haskell also has a let, which is kin to the let in CL/Scheme though Haskell uses pattern matching significantly.
16:47:12 <theorbtwo> gimpyastronut: Then you will be well-placed to understand recursion-instead-of-iteration in Haskell.
16:47:17 <aristid> i don't think HOFs are the most difficult aspect for non-haskell programmers
16:47:30 <Peaker> When programming Haskell, I rarely use recursion directly
16:47:36 <JoeyA> In this:  map read . words <$> getLine
16:47:44 <kmc> :t map read . words <$> getLine
16:47:45 <lambdabot> forall a. (Read a) => IO [a]
16:47:45 <JoeyA> what order of operations does . have?
16:47:46 <newsham> to iterate is illiterate, to recurse is worse..
16:47:46 <gimpyastronut> Well, I've got to go, but thanks for the clear info and everyone have a wonderful night and 73s to all.
16:47:50 <tensorpudding> CL has mapcar, Haskell has map
16:47:52 <newsham> we abstract out the recursion
16:47:54 <kmc> JoeyA, it's (map read . words) <$> getLine
16:47:55 <theorbtwo> aristid: I think the hardest aspect for me starting is getting out of a monad to write pure code.
16:48:10 <pikhq> aristid: No, it's the "ZOMG MONADS" bit.
16:48:14 <Peaker> @type (.)
16:48:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:48:19 <Peaker> JoeyA, The type of (.) tells you
16:48:25 <tensorpudding> The most vital between Haskell and the Lisps are that Haskell has static types.
16:48:30 <pikhq> Not realising that a "monad" is just higher-order-function-land.
16:48:36 <pikhq> :P
16:48:40 <tensorpudding> vital difference*
16:48:42 <aristid> pikhq: yeah it just takes a mental bit flip or something, and it takes a long while, or it did for me.
16:48:52 <newsham> (\x -> map read (words x)) <$> getLine
16:48:52 <Peaker> tensorpudding, Purity is more vital, imo
16:48:52 <theorbtwo> pikhq: I think I got monads, at least the first bit of getting them.
16:49:01 <Peaker> purity, static types, laziness
16:49:08 <tensorpudding> Purity is an effect of the type system.
16:49:13 <theorbtwo> I never managed to *escape* them, and get a decent glimpse of the promised land.
16:49:22 <pikhq> tensorpudding: Type system + laziness.
16:49:25 <Peaker> tensorpudding, Why do you say that?
16:49:25 <p_l> yeah, most lisps are dynamic languages (doesn't mean the type system has to be less capable, though. It's just that runtime replacement, including replacement of types, would run afoul of Haskell-style in big app)
16:49:40 <Peaker> You can have a type system, laziness, and still not have purity (e.g: unsafePerformIO, unsafeInterleaveIO)
16:49:52 <newsham> peaker: you mean Haskell?
16:49:58 <Peaker> Yes :-)
16:50:02 <dcoutts_> unsafeInterleaveIO isn't impure
16:50:18 <kmc> Haskell's type system enforces no separation between pure and impure values
16:50:18 <pikhq> unsafeInterleaveIO is merely unsafe.
16:50:21 <Peaker> dcoutts_, unsafePerformIO isn't impure either (in certain use cases)
16:50:32 <tensorpudding> Yes, but the unsafe-fu is special; you can't write it yourself, because of type system and because IO is segregated by being a monad.
16:50:33 <kmc> you almost never see an impure value
16:50:44 <Peaker> unsafeInterleaveIO yields impurity later on in certain use cases
16:50:50 <newsham> dcoutts: what if the underlying file is time variant?
16:50:55 <kmc> yeah
16:51:04 <kmc> unsafeInterleaveIO allows you to make order of execution depend on order of evaluation
16:51:13 * hackagebot hpage 0.8.6 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.6 (FernandoBenavides)
16:51:15 <Peaker> I hate lazy IO :P
16:51:19 <dcoutts_> Peaker: ok, more accurately, you cannot make an impure value with unsafeInterleaveIO where as it is possible with unsafePerformIO
16:51:29 <dcoutts_> newsham: not a problem
16:51:32 <Peaker> dcoutts_, indirectly, you can
16:51:32 <tensorpudding> In any case, the one feature that Haskell has that almost no other language has is lazy evaluation by default.
16:51:53 <JoeyA> Why does this say "Prelude.read: no parse" when I give it a line with 2 numbers?  http://codepad.org/N9mVD3aS
16:52:01 <dcoutts_> Peaker: you can make non-deterministic IO actions, just like you can with forkIO
16:52:13 <Peaker> dcoutts_, in the IO monad, with unsafeInterleaveIO, you can make a value of a pure type be impure and expose evaluation order
16:52:14 <newsham> joeya: you messed up somehow :)
16:52:20 <newsham> what is a good example line?
16:52:21 <fax> JoeyA: it doesn't know to read integers
16:52:26 <JoeyA> 1 2
16:52:31 <fax> JoeyA: you need to use a type annotation somewhere
16:52:36 <Peaker> dcoutts_, e.g: lazy IO read of a socket, the other end can detect if someone is reading from it
16:52:38 <fax> e.g. [x,y::Integer] <- map read ...
16:52:40 <dcoutts_> Peaker: the value is always wrapped in IO
16:52:41 <newsham> > map read . words $ "1 2" :: [Int]
16:52:42 <lambdabot>   [1,2]
16:52:47 <JoeyA> What I guessed was this:
16:52:53 <tensorpudding> Ugh, I missed that gimpy left.
16:52:55 <JoeyA> [x,y] :: [Int,Int]
16:52:59 <Peaker> dcoutts_, d <- getContents ; "d" is no longer wrapped in IO
16:53:09 <dcoutts_> Peaker: no, it is still wrapped in IO
16:53:20 <Peaker> dcoutts_, the type of "d" is String
16:53:28 <dcoutts_> you're just using >>=, result is IO
16:53:51 <Peaker> dcoutts_, I can do:  fmap pureFunc getContents -- now pureFunc is getting a supposedly pure value
16:54:04 <Peaker> dcoutts_, but it's not really pure
16:54:10 <dcoutts_> Peaker: I can do the same with getRandom
16:54:16 <Peaker> @type getRandom
16:54:17 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
16:54:21 <dcoutts_> that's not what we mean by impure
16:54:39 <newsham> dcoutts: behavior will be a function of time.  sounds impure to me
16:54:39 <Peaker> dcoutts_, You have a value of type String -- it's no longer wrapped in IO when you give it to the fmap function
16:55:23 <newsham> extreme case, lets say that you use it on a synthetic file that returns a series of lines with the current datestamp
16:55:27 <Peaker> yet whether or not the pure function evaluates this pure String and what part of it, affects whether or not an effect (read from a socket, pipe, or what not, which is visible) happens
16:55:31 <dcoutts_> newsham: behaviour of IO actions can depend on the time, getTime
16:55:52 <Peaker> dcoutts_, getTime returns a pure value -- evaluating that pure value has no effect
16:55:54 <JoeyA> Why does this yield a parse error?  f :: String -> [Int,Int]
16:56:11 <mauke> [Int,Int] makes no sense
16:56:12 <Peaker> JoeyA, what do you mean by [Int,Int] ?
16:56:25 <JoeyA> It means the result is an array of 2 ints
16:56:29 <newsham> dcoutts: sure, but in this case you get [String] not [IO String]
16:56:30 <JoeyA> I guess I should have just done [Int]
16:56:39 <newsham> and which strings you get out will be a function of when you happen to read them
16:57:19 <Peaker> "IO a" is a license to be naughty BEFORE yielding "a".  Once "a" exists -- it must have pure semantics
16:57:34 <dcoutts_> once you look at the value it does not change
16:57:35 <Peaker> It cannot remain impure after it was given to the rhs of >>=
16:57:47 <Peaker> dcoutts_, that's not enough -- it must not matter whether I look at it at all
16:57:53 <Peaker> or when I look at it
16:58:06 <dcoutts_> why? it's all in IO
16:58:17 <dcoutts_> you can have non-deterministic IO actions
16:58:20 <dcoutts_> we have forkIO
16:58:22 <Peaker> The "a" yielded by "IO a" is no longer in IO
16:58:50 <dcoutts_> it is still in IO, it's inside a >>=
16:59:06 <c_wraith> Peaker, unsafeInterleaveIO would seem (at least to some extent) to violate that assertion
16:59:09 <dcoutts_> unsafeInterleaveIO returns in IO, that's why it is ok and unsafePerofmIO is not
16:59:15 <Peaker> dcoutts_, I got bitten it in practice, by for example:  do { h <- openFile ... ; d <- getContents ; closeFile h ; ... <use d purely> ...
16:59:24 <Peaker> c_wraith, exactly
16:59:31 <dcoutts_> Peaker: sure, don't write non-deterministic IO programs, they're confusing
16:59:41 <Peaker> dcoutts_, Consider:
17:00:01 <c_wraith> There are cases where unsafeInterleaveIO is fine.  I don't think reading from arbitrary files is one of them.  So I don't use APIs that use that.
17:00:01 <Peaker> dcoutts_, do { openFile ; d <- getContents ; let res = computeResult of d ; closeFile ; ... is <res> safe? }
17:00:20 <kmc> tl;dr: lazy IO is evil
17:00:35 <dcoutts_> Peaker: that's a non-determinisic IO action, it has a perfectly sensible semantics
17:00:51 <dcoutts_> kmc: which is a different argument from saying it is impure
17:01:03 <Peaker> dcoutts_, purity means: A) Won't change once you see it  B) Won't matter if/when you evaluate it.   unsafePerformIO might violate both.  unsafeInterleaveIO only violates B
17:01:35 <dcoutts_> kmc: lazy IO can be confusing because it is non-deterministic, it's exactly the cases where the non-determinism does not make any difference that lazy IO is useful
17:01:57 <dcoutts_> Peaker: we're using different definitions of purity then
17:02:00 <Peaker> dcoutts_, the semantics of "res" in my example above depend on whether or not pure functions evaluated their argument, or how deep
17:02:20 <Peaker> dcoutts_, Say you print (someFunc res)   just before the close
17:02:20 <kmc> if you're worried about errors then almost any IO operation is non-deterministic
17:02:49 <c_wraith> well, the worry is about errors happening after the handoff to >>=
17:02:50 <Peaker> dcoutts_, Whether or not "res" is safe to use after the close  -- depends on how much of "res" was evaluated/forced by someFunc, which is pure
17:03:26 <Peaker> Change a completely pure part of your program one day -- and boom, it breaks. Suddenly you read from a closed file
17:03:44 <Peaker> changing a pure part of the program -> breaks the order of effects...
17:03:54 <dcoutts_> Peaker: the observed value of "res" depends on other IO actions, you can do similar things with randomness or forkIO concurrency.
17:04:07 <Peaker> dcoutts_, It also depends on pure computations
17:04:13 <JoeyA> "<fax> e.g. [x,y::Integer] <- map read ..."  Thanks, but it requires that I enable the -XScopedTypeVariables parameter.
17:04:16 <JoeyA> Is there another way?
17:04:26 <kmc> map (read :: String -> Integer) ...
17:04:28 <Peaker> dcoutts_, (hey, maybe even enabling optimizations would break it)
17:04:34 <JoeyA> I tried [x,y] :: [Int] first, but it says they're out of scope (even though it's the next line of the do block)
17:04:38 <dcoutts_> Peaker: which is allowed
17:04:54 <kmc> JoeyA, yeah.  the scope issue makes sense when you consider that "do" desugars into (>>=)
17:05:03 <dcoutts_> Peaker: optimisations can change thread scheduling, it's all allowed by a non-deterministic semantics
17:05:21 <Peaker> dcoutts_, But I'm talking about the pure part of the program
17:05:30 <JoeyA> What if I do this?  ([x,y]::Int; [x,y] <- map read . words <$> getLine)
17:05:32 <pikhq> JoeyA: ([x,y] :: [Integer]) <- map read -- Maybe?
17:05:34 <JoeyA> I get a parse error on the ;
17:05:35 <dcoutts_> Peaker: no, you're still talking about IO actions
17:05:40 <c_wraith> Peaker: really, this boils down to "don't use things implemented in terms of unsafeInterleaveIO"
17:05:46 <Peaker> When I take a "String", in Haskell, I really expect it to be a simple list of chars.. I don't expect it to affect my program's semantics whether I evaluate it before another string, or after
17:05:49 <kmc> JoeyA, i'd use map (read :: String -> Integer)
17:06:08 <dcoutts_> it boils down to: be careful with non-deterministic programs (eg concurrency and lazy IO)
17:06:15 <kmc> JoeyA, but also, if you use x and y later in a way that constrains them to Integer, it won't be necessary
17:06:19 <newsham> arguing semantics
17:06:20 <JoeyA> Thanks
17:06:29 <pikhq> JoeyA: do x <- y; desugars down to "y >>= \x -> ..."
17:06:42 <kmc> but that might be less clear
17:06:45 <Peaker> dcoutts_, imagine 2 calls to getContents, yielding "d" and "e".  I give "d" and "e" to a pure function. Whether it evaluates d or e first affects program semantics.  If I change (f d + f e) to (f e + f d), I get a different behavior, despite (+) supposedly being cummutative (in my pure part)
17:06:51 <JoeyA> pikhq> Thanks, makes sense
17:07:02 <dcoutts_> Peaker: and yet the semantics of your program can change depending on if / how much you evaluate when using forkIO too, but you don't call that unsafe
17:07:14 <fax> When I see puzzles like sudoku or 'logic mazes' or any of that sort of thing I don't want to solve them
17:07:15 <Peaker> dcoutts_, Can you give an example?
17:07:18 <dcoutts_> Peaker: erm I mean the behaviour, not the semantics. The semantics allows either behaviour.
17:07:26 <fax> All I can think is "it would take 2 mins to write a program to solve these"
17:07:31 <fax> that is what learning programming has done
17:07:34 <Peaker> dcoutts_, How can changing the *pure* part of the program affect the behavior with forkIO?
17:07:41 <Phyx-> wow, alot of different topics at once.. *gets dizzy trying to follow the conversations*
17:07:45 <JoeyA> kmc: Thanks, (read :: String -> Integer) works beautifully..
17:07:47 <dcoutts_> Peaker: if you evaluate something or not, then that changes timing which can change scheduling and thus results.
17:07:54 <JoeyA> However, I still want to know why I can't do this:  ([x,y] :: [Int]; [x,y] <- map read . words <$> getLine)
17:07:54 <Peaker> fax, It won't take long, but considerably more than 2 min, to write a soduko solver :)
17:07:58 <JoeyA> It yields a parse error
17:08:08 <kmc> JoeyA, because type signatures are not part of the syntax of a "do" block
17:08:14 <fax> JoeyA, did you try what I suggested
17:08:28 <dcoutts_> Peaker: the way to look at it is in terms of possible traces of IO events
17:08:45 <kmc> a "do" block is a ;-separated list of statements.  each statement is of the form "e", "x <- e", or "let ..."
17:08:49 <kmc> not "x :: t"
17:09:02 <kmc> @undo do { x <- e; f x }
17:09:03 <lambdabot> e >>= \ x -> f x
17:09:04 <dcoutts_> Peaker: forkIO says the IO events of the forked thread can interleave arbitrarily with those of the main thread (constrained possibly by some synchronisation)
17:09:17 <kmc> JoeyA, "do" is just sugar for using this >>= operator.  and it's not clear how the type signature would work in that sugar
17:09:30 <kmc> it *is* relatively clear how "(x :: t) <- e" would work
17:09:43 <JoeyA> fax> Yes, but it requires the -XScopedTypeVariables switch.
17:09:49 <kmc> as e >>= \(x :: t) -> ...
17:09:53 <kmc> but that requires an extension as you noted
17:09:55 <Peaker> dcoutts_, well, indeed, if you measure resource use -- then pure evaluation has observable side effects
17:10:00 <fax> JoeyA, so?
17:10:08 <dcoutts_> Peaker: the semantics of interleaveIO is pretty similar, the IO events interleave arbitrarily. Results can change depending on the actual interleaving.
17:10:13 <Peaker> dcoutts_, I take that point -- usually though resource use is considered an "invisible" side effect
17:10:52 <Peaker> dcoutts_, if you ignore the visibility of resource use and avoid unsafeInterleaveIO/performIO -- then changing your pure part cannot change behavior
17:11:07 <Peaker> dcoutts_, if you add measurement of resource use, OR unsafeInterleaveIO, then changing the pure part can affect visible behavior
17:12:12 <dcoutts_> Peaker: and forkIO makes observation inevitable
17:12:24 <Peaker> by "changing your pure part", btw, I meant just changing evaluation order
17:12:29 <JoeyA> So in [x,y] <- map (read :: String -> Integer) . words <$> getLine  , how does (read :: String -> Integer) work?
17:12:38 <AmunRa> Hello! I'm struggling to create a ".so" lib from my haskell code. `ghc -fPIC -shared -o foo.so foo.hs` errors with: "function main is not defined in module Main"
17:12:40 <kmc> JoeyA, the syntax is (e :: t) for e an expression and t a type
17:12:51 <JoeyA> If a type signature is given in place of a function, does it cast that function to that type?
17:12:52 <kmc> JoeyA, it's just a hint to the compiler that e has type t
17:12:55 <dcoutts_> Peaker: to be deterministic we must eliminate forkIO and unsafeInterleaveIO, which makes sense given their semantics in terms of sets of possible event traces are pretty similar.
17:12:56 <AmunRa> has anyone tried to do this before?
17:12:59 <kmc> it's not really a cast in the C sense
17:13:02 <Peaker> dcoutts_, not if you assume forkIO is non-deterministic anyway -- it will change because of the underlying platform, temperature, or what not
17:13:05 <kmc> you're asserting a fact that had to be true anyway
17:13:08 <kmc> but you can assert something more specific
17:13:12 <JoeyA> oh
17:13:20 <kmc> in this case, (read :: String -> Integer) instead of (read :: (Read a) => String -> a)
17:14:16 <Peaker> dcoutts_, forkIO is just non-deterministic, not really determined by evaluation order per-se.  It doesn't break correct programs to change evaluation order.  With unsafeInterleaveIO, changing eval. order of pure part does break programs
17:14:36 <JoeyA> AmunRa> I'm a super Haskell newbie, but first of all, are you sure you don't have module Main written in foo.hs ?
17:15:30 <AmunRa> well.. JoeyA.. that's the point.. if I'm creating a ".so" then I don't need a main function
17:15:37 <pikhq> AmunRa: The flags you want are "-fPIC -no-hs-main -optl -shared"
17:15:44 <JoeyA> Nor do you need a main Module.
17:16:06 <pikhq> I *presume* you're creating a .so file with exported C functions.
17:16:09 <JoeyA> That's why I asked: are you sure you didn't write module Main (not a function definition, a module name) at the top of foo.hs ?
17:16:20 <mauke> JoeyA: what
17:16:32 <pikhq> JoeyA: What? Shaddup.
17:16:33 <mauke> if you don't write anything, it's like 'module Main (main) where'
17:16:34 <dcoutts_> Peaker: you mean forkIO programs that are specially constructed to be essentially deterministic
17:16:39 <Peaker> dcoutts_, I think that line of logic is dangerous:  IO is non-deterministic -> All pure values are yielded by non-deterministic IO actions -> As long as pure values memoize, everything is "pure" and it's OK for all pure evaluation to have any effect we want -- it's just the IO non-determinism at play
17:16:41 <JoeyA> okay :)
17:16:56 <AmunRa> pikhq, yes.. well. that's the next step.. first one is to make sure I can compile something :-) exposing haskell to C++ is my aim eventually
17:16:58 <Peaker> dcoutts_, Yeah -- that should include all programs that use forkIO (in reality, it of course does not)
17:17:22 <pikhq> AmunRa: You are not exposing Haskell to C++ in any way other than by way of C.
17:17:31 <dcoutts_> Peaker: I think it's just that people find the kind of non-determinism in interleaveIO to be more confusing than the kind you get from forkIO, since the scheduling behaviour is so different
17:17:31 <AmunRa> pikhq, correct
17:18:15 <pikhq> C++ has an ABI that, outside of its own lightweight C ABI, is *not* going to be interacted with by anything other than C++.
17:18:43 <pikhq> Well. And the occasional absolutely bonkers C or assembly programmers.
17:18:53 <pikhq> s/programmers/programmer/
17:19:24 <AmunRa> well.. if I 'export "C"' the key things I need haskell to understand I should be fine.. right?
17:19:24 <twink> pikhq: C++ has a tough enough time interoperating with it that I doubt much of anything else will try.
17:20:06 <twink> pikhq: ld.so contributors appear sane enough to me.
17:20:10 <Peaker> dcoutts_, I just find unsafeInterleaveIO betrays the Haskell way of doing it the "right way", even if it is tough.. I find it exposes evaluation order in a more significant/brutal way than resource measurements (especially really indirect ones such as forkIO) does
17:20:11 <tensorpudding> This channel talks about C++ too often.
17:20:19 <lispy> C++ has a hard time interoperating with other C++ :)
17:20:35 <dcoutts_> Peaker: note that imprecise exceptions do the same: http://www.mail-archive.com/haskell@haskell.org/msg21793.html
17:20:49 * twink doesn't really do enough with C++ to talk about it much.
17:21:01 <mauke> preflex: karma C
17:21:01 <preflex>  C: 78145
17:21:04 * twink mostly does C, and since that's all work, I'm glad enough to forget about it.
17:21:08 <kmc> but imprecise exceptions expose evaluation order to IO results
17:21:16 <kmc> not to pure code
17:21:33 <Peaker> dcoutts_, Yeah, partiality sucks too
17:22:06 <Peaker> dcoutts_, To solve that you really need to go DT, it seems (and I'm all for it..). To solve the lazy IO problem, I want something like Iteratee. To solve the partiality problem, DT's
17:22:15 <AmunRa> pikhq, those flags didn't seem to help...
17:22:25 <kmc> ghc -XAgda
17:22:54 <pikhq> "ghc --make -no-hs-main -optl -shared -fPIC -o foo.so foo.hs" ought to work?
17:23:29 <JoeyA> Suppose I want to read/process lines from a file, and the first line tells me how many lines are after it.  Does Haskell have a syntactic sugar function for an imperative-style for loop, or should I just use recursion?
17:23:32 <dcoutts_> Peaker: seems to me the solution is simple, don't write non-deterministic programs. We try to avoid/limit it for concurrent programs. We should do the same with lazy IO, that is only use it where the non-determinism does not matter / have (usually) any effect on the result.
17:23:53 <mauke> JoeyA: forM_
17:23:54 <kmc> JoeyA, not sugar.  just an ordinary function
17:23:56 <kmc> :t forM_
17:23:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:24:01 <lispy> I was really impressed with some agda code glguy showed me today  where he proved the monad laws for the monad he defined.
17:24:04 <kmc> forM_ [1..20] $ \x -> do ...
17:24:14 <Peaker> dcoutts_, I disagree that it's on the same page as forkIO... With forkIO, pure computation changes does not add any new non-determinism
17:24:16 <lispy> I wish we could do that for haskell!
17:24:35 <JoeyA> What does the $ do?
17:24:37 <Peaker> dcoutts_, with unsafeInterleaveIO, I must be actively careful about evaluation order, that sucks!
17:24:37 <kmc> :t ($0
17:24:38 <kmc> :t ($)
17:24:38 <lambdabot> parse error (possibly incorrect indentation)
17:24:39 <lambdabot> forall a b. (a -> b) -> a -> b
17:24:40 <kmc> @src ($)
17:24:40 <lambdabot> f $ x = f x
17:24:54 <lispy> JoeyA: it's the identity function specialized to the function type
17:24:57 <AmunRa> JoeyA, there are higher functions that you can use.. such as map or fold
17:25:04 <kmc> JoeyA, (f $ x) is just (f x).  but ($) has low precedence, so (f $ g $ h $ x) is (f (g (h x)))
17:25:09 <kmc> though we'd rather write (f . g . h $ x)
17:25:12 <AmunRa> pikhq, nope.. didn't
17:25:16 <JoeyA> Ah
17:25:17 <twink> JoeyA: New to Haskell? ($) is application. basically what everyone else said.
17:25:17 <Peaker> I can (barely) take being actively careful about evaluation order -- when it comes to improving performance
17:25:21 <dcoutts_> Peaker: take a look at this thread http://www.mail-archive.com/haskell@haskell.org/msg21782.html
17:25:22 <JoeyA> Yes I am
17:25:24 <pikhq> AmunRa: Compile error = ?
17:25:30 <AmunRa> same
17:25:40 <JoeyA> $ is essentially a do-nothing, right?  (except it tweaks the order of operations)
17:25:46 <kmc> f $ x = f g
17:25:47 <kmc> err
17:25:48 <kmc> f $ x = f x
17:25:54 <JoeyA> So composition is easier
17:25:56 <pikhq> JoeyA: Normally, yes.
17:26:05 <Peaker> dcoutts_, thanks, reading..
17:26:08 <JoeyA> I ran into that with things like (putStrLn.show) (x*y)
17:26:14 <pikhq> You can do fun things with partially applying it. :P
17:26:37 <JoeyA> I'm glad to know I can do `putStrLn . show $ x*y`
17:27:14 <kmc> btw, (putStrLn.show) = print
17:27:14 <mauke> print $ x*y
17:27:17 <twink> Well, putStrLn . show is in the libs already as print
17:27:27 <kmc> glorious stereo
17:29:25 <lispy> JoeyA: yes, when ($) is used, you can actually replace it with the identity function not counting syntax
17:29:56 <AmunRa> ha.. realised it was a product of my own stupidity (as usual) forgot "module Foo (..) where" bit.. it's an improvement... I get relocation errors now :-)
17:31:42 <dcoutts_> Peaker: and here's a more detailed one about the trace semantics http://haskell.org/pipermail/haskell-prime/2009-October/003039.html
17:32:05 <JoeyA> What does () mean ? (nothing inside the parens)
17:32:17 <kmc> the type named () has only one value, also named ()
17:32:18 <kmc> :t ()
17:32:19 <lambdabot> ()
17:32:26 <kmc> it's a sort of "useless type"
17:32:29 <tensorpudding> () is a boring value
17:32:32 <lispy> JoeyA: that's the type unit
17:32:32 <AmunRa> JoeyA, it's the "Unit" type
17:32:49 <AmunRa> i.e. "void" it many other languages
17:32:54 <lispy> () can also represent an empty type class context
17:32:58 <JoeyA> oh
17:33:03 <Peaker> dcoutts_, Well, if I understand the replies correctly, then using memoized pure values everywhere means referential transparency is never broken -- because you could always say the IO action that yielded the memoized value "looked into the future" or what not
17:33:19 <tensorpudding> the type of main is often given as IO ()
17:33:21 <JoeyA> Suppose in C, you could do this:  int main(void, void)
17:33:26 <JoeyA> err, int foo(void, void)
17:33:33 <tensorpudding> which means that it does IO, but has no interesting return value.
17:33:33 <JoeyA> Would () be like those voids?
17:33:35 <dcoutts_> Peaker: "looking into the future" is one way to think about non-deterministic semantics
17:33:41 <lispy> JoeyA: yes
17:33:47 <tensorpudding> kinda
17:33:58 <JoeyA> Oh, so it means the enclosing do function doesn't have to return a value, correct?
17:34:01 <lispy> JoeyA: but in C, I don't think that's valid (you'd need a pointer to a void)
17:34:06 <JoeyA> :t forM
17:34:07 <tensorpudding> in void functions you don't have a return statement
17:34:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:34:08 <JoeyA> :t forM_
17:34:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:34:11 <dcoutts_> Peaker: any observed interleaving is one of the interleavings that the semantics allowed.
17:34:21 <lispy> JoeyA: but, the Haskell analog of void * is more complex than ()
17:34:34 <tensorpudding> if you wrote a function in haskell with type IO (), you would still have to explicitly do'return ()' at the end
17:34:58 <tensorpudding> using do notation, that is
17:35:01 <JoeyA> What's the difference between forM and forM_
17:35:16 <lispy> the returned type
17:35:18 <dcoutts_> Peaker: you might complain that the implementation of this interleaving is more demonic than the usual interleavings you get from forkIO
17:35:24 <Peaker> dcoutts_, it's a cheap cop-out, IMO, because just by taking "unsafePerformIO :: IO a -> a", and converting it to: unsafePerformIO' :: IO (IO a) -> IO a  -- making sure the "a" is memoized, and having to put it somewhere in "main" rather than in a globally pure value -- means I never break referential transparency
17:35:25 <dolio> It doesn't even have to look into the future. It may return a 'random' result that just happens to coincide with whatever evaluation strategy gets used in practice.
17:35:26 <tensorpudding> functions with _ at the end are run for their side-effects, and ignore the return type
17:35:27 <JoeyA> It appears one must return an array of some sort, while the other doesn't.
17:35:39 <lispy> JoeyA: monadic things with _ at the end of the name ignore the intermediate results
17:35:46 <kmc> JoeyA, lists aren't arrays
17:35:48 <tensorpudding> @type sequence_
17:35:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:35:54 <JoeyA> I mean list, sorry
17:35:54 <tensorpudding> @type sequence
17:35:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:35:59 <JoeyA> Every time I see [], I think array.
17:36:04 <Peaker> @type fmap unsafePerformIO
17:36:04 <dcoutts_> Peaker: yes, pretty much.
17:36:05 <lambdabot> Not in scope: `unsafePerformIO'
17:36:10 <Peaker> @type fmap System.Unsafe.unsafePerformIO
17:36:11 <lambdabot> Couldn't find qualified module.
17:36:27 <tensorpudding> in the example of sequence_, it runs the sequences monadic actions in order, and ignores the return values of the actions
17:36:32 <Peaker> dcoutts_, Well, then "purity" doesn't amount to much
17:36:33 <kmc> JoeyA, the type () is the "boring type" with only one value.  so the type IO () is the type of IO-recipes which, when executed, produce the boring value
17:36:38 <kmc> but they can still do IO
17:36:39 <tensorpudding> whereas in sequence, it collates a list of the returned values
17:36:43 <kmc> so IO () is a much more interesting type than ()
17:37:01 <aavogt> @type fmap System.IO.Unsafe.unsafePerformIO
17:37:03 <lambdabot> forall a (f :: * -> *). (Functor f) => f (IO a) -> f a
17:37:10 <Peaker> dcoutts_, Which reminds me of "C is a pure language" by Conal
17:37:33 <JoeyA> Oh, and since m is a monad in the context above, m () is more generic than IO (), right?
17:37:41 <tensorpudding> Yes.
17:37:44 <kmc> yes
17:37:54 <kmc> sequence_ works for any monad
17:37:57 <kmc> @src sequence_
17:37:57 <dcoutts_> Peaker: but if I summarise it the other way, you're just saying that non-deterministic IO programming is confusing, and I agree! :-)
17:37:57 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:38:10 <kmc> JoeyA, if you like:  sequence_ [] = return (); sequence_ (x:xs) = do { x; sequence_ xs }
17:38:24 <Peaker> dcoutts_, The "pure part" of our program which is not based on "globals" but *any* input from IO does not benefit at all from any argument for purity
17:38:34 <Peaker> dcoutts_, because all of IO is allowed to be non-deterministic
17:38:35 <kmc> sequence [] = return []; sequence (x:xs) = do { y <- x; ys <- sequence xs; return (y:ys) }
17:38:48 <Peaker> dcoutts_, everything might be using fmap unsafePerformIO, and the compiler doesn't verify it isn't
17:38:50 <tensorpudding> although sequence_ is probably useless in monads that don't involve side-effects, like [] and Maybe
17:38:50 <newsham> peaker: no, most IO is linearized by >>=
17:38:57 <newsham> as opposed to the lazy IO stuff whic hisnt
17:38:59 <kmc> it's useful in Maybe
17:39:03 <kmc> it's like any isNothing
17:39:08 <dcoutts_> Peaker: your pure functions are still pure, your IO actions allow for non-determinism
17:39:18 <kmc> JoeyA, note the technique of passing around monadic actions as values and executing them when and only when we want
17:39:19 <Peaker> newsham, I mean that type-wise, unsafeInterleaveIO or fmap unsafePerformIO -- both of which don't break "purity" -- can lurk anywhere
17:39:27 <aavogt> @type any isNothing
17:39:28 <lambdabot> forall a. [Maybe a] -> Bool
17:39:42 <Peaker> dcoutts_, But since my "pure" functions are fed non-deterministic values by definition, any determinism they themselves have -- gives me almost no benefit
17:39:48 <kmc> hmm, sequence_ doesn't give you the result though
17:39:52 <kmc> :t foldr1 (>>)
17:39:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
17:40:00 <Peaker> dcoutts_, I think it kills the entire argument for purity in the first place -- that kind of a Haskell world has no significant advantage
17:40:01 <kmc> maybe that instead
17:40:01 <tensorpudding> sequence_ on a list of Maybe a's will return a Just (), not a Bool.
17:40:10 <newsham> peaker: i'm playing devils advocate, mostly i am on your side.  "no benefit"?  still great for testing and proving
17:40:12 <tensorpudding> or will it return Nothing?
17:40:22 <kmc> it'll return Nothing iff any of them was Nothing
17:40:25 <aavogt> > sequence [Just 5, Nothing]
17:40:25 <dcoutts_> Peaker: it doesn't, it just suggests that writing non-deterministic programs is a bad idea
17:40:26 <kmc> that's why i said "like"
17:40:26 <lambdabot>   Nothing
17:40:29 <aavogt> > sequence_ [Just 5, Nothing]
17:40:30 <lambdabot>   Nothing
17:40:34 <kmc> > sequence [Just 3, Just 4]
17:40:35 <lambdabot>   Just [3,4]
17:40:38 <kmc> > sequence_ [Just 3, Just 4]
17:40:39 <lambdabot>   Just ()
17:40:39 <Peaker> dcoutts_, The type system does not help me write deterministic programs
17:40:49 <tensorpudding> Just () is a boring value, but it is distinct from Nothing
17:40:54 <dcoutts_> Peaker: it does, it distinguishes IO from non-IO
17:41:02 <kmc> @check \xs -> any isNothing xs == isNothing (sequence xs)
17:41:04 <lambdabot>   "OK, passed 500 tests."
17:41:24 <Peaker> dcoutts_, but virtually all non-IO is based on inputs from IO, which are hiding effects/non-determinism within them
17:41:28 <JoeyA> Does Haskell have a forM_-like function that takes a min and max (or just a count) and calls a function?
17:41:41 <kmc> JoeyA, use [a..b] syntax
17:41:43 <JoeyA> Or do I do that myself with [0 .. x-1] ?
17:41:43 <fax> > any isNothing [] == isNothing (sequence [])
17:41:45 <lambdabot>   True
17:41:45 <kmc> yeah
17:41:48 <dcoutts_> Peaker: which is why we try to write deterministic IO programs
17:41:57 <kmc> or if you don't like the sugar, enumFromTo
17:41:59 <mauke> JoeyA: count is replicateM_
17:42:15 <kmc> > forM (enumFromTo 1 10) $ \x -> Just ()
17:42:16 <lambdabot>   Just [(),(),(),(),(),(),(),(),(),()]
17:42:18 <tensorpudding> @type replicateM_
17:42:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
17:42:34 <Peaker> dcoutts_, But then the type-system-helps-us-with-the-pure-part argument is pretty much a lie, because if the program is contaminated by one misplaced unsafeInterleaveIO, the pure part will behave non-deterministically too
17:42:35 <kmc> JoeyA, also remember that if any control-flow function like forM is missing, you can write it yourself
17:42:39 <kmc> but it is good to know the standard lib
17:42:45 <JoeyA> okay
17:42:58 <aavogt> hence the `unsafe' there, Peaker
17:43:12 <kmc> forM_ [] f = return (); forM_ (x:xs) f = do { f x; forM_ xs f }
17:43:13 <dcoutts_> Peaker: you're still confusing >>= \x ->  with purity
17:43:19 <fax> any isNothing (x:xs) == isNothing x && any isNothing xs == isNothing (x >>= \a -> sequence xs >>= \as -> return (a:as)) == isNothing (sequence xs)
17:43:31 <fax> :/
17:43:43 <fax> the gap is too big
17:43:49 <Peaker> dcoutts_, and there is a real qualitative difference between forkIO and unsafeInterleaveIO here, as I said earlier -- they don't just both inject non-determinism.  unsafeIIO injects a *deterministic* reliance on evaluation order, not just random non-determinism
17:43:55 <tensorpudding> @type forM
17:43:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:44:22 <tensorpudding> @type forM_
17:44:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:44:42 <tensorpudding> hmm, is there something like do-while
17:45:06 <aavogt> Peaker: evaluation order is not deterministic
17:45:16 <aavogt> or it doesn't have to be
17:45:30 <Peaker> Now I understand Conal's perspective on IO so much better!  I always thought Conal is exaggerating, because we still have our sanctuary in the large pure part of our program.  But now I see there is no sanctuary -- we're allowed to forgo our most basic assumptions on the pure part too, by simply claiming that the IO semantics are weird enough to strangely "coincide" with whatever the evaluation yielded
17:45:51 <dcoutts_> Peaker: I agree it's more confusing. I simply claim that the semantics allows both and that we should be careful with non-determinism.
17:45:56 <pokoko222> anyone has read "Joel on Software" ?
17:46:05 <JuanDaugherty> y
17:46:27 <Peaker> dcoutts_, Yes, I now realize IO semantics allow enough "strangeness" to destroy the benefit of the purity in the pure part
17:46:35 <JuanDaugherty> but only recall the name/web presence
17:46:41 <Peaker> dcoutts_, Makes me even more against unsafeInterleaveIO :-)
17:47:12 <dcoutts_> Peaker: did you read the last link I posted? I think that fairly clearly explains the view I was taking.
17:47:39 <JoeyA> forM [] f = return []; forM (x:xs) f = do { y <- f x; ys <- forM xs f; return (y:ys) }
17:47:41 <JoeyA> Is that correct?
17:47:44 <Peaker> dcoutts_, missed it, will read now
17:48:00 <mauke> @src forM
17:48:00 <lambdabot> forM = flip mapM
17:48:11 <pokoko222> JuanDaugherty good or just good marketing?
17:48:22 <mauke> JoeyA: yes
17:48:33 <JuanDaugherty> not really relevant to anything here sfaict
17:48:55 <JuanDaugherty> (and I didn't say anything about "good")
17:49:01 <Peaker> dcoutts_, btw, in what scenario/case does the non-determinism of unsafeIIO *not* make a difference to the results?
17:49:20 <JuanDaugherty> */ct/can remember/
17:49:34 <dcoutts_> Peaker: when the interleavings of events make no difference to the calculated results
17:50:44 <Peaker> dcoutts_, does this ever happen for something like unsafeInterleaveIO?
17:50:51 <Peaker> (with a file read, for example)
17:51:16 <aavogt> @src interact
17:51:17 <lambdabot> interact f = do s <- getContents; putStr (f s)
17:51:19 <dolio> How often does it *not* happen?
17:51:24 <dcoutts_> Peaker: eg readFile when no other agent is writing to it
17:52:01 <dcoutts_> Peaker: similar conditions to "well constructed forkIO programs", non-interference of events
17:52:19 <Peaker> dcoutts_, how can you ever know no-one else is writing to it?
17:52:35 <Peaker> Files can never have a guarantee of non-interference, unlike MVars
17:52:40 <dcoutts_> Peaker: good question
17:52:42 <JuanDaugherty> pokoko222, when in doubt, pity a fool
17:52:56 <dcoutts_> Peaker: if you have to worry about that, then don't use it
17:53:05 <pokoko222> JuanDaugherty i pity your mom
17:53:14 <Peaker> dcoutts_, I think this holds true for all cases of "getContents" -- so I don't think there's a case for which it isn't broken
17:53:23 <JuanDaugherty> :(
17:53:42 <dcoutts_> Peaker: I disagree, there are many simple cases where it's fine, where you really have to assume nobody else is interfering anyway
17:54:28 <dcoutts_> Peaker: where you could do it more explicitly but you're no better off when someone changes something behind your back, it's still violating an assumption of your program and it'll calculate some "wrong"/"inconsistent" result
17:54:42 <dolio> Peaker: How do you trust strict getLine, then? Depending on how your program is scheduled, outside agents writing to the same file may produce different results.
17:54:58 <Peaker> dolio, evaluation order won't interact with it
17:55:06 <dcoutts_> Peaker: eg think of calculating a line count, you can do it with explicit IO but if someone else is modifying the file concurrently you're still going to get screwy results
17:55:55 <dolio> Evaluation order is a red herring in that case.
17:56:30 <fryguybob> Anybody use the hs-dotnet package?  I'm getting COM error: 0x80070002 when I try to run any of the examples.
17:56:48 <dolio> The problem with IO executing due to evaluation order is that your program, on its own, gets nondeterministic results if it operates on the same resource lazily.
17:57:26 <JoeyA> What's the difference between Int and Integer?
17:57:35 <dolio> Any IO at all has nondeterminism problems if you consider agents external to your program being able to modify things behind your back.
17:57:35 <Peaker> dcoutts_, At least with strict IO I'll know how my program will behave after the file is read
17:58:01 <Peaker> Regardless of what other agents will do
17:58:23 <Peaker> so I am still screwed, but for a much more limited amount of time -- which might be important
17:58:37 <dcoutts_> Peaker: right, I see it as what level of detail you want. The point is, there are cases where "it doesn't matter"
17:58:37 <aavogt> is this like knowing that you have  a random number * 5
17:59:19 <Peaker> dcoutts_, It may seem not to matter -- but there are also more subtle effects like maximum fd counts
17:59:22 <aavogt> instead of some other random number (whose distribution is also unknown)
17:59:28 <dcoutts_> Peaker: there are certainly cases where you do care and you do want to go right down to the low level of detail, eg network servers care a lot.
18:01:20 <Peaker> dcoutts, there's also the non-determinism of the possibility of error, which a pure value cannot account for.. what program wants to ignore that?
18:01:24 <dolio> The only way to really eliminate the problem entirely is to have the OS support some kind of immutable view of the relevant system resources.
18:01:33 <dolio> (Which isn't something I'd necessarily be against.)
18:01:45 <Peaker> dolio, What about banning unsafeInterleaveIO?
18:01:59 <aavogt> dolio: copy on write filesystems?
18:02:05 <dolio> Peaker: That doesn't get rid of the problem of other programs changing things out from under you.
18:02:07 <dcoutts_> Peaker: we have imprecise exceptions
18:02:21 <Peaker> dcoutts_, We need to ban those too, but that's a little harder :)
18:02:42 <aavogt> what is the alternative?
18:02:51 <aavogt> (to imprecise exceptions)
18:02:55 <dcoutts_> Peaker: except that they're enormously useful, otherwise you get no info about exceptions from pure code.
18:02:59 <Peaker> dolio, I'm more worried about the part where you have to be careful to evaluate pure things correctly
18:03:16 <Peaker> dcoutts_, There just shouldn't be any exceptions in pure code :)
18:03:44 <Peaker> dcoutts_, pass proofs required to avoid the exceptional situations
18:04:44 <dcoutts_> Peaker: there is if you pass _|_ in to pure code that is strict
18:04:58 <Peaker> dcoutts_, there shouldn't be a _|_
18:05:26 <dolio> Languages without _|_ aren't ready yet, though.
18:05:36 <dcoutts_> Peaker: then hope you don't have any IO errors :-)
18:05:38 <Peaker> dcoutts_, Or at least, the type with _|_ should be different from that without
18:06:01 <dcoutts_> Peaker: you can do similarly with storing IO results in eg MVars and passing them to pure code, it's not so weird
18:06:22 <dcoutts_> Peaker: all types in Haskell have a _|_
18:06:22 <Peaker> Anyway, I think if everyone was forced to use Iteratee for everything, it would accelerate the kind of changes needed everywhere to make it just as usable as unsafeInterleaveIO, but without the problematic reliance on evaluation order
18:06:58 <Peaker> Just like being forced to remain faithful to purity due to laziness yielded the discovery of the IO monad, long after most language researchers would have given up on the notion of purity
18:07:36 <Peaker> I am not sure what advantage unsafeInterleaveIO has over Iteratee, except for a bit more Prelude support
18:08:29 <dcoutts_> at the moment it's considerably easier to use
18:08:41 <Peaker> dcoutts_, Because people are using it, rather than Iteratee
18:08:43 <dolio> I need to get around to learning the iteratee stuff one of these days.
18:08:58 <dcoutts_> I agree that we should explore reliable ways of doing IO that can give sensible resource guarantees
18:09:01 <Peaker> dcoutts_, that's what I meant by Prelude support
18:09:11 <aavogt> lazy IO is simpler
18:09:29 <Peaker> conal, hey.. I just got a new perspective on the problematicness of IO
18:09:44 <Peaker> aavogt, in the same sense not separating pure code from non-pure code is simpler
18:09:55 <conal> Peaker: yeah?
18:10:14 <aavogt> I don't see that analogy
18:10:29 <dcoutts_> Peaker: it's a bit more than just prelude support, last time I looked at the iteratee stuff it did not pass the "can I explain this to an undergraduate" test
18:10:44 <dcoutts_> Peaker: but I agree that it should be improved and simplified
18:10:50 <Peaker> conal, I realized that the claim that unsafeInterleaveIO doesn't break referential transparency (and thus: "purity") is correct, but that it is based on a reasoning trick -- where you can assign the blame for dependence on evaluation order to the "unsafeInterleaveIO" that generated the pure value in the first place, and claim it looked into the future to do so (after all, it's in IO, it's OK!)
18:11:03 <Peaker> dcoutts_, I'm an undergraduate :)
18:11:31 <dcoutts_> Peaker: ah but you're in the 10% who embraced Haskell :-)
18:12:10 <Peaker> conal, so when you use unsafeInterleaveIO anywhere (which the type system doesn't help you with), your pure part can behave strangely, and it's "justified" because it was fed inputs from unsafeInterleaveIO
18:12:37 <Peaker> so the blame for the weirdness is not that the pure part is impure, it's that the impure part outside looked into the future and decided how to act accordingly
18:12:38 <dolio> Wow, these types are something.
18:12:46 <conal> Peaker: that trick seems to be a standard one.  used to explain exceptions also.  if we can attach something to IO, we say it's okay because IO can do unexplained/unexplainable things.
18:13:20 <conal> i think simon pj said "whatever we don't understand, we toss into IO".
18:13:21 <Peaker> conal, the "strangely coincides with evaluation order, but not necessarily *caused* by it" is what I missed earlier
18:13:40 <Peaker> conal, The way to explain how evaluation still has no effect with unsafeInterleaveIO
18:13:51 <conal> Peaker: ditto for exceptions, iiuc.
18:14:03 <conal> Peaker: i don't buy that reasoning at all.
18:14:51 <conal> Peaker: what's the source of that quote ("strangely coincides ...")?
18:14:55 <Peaker> It reenforces the importance of explaining IO as well. I previously thought that since we can narrow IO down to a tiny part of the program, it's not that important.. But now that that tiny part can be assigned blame for effects/weirdness in the huge rest of the program, it becomes much more important
18:15:12 <newsham> conal: no blog since jan 21?
18:15:13 <dcoutts_> I think Simon M summarised it roughly as "true but not helpful"
18:15:32 <Peaker> conal, http://www.mail-archive.com/haskell@haskell.org/msg21785.html
18:15:35 <conal> newsham: i guess not.  i guess i like to focus on one thing at a time.
18:15:44 <newsham> what are you focusing on now?
18:15:48 <newsham> :)
18:16:01 <Peaker> "nondeterministic decisions that incidentally coincide with the evaluation order of things in the program. This is perhaps not very satisfying, and makes the semantics of IO very strange (IO actions can essentially look into the future), but it means referential transparency isn't broken."
18:16:16 <conal> newsham: objective-c / cocoa touch / opengl programming
18:16:29 <newsham> interesting
18:16:36 <conal> Peaker: thx
18:17:12 <Peaker> maybe if we rule out the ability of IO to look into the future -- we can kill this explanation
18:18:20 <blackdog> can you initialise a Data.Map with a function taking keys to values?
18:18:33 <conal> Peaker: it's such a strange state of affairs.  to keep up the belief in the well-behavedness of the non-IO part of haskell, we're inventing outlandishly odd behavior of IO.
18:18:33 <blackdog> I need it to be lazy, so fromList won't work
18:18:34 <Peaker> dcoutts_, btw, I think explaining Iteratee to random programmers should be easy.. at least the essence of it
18:18:48 <Peaker> conal, Exactly, that's the part I learned about today
18:18:54 <dolio> blackdog: No.
18:19:32 <conal> Peaker: might be worthwhile assembling these clues about the haskell growing increasingly neurotic.
18:19:36 <dcoutts_> Peaker: "looking into the future" is only an silly explanation to anthropomorphise non-determinism
18:19:46 <hcube> hi! is anyone experienced with Data.Vector? (especially the unboxed interface)
18:19:48 <conal> Peaker: maybe as basis for an intervention.
18:20:00 <dolio> hcube: I have some experience.
18:20:02 <Peaker> conal, what kind?
18:20:17 <hcube> how can is use my own data type in unboxed vector?
18:20:24 <newsham> speaking of IO semantics, in relaed news scientists ask why we lie to others and ourselves. http://science.howstuffworks.com/evolution/why-do-we-lie.htm
18:20:25 <hcube> *how can i use
18:20:31 <fryguybob> Peaker: So how would you "rule out the ability of IO to look into the future"?
18:20:51 <conal> Peaker: the kind where your friends gather around and confront you with behavior that you're in denial about.
18:20:58 <aavogt> conal: but lazy IO isn't a terribly new invention, is it?
18:20:59 <Peaker> dcoutts_, well, by saying your "main" used a non-deterministic thing anywhere, and thus the *entire program*s beahvior is non-deterministic, the pure part is only visible via main's behavior, therefore the pure part has no meaningful determinism
18:21:29 <dcoutts_> Peaker: pure parts can usually be described separately
18:21:37 <dcoutts_> by abstracting over inputs
18:21:40 <Peaker> conal, I think that's what http://www.mail-archive.com/haskell@haskell.org/msg21789.html is about
18:21:43 <newsham> peaker: in fairness, the primitive is called "unsafe*"
18:22:25 <Peaker> newsham, Yes, but "getContents" is not called "unsafe*"
18:22:34 <conal> aavogt: i'm talking about an old problem.  starting with the acceptance of monadic IO as a "solution" for functional I/O.
18:22:35 <dolio> hcube: I think you need to write code similar to the stuff in Data.Vector.Unboxed.Base
18:22:40 <newsham> right, but what of other api functions that call unsafe*?
18:22:41 <blackdog> dolio: so if i want to memoise a function on lists for which i can compute a signature, i have to roll my own?
18:22:41 <Peaker> dcoutts_, Described separately, but only ever executed in a non-deterministic context
18:22:47 <conal> newsham: thx for that ptr
18:23:03 <dolio> blackdog: I think people have written stuff to do that. Just not Data.Map.
18:23:07 <dcoutts_> Peaker: no, you can easily not write non-deterministic IO programs, just don't use the non-deterministic constructs.
18:23:08 <dolio> conal has a library, as I recall.
18:23:08 <Peaker> newsham, Sometimes, they are safe despite calling unsafe
18:23:17 <newsham> good point
18:23:45 <aavogt> conal: I mean, how are people increasingly crazy if all your data points are quite old?
18:23:50 <dolio> hcube: See the stuff like "newtype instance Vector Int = ..."
18:24:00 <dolio> And "instance Unbox Int".
18:24:15 <hcube> ok
18:24:22 <aavogt> hmm, though the imprecise exceptions stuff is somewhat newer
18:24:57 <dolio> hcube: You might want to look at the instances for Complex at the bottom, as that's not just a primitive type.
18:25:30 <conal> aavogt: the new data points are the recent justifications/rationalizations for the old beliefs.  and maybe not increasingly, just sustained.
18:25:59 <Peaker> dcoutts_, They aren't marked as such
18:26:08 <Peaker> dcoutts_, how do I know what constructs are non-deterministic?
18:26:21 <dolio> The imprecise exceptions stuff isn't really that new in concept. You could catch pure exception in GHC prior to it.
18:26:52 <dolio> What might be new is the operational semantics they gave for it.
18:27:12 <dcoutts_> Peaker: from the documentation I suppose, how do you know anything about IO actions from random libs?
18:28:50 <dcoutts_> Peaker: and even if you make your nice H98 IO program, you've still got the problem of other agents in the same OS environment/context
18:31:20 <Peaker> dcoutts_, why did you write, btw, that you have stronger guarantees about interleaving with unsafeInterleaveIO than with forkIO?
18:31:31 <danharaj> Hey Conal, are you working on Phooey still?
18:31:49 <Peaker> Is randomness a lesser guarantee than dependence on evaluation order?
18:32:21 <siracusa> dcoutts_: pixbufNewSubpixbuf -- it takes 4 ints, can you tell me what int is what?
18:32:39 <dcoutts_> siracusa: check the gtk C API docs
18:32:44 <conal> danharaj: i've stopped working on haskell-based GUIs until i can see a GUI foundation library that's cross-platform and doesn't kill ghci.
18:33:37 <dcoutts_> Peaker: are you looking at a particular mailing list post where I said that? if so I'll take a look and try any work out what I meant :-)
18:33:41 <fryguybob> conal: Including widgets or not?
18:34:12 <conal> fryguybob: i don't understand the question.
18:34:14 <danharaj> conal: Lamentable. I really like the idea of phooey, so I'd like to see something like it grow to maturity. I guess I'll go find gui library project to throw my sword in to fix ghci support.
18:34:48 <Peaker> dcoutts_, oh whoops, that's something Jonathan Cast has said
18:35:00 <danharaj> conal: If there's a particular library you'd like to see work... :)
18:35:00 <fryguybob> conal: Are you wanting a library that has widgets or just draws to a screen and handles input events?
18:35:17 <conal> danharaj: i'd love to see wxhaskell get fixed to be ghci-friendly.  or gtk2hs to be mac-friendly (including 3d).  then i'd get back to GUI & GPU libraries for haskell.
18:35:47 <conal> fryguybob: ah, thx.  i'm torn about which to prefer.
18:36:07 <Peaker> dcoutts_, btw, the "correct" way to comprehend unsafeInterleaveIO is how you specified it ("random order of effects, use only when *any* order would do") which I think would narrow its use cases to almost nil. The way people comprehend it is (effects driven by evaluation and *thus* useful, and thus they use it everywhere with barely documenting it)
18:36:35 <conal> fryguybob: an existing gui/widget lib gives a rich set of widgets fast(ish), but is opposite to the direction of denotative/functional programming that i really want to be supporting.
18:36:51 <fryguybob> conal: Right, that's what I was wondering about.
18:37:28 <danharaj> conal: What sort of specifications would your minimal library satisfy?
18:37:33 <conal> fryguybob: so maybe something that's just opengl with low-level input would be the best starting point to denotative GUIs.  and beautifully modern (GPU-accellerated) ones at that
18:37:37 <Peaker> dcoutts_, That second outlook is shaping how people use it -- which is really really awful
18:38:19 <conal> danharaj: depends on whether it's the denotative/gpu direction or the lots-of-familiar-widgets direction.
18:38:21 <Peaker> dcoutts_, I think the first author of RWH, in a talk about the book, quoted some guy who said "The purpose of something is not what people claim, but what it actually does in practice"... :)
18:39:08 <danharaj> conal: I think denotative is the way to go, but IMO you have to try to conform to native look and feel as much as possible for the sake of the user. I'm not sure a non-widget library could do that reasonably.
18:39:46 <Peaker> danharaj, I think the native widgets are so horrible that it's not worth it
18:40:16 <conal> danharaj: that's where i'm torn.  we can go for something familiar, which has strong merit.  or we could go for something revolutionary -- something wonderful.
18:40:21 <fryguybob> danharaj: I think the look and feel part could come in at a different level.  For instance WPF doesn't use native widgets, but constructs them with the new lower level that it makes.
18:41:26 <fryguybob> danharaj: I don't know how you can do that without having a team of designers an attention to detail though.
18:41:48 <danharaj> peaker: I think it's up to the user to decide what is acceptable and what is not. I don't use Leksah, for example, because I don't like the clash of GTK with the rest of my (win7) apps. GUI's have to be user oriented, and the easiest way to make them comfortable is to use something they use all the time.
18:42:16 <dcoutts_> Peaker: you don't see people using unsafePerformIO directly very much and for good reason. It's usually carefully wrapped up so that the order of events does not matter. See for example the thing about H98 Handle locking and semi-closed Handle states. That's all there to stop you from shooting yourself in the foot. Nevertheless, if you try hard enough to can get around the safety mechanism and expose some non-determinism. Though why you would want
18:42:16 <dcoutts_>  to do that I do not know.
18:42:23 <conal> i'd like to help create a really new library that is denotative (not IO) and strongly compositional, and also has a flashy look & feel, exploiting modern GPUs.
18:42:32 <dolio> Which native widgets?
18:42:41 <dolio> I like my KDE.
18:42:49 <Peaker> dcoutts_, people understand the problematic nature of unsafePerformIO much better than they do that of unsafeInterleaveIO, I think
18:43:04 <dcoutts_> Peaker: I think you're right.
18:43:12 <fryguybob> danharaj,conal: It seems to me that the "look and feel" doesn't really exist unless you can declaratively write it down what exactly that "look and feel" is.  Having native widgets only gets you part of the way there.
18:43:29 <Peaker> danharaj, My point is that native GUIs are so bad, that while breaking compatibility is a bad thing, it's not as bad as using native guis :)
18:44:16 <danharaj> peaker: You will not have many users with that attitude :p
18:45:03 <dolio> Are most applications on windows 7 actually consistent? Back on XP even Microsoft had like 6 different widget sets. :)
18:45:10 <Peaker> danharaj, the iPhone proves that wrong..
18:45:18 <conal> and maybe if the design is denotative, it'll be much easier to create & compose widgets than with these legacy libs we've been carrying around.  so we can catch up with all that functionality.  maybe.
18:45:23 <Peaker> danharaj, Vastly different widgets to anything previously used
18:45:49 <danharaj> Peaker: That's a new platform. You're not mixing iphone with gtk apps at the same time, are you?
18:46:25 <danharaj> If part of the project is writing a declarative gui shell for linux/win/mac, that would be awesome.
18:46:37 <conal> Peaker: i'm with you.  the iphone is so compellingly beautiful that the break with the familiar is okay.  and better than okay.
18:46:52 <conal> Peaker: that's what i'd like to go for.
18:46:59 <fax> hello
18:47:21 <fryguybob> conal: How much of that is not having a mouse and keyboard?
18:47:30 <Peaker> conal, I'm torn here, because I appreciate the technical merits of the iPhone, but I really hate what taking that direction (of closed platforms controlled by corporations) would do to society
18:48:01 <conal> i'd be relieved if wxhaskell could stop killing ghci, or if gtk2hs could look pretty on my mac and handle 3d.  but only relieved.  i'd be *inspired* and thrilled to have something really lovely inside & out.
18:48:10 <conal> Peaker: ditto!
18:49:19 <danharaj> conal: It would be enormous work to build from the ground up. But I would be interested in contributing to it.
18:50:18 <conal> Peaker: i'm continuing to focus on iphone os for now.  i want to start learning android soon.
18:51:32 <fryguybob> conal,danharaj: For minimal stuff whatever Chrome is doing has a lot of reach and would be (at least somewhat) light weight.
18:51:59 <conal> fryguybob: chrome the browser?
18:52:36 <fryguybob> conal: Yeah, it has to be fast, cross platform and will keep getting developed.
18:53:10 <Peaker> conal, I just reject the iPhone because of this.. I'll get an Android
18:53:34 <fryguybob> conal: It's minimal in the sense that it is everything that html canvas can do (but not necessarally more).
18:54:00 <Makoryu> Does GHC compile to Dalvik now?
18:54:02 <conal> fryguybob: i'm confused about what you're suggesting.  do you mean make guis that run inside the chrome browser?
18:54:58 <p_l> Makoryu: I don't think so, Dalvik is slightly under-documented.
18:55:05 <fryguybob> conal: No, though that can be interesting.  I'm saying make a layer that binds to the GUI code cut out of Chrome.
18:55:18 <conal> fryguybob: ah.  got it.
18:55:46 <conal> fryguybob: i'd want to use GPU execution as a basis of the implementation.
18:56:08 <conal> fryguybob: since GPUs are amazingly fast and are such a good fit for functional programming.
18:56:19 <fryguybob> conal: Right, and I'm sure Chrome will go there at some point (IE's already headed there in the next version).
18:56:22 <BMeph> conal: Have you given any thought to having a "back end" to your denotative display, to output SVG, similar to Neil Brown's CSP-outputting CHP add-on? :)
18:57:02 <fryguybob> BMeph: SVG with javascript?
18:57:27 <conal> BMeph: i'm targeting GPU execution currently.  starting with GLSL, which runs on iphone & android phones.
18:57:31 <BMeph> fryguybob: If it needs it. Conal? :)
18:58:22 <BMeph> conal: Ah, go straight for the heart - I like it!
18:59:31 <danharaj> conal: What language are you using to explore this current area?
18:59:35 <fryguybob> conal: Anyway, I'm most interested in using language to capture "look and feel" as an orthogonal layer from actual pixels on the screen.
18:59:57 <danharaj> (denotative GUI's running on iphone/android)
19:00:53 <conal> it hit me last year that now is an incredibly compelling time to prepare for denotative programming to become very important.  since GPUs are so amazing in power & price, and they're much more harmonious with the denotative paradigm than with imperative paradigm.
19:01:29 <danharaj> Because a gpu is essentially a bunch of independent threads of execution?
19:01:31 <conal> danharaj: i've been developing a successor to pan, pajama, and vertigo.
19:02:08 <conal> danharaj: because gpus are massively parallel
19:02:19 <danharaj> mm.
19:02:54 <danharaj> Actually I never noticed the potential compatibility between the two until you pointed it out.
19:03:25 <conal> afaict, parallelism & concurrency are inherently a dreadful match with the sequential paradigm (including haskell's IO) that we've carried forward from the 1940s.
19:03:47 <conal> so misery guaranteed.
19:04:07 <danharaj> It's a shame that GPU vendors opted for imperative languages for their shaders instead of a declarative language.
19:04:20 <conal> danharaj: yeah.
19:04:25 <fryguybob> peace out everyone.
19:04:28 <kmc> yeah
19:04:29 <danharaj> nite.
19:04:38 <conal> danharaj: "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
19:04:43 <kmc> there is a rule that every new language has to be an imperative language with C-like syntax, or else "nobody will use it"
19:04:45 <danharaj> Everything looks like a nail.
19:04:48 <kmc> conal, great quote
19:05:05 <conal> we started out programming sequential computers, and then they programmed us.
19:05:32 <danharaj> Now that I see it, shaders are obviously declarative. You should be specifying how pixels/fragments/etc. transform, not manually loading registers etc.
19:06:24 <conal> kmc: i kept running into that rule.  had that conversation when i was at in the graphics group at microsoft research and the directx guys came to talk about what the shading language would be like.
19:07:30 <Adamant> I don't know that they're 'declarative'. but declarative stuff is usually highly parallelizable, and GPU's are nothing if not highly parallelizable.
19:07:32 <fax> What should I evolve in haskell?
19:07:34 <conal> eventually i realized that i don't want to pitch to professional programmers.  they're already stuck in their mental paradigms.
19:07:50 <Adamant> so who do you want to pitch to?
19:07:59 <bremner> professional catchers
19:08:14 <conal> kids, artists.  right-brain dominant folks.
19:08:17 <BMeph> kmc: Exhibit One: Javascript
19:08:18 <Adamant> bremner: bad pun, you're out of here!
19:08:26 <Adamant> :P
19:08:36 <danharaj> Mathematicians.
19:08:46 <Adamant> conal: good luck. you'll need it.
19:08:47 <kmc> i think the rule is actually bullshit
19:08:51 <kmc> Python and Ruby are enormously popular
19:09:12 <Adamant> Python is kinda enormously popular at this point.
19:09:25 <danharaj> kmc: I think it is in the context of low-level systems-type programming. A shader language is that kind of language.
19:09:26 <Adamant> Ruby is doing well but it's not huge in language erms.
19:09:27 <conal> Adamant: have you seen my "tangible functional programming" work?
19:09:44 * BMeph is old enough to remember the Logo craze...but not young enough to remember what those kids moved on to do with it.
19:09:49 <Adamant> conal: not yet. I just know this is a market where systems and companies tend to go to die.
19:10:08 <Adamant> which doesn't make it unimportant
19:10:20 <Adamant> a real win there would be a good thing
19:10:31 <p_l> danharaj: obviously, you need a higher-level language that compiles into GLSL/OpenCL
19:10:52 <dcoutts_> conal: I'm still hopeful we can demonstrate the advantages to programmers, especially when it comes to new hardware (clusters, multi-core, GPUs)
19:11:40 <conal> dcoutts_: yeah.  maybe we can.  personally i gave up after many years of such an effort.
19:11:44 <conal> "It is difficult to get a man to understand something when his salary depends on his not understanding it." - Upton Sinclair
19:11:50 <dcoutts_> OO programmers seem to be slowly learning that mutable shared state is a bad idea
19:12:00 * ManateeLazyCat I was think this idea: use darcs/patch-tag.com manage source code, and make others features (homepage, release version, wiki, issues) on code.google.com, it's perfect is code.google.com support darcs.
19:12:08 <dcoutts_> conal: in the mean time we can beat them at their game :-)
19:12:32 <ManateeLazyCat> dcoutts_: Hey, have you convert gtk2hs hashed? :)
19:12:32 <conal> dcoutts_: which game?
19:12:49 <dcoutts_> conal: solving problems with programs
19:13:15 <danharaj> A full fledged declarative GUI library would set off a few light bulbs.
19:13:15 * BMeph just lost.
19:13:21 <conal> dcoutts_: ah, yeah.
19:13:25 <dcoutts_> ManateeLazyCat: not yet
19:13:28 <danharaj> Also, i can't imagaine many problems harder than that.
19:13:52 <ManateeLazyCat> dcoutts_: I have use GIO developing a simple file-manager (http://farm5.static.flickr.com/4027/4584389024_782b1e09ee_o.png), gio is much faster than GnomeVFS, and easier to use.
19:14:13 <ManateeLazyCat> dcoutts_: Ok, nevermind, just do it when you have time.
19:14:17 <conal> danharaj: yeah.  i think denotational/compositional GUI lib design will continue to be hard until it suddenly becomes incredibly simple.
19:14:33 <ManateeLazyCat> dcoutts_: I found hashed repository can exchange patches with darcs-1-format repository.
19:14:39 <dcoutts_> ManateeLazyCat: yes
19:15:03 <Adamant> conal: nice presentation. it could potentially make stuff simpler, from what I saw skimming stuff.
19:15:16 <ManateeLazyCat> dcoutts_: Anyway, convert hashed-format will got faster get speed. :)
19:15:35 <conal> sadly, i see haskell IO as a local optimum.  comfortable enough to tolerate but nowhere close to the denotative/functional dream.
19:16:17 <Adamant> it's just that there have been a lot of 'teach everyone programming' efforts, including ones doing fairly innovative things, that more or less don't end up doing so.
19:16:21 <danharaj> conal: Sounds like everything in life :(
19:16:52 <fax> conal nice when people say something I agree with
19:16:56 <conal> danharaj: yeah.  the good is the enemy of the great.
19:17:17 <conal> fax: :)  nice when i can say this sort of thing and not get jumped on.
19:17:21 <Adamant> then again, we aren't likely to get hard AI anytime soon, but AI research has certainly delivered some interesting stuff.
19:17:23 <ezyang> Well, first things first; we have to get unhappy with Haskell IO
19:17:33 <conal> ezyang: yeah!
19:17:41 <conal> ezyang: that's why i agitate.
19:17:50 <danharaj> I'm already unhappy with it. I hate doing IO in Haskell :|
19:17:55 <fax> yeah that is for sure, I have to be so careful because a lot of things I beleive tend to upset a lot of people
19:17:59 <conal> i'm bummed that imperative programming has become the killer app of functional programming.
19:18:08 <danharaj> I try to get away from the IO monad asap when writing programs.
19:18:33 <danharaj> conal: It's funny how some features make imperative programming really easy.
19:18:39 <kmc> i love imperative programming in Haskell compared to any other language.  that said i agree with conal
19:18:40 <danharaj> (but still imperative)
19:19:01 <conal> kmc: yeah, me too.  when i want imperative programming, i go to haskell.
19:19:13 <conal> (unless i want it for the iphone)
19:19:18 <ManateeLazyCat> dcoutts_: Now, GIO can replace GnomeVFS completely. :)
19:19:51 <dcoutts_> Fortunately it's not an either/or. We can use sub-optimal IO and write nicer programs than the traditional alternative while at the same time some people can look into improvements on IO
19:20:19 <dcoutts_> a spectrum from research to practice, we need to push at all levels
19:20:33 <kmc> yes
19:20:46 <danharaj> Need more manpower.
19:20:53 <danharaj> (and womanpower, for that matter{
19:20:59 <dcoutts_> always needs more manpower :-)
19:21:12 <ManateeLazyCat> kmc: I use gtk2hs everyday, i think gtk2hs's API is much clear than other language binding.
19:21:20 <conal> "If you want to build a ship, don't drum up people together to collect wood and don't assign them tasks and work, but rather teach them to long for the endless immensity of the sea." - Antoine de Saint-Exupéry
19:21:57 <kmc> :O
19:21:59 <danharaj> Well at some point they need to be given things to do :p
19:22:19 <gwern> danharaj: you know, I understand that in the old english which 'man' comes from, that was inclusive of women
19:22:33 <QtPlatypus> Or at least a task list of what is needed to be done.
19:22:34 <danharaj> gwern: I was being tongue in cheek, I know that :D
19:22:48 * gwern eyes danharaj suspiciously. really.
19:23:05 <gwern> how'd a nice lad like you learn an obscure philological observation like that?
19:23:42 <ManateeLazyCat> IMO, it's not perfect *pure* solution in this world, even Haskell, we still need mix imperative feature in it.
19:23:46 <gwern> (incidentally if anyone is skeptical, see http://en.wikipedia.org/wiki/Man_%28word%29 )
19:23:54 <fax> I don't know what is going on but I love the sound of 'philological'
19:24:11 <danharaj> gwern: Because one time I facepalmed because someone thought 'woman' was sexist.
19:24:16 <gwern> 'J.R.R Tolkien was a renowned philologist.'
19:24:28 * gwern whispers philological nothings in fax's ear
19:24:39 <fax> mmm marry me :)
19:24:42 <danharaj> philololololology
19:24:50 <gwern> phikekekekek!ogy
19:25:26 <gwern> ManateeLazyCat: imperative features are just things we don't know how to treat functionally yet!
19:25:52 <ManateeLazyCat> gwern: I mean mix FFI. :)
19:26:37 <conal> gwern: in other words, imperative code is the "how" where we don't yet know the "what".
19:27:07 <conal> ie we know how to do it, but we don't know what it is that we're doing.
19:27:12 <danharaj> To be fair, sometimes you have to wade balls-deep into theory to understand "what"
19:27:16 <gwern> that's the haskellers' vow: 'Imperative programs are countless; I vow to purify them all. Blind misunderstanding is countless; I vow to prove them all. Obscurities are countless; I vow to resolve them all. I vow to attain the way of the Wadler.'
19:28:23 <gwern> a haskeller is a being of great compassion, who has returned this world of sinbin functions, abandoning 'lambdana'
19:28:40 <conal> gwern: yep.  though replace wadler with bird, since wadler promoted imperative programming (via IO)
19:28:53 <gwern> conal: bird lacks a syllable
19:29:06 <gwern> conal: 'buddha' has 2 syllables, and the same stresses as 'wadler'
19:29:22 <conal> gwern: ah.
19:29:42 <gwern> ('san easy mistake. many would-be parodists fail to respect the prosody of the original.)
19:29:43 <dolio> Just pronounce Bird with two syllables.
19:29:53 <gwern> dolio: now you are just being silly.
19:30:00 <danharaj> Users should be called Haskelletors as someone once said in this channel.
19:30:34 * gwern doesn't like that, by the power of lambda!
19:31:28 <gwern> eh. 'lambda' isn't a very good replacement for 'greyskull'
19:31:50 <danharaj> "haskell" but kind of fudge the e to a u
19:32:13 <Makoryu> Haskell has its own special superhero persona waiting to be pulled out of the mythology monad
19:32:24 <Makoryu> We just need the right pattern match
19:32:26 <gwern> the problem is the pitch. greyskull is low-high, lambda or haskell is the opposite
19:32:47 <Makoryu> gwern: What?
19:32:50 <Makoryu> In what language?
19:32:52 <Makoryu> Swedish?
19:32:55 <ezyang> gwern: Try functor?
19:32:55 <gwern> gwernish
19:33:09 <ezyang> no, wrong way
19:33:28 <gwern> ezyang: actually, I think that works. by the power of functor! (funk-TOR)
19:33:46 <Makoryu> gwern: Seriously what's your native language
19:33:50 <gwern> Makoryu: english
19:34:09 <gwern> shoot, I should've made Makoryu guess. it's always funny when people try to guess my accent
19:34:52 <Adamant> I would have guessed English with a side of Welsh.
19:34:58 <Makoryu> gwern: I would guess that you had a Martian accent. I don't think I've ever met an English speaker who would stress the second syllable in "functor" and "greyskull"
19:35:03 <dcoutts_> conal: I expect if we try hard enough that we can say precisely what an IO program means, eg in terms of CSP (iirc there's a denotational semantics for CSP). It's just such an explanation doesn't make it any nicer! :-)
19:35:34 <gwern> Makoryu: well, if you're shouting it, I think people would stress the second syllable in functor. and doesn't he-man in the cartoons stress the second syllable of greyskull?
19:35:55 <conal> dcoutts_: i would be very surprised if we could do so.  keeping in mind that the IO API includes thousands if ffi-imported primitives.
19:36:07 <gwern> Makoryu: but it's not just the volume/stress, it's the pitch. 'grey' is lower pitched than 'skull'. 's' is high and sibilant
19:36:11 <Makoryu> gwern: I've never seen the show, but when people quote it, they stress "grey"
19:36:20 <dcoutts_> conal: but you're right of course that there's no denotation in the programmer's head when writing the IO program, where as there might be for pure programs.
19:36:23 <conal> dcoutts_: and since their return types are IO, they have to be precisely explainable in terms of the denotational model of IO
19:36:48 <Makoryu> gwern: Also, are you from the north of England? :p
19:36:59 <conal> dcoutts_: yeah, and i'm saying more than that.  not only missing from programmers' heads, but probably nowhere to be found.
19:37:00 <dcoutts_> conal: sure, the rest of the OS environment is a very complex mix of processes
19:37:48 <gwern> Makoryu: watch http://www.youtube.com/watch?v=7yeA7a0uS3A and tell me that 'skull' isn't slightly louder than 'grey'
19:37:56 <JoeyA> :t foldl'
19:37:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:38:04 <JoeyA> @src foldl'
19:38:04 <lambdabot> foldl' f a []     = a
19:38:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:38:17 <conal> this is how i see IO being a staggeringly huge departure/abandonment of the denotative/functional endeavor.
19:38:19 <gwern> Makoryu: och, I is scootish raised'n'bairn!
19:38:20 <JoeyA> What module is foldl' in?
19:38:27 <gwern> @hoogle foldl'
19:38:27 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
19:38:27 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
19:38:27 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
19:38:31 <JoeyA> thanks
19:38:59 <Adamant> gwern: just because you are Scottish doesn't mean you were raised in a barn, you stereotyper :P
19:39:06 * Adamant ducks
19:39:11 <gwern> Adamant: bairn=born -_-
19:39:15 <Adamant> yeah I know
19:39:18 <Adamant> :)
19:39:22 <gwern> silly tawpie
19:39:24 <Makoryu> gwern: Awesome. Do you say "stane" for "stone?" :D
19:39:26 <gwern> ye ken not
19:39:30 <Adamant> whas like us?
19:39:50 <conal> gwern: isn't a bairn a child?
19:39:53 <Adamant> (not me, actually, but I have a friend who's Scottish)
19:39:58 <sshc> If I'm given a list of integers from 1-n, where n is a positive integer, how do I reverse the order of the numbers *by a series of swaps of the first place with any other number*?  I'm actually keeping a list of the steps (a list of numbers which is the place that was swapped with the very first place), but I just need to know how to do so.
19:39:59 <Adamant> yeah
19:40:02 <gwern> Makoryu: eh, yer too gleg-gabbit fer me to answer
19:40:26 <gwern> conal: I think it's both verb and noun
19:40:40 <gwern> conal: the noun is more of an infant or baby, I had understood
19:40:45 <dcoutts_> conal: though we should distinguish between the incomprehensible meaning of external processes and the possibly-comprehensible description of our own programs' interaction behaviour
19:40:50 <conal> gwern: ah, thx.
19:41:06 <gwern> sshc: 'reverse the order of the numbers'?
19:41:27 <sshc> gwern: [1, 2, 3, 4] -> [4, 3, 2, 1]
19:41:31 <Makoryu> gwern: Sorry for being so foreign :| I've never been to the British isles.
19:41:36 <conal> dcoutts_: i'm not even going for biological life etc.  just things that we give type IO to.
19:41:45 <gwern> sshc: is there something wrong with 'reverse'?
19:41:45 <Adamant> gwern: are you actually Scottish? I though gwern was a Welsh name.
19:41:51 <gwern> Adamant: I'm neither
19:42:04 <gwern> Adamant: 'gwern branwen' do be a pseudonym, ken?
19:42:10 <dcoutts_> conal: but that includes what other processes are doing
19:42:11 <Adamant> alright
19:42:13 <gwern> seriously no one could actually be named that
19:42:15 <conal> dcoutts_: and which therefore must be explainable precisely and fully in terms of the hypothetical denotational model of IO.
19:42:19 <sshc> gwern: I need a list of numbers, which are the places I can swap with the first to get to the final reversed list
19:42:26 <gwern> it'd be like someone named artur pendragon
19:42:30 <fax> sshc, huh??
19:42:34 <sshc> gwern: These numbers can only be swaps with the first
19:42:39 <Adamant> gwern: I can't believe a lot of other Welsh words are real either
19:42:47 * ezyang idly wonders if IO is a bad name for the phenomenon. 
19:42:48 <gwern> Adamant: I wondered sometimes too
19:43:09 <conal> dcoutts_: to check whether i'm understanding you, would you please give an example of these external processes?
19:43:09 <gwern> Adamant: but finnish is even worse!
19:43:12 <Adamant> it could be weirder. it could be basque.
19:43:17 <gwern> Adamant: there everything sounds like curses
19:43:20 <Adamant> *Basque
19:43:20 <sshc> For example, to get from [1, 2, 3] to [3, 2, 1], I can do that with only one swap: the 1st and the 3rd, so the list of moves I want is a singleton list: [3]
19:43:28 <Makoryu> gwern: Anyway, the pronunciation in that video clearly has a high, level pitch for "grey" and a falling pitch for "skull" (roughly 1 and 4 respectively, in Mandarin tones). The volume is about the same.
19:43:45 <Adamant> Hungarian is also hard to learn, supposedly.
19:43:49 <sshc> It's [3] because the only swap necessary is the swap with the 3rd place (the 3rd place is swapped with the 1st)
19:43:57 <ManateeLazyCat> <sshc> It's [3] because the only swap necessary is the swap with the 3rd place (the 3rd place is
19:43:57 <ManateeLazyCat> 	   swapped with the 1st) [10:43:46]
19:43:57 <ManateeLazyCat> >
19:43:57 <ManateeLazyCat>  
19:44:03 <ManateeLazyCat> Sorry, erc bug.
19:44:07 <gwern> sshc: sounds like you're treatin lists like an array
19:44:09 <ManateeLazyCat> Sorry.
19:44:16 <fax> sshc, I would first write a program that takes [1,2,3] and [3] and outputs [3,2,1] -- then I would invert it to derive this program
19:44:18 <sshc> gwern: lists are still ordered.
19:44:46 <gwern> sshc: the point is he's talking about 'swaps' - that's student talk about arrays, not lists. you build new lists with consing
19:44:53 <sshc> fax: It needs to work with any size
19:45:00 <fax> sshc, ???
19:45:19 <dcoutts_> conal: so a CSP description of a Haskell IO program that does getChar/putChar would describe what interactions the program can have. That is a meaning on it's own. Of course to "run" that program we have to compose it with other processes (like the terminal). We do not need to describe the meaning of the terminal to describe our program in isolation.
19:46:21 <conal> dcoutts_: yep.  i'm with you there.  i don't expect getChar & putChar to be difficult at all to handle denotationally.
19:46:24 <gwern> sshc: are you allowed to exploit the 1-n structure?
19:46:44 <sshc> gwern: I guess I'm allowed to do anything.  I'm just tyring to figure this out.
19:46:57 <gwern> sshc: because I mean, if you are, the answer is obvious. every entry except the middle will be swapped
19:46:58 <dcoutts_> conal: it obviously gets much harder for additional FFI primitives
19:47:18 <gwern> sshc: so the answer would be something like 'all n-1 > median'
19:47:29 <sshc> fax: gwern: I want a function of type Integer -> [Integer].  It takes a positive integer that is greater than 1, and it needs to return a list of numbers.  These numbers represent a valid series of swaps that reverse the list [1..n].  Each number from the start of the swap list represents a swap of the first number and that place.
19:47:29 <conal> dcoutts_: exactly.  that's why i mentioned ffi.  whatever has type IO has to be explainable in the hypothetical model.
19:47:45 <dcoutts_> conal: especially once we treat those FFI bits as "part of the program" where we need to explain their meaning, rather than as external interacting processes that we do not seek to explain.
19:47:52 <fax> sshc urgh you are all over the place
19:48:05 <conal> dcoutts_: if they have type IO, then we do have to explain their meaning.
19:48:13 <gwern> fax: no, it's easy. it's only unclear because you're thinking of small examples
19:48:39 <dcoutts_> conal: yes and FFI complicates it considerably
19:48:47 <gwern> fax: think about how to swap [1,2,3,4,5,6,7,8,9]. in sshc's terminology, you have to move [6.7.8.9]
19:49:18 <gwern> fax: or, f ns = filter (\x -> x > length ns / 2) ns
19:49:44 <fax> gwern oh it's only handling reverses?
19:50:09 <gwern> or, 'f x = [x`div`2..x]', I think
19:50:23 <gwern> > let f x = [x `div` 1 .. x] in f 9
19:50:24 <lambdabot>   [9]
19:50:30 <gwern> > let f x = [x `div` 2 .. x] in f 9
19:50:31 <lambdabot>   [4,5,6,7,8,9]
19:50:53 <gwern> wait, that's not right. the pivot should be 5
19:50:56 <conal> dcoutts_: which is for me the most compelling reason for believing that haskell-style IO will never fit denotative/functional programming
19:51:09 <gwern> > let f x = [(x `div` 2)+1 .. x] in f 9
19:51:10 <lambdabot>   [5,6,7,8,9]
19:51:16 <dcoutts_> conal: my point is simply that we do not always have to give a complete explanation because we can abstract over IO actions and describe our own program's interaction behaviour
19:51:21 <conal> and the obstacles are inherent not only in the particulars of haskell IO but in the very goals.
19:51:23 <gwern> > let f x = [(x `div` 2)+2 .. x] in f 20
19:51:24 <lambdabot>   [12,13,14,15,16,17,18,19,20]
19:51:30 <gwern> > let f x = [(x `div` 2)+1 .. x] in f 20
19:51:31 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
19:51:40 <gwern> hm.
19:51:45 <gwern> sshc: well, do you understand yet?
19:52:02 <conal> dcoutts_: are you saying that we can somehow avoid explaining the semantics of primitives that have type IO?
19:52:03 <sshc> fax: If the swap list was [2, 3, 2], when that is applied to [1, 2, 3, 4, 5, 6], then after the first swap, the list would be [2, 1, 3, 4, 5, 6], because the second place was modified with the first.  Then the *third* place would be swapped with the first, making [3, 1, 2, 4, 5, 6].  Finally, the *second* place would be swapped with the first, making [1, 3, 2, 4, 5, 6].  That's how swapping with
19:52:09 <sshc> the first place works.	But, [1, 3, 2, 4, 5, 6] is *not* what I want, since it's not the reverse of [1..6] (which is syntax sugar for [1, 2, 3, 4, 5, 6])
19:52:12 <dcoutts_> conal: yes exactly
19:52:31 <gwern> sshc: hold on, you told us it was a list 1-n
19:52:45 <sshc> gwern: The list I want to reverse is [1..n]
19:53:02 <sshc> gwern: The series of swaps in that example was [2, 3, 2]
19:53:06 <sshc> Which doesn't work for reversing
19:53:11 <dcoutts_> conal: eg the distinction between an openFile system FFI call and a FFI call to do zlib compression. One we can say is interaction with an external process where as the other we really ought to explain fully as it's simply not sensible to pretend it's an abstract external agent. We couldn't say anything useful about our program otherwise.
19:53:20 <conal> dcoutts_: i don't see it.  you know how denotational semantics works, don't you?  the denotation function has to map *all* values to denotations within the model.
19:53:35 <sshc> findSwapsWithFirstPlaceNecessaryToReverse1ToN :: Integer -> [Integer]
19:53:46 <dcoutts_> conal: yes, but that's what a CSP description of how a process interacts says
19:53:57 <BMeph> "T vow to attain the way of the Simons." ;)
19:54:00 <sshc> gwern: You're saying that f x = [(x `div` 2)+1 .. x] in f 20 works?
19:54:13 <gwern> no, you changed the problem
19:54:30 <conal> dcoutts_: i don't think so, and i don't know how to get out of this loop.  maybe we're not hearing each other.
19:54:31 <gwern> BMeph: oh, that's good. better than wadler because you got the plural right
19:54:46 <sshc> gwern: You do understand what I'm trying to figure out, right?
19:55:00 <gwern> sshc: you want a descending bubble sort with logging, is my workign theory
19:55:10 <gwern> why you would want such a thing, I am unsure
19:55:37 <conal> no, not the simons either.  they're doing lots of imperative programming.  compare with richard bird.
19:55:51 <conal> oh -- maybe "richard"
19:55:57 <dcoutts_> conal: you agreed that getChar can be explained in CSP terms as interaction with another process, that is an IO value, we do not seek to describe precisely what the result of the action is, we have abstracted over what is on the other side of that getChar channel, we just explain our interactions.
19:56:10 <twink> Please, selection sort, not bubble sort.
19:56:33 <gwern> twink: what's the diff?
19:56:35 <conal> dcoutts_: no, i didn't.  i wasn't talking about csp.  getChar & putChar have simple denotations.
19:57:26 <conal> dcoutts_: and just like the sine function can be explained without explaining how it gets its arguments or how its results are consumed, so with putChar & getChar.
19:57:34 <twink> Bubblesort is just offensive. Selection sort is easier to write, easier to prove the correctness of, easier to understand, etc.
19:57:50 <gwern> twink: is sshc's 'swap' compatible with selection sort? or bubble?
19:58:05 <gwern> (it seems like bubbling to me)
19:58:06 <sshc> Swaps can only be with the first position and any other positoin
19:58:26 <twink> gwern/sshc: That would be selection.
19:58:29 <sshc> f :: Integer -> [Integer]
19:58:54 <conal> i doubt the csp angle helps to solve the problem of giving a denotative basis to IO
19:59:16 <dcoutts_> conal: it's in terms of traces and events
19:59:17 <gwern> sshc: why not just write your crippled sort function, and then add a writer monad?
19:59:17 <conal> because it doesn't address those thousands of odd primitives that have type IO.
19:59:32 <conal> dcoutts_: yeah.  that's a tiny piece.
19:59:45 <dcoutts_> conal: right, each primitive needs to be described separately, it's not simple.
19:59:53 <dolio> Denotation is overrated, anyhow.
20:00:26 <conal> dolio: that's a separate value judgment.  which i won't argue.
20:00:42 <dcoutts_> conal: I never said it was simple, or that it was nice, or that it was especially useful :-)
20:00:45 <dolio> If you keep citing Richard Bird at least, he was all about algebraic reasoning about programs.
20:00:50 <gwern> 'A programmer has got to know when to keep his mouth and his mind shut. You might end up dead.' 'Isn't that the usual fate of men, Harry?'
20:01:08 <dolio> Where it doesn't really matter what things "are", only what algebraic laws they satisfy.
20:01:19 <gwern> @quote long
20:01:19 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
20:01:19 <lambdabot> HList syntax or something.
20:01:38 <conal> richard bird was off the top of my head.  i like that he's in our community and he still thinks about functional programming w/o IO
20:01:41 <dolio> Same thing with looking to category theory. Asking what things are is "evil." You shouldn't care what they are, up to isomorphism.
20:02:02 <conal> dolio: and yeah.  i like the distinction you're making between algebra & denotation.
20:02:33 <JoeyA> Is there a Haskell function for this? :
20:02:33 <JoeyA> smear :: (a -> b -> a) -> a -> [b] -> [a]
20:02:33 <JoeyA> smear f b [] = [b]
20:02:33 <JoeyA> smear f b (x:xs) = b : smear f (f b x) xs
20:02:34 <sshc> twink: Selection sort looks exactly like what I need.  Thanks!
20:02:38 <conal> dcoutts_: though you did say it's doable, iiuc, which i'm highly doubtful of.
20:02:43 <sshc> twink: THe wikipedia article was helpful.
20:02:47 <JoeyA> It's like foldl, but it builds a list of the results as it goes.
20:02:48 <gwern> @hoogle (a -> b -> a) -> a -> [b] -> [a]
20:02:49 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:02:49 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
20:02:49 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
20:02:52 <sshc> twink: (Of course, instead of maximum it's minimum)
20:02:56 <gwern> how about that
20:03:08 <gwern> @src scanl
20:03:08 <lambdabot> scanl f q ls = q : case ls of
20:03:08 <lambdabot>     []   -> []
20:03:08 <lambdabot>     x:xs -> scanl f (f q x) xs
20:03:19 <conal> dcoutts_: for instance, these games to explain how exceptions & such can be sensitive to the order of evaluation of pure code.
20:03:27 <dcoutts_> conal: in practice, one probably cannot get much further than what is included in the IOSpec package without going mad.
20:03:52 <dcoutts_> conal: but you don't need to give that detail, allowing any possible interleaving is enough
20:04:07 <dcoutts_> demonic choice
20:04:18 <JoeyA> gwern> That's exactly it, thanks
20:04:21 <JoeyA> scanl
20:04:29 <BMeph> Point: gwern. :)
20:04:53 * gwern is a Bear of very little Brain and long type signatures confuse him
20:05:02 <gwern> so I ask others for help
20:05:08 <JoeyA> hehe
20:06:35 <dcoutts_> conal: http://en.wikipedia.org/wiki/Communicating_sequential_processes#Denotational_semantics
20:06:49 <conal> dcoutts_: maybe you're right about that.  the semantics are loose (power set), so any actual result is only required to be a member of the set-valued denotation.
20:07:17 <dcoutts_> conal: exactly, "the set of sequences of events (traces) that the process can be observed to perform"
20:07:20 <conal> dcoutts_: as i said, csp addresses only the tiniest fraction of haskell's IO
20:07:30 <dcoutts_> conal: so it's precise but extremely unhelpful! :-)
20:07:48 <conal> yeah! :)
20:09:46 <Traveler2> hello
20:10:01 <sshc> twink: Actually, no, that algorithm won't work!
20:10:14 <sshc> twink: It requires the ability to swap with two positions that aren't the very first
20:10:14 <Traveler2> I was wondering are the y combinator and the id function connected?
20:10:46 <dolio> What does connected mean?
20:10:46 <Traveler2> y f=f(y f) and id has the property id (f id)=f id
20:10:49 <dcoutts_> conal: so on FFI, I think one might still be able to give a precise and yet unhelpful denotion in terms of CSP-style interaction with external processes. It only starts to become even vaguely helpful once you can give a meaning to those external processes.
20:11:36 <gwern> sshc: anyone writing a sort for an array wouldn't adopt your 'slide down' bit; anyone writing a sort for a list wouldn't restrict the swap like that. your sort is one weirdass hybrid
20:12:03 <conal> dcoutts_: oh -- maybe i'm starting to understand what you really mean about these external processes.  maybe you mean we could take everything in IO that we don't understand and call it an external process.
20:12:24 <conal> dcoutts_: sort of like IO itself is, relative to denotative/functional programming.
20:12:35 <conal> so bring in only a tiny part of IO for explaining
20:12:42 <conal> dcoutts_: something like that?
20:13:02 <sshc> gwern: Yeah, it has a limitation.  I'm figuring out how I can reverse a list of 1..n through swaps *with* that limitation.
20:13:10 <conal> dcoutts_: i thought you mean like whoever is typing characters into getChar and reading them from putChar.
20:13:11 <dcoutts_> conal: yes exactly, we precisely describe our interaction behaviour with the external IO, it's just not all that useful for saying things about our programs.
20:13:13 <gwern> conal: in game theory, 'the world' is often modeled as a player
20:13:27 <JoeyA> @src zipWith
20:13:27 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
20:13:27 <lambdabot> zipWith _ _      _      = []
20:13:37 <dcoutts_> conal: so it's all just a pernickity point about the difference between a precise denotion and a useful one
20:13:44 <sshc> gwern: I don't really need to swap anything; I just need a list of swaps with the first position that will result in a reversed list
20:14:14 <dcoutts_> conal: and you're obviously looking for a nicer and more useful one
20:15:29 <conal> dcoutts_: indeed.  i'm trying to pick up on the original intention of functional programming.  what backus talked about in "can programming be liberated ...".  good for composition and precise reasoning.
20:16:08 <conal> more than just using functional programming as a way to generate imperative programs.  i.e. a fancier C preprocessor.
20:16:50 <conal> a *much* fancier C preprocessor
20:16:56 <dcoutts_> :-)
20:17:19 <slymee`> conal, what's the goal exactly? what is "liberated"?
20:17:27 <kmc> we will be greeted as liberators
20:17:38 <conal> kmc: :)
20:18:04 <conal> slymee`: backus explains it well in the first 5 or so sections of that turing award address.
20:18:24 <conal> slymee`: i could try summarizing, but he said it so well!
20:18:43 <gwern> @quote liberator
20:18:43 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
20:18:49 <slymee`> i just don't trust the romance...
20:19:36 <kmc> you go to war with the language you have
20:19:51 <conal> slymee`: good!  don't trust.  read the paper, and think for yourself.
20:20:25 <conal> i hope no one would take my word for such things.  i don't say them to persuade, only to inspire curiosity & reflection.
20:20:58 * ManateeLazyCat Haskell is "super C" language. :)
20:21:02 <slymee`> ok, I'll read it then
20:21:14 <tensorpudding> Super C?
20:21:20 <pikhq> conal: Though it must be said that very fancy C preprocessors are themselves pretty cool. ;)
20:21:31 <conal> pikhq: yeah! :)
20:21:57 <conal> pikhq: functional programming really is great for generation of programs in any paradigm, including imperative.
20:22:10 <ManateeLazyCat> tensorpudding: Yes, i create this word "Super C". :)
20:22:27 <conal> it's just not denotative
20:22:32 <Makoryu> ManateeLazyCat: I'd much sooner compare Haskell to Lisp than to C. Haskell is high-level to the core.
20:22:36 <pikhq> conal: Well, yes. Code generation is pretty inherently functional.
20:22:59 <ManateeLazyCat> Makoryu: I don't like Lisp now. :)
20:23:08 <gwern> ghc's code generation is not referentially transparent :)
20:23:09 <conal> pikhq: from our modern perspective, yeah.
20:23:21 <Makoryu> ManateeLazyCat: I'm not terribly fond of it either.
20:23:35 <conal> pikhq: and we don't yet have that perspective about some other things.  but i'm optimistic!
20:24:13 <kmc> yeah, a compiler is about the most complicated / useful program that can be regarded as mostly a pure function
20:24:31 <ManateeLazyCat> Makoryu: My favourite lisp -- elisp break my heart ....
20:25:25 <conal> kmc: and hence disappointing to me that even ghc is wed to files.
20:25:32 <kmc> yeah
20:25:33 <kmc> brb
20:26:00 <conal> and moreover that module references are like global mutable variables.
20:26:03 <flippo> elisp?  Who pays attention to scoping anyway.
20:26:16 <Makoryu> （　°∀°）
20:42:42 <sshc> fax: gwern: twink: I have been enlightened!  I know how to write this function now! :D
20:45:21 <fax> oh cool what method are you using to write this program
20:45:22 <fax> ?
20:45:37 <sshc> fax: vim
20:45:46 <andrewsw> lol
20:46:31 <sshc> fax: I found a solution by finding working swap lists that work when 1≤n≤5, and examining the pattern
20:50:07 <sshc> What is the name of the function that removes identical consequtive elements in a list again?
20:50:23 <sshc> "mississippi" -> "misisipi"
20:50:30 <ezyang> > nub [1,2,3,3,4,1]
20:50:31 <lambdabot>   [1,2,3,4]
20:50:35 <ezyang> nope
20:50:47 <tensorpudding> > num "mississippi"
20:50:48 <lambdabot>   Not in scope: `num'
20:50:52 <tensorpudding> > nub "mississippi"
20:50:52 <lambdabot>   "misp"
20:50:57 <sshc> nub removes all duplicates; not one of identical consequtive elements
20:51:03 <glguy> map head . group
20:51:09 <sshc> :t group
20:51:10 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:51:26 <glguy> > (map head . group)  "mississippi"
20:51:28 <lambdabot>   "misisipi"
20:51:36 <sshc> I thought there was a function for that.  Huh.  Thanks, glguy!
20:54:17 <siracusa> Can you create semi-transparent Pixbufs in Gtk2Hs?
20:55:51 <sshc> Now I just need a way to create a list based on a number.  Passing it 5 will generate [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 3, 4, 5]] (They can also be concatenated).  Is there a one-liner that will do this, or can I only do it elegantly on multiple lines?
20:56:38 <dcoutts_> siracusa: yes
20:56:43 <Ferdirand> > [ [1..n] | n <- [1..n] ]
20:56:44 <lambdabot>   *Exception: not a number
20:56:57 <Ferdirand> > [ [1..n] | n <- [1..5] ]
20:56:58 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
20:57:01 <fax> > (reverse . inits) [1..5]
20:57:02 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1],[]]
20:57:35 <siracusa> dcoutts_: So how then? I want to merge two pixbufs RGB and A to a new RGBA one.
20:57:38 <sshc> Thanks, guys :)  THose are clever
20:58:20 <dcoutts_> siracusa: you can create a pixbuf with an alpha channel
20:58:40 <SubStack> > tails [1..5]
20:58:41 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
20:59:13 <ezyang> > map reverse $ tails [5..1]
20:59:14 <lambdabot>   [[]]
20:59:24 <ezyang> oh, right
20:59:32 <ezyang> > map reverse $ tails [5,4..1]
20:59:33 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1],[]]
21:01:58 <siracusa> dcoutts_: The problem is, I have the alpha channel separated in a file and I can't find a function so set A channel pixelwise for the other pixbuf.
21:02:04 <SubStack> > tail $ scanl (flip (:)) [] [1..5]
21:02:05 <lambdabot>   [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
21:02:28 <SubStack> blarg
21:02:57 <dcoutts_> siracusa: you could either do it directly by writing code to modify the pixel data, or you might be able to achieve the same result using pixbufAddAlpha and pixbufComposite. Check the docs.
21:06:36 <siracusa> dcoutts_: I checked the docs, but unfortunately I didn't find a function for setting a single pixel in a pixbuf. And pixbufAddAlpha only takes a single color for the whole pixbuf.
21:07:38 <dcoutts_> siracusa: pixbufGetPixels
21:08:03 <dcoutts_> check the docs for that function, see the demo that uses it
21:08:25 <siracusa> dcoutts_: Ah, thanks for that!
21:08:46 <dcoutts_> siracusa: it might be worth checking if a simply copy will work though
21:09:37 <dcoutts_> siracusa: pixbufCopyArea I mean, depends if it overwrites channels in the destination that are not present in the source
21:22:18 <sshc> How do I remove consecutive duplicates in a list?  (Sorry, I thought I needed to remove only one instead of both)
21:22:47 <Cale> sshc: map head . group
21:23:13 <sshc> Cale: That only removes one of the multiple consecutive duplicates in a list
21:23:26 <Cale> oh, you want to remove all the elements if any are repeated?
21:23:37 <sshc> Cale: Yes, *if they're next to each other*
21:23:51 <ivanm> map head . group, like Cale said
21:24:03 <sshc> ivanm: "mississippi" -> "miii"
21:24:11 <sshc> > map head . group $ "mississippi"
21:24:12 <Cale> map head . filter (null . tail) . group
21:24:12 <lambdabot>   "misisipi"
21:24:21 <sshc> Nope, that doesn't remove all of them, ivanm
21:24:25 <Cale> > map head . filter (null . tail) . group $ "mississippi"
21:24:26 <lambdabot>   "miiii"
21:24:35 <sshc> Cale: Yes, thanks!
21:24:35 <ivanm> oh, I get you now
21:24:41 <sshc> It's been a few months since I've written Haskell
21:25:09 <ivanm> concat rather than "map head" might be another alternative
21:25:23 <Cale> oh, yes
21:25:29 <Cale> > concat . filter (null . tail) . group $ "mississippi"
21:25:31 <lambdabot>   "miiii"
21:25:46 <Cale> It's equivalent, since the only thing left are lists of length 1
21:25:54 <djahandarie> Man, cabal is giving me trouble
21:25:58 <djahandarie>     Cabal-1.8.0.2-f1b96fbe00cb2101ed495d60417d9464 is shadowed by package Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a
21:26:05 <ivanm> dammit, lambdabot needs a @criterion plugini so we can tell which is better!
21:26:15 <djahandarie> Wow that's a good idea ivanm
21:26:20 <ivanm> djahandarie: ummm.... you explicitly installed a new version of Cabal...
21:26:21 <djahandarie> Where would the graphs go though? :P
21:26:32 <ivanm> djahandarie: just a command line response, e.g. "first version faster"
21:26:49 <djahandarie> It might not be conistantly better though!
21:27:04 <ivanm> djahandarie: criterion never promises anything though
21:27:15 <Cale> map head is probably a *little* faster
21:27:20 <ivanm> yeah
21:27:37 <ivanm> djahandarie: are both Cabal versions in global pkg db?
21:27:43 <Cale> concat will be finding the empty list at the end of each sublist and branching based on that
21:27:45 <ivanm> or did you have one with ghc and then tried to install it by hand?
21:27:52 <ivanm> Cale: right
21:28:28 <djahandarie> Oh you know, I think debian might have decided to go and install another version of cabal without telling me
21:28:31 <djahandarie> God damn it
21:28:43 <ivanm> djahandarie: it's the _same_ version though
21:29:16 * Cale wonders if he upgrades to the latest Ubuntu how much time he will have to spend removing PortAudio.
21:29:26 <ivanm> @tell QtPlatypus if you're still looking for work: http://blog.well-typed.com/2010/05/well-typed-are-hiring/
21:29:26 <lambdabot> Consider it noted.
21:29:26 <Cale> er, PulseAudio, sorry
21:29:39 <ivanm> Cale: twice as long as you did for the current version
21:29:47 <Cale> Probably
21:29:52 <shapr> Cale: PulseAudio is working fine in the latest ubuntu.
21:30:21 <ivanm> hey shapr
21:30:30 <ivanm> but what happens if you don't _want_ that abomination on your computer?
21:30:37 * ivanm 's solution is to not use ubuntu... >_>
21:30:46 <Cale> shapr: Well, last time, it took the few dozen volume controls on my sound card and hid them all behind a single master volume, and it fixed my headphone volume at 0%
21:30:56 <ivanm> except I have to at uni (unless I decide to manage the computer myself, which means even _more_ procrastination)
21:30:58 <BMeph> "Meet the new (Ubuntu), same as the old (Ubuntu)..." ;)
21:31:17 <shapr> I have had one problem with Ubuntu's user-friendliness...
21:31:21 <ivanm> BMeph: is that like "We have never been at war with ..." ?
21:31:35 <shapr> I plugged in a second wifi adapter via usb, and then wanted to use that to do 802.11 injection, and network manager freaked out all over the place.
21:31:43 <BMeph> ivanm: "No, we have _always_ been at war with..." ;)
21:31:55 <ivanm> oh, right
21:32:03 <ivanm> shapr: lol
21:32:26 <ivanm> shapr: to be fair, that is probably one thing that wasn't ubuntu's fault per se (unless its because they were using a pre-release version of NM... >_>)
21:32:56 * BMeph suspects that when shapr says "wifi adapter", he could just as well say "cousin", with no further modifications...
21:32:58 <djahandarie> ivanm, okay, I killed the debian one, but cabal is still complaining... how do I know which one to unregister?
21:33:44 <shapr> ivanm: Yah, in this case I don't *want* ubuntu to do user-friendly wifi adapter management, I want it to setup the interface and leave me alone.
21:33:56 <ivanm> djahandarie: check how old the files are in /usr/lib/ghc-<version>/package.conf.d/
21:34:14 <ivanm> shapr: "I want it to setup the interface" == user-friendly ;-)
21:34:28 <shapr> Yeah, but it went from friendly to control-freak.
21:34:39 <ivanm> djahandarie: and compare it to the other root libraries dates
21:34:52 <ivanm> shapr: heh, "my precious wifi adaptor! not yours! mine!"
21:35:00 <djahandarie> ivanm, only one of them is in there, and it matches all the rest of the root library dates
21:35:17 <ivanm> djahandarie: sure the other one isn't in user pkg config?
21:35:29 <shapr> network manager circled the wifi adapter as if it were poison for half an hour, then suddenly jumped on it like it was starving, and refused to let go of it until I ripped it out of the usb port.
21:35:30 <ivanm> djahandarie: what does "ghc-pkg check" say?
21:35:38 <ivanm> shapr: lol
21:35:51 <djahandarie> ivanm, it doesn't say anything... let me check usr pkg config
21:36:01 <andrewsw> shapr: there's a reason it's called "network mangler" on debian-user...
21:36:11 <ivanm> andrewsw: it is? really?
21:36:13 <p_l> so far, the most user friendly interface to configure wifi on linux, that I personally encountered, was manual editing of wpa_supplicant config. The others looked nice, but didn't always work, which is necessary for "user-friendly"
21:36:13 <shapr> My programs were confused since network-manager decided to connect both wifi adapters to the same access point, doing funny things to my routing tables.
21:37:01 <shapr> In any case, what hackages could I use to build a dependency chain for my college courses?
21:37:16 <andrewsw> what am I doing wrong with `res <- try $ print "foo"`, I get "Ambiguous type variable..."
21:37:30 <ivanm> I use NM solely because it lets me avoid thinking about which network (wired vs wireless) is up
21:37:30 <andrewsw> where try is Control.Exception.try
21:38:01 <ivanm> shapr: there's currently only one full hackage atm (roel's reverse dep one doesn't contain tarballs nor documentation)
21:38:11 <ivanm> andrewsw: in base methinks
21:38:13 <shapr> huh?
21:38:18 <ivanm> @hoogle try
21:38:18 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
21:38:19 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
21:38:19 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
21:38:23 <Cale> andrewsw: try :: (Exception e) => IO a -> IO (Either e a)
21:38:26 <andrewsw> ivanm: yup. for a while (several months or more) it was routinely suggested to apt{-get,itude} purge network manager
21:38:32 <Cale> andrewsw: It needs to know which e though
21:38:39 <ivanm> andrewsw: except since 6.10, there's two versions: Prelude's and Control.Exceptions
21:38:41 <shapr> hiya johnw
21:38:45 <johnw> hey shapr!
21:38:56 <ivanm> shapr> In any case, what hackages could I use to build a dependency chain for my college courses?
21:38:57 <Cale> andrewsw: If you were to pattern match on the result and did something which fixed the e in question, then it would work
21:39:00 <andrewsw> hmmm... I don't care which e
21:39:04 <shapr> ivanm: Wait, was that an answer to which package I could use to track dependencies?
21:39:32 <ivanm> shapr: yes, but you said _hackage_, not _package_ :p
21:39:39 <Cale> andrewsw: Then you can use the SomeException constructor when pattern matching the result
21:39:42 <ivanm> andrewsw: you can use SomeException, except that's frowned upon
21:39:43 <shapr> :-P
21:39:47 <Cale> case res of
21:39:49 <shapr> pedant!
21:39:55 <Cale>    Left (SomeException e) -> ...
21:39:56 <andrewsw> ah.
21:40:03 <andrewsw> I'm not afraid of frowning :(
21:40:25 <shapr> johnw: Writing any Haskell lately?
21:40:29 <ivanm> shapr: guilty as charged
21:40:47 <Cale> I don't see why it's frowned upon. You can also create your own exception types which catch any subset of the instances of Exception
21:40:49 <johnw> shapr: not a line
21:40:58 <ivanm> Cale: I think the docs say why it's bad
21:41:31 <shapr> johnw: Aww...
21:41:35 <Cale> SomeException is fundamental to the way that the new exception library works though...
21:41:37 <johnw> i'd love to
21:41:41 <johnw> in fact, that's why I came in
21:41:45 <johnw> to build up to it again
21:41:54 <shapr> Should I use erwig's graph library to build dependencies, or is there a better way?
21:41:59 <shapr> johnw: Yay!
21:42:06 <ivanm> andrewsw, Cale: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#4
21:42:21 <johnw> but tonight, C++
21:42:36 <ivanm> shapr: I would say use the new improved version of FGL, but we haven't even started coding yet... >_>
21:42:49 <shapr> oh
21:43:04 <Cale> Well, okay, if you're handling a specific error, then it's not what you want.
21:43:15 <Cale> But if you're handling all errors and just printing an error message, it's fine.
21:43:19 <ivanm> Cale: or a specific class of errors
21:43:38 <andrewsw> SomeException is just what I needed for this.
21:43:39 <andrewsw> thanks
21:43:55 <ivanm> Cale: right, for error _management_ (as in "oops, soemthing went wrong") rather than failback stuff it's probably OK
21:44:25 <andrewsw> yeah, this is a case of "something went wrong, don't care what it is."
21:44:52 <ivanm> "something went wrong (the universe ended); you should fix this!" ;-)
21:45:09 <andrewsw> exactly. where's my towel...
21:45:12 <Cale> of course, not much can go wrong when printing a value...
21:45:28 <andrewsw> Cale: when you're as noobish as me...
21:45:33 <ivanm> Cale: sure it can, the stdout buffer is full, etc. ... >_>
21:45:53 <ivanm> the user is trying to Ctrl-c (like the docs say) but you won't let it...
21:45:58 <andrewsw> Cale: seriously, though I was using a slightly more complicated expression on the right and didn't understand, so went to the base case
21:46:38 <shapr> Has anyone run HLint on the entirety of hackage?
21:47:12 <lispy> shapr: not that I know of, but that would be interesting
21:47:16 <glguy> Cale: printing negative floats on macports' GHC segfaults!
21:47:28 <glguy> there is plenty to go wrong :)
21:47:57 <ivanm> shapr: *shudder*
21:48:14 <ivanm> shapr: maybe you should suggest it to ezyang as his next project ;-)
21:48:25 * ivanm ignores several of hlints warnings though
21:48:39 <ivanm> e.g. if I'm using a list of Chars rather than a String, there's probably a reason for it...
21:48:48 <ivanm> glguy: really? how come?
21:48:55 <lispy> glguy: hey, I thought it was just reading them?
21:49:03 <glguy> isn't it both?
21:49:17 <lispy> ah, I thought awick said reading, but either way it's bad
21:49:21 <QtPlatypus> What is the diffrence between Strings and lists of Chars?
21:49:22 <lambdabot> QtPlatypus: You have 1 new message. '/msg lambdabot @messages' to read it.
21:49:32 <glguy> Prelude> (-1 :: Float)
21:49:32 <glguy> -Segmentation fault
21:49:42 <systemfault> glguy: Why didn't you just install the haskell platform?
21:49:49 <glguy> systemfault: I did
21:49:52 <ivanm> QtPlatypus: if I have a list of separator Chars, then I don't want to consider them as a String
21:49:55 <glguy> but I wanted 64-bit so I tried that first
21:50:35 <lispy> systemfault: The HP version of GHC uses apple's iconv, but anything you install with macports (think Haskell FFI libraries) uses macports iconv.  This leads to linker errors.
21:50:53 <systemfault> Ah ok
21:51:22 <lispy> glguy: next you could try building ghc from source and forcing it to use macports iconv :)
21:51:29 <QtPlatypus> Ah I now see your point
21:52:14 <lispy> Hmm...I think I found a cabal bug with "if impl(ghc >= 6.12)..."
21:52:39 <dcoutts_> lispy: mm?
21:53:15 <lispy> dcoutts_: in the darcs.cabal it has a line to use -fno-warn-unused-do-bind, but that gets ignored when I put it inside the previously mentioned guard
21:53:30 <ivanm> lispy: that's a known bug
21:53:36 <ivanm> you have to have a if true line before it
21:53:44 <dcoutts_> huh?
21:53:57 <dcoutts_> what known bug?
21:54:05 * ivanm finds the link
21:54:15 <lispy> Well, it does evaulate the ghc-options line (I can tell by using a bogus flag)
21:54:23 <glguy> is it a known bug if dcoutts doesn't know about it?
21:54:32 <dcoutts_> :-)
21:54:36 <ivanm> Cabal bug 656 I believe
21:54:48 <ivanm> whoops, not that
21:54:55 <ivanm> (read the wrong darcs commit message)
21:55:03 <ivanm> http://www.mail-archive.com/cabal-devel@haskell.org/msg05939.html
21:55:17 <ivanm> lispy: ^^ is that what you're talking about?
21:55:24 <lispy> ivanm: hmm...my naive attempt at what you suggested didn't help
21:55:26 <lispy> reading
21:56:09 * lispy tests it
21:56:26 <lispy> ivanm: yay!  works like a charm
21:56:32 <ivanm> \o/
21:57:06 <ivanm> dcoutts_: so it _is_ a known bug; I don't know if byorgey filed it though
21:57:20 <dcoutts_> lispy: since nobody seems to have filed that bug, would you mind doing so, give the example
21:57:44 <glguy> Does that require a trac account?
21:57:50 <lispy> Oh boy.  Depends on if I need a trac account :)
21:57:55 <dcoutts_> there's the guest account
21:57:57 <ivanm> nope, anonymous works
21:58:01 <lispy> \0/
21:58:04 <ivanm> bug 656 is one that I filed in that way
21:58:12 <ivanm> byorgey: tsk, tsk, not even filing bugs when you say you will...
22:02:21 <lispy> http://hackage.haskell.org/trac/hackage/ticket/684
22:02:29 <lispy> dcoutts_: is that enough info?
22:03:34 <dcoutts_> lispy: I guess so, thanks.
22:04:05 <glguy> popquiz a b = (a ⊃ b) ⊃ b  -- name that logic operator!
22:05:07 <lispy> it looks like subset
22:05:09 <dobblego> reverse implication
22:05:15 <lispy> as in, b is a subset of a
22:05:16 <dobblego> *inverse
22:05:50 <ivanm> lispy: except dcoutts_ isn't on the internets atm as he's busy writing his thesis up, so it's unlikely that will get fixed
22:05:57 <glguy> ⊃ as material implication
22:06:03 <glguy> popquiz as the function name
22:06:06 <lispy> ivanm: I'm writing a patch to use the workaround :)
22:06:15 * ivanm notes that it is currently impossible to use cabal 1.8's new executable-depending-on-library feature if you want documentation built
22:06:28 <ivanm> lispy: except that workaround shouldn't be needed...
22:07:22 <fax> modus ponens
22:07:37 <fax> wait no
22:07:40 <dobblego> ($)
22:08:07 <fax> glguy: it's not a tautology thuogh
22:08:36 <glguy> I didn't say "name that tautology" :-p
22:08:57 <glguy> there is a common name for the function with that same truth table
22:09:27 <fax> @let False --> _ = True ; _ --> x = x
22:09:28 <lambdabot>  Defined.
22:10:10 <fax> > liftA2 (\x y -> b --> (b --> a)) [True,False] [True,False]
22:10:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:10:12 <lambdabot>         against inferred type ...
22:10:31 <glguy> ⊃ is like ->
22:10:52 <fax> oh I was reading it backwards
22:13:30 <dobblego> unsafeCoerce :)
22:13:58 <glguy> you guys are killing me :0-p
22:14:19 <fax> why did you write it just the subset symbol?
22:15:37 <glguy> an attempt to make it more obvious that I was defining a binary truth function
22:15:40 <glguy> fail :)
22:15:41 <glguy> > let False --> _ = True; _ --> x = x in liftM2 (\x y -> (x --> y) --> y) [True,False][True,False]
22:15:42 <lambdabot>   [True,True,True,False]
22:15:55 <fax> OR ??
22:15:57 <glguy> yeah
22:16:12 <fax> ;/
22:16:12 <glguy> I pasted an untyped call/cc earlier and someone got it right away
22:16:16 <glguy> I figured that this would be easier
22:16:16 <fax> loll
22:16:25 <fax> domain knowledge
22:17:31 <dobblego> OR doesn't have the same truth table as (->)
22:17:46 <fax> ??
22:17:59 <dobblego> T -> F = F
22:18:04 <glguy> <_<
22:18:06 <glguy> >_>
22:18:11 <sshc> Is there a standard function that inserts something in between every element in a list?
22:18:19 <lispy> sshc: intercalate?
22:18:20 <glguy> intersperse
22:18:22 <dobblego> sshc, intersperse/intercalate
22:18:32 <glguy> dobblego: glguy: popquiz a b = (a ⊃ b) ⊃ b  -- name that logic operator!
22:18:33 <sshc> f " " ["some", "words"] -> ["some", " ", "words"]
22:18:42 <lispy> is intercalate the composition of concat and intersperse?
22:18:46 <glguy> yes
22:18:49 <applicative> > intersperse 'a' "hhhhhhhh"
22:18:49 <lambdabot>   "hahahahahahahah"
22:18:55 <dobblego> glguy, oh I completely misunderstood until you repeated it, sorry
22:19:04 <sshc> > intercalate " " ["some", "words"]
22:19:05 <lambdabot>   "some words"
22:19:10 <sshc> :D
22:19:15 <sshc> Thanks!
22:19:28 <lispy> sshc: in that example, just unwords
22:19:35 <lispy> > unwords ["some", "words"]
22:19:36 <lambdabot>   "some words"
22:19:55 <sshc> unsword could haev worked in that case, which is why I suppose I chose a poor example.
22:20:03 <lispy> kk
22:20:06 <dobblego> @type fmap fmap fmap concat intersperse
22:20:07 <lambdabot> forall a. [a] -> [[a]] -> [a]
22:20:10 <sshc> I also overlooked that intercalate also concats
22:20:15 <sshc> :t intercalate
22:20:16 <lambdabot> forall a. [a] -> [[a]] -> [a]
22:20:21 <lispy> :t intersperse
22:20:22 <lambdabot> forall a. a -> [a] -> [a]
22:20:22 <sshc> @src intercalate
22:20:23 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
22:20:45 <sshc> > intersperse " " ["some", "words"]
22:20:46 <lambdabot>   ["some"," ","words"]
22:20:50 <sshc> Ah!
22:21:07 * sshc loves enlightenment
22:21:15 <lispy> intercalate == python's string.join
22:21:28 <glguy> fax: I was watching a video on youtube today about the discovery of the memristor and the speaker mentioned how you can construct all of the logic operators with material implication and False
22:21:36 <glguy> so I was playing around with that
22:22:02 <fax> glguy: if you said 'implement OR using ->' I could do it.. but going the other way is much harder!
22:22:07 <lispy> glguy: as in, nor is universal?
22:22:22 <fax> now I have an urge to turn truth tables into -> programs
22:23:09 <glguy> I wrote a program that generate all expresions with A B ⊃ FALSE (for arbitrary A and B) using logict to search around for things
22:23:20 <glguy> I used logict to get the fair backtracking >>- :)
22:23:55 <fax> what does it result in?
22:24:27 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25379#a25379
22:24:29 <glguy> for example
22:24:41 <applicative> the so-called sheffer stroke "neither ...nor' can do them all, familiarly.  not p = neither p nor p  etc
22:26:00 <fax> ah cool
22:26:04 <lispy> glguy: why does it print A -> False, twice for not?
22:26:13 <glguy> it doesn't eliminate duplicates
22:26:22 <glguy> just searches blindly
22:26:33 <glguy> I didn't want to spend a bunch of time on it, I just wanted to see it go :)
22:27:21 <glguy> the only pruning that I did was to eliminate x ⊃ y  where x == y
22:28:14 <glguy> (it returns 3 results from each search and moves on)
22:28:36 <applicative> its funny, or is the only one that doesn't need False, in your list.   (A -> B) -> B  and the other way round, since it's symmetric
22:30:25 <fax> glguy: can you search for (0,0)-->(0,0), (1,0)-->(1,0), (0,1)-->(1,0), (1,1)-->(1,1)   (adder)
22:30:54 <fax> wait
22:31:00 <fax> how do you even do multiple outputs?
22:31:08 <fax> does that just means shared subexpressions
22:31:09 <glguy> with two expressions
22:31:20 <glguy> one xor
22:31:21 <glguy> one and
22:31:23 <fax> (I am wondering how there is a 3x reduciton in size)
22:32:00 <glguy> where did you hear 3x in size (the speaker said that, but I certainly didn't mention it) did you watch that video?
22:32:08 <glguy> what's going on here... get out of my head!
22:32:54 <applicative> fax is like that
22:36:33 <glguy> fax it might not be that implication is small but that the other gates are big
22:37:08 <lispy> I'm just reading this: http://www.haskell.org/haskellwiki/Maintaining_laziness#Maybe.2C_Either.2C_Exceptions  Would, Maybe (Foo, String) be as 'lazy' as (Maybe Foo, String)
22:39:35 <ivanm> I think that suggestion is wrong
22:40:04 <ivanm> IMHO, in most cases if it can't get the entire String then it should fail completely, not give me a "but I got this out of it for you!" message
22:40:51 <lispy> Yeah.  That seems pretty reasonable to me too
22:41:26 <ivanm> lispy: and the "Maybe" is there inside the tuple because there might be an error message AFAICT
22:41:48 <ivanm> whereas with your variant, the Foo is required only if the Maybe is Nothing... which doens't make sense :s
22:42:36 <lispy> ivanm: well, the Maybe (Foo, String) is in alignment with what you said.  It either produces a value and the remainder, or it just plain fails.
22:42:55 <ivanm> hmmmm.... could be
22:43:04 <ivanm> or I could just use a lazy parser >_>
22:43:37 <glguy> this sounds like a job for asynchronous exceptions!
22:44:05 <lispy> Yeah, I was wanting to convert this parser to an iteratee based parser.  Right now it's a strict parser that produces a lazy list.  Which means it's hard to use, but the parsing step doesn't leak.
22:44:25 <ivanm> hmmmmm....
22:44:35 <lispy> (by hard to use, I mean, consuming the list it generates can lead to leaks)
22:44:45 * ivanm blindly uses polyparse's lazy parser and bitches to malcolmw when something is too lazy or it doesn't work
22:44:59 <lispy> I'm thinking that the parsing step may not need to be an iteratee, but instead I should transform the Maybe (Foo, String) part to iteratee style
22:45:19 <lispy> :t unfoldr
22:45:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
22:45:52 <lispy> ah yeah, it's exactly perfect for unfoldr
22:46:03 <ivanm> \o/
22:46:12 * lispy wonders if iteratee has a way to convert something suitable for unfoldr to an enumerator
22:46:21 <ivanm> lispy: I take it Foo is the value you've parsed?
22:46:27 <lispy> ivanm: aye
22:46:47 <ivanm> then yes, your variant definitely makes more sense ;-)
22:46:57 <ivanm> AFAICT the wiki page used the Maybe for an error message, not the parsed value
22:47:06 <lispy> You're right
22:47:12 <ivanm> lispy: are you rolling your own parser or something?
22:47:26 <lispy> I'm trying to improve an existing parser
22:47:34 <lispy> The darcs patch parser, actually
22:47:42 <ivanm> ahhhhh
22:47:52 <ivanm> wait, so darcs is now going to dep on iteratee as well? >_>
22:48:56 <lispy> having darcs use iteratees is a pet project of mine.  But it's tricky.  We use a custom type threaded list internally (for proof properties), and that's not going to jive with using iteratees.
22:49:14 <lispy> The other direction I've considered is a zipper
22:49:21 <lispy> And the zipper could work with the type threading
22:49:38 * ivanm has never worked out what iteratees even does
22:49:50 <ivanm> I see all these parsing libraries using it.... but don't get what's the point
22:49:52 <lispy> iteratee == complicated idiom for doing left folds
22:50:35 <lispy> Basically, the left fold gives  you a way to encapsulate resource usage patterns.  So you have better ability to control for speak leaks
22:50:43 <lispy> If you're consuming a stream it's really nice
22:50:51 <lispy> Like if you're reducing a stream down to a value
22:51:10 <glguy> git?
22:51:20 <lispy> glguy: you're a punk :)
22:51:29 <ivanm> hmmm.... I kinda get that
22:52:35 <lispy> glguy: with all the extra type safety we put into darcs and your interest in agda, I'm surprised you're not more interested in improving darcs :)
22:52:56 <lispy> glguy: add your must-have features for git, improve the performance a bit, and bam!
22:53:38 <glguy> the agda interest kind of screws up my haskell type interest
22:53:59 <Ke> I just can't get using inferior product only because it's written in haskell
22:54:09 <Ke> !
22:54:10 <lispy> ivanm: this page might help: http://www.haskell.org/haskellwiki/Enumerator_and_iteratee
22:54:11 <glguy> oh snap
22:54:38 * lispy cries
22:54:40 <ivanm> Ke: you mean darcs vs git?
22:54:45 <Ke> yes
22:54:51 <ivanm> define "inferior product"
22:54:54 <glguy> "darcs"
22:54:56 <Ke> slow
22:54:56 <glguy> haha!
22:54:59 <ivanm> I find darcs' interface and theory superior
22:55:07 <ivanm> @slap glguy
22:55:07 * lambdabot pushes glguy from his chair
22:55:11 <ivanm> and haven't had any speed problems with darcs
22:55:20 <glguy> darcs is great if you are working on something by yourself
22:55:29 * lispy wonders if glguy likes practical jokes -- I know where you sit at work!
22:55:31 <ivanm> plus, if I have a problem with darcs, I"m more likely to be able to get help from someone about it
22:56:01 <ivanm> lispy: so you'll find out on Monday if he likes being the butt of practical jokes? :p
22:56:52 <lispy> ivanm: yeah, pay back for all the darcs vs. git barbs :)
22:56:57 <ivanm> lispy: hmmmm, that link kinda helps
22:57:02 <ivanm> lispy: :D
22:57:12 <glguy> lispy: I'm guessing you wouldn't want to open that realm of possibilities :-D
22:57:15 <ivanm> I also like using darcs precisely _because_ git is popular
22:57:29 <Ke> heh
22:58:02 <lispy> The most compelling argument I've heard for git is github
22:58:20 <lispy> I wonder if patch-tag has caught up
22:58:36 <ivanm> lispy: I _hate_ github
22:59:09 <glguy> Also I heard that metacity is the best window manager
22:59:14 <ivanm> lol
22:59:16 <Ke> well there are a lot more tools for git
22:59:18 <glguy> and that vim is a better editor than emacs
22:59:39 <glguy> ...strong types are for weak minds...
22:59:43 <ivanm> lispy: because it's now too easy for people to start up throw-away projects and tell people to "get it off github" without making real releases
22:59:48 <glguy> Fedora is better than Ubuntu
22:59:50 <glguy> and...
22:59:59 <ivanm> you should _never_ expect/require end users to use HEAD
22:59:59 <Ke> should darcs linux and do some benchmarks
23:00:05 <lispy> ivanm: open source == lazy :)
23:00:09 <ivanm> Ke: you mean the kernel?
23:00:13 <ivanm> lispy: I beg to differ
23:00:13 <Ke> yes
23:00:20 <glguy> oh, I know
23:00:24 <glguy> dogs make better pets than cats
23:00:27 <ivanm> if I was lazy, I wouldn't bother playing with my OS
23:00:34 <ivanm> glguy: we get the point, you can stfu no
23:00:35 <ivanm> *now
23:00:43 <glguy> it was the emacs comment, wasn't it
23:00:51 <ivanm> no
23:00:56 * wli wonders how one would convert the history to darcs' format.
23:01:03 <ivanm> well, in the sense that it was the 2nd one
23:01:05 <glguy> there are a few tools out there
23:01:07 <lispy> Seriously, can we has an irc op to ban the troll ;)
23:01:17 <glguy> (for converting between formats)
23:01:29 <ivanm> lispy: you just need the magic "@where ops" incantation!
23:01:44 <glguy> I don't want to have to ban ivanm
23:01:45 * lispy used to be an op here
23:02:07 * ivanm tries to work out how he's a troll...
23:02:21 <glguy> wli: there are a few tools for converting and they each seem to be good at different kinds of things
23:02:29 <lispy> These types are so incomprehensible: http://hackage.haskell.org/packages/archive/iteratee/0.3.5/doc/html/Data-Iteratee-Base.html
23:02:41 <glguy> in converting darcs repos to git I found that I just had to try a variety of them on each repository to see which would succeed
23:02:57 <ivanm> lispy: ugh
23:03:13 <Ke> ivanm: anyways only argument I have heard for darcs is "simple"
23:03:21 <Cale_> http://web.archive.org/web/20070606182509/http://zooko.com/badmerge/concrete-good-semantics.html
23:03:28 <Cale_> ^^ this makes a good argument for darcs
23:03:29 <dolio> lispy: Yeah, I was looking at that earlier.
23:03:39 <Cale_> (unfortunately the original seems down)
23:03:55 <dolio> It's not very clear what I'm supposed to do with those.
23:04:11 <ivanm> Ke: have you seen the camp video?
23:04:13 <glguy> The types make sense once you spend a few hours with them
23:04:23 <Ke> ivanm: nope
23:04:35 <ivanm> Ke: http://projects.haskell.org/camp
23:05:05 <lispy> glguy: in particular, I was hoping there would be a type to help me go from (a -> Maybe (b, a)) to an enumerator over b
23:05:25 <ivanm> damn, the video isn't prominent anymore
23:05:31 <applicative> Ke, simple is the best possible argument
23:05:45 <ivanm> Ke: http://projects.haskell.org/camp/unique
23:05:57 <lispy> Ke: the darcs/camp folks have a lot more emphasis on trying to make a robust formalism (with proveable properties about the implementations).  Which matters to me, but maybe not to Joe-Hacker.
23:06:06 <ivanm> lispy: true
23:06:26 <Cale_> Basically, many of the revision control systems ignore the history of patches when doing a merge, instead taking just 3 points in the history (the two branches and the point from which they branched off) to decide how to do the merge. Not making use of all the other information available can result in unintuitive bad merges.
23:06:27 <lispy> Camp has quite a bit of Coq proofs for it
23:06:28 <glguy> Does darcs still attempt to perform a merge when you push to a remote repository?
23:06:40 <ivanm> glguy: a "merge"?
23:06:45 <glguy> cale	git actually isn't in that category
23:06:53 <Cale_> (and ones, as that page shows, which still result in compiling, though incorrect, code!)
23:06:58 <lispy> glguy: well yeah, no one has tried to 'fix' that since the other day when you explained it to me :)
23:07:01 <glguy> ivanm: create state that you haven't seen before on push
23:07:17 <applicative> git is a black box, so far it seems to work, but i think it will turn everything to white noise on Aug 12, sometime after Facebook starts charging ....
23:07:49 <ivanm> glguy: well, shouldn't all VCS do that in case of inconsistent patches (i.e. the repo changed since you last pulled and now your repo won't work)?
23:07:57 <ivanm> applicative: huh?
23:08:13 <glguy> nope, they should always require you to pull again
23:08:20 <applicative> I was trying to formulate a paranoid meme to spread against git.
23:08:23 <glguy> there is no telling what you are creating when you make new state on a push
23:08:40 <applicative> no one knows how it works, they just trust it.   This is my starting point
23:08:48 <ivanm> glguy: but that will break the other repository!
23:08:55 <glguy> huh?
23:08:56 <ivanm> applicative: hmmm..... I like it! :D
23:09:20 <Cale> I wish Facebook would start charging. It would be suicide, and then I could continue to ignore its existence with fewer annoyances.
23:09:28 <ivanm> glguy: if you push to a remote repo (which for all intents and purposes is usually a central one), how do you tell if your patch will break it?
23:09:34 <ivanm> Cale: heh
23:09:41 <lispy> ivanm: glguy is talking about how darcs is happy to create a new set of patches in the history (via merge not record), whether that set of patches is locally (where you can inspect the result) or remotely.
23:09:54 <applicative> The git algorithm is to patch and so forth .... until Aug 12 2010, then replace it all with ... whitespace
23:09:55 <ivanm> oh
23:09:56 <glguy> ivanm: when you push to a repository you should have all o the patches that that repository has
23:09:58 <glguy> and only add new ones
23:10:35 <ivanm> then again, git sucks as well; don't a lot of companies still use perforce because it scales better than git?
23:11:06 <glguy> I think that comes up if you have massive binary blobs in your revision control
23:11:46 <lispy> ivanm: I would have guessed because they are entrenched and sometimes (mostly with binary files) you do want to be able to do an organization wide file lock in the repo.  Perforce is good at both (entrenching and obessively locking)
23:12:15 <lispy> I used Perforce for 2 months and, it's actually a lot worse than SVN :)
23:12:16 <ivanm> yeah, I think the reasons given are usually to do with binary blobs
23:12:29 <glguy> applicative: you should associate it with the Mayan calandar
23:12:39 <lispy> Google uses Perforce internally and is probably the biggest Perforce client in the world
23:13:25 <glguy> \o/ baby fell asleep!
23:18:59 <EvanR> this is insane. im trying to go back to my c program, and i cant seem to solve problems anymore, because i dont have first class, higher order functions, lazy evaluation, algebraic data types, pattern matching, among other things
23:19:24 <EvanR> i keep wanting to implement a subhaskell
23:20:15 <fax> EvanR, haha this is what happens when you learn haskell
23:20:21 <Ke> ivanm: changes might depend on other changes that do not actually modify the same line, I think the example in the video might not always be relevant
23:20:38 <Ke> (and typically do depend on)
23:20:46 <glguy> fax: isn't that the phenomenon that lead to "SHE"?
23:20:59 <fax> sounds likely
23:21:48 <applicative> i'm thinking Linus is really into the Mayan calendar.  Git is so fast .... because it doesn't have to worry about anything after Aug 12 2010
23:21:57 <EvanR> lol
23:21:58 <Ke> =D
23:22:14 <EvanR> quote that
23:22:23 <lispy> glguy: I have an iteratee question about enumerators
23:22:32 <lispy> glguy: enumerator == fold, right?
23:22:49 <glguy> When I said that it only takes a few hours to understand the types I didn't mean that you only had to do it once
23:22:58 <lispy> hehe
23:23:15 <lispy> ?remember <glguy> When I said that it only takes a few hours to understand the types I didn't mean that you only had to do it once
23:23:15 <lambdabot> Done.
23:23:59 <lispy> glguy: I was trying to understand the difference between EnumeratorN and EnumeratorGM.  See http://hackage.haskell.org/packages/archive/iteratee/0.3.5/doc/html/Data-Iteratee-Base.html
23:24:17 <applicative> Join my facebook society "Can we get 4000000 rubyists to say, Please Linus, don't turn all our 'code' to whitespace on Aug 12 2010!!"
23:24:41 * glguy 's first reaction to the shape of applicative msg was that it waas spam and that I needed to op
23:24:53 <glguy> "Join my facebook society... [triggered]
23:25:19 <applicative> glguy:  sorry, it was in very bad taste.
23:25:21 <glguy> lispy: ok, let me spin back up
23:25:25 <EvanR> how hard can haskell be to implement on a basic level
23:25:27 <glguy> applicative: no, you're fine!
23:25:40 <glguy> I'm just explaining my initial, corner of the eye reaction
23:25:42 <lispy> EvanR: As hard as you want it to be? :)
23:25:56 <EvanR> great, not hard thanks
23:26:03 <glguy> lispy: OK, let me spin up
23:26:30 * lispy puts glguy in a salad spinner and starts pressing the button
23:27:11 <johnw> GHC doesn't like make -j
23:27:21 <johnw> (building the compiler, that is)
23:29:06 <glguy> lispy: I believe that the difference is that one is used for changing the underlying stream type while the other is for consuming some elements and producing a new one. This is the building of horizontal vs vertical parsers
23:29:40 <lispy> hmm
23:29:58 <glguy> so you could use an enumeratorN to transform an enumerator than runs on bytes to one that operates on base64 encoded bytes
23:31:59 <opqdonut> applicative: what were you referring to with that?
23:32:30 <lispy> glguy: so, what would that look like with types.  The nested iteratee would still mention bytes and the outer one would mention base64?
23:32:35 <Ke> Cale: anyone sane doing the merge would notice that kind of an error from the diff, but yes that could be a problem
23:32:43 <edwardk> preflex: xseen jbapple
23:32:43 <preflex>  jbapple was last seen on freenode/#haskell 15 hours, 10 minutes and 25 seconds ago, saying: Did everyone see this: http://focalize.inria.fr/ ? "a programming environment to develop certified programs. The environment is based on a functional programming language with object-oriented features. The language allows the programmer to write formal specifications and proofs of the program in a unified
23:32:44 <preflex>  and consistent setting."
23:33:40 <jbapple> heyHEYhey
23:34:59 <ivanm> opqdonut: <applicative> I was trying to formulate a paranoid meme to spread against git.
23:35:29 <glguy> lispy -> PM
23:35:47 <lispy> glguy: thanks.  I was still reading :)
23:38:41 <opqdonut> ah
23:48:36 <lispy> :t lift
23:48:37 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:50:36 <fax> :t drop
23:50:37 <lambdabot> forall a. Int -> [a] -> [a]
23:51:09 <glguy> :t break
23:51:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:51:24 <glguy> :t fix
23:51:25 <lambdabot> forall a. (a -> a) -> a
23:51:37 <fax> XD
23:51:49 <glguy> do try to be more careful!
