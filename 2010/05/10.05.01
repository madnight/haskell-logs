00:11:22 <elly> :t &&&
00:11:24 <lambdabot> parse error on input `&&&'
00:11:27 <elly> :t (&&&)
00:11:28 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:11:48 <elly> rats
00:11:51 <elly> @hoogle &&&
00:11:51 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
00:12:06 <elly> I swear there was a saner version around
00:12:08 <elly> :t (&&)
00:12:09 <lambdabot> Bool -> Bool -> Bool
00:12:11 <elly> nope
00:12:50 <opqdonut> what do you want?
00:12:52 <glguy> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)
00:12:53 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
00:13:00 <elly> yes
00:13:04 <elly> what glguy said was the type I wanted
00:13:05 <elly> excellent
00:13:18 <glguy> In the original type a = (->)
00:16:54 <humasect> thanks everyone! take care=) =)
00:19:24 <mamalujo> how come Disambiguate Record Fields doesn't allow the same name to be used within the same module? Yet its fairly easy to use a type class based disambiguation that would work?
00:20:24 <ivanm> what is Disambiguate Record Fields?
00:20:42 <mamalujo> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#disambiguate-fields
00:20:53 <ivanm> but I would hazard a guess because it doesn't make sense as they would be two functions with the same name but different types
00:21:42 <mamalujo> yes that must be it, but why doesn't it generate a type class with two instances instead?
00:21:51 <ivanm> because it isn't a type class...
00:22:44 <shrughes> so how's that toy interpreted language going?
00:25:04 <mamalujo> well, it seems a shame that its not, thats all I'm saying, how come they implemented some disambiguation system, yet one incapable of doing something a rather naive approach could. Perhaps theres some efficiency problem?
00:27:06 * ivanm has no idea what mamalujo is talking about
00:27:16 <ivanm> why should they use a type class? records /= type class
00:27:40 <ivanm> the current record system is a compromise since the original committee couldn't agree on what the one true record system should look like
00:28:04 <ivanm> that disambiguation system you're referring to in GHC probably uses per-module namespacing
00:37:57 <mamalujo> ivanm, well, I know how the current situation arose; simply its a common complaint and some pseudo-overloading system that doesn't use type classes was suggested (http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution). I'm just wondering what's wrong with more obvious approaches.
00:38:19 <ivanm> whereas I wonder why this is even a problem for anyone
00:38:38 <ivanm> however, I'm not sure how you propose this "let's automatically make a typeclass thing" is going to work
00:39:17 <ivanm> since the way it's being treated there isn't even as a function, so a type class isn't even relavent
00:40:01 <mamalujo> ivanm, well, mangling names locally in a module definitely isn't difficult. But its surely not particularly pretty either
00:41:05 <mamalujo> what do you mean, isn't treated as a function? thats all record declaration creates, accessor functions, right?
00:41:48 <ivanm> mamalujo: that extension disambiguates between records when used like foo { x = bar }
00:44:12 <ivanm> in that situation, x isn't a function
00:45:19 <roconnor> > 2*1000^3
00:45:20 <lambdabot>   2000000000
00:48:27 <mamalujo> ah, you were refering to the disambiguate fields extension. you are right, its an orthogonal issue.
00:49:50 <ivanm> exactly
00:50:00 <ivanm> which was what you were originally talking about
01:05:30 <Cale> mamalujo: Typechecking and inference becomes more difficult if you don't know what it is that variables refer to.
01:07:54 <ivanm> hey Cale
01:10:21 <sungji> good morning :)
01:11:09 <sungji> does anyone know how to correct lines 10 and 12 here (http://gist.github.com/385880) to get a valid induction proof?
01:20:30 <roconnor> > 't'
01:20:31 <lambdabot>   't'
01:27:58 * hackagebot HTicTacToe 0.2 - An SDL tic-tac-toe game.  http://hackage.haskell.org/package/HTicTacToe-0.2 (KorcanHussein)
01:46:47 <nyachtung> hi. I tried to think about exponentials in a category of functors but haven't succeeded. Are they possible?
01:48:23 <hiato> Hello all
01:48:35 <pastorn> yo
01:50:15 <hiato> Yet another beginner question today: How do I list a handle as part of a data constructor? Let's say I have data Abc = Abc { xyz :: Handle }. How do I then call Abc pqr? I have tried Abc (Handle pqr), but i can't seem to get that to work
01:52:45 <pastorn> @type hPutStrLn
01:52:46 <lambdabot> Not in scope: `hPutStrLn'
01:53:02 <pastorn> @hoogle hPutStrLn
01:53:03 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
01:53:03 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
01:53:03 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
01:53:26 <pastorn> hiato: hPutStrLn (xyz myABC) "lol i got printed"
01:54:26 <hiato> oh, so I have to use a hadle function of it first then?
01:55:07 <pastorn> hiato: read this: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
01:56:32 <hiato> pastorn: I'm not entirely sure what you're getting at
01:56:55 <pastorn> hiato: it seems that you're not entirely sure on how to use records
01:57:59 <hiato> Well, possibly. I can use them just fine so long as they dont take other data constructors like handle
01:58:18 <pastorn> hiato: what do you even mean by that?
01:59:06 <pastorn> data MyRec = MR { a :: Maybe Int, b :: Either String Float }; someRec = MR { a = Just 4, b = Left "lol" }
01:59:07 <hiato> data Msg = Msg { sig :: String, channel :: String, body :: [String] } deriving (Show, Read, Eq)
01:59:10 <hiato> data Bot = Bot { socket :: Handle, server :: String, port :: Int, chan :: String, nick :: String, eval :: Msg -> Msg }
01:59:14 <hiato> whoops
01:59:21 <hiato> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25259#a25259
01:59:38 <pastorn> hiato: irc bot?
01:59:43 <hiato> pastorn: you but ya
01:59:52 <hiato> and the framework is all good
01:59:55 <pastorn> but why aren't you using the IRC library?
02:00:02 <pastorn> Network.IRC
02:00:10 <hiato> More fun this way
02:00:15 <pastorn> hiato: cabal install irc; import Network.IRC
02:00:18 <pastorn> no it's not :/
02:00:27 <hiato> Is to me :)
02:00:46 <hiato> Point being, how do I call the data constructor for bot?
02:01:12 <pastorn> hiato: in GHCI
02:01:14 <pastorn> :
02:01:16 <pastorn>  :t Bot
02:02:01 <hiato> Yeah?
02:02:42 <hiato> What I'm asking is how do I parse an anrbitrary handle, say, meHandle?
02:02:56 <pastorn> you never parse a handle
02:03:02 <pastorn> you obtain them
02:03:06 <ClaudiusMaximus> @hoogle a -> IO Handle
02:03:06 <lambdabot> Control.Exception evaluate :: a -> IO a
02:03:06 <lambdabot> Control.OldException evaluate :: a -> IO a
02:03:06 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
02:03:09 <hiato> So then it's a bad data type?
02:03:22 <pastorn> hiato: no, you should still have your handle in you Bot type
02:03:31 <pastorn> but you should get it through connectTo
02:03:39 <pastorn> @type connectTo
02:03:40 <lambdabot> Not in scope: `connectTo'
02:03:48 <pastorn> @hoogle connect
02:03:48 <lambdabot> Network.Socket connect :: Socket -> SockAddr -> IO ()
02:03:48 <lambdabot> Network.HTTP.Base CONNECT :: RequestMethod
02:03:48 <lambdabot> Network.Socket Connected :: SocketStatus
02:04:04 <pastorn> hiato: let me check my code
02:04:21 <hiato> < hiato> oh, so I have to use a hadle function of it first then? <--- Guess my hunch was right. Ok, thanks :)
02:04:31 <ClaudiusMaximus> @hoogle connectTo
02:04:31 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
02:04:31 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
02:06:32 <hiato> Meh, tha's clumsy
02:06:49 <pastorn> no it's not
02:07:13 <hiato> So I have to give some func all the data for the bot type, let it wrap the handle connection and then return the filled bot... eh
02:07:19 <pastorn> type HostName = String
02:07:25 <pastorn> data PortID
02:07:27 <pastorn>   = Service String | PortNumber PortNumber | UnixSocket String
02:07:48 <ClaudiusMaximus> hiato: you can have partially filled records
02:07:57 <hiato> ClaudiusMaximus: Oh, how so?
02:08:19 <pastorn> hiato: just don't define the parts of the record
02:08:25 <pastorn> it'll be undefined, almost
02:08:42 <hiato> Ah, so the explicit constr then. Cool, thanks guys
02:08:42 <pastorn> hiato: it'll give you lots of warnings, but you can :)
02:09:16 <ClaudiusMaximus> have defaultBot = { handle = error "unconnected", ... } then have:  connect (:: Bot -> IO Bot) = \b -> do { h <- connectTo ...; return b{ handle = h } }
02:09:19 <hiato> Heh, yeah, quite a few :P But nice trick
02:09:42 <ClaudiusMaximus> then do realBot <- connect defaultBot
02:09:48 <pastorn> hiato: or just create the handle at startup, like normal people :p
02:09:58 <hiato> ClaudiusMaximus: Yeah, that's a nice one
02:10:05 <hiato> pastorn: Nevar :P
02:10:08 <ClaudiusMaximus> or use Maybe Handle if you don't want code explosions in your face
02:10:19 <hiato> Even butter :)
02:10:25 <hiato> *e
02:10:44 <pastorn> hiato: here's my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25260#a25260
02:11:00 <hiato> and with maybe I dont have to change any of my interfaces - woo
02:11:24 <pastorn> 'server' and 'port' are constants defined in Conf.hs
02:11:41 <hiato> pastorn: nice stuff
02:11:55 <hiato> but yeah, I see how it coould be done
02:14:22 <hiato> Blarg, no, nevermind, it's not liking Just $ socket xyz. Meh, I guess hGetLine and such don't wrap maybe
02:14:59 <Saizan> wrap^
02:15:00 <Saizan> ?
02:15:23 <hiato> Er, accept the moand interface
02:15:43 <Saizan> what's the type of socket and xyz?
02:16:36 <hiato> Saizan: data Bot = Bot { socket :: Maybe Handle ...
02:16:54 <hiato> and xyz :: Bot
02:17:08 <pastorn> hiato: you shouldn't have a Maybe Handle
02:17:15 <pastorn> you should just connect and put it there
02:17:15 <hiato> Oh?
02:17:21 <hiato> Bleh
02:17:32 <hiato> ok, and do partial records
02:17:37 <pastorn> connect :: Server -> Port -> IO Bot
02:17:39 <pastorn> no
02:17:43 <pastorn> don't do that
02:17:44 <hiato> (but I liked maybe)
02:17:49 <pastorn> it's an excellent way of crashing
02:17:58 <hiato> Ah, ok
02:18:03 <pastorn> hiato: the rule of thumb is this:
02:18:16 <pastorn> don't do error handling unless there's a meaningful way to recover
02:18:21 <Saizan> "Just $ socket xys" would be of type Maybe (Maybe Handle), but i don't see the utility
02:18:33 <hiato> Saizan: and that it is
02:18:39 <hiato> pastorn: Ok, noted
02:19:21 <Saizan> i mean, i don't see the point of Just, or how that's related hGetLine
02:19:44 <hiato> but wait, pastorn, then were back to  < hiato> So I have to give some func all the data for the bot type, let it wrap the handle connection and then return the filled bot... eh - no?
02:19:53 <pastorn> hiato: so using Maybe will just clutter your code
02:20:22 <pastorn> hiato: that doesn't even make sense...
02:21:36 <hiato> Saizan: As I cant seem to use something for a Handle in the constructor, I need to use a connection first before I can construct a Bot. But, in doing so, it means I have to parse info for all the other pieces of the constructor for that bot to that function
02:23:17 <hiato> So, it was suggested to: a) use incomplete records (bad style) b) use maybe for the handle c) use empty records with handle to create a new one d) make a connection then creat a record
02:24:25 <hiato> I'm not really that knowledgable about haskell, so I can imagine that this probably doesn't make much sense
02:24:39 <Saizan> i'd have a record type that representins the configuration, and a different record type that represents a connected bot
02:24:57 <hiato> I was just thinking that, yeah, I'll go with that
02:25:16 <Saizan> the firs twill have fields like server address, nick, password, the other essentially an Handle
02:25:35 <hiato> Yep :) Good idea
02:25:37 <pastorn> shit
02:25:41 <pastorn> i broke hpaste
02:25:42 <pastorn> sorry
02:25:50 <hiato> heh, so it was you :P
02:26:08 <pastorn> yeah, i tried to add a revision for my paste, then it died
02:26:17 <hiato> ditto
02:27:08 <pastorn> hiato: have you done this? http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
02:27:32 <hiato> pastorn: er, nope? But I'll take a look at it if all else fails
02:27:39 <Saizan> the record for the connected bot would probably have a field for the _current_ nick and so, since they can change while running
02:28:03 <pastorn> Saizan: how often does that happend?
02:28:24 <hiato> Saizan: Either?
02:28:57 <hiato> as in Either String String
02:29:00 <Saizan> pastorn: rarely, maybe it makes more sense for joined channels though
02:29:14 <Saizan> hiato: where would you use Either?
02:29:18 <hiato> nick
02:29:27 <Saizan> it doesn't make sense to me
02:29:33 <pastorn> hiato: you should start by copying that tutorial... maybe that'll make you see what's what
02:29:34 <hiato> Ok then
02:33:51 <hiato> Saizan: Would you link the bot record with a connection one?
02:34:42 <Saizan> hiato: link?
02:35:07 <pastorn> hiato: this is haskell land! no pointers here!
02:35:34 <monadic_kid> ...
02:35:39 <Saizan> i'd have data BotConf = BotConf { server, nick, channel :: String }, data BotState = BotState { connection :: Handle }
02:35:50 <hiato> er, I donno what haskell terminology is for that. Would there be a field in the bot record for a connection record? Or wait, hmm, this may be a step backwards
02:36:19 <Saizan> depends how much information you want to keep about each connection
02:36:40 <hiato> Well, ideally I'd like it all wrapped up under one record
02:36:41 <Saizan> an Handle would be enough for a simple bot
02:37:27 <hiato> Hmm, but then I run into the sam problem as before... this is certainly not easy.
02:37:37 <Saizan> what problem?
02:37:55 <Saizan> you get a BotState only after you connect
02:38:05 <Saizan> so you have an Handle to put there
02:38:10 <hiato> Where I have data Bot = Bot { stuf ... state :: Connection }
02:38:34 <hiato> and i cant construct it until I've filled connection
02:38:46 <Saizan> i don't see why you've to put the configuration in the same datatype that represents the current state of the bot
02:40:10 <hiato> Well, mostly because I want to parse an entier record wit a function, instead of providing both a bot record and a connection record to that function, to (eg) get the chan or whatever
02:40:27 <hiato> s/wit/to
02:40:39 <Saizan> do you mean pass rather than parse?
02:40:46 * pastorn doesn't understand the first thing about that
02:41:01 <pastorn> hiato: it seems like you insist on making stuff hard for yourself
02:41:02 <hiato> that too, as well as entire not entier
02:41:47 <hiato> pastorn: Heh, but surly it makes for simpler code, rather than having to keep track of matching pairs in yet another record
02:42:14 <pastorn> see, now you're thinking about it in a compicated way again
02:42:23 <pastorn> keep all you need to keep track of in just one record
02:42:26 <pastorn> and let that be that
02:42:43 <hiato> But I cant, due to that Handle problem
02:42:49 <pastorn> all "on the same level"; there's no need for records containing records
02:42:58 <pastorn> it's not a problem, you're just making one up
02:44:28 <hiato> I mea, I now have http://dpaste.com/189666/
02:44:49 <hiato> (though connection can go as a type)
02:45:41 <hiato> so actually http://dpaste.com/189667/
02:46:17 <pastorn> hiato: http://codepad.org/s6EDrfaZ
02:46:22 <pastorn> how hard can it be?
02:46:29 <pastorn> :p
02:47:14 <hiato> pastorn: That's exactly where I am now
02:47:16 <hiato> :P
02:47:33 <pastorn> why do you have THREE datatypes?
02:47:45 <pastorn> maybe Msg needs to be one, but the rest don't
02:48:02 <pastorn> and why do you keep eval in your config?
02:48:03 <hiato> one is for messages, the other is for configs and the last is like your bot
02:48:32 <pastorn> seems rather weird... why not just have a function eval?
02:49:09 <hiato> The whole idea is that I can have multiple bots, each with their own connections and configs and each have their own code for being bots
02:49:26 <Saizan> hiato: notice that pastorn's doesn't keep the server and port around, they are needed only to make the connection
02:49:50 <pastorn> hiato: i think you might want to focus on getting one bot in one channel running first
02:50:00 <pastorn> crawling before walking and all that
02:50:31 <hiato> Fair enough, but with this framework of mine I can still do that, I think
02:51:35 <pastorn> hiato: i'm doing some stuff to your code...
02:51:37 <pastorn> hang on
02:51:44 <hiato> ok
02:53:59 <pastorn> Jonno_FTW: we're talking IRC bots!
02:54:01 <pastorn> :D
02:54:15 <pastorn> Jonno_FTW: hiato is making one :)
02:54:27 <hiato> ... or trying at least :P
02:54:31 <Jonno_FTW> wow
02:54:41 <Jonno_FTW> how's it coming along?
02:55:25 <hiato> Well, I think I have a nice framework just about nailed. Now I just need to run off some eval functions for some test bots an we'll see
02:56:20 <Jonno_FTW> did you use pastorn's framework?
02:56:26 <hiato> Nope
02:56:55 <Jonno_FTW> source?
02:57:08 <hiato> Ok, will upload
02:58:08 <hiato> Warning, I am a haskell newb: http://dpaste.com/189670/
02:58:26 <hiato> brb, shower
03:00:07 <pastorn> hiato: http://codepad.org/YsrQK23p
03:00:09 <mauke> that thing looks ridiculously easy to flood off
03:00:34 <pastorn> then the function 'handle' is what actually does magic
03:00:54 <Jonno_FTW> looks like the one from the tutorial
03:01:09 <pastorn> Jonno_FTW: it's not :)
03:01:18 <pastorn> well, maybe it is now
03:01:22 <pastorn> i dunno
03:01:26 <Jonno_FTW> the previous one
03:02:42 <Jonno_FTW> i should probably rewrite that bot i did
03:02:57 <pastorn> Jonno_FTW: is it active anywhere?
03:03:07 <Jonno_FTW> nope
03:03:11 <Jonno_FTW> it can be
03:03:14 <pastorn> :(
03:03:27 <Jonno_FTW> you can test it on rizon #perwl
03:03:42 <Jonno_FTW> what other uses of the Network package are there though?
03:04:11 <pastorn> Jonno_FTW: you can do anything with that!
03:04:17 <pastorn> Jonno_FTW: write a browser!
03:04:22 <Jonno_FTW> implement ping?
03:04:46 <Jonno_FTW> could I make my own chat protocol?
03:04:53 <pastorn> Jonno_FTW: there's already lynx and links, make 'hyena' :)
03:05:01 <Jonno_FTW> badger
03:05:37 <pastorn> Jonno_FTW: sure, you could make your own chat protocol
03:05:53 <Jonno_FTW> i need ideas
03:05:59 <pastorn> Jonno_FTW: for that though, i'd suggest you look at binary parsers first
03:06:05 <pastorn> Jonno_FTW: ever used Data.Binary?
03:06:09 <Jonno_FTW> nope
03:06:17 <Jonno_FTW> is it for low level stuff?
03:06:30 <pastorn> see, in the end, what you want in to put and read ByteSTrings over your handles, right?
03:06:57 <Jonno_FTW> yep
03:06:59 <pastorn> binary make that really simple
03:07:04 <Jonno_FTW> ok
03:07:07 <pastorn> so for
03:07:09 <ivanm> preflex: seen gwern
03:07:09 <preflex>  gwern was last seen on #xmonad 7 hours, 56 minutes and 10 seconds ago, saying: nice borges quote
03:07:29 <ivanm> @tell gwern I think I worked out what my problem was: I had two functions the wrong way round :s
03:07:29 <lambdabot> Consider it noted.
03:07:45 <pastorn> data X = X Int Float Int (Char,Char) would have the parser
03:08:03 <pastorn> liftM4 get X
03:08:09 <pastorn> no
03:08:11 <pastorn> sorry
03:08:25 <pastorn> liftM4 (X) get get get get
03:08:41 <Jonno_FTW> yep
03:09:00 <Wooga> how do i use value of randomIO from System.Random with pure functions?
03:09:04 <Jonno_FTW> although, I still haven't read up on Datatyping in haskell
03:09:41 <pastorn> Wooga: you calculate your random stuff before calling the function
03:10:33 <ivanm> @tell gwern no, wait, that wasn't it... but I _did_ have a variable name wrong, so it was probably grabbing one of the same name from out of scope
03:10:33 <lambdabot> Consider it noted.
03:10:42 <Wooga> palmje: how do i calculate it?
03:10:56 <pastorn> Jonno_FTW: http://code.haskell.org/binary/
03:11:02 <Wooga> i can't see any way of value of randomIO to be used
03:11:10 <mauke> :t randomIO
03:11:11 <lambdabot> forall a. (Random a) => IO a
03:11:12 <pastorn> Wooga: yes you can
03:11:17 <mauke> Wooga: just like getLine
03:11:22 <pastorn> (randomIO :: IO Int) >>= print
03:11:40 <Wooga> i tried myvar <- randomIO, but this didn't worked
03:11:46 <benmachine> Wooga: make your pure function accept random input as a parameter
03:11:54 <mauke> "doesn't work" is not an error description
03:12:15 <pastorn> Wooga: you might need to state its type, since randomIO is polymorphic
03:12:31 <pastorn> (haskell needs to know which version of randomIO to run)
03:13:24 <Wooga> ah, with explicit :: IO Int it works
03:13:27 <Wooga> thank you guys
03:13:35 <pastorn> 's cool
03:14:21 <Jonno_FTW> i reckon, a p2p chat protocol would be pretty good
03:15:23 <hiato> Jonno_FTW: Any ideas? Thnigs you wanna bash? Or pastorn for that matter? :)
03:16:37 <pastorn> hiato: your first step should be to establish a connection with a server and printing stuff from the socket in the terminal
03:16:41 <pastorn> have you done that?
03:17:00 <hiato> pastorn: nope, I have yet to write a simple bot :P
03:17:13 <pastorn> hiato: don't bother with the bt
03:17:15 <hiato> (at least in Haskell)
03:17:18 <pastorn> just get that to work
03:17:24 <pastorn> add the bot stuff later
03:17:29 <hiato> I guess
03:17:32 <monadic_kid> Wooga: If you to use a pure function you can using StdGen (RandomGen typeclass) and explicitly/implicitly threading the generator in and out of functions
03:17:43 <monadic_kid> Wooga: *if you want to use
03:19:17 <pastorn> hiato: you should do that "rolling your own irc bot" tutorial, and then come back to your project
03:19:36 <pastorn> i'm guessing that would be the most productive use of your time :)
03:20:01 <hiato> pastorn: I got toags of it, so I'm happy to learn by trial and error
03:20:21 <pastorn> "toags"
03:20:25 <pastorn> is that even a word?
03:20:30 <hiato> *tons
03:20:37 <hiato> not sure where that came from
03:21:00 <hiato> but, I got to run, so cherrs, and thanks all for all the help :)
03:21:26 <Jonno_FTW> ok
03:23:26 <Jonno_FTW> so i reckon, i could have a listening loop, and at any time you can send a message to the other person, but sending bounces off everyone else that is connected
03:24:08 <Jonno_FTW> and to keep things secret, if people want to read your message, they also need a copy of your hash
03:24:40 <pastorn> Jonno_FTW: will you be using a server in this setup?
03:24:44 <Jonno_FTW> no
03:24:56 <Jonno_FTW> peer to peer
03:25:29 <Jonno_FTW> command line run
03:26:10 <Jonno_FTW> but i think it would be difficult to know who has sent/received each message
03:26:25 <pastorn> Jonno_FTW: IPs?
03:26:42 <Jonno_FTW> yep
03:26:54 <Jonno_FTW> and I guess you could assign a nick to an IP
03:27:11 <pastorn> yeah
03:27:39 <Jonno_FTW> and stored in a file, so nickname IP allocation is propogated
03:28:31 <Jonno_FTW> i suppose you could have an initial connection to another IP
03:28:46 <Jonno_FTW> and that IP will alert you to anyone new
03:28:57 <Jonno_FTW> does this seem doable?
03:29:40 <pastorn> probably
03:29:48 <pastorn> so you'd create a ring of some sort?
03:29:54 <Jonno_FTW> a what?
03:30:17 <pastorn> sharing IPs and what not
03:30:23 <Jonno_FTW> yeah
03:34:08 <Jonno_FTW> where would I start?
03:34:58 <pastorn> i dunno
03:35:15 <pastorn> maybe by having two clients connecting to each other
03:35:32 <pastorn> do you have access to logins at more than one computer?
03:35:42 <Jonno_FTW> yes
03:35:48 <Jonno_FTW> i was thinking that
03:35:57 <Jonno_FTW> sending and listening on a port
03:40:46 <Jonno_FTW> how would I go about that?
03:41:12 <pastorn> Jonno_FTW: start reiding the documentation on Network
03:41:30 <Jonno_FTW> i am
03:41:46 <pastorn> it'll probably give you some ideas on what you could do
03:44:24 <roconnor> mmmm, 1 petabit of memory per square cm
03:46:19 <twink> 256 TB RAM/cm^2? where is this?
03:48:44 <roconnor> http://www.youtube.com/watch?v=bKGhvKyjgLY&feature=related  about 36:45 to 38:00
03:49:03 <roconnor> twink: the memory goes right on the CPU
03:49:06 <roconnor> :)
03:49:37 <roconnor> Mmm 256 TB of L1 cache
03:52:21 <cizra> roconnor: RAM /= L1
03:52:50 <roconnor> oh?
03:52:54 * roconnor doesn't know much
03:53:02 <cizra> roconnor: L1 is made of triggers (transistors) and is a couple of orders of magnitude faster
03:53:20 <cizra> roconnor: RAM is made of (mostly) capacitors holding the state of the bit
03:53:56 <cizra> roconnor: The guy behind most of libc wrote a good book, "what every programmer should know about memory"
03:54:08 <cizra> http://people.redhat.com/drepper/cpumemory.pdf
03:54:22 <roconnor> ok
03:55:22 <roconnor> I'm not sure how fast this memristor memory will be, though it seems to be potentially as fast as SRAM
03:57:51 <twink> Seymour Cray used to like to use SRAM as main memory.
03:57:53 <ivanm> @slap mumamo-mode
03:57:54 * lambdabot secretly deletes mumamo-mode's source code
04:02:09 <sanyi> hi
04:02:23 <pastorn> hello
04:02:31 <sanyi> i'm new to haskell and to functional programming in general
04:02:38 <sanyi> my question would be:
04:02:38 <Wooga> what is better: example in http://www.haskell.org/haskellwiki/Examples/Random_list or something like `sequence (replicate 10 (randomIO :: IO Int))' ?
04:02:57 <roconnor> @src replicateM
04:02:58 <lambdabot> replicateM n x = sequence (replicate n x)
04:03:02 <sanyi> i want to check the equality of two lists
04:03:21 <sanyi> i've used zipWith (==) list1 list2
04:03:36 <blackh> sanyi: You can just say list1 == list2
04:03:39 <roconnor> > [1,2,3] == [1,2,3]
04:03:40 <sanyi> now i get a list full of True-s if they are equal
04:03:40 <lambdabot>   True
04:03:47 <roconnor> > [1,2,3] == [1,3,3]
04:03:48 <lambdabot>   False
04:03:54 <sanyi> moment :)
04:03:57 <roconnor> @src [] (==)
04:03:57 <lambdabot> []     == []     = True
04:03:57 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
04:03:57 <lambdabot> _      == _        = False
04:04:19 <sanyi> well yes, this seems to work :)
04:04:28 <sanyi> a bit silly that it didn't occur to me ;)
04:04:58 <blackh> Wooga: That depends on whether you want your random number generation to be in pure parts of your code.
04:05:19 <cizra> sanyi: you can fold
04:05:38 <blackh> If you do, then the pure approach is better.  MonadRandom is a good way to do random number generation in pure code - it makes the code a lot more readable.
04:05:54 <blackh> I have a question for the channel too!
04:05:55 <cizra> sanyi: I've never managed to exactly work out how to exactly use folds, but that sounds like the tool you want.
04:06:05 <blackh> http://pastebin.org/196420
04:06:37 <benmachine> cizra: pretty much any function involving lists can be a fold :)
04:06:48 <blackh> ^ I've made a data structure that's like a list except that it works in a monad.  What sort of standard type classes are there for a data structure like this?
04:06:49 <benmachine> but it's not necessarily the most obvious way to do it
04:07:12 <cizra> benmachine: anding a list of trues sounds just like the job for folds
04:07:45 <benmachine> cizra: it is!
04:07:56 <benmachine> but comparing two lists for equality item-by-item is more awkward to do that way
04:08:15 <benmachine> the zipWith doesn't quite work because it doesn't make sure they're the same length
04:08:27 <cizra> benmachine: 'course. Anyway, AFK
04:08:38 <benmachine> this is one case where just recursing is the easiest way
04:09:04 <benmachine> sanyi: it might be educational to see if you can work out how (==) works when applied to lists
04:09:23 <blackh> I don't think there are any standard type classes for this.  Foldable and Traversable, for instance, don't work.  But has anyone done this?  You could call it a "monadic iterator".
04:09:31 <benmachine> i.e. to write eqList :: (Eq a) => [a] -> [a] -> Bool yourself
04:09:45 <benmachine> blackh: it looks quite like the "proper" ListT
04:09:47 <dubhrosa> need some guidance please - I installed the Haskell Platform afresh on my Ubuntu laptop a couple of weeks back, when I tried to cabal install criterion ghc 6.10.4 crashed; I filed a bug report, which was closed because the problem doesn't happen with 6.12, so I apt-get installed 6.12, and now cabal fails to do anything with the error "cabal: failed to parse output of 'ghc-pkg dump" I see that message on some of the mailin
04:09:47 <dubhrosa> g lists but I can't tell whether there is a fix or workaround, can anyone enlighten me?
04:10:16 <benmachine> which would suggest Monad m => Monad (Iterator m)
04:10:35 <benmachine> possibly MonadTrans, MonadReader etc.
04:11:05 <benmachine> blackh: I'm not sure why you newtyped iterator though, instead of just putting that type in the original definition
04:11:44 <benmachine> oh wait I think I see
04:11:45 <benmachine> hmm
04:12:03 <blackh> benmachine: Thank you - that was exactly the answer I was after.  I didn't want to reinvent a data structure that someone else had already done on hackage.
04:12:14 <blackh> ...I knew it must be there somewhere!
04:12:20 <benmachine> blackh: keep in mind that there exists a ListT out there that is outright broken
04:12:20 <blackh> It doesn't have to be exactly the same.
04:12:26 <benmachine> hence my use of the term "proper"
04:12:45 <benmachine> I don't know where the proper ListT is, except that it might be related to LogicT
04:12:46 <blackh> benmachine: Which one is the non-broken one? I see 'List' on hackage version 0.2.
04:12:53 <benmachine> but probably isn't exactly the same
04:13:03 <benmachine> blackh: hmm, let me take a look
04:13:12 <pastorn> blackh: you might want to look at LogicT for your backtracking needs
04:13:47 <blackh> At first glance, LogicT doesn't look like what I'm after.
04:14:02 <sanyi> ok, thank you all for the suggestions
04:14:50 <benmachine> blackh: the List package is not what I had in mind when I said "broken" but that doesn't necessarily mean it works :P
04:15:33 <blackh> benmachine: It looks reasonable - I'll have a play.
04:15:44 <benmachine> blackh: mtl's Control.Monad.List contains the ListT that I seem to recall was bad
04:16:49 <benmachine> it's just m [a] which isn't right at all
04:16:53 <blackh> benmachine: Oh yes, I see it.  It's m [a] which is not what I want.  I want something that requires a generic monadic action for each cell.
04:17:00 <benmachine> yeah
04:17:13 <benmachine> it's not what most people want iirc :P
04:17:26 <benmachine> I think it might even break some of the monad laws
04:20:56 <Saizan> you get that "m [a]" is a monad only when m is commutative
04:21:38 <Saizan> "\a -> m [a]" actually, if you excuse the type lambda :)
04:22:20 <benmachine> m :. [] -- :)
04:22:30 * benmachine doesn't know if that actually works, mind
04:25:26 <Twey> Should do
04:27:44 <CalJohn> I wish undefined actually did all the coding for me
04:28:25 <pastorn> CalJohn: no, that's 'error'
04:31:33 <sanyi> hm, i have this small code here: http://pastebin.com/ip3206Cq
04:31:53 <sanyi> and it gives me the error: Could not deduce (Eq a) from the context ()
04:32:16 <sanyi> what does this mean?
04:32:35 <sanyi> == should give me Bool, right?
04:33:27 <Twey> sanyi: (==) :: Eq a => a -> a -> Bool
04:33:47 <Twey> You haven't specified Eq a in your type, so there's no guarantee that your ‘a’ will support ==
04:34:02 <sanyi> i see
04:34:42 <sanyi> so how can i specify Eq?
04:34:54 <Twey> isPalindrome :: Eq a => [a] -> Bool
04:35:00 <sanyi> thanks!
04:35:09 <Twey> You're welcome
04:35:30 <Twey> You have other problems, though ☺
04:35:35 <Twey> Is "abcba" a palindrome?
04:35:43 <Entroacceptor> yes
04:35:52 <sanyi> yeah, i get it
04:35:53 <Twey> Entroacceptor: That was for sanyi's benefit, but okay :þ
04:36:01 <Entroacceptor> :)
04:36:09 <sanyi> i only check lists with even length stuff
04:36:55 <kynky> Was it a car or a cat I saw?
04:37:11 <sanyi> btw: what does "Eq =>" tell to the compiler exactly?
04:37:21 <sanyi> that my type a supports equality?
04:38:24 <sepp2k> sanyi: That a must be an instance of Eq, which means it has a == function.
04:38:38 <sepp2k> @src Eq
04:38:38 <lambdabot> class  Eq a  where
04:38:38 <lambdabot>     (==), (/=)   :: a -> a -> Bool
04:40:44 <sanyi> you guys are really helpful: quite nice for a change ;)
04:41:14 <sanyi> i'm starting to understand my xmonad config now
04:44:28 <kstt> hi, I have a question regarding the special semantic of (-)
04:44:38 <sepp2k> sanyi: As a style note: if conditions don't need to be parenthesized. Neither do the operands of `==` (unless they contain operators with lower precedence than ==, but since in your code they only contain regular function calls, that's not the case here)
04:45:43 <kstt> ((+) N) is valid for a point free application of (+), how about doing the same with (-) ? I want a point free lambda expression that substract N
04:45:56 <Twey> kstt: ‘subtract’
04:46:03 <Twey> It's a wart of Haskell that (-) is a bit special.
04:46:12 <kstt> ok
04:46:16 <kstt> thank you
04:46:31 <Twey> It's often less confusing to just use the explicit functions ‘subtract’ and ‘negate’.
04:46:54 <kstt> nice to see sometime that haskell has been designed by humans ... I tend to forget that
04:48:00 <sepp2k> sanyi: Also assuming that you wrote it the way you did to gain performance over just "mylist == reverse mylist", I'm pretty sure your version will perform worse.
04:48:55 <sanyi> sepp2k: nope, it was just an exercise
04:49:57 <Twey> sepp2k: Not necessarily
04:51:11 <sanyi> well if equality checking is real slow for some object, my version only needs to do half as many... :)
04:51:36 <sepp2k> Ok, that's true.
05:00:39 <Twey> sepp2k: Equality checking involves evaluation of the item, whereas length only has to note the presence of the (:) constructor,
05:00:45 <Twey> s/,//
05:01:47 <sanyi> is there some easy way to access the source code / documentation of a function from ghci?
05:01:55 <sepp2k> Twey: The items need to be evaluated either way as he still compares the two sublists for equality.
05:02:06 <sanyi> in ipython for example you can use: function??
05:02:14 <sanyi> and you get the source + docstrings
05:02:34 <sanyi> i know haskell is different, but something similar would be nice
05:03:31 <sepp2k> sanyi: If you install lambdabot+goa you can use lambdabot commands like :src in ghci
05:03:57 <ski> @src length
05:03:58 <lambdabot> Source not found.
05:04:15 * ski peers quizzingly at lambdabot
05:04:38 <ski> @src any
05:04:38 <lambdabot> any p =  or . map p
05:05:03 <sanyi> thanks, i'll try it
05:05:04 <Saizan> sanyi: you could install hoogle, and then use hoogle --info
05:05:38 <Saizan> it gives you the haddock documentation, and a link to the online docs which usually link to the source
05:07:05 <MarcWeber> Liskni_si: I must have missed it. Can you give me a headline or such so that I can try digging for your mail?
05:07:31 <MarcWeber> If you don't get a reply ping me again, please.
05:12:29 <kstt> Twey: thank you again, you helped me to reduce my solution to euler pb #22 down to 2 lines
05:12:55 <kstt> which is short indeed :)
05:13:19 <roconnor> MarcWeber: rumour has it we can mount loop-aes partitions with dm-crypt
05:29:10 <MarcWeber> roconnor wrong channel? If this belongs to nixos I thought true crypt another nice way. That's why I stopped working on aes
05:33:01 <sepp2k> Is code.haskell.org down?
05:35:16 <CalJohn> sepp2k: looks like it
05:36:38 <Entroacceptor> again?
05:55:03 <facsimile> hi
05:55:31 <facsimile> are there any new functional pearls or good papers?
06:07:56 <whald> can someone please explaint to me whats wrong with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25261 in simpler wording than ghc does?
06:08:59 <sepp2k> whald: It'd be nice if the paste contained the error message. Even if you find ghc's wording confusing, it might still be helpful to the rest of us.
06:10:27 <cizra> whald: You can add stuff to the same paste.
06:10:28 <facsimile> whald this is funny
06:10:36 <facsimile> just replace thw $ with (
06:10:40 <facsimile> and it will wok
06:10:42 <whald> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25261#a25262
06:10:48 <facsimile> you can have fun figuring out why
06:11:09 <facsimile> runST (do
06:12:07 <whald> that gives me the same error message i don't understand
06:12:58 <whald> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25261#a25263
06:13:57 <whald> this keeps me busy for a full day now... what I ultimately need is the "rnd" function having the signature "rnd :: Rand Float"
06:14:19 <whald> and "newtype Rand = ???"
06:14:27 <Saizan> what's the type of uniform?
06:14:42 <whald> http://hackage.haskell.org/packages/archive/mwc-random/0.4.1.1/doc/html/System-Random-MWC.html#v%3Auniform
06:15:21 <facsimile> try turning off monomorphism
06:15:30 <Saizan> ok, so the last paste works, right?
06:15:42 <whald> no, same error as the first one
06:16:29 <Saizan> oh, right, you've to give a signature to runRand
06:17:18 <Saizan> runRand :: (forall s. Gen s -> ST s a) -> a
06:19:28 <whald> does that imply "existential quantification" or the like?
06:21:22 <Saizan> no
06:21:31 <Saizan> Rank2Types
06:22:27 <Saizan> rank-2 or in general rank-n types are those where universal quantification appears nested on the left of an ->
06:23:03 <Saizan> basically, that keeps the argument 'a' of runRand polymorphic enough
06:23:10 <Saizan> so it can be accepted by runST
06:23:44 <whald> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25261#a25264
06:32:12 <facsimile> whald type for rnd looks wrong
06:32:32 <whald> i *think* I finally have it
06:32:35 <Saizan> rnd :: Gen s -> ST s Float
06:32:36 <whald> moment please
06:32:43 <byorgey> yeah, should be  Gen s -> ST s Float
06:32:46 <byorgey> or something like that
06:33:07 <Saizan> it has to match (forall s. Gen s -> ST s a) afterall
06:37:37 <whald> now i have http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25261#a25266
06:38:03 <whald> this is is close, but it's not exactly what i need
06:38:52 <whald> i can't write rmul the way i need to, because i'm still passing the generator explicitely
06:39:22 <facsimile> hm?
06:39:33 <whald> so i'll have to wrap it up within the "Rand" as I was doing prevoiusly with a StdGen
06:40:14 <whald> the "rnd" funtion explicitely has the "gen" parameter
06:40:24 <facsimile> write
06:40:26 <facsimile> rnd
06:40:32 <facsimile> rnd = uniform
06:40:34 <facsimile> if you want
06:42:55 <whald> yes, sorry, that was a stupid complain
06:43:24 <facsimile> wait
06:43:47 <facsimile> whald, are you trying to do somthing that uses ST AND random  numbers?
06:44:14 <facsimile> because you could just make a cell that contains a stream of randoms.. and a function that pops one off
06:44:28 <facsimile> no need for any of this odd stuff, or transformers
06:44:30 <whald> i dont care about ST besides i need to fight it to get the mwc prng
06:44:41 <blackdog> facsimile: i think the statistics library with the prng uses ST
06:45:15 <facsimile> so what is the goal?
06:46:00 <whald> i have a working solution that uses a StdGen hidden in my own Rand monad, and within that i can just use "rnd" like in the rMul function to get a float in [0..1)
06:46:19 <facsimile> solution to what
06:46:21 <whald> and i want to replace StdGen with the MWC generator
06:46:30 <whald> without changing all my code base
06:46:53 <whald> i thought i was a clever kid wrapping the StdGen in my own monad so i can swap it later
06:47:08 <whald> seems i'm not *that* clever now that i really want to do it :-)
06:47:35 <facsimile> oh I see
06:47:53 <facsimile> you need to swap out the implementation of a monad
06:48:13 <facsimile> but it's difficult because of STs type hack
06:48:42 <whald> yes, this is really beyond my knowledge currently
06:49:06 <facsimile> whald, let me just explain -- ST is essentially different from all other monads
06:49:21 <facsimile> because it uses this clever trick with types
06:49:33 <facsimile> if it wasn't for that, your idea would have worked perfectly
06:50:09 <nomeata> Hi. The haskell platform upgrades paralell from 1.1. to 2.2. Are there any packages that have problem building against the old version?
06:50:51 <ivanm> nomeata: I believe all of them have been updated to use the new one
06:51:58 <whald> facsimile: that's the module i want to replace: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25267#a25267
06:52:14 <nomeata> ivanm: is there a list of packages that will require updating? (I’m preparing the debian upload, and I want to make sure it does not break too much)
06:52:24 <whald> is there any chance to do this without touching everything using this module?
06:52:26 <ivanm> nomeata: let me check what we've got in gentoo
06:52:34 <facsimile> whald you can try addding an s parameter to Rand
06:52:42 <facsimile> just follow along with ST
06:53:10 <facsimile> it means changing everything but that's just what has to be done
06:53:17 <whald> if not i'll just drop the MWC and roll my own mersenne twister or something, at least the i know what i'm doing...
06:53:32 <nomeata> but then, there are not many packages, build-depending on them, and none high in the dependency tree. I think we can cope :-)
06:55:22 <whald> (sorry for sounding a bit harsh, I'm a bit frustrated at the moment)
06:57:00 <Saizan> mh
06:58:07 <Saizan> whald: i think you can keep the same interface modulo s/StdGen/Seed/
06:58:28 <cizra> > length " ̐"
06:58:29 <lambdabot>   2
06:58:56 <ivanm> nomeata: the only known packages that we have that require exactly 1.* are hxt (but there's a newer version that doesn't need parallel) and vty
06:59:12 <ivanm> there might be others for which our deps aren't strict enough (because the cabal file wasn't strict enough) but that's it
07:00:05 <whald> saizan : then i depend on save / restore in http://hackage.haskell.org/packages/archive/mwc-random/0.4.1.1/doc/html/System-Random-MWC.html#v%3Asave being cheap operations for performance, right?
07:00:29 <ivanm> nomeata: the only one that I actually have installed is criterion, and it works fine with 2.*
07:01:20 <nomeata> ivanm: sounds good, thanks
07:01:27 <ivanm> no worries
07:03:33 <gwern> uhoh. code.haskell.org is down
07:03:34 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:03:37 <gwern> @messages
07:03:38 <lambdabot> ivanm said 3h 56m 8s ago: I think I worked out what my problem was: I had two functions the wrong way round :s
07:03:38 <lambdabot> ivanm said 3h 53m 4s ago: no, wait, that wasn't it... but I _did_ have a variable name wrong, so it was probably grabbing one of the same name from out of scope
07:03:55 <gwern> ivanm: that's elisp for you! you cut yourself as oft as the enemy
07:04:08 <ivanm> gwern: I got it working.... as long as you have at most _1_ code block
07:04:25 <ivanm> more than that, it fails (I think because it's ambiguous whether ~~~~~ starts or ends a code block)
07:05:08 <ivanm> even after upgrading to the latest mumamo-mode (since I had a really old version for some reason) it fails :s
07:06:39 <ivanm> gwern: I'm thinking of moving to your setup, where I do the code first in haskell-mode and then start doing the markdown
07:06:43 <ivanm> because this really isn't working :s
07:10:20 <Saizan> whald: well, if you enter and exit from Rand a lot
07:11:28 <Saizan> whald: however, wrt types it'd go like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25268#a25268
07:11:44 <gwern> ivanm: simple is good
07:11:56 <ivanm> except having multimode would be nice :s
07:12:06 <ivanm> since I wouldn't have to keep changing modes when I want to edit something
07:12:57 <ivanm> damn, haskell-mode currently doesn't play nicely with literate haskell
07:12:59 <whald> Saizan: thanks a lot!!
07:13:19 <Saizan> whald: save and restore are used only in runRand, we keep the Gen s around otherwise
07:13:34 <Saizan> whald: np :)
07:13:37 <ivanm> @ask Baughn any chance bird-style literate-haskell-mode could auto-insert the `>' for you when you hit enter to indent, etc.?  or would it be too hard to tell when to do that and when not to?
07:13:37 <lambdabot> Consider it noted.
07:14:11 <ivanm> @tell Baughn however, indentation doesn't seem to work in literate-haskell-mode :s
07:14:12 <lambdabot> Consider it noted.
07:14:16 <pokoko222> hello mortals haskell chanell still the best, 674 users wow
07:15:02 <Saizan> whald: actually, you might want a version of runRand that uses initialize instead, but that should be hard to do
07:15:18 <Saizan> whald: err, shouldn't
07:16:03 <whald> saizan: yes, i already did that :-)
07:16:37 <whald> saizan: thanks again, i really appreciate your help
07:32:01 <danharaj> Would anyone be willing to vouch for a gui library on windows?
07:32:08 <dmwit> gtk2hs
07:32:47 <dmwit> I've heard good things about wxHaskell, too.
07:33:05 <danharaj> I haven't been able to get wxhaskell to build :p I guess I'll try gtk2hs
07:33:11 <dmwit> But you should use the one you've worked with before in another language; that will be simplest.
07:33:57 <danharaj> I haven't written a gui in another language. The most I've done is play with opengl/directx.
07:34:21 <ManateeLazyCat> We can't access code.haskell.org/gtk2hs by Browser?
07:35:04 <ManateeLazyCat> Not just gtk2hs, i can't access code.haskell.org completely, it's just my box can't work?
07:35:30 <danharaj> I can't access it either.
07:36:05 <palmje> < Wooga> palmje: how do i calculate it? <- calculate what? o.O
07:36:13 <sbahra> http://downforeveryoneorjustme.com/code.haskell.org
07:36:27 <ManateeLazyCat> What's wrong with code.haskell.org ? It's real trouble for developer.
07:36:48 <byorgey> the apache server goes down regularly, not sure why
07:36:58 <byorgey> code.haskell.org itself is up, I can ssh in just fine.
07:37:25 <sbahra> Why not use lighttpd over Apache?
07:37:43 <ManateeLazyCat> byorgey: Yes, i can push/pull patches to code.haskell.org, but i can't access it by Browser.
07:38:09 <ManateeLazyCat> byorgey: I hope maintainer fix this problem completely, always down.
07:39:49 * ManateeLazyCat http://downforeveryoneorjustme.com/code.haskell.org Looks not just me.
07:40:22 <Baughn> @clear
07:40:22 <lambdabot> Messages cleared.
07:42:16 <nomeata> code.haskell.org is down again, right? Can someone paste me the current state of http://code.haskell.org/haskell-platform/haskell-platform.cabal, if possible?
07:44:27 <max_atreides> learning haskell right now, - omg monads are hurting my brain.
07:45:25 <danharaj> Would you like to ask a few questions about monads to get you acclimated?
07:45:57 <Saizan> nomeata: do you have an ssh account?
07:46:25 <nomeata> Saizan: indeed I have. thanks for the hint
07:46:35 <max_atreides> danharaj: i probably will eventually :) I'm going through all the tutorials on haskell.org atm
07:46:58 <danharaj> Alright. Don't worry, once you get it, it becomes easy.
07:47:12 <max_atreides> i have no formal math training, it's probably why it's not easy for me
07:47:23 <Saizan> you don't need any math
07:48:12 <Saizan> though you need to understand typeclasses to learn how the interface works, and be familiar with first-class functions to understand the implementation of some monads
07:48:12 <max_atreides> but comming from unix background and havy use of pipes I find the rest of haskell very elegant
07:48:13 <danharaj> Certainly having a math background makes it easier for you to grasp high-level abstract concepts, but so does a programming background.
07:49:57 <jmcarthur> monads being hard is really just a result of trying to understand them before using them
07:50:22 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- the Motivation paragraph should give some perspective
07:50:33 <danharaj> It might be easier to understand monads if you try to understand what a functor is first.
07:50:37 <jmcarthur> really, there's not much to understand besides the types and laws
07:50:43 <Saizan> jmcarthur: and/or before having understood the type system
07:50:45 <max_atreides> are monads just an easy way to compose function f() and g() (like calculus) -into f(g(x))?
07:50:52 <jmcarthur> Saizan: oh, yes, that's a biggie
07:51:10 <jmcarthur> max_atreides: close. monads provide a way to compose certain kinds of functions
07:51:27 <Saizan> max_atreides: they are a way to compose functions that return a "richer" result
07:51:42 <facsimile> max_atreides: no use . for that e.g.  f . g
07:51:53 <jmcarthur> max_atreides: i'm going to hopefully not blow your mind by introducing more combinators, but...
07:51:53 <Saizan> max_atreides: where what richer actually means depend on the monad
07:51:58 <jmcarthur> :t (.)
07:51:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:52:01 <jmcarthur> : (<=<)
07:52:07 <jmcarthur> :t (<=<)
07:52:07 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
07:52:14 <danharaj> A category is a setting in which you can compose functions.
07:52:34 <danharaj> A functor is a way from moving between categories, that is it tells you how to translate function composition in one setting to another.
07:52:34 <jmcarthur> those types are very similar. the first is normal function composition. the second is "kleisli" composition (the kind of composition you get from Monad)
07:52:55 <facsimile> so (<=<) is compose and return is identity in the category
07:52:56 <jmcarthur> dang, caleskell
07:53:03 <jmcarthur> :t (Prelude..)
07:53:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:53:09 <jmcarthur> that's what i meant by (.)
07:53:27 <jmcarthur> lambdabot's (.) is a lie
07:53:29 <max_atreides> jmcarthur: so monads are a flexible way to compose functions?
07:53:41 <max_atreides> so that they can exchange types between each other?
07:54:01 <max_atreides> or speak in common... "language"?
07:54:02 <jmcarthur> max_atreides: i suspect that you somewhat understand but can't phrase it in a way that is meaningful to me :P
07:54:27 <max_atreides> jmcarthur: haha, ok- i'll go through more tutorials and be back eventually :D
07:54:33 <jmcarthur> max_atreides: if you understand id and (.), then you are close to understanding return and (<=<)
07:55:05 <jmcarthur> max_atreides: and ($) is a lot like (=<<), too
07:55:07 <max_atreides> jmcarthur: . is no problem
07:55:09 <Saizan> max_atreides: normally you have functions of type A -> B for some base types A and B, for each monad M you can imagine living in a world where functions types are instead of the form A -> M B, and the monad interface will let you compose those
07:55:54 <Saizan> which is just a rephrasing of what has been told up till now :)
07:56:32 <max_atreides> so monads are like a translation table between A -> B
07:56:42 <jmcarthur> err
07:56:43 <danharaj> Not really.
07:57:05 <kstt> :)
07:57:09 <jmcarthur> max_atreides: let's put something concrete in place of this abstract m we're using. how about Maybe?
07:57:20 <max_atreides> ok
07:57:31 <jmcarthur> max_atreides: so in this case, (<=<) :: (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)
07:57:49 <jmcarthur> max_atreides: compare to (.) and you might understand it, at least for this concrete case
07:58:42 <jmcarthur> @djinn (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)
07:58:42 <lambdabot> f a b c =
07:58:42 <lambdabot>     case b c of
07:58:42 <lambdabot>     Nothing -> Nothing
07:58:42 <lambdabot>     Just d -> a d
07:58:50 <max_atreides> so you are defining a transformation?
07:59:03 <danharaj> How about this:
07:59:10 <danharaj> Maybe is a type constructor right?
07:59:17 <jmcarthur> i'm creating a new function from two other functions
07:59:19 <facsimile> yes
07:59:27 <max_atreides> yes
07:59:30 <danharaj> (question was to atreides :p)
07:59:49 <danharaj> Ok, to make sure, a type constructor is a thing that takes a type and gives you a new one, right?
08:00:06 <max_atreides> danharaj: yes
08:00:46 <danharaj> ok, but there are certain special kinds of type constructors that are very nice. Let's say I have a function Foo :: A -> B. Can I turn that into a function Foo :: Maybe A -> Maybe B?
08:01:12 <max_atreides> yes
08:02:02 <opqdonut> :t liftM
08:02:02 <danharaj> It's a good exercise to define that transformation, a function that takes Foo and gives you Maybe Foo. You can do that whenever you have free time.
08:02:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:02:04 <max_atreides> Convert :: ( a -> b ) -> ( Maybe a -> Maybe b )
08:02:13 <danharaj> Maybe even do it right now.
08:03:18 <Saizan> function names must start with a lowercase letter
08:03:50 <danharaj> If you want an example you already know and love, list is a type constructor and the conversion function is map.
08:04:47 <danharaj> Also, note that the conversion preserves composition. If you have f . g, then map (f.g) = map f . map g. Are you still with us?
08:04:49 <max_atreides> danharaj: which function would be the monad in case of the list?
08:05:03 <danharaj> We aren't even talking about monads yet. We're talking about functors :p
08:05:16 <Saizan> max_atreides: the monad is the type constructor itself, i.e. []
08:05:19 <danharaj> Monads are special types of functors.
08:05:47 <max_atreides> danharaj: ok, i get what you said about the lists
08:06:03 <max_atreides> and map makes sence
08:06:04 <max_atreides> *sense
08:07:21 <danharaj> Ok, now I'm trying to think. There are two ways of defining a monad, the math way and the programming way. I'm not sure which would be more intuitive. Anyone want to help out?
08:07:46 <danharaj> Ah fuck it. We'll do it live!
08:07:48 <max_atreides> Saizan: I have C and Python background
08:08:00 <Saizan> a functor is any type constructor f for which you can implement a function of type  ( a -> b ) -> ( f a -> f b ) (that respects some laws) in the context of Haskell
08:08:08 <Saizan> tbc.
08:08:18 <danharaj> Ok, ok. So now our functor tells us how to construct a new type from an old one, and how to upgrade old functions into new ones.
08:08:33 <max_atreides> Saizan: ok, thanks
08:08:34 <danharaj> But it doesn't tell you how to construct a new value from an old one.
08:08:36 <kmc> "Functor" and "Monad" are the names of two APIs.  type classes.
08:08:41 <kmc> @src Functor
08:08:42 <lambdabot> class  Functor f  where
08:08:42 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:09:00 <Saizan> max_atreides: i think the tutorial i linked above would be a nice place to start
08:09:13 <kmc> you have to understand type classes and higher-order functions before you will understand Functor or Monad
08:09:22 <Saizan> max_atreides: http://www.haskell.org/haskellwiki/Monads_as_computation
08:09:44 <danharaj> If he understands map then he understands enough higher order functions to grasp functors/monads.
08:09:47 <max_atreides> ok, I'll read that. I just didn't want anyone to feel like I'm ignoring them :)
08:09:56 <kmc> at which point, i think just looking at the type class and the stated laws is the best definition of what Functor or Monad is
08:10:01 <kmc> and looking at examples
08:10:13 <kmc> but not burrito metaphors
08:10:17 <danharaj> heh
08:10:26 <kmc> and not category theory
08:10:28 <max_atreides> thanks again
08:12:01 <twink> Where's the "Monads as Mexican food" link?
08:12:04 <danharaj> Anyway, if you're still interested. A monad not only let's you translate types and functions, but it also has a way of translating values. That is what return is. It takes a value and sticks it into your monadic type.
08:13:03 <danharaj> There is a precise way in saying that return is the simplest function (a -> M a) that does this.
08:15:09 <danharaj> In the case of Maybe, return x is Just x. For List, return x = [x] the singleton list.
08:15:44 <facsimile> for Identity monad  return x = x !!
08:15:53 <facsimile> and (<=<) = (.)
08:15:58 <max_atreides> ok, i think i see what you are getting at
08:16:51 <danharaj> For me, at first I didn't realize that this was special about monads. In general, if you make a new type out of an old one, that doesn't mean you have an obvious and natural way of translating values into new ones.
08:20:31 <danharaj> Now, there's two ways of defining a monad from here. You will see one very often because it's the way you use monads in practice. I'm going to try to explain the other way, because maybe seeing it in two ways will help you understand it as a whole.
08:21:49 <max_atreides> danharaj: sounds good. I'm reading the tutorial but i'm also looking at irc :)
08:22:34 <danharaj> Let's say you have a value foo :: M A that is already in the monad. Isn't it redundant to apply return to foo? I mean you get a value in M M A.
08:23:52 <danharaj> The second part of a monad is that if you're in the monad, then you can be reduced to a value in M A. So if you're in M M M M M M A, you can be put in M A in a natural way.
08:25:06 <danharaj> For example, let's say you have a list of lists: [[a]]. You can turn that into a list by [x:y:..] -> x ++ y ++ ...
08:25:16 <Saizan> danharaj: if you used parentheses like one would in haskell it might help :)
08:25:26 <danharaj> Pfffff :p
08:26:10 <danharaj> Another example, Maybe (Maybe A) = Nothing | Just Nothing | Just Just A
08:26:27 <danharaj> It's obvious that Nothing and Just Nothing are the same thing, and there's really no different between Just Just A and Just A.
08:26:45 <max_atreides> interesting
08:27:08 <EvanR> > Nothing == Just Nothing
08:27:09 <lambdabot>   False
08:27:11 <kmc> i don't agree
08:27:28 <scree_> you clearly lose data, just in a sensible fashion
08:27:36 <kmc> it's misleading to say that Nothing and (Just Nothing) are the same thing
08:27:47 <kmc> (Maybe T) and (Maybe (Maybe T)) aren't isomorphic
08:28:05 <kmc> as scree_ said, "join" loses structure in a particular regular way
08:28:06 <danharaj> The mapping satisfies certain coherence conditions.
08:28:27 <Saizan> yeah, but join is not an isomorphism
08:28:30 <facsimile> kmc: think about the quotient set (Maybe (Maybe T))/join
08:28:33 <kmc> also (Just Just A) doesn't make sense
08:28:36 <kmc> it'd be Just (Just A)
08:28:44 <danharaj> It's not an isomorphism, but it preserves the monadic structure you actually care about.
08:28:53 <danharaj> Yes this is pseudocode.
08:29:00 <kmc> why not get the code right?
08:29:06 <Wooga> i can wrap into Maybe monade values with `return "Hello" >>= Just', but how do i wrap into IO monade?
08:29:07 <facsimile> this induces exactly the equivalences that danharaj said
08:29:11 <danharaj> Because I'm a lazy jackass.
08:29:11 * hackagebot hexpat 0.13 - wrapper for expat, the fast XML parser  http://hackage.haskell.org/package/hexpat-0.13 (StephenBlackheath)
08:29:22 <kmc> Wooga, that's unnecessarily complex
08:29:30 <kmc> Wooga, (return x >>= f) is always the same as (f x)
08:29:39 <kmc> Wooga, and that holds for *any* monad
08:29:40 <kmc> > Just 3
08:29:41 <lambdabot>   Just 3
08:29:43 <danharaj> Ok how do we resolve this sticking point and return to the climax of the monad definition.
08:29:45 <kmc> ^^^ 3 wrapped into Maybe mona
08:29:53 <Wooga> kmc: but what with IO case?
08:29:55 <Saizan> Wooga: however that expression would work, and be equal to Just "Hello"
08:29:57 <kmc> Wooga, use "return"
08:30:06 <kmc> Wooga, what you've hit upon is that some monads expose the implementation of return, and others don't
08:30:11 * hackagebot hexpat-iteratee 0.1 - chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.1 (StephenBlackheath)
08:30:13 <kmc> Maybe exposes the implementation of return, and calls it "Just"
08:30:23 <kmc> IO does not expose the implementation of return; you have to call it by that name
08:30:37 <kmc> remember, return and (>>=) are just the names of methods in a type class, i.e. they are an API supported by various types
08:30:39 <facsimile> Maybe T is isomorphic to X = (Maybe (Maybe T))/join because in X Nothing and Just Nothing are identifed
08:30:46 <scree> > Just Just <*> Just 1 == Just (Just 1)
08:30:47 <lambdabot>   Precedence parsing error
08:30:47 <lambdabot>      cannot mix `Control.Applicative.<*>' [infixl ...
08:30:57 <benmachine> but even in IO it's pointless to do (return "Hello" >>= something)
08:31:04 <scree> > (Just Just <*> Just 1) == Just (Just 1)
08:31:05 <lambdabot>   True
08:31:05 <kmc> yes
08:31:20 <kmc> in any monad which obeys the laws, (return x >>= f) is equivalent to (f x)
08:31:49 <EvanR> are there monads that dont obey the monad laws? :)
08:31:50 <danharaj> Which is the law that corresponds to 'return x' is the simplest function that lifts a value into a monadic value.
08:32:14 <benmachine> EvanR: there's definitely none in base, and most libraries won't have any
08:32:22 <danharaj> By definition they're not monads then.
08:32:26 <EvanR> by definition they arent monads
08:32:37 <Saizan> they are instances of Monad though :)
08:32:43 <danharaj> Anyway, back to the train of thought.
08:32:47 <benmachine> depends how you use your terminology I guess
08:32:56 <kmc> Control.Monad.Omega defines a useful "monad" which does not obey the laws
08:33:02 <danharaj> max_atreides: We have fmap, return, and join.
08:33:12 <benmachine> kmc: it does if you satisfy the preconditions, right?
08:33:18 <kmc> no
08:33:22 <benmachine> oh
08:33:27 <kmc> it does if you ignore the order of the result list
08:33:31 <benmachine> oh right
08:33:32 <max_atreides> kk
08:33:57 <danharaj> So wouldn't it make more sense to have it return a multiset if the order was not natural?
08:34:04 <kmc> yeah
08:34:07 <scree> IIRC some of the reactive monads aren't really monads
08:34:10 <kmc> but you'd need to choose a multiset type
08:34:14 <kmc> they use [] to make things simple, i guess
08:34:21 <danharaj> Yeah makes sense. Anyway. We have fmap, return, and join. With these we can do everything we can in a monad.
08:34:29 <Saizan> you'd need Ord for any sensible multiset
08:34:34 <Saizan> or at least Eq
08:34:40 <benmachine> most multiset types need to place restrictions on the type
08:34:54 <kmc> gotta get some associated constraint families :D
08:35:01 <benmachine> totally
08:35:06 <facsimile> it all depends on what equality you use
08:35:13 <scree> If you don't have Eq then there isn't a problem with returning a list
08:35:19 <jmcarthur> scree: if you are referring to conal's Reactive, then you're right. Event break the monad laws
08:35:19 <danharaj> Let's examine the IO monad. The type IO a represents a computation that does IO and then returns a value a.
08:35:26 <facsimile> some monad might only hold up to permutations
08:35:38 <jmcarthur> *Event breaks
08:35:48 <scree> jmcarthur: yep
08:35:59 <danharaj> In this case, return x is the function that does no IO and returns x. It is very simple.
08:38:11 <danharaj> You have a bunch of functions that let you define IO computations. For example, let's say you want to put a string on the screen. This computation has type IO (), because it does IO and returns nothing.
08:38:35 <danharaj> But in order to construct such a computation, you need to give it a string. So the function is putStr :: String -> IO ()
08:39:40 <danharaj> Actually this is where >>= is more natural than join :p But anyway, you should finish your tutorial.
09:05:11 <cizra> Parsec question: can I have a parser that accepts multiple data types? More precisely, I'm using the "many" combinator with Parser Chars, but I want to skip some characters. skipMany returns something like (), which doesn't match Char the other option.
09:07:46 <cizra> So basically it should look like many (blanks <|> chars), except that the types don't match.
09:07:55 <byorgey> cizra: you'll have to do something like wrap both in adapters so that they all have type  Parser (Maybe Char)
09:08:05 <sepp2k> cizra: You could create a list of Maybe Char like  `many (blanks >> return Nothing <|> chars >>= Just)`
09:08:06 <cizra> oh. Hm.
09:08:20 <byorgey> then  fmap catMaybes
09:08:56 <cizra> hmmm, OK. I see.
09:15:30 <EvanR> > [0,-1,..]
09:15:31 <lambdabot>   <no location info>: parse error on input `..'
09:15:34 <EvanR> > [0,-1..]
09:15:34 * hackagebot Combinatorrent 0.3.1 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.3.1 (JesperLouisAndersen)
09:15:35 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
09:15:38 <EvanR> awesome
09:16:28 <kmc> > enumFromThen 0 (-1)
09:16:29 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
09:18:12 <EvanR> so if my datatype is basically a list, in order to give it a Num instance ill have to make it a newtype, and then list ops dont work on it :(
09:19:04 <jlouis> ^^ that one fixes some nasty bugs
09:19:05 <xerox> make a fromList and toList
09:19:15 <Vitka> You want something like specialized list?
09:19:32 <EvanR> fromList toList is good
09:20:10 <xerox> or just implement even more useful combinators for your T a
09:20:24 <EvanR> thats what im doing
09:20:47 <EvanR> but they are written in terms of list ops ;)
09:22:20 <EvanR> oh shite, i cant make a Num instance without an Eq instance ;)
09:22:32 <EvanR> @src Num
09:22:32 <lambdabot> class  (Eq a, Show a) => Num a  where
09:22:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:22:32 <lambdabot>     negate, abs, signum     :: a -> a
09:22:32 <lambdabot>     fromInteger             :: Integer -> a
09:23:06 <EvanR> nevermind
09:25:38 <EvanR> @src (+++)
09:25:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:25:46 <EvanR> @hoogle (+++)
09:25:46 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
09:25:46 <lambdabot> Text.Html (+++) :: (HTML a, HTML b) => a -> b -> Html
09:25:46 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
09:28:05 <cizra> byorgey: catMaybes I understand, but why fmap? To make it work with Parser stuff?
09:35:57 <Jordi> hi
09:36:20 <facsimile> hi
09:36:24 <Jordi> is there a simple way of managing SrcSpanInfo in annotated haskell-src-exts?
09:36:59 <Jordi> it looks ugly
09:40:46 <byorgey> cizra: exactly, catMaybes :: [Maybe a] -> [a],  so  fmap catMaybes :: Parser [Maybe a] -> Parser [a]
09:40:49 <Wooga> in which module i can find a State monade?
09:40:56 <byorgey> Wooga: Control.Monad.State
09:41:01 <Wooga> thanks
09:41:18 <opqdonut> heh, monade
09:41:20 <opqdonut> (li)monade
09:41:37 <Wooga> oops
09:41:45 <Wooga> i have only Control.Monad.Fix        Control.Monad.ST         Control.Monad.ST.Strict Control.Monad.Instances  Control.Monad.ST.Lazy
09:42:10 <benmachine> Wooga: so you need to install a library of some kind
09:42:27 <benmachine> what are you going to use it for?
09:42:50 <Wooga> i am just reading manual about monads
09:43:06 <benmachine> oh right
09:43:23 <benmachine> maybe you want the Haskell Platform
09:43:35 <benmachine> it's a collection of useful libraries
09:46:35 <Wooga> oh, thanks, it looks like what i want
09:48:16 <HugoDaniel> hi
09:48:26 <HugoDaniel> haskell is taking a hard beat on the shootout :(
09:49:10 <monadic_kid> HugoDaniel: ?
09:50:27 <HugoDaniel> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
09:51:11 <HugoDaniel> haskell used to be way up there kicking arse, now its fighting for a spot in the middle of the table
09:52:39 <monadic_kid> HugoDaniel: You're looking at one particular shootout set-up.
09:52:40 <kstt> I also recall I've seen it « beating » more langages than that
09:52:47 <cizra> \o/ My 48h Scheme can parse all of the R6RS standard strings!
09:53:29 <monadic_kid> HugoDaniel: there is more than one shot out like this: http://shootout.alioth.debian.org/u32/performance.php?test=pidigits
09:53:44 <HugoDaniel> monadic_kid: you are right, i usually only look at this one, it seems to be the one to look out for
09:53:54 <Zagen> hey guys
09:53:54 <HugoDaniel> the others are just waiting to become deprecated :P
09:53:56 <EvanR> i just look at haskell vs different things, and for all the 'fast' languages, haskell is 3x as slow 3x memory usage, for the most part
09:54:22 <EvanR> and its way faster than everything else
09:54:26 <cizra> EvanR: Ever tried xmonad?
09:54:29 <Wooga> one more question: where i can find RndGen data type?
09:54:34 <EvanR> cizra: no
09:54:35 <Zagen> can i get a little but huge help from you guys?
09:54:35 <cizra> EvanR: I've NEVER seen a window manager as fast.
09:54:48 <cizra> Zagen: Don't ask to ask! Just ask!
09:54:52 <HugoDaniel> yes EvanR, but you have an amazing set or profiler tools, a great RTS with loads of information, and the best ffi to C to optimize away
09:55:45 <EvanR> it also says that it outperforms ocaml, sometimes
09:56:08 <Zagen> ok, well is a php related question, how do i manage to fill out an username/password form prompted by my site automatically with a php script inside my webpages?
09:56:27 <HugoDaniel> Zagen: #php <-- go
09:56:28 <dmwit> Zagen: #php, maybe
09:56:59 <HugoDaniel> Zagen: i would also try out #javascript :P
09:57:00 <Zagen> php channel?
09:57:08 <Zagen> yah i was thinking that to
09:57:49 <EvanR> ghc haskell is just amazing
09:57:52 <kmc> Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
09:58:31 <Zagen> emmm...sure...
09:58:42 <EvanR> someone quote that
09:59:12 <Gracenotes> dot dot dot
09:59:47 <cizra> \ldots
09:59:50 <monadic_kid> HugoDaniel: Those benchmarks aren't that good really, langauges that have missing entries, the examples aren't very realistic, not using the latest version of the compilers, using SIMD instructions, using bindings to native libraries, etc, etc.
10:00:03 <Zagen> so i just have to type #php to get into that channel? sry first time on irc
10:00:10 <kmc> Zagen:  /join #php
10:00:18 <Zagen> roger that, thanks
10:00:21 <kmc> :)
10:00:27 <cizra> Zagen: How did you end up in Haskell, I wonder?
10:00:35 <kmc> we have one of the biggest channels
10:00:39 <monadic_kid> HugoDaniel: Even so out of all the benchmarks Haskell is somewhere around 2-4x slower than C, that is not bad at all really
10:00:48 <kmc> EvanR, i'd not be surprised if GHC Haskell outperforms OCaml for some things
10:00:54 <kmc> GHC gets a lot more work than ocamlc these days
10:01:21 <danharaj> When is haskell' gonna get finalized so all those extensions get sorted out?
10:01:24 <byorgey> @remember kmc Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
10:01:24 <lambdabot> Good to know.
10:01:36 <kmc> danharaj, never.  Haskell' is an ongoing project
10:01:37 <EvanR> yeah but the ocaml people says haskell is slow, inefficient
10:01:40 <byorgey> danharaj: it's being worked on as we speak.
10:01:45 <kmc> danharaj, it has yearly releases
10:01:47 <Zagen> yah im already getting that
10:01:51 <byorgey> danharaj: the Haskell 2010 report is almost finished being written up
10:01:52 <monadic_kid> danharaj: it has been, it's called Haskell 2010
10:01:57 <danharaj> yay
10:01:59 <kmc> then there will be Haskell 2011 and so forth
10:02:04 <Zagen> damn im sent to an overflow channel :S
10:02:11 <kmc> but most of the important GHC extensions are not in Haskell 2010
10:02:11 <danharaj> That's good. 12 years between updates is inadequate.
10:02:17 <danharaj> boo :|
10:02:37 <chrisdone> hi chappies
10:02:39 <monadic_kid> Haskell 2010 is incremental but the plan is to have lots of increments right
10:02:44 <kmc> yeah
10:02:50 <kmc> they're starting small
10:03:15 <danharaj> does it have any institutions/governments/companies backing it?
10:03:30 <kmc> there were 5 or so releases in the '90s
10:03:32 <chrisdone> @quote ruby
10:03:32 <lambdabot> dobblego says: many of my colleagues used to be [fond of ruby] as well until I was let loose on them
10:04:12 <mux> hmm, regex-tdfa doesn't provide instances for Char8 variants of ByteString?
10:05:59 <Saizan> mux: there are no Char8 variants
10:06:07 <Saizan> there's only lazy and strict bytestrings
10:06:22 <Saizan> the .Char8 modules just provide an additional API to each
10:06:48 <EvanR> > let f a b c = a+b-c in 5 `f` 5 3
10:06:49 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:06:49 <lambdabot>    `GHC.Num.Num t' arising f...
10:06:50 <mux> hmm alright then I must be missing something because I supposedly lack a lazy bytestring instance
10:07:04 <EvanR> > let f a b c = a+b-c in (5 `f` 5) 3
10:07:05 <lambdabot>   7
10:08:43 <mux> ghci seems to agree on that I don't have those instances
10:09:55 <HugoDaniel>     
10:10:01 <chrisdone> HugoDaniel: !!!
10:10:09 <HugoDaniel> chrisdone: !!!
10:10:11 <chrisdone> HugoDaniel: i'm in italy now :D
10:10:12 <HugoDaniel> how is italy ?
10:10:14 <HugoDaniel> :D
10:10:20 * chrisdone does a one-man-mexican-wave
10:10:36 <chrisdone> hot! and beautiful
10:10:44 <HugoDaniel> :)
10:10:48 <HugoDaniel> are you coding in lisp now ?
10:10:55 <chrisdone> here at create-net they want to release some open source haskell software
10:11:07 <chrisdone> there's some lisp that i'm going to kind of duplicate in haskell
10:11:13 <silver> what's mexican wave? :)
10:11:15 <HugoDaniel> allright! you're in the right place
10:11:22 <chrisdone> :)
10:12:04 <silver> oh I see what it is
10:12:17 <chrisdone> silver: outside of the UK I don't know what they call it. in a line, when the person next to you stands up with their hands in the air, you do it
10:12:17 <silver> never knew it's "mexican" :S
10:12:37 <dmwit> In the US, just "the wave".
10:12:48 * dmwit had to Wikipedia it =)
10:13:05 <byorgey> funny, I wonder why mexican
10:13:07 <chrisdone> I would wikipedia it but this free internet is only fast enough for IRC
10:13:15 <EvanR> hahaha mexican wave
10:13:17 <HugoDaniel> eheh
10:13:17 <scree> the one man mexican wave is the internationally accepted sign for "don't shoot oh you weren't going to"
10:13:25 <imc> greetings everybode!
10:13:28 <chrisdone> scree: haha
10:13:31 <silver> hey
10:13:59 <imc> little question for you : is it possible to write more than one pattern in a case alternative?
10:14:21 <monochrom> No.
10:14:24 <imc> like case x of  \ P1 | P2 -> something \ P3 | P4 -> something else?
10:14:25 <imc> ah
10:14:27 <imc> ok
10:14:28 <silver> mm?
10:14:41 <scree> or possibly "and it was literally this big"
10:14:41 <imc> (\ stands for newline)
10:15:05 <imc> thankyou monochrom
10:15:13 <EvanR> 'or pattern'
10:15:16 <EvanR> why did i think of that
10:15:18 <EvanR> didnt
10:15:20 <dmwit> imc: You can have named selectors on each of the constructors.
10:15:37 <dmwit> imc: e.g. data Foo  = Bar { label :: Int } | Baz { label :: Int } | Quux
10:16:02 <dmwit> imc: label :: Foo -> Int will then be a partial function, but you can use it in a fall-through case or so...
10:16:21 <imc> mm
10:16:27 <dmwit> imc: (But I, too, wish we had OCaml's nicety here.)
10:16:47 <monochrom> But it won't help with case xs of 0:_ -> longcode; 0:0:_ -> longcode {- again -}; 0:1:0:_ -> longcode {- moar -}
10:16:58 <imc> no, doesn't help too much in this case.... but nice thing that 'label' one
10:17:09 <EvanR> factor out the longcode into a let or where
10:17:22 <imc> ok, back to code :D
10:17:25 <dmwit> case xs of _ | any (`isPrefixOf` xs) [[0], [0,0], [0,1,0]] -> longcode
10:17:25 <monochrom> yeah we all know that
10:17:32 <dmwit> monochrom: ^^ =)
10:17:40 <chrisdone> dmwit: that kind of thing disturbs me because of the potential for label Quux
10:17:51 <imc> i had to do this school project in java.... what a pain! now i'm writing from scratch in haskell just for my pleasure
10:17:54 * dmwit nods at chrisdone
10:18:41 <monochrom> does not disturb me a bit
10:18:52 <Liskni_si> MarcWeber: it went as a link on irc, then you asked something, i answered, and you didn't reply
10:19:14 <monochrom> I would be very glad with data Maybe a = Nothing | Just { fromJust :: a}
10:23:49 <chrisdone> monochrom: well, fromJust disturbs me for the same reason
10:26:08 <int-e> hmmmm. goodForNothing :: Mazbe a -> (); goodForNothing Nothing = ()
10:26:17 <int-e> s/z/y/
10:28:08 <gwern> > 60 * 0.75
10:28:10 <lambdabot>   45.0
10:36:45 <chrisdone> gwern: kewl
10:39:29 <CalJohn> imc: looks like you might enjoy PatternGuards
10:40:04 <CalJohn> actually, ignore that
10:42:16 <EvanR> hrm, debug.trace doesnt occur when i think it should :)
10:47:26 <AnimalMachine> Is there a reason why Network.Socket.recvFrom blocks if there's no data to read? I thought it should return 0...
10:50:31 <chrisdone> AnimalMachine: don't all (or most) socket functions block by default? i would think you'd have to use select() to receive data otherwise
10:51:00 <EvanR> AnimalMachine: blocking sockets is great, and in haskell, its even greater because of threads
10:51:01 <chrisdone> AnimalMachine: i think you should do a check or something to see if there are any bytes on the socket before calling recv()
10:51:05 <chrisdone> iirc
10:52:41 <chrisdone> AnimalMachine: are you on Windows?
10:53:07 <mdmkolbe> I'm thinking about using darcs as a lightweight, serverless, concurrently accessible, nosql, ACID database.  To do that I need to be able to talk directly to a darcs repository and send it patches corresponding to the DB actions.  Is there a good introduction to writing that sort of thing with the darcs API?
10:53:11 <EvanR> the usual way to do networking is to make a forkIO to read from the thread and do something with it when itgets there
10:53:30 <gwern> mdmkolbe: have you looked at filestore?
10:53:33 <EvanR> read from the socket*
10:55:28 <mdmkolbe> gwern: I haven't.  Though for my system it needs to be able to distinguish between "rm line1 and insert another line at same place" and "change line1 to something else".  Can filestore do that?
10:55:43 <AnimalMachine> I'm on linux. I looked in Network.Socket for select and it's not there. What I'm doing is trying to make a client/server game and while forking my server part wouldn't be too bad, I'd rather not fork the client.
10:55:47 <gwern> mdmkolbe: what's the difference?
10:56:22 <EvanR> AnimalMachine: you dont normally use select in haskell
10:56:28 <EvanR> forkIO is a lot easier
10:56:39 <gwern> (that sounds like requiring people to know the difference between adding negative one and subtracting positive one from something - the end result is the same)
10:57:12 <EvanR> AnimalMachine: keywords, forkIO Chan MVar Control.Concurrent
10:57:20 <gwern> > (500 / 25, 75 / 7)
10:57:21 <lambdabot>   (20.0,10.714285714285714)
10:58:05 <chrisdone> AnimalMachine: hmm. looking at the documentaiton, recvFrom isn't supposed to block. are you 100% sure it's blocking?
10:58:30 <mdmkolbe> gwern: it has to do with merging of patches and conflicts.  The the latter causes conflicts that the former should not (at least in the Darcs model).  And to properly get ACID I need that level of control over conflicts.  (Give me a minute and I'll cook up an example.)
10:58:50 <EvanR> it does block
10:58:53 <gwern> mdmkolbe: does darcs actually distinguish between the two?
10:59:18 <gwern> mdmkolbe: filestore works through darcs's xml output; if you can make a patch that exhibits the difference and look at --xml-output, you'll see for yourself
10:59:54 <mdmkolbe> gwern: the back end of darcs does distinguish the two, I'm not sure the front end command-line interface provides access to that though
10:59:54 <AnimalMachine> chrisdone: you can use the RWH example from ch 27. adding a putStrLn in the procMessages loop shows that it blocks.
11:00:26 <chrisdone> AnimalMachine: actually I think EvanR is right, it's supposed to block the calling thread. on Windows it blocks the whole process if not compiled with -threaded
11:00:37 <chrisdone> http://hackage.haskell.org/trac/ghc/ticket/1129
11:00:49 <EvanR> AnimalMachine: alright, you want to do it the C way. you need to use Sockets.BSD to set the socket to non blocking with a setsockopt
11:01:05 <EvanR> then check for socket errors like E_WOULDBLOCK
11:01:13 <EvanR> that means nothing to read
11:01:17 <AnimalMachine> chrisdone: I found that one too, and I think that's probably the case.
11:02:40 <AnimalMachine> EvanR: where's that function again? I don't see it listed in Network.BSD and hoogle returns nothing.
11:03:00 <EvanR> you really dont want to do this, but ok
11:03:31 <AnimalMachine> well ... for datagrams is it really better to just connect, fork, and stm? seems like a bit much...
11:03:41 <mdmkolbe> gwern: eh, what darcs command would I use --xml-output with? (darcs chagnes --xml-output only gives the patch names)
11:03:41 <EvanR> setSocketOption
11:03:48 <EvanR> AnimalMachine: you dont connect datagram sockets
11:03:53 <gwern> mdmkolbe:  maybe --verbose as well?
11:04:09 <EvanR> AnimalMachine: you dont need stm
11:04:37 <mdmkolbe> gwern: nope
11:05:06 <mdmkolbe> gwern: I'm only getting the meta-info about the patch, not the patch contents
11:05:08 <gwern> Darcs.hs:  (_, _, output) <- runDarcsCommand repo "changes" ["--xml-output", name]
11:05:12 <gwern> hm
11:05:12 <AnimalMachine> EvanR. oh ... I think when I glanced at Chan's before I thought they were unidirectional. That might not be so bad afterall.
11:05:27 <AnimalMachine> Thanks for the help everyone, time to experiment some more. =)
11:05:28 <EvanR> they are, but (Chan a, Chan b) for example isnt
11:05:41 <EvanR> not that you need it for reading
11:06:04 <chrisdone> what does unidirectional mean in this context?
11:06:28 <EvanR> half duplex ;)
11:06:42 <ManateeLazyCat> Good news, all gtk2hs packages can install by Cabal (except gstreamer, and Axel have working on it).
11:06:44 <gwern> so.. monoplex??!
11:06:52 <EvanR> yes
11:06:56 <ManateeLazyCat> I have test gtk2hs with GHC-6.12.2, works fine.
11:07:14 <cinema> ManateeLazyCat: I aù installinhg gtk2hs, but have problems with pango
11:07:14 <lambdabot> cinema: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:07:25 <luite> ManateeLazyCat: ah nice work. how does it work on windows?
11:07:25 <ManateeLazyCat> cinema: I have fix it.
11:07:33 <ManateeLazyCat> cinema: Please pull new patches.
11:07:54 <cinema> ManateeLazyCat: From which repository ?
11:08:05 <ManateeLazyCat> cinema: In my patches for pango, no problem. But Axel push new patches break it.
11:08:12 <ManateeLazyCat> cinema: code.haskell.org/gtk2hs
11:08:40 <cinema> ManateeLazyCat: the message is Setup: can't find source for Graphics/Rendering/Pango/Types in .,
11:08:48 <mdmkolbe> gwern: anywho, it looks like filestore interface doesn't allow you do directly specify the patch.  It expects you to provide a new version of an object which it then applies a diff to get the patch.  For what I'm after, that would never work.
11:08:49 <mdmkolbe>   (b/c with only diff you can't distinguish between insert-line-next-to-delete-line and change-line)
11:08:52 <ManateeLazyCat> cinema: yes, please pull again.
11:08:59 <cinema> ManateeLazyCat: probably a recent patch broke everything
11:09:01 <ManateeLazyCat> cinema: I have fix it in newest patch.
11:09:19 <cinema> ManateeLazyCat: OK, I'll do it now
11:09:44 <AnimalMachine> EvanR: well ... when I thought of forking off the network recv/send funtions I figured I'd need a bidirectional way for the network thread to communicate with the main thread ...
11:09:53 <EvanR> dont use just two
11:10:06 <AnimalMachine> EvanR: yea. didn't occur to me. lol
11:10:08 <EvanR> in haskell forkIO threads are cheap
11:10:19 <ManateeLazyCat> luite: Well, i haven't Windows for Test.
11:10:23 <EvanR> you make like a million, treat them as any other data
11:10:24 <cinema> ManateeLazyCat: Thanks a lot, it works now
11:10:26 <AnimalMachine> thanks again
11:10:40 <ManateeLazyCat> luite: But i think it's should be easy because we have convert all packages to Cabal.
11:11:10 <ManateeLazyCat> luite: I think have some Windows user try to make it work.
11:11:32 <ManateeLazyCat> luite: Plase read detail from gtk2hs list.
11:11:48 <ManateeLazyCat> luite: I just test gtk2hs on linux. :)
11:12:22 <luite> ManateeLazyCat: ah ok. I was wondering how you should install the gtk dev packages to make it work
11:12:28 <ManateeLazyCat> cinema: Please report any problem, i have test all Cabal packages with GHC-6.12.2, works fine.
11:12:53 <cinema> ManateeLazyCat: OK, I'll test everything I can
11:13:08 * ManateeLazyCat pasted "package dev for gtk2hs" at http://paste2.org/get/804833
11:13:49 <luite> hehe unfortunately, windows doesn't have aptitude :)
11:13:55 <ManateeLazyCat> cinema: Please don't install below packages: gstreamer, sourceview, mozembed
11:14:10 <ManateeLazyCat> cinema: gstreamer have some technology need to fix.
11:14:27 <ManateeLazyCat> cinema: sourceview is departed
11:14:57 <ManateeLazyCat> cinema: mozembed is break long time that i don't know how to make it work in my box.
11:15:00 <EvanR> is there a clamp function, like a min or max but for an interval
11:15:12 <ManateeLazyCat> cinema: But i think you can use webkit package instead mozembed.
11:15:47 <EvanR> @hoogle Ord a => a -> a -> a -> a
11:15:48 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
11:15:48 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
11:15:48 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
11:16:21 <ManateeLazyCat> cinema: I think everything is stable as gtk2hs-0.10.1, because we just add few functions and fix bugs in this version.
11:16:48 <ManateeLazyCat> cinema: Haven't push new patches (Gtk+ 2.18.3, gio 2.24.0) to main repository.
11:18:02 <ManateeLazyCat> We will split all non-core packages from main repository, such as, webkit to http://code.haskell.org/webkit, vte to http://code.haskell.org/vte ... etc.
11:19:25 <gwern> mdmkolbe: eh. in that case you're on your own. the darcs api was relatively recently exposed and few have used it
11:19:29 <gwern> preflex: seen dons
11:19:29 <preflex>  dons was last seen on #haskell 2 days, 3 hours and 58 seconds ago, saying: * dons loves investments in the toolchain
11:19:32 <gwern> preflex: seen sjanssen
11:19:32 <preflex>  sjanssen was last seen on #haskell 25 days, 17 hours, 40 minutes and 28 seconds ago, saying: Veinor: there are potential slowdowns when using -threaded on a single processor
11:19:40 <cinema> ManateeLazyCat: and is gtkglext working ?
11:19:47 <ManateeLazyCat> cinema: Yes.
11:20:15 <ManateeLazyCat> cinema: All packages except `gstreamer` `sourceview` `mozembed`.
11:20:32 <cinema> ManateeLazyCat: OK, thanks
11:21:02 <ManateeLazyCat> cinema: I don't change any code, just do a convert, if you have any code use gtk2hs-0.10.1, should be okay in this version.
11:21:37 <cinema> ManateeLazyCat: OK, I'll try compiling my code now
11:24:05 <ManateeLazyCat> cinema: We do some clean work (change path some modules and hidden internal modules), please report any problem to gtk2hs list, we will adjust gtk2hs for your code. :)
11:24:27 <CalJohn> @hoogle a -> [a] -> Bool
11:24:28 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:24:28 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:24:28 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:24:30 <ManateeLazyCat> cinema: Or report to me, i can adjust it immediately. :)
11:26:02 <cinema> ManateeLazyCat: Error message: Failed to load interface for `Graphics.UI.Gtk.Pango.Layout'
11:28:08 <ManateeLazyCat> cinema: Yes, Axel change path.
11:28:23 <cinema> ManateeLazyCat: It seems the module is in Graphics/Rendering/Pango now. OK I'll change the path
11:28:26 <ManateeLazyCat> Change to "Graphics/Rendering/Pango/Layout.chs"
11:29:27 <ManateeLazyCat> cinema: Sorry for inconvenience, i think change to Rendering is right thing.
11:30:04 <cinema> ManateeLazyCat: I'm doing it now
11:30:41 <ManateeLazyCat> Because pango don't need Gtk, so `Graphics.UI.Gtk.Pango.Layout` is wrong path.
11:31:03 <ManateeLazyCat> cinema: We will add those notes in next version.
11:31:22 <cinema> ManateeLazyCat: now, Module   `Graphics.Rendering.Pango.Font'   does not export    `FontMetrics(..)'
11:31:51 <ManateeLazyCat> Graphics/Rendering/Pango/Enums
11:33:15 <mjrosenb> just curious
11:33:23 <cinema> ManateeLazyCat: Thanks, it compiles now
11:33:38 <mjrosenb> would stream fusion be intelligent enough to optimize this in the obvious way?
11:34:18 <mjrosenb> takeWhile f l ++ take n (dropWhile f l)
11:35:08 <cinema> ManateeLazyCat: And it works !  My program pretty-printer generates correct postscript code
11:35:19 <ManateeLazyCat> cinema: Axel hidden some internal modules, and this perhaps break you code. If you code need some functions that have hidden in Cabl version, please report it.
11:35:27 <kayuri> Hi, I've updated cabal and now got "cabal: (: openFile: does not exist (No such file or directory)" each time I wan't cabal to perform any operation. Haskellers, could you point me to the solution of my problem?
11:35:50 <cinema> ManateeLazyCat: Thanks a lot for your help
11:35:54 <ManateeLazyCat> cinema: We will do re-expoert or give you suggestion that how to change your code.
11:35:59 <ManateeLazyCat> cinema: NP :)
11:36:15 <mjrosenb> kayuri: it sounds like the solution is one part haskell and one part version mismatch
11:38:04 <ManateeLazyCat> cinema: I have check Axel's patches detail, i think most break code will happened with pango like your situation.
11:38:39 <cinema> ManateeLazyCat: These are easy to fix anyhow
11:38:40 <ManateeLazyCat> cinema: If new version break you GIO code, it's my fault, i change gio path for merge new APIs. :)
11:38:47 <kayuri> mjrosenb: hmm, you are right, but I haven't found any fine way to substitue hs-cabal from MacPorts with haskell-platform one.
11:39:07 <cinema> ManateeLazyCat: I don't use gio yet
11:39:59 <ManateeLazyCat> cinema: Currently, GIO is not un-complete in gtk2hs main repo, if you want try to use all APIs in GIO, try to get code from https://patch-tag.com/r/AndyStewart/gio-branch/
11:40:17 <ManateeLazyCat> is uncomplete in main reo.
11:40:42 <ManateeLazyCat> https://patch-tag.com/r/AndyStewart/gio-branch/ is temporary repository for test new GIO APIs,.
11:41:06 <ManateeLazyCat> cinema: I will merge those patches when Axel have time review it.
11:41:50 <cinema> ManateeLazyCat: Bravo for the good work
11:42:32 <ManateeLazyCat> http://www2.in.tum.de/~simona/gtk2hs-2.18/ this repository have many patches for Gtk+ 2.18.3
11:42:50 <ManateeLazyCat> cinema: But some functions still need review before push to main repo.
11:43:29 <ManateeLazyCat> cinema: If you want help us review code, try test http://www2.in.tum.de/~simona/gtk2hs-2.18/ :)
11:43:51 <ManateeLazyCat> cinema: Otherwise use code from main repository (old but stable)
11:46:00 <ManateeLazyCat> cinema: I need go to bed, good night. :)
11:46:26 <cinema> ManateeLazyCat: Good night, and many thanks
12:02:00 <nyachtung> hi. What categorical construction corresponds to universal quantification?
12:02:30 <danharaj> In what context.
12:03:56 <nyachtung> I think I mean forall in System F
12:04:24 <byorgey> nyachtung: universally quantified Haskell (or System F) types often correspond to natural transformations.
12:04:37 <byorgey> that may or may not be what you're looking for.
12:05:25 <mreh> @quote monads looking for
12:05:25 <lambdabot> No quotes for this person. My pet ferret can type better than you!
12:05:44 <nyachtung> But what if there is no arrow in the type? (ie forall a. [a])
12:05:48 <danharaj> There's a rough correspondence of type constructors and functors, and functions defined on polymorphic types and natural transformations.
12:08:23 <nyachtung> And the type should be some object of the category (that should be something like a "set" of all natural transformation between two functors). ?
12:13:12 <danharaj> It's more like, when you define a function on a polymorphic type, it has to be defined 'in the same way' for each type. This corresponds to the fact that it is a natural transformation.
12:13:56 <dolio> nyachtung: forall a. [a] is like a colimit in category theory (I think that's right).
12:16:26 <dolio> There's an arrow f : (forall a. [a]) -> [T] for any type T.
12:17:06 <dolio> And for any g : T -> U, map g . f = f.
12:17:07 <nyachtung> Yeah, it looks like (co)limits. But there must be a problem with functors that aren't actually functors like F(a) = a -> a
12:17:33 <dolio> @free l :: forall a. [a]
12:17:33 <lambdabot> $map f l = l
12:17:57 <dolio> forall a. a -> a is something else.
12:18:16 <nyachtung> But there must be some generalization...
12:18:17 <dolio> I'm not sure there's any one categorical concept that covers all polymorphic types.
12:19:04 <danharaj> forall a. a->a sits nicely inside of forall a b. a-> b which is a bifunctor
12:19:41 <dolio> Yes. forall a. a -> a is a coend (I think) of (->).
12:20:00 <dolio> (Co)ends might subsume (co)limits.
12:20:20 <danharaj> Everything is a kan extension :p but I'll get back to you on that in a few weeks.
12:20:20 <dolio> (My knowledge of category theory gets sketchy about there.)
12:20:59 <dolio> Anyhow, even if you make sense of those, I'm not sure if they cover all higher-rank types.
12:21:34 <dolio> (forall a. (forall b. (forall c. (forall d. d -> c) -> b -> c) -> b) -> a) -- what is this?
12:22:02 <danharaj> ugly.
12:25:11 <fax> ?djinn (forall a. (forall b. (forall c. (forall d. d -> c) -> b -> c) -> b) -> a)
12:25:11 <lambdabot> -- f cannot be realized.
12:31:53 <chrisdone> ?djinn Bool -> a -> Bool
12:31:54 <lambdabot> f a _ = a
12:32:27 <m_z> do you have to create a file called Main.hs to compile a haskell executable?
12:32:34 <danharaj> yes
12:32:36 <chrisdone> ?djinn a -> (b -> c) -> b - > c
12:32:36 <lambdabot> Cannot parse command
12:32:41 <chrisdone> ?djinn a -> (b -> c) -> b -> c
12:32:41 <lambdabot> f _ a b = a b
12:32:46 <m_z> thanks
12:32:58 <danharaj> wait no
12:33:03 <danharaj> you just need a module Main
12:33:17 <danharaj> My bad.
12:33:41 <m_z> so the file can be named anything you like, but has to have "module Main (main) where" at the top?
12:33:50 <AnimalMachine> m_z correct
12:34:24 <AnimalMachine> m_z: and you can set which file has the Main module in your cabal file with "Main-is"
12:40:09 <m_z> ok thanks
12:55:27 <sallysue> Hello gentlemen! I am an actual woman; I have one of those where your penis goes! Now I am here to issue a challenge: The one who is able to make a useful program in Haskell gets to have his way with my special place. I feel safe saying that here.
12:55:48 --- mode: ChanServ set +o mauke
12:55:48 --- kick: sallysue was kicked by mauke (sallysue)
12:56:08 <opqdonut> sigh
12:56:34 <p_l> ...
12:56:43 --- mode: mauke set +b *!~55c89673@gateway/web/freenode/x-lwucohxnlkqcgxrk
12:56:50 <monadic_kid> again!
12:58:43 --- mode: mauke set -o mauke
12:59:03 <gwern> monadic_kid: I was just about to say, why would someone troll that way a second time?
13:00:32 <Minimiscience> Is it good style for some functions in a library to return "ReaderT a (Either String) b" and others "ReaderT a Identity b"?
13:00:39 <fnord123> > print "/set mode +kb sallysue"
13:00:40 <lambdabot>   <IO ()>
13:00:48 <fnord123> sweet; now i can have my special way.
13:00:51 <ddarius> dolio: It's called a dinatural transformation and leads to the theory of (co)ends.
13:00:57 <fnord123> wait. doh!
13:01:27 <ddarius> Incidentally, universal quantification is closer to a limit than a colimit.
13:02:23 <danharaj> There is a way in which universal and existential quantification are in an adjunction relationship, but I'm not clear on the details.
13:02:34 <danharaj> I have a few books on categorical logic/type theory I've been meaning to get through.
13:02:45 <ddarius> danharaj: Universal quantification is the right adjoint of weakening, existential quantification is the left adjoint.
13:03:19 <danharaj> and something something fibered categories.
13:03:29 <DigitalKiwi> gwern: maybe they really want to get laid and just don't want to admit it?
13:03:39 <gwern> anyone have any suggestions for who should have core commit bit for xmonad?
13:03:51 <DigitalKiwi> have you not read the best of craigs list about why you should date a geek?
13:04:05 <dolio> ddarius: You can view the type (forall a. [a]) as the colimit of the diagram [], though, no? Or do I have that wrong?
13:04:09 <DigitalKiwi> http://www.craigslist.org/about/best/sfo/66795671.html
13:04:51 <monadic_kid> Minimiscience: You probably want to use a type-class instead of a specific monad stack in your interface and you probably want to hide your stack in a newtype definition with it's constructor hidden in a module.
13:05:38 <monadic_kid> Minimiscience: something like foo :: MonadReader r m  => ....
13:06:38 <dolio> Oh, I do have it backwards.
13:06:59 <dolio> (forall a. [a]) -> [T] with the free theorem makes it a cone.
13:07:02 <dolio> And it's a limiting cone.
13:08:09 <fax> I don't get cones
13:08:27 <ddarius> fax: They are natural transformations from the constantly X functor for some X.
13:08:38 <Cale> If you have a limit, I will give it to you, if you have no limit, I will take it away from you.
13:08:44 <DigitalKiwi> fax: you should see your doctor about that
13:09:05 <DigitalKiwi> they make a pill for that now
13:09:58 <gwern> Cale: a ship cannot anchor where the water is too shallow?
13:10:13 <jbapple> Where does cabal put its extra-source-files?
13:10:22 <jbapple> or, cabal-install, I guess
13:10:44 <Saizan> they are in the tarball
13:10:53 <gwern> jbapple: /usr/share I thought or its equivalent
13:11:11 <monadic_kid> data-files puts into share
13:11:12 <jbapple>  /usr/share is big
13:11:26 <Saizan> (if there are any)
13:11:31 <jbapple> where does the tarball get stored?
13:11:58 <Saizan> there's a cache under ~/.cabal/packages
13:12:18 <jbapple> Is there a permanent/global location?
13:12:22 <Saizan> however if you need some files to be installed in the system you should specify them as data-files instead
13:12:47 <Saizan> and you can access the location via the Paths_$pkg module
13:12:47 <jbapple> maybe I should do that
13:13:08 <jbapple> Where can I find more information on the Paths_$pkg module?
13:13:27 <Saizan> the cabal manual, i think
13:13:37 <jbapple> gwern: I can't find anything in /usr/share or /usr/local/share that seems to match
13:13:45 <gwern> jbapple: I could be wrong...
13:15:08 <Saizan> extra-source-files are not copied anywhere during installation, they are only copied by sdist into the tarball
13:15:43 <Saizan> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#general-fields
13:16:00 <jbapple> Thanks, Saizan
13:16:22 <jbapple> I don't think cabal has a category for the files I want to include
13:16:46 <jbapple> They are source files, but for a different compiler, but also documentation/proof files by the curry-howard isomorphism :-)
13:16:47 <Saizan> well, the data-files can be anything
13:17:52 <Saizan> you could ask yourself what do you want cabal to do with them :)
13:19:42 * Saizan wonders if encoding dependent pairs as coinductive types is ok.
13:21:58 <danharaj> Is there a reason other than a lack of neccessity that Haskell doesn't have namespaces in the same way C++/etc. do?
13:22:10 <danharaj> in addition to the module level qualifications.
13:27:34 <jbapple> In principle, I doubt anyone considers *additional* reasons once they think something is totally unnecessary
13:28:03 <danharaj> Well, just because something is unnecessary doesn't mean it's not convenient.
13:28:23 <danharaj> I'm all for parsimony in most cases.
13:28:36 <jbapple> You're right, there is kind of a gap between "necessary" and "totally unnecessary" in which "convenient" lies
13:29:06 <danharaj> and whom you ask gives you a different answer :p
13:29:18 <jbapple> How would namespaces in Haskell make things more convenient? IIRC, namespaces & Haskell modules are similar
13:29:56 <mjrosenb> also, the fact that you can introduce local bindings using with and/or let
13:29:59 <danharaj> Well, you can't export qualified names via modules, you can only import them as qualified. Suppose you could put namespaces in modules. Then things in those namespaces would be qualified.
13:31:36 <jbapple> I see
13:41:58 * hackagebot meldable-heap 1.1.2 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-1.1.2 (JimApple)
13:42:13 <fax> Cool.
13:43:01 <danharaj> "An identifier is treated as a single token using try."
13:43:08 <jlouis> jbapple: nice with the Coq verification
13:43:14 <jlouis> jbapple: extraction?
13:43:32 <danharaj> From the parsec TokenParser documentation. Can anyone tell me what it means?
13:43:44 <fax> jlouis (yes)
13:43:54 <jbapple> jlouis: http://code.google.com/p/priority-queues/source/browse/brodal-okasaki/Extract.v
13:44:22 <fax> jbapple++
13:44:52 <jlouis> jbapple: oh, yes that is nice. I have a heap here based on psqueue which I go pondering on how to replace
13:44:55 <jbapple> thank you :-)
13:45:17 <jon_of_arc> danharaj: I'm pretty sure that just indicates that (outside of the identifier-parsing combinator) a failed identifier parse is never considered to have consumed input
13:45:27 <jbapple> well, priority search queues can do things that regular priority queues can't
13:45:28 <tommd> jbapple: 1) Does the hackage package include coq source 2) Do you have any opinions to share on how the development went
13:45:36 <jon_of_arc> danharaj: implemented in terms of try
13:45:52 <jlouis> jbapple: true, and I do use the search feature of them :)
13:45:56 <jbapple> tommd: (1) yes (2) yes
13:45:57 <danharaj> Ah thanks, that makes sense.
13:46:30 <tommd> jbapple: Perhaps I can look forward to a blog post then?
13:46:40 <jbapple> tommd: Maybe :-)
13:47:33 <jbapple> Some things about coq were a pain: extraction from modules doesn't work, for instance
13:48:01 <tommd> Hum, I will certainly remember that!
13:48:18 <jlouis> I would like to read a blogpost on using Coq
13:48:23 <jlouis> for that, that is
13:48:26 <jbapple> also, I got bitten by a strict positivity requirement, so I couldn't make things as modular as I would like
13:48:52 <jbapple> as a matter of fact, I need to ask a question on #coq about that.
13:48:53 <jbapple> brb
13:51:05 <jbapple> ok, I guess I don't
13:51:22 <jbapple> another tricky bit was coming up with the specification
13:51:37 <jbapple> I went through two before I found one I thought was strong enough
13:51:49 <jbapple> Now I think I can write an even stronger one
13:52:12 <jbapple> This is complicated by the fact that, contrary to popular belief, <= need not be antisymmetric
13:52:30 <jbapple> for instance, f <= g = f 1 <= g 1
13:52:31 <Luigi> hii
13:53:44 <jbapple> tommd: I should note: extraction of *Haskell* from modules doesn't work
13:53:52 <jbapple> extraction of O'Caml works fine, IIRC
13:53:58 <jbapple> and I didn't try Scheme
13:54:23 <Luigi> hello
13:54:57 <hellidunno> hi
13:55:12 <fax> hi
13:55:14 <jbapple> Another thing I found is that, when possible, it was better to define props as functions than as inductive datatypes.
13:55:14 <Luigi> hii
13:55:24 <fax> jbapple: that's interesting, why?
13:55:29 <fax> to do with proof irrelevance?
13:55:35 <Luigi> n
13:55:35 <jbapple> Then you don't have to muck with constructors sometimes
13:56:03 <jbapple> and simplify does a lot of work for you
13:56:25 <tommd> hum, very interesting
13:56:37 <jbapple> the YNot people had something about that in their most recent paper, I think
13:56:55 <jbapple> Let's see, what else . . .
13:57:14 <jbapple> Program is a trap is you want to prove anything about your programs later
13:57:40 <fax> hehe
13:57:49 <jbapple> Function, on the other hand, it quite nice
13:57:54 <tommd> yeah, I learned that one but thought it was just that *I* can't use Program.
13:57:57 <fax> jbapple: I hope that will change once coq has proof irr.
13:58:05 <tommd> irr?
13:58:12 <jbapple> irrelevance
13:58:15 <tommd> ahh
13:59:15 <jbapple> Type classes are also tricky
13:59:48 <jbapple> Oh, here's something else I learned: plan ahead for extraction, don't use coq's built-in unary nat type
13:59:52 <tommd> ... can't say that's very surprising.  What's more surprising is you ran into that in this project.
13:59:59 <tommd> the type class comment.
14:00:44 <tommd> jbapple: I'll have to look over your code - this has always been a question in my mind (how to avoid using nat, use Integer and even Int when possible)
14:01:41 <jbapple> look for "Variable" in Bootstrap.v
14:01:48 <tommd> thank you
14:02:24 <tommd> jbapple: I have to run, thank you for the comments!
14:02:28 <tommd> and the package!
14:02:49 <jbapple> you're welcome
14:03:51 <Guest23470> How to compute with Ratio?
14:04:24 <mauke> normally
14:05:14 <pedagand> hi folks. Anyone using etags on Bird-style literate haskell code?
14:05:26 <pedagand> Using hasktags, emacs uses the wrong regexp to locate functions in the buffer. I'm having a bad time trying to fix that. No success so far.
14:05:46 <aavogt> is this the tags stuff that ghci does?
14:06:45 <pedagand> well, I'm not working on interpreted code. I read that this stuff was for interpreted code only (on the haskell wiki)
14:07:36 <cizra> I'm trying to run quickcheck, but I get this error:     No instance for (Arbitrary Char)
14:07:44 <pedagand> aavogt, yeah, according to GHC doc, it's for the currently loaded module
14:07:51 <cizra> indeed, Test.QuickCheck.Arbitrary didn't get installed with cabal.
14:08:03 <aavogt> is there some reason you can't load your module(s) in ghci?
14:09:49 <jbapple> How can I import Paths_pkgname?
14:10:01 <pedagand> it's a non negligible code base, with some pre-processing madness (She)
14:10:08 <jbapple> > :m + Paths_meldable_heap
14:10:08 <jbapple> <no location info>:
14:10:08 <jbapple>     Could not find module `Paths_meldable_heap':
14:10:08 <jbapple>       it is not a module in the current program, or in any known package.
14:10:09 <lambdabot>   <no location info>: parse error on input `:'
14:10:31 <jbapple> I just want to find out where cabal installs my extra files
14:10:34 <aavogt> jbapple: :set -idist/build/autogen
14:10:54 <aavogt> provided you have configured the package
14:10:57 <jbapple> aavogt: same error message
14:11:07 <jbapple> I have cabal installed the package
14:11:14 <aavogt> as in, run runghc Setup configure
14:11:29 <jbapple> I'm in ghci
14:11:36 <jbapple> do I need to load Setup.hs into ghci?
14:11:40 <aavogt> no
14:12:03 <jbapple> so, I installed the package from hackage
14:12:09 <jbapple> then I load GHCi with no files
14:12:14 <aavogt> anyways, at some point cabal writes a  Paths_program_name.hs inside    dist/build/autogen
14:12:36 <jbapple> where is the dist directory?
14:12:57 <b0fh_ua> Hi there. I have 2 functions: func1 :: Int -> IO (Either Int String) and func2 :: Int -> IO (Either Int String). With Control.Monad.Either I could write something like func1 1 >>= func2, but that IO stuff doesn't allow me to do so. Do you have any suggestions of how to implement such kind of chaining of function calls?
14:13:04 <mdmkolbe> Does happstack always have to run as a server?  Can it run as a CGI instead?
14:13:06 <aavogt> you can't load the Paths_program module unless it was exported by the cabal file
14:13:21 <jbapple> goddamit
14:13:37 <aavogt> or if you have that file there for you
14:13:42 <jbapple> I just want to give people who cabal install my package the ability to look at some extract documentation/source files
14:13:48 <jbapple> I do not know how to do this
14:14:02 <jbapple> extra-source-files does not install the files
14:14:09 <aavogt> you know how you list your exported-modules:  in the cabal file?
14:14:13 <jbapple> data-files hides them somewhere you need GHCi to find
14:14:36 <aavogt> you can include the Paths_...  module
14:14:56 <aavogt> though perhaps it's better to reexport that module from from something with a more sensible name
14:15:05 <jbapple> That seems like extreme overkill. Users don't need to be able to find the files from inside a GHC runtime
14:15:28 <jbapple> I just want them to be able to read the files with "less"
14:15:36 <jbapple> and open them with emacs
14:15:48 <aavogt> do you have an executable with your library?
14:15:59 <jbapple> no
14:17:00 <aavogt> anyways, it isn't that difficult to look in ~/.cabal/share/program-version/*
14:17:06 <jbapple> Is it true that there is no way to package up documentation with cabal other than with haddock?
14:17:29 <jbapple> that only works with local installs
14:17:41 <jbapple> global installs do not appear to leave any packages there
14:17:46 <jbapple> at least, not on my system
14:18:19 <aavogt> right, they put the data files somewhere else
14:18:29 <cizra> gahhh
14:18:31 <cizra> Trouble with cabal!
14:18:43 <jbapple> So what goes in ~/.cabal/share/program-version
14:19:02 <cizra> cabal list quickcheck says Latest version available: 2.1.0.3. However, when I cabal install/upgrade quickcheck, it gets me the same old 1.2.something version!
14:19:27 <jbapple> cabal install "quickcheck >= 2.0"
14:19:53 <jbapple> if not the data files?
14:20:04 <cizra> Huh. Why does the default not work right?
14:21:52 <jbapple> aavogt: It appears the data files DO end up in that directory
14:22:15 <jbapple> along with the extra-source files
14:22:16 <triyo> I'm setting up haskell dev in my emacs env. I have haskell-mode setup correctly. Is there support for running ghci and sending haskell expressions to it from haskell-mode buffer in emacs?
14:22:21 <jbapple> but ONLY on a local install!
14:22:27 <jbapple> arg!
14:23:37 <jbapple> OK, let me rephrase my question in a context readable by those who haven't been following along:
14:23:52 <hstefan1> hello. So, I'm working on an exercise and found: 3^n = 1459. How can I found the N?
14:23:55 <aavogt> because global installs go somewhere in /usr/local?
14:24:05 <hstefan1> ooops, sorry
14:24:08 <hstefan1> wrong channel
14:24:36 <jbapple> Is there any way to add extra documentation files to a cabal package such that the files can be located by a human without loading up a GHC runtime, even if the package is installed globally?
14:26:07 <jbapple> BTW, I finally found the files: /usr/local/share/mypackage
14:26:13 <jbapple> I had to pack them as data
14:26:32 <jbapple> and they may be installed somewhere else in the future, since cabal makes no promises about locations
14:26:54 <triyo> Oh I have "haskell-mode-hook 'turn-on-haskell-ghci" in my .emacs file. So all I had to do was C-c C-l.
14:27:31 <danharaj> Maybe I shouldn't code while drinking a glass of wine
14:28:31 <jbapple> aavogt: thanks for your help
14:29:52 <fnord123> cizra: what version of ghc?
14:33:17 <pgs31> evening all
14:33:23 <pgs31> Quick question for you
14:33:33 <pgs31> How do I turn a Word64 into a Word64# ?
14:34:21 <Lemmih> pgs31: Are you sure you really wanna do that?
14:34:34 <pgs31> It's a bit of an experiment
14:34:42 <pgs31> I've got a 2gb files full of them
14:34:46 <pgs31> file, even
14:34:50 <Lemmih> pgs31: case your_word of W# w# -> ...
14:34:58 <Lemmih> ?src Word64
14:34:58 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:35:09 <Lemmih> Eh, something like that.
14:35:15 <pgs31> And I was wondering how much memory I would save if I unboxed them..
14:36:12 <pgs31> Lemmih: I don't quite understand the case statement above..
14:36:15 <Lemmih> pgs31: How about using an array of unboxed words?
14:36:26 <pgs31> Yes, that is the idea
14:36:34 <Lemmih> pgs31: Word64 is just a box around a Word64#
14:36:56 <pgs31> Lemmih, indeed - but I get a Word64 back from Data.Binary.Get
14:37:11 <pgs31> I was wondering how to turn that in to a Word64# to put in an array
14:37:19 <Lemmih> pgs31: bbl
14:37:29 <pgs31> Lemmih: Sure, take your time :)
14:38:27 <pgs31> Lemmih: (as a stepping stone, I've made a non-polymorphic list like think to stick them in - e.g. data WordList = EmptyWordList | ConsWordList Word64# WordList
14:38:50 <aavogt> jbapple: perhaps just add an executable to your library that lists your installed documentation?
14:39:07 <aavogt> though this should probably be a cabal-install feature
14:39:34 <danharaj> So I'm importing "whiteSpace" from Parsec.Token as P, so P.whiteSpace, and then defining whiteSpace in my module, but ghc still says there's an ambiguity. I don't understand, can someone help?
14:40:27 <pgs31> danharaj: Did you import it with 'qualified' ?
14:40:30 <aavogt> why must data-accessor-template remain broken for cabal install users!?
14:40:40 <fffej> I'm trying to use the Data.Vector package (the mutable part).  I'm got a simple function, but I can't get the type signature right, nor can I understand the one GHC tells me.  Code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25271#a25271 - could someone help me understand what the type of x / s is and why?
14:40:51 <danharaj> yeah that was the problem pgs
14:41:04 <danharaj> So without qualified, it imports both the plain name and the qualified name right?
14:41:34 <pgs31> danharaj: I'm not entirely sure, a bit of a newb myself :)
14:41:53 <aavogt> fffej: you probably don't want to return $ GM.write
14:42:40 <danharaj> I have a feeling once I get the parsec token library this'll be easy to do in the future. :|
14:42:43 <aavogt> as in, drop the return, if GM.write has the type I think it does
14:43:00 <pgs31> danharaj: good luck!
14:43:03 <fffej> @aavogt I see - thanks  (so I was doing IO (IO ())  or something similar)
14:43:03 <lambdabot> Unknown command, try @list
14:43:42 <fffej> aavogt: thanks, that fixed it
14:44:23 <aavogt> though that's sort of beside the problem you have for typing addSource
14:44:46 <fffej> :)  what other problems do I have?
14:48:06 <aavogt> fffej: apparently none once you change that around. It might be nicer to use forM_ [0..sz] $ \a -> do ...
14:48:26 <aavogt> so there isn't that f name around
14:48:28 <jbapple> aavogt: http://hackage.haskell.org/trac/hackage/ticket/674
14:49:11 <fffej> aavogt: thanks, so as a general rule I want less name hanging around? (I've got no sense of what constitutes good Haskell style)
14:49:23 <aavogt> I dunno, either is common
14:50:02 <cizra> fnord123: The Glorious Glasgow Haskell Compilation System, version 6.12.1
14:50:25 <ski> fffej : it depends
14:51:45 <ski> fffej : e.g., there's usually not much point in naming every subexpression in an expression; otoh, naming "strategic" parts can improve readability a lot
14:52:13 <fffej> ski: makes sense
14:52:44 <ski> fffej : but, in e.g. `forM_' (but also in `map',`foldr',`any',&c.) the function argument often acts like a "loop body" in an imperative language .. where it doesn't always make sense to name it
14:53:39 <pgs31> Lemmih: With your advice I did some digging around in the source, and the following does the trick:
14:53:39 <pgs31> myUnboxer (W64# i) = i
14:54:24 * ski would probably call that `unW64#' ..
14:54:29 <aavogt> as in, your name 'f' doesn't say anything so if you can cleanly leave it out, there's less to think about
14:54:43 <fffej> thanks aavogt + ski
14:55:44 <pgs31> ski: good plan :)
14:55:47 <tommd> Is there a "RandomGen" like class that allows failure of the RNG?
14:56:04 <pgs31> ski: Confusingly, doing that actually makes my program use slightly _more_ memory
14:56:07 <gwern> sometiems I reflect - 'Marvin Minsky is still alive!' and an somewhat amazed
14:56:08 <ski> tommd : not that i can think of
14:56:09 <ddarius> Why would a random number generator fail?
14:56:18 <jbapple> if your system runs out of entropy
14:56:26 <ddarius> Then you wait for more.
14:56:35 <tommd> ddarius: Many PRNGs can produce a limited number of pseudo random bits before repeat
14:56:40 <ski> pgs31 : *renaming* causes your program to use more memory !?
14:56:45 <gwern> ddarius: what if it's special stored entropy you bought?
14:56:59 <ddarius> Then you buy more.
14:57:12 <pgs31> ski: no no, not renaming - changing from a list of Word64 to a list of Word64#
14:57:31 <ddarius> You can't have a list of Word64#
14:57:50 <ski> @kind GHC.Exts.Word64#
14:57:51 <lambdabot> #
14:57:54 <ski> @kind [GHC.Exts.Word64#]
14:57:55 <lambdabot>     Expecting a lifted type, but `GHC.Prim.Word64#' is unlifted
14:57:55 <lambdabot>     Expected kind `*', but `GHC.Prim.Word64#' has kind `#'
14:58:00 <ski> @kind []
14:58:00 <lambdabot> * -> *
14:58:24 <ski> it's a kind error
14:58:35 <pgs31> ddarius: not quite a list, of course. A 'MyWordList': data WordList = EmptyWordList | ConsWordList Word64# WordList
14:58:35 <mjrosenb> ski: you're so kind
14:58:50 <ski> mjrosenb : hahaha :)
14:59:24 <pgs31> ski, ddarius: Time for adventures in Data.Vector
15:00:04 <pgs31> (ps: Is Data.Vector the best tool for storing very long lists of numbers?)
15:00:28 <mjrosenb> pgs31: depends, lists are pretty good at storing things
15:01:17 <pgs31> mjjrosenb: I've been doing a few little tests - a 200mb file of words when forced to load into a list makes my program use about 750mb
15:01:29 <pgs31> mjrosenb: Which isn't a total disaster
15:01:29 <ddarius> pgs31: The question is what you want to do with the "lists of numbers."  If the only operation you want to do is store them, then I recommend ().
15:01:34 <mjrosenb> pgs31: ahh, you are concerned about memory usage.
15:01:47 <tommd> pgs31: It can't be lazy?
15:01:51 <tommd> You need all that at once?
15:02:10 <mjrosenb> pgs31: because lists are *awesome* for doing operations on the first two or three elements at a time
15:02:17 <gwern> ddarius: what is the signature of the 'buy more' function?
15:02:21 <ski> fffej : an example. say you wanted to check whether there are two unequal elements of a list `xs', both larger than `n'
15:02:39 <ski> fffej : one way of writing this is as `any (\x0 -> any (\x1 -> x0 /= x1 && all (n <) [x0,x1]) xs) xs'
15:02:46 <pgs31> tommd: Well not always, but sometimes - I am very often going to be using that same base list lots of times for different things.
15:03:02 <pgs31> tommd: So it would be nice to just get the pain over and get it in memory
15:03:33 <ski> fffej : another way is as `let f x0 = any g xs where g x1 = x0 /= x1 && all (n <) [x0,x1] in any f xs'
15:04:01 <ruperdupe> Hey, what's the best way to show a Rational as a decimal. i.e.  (1 % 100) to 0.01 Thanks
15:04:14 <pgs31> ddarius: I want to do things like adding them up, merging them with other lists, taking averages etc (the data is high frequency timeseries for.. you guessed it.. finance ;)
15:04:36 <ski> fffej : i think you'll agree that the former of those is slightly clearer than the latter (even if you put the "main" expression first, and "hang" the rest on a `where'-clause on the enclosing definition)
15:04:54 <pgs31> pgs32: mjrosenb sure, but by and large when I am doing something I will be doing it to the whole list
15:05:05 * pgs31 fails at irc
15:05:35 <pgs31> So given that, are lists a bad idea? Or am I Just Doing It Wrong :)
15:05:46 <ski> fffej : but, in this case, i think i would prefer  (`any` xs) $ \x0 -> (`any` xs) $ \x1 -> x0 /= x1 && all (n <) [x0,x1]
15:06:17 <ski> fffej : maybe replacing the last `all (n <) [x0,x1]' part with  (`all` [x0,x1]) $ \x -> x > n
15:07:14 <ManateeLazyCat> Get code from http://code.haskell.org/gtk2hs and do "./bootstrap.sh", that's all.
15:07:22 * ddarius points ski at the flip function
15:07:41 <ManateeLazyCat> bootstrap.sh will install all gtk2hs packages automatically,	include build documentation for APIs.
15:07:54 <pedagand> (for the record: hasktags output is badly broken on Bird-style literate code. It can be hacked with sed, but that's rather fragile. Following aavogt, I recommend ghci :etags (but that's a pain in my case))
15:08:01 <ski> (ddarius : yes, i'm aware of `flip', i just find sections nicer to read in cases like this)
15:09:35 <Olathe> @hoogle (a -> IO b) -> [a] -> IO [(a, b)]
15:09:35 <lambdabot> No results found
15:09:52 <ski> pgs31 : i think the point is not as much whether you want to do something to the whole list; but whether your operation is incremental or not
15:10:30 <ski> > scanl (+) 0 [1,10,30,2,400]
15:10:31 <lambdabot>   [0,1,11,41,43,443]
15:10:42 <ski> that's an incremental operation on a list
15:10:49 <pgs31> ski: By and large they will be; but often they need to look at every (or a lot of) the elements in the list
15:10:53 <pgs31> ski: yes, just like that
15:11:12 <ski> you only need to look at the "previous" input elements to compute each output element
15:11:40 <pgs31> pgs31: Yes, or sometimes the last n or something.. never forwards though.
15:11:48 <ski> and, you don't even need to keep all the previous input elements around to be able to compute the next output element .. just the current prefix sum is needed
15:12:15 <pgs31> ski: You are entirely correct - that is the sort of thing I'll be doing.
15:12:31 <pgs31> ski: however, when I am doing them, I will usually be doing them on every element in the list..
15:12:51 <ski> if your list operation is something like subtracting the sum of *all* elements, from each elements .. then that's *not* an incremental operation (it's a "bulk operation")
15:13:15 <pgs31> ski: And the operations themselves will be usually quite simple, as in the above example
15:13:31 <pgs31> ski: Are lists in haskell implemented as linked lists?
15:13:45 <Zao> pgs31: Singly linked, basically.
15:13:46 <tommd> No, they're implemented as donkeys.
15:13:46 <ski> lists (in haskell)are (lazy) linked lists, yes
15:14:01 <Zao> A list is a head with a value and a tail, or an empty list.
15:14:10 <Zao> @src []
15:14:10 <lambdabot> data [] a = [] | a : [a]
15:14:28 <alfs_boner> nice
15:14:34 <pgs31> zao: So I wonder how much cost there is in the indirection needed to get the next element, if there an awful lot of elements.
15:14:36 <alfs_boner> @src ()
15:14:36 <lambdabot> data () = ()
15:14:47 <Zao> pgs31: Depends on what you mean by "cost".
15:14:54 <Zao> pgs31: Indexing in a list is expensive.
15:14:59 <Zao> pgs31: Iterating over it is cheap.
15:15:14 <ski> pgs31 : the idea of lazy I/O is basically that you can read a large file into a lazy list, transform that list into another list (by an *incremental* operation), and output that list into some other file
15:15:18 <pgs31> zao: Well, time for iteration in this case.
15:15:58 <Zao> pgs31: Quite cheap, I'd say.
15:16:12 <Zao> pgs31: Especially with fusion rules and whatnot.
15:16:17 <pgs31> zao: Thanks, I will ruminate on that and do a few little test cases
15:16:22 <ski> pgs31 : the idea being that in actual operation, this will only read a small part of the file into memory, and, hopefully, the earlier parts of the list can be garbage-collected long before you're getting close to the end of the input list
15:17:03 <pgs31> ski: yes, you are right. I think what I really want is to strictly and efficiently load this big file into memory.
15:17:09 <pgs31> ski: and then work with it lazily
15:17:59 <ski> pgs31 : however, there are dangers in this approach, in that, sometimes, your code keeps references to earlier elements of the list around, when it shouldn't. and this then causes "memory leaks" (i.e. memory that ought to have been garbage collected isn't, because the GC thinks you still might need it)
15:18:26 <pgs31> ski: I've been having lots of fun with the profiler already :)
15:18:30 <ski> (and of course, you need to make sure to only use incremental operations)
15:18:42 <ski> but when this approach works, i think it is quite elegant
15:18:50 <gwern> @quote immortality
15:18:50 <lambdabot> newsham says: so the key to immortality is ambiguous naming?
15:18:53 <gwern> @quote immortality
15:18:53 <lambdabot> newsham says: so the key to immortality is ambiguous naming?
15:19:01 <gwern> @quote Dijkstra
15:19:01 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
15:19:01 <lambdabot> regeneration."
15:19:15 <gwern> @remember Dijkstra I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have liked this", well, that would be enough immortality for me.
15:19:16 <lambdabot> It is stored.
15:19:19 <gwern> @flush
15:19:30 <tommd> @quote hack
15:19:30 <lambdabot> everbody says: is hackage down?
15:19:31 <pgs31> ski: I agree entirely. I am trying to replicate something which already exists in C++ to show some colleagues that Haskell can do Real Things (tm)
15:20:05 <pgs31> ski: And in C/C++ we do things that already push what the machine can cope with
15:20:45 <pgs31> ski: I am hoping that STM and Parallel Haskell can trump any overhead that I get from using Haskell ;)
15:20:47 <tommd> pgs31: So your colleagues only accept "real things" that duplicate what they have already done?  Not all the other real things people have already done with Haskell?
15:21:07 <pgs31> tommd: I didn't mean to cause any offence, please forgive me.
15:21:30 <tommd> pgs31: No, I'm not meaning to sound annoyed or flame - it just sounds like a shaky comparison.  I do wish you luck in it.
15:21:31 <pgs31> tommd: Are there existing haskell projects that work with very large data sets around that I can take a look at?
15:21:32 <gwern> pgs31: say 10 Hail Wadlers and 1 Our Simon, and you are forgiven, my son
15:21:46 <ski> pgs31 : "strictly and efficiently load this big file into memory" isn't what you want to do, with lazy I/O. you want to read the file lazily, and work with it lazily
15:22:01 <fnord123> what is a very large data set for you
15:22:06 <ddarius> Presumably your team is a bunch of competent C++ programmers, and presumably you are a beginner Haskell programmer.  I don't think you are setting things up well here.
15:22:07 <fnord123> gb, tb, or pb
15:22:20 <ski> pgs31 : but. maybe what you want is actually to load your file strictly .. it depends on what operations you want to do (which i don't know)
15:22:29 <pgs31> fnord123: Nothing silly, it fits into memory. Say a couple of GB
15:22:39 <fnord123> so medium sized
15:22:51 <pgs31> fnord123: but you can't go copying it around too much without causing problems
15:22:54 <pgs31> yea
15:22:57 <tommd> But only if it's flat.  So perhaps you want to use an unboxed array?  Is that what the C algorithm deals with?
15:23:18 <fnord123> one day's worth of data for me these days is ~60gb. but im working in c++
15:23:20 <pgs31> tommd: Yes, it is all just stored as flat arrays of timestamp, value pairs of doubles
15:23:38 <pgs31> fnord123: Is that financial tick data too?
15:23:44 <cvxp> Hi. What is the "right" way to get a working Haskell environment set up on Arch Linux? I installed GHC, which works, but trying to download and use packages is a nightmare. At the moment, trying to run "cabal update" tell me that cabal-install is outdated, but it chokes when I run "cabal install cabal-install", it warns me that "cabal-instal-0.8.2 depends on multiple version of the same package" and dies. I've installed everything f
15:23:44 <fnord123> how did you guess
15:23:49 * pgs31 grins
15:24:02 <pgs31> That's some full depth of order book right
15:24:03 <ddarius> cvxp: Use the Haskell Platform.
15:24:14 <fnord123> i used to work on a system handling petabyte/day.. oh fortran. :D
15:24:25 * pgs31 grins
15:24:26 <cvxp> ddarius: Ah.
15:24:39 <ski> (cvxp : also, cut off at "... I've installed everything f")
15:24:42 <ddarius> There should be a "Haskell Platform" package on Arch Linux.
15:25:06 <pgs31> fnord123: Have you convinced them to switch to Haskell yet?
15:25:09 <tommd> Yeah, dons maintains the arch packages fairly well as I understand.
15:25:17 <fnord123> pgs31: i would love to see an orderbook impl in haskell. I wonder if Okesaki has tried it
15:25:28 <cvxp> Yeah, it's marked as outdated on arch's page, so I'll just use the tarball from the site.
15:25:35 <fnord123> pgs31: no i wouldn't try to but theyre all mathematicians where i work so they play with haskell in their spare time
15:25:47 <fnord123> but they wouldn't bet the company on it just yet
15:25:57 <pgs31> fnord123: Exactly my predicament
15:26:01 <alfs_boner> anyone do any usefull shell programming in haskell?
15:26:38 <ddarius> There are quite a few financial/trading institutions that use Haskell, but I don't think too many of them use it to directly read and process the time series.
15:26:52 <ddarius> I could be wrong about the latter part though.
15:27:15 <fnord123> ddarius: aye. the papers I read are about how they use haskell to handle option pricing and supporting crazy excel extensions
15:27:26 <fnord123> at least that's what I gleaned from lennart's presentations
15:27:30 <pgs31> fnord123: We had Simon PJ come in and give us a talk
15:27:40 <pgs31> fnord123: His son did an internship :)
15:27:51 <mreh> i wish my dad was spj
15:28:08 <mamalujo_> rofl
15:28:12 <mreh> hmph
15:28:41 <monochrom> haha
15:28:54 <pgs31> ddarius: I think you're right - but I thought I'd give it a try. If nothing else, it is a lot of fun learning a language like Haskell
15:28:57 <gwern> alfs_boner: my haskell scripts are useful to me, anyway
15:29:43 <gwern> fnord123: what's an orderbook datastructure?
15:30:37 <alfs_boner> gwern: do you use Hashell
15:30:39 <alfs_boner> ?
15:30:48 <gwern> alfs_boner: I think I uploaded it, but no
15:31:00 <gwern> not developed enough to compete with bash
15:31:04 <mreh> when you get to advanced haskell, it's pretty "fun"
15:31:09 <mreh> man it makes my head hurt
15:31:27 <gwern> @quote hurt
15:31:28 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
15:31:28 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
15:32:37 * twink did
15:32:41 <gwern> haskell makes a good base syntax for shell tasks, but it's not there. so you need some sort of interpretive layer there
15:33:34 <fnord123> gwern: an orderbook is something representing the live orders for a security on an exchange. The operations are add, delete, and modify in random places. Depending on the exchange, inserts are done by price. But deletions are done by order ID. In c++ it would usually be something like a multi-map and an order index map. But if you want it to be extremely performant you might hack about it in other ways (avoiding allocation/deallocatio
15:34:11 <gwern> fnord123: so it's not actually a datastructure, just a pattern of use
15:34:28 <tommd> With extreme performance requirements.
15:35:10 <fnord123> gwern, yes.
15:35:23 <ski> (fnord123 : cut off at ".. (avoiding allocation/deallocatio")
15:35:38 <fnord123> And allocation/deallocation on the map)
15:35:57 <tommd> Whats with all these bad IRC clients that don't automatically break the message into two parts?
15:36:19 <fax> the problem is the IRC server actually
15:36:30 <fax> well protocol
15:36:32 <ski> tommd : it's impossible to do generally. the IRC protocol is broken
15:36:41 <tommd> Ah, I thought it was client dependent.  I've seen my own message separated into parts.
15:36:53 <ski> some clients try to guess
15:36:57 <tommd> And the client _could_ resend parts it sees as incomplete in the return stream.
15:37:08 <Polarina> What's the difference between foldl1 and foldr1?
15:37:16 <gwern> my irssi script works fine for that; it's a client issue I think
15:37:16 <mamalujo_> yeah, I have a plugin that breaks too long quips..
15:37:25 <cvxp> This is fun. I'm trying to set up the haskell platform, and it tells me GHC isn't functioning. So I try a "Hello world" program, and it tells me "unknown package haskell98". "cabal install haskell98" didn't work, so I ran "ghc-pkg check", and I got a flood of output about missing files, followed by this: http://pastebin.com/QnMKELBp
15:37:27 <gwern> Polarina: the difference between foldr and foldl I'd guess
15:37:36 * ski is not sure whether clients get sent back their own channel messages ..
15:38:03 <Polarina> gwern, and those are?
15:38:14 <gwern> @src foldr
15:38:15 <lambdabot> foldr f z []     = z
15:38:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:38:15 <gwern> @src foldl
15:38:16 <lambdabot> foldl f z []     = z
15:38:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:38:19 <gwern> ^
15:38:31 <tommd> > foldl (+) 0 [1..3]
15:38:31 <lambdabot>   6
15:38:47 <tommd> grr, what was the "fold" version someone made to show the nesting?
15:39:10 <cvxp> In the words of Bob Dylan: "Everything is broken!"
15:39:10 <ski> > foldl f z [0,1,2,3]
15:39:11 <lambdabot>   f (f (f (f z 0) 1) 2) 3
15:39:21 <ski> > foldr f z [0,1,2,3]
15:39:22 <lambdabot>   f 0 (f 1 (f 2 (f 3 z)))
15:39:27 <tommd> ahh, thanks ski
15:39:43 <ski> > foldl (flip f) z [0,1,2,3]
15:39:44 <lambdabot>   f 3 (f 2 (f 1 (f 0 z)))
15:39:45 <Polarina> Ah. :)
15:40:22 <tommd> cvxp: BTW, it sound like you or something might have deleted your .ghc at one point.
15:40:48 <mamalujo_> cvxp: are you compiling the platform or installing a distro binary?
15:41:18 <cvxp> mamalujo_: Compiling, but at this point GHC isn't even working.
15:41:22 <ski> > foldr (\x s -> concat ["(",show x," + ",s,")"]) "0" [1,2,3]
15:41:23 <lambdabot>   "(1 + (2 + (3 + 0)))"
15:41:23 <ski> > foldl (\s x -> concat ["(",s," + ",show x,")"]) "0" [1,2,3]
15:41:24 <lambdabot>   "(((0 + 1) + 2) + 3)"
15:41:38 <cvxp> tommd: I don't remember doing that. Might have been accidental.
15:41:44 <cvxp> It's there now.
15:42:35 <Polarina> With an f of which foldl1 and foldr1 doesn't matter (same output) -- which one is preferable?
15:42:43 <mauke> > foldr (+) 0 [1,2,3] :: Expr
15:42:44 <lambdabot>   1 + (2 + (3 + 0))
15:43:28 <mauke> foldl1'
15:43:50 <Polarina> Thanks.
15:43:50 <mamalujo_> cvxp: well, I'd probably start from the beggining seeing such mess, but I just don't know how to get out of it usually, though I gather its more fun, povided one likes messing with one's system that is..
15:44:45 <cvxp> mamalujo_: I wish I knew what I did to break it. ):
15:52:48 <mamalujo_> cvxp: well, at least its practical that the compiler doesn't have particularly demanding dependencies: package of a decently current (6.12.1) , taken from debian testing, could be fully satisfied from stabe, even though this stable was supposed to be on its way to old-stable by now.
15:53:52 <ivanm> preflex: seen quicksilver
15:53:52 <preflex>  quicksilver was last seen on #haskell 1 day, 6 hours, 17 minutes and 40 seconds ago, saying: but these days I don't find fancy shell features compelling enough to bother to install zsh on a new machine.
15:56:43 --- mode: ChanServ set +o mauke
15:56:43 --- mode: mauke set -b *!~55c89673@gateway/web/freenode/x-lwucohxnlkqcgxrk
15:58:43 --- mode: mauke set -o mauke
15:59:21 <lpsmith> so why does parsec, iteratee, and many other hackage packages have this style of definition:   instance Monad Parsec where {return = returnP; (>>=) = bindP } ... bindP = ... {-# INLINE bindP #-}
15:59:48 <lpsmith> I mean,  bind often gets inlined without such an idiom
16:01:28 <monochrom> I do that in prime-numbered years.
16:03:05 <jbapple> lpsmith: I have done that before to get profiling to work correctly
16:03:26 <monochrom> You may like to do it when the code for >>= is long.
16:03:29 <lpsmith> jbapple, ahh, that makes sense
16:03:45 <Philippa> lpsmith: because often isn't good enough
16:03:56 <jbapple> GHC's profiler just mangles up class function names in such a way that it impossible to tell which instance is which
16:04:34 <ivanm> @tell quicksilver thank you very much for your suggestion to try mumamo-mode... after spending the last couple of days on it, I'm giving it up as for some reason it fails (I think because it has trouble distinguishing between opening and closing sections); it doesn't help when the developers idea of version control is "comment out the old version" :s
16:04:34 <lpsmith> Philippa, do you know of cases where bind doesn't get inlined without that idiom,  and does get inlined with?
16:04:34 <lambdabot> Consider it noted.
16:05:25 <Philippa> not specifically, but that's not the point
16:05:44 <lpsmith> then what is your point?  :)
16:06:06 <Philippa> trusting all possible inliners to inline it isn't necessarily the right move
16:06:36 <Philippa> you don't know what the inliner'll do tomorrow, or on any (version of any) compiler you haven't tested it with
16:06:47 <gwern> ivanm: that's very passsive-aggressive a thanks :)
16:07:06 <ivanm> :D
16:07:23 <ivanm> I was going more for a sarcastic "thanks" though...
16:07:53 <lpsmith> Well,  marking a function as {-# INLINE ... #-} makes it less likely that things inside that function will get inlined,  IIRC
16:08:31 <gwern> ivanm: 'thank you very much' is more likely to be sincere than 'thanks a lot' or 'thanks a bunch'
16:09:20 <ivanm> gwern: eh, depends on the tone of voice ("thanks a bunch" isn't common here, but "thank you very much" is used for sarcastic replies)
16:09:23 <lpsmith> "thanks a lot" or "thanks a bunch" can be sincere,  but yes.   The general connotation is there
16:09:37 <Philippa> lpsmith: less so if those things are also thus marked, I suspect. And IIRC something like Parsec really, really wants the top level of >>= inlined so it can do case/ctor
16:12:59 <Philippa> (and >>= is comparatively big in parsec, it's not unreasonable to be suspicious about whether the inliner will always inline it anyway)
16:13:39 <ivanm> Philippa: >>= is big in a lot of monads...
16:13:52 <ivanm> or do you mean big size-wise as opposed to usage-wise?
16:14:26 <Philippa> the former. I'm not sure why you'd take it to mean the latter
16:15:02 <ivanm> "foo is big in certain circles"
16:16:25 <mauke> >>= is big in japan
16:16:32 <mauke> that's why it can't be inlined
16:16:36 <jlouis> what decides an inlining? only size of the definition or also the number of uses?
16:18:05 <Philippa> jlouis: the whim of the specific inliner being used :-) Which was part of my point
16:18:31 <cvxp> I *think* it's working now.
16:18:34 <cvxp> \0/
16:18:57 <Philippa> ivanm: I don't know of anyone referring to use frequency as popularity, so that still doesn't work - though "hot" does
16:19:03 <Philippa> anyway, I'm heading off
16:19:14 <ivanm> Philippa: it's a cultural thing
16:33:19 <danharaj> I have a datatype that I have an IORef to. It has named fields. What is the nicest way of using modifyIORef to modify one of the fields?
16:33:54 <ddarius> danharaj: Use record update notation.
16:34:22 <danharaj> What is that?
16:36:19 <ddarius> http://haskell.org/onlinereport/exps.html  See section 3.15.3
16:37:17 <danharaj> thanks :)
16:37:33 <jmcarthur> or use something like data-accessor or fdlabels
16:37:39 <jmcarthur> *fclabels, i think
16:37:56 <jmcarthur> there's also lenses, if i recall the name correctly
16:38:11 <jmcarthur> data-accessor is the simplest. the other two are supposedly more powerful
16:39:34 <jmillikin> Anybody here know enough about the FFI to diagnose this error / bug? I'm completely baffled < http://stackoverflow.com/questions/2751928/why-do-compiled-haskell-libraries-see-invalid-static-ffi-storage>
16:42:18 <mauke> what is sys_siglist?
16:42:37 <jmillikin> static const char **sys_siglist;    in <signal.h>
16:42:47 <mauke> static? wtf
16:42:51 <jmillikin> sorry, not static
16:43:09 <jmillikin> extern __const char *__const sys_siglist[_NSIG];
16:43:15 <mauke> ah, #ifdef __USE_BSD
16:43:26 <applicative> does lambabot know  type that uses record syntax?  I mean, so one could illustrate with lambdabot?
16:43:42 <jmillikin> The variable used doesn't matter; this happens for any static data. I just picked one which is present on most systems.
16:43:45 * mauke ponders
16:44:00 <EvanR> it knows State
16:44:27 <EvanR> @src State
16:44:28 <lambdabot> Source not found. You untyped fool!
16:44:57 <Cale> http://simple.wikipedia.org/wiki/Zero -- "Zero is a special number. If there are zero things, there are not any things. There are none."
16:45:19 <EvanR> > length []
16:45:21 <lambdabot>   0
16:46:00 <danharaj> I'm going to hazard a guess that Data.Acessor is not bundled with common platform?
16:46:58 <applicative> Cale, the wikipedian should read Frege, of course.  "Number belongs to a concept" -- so the way to say it is: if there are zero Fs, then there aren't any Fs
16:47:09 <mauke> jmillikin: your import type looks wrong
16:47:38 <jmillikin> What should it be?
16:47:58 <jmillikin> I've tried adding the head file name and "static"
16:47:59 <mauke> I don't think this variable is importable
16:48:17 <jmillikin> ... but it works. I can import and use it, in GHCI
16:48:47 <mauke> we're too close to C land and UB for me to be comfortable
16:49:22 <jmillikin> If I define a custom C procedure to wrap it, I can import *that* and it still returns the same (invalid) pointer value.
16:55:02 <Mathnerd314> > ($) `asTypeOf` (.)
16:55:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
16:55:55 <Mathnerd314> can I use a newtype to get around that?
16:57:01 <pikhq> :t asTypeOf
16:57:02 <lambdabot> forall a. a -> a -> a
16:57:03 <jmcarthur> i'm not sure i see how those types are similar enough for that to make any sense
16:57:07 <mauke> Mathnerd314: around what?
16:57:14 <Mathnerd314> :t (.)
16:57:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:57:17 <Mathnerd314> :t ($)
16:57:19 <lambdabot> forall a b. (a -> b) -> a -> b
16:57:30 <Mathnerd314> similarity should be evident...
16:57:31 <jmcarthur> oh you mean the fmap version of (.)
16:57:42 <jmcarthur> i thought you meant the Prelude one
16:58:03 <jmcarthur> you could overload ($) with a type class. i've done that before
16:58:05 <mauke> > Identity ()
16:58:05 <lambdabot>   No instance for (GHC.Show.Show
16:58:06 <lambdabot>                     (Control.Monad.Identity....
16:58:17 <tommd> jmillikin: This is x86-64, right?  I don't see this behavior on x86.
16:58:19 <jmcarthur> or you could just say ($) = fmap
16:58:30 <jmcarthur> but that is probably not what you want
16:58:32 <pikhq> Or you could use id.
16:58:40 <tommd> (I'm really just confirming you don't have some rare architecture, seeing as I can tell its 64 bit).
16:58:46 <pikhq> (the more-generic ($). :))
16:58:51 <mauke> > runIdentity $ (*2) . Identity 21
16:58:52 <lambdabot>   42
16:58:56 <jmillikin> tommd: yes, I'm on 64-bit. I hadn't thought that could be the problem.
16:59:00 <jmcarthur> wait, what does id have to do with ($)?
16:59:02 <mauke> > (*2) $ 21
16:59:03 <lambdabot>   42
16:59:10 <pikhq> :t ($)
16:59:11 <pikhq> :t id
16:59:12 <lambdabot> forall a b. (a -> b) -> a -> b
16:59:13 <lambdabot> forall a. a -> a
16:59:14 <mauke> jmillikin: ($) = id
16:59:15 <jmcarthur> oh
16:59:16 <jmcarthur> that
16:59:18 <tommd> jmillikin: I'm guessing your found an architecture specific bug in GHC.  I'd report it.
16:59:19 <mauke> er
16:59:20 <jmcarthur> nevermind i'm dumb
16:59:23 <mauke> wrong nick, sorry
16:59:25 <pikhq> Heheh.
17:00:20 <jmillikin> tommd: thanks, I'll do that
17:14:46 <gwern> > 4*30 + 360
17:14:48 <lambdabot>   480
17:16:48 <fax> interesting theory gwern
17:17:05 <danharaj> Oh wow I feel good.
17:17:32 * gwern is getting tired of the sarcastic remarks
17:17:33 <danharaj> I just spent a few hours writing a parser, and at the end, only one logical error that was easy to correct.
17:18:19 <dibblego> is that an invitation to others to find the rest of the bugs?
17:19:47 <danharaj> haskell just works
17:19:57 <danharaj> or rather, if it type checks, it works.
17:20:00 <tommd> So does Coq.
17:20:19 <danharaj> yes but if haskell requires you to wade balls-deep in theory to understand, then coq requires a diving suit :p
17:20:20 <tommd> "If the theorem is proven, it works"
17:20:44 <dolio> Unless Coq is inconsistent.
17:21:12 <tommd> So you are saying that "Axiom explode, True = False." is a bad thing?
17:21:57 <dolio> It may be unnecessary. Who knows?
17:23:28 <fax> 00:19 < danharaj> haskell just works
17:23:28 <fax> 00:19 < danharaj> or rather, if it type checks, it works.
17:23:30 <fax> I don't agree with this
17:23:43 <fax> this is definitely not true in my experience
17:23:49 <nus> well, it does, sometimes :-P (-;
17:23:57 <fax> what's VERY interesting is that many many people say this
17:24:05 <mamalujo_> anyone here used yi editor?
17:24:18 <fax> so what's going on? am I just rubbish or is everyone over-optimistic, or what?
17:25:13 <danharaj> It's because we're doing easy stuff.
17:25:27 <jon_of_arc> You may just have higher standards; it's possible for Haskell to be strikingly closer to "if it typechecks, it works" than [a given body of languages] without actually being particularly close
17:25:31 <jon_of_arc> Or that
17:25:38 <Draconx|Laptop> fax, I think it's often true when people are doing exercises to learn the language.
17:26:54 <danharaj> I haven't come across the need for any extensions to the type system, so I think I am doing fairly basic stuff, even though that basic stuff pretty much encompasses most hobby programming.
17:27:33 <danharaj> Charity, on the other hand is a language that by definition works if it type checks :p
17:28:11 <gwern> mamalujo_: I use it
17:28:12 <applicative> why is it that Charity works if it typechecks?  Is it total? I cant remember
17:28:33 <dolio> Charity is total.
17:28:33 <danharaj> Yeah.
17:28:39 <danharaj> ...totally AWESOME
17:28:41 * danharaj rimshot
17:29:12 <mamalujo_> gwern: so, how mature is that currently? is it really emacs done right already?
17:29:16 <applicative> It there a working interpreter?
17:29:26 <gwern> mamalujo_: it's better than emacs for haskell editing. nothing else
17:29:39 <applicative> danharaj, I mean for charity
17:30:26 <danharaj> applicative: I dunno, I'm on windows and there's no implementation there. It's an experimental language and I don't think it has much real support.
17:30:40 <danharaj> gwern: What is better for haskell, cause I'm on notepad right now :|
17:30:44 <dolio> There's an interpreter on the website, I think.
17:30:56 <dolio> But I'm not sure if it's source. It might just be a binary.
17:31:17 <gwern> I think i'd rather wait for High Charity
17:31:34 <fax> I use a lot of extensions for haskell
17:32:11 <mamalujo_> gwern: well, that's still quite a reccomendation, I'll try it out
17:32:21 <dolio> I have a tarball labelled charity-bin-Linux-i686.
17:32:28 <dolio> And I seem to recall that's all there is.
17:33:25 <applicative> dolio, yes, i see the linux tarball.  os x cannot execute binary unix file etc
17:35:00 <applicative> This is what I remember on hackage, I think a precursor of charity http://hackage.haskell.org/package/CPL
17:35:29 <danharaj> CPL is the language Tatsuya Hagino introduced in his thesis.
17:35:34 <danharaj> I have his paper and I'm slowly going through it.
17:35:50 <fax> CPL is soo cool omg
17:36:03 <fax> danharaj I heard about it in Computational Category Theory
17:36:46 <danharaj> in where? I am interested.
17:36:54 <danharaj> I haven't been able to get a good survey resource on the subject.
17:37:30 <fax> what subject
17:37:31 <fax> this book is an intro to category theory
17:37:31 <fax> www.cs.man.ac.uk/~david/categories/book/book.pdf
17:37:31 <fax> but they mention Hagino because he's so cool
17:38:13 <danharaj> Ah, but is it CS oriented?
17:38:20 <danharaj> Because that'd be something useful as well.
17:38:25 <danharaj> thanks!
17:43:48 <danharaj> Time to test Haskell code's ability to be extended. I have to expand my little command line to handle bigger datatypes as well as commands.
17:44:08 <applicative> Computational Category Theory says Hagino represents types as Objects, parametrized types as Functors, functions are Morphism, functions from () to a type are values... but they oppose this taking values as the Objects.  I wonder how they do that...
17:45:00 <danharaj> Anyone know if Hagino's CPL has been extended with dependent types?
17:47:22 <applicative> Hagino says,
17:47:30 <applicative> this must be investigated
17:49:14 <jmillikin> tommd: In your answer to my SO question, I notice you're compiling *every* file. Could you try compiling only A.hs, as per the instructions, to see if it still works?
17:49:36 <jmillikin> tommd: rm -f *.o *.hi; ghc -c A.hs; runhaskell Main.hs
17:50:56 <applicative> fax et al.  does anyone know if D. Turner every gave a proper specification of the 'total functional programming' language he envisaged in the paper with that name
17:51:52 <fax> not to my knowledge, at any rate I was underwhelmed by his papers
17:52:08 <danharaj> CPL fits the bill.
17:52:14 <applicative> when i read the paper i thought, now I have a cool Haskell project, I will implement an interpreter for it.  I liked the paper on that, and the one on Church
17:52:54 <gwern> applicative: when I read it, I thought, 'this would be better done in scheme than haskell'
17:53:35 <applicative> gwern, that might be right, except my scheme comprehension is not as strong...
17:53:52 <gwern> I mean, why bother making the language strict and total in a lazy language?
17:55:37 <applicative> gwern, yes but e.g. haskell's lazy lists are his codata lists.
17:56:32 <dolio> applicative: It seems a lot like Agda, minus the dependent types.
17:57:02 <fax> but dolio you can define lambda in CPL
17:57:54 <dolio> I mean Turner's language is like Agda minus the dependent types.
17:57:59 <fax> oh
17:58:20 <fax> yeah I agree if you have seen things like Agda, turners stuff is a step back
17:58:38 <applicative> dolio, yes, but Agda seems like overkill.  The idea was to have a simple programming language in which one just does stuff.  The idea was that totality, the right data v. codata opposition, etc. might bring unknown benefits, first among them reasoning about one's code.
17:59:05 <applicative> fax, but could something like Agda really aspire to be a useful programming language?
17:59:12 <gwern> in practice, bottom doesn't seem to stop us all that much
17:59:39 <dolio> I think trying to do total programming without dependent types is likely to result in your language being too limited.
17:59:41 <danharaj> Doesn't the presence of bottom prevent some kinds of program transformations?
17:59:56 <fax> danharaj - hm? that's not something I've heard of befoer
18:00:06 <ddarius> applicative: That's what it is aspiring to do.  There are also other dependently typed programming languages.
18:00:09 <applicative> dolio, i see that, one question was, when do we hit a brick wall.
18:00:11 <dolio> It's not hard to come up with programs that are difficult to write unless you can prove things about your code.
18:00:16 <ddarius> danharaj: Sure it does.
18:00:49 <fax> applicative - if you want to give total correctness proofs for everything it's going to take a bit longer.. if you /don't/ then, you probably won't use agda
18:00:57 <dolio> Like "compute a list of fibonacci numbers less than some given number."
18:01:02 <ddarius> dolio: You would just have to reify the proofs as values so that you would be doing structural induction on those.
18:01:06 <fax> applicative: that's why there are not lots of 'real programs' written in agda
18:01:08 <m3ga> i've got code that works with ghc 6.12 but fails with ghc 6.10.4. the problem seems to be Seq.filter. is that new in 6.12?
18:01:31 <Adamant> dolio: we all need a verified Fibonacci generator.
18:01:37 <gwern> Prelude Control.Monad Data.Char Data.List Data.Sequence> :t Data.Sequence.filter
18:01:41 <gwern> <interactive>:1:0: Not in scope: `Data.Sequence.filter'
18:01:43 <fax> dolio: well that is easy to do but nobody seems to like my ways to do it :P
18:01:49 <gwern> m3ga: looks like it
18:01:58 <danharaj> fax: yeah
18:02:13 <fax> what transformations use _|_?
18:02:13 <applicative> my impression was that Turner was envisaging an extensible system, if you need some off the wall recursion you write {-#LANGUAGE OffTheWallRecursion #-}
18:02:17 <m3ga> thanks gwern
18:02:30 <dolio> fax: Well, there are easy ways to do it, and satisfying ways to do it, and the satisfying ways need proofs. :)
18:02:43 <danharaj> None that use bottom, but transformations that can't work because they strictify non-terminating code, making a bottom percolate through the code.
18:03:09 <ddarius> danharaj: Many fusion systems for Haskell are unsound in the face of bottom.
18:03:22 <fax> uh
18:03:25 <dolio> ddarius: I'm not sure how to encode the right proofs in a language like Turner's, without dependent types.
18:03:34 <fax> I thought you meant that because there was NOT bottom, you couldn't do certain transforms
18:03:43 <danharaj> oh, no. I must have mistyped.
18:04:00 <ddarius> danharaj: No, fax misread.
18:04:00 <fax> I misread
18:04:16 <danharaj> that's like the categorical dual of me mistyping :p
18:04:46 <fax> hehe
18:04:58 <danharaj> I don't quite entirely understand dependent types. Could you describe subtypes with dependent types by having the type depend on a predicate on the parent type, for example?
18:05:06 <applicative> I'm not seeing that the desire for dependent types, or for a proof system, isn't just independent of the desire for totality, or for a series of nested total languages
18:05:42 <fax> danharaj: if |N is integers say, you can make a new data type  Sigma n : |N, P(n)  whose elements are pairs:  A number and a proof that it satisfies P
18:06:02 <fax> that's an example of a dependent type
18:06:06 <danharaj> ah
18:06:39 <fax> data Sigma (A :: *) (P :: A -> *) where Witness :: (a :: A) -> P a -> Sigma A P
18:06:48 <fax> in dependent-GADT syntax
18:06:57 <applicative> fax, but isn't the textbook example of dependent types Vec n so to speak
18:07:25 <ddarius> applicative: That's a pretty boring example.
18:07:28 <fax> the thing is, I don't really know any uses for Vec n
18:07:55 <dolio> It's a common example, but it only really needs type-level naturals of some sort. It's not a very compelling example of dependent types.
18:08:04 <fax> indexing it with Fin is pretty neat -- and you can make a monad out of it -- but more involved use of Vec is rare
18:08:21 <applicative> I wasn't praising it much, just thinking its better than pairs of n and a proof that n is P
18:08:27 <fax> it would be realy nice to see a lot more examples of dependent programming, but this means figuring it all out from scratch - because hardly anyone knows how to do it
18:09:28 <fax> Sigma is more interesting, you can use it to define lists in terms of vectors or vectors in terms of lists.
18:09:50 <danharaj> I thought of a way to prove that a sort that works by choosing pivots is total 'structurally' but it's sketchy and involves having types depend on predicates.
18:10:04 <danharaj> 'thought of' I'm sure it's been done, but I did it while musing.
18:10:27 <fax> danharaj - that sounds really cool
18:10:30 <ddarius> Dependent types are similar to predicates in logic.  Mathematicians already know how to work with such things.
18:11:53 <danharaj> The observation I made was that, ok, use nil, singleton, and ++ as your means of constructing lists. Now, observe that, given a predicate and two sorted lists x, y, if all the elements in x are less than the pivot, and all the elements of y are greater than it, then x ++ y is also a sorted list. A singleton is always sorted.
18:12:08 <danharaj> er, predicate should be pivot
18:12:22 <fax> ah that's naet
18:12:23 <applicative> ddarius, this is what makes me suspicious, it seems like an artificial attempt to extend the analogy of type signatures (p -> q) -> (r-> p) -> (r -> q) to predicate logic
18:12:23 <fax> neat
18:12:58 <danharaj> Then you fudge some details around. When I am not totally swamped with schoolwork and a thousand trains of thought, I'll sit down and try to figure out the general idea.
18:13:27 <fax> danharaj: it makes sense to me :)
18:13:28 <ddarius> applicative: There's nothing artificial about it (or at least no more artificial than any other such thing).  Martin-Loef type theory corresponds to higher order logic and thus to a variant of intuitionistic set theory.
18:14:00 <fax> I think it makes sens, if you think of lambda calculus as 'just another way to write proofs'
18:14:40 <ddarius> The lambda calculus is actually my preferred way to write (formal) proofs as it is usually more compact and less ambiguous.
18:14:43 <applicative> ddarius, I grasp that, but the question whether this justifies making a new programming language.   Should I extend the system so that my types correspond to quantified modal logic with tense operators too?
18:15:14 <ddarius> applicative: You can and people have.  It's just another language.
18:15:16 <danharaj> The question is, can you find a framework which can express these extensions?
18:15:26 <danharaj> CPL doesn't have any primitive datatypes. Because category theory tells you how to make them.
18:15:43 <danharaj> For example.
18:16:00 <ddarius> applicative: I don't see what others going out and creating languages takes from you.  If you don't want to use it, don't use it.
18:16:21 <ddarius> I also don't see how basing a language design off of a correspondence with logic is -worse- than making an ad-hoc one.
18:17:11 <danharaj> If you want a language to be useful, you need a solid community with support for a main language. Experimental languages are often defficient as practical languages. For example, haskell is great and relevant only because everyone here supports it instead of using a dozen splinter languages.
18:17:26 <gwern> haskell was founded to absorb a dozen splinter languages :0
18:17:32 <applicative> ddarius, I'm not complaining, far from it, I was just wondering what advantage comes from it.  The association with proofs that aren't like those for the propositional calculus, but like regulare mathematical ones is interesting of course.
18:18:08 <dolio> http://code.haskell.org/~dolio/agda-share/sorting/html/Sorting.html
18:18:24 <dolio> There's an insertion sort I wrote. It proves that the output is sorted and a permutation of the input.
18:18:39 <ddarius> applicative: The advantage comes from having a clean foundation, being able to import many theorems and expertise, being able to contribute back to the logic.
18:21:44 <applicative> ddarius, this is admirable, of course.  I was just wondering if, for example, lots of ordinary programs as you might write them in Haskell, might somehow become much simpler in the richer environment --as in Haskell programs are often so much simpler and more transparent than in other languages
18:22:03 <ddarius> applicative: It depends.
18:22:39 <ddarius> applicative: Usually in a dependently typed setting you have higher standards.  You can do things in Agda which simply aren't possible in Haskell.
18:23:12 <ddarius> However, doing things that you can do in Haskell in Agda won't be particularly shorter, at least until you try to have strong guarantees.
18:24:12 <dolio> Oh, also, the other day, glguy was writing a tail-recursive preorder tree traversal in Agda. It requires you to use well-founded recursion.
18:24:24 <ddarius> So, for example, if my Haskell function only works correctly on certain types of input I can either 1) go "Oh well, hope it is only used on that input." or 2) try to encode that condition somehow.  If you choose 2, it is very likely that it will be more complicated and less effective than doing the same in Agda.
18:24:33 <dolio> Which, I don't know how you'd do that in Turner's language.
18:25:49 <applicative> Turner seemed to leave it an open question what forms of recursion were to be supported.  I wondered if this was part of the reason the project seemed to come to grief
18:26:29 <danharaj> Never quite figured out what a fold from an exponential functor would be.
18:27:07 <ddarius> danharaj: Exponentials are not initial algebras.
18:27:15 <dolio> Yes, I suppose one option would be to have the language directly support things like well-founded recursion.
18:27:44 <danharaj> Not in Set, but is there not a category where you have a fixed point?
18:27:48 <ddarius> danharaj: There are papers about folds on data types containing strictly positive uses of exponential types, but I think that is different from what you are asking about (though you may find them interesting none the less.)
18:27:54 <dolio> In Agda, it's just doing induction on a proof of well-foundedness/accessibility.
18:28:36 <applicative> the principal desideratum in Turner was that  the recursion types supported should be recognizable by the type checker, if I understood.
18:29:56 <danharaj> ddarius: I would be interested in such things
18:30:40 <ddarius> @google "Bananas in Space" haskell
18:30:41 <lambdabot> http://www.cs.nott.ac.uk/~gmh/bib.html
18:30:42 <lambdabot> Title: Graham Hutton: Publications
18:31:12 <danharaj> that's nifty
18:31:21 <danharaj> also, funny name.
18:32:33 <danharaj> I was thinking, for example, the powerset functor has no fixpoint in Set, but the limited powerset functor, say limited to countably infinite subsets, wouldn't that have a fixpoint and thus have an initial algebra?
18:35:21 <ddarius> danharaj: An exponential may be isomorphic to an intial algebra in some cases (e.g. certainly for any exponent of a finite set over a finite set).
18:36:55 <ddarius> danharaj: Note that Lambek's lemma says that initial algebras are fixpoints (up to isomorphism), but it doesn't say that fixpoints are initial algebras.
18:37:01 <danharaj> ah.
18:38:43 <ddarius> I'm certain you can make categories where every exponential object is the initial algebra of some functor.
18:39:08 <ddarius> As a trivial example, the terminal category is trivially cartesian closed.
18:39:44 <ddarius> And every functor on it has an initial algebra (though there is only one functor...)
18:40:11 <fax> algebra (category theory) is so hard to understand
18:40:19 <fax> FA -> A type stuff
18:40:44 <ddarius> One thing to note though, N is an initial algebra (an inductive type).  N -> X is isomorphic to Stream X which is a final coalgebra (a coinductive type.)
18:42:18 <danharaj> That's interesting.
18:45:31 <danharaj> Has operad theory been applied to types yet? I feel like that should combine the advantages of algebraic specification and category theory.
18:48:36 <ddarius> It's pretty much immediate that for categories where initial algebras are representable as omega-colimits and final coalgebras as omega-limits, if A is an initial algebra then A -> X is isomorphic to a final coalgebra.
18:48:58 <ddarius> danharaj: I believe there has been some applications of operad or general multicategory theory to types.
18:49:25 <danharaj> Been trying to get into the know of this sort of research. There are no professors in the field at the CS dept. at my university.
18:50:26 * twink has had a couple of books he doesn't understand on all that.
18:51:27 <djahandarie> I don't really like reading books
18:53:08 <twink> The stuff about \omega\lambda\times hyperdoctrines kind of sounds cool but are beyond me for the moment.
18:54:53 <danharaj> If there are survey books, I would love to know them. I have Jacobs' Categorical Logic and Type Theory, but it just scratches the surface :|
19:00:43 <aavogt> is there something like these for the chart library: http://www.graphviz.org/doc/info/colors.html#brewer
19:01:40 <ezyang> I rolled my own
19:02:09 <ezyang> colors = cycle $ map opaque [ blue, red, green, yellow, cyan, magenta, black ]
19:02:17 <ezyang> (mumble imports mumble)
19:04:07 <danharaj> Is there a standard module for bitfields and their manipulation?
19:04:18 <tromp_> Data.Bits ?
19:04:19 <ezyang> Data.Bit
19:04:36 <ezyang> *s
19:05:17 <aavogt> ezyang: thanks
19:05:30 <ezyang> np
19:05:46 <ezyang> Chart has some default cycle inside, but I don't know how to use it w/o using the simplified interface.
19:05:51 <danharaj> Thanks.
19:20:30 <sbahra> > 3 .&. 1 :: Int
19:20:31 <lambdabot>   1
19:20:36 <sbahra> oh, nice lambdabot has it
19:26:15 <andrewsw> @src (.&.)
19:26:16 <lambdabot> Source not found. My pet ferret can type better than you!
19:27:56 <sbahra> :t (.&.)
19:27:57 <lambdabot>     Ambiguous occurrence `.&.'
19:27:57 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
19:27:57 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
19:28:10 <sbahra> :t Data.Bits.(.&.)
19:28:12 <lambdabot> Couldn't find qualified module.
19:28:16 <andrewsw> bitwise and?
19:28:30 <andrewsw> > 3 .&. 2 :: Int
19:28:31 <lambdabot>   2
19:28:38 <sbahra> andrewsw, yes. Type  (Bits a) => a -> a -> a
19:28:50 <andrewsw> cool. thanks
19:28:59 <andrewsw> > 4 .&. 1 :: Int
19:29:00 <lambdabot>   0
19:29:22 <sbahra> > 3 .|. 1 :: Int
19:29:23 <lambdabot>   3
19:29:39 <andrewsw> > 4 .|. 1 :: Iint
19:29:40 <lambdabot>   Not in scope: type constructor or class `Iint'
19:29:42 <andrewsw> > 4 .|. 1 :: Int
19:29:43 <sbahra> > 2 .|. 1 :: Int
19:29:44 <lambdabot>   5
19:29:44 <lambdabot>   3
19:29:47 <andrewsw> heh
19:30:01 <sbahra> There's a whole bunch :) (and rotate)
19:31:09 <andrewsw> > complement 1 :: Int
19:31:10 <lambdabot>   -2
19:31:12 <andrewsw> heh
19:45:51 <uorygl> ~/.cabal/bin has snuck out of my $PATH again.
19:46:15 <uorygl> So, I guess I need to add a certain line to a certain file in my home directory.
19:47:30 <dibblego> echo "export PATH=/home/you/.cabal/bin:$PATH" >> ~/.profile
19:47:37 <uorygl> Perfect.
19:47:56 <uorygl> Technically incorrect, but perfect.  :P
19:47:58 <uorygl> Thank you.
19:50:08 <uorygl> Hrm.  Now when I try to open an Agda file with emacs, I get this: File mode specification error: (file-error "Cannot open load file" "haskell-indent")
20:27:39 <Sidmouth> This might be a silly question, but is there a nice pointfree way to do this: "f x:y:z:_ = g x y z"?
20:28:32 <tensorpudding> @pl f (x:y:z:_) = g x y z
20:28:33 <lambdabot> f = ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .) . g . head) tail
20:29:05 <tensorpudding> That's a truly ugly one there.
20:29:06 <fax> yeah that's a lot better
20:33:39 * aavogt tries some typeclass hackery for that
20:39:43 <uorygl> @type \(x:y:z:_) -> ?g x y z
20:39:44 <lambdabot> forall t t1. (?g::t -> t -> t -> t1) => [t] -> t1
20:40:31 <uorygl> I'm guessing there is not.
20:40:52 <fax> :t liftA3 ?g (!!0) (!!1) (!!2)
20:40:53 <lambdabot> forall d a. (?g::a -> a -> a -> d) => [a] -> d
20:41:20 <uorygl> The way you want it to work doesn't work...
20:41:27 * uorygl tries to figure out what that way is.
20:42:05 <uorygl> @type foldl
20:42:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:43:24 <uorygl> So, the pointfree way you want is this: f xs = foldl ($) g (take 3 xs)
20:43:33 <uorygl> Unfortunately, Haskell's type system won't let you do that.
20:50:41 <Sidmouth> I'm happy enough with f = g <$> (!!0) <*> (!!1) <*> (!!2); it's a lot nicer than what I was getting from pointfree.
20:50:44 <Sidmouth> Thanks, fax.
20:50:54 <idnar> @type f xs = foldl ($) g (take 3 xs)
20:50:55 <lambdabot> parse error on input `='
20:51:11 <idnar> @type \f xs -> foldl ($) g (take 3 xs)
20:51:12 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
20:51:12 <lambdabot>     Probable cause: `$' is applied to too many arguments
20:51:12 <lambdabot>     In the first argument of `foldl', namely `($)'
20:51:40 <idnar> @type \xs -> foldl ($) ?g (take 3 xs)
20:51:41 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
20:51:41 <lambdabot>     Probable cause: `$' is applied to too many arguments
20:51:41 <lambdabot>     In the first argument of `foldl', namely `($)'
20:52:00 <Cale> Sidmouth: It's probably better just to use pattern matching here anyway
20:52:03 <idnar> ah, yes
20:52:06 <idnar> of course
20:53:07 * hackagebot wai 0.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.0.1 (MichaelSnoyman)
20:53:50 <uorygl> Yeah, I'd rather not have to know what <$> and <*> are.
20:53:57 <uorygl> How are those pronounced, again?  "Money" and what?
20:54:38 <idnar> <$> is fmap
20:54:45 <idnar> and I pronounce <*> "ap" even though it's not quite
20:54:51 <tensorpudding> "fmap" and "ap"
20:54:57 <uorygl> Someone came up with cute pronunciations of those.
20:55:09 <idnar> I pronounce fmap as "map" anyway
20:55:20 <tensorpudding> ap, map, fmap
20:55:33 <uorygl> It's clear what function we're missing.
20:55:36 <idnar> ap, map, fap... err, wait...
20:55:43 <uorygl> Yep, that one.
20:55:57 <danharaj> I apply that function too often. :|
20:56:06 <idnar> @let fap = <*>
20:56:06 <lambdabot>   Parse error: VarSym "<*>"
20:56:15 <idnar> @let fap = (<*>)
20:56:16 <lambdabot>  Defined.
20:56:22 <uorygl> Perhaps "ap" should be the S combinator, and "fap" should be its generalization to functors.  Or monads, I guess.
20:56:34 <uorygl> @type (ap, (<*>))
20:56:35 <lambdabot> forall (m :: * -> *) a b (f :: * -> *) a1 b1. (Monad m, Applicative f) => (m (a -> b) -> m a -> m b, f (a1 -> b1) -> f a1 -> f b1)
20:56:46 <uorygl> I guess <*> is already a generalization.
20:56:53 <uorygl> Are applicatives also from category theory?
20:57:08 * hackagebot hamlet 0.0.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.0.1 (MichaelSnoyman)
20:57:12 <tensorpudding> applicative functors
20:57:32 <uorygl> I guess fap is a fine name for that function.
20:57:56 <danharaj> everything is from category theory :p
20:58:19 <blackdog> eesh, no thanks. i already cop enough charges of intellectual masturbation by using haskell anyway
20:58:25 <idnar> blackdog: hahaha
20:58:34 <blackdog> every now and then my friends ask with mock concern "have you thought about using a real language?"
20:58:47 <uorygl> Heh.
20:58:48 <blackdog> perl has lambdas, you know
20:58:54 <danharaj> Perl is a real language?
20:58:55 <uorygl> Python, too!
20:58:58 <idnar> heh
20:59:02 <uorygl> Heck, JavaScript has them.
20:59:07 <idnar> I used to get people bugging me about using Python
20:59:08 <danharaj> C++ is going to have them.
20:59:13 <idnar> "When are you going to use a real language?", they said
20:59:14 <blackdog> js is interesting that way, actually
20:59:18 <uorygl> Now C++ I just can't believe.
20:59:30 <danharaj> It's in the upcoming standard.
20:59:32 <idnar> I started telling them I was going to switch to Haskell any day now, and they stopped bugging me ;)
20:59:39 <tensorpudding> C++ is always adding stuff.
20:59:42 <blackdog> because it doesn't have a first class class system, you sort of have to use lambda
20:59:43 <idnar> (unfortunately I lied about the "any day now" part)
20:59:43 <danharaj> I think some compilers already implement them?
20:59:45 <tensorpudding> It'd do them significant good to remove stuff instead.
20:59:47 <blackdog> and people get addicted to it that way
20:59:51 <Cale> blackdog: The response is of course "I should be asking you the same thing"
21:00:28 <gwern> blackdog: the right answer is to say you plan to write your next program in assembler
21:00:39 <gwern> blackdog: that'll learn them to throw around adjectives like 'real'
21:00:55 <danharaj> Real men design analog circuits to solve their problems.
21:01:07 <blackdog> Cale, gwern: indeed:)
21:01:13 <fax> real men bash rocks together!!!
21:01:18 <uorygl> I'm going to design a really awesome Haskell processor any day now.  :P
21:01:18 <blackdog> it's hard arguing with perlians, though
21:01:25 <blackdog> (perlmonks?)
21:01:33 <uorygl> I just need to get my Verilog compiler working.
21:01:37 <idnar> perl hackers
21:01:39 <idnar> as in JAPH
21:01:42 <gwern> blackdog: perhal hackers, a la JAPH
21:01:42 <blackdog> the answer to any language deficiency is always "Oh, there's something on CPAN for that"
21:01:43 <danharaj> neckbeards
21:02:02 <blackdog> i'm sure neckbeard is reserved for lispers and old-school unix heads...
21:02:10 <danharaj> I call everyone a neckbeard.
21:02:13 <gwern> the old dilbert cartoon
21:02:15 <danharaj> Especially Lunix users
21:02:21 <gwern> here's a nickel kid get yourself a real os
21:02:25 <Cale> I watched an hour lecture on the insane complications involved in reliably designing CMOS resistors last night
21:02:31 <tensorpudding> How old is that cartoon anyway?
21:02:35 <blackdog> gwern: i thought it was "here's a nickel, get yourself a better computer"...
21:02:46 <gwern> tensorpudding: must be 80s
21:02:54 <tensorpudding> Was Dilbert even around back then?
21:03:02 <gwern> blackdog: pretty sure it was OS; a nickel wouldn't buy you a computer...
21:03:11 <tensorpudding> I thought Dilbert was born in like 1994 or something.
21:03:21 <blackdog> gwern: i think the argument was that the computer you're using isn't worth even a nickel...
21:03:47 <idnar> that doesn't sound like Dilbert's style anyway
21:03:57 <idnar> but Dilbert started in 1989
21:03:58 <gwern> dilbert used to be more technical
21:03:59 <blackdog> http://tomayko.com/writings/that-dilbert-cartoon
21:04:05 <blackdog> ran in 1995
21:04:46 * gwern feels partially vindicated - dilbert began in the 80s, just not that cartoon
21:05:20 <tensorpudding> 89 only has its toes in the 80's
21:06:54 <idnar> oh, right, the comment isn't from one of the main characters
21:08:44 <danharaj> can anyone explain the definition of an applicative functor as a lax monoidal functor?
21:08:45 <blackdog> idnar: no, dilbert's more passive aggressive
21:09:10 <Cale> danharaj: Sure. Do you know what lax monoidal functors are?
21:09:16 <blackdog> idnar: actually, dilbert shits me right off. he's clearly an intelligent guy who is doing absolutely nothing to make his life better, instead choosing to lob passive-aggressive comments at his mindless boss
21:09:17 <Cale> (And monoidal categories)
21:09:33 <danharaj> Yeah, I'm just not sure what the monoidal structure is.
21:09:36 <blackdog> he's not even an antihero, he's just a zero.
21:09:42 <danharaj> And I don't know what the difference between strict and lax monoidal functors is.
21:09:42 <Cale> danharaj: Well, it's just the stupid one
21:09:55 <Cale> With (,) as the monoid operation and () as the unit
21:10:02 <Cale> brb
21:10:25 <blackdog> also: someone is wrong on the internet: http://moonmaster9000.tumblr.com/post/564241201/ruby-v-haskell-round-3-mutually-recursive-data
21:10:30 <danharaj> heh. I wouldn't call that the stupid one. I should've figured since it's the only one that makes sense in the relevant category.
21:10:35 <blackdog> hard even to know where to start.
21:13:19 <idnar> blackdog: it makes those of us who choose to labour under the tender affections of a PHB feel better :P
21:13:45 <blackdog> idnar: it shouldn't. it should make you feel complicit and ashamed of yourself. :)
21:14:23 <idnar> blackdog: haha
21:14:54 <danharaj> The empty product is the terminal object right? I always get it mixed up.
21:15:13 <Sidmouth>  /quit
21:15:20 <idnar> danharaj: oh man
21:15:38 <idnar> danharaj: because of all this Dilbert talk, I read your line completely the wrong way
21:16:21 <blackdog> idnar: heh, sorry. firing up there for a second.
21:16:32 <danharaj> Joke just flew over my head.
21:16:58 <idnar> danharaj: I read "product" in the marketing sense, and "terminal" in the computer terminal sense
21:17:09 <danharaj> heh
21:20:48 <danharaj> Ok, so an applicative functor F is a lax monoidal functor from our universe with product as monoidal structure to... our F universe with product as the monoidal structure as well?
21:21:39 <dolio> That sounds right.
21:22:46 <danharaj> So... is every continuous functor applicative?
21:24:58 <danharaj> ah whatever. I'd rather go to bed.
21:25:04 <dolio> Probably.
21:25:59 <ManateeLazyCat> Ah, looks STM too fast break my code. :)
21:27:52 <portnov> @type \b -> b ?x ?y
21:27:53 <lambdabot> forall t t1 t2. (?y::t1, ?x::t) => (t -> t1 -> t2) -> t2
21:44:55 * ManateeLazyCat Perhaps i got a bug between `readTVarIO` and GHC-6.12.2, always got "segment fault", same code works fine with GHC-6.12.1 
21:46:45 <blackdog> irb
21:46:49 <blackdog> ... oops, sorry
21:47:54 * ManateeLazyCat Still in investigation.
21:48:19 <ManateeLazyCat> Today looks is another unlucky day.
21:48:46 * ManateeLazyCat When i upgrade to Gtk+ 2.20, Gtk+ library break my code. 
21:48:57 * ManateeLazyCat When i upgrade GHC-6.12.2, ghc break my code.
21:50:10 <fax> danharaj?
21:50:16 <ivanm> ManateeLazyCat: you do realise that when you use /me, it's meant to be actions or third-person stuff
21:50:43 <ManateeLazyCat> ivanm: Just fun.
21:52:07 <ManateeLazyCat> ivanm: Have you occur same problem like me?
21:52:18 <ivanm> nope
21:52:28 <ivanm> but then again, I only have gtk2hs installed for Chart support in criterion
21:52:49 <blackdog> ManateeLazyCat: how's it coming along, anyway?
21:53:11 <blackdog> there's a bunch of stuff that needs gtk2hs that i've given up on just because it's so hard to get installed on mac os x
21:53:43 <ivanm> blackdog: is that because of needing C libraries?
21:53:51 <ManateeLazyCat> blackdog: I haven't Windows and Mac, sorry.
21:53:56 <ivanm> or you just can't be bothered doing a ./configure && make && make install? :p
21:54:31 <ManateeLazyCat> ivanm: Check gtk2hs, just do "./boostrap.sh", that's all.
21:54:51 <ManateeLazyCat> ivanm: All packages in gtk2hs (except gstreamer) can install by Cabal.
21:55:30 <ivanm> eh, the ebuild uses configure and make, I don't need to build it myself
21:55:32 <ManateeLazyCat> blackdog: Any hint about "segment fault" when i do readTVarIO in GHC-6.12.2?
21:56:15 <ManateeLazyCat> ivanm: We don't need ./configure stuff for install gtk2hs, just do run bootsrap.sh or "cabal install"
21:56:33 <ivanm> ManateeLazyCat: I don't care how darcs does it, I care about how _releases_ do it
21:56:46 <ManateeLazyCat> ivanm: Ok, again. :)
21:56:49 <ivanm> I don't develop with gtk2hs, so I don't care about the HEAD version
21:56:59 <ivanm> so AFAIK, current release requires ./configure and make
21:57:11 <ManateeLazyCat> ivanm: Axel will release next version when he finish convert gstreamer to Cabal.
21:57:35 <ManateeLazyCat> ivanm: Ok, ok, i know you mean, we have talk this enough. :)
21:57:45 <aavogt> is there a nicer way to do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25275#a25275
21:58:04 <aavogt> asin, a way that needs less type signatures?
21:58:23 <ivanm> ManateeLazyCat: right, but even if there is a bootstrapping script, it won't help windows, OSX (well, might work there), etc.
21:58:59 <ManateeLazyCat> ivanm: Yes, i haven't Windows and OSX, so i don't know detail, i just test gtk2hs with Linux.
22:02:41 <hamishmack> ManateeLazyCat: I have working gtk2hs on linux, osx and windows, but built the old way.  Where is the latest cabalized version and I'll try it out?
22:03:15 <ManateeLazyCat> hamishmack: Axel have push my Cabal patches to main reop.
22:03:16 <ivanm> hamishmack: you have to get the darcs version IIRC
22:03:19 <ManateeLazyCat> hamishmack: Check again.
22:03:51 <ManateeLazyCat> hamishmack: I have test darcs with 6.12.2
22:04:03 <ManateeLazyCat> ivanm: hamishmack is a leksah developer. :)
22:04:15 <ivanm> ManateeLazyCat: I know...
22:04:29 <ManateeLazyCat> hamishmack: Get code and run ./bootstrap (if you want to test all packages)
22:04:35 <ivanm> I just said he had to get the latest darcs version if he wanted to test the cabalised stuff
22:04:39 <blackdog> ivanm: that and not being in cabal
22:04:41 <blackdog> hackage, rather
22:04:45 <blackdog> and _then_ the c il
22:04:48 <blackdog> library stuff
22:04:54 <hamishmack> I'm sticking with 6.12.1 until HP is updated
22:04:54 <blackdog> ManateeLazyCat: sorry man, I don't know.
22:05:27 <ivanm> hamishmack: it will probably work with 6.12.1 as well
22:05:41 <blackdog> hamishmack: are you the NZ hamish who's coming to AusHac?
22:06:10 <hamishmack> blackdog: Yes
22:06:25 <ManateeLazyCat> blackdog: Thanks, still in investigation, i will report to GHC team if i found this is a bug of 6.12.2 :)
22:06:31 <hamishmack> I think blackh may come too
22:06:53 <ManateeLazyCat> hamishmack: Current gtk2hs works from 6.10 to 6.12
22:07:10 <ManateeLazyCat> hamishmack: Axel test with 6.10, i test with 6.12.1 and 6.12.2
22:07:17 <blackdog> hamishmack: i know he is - he's staying with me:)
22:07:29 <blackdog> planning leksah hacking?
22:07:33 <ManateeLazyCat> hamishmack: If you just have 6.12.1, gtk2hs support it.
22:08:10 <ivanm> what's the trick to put in a {-# ... #-} in your file to have ghci pick mtl over transformers?
22:08:24 <ManateeLazyCat> hamishmack: Have any STM code in leksah?
22:08:58 <hamishmack> blackdog: I'd like to fix up yi support a bit more (its still very early days)
22:09:14 <c_wraith> ivanm: something like OPTIONS_GHC -hide-package transformers  ?
22:09:41 <ivanm> c_wraith: that's the one, ta
22:09:44 <ManateeLazyCat> hamishmack: BTW, i think leksah shouldn't depend Yi always, if Yi break, Leksah break too.
22:10:01 <hamishmack> ManateeLazyCat: I don't think we have any STM in Leksah.
22:10:05 <ManateeLazyCat> hamishmack: Except Yi split some base library out.
22:10:38 <hamishmack> ManateeLazyCat: We use Yi as a library
22:10:47 <ManateeLazyCat> hamishmack: Nevermind, i just test my gtk2hs code with 6.12.2, and found ghc got "segment fault" when i do "readTVarIO"
22:11:10 <hamishmack> and we support both GtkSourceView and Yi
22:11:44 <ivanm> c_wraith: dammit, looks like that doesn't work anymore :s
22:12:16 <aavogt> ivanm: there's something fo package-qualified imports...
22:12:21 <ManateeLazyCat> hamishmack: Yi have different back-end, that's mean Yi just can do minimum features between those back-end.
22:12:22 <ivanm> yeah, might do that
22:12:29 <aavogt> otherwise just ghc-pkg hide transformers
22:13:29 <ivanm> actually, stuff it, I'll do that
22:13:32 <ivanm> I thought it was for just one file
22:13:34 <ManateeLazyCat> hamishmack: And i agree share basic-library for different editor projects.
22:13:51 <ManateeLazyCat> hamishmack: Such as "Code Completion" back-end.
22:14:49 <ivanm> OK, how do I set a CPP flag?
22:15:03 * ivanm is trying to get latest criterion use chart support properly
22:15:13 * ManateeLazyCat I don't know when time release my project, gtk2hs take up too much time in April.
22:15:42 <ivanm> OK, worked that out
22:17:54 <kingping> Hello
22:17:55 <ManateeLazyCat> hamishmack: Please report any problem to gtk2hs list, thanks. :)
22:18:32 <ManateeLazyCat> hamishmack: Plan to use gio code in leksah?
22:18:37 * ivanm waves idly in kingping's general direction
22:18:43 <kingping> May I call (\x-> let y = x + 2 in y + 4) a combinator ?
22:18:45 <kingping> :)
22:19:10 <idnar>  I'd call it (+6)
22:19:45 <kingping> > (\x-> let y = x + 2 in y + 4) 5
22:19:46 <lambdabot>   11
22:20:26 <ManateeLazyCat> hamishmack: I have build temporarily repository (https://patch-tag.com/r/AndyStewart/gio-branch/) for test gio new APIs (update to 2.24.0), you can try to use it.
22:20:51 <hamishmack> ManateeLazyCat: I don't think we will need it.  I saw your not about utf8 filenames, but I think we will wait for fixes to ghc for that.
22:21:43 <ManateeLazyCat> hamishmack: I think use GIO APIs is simpler, gio hidden platform details.
22:22:06 <ManateeLazyCat> hamishmack: And use GIO, you will got many modern APIs to handle file.
22:22:15 <ManateeLazyCat> hamishmack: Detail see documentation of gio/gvfs
22:22:58 <ivanm> kingping: I don't think it's a combinator
22:23:12 <ivanm> according to wikipedia, "A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments."
22:23:38 <ManateeLazyCat> hamishmack: FilePath (or Directory) functions in System can't handle utf-8 (or other coding), at least for Linux.
22:23:46 <ManateeLazyCat> hamishmack: And gio handle those problem well.
22:24:07 <kingping> Maybe, I'm also reading http://en.wikipedia.org/wiki/Lambda_calculus#Free_and_bound_variables
22:24:15 <kingping> 2 ivanm
22:24:33 <ManateeLazyCat> hamishmack: You have Windows and Mac ?
22:25:05 <ivanm> kingping: that isn't lambda calculus though since you have numbers
22:25:57 <hamishmack> ManateeLazyCat: Mac with VMs for Windows 7 and Ubuntu 10.4
22:25:58 <kingping> ivanm: Ok, ?x.(y=x+x; y+x)
22:26:22 <ManateeLazyCat> hamishmack: Hehe, so powerful box.
22:26:33 <tensorpudding> you can use church numerals instead though
22:26:39 <ManateeLazyCat> hamishmack: Please help us test gtk2hs on Mac and Windows.
22:27:52 <ivanm> kingping: is + defined as a lambda function?
22:28:03 <ivanm> anyone here still have chart 0.12 documentation installed?
22:28:55 <ivanm> I want to check what the old meaning of BarsFixGap used to be (since it's changed from taking a single Double into taking two Doubles)
22:30:29 <kingping> ivanm: ?x y.(z=x y; z)  :D
22:30:56 <ivanm> that doesn't even look like a lambda function ;-)
22:31:03 <ivanm> what's that equality sign doing there!?!?!?!?
22:31:06 <ivanm> :p
22:31:15 <kingping> It is let z = x ;)
22:31:42 <kingping> > :t (\x y -> let z = x y; z)
22:31:43 <lambdabot>   <no location info>: parse error on input `:'
22:32:19 <Veinor> hm, > :t (\x y -> (let z = x y; z))
22:32:23 <Veinor> > :t (\x y -> (let z = x y; z))
22:32:24 <lambdabot>   <no location info>: parse error on input `:'
22:32:30 <Veinor> :t (\x y -> (let z = x y; z))
22:32:31 <lambdabot> parse error on input `)'
22:32:32 <kingping> > @type 2
22:32:33 <lambdabot>   <no location info>: parse error on input `@'
22:32:33 <Veinor> ...
22:32:43 <kingping> > @ 2
22:32:45 <lambdabot>   <no location info>: parse error on input `@'
22:32:50 * ManateeLazyCat I hope all gtk2hs packages will add into "Haskell Platform". 
22:34:27 <tensorpudding> @type 2
22:34:29 <lambdabot> forall t. (Num t) => t
22:35:18 <ManateeLazyCat> Bye all, debugging 6.12.2 bug .....
22:35:22 <kingping> ?x.x is a lambda abstraction, right?
22:35:23 <lambdabot> Maybe you meant: . thx
22:35:37 <ivanm> kingping: yeah, the identity function
22:35:44 <ivanm> @help thx
22:35:45 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(43,48): Non-exhaustive patterns in case
22:35:52 <ivanm> ?
22:36:09 <ivanm> @thx
22:36:10 <lambdabot> you are welcome
22:36:11 <kingping> And x y is an application in ?x y.x y ?
22:36:19 <ivanm> yeah
22:36:34 <tensorpudding> λx.λy.x y
22:36:37 * ivanm hasn't done any formal lambda calculus though
22:36:41 <ivanm> tensorpudding: show-off
22:36:57 <idnar> heh
22:36:59 <ivanm> anyway, I've sent bos a patch to have chart support in criterion again! \o/
22:37:08 <kingping> And http://en.wikipedia.org/wiki/Lambda_calculus#Free_variables states that: "The free variables of a term are those variables not bound by a lambda abstraction."
22:37:23 <tensorpudding> but most of the time people replace λx.λy with λx y.
22:37:27 <tensorpudding> because it's shorter
22:37:59 <ivanm> after all, lambda functions get _long_... >_>
22:38:02 <tensorpudding> in the lambda calculus all functions are of one variable
22:38:05 <kingping> And also the article says: "For example, the lambda term representing the identity ?x.x has no free variables, but the constant function ?x.y has a single free variable, y."
22:38:49 <kingping> So is z in ?x y.(let z=x y; z) is free..
22:39:26 <ivanm> no, since you bind it (I think...)
22:39:51 <kingping> Yes, I do, but using only bound variables, which are within abstraction.
22:40:05 <kingping> So ?x y.(let z=x y; z) is combinator?
22:40:30 <kingping> If I apply beta-reductin it's going to be I think..
22:46:56 <kamatsu> z is not free in that example
22:47:25 <kamatsu> although i wasn't aware that people used let bindings in lambda calculus, they can be reduced as follows:
22:47:53 <kamatsu> let a=b; c  -> (\a. c ) b
22:48:11 <kamatsu> therefore in your example, applying that rewrite:
22:48:40 <kamatsu> \x y. (let z=x y; z) -> \x y. (\z. z) (x y)
22:49:23 <kamatsu> that looks like it can be eta-reduced to the identity function
22:49:47 <kingping> -> \x y.x y ?
22:50:04 <kamatsu> eta reduction says that \x. f x is just f
22:50:13 <kamatsu> so..
22:50:28 <kamatsu> \x.(\y. (\z.z) x y)
22:50:29 <kamatsu> ->
22:50:32 <kingping> But there's \x.\y. ...
22:50:38 <kamatsu> \x.(\z.z) x
22:50:46 <kamatsu> eta reducing again
22:50:49 <kamatsu> (\z.z)
22:51:12 <fax> beta reduction gives \x. x
22:51:14 <fax> so x = z
22:51:15 <kamatsu> so? you just eta reduce twice.
22:51:35 <kamatsu> or you can use beta reduction and eta reduction
22:52:42 <kamatsu> (as fax did)
22:53:01 <kingping> Well, I implied, ?x y.(z = (x y); z)
22:53:23 <kingping> Where z is result of applying x to y.
22:53:24 <kamatsu> what is the difference between that and your previous one?
22:53:39 <kamatsu> yes, my rewrite rule still applies for that.
22:53:55 <kamatsu> once again:
22:54:09 <kamatsu> \x.\y. (\z. z) (x y)
22:54:27 <kamatsu> oh, crap
22:54:29 <kingping> ?x y.x y
22:54:29 <lambdabot> Maybe you meant: . ? @ v
22:54:43 <kamatsu> no, \x.x
22:54:59 <kamatsu> well, \x y. x y is just as valid
22:55:09 <kamatsu> but you can use eta reduction on the y.
22:55:53 <kamatsu> \x y. x y is equivalent to \x. x
22:55:53 <kingping> ^^
22:56:30 <kingping> \x y. x y != \x y. x(y) ?
22:56:42 <kamatsu> no
22:56:51 <kamatsu> but
22:56:59 <kamatsu> \x y. x y == \x (\y. x y)
22:57:19 <kamatsu> remember eta reduction says \x. f x is just f
22:57:25 <kamatsu> so \y. x y -> x
22:57:27 <kamatsu> therefore
22:57:28 <kamatsu> \x. x
22:58:06 <kamatsu> \x y. x y is equivalent to \x y. x(y)
22:58:08 <kingping> > (\x y -> x y) (+3) 2
22:58:09 <lambdabot>   5
22:58:32 <kamatsu> > (\x -> x) (+3) 2
22:58:34 <lambdabot>   5
22:58:44 <kamatsu> ;)
22:58:54 <kingping> > (\x y -> let z = x y; z) (+3) 2
22:58:55 <lambdabot>   <no location info>: parse error on input `)'
22:59:05 <kamatsu> that's not valid let syntax in haskell
22:59:17 <kamatsu> > (\x y -> let z = x y in z) (+3) 2
22:59:18 <lambdabot>   5
22:59:26 <kingping> Ah, right.
22:59:46 <kamatsu> so, to summarize:
23:00:06 <kamatsu> (\x y. let z = x y; z) -> \x y. x y -> \x. x
23:00:09 <kingping> So the last expr should be treated as combinator.
23:00:24 <kamatsu> what do you mean?
23:00:55 <kingping> It doesn't have free variables, which are not in scope of the lambda abstraction.
23:01:47 <kamatsu> in the formal semantics of lambda calculus, evaluation via substitution requires that that is true for application.
23:02:39 <kamatsu> if i understand you correctly
23:02:45 <kingping> > (\x -> x) (+) 2 7
23:02:46 <lambdabot>   9
23:02:48 <kamatsu> what exactly do you mean by the last expr?
23:03:04 <kingping> kamatsu: (\x y. let z = x y; z) -> \x y. x y -> \x. x
23:03:11 <kingping> Which is yours.
23:03:30 <kingping> s/;/in/
23:03:54 <kamatsu> i still don't understand what you mean
23:04:02 <DigitalKiwi> do you not know sed?
23:04:08 <kamatsu> no, that's not the problem
23:04:11 <DigitalKiwi> ;p
23:04:19 <kulin> if i want Data.Map to have two keys to the same value (in this case a network handle) where should i start?
23:04:26 <kingping> http://en.wikipedia.org/wiki/Lambda_calculus#Free_and_bound_variables: "An expression which contains no free variables is said to be closed. Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic."
23:04:31 <kamatsu> kingping quoted me, but i don't know what expression he's referring to.
23:04:38 <kamatsu> kingping: i know that
23:04:52 <kamatsu> kingping: what i want to know is why you think that some expression in lambda terms must be a combinator.
23:05:09 <kamatsu> kingping: it'd be helpful if you'd specify what expression you mean
23:05:13 <kingping> I don't know, I like that word :D
23:05:26 <kingping> \x y. x y
23:05:38 <kamatsu> okay, so you're saying what about it?
23:05:48 <kingping> It is combinator.
23:05:48 <kamatsu> it is a combinator
23:05:58 <DigitalKiwi> I like the words "that's what she said" but that does not mean I go around applying them to everything people say
23:05:59 <kamatsu> but, that doesn't mean anything
23:06:02 <DigitalKiwi> oh wait
23:06:05 <kingping> (\x y. let z = x y in z) is also a combinator.
23:06:11 <kamatsu> yes
23:06:20 <kamatsu> as i said all the way at the beginning ... "z is not free"
23:06:32 <kingping> Because it beta/etha/tetha/psi/gamma/cappa reduces to \x y. x y
23:06:43 <kamatsu> well, even \x. x
23:06:51 <kingping> Yes, eta \x. x
23:06:57 <kamatsu> it only beta reduces \x y. x y
23:07:29 <kamatsu> it's interesting you've got lets there
23:07:39 <kamatsu> i've never actually seen lets used in the lambda calc
23:07:40 <kingping> but (\x y. let z = x m in z) is not a combinator.
23:07:44 <kamatsu> right
23:07:47 <kamatsu> m is free
23:08:22 <kamatsu> as let a = b in c -> (\a. b ) c
23:09:53 <kingping> kewl
23:10:01 <kingping> Thanks so much.
23:10:57 <kamatsu> no worries
23:11:34 <kingping> It's strange no ppl in our uni use FP.
23:11:51 <kamatsu> what uni?
23:12:06 <kamatsu> my uni is veritably full of people that do
23:12:10 <kingping> Ah, technical university in one of russian cities.
23:12:27 <kamatsu> the great dons hails from my university
23:12:50 <kingping> We had a month or so of logical programming in visual prolog, that's all. Everything else is C.
23:13:04 <kamatsu> as far as logic languages go, prolog sucks anyway
23:13:09 <kamatsu> stupid LTR
23:13:14 <Randroid> My impression is that FP seems to be more popular at universities, and OOP in the business world.
23:13:22 <kamatsu> that is true in general
23:13:38 <kingping> I believe FP is more general.
23:13:48 <kingping> LTR?
23:13:50 <arw> bussiness seems firmly java and c++, except for some niches.
23:13:52 <kamatsu> left-to-right
23:14:04 <kamatsu> it's the major annoying failing of prolog
23:14:44 <kamatsu> my university is teaching Agda now, so i guess we're ahead of the curve
23:15:07 * kingping envys :]
23:15:43 <kingping> I wish I was born anywhere else.
23:15:50 <kamatsu> it's mostly because we have TacticalGrace
23:15:53 <Kaidelong> is Agda general purpose or is a research or DS language?
23:16:01 <Kaidelong> is it a
23:16:03 <kamatsu> Kaidelong: it's a theorem proving language
23:16:08 <arw> some first-years are about to launch a major complaint about java as a first language. except their alternative is python, of all things...
23:16:15 <kamatsu> Kaidelong: intuitionistic dependant types
23:16:25 <kulin> i wish my school would stop teaching c
23:16:26 <kamatsu> arw: stick with java, imo
23:16:29 <Kaidelong> arw: given the way universities tend to teach java they may as well use C
23:16:40 <kingping> kulin: +1
23:16:44 <kamatsu> My uni starts with C for first years
23:16:53 <kamatsu> i think it's productive, they learn how the machine really works first
23:16:58 <kulin> people are learning about linked lists and other completely irrelevant topics
23:16:59 <arw> kamatsu: agreed, and i hope in this case the profs will stick with java.
23:17:33 <kulin> we dont program in punch cards, we shouldnt program in c
23:17:43 <arw> Kaidelong: yes, its often a problem that nobody finds the real balance between "teach the language" and "teach programming".
23:17:45 <Kaidelong> arw: one nice thing about java over python is that although students will still make the mistake of thinking references are values they won't make the mistake of using one type where they need another
23:17:46 <kingping> I couldn't get rid of imperative habits, when programming in erlang, haskell.
23:17:49 <kamatsu> I think students are better served by programming languages that encourage discipline and will completely barf at you if you do it wrong.
23:17:54 <Kaidelong> without the compiler making it clear, anyway
23:18:14 <kingping> I think ppl shouldn't taught C as first language.
23:18:27 <kamatsu> I think it works, but you have to have good teachers and approach it properly
23:18:33 <kamatsu> Haskell works as a first language too
23:18:50 <Kaidelong> kamatsu: Java seemed disciplinarian when I first looked at it but after I saw how other people actually wrote java in the industry I was not impressed anymore
23:19:03 <kamatsu> Kaidelong: it's certainly more disciplined than Python though
23:19:10 <kamatsu> Kaidelong: there's just more idiots using Java.
23:19:16 <Niccus> the important part is to not just learn one language
23:19:18 <arw> Kaidelong: agreed. typing is one major point. the others are syntax (java is just more similar to what is used later on, and python is just very obscure in that regard) and usability of the language. they will need java later on, but they most probably won't need python.
23:19:26 <Kaidelong> kamatsu: but they just work around the discipline, it seems like people who write python at least try to stick more to python style
23:19:51 <kulin> the problem is a lot of my teachers dont even know there are better functional languages than lisp, so functional languages just get lip service, incorrectly claiming they are slow and not suitable to real world applications
23:20:08 <kamatsu> kulin: that's sad :(
23:20:14 <Kaidelong> I wasn't aware that LISP was slow and unsuitable for real world applications either
23:20:24 <Kaidelong> over here they teach SML/NJ
23:20:26 <kingping> kulin: Same is here, they don't think there's anything else in FLP besides prolog, lisp.
23:20:28 <kulin> kaide well its not slow, since the 70s or so i guess
23:20:37 <kamatsu> here we teach Agda/Haskell largely
23:20:38 <Kaidelong> The guy who teaches the subject is completely apathetic
23:20:53 <kamatsu> and C/Java as well
23:20:57 <Kaidelong> and SML/NJ seems to have a lot of special constructs and exceptions to the rules that frustrates students
23:21:00 <kamatsu> but in terms of FP languages, Agda/Haskell.
23:21:03 <QtPlatypus> The speed of a lanuage is proportinal to effort that has gone into optimizing its compiler/interprator.
23:21:03 <blackdog> kamatsu: is Chak teaching the Agda course?
23:21:07 <kamatsu> blackdog: yup
23:21:11 <Kaidelong> I think OCaml would be a better choice
23:21:19 <Kaidelong> (than SML/NJ)
23:21:32 <blackdog> kamatsu: ah, nice. wish i was still freelancing, i'd come back and sit at the back of the class... :)
23:21:37 <kamatsu> aha
23:21:45 <kamatsu> agda is very nice
23:21:49 <Adamant> OCaml is probably more viable
23:21:53 <Adamant> in the long run
23:21:53 <kamatsu> i found it alot more digestible than isabelle
23:21:54 <Kaidelong> everyone I know here who took the guy's class say they hate functional programming and like PROLOG better
23:22:05 <arw> QtPlatypus: in part. but there is also the overall design that influences the speed of the resulting program. if you design a language without the aliasing problem for example, the compiler will have a far easier time.
23:22:08 <Kaidelong> so that does not reflect well on SML/NJ
23:22:14 <fax> Kaidelong that's amazing
23:22:15 <blackdog> Prolog _is_ admittedly excellent on carefully chosen toy probles.
23:22:28 <fax> blackdog lol yeah right
23:22:44 <QtPlatypus> arw: True.
23:22:44 <kingping> Kaidelong: No idea why hate, after all FP is easier than prolog.
23:23:10 <arw> prolog would be nice as an addon library to solve some parts and be able to do the rest in a 'sane' language.
23:23:22 <Kaidelong> kingping: I think it is because the things that make FP so nice (consistency, compositionality) don't shine in SML/NJ
23:23:22 <arw> similar to how sql is used.
23:23:23 <kamatsu> i am glad cos i get to teach a haskell-based course for the first time next semester
23:23:28 <kamatsu> i'm getting sick of teaching java and c
23:23:28 <Kaidelong> I looked over some of my roomate's assignments
23:23:48 <Kaidelong> a lot of the time the "obvious" solutions didn't work, because something turned out to be a special keyword rather than a function
23:24:15 <Kaidelong> had to do with the fact that SML doesn't short circuit, I think
23:24:30 <Kaidelong> unless there is a special keyword to do it
23:24:42 <kamatsu> ew
23:25:04 <ManateeLazyCat> I'm reading tutorial of CHP, anybody compare CHP with DBus?
23:25:28 <kamatsu> DBus is a concurrency framework?
23:25:44 <ManateeLazyCat> Looks CHP's communication is synchronous, and DBus is asynchronous, perhaps i'm wrong.
23:25:46 <tensorpudding> DBus does IPC, doesn't it?
23:25:55 <ManateeLazyCat> Yes, DBus, is IPC
23:25:56 <arw> kamatsu: no. IPC via some kind of xml messages.
23:26:03 <kamatsu> arw: ah
23:26:10 <ManateeLazyCat> Similar IPC
23:26:13 <ManateeLazyCat> But not all.
23:26:15 <kamatsu> arw: then, only similar to CHP on a surface level
23:26:19 <arw> kamatsu: local only and somewhat limited, but the new 'standard' for desktop environments on linux.
23:26:25 <kamatsu> right
23:26:30 <Kaidelong> I got everything working eventually but I saw why my classmates would be frustrated by it
23:26:33 <kamatsu> i don't know if i even use it for anything
23:26:56 <arw> kamatsu: CHP?
23:27:06 <ManateeLazyCat> I want just know the principle of CHP, and how difference with DBus's one.
23:27:10 <kamatsu> communicating haskell processes
23:27:25 <ManateeLazyCat> Currently, i use DBus communication haskell processes.
23:27:44 <ManateeLazyCat> http://docs.google.com/viewer?a=v&q=cache:4kz-uhBzm88J:www.cs.kent.ac.uk/projects/ofa/chp/tutorial.pdf+chp+haskell&hl=zh-CN&pid=bl&srcid=ADGEESi4aehr8fsYc87h8z0Sm_dT1KxgjUf3aG-fijSGwyEqUf1N-Ov3tCCDlHYahCj4nR1rPWFU4Jwpe6Y8ZPfP6-c9eHhpyXizbUSVHxH8rzjP19lwvu3GbeNuRPWfhVSeqvUrAdrW&sig=AHIEtbT2EOl00DXNGgujScrtQmfUfRv1lQ
23:27:57 <ManateeLazyCat> Open CHP tutorial in Google Docs.
23:28:05 <kamatsu> it's a concurrency framework for haskell, doesn't really do IPC
23:28:19 <kamatsu> afaik
23:28:34 <ManateeLazyCat> kamatsu: That's mean CHP can't for non-haskell process?
23:28:43 <kamatsu> ManateeLazyCat: essentially yes.
23:29:01 <kamatsu> but i don't know much about it
23:29:05 <tensorpudding> CHP will only work on two Haskell applications, I'm pretty sure that DBus is language-agnostic.
23:29:06 <kamatsu> so, don't quote me
23:29:51 <ManateeLazyCat> tensorpudding: Looks DBus is i need.
23:30:04 <kulin> is there some type like (a,b) that i can use as a key for Data.Map.map so that I can do Data.Map.lookup a or Data.Map.lookup b and get the value mapped to (a,b)?
23:30:09 <ManateeLazyCat> tensorpudding: I use DBus with STM handle multi-processes communication.
23:30:45 <ManateeLazyCat> kulin: Have.
23:31:25 <kulin> do you know what module that is in?
23:31:46 <arw> depends on what you want to do. dbus is suited for local and low-throughput high-latency communication only. you wouldn't want to try doing any extensive calculations with it...
23:31:55 <ManateeLazyCat> kulin: filterWithKey ?
23:33:58 <ManateeLazyCat> arw: I'm bulid a Haskell/Gtk+ multi-processes framework, I use DBus (dbus-core, dbus-client) for multi-processes communication, and all calculation in running in separate processes.
23:34:10 <kulin> ya, i guess i can just use filter with key, i was hoping there was a type that I could use through lookup so i might get a time better than O(n)
23:34:15 <ManateeLazyCat> kulin: filterWithKey :: (Ord k) => (k -> a -> Bool) -> Map k a -> Map k a
23:35:08 <ManateeLazyCat> kulin: Use Set replace Map?
23:36:21 <ManateeLazyCat> kulin: Data.Set is give your O(log n) search time.
23:36:23 <idnar> kulin: you could probably wrap something around two maps
23:36:33 <arw> ManateeLazyCat: then dbus should be what you want, for most user-interface stuff its suited well. you just don't want to let it transmit your 1GB matrix of simulation results...
23:37:09 <idnar> or one map, or a set, depending on what you want
23:38:23 <kulin> ill tinker with set a bit, see if i can get it to do what i want, but i might just end up maintaining two maps
23:38:31 <ManateeLazyCat> arw: Yeah, i never use DBus transform calculate data, i use DBus transform command, such as, daemon process send DBus message to child-plugin process "Hey, child, do this job and return use DBus message return result to me".
23:38:34 <kulin> thanks ManateeLazyCat and idnar
23:39:02 * ManateeLazyCat pasted "Data.Set search code." at http://paste2.org/get/805499
23:39:03 <ManateeLazyCat> kulin: Example, i use above code search in Data.Set
23:39:43 <ManateeLazyCat> arw: I'm interested CHP, and want to know what's it.
23:40:40 <ManateeLazyCat> arw: Looks CHP is special IPC mechanism for Haskell processes, and avoid to share variable (MVar or TVar) between Haskell processes, right?
23:40:59 <arw> ManateeLazyCat: I didn't know about CHP until 10 minutes ago, so I'm the wrong person to ask :)
23:41:30 <ManateeLazyCat> arw: CHP is young project, but looks stable enough. :)
23:42:00 <ManateeLazyCat> Any CHP master here?
23:42:18 <arw> ManateeLazyCat: but as far as I've understood, M/TVars work only with threads, not processes.
23:42:51 <arw> ManateeLazyCat: but i'm not quite sure. also, network communication is another thing you usually want from an IPC system.
23:43:09 <ManateeLazyCat> arw: Yes, but for communication with multi-processes, you need use M/TVar build multi-thread to listen message, right?
23:43:56 <ManateeLazyCat> arw: Currently, i build many TVar in my program, for receive DBus messages.
23:44:18 <idnar> arw: is it really IPC if you transport it over a network?
23:44:24 <arw> ManateeLazyCat: IPC is usually synchronous, so to make it asynchronous, you will need something like a receiver thread and some M/TVars for synchronisation with that receiver thread.
23:44:58 <ManateeLazyCat> arw: I use dbus-core and dbus-client.
23:45:00 <Ke> or spooling with files!
23:45:02 <arw> idnar: yes. nobody prevents the processes from running on different machines. the mechanisms are very similar.
23:45:05 <p_l> idnar: well, it's still inter-process, right?
23:45:22 <idnar> p_l: sure, but any network protocol is "inter-process communication"
23:45:24 <ManateeLazyCat> arw: All TVars is handle asynchronous when receive DBus message.
23:45:37 <idnar> so that seems a bit uselessly loose
23:46:20 <arw> idnar: in a way, yes. usually you want some mechanisms an IPC framework should provide.
23:46:42 <idnar> arw: okay
23:46:46 <ManateeLazyCat> arw: TVars is for protected share variable when daemon process receive some many DBus message concurrently.
23:46:53 <arw> idnar: (un)marshalling of data, transport-agnostic transmission, name services.
23:47:13 <ManateeLazyCat> @package dbus-core
23:47:13 <lambdabot> http://hackage.haskell.org/package/dbus-core
23:47:18 <ManateeLazyCat> @package dbus-client.
23:47:18 <lambdabot> http://hackage.haskell.org/package/dbus-client.
23:47:43 <arw> idnar: many network protocols implement those for themselves, but there are some which are based on a common IPC framework.
23:47:51 <ManateeLazyCat> Above two packages is Haskell implementation for DBus protocol, i always use it.
23:48:15 <arw> idnar: the whole NFS/NIS family of protocols is based on SunRPC for example.
23:50:01 <ManateeLazyCat> CHP is cool, but it's looks not i need, research it later.
23:53:25 <ManateeLazyCat> The best multi-processes *asynchronous* mechanism i know in Haskell is `dbus-client`.
23:54:19 <ManateeLazyCat> Because John implementation `dbus-core` and `dbus-client` with Haskell instead binding, so it's stable enough.
23:55:42 <ManateeLazyCat> I recommend all haskeller use DBus for multi-processes communication, it give your clearer logic than other IPC mechanism.
23:55:54 <ManateeLazyCat> DBus can work in Windows and Mac ?
23:57:03 <ivanm> if it can, there's probably no point
23:57:17 <ivanm> ManateeLazyCat: also, I have the feeling that using dbus is a bit of an abuse...
23:57:24 <ivanm> anyway, dbus is pretty DE specific
23:57:25 <Ke> wikipedia says yes
23:57:39 <ivanm> (I think KDE has just started getting dbus support, and not everyone uses a DE anyway)
23:57:54 <arw> yes, but it will still be a major hassle, because nobody on those platforms will have dbus installed and running.
23:58:06 <ManateeLazyCat> ivanm: No, because my project is Haskell Application Platform like gnome or kde, so i'm not abuse . :)
23:59:06 <Ke> There seems to be no abstracted portable ipc api for haskell sadly
