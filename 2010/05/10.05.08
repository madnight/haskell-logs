00:20:04 <systemfault> Watching SPJ's talk about DPH, looks very nice :)
00:31:40 <cdsmithus> Success!  For perhaps the first time, a program written in Haskell can connect to and remain logged in to Linden Labs' "Second Life" virtual world.  Wiring to to your favorite FRP implementation is left as an exercise for the reader. :)
00:32:07 <p_l> lol
00:32:19 <lispy> cdsmithus: wow!
00:35:54 <cdsmithus> That is one crazy protocol.  A weird mix of XML-RPC to some pieces, and UDP datagrams to others, and the UDP datagrams have some parts in big endian byte order, other parts in little endian, no documentation at all... it was a challenge!
00:38:44 * p_l recalls hearing something about Second Life bots written in CL few years ago
00:39:09 * dv- recommends calling it Functional Life
00:39:10 <p_l> but they had some special .NET libs for that (and a CL ported to .NET vm)
00:40:18 <cdsmithus> p_l, yes, there is a .NET / Mono implementation.  I spent some time on trying to get Haskell to talk to a Mono librray, then gave up and implemented the protocol.
00:44:21 <cdsmithus> I suppose I need to clean up some code and put it on Hackage now... perhaps change the Cabal file to stop claiming "-any" for all the dependencies
00:55:46 <glguy> ?djinn (Either a (a -> b) -> b) -> b
00:55:46 <lambdabot> f a = a (Right (\ b -> a (Left b)))
01:01:29 <javuchi> hello, i'm looking for a book that i started to read a year ago or so about haskell
01:01:43 <javuchi> a very complete book, i read it on the web
01:01:59 <javuchi> do you know what book i'm talking about?
01:02:06 <javuchi> it has difficult exercices
01:02:20 <Saizan> @where rwh
01:02:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:02:24 <Saizan> that one?
01:03:13 <javuchi> oh yes, tahnk you Saizan
01:03:33 <Saizan> glguy: attracted by the classical dark side?:)
01:04:05 <glguy> hurray!
01:04:14 <glguy> ?djinn ((a -> b) -> b) -> (a -> ((c -> b) -> b)) -> ((c -> b) -> b)
01:04:14 <lambdabot> f a b c = a (\ d -> b d c)
01:04:37 <glguy> ?djinn a -> ((a -> b) -> b)
01:04:37 <lambdabot> f a b = b a
01:04:58 <glguy> Saizan: I'm attracted to embedding that unclean logic in something more concrete ;)
01:08:11 <glguy> ?djinn ((a -> ((b -> c) -> c)) -> ((a -> c) -> c)) -> ((a -> c) -> c)
01:08:11 <lambdabot> f a b = a (\ c _ -> b c) b
01:08:14 <Saizan> hah, that's a nice exercise :)
01:08:24 <lispy> the repository for iteratee has disappeared
01:08:31 <lispy> Anyone know where I can find it?
01:08:41 <lispy> I'm thinking I'll have to email John Lato
01:09:28 <glguy> I think that it is pretty nifty that djinn got type type for excluded middle
01:10:37 <glguy> or rather the implementation
01:11:49 <Saizan> if only the philosophy students that come to #logic knew about djinn..
01:12:08 <Twey> lispy: http://okmij.org/ftp/Streams.html#iteratee maybe?
01:12:19 <glguy> They'd be able to tell us about the things that don't not exist?
01:13:45 <glguy> ?djinn ((((a -> b) -> b) -> b) -> b) -> ((a -> b) -> b
01:13:45 <lambdabot> Cannot parse command
01:13:47 <Saizan> haha, maybe, but surely they'd be able to solve their exercises
01:14:04 <glguy> ?djinn ((((a -> b) -> b) -> b) -> b) -> ((a -> b) -> b)
01:14:04 <lambdabot> f a b = a (\ c -> c b)
01:14:21 <Saizan> or fall into depression knowing that a machine can easily do what they find hard :)
01:14:31 <opqdonut> or start believing in AI
01:14:56 * glguy wonders if anyone buy Saizan knows the names of these things
01:14:58 <glguy> but
01:15:49 * hackagebot test-framework 0.3.1 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.3.1 (MaxBolingbroke)
01:15:51 * hackagebot test-framework-hunit 0.2.6 - HUnit support for the test-framework package.  http://hackage.haskell.org/package/test-framework-hunit-0.2.6 (MaxBolingbroke)
01:15:53 * hackagebot test-framework-quickcheck 0.2.6 - QuickCheck support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck-0.2.6 (MaxBolingbroke)
01:15:55 * hackagebot test-framework-quickcheck2 0.2.7 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.7 (MaxBolingbroke)
01:16:18 <lispy> Twey: John Lato made a repository and maintains a version of that which is on hackage.  If I'm going to hack it, I might as well start from the tarball on hackage.
01:16:32 <lispy> Twey: John's repo used to be linked to the hackage package, but I guess it moved
01:16:38 <Twey> Mm
01:18:29 <glguy> ?bot
01:18:30 <lambdabot> :)
01:19:25 <ivanm> @botsmack
01:19:25 <lambdabot> :)
01:44:03 <opqdonut> anyone know the origin of the term "purely functional"?
01:44:47 <Saizan> there's another debate on its semantics?
01:45:44 <Twey> I sometimes feel like I don't understand Hackage/Cabal/cabal-install at all.  Why does happstack-helpers require the broken happstack-util-0.4.1 when happstack-util-0.5.0.1 is available and installed?  Aren't the packages kept in sync?
01:46:13 <opqdonut> nah, I'd just like to cite somebody in my master's
01:47:58 * hackagebot hashed-storage 0.4.13 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.13 (PetrRockai)
01:49:02 <Lor> opqdonut, a quick search with google scholar would seem to indicate Landin's "Correspondence between ALGOL 60 and Church's Lambda-notation: part I"
01:49:34 <Saizan> Twey: "cabal install happstack-helpers --dry-run -v" should shed some light
01:49:43 <Lor> (Well, not so quick, since it only allows filtering by date, not sorting by date)
01:50:23 <opqdonut> thanks :)
01:52:37 <Twey> Saizan: Um, in a manner of speaking… happstack-helpers-0.50 discards happstack-state-0.5.0, and the craziness proceeds from there
01:56:26 <Dae_> is there any work being done on haskell for android? I googled around a bit, but I couldn't find anything
02:00:14 <edon> what's the best source for understanding monad transformers?
02:00:19 <Twey> Saizan: Unpack and configure requires containers >=2 && <3, but after ‘cabal-install 'containers >=2 && <3' --preference='base >=4'’ it still says the dependency is missing
02:00:43 <Twey> (I thought I'd see if it would build if the upper bounds were lifted from those dependencies)
02:06:11 <Saizan> well, evidently -helpers has not been upgraded to work with the new happstack release
02:09:01 <Saizan> if you lifted that constraint you should also lift the one on containers (which i think it's more stable than happstack anyhow)
02:11:49 <Twey> Saizan: I'd like to try…
02:11:53 <proppy> About http://www.haskell.org/haskellwiki/99_questions/1_to_10, for 2/ Problem 2 2nd solution, shouldn't it be myButLast'' (_:xs) = myButLast'' xs instead of myButLast (without the ''), it seems like a typo
02:14:13 <proppy> will edit the page
02:17:06 <Twey> Saizan: No matter what I install, it still comes up with the list of dependencies
02:22:48 <Saizan> Twey: i relaxed the contraints dep in the happstack-helper.cabal and i got cabal to build it against happstack-*-0.5, the problem is that i get a build error at that point.
02:23:11 <Twey> Hmn :-\
02:23:58 <Twey> How did you do that?  I unpacked it and edited the Cabal file then did a Setup.hs configure, and it just listed unmet dependencies.
02:26:19 <Saizan> i use "cabal install"
02:26:26 <Saizan> with no package argument
02:26:32 <Saizan> it picks the .cabal in the current directory
02:26:48 <Saizan> http://code.haskell.org/~Saizan/happstack-helpers-0.50.1.tar.gz <- patched, btw
02:27:23 <Saizan> Twey: Setup configure defaults to a --global installation so it won't see packages installed in the user db
02:28:21 <Saizan> (fsvo patched, i.e. axing things away to make it build, such as constraints and a duplicates instance)
02:30:10 <Twey> Saizan: Ohhh.
02:30:22 <Twey> Cool.
02:30:29 <Twey> I didn't know cabal-install could do that.
02:30:50 <Twey> Ah, you fixed it already?  I was just considering it ☺
02:31:14 <Saizan> yup :)
02:31:56 <Saizan> you could mail the maintainers maybe :)
02:32:07 <Twey> ♥
02:32:09 <Twey> Will do
02:32:19 <Twey> This has been blocking a project of mine for about two months now
02:33:13 <tensorpudding> Is there a data structure that supports efficient transpositions?
02:37:17 <Saizan> a pair of an Array and a Bool?
02:37:38 <roconnor> tensorpudding: A*B -> C
02:41:34 <Phyx-> @ap
02:41:35 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:41:36 <Phyx-> @src ap
02:41:37 <lambdabot> ap = liftM2 id
02:41:39 <Phyx-> ah
02:43:51 <Lor> @src ($)
02:43:52 <lambdabot> f $ x = f x
02:43:58 <Lor> bah.
02:47:09 * Phyx- just realized that tab completion works in ghci
02:48:14 <Spockz> Phyx-, already?
02:52:35 <proppy> Is there a prelude function for returning the first element of a list ?
02:52:38 <Phyx-> Spockz: yes, I'm a slow learner :)
02:52:43 <Phyx-> proppy: head
02:52:55 <proppy> Phyx-: thanks :)
02:53:05 <Phyx-> but it's unsafe, e.g. crashed on en empty list
02:53:09 <Phyx-> an*
02:53:49 <proppy> looking forward writing quickCheck for 99questions answers
02:54:06 <proppy> so I thought I could write something like
02:54:07 <proppy> prop_myFirst = myFirst xs == head xs where types = xs :: [Int]
02:54:21 <proppy> does this sound like a silly idea ?
02:55:58 <Phyx-> @check \a->head a == head a
02:56:00 <lambdabot>   "*Exception: Prelude.head: empty list
02:56:05 <Phyx-> proppy: that will happen
02:56:12 <Phyx-> and the test won't terminate
02:56:26 <proppy> what is @check an alias for quickCheck ?
02:56:54 <proppy> Phyx-: searching for a way to test the function with list of at least one element :)
02:57:53 <Phyx-> proppy: check the quickcheck documentation, you can streer the checking but I don't remember how exactly
02:58:21 <proppy> Phyx-: yes thanks I'm reading http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
03:01:07 <Saizan>  @check \a-> not (null a) ==> head a == head a
03:01:10 <Saizan> @check \a-> not (null a) ==> head a == head a
03:01:11 <lambdabot>   No instance for (Test.QuickCheck.Testable
03:01:11 <lambdabot>                     (Test.QuickCh...
03:01:24 <Saizan> @check \a-> not (null a) ==> (head a == head a)
03:01:24 <lambdabot>   No instance for (Test.QuickCheck.Testable
03:01:25 <lambdabot>                     (Test.QuickCh...
03:02:09 <Phyx-> @type (==>)
03:02:11 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
03:02:11 <proppy> I was trying something like prop_myFirst (x:xs) = myFirst (x:xs) == head (x:xs), but it doesn't seems to work :)
03:02:43 <proppy> prop_myFirst (x:xs) = myFirst (x:xs) == head (x:xs) where types = (xs::[Int], x::Int)
03:02:52 <proppy> still returns *** Failed! Exception: 'Scratch.hs:(6,0)-(7,36): Non-exhaustive patterns in function prop_myFirst' (after 1 test):
03:03:20 <Phyx-> proppy: yes, that'll not prevent it from testing the empty string, that'll just fail on pattern matching when it eventually does check it
03:03:48 <Phyx-> proppy: also, lists are uniform in types, so saying x :: Int implies xs :: [Int] and the other way around
03:04:27 <sosman> I have a tiny attempt at my first Haskell program @ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25382#a25382.  It currently runs but having got a filename to read, I'm not sure how to get the file handle.
03:04:29 <proppy> Phyx-: thanks :0
03:05:27 <gueux> hi
03:05:34 <proppy> Saizan: prop_myFirst xs = not (null xs) ==> myFirst xs == head xs where types = xs::[Int]
03:05:36 <gueux> I've updated xmonad and xmonad-contrib via cabal, but now ghc does not seem to look into the .cabal folder... do I have to change a environment variable or something?
03:05:38 <proppy> does the trick :)
03:05:40 <proppy> Saizan: thanks !
03:06:52 <sosman> I basically want to apply myfunc to the contents of the file named on the command line or stdin if not provided.
03:07:11 <proppy> it seems thare where types for quickcheck is optional, nice
03:07:22 <proppy> does this when that it will test it with various types ?
03:08:51 <Phyx-> sosman: you could just use "readFile" to read the file in by name, no handle needed. but if you really want to use the handle to read the file, check withFile or indeed openFile
03:09:40 <Phyx-> proppy: your tests don't actually depend on the elements inside the list. since you're basically just checking the structure instead of the elements
03:10:27 <sosman> Phyx-: thanks - when i uncommented the openFile (line 12) I get "Parse error in pattern".
03:10:50 <proppy> Phyx-: yes, so the type quickCheck supply there is not important
03:10:55 <proppy> Phyx-: I was just wondering :)
03:11:53 <Phyx-> sosman: that's because you're not in a do block after the ->
03:12:16 <sosman> Phyx-: I have to have nested do?
03:13:54 <Rectal> Hello
03:14:30 <Rectal> Just wondering if I could ask a couple questions
03:14:56 <jlouis> Saizan: dropped a longish mail to cafe about combinatorrent IO :)
03:15:00 <Phyx-> sosman: yes, because after the -> it doesn't know you were in a do so say it simply
03:15:25 <Rectal> First year Uni is pretty sucky, they make all the code and I have to figure out how it works
03:15:48 <Phyx-> Rectal: sure
03:16:47 <Rectal> They make all the functions, but I need to use one of those functions on some data, I was wondering how to use it on a list of lists
03:17:03 <Phyx-> sosman: after that, myfunc (hGetContents hin)
03:17:07 <Phyx-> won't typecheck either
03:17:29 <proppy> quickCheck gave up! after generating 14tests, with prop_elementAt xs n = not (null xs) && n < length xs && n >= 0 ==> elementAt xs n == xs !! n where types = n :: Int
03:17:38 <proppy> maybe that means that constraints are too hard ?
03:19:07 <Rectal> [(x, [y], z)] -- What is the best way to count the amount of y for each value of z, then return the z -- I used unzip3 so far, but after I got a function working (without compile errors) it crashes
03:19:20 <ivanm> Rectal: which uni are you at?
03:19:21 <Zao> "crashes"?
03:19:47 <ivanm> map (\(x,ys,z) -> (length ys, z)) ?
03:19:56 <roconnor> proppy: how \xs -> zipWith elementAt xs [0..] == xs ?
03:19:57 <Rectal> Well, I am on windows and since it is a commandprompt it just quits rather than let me read the error
03:20:02 <roconnor> how about
03:20:28 <ivanm> Rectal: what's the actual function you tried to use?
03:20:30 <Rectal> Everything you just said is GREAT - not sure what it does, but I will look that up in Preulude and try to fit those in! THANK YOU
03:20:38 <ivanm> (note that unzip3 probably isn't what you want)
03:21:03 <Zao> I can't say I quite grok what you want your function to do.
03:21:14 <Rectal> I had never tried lists of lists, so it may look ugly, ill try to fix this first
03:21:18 <Zao> Why bother with counting things when you in the end do not return it.
03:21:23 <ivanm> Zao: AFAICT what I said *shrug*
03:21:32 <proppy> roconnor: google zipWith :)
03:21:34 <proppy> googling
03:21:35 <Phyx-> sosman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25382#a25383
03:21:57 <proppy> nice
03:22:05 <sosman> Phyx-: thanks - my brain was starting to hurt.
03:23:32 <Phyx-> Rectal: run your program from cmd.exe instead of double clicking on it to see the error
03:25:40 <Rectal> Thank phyx
03:25:59 <proppy> Rectal: it will not work because it will try to call elementAt x1 0 then elementAt x2 1
03:26:19 <proppy> oups roconnor
03:26:54 <Phyx-_> hm freenode disconnected me! how rude
03:26:54 <proppy> instead of elementAt xs 0, elementAt xs 1
03:27:16 <proppy> roconnor: I should find a way to generate a infinite list of xs
03:27:20 <proppy> [xs, xs, xs, ..]
03:27:56 <Rectal> I miss C
03:28:00 <Rectal> or even VB....
03:28:04 <roconnor> proppy: ah ooops
03:28:16 <roconnor> \xs -> map (elementAt xs) [0..] == xs ?
03:28:19 <roconnor> duh
03:28:28 <Phyx-> Rectal: you mean you miss imperative languages
03:28:35 <roconnor> wait
03:28:38 <roconnor> still not right
03:28:40 <ivanm> Rectal: which uni are you at?
03:28:47 <proppy> infinite xs = xs:(infinite xs)
03:28:59 <proppy> and zipWith elementAt infinit xs [0..] ?
03:29:01 <Rectal> Australian National University
03:29:08 <Jafet> He misses rectal ones
03:29:18 <ivanm> Rectal: which subject is this?
03:29:21 <Rectal> Phyx I miss anything that was easy
03:29:46 <Phyx-> Haskell's not that hard once you get used to it
03:29:51 <roconnor> \xs -> zipWith (const (elementAt xs)) xs [0..] == xs
03:29:57 <Rectal> Intro to Computing and Algorithims
03:29:58 <roconnor> @type  \xs -> zipWith (const (elementAt xs)) xs [0..] == xs
03:29:59 <lambdabot> Not in scope: `elementAt'
03:30:05 <roconnor> @type  \xs -> zipWith (const (?elementAt xs)) xs [0..] == xs
03:30:07 <lambdabot> forall a b. (?elementAt::[a] -> b -> a, Num b, Enum b, Eq a) => [a] -> Bool
03:30:07 <ivanm> Rectal: COMP1100?
03:30:11 <Rectal> Yes
03:30:11 <roconnor> still
03:30:12 <ivanm> what are you needing to do that for?
03:30:14 <roconnor> that is kinda lame
03:30:21 * ivanm points out that he is a tutor for that subject, as is Axman6 ...
03:30:23 <Rectal> Ivan, are you one of the tutors?
03:30:27 <Rectal> Oh
03:30:27 <ivanm> yup :D
03:30:31 <Rectal> Oh yes
03:30:33 <Rectal> Can I ask you a question?
03:30:38 <ivanm> sure
03:30:41 <Rectal> I will try to keep it in terms of X y and z
03:30:45 <proppy> roconnor: const generate an infinite list of constant ?
03:30:54 <ivanm> note that i haven't looked that in-depth at the assignment
03:31:03 <roconnor> proppy: no.
03:31:13 <Phyx-_> wtf
03:31:15 <Phyx-_> i cloned?
03:31:25 <proppy> is there a prelude fonction to generate an infinite list of constant ?
03:31:34 <roconnor> @type \xs -> all (zipWith (==) (map (?elementAt xs) [0..]) xs)
03:31:35 <ivanm> proppy: [1,1..]
03:31:35 <lambdabot>     Couldn't match expected type `a -> Bool'
03:31:35 <lambdabot>            against inferred type `[Bool]'
03:31:35 <lambdabot>     In the first argument of `all', namely
03:31:37 <ivanm> or repeat 1
03:31:39 <ivanm> > repeat 1
03:31:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:31:41 <roconnor> @type \xs -> and (zipWith (==) (map (?elementAt xs) [0..]) xs)
03:31:42 <lambdabot> forall a a1. (Eq a, ?elementAt::[a] -> a1 -> a, Num a1, Enum a1) => [a] -> Bool
03:31:43 <proppy> ok :)
03:31:55 <gueux> is there a way to say ghc to use the ~/.cabal/lib directory? http://pastebin.com/wacAUSWK it does not seem to use it
03:31:56 <roconnor> this is the best I can think of: \xs -> and (zipWith (==) (map (elementAt xs) [0..]) xs)
03:32:00 <opqdonut> > fix (1:)
03:32:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:32:09 <proppy> so zipWith elementAt repeat xs [0..]
03:32:13 <proppy> should do the trick ?
03:33:19 <Phyx-> proppy: missing () zipWith elementAt (repeat xs) [0..]
03:33:19 <Rectal> What exactly does IntMap do?
03:33:35 <roconnor> proppy: you are thinking of zipWith elementAt (repeat xs) [0..]
03:33:38 <roconnor> but it doesn't work
03:33:42 <roconnor> because both lists are infinite
03:33:50 <roconnor> and you get an infinite list out
03:34:11 <roconnor> we want to zipWith something xs [0..]
03:34:19 <roconnor> so that we only zip as long as xs is
03:34:23 <proppy> roconnor: why not map(element xs) [0..] == xs ?
03:35:33 <proppy> roconnor: ah yes, you're right quickcheck might not be able to converge with infinite list
03:35:37 <proppy> (I guess)
03:35:41 <Rectal> btw, Recatl as in Rectal Exambot, a reference to a line in an episode of Futurama
03:36:17 <roconnor> proppy: those lists are not equal
03:36:22 <roconnor> they have different lengths
03:36:55 <proppy> ah yes you're right the right one is infinite
03:37:01 <proppy> oups the left one :)
03:37:48 <proppy> roconnor: hence the zipWith
03:38:25 <Rectal> Ivan, my current code is here http://pastebin.com/WuyB3vG5
03:38:39 <roconnor> yep
03:38:48 <Rectal> Some things may have been slightly changed since last testing
03:39:33 <proppy> roconnor: thanks
03:39:34 <proppy> rop_elementAt xs n = not (null xs) ==> and (zipWith (==) (map (elementAt xs) [0..]) xs) == True where types = n :: Int
03:41:04 <ivanm> Rectal: what's your question?
03:41:26 <ivanm> Rectal: it says what your error is
03:41:37 <ivanm> Rectal: first of all, [y[ys]] doesn't make sense
03:41:42 <Rectal> Yes, I know that
03:41:50 <ivanm> note that x:[xs] means its a two element list
03:41:53 <Rectal> Does [y:[ys]] make any?
03:41:58 <ivanm> you probably mean (x:xs)
03:42:09 <Rectal> Well, I wasn't sure, since at that time it was a list inside a list
03:42:19 <ivanm> Rectal: [y:[ys]] == [[y,ys]]
03:42:27 <Rectal> Oh right
03:42:28 <ivanm> Rectal: ignore all that
03:42:34 <Saizan> jlouis: so basically in erlang you're not doing an incremental parse at all?
03:42:52 <Rectal> So y:ys is still appropriate when it is inside a list itself?
03:43:15 <ivanm> Rectal: first of all, use better variable names or you'll lose marks! ;-)
03:43:39 <ivanm> you can say (y:ys), where y is [Coord] and ys is [[Coord]]
03:43:44 <ivanm> then you just want length y
03:44:02 <Saizan> jlouis: however i think the ensure+Partial mechanism in attoparsec could be smarter if it paid more attention to how many bytes are required to proceed further
03:44:16 <ivanm> Rectal: where do you get that type signature from though?
03:44:36 <ivanm> A much better way of doing it would be [(Coord, [Coord], Board)]
03:44:51 <Rectal> I uh... thought unzip3 would be better
03:44:53 <Rectal> Tehee!
03:44:57 <ivanm> nope ;-)
03:45:03 <Rectal> Sorry, I got it to work slightly
03:45:04 <ivanm> Rectal: you have a list of possible moves
03:45:15 <ivanm> (where "move" == (Coord, [Coord], Board)
03:45:48 <Rectal> To choose the best one I choose the one with the most values inside the middle [Coord]?
03:46:08 <ivanm> What is [Coord]?  the flipped pieces?
03:46:11 <cebewee> 4/wc
03:46:14 <Rectal> Yes
03:46:16 <ivanm> if so, yes: you want to pick the first one with the maximum
03:46:29 <ivanm> Rectal: so, think of it this way:
03:46:36 <ivanm> you have the current move, and the rest of the moves
03:46:49 <ivanm> return the score along with the chosen move
03:47:06 <ivanm> in your recursive call, return the best possible move in the rest of that list
03:47:13 <jlouis> Saizan: nope :)
03:47:15 <ivanm> then compare that score to the score of the first element
03:47:29 <jlouis> Saizan: In erlang I wait until I have everything and then just parse it
03:52:33 <Rectal> We are talking about the greedy AI right?
03:54:37 <ivanm> yes
03:54:59 <ivanm> Rectal: think about it, if we have a list of moves (m:ms), then find the best move out of ms and compare that to m
03:56:59 * hackagebot wumpus-core 0.15.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.15.0 (StephenTetley)
04:02:25 <proppy> wierd quickCheck returns ok with prop_myReverse xs = myReverse xs == reverse xs
04:02:35 <proppy> and myReverse (x:xs) = x:xs
04:02:38 <proppy> which is wrong
04:03:33 <dobblego> it's defaulting to ()
04:03:40 <dobblego> try (Xs :: [Int])
04:03:44 <dobblego> *xs
04:03:45 <proppy> @check xs = myReverse xs == reverse where myReverse (x:xs) = x:xs
04:03:45 <lambdabot>   Parse error at "=" (column 4)
04:04:12 <Peaker> Type defaulting is a horrible feature
04:04:19 <ivanm> @check let myReverse = id in \ (xs :: [Int]) -> myReverse xs == reverse xs
04:04:19 <lambdabot>   Parse error in pattern at "->" (column 39)
04:04:37 <ivanm> @check \ (xs :: [Int]) -> id xs == reverse xs
04:04:37 <lambdabot>   Parse error in pattern at "->" (column 17)
04:04:37 <ivanm> bah
04:04:49 <dobblego> @check let myReverse = id in \x -> reverse x == myReverse (x :: [Int])
04:04:50 <lambdabot>   "Falsifiable, after 1 tests:\n[2,2,-3]\n"
04:05:23 <Peaker> @check liftA2 (==) reverse id :: [Int] -> Bool
04:05:34 <dobblego> @check let myReverse = id in \x -> reverse x == myReverse
04:05:34 <proppy> prop_myReverse xs = myReverse xs == reverse xs where types = (xs :: [Int])
04:05:34 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
04:05:34 <dobblego> @check let myReverse = id in \x -> reverse x == myReverse x
04:05:34 <lambdabot>   "OK, passed 500 tests."
04:05:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
04:05:53 <proppy> @check let myReverse = id in \x -> reverse x == myReverse x where types = (x :: [Int])
04:05:53 <lambdabot>   Parse error at "where" (column 54)
04:05:57 <proppy> :(
04:06:21 <roconnor> @hoogle readLine
04:06:22 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
04:06:22 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
04:06:22 <lambdabot> module System.Console.Editline.Readline
04:06:28 <roconnor> @hoogle readLn
04:06:28 <lambdabot> Prelude readLn :: Read a => IO a
04:06:29 <lambdabot> System.IO readLn :: Read a => IO a
04:07:22 <proppy> dobblego: adding where types = (xs :: [Int]) does the trick thanks
04:07:22 <dobblego> no worries mate
04:12:05 <Rectal> Ivan, am I supposed to just use validMoves on it, then use the scoreboard function?
04:12:05 <Rectal> @rectal test
04:12:05 <ivanm> Rectal: something like that, yes
04:12:05 <lambdabot> Unknown command, try @list
04:12:33 <Peaker> I wonder how @check is parsed.. apparently  @check x :: y   parses differently from @check (x :: y)
04:14:51 <Rectal> Spam
04:14:56 <ivanm> nope, net-split
04:15:06 <Rectal> I mean, it was like spam.... 999 lines
04:15:13 <Rectal> What exactly is a net split?
04:15:25 <ivanm> http://en.wikipedia.org/wiki/Net_split
04:16:53 <proppy> came up with an alternative version of isPalindrome
04:16:54 <proppy> http://gist.github.com/394508
04:16:57 <proppy> care commenting ?
04:24:23 <Phyx-> hmm is there a library function that does this http://phyx.pastebin.com/9Bjk8zXV
04:24:45 <Phyx-> basically just cycle the head of the list
04:25:59 <Saizan> > let f xs = map (take (length xs)) . tails . cycle in f [1..3]
04:26:00 <lambdabot>   *Exception: Prelude.cycle: empty list
04:26:06 <Rectal> I am trying to compare the x with the xs, but all the tuples are making it hard,  you sure I shouldn't unzip them ivan?
04:26:09 <Saizan> > let f xs = map (take (length xs)) . tails . cycle $ xsin f [1..3]
04:26:10 <lambdabot>   not an expression: `let f xs = map (take (length xs)) . tails . cycle $ xsi...
04:26:15 <Saizan> > let f xs = map (take (length xs)) . tails . cycle $ xs in f [1..3]
04:26:16 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1...
04:26:32 <proppy> Phyx-: [1,2,3,4] became [2,3,4,1] ?
04:26:50 <Saizan> > let f xs = map (zipWith (flip const) xs) . tails . cycle $ xs in f [1..3]
04:26:51 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1...
04:27:12 <Phyx-> proppy: no it becomes [[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
04:27:29 <apfelmus> > let f xs = zipWith (++) (tails xs, inits xs) in f [1..5]
04:27:30 <lambdabot>   Couldn't match expected type `[a]'
04:27:30 <lambdabot>         against inferred type `([[a1]], ...
04:27:56 <Rectal> Hoiw do you talk to someone in particular?
04:27:58 <apfelmus> > let f xs = zipWith (++) (tails xs) (inits xs) in f [1..5]
04:27:59 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4],[1,2,3,4,5]]
04:28:00 <Rectal> !Rectal hello
04:28:02 <Rectal> no
04:28:17 <Phyx-> /msg <nickname>
04:29:31 <proppy> apfelmus: in which module is tails defined ?
04:29:41 <apfelmus> proppy: Data.List
04:29:57 <proppy> apfelmus: thanks
04:30:09 <apfelmus> proppy: np :)
04:34:30 <proppy> quickchecked my answers to 99_questions here http://gist.github.com/394513
04:35:18 <proppy> thanks for your help roconnor, Phyx-, dobblego :)
04:36:59 <roconnor> how do I set which file I want to me the Main module when compiling with GHC?
04:37:09 <roconnor> Finding anything in the GHC manual is impossible
04:39:09 <proppy> roconnor: man ghc tells -main-is :)
04:39:19 <proppy> or -no-hs-main ?
04:39:58 <Phyx-> @pl (\a -> join . liftM2 f a)
04:39:58 <lambdabot> (join .) . liftM2 f
04:41:18 <roconnor> proppy: thanks
04:45:07 <_KY_> Is Haskell better supported on .NET or JVM?
04:46:07 <Ke> is it supported at all?
04:47:20 <_KY_> Looks like both are under way
04:47:53 <_KY_> Does anyone have latest information?
04:48:02 <Ke> use ghc
04:48:31 <_KY_> I want some .NET interoperability
04:52:31 <Twey> It's not really supported running on either
04:52:40 <Twey> But there is a .NET interop library for GHC
04:52:54 <Twey> http://hackage.haskell.org/package/hs-dotnet
04:53:48 <Twey> Looks to be quite comprehensive, though I haven't used it myself
04:54:33 <Twey> Looks like it might have broken dependencies… base >=4 && <4
04:55:05 <Twey> Oh, that could just be the Hackage build system
04:55:28 <Phyx-> hmm.. either i'm going crazy or GHC is
04:55:33 <Twey> I think it adds <4
04:56:53 <_KY_> What do you mean?
04:57:02 <_KY_> It says <3 or >=4
04:58:17 <gueux> is that just me or emacs does not color haskell well? --> seems to be considered as a comment marker :(
04:58:34 <Phyx-> need some fresh pairs of eyes on this, it's simple yet i can't find what's wrong here http://phyx.pastebin.com/YE5ksRVK
04:59:03 <Twey> gueux: WFM — do you have the latest haskell-mode?
04:59:29 <gueux> Twey: I have 2.7.0-2
05:01:32 <Phyx-> anyone see why eval is returning that? I'm sure it's something very simple, but i just can't see it atm
05:01:36 <Phyx-> lol
05:02:54 <Twey> Phyx-: The expression you passed is (- 8 (- 5 (- 2 (/ 10 5)))), Lispily
05:03:11 <benmachine> seems your subtraction is associating to the right
05:03:29 <Phyx-> ahh
05:03:31 <Phyx-> right
05:03:33 <Twey> There's no association involved — it's evaluating it exactly as Phyx- specifies it, which is as above
05:04:01 <Phyx-> Now see, I've been looking at that for ages, hehehe, thanks Twey
05:05:43 <Twey> Presumably you want (- (- (- 8 5) 2) (/ 10 5)) or (Sub (Sub (Sub (Lit 8) (Lit 5)) (Lit 2)) (Div (Lit 10) (Lit 5)))
05:05:46 <Phyx-> Why didn't I see that :|
05:06:02 <Twey> Plus a ‘Paren’ perhaps, though your ‘Paren’ is redundant at the moment
05:07:12 <Phyx-> Twey: yeah, the Paren is just used for pretty printing. but the bug was in buildTree, which associated everything to the right :| fixing now
05:07:49 <Rectal> If I have a tuple, inside a list, how would sort of convert it to xs? Like (x,y,z):(xs,ys,zs)
05:10:16 <mux> that makes no sense; you cannot automagically convert a list of triples into a triple of lists
05:10:50 <mux> what are you trying to write?
05:10:56 <dobblego> @type unzip3
05:10:57 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
05:11:06 <mux> I don't think he means that
05:13:28 <ivanm> Rectal: don't
05:13:36 <ivanm> Rectal: treat each element of the list seperately
05:13:38 <ivanm> and recurse
05:13:42 <mux> Rectal: if you pattern match on a list, what's on the right of ':' is one element of the list, and what's on the right of ':' has to be of type of a list of such elements
05:13:50 <ivanm> dobblego: nah, he stuffed up by using that in the first place ;-)
05:13:53 <mux> if you need to take out two triples at once you could write
05:13:54 <ivanm> he has no need to do that
05:14:01 <ivanm> Rectal: you want recursion
05:14:10 <ivanm> mux: fyi, it's an assignment
05:14:14 <mux> (x1,y1,z1):((x2,y2,z2):rest)
05:14:17 <mux> oh.
05:14:28 <dobblego> I've no idea what he wants
05:14:56 <mux> I think he doesn't either, but when he'll get his thoguhts straighten, he'll realize what he wants is probably plain recursion :-)
05:14:57 <ivanm> dobblego: I know what he wants, and he doesn't get my hints that he's doing it the wrong way
05:15:32 <ivanm> short version: he has a list of triples, and he wants to return the first element that is a maximum under some criteria
05:16:11 <Rectal> I am not really sure what recursion is, so I am not sure what you are saying
05:16:28 <dobblego> a recursive function is one which calls itself in its body
05:16:30 <mux> heh, recursion isn't even needed
05:16:45 <Jafet> @quote recursion
05:16:45 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
05:16:50 <ivanm> mux: yes it is
05:16:53 <mux> recursion: see recursion
05:16:54 <ivanm> mux: I tutor this subject ;-)
05:17:18 <mux> ivanm: I mean that he could write it by using some specific function and not have to recurse himself :-)
05:17:25 <Jafet> You tutor recursion? Sounds painful
05:17:25 <ivanm> Rectal: when you do map f (x:xs) = f x : map f xs, that's recursion
05:17:33 <ivanm> (you're recursing on xs)
05:17:40 <ivanm> mux: no, he pretty much has to
05:17:46 <ivanm> Jafet: I tutor the subject this assignment is for
05:17:48 <ivanm> so does Axman6
05:18:02 <mux> ivanm: does the comparison function involve state?
05:18:13 <ivanm> mux: no
05:18:41 <mux> well there's this funciton of type (a -> a -> Ordering) -> [a] -> a ...
05:19:19 <alise> Can a Data.Generic-y using type thing get the names of the accessors of ADTs?
05:19:42 <ivanm> mux: no, he doesn't know it
05:19:48 <ivanm> stop giving him advanced help! ;-)
05:20:03 <mux> ivanm: ok then, I was curious because I thought you were saying it would be impossible to use it :-P
05:26:48 <roconnor> @src splitAt
05:26:49 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:32:47 <Baughn> ..if I have to write "liftM6 Foo get get get get get get" /one more time/...
05:35:05 * Jafet plays the Zelda sound motif
05:36:39 <Phyx-> Jafet: aww man, now it's stuck in my head :|
05:36:41 <ivanm> Baughn: lol
05:37:05 <Jafet> Sorry, I was playing it for Baughn.
05:37:20 <Baughn> Jafet: I'll stick to "Bless the little queen". :P
05:38:22 * ivanm sticks to Божественна Тромпіта
05:38:28 <Jafet> lift, or: how I stopped worrying and learned to love monad transformer stacks
05:38:58 <ivanm> Baughn: you could always use repeated ap's rather than liftM6...
05:39:07 <Peaker> Baughn, TH
05:39:13 <Baughn> ivanm: That would be even more code.
05:39:24 <Baughn> Peaker: True. I could (and do) use that.
05:39:26 <Peaker> Baughn, what about "deriving Binary"?
05:39:33 <ivanm> Baughn: I didn't say I was actually recommending it...
05:40:30 <Jafet> ivanm, hah
05:40:30 <Baughn> Peaker: It would be nice if we had some TH way to register new derive mechanisms
05:40:42 <roconnor> > scanl1 (+) [a,b,c]
05:40:43 <lambdabot>   [a,a + b,a + b + c]
05:40:54 <roconnor> > scanl (+) 0 [a,b,c]
05:40:56 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
05:42:13 <Peaker> Baughn, I'd like it if TH was capable of creating new syntax that didn't look so foreign and hacky
05:42:53 <Baughn> Peaker: I'd love it if TH had a way to separate the namespaces of code you call and the module you call it from
05:43:05 <Baughn> Let's admit it: Template haskell is an ugly hack.
05:54:50 <Rectal> If I am not supposed to treat element of the list seperately, is that mean I am supposed to use let or do let?
05:55:16 <ivanm> Rectal: treat elements of the list seperately
05:55:34 <ivanm> you want some function [(Coord, [Coord], Board)] -> Coord or something
05:55:40 <Rectal> Oh okay
05:55:43 <Rectal> You confused me
05:55:54 <Rectal> [22:13] <ivanm> Rectal: don't [22:13] <ivanm> Rectal: treat each element of the list seperately
05:55:54 <ivanm> though I think that's not quite right either; there should be no reason to pass [Coord] around, etc.
05:56:11 <ivanm> Rectal: the "don't" was to what you _were_ doing ;-)
05:56:12 <roconnor> > iterate (f . f) x
05:56:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:56:13 <lambdabot>    `SimpleReflect.FromExpr ...
05:56:17 <Rectal> Oh right, sorry
05:56:21 <roconnor> > iterate (f . f) x :: [Expr]
05:56:22 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:56:22 <lambdabot>    `SimpleReflect.FromExpr ...
05:56:28 <roconnor> > iterate (f . f) 0
05:56:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:56:29 <lambdabot>    `GHC.Show.Show a'
05:56:29 <lambdabot>      a...
05:57:24 <ivanm> > iterate ((f . f) :: (Expr -> Expr)) x :: [Expr]
05:57:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:57:24 <lambdabot>    `GHC.Show.Show a'
05:57:24 <lambdabot>      a...
05:57:24 <ivanm> @type a
05:57:24 <lambdabot> Expr
05:57:24 <ivanm> @type x
05:57:24 <lambdabot> Expr
05:57:24 <ivanm> @type f
05:57:24 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:57:24 <ivanm> roconnor: ^^ there's your problem by the looks of things...
05:57:24 <Rectal> But to update the State I need to get the board, do I recreate the board by adding the new Coord, or just grab the coord from the function validMoves?
05:57:29 <roconnor> > f 0
05:57:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:57:30 <lambdabot>    `SimpleReflect.FromExpr ...
05:57:59 <ivanm> Rectal: get the result of validMoves, and just pass around the current board
05:58:00 <ivanm> I _think_ that's all you have to do
05:58:06 <roconnor> @type (f x)
05:58:06 <ivanm> where is that three-tuple coming from?
05:58:07 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
05:58:17 <ivanm> @type g
05:58:17 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:58:19 <ivanm> > f x
05:58:20 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:58:20 <lambdabot>    `GHC.Show.Show a'
05:58:20 <lambdabot>      a...
05:58:29 <ivanm> > f x :: Expr
05:58:29 <lambdabot>   f x
05:58:35 <Rectal> validMoves :: Stone        -- stone of active player            -> Board        -- game board            -> [(Coord,     --  coord of new stone,                 [Coord],   --  stones captured including new stone,                 Board ) ]  --  new game board
05:58:36 <ivanm> > iterate ((f . f) :: (Expr -> Expr)) (x :: Expr) :: [Expr]
05:58:37 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:58:37 <lambdabot>    `GHC.Show.Show a'
05:58:37 <lambdabot>      a...
05:59:18 <ivanm> Rectal: gah!
05:59:18 <ivanm> Rectal: oh, validMoves returns that? I thought it just returned [Coord]
05:59:18 <ivanm> Rectal: OK, you have a list of three-tuples; just go through that
06:04:17 * hackagebot hexpat 0.15.1 - wrapper for expat, the fast XML parser  http://hackage.haskell.org/package/hexpat-0.15.1 (StephenBlackheath)
06:04:18 <Rectal> How do I do that though? If [(2),[2,3,4],4)] I tried maybe (x:xs, y:ys, z:zs) or (x,y,z):(xs,ys,zs) I don't know how to recur that sort of data
06:04:18 <Rectal> [(2,[2,3,4],3)]
06:04:18 <hpc> what do you want to match?
06:04:20 <hpc> you can get the head of the outer and inner lists by matching against (x, (y:ys), z):tuples
06:04:34 <Jafet> I am thinking about 2-3-4 trees for some reason
06:04:47 <Jafet> Or maybe heaps
06:05:11 <Rectal> if it was [(x, [y], z)] I wanted to get the maximum length of [y] and then compare that to length of the current y, and then output the z
06:05:24 <ivanm> Rectal: ((c,ss,b):mvs)
06:05:32 <ivanm> note that it is a list of 3-tuples
06:06:13 <ivanm> and you _dont'_ need to split apart the inner list
06:12:40 <illissius`> haskell has the crypticest compiler errors ever: http://haskell.pastebin.com/cWj5TDRK
06:13:03 <illissius`> what it's saying seems to imply that i've made Integer an instance of NumVal, which I haven't, and otherwise I can't make sense of it -- can anyone help?
06:13:53 <Saizan> illissius`: contexts are not taken in consideration when checking which instance matches
06:14:07 <Saizan> they are only added as additional constraints later
06:14:31 <Saizan> so that error doesn't imply NumVal Integer
06:15:06 <roconnor> @type State
06:15:08 <lambdabot> forall s a. (s -> (a, s)) -> State s a
06:15:10 <Saizan> IOW:  write two Show instances instead of the (NumVal n) => Show n  one
06:15:21 <illissius`> hmm. so is the problem that I'm trying to use 'one' show within the 'other' show?
06:15:56 <illissius`> ok, I'll try that then :)
06:16:02 <fax> happy haskell day!
06:16:19 <Rectal> If I am supposed to be using notation such as ((c,ss,b):mvs, and to caluclate the score of the moves by adding up all the values within the SS, how do I compare it to the maximum value attainable inside all of the list?
06:16:24 <Rectal> Such as CurrentScore = length ss
06:16:41 <roconnor> @type evalState
06:16:43 <lambdabot> forall s a. State s a -> s -> a
06:16:43 <Rectal> BestScore = maximum ( map length mvs))
06:17:37 <ivanm> Rectal: don't use maximum
06:17:42 <Saizan> illissius`: the problem is that "instance (NumVal n) => Show n where" means "use this instance for all the types, oh and check that they are also instance of NumVal", while you think it means "if a type is an instance of NumVal then use this instance"
06:18:02 <ivanm> since it will result in you effectively going through the list twice
06:18:37 <ivanm> Rectal: so, recurse and have it return the move with the maximum score in mvs, and see if the current move has the same or bigger score
06:18:38 <dpratt71> trying to install happstack on Windows (bad idea?); get an error installing "strict-concurrency-0.2.3": "Could not find module `Control.OldException'"
06:18:58 <illissius`> Saizan: yeah, i think i get it. also, it works. thanks!
06:19:02 <ivanm> dpratt71: which version of GHC?
06:19:55 <dpratt71> ivanm:  what's the easiest way to tell?
06:20:07 <Saizan> dpratt71: ghc -V
06:20:24 <roconnor> > divMod 7 3
06:20:25 <lambdabot>   (2,1)
06:20:27 <dpratt71> 6.10.4
06:20:36 <Saizan> dpratt71: also, tell us "cabal --version", i think you've to install a newer version of cabal-install
06:20:59 <dpratt71> cabal-install version 0.6.2
06:21:00 <dpratt71> using version 1.6.0.3 of the Cabal library
06:21:09 <Rectal> Sorry Ivanm, I am terrible with these concepts of recursive. I know the basics, addOne (x:xs) = 1 + addOne xs addOne [] = 0
06:21:25 <ivanm> yeah, looks like it doesn't specify which version of base it wants whereas it actually wants base-4
06:21:35 <Saizan> dpratt71: eh, yeah, run cabal install "cabal-install >= 0.8"
06:21:52 <ivanm> Rectal: right, the point here is that addOne calls itself on a sub-part of the data structure that gets passed in
06:21:59 <fryguybob> I had an idea for something interesting, perhaps someone has already done it: make something hoogle like that can list "one-liners" that can perform some operation on strings within a specific type.
06:22:04 <ivanm> Saizan: do you need the constraint?
06:22:05 <Saizan> dpratt71: then retry with happstack, strict-concurrency should build
06:22:05 <dpratt71> Saizan: ok, thanks
06:22:29 <Saizan> ivanm: i think the preferred one is still some 0.6.x, it doesn't hurt anyhow
06:22:32 <fryguybob> So for instance you could give it "aaabbc" -> "abc" as input and it would spit out > nub
06:22:41 <ivanm> Saizan: "cabal install cabal-install" will get the newest one
06:23:05 <ivanm> fryguybob: sounds too complicated
06:23:06 <Rectal> Can you have guards on where statements?
06:23:10 <ivanm> yes
06:23:13 <Rectal> Okay
06:23:15 <Rectal> That helps
06:23:15 <Saizan> ivanm: ok, the preference must have been removed
06:23:16 <Rectal> I think
06:23:17 <ivanm> Rectal: but you shouldn't need to
06:23:45 <ivanm> Saizan: hmmm? the only constraint cabal-install had was to default to base-3 if unspecified
06:23:47 <fryguybob> ivanm: how so?
06:24:06 <ivanm> fryguybob: it has to try every possible function for every type that looks like that to try and work out which you want
06:24:19 <Saizan> ivanm: do you know of the preferences mechanism? the one that e.g. makes it pick parsec-2 instead of parsec-3 ?
06:24:19 <ivanm> note also that it might not be just the one function: you might need a composition of functions
06:24:20 <Peaker> > (`map` [4,5]) $ \i -> case i of (x:y:xs) | x < 5 -> x | x >= 5 -> y
06:24:21 <lambdabot>   No instance for (GHC.Num.Num [b])
06:24:21 <lambdabot>    arising from a use of `e_14555' at <in...
06:24:35 <Peaker> > (`map` [[4,5], [5,7]]) $ \i -> case i of (x:y:xs) | x < 5 -> x | x >= 5 -> y
06:24:36 <lambdabot>   [4,7]
06:24:42 <ivanm> e.g. : "cccbba" -> "abc"; which function returns that?
06:24:45 <Rectal> Ivam, can I pastebucket my code,a nd you tell me which parts need changing?
06:24:54 <ivanm> Rectal: I can have a look, yes
06:25:00 <ivanm> Saizan: oh, it still defaults to parsec-3?
06:25:01 <fryguybob> ivanm: Oh, it would only look at a subset of reasonable ones, like some of the combinations that fit the type.
06:25:04 <ivanm> s/3/2/?
06:25:05 <fax> :t (>>= replicateM ?k)
06:25:06 <lambdabot> forall (m :: * -> *) a. (?k::Int, Monad m) => m (m a) -> m [a]
06:25:06 <Peaker> > reverse . nub $ "cccba"
06:25:07 <ivanm> s/?//
06:25:07 <lambdabot>   "abc"
06:25:19 <fax> :t (=<< replicateM ?k)
06:25:20 <lambdabot> forall b (m :: * -> *) a. (?k::Int, Monad m) => (m [a] -> m a -> b) -> m a -> b
06:25:21 <ivanm> Peaker: not what I was aiming at, but OK ;-)
06:25:31 * ivanm meant more the map head . group . sort alternative to nub
06:26:01 <fryguybob> ivanm: Right, so if you had map, head, group, sort, reverse and nub in your search, then it would find that.
06:26:18 <Rectal> http://pastebin.com/FrAnpgBD  doesn't work yet
06:26:23 <Saizan> ivanm: yes
06:26:41 <fryguybob> The output could be sorted by "simplicity".
06:26:51 <ivanm> fryguybob: still quite a few permutations it would have to try
06:27:03 <ivanm> fryguybob: such a thing is probably possible, but IMHO would be too much of a PITA
06:27:17 <ivanm> Rectal: *sigh* nope
06:27:25 <Saizan> ivanm: currently we have "cabal-install < 0.10" until recently we had "cabal-install < 0.8", so if you wanted 0.8.2 you needed to specify >= 0.8
06:27:47 <ivanm> Rectal: recurse first, _then_ compare the recursive result's best score to the current score
06:27:56 <Rectal> okay, I will try taht
06:28:04 <ivanm> Saizan: cabal-install has a constraint on cabal-install? :o
06:28:21 * ivanm thinks that's the third time at least he's said given that advice...
06:28:39 <dpratt71> did "cabal update" and "cabal install cabal-install"; still get the same error on install of "strict-concurrency-0.2.3"
06:28:54 <dpratt71> maybe I need to do some cleanup?
06:29:09 <Saizan> ivanm: open ~/.cabal/packages/hackage.haskell.org/00-index.tar and look in the preferred-versions file.
06:29:11 <ivanm> dpratt71: which version of cabal-install did it build?
06:29:24 <ivanm> Saizan: oh, it was in _hackage_ that the constraint existed
06:29:43 <Saizan> ivanm: that's what i've been saying from the start!
06:29:50 <dpratt71> 0.8.2
06:29:51 <Rectal> How do I tell each one is larger? Compare it to the previous value?
06:29:57 <Saizan> dpratt71: cabal --version ?
06:30:12 <dpratt71> ?!
06:30:13 <lambdabot> Maybe you meant: . ? @ v
06:30:20 <ivanm> Saizan: sorry, I misunderstood you and thought you meant it was within cabal-install that those constraints existed
06:30:26 <dpratt71> still "cabal-install version 0.6.2
06:30:26 <dpratt71> using version 1.6.0.3 of the Cabal library"
06:30:31 <ivanm> dpratt71: you just pre-empted him, that's all ;-)
06:30:33 <Fanael> @dice
06:30:34 <lambdabot> unexpected end of input: expecting number
06:30:35 <dpratt71> ?!
06:30:35 <lambdabot> Maybe you meant: . ? @ v
06:30:37 <ivanm> :o
06:30:38 <Saizan> dpratt71: you've a $PATH problem
06:30:44 <ivanm> Saizan: beat me to it!
06:30:52 <Saizan> err, %Path% in your case :9
06:30:53 <Saizan> :)
06:30:54 <Eelis> on hackage, is there an easy way to see which other packages depend on a given package?
06:31:14 <Peaker> Eelis, there's some rev-dep hackage fork somewhere
06:31:25 <dpratt71> Saizan: ok, how to diagnose/fix?
06:31:30 <Eelis> Peaker: ah, sounds good
06:31:48 <aristid> what's the name of the other haskell book again? you know, there's real world haskell - and an easier book, of which i forgot the name
06:32:02 <hpc> learn you a haskell?
06:32:05 <ivanm> dunno know where cabal-install installs executables on windows...
06:32:06 <Eelis> ah, i found http://hackage.haskell.org/trac/hackage/ticket/576 , a feature request for it
06:32:12 <ivanm> hpc: not a book yet...
06:32:15 <Saizan> dpratt71: well, you've to find where this 0.6.2 version cabal.exe is installed, and remove it, and make sure that the location of where the 0.8.2 just got installed appears in your %Path%
06:32:16 <aristid> hpc: thanks
06:32:27 <ivanm> Eelis: there is a reverse package mirror of hackage by roel...
06:32:32 <ivanm> @google reverse dependency hackage
06:32:32 <Saizan> dpratt71: cabal should have told you where it installed the executable
06:32:33 <lambdabot> No Result Found.
06:32:35 <ivanm> bah
06:32:37 <hpc> ivanm: not a dead-tree book
06:32:43 <ivanm> Eelis: http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
06:32:46 <hpc> but close enough for practical purposes
06:32:50 <Eelis> ivanm: yeah, it's linked to from the page i mentioned
06:32:52 <nagnatron> aristid: functional programming in haskell by hutton?
06:32:54 <ivanm> hpc: well, a tutorial /= book
06:32:57 <ivanm> Eelis: oh
06:33:04 <aristid> nagnatron: no i meant the one by BONUS
06:33:12 <aristid> http://learnyouahaskell.com/
06:33:13 <ivanm> so yeah, LYAH
06:33:17 <aristid> tho it's seemingly not a book
06:33:24 <nagnatron> oh learn you a haskell, it's awesome
06:33:34 * ivanm begs to differ
06:33:38 <regalia> for great good =D
06:34:06 <Peaker> I heard mostly good things about LYAH
06:34:32 <Peaker> yairchu, Why don't you convert your Haskell tutor outline to an actual tutorial?
06:34:59 <yairchu> Peaker: I'm going to tutor a friend first and have more insight about it
06:35:28 <aristid> :D "Note: you can do 5 + 4.0 because 5 is sneaky and can act like an integer or a floating-point number. 4.0 can't act like an integer, so 5 is the one that has to adapt. "
06:35:43 <roconnor> damn you type system, for not catching my error!!!
06:36:55 <ddarius> roconnor: You should go (back) to a dynamically typed language.  Static types don't catch any interesting errors and just keep you from writing the code you want to write and make you have to write boilerplate to appease the type checker.
06:37:02 <roconnor> heh
06:37:15 <Phyx-> wait what?
06:37:16 <roconnor> I was thinking that money and array indexes shouldn't have the same type.
06:37:18 * Phyx- rereads
06:38:13 * roconnor replaces "snd" by "fst" and sees if his program works
06:38:44 <ddarius> itemsCosting!(Dollars 5)
06:39:32 <Jonno_FTW> http://blog.well-typed.com/2010/05/well-typed-are-hiring/
06:39:51 <roconnor> w00t
06:39:53 <roconnor> correct
06:40:31 <dpratt71> what's the story with the "extralibs\bin" folder? should cabal be in there?
06:40:46 <aristid> Jonno_FTW: "GBP per day" :D
06:41:01 <aristid> maybe that's usual but i didn't see salaries per day yet
06:41:05 <Jonno_FTW> great british pounds i assume
06:41:16 <Jonno_FTW> but i only just saw it on the haskell reddit
06:41:25 <aristid> it's the "per day" that seems funny
06:41:38 <ivanm> aristid: because they can't guarantee work
06:45:47 <dpratt71> I removed cabal from "extralibs\bin" and it worked! thanks ivanm, Saizan
06:46:06 <Saizan> np :)
06:47:25 <Peaker> it's not a very high salary..
06:47:32 * ivanm guesses that that's the one installed by the platform
06:47:49 <ivanm> Peaker: if you read the reddit discussion, dcoutts_ says that you're highly likely to get more than that from project commissions
06:47:59 <ivanm> they just can't guarantee work (and hence pay) up-front
06:48:31 * ivanm would consider applying if he wasn't already doing a PhD
06:49:32 <Peaker> ah.. well, I would consider applying if I wasn't deep in a full time job
06:50:23 <roconnor> > 100000000000000000 :: Int
06:50:24 <lambdabot>   100000000000000000
06:50:25 <roconnor> > 100000000000000000 :: Int32
06:50:27 <lambdabot>   1569325056
06:50:32 <roconnor> whew
06:50:40 <fax> > 100000000000000000 == 1569325056
06:50:41 <lambdabot>   False
06:50:59 <roconnor> I had 8 minutes to fix an integer overflow in my google code jam submission
06:50:59 <fryguybob> > Int == Int32
06:51:00 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `Int32'
06:51:13 <Jafet> Should 100000000000000000 be a valid Int32 literal, even?
06:51:15 <roconnor> > typeOf (undefined::Int)
06:51:15 <Fanael> > (100000000000000000 :: Int32) ==1569325056
06:51:16 <lambdabot>   Int
06:51:16 <lambdabot>   True
06:51:31 <roconnor> > typeOf (undefined::Int) == typeOf (undefined::Int64)
06:51:33 <lambdabot>   False
06:51:45 <roconnor> Jafet: sure
06:51:51 <mauke> Jafet: there are no Int32 literals
06:52:07 <Peaker> Overflowing Ints is one of the questionable trade-offs Haskell makes for performance IMO... "Int" should really be used as a performance hack and only where you must
06:52:10 <Jafet> > (fromIntegral 100000000000000000)::Int32
06:52:11 <lambdabot>   1569325056
06:52:15 <roconnor> I managed to fix my bug in 6 minutes
06:52:16 <Jafet> > (fromEnum 100000000000000000)::Int32
06:52:17 <lambdabot>   Couldn't match expected type `GHC.Int.Int32'
06:52:17 <lambdabot>         against inferred type ...
06:52:30 <Jafet> I think it should produce some error, somewhere
06:52:55 <Peaker> How expensive would overflow checking all Int arithmetic be?
06:53:02 <Peaker> Dependent types might improve the situation here, too
06:53:14 <Jafet> I mean just for literals.
06:53:27 <dpratt71> how do I terminate a happstack process?
06:53:31 <fax> I don't think so
06:53:44 <Jafet> For example, if you get type inference to a bounded Int where you expected Integer, this would be a good place to detect it
06:53:50 <Peaker> fax, about DT's?
06:53:56 <fax> yes
06:54:05 <Peaker> fax, Well, consider that you could prove things about the range of the Int
06:54:16 <Peaker> fax, And thus get both performance and safety, rather than choosing
06:55:02 <aristid> hmm #haskell is really _the_ place for haskell programmers
06:55:15 <aristid> everybody is here, it seems
06:55:17 <Jafet> Peaker, you might as well use established tools like coq, then
06:55:19 <ivanm> aristid: well, it makes more sense for us to be here than in say ##java...
06:55:24 <Jafet> And then generate fast haskell
06:55:32 <danharaj> I think in some cases you want overflow behavior, or more commonly, saturated arithmetic is desirable.
06:55:38 <aristid> ivanm: yeah but most, say, java programmers are NOT in ##java
06:55:41 <ivanm> but not everyone is here: not a lot of academics are here for example (AFAIK, anyway)
06:55:45 <Peaker> Jafet, sure, Coq is one DT option
06:55:52 <aristid> but for example the authors of rwh are here
06:55:52 <ivanm> aristid: because there's no real community around java
06:55:55 <Peaker> danharaj, that's the rare case
06:55:56 <aristid> so is the author of lyah
06:56:04 <aristid> and dcoutts_ is here too
06:56:10 <Peaker> danharaj, the more common case is that it is a bug, or that you think it just wouldn't happen
06:56:43 <Peaker> the simons aren't here...
06:56:49 <ivanm> aristid: tbh, they're not here that often nowadays
06:56:51 <danharaj> Peaker: I think it might be one of the harder things to prove that an overflow does not occur, unless you manually check for overflow cases to trivialize it.
06:56:59 <fax> suppose that we had  [-] :: Int32 --> Integer, plus :: Integer --> Integer --> Integer,  and our basic arithmetic operators were typed like   (+) :: forall x y :: Int32, plus [x] [y] <= intMax -> Int32
06:57:06 <Peaker> they have work to do :)
06:57:26 <aristid> ivanm: hmm there nicks are here tho
06:57:34 <aristid> Peaker: work? what's that? ;)
06:57:36 <fax> so that computationally it's the same as C programming, you just add stuff.. but in terms of programming you have to prove operation does not overflow
06:57:45 <ivanm> aristid: yes, but they're not always online/responsive
06:58:01 <ivanm> and bos isn't even idling here atm ;-)
06:58:13 <Peaker> fax, Ok, what about it?
06:58:14 <fax> Peaker: Now can you imagine actually doing that? proving every single use of an arithmetic operator correct
06:58:36 <Peaker> fax, Yeah, with the proper abstraction/tools
06:58:42 <Jafet> One way to check for overflow is to do the calculation and then see if it overflowed -- so really the statement in that case must be not that you didn't overflow, but that you didn't propagate overflowed values
06:58:44 <fax> no there are no tools or abstractions for this
06:58:59 <fax> What you must do is _try this out in practice_
06:59:08 <fax> then it will be clear this is not practical
06:59:14 <Peaker> fax, Before the IO monad, specifying/proving the purity of each computation would seem pretty difficult too
06:59:15 <Jafet> Well, compilers like gcc have trivial heuristics eg. for checking loop ranges
06:59:31 <Peaker> fax, I suppose the majority of programmers would tell you that isn't practical either
06:59:49 <arw> Jafet: checking for overflow is not that easy, if you don't have access to the processors overflow flag.
06:59:52 <fax> Peaker, you cannot just claim some magic solution exists without being able to name it - that is a really unconvincing argument to someone who actually wants to do this stuff
06:59:54 <Peaker> fax, I imagine an IDE where automated theorem provers do most of the work
07:00:01 <arw> Jafet: all the trivial ways to check are prone to errors.
07:00:10 <fax> Peaker, it might convince some kind of idealist that doesn't care about getting actual programs proved correct
07:00:18 <Jafet> arw, if you make some assumptions eg. twos complement
07:01:14 <fax> also consider floating point, it's ever harder than Int32 -- you have to carry around and accumulate error estimates
07:02:10 <fax> It is not really right to just say "dependent types solve this correctness problem" without having applied them to it and finding that they infact do -- I am claiming they will not help one bit
07:02:35 <Jafet> I think Peaker is just ranting that it can -- not that it will
07:02:35 <ddarius> fax: There are lots of tools and abstractions that one can fairly readily point to that would simplify such problems.  It's not just Peaker saying "Oh, some magic tool will do it all for me."  Whether it will be practical with those tools is still an open question.
07:02:57 <Jafet> Er, rambling
07:03:15 <fax> ddarius - like what sort of abstractions are there for this kind of numerics?
07:03:52 <ddarius> fax: If your integer manipulations fall within the subset of Presburger arithmetic in some specific cases, then the computer -can- handle all of that for you (in that case.)
07:04:09 <Jafet> Doubly exponentially.
07:04:44 <ddarius> And of course you can always make weaker functions from that function that let you discharge the proof obligation dynamically.
07:05:32 <roconnor> awww I only needed 33 points to advance past the google code jam qualification round
07:05:42 <roconnor> why did I bother solving all of them?
07:05:49 <ivanm> roconnor: heh, how many did you get?
07:05:53 <ddarius> E.g. I can make a Integer -> Integer -> Maybe Int32.
07:06:24 <fax> oh that's a good point
07:06:30 <roconnor> ivanm: all 3 I believe
07:06:33 <fax> the predicate is decidible
07:06:38 <fax> decidable
07:06:41 <ivanm> roconnor: points I mean
07:06:43 <Peaker> fax, I am not as optmistic about floating point -- I think their semantics are so complicated that proving anything about their correctness is not clear to me as a possibility.. But making sure ints fit within their bounds sounds plausibly possible with automated theorem provers
07:06:45 <roconnor> 99 points
07:06:47 * ivanm has no idea what you're asked to do
07:07:24 <fax> Peaker - well it does not hold as much weight as if you have actually put it into practice for a real program
07:07:36 <Peaker> fax, It does not hold as much weight as a proof, I agree
07:07:51 <fax> (you should prove me wrong by doing this :))
07:08:05 <Peaker> fax, that's why I originally said "DT's might improve ..."
07:08:19 <Peaker> I didn't say they will ...
07:08:43 <fax> oh so you don't realyl think they are a practical solution for this?
07:09:23 <Peaker> fax, I think that if they aren't already, they will be, but I admit there is a possibility it will never be practical
07:09:34 <fax> hrrm
07:10:02 <Peaker> and that I am not knowledgable enough to analyze the situation too deeply.. I do prefer optimism over pessimism over the possibilities in the unknown, too
07:10:23 <fax> yeah. I am not too keen on optimism
07:11:36 <Peaker> fax, heh, why? An optimistic researcher will probably get much futher towards solution than the pessimistic one
07:12:09 <fax> Peaker, well it is optimistic who says "oh this will be fine" when it has a chance of breaking
07:12:25 <Saizan> ?hackage k-d-map
07:12:25 <lambdabot> http://hackage.haskell.org/package/k-d-map
07:12:41 <Jafet> @hackage it works now?
07:12:41 <lambdabot> http://hackage.haskell.org/package/it works now?
07:13:19 <fax> roconnor these code jam problems don't sound very fun :/
07:13:26 <fax> Infact I cannot even understand what this snapper is about
07:15:54 <Peaker> fax, Also the optimistic who says "DT solved the problem of array indexing safety, list length verification, and more, it will probably solve the issue of integer bounds, as programmers generally are capable of proving to themselves that their integers are within the bounds"
07:16:18 <aristid> Char supports UTF-32?
07:16:22 <fax> yes but you do not put your claim into practice -_-
07:16:37 <Jafet> The encoding of Char is unspecified, but it does Unicode since ghc 6.12
07:16:46 <mauke> Char has always been unicode
07:16:54 <mauke> it has no encoding
07:16:55 <Peaker> fax, Too much things to do, too little time/energy
07:16:58 <aristid> Jafet: 6.12 only?
07:17:09 <Peaker> mauke, except the hidden representation
07:17:13 <Jafet> I heard something got improved from 6.12
07:17:17 <Saizan> what changed in 6.12 is how the System.IO primitive works
07:17:23 <Jafet> I see.
07:17:28 <mauke> Peaker: what hidden representation?
07:17:38 <aristid> on 6.10: Prelude> maxBound :: Char    '\1114111'
07:17:48 <Saizan> gah, *primitives work
07:17:50 <Peaker> mauke, "Char" is represented somehow...
07:18:01 <mauke> Peaker: [citation needed]
07:18:01 <Saizan> aristid: Char has always been able to represent the whole of unicode
07:18:38 <aristid> Saizan: many languages have huge problems with non-BMP characters
07:18:45 <Jafet> And then there is ByteString
07:19:07 <Axman6> aristid: non BMP? as in bitmap?
07:19:08 <Peaker> mauke, All data types have a reprsentation, abstract (hidden) or not..
07:19:15 <Saizan> aristid: though before 6.12 if you do e.g. readFile you'll get a [Char] with just the octects
07:19:34 <Saizan> aristid: since 6.12 it'll do decoding according to your locale for you
07:19:48 <mauke> Axman6: no
07:19:53 <Peaker> Using [Char] for a bytestring makes little sense indeed...
07:20:05 <aristid> Saizan: oh, that's an important change.
07:20:16 <aristid> Axman6: BMP as in Base Multilingual Plane
07:20:24 <Axman6> righto
07:20:30 <aristid> Axman6: BMP = the first 65536 unicode characters
07:20:49 <Zao> Plane 0.
07:21:38 <Zao> Char represents any code point of the 17 planes.
07:22:07 <Peaker> Which plane to "control code points" belong in? (Reversing direction, etc)
07:22:15 <aristid> hmm ByteString support for UTF-32 would be cool
07:22:17 <Peaker> s/to/do
07:22:35 <Zao> Peaker: They're in the BMP I believe.
07:22:44 <Peaker> aristid, I'd expect any Unicode encoding support from Bytestringto just be conversions to/from String
07:22:45 <Zao> http://www.fileformat.info/info/unicode/block/index.htm
07:22:47 <Jafet> aristid, eh? ByteString is a byte string.
07:22:56 <Twey> aristid: It has no encoding.
07:22:57 <aristid> Jafet: so?
07:23:05 <Twey> It's just a string… of bytes.
07:23:09 <aristid> Twey: Data.ByteString.Word8 disagrees
07:23:09 <Jafet> The encoding is orthogonal.
07:23:11 <Twey> Encoding comes later.
07:23:22 <Twey> aristid: How so?
07:23:28 <mauke> aristid: did you mean: Char8
07:23:30 <Saizan> *Char8 ?
07:23:33 <Zao> Peaker: http://www.fileformat.info/info/unicode/char/202e/index.htm
07:23:36 <aristid> mauke: yeah
07:23:43 <aristid> Data.ByteString.Char8 uses latin1
07:23:53 <aristid> implicitly
07:23:56 <mauke> right
07:24:06 <Saizan> aristid: anyhow if you want something with a representation similar to bytestring but that supports more encoding out of the box there's text
07:24:10 <aristid> "More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls. "
07:24:13 <Twey> Convenience functions to allow you to treat bytes as characters without doing any recoding
07:24:17 <Zao> The documentation of Char8 explicitly states that it's an oddball.
07:24:34 <Saizan> @hackage text
07:24:34 <lambdabot> http://hackage.haskell.org/package/text
07:24:47 <Twey> The ‘encoding’ chosen is just for convenience in that it's what you get if you do no transcoding at all
07:25:01 <Twey> And just interpret them directly as Unicode codepoints
07:25:18 <aristid> yeah :)
07:25:51 <rajrn> hello all
07:25:55 <Twey> Hi
07:26:01 <rajrn> Hello Twey
07:26:40 <rajrn> I have a kind of an OT question.
07:27:10 <Twey> Then why did you join this channel to ask it?
07:27:11 <rajrn> http://book.realworldhaskell.org/read/getting-started.html (How do I create a webpage like this ? ) I was looking at the book and was working on something similar which will be available for free
07:27:16 <Twey> Ah
07:27:18 <Twey> I see
07:27:46 <rajrn> well it is tangentially related to haskell as I was inspired by the webpage
07:28:01 <rajrn> and I want to create something under the CC license ...
07:28:04 <Twey> dons or bos might know
07:28:27 <rajrn> I think I mailed bos but got no reply from him ...
07:28:29 <Twey> I suspect it may be happstack-based
07:29:00 <rajrn> Twey: em happstack-based ? what is that ?
07:30:07 <rajrn> interesting
07:30:16 <Twey> rajrn: happstack is the primary Web framework for Haskell, among other things.
07:30:36 <rajrn> So he wrote the webpage in Haskell ? cool
07:31:13 <Fanael> I've seen webpage written in brainfuck, so why not Haskell?
07:31:14 <Twey> I don't know for sure.  It just seems likely.
07:32:12 <rajeshsr> hi
07:32:20 <rajeshsr> can anyone help me with this error?
07:32:22 <rajeshsr> Couldn't match expected type `String'
07:32:24 <rajeshsr>            against inferred type `[b] -> [Int]'
07:32:26 <rajeshsr>     In the first argument of `putStrLn', namely
07:32:28 <rajeshsr>         `(getAns (map read (words line) :: [Int]))'
07:32:56 <rajrn> rajeshsr: I think you are expected to use the pastebin
07:33:10 <rajrn> hpaste.org
07:33:28 <rajeshsr> rajrn, hmm, ok! anyway, that is just 4 lines, thats the reason i didn't!
07:34:26 <mauke> rajeshsr: what's the type of getAns?
07:34:53 <rajeshsr> mauke, ha, yeah!! that is the error, i guess! It has type [Int]
07:35:01 <mauke> no, it doesn't
07:35:05 <mauke> rajeshsr: what's the type of getAns?
07:36:50 <rajeshsr> mauke, yes, getAns type is not String. It returns [Int].
07:36:56 <mauke> dude
07:37:00 <mauke> what is the type of getAns?
07:37:19 <Fanael> @type replicate
07:37:20 <lambdabot> forall a. Int -> a -> [a]
07:37:44 <Twey> rajeshsr: Usual IRC etiquette is that pastes of about three lines or more should go in a pastebin.
07:38:20 <kpreid> better solution: delete the line breaks
07:38:20 <rajeshsr> mauke, i don't get what you mean? [Int] -> [Int] is the getAns type.
07:38:28 <mauke> ah
07:38:52 <mauke> no, that also looks wrong
07:38:58 <mauke> it doesn't match your error message
07:39:28 <rajeshsr> getAns ([n, k]) =  foldl (\a b -> 2*a + 1) [0..n]
07:39:53 <mauke> :t \[n, k] -> foldl (\a b -> 2*a + 1) [0..n]
07:39:54 <lambdabot> forall b t. (Num [t], Num t, Enum t) => [t] -> [b] -> [t]
07:39:59 <mauke> that's the type of getAns
07:40:17 <rajeshsr> mauke, uh!! ok! :)
07:40:39 <mauke> or [Int] -> [Int] -> [Int]
07:40:59 <mauke> no, wait
07:41:09 <mauke> there's a Num [t] constraint here
07:41:14 <Twey> Where does ‘Num [t]’ come from?
07:41:15 <mauke> this function can't work
07:41:34 <mauke> Twey: trying to multiply [0..n] by 2
07:41:48 <Twey> foldl doesn't get the whole list passed to it, does it?
07:41:54 <Twey> :t foldl
07:41:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:42:16 <Twey> Oh
07:42:17 <Twey> That's the zero
07:42:23 <Twey> Okay
07:42:30 <Twey> Silly me
07:42:50 <Absolute0> Do I have an indent error on line 4? http://codepad.org/CUA7OLgK
07:43:13 <Twey> Absolute0: Yes
07:43:32 <Twey> ‘b’ needs to be indented less than or equal to ‘a’
07:43:33 <Absolute0> i am using notepad ++
07:43:36 <Absolute0> looks right in there
07:43:41 <Absolute0> :(
07:43:43 <Twey> You're using tabs
07:43:46 <Twey> Stop it
07:43:48 <Absolute0> right
07:43:59 <Twey> Have your editor convert tabs to spaces when you save
07:44:01 <Fanael> Tabs will eat your cat.
07:44:27 <Absolute0> ah sweet relief
07:44:28 <Absolute0> :)
07:44:57 <rajeshsr> mauke, ha, i missed the initialization!! So poor in haskell! :(
07:45:00 <arw> or have your editor mark spaces for indentation in red.
07:45:12 <Absolute0> I am trying to do the second problem on project euler, the canonical 0 :1 :zipWith (+) fibs (tail fibs) goes on forever :(
07:45:21 <Twey> You can also have your editor display tabs as eight-space monsters, as that's how GHC sees them.
07:45:26 <Twey> I advise against it, however.
07:45:35 <Twey> Of course it does
07:45:39 <Twey> It's an infinite list
07:45:44 <Twey> The Fibonacci sequence doesn't terminate
07:45:51 <Twey> You just need to use ‘take’ to get however many you need
07:46:03 <xerox> lol.
07:46:43 <Absolute0> Twey, I was trying to reach 4 * 10^6 in the fib sequence
07:46:50 <Absolute0> and that takes forever with the recursive method
07:47:09 <Absolute0> the one i gave above
07:47:20 <Twey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ takeWhile (< 4e6) fibs
07:47:21 <lambdabot>   9227464.0
07:47:28 <Twey> That was a very short forever ;)
07:48:15 <Absolute0> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum [x| x<-fibs, x `mod` 2 == 0, x < 4e6]
07:48:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:48:17 <lambdabot>    `GHC.Real.Integral a'
07:48:17 <lambdabot>   ...
07:48:30 <Twey> Absolute0: That will go forever.
07:48:52 <Absolute0> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum [x| x<-fibs, x `mod` 2 == 0, x < 4000000]
07:48:55 <Absolute0> there :)
07:48:56 <lambdabot>   mueval-core: Time limit exceeded
07:49:06 <Twey> Commas in list comprehensions just filter, they don't tell the list comprehension to stop
07:49:15 <Absolute0> ah
07:49:15 <Fanael> > 2 + 2 * 2 + undefined
07:49:17 <lambdabot>   *Exception: Prelude.undefined
07:49:30 <Absolute0> so how do i stop at 4e6?
07:49:41 <Twey> Once it hits 4ᴇ6 it will continue testing every further element for being less than 4ᴇ6 and discarding them all
07:49:48 <Twey> Use ‘takeWhile’ as I did above
07:49:49 <Fanael> takeWhile, maybe?
07:49:52 <Absolute0> ah
07:50:06 <Twey> List comprehensions don't provide a mechanism for stopping, because that's not their purpose
07:50:26 <Absolute0> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ takeWhile (<4000000) [x| x<-fibs, x `mod` 2 == 0]
07:50:27 <lambdabot>   4613732
07:50:30 <Absolute0> ah :)
07:50:48 <Absolute0> so that fib implementation is effecient i guess?
07:50:53 <Fanael> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ takeWhile (<4000000) [x| x<-fibs, x `mod` 2 == 0]
07:50:53 <Twey> I'd probably put the takeWhile inside the comprehension, but that doesn't make a huge difference here
07:50:55 <Absolute0> is lambdabot just that fast?
07:51:02 <Twey> About as efficient as you can get, yeah
07:51:06 <Twey> \b is horribly slow
07:51:11 <Saizan> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ [x | x <- takeWhile (< 4e6) fibs, x `mod` 2 == 0]
07:51:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:51:12 <lambdabot>    `GHC.Real.Fractional a'
07:51:12 <lambdabot> ...
07:51:21 <Twey> Though she does seem to be in top form today
07:51:51 <Fanael> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum $ takeWhile (<4000000) (fibs >>= \x -> if x `mod` 2 == 0 then return x else [])
07:51:52 <lambdabot>   4613732
07:51:54 <Absolute0> there I went thinking the fib implementation is slow, I clearly need to brush up in haskell :)
07:52:29 <Twey> @let (y ?? n) p = if p then y else n
07:52:30 <lambdabot>  Defined.
07:53:25 <Absolute0> Fanael, can you explain that functor usage?
07:53:44 <Twey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . takeWhile (< 4e6) $ fibs >>= join ((return ?? const []) . flip mod 2)
07:53:45 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
07:53:46 <lambdabot>    arising from a use of ...
07:53:49 <Twey> Oof ☹
07:54:02 <Twey> Oh, d'oh
07:54:08 <Twey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . takeWhile (< 4e6) $ fibs >>= join ((return ?? const []) . (== 0) . flip mod 2)
07:54:09 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:54:09 <lambdabot>    `GHC.Real.Fractional a'
07:54:09 <lambdabot> ...
07:54:15 <Absolute0> what does >>= do between a list and a lamda?
07:54:16 <Twey> Aw, never mind :þ
07:54:30 <Fanael> @type (>>=)
07:54:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:54:31 <Twey> Absolute0: It's a monad, not a functor.  If you're new to Haskell, you probably shouldn't worry about it just yet.
07:55:02 <Absolute0> :t (return 5)
07:55:03 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
07:55:08 <Absolute0> hmm :)
07:55:27 <Absolute0> at one point i was starting to understand monads
07:55:31 <Absolute0> not sure why i gave up
07:55:32 <Fanael> :t (flip concatMap)
07:55:33 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
07:56:02 <Absolute0> so what is the >>= operator doing in the example above?
07:56:02 <EvanR> in order to understand monads you must first understand burritos
07:56:33 <Twey> Absolute0: As Fanael implied, (>>=) on lists is just concatMap with the arguments reversed.
07:57:06 <Twey> concatMap = (concat .) . map: that is, it maps the specified function (which must return a list) over the list, then concatenates the results.
07:57:13 <Absolute0> concatMap (+1) [0..9]
07:57:17 <Absolute0> > concatMap (+1) [0..9]
07:57:18 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
07:57:18 <lambdabot>    arising from a use...
07:57:21 <Twey> > map (* 2) [0 .. 9]
07:57:22 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
07:57:32 <Absolute0> > concatMap (* 1) [0..9]
07:57:33 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
07:57:33 <lambdabot>    arising from a use...
07:57:37 <Twey> > map (\x -> [x, x * 2]) [0 .. 9]
07:57:38 <lambdabot>   [[0,0],[1,2],[2,4],[3,6],[4,8],[5,10],[6,12],[7,14],[8,16],[9,18]]
07:57:42 <Twey> > concat $ map (\x -> [x, x * 2]) [0 .. 9]
07:57:43 <lambdabot>   [0,0,1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18]
07:57:49 <Twey> > concatMap (\x -> [x, x * 2]) [0 .. 9]
07:57:50 <akosch> One of my friends asked: "How can I benefit from learning Haskell?". He already knows C, C++, Python. What should I tell him?
07:57:51 <lambdabot>   [0,0,1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18]
07:58:06 <danharaj> Haskell is different from all of those.
07:58:07 <Twey> akosch: http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
07:58:08 <Absolute0> akosch, "Get a girl friend
07:58:09 <Absolute0> "
07:58:16 <EvanR> akosch: to make your brain explode
07:58:30 <Absolute0> :t concatMap
07:58:31 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:58:35 <Twey> > [0 .. 9] >>= \x -> [x, x * 2]
07:58:36 <lambdabot>   [0,0,1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18]
07:58:59 <akosch> well, thanks ;)
08:00:14 <Absolute0> The various methods of performing a task in haskell can get annoying for perfectionists. :)
08:00:33 <fax> yeah lol
08:00:34 <Phyx-> that's true for every language isn't it
08:00:36 <Jafet> That's why perfectionists use python
08:00:42 <fax> being a perfectionist is a blessing and a curse
08:01:12 <Absolute0> Phyx-, the flexibility provided with haskell just makes it worse
08:02:02 <Twey> Perfectionism puts its own limit on that once you get used to it.
08:02:09 <arw> perfectionists use assembler. the compiler never gets it right.
08:02:24 <EvanR> im finding you have to be very disciplined to do it right in haskell, its not like you can throw random loops and variables at the problem
08:02:30 <rajeshsr> print function prints a newline in the end. What to do if i don't want it to print newline?
08:02:36 <Zao> putStr.
08:02:45 <Zao> putStr . show, that is.
08:02:56 <Zao> @src print
08:02:56 <lambdabot> print x = putStrLn (show x)
08:03:00 <rajeshsr> Zao, oh, ok, thanks!
08:08:29 <Fanael> IO monad haunts me, what shall I do?
08:08:47 <Zao> Hug it.
08:08:50 <EvanR> who you gonna call
08:09:17 <Zao> Oleg.
08:09:36 <rajeshsr> :t print
08:09:37 <lambdabot> forall a. (Show a) => a -> IO ()
08:10:29 <Fanael> But I don't want to hug, well, a monad. Any other ideas?
08:10:46 <Jafet> Not even lists?
08:11:01 <Jafet> You could also hug arrows, but that sounds somewhat dirty.
08:11:10 <koala_man> that's why you should call them warm, fuzzy things. much more huggable
08:11:18 <Zao> Go functor yourself!
08:11:35 <Fanael> That sounds awfully.
08:12:00 <Zao> It might not be too applicative to the current conversation.
08:12:37 <Jafet> These jokes are getting a bit derivative
08:13:33 <Zao> We need a newtype of jokes.
08:13:36 <Zao> Something suitable forall.
08:13:43 <EvanR> o_O
08:14:09 <Zao> I'd better stop before someone kicks my _|_.
08:14:15 <fax> lol
08:14:18 <Fanael> :D
08:14:42 <fax> I cat stand all this nonsense
08:15:17 <xerox> I hand stand all this nonsense
08:17:08 <JoeyA> If I have let f x y = (x,y)  , why aren't these the same?
08:17:09 <JoeyA> fst (f 1 2)
08:17:14 <JoeyA> fst . f $ 1 2
08:17:27 <xerox> because f takes two arguments
08:17:53 <xerox> > let (.:) = (.).(.); f x y = (x,y) in (fst .: f) 1 2
08:17:54 <lambdabot>   1
08:19:07 <fax> :t let (.:) = (.).(.); f x y = (x,y) in (fst .: f)
08:19:08 <lambdabot> forall a b. a -> b -> a
08:19:11 <Saizan> JoeyA: fst . f $ 1 2 = (fst . f) (1 2)
08:19:38 <xerox> while you want (fst .) . f instead
08:20:13 <Zao> @type (\x y -> 'a' , \(x,y) -> 'a')
08:20:15 <lambdabot> forall t t1 t2 t3. (t -> t1 -> Char, (t2, t3) -> Char)
08:20:27 <Saizan> you want (((fst .) . f) 1) 2, btw
08:20:38 <xerox> \f g -> (f .) . g = \f g -> (.) (f .) g = \f g -> (.) ((.) f) g = \f -> (.) ((.) f) = \f -> ((.) . (.)) f = (.) . (.)
08:20:42 <Zao> Saizan: Starting to sound a bit pointless.
08:21:16 <EvanR> why is it called pointless form if its mostly periods
08:21:46 <Saizan> = ((fst .) . f) 1 2  -- less explicit, more readable
08:21:52 <Fanael> It's called pointless because it's, well, pointless.
08:22:22 <Zao> http://www.haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21
08:22:23 <Saizan> it's called pointfree because the original notation for lambdas used dots
08:22:43 <aristid> silver: is (fst .) . f really the most readable version? ;)
08:22:54 <Zao> aristid: Seems to be write-only to me.
08:23:01 <Saizan> ah, it's from topology? that also makes sense
08:23:03 <aristid> Saizan: wow that's a nice bit of knowledge
08:23:16 <aristid> oh
08:23:33 <JoeyA> I think Saizan meant compared to the one with more parens
08:23:38 <aristid> Saizan: is your explanation a lie?
08:23:44 <JoeyA> fst (f 1 2) is more readable to me
08:24:13 <JoeyA> but I didn't know why I couldn't compose them like normal functions and say fst . f $ 1 2
08:24:46 <aristid> :t (->)
08:24:47 <lambdabot> parse error on input `->'
08:24:54 <aristid> :t (->) Int
08:24:55 <lambdabot> parse error on input `->'
08:24:59 <rajeshsr> I got an error like this: /tmp/runghcXXXX5487.hs:1:0:
08:24:59 <EvanR> thats (fst . f) 1 2?
08:25:00 <rajeshsr>     No instance for (Num
08:25:00 <rajeshsr>                        (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]))
08:25:00 <rajeshsr>       arising from the literal `10000' at /tmp/runghcXXXX5487.hs:1:0-4
08:25:01 <aristid> oh wait, it's a type already
08:25:10 <rajeshsr> when i ran runhaskell a.hs
08:25:17 <rajeshsr> any idea of what is happening?!
08:25:44 <rajeshsr> the input file had that 10000 as an input! But why does that hurt haskell?!
08:26:07 <aristid> rajeshsr: http://hpaste.org
08:26:21 <JoeyA> EvanR> No, I can't do that because f takes 2 arguments, not 1.  The . operator wasn't as generic as I expected.
08:26:36 <EvanR> JoeyA: i was just trying to desugar it
08:26:44 <EvanR> so to speak
08:26:45 <JoeyA> I was too
08:26:53 <EvanR> so if thats what it is, thats why it doesnt work
08:27:14 <rajeshsr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25385#a25385
08:27:19 <JoeyA> Couldn't match expected type `(a, b)' against inferred type `t1 -> (a1, t1)'  In the second argument of `(.)', namely `f'
08:29:17 <rajeshsr> anyone can help me?
08:29:41 <rajeshsr> aristid, posted at: ^
08:29:50 <Absolute0> Can a factor of a number be more than half of that number? Or is there some better limiting factor regarding maximum factors?
08:30:13 <Jafet> What is a "factor"?
08:30:14 <aristid> rajeshsr: i meant your actual haskell code :)
08:30:19 <Zao> Note that a tuple is not two arguments.
08:30:28 <Zao> It's one argument of N-tuple type.
08:30:39 <Absolute0> Jafet, factors 6 = [3, 2, 1]
08:30:50 <aristid> @src ($!)
08:30:50 <lambdabot> f $! x = x `seq` f x
08:31:00 <Jafet> 6 is also normally considered a factor of 6.
08:31:16 <rajeshsr> aristid, ha, well the code compiles well! But when i run runhaskell it fails! the input file i gave has 10000 as a literal. Assume that it takes the input numbers and prints some result..
08:31:22 <dfkjjkfd> if n = q * b, if b >= 2 , q <= n/2
08:31:28 <Jafet> The next largest factor must be at most 6/2, for obvious reasons.
08:31:51 <aristid> rajeshsr: maybe it compiles but still is broken
08:31:53 <rajeshsr> the thing is i can't paste the code now! This is actually code jam problem, am trying to solve with haskell! :)
08:31:59 <Absolute0> Jafet, thats just for "6", how about N?
08:32:08 <aristid> rajeshsr: then you're screwed :P
08:32:15 <EvanR> N / N = an integer
08:32:17 <Jafet> Absolute0, time to think then
08:32:20 <b0fh_ua> Hello! Doe do I find the cause of the error "*** Exception: Error in array index" if running a function in ghci?
08:32:22 <rajeshsr> aristid, nope i got it accepted with C++! :)
08:32:29 <b0fh_ua> something like stack trace or whatever
08:32:44 <b0fh_ua> *How
08:32:55 <rajeshsr> i coded it all in haskell and C++, and want to submit in haskell this time! I failed! :(
08:32:55 <rickythesk8r> Absolue0: aren't the first two prime number 2 and 3?
08:33:15 <rajeshsr> aristid,  may be for the large test case i should submit with haskell!
08:33:21 <Zao> b0fh_ua: Isn't there some kind of debugger you can use?
08:33:58 <aristid> rajeshsr: *shrug*
08:34:15 <Jafet> ghci includes debugging features, there is a whole manual out there
08:34:25 <b0fh_ua> Zao: I'm new to haskell, and I have know almst nothing about debugging. But at least some sort of information of where exactly the error occur would be helpful at first time.
08:34:38 <Jafet> @quote oasis
08:34:38 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:34:46 <b0fh_ua> :t fix
08:34:47 <lambdabot> forall a. (a -> a) -> a
08:34:53 <b0fh_ua> hm
08:35:10 <aristid> :t (x .) . y
08:35:11 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
08:35:11 <lambdabot>     In the first argument of `(.)', namely `x'
08:35:11 <lambdabot>     In the first argument of `(.)', namely `(x .)'
08:35:15 <Entroacceptor> how does the trace work?
08:35:24 <fax> http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470848820.html?0470848820=
08:35:27 <fax> anyone know this book?
08:35:28 <aristid> :t (id .) . id
08:35:29 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
08:35:31 <fax> "Program Construction: Calculating Implementations from Specifications"
08:35:36 <aristid> :t id . id
08:35:37 <lambdabot> forall a. a -> a
08:35:41 <JoeyA> "<rajeshsr> This is actually code jam problem, am trying to solve with haskell! :)"  Good luck to you too :)  I'm in the same boat
08:35:45 <Zao> b0fh_ua: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html
08:36:30 <rajeshsr> JoeyA, ha, cool! :) This time i want to maximize the number of languages used! Thought will solve A with haskell, and i failed! :(
08:36:37 <Zao> It might be as easy as   :trace yourfunc
08:37:31 <JoeyA> I'm just trying to learn Haskell myself
08:37:53 <b0fh_ua> Zao: okay, thanks
08:39:00 <rajeshsr> JoeyA, I am learning haskell multiple times! :) I start to learn absorb something, then leave it and then read again! So far am just a beginner with a surface knowledge of everything but will take ages to get a working code in haskell! :) Haskell is the most esoteric language i ever touched!
08:40:21 <JoeyA> I want to find the number of bits in a number.  Is there a cleaner way than this? :  bitWidth n = snd (until (\ (x,y) -> x == 0) (\ (x,y) -> (shiftR x 1, y+1)) (n, 0))
08:40:43 <JoeyA> I'm using until to pass a tuple along, right-shifting it as it goes.
08:41:25 <monochrom> I would try writing my own recursion.
08:41:38 <Zao> There's some fancy bit-twiddling unrolls.
08:41:53 <Saizan> > let bitWidth n = snd (until (\ (x,y) -> x == 0) (\ (x,y) -> (shiftR x 1, y+1)) (n, 0)) in bitWidth 5
08:41:54 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:41:54 <lambdabot>    `Data.Bits.Bits t'
08:41:54 <lambdabot>      a...
08:42:01 <Saizan> > let bitWidth n = snd (until (\ (x,y) -> x == 0) (\ (x,y) -> (shiftR x 1, y+1)) (n, 0)) in bitWidth (5 :: Int)
08:42:01 <lambdabot>   3
08:42:08 <Zao> http://codepad.org/NhuFK4wt
08:42:12 <JoeyA> I suppose there's an until-like function that passes the argument through and counts the results.
08:42:13 <Zao> That's for 32-bit quantities in C++.
08:42:16 <Chaze> JoeyA: the ugliest version is still ceil(log_2(n))
08:42:20 <JoeyA> err, counts the number of cycles.
08:42:40 <Zao> http://graphics.stanford.edu/~seander/bithacks.html
08:42:43 <benmachine> isn't there a typeclass function for this
08:42:54 <JoeyA> Zao> Yup
08:43:24 <Absolute0> which operator divides into an integer result?
08:43:34 <hpc> `div`
08:43:36 <monochrom> div, rem
08:44:15 <benmachine> > length $ unfoldr (\x -> ((), shiftR x 1) <$ guard (x > 0)) 5
08:44:16 <lambdabot>   3
08:44:41 <Absolute0> > let n = 600851475143 in head $ dropWhile (\x -> (x `mod` n) /= 0 ) [n `div` 2, (n `div` 2)-1 .. 0]
08:44:43 <Absolute0> :)
08:44:45 <lambdabot>   mueval-core: Time limit exceeded
08:44:51 <Absolute0> my coding stinks!
08:45:29 <rajeshsr> strange! too strange!! Works now!! I can't digest this! I made no change. Now running the same command works!!
08:46:22 <gwern> rajeshsr: unless there was IO involved that's impossible :)
08:46:27 <rajeshsr> So, guess what mistake i did?!!  runhaskell < ASmall.in > oH1
08:46:27 <rajeshsr>  :P :(
08:46:30 <rajeshsr> stupid me!!
08:46:40 <JoeyA> rajeshsr> That's what's hard about Haskell.  It's highly stateful and nondeterministic.
08:46:41 <rajeshsr> giving input file to runhaskell!!
08:46:52 <JoeyA> jk, of course
08:47:19 <SonOfLilit> Hello
08:47:29 <SonOfLilit> I have written a monster
08:47:30 <SonOfLilit> let maxi (x:xs) = fst . foldl (\(mi,v) (i,k) -> if k>v then (i,k) else
08:47:30 <SonOfLilit> (mi, v)) (0,x) $ zip [1..] xs
08:47:40 <SonOfLilit> I am seeking a way to simplify it
08:48:02 <JoeyA> Are you getting the max of a list?
08:48:07 <SonOfLilit> max index
08:48:18 <Absolute0> How do I get all the functions for a type in ghci?
08:48:19 <JoeyA> so, the 0-based position of the maximum item, correct?
08:48:23 <fax> http://library.wolfram.com/infocenter/Conferences/5020/
08:48:23 <Absolute0> :info doesnt list everythign
08:48:28 <SonOfLilit> I tried to replace the if with something like a 'maxby' but it doesn't work out well
08:48:29 <fax> hehe wrong kind of 'origrami programming'
08:48:39 <monochrom> :type on
08:48:45 <monochrom> @type on
08:48:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:48:47 <SonOfLilit> JoeyA: exactly
08:49:06 <Absolute0> I want to round sqrt n into a Num type
08:49:13 <hpc> fax: that paper is disappointingly two-dimensional
08:49:14 <JoeyA> take 1 $ sort $ zip [0..] xs
08:49:16 <JoeyA> (guess)
08:49:36 <fax> hpc lool
08:49:39 <SonOfLilit> Isn't that horrible in terms of performance?
08:50:00 <JoeyA> Well, it sorts instead of getting max
08:50:01 <SonOfLilit> now that I think of it, I /have/ heard that Haskell's sort sorts lazily...
08:50:06 <JoeyA> so it's probably something like n log n instead of n
08:50:29 <SonOfLilit> what bothers me is the space complexity
08:50:39 <SonOfLilit> I'm dealing with /big/ lists
08:52:11 <alpounet> SonOfLilit, then you may consider using another data structure
08:53:40 <SonOfLilit> I think lists fit just fine
08:53:50 <gwern> are you using infinite lists?
08:53:54 <SonOfLilit> what's wrong with folding through a list to find the max index/
08:53:55 <gwern> if not, I think Seq fits better
08:53:56 <SonOfLilit> ?
08:54:14 <monochrom> use foldl' instead of foldl
08:54:29 <SonOfLilit> ah, that would probably help performance :-)
08:54:31 <monochrom> same deal with adding numbers.
08:54:32 <gwern> SonOfLilit: if you're searching your list, why not a tree?
08:54:40 <fax> hey monochrom
08:54:44 <fax> heave you seen this book??
08:54:47 <SonOfLilit> it's a throwaway list
08:54:56 <fax> Program Construction: Calculating Implementations from Specifications
08:55:08 <SonOfLilit> I'm just trying to say "find i so that f(i,...) is maximal"
08:55:22 <JoeyA> Better, but not the best:  let maxi xs = snd $ head $ sortBy (flip compare) $ zip xs [0..]
08:55:33 <monochrom> hey fax
08:55:38 <monochrom> I think
08:55:44 <monochrom> I have
08:55:49 <monochrom> only heard of it.
08:55:57 <monochrom> Isn't it great to
08:56:04 <monochrom> slowly unfold
08:56:08 <benmachine> :t maximumBy (comparing snd)
08:56:09 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
08:56:11 <monochrom> your complete sentence.
08:56:18 <monochrom> Burma Shave
08:56:21 <fax> :)
08:56:44 <fax> it uses Guarded Command Language I think this book is going to be a good one
08:57:00 <xerox> hahaha monochrome.
08:57:08 <monochrom> Why do people behave like their IRC client is only 10 characters wide?
08:57:27 <SonOfLilit> benmachine: that sounds like a good way to do it
08:57:31 <xerox> anxiety
08:58:05 <benmachine> I think newlines are a sort of punctuation sometimes
08:58:17 <monochrom> I can understand why people behave like their MSN client is only 10 characters wide, because it is really 10 characters wide.
08:58:46 <Phyx-> eh?
08:59:03 <Phyx-> just widen it?
08:59:10 <aristid> Phyx-: i don't know what a "MSN client" is, either
08:59:18 <monochrom> Yeah, widen your IRC client already.
08:59:27 <SonOfLilit> @src comparing
08:59:28 <lambdabot> Source not found. Just try something else.
08:59:30 <Phyx-> and msn client, lol
08:59:33 <SonOfLilit> @type comparing
08:59:35 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:59:38 <aristid> monochrom: sorry i can't, my screen only has 1280 pixels of width :)
08:59:42 <SonOfLilit> Where does it come from?
08:59:47 <benmachine> Data.Ord
08:59:51 <fax> "Programmers call their errors 'bugs' to preserver their sanity; that number of 'mistakes' would not be psychologically acceptable"
08:59:54 <Phyx-> aristid: so? you can always start scrolling :P
08:59:57 <benmachine> it's pretty much the only thing in there
09:00:04 <aristid> Phyx-: oO
09:00:23 <SonOfLilit> how do I import it into my ghci without moving from my current namespace
09:00:24 <SonOfLilit> ?
09:00:35 <Phyx-> :m +Data.Ord
09:01:06 <benmachine> you can also just use Data.Ord.comparing even if it's not in your ghci context
09:01:19 <JoeyA> Can you cleanly nest functions in Haskell?  Something like:
09:01:19 <SonOfLilit> thanks :-)
09:01:23 <JoeyA> f x =
09:01:27 <JoeyA>    g x = x*x
09:01:36 <JoeyA>    (g x) + 2
09:02:03 <benmachine> > let f x = let g x = x*x in g x + 2 in f 9
09:02:04 <lambdabot>   83
09:02:09 <SonOfLilit> JoeyA: you mean like let?
09:02:12 <monochrom> f x = g x + 2 where g x = x*x
09:02:14 <JoeyA> yes :)
09:02:26 <Phyx-> well, technically speaking + doesn't move you from your current namespace so :)
09:02:43 <JoeyA> Doesn't let, though?
09:02:53 <JoeyA> Or does g x interfere with the scope of the program?
09:02:57 <benmachine> you're talking about different +s
09:03:08 <benmachine> let introduces a new scope
09:03:16 <JoeyA> okay, good.  Lexical scope
09:03:23 <benmachine> Phyx-: I know, it was an alternative not a correction
09:03:40 <Phyx-> benmachine: i know :)
09:04:11 <Phyx-> I should go fix my code... but i'm tired for the day, :(
09:05:34 <Phyx-> > id
09:05:34 <lambdabot>   {()->()}
09:05:46 <Phyx-> > (.) (.)
09:05:47 <lambdabot>   No instances for (Test.SmallCheck.Serial (f (a -> b)),
09:05:47 <lambdabot>                    G...
09:06:55 <Phyx-> > flip ((.) (.) (++)) id
09:06:56 <lambdabot>   {()->{()->()}}
09:07:03 <Phyx-> yes i am aware that's just (++)
09:07:05 <Phyx-> lol
09:07:26 <osfameron> roconnor: ooo, the google codejam question is cute
09:07:35 <roconnor> osfameron: there are 3
09:07:45 <osfameron> ah, the first one, the "snapper"
09:07:52 <Phyx-> cute?
09:07:52 <osfameron> is the only one I looked at
09:08:17 <JoeyA> > map (== 1) [1,0,0,1]
09:08:18 <lambdabot>   [True,False,False,True]
09:08:30 <JoeyA> > map (- 1) [1,0,0,1]
09:08:31 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
09:08:31 <lambdabot>    arising from a use of `e_111001' ...
09:08:32 <osfameron> it's nice working out what the problem is
09:08:32 <fax>  I didn't get snapper
09:08:46 <osfameron> you could brute-force it of course
09:08:49 <JoeyA> Do I have to say map (flip (-) 1) [1,0,0,1] instead?
09:08:49 <SonOfLilit> osfameron: technically, the contest is still running
09:08:54 <benmachine> JoeyA: subtract 1
09:08:54 <JoeyA> I'm trying to make it short and concise.
09:08:55 <SonOfLilit> and I'm participating
09:08:58 <benmachine> :t subtract 1
09:08:58 <osfameron> ah, maybe I should join
09:08:59 <lambdabot> forall t. (Num t) => t -> t
09:09:01 <osfameron> not sure I've got time
09:09:04 <JoeyA> ah
09:09:07 <SonOfLilit> so I'm not supposed to listen to people talking about things...
09:09:08 <benmachine> osfameron: maybe you should fmap!
09:09:17 <xerox> > map (subtract 1) [1,0,0,1]
09:09:18 <lambdabot>   [0,-1,-1,0]
09:09:28 <osfameron> benmachine: well, the only spoiler I made was that it was "cute" ;-)
09:09:34 <SonOfLilit> yes
09:09:37 <mdmkolbe> Is there a standard function for converting a Maybe into a MonadPlus?  (i.e. maybe mzero return)
09:09:37 <JoeyA> @src count
09:09:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:09:46 <osfameron> I did spoil on #other_channel, then realised I shouldn't
09:09:52 <benmachine> osfameron: I get the feeling you think I said something of any consequence whatsoever
09:09:53 * osfameron sits in the naughty corner
09:10:07 <osfameron> benmachine: oops, I think I meant that for SonOfLilit
09:10:10 <SonOfLilit> the other questions are interesting too
09:10:11 <benmachine> oic
09:10:11 <osfameron> but I'm sure fmaps would help yes!
09:10:18 <benmachine> :P
09:10:37 <benmachine> I was just making a silly joke because you said maybe you should join >_>
09:10:38 <SonOfLilit> solving them in Haskell has proven quite a challenge, though
09:10:49 <benmachine> and then I explained it for some reason
09:11:11 <osfameron> ah. jokes are always funnier when you have to explain them!
09:11:19 <benmachine> I know right
09:11:49 <Phyx-> </sarcasm>
09:12:14 <Phyx-> is it just me, or does the new google interface, look and feel "off"
09:12:24 <osfameron> yeah, I thought it was horrid
09:12:30 <osfameron> but I guess we'll get used to it
09:12:38 <JoeyA> How do I prevent this count function from stack overflowing?  http://codepad.org/EvBwbpKC
09:13:44 <JoeyA> It's "tail recursive", but n x is called each time, which I think necessitates a stack.
09:14:03 <JoeyA> then again, I'm not sure why it would.
09:15:52 <Peaker> JoeyA, can't you compose it from "iterate"?
09:16:24 <roconnor> SonOfLilit: you can see my solutions with the contest is over
09:17:03 <Peaker> does tail recursion affect stack use in GHC?
09:17:13 <roconnor> SonOfLilit: are you willing to share your codeJam nick?
09:18:03 <SonOfLilit> It is, I think, SonOfLilit or SonOf
09:18:20 <SonOfLilit> you won't find me on the top charts
09:18:28 <SonOfLilit> I'm having a pretty awful contest, actually :P
09:18:43 <SonOfLilit> but it is good Haskell practice and good fun
09:19:02 <roconnor> ya I do programing contests to practice haskell
09:19:07 <roconnor> I don't really like them otherwise
09:19:15 <roconnor> normally I do only ICFP
09:19:38 <fax> but don't you aleady know haskell
09:19:51 <fax> I don't feel like I would learn anything from this contest
09:19:58 <fax> just get frustrated rpobaly
09:20:00 <roconnor> fax: you probably wouldn't
09:20:09 <fax> :(
09:20:21 <roconnor> I did it cause I thought I could solve all the problems in a few minutes
09:20:28 <roconnor> but the damn last one took me 2 hours :(
09:20:32 <fax> I don't even understand the problems...
09:20:47 <roconnor> fax: I'm surprised
09:22:09 <SonOfLilit> me too
09:22:23 <SonOfLilit> they are quite simple to understand... just so hard to solve
09:22:39 <roconnor> well I guess I did find problem 2 akwardly phrased
09:25:31 <roconnor> fax: but definitely the ICFP helps me get more pratical Haskell programming experience
09:25:42 * hackagebot printf-mauke 0.5 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5 (LukasMai)
09:25:50 <roconnor> fax: hey, you should do the 2006 contest
09:26:54 <mauke> RossPaterson++
09:27:17 <fax> roconnor, where is it? (I don't see it on here http://code.google.com/codejam/contests.html )
09:27:26 <roconnor> er
09:27:30 <roconnor> the 2006 ICFP contest
09:27:36 <JoeyA> I used $! to coerce my count function to be tail-recursive:  http://codepad.org/tWa8RPA4
09:27:47 <roconnor> fax: http://boundvariable.org/
09:28:11 <JoeyA> However, count (== 0) (subtract 1) 100000000 (100 million iterations) takes 11 seconds.
09:28:14 <roconnor> JoeyA: that's not unusual
09:28:29 <roconnor> using $!
09:28:50 <roconnor> JoeyA: compiled or interpreted?
09:28:58 <JoeyA> compiled
09:29:13 <mauke> > length. takeWhile (/= 0) . iterate (subtract 1) $ 100000000
09:29:14 <JoeyA> (ghc)
09:29:17 <lambdabot>   mueval-core: Time limit exceeded
09:29:44 <roconnor> JoeyA: how long should it take?
09:30:19 <roconnor> JoeyA: did you compile with -O2 ?
09:30:19 <fax> that sounds fun
09:30:40 <JoeyA> well, considering that I'm looping with an Int, and that an empty for loop in C can typically do 1000000000 cycles in a second
09:30:43 <roconnor> fax: actually if you know C you should consider implementing the virtual machine in C.
09:30:50 <JoeyA> I'll try O2
09:31:02 <JoeyA> but 10 seconds for 100 million cycles is literally 100 times slower than expected.
09:31:05 <roconnor> fax: but then do the rest in Haskell
09:31:25 <roconnor> JoeyA: 100 slower for non-optimized haskell doesn't sound unusual
09:31:25 <mauke> switching from Integer to Int improved my time from 10 to 9 seconds
09:32:59 <JoeyA> With -O2, mauke's solution is 6 seconds instead of 8.
09:33:17 <mauke> JoeyA: try (100000000 :: Int) instead of 100000000
09:33:30 <JoeyA> Did; down to 5 seconds.
09:34:29 <JoeyA> There are some Google Code Jam problems where my solution and the top 10 solutions needed to run a C++ program for a full minute (25% of the allotted time)
09:34:51 <JoeyA> I'm wondering if Haskell will be sufficiently fast for solving problems of high magnitude.
09:35:22 <mauke> time for equivalent C program: 0.001 seconds
09:36:01 <mauke> holy fuck
09:36:14 <JoeyA> Well, the C++ program(s) used primarily C constructs (arrays rather than std::vector), if I'm not mistaken
09:36:31 <JoeyA> unless you're talking about the takeWhile thing
09:36:55 <mauke> JoeyA: http://codepad.org/RhJBwRwb
09:36:59 <roconnor> JoeyA: My longest code jam solution took 2 seconds
09:37:09 <roconnor> and I forgot to do -O2
09:38:07 <mauke> guess what gcc does with this code
09:38:25 <JoeyA> mauke> Even that was 0.001 seconds, with the GNU nested function?
09:38:42 <mauke> IT CONSTANT-FOLDED EVERYTHING
09:38:52 <JoeyA> nice
09:38:54 <idnar> haha
09:39:04 <pikhq> GCC is craziness. :)
09:39:07 <mauke> subl $16, %esp; movl $100000000, 4(%esp); movl $.LC0, (%esp); call printf
09:39:16 <idnar> go go gadget compiler
09:39:19 <mauke> the whole program is literally a call to printf with constant arguments
09:39:28 <Ke> shouldn't ghc constant fold everything better
09:39:35 <roconnor> that's cheating!
09:39:49 <JoeyA> I guess in this case, since it could see count was a pure function, it folded it.
09:39:53 <mauke> roconnor: the benefits of using a pure language!
09:39:53 <Ke> haskell should allow folding all constant expressions
09:40:02 <JoeyA> However, that'd be hard to do in Haskell what with all the statefulness and nondeterminism.
09:40:02 <Ke> yes
09:40:07 <roconnor> mauke: GCC is a pure language?
09:40:22 * roconnor is confused
09:40:54 <JoeyA> Too bad Haskell isn't a purely functional language.  These types of optimizations would be commonplace.
09:41:03 <JoeyA> (I'm being facetious)
09:41:25 <JoeyA> Well, GCC has an attribute((pure)) that can be added to functions (e.g. strlen)
09:41:39 <JoeyA> and I guess it can auto-detect static pure functions as well.
09:41:44 <Twey> mauke: Hahaha, awesome.
09:42:43 <idnar> mauke: psshh, why didn't it constant-fold printf too?!
09:42:43 <pikhq> idnar: It doesn't have printf in the compilation unit.
09:42:43 <roconnor> isn't GHC using a GCC backend?
09:42:43 <mauke> not by default
09:42:44 <roconnor> why doesn't it get constent folded away in GHC?
09:42:46 <idnar> pikhq: that's no excuse
09:42:47 <roconnor> oh
09:42:53 <idnar> pikhq: in fact, it should just constant-fold my whole computer
09:42:53 <alpounet> with -fvia-c it does i guess
09:43:11 <Twey> Haha
09:43:36 <Twey> void os() { printf("42"); }
09:47:29 <stulli> What is a good package for downloading a URL? I used Network.Curl.Download, but cabal install fails for me now.
09:48:50 <roconnor> wget?
09:50:21 <roconnor> oh you mean haskell package?
09:50:27 <timmaxw2> > -1 `rem` 3
09:50:27 <lambdabot>   -1
09:50:35 <timmaxw2> > -1 `mod` 3
09:50:36 <lambdabot>   -1
09:50:40 <roconnor> more brackets
09:50:40 <timmaxw2> is that a bug?
09:50:50 <timmaxw2> (-1) `rem` 3
09:50:56 <roconnor> more >'s
09:50:57 <timmaxw2> > (-1) `rem` 3
09:50:58 <lambdabot>   -1
09:51:05 <timmaxw2> > (-1) `mod` 3
09:51:06 <lambdabot>   2
09:51:08 <timmaxw2> d'oh
09:51:24 <roconnor> arguably it is a bug but it is a difficult parsing problem
09:51:40 <fax> dunn why people donot just write  negative 3
09:51:52 <roconnor> > negative 3
09:51:53 <lambdabot>   Not in scope: `negative'
09:51:59 <timmaxw2> > negate 3
09:51:59 <fax> it's kind of weird trying to pander to stupid conventions that come from the era of writing stuff on paper
09:51:59 <lambdabot>   -3
09:52:27 <bremner> roconnor: HaskellBOL \o/
09:52:29 <stulli> roconnor: Yes, i mean a haskell package. I just found http-wget though, i'll try that.
09:52:42 <kpreid> just write 0 - 1 and it becomes clear :-)
09:52:44 <roconnor> BOL?
09:52:58 <roconnor> > 0 - 1 `mod` 3
09:52:58 <bremner> NEGATE 3 YIELDING X
09:52:59 <lambdabot>   -1
09:53:10 <roconnor> hmm
09:53:19 <roconnor> I'm not sure mod should bind so tightly
09:53:34 <roconnor> div sure
09:53:37 <roconnor> but not mod
09:53:43 <roconnor> well
09:53:44 <roconnor> hmm
09:53:47 <Peaker> mod should have the same precedence of div for simplicity of remembering it..
09:54:02 <Peaker> I think precedence rules should optimize for ease of remembering them first, saving parenthesis second :)
09:54:27 <timmaxw2> i think mod does have the same precedence as div
09:54:33 <timmaxw2> prelude says infixl 7  *, /, `quot`, `rem`, `div`, `mod`
09:54:53 <SonOfLilit> which is why I don't support rules of precedence at all
09:55:00 <timmaxw2> i expected it to bind more tightly than negation...
09:55:50 <mauke> you can't bind more tightly than negation
09:56:08 <timmaxw2> negation is supposed to have precedence 6 (same as +, -). so why is (-1 `mod` 3) parsed as (-(1 `mod` 3))? `mod` has precedence 7
09:56:19 <idnaria> fax: it's not like "negate 3" is any easier to read on a computer screen than on paper
09:56:32 <fax> idnaria it is easier for a computer to read
09:57:04 <idnaria> fax: optimising for the computer at the expense of the human is generally not a great idea
09:57:12 <fax> I disagree
09:57:14 <timmaxw2> > -1:[]
09:57:15 <lambdabot>   [-1]
09:57:27 <timmaxw2> > -1==2
09:57:28 <lambdabot>   False
09:57:35 <fax> we should make programming easy for computers, then we will not have to do so much of it
09:57:47 <timmaxw2> nevermind, i'm an idiot...
09:58:24 <timmaxw2> fax: on the contrary, the compiler should do as much work as possible for us. the compiler is written once and used many times.
09:58:45 <fax> timmaxw2 - you said on the contrary, but I feel like you are agreeing with me
09:59:17 <timmaxw2> fax: apparently i don't understand your position.
09:59:44 <fax> compiling a program is programming
10:00:09 <fax> people used to write out high level programs then compile them by hand so the computer would run it
10:01:27 <SonOfLilit> timmaxw2: extending your language should be easy, so that it would grow to fit your needs.
10:01:30 <Twey> > (-1 `mod` 3)
10:01:31 <lambdabot>   -1
10:01:37 <Twey> timmaxw2: It isn't
10:01:46 <SonOfLilit> to make it easy, special cases must be eliminated like the plague
10:02:06 <Twey> SonOfLilit: Are you a Schemer?  ;)
10:02:24 <SonOfLilit> not yet
10:02:27 <SonOfLilit> might be one day
10:02:33 <timmaxw2> Twey: i figured out the precedence bit, that was just me being an idiot
10:02:39 <Twey> timmaxw2: Ah, okay ☺
10:02:53 <Twey> > (+ 1) -3
10:02:54 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
10:02:55 <lambdabot>    arising from a use of `e_113' at ...
10:03:00 <Twey> mauke: Yes you can…
10:05:22 <idnaria> fax: I'm confused about your position too
10:05:51 <idnaria> fax: x86 assembly is easier for an Intel x86-based computer than Haskell, but it's definitely not easier for a human
10:06:21 <SonOfLilit> easier for it to read, but not easier for it to process
10:06:25 <fax> idnaria, so it is not reasonable to make x86 more human friendly
10:06:40 <idnaria> fax: isn't that exactly what Haskell is?
10:06:43 <increpare> Mmm.  I'm having trouble getting gtk2hs to build on OSX10.6.  At the moment it's telling me it can't find mtl.  But cabal informs me that it is installed (and I can load some mtl packages from ghci).  I am confused, and the internet is not helping me.  Ring any bells for anyone here?
10:06:44 <idnaria> (in essence)
10:07:00 <fax> I don't see it that way, but I think that is a perfectly sensible way to view it
10:09:10 <Null-A> i'm working on codebase that uses sideeffects like you wouldn't believe, spread across multiple C++ files
10:09:17 <Null-A> and functions which span over 1000 lines of code
10:09:26 <increpare> Null-A: What does this function do?
10:09:32 <Null-A> and conditonal statements nested up to 7 times deep in functions
10:09:36 <Null-A> it's a compiler
10:09:42 <Null-A> it outputs intermediate code
10:09:48 <Null-A> using standard streams lol
10:09:54 <Null-A> in C++
10:09:55 <increpare> You think it is a well-designed function?
10:10:13 <Null-A> not really, it's very difficult to understand what's going on
10:10:20 <Null-A> I have to keep track of many side effects
10:11:04 <danharaj> hrm... I'm using parsec. I have a parser that has a polymorphic return type. I'm not sure if I'm allowed to do that or how I would write it.
10:11:09 <Null-A> I wish it was written with less side effects =) I certainly see the value
10:12:31 <ddarius> danharaj: Why wouldn't you be able to do that?
10:13:24 <monochrom> I make x86 more friendly to me by moving to haskell.
10:13:53 <increpare> I've spent all day going back and forth between wx and gtk trying to get one of them to work properly,...think I'm just going to go and implement everything in glut mmm glut
10:13:55 <danharaj> ddarius: Because when I went to write it I was like "uh...". But now what I'm doing is passing another parser as an argument to this one that tells it how to parse for the polymorphic type.
10:14:26 <monochrom> f :: Parser a -> Parser a ?
10:15:00 <monochrom> f g = do { char '('; x <- g; char ')'; return x } ?
10:15:24 <ddarius> monochrom: That would be f = parens
10:15:37 <monochrom> for educational purpose
10:16:09 <ddarius> f g = char '(' *> g <* char ')'
10:16:36 <monochrom> that is nice
10:19:23 <Null-A> Which functional language has the largest 3rd party library support?
10:19:35 <fax> haskell
10:19:35 <ddarius> F#
10:19:38 <pikhq> Define "functional".
10:20:46 <jlouis> Null-A: that question is not important. The importance is wether the libraries you are going to need are present and decent
10:21:19 <Null-A> ddarius: ah right, I forgot about that one
10:21:23 * pikhq makes a code generator to produce every possible Haskell library.
10:21:47 <ddarius> pikhq: sequence ['\0' ..]
10:21:53 <idnaria> pikhq: heh
10:21:59 <idnaria> that's like the program I wrote to draw a picture of god
10:22:12 <pikhq> ddarius: Not quite. map valid . sequence ['\0' ...]
10:22:12 <pikhq> :P
10:22:45 <jlouis> boing shapr
10:22:50 <idnaria> pikhq: just compile them all and grab the output
10:23:01 <idnaria> the ones that don't compile will be naturally excluded
10:23:06 <monochrom> That generates all sorts of libraries with unmatching haddocks.
10:23:11 <shapr> jlouis: y0! Happy Code!
10:23:27 <Makoryu> :t sequence ['\0' ..]
10:23:27 <lambdabot>     Couldn't match expected type `m a' against inferred type `Char'
10:23:28 <lambdabot>     In the expression: '\NUL'
10:23:28 <lambdabot>     In the first argument of `sequence', namely `['\NUL' .. ]'
10:23:58 <ddarius> sequence . repeat except that won't produce any Haskell programs in finite time.
10:24:17 <ddarius> The Omega library would be useful here.
10:24:52 <idnaria> :t sequence . return $ ['\0' ..]
10:24:53 <lambdabot> [[Char]]
10:25:27 <ddarius> sequence . return = id
10:25:40 <Makoryu> :t [sequence . return, id]
10:25:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:25:41 <lambdabot>       Expected type: m [a]
10:25:41 <lambdabot>       Inferred type: m a
10:26:08 <ddarius> :t sequence . return
10:26:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:26:09 <aavogt> :t [sequence . return, liftM (:[])]
10:26:10 <lambdabot> forall (m :: * -> *) a1. (Monad m) => [m a1 -> m [a1]]
10:27:01 <ddarius> sequence . return = fmap return
10:28:08 <Phyx-> hmm... is it possible to create instead of all permutations, all unique permutations? something like nub . permutations but in 1 call not 2
10:28:52 <roconnor_> > permutations [1,2,3]
10:28:53 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
10:29:06 <increpare> having troubles with cabal - it seems whenever I try to configure any packages manually (runhaskell Setup.hs configure) that they're not detecting the packages installed in cabal
10:29:09 <ddarius> roconnor_: permutations [1,1,2]
10:29:15 <Phyx-> > permutations [1,2,3,3]
10:29:16 <lambdabot>   [[1,2,3,3],[2,1,3,3],[3,2,1,3],[2,3,1,3],[3,1,2,3],[1,3,2,3],[3,3,2,1],[3,3...
10:29:25 <Phyx-> roconnor_: that would contain duplicates
10:29:34 <increpare> > permutations [1..]
10:29:34 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:29:58 <mauke> > map (take 10) . permutations $ [1 ..]
10:29:59 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
10:30:18 <increpare> > permutations $ repeat 1
10:30:19 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:30:21 <xerox> what does it mean unique permutations Phyx- ?
10:30:33 <mauke> nub . permutations
10:30:38 <roconnor_> Phyx-: oh
10:30:39 <Makoryu> > take 10 <$> permutations [1..]
10:30:39 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
10:30:45 <roconnor_> interesting
10:30:46 <increpare> > permutations [1,2,3] == (nub.permutations) [1,2,3]
10:30:47 <lambdabot>   True
10:31:04 <idnaria> > permutations [1,2,2] == (nub.permutations) [1,2,2]
10:31:05 <lambdabot>   False
10:31:07 <Makoryu> :t [(<$>), (.)]
10:31:07 <Phyx-> mauke: right, but i wanted not to generate them in the first place, if possible
10:31:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
10:31:15 <roconnor_> I claim it is possible :P
10:31:59 <increpare> > permutations (repeat 1) == (nub.permutations) (repeat 1)
10:32:05 <lambdabot>   mueval: ExitFailure 1
10:32:14 <Phyx-> and also without checking the list everytime before adding an entry, since i might as well do nub then :)
10:32:35 * hackagebot control-event 1.1.0.4 - Event scheduling system.  http://hackage.haskell.org/package/control-event-1.1.0.4 (ThomasDuBuisson)
10:33:39 <leoncamel_erc> /
10:34:51 <roconnor_> @src permutations
10:34:51 <lambdabot> Source not found.
10:36:09 <roconnor> @src permutations
10:36:09 <lambdabot> Source not found. That's something I cannot allow to happen.
10:39:28 <rovar> is there a convenient way to convert records to/from Data.map?
10:39:59 <Peaker> rovar, You mean Data.Map?
10:40:21 <rovar> yes
10:40:25 <osfameron> Data.Map is typed isn't it, unlike records ?
10:40:32 <osfameron> I mean, all typed the same
10:40:58 <Peaker> rovar, Can you explain more about what you mean?
10:41:41 <rovar> hrrm...
10:41:52 <rovar> I think I may have answered my own question..
10:42:42 <rovar> i'm using a binary network protocol (BSON) which as you might guess, has it's own set of data types
10:43:13 <rovar> so there is the BsonValue data type which contains all of these types..
10:43:59 <rovar> i would like a clear, convenient way to create schemas for messages, which is basically [ (string, BsonValue) ]
10:44:29 <rovar> but...
10:45:34 <rovar> i would like to use record or something like it to map const strings with variables..
10:46:06 <rovar> [ ("field1", BsonInt), ("Field2", BsonString) ]  won't work, and it isn't very nice to look at anyways
10:46:15 <Peaker> rovar, Converting [(k, v)] to Map k v  is:
10:46:18 <Peaker> @type Data.Map.fromList
10:46:21 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
10:47:17 <rovar> Peaker, but my point is I'm defining a schema, not actually the data itself.
10:48:13 <rovar> so I don't want to create that list and convert it to a map.. I want to use that list (or some name -> BsonValue description) and use it to construct a map with real values
10:48:49 <portnov> Q: how can I say haskell program to wait infinite? For example, I made several forkIO's with network listeners and want to wait... until user will press ctrl-c or smth like that
10:49:17 <aavogt> @docs Control.Concurrent
10:49:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
10:49:34 <benmachine> portnov: are they waiting for something in particular?
10:49:53 <aavogt> portnov: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Concurrent.html#11
10:50:19 <portnov> benmachine: for network connections )
10:50:20 <aavogt> oh but if you want to wait for ctrl-c, that's easier than that link
10:50:51 <rovar> portnov, I would use an MChan
10:50:58 <benmachine> portnov: then usually you just do your accept or read or whatever and it'll block until something interesting happens, surely
10:51:07 <rovar> have it read the MChan, but if nothings writing to the MChan, it will block forever
10:51:36 <benmachine> possibly you mean Chan or MVar
10:52:20 <rovar> yea.. a Chan..
10:52:29 <portnov> benmachine: with 1 thread, it's ok. But when main = do {forkIO listener1; forkIO listener2}, main will just exit immediately :/
10:52:43 <rovar> I call them MChan's in my mind because they use the same construct as an MVar, and it distinguishes them from TChan
10:52:55 <benmachine> portnov: make one of the listener threads run in the main thread?
10:53:22 <portnov> benmachine: not good, because i want to do smth other in main thread
10:53:26 <aavogt> or after you forkIO,     v <- newEmptyMVar; takeMVar v
10:53:29 <aavogt> that will block
10:53:35 <benmachine> portnov: do that then
10:53:38 <rovar> portnov.. this example is screaming for a Chan.  seriously.. have the main thread read the Chan.  when the worker threads are done, have them write to it
10:53:44 <benmachine> aavogt: you might get a BlockedOnDeadMVar excpetion
10:53:50 <benmachine> or whatever it's called
10:53:55 <aavogt> maybe
10:54:21 <portnov> yeah, with just newEmptyMVar/takeMVar i got an exception.
10:55:33 <gwern> 'Maverick Meerkat' oy
10:55:42 <Twey> Haha
10:55:54 <Twey> Is that what they're calling the next one?
10:55:58 <gwern> yeah
10:56:03 <Twey> I quite liked ‘Lucid Lynx’
10:56:11 <rovar> hah
10:56:17 <gwern> karmic koala made me wtf
10:56:18 <Twey> It was certainly better than ‘Hoary Hedgehog’
10:56:50 <rovar> portnov, just use the Chan approach.  This is exactly how they're meant to be used.
10:57:12 <Twey> I reckon they just pull up a random list of adjectives starting with the desired letter and grab the first one
10:57:12 <gwern> nah, hoary hedgehog is cute. it reminds me of _Redwall_
10:57:18 <Ke> just waiting for xenophobic xerxes
10:57:27 <Twey> Oh, Spike was a very hoary hedgehog, it's true
10:57:34 <Twey> Ke: Haha
10:57:42 <portnov> ok, thanks all.
10:58:57 <gwern> Ke: xerxes is an animal?
10:59:07 <Ke> not really
10:59:35 <gwern> then you'll wait a long time, certes
11:09:18 <gwern> hah. I like edward's list of library-defined operators
11:09:22 <gwern> line 1: '! <+> <> +++ <-> <|> // <$> </> >< ## $$ << <?> ==> !! # $+$ /=? <&>'
11:09:35 <gwern> step off perl
11:09:52 <gwern> @hoogle ($+$)
11:09:53 <lambdabot> Text.PrettyPrint.HughesPJ ($+$) :: Doc -> Doc -> Doc
11:09:53 <lambdabot> Language.Haskell.TH.PprLib ($+$) :: Doc -> Doc -> Doc
11:09:53 <Twey> Hahaha
11:09:55 <edwardk> those were really handy to me just now actually when trying to decide what to call things =)
11:10:19 <Twey> Stop worrying about clashes.  That's why we have qualified imports.  :þ
11:10:30 <gwern> '|||| ~=? ~> ~?= ~|||~ ~||~ ~|~ ~~> ~~? ~~~>' <- for when two tildes just isn't enough
11:10:51 <edwardk> Twey: i mostly model my containers on things like Data.Map, etc.
11:11:14 <edwardk> currently bashing out a brodal/okasaki heap with a 'modern' interface, using tricks so i can support Foldable, etc.
11:11:15 <Twey> Which don't worry about clashes and use qualified imports
11:11:23 <edwardk> Twey: yeah
11:11:41 <aavogt> qualified operators anybody??
11:11:56 <Twey> We have them, thanks
11:12:00 <edwardk> aavogt: operators are where i draw the line. ;)
11:12:11 <Twey> Blech
11:12:30 <aavogt> > M.fromList ("hello" `zip` [1..]) M.! 'l'
11:12:32 <lambdabot>   4
11:12:48 <BillyKid> Hi, im trying to learn haskell. Some websites are using the '|' for or in data declarations, my ghci says it is an invalid character, is this a problem with ghci or something else im doing wrong?
11:13:10 <aavogt> ghci doesn't let you declare data types
11:13:11 <Twey> Would be nicer if the syntax for qualified operators included punctuation at the beginning, but hey
11:13:19 <tensorpudding> You can't declare data/type/newtype in GHCi, unfortunately.
11:13:29 <aavogt> it does if you use `M.lookup` ?
11:13:34 <aavogt> or is that cheating?
11:13:35 <edwardk> Twey: yeah the syntax for kata is !_M there, which feels latexy enough to be tolerable to me
11:13:54 <aavogt> ooh, subscripts
11:14:00 <Twey> aavogt: WFM
11:14:07 <BillyKid> thats weird, my university is giving me an exercise where i have to use it (methinks!) but we are told to do it in ghci :/
11:14:10 <Twey> But I guess that's cheating
11:14:31 <Twey> BillyKid: You can write your data declarations to a file then load them into GHCi using :l
11:14:43 <edwardk> aavogt: i figure it is close enough to what a mathematician would write when explaining anyways
11:14:44 <BillyKid> Twey, that is what I am doing.
11:14:54 <Twey> That shouldn't give you an error.
11:15:03 <BillyKid> Data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:15:06 <arw> BillyKid: you can edit your file (which you are supposed to turn in i guess) with :e in ghci and then interactively use what is declared in that file.
11:15:13 <BillyKid> that gives error on the '|'
11:15:22 <kpreid> BillyKid: lowercase d in 'data'
11:15:30 <BillyKid> ooh
11:19:29 * hackagebot liboleg 2010.1.5 - An evolving collection of Oleg Kiselyov's Haskell modules  http://hackage.haskell.org/package/liboleg-2010.1.5 (DonaldStewart)
11:25:11 * increpare was half-expecting them to occupy a special Oleg namespace :P
11:30:01 <jlouis> Saizan: I wonder if this code is better. I have more or less the idea in the mail now
11:31:41 * hackagebot download-curl 0.1.2 - High-level file download based on URLs  http://hackage.haskell.org/package/download-curl-0.1.2 (DonaldStewart)
11:32:54 <jlouis> Saizan: ok, slightly better. At least we are better than Deluge now it seems
11:33:44 <Saizan> jlouis: in this the next branch?
11:34:31 <jlouis> Saizan: in two seconds
11:34:53 <jlouis> Saizan: now
11:35:22 <jlouis> http://github.com/jlouis/combinatorrent/commit/fc131fe24207909dd980c674aae6aaba27b966d4 is the commit of the idea
11:35:56 <jlouis> It "only" allocates around 20% here rather than around 33%, so it gives some improvement
11:38:10 <jlouis> had hoped for more though
11:38:36 <Saizan> L.concat is not that good either, (nor L.length), maybe you should keep a separate counter for the length so far and use a Builder?
11:39:19 <Saizan> well, assuming we get to a considerable amount of chunks
11:39:57 <jlouis> Saizan: Indeed those are good ideas. I simply wanted a first fast stab at it
11:42:07 <jlouis> I was wondering on building up a list of chunks and then concatenate them at the last possible moment, but a quick glance at the code suggested this is somewhat what is happening inside
11:42:21 <Saizan> yeah
11:42:39 <Saizan> the only difference is the strictness on the elements
11:42:43 <jlouis> it is still better than concatenating bytestrings it seems
11:42:47 <jlouis> strict ones
11:44:03 <Saizan> one third is promising
11:44:24 <jlouis> yes
11:45:40 <jlouis> Saizan: you should also add yourself to AUTHORS at some point :) The CPU / Network graph is promising! http://jlouis.github.com/combinatorrent/
11:46:05 <jlouis> The last couple of points where above 0.10
11:46:15 <whald> i guess the most performant and also simplest way to represent an Int -> Float LUT is the use of an unboxed array, right?
11:46:42 <jlouis> whald: I would guess so
11:47:17 <whald> jlouis: ok, then i'll do so. thanks.
11:49:20 <Saizan> jlouis: how do you make the measurements? runCombinatorrent.sh?
11:50:26 <jlouis> Saizan: yes
11:52:11 <jlouis> Saizan: it is really not that stable for general consumption, but it takes the output from the RTS and a special output from combinatorrent and merges them into a stat db. postproc.hs then make data digestable for R which plots the sparklines
11:56:22 <dons> jlouis: those are awesome
11:57:01 <dons> that tool needs to be made available for general consumptoin
11:59:19 <jlouis> dons: unfortunately they are not really in a state where they are currently for the general consumption. But I have thought about doing something to the criterion/progression duo along those lines
12:01:05 * hackagebot printf-mauke 0.5.0.1 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5.0.1 (LukasMai)
12:01:40 <dons> its a good proof-of-concept for what we could do with easy, grokkable live stats from the rts
12:01:56 <dons> the eventlog framework should emit the raw data to produce these
12:03:48 <tromp> i get some errors trying  cabal install happstack
12:04:06 <dons> tromp: tell the #happs guys
12:04:18 <tromp> let me try that channel
12:04:57 <danderson> > forever $ throwIO ThreadKilled
12:04:58 <lambdabot>   Not in scope: `throwIO'Not in scope: data constructor `ThreadKilled'
12:05:13 <dons> heh
12:05:16 <danderson> sigh
12:05:21 <pastorn> danderson: that seems nasty... is it?
12:05:22 <gwern> danderson: man, those modules aren't even in scope
12:05:37 <danderson> gwern: I thought lambdabot was supposed to do what I mean!
12:05:48 <gwern> danderson: no, it's supposed to do what's safe
12:05:52 <mauke> base-4.2.0.0 was excluded because of the top level dependency base -any
12:05:58 <mauke> what
12:06:14 <danderson> gwern: what's not safe? :)
12:06:25 <gwern> mauke: can you not read? obviously "base-4.2.0.0" /= "base -any"
12:06:31 <danderson> (I was actually just wondering if forever would also eat exceptions or let them pass)
12:06:40 <gwern> @src forever
12:06:40 <lambdabot> Source not found. :(
12:06:49 <danderson> but I have the answer from ghci
12:06:52 <danderson> it lets them pass
12:06:56 <gwern> danderson: let them pass. it doesn't catch anything - 'forever a = a >> forever a'
12:07:24 <danderson> right
12:10:15 <sshc> > fix this error
12:10:16 <lambdabot>   Not in scope: `this'
12:10:23 <sshc> > fix ou tof scope error
12:10:24 <lambdabot>   *Exception: GHC Panic!  DUMP O
12:10:30 <sshc> > fix undefined error
12:10:31 <lambdabot>   *Exception: Prelude.undefined
12:10:35 <sshc> > fix error
12:10:36 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:10:41 <aavogt> @type ou
12:10:42 <lambdabot> forall a. a
12:10:44 <gwern> ...that ghc panic one worries me
12:10:45 <aavogt> @type tof
12:10:46 <lambdabot> forall a. a
12:10:47 <danderson> see, the DWIM module is all broken.
12:10:53 <mauke> > fix ou tof scope error
12:10:55 <lambdabot>   *Exception: GHC Panic!  DUMP O
12:10:57 <mauke> wat
12:11:02 <aavogt> > scope
12:11:03 <dons> awesomo
12:11:03 <lambdabot>   *Exception: GHC Panic!  DUMP O
12:11:09 <gwern> mauke: precisely my inarticulate chum
12:11:28 <silver> they killed lambdabot
12:11:29 <jlouis> dons: oh, that is a neat idea
12:11:32 <dons> that looks like a bytecode error (DUMP O[BJ ... ])
12:11:35 <aavogt> dons: http://hackage.haskell.org/package/strict-concurrency-0.2.3 apparently doesn't build if you force it to use base-3
12:11:47 <gwern> > 1+1
12:11:49 <lambdabot>   2
12:11:57 <gwern> silver: mueval is tougher than it looks
12:12:11 <dons> bug in mueval?
12:12:26 <mauke> > L.scope
12:12:27 <lambdabot>   Not in scope: `L.scope'
12:12:30 <aavogt> > error "GHC Panic!  DUMP O"
12:12:31 <lambdabot>   *Exception: GHC Panic!  DUMP O
12:12:54 <gwern> dons: I'm not sure. here on the cli, it's just 3 out of scope errors, nothing about a panic
12:13:00 <gwern> mueval -e "fix ou tof scope error"
12:13:01 <gwern> Not in scope: `ou'Not in scope: `tof'Not in scope: `scope'
12:13:44 <djahandarie> Where is that scope function from in the first place?
12:14:10 <mauke> > (scope, scope)
12:14:11 <lambdabot>   Not in scope: `scope'Not in scope: `scope'
12:14:17 <mauke> > scope
12:14:18 <lambdabot>   Not in scope: `scope'
12:14:22 <djahandarie> ... fixed?
12:14:24 <djahandarie> > fix scope
12:14:25 <lambdabot>   Not in scope: `scope'
12:14:28 <djahandarie> lol
12:14:56 <dons> gwern: inneresting.
12:14:59 <aavogt> dons: I can't reproduce that error, but tromp in #happs might show otherwise
12:15:03 <dons> > f x
12:15:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:15:04 <lambdabot>    `GHC.Show.Show a'
12:15:04 <lambdabot>      a...
12:15:11 <dons> aavogt: hmm
12:20:29 <gwern> (hackage happstack cabalinstalls under 6.10 for me)
12:24:28 <tromp> happstack working now; thx, dons and aavogt
12:33:39 * hackagebot WashNGo 2.12.0.1 - WASH is a family of EDSLs for programming Web applications in Haskell.  http://hackage.haskell.org/package/WashNGo-2.12.0.1 (MarcWeber)
12:35:19 <fax> > priems
12:35:20 <lambdabot>   Not in scope: `priems'
12:35:20 <fax> > primes
12:35:21 <lambdabot>   Not in scope: `primes'
12:35:23 <fax> dammt
12:35:44 <fax> @quote prime
12:35:44 <lambdabot> dons says: -fglasgow-exts ~= -fhaskell-prime
12:35:47 <fax> @quote primes
12:35:47 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
12:35:53 <fax> @let primes = nubBy(((>1) .) . gcd) [2..]
12:35:54 <lambdabot>  Defined.
12:36:06 <aavogt> > nubBy (\x y -> x `mod` y == 0) [2..]
12:36:07 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:36:26 <aavogt> > primes
12:36:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:40:20 <fax> > (20 + primes !! 9, 20 + primes !! 13)
12:40:21 <lambdabot>   (49,63)
12:56:46 <mdmkolbe> Is there a good test suite for parsing of Haskell code?  (I'm working on a new approach to the parsing problem and I want to make sure it works out right)
12:57:21 <ezyang> You can quickcheck it with the official parser
12:57:28 <ezyang> Language.Haskell.Parse
12:58:13 <Saizan> there's also ghc's testsuite
13:00:38 <mdmkolbe> Saizan: yeah, but it seems pretty sparse (http://darcs.haskell.org/testsuite/tests/ghc-regress/layout/)
13:01:01 <kmc> if you just want some haskell code to parse
13:01:10 <kmc> the nofib suite is pretty standard for benchmarking in general
13:01:23 <kmc> or you can grab some stuff from hackage
13:01:28 <kmc> but it won't necessarily test pathological cases
13:03:34 <ezyang> Is (.) on arrows mappend on monoids?
13:04:35 <kmc> a monoid is a category with one type T (one object).  the monoid elements are morphisms of signature T -> T and the monoid binary operation is composition of morphisms
13:04:57 <kmc> so i'm not quite sure i understand your question, but it seems the answer should be "yes"
13:06:19 <ezyang> ok!
13:06:29 <ezyang> Just wonderin'. :^)
13:06:38 <hants> kmc, can you point me to a nice description of haskell monads? (i still dont fully understand them)
13:07:19 <kmc> hmm
13:07:32 <ClaudiusMaximus> > 44.4 / 18.8
13:07:33 <lambdabot>   2.361702127659574
13:07:36 <aavogt> @docs Control.Monad
13:07:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
13:09:07 <Saizan> ezyang: you could write instance Arrow arr => Monoid (arr a a) where mempty = id; mappend = (.); if that's what you're asking :)
13:09:12 <mdmkolbe> hants: C++ allows you to do operator overloading (e.g. you can redefine what "+" means).  Monads are Haskells way to allow you to overload the concept of sequencing (i.e. it is like if C++ allowed you to operator overload ";")
13:09:45 <kmc> hants, http://haskell.org/haskellwiki/Monads_as_computation
13:09:53 <kmc> hants, http://haskell.org/haskellwiki/Monads_as_containers
13:10:05 <Zao> mdmkolbe: You can overload "operator ,".
13:10:06 <dino-> I'm writing some haddock comments and seeing something strange, wonder if I'm doing it wrong.
13:10:07 <kmc> hants, but i think there's a few prerequisites that are often overlooked
13:10:17 <hants> which?
13:10:19 <kmc> first of all, you have to understand type classes and higher-order functions
13:10:35 <kmc> because all the burrito analogies aside, "Monad" is just the name of a type class, whose most interesting method is a HOF
13:10:36 <hants> well i hope i do that already
13:10:37 <dino-> When I doc individual function args, the comments are all shifted up one line and the first arg's comment is gone.
13:10:40 <kmc> hants, good
13:10:42 <dino-> So, the final type has no comment.
13:10:43 <Zao> std::vector<int> v; v += 42, 3, 5; // epic
13:11:04 <dino-> Sound familiar to anyone?
13:11:35 <hants> well then thank you kmc and mdmkolbe!
13:11:50 <kmc> hants, i also think it's useful to get comfortable working in a few specific monads, before you try to understand what it is that Monad generalizes
13:11:53 <roconnor> dino-: up, the comments have to go after the argument type
13:11:54 <roconnor> em
13:11:56 <roconnor> um
13:11:58 <roconnor> er
13:11:59 <roconnor> ya
13:12:06 <kmc> that is, pretend for a while that return :: a -> Maybe a and (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
13:12:11 <kmc> and then do the same for lists
13:12:20 <dino-> roconnor: I was doing the -- ^ foo style
13:12:20 <kmc> and maybe IO (but be aware that IO is a strange atypical monad)
13:12:34 <dino-> Maybe I should paste an example
13:13:16 <hants> what makes io that atypical?
13:13:33 <aavogt> is  `return' a HOF?
13:13:47 <aavogt> must a HOF have a more restrictive type than a regular function?
13:13:54 <ezyang> Saizan: That was the idea. I was thinking, "Man, the standard libraries are getting an operator for mappend, but don't we already have a perfectly good one?" :o)
13:15:17 <Saizan> well, in this sense mappend is more general than (.), though mappend's type would be too restrictive for (.), so it doesn't work ;)
13:16:05 <ezyang> well, that's why I was all like "categorical composition"
13:16:25 <ezyang> :t (.)
13:16:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:16:32 <ezyang> ehe
13:16:44 <ezyang> "insufficiently general"
13:20:58 <dino-> Ah! it only happens when there are constraints
13:21:12 <roconnor> dino-: this is what I do : http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/src/Data-Colour-RGB.html#mkRGBGamut
13:21:35 <roconnor> and I get : http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/Data-Colour-RGBSpace.html#v%3AmkRGBSpace
13:22:22 <dino-> I get the same when there are no constraints
13:23:27 <danharaj> Should I put language pragmas in the module files that use them or the top level file of my project?
13:23:53 <ezyang> I tend to put them in the module files that use them.
13:23:57 <noteed> danharaj: in the module in need for the pragma
13:24:02 <mux> in the module file that uses it and also list it in the .cabal file if you have one
13:24:56 <danharaj> thanks. ... hmm I have {-# LANGUAGE GADTs #-} in the module, but it doesn't work. -XGADTs works as a flag though. Am I doing something wrong?
13:25:13 <whald> roconnor: hey, there is a haskell lib dealing specifically with colours? that's crazy, i did not even dare to google for it :-)
13:25:29 <kmc> color is mad complicated
13:25:56 <pastorn> danharaj: is that {-# comment on the first line in the file?
13:26:15 <pastorn> it should be above 'module XXX ...'
13:26:29 <danharaj> ohhh. Alright thanks.
13:26:30 <noteed> whald: yep, but it does a lot of stuff
13:26:48 <pastorn> danharaj: though some pragmas should be in the middle of your code
13:26:49 <whald> kmc: i guess. either that or planck was wrong. i just computed that the amount of energy emitted by an heated body indeed IS infinite at any wavelength!
13:26:55 <pastorn> like noinline and specialize
13:27:00 <kmc> :D
13:27:16 <danharaj> I missed the line in the ghc manual that language pragmas were file-header.
13:27:34 <roconnor> whald: I'm the author
13:28:14 <Makoryu> @pl forever f = f >> forever f
13:28:14 <lambdabot> forever = fix (ap (>>))
13:28:31 <whald> roconnor: i'm a bit puzzled by the haskell syntax still. short question: can i use it for XYZ -> RGB conversion?
13:28:50 <Polarina> whald, of course.
13:28:51 <whald> roconnor: that is sRGB
13:29:25 <whald> Polarina: now i don't know what to do this evening. thanks... ;-)
13:29:53 <Makoryu> :t ap
13:29:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:30:11 <McManiaC> is there an easier way to get the *last* 5 elements of a list than "reverse . take 5 . reverse" ?
13:30:44 <Makoryu> :t \xs -> drop (length xs - 5) xs
13:30:45 <lambdabot> forall a. [a] -> [a]
13:30:50 <Makoryu> @pl \xs -> drop (length xs - 5) xs
13:30:50 <lambdabot> drop =<< subtract 5 . length
13:31:27 <McManiaC> hm yeh
13:31:30 <McManiaC> of course
13:31:30 <McManiaC> :)
13:32:07 <roconnor> whald: you mean CIEXYX ?
13:32:59 <whald> roconnor: yes, i just implemented spectral curve -> CIEXYZ, and it seems using you lib i can go wherever i want from that?
13:33:04 <whald> s/you/your
13:33:15 <roconnor> Ya, I was going to do spectral curves at some point in time
13:33:17 <roconnor> anyhow
13:33:25 <roconnor> http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/Data-Colour-CIE.html#v%3AcieXYZ
13:33:40 <roconnor> this will get you Colour Double or whatever floating point type you want
13:34:04 <roconnor> http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/Data-Colour-SRGB.html#v%3AtoSRGB24
13:34:12 <roconnor> will get you 8 bit x 3 srgb values
13:35:02 <whald> roconnor: wow, that's pretty cool, i'll plug this in now! thanks for the cool stuff :-)
13:37:32 <dino-> roconnor: Ok, what I'm seeing is this. This source: http://ui3.info/d/haddock/Foo.hs
13:37:40 <dino-> Gets me this doc: http://ui3.info/d/haddock/dist/doc/html/foo/Foo.html
13:38:45 <dino-> The class constraint seems to muck it up.
13:42:46 <BillyKid> anyone can spot what is wrong with this declaration, Size :: Tree a => Int when used for (Size (Node x y) = 1 + Size x + Size y)
13:43:21 <ezyang> Aren't functions not supposed to be capitalized?
13:43:49 <BillyKid> ok ill try lower case
13:44:12 <kmc> yeah, variables all start with lower case
13:44:19 <kmc> in expression context, an upper-case identifier is a data constructor
13:44:37 <ezyang> I'm also a little confused why your have bracketing parentheses
13:47:27 <BillyKid> oh i just put that there to highlight it
13:48:42 <dino-> Ah, maybe fixed in dev: http://trac.haskell.org/haddock/ticket/128
13:49:20 <kmc> we use guillemets for quoting / bracketing code
13:49:21 <kmc> sometimes
13:49:31 * increpare finally has wxMac compiling : )
13:49:32 <kmc> let x = "like so"
13:50:55 <increpare> kmc: very civilised : )
13:51:21 <BillyKid> wooo my function works!
13:51:28 <BillyKid> haskell is pretty cool.
13:51:50 <c_wraith> BillyKid: that's a fun feeling
13:51:53 <voxp> cabal keeps alerting me after every update that a new version of cabal-install is available, despite having run 'cabal install cabal-install' and 'cabal install --global cabal-install'
13:52:04 <voxp> Is there something else I should be doing?
13:53:19 <voxp> 'cabal info cabal-install' says that the current installed version is 'unknown' and that the latest is 0.8.2
13:53:41 <roconnor> dino-: that's terrible :(
13:54:20 * increpare cries 
13:54:33 * fax too (install problems)
13:54:34 <Makoryu> voxp: When I run into Cabal glitches, I nuke and pave.
13:54:38 <ezyang> ==
13:54:51 <dino-> roconnor: It is. This is the haddock that shipped with ghc 6.12
13:55:02 <increpare> Makoryu: I'm very close to taking this approach myself right now
13:55:18 <voxp> Makoryu: I was afraid of that. ):
13:55:35 <voxp> I just got the haskell-platform built and installed too.
13:56:25 <Saizan> voxp: cabal --version ?
13:56:36 <voxp> 1.8.0.2
13:56:37 <Saizan> voxp: i think you've a $PATH or %Path% problem there
13:56:57 <Saizan> that's the Cabal one, the cabal-install one instead?
13:57:10 <voxp> 0.8.0
13:57:48 <voxp> But I've run 'cabal update; cabal install cabal-install' with and without the --global flag.
13:57:48 <dino-> Later I'll cabal-install a shiny newer haddock and try that.
13:57:50 <Saizan> ok, so i think the cabal you got with the platform is masking the cabal that got installed by cabal itself
13:58:25 <voxp> Saizan: 0_0 How should I go about fixing that? Or are we back at the 'nuke and pave' step?
13:58:48 * hackagebot hpage 0.9.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.9.0 (FernandoBenavides)
13:58:55 <voxp> I was trying to install Yi, but I kept getting annoying errors about dependencies, so I ran 'cabal update' and that's where I'm at.
13:59:29 <Saizan> voxp: you should locate where is the binary for this cabal version 0.8.0 and rename it to something else and see if cabal --version changes, at which point you can delete it
13:59:53 <Saizan> voxp: are you on windows?
14:00:06 <voxp> Arch Linux
14:01:03 <voxp> Ah, so the global install didn't work. The version in /usr/bin is outdated, while the version in ~/.cabal/bin isn't.
14:01:46 <Saizan> for global installs you should use "cabal install --global --root-cmd=sudo" but those are discouraged anyway
14:02:17 <voxp> Saizan: Yeah, I've used those flags before, but I didn't know they were discouraged.
14:02:18 <voxp> Whoops.
14:03:02 <Saizan> well, the only reason is that it's better to let your distro package manager deal with such directories, they should work though
14:03:07 <danharaj> How can I try two parsec parsers with different return types? <|> requires them to be of the same type.
14:03:23 <mauke> danharaj: and do what with the results?
14:03:31 <kmc> danharaj, what would the return type of the combination be?
14:03:36 <Saizan> danharaj: Left <$> foo <|> Right <$> bar
14:03:37 <danharaj> Construct a type that can take any of the possible parser returns.
14:03:44 <voxp> Saizan: Regardless, cabal install of yi breaks on both versions, so it doesn't matter. xD
14:03:46 <kmc> danharaj, it's like asking how you can write an "if" expression where the "then" and "else" have different types
14:04:09 <danharaj> each of my parsers looks like (Foo a), but the a can be different in each case.
14:04:15 <kmc> ah
14:04:25 <Saizan> voxp: ghc version?
14:04:45 <kmc> danharaj, the simple way:  data SomeFoo = SFA (Foo A) | SFB (Foo B) | ...
14:05:00 <kmc> (SFA <$> parseFooA) <|> (SFB <$> parseFooB)
14:05:08 <kmc> danharaj, but maybe what you really want is an existential type
14:05:08 <fax> huh that's cool
14:05:13 <voxp> 6.12.1. The install complains about 'cannot configure data-accessor-monads', which requires a version of transformers witn number 0.2.*
14:05:16 <danharaj> hmm I think I misphrased.
14:05:18 <kmc> data SomeFoo = forall a. SomeFoo (Foo a)
14:07:07 <danharaj> I have three parsers that return Foo a, Foo b, Foo c, respectively for specific types a,b,c. I want a parser that tries them and returns whichever works. So it's type should be Parser (Foo t), where t is a type variable. But GHC disagrees. I don't understand why.
14:07:10 <Saizan> voxp: try with --constraint="data-accessor-monads-fd == 0.2"
14:07:59 <kmc> danharaj, a function of type String -> Foo t means that the caller gets to choose some t, and the function will return (Foo t)
14:08:22 <kmc> that's why the full (GHC-extensions-enabled) type is forall t. String -> Foo t
14:08:29 <kmc> for *all* types t, the function will return a Foo t
14:08:46 <kmc> and that's incompatible with what you're doing, which is that the *parser* gets to choose t, and will only return that specific t
14:08:47 <danharaj> oh, well then you're right, I want "there exists"
14:08:50 <kmc> yeah
14:08:55 <kmc> so above i gave two ways to do this
14:09:03 <ezyang> Doesn't GHC not have true existentials?
14:09:09 <danharaj> I am confused why existentials use forall?
14:09:22 <kmc> danharaj, it is confusing
14:09:32 <kmc> danharaj, there's a forall in the type of the constructor
14:09:44 <kmc> with the above, SomeFoo :: forall a. (Foo a) -> SomeFoo
14:10:05 <Xask> Hi all! I'm new to haskell programming and I have a simple question : I want to continue a function which starts with:** function1 :: [(String,Int)]->Bool **. My question is how to symbolise a tuple which is inside a list. I know that list is (x:xs). Any help is more than welcome :)
14:10:07 <kmc> also, universals and existentials are related via a continuation-passing transform
14:10:09 <danharaj> kmc: Just to be sure, these are the same existential types I learned of in Pierce's Types and Programming Languages (Or your favorite textbook on the subject, for that matter), right?
14:10:15 <kmc> danharaj, yes
14:10:22 <kmc> TaPL is my favorite textbook on the subject ;)
14:10:24 <voxp> Saizan: "for the depedency  on transformers =0.2.*, there are these packages: [list of packages]. However, none of them are available"
14:10:39 <ddarius> danharaj: You can't recover the a,b,c from exists t. Foo t.  Any functions using that result will need to be universally quantified over that t, i.e. they don't care at all what the tis.
14:10:53 <kmc> Xask, if you match a list of type [(String,Int)] against the pattern (x:xs), x has type (String,Int)
14:10:55 <kmc> that might be what you want
14:11:03 <kmc> but you can also match, e.g. ((a,b):xs)
14:11:07 <kmc> in which case a :: String and b :: Int
14:11:32 <kmc> > case [(1,'a'),(2,'b')] of ((a,b):xs) -> (b,a)
14:11:33 <lambdabot>   ('a',1)
14:11:45 <Xask> many thanks kmc I will try that
14:12:08 <kmc> :)
14:12:37 <danharaj> ddarius: I guess I need to elaborate more on what I am doing to get help for my intented effect.
14:13:48 <kmc> danharaj, the type (exists a. T a) is similar to the type (forall r. (forall a. T a -> r) -> r)
14:14:18 <kmc> the former is "T a, for some specific unspecified a"
14:14:19 <danharaj> I am parsing lines in a language I am interpreting. Foo a is the type of a term that returns a when evaluated (I have a function called eval). My parsers return different Foo a,b,c. Can I wrap my combinators into one and then use that result in eval?
14:14:33 <kmc> the latter is "give me a function that accepts T a, for any a I choose, and I'll give you the function's result"
14:14:42 <kmc> in other words, it's a continuation-passing transformed version of the former
14:14:47 <danharaj> And then I show my eval, so ultimately I don't actually get to touch the type.
14:14:56 <kmc> oh
14:14:59 <kmc> that's tricky
14:15:21 <interferon> I'm having a hard time telling the difference between Monoid and MonadPlus
14:15:28 <ezyang> interferon: One is also a monad.
14:15:29 <kmc> because you're trying to guarantee statically that your parser parses well-typed terms
14:15:43 <interferon> ezyang: which?
14:15:43 <kmc> interferon, if m is a monad such that (m a) is always a monoid, then m is a MonadPlus
14:15:52 <danharaj> My error, btw is Expected type: GenParser Char () (Foo a) Inferred type: Parser (CExpr Int)
14:15:52 <kmc> iff
14:15:58 <ezyang> So List is a monoid and monadplus, but numbers over addition is just a monoid, since there's no monadic instance for numbers
14:16:10 <kmc> danharaj, i think you should parse a "raw" syntax which is not type-tagged
14:16:18 <danharaj> er, that CExpr should be a foo or viceversa
14:16:20 <kmc> and then have a "type checker" that produces the checked syntax
14:16:24 <danharaj> hmmm
14:16:33 <kmc> otherwise, you'll have to bake that type checker into your parser
14:16:37 <kmc> and it'll be uglier
14:17:13 <increpare> Hmm.  Just tried removing everything and reinstalling haskell platform (osx 10.6), but the installer is failing in a rather non-communicativemanner.
14:17:43 <danharaj> kmc: Hmm, that's a lot deeper than I planned to go.
14:18:04 <kmc> danharaj, then i'm afraid you can't use the type-tagged syntax
14:18:06 <danharaj> kmc: What I don't understand is, Parser (Foo a) and Parser (Foo Int), what is the relation between these two types?
14:18:08 <ddarius> ezyang: Numbers aren't even the right kind to be monads.
14:18:16 <kmc> unless there's another option i'm missing
14:18:32 <kmc> danharaj, "Parser (Foo a)" is a parser which promises to produce a (Foo a) for any 'a' i choose
14:18:44 <kmc> "Parser (Foo Int)" will only produce (Foo Int) and I can't choose otherwise
14:18:51 <danharaj> ah
14:19:06 * kmc really likes the way that two-party dialogues in natural language encode alternating universal and existential quantifiers
14:19:30 <interferon> kmc: what do you mean?
14:19:37 <fax> kmc, that sounds interesting - examples?
14:19:51 <ddarius> kmc: I agree.  It's very helpful to view existential/universal as producer-chooses/consumer-chooses.
14:21:10 <ezyang> ooh, filing that one away.
14:21:42 <danharaj> I guess the part that gets me stuck is: I don't care about the type, I'm sending it to a function that knows what to do regardless of the type, and then I'm sending that to show, which is guaranteed to work because the type has to be an instance of Show.
14:21:50 <danharaj> So why do I have to care about the type?
14:22:18 <kmc> it sounds like you want the existential type
14:22:22 <ddarius> danharaj: If you don't care about the type at all, then an existential would work as the consuming functions would be universally quantified over the type variable.
14:22:25 <kmc> data SomeFoo = forall a. (Show a) => SomeFoo (Foo a)
14:22:40 <JoeyA> Is there a simpler way to write this?:  pairs :: [a] -> [(a,a)]; pairs [] = []; pairs (x:xs) = map (\y -> (x, y)) xs ++ pairs xs
14:22:55 <kmc> danharaj, consider
14:22:56 <JoeyA> Granted, it's simple enough.  I figure there's a function for (\x -> (x, y)).
14:23:08 <voxp> Saizan: I still can't get it to work. ): ( http://pastebin.org/211192 )
14:23:23 <JoeyA> (it gets all pairs out of a list of size n, resulting in a list of size O(n^2))
14:23:23 <kmc> > null [(), 7, 'x']
14:23:24 <lambdabot>   Couldn't match expected type `()'
14:23:25 <lambdabot>         against inferred type `GHC.Types....
14:23:31 <ddarius> JoeyA: You mean \y -> (x,y) which is just (,) x
14:23:33 <Makoryu> JoeyA: There's an extension that lets you write that as (,y)
14:23:36 <kmc> danharaj, obviously "null" doesn't care about the type of the list elems
14:23:58 <kmc> danharaj, but you still need to obey the rule that a list contains only one type
14:24:03 <kmc> even though the consumer of that list doesn't care which type
14:24:11 <danharaj> kmc: true
14:24:14 <kmc> similarly, you need to obey the rule that a Parser only parses one type of value
14:24:21 <kmc> even if the caller of the parser doesn't care which type
14:24:45 <kmc> to squash several types down into one, you can use a simple discriminated union (the simplest case being Either), or an existential
14:24:54 <JoeyA> ddarius> Yes, thanks
14:24:59 <kmc> if we had data E = forall a. (E a)
14:25:06 <kmc> then > null [E (), E 7, E 'x']
14:25:08 <kmc> is just fine
14:25:11 <Saizan> voxp: add --constraint="data-accessor < 0.2.1.3" ? :)
14:25:16 <ddarius> JoeyA: Incidentally, you function is a foldr.
14:25:22 <danharaj> kmc: I see what you're saying. Btw which extension allows existential types?
14:25:30 <kmc> ExistentialQuantification
14:25:31 <kmc> in GHC
14:25:43 <Saizan> voxp: we're hitting a case where the dependency solver is not particularly smart, so we've to do its work
14:25:44 <kmc> some other compilers (but not GHC) support the direct "exists" syntax
14:25:51 <kmc> GHC's is a bit annoyingly indirect
14:25:58 <kmc> but allows the same things, modulo more wrapping / unwrapping
14:26:02 <voxp> Saizan: *smacks forehead* Yeah, I was overthinking the problem.
14:26:24 * increpare ah I just had to uninstall all the other versions manually.  WHeee.
14:27:11 <Makoryu> There really ought to be a nuke-and-pave command built into Cabal
14:27:38 <c_wraith> I've asked for that before.
14:27:50 <JoeyA> @src foldr
14:27:51 <lambdabot> foldr f z []     = z
14:27:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:27:53 <danharaj> So what I should do is wrap the return value of each parser into an existential type, and return that right?
14:27:57 <danharaj> that is what SomeFoo is.
14:28:01 <increpare> @src (.)
14:28:02 <lambdabot> (f . g) x = f (g x)
14:28:07 <c_wraith> dcoutts said that he sees value in configure + build in one, but thinks needing to use clean just indicates cabal isn't good enough yet
14:28:14 <kmc> danharaj, yeah
14:28:25 <kmc> danharaj, but you're still not going to get your typed syntax back out
14:28:29 <kmc> without running a type-checking stage
14:28:45 <danharaj> Well, if the parser accepts the input, then it is well typed.
14:28:48 <Makoryu> @src return (->)
14:28:48 <lambdabot> Source not found. You type like i drive.
14:28:51 <kmc> or perhaps with a Data.Dynamic Typeable-sort-of-hack
14:28:57 <ddarius> JoeyA: Actually, I'm wrong, it's a paramorphism, but not nicely a catamorphism.
14:28:57 <JoeyA> @src foldl
14:28:58 <lambdabot> foldl f z []     = z
14:28:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:29:03 <kmc> danharaj, if that's already the case, you can avoid doing this
14:29:11 <kmc> well, hmm
14:29:29 <kmc> i take that back
14:29:35 <kmc> the existential seems correct
14:29:45 <Saizan> let the type checker decide.
14:29:46 <kmc> you will run into trouble only if you need a term to have a specific type
14:29:48 <kmc> i.e.
14:29:55 <kmc> if your program needs to manipulate a (Foo Int) later
14:30:03 <kmc> there is no way to prove that your (exists a. Foo a) is actually a (Foo Int)
14:30:05 <kmc> even though it might be
14:30:18 <kmc> in that case the discriminated union is nicer
14:30:21 <Saizan> unless Foo is a GADT and ...
14:30:21 <danharaj> Too bad I can't do cases on the possible types.
14:30:27 <danharaj> actually Foo is a GADT
14:30:37 <ddarius> danharaj: If you could, you'd destroy parametricity.
14:30:40 <kmc> if you think you want type case, you probably want a discriminated union
14:31:04 <danharaj> ddarius: True, but don't GADT's kind of do that?
14:31:08 <Saizan> pattern matching on the constructors could make you recover information about the type, depending on the definition
14:31:10 <kmc> most of the supposed flexibility of dynamically-typed languages is actually just using type case to compensate for a lack of algebraic types
14:31:18 <kmc> Saizan, but the existential only has one constructor
14:31:34 <kmc> the issue is not patternmatching Foo, it's patternmatching SomeFoo and how uninformative that is
14:31:36 <ddarius> danharaj: No.  They, along with other approaches, include a proof of a particular type with the values.
14:31:39 <ezyang> ==kmc
14:32:09 <kmc> if you really can't use a regular union type and you really need an open union over all the types in the language, Data.Dynamic is the way to go
14:32:13 <ddarius> kmc: Saizan is referring to GADTs.
14:32:23 <danharaj> ddarius: So, in this case I have a Foo a. So it is guaranteed to satisfy one of Foo's constructors. Why can't I match on them?
14:32:38 <Saizan> danharaj: you can match on them.
14:32:40 <ddarius> danharaj: You can.
14:33:06 <kmc> hmm
14:33:10 <kmc> i guess you can
14:33:15 <ddarius> You can't do, typecase Foo a of Foo Int -> ..., Foo Char -> ...
14:33:27 <danharaj> oh, definitely not.
14:33:31 <danharaj> I guess I misphrased.
14:33:38 <kmc> maybe i misunderstood
14:33:40 <danharaj> I wish I didn't have to wrap Foo in an extra type though :\
14:33:58 <kmc> danharaj, you'd have to represent the typing information for the language somehow
14:34:12 <ddarius> danharaj: Do you use the type variable of Foo within the parser for any purpose?
14:34:23 <Saizan> if you existentially wrap "data Foo a where FooInt :: Foo Int; FooBool :: Foo Bool"; then after you extract it you can pattern match and recover the identity of the type
14:34:44 <kmc> i agree with Saizan now.  i'm not sure why i was confused earlier
14:34:49 <danharaj> ddarius: I'm not sure I understand. The only place I intended to use it for was to determine the return type of eval :: Foo a -> a
14:35:39 <ddarius> danharaj: What does your Foo type look like?
14:35:58 <danharaj> Foo a where (a bunch of GADT constructors)
14:36:02 <_Ray_> Hey, newbie question. For a given T, how would I read T integers from stdin into an array?
14:36:04 <danharaj> I should paste this.
14:36:39 <ddarius> :t \n -> replicateM n readLn
14:36:40 <lambdabot> forall a. (Read a) => Int -> IO [a]
14:36:46 <Twey> _Ray_: Are you sure you want an array?
14:36:53 <Twey> This sounds like a job for a list, usually.
14:37:19 <_Ray_> List, yeah. Haven't done Haskell in a while :) Whatever [1,2,3] is
14:37:34 <Twey> :t flip replicateM readLn
14:37:35 <lambdabot> forall a. (Read a) => Int -> IO [a]
14:37:57 <kmc> that's a list
14:38:08 <kmc> which has very different characteristics from an array
14:39:12 <_Ray_> Yeah, not planning on !indexing it much, just wanted to get a "collection" of ints to a function.
14:39:17 <kmc> cool
14:39:32 <kmc> Twey has it then
14:39:38 <increpare> so how does one best nuke-and-pave cabal?
14:39:39 <Twey> Or ddarius.
14:39:54 <danharaj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25387#a25387
14:39:54 <Twey> increpare: Delete ~/.cabal and ~/.ghc
14:40:00 <danharaj> I pasted what I think is relevant.
14:40:23 <increpare> Twey: cheers
14:41:03 <ddarius> danharaj: Use an existential and everything should work fine.
14:41:14 <aristid> :t x
14:41:15 <lambdabot> Expr
14:41:19 <aristid> :t f
14:41:20 <_Ray_> So I would use it like "main = do\n ints = (flip replicateM readLn) 42\n putStr (f ints)", if my function were f?
14:41:21 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:41:36 <aristid> @src f
14:41:36 <lambdabot> Source not found. You untyped fool!
14:41:42 <Twey> _Ray_: No
14:41:57 <danharaj> ddarius: So wrap the return values in an existential type?
14:42:05 <_Ray_> Twey: How, then?
14:42:06 <Twey> _Ray_: replicateM 42 readLn >>= putStr . f
14:42:07 <kmc> ints <- replicateM 42 readLn
14:42:17 <Twey> Yeah, <- being the main difference
14:42:27 <kmc> _Ray_, = is used within "let" to give names to values.  <- is used within "do" to execute actions and give names to results
14:42:40 <ddarius> danharaj: Locally, i.e. within parseCmd or whatever that last function was, wrap them in an existential constructor with a type like CExpr a -> AnyExpr
14:42:40 <_Ray_> Oh, right. Thanks :)
14:42:56 <kulin> if i have a type: TVar [TVar Int], when I read/write an existing int in the list, will it cause retries for read/write on the list?
14:43:22 <ddarius> kulin: No.
14:43:35 <aristid> how about this? :D putrStr $ fmap f (replicateM 42 readLN)
14:43:38 <kmc> once you've got the inner (TVar Int) value, the system doesn't care that it's also part of the list
14:43:46 <ddarius> aristid: Type error.
14:43:53 <kmc> but if you have to read the list tvar to get the inner tvar, that read will conflict with a write to the list
14:44:05 <ddarius> aristid: And undeclared variable error.
14:44:08 <_Ray_> Where's replicateM? (And where could I find "where is X" for functions X?)
14:44:16 <ddarius> @hoogle replicateM
14:44:17 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:44:17 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
14:44:22 <Twey> @index replicateM
14:44:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:44:30 <kulin> ok that is what I expected, i just wasnt sure, thanks
14:44:33 <kmc> _Ray_, Hoogle and Hayoo also have websites
14:45:02 <aristid> ddarius: do you refer only to my typos, or to something more substantial?
14:45:05 <_Ray_> I found "Control.Monad", I was going to try "import"-ing it. Should've tried before asking xP
14:45:12 <kmc> 's okay
14:45:15 <Twey> aristid: Something considerably more substantial.
14:45:23 <kmc> asking about the general way to solve the problem is more important anyway
14:45:38 <Twey> aristid: You meant ‘fmap f (replicateM 42 readLn) >>= putStr’
14:45:44 <Twey> That'd work.
14:45:48 <kmc> should be possible to do with applicative though
14:46:01 <kmc> because it's a fixed pipeline
14:46:13 <aristid> Twey: ah
14:46:19 <kmc> hmm maybe not?
14:46:43 <Twey> aristid: putStr :: String -> IO (), not :: IO String -> IO ()
14:47:30 <Twey> aristid: 'course, typos are substantial too.  The compiler won't go ‘oh, that's obviously a typo for “putStr”.’
14:48:08 <aristid> Twey: i can fix typos fairly quickly, while substantial mistakes might point to a broken mental model.
14:48:43 <danharaj> ddarius: I'm not sure what you mean.
14:48:57 <Cale> aristid: It's important to understand that a value of type IO t is rather unlike a value of type t, in that it describes a bunch of effects which could be carried out to produce a value of type t.
14:49:46 <ddarius> data AnyExpr where AnyExpr :: CExpr a -> AnyExpr;  parseAll = fmap AnyExpr parseInt <|> fmap AnyExpr parseList
14:50:28 <danharaj> ddarius: thanks.
14:50:31 <danharaj> kmc: thanks
14:50:32 <aristid> Cale: which i think i understand.
14:51:08 <Cale> aristid: If you have a value x of type IO t, and you want a value v of type t, then you need to run the action first. Normal evaluation will never get it to run, but inside a do-block, you can write v <- x -- the do-block as a whole will then represent an IO action which when run, will (in part) run x, naming its result v
14:51:38 <_Ray_> Hrm. More annoyingness from my part. How could I tell readLn that what I want to read is an Integer, and not an IO String? I am doing "ints <- replicateM t readLn :: [Integer]"
14:51:41 <Cale> (You might already know this, just thought I'd explain anyway :)
14:51:57 <aristid> Cale: if i understand it correctly, there are two ways to run an IO action. route it somehow into main, or use unsafePerformIO (or a similar function)
14:51:57 <Twey> _Ray_: :: IO [Integer]
14:52:13 <aristid> of course i would never consider the latter :D
14:52:19 <Twey> _Ray_: Or ints :: [Integer] <- …, but that requires an extension
14:52:21 <Cale> _Ray_: Or just use the result like a list of integers and it'll work fine
14:52:31 <Twey> Yeah.  That'll work, too.
14:52:43 <siracusa> dcoutts_: ?
14:53:11 <Cale> aristid: Yeah, you basically never want unsafePerformIO -- it circumvents the normal process of evaluation and inserts an arbitrary IO action into it.
14:53:39 <Cale> If you don't understand exactly how the compiler is going to compile things, it can produce rather surprising results.
14:53:51 * roconnor was considering unsafePerformIO to make progress bars for paralell array comprehension
14:53:51 <_Ray_> Will it? Cause I'm reading t from stdin as well, t <- hGetLine stdin, and when I give it to replicateM, it yells "Couldn't match expected type `Int' against inferred type `String'"
14:54:04 <aristid> Cale: it's also very unelegant.
14:54:08 <Cale> aristid: yeah
14:54:14 <kmc> _Ray_, maybe you want readLn instead of hGetLine
14:54:19 <kmc> :t getLine
14:54:20 <lambdabot> IO String
14:54:21 <kmc> :t readLn
14:54:22 <lambdabot> forall a. (Read a) => IO a
14:54:25 <kmc> (unfortunate names btw)
14:54:29 <aristid> @src readLn
14:54:30 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
14:54:31 <kmc> the latter parses to a value of type a
14:54:41 <ddarius> I have no idea how readLn got its name.
14:54:48 <aristid> @pl . undo do l <- getLine; r <- readIO l; return r
14:54:48 <lambdabot> (line 1, column 1):
14:54:48 <lambdabot> unexpected "."
14:54:48 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:54:57 <aristid> @undo do l <- getLine; r <- readIO l; return r
14:54:58 <lambdabot> getLine >>= \ l -> readIO l >>= \ r -> return r
14:55:01 <Cale> :t readIO =<< hGetLine stdin
14:55:02 <lambdabot> Not in scope: `hGetLine'
14:55:03 <lambdabot> Not in scope: `stdin'
14:55:07 <aristid> @pl getLine >>= \ l -> readIO l >>= \ r -> return
14:55:07 <lambdabot> (readIO =<< getLine) >> return
14:55:16 <danharaj> ddarius/kmc: Ok, my parse function now returns AnyExpr. How do I apply show . eval to it now, if that's even allowed?
14:55:19 <kulin> i dont know how i feel about being able to read a type other than string & bytestring from an input, seems like the parse should be put on the caller
14:55:36 <aristid> huh the result of @pl seems wrong there, or is it correct?
14:55:42 <Cale> :t readIO =<< System.IO.hGetLine System.IO.stdin
14:55:43 <lambdabot> forall b. (Read b) => IO b
14:55:56 <Cale> aristid: Your input wouldn't have typechecked.
14:55:57 <ddarius> danharaj: Write eval as you want.  Then make a wrapper which unwraps the existential, gives the result to eval, then displays the result.
14:55:57 <aristid> :t (readIO =<< getLine) >> return
14:55:58 <lambdabot>     Couldn't match expected type `IO b'
14:55:59 <lambdabot>            against inferred type `a -> m a'
14:55:59 <lambdabot>     In the second argument of `(>>)', namely `return'
14:56:07 <wli> @type readLn
14:56:08 <lambdabot> forall a. (Read a) => IO a
14:56:08 <aristid> Cale: damn
14:56:10 <increpare> :t (.)
14:56:11 <Cale> aristid: Otherwise, it's fine
14:56:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:56:12 <aristid> @pl getLine >>= \ l -> readIO l >>= \ r -> return r
14:56:12 <lambdabot> readIO =<< getLine
14:56:21 <Cale> aristid: You're missing a parameter to return
14:56:29 <aristid> Cale: yeah :/
14:56:33 <increpare> @src (.)
14:56:33 <lambdabot> (f . g) x = f (g x)
14:56:37 <danharaj> ddarius: oh, now I completely understand.
14:56:47 <aristid> @src readIO
14:56:48 <lambdabot> Source not found.
14:57:00 <kmc> danharaj, evalAny (AnyExpr e) = show $ eval e
14:57:29 <Cale> increpare: Note that lambdabot has a different (.). If you want the type of the one in the Prelude...
14:57:33 <Cale> :t (Prelude..)
14:57:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:57:46 <Cale> (Or just ask ghci)
14:58:56 <increpare> Cale: yip yip was just checking if it was still there : )
14:58:59 <_Ray_> Argh. I must be an idiot :/ I just can't read a list of ints from stdin, it seems. I'm using http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25388 . I will first have an int t on its own line, then (on the next line), t integers that I want to read. D: Shouldn't be so hard :(
14:59:11 <Cale> The one in lambdabot is a generalisation. You can view functions of a parameter of type a as being like containers indexed by values of type a, and what (.) is doing is applying a function b -> c to each of the elements held by the container of type a -> b, to obtain a container of type a -> c
14:59:33 <Cale> So, why not any container type at all? :)
14:59:38 <Twey> _Ray_: No need for those semicolons
15:00:15 <increpare> Cale: you introduce any other such niceties of late?
15:00:15 <Makoryu> > (**2) . [1..3]
15:00:17 <lambdabot>   [1.0,4.0,9.0]
15:00:35 <Cale> increpare: Someone suggested a neat generalisation of flip
15:00:40 <Twey> _Ray_: You mean ‘readLn’, not ‘read’ (‘read’ is a pure function that parses a string to extract a value)
15:00:41 <increpare> Cale: oho?
15:00:45 <Cale> hmm, did I put that one in?
15:00:47 <Cale> :t flip
15:00:49 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:00:52 <Cale> yes :)
15:01:00 <_Ray_> Twey, but I don't want to read the entire line, I just want the equivalent of "cin >> someInteger;"
15:01:01 <increpare> Cale: this looks queer!  let me have a think
15:01:08 <ddarius> :t readIO
15:01:09 <lambdabot> forall a. (Read a) => String -> IO a
15:01:14 <ddarius> Ah, no
15:01:19 <Twey> That's not the one, either
15:01:21 <increpare> @src flip
15:01:22 <lambdabot> flip f x y = f y x
15:01:49 <danharaj> kmc: I am getting the error couldn't match expected type "Foo a" against inferred type "AnyFoo" on e in your example :\
15:01:54 <Makoryu> @hoogle IO String
15:01:54 <lambdabot> Did you mean: :: IO String /count=20
15:01:54 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
15:01:54 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
15:02:08 <Twey> _Ray_: I don't really know how that behaves
15:02:13 <Twey> It's been a while since I used C++
15:02:16 <Cale> flip f x = fmap ($ x) f
15:02:29 <kmc> :t words -- _Ray_
15:02:30 <lambdabot> String -> [String]
15:02:33 <kmc> > words "a bunch of words here"
15:02:34 <lambdabot>   ["a","bunch","of","words","here"]
15:02:35 <increpare> Cale: (I guess a main reason to avoid generalizing along these lines is that the type-signatures are no quite longer so self-explanatory)
15:02:48 <Twey> Oh, does it read until the next space?
15:02:49 <_Ray_> Oh, I'll readLine, then words, then cast to :: [Integer]?
15:02:56 <Cale> For flip it's a little questionable, but kind of neat anyway.
15:03:01 <kmc> _Ray_, getLine then
15:03:04 <Twey> No casting… you need to map read over it
15:03:04 <kmc> to defer the parsing
15:03:06 <kmc> then "map read"
15:03:11 <Cale> For (.), I've found that it actually improves my understanding of some expressions.
15:03:17 <Saizan> danharaj: maybe you just need to adapt the type signature?
15:03:22 <kmc> we don't normally "cast" in Haskell... a type signature (e :: t) is just asserting a fact that already had to be true
15:03:30 <kmc> but it can be a more specific fact
15:03:58 <kmc> danharaj, you can't apply (show.eval) to an AnyFoo; you have to pattern-match on the AnyFoo constructor and apply to what's inside
15:03:58 <Makoryu> _Ray_: Haskell does not have cast. It has functions that convert one type of value to another.
15:04:00 <kmc> my example does that
15:04:04 <Cale> Like, when someone writes something like (f .) . g, it's a good deal easier to understand (at least partly) in terms of the functor definition.
15:04:11 <danharaj> kmc: Yeah I just realized the error was elsewhere >_<
15:04:16 <aristid> is readIO = return . read?
15:04:20 <kmc> no
15:04:22 <ddarius> aristid: No.
15:04:23 <Cale> (at least to me)
15:04:24 <kmc> readIO throws an IO error
15:04:25 <Makoryu> > let foo :: Int; foo = read 3 in foo
15:04:26 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
15:04:26 <lambdabot>    arising from the literal `...
15:04:26 <kmc> on parse failure
15:04:31 <Makoryu> Oh right
15:04:33 <Twey> aristid: No, it's a variant of ‘read’ that throws IO exceptions on parse errors
15:04:34 <Makoryu> > let foo :: Int; foo = read "3" in foo
15:04:35 <lambdabot>   3
15:04:39 <kmc> though, with the new exceptions system the error thrown by "read" is also catch-able
15:04:41 <Twey> (and is strict)
15:04:48 <Cale> kmc: ... sort of ;)
15:04:49 <kmc> it was more important with H98 exceptions, which are IO-only
15:04:50 <Twey> Yeah, the strictness is the important bit.
15:04:50 <danharaj> Now it builds! Huzzah. I feel like this project is a lot more than I bargained for. Two extensions already. This is only my second real project.
15:04:57 <kmc> danharaj, :D
15:05:01 <kmc> jumping in the deep end eh ;)
15:05:02 <Twey> It's like read + IO exceptions + eval
15:05:06 <danharaj> kmc: You know it.
15:05:13 <Cale> I still would never want to rely on being able to catch an exception thrown from pure code.
15:05:30 <Twey> _Ray_: fmap (map read . words) getLine >>= print
15:05:33 <Cale> Because it involves such careful control of evaluation order.
15:05:35 <kmc> (btw, i think -XGADTs enables existentials though maybe only in GADT syntax)
15:05:36 <Twey> Er
15:05:48 <kmc> Cale, it just involves not caring *which* exception you get
15:05:53 <Cale> (it can be done, but it's rather fragile)
15:05:55 <danharaj> kmc: I had to enable ExistentialQuantification as well to use forall a.
15:06:00 <kmc> yeah
15:06:06 <Twey> _Ray_: print . answers . map read . words =<< getLine
15:06:10 <kmc> data AnyFoo where { AnyFoo :: Foo a -> AnyFoo }
15:06:17 <kmc> that might work without -XEQ
15:06:22 <kmc> not important anyway
15:06:24 <roconnor> @pl (\c -> g c >>= f)
15:06:25 <lambdabot> (f =<<) . g
15:06:28 <kmc> Cale, i think the semantics of imprecise exceptions are pretty well specified
15:06:33 <Cale> You have to ensure that the exception which happens is evaluated inside the catch.
15:06:54 <danharaj> kmc: It's a little ugly though, that you have to wrap things. Would it not make sense to associate to every type constructor a polymorphic type and an existential type?
15:07:03 <Cale> Or else you won't catch anything -- the exception will be returned as part of the result, and only happen after it's too late.
15:07:13 <kmc> danharaj, perhaps
15:07:26 <kmc> danharaj, in some other Haskell compilers you can write a type "exists t. Foo t"
15:07:55 <danharaj> kmc: Well, I have to respect the reasoning of the GHC people... what is that reasoning anyway? Why the indirection?
15:08:03 <Cale> Together with the imprecise specification of evaluation order (which is essential), this makes it a little tricky to ensure that exceptions are actually caught. There's Control.Exception.evaluate to help, but it's still not easy.
15:08:08 <kmc> GHC has a bit of a philosophy of requiring more wrapping from the user, in exchange for simpler compiler implementation
15:08:09 <ddarius> kmc: That makes the type level a little nicer, especially in more complex cases (i.e. it avoids needing to make even a Foo data type) but doesn't change too much at the value level.
15:08:30 <_Ray_> Twey: Thanks, that seems to work :) One more thing. I have a list of 2-element lists. I want to process them. Is this the right way to match the general case, and the base case, respectively? ((x:y:xs):xxs), where xxs is the rest of the 2-element lists, and x and y are my elements, and the base case being [x:y:xs]?
15:08:33 <kmc> this is the case with existentials; it'll be the case with impredicative types soon
15:08:41 <kmc> it's arguably the reason GHC doesn't support an infinite-types extension
15:08:45 <kmc> though i doubt anyone particularly wants that
15:09:24 <danharaj> kmc: I guess that's an alright philosophy for experimental extensions.
15:10:01 <Twey> _Ray_: If they're two-element lists, you can just say ([x1, x2] : xs)
15:10:12 <danharaj> kmc: But I hope that the situation will change if, say, existentials become official parts of the language.
15:10:49 <kmc> danharaj, yeah.  these issues will be debated at great length before that happens
15:10:52 <Makoryu> _Ray_: If they're all exactly two elements, is there a reason you used lists instead of tuples?
15:11:00 <ddarius> danharaj: Again, in your particular case, free existentials would make no difference.
15:11:01 <kmc> imo, existentials are one of the more necessary ghc extensions
15:11:05 <kmc> in terms of actually getting stuff done
15:11:08 <Makoryu> :t [(1, 2), (3, 4), (5, 6)]
15:11:09 <lambdabot> forall t t1. (Num t, Num t1) => [(t, t1)]
15:11:18 <kmc> with existentials, Haskell is reasonably strong for OOP
15:11:18 <_Ray_> Makoryu: Just using the general "get me k-element subsets" function I had, for k=2
15:11:27 <Makoryu> _Ray_: Ah.
15:11:30 <kmc> and though OOP is not the universal tool that many people make it out to be, it is *a* useful tool
15:11:43 <danharaj> kmc: The fact that someone as novice as me managed to bump into them as an intuitive implementation solution says something.
15:11:48 <_Ray_> So ([x, y] : xs) and ([[x, y]]) are the patterns to use? ghc complains that they overlap
15:11:52 <kmc> and more useful when your language is free of some of the crippling restrictions of some standard OOP languages
15:11:54 <danharaj> kmc: I doubt I'll run into some of the more exotic extensions any time soon.
15:11:56 <kmc> danharaj, yeah
15:12:15 <kmc> danharaj, a lot of the extensions are just sugar.  if you don't know about them you'll probably just write slightly more verbose code
15:12:19 <kmc> brb
15:12:26 <danharaj> ddarius: Do you mean I would still have to wrap the type?
15:12:28 <kulin> there is something to be said about keeping the features of a language small
15:12:31 <Twey> _Ray_: [[x, y]] is a list containing only a single two-element list containing the items ‘x’ and ‘y’
15:12:41 <_Ray_> Yep, that's what I want
15:12:54 <illissius> danharaj: what is your project?
15:12:57 <danharaj> kulin: there's also something to be said about making them complete. Existentials seem to be a natural completion, especially since they don't break type inference or anything.
15:13:12 <_Ray_> I have things like [[1,2], [2,1], [3,1], [1,3]], and I want to do something to each.
15:13:13 <Twey> _Ray_: ([x, y] : xs) is a list of any number of items (>= 1) whose first item is a two-element list containing only the items ‘x’ and ‘y’
15:13:20 <danharaj> illissius: My friend and I came up with a little imperative language, he's implementing an interpreter in C and I'm implementing one in Haskell
15:13:45 <_Ray_> Twey: Sounds like what I want. Why is there overlap, according to ghc?
15:13:45 <ddarius> danharaj: You wouldn't need to make AnyExpr, but it would probably still be easier to do something like type AnyExpr = exists a. CExpr a.  You'd still have to pack and unpack things at the value level.
15:13:46 * ezyang is amused. 
15:13:53 <Twey> _Ray_: Since the former is more specific than the latter (it's a special case where xs = []), you must put it last if the other is to have a chance of taking effect
15:14:03 * wli has been doing this a rather long time not to know how to effectively use existentials.
15:14:11 <_Ray_> Oh, you're right, I forgot about that.
15:14:22 * wli = twink btw
15:14:36 <danharaj> ddarius: I guess I expected eval :: Foo a -> ... to be automatically lifted to work on existentials of Foo a.
15:14:45 <Twey> _Ray_: You have failed to handle the [] case in your example, and also, if you know you're only going to have two elements, it may be worthwhile to use pairs instead of lists.
15:14:49 <illissius> danharaj: oh, I see. funny, because I'm doing a haskell compiler for a mini-language as an assignment and bumped into / am bumping into many of the same questions you've been asking at the same time :)
15:15:00 <danharaj> illissius: haha
15:16:07 <_Ray_> hrmph. Alright, so it compiles xD But still no dice with reading. I'm doing http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25390 , starting the program, and entering "26000000 11000000 6000000",followed by an enter. It tells me "Prelude.read: no parse"
15:16:43 <_Ray_> oh, wait. nvm, I have to fix something first
15:17:48 <_Ray_> yay, it works :) Thanks a lot! :)
15:17:55 <Twey> You're welcome
15:20:34 <danharaj> What's the easiest way to strip quotes from a string?
15:21:01 <kmc> you just want to remove every occurrence of the character '"'?
15:21:04 <tensorpudding> filter (/='\"')?
15:21:29 <kmc> > '"'
15:21:30 <lambdabot>   '"'
15:21:59 <tensorpudding> Hmm, so you don't need the \
15:22:07 <tensorpudding> unless it's "\""
15:22:11 <danharaj> ah, I thought there would be a standard function for it.
15:22:29 <kmc> "read" will turn a string literal into a string
15:23:00 <kmc> > read "\"Hello, \n w\\x78rld!\""
15:23:01 <lambdabot>   *Exception: Prelude.read: no parse
15:23:02 <danharaj> Well, I am returning show $ evalAny... right? I want to strip the quotes from show.
15:23:03 <kmc> > read "\"Hello, \n w\\x78rld!\"" :: String
15:23:04 <lambdabot>   "Hello, \n wxrld!"
15:23:37 <roconnor> I've rewritten http://www.haskell.org/haskellwiki/IO_Semantics to remove the continuations.  Hopefully this will make IO a lot less mysterious
15:23:39 <kmc> danharaj, what are you doing with the result?
15:23:57 * hackagebot hamlet 0.2.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.2.0 (MichaelSnoyman)
15:24:10 <danharaj> kmc: Just putting it to stdio. It displays the quotes.
15:24:17 <danharaj> stdout, rather
15:24:20 <kmc> danharaj, are you using "print"?
15:24:25 <danharaj> putStr
15:24:26 <kmc> oh
15:24:48 <kmc> well, if you call "show" on a string, it'll make that string into a string literal
15:25:00 <kmc> if you show an Int, it shouldn't add any quotes
15:25:11 <facsimile> 666
15:25:58 <kmc> if you want to treat String specially, you'll need to make a new show-like function
15:26:03 <kmc> which is id for String and show for everything else
15:26:52 <danharaj> kmc: Are you sure? Because my output types are Bool and Int, and the quotes show up. Maybe I am using print somewhere.
15:26:58 <roconnor> how do you tell if 1 is the string "1" or the integer 1
15:27:23 <roconnor> you shouldn't use print with show
15:27:27 <kmc> danharaj, right.  print will call "show" again
15:27:30 <kmc> print = putStrLn . show
15:27:36 <roconnor> @serc print
15:27:37 <lambdabot> print x = putStrLn (show x)
15:28:21 <danharaj> print is nowhere to be found.
15:28:25 <danharaj> Strangeness.
15:28:30 <roconnor> @index print
15:28:31 <lambdabot> System.IO, Prelude
15:28:33 <kmc> maybe you can hpaste this?
15:28:38 <danharaj> hahahaha
15:28:41 <danharaj> Ok, I am absent minded.
15:29:07 <kmc> ghci also uses print
15:29:11 <kmc> is that the problem? ;)
15:29:14 <danharaj> Sorry for that >_< Yeah, I forgot that I moved show into the wrapper function, and didn't take it out of the line.
15:29:18 <kmc> cool :)
15:29:40 <danharaj> Non-trivial compilation errors are like a stack trace for me.
15:29:43 <ddarius> roconnor: Perhaps you want to change the title?
15:29:47 <danharaj> I have no friggin clue where I am anymore.
15:29:51 <roconnor> ddarius: why?
15:30:15 <facsimile> I usually ignore compile errors
15:30:31 <hpc> facsimile: you had better be trolling
15:30:37 <ddarius> roconnor: "Rewritten to remove continuations." "Semantics of IO: A Continuation Approach"
15:30:53 <roconnor> ha
15:30:54 <facsimile> this channel is getting stupid
15:30:55 <roconnor> yes
15:31:00 <facsimile> I think I should stop coming here
15:31:15 <roconnor> facsimile: #haskell-in-depth ?
15:31:28 <kmc> when you get a type error, just add "unsafeCoerce" until it goes away
15:31:39 * ezyang cringes 
15:31:51 <kulin> is there a keyword which means current module?
15:31:56 <kmc> (this has been another episode of: advice given ironically in #haskell and sincerely in ##c)
15:32:07 <hpc> kulin: you shouldn't need one if you import right
15:32:17 <kmc> kulin, don't think so.  what would it do?
15:32:27 <kulin> well my module is using the same function names as functions in prelude
15:32:28 <kmc> disambiguate to "this module"?
15:32:34 <kulin> and i dont want to qualify prelude
15:32:40 <hpc> kmc: i think he means like what 'this' does in Java
15:32:49 <ezyang> hiding can be a bandaid
15:32:55 <kmc> hpc, that'd be quite different
15:33:04 <kmc> import Prelude hiding(foo, bar); import qualified Prelude as P
15:33:16 <kmc> kulin, but i'd guess you can use the same qualified name
15:33:22 <kmc> if your module is named Foo, qualifie Foo.bar
15:33:46 <hpc> alternatively, don't clash with Prelude names?
15:33:54 <hpc> or is that not a choice?
15:34:13 <kulin> maybe prelude shouldnt use the good names then! :)
15:34:20 <hpc> heh
15:34:23 <kulin> ill just use hiding, i forgot about that for some reason
15:35:47 <facsimile> man I hate the attitude of normal people, everyone thinks you're some kind of deciectful; bastard if you have some idea they don't understand
15:36:02 <kmc> yup
15:36:07 <kmc> that's why Lisp users are "smug"
15:36:18 <facsimile> I was not thinking of lisp users
15:36:24 <kulin> lets tp their channel
15:36:24 <kmc> they know better ways of doing things and so must be mocked
15:36:42 <kmc> (better than Java, before you all flame me)
15:36:51 <facsimile> I hate IRC and I hate computers, what the hell am I doing here
15:37:09 <hpc> 'better than Java'... that seems a tautology
15:37:11 <illissius> hooray! /me figured out how to do type-level equality checking for type arithmetic.
15:37:17 <Twey> facsimile: Are you an American?
15:37:27 <facsimile> no
15:37:40 <Saizan> illissius: yay! how in particular?
15:37:51 <Twey> facsimile: Interesting
15:38:01 <facsimile> yeah I don't really get that racism stuff
15:38:09 <illissius> hpc: at one point on last.fm there was a movement to tag everything with 'better than radiohead' (radiohead having been the most popular artist since forever); it culminated in everyone tagging radiohead with 'better than radiohead'
15:38:24 <facsimile> you've said somthing to this effect before liek when I said I didn't know a foreign language "oh you're american then"
15:38:25 <hpc> illissius: i love it
15:38:37 <facsimile> kind of rude
15:38:59 <ElMarsh> hi guys, do you know where I could get a haskell bundle for e-textedtior?
15:39:14 <Makoryu> facsimile: Wait, how is it racist to ask if you're American
15:39:15 <hpc> to be fair, demographically america is the only country where you are likely to speak only english
15:39:27 <hpc> and no other languages
15:39:31 <facsimile> Makoryu: the implication
15:39:32 <ElMarsh> that's not true
15:39:39 <Phyx-> hrm.. why is the world spinning
15:39:40 <Makoryu> facsimile: How is it racist?
15:39:42 <illissius> Saizan: class MaybeSame a b where same :: a -> b -> Maybe (SameType a b); data SameType a b where Same :: SameType a a; and then instances for Zero Zero, (Succ a) Zero, and so on
15:40:03 <Saizan> illissius: ah, ok :)
15:40:03 <ElMarsh> anybody know where I can download a Haskell bundle for E texteditor? Or could anybody suggest a good IDE?
15:40:12 <Makoryu> facsimile: I don't know anyone who thinks that "you must be American!" is a racist comment... except a few teabaggers
15:40:19 <Makoryu> facsimile: Are you a teabagger?
15:40:35 <illissius> especially because american isn't a race!
15:40:39 <illissius> except in appalachia
15:40:41 <kulin> elmarsh, im assuming you dont like emacs?
15:40:47 <Makoryu> illissius: Exactly
15:41:02 <Makoryu> illissius: I would expect most people to know the word "prejudice"
15:41:07 <Makoryu> But Americans usually don't
15:41:11 <illissius> it might be jingoist or some other -ist though
15:41:16 <illissius> *shrug*
15:41:22 <ElMarsh> hm, I've never tried it. I'm actually new to Haskell, I use E-texteditor for pretty much everything else so it would've been nice to have haskell on that too
15:41:29 <ElMarsh> I'll check it out though, thanks!
15:41:42 <Twey> facsimile: It's just a pattern I've observed in American culture.  I don't know of any culture where intelligence is mocked quite so often.
15:41:46 * Phyx- thinks he's reached the balmer peek
15:41:56 <jthing> I use vim and emacs.. for haskell usually emacs.
15:42:08 <ElMarsh> eh I've used vim before
15:42:10 <hpc> Phyx-: have fun with that :P
15:42:10 <facsimile> Twey uh i was talking about this channel
15:42:13 <kulin> well emacs is just a general open source editor, but there is a haskell mode which works well enough
15:42:16 <ElMarsh> I'm looking for something more lightweight
15:42:33 <Phyx-> hpc: yes, I'm gonna try and solve some problems with it :)
15:42:36 <kulin> theres not much more lightweight than vim
15:42:47 <ElMarsh> have you ever used the E-text editor or textmate?
15:42:50 <Twey> facsimile: For example, in Japan, ‘good grades’ is part of the stereotypical ‘ideal student’ that all the girls fawn over — in America, it's indicative of the stereotypical ‘nerd’ who's treated with disgust and probably bullied and denigrated by the worse students
15:42:51 <kmc> original vi
15:42:55 <kulin> but ill just get straight to it, i dont know anything about e texteditor, sorry :(
15:43:00 <hpc> original vi is a user's nightmare
15:43:07 <jthing> kulin, acually It is fairly complex. gedit is simple..
15:43:09 <hpc> arrow keys don't work in insert mode
15:43:18 <kmc> on the other hand, japan has a much higher rate of suicide due to poor grades
15:43:21 <ElMarsh> well textmate/e-texteditor is great
15:43:27 <Twey> That's true
15:43:28 <kulin> ed is probably the simplest
15:43:39 <kmc> whereas in America even the dumbest of the dumb will survive to work at McDonalds or go to prison
15:43:41 <illissius> america probably has a much higher rate of suicide due to *good* grades, though i have no evidence.
15:43:45 <jthing> hpc: it is logiacal in it's own way.. If you are used to a typewriter :)
15:43:46 <kmc> yeah
15:43:53 <ElMarsh> yeha I've looked at VIM before, I wouldn't call it lightweight
15:43:59 <Twey> I didn't necessarily say that was a good thing — just something I've noticed in media from the respective countries
15:44:02 <kmc> yeah
15:44:07 <hpc> if you are absolutely deadset on lightweight, use cat >
15:44:13 <hpc> :P
15:44:18 <ddarius> Twey: Perhaps you shouldn't judge countries based on television shows...
15:44:19 <kulin> as an american, i can safely say that in america, ignorance is a virtue
15:44:21 <ElMarsh> g-edit looks nice
15:44:28 <ElMarsh> is there haskell support?
15:44:42 <Twey> Ideally, of course, we wouldn't have any stereotypes at all and everybody would just be judged on their own merits and not compartmentalised ☺
15:45:03 <bremner> I've heard that people like you think like that.
15:45:26 <hpc> Twey: and ideally, we could do all that without having to intimately know someone; stereotypes are a shitty but somewhat necessary shortcut
15:45:27 <jthing> lol
15:45:51 <hpc> it would certainly help if stereotypes weren't so damaging
15:45:52 <facsimile> hpc - you could probably be more openminded and less judgmental
15:45:59 <Makoryu> kulin: Yeah, people here act like "ignorance is bliss" was one of the ten commandments
15:46:05 <facsimile> hpc I know that at least one person would appreiciate it
15:46:26 <Twey> ddarius: Television is an interesting way of getting insight into a culture, because it tends to be a caricature of how the majority actually thinks and behaves… there's a bit of a chicken-and-egg problem as to where the causation lies, but there does seem to be correlation.
15:46:32 <kmc> i think this attitude is pretty recent
15:46:46 <illissius> telepathy -- or just some kind of accurately-read-someone's-character-if-not-their-intimate-thoughts capability -- would be pretty nice.
15:46:58 * ezyang spidey sense OT 
15:47:13 <kmc> during the Cold War, scientific ability was held in high esteem as a way to beat the godless commies
15:47:26 <Twey> hpc: I hear it is possible to actually reserve judgement on someone until you know enough about them to make an informed decision :þ
15:47:50 <facsimile> well the war sucked up all the scentists and killed worthwhile productivity
15:47:55 <facsimile> all you get is bigger bombs
15:48:01 <illissius> kmc: the terrorists are making america stupid by being too incompetent to scare (them/us) enough! it's their secret plan!
15:48:04 <Twey> kmc: But there are hints at it in Miller
15:48:05 <facsimile> so being valued isn't always a good thing
15:48:08 <kmc> yes illissius
15:48:13 <jthing> facsimile, and nucear power
15:48:26 <kmc> plenty of useful tech came out of the cold war
15:48:37 <kmc> such as this here packet-switched telecommunications network
15:48:38 <kulin_> space flight
15:48:50 <flippo> Napalm.
15:49:01 <kmc> microwave ovens (WW2, actually)
15:49:17 <flippo> Agent Orange.
15:49:43 <kmc> if the game is "name something terrible for each useful thing" then i don't dispute that you can keep playing
15:50:32 <jthing> better put spell checking is on...
15:51:08 <jthing> and.. the internet
15:51:40 <jthing> without it I guess you would just be griping at the  local bar ;)
15:51:59 <flippo> Bar arguments just aren't the same with smart phones.
15:52:09 <jthing> Now it can be recorded for all eternity..
15:52:52 <flippo> Someone is always invoking facts and trying to end arguments early.
15:53:16 <ddarius> flippo: That's when you smash them over the head with a beer bottle.
15:53:21 <Zao> This isn't about Haskell. Did you guys miss -blah again?
15:53:34 <hpc> -blah is busy talking about haskell atm
15:53:43 <ddarius> No it isn't.
15:53:58 <Zao> Just regular math.
15:54:33 <hpc> ah, thought i walked in on an algorithm discussion or something
15:54:41 <ezyang> heh :-)
15:54:51 <danharaj> So I've used parsec's buildExpressionParser, and I'm getting a weird result.
16:02:06 <roconnor> oh I ended up in 901th place in the codejam qualifiers
16:27:48 <ElMarsh> hey, can I get emacs for windows?
16:27:57 <ulfdoz> yes
16:28:34 <shapr> ElMarsh: Yes, EmacsW32 works nicely
16:29:22 <wortzer> What is the proper place to ask about Yi architecture?
16:29:35 <ezyang> prolly the mailing list...
16:30:14 <ElMarsh> thank you :)
16:30:33 <ElMarsh> should I install lisp first?
16:30:45 <wortzer> ElMarsh, not really
16:30:46 <ulfdoz> ElMarsh: No
16:30:51 <ElMarsh> awesome, thanks
16:30:59 <ulfdoz> Just extract the zip file, iirc.
16:36:10 <wortzer> I'm working through Real World Haskell. What are some OSS projects I could sharpen my teeth on?
16:37:23 <Polarina> wortzer, xmonad.
16:37:45 <illissius> ok, this is probably a dumb question, but how again do i 'unwrap' an existential type?
16:38:02 <illissius> ghc complains about escaping type variables or non-rigid contexts when i try the obvious-seeming ways
16:39:03 <c_wraith> you can't
16:39:09 <c_wraith> that's kind of the point of an existential type
16:39:20 <c_wraith> You're throwing away all the information about it
16:39:31 <illissius> hmm
16:39:42 <illissius> ok, someone was using the unwrap word earlier
16:40:19 <FunctorSalad> *random thought* does anyone use Writer with some monoid that *isn't* a list monoid? :)
16:40:26 <tensorpudding> there's foldM, mapM, etc., but no unfoldM
16:40:30 <ezyang> FunctorSalad: Of course!
16:40:36 <ezyang> Just the other day I used it with Set.
16:40:36 <mauke> Endo
16:41:04 <FunctorSalad> mauke: that was my thought too... don't have any application for WriterT Endo in mind right now, but it looks funny
16:41:24 <mauke> DList?
16:41:35 <FunctorSalad> ezyang: oh right, here the lack of restricted monads doesn't foil it
16:41:52 <ezyang> yep :-)
16:42:10 <ezyang> WriterT Endo would be pretty funky
16:42:25 <FunctorSalad> with DLists it isn't much different from WriterT [a], is it?
16:42:30 <tensorpudding> I've found recently that I've been rewriting the same function in several places. I've seen it in other languages but it's not in Data.List.
16:42:30 <mauke> DList is Endo
16:42:57 <danharaj> argh, friggin left recursion.
16:43:03 <FunctorSalad> btw I'm just musing about MonadWriter because I'm trying to figure out whether the list monad transformer can sensibly be one
16:43:08 <kmc> Sum and Product could be useful too
16:43:56 <FunctorSalad> correction: whether MonadWriter W N => MonadWriter W (ListT N)
16:44:11 <ezyang> It'd be kind of cool if I could write a function (t :: * -> *) a -> a
16:44:12 <FunctorSalad> the lazy one that has monadic effects at every cell
16:44:27 <FunctorSalad> and at the Nil, and that seems to confuse things...
16:44:35 <FunctorSalad> since there's one more monoid element than lists elements :)
16:44:39 <ezyang> but that would be so unsafe...
16:44:56 <Makoryu> ezyang: The problem being that kind tells us nothing about the structure of the type itself
16:45:10 <ezyang> yep
16:45:18 <Makoryu> ezyang: So "forall t. t :: * -> *" includes (->) r
16:45:30 <Makoryu> And lots of other bad stuff
16:45:31 <FunctorSalad> ezyang: I can't parse that
16:45:51 <ezyang> I'm trying to think of how one could make Sum/Product monoid instances or ZipList/List usable without all of the wrapping and unwrapping
16:46:04 <ezyang> Maybe a Wrapper typeclass with a common function...
16:46:57 <FunctorSalad> hmm, I think there are fundamental obstacles there... the newtypes give the compiler hints after all, so the less wrapping, the more proving needs to go on behind the scenes
16:47:21 <FunctorSalad> Sum/Product is not so bad of course, but it's been debated ad nauseam ;)
16:47:57 <FunctorSalad> (idea 1: Make two Monoid classes according to additive/multiplicative notation; idea 2: Just make a Ring class)
16:48:21 <ezyang> I mean, it's still a monoid, and you might want to use it as such.
16:48:29 <FunctorSalad> (maybe some others :))
16:48:49 <FunctorSalad> hmm is Num a => Num (Sum a)?
16:49:06 <FunctorSalad> if Sum a is a member of enough classes, maybe you wouldn't have to unwrap it ;)
16:50:55 <aristid> FunctorSalad: instance (Num a) => Monoid (Sum a) -- Defined in Data.Monoid
16:51:13 <FunctorSalad> aristid: Num
16:52:11 <aristid> FunctorSalad: nevermind i was misunderstanding
16:52:34 <FunctorSalad> I mean typeclasses and G-N-deriving as an alternative to unwrapping
16:54:36 <aristid> hmm Monoid seems much more wrapper-prone than Monad and i bet there is a reason for it
16:55:23 <kmc> because a lot of very basic types can be made a Monoid in at least two ways
16:55:43 <kmc> Bool is a monoid under (&&) or (||); nums under (+) or (*)
16:56:03 <Makoryu> kmc: I've wondered for a while if Monoid should have two parameters
16:56:17 <kmc> but most types are only a monad in one reasonable way
16:56:28 <ddarius> aristid: Something being a monoid is saying a lot less than something being a monad so its much easier for it to be true in multiple ways or at all.
16:56:41 <gnomnain> can a type be a monad in two ways ?
16:56:49 <FunctorSalad> kmc: Writer Bool? *g*
16:56:53 <kmc> for each M there's usually only one decent way to do (a -> M a) and (M (M a) -> M a)
16:56:54 <FunctorSalad> gnomnain: that one
16:57:00 <kmc> but i' msure there are exceptions
16:57:06 <kmc> [] would be Applicative in two ways
16:57:09 <FunctorSalad> if W is a monoid in two ways, Writer W is a monad in at least two ;)
16:57:14 <gnomnain> D
16:57:18 <kmc> hence the ZipList wrapper
16:57:20 <kmc> FunctorSalad, ;)
16:57:37 <siracusa> Are there predefined functions for setting/retrieving values form a [[val]] at a certain position?
16:57:40 <aristid> ddarius: that explains it
16:57:48 <kmc> siracusa, (!x) . (!y)
16:57:57 <kmc> siracusa, but lists are really not good for random access like that
16:58:14 <ddarius> kmc: !!
16:58:18 <kmc> err right
16:58:19 <kmc> !!
16:58:27 <siracusa> kmc: The Array modules look to complicated :-S
16:58:32 <kmc> ! is for Array which is probably what you want anyway
16:58:38 <kmc> siracusa, they are a bit complicated
16:58:52 <kmc> but it's not too bad and we can help
16:58:59 <kmc> whereas lists are grossly inefficient for this stuff
16:59:06 <kmc> maybe what you want is Data.Sequence
16:59:36 <kmc> which has a list-like interface but is nearly as efficient as arrays
16:59:48 <siracusa> I want a NxN matrix where I can set and get single elements
17:00:11 <siracusa> and if possible without IO
17:00:12 <FunctorSalad> pure?
17:00:46 <siracusa> ST monad would be the way to go I think.
17:00:59 <kmc> siracusa, or regular Array
17:01:00 <FunctorSalad> to mutate that thing purely I think you'd want a Map IndexType Scalar
17:01:03 <kmc> but that involves lots of copying
17:01:15 <kmc> Map (Int,Int) v is worth considering
17:01:18 <kmc> as is Seq (Seq v)
17:01:35 <FunctorSalad> that would copy just O(log n) to modify a single component
17:01:59 <kmc> http://hackage.haskell.org/package/vector is the high-performance vector library
17:02:12 <kmc> it has immutable vectors but i don't think they have efficient update
17:02:20 <siracusa> O(1) is only possible with IO?
17:02:22 <FunctorSalad> IndexType could be an inductive type that has exactly the right number of elements, but I think that's actually slower than (Int,Int) ;)
17:02:44 <FunctorSalad> or a strict Pair maybe
17:03:03 <kmc> siracusa, O(1) update would imply writing over the original value, wouldn't it?
17:03:11 <kmc> in that case you need a mutable-state monad, be it IO or ST
17:03:17 <kmc> ST is exactly as efficient as IO
17:03:26 <tensorpudding> I want my unsafeLaunchMissiles to run in O(1) time
17:03:30 <kmc> IO is a just special case of ST where you're allowed to do more things, and you don't get runST
17:03:36 <FunctorSalad> you could imagine some functional structure that just postpones the problem
17:03:45 <Makoryu> tensorpudding: Didn't you hear? unsafeWakeDaleks is the new unsafeLaunchMissiles
17:03:49 <siracusa> Well, it's a GUI program, so IO would not be too bad.
17:03:52 <FunctorSalad> or not necessarily functional... just a list of updates
17:03:59 <kmc> also http://hackage.haskell.org/package/repa is the new hotness
17:04:15 <kmc> "new" as in "uploaded yesterday"
17:04:16 * ddarius needs to recreate the J dictionary over Repa.
17:04:46 <FunctorSalad> tensorpudding: what's the parameter?
17:05:10 <FunctorSalad> number of missiles? that's quite easily parallelizable no?
17:05:12 <Makoryu> ddarius: Oh man, J
17:05:44 <FunctorSalad> parmap (\x -> unsafeLaunchMissile x `seq` ()) missiles
17:05:46 <kulin_> ive never compiled a program for non-programmers to use before, is there an option to compile all libraries into the program with cabal, or is the problem more sophisticated than that?
17:06:01 <tensorpudding> I suppose I could make a parallel strategy for launching missiles
17:06:22 <Makoryu> @let strictly f = seq f ()
17:06:23 <lambdabot>  Defined.
17:06:26 <ddarius> kulin_: On Linux and Windows, I believe the default for GHC is to always statically link everything.
17:06:26 <Makoryu> :t strictly
17:06:27 <lambdabot> forall a. a -> ()
17:06:44 <tensorpudding> GHC doesn't have dynamic linking does it?
17:06:45 * p_l would love a parallel unsafeRaiseCthulhu
17:06:49 <Makoryu> Hmmm wait
17:07:04 <ddarius> FunctorSalad: You'd have to actually make a parallel array of physical connectors to get it to be O(1).
17:07:14 <Makoryu> p_l: I think that's an inherently locking IO action, unfortunately...
17:07:15 <tensorpudding> I vaguely remember there being a blog entry on my feeds, maybe from Planet Haskell, about someone getting dynamic linking to work, some time ago, but I do not remember.
17:07:22 <Makoryu> So, very much not parallelizable
17:07:29 <FunctorSalad> ddarius: impossible for n -> infty, of course
17:07:31 <kulin_> oh, so then it isnt anything I need to worry about, great
17:07:37 <FunctorSalad> (or is it)
17:07:48 <ddarius> tensorpudding: It had some support of some sort on Mac because it needed to for some crazy Mac reason.
17:07:55 <FunctorSalad> you can only have so many wires branching out from your red button...
17:08:29 <ddarius> FunctorSalad: They don't all have to come from your red button.
17:08:44 <bremner> wireless missile launching ftw
17:08:45 <Makoryu> Or do they?
17:08:47 <FunctorSalad> ddarius: depends on problem spec
17:08:53 <Makoryu> FunctorSalad: Or does it?
17:09:04 <FunctorSalad> ddarius: tensorpudding wanted O(1) missiles for *himself*
17:09:07 <ddarius> FunctorSalad: You can split the wire later and split the splits.
17:09:27 <ddarius> Wireless would be another option.
17:09:28 <FunctorSalad> ddarius: took that into account I think
17:09:48 <kulin_> what is this missle problem, is this a real thing or an inside joke?
17:09:53 <tensorpudding> It's a joke
17:09:55 <ddarius> At any rate, a parallel map would still take O(n) time.
17:10:11 <tensorpudding> @quote unsafeLaunchMissile
17:10:11 <lambdabot> EvilTerran says: {-# LANGUAGE FlexibleMorals #-} -- needed for unsafeLaunchMissiles
17:10:18 <tensorpudding> etc.
17:10:27 <FunctorSalad> you need some minimal amount of *whatever carrier* flowing out from your center to transmit 1 bit of information, I'd think
17:10:46 <FunctorSalad> or to duplicate it, actually
17:11:01 <Makoryu> kulin_: It's a thought experiment used a lot when talking about transactional memory, which relies on being able to automatically undo any transactional operation if a transaction is interrupted
17:11:11 <FunctorSalad> I mean if you have a sphere tightly packed with branching wires or other transmitters
17:11:41 <FunctorSalad> you'll still get transmission time -> ifty as number of nodes to reach -> ifty or not?
17:12:13 <Makoryu> kulin_: Basically, if you allow the programmer to say "atomically { launch_missiles(); do_something_that_might_fail(); }" then your TM system is broken
17:12:13 <FunctorSalad> and I mean a ball
17:12:14 <FunctorSalad> not a sphere
17:12:51 <kulin_> i see
17:13:21 <FunctorSalad> I'm out of my physics knowledge there though to say exactly
17:13:31 <siracusa> Can I store values of type (Int, Int) in an IOArray?
17:13:35 <kulin_> probably you just need a missle defense system that has +1 missles of the previous missle system, on to inifity, then let someone else worry about it after you die
17:13:55 <kulin_> why do i always forget the second i?
17:14:01 <kulin_> my hands are bad at spelling
17:15:09 <kulin_> so TM is a bigger concept than STM for threading I take it
17:16:01 <aristid> kulin_: what's TM?
17:16:07 <kulin_> transactional memory
17:16:20 <FunctorSalad> siracusa: btw maybe an ad-hoc 4-way branching tree (into 4 subsquares) would be considerably faster than Map (Int,Int)? no idea
17:16:33 <aristid> kulin_: what's the difference to STM?
17:16:37 <Makoryu> kulin_: Yup, the original ™ design called for special hardware
17:16:40 <Makoryu> Errrgh
17:16:42 <FunctorSalad> that would easily allow sparse matrices too
17:16:49 <aristid> Makoryu: lol autoreplace?
17:16:58 <Makoryu> aristid: STM doesn't require special hardware.
17:17:01 <Makoryu> And yup
17:17:38 <siracusa> FunctorSalad: The matrices I'm using are pretty small
17:18:06 <aristid> it's viable to make TM hardware? oO
17:18:24 <aristid> Makoryu: i wouldn't have thought of doing that in hardware
17:18:41 <Ke> Sun tried it, I think they released nothing
17:18:45 <Makoryu> aristid: It's not *that* viable
17:19:46 <Makoryu> aristid: IIRC, it would have needed a new FSB design altogether
17:20:00 <Makoryu> And some other awkward requirements
17:20:19 <aristid> Makoryu: maybe memristors will allow TM ;)
17:20:23 <Makoryu> Maybe.
17:20:44 <Makoryu> But we already have STM with nicer semantics than HTM was supposed to give us
17:21:52 <aristid> Makoryu: isn't HTM about performance?
17:23:14 <Makoryu> aristid: I think it started as a way to deal with cache coherency problems (I'm not sure coherency is the right word though)
17:24:13 <Makoryu> So parallelization was the real concern, rather than performance as such
17:24:33 <Makoryu> Though, performance did become one of the major roadblocks to implementing it in hardware
17:25:16 <Makoryu> IIRC, a lot of the tricks used for single-core speedup would no longer work in a HTM system.
17:25:22 <aristid> Makoryu: and now it's implemented in software, with nicer semantics, and also satisfactory performance and parallelism?
17:25:32 <Makoryu> aristid: Pretty much.
17:26:03 <Makoryu> aristid: Of course, STM also still has a bad rep from the time when everyone was trying to implement it for C++
17:26:51 <Makoryu> So you'll still run into people who have heard that STM "will never be ready for prime time"
17:27:08 <aristid> haskell has it already :)
17:27:25 <Makoryu> Yup. Clojure too.
17:27:49 <Makoryu> I suspect all the people who were working on C++ versions are now kicking themselves in the face
17:30:00 <baguasquirrel> oh whatever, everyone's who's working on C++ anything kicks themselves in the face everyday
17:30:06 <scotthw> lol
17:30:12 <baguasquirrel> (sorry, couldn't resist)
17:30:21 <aristid> baguasquirrel: you should've resisted :)
17:30:53 <scotthw> does anyone have experience with http://hackage.haskell.org/packages/archive/fft/0.1.6/doc/html/Math-FFT-Base.html?
17:30:58 <scotthw> Math.FFT.Base
17:31:18 <glguy> "ready for prime-time" and "is supported" aren't quite the same
17:31:47 <scotthw> is that in reference to Math.FFT?
17:31:49 <aristid> scotthw: does it just seem like it, or is the API terrible?
17:31:59 <scotthw> yeah, it confuses the heck out of me
17:32:02 <scotthw> that's what i'm asking
17:32:16 <aristid> glguy: referring to STM?
17:32:16 <scotthw> why* im asking
17:32:41 <glguy> aristid: yeah
17:32:42 <scotthw> well, really, I have a list of Doubles ranging from -1 to 1
17:32:45 <scotthw> and I'd like to do a FFT
17:32:46 <scotthw> that's all
17:32:54 <scotthw> is there an easy way to do this?
17:33:04 <scotthw> do i NEED to convert to complex numbers first?
17:33:35 <aristid> glguy: what are the deficiencies of the current STM implementation that you mean?
17:33:49 <glguy> lack of control of the scheduling and performance
17:34:12 <glguy> it seems more suited to quick prototyping work now
17:35:14 <aristid> glguy: are these problems solvable? or is it a general deficiency of the STM model?
17:38:29 <glguy> I imagine that it could be solved with further work. There is a balance to maintain between being too simple to be useful and too complex to preserve the merits
17:40:49 <sosman> I would like to pass the first 3 elements of a list and the rest to a function like (head (drop 3 ws)) (tail (drop 3 ws)).
17:41:07 <sosman> Feels like there should be a better way.
17:41:14 <sosman> Any tips?
17:41:35 <aristid> sosman: how about splitAt?
17:41:47 <aristid> @src splitAt
17:41:48 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
17:41:59 <sosman> aristid: yes I tried that but that leaves me with a tuple
17:42:02 <ClaudiusMaximus> scotthw: what about http://hackage.haskell.org/packages/archive/fft/0.1.6/doc/html/Math-FFT.html#10
17:42:30 <sosman> so I still need fst and snd
17:42:31 <aristid> sosman: try uncurry
17:42:36 <kmc> sosman, case splitAt 3 ws -> (h, t) -> f h t
17:42:39 <aristid> @src uncurry
17:42:39 <lambdabot> uncurry f p = f (fst p) (snd p)
17:42:40 <kmc> err
17:42:43 <kmc> first -> should be "of"
17:42:57 <sosman> where f could be id?
17:42:58 <ClaudiusMaximus> (note: i never used it, nor the fftw C api)
17:43:29 <kmc> sosman, id h t => h t
17:43:33 <kmc> meaning h would have to be a function
17:43:34 <kmc> which is possible
17:43:36 <kmc> but you didn't imply that
17:43:54 <kmc> :t \f -> uncurry f . splitAt 3
17:43:55 <lambdabot> forall c a. ([a] -> [a] -> c) -> [a] -> c
17:44:38 <sosman> Ok function I am passing these to has other paramaters too.
17:44:44 <kmc> sosman, in this case uncurry does what you want.  but there's an important general technique to learn which is, when you have something (such as a tuple) and need to take it apart, use "let" or "case"
17:44:52 <kmc> case particularly when there are multiple alternatives
17:45:08 <sosman> ok so use let with pattern match
17:45:09 <sosman> ?
17:45:17 <aristid> sosman: either partial evaluation or let with pattern match
17:45:24 <kmc> let (h,t) = splitAt 3 ws in f h t
17:45:30 <kmc> case splitAt 3 ws of (h,t) -> f h t
17:45:34 <kmc> both will work
17:45:55 <sosman> thx
17:46:02 <sosman> That was what I was looking for.
17:46:37 <kmc> there is a difference in laziness, which probably doesn't matter
17:46:43 <aristid> sosman: maybe you enjoy this: http://learnyouahaskell.com/higher-order-functions#curried-functions
17:46:58 <kmc> and you can't use "let" when there are alternatives (e.g. Just versus Nothing) and you want to handle each one separately
17:46:58 <Makoryu> :t curry . splitAt 3
17:46:59 <scotthw> ClaudiusMaximus: I know, I was asking about that package, but it is very confusing...
17:46:59 <lambdabot>     Couldn't match expected type `(a, b) -> c'
17:46:59 <lambdabot>            against inferred type `([a1], [a1])'
17:46:59 <lambdabot>     Probable cause: `splitAt' is applied to too many arguments
17:47:06 <scotthw> the API is pretty awful
17:47:11 <Makoryu> :t curry . splitAt
17:47:12 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
17:47:12 <lambdabot>       Expected type: Int -> (a, b) -> c
17:47:12 <lambdabot>       Inferred type: Int -> [a1] -> ([a1], [a1])
17:47:16 <Makoryu> Pffft
17:47:18 <Makoryu> Oh well
17:47:26 * Makoryu will stop spamming the channel
17:47:52 <ClaudiusMaximus> scotthw: looks like it's based on the fftw3 C api, which is really complicated of itself - i think someone wrote a pure haskell fft code generator at one point...
17:48:32 <scotthw> ClaudiusMaximus: so that's what I'm currently using
17:48:32 <scotthw> http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/Numeric-FFT.html
17:48:55 <scotthw> but my problem is that it requires Complex Doubles as input
17:49:03 <scotthw> I can convert
17:49:15 <aristid> @pl \f -> uncurry f . splitAt 3
17:49:15 <scotthw> but I'm not a math whiz and not sure I am converting correctly
17:49:15 <lambdabot> (. splitAt 3) . uncurry
17:49:31 <fryguybob> scotthw: converting from what?
17:49:43 <scotthw> From Double -> Complex Double
17:49:46 <scotthw> -1 to 1
17:49:47 <ClaudiusMaximus> :t (:+0)
17:49:48 <lambdabot> forall a. (RealFloat a) => a -> Complex a
17:49:49 <scotthw> is what I have now
17:50:26 <scotthw> Yes, but I think it wants something more along the lines of mkPolarPi r  =  r * cos pi :+ r * sin pi
17:50:31 <scotthw> instead of just :+ 0
17:50:43 <scotthw> ?
17:51:13 <kmc> ah
17:51:27 <kmc> isn't that just \x -> (-x) :+ 0
17:51:37 <kmc> > (cos pi, sin pi)
17:51:38 <lambdabot>   (-1.0,1.2246467991473532e-16)
17:51:55 <scotthw> hmm
17:51:59 <fryguybob> scotthw: The real numbers are embedded in the complex numbers, so the natural mapping is just x + 0i
17:52:08 <scotthw> Like I said, not a math whiz
17:52:12 <scotthw> but thank you!
17:53:05 <FunctorSalad> kmc: as someone who isn't so up-to-date with haskell arrays... which parts of `repa' are news?
17:53:11 <FunctorSalad> the multidimensionality?
17:53:54 <Cale> FunctorSalad: The parallelism
17:53:56 <FunctorSalad> oh and "automatic parallelization"
17:54:01 <FunctorSalad> yeah
17:54:58 <Cale> Oh, and the ability to corrupt the heap ;)
17:55:06 <danharaj> My parsec parser is hitting loops and overflowing, how can I examine the execution to see where it's happening?
17:56:20 <Cale> danharaj: That can be tricky, but there are a lot of "obvious" cases for stack overflow. Look for accumulating parameters which don't get evaluated often.
17:56:23 <FunctorSalad> danharaj: something better than "trace"? that's the hard way
17:56:51 <FunctorSalad> in the sense of littering up your whole code ;)
17:56:51 <danharaj> Cale: I'm pretty sure it's a left recursion I accidentally put into the grammar.
17:56:52 <Cale> ah, okay
17:57:18 <Cale> Well, you can also compile with profiling, and then examine the number of entries to each cost-centre (function, roughly)
17:57:30 <Cale> If you're totally at a loss for where it might be
17:57:40 <danharaj> how do I run with profiling?
17:57:41 <Cale> That is, compile with -prof -auto-all
17:57:45 <Cale> and then run with +RTS -p
17:57:51 <danharaj> <3 Cale
17:58:48 <danharaj> huh, well it won't tell me anything, it just stack overflows and exists.
17:58:59 <danharaj> exits*
17:59:17 <Makoryu> Stack overflow, ergo est.
17:59:28 <jmcarthur> danharaj: you did it wrong, you're supposed to say Cale++
17:59:59 <danharaj> But I don't think he needs a new revision.
18:00:03 <Cale> danharaj: Do you see a .prof file?
18:00:06 <Philonous> IS it really desirable to replace Cale with Cale+1 ?
18:00:34 <danharaj> Cale: Oh, I thought it would give me stuff in console :) Yes I do
18:00:34 <ezyang> Does the mutant Cale have superpowers?
18:00:38 <Cale> I was a nilpotent element before, and now I'm a unit!
18:01:12 <kmc> FunctorSalad, the repa paper is pretty good
18:01:46 <danharaj> hmm, this might not be obvious to figure out.
18:01:52 <danharaj> Maybe I'll try trace
18:02:20 <fryguybob> @type "Cale"
18:02:21 <lambdabot> [Char]
18:02:22 <fryguybob> @type ("Cale"++)
18:02:22 <FunctorSalad> danharaj: import Debut.Trace
18:02:23 <lambdabot> [Char] -> [Char]
18:02:43 <mauke> Debut.Tragic
18:02:47 <FunctorSalad> danharaj: the key to using it is that it's completely unsafe, but you want that here
18:02:52 <FunctorSalad> oh
18:02:55 <FunctorSalad> typo
18:02:56 <aristid> fryguybob: in caleskell, Cale is allowed to be any Monoid
18:03:17 <FunctorSalad> (`unsafe' as in not referentially transparent)
18:03:22 <aristid> and therefore Cale++ is a partially applied mappend
18:03:35 <FunctorSalad> > let x = trace "foo" 1 in x + x
18:03:36 <lambdabot>   Not in scope: `trace'
18:03:46 <kmc> it's not really unsafe, because it doesn't change the semantics of your program
18:03:48 <FunctorSalad> will print one message, but inlining it will print two
18:03:59 <FunctorSalad> or zero if that let-expression is never used
18:04:05 <kmc> if you ignore trace printing
18:04:19 <FunctorSalad> yeah, I just meant with respect to that
18:04:26 <Cale> danharaj: What does your .prof file look like?
18:04:27 <FunctorSalad> (and like I said you want that)
18:04:29 <kmc> trace prints a line when an expression is evaluated.  this is how print works in most languages,  but it's unintuitive with lazy eval
18:04:37 <kmc> and with optimizations as FunctorSalad pointed out
18:04:40 <Cale> danharaj: Look at the column which lists the number of entries to each thing
18:04:46 <danharaj> Cale: a list of functions that looks like a wave :p
18:04:50 <Cale> danharaj: Find things with particularly large number of entries
18:05:01 <Cale> danharaj: Chances are, the problem is nearby to one of those
18:05:19 <danharaj> Cale:The highest numbers are spread out nearly throughout :|
18:05:25 <Cale> mmm
18:05:29 <FunctorSalad> kmc: it just confused me the first time when I added tracers to a program which I thought of as proceeding like an imperative one would... and everything was reverse-order :o
18:05:36 <pastorn> i'm drunk now
18:05:39 <pastorn> i should haskell
18:05:40 <Cale> danharaj: Could it be that the loop involves all of those?
18:05:43 <FunctorSalad> but that's the point
18:05:49 <danharaj> It hangs on parsing comparisons like (2>9) when the operator is illegal, like 2>>9
18:05:55 <danharaj> I don't know why, it should just quit.
18:05:58 <pastorn> ask em anything!
18:06:10 <pastorn> everythidng typechecks in my head at the moment!
18:06:18 <mauke> pastorn: how do I shot web?
18:06:32 <kmc> pastorn, smoke a big bowl and *then* do haskell
18:06:34 <pastorn> shot :: Web -> IO ()
18:06:47 <pastorn> mauke: gimme something hard for gods sake!
18:07:00 <FunctorSalad> @type gfoldl
18:07:01 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
18:07:04 <FunctorSalad> pastorn: ^^^^
18:07:34 <applicative> src gflold
18:07:41 <applicative> @src gfoldl
18:07:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:07:50 <pastorn> @hoogle Data
18:07:51 <lambdabot> module Data.Data
18:07:51 <lambdabot> Data.Data class Typeable a => Data a
18:07:51 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
18:09:14 <pastorn> FunctorSalad: amagad wat?
18:09:27 <FunctorSalad> pastorn: you wanted something hard no? :(
18:09:29 <pastorn> i asked for something hard, not somithing impossible
18:09:44 <pastorn> FunctorSalad: can haz vocubaulary skillz @ ur side
18:09:48 * mauke used harden
18:09:58 <FunctorSalad> pastorn: wut?
18:10:14 <pastorn> wut wut
18:10:14 <FunctorSalad> that's a perfectly cromulent sentence except for missing a comma
18:10:21 <FunctorSalad> in front of "no"
18:10:43 <danharaj> aha! I see what's wrong
18:10:44 <pastorn> FunctorSalad: give me ONE use of gfoldl
18:10:57 <pastorn> otherwise i'll dismiss it as abstract nonsense
18:11:02 <aavogt> @src gmapQ
18:11:02 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:11:08 <FunctorSalad> pastorn: gmapQ and gmapT? ;)
18:11:19 <mauke> :t gmapQ
18:11:20 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
18:11:25 <FunctorSalad> which are useful to implement everything and everywhere
18:11:31 <mauke> :t everywhere
18:11:33 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
18:11:34 <aavogt> haha
18:11:35 <FunctorSalad> which will make you rich
18:12:52 <FunctorSalad> (iirc the gmaps are really special cases of gfoldl, they're just methods for speed)
18:12:52 <pastorn> FunctorSalad: CAN HAZ POT OF GOLDZ/
18:12:58 <pastorn> !??!??!?!?7
18:13:17 <aavogt> yeah, but do people use gfoldl directly?
18:13:34 <mauke> pastorn: how can I write getCC with Control.Monad.Cont?
18:13:37 <FunctorSalad> not that I knew... these two and the monadic one
18:13:46 <FunctorSalad> gmapM or so
18:13:52 <pastorn> mauke: amagad fagg u
18:13:58 <pastorn> i don't remember
18:14:06 <pastorn> it was hard!
18:14:12 <FunctorSalad> ContT would be my next idea too
18:14:12 <aavogt> @hoogle getCC
18:14:13 <lambdabot> No results found
18:14:24 <aavogt> @hoogle callCC
18:14:25 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
18:14:26 <FunctorSalad> surround it with some reverse state transformers for flavour maybe
18:14:26 <pastorn> mauke: can haz logs?
18:14:39 <baguasquirrel> hunh...  looks like I remembered incorrectly
18:14:40 <baguasquirrel> http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/src/Text-JSON-Generic.html#toJSON
18:14:45 <pastorn> mauke: don't you have any logs?
18:14:48 <baguasquirrel> the generics module for JSON doesn't use gfoldl
18:14:48 <pastorn> @where log
18:14:48 <lambdabot> I know nothing about log.
18:14:52 <baguasquirrel> it does use gmapQ though
18:14:55 <pastorn> @where logs
18:14:55 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
18:14:57 <aavogt> pastorn: see /topic
18:15:01 <aavogt> oh or there too
18:15:21 <scotthw> is there such a thing as a double map?
18:15:27 <scotthw> like if i have a list of lists
18:15:28 <pastorn> aavogt: spamming the log is way of showing love, don't you know that?
18:15:32 <scotthw> and i want to map to the lists inside the lists
18:15:35 <pastorn> BFOL
18:15:45 <pastorn> (basic fact of life)
18:15:55 <FunctorSalad> scotthw: fmap fmap fmap
18:15:59 <FunctorSalad> seriously :(
18:16:01 <Makoryu> scotthw: doubleMap f = map (map f)
18:16:13 <Makoryu> Also: map . map
18:16:15 <pastorn> @type fmap fmap fmap
18:16:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:16:17 <Makoryu> Also: fmap . fmap
18:16:34 <FunctorSalad> > fmap fmap fmap ord [['a','b']]
18:16:36 <lambdabot>   [[97,98]]
18:16:38 <FunctorSalad> ^^
18:16:48 <scotthw> OK!
18:18:33 <gwern> @quote blind
18:18:34 <lambdabot> No quotes match. You type like i drive.
18:19:13 <FunctorSalad> scotthw: ok, to be fair, it is correct, but obfuscated :) "(fmap . fmap) f mylist" or "fmap (fmap f) mylist" are more idiomatic
18:19:25 <gwern> I see we lost the quote about 'if you play too much with your monads, do you go blind?'
18:19:34 <FunctorSalad> gwern: BIND
18:19:36 <FunctorSalad> not blind
18:19:44 <gwern> @quote play.*bind
18:19:45 <lambdabot> DavidLeimbach says: Don't play with your monads... eventually you'll go bind.
18:19:48 <FunctorSalad> that was the funniest part
18:20:01 <FunctorSalad> (because there is no real joke)
18:20:42 <aavogt> @google monod
18:20:43 <lambdabot> http://en.wikipedia.org/wiki/Jacques_Monod
18:20:43 <lambdabot> Title: Jacques Monod - Wikipedia, the free encyclopedia
18:21:10 <FunctorSalad> (so it gets reverse joke-psychology points)
18:21:40 <aavogt> hmm, no Operon in haskell yet?
18:22:13 <FunctorSalad> (I mean, you expect a continuation of the sexual allusion... and then bam, a dumb pun with no deeper meaning)
18:24:28 <sosman> Trying to learn Haskell and by writing syslog parser at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25395#a25395.  TimeStamp is currently a string and I would like to turn it into some kind of haskell timestamp (line 38) but not sure what type TimeStamp would be (line20).
18:26:27 <FunctorSalad> sosman: UTCTime or ZonedTime probably... to warn you, the lib is slightly user-hostile due to going on about leap seconds ;)
18:26:28 <rovar> http://gist.github.com/394874
18:26:42 <sosman> I guess part of the newbie challenge is to parse "parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t"
18:26:43 <rovar> the compiler is complaining about a syntax error at the last semicolon
18:26:45 <FunctorSalad> in fact I'm not sure if you want UTCTime or the other UTC
18:26:51 <rovar> anyone know what stupid thing I did this time?
18:27:08 <aavogt> rovar: you need more {}
18:27:23 <aavogt> around the stuff after the let
18:27:37 <rovar> ?
18:27:46 <aavogt> @where report
18:27:46 <lambdabot> http://www.haskell.org/onlinereport/
18:27:55 <FunctorSalad> ZonedTime has both a time zone and a local time IIRC, at least that part is how it should be ;)
18:28:04 <aavogt> if you're going to use explicit {};, you should read how it is defined
18:28:14 <aavogt> it's not as obvious as layout
18:28:33 <ddarius> Layout is defined in terms of brackets...
18:28:41 <FunctorSalad> @type parseTime
18:28:42 <lambdabot> Not in scope: `parseTime'
18:28:50 <FunctorSalad> @type Data.Time.parseTime
18:28:51 <lambdabot> forall t. (time-1.1.4:Data.Time.Format.Parse.ParseTime t) => System.Locale.TimeLocale -> String -> String -> Maybe t
18:29:18 <Makoryu> rovar: Change "let y = x + 1;" to "let { y = x + 1 };"
18:29:23 <FunctorSalad> > Data.Time.parseTime undefined "%H%M" "0329"
18:29:24 <lambdabot>   Not in scope: `Data.Time.parseTime'
18:29:42 <FunctorSalad> I'm not sure whether it lets you get away without a locale with format specifiers that don't use it
18:30:03 <rovar> aavogt, Makoryu: Thanks.
18:30:04 <FunctorSalad> getting the locale is another annoying IO op iirc
18:30:08 <rovar> now I need to look into why that is
18:30:13 <aavogt> ddarius: I mean you can get layout right without thinking about... after this keyword, there should be a { ...
18:30:36 <aavogt> rovar: it's probably nicer to write it without the do:
18:30:47 <aavogt>   let y = x + 1 in return (y,y)
18:30:48 <rovar> yea
18:31:06 <sosman> FunctorSalad: parseTime is Maybe t - doesn't match UTCTime.
18:31:07 <Makoryu> rovar: If you use explicit braces, everything inside that also needs explicit braces. That's the problem.
18:31:08 <FunctorSalad> > Data.Time.Format.Parse.parseTime undefined "%H%M" "0329" :: Maybe UTCTime
18:31:09 <lambdabot>   Not in scope: type constructor or class `UTCTime'Not in scope: `Data.Time.F...
18:31:29 <FunctorSalad> sosman: the `t' will be your time type
18:33:07 <aavogt> @hoogle locale
18:33:08 <lambdabot> No results found
18:33:34 <FunctorSalad> wasn't there some way to do multiple commands with ghc -e?
18:33:37 <aavogt> @hoogle defaultTimeLocale
18:33:38 <lambdabot> No results found
18:33:46 <FunctorSalad> it's useful for :i or :bro
18:33:59 <aavogt> FunctorSalad: yeah, just do multiple -e 'f x y' -e 'g ab'
18:34:08 <FunctorSalad> aavogt: ahh thanks
18:34:20 <FunctorSalad> tried \n and ^Q^J to no success
18:34:23 <aavogt> each -e corresponds to one line you input into ghci
18:34:58 <danharaj> Argh. More left recursion.
18:34:59 <aavogt> so   ghc -e ':m Data.List' -e 'sort "qwerty"'  -- this should work
18:35:51 <FunctorSalad> hmm and is there a command to dump *all* the database? it's there, as evidenced by tab completion ;)
18:36:05 <rovar> two more dumb questions, what module do I import to get Handle? Hackage says it's part of GHC.IO.Handle but I can't import that.
18:36:07 <FunctorSalad> ok, the package list can be grabbed through ghc-pkg
18:36:14 <FunctorSalad> err, the module list
18:36:22 <aavogt> rovar: probably System.IO
18:36:23 <FunctorSalad> ghc-pkg field exposed-modules or so
18:36:45 <aavogt> you could import GHC.IO.Handle if you   load with  -package ghc... but don't :)
18:36:48 <rovar> 2nd, Network.Socket list's AF_INET as a data constructor, but GHC disagrees
18:36:53 <rovar> aavogt, thanks :)
18:37:34 <FunctorSalad> maybe that stuff is guarded by #ifdefs
18:37:36 <rovar> nevermind on the 2nd question
18:37:52 <FunctorSalad> and you didn't have the include files where it could find them?
18:38:18 <FunctorSalad> I'm probably confusing it with another low-level library :(
18:40:02 <danharaj> I really like how easy it is to follow the execution of a program in haskell.
18:40:05 <danharaj> Compared to say, C++.
18:41:24 <FunctorSalad> danharaj: it's partly because lack of implicit mutation I think
18:42:08 <FunctorSalad> (a function can't be involved in anything that isn't evidenced in the type)
18:43:08 <danharaj> FunctorSalad: Yeah. Still don't have the hang of factoring left-recursion out of my parsec parser :\
18:43:33 <FunctorSalad> though that comes with the disclaimer that all bets are off for the IO type
18:43:52 <FunctorSalad> (from the abstract level's pov)
18:44:35 <FunctorSalad> danharaj: can't find the path it's looping in?
18:45:13 <danharaj> I know the path.
18:45:22 <danharaj> I'm just trying to figure out the best way to avoid it.
18:46:28 <FunctorSalad> hmm not a parsing theorist
18:47:03 <FunctorSalad> I *think* happy deals with left recursion automatically? but it's much less convenient than parsec
18:47:31 <FunctorSalad> (preprocessing step, confusing trace)
18:48:49 <danharaj> IIRC Happy generates LALR parsers, and Parsec is LL
18:48:50 <FunctorSalad> danharaj: parsec has a module for precedence parsing too, if that's where your left recursion happens
18:49:16 <tomberek> edwardk: ya there?
18:49:24 <edwardk> yeah
18:49:26 <FunctorSalad> hmm but parsec can execute arbitrary code
18:49:37 <FunctorSalad> can it still be said to be LL on some level?
18:49:49 <edwardk> wrestling with a bug
18:50:02 <danharaj> FunctorSalad: I don't understand.
18:50:40 <FunctorSalad> danharaj: I mean, a parsec parser could just munch all tokens linearly and then run an arbitrary haskell program on it
18:50:49 <tomberek> edwardk: can I quiz you on you annotated graph stuff?
18:50:57 <FunctorSalad> but maybe we're restricting to only some parsec primitives?
18:51:09 <danharaj> FunctorSalad: Yeah. No trickery :)
18:51:17 <edwardk> @hpaste
18:51:17 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:51:32 <danharaj> FunctorSalad: Although you give me an idea to check for this infinite loop :D
18:51:36 <tomberek> edwardk: I was wondering if memorization can do the same thing as annotation, or am i missing something?
18:52:35 <edwardk> memoization solves a different problem
18:52:40 <FunctorSalad> danharaj: you can write a more controlled log by using ParsecT with the underlying monad being IO, Writer or State
18:52:49 <FunctorSalad> (more controlled than with `trace')
18:53:16 <danharaj> FunctorSalad: It's not necessary. I understand the problem, I just  don't want to fix it with a kludge.
18:53:23 <edwardk> Hrmm, can someone take a look at http://paste.lisp.org/display/98978 and help me figure out what the heck i screwed up with deleteMin ? it hangs every time i try something like deleteMin $ fromList [10,9..1]
18:53:34 <tomberek> edwardk: memoization vs annotations?
18:53:36 <edwardk> for reference i can point to http://www.eecs.usma.edu/webs/people/okasaki/jfp96/final.sml which should work correctly
18:54:23 <edwardk> tomberek: memoization answers the fact that a given function and argument pair has given an answer before, the annotations evolve with a changing structure and the branding keeps you from misusing them
18:54:50 <danharaj> On some inputs I get into an infinite loop because I try to parse a boolean expression, which tries to parse a comparison of arithmetic expressions, which might contain integer-valued conditionals which try to parse boolean expressions which try to parse a comparison...
18:55:09 <danharaj> All without consuming input. I just have to figure out how to say "Hey, this isn't going to work."
18:56:01 <tomberek> edwardk: i was looking at your Degree 'Annotated' Graph and I don't see how it evolves with the structure, I just see degrees being calculated and tacked on into the tuple. I still don't understand the difference
19:05:12 <tomberek> edwardk: maybe the comonad instance needs to be fixed, but if we say we want the annotation to be updated with the graph, why don't we just store two graphs (perhaps different implementations) and run the function on both through a common API?   In the code : extend f ea = (fst ea, f ea) I don't see how annotations are updated, they seem the same.
19:06:16 <edwardk> the key observation is that the actions that change the shape of the graph aren't comonadic.
19:06:30 <edwardk> that is perhaps where your confusion comes in.
19:07:10 <tomberek> but annotations can change without a structure change
19:08:18 <edwardk> you can create a new annotation out of whole cloth, and you can wrap it up in the comonad, etc, sure.
19:08:51 <edwardk> but any time you change the shape of the graph you get a new brand, and the operation that changes the shape of your graph updates the annotations that are wrapped in the comonad
19:09:02 <edwardk> which is the incentive to bundle them
19:09:45 <tomberek> edwardk: I guess I'm less sold on annotations,, I'm trying to believe! hehe.   I was going to ask you another thing, about approaching the basic interface to graphs from a set perspective, namely ensuring subsets via the type system
19:11:10 <edwardk> i'm somewhat neutral on them myself. what i like about them is that the garbage collection story is good. the memory footprint, especially when updating them heavily, is good. that you can encapsulate a lot of algorithms into an 'online' form that allows you to update the answer as the graph changes shape, etc.
19:11:24 <edwardk> what i don't like is that the brands are a pain in the behind to manage
19:11:47 <edwardk> and that folks don't have a good mental model for comonads
19:11:55 <tomberek> gc is good? hell, my whole problem with FGL is bad GC
19:12:05 <edwardk> that was the point
19:12:09 <edwardk> you separate shape from data
19:12:50 <tomberek> hm, would you mind looking at what i did with Data.Vector and comonads, give me some pointers?
19:12:54 <edwardk> your graph shape knows node numbers or whatever that don't change as the data shifts, which you can use to index into an unboxed array or vector, etc.
19:13:30 <edwardk> that way as you run a bunch of passes you are just mangling unboxed vectors and not a ton of fiddly bits strewn all over the graph itself
19:14:01 <edwardk> sure, let me chase down this bug first, since i'm not getting very far with my attention split ;)
19:14:07 <edwardk> and then i'll switch gears =)
19:14:25 <tomberek> edwardk: i like the idea, i just get lost easy... I have to go soon.  Ok if I email it?
19:14:31 <edwardk> sure
19:20:03 <DigitalKiwi> this pages says lists can hold anything
19:20:15 <DigitalKiwi> so functions too?
19:20:29 <Makoryu> Yup
19:20:44 <Makoryu> :t [const, asTypeOf]
19:20:44 <lambdabot> forall a. [a -> a -> a]
19:20:47 <ClaudiusMaximus> :t [(<),(<=),(==),(>=),(>)]
19:20:48 <lambdabot> forall a. (Ord a) => [a -> a -> Bool]
19:21:03 <Makoryu> :t [id, toUpper, toLower, toTitle]
19:21:03 <lambdabot> [Char -> Char]
19:21:13 <DigitalKiwi> hmm, k
19:21:14 <DigitalKiwi> thanks
19:21:38 <DigitalKiwi> sometimes people say one thing but mean another
19:21:40 <DigitalKiwi> >.>
19:22:06 <DigitalKiwi> or like "oh i didn't think of that when i said that"
19:23:23 <Makoryu> :t [readIO, putStrLn]
19:23:24 <lambdabot> [String -> IO ()]
19:23:46 <FunctorSalad> random idea... monadic patterns? f M[x] = ... would translate to f m = m >>= (\x -> ... ) ?
19:24:09 <FunctorSalad> 'M' is the monad, though it could just be inferred
19:25:17 <FunctorSalad> too obvious for nobody to have considered and rejected it of course
19:25:38 <Cale> edwardk: What's this about comonadic graph transformations?
19:25:47 <FunctorSalad> one would have to define an ordering of pattern positions
19:26:20 <Cale> FunctorSalad: It's really rare to want that sort of thing in the first place...
19:26:42 <Cale> FunctorSalad: What's the point of taking an action as a parameter if the first and only thing you're going to do with it is run it?
19:26:57 <Cale> Just take the result as a parameter instead.
19:28:22 <FunctorSalad> Cale: hmm, when defining monad transformer you often must take monadic values as args
19:29:05 <Cale> hmm
19:29:25 <Cale> I'm not sure I know what you mean... are you sure you're not just looking for liftM2 or ap or something?
19:29:57 <FunctorSalad> in your example one has control over the type of the function, apparently
19:30:02 <aristid> @src ap
19:30:02 <lambdabot> ap = liftM2 id
19:30:27 <FunctorSalad> this could at least be useful if you do indeed just want to run it once :) but are forced to a certain signature
19:30:47 <FunctorSalad> admittedly I didn't see the loss of generality there at first
19:31:28 <FunctorSalad> Cale: about monad transformers, for example, the type of lift forces a monadic value as input
19:31:50 <aristid> where does lambdabot get its @src database from, btw?
19:31:52 <FunctorSalad> or methods like `listen'
19:32:03 <Cale> uh, sure, but it doesn't produce the same type of monadic action as the result
19:32:10 <Cale> So your notation wouldn't be useful there
19:32:16 <Cale> lift :: m a -> t m a
19:32:38 <Cale> So if you were to immediately run the action of type m a, your result would have type m a
19:32:42 <Cale> which is inappropriate
19:32:44 <FunctorSalad> oh right, there must be some postprocessing of the rhs too
19:32:49 <ddarius> edwardk: You have a variable shadowing error
19:32:52 <ddarius> I suspect.
19:32:54 <FunctorSalad> can't always be the top level
19:33:24 <Cale> aristid: A hand-crafted text file
19:33:27 <edwardk> ddarius: oh?
19:33:49 <edwardk> ddarius: ooh, adding -Wall and checking
19:34:14 <aristid> Cale: a suggestion then. :) maybe ap = liftM ($) would be easier to understand for some people?
19:34:20 <ddarius> edwardk: The f in the pattern of deleteMin is never used.
19:34:25 <aristid> *liftM2 ($)
19:34:28 <FunctorSalad> Cale: the picture I have in mind is that it's common to define homomorphisms by defining them on generators
19:34:42 <FunctorSalad> Cale: which of course is just what (>>=) is for a monad from algebra
19:34:43 <Cale> aristid: yes, I had that idea when I saw the output it gave you there too
19:34:48 <edwardk> ahhh
19:34:55 <edwardk> thank you thank you thank you =)
19:35:37 <FunctorSalad> but I agree it seems to narrow if it can only produce functions of type "m a -> m b -> .... m z"
19:35:40 <edwardk> getMin should be using the one from the pattern, thats the culprit
19:37:19 <FunctorSalad> (it seems you get exactly the liftMns, yes)
19:38:11 <aristid> @unpl ap
19:38:12 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
19:38:30 <edwardk> ddarius: that fixed it!
19:38:50 <FunctorSalad> the objective is to save a name, of course
19:39:07 <FunctorSalad> (but you do that with "liftM (\x -> ...)" too)
19:39:21 <ddarius> edwardk: What's wrong with the record definition of Tree?
19:40:08 <FunctorSalad> Cale: the "M[x]" was inspired by the meaning in logic as 'formula which may have free occurences of x'
19:40:38 <edwardk> ddarius: the Show instance was a pain in the butt for debugging ;)
19:40:44 <edwardk> i'll flip it back before i call it done
19:41:20 <aristid> @unpl liftM
19:41:20 <lambdabot> liftM
19:41:20 <FunctorSalad> from that perspective the pattern shouldn't be followed by a "=" at all, since the RHS is what is being *substituted* for x
19:41:54 <FunctorSalad> the monad is some term structure monad in this case of course
19:42:26 <edwardk> i should also move the child counts out all the way into the Heap constructor rather than leave it in the Node constructor =/
19:44:09 <edwardk> ddarius: annotated with the correction: http://paste.lisp.org/display/98978#1
19:44:23 <FunctorSalad> Cale: ok, I think what I really wanted, it seems, is the expression "m[x/...]" as sugar for "m >>= (\x -> ...)"... which is too trivial to warrant a syntax of course
19:45:00 <FunctorSalad> that would make case in the sense of some term monad with substitution as bind, anyway
19:46:14 <ddarius> edwardk: Ah
19:46:17 <edwardk> ddarius: do you think it is worth the complications of baking leq into the constructor like that in order to be able to support Foldable, etc?
19:46:30 <ddarius> edwardk: It's... unusual...
19:46:44 <edwardk> i used it once before in my BitSet
19:46:54 <ddarius> edwardk: Is it possible for heaps with different leqs to come together?
19:46:59 <edwardk> nope
19:47:12 <edwardk> since they only ever get constructed when there was an Ord instance available. so you have confluence
19:47:18 <edwardk> and the Heap constructor isn't exposed
19:47:43 <ddarius> So if I break out IncoherentInstances...
19:48:11 <edwardk> then you might be able to construct a multi-module masterpiece that shoots yourself in the foot ;)
19:49:32 <edwardk> the only one that i actually hand construct is for groupBy since i need to lift one into an instance for [a]
19:49:32 <ddarius> :t foldMap
19:49:33 <lambdabot> Not in scope: `foldMap'
19:49:37 <ddarius> @hoogle foldMap
19:49:38 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:49:38 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
19:50:34 <FunctorSalad> apropos foot-shooting: "do { x <- $1, y <- $2 ..."  anyone? ;)
19:51:08 <edwardk> er rather i needed to duplicate the implementation of (<=) for [a] given one for a :: (a -> a -> Bool) -> [a] -> [a] -> Bool
19:51:25 <FunctorSalad> that's not the way to solve it... but it does seem that sometimes there are names whose only purpose is to be passed to (>>=)
19:52:40 <Accidus> I'll try here: I'd like a hint to a Mac Lane exercise --- an example of a CCC A and a small category J such that A^J is not CCC.
19:54:06 <aristid> @pl product [1..n]
19:54:06 <lambdabot> product [1..n]
19:54:12 <aristid> @pl \n -> product [1..n]
19:54:13 <lambdabot> product . enumFromTo 1
19:54:20 <luite> how would you guys try to solve recurrence relations like: F[n,m] = F[n-1,m] + max(F[n-2,m-1],F[n-1,m-2]), with F[0,m] = F[n,0] = 1
19:55:13 <FunctorSalad> Accidus: no idea, your stock non-cccs are the algebraic ones I guess (e.g. abelian groups, where you need a tensor product in the place CCC specifies product...)
19:55:33 <FunctorSalad> but they aren't simply Set^J...
19:55:51 <ddarius> FunctorSalad: A subcategory.
19:56:00 <FunctorSalad> ddarius: doesn't help him
19:56:11 <FunctorSalad> it must be A^J exactly
19:56:17 <ddarius> Indeed.
19:58:14 <FunctorSalad> hmm ccc implies that product-with-X (X fixed) is colimit-preserving
19:58:22 <FunctorSalad> maybe something where that fails
19:58:58 <ddarius> Accidus: Exercise 5 in IV.6 of "Categories for the Working Mathematician" is "For any J, prove that A cartesian closed implies A^J cartesian closed."
19:59:56 <Accidus> ddarius, What? In my version it says the opposite!
20:00:57 <FunctorSalad> yours specifies "small", which is a contradiction a fortiori though
20:01:03 <Accidus> ddarius, are you sure you're reading it correctly? It says "need not imply"
20:01:14 <ddarius> Accidus: I quoted it.
20:01:43 <FunctorSalad> (if what ddarius quotes is true, then there is no J at all with the prop, so no small one...)
20:02:30 <FunctorSalad> I'd check who has the more recent version
20:02:37 <FunctorSalad> if it is indeed a contradiction
20:03:02 <Accidus> ddarius, the exercise you quoted says "Show that A cartesian closed need not imply A^J cartesian closed."
20:04:36 <ddarius> Mines the first edition, so perhaps there is errata somewhere.
20:05:40 <Accidus> Mine is also the first edition, and I just googled up the 2nd edition
20:05:45 <FunctorSalad> surely there's some errata database site... google doesn't seem to help at first glance
20:05:55 <FunctorSalad> ("errata" "categories for the working mathematician")
20:14:30 <ddarius> Accidus: There could be issues with size that lead to differing conclusions.
20:15:25 <FunctorSalad> as I said...
20:15:41 <FunctorSalad> the extra condition strengthens the contradiction between your versions
20:18:11 <FunctorSalad> why is every function of a type "M A -> M B" writeable as a bind for vector spaces and I think other free structures, but not for, say, M = State S?
20:19:01 <FunctorSalad> you know what I mean... "why"="is there some important property seperating the two classes"
20:19:09 <Accidus> FunctorSalad, as none of the versions mention size --- that just doesn't make sense
20:19:34 <FunctorSalad> Accidus: your first message said 'small'
20:19:45 <Accidus> Yes, but that was my addition
20:20:06 <FunctorSalad> how's that me not making sense then :)
20:20:21 <FunctorSalad> I just said something about these 2 versions
20:20:45 <ManateeLazyCat> Hi all. :)
20:21:06 <FunctorSalad> hi ManateeLazyCat
20:21:35 <ManateeLazyCat> FunctorSalad: Hi.
20:21:55 <ManateeLazyCat> FunctorSalad: Login #haskell for rest a moment. :)
20:22:13 <Accidus> ddarius, are you sure you're not confusing with III.5.5? (but the phrasing is completely different)
20:23:55 <FunctorSalad> wait, or *is* every f :: M A -> M B equal to (=<<) (f . return) ?
20:24:23 <Cale> :t (=<<) (?f . return)
20:24:24 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (?f::m1 a -> m b, Monad m1, Monad m) => m a -> m b
20:24:26 <FunctorSalad> Cale: still going on about how much of a loss of generality that binding style is
20:24:51 <FunctorSalad> at least for free algebraic structures it is none
20:24:53 <FunctorSalad> I think
20:25:01 <FunctorSalad> as long as the target is some "M B" too
20:25:09 <Cale> FunctorSalad: It's a huge loss of generality for everything except commutative monads.
20:25:39 <Accidus> Hmm...? What binding style?
20:26:01 <FunctorSalad> functions of the form "f m = m >>= (\x -> ....)"
20:26:30 <FunctorSalad> Cale: are you sure you can't just perform the effects in the "..."? remember it returns M B, not B (as with liftM)
20:27:00 <Cale> FunctorSalad: You lose the ability to perform the effects associated with m later
20:27:49 <kmc> does "commutative monad" have the obvious meaning of f <=< g === g <=< f ?
20:28:04 <Cale> kmc: well, not quite
20:28:20 <FunctorSalad> Cale: hmm but for algebras it is so, or am I missing something too
20:28:39 <Cale> kmc: it means roughly that (do v <- x; w <- y; f x y) = (do w <- y; v <- x; f x y)
20:28:49 <Cale> FunctorSalad: ?
20:28:49 <FunctorSalad> a homomorphism out of a free alg is the extension of its restriction to generators
20:29:04 <Cale> FunctorSalad: I'm afraid I don't understand how you're thinking about this.
20:29:21 <Cale> What algebras?
20:29:32 <Cale> The algebras of the monad?
20:29:40 <FunctorSalad> Cale: M = free {module,group,...} monad
20:29:48 <kmc> Cale, ok.  so actions are only required to commute if they don't depend on each other's results
20:29:48 <Cale> ...
20:29:51 <Cale> hmm
20:29:58 <FunctorSalad> monads arising from universal algebra algebraic structures
20:30:27 <Cale> okay, give me a minute to try to connect that way of thinking with what we're talking about here
20:30:34 <FunctorSalad> take vector spaces as the easiest case... a linear map is equal to the extension by linearity of its restriction to the basis
20:30:47 <FunctorSalad> ("the" since M A is the vector space freely generated by A)
20:30:50 <Cale> Can we just use the free monoid monad?
20:30:54 <kmc> Cale, so something like:  liftM2 f x y === liftM2 (flip f) y x
20:30:57 <Cale> (aka the list monad)
20:31:01 <FunctorSalad> that should work too
20:31:03 <Cale> okay
20:31:10 <kmc> that definition would work for applicatives as well... are there "commutative applicatives"?
20:31:13 <Cale> so consider f x = x >>= g for some g
20:31:15 <ddarius> Accidus: Cartesian closed categories are introduced in section IV.6, there would be no exercises about them earlier and again, that was an exact quote of the exercise from the book, it doesn't matter where it came from.
20:31:44 <FunctorSalad> Cale: odd... with the list monad I can think of counterexamples myself ;)
20:31:58 <Cale> We can't, in particular, write h x = x >>= \u -> x >>= \v -> return (u,v)
20:32:06 <Cale> in that form
20:32:16 <FunctorSalad> "reverse" at some monotype is not the bind-lift of some A -> M A, sure
20:32:57 <FunctorSalad> but wait! that's not a monoid homo
20:32:59 <Cale> oh, and sure, there will be lots of stuff which is list-specific that is inaccessible
20:33:17 <FunctorSalad> that's the thing
20:33:22 <Accidus> ddarius, The problem is that I also have the 1st edition of the book, and the question is phrased differently to what you said
20:33:26 <Cale> But that's not what I'm talking about
20:33:28 <Cale> look at my example
20:33:44 <Cale> It's just a simple Cartesian product, right?
20:34:07 <Cale> > let h x =  x >>= \u -> x >>= \v -> return (u,v) in h [1,2,3]
20:34:07 <FunctorSalad> yes
20:34:08 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
20:34:27 <FunctorSalad> but as I just noticed I mixed up cats, as Hask makes you ;)
20:34:35 <ddarius> Accidus: What's the ISBN number of your book?
20:34:35 <Cale> Is it easy to see that will be impossible to write in the form  f x = x >>= g ?
20:35:03 <FunctorSalad> every morphism f of the *other* cat of the adjunction (monoids here) is equal to (=<<) (r . return)
20:35:13 <Cale> what?
20:35:16 <FunctorSalad> not every *Hask* function from M A to M B
20:35:25 <Accidus> 0-387-90036-5
20:35:26 <Cale> I don't think you mean (=<<) (r . return)
20:35:35 <FunctorSalad> sorry, 'r' is 'f'
20:35:38 <kmc> abbreviating "homomorphism" as "homo" is fraught with peril
20:35:42 <Cale> Or (f . return) even
20:35:44 <Accidus> Or 0-387-90025-7
20:35:56 <Accidus> Or 3-540-90036-5
20:36:04 <FunctorSalad> Cale: f :: M A -> M B, then so is (=<<) ( f . return )
20:36:07 <FunctorSalad> or not?
20:36:08 <ddarius> Accidus: Okay, same as mine then.
20:36:21 <kmc> :t \f -> (=<<) ( f . return )
20:36:22 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m1, Monad m) => (m1 a -> m b) -> m a -> m b
20:36:58 <Accidus> ddarius, and page 96 question 5 begins with the word "Prove that for all J"?
20:37:07 <FunctorSalad> kmc: that's more general, but the point remains
20:37:31 <ddarius> Accidus: On that page, question five begins, "For any J, ..."
20:37:33 <FunctorSalad> Cale: my confusion was that every {linear map, monoid homomorphism} is the (=<<) of its (. return)
20:37:46 <Accidus> ddarius, interesting.
20:37:58 <Cale> FunctorSalad: I'm not sure if that's true.
20:38:06 <FunctorSalad> Cale: but not every *set* function between {vector spaces, monoids} is of that form
20:38:18 <ddarius> It's quite obvious that not every function M A -> M B is expressible of \ma -> ma >>= f . return for some f.
20:38:30 <FunctorSalad> ddarius: as I said
20:38:47 <FunctorSalad> ddarius: it's true if they're morphisms in the other cat (we glossed over forgetful functors)
20:38:49 <Cale> Not even every homomorphism
20:39:07 <Cale> Not in general anyway
20:39:09 <FunctorSalad> (if we start from the monad, the "other cat" is the kleisli I think)
20:39:21 <FunctorSalad> Cale: pretty sure it is
20:39:37 <FunctorSalad> two homomorphisms are equal if they are equal on the set of free generators
20:39:53 <FunctorSalad> (all the M A are free algebras)
20:40:08 <FunctorSalad> so if you restrict to generators and use the universal property to extend back, you must get the same
20:40:46 <Cale> Let's be more concrete about this...
20:40:58 <Cale> What M are you using?
20:41:18 <FunctorSalad> I think any, but say M = free K-vector space or M = free monoid
20:41:38 <FunctorSalad> with the domain 'Set', which I didn't really distinguish from Hask for this argument
20:41:53 <Cale> Okay, so M: Set -> Set?
20:42:15 <FunctorSalad> yes
20:42:27 <Cale> It can't just be the free monoid functor, since that's not an endofunctor
20:42:38 <Cale> right, okay
20:42:40 <FunctorSalad> it just got confusing because "M A -> M B" is strictly speaking set functions, not monoid homos
20:42:44 <Cale> right
20:42:45 <FunctorSalad> but it must be monoid homos
20:43:18 <Cale> So you're saying that the forgetful image of every monoid homomorphism will be of that form?
20:43:51 <FunctorSalad> that every monoid homomorphism is the "bind" (as a unary op) of its forgetful image
20:44:04 <FunctorSalad> which I think follows immediately from the adjunction condition
20:44:20 <Cale> uhhh
20:44:39 <FunctorSalad> and this only works for the image of the free functor of course, otherwise the types don't even match
20:44:41 <Cale> bind doesn't have the right type to do that
20:44:49 <Cale> Our bind works only with set functions here
20:45:00 <Cale> M is a monad on Set.
20:45:03 <Accidus> Cale: What about this one: T = UF for some adjunction F -| U
20:45:24 <FunctorSalad> bind :: Set(A,U B) -> Mon(F A, F U B)
20:45:34 <Accidus> Now if f : TA -> TB then f : FU A -> FU B
20:45:39 <FunctorSalad> cancel the second F
20:45:39 <Accidus> equivalent to
20:46:37 <Accidus> Hmm...
20:47:01 <Cale> If this just amounts to saying that the forgetful image of every homomorphism (which will have type M A -> M B) will be of the form (>>= f) where f :: A -> M B, then okay.
20:47:02 <Accidus> just ignore me
20:47:10 <FunctorSalad> Cale: actually your formulation was right too (reread it)
20:47:35 <FunctorSalad> since U is injective, it doesn't really matter whether we say the monoid homos or their forgetful images are the same, though
20:47:41 <Cale> That's practically the definition of what it means to be free. :)
20:48:07 <FunctorSalad> but you were right that I needed "hetero-bind" Set(A,U B) -> Mon(F A, B)
20:48:09 <Cale> Well, it matters if we're talking about bind
20:48:13 <FunctorSalad> aka the adjunction iso ;)
20:48:23 <Cale> heh, okay
20:48:56 <FunctorSalad> if B is a free monoid and we write it as F A0, that looks more like a bind ;)
20:49:09 <Cale> Er, isn't that backward? Which one is F and which is U? :)
20:49:15 <FunctorSalad> F is free
20:49:21 <Cale> okay
20:49:29 <FunctorSalad> U... suppose it originates in "underlying"
20:49:30 <Cale> and U is underlying then
20:49:31 <Cale> yeah
20:50:55 <FunctorSalad> I didn't claim it's a deep fact (it's the adjunction iso), just the apparent contradiction between homomorphisms being stable under the round trip "restrict/extend"
20:51:25 <Cale> So, in (almost) any case, there are lots of M A -> M B functions we can write using essentially only the monadic machinery, but which don't correspond to homomorphisms on the other side of the adjunction
20:51:34 <FunctorSalad> and haskell functions apparently not being so, but they are... it's just that they must be homomorphisms in the kleisli category of M, or maybe eilenberg-moore
20:51:55 <FunctorSalad> s/homomorphisms/morphisms/
20:52:25 <Cale> 'homomorphisms' is okay anyhow :)
20:52:45 <Accidus> FunctorSalad, can you run that again?
20:53:02 <Accidus> FunctorSalad, you say that any Haskell function MA -> MB is an M-homomorphism?
20:53:03 <Cale> I tend to prefer 'arrow' when talking about abstract categories, and 'morphism'/'homomorphism' interchangeably for specific categories of algebraic objects.
20:53:23 <FunctorSalad> (the eilenberg-moore one of the free vectorspace/monoid monad is the category of vectorspaces/monoids again, so it really is the same principle)
20:53:54 <Cale> Accidus: any Haskell function of the form (>>= f) where f :: A -> MB is the forgetful image of a homomorphism of free monoids on the other side of the adjunction.
20:54:07 <Cale> er, or free-other-objects :)
20:54:27 <Accidus> Cale, Ah. That makes sense.
20:54:27 <FunctorSalad> Accidus: no :) just that if we write the monad M as an adjunction Hask <-> C, then morphisms of C are stable under forget/return/bind
20:54:47 <Accidus> FunctorSalad, C being?
20:55:02 <FunctorSalad> (which is just the condition that the adjunction isomorphism is... an isomorphism)
20:55:14 <FunctorSalad> (so don't expect anything deep here, just resolving the confusion)
20:55:37 <JuanDaugherty> C one takes it is the programming lang
20:55:45 <Cale> hehe
20:55:48 <FunctorSalad> Accidus: I think any category that lets you write M as an adjunction works?
20:55:58 <FunctorSalad> the two extreme cases being the ones I mentioned
20:56:11 <Accidus> FunctorSalad, ah, I thought you had a specific category in mind
20:56:20 <Cale> It works for some specific free/forgetful pairs.
20:56:26 <FunctorSalad> Accidus: Kleisli, Eilenberg-Moore
20:56:32 <JuanDaugherty> it's ambig until the speaker declars
20:56:33 <Cale> I'm not yet convinced that it always does, but it wouldn't surprise me.
20:56:37 <JuanDaugherty> *declares
20:57:02 <Cale> It's sort of the definition of what it means for a sort of object to be 'free'
20:57:02 <FunctorSalad> "Kleisli" corresponds to free algebras, E-M to all algebras
20:57:29 <JuanDaugherty> two slits with "anonymous category" and the "the c programming lang"
20:57:42 <FunctorSalad> Cale: the image of a functor which is a left adjoint?
20:58:01 <FunctorSalad> with the other cat usually being 'less structured' (Set,Hask)
20:58:28 <FunctorSalad> Cale: not convinced about? it's just a dumb tautology in the end ;)
20:58:54 <FunctorSalad> or that every monad can be written as these adjunctions?
20:59:09 <Cale> FunctorSalad: I know that every monad can be written as these adjunctions.
20:59:23 <FunctorSalad> thought so :)
21:00:50 <Accidus> So... Any recommendations for the counter-example?
21:01:04 <Cale> I suppose it almost has to be right. I'd like to see the details in terms of the unit and counit though.
21:01:07 <Cale> Accidus: hmm
21:01:29 <Cale> Accidus: It's clear that if C has terminal objects and products then C^J will too, yeah?
21:01:39 <Accidus> Obviously the problem is exponentials
21:04:22 <Cale> We'll also want to avoid certain C, because Set^J will be Cartesian closed
21:04:40 <Cale> (in fact, it'll be a topos)
21:04:52 <FunctorSalad> Accidus: tried finding one such that multiplication with a fixed object doesn't preserve colimits yet? sorry, got way carried away with that other issue ;)
21:05:29 <FunctorSalad> maybe an application of the monad law somewhere saves it from total tautology-status
21:05:33 <FunctorSalad> :)
21:06:11 <Accidus> FunctorSalad, Hmm... so I guess a Heyting algebra that is not complete?
21:06:22 <Cale> FunctorSalad: It's one of those things which is "obviously true", but there's enough there that I'd still like to see all the details written out before I'd be totally comfortable.
21:07:15 <FunctorSalad> Cale: it's not that obvious for algebraic structures; the "work" is in the proof that the free/forgetful pair is an adjunction
21:07:28 <FunctorSalad> (unless you define `free' that way :))
21:07:50 <FunctorSalad> but at least with vector spaces it's a theorem that they're all free ;)
21:07:53 <Cale> FunctorSalad: I mean, it's not 100% obvious to me that it's true of just any adjunction and the monad arising from that
21:11:12 <edwardk> hrmm, need a module name for my heaps
21:12:27 <edwardk> There is already a Data.Heap out there, but i'm kind of tempted to trample on the same namespace
21:12:45 <ddarius> edwardk: Are your heaps the best possible?
21:12:55 <edwardk> ddarius: asymptotically optimal
21:13:25 <edwardk> ddarius: and they support a bunch of things that no other haskell heap does like Foldable, etc.
21:14:11 <edwardk> when i was writing them i also kept in mind the idea of writing them in a style conducive to later moving them into something like 'containers'
21:14:29 <Cale> Accidus: hmm, I think I'm starting to see what the problem might be.
21:14:35 <edwardk> since iirc there was some traffic a while back asking for heaps in containers
21:14:42 <kmc> hi edwardk
21:14:45 <edwardk> heya kmc
21:14:46 <kmc> are these the finger-tree heaps?
21:14:56 <FunctorSalad> Cale: starting from the F -| U, the property to prove is "(f :: F A -> F B)  ==  phi ( U (f)  .   unit_A )" identity, which is more or less one of the definitions of adjunction?
21:15:00 <edwardk> nah, these are brodal/okasaki heaps
21:15:09 <kmc> ah cool
21:15:12 <ddarius> edwardk: Perhaps put them in their own module, propose them to be included in containers, if they are take Data.Heap.
21:15:14 <edwardk> which gives a bunch of stuff like O(1) merge
21:15:32 <FunctorSalad> U(f) . unit_A :: A -> U F B
21:15:40 <FunctorSalad> then you apply the adjunction mapping to that
21:15:49 <FunctorSalad> *the adjunction iso
21:15:58 <FunctorSalad> should be a short unique name for it
21:16:11 <ddarius> transpose/transposition
21:16:27 <FunctorSalad> yeah that's not bad, but is it well-known enough?
21:16:28 <edwardk> ddarius: jim apple also has an implementation of these, though he didn't use the optimized form from the brodal/okasaki paper, and extracted it from coq, so its hardly idiomatic ;)
21:16:32 <ddarius> Also left/right adjunct though I can never remember which is which.
21:16:48 <ddarius> FunctorSalad: It's fairly common.
21:17:06 <FunctorSalad> heh calling the isomorphisms left/right with the functors already being so is evil
21:17:25 <FunctorSalad> like calling the up and down side of a square left and right
21:17:44 <ddarius> That's not the issue.
21:18:07 <FunctorSalad> with the functors it's easy, the left one is the left that you can move over to the left
21:18:22 <FunctorSalad> Mon(F A, B) ~ Set( A, U B)
21:18:25 <FunctorSalad> F is left
21:18:55 <Accidus> Cale, if A is A-enriched, then one has an exponential via the Yoneda embedding
21:19:18 <Cale> Accidus: yeah
21:19:41 <Cale> Accidus: and the 'obvious' thing is not functorial
21:19:51 <Accidus> Unless A is A-enriched
21:20:03 <FunctorSalad> *the left one is the functor that you can move over to the left [amazing that I can still form sentences at all with that level of scatterbrainedness?]
21:20:14 <Cale> Well, H^G(X) = (HX)^(GX) will never work
21:20:45 <Cale> You would use H^G(X) = Hom(yX x G, H)
21:20:57 <FunctorSalad> Accidus: I didn't understand the Heyting algebra remark, by the way
21:21:19 <Accidus> FunctorSalad, A complete heyting algebra is distributive
21:21:35 <Accidus> FunctorSalad, an incomplete one isn't
21:21:44 <FunctorSalad> in the lecture we used the yoneda lemma to show what the exponential for presheaf categories is if it exists
21:21:59 <FunctorSalad> I think it wasn't pointwise, yes... multiplied with a funny factor
21:22:24 <FunctorSalad> (sorry don't remember...)
21:22:26 <Accidus> FunctorSalad, it's F^G := (y(-) x G, F)
21:22:34 <ddarius> FunctorSalad: Presheaf categories always have exponents because they are always toposes.
21:23:26 <FunctorSalad> ddarius: yes, but the argument probably didn't use Set and would work as a constraint ("if it exists") for any target cat which is ccc
21:23:55 <Accidus> FunctorSalad, It used Set-enrichment
21:23:58 <FunctorSalad> Accidus: yes that looks like it
21:24:06 <Accidus> FunctorSalad, so you need a yoneda embedding
21:24:17 <FunctorSalad> (the F^G, that is)
21:24:18 <Accidus> Of the base category within itself
21:25:34 <danharaj> I don't think I should be using parsec's generated expression parsers if I'm going to be mixing statements from multiple ones.
21:25:48 <danharaj> It seems rather easy to get left recursion or it just not working.
21:25:53 <FunctorSalad> Accidus: I'd have to rethink where exactly the yoneda is applied here :(
21:26:18 <FunctorSalad> Accidus: the Sets are the Sets of natural isomorphisms from a yoneda functor to a functor?
21:26:21 <Accidus> FunctorSalad, F^G(x) ~= [y(x), F^G]
21:26:41 <FunctorSalad> yes
21:26:55 <Cale> and then assuming it's an exponential, that had better be isomorphic to [y(x) x G, F]
21:27:16 <FunctorSalad> [ , ] is external here?
21:27:16 <Accidus> And the last bit exists, because of yoneda
21:27:19 <Cale> But that's a perfectly good functor already, so we can just define it that way
21:27:32 <Accidus> yes
21:27:34 <FunctorSalad> and ^ the exponential in Set (which as you said happens to be the same....)
21:27:35 <Cale> [ , ] is just the notation Accidus chose for Hom(,)
21:28:15 <Cale> Also could have written Set^(C^op)(y(x) x G, F)
21:28:34 <FunctorSalad> ah, and now [y(x),F^G] ~= [ y(x) x G, F ] ?
21:28:40 <Cale> yeah
21:28:42 <Accidus> In any case, I think incomplete Heyting algebras are not easy to construct
21:28:42 <FunctorSalad> that's still generic?
21:28:44 * Accidus sighs.
21:30:08 <Cale> Accidus: How about we try some really simple examples
21:30:26 <FunctorSalad> did I miss the step yet where we use Set?
21:30:42 <Accidus> FunctorSalad, Yes
21:30:52 <Cale> Like the category 2 = "0 -> 1" is Cartesian-closed.
21:30:55 <Accidus> FunctorSalad, [y(x)xG,F] is not necessarily an A object
21:31:05 <Accidus> It's an object in Set
21:31:15 <FunctorSalad> yes, but otherwise it holds so far?
21:31:19 <Cale> Can we get a counterexample somehow from that?
21:32:17 <Accidus> FunctorSalad, what do you mean otherwise?
21:32:28 <Cale> Is 2^Disc(2) Cartesian closed?
21:32:57 <Accidus> FunctorSalad, If you want to define F^G(x) as Hom[y(x)xG,F], then the Hom-set has to be an A object
21:33:23 <Accidus> FunctorSalad, otherwise you just can't define it
21:33:35 <Accidus> Cale, What's Disc(2)?
21:33:45 <Cale> discrete category on two objects
21:34:02 <Cale> So, 2^Disc(2) is basically just a commutative square
21:34:31 <FunctorSalad> Accidus: "otherwise" I mean just that we have a natural isomorphism F^G ~= [ y(-) x G, F ], with both sides being functors J -> Set
21:34:54 <Accidus> Cale, are you sure? C^Disc 2 amounts to just choosing two objects of C
21:34:58 <FunctorSalad> which, like you said, has the wrong type thus far
21:35:21 <FunctorSalad> but might still help in building a contradiction
21:35:22 <Cale> Accidus: in all possible ways
21:35:27 <Accidus> And the natural transformations are simply morphisms
21:35:29 <siracusa> In Gtk2Hs widgetModifyBg takes a value of type Color, but Color has no exported constructors. How do you create a value of it?
21:35:36 <Cale> pairs of morphism
21:35:37 <Cale> s
21:35:49 <FunctorSalad> we didn't apply the condition F^G must have yet
21:35:49 <Accidus> Cale, aye
21:35:53 <FunctorSalad> from the adjunction
21:37:08 <Cale> So if we start from 0 -> 1, and "square" it in this way, we end up with objects (0,0), (0,1), (1,0), and (1,1)
21:37:18 <Cale> and the arrows are fairly obvious
21:37:41 <FunctorSalad> (and translate that over to the [ y(-) x G, F ], which doesn't require that it's of type J -> A?)
21:37:46 <ddarius> The Yoneda embedding (for Set) preserves limits and exponentials.
21:38:15 <Cale> I don't know if this is going to fail, but I think it's worth trying some small examples like this. Chances are if the thing fails in general, it'll fail on some small finite case :)
21:38:30 <ddarius> s/for Set/for presheaves over Set/
21:38:53 <FunctorSalad> Cale: thought taking the product over a discrete cat could cause no problems...
21:39:06 <FunctorSalad> why not try  0 -> 1? ;)
21:39:22 <FunctorSalad> nvm, you had that
21:39:23 <Cale> Well, we could do that too
21:39:41 <FunctorSalad> sorry if I repeat stuff you already said... wasn't following your conversation all the time
21:40:15 <ddarius> 0 -> 1 is not the discrete category on two objects.
21:40:33 <FunctorSalad> so?
21:40:48 <Cale> I was doing 2^Disc(2), but you could try 2^2
21:41:06 <Accidus> Hmm... Interesting. I think 2^Disc 2 works
21:41:15 <FunctorSalad> 2^(Disc 2) as J?
21:41:21 <Accidus> No. Disc 2 as J
21:41:22 <JoeyA> ghci's line reading is annoying; no Ctrl+Right/Left or Home/End, unlike programs such as GNU bash.  How might I remedy this?  I'm on Ubuntu.
21:41:23 <Cale> FunctorSalad: as C^J
21:41:41 <jbapple> JoeyA: I had this same problem
21:41:47 <Accidus> Because a functor amounts to 2 objects and a n.t. amounts to 2 morphisms
21:41:49 <interferon> let's say i have the following inside an IO monad:   foo <- map frob . filter isValid <$> readRecords
21:42:01 <Cale> JoeyA: Home and End work...
21:42:05 <FunctorSalad> JoeyA: hmm, I'd find out where haskeline reads its config
21:42:07 <interferon> readRecords will be executed in sequence, but will the pure functions applied to it be left as thunks?
21:42:27 <FunctorSalad> recent ghci's use haskeline I think
21:42:32 <Cale> JoeyA: Which GHC?
21:42:40 <JoeyA> version 6.10.4
21:42:42 <FunctorSalad> or was it still available with either haskeline or readline...
21:42:44 <Cale> okay
21:42:58 <Cale> I was using 6.10.4 up until quite recently and those keys worked for me...
21:43:06 <jbapple> Here's what I had to do to fix it with 6.12:
21:43:06 <jbapple> $ cat ~/.haskeline
21:43:06 <jbapple> keyseq: "\ESC[1;5D" ctrl-left
21:43:06 <jbapple> bind: ctrl-left meta-b
21:43:06 <jbapple> keyseq: "\ESC[1;5C" ctrl-right
21:43:07 <jbapple> bind: ctrl-right meta-f
21:43:18 <jbapple> for 6.10 I think I had to install libreadline-compat or some such nonsense
21:43:23 <kmc> interferon, yes
21:43:32 <kmc> interferon, working within the IO monad does not imply strict evaluation order
21:43:34 <interferon> kmc: beautiful! thanks
21:43:35 <Accidus> Actually, I don't think 2 works
21:43:43 <FunctorSalad> Accidus: anyway, I was just saying we have a natural iso in the category Set^J, even if we haven't constructed the exponential
21:43:47 <interferon> kmc: but it does for the IO actions themselves, right?
21:43:52 <Cale> (well, home and end did)
21:44:06 <danharaj> > :t notFollowedBy
21:44:08 <lambdabot>   <no location info>: parse error on input `:'
21:44:22 <Cale> interferon: The IO actions themselves describe a sequence of actions to be *executed*
21:44:25 <kmc> (the thing called a "monad" is the type "IO" itself.  a value of type (IO t) might be called an "IO action" or "IO recipe")
21:44:45 <kmc> interferon, the point of IO is not to constrain evaluation order.  the point is to *decouple* execution order and evaluation order
21:44:48 <Cale> interferon: But the order in which the expressions describing the IO actions are *evaluated* into values is irrelevant.
21:44:53 <jbapple> here's a page for fixing haskeline, but I think 6.10 uses the regular readline: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
21:44:57 <Cale> Evaluation never causes execution to occur
21:45:09 <interferon> so the low-level IO actions will be executed in sequence at the toplevel
21:45:26 <Cale> interferon: As described by the main action, yeah.
21:45:31 <kmc> IO actions are executed in whatever sequence you specify using (>>=) and friends
21:45:34 <interferon> but any non-IO operations applied to them result in thunks, as usual?
21:45:34 <coppro> pl \x y -> elem y (func x)
21:45:45 <coppro> @pl \x y -> elem y (func x)
21:45:45 <lambdabot> flip elem . func
21:45:45 <kmc> which is unrelated to what order they're evaluated in
21:45:46 <Cale> interferon: s/thunks/expressions/
21:46:08 <Cale> thunks are an unnecessary detail to think about if you're just programming :)
21:46:16 <kmc> interferon, it seems like you're looking for a special property of IO action values
21:46:19 <kmc> and their evaluation
21:46:26 <coppro> @pl \x y -> elem x (func y)
21:46:26 <lambdabot> (. func) . elem
21:46:31 <Cale> Just imagine expressions being reduced to other expressions until you reach values on which you can pattern match
21:46:36 <Cale> That's what evaluation is doing.
21:46:40 <kmc> interferon, but there isn't one
21:46:53 <FunctorSalad> Cale: hmm, I found "thunk" useful to understand a bit what's going without knowing about the implementation in depth :)
21:46:59 <Cale> Execution, on the other hand, is carrying out the effects described by IO actions.
21:46:59 <ManateeLazyCat> interferon: Because IO Monad is depend "RealWorld" that out of `main`, so IO Monad will evaluate always
21:47:37 <ManateeLazyCat> interferon: IO monad don't like pure expression in Haskell that just evaluate when you need it.
21:47:39 <Cale> FunctorSalad: Well, okay, it's nice to know how these things can be implemented efficiently, but I still tend to picture thunks as just some kind of memory-graph-representation of expressions.
21:48:07 <Cale> I really really hate the RealWorld analogy of IO
21:48:17 <FunctorSalad> Cale: sure I meant the graph picture too
21:48:36 <interferon> Cale: really?
21:48:46 <Cale> interferon: really.
21:48:48 <interferon> Cale: i found it useful, but then again i'm here asking questions about it :)
21:48:50 <FunctorSalad> and that it's a piece of suspended code that can compute the value of the type in question...
21:48:51 * ddarius does as well.
21:49:03 <ddarius> (hate the "RealWorld" view of IO)
21:49:08 <kmc> i think it's an unnecessary level of machinery for an analogy
21:49:17 <ManateeLazyCat> interferon: Search "IO Inside" in HaskellWiki, you will know the distinguish between IO moand and other pure expression.
21:49:18 <kmc> it's enough just to think of IO monad values as descriptions
21:49:28 <Cale> Just think of a value of type (IO t) as being a description of an effectful program which, if executed, produces a value of type t as its result.
21:49:35 <kmc> ManateeLazyCat, the evaluation behavior of IO monad values is *not* different from other expressions
21:49:37 <FunctorSalad> didn't know it's so flawed you'd hate it :)
21:49:42 <pikhq> The RealWorld thing only gets you much enlightenment when you already comprehend IO.
21:49:56 <Cale> But it's important to understand that *evaluation* of a value of type (IO t) does *not* cause it to execute
21:50:07 <interferon> i guess the RealWorld analogy is useful for understanding how the IO monad steps are executed in the given order
21:50:09 <interferon> right?
21:50:13 <Cale> any more than loading a program into a text editor would cause it to run
21:50:16 <kmc> IO monads happen to be descriptions of actions to take in the real world.  so is ("call your mother tomorrow" :: String)
21:50:16 <interferon> but other than that, the actions abstraction is better
21:50:18 <FunctorSalad> Cale: you suggested the picture where "GetChar" and so on are free instead? iirc
21:50:26 <Cale> interferon: It's not even particularly good at that :)
21:50:31 <interferon> hehe
21:50:32 <kmc> neither one will call your mother by virtue of being evaluated
21:50:33 <Cale> FunctorSalad: yeah
21:50:35 <FunctorSalad> (as if it was a constructor of a gadt)
21:50:58 <Cale> interferon: Because things can happen to the real world (but not the RealWorld) in between the actions
21:51:00 <kmc> IO monad actions are descriptions in a particular form that the "execution" part of a Haskell system, which is distinct from the "evaluation" part, can understand
21:51:11 <interferon> ok, that's true
21:51:17 <FunctorSalad> can that explain forkIO? (not that State RealWorld could)
21:51:33 <interferon> it is kind of a lousy analogy in that respect
21:51:34 <ManateeLazyCat> interferon: Haskell compiler will consider "IO moand" has side-effect, so it evaluate it always.
21:51:37 <Cale> FunctorSalad: Well, that's a reason that the RealWorld analogy completely fails in the presence of forkIO
21:51:53 <kmc> ManateeLazyCat, that's simply incorrect
21:52:01 <Cale> You need a nondeterministic semantics to explain concurrency.
21:52:04 <ManateeLazyCat> kmc: What's the correct version?
21:52:13 <FunctorSalad> you could define the semantics as "the interpreter must form a thread here, and then it's their problem"?
21:52:15 <FunctorSalad> ;)
21:52:17 <kmc> ManateeLazyCat, that evaluation of IO actions proceeds the same way as any other value
21:52:29 <kmc> and *execution* of IO actions is driven by a separate process
21:52:41 <kmc> and has nothing to do with lazy vs. strict
21:52:43 <ddarius> Cale: It doesn't completely fail necessarily, but justifying it gets ridiculous.
21:52:47 <Cale> yeah
21:52:56 <kmc> except in that, like anything else inspecting a value, the IO-executor must evaluate it first
21:53:11 <FunctorSalad> it transforms the world to a state where an extra thread is running on the machine?
21:53:16 <ManateeLazyCat> kmc: driven by a separate process?
21:53:23 <Cale> I suppose you could define the RealWorld type as somehow being the powerset of all possible worlds
21:53:27 <ManateeLazyCat> kmc: More detail?
21:53:27 <kmc> yes, evaluation and execution are separate processes
21:53:29 <kmc> (conceptually)
21:53:46 <kmc> to run a Haskell program: evaluate "main" to get an IO action, then execute that action
21:54:00 <Cale> but even then, you run into problems with things as simple as getCurrentTime
21:54:43 <kmc> the RealWorld thing is also problematic because people are told that it's how GHC "really works", but GHC's RealWorld value is a total hack and contains no data at all
21:54:54 <FunctorSalad> Cale: why? time could be a component of the state
21:54:59 <interferon> kmc: it's basically an unforgeable token right?
21:55:05 <Cale> and GHC uses side-effectful functions at a low-level
21:55:14 <DW_Ya_DiqG> wanna c somethin fucced up lol dont send pics to ur bf if ur gonna do him dirty lol http://www.paybackNikki.in/?id=1053lbj6dbtpx2w0nwezzclymagipl
21:55:16 <kmc> interferon, nah, it's easy to forge
21:55:38 <kmc> interferon, unsafePerformIO forges it
21:55:40 <Cale> the RealWorld (or State# RealWorld) is just a token to piggyback on the dependency analyser to ensure that the operations stay in order
21:55:43 <FunctorSalad> we don't really need a nondeterministic universe to have multiple threads on our machine too (but as has been said, it becomes a bit of a cop-out ;))
21:55:52 <interferon> doh!
21:55:56 --- mode: ChanServ set +o Cale
21:56:05 <Cale> hmm...
21:56:21 <kmc> and yeah, that's the irony of claiming Haskell has a type-level separation between pure and impure values... the truth is that by the time you dig deep enough in GHC to find an actual impure value, its type is totally uninformative
21:56:31 * Cale wonders if it's even worth adding a ban.
21:56:51 --- mode: Cale set +b *!*@pool-71-102-81-229.plspca.dsl-w.verizon.net
21:56:53 <interferon> i guess i still don't see how order is enforced in the IO monad.  is it extralingual?
21:56:55 <ddarius> Cale: You could notify the freenode ops.
21:56:59 --- mode: Cale set -o Cale
21:57:08 <kmc> interferon, order of execution is specified by (>>)
21:57:12 <ManateeLazyCat> kmc: So you mean, *evaluation* IO monad is same as other moand, just have difference at *executive* ?
21:57:14 <FunctorSalad> kmc: how does that make the claim misleading? it applies to anything not IO-infested
21:57:15 <kmc> how is order of strings being glued together enforced by (++)
21:57:22 <Cale> interferon: It's described directly by the construction of the IO values.
21:57:44 <interferon> oh
21:57:49 <kmc> interferon, in the string value "call your mother, then eat a sandwich" how is order specified?
21:57:54 <FunctorSalad> kmc: ok, the typesystem just marks that about which nothing in guaranteed, it doesn't predict how the impure world will behave
21:57:55 <kmc> it's just part of the data type (english text)
21:57:56 <Cale> interferon: It has nothing to do with the order in which those values are evaluated -- you could evaluate the expressions representing them in any order you like, and you'd get the same sequence of actions.
21:58:02 <interferon> so because you need an IO value to pass to the next one, you need to evaluate down to a single IO (blah) action?
21:58:09 <FunctorSalad> s/in/is/
21:58:20 <Cale> interferon: I can give a decent mental model...
21:58:20 <interferon> Cale: hmm good point
21:58:26 <Cale> Consider a datatype like this:
21:58:29 <Cale> data IO t where
21:58:33 <Cale>   ReturnIO :: a -> IO a
21:58:42 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
21:58:55 <Cale>   GetChar :: IO Char
21:59:01 <Cale>   PutChar :: Char -> IO ()
21:59:09 <Cale>   ... other operations ...
21:59:49 <FunctorSalad> kmc: I think it does well at keeping the impure out, even if it doesn't make any guarantees about what the impure does
21:59:54 <FunctorSalad> lazy IO to the side
22:00:01 <Cale> So, when you write a program like  getChar >>= putChar, if fully-evaluated, it evaluates into the value:  BindIO GetChar PutChar
22:00:14 <Cale> and then the runtime system pattern matches on that value and actually *does* stuff
22:00:47 <Cale> exec (BindIO x f) = do v <- exec x; exec (f v)
22:01:12 <interferon> i see
22:01:23 <interferon> so it can't pattern-match until its gotten down to one of the data constructors of IO
22:01:45 <Cale> (this 'exec' is just schematic, and might actually be implemented in a lower-level language)
22:01:50 <Cale> yeah
22:01:58 <Cale> and so it evaluates, to get down to a constructor
22:02:03 <Cale> (so it can pattern match)
22:02:12 <Cale> and then executes, according to which constructor it got
22:02:23 <Cale> (and execution is where the effects really happen)
22:03:17 <kmc> now i'm wondering about a hypothetical dynamically typed language with a Haskell-like distinction between exec and eval
22:03:35 <kmc> i think there is an advantage to this way of thinking
22:03:36 <Cale> kmc: I think it would be fun for scheme to go in that direction.
22:04:05 <kmc> and that the static type-level separation is almost secondary to the conceptual separation
22:04:08 <JoeyA> jbapple> Thanks; here's what I put in my .haskeline file, and both ctrl+left/right, home/end, and delete work now:  http://codepad.org/ewlxFC46
22:04:15 <JoeyA> ~/.haskeline, that is
22:07:16 <FunctorSalad> @ty runWriter
22:07:17 <lambdabot> forall w a. Writer w a -> (a, w)
22:08:07 <interferon> Cale, kmc: thanks for the explanations - i appreciate your patience
22:08:32 <FunctorSalad> > runWriter ((join . join) (Writer "outer " (Writer "middle " (Writer "inner " 42)))))
22:08:33 <lambdabot>   <no location info>: parse error on input `)'
22:09:03 <FunctorSalad> > runWriter (join . join . Writer "outer " . Writer "middle " . Writer "inner " $ 42)
22:09:04 <lambdabot>   Couldn't match expected type `(a, w)'
22:09:04 <lambdabot>         against inferred type `[GHC.T...
22:09:07 <coppro> how do I delete every occurrence of a value from a list?
22:09:08 <FunctorSalad> :(
22:09:28 <FunctorSalad> coppro: filter
22:09:46 <FunctorSalad> > filter ((== 'a') "lolbar"
22:09:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:09:51 <coppro> yeah, per tradition, I figured it out immediately upon asking
22:09:54 <FunctorSalad> > filter (/= 'a') "lolbar"
22:09:55 <lambdabot>   "lolbr"
22:10:29 <FunctorSalad> > runWriter (join . join . Writer "outer " . Writer "middle " . Writer "inner " $ ())
22:10:30 <lambdabot>   Couldn't match expected type `(a, w)'
22:10:30 <lambdabot>         against inferred type `[GHC.T...
22:10:45 <FunctorSalad> > join . join . Writer "outer " . Writer "middle " . Writer "inner " $ ()
22:10:46 <lambdabot>   Couldn't match expected type `(a, w)'
22:10:46 <lambdabot>         against inferred type `[GHC.T...
22:10:51 <FunctorSalad> @ty Writer
22:10:52 <lambdabot> forall a w. (a, w) -> Writer w a
22:11:02 <FunctorSalad> meh thought it's curried
22:11:21 <FunctorSalad> > let writer = curry Writer in join . join . writer "outer " . writer "middle " . writer "inner " $ ()
22:11:22 <lambdabot>   Couldn't match expected type `[a]'
22:11:23 <lambdabot>         against inferred type `GHC.Types...
22:12:07 <FunctorSalad> > let writer = curry Writer in (join . join . writer "outer " . writer "middle " . writer "inner ") ()
22:12:08 <lambdabot>   Couldn't match expected type `[a]'
22:12:08 <lambdabot>         against inferred type `GHC.Types...
22:12:21 <FunctorSalad> I fail epically today
22:12:22 <FunctorSalad> again
22:13:05 <FunctorSalad> anyway, twisting the monoid composition would be a valid monad too, eh?
22:13:20 <FunctorSalad> of course. dual monoid is a monoid
22:14:48 <FunctorSalad> > let writer w a = Writer (w,a) in (join . join . writer "outer " . writer "middle " . writer "inner ") ()
22:14:49 <lambdabot>   Couldn't match expected type `[a]'
22:14:49 <lambdabot>         against inferred type `GHC.Types...
22:15:40 <FunctorSalad> @ty join . join . writer "outer " . writer "middle " . writer "inner "
22:15:42 <lambdabot> Not in scope: `writer'
22:15:42 <lambdabot> Not in scope: `writer'
22:15:42 <lambdabot> Not in scope: `writer'
22:15:58 <djahandarie> Try @let
22:15:59 <FunctorSalad> @ty let writer w a = Writer (w,a) in join . join . writer "outer " . writer "middle " . writer "inner "
22:16:00 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
22:16:00 <lambdabot>       Expected type: [[a]]
22:16:00 <lambdabot>       Inferred type: [Char]
22:16:02 <djahandarie> Or that
22:16:29 <djahandarie> @let blahblahblah = 5
22:16:30 <lambdabot>  Defined.
22:16:35 <djahandarie> @ty blahblahblah
22:16:36 <lambdabot> forall t. (Num t) => t
22:16:38 <FunctorSalad> ah. needs flipping
22:16:54 <FunctorSalad> > let writer a w = Writer (w,a) in join . join . writer "outer " . writer "middle " . writer "inner " $ ()
22:16:55 <lambdabot>   No instance for (GHC.Show.Show
22:16:55 <lambdabot>                     (Control.Monad.Writer.La...
22:17:19 <FunctorSalad> > let writer a w = Writer (w,a) in let Writer (w2,a2) = join . join . writer "outer " . writer "middle " . writer "inner " $ () in (w2,a2)
22:17:20 <lambdabot>   ((),"outer middle inner ")
22:17:44 <ElMarsh_> hi, can anybody show me how to set leksah up? I 've downloaded it, and I've installed the Haskell Platform.
22:17:55 <FunctorSalad> that choice is arbitrary isn't it?
22:17:56 <ElMarsh_> I got a pop up that asks for the location of source files
22:18:02 <FunctorSalad> (not @ you ElMarsh_ )
22:18:10 <ElMarsh_> do I just include my haskell folder? thanks
22:20:08 <FunctorSalad> ElMarsh_: hmm I'd think it gathers any haskell projects it can find, but a big one is usually ~/.cabal/packages
22:20:15 <FunctorSalad> (cabal's package cache)
22:20:33 <FunctorSalad> leksah unpacks the cached packages there
22:20:38 <ElMarsh_> I'm on windows by the way, would that affect your answer?
22:21:16 <ElMarsh_> and I don't really know what "cabal" is, I never had to download anything like that -- I just downloaded and installed the Haskell Platform
22:21:22 <ElMarsh_> I tihnk it says that it's all included though
22:21:39 <FunctorSalad> I'm not familiar with the platform; if it means you have an empty cabal package cache, maybe you could just download the whole hackage tarball?
22:22:00 <FunctorSalad> cabal is the most widely used build and packaging system for haskell
22:22:06 <ElMarsh_> I see
22:22:14 <ElMarsh_> are you using Leksah yourself?
22:22:17 <FunctorSalad> it downloads stuff from a site called hackage
22:22:19 <FunctorSalad> @where hackage
22:22:20 <lambdabot> http://hackage.haskell.org/package/
22:22:30 <FunctorSalad> I just took a look at it
22:22:49 <ElMarsh_> which IDE/editor do you use?
22:23:00 <ElMarsh_> I'm just starting up literally
22:23:04 <FunctorSalad> if the platform includes the source, you could just use that directory
22:23:24 <FunctorSalad> sorry as I said I'm not familiar with it :) @editor: emacs with haskell-mode
22:23:40 <kmc> leksah is neat but it's not too tremendously popular
22:23:56 <kmc> i think most haskell coders use whatever editor they're otherwise comfortable with, usually emacs or vim
22:24:15 <ElMarsh_> it looks pretty nice, but I'm just having trouble setting it up
22:24:16 <ivanm> yup
22:24:28 <FunctorSalad> the editor component itself is a bit of a large drawback if you have a emacs or vim habit
22:25:12 <ElMarsh_> there's an option here that says " extract packages from cabal-install" , do you know what that means?
22:25:13 <FunctorSalad> ElMarsh_: btw, you just need the sources for metadata, so you only really need to gather sources for the packages you want to look at
22:25:38 * ivanm was going to implement tred-like functionality in graphviz today... then realised that there was no real way he could abstract this for the DotRepr class :s
22:25:57 <FunctorSalad> ElMarsh_: btw, the tarball I mentioned is here: http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar
22:26:01 <FunctorSalad> 92MB
22:26:39 <FunctorSalad> if you unpack that, it should accept that as the directory for 'extract from cabal-install' I'd expect
22:26:43 <FunctorSalad> (expect :))
22:27:06 <FunctorSalad> this is only if you want (almost) all the sources of user-contributed libs, of course
22:27:28 <FunctorSalad> ivanm: tred?
22:28:07 <ivanm> FunctorSalad: part of Graphviz; it removes transitive edges
22:28:08 <FunctorSalad> btw is it really an uncompressed tar? too much bandwidth? ;)
22:28:09 <ivanm> http://ghcmutterings.wordpress.com/2009/07/06/visualising-the-haskell-package-dependency-graph/
22:28:20 <ivanm> ^^ that's why I wanted to implement it
22:28:30 <FunctorSalad> ivanm: sounds like something you'd want to do...
22:28:39 <FunctorSalad> they get huge enough already
22:28:43 <ivanm> right
22:28:56 <FunctorSalad> as always, svg fail
22:29:06 <ivanm> FunctorSalad: hmmm?
22:29:16 <FunctorSalad> ivanm: on my side :) fonts overflowing
22:29:22 <ivanm> ahhh
22:29:24 <ivanm> yeah, that sucks
22:29:27 <FunctorSalad> *hugs his pngs*
22:29:29 <FunctorSalad> ;)
22:29:45 <ivanm> except that, since I have to different data types for Dot graphs which are used via a class, but there's no real way I can think of to have the class allow changing the datatype
22:29:49 <ivanm> it only lets you _use_ it
22:30:06 <ivanm> FunctorSalad: well, I had to end up using svgs for SourceGraph because the pngs didn't show any useful information :s
22:30:23 <cads> FunctorSalad: what is the appropriate salad _dressing_ for functors?
22:30:54 <FunctorSalad> seems like every single person involved in anything related to GUIs must be using a 60dpi setting or so...
22:30:55 <ivanm> ooooh, that reminds me
22:31:17 <ivanm> I was reading the paper on ocamlgraph, and was wondering: what differentiates an ocaml functor from a haskell typeclass?
22:31:38 <ivanm> FunctorSalad: have a look here if you don't believe me that the pngs are almost useless: file:///home/ivan/Haskell/Sample_SourceGraph/SourceGraph/SourceGraph.html
22:32:03 <cads> FunctorSalad: d'oh you've reminded me I've still yet to get haskell-gtk working in windows
22:32:27 <ivanm> cads: haskell-gtk? you mean gtk2hs?
22:32:30 <coppro> Okay... question. Why does this give what it gives:
22:32:35 <coppro> @pl \x y -> x y y
22:32:36 <lambdabot> join
22:32:40 <cads> I swear that anything titled ___2hs will have a hard time working in windows
22:32:43 <FunctorSalad> ivanm: heh I agree that vector graphics are the right technology for the job in principle
22:32:58 <cads> ivan: aye
22:33:32 <coppro> that seems to be monad-specific
22:33:33 <FunctorSalad> just love to complain about overflowing fonts caused by these tiny-dpi hegemonists
22:33:45 <FunctorSalad> ;)
22:34:10 <ivanm> coppro: right
22:34:22 <ivanm> in this case, it's using the ((->)a) monad
22:34:41 <FunctorSalad> (my svg viewing software, not you)
22:34:46 <coppro> it doesn't work when I try join (==) 1
22:35:36 <ivanm> > join (==) 1
22:35:37 <lambdabot>   True
22:35:42 <coppro> huh
22:35:44 <ivanm> coppro: you have to import another module to use it
22:35:47 <kmc> > join (==) (1/0)
22:35:48 <ivanm> Control.Monad.Instances IIRC
22:35:48 <lambdabot>   True
22:35:50 <ivanm> something like that
22:35:54 <kmc> > join (==) (0/0)
22:35:55 <lambdabot>   False
22:35:56 <coppro> ah
22:35:58 <coppro> ok, thanks
22:37:21 <FunctorSalad> ivanm: I haven't found a good way to deal with huge graphs produced by graphviz in general
22:37:40 <FunctorSalad> the visual edge gets lost a bit if you blindly have to scroll through 10x10 screens....
22:37:43 <ivanm> FunctorSalad: yeah
22:38:05 <FunctorSalad> maybe a viewer that auto-summarizes when zoomed out?
22:38:14 <FunctorSalad> would be domain-specific
22:38:28 <ivanm> but anyway.... wrt implementing tred in my library, the only thing I can think of is to define an unsafe conversion function and to not let any other datatypes join that typeclass
22:38:39 <ivanm> FunctorSalad: yeah
22:38:59 <ivanm> FunctorSalad: tupil and ubigraph seem to produce nice graphs, but have the drawback of being gui-based (and proprietary for ubigraph)
22:39:36 <FunctorSalad> ivanm: it might not be nice but you can kinda seal a typeclass by making the fold for the (imaginary) sum type a method
22:39:52 <FunctorSalad> but then you might just want that finite sum type
22:40:15 <ivanm> FunctorSalad: I was planning more on exporting it and exporting the methods seperately (so they're usable as functions)
22:40:16 <cads> @type (a,b,c)
22:40:17 <lambdabot> (Expr, Expr, Expr)
22:40:28 <cads> @type (a,(b,c))
22:40:29 <lambdabot> (Expr, (Expr, Expr))
22:40:32 <FunctorSalad> just like the list type is fixed by the methods (:), [] and foldr, and their coherence laws
22:40:44 <FunctorSalad> (which you can't enforce of course)
22:41:03 <FunctorSalad> (did I miss one?)
22:44:08 <FunctorSalad> fixed=specified up to isomorphism, here
22:45:52 <FunctorSalad> am I even speaking the truth here in haskell's lazy setting? :o
22:47:55 <FunctorSalad> the initial algebra / final coalgebra coincidence doesn't mean that the traditional combinators there aren't enough, or does it...
22:49:36 <FunctorSalad> (just that unfoldr and "pop: [a] -> Maybe (a,[a])" would be fine too)
23:32:15 <fhobia> is there a command like man but for haskell to say look up what calls are in a library ?
23:32:47 <Jafet> It's usually haddock
23:34:30 <fhobia> ok, i guess i'll fool around with that
23:34:35 <c_wraith> you can use :browse in ghci, too
23:34:46 <c_wraith> That will give you a list of things in a module
23:34:58 <fhobia> oh, awesome
23:37:27 <c_wraith> :info is also a useful command in GHCI. it will tell you about types and typeclasses
23:38:07 <Jafet> What ghci sees and what the documentation says are often different things
23:38:25 <Jafet> Don't rely on it.
23:52:30 <FunctorSalad> unless you just cabal haddock'ed it ;)
23:52:47 <FunctorSalad> :browse is cool, would be even cooler with haddock
23:53:32 <ivanm> FunctorSalad: and haddock is even cooler with hscolour'd source!
23:53:35 <FunctorSalad> is there some efficiency concern here? or what is it
23:54:06 <FunctorSalad> ivanm: and hscolour is even cooler if you hack the color scheme so it doesn't throw away information by using too few colors... or was that some other ;)
23:54:12 <Cale> I would settle for a cabal-maintained HTML index of all installed packages.
23:54:22 <ivanm> hmmmm?
23:54:27 <ivanm> what information does it throw away?
23:54:29 <Cale> (of course with source code turned on)
23:54:39 <FunctorSalad> ivanm: IIRC it has more syntax classes than colours
23:54:50 <FunctorSalad> maybe I'm thinking of some other highlighter.
23:55:14 <ivanm> Cale: cabal-install does that already
23:55:19 <ivanm> but yeah, a global one would be nice
23:55:37 <FunctorSalad> Cale: that's not much more than a 'find' and some toc-generator away, is it?
23:55:54 <FunctorSalad> if you have --documentation on already
23:56:03 <FunctorSalad> it puts them in /usr/local/share/whatever
23:56:44 <Jafet> Write a cabal package to do it!
23:56:59 <Cale> FunctorSalad: I mean something like the old hierarchical libraries documentation where it shows the union of all the packages' trees. I'm sure it could be done, but if it does it, then I'm not sure where it's going.
23:57:14 <Cale> (also, it shouldn't be putting anything in /usr/local)
23:57:27 <Cale> Maybe in ~/.cabal :)
23:57:29 <ivanm> Cale: do you mean have the library Cabal do it as well?
23:57:35 <ivanm> Cale: but yes, cabal-install does it already
23:57:49 <FunctorSalad> Cale: maybe union the "contents" pages together with some slight html-level stuff
23:57:55 <Cale> ivanm: Where does it put the master index?
23:58:11 <FunctorSalad> Jafet: too busy fixing my broken emacs initdirs :o
23:58:17 <ivanm> in ~/.cabal/share/doc/index.html IIRC
23:58:28 <Cale> hmm
23:58:31 <FunctorSalad> it slows down the fixing since your keys are broken
23:58:32 <Cale> I don't have that file
23:58:52 <Jafet> I had to jump some hoops to get that file made
23:59:30 <ivanm> Cale: you're using cabal-install-0.8.x?
23:59:34 <FunctorSalad> Cale: there are some monitor programs for putting stuff into /usr/local with no worries ;)
23:59:56 <Cale> FunctorSalad: I like installing packages as user anyway
