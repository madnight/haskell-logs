00:00:09 <deteego> Cale: thanks for your help
00:00:21 <ManateeLazyCat> Zao: So how about FreeBSD?
00:00:26 <Cale> deteego: No problem
00:00:38 <ManateeLazyCat> Zao: I found it's hard to write process-manager for cross-platform.
00:00:40 <Zao> ManateeLazyCat: Two options there. Either do things right and understand the native /proc.
00:00:48 <Zao> ManateeLazyCat: Or mount linprocfs and suffer retardedness.
00:00:57 <kmc> deteego, this is an important Haskell technique; we can pass around IO actions and execute them only when we want
00:01:00 <ManateeLazyCat> Zao: Never try FreeBSD.
00:01:02 <kmc> just evaluating an action doesn't execute it
00:01:30 <Zao> Or did you mean an actual PID by "pid" in your path?
00:01:42 <ManateeLazyCat> Zao: Yeah
00:01:50 <ManateeLazyCat> Zao: pid mean your real process id.
00:02:05 <ManateeLazyCat> Zao: Like /proc/5267, /proc/3243
00:02:19 <Cale> deteego: While it's not impossible to jump right in, it's probably a good idea to have a decent grasp of how to do more-traditional I/O in Haskell before approaching FRP. You can set up the traditional event-handler sorts of abstractions by hand quite easily, because IO actions are first-class.
00:02:40 <Zao> ManateeLazyCat: You've misspelled "interger" by the way.
00:02:44 <ManateeLazyCat> Zao: If you just run my code, you will got all running processes in your system (if you use linux).
00:02:59 <Cale> deteego: and of course, WxHaskell and Gtk2Hs already do so.
00:03:12 <Cale> deteego: What sort of programs are you interested in writing?
00:03:31 <ManateeLazyCat> Zao: I just parse basic information for /proc/YourProcessID/stat
00:03:53 <ManateeLazyCat> Zao: If i parse all status, i can use it develop my own "ps" program. :)
00:03:54 <Zao> ManateeLazyCat: You might want to document what packages you depend on.
00:03:58 <ManateeLazyCat> Zao: Thanks, i fix it.
00:04:14 <ManateeLazyCat> Zao: Yeah, just paste for fix those.
00:04:15 <ManateeLazyCat> :)
00:04:45 <ManateeLazyCat> Zao: I want let haskeller check my code before i upload to hackage.
00:04:52 <Zao> mlc: /proc/19677/stat: openFile: does not exist (No such file or directory)
00:06:00 <deteego> Cale: im actually coding a game
00:07:21 <ManateeLazyCat> Zao: Yes, it's just work when /proc is mount.
00:07:50 * ManateeLazyCat Have 44 status in /proc/pid/stat
00:09:47 <deteego> Cale: also btw, using the definition of onKey :: Event -> Char -> (Char -> IO ()) -> IO ()
00:10:02 <deteego> Cale: doing onKey OnPress 'C' (testFunc3 2 "cheese") gives the error message
00:10:10 <Cale> deteego: So, one way you could go about this, which I think would be instructive in any case, is to not worry about I/O for the time being, and instead set out to represent all (or at least part to begin with) of the game state as a single value in some fashion.
00:10:17 <ManateeLazyCat> Zao: It's okay after you mount /proc ?
00:10:34 <deteego> Cale: yes (im not up to that part yet)
00:10:50 <deteego> im currently making more of an API for scripting the game Logic
00:11:18 <Zao> ManateeLazyCat: As my paste shows (in PM), it works if I mount linprocfs.
00:11:26 <Cale> So if you have some datatype GameState, you would (depending on the sort of game) have something which would step time forward:  GameState -> GameState
00:11:32 <Zao> ManateeLazyCat: It obviously does not work if I mount the proper FreeBSD procfs.
00:11:39 <deteego> the game will have certain events (like when a unit casts a spell) and people would be able to attach functions to that event
00:11:40 <Zao> As that, unlike Linux's, is sane :D
00:12:27 <ManateeLazyCat> Zao: Oh, i need write documentation in it : "This library just works for Linux.... :) "
00:12:43 <Zao> (or FreeBSD with linprocfs)
00:13:00 <deteego> actually, I dont think I have communicated my problem Cale
00:13:27 <ManateeLazyCat> Zao: It's useful to upload to hackage?
00:13:34 <deteego> I want onKey to work with all 3 function definitions (testFunc, testFunc2 and testFunc3)
00:13:58 <deteego> (Char -> IO ()) -> IO () will only work with functions that have Char as the first argument
00:14:02 <deteego> and return an IO
00:14:20 <deteego> not for example testFunc3 :: Char → Int → String → IO ()
00:14:30 <Cale> deteego: But A -> B -> Char -> IO () will become such a function Char -> IO () just as soon as you apply it to some parameters of types A and B
00:14:45 <deteego> ah
00:14:56 <deteego> im getting an error though
00:14:57 <deteego>     Couldn't match expected type `Int' against inferred type `[Char]'
00:14:58 <deteego>     In the second argument of `testFunc3', namely `"cheese"'
00:14:58 <deteego>     In the third argument of `onKey', namely `(testFunc3 2 "cheese")'
00:14:58 <deteego>     In the expression: onKey OnPress 'C' (testFunc3 2 "cheese")
00:15:18 <Cale> oh, it seems to think it needs an Int there
00:15:22 <deteego> onKey is defined as onKey :: Event -> Char -> (Char -> IO ()) -> IO ()
00:15:37 <Cale> where you're giving it "cheese"
00:15:47 <deteego> yup
00:15:51 <Cale> can I see your current definition of testFunc3?
00:16:16 <deteego> testFunc3 :: Char → Int → String → IO ()
00:16:26 <Cale> Wrong parameter order
00:16:34 <Cale> It should be   Int -> String -> Char -> IO ()
00:16:57 <deteego> I am such an idiot
00:17:02 <deteego> lolz
00:18:19 <ManateeLazyCat> Zao: Can you tell me how to do in FreeBSD? (I mean command, i can write it in documentation), thanks.
00:19:40 <deteego> Cale: just to make things clear
00:20:24 <deteego> Char -> IO () refers to any function which has the last 2 parameters
00:20:30 <deteego> as Char -> IO ()
00:21:33 <deteego> and ) -> IO () ontop of that means the function has to return an IO
00:25:54 <nornagon> @pl \(x,y) -> (+x) *** (+y)
00:25:55 <lambdabot> uncurry ((. (+)) . (***) . (+))
00:25:55 <Cale> deteego: In general, the type A -> B is the type of functions which take a parameter of type A, and produce a result of type B
00:26:17 <Cale> deteego: and -> associates to the right, which means that when we write A -> B -> C, it really means A -> (B -> C)
00:26:42 <Cale> But of course, we normally think of that as the type of a function which takes parameters of type A and B and produces a result of type C
00:27:00 <Cale> But it's also the type of a function which takes a parameter of type A, and produces a function of type B -> C
00:28:04 <Cale> and when we write something like f x y z, what it really means is ((f x) y) z
00:28:43 <Cale> that is, apply the function f to the value x to get another function, and then apply that function to y to get yet another function, and then apply *that* function to z, and get a result which may or may not be a function
00:29:41 <Cale> deteego: Does that help at all?
00:29:45 <Cale> So, for instance...
00:29:51 <Cale> > map (+1) [1..5]
00:29:52 <lambdabot>   [2,3,4,5,6]
00:30:11 <Cale> We can apply map to the parameters (+1) and [1..5] to get this result [2,3,4,5,6]
00:30:29 <Cale> But when we apply map to (+1), we get a function, which is then applied to [1..5]
00:30:47 <Cale> So instead of applying that function directly, we could use it in another way -- say, as the parameter to map itself
00:30:57 <Cale> map (map (+1)) [[1,2,3],[4,5],[6,7,8]]
00:30:58 <Cale> > map (map (+1)) [[1,2,3],[4,5],[6,7,8]]
00:30:59 <lambdabot>   [[2,3,4],[5,6],[7,8,9]]
00:33:05 <Cale> deteego: Does that make sense?
00:33:18 <Cale> (I'm hoping that you're already familiar with what map does)
00:36:18 <Cale> deteego: I'm off to watch something, I'll be back later if you have any questions...
00:36:39 <Cale> (or you can just ask the others here, I'm sure they'd help :)
00:36:41 * hackagebot wai-handler-fastcgi 0.0.0.1 - WAI wrapper around direct-fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.0.0.1 (MichaelSnoyman)
00:39:26 <Zao> ManateeLazyCat: mount -t linprocfs linproc /compat/linux/proc
00:39:39 <Zao> ManateeLazyCat: Note that it's normally mounted in /compat/linux/proc, not /proc itself.
00:40:17 <cdsmithus> Hmm... adding a custom preprocessor worked for building with cabal, but now cabal sdist complains that it can't find a source file.
00:40:22 <ManateeLazyCat> Zao: Any Environment variable for this? Maybe i don't need write fixed patch.
00:41:35 <dcoutts_> cdsmithus: ah, try runghc Setup sdist
00:41:38 <ManateeLazyCat> Zao: BTW, System.Posix.Proc is appropriate name? I don't want dirty namespace of GHC.
00:42:01 <Zao> ManateeLazyCat: It's not Posix.
00:42:09 <cdsmithus> dcoutts: thanks, I will
00:42:12 <dcoutts_> cdsmithus: the problem is the Setup.hs interface is almost useless for cabal-install to wrap properly
00:42:36 <ManateeLazyCat> Zao: Can you suggeste a appropriate name?
00:42:38 <deteego> Cale: yes that makes sense
00:42:41 <deteego> Cale: thanks
00:42:41 <kmc> SPJ is so much fun to watch
00:42:47 <Zao> System.Linux.Proc?
00:42:48 <dcoutts_> cdsmithus: the Setup.hs interface is designed for humans rather than machines, it should just prepare the source tree but instead it does the whole thing
00:42:51 <cdsmithus> That worked.  Thanks!
00:42:51 <kmc> "this is way better than lots of pointers like snakes" *waves arms around*
00:42:54 <Zao> Or something similiar.
00:43:19 <ManateeLazyCat> Zao: But FreeBSD can work when you mount /proc
00:43:22 <cdsmithus> I should just use TH and get rid of the preprocessor altogether, I suppose.
00:43:30 <ManateeLazyCat> Zao: And maybe other Unix system can works too.
00:43:39 <Twey> ManateeLazyCat: But they work differently.
00:43:55 <cdsmithus> But not being familiar with TH, I found it easier to generate source code rather than write TH magic.
00:44:07 <ManateeLazyCat> Twey: Have OS tag in GHC or Cabal?
00:44:17 <Zao> ManateeLazyCat: It's however still the Linux kind of procfs.
00:44:45 <pasc1> hi, i hope somebody can help me with my problem: http://pastebin.com/Bpxcdm2T
00:44:58 <ManateeLazyCat> Zao: I have see your result, works fine, isn't?
00:45:35 <Zao> ManateeLazyCat: It is still the Linux dialect of proc. It's not a "posix proc" nor a "freebsd proc".
00:45:44 * hackagebot mvclient 0.1 - Client library for metaverse systems like Second Life  http://hackage.haskell.org/package/mvclient-0.1 (ChrisSmith)
00:45:49 <kmc> pasc1, what are you using Dynamic for?
00:45:58 <ManateeLazyCat> Zao: Ok, i change it.
00:46:09 <kmc> pasc1, i think you might want an existential over Langs
00:46:42 <pasc1> kmc: just as a interface. i need to know the type my languages to load them
00:46:43 <cdsmithus> Oops, I managed to leave the preprocessor stuff out of the Cabal package.  Drat!
00:47:01 <kmc> pasc1, the simple alternative is data SomeLang = SEn (Lang En) | SFr (Lang Fr) | ...
00:47:14 <kmc> the existential type would be data SomeLang = forall a. SomeLang (Lang a)
00:47:33 <kmc> Dynamic might be a reasonable solution but i think the others are better
00:48:43 <kmc> anyway, to select a language by name
00:48:51 <pasc1> kmc: okay. the simple alternative does not seem to be good in order to add new languages. existential types look interesting
00:48:52 <kmc> you'd build a Data.Map LangName SomeLang
00:48:57 <kmc> yeah
00:49:21 <kmc> pasc1, existentials are useful for an "open" union like that
00:49:55 <ivanm> preflex: seen Fallen_Demon
00:49:55 <preflex>  Fallen_Demon was last seen on #haskell 22 days, 48 minutes and 30 seconds ago, saying: So a ton of legitimate emails get swept into places they shouldn't
00:50:37 <pasc1> kmc: okay, thank you for help!
00:51:35 <ivanm> kamatsu: for the ICFP, AFAIK _any_ language is allowed
00:51:39 <kmc> pasc1, a standard example is (the new) Control.Exception
00:51:45 <ivanm> they just hope an FP language wins ;-)
00:51:53 <ivanm> *ICFP contest
00:52:08 <kamatsu> ivanm: that's sad
00:52:15 <ivanm> why?
00:52:33 <kamatsu> i mean, it always seems like those programming competitions always get edged out by C programs
00:53:02 <arcatan> every language is a functional one!
00:53:09 <kamatsu> functional as in, it works
00:53:13 <cdsmithus> kamatsu: I don't think C normally wins ICFP.
00:53:23 <kamatsu> cdsmithus: i see
00:53:32 <kamatsu> well, hopefully some haskellers enter
00:53:39 <ivanm> @google icfp contest winners
00:53:40 <lambdabot> http://icfpcontest.org/
00:53:40 <lambdabot> Title: ICFP '09 Programming Contest - Main Page
00:53:47 <ivanm> TeX won the judges choice awards IIRC
00:53:51 <ivanm> (last yera, that is)
00:54:01 <Ke> o_O
00:54:06 <kamatsu> TeX?
00:54:07 <kamatsu> really?
00:54:34 <ivanm> really
00:54:39 <ivanm> with a little perl for networking
00:54:47 * hackagebot mvclient 0.1.1 - Client library for metaverse systems like Second Life  http://hackage.haskell.org/package/mvclient-0.1.1 (ChrisSmith)
00:55:04 <ivanm> kamatsu: considering that the only prize is that you nominate a language to be declared to be really cool/nifty/something like that, only people who care enter
00:55:11 <nornagon> it's a kamatsu
00:55:14 <nornagon> hi kamatsu
00:55:17 <ivanm> and it's time based, so FP langs have an advantage in coding speed
00:55:20 <kamatsu> nornagon: hi nornagon
00:55:31 <nornagon> > Linking particles ...
00:55:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:55:42 <nornagon> (why is ghc so slow to link :()
00:55:44 <kamatsu> nornagon: ahaha, I should, like, do that
00:55:47 * hackagebot proc 0.0.1 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.1 (AndyStewart)
00:56:02 <kamatsu> nornagon: i can't imagine it would take very long
00:56:05 <SubStack> :o that looks useful
00:56:12 <ivanm> kamatsu: http://web.cecs.pdx.edu/~sheard/2008IcfpContest/results/
00:56:17 <nornagon> kamatsu: i've spent about 20 mins on it so far and i'm almost done
00:56:21 <ivanm> it was 2008, not 2009 sorry
00:56:24 <kamatsu> nornagon: cool, i'll make a start tonight
00:56:26 <ivanm> and LaTeX, not plain TeX
00:56:36 <SubStack> hackage really needs a "browse" link for cruising the files in those tarballs
00:56:44 <kamatsu> Java!?
00:56:59 <ivanm> SubStack: well, if people use the cabal 1.6 functionality to link to the repo...
00:57:10 <ivanm> http://en.wikipedia.org/wiki/ICFP_Contest
00:57:37 <dcoutts_> SubStack: the new server has that feature actually, browsing the tarball contents directly
00:57:52 <ivanm> hey dcoutts_
00:57:58 <dcoutts_> @yarr!
00:57:58 <lambdabot> Shiver me timbers!
00:58:01 <ManateeLazyCat> Why there is not haddock document at http://hackage.haskell.org/package/proc ? Need wait a moment?
00:58:01 <kamatsu> btw, ivanm, will you be mailing reminders when AusHac is about to begin?
00:58:11 <ivanm> kamatsu: yeah
00:58:11 <kamatsu> or alex mason
00:58:20 <kamatsu> ok, good, cos i won't remember otherwise
00:58:23 * ivanm still has to book accom + organise transport
00:58:30 <ivanm> I've got to head off for a few hours; bbl
00:58:39 <kamatsu> later
00:58:44 <dcoutts_> ManateeLazyCat: yep, just wait a bit
00:58:54 <ManateeLazyCat> dcoutts_: Oh, thanks.
01:00:40 <SubStack> dcoutts_: nifty!
01:01:22 <dcoutts_> SubStack: we mainly added the serving tarball content feature to help with documentation uploads but it's handy for the source tarballs too
01:01:58 <SubStack> well that is an especially handy feature when people make an examples/ directory
01:03:48 <deteego> I wild kamatsu approaches
01:04:00 <kamatsu> deteego: eh?
01:05:06 <kamatsu> deteego: you're not matt, are you?
01:05:14 <deteego> yes Iam
01:05:23 <kamatsu> >_> too many people i know in IRC.
01:05:28 <deteego> lol
01:06:03 <nornagon> kamatsu: ok, done
01:06:08 <nornagon> about 30 mins all up
01:06:19 <deteego> hows your project going kamatsu
01:06:23 <kamatsu> deteego: which one?
01:06:30 <deteego> ghc backend
01:06:36 <kamatsu> deteego: slow
01:06:46 <kamatsu> in performance ;)
01:06:51 <kamatsu> and in progress ;)
01:06:57 <deteego> lolz
01:07:22 <deteego> hmmm, I wonder if Go is worth looking into
01:07:30 <nornagon> kamatsu: is it just me, or is something wrong when none of the assignments for a subject take longer than 30 minutes?
01:07:45 <kmc> deteego, the programming language?
01:07:49 <deteego> kmc: yeah
01:08:03 <kamatsu> nornagon: If i didn't know haskell at all, it might be challenging?
01:08:17 <kamatsu> nornagon: remember the course assumes no haskell knowledge
01:08:27 <nornagon> i guess
01:08:47 <nornagon> trying to decide what subjects to take next year
01:08:49 <kamatsu> the 2nd agda assignment was harder, but still only took me an hour or so
01:08:53 <nornagon> *semester
01:09:05 <kamatsu> I'm teaching prog langs, have you done that one yet?
01:09:09 <nornagon> nope
01:09:17 <deteego> kamatsu: what one is that?
01:09:20 <kamatsu> comp3161
01:09:28 <nornagon> i guess i should do that one
01:09:29 <deteego> ah right
01:09:30 <kmc> Go is worth looking into.  it has some nice things, and also makes some basic mistakes that have been known for decades
01:09:41 <kmc> it's not going to save the world, imo
01:09:41 <deteego> kmc: such as?
01:09:48 <kmc> nullable references
01:09:51 <kmc> no polymorphism
01:09:55 <deteego> ouch
01:09:59 <nornagon> no polymorphism?!
01:10:08 <kamatsu> it has structural subtyping
01:10:16 <kamatsu> and therefore ad-hoc polymorphism
01:10:31 <kmc> there's a type like java's Object.  you can cast up to it, and cast down, and it's checked at runtime
01:10:38 <kmc> meaning the polymorphism situation is like 2004-era java
01:10:40 <kamatsu> kmc: it also has interfaces and ad-hoc poly
01:10:40 <kmc> aka terrible
01:10:48 <kmc> yeah
01:10:51 <kmc> very, very ad-hoc
01:11:02 <kamatsu> Haskells polymorphism is ad-hoc too
01:11:05 <kamatsu> i fail to see the problem
01:11:06 <kmc> as in, since InternalCombustionEngine and BitRegister both have a "shift" function, they share an interface :D
01:11:18 <kamatsu> kmc: only if you define an interface with a "shift" function
01:11:18 <kmc> Haskell also has parametric polymorphism
01:11:35 <kmc> kamatsu, but once i've done so, both those classes are members automatically
01:11:53 <kmc> Haskell's generic collections, etc. are statically type safe in a way that Go's can't be
01:12:02 <kmc> it's exactly the same difference between Java 5 and earlier Java
01:12:06 <kamatsu> They were trying to approximate dynamic typing.
01:12:29 <kamatsu> with the automatic interfaces
01:12:30 <kmc> it's funny how the go-bots on reddit etc. think that casting to interface{} is so much better than casting to Object
01:12:40 <kmc> kamatsu, i know.  i just think it's bad.
01:12:45 <kamatsu> I agree
01:13:03 <kmc> Go is a statically typed language for people who dislike statically typed languages because they don't know the difference between static typing and manifest typing
01:13:21 <kamatsu> Also, it has nice  concurrency features, but there is nothing much new there not seen already in Haskell or Erlang.
01:13:22 <kmc> btw, i think it should have shipped with a REPL
01:13:26 <kmc> given this target audience
01:13:37 <kmc> and their use of the name "goroutines" is annoying and misleading
01:13:42 <kmc> they're not coroutines
01:13:46 <kmc> they're just (green) threads
01:13:49 <kmc> but threads have bad p.r.
01:14:10 <kamatsu> also, i'm not sure about this
01:14:39 <kamatsu> but the way they sell it as a concurrent language while providing no way to easily have immutable data or control effects seems scary
01:14:58 <kamatsu> immutable data is basically the same as in java, very cumbersome.
01:15:08 <nornagon> sigh
01:15:31 <deteego> id probably prefer to use D
01:15:43 <kamatsu> yeah, if you can choose which standard library to use
01:15:47 <deteego> even though D still has library issues
01:15:48 <kamatsu> or which compiler will work
01:15:53 <deteego> yeah....
01:15:56 <kamatsu> or which version of the language spec to use
01:15:57 <nornagon> kamatsu: haha, as usual give is broken when i try to submit my assignment :(
01:16:14 <kamatsu> nornagon: that always happens, has manuel just not set it up yet?
01:16:25 <deteego> I wonder if there is an ETA for D 2.x
01:16:27 <nornagon> it's set up, but i get perms errors when it tries to compile
01:16:45 <kamatsu> nornagon: I can shout at Manuel in the PLs meeting tomorrow ;)
01:16:48 <nornagon> :P
01:16:53 <nornagon> i already sent him an email
01:16:53 <kamatsu> well, not shout
01:18:34 <nornagon> :t tails
01:18:35 <lambdabot> forall a. [a] -> [[a]]
01:18:42 <nornagon> i guess that's in Data.List
01:19:19 <kmc> yeah
01:19:59 <nornagon> > zip ps (tails ps) where ps = [1,2,3,4]
01:20:00 <lambdabot>   <no location info>: parse error on input `where'
01:20:18 <nornagon> > let ps = [1,2,3,4] in zip ps (tails ps)
01:20:19 <lambdabot>   [(1,[1,2,3,4]),(2,[2,3,4]),(3,[3,4]),(4,[4])]
01:21:30 <deteego> kamatsu: you got any other projects going on?
01:22:26 <kamatsu> operational transforms editor
01:22:58 <kamatsu> deteego: see opardum http://www.liamoc.net/pages/projects.html
01:25:05 <deteego> kamatsu: oh nice
01:25:32 <mxc> hi
01:25:39 <kmc> hi
01:25:54 <deteego> hi
01:25:57 <mxc> so i was chatting a while ago about continuations for error handling vs using Eithers
01:26:31 <mxc> the consensus was that with continuations, you dont need a conditional everytime you bind so they should outperform using Eithers
01:26:51 <mxc> (the Data.Cereal authors first promoted this i think)
01:27:08 <kmc> hmm.  ghc had (has) a "vectorized returns" optimization which is like a little local CPS transform around each "case", and might make this irrelevant?
01:27:40 <mxc> in a quick and dirty benchmark, my ErrorCPS runs in twice the time as using Eithers
01:28:11 <roconnor> mxc: edwardk's library uses data families to automagically cps optimize monad transformation stacks
01:29:17 <roconnor> but for the lazy, simply wrapping a Cont around your monad stack can also speed things up: http://r6.ca/blog/20071028T162529Z.html
01:29:56 <mxc> I wrote my own monad which is a continuation but that takes two functiosn ,not one
01:30:08 <roconnor> ya
01:30:12 <mxc> so it functions like the either function in the prelude
01:30:26 <roconnor> that will be what edwark does, and is even faster than simply wrapping a ContT around your monad.
01:30:33 <mxc> am i letting some laziness seep through here:
01:30:39 <mxc> {-# INLINE bindErrCPS  #-}bindErrCPS ::  ErrCPS e m b -> (b -> ErrCPS e m a) -> ErrCPS e m a
01:30:41 <mxc> > bindErrCPS m f =  ErrCPS $ \err good -> runErrCPS m err $ \x -> x `seq` runErrCPS (f x) err good
01:30:44 <mxc> oops sry
01:30:44 <lambdabot>   <no location info>: parse error on input `='
01:30:51 <roconnor> why seq?
01:30:52 <mxc> {-# INLINE bindErrCPS  #-}
01:30:52 <mxc> bindErrCPS ::  ErrCPS e m b -> (b -> ErrCPS e m a) -> ErrCPS e m a
01:30:52 <mxc> bindErrCPS m f =  ErrCPS $ \err good -> runErrCPS m err $ \x -> x `seq` runErrCPS (f x) err good
01:31:05 <edwardk> roconnor: yeah, though upon reflection it only seems to be a BIG win when the bottom of the stack is in codensity form
01:31:11 <mxc> i just put that in now, hoping that it might speed it up a bit
01:31:31 <mxc> voodoo programming :(
01:31:48 <roconnor> edwardk: what is codensity form?
01:31:49 <edwardk> (that lets me use free implementations for binds, returns, fmap, etc. and not manipulate most of the stack
01:32:16 <mxc> ErrCPS is a newtype:
01:32:16 <mxc>  newtype ErrCPS e m a = ErrCPS { runErrCPS :: forall r . (e -> m r) -> (a -> m r) -> m r }
01:32:18 <roconnor> and what is it that only seems to be a big win when?
01:32:19 <edwardk> newtype Codensity f a = Codensity { runCodensity :: forall r. (a -> f r) -> f r }
01:32:27 <edwardk> 'universally quantified ContT'
01:33:14 <edwardk> mxc: that is a right kan extension, i have it in monad-ran as Ran (ErrorT e m)
01:33:39 <mxc> right kan?
01:34:02 <edwardk> mxc: google comonad.com and kan extensions i have a few articles on the topic
01:34:19 <edwardk> 'generalized cps' is a good way to think about it in haskell terms
01:34:55 <deteego> kamatsu: for your presentation on safe
01:35:14 <deteego> kamatsu: you can also say that Haskell puts all the restrictions in the right places, and puts the flexibility where it matters
01:35:53 <deteego> which is in data types, functions etc etc etc
01:36:52 <kamatsu> deteego: i've already done that presentation
01:38:03 <deteego> kamatsu: yeah but for future use, I guess...
01:38:44 <kamatsu> yeah, good idea
01:39:46 <mxc> yeah, comonad.com is a couple years of doctoral category theory above my head
01:39:51 <deteego> also I guess its possible writing stupid code in Haskell, but its kinda the same thing with Python
01:40:00 <deteego> in doing so you are probably shooting yourself in the foot
01:40:06 <deteego> where as other languages just allow you to do it
01:41:26 <mxc> i'm just surprised that using continuations is so much slower than Either with conditionals
01:41:31 <roconnor> right kan isn't really more scary than monad
01:42:03 <roconnor> mxc: didn't you say it was faster?
01:42:16 <roconnor> oh no
01:42:21 <roconnor> you said it was slower
01:42:22 <mxc> Either runs almost exactly 3 times faster
01:42:26 <roconnor> :O
01:42:35 <mxc> which i why i'm thinking i might be doing something wrong or letting in some laziness
01:43:04 <mxc> which i why I stuck that seq in the bind statment
01:43:08 <roconnor> :O
01:43:13 <mxc> s/statment/definition
01:44:58 * hackagebot gsmenu 1.1 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-1.1 (TroelsHenriksen)
01:45:09 <mxc> and -O2 seems to have no effect
01:45:29 <roconnor> what is your benchmark?
01:46:48 <mxc> sec, i'll stick it on hpaste
01:47:39 <mxc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25421#a25421
01:47:45 <mxc> all in main
01:48:16 <mxc> either runs the tests in about 35 msec on average, ErrCPS in 95
01:50:04 <roconnor> what is mkEMA?
01:51:47 <rajeshsr> hi
01:52:17 <rajeshsr> how do i realize a semantics like this? if(!vis[i]) {vis[i] = 1; //codes}else //codes
01:52:30 <Botje> rajeshsr: uh. context?
01:52:54 <rajeshsr> Botje, yep, a sort of static memory..
01:53:15 <Botje> the direct translation would involve an array
01:53:19 <Cale> rajeshsr: Er, you're interpreting an imperative programming language?
01:53:25 <Baughn> rajeshsr: I feel almost certain you want something entirely different in Haskell
01:53:29 <Botje> rajeshsr: but can you explain what you're doing on a slightly higher level?
01:53:30 <mxc> just a simple function that runs an exponentation moving average on the list
01:53:38 <Cale> Or are you asking how to write code like that in Haskell?
01:53:38 <Botje> often there's a MUCH better approach
01:53:59 <roconnor> mxc: does it use error?
01:54:18 <mxc> roconnor - yeah, in the call to midError
01:54:22 <rajeshsr> Cale, well, i am generating a list which has some cycles, i need to do something if i found a cycle, after finding the cycle length..
01:54:45 <Cale> rajeshsr: I'm sorry, what?
01:54:51 <roconnor> mxc: can you paste the code?
01:54:53 <mxc> roconnor - its a toy function, more to benchmark the Either error monad vs. my ErrCPS monady
01:55:00 <mxc> its all on the hpaste
01:55:03 <Cale> rajeshsr: What are you trying to compute?
01:55:11 <rajeshsr> Cale, well, it is similar to 3n+1 problem, Collatz conjecture or something..
01:55:13 <mxc> oops, my bad
01:55:15 <roconnor> rajeshsr: google code jam?
01:55:16 <Cale> rajeshsr: okay
01:55:22 <roconnor> ah
01:55:24 <roconnor> nevermind
01:55:25 <rajeshsr> roconnor, exactly! 3rd problem!
01:55:29 <roconnor> oh I was right
01:55:57 <mxc> roconnor - you were right, just updated it hpaste
01:56:01 <mxc> i mucked up the copy/paste
01:56:11 <roconnor> rajeshsr: are you doing the O(N) or the O(N^2) algorithm.
01:56:14 <roconnor> ?
01:56:31 <rajeshsr> roconnor, O(N^2) for now, but we can make it O(N) with a queue..
01:56:43 <rajeshsr> deque to be more precise..
01:56:56 <rajeshsr> but i do not know how would i do that in haskell!
01:56:58 <roconnor> interesting
01:57:15 <rajeshsr> first let me learn about finding cycles with O(N^2) then move to deque
01:57:28 <roconnor> rajeshsr: I'd probably use lists rather than arrays for O(N^2) cycle finding
01:57:50 <flux> hmm, ensimmäinen OCR-yritys tesseractilla di-kääreistä: Sig;-gfg;;:6‘ 6** ¤YhkV¤-iny=vf¤hwnvf¤¢beqqv.c¤c . I \ uis0x£iw1;.uxLuw4mz4¤n9Ppq¤6z .. pitänee säätää vielä tai todeta että standardiocr ei oikein pure :)
01:57:58 <flux> whops, echan
01:58:00 <rajeshsr> well, using list can make it O(N^3)
01:58:08 <rajeshsr> indexing in list is O(N)
01:58:13 <Cale> What are you trying to compute?
01:58:16 <aristid> flux: ocr is flimsy.
01:58:30 <rajeshsr> Cale, i was trying to solve Problem C at code jam
01:58:31 <flux> aristid, indeed
01:58:50 <roconnor> rajeshsr: ya but you only need to call findIndex which is O(N) making the whole thing O(N^2)
01:59:05 <Cale> Oh, I see where it is
01:59:12 <Cale> Didn't notice the sidebar there.
02:00:03 <rajeshsr> roconnor, ha, ok! It is O(N*2*N)! :)
02:00:44 <rajeshsr> somehow i thought it will get O(N^3)!
02:01:29 <Cale> Yeah, indexing in a list is usually the wrong thing to do. There's usually a better way to express things.
02:01:53 <roconnor> rajeshsr: if you actually need to use random access for some problem similar to this in the future, you will probably want to use STArray, or maybe DiffArray if you want something easier to use.
02:02:12 <roconnor> rajeshsr: but as you see for this problem, lists are fine.
02:03:06 <rajeshsr> roconnor, hmm, ok. Let me see about them. What about Data.Array?
02:03:33 <aristid> rajeshsr: Data.Array is expensive to mutate
02:04:38 <mxc> STArrays could be the solution
02:04:48 <mxc> roconnor - any thoughts on my ErrCPS code?
02:04:56 <rajeshsr> aristid, oh, ok
02:04:56 <Cale> Using STArray is admitting defeat
02:05:00 <roconnor> mxc: 'fraid not. :(
02:05:01 <mxc> oops, didn't notice that you just mentioned STArrays
02:05:07 <rajeshsr> roconnor, BTW, you want to look at how i solved small set with haskell? One of the ugliest code ever! :)
02:05:15 <rajeshsr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25423#a25423
02:05:35 <rajeshsr> like to know how i can improve my coding style..
02:05:53 <roconnor> ya, get rid of arrays :D
02:06:07 <Cale> rajeshsr: Whenever you see something repeated, make a definition
02:06:08 <roconnor> rajeshsr: or are you talking about formating of code?
02:06:18 <rajeshsr> roconnor, little did i realize that i didn't use arrays the way i want! It is just a function actually!
02:06:46 <rajeshsr> Cale, hmm, ok so how do you get those common stuffs out of where?
02:06:58 <roconnor> rajeshsr: you can remove the "return ()" in process
02:07:03 <rajeshsr> where x = [y] y = [1..] is that allowed?
02:07:11 <Cale> rajeshsr: also, don't chain ($) like that, use (.) to compose things, and only one ($) at the end to apply it, and it'll make it easier to chop up.
02:07:33 <roconnor> where is dr.haskell when you need it :D
02:07:51 <Cale> take (n+1) . takeWhile (<= maxPos) . scanl (+) 0 . drop ind . cycle
02:08:19 <rajeshsr> Cale, oh, ok!
02:08:54 <rajeshsr> But composition seems to work only with functions taking 1 paramater, right? i remember trying it and failing!
02:09:16 <c_wraith> all functions only take one parameter
02:09:21 <Twey> Yes, but all functions take one parameter, so you can compose compositions ;)
02:09:23 <Cale> rajeshsr: Whenever you can write f $ g $ h $ x, you can rewrite it to f . g . h $ x
02:09:48 <Twey> Well, not quite whenever
02:09:58 <Cale> rajeshsr: The latter is better style, because you can start reading it or breaking it up from anywhere -- g . h is a well-typed thing
02:10:01 <rajeshsr> yep, x is a single parameter, in this case it isn't, right?
02:10:03 <mxc> cale dont you need (f . g . h) x
02:10:03 <Twey> Since . binds much more tightly than $
02:10:04 <Cale> while g $ h is not
02:10:12 <rajeshsr> Cale, ha, got it! You curried..
02:10:12 <Cale> mxc: The $ takes care of that
02:10:25 <Cale> rajeshsr: hm?
02:10:31 <rajeshsr> takeWhile (<= maxPos) .
02:10:33 <Twey> So if one of f, g, or h has an operator that binds more tightly than $ but less tightly than ., you need brackets
02:10:37 <rajeshsr> i missed the dot there..
02:10:41 <Cale> rajeshsr: Oh, takeWhile is a curried function
02:10:43 <aristid> @src $
02:10:43 <lambdabot> f $ x = f x
02:10:48 <Cale> We partially apply it there
02:10:55 <Cale> But you were already partially applying it
02:10:57 <roconnor> mxc: I'm a bit surprised at your result, but edwardk is the expert on this subject.
02:11:00 <Cale> I didn't change that
02:11:06 <Twey> f $ g *** h $ i = f . (g *** h) $ i, not f . g *** h $ i
02:11:14 <Cale> last $ take (n+1) $ takeWhile (<= maxPos) $ scanl (+) 0 $ drop (ind) $ cycle lis
02:11:14 <aristid> @src ***
02:11:15 <lambdabot> f *** g = first f >>> second g
02:11:21 <Cale> ^^ you have this in your code
02:11:30 <aristid> Twey: arrows oO
02:11:39 <Cale> We can replace all the ($)'s but the last one with (.)
02:11:50 <Twey> aristid: Doesn't really matter what the operator is… it's just the first that sprang to mind with the appropriate characteristics
02:11:58 <Cale> last . take (n+1) . takeWhile (<= maxPos) . scanl (+) 0 . drop ind $ cycle lis
02:12:01 <Twey> I think + works just as well, though you're unlikely to see it there
02:12:05 <mxc> edwardk :  any thoughts on why the CPS error handling is 3 times slower than using Either in the main functions here:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25421#a25422
02:12:12 <Cale> and actually, I usually like to push that last function into the composition while I'm at it:
02:12:16 <Cale> last . take (n+1) . takeWhile (<= maxPos) . scanl (+) 0 . drop ind . cycle $ lis
02:12:37 <Cale> It's the same thing, but written only slightly differently
02:12:52 <aristid> hmm does anybody use the arrow proc syntax?
02:13:00 <Cale> But the advantage is that, for example,  takeWhile (<= maxPos) . scanl (+) 0  is a valid function on its own
02:13:18 <Cale> while  takeWhile (<= maxPos) $ scanl (+) 0  is a type error
02:13:30 <aristid> and as a function on its own, it can be factored out easily
02:13:47 <Cale> So we've effectively made more subexpressions for ourselves, and yeah, made the code easier to factor
02:13:54 <aristid> @src scanl
02:13:54 <lambdabot> scanl f q ls = q : case ls of
02:13:54 <lambdabot>     []   -> []
02:13:54 <lambdabot>     x:xs -> scanl f (f q x) xs
02:14:12 <Cale> > scanl (+) 0 [1,20,300,4000,50000]
02:14:13 <lambdabot>   [0,1,21,321,4321,54321]
02:14:44 <zebcca> hi, newbie here, just starting out with haskell -- having a problem with the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25424
02:14:56 <zebcca> it works as expected in that form, but if i remove/comment the putStr in line 6, i get a "no parse" error
02:15:06 <zebcca> i'm finding it kind of baffling at the moment...is this some subtlety of lazy I/O i'm not grasping?
02:15:24 <Cale> zebcca: Never ever hClose a handle which has had hGetContents applied to it
02:15:32 <rajeshsr> Cale, any thought about detecting cycles?
02:15:33 <aristid> @let fac = scanl (*) 1 [2..]
02:15:34 <lambdabot>  Defined.
02:15:40 <Cale> zebcca: yes, it's lazy IO
02:16:14 <zebcca> ok...and that also explains why i get the same problem using withFile rather than explicit open/close?
02:16:23 <Cale> zebcca: Which some people dislike, but it can also be convenient if you're not opening so many things that you have to be cautious about your usage of filehandles.
02:16:58 <Cale> zebcca: yeah
02:17:39 <zebcca> Cale: ok, thanks...so the "appropriate" thing to do there would be to just leave it open?
02:17:40 <Cale> zebcca: withFile will close the filehandle, which will cause the unevaluated portion of the magical string value that hGetContents gives you be truncated.
02:17:44 <Cale> yeah
02:18:10 <Cale> It'll be closed at some point as the string you got is garbage collected, or if the evaluation of the string gets to the end
02:18:44 <rajeshsr> roconnor, you solved C with haskell?
02:19:07 <zebcca> Cale: alright, i think i understand...thanks
02:19:40 <roconnor> rajeshsr: yes, I did all the problems in Haskell
02:19:43 <aristid> is there a diagram or something similar how to decide which container to use?
02:20:06 <Cale> zebcca: If you want to slurp a whole file into memory at once so you can close the handle, it's best to use something like the hGetContents from Data.ByteString (the strict variant), and then convert that to a String if you need to.
02:20:15 <aristid> like http://adrinael.net/containerchoice for the language whose name must not be sayed
02:20:36 <Cale> I don't know why, but unfortunately there aren't pre-existing strict versions of the lazy String IO stuff.
02:21:01 <rajeshsr> roconnor, oh, ok! seems you go by the same name at code jam too!
02:21:07 <roconnor> yep
02:21:31 <roconnor> rajeshsr: did you enter the contest? if so under what name?
02:21:49 <rajeshsr> roconnor, under rajeshsr. I solved only A!
02:22:09 <roconnor> rajeshsr: that's good enough
02:22:49 <rajeshsr> now trying to solve all those problems in haskell..
02:22:51 <Baughn> zebcca: You'll also want to look at bytestring-mmap, which will work better if your read pattern isn't sequential
02:23:26 <Baughn> aristid: Mm. With haskell, it's a single node - "Use Data.Map".
02:23:38 <aristid> Baughn: is Data.Map this good?
02:23:45 <Cale> hehe
02:23:59 <Baughn> aristid: It's very, very good. I may have exaggerated slightly, but mostly I didn't.
02:24:31 <Baughn> aristid: Though of course lists, Data.Seq and arrays also have their place
02:25:14 <Cale> Also, the PSQueue package has a lovely priority search queue
02:25:48 <Cale> (which is like a sort of combination of a priority queue and a finite map)
02:26:25 <aristid> i think i will try to make a Data.Map for the factorial function! \o/
02:26:26 <Cale> and there are other sorts of queues as well, but Data.Sequence works reasonably well for that most of the time
02:27:18 <Baughn> aristid: For memoization with dense indices, do keep in mind that Array is lazy in the values.
02:27:32 <aristid> Baughn: but Array is not infinite!
02:27:47 <Baughn> aristid: Neither is Data.Map
02:28:02 <aristid> Baughn: hmm why not? :)
02:28:04 <Baughn> aristid: If you need an infinite map.. umh, there probably is something somewhere, but...
02:28:07 <Baughn> Anyone?
02:28:43 <Baughn> aristid: It's strict in the spine. Of course, you can indefinitely add elements, but you can't build its spine lazily. :/
02:29:15 <aristid> is Data.Tree strict in the spine?
02:29:30 <Baughn> No.
02:29:58 <Cale> Data.MemoCombinators
02:30:09 <aristid> @hoogle Data.MemoCombinators
02:30:09 <lambdabot> No results found
02:30:17 <Cale> http://hackage.haskell.org/package/data-memocombinators
02:30:27 <Cale> It's brilliant
02:30:38 <Cale> and you can memoise over infinite domains like Integer
02:30:47 <aristid> too bad i don't have cabal running yet :/
02:30:57 <Cale> No mutation required too :)
02:31:11 <Baughn> aristid: You saw the cabal-install bootstrap script, right?
02:31:17 <Cale> It hitchhikes on the little bit of mutation which is present in any implementation of lazy evaluation.
02:31:45 <aristid> Baughn: i want to reinstall my computer this week, so i don't want to install software for just a few days
02:31:58 <aristid> it's ubuntu 10.04 time :)
02:32:30 <Baughn> Oh.. that was released already?
02:32:33 <Cale> aristid: I'm interested to know how that goes
02:32:42 <aristid> Cale: mutation in lazy evaluation? oO
02:33:02 <Cale> aristid: Yeah, under the covers, expressions are being replaced by values
02:33:13 * Baughn uses Arch.. less annoyance, since I generally build my own environment from scratch.
02:33:23 <aristid> Baughn: yes yes :) i will use that opportunity to clean up some cruft and reformat everything with ext4
02:33:24 <Cale> I had such a horrible time with the last couple Ubuntu upgrades
02:33:36 <Baughn> aristid: If you're feeling daring, you might consider Btrfs
02:33:40 <Cale> Removing PulseAudio is becoming more and more painful.
02:33:52 <aristid> Baughn: it's my only machine, so no :)
02:33:52 <Cale> Or it has been anyway
02:33:59 <rajeshsr> roconnor, BTW, you have any idea of representing the computation i said: if(!vis[i]) {vis[i] = 1; //}...
02:34:01 <Baughn> aristid: I've been running it without issue for several months now, and.. well, I get 30% more speed from my SSD with it...
02:34:29 <rajeshsr> roconnor, other than using a list which makes vis[i] O(N)!
02:34:30 <Baughn> Cale: Eheh. But I don't /want/ to remove pulseaudio. ^^;
02:34:32 <aristid> Baughn: i will definitely use btrfs when it's a bit more mature. i'm very keen on the shininess it will bring
02:34:42 <Botje> rajeshsr: shrug. use a set?
02:34:44 <Baughn> Cale: It's, um, an improvement on Alsa.
02:34:47 <Botje> maybe an intset
02:35:11 <rajeshsr> Botje, oh, i see! Let me check that..
02:35:28 <Baughn> aristid: Watching the mailing list, they've gotten past the "fix horrifying data-eating bugs" stage, and even the "fix crash-bugs" stage..
02:35:36 <Cale> Baughn: It takes the couple dozen volume controls on my soundcard (an audigy 2), and shoves them all behind a single master volume control, and pegs my headphone volume at 0
02:35:44 <aristid> Cale: so, back to haskell... replacing expressions by values is hidden mutation? didn't think of it that way, yet... but i guess it helps to explain why exactly laziness makes haskell so much more feasible :>
02:35:48 <osfameron> alsa/pulse/jack/ohmyohmy... linux has too many soundsystems, and too much pain lurks at their interstices...
02:36:18 <Zao> All you need is OSS.
02:36:22 <Baughn> aristid: Oh yes. There are theorems that declare many data structures that are O(1) in an imperative to be impossible below O(lg n) in a purely functional language.
02:36:24 <SubStack> gaaaaah packages with -Werror
02:36:33 <Baughn> aristid: Lazy mutation kiboshes that rule. :)
02:36:40 <aristid> Baughn: also, the ST monad
02:36:52 <Baughn> aristid: No, that's got nothing to do with laziness. ST is just cheating.
02:36:58 <aristid> no it's not :P
02:37:14 <Baughn> ST provides a restricted form of unsafePerformIO
02:37:35 <Baughn> (Restricted and /safe/)
02:37:42 <Baughn> ..it's still not a purely functional /anything/
02:37:47 <aristid> Baughn: the implementation of ST might be cheating, but the semantics could be emulated (slowly) in pure code :)
02:38:05 <Baughn> aristid: Eheh. Sure, asymptotically slower.
02:38:22 <Taejo> only by an O(log n) factor
02:38:37 <Twey> Pure semnantics, impure implementation… like most of the rest of Haskell :þ
02:38:45 <Twey> semantics**
02:38:47 <Baughn> @where okasaki
02:38:48 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
02:38:52 <aristid> Twey: that's the great thing about haskell
02:38:56 <Baughn> aristid: ^-- You want to have a look at that one
02:39:06 <Baughn> aristid: It goes into great length on /how/ laziness helps. :)
02:39:14 <aristid> Baughn: thanks :)
02:39:34 <Baughn> aristid: Oh, and IIRC Data.Map is based on his work
02:39:58 <Baughn> ..but so is almost /every/ modern Haskell data structure, so yeah
02:41:59 <Baughn> aristid: Exploiting lazy evaluation is old hat. It gets /really/ interesting once you realize that unsafePerformIO thunks are also executed deterministically, at the exact time lazy mutation would be...
02:42:15 <Baughn> (But, um, don't quote me on that. I'd get lynched.)
02:42:17 <quicksilver> Data.Map is a fairly boring size-balanced tree implementation, it's not based on okasaki
02:42:37 <aristid> Baughn: if i'd like to use unsafePerformIO, i'd use ocaml ;)
02:42:51 <quicksilver> indeed, apparently, competing AVL-based versions are faster
02:43:46 <Baughn> Huh. Hm, what was the name of that phackage with all of Okasaki's structures in it?
02:44:31 <roconnor> <Baughn> aristid: Oh yes. There are theorems that declare many data structures that are O(1) in an imperative to be impossible below O(lg n) in a purely functional language.
02:44:46 <roconnor> I'm not aware afe any result for lazy pure functional languages.
02:44:52 <roconnor> *of
02:45:01 <Baughn> They don't /hold/ for lazy pure functional languages, which was rather the point.
02:45:58 <noteed> Baughn: edison?
02:46:05 * roconnor is confused
02:46:30 <Cale> I would really love to see a proof that any complexity bound which held for an imperative language would be the same for a lazy functional one
02:47:05 <Baughn> I'm relatively sure I could write a proof that there can't be such a proof
02:47:10 <roconnor> Cale: I haven't seen such an result either
02:47:19 <Baughn> ..or rather, that it's always possible to get the same complexity
02:47:30 <Baughn> noteed: Edison, thanks.
02:47:42 <roconnor> Baughn: that would be a publishable result AFAIK.
02:47:44 <Baughn> roconnor: I was pointing out to aristid why lazy mutation is a very good thing.
02:48:09 <Baughn> roconnor: Ah.. but I'd be doing it by abusing unsafePerformIO, as is my first resort, so probably not publishable.
02:48:28 <roconnor> :)
02:48:48 <quicksilver> well, that would be a theorem that data structures which are possible in O(1) in an imperative language are possibly in O(1) in an impure functional language
02:48:53 <quicksilver> that woudlnt' surprise anyone :)
02:48:55 <aristid> Cale: wouldn't that be relatively trivial with the ST monad?
02:48:57 <roconnor> I don't think using unsafePerformIO is what Cale meant
02:49:28 <Baughn> aristid: ST monad = restricted unsafePerformIO. I told you that already. :)
02:50:01 <aristid> Baughn: ST monad = purely functional semantics :)
02:50:16 <Baughn> Only from the outside. :P
02:50:53 <aristid> Baughn: just like lazy evaluation is only pure from the outside and uses mutation inside?
02:51:12 <nus> err
02:51:24 <orwhal> .
02:51:24 <Cale> The ST monad is imperative programming.
02:51:33 <Cale> (essentially)
02:51:42 <Baughn> aristid: Oh hush you.
02:52:08 <Baughn> aristid: Lazy evaluation doesn't involve the /programmer/ writing impure code, unlike the ST monad
02:52:19 <roconnor> Baughn: setting a value in an array using ST is still O(N) because of all the freezing and thawing needed.
02:52:34 <roconnor> er
02:52:35 <Cale> But it's not as obvious that the restricted kind of mutation you get from lazy evaluation is enough to get you the same complexity bounds as allowing unrestricted mutation.
02:52:40 <roconnor> that was for aristid
02:52:47 <Baughn> roconnor: Don't remind me. ;_;
02:53:06 <Baughn> roconnor: But it's O(n) with a small constant factor in GHC 12.3, isn't it?
02:53:17 <Baughn> Card-marking and all that
02:53:18 <roconnor> I have no idea
02:53:31 <quicksilver> roconnor: sure, but a complex algorithm which involves many array settings but can be run all in one ST action isn't O(N*number of sets)
02:53:58 <quicksilver> for algorithms which were already at least O(N) in the first place, the freeze-thaw is asymptotically irrelevant
02:54:01 <roconnor> quicksilver: ya but we want a the same complexity for *all* programs, not *many* programs
02:54:06 * quicksilver nods
02:54:58 <roconnor> ya, but ST shouldn't be allowed anyways, thought I can't pin down why exactly
02:55:10 <Baughn> Anyway, pretty sure the card-marking cuts the freeze/thaw time to something like 1/256 (if not less) than it is in 12.1
02:55:33 <Baughn> No asymptotic difference, but quite useful in practice
02:55:59 <aristid> Baughn: both the IO monad (when used from main, not unsafePerformIO) and the ST monad (when used from anywhere) are formally pure :)
02:57:52 <quicksilver> roconnor: well the point is that IO and ST are both primitives the compiler has to supply.
02:58:05 <quicksilver> roconnor: they don't follow from any reasonable notion of typed lambda calculus.
02:58:12 <quicksilver> roconnor: that's why they should be excluded.
02:58:39 <quicksilver> any complexity comparison where you permit the compiler to provide new primitives just means you can say "oh, and the compiler has a primitive to do this in O(1)"...
03:00:27 <aristid> quicksilver: i'm not a mathematician, i just want to use the best tools for the job. and if the ST monad helps me achieve my goals and there is no satisfactory alternative in pure style, i'll use it. no need to ban useful tools.
03:00:29 <Saizan> quicksilver: yeah, but you need an argument to justify why restricting oneself to lambda calculus and not something else is reasonable/relevant
03:00:52 <quicksilver> aristid: I'm not suggesting they should be banned!
03:01:13 <quicksilver> aristid: I'm explaining why they aren't relevant to a discussion of complexity analysis of "purely functional programming languages"
03:01:17 <quicksilver> Saizan: of course.
03:02:09 <quicksilver> Saizan: in this case, for no better reason than I think that's what the question means when it asks for 'purely functional programming languages'. I might be wrong. I think that's how the term would be generally understood though.
03:02:24 <quicksilver> (in the precise context of comparing complexity with imperative languages)
03:03:46 <Cale> Of course, we're already ignoring plenty of log factors at the hardware level, and it usually doesn't hurt to ignore another.
03:04:33 <rl> quicksilver: linear/uniqueness types are quite reasonable
03:05:06 <Cale> But it would be really nice to have some sort of technique for taking lazy evaluation and getting everything you need with respect to complexity from it.
03:05:19 <aristid> Cale: you mean for example the complexity of a single integer division?
03:05:32 <Cale> aristid: Or a memory lookup
03:05:38 <Saizan> quicksilver: yeah, it makes the question more interesting at least :)
03:06:16 <Cale> aristid: It's certainly not O(1) to index memory as the size of the memory grows without bound :)
03:07:16 <Cale> aristid: In fact, for physical reasons, it's worse than O(log n), but ignoring those, you need to examine all the bits of the address to look something up.
03:07:45 <aristid> Cale: division is easier to analyze :)
03:08:50 <aristid> Cale: is an assumption of infinite memory reasonable anyways? i mean, memory is in practice always finite, no?
03:08:55 <Cale> If we assume that there is an upper bound on the amount of information you can put into a given volume of space, and that information can't travel faster than light, then memory lookup is at best O(n^(1/3))
03:09:21 <Cale> I'm just assuming that we can make more and more memory as the problems get larger, so we always have enough.
03:09:45 <aristid> the universe is probably only of finite size so there must be some limit i think :)
03:09:52 <ketil> aristid, in practice every program terminates, too.
03:10:02 <Cale> If you assume that memory is bounded, then asymptotic analysis goes out the window completely.
03:10:09 <Cale> Everything is constant time.
03:10:58 <ketil> However, we need to simplify in order to make elegant theory.
03:10:58 <aristid> Cale: so it's a useful lie :D
03:11:15 * ketil apologies for barging in into the middle of an ongoing conversation.
03:11:20 <quicksilver> rl: ST is quite reasonable.
03:11:28 <ketil> (and for misspelling)
03:11:30 <Cale> The O(n^(1/3)) thing does actually make sense for fairly large memories.
03:11:32 <quicksilver> rl: it's just a question of what you're trying to discuss.
03:11:51 <Cale> Though in fact, some physicists think it may be O(n^(1/2))
03:12:33 <ketil> Hm.  I'm trying to persuade my IT department to get one of those new SGIs, the only machine still providing distributed global shared memory (NUMA)
03:12:48 <FliPPeh> numa numa yay...
03:12:50 <FliPPeh> scnr.
03:12:55 <ketil> scnr?
03:13:01 <FliPPeh> sorry, count not resist.
03:13:03 <aristid> ketil: why?
03:13:04 <FliPPeh> could*
03:13:13 <rl> quicksilver: well, you're discussing the lambda calculus and linear types are quite a reasonable thing to have there and ST can be implemented in terms of those
03:13:22 <ketil> aristid, because I don't want to bother with MPI.
03:13:31 <kulin> is there a ghc option so that exceptions will include some sort of stack trace in their description?
03:14:13 <ketil> I was just watching SPJs talk in Boston on NDP, and he says something about how nice it would be to get parallelism (or performance in general) with low programmer effort.
03:14:30 <aristid> ketil: if you might need more power in the future, you might need multiple machines and then you can't do this anymore :)
03:14:39 <ketil> kulin, don't think so.  Stack traces aren't so easy.
03:14:45 <Cale> kulin: You can try compiling with -prof -auto-all and then running your program with +RTS -xc
03:15:11 <Cale> kulin: Often it's not as useful as you'd hope, but if you're totally at a loss, there's a chance it may help
03:15:25 <ketil> aristid, the point is, I have medium power jobs.  I can do them in a couple of days.  It'd be nice if I could do them in a couple of hours instead, but I'm not going to spend a week rewriting them to achieve this.
03:15:50 <kulin> ok thanks cale
03:15:53 <Cale> kulin: One problem is that GHC doesn't use a stack in the same way that strict language implementations do.
03:16:34 <ketil> Cale, kulin: I've used this option occasionally, and it has always been a lot less useful than I'd have thought.  Unfortunately.  But do try it.
03:16:34 <Cale> kulin: There is a stack (which you will hear about if you get a stack overflow), but it effectively holds on to case expressions which are waiting for their scrutinee to be reduced enough to pattern match.
03:17:07 <Cale> (well, a lower-level analogue to that)
03:17:24 <kulin> ya, i was just thinking there might be some compile option that would put extra info into the exceptions is all, like the calling functions or something
03:17:27 <kulin> not a full stack trace
03:19:29 <Cale> kulin: But for this reason, we're usually really careful with any pure function that possibly throws an exception. Never use head or tail unless you are absolutely sure the list is nonempty, for instance :)
03:19:57 <Cale> (because it can be really irritating to track it down if you're wrong)
03:20:16 <Cale> Another option is the GHCi debugger. I haven't really tried it so much
03:20:34 <kulin> but... i want to use exceptions as a second return type.... jk :)
03:21:14 <kulin> I think i know what the cause is, i just need to figure out why the `catch` isnt catching
03:22:29 <Cale> Ah, if you try to catch an exception thrown from pure code, it can be quite tricky
03:23:12 <Cale> You have to ensure that the call to error is evaluated inside the catch -- otherwise, you could just end up returning it without the exception happening, and something later on will evaluate it, but too late for the catch to do anything.
03:23:27 <Cale> Control.Exception.evaluate can help in this regard
03:23:52 <Cale> If it's just a normal exception thrown from IO, it's less tricky :)
03:24:09 <aristid> am i blind or is Either no monad?
03:24:44 <bremner> too many type parameters for a start
03:25:03 <kulin> its a normal exception from IO, just something must have changed so my catch block is no longer catching correctly, probably a paren somewhere
03:25:03 <FliPPeh> Either is no monad
03:25:05 <Cale> Either e is a monad for any e
03:25:06 <Peaker> aristid, "Either" is not a monad, but "Either a" can be, if you ignore the silly "fail" method
03:25:21 <aristid> i don't see an instance for Either a either
03:25:30 <bremner> Either String a ?
03:25:36 <Cale> import Control.Monad.Error from the mtl and you get an instance for some e
03:25:40 <bremner> fail s = Left s
03:25:48 <aristid> Cale: ah thanks
03:25:49 <Peaker> Cale, that sucks
03:25:58 <Peaker> I uploaded the eithert package
03:26:06 <Cale> Peaker: I agree.
03:26:21 <Peaker> Apparently, it's also in the category-extras package
03:26:29 <Peaker> http://hackage.haskell.org/package/EitherT
03:26:37 <aristid> Cale: i was wondering if Either a would not make for convenient error handling when used monadically
03:26:56 <Cale> aristid: It would
03:27:07 <Peaker> aristid, It does, and not only error handling, also breaking out of loops and more
03:27:08 <Cale> aristid: Except for some reason the Prelude is missing the relevant instance
03:27:23 <Peaker> Because of the "fail" method.
03:27:26 <Peaker> probably
03:27:28 <Cale> and the mtl has a silly restrictive one
03:27:37 <Cale> yeah, fail is so stupid
03:27:44 <Cale> We should get rid of it already
03:27:46 <aristid> Peaker: hmm? the Maybe instances has fail too
03:27:55 <Peaker> aristid, Making a Nothing is easy
03:28:02 <Peaker> aristid, Making a "Left" requires making an "l"
03:28:05 <Cale> At least kick it out into its own class
03:28:07 <aristid> oh right there is no default value for Left
03:29:58 <aristid> Cale: do you think this will ever happen?
03:30:25 <Cale> aristid: I'm still hoping that at some point there will be a revolution and we'll re-do the Prelude.
03:31:19 <Cale> Particularly once we get constraint families, I think it would be a good idea.
03:31:35 <aristid> Cale: maybe it would be less painful if it would be possible to do class NewMonad and instance Monad a => NewMonad a
03:31:53 <aristid> so all Monads would automatically be NewMonads
03:31:57 <quicksilver> that's an attractive idea but it breaks polymorphism and separate compilation.
03:32:14 <quicksilver> (unless you really mean that is the only way to be a NewMonad, in which case that's probably OK)
03:32:41 <quicksilver> (and it works right now, if that is what you mean)
03:32:49 <Cale> It's also just really ugly. Break the world and recompile things a bit.
03:32:50 <aristid> quicksilver: i'm not sure if separate compilation is a good idea anyways :)
03:32:56 <Cale> and you end up with a better world :)
03:33:02 <aristid> Cale: break the world won't happen.
03:33:10 <Cale> Well, I still hope it will.
03:33:20 <Cale> We shouldn't be so afraid of breaking things.
03:33:31 <quicksilver> aristid: some aspects of compilation are inevitably O(n^2) or higher.
03:33:41 <Cale> The old versions of GHC all the way back still exist.
03:33:44 <quicksilver> aristid: separate compilation is essential unless you can fix all those problem.
03:33:57 <quicksilver> and there are quite a few.
03:34:09 <Cale> People who don't want to update their code don't have to upgrade :)
03:34:27 <Cale> Also, we could have multiple versions of the base package
03:34:28 <aristid> Cale: you won't be able to use most modules is the problem
03:34:31 <arw> well, linking old stuff to new stuff would still be nice...
03:34:55 <aristid> quicksilver: i totally want instance X a => Y a
03:35:46 <Cale> aristid: You want instances which overlap with everything?
03:35:57 <quicksilver> aristid: well as I said, you can have it, if you mean that the ONLY way to be a Y is to be an X. That works.
03:35:58 <aristid> Cale: yes
03:36:06 <quicksilver> aristid: if you don't want that, you break polymorphism.
03:36:07 <aristid> quicksilver: no that's not what i want :)
03:36:10 <quicksilver> price too high to pay.
03:36:54 <quicksilver> if we lose separate compilation you have to compile all of base + containers + verything else you use, every time
03:37:10 <quicksilver> that makes compiling a 2 line program take about 30 minutes or so on a really fast machine, IIRC.
03:37:40 <aristid> quicksilver: the compiler doesn't have to be THAT stupid :)
03:40:47 <aristid> but i guess if you say it's not realistic...
03:41:32 <aristid> Cale: maybe breaking the world would be possible if there was a compatibility mode?
03:42:07 <aristid> clearly the Monad situation is a problem :)
03:42:31 <Twey> I never liked this world anyway
03:42:32 <Cale> aristid: We actually already have done stuff like this. base-4 is not quite compatible with base-3
03:42:47 <quicksilver> aristid: I'm just engaging in hyperbole to try to force you to engage with the problem :)
03:43:06 <quicksilver> overlapping instances are a problem because each module generates constraints based on the information visible in that module
03:43:30 <quicksilver> the clever thing about the existing system is that, because of the way instances work
03:43:39 <quicksilver> "new" instances appearing that that module didn't know about will not cause problem
03:43:56 <quicksilver> this is a kind of monotonicity property which makes type classes as they are scale
03:44:00 <aristid> quicksilver: i don't understand haskell well enough yet to deeply engage with the problem :)
03:44:10 <quicksilver> if you allow overlapping instancesm that becomes untrue
03:44:13 <kulin> oh Cale, i think i was using catch from prelude :)
03:44:15 <kulin> so that is why
03:45:03 <aristid> quicksilver: the problem is, it forces programmers to write boilerplate code at times. and i really hate boilerplate :)
03:45:19 <aristid> quicksilver: but i don't know how to solve it
03:45:23 <Cale> kulin: Oh, yeah, that's another problem
03:45:33 <aristid> Cale: when did base-4 come out?
03:46:00 <Cale> aristid: 6.10 or so?
03:46:15 <Cale> I forget
03:46:22 <aristid> Cale: and most modules have been ported to base-4?
03:46:37 <aristid> i guess some industrial users still use 6.8 for that reason
03:47:24 <Cale> aristid: yeah
03:47:52 <Cale> GHC still comes with base-3 as well
03:48:13 <fasta> I would be surprised by anyone advanced using 6.8 myself.
03:48:17 <aristid> Cale: why wasn't fail dropped in base-4?
03:48:26 <Cale> aristid: Nothing in the Prelude changed
03:49:12 <aristid> Cale: hmm how about this: ghc 6.14 could warn about every use of fail, and 6.16 could drop it by default (but with an option to enable it)
03:49:14 <Cale> I guess you have people who think that the standard should change first, but I think that's a ridiculous point of view. How can you know that it's the right thing to standardise if you haven't actually tried the changes?
03:49:43 <Cale> fail isn't the only thing people want to change
03:49:48 <kulin> just need to make a Postlude
03:49:54 <Twey> Haha
03:49:55 <aristid> but it's obviously the most important! :)
03:49:59 <Cale> There's at least a few dozen modifications which most people agree would improve the prelude.
03:50:08 <fasta> I think the only thing which should be in the standard is the abstract machine on which everything else can be build.
03:50:36 <Twey> Um.  Standardisation is for interface, not implementation.
03:50:41 <Cale> fasta: I could get behind that point of view, though there are lots of primitives...
03:50:48 <aristid> Cale: Monads are the bread and butter of haskell, and preventing legitimate Monads from being Monads is a big minus :)
03:51:04 <fasta> Twey, the abstract machine _is_ the interface.
03:51:17 <quicksilver> aristid: except it's not really a problem, because a spurious instance of fail takes a single line to right and doesn't do any harm.
03:51:28 <Cale> Perhaps what we should have in the standard is a Preprelude consisting of a bunch of really primitive stuff, and then the user Prelude would be a normal module built on top of that.
03:51:33 <quicksilver> in fact, you can simply omit fail entirely if you don't mind a compile-time warning.
03:51:45 <aristid> quicksilver: ah, you mean using fail = undefined?
03:51:50 <aristid> that's a clever trick :)
03:51:54 <Twey> fasta: ‘On which everything else can be built’ means that you intend people to build the real language on top of it… so this standardised interface will merely be an implementation detail, and everything that's likely to be used will be unstandardised.
03:52:02 <Twey> Like Scheme.
03:52:14 <quicksilver> fail = error "In my well-researched opinion, this method is inappropriate for this class. Put that in your pipe and smoke it, language experts!"
03:52:22 <Twey> Hahaha.
03:52:27 <fasta> Twey, right. Scheme sees not a lot of shared code, because there is no Hackage that is marketed well.
03:52:54 <aristid> fasta: also there are incompatible implementations of scheme, and all real lispers use common lisp :P
03:53:13 <Cale> I like scheme a whole lot more than common lisp
03:53:20 <Cale> It's too hard to write functional programs in CL.
03:53:21 <fasta> aristid, there are incompatible implementations, because there is no abstract machine that does everything people want it to do.
03:53:33 <fasta> aristid, Common Lisp is such an abstract machine for a lot of things.
03:53:42 <aristid> Cale: sure, scheme is more elegant, but you know what? just don't use lisp at all :)
03:54:22 <Cale> heh
03:54:47 <Cale> Well, that's pretty much where I am now.
03:55:20 <aristid> lisp isn't even statically typed :)
03:55:30 <Cale> I can't really stand to program in an untyped language anymore.
03:55:38 <bremner> there are statically typed schemes
03:55:54 <bremner> dunno much more than that.
03:55:58 <Cale> There's liskell :)
03:56:52 <bremner> http://www.ccs.neu.edu/home/samth/typed-scheme/
03:58:43 <aristid> bremner: i wonder if it's possible to write macros in that scheme
03:58:50 <bremner> no idea
03:59:03 <bremner> but, see e.g. template haskell
04:02:01 <Cale> I seem to recall being fairly unimpressed with that, but I can't remember clearly why. I think that the type inference was weak or nonexistent to the point that you had to annotate way more than just top-level stuff.
04:06:02 <StarFire> If fail is removed, what should happen when a pattern match fails in a do block or a list comprehension?
04:06:14 <StarFire> I'm not advocating fail, I'm just curious.
04:06:32 <Cale> Actually I just want it out of the Monad class, not necessarily removed entirely
04:07:06 <StarFire> So in order to have non-exhaustive patterns inside a do block, you'd have to be an instance of MonadFail?
04:07:09 <whald> is there a book like Joshua Bloch's "Effective Java" for Haskell? that kind of book that you always wish you'd better have read much earlier?
04:07:24 <Cale> So you'd have a separate class MonadFail which had fail in it, and do-blocks which matched against failable patterns (pattern matches against a constructor of a type with at least 2 constructors) would induce a MonadFail constraint
04:07:27 <Twey> Umm, RWH?
04:07:31 <mreh> shall we make all operations assumed to be fail, and have a class of operations called win that we know don't fail
04:07:35 <Cale> yeah
04:07:52 <Cale> This is roughly what Haskell 1.4 had, only they just used MonadZero for that
04:07:57 <Cale> I want MonadZero back as well
04:08:07 <aristid> Cale: why was it removed?
04:08:10 <Cale> Haskell 1.4 was so much cooler than Haskell 98 in a lot of ways
04:08:22 <Cale> aristid: not any particularly good reason
04:08:30 <StarFire> I guess that would be nicer than the current situation.
04:08:42 <Cale> There was an avalanche of failure which happened when they removed monad comprehensions
04:08:43 <mreh> whald: I'm told the "Haskell Road to logic something and something" by someone is quite good, I was going to buy it myself but it's only print on demand
04:09:08 <mreh> @google haskell road
04:09:09 <lambdabot> http://homepages.cwi.nl/~jve/HR/
04:09:09 <lambdabot> Title: The Haskell Road
04:09:45 <aristid> mreh: is print on demand bad?
04:10:00 <aristid> Cale: monad comprehensions? what's that?
04:10:03 <Cale> They removed monad comprehensions and then someone said "Hey, the only reason we needed MonadZero was for guards in monad comprehensions! (which was false) All the current instances of MonadZero are also instances of MonadPlus anyway, let's merge them."
04:10:04 <whald> mreh: ah, there's a free sample chapter, i'll have a look. thanks.
04:10:05 <StarFire> Why were monad comprehensions removed, and what were they good for?
04:10:11 <mreh> aristid: not really, it has a cheap generic cover, it reads well enough
04:10:45 <Cale> aristid: list comprehension syntax but for monads other than the list monad
04:11:01 <kmc> what else was cooler in Haskell 1.4?
04:11:11 <Cale> and so they merged MonadZero into MonadPlus and promptly noticed that failable patterns would induce a MonadPlus constraint and not just MonadZero
04:11:16 <aristid> Cale: i don't really like list comprehension syntax, it's too tempting to make too long lines with that
04:11:34 <Cale> aristid: So break the line
04:11:50 <kmc> anything multi-line should probably use "do", imo
04:12:04 <aristid> it's the same thing anyways
04:12:05 <chat89849> heey
04:12:09 <Cale> There are cases where monad comprehension syntax would be nice anyway
04:12:20 <Cale> particularly where you have lots of guards
04:12:23 <chat89849> sombary hier
04:12:23 <kmc> when reading a list comprehension you have to read the generators / conditions one by one, then snap back to the beginning for the equivalent of the last statement
04:12:49 <Cale> I read them from left to right
04:13:25 <Cale> list comprehensions induce a slightly different type of thinking from do-blocks
04:13:28 <Cale> Similar to let and where
04:15:01 <aristid> Cale: i've seen too many hard-to-read list comprehensions (in python) to be enthusiastic about them
04:15:36 <carbonix> hello, may I ask a bit for some help?
04:15:44 <carbonix> (some easy haskell code)
04:15:45 <ivanm> carbonix: no harm in asking
04:15:50 <ivanm> whether we answer or not... ;-)
04:15:51 <Cale> carbonix: Yes, but you may not ask to ask for help ;)
04:16:04 <Cale> (but it seems you already have :)
04:16:13 <Saizan> aristid: python ones are too verbose :P
04:16:16 <carbonix> ok :)
04:16:23 <carbonix> so, I have a graph defined like this : g2 = Graph [0, 2, 4, 6] [(0, 7), (0, 6), (7, 4), (7, 2)]
04:16:34 <aristid> Saizan: heh, yeah
04:16:40 <carbonix> and I'm willing to get the neighbors of a node, with a function
04:16:44 <carbonix> like this neighbors (Graph v e) (node) = [ w | (node, w) <- e ]
04:16:54 <quicksilver> carbonix: strange, your edges mention a node 7 but you graph doesn't seem to have a node 7 ;)
04:17:11 <ivanm> carbonix: any particular reason for not using fgl graphs?
04:17:30 <ivanm> (they will stop this problem I believe...)
04:17:46 <carbonix> ivanm: it's a homework, so we have to do it from scratch
04:17:49 <Cale> ivanm: what problem?
04:17:52 <Saizan> carbonix: the node in "(node, w) <- e" is a newly bound variable that shadows the node bound as parameter to the function
04:18:24 <ivanm> Cale: referencing nodes that aren't in the graph
04:18:36 <ivanm> carbonix: fair enough
04:18:41 <Saizan> carbonix: you've to write "neighbors (Graph v e) node = [ w | (node', w) <- e, node == node' ]"
04:18:50 <ivanm> carbonix: remember, Data.Graph uses an array, so the bounds of your array have to match the nodes you have
04:19:03 <Cale> ivanm: He's not using Data.Graph either
04:19:21 <aristid> Saizan: gotta admit that's a nice use of list comprehensions
04:19:25 <ivanm> Cale: oh, whoops; looked like he was :s
04:19:39 <carbonix> thanks, I think I got it, so basically there was no connection between param in the function, further passed to the set..
04:20:01 <ivanm> eh, that's just map snd . filter ((==) node . fst) $ e
04:20:02 <ivanm> ;-)
04:20:13 <Cale> carbonix: If you do a pattern match, the variables which occur in the pattern are always fresh variables which will shadow any definitions in a surrounding scope
04:20:27 <aristid> ivanm: which is less readable, unfortunately :)
04:20:28 <carbonix> ok, thank you Cale
04:20:43 <ivanm> aristid: that's what _you_think!
04:20:52 <aristid> ivanm: i wonder how to do it with arrows
04:21:06 <ivanm> eh, no idea ;-)
04:21:22 <aristid> @src (&&&)
04:21:23 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
04:21:30 <aristid> @src (>>>)
04:21:30 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:21:46 <Saizan> have you?
04:21:47 <aristid> oh right >>> was in the class or something
04:22:00 <Saizan> &&& is in the class too, but it has a default
04:22:26 <aristid> there's no >>> in the class shown by ghci oO
04:22:37 <ivanm> @hoogle (>>>)
04:22:37 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
04:22:37 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
04:22:51 <ivanm> aristid: @src has a list of pre-defined source definitions
04:23:09 <ivanm> it doesn't scan the documents in question
04:23:29 <aristid> is (>>>) = arr?
04:23:32 <Saizan> aristid: got moved to Control.Category.Category, and i think the method is (.) and (>>>) is an alias for flip (.) now
04:23:37 <Saizan> aristid: no
04:24:03 <aristid> @src (.)
04:24:03 <lambdabot> (f . g) x = f (g x)
04:24:12 <Saizan> not the same (.)
04:24:25 <Saizan> unless we are in the (->) Category :)
04:26:43 <quicksilver> Control.Category..
04:26:50 <quicksilver> I just had to say that because it looks so stupid
04:27:09 <quicksilver> qualified operator syntax really doesn't look good on an operator called '.'
04:28:28 <ketil> That's what you get for copying syntax based on the popularity of other languages.  This is no way to avoid success!
04:29:47 <quicksilver> z-encoding ftw!
04:29:53 <quicksilver> Controlz46Categoryz46.
04:30:00 <Entroacceptor> you could use Tab as a separator ;)
04:30:11 <Entroacceptor> or that =)
04:30:42 <quicksilver> Entroacceptor: no, vertical tab!
04:30:49 <quicksilver> obscure whitespace characters are great.
04:30:52 <Entroacceptor> aah, even better!
04:31:23 <Entroacceptor> that reminds me of my time in school...
04:31:29 <quicksilver> I'd really like my editor to show qualification prefixes suffix, and subscript. (and smaller font)
04:31:34 <Entroacceptor> the administrator hid some fils with ASCII char 255
04:34:57 <ivanm> hey Axman6
04:35:04 <Axman6> 'lo
04:35:15 <ivanm> how are you and sarah planning to travel to/from sydney?
04:35:21 <Axman6> not sure yet
04:35:23 * ivanm should probably start booking hostels, etc.
04:35:27 <Axman6> aye
04:35:42 <ivanm> see, if we were all going on the one day, I think taking my car might be an option
04:35:46 <Axman6> we should sent out an email actually, telling everyone to start planning
04:35:53 <ivanm> but since you're going earlier, it's probably not cost effective for me to drive on my own
04:36:02 <ivanm> Axman6: yeah, kamatsu asked for such an email before
04:36:04 <Axman6> well, there's a few canberrans going, so talk to them about it
04:36:23 <ivanm> the only other canberran I know of that's going is fallen_demon, and he's not going till saturday
04:36:38 <sosman> Sounds like half you guys are from around these parts?
04:36:53 <Axman6> where are these parts sosman?
04:36:55 <ivanm> "these parts" == "down under"?
04:37:01 <sosman> yeah
04:37:06 <ivanm> Axman6: his hostname says victoria
04:37:14 <Axman6> are you coming to AusHac2010?
04:37:19 <Axman6> the first aussie haskell hackathon
04:37:22 <Axman6> ?
04:37:37 <ivanm> well, there's the two of us, dibblego when he's around, Pseudonym, blackdog, juhp, TacticalGrace
04:37:40 <ivanm> who have I missed?
04:37:41 <sosman> Heh - give me a few more days and I might write my first Haskell application :-)
04:37:50 <ivanm> sosman: http://www.haskell.org/haskellwiki/AusHac2010
04:37:50 <sosman> And its a  hack!
04:37:59 <Axman6> well, its in two months, so you've got plenty of time to write ;)
04:38:03 <ivanm> Axman6: any new sign ups since you emailed me the list?
04:38:17 <sosman> 2 days to write - 2 months to get it to compile.
04:38:28 <Axman6> ivanm: i don't think so. i should add you to the email list (something i only figured out you could do the other day)
04:38:34 <Axman6> otherday = yesterday
04:38:53 <ivanm> oh, for the registration form?
04:39:14 <ivanm> Axman6: any idea which part of Sydney randwick counts as for accom searching sites?
04:39:15 <Axman6> yeah
04:39:20 <Axman6> no idea
04:39:32 <Axman6> ask a sydney sider like manuel
04:40:01 <ivanm> blackdog: you around?
04:42:35 <Axman6> ivanm: can you pm me your email?
04:42:47 <ivanm> done
04:42:58 <ivanm> ooohhhh, $75/night at St Marks Lodge
04:43:38 <ivanm> preflex: seen juhp
04:43:38 <preflex>  juhp was last seen on #haskell 21 hours, 59 minutes and 12 seconds ago, saying: heh
04:49:23 <sosman> So I have seen a few job ads recently in Melbourne that mention Haskell.
04:49:42 <QtPlatypus> sosman: Cool
04:51:20 <roconnor> sosman: really?
04:51:34 <sosman> Yeah - not the primary skill.  Comes up in my python filter
04:51:38 <sosman> on seek
04:51:48 <roconnor> as in, Haskell developers wanted, or work that involves Haskell (surpisingly these are not the same)?
04:52:21 <sosman> roconnor: didn't really follow up, I just keep an eye on the python market.
04:52:30 * roconnor nods
04:52:45 <sosman> But a company that uses Haskell gotta be somewhat interesting I figure
04:53:05 <ivanm> roconnor: where the former is because haskell developers are considered to be smarter?
04:53:12 <roconnor> I hear people just use Haskell for controlling lawnmowers :P
04:53:18 <roconnor> ivanm: yes
04:53:27 <ivanm> who uses haskell for lawnmowers?
04:53:38 <ivanm> our victa lawnmowers don't need no computers!
04:54:00 <roconnor> I'm probably misremembering, but I thought someone here worked for a company using Haskell to make lawnmowers.
04:54:06 <dv-> I thought we were avoiding success :|
04:55:03 <ivanm> roconnor: oh, right, yeah, to _make_ lawnmowers
04:55:06 <ivanm> that sounds about right
04:55:23 <aristid> roconnor: do you disrespect lawnmowers?
04:56:00 <sosman> Only those with single sided crank
04:56:44 <roconnor> aristid: no, but other people might; I'm relying on that.
04:56:55 <roconnor> ;P
04:58:54 <Traveler0> hi all, can anyone help me out with this bit of code please? Im trying to get the average rating but it doesnt seem to work properly
04:59:02 <Traveler0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25426#a25426
05:01:23 <roconnor> Traveler0: you are dividing by the length of all the ratings, not just of the ratings of the director in questions
05:01:35 <roconnor> Traveler0: instead you should 1. filter the list
05:01:40 <roconnor> 2. sum the ratings
05:01:48 <roconnor> 3. divide by the lenght of the *filtered* list
05:02:31 <Traveler0> i see..alright ill have a go at it. thanks for that
05:02:45 <roconnor> ... we really ought to a nicer average function in the standard library that does all the fancy knot tying.
05:05:04 <Traveler0> doesnt it excist in the library? or does it?
05:05:40 <roconnor> I'm not aware of one.
05:06:06 <Traveler0> hmm..okay :)
05:06:33 <Twey> > let mean = uncurry (/) . foldr ((*** succ) . (+)) (0, 0) in mean [1 .. 6]
05:06:35 <lambdabot>   3.5
05:06:45 <wli> What kind of knot tying is this average supposed to do? Cesaro summation?
05:06:47 <roconnor> Twey: now use foldl'
05:07:02 <Twey> Why?
05:07:20 <roconnor> wli: knot tying is only used to prevent the double traversal of the list to comput the length and the sum
05:07:36 <roconnor> > let mean = uncurry (/) . foldr ((*** succ) . (+)) (0, 0) in mean [1 .. 10^6]
05:07:38 <lambdabot>   *Exception: stack overflow
05:07:45 <Twey> Oh
05:07:47 <roconnor> > sum [1..10^6]
05:07:49 <lambdabot>   *Exception: stack overflow
05:07:49 <Twey> Ick
05:07:54 <roconnor> ?
05:07:56 <Twey> Yeah
05:07:59 <Twey> :-\
05:08:14 <Twey> foldl' (+) 0 [1 .. 1e6]
05:08:15 <roconnor> > foldl' (+) 0 [1..10^6]
05:08:16 <lambdabot>   500000500000
05:08:23 <wli> I had some kind of code that was supposed to do moving averages using spline interpolation and exponential decay.
05:08:37 <roconnor> Twey: you can't just use foldl' in yours cause pairs are not strict
05:08:49 <Twey> Yeah… needs some seq'ing, I guess
05:08:54 <roconnor> so it is all very complicated :D
05:09:07 <Twey> Weird that sum doesn't use foldl'
05:09:18 <roconnor> Twey: I think it is just that foldl' isn't in H98
05:09:26 <Twey> Ah
05:09:26 <roconnor> and lambdabot isn't doing -O2
05:09:32 <roconnor> or maybe isn't even doing -O
05:09:32 <Twey> *nod*
05:10:49 <roconnor> ((*** succ) . (+)) -- I can't do this in my head :D
05:11:25 <roconnor> ``what part of uncurry (/) . foldr ((*** succ) . (+)) (0, 0) don't you understand?''
05:11:41 <Vitka> ALL OF IT OMG
05:11:44 <Vitka> ...sorry.
05:11:48 <roconnor> :D
05:12:18 <dino-> roconnor: That haddock business from yesterday, fixed in recent versions. I did a squeaky clean cabal install of 2.7.2
05:12:39 <roconnor> good
05:12:41 <Twey> \x -> ((x +) *** succ) ⇒ \x -> (***) (x +) succ ⇒ \x -> flip (***) succ (x +) ⇒ \x -> flip (***) succ . (+) $ x ⇒ flip (***) succ . (+) ⇒ (*** succ) . (+)
05:12:52 <Vitka> Sad thing is, i mostly understand what these functions do on their own... expect maybe arrow one.
05:13:20 <Twey> Vitka: For a function, (f *** g) is just a function that takes a tuple (a, b) and returns (f a, g b)
05:16:03 <fasta> Is there anything interesting which makes use of the Arrow class like other stuff uses the Monad class where it is actually mandatory that you know it is part of the Arrow class and that could not have been written just in a module?
05:16:59 <Vitka> So (*** succ) . (+) adds element to its successor?
05:17:35 <Twey> :t (*** succ) . (+)
05:17:36 <lambdabot> forall c b'. (Enum b', Num c) => c -> (c, b') -> (c, b')
05:17:50 <Twey> (succ for Num is just (+ 1))
05:18:24 <Twey> So it's a function that takes two arguments, a value and a pair, and adds the value to the first of the pair and increments the second
05:18:47 <Vitka> Ahah. So one element of tuple serves as index of sorts, it's incremented bt succ and (+) adds the other?
05:19:20 <Twey> Yyes.  If I understand you correctly.
05:21:11 <Vitka> It's sad I don't get things like monads and arrows yet, and miss good part of Haskell's power.
05:22:54 <Vitka> Feels bad when you try to write something real-worldy and think "it could've probably been so much simpler if I knew how".
05:25:40 <dino-> fasta: the HXT API that uses arrows maybe?
05:25:51 <Peaker> Vitka, Arrows aren't that important :)
05:25:57 <Peaker> Vitka, Monads are pretty important though
05:26:19 <fasta> dino-, I count HXT as a piece of garbage. Other people have potentially different opinions.
05:26:36 * wli is unsure of what HXT is.
05:26:43 <dino-> wli: X
05:26:47 <Peaker> Vitka, One good way to understand monads is just to ignore them - write some code, follow some steps to refactor code out -- and behold you got a monad :)
05:26:49 <dino-> wli: XML parsing and creation
05:26:51 <fasta> Vitka, arrows are irrelevant to write interesting programs.
05:27:04 <dino-> Kind of powerful, with validation using RelaxNG, XPath, and more.
05:28:04 <dino-> fasta: Is there something you'd use instead for XML work? haxml perhaps?
05:28:05 <fasta> Vitka, and understanding the abstract is useless without some experience with some concrete instances. All the monads you will ever need have been pretty much predefined or can be created by using monad transformers and again, you don't need monads to write interesting programs.
05:28:18 <fasta> dino-, I like the xml package.
05:28:20 <roconnor> arrows are usfeul when you compose monads and comonads ... not that I've ever done this.
05:28:36 <wli> Some of the flaws may be innate to XML. Anyway, something to handle whatever XML's oddities are from glorified S-expressions is a good idea.
05:28:40 <fasta> dino-, I like it because it has a simple interface.
05:29:27 <fasta> If I would have to write something for "extreme performance" I might use hexpat or something like that.
05:29:34 <aristid> i think the problem with learning monads is that the IO monad is an outlier
05:29:56 * wli = twink btw
05:30:16 <Vitka> Maybe it's not monads themselves - it's abstract datatypes. I can see defining container ADT like List or Tree or something, but anything else and I can't seem to fit it in.
05:30:19 <Peaker> fasta, but monads help
05:30:20 <fasta> dino-, haxml is definitely easier than HXT.
05:30:23 <wli> aristid: I also found that monad transformer stacks were really necessary to learning monads.
05:30:33 <aristid> wli: huh?
05:30:33 <fasta> Peaker, yes, but you can write useful programs without them.
05:31:03 <wli> aristid: A big part of the point of all the monad stuff is being able to combine them with monad transformers.
05:31:27 <aristid> wli: the Maybe monad is very useful in itself
05:31:54 <fasta> The thing with newbies and monads is that they ask "when should I use a monad?". Instead they should just write code and figure out that something could be done in a better way in some cases and that often that is a monad.
05:31:56 <dino-> Hey, wli is back.
05:31:58 <ivanm> @ask blackdog for purposes of finding accom and transport for aushack, what would you call the part of sydney that UNSW is in?
05:31:59 <lambdabot> Consider it noted.
05:32:12 <wli> dino: I've been around using the nick twink
05:33:03 <dino-> Speaking of Maybe, I was thinking of how helpful it was to go through All About Monads.
05:33:14 <dino-> Starts basically with Maybe and the sheep.
05:33:29 <dino-> Pay no attention to the IO to start with
05:34:12 <dino-> Vitka: http://www.haskell.org/all_about_monads/html/index.html
05:35:00 <aristid> dino-: wow, that's comprehensive
05:35:06 <dino-> fasta: I will look at those, xml and haxml. I have a largeish pile of hxt code now in this thing I'm working on. And mostly I get it, but have trouble. Of course with the arrow code.
05:35:15 <confounds> dino-: is that how you learned?
05:35:21 <stroan> I read all the monad tutorials. I only really understood them when I had to start writing my own. Reading the tutorials are important, but understanding comes with application
05:35:51 <wli> aristid: Here's an example of a monad transformer stack http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25429#a25429
05:36:21 <aristid> wli: that's terrible code!
05:36:59 <dino-> confounds: That together with other things. There was a small document Cale wrote, Monads As Containers, that helped quite a bit. And a chapter in YAHT where the book has you write a state monad from scratch, step by step.
05:37:05 <dino-> http://www.haskell.org/haskellwiki/Monads_as_containers
05:37:10 <dino-> http://en.wikibooks.org/w/index.php?title=Haskell/YAHT
05:37:24 <wli> I think YAHT was the one that did it for me.
05:37:40 <wli> aristid: It's a little dense.
05:37:48 <confounds> dino-: nice, good to know. thanks
05:38:16 <aristid> wli: not just a little. there's no elegance in such symbol deserts
05:38:25 <fasta> wli, my eyes.
05:38:59 <dino-> Oh and what did it for me with mtl transformers was this: .. oh no Monad Transformers Step by Step is gone!
05:41:14 <zygoloid> wli: rep = forever. do you really need (lift . lift . tell)? isn't tell itself enough?
05:41:47 <wli> zygoloid: It seemed to need 2 lifts to typecheck.
05:42:07 <dino-> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.596
05:42:07 <wli> zygoloid: yeah, rep is basically forever
05:42:11 <fasta> wli, I don't think you ever need those lifts there.
05:42:16 <dino-> Monad Transformers Step by Step
05:42:26 <fasta> wli, you can derive MonadWriter for example.
05:43:56 <wli> Both lifts are needed to typecheck.
05:44:39 <zygoloid> wli: map order $ liftM2 (,) xs ys == liftM2 (uncurry order) xs ys
05:46:36 <wli> order's uncurried to begin with
05:46:52 <aristid> wli: ($ x) is the same as x, no?
05:47:12 <wli> aristid: no
05:47:34 <sosman> ciao
05:48:19 <zygoloid> wli: sorry, i meant curry order
05:48:36 <wli> I got there eventually.
05:48:47 <aristid> wli: what's the difference between ($ x) and x?
05:48:56 <aristid> @src $
05:48:57 <lambdabot> f $ x = f x
05:48:58 <quicksilver> aristid: x is the value x. ($ x) is the function that applies a function to x.
05:49:05 <ivanm> aristid: you can do this:
05:49:08 <rajeshsr> @src when
05:49:09 <lambdabot> when p s = if p then s else return ()
05:49:13 <ivanm> > map ($2) [(^2), succ]
05:49:13 <lambdabot>   [4,3]
05:49:19 <zygoloid> wli: i think i'd use filter twice rather than the Map trick (i'm worried about LT or GT not appearing as keys in corner cases...)
05:49:21 <quicksilver> > ($3) negate
05:49:22 <lambdabot>   -3
05:49:26 <ivanm> aristid: ^^ if you don't have the $ there, it won't work
05:49:33 <aristid> oh
05:49:36 <ivanm> because map requires a function
05:49:36 <wli> aristid: ($ x) is a function of a function that produces a result from the function by applying it to x
05:49:40 <ivanm> @type ($3)
05:49:41 <lambdabot> forall a b. (Num a) => (a -> b) -> b
05:49:45 <aristid> ($ x) is not the same as $ x, eh?
05:49:52 <quicksilver> indeed not
05:49:52 <aavogt> it could still work given some additional instances
05:50:00 <aristid> quicksilver: that's evil :)
05:50:00 <ivanm> aristid: saying just "$ x" doesn't make sense
05:50:03 <quicksilver> it's secton syntax.
05:50:03 <aavogt> @unpl ($ x)
05:50:03 <lambdabot> (\ a -> a x)
05:50:04 <ivanm> ($x) is a section
05:50:07 <aristid> ivanm: exactly:)
05:50:19 <quicksilver> aristid: it's like (*2) or ("hi"++)
05:50:20 <aristid> my mental parser discarded the ()
05:50:23 <quicksilver> sections are great.
05:50:30 <ivanm> quicksilver: yup
05:50:44 <ivanm> except they don't compose too well when doing function composition
05:50:50 <Peaker> ivanm, why not?
05:50:59 <ivanm> i.e. it'd be nice if you could do something like ( +1 . 2^)
05:51:05 <ivanm> @type ( +1 . 2^ )
05:51:05 <lambdabot> parse error on input `)'
05:51:25 <Peaker> (+1) . (2^) isn't too bad
05:51:31 <aavogt> you want spaces to count even more :)
05:51:42 <Peaker> > (+1) . (2^) $ 5
05:51:43 <lambdabot>   33
05:51:52 <ivanm> yeah, but especially if I'm doing something like "((==foo) . bar)", then there's no real reason for me to use a section there
05:52:02 <ivanm> and I might as well make it ((==) foo . bar)
05:52:09 <wli> zygoloid: There's some error handling lacking in/around degenerate functions that bomb the inequality checks (e.g. identically 0).
05:52:21 <aavogt> you know, points exist for a reason
05:52:32 <ivanm> aavogt: yes, to keep score
05:52:32 <ivanm> :p
05:52:33 <aavogt>  \x -> foo == bar x
05:52:49 <aristid> aavogt: points are not point-free
05:52:53 <ivanm> aavogt: if I have three or more functions chained together as the function in a map?
05:53:09 <aristid> ivanm: then maybe you have too much complexity chained together anyways
05:53:19 <ivanm> *shrug* maybe
05:53:37 <aavogt> I know what you mean
05:54:17 <ivanm> OK, I only have one time I do trhee functions
05:54:18 <aristid> this is how haskell should look like: http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/src/Data-MemoCombinators.html :)
05:54:25 <aristid> *haskell code
05:54:27 <ivanm> ((==) 1 . flip mod 3 . length)
05:54:41 <ivanm> when I'm checking if the length of a list is 3n + 1 for some n
05:54:45 <aavogt> more type signatures than code?
05:55:01 <ivanm> nope
05:55:45 <ivanm> that reminds me.... I need to consider if I should start using a record data structure for the various FGL -> {DotGraph,FGL} functions in graphviz
05:55:50 <dino-> On an arrow-positive note, there is a lot of example code for hxt now on haskellwiki that didn't used to be there.
05:56:09 <aristid> ivanm: maybe (`mod` 3) instead of flip mod 3? :)
05:56:16 <aavogt> please use pretty records if they are nested at all
05:56:50 <ivanm> aristid: except I think I already stated that I don't like having to wrap sections in brackets inside function compositions ;-)
05:56:55 <ivanm> aavogt: huh?
05:57:15 <ivanm> aavogt: I mean to replace all the functions here: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz.html#v%3AgraphToDot
05:57:15 <aavogt> because it's really ugly to write      foo { field = f (field foo) }
05:57:30 <aavogt> oh, instead of those tuples?
05:57:35 <aristid> ivanm: hmm why?
05:57:44 <ivanm> if I use the one record with optional arguments (i.e. use Maybe), then I can combine graphToDot, graphToDot', clusterGraphToDot and clusterGraphToDot' into one
05:57:49 <aavogt> or the attributes list?
05:58:06 <ivanm> aavogt: instead of all the arguments
05:58:21 <ivanm> so if you don't want any edge labels, you currently have to explicitly say (const [])
05:58:41 <ivanm> actually, maybe not combine 4 into 1; that (Ord b) constraint needed to tell if a graph is directed or not might throw things a bit...
06:01:26 <aavogt> oleg has a demo for optional keyword arguments
06:01:55 <ivanm> aavogt: ummm.... I'm not talking about keyword arguments
06:02:03 <ivanm> I'm talking about optional parameters
06:02:14 <ivanm> as in, specifying all those functions
06:02:23 <aavogt> yes, but if they are optional, how do you specify exactly the ones you want?
06:02:50 <Peaker> Funny, Reading the Omega paper, their use of ASCII notation makes DT's seem so much easier than previous stuff I've read which used mathy Latex or what not
06:03:02 <aavogt> surely you're not doing      f :: Maybe a -> Maybe b  -> Maybe  c -> result
06:03:21 <aavogt> then you have to remember which position your value actually goes
06:03:29 <ClaudiusMaximus> records?
06:03:48 <ivanm> aavogt: using a record for all the functions
06:04:05 <aavogt> then you rely on class magic to conveniently pass in the default parameters
06:04:16 <ivanm> as in, use the default function of (const []) for most of them, and the default clustering function would just be N
06:05:02 <ClaudiusMaximus> data Arguments = Args { foo, bar, baz :: ... }, defaults = Args defFoo defBar defBaz, turboFunction (defaults{foo = myFoo}) quux
06:05:39 <ClaudiusMaximus> or something along those lines?
06:05:47 <ivanm> yup
06:06:13 <ClaudiusMaximus> and the class magic would make 'defaults' a class member?
06:06:20 <aavogt> yes
06:06:24 <ivanm> huh? what class magic?
06:06:30 <ivanm> I'm not talking about any class magic...
06:06:35 <aavogt>  class Defaults a where defaults :: a
06:06:45 <ClaudiusMaximus> ok, crossed wires
06:06:48 <ivanm> ummmm..... I'm not talking about that at all
06:06:58 <aavogt> otherwise you must remember which defaults belong to which function
06:07:14 <ivanm> I'm talking about a record containing all the arguments I currently pass in to those functions
06:07:16 <aavogt> so that's two names instead of one
06:07:35 <ivanm> with default boring implementations
06:08:21 <ClaudiusMaximus> sometimes over-engineered magic appears more elegant, but in the end boring code works better (in my experience at least)
06:10:19 <aavogt> or is this separation between function and data really pointless if the correspondence is one to one?
06:12:25 <ivanm> OK, let me start again
06:12:40 <ivanm> I currently have four functions, three of which are abstractions of the fourth
06:12:55 <ivanm> these take various function and constant parameters
06:13:14 <ivanm> in many cases, people are going to use "default" functions such as (const [])
06:14:42 <ivanm> I'm wondering if I should use the optional-parameter trick of replacing all those arguments with one record structure containing all those arguments and give them all default implementations: "(const [])" for the (a -> Attributes) ones, "N" for the (LNode a -> NodeCluster c l) one, etc.
06:14:56 <ivanm> I don't want any kind of type class or anything since that would be pointless
06:15:40 <Saizan> aavogt: what are "pretty records"?
06:15:42 <quicksilver> the user still needs to type "defaultParamSet { foo = bar }" though, right?
06:15:48 <quicksilver> (that was for ivanm)
06:15:48 <ivanm> yes
06:15:54 <aavogt>  so OO style:    data ToDot gr a b = ToDot { graph :: gr a b, attrs :: [ .. ], nodeAttrs :: ..., edgeAttrs :: ..., toDot :: DotGraph Node }
06:15:55 <ivanm> quicksilver: I guessed that
06:16:03 <quicksilver> personally I find that uglier than just having specially named functions
06:16:10 <quicksilver> as long as the funcitons are sensibly named.
06:16:15 <ivanm> quicksilver: "specially named functions"?
06:16:18 <aavogt> Saizan: hlist if necessary, but something like fclabels or data-accessor
06:16:22 <quicksilver> your current situation, ivanm
06:16:34 <quicksilver> four separate functions (distinguished by their names, I presume!)
06:16:41 <ivanm> the other reason for doing this is that that way you don't have to keep passing a bunch of functions around if you're doing more than one visualisation; you can instead pass one record structure around
06:16:55 <ivanm> quicksilver: I'm talking about the first four functions here: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz.html#v%3AgraphToDot
06:16:55 <Peaker> quicksilver, Isn't that a cartesian explosion of functions?
06:16:56 <quicksilver> ah well, a record version can be useful for that reason yes
06:17:12 <quicksilver> Peaker: yes, of course, but in practice a small number of them cover the most common cases
06:17:28 <quicksilver> Peaker: you just give convenience functions for the convenient common cases and then an all-encompassing one for the general case.
06:17:43 <ivanm> the primed versions devolve to the non-primed versions; graphToDot is just clusterGraphToDot with the (LNode a -> NodeCluster c l) function being just "N" and the (c -> [GlobalAttributes]) function is (const [])
06:17:43 <quicksilver> you don't try to do every permutation of omitted args :)
06:17:59 <ivanm> quicksilver: no, I wasn't that silly ;-)
06:18:02 <Peaker> quicksilver, That's a lot of work.. :(  One of the downsides of Haskell my coworkers ask me about when I try to convert them from Python, where you just:  def f(x=1, y=2, z=3): .. and get optional and keyword args for almost free
06:18:28 <quicksilver> I agree it's a downside Peaker but I think it's utterly trivial and dull.
06:18:34 <ivanm> but in a lot of cases people are going to use functions like (const []) for one or more of the (a -> [Attribute]) functions, so I was thinking a record structure with defaults like that might make sense
06:18:35 <aristid> okasaki is a big text, my printer needs forever to print it :D
06:18:45 <quicksilver> if people find that a substantial reason to choose one language over another I have no words left for them :P
06:18:48 <Peaker> quicksilver, Yes, I don't think anyone sees it as a showstopper
06:18:49 <ivanm> aristid: his thesis?
06:18:54 <ivanm> or an illegal copy of his book?
06:19:06 <Peaker> quicksilver, but when I try to "sell" Haskell, it's important to have as little downsides as possible :)
06:19:06 <aavogt> aren't the two mostly the same?
06:19:10 <ivanm> Peaker: you can kinda get that with records...
06:19:18 <ivanm> aavogt: the book has more stuff and costs money
06:19:25 <Peaker> ivanm, Just takes more boilerplate
06:19:34 <quicksilver> Peaker: for APIs which make really heavy usage of that, I prefer the method used by Gtk + Wx + lots of other library
06:19:36 <aristid> ivanm: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
06:19:47 <quicksilver> Peaker: f [ x := 1, y := 2, z := 3 ]
06:19:49 <aavogt> tuition covers that :)
06:20:05 <aristid> aavogt: i don't study CS.
06:20:12 <quicksilver> Peaker: requires a fair amount of setup behind the scenes, but gets you fully typed argument lists.
06:20:16 <aavogt> I don't either
06:20:29 <quicksilver> (and some namespace issues which I don't care about but some people do)
06:20:56 <Peaker> quicksilver, cool.. haven't seen that. how do you define a new function or arg types?
06:21:02 <ouyes> what is this channel for?
06:21:24 <Twey> Unicycling.
06:21:35 <tab> achieving enlightenment
06:21:41 <ddarius> Followed distantly by Haskell.
06:21:42 <hpc> bacon recepies
06:22:11 <byorgey> ouyes: hehe, it is for discussing the programming language Haskell
06:22:21 <quicksilver> Peaker: well, you have something like (x :: Attribute Int), and data Assignment = forall x . Attribute x := x
06:22:38 <quicksilver> Peaker: and to do cleverer things you add a Phantom type into Attribute
06:22:38 <ouyes> byorgey, do we know each other?
06:22:58 <quicksilver> (to indicate, for example, that only certain Attributes are permitted in certain functions)
06:23:12 <byorgey> ouyes: I don't think so.
06:23:19 <Peaker> quicksilver, is it a lot of work, after having the basic infrastructure, to add a new function?
06:23:20 <quicksilver> then f :: [Assignment] -> Whatever
06:23:25 <Peaker> or new attributes?
06:23:38 <quicksilver> a few lines.
06:23:55 <quicksilver> it gets quite fiddly if you have lots of different functions supporting overlapping sets of attributes, I guess.
06:23:59 <quicksilver> I haven't tried to push it that far.
06:24:03 <rajeshsr> :t findIndex
06:24:05 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
06:24:33 <roconnor> quicksilver: do you have to use p
06:24:42 <roconnor> quicksilver: do you have to use [] to call the functions with the default arguments?
06:24:44 <Peaker> quicksilver, I don't see the great value in sharing attributes, except to have shorter names maybe
06:24:54 <ouyes> byorgey, then thank you and i came to the wrong place
06:24:57 <quicksilver> Peaker: http://hackage.haskell.org/packages/archive/wx/0.12.1.4/doc/html/Graphics-UI-WX-Attributes.html
06:25:00 <quicksilver> roconnor: yes
06:25:13 * gwern has a scan of okasaki's book
06:25:13 <quicksilver> roconnor: well, that's my preferred solution. I don't find [] hard to type.
06:25:28 <quicksilver> roconnor: undoubtedly you can do something horrible with overloading to make it shorter in some cases
06:25:35 <gwern> I probably should compare it to the thesis PDF so we can finally tell people how they differ
06:26:13 <quicksilver> obviously one step further is to replace [] with a more powerful collection type which collects information about the attributes it collects
06:26:17 <quicksilver> and permits constraints on that
06:26:29 <quicksilver> WX doesn't go that far, I don't think GTK does either
06:27:01 <quicksilver> Peaker: I use this idea with OpenGL's StateVar types which you are probably familiar with.
06:27:26 <Peaker> quicksilver, yeah, I don't find it very pretty, though
06:28:07 <quicksilver> Peaker: e.g. with [lighting := Disabled, currentColor := Color4 0 0 0 1] $ do ....
06:28:30 <quicksilver> Peaker: (which handles saving the StateVars and restoring them after the inner do-block, so it feels more compositional and less stateful)
06:28:33 <quicksilver> ...but still type-safe
06:28:46 <Peaker> sort of type safe :)
06:28:57 <quicksilver> yeah. At least the attributes are type-checked.
06:29:02 <Peaker> with [lighting := Disabled, lighting := Enabled] $ do ... ?
06:29:09 <roconnor> quicksilver: what library is this?  It sounds nice
06:29:13 <quicksilver> it's defined in left to right order.
06:29:20 <quicksilver> roconnor: which one? I've been discussing multiple things.
06:29:28 <roconnor> with [lighting := Disabled, currentColor := Color4 0 0 0 1] $ do
06:30:30 <quicksilver> roconnor: well those things are openGL constructs; the 'with' function is one of my own. I'll paste the source it's only a few lines.
06:31:33 <roconnor> quicksilver: oh you don't have an entire functional reintepretation of the OpenGL API?
06:31:58 <quicksilver> sadly not.
06:32:04 <quicksilver> quite a few people are working on that.
06:32:08 <quicksilver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25430#a25430
06:32:49 <roconnor> I'd like to do one for cairo.
06:32:58 <roconnor> or rather I'd like to have one for cairo
06:33:07 <ivanm> heh
06:33:11 <ivanm> fine distinction there ;-)
06:34:00 <quicksilver> I started work on a 2D graphics combinator system with opengl as a backend which woudl theoretically have supported other backends
06:34:23 <Peaker> I used luqui's graphics-drawingcombinators
06:34:39 <quicksilver> I can't find the := thing in Gtk, I'm not sure how that compares to the WX one
06:36:36 <roconnor> Peaker: how is line thinkness defined?  Are there endcaps?
06:36:48 <roconnor> in graphics-drawingcombinators
06:36:53 <ivanm> roconnor: "thinkness"? lines can think now? :o
06:37:01 <roconnor> er
06:37:06 <roconnor> *thickness
06:37:22 <Peaker> roconnor, I didn't use lines, just text and "normal polys" (I used for rectangles)
06:37:22 <roconnor> ivanm: bow down to our new line overlords
06:37:23 <ivanm> awwwww.....
06:38:01 <Peaker> Why not a normal parameter to a line-drawing function? There wouldn't be that many parameters there..
06:39:25 <roconnor> off the top of my head there are parameters for end caps (both ends), colour, thickness, and dashedness (with it's own set of parameters).
06:41:25 <gour> is there some haskell lib providing the same functionality as python's pytz (http://pytz.sourceforge.net/)
06:41:41 <Peaker> roconnor, color is better composed separately (have the line take the color from another image)
06:42:00 <Peaker> roconnor, not sure what dashedness or end cap params would be
06:42:02 <ivanm> gour: what does pytz do?
06:42:24 <gour> ivanm: calculations with timezones
06:42:32 <ivanm> gour: time maybe?
06:42:54 <ivanm> cdsmithus: do I dare ask why you wanted a library to interact with second life?
06:43:41 <gour> ivanm: that's 'standard' lib?
06:43:53 <ivanm> it's in the platform, if that's what you mean
06:44:45 <gour> yep... thanks. i'll try to check if it is good-enough
06:44:49 <roconnor> gour: time is tricky.  What caculations are you thinking of?
06:45:46 <roconnor> some timezone caculation stuff isn't purely functional.  It depends on the politics of the day of various  governments.
06:46:56 <ddarius> You should just display time as the vibration count of a monochromatic electromagnetic wave.
06:47:36 <ivanm> roconnor: daylight-saving, etc.?
06:47:46 <roconnor> ivanm: yes
06:48:46 <roconnor> when I was in Cuba last, the government just decided they weren't going to bother going off of DST that year.
06:49:10 <gour> roconnor: well, i'd need it for astronomy/astrology to calculate ephemeris (via C-lib). one give the place & time of birth and we need to find out what is UTC time for the given time in specified timezone
06:49:37 <dino-> I have one of those time-setting radio wristwatches. I wonder how that would have dealt with that Cuba business.
06:50:18 <temoto> Hello. Does anyone with good understanding on stochastic recurrent neural networks (RBM in particular) have a spare minutes?
06:50:49 <ivanm> roconnor: :o
06:51:19 <ivanm> roconnor: yeah, I've never understood DST: if its worth having in the summer, why not have an extra hour of daylight in the winter as well (when you have less sun during the "day" to start with)?
06:51:38 <roconnor> gour: so long as you know the offset from UTC (rather than the timezone name) you are find
06:51:51 <ivanm> s/find/fine/
06:51:52 <ivanm> ;-)
06:51:52 <roconnor> gour: it is the mapping from region to offset that isn't purely functional.
06:51:58 <roconnor> ya
06:52:13 <dino-> We should just use GMT everywhere, all the time.
06:52:22 <roconnor> ivanm: what lattitude do you live at?
06:52:33 <roconnor> dino-: let's use swatch's internet time!
06:52:36 <roconnor> :P
06:52:43 <ivanm> roconnor: dunno, I'm in canberra now
06:52:51 <ivanm> (but I used to live in Brisbane)
06:53:44 <triyo> A bit of a n00bie question. What is the difference between the State monad and the IORef monad and when should I use which?
06:53:47 <temoto> Canberra: 55.782,37.5008
06:53:49 <mm_freak> dino-: then you couldn't 'show' a timestamp anymore
06:53:58 <aristid> dino-: let's use UTC instead of GMT
06:54:11 <dino-> Yes, I should have said UTC
06:54:19 <roconnor> Ooh I've been through Canberra.  After I left it seemed to have burned down.
06:54:36 <roconnor> ivanm: but it is far enough south that I thought you'd appreciate DST
06:54:37 <dino-> mm_freak: What do you mean? It's still a time, just no zone at all, no DST either.
06:54:38 <temoto> triyo, State is pure. Use it.
06:54:44 <ivanm> roconnor: heh, yeah, there was a fire here about 7 years back IIRC
06:54:55 <ivanm> roconnor: I just moved here in February ;-)
06:54:57 <roconnor> ivanm: I passed through in dec 2002
06:54:59 <dino-> roconnor: What is that swatch thing?
06:55:00 <mm_freak> dino-: yes, but you would need a showLocal, which would need to be an IO computation
06:55:12 <ivanm> yeah, 02/03 would have been it
06:55:23 <roconnor> ivanm: anyhow AFAIK the DST thing is to try to get the sunrise in the morning just before people go to work.
06:55:30 <ivanm> and I'm not an outdoors-y person anyway, so having sun be up till 8 PM doesn't hold much advantage to me ;-)
06:55:52 <triyo> temoto: I am following the "scheme in 48 hours in haskell" tutorial and came across the usage of the IORef
06:55:58 <aristid> ivanm: no reason not to use UTC, then
06:56:08 <gour> roconnor: we plan to use geonames.org data and connect each place with its timezone based on tzdata and put it in a database. then when one selects place from the database, the timezone for the place should be tied to it and haskell lib should give us offset for ephemeris calculations which are normalized for UTC
06:56:18 <mm_freak> dino-: or alternatively a complicated showUsingTimeZone function, which doesn't need the OS to compute the local time =)
06:56:26 <roconnor> gour: sounds good
06:56:39 <ivanm> aristid: sure there is; it's a PITA to bother changing the clocks
06:56:52 <dino-> mm_freak: Sure. I was thinking more radical. The whole Earth using UTC.
06:57:00 <mm_freak> ah
06:57:06 <temoto> mm_freak, it's just that 8:30 would mean morning in London and evening in Toronto or something.
06:57:11 <gour> roconnor: time lib should be sufficient?
06:57:31 <triyo> temoto: apparently author chose IORef over State because the type of data that needed to be stored was fairly complex
06:57:39 <temoto> triyo, yeah i followed that tutorial too.
06:57:48 <ivanm> dino-: at the same time?
06:57:50 <roconnor> gour: it won't do the region to offset stuff, but it will do the rest
06:58:13 <gour> roconnor: good.
06:58:30 <ivanm> aristid: anyway, when you have countries using DST for longer than non-DST in a given year, you have to wonder: why don't they just move the entire working day forward an hour and forget about DST?
06:58:38 <mm_freak> temoto, dino-: i think, local times are easier locally and allow for a more natural experience when you travel
06:58:38 <aristid> dino-: we should institute a global terror regime to enforce that.
06:58:43 <dino-> ivanm: yeah
06:58:43 <roconnor> gour: it even will compute local time for a given longtitude.
06:58:49 <dino-> aristid: no, that doesn't sound nice
06:58:57 <gour> roconnor: great
06:58:59 <temoto> triyo, maybe because IORef is easier to understand with imperative language background, because it's pretty much like good old mutable variable.
06:59:08 <mm_freak> with time zones 9 pm is in the morning everywhere
06:59:10 <aristid> dino-: ok, a terror regime that always says nice things to people
06:59:14 * roconnor browses http://en.wikipedia.org/wiki/2003_Canberra_bushfires
06:59:17 <mm_freak> without it would depend on, well, the time zone ;)
06:59:18 <ivanm> dino-: what would be the point? let's just arbitrarily say that 1 PM is at noon
06:59:19 <dino-> Speaking of SL earlier, I was a little annoyed that they chose PST to be their official time in there.
06:59:37 <mm_freak> you would just make humans compute what machines would do automatically otherwise
06:59:38 <gour> btw, few days ago i discovered fossil scm and plan to use its distributed tracker with darcs...it looks ok & easily deployable
07:00:39 <ivanm> mm_freak: 9 PM? you mean AM?
07:00:46 <triyo> temoto: I see. I come from a predominantly imperative background and must say that even understanding the-somewhat simple State monad was a challenge, or rather still is a challenge.
07:01:31 <temoto> triyo, yeah i have a theory that it takes several months to understand monads, no matter what you do. :)
07:01:44 <dino-> How do people work it with big projects across the planet, I wonder? I would want to just represent everything in UTC. Meeting times, etc. Forget zones. Put a UTC clock on your computer desktop next to your localtime clock.
07:02:20 <mm_freak> ivanm: see, the sole idea already confuses me =)
07:02:26 <mm_freak> s/sole/mere/
07:02:37 <ivanm> heh
07:02:48 <temoto> dino-, they meet up at constant time. Which is great for those who don't sleep at that time and bad for others.
07:03:03 <cdsmithus> temoto: Some mathematicians I know say that to understand any concept in category theory as a beginner, you should first be familiar with at least 3 examples from different fields.  The same is likely true for monads in Haskell.
07:03:05 <mm_freak> temoto: only if you think too complicated =)
07:04:03 <aristid> 16:00 UTC should be a good time.
07:04:03 <mm_freak> but honestly you don't /need/ to understand monads…  at some point you start to understand them automatically anyway
07:04:09 <mm_freak> without having to read tons of tutorials
07:04:11 <dino-> I worked somewhere with a remote team in India. We had a meeting at 8am here (EST) so that it would be 7pm or something for them. It gets tricky with sleep and all, yes.
07:04:21 <mm_freak> and you can work with them without having to understand them
07:04:54 <ivanm> @time
07:04:54 <lambdabot> Local time for ivanm is Tue May 11 00:04:31
07:05:05 <ivanm> see, if it was DST atm then it'd be 1AM now...
07:05:06 <ivanm> ;-)
07:05:09 * ivanm -> bed
07:05:11 <ivanm> g'night all
07:05:14 <mm_freak> @time
07:05:24 <cdsmithus> mm_freak: That's true... and kind of what I was saying.  *First* use some particular monads.  Then try to understand monads, if you like.
07:05:26 <mm_freak> ah CTCP lol
07:05:31 <mm_freak> that's cheating =P
07:05:40 <ivanm> heh
07:05:51 <ivanm> cdsmithus: do I dare ask why you wanted a library to interact with second life?
07:05:52 <mm_freak> good night, ivanm
07:05:56 <mm_freak> it's 16:05 here
07:05:57 <gour> night ivanm
07:06:07 <ivanm> mm_freak: how else would it work if not for CTCP?
07:06:17 <ivanm> you want lambdabot to trace your IP address or something? :p
07:06:23 <mm_freak> ivanm: abusing /whois
07:06:30 <aristid> mm_freak: then you must be in africa or europe?
07:06:40 <mm_freak> aristid: europe
07:06:50 <dino-> @time
07:06:53 <lambdabot> Local time for dino- is Mon May 10 10:06:25 2010
07:07:07 <aristid> dino-: which coast?
07:07:18 <dino-> aristid: East, North Carolina
07:08:12 <Traveler0> hi, can anyone give me a hand correcting this code please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25426#a25426
07:08:34 <Traveler0> trying to get the average from a set of numbers (ratings)
07:09:46 <Traveler0> i know i have to filter the list first since that is doing all the numbers..but im kind of newb and really suck at this
07:10:04 <rajeshsr> roconnor, can you help me debug my haskell implementation of O(N^2) for Problem C at GCJ? The link is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25431#a25431
07:10:19 <rajeshsr> this time it looks a bit readable! Not that ugly! ;)
07:11:07 <cdsmithus> Traveler0: That didn't make sense to me.  What are your Database and Director types doing?
07:11:47 <cdsmithus> Traveler0: I mean, what are they?
07:11:55 <roconnor> rajeshsr: is your problem with computeCycle?
07:12:24 <mm_freak> hmm…  interesting PRNG
07:12:28 <zygoloid> Traveler0: netflix? :)
07:13:30 <Traveler0> zygoloid: means?
07:14:03 <rajeshsr> roconnor, i don't think so, i tested it separately. It seems to behave correctly..
07:14:08 <zygoloid> Traveler0: just guessing what this is for. http://www.netflixprize.com/
07:14:47 <Traveler0> lol..
07:14:54 <roconnor> rajeshsr: ah, I'm not sure I can help much
07:14:56 <rajeshsr> roconnor, it gives correct answer for almost all cases in C-small.
07:15:04 <roconnor> rajeshsr: it looks vaguely correct so you must be pretty close.
07:15:16 <mm_freak> > join . takeWhile (not . null) . map (take 5) . iterate (drop 5) . map (!! 2) $ permutations "011001"
07:15:17 <lambdabot>   "11001111011011000011000011010001110011000001110111010001110011010001110000...
07:15:19 <rajeshsr> roconnor, hmm, ok! thanks
07:15:20 <cdsmithus> Traveler0: If you update your paste to include the type declarations for Database, Director, and Rating, I think we'll be able to help a lot more.
07:15:30 <zygoloid> Traveler0: anyway. which of the two functions do you want help with?
07:15:41 <rajeshsr> roconnor, now any comment on the coding style? what other improvement can be done?
07:15:49 <Traveler0> ill paste the whole coding for that
07:16:21 <roconnor> rajeshsr: your if line is too long.
07:16:41 <roconnor> rajeshsr: if your body begins with an if, like in this case, you can use gaurds instead
07:16:46 <roconnor> and it will probably be more clear
07:16:51 <roconnor> guards
07:16:52 <zygoloid> Traveler0: the most obvious issue is that averageRatingDirector should divide by the number of results at some point, if it's supposed to compute an average
07:16:59 <rajeshsr> roconnor, oh, ok!
07:17:11 <Traveler0> hpaste is down atm
07:17:21 <Traveler0> ya i know zygoloid
07:17:41 <Traveler0> the thing is that it has the list has to be filtered
07:17:47 <Vitka> Is it possible to map parser over list of strings? mapM keeps complaining about type.
07:17:56 <zygoloid> Traveler0: ok. do you know how to use the 'filter' function?
07:18:00 <Traveler0> only for the ratings that the director has given
07:18:02 <cdsmithus> Vitka: What kind of parser?
07:18:11 <zygoloid> @type filter
07:18:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:18:25 <Vitka> Simple CharParser st Integer.
07:18:30 <Traveler0> kind of ya..been doing haskell for a couple of weeks so not really an expert in this
07:18:54 <Vitka> (integer mylexer) to be precise.
07:19:30 <ski> > filter even [0,1,3,6,10,15,21,28]
07:19:31 <lambdabot>   [0,6,10,28]
07:19:34 <zygoloid> Traveler0: ok. how far can you get before you get stuck?
07:19:54 <Traveler0> with use of the filter function?
07:19:57 <zygoloid> yeah
07:20:18 <cdsmithus> Vitka: Yes, you should be able to mapM that.  What's the type error?
07:20:48 <rajeshsr> BTW, any debugger for haskell like dgd?
07:20:51 <rajeshsr> *gdb
07:20:53 <Vitka> Couldn't match expected type `a -> m b'  against inferred type `CharParser st Integer'
07:20:54 <Traveler0> well not far since i dont know exactly how to implement it in that code
07:21:32 <zygoloid> Traveler0: ok, so filter wants a function to say whether elements should be kept, and a list of elements to filter.
07:21:34 <ski> Vitka : just jumping in, but that sounds like you're either omitting an argument, or specifying too many arguments
07:21:55 <Traveler0> alright..
07:22:11 <zygoloid> Traveler0: so you want: averageRatingDirector database director = averageRating (filter ??? database)
07:22:22 <Vitka> Well, mapped function needs a string argument, but mapped parser is just Charparser...
07:22:23 <zygoloid> Traveler0: that just leaves implementing averageRating and whatever the ??? is
07:22:59 <ski> Vitka : how does your call to `mapM' look like ?
07:23:04 <zygoloid> Traveler0: the function we give to filter should return True if the director of that database entry is 'director' and False otherwise
07:23:11 <cdsmithus> Vitka: ok, right... I wasn't thinking.  just should be able to just plain map runParser over the list
07:23:29 <zygoloid> Traveler0: do you know about 'where' clauses?
07:23:40 <Vitka> params <- mapM (integer mylexer) line
07:24:01 <Vitka> line is list of string actually.
07:24:13 <Vitka> line <- count 11 $ count 3 (space <|> digit)
07:24:27 <Traveler0> hmm i see..ya i've done 'where' clauses before
07:25:20 <zygoloid> Traveler0: ok. so you want to write a function which takes a database entry and determines if the director matches.
07:25:33 <cdsmithus> Vitka: if you're not parsing from the input for the current parser, then you want to use runParser again... e.g.: let (Right params) = map (runParser (integer mylexer) "") line
07:25:42 <zygoloid> Traveler0: if you implement it in a where clause in averageRatingDirector you can use the 'director' argument passed in, for your check
07:26:22 <cdsmithus> Vitka: But it sounds like you want to use some other combinator instead of obtaining line to begin with.
07:26:43 <Traveler0> so i can say in the where clause that I only want the rates that are coming from the 'director' right?
07:28:01 <carbonix> hello, does anyone have any suggestion on implementing the algorithm for strongly connected components of a graph?
07:28:16 <Vitka> Maybe, the line in question is specified as "aaabbblllfffcccsssxxxrrrpppiiimmmvvvvvv" where all but vvvvvv are up to 3-digit numbers.
07:28:38 <cdsmithus> carbonix: You need to implement the algorithm?  Or is it okay to use one that already exists?  Several widely used graph packages give you that.
07:28:41 <carbonix> so far, i've done a basic dfs (by simulating a stack),
07:29:13 <carbonix> cdsmithus: I've read about the packages, I have to do it as a homework, so i have to write from scratch
07:29:14 <zygoloid> Traveler0: yeah, you can write a function 'keep' which chooses whether to keep the row. then pass that function as the first argument to 'filter'.
07:29:45 <carbonix> cdsmithus: I've been working on it whole day, and I still get stuck, unfortunately :(
07:30:28 <triyo> I'm trying ti navigate through the haskell html docs. I can't find the Control.Monad.State docs..
07:30:47 <Traveler0> zygoloid: thats understandable now but now comes the coding.. :( ill have a go at it and see how far i can get with it
07:30:59 <cdsmithus> carbonix: I'd have to look it up.  I seem to recall the algorithm being moderately complex last time I saw it.
07:31:28 <carbonix> cdsmithus: do you have a couple of minutes? (no prob if no), i can just paste it somewhere
07:31:32 <mauke> triyo: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html
07:31:42 <cdsmithus> carbonix: A few, sure.
07:32:37 <carbonix> cdmithus: http://www.pastebin.org/217878
07:33:34 <carbonix> cdsmithus: on short, the dfs function is working fine, the problem is at dfsV_aux, which should retain in the newstack list the nodes in their finished order (like when dfs finishes a node, it's pushed on newstack)
07:34:01 <carbonix> cdsmithus: it's kosaraju's algorithm - http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm
07:34:21 <cdsmithus> carbonix: there are vertices in your edges list that don't appear in the vertex list?
07:34:34 <ski> Vitka : what is the type of `integer' ?
07:35:15 <roconnor> rajeshsr: Debug.Trace.trace will give you print-style debugging
07:35:15 <carbonix> cdsmithus: fixed it, they all should appear in vertex and edge
07:35:37 <rajeshsr> roconnor, thanks
07:35:39 <ski> Vitka : and where does this `mapM' call occur ? inside another parser ? inside an `IO'-action ?
07:35:50 <roconnor> @src Debug.Trace.trace
07:35:50 <Vitka> Inside another parser.
07:35:51 <lambdabot> Source not found. There are some things that I just don't know.
07:38:48 <carbonix> cdsmithus: if you run with hugs I can tell you where exactly is the mismatch, might just be a typo, because on paper the method works
07:38:57 <ski> Vitka : ok. hmm .. you *could* merge the `line <- count 11 $ count 3 (space <|> digit)' parsing with the `params <- mapM (integer mylexer) line' one; doing both parsings at once .. but i'm not sure how convenient that would be in your case
07:39:38 <cdsmithus> carbonix: Sorry, was reading about the algorithm first.  Looking at the code now
07:39:59 <ski> Vitka : the usual operation of parsing with Parsec is to parse "once" from a string (or token-list) to the intended "parse tree" .. not doing multiple sub-passes
07:40:25 <carbonix> cdsmithus: basically, the dfsV_aux tries to simulate the stack (in newstack) from wiki
07:41:00 <Vitka> I'm trying to think of more elegant way to parse aforementioned line...
07:42:39 <soupdragon> http://personal.cis.strath.ac.uk/~adam/type-inference/
07:42:46 <ski> hm .. i guess this might be a good example of why one could want "additive conjunction" in Parsec
07:42:56 <soupdragon> 'We consider the problems of first-order unification and type inference from a very general perspective on problem-solving, namely that of information increase in the problem context. This leads to a powerful technique for implementing type inference algorithms. We describe a unification algorithm and illustrate the technique by applying it to the familiar Hindley-Milner type system, but it can be applied to more advanced type systems'
07:44:00 <rajeshsr> @src findIndex
07:44:00 <lambdabot> findIndex p     = listToMaybe . findIndices p
07:44:16 <rajeshsr> @src findIndices
07:44:17 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
07:46:49 <cdsmithus> carbonix: Okay, so what's dfsV_aux doing wrong?
07:47:49 <rajeshsr> i would like to have lamdabot as a command line app like gchi. Is that possible?
07:47:53 <carbonix> cdsmithus: if I call dfsV_aux g2 [] [0] [] (this means, it starts from node 0), the newstack at the is [7, 4, 2, 6, 0] , and it should've been [4, 2, 7, 6, 0]
07:49:01 <carbonix> cdsmithus: it should record the node after it was expanded completely
07:50:46 <cdsmithus> carbonix: right, so the problem is that when you reach 7 again via four, and then back up, you're adding it to S.
07:51:18 <zeshan> any one is alive here
07:51:33 <zeshan> i need a help
07:51:40 <zeshan> can any one help me? plzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
07:51:52 <aristid> @src zip
07:51:53 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:51:53 <lambdabot> zip _      _      = []
07:51:53 <wli> zeshan: Ask away, don't ask to ask.
07:51:58 <zeshan>  can any one help me? plzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
07:52:00 <mauke> zeshan: you're annoying
07:52:05 <Tass_> zeshan, get some manners.
07:52:13 <zeshan> oki sory :-s
07:52:37 <zeshan> tass_ sory
07:52:58 <carbonix> cdsmithus: uhm, thanks, I forgot about the link back, at least now I know I've been thinking bad :(
07:53:08 <wli> @type flip runContT return . callCC . runReaderT . forever
07:53:09 <lambdabot> forall r (m :: * -> *) b a. (Monad m) => ReaderT (r -> ContT r m b) (ContT r m) a -> m r
07:53:15 <Zao> zeshan: There are plenty of people alive at any time. Ask a proper question regarding Haskell and you will probably receive aid.
07:55:13 <Zao> zeshan: Me responding does not mean that you should PM me. Ask the channel.
07:55:30 <zeshan> i want to exploit a website
07:55:37 <Zao> zeshan: We want to kickban you.
07:55:42 <aristid> MonadPlus is strictly weaker than Monoid, right?
07:55:46 <quicksilver> then you're in the wrong channel. This channel is for discussing hte haskell programming language.
07:55:55 <Zao> quicksilver: And burritos.
07:55:57 <quicksilver> aristid: they have different kinds entirely.
07:56:07 <zeshan> sory sir
07:56:13 <aristid> quicksilver: huh?
07:56:14 <zeshan> i am just 16 yer kid
07:56:18 <quicksilver> aristid: Monoid applies to concrete types of kind *, MonadPlus to types of kind * -> *
07:56:34 <aristid> zeshan: go play in the sandbox :P
07:56:37 <zeshan> :-s i am sory if i did any missbehave
07:56:49 <zeshan> but i love hacking
07:57:00 <quicksilver> aristid: "[Char]" is a Monoid, while "[]" is a MonadPlus
07:57:03 <zeshan> wher u from aristid?
07:57:10 <Zao> zeshan: I strongly recommend that you focus your life on something productive instead.
07:57:14 <aristid> quicksilver: i see
07:57:44 <zeshan> oki sir i will
07:57:46 <quicksilver> > "hi" `mappend` "there"
07:57:47 <lambdabot>   "hithere"
07:57:53 <Vitka> @undo { do n <- count 3 (char ' ' <|> digit) ; return ((read n) :: Int) }
07:57:54 <lambdabot>  Parse error at "{" (column 1)
07:57:56 <quicksilver> > "hi" `mplus` "there"
07:57:57 <lambdabot>   "hithere"
07:58:02 <zeshan> :(
07:58:10 <aristid> quicksilver: same result ;)
07:58:10 <zeshan> no one is helping me...
07:58:13 <quicksilver> aristid: yup.
07:58:20 <soupdragon> ill help you
07:58:30 <quicksilver> aristid: they do indeed coincide for this one, but for Maybe they don't.
07:58:32 <carbonix> cdsmithus: do you think I could a use filter function on neighbors on line 30?
07:58:38 <zeshan> thnk you sir soupdraon
07:58:50 <Vitka> @undo do { n <- count 3 (char ' ' <|> digit) ; return ((read n) :: Int) }
07:58:50 <lambdabot> count 3 (char ' ' <|> digit) >>= \ n -> return ((read n) :: Int)
07:58:51 <aristid> quicksilver: Maybe x is no monoid, is it?
07:59:09 <quicksilver> > Just "hi" `mappend` Just "there"
07:59:10 <lambdabot>   Just "hithere"
07:59:13 <quicksilver> aristid: sure is :)
07:59:19 <wli> @type fail -- for pain
07:59:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:59:26 <quicksilver> > Just "hi" `mappend` Nothing
07:59:27 <lambdabot>   Just "hi"
07:59:28 <zeshan> <soupdragon> sir if u allow me to pm you :-s
07:59:29 <aristid> instance (Monoid a) => Monoid (Maybe a) -- Defined in Data.Monoid
07:59:29 <Vitka> @pl  \n -> return ((read n) :: Int)
07:59:29 <lambdabot> return . (:: Int) . read
07:59:32 <quicksilver> > Just "hi" `mplus` Nothing
07:59:33 <lambdabot>   Just "hi"
07:59:40 <aristid> quicksilver: but only when a is a Monoid too
07:59:45 <quicksilver> aristid: right.
07:59:59 <aristid> > Just "hi" `mappend` Just " you"
08:00:00 <lambdabot>   Just "hi you"
08:00:09 <quicksilver> they do coincide, sorry. I was sure they didn't.
08:00:15 <zeshan> <soupdragon> sir can i send u message personaly?
08:00:25 <aristid> > Just "hi" `mplus` Just "you"
08:00:26 <lambdabot>   Just "hi"
08:00:30 <quicksilver> ah no, that's it
08:00:32 <aristid> quicksilver: they don't :)
08:00:32 <quicksilver> grin
08:00:34 <quicksilver> thanks!
08:00:40 <aristid> :)
08:00:48 <carbonix> how do I say x does not belong to? if x belongs to y is x <- y ?
08:00:52 <quicksilver> aristid: anyhow, you expect MonadPlus to obey the Monoid laws
08:01:02 <quicksilver> aristid: and there is some debate about whether it should also obey some other laws
08:01:04 <ski> carbonix : context ?
08:01:07 <aristid> quicksilver: MonadPlus is associative?
08:01:11 <quicksilver> which relate it to the Monad operations.
08:01:13 <quicksilver> yes, definitely.
08:01:26 <aristid> somehow didn't expect it to
08:01:30 <carbonix> ski: like, [ x | x <-y, x does not belong to z ]
08:02:01 <ski> > [ x | x <- [0..9] , x `notElem` [2,3,5,7] ]
08:02:02 <lambdabot>   [0,1,4,6,8,9]
08:02:03 <quicksilver> aristid: some possible laws here http://www.haskell.org/haskellwiki/Monadplus
08:02:14 <ski> > [ x | x <- [0..9] , not (x `Elem` [2,3,5,7]) ]
08:02:15 <lambdabot>   Not in scope: data constructor `Elem'
08:02:18 <ski> er
08:02:21 <ski> > [ x | x <- [0..9] , not (x `elem` [2,3,5,7]) ]
08:02:22 <lambdabot>   [0,1,4,6,8,9]
08:02:31 <ski> carbonix : does any of those work for you ?
08:02:32 <soupdragon> > let s = [ x | x <- s, x `notElem` s ] in s
08:02:36 <lambdabot>   mueval-core: Time limit exceeded
08:02:45 <carbonix> ski: should work
08:02:53 <carbonix> ski: testing it
08:02:53 <noteed> zeshan: you can just write your question, if someone can help you, he will
08:02:54 <aristid> quicksilver: the mplus from the Maybe MonadPlus probably has a Prelude function equivalent, doesn't it?
08:02:54 <zeshan> No One Is HelPIng me :(
08:03:10 <ski> zeshan : so you want to learn Haskell ?
08:03:16 <zeshan> yes
08:03:23 <soupdragon> zeshan, why are complaining here rather than talking to me in PM?
08:03:28 <zeshan> and also i want to hack some porn abuse site
08:03:31 <janbanan> Don't do it
08:03:38 <aristid> zeshan: then read this: http://learnyouahaskell.com/ and don't hack any site.
08:03:40 <ski> zeshan : i think you should take a look at a Haskell tutorial
08:03:52 <soupdragon> zeshan, you probably mean "crack" rather than "hack"
08:03:59 <soupdragon> hacking is what the people in this channel do
08:04:02 <carbonix> ski , cdsmithus : thanks for the help, partially solved the problem :)
08:04:03 <soupdragon> cracking is what 12 year olds do
08:04:13 <zeshan> ohhh
08:04:21 <zeshan> u know how to make ddos?
08:04:31 <zeshan> irc ddos
08:04:39 <Vitka> @pl  \n -> ((read n) :: Int)
08:04:40 <lambdabot> (:: Int) . read
08:04:57 <ski> zeshan : would you like to know how to make a monad ?
08:04:59 <aristid> Vitka: oO i didn't know it's possible to have :: in a section
08:05:02 <aristid> :t (::)
08:05:03 <lambdabot> parse error on input `::'
08:05:08 <aristid> :t (:: Int)
08:05:08 <ski> Vitka : don't believe that reply :)
08:05:09 <lambdabot> parse error on input `::'
08:05:28 <ski> (aristid : it isn't, `pl' is a bit stupid like that ..)
08:05:33 <aristid> ski: i see :)
08:05:55 <Vitka> Hmm.
08:06:03 <aristid> Vitka: read :: Int would be what you want
08:06:12 <aristid> no
08:06:13 <aristid> hmm
08:06:18 <ski> aristid : no, `read :: String -> Int'
08:06:29 <ski> > (read :: String -> Int) "42"
08:06:30 <lambdabot>   42
08:06:32 <ski> > (read :: String -> Int) "boom !"
08:06:33 <lambdabot>   *Exception: Prelude.read: no parse
08:06:48 <ski> > (reads :: ReadS Int) "42"
08:06:49 <lambdabot>   [(42,"")]
08:06:54 <ski> > (reads :: ReadS Int) "boom !"
08:06:55 <lambdabot>   []
08:07:53 <aristid> ski: where is ReadS from?
08:07:58 <ski> @src ReadS
08:07:59 <lambdabot> Source not found. It can only be attributed to human error.
08:08:01 <ski> @index ReadS
08:08:01 <lambdabot> Text.ParserCombinators.ReadP, Text.Read, Prelude, Distribution.Compat.ReadP
08:08:09 <ski>   type ReadS a = [(a,String)]
08:08:19 <ski> so, it's in `Prelude'
08:08:39 <ski> er, that should be
08:08:44 <ski>   type ReadS a = String -> [(a,String)]
08:08:48 <ski> @type reads
08:08:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:09:04 <ski>   reads :: Read a => ReadS a  -- equivalent type signature
08:09:32 <aristid> > (reads :: ReadS Int) "42x"
08:09:33 <lambdabot>   [(42,"x")]
08:09:38 <aristid> cool stuff.
08:10:02 <ski> the list is for possibly many (or possibly no) way to parse.. the extra `String' is for the rest of the string
08:11:40 <aristid> > (reads :: ReadS Int) ""
08:11:41 <lambdabot>   []
08:12:15 <aristid> so ReadS doesn't fail on invalid input
08:12:34 <ski> well, it fails by returning an empty list :)
08:12:56 <ski> (but yes, it is not a partial function, like `read' is)
08:13:58 <aristid> quicksilver: is there a MonadPlus wrapper Monoid?
08:14:08 <quicksilver> don't think so
08:14:30 <aristid> IO is a MonadPlus? oO
08:15:45 * ski thinks it shouldn't ..
08:15:52 <quicksilver> sure, via exception handling. Although some people think catching all exceptions is evil. Other people simply think all exceptions are evil.
08:15:57 <ski> (also see `MonadPlus_reform_proposal' on the wiki)
08:17:40 <aristid> ski: do you think Maybe should be a MonadPlus?
08:18:25 <benmachine> I don't think people think catching all exceptions is evil, people just think it's used much more often than necessary
08:18:32 <benmachine> and frequently inappropriately
08:19:58 <ski> @wiki MonadPlus
08:19:58 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
08:20:03 <ski> @wiki MonadPlus_reform_proposal
08:20:03 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
08:20:03 <benmachine> however it is true that all exceptions are evil >_>
08:20:06 <quicksilver> benmachine: well the generic argument goes something like "knowing that it's safe to catch *all* exceptions is global knowledge, and therefore can never be appropriate in modular code, which is not supposed to have complete global knowledge"
08:20:07 <ski> aristid : ^
08:20:33 <quicksilver> benmachine: i.e. you must assume your module is used in the context with layers below + above it which invent and catch exceptions you've never heard of and shouldn't touch.
08:20:55 <ski> (i would add that i would prefer `MonadOr' to be called `MonadOrElse' or `MonadElse', to emphasize the assymetric behaviour of `morelse')
08:20:57 <aristid> ski: i was referring to that
08:21:08 <aristid> ski: Maybe doesn't satisfy Left Distribution
08:21:09 <benmachine> quicksilver: but if you're writing a main function, can't you claim that you know yours is the top level?
08:21:12 <quicksilver> argument doesn't actually hold water, because you can't write any code at all without making at least a few global assumptions (call them global invariants, functional programmers prefer that ;)
08:21:24 <ski> aristid : right, so it should be a `MonadElse'
08:21:31 <quicksilver> benmachine: no, you might end up being called from ghci, or from some Haskell Application Server type master-server.
08:21:56 <quicksilver> benmachine: anyhow I'm not actually espousing the argument, just attempting to report it.
08:22:10 <benmachine> mm, ok
08:22:20 <benmachine> but I'd think that argument would make executeFile evil too
08:22:31 <benmachine> but then, maybe it is
08:23:16 <quicksilver> benmachine: I'm happy with a weaker version of the argument like "catching all exceptions is probably bad for compositionality"
08:23:29 <quicksilver> benmachine: "don't make more assumptions about your environment than you have to"
08:23:36 <benmachine> yeah, seems fair
08:23:56 <benmachine> I don't like exceptions in general though :P
08:24:14 <benmachine> but I write toys so I don't get the use cases that most people do, perhaps
08:24:39 <aristid> is there a standard function which does the same as mplus for the Maybe MonadPlus?
08:25:11 <benmachine> Control.Applicative.<|> I suppose?
08:25:17 <benmachine> might be slightly cheating though :P
08:25:35 <Saizan> mappend for the First wrapper
08:25:37 <benmachine> also, \x y -> getFirst (mappend (First x) (First y))
08:25:38 <zeshan> any one is here?
08:25:40 <ski> @type Data.Generics.Aliases.orElse  -- appears to be it
08:25:41 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
08:25:52 <Jonno_FTW> @hoogle Control.Applicative
08:25:52 <aristid> @src orElse
08:25:52 <lambdabot> module Control.Applicative
08:25:52 <lambdabot> Control.Applicative class Functor f => Applicative f
08:25:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:25:56 <illissius> I'm still having problems with the llvm bindings. This is what it gives me when I try to compile: http://haskell.pastebin.com/KLdFmeCr
08:25:56 <benmachine> @pl \x y -> getFirst (mappend (First x) (First y))
08:25:57 <lambdabot> (getFirst .) . (. First) . mappend . First
08:26:00 <benmachine> neat
08:26:04 <benmachine> sort of
08:26:10 <illissius> anyone know what could be causing this, or at least any idea on how to troubleshoot it?
08:26:21 <ski> zeshan : what is your (Haskell-related) question ?
08:27:18 <Saizan> illissius: looks like the llvm lib is not getting linked in
08:27:45 <aristid> ski: thanks, orElse it is
08:28:01 <ski> (i've never seen that `orElse' before, though ..)
08:28:10 <JuanDaugherty> illissius, you do know there's an llvm channel, albeit not on this net
08:28:25 <illissius> I know
08:28:47 <illissius> this seems to be an issue with the llvm bindings, not llvm itself, though I'm not really sure
08:29:12 <aristid> ski: it fits the name morelse
08:29:21 <ski> @type \x y -> getFirst (mappend (First x) (First y))
08:29:21 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
08:29:43 <aristid> :t getFirst . mappend
08:29:44 <lambdabot>     Couldn't match expected type `First a'
08:29:44 <lambdabot>            against inferred type `a1 -> a1'
08:29:44 <lambdabot>     Probable cause: `mappend' is applied to too few arguments
08:29:57 <soupdragon> I wish we could do   isomorphism In out (a -> a -> a) f :: X a -> X a -> X a
08:30:15 <soupdragon> and  isomorphism In Out (a -> (b -> a) -> b) g :: (X a -> (X b -> X a) -> X b)
08:30:18 <soupdragon> and so on
08:30:32 <ski> @type (getFirst .) . mappend
08:30:32 <lambdabot> forall a. First a -> First a -> Maybe a
08:30:33 <aristid> @pl \x y -> getFirst (mappend (First x) (First y))
08:30:33 <lambdabot> (getFirst .) . (. First) . mappend . First
08:30:50 <aristid> . sections scare me
08:31:00 <soupdragon> learn this one:  (f .) . g
08:31:07 <ski> replace them with `argument' and `result', then ?
08:31:17 <soupdragon> once you understrand that it is a good start
08:31:17 <aristid> @unpl (f .) . g
08:31:18 <lambdabot> (\ d i -> f (g d i))
08:31:25 <mauke> @urkl f
08:31:25 <lambdabot> I know nothing about f.
08:31:42 <benmachine> @help urkl
08:31:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:31:48 <benmachine> bzzt
08:31:54 <aristid> benmachine: it hates you
08:31:58 <Jonno_FTW> how come this won't work?
08:31:59 <benmachine> no mauke does
08:32:00 <Jonno_FTW> input <- fmap lines (concat $ mapM readFile $ getDirectoryContents "C:\\
08:32:05 <ski> aristid : anyway, why did you want a monomorphic `orElse' ?
08:32:19 <Jonno_FTW> where the string on the end is a directory
08:32:26 <mauke> Jonno_FTW: concat doesn't make sense there
08:32:33 <benmachine> :t mapM
08:32:34 <aristid> ski: i somehow felt a desire for knowing whether there is one
08:32:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:32:38 <rajeshsr> :t findIndex
08:32:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
08:32:40 <aristid> ski: no particular reason
08:32:46 <benmachine> mapM works on plain lists, not IO [a]
08:33:13 <ski> Jonno_FTW : `input <- mapM (liftM (lines . concat) . readFile) (getDirectoryContents "C:\\...")' ?
08:33:19 <aristid> > mapM (+1) [1,2,3]
08:33:20 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
08:33:20 <lambdabot>    arising from a use of `M71526049...
08:33:26 <Jonno_FTW> hnnn
08:33:29 <mauke> mapM readFile =<< getDC "..."
08:33:31 <aristid> :z mapM (+1) [1,2,3]
08:33:34 <mauke> and then the lines thing
08:33:35 <aristid> :t mapM (+1) [1,2,3]
08:33:36 <lambdabot> forall (m :: * -> *) b. (Num (m b), Monad m) => m [b]
08:33:38 <benmachine> aristid: the function is monadic
08:33:48 <ski> or, i suppose not exactly that
08:33:52 <aristid> > mapM (+1) [1,2,3] :: [[Int]]
08:33:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
08:33:53 <lambdabot>    arising from the literal `...
08:34:11 <aristid> > (mapM (+1) [1,2,3]) :: [[Int]]
08:34:12 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
08:34:12 <lambdabot>    arising from the literal `...
08:34:15 <benmachine> aristid: requires Num [a]
08:34:19 <benmachine> which is silly
08:34:22 <ski> @type \f g -> liftM f . g
08:34:23 <lambdabot> forall a1 r (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => (a1 -> r) -> f (m a1) -> f (m r)
08:34:28 <benmachine> you can't get (+1) to be a -> m b
08:34:31 <ski> @type \f g -> liftM f Prelude.. g
08:34:32 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a1 -> r) -> (a -> m a1) -> a -> m r
08:34:37 <ski> (hm .. no, that's right)
08:34:39 <benmachine> unless you have Num (m b)
08:34:40 <mauke> > mapM Just [1,2,3]
08:34:42 <lambdabot>   Just [1,2,3]
08:34:46 <wli> > mapM (return . succ) [1..3]
08:34:47 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
08:34:47 <lambdabot>    arising from a use of `M12647859...
08:34:50 <mauke> therefore mapM == id
08:34:53 <wli> > mapM (Just . succ) [1..3]
08:34:54 <lambdabot>   Just [2,3,4]
08:35:38 <Jonno_FTW> o
08:35:43 <wli> > mapM (\x -> guard (x /= 2) >> Just x) [1..3]
08:35:44 <lambdabot>   Nothing
08:35:49 <ski> aristid : arguably, `orElse' should be in `Data.Maybe', if there is deemed sufficient reason to have a monomorphic variant
08:35:53 <Jonno_FTW> I'll sort this out when it's not 1am
08:36:31 <aristid> ski: i somehow like it when a polymorphic function just aliases different monomorphic functions
08:36:35 <aristid> don't ask me why
08:36:49 * benmachine asks aristid why
08:37:05 <aristid> benmachine: it feels more clean and orderly, dunno
08:37:10 <ski> aristid : you mean you'd like to be able to specify the more specialized one, if you only require that ?
08:37:35 <aristid> ski: i could get the same by forcing a type :)
08:37:47 <ski> yes, but that's usually uglier
08:37:53 <wli> Polymorphism is templates not overloading.
08:37:54 <benmachine> aristid: it'd be weird for (+) :)
08:38:23 <aristid> benmachine: why do i suddenly have to think of ocaml? :D
08:38:24 <ski> wli : well, in this case we were talking about bounded polymorphism :)
08:42:57 <illissius> Saizan: any idea how to make sure and/or figure out why and/or rectify it? (llvm not being linked in)
08:47:48 <rajeshsr> > Couldn't match expected type `Integer' against inferred type `Int'
08:47:49 <lambdabot>   <no location info>: parse error on input `type'
08:47:56 <rajeshsr> and vice versa...
08:48:07 <rajeshsr> is there any efficient way to weed such errors?
08:48:24 <rajeshsr> now i go to those arguments and add fromIntegral..
08:48:43 <rajeshsr> I thought it will be natural to interpret Int args as Integer!
08:49:22 <aavogt> you can express that with typeclasses
08:49:34 <rajeshsr> aavogt, you mean?
08:49:46 <aavogt> but I'm not sure you can manage to keep the nice errors that way
08:50:21 <rajeshsr> aavogt, the problem is all of a sudden all my data types are interpreted as Int, mainly because there are definitions like n = length lis etc..
08:50:37 <rajeshsr> But while doing computation they can exceed Int
08:50:39 <gwern> so use genericLength
08:50:47 <gwern> @hoogle [a] -> Integer
08:50:48 <lambdabot> Prelude head :: [a] -> a
08:50:48 <lambdabot> Prelude last :: [a] -> a
08:50:48 <lambdabot> Data.List head :: [a] -> a
08:50:50 <aavogt> because there are no implicit conversions
08:50:52 <gwern> bleh
08:51:10 <aavogt> but you could write    class OmNum a b c where  (+) :: a -> b -> c
08:51:13 <rajeshsr> gweiqi, well, findIndex and many others like that!
08:51:17 <gwern> genericLength is hit #5, just one short
08:51:24 <gwern> rajeshsr: most of them have Integer equivs
08:51:30 <aavogt> which can express those implicit conversions you want
08:51:35 <benmachine> @hoogle+
08:51:36 <lambdabot> Data.List last :: [a] -> a
08:51:36 <lambdabot> Data.List genericLength :: Num i => [b] -> i
08:51:36 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
08:51:37 <aavogt> but nobody seems to do that
08:51:42 <benmachine> gwern: where one = two
08:52:21 <rajeshsr> aavogt, hmm, so it is better to use fromIntegral in the places of errors?
08:52:36 <rajeshsr> that is really sicking!! :(
08:53:58 <rajeshsr> so finally i managed to solve Problem C in GCJ with haskell! It was really a silly bug to find!! :)
08:53:59 <quicksilver> rajeshsr: no, it isn't. It's really important.
08:54:12 <quicksilver> rajeshsr: because it forces you to think about the places in your code where Int might overflow.
08:54:18 <quicksilver> (at the boundaries between Int and Integer)
08:54:25 <quicksilver> implicit conversions are just bugs waiting to happen.
08:54:36 <rajeshsr> quicksilver, hmm, exactly! That is the problem i faced.
08:54:50 <aavogt> rajeshsr: so are implicit conversions when they aren't the ones you want
08:54:52 <rajeshsr> it interpreted as Int by default and all values overflowed
08:55:31 <rajeshsr> I added type signatures to functions to make them Integer and had to add fromIntegral at lots of places!
08:55:53 <cdsmithus> quicksilver: on the other hand, I've found length's insistence on being an Int to *cause* numeric overflow in applications more often than anything else.
08:55:54 <aavogt> quicksilver: most code is filled with bugs waiting to happen regardless
08:56:04 <rajeshsr> aavogt, hmm, agreed! It is true with float and Int! Int and Integer aren't all that bad to mix..
08:57:16 <rajeshsr> I would even say only Integer type is enough!
09:00:15 <benmachine> aavogt: better go back to slide rules :P
09:00:28 <Saizan> illissius: "ghc-pkg describe llvm" should list an ld-options field, check if they make sense
09:00:55 <Saizan> illissius: that's filled in with info collected by the configure script, afaiu
09:02:35 <benmachine> I wish cabal-install had a simple command to tell you which libraries you had installed which were a major version or more behind those on hackage
09:02:46 * benmachine doesn't care about .0.0.1 upgrades
09:03:11 <aavogt> use cabal's api?
09:03:40 <aavogt> but in any case that's kind of broken because there doesn't seem to be a way to tell if a package follows the PVP
09:03:40 <benmachine> pfft I don't want to do any actual work
09:03:59 <benmachine> ah, my method for doing that is 1. assume it does 2. whine when it doesn't
09:04:47 <aavogt> well you're not going to find about those whining cases without doing all the work that cabal failed at
09:08:03 <ezyang> Ok, time to figure out why my GHC build failed
09:09:22 <soupdragon> "Functional Programming advocates have claimed that assignment (to a variable or data structure) is dangerous because it violates referential transparency. Curiously, this note shows that for uniﬁcation, the functional approach is error-prone, while the procedural, state-modiﬁcation approach tends to lead to a correct solution."
09:09:31 <soupdragon> norvig.com/unify-bug.pdf
09:11:24 <opqdonut> i have had the same feeling for a while
09:11:39 <opqdonut> (i've implemented a couple of unification-esque things at work lately)
09:12:27 <ski> (.. sometimes, state (in some incarnation) really is appropriate)
09:13:27 * wli is not terribly impressed by the claim there.
09:13:33 <quicksilver> cdsmithus: really? You often deal with lists longer than 4 billion items on a 32 bit machine?
09:14:09 <quicksilver> cdsmithus: it's a real potential problem but I can't believe it comes up often in practice.
09:14:17 * ski often deals with infinite lists on a 32 bit machine ;)
09:14:24 <gwern> benmachine: can't you use cabal upgrade --dry-run and see what's out of date?
09:14:28 <quicksilver> haskell is much too slow to count the size of such lists in useful time.
09:14:40 <quicksilver> ski: but I bet you don't often touch - or count - more than 4 billion of them.
09:14:47 <cdsmithus> quicksilver: That's irrelevant.  lengths get used in other computations, and force the entire expression to be evaluated as an Int instead of an Integer
09:14:53 <quicksilver> ski: the claim at issue is running 'length' causing Int overflows.
09:14:59 <ski> quicksilver : *nod* (hence the irony)
09:15:03 <aristid> if you calculate the length of a list with 4 billion items, you are doing something wrong :)
09:15:20 <quicksilver> cdsmithus: that's just sloppy programming; if you need better precision you fromIntegral the result of length.
09:15:24 <ski> in any case, i would prefer if the standard `length' had the type of `genericLength'
09:15:42 <quicksilver> well in many ways I'd prefer it if Integer was the standard integral type
09:15:51 <cdsmithus> quicksilver: It wouldn't be sloppy programming if length didn't return a broken (okay, very limited special-purpose) type by default
09:15:54 <quicksilver> but give that it's still 30x slower or something, that's just not feasible.
09:16:03 <noteed> soupdragon: did you see this ? http://www.cs.uu.nl/wiki/bin/view/Ehc/EfficientFunctionalUnificationAndSubstitution
09:16:05 <monochrom> if you calculate the length of a list with 4 billion items, the answer is 4 billion.
09:16:15 <wli> The unification occurs check bug he's on about doesn't seem to be universal at all. Probably an artifact of Lisp or the specific codebase if anything.
09:16:38 <quicksilver> cdsmithus: s/very limited special-purpose/fast, machine-supported, and always almost sufficient/
09:16:50 <quicksilver> cdsmithus: we may as well agree to differ, it's a silly argument of anecdotes.
09:16:55 <mornfall> quicksilver: There's no particularly good way to make the situation much better.
09:17:10 <quicksilver> it annoys me mildly that we're force by pragmatic issues to use Int, but I don't believe it is likely to cause bugs.
09:17:13 <mornfall> Wrt. the 30x slowdown, anyway.
09:17:26 <quicksilver> and I certainly believe it is less likely to cause bugs than implicit conversions would be.
09:17:54 <quicksilver> mornfall: I think you might hope for something more like a 2x slowdown, but I'm no codegen expert.
09:17:54 * wli sticks to genericLength and Integer
09:18:39 * rajeshsr reads an interesting wiki article: http://en.wikipedia.org/wiki/The_Complexity_of_Songs
09:18:40 <mornfall> quicksilver: I wouldn't hope for that good, given that most everything to do with Integer needs branching (and there's no way around that).
09:19:02 <mornfall> quicksilver: And that integer arithmetic is about the fastest thing on the CPU.
09:19:51 <monochrom> use Gödel numbering to avoid branching
09:20:14 <quicksilver> mornfall: well you hope for entire code chunks and inner loops to be specialised to the case where everything is in-range for Int
09:20:33 <quicksilver> mornfall: and you use the hardware overflow register to branch out on overflow only to the fallback case
09:20:37 <mornfall> quicksilver: Well, if you can prove that, then you are lucky and get 0 slowdown. :)
09:20:53 <quicksilver> mornfall: no, you don't *prove* it
09:21:06 <quicksilver> mornfall: you assume it, and use the hardware overflow register to fall back if you're wrong
09:21:31 <quicksilver> register/flag/whatever the word is.
09:22:03 <mornfall> quicksilver: Well, but you still need to check that overflow all the time, which involves branching. Or you have to re-do parts of the computation if the assumption failed somewhere amid computation. (But I don't think that overflow is preserved by arithmetic, so you have to branch after each arithmetic instruction anyway?)
09:22:29 <quicksilver> mornfall: I don't know :)
09:22:41 <mornfall> You can only lift the check out of a loop if the loop has exactly one arithmetic instruction in it.
09:22:46 <mornfall> As far as I can tell.
09:23:06 <monochrom> It is exception throwing and catching in hardware. No branching until the exception happens.
09:23:37 <quicksilver> mornfall: isn't a non-taken branch free?
09:23:47 <quicksilver> (on a pipelining system, if the branch predictor got it right)
09:24:01 <quicksilver> well free apart from bloating code a bit
09:25:14 <monochrom> If you use hardware exception, it is free on 1970 hardware too. The "branching" is in microcode, not in an assembly instruction.
09:25:48 <quicksilver> that's good :) so my idea holds at least a little water.
09:25:58 <quicksilver> still fairly gnarly codegen though.
09:26:55 <quicksilver> I didn't know that chips had hardware exceptions in their ALU though, I thought that was FPU only
09:27:11 <ski> rajeshsr : wonderful :D
09:27:39 <rajeshsr> ski, yep! That was really amusing. Knuth proves time and again that CS is all fun!
09:28:38 <mornfall> monochrom: You don't get hardware exceptions from overflows.
09:29:01 <mornfall> quicksilver: If the predictor got it right, it's cheap, otherwise it's expensive. It's never free. :)
09:29:03 <monochrom> You are right about certain popular CPUs.
09:29:46 <mornfall> monochrom: The others don't really matter.
09:30:11 <quicksilver> mornfall: well it's free in so far as if the next instruction is arithmetic, it will already have started running
09:30:13 <mornfall> monochrom: If Integer is fast on some obscure platform, but still slow on the mainstream one, it's not going to help any.
09:30:28 <quicksilver> mornfall: and that's pretty much better than any alternative
09:30:38 <aristid> Int64 ftw
09:30:44 <quicksilver> mornfall: if you've got the arithmetic parts running back-to-back or overlapping as much as possible, you've won.
09:32:47 <mornfall> quicksilver: The problem is that every arithmetic of the original code is followed by branch in the Integer version, so there's certainly a lot more work for the CPU, although presumably the decoder and caches are fast enough to hide the extra bloat.
09:33:12 <carbonix> uhm, another short question.. I have a a data type: data NodeType a = Null | Node a [NodeType a], and I need to see if two objects are equal
09:33:22 <carbonix> I've written: instance (Eq a) => Eq (NodeType a) where  Node a xs == Node b ys = a == b && xs == ys
09:33:24 <mornfall> quicksilver: It would probably work if you could tell the predictor to always avoid the jump.
09:33:30 <quicksilver> mornfall: well it can conceivably be much better than the existing situation which is a case analysis and decode for every Integer
09:33:34 <carbonix> but it gives me overflow..
09:33:34 <mornfall> quicksilver: So only overflows incur actual cost.
09:33:36 <ezyang> carbonix: Note that you could have also done "deriving (Equal)
09:33:42 <quicksilver> mornfall: yes, that's what I'm aiming for
09:33:48 <ezyang> erm, (Eq)
09:34:02 <quicksilver> mornfall: and that cost is negligible compared to the huge cost of a C library call to GMP
09:34:07 <quicksilver> mornfall: so I don't really care about that :)
09:34:09 <carbonix> ezyang: i'll try now
09:34:11 <soupdragon> carbonix, that's odd, are you using infinite trees?
09:34:19 <ezyang> but your impl shouldn't overflow...
09:34:23 <carbonix> soupdragon: no, it's a particular way I have to represent graphs
09:34:48 <carbonix> like a node with a key and "pointers" to neighbors
09:34:48 <soupdragon> by infinite I mean something like  g = NodeType lady [g,a,g,a]
09:35:11 <soupdragon> if you tried to check g == g it would go into an infinite loop (possibly causing a stack overflow)
09:35:12 <mornfall> quicksilver: Sure, once you are in GMP, the battle's been lost long time ago. But you need a non-GMP Integer implementation anyway, or you'd have to branch also *before* each arithmetic otherwise.
09:35:41 <benmachine> quicksilver: even if Integer is 30x slower than Int, couldn't it be argued that in the majority of use cases, that's 0.3% of your runtime instead of 0.01%? :)
09:35:43 <carbonix> soupdragon: I'm not having that situation, just n1 = Node "L" [n2] and n2 = Node "X" [n3] , etc.
09:35:48 <mornfall> Actually, you can't avoid that either.
09:35:59 <soupdragon> when you say etc what exactly is happening beyond n2?
09:36:04 <carbonix> soupdragon: is it normal to get overflow when I do n1 == n2 ?
09:36:12 <carbonix> sorry, n1 == n1
09:36:14 <ezyang> > repeat 1 == repeat 1
09:36:16 <mornfall> Well, you have to re-arrange your arithmetics carefully to lift out the possibly overflown things out of all loops.
09:36:18 <lambdabot>   mueval-core: Time limit exceeded
09:36:24 <ezyang> > repeat 1 == repeat 2
09:36:25 <lambdabot>   False
09:36:28 <monochrom> > "L" == "X"
09:36:29 <lambdabot>   False
09:36:30 <carbonix> soupdragon: I have a dfs on a graph actually, but I get overflow on n1 == n1 , for example
09:36:31 <monochrom> works
09:36:41 <soupdragon> carbonix, yes but you have not answered my question
09:36:45 <monochrom> > "L" == "L"
09:36:45 <ezyang> > let x = repeat 1 in x == x
09:36:45 <lambdabot>   True
09:36:48 <monochrom> Also works.
09:36:49 <lambdabot>   mueval-core: Time limit exceeded
09:36:59 <illissius> if I edit a .conf file for a package, how do i get ghc to pick up the changes?
09:37:15 <carbonix> soupdragon: "when you say etc what exactly is happening beyond n2?" -> I have 5 nodes defined in the same manner
09:37:15 <ddarius> carbonix: Do you handle the Null case?
09:37:47 <carbonix> ddarius: hm, seems not
09:37:47 <monochrom> eww. I see why stack overflow now. :)
09:37:49 <ddarius> mornfall: "overflowed"
09:38:02 <soupdragon> carbonix: are there any loops in the remaining 5 nodes
09:38:17 <mornfall> ddarius: I was about to write overflown. :))
09:38:24 <carbonix> soupdragon: yes, there might loops, not n1 -> n1, but n1 -> n2 -> n3 -> n1, for example
09:38:25 <monochrom> overthrown
09:38:33 <soupdragon> carbonix, that is why!
09:38:35 <mornfall> re-vo-lu-tion!
09:38:47 <soupdragon> carbonix, do you see why that causes an infinite loop?
09:38:58 <mornfall> on-die arbitrary-precision arithmetic for the masses
09:38:59 <carbonix> soupdragon: ok, so xs == ys checks recursively, not only 'superficial'
09:39:06 <illissius> (never mind, got it -- ghc-pkg --recache)
09:39:13 <ddarius> mornfall: You did write "overflown"
09:39:24 <mornfall> Gah!
09:39:25 <carbonix> soupdragon: yes, thanks. the effect I'm actually trying to is just check if the list of adjancecy nodes are equal
09:39:41 <mornfall> ddarius: Bummer. :D
09:39:57 <illissius> mornfall: oh hai thar.
09:40:17 <illissius> a BCoppens too! wtf.
09:40:18 <mornfall> illissius: You ring a bell.
09:40:19 <benmachine> carbonix: but a node *is* a list of adjacency nodes :P
09:40:26 <mornfall> BCoppens: Hey dear. :)
09:41:03 <carbonix> benmachine: true!:), but I believe there has to be way on doing the compare with this implementation, right?
09:41:11 <illissius> mornfall: yeah I hang out in various kde channels. in olden times i even communicated in them
09:41:39 <mornfall> illissius: Yeah, everything was clear the moment you mentioned Bart. :)
09:41:58 <benmachine> carbonix: it's a bit tricky
09:42:01 <soupdragon> carbonix, comparing equality of potentially infinite objects like that is impossible in general
09:42:27 <benmachine> carbonix: there's no way to see whether a data structure is really cyclic or if it's just very very nested
09:42:35 <soupdragon> carbonix, the solution is to give unique names to unique objects and just compare names rather than structure
09:42:39 <benmachine> there is no "pointer equality" as it were
09:42:56 <soupdragon> so then you have  NodeType name _ _ == NodeType name' _ _ = name == name'
09:42:58 <illissius> Saizan: I made it use the llvm 2.7 libs rather than the 2.6 ones, which, for whatever reason, made most of the errors go away -- there's one left: /usr/lib/llvm-2.7/lib/libLLVMScalarOpts.a(Scalar.o): In function `LLVMAddInstructionCombiningPass': (.text+0x524): undefined reference to `llvm::createInstructionCombiningPass()'
09:43:05 <illissius> I guess I'll ask about that one in #llvm.
09:43:23 <carbonix> interesting, I've been able to do this comparison in scheme with some lazy evaluation with delay / force
09:43:38 <soupdragon> carbonix: using EQ?
09:43:43 <carbonix> soupdragon: yes, this is what I've had in the first place
09:44:30 <carbonix> soupdragon: yes, I think with normal eq
09:44:34 <soupdragon> carbonix, you know in scheme how you can have to lists that are EQUAL but they are not EQ
09:45:07 <carbonix> soupdragon: I might be confusing things
09:45:11 <monochrom> eq? usually does pointer equality in your case
09:45:20 <soupdragon> Do you not understand what I just said?
09:45:46 <soupdragon> carbonix, if you compute say (1 2 3 4) in two different ways, in Scheme they might not be EQ but they will always be EQUAL
09:45:59 <benmachine> EQ sounds evil
09:45:59 <soupdragon> (you need to understand this to see why haskell doesn't support this)
09:46:03 <soupdragon> EQ is fine
09:46:11 <ezyang> it's pretty evil, I'll say
09:46:13 <ddarius> (eq? (cons 1 2) (cons 1 2)) is never true.
09:46:20 <monochrom> If you use equal? in scheme, you get the same infinite loop.
09:46:43 <carbonix> ok, I think I somehow see the difference
09:46:49 <soupdragon> There is a good reason for EQ in scheme and not in haskell, I cannot say what the reason is without confusing carbonix though
09:47:48 <ddarius> soupdragon: The reason is simply that you can tell the difference between not eq? things in Scheme.  You can't in Haskell.
09:47:53 <Skrirh> is there someone in here who can help me with c#
09:48:07 <monochrom> we don't know c#
09:48:11 <ddarius> Skrirh: In some C# channel or in the variety of forums on MSDN.
09:48:21 <mreh>  /join #c#
09:48:24 <mreh> hehe
09:48:29 <Skrirh> :p lol okey!
09:48:31 <Skrirh> whaha
09:48:38 <Skrirh> i didnt know
09:48:50 <mreh> is #c# a channel?
09:49:05 <mreh> oh, it redirects
09:49:06 <monochrom> I wonder if it's #c# or ##c# too
09:49:21 <mreh> monchrom, come and see
09:49:26 <bremner> #c#*
09:49:36 <monochrom> redirection is an ingenious invention. don't you wish #haskell redirects to #c# too.
09:49:39 <mreh> I've taken over ##c#
09:49:56 <Skrirh> hi am i now in c# channel?
09:50:15 <mreh> my /whois says "yes"
09:50:39 <mreh> Skrirh, I believe they are in ##csharp
09:50:41 <carbonix> soupdragon: EQUAL has anything to do with equal? and EQ with eq?
09:50:48 <Skrirh> aha, okey!, can someone help me with some progamming, im stuck:P
09:50:51 <Skrirh> ok :P
09:51:01 <aristid> Skrirh: c# is different from haskell ;)
09:51:02 <monochrom> Oh God mreh is evil
09:51:09 <mreh> Skrirh, this is still #haskell
09:51:10 <carbonix> soupdragon: or actually, you're referring to something more conceptual
09:51:23 <Skrirh> shit lol
09:51:25 <mreh> but you're in the channel ##csharp too
09:51:36 <Skrirh> aha!
09:51:50 <mreh> 10 bucks says he get it wrong again
09:52:12 <jlouis> carbonix: since this is #haskell, I'll bash Scheme. Scheme got its typing discipline wrong (dynamic) and as a result, they had to invent multiple forms of equality because you will sometimes need the "other kind"
09:52:32 <mreh> too many parenthesis too
09:52:34 <soupdragon> jlouis, that is not a really well thought out argument actually
09:53:02 <jlouis> soupdragon: if you don't agree with my argument, you are to eat a loaf of bread with two tablespoons of dijon mustard on it
09:53:18 <soupdragon> It's more about referential transparency (which is orthogonal to typing), and writing efficient programs
09:53:34 <carbonix> jlouis: sorry, I'm just a newbie in functional programming in general, didn't want to disturb anyone around.
09:53:51 <soupdragon> try e.g. implementing a WAM in Scheme without it, you'll find it's a completely stupid waste of time
09:53:59 <jlouis> carbonix: you don't. The discussion is fairly interesting actually
09:54:09 * mreh thinks of the pop art "WAM" painting
09:55:20 <triyo> I have a silly question. How do I read out the Integer value out of a (IO Integer)? I wish to pass it onto putStrLn for printing (via show).
09:55:33 <Zao> triyo: x <- or >>=
09:55:48 <aristid> @let nan = (0.0 / 0.0) :: Double
09:55:49 <lambdabot>  Defined.
09:55:55 <aristid> > compare nan nan
09:55:57 <lambdabot>   GT
09:55:57 <monochrom> Let f be your IO Integer thingy. f >>= putStrLn
09:56:02 <Zao> <- in a do block performs the action and binds the result to the LHS name.
09:56:10 <tromp> f >>= print
09:56:12 <triyo> This is the moment where I say, I knew that... to much new stuff in short space of time. :) thx
09:56:14 <Zao> >>= performs an action and passes the value to the action to the right.
09:56:35 <monochrom> You are not right in thinking "how to read out". You are right in thinking "how to pass it on". >>= passes it on.
09:56:35 <aristid> i think compare nan nan should not be GT
09:56:42 <danharaj> To a function that returns an action actually.
09:58:04 <tromp> or you can be verbose and do: i <- f; print i
09:58:18 <mreh> seriously, I own ##c#
09:58:21 <mreh> what now?
09:58:27 <danharaj> do notation IMO should be avoided by a beginner until they get what's going on underneath.
09:58:31 <monochrom> oh woops it's an Integer, should be print instead of putStrLn :)
09:58:42 <Zao> @src print
09:58:43 <lambdabot> print x = putStrLn (show x)
09:58:57 <soupdragon> danharaj, I can't see any reason for - infact it is opposite to the normal way of learning things
09:59:03 <mreh> print = putStrLn . show?
09:59:16 <monochrom> IMO people have too much opinion
09:59:23 <danharaj> soupdragon: what? I'm not sure what you mean.
09:59:25 <osfameron> monochrom++
09:59:41 <zygoloid> triyo: it is important to understand that an IO Integer does not actually have an Integer value 'in' it, in general.
09:59:47 <ezyang> I'm not really sure how to teach people things these days. Maybe throw lots of different angles at them and see what sticks.
10:00:08 <soupdragon> danharaj, we always learned things like how to do long divison before studying the construction of rational numbers from set theory axioms
10:00:14 <zygoloid> triyo: rather, an IO Integer value represents some process which can produce an Integer.
10:00:43 <djahandarie> Stupid people. They should have realize that implanting their memories into robotic brains would be best YEARS ago.
10:01:11 <triyo> zygoloid: thx I read that advice few days ago. It said it represents a computation rather than value if I'm not mistaken
10:01:14 <monochrom> It is actually trivial to introduce both >>= and do at almost the same time. See http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming  It only takes 10 minutes or so.
10:01:21 <mreh> but monads *are* functors
10:01:30 <danharaj> soupdragon: That's not the same situation here. Do is just a rewriting of >>=. It makes you think that foo <- bar actually makes a variable called foo and puts the result of bar in it. That's not what's going on.
10:01:31 <mreh> so why doesn't IO Integer have an Integer in it?
10:02:15 <monochrom> because Schrödinger's box doesn't have a dead cat in it. (nor live cat)
10:02:23 <zygoloid> triyo: yes, that's right. one difference is that, if f :: IO Integer, then: "do x <- f; y <- f; return (x, y)" will perform the 'f' computation/process *twice*, and can return two different integers.
10:03:36 <zygoloid> mreh: it's not that it doesn't have an *Integer* in it, it's that it doesn't have *an* Integer in it. In the same way that 'f :: a -> Integer' doesn't have *an* Integer in it, in general :)
10:03:59 <triyo> zygoloid: I've also seen how lists can behave under these binding circumstances. Very cool I must say.
10:05:24 <djahandarie> monochrom, nothing like clearing up a misunderstanding with a quantum analogy
10:05:54 <jlouis> quantum theory makes everything sane
10:06:05 <arw> quantum analogies are in a mixed state of beeing understood and misunderstood...
10:06:05 <triyo> mixing <- and >>=, is it idiomatic? for exampleI have  .... val <- ref >>= readIORef
10:06:11 <mreh> when people say haskell is my favourite imperative programming language, what part are they talking about? Monads?
10:06:25 <monochrom> plus intuitionistic logic. the box doesn't have a dead cat because you can't prove it's dead.
10:06:43 <jlouis> triyo: I do it all the time
10:06:47 <mreh> if it's a box you can't see into, it must have suffocated
10:06:52 <c_wraith> triyo: yeah, that's fine.  Though it's sometimes more common to mix with =<<, as it functions semi-analogously with $
10:06:57 <djahandarie> Quantum theory adds the "sane" to "insane", but nowhere else.
10:06:58 <jlouis> triyo: I don't know if it is idiomatic though
10:07:24 <danharaj> mreh: Higher order functions and algebraic datatypes make imperative programming really easy.
10:07:35 <Entroacceptor> monochrom: you're wrong, the box actually has both cats in it
10:07:46 <monochrom> interesting!
10:08:01 <mreh> I thought the cat was a probability distribution
10:08:02 <c_wraith> mreh: in addition to danharaj's point, there's also the fact that IO actions are first-class values, and can be passed around, etc, just like any other value
10:08:51 <djahandarie> I thought the cat was a vector in a complex plane!
10:08:57 <triyo> Ok, I have a .... val <- ref >>= readIORef and need to apply show function to it. I was thinking something like this could work instead  ref >>= readIORef >>= show ... however I was meat with a nice error message.
10:09:15 <djahandarie> Was the cat performing a ballet when it was "spinning"?
10:09:28 <ezyang> The cat is imaginary.
10:09:33 <c_wraith> triyo: show's return type isn't Monad m => m a
10:09:39 <danharaj> ref >>= print?
10:09:41 <mreh> I hate that cat
10:09:55 <c_wraith> triyo: which means it can't be used as an argument to >>=
10:10:24 <soupdragon> nk
10:10:50 <triyo> oh of course, thx c_wraith, that makes sense, after checking :type
10:11:58 <triyo> I read somewhere I can apply a pure function with something like liftM I think...would that help.
10:12:31 <c_wraith> yes, it would work.  fmap and <$> do the same thing as liftM
10:13:08 <c_wraith> It's kind of sad we have 3 names for that function.  historical reasons  >_>
10:13:22 <mreh> I made this point before
10:14:54 <triyo> ok good, I see. I think I am making some good progress in learning Haskell. Thanks guys for your support here.
10:15:03 <aristid> c_wraith: fmap is not the same as liftM
10:15:09 <noteed> c_wraith: also map is fmap on list
10:16:07 <c_wraith> aristid: It's the same semantics, and same signature except for a typeclass constraint.  The fact that the constraints are different rarely actually matters.
10:16:32 <aristid> c_wraith: the typeclasses don't have the same instances
10:17:10 <c_wraith> aristid: every monad should have a functor instance such that fmap = liftM
10:17:27 <c_wraith> aristid: the fact that some functors aren't monads means that fmap is a bit more general
10:17:50 <burp> does every monad have to be a functor?
10:18:09 <aristid> c_wraith: there's no guarantee that every monad has in fact a functor instance, but i guess that's pedantic
10:18:14 <c_wraith> burp: it's not required, but semantically monad is a strict superset of the functionality of functor
10:18:22 <burp> ok
10:18:23 <zygoloid> every monad is a functor. but not every Monad instance has a corresponding Functor instance
10:18:44 <aristid> @src liftM
10:18:45 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:19:03 * zygoloid agrees with c_wraith that every Monad instance /should/ have a corresponding Functor instance
10:19:07 <aristid> zygoloid: liftM has the advantage that it is outside of a class
10:19:27 <aristid> @undo do { x1 <- m1; return (f x1) }
10:19:28 <lambdabot> m1 >>= \ x1 -> return (f x1)
10:19:36 <aristid> @pl m1 >>= \ x1 -> return (f x1)
10:19:37 <lambdabot> f `fmap` m1
10:19:40 <aristid> haha :D
10:19:48 <zygoloid> aristid: you still need the Monad instance, so that's not /really/ an advantage :)
10:19:53 <c_wraith> caleskell strikes again!
10:20:06 <zygoloid> c_wraith: just @pl being overly optimistic
10:20:22 <zygoloid> if it were Caleskell it'd write it as f . m1 :)
10:20:28 <c_wraith> oh, good point :)
10:20:37 <aristid> :t (.)
10:20:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:21:05 <aristid> ah, Caleskell
10:21:32 <aristid> :t fail
10:21:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:24:38 <b0fh_ua> Hello! Can somebody please explain what am I doing wrong there -> http://pastebin.com/8qHJdKPU ?
10:26:33 <zygoloid> b0fh_ua: action :: IO (Result String), not ErrorT LJError IO String.
10:27:11 <zygoloid> (except that then you'll get a type error on the session argument to postIt)
10:27:39 <zygoloid> the nice fix is to wrap "authenticate username" and "postIt username session" with the ErrorT constructor
10:28:14 <zygoloid> b0fh_ua: (basically, authenticate and postIt are returning values in the "wrong" monad)
10:28:29 <BMeph> b0fh_ua: Thank you! ;)
10:29:14 <b0fh_ua> zygoloid: well, not sure if I understood what did you mean about "wrong monad". Can you please explain?
10:29:22 <b0fh_ua> BMeph: ?
10:29:42 <redocdam> is dons around
10:29:54 <zygoloid> b0fh_ua: ok. authenticate produes an IO (Result Session). action wants an ErrorT LJError IO Session
10:30:03 <redocdam> lmao
10:30:12 <redocdam> ErrorT LJError
10:30:14 <redocdam> wtf
10:30:39 <redocdam> very descriptive
10:31:23 <redocdam> that was so hideous I refuse to be here
10:33:17 <zygoloid> b0fh_ua: you can use the ErrorT constructor to convert the IO (Result Session) you have to the ErrorT LJError IO Session you want
10:33:18 <BMeph> b0fh_ua: Your example let me use one of my cathphrases here... ;)
10:33:43 <b0fh_ua> aha
10:33:59 <BMeph> b0fh_ua: Namely, "UR DOIN IT RONG!" ;)
10:35:43 <dino-> Is there an arrow equivilent of using liftM and ap together as in: SomeConstructor `liftM` x `ap` y  ?
10:35:58 <b0fh_ua> zygoloid: well, but session seems to be of type "Result Session"
10:35:59 <dino-> I want to say arr is like liftM, from the type
10:36:05 <b0fh_ua> which has to be expanded somehow
10:36:14 <opqdonut> dino-: you can't really "apply" the arrow to anything
10:36:25 <opqdonut> maybe compose it with const y?
10:36:31 <b0fh_ua> I could do something like authenticate username >>= ErrorT . (postIt username)
10:36:42 <opqdonut> arr x <<< const y
10:36:48 <b0fh_ua> but how to easily chain editIt after all?
10:37:13 <dino-> Or constA ?
10:37:30 <dino-> I had better read the types some more.
10:38:03 <paolino> hi there, I have this function which I cannot understand what is wrong http://haskell.pastebin.com/fuRdmyEw. I get *** Exception: Prelude.read: no parse when I try to evaluate the output action
10:38:17 <opqdonut> yeah, err, constA
10:38:21 <zygoloid> b0fh_ua: do session <- ErrorT $ authenticate session; ErrorT $ postIt username session
10:38:31 <dino-> But what I'm trying to avoid is lots of  x <- foo -< j ; y <- bar -< j ; [lots more of this] only to returnA -< SomeConstructor x y ...
10:38:49 <BMeph> b0fh_ua: Your REEEAAALY big problem, is that you're trying to use a Result Session as if it were a Session. You should re-do postIt and editIt, or use a helper function, to break down the functionality more. :)
10:38:54 <Zao> paolino: Sounds like reading fails.
10:39:06 <zygoloid> dino-: it sounds like you want an applicative functor interface rather than an arrow interface
10:39:12 <dino-> Starts to look exactly like the times you should be lifting your constructor into your monad.
10:39:20 <paolino> Zao but it passed the reads test
10:39:25 <Zao> > (read "omg") :: Int
10:39:26 <lambdabot>   *Exception: Prelude.read: no parse
10:39:33 <zygoloid> dino-: fortunately there's the WrappedArrow type in Control.Applicative for exactly that.
10:39:39 <Zao> paolino: And the read on line 12?
10:39:48 <dino-> zygoloid: Ok, will look at that.
10:39:54 <dino-> opqdonut, zygoloid: thanks!
10:40:39 <paolino> Zao: it should be given the same string as the reads in line 4
10:41:08 <paolino> Zao: h1 and h2 are on the same file
10:41:09 <Zao> paolino: I don't have the mental capacity to parse this code tonight.
10:41:15 <Zao> paolino: I defer to the channel.
10:41:31 <Zao> :trace in ghci maybe?
10:42:22 <Zao> Hrm, doesn't seem to do much with exceptions.
10:42:23 <cdsmithus> paolino: Your code will fail with that exception if some prefix of the file can be parsed, but the entire file cannot
10:42:24 <paolino> yes, it looks like hGetContents h2 gives an empty string
10:43:19 <sinelaw> heya all
10:43:20 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
10:43:21 <benmachine> seems GLUT applications segfault on my computer
10:43:25 <benmachine> so I can't play raincat :(
10:43:26 <paolino> cdsmithus: read and reads are so different ?
10:43:38 * paolino tries with reads
10:43:54 <cdsmithus> paolino: reads returns pairs of values and "rest of the string"s.  read only works if the value is the entire string
10:44:30 <cdsmithus> > reads "16s" :: [(Int, String)]
10:44:31 <lambdabot>   [(16,"s")]
10:44:38 <cdsmithus> > read "16s" :: Int
10:44:39 <lambdabot>   *Exception: Prelude.read: no parse
10:44:50 <paolino> ooh
10:45:14 <paolino> thanks cdsmithus, I'd never guessed
10:45:42 <Zao> Any particular reason you just don't use the result of reads?
10:45:56 <cdsmithus> So, you can use (filter ((== "") . snd) (reads ...))
10:46:09 <Zao> And probably testing that there's no rest.
10:47:23 <paolino> Zao:  I hope I have a smaller memory footprint when I scan a directory for files containing a valid value of type a and decide after which to use
10:48:33 <paolino> while retaining the locks so that they cannot be changed
10:49:00 <b0fh_ua> BMeph: looks like you're right
10:49:16 <b0fh_ua> I have to create another function which will invoke postIt and editIt
10:49:29 <b0fh_ua> and take Session as parameter
10:51:50 <ezyang> Oh man, GHC is built!
10:52:34 <b0fh_ua> BMeph, zygoloid : http://pastebin.com/tvvNs3md
10:55:46 <Eelis> the wiki page on data parallel haskell only talks about ghc 6.10.1, and strongly cautions that its support for DPH is still shaky. to what extent has DPH matured in the ghc 6.12 releases? is it still strictly "to give early adopters the opportunity to see where the project is headed and enables them to experiment with simple DPH programs"?
10:56:27 <ezyang> I think the idea is that 6.10 lets you write programs in DPH syntax, but not actually expect performance boosts, and 6.12 actually getting the fusion and other crucial bits down so that you will see performance
10:57:01 <Eelis> great. and what about the "feature-deprived, special-purpose Prelude"? is that still required?
10:57:07 <ezyang> Yes.
10:57:18 <ezyang> You need to marshal data to and from parallel arrays
10:57:26 <Eelis> and "the inability to mix vectorised and non-vectorised code in a single Haskell module" ?
10:57:59 <spacebark> hi im just learning haskell and am having trouble declaring the type of a deterministic finite automata
10:58:01 <ezyang> Dunno about that
10:58:10 <Eelis> ezyang: ok, thanks
10:58:10 <ezyang> spacebark: Pastebin what you have so far
10:58:30 <ezyang> The article on haskellwiki seems to imply so.
10:59:45 <jmcarthur> i think in 6.12 you still can't mix them in the same module
11:00:16 <spacebark> http://pastebin.com/0HZxNijT
11:00:23 <jmcarthur> dph is typically much much faster with ghc head, btw
11:01:05 <Eelis> jmcarthur: ok, i see. since i'm not /that/ eager to be an early-adopter, i think i'll wait for 6.14 then :)
11:01:27 <noteed> spacebark: what don't you like there ?
11:01:33 <spacebark> it doesnt compile
11:01:43 <noteed> spacebark: you can replace the function by a pair
11:01:57 <spacebark> i get a parse error in data/newtype declaration
11:02:02 <spacebark> ont he third line
11:02:05 <pastorn> spacebark: if you use 'data' you need to have a cunstructor
11:02:14 <noteed> spacebark: and since you use the data keyword, you have to provide a data constructor too
11:02:23 <spacebark> ok
11:02:24 <spacebark> so
11:02:25 <pastorn> data DFA = (... ==> data DFA = DFA (...
11:02:42 <noteed> spacebrak: yes
11:02:45 <spacebark> ok
11:02:51 <spacebark> i see
11:02:52 <spacebark> thanks!
11:03:12 <noteed> spacebark: but since you use a proper data type, you can get rid of the tuple
11:03:39 <noteed> data DFA = DFA [State] [Symbol] ((State, Symbol) -> State) State [State]
11:04:07 <spacebark> and so when I would pattern match it in a function
11:04:10 <spacebark> it would be like
11:04:46 <spacebark> DFA (qs, alphabet, delta, start, finals)
11:04:46 <spacebark> ?
11:04:51 <noteed> spacebark: for Show'ing purpose, you can replace (State, Symbol) -> State by [((State,Symbol),State)]
11:04:59 <noteed> spacebark: yes
11:05:11 <pastorn> spacebark: yes, but for this many variables in one construction begs for records
11:05:23 <noteed> or DFA qs alphabet delta start finals if you get rid of the tuple
11:05:43 <pastorn> so that you don't have to do 200 changes later, when you realise that your datatype is missing something/needs changing
11:06:08 <spacebark> what is the syntax for records?
11:06:16 <spacebark> {"something":somthing}?
11:06:37 <noteed> spacebark: data DFA = DFA { dfaQs :: [State], ... }
11:06:41 <pastorn> spacebark: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
11:08:04 <spacebark> ok thanks!
11:08:54 <ezyang> I'm trying to think how I would design a word splitting algorithm in nested data parallelism style
11:09:24 <ezyang> My biggest question is whether or not I should implement chunking, or split the string down to singleton and hope DPH chunks things for me.
11:10:46 <ezyang> And how to efficiently split a data parallel array into two pieces
11:16:50 <pastorn> ezyang: DPH solves the [[a]] thing for you automagically, does it not?
11:17:21 <ezyang> Yes. I'm just a little confused :-)
11:17:49 <ezyang> Namely, say my input is one giant string; I don't really know how to split it into [:[:Word8:]:]
11:18:01 <ezyang> (where string = ByteString.Word8.Strict)
11:20:25 <pastorn> ezyang: divide it in as many sequences as you have CPU cores?
11:20:29 <pastorn> (just guessing)
11:20:55 <ezyang> pastorn: Possible!
11:21:12 <ezyang> Not terribly general, and I assume the division would be sequential, which probably is ok
11:21:34 <ski> spacebark : .. getting the syntax to work ?
11:21:48 <pastorn> ezyang: have you watched that new youtube video on DPH?
11:22:03 <ezyang> Yeah... it's why I'm playing around with this
11:22:03 <pastorn> ezyang: http://www.youtube.com/watch?v=NWSZ4c9yqW8
11:22:26 <pastorn> so what's the program that you're trying to write?
11:22:38 <ezyang> > words "foo bar   baz"
11:22:39 <lambdabot>   ["foo","bar","baz"]
11:22:47 <ezyang> But parallel :-)
11:23:32 <pastorn> so wordsP :: [: Char :] -> [:[: Char :]:] ?
11:23:52 <ezyang> Yeah.
11:24:21 <ezyang> Or even
11:24:27 <pastorn> isn't there a fold function for DPH?
11:24:30 <ezyang> wordsP :: [: Char :] -> [: String :]
11:24:35 <pastorn> which you can use to define it
11:24:43 <ezyang> nope!
11:24:52 <ezyang> well, at least, not one I see
11:24:53 <pastorn> @where dph
11:24:53 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
11:25:50 <ezyang> In particular, you need to decide what kind of shape you're going to fold over the parallel array with
11:26:28 <pastorn> wtf? combineP: http://haskell.org/ghc/docs/6.12-latest/html/libraries/dph-par-0.4.0/src/Data-Array-Parallel-Prelude-Base-PArr.html#combineP
11:26:34 <ezyang> well, that's not really a hard thing
11:26:39 <ezyang> pastorn: I was wondering about that too :-)
11:26:59 <pastorn> const . const
11:27:31 <ski> ap . ap
11:27:53 <pastorn> @type ap . ap
11:27:54 <lambdabot> forall a b a1. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
11:28:02 <ezyang> I believe it interleaves two DP arrays on a boolean mask
11:28:09 <pastorn> ski: that looks an aweful lot like Cont...
11:28:29 <djahandarie> I like how the Monad goes away
11:28:31 <djahandarie> @type ap
11:28:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:29:19 <rajeshsr> is there anyway to find out to which module a function belongs to with lambdabot?
11:29:37 <pastorn> djahandarie: it actually doesn't
11:29:39 <ezyang> though I'm not sure why it's [:Int:] and not [:Boolean:]
11:29:42 <pastorn> ap . ap
11:29:45 <pastorn>   :: (Monad ((->) (a -> a1)), Monad ((->) a)) =>
11:29:47 <pastorn>      (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
11:32:01 <ski> pastorn : i have no idea what it does ..
11:33:00 <ski> @index catMaybes
11:33:00 <lambdabot> Data.Maybe
11:33:05 <ski> rajeshsr : like that ^ ?
11:33:40 <rajeshsr> @index (<$>)
11:33:41 <lambdabot> bzzt
11:33:53 <rajeshsr> @index ($)
11:33:53 <lambdabot> Prelude
11:33:57 <rajeshsr> @index (<$>)
11:33:58 <lambdabot> bzzt
11:34:03 <rajeshsr> ski, think so!
11:34:12 <rajeshsr> why doesn't <$> work?
11:34:18 <ski> hm, apparently it doesn't know about `(<$>)'
11:34:38 <rajeshsr> @index forM_
11:34:39 <lambdabot> bzzt
11:34:42 <ski> @type (Control.Applicative.<$>)
11:34:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:34:57 <ski> @type Control.Monad.forM_
11:34:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
11:35:22 <ski> i'm not really sure which modules `index' knows about .. it's usually worth a try, though
11:36:25 <ski> @hoogle <$>
11:36:26 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:36:33 <ski> ^ one can try `hoogle', as well
11:36:41 <rajeshsr> ski, ha, so hoogle works!
11:36:59 <rajeshsr> @hoogle forM_
11:36:59 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
11:37:00 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
11:38:34 <ski> (there's also this `hayoo' thing, which, reportedly, indexes all of hackage)
11:39:00 <rajeshsr> ski, oh, ok!
11:43:47 <ezyang> I wonder what a lifted parallel array is
11:45:56 * byorgey makes a lifted parallel array soufflé
11:46:04 <fizruk> hi all! i'm looking for a book about haskell (not tutorial) or maybe some related maths to read this summer. can you advise anything?
11:46:23 <ezyang> @whats rwh
11:46:24 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:47:38 <Baughn> @djinn (a -> m (Maybe b)) -> [a] -> m (Maybe b)
11:47:39 <lambdabot> Error: Undefined type []
11:47:55 <olsner> "about Haskell or maybe some related maths" <3
11:48:12 <fizruk> what's with it? )
11:48:47 <byorgey> fizruk: you mean you want to learn Haskell, or you already know it and want to learn more?
11:49:44 <soupdragon> what happens if you get the point where there isn't any more haskell to learn?
11:49:59 <fizruk> phrase "i know haskell" is a little bit strange, but yes, i want to learn more
11:50:15 <zygoloid> soupdragon: i'm sure someone will tell us if it ever happens
11:50:26 <mreh> @google haskell road
11:50:28 <tromp> you're talking about enlightenment, soupdragon?
11:50:28 <lambdabot> http://homepages.cwi.nl/~jve/HR/
11:50:28 <lambdabot> Title: The Haskell Road
11:51:30 <byorgey> fizruk: any particular sorts of maths you are interested in?  what's your mathematical background?
11:53:00 <illissius> soupdragon: you make some
11:53:25 <fizruk> byorgey: i'll be satisfied with any related maths, i think. for example discrete maths or category theory... i want something to make my brains work )
11:53:39 <fizruk> but not to break )))
11:53:50 <byorgey> fizruk: for category theory I've heard great things about Awodey's book
11:53:54 <byorgey> although I haven't read it myself
11:54:33 <rajeshsr> byorgey, what would you recommend for mathematically inclined people for haskell? Mine is just some understanding of Logic. Am interested in exploring such concepts as Theorem Proving, Type theory and more logic. I don't have any formal knowledge of those though!
11:55:29 <byorgey> I also recommend Graham, Knuth and Patashnik's "Concrete Mathematics" to anyone, it is a fantastic book
11:56:14 <fizruk> i'm student and on next course there should be category theory course in our university
11:56:41 <fizruk> so i think it'll be good to read something introducing to it or something related
11:56:51 <byorgey> rajeshsr: one fun place to start might be with the Software Foundations online textbook: http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
11:56:56 <danharaj> Pierce's Types and Programming Languages.
11:57:07 <byorgey> also what danharaj said.
11:57:37 <aristid> :t (.)
11:57:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:57:41 <aristid> scnr :D
11:57:48 <rajeshsr> byorgey, i tried to read Concrete maths! It wasn't so easy i would say, but reading it like a novel was amusing! :)
11:57:50 <danharaj> If you're used to mathematics (real math, with proofs and whatnot), Pierce's book can be digested in very short time.
11:57:53 <aristid> @src (.)
11:57:54 <lambdabot> (f . g) x = f (g x)
11:58:04 <aristid> lambdabot: you are inconsistent with yourself.
11:58:13 <byorgey> rajeshsr: indeed, it is definitely not easy!
11:58:28 <byorgey> it is brain-expanding though, and very well written
11:58:41 <byorgey> the kind of book you can read through five times and learn new things each time
11:59:05 <aristid> Cale: the type of (.) is not compatible with its @src :)
11:59:16 <rajeshsr> byorgey, yes, just 1 page is worth more than 1 hour of wisdom. Knuth always rocks.
11:59:59 * hackagebot haddock 2.6.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.6.1 (DavidWaern)
12:00:49 <rajeshsr> byorgey, i have always been wondering what it takes to understand Knuth's books. For intellectual salvation we need to understand what the GOD (Knuth) says! :)
12:01:52 <c_wraith> what's changed in the new haddock?
12:02:03 <danharaj> Everythiiing.
12:02:25 <c_wraith> noooo
12:03:54 <aristid> rajeshsr: doesn't knuth use imperative languages?
12:04:20 <rajeshsr> aristid, he did i guess! :) In what language was TeX originally written?
12:04:25 <tensorpudding> Knuth was a fan of Pascal.
12:04:37 <tensorpudding> TeX is written in WEB, which is a literate variant of Pascal.
12:04:55 <rajeshsr> tensorpudding, oh, ok! thanks
12:05:30 <tensorpudding> Of course he wrote TeX back at a time when Pascal was considered a relatively high-level language.
12:05:59 <Apocalisp> I was a fan of Pascal at the time. A slight improvement over C.
12:06:05 <rajeshsr> tensorpudding, well, he didn't consider Lisp then, which does show his inclination for imperative programming..
12:06:05 <aristid> rajeshsr: doesn't he use MMIX or so in his books?
12:06:19 <rajeshsr> aristid, that is just an abstract machine
12:06:21 * soupdragon wants to do something, maybe program in haskell -- but has been struggling to come up with any ideas for the last week
12:06:31 <aristid> rajeshsr: it's an imperative abstract machine :)
12:06:33 <rajeshsr> of course, not that abstract! :)
12:06:46 <noteed> soupdragon: did you consider haskell_proposals on reddit ?
12:06:54 <aristid> rajeshsr: btw., lisp is somewhat imperative too
12:06:58 <rajeshsr> is there anything called Functional Abstract Machine?!
12:07:16 <rajeshsr> aristid, yep, but FP isn't totally impossible.
12:07:41 <rajeshsr> Am inspired by its simplistic beauty and consistent syntax!
12:07:41 <noteed> soupdragon: or contribute to a project (e.g. by looking at what is hosted on github)
12:07:44 <tensorpudding> You can't blame Knuth for not choosing Lisp; Lisp was too slow and didn't run on many machines in the 1970's.
12:07:45 <ezyang> "sumP = GHC.PArr.sumP" o rly
12:08:14 <aristid> ezyang: for real.
12:08:24 <ezyang> no wai
12:08:55 <mun_> is first-order logic an application of lambda calculus?
12:08:56 <soupdragon> no I don't see anything there I like
12:09:16 <rajeshsr> tensorpudding, hmm! But I have never heard of Knuth being an avid Lisper or a FP guy. He stresses mainly on the foundations of CS.
12:09:44 <tensorpudding> Knuth started out programming in the days when assembler was the only way.
12:09:45 <ezyang> So, question for DPH devs: is there currently ways to define our own operators like sumP or prodP?
12:09:50 <noteed> soupdragon: on hackage or github too? what kind of stuff do you like?
12:09:52 <wli> Knuth is more of an asm guy.
12:10:05 <wli> MIX asm etc.
12:10:13 <soupdragon> noteed, I don't really know right  nwo :( that's my problem
12:10:29 <rajeshsr> tensorpudding, oh, well what i meant is he mainly works on langage agnostic or paradigm agnostic stuffs and makes really awesome things on that!
12:10:33 <fizruk> wli: he is GOD, it was already mentioned )
12:11:04 <wli> fizruk: LR parsing?
12:11:25 <fizruk> wli: what?
12:11:41 <wli> fizruk: He's "god" because of his work on LR parsing?
12:11:41 <rajeshsr> fizruk, to LR parse what he said?! ;)
12:11:44 <thoughtpolice> ezyang: I think you can define further functions in terms of things like sumP/prodP naturally, but I remember having some discussions with RL on g-h-u a while back, and GHC seems to internally wire the built in vector primitives directly to the optimizer/vectorizer pass so I don't know if you can add new trivial operators like sumP easily
12:11:56 <fizruk> rajeshsr: no )
12:12:07 <tensorpudding> I remember reading Dijkstra lambasting Lisp in one of his 80's interviews.
12:12:09 <thoughtpolice> ezyang: I remember making GHC's vectoriser pass panic a good number of times on fairly simple variations of the same thing
12:12:45 <mreh> Dijkstra prefered imperative languages over functional ones if I'm not mistaken
12:12:49 <thoughtpolice> (this was 6.10.1, 6.12 & 6.13 are probably far better in this respect)
12:12:50 <ezyang> thoughtpolice: Oof, ok.
12:13:02 <tensorpudding> Though I am to believe that he was a fan of Haskell in the 90's
12:13:08 <mreh> woo
12:13:19 <ezyang> thoughtpolice: So, I should stick to looking at strictly numeric programs to parallelize
12:13:20 <rajeshsr> tensorpudding, ha, i will be interested to see that interview. Am not convinced about why Lisp isn't a good language to code!
12:13:43 <tensorpudding> He was mostly referring to his experience with Lisp in the 60's at that interview.
12:13:47 <tensorpudding> Specifically, LISP 1.5
12:13:55 <mreh> Lisp has no type system, right?
12:14:04 <tensorpudding> It has dynamic typing.
12:14:05 <rajeshsr> mreh, yeah
12:14:06 <mreh> or am I conflating Lisp with Scheme
12:14:14 <ski> Scheme is a Lisp
12:14:15 <rryan> I'm having some trouble compiling the 2010.1.0.0 haskell platform on Ubuntu Lucid 10.4 amd64. http://pastebin.com/e5k2hJYK Has anybody else has similar troubles? I have ghc6 installed from the lucid repositories, and can import Control.Monad fine.
12:14:21 <benmachine> wasn't dijkstra basically a giant troll
12:14:25 <tensorpudding> It does have predicates which test type.
12:14:42 <ezyang> fol fol fol del rol
12:14:50 <benmachine> I don't mean to suggest he wasn't also a genius but :P
12:14:52 <soupdragon> mreh, there is lots of type inference in something like SBCL - the language is untyped but that doesn't mean you wont get compile time errors about wrong programs in a mature implementation
12:15:02 <tensorpudding> Dijkstra is most known for his complaining at how other people are doing it wrong, and that CS was dying.
12:15:06 * ski hands ezyang three first-order logics on a plate
12:15:08 <mreh> scheme has ?boy, right?
12:15:25 <ski> mreh : sorry ?
12:15:29 <tensorpudding> Also, for his gorgeous handwritten essays.
12:15:35 <mreh> predicates for checking types
12:15:45 <Saizan> rryan: you've to install libghc6-base-prof or something like that
12:15:49 <mreh> if my memory serves me correctly
12:15:53 <tensorpudding> And he co-wrote the first compiler for Pascal.
12:15:55 <ski> (maybe you're thinking of `null?',`pair?',`symbol?',&c. ?)
12:16:10 <thoughtpolice> ezyang: so that 'sumP = GHC.PArr.sumP' looks like a regular definition, but it has an internal special meaning to the compiler/optimizer. I seem to remember being able to trivially expand some definitions and get the vectorizer to freak out, but like I said this was just when 6.10 was released, so a year or so ago
12:16:15 <thoughtpolice> ezyang: probably, yeah
12:16:17 <tensorpudding> Scheme has null?, CL has nullp
12:16:21 <mreh> ski: quite possibly
12:16:24 <thoughtpolice> ezyang: like I said that was a long time ago, you may want to ask g-h-u to be sure
12:16:30 <rajeshsr> tensorpudding, Dijkstra is famous for whining about one thing or the other! :)
12:16:51 <ezyang> thoughtpolice: Ok.
12:16:58 <thoughtpolice> they are much more up to date w.r.t to the Repa/DPH work
12:17:00 <soupdragon> actually CL has NULL
12:17:03 <tensorpudding> He was an academic for most of his days, though he wrote code too.
12:17:12 * thoughtpolice is still slightly confused by the umbrella-project that is data parallel haskell these days
12:17:15 <fizruk> i'm choosing a book for a summer: "Concrete Mathematics" (Graham, Knuth, and Patashnik) or "Category Theory" (Steve Awodey) ?
12:17:15 <soupdragon> but predicates are usually called stuff like DIGIT-CHAR-P
12:17:39 <tensorpudding> Concrete Mathematics is a quirky read.
12:17:54 <mreh> is like counting with beans
12:18:02 <rajeshsr> fizruk, be cautioned about Concrete Maths! You may get a bit of everything, but not completely to do it all within this summer!
12:18:02 <thoughtpolice> previously, DPH = awesome syntactic sugar for nested data parallelism. now there's vector for fast flat arrays, and Repa which is automatically parallel, but seems to piggy back on the already existing GHC-DPH implementation (notably in the examples I see conversions to/from repa arrays and dph-prim-par arrays)
12:18:03 <mreh> is that like counting with beans
12:18:07 <fizruk> tensorpudding: some people said it can be read many times
12:18:08 <thoughtpolice> the whole thing is very confusing to me at this point
12:18:12 <tensorpudding> Awodey's Category Theory book is kinda sparse.
12:18:14 * thoughtpolice cries
12:18:42 <tensorpudding> It's one of the more easily readable to computer scientists, I suppose.
12:19:12 <seeg> hello
12:19:27 <seeg> i found a nice implementation of euler's totient function, it's very quick
12:19:28 <seeg> http://pastebin.com/GAu4T7Lh
12:19:30 <fizruk> tensorpudding: what do you mean by "sparse"?
12:19:36 <seeg> could someone tell me how to implement it in haskell?
12:19:47 <tensorpudding> It doesn't cover a lot of material compared to other books.
12:19:48 <jmcarthur> opposite of dense?
12:20:23 <fizruk> tensorpudding: can you advise some alternative?
12:20:24 <rryan> Saizan : thanks that worked
12:20:39 <tensorpudding> I've not read so many.
12:20:41 <rajeshsr> tensorpudding, well, what would be the pre-requisite for Concrete Mathematics, if you have a not so bad Discrete Maths and Calculus. I do find it too stretching at times. For instance I never mastered its summation lesson which is overwhelming with a lot of wonderful techniques. I am just using it as a reference these days. I would like to digest it completely, but never know why am not able to!
12:20:56 <tensorpudding> It's definitely better than Mac Lane though
12:21:36 <tensorpudding> Nothing wrong with Awodey, just that you might want a supplement.
12:22:08 <tensorpudding> Concrete Mathematics doesn't really need pre-reqs except for patience.
12:22:34 <ezyang> thoughtpolice: Thanks for your help. I'd nearly forgotten about Repa
12:22:46 <ezyang> tensorpudding: What would you recommend as a supplement?
12:23:02 <soupdragon> seeg, if you use a mutable array you can translate that code line for line
12:23:08 <tensorpudding> I've been reading that paper by Fokkinga
12:23:14 <cdsmithus> rajeshsr: You should be fine with Concrete Mathematics.  It's really written for someone with, maybe, an undergraduate discrete math course, and some general experience in mathematical thinking.
12:23:16 <fizruk> tensorpudding: i suppose, both books are worth reading, what should be the first?
12:23:59 <tensorpudding> They aren't really comparable.
12:24:57 <tensorpudding> I suppose you could do either.
12:25:00 <rajeshsr> cdsmithus, hmm, yeah i do satisfy both the requirements! :) But as tensorpudding may be it takes more patience. It is really frustrating if you stay in a chapter for a loong time, so i tend to take up a novel-reading approach which i don't think is good for this.
12:27:08 <tensorpudding> Fokkinga's Gentle Introduction is a good supplement if you want to use Category Theory with Haskell.
12:27:35 <rajeshsr> a general question to people who worked through Concrete Maths: Do you solve exercise problems? how long does it take to complete a chapter on the average?
12:27:36 <tensorpudding> It's got an unusual notation though.
12:27:51 * soupdragon starts reading Fokkinga
12:28:41 <tensorpudding> Despite being called Gentle, it's a harder read than Awodey.
12:28:42 <fizruk> tensorpudding: thank's a lot, i think, i'll try dive into category theory this summer )
12:29:09 * soupdragon thinks calling things "Gentle Introduction .." is a CS in-joke
12:29:47 <fizruk> tensorpudding: are there any serious prerequisites nedeed to read normally these books?
12:30:08 <tensorpudding> Ability to reason abstractly is critical.
12:30:23 <fizruk> :)
12:30:41 <tensorpudding> I'm a math person primarily, so I kinned well to category theory, but if you aren't good at math it will be challenging.
12:30:44 <wli> tensorpudding: Category theory... 'nuff said.
12:31:25 <tensorpudding> Having a background in abstract algebra would be necessary to read Mac Lane's book, but Awodey doesn't rely on you being familiar with algebra.
12:31:36 <danharaj> Mac Lane's book requires a great deal of mathematical maturity.
12:31:50 <byorgey> that is an understatement.
12:32:06 <danharaj> It really is "for the working mathematician."
12:32:08 <fizruk> tensorpudding: awodey >> fokkinga ?
12:32:32 <soupdragon> what is Mac Lane's book
12:32:43 <soupdragon> Categories for the working mathematician?
12:32:52 <danharaj> Cats4Mats
12:32:53 <tensorpudding> Awodey's easier, slower, longer but more mathematical and less CS
12:33:12 <fizruk> mmm
12:33:43 <byorgey> soupdragon: yes
12:34:07 <seeg> how to code a function that takes elements from some list until some element is repeated in this list?
12:34:19 <seeg> i.e. for [1, 2, 3, 4, 1, ...] it would return [1, 2, 3, 4]
12:34:25 <fizruk> tensorpudding: for easy summer reading awodey is likely to be better that fokking )
12:34:47 <ezyang> Math is never easy...
12:34:49 <mauke> seeg: that looks like a rather inefficient operation
12:34:52 <tensorpudding> If you are new to abstract mathematics, Awodey will not be impossible but it'd be good to take it slow.
12:35:30 <seeg> mauke, well, i want to count the elements in a list until some element is repeated
12:35:50 <mauke> why?
12:35:51 <tensorpudding> The price of admission of Mac Lane is that you should probably understand what the introduction is talking about.
12:35:55 <seeg> actually, the goal is to find length of cycles in sequences
12:36:02 <soupdragon> > let append [] elt = Just [elt] ; append (x:xs) elt | x == elt = Nothing | otherwise = liftM (x:) (append xs) elt in scanl append [] [1,2,3,4,1]
12:36:02 <lambdabot>   Couldn't match expected type `[t]'
12:36:03 <lambdabot>         against inferred type `Data.Mayb...
12:36:16 * hackagebot haskore 0.1.0.4 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.1.0.4 (HenningThielemann)
12:39:33 <rajeshsr> seeg, what problem is that?
12:39:47 <seeg> that's project euler problem 74
12:40:02 <rajeshsr> hmm, ok
12:40:04 <seeg> i try the naive way, if it goes slow then i'll think more about it
12:40:21 <rajeshsr> findIndex from Data.List may help you..
12:41:23 <byorgey> seeg: try using a scanl to build up cumulative Sets, and stop when the Set doesn't get larger
12:42:42 <rajeshsr> byorgey, a list of sets you mean?!
12:42:58 <byorgey> sure.
12:43:10 <byorgey> but because of laziness and sharing it won't be that bad.
12:43:18 <rajeshsr> byorgey, hmm, ok!
12:43:21 <byorgey> most of the sets in the list will share a lot of structure
12:43:26 <rajeshsr> yep
12:43:35 <byorgey> and the sets past the point where the first repeat happens will never actually be constructed
12:44:40 <byorgey> this is exactly the kind of wholemeal thinking that is enabled by laziness + sharing.  just run a data structure through a pipeline of transformations, and don't worry about it being huge or infinite or whatever.
12:45:04 <Baughn> > let f foo@~(Just 2) = foo in f Nothing
12:45:05 <lambdabot>   <no location info>: Parse error in pattern
12:45:06 <rajeshsr> byorgey, hmm, ok
12:45:10 <Baughn> > let f ~foo@(Just 2) = foo in f Nothing
12:45:11 <lambdabot>   *Exception: <interactive>:1:141-161: Irrefutable pattern failed for pattern...
12:45:55 <byorgey> so in this case, first use a scanl to create the list of all cumulative Sets at each point in the list
12:48:32 <seeg> byorgey, i don't know how to do it...
12:49:08 <Twey> > let f foo@(~(Just 2)) = foo in f Nothing
12:49:09 <lambdabot>   Nothing
12:49:38 <Twey> Baughn: ↑
12:49:39 <pkrumins> is there a deparse for haskell in lambdabot?
12:49:51 <Twey> A dep arse?
12:50:00 <Baughn> Twey: Ooh
12:50:01 <pkrumins> Yes.
12:51:43 <geheimdienst> > let a = [1,2,3,4,1] in map snd $ takeWhile (\(index, value) -> value `notElem` take index a) $ zip [0..] a
12:51:44 <lambdabot>   [1,2,3,4]
12:52:10 <pkrumins> So is there a deparse? (like Perl's deparse)
12:52:14 <geheimdienst> do you think this is any good, guys?
12:52:25 <Twey> pkrumins: What is a deparse?
12:53:08 <geheimdienst> pkumins, you mean a decompiler? disassembler?
12:53:12 <pkrumins> it would show how haskell sees expressions based on precendece
12:53:28 <soupdragon> no there is no such thing
12:53:32 <pkrumins> like `case lookup action of` as `case (lookup action) of`
12:53:46 <rajeshsr> >let primes n = p:primes (div n  p) where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n/2]
12:53:48 <Twey> pkrumins: I think you want to try the core dump from GHC
12:53:53 <pkrumins> or `f g x` as `(f g) x`
12:53:57 <rajeshsr> >primes 10
12:54:04 <rajeshsr> > primes 10
12:54:06 <lambdabot>   Not in scope: `primes'
12:54:08 <pkrumins> Twey: why would I want a core dump?
12:54:11 <Twey> But you won't get the former… brackets are no less special than case … of, so there's no reason it would insert them
12:54:12 <rajeshsr> > let primes n = p:primes (div n  p) where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n/2]
12:54:13 <lambdabot>   not an expression: `let primes n = p:primes (div n  p) where p = head.dropW...
12:54:20 <Twey> pkrumins: GHC core, that is, not program core :þ
12:54:35 <pkrumins> :)
12:54:49 <Twey> pkrumins: It's the subset of Haskell used to represent stuff internally… so no infix operators or any of that sugar.
12:55:25 <pkrumins> That seems to be too much of trouble to use. I'll just move along.
12:56:11 <Twey> geheimdienst: Hmm
12:56:54 <Twey> > inits [1, 2, 3, 4, 1]
12:56:55 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,1]]
12:57:01 <rajeshsr> @src mod
12:57:01 <lambdabot> Source not found. My mind is going. I can feel it.
12:57:07 <soupdragon> > inits [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,1]]
12:57:07 <lambdabot>   <no location info>: lexical error at character '\SI'
12:57:09 <rajeshsr> @src rem
12:57:09 <lambdabot> Source not found. That's something I cannot allow to happen.
12:57:15 <soupdragon> -_-
12:57:47 <rajeshsr> > let primes n = p:primes (div n  p) where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n/2]
12:57:48 <lambdabot>   not an expression: `let primes n = p:primes (div n  p) where p = head.dropW...
12:58:05 <rajeshsr> what is wrong with that?
12:58:16 <soupdragon> @let primes n = p:primes (div n  p) where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n/2]
12:58:16 <lambdabot>  Defined.
12:58:17 <soupdragon> > primes
12:58:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:58:18 <lambdabot>    `Test.SmallCheck.Serial ...
12:58:36 <Twey> > let a = [1, 2, 3, 4, 1] in map snd . takeWhile (uncurry $ flip notElem) $ inits a `zip` a
12:58:37 <lambdabot>   [1,2,3,4]
12:59:54 <rajeshsr> soupdragon, oh, ok!
13:00:08 <rajeshsr> but it doesn't evaluate as seen above..
13:00:12 <rajeshsr> > primes 10
13:00:13 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:00:13 <lambdabot>    `GHC.Real.Integral t'
13:00:13 <lambdabot>   ...
13:00:29 <rajeshsr> what is that really mean?
13:00:47 <geheimdienst> > let a = [1, 2, 3, 4, 1] in map fst . takeWhile (uncurry notElem) $ a `zip` inits a
13:00:48 <lambdabot>   [1,2,3,4]
13:00:54 <geheimdienst> wow twey, not bad
13:01:17 <stepcut> my cabal package includes an example file, demo.hs. Should I list that as extra-source-files, or is something more appropriate ?
13:01:52 <rajeshsr> @let cycle_len x:xs = findIndex (==x) xs + 1
13:01:52 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "cycle_len"))
13:02:00 <rajeshsr> @let cycle_len (x:xs) = findIndex (==x) xs + 1
13:02:02 <lambdabot>  <local>:7:40:
13:02:02 <lambdabot>      No instance for (Num (Maybe Int))
13:02:02 <lambdabot>        arising from the...
13:02:10 <Twey> > let f = map snd . takeWhile (uncurry $ flip notElem) . join (zip . inits) in f [1, 2, 3, 4, 1]
13:02:11 <lambdabot>   [1,2,3,4]
13:03:41 <zygoloid> @undef
13:03:56 <zygoloid> @let primes n = p:primes (div n  p) where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n `div` 2]
13:03:57 <lambdabot>  Defined.
13:04:04 <zygoloid> > primes 10
13:04:05 <lambdabot>   [2,*Exception: Prelude.head: empty list
13:04:25 * hackagebot happstack-hamlet 0.2.1 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-0.2.1 (JeremyShaw)
13:04:47 * geheimdienst enjoys simplifying code he doesn't really understand ;-)
13:05:09 <zygoloid> rajeshsr: there are no standard types with which you can use both div and (/)
13:06:12 <ski> @type let cycleLen (x:xs) = fmap (+ 1) (findIndex (==x) xs) in cycleLen  -- rajeshsr
13:06:13 <lambdabot> forall a. (Eq a) => [a] -> Maybe Int
13:06:36 <rajeshsr> zygoloid, ha that n/2 was the culprit!
13:06:41 <rajeshsr> ski, cool!!
13:07:10 <seeg> that's funny, all the 60-element chains from this problem end at 1454
13:07:18 <seeg> then they start to repeat themselves
13:07:22 <Twey> geheimdienst: Hehe
13:07:25 <Twey> geheimdienst: Try to expand it
13:07:34 <Twey> A step at a time
13:07:38 <Twey> It gets easier with practice
13:07:59 <ski> > let cycleLen (x:xs) = fmap (+ 1) (findIndex (==x) xs) in cycleLen []
13:08:00 <lambdabot>   *Exception: <interactive>:1:141-189: Non-exhaustive patterns in function cy...
13:08:32 <rajeshsr> > let cycleLen (x:xs) = fmap (+ 1) (findIndex (==x) xs) in cycleLen [1,2,3,1]
13:08:33 <lambdabot>   Just 3
13:08:45 <geheimdienst> twey, woah, what is that join that you used? i hoogled, but that finds only Control.Monad.join, which can't be right
13:09:02 <rajeshsr> BTW, so how to make my prime factorization work in ghci?
13:09:03 <ski> > let cycleLen xs0 = do x:xs <- return xs0; i <- findIndex (==x) xs; return (i+1) in cycleLen []
13:09:04 <lambdabot>   Nothing
13:09:07 <Twey> geheimdienst: It is
13:09:11 <Twey> :t join
13:09:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:09:15 <BMeph> > primes 11
13:09:18 <lambdabot>   [*Exception: Prelude.head: empty list
13:09:53 <Twey> When m = (-> b), join :: (a -> a -> b) -> (a -> b)
13:10:13 <ski> > let cycleLen xs0 = listToMaybe [ i + 1 | x:xs <- [xs0] , i <- findIndices (==x) xs] in cycleLen []
13:10:14 <lambdabot>   Nothing
13:10:16 <Twey> So it basically just produces a function that supplies the given argument twice
13:10:22 <Twey> > join (+) 2
13:10:23 <lambdabot>   4
13:10:27 <Twey> > join (*) 3
13:10:28 <lambdabot>   9
13:10:31 <Twey> &c.
13:10:46 <ski> Twey : s/(-> b)/(a ->)/
13:11:10 <geheimdienst> unbelievable :-o
13:11:27 <Twey> ski: I got a little confused by that one, to be honest
13:11:37 <ski> > join f x :: Expr
13:11:38 <lambdabot>   f x x
13:11:44 <Twey> That's cute
13:11:53 * geheimdienst thinks any sufficiently advanced monad wranglery is indistinguishable from magic
13:12:01 <Twey> :t join `asTypeIn` \j -> j (+)
13:12:03 <lambdabot> forall a. (Num a) => (a -> a -> a) -> a -> a
13:12:19 <cdsmithus> geheimdienst: The ((->) r) monad certainly is surprising when you first see it.  But not magic really.
13:12:20 <Twey> That's a bit misleading thanks to the type of (+), I guess
13:12:30 <rajeshsr> @let primes n = if n /= 1 then p:primes(div n  p) else [] where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n]
13:12:31 <lambdabot>  <local>:1:0:
13:12:31 <lambdabot>      Warning: Pattern match(es) are overlapped
13:12:31 <lambdabot>               In...
13:12:37 <ski> the (raw) environment monad is not magic .. just possibly overused in #haskell sometimes, though ..
13:12:39 <rajeshsr> > primes 10
13:12:40 <lambdabot>   [2,*Exception: Prelude.head: empty list
13:12:58 <geheimdienst> what do i need to import to get this to work in ghci? control.monad is not enough
13:13:20 <Twey> geheimdienst: Control.Monad.Instances
13:13:39 <geheimdienst> thanks
13:13:39 <Twey> Contains the Monad instance for functions
13:14:09 <Twey> ski: Oh, now that makes more sense.  Thanks.  :þ
13:14:24 <rajeshsr> the code seem to work locally. I don't get that warning firstly..
13:14:32 <rajeshsr> so what is happening?
13:15:41 <ski> rajeshsr : i think the definition of `primes' zygoloid provided above is still in lambdabot's system (and that takes precedence over your later definition)
13:15:54 <rajeshsr> oh
13:16:00 <rajeshsr> @undef primes
13:16:22 <ski> (basically, this is a definition like `f x = ..x..' followed by another `f x = ..x..'; the first one will always be used)
13:16:32 <rajeshsr> @unlet primes
13:16:32 <lambdabot>   Parse error: SemiColon
13:16:54 <seeg> well, i computed it, but it took 5 minutes
13:17:10 <geheimdienst> rajeshsr, why not try this? let primes = ... in primes 10
13:17:13 <seeg> probably some guys did it in 0.1 secs with assembler or somethign :D
13:17:17 <rajeshsr> so what is the command to undefine primes?
13:17:35 <rajeshsr> > let primes n = if n /= 1 then p:primes(div n  p) else [] where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n] in primes 10
13:17:36 <lambdabot>   [2,5]
13:17:42 <rajeshsr> > let primes n = if n /= 1 then p:primes(div n  p) else [] where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n] in primes 177
13:17:42 <mauke> @undefine
13:17:52 <lambdabot>   [3,59]
13:17:55 <ski> rajeshsr : `undefine' undefines all the locally defined things .. and your `undef' call above already spell-corrected to it
13:18:42 <rajeshsr> ski, oh, so it doesn't just undefine only my function primes?
13:18:53 <geheimdienst> seeg probably they spent 30 mins of programmer time to save 5 mins of cpu time ... silly :-)
13:19:49 <Twey> So what is ‘unlet’ for?
13:20:00 <seeg> geheimdienst, yeah, but with the trick with the totient function computation was brilliant
13:20:06 <ski> rajeshsr : that's right. there's currently no way to undefine individual definitions or equations
13:20:12 <BMeph> > let primes n = if n /= 1 then p:primes(div n  p) else [] where p = head.dropWhile (\x -> n `mod` x /= 0) $ [2..n] in primes 11
13:20:12 <benmachine> @help unlet
13:20:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:20:13 <lambdabot>   [11]
13:20:15 <ski> Twey : i'm not sure it is even a valid command
13:20:18 <Twey> @unlet let fibs = 0 : 1 : zip fibs (tail fibs) in fibs
13:20:18 <lambdabot>   Parse error: KW_Let
13:20:28 <seeg> my haskell program ran about 30 mins with memoizing, while this clever program ran for couple of secs in python
13:20:30 <rajeshsr> ski, how your function: let cycleLen xs0 = do x:xs <- return xs0; i <- findIndex (==x) xs; return (i+1) in cycleLen [] works with empty list? you seem to take x:xs..
13:20:33 <Twey> ski: It throws a nice Haskelly parse error
13:20:42 <Twey> So presumably it takes Haskell code of some kind
13:20:44 <ski> (probably, `unlet' spell corrected to some other command, $DEITY knows what)
13:20:51 <Twey> Huh
13:20:55 <benmachine> @unlit blah
13:20:55 <lambdabot> Unknown command, try @list
13:21:03 <benmachine> @anlet blah
13:21:03 <Twey> I thought maybe it converted stuff to lambdas and fix
13:21:03 <lambdabot>   Parse error: SemiColon
13:21:07 <benmachine> hmmmm
13:21:11 <ski> @let primes
13:21:11 <lambdabot>   Parse error: SemiColon
13:21:30 <ski> probably `let', i think
13:21:40 <Twey> @unlet foo = "bar"
13:21:41 <lambdabot>  Defined.
13:21:45 <Twey> I guess so.
13:21:49 <Twey> How dull.  :þ
13:21:53 <benmachine> hah
13:21:55 <ski> rajeshsr : the when the `x:xs <- return xs0' command fails in the `Maybe' monad, `Nothing' is returned
13:21:58 <benmachine> > foo
13:22:00 <lambdabot>   "bar"
13:23:08 <rajeshsr> ski, may be writing it with "no do" notation, that is with =<< etc. can give me some idea. What is lambdabot command to do it?
13:23:29 <ski> (rajeshsr : in the list monad, it would work as well, except the empty list is returned as well .. the list comprehension version above is similar)
13:24:01 <ski> @undo do x <- m; y <- f x; z <- g x y; h x y z
13:24:01 <lambdabot> m >>= \ x -> f x >>= \ y -> g x y >>= \ z -> h x y z
13:24:19 <ski> @undo do x:xs <- m; f x xs
13:24:19 <lambdabot> m >>= \ a -> case a of { x : xs -> f x xs; _ -> fail ""}
13:24:39 <rajeshsr> @undo do x:xs <- return xs0; i <- findIndex (==x) xs; return (i+1
13:24:39 <lambdabot> Unbalanced parentheses
13:24:43 <rajeshsr> @undo do x:xs <- return xs0; i <- findIndex (==x) xs; return (i+1)
13:24:43 <lambdabot> return xs0 >>= \ a -> case a of { x : xs -> findIndex (== x) xs >>= \ i -> return (i + 1); _ -> fail ""}
13:25:34 <Twey> > do { [x] <- []; return x } :: Maybe Int
13:25:35 <lambdabot>   Couldn't match expected type `[a]'
13:25:35 <lambdabot>         against inferred type `Data.Mayb...
13:25:37 <ski> @src Maybe fail
13:25:37 <lambdabot> fail _      = Nothing
13:25:41 <ski> @src [] fail
13:25:41 <lambdabot> fail _      = []
13:25:41 <Twey> D'oh
13:25:47 <BMeph> > let cycleLen xs0 = listToMaybe [ i + 1 | x:xs <- [xs0] , i <- findIndices (==x) xs] in cycleLen [3..9]
13:25:48 <lambdabot>   Nothing
13:25:51 <Twey> > do { Just x <- Nothing; return x } :: Maybe Int
13:25:52 <lambdabot>   Nothing
13:26:22 <ski> do { x <- Nothing; return x } :: Maybe Int
13:26:25 <ski> > do { x <- Nothing; return x } :: Maybe Int
13:26:25 <lambdabot>   Nothing
13:26:28 <benmachine> > do { Just 3 <- Just 4; return 3 } :: Maybe Int
13:26:31 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
13:26:31 <lambdabot>    arising from the lite...
13:26:35 <benmachine> oh
13:26:37 <benmachine> yeah
13:26:40 <ski> > do { 3 <- Just 4; return 3 } :: Maybe Int
13:26:40 <benmachine> > do { 3 <- Just 4; return 3 } :: Maybe Int
13:26:41 <lambdabot>   Nothing
13:26:41 <lambdabot>   Nothing
13:26:48 <sshc> How do I find where the "Prelude.read: no parse" exception is being thrown?
13:26:59 <ski> (where `Just' can be replaced by `return')
13:27:00 <benmachine> sshc: excise all uses of the read function from your code >_>
13:27:07 <rajeshsr> k, bye everyone! Got to sleep, late night here.
13:27:15 <ski> rajeshsr : night
13:27:15 <rajeshsr> Thanks for all your help.
13:27:19 <rajeshsr> Good night
13:27:26 <rajeshsr> ski, good night!
13:30:00 <sshc> benmachine: Is there any way I can debug this?
13:30:30 <benmachine> sshc: possibly, but hard-to-debug errors is most of the reason "read" isn't used
13:30:38 <seeg> ok, time to go
13:30:42 <seeg> thanks everyone
13:30:48 <seeg> good night
13:30:52 <benmachine> good ngith
13:30:53 <benmachine> er
13:30:55 <benmachine> close enough
13:32:51 <geheimdienst> > read "5" :: Int
13:32:52 <lambdabot>   5
13:32:56 <geheimdienst> > read "abc" :: Int
13:32:57 <lambdabot>   *Exception: Prelude.read: no parse
13:33:22 <geheimdienst> sshc, that means, you need to look at the places where you call read and at the input you feed it
13:34:06 <sshc> geheimdienst: I already know what causes the exception to be thrown.
13:41:43 <aristid> i somehow always get a shock when i see a "geheimdienst" on my screen.
13:42:25 <mauke> well, as long as it's not "gestapo"
13:43:57 <BMeph> "'geheimdienst' ist nicht geheime." ;þ
13:46:10 <geheimdienst> bmeph, that would make a very good lolcat
13:47:16 <BMeph> geheimdienst: Especially with the "pancake bunny" picture! :D
13:48:49 * ski listens to "Ich bin errdiener" ..
13:49:27 <mauke> a what?
13:49:48 <tromp> ein was?
13:51:33 <BMeph> Verdiener, etwa? ;)
13:52:04 <Zao> What's the female form of gartenzwerge?
13:52:06 <Zao> Is there one?
13:52:34 <Amadiro> I don't think "zwerg" (dwarf) has a female form.
13:53:00 <kmc> Was ist das Bullshit?
13:53:19 <Zao> Haskell types need genuses.
13:54:27 <mauke> why, Gartenzwergin of course
13:54:29 <arw> there is "zwergin" as a female form, so it would be "gartenzwerginnen".
13:54:55 <kmc> garden dwarf inside?
13:55:31 <geheimdienst> well if it's inside it wouldn't be in the garden, duh
13:55:33 <geheimdienst> ;-)
13:55:47 <arw> there is the "wintergarten"...
13:58:09 <Twey> 21:25:09 < Twey> > do { [x] <- []; return x } :: Maybe Int
13:58:14 <Twey> This would be nice to have
13:58:27 <Twey> Failable matching of arbitrary patterns
13:58:53 <soupdragon> why have you written [] rather than Nothing?
13:58:57 <ski> the problem here is that `[]' doesn't have type `Maybe a' for any `a'
13:59:02 <aavogt> this exists, other than the implicit conversion from [] -> Maybe
13:59:07 <soupdragon> is [] meant as a general notation for monoid zero
13:59:36 <ski> > do { x <- return []; return x } :: Maybe Int
13:59:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:59:37 <lambdabot>         against inferred type ...
13:59:43 <ski> er, meep
13:59:46 <ski> > do { [x] <- return []; return x } :: Maybe Int
13:59:47 <lambdabot>   Nothing
14:00:26 <ski> so, we already have "Failable matching of arbitrary patterns", in the `Maybe' (as well as in the list) monad
14:00:51 <Twey> Oh
14:00:52 <Twey> Right
14:00:54 <Twey> Heh
14:01:23 <kmc> > [ x | [x] <- return [] ]
14:01:24 <lambdabot>   []
14:01:37 <ski> (arguably, this ought to require `MonadZero', though)
14:02:56 <triyo> anyone have any example code snippets that demonstrates usage of Data.IORef pls?
14:03:27 <ski> what do you want to use it for ?
14:03:54 <kmc> triyo, it's very simple.  you create, read, and write mutable cells, all as IO actions
14:04:01 <kmc> the types say almost everything you need to know
14:04:10 <kmc> i can put together a simple little example though
14:05:56 <triyo> kmc: I'm put up my snippet of very basic attempt to demonstrate usage.
14:06:16 <ski> triyo : where ?
14:06:19 <kmc> triyo, here's an example http://codepad.org/eBmNEAEv
14:06:30 <triyo> Part I get stuck on id after write, how to use readIORef to get update state
14:07:20 <triyo> kmc: that explains it all, thx for the example.
14:07:32 <shajen> hi
14:07:41 <shajen> can somebody look at this http://pastebin.com/RmgmMGRG
14:07:50 <shajen> and tell me where is the problem
14:08:11 <kmc> shajen, start by telling us what the problem is
14:08:19 <Zao> Depends on what the ... ^
14:08:22 <mauke> compare d 0 == EQ better written as d == 0
14:08:39 <kmc> shajen, Two (Double,Double) is an unnecessary layer of wrapping.  should probably be Two Double Double
14:08:52 <shajen> ok i try
14:09:00 <Zao> shajen: As you return a Roots, you need to return one of the values of Roots.
14:09:15 <Zao> shajen: Your bare values and tuples are not valid values of Roots.
14:09:20 <shajen> but i hav eproblem in 4:28
14:09:28 <Zao> (9001) is not (One 9001)
14:09:39 <shajen> so what should be return
14:09:45 <noteed> shajen: e.g. -b/2*a is a Double, not a Root
14:10:00 <mauke> compare d 0 == GT better written as d > 0
14:10:23 <shajen> mauke: ok but my techer tell that we have to use this ;]
14:10:31 <mauke> shajen: One (-b / (2 * a))
14:10:33 <Cale> mauke: Or as a case expression on compare
14:10:38 <shajen> noteed: ok so what should i write
14:10:42 <shajen> aaa
14:11:48 <kmc> triyo, http://codepad.org/0QZ2uBxx here's a more involved example which uses IORef to make a little mutable "object"
14:12:00 <shajen> ok its working
14:12:05 <kmc> note that the user code doesn't need to use the IORef functions.  that's hidden by closure over free variable
14:12:45 <shajen> can you see at ex 2
14:12:46 <shajen> http://www.speedyshare.com/files/22375381/lista10.pdf
14:13:01 <shajen> exacly on          Is it better than the previ-
14:13:02 <shajen> ous one?
14:13:06 <triyo> kmc: noted, thanks
14:13:44 <kmc> i am impressed by the two-column bilingual problem set
14:15:05 <Cale> shajen: An advantage is that through the use of the Roots type it is more specific about what possible numbers of roots the equation might have.
14:15:28 <Cale> (After all, a list could have any number of elements)
14:16:32 <Cale> A disadvantage is that there are not many functions which operate on the Roots type (at least not yet), while there are a lot of handy functions for manipulating lists.
14:16:47 <shajen> hm
14:17:38 <ddarius> Maybe (Either a (a,a))
14:17:48 <shajen> Cale: o but which func is faster?
14:17:49 <kmc> yikes
14:18:16 <Cale> shajen: I wouldn't expect there to be too significant a difference in performance.
14:19:07 <shajen> ok
14:19:09 <shajen> thanks
14:19:13 <Cale> shajen: At least, they're probably both fast enough that you'd have trouble telling.
14:19:29 <shajen> but which i better i mean good looking ;]
14:20:59 <triyo> kmc: could you do me a favor please. I have added my code snippet of my IORef learning example. Its far more overcomplicated than your good examples. Just curious to know why the Result prints 2 when it should print 4 since square function result is mutated to a new value.
14:21:03 <triyo> http://codepad.org/msAn9wjs
14:21:49 <Cale> triyo: What is that liftIO doing there?
14:22:18 <c_wraith> @instances MonadIO
14:22:19 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
14:22:24 <Cale> triyo: You seem to be running the ref action more than once.
14:22:34 <c_wraith> IO is an instance of MonadIO!  You can call liftIO as much as you like! :)
14:22:43 <Cale> Yes, I know, but it's pointless :)
14:22:51 <Cale> triyo: You defined this ref action which creates a new IORef
14:22:56 <c_wraith> Well.  I never claimed it wasn't ;)
14:23:54 <Cale> triyo: And you run it once with  ref >>= flip writeIORef (square 2), but you throw away the IORef in the process there, and it's gone forever.
14:24:15 <triyo> hmm thats the part I dont understand.
14:24:16 <Cale> So that IORef is garbage collected, and then in the next line, you have:
14:24:32 <Cale> val <- ref >>= readIORef, which makes you a new IORef and then reads from it
14:24:41 * triyo is wandering if he should call it a night :(
14:24:43 <Cale> ref is not an IORef here.
14:25:02 <Cale> It's an IO action which makes a new IORef initialised to (read (args !! 0))
14:25:18 <ski>   val <- readIORef =<< ref  -- please ?
14:25:39 <triyo> of I see, so ref is not actually the ref as I intended
14:25:41 <Cale> That's the least of our concerns for the moment ;)
14:25:43 <EvanR-work> cool, gnu ld is taking 500M
14:25:49 <EvanR-work> the server has... 500M
14:25:49 <stepcut> how can I add -fno-warn-unused-bind with out breaking my package on GHC 6.10 ?
14:25:50 <Cale> triyo: yes
14:26:07 <Cale> triyo: You said   let ref = ... some IO action ...
14:26:21 <Cale> triyo: Which defines ref to be the same action as what is on the right there.
14:26:44 <Cale> Let's start simplifying this program...
14:27:05 <triyo> ok I'm all eyes and ears :)
14:27:32 <Cale> initVal is just another name for newIORef as you've defined it, so let's make that replacement
14:28:27 <Cale> Let's get rid of the liftIO (which does nothing in this context), and instead of defining the action 'ref', we'll do what you intended and run it.
14:28:35 <Cale> ref <- newIORef $ read (args !! 0)
14:28:50 <triyo> ok,
14:29:02 <Cale> The rest is going to have to change, as now ref is an IORef, and not an IO action.
14:29:12 <Cale> writeIORef ref (square 2)
14:29:31 <triyo> quick question. Why is liftIO pointless in that context. Just trying to get a good understanding of this pls
14:29:35 <Cale> val <- readIORef ref
14:30:09 <Cale> triyo: liftIO's job is to take an IO action, and turn it into an action in some monad which is built up over IO.
14:30:31 <Cale> (usually some *different* monad, but it's the identity function when that's just the IO monad again)
14:30:49 <Cale> So it adds whatever structure is necessary in that new monad.
14:31:29 <Cale> If you're not working with monad transformers, you don't need liftIO
14:32:09 <triyo> ok so liftIO usefulness only really shows up when dealing with MT
14:32:13 <Cale> http://codepad.org/Fn9HmTBL
14:32:18 <Cale> yeah
14:32:27 <triyo> ok got it.
14:33:20 <Cale> The other thing which is rather important to be mindful of is the difference between an IO action, and its result.
14:33:42 <Cale> A value of type (IO t) is like a description of something which could be done to produce a value of type t.
14:33:48 * jmcarthur wishes there was no need for liftIO
14:33:54 <kmc> i usually call them "recipes"
14:34:27 <tromp> eg. the difference between a launchMissiles action and world war III
14:34:41 <Cale> Normal Haskell evaluation will never cause the instructions described by the value of type (IO t) to be carried out.
14:35:01 <Cale> (any more than opening the source code to a program in a text editor would cause it to run)
14:35:11 <jmcarthur> (in the absense of certain unsafe functions never to be named in the presence of a newbie)  ;)
14:35:13 <tromp> can Haskell cause World War III?
14:35:26 <Cale> Instead, execution of IO actions is a separate process.
14:35:27 <tromp> or was that with @can?
14:35:36 <voker57> @faq can Haskell cause World War III?
14:35:37 <lambdabot> The answer is: Yes! Haskell can do that.
14:35:38 <jmcarthur> tromp: @faq
14:36:33 <geheimdienst> @faq can Haskell not launch missiles and not cause WW3?
14:36:33 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:36 <Cale> Using do-notation, you can build up more complicated IO actions from simpler ones. The notation v <- x means that when the action described by this do-block is executed, to execute the action x, and name its result v
14:36:49 <Cale> triyo: clear enough?
14:38:12 <triyo> Cale: much better. Thank you
14:38:36 <geheimdienst> cale, couldn't it be said that running a haskell program is the execution of that one big honking IO monad?
14:38:46 <kmc> yes
14:38:52 <kmc> if by "monad" you mean "action"
14:38:57 <kmc> the thing called a "monad" is the type named "IO" itself
14:39:03 <Cale> geheimdienst: It's the interleaved processes of evaluation of expressions into values, and the execution of IO actions
14:39:04 <kmc> and other such types like Maybe, [], etc.
14:39:27 <Cale> Evaluation has no side effects (normally)
14:39:29 <geheimdienst> yeah that's what i mean, action
14:39:29 <ddarius> "type constructor(s)"
14:39:50 <Cale> But it is obviously just as important.
14:40:01 <ElMarsh> hi, isn't it true that Haskell code does not consist of any statements?
14:40:16 <Cale> ElMarsh: That's questionable, but what is a statement?
14:40:39 <ski> "I'm a teapot, short and stout." is a statement
14:40:44 <ddarius> There is a sytactic class for statements, though the only non-trivial thing it contains is x <- m.
14:40:48 <Cale> ElMarsh: The Haskell Report names the parts of do-blocks statements.
14:40:51 <ElMarsh> right, I don't mean logic statements
14:40:58 <ElMarsh> I mean affecting the computer's current state.. et c
14:41:30 <jmcarthur> it is true and untrue
14:41:39 <Cale> ElMarsh: There's something akin to statements as part of do-notation, but it's just syntactic sugar for more expressions.
14:41:41 <jmcarthur> as with most hearsay ;)
14:42:05 <ElMarsh> jmcarthur, could you explain?
14:42:31 <Cale> It's not a terribly meaningful question to ask whether a programming language has statements.
14:43:07 <Cale> We can write things such as:
14:43:08 <ElMarsh> also, when you do something like let a = 2 in a*2, does the computer not have to store 2 in some part of its memory for the symbol a?
14:43:19 <Cale> main = do x <- getLine; putStrLn x
14:43:20 <ElMarsh> or have it linked
14:43:37 <jmcarthur> on the one hand, you can use a haskell program to manipulate the "real world," but on the other hand the language itself treats such things as opaque objects having no effect themselves
14:43:38 <Cale> and the "x <- getLine" and "putStrLn x" are called "statements"
14:43:42 <ddarius> ElMarsh: No, it doesn't.
14:43:42 <kmc> ElMarsh, actions in the IO monad can very much affect the state
14:43:57 <ddarius> ElMarsh: In fact, it very likely won't.  It will just optimize that to 4.
14:44:06 * hackagebot cil 0.0.0 - An interface to CIL and ACSL through Frama-C.  http://hackage.haskell.org/package/cil-0.0.0 (TomHawkins)
14:44:26 <ddarius> Cale: What's your opinion of the Command Query separation?
14:44:31 <kmc> ElMarsh, Haskell can do mutable variables, file IO, network IO, control robots, etc.
14:44:35 <Cale> ddarius: ?
14:44:46 <Cale> ddarius: My opinion is that I've never heard of it
14:44:57 <ElMarsh> ddarius, I was curious about that.. how does Haskell evaluate this? let a = 2 in a*2 does it not have to "remember" that a has the value of 2 so that where ever it sees a you can "plug in" 2?
14:45:04 <jmcarthur> ElMarsh: referential transparency is a big part of haskell, and it means that you can take any expression and replace it with its result without changing program semantics, so it's important to be very careful about how you use things with side effects
14:45:06 * hackagebot synthesizer-core 0.3.0.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.3.0.1 (HenningThielemann)
14:45:24 <Cale> ElMarsh: Once that expression begins evaluating, perhaps
14:45:33 <ezyang> jmcarthur: Be careful, I got into an argument with ddarius about what referential transparency actually is!
14:45:50 <Cale> ElMarsh: Consider something more interesting, like  let a = 1 + 1 in a * a
14:46:04 <kmc> ElMarsh, in general a "let" binding *might* introduce a location in memory for that symbol, but it might be clever enough to resolve it all at compile time
14:46:15 <kmc> if you write let a = 2 in a*3 then expect to get only 6 in your code
14:46:42 <Cale> ElMarsh: This will result in an expression graph in memory which has a node for (*) with two pointers pointing to an expression 'a' which consists of a node (+) and two pointers pointing to copies of 1
14:47:16 <kmc> ElMarsh, an important property of Haskell is that *evaluation* has no side effects, so we can always substitute "equals for equals"
14:47:17 <Cale> Of course, I'm talking about a completely unoptimised abstraction, and kmc is talking about properly optimised code :)
14:47:32 <kmc> note that this doesn't mean that Haskell has no effects on the real world
14:47:40 <kmc> it means that we handle them through a mechanism other than evaluation
14:47:41 * geheimdienst thinks haskell programs can be completely evaluated at compile time, except for those things that depend on i/o
14:47:47 <mreh> is there musicXML support in haskore yet?
14:48:02 <kmc> geheimdienst, have you seen the supercompiler work by e.g. ndm?
14:48:13 <ElMarsh> right , I equals for equals kind of thing lets us see the program in a more "mathematical" way
14:48:17 <ddarius> ezyang: The "argument" was about what referential transparency implied.  I provided a definition which matches what jmcarthur said.
14:48:22 <jmcarthur> geheimdienst: but what does evaluation even mean when you say something like that?
14:48:46 <Cale> geheimdienst: You could do a lot, but the compilers tend not to do that, especially because it sucks when your compiler gets stuck in an infinite loop, and you don't know if it's a bug in your compiler or a bug in your program.
14:49:17 <ezyang> ddarius: Hmm, I guess he did say something different from what I tried to say.
14:49:21 <Philippa> geheimdienst: in the absence of IO, there's nothing to evaluate :-)
14:49:34 <temoto> Does anyone with good understanding on Restricted Boltzmann Machine (recurrent neural network with stochastic binary neurons) have a spare minutes?
14:49:35 <Cale> There could be stuff to evaluate
14:49:43 <Axman6> i dunno, constants can be evaluated (even complex ones)
14:49:44 <ElMarsh> Cale, I see what you're talking about. So  at some point the program will perhaps have to link an expression for some symbol right? I was under the impression that this kind of thing was not done in Haskell (although I was a bit confused about hearing that..)
14:49:44 <Cale> The program might look like  main = print foo
14:49:47 <soupdragon> hi Philippa
14:49:52 <Cale> where foo is some constant expression
14:50:03 <Cale> and might take 8 years to compute :)
14:50:06 <kmc> ElMarsh, it sounds like you're talking about implementation issues
14:50:07 <Philippa> soupdragon: reusing old nicks now?
14:50:11 <soupdragon> yes
14:50:16 <ddarius> Cale: Sounds like beginner code.
14:50:16 <ezyang> ddarius: Quick question: what is it called when you can take the result (not the body) of an expression and replace that with the expression w/o causing changes in semantics?
14:50:25 <Cale> ddarius: hehe
14:50:27 <kmc> "Haskell" is an abstract, standardized language and doesn't make guarantees about precisely how memory is used, etc.
14:50:54 <Cale> ElMarsh: I'm not sure what you mean...
14:50:57 <Liskni_si> is there any other way to make GHC spit the current source location that using that assert trick that loch does?
14:51:02 <geheimdienst> jmcarthur, well, write 2*2 in the source and get back 4. going from 2*2 to 4 is evaluation ...
14:51:04 <ddarius> ezyang: I don't know what you mean by "body"
14:51:09 <ezyang> ddarius: For example, foo (2+2) is the same as foo 4
14:51:14 <Liskni_si> *than
14:51:24 <Cale> ElMarsh: In memory at runtime, there are essentially graphs representing expressions, and they are transformed and updated according to evaluation.
14:51:43 <ezyang> or if I have multiplyTwo x = x * 2, foo (multiplyTo 5) is the same as foo 10
14:51:46 <Cale> ElMarsh: I have an example lying around from a little while ago...
14:51:48 <geheimdienst> philippa, yes, IO turned out to be more important than the designers of haskell originally anticipated </ducks>
14:51:57 <ezyang> (no guarantees about foo (5 * 2) though
14:52:04 <Cale> http://cale.yi.org/share/fib.png
14:52:30 <ElMarsh> right, this is just an expression tree yes?
14:52:56 <Cale> This shows one particular implementation of the fibonacci sequence (not a particularly good one), and the graphs which happen in memory as the expression (fib 0 1 3) is evaluated
14:53:09 * hackagebot DrIFT-cabalized 2.2.3.2 - Program to derive type class instances  http://hackage.haskell.org/package/DrIFT-cabalized-2.2.3.2 (GwernBranwen)
14:53:13 <ElMarsh> but if you had a = 3 somewhere then it would have to remember that a is 3, and so something had to have been done in the memory. I was reading about functional languages versus "von neumann languages"
14:53:13 <Cale> (at least, in my approximate mental-model abstract machine)
14:53:32 <ddarius> ezyang: I doubt that has any name.  Either multiplyTwo 5 = 5 * 2 = 10 or they are all non-equal.  It would be odd to say multiplyTwo 5 /= 5 * 2 but does equal 10.
14:53:54 <ElMarsh> and it said that haskell is not an "imperative language" like those other languages are
14:54:02 <kmc> ElMarsh, Haskell *is* an imperative language
14:54:05 <Cale> ElMarsh: The program in question here looks like   fib a b 0 = a;  fib a b n = fib b (a+b) (n-1)
14:54:05 <kmc> it's also a functional language
14:54:06 <ezyang> well, for example, in an impure language foo(getRandom()) would be different from foo(23)
14:54:09 <ElMarsh> oh
14:54:16 <kmc> ElMarsh, lots of people are confused about this
14:54:27 <ezyang> I was thinking about this and I think this is what I was confusing referential transparency with.
14:54:33 <kmc> Haskell supports imperative programming.  it supports it so well that we give it its own type
14:54:35 <Cale> ElMarsh: To the extent that you can do imperative programming in it, Haskell is an imperative language.
14:54:40 <soupdragon> f()+f() might be odd
14:54:45 <ElMarsh> ah because the book I was reading told me that it was a fully descriptive language.. when saying let a = 3 in a + 3 looks clearly imperative somehow
14:54:45 <jmcarthur> geheimdienst: sure, but i'm not sure where to say "evaluation" happens between compile time and run time, sometimes
14:55:07 <Cale> ElMarsh: It's important to realise that when you write  let a = 1 + 1 in foo
14:55:10 <kmc> ElMarsh, "let" is not imperative.  it's just a way to give a name to an expression, as a shorthand for using it later
14:55:16 <Cale> ElMarsh: It doesn't necessarily evaluate a at all
14:55:16 <kmc> (and to introduce sharing of the work of evaluation)
14:55:47 <Cale> ElMarsh: Also, let allows recursion:
14:55:51 <ElMarsh> ah right, is that about "lazy evaluation"  (  I haven't read that part yet )
14:55:54 <kmc> ElMarsh, Haskell is a functional language.  functions compute data of various types.  one of the many data types we can compute is "sequence of steps affecting the outside world".  and there's also a mechanism to actually perform those steps, once computed.  in that sense, Haskell is also an imperative language
14:55:58 <triyo> Ok coming to a topic of "Monad transformers".  I'm trying to understand the usefulness of it. Could someone give me some basic pointers around understanding MT.
14:56:00 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
14:56:01 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
14:56:13 <Cale> ^^ This defines two infinite lists.
14:56:22 <geheimdienst> jmcarthur, i would say part of evaluation can be done at compile-time, the rest has to be done at run-time. a guy once told me that a compiler is more or less doing partial evaluation on the program source, i found that quite true
14:56:26 <ElMarsh> kmc, but isn't it potentially imperative? when the computer has to remember that the symbol a stands for 3 or something
14:56:27 <Cale> There's no way that we could really evaluate all of the value 'evens'
14:56:39 <kmc> ElMarsh, this usage of "let" has nothing to do with imperative
14:56:45 <Cale> ElMarsh: Also note that the value 'a' is a *constant*
14:56:55 <cdsmithus> ElMarsh: Yes, that's lazy evaluation.  But you can't separate lazy evaluation completely from these ideas.  Lazy evaluation is part of why we can say that "let" doesn't do anything, but rather just introduces a name.
14:57:00 <kmc> ElMarsh, how much Haskell do you know?
14:57:01 <Cale> ElMarsh: It will not change ever as long as it remains in scope.
14:57:27 <ElMarsh> I just started; and Cale I understand that they are constants, like if you let x = 3 in a mathematical proof
14:57:39 <kmc> yes, they're much like "let" in maths
14:57:44 <Cale> ElMarsh: Right
14:58:04 <kmc> ElMarsh, it seems that your idea of "imperative" is "uses memory"
14:58:08 <kmc> which is not what the word means
14:58:08 <ElMarsh> maybe I have a misconception of the definition of "imperative"
14:58:11 <ElMarsh> right
14:58:19 <ElMarsh> what would be a better definition?
14:58:24 <kmc> an "imperative program" is a program defined as a sequence of steps to be carried out in order
14:58:37 <cdsmithus> And in math, if you "let x = the number of hooves on the nearest pink unicorn", then x is undefined... but if you never rely on the value of x in your proof, then the proof is still correct.
14:58:40 <kmc> which affect program state and possibly the state of external things, i.e. input/output devices
14:59:03 <geheimdienst> triyo, i looked at http://en.wikibooks.org/wiki/Haskell/Monad_transformers
14:59:07 <kmc> ElMarsh, it's important to note that the *semantics* of Haskell don't say anything about using memory to store "a" there.  it's only an implementation detail
14:59:24 <geheimdienst> after looking at it i was less confused than before
14:59:33 <ezyang> In fact, Haskell probably won't even compute a until you use it somewhere else
14:59:34 <kmc> Haskell doesn't provide a way to talk about memory directly, until you import certain modules like the foreign interface to the C language
14:59:38 <geheimdienst> (which is more than can be said about many monad tutorials ...)
15:00:04 <ElMarsh> hm. I thought that an "imperative" line of code is something that affects the computer's current state and such
15:00:07 <triyo> geheimdienst: thanks for the link
15:00:08 <kmc> yes
15:00:11 <kmc> but "let" doesn't alter state
15:00:20 <kmc> in the sense that there's not a "before" and an "after"
15:00:26 <kmc> you're just defining notation.  saying what "a" means in the body of the let
15:00:37 <Cale> ElMarsh: single lines of code aren't so much imperative as entire programs
15:00:38 <kmc> it's not as though there was a time in your program execution where "a" ddn't mean that
15:00:39 <ElMarsh> ah, so when we "create" something in the memory, it is not considered "altering"?
15:00:58 <Cale> ElMarsh: Yeah, it's important to point out that when we talk about what the computer will do in response to some bit of Haskell code, we're talking about particular implementation -- maybe one that doesn't even really exist.
15:01:05 <cdsmithus> ElMarsh: You might not be creating something in memory.  For some particular GHC version, perhaps you are.  The next one, maybe not.
15:01:23 <Cale> ElMarsh: There are a lot of ways to imagine implementing the language, and they all have different time and memory characteristics.
15:01:34 <Cale> ElMarsh: It's up to the compiler writers how this stuff really happens.
15:01:42 <cdsmithus> ElMarsh: So, what we really mean is do something in a way that you can observe from within your program.
15:01:47 <Cale> (and the simplifier :)
15:01:54 <kmc> ElMarsh, if i'm writing a maths proof, and i say "Let z be the complex number 3 + 4i"
15:02:07 <kmc> did someone allocate memory and write two integers into it?
15:02:07 <ElMarsh> yes
15:02:11 <cdsmithus> ElMarsh: A let statement does *not* do anything you can observer from within the program.  Whether it affects the contents of your RAM is irrelevant
15:02:12 <kmc> no, it's just a definition
15:02:17 <aristid> @src .
15:02:17 <lambdabot> (f . g) x = f (g x)
15:02:22 <aristid> :t (.)
15:02:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:02:28 <kmc> if i wrote a *program* to interpret math proofs, it might allocate memory, but that's an implementation fact, not a property of maths
15:02:30 <aristid> Cale: this bugs me
15:02:30 <Cale> :t (Prelude..)
15:02:31 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:02:32 <Axman6> >_____________<
15:02:40 <kmc> hi Axman6
15:02:50 <Axman6> aristid: me too, and Cale refuses to fix it
15:02:54 <Cale> aristid: Would you like me to update the @src text file?
15:03:01 <aristid> Cale: yeah
15:03:04 <ElMarsh> hm
15:03:18 <Axman6> update the (.) definition! >_<
15:03:20 <aristid> (.) = fmap
15:03:25 <kmc> ElMarsh, but i think you've picked up on an interesting and non-obvious fact which is that, under the hood, in the implementation used by GHC, a Haskell program does tons of mutating memory
15:03:34 <ElMarsh> that's interesting, so abstractly Haskell is not imperative. But when you have to implement the ideas it will end up at least a bit imperative?
15:03:46 <kmc> every time you evaluate an expression, it overwrites itself with the value it got
15:03:48 <ezyang> Eventually.
15:03:51 <kmc> so that a future evaluation won't redo the work
15:03:52 <Cale> @src (.)
15:03:53 <lambdabot> (f . g) x = f (g x)
15:03:54 <Cale> hmm
15:03:59 <ezyang> The same way eventually it's just pushing electromagnetic pulses around silicon.
15:03:59 <cdsmithus> ElMarsh: Machine code is imperative... so yes, ultimately you end up with imperative code
15:04:01 <geheimdienst> elmarsh, if you ask me, the central thing about imperative programming is that the statements are ordered: first do this, then that. first print this, then read something, etc.
15:04:01 <Cale> perhaps it only reloads the file on a restart
15:04:04 <Axman6> ElMarsh: our computers are imperative, so yes, it has to
15:04:04 <kmc> ElMarsh, yes.  at least, if you want an efficient implementation
15:04:10 <Cale> @flush
15:04:34 <kmc> ElMarsh, but it's also not true that "abstractly Haskell is not imperative", because there are *specific* data types and functions in Haskell for executing sequences of steps
15:04:34 <Cale> @src (.)
15:04:42 <lambdabot> (f . g) x = f (g x)
15:04:48 <lambdabot> NB: In lambdabot,  (.) = fmap
15:04:50 <Axman6> good lambdabot
15:04:59 <benmachine> @src (++)
15:05:01 <Axman6> bad lambdabot!
15:05:06 <lambdabot> []     ++ ys = ys
15:05:12 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:05:15 <Cale> benmachine: Ah, now you're making more work for me
15:05:22 <lambdabot> Plugin `source' failed with: thread killed
15:05:24 <Cale> heh
15:05:26 <benmachine> sry :P
15:05:29 <kmc> nota bene
15:05:35 <ElMarsh> okay, I guess I will have to keep that in mind, I just started learning Haskell ( literally )
15:05:52 <kmc> ElMarsh, cool.  it's a lot of fun to learn
15:05:53 <Axman6> Cale: what's wrong with having C.. and C.++ for all your nonsense?
15:05:55 <ElMarsh> I think my understanding has improved a lot though, thanks guys
15:05:56 <kmc> and we're always here to help
15:05:57 <temoto> ElMarsh, there's actually effort on making a hardware Haskell implementation and it's successful to some extent. That thing is not "imperative even at some level".
15:06:04 <Axman6> its a perfectly reasonable thing to ask
15:06:20 <Cale> Well, our computers are imperative in the sense that the instruction sets they describe consist of imperative instructions. At a lower level, I would say that things are quite declarative :)
15:06:28 <ElMarsh> will that not be a von neumann machine?
15:06:30 <kmc> i think it's easy to get hung up early on labels, which will be easier to understand once you  know more of the language itself
15:06:32 <Twey> Axman6: Hahaha, C.++
15:06:33 <kmc> ElMarsh, yeah
15:06:45 <kmc> it'd be very different from a von neumann machine
15:06:52 <Axman6> Twey: super OO C++ :P
15:07:13 <kmc> OO and C++ don't belong in the same sentence ;P
15:07:26 <Cale> Haskell programs would run much better on a machine whose memory and CPU are physically mixed together into a single substrate
15:07:46 <ddarius> kmc: C++ contains a perfectly reasonable OO sublanguage.
15:07:50 <cdsmithus> Whoa!  I just suddenly realized that (.) really IS fmap!
15:07:53 <Axman6> Cale: memristors could make that happen
15:07:55 <Cale> The process of evaluation, carried out in a naive way, is *extremely* memory bandwidth intensive.
15:08:00 <aristid> Axman6: i wanted to say that!
15:08:00 <Cale> Axman6: I agree :)
15:08:03 <aristid> Axman6: i hate you
15:08:07 <Cale> I was about to say it too :)
15:08:08 <pastorn> Cale: what machines like that are there?
15:08:10 <ezyang> cdsmithus: congrats :-)
15:08:17 <aristid> :D
15:08:22 <geheimdienst> i wouldn't see words like imperative and functional as hard-and-fast categories. it's more like the language designers placing a little more emphasis on this aspect or that
15:08:25 <Axman6> Cale: good! now add C.. and C.++ and we can be frienda again :0
15:08:27 <Axman6> ;)*
15:08:33 <kmc> ddarius, a OO sublanguage where adding private members requires your client code to be recompiled?
15:08:38 <aristid> cdsmithus: just (.) in the Prelude has a more restrictive type :)
15:08:40 <Cale> Axman6: I could *add* those things if you really want them ;)
15:08:56 <kmc> or do you mean the "OO sublanguage" where everything is a pointer to a declared-but-not-defined C struct?
15:08:59 <ElMarsh> also, this may be a very vague question, but if you had to tell someone the main difference between a functional language and a non-functional language, what would you say? I was under the impression that functional languages are declarative, and that's one of the main differences
15:09:04 <Axman6> and change (.) and ++ back to how the standard defines them
15:09:17 <roconnor> simple denotational semantics
15:09:18 <kmc> ElMarsh, that's very broad.  people mean lots of different things by "functional language"
15:09:19 <aristid> Axman6: i like caleskell :P
15:09:34 <Axman6> aristid: that's fine, but it gets in the way of learning and teaching in here
15:09:37 <Cale> ElMarsh: The main thing that allows a language to be functional is that it supports "functional programming" well. ;)
15:09:49 <kmc> ElMarsh, I usually mean "any language with first-class functions".  which includes most good languages, Haskell and Scheme and ML traditionally, but also includes C#, Python, Ruby, Perl, D, Go, ...
15:09:50 <Cale> ElMarsh: What is functional programming? Well...
15:09:53 <Axman6> and there have been _many_ complaints about it
15:09:53 <aristid> Axman6: it helped me learn ;)
15:10:00 <Axman6> not just from me
15:10:01 <ElMarsh> maybe I meant functional programming
15:10:26 <Cale> ElMarsh: I'll give a hint at what it might mean.
15:10:27 <aristid> @src ++
15:10:27 <lambdabot> []     ++ ys = ys
15:10:28 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:10:28 <lambdabot> -- OR
15:10:28 <lambdabot> xs ++ ys = foldr (:) ys xs
15:10:42 <Cale> ElMarsh: Why do we allow functions to have parameters in imperative languages?
15:10:44 * geheimdienst thinks that if it has map, it's a functional language, and that's that
15:10:57 <ElMarsh> well this is what wiki has to say about it : In computer science, functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data.  From this, it tells me that it is not imperative
15:11:10 <ElMarsh> hm
15:11:14 <aristid> geheimdienst: yay for Perl, the functional programming language.
15:11:15 <kmc> ElMarsh, working from that definition, you'd have to say Haskell is a "multiparadigm" language
15:11:21 <temoto> ElMarsh, to me, functional language is a language where values and functions are indistinguishable or, can be seen as each other.
15:11:38 <kmc> ElMarsh, the thing is, some people treat functional and imperative as different worlds that should never mix when, in fact, FP techniques are enormously useful in imperative programs and vice-versa
15:11:45 <ddarius> temoto: That arguably doesn't include Haskell.
15:11:48 <Cale> ElMarsh: Or perhaps better: why, when writing a program in an imperative language, would you decide to make something a function?
15:11:54 <kmc> ElMarsh, in Haskell we regularly have functions returning actions producing functions returning... etc.
15:11:58 <temoto> ddarius, how is that?
15:12:10 <ddarius> temoto: Functions are values, but values aren't functions in general.
15:12:11 <aristid> ddarius: you can write a Show instance for (->) x y, no?
15:12:29 <aristid> because functions are a kind of value
15:12:30 <Twey> Sure, but not a useful one
15:12:33 <temoto> ddarius, how values aren't nullary functions?
15:12:40 <ElMarsh> I would write a function for different reasons, organization, abstraction
15:12:43 <aristid> Integers are values, but values aren't Integers in general
15:12:44 <Cale> ElMarsh: okay
15:12:47 <Makoryu> aristid: I think smallcheck provides such an instance
15:12:56 <Twey> instance Show (a -> b) where show _ = "<function>"
15:12:59 <ddarius> temoto: Int isn't a function type.
15:13:16 <aristid> Makoryu: yeah i think caleskell imports that
15:13:20 <aristid> > id
15:13:20 <Twey> temoto: Functions take arguments, by definition
15:13:21 <Cale> ElMarsh: Those are good reasons. Have you ever run into a situation where there was an almost-repeated piece of code, but where you couldn't turn it into a function?
15:13:21 <lambdabot>   {()->()}
15:13:26 <aristid> it does.
15:13:35 <ElMarsh> yes
15:13:52 <Cale> ElMarsh: Probably because some part of the code itself was a bit different, yeah?
15:14:00 <ElMarsh> yeah
15:14:15 * hackagebot synthesizer-core 0.3.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.3.1 (HenningThielemann)
15:14:32 <Cale> So, the initial insight of functional programming is that if we just allowed functions to be values, and allowed functions to take other functions as parameters, that problem would go away.
15:14:40 <aristid> Cale: oh i know! i'd use the preprocessor! yesyes. BOOST_PP_REPEAT
15:15:11 <Cale> We could make the bits of code that are changing into function parameters, and we'd regain our abstraction.
15:15:29 <kmc> (this "initial insight" is from the 1930's, it's one of the first things ever done under the label "CS", and predates all programming languages and most of their designers, which is why it's funny how many of them still get it wrong)
15:15:34 <Cale> heh :)
15:15:57 <ElMarsh> other functions as parameters in what way?
15:16:07 <Cale> ElMarsh: Let's take a concrete example.
15:16:08 <temoto> ddarius, Twey okay, we discussed that too. So if we exclude nullary functions, then definition of functional language doesn't rely on 'values are functions'. Only 'functions are values part is left'.
15:16:10 <ElMarsh> okay
15:16:17 <Cale> Consider the following function for adding the numbers in a list:
15:16:19 <kmc> ElMarsh, perhaps you should read http://mitpress.mit.edu/sicp/ or watch the video lectures
15:16:20 <Cale> sum [] = 0
15:16:25 <Cale> sum (x:xs) = x + sum xs
15:16:39 <Cale> Now how about one which multiplies them instead?
15:16:44 <Cale> product [] = 1
15:16:51 <Cale> product (x:xs) = x * product xs
15:17:13 <ElMarsh> alright
15:17:16 <Cale> They're essentially the same program, but with 0 replaced by 1, and (+) replaced by (*)
15:17:27 <Cale> So there should be a way to avoid this repetition.
15:17:30 <ElMarsh> yea
15:17:52 <pastorn> @type foldr
15:17:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:17:57 <Cale> So what we'll do is define a new function with 2 more parameters: f will be the combining operation
15:18:09 <Cale> and z will be what to replace the empty list with
15:18:16 * hackagebot haskore-synthesizer 0.0.3.1 - Music rendering coded in Haskell  http://hackage.haskell.org/package/haskore-synthesizer-0.0.3.1 (HenningThielemann)
15:18:20 <temoto> Then i would redefine it as 'language treating functions as values to extent that you don't need to do anything special to "call" a function'. Not sure if that would require lazy evaluation, but laziness definitely covers that.
15:18:26 <Cale> fold f z [] = z
15:18:46 <Cale> fold f z (x:xs) = f x (fold f z xs)
15:18:48 <kmc> temoto, almost all functional languages are not lazy
15:19:06 <kmc> if you require laziness or even think it's relevant, you're using a very nonstandard definition
15:19:08 <Cale> Now we can write:
15:19:12 <Cale> sum = fold (+) 0
15:19:17 <Cale> product = fold (*) 1
15:19:18 <pastorn> what was the reasons for making haskell lazy?
15:19:25 <ElMarsh> ah, so like f ( f , z )  .... then the operation done will be depending on what argument was passed in for f
15:19:27 <aristid> Cale: maybe you should use points to make it easier for ElMarsh?
15:19:38 <Cale> aristid: points?
15:19:41 <cdsmithus> pastorn: compositionality, mainly.  Laziness lets you separate things into modular pieces in new ways
15:19:42 <mauke> parameters
15:19:45 <ElMarsh> but you can do something this with python
15:19:48 <Cale> oh
15:19:49 <temoto> kmc, yeah i'm aware of that nonstandardness :)
15:19:50 <Cale> right
15:19:50 <kmc> pastorn, by definition.  there were a bunch of lazy research languages, they started standardizing Haskell in order to have one lazy research language
15:20:00 <ElMarsh> you can do something like this*
15:20:05 <Cale> ElMarsh: Right, you *can* program functionally in python
15:20:06 <kmc> that was its purpose explicitly
15:20:10 <Makoryu> ElMarsh: And Python is regarded by some as a functional language.... But Guido doesn't like that designation, and goes out of his way to avoid it
15:20:12 <Cale> ElMarsh: It's not optimised for that, but you can.
15:20:19 <ElMarsh> ohhh
15:20:23 <aristid> Cale: i read about points in an explanation of the word point-free
15:20:42 <pastorn> kmc: ok, but why was it important for it to be lazy?
15:20:55 <kmc> pastorn, do you mean why were people researching lazy languages before Haskell?
15:21:00 <Cale> aristid: yes, I was just confused about in which sense you meant there -- I hadn't even consciously realised that I'd written sum and product in a points-free way
15:21:01 <pastorn> yeah
15:21:02 <ElMarsh>  I actually don't know a lot of C/C++ , can you not pass functions as arguments in C/C++?
15:21:07 <pastorn> i guess i am :)
15:21:09 <aristid> ElMarsh: you can even do it in C
15:21:11 <mauke> use List::Util qw(reduce); sub sum { reduce { $a + $b } 0, @_ }  sub product { reduce { $a * $b } 1, @_ }  # just because I can
15:21:16 <mauke> ElMarsh: only function pointers
15:21:19 <kmc> ElMarsh, not effectively.  you can pass "function pointers" which are not as general as full first-class functions
15:21:23 <Cale> ElMarsh: Not really.
15:21:28 <mauke> ElMarsh: meaning you need to have a global function elsewhere you can point to
15:21:31 <kmc> because they limit you to a small set of predefined functions, those you've written explicitly in your code
15:21:37 <Makoryu> ElMarsh: You can sort of do it, but it's much more of a pain
15:21:42 <Cale> ElMarsh: You can pass pointers to functions, but you can't pass the functions themselves, which makes a big difference
15:21:43 <kmc> a critical FP technique is a function that "computes" another function dynamically
15:22:03 <ElMarsh> yes it isn't the same, but you could achieve the same kind of functionality
15:22:08 <aristid> Cale: for this specific example of course it doesn't matter.
15:22:11 <Cale> and in order to implement proper functions, you'd need to bundle all the values of variables in local scope
15:22:16 <cdsmithus> pastorn: To be a bit overly confrontational (but maybe spark discussion), because lazy languages are the only correct ones.  In strict languages, there are terms that have a defined meaning, but the program hangs forever trying to calculate them.
15:22:22 <kmc> ElMarsh, with significantly more pain yes
15:22:22 <pikhq> Closures aren't going to work well with C without a garbage collector.
15:22:24 <Makoryu> ElMarsh: Sometimes, sure, you can. It takes a lot of boilerplate.
15:22:44 <aristid> pikhq: c++0x will have closures, without a garbage collector.
15:22:45 <cdsmithus> I should have said a "definable" meaning
15:22:45 <pastorn> cdsmithus: hmmm..
15:22:56 <pikhq> aristid: And it doesn't work well at all.
15:23:05 <geheimdienst> elmarsh, it's more clunky in c, because you would need to pass around the function pointer, any parameters the function needs, and the current value of any variables it would like to see, ...
15:23:28 <cdsmithus> pastorn: Put in a more real-world way, laziness lets you write your programs in more ways... and, as a result, divide up your problem in ways that you couldn't in a strict language.
15:23:30 <Makoryu> ElMarsh: A couple compilers have extensions to C that implement a garbage collector for the sole purpose of allowing functional programming :p
15:23:36 <aristid> pikhq: well, i think it is the correct decision not to introduce a GC to c++, because c++ is basically the language that you have to resort to when you don't want GC
15:23:40 <Cale> pastorn: And perhaps more relevantly, because many of the programs that are excluded by strict languages are actually programs we'd like to write -- we want to have the extra flexibility in terms of how we break down our problems
15:23:49 <pikhq> aristid: Uh, no.
15:24:06 <pastorn> Cale: true
15:24:10 <Makoryu> aristid: U MENA C?
15:24:12 <ElMarsh> ah
15:24:23 <ElMarsh> actually, does haskell has automatic garbage collection?
15:24:28 <aristid> ElMarsh: yes.
15:24:28 <Makoryu> aristid: Seriously, C++ is a bad idea. Don't do it.
15:24:30 <Makoryu> ElMarsh: Yep
15:24:35 <kmc> C++1x will have optional gc
15:24:37 <pikhq> If you just don't want GC happening, you can do that quite feasibly in almost any GC'd language.
15:24:38 <ElMarsh> neat
15:24:48 <aristid> Makoryu: i have been doing c++ for 8 years, so the damage is done.
15:24:52 <kmc> it's possible to write a language for manual memory management, and still provide appropriate hooks to plug in a gc
15:24:55 <kmc> C++ is not that language
15:24:55 <Makoryu> aristid: :(
15:25:00 <Cale> pastorn: When you write strict programs, you're constantly turning the whole program inside-out because you can't tell how much of something that you'll need beforehand, so you end up breaking through any semblance of abstraction so that you don't compute more than you need.
15:25:02 <kmc> hence resorting to the wretched hack of "conservative gc"
15:25:03 <pastorn> i remember working on haskell tetris... instead of each block generating a new one i just wrote one function that spawned an infinite list of blocks and then just constantly ran tail on that
15:25:04 <pikhq> The technique is called "memory pools". Whereby you *basically* create a heap and manage it manually.
15:25:11 <ElMarsh> you guys don't like C++? haha
15:25:15 <pastorn> something i couldn't have done in a strict language
15:25:15 <cdsmithus> pastorn: The classic example is if I want to add up the prime numbers until the sum is greater than 1000.  In a strict language, I'd need a piece that says "give me all the primes from 1 to n", and figure out what n to choose.  In a lazy language, I can ask for *all* the primes.  Then I can ask for *all* the partial sums, and then I can ask for the first one that's greater than 1000.
15:25:18 <kmc> ElMarsh, you broke the code ;)
15:25:27 <Cale> That is, you have to fuse consumers and producers by hand, because you don't have infinite datastructures.
15:25:28 <ElMarsh> haha
15:25:49 <kmc> ElMarsh, it is more suitable for some things than others.  there are some tasks where C++ is regrettably the best language; i think it still has unnecessary pain in those cases
15:25:53 <aristid> ElMarsh: i think c++ is the only option for some problems.
15:26:06 <ElMarsh> I was either going to learn Haskell or C++, but C++ felt like more of the same with just "more stuff to worry about". Haskell sounded like it's actually something different
15:26:12 <kmc> ElMarsh, yes
15:26:14 <Cale> ElMarsh: Regardless of what it might be useful for, C++ is a horrid language.
15:26:21 <kmc> learning Haskell will expand your mind
15:26:22 <Makoryu> ElMarsh: Your intuition is correct :p
15:26:26 <ElMarsh> haha
15:26:30 <pikhq> ElMarsh: Haskell will help you *immensely* with one aspect of C++, BTW.
15:26:36 <pikhq> Template metaprogramming.
15:26:37 * pastorn knows next to no imperative languages
15:27:08 <ElMarsh> really, could you "survive" professionally without knowing imperative languages?
15:27:11 <pikhq> (as it's a pure, functional language, with (poorly-implemented) pattern matching)
15:27:29 <pikhq> ElMarsh: You can survive professionally without being able to program.
15:27:34 <pastorn> ElMarsh: i can code java if i have to, but i don't like to
15:27:43 <aristid> ElMarsh: i think it's better to know both worlds :)
15:27:48 <pikhq> Even in computers. System administrators exist. :)
15:27:58 <ElMarsh> haha
15:28:04 <Cale> ElMarsh: http://yosefk.com/c++fqa/defective.html -- here's a great description of many of the things which are wrong with C++, but it leaves out a lot of the reasons that I'd actually give.
15:28:05 <Makoryu> ElMarsh: I would advise you to learn C when you are comfortable enough with your algorithms that you could manually distill them into assembler code.
15:28:07 <kmc> every general purpose language I know is imperative, by definition
15:28:18 <Makoryu> ElMarsh: Because that's pretty much what you do when you're writing C.
15:28:28 <aristid> pikhq: system administrators are programming with the imperative untyped everything-is-a-string programming language called bash ;)
15:28:36 <ElMarsh> I know a fair share of algorithms pretty well
15:28:40 <ElMarsh> at least I hope I do
15:28:46 <pikhq> (granted, any *good* sys admin will have at least some proficiency in programming)
15:28:49 <mauke> bash is a stringly-typed language
15:28:55 <kmc> hehe
15:28:56 * benmachine giggles
15:28:57 <ElMarsh> I've heard people say that I should've even bother with C though, just go to C++
15:29:01 <kmc> ElMarsh, no
15:29:05 <kmc> that is horrible advice
15:29:08 <aristid> Cale: the thing is, many people will conclude that C were a better option, which is completely wrong.
15:29:08 <kmc> C is a small, simple language
15:29:09 <pikhq> aristid: Yeah, I prefered those semantics when it was called Tcl.
15:29:12 <geheimdienst> oh, mauke has read the programming jargon thing on reddit as well :-)
15:29:13 <mauke> ElMarsh: those are C++ programmers and should be ignored
15:29:17 <kmc> it makes sense, it's put together well, and it's crucial for a lot of things
15:29:20 <kmc> C++ is a huge sprawling mess
15:29:25 <cdsmithus> ElMarsh: I disagree greatly.  C is a very nice, if not exactly featureful, language.  Use it over C++ if you can.
15:29:30 <mauke> geheimdienst: I haven't, actually
15:29:30 <kmc> the stuff C++ adds on top of C is many many times larger than C itself
15:29:34 <ElMarsh> haha, of course also coming from Bjarne himself, it shouldn't be trusted :P
15:29:45 <aristid> kmc: the stuff also adds value.
15:29:46 <kmc> not that C++ features are never useful, but you should know C well before you try to grasp all the other crap
15:29:47 <pikhq> ElMarsh: No. C is a small, simple language, and can be learned in perhaps a couple of weeks. C++ is several languages, glued together and stuck on top of C.
15:29:52 <kmc> aristid, of course
15:29:56 <geheimdienst> "bjarne stroustrup bolts everything he has ever heard of onto c to create c++" ...
15:30:01 <kmc> it adds value and headache, and i find often not in a favorable ratio
15:30:05 <Cale> aristid: Well, it's sort of wrong. I would actually contend that there are ways in which C *is* a better option, in that even though it sucks for programming in directly, it has less cruft, and makes a better target language for a compiler :)
15:30:06 <kmc> but you can pick and choose
15:30:08 <ElMarsh> yes I get the feeling that C++ is a pain :P
15:30:33 <kmc> part of the problem with using C++ in a multi-programmer setting is that everyone has a different idea which subset of the features are broken beyond repair and should be avoided
15:30:44 <Cale> ElMarsh: We've known how to implement first-class functions with a reasonable degree of efficiency, and we've known what a tremendous benefit to programming they are, since around the 1970's. It is absolutely inexcusable not to support them.
15:30:52 <pikhq> ElMarsh: C++ is a pain to write, a pain to read, and a pain to implement.
15:30:53 <aristid> Cale: *shrug* it's easy to use a C-like subset of C++ as a target for a compiler, but i agree that C is better because it has faster compilers.
15:30:56 <ElMarsh> there was a site I stumbled across though that compared run times and number of lines for C and C++, a lot of times C required more lines ( by a significant amount )
15:31:05 <pikhq> Are there any compilers that support C++ fully yet?
15:31:21 <pastorn> gcc?
15:31:22 <aristid> pikhq: are there any compilers that support C fully yet?
15:31:26 <pikhq> ElMarsh: C's standard library is fairly sparse.
15:31:32 <ElMarsh> to me, readability and succinctness are important factors
15:31:35 <aristid> no, there is not a single compiler which supports either C or C++ fully.
15:31:41 <pikhq> aristid: I think GCC's got full support of C90.
15:31:45 <Makoryu> aristid: The hell?
15:31:49 <jbapple> aristid: [citation needed]
15:31:50 <aristid> pikhq: no, probably not.
15:31:50 <ElMarsh> if C++ was easier to read than C then I would have to go with C++ maybe
15:31:50 <kmc> should we establish #haskell-bitching-about-C++?
15:31:52 <pikhq> C99 is most certainly still a work in progress.
15:32:27 <kmc> i mean i've done my fair share of bitching now and in the past, but perhaps it should be somewhere else
15:32:29 <aristid> kmc: oh, everybody's bitching about c++, even the people in ##c++, although i still think c++ is better than its reputation :)
15:32:33 <kmc> hehe
15:32:45 <kmc> aristid, careful or i'll have a bot tell you snarkily that you're off topic ;P
15:32:52 <Makoryu> aristid: It is both better and worse than its reputation.
15:32:59 <ElMarsh> if you had to do some lower level work, C would be the language you'd turn to?
15:33:09 <Makoryu> ElMarsh: C, or assembler.
15:33:11 <aristid> ElMarsh: not me, i'd use c++. :P
15:33:23 <kmc> is there a good "programming languages" channel?
15:33:32 <Makoryu> kmc: This would be it.
15:33:34 <benmachine> heh
15:33:36 <kmc> that's what i was afraid of
15:33:37 <pikhq> ElMarsh: Brainfuck. :P
15:33:44 <Makoryu> I lurked in #somethingorother for a while but nobody talked there
15:33:53 * geheimdienst thinks lower levels are overrated
15:33:53 <benmachine> I can't imagine there'd be a generic language channel that was anything but constant flamewars >_>
15:34:03 <ElMarsh> haha
15:34:06 <ElMarsh> I agree
15:34:07 <pikhq> (only half-joking about that...)
15:34:20 <benmachine> well, maybe you could have ##functional or whatever
15:34:22 <cdsmithus> pikhq: Really?  Only half?
15:34:28 <aristid> geheimdienst: a secret service is usually more high level than that, eh?
15:34:28 <Makoryu> geheimdienst: They are. People mistakenly equate "low level" with "high performance"
15:34:28 <pikhq> cdsmithus: Only half.
15:35:21 <hpc> brainfuck has a really simple instruction set
15:35:31 <aristid> pikhq: in that brainfuck actually is low-level?
15:35:42 <aristid> almost as low-level as a turing machine
15:35:43 <cdsmithus> ... and is incredibly awkward to tell your boss that you're using. :)
15:36:04 <aristid> cdsmithus: fortunately, that never happens.
15:36:16 <Makoryu> Oh yeah, #proglangdesign
15:36:33 <pikhq> aristid: Yes, I'd consider that somewhat low-level. Though not related to machines we're actually using. :)
15:37:06 <aristid> pikhq: let's pretend we use memristor machines
15:37:18 <cdsmithus> I would mention now a recent story about building an OS kernel in Haskell, then translating to C.  Strong language design has applications even in low-level stuff
15:37:34 <kmc> there's Atom
15:37:37 <ElMarsh> by the way, which Haskell editor/IDE do you guys use? I'm currently using Visual Haskell -- any objections to that?
15:37:53 <mrd> speaking of flamewars
15:37:55 <kmc> ElMarsh, most people use whatever text editor they otherwise use
15:38:01 <kmc> i.e. not a special Haskell IDE
15:38:07 <aristid> mrd: hahaha
15:38:09 <kmc> i use vim, i used to use emacs, they're both decent
15:38:30 <cdsmithus> ElMarsh: There isn't really an environment.  If I already have a file browser window open, I double-click, and something opens.  Otherwise, I use lpe from the terminal
15:38:43 <ElMarsh> do you know textmate/ E - text editor?
15:38:53 <aristid> textmate doesn't run on linux
15:39:28 <cdsmithus> aristid: These days, I'd be surprised if something like a text editor doesn't work in Wine
15:39:31 <ElMarsh> ah , yeah textmate doesn't run on windows either, E - text editor is the windows version for it
15:39:53 <Makoryu> ElMarsh: To be precise, E is an unsanctioned clone of TextMate
15:39:55 <aristid> cdsmithus: textmate probably won't run in wine either, or does wine support os x emulation?
15:39:58 <geheimdienst> cdsmithus, textmate is a mac program
15:40:01 <cdsmithus> aristid: Oh, never mind
15:40:02 <ElMarsh> but I really like it, you could make it compatible with Haskell as well, but I couldn't find a bundle for it
15:40:13 <mrd> anyone do any work with approx-comparisons of FP numbers?  I'm in a bit of a quandary about how to proceed here.  I can use my own homebrewed approximation module, use the ieee library (which apparently doesn't build on 6.12), or something else.
15:40:28 <Makoryu> ElMarsh: There's a Haskell bundle in the main repository. I'm the maintainer... I should know :p
15:40:31 <benmachine> kmc: I'm curious, can I ask what made you switch?
15:40:34 <aristid> > compare nan nan
15:40:35 <lambdabot>   Not in scope: `nan'Not in scope: `nan'
15:40:43 <ElMarsh> the maintainer?
15:40:43 <aristid> it lost my @let :(
15:40:49 <Makoryu> ElMarsh: Of the Haskell bundle.
15:40:53 <mrd> > 0/0
15:40:53 <aristid> @let nan = 0.0 / 0.0 :: Double
15:40:53 <lambdabot>   NaN
15:40:54 <lambdabot>  Defined.
15:40:54 <ElMarsh> :O
15:40:59 <ElMarsh> great!
15:41:02 <aristid> > compare nan nan
15:41:03 <lambdabot>   GT
15:41:07 <ElMarsh> I tried to use the textmate bundle but it didn't work
15:41:23 <aristid> > nan > nan
15:41:23 <mrd> obviously default compare doesn't work well with FP, for that and other reasons (machine epsilon)
15:41:24 <lambdabot>   False
15:41:34 <benmachine> aristid: welcome to Floats Are Crazy, lesson 1 >_>
15:41:54 <aristid> benmachine: i dislike how compare behaves
15:42:01 <wli> Try implementing multiple precision floating point arithmetic.
15:42:01 <Makoryu> ElMarsh: TextMate is awful for Haskell, and it makes me cry.
15:42:03 <benmachine> aristid: you're not the only one
15:42:16 <ElMarsh> oh is it
15:42:19 <mrd> would it be that terrible if Ord Double was defined with machine epsilon in mind?
15:42:20 <benmachine> but people have different ideas about how to fix it
15:42:24 <ElMarsh> because I really like it when I code in Python
15:42:43 <Makoryu> ElMarsh: It's okay for Python. A little nicer than the default stuff that comes with vim.
15:42:46 <ElMarsh> the completing brackets/ quotation mark feature is fancy too
15:42:47 <mrd> and Eq too
15:42:49 <aristid> benmachine: the IEEE754 semantics of quite NaN are another matter, but compare just returning GT somehow feels wrong
15:42:50 <Makoryu> Yeah.
15:42:54 <cdsmithus> mrd: You mean if it reported EQ for values that aren't equal?  I'd consider that horrible,
15:42:55 <aristid> -quite+quiet
15:43:04 <mrd> cdsmithus: aren't "equal" ?
15:43:07 <mrd> what's equal mean with FP
15:43:10 <Makoryu> ElMarsh: The problem is that the indentation model is so limited as to be completely useless for Haskell
15:43:17 <ElMarsh> ah I see
15:43:34 <aristid> mrd: NAN is not equal to NAN, as defined by the relevant FP standard (IEEE 754)
15:43:39 <cdsmithus> mrd: Every floating point value (except nan and inf) has a real number equivalent.  You can check if they are equal or not.
15:43:51 <benmachine> cdsmithus: all the options are horrible, I think EQ would be a sane compromise in this case
15:44:03 <aristid> benmachine: i'd vouch for bottom.
15:44:07 <ElMarsh> are you familiar with "Leksah"
15:44:11 <benmachine> aristid: but partial functions are ew
15:44:20 <aristid> benmachine: Double is partial itself.
15:44:28 <benmachine> aristid: how so
15:44:30 <mrd> certainly FP values correspond to precise real numbers, but often they are the result of an approximation forced upon you.  however I didn't come here to debate whether ORd should change.
15:44:32 <cdsmithus> benmachine: When things get ugly, I'd rather be correct and let people write what they really mean.  Better than an Eq that's non-transitive!
15:44:39 <aristid> benmachine: there's nan.
15:44:53 <benmachine> aristid: but that can be caught and analysed in pure code
15:44:55 <mrd> I want to know whether there's a "better" way to proceed with this
15:44:59 <aristid> benmachine: EQ would be totally wrong to return from compare
15:45:23 <aristid> benmachine: did you know there is actually millions or billions of different NAN values?
15:45:27 <Makoryu> ElMarsh: I've heard of it.
15:45:28 <benmachine> aristid: it would be wrong by the IEEE standard, but I'd rather we stuck to haskell's rules than theirs
15:45:28 <cdsmithus> aristid: Ever?  But two floating point numbers CAN be the same.
15:45:31 <benmachine> aristid: yes
15:45:43 <mrd> offer a type-class for users to implement that provides the approx operations on the desired type?  use the (currently) broken ieee library?  or just bake something in
15:45:44 <Makoryu> ElMarsh: I can't say I've ever gotten it to work.
15:45:49 <benmachine> but usually you don't care about the difference :P
15:45:59 <ElMarsh> yeah, I downloaded it but I can't get it to work
15:46:21 <aristid> cdsmithus: two NAN values CANNOT be the same.
15:46:25 <benmachine> cdsmithus: non-transitive? but the current GT is non-transitive I think
15:46:28 <ElMarsh> I was secretly hoping that you know how to set it up and everything haha
15:46:28 <cdsmithus> aristid: Yeah, sure
15:46:38 <benmachine> aristid: it depends on how you define equality
15:46:48 <aristid> benmachine: in terms of (==)? :)
15:46:52 <aristid> > nan == nan
15:46:53 <lambdabot>   False
15:46:54 <benmachine> aristid: I believe the Eq class only requires an equivalence relation
15:47:01 <hpc> @src nan
15:47:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:47:07 <aristid> hpc: i @let it
15:47:14 <benmachine> obviously it'd be nice to follow the standard where possible
15:47:14 <hpc> ah
15:47:15 <cdsmithus> benmachine: How is > non-transitive?
15:47:15 <aristid> hpc: @let nan = 0.0 / 0.0 :: Double
15:47:36 <pastorn> ((a -> b) -> a) -- what's this?
15:47:43 <pastorn> Cont is ((a -> b) -> b)
15:47:54 <cdsmithus> pastorn: It's an uninhabited type?
15:47:55 <danharaj> Maybe float should look like Float x | NaN where Float x can be ordered by NaN cannot, so you have to explicitly deal with it.
15:48:01 <benmachine> cdsmithus: hmm, I don't think I mean non-transitive
15:48:05 <aristid> benmachine: it isn't possible while maintaining IEEE754 semantics, which happens to be the accepted standard
15:48:06 <pastorn> cdsmithus:
15:48:10 <pastorn> @type ap . ap
15:48:11 <lambdabot> forall a b a1. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
15:48:14 <kmc> (==) is not reflexive for Double
15:48:20 <kmc> > let x = 0/0 in x == x
15:48:21 <lambdabot>   False
15:48:24 <mrd> well at least I started a fun new flamewar
15:48:44 <benmachine> aristid: I meant the IEEE standard :P which doesn't define a comparison between nans
15:48:54 <benmachine> mrd: itym lively discussion :D
15:49:16 <benmachine> aristid: oh I suppose it does sort of
15:49:38 <ElMarsh> is there  a way to save IRC logs?
15:49:46 <benmachine> but I just don't like non-total functions turning up where they're not invited
15:49:46 <hpc> yes
15:49:52 <danharaj> ElMarsh: That depends on your client.
15:49:54 <hpc> what client are you using?
15:49:55 <benmachine> ElMarsh: client-dependent but pretty much every client can
15:49:56 <pastorn> ElMarsh: most clients do that automagically
15:50:02 <kmc> ElMarsh, everything in this channel is already logged
15:50:08 <pastorn> @where log
15:50:08 <lambdabot> I know nothing about log.
15:50:10 <pastorn> @where logs
15:50:10 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
15:50:19 <pastorn> ElMarsh: ^^^
15:50:22 <ElMarsh> great thanks
15:50:29 <geheimdienst> @where anything
15:50:30 <lambdabot> I know nothing about anything.
15:50:38 <hpc> :D
15:50:39 <pastorn> @slap geheimdienst
15:50:39 * lambdabot pulls geheimdienst through the Evil Mangler
15:50:44 <pastorn> @botsnack
15:50:44 <lambdabot> :)
15:50:48 <aristid> benmachine: well, maybe Double just should not be in the Eq and Ord classes.
15:50:49 <hpc> @where everything
15:50:49 <lambdabot> I know nothing about everything.
15:51:10 <ElMarsh> I'm on a web client thing
15:51:13 <benmachine> aristid: then it becomes deeply obnoxious to write a lot of code that works nearly all the time
15:51:17 <fryguybob> > (uncurry encodeFloat . decodeFloat) (0.0/0.0)
15:51:18 <lambdabot>   -Infinity
15:51:23 <ElMarsh> I just copied and pasted everything
15:51:28 <aristid> benmachine: that's the problem, but it would be the clean thing to do
15:51:29 <mrd> I look forward to the day when we can have precise representations of every real number in finite space
15:51:33 <hpc> ElMarsh: mibbit?
15:51:36 <ElMarsh> there was some good stuff on here today, thanks :)
15:51:40 <benmachine> mrd: yeah, me too
15:51:54 <ElMarsh> I have no idea what it's called I just googled freenode and clicked on the 2nd hit
15:52:04 <hpc> web programs can't use your hard drive without express permission
15:52:08 <cdsmithus> mrd: That requires an infinite alphabet.
15:52:08 <benmachine> aristid: but any time you use Doubles you're already admitting some uncleanliness :P
15:52:23 <aristid> benmachine: it's worse than the ST monad ;)
15:52:33 <wli> Do what C does: use specialized comparator functions (macros) to do the IEEE754-compatible comparison semantics.
15:53:07 <benmachine> wli: how do they work?
15:53:17 <mrd> cdsmithus: I'll be looking forward for a long time
15:53:36 <hpc> benmachine: a bunch of conditions and bitwise logic, i assume
15:53:42 <wli> benmachine: man 3 isgreater() etc.
15:53:46 <benmachine> hpc: I meant semantically :P
15:53:49 <hpc> ah
15:53:59 <wli> hpc: Also (probably) inline asm for machine support.
15:54:23 <aristid> wli: i think they're probably implemented as compiler builtins, if they're in the C standard
15:54:27 <wli> benmachine: They do the NaN comparison failure.
15:54:30 <aristid> at least that's what modern compilers do
15:54:50 <benmachine> wli: that doesn't tell us what compare nan nan should return
15:54:53 <wli> aristid: Yeah, probably.
15:55:29 <cdsmithus> benmachine: Yeah, Ord requires a total order, which IEEE floats don't have.  (It's not even a partial order, due to lack of reflexivity)
15:55:52 <wli> benmachine: ISTR the actual behavior being that any predicate will fail. So isgreater() with a NaN is always false (including two NaN's), islessequal() similarly, etc.
15:55:58 <benmachine> cdsmithus: so we have to either break Ord or break IEEE
15:56:09 <hpc> or both :P
15:56:18 <cdsmithus> Actually, it also lacks antisymmetry, because positive and negative zero are supposed to compare equal, by IEEE
15:56:23 <benmachine> wli: that's the behaviour for <=, >=, == etc. but compare doesn't have a "false" option
15:56:27 <benmachine> it's EQ LT or GT
15:56:59 <benmachine> cdsmithus: oh, I always thought that unpleasant too
15:57:03 <wli> benmachine: Right, so Ord doesn't fly with IEEE754. The IEEE754 users will need some other API.
15:57:14 <benmachine> x == y but 1 / x /= 1 / y
15:57:42 <benmachine> wli: so you think we should come up with our own ordering on Floats and have Ord use that?
15:57:58 <benmachine> which is almost always the same as you'd expect except where that would lead to contradictions
15:58:49 <wli> benmachine: I would let Ord do something natural for itself, and provide an IEEE754 API for the native operations.
15:59:04 <benmachine> right
15:59:17 <benmachine> so you could import Data.IEEE (greaterequal) or whatever
15:59:31 <benmachine> .<=. or something silly
16:00:01 <aristid> benmachine: and where in the ordering would NAN be?
16:00:06 <aristid> the highest value or the lowest
16:00:16 <aristid> higher or lower than +/-inf?
16:00:21 <cdsmithus> > let { inf = 1 / 0 ; ninf = (-1) / 0 } in (1 / inf) == (1 / ninf)
16:00:23 <lambdabot>   True
16:00:35 <fryguybob> > (uncurry encodeFloat . decodeFloat) (0.0/0.0) == (uncurry encodeFloat . decodeFloat) (-1.0/0.0)
16:00:36 <lambdabot>   True
16:00:38 <benmachine> aristid: it doesn't really matter
16:00:39 <aristid> benmachine: i mean in the total Ord ordering that you implicitly propose
16:00:55 <Draconx|Laptop> cdsmithus, floating point satisfies a restricted form of antisymmetry: a <= b && b <= a implies a == b
16:01:03 <benmachine> I guess it's kind of crappy to have that decision arbitrary
16:01:07 <benmachine> but a lot of things are kind of crappy
16:01:11 <aristid> benmachine: of course it matters, it affects all algorithms that use it
16:01:24 <aristid> benmachine: if it truly wouldn't matter, we could use bottom :)
16:01:34 <benmachine> aristid: it affects them yes
16:01:41 <aristid> i mean, nan is basically bottom
16:01:46 <benmachine> I didn't mean, it doesn't really matter, so have GHC pick a random option at startup
16:01:50 <cdsmithus> I don't like that: So a standard Eq instance returns True for distinguishable values.
16:01:59 <benmachine> no nan is not bottom because nan can be detected safely in pure code
16:02:04 <benmachine> bottom cannot
16:02:14 <aristid> benmachine: i mean conceptually
16:02:30 <benmachine> aristid: I'd argue the difference is significat
16:02:34 <aristid> nan is the bottom of IEEE754 itself
16:02:50 <aristid> it's where computations go to die
16:02:54 <benmachine> because you have isnan() but you don't have isbottom()
16:02:55 <cdsmithus> aristid: No, I odn't think so.  One means you have no information about the value.  The other means that you do have information, and that information is that the value is indeterminate
16:03:01 <tensorpudding> I like naan
16:03:08 <tensorpudding> is tasty
16:03:18 <benmachine> yeah nan means "you screwed up" bottom means "i dunno"
16:03:23 <aristid> NAN propagates from the inner part of an expression to the outer part
16:03:53 <benmachine> yes so they are similar in that respect
16:04:02 <pikhq> NAN is more like a Nothing value in IEEE754, though.
16:04:04 <Draconx|Laptop> aristid, except when it doesn't.
16:04:07 <benmachine> yeah
16:04:26 <aristid> Draconx|Laptop: it always does when you use only IEEE754 operations.
16:04:28 <fryguybob> > Nothing == Nothing
16:04:29 <lambdabot>   True
16:04:37 <Draconx|Laptop> aristid, isnan *is* an IEEE754 operation!
16:04:42 <aristid> > Nothing < Nothing
16:04:43 <lambdabot>   False
16:04:53 <fryguybob> > Nothing <= Nothing
16:04:54 <benmachine> aristid: also, we don't use only IEEE operations :P
16:04:54 <lambdabot>   True
16:04:56 <Draconx|Laptop> aristid, and a very important one, at that.
16:05:03 <pikhq> fryguybob: "Analogy". :)
16:05:10 <fryguybob> :D
16:05:16 <aristid> Draconx|Laptop: well you can also use !(x==x) to check for nan :)
16:05:23 <pikhq> Also, since when was Maybe a member of Ord?
16:05:28 <pikhq> :t (<)
16:05:29 <wli> > (Nothing `compare` Nothing, Nothing < Nothing)
16:05:29 <lambdabot> forall a. (Ord a) => a -> a -> Bool
16:05:30 <lambdabot>   (EQ,False)
16:05:32 <aristid> Draconx|Laptop: i meant the operations that return a floating-point value but i should have said it
16:05:49 <pikhq> @instances Ord
16:05:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:05:51 <aristid> > Nothing < Just 1
16:05:51 <Draconx|Laptop> aristid, it's not the same: x == x raises an exception.
16:05:52 <lambdabot>   True
16:05:56 <aristid> > Nothing > Just 1
16:05:57 <lambdabot>   False
16:05:58 <benmachine> Ord a => Ord (Maybe a) where Nothing is a minimum, I think
16:06:14 <benmachine> > minBound :: Maybe ()
16:06:15 <pikhq> benmachine: Ah.
16:06:15 <lambdabot>   No instance for (GHC.Enum.Bounded (Data.Maybe.Maybe ()))
16:06:16 <lambdabot>    arising from a ...
16:06:21 <benmachine> hmm
16:06:23 * benmachine shrugs
16:06:25 <Makoryu> > () < ()
16:06:26 <lambdabot>   False
16:06:33 <pikhq> > minBound :: Maybe Int
16:06:34 <lambdabot>   No instance for (GHC.Enum.Bounded (Data.Maybe.Maybe GHC.Types.Int))
16:06:34 <lambdabot>    aris...
16:06:40 <pikhq> *shrug*
16:06:45 <aavogt> > let nan = 0 / 0 in nan == nan
16:06:46 <lambdabot>   False
16:06:49 <benmachine> that's bounded not ord I was just curious
16:06:49 <fryguybob> > Just (0.0/0.0) == Just (0.0/0.0)
16:06:50 <aristid> haskell has Ord instances for EVERYTHING?
16:06:50 <lambdabot>   False
16:07:00 <Makoryu> aristid: Not quite, no :p
16:07:07 <tensorpudding> > True > False
16:07:07 <lambdabot>   True
16:07:10 <aristid> Makoryu: it does have them for ()
16:07:11 <Makoryu> Though lambdabot's prelude might....
16:07:15 <aristid> oh
16:07:15 <benmachine> > fix (True >)
16:07:19 <lambdabot>   mueval-core: Time limit exceeded
16:07:23 <benmachine> > fix (True >=)
16:07:27 <lambdabot>   mueval-core: Time limit exceeded
16:07:28 <Makoryu> > putStrLn "foo" < getLine
16:07:28 <benmachine> aw
16:07:29 <lambdabot>   Couldn't match expected type `()'
16:07:29 <lambdabot>         against inferred type `[GHC.Types...
16:07:31 <aristid> Makoryu: instance Ord () -- Defined in Data.Tuple
16:07:41 <tensorpudding> There aren't Ord instances for function types.
16:07:52 <aristid> tensorpudding: haha :D
16:07:55 <Makoryu> tensorpudding: Doesn't lambdabot import smallcheck?
16:07:59 <Makoryu> > id < ($)
16:08:00 <lambdabot>   No instance for (GHC.Classes.Ord ((a -> b) -> a -> b))
16:08:00 <lambdabot>    arising from a us...
16:08:02 <Makoryu> Dang.
16:08:07 <benmachine> > id == id
16:08:08 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
16:08:08 <lambdabot>    arising from a use of `GHC.Cla...
16:08:12 <benmachine> > show id
16:08:13 <lambdabot>   "{()->()}"
16:08:15 <cdsmithus> > let nan = 0/0 in (nan == nan, compare nan nan)
16:08:16 <lambdabot>   (False,GT)
16:08:27 <aristid> i think it's taught in CS 101 that function equality is undecidable?
16:08:32 <cdsmithus> Oh... really?  It's greater than itself?
16:08:42 <aristid> cdsmithus: no.
16:08:46 <aristid> > nan > nan
16:08:47 <lambdabot>   False
16:08:50 <sshc> > let nan = 0/0 in (nan > nan, compare nan nan)
16:08:51 <lambdabot>   (False,GT)
16:08:59 <aristid> we have a global let nan
16:09:03 <benmachine> aristid: hmm, depends what you want from equality
16:09:06 <aristid> it will get lost at the next flush
16:09:11 <sshc> > let nan = 0/0 in (nan > nan, nan < nan, nan == nan, nan <= nan, nan >= nan, compare nan nan)
16:09:12 <lambdabot>   (False,False,False,False,False,GT)
16:09:21 <sshc> > fix nan
16:09:22 <lambdabot>   Couldn't match expected type `a -> a'
16:09:22 <lambdabot>         against inferred type `GHC.Ty...
16:09:29 <sshc> @type nan
16:09:30 <lambdabot> Double
16:09:40 <cdsmithus> That's ugly.  I don't particularly care what order is chosen for floating point values, but it should be one!
16:09:44 <benmachine> aristid: I mean, there are only like four functions Bool -> Bool
16:09:57 <soupdragon> cdsmithus: it makes sense to me
16:09:58 <aristid> cdsmithus: ever heard of IEEE 754?
16:10:07 <soupdragon> @check isNan
16:10:07 <lambdabot>   Not in scope: `isNan'
16:10:09 <Draconx|Laptop> cdsmithus, they really shouldn't belong to Ord *at all*.
16:10:11 <soupdragon> @check isNaN
16:10:11 <lambdabot>   "Falsifiable, after 0 tests:\n2.5\n"
16:10:17 <soupdragon> @check not . isNaN
16:10:18 <lambdabot>   "OK, passed 500 tests."
16:10:33 <cdsmithus> aristid: Sure... I know IEEE 754 is there, but also impossible to represent with Ord.
16:10:35 <benmachine> @check (< 500)
16:10:36 <lambdabot>   "OK, passed 500 tests."
16:10:45 <aristid> cdsmithus: that's the problem :)
16:10:49 <cdsmithus> So, I'm saying you have to do something arbitrary... but it should be arbitrary and consistent
16:11:30 <aristid> cdsmithus: oh, it is consistent, it always return false, like the standard says
16:11:42 <aristid> of course that doesn't constitute a valid ordering
16:11:44 <Draconx|Laptop> cdsmithus, really, the bigger problem facing floating point support in Haskell is that there is no way to convert between the various floating point types.
16:11:45 <cdsmithus> aristid: compare is not consistent with (>)
16:11:55 <benmachine> I wonder if the ordering on nans breaks Data.Map and Data.Set
16:12:06 <benmachine> > S.fromList [0/0, 0/0.0]
16:12:07 <lambdabot>   fromList [NaN,NaN]
16:12:12 <aristid> cdsmithus: exactly, that's how i started this whole discussion.
16:12:25 <benmachine> hmm that sort of makes sense
16:12:37 <aristid> > S.fromList [0/0, 1, 0/0.0]
16:12:38 <lambdabot>   fromList [NaN,1.0,NaN]
16:12:39 <cdsmithus> benmachine: I'm fairly sure it does.. or could, with minor changes... it's rather horridly broken.
16:12:58 <aavogt> > (0/0) `S.member` S.fromList [0/0, 0/0.0]
16:12:59 <lambdabot>   False
16:13:22 <cdsmithus> > compare 5 nan
16:13:23 <lambdabot>   GT
16:13:23 <aristid> cdsmithus: well, compare nan nan = undefined was my suggestion :)
16:13:43 <benmachine> > div 1 0
16:13:44 <lambdabot>   *Exception: divide by zero
16:13:52 <aristid> cdsmithus: it seems like compare checks for <, then == and then gives up
16:13:54 <cdsmithus> > 5 `S.contains` (S.fromList [ 5, nan ])
16:13:55 <lambdabot>   Not in scope: `S.contains'
16:14:01 <benmachine> aristid: I just like totality where possible
16:14:19 <benmachine> but then I'm not about to suggest that div 1 0 return 0 or 1 or maxBound or anything
16:14:35 <kmc> > let k = 0/0; m = M.fromList [(k, 'x')] in M.lookup k m
16:14:37 <lambdabot>   Nothing
16:14:47 <cdsmithus> > 5 `S.member` S.fromList [5, nan]
16:14:49 <lambdabot>   True
16:14:51 <aristid> floating-point is a huge problem in most languages :/
16:15:01 <Draconx|Laptop> kmc, you can actually cause map members to disappear completely (with respect to lookup) by adding elements to it!
16:15:02 <cdsmithus> 5 `S.member` S.fromList [nan, 5]
16:15:12 <aristid> which is why operator overloading is so important: you can resort to better numeric types
16:15:13 <cdsmithus> > 5 `S.member` S.fromList [nan, 5]
16:15:14 <lambdabot>   True
16:15:20 <benmachine> the silly thing is that Maybe is quite an effective solution to the problem that NaN wants to solve :P
16:15:20 <cdsmithus> Hmm, I can't make it break
16:15:37 <Draconx|Laptop> aristid, this is because language designers who've never read Kahan's paper think that adding float and double types constitutes proper floating point support.
16:15:44 <benmachine> cdsmithus: it's entirely possible that the API only uses one comparison operation and thus makes consistent assumptions from it
16:15:55 <benmachine> cdsmithus: in which case it would work fine, but basically by sheer luck
16:16:10 <benmachine> uhh I don't mean API
16:16:13 <benmachine> I mean library guts
16:16:21 <aavogt> Draconx|Laptop: how are those members of the map ever there?
16:16:32 <aristid> Draconx|Laptop: it's not like nan were the only problem of floating-point semantics
16:16:33 <aavogt> to lookup at least
16:16:36 <Draconx|Laptop> aavogt, it can cause non-NaN members to disappear.
16:16:36 <cdsmithus> benmachine: Yeah, I see.  If it only ever uses (>), then it will seem like nan comes right before -inf
16:16:45 <Draconx|Laptop> aristid, I never said they were.
16:17:08 <cdsmithus> benmachine: wait, that's not true... it would still seem different on the left versus right
16:17:11 <aristid> Draconx|Laptop: if i can use something like Ratio, i will.
16:17:39 <aavogt> can you construct a small example that does so?
16:17:53 <Draconx|Laptop> yeah, give me a minute.
16:17:55 <benmachine> cdsmithus: but maybe whether it compares on the left and the right is consistent between insertion and lookup
16:18:05 <Draconx|Laptop> aavogt, it depends on the underlying tree balancing and lookup algorithms.
16:18:23 <benmachine> but then Draconx is apparently going to find us an example in which it does break in which case you can ignore my hypothesising :)
16:18:45 <Draconx|Laptop> aavogt, the trick is to force the nan to be balanced into an inner node position, at which point all nodes to one side of the nan will disappear..
16:18:47 <cdsmithus> benmachine: Yeah, I am rather convinced it's gotta be possible?
16:19:58 <cdsmithus> So anyway, this is why I think we just need a consistent Ord.  Who cares if it's the IEEE 754 one or not; that one is impossible anyway, so should be relegated to some implementation that doesn't use the Ord type class.
16:20:37 <benmachine> or we could just add selective instance importing to the language wooooo
16:21:03 <mrd> btw, I opted to create and use my own type-class and instance to do comparisons within machine epsilon, fwiw
16:21:13 <aristid> cdsmithus: which total ordering do you propose?
16:21:19 <cdsmithus> You could, but you'd still be unable to make a IEEE 754 compatible Ord instance that's still internally consistent between compare and the infix operators.
16:21:21 <benmachine> mrd: don't you still have problems when error accumulate?
16:21:45 <cdsmithus> aristid: I don't care.  Make -inf < ... < -0 < 0 < ... < +inf < nan... that works
16:21:50 <benmachine> cdsmithus: well generally it'd just be a massive mess I think
16:21:57 <ddarius> benmachine: He just returns bogus results.
16:22:11 <ddarius> Or he is very careful.
16:22:14 <aristid> cdsmithus: why not nan < -inf, then it would be compatible with Nothing
16:22:18 <Draconx|Laptop> cdsmithus, sure, but defining functions that nobody will use is pointless.  Just kill the instance.
16:22:21 <cdsmithus> aristid: fine.
16:22:22 <mrd> benmachine: for my uses I don't think it matters, computer graphics
16:22:23 <benmachine> *Errors
16:22:28 <benmachine> mrd: if you say so :P
16:22:41 <cdsmithus> Draconx: Then I can't have a Set Float?
16:22:41 <soupdragon> put nan between -0 and 0
16:22:51 <ddarius> mrd: It will probably only matter in extreme cases, but it can matter significantly then.
16:22:51 <aristid> cdsmithus: although i'm not sure if i like putting nan in a random place
16:22:55 <mrd> yea
16:22:57 <Draconx|Laptop> cdsmithus, nope.
16:23:12 <Saizan> i'd have it between 3 and 4
16:23:13 <Draconx|Laptop> cdsmithus, if you want a Set Float, you're using the wrong data type.
16:23:29 <benmachine> s/Set //
16:23:31 <cdsmithus> Draconx: I certainly don't believe that.
16:23:31 <benmachine> :P
16:24:09 <benmachine> it's reasonable to ask for a Set (Complex Double) as well
16:24:13 <benmachine> implementationwise it can be done
16:24:22 <aristid> benmachine: it doesn't make sense to use
16:24:31 <benmachine> aristid: how so?
16:24:32 <aristid> there's no reasonable use case that i can think of
16:24:46 <benmachine> can you think of a reasonable use case for Set Integer?
16:25:08 <Taejo> benmachine: well to have a meaningful set, you need meaningful equality
16:25:16 <benmachine> Taejo: I guess that's true
16:25:28 <benmachine> but meaningful Float equality isn't completely impossible
16:25:37 * ddarius whispers "intervals"
16:25:54 <Taejo> ddarius: ?
16:25:54 <aristid> benmachine: yes, i can think of a use case for Set Integer
16:26:06 <Taejo> speak up, ddarius, I can't hear you
16:26:10 <benmachine> aristid: I'm too sleepy
16:26:37 <aristid> benmachine: i should long have gone to bed too! gotta wake up in 5 hours
16:27:01 <aristid> benmachine: good night then.
16:27:18 <benmachine> I've gotta wake up in... hmm about 33 hours
16:27:32 <benmachine> but I'm *going* to wake up in eight because I'm not a complete layabout >_>
16:27:51 * benmachine .
16:28:14 <cdsmithus> So I don't know what the problem is... lots of use cases for Set Float.  Suppose I want to keep track of what values occur, to the greatest precision I have them in, and then extract a range of them later.  There are worse ways than keeping a Set, then using Set.toList at the end
16:29:09 <ddarius> cdsmithus: Why not just use a list?
16:29:18 <cdsmithus> ddarius: O(n) insertion times?
16:29:54 <cdsmithus> I suppose an unsorted list
16:30:48 <cdsmithus> Or, to introduce the obvious whole class of examples, I could be working for Float not as an approximation to real numbers, but rather *as* IEEE floating point values.  Then I have equality just fine
16:35:14 <ElMarsh> are there any good computer science channels?
16:35:45 <alpounet> #ælgorithms ? maybe
16:36:06 <ElMarsh> thanks, I'll check it out
16:37:54 <cdsmithus> Or, if you want another example, I could have a static data set of spatial data, where the locations of an object are fixed (the same float every time), and I still want to store certain data indexed by those locations.  Then a Map (Float, Float) Properties may be exactly what I want
16:39:08 <cdsmithus> So the point is, if IEEE 754 behavior were implemented elsewhere (probably without the Ord type class that doesn't fit), then a correct Ord instance for Float would be entirely usable.
16:39:41 <dpratt71> so if I'm setting up an install of Ubuntu (10.4) expressly for the purpose of Haskell-hacking, besides cabal, what ought I install?
16:40:14 <cdsmithus> dpratt: Install GHC, and then the platform from the haskell platform web site.  Then cabal install anything else
16:41:22 <cdsmithus> You'll likely need some lib*-dev packages, but you'll be told as you go which they are
16:42:28 <dpratt71> cdsmithus: ok; would installing a "cabal-install" package through the package manager accomplish largely the same thing?
16:43:07 <cdsmithus> dpratt71: You wouldn't get the platform.  I think it's a good idea to just install the haskell platform as one.
16:44:03 <cdsmithus> The Haskell Platform is a collection of central, well-tested libraries that we know work together.  A great starting point for Haskell, then install other packages as needed
16:44:44 <cdsmithus> I believe the intent is to ultimately have a haskell-platform package in Ubuntu.  It's not there yet, though
16:45:03 <dpratt71> cdsmithus: ok; any thoughts as to accompanying utilities, editors, other?
16:45:13 <blackdog> dpratt71: emacs + ghc-mod
16:45:13 <lambdabot> blackdog: You have 1 new message. '/msg lambdabot @messages' to read it.
16:45:30 <Draconx|Laptop> cdsmithus, there are much, much better data structures than Map Float Float for spatial lookups, ones that don't require you to pull keys out of a hat.
16:45:50 <dpratt71> blackdog: I'll check that out, thanks
16:45:51 <blackdog> @tell ivanm kensington.
16:45:52 <lambdabot> Consider it noted.
16:46:01 <blackdog> @tell ivanm maybe kingsford.
16:46:01 <lambdabot> Consider it noted.
16:46:39 * hackagebot Semigroup 0.0.4 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.4 (TonyMorris)
16:47:18 <erikc> has anyone built the haskell platform on aix?
16:48:13 <erikc> can a registerised ghc be built on ghc?
16:48:30 <blackdog> erikc: (unhelpful, but surprised: you're using aix?)
16:48:31 <cdsmithus> Draconx: Perhaps... but I'm going to start out using Map (Float, Float) because it's what I know, and it's going to work just fine, and I'll save the time unless I run into a situation where "better" matters.  Unless, of course, you yank the Ord instance for Float... which works fine today, by the way, as long as I don't do something silly like put infinities or nans in the map
16:49:09 <cdsmithus> I'd love to see it fixed.  But taking it away is just user-hostile
16:49:17 <Draconx|Laptop> cdsmithus, unless you know the keys in advance, floating keys for maps are not very useful.  If you know the keys in advance, there's little reason to be using floating point.
16:49:26 <erikc> blackdog: work at ibm, so a mix of zos/aix/linux
16:49:34 <cdsmithus> What about the reason that it's what I was provided with?
16:49:41 <cdsmithus> from some other data source
16:49:48 <erikc> err, i meant can a registerised ghc be built on ppc
16:50:04 <blackdog> erikc: ah, for a moment I thought you were erik de castro lopo. mistaken identity, sorry.
16:50:08 <erikc> ah hehe
16:50:12 <Pseudonym> BTW, if sort of Float makes sense, then Float as a sort key makes sense.
16:50:19 <Pseudonym> Sorry, Float as a map key.
16:50:26 <Pseudonym> Because sort can be implemented in terms of Map.
16:50:32 <blackdog> Pseudonym: "sort of Float" could be called "Floaty", perhaps...
16:51:38 <Pseudonym> There are situations, in particular, where == on floating-point types makes perfect sense.
16:51:55 <Pseudonym> If you convert a 32-bit integer to a Double and back, it'd better be lossless, otherwise the implementation is broken.
16:52:24 <Draconx|Laptop> I don't disagree with your statement about == sometimes making sense, but your example has nothing to do with that.
16:52:38 <Pseudonym> Of course.  I'm just making the point.
16:52:47 <Pseudonym> Well...
16:52:47 <Draconx|Laptop> with an irrelevant example?
16:52:49 <Pseudonym> Actually, no.
16:53:04 <Pseudonym> Imagine a scripting language where you need to store a union of monotypes.
16:53:05 <cdsmithus> Pseudonym: Sure, but Int32 -> Double -> Int32 is just accidental in a sense, though.  More significant is your sort example, or mine where I have a fixed set of data to manipulate.
16:53:12 <Pseudonym> Presumably as a discriminated union.
16:53:31 <Pseudonym> If you need to store a Double and an Int32, then you can save a tag.
16:53:36 * Pseudonym has done something very similar
16:55:36 <Pseudonym> So I guess that's relevant.
16:56:17 <cdsmithus> The sort example is a good one.  Fundamentally the same as things I was saying earlier: from the definition of the problem, you know a set of values that you care about.
16:56:36 <Draconx|Laptop> cdsmithus, so, why are you using floating point when you know the values in advance?
16:57:14 <cdsmithus> Because what I'm trying to do is sort a list of floating point values?
16:57:16 <juhp> preflex: seen ivanm
16:57:16 <preflex>  ivanm was last seen on #haskell 9 hours, 50 minutes and 59 seconds ago, saying: you want lambdabot to trace your IP address or something? :p
16:58:51 <cdsmithus> Ultimately, here's the point: at the global level, in an entire application (or, perhaps, collection of applications and associated network protocols), maybe I could have chosen a different data type.  But, right now, in a particular piece of code, maybe I've got a bunch of Floats and I want to do something with them.
16:59:00 <Draconx|Laptop> cdsmithus, ok.
16:59:21 <aavogt> Draconx|Laptop: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25432#a25432
17:00:28 <aavogt> so   insert x, insert NaN, insert (x+delta)   makes things unreachable
17:00:43 <JoeyA> This is elegant as it is, but can I factor down the syntax even further?  let (xs,ys) = span ((/= pos) . fst) $ reverse history
17:01:37 <aavogt> you don't gain anything by using a section there
17:01:39 <cdsmithus> aavogt: Nice!  So at least the Map problem with the current Ord instance is concrete
17:01:47 <Draconx|Laptop> aavogt, ah yes, makes sense.
17:02:48 <JoeyA> aavogt: Was that to me or to someone else?
17:03:12 <aavogt> yes, I was going to write    span ((/=) pos . fst)
17:03:22 <aavogt> or    break ((==) pos . fst)
17:03:28 <aavogt> it's really arbitrary
17:03:34 <JoeyA> ah
17:03:39 <cdsmithus> I think the section is clearer, personally
17:03:55 <JoeyA> I figured out I could pull pos out, but I thought (/= pos) was clearer
17:04:11 <JoeyA> and I'm glad to know about break
17:04:34 <aavogt> @hoogle a -> [(a,b)] -> ([(a,b)],[(a,b)])
17:04:35 <lambdabot> No results found
17:04:38 <JoeyA> I'm not code golfing, so the extra character doesn't matter :)
17:04:54 <aavogt> @type lookup
17:04:55 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:05:50 <JoeyA> @type until
17:05:51 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:07:12 <Draconx|Laptop> cdsmithus, so, it's still not clear to me why Data.Map (Float, Float) is a good idea in this case.
17:08:19 <dpratt71> how does cabal decide where to put cabal?; I have two versions, of course, one at "/usr/bin/cabal", one at "~/.cabal/bin"
17:11:25 <aavogt> dpratt71: by default it will go in ~/.cabal/bin, unless you say otherwise in the config file, or with the flag --global
17:13:51 <dpratt71> aavogt: thanks; not a very experienced Linux user, I fear; should I add "~/.cabal/bin" to the path?
17:14:03 <aavogt> definitely
17:14:50 <dpratt71> aavogt: thanks; now lemme see if I can remember how to do that :) ...
17:18:50 <BitingTreeFerret> how do I get the HWND when making a Windows GUI program?
17:19:09 <cdsmithus> Draconx: I'm not sure how to continue this.  I suppose I should back up, and just say that I think a change that makes "if x < 3.5 then y else z" a type error... is just not feasible.  This despite that fact that certain floating point comparisons are problematic
17:20:20 <cdsmithus> And perhaps you can find a better data structure for the same problem we discussed, but the fact remains that had I been solving that problem, I might be done by now using Map (Float, Float) a
17:20:22 <Draconx|Laptop> cdsmithus, I too would like that to not be a type error.
17:21:00 <cdsmithus> The ^sample problem, I meant to type
17:21:18 <Draconx|Laptop> cdsmithus, I wish the <, <=, >= and > operators didn't come with the assumption that they totally order a data type.
17:23:28 <cdsmithus> Well, or partially, or... anything really.  If you're willing to ignore documentation, you can make Ord represent a pre-order (but it won't be compatible with Eq)
17:23:39 <cdsmithus> But, IEEE rules for Float aren't even a pre-order
17:24:10 <Draconx|Laptop> they satisfy a restricted definition of partial order, which is for all intents and purposes good enough.
17:24:59 <Draconx|Laptop> and that is: "x == x implies x <= x" and "x <= y && y <= x implies x == y", plus transitivity.
17:29:06 <applicative> BitingTreeFerret, I don't know anything about Windows.  But what library are you using for making a program?
17:30:19 <JoeyA> When working with Integers, is it possible to avoid having to apply fromIntegral every time it comes into contact with Int?  (particularly when functions like length are involved)
17:30:27 <pastorn> BitingTreeFerret: HWND?
17:30:57 <applicative> pastorn, it is a handle type associate with a window
17:31:02 <applicative> if i understand
17:31:16 <monochrom> Yes.
17:37:01 <pastorn> BitingTreeFerret: http://hackage.haskell.org/package/Win32
17:37:02 <jimbo1> Hello everyone!  Quick, easy question from a haskell newbie.
17:37:04 <pastorn> somewhere in there
17:37:33 <jimbo1> If I have a list like [x,y,z] and I want it to turn into [x, x+y, x+y+z]
17:37:37 <jimbo1> How can I do that?
17:37:48 <pastorn> @type scanl
17:37:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:37:49 <wli> scanl1 (+)
17:37:55 <aavogt> > scanl1 (+) [x,y,z] :: [Expr]
17:37:56 * hackagebot sox 0.2.0.1 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.0.1 (HenningThielemann)
17:37:56 <lambdabot>   [x,x + y,x + y + z]
17:38:11 <jimbo1> Perfect, I thought it was fold or something, but it's scan..
17:38:17 <pikhq> jimbo1: \[x,y,z] -> [x, x+y, x+y+z]
17:38:20 <pikhq> :P
17:38:33 <jimbo1> :)
17:39:34 <danharaj> How would you express 'primitive recursion' over lists with fold and accompanying functions?
17:40:02 <ezyang> Hmm, I wonder if anyone has DPH-ized the nofib benchmarks
17:40:37 <aavogt> I don't think that the calculations in nofib could benefit much?
17:41:04 <ezyang> aavogt: Possibly. I haven't looked too closely yet.
17:41:22 <ezyang> I'm looking for simple problems to parallelize and am having hard time finding them :o)
17:41:28 <ezyang> *having a
17:42:28 <aavogt> danharaj: 'primitive recursion' isn't one specific thing
17:42:37 <ElMarsh> something to parallelize?
17:42:38 <ElMarsh> anything?
17:42:52 <Cale> danharaj: if you have a function  g [] = z; g (x:xs) = f x (g xs), then g = foldr f z
17:42:57 <ezyang> sure... but using NDP
17:42:59 <Cale> danharaj: Is that what you mean?
17:43:11 <aavogt> it would get rather awkward to write in terms of a fold a function that looks at multiple elements at the same time
17:43:24 <soupdragon> primitive recursion? in the sense of primitive recursive function?
17:43:54 <danharaj> Well, let's say we define fold, etc. on the natural numbers in the natural way, how would you encapsulate the definition of primitive recursion as a single signature? and then take that and transate it to recursion schemes over lists.
17:44:03 * aavogt wonders if it is possible to have a @fold and @unfold
17:44:19 <soupdragon> Can you please define primitive recursion
17:44:23 <uorygl> So, I've been mulling over colimits.
17:44:26 <ezyang> that would be pretty cool
17:44:45 <danharaj> soupdragon: http://en.wikipedia.org/wiki/Primitive_recursive_function#Definition
17:45:08 <uorygl> It's pretty clear what they are when J is a discrete category.
17:45:15 <soupdragon> right, so in the sense of primitive recursive function.
17:45:22 <danharaj> aavogt: The way I interpret it, fold corresponds to inductive definitions, and some other function corresponds to strong inductive definitions.
17:45:25 <uorygl> Then it seems like whenever you have arrows, you just glue their inputs and outputs together.
17:45:38 <Cale> uorygl: yeah, that's the right intuition :)
17:46:54 <JoeyA> Does the length function take linear time, or is the size of lists cached?
17:47:05 <cdsmithus> JoeyA: It's linear.
17:47:18 <Cale> You might start with foldNat z s Zero = Zero; foldNat z s (Succ n) = s (foldNat z s n)
17:47:26 <Cale> Perhaps.
17:47:41 <soupdragon> danharaj: fold corresponds to inductive-elimination
17:47:57 <cdsmithus> JoeyA: In general, you might not even know the length of a list, without doing some arbitrary computation, so that isn't done until you ask
17:48:01 <uorygl> I'm tempted to use limits and/or colimits to define the real numbers.  Couldn't be too hard, I'm sure.  :P
17:49:06 <uorygl> So, what next?
17:49:50 <ezyang> Ooh, I bet I could use DPH for nondeterministic Turing machines
17:50:37 <soupdragon> ISTR that some nondeterministic turing machines are super-turing?
17:51:09 <Cale> soupdragon: no, you can simulate an NTM with a TM, it just might take exponentially longer to run
17:51:41 <uorygl> What does it mean to say that an NTM halts?
17:52:00 <monochrom> when some execution halts
17:52:01 <cdsmithus> uorygl: it means that there is some sequence of choices such that it halts.
17:52:47 <uorygl> Okay.  Take this algorithm: Receive a Turing machine as input.  Pick an arbitrary natural number.  Run the Turing machine that many steps.  If it hasn't halted yet, loop forever.
17:53:06 <uorygl> Hmm, wait.
17:53:21 <uorygl> That halts if its input halts and does not halt otherwise.  That's not exactly solving the halting problem, is it.  :P
17:53:30 <uorygl> So Cale's right.
17:53:33 <ezyang> uorygl: The halting problem is still not solvable for NTM.
17:53:41 <ezyang> Or with NTM, for that matter.
17:54:06 <kmc> yes, DTM and NTM both decide the same computability class, the class of recursive languages
17:54:17 <kmc> "general recursive" as opposed to "primitive recursive"
17:54:45 <kmc> a simple model of PR is an imperative program where each FOR loop has an upper bound which is known before the loop starts
17:54:55 <kmc> rather than a WHILE loop which can exit "unexpectedly"
17:54:58 <cdsmithus> When you think about complexity classes, though, they are quite different.  And then you can also meet their weird cousins, the alternating Turing machines.
17:55:52 <uorygl> Hmm.  For a parallel processor with infinitely many cores, I suppose in practice, P = NP.  So you can sort of say that either parallelization is useful or NP-complete problems are easy, yes?
17:56:21 <kmc> under this unrealistic model of parallelization, yes
17:56:30 <dpratt71> when I "make" the Haskell platform, I get an error:
17:56:32 <dpratt71> Control/Monad/Cont.hs:74:7:
17:56:32 <monochrom> if you have so many cores.
17:56:34 <dpratt71>     Could not find module `Control.Monad':
17:56:40 <cdsmithus> uorygl: Not so fast.  There are classes of efficiently parallelizable algorithms... they aren't just nondeterministic machines.
17:56:54 <kmc> for a more realistic model, even P-complete problems are difficult to parallelize
17:57:01 <kmc> that's one of the interpretations of the class P-complete
17:57:22 <ezyang> Well, if you have infinite cores, you just run each core on every possible solution and return the one that gives you the certificate.
17:57:24 <kmc> NC is described as the class of problems efficiently solvable on a parallel computer
17:57:40 <ezyang> s/solution/certificates/ s/certificate/verified/
17:57:43 <kmc> a more realistic example for NP might be a self-reproducing computer
17:57:53 <kmc> which will use polynomial time but exponential matter/energy
17:58:00 <uorygl> Humans are self-reproducing computers.  :P
17:58:05 <kmc> also reminds me of the classical-optical solution to the Traveling Salesman Problem
17:58:21 <kmc> which uses each photon as an independent thread of execution
17:58:32 <kmc> hence polynomial time, but exponential energy
17:58:51 <danharaj> It's interesting that you can even make that conversion.
17:59:06 <cdsmithus> The problem with "infinite cores" is the amount of communication that needs to happen.  If you *also* assume infinite memory bandwidth in a coherent shared memory, then I agree that they could run any NP problem in polynomial time
17:59:19 <kmc> NP requires no communication though, except at the end
17:59:55 <cdsmithus> It certainly requires copying the state of the machine.
18:00:09 <kmc> that's true
18:00:18 <cdsmithus> Or sharing it in some kind of copy on write scenario
18:00:28 <kmc> i'm assuming your infinite processors are arranged in an infinite binary tree
18:00:39 <kmc> in which case you only need to communicate to your immediate children
18:00:40 <cdsmithus> The latter can be seen as "constant time"... if you have infinite memory bandwidth
18:00:55 <kmc> but it's rather difficult to think about, because it's unrealistic
18:01:10 <kmc> i think the computer that gets twice as fast after each instruction is in a way more realistic, but it's actually a hypercomputer
18:01:28 <danharaj> That thing violates quantum mechanics.
18:01:35 <kmc> does it?
18:01:48 <danharaj> Well, it seems so heuristically.
18:02:58 <danharaj> The less time that passes, the more uncertainty plays a factor. You are making uncertainty arbitrarily high. Or something like that.
18:04:12 <danharaj> hell, it violates classical mechanics. You have to do an infinite amount of work in a finite amount of time.
18:04:31 <danharaj> (Because it can compute chaitin's constant which has infinitely many bits of information)
18:05:03 <ezyang> Infinite processors is actually a useful thing to think about
18:05:13 <soupdragon> okay I have figured out a haskell program to write!
18:05:15 <ezyang> Because it tells you what the depth of your parallel problem is.
18:05:50 <cdsmithus> soupdragon: And it is?  (Hopefully none of this infinite cores stuff!)
18:06:09 <soupdragon> I want to grow a crystal (3D model)
18:08:16 <ddarius> soupdragon: Get some sugar and some water.
18:11:24 <JoeyA> Is there a function/set of functions for applying a function to the items in a tuple?
18:11:37 <pastorn> @type (***)
18:11:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:11:42 <ezyang> actually, I don't think I can data parallelize the tape
18:11:44 <pastorn> @type (&&&)
18:11:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:11:54 <ezyang> boy, dph seems pretty hobbled
18:11:58 <pastorn> ((+1) &&& (0,0))
18:12:03 <pastorn> > ((+1) &&& (0,0))
18:12:03 <lambdabot>   Couldn't match expected type `b -> c''
18:12:04 <lambdabot>         against inferred type `(t, t...
18:12:08 <pastorn> argh
18:12:26 <pastorn> > ((+1) *** (0,0))
18:12:27 <lambdabot>   Couldn't match expected type `b' -> c''
18:12:27 <lambdabot>         against inferred type `(t, ...
18:14:05 * hackagebot proc 0.0.2 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.2 (AndyStewart)
18:14:14 <dpratt71> yikes! why do I have a hard time believing that people who like Haskell also like Emacs? seems seriously complicated
18:14:37 <pastorn> dpratt71: i like haskell and dislike emacs
18:14:52 <pastorn> i only use ED THE STANDARD EDITOR
18:14:55 <ezyang> vim vim vim
18:15:05 <aavogt> @google ed the horse
18:15:06 <lambdabot> http://en.wikipedia.org/wiki/Mister_Ed
18:15:06 <lambdabot> Title: Mister Ed - Wikipedia, the free encyclopedia
18:15:19 <pikhq> dpratt71: We're mostly Unicians. And as such, are fairly normal participants in the great Editor Wars.
18:15:25 <pastorn> ezyang: VI VI VI, the editor of the beast
18:15:33 <LeNsTR> emacs? ^_^`
18:15:35 <danharaj> I use notepad.
18:15:39 <ddarius> pikhq: I started vim on Windows and then later Haskell on Windows.
18:15:43 <LeNsTR> hah)
18:15:49 <pikhq> danharaj is the real freak here. :)
18:15:59 <pikhq> ddarius: Yeah, but that's not exactly the norm. :P
18:16:01 <danharaj> Well, notepad++
18:16:14 <pikhq> Oh, never mind then. Just a Win32ite, then.
18:16:21 <danharaj> But it's basically notepad with syntax highlighting
18:16:22 <dpratt71> I was using Notepad++ on Windows
18:16:46 <danharaj> I was thinking of trying to learn emacs so I could use haskell mode, but I don't want to grow a neckbeard and give up soap.
18:16:49 <dpratt71> looking for a good editor on Linux
18:16:56 <tomberek> key danharaj, ezyang
18:17:05 <danharaj> :d
18:17:10 <pikhq> danharaj: Come on, man, that's not all Emacs users.
18:17:15 <pikhq> Many of us know how to use soap.
18:17:17 <danharaj> No, but it's amusing to think of them that way.
18:17:19 <pikhq> :)
18:17:29 <danharaj> I have several clean shaven friends who use it.
18:17:31 <pikhq> The neckbeard, however, is entirely accurate.
18:18:02 <danharaj> Ok, I should be figuring out the poincare lemma instead of making fun of lunix and emacs on the internet.
18:18:09 <JoeyA> @hoogle (a -> b) -> (a, a) -> (b, b)
18:18:10 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:18:10 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
18:18:10 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
18:18:23 <dpratt71> I can't even figure out how to File -> New in Emacs :(
18:18:23 <gwern> @quote Galois
18:18:23 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
18:18:31 <Adamant> danharaj: probably a good idea when you still use Notepad :P
18:18:42 <pastorn> JoeyA: import Control.Arrow
18:18:47 <pastorn> @type first
18:18:47 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:18:48 <LeNsTR> dpratt71: C-x C-f
18:18:48 <Adamant> I keed, I keed
18:19:01 <pastorn> @let both f = first f . second f
18:19:01 <lambdabot>  Defined.
18:19:03 <danharaj> It's only until I write my own text editor in haskell. :p
18:19:12 <pastorn> > both (+1) (0,10)
18:19:13 <lambdabot>   (1,11)
18:19:16 <pastorn> JoeyA: ^^
18:19:37 <Adamant> danharaj: oh Notepad++? that's acceptable
18:20:00 <ezyang> @quote galois
18:20:00 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
18:20:05 <ezyang> hm, only quote
18:20:12 <Adamant> @quote Shivers
18:20:12 <lambdabot> No quotes match. You untyped fool!
18:20:18 <ddarius> Why you should stay armed.
18:20:22 <DigitalKiwi> notepadd++ has 33 year outdated syntax highlighting
18:20:37 <DigitalKiwi> -d
18:20:41 <dpratt71> LeNsTR: thanks :)
18:20:43 <danharaj> It works.
18:20:45 <LeNsTR> ^^
18:21:02 <DigitalKiwi> don't believe me, try and edit some fortran in it ;D
18:21:30 <DigitalKiwi> it doesn't know anything past 77
18:21:46 <danharaj> My first problem would be writing something in fortran.
18:22:04 <DigitalKiwi> real programmers use fortran, nub
18:22:05 <soupdragon> markmanship doesn't do much good if your gun is not loaded
18:22:38 <danharaj> real programmers live in basements and smell like cheetos
18:22:53 <DigitalKiwi> s/real programmers/emacs users/
18:23:02 <LeNsTR> xD
18:30:40 <mun_> is first-order logic an application of lambda calculus?
18:31:23 <shepheb> first order logic is strictly less powerful. the LC can easily represent logic values and operations
18:31:24 <ddarius> mun_: No.
18:31:59 <mun_> so only higher-order logics are?
18:32:40 <ddarius> Higher-order logics aren't either.
18:33:06 <ddarius> The typed lambda calculus can be used to represent -a- higher order logic, but isn't necessary for higher order logic.
18:33:07 <danharaj> The lambda calculus as in the inconsistent untyped lambda calculus?
18:33:46 <mun_> right. so what's significant about lambda calculus?
18:33:55 <ddarius> Computing.
18:34:15 <soupdragon> what do you mean by saying that untyped lambda calculus is inconsistent?
18:35:18 <ddarius> soupdragon: All Turing-complete lambda calculi correspond to proof systems for inconsistent logics.
18:35:26 <soupdragon> how can you compare the powers of first order logic and lambda calculus
18:35:40 <soupdragon> ddarius, how does it correspond to any logic at all?
18:36:10 <ddarius> soupdragon: Look up the Curry-Howard correspondence.
18:36:42 <ddarius> However it doesn't really make a lot of sense to compare the lambda calculus to first order logic directly.
18:36:51 <soupdragon> ddarius, Curry-Howard talks about typed-lambda calculi
18:37:02 <ddarius> soupdragon: Untyped = unityped.
18:37:03 <soupdragon> ddarius, so are we using the type system where every term has type * say?
18:37:09 <ddarius> soupdragon: Yes.
18:37:42 <ddarius> However, even typed lambda calculi that are Turing-complete, e.g. Haskell, correspond to inconsistent logics.
18:37:50 <ddarius> Admittedly, much less trivial logics.
18:38:07 <QtPlatypus> soupdragon: In the untyped lambda calculis you can express terms like.  "Y NOT" which breaks.
18:38:14 <danharaj> Would you not need dependent typing to get a correspondance between some propositions of first order logic and terms in your typed lambda calculus?
18:38:31 <jimbo1> im getting the following error:
18:38:32 <jimbo1>     No instance for (Integral Double)       arising from a use of `^'
18:38:40 <QtPlatypus> Which is why utlc was rejected as a foundation.
18:38:50 <jimbo1> is there a ^ that will accept (Integral Double)?
18:38:56 <jimbo1> or to I need a fromIntegral or something
18:39:01 <jimbo1> do* I need
18:39:34 <ddarius> jimbo1: There are three exponentiation functions: (^), (^^) and (**)
18:39:35 <Draconx|Laptop> jimbo1, the floating point power operator is (**)
18:39:53 <jimbo1> I thought something like that existed
18:39:56 <jimbo1> Thanks
18:39:58 <jimbo1> What is ^^?
18:40:06 <soupdragon> QtPlatypus, obviously the people who were considering untyped lambda calculus as a foundation were not thinking of it in terms of curry-howard, that's why I asked in what sense is it in consistent
18:40:38 <danharaj> It has non-normalizing terms.
18:40:45 <nus> @type (^^)
18:40:46 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:40:57 <soupdragon> So what is the logical reading of a lambda term?
18:41:12 <ddarius> soupdragon: The Curry-Howard correspondence wasn't very clear in 1930 when Alonzo Church developed the lambda calculus for a foundation for logic.
18:41:34 <ddarius> soupdragon: Again, via the Curry-Howard correspondence, a lambda term corresponds to a -proof- not a proposition.
18:41:43 <soupdragon> ddarius, that is ridiculous.
18:41:48 <ddarius> soupdragon: So, application corresponds to modus ponens.
18:42:13 <soupdragon> ddarius, Nobody is going to design a foundation of 'mathematics' when there is only a single mathematical expression
18:42:34 <danharaj> heh
18:42:55 <Cale> There are an awful lot of lambda terms
18:42:57 <danharaj> In my logic class, we only had modus ponens.
18:43:01 <Cale> (infinitely many)
18:43:05 <ddarius> soupdragon: Alonzo Church wasn't trying to use the lambda calculus via Curry-Howard.
18:43:14 <soupdragon> Okay
18:43:35 <jimbo1> OK I still have an issue with that...
18:43:53 <ddarius> danharaj: That corresponds to Hilbert style proofs and from that to combinatory logic.
18:43:58 <jimbo1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25433#a25433
18:44:13 <danharaj> ddarius: Yep. :p
18:44:14 <JoeyA> Where is the where keyword syntactically valid?
18:44:16 <JoeyA> > a+a where a=2
18:44:17 <lambdabot>   <no location info>: parse error on input `where'
18:44:20 <jimbo1> Is this because of the **?
18:44:22 <JoeyA> > let b = a+a where a=2
18:44:24 <lambdabot>   not an expression: `let b = a+a where a=2'
18:44:39 <ddarius> danharaj: It's a painful way to do proofs.
18:44:40 <JoeyA> err,
18:44:47 <aavogt> > let x = y where y = 1 in x
18:44:49 <Cale> jimbo1: (^) is exponentiation with any base and non-negative integer exponents, (^^) is exponentation with fractional bases and arbitrary integer exponents, (**) is exponentiation with floating point base and exponent.
18:44:49 <lambdabot>   1
18:44:50 <JoeyA> > let b = a+a where a=2 in a
18:44:51 <lambdabot>   a
18:44:55 <danharaj> ddarius: I agree. But it was also elegant in its parsimony.
18:45:05 <JoeyA> > let b = a+a where a=2 in b
18:45:06 <lambdabot>   4
18:45:14 <soupdragon> So what was the idea for using lambda calculus as a foundation?
18:45:15 <Makoryu> :t a
18:45:16 <lambdabot> Expr
18:45:17 <nus> @type (:+)
18:45:18 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
18:45:24 <jimbo1> Cale: OK, but I'm still not sure what to do here
18:45:24 <soupdragon> What sort of logical reading would you give to the terms?
18:45:29 <ddarius> danharaj: It's great for proving metatheoretic properties about the logic, it's not great for actually using.
18:45:42 <ddarius> soupdragon: Why do they need a logical reading?
18:45:45 <jimbo1> It isn't the exp
18:45:57 <Cale> jimbo1: Is cumPhases a list of lists of doubles?
18:46:03 <soupdragon> ddarius, because that's how you do mathematics
18:46:09 <jimbo1> A list of lists of Complex numbers
18:46:12 <nus> @type (0 :+ 1)
18:46:13 <lambdabot> forall t. (RealFloat t) => Complex t
18:46:16 <nus> @type (**)
18:46:17 <jimbo1> Oh, actually let me look
18:46:17 <lambdabot> forall a. (Floating a) => a -> a -> a
18:46:34 <jimbo1> Yes, I think it is a list of list of Doubles
18:46:37 <soupdragon> if you cannot write some term that means (i.e. is read as)   forall x y, x + y = y + x   then you cannot do arithmetic
18:46:55 <Cale> jimbo1: So you'll have to convert -- an easy way would just be to replace f with f :+ 0
18:47:05 <Cale> jimbo1: You could also use realToFrac
18:47:12 <jimbo1> Great idea to add the :+ 0
18:47:30 <jimbo1> Worked like a charm
18:47:56 <cdsmithus> jimbo1: Try **, if the exponent is a floating point number
18:48:02 <cdsmithus> eep
18:48:05 <cdsmithus> That was old
18:48:09 <cdsmithus> :)
18:48:28 <jimbo1> cdsmithus: Yep, I'm using it
18:48:39 <cdsmithus> Sorry 'bout that!  My IRC client stops scrolling down sometimes, so I end up responding to stuff from 30 minutes ago!
18:48:49 <jimbo1> :) NP
18:53:25 <soupdragon> Chuchs system is not lambda-calculus
18:54:08 <soupdragon> The terms are  { } ( ) \[ ]  PI SIGMA AND NOT IOTA A
18:55:39 <soupdragon> then you can define things like e.g. Exists := \pi SIGMA phi. phi(pi)
18:57:04 <soupdragon> I don't know how to read this one but    Implies := \u \v -> ~ . u ~. ~ v
18:57:32 <soupdragon> then axioms such as  Implies pq p  are postulated
18:58:28 <soupdragon> It's kind of surprising that this system is inconsistent, because beta reduction is confluent
19:00:16 <soupdragon> I wonder what the actual contradiction found was?
19:16:24 <uorygl> Looking up, I got the idea that there was a Unicode character called "PI SIGMA AND NOT IOTA A".  Turns out I'm wrong.
19:17:07 <uorygl> What a strange character that would be, a letter blended with two other letters but not a third.
19:17:20 <monochrom> hehe yeah!
19:17:46 <uorygl> Of course, there's no indication as to whether it's uppercase or lowercase...
19:18:01 <monochrom> allegro con brio ma no troppo
19:18:08 <monochrom> s/no/non/
19:36:54 <djahandarie> Ugh, does someone know the name of this category theory construct? I can't remember where I read it... d f g = c f (fmap return . g) . return
19:37:28 <djahandarie> Hm, edwardk would probably but he's not here
19:39:42 <ddarius> What is c?
19:40:06 <djahandarie> It'd be easier if I knew that
19:40:17 <djahandarie> I just have that nugget in my head
19:40:41 * djahandarie reminds himself to remember more useful stuff
19:40:43 <nus> soupdragon, Kleene, Rosser. "The inconsistency of certain formal logics"
19:42:17 <soupdragon> cool ty
19:42:58 <djahandarie> ddarius, if I remember correctly d and c are kernels for morphisms
19:44:01 <djahandarie> Ah, it was d' f g = c' f (fmap return . h) . return   and then d f g = something . d' f g
19:44:33 <djahandarie> So you could construct d through its kernel d' which is a manipulation of c'
19:45:05 <djahandarie> Still have no idea what d and c are though
19:45:21 <djahandarie> Whoooa where'd that h come from
19:45:44 <djahandarie> d' f g = c' f (fmap return . g) . return; d f g = something . d' f g
19:46:00 <djahandarie> Now just need to keep looking at morphisms until one rings a bell
19:48:26 <soupdragon> > 1/(sqrt(7)-2)
19:48:26 <lambdabot>   1.5485837703548633
19:49:26 <soupdragon> > (sqrt(7)+2)/11
19:49:27 <lambdabot>   0.42234102827859915
19:49:46 <soupdragon> > (sqrt(7)+2)/3
19:49:47 <lambdabot>   1.5485837703548635
19:53:28 <djahandarie> ddarius, http://comonad.com/reader/2008/dynamorphisms-as-chronomorphisms/
19:53:40 <djahandarie> I guess I was right that edwardk would know about it, lol
19:57:11 <kmc> this "Harnessing the Multicores: Nested Data Parallelism in Haskell" paper is full of typos :/
19:59:04 <djahandarie> kmc... you mean the one by spj?
19:59:12 <djahandarie> And rl and chakravarty
19:59:17 <djahandarie> Forget who else
19:59:20 <kmc> yeah
19:59:24 <djahandarie> Seems like they'd have someone proof read...
19:59:36 <kmc> yeah
19:59:40 <kmc> maybe i have a preprint or something?
20:00:11 <djahandarie> That's what I was thinking. spj has a copy on his site
20:00:56 <kmc> yeah, that's the one i have
20:01:19 <kmc> pg 11-12, every "class" except the first should be "instance".  unless i'm seriously crazy
20:01:51 <kmc> it seems like an awesome paper otherwise
20:01:57 <kmc> and the talk was very good
20:03:36 <JoeyA> :( Haskell isn't lazy enough with this:  http://codepad.org/LVn3f7h6
20:04:03 <JoeyA> I tried to make a function called 'ones' that generates an Integer with all bits set to 1, then test the 5th bit of it.
20:04:42 <kmc> an Integer can contain a potentially infinite number of bits
20:04:51 <kmc> and yes, they're strict
20:04:54 <JoeyA> In my case, ones contains infinitely many bits
20:05:22 <kmc> you could implement a lazier bitvector type, though
20:05:37 <kmc> calling it "Integer" wouldn't really be appropriate, imo
20:06:11 <JoeyA> kmc> Agreed :)
20:06:39 <djahandarie> kmc, oh wow, you're right
20:07:10 <djahandarie> kmc, yeah, you're definitely right
20:07:57 <JoeyA> I suppose I could do it with an Array?
20:08:06 <JoeyA> I need to learn how to make arrays (not lists) in Haskell
20:08:48 <kmc> Array might not be lazy enough, either
20:08:54 <pastorn> JoeyA: it's not that hard
20:08:57 <kmc> what're you trying to do, exactly?
20:09:10 <pastorn> JoeyA: use arrayList and ! instead of !!
20:09:13 <JoeyA> I want to write an efficient primes generator for the sake of learning.
20:09:29 <JoeyA> I'm starting with the simpler case of a bitmap set to all 1s
20:09:31 <gwern> we had best tell JoeyA nothing
20:09:59 <gwern> 'Jimmy Tightlips, where'd they shoot you?' 'I ain't saying nutting'
20:10:28 <kmc> haha
20:10:38 <pastorn> JoeyA: when using haskell arrays you should consider applications where you mostly read and almost never do any writing to them
20:10:45 <JoeyA> I'm trying to push lazy evaluation to the limits, and I'd rather not keep running into walls.
20:11:02 <kmc> pastorn, that's true with the immutable Array
20:11:20 <pastorn> JoeyA: but if you use STArray, then it's a different story
20:11:23 <kmc> the mutable IOArray / STArray are fine for read/write like any other imperative language
20:11:36 <kmc> though you may want unboxed types, or you may want to take extra care with strictness
20:11:39 <kmc> and there's also "vector"
20:11:54 <gwern> @quote array
20:11:55 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
20:12:44 <kmc> heh yes
20:13:32 <gwern> @remember gwern Haskell has the best arrays around; problem is, we don't know which module it is.
20:13:32 <lambdabot> Okay.
20:13:39 <_root> Hello.
20:13:40 <kmc> hehehe
20:13:41 <kmc> hi _root
20:13:44 <_root> Yes.
20:14:30 <monochrom> But what are arrays really?
20:14:40 <_root> monochrom: What is a variable?
20:14:49 <kmc> what is love?
20:14:57 <monochrom> I don't know that either. What is a variable?
20:14:58 <ddarius> Baby don't hurt me.
20:15:03 <max_atre1des> baby don't hurt me.
20:15:06 <max_atre1des> no more.
20:15:09 <_root> monochrom: You are probably better off having a book.
20:16:03 <monochrom> I haven't seen a book that really says what a variable is. They say how to use variables, sure; not what it is.
20:16:13 <gwern> one's man variable is another man's constant
20:16:39 <monochrom> one variable's man is another constant's woman
20:17:06 <_root> monochrom: What is a value?
20:17:09 <nus> depends on the interpreter (^:
20:17:22 <max_atre1des> penny is my constant
20:17:44 <gwern> lisp programmers know the value of everything and the cost of nothing; haskellers don't even know that
20:18:08 <soupdragon> lol
20:18:11 <gwern> hm, CS house. I thought about joiing that
20:18:28 <gwern> CS house had a nice collection of equipment; I wish I had played with their lisp machines
20:19:26 <gwern> (I wonder how their soda machine is doing)
20:20:20 <monochrom> pure transparent soda
20:20:35 <_root> This channel is useless for intellectual advancement.
20:20:53 <kmc> _root, not in my experience
20:20:56 <ddarius> _root: Indeed.  Read a book.
20:21:01 <kmc> you could ask a question or propose a topic
20:21:02 <monochrom> haha
20:21:03 <gwern> _root: until cale comes around and delivers an impromptu lecture, of course
20:21:05 <kmc> or just hang around a while
20:21:07 <_root> ddarius: You probably don't want to speak to me that way.
20:21:22 <wli> _root: Meditate.
20:21:23 <kmc> i have a *good feeling* about this
20:21:38 <gwern> _root: why not? are you the revenant of lilo who will k-line any brothers who dis you?
20:21:38 <_root> wli: That does nothing.
20:21:55 <_root> gwern: http://antisec.wordpress.com discusses that particular problem.
20:22:53 <soupdragon> uh. is there some kind of scripted play going on here impromptu?
20:23:06 <soupdragon> (I should not interrupt)
20:23:20 <gwern> _root: how is that relevant?
20:23:44 <_root> gwern: The same way your outburst was.
20:24:06 <_root> I would like to discuss polymorphic first class labels.
20:24:20 <soupdragon> Haskell doesn't have that
20:24:25 <gwern> _root: my point was that you are not of any significance that I know of here; if you don't wish to be condescended to, do something to stop that like raise a good topic
20:24:29 <kmc> there was a recent blog post
20:24:31 <_root> soupdragon: Why not?
20:24:34 <_root> kmc: Yes.
20:24:39 <_root> kmc: This is why I wanted to discuss them.
20:24:49 <_root> soupdragon: Maybe you want to elaborate further.
20:24:59 <djahandarie> There is actually a ticket for that in prime
20:24:59 <_root> gwern: I'm not of "any significance" ?
20:24:59 <kmc> you could link the post for those who did not see it
20:25:06 <kmc> sigh
20:25:08 <_root> kmc: Don't have it.
20:25:08 <Cale> _root: "What is a variable?" and "What is a value?" are to some extent philosophical questions. I could give you some possible answers to them, but there are a lot of ways you could set things up.
20:25:18 <_root> kmc: Found it at work, but I don't sync browsers.
20:25:32 <gwern> _root: are you? I suggested one way, that you're a zombie lilo. but that doesn't seem to be it.
20:25:43 <_root> Cale: Well, for one to understand arrays, they'd understand the culmination of variables/values wouldn't they?
20:25:47 <kmc> here it is: http://intoverflow.wordpress.com/2010/05/09/polymorphic-first-class-labels/
20:25:49 <_root> gwern: :(
20:25:54 <_root> kmc: Great!
20:26:10 <Cale> _root: Well, arrays are a type of value.
20:26:11 <kmc> i'm not sure how useful this really is
20:26:17 <kmc> by which i mean actually not sure, not passively saying it's useless
20:26:26 <kmc> first-class labels are very useful
20:26:41 <kmc> haven't thought about the use cases for using them polymorphically in this particular way
20:26:51 <kmc> and this seems like a pretty heavy solution
20:27:01 <kmc> but it's good that we at least have a solution
20:27:04 <_root> Cale: Really, go on!
20:27:12 <JoeyA> In my opinion, an ideal array module would be mutable and wouldn't be based on monads.  There would be a function that sets an item in the array (resizing if needed) and returns the new array.  Moreover, lazy evaluation would work with it.
20:27:18 <JoeyA> Are there caveats to such a module?
20:27:21 <_root> kmc: Indeed.
20:27:27 <djahandarie> I've used fclabels to do much of that stuff
20:27:30 <mrd> JoeyA: Data.Array
20:27:39 <kmc> JoeyA, if that's going to mutate, then what if some other code kept a reference to the old array?
20:27:54 <kmc> JoeyA, there was DiffArray, which mutated behind the scenes and kept a sort of changelog
20:27:59 <mrd> oh, would be mutable
20:28:02 <kmc> but it seems its performance was actually crap
20:28:12 <pastorn> good in theory, though :)
20:28:16 <kmc> it's a good avenue for further research
20:28:32 <kmc> there is precedent in ByteString for carefully using mutation behind the scenes to make a fast immutable persistent interface
20:28:48 <mrd> linear typed arrays ;)
20:28:50 <kmc> writing such a library is not for the faint of heart
20:28:54 <JoeyA> I guess the problem has something to do with how lists can be referred to by single link, whereas arrays are big blocks?
20:28:59 <Cale> _root: Variables are, roughly, names which stand in place of values. Values are quantities of various types which can convey information in various ways, primarily by being distinguishable from other values, and in the manners in which they can be converted to other values by way of functions.
20:29:07 <gwern> mrd: do we have linear types in haskell? I don't think I've seen them used
20:29:13 <JoeyA> Does laziness work on ByteStrings ?
20:29:17 <kmc> _root, in particular, values do not change over time.  3 is always 3
20:29:20 <_root> Cale: Do you know see the relevance?
20:29:28 <_root> kmc: Variables store a value.
20:29:28 <kmc> but a "reference cell" might hold one value now, and a different value later
20:29:31 <Cale> _root: relevance to what?
20:29:36 <kmc> in Haskell, variables don't change what value they store
20:29:40 <kmc> but other things (like IORef cells) can
20:29:40 <Cale> _root: Variables don't necessarily *store* values
20:29:46 <gwern> JoeyA: there are lazy bytestrings - the laziness is chunky
20:29:48 <kmc> JoeyA, there are lazy bytestrings, which come in "chunks"
20:29:48 <Cale> _root: They're just names for particular values.
20:29:51 <_root> Cale: What is a value?
20:29:55 <mrd> gwern: maybe in Haskell''
20:29:59 <kmc> heh i like gwern's phrasing better
20:30:04 <JoeyA> "chunky" Exactly what I expected, awesome
20:30:11 <kmc> Haskell' is Haskell''
20:30:15 <Cale> _root: I could give you some philosophical or technical definition, but some examples will probably help more than anything :)
20:30:21 <_root> Cale: Varaibles do not store values?
20:30:26 <JoeyA> In the prime generator I'm thinking about, I would have had to do chunking manually in a sense
20:30:27 <_root> Variables, even.
20:30:30 <kmc> they do
20:30:34 <JoeyA> In other words, sieve part of it, then sieve more as needed.
20:30:37 <kmc> or they name values, rather
20:30:39 <_root> I'm not sure what book Cale has.
20:30:43 <kmc> "store" is an irrelevant implementation detail
20:30:48 <Cale> _root: I have lots of books
20:31:00 <_root> Cale: Maybe I can tick off the ones that are flawed, for you.
20:31:02 <pikhq> _root: We don't store values in Haskell.
20:31:07 <kmc> variables are names for values
20:31:08 <pikhq> They just exist.
20:31:13 <_root> pikhq: That's silly.
20:31:13 <kmc> variables might be *implemented* by storing a value in memory
20:31:20 <kmc> they also might be implemented by constant-folding them away at compile time
20:31:28 <_root> kmc: Interesting.
20:31:29 <Cale> _root: Let's look at a function definition:  f x = x^2 + x + 1
20:31:45 <Cale> Here, f and x are variables.
20:31:55 <Cale> f is naming the function that we're defining
20:32:03 <Cale> and x gives a name to its parameter
20:32:19 <_root> Yes?
20:32:33 <Cale> x might take on different values as the program runs (and hence 'vary'), when f is applied to various values.
20:32:42 <_root> On a side note, could you tell me where in your standard it says that functions are variables.
20:32:55 <Cale> At one point, we might evaluate f 5, where x would become a name for the value 5 in the body of the function
20:32:59 <kmc> _root, who said that?
20:33:02 <mrd> you guys are way too nice to trolls
20:33:02 <kmc> functions are values
20:33:07 <kmc> thus, some functions are stored in variables
20:33:16 <kmc> mrd, they're usually not this subtle
20:33:19 <Cale> So we would compute the value of f 5 as 5^2 + 5 + 1 = 25 + 5 + 1 = 31
20:33:20 <_root> mrd: I'm trolling?
20:33:27 <kmc> _root, it seems like you came here to antagonize people
20:33:30 <blackdog> mrd: the only thing trolls get off on is causing disharmony. if you're nice to them, they get bored.
20:33:36 <kmc> maybe you just have a very confrontational approach to learning
20:33:36 <_root> kmc: I wouldn't want to antagonize friendly people.
20:33:38 <pikhq> _root: Functions are values. "f" is the variable that represents the value "\x->x^2+x+1".
20:33:43 <_root> kmc: Indeed
20:33:45 <kmc> but it's fairly unusual that someone comes in with your attitude
20:33:49 <Cale> _root: You *might* be trolling, but I don't care, these are decent questions, though there might be better ones to ask.
20:33:49 <kmc> it might be necessary in other channels
20:33:51 <blackdog> mrd: so either he's a troll and will get bored, or is genuinely curious and will become enlightened.
20:33:56 <kmc> the whole "linux sucks because my sound doesn't work" strategy
20:33:56 <_root> kmc: My attitude? :(
20:34:05 <_root> Cale: They are "fair" questions.
20:34:09 <gwern> trolls don't usually bother to get hostmasks
20:34:17 <_root> Cale: I don't know how people attribute attitude to text.
20:34:24 <Cale> _root: Okay
20:34:29 <kmc> anyway
20:34:32 <_root> Cale: So, we were saying.
20:34:33 <ElMarsh> yes go on please, I was here earlier asking something similar :)
20:34:33 <kmc> it *is* a reasonable discussion
20:34:40 <_root> Before we got childishly interrupted by children.
20:34:41 <soupdragon> I really wish people wouldn't call every fucking thing a troll
20:34:47 <soupdragon> It's the BANE of the internet
20:34:48 <kmc> functions are values.  variables store values.  thus, some variables can store functions
20:34:49 <_root> soupdragon: You're a troll.
20:34:51 <_root> soupdragon: Die!
20:34:55 <pikhq> :P
20:35:04 <_root> kmc: What's the difference between a variable and a function?
20:35:06 <wli> We have hit the Troll Wall.
20:35:12 <kmc> _root, what's the difference between 5 and a duck?
20:35:16 <kmc> they're totally different kinds of thing
20:35:22 <_root> kmc: Where is "duck" defined?
20:35:25 <JoeyA> Hmm, is the lazy bytestring mutable?
20:35:25 <kmc> sigh
20:35:34 <Cale> _root: So if we wanted to evaluate an expression like f 5 + f 6, for instance, the value of x would be different at different times, and so that's where the name "variable" comes from.
20:35:37 <kmc> a variable is a name for a value.  a function is a mapping from input values to output values
20:35:46 <_root> kmc: I see.
20:35:48 <kmc> there's no "difference", in that they're totally different concepts
20:35:49 <Cale> _root: f itself wouldn't change
20:35:55 <kmc> they both involve "values"
20:35:59 <kmc> which can themselves be functions, of cours
20:36:05 <Cale> _root: But perhaps in a different context, f might be a different value
20:36:11 <Cale> (maybe not even a function)
20:36:11 <kmc> that's the essence of functional programming: functions that take or return other functions
20:36:12 <_root> So, being as they both "involve" values, they are both variables?
20:36:13 <gwern> @let duck = "duck"
20:36:14 <lambdabot>  Defined.
20:36:18 <kmc> _root, no
20:36:25 <djahandarie> > fix duck -- my duck is broken!
20:36:25 <_root> This is what you just said, is it not?
20:36:26 <lambdabot>   Couldn't match expected type `a -> a'
20:36:26 <lambdabot>         against inferred type `[GHC.T...
20:36:27 <gwern> > duck duck duck goose
20:36:28 <lambdabot>   Not in scope: `goose'
20:36:30 <pikhq> _root: No, variables are nothing more than names for values.
20:36:32 <kmc> _root, no, i'm not sure how you could read that
20:36:43 <_root> kmc: 04:35 < kmc> they both involve "values"
20:36:46 <kmc> yes
20:36:49 <_root> I'm just trying to understand you.
20:36:51 <kmc> and i said a variable is a name for a value
20:36:57 <kmc> i didn't say a variable is anything which involves values whatsoever
20:37:00 <kmc> you can think of a function as a set of (input,output) pairs
20:37:04 <djahandarie> @let duck = id
20:37:04 <lambdabot>  <local>:5:0:
20:37:04 <lambdabot>      Multiple declarations of `L.duck'
20:37:04 <lambdabot>      Declared at: <local...
20:37:10 <_root> kmc: Alright.
20:37:11 <djahandarie> Damn it gwern
20:37:17 <kmc> that is, the function \x -> x + 5
20:37:24 <_root> gwern: So, then, what would an array be?
20:37:24 <kmc> takes an input number and returns 5 plus that input
20:37:25 <soupdragon> @let goose = id
20:37:25 <lambdabot>  Defined.
20:37:37 <kmc> so it's like the set {..., (-1,4), (0,5), (1,6), (2,7), ... }
20:37:49 <kmc> where 0, 2, 7, and such are values
20:37:51 <kmc> and the set itself is a value
20:37:53 <_root> Err, kmc.
20:37:56 <soupdragon> that's not what functions in haskell are :P
20:37:57 <kmc> and we said all this without naming anything
20:37:58 <gwern> @unlet duck
20:37:59 <lambdabot>   Parse error: SemiColon
20:38:02 <gwern> ah well
20:38:06 <djahandarie> God damn it gwern!
20:38:15 <soupdragon> @unlet duck ;
20:38:15 <lambdabot>   Parse error: SemiColon
20:38:18 <gwern> djahandarie: I take patches for lambdabot if you want to implement an @unlet :)
20:38:23 <Cale> unlet is not a command
20:38:24 <Cale> @undefine
20:38:27 <kmc> soupdragon, it's not how any sane haskell compiler would *represent* a function.  it's very much what they are, conceptually
20:38:33 <kmc> this is how functions are defined in maths
20:38:34 <kmc> as sets of pairs
20:38:43 <soupdragon> kmc, yeah set theory is totally different than computable functions
20:38:59 <kmc> of course
20:39:00 <paradox__> hi haskell guys, did you try the google codejam
20:39:05 <Cale> soupdragon: Let's ignore the subtle matters of computability for the moment :)
20:39:08 <gwern> Cale: well, there is unLet in the transform code
20:39:16 <kmc> but every computable function is a set of pairs too
20:39:21 <soupdragon> isn't it central to this?
20:39:25 <kmc> it's just a rather special set of pairs, compared to all the sets of pairs you might think of
20:39:26 <soupdragon> if not I must be off in my own world
20:39:34 <Cale> soupdragon: well...
20:39:38 <Makoryu> @get duck = foldr f
20:39:38 <lambdabot> shapr!!
20:39:42 <kmc> heh
20:39:46 <ElMarsh> you said earlier about something: 'variables could be implemented via memory changes or something else'? what was that other way?
20:39:48 <kmc> @dick-balls duck
20:39:48 <lambdabot> Unknown command, try @list
20:39:50 <Cale> soupdragon: _root is asking very basic questions like what variables and values are
20:39:50 <Makoryu> @unget
20:39:50 <lambdabot> Unknown command, try @list
20:39:52 <kmc> aww it broke
20:39:57 <Makoryu> Oh, spellcheck is disabled
20:40:00 <paradox__> i used haskell for the code jam but my code eats up too much mem, can anyone help me with forced evaluation
20:40:07 <Cale> soupdragon: We could start in with Scott domains and continuity and such, but I'm not sure it would help.
20:40:13 <kmc> ElMarsh, in "let a = 2 in a*3", it might as well optimize this just to 6
20:40:15 <danharaj> category theory :p
20:40:19 <_root> Cale: I'm trying to figure out your definitions of it.
20:40:21 <Cale> A set of pairs is a pretty good mental model for what functions are :)
20:40:22 <kmc> in which case the variable "a" has no runtime representation at all
20:40:25 <_root> Cale: You see, I'm not a haskell programmer.
20:40:31 <Cale> _root: okay
20:40:34 <_root> Cale: I'm deliberating on becoming one.
20:40:40 <_root> What would you suggest, friend?
20:40:50 <blackdog> paradox__: I did. only got an hour or two to work on it though
20:40:50 <soupdragon> hmm
20:40:53 <Cale> _root: Functions in Haskell are very similar to what functions are in mathematics
20:41:05 <paradox__> http://pastebin.com/vc1vgsj3
20:41:11 <ElMarsh> "they also might be implemented by constant-folding them away at compile time"
20:41:12 <paradox__> thats my solution for q3
20:41:13 <_root> Cale: Named sequences.
20:41:14 <soupdragon> I think I better sit out because I totally disagree
20:41:15 <kmc> Haskell beginners are often prone to navel-gazing over "what *is* a variable, really??" (or similar for functions, monads, etc)
20:41:18 <kmc> it can sometimes be useful
20:41:24 <applicative> Cale, or, they are functions, in a funny restricted mathematics
20:41:28 <_root> kmc: I come from a ... different background.
20:41:31 <soupdragon> I don't want to confuse things
20:41:32 <kmc> but it's often best to just read and write more code
20:41:34 <_root> Or, rather, I come from no background.
20:41:36 <paradox__> but i dont understand how to use $! or seq make it not eat all my mem
20:41:38 <kmc> _root, that's cool
20:41:41 <Cale> _root: Well, 'sequence' implies something a bit more than we want.
20:41:47 <paradox__> the solution works otherwise
20:42:10 <blackdog> paradox__: have you compiled with profiling?
20:42:12 <applicative> the word 'variable' is a menace, I can't believe Haskellers use it at all.
20:42:12 <ddarius> type (a -> b) = Set (a, b)
20:42:39 <Makoryu> applicative: It has exactly the same definition as in algebra.
20:42:44 <Cale> _root: In mathematics, if A and B are sets, then a function f: A -> B is a triple (A,B,G), where G is a set of pairs (a,b) with a in A and b in B, so that for each a in A, there is exactly one b in B for which (a,b) is in G.
20:42:54 <soupdragon> oh wow, "The inconsistency of certain formal logics" is actually /by/ Haskell Curry
20:43:03 <Makoryu> applicative: It's the imperative languages that appropriated it for their nefarious semantic drift :p
20:43:04 <danharaj> Well, yeah.
20:43:17 <Cale> When (a,b) is in G (the graph of the function), we say that f(a) = b
20:43:29 <_root> Makes perfect sense.
20:43:31 <Cale> okay
20:44:03 <kmc> Makoryu, i think "variable" meant what it means in Haskell in maths
20:44:07 <kmc> long before any imperative language
20:44:11 <kmc> and yes it is an unfortunate name
20:44:17 <kmc> they "vary" in another sense
20:44:29 <kmc> in that the value bound to a parameter of a function varies from call to call
20:44:38 <kmc> but it doesn't just "change" randomly
20:44:43 <kmc> as it may in an imperative language
20:44:44 <Cale> So, you might be familiar with 'functions' in an imperative language like, oh, getchar, which takes *no* parameter, and yet produces a character which might be different every time. That's not a function in the sense that we mean it.
20:45:13 <Cale> (A Haskell programmer might call it an IO action)
20:45:15 <ElMarsh> right, that is known as an impure function right?
20:45:33 <kmc> Haskell doesn't have impure functions, at least none you're supposed to see
20:45:41 <kmc> Haskell has pure functions, some of which return IO actions
20:45:43 <Cale> Or perhaps an impure function, though the fact that it has no parameters means that it's usually not considered a function at all.
20:46:08 <applicative> Makoryu, see the great Tarski's remark, basically quoting Frege 1884 : http://books.google.com/books?id=ehwo-5FkPXcC&lpg=PP1&dq=tarski%20logic&pg=PA4#v=onepage&q&f=false
20:46:57 <djahandarie> I wonder if quantum computing could help resolve the IO issues of Haskell
20:46:58 <Cale> _root: So, when we describe how a function f: A -> B associates values of its domain A to values of its codomain B, we usually give an equation (or bunch of equations), that the function is meant to satisfy
20:47:21 <Cale> _root: If the domain and codomain are the integers, say, we might write f(x) = x^2 + x + 1
20:47:22 <kmc> getChar is just an IO action
20:47:28 <kmc> it's not a function in any way; it has no arguments
20:47:31 <Cale> (or in Haskell, we wouldn't write the parens around x)
20:47:39 <applicative> kmc, in \x -> x + 3  'x' is a variable in the only scientifically respectable sense.  What varies?
20:48:20 <Cale> _root: The 'x' in this description is called a formal parameter, and the intention is that this equation is valid when x is replaced by any value in the domain.
20:48:54 <_root> I see
20:49:07 <Cale> We also call it a variable
20:49:39 <Cale> It gives a sort of name to the values to which we might apply the function f, and lets us describe what the result will be in terms of them.
20:49:56 <soupdragon> you could define values like {0,1,2,3,...,(0,0),(0,1),(0,2),...,(1,0),...,Nothing,Just 1,Just 2,...Just (0,0),...,...(Nothing,Nothing),...} and terms as {a,b,c,...,0,1,2,3,...,(a,a),....,(a,0),.......}
20:50:18 <applicative> the absurdity of finding a meaning of the variable 'x' in f(x) = x^2 + x + 1  shows best when you desugar it to f = \x ->  x^2 + x + 1
20:51:03 <kmc> this conversation reminds me of http://img.moronail.net/img/9/2/1392.jpg
20:51:04 <Cale> _root: So, apart from the usual integers and strings and so on, there are also values which are functions
20:51:26 <Cale> kmc: hehe
20:51:27 <_root> Cale: Alright.
20:51:36 <djahandarie> Bahaha kmc
20:51:38 <_root> Wow, I think I'm going to investigate further, with a HS book.
20:51:47 <kmc> HS?
20:52:15 <Cale> > let f g x = g (g x) in f (+1) 5
20:52:16 <lambdabot>   7
20:52:22 <applicative> the x in " \x -> x^2 + x + 1" has no meaning, it is not an independent sign even.   It is part of a device for exhibiting the common pattern in 0^2 + 0 + 1 and 1^2 + 1 + 1 and 2 ^2 + 2 +1
20:52:27 <Cale> Here, f is a function which takes two parameters: g and x
20:52:46 <kmc> maybe it'd be more obvious if you used de bruijn indices
20:52:47 <Cale> g will be a function, and we apply it twice to the value x to see the result
20:52:53 <kmc> or the representation of lambda calc which is just a graph
20:52:58 <applicative> f is a function of two arguments, they are not g and x     g and x dont exist
20:53:14 <Cale> applicative: Please.
20:53:36 <applicative> you'll never impart cognition if you take this path.
20:53:43 <Cale> _root: and we apply f to the function (+1) (which adds 1 to any number you give it), and then the value 5
20:54:11 <Cale> and this gives us (+1) ((+1) 5), which is (+1) 6, which is 7
20:54:29 <Cale> We could also write:
20:54:34 <Cale> > let f g x = g (g x) in f (*2) 5
20:54:36 <lambdabot>   20
20:54:54 <Cale> So now instead of adding 1 twice, we multiply by 2 twice
20:55:23 <Cale> This f is a simple example of a higher order function -- one which takes a function as one of its parameters
20:56:20 <Cale> _root: I wonder if that makes any sense :)
20:56:38 <_root> Cale: Sort of.
20:56:52 <Cale> Let's give f a proper name, 'twice'
20:57:06 <Cale> @let twice g x = g (g x)
20:57:07 <lambdabot>  Defined.
20:57:34 <Cale> > twice (+1) 5
20:57:35 <lambdabot>   7
20:57:43 <Cale> > twice (twice (+1)) 5
20:57:44 <lambdabot>   9
20:57:59 <pastorn> :t twice ap
20:57:59 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
20:57:59 <lambdabot>     Probable cause: `ap' is applied to too few arguments
20:57:59 <lambdabot>     In the first argument of `twice', namely `ap'
20:58:03 <pastorn> booooo
20:58:09 <pastorn> :t twice callCC
20:58:10 <lambdabot>     Occurs check: cannot construct the infinite type:
20:58:10 <lambdabot>       m = (->) (a -> m b)
20:58:10 <lambdabot>     Probable cause: `callCC' is applied to too many arguments
20:58:13 <Cale> pastorn: heh
20:58:16 <tensorpudding> @src twice
20:58:17 <lambdabot> Source not found. You speak an infinite deal of nothing
20:58:19 <applicative> :t twice return
20:58:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = m t
20:58:19 <lambdabot>       Expected type: t
20:58:19 <lambdabot>       Inferred type: m t
20:58:32 <pastorn> @type callCC
20:58:33 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:58:34 <Cale> :t twice
20:58:35 <lambdabot> forall t. (t -> t) -> t -> t
20:58:45 <pastorn> @type callCC callCC
20:58:46 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> m b1
20:58:46 <lambdabot>       Expected type: m (b -> m b1)
20:58:46 <lambdabot>       Inferred type: m b
20:58:51 <pastorn> @type callCC . callCC
20:58:52 <lambdabot> forall a (m :: * -> *) b b1. (MonadCont m, MonadCont ((->) (a -> m b))) => ((m a -> (a -> m b) -> b1) -> (a -> m b) -> m a) -> m a
20:58:55 <pastorn> yay!
20:59:07 <pastorn> Cale: tell me what that does plz
20:59:12 <monochrom> You need 2nd-rank polymorphism if you want "twice return" to work.
20:59:25 <pastorn> @type join
20:59:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:59:34 <pastorn> :t twice join
20:59:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
20:59:35 <lambdabot>       Expected type: m (m a)
20:59:35 <lambdabot>       Inferred type: m a
20:59:42 <pastorn> that should've worked...
20:59:48 <tensorpudding> What type would twice have in that case?
20:59:51 <Cale> This channel is full of fail tonight :)
21:00:15 * Makoryu sighs
21:00:22 <Makoryu> > twice f
21:00:23 <lambdabot>   Ambiguous type variable `t' in the constraints:
21:00:23 <lambdabot>    `Test.SmallCheck.Serial ...
21:00:26 <Cale> Mind you, it's a bit subtle why twice join doesn't work
21:00:29 <applicative> @type "hahah" + "!!"  -- there's success
21:00:30 <lambdabot>     No instance for (Num [Char])
21:00:30 <lambdabot>       arising from a use of `+' at <interactive>:1:0-13
21:00:30 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
21:00:34 <applicative> nope....
21:00:39 <Cale> haha
21:00:45 <applicative> @type "hahah" ++ "!!"  -- there's success
21:00:45 <lambdabot> [Char]
21:00:46 <Makoryu> > twice (+1) 1
21:00:47 <lambdabot>   3
21:01:07 <Makoryu> @let twice' f x = f (f x)
21:01:07 <lambdabot>  Defined.
21:01:10 <Makoryu> :t twice'
21:01:11 <lambdabot> forall t. (t -> t) -> t -> t
21:01:17 <soupdragon> applicative, what does it mean for something to exist?
21:01:17 <Makoryu> Wait a second
21:01:20 <Makoryu> OH RIGHT
21:01:30 * jmcarthur decides to consider /var/log/auth.log to be a free word list
21:02:00 <monochrom> I fail. I can't give a 2nd-rank type to twice.
21:02:06 <applicative> soupdragon, in the context, the real question was whether certain expressions have content
21:02:06 <tensorpudding> jmcarthur: your ssh server getting a lot of attention?
21:02:19 <pastorn> @let join' x = join (join x)
21:02:19 <lambdabot>  Defined.
21:02:24 <pastorn> @type join'
21:02:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
21:02:25 <jmcarthur> i just never bothered to change the port to something else
21:02:25 <soupdragon> applicative, well it is not clear to me what  that mean
21:02:57 <jmcarthur> i'm only allowing key authentication, so i'm not really too concerned
21:03:02 <applicative> soupdragon, in the definition    ... twice f x = f (f x)  the word 'twice' comes  to have content and to mean something
21:03:20 <soupdragon> yeah
21:03:24 <applicative> but the f and x dont mean something, they have a different role.  They show the argument places
21:03:34 <Cale> _root: anyway... this sort of philosophical stuff is easier to tackle once you have a good feel for at least the basics of the language.
21:03:46 <Cale> _root: you might try some tutorial like LYAH
21:03:49 <Cale> @where lyah
21:03:50 <lambdabot> http://www.learnyouahaskell.com/
21:03:57 <soupdragon> because they are universally quantified?
21:04:14 <Cale> Or if you're more serious in a practically minded way, RWH is good
21:04:18 <Cale> @where rwh
21:04:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:04:27 <applicative> cconsider pronouns.  If I say "Cale thinks he knows what a variable is" we will say that 'he' means Cale, has content, that 'he' exists
21:04:52 * jmcarthur wonders what kind of useless data could be mined from his logfiles
21:04:55 <RogueShadow> Not at all fail, a very fun channel from what I read.
21:05:05 <applicative> but if I say, "No one has met his great great great grandmother" who is "he", the one meant by "his"
21:05:14 <Cale> RogueShadow: I was just referring to the sudden wash of type errors
21:05:31 <RogueShadow> mhmm, I got tired of reading the buffer. So I missed some of that.
21:05:33 <soupdragon> that's universal quantification too!
21:06:01 <applicative> I want to tweet my type errors from lambdabot like chrisdone does from emacs
21:06:03 <tensorpudding> if you had a function of type forall a b. a -> b, you could define a very generic iteration function over it.
21:06:07 <Cale> "forall x. x has not met the great great great grandmother of x"
21:06:14 <jmcarthur> my log files contain a total of 19577 failed login attempts that used invalid usernames
21:06:28 <applicative> Cale, so who is x
21:06:35 <Cale> applicative: Anyone.
21:06:36 <jmcarthur> only 8126 of those are unique usernames
21:06:39 <soupdragon> So the statement is that  Universally quantified variables, do not exist.. And I guess  Existentially quantified variables DO exist
21:06:42 <jmcarthur> this is OT, sorry
21:06:51 * jmcarthur goes to -blah
21:06:51 <applicative> So say it's president obama?
21:06:53 <Cale> applicative: x ranges over some set of people
21:07:04 <jimbo1> Couldn't match expected type `Integer'            against inferred type `Double'       Expected type: [Integer]       Inferred type: [Double]     In the second argument of `map',
21:07:09 <applicative> which does it range over
21:07:13 <jimbo1> is there a / that will accept doubles?
21:07:18 <jimbo1> `div` is no different
21:07:29 <c_wraith> :t 1.0 / 2.0
21:07:30 <lambdabot> forall t. (Fractional t) => t
21:07:40 <c_wraith> > 1.0 / 2.0 :: Double
21:07:41 <lambdabot>   0.5
21:07:54 <monochrom> @quote fromIntegral
21:07:55 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
21:07:56 <jimbo1> this is the line I have: map (/ sqrt(((x/y)/2))) wn
21:08:00 <Cale> So, given this statement, and the fact that Obama belongs to that set of people we're quantifying over, we can infer that "Obama has not met the great great great grandmother of Obama"
21:08:03 <jimbo1> where wn is a list of doubles
21:08:04 <monochrom> darn that!
21:08:05 <monochrom> @quote fromIntegral
21:08:05 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
21:08:07 <applicative> no one has ever met his great great great grandmother
21:08:21 <monochrom> heh that's a good one!
21:08:32 <applicative> Cale of course that's right, but it doesn't assign a value to 'x'
21:08:56 <Cale> applicative: It binds the value Obama to x
21:09:09 <applicative> 'x' doesn't have a value, it a part of a symbol, a  part of "for all x ... x...."
21:09:24 <soupdragon> Cale but it seems bizarre to me that everyone is saying that a function is set theoretical
21:09:25 <Cale> It doesn't have a specific value.
21:09:25 <pastorn> > "Palin" > "Obama"
21:09:26 <lambdabot>   True
21:09:30 <pastorn> there we go
21:09:39 <jimbo1> Any tips?
21:09:41 <applicative> Obama is indeed a value, to find a value in 'x' is like finding a rat in Socrates
21:10:02 <Cale> soupdragon: Haskell functions are still mathematical functions, they just have a bit more structure to them
21:10:17 <tensorpudding> > "Love" > "Hate"
21:10:18 <lambdabot>   True
21:10:30 <Cale> soupdragon: We're just neglecting to mention that additional structure, because order theory can wait for beginners.
21:10:33 <tensorpudding> > "Love" > "Tacos"
21:10:34 <lambdabot>   False
21:10:59 <applicative> > "Robert Mitchum" > "Love"
21:11:00 <lambdabot>   True
21:11:00 <Cale> soupdragon: They're continuous functions, with a particular definition of continuity.
21:11:10 <soupdragon> Cale no even if we were just thinking about the total subset of haskell
21:12:34 <Cale> (actually, some work in synthetic topology defines continuity via definability in some functional programming language, and then works backwards from there to define open sets :)
21:12:44 <jimbo1> got it, x and y needed a fromIntegral
21:12:51 <soupdragon> the whole point of haskell is that it computes stuff - that takes time and space, and it happens by some kind of execution
21:13:09 <Cale> soupdragon: But the operational semantics of Haskell is unspecified
21:13:30 <Cale> soupdragon: So if you want to talk about the operational semantics, you have to pick a compiler :)
21:13:35 <Cale> (or interpreter)
21:13:59 <tomberek> Cale: what's the extension that allows something like constraint (Eq a, Monoid a) = CollectionLike a
21:14:00 <soupdragon> we don't have to pin it down exactly
21:14:03 <Cale> We can ask what exactly GHC does to evaluate expressions
21:14:13 <JoeyA> @src zipWith
21:14:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:14:14 <lambdabot> zipWith _ _      _      = []
21:14:16 <Cale> Or we can ask what some abstract lazy graph reduction machine would do
21:14:40 <JoeyA> in the zipWith example above, how does Haskell know to prioritize the first line over the second line?
21:14:49 <JoeyA> Can _ be thought of as "otherwise" ?
21:14:54 <Cale> tomberek: Well, that's a constraint synonym. Constraint synonyms and families are not in GHC yet.
21:15:21 <Cale> JoeyA: Because the pattern matches are in order.
21:15:28 <tomberek> Cale: hm, i saw some code with that, they must have been compiling in another compiler
21:15:29 <JoeyA> ah, so line order matters
21:15:31 <Cale> JoeyA: The first line to match wins.
21:15:33 <JoeyA> That simplifies things
21:15:47 <Cale> tomberek: I think there might be a preprocessor
21:15:50 <applicative> There are three things you do not want to see being made -- sausages, legislation, and whatever you had GHC compile your module to.
21:15:54 <Cale> tomberek: But I'm not sure.
21:16:13 <kmc> yes
21:16:27 <kmc> ghc -ddump-shoggoth
21:17:00 <_root> Sorry for leaving you all, friends.
21:17:50 <applicative> _root, please stay, then we can argue about what a variable is forever...
21:17:55 * Cale made his own sausages once. :) I added a bunch of soya sauce, sugar and honey, so they were sort of teriyaki pork sausages.
21:18:10 <Cale> applicative: hehe
21:18:11 <_root> applicative: I don't truly care about variables.
21:18:17 <_root> applicative: Your nick is dumb.
21:18:20 <_root> (btwftw)
21:18:23 <JoeyA> Cale: Actually, I'm not so sure I should rely on that (pattern matches being in line order).  GHC threw this warning when I tried to exploit that:  "Warning: Pattern match(es) are overlapped"
21:18:24 <Cale> *I* thought it was a decent question.
21:18:28 <applicative> _root, my nick is dumb
21:18:34 <_root> applicative: You're so applicative.
21:18:36 <Cale> It's a difficult question to answer coherently.
21:18:37 <cdsmithus> Cale, tomberek: the constraint family stuff?  Yeah, the talk said they had a preprocessor
21:18:41 <monochrom> he nick is applicative, not dumb
21:18:52 <_root> monochrom: You were the one who didn't know what an array/value/variable was.
21:18:56 <kmc> hmm
21:18:57 <applicative> @src (<*>)
21:18:58 <lambdabot> Source not found. Just try something else.
21:19:01 <kmc> what was that about antagonizing people again?
21:19:06 <_root> monochrom: I was trying to help you.
21:19:10 <Cale> JoeyA: It tends to only say that if a later line is more specific than a previous one.
21:19:10 <_root> kmc: Where did I do this?
21:19:13 <tomberek> Cale, cdsmithus: i'm trying to track it down
21:19:15 <_root> kmc: I shall remedy it.
21:19:18 <applicative> @instances Applicative
21:19:18 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
21:19:19 <Cale> JoeyA: (so it'll never get used)
21:19:32 <soupdragon> John Baez is great
21:19:37 <Cale> JoeyA: But there are cases when it makes a mistake about that, I think.
21:19:38 <jimbo1> is there a linear interpolation function in haskell?
21:19:49 <Cale> jimbo1: [a,b..c]
21:20:01 <nus> _root, frends don't let frends call themselves dumb
21:20:02 <jimbo1> not quite what I meant
21:20:04 <Cale> > [1,1.2..10]
21:20:05 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.199...
21:20:12 <_root> nus: On the contrary...
21:20:28 <cdsmithus> jimbo1: What did you mean?  Like: (Int -> Double) -> (Double -> Double) by interpolation?
21:20:31 <jimbo1> Oh! that's interesting
21:20:38 <applicative> there are four things you do not want to see being made, ... ...  ... and floating point calculations
21:20:39 <jimbo1> http://www.mathworks.com/access/helpdesk/help/techdoc/ref/interp1.html
21:20:57 <jimbo1> That's what I was referring to
21:21:04 <Cale> oh, okay
21:21:14 <Cale> No, nothing like that is in the standard library
21:21:37 <jimbo1> do you know if it is in a non-standard?
21:21:44 <Cale> hmmm
21:21:49 <aavogt> hmatrix?
21:22:23 <jimbo1> I see this DSP package
21:22:23 <jimbo1> http://hackage.haskell.org/package/dsp
21:22:28 <jimbo1> mentions Interpolation at the top
21:22:33 <jimbo1> but I need to explore better
21:23:04 <cdsmithus> @let interpolate g x = let a = floor x in (x - a) * g a + (a + 1 - x) * g (a + 1)
21:23:05 <lambdabot>  Defined.
21:23:48 <jimbo1> ?
21:23:54 <jimbo1> what are g and a in that?
21:24:28 <cdsmithus> I'm unsure what you meant... but that interpolates a function on the integers to a function on floats
21:24:54 <kmc> g is the function you interpolate
21:24:59 <cdsmithus> or RealFrac's, in particular
21:25:02 <kmc> a is a "let"-bound variable
21:25:05 <kmc> it's being defined right there
21:25:11 <kmc> it's equal to (floor x)
21:25:13 <monochrom> a is floor x, as "let a = floor x" says
21:26:00 <Cale> cdsmithus: He wants a function which takes a bunch of (x,y) points with various x's, and builds a function whose graph consists of line segments joining those points
21:26:16 <cdsmithus> Cale: Ah, okay.... slightly harder then.
21:26:18 <jimbo1> That's right
21:26:37 <monochrom> turn the bunch into a function...
21:27:44 <Cale> You would probably want to use Data.Map.splitLookup
21:28:33 <Cale> and when you get Nothing, you do a findMax and findMin on the respective halves, and do a straight line interpolation.
21:28:39 <tomberek> Cale, cdsmithus: anything else commonly used for constraint synonyms
21:28:52 <tomberek> or just type it all out?
21:29:26 <kmc> you can use a class with a single undecidable instance
21:29:28 <Cale> tomberek: You could maybe also look for the stuff on constraint families
21:29:30 <kmc> or you can use the C preprocessor
21:29:31 <cdsmithus> tomberek, the main point of the paper was "constraint synonym families"
21:29:40 <kmc> both are pretty bad hacks
21:29:58 <kmc> CPP is at least straightforward
21:30:07 <Cale> http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf
21:30:29 <tomberek> yeah, it introduces it
21:37:24 <tomberek> but i don't see any actual implementation anywhere
21:38:21 <cdsmithus> {-# LANGUAGE ViewPatterns #-}
21:38:23 <cdsmithus> import qualified Data.Map as M
21:38:25 <cdsmithus> interpolate dat x = case M.splitLookup x vals of
21:38:27 <cdsmithus>         (_,  Just y,  _ ) -> y
21:38:29 <cdsmithus>         (   M.maxViewWithKey -> Just ((x1, y1), _),
21:38:31 <cdsmithus>             Nothing,
21:38:33 <cdsmithus>             M.minViewWithKey -> Just ((x2, y2), _) )
21:38:35 <cdsmithus>                           -> ((x - x1) * y1 + (x2 - x) * y2) / (x2 - x1)
21:38:37 <cdsmithus>         _                 -> error "Out of range"
21:38:39 <cdsmithus>     where vals = M.fromList dat
21:38:43 <cdsmithus> jimbo1: There ya go
21:39:22 <jimbo1> cdsmithus: Whoa, I wasn't paying attention - did you just write that?
21:39:25 <cdsmithus> Yeah
21:39:32 <jimbo1> That's fantastic
21:39:37 <jimbo1> Let me play with it a bit
21:41:07 * cdsmithus remembers the debate earlier today about whether it's ever useful to have floating point values as keys in Data.Map...
21:41:28 <iaefai> Would ghc choke on a file that has #!runhaskell on the first line?
21:42:55 <jimbo1> cdsmithus: can you explain the use of {-# LANGUAGE ViewPatterns #-}
21:42:56 <jimbo1> ?
21:43:37 <cdsmithus> jimbo1: Yep.  I needed to pattern match on the results of those view functions, so that we only interpolate if there's a nearest eleemnt of the Map both above and below it.
21:43:45 <cdsmithus> jimbo1: View patterns are a nice way to do that.
21:44:11 <jimbo1> OK
21:44:32 <jimbo1> I am getting:
21:44:58 <jimbo1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25434#a25434
21:45:00 <cdsmithus> f (myView -> pat), desugars to call myView on the first argument, and then pattern match the result against pat
21:45:09 <jimbo1> Did I know copy correctly
21:45:23 <jimbo1> sorry, did I not copy correctly?
21:45:31 <cdsmithus> Nope, you're fine.  That's just a warning.  Old versions of GHC *always* give warnings on view patterns.
21:45:40 <cdsmithus> Annoying, but it's fixed in 6.12 I think
21:45:48 <aavogt> mostly
21:45:51 <pastorn> cdsmithus: view patterns + records seems like a cool thing to do :)
21:46:17 <jimbo1> Yep, I'm on 6.10.4
21:46:18 <cdsmithus> pastorn: definitely, view patterns are awesome together with stuff like fclabels or data-accessor
21:46:34 <pastorn> fclabels is a bit messy
21:46:56 <pastorn> if only there was a 'puts' that worked with records
21:47:01 <pastorn> then everything would be fine
21:47:51 <cdsmithus> I'm a fan of fclabels.  Honestly, I think with a few language changes, the built-in Haskell record system could be deprecated, in favor of library alternatives.
21:47:55 <JoeyA> I'm not sure why this works:  take 10 $ foldl' sortedUnion [] [[x*2 | x <- [1..]], [x*3 | x <- [1..]], [x*5 | x <- [1..]]]
21:48:08 <JoeyA> sortedUnion is a function that merges two sorted lists, removing duplicates between them
21:48:22 <JoeyA> So the example above prints 10 numbers that are multiples of 2, 3, or 5
21:48:35 <cdsmithus> JoeyA: What about it don't you understand?
21:48:37 <JoeyA> The part I don't get is:  doesn't foldl' strictly evaluate at each step?
21:48:48 <jimbo1> cdsmithus: can you give an example of how your interpolate is used?
21:48:51 <JoeyA> In other words, why does the laziness work here?
21:48:54 <pastorn> cdsmithus: nah, the only thing the record system needs is a shorthand for applying a function over one of the fields
21:48:59 <monochrom> foldl' uses seq. Let's see what seq does:
21:49:21 <monochrom> > seq (undefined : undefined) "OK!"
21:49:22 <lambdabot>   "OK!"
21:49:25 <monochrom> OK!
21:49:28 <cdsmithus> jimbo1: Sure, just do, e.g., "interpolate [(2,3), (7,1), (10,17)] 8"
21:49:44 <JoeyA> If foldl' were being strict, I think it would first try to call sortedUnion on [] and [x*2 | x <- [1..]]
21:49:52 <monochrom> You see it is not that strictly evaluate, is it?
21:50:03 <jimbo1> I'm sorry, I just don't understand what in the heck it is doing
21:50:32 <cdsmithus> JoeyA: foldl' is strict, over the value you give it, which is the top-level constructor of the list.  That doesn't mean it's strict over the whole list.
21:50:47 <applicative> jimbo1, I'm still trying to figure it out, never studied view patterns...
21:50:48 <pastorn> cdsmithus: like this: f rec = rec { fld \ f } where f :: fld -> fld
21:50:51 <pastorn> whoops
21:50:57 <pastorn> inner f /= outer f
21:51:04 <jimbo1> applicative: yep, It's a little indimidating
21:51:04 <JoeyA> oh, so the infinite list is treated like a first-class generator?
21:51:05 <cdsmithus> jimbo1: Maybe you'd better define your problem then.  What data do you have, and what you want to do?
21:51:08 <applicative> cdsmithus must give us more of a tutorial
21:51:33 <monochrom> > seq (repeat False) "OK!"
21:51:34 <lambdabot>   "OK!"
21:51:34 <JoeyA> Here's an infinite list, rather than here is [1,2,3,4,5,6,7,8,9,10,11,12,13,14,...]
21:51:48 <applicative> jimbo1, I think they shouldnt be necessary here.  Its just that thy make it smooth if youre familiar with them.
21:52:11 <jimbo1> cdsmithus: I have a list of doubles with a size.  I want to turn it into a longer (or shorter!) list and fill in appropriate values in the middle of gaps.
21:52:39 <monochrom> When I say something, only trolls see it.
21:52:41 <nornagon> [1,4] -> [1,2,3,4]?
21:52:48 <jimbo1> yes
21:52:57 <jimbo1> but for example
21:53:01 <cdsmithus> jimbo1: How do you know where the gaps are?
21:53:07 <nornagon> succ?
21:53:10 <DigitalKiwi> has anyone seen monochrom say anything lately? I have not seen him in months
21:53:26 <cdsmithus> DigitalKiwi: monochrom has been talking, yes.
21:53:28 <jimbo1> Let me give a better example
21:53:29 <applicative> jimbo1, in ghci you can see the type of interpolate is interpolate :: (Ord a, Fractional a) => [(a, a)] -> a -> a
21:53:38 <jimbo1> Right, I did tht
21:53:43 <DigitalKiwi> preflex: seen monochrom
21:53:44 <preflex>  monochrom was last seen on #haskell 1 minute and 5 seconds ago, saying: When I say something, only trolls see it.
21:53:53 <DigitalKiwi> oh well i'll be
21:54:00 <applicative> so it takes a list of inputs and yields a function (a->a) as desired
21:54:02 <jimbo1> So this is straight from matlab, but it will explain a lot
21:54:09 <DigitalKiwi> well i guess that manes preflex and cdsmithus are trolls, amirite?
21:54:33 <DigitalKiwi> s/manes/means/
21:54:40 <cdsmithus> Hey!  I'm very secretive about my trollishness.  Shhh!
21:55:23 <jimbo1> Sorry, give me one second
21:56:58 <rrjamie> I've been experimenting with haskell to solve google code jam problems, and al is going well, except in many cases my types get downcasted from [Integer] to [Int] and I lose big number support
21:57:01 <applicative> jimbo1, so interpolate [(1,1),(2,4)] 1.5   is 2.5      you want to map this over your list of additional points
21:57:54 <DigitalKiwi> this is the second time i have heard of google code jam but still don't know what it is
21:57:58 * DigitalKiwi goes to....google it
21:58:03 <cdsmithus> pastorn: I didn't understand the last thing you said, exactly... Yes, having putters for records would be nice.  But so would composing them and having putters for composing them, and having modify functions that act on fields.... basically, all the stuff fclabels and data-accessor give you
21:58:22 <kmc> rrjamie, Haskell has no implicit numeric coversions
21:58:29 <monochrom> @hoogle Int
21:58:29 <lambdabot> module Data.Int
21:58:29 <lambdabot> Text.Read Int :: Integer -> Lexeme
21:58:29 <lambdabot> Text.Read.Lex Int :: Integer -> Lexeme
21:58:57 <kmc> rrjamie, but it might be inferring Int based on use of a function like length or (!!) etc.
21:59:00 <kmc> which regrettably use Int
21:59:12 <kmc> look at the "generic" versions from Data.List
21:59:14 <rrjamie> kmc, alright.. I think that's what's getting me, I just I have to find out where, thanks
21:59:21 <pastorn> cdsmithus: i was talking about new language syntax
21:59:26 <pastorn> maybe that's overkill...
21:59:28 <kmc> rrjamie, you can add explicit (3 :: Integer) type sigs
21:59:34 <kmc> and then you will get type errors
21:59:37 <rrjamie> can you convert from int to interger?
21:59:39 <kmc> and you can find them
21:59:39 <kmc> yes
21:59:42 <kmc> :t fromIntegral
21:59:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:59:59 <pastorn> cdsmithus: http://research.microsoft.com/en-us/um/people/simonpj/haskell/records.html
22:00:02 <monochrom> > (fromIntegral (5 :: Int)) :: Integer
22:00:02 <lambdabot>   5
22:00:03 <pastorn> search it for \
22:00:19 <cdsmithus> pastorn: Well, some language syntax is needed for records, I think.  But it could be made more generic so most of the record stuff could be done in libraries
22:00:29 <rrjamie> kmc, thanks
22:00:34 <jimbo1> applicative: what are those inputs?
22:00:49 <jimbo1> is 1.5 the step?
22:01:08 <jimbo1> what do the tuples represent
22:01:16 <jimbo1> LOL sorry for all the questions
22:01:52 <jimbo1> OH, I understand what is here
22:02:04 <jimbo1> The tuples are positions and values in a gap-filled array
22:02:18 <Peaker> a.k.a: sparse array
22:02:24 <cdsmithus> jimbo1: The list of ordered pairs are data points to interpolate between.
22:02:26 <jimbo1> check
22:02:56 <jimbo1> and the other input is the point to which i want to interpolate
22:03:01 <jimbo1> hmm OK good
22:03:59 <ski> pastorn : how would you use that to modify a nested field ?
22:04:13 <cdsmithus> jimbo1: In general, if you want to reuse an interpolated function, just pass the list and assign the result a name with a let binding or something, so that the Map won't be rebuilt each time it's evaluated.
22:05:08 <cdsmithus> jimbo1: Like, "let f = interpolate [(1,2), (2,4)]"  and then later, "f 3"
22:05:22 <pastorn> ski: hmm...
22:05:51 <pastorn> \rec -> rec { fld \ (\r -> r \ f) }
22:05:52 <pastorn> i guess
22:06:11 <pastorn> or maybe \ \ f
22:06:12 <ski> that only specifies one field name
22:06:18 <ski> (so it can't be right)
22:06:26 <pastorn> ski: use ,
22:06:37 <pastorn> maybe this will give parse errors
22:06:50 <pastorn> i just like the syntax, i don't say it's the way to go :)
22:07:20 <ski> i'm all for improving record syntax .. i just want a well-thoughout system :)
22:08:40 <cdsmithus> The thing is, we have most of the pieces in library format: fclabels and data-accessor are very nice packages... and either view patterns or pattern guards can pattern match against records in these systems (with some annoying limitations that could be removed)
22:08:53 <pastorn> ski: you people and your thoroughness!
22:09:41 <applicative> jimbo1, I see the great bos had a tutorial on view patterns a while back, if you want to figure out cdsmithus' middle case  http://www.serpentine.com/blog/2009/01/11/fun-with-haskell-view-patterns/
22:10:44 <cdsmithus> The other nice thing about fclabels and data-accessor is that they work at a conceptual level, but don't require things about the representation of your data.  i.e., your data type could be something really funky, and you can still build record accessors for "fields" that are encoded any way you like.
22:11:38 * ski doesn't think of `fclabels' or `data-accessor' as representing records
22:11:49 <ezyang> (stark) I'm kind of ambivalent about view patterns.
22:12:15 <ski> i would prefer another syntax for view patterns, i think
22:12:32 <cdsmithus> ski: like, pattern guards?  Which are in Haskell 2010, I believe
22:12:53 <ski> cdsmithus : i'm not sure .. but i think the `<expr> -> <pat>' isn't that good
22:13:18 <ski> ideally, i want something that has a declarative reading
22:13:35 <cdsmithus> pattern guards let you say: f x | Just a <- myView x = a
22:13:47 <ski> (yes, i know)
22:14:19 <ski> i.e., it appears that `(e ->)' would be some kind of half-inverse to `e', if you try to reason equationally about it
22:14:55 <ski> but i'm not clear on exactly what declarative reading it would have
22:15:27 <cdsmithus> ski: Not sure what you mean by delcarative then.  View patterns seem perfectly declarative to me.
22:16:00 <ski> cdsmithus : what is the value of the "expression" `(* 2) -> 5', then ?
22:16:44 <ski> imo, patterns should, as far as possible, be possible to interpret as expressions
22:16:52 <Cale> > \((*2) -> x) -> 5
22:16:52 <cdsmithus> ski: It's not an expression.  It's a pattern, and it matches all x such that (* 2) x === 5
22:16:53 <lambdabot>   {-3->5;-2->5;-1->5;0->5;1->5;2->5;3->5}
22:17:00 <ski> so that we can reason algebraically about code
22:17:17 <ski> cdsmithus : i know. and that's an operational description of what it does
22:17:30 <Cale> oh, I see what you mean
22:18:27 <ski> e.g., there is a reason why we can write `f (x:xs) = x * x + length xs', where `x:xs' can be interpreted as an expression
22:18:43 <ski> (and `f (x:xs)' itself too, for that matter)
22:19:40 <ski> the point is that if we manage to rewrite the argument in a call to `f' to the form `(..) : (..)', then we can "replace equals for equals", and continue reasoning equationally
22:20:09 <Cale> ski: Well, guards have the same problem
22:20:12 <ski> now, the specific evaluation order that happens in Haskell is one instance of such equational reasoning
22:20:58 <ski> Cale : yes, but i interpret `f x | p x = g x' as `forall x. f x = g x  <=  p x = True'
22:21:25 <ski> (modulo some extra cruft, for multiple guards, and guards on multiple equations, &c.)
22:21:48 <Cale> ski: Okay, but doesn't a similar transformation work for view patterns?
22:22:18 <ski> Cale : not as easily. guards attach to equations, while view patterns can occur anywhere inside a pattern
22:23:56 <ski> if we define
22:24:05 <ski>   f ((^ 2) -> x) = g x
22:24:19 <ski> then it appears that we are able to reason correctly like
22:24:30 <ski>      f 3
22:24:59 <ski>   =  f ((^ 2) -> ((^ 2) 3))
22:25:14 <ski>   =  f ((^ 2) -> 9)
22:25:19 <ski>   =  g 9
22:25:41 <cdsmithus> I don't understand why the second step would seem correct
22:25:42 <ski> but i'm not sure what `((^ 2) ->)' would mean, as a function
22:25:44 <Cale> I wouldn't use quite that sequence of steps, but okay
22:26:04 <ski> cdsmithus : `(^ 2) 3', which is `3 ^ 2', simplifies to `9'
22:26:05 <Cale> I would say that the initial equation means forall y. f y = g (y^2)
22:26:06 <cdsmithus> Oh, I'm confused.  nvm
22:26:17 <Cale> It's just another way of writing that.
22:26:46 <ski> (of course, the usual Haskell evaluation wouldn't force `3 ^ 2' at this point, the above was just an example of reasoning)
22:27:11 <ski> Cale : yes. but that's a contextual definition
22:27:33 <Cale> I don't see how it's any different from the interpretation of guards
22:28:04 <Cale> Sure, you can nest them, but it's easy to desugar.
22:28:17 <ski> imo, the `f x | p x = g x' syntax is "just" a funny notation for adding a precondition to an equation
22:28:53 <cdsmithus> ski: right, but in the same sense, so are view patterns.  Just you attach the conditions to the individual parameters
22:29:35 <ski> cdsmithus : no, view patterns are patterns themselves, they can occur anywhere nested within an argument pattern
22:29:56 <Cale> ski: But they desugar into normal patterns
22:30:04 <Cale> along with some additional bindings
22:30:23 <ski> i want a direct semantics for them
22:30:35 <ski> you can always add desugaring rules
22:30:40 <cdsmithus> ski: So your concern extends equally to pattern guards?
22:30:46 <ski> i want a way to think of view patterns "in themselves"
22:31:31 <aavogt> interesting concerns. I just though "hey cool, expressions in patterns themselves!"
22:31:31 <ski> cdsmithus : pattern guards are (mostly) similar to guards in the respect. since they can't occur nested, they are not as problematic, impov
22:32:35 <ezyang> Huh, Haskell doesn't have SSL implementation? That seems poor...
22:32:44 <cdsmithus> ezyang: True... and annoying
22:32:51 <jlouis> ezyang: I use hopenssl
22:33:00 <cdsmithus> @google hopenssl
22:33:02 <lambdabot> http://gitorious.org/hopenssl
22:33:02 <lambdabot> Title: Haskell FFI bindings to OpenSSL - Gitorious
22:33:05 <ski> a comparision with two Lisps
22:33:17 <ski> in Scheme we can write
22:33:22 <ski>   (define foo
22:33:26 <ski>     (lambda (x y)
22:33:31 <cdsmithus> That's nice!  I could have used that... though, getting haxr to use it would have been another challenge
22:33:36 <ski>       (+ (* x x) (* y y))))
22:33:46 <ski> and, there's a "sugar" for this
22:33:50 <ski>   (define (foo x y)
22:33:58 <ski>     (+ (* x x) (* y y)))
22:34:08 <ski> while, in CL, we write the latter as
22:34:14 <ski>   (defun foo (x y)
22:34:21 <jlouis> hopenssl is not the full bindings, but it was sufficient for some parts
22:34:23 <ski>     (+ (* x x) (* y y)))
22:34:33 <jlouis> at least for the sha1 sum I needed :)
22:34:48 <cdsmithus> jlouis: Ah, okay.  Got it.  But not actual SSL, it appears
22:34:49 <ski> imo, the CL "sugar" variant is strictly less declarative than the Scheme variant
22:35:11 <Makoryu> ski: Yeah. That always irked me about CL.
22:35:20 <ski> because in the Scheme variant, the left-hand-side `(foo x y)' has the same shape as the corresponding expression that will invoke the function
22:35:31 <ski> while in CL, we don't have this correspondence
22:36:00 <jlouis> Good moaning btw. I can't sleep more
22:36:24 <jlouis> In reality, I got Cale'ish in my sleeping pattern as of late
22:36:31 <ski> iow, we can think of the `(define (foo x y) ..x..y..)' form in Scheme as declaring that an equality between two expressions hold (for every value of `x' and `y'), while we can't read the CL variant declaratively, as easily
22:36:37 <Cale> jlouis: heh
22:36:52 <pastorn> Cale: what are your sleeping patterns?
22:36:54 <Cale> jlouis: Going to bed in the morning and waking up in the afternoon?
22:37:08 <pastorn> Cale: awesome!
22:37:15 <pastorn> like me, at times :)
22:37:23 <ski> for similar reasons, the `f x y' in `f x y = ..x..y..' in Haskell is a good choice of syntax
22:37:57 <JoeyA> When I import a source file with ghci, it says:   [1 of 1] Compiling Sieve ( sieve.hs, interpreted )
22:38:11 <JoeyA> Can I make it so sieve.hs is first compiled?
22:38:37 <ddarius> JoeyA: Compile it.  Then it will be loaded compiled.
22:38:41 <JoeyA> ghc -c sieve.hs first ?
22:38:49 <ddarius> JoeyA: Yes, that should work.
22:38:53 <ski> in Haskell, the patterns that can't be thought of as expressions are `_',`<var> @ <pat>',`~ <pat>' (if i'm not forgetting any)
22:39:05 <JoeyA> ddarius: thanks
22:39:22 <aavogt> well the @ and ~ are sort of out of place like the -> for view patterns
22:39:22 <jlouis> Cale: yes!
22:39:23 <cdsmithus> ski: Definitely, I understand and agree with that... pattern matching without guards has a very nice quality of just declaring an equality... If the right hand side happens to not do non-pattern stuff, you can reverse the equality.  That's nice.
22:39:44 <ski> aavogt,cdsmithus : right.
22:40:05 <jlouis> I wonder if it is the Haskell coding which affects me
22:40:15 <ski> (btw, i have some ideas for how to interpret `<var> @ <expr>' as an expression :)
22:40:20 <cdsmithus> jlouis: Nope, Haskell code has no effects
22:41:50 <ski> (Cale : but yes, i agree that guards are also somewhat ugly in this respect .. but i think the lack of nesting makes them nicer)
22:42:07 <Cale> ski: I might see what you're driving at now
22:42:55 <cdsmithus> ski: So, if the concern is this symmetric property (modulo, of course, that you need to restrain the types of expressions that can occur in patterns), then I think somewhat explicitly, view patterns were introduced for cases where you can't get that to work.
22:44:02 <ski> cdsmithus : maybe. i still wonder if there's really any sense in "equational reasoning" such as the above from `f 3' to `g 9'
22:44:11 <cdsmithus> (Somewhat relevantly, add record field patterns to your list of places where this doesn't work exactly right)
22:44:59 <ski> (i was wondering if there were examples of record patterns in this category as well, but i couldn't recall whether it was an extension or not)
22:45:16 <cdsmithus> ski: Well, I think you can match in one direction, as you did.  But the reverse direction, in general, involves computing the inverse of an arbitrary function.
22:45:44 <ski> well, the computability isn't the point
22:46:08 <ski> (the point is the equational reasoning)
22:46:56 <ski> but, yes, in general, functions do not have inverses .. which leads me to suspect that a declarative semantics for view patterns might have to involve non-deterministic expressions
22:47:18 <ski> (well,s/inverses/half-inverses/, i think)
22:47:52 <cdsmithus> Then if you know that x = g y, you can substitute (f (g -> x)) for y, and equational reasoning works.
22:48:17 <cdsmithus> (if f (g -> x) = y, that is)
22:48:18 <Peaker> bottomy bottoms
22:48:50 <cdsmithus> ski: sure, certainly functions have inverses when treated as relations, and that's good enough here
22:48:51 <ski> above i used a rewrite rule from the expression/pattern `x' to `foo -> foo x' (for any `x' and `foo')
22:49:31 <ski> and i suspect that what we really neeed is that the set of solutions of the first expression/pattern here is included in the set of solutions of the second one
22:50:00 <jimbo1> cdsmithus: I'm sorry I had to AFK for a bit, but I have a question about interpolate
22:50:07 <cdsmithus> jimbo1: Sure, go ahead
22:50:19 <jimbo1> I understand now what it does, but I dont think it's what I need
22:50:26 <jimbo1> So in matlab, if I say interp1( (0:4) , [1,2,10,4,5] , (0:0.21:4) )
22:50:37 <jimbo1> it returns
22:50:53 <jimbo1> 1.0000    1.2100    1.4200    1.6300    1.8400    2.4000    4.0800   5.7600    7.4400    9.1200    9.4000    8.1400    6.8800    5.6200   4.3600    4.1500    4.3600    4.5700    4.7800    4.9900
22:50:58 <cdsmithus> I don't know matlab, so you'll have to explain what that means.
22:51:25 <jimbo1> Sure, so the first element (0:4)
22:51:37 <cdsmithus> What is (0:4)?
22:51:37 <jimbo1> just is a list [0..4]
22:51:40 <cdsmithus> Okay
22:51:51 <jimbo1> the second element is my vector of values
22:52:35 <jimbo1> So do you see what the interp1 function does?
22:52:45 <cdsmithus> Okay, so in my code, you'd want those first two arguments as a list of ordered pairs.  zip can do that for you.
22:52:55 <cdsmithus> > zip [0..4] [1, 2, 10, 4, 5]
22:52:56 <lambdabot>   [(0,1),(1,2),(2,10),(3,4),(4,5)]
22:53:05 <ski> (cdsmithus : i'm not sure i follow your `x = g y' example .. substitute `f (g -> x)' for `y' in what ? .. in `f (g -> x) = y' ?)
22:53:09 <jimbo1> Right
22:54:11 <jimbo1> But you see in my example, the element 2 is replaced with 1.84 and 4.08
22:54:11 <cdsmithus> And then you want to map that onto the last argument... map (interpolate (zip [0..4] [1,2,10,4,5]) [0, 0.21 ... 4]
22:54:27 <jimbo1> Hmmmmm
22:54:29 <jimbo1> OK
22:55:05 <cdsmithus> Umm, except  you should pet in the second close parenthesis that I left out
22:55:10 <cdsmithus> ^put
22:55:23 <jimbo1> at the very end? or after the zip?
22:55:41 <JoeyA> Why does this yield a stack overflow?  It's tail-recursive.  let f :: Int -> Int -> Int; f a c | c > 0 = f (a+c) (c-1) | otherwise = a in f 0 1000000
22:56:06 <ski> JoeyA : you don't incrementally force the accumulator
22:56:29 <Pseudonym> It probably won't overflow the stack if you compile with -O2 or something like that.
22:56:39 <Damien> anyone on
22:56:39 <cdsmithus> map (interpolate (zip [0..4] [1,2,10,4,5])) [0, 0.21 .. 4]
22:56:42 <ski> JoeyA : replace `f (a+c) (c-1)' with `(f $! a+c) (c-1)', e.g.
22:56:46 <Damien> oh
22:56:50 <jimbo1> right thats what I thought
22:56:51 <Damien> finally
22:56:57 <Pseudonym> anyone `on` fst
22:56:59 <ski> (JoeyA : or use `seq', or bang-patterns)
22:57:12 <Pseudonym> :t who `on` fst
22:57:13 <lambdabot> Not in scope: `who'
22:57:24 <jimbo1> LOL
22:57:35 <ski> @type any `on` fst
22:57:35 <lambdabot>     Couldn't match expected type `a -> Bool'
22:57:36 <lambdabot>            against inferred type `[a]'
22:57:36 <lambdabot>     In the first argument of `on', namely `any'
22:57:51 <cdsmithus> ski: Sorry, I was being confusing there... yes, if I have the equation: f (g -> y) = y, and I can find x such that g x = y, then I can replace y with f x.  That's what I meant.
22:57:54 <Damien> anyone know anything bout making games -.-
22:58:11 <Pseudonym> Damien: I wrote an obfuscated tic-tac-toe implementation once.
22:58:25 <Damien> just wanted to ask if there was someone that knew a lil
22:58:29 <Damien> or enuf
22:58:34 <cdsmithus> ski: So you need to compute the inverse (just as a relation)... but, if you know that, you can certainly do the substitution
22:58:36 <Pseudonym> Enough for what, though?
22:58:42 <Damien> to make a thing like hammer editor
22:58:48 <Damien> for counterstrike'
22:58:49 <jimbo1> cdsmithus: your version still gives quite different results
22:58:54 <Damien> like a 3d world maker
22:59:00 <Damien> dont care if its pixels
22:59:09 <Damien> i just wanna know what code i should get into
22:59:20 <cdsmithus> jimbo1: Okay, let me look at it...
22:59:20 <Damien> or opengl or d3d
22:59:22 <jimbo1> OK
22:59:25 <Damien> alright
22:59:33 <Damien> has top side and other side view
22:59:34 <ski> cdsmithus : so you're really replacing `y' with `g x' (i presume) in `f (g -> y) = y' yielding `f (g -> g x) = g x', which simplifies to `f x = g x', which you can then apply on a call `f 3'
22:59:35 <jimbo1> I will make you a hpaste of the results from yours vs. matlab
22:59:37 <Damien> and a cam view
22:59:47 <Damien> and u just put objects in it
22:59:58 <Damien> seems fairly simple... i guess
23:00:15 <Makoryu> Damien: Sure, you can probably do it in about five lines of code, I think
23:00:21 <Makoryu> So there's no reason for us to do it for you
23:00:29 <Makoryu> You *have* read SICP, right?
23:00:40 <Damien> to me?
23:00:40 <cdsmithus> jimbo1: Yes, it does... I think it's broken.  Sorry!
23:00:43 <Makoryu> Damien: Yes
23:00:50 <jimbo1> Any ideas?
23:00:57 <Makoryu> Damien: I said your name. Damien: Should I use it more often?
23:00:58 <jimbo1> I don't know if I can do this myself.
23:01:16 <Damien> no, i havent
23:01:25 <Damien> dont know did squat bout codes
23:01:30 <pikhq> I once wrote an adventure game engine in Brainfuck. That count as "knowing about making games"? :P
23:01:31 <Makoryu> Damien: If you haven't read your SICP today, you should read it.
23:01:41 <Damien> wtf, is sicp
23:01:45 <ski> @where SICP
23:01:46 <lambdabot> http://mitpress.mit.edu/sicp/
23:01:47 <jimbo1> pikhq: Crazy!
23:01:53 <pikhq> The Structure and Interpretation of Computer Programs.
23:01:56 <Damien> gmaker ftw
23:01:59 <Makoryu> Damien: lambdabot knows
23:02:28 <Damien> just want like a page...
23:02:31 <Damien> with how to do it
23:02:38 <Makoryu> Damien: It's called SICP
23:02:39 <Damien> instead of looking for each individual code
23:02:39 <pikhq> Damien: I think the answer to this is quite honestly "learn how to program".
23:02:44 <cdsmithus> jimbo1: My fault... on the line that does the actual calculation in my code, swap y1 and y2
23:02:48 <Damien> i know tard
23:02:57 <Damien> thats the case
23:02:58 <Damien> yo
23:03:05 <Damien> dont teh know if teh tru skills plant
23:03:06 <Damien> fucker
23:03:12 <jimbo1> OK I'll try it
23:03:18 <Damien> not sure if i want opengl or direct3d
23:03:24 <Damien> i got reallllly far
23:03:29 <Makoryu> Damien: That's not very bro of you. Also, your mom.
23:03:31 <pikhq> You're the "'tard" who can't use English correctly. :P
23:03:36 <Pseudonym> Damien, you should probably learn some geometry first.
23:03:44 <Damien> ,|,,
23:03:46 <jimbo1> cdsmithus: HEYYYYYYYYYY!
23:03:55 <Pseudonym> Because you'll need to know it whichever of those two you use.
23:03:55 <jimbo1> You deserve a party in your honor
23:03:55 <Damien> i got mountains trees
23:04:01 <Damien> stand with deers
23:04:02 <Damien> guns
23:04:04 <Damien> everything
23:04:04 <Damien> but
23:04:05 <pikhq> If you're going to be doing any 2D or 3D game development, Pseudonym is quite right. Geometry will be quite needed.
23:04:07 <Damien> i need teh grid
23:04:18 <Damien> i mean i want my own engine
23:04:18 <cdsmithus> jimbo1: For being a dork and getting simple linear interpolation wrong? :)
23:04:24 <Makoryu> Damien: There are people in #freenode who know a LOT about OpenGL and Direct3D
23:04:29 <Damien> ty
23:04:32 <pikhq> As well as *quite* plausibly some decent physics knowledge.
23:04:42 <jimbo1> cdsmithus: No!  For being a pro and figuring it out!
23:04:47 <Pseudonym> If it's a level editor, physics probably won't come up quite as much.
23:04:51 <pikhq> And shove trig in there, too.
23:05:05 <pikhq> Pseudonym: He wants his own engine.
23:05:20 <pikhq> Physics is going to come up for many a not-RPG thing.
23:05:20 <Damien> no an engine
23:05:22 <cdsmithus> jimbo1: In any case, the basic task is the same, but I'm guessing matlab doesn't have first-class functions, so they make you specify a list of sampling points.  I gave you the actual function, so you can evaluate it at whatever points you want
23:05:29 <Pseudonym> By which I assume he means that he wants to know how to take a polygonal model and show it on the screen.
23:05:37 <Damien> not*
23:05:40 <Pseudonym> No?
23:05:45 <jimbo1> cdsmithus: makes perfect sense
23:05:52 <Pseudonym> You actually want to write a complete game?
23:05:57 <jimbo1> Boy this place is hopping tonight
23:06:11 <ski> cdsmithus : recent matlab actually has lambda
23:06:21 <Pseudonym> Damien, do you have access to a good university-level library?
23:06:28 <pikhq> Damien: Actually, to be perfectly honest (and not just poke fun at you), I strongly suggest that you improve your English skills.
23:06:35 <pikhq> As it is the lingua franca of programming.
23:07:19 <pikhq> (and yes, I'm aware you're a native speaker. The point still stands.)
23:07:36 <cdsmithus> ski: Okay, then whoever wrote interp1 just didn't use it!
23:08:01 * ski hasn't looked at this "interp1"
23:08:02 <Damien> okay i just wanna know what language would you write a 3d world maker in...? any ideas
23:08:27 <Pseudonym> Honestly, it'd depend on my requirements.
23:08:29 <pikhq> Damien: This being #haskell, I must say: Haskell is quite a good option.
23:08:32 <Makoryu> Damien: Let's see. You could write it in Haskell.....
23:08:40 <blackdog> Damien: go learn Maya.
23:08:40 <jimbo1> Damien: Probably Brainfuck.
23:08:40 <pikhq> But, yes, it'd depend on the requirements of the task at hand.
23:08:46 <Pseudonym> But then, people have written modellers in Erlang.
23:08:58 <pikhq> C is quite plausible, and C++ is quite *popular* for this...
23:09:00 <jimbo1> Damien: or COBOL?
23:09:05 <pikhq> Java's got good library support, as always...
23:09:10 <jimbo1> :)
23:09:13 <pikhq> C# as well.
23:09:21 <pikhq> And Brainfuck's always fun. :P
23:09:23 <Pseudonym> Most of 'em are probably written in C++, though.
23:10:13 <jimbo1> No but seriously, yes most 3D games are written in a version of C/C++/C#.  Although I know a friend who has accomplished this feat in Haskell.
23:10:29 <Pseudonym> The reason why I ask about the library is that you're probably better working your way through a textbook on the subject.
23:10:41 <blackdog> Damien: you're asking the wrong question, basically. you almost certainly don't want to write much of it yourself. If you get a 3d modelling environment like Maya (or Blender if you're cheap), you can start playing around with 3D objects and export them to use them in whatever engine you end up with, with minimal scripting.
23:10:41 <Makoryu> jimbo1: Wait, who writes them in C#?
23:10:48 <Pseudonym> Whatever the modern equivalent of Foley/van Dam/Feiner/Hughes or Watt is.
23:11:27 <pikhq> Makoryu: Large number of games on Xbox Arcade are in C#.
23:11:41 <jimbo1> Makoryu: I believe the xbox indie game XNA system is based on C#
23:11:45 <Makoryu> pikhq: D'oh. I didn't think of that. :p
23:11:47 <jimbo1> Oh, sorry, a little late to respond
23:11:49 <pikhq> As Microsoft makes it very easy to get into, with XNA.
23:12:05 <Makoryu> Yeah, I guess XNA specifically makes C# work well for games
23:12:10 <cdsmithus> Well, you can pretty much write a game in whatever language you want.  Game engines, like rendering pipelines and the like, have different requirements
23:12:32 <jimbo1> Yeah I also have a friend who wrote a fairly simple game in C# for XBox Live and has sold ~20000 copies or something
23:12:56 <Pseudonym> Damn, I'm in the wrong business.
23:13:23 <jimbo1> It's unbelievable that he did that.  Games sell for a dollar, you get $.70 or something per sale.
23:13:40 <jimbo1> He spent a month or two on it and just sits back now...
23:14:00 <jimbo1> Not a full time gig, but for a college student, that's a pretty good deal.
23:14:06 <cdsmithus> Well, few of us are here because we think Haskell is the road to riches. :)
23:14:29 <jimbo1> :)
23:14:37 <Damien> 5 lines brotherman
23:14:42 <jimbo1> Here is the game if you are interested: http://marketplace.xbox.com/en-US/games/media/66acd000-77fe-1000-9115-d80258550169/
23:14:49 <jimbo1> And now I'll stop plugging him, :)
23:14:57 <Pseudonym> Oh, man.  Just leafing through the table of contents for the third edition of Watt's "3D Computer Graphics".  People really did seem to think that the programmers of the future would be using PHIGS or GKS.
23:15:15 <cdsmithus> What are PHIGS and GKS?
23:15:19 <Pseudonym> Even GL (this predates OpenGL) doesn't get a look-in.
23:15:21 <DigitalKiwi> cdsmithus: i thought haskell could get me laid
23:15:25 <DigitalKiwi> that's what that oen guy said
23:15:37 <Makoryu> Damien: I was lying about the 5 lines thing. It would probably take five *months* of work, and thousands of lines of code.
23:15:49 <pikhq> DigitalKiwi: Yes, but you may also have to change your gender preferences.
23:15:57 <Pseudonym> cdsmithus: They are a couple of archaic graphics pipeline APIs.
23:16:01 <DigitalKiwi> >.>
23:16:03 <cdsmithus> Ah, gotcha
23:16:07 <DigitalKiwi> he said with chicks!
23:17:03 <DigitalKiwi> 'twas cads
23:17:11 <pikhq> Did he specify that he meant the slang term for female Homo sapiens, or the common term for the newly-hatched forms of members of Aves?
23:17:31 <monochrom> The complete sentence was "haskell could get you laid chicken eggs"
23:17:35 <pikhq> Also, if the latter, I haven't a clue how *anything* could aid with that.
23:17:56 <monochrom> @faq can haskell get you laid chicken eggs?
23:17:56 <lambdabot> The answer is: Yes! Haskell can do that.
23:18:18 <pikhq> Oh, right. Lambdabot, who knows all, says so.
23:18:19 <Pseudonym> Haskell would be a fine language for writing an incubator thermostat controller in.
23:19:03 <blackdog> @vixen can haskell get you laid chicken eggs?
23:19:04 <lambdabot> Ooh, functional programmers are so hot!
23:19:08 <blackdog> see?
23:19:19 <pikhq> Hail lambdabot!
23:19:19 <monochrom> hahahah
23:19:29 <jimbo1> XD
23:19:31 <monochrom> hot eggs!
23:19:32 <blackdog> i knew that easter egg would come out eventually.
23:19:53 <lambdabot> I'm written in Haskell, so it can do something right.
23:20:05 <pikhq> :D
23:20:24 <jimbo1> hmm, does zip not work on [Double] ?
23:20:35 <pikhq> :t zip
23:20:37 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
23:20:39 <jimbo1> or is it just that both lists need to be the same type
23:20:42 <pikhq> Why wouldn't it?
23:20:43 <jimbo1> Probably that
23:21:01 <pikhq> jimbo1: Clearly both lists need to *have types*.
23:21:04 <monochrom> zip works on two [Double]s
23:21:11 <pikhq> But that's the only restriction.
23:21:21 <jimbo1> i cannot zip a [Int] and a [Double]
23:21:30 <cdsmithus> @ski: Back to earlier topics, just I think that can recover equational reasoning by substituting with the relation: x <=> (g -> g x) within that parameter of the function.
23:21:30 <lambdabot> Unknown command, try @list
23:21:33 <jimbo1>     Couldn't match expected type `Int' against inferred type `Double'       Expected type: [Int]       Inferred type: [Double]     In the second argument of `zip',
23:21:36 <pikhq> > zip [1,2,3] [1.0,2.0,3.0]
23:21:38 <lambdabot>   [(1,1.0),(2,2.0),(3,3.0)]
23:21:42 <monochrom> > zip ([] :: [Int]) ([] :: [Double])
23:21:43 <lambdabot>   []
23:21:46 <monochrom> works
23:21:47 <pikhq> Looks to me like you can.
23:21:50 <jimbo1> See, that's what I thought...
23:22:15 <pikhq> jimbo1: You have probably imported a different "zip" function.
23:22:48 <jimbo1> Is there an easy way to see which I have imported?
23:22:51 <pikhq> Or... Hmm.
23:23:00 <pikhq> What else could it be?
23:23:02 <jimbo1> I don't think that is the problem
23:23:12 <cdsmithus> jimbo1: Actually, no... the reason is that you're using the result in a context that expects a Fractional a => [(a,a)]
23:23:18 <DigitalKiwi> http://dpaste.com/193095/ pikhq
23:23:23 <pikhq> Oh. XD
23:23:34 <cdsmithus> jimbo1: map the fromIntegral function over the first list
23:24:09 <jimbo1> OK!!
23:24:28 <Damien> my english skills pwn
23:24:30 <Damien> fatty
23:24:39 <DigitalKiwi> i'm not fat!
23:24:44 <DigitalKiwi> i am 'fluffy'
23:24:44 <jimbo1> @faq can haskell get you laid?
23:24:44 <lambdabot> The answer is: Yes! Haskell can do that.
23:24:52 <Pseudonym> @remember Damien my english skills pwn
23:24:52 <lambdabot> Good to know.
23:25:00 <max_atre1des> there is a monad for that
23:25:00 <DigitalKiwi> *English
23:25:02 <Pseudonym> Sorry, had to write that one down.
23:25:29 <jimbo1> How does @remember work?
23:25:49 <Damien> i dont want to mess with making a game
23:25:55 <Damien> i wanna have all my stuff in one thing
23:26:10 <Damien> like if i did write a program that had my stuff on the grid no matter how hard it'd be
23:26:12 <mreh> Damien: you can make games in haskell
23:26:20 <Damien> i dont need a game maker
23:26:37 <pikhq> "On the grid"?
23:26:44 <pikhq> Oh.
23:26:49 <Damien> on a grid
23:26:55 <pikhq> (x,y) grid. That kind.
23:27:01 <Damien> x,y,z
23:27:04 <Damien> 3d
23:27:08 <Damien> with a little cam
23:27:26 <Damien> that parts pushin  it
23:27:38 <pikhq> You're not going to be making a game anytime soon.
23:27:50 <Damien> ive done made games
23:27:55 <Damien> i want a program
23:27:56 <pikhq> How much experience do you have with programming?
23:27:59 <Damien> just, a 1337 one
23:28:02 <Damien> none.
23:28:04 * DigitalKiwi scrolls up and sees what a jerk Damien has been being
23:28:05 <Damien> cept pascal
23:28:11 <jimbo1> LOL
23:28:15 <pikhq> None at all?
23:28:16 <Damien> :P
23:28:19 <Damien> nope
23:28:20 <mreh> Damien: what do you want to know?
23:28:22 <pikhq> Okay, then.
23:28:23 <Damien> just wanted some pointers
23:28:26 <Pseudonym> Damien, how about maths?
23:28:31 <Damien> and have crack heads putting me down
23:28:32 <mreh> c has pointers
23:28:36 <Damien> 104 in algrebra
23:28:37 <Pseudonym> You know about trigonometry?  Vectors?
23:28:40 <pikhq> The secret to becoming a good programmer is to be willing to devote your life to it.
23:28:46 <Damien> and all i did was sleep in there
23:28:52 <Pseudonym> We don't care about your score, BTW.  Just how much you know.
23:28:55 <pikhq> I, myself, have spent 12 years at it. And have merely become decent.
23:28:59 <Damien> yeah, i mean im all around good at pcs
23:29:01 <DigitalKiwi> wah we never covered vectors in this trig course i just finished D:
23:29:13 <mreh> Damien: good for you, what is it you want to know then?
23:29:20 <jimbo1> Damien: To be fair, you came in here and immediately called people "tards" and "fuckers."  You can't expect people to WANT to help you.
23:29:24 <JoeyA> Why is setBit on an Integer so slow as the number gets larger?
23:29:24 <Makoryu> Damien: You've said "tard" or "fuck you" to everyone who offered you sane advice. Please either shape up and listen, or go pound sand.
23:29:25 <Damien> just some smalls stuff
23:29:36 <jimbo1> Makoryu: Looks like we're on the same page!
23:29:36 <mreh> guys keep it friendly please
23:29:39 <Damien> b4 that somebody was being shameful
23:29:41 <Damien> anyway
23:29:42 <cdsmithus> DigitalKiwi: Yeah, 3D graphics math tends to be covered in linear algebra courses a bit?  Some of the ideas anyway
23:29:53 <Damien> is opengl2 or d3d better
23:29:53 <Pseudonym> Yeah.
23:30:02 <Damien> like... for linux
23:30:03 <JoeyA> I ran a test that sets 100000 sequential bits in a number
23:30:07 <pikhq> Damien: Actually. http://catb.org/~esr/faqs/smart-questions.html Read this essay before you ask another question.
23:30:08 <JoeyA> It took 75 seconds
23:30:13 <Pseudonym> I don't think you can get D3D for Linux.
23:30:16 <Makoryu> Damien: D3D does not work on Linux.
23:30:21 <Damien> ah good deal
23:30:27 <Damien> one i like though
23:30:28 <pikhq> ("How to Ask Questions the Smart Way", by ESR)
23:30:35 <Damien> no wonder i couldnt get this to work
23:30:39 <cdsmithus> Oh, I hate that "smart questions" essay.  It's really very insulting
23:30:40 <Damien> i mean i tried wine"ing it
23:30:41 <JoeyA> whereas 10000 took .25 seconds
23:30:54 <DigitalKiwi> cdsmithus: i just realized it now, when we were doing polar coords i was reminded of vectors (i've done them in previous trig courses) but then we didn't cover them :(
23:31:06 <pikhq> cdsmithus: Only moderately.
23:31:14 <Damien> more data to process
23:31:41 <DigitalKiwi> d3d works on linux quite well!
23:31:51 <DigitalKiwi> in wine >.>
23:31:53 <JoeyA> Setting bits by left-shifting an Integer 1 is faster, coming in at .684 seconds for 100000 bits
23:32:10 <Damien> idk, its saying i dont have enough volume
23:32:15 <Damien> ive messed with it for ours
23:32:27 <Damien> with sudoing to installing 8 gigs of crap
23:32:28 <DigitalKiwi> talk louder
23:32:39 <mreh> Damien: do you have a haskell question?
23:32:55 <blackdog> cdsmithus: i think that's just ESR's attitude rubbing off a bit - the actual content's pretty good, i think.
23:32:57 <Damien> yea what is it
23:33:06 <Damien> google ftw
23:33:12 <mreh> @google haskell
23:33:13 <lambdabot> http://www.haskell.org/
23:33:14 <lambdabot> Title: Haskell - HaskellWiki
23:33:21 <mreh> there's loads on there
23:33:23 <cdsmithus> cdsmithus: Oh, I know it's his personality rubbing off.  I'd still never point someone to it
23:33:35 <blackdog> cdsmithus: first sign of madness, that
23:34:11 <Damien> iq can only be so high
23:34:38 <DigitalKiwi> why did cdsmithus just ping himself >.>
23:34:43 <cdsmithus> I did?
23:34:48 <cdsmithus> Oh!
23:34:54 <Damien> ::
23:34:55 <cdsmithus> Umm, I don't know actually.
23:35:06 <Pseudonym> Your IRC client is becoming sentient.
23:35:20 <jimbo1> haha
23:35:43 <Damien> so, brainfuck it is?
23:35:55 <jimbo1> jimbo1: Skynet is now sentient.
23:36:02 <cdsmithus> cdsmithus: Quit talking to ourself in public.  You're making us look crazy!
23:36:02 <pikhq> Brainfuck is certainly *entertaining*, but I wouldn't suggest it to any new programmer.
23:36:13 <pikhq> It's a diversion for people who already can program.
23:36:23 <Damien> well
23:36:27 * mreh wishes people would speak in complete sentances
23:36:35 <Damien> haskells mainly for what now?
23:36:41 * blackdog thinks mreh is
23:36:53 <pikhq> Haskell is a general purpose functional programming language.
23:36:55 <mreh> Damien, it's a general purpose programming language
23:37:11 <pikhq> And as such, is quite usable for most purposes one could write a program for.
23:37:13 <Damien> im still a nub
23:37:23 <Makoryu> Damien: Don't worry. We can tell.
23:37:24 <jimbo1> You can do just about anything in most programming languages.  Sort of like you can write just about anything with any pencil or pen.
23:37:29 <Damien> good deal
23:37:31 <jimbo1> No?
23:37:36 <Pseudonym> :t nub
23:37:37 <lambdabot> forall a. (Eq a) => [a] -> [a]
23:37:47 <arw> you can also do anything with a general turing machine :)
23:37:52 <jimbo1> Pseudonym: You have me cracking up!
23:38:13 <Pseudonym> Like most programming languages, Haskell is mainly for writing its own compiler in.
23:38:14 <monochrom> I can't write a CDR with a pencil
23:38:19 <Damien> so its not basic
23:38:22 <pikhq> Pseudonym: *grin*
23:38:23 <cdsmithus> Damien: If you're looking for things Haskell is particularly good at: (1) concurrency, (2) DSLs, and (3) doing hard stuff
23:38:35 <pikhq> Damien: No, BASIC is a particularly crappy language.
23:38:43 <Damien> yea
23:38:48 <Damien> so is pascal
23:38:48 <Pseudonym> Hey, most of us started out on BASIC.
23:38:57 <pikhq> Pseudonym: Doesn't make it less crappy.
23:39:01 <Pseudonym> Well, no.
23:39:06 <pikhq> (and yes, I started on BASIC too)
23:39:06 <muhtimin> I'd say basic is good what it's for. :)
23:39:11 <cdsmithus> I did do some BASIC.  At very formative years, no less.  That could explain a lot.
23:39:13 <Damien> so what was this wrote in
23:39:29 <pikhq> muhtimin: Running on an Apple II, or similarly powerful machine?
23:39:31 <Makoryu> Damien: Pascal is pretty much C with some details changed, you know.
23:39:38 <pikhq> Damien: Where "this" = ?
23:39:44 <blackdog> Makoryu: they kind of buggered up strings, though.
23:39:55 <Damien> really
23:39:58 <Damien> it was cake
23:40:00 <Makoryu> blackdog: So did Kernighan and Ritchie.
23:40:01 <Pseudonym> Makoryu: Err...
23:40:06 <Pseudonym> No.
23:40:08 <blackdog> not that strings in C are wonderful either, but they're barely usable...
23:40:13 <Pseudonym> Pascal is simplified Algol.
23:40:25 <Makoryu> Pseudonym: Yes, I know where it comes from.
23:40:29 <Pseudonym> For recovering Algoholics.
23:40:32 <Damien> i wrote like a mario game in it
23:40:33 <Makoryu> （　≖‿≖）
23:40:39 <Damien> no jumping tho :(
23:40:42 <jimbo1> Yikes, time to debug.
23:40:50 <mreh> must have been a hard game
23:40:58 <Damien> lol
23:41:04 <Pseudonym> Sounds like you have a head start, though.
23:41:07 <Damien> im not getting anywhere
23:41:12 <blackdog> mreh: mario with no jumping sounds a bit like that tetris game xkcd featured recently.
23:41:20 <mreh> blackdog:?
23:41:24 <Damien> it was more like...
23:41:30 <Damien> river city ranssom
23:41:35 <Damien> one more time
23:41:39 <mreh> Damien: if you like games check out FRP, after you've learned you a Haskell
23:41:40 <Damien> we gonna celebrate
23:42:09 <blackdog> mreh: http://xkcd.com/724/
23:42:34 <Damien> so would the grid deal be hard with hask
23:42:46 <mreh> tetris hell, ah
23:43:12 <Damien> can u use pics or would i have to align a grid somehow
23:43:18 <Damien> wow
23:43:26 <Damien> idk man
23:43:41 <Damien> i got half of it done though
23:43:42 <mreh> Damien: what kind of grid are we talking about? graphics? an array?
23:43:43 <Damien> in gimp
23:43:52 <Damien> have to be an array
23:44:00 <mreh> it doesn't have to be an array
23:44:03 <Damien> like x is the top and y is the side
23:44:12 <Damien> and thats where it would be in game
23:44:19 <mreh> you can use a map to represent a grid
23:44:19 <Damien> like info_node_player
23:44:24 <jimbo1> How can I use trace inside of a do construct?
23:44:35 <blackdog>   jimbo1: same as ever
23:44:40 <Damien> or w/e
23:44:41 <mreh> trace the whole IO action
23:44:48 <blackdog> :t trace
23:44:48 <jimbo1> mreh: what do you mean?
23:44:49 <lambdabot> Not in scope: `trace'
23:44:54 <blackdog> :t Debug.Trace.trace
23:44:54 <lambdabot> forall a. String -> a -> a
23:45:02 <mreh> like that
23:45:18 <Damien> well no help
23:45:19 <Damien> so..
23:45:20 <blackdog> so "a <- action" goes to "a <- (trace "blah" action")
23:45:31 <Damien> is anything possible with haskell? :D
23:45:32 <blackdog> urgh. i completely screwed the quotes there. sorry.
23:45:39 <mreh> Damien: get cabal and download some of the games on hackage if you want to see
23:45:52 <jimbo1> blackdog: sorry, maybe I stated my problem wrong
23:46:02 <jimbo1> I have a large let within a do
23:46:06 <jimbo1> can I still do this?
23:46:10 <jimbo1> in the let that is
23:46:13 <blackdog> sure.
23:46:16 <mreh> I wrote haskelloids in a couple of weeks
23:46:45 <muhtimin> ........................................................................................................................
23:46:51 <jimbo1> Oh, OK that was really easy
23:46:52 <pikhq> Damien: As Haskell is Turing complete, yes, anything that can be computed can be computed with Haskell.
23:46:55 <jimbo1> I'm just dumb
23:47:29 <cdsmithus> jimbo: if you use trace in a let binding, it won't actually print anything until you force the binding.
23:47:37 <blackdog> jimbo1: there are no dumb questions, just dumb people who should be shunned and vilified.
23:47:41 <jimbo1> What does that mean?
23:47:51 <jimbo1> You mean once the let is closed.
23:47:54 <Damien> so is haskell a series of languages
23:47:54 <jimbo1> That's a problem...
23:48:04 <pikhq> Damien: No, just a language.
23:48:17 <blackdog> do; let a = trace "BOO" 1; putStr "exiting"
23:48:22 <Damien> if i did find a code for "a game engine"
23:48:25 <Damien> what code would i have to use
23:48:25 <cdsmithus> No, I mean until you actually use the value.  Just giving it a name (with let) doesn't do anything
23:48:35 <pikhq> Read some stuff on it.
23:48:36 <blackdog> jimbo1: you never used a in that, so "BOO" won't ever get printed.
23:48:37 <pikhq> @where lyah
23:48:38 <lambdabot> http://www.learnyouahaskell.com/
23:48:42 <pikhq> @where real world haskell
23:48:42 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
23:48:59 <Damien> was that to me
23:49:04 <jimbo1> is there a way to just print within a let construct?
23:49:04 <pikhq> Yes.
23:49:06 <SColes> yes
23:49:07 <Damien> wow..
23:49:10 <pikhq> Start with LYAH.
23:49:10 <Damien> i hate reading
23:49:19 <DigitalKiwi> is that last lamdabot thing supposed to be a joke? >.>
23:49:25 <pikhq> Damien: This is a problem.
23:49:26 <pikhq> DigitalKiwi: Yes.
23:49:38 <cdsmithus> jimbo1: No.  Let bindings don't do anything.  They just define names
23:49:39 <blackdog> jimbo1: not really.
23:49:47 <jimbo1> right, I didn't think so,
23:49:48 <pikhq> Damien: You see, to do *anything* with programming, expect to spend a long amount of time reading.
23:49:56 <Damien> no codes like set cubes x,y,1,1
23:49:58 <pikhq> I, personally, spend pretty much of my day reading.
23:50:08 <Damien> i dont
23:50:09 <Damien> i game
23:50:22 <pikhq> You should fix that.
23:50:28 <blackdog> coding is hard, let's go fragging...
23:50:51 <Damien> so noone would help me if i did start
23:51:03 <Damien> i mean i would have to google haskell language tutorials or some bs
23:51:24 <pikhq> @where lyah
23:51:24 <lambdabot> http://www.learnyouahaskell.com/
23:51:37 <pikhq> There's the best introductory tutorial I know of.
23:51:53 <SColes> Damien, if you had a question other than "how do i maek gaem?" I'm sure that wouldn't be the case.
23:52:45 <mreh> Damien: to make games it takes a huge amount of dedication to the subject
23:52:45 <jimbo1> SColes: How do I shot web?
23:52:56 <Damien> its a
23:52:56 <SColes> jimbo1, very carefully... very carefully
23:52:58 <Damien> program..
23:53:03 <Damien> not a game
23:53:06 <Damien> nor an engine
23:53:23 <pikhq> Damien: To make programs requires a huge amount of dedication to the subject.
23:53:37 <pikhq> I've been doing this since I was *8*. *Eight*!
23:53:39 <Damien> of which
23:53:47 <Damien> kirby ftw
23:54:00 <Damien> no, i need like
23:54:06 <mgsloan>  pikhq - me too haha
23:54:07 <QtPlatypus> pikhq: I don't think it does.
23:54:24 <mgsloan> to make decent programs does
23:54:28 <pikhq> Don't expect to just "magically be awesome" after a short chunk of time.
23:54:34 <pikhq> QtPlatypus: To be good at it, it does.
23:54:47 <pikhq> To be a noob forever, obviously, takes hardly any effort.
23:54:57 <QtPlatypus> Yeah.
23:55:09 <QtPlatypus> But one starts off as a noob and then one learns.
23:55:14 <Damien> open screen 1024x768     divide 4 screens  one with x(top) y(middle) z(side)
23:55:16 <pikhq> Quite true.
23:55:19 <Damien> after that.. i'd be good
23:55:20 <QtPlatypus> And one way to learn is to learn by doing.
23:55:24 <pikhq> Just like anything else.
23:55:59 <kfish> Damien, spend 15min/day learning to program; mark off each day in your calendar that you did 15min; try not to miss a day
23:56:18 <pikhq> Damien: Yes. Reality check: you're going to become good after a *lot* of painstaking effort. You're going to read a lot. You're going to make a lot of shitty programs. They will get progressively less shitty.
23:56:44 <pikhq> Damien: You are probably also going to learn a lot of math *if* you focus on game development.
23:57:38 <Pseudonym> You don't need very much to start, though.
23:57:48 <Pseudonym> Vectors, matrices and some trig will get you started.
23:57:55 <pikhq> True.
23:57:55 <blackdog> there's an interesting problem in there, though. is there an environment that makes it easy to play with 3d stuff? something akin to logo for 2d?
23:58:18 <Damien> yeah, opengl dlls
23:58:29 <pikhq> Damien: Hah, hah, no.
23:58:32 <Damien> :D
23:58:49 <pikhq> That's state machine land. :P
23:59:11 <Damien> well see how deep im going
23:59:18 <Damien> and u guys dont help
23:59:20 <Damien> lol
23:59:58 <SColes> maybe haskell isn't a good language for what you want to do?
