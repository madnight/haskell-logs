00:01:17 <chewbranca> I just made sure haskell files are auto expanding tabs to spaces and it works fine now
00:01:29 <tomberek> kmc: would you mind looking at this, tell me if I'm just off to lunch: http://codepad.org/6sPyKQjA
00:01:34 <ski> (s/mix tabs and spaces/mix tabs and spaces for indentation\/layout/)
00:03:12 <ski> tomberek : maybe you wanted to load this in an interactor like GHCi or Hugs ?
00:03:44 <tomberek> ski : no, i'm just asking if that typeclass even makes sense
00:04:19 <ski> the error suggests that you're trying to compile and/or run this to an executable
00:04:36 <tomberek> ski : yeah, i shouldn't have checkmarked "Run Code"
00:05:17 <copumpkin> so do smerdyakov and xah_lee have permanent bans then?
00:05:38 <ski> the class declaration itself looks valid, i think
00:05:46 <tomberek> ski: I'm trying to say that I want to be able to Label types with other types.  The simplest would be (a,b) or data M a b = M a b
00:06:13 <ski> i'm not sure what you mean by that ..
00:07:20 <tomberek> ski: it compiles, but I've been running into so many dead-ends, I'd like a second opinion.    Eg: I want to take a type, be able to attach labels to it, but still use the original type in the original way.  I thought the Writer monad had all the plumbing for me, but couldn't get it to work.
00:07:41 <copumpkin> you just want a functor, I'd think?
00:07:49 <copumpkin> then you can fmap anything you want to it
00:07:54 <kmc> yeah
00:08:12 <copumpkin> (,) a is a label of type a on anything
00:08:21 <copumpkin> fmap on that will apply a function to the original value, preserving the label
00:08:35 <kmc> > fmap succ ("label",3)
00:08:36 <lambdabot>   ("label",4)
00:08:37 <copumpkin> > fmap (+1) ("I am a banana", 5)
00:08:38 <lambdabot>   ("I am a banana",6)
00:08:40 <tomberek> copumpkin : correct, and for simple structures, (,) is all i need)
00:08:45 <copumpkin> man, my label is so much better
00:08:46 <kmc> my spoon is too big!
00:08:51 <ski> tomberek : hm, iirc, edwardk had something that sounds similar to what you possibly is trying to do
00:08:58 <copumpkin> tagged?
00:09:00 <tomberek> ski, yeah, annotations
00:09:04 <copumpkin> that's type-level labels
00:09:17 <copumpkin> it's a phantom type in tagged
00:10:15 <ski> copumpkin : i'm not really in favor of permanent bans at all ..
00:10:20 <tomberek> copumpkin, kmc, ski: I want to be able to say not only is something simple like a string labeled, but that the elements of a Map or Tree, etc, are labeled
00:10:58 <copumpkin> how would the elements of a Map be labeled?
00:10:59 <ski> (copumpkin : well, maybe with the possible exception of "IRSeekBot", i.e.)
00:11:01 <copumpkin> individually?
00:11:40 <copumpkin> @let label = (,)
00:11:44 <lambdabot>  Defined.
00:11:48 <copumpkin> > label "my spoon is too big" 5
00:11:49 <lambdabot>   ("my spoon is too big",5)
00:11:54 <ivanm> copumpkin: :o
00:12:05 <ivanm> you're defining useless stuff again? :o
00:12:08 <copumpkin> > label "omg" M.empty
00:12:09 <lambdabot>   ("omg",fromList [])
00:12:12 <tomberek> copumpkin : the map as a whole can be labeled via (,)  but each element would need to be a tuple.  I want to abstract this to cases when you don't want to use a tuple.
00:12:17 <ivanm> hey tomberek
00:12:22 <tomberek> hey ivanm
00:12:23 <copumpkin> tomberek: why would you not want to use a tuple?
00:12:46 <copumpkin> it seems like if you wanted to label the elements individually, you just map the labels to the elements
00:12:53 <tomberek> copumpkin,,, why label each Int as (Int,Even) or (Int, Odd) when there's a simpler method
00:13:07 <ivanm> what are you two discussing this time?
00:13:24 <copumpkin> tomberek: what is it?
00:13:28 <ski> tomberek : what simpler method are you speaking of ?
00:13:29 <ivanm> tomberek: you haven't gone back to thinking that it'd be a good idea to subsume the node index into the label again have you?
00:14:02 <tomberek> ski, copumpkin: calculating it is quicker and cheaper than a lookup
00:14:14 <ski> "it" refering to ?
00:14:26 <copumpkin> tomberek: depends on the type though. if it's a peano natural, it's simpler to look it up
00:14:45 <tomberek> copumpkin: true, but as you said, it depends
00:14:53 <ddarius> In category theory a common way to represent the intuitive notion of a "labelled structure" is to use a slice category.  So an A-labelled B is a function B -> A.  Products are a trivial way, AxB -fst-> A, but you can do Int -even-> Bool.
00:15:01 <Olathe> @pl \f xs -> xs
00:15:02 <lambdabot> const id
00:15:08 <copumpkin> you think the cases in which it's faster to calculate it are common?
00:15:10 <djahandarie> So... is there going to be going to be a new std library which fixes all this Applicative/Functor/Monad mess?
00:15:25 <ski> tomberek : are you wanting to cache some information that can in principle be computed from the "labelled" data ?
00:15:45 <ivanm> djahandarie: it's highly unlikely to appear in the near future
00:15:59 <tomberek> ddarius: ok, then it looks like I'm looking for the Slice class?
00:16:11 <ivanm> since the current process for Haskell' is to do small gradual changes that have already been implemented (to prove that their actually implementable)
00:16:20 <ivanm> tomberek: is this to do with FGL?
00:16:43 <kmc> djahandarie, there are alternative prelude packages
00:16:48 <kmc> i don't know which ones are good etc.
00:16:56 <ski> ddarius : i'd be careful with "is" there .. an `A'-labelled object is a pair of an object `B' and a function `B -> A'
00:16:59 <tomberek> ivanm : i haven't done any FGL tonight, I'm playing around, trying to learn, force Haskell to do my bidding
00:17:03 <djahandarie> I wouldn't want anything I write to depend on some obscure package
00:17:22 <ivanm> tomberek: *phew* from usage of "label" I was getting worried that you were doing something crazy again...
00:17:28 <djahandarie> And even with a fixed Prelude, everything else would still be messed up and I would need to do a lot of hiding / redefining
00:17:41 <tomberek> ivanm : but fgl IS where I got the idea,, but don't worry
00:17:54 <tomberek> ivanm : crazy is good, no?
00:18:36 <ivanm> tomberek: not when I have to beat it through your head about why it's a bad idea! :p
00:18:42 <tomberek> ivanm: speaking of which, have you looked over the repo?
00:19:07 * ivanm makes a derogatory comment about how difficult it is to get through to an american or a member of the military without considering an american military person...
00:19:08 <ivanm> ;-)
00:19:10 <ivanm> tomberek: nope
00:19:14 <ski> ivanm : what's a bad idea ? :)
00:19:33 <ivanm> ski: tomberek has twice thought that it'd be great for FGL if the Node type was subsumed into the Label type
00:19:52 <ivanm> and then provide functions on how to get the Node value out, etc.
00:20:07 * ski isn't that familiar with FGL to know what function the `Label' type has
00:20:09 <ivanm> took me a while to convince him that it would lead to too many possible errors (mainly when specifying edges)
00:20:14 <ddarius> ivanm: I'm an American military member.
00:20:24 <ivanm> ddarius: but I haven't had to convince you of anything!
00:20:32 * ivanm points out that his brother is in the australian defence force
00:20:43 <ski> ivanm : maybe that's why you haven't tried ! :)
00:20:50 <tomberek> ddarius: where?
00:20:50 <ivanm> heh
00:21:18 <ivanm> ski: anyway, currently in FGL the graphs are of kind * -> * -> *, where the two type params are the node label and the edge label respectively
00:21:24 <ski> tomberek : anyway, you still haven
00:21:38 <ivanm> the labels are just extra things you attach to each node/edge, where there is currently "type Node = Int"
00:21:39 <ski> 't answered whether you are doing a cache of some sort or not
00:22:05 <tomberek> ski ; no
00:22:37 <ski> tomberek : ok, so you're talking about labelling with extra information that can't be computed (in general) from the value being labeled, then ?
00:22:53 <tomberek> ski, sure
00:24:17 <tomberek> ivanm : enough complaining about my martial profession, get to looking at the repo
00:24:47 <ivanm> awwwwww
00:24:57 <patch-tag> after upgrading patch-tag to ghc 6.12.1 I started having trouble serving pages with foreign chars, eg http://localhost/r/tphyahoo/hkl/snapshot/current/content/pretty/foreignchars.hs      this seems to be same issue as http://groups.google.com/group/pandoc-discuss/browse_thread/thread/8bfb53fb1b59bd1b%3C/span%3E?pli=1   however the solution there doesn't apply. locale command output -> everything is already utf8. any ideas?
00:25:11 <ivanm> patch-tag: you upgraded yourself? >_>
00:25:22 <ski> ivanm : well, my uninformed opinion is that one probably *could* merge labels and nodes in graphs .. *but*, if one's working with different labellings, that still pertain to the same graph, it could be inconvenient to have to change the graph structure, instead of just changing what is attached to each node (or edge, in case of edge-coloring)
00:25:23 <patch-tag> i do not like your tone.
00:25:24 <patch-tag> :)
00:25:27 <ivanm> patch-tag: anyway, as of 6.12.1 ghc starts using the locale for I/O
00:26:00 <ivanm> ski: the problem with making the index type part of the label is that then edges are of the form ((1, 'a'), (2, 'b'))
00:26:11 <ivanm> so you have duplicate information, with the possible problem of specifying the label wrong
00:26:15 * ski realizes "martial" maybe be etymologically related to "mars"
00:26:21 <patch-tag> I'm confused. I can do putStrLn a string with umlauts, but if I do readFile for a file with umlauts in contents I get that multi byte error
00:26:56 <ski> ivanm : index being ?
00:26:57 <ivanm> ski: yup, it is
00:27:01 <ivanm> ski: the Int
00:27:08 <ski> the node ?
00:27:09 <tomberek> ski, righto         ivanm: a 'smart' edge constructor would strip all that... but whatever, I'm no longer advocating that
00:27:22 <ivanm> patch-tag: what's the encoding used for that file as opposed to the system's locale?
00:27:30 <ivanm> tomberek: *phew*
00:27:32 <ivanm> ski: yeah
00:27:33 <patch-tag> how can I find out the encoding used for a file?
00:27:59 <ivanm> use file
00:28:04 <ivanm> file foo
00:28:31 <ivanm> tomberek: your idea had merit; it just means that someone constructing a graph manually could stuff up
00:28:50 <patch-tag> foreignchars.txt: ISO-8859 text  when it should be utf-8 I guess. so how can I make it use other encoding?
00:28:56 <ski> ivanm : so this is basically the same argument as used in the relational model for refering to objects by some kind of unique identifiers, and letting extra information pertaining to the objects be specified once in a separate relation ?
00:29:21 <ddarius> @google "Simplicial database"
00:29:23 <lambdabot> http://lambda-the-ultimate.org/node/3761
00:29:23 <lambdabot> Title: Simplicial Databases | Lambda the Ultimate
00:29:28 <ivanm> ski: yup
00:29:36 <ivanm> ski: since the extra information may not be unique
00:29:43 <ivanm> patch-tag: iconv IIRC
00:29:59 <ski> ddarius : interesting, ty
00:30:14 <tomberek> ivanm : ski get's the idea.  But anyway, for simplicity, I dropped it.  For now we're just trying to get a basic re-write of FGL out.
00:30:17 <ivanm> patch-tag: e.g. http://johnmacfarlane.net/pandoc/README.html#character-encodings
00:30:23 <ivanm> tomberek: yup
00:31:30 <patch-tag> thanks ivanm.
00:31:36 <ivanm> np
00:33:10 <ivanm> are there any good tutorials on TH?
00:33:44 <SubStack> template haskell -_-
00:33:55 <ivanm> SubStack: TH is a good tutorial on TH? :/
00:34:16 <SubStack> no, I just never did like template haskell very much
00:34:22 <SubStack> seems so out-of-place
00:35:17 <ivanm> well, I'm wanting to have some auto-instance generators
00:35:24 <ivanm> since atm type families can't do deriving :s
00:35:58 <ivanm> tomberek: do you care if I expand src/tgt to fromNode/toNode ?
00:36:53 <tomberek> ivanm : semantically, then we have fromContexts to Contexts fromNode toNode,, to many "from"
00:37:09 <ivanm> well, for some reason having that short "src" and "tgt" annoys me :s
00:37:24 <tomberek> ivanm: source, target?
00:37:27 <ski> (btw, `fromNode' and `toNode' might sound like functions that convert between nodes and some other thing)
00:37:35 <tomberek> ski, yeah
00:37:42 * ski was just about to suggest what tomberek did
00:37:44 <tomberek> source :: Edge g -> Node g
00:37:47 <ivanm> tomberek: well, partially it's because those names don't really mean much
00:37:55 <ivanm> ski: true
00:38:06 <ski> well, graphs by themselves don't really mean that much
00:38:23 <ivanm> ski: :o
00:38:25 <ivanm> sure they do!
00:38:32 * tomberek slaps ski upside the head.
00:38:58 <ski> i mean that depending on the domain of application of graphs, you might have better names that `source' or `target'
00:39:32 <tomberek> ah! he didn't mean "mean that much" in terms of intrinsic worth, only intrinsic meaning
00:39:44 <ivanm> ski: oh...
00:39:50 <ivanm> you're off the hook then... _this time_
00:39:52 <ivanm> ;-)
00:40:01 * ski grins
00:40:02 <ivanm> preflex: seen Cale
00:40:02 <preflex>  Cale was last seen on #haskell 10 hours, 36 minutes and 11 seconds ago, saying: and there are apparently a good number of interesting results for those, but I don't know if much is known about category algebras in general.
00:40:14 <ivanm> bah, and we can't even ask Cale about terminology
00:40:57 * ski has seen `source' and `target' (or abbreviations like `src', `tgt') used in texts (mostly on CT) that have treated graphs
00:41:00 <glguy> stuff like ‚Äúdomain‚Äù ‚Äúcodomain‚Äù ‚Äúrange‚Äù?
00:41:20 <ivanm> well, according to wikipedia there's also head/tail
00:41:29 <copumpkin> o.O
00:41:53 <tomberek> ivanm : confusing,,, does head point to the "head of the trail" or "head of the arrow"  or "head of the function"
00:41:57 <ivanm> and waddaya know, Graphviz got that the wrong way round... :@
00:42:06 <ski> maybe i've seen someone using `domain' and `codomain' (or `range' ?) (with abbreviations `dom' and `cod') but that conflicts with using those for categories, so i think in texts that treat both, usually `source' and `target' is used for graphs
00:42:13 <ivanm> tomberek: yeah, which confused me for a while with graphviz
00:42:28 <copumpkin> source and destination?
00:42:31 <ivanm> OK, I'll change that to source/target
00:42:42 <tomberek> ivanm: yeah, for a directed edge, that seems the best
00:42:43 <ivanm> I'd rather not do too many abbreviations, that's all
00:42:50 <tomberek> ok
00:42:53 * ski agrees with ivanm
00:43:08 <tomberek> NLabel -> NodeLabel?
00:43:29 <ski> copumpkin : possible (but for some reason i'd want to flip out `source' with some other word that goes better together with `destination' .. but i'm not sure what worD)
00:43:37 <ivanm> tomberek: yeah, I'll do that as well
00:43:42 <ski> tomberek : yes, please :)
00:43:48 <copumpkin> I guess :)
00:43:50 <copumpkin> anyway, bedtime
00:43:56 * copumpkin yawns
00:44:00 <krainboltgreene> What are filesystems usually written in?
00:44:07 <copumpkin> c or c++
00:44:14 <tomberek> EdgeLabel, degreeIn vs degIn
00:44:25 <ivanm> krainboltgreene: whichever language the kernel is written in would be my guess
00:44:29 <ivanm> which strangely enough is usually C
00:44:37 <ivanm> tomberek: inDegree and outDegree
00:44:43 <ivanm> copumpkin: so you're flying tomorrow?
00:44:50 <copumpkin> ivanm: tomorrow being sunday, yep
00:45:00 <ivanm> @time copumpkin
00:45:01 <copumpkin> leaving home saturday
00:45:02 <lambdabot> Local time for copumpkin is 2010-05-29 03:44:38 -0400
00:45:06 <krainboltgreene> ivanm: Would Haskell work well as a filesystem language?
00:45:09 <tomberek> ivanm: and to go extreme... gmap -> graphMappingFunctionThatWeLike
00:45:31 <ivanm> krainboltgreene: could be, but there's only been academic-level research on it now, no real-world usage
00:45:39 <ivanm> tomberek: nah, gmap can stay
00:45:46 <tomberek> hehe
00:45:52 * ivanm suspects tomberek is going a bit silly
00:45:54 <ivanm> @time tomberek
00:45:54 <krainboltgreene> I can't even find anything on Wikipedia about what uses what language. That's so strange.
00:45:56 <lambdabot> Local time for tomberek is Sat May 29 00:44:50 2010
00:46:05 <ivanm> krainboltgreene: what do you mean by "what uses what language"?
00:46:16 <tomberek> ivanm: i've been drinking
00:46:21 <ski> tomberek : i wouldn't mind `graphMap' :)
00:46:25 <krainboltgreene> ivanm: Well, I mean, what is Ext4 written in?
00:46:30 <ivanm> krainboltgreene: file systems themselves are just a standard way of reading in the bytes on a hard disk to get useful stuff out of it
00:46:31 <krainboltgreene> Or are filesystems a part of the kernal?
00:46:34 <ivanm> you could technically use anything
00:46:40 <copumpkin> ivanm: I quite like the interface of http://www.cs.nott.ac.uk/~nad/listings/lib/Data.Graph.Acyclic.html#343, which is based on fgl
00:46:43 <ddarius> Asking "what languages filesystems are written in" is like asking "what languages are audio format written in"?
00:46:45 <ivanm> krainboltgreene: yeah, filessytem drivers are ususally part of the kernel for efficiency reasons
00:46:51 <ddarius> -?
00:47:01 <tomberek> ivanm: actually, gmap is really contextMap, and nmap is nodeMap
00:47:10 <krainboltgreene> Interesting.
00:47:12 <ivanm> ddarius: well, WebM is written in Go, ins't it?
00:47:21 <ddarius> I don't know what WebM is.
00:47:26 <copumpkin> I think gmap, emap, and nmap are fine, myself
00:47:32 <ivanm> tomberek: yeah, and there was also emap
00:47:34 <copumpkin> they're common enough that having short names is good
00:47:47 <tomberek> copumpkin,, thanks
00:47:49 <ivanm> ddarius: google's new VP8 + theora + matroska format for HTML5 video
00:48:08 <tomberek> everyone: any ideas out there for a FGL rewrite? keep 'em coming
00:48:14 <krainboltgreene> OS level stuff is obfuscated for me.
00:48:15 <ivanm> copumpkin: what's that in?
00:48:16 <djahandarie> Ugh, WebM
00:48:21 <copumpkin> ivanm: agda
00:48:24 <pikhq> krainboltgreene: On Linux, filesystems get written in a *lot* of languages. We've got userspace filesystems, making it so that nearly anything that can interface with /dev/fuse can implement a filesystem.
00:48:26 <krainboltgreene> I wish there was a tag-based filesystem out there.
00:48:42 <copumpkin> it's basically a reduced fgl with lots more statically checked properties :)
00:48:42 <ivanm> "tag-based"?
00:48:45 <pikhq> (most commonly going through a C library, but you *can* manipulate /dev/fuse manually)
00:48:47 <ddarius> There probably is.
00:49:15 <ski> copumpkin : i wouldn't mind slightly longer names .. seeing that we can use `dabbrev-expand' :)
00:49:18 <krainboltgreene> ivanm: Yeah, that is instead of focusing on hierarchical directory-based organization, tags isntead.
00:49:32 <copumpkin> functorMap
00:49:34 <ski> (.. i.e. if slightly longer names makes the code more readable)
00:49:46 <ivanm> krainboltgreene: uggghhh
00:49:52 <ski> copumpkin : .. i wouldn't mind :)
00:49:53 <copumpkin> I think the short names for common operations are perfectly readable
00:49:54 <krainboltgreene> I would imagine the focus would be on file meta-data.
00:50:05 <copumpkin> it's just that we can't juggle loads of abbreviations, generally
00:50:13 <krainboltgreene> Would probably make filesystem searches a lot faster.
00:50:18 <ivanm> I like to explicitly sort my data and do whatever I want with it rather than trusting some hodge-podge metadata to do it
00:50:26 <ski> (copumpkin : but i also don't think `fmap' is really bad, since its both a common, and a quite abstract/general operation)
00:50:27 <copumpkin> I think longer names obscure the "structure" a bit more
00:50:36 <copumpkin> there's obviously a trade-off, anyway :)
00:50:42 <krainboltgreene> ivanm: That's a strange thing to say. Metadata would be set by you, so ... it'd be organized by you.
00:50:45 <krainboltgreene> Just like you like.
00:51:07 <ivanm> krainboltgreene: oh? really? so I would then have to explicitly go and do a lot of metadata tagging?
00:51:12 <ivanm> that sounds like more effort than its worth
00:51:27 <ivanm> much easier to set up a proper directory hierarchy and stick to it
00:51:35 <ddarius> You can, and it has been done, that each "directory" in a path simply corresponds to restricting by another "tag"
00:51:57 <krainboltgreene> ivanm: Since what we're discussing doesn't exist, I'm not sure I can gauge how difficult it would be to do something?
00:52:15 * krainboltgreene points to ddarius.
00:52:23 <krainboltgreene> Doesn't that bookmarking social site do that?
00:52:25 <ivanm> krainboltgreene: put it this way: do you go now and manually tag every photo, file, etc. you have on your computer?
00:52:29 <krainboltgreene> Can't remember the name, the one by Yahoo.
00:52:43 <krainboltgreene> ivanm: If it meant faster searches? Damn straight I would.
00:52:51 <krainboltgreene> And if tags were actually the focus.
00:53:04 <ivanm> also, people keep advocating such things based upon how iPhone does it and its really cool; yet you then have application lock-in because only one app reads a certain file type
00:53:17 <ivanm> krainboltgreene: how would having tags automagically make file system searching faster?
00:53:27 <ivanm> because it's all in one big explicit database?
00:53:34 <ddarius> ivanm: Nothing stops you from having a directory-like view and "copying" a picture into a directory corresponds to tagging it.
00:53:54 <krainboltgreene> ivanm: I've always noticed things searching faster if I do it in /home/krainboltgreene than in /
00:53:59 <davidL> krainboltgreene: del.icio.us
00:54:05 <krainboltgreene> davidl: Bingo, that's it.
00:54:09 <ivanm> krainboltgreene: strange that, you have much fewer files in ~/ than in /
00:54:23 <krainboltgreene> ivanm: Incorrect.
00:54:39 <krainboltgreene> ivanm: Well, I mean, / minus ~/.
00:54:44 <ivanm> oh? seeing as how ~/ is a subset of /, then you mustn't have any other files outside of ~/
00:54:48 * ski grins
00:54:56 <ivanm> and how are you searching?
00:55:02 <ivanm> I find locate works really well
00:55:10 <krainboltgreene> I think we're getting into semantics here.
00:55:14 <ivanm> and as for when I want a specific file/document, I know where it is because of where I've saved it
00:55:19 * ski thinks tags would need to be grouped into different areas of interest, to be useful
00:55:52 <ddarius> ski: I don't think that's necessary for them to be useful, but certainly a namespacing mechanism that adds back some hierarchical structure would likely be useful.
00:56:06 <krainboltgreene> Designing UI (this is what I'm good at) for hierarchical directory-based systems is a pain in the ass. Tag systems always go over better in my experience.
00:56:31 <pastorn> copumpkin!!!
00:56:33 <ivanm> huh? what UI do you need?
00:56:42 <ivanm> it's a _directory hierarchy_
00:56:45 <ivanm> pastorn: he's asleep
00:56:48 <pastorn> awww
00:56:50 <BMeph> Sounds like ZigZag...
00:56:50 <krainboltgreene> Anyways, I asked here because the Haskell group is on the cutting academic edge.
00:56:53 <ivanm> or at least said he was going to sleep...
00:57:01 <ivanm> krainboltgreene: of what though?
00:57:11 <djahandarie> ivanm, that doesn't mean there is only one interface to a hierarchy...
00:57:15 <ivanm> I doubt we're on the cutting edge of molecular physics...
00:57:31 <tomberek> ivanm : are you familiar with edwardk's fgl ideas?
00:57:38 <krainboltgreene> ...Computer Science?
00:57:49 <davidL> krainboltgreene: I would like to see something like that. I'm a big fan of using tags to organize things, and then filtering them later with unions/intersections/etc
00:57:59 <krainboltgreene> What does molecular physics have to do with filesystems and haskell? D:
00:58:15 <krainboltgreene> Learning Haskell was hard enough, don't tell me I have to know molecular physics too :/
00:58:25 <ddarius> davidL: I'm pretty sure something like that has been done and failing that it would not be hard to do.
00:58:38 <ivanm> tomberek: the annotation stuff?
00:58:43 <ivanm> they weren't really for FGL IIRC
00:58:48 <ivanm> djahandarie: what other interface is there then?
00:59:00 <djahandarie> ivanm, the finder in Mac, for example
00:59:09 <djahandarie> Looking at each level seperately
00:59:13 <krainboltgreene> davidl: There's this little microkernal OS called HelenOS that I've thought of trying to talk into using a tag-based filesystem, maybe with something other than C.
00:59:15 <ivanm> krainboltgreene: no, my point was you can't just say that we're on the "cutting edge" without qualifying what you mean and how it relates to you
00:59:25 <davidL> ddarius: the Be Filesystem does something like that, but it sucks
00:59:28 <tomberek> ivanm: that, branding, comonads... anything there useful?
00:59:34 <krainboltgreene> ivanm: We're in a Haskell room talking about filesystems. I'm pretty sure it's implied.
00:59:34 <ivanm> djahandarie: not really that different from any other interface...
00:59:42 <ivanm> tomberek: doesn't really apply to what we're doing
00:59:45 * djahandarie shrugs
01:00:03 <tomberek> ivanm: roger... ok, what's next for our project?
01:00:34 <ivanm> krainboltgreene: what makes you think that the Haskell community is on the cutting edge of filesystem stuff?
01:00:35 <ivanm> which is what you seem to be implying
01:00:35 <ivanm> tomberek: cleaning up the code, etc.
01:00:56 <ivanm> getting some TH (if I can grok it) to generate Show isntances (rather than have those ugly data/type hacks for Context and Edge)
01:01:01 <dv_> haskell and filesystems?
01:01:11 <dv_> I'd rather associate haskell and AI research
01:01:27 <ivanm> dv_: exactly
01:01:28 <dv_> or haskell and mission-critical software
01:01:31 <krainboltgreene> Nevermind Ivanm.
01:01:32 <ivanm> and even that is stretching it
01:02:06 <dv_> yes, well, actually I mean neural network stuff
01:02:26 <ivanm> dv_: it isn't that associated in current academia that much AFAIK; it's just starting to be used from what I've heard
01:02:28 <dv_> which is actually pure statistics
01:02:38 <dv_> and heuristics
01:02:39 <ivanm> of course, I'm not in that field so I could be wrong
01:03:04 <dv_> so languages like C would add tons of overhead for allocating memory etc.
01:03:18 <tomberek> dv_ : NNs? talk to alpounet... in fact, the FGL rewrite was prompted by the attempt at writing a NN library
01:03:28 <dv_> but filesystems are very low-level stuff, where C is king
01:03:48 <ivanm> tomberek: not quite true
01:03:58 <tomberek> ivanm : from my side
01:04:02 <davidL> there are haskell bindings to fuse
01:04:03 <ivanm> fair enough
01:04:09 <dv_> tomberek: sometimes I imagine skynet is written in liskell :)
01:04:27 <ivanm> the FGL rewrite was prompted by Martin Erwig saying he's had enough (possibly by someone from HNN wanting something in FGL...)
01:04:30 <ddarius> File systems are just like file formats.  File system -drivers- are typically in C, but that is because they have to interface with a C kernel.
01:04:36 <ivanm> dv_: why liskell?
01:04:45 <ivanm> ddarius: yup
01:05:02 <dv_> ivanm: well, lisp lists & macros + haskell
01:05:20 <ivanm> yeah, I have a vague understanding of what liskell is
01:05:31 <ivanm> but why would skynet be written in liskell rather than pure haskell?
01:05:33 <pastorn> dv_: no, it's all perl
01:05:34 <dv_> thinking along the lines of this: http://xkcd.com/224/
01:05:41 <ivanm> unless liskell supports eval...
01:05:45 <mah01> I want to replace text in ByteString with regular expressions. Is there some simple library to do that? With smth like 'replace (mkRegex "a") "abcd" "X"'
01:06:02 <ivanm> mah01: see the regex libraries
01:06:07 <ivanm> pretty sure they support Bytestrings
01:06:12 <ivanm> RWH has a chapter on them
01:06:28 <mah01> yeah.. there are plenty of them with ByteString support. But I am specifically looking for simple replace
01:06:32 <tomberek> ivanm: yeah, we had been poking and pestering Martin
01:06:47 <ivanm> see, whereas I was just going to do an end-run around the whole problem ;-)
01:07:04 <ivanm> mah01: if you want to use regexes, _nothing_ is simple ;-)
01:08:06 <dv_> yeah
01:08:17 <dv_> sometimes I think the world needs an wysiwyg ide for these things.
01:08:21 <mah01> ivanm, right, but cmon, I want simple text replacement. And what these regex libraries give me is just insane return
01:08:24 <mah01> for example execute :: Regex -> ByteString -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
01:08:48 <ivanm> mah01: there are some String replacement libraries, but I don't know if any of them support bytestrings
01:09:01 <ivanm> and I don't recall regex returning anything like that
01:09:06 <ivanm> mah01: which library is that from?
01:09:14 <mah01> Text.Regex.PCRE.ByteString
01:09:43 <ivanm> mah01: which _library_ is that from?
01:09:45 <ivanm> not which module ;-)
01:09:51 <mah01> ivanm, regex-pcre
01:10:10 * ski wonders why it needs `IO' ..
01:10:15 <ivanm> mah01: you use it via regex-base
01:10:43 <ivanm> mah01: read through the RWH chapter
01:10:46 <ivanm> ski: C binding
01:11:00 <ski> that doesn't answer it
01:11:09 <ski> (by itself)
01:11:15 <ivanm> mah01: or even http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
01:11:43 <mah01> ivanm, thanx, I will check that right away
01:11:43 <ski> are you suggesting that it mutates some state (which is observable) ?
01:12:01 <ivanm> ski: or they just haven't unsafePerformIO'd it yet
01:12:09 <ivanm> that appears to be an internal module that you're not meant to use
01:12:50 <ski> that could be it, i suppose
01:15:52 * ivanm -> dinner
01:19:58 <tomberek> (a->b)->(a->c)->(b->c->d)->d   does something like this exist out there?
01:20:21 <portnov> :t on
01:20:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:20:37 <kmc> @hoogle (a->b)->(a->c)->(b->c->d)->d
01:20:37 <lambdabot> No results found
01:20:44 <kmc> @djinn (a->b)->(a->c)->(b->c->d)->d
01:20:44 <lambdabot> -- f cannot be realized.
01:20:48 <int-e> @type liftM2 (+)
01:20:49 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
01:20:49 <tomberek> yeah, i hoogled and hayoo'd it
01:21:06 <ski> tomberek : where would the `a's come from ?
01:21:18 <int-e> @type \a b f -> liftM2 f a b
01:21:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => m a1 -> m a2 -> (a1 -> a2 -> r) -> m r
01:21:28 <tomberek> a->(a->b)->(a->c)->(b->c->d)->d
01:21:29 <tomberek> oops
01:21:31 <int-e> @type \a b f x -> liftM2 f a b x
01:21:32 <lambdabot> forall t a1 a2 r. (Monad ((->) t)) => (t -> a1) -> (t -> a2) -> (a1 -> a2 -> r) -> t -> r
01:21:41 <ski> @djinn a->(a->b)->(a->c)->(b->c->d)->d
01:21:41 <lambdabot> f a b c d = d (b a) (c a)
01:21:49 <tomberek> @djinn a->(a->b)->(a->c)->(b->c->d)->d
01:21:50 <lambdabot> f a b c d = d (b a) (c a)
01:21:51 <tomberek> nice
01:22:12 <tomberek> but there isn't anything already out there in prelude?
01:22:42 <ski> looks like some kind of variant of `on' and `ap' ..
01:22:59 <ski> (or rather `liftM2' than `ap', i suppose)
01:23:34 <ski> tomberek : maybe you can use what int-e suggested ?
01:23:44 <int-e> > ((:) <$> succ <*> replicate 10) 2
01:23:44 <lambdabot>   [3,2,2,2,2,2,2,2,2,2,2]
01:25:39 <tomberek> int-e: not using Monads.. i guess djinn's output works, not fancy, but works
01:26:14 <kmc> @pl \a b c d -> d (b a) (c a)
01:26:14 <lambdabot> ap (flip . (((.) . flip . flip id) .) . flip id) (flip id)
01:26:19 <kmc> there, easy as pie
01:26:28 <tomberek> puch
01:26:37 <tomberek> ouch
01:26:44 <int-e> "something like ap" indeed ;)
01:27:01 <kmc> :t flip id
01:27:02 <lambdabot> forall a b. a -> (a -> b) -> b
01:27:18 <int-e> @pl \d b c a -> d (b a) (c a)
01:27:18 <lambdabot> liftM2
01:27:18 <ski> (int-e : when i was saying `ap', i was thinking of the combinator `s', which doesn't have a (direct) name in Haskell, though)
01:27:26 <pastorn> @type ap
01:27:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:27:30 <tomberek> kmc: is there a channel I can play with djinn and @pl without clogging the this channel?
01:27:52 <pastorn> @type (<*>)
01:27:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:27:55 <int-e> @pl \f g x -> f x (g x)
01:27:55 <lambdabot> ap
01:27:57 <pastorn> hmm.....
01:28:01 <ski> tomberek : ok, then maybe you can use `(<*>)' and `(<$>)', which uses `Applicative' and `Functor', instead ? :)
01:28:03 <int-e> ski: of course @pl disagrees ;)
01:28:19 <ski> int-e : note the "direct" :)
01:28:32 <ski> (iow, `ap' is too general)
01:28:33 <Botje> tomberek: you can /query lambdabot
01:28:46 <Botje> or just /msg lambdabot @pl ...
01:29:03 <int-e> @type (<*>)
01:29:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:29:45 <int-e> (also a generalization of S)
01:30:10 <ski> .. because it is a generalization of `ap'
01:30:50 <int-e> .. or would be, if every Monad had the obvious Applicative instance as well.
01:41:39 <tomberek> anyone remember the characters available for infix?
01:44:10 <ivanm> tomberek: you mean `foo` ?
01:44:14 <ivanm> or defining new operators?
01:44:30 <tomberek> defining new ones.. i remember seeing the list
01:44:41 <kmc> tomberek, http://www.haskell.org/onlinereport/syntax-iso.html
01:45:06 <ivanm> tomberek: combination of any symbols except for ( and ) IIRC
01:45:08 <kmc> !#$%&*+./<=>?@\^|-~
01:45:17 <tomberek> hm
01:45:18 <ivanm> oh, right, no [,{,] or } either
01:45:28 <kmc> or anything unicode regards as a symbol or punctuation, except _:"'(),;[]`{}
01:45:40 <tomberek> kmc, thanks
01:45:45 <ivanm> kmc: you can use :, can't you?
01:45:52 <ivanm> though if it starts with : it denotes a constructor
01:46:02 <ivanm> oh, and it can't start with --
01:46:03 <kmc> you're right
01:46:22 <kmc> the grammar is symbol {symbol | :}
01:46:25 <kmc> where the braces mean zero or more
01:47:03 <kmc> and it can start with --
01:51:13 <ivanm> kmc: oh? I thought ghc bitched if you had --<symbol>
01:55:13 <jkramer> Is there a good library for web form input validation?
01:55:41 <BMeph> Alexandria. ;˛
01:55:58 <voker57> jkramer: regex?
01:56:17 <jkramer> lol
01:56:35 <jkramer> I mean something more structured
01:57:11 <jkramer> Something like http://search.cpan.org/~lyokato/FormValidator-Simple-0.28/lib/FormValidator/Simple.pm
01:57:15 <kmc> ivan, i just tested it
01:57:24 <kmc> ivan, it's suspicious and a good lint tool would point it out
01:58:59 <Cale> ivanm: terminology question?
02:00:52 <tomberek> Cale: yes
02:01:47 <tomberek> Cale: (Graph g) => Edge g -> Node g     src/tg   source/target   fromNode toNode,  we thought source/target was best
02:02:11 <Cale> These are directed edges?
02:02:14 <tomberek> yep
02:02:24 <Cale> Yeah, source and target are good.
02:02:37 <tomberek> ok... thanks
02:02:44 <Cale> Especially as 'head' and 'tail' are taken ;)
02:03:12 <tomberek> yeah,, and those are confusing... "head of the arrow" ~= "head of trail"
02:03:27 <Cale> Oh?
02:03:35 <Cale> Oh, I see what you mean.
02:03:43 <tomberek> the head of trail means begining,,, head of arrow is what it points to
02:03:57 <tomberek> so 'head' is bad terminology for directed edges
02:04:01 <Cale> Normally I'd think head of the arrow.
02:04:23 <tomberek> agreed, but source/target just seem so much better, unambiguous
02:04:27 <Cale> But yeah, you have a point that it's a bit confusing when talking about paths
02:04:31 <Cale> yeah
02:05:15 <tomberek> Cale: ivanm should be cleaning up the fgl rewrite code right now
02:05:33 <Cale> By the way, has anyone else been playing with Wolfgang Jeltsch's records library?
02:09:04 <Cale> I think it's really cool. :)  Sort of like a modernised version of HList using new type system features (type families in particular) to make things a good bit more straightforward.
02:09:17 <scree> It seems to be one of those that's really easy to learn to use, unless you see the type signatures
02:09:33 <Cale> Well, there are worse type signatures ;)
02:09:47 <scree> I don't like using those ones either
02:11:56 * ski idly wonders whether formlets provide form input validation
02:12:25 <Cale> It's a good bit easier to use now. I was having trouble with ambiguous types (particularly with the 'style' parameters), but there's a withStyle function to help disambiguate things now, and a few more handy combinators :)
02:13:56 <Baughn> ..so when are we going to get something like this in GHC? >_>
02:14:16 <Cale> Something like what?
02:14:19 * Baughn just found Records. Good documentation.. doesn't look too bad.
02:14:28 <Baughn> records, lenses.. you name it.
02:14:52 <Baughn> I'm so very tired of manually writing code that would be trivial with lenses..
02:14:54 <Cale> Yeah, well, the existence of this library is starting to convince me that maybe libraries really are the best way to go with extensible records.
02:15:59 <Baughn> Which reminds me, I must fix data-accessor-template so it works again
02:16:07 <Cale> In the end, we might just need to get the GHC guys to add a new subkind of * which is filled with one-element types whose names are identified with the names of their values.
02:16:22 <Cale> Like, `foo :: `foo
02:17:23 <Cale> (Which would be super-useful for record label names)
02:18:00 <scree> in terms of convenience, or a deeper reason?
02:18:08 <Cale> Mostly convenience.
02:18:27 <Cale> There's a fair amount of boilerplate you have to write currently.
02:18:34 <scree> on that front, a one-line TH Name declaration would be nice
02:18:49 * Baughn groans. Utterly broken ghc install...
02:18:55 <scree> don't know if/why there is/n't one
02:20:10 <Baughn> Hm. Somewhere between uploading to hackage and installing locally, the utf-8 copyright sequence in AES appears to have turned into latin-1, which kills ghc-pkg?
02:20:30 <pastorn> scree: there is with fclabels
02:21:14 <Baughn> ..oh. Changed locale at some point. Oh dear.
02:21:14 <pastorn> scree: you just have to do data A = A { _x :: X, _y :: Y } and then place $ or something in front of that declaration
02:21:50 <Baughn> Well, it would be nice to not have to do that. >_>
02:22:45 <pastorn> Baughn: true, true
02:22:58 <Baughn> Hum. But I have to wonder about the runtime efficiency of Jeltsch's records.
02:23:03 <pastorn> then finally we could have puts for MonadState
02:23:11 <klaas111> hi
02:23:12 <pastorn> Baughn: linky?
02:23:15 <scree> pastorn: I meant for the Name class in the records library, though fclabels is also nice
02:23:18 <Baughn> http://hackage.haskell.org/packages/archive/records/0.1.1.0/doc/html/Data-Record.html
02:23:23 <klaas111> what is the meaning of ($) ?
02:23:32 <klaas111> and how could I find out for myself next time?
02:23:35 <Starfire> @src ($)
02:23:36 <lambdabot> f $ x = f x
02:23:36 <Baughn> @src ($)
02:23:36 <lambdabot> f $ x = f x
02:23:48 <djahandarie> Is hs-plugins messy?
02:23:57 <pastorn> klaas111: the key point with $ is how it binds
02:24:04 <pastorn> klaas111: in ghci: :i ($)
02:24:15 <klaas111> thanks
02:24:15 <pastorn> it should say something about 'infix*'
02:24:29 <Baughn> klaas111: $ is lowest-precedence, which essentially makes it work as a left paranthesis, with the closing right-paranthesis as far to the right as possible.
02:24:47 <Baughn> > map ($ 2) [(+1),(+2)] -- klaas111: But you can also do things like this
02:24:48 <lambdabot>   [3,4]
02:25:07 <Baughn> > map (`id` 2) [(+1),(+2)] -- ..well.
02:25:07 <lambdabot>   [3,4]
02:25:22 <scree> > succ $ length $ map (+1) $ replicate 4 $ pred 3
02:25:23 <lambdabot>   5
02:25:30 <scree> klaas111: ^^^
02:25:39 <klaas111> so in xmonad configs...
02:25:49 <djahandarie> > succ . length . map (+1) . replicate 4 . pred $ 3
02:25:51 <lambdabot>   5
02:26:20 <klaas111> pending left parenthesis makes sense
02:26:21 <klaas111> to me
02:26:28 <scree> djahandarie: it was for educational rather than stylistic purposes
02:27:02 <djahandarie> Mine was for education AND stylistic purposes. :P
02:27:05 <BMeph> I'm curious; does the TIOBE index give any useful information at all? I can't see the point of an index that ranks Erlang lower than PowerShell (!). :\
02:28:04 <mauke> BMeph: it does a google search for "$language programming" and counts the results
02:29:23 <djahandarie> Wait, seriously?
02:30:15 <ivanm> that's pretty much it
02:30:16 <Cale> klaas111: Yeah, ($) is just function application, but it has really low precedence.
02:30:34 <Baughn> I still say $ should be left-associative. ;_;
02:30:45 <Cale> Baughn: and I still agree with you :)
02:30:46 <ivanm> Baughn: submit a proposal then!
02:30:54 <ivanm> why though? what difference does it make?
02:31:04 <djahandarie> That would be nicer actually
02:31:09 <Cale> ivanm: There are a few reasons
02:31:19 <ivanm> such as...?
02:31:24 <Cale> 1) Function application is normally left associative
02:31:45 <ivanm> how does that affect how you use $ though?
02:31:55 <Cale> 2) Every time we currently see f $ g $ h $ x with the current right associative $, we can replace that by f . g . h $ x
02:32:09 <Cale> So there's no point in having the right-associativity
02:32:20 <ivanm> Cale: and making $ left associative would prevent people from doing that?
02:32:25 <ivanm> if so, that's good enough for me :p
02:32:27 <ski> 3) `$!'
02:32:27 <Cale> Well, yes
02:32:34 <Cale> 3) Yes, $!
02:32:48 <ivanm> what's wrong with $!?
02:32:49 <Cale> It's awkward to apply more than one parameter strictly with $!
02:32:56 <ski> @src foldl'
02:32:56 <lambdabot> foldl' f a []     = a
02:32:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:33:03 <Cale> Obviously, we want $! to have the same associativity as $
02:33:25 <Baughn> ivanm: Proposing a change is pointless, with all the existing code. Otherwise I would.
02:33:39 <Baughn> ivanm: Haskell has failed. ;_;
02:33:40 <Cale> and currently if you want to strictify f x y z, you have to write ((f $! x) $! y) $! z
02:33:46 <Cale> re-associating things to the left
02:33:47 <ski> ivanm : the second equation there should be  foldl' f a (x:xs) = foldl' f $! f a x $ xs  but we can only write it as  foldl' f a (x:xs) = (foldl' f $! f a x) xs  if we want to use `$!'
02:33:55 <ivanm> Baughn: it failed because it became popular? :p
02:34:03 <Baughn> @quote success
02:34:04 <lambdabot> Pseudonym says: If the Romans had a zero, their programs would have been able to signal successful termination.
02:34:14 <Baughn> @quote at all costs
02:34:14 <lambdabot> No quotes for this person. It can only be attributed to human error.
02:34:15 <pastorn> Baughn: what would be the point in changing it from left to right?
02:34:21 <ivanm> @quote costs
02:34:21 <lambdabot> Baughn says: "<dpratt71> so I read somewhere that the unofficial  motto of Haskell was \"avoid success at all costs\"...<Baughn> dpratt71: Yeah. We failed."
02:34:31 <ski> Baughn : i don't think changing it in a new major implementation version would be that bad
02:34:41 <Cale> Baughn: I think there's a lot less abuse of $ now than there was a couple years ago
02:35:02 <Baughn> pastorn: From.. left to right?
02:35:10 <scree> surely the best way is just to change what the lambdabot does
02:35:13 <pastorn> yeah, for $
02:35:19 <scree> after that it's bound to catch on
02:35:24 <Cale> :)
02:35:28 <ski> pastorn : it currently already *is* right-associative
02:35:31 <scree> people might hate you, but ...
02:35:36 <Baughn> pastorn: We want it to be left-associative.
02:35:38 <Baughn> Cale: Go do it!
02:35:40 <pastorn> why?
02:35:47 <Baughn> pastorn: Scroll up
02:35:50 <ski> pastorn : see above
02:35:51 <Cale> 4) More expressions can have the parens removed from them
02:35:55 <ivanm> pastorn: I already asked that!
02:36:07 <Baughn> (+) $ foo 2 $ bar 3
02:36:17 <Cale> For example,  f (g x) (h y) (k z)  could be written  f $ g x $ h y $ k z
02:36:19 <ivanm> Cale: eh, preventing f $ g $ h $ x is good enough for me
02:36:25 <tomberek> Cale: what about a new operator that is left-associative ?
02:36:36 <ivanm> we already had the problem where someone asked why we have . if we can just use $
02:36:38 <Cale> tomberek: What easy-to-type symbol are you going to steal?
02:36:41 <Baughn> tomberek: I keep wanting to write an AdvancedPrelude..
02:36:46 <Baughn> It would have this change, among other things.
02:36:54 <tomberek> Cale : (~$)
02:36:55 <Cale> It's silly to have both
02:37:00 <Baughn> (And much fewer functions. WHy is log in the prelude? Seriously?)
02:37:08 <tomberek> (#)
02:37:08 <ivanm> Baughn: and fix up the Numerical hierarchy and the Monad hierarchy, etc.?
02:37:09 <Cale> The right associative one is completely unnecessary
02:37:22 <Baughn> ivanm: That, I can't do just like that.
02:37:23 <ivanm> I think the Prelude should stop re-exporting Data.List stuff, etc.
02:37:28 * Baughn nods
02:37:35 <Baughn> Export type-classes instead
02:37:43 <ivanm> admittedly, it's nice for quick and dirty hacks in ghci
02:37:51 <Cale> Baughn: I think it makes sense for log to be in the Prelude
02:38:01 <ivanm> so unless we have some kind of prelude plus as the default in ghci...
02:38:05 <djahandarie> ghci should just import Data.List automatically :P
02:38:13 <ivanm> Cale: well, it has to be wherever the Floating point stuff is defined
02:38:17 <ivanm> djahandarie: heh
02:38:21 <Baughn> Cale: I don't. I more frequently want log to be a logging function than to be math.
02:38:30 <ivanm> same with Data.Maybe
02:38:35 <Cale> Wow, I'd not even thought of that :)
02:38:46 <ivanm> Baughn: hmmm.... nah, maths is more important!
02:38:48 <ivanm> :p
02:38:55 <ivanm> unless we split numbers off into a separate module
02:39:02 <Cale> log *must* be the natural logarithm ;)
02:39:03 <Baughn> Cale: Point is not to clutter the fundamental namespace, which we can't actually replace very easily
02:39:10 <ivanm> Cale: damn straight!
02:39:19 <Baughn> No! It must be log10!
02:39:20 <djahandarie> Prelude shouldn't be "you can write a decent haskell program with only this stuff"... it should be the core stuff required to write anything at all.
02:39:31 <Baughn> Agreed
02:39:32 <Cale> log10 is so useless and stupid
02:39:45 <Baughn> Cale: log2, then?
02:39:50 <djahandarie> Although, it's possible that they had the list stuff in there to write other functions easier though, not sure
02:39:51 <ivanm> I would support keeping only the equivalent of Num and maybe Integral in the Prelude and shifting the rest of the numerics stuff
02:40:02 <ski> .. one'd have to be careful with cases like "withFoo foo . replicateM n $\n  yield $ frob 42", though
02:40:03 <mauke> ld, lg, ln
02:40:06 <Cale> logBase 2 you might want to be lg
02:40:30 <scree> we can have different preludes for different people
02:40:32 <Cale> But I honestly don't really think there's much need for a concept of logarithms to any base but the natural one
02:40:41 <scree> computer scientists have log = log2
02:40:44 <Cale> They're all easy scalar multiples of each other anyway
02:40:50 <scree> mathematicians can have log = log_e
02:40:52 <Baughn> log foo / log 2 is pretty easy
02:40:55 <Cale> and the natural one is the one with all the good properties
02:41:09 <ivanm> scree: nah, I would say that computer scientists are more likely to ignore the base
02:41:16 <ivanm> since it's just a constant factor difference anyway
02:41:20 <ivanm> and what's another constant factor?
02:41:25 <ivanm> Cale: yup
02:41:28 <Cale> If I were the dictator of mathematical notation, I'd abolish logs to other bases.
02:41:29 <tomberek> log = ln in Big - O
02:41:35 <ivanm> for calculus, exponential growth, etc.
02:41:40 <djahandarie> Can the other bases be calculated more efficiently than a division?
02:41:57 <ivanm> Cale: well, it can be shorter to write log_b rather than log x/log b all the time
02:42:06 <Baughn> tomberek: log = exp in Big-X
02:42:10 <scree> ivanm: O(2^(log2 x)) /= O(2^(log x)) :P
02:42:26 <ivanm> scree: heh
02:42:35 <Cale> ivanm: sure, but it forces you to remember a bunch more identities which would normally be obvious consequences of the properties of division
02:43:09 <mauke> preflex: calc ln 1000
02:43:10 <preflex>  6.907755278982137
02:43:13 <mauke> preflex: calc ld 1000
02:43:13 <preflex>  9.965784284662087
02:43:50 <Baughn> ..what
02:44:01 <Baughn> I'm pretty sure that's supposed to be 3
02:44:07 <mauke> preflex: calc lg 1000
02:44:07 <preflex>  3
02:44:14 <Cale> lol
02:44:41 <ski> scree : .. but then `f' and `g' being in the same complexity class doesn't entail `(2^) . f' and `(2^) . g' being in the same complexity class
02:44:56 <cwraith> so preflex has ld and lg backwards.  nice.
02:45:08 <mauke> how is that backwards
02:45:10 <int-e> ? ld = base 2, lg = base 10.
02:45:13 <ski> mauke : what does the `d' in `ld' stand for ?
02:45:16 <mauke> dyadic
02:45:18 <ivanm> Cale: this is a common problem IMHO: when teaching, you often want to present a simpler example, which is why in high school you often have log = log10
02:45:29 <Cale> ivanm: I don't think that's really simpler.
02:45:33 <scree> ski: no, certainly not
02:45:43 <Cale> ivanm: Also, I don't think the way that logarithms are taught in highschool is at all appropriate.
02:45:55 <Cale> Teaching about logarithms before Calculus is really dumb.
02:45:59 <scree> ski: I'm just saying, since complexity usually uses 2^n for exponential, it must be using log_2 for log
02:46:02 <ivanm> Cale: what's easier for students to understand and calculate in high school: using base 10, or using e which they probably haven't heard of yet?
02:46:10 <ivanm> Cale: logarithms have uses outside of calculus
02:46:18 <ivanm> and if you give me some time I'm sure I can think of some! :p
02:46:25 <Cale> ivanm: They don't even have *definitions* outside calculus :)
02:46:28 <voker57> how do i state multiple class restrictions? like (Class1 a), (Class2 b) => ...
02:46:31 <wvd> I've been interested in programming games in functional languages, however, why is almost every game programmed using Yampa and FRP?
02:46:47 <mauke> I was taught logarithms as the other inverse of exponentiation
02:46:56 <ivanm> Cale: sure they do: log_b a = x ==> a = b ^ x
02:47:02 <mauke> voker57: like a tuple
02:47:13 <ivanm> voker57: (Class1 a, Class2 b) => ...
02:47:13 <Cale> ivanm: and what does b^x mean when x is not a rational number?
02:47:20 <voker57> thanks
02:47:24 <Cale> How do we even know that equation has a solution at all?
02:47:29 <ski> scree : well, if we had a notation for exponential that could easily omit the base, then i'm sure people would often do this (and isn't this what "EXP-TIME" &c. is ?)
02:47:31 <scree> Cale: they don't have definitions outside *analysis*
02:47:33 <mauke> Cale: pocket calculator, duh
02:47:41 <Cale> scree: okay, sure :)
02:47:42 <ivanm> Cale: well, I don't know about you but I didn't learn about complex numbers then...
02:47:44 <ivanm> ;-)
02:47:59 <Cale> ivanm: I'm not even talking about complex numbers
02:48:13 <ivanm> oh, just arbitrary decimals?
02:48:14 <Cale> I'm just saying, what the fuck does 2^(sqrt(2)) mean?
02:48:24 <ivanm> > 2 ** sqrt 2
02:48:26 <lambdabot>   2.665144142690225
02:48:30 <ivanm> Cale: ^^ that's what it means
02:48:33 <Cale> It's not 2 multiplied by itself sqrt(2) times, I'll tell you that ;)
02:48:37 <scree> ski: ok, but "exponential time" isn't a complexity class
02:48:48 <ski> true
02:48:57 <ivanm> Cale: *shrug* OK, it might not have any meaning without calculus
02:49:01 <scree> ski: and 2^n occurs as a complexity class a lot more often than e^n :)
02:49:02 <ivanm> in terms of definitions
02:49:05 <mauke> Cale: we can approximate it by rationally approximating sqrt(2)
02:49:05 <ski> (the "TIME" is refering to what is measured)
02:49:08 <ivanm> but it can still be of _use_
02:49:11 <ivanm> interest rates, etc.
02:49:18 <Cale> mauke: And... taking a limit? :)
02:49:23 <Cale> *cough*
02:49:24 <mauke> uh oh
02:49:50 <ski> ivanm : s/==>/<=>/ :)
02:49:52 <int-e> Cale: well, with that context, what does sqrt(2) mean?
02:50:01 <ivanm> ski: eh, whatever ;-)
02:50:06 <Cale> int-e: Indeed.
02:50:24 <mauke> int-e: x where x*x = 2
02:50:28 <Cale> int-e: Of course, we can say that it's a positive solution to the equation x^2 = 2
02:50:37 <Cale> int-e: But it's not obvious that such a number exists.
02:50:39 <Baughn> int-e: If you're starting with that, what does 2 mean?
02:50:46 <scree> int-e: that's easy.  it's the image of X in Q[X] / (X^2 + 2)
02:50:49 <int-e> Cale: but I believe it's fine to introduce concepts in a non-rigorous way. you need some guiding examples to justify limits and all that.
02:50:56 <scree> s/+2/-2
02:51:10 <Cale> int-e: I just think that introducing the logarithm needlessly early is pushing it.
02:51:17 <Baughn> sqrt(2) is a number, which can't be fully written down in any other form
02:51:36 <ski> (or, possibly `x =< log_b a  <=>  b^x =< a', e.g. if you're wanting truncating logarithms for naturals)
02:51:39 <Baughn> ..sqrt(2) means sqrt(2).
02:51:41 <Cale> int-e: I saw a lot of people get confused by logarithms in highschool for no other reason than that the definition we were given was actually circular.
02:51:49 <mauke> 2^{0.5}
02:52:11 * Baughn quickly hides mauke under a tent
02:52:44 <Cale> Of course, this is only a tiny fragment of what's wrong with highschool mathematics education.
02:53:18 <mauke> what was that definition?
02:53:28 <scree> I think in some parts of eastern europe they really do start teaching analysis at highschool equivalent
02:53:57 <int-e> Baughn: oh, there are so many 2-s - 2 could be an equivalence class of Dedekind cuts, which in turn are sets of rational numbers, which are equivalence classes of pairs of integers, which are equivalence classes of pairs of natural numbers, which are the finite ordinal numbers, where 2 is {{},{{}}}.
02:54:35 <int-e> Baughn: clearly you can't introduce real numbers to high school students that way ;)
02:55:21 <Cale> mauke: Well, I say "circular", but they didn't really complete the circle directly. We had log_b x = y <=> b^y = x, but typically the definition of b^y is exp(y log b) in the first place.
02:55:51 <mauke> "typically"?
02:56:01 <scree> int-e: sqrt 2 doesn't refer to something in that construction; it has type (Complete a, Ord a, Field a) => a
02:56:04 <mauke> I've never seen that definition of b^y in school
02:56:07 <Cale> There are lots of choices of definitions you could make
02:56:16 <int-e> at that level they should define b^y for integer exponents and for rational exponents with positive b (assuming you gloss over the root issue), and leave it at that.
02:56:35 <Cale> We just didn't receive a definition of b^y at all, though we did see that potential definition as an identity.
02:57:22 <Cale> There was a missing definition, and a bunch of circularly related identities with nowhere that things got tied down :)
02:58:13 <mauke> hmm. when/where do you learn the definition of "set"?
02:58:30 <Cale> Which one? :)
02:58:43 <Cale> I didn't learn the ZFC definition of set until pretty late.
02:59:02 <int-e> naive set theory goes a long way
02:59:08 <mauke> the one that's used all over calculus and linear algebra
02:59:11 <ivanm> I don't think I've ever learned ZFC set theory
02:59:12 <mauke> without an explanation
02:59:23 <scree> int-e: it goes all the way :)
02:59:24 <wvd> I've been interested in programming games in functional languages, however, why is almost every game programmed using Yampa and FRP?
02:59:43 <ivanm> no wait, I did groups in high school, so I must have learnt something about sets then...
02:59:57 <scree> int-e: to every possible proposition
03:00:04 <ivanm> wvd: because people think the Reactive approach translates better to how to write games
03:00:16 <Cale> We were introduced to some basic things which were valid to do with sets in my first year algebra and calculus courses.
03:00:33 <Cale> Nothing like the axiom of replacement, mind you :)
03:01:06 <djahandarie> I've been thinking about doing a math minor since it's really interesting... but my math grades are never that great
03:01:10 <wvd> ivanm: Are there any articles which clearly give the differences between functional programming and functional reactive programming?
03:01:18 <Cale> But you don't really need all of ZFC for most basic linear algebra and calculus.
03:01:24 <ivanm> wvd: maybe one of the reactive papers?
03:01:24 <djahandarie> I always tend to make dumb mistakes on exams and such
03:01:41 <ivanm> wvd: I've never really bothered to take the time to learn and understand reactive programming tbh
03:02:12 <scree> so, I think my first year lecturer for this was insane and presented most of the actual ZFC axioms
03:02:22 <wvd> ivanm: Me too, and like, Haskell itself is already high-level enough, I don't need high-high level.
03:02:44 <djahandarie> Haskell "mad baked" version
03:02:49 <Cale> djahandarie: My friend Adeel was in electrical engineering to begin with in university, and failed a bunch of stuff, including his mathematics courses. He switched to a mathematics degree and his marks went from 40's to 90's.
03:03:05 <scree> no-one understood four words together of what he was saying, but ...
03:03:13 <ivanm> wvd: it's not "high-high" level IIUC; it's just a different approach to I/O, etc.
03:03:14 <Cale> They explain stuff better in the courses which are designed for mathematicians ;)
03:03:33 <wvd> ivanm: Well, Yampa is implemented in (Haskell?) so it gives you an extra buffer.
03:03:55 <Baughn> wvd: I find Haskell to be painfully low-level at times. ;)
03:04:02 <ivanm> wvd: so is reactive
03:04:17 <ivanm> they're just libraries on top of Haskell that do some stuff differently
03:04:20 <djahandarie> Cale, I haven't really gotten to any of the higher-level math stuff yet though, so who knows if my marks will get better
03:04:25 <int-e> Cale: you mean math is not just about applying formulas? Those definitions that mathematicians keep babbling about are actually good for something? ;-)
03:04:30 <ivanm> Cale: you know anything about FRP?
03:04:32 <Cale> int-e: hehe
03:04:33 <djahandarie> Only done up to Calc II at this stuff
03:04:37 <wvd> But like every game I found or something related to 3D, used FRP.
03:04:39 <Cale> ivanm: I know the basic idea.
03:04:52 <ivanm> Cale: care to explain it to wvd then?
03:04:55 <Cale> ivanm: I tried writing some demos with Reactive, but I hit the performance bugs really hard.
03:05:19 <scree> someone should write a big message somewhere saying, "Reactive doesn't work yet"
03:05:47 <djahandarie> Well if there are enough people trying to use it, then it'll get fixed :P
03:06:20 <scree> djahandarie: I don't know that that follows
03:06:38 <scree> djahandarie: do you mean, they will fix it, or, the pressure will force it to get fixed?
03:06:39 <wvd> Well.
03:06:40 <djahandarie> Well, "more likely to be" fixed
03:06:55 <wvd> It looks like there has been a lot of research on FRP
03:07:01 <djahandarie> That's just what I've observed elsewhere
03:07:15 <djahandarie> The actual workings of it are black-box :P
03:07:27 <scree> the point is it's broken because how to fix it is an open research problem, not because no-one can be bothered
03:07:39 <Cale> wvd: The basic idea behind functional reactive programming is related to the idea behind model/view/controller. A program has some inputs and some outputs (possibly with some feedback cycles out there), and the part in-between, the model, is a specification of how outputs should correspond to inputs.
03:07:53 <scree> we don't even know if fixing it is realistic
03:08:09 <djahandarie> scree, right, but more people would be interested in solving it if more people are interested in using it... including some of the people who are interested in using it.
03:08:53 <scree> djahandarie: I agree, but ATM most users get the impression it should work out of the box, and then get awfully surprised when they hit one of the 101 known bugs
03:09:28 <djahandarie> I'm just against putting a big banner discuraging people from using it (or anything)
03:09:48 <Cale> wvd: With traditional FRP, we have a couple basic types of "values over time" that need to be dealt with: "Behaviours" are things which always have a value at every point in time (whenever you care to look at it). Things like the position of the mouse, the current time, the current state of the display, and so on.
03:10:10 <scree> djahandarie: I was more thinking of "please play with this, it's cool, but don't expect it to work properly"
03:10:42 <Cale> wvd: Along with that, we have "Events" which are things that have values at various points in time -- the sequence of keystrokes to a program, the sequence of mouse clicks, and so on.
03:10:55 <djahandarie> scree, I think it'd be better if it just said "Known performance issues, see [link]." That way people can decide if it works for them or not
03:11:24 <wvd> Cale, ah, that makes sense when it comes down to a game.
03:11:32 <Cale> wvd: And the idea is that perhaps we can specify programs as functions from a certain set of input behaviours and events, to a certain set of output behaviours and events.
03:11:52 <scree> djahandarie: to me, "performance issue" could mean, it's a bit slow
03:11:58 <scree> djahandarie: not, it has massive time leaks
03:12:00 <Cale> (with lots of help from various useful functions for constructing new behaviours and events from old ones)
03:12:11 <wvd> What about perfomance of FRP vs FP?
03:12:17 <djahandarie> Maybe a qualifer would help then? "Big performance issues" :P
03:12:25 <Cale> FRP is a technique inside of functional programming :)
03:12:36 <Cale> There's actually not just one way of doing FRP either
03:13:12 <Cale> Some methods for doing FRP, like Yampa, seem to have had fairly good luck getting off the ground with respect to performance.
03:13:21 * hackagebot monoid-owns 2010.5.29 - a practical monoid implementation  http://hackage.haskell.org/package/monoid-owns-2010.5.29 (JinjingWang)
03:13:23 * hackagebot mps 2010.5.29 - simply oo  http://hackage.haskell.org/package/mps-2010.5.29 (JinjingWang)
03:13:45 <ivanm> you're saying that the current implementation of monoids isn't _practical_?
03:13:54 <scree> djahandarie: last I checked, you can also get it to hang when it shouldn't
03:13:56 <ivanm> omg, we have something in the libraries that can't be used?
03:13:57 <Cale> ivanm: monoids?
03:14:10 <scree> djahandarie: so, quite a big performace issue there :P
03:14:12 <ivanm> Cale: see what hackagebot just said
03:14:17 <Cale> oh, heh
03:14:33 <djahandarie> He versions his packages by date?
03:14:34 <Cale> JinjingWang makes strange packages
03:14:42 <ivanm> yes, to both djahandarie and Cale
03:14:46 <Cale> *really* strange packages :)
03:14:53 <ivanm> "A more practical implementation of the monoid class"
03:15:12 <ivanm> looks the same to me
03:15:16 <ivanm> except that + = mappend
03:15:31 <ivanm> and he's fixed Int, etc. as being Sum monoids
03:15:45 <Cale> Weird.
03:16:28 <ivanm> http://github.com/nfjinjing/monoid-owns/blob/master/src/Data/Monoid/Owns.hs
03:16:31 <kmc> this is worth it to write + instead of ++?
03:16:36 <ManateeLazyCat> aavogt: Have you know where i can find *much* HList example? I have read Oleg's paper, but less help with practical code.
03:16:40 <ivanm> @src mconcat
03:16:41 <lambdabot> Source not found. Are you on drugs?
03:16:52 <djahandarie> lambdabot is pretty rude
03:17:05 <Cale> http://hackage.haskell.org/packages/archive/mps/2010.2.25/doc/html/MPS-Light.html
03:17:18 <ivanm> he hasn't even done what a lot of people wish and use foldl' for sum monoids
03:17:22 <ivanm> *for mappend in
03:18:42 <Cale> (-) :: (a -> b) -> a -> b
03:18:43 <Cale> (<->) :: Num a => a -> a -> a
03:18:48 <Cale> hehe
03:19:20 <ManateeLazyCat> Where i can find HList example?
03:19:36 <Cale> ManateeLazyCat: People actually use HList?
03:19:44 <djahandarie> lol
03:19:48 <ivanm> Cale: despite my warnings, yes
03:19:56 <scree> someone was telling me they're building a programming language where monoids are the building block of all paralellization
03:19:57 <ivanm> aavogt is the one who suggested it to ManateeLazyCat...
03:19:57 <ManateeLazyCat> Cale: I have some polymorphism function need to handle.
03:20:09 <ManateeLazyCat> Cale: Except HList, i can't found other clean solution.
03:20:14 <ivanm> scree: hmmm... implicit parMap using mconcat or something?
03:20:34 <Cale> scree: Well, that's sort of true regardless of language :)
03:20:53 <ManateeLazyCat> Cale: I have read Oleg paper, and HList is i need, but i want some example to study it deeply...
03:21:07 <Cale> Monoids are directly or indirectly responsible for almost all efficient algorithms.
03:21:18 <akosch> i'm not quite sure how to indent the where keyword
03:21:24 <ManateeLazyCat> Cale: My current code can work, but i have *huge* duplicate instance code.
03:21:25 <akosch> for example i have this code: http://pastebin.com/Tb4A0FBs
03:21:35 <scree> ivanm: as in, a fold over a monoid can be done in any order
03:21:38 <akosch> how would you indent where in line 8 and 13
03:21:40 <Taejo> Cale: surely you mean efficient parallel algorithms?
03:21:44 <Cale> akosch: Normally I indent it less than that.
03:21:47 <scree> ivanm: that may or may not be what you said
03:21:56 <Cale> Taejo: Even efficient sequential algorithms :)
03:22:09 <ivanm> scree: kinda, yeah
03:22:13 <akosch> Cale: so minus a few spaces?
03:22:23 <ivanm> I meant that it then can be parallelised automagically
03:22:36 <Cale> akosch: Yeah, I indent 'where' relative to the function definition itself
03:22:49 <Taejo> Cale: could you give some examples?
03:22:51 <scree> so, for any container type, you just supply an instance for "parallel monoidal fold", and you're away
03:23:05 <Cale> akosch: It's actually hanging directly off of the function declaration, and isn't part of the expression to the right of the =
03:23:13 <Cale> Taejo: Sure. Binary search trees. :)
03:23:32 <ManateeLazyCat> Cale: JinJingWang's version is funny, with date..... :)
03:23:44 <exDM69> http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/  <<--- has this been discussed here?
03:23:46 <akosch> Cale: seems reasonable, thx...
03:24:11 <djahandarie> exDM69, I don't think so...
03:24:50 <Cale> Taejo: Most uses of trees are monoidal -- you have a bunch of elements, and you build a tree of summaries of those elements, where each node has some monoid operation applied to the summaries of its subtrees
03:25:10 <exDM69> I didn't know Intel had any interests working with Haskel
03:25:21 <Cale> Taejo: Associativity lets you balance the tree, identities let you deal with empty subtrees
03:26:08 <djahandarie> exDM69, they probably don't have much. I wouldn't be surprised if it was just a favorite of the guy working on that library and he got an okay to make a Haskell version of it
03:26:37 <Cale> Taejo: For example, the 'minimum' monoid for a search tree.
03:26:54 <exDM69> djahandarie: getting ok'd to publish it in intel.com is a step to the right direction anyways
03:27:08 <djahandarie> Yeah, definitely a good sign
03:27:27 <ivanm> OK, I just got something that gmail thought was spam that was inviting me to submit a paper for some conference in kuala lumpur
03:27:29 <Heffalump> djahandarie: I believe that's the case, yes
03:27:37 <ivanm> thing is, it wasn't may email address in the To field...
03:28:01 <Cale> Taejo: Another example I like is actually used in hardware implementations of addition. :)
03:28:53 <ManateeLazyCat> ivanm: You don't like HList?
03:29:06 <Cale> Rather than chaining carries mindlessly all the way to the end of an addition, resulting in an O(n) delay, you can classify what the various combinations of bits of the summands will do to a carry
03:29:22 <ivanm> ManateeLazyCat: no
03:29:28 <ivanm> one of the great things about Haskell is its strong typing
03:29:34 <ivanm> HList deliberately removes that
03:30:04 <mauke> ivanm: ?!
03:30:04 <Cale> There are 3 possibilities: (0, 0) will absorb a carry that comes in,  (1, 0) and (0, 1) will cause a carry to be propagated, and (1, 1) will emit a carry regardless
03:30:11 <ivanm> mauke: doesn't it?
03:30:14 <ManateeLazyCat> ivanm: I think not.
03:30:18 <ivanm> you have a list full of unknown values
03:30:19 <mauke> ivanm: how?
03:30:24 <mauke> it's nested tuples
03:30:42 <ManateeLazyCat> ivanm: I have read Oleg paper, HList is nested tuples.
03:31:04 <ManateeLazyCat> ivanm: It's don't like [Dynamic] something.
03:31:25 <Cale> There's a monoid operation on these 3 classes for combining the effects on carries, with propagation as the identity
03:31:28 <ivanm> gah, I can't even find where the actual list type is defined...
03:31:33 <mauke> next you'll be telling us tuples are evil
03:31:41 <mauke> because (a, b) could be ANYTHING!
03:31:55 <Cale> and you can use that monoid operation to build a circuit with logarithmic delay (and linear cost)
03:32:00 <ivanm> OK, found it
03:32:10 <Cale> Maybe that does count as parallel somewhat.
03:32:13 <ivanm> in that case, I misunderstood what HList was; I thought it was a [forall a . a]
03:32:42 <ManateeLazyCat> mauke: Do you know where i can found HList example or practical manual, i'm studying it....
03:32:45 <ivanm> so, what do HList types look like then?
03:32:59 <ivanm> huge ugly monstrosities?
03:32:59 <mauke> ManateeLazyCat: no, sorry
03:33:05 <mauke> <ivanm> Cale: despite my warnings, yes
03:33:13 <mauke> why are you warning people if you have no idea how it works?
03:33:34 <ivanm> mauke: because I had mixed up HList at some point with something else and had associated with that ever since
03:33:53 * ivanm still thinks it looks ugly though
03:34:30 <ManateeLazyCat> mauke: Ok, thanks anyway... I think HList is perfect way to handle polytechnic functions, Oleg even use Hlist build OOHaskell.
03:34:39 <ivanm> and I question the need for such a convoluted thing
03:34:44 <Cale> ManateeLazyCat: You might want to check out Wolfgang Jeltsch's new library called "records", if you're interested in this stuff. I'm afraid there's not much more in the way of examples though.
03:35:03 <ManateeLazyCat> Cale: Thanks, i will look it.
03:35:06 <ivanm> anyway, whilst people are asking for tutorials on libraries, anyone know of a good tutorial for TH?
03:35:20 <Cale> ManateeLazyCat: What are you trying to do?
03:35:47 <jeeez> >val = 600851475143
03:35:47 <jeeez> >limi = floor.sqrt $ val
03:35:47 <jeeez> >v::=foldl (\acc x -> if val `mod` x==0 then x else acc) 2 [2..limi]
03:36:14 <jeeez> i thought it'ld spew out the error right here :\ works only on one-line code?
03:36:48 <Cale> jeeez: That's true, but also you need a space after > in order for lamdabot to notice you
03:37:07 <jlouis> jeeez: you can probably pack it up in a let block
03:37:16 <Cale> The evaluator only responds to messages beginning with "> "
03:37:30 <Cale> (and it wants expressions)
03:37:40 * ManateeLazyCat pasted "polymorphism functions in Keymap." at http://paste2.org/get/856258
03:37:41 <ManateeLazyCat> Cale: Above
03:37:44 <jeeez> okay, let me try again
03:37:53 <Cale> > let val = 600851475143; limi = floor.sqrt $ val in foldl (\acc x -> if val `mod` x==0 then x else acc) 2 [2..limi]
03:37:55 <lambdabot>   486847
03:38:01 <Cale> ^^ there you go
03:38:06 <ManateeLazyCat> Cale: http://paste2.org/get/856258 is all i want, i want mix many polymorphism function in Keymap.
03:38:32 <ManateeLazyCat> Cale: For current solution, it's works, but i need write many *duplicate* code in "instance ActionInputArgs ... "
03:39:03 <Cale> ManateeLazyCat: What do all those things have in common that makes you want to use them together?
03:39:09 <ManateeLazyCat> Cale: And aavogt told me i can use HList define Environment, then i can save those duplicate instance code.
03:39:14 <voker57> can I apply {-# LANGUAGE only to part of code?
03:39:27 <ManateeLazyCat> Cale: Gtk+ action
03:39:33 <ivanm> voker57: only if you split that part of the code up into a separate module
03:39:50 <jeeez> Cale: why does it work for you, but said something about typing problems with val, limi when i had them as separate statements?
03:39:55 <ManateeLazyCat> Cale: I want build a extensable system.
03:40:14 <Cale> jeeez: Where did you put these definitions?
03:40:36 <jeeez> i have then in a hs file, and did :l file.hs
03:40:37 <ManateeLazyCat> Cale: And don't care "input/output argument" of function that build by Application programmer.
03:40:56 <jeeez> Cale: [and the :: part is by mistake, not a part of the original code, so you can ignore that]
03:40:56 <ManateeLazyCat> Cale: Simple, i want mix many polymorphism functions in one Map.
03:42:43 <Cale> ManateeLazyCat: How can you just not care about what the inputs and outputs to the function are? After all, in order to call the function, your program will have to know which arguments it has.
03:43:10 <Cale> and in order to do anything with the result, your program will have to know the result type
03:43:37 <Cale> So obviously, the types of function which you can put into your Keymap can't *really* be arbitrary
03:43:56 <ManateeLazyCat> Cale: Please see class ActionInputArgs and ActionOutputArg at http://paste2.org/get/856258
03:44:12 <jeeez> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25788#a25788 that's what i get
03:44:16 <Cale> jeeez: Ah, you're being bitten by the monomorphism restriction.
03:44:19 <ManateeLazyCat> Cale: I think you don't catch my point.
03:44:40 <Cale> jeeez: and/or the fact that val is being used as a Floating point number, since you apply sqrt to it
03:44:49 <kmc> the /dreaded/ monomorphism restriction
03:44:52 <Cale> jeeez: and then later as an integer-like number, when you apply mod
03:44:53 <ManateeLazyCat> Cale: Any function can as Keymap element, that "input argument" instance ActionInputArgs, "output argument" instance ActinOutputArgs.
03:45:09 <Cale> jeeez: An easy solution is just to do a conversion in one place or the other.
03:45:18 <ivanm> kmc: let's make it the "Malicicious monomorphism restriction" just so we have MMMR ;-)
03:45:23 <ivanm> M^3 R
03:45:24 <Cale> I recommend  limi = floor . sqrt . fromInteger $ val
03:45:41 <ManateeLazyCat> Cale: Now everything works fine, except i need write new instance code for new *type* even it's just different order.
03:46:11 <jeeez> Cale: thanks. got it!
03:46:27 <Cale> jeeez: With the monomorphism restriction off, 'val' will get a polymorphic type, and it'd be okay to use it as multiple types of numbers like that
03:46:51 <djahandarie> Does lambdabot have -fno-monomorphism-restriction ?
03:46:53 <ManateeLazyCat> Cale: I think my need has outside of standard of Haskell98.
03:46:56 <Cale> djahandarie: yes
03:47:19 <Cale> ManateeLazyCat: I see.
03:47:45 <ManateeLazyCat> Cale: So you have any better idea that don't use TH or HList?
03:48:02 <ManateeLazyCat> Cale: I can use TH generate instance code, but ugly.
03:48:24 <Cale> ManateeLazyCat: Well, there's a way to do it which sort of mimics HList without pulling in the whole complex HList thing :)
03:48:25 <ManateeLazyCat> Cale: I think HList will fix my polymorphism problem, still in studying....
03:48:56 <ManateeLazyCat> Cale: [Dynamic] ?
03:48:57 <Cale> ManateeLazyCat: Write an instance of ActionInputArgs just for the base types, and then write an instance for pairs
03:49:20 <Cale> which recursively uses the instances for the base types.
03:49:43 <Cale> (well, sort of "recursively" anyway)
03:50:11 <Cale> Can you write an instance (ActionInputArgs a, ActionInputArgs b) => ActionInputArgs (a,b) ?
03:50:46 <mreh> MMR = measles mumps and rubella
03:51:53 <kmc> together at last
03:52:05 <mreh> has anyone here had trouble with lambdacube?
03:52:22 <mreh> my openGL definitely works, lambdacube does not
03:52:40 <ManateeLazyCat> Cale: "ActionInputArgs (a,b)" ? Can you explain why need that?
03:53:24 <Cale> ManateeLazyCat: Well, once you can do it for pairs, you can do it for any sequence of arguments of appropriate types
03:53:31 <Cale> ManateeLazyCat: Just by nesting pairs.
03:53:49 <ManateeLazyCat> Cale: ActionInputArgs is design for feed *subset value* with old Environment, then ActionOutputArgs return new "subset value" to update Environment.
03:53:51 <Cale> ManateeLazyCat: This is essentially the sort of relationship which HList makes lots of use of.
03:56:11 <ManateeLazyCat> Cale: I haven't catch your point, i need think a moment....
03:56:18 <Cale> ManateeLazyCat: Is there a good reason for the continuation passing style in the type of execute?
03:56:36 <Cale> Oh, perhaps I see why you need it.
03:56:42 <Cale> err...
03:57:17 <ManateeLazyCat> (==>) :: forall a b . (ActionInputArgs a, ActionOutputArgs b) => Text -> (a -> IO b) -> (Text, Action)
03:57:34 <Cale> Why not just:  execute :: (ActionInputArgs a) => Environment -> IO a  ?
03:58:13 <ManateeLazyCat> type Keymap = Map Text Action
03:58:18 <Cale> Your current instances of ActionInputArgs don't do anything sneaky with the result of 'f'
03:58:19 <ManateeLazyCat> data Action = forall a b . (ActionInputArgs a, ActionOutputArgs b) => Action {actionFun :: a -> IO b}
03:58:19 <ManateeLazyCat>  
03:59:03 <Cale> and if you want a function with the type that your execute currently has, you could always write one
03:59:09 <Cale> in terms of the simpler execute
03:59:25 <Cale> I suppose it doesn't really matter...
03:59:46 <Cale> It's just a bit odd to implicitly be using the Cont monad here.
04:01:01 <jlouis> Cale: do you remember if roconnor got improvements from your Prio. Search. Q. drop-in?
04:01:04 <portnov> :t iterate . (=<<)
04:01:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> [m b]
04:01:12 <Cale> jlouis: It was slower
04:01:28 <portnov> :t iterateM
04:01:29 <lambdabot> Not in scope: `iterateM'
04:01:39 <ManateeLazyCat> Cale: Even i write "execute :: (ActionInputArgs a) => Environment -> IO a", problem still there, i still need write duplicate instance code.
04:02:03 <jlouis> Cale: did it use less memory though?
04:02:37 <ManateeLazyCat> Cale: And i think i can't write "execute :: (ActionInputArgs a) => Environment -> IO a  ?
04:02:38 <Cale> ManateeLazyCat: Okay, but what if you have:  instance (AIA a, AIA b) => AIA (a,b) where execute env = liftM2 (,) (execute env) (execute env)
04:02:57 <ManateeLazyCat> Cale: Because it return *a* will mismatch with (a -> IO b)
04:03:26 <Cale> ManateeLazyCat: Look at your current instances. Just drop the f parameter and replace f with return in the body
04:03:35 <Cale> ManateeLazyCat: and it'll do the same thing :)
04:04:17 <Cale> and if you want the "CPS" version back:  execute' env f = execute env >>= f
04:04:19 <ManateeLazyCat> Cale: Can we stop a while, i'm so hungry, i need some food, can we talk continue after i eat something?
04:04:28 <Cale> sure, I should eat something as well :)
04:04:38 <ManateeLazyCat> Cale: Ok, see you later. :)
04:05:37 <portnov> > sequence (take 5 ((iterate . (=<<)) (\x -> putStr "foo") (putStr " ")))
04:05:39 <lambdabot>   <IO [()]>
04:07:54 <klaas111> hi
04:08:13 <klaas111> I have a question regarding 'while loops' as show in Real World Haskell
04:08:15 <klaas111> like so:
04:08:18 <klaas111> http://pastebin.com/UjHKHJrq
04:08:41 <klaas111> this is really a recursive function, w/ possibly very long input
04:08:48 <Cale> klaas111: sure
04:08:55 <klaas111> wouldn't this lead to a stack overflow?
04:09:25 <Cale> There is a stack in the evaluator, but it isn't used for what it's used for in evaluating a strict language.
04:09:47 <klaas111> ok
04:10:08 <klaas111> so my takeaway is "magic solves this" in Haskell
04:10:28 <Cale> Instead, the stack represents all the pattern matches which are sitting and waiting for their scrutinees to be sufficiently evaluated to be able to match one of the patterns
04:10:45 <Cale> Well, you have to remember that lazy evaluation is outermost first.
04:11:06 <Cale> I suppose the fact that we have the IO monad sitting around here obfuscates what's going on a bit :)
04:11:23 <Cale> But remember that IO execution is separate from evaluation of expressions to values
04:12:05 <Cale> In practical terms the evaluator will evaluate the IO action just far enough that the executor can decide what to do next.
04:12:52 <klaas111> ok
04:13:19 <djahandarie> klaas111, that is a classic example (if you ignore the IO monad) of tail recursion, which can be changed into a loop
04:13:44 <Cale> tail recursion is sort of irrelevant to the Haskell evaluator though
04:13:58 <Cale> Because things are outermost-first anyway
04:14:14 <djahandarie> That doesn't get rolled into a loop?
04:15:14 <Cale> djahandarie: You mean fusing the construction of the list away entirely? It's conceivable, I suppose.
04:16:00 <Cale> I'd be a bit surprised.
04:16:05 <klaas111> different question: the dot should be pronounced as "after"?
04:16:12 <klaas111> f . g
04:16:15 <Cale> klaas111: It could be :)
04:16:15 <maltem> Hehe, "the evaluator", "the executor" - reminds me of how we were talking, in the algebra course, about a superhero comic featuring (German names) the Kommutator, Zentralisator and Normalisator
04:16:26 <Cale> klaas111: I've also heard it read "f following g"
04:16:27 <kmc> haha maltem
04:16:35 <klaas111> yeah makes sence
04:16:41 <klaas111> f . g x
04:16:44 <Cale> klaas111: But I usually just say "composed with"
04:17:03 * mux uses the mathematical way of saying it in french, "f rond g" :-P (rond is more or less circle)
04:17:14 <kmc> this "while loop" example is actually really subtle
04:17:42 <klaas111> f (g x)  is the same as f . g x right?
04:17:44 * djahandarie has become interested
04:17:46 <mauke> f ‚àò g is clearly pronounced fringy
04:17:50 <kmc> @src (.)
04:17:50 <lambdabot> (f . g) x = f (g x)
04:17:50 <lambdabot> NB: In lambdabot,  (.) = fmap
04:18:01 <mauke> klaas111: no
04:18:03 <Cale> klaas111: It's the same as (f . g) x
04:18:05 <mux> klaas111: no, but nearly; f (g x) == f . g $ x
04:18:09 <Cale> klaas111: Or f . g $ x
04:18:16 <Cale> f . g x means f . (g x)
04:18:29 <kmc> klaas111, in a strict language with impure eval, this code would be tail recursive
04:18:37 <kmc> klaas111, which means no stack overflow
04:18:47 <kmc> assuming your language guarantees tail-call optimization, which most functional languages do
04:18:49 <kmc> for precisely this reason
04:19:02 <kmc> in Haskell, with lazy eval and first-class actions, the story is a bit more complicated
04:19:27 <kmc> because the second equation desugars to
04:19:34 <exDM69> is there a way to get a backtrace in GHCi from a piece of code that uses error to raise an exception
04:19:38 <kmc> runall (firstelem:remainingelems) = firstelem >> runall remainingelems
04:19:51 <kmc> which is not a tail call
04:20:03 <kmc> because the recursive call to runall is buried within one of the args to (>>)
04:20:10 <Cale> But it's irrelevant that it's not a tail call, because we're not using strict evaluation anyway
04:20:13 <maltem> exDM69, usually no
04:20:16 <kmc> it is, however, productive
04:20:19 <Cale> right
04:20:23 <kmc> if you make certain assumptions about how (>>) is implemented for IO
04:20:42 <kmc> you can't actually see that it's productive, because IO is an abstract type and the implementation of (>>) is implementation-dependent
04:20:46 <klaas111> I'm asking questions for which I'm not (yet) able to understand the answers...
04:20:50 <kmc> it's probably guaranteed somewhere
04:21:04 <klaas111> but thanks anyway...
04:21:17 <kmc> klaas111, i can explain more if you like
04:21:21 <Cale> kmc: Well, it's sort of guaranteed by the fact that if it wasn't so, then almost every Haskell program ever would immediately break ;)
04:21:24 <kmc> but as i said, it's pretty subtle
04:21:48 <klaas111> kmc: not yet, I need to grok some more trivial stuff firs
04:21:49 <klaas111> t
04:21:56 <mux> klaas111: I'm still glad you asked, because Cale and kmc explanations are very interesting :-)
04:22:00 <djahandarie> kmc, can you keep on going actually, I'm not sure myself
04:22:04 <klaas111> it's been about 7 years ago I last touched Haskell
04:22:25 <kmc> djahandarie, well, that's about it
04:22:29 <klaas111> I'm looking for some nice excuses to play with it again
04:22:29 <kmc> do you know what i mean by "productive"?
04:22:36 <djahandarie> kmc, not really, that's where I got lost
04:23:02 <kmc> ok i might not have this definition right either
04:23:03 <kmc> but
04:23:06 <kmc> > let x = () : x in x
04:23:07 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:23:19 <kmc> not a tail call
04:23:20 <ManateeLazyCat> Cale: You're right, "execute     :: Environment -> IO a" is simpler, then i can change runAction to : "execute env >>= fun >>= update env  "
04:23:21 <Cale> klaas111: Generally, thinking about the manner in which things get evaluated and executed can get kind of subtle. Also, it's made more hazy by the fact that the standard doesn't actually say anything about the order in which evaluation occurs, only specifies what the results should be and says that if there's an order of evaluation under which the program terminates, it had better terminate :)
04:23:24 <kmc> because the recursion is buried inside (:)
04:24:04 <klaas111>  Generally, thinking about the manner in which things get evaluated and executed can get kind of subtle. Also, it's made more hazy by the fact that the standard doesn't actually say anything about the order in which evaluation occurs, only specifies what the results should be and says
04:24:16 <Cale>  that if there's an order of evaluation under which the program terminates, it had better terminate :)
04:24:18 <klaas111> sry trigger happy copy/paste
04:24:20 <kmc> but we say it's 'productive' because, when you force 'x' to whnf, it produces a value without doing lots of work all at once
04:24:31 <Cale> (Oh, thought perhaps I got cut off)
04:24:53 <kmc> > let x = () : x in case x of (_:_) -> 3
04:24:54 <lambdabot>   3
04:25:10 <kmc> djahandarie, so we can pattern match, even though it's an infinite list
04:25:29 <klaas111> any tips on how to get started with haskell again
04:25:35 <klaas111> "real world projects"?
04:25:47 <kmc> and furthermore if we match against (y:ys) and then go on to do something with ys only, the rts can garbage collect y, and the cons cell that bound them together
04:25:47 <klaas111> I'm doing mostly web stuff professionally
04:26:02 <klaas111> I'm not sure that's a perfect match problem/solution
04:26:04 <kmc> in effect the stack is inside out... the stack is a stack of stuff we've demanded, not stuff we're computing
04:26:15 <djahandarie> kmc, ah, okay
04:26:15 <Cale> ManateeLazyCat: Am I wrong, or will that instance of AIA for pairs actually solve your problem?
04:26:17 <kmc> klaas111, there's a lot of interesting work being done in Haskell web frameworks
04:26:43 <kmc> djahandarie, and so the idea, intuitively at least, is that IO is an algebraic data type
04:26:57 <kmc> and that the executor has to evaluate that data to whnf before knowing what to do
04:27:17 <kmc> but even if we hand it an IO action with an infinite depth of (>>)
04:27:27 <kmc> it can peel off those components one at a time and throw them out
04:27:30 <kmc> and so there's no overflow
04:27:30 <Cale> I like to think of IO as internally looking like a GADT with bind as an explicit data constructor
04:27:36 <kmc> yes
04:27:37 <Cale> data IO a where
04:27:41 <ManateeLazyCat> Cale: If i write "instance (AIA a, AIA b) => AIA (a,b) where", how to handle order? Function argument maybe (a, b) or (b, a), or more complicated (a,b,c...n)
04:27:42 <Cale>   ReturnIO :: a -> IO a
04:27:45 <kmc> though that actual GADT would not obey the monad laws
04:27:51 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
04:28:00 <Cale>   GetChar :: IO Char
04:28:01 <ski> maltem : i'd like to see that comic !
04:28:05 <Cale>   ... etc. etc. ...
04:28:17 <Cale> ManateeLazyCat: Does the order matter?
04:28:50 <Philippa> *sigh* someone mentioned my name overnight and it's scrolled away. Oh well
04:28:51 <Cale> ManateeLazyCat: If you write the parts in a different order, then the IO actions for extracting those values from the environment will run in a different order, but that's all.
04:29:01 <kmc> Philippa, there are logs
04:29:17 <Cale> <ski> @where ops
04:29:18 <Cale> <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
04:29:29 <Cale> ^^ that's the only mention I see
04:29:34 <Philippa> Cale: thanks, no big deal if that's all it was then
04:30:00 <ManateeLazyCat> Cale: I try....
04:30:22 <kmc> what Cale said reminded me of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25789#a25789
04:30:27 <kmc> i'm not sure this is good for anything
04:31:03 <kmc> but it's possible to collapse ((Monad m) => m a) into a monomorphic type and back
04:31:04 <Cale> It's very close to a bunch of actually useful things :)
04:31:32 <kmc> it's interesting that Map ends up being existential
04:31:34 <Cale> As for the point about IO satisfying the monad laws like that, it just depends on how you interpret the monad laws.
04:31:54 <maltem> ski, I'll tell them there's a target audience waiting
04:32:03 <kmc> yeah... the way i see it, this T obeys the monad laws, only because it's abstract
04:33:22 <kmc> if i had ´module OmniMonad(T(..), runT) whereª then i'd consider it not a proper monad anymore
04:33:31 <Reisen> djahandarie, spy!
04:33:31 <kmc> it's a bit weird that matters
04:33:42 <djahandarie> Heh
04:35:29 <Cale> It's the difference between syntactic and semantic equality, I think.
04:36:01 <Cale> kmc: Have you looked at MonadPrompt?
04:36:25 <ski> kmc : it is good that you don't export `Map' bec.. yes, exactly :)
04:37:19 <ManateeLazyCat> Cale: Yes "instance (ActionInputArgs a, ActionInputArgs b) => ActionInputArgs (a, b) where" fix (a,b) problem, but how about (a,b,c) (a,b,c,d) (a,b,c,d,e) .... ?
04:37:30 <ManateeLazyCat> Cale: I need write those ?
04:37:32 <Cale> ManateeLazyCat: Well, (a,(b,c)) works
04:37:52 <Cale> ManateeLazyCat: If you don't like the syntax, you can define a new type of pairs with an infix data constructor
04:37:55 <ManateeLazyCat> Cale: Nested tuple, that's HList do.... :)
04:38:07 <kmc> Cale, i need to take another look
04:38:09 <kmc> thanks for the suggestion
04:39:13 <ManateeLazyCat> Cale: I just read Oleg paper, haven't see the implementation of HList, looks i'm re-implementation HList.. :)
04:39:33 <ski> kmc : btw, note that if we were just after getting a `Functor' instance, we could do `data T :: * -> * where Point :: a -> T a; Join :: T (T a) -> T a' and then `data U b = forall a. MapLift (a -> b) (T a)' and then we can safely do `instance Functor U' and still export constructors :)
04:39:43 <Cale> ManateeLazyCat: Yeah, though only a tiny fragment which is quite manageable :)
04:40:00 <ski> (i wonder if a similar trick is possible with `Monad' ..)
04:41:25 <ManateeLazyCat> Cale: I'm curious, HList is implementation like my code: use nest tuple base on typeclass?
04:41:36 <Cale> ManateeLazyCat: Essentially
04:41:49 <Cale> ManateeLazyCat: and lots of typeclasses for each of the various operations on HLists
04:42:16 <Cale> (and they tend to be multiparameter typeclasses with functional dependencies)
04:43:18 <maltem> Anyone who ever investigated the backslash-docbook-pdftex problem when building the ghc documentation?
04:43:54 <ManateeLazyCat> Cale: I think HList build some sugar that make nested-tuple looks like list, and not (a, (b, (c, ... n) :)
04:44:25 <Cale> ManateeLazyCat: Well, yeah, it uses a type which is the same as pairs, but uses an infix data constructor instead
04:44:37 <Cale> if I recall correctly
04:45:17 <Cale> Oh, it defines:
04:45:21 <Cale> data HNil = HNil
04:45:30 <Cale> data HCons e l = HCons e l
04:45:43 <ManateeLazyCat> Cale: Maybe the best way is use HList? Looks i'm re-build everything that HList have finish... :)
04:45:43 <Cale> type e :*: l = HCons e l
04:45:45 <Cale> and
04:45:48 <ski> kmc : hm, i suspect in your case, you could just as well say `data T a = Point a' (possibly modulo `seq'-issues, as usual)
04:45:55 <Cale> e .*. l = HCons e l
04:46:12 <Cale> ManateeLazyCat: I wouldn't. HList is needlessly complicated for this.
04:46:28 <Cale> ManateeLazyCat: We have lots of similar typeclasses around.
04:46:52 <Cale> ManateeLazyCat: The only thing you'd get from HList is the type definitions
04:47:05 <Cale> and you're probably better off just using the GHC extensions and writing:
04:47:29 <Cale> data (a :*: b) = a :*: b  deriving (Eq, Ord, Show, Read)
04:47:53 <Cale> and then writing an instance for that type (similar to the one for pairs)
04:48:55 <klaas111> how should I understand this: http://pastebin.com/SzKeEfA2
04:49:05 <klaas111> (from my xmonad config)
04:49:19 <klaas111> specifically: the braces after defaultconfig
04:49:27 <kmc> klaas111, that's the record-update syntax
04:49:28 <Cale> klaas111: That's record update syntax
04:49:30 <kmc> r { x = v }
04:49:44 <klaas111> ok makes sense
04:49:51 <kmc> means "a record like r, except with field x set to v"
04:49:52 <klaas111> that's what I thought/hoped
04:49:56 <kmc> :)
04:50:42 <klaas111> I have to say... the people on this channel are extremely friendly
04:50:45 <klaas111> and quick to answer !
04:51:06 <klaas111> I hope Haskell doesn't get to popular ....
04:51:07 <MacMagnus> can someone help me with this? http://pastebin.com/grKT8yxm (if cont compile...)
04:51:21 <ManateeLazyCat> klaas111: You can use record just set the value you want set in defaultConfig.
04:51:31 <Cale> Yeah, we try to be helpful, but there's always the fear that we're making the language too popular.
04:51:43 <Cale> (and so we'll never get to change the things we want to change)
04:52:27 <klaas111> well... thanks again. gotta go now and do something useful other than hacking around w/ new tools
04:52:40 <klaas111> will probably be back with more questions
04:52:52 <ManateeLazyCat> Cale: Haskell is become popular, many many advanced programmer interested "Functional Language" .... :)
04:53:16 <Cale> MacMagnus: n is a number
04:53:23 <Cale> MacMagnus: and so [n] is a list of numbers
04:53:37 <Cale> MacMagnus: but "Prime: " is a list of characters :)
04:53:44 <Cale> So you can't ++ them together
04:54:06 <MacMagnus> oh... yeah your right
04:54:15 <kmc> > "foo" ++ [3]
04:54:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
04:54:16 <lambdabot>    arising from the literal `3...
04:54:17 <kmc> > "foo" ++ show [3]
04:54:18 <lambdabot>   "foo[3]"
04:54:18 <Cale> oh, another thing
04:54:21 <Cale> `mod` not mod
04:54:36 <Cale> It thinks that n is a function as well, because you have n mod a
04:54:37 <MacMagnus> yeah :) forgot that.
04:54:54 <Cale> which means "apply the function n to the values mod and a"
04:55:35 <MacMagnus> thanks :D that part works now
04:55:44 <Cale> MacMagnus: Also, watch out, there are tabs in your file
04:56:01 <Cale> MacMagnus: It's best to configure your editor to automatically convert tabs to spaces
04:56:22 <Cale> Because things are layout sensitive, and it can be important that things line up exactly to a particular column
04:56:33 <MacMagnus> yeah i know, did a clean install and forgot about it :P but thanks for the remainder :)
04:58:18 <MacMagnus> but how do I print the number to the terminal?
04:59:18 <MacMagnus> n.toString() :P
04:59:22 <kmc> > show 3
04:59:23 <lambdabot>   "3"
04:59:29 <kmc> > show [1,2,5]
04:59:30 <lambdabot>   "[1,2,5]"
04:59:34 <kmc> etc.
04:59:39 <kmc> works on a wide variety of types
05:00:49 <MacMagnus> ah :D thanks a lot
05:01:31 <kmc> :)
05:02:00 <kmc> > fix show
05:02:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
05:12:53 <ManateeLazyCat> Cale: Have any function do this : "convert :: (a,(b,c)) -> (a, b, c)" ? Then i can do something like this: "execute env >>= action . convert >>= update env".
05:13:30 <ManateeLazyCat> (a,(b,(c,d))) -> (a,b,c,d)
05:13:49 <kmc> if you want it to work for any tuple shape, that's not going to happen
05:14:16 <ManateeLazyCat> kmc: Yes, i want it work for any tuple.
05:14:18 <RyanT5000> kmc: couldn't it be accomplished with some kind of typeclass, potentially?
05:14:35 <kmc> RyanT5000, yeah
05:14:40 <mauke> it doesn't look recursible
05:14:44 <Jafet> Why do you want a function for any tuple?
05:14:45 <kmc> but you're still writing the instances yourself
05:15:00 <Jafet> It's a dead-end job, unless you already have a mechanism to handle n-tuples
05:15:22 <kmc> it amounts to writing every special-case function but giving them all the same name
05:15:25 <ManateeLazyCat> Jafet: Infact, i (a,(b,c...n)) is enough, but it's make code hard to read...
05:16:29 <kmc> sounds like you're trying to convert between two different encodings of heterogenous lists
05:16:36 <kmc> one of which plays nicely with the type machinery, one of which doesn't
05:16:59 <ManateeLazyCat> kmc: If for (a,(b,c)), i don't need write many instance, i just instance for "a", "b", "c", i want a function will transform "(a,(b,(c...n))) -> (a,b,c, .... n)"
05:17:24 <djahandarie> Heterogenous? Does that have some specific definition in CS?
05:17:47 <djahandarie> Or do you just mean "composed of different things"
05:17:57 <kmc> that's the definition i mean
05:18:12 <ManateeLazyCat> kmc: Well, my local function use (a,b,c ... n) style, and instance work is (a,(b,(c ... n)))) style, i want build a bridge between those two style.
05:18:22 <kmc> right
05:18:30 <Jafet> Template Haskell!
05:18:31 <kmc> you can generate them with TH
05:18:32 <mux> I guess you could use HList, but I suspect that it would be best if you can avoid all of this
05:18:35 <kmc> @quote majesty
05:18:35 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
05:18:51 <kmc> HList is, very roughly, like the (a,(b,(c,... encoding you're already using
05:18:53 <djahandarie> lol
05:18:59 <ManateeLazyCat> Jafet: I don't like Template Haskell, if i can use "nested-tuple" fix my problem (like HList do).
05:19:04 <kmc> if you're not willing to change the rest of your code to match
05:19:08 <kmc> then using HList is no better
05:19:35 <ManateeLazyCat> kmc: Yes, looks i'm re-implementation everything that HList have finish.
05:19:55 <Jafet> I think this is one of those problems that TH lets you pack away in a dirty little corner
05:20:04 <ManateeLazyCat> Jafet: Indeed.
05:20:28 <ManateeLazyCat> Jafet: TH can't give me clear logic like natural Haskell style.
05:21:33 <ManateeLazyCat> Jafet: I'm very unlike that TH make me like AST robot... :)
05:21:42 <Jafet> But whatever
05:22:49 <ManateeLazyCat> kmc: What you mean "then using HList is no better"? I'm newbie to HList...
05:23:02 <kmc> ManateeLazyCat, I mean that HList is already like (a,(b,(c, ...
05:23:10 <kmc> you won't make this problem go away by using HList
05:23:17 <djahandarie> Would it be a decent idea to use a config file? Or go the haskell-config-file style where it just calls a single function with a number of parameters (i.e., xmonad, yi)
05:23:22 <kmc> you'll make this problem go away by converting the rest of your code to that style, rather than (a,b,c)
05:23:25 <kmc> djahandarie, for what?
05:23:36 <kmc> djahandarie, if you want xmonad/yi style config the "dyre" package provides it
05:23:53 <djahandarie> Oh wow, didn't know there was a package for that
05:24:22 <Jafet> There's the lazy Read way
05:24:31 <ManateeLazyCat> djahandarie: The principle of dyre is recompile config file and entry new binary enty.
05:24:36 <ManateeLazyCat> s/binary entry
05:24:52 <kmc> does TH really lack pattern splices?
05:24:57 <kmc> or am i doing something dumb
05:25:09 <Jafet> Currently
05:25:15 <Jafet> It's a known oversight it seems
05:25:24 <ManateeLazyCat> kmc: I think only way is change my code to (a,(b,c)) style, even i don't like it ....
05:25:41 <kmc> ManateeLazyCat, or use TH.
05:26:23 <ManateeLazyCat> kmc: Yes, i can use TH generate instance code, but if let me choose, i prefer to use (a,(b,c)) :)
05:26:38 <kmc> no i mean you can use TH to generate (a,(b,c)) -> (a,b,c)
05:26:47 <kmc> though for uniformity i'd use (a,(b,(c,())))
05:27:09 <ManateeLazyCat> kmc: Hmmm, maybe that's a good idea.
05:27:32 <ManateeLazyCat> kmc: Use TH do (a,(b,c)) -> (a,b,c) is acceptable
05:28:36 <ManateeLazyCat> djahandarie: dyre is perfect for re-compile config file, but if you want re-compile all project, dyre can't do that.
05:29:16 * ManateeLazyCat Infact, i build new myself re-compile module for my need, like dyre, but for all project....
05:31:10 <Jafet> (Who's the Church of the topic?)
05:31:32 <kmc> alonzo
05:31:35 <wli> Alonzo
05:32:42 <Jafet> Hm, a pretty long remembrance then
05:33:46 * ManateeLazyCat pasted "Core.hs" at http://paste2.org/get/856370
05:33:52 <ManateeLazyCat> djahandarie: Above is my re-compile module.
05:34:19 <ManateeLazyCat> djahandarie: For all project re-compile
05:35:13 <ManateeLazyCat> All project re-compile give your power that you can use your project (editor) write itself, and update itself don't need restart.
05:36:11 <ManateeLazyCat> Perhaps have other dynamic link solution, but http://paste2.org/get/856370 is best i can do
05:36:37 <ManateeLazyCat> Only disadvantage is you need long compile time if you project is too big.
05:36:55 <ManateeLazyCat> But this can fix with some delay-entry solution
05:37:34 <ManateeLazyCat> re-compile process running in background, only re-lauch new binary entry when new code re-compile successful.
05:54:29 <ManateeLazyCat> Cale: Thanks for your help! Nested-Tuple fix my problem perfect! :)
06:06:55 <Axman6> So i was looking at the source for Data.Rope, and noticed this:
06:06:56 <Axman6> null::Rope->Bool
06:06:57 <Axman6> null x=length x>0
06:07:25 <chrisdone> O_O
06:07:44 <Axman6> that is as wrong as i think it is right?
06:07:48 <chrisdone> good catch
06:08:11 * chrisdone looks at the source of the `length` function..
06:08:28 <Axman6> i'll email the author
06:14:32 <Silvah> length is O(1)...
06:14:50 * edwardk looks up. which Data.Rope?
06:15:11 <edwardk> oh the slow one
06:15:14 <edwardk> nm =)
06:15:22 <Axman6> heh
06:15:36 <Axman6> why's it slow?
06:16:02 <edwardk> cons, snoc, head, tail, etc are common operations you want to perform on string like representations and are all O(log n) in that version
06:16:17 <Axman6> ah
06:16:54 <edwardk> the fingertree of bytestrings version in the rope library has better asymptotics across the board.
06:17:37 * maltem is confused by the many fingertree/rope variants floating around
06:18:06 <maltem> (where many = 3, I think)
06:18:54 <kmc> hmm, the TH tuple un-nester is really short actually
06:19:01 <mux> am I confused or...? even if length is O(1), the definition of null here is incorrect; it should be null x = length x == 0
06:19:04 <kmc> of course TH code takes about 10 times as long to write as usual
06:19:24 <Silvah> @pl \x -> length x > 0
06:19:25 <lambdabot> (> 0) . length
06:20:11 <Silvah> mux: I don't think it's possible to make a rope of negative length, so it just looks strange, but is correct.
06:20:39 <maltem> Silvah, the point is > vs ==
06:20:48 <mux> Silvah: that would be true if it was using <=
06:20:49 <djahandarie> No, in that case it should be <=
06:20:53 <aavogt> kmc: it's specific for a given length of tuples though?
06:21:10 <Silvah> Ah, yep.
06:21:21 <Silvah> I didn't sleep well ;)
06:22:58 <kmc> aavogt, given the length, it generates a function
06:23:33 <kmc> so e.g. unNest 3 == [| \(x,(y,(z,()))) -> (x,y,z) |]
06:24:14 <kmc> initially i had the recursion in the wrong place and got something ungodly complicated
06:24:35 <chrisdone> c++ style errors?
06:24:47 <kmc> ?
06:29:11 <djahandarie> Weird, a library I made is impossible to import anywhere else because of  /home/darius/.cabal/lib/bot-0.1/ghc-6.12.1/HSbot-0.1.o: unknown symbol `__stginit_botzm0zi1_BotziProcess_'
06:29:23 <djahandarie> No errors in the cabal install
06:29:43 <dcoutts> djahandarie: you probably forgot to list the module in the .cabal file
06:29:54 <dcoutts> Cabal cannot currently check that you've correctly listed all the modules
06:30:04 <djahandarie> It is, Exposed-modules: Bot
06:30:19 <dcoutts> djahandarie: and what bout the Bot.Process module?
06:30:29 <djahandarie> Oh, snap
06:30:42 <int-e> you need an Other-modules line listing all the other modules
06:30:43 <dcoutts> djahandarie: list it in other-modules
06:30:44 <djahandarie> I only listed that under the Executable section
06:30:47 <mux> dcoutts: hi! have you reached a conclusion on that ghc-pkg problem / pkg-config problem I was having? may I be of some help?
06:31:11 <djahandarie> Thanks
06:31:16 <dcoutts> mux: oh about the include dirs that ghc-pkg checks for
06:31:20 <mux> yes
06:31:29 <dcoutts> mux: we talked about it in #ghc the other day
06:31:38 * dcoutts tries to recall if we filed a ticket
06:31:46 <mux> yeah, I saw the beginning of the discussion at least
06:33:06 <dcoutts> mux: I think we didn't file any ticket, but probably should so we don't forget
06:33:18 <dcoutts> mux: I think we decided ghc-pkg should perhaps just warn
06:33:19 <mux> I can take care of that at least, if you want
06:33:26 <mux> sounds reasonable to me
06:33:27 <dcoutts> mux: that'd be great, thanks
06:33:30 <mux> sure
06:33:44 <aavogt> kmc: where's the recursion... you just need foldr
06:35:14 <aavogt> like here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25791#a25791
06:36:52 <ski> @help unpf
06:36:52 <lambdabot> pointful <expr>. Make code pointier.
06:36:57 * mux is waiting for the verification e-mail to be able to add a new ticket
06:36:57 <ski> huh ?
06:37:01 <ManateeLazyCat> aavogt: I have use "nested-tuple" fix my problem, thanks for your help!
06:37:20 <aavogt> huh?
06:37:34 <ski> shouldn't that be `pf', then ?
06:37:39 <ManateeLazyCat> aavogt: instance (ActionInputArgs a, ActionInputArgs b) => ActionInputArgs (a, b) where execute env = liftM2 (,) (execute env) (execute env)
06:37:41 * hackagebot Data-Rope 0.2 - Ropes, an alternative to (Byte)Strings.  http://hackage.haskell.org/package/Data-Rope-0.2 (PierreEtienneMeunier)
06:37:54 <aavogt> I don't know why you want to write all those instances
06:38:08 <ski> also, wasn't there some command for turning "BotziProcess" into "Bot.Process" ?
06:38:22 <aavogt> preflex: zdec BotziProcess
06:38:22 <preflex>  Bot.Process
06:38:38 <ManateeLazyCat> aavogt: I have change my function argument to (a,(b,(c ... n))) style.
06:38:52 <ManateeLazyCat> aavogt: Then i don't need HList, overkill... :)
06:39:00 <aavogt> ManateeLazyCat: instead of having the class context explicitly list each field that is being used?
06:39:15 <kmc> aavogt, yeah that's what i have
06:39:20 <kmc> the recursion is in the fold
06:39:25 <mauke> preflex: zenc "Bot.Process"?
06:39:25 <preflex>  z22UBotziProcessz22Uz3fU
06:39:29 <ski> aavogt : ah, that was it :)
06:40:05 <aavogt> kmc: it's not too difficult... it's just a really ugly way to write haskell code in haskell
06:40:11 <ski> preflex: zdec __stginit_botzm0zi1_BotziProcess_
06:40:11 <preflex>  __stginit_bot-0.1_Bot.Process_
06:40:37 <ManateeLazyCat> aavogt: I just instance every field of Environment, then change my function arguments to "nested-tuple" style.
06:40:50 <aavogt> especially with patterns, since there are no quotes for patterns
06:41:18 <ski> (ManateeLazyCat : `n' being `()', yes ?)
06:41:46 <ManateeLazyCat> aavogt: Because i has write "instance (ActionInputArgs a, ActionInputArgs b) => ActionInputArgs (a, b) where execute env = liftM2 (,) (execute env) (execute env)", so polymorphism function will instance recursive automatically.
06:41:47 <ManateeLazyCat>  
06:42:39 <ManateeLazyCat> aavogt: I still use regular-record to define "data Environment = Environment {...}"
06:43:06 * ManateeLazyCat pasted "new instance." at http://paste2.org/get/856435
06:43:20 <ManateeLazyCat> aavogt: Look above, i just need write those instance.
06:43:42 * ski gives ManateeLazyCat a cookie
06:44:13 <ManateeLazyCat> aavogt: Perhaps HList code is better, but it too overkill for my situation.
06:44:31 * aavogt never understands why people say stuff like that
06:44:36 <kmc> no quotes or splices :/
06:45:08 <ManateeLazyCat> aavogt: I think my solution "nested-tuple base on typeclass" is similar HList, but my code is simpler... :)
06:45:17 <aavogt> kmc: but for the empty tuple name!
06:45:29 <mux> dcoutts: http://hackage.haskell.org/trac/ghc/ticket/4104
06:45:34 <aavogt> uh, it's not simpler if you have to write it instead of it being in a library
06:47:00 <ManateeLazyCat> aavogt: I think HList is "nested-tuple" essentially, just more sugar?
06:48:10 <dcoutts> mux: thanks, I added a comment too
06:48:42 <mux> dcoutts: seen; I should have said that indeed
06:49:03 <ManateeLazyCat> aavogt: Maybe HList can avoid write instance code like http://paste2.org/get/856435 ?
06:50:30 <aavogt> I'm still not sure why you keep this Environment record around when all you do is just run IO actions based on it's contents
06:50:44 <aavogt> tvars aren't serializable... are they?
06:51:12 <kmc> how would that work?
06:51:32 <ManateeLazyCat> aavogt: Because i need hook reference (TVar) in gtk2hs's callback.
06:52:07 <ManateeLazyCat> aavogt: My gtk2hs program is update those "share state" through user's event.
06:52:33 <ManateeLazyCat> aavogt: If i don't use TVar, i can't update state when user trigger some event.
06:53:42 <ManateeLazyCat> aavogt: Like i said, i try to avoid write "Environment -> IO ()", because i want split connect between modules.
06:53:59 <ManateeLazyCat> aavogt: Low-level modules don't need know the detail of other modules.
06:54:26 <ManateeLazyCat> aavogt: All communication action is mix by Environment in *higher* module.
06:55:00 <ManateeLazyCat> aavogt: Then i can get good layout with different level modules.
06:55:56 <edwardk> does PierreEtienneMeunier log into irc?
06:56:28 <ivanm> edwardk: yeah, lemme dig up his nick
06:56:35 <ivanm> he was talking about his ropes stuff yesterday
06:56:42 <edwardk> yeah
06:56:43 <Axman6> edwardk: i emailed him about the null thing already
06:57:05 <edwardk> Axman6: mostly i just wanted to point out that fingertrees are way faster than bounded balance for what he wants
06:57:37 <ivanm> edwardk: I like, I got him confused with sioraiocht
06:57:55 <ivanm> since he's doing rope stuff as well
06:57:55 <ManateeLazyCat> aavogt: And other advantage is, if i write "(OldA, OldB) -> IO (NewA, NewB)" instead "Environment -> IO ()", i can keep low-level functions purely, don't need do "readTVarIO" and "writeTVarIO" everywhere.
06:58:28 <aavogt> so using hlist you'll end up with:     r -> IO r
06:58:48 <edwardk> i went to go benchmark the difference between the two libs and i couldn't come up with one that showed both in a positive light. either the problem is too big, or the problem uses his special case for handles, either way one of the two winds up a flat line across the bottom of the benchmark due to the difference in asymptotics
06:58:58 <aavogt> with some massive class context that indicates which fields were read or modified in the r
06:59:04 <edwardk> ivanm: i also have a lib in that area ;)
06:59:32 <edwardk> though mine was constructed mostly for my own use and posted as an afterthought
06:59:47 <ivanm> I know
07:00:22 <ManateeLazyCat> aavogt: Ah, If i can do "r -> IO r" and split layout, that's cool.
07:00:24 <ivanm> sioraiocht was talking about writing a paper on ropes, and Pierre has released some rope libraries recently IIRC which is why I thought they were the same person
07:00:35 <edwardk> i don't particularly care one way or the other but i'd hate to see the wrong data structure win out
07:00:39 <edwardk> yeah
07:00:59 <edwardk> i'd been talking to sioraiocht about ways to add fusion to my rope lib
07:01:27 <aavogt> but it sort of discourages you to write type signatures, since the signature grows linearily with the number of fields you operate with
07:01:38 <edwardk> apparently its the topic of his dissertation or some such
07:02:25 <ivanm> yeah
07:02:37 <ivanm> he was submitting a paper on it to the Haskell Workshop or something IIRC
07:02:38 <edwardk> i was planning on going back and adding support for ropes of vectors, etc. but i'll admit i don't really care enough to sit and duke things out with benchmarks, and 3-4 competing implementations
07:03:05 <ivanm> I lie, it was for the Haskell symposium
07:03:07 <Saizan> where's a dons when you need it?
07:03:10 <ManateeLazyCat> aavogt: Ah, maybe just keep my solution is simple.
07:03:13 <ivanm> preflex: seen dons
07:03:13 <preflex>  dons was last seen on #haskell 21 hours, 11 minutes and 51 seconds ago, saying: man, 1 up, 3 down, http://www.reddit.com/r/programming/comments/c93p8/announcing_intel_concurrent_collections_for/ :/
07:03:34 <Olathe> @pl \a b -> b
07:03:34 <lambdabot> const id
07:03:37 <Saizan> ah, on reddit :)
07:03:45 <ivanm> Saizan: lol
07:04:08 <edwardk> heh lambdabot needs to read reddit. dons was last seen on reddit 5 minutes and 23 seconds ago, saying: ...
07:04:28 <ivanm> dons did a comment on reddit saying "..." ?
07:05:29 * Axman6 would really like to know when Galois will be publishing the video of the L4.verified talk
07:05:30 <edwardk> to make that fully accurate: dons was last seen on reddit 6 hours ago, saying: do you have numbers, besides?
07:05:31 <Saizan> (anyhow, it was a failed attempt at a joke about making benchmarks)
07:05:49 <ManateeLazyCat> aavogt: Everything has a price, maybe HList will make me crazy in other place.... :)
07:05:56 <ivanm> Saizan: that's what I was thinking of actually tbh
07:06:02 <ivanm> like that comic strip with the tupil guys?
07:06:08 <ManateeLazyCat> aavogt: But i don't know, i haven't understand HList deeply.
07:06:19 <edwardk> Saizan: heh well i was trying because he'd asked if I had any in response to my post on reddit
07:06:43 <edwardk> sadly i can't come up with a 'fair' benchmark suite, since you can always say that you could go down some fast path with one or the other
07:07:07 <ManateeLazyCat> aavogt: Thank you very much, my code is clear enough now even i don't use HList. :)
07:07:48 <Saizan> edwardk: sounds like monad-ran
07:07:51 <edwardk> i.e. consing up a rope is O(n log n) using Data-Rope, but O(n) using rope, but either could argue that you can build a bytestring and build the rope in O(1) or build a string then build the rope, etc.
07:08:17 * ManateeLazyCat I has pay for my "Environment -> IO ()" functions, i won't do that anymore ....
07:08:30 <ivanm> edwardk: how about a benchmark comparing pretty-printer libraries creating ropes?
07:08:34 <edwardk> Saizan: nah, i now concede that all of the non-codensity monads in monad-ran are slower than their equivalents. the codensity monads in there though are somewhat competitive
07:09:48 <edwardk> ivanm: well, there that O(1) vs. O(log n) cons should pay out --  there its just a function of the size of the benchmark
07:10:34 <ivanm> by "pay out" as in become obvious?
07:10:38 <edwardk> yeah
07:10:54 <ivanm> then isn't that a good benchmark as a comparison?
07:11:02 <edwardk> sure
07:11:25 <Silvah> edwardk: lambdabot?
07:11:38 <Jafet> Which data structures are Data-Rope and rope?
07:11:45 <Silvah> Ropes.
07:11:59 <Jafet> Sounds like one's a straight-up binary tree and the other is lazy or fingered
07:12:30 <ivanm> Jafet: probably alternate implementations of the same basic concept
07:12:38 <edwardk> ivanm: its just a pain in the neck to implement using the Data-Rope api which is all about Word8s except when he forgets and returns Chars.
07:12:48 <ivanm> ugh
07:12:51 <ivanm> who wrote that one?
07:13:15 <edwardk> actually it looks like he only used Char in 'index'
07:13:18 * ivanm is reading through SPJ's TH paper, and is already stuck on page 2
07:14:54 <Saizan> link?
07:15:01 <ivanm> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8322
07:15:13 <EvanR> i extracted enough information about 'a theory of objects' to understand some of cardellis object calculi. and it seems the simplest one is directly representable in haskell using record types, record update syntax, and functions. that means haskell is object oriented! ;)
07:15:15 <ivanm> (I can't give you the full on MSR link because for some reason I can't access MSR :s )
07:15:36 <edwardk> EvanR: have you read OOHaskell?
07:15:37 <ivanm> I can't follow why TH-printf needs an accumulating parameter for the gen function
07:15:47 <EvanR> no
07:16:22 <edwardk> EvanR: it is a pretty good overview of how to implement OOP in haskell, Oleg-style.
07:16:37 <EvanR> http://homepages.cwi.nl/~ralf/OOHaskell/ this?
07:16:44 <edwardk> yeah
07:17:57 <kmc> ivanm, which function?
07:18:14 <ivanm> kmc: the gen function, second page (the full version)
07:18:16 <ManateeLazyCat> edwardk: I think it's base on HList.
07:18:28 <edwardk> EvanR: you might also like http://comonad.com/reader/2006/overloaded-functions-with-subtyping/ if you're exploring object calculi
07:18:32 <EvanR> i also found a pdf about abstract data types vs object oriented objects. this stuff is so strange
07:18:34 <ivanm> also, with TH is the $ part of the compiler or is it an actual part of the library?
07:18:37 <edwardk> ManateeLazyCat: it is, hence 'oleg-style' ;)
07:18:44 <edwardk> $ is just $
07:18:51 <Jafet> $() is syntax
07:18:57 <ivanm> Jafet: that's what I meant
07:19:14 <kmc> ivan, with TH $(...) and $x becomes special syntax
07:19:25 <ivanm> so, can $(..) or $x be considered as Expr -> String functions?
07:19:26 <kmc> as is [| ... |] and variants like [t| ... |]
07:19:27 <ManateeLazyCat> edwardk: HList is "nested-tuple", i use HList principle fix my polymorphism functions just now, even i don't use HList last. :)
07:19:33 <kmc> ivan, no
07:19:51 <ManateeLazyCat> edwardk: I like Oleg idea.
07:19:52 <kmc> those are splices
07:19:55 <akosch> what's the best way of doing something x times (for example like read line from input 10 times...)?
07:20:01 <ManateeLazyCat> edwardk: Very neat.
07:20:07 <ivanm> akosch: replicateM
07:20:10 <ivanm> @type replicateM
07:20:10 <kmc> they evaluate the expression to a syntax tree, then splice it in at this position in the code
07:20:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:20:20 <akosch> ivanm: thx
07:20:30 <edwardk> ManateeLazyCat: yeah oleg i a great source of things that just need a little polish to put into production ;)
07:20:43 <ivanm> kmc: right, it's just that in the example they have $x evaluating the x Expr value to a String
07:20:53 <ivanm> so I"m trying to work out what it does
07:21:10 <ivanm> or does it just return code, and in this case the code it returns is a String literal?
07:21:24 <ManateeLazyCat> edwardk: I have download Oleg's OOPHaskell source code, but haven't read it, it's a bit overkill for me. :)
07:21:40 <EvanR> edwardk: HList eh...
07:21:46 <kmc> ivanm, $x ++ "foo" is valid if (x :: Expr)
07:21:55 <kmc> x could be the code for expression, not just a string literal
07:21:55 <ivanm> kmc: it is
07:22:06 <kmc> it will splice in that code, then type check as if you'd written the code yourself
07:22:17 <edwardk> ManateeLazyCat: it makes a lot more sense if you read it while reading the paper
07:22:23 <ivanm> kmc: OK, so $ is kinda like some Expr -> <code> function?
07:22:33 <kmc> you really can't think of it as a function
07:22:43 <ivanm> k
07:22:49 <ManateeLazyCat> edwardk: Oleg's paper is very nice.
07:23:14 <kmc> ivanm, it means "compute some code and insert it here"
07:23:18 <kmc> it's how you invoke macros, basically
07:23:18 <ManateeLazyCat> edwardk: But i prefer as Pure Haskeller, try to avoid use OOP technology. :)
07:23:20 <ivanm> *nod*
07:23:34 <kmc> OOP isn't un-Haskelly
07:23:42 <kmc> when it's actually the right tool for the job
07:24:15 <ManateeLazyCat> kmc: I mean i won't use OOP's class hierarchy (such as Java), i prefer to use typeclass. :)
07:24:27 <kmc> sure
07:24:41 <kmc> ManateeLazyCat, when i've done OOP in Haskell it's often without type classes either
07:24:54 <kmc> interfaces are record types, possibly existentially quantified
07:25:13 <edwardk> i usually just define oop-like constructs via fclabels and records these days. i define a record for the fields in want to be able to inherit, provide a typeclass with accessor that returns that subset of the object's fields, and then define composed accessors for all of its members
07:25:34 <edwardk> then i can subclass just by composition for most uses
07:25:40 <edwardk> tying the knot is the only tricky part
07:25:48 <ManateeLazyCat> kmc: I always integrate Typeable with typeclass, and that's enough for my need.
07:26:05 <ManateeLazyCat> kmc: typeclass for common interface, Typeable do speical interface.
07:26:45 * ManateeLazyCat I was a Java programmer :)
07:26:52 <ski> `$' in TH is basically an `unquote' operator
07:27:26 <ivanm> kmc: so, with something like the app :: Expr -> Expr -> Expr function, TH doesn't do any type-checking to ensure that the first Expr represents a function and that the second is a value of the right type to apply the function on, correct?
07:27:41 <kmc> ivan, correct
07:27:53 <ski> edwardk : tying the knot being the same as open recursion, in this case ?
07:28:24 <ManateeLazyCat> edwardk: If you just need inherit "A -> B", i think "class Typeable a => Foo a where" is simpler.
07:28:33 <ivanm> and [| ... |] is a shortcut to writing some of the stuff explicitly using lam, etc.?
07:28:33 <kmc> the types on your metaprogram represent parts of the language grammar.  as such, type-correctness of the metaprogram proves that it will produce syntactically valid code, not that it will produce type-correct code
07:28:39 <ManateeLazyCat> edwardk: I always avoid to use too many inherit.
07:28:42 <ivanm> in that you're writing more "normal" Haskell?
07:28:58 <kmc> ivanm, correct
07:29:09 <ivanm> cool
07:29:19 <kmc> in fact there's a lot you can't do with [| ... |]
07:29:30 <kmc> which the paper gets into
07:29:33 <ivanm> but when you can it's more concise?
07:29:33 <ski> ivanm : contrast this with MetaML (and MetaOCaml), where you can define an `app :: Code (a -> b) -> Code a -> Code b' where you can't even compile a program that would pass code to `app' that would not type-check
07:29:51 <kmc> and the syntax in GHC now is not precisely the same as this paper, and is lacking some of the stuff described in the paper iirc
07:30:38 <ivanm> ski: so MetaML and MetaOCaml are stricter than TH?
07:30:44 <ski> ivanm : in MetaML / MetaOCaml , there's a corresponding `DynCode' that corresponds to `Expr' .. but i'm not sure whether it type-checks as soon as possible, or only when running/splicing the whole value of type `DynCode'
07:30:53 <ivanm> kmc: what kind of stuff is lacking?
07:30:56 <ski> ivanm : yes
07:31:02 <kmc> ivanm, pattern quotes and splices
07:31:05 <ivanm> ski: *nod*
07:31:10 <kmc> is the main one annoying me atm
07:31:10 <ivanm> kmc: hmmm...
07:31:14 <ManateeLazyCat> edwardk: BTW, Oleg release OOPHaskell as cabal package?
07:31:43 <edwardk> oleg doesnt really speak cabal :)
07:31:47 <applicative> edwardk, I was trying to think of a rope vs. data-rope competition, but you don't have as many functions in the font-page module, Data.Rope.
07:32:10 <aavogt> the justification for the quote syntax ([| |]) can be done later on, ivanm
07:32:10 <ivanm> ManateeLazyCat: dons and gwern have done most of the cabalisation of oleg's projects
07:32:16 <ivanm> there's an oleglib or something on hackage
07:32:23 <ivanm> aavogt: *nod*
07:32:35 <ivanm> yeah, I'm finding the explicit syntax easier to understand atm
07:32:41 <aavogt> as in the two tutorials by bulat: http://haskell.org/haskellwiki/Template_Haskell#Template_Haskell_tutorials_and_papers
07:32:48 <edwardk> applicative: yeah. i could probably stand to add a few more
07:32:58 <applicative> edwardk, so far a couple of totally trivial tests (read, print length; read, trunctate, print length) , http://pastebin.com/Lmhz5gJh
07:33:12 * ManateeLazyCat aavogt are TH master. :)
07:33:16 <ivanm> aavogt: yeah, I saw that link; but I have trouble enough reading and comprehending his emails on -cafe, so I didn't want to try risking his tutorials...
07:33:18 <ManateeLazyCat> s/are/is
07:33:23 <ManateeLazyCat> ivanm: Ah, i read it.
07:33:40 <aavogt> it takes a while to understand when you may nest [| $( ) |]
07:34:06 <edwardk> erm
07:34:09 <applicative> edwardk, can there be append and reverse, for example, in that module
07:34:16 <aavogt> ivanm: that tutorial shouldn't be too bad :)
07:34:19 <edwardk> neither one of those is a great benchmark because they don't use the ropeyness of the rope
07:34:32 <edwardk> they just build a rope out of a bytestring
07:34:41 <ivanm> edwardk: tie some knots in them then! :p
07:34:43 <applicative> edwardk, of course not, i was preparing my system... looking for a good operation
07:34:47 <edwardk> yeah
07:35:08 <ski> edwardk : *reprod* about knots ..
07:35:10 <edwardk> i do need to supply a fast replicate, and reverse. i'm shocked append isn't there
07:35:19 <aavogt> ManateeLazyCat: people like mmorrow are certainly better
07:35:36 <ski> @get-mmorrow
07:35:37 <lambdabot> Unknown command, try @list
07:35:43 <edwardk> ah my append is my monoid =)
07:35:46 <applicative> edwardk, obviously your ropes have much more structure, so more can be done.  maybe the difference won't emerge
07:35:58 <edwardk> the reason reverse isn't there is a question of semantics
07:36:00 <ManateeLazyCat> aavogt: I think mmorrow has disappear long time :)
07:36:06 <edwardk> there are two operations that could be reverse
07:36:11 <edwardk> reversing chars and reversing word8s
07:36:23 <applicative> edwardk, i see
07:36:37 <applicative> i wonder what his is?
07:36:40 <ivanm> ski: methinks we all want that command
07:36:40 <edwardk> the Data.Rope module only exports the methods that make sense for both
07:36:43 <edwardk> he reverses word8s
07:36:48 <applicative> notice they give different results for truncate...
07:36:49 <applicative> ha
07:36:49 <edwardk> since he has no notion of utf-8 chars
07:36:55 <akosch> can i write a lambda function without arguments?
07:36:58 <ivanm> edwardk: so it could stuff up encodings?
07:37:06 <edwardk> ivanm: yes
07:37:08 <applicative> edwardk, but the same for the whole length
07:37:09 <ivanm> akosch: no, because it then wouldn't be a function...
07:37:15 <ski> akosch : i think you want just a constant, like `x = 42'
07:37:38 <akosch> i just want to group some actions together...
07:37:56 <ski> akosch : note that the body probably won't be evaluated before `x' is actually needed
07:38:07 <edwardk> how big is monster.txt?
07:38:24 <applicative> edwardk, i supply YOUR length...
07:38:25 <ski> > length "monster.txt"
07:38:26 <lambdabot>   11
07:38:33 <monochrom> haha
07:38:36 <edwardk> ski: smart ass ;)
07:38:51 * ski reprods edwardk yet again about the above question
07:38:54 <ivanm> kmc: dammit, I wish he started his paper with a quick introduction to all the syntax rather than suddenly going "Oh, yeah, and we used [ p | ... | ] which means this"
07:39:09 <edwardk> ski: what about knots?
07:39:17 <aavogt> there is no [p| |]
07:39:20 <applicative> 4891239
07:39:24 <edwardk> ski: looking back trying to find the original question
07:39:25 <ski> <edwardk> tying the knot is the only tricky part
07:39:26 <ski> <ski> edwardk : tying the knot being the same as open recursion, in this case ?
07:39:35 <monochrom> I prefer suddenly going "we use [p|...|] which means this"
07:39:37 <ivanm> aavogt: oh... so does this mean the generic zipN can't work?
07:39:39 <edwardk> yes
07:39:42 <ivanm> or it's just done differently?
07:39:43 <aavogt> ivanm: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/template-haskell.html
07:39:44 <ski> (about "define oop-like constructs via fclabels and records")
07:39:52 * ManateeLazyCat Reading http://hackage.haskell.org/package/liboleg
07:40:04 <ivanm> monochrom: well, he just says what it is rather than explains what it does
07:40:18 <applicative> Prelude> readFile "monster.txt" >>= print . length   yields    4890591
07:40:42 <monochrom> doesn't matter to me
07:40:44 <portnov> ManateeLazyCat: i thought it's the library which will add some milliOlegs to me...
07:41:00 <ivanm> well, I'm trying to work out what it means...
07:41:23 <ManateeLazyCat> ivanm: So haven't a "standalone" OOP library by Oleg?
07:41:34 <ivanm> ManateeLazyCat: not that I know of
07:41:48 <edwardk> applicative: you should start seeing a difference between the two once the depth of the tree is deep enough that the constant factors of the fingertree are smaller than the asymptotic factors of the bounded balance tree, so 3-4 levels deep, or a minimum of 8-16 chunks
07:41:58 <aavogt> ManateeLazyCat: I think hlist has some stuff from the oohaskell paper
07:41:59 <ivanm> AFAIK, most of oleg's works are stuff that are then taken as ideas and cleaned up before being released into libraries
07:42:06 <EvanR> :t returnIO
07:42:07 <lambdabot> Not in scope: `returnIO'
07:42:27 <ivanm> e.g. iteratee
07:42:50 <aavogt> ivanm: [| |] quotes are just a convenience notation for some constructors of the TH AST
07:42:57 <ski> EvanR : possibly you just want `return' ?
07:43:08 <ski> @type return :: a -> IO a
07:43:08 <lambdabot> forall a. a -> IO a
07:43:11 <ivanm> aavogt: *nod*
07:43:15 <aavogt> though perhaps there are some subtlties regarding which variable is being bound
07:43:17 <edwardk> applicative: i kind of wish i'd kept my first version of the rope library around for benchmarks (it handled the utf8 encoding differently, by tracking tail bytes as a separate counter)
07:43:23 <ski> edwardk : ok, ty
07:43:30 <ManateeLazyCat> aavogt: I have download http://homepages.cwi.nl/~ralf/OOHaskell/OOHaskell.zip , but i prefer Oleg will release it as Cabal package.
07:43:33 <Taejo> what are the relative pros and cons with writing a separate lexer and parser for a language, against writing a unified parser (the latter seems more common with parsec -- is that true?)
07:43:43 <aavogt> ManateeLazyCat: that's not likely to happen
07:43:45 <ivanm> ManateeLazyCat: he won't
07:43:51 <ManateeLazyCat> ivanm: Why?
07:44:02 <edwardk> Taejo: the reason why they are separate is mostly a technical limitation on many old school LALR parsers
07:44:15 <ivanm> ManateeLazyCat: because he doesn't seem to release stuff from what I've noticed
07:44:17 <ManateeLazyCat> ivanm: Looks pretty cool
07:44:21 <aavogt> if you want to do the cabalising I'm sure you'll get support
07:44:22 <Saizan> ManateeLazyCat: OOHaskell is a proof of concept of what you can do, it's not intended for everyday use
07:44:23 <Taejo> edwardk: so if I'm using Parsec, I shouldn't lex separately?
07:44:25 <edwardk> Taejo: with recursive descent/LL parsing they can be collapsed without additional machinery
07:44:41 <edwardk> with parsec lexing separately is just a needless pain in the behind ;)
07:44:41 <ivanm> Saizan: as with most of oleg's stuff?
07:44:48 <ivanm> Taejo: nope
07:45:02 <Taejo> ivan, edwardk: thanks
07:45:05 <ivanm> Taejo: I find combinator parsing more expressive, etc. and easier to read
07:45:05 * ski for a while thought Taejo was talking about relative pros and cons with writing a separate serializer/pretty-printer and parser for a language :)
07:45:08 <aavogt> ivanm: though you sort of need  '' and ' to quote names if you want to be hygenic
07:45:16 <ManateeLazyCat> Saizan: If OOHaskell can works perfect, why not use it everyday?
07:45:29 <Saizan> ivanm: actually no, e.g. HList, iteratee, LogicT, ..
07:45:34 <ivanm> Taejo: but I'm not sure how well it would perform if you bothered to write a "traditional" parser and compared it to a combinator one
07:45:38 <aavogt> @type mkName
07:45:39 <lambdabot> Not in scope: `mkName'
07:45:43 <aavogt> @hoogle mkName
07:45:44 <lambdabot> Language.Haskell.TH mkName :: String -> Name
07:45:44 <lambdabot> Language.Haskell.TH.Syntax mkName :: String -> Name
07:45:44 <lambdabot> Language.Haskell.TH.Syntax mkNameG_d :: String -> String -> String -> Name
07:45:51 <ivanm> Saizan: except iteratee seems to be developed separately nowadays IIUC
07:45:53 <edwardk> ManateeLazyCat: oleg-haskell is hardly idiomatic haskell ;)
07:45:56 <Taejo> ivanm: in this case, I'm only parsing a few kilobytes
07:46:09 <ivanm> Taejo: what are you parsing?
07:46:19 <Taejo> a programming language
07:46:20 <edwardk> ManateeLazyCat: also HList/OOHaskell is rather inefficient, as it involves a linear scan for the field through the HList
07:46:20 <Saizan> ManateeLazyCat: it's a pretty heavy and probably quite inefficient encoding
07:46:31 <ManateeLazyCat> edwardk: I hope Oleg can release it's library with many standalone cabal package, and not liboleg. :)
07:46:40 <aavogt> hmm, though you could use those mkNameG_d to refer to a name in a specific module / qualification
07:46:51 <ManateeLazyCat> edwardk: yes, because HList is "nested-tuple"
07:46:53 <edwardk> ManateeLazyCat: oleg doesn't bother with releasing libraries. liboleg is an independent effort to package up his goodies
07:47:18 <ivanm> @hoogle TH_Render
07:47:19 <lambdabot> No results found
07:47:25 <ManateeLazyCat> edwardk: Lost for haskell community.
07:47:25 <monochrom> you are free to compete and release a set of small packages
07:47:39 <ivanm> is the class referred to in here real? http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example
07:47:44 <Saizan> ivanm: there's a difference between "needing to be polished" and "i'm writing this up but even i wouldn't use it"
07:47:50 <edwardk> ManateeLazyCat: nah, i'd rather have him out there innovating and then have the rest of us clean up after him with things like liboleg, reflection, etc.
07:47:59 <ivanm> Saizan: right
07:48:11 <ivanm> Saizan: but does oleg tend to polish stuff up himself?
07:48:17 <kmc> i've had some use cases for separate lexing with Parsec
07:48:21 <kmc> it's not the norm, though
07:48:26 <Saizan> ivanm: no, but for OOHaskell he specifically says the latter in the paper.
07:48:34 <ivanm> because most of the stuff I"ve noticed that started off with him ended up being polished by someone else AFAICT
07:48:37 <ivanm> Saizan: *nod*
07:48:50 <ivanm> kmc: why did you have to lex separately?
07:48:51 <pchiusano> hello
07:49:02 <ManateeLazyCat> edwardk: I'm reading Oleg's homepage, he has finish so much awesome work.
07:49:07 <kmc> i was processing a language with a Haskell-like layout rule
07:49:16 <kmc> so i lexed, applied layout, then parsed
07:49:35 <edwardk> ivanm: mostly because in my experience talking to him, he usually gets involved when someone asks him a pointed question and then he sits down thinks for about 3 seconds and rattles off an answer ;)
07:49:42 * Cale tries to track down a segmentation fault in nymphaea with the newer gtk library on hackage.
07:49:48 <edwardk> and then if its neat enough he sends it to a mailing list and forgets about it
07:49:48 <ivanm> Taejo: a word of warning: apparently a lot of the difficulties I had with parsing Dot code was because I _didn't_ lex, etc. like dot, neato, etc. do; mainly due to considering quoted strings (as they just consider it a list of bytes when "parsing")
07:49:50 <EvanR> i finally scrolled down to the bottom after accidentally scrolling up and leaving it there. damn this channel produces a lot of traffic
07:50:05 <ivanm> edwardk: heh, but was that aimed at ManateeLazyCat?
07:50:18 <ivanm> Cale: sounds like fun :s
07:50:18 <EvanR> i checked the type of returnIO because thats what oleg uses in his first OOHaskell example
07:50:23 <Taejo> ivanm: my language is pretty simple (no strings, even) so I probably won't have an issue
07:50:27 <EvanR> guessing its just return
07:50:34 <edwardk> ivanm: aimed in response to your ' most of the stuff I"ve noticed that started off with him ended up being polished by someone else AFAICT '
07:50:35 * ivanm waves idly in pchiusano's general direction
07:50:46 <edwardk> heya pchiusano
07:50:54 <pchiusano> hey!
07:50:56 <Cale> ivanm: Something strange is occurring. It seems like the segfault happens sometime after any particular event handler.
07:51:00 <pchiusano> ivanm: ?
07:51:06 <ivanm> Taejo: admittedly, the problem with Dot code was how to deal with two different possible encodings, which might not be an issue with you
07:51:12 <Cale> (well, I'm not sure yet which is last)
07:51:13 <ivanm> pchiusano: just my way of saying "hi" ;-)
07:51:19 <ivanm> Cale: hmmm...
07:51:26 <pchiusano> ivanm: ah :)
07:51:43 <alexyk> where do we get ord?
07:51:44 <ivanm> Cale: well, you've got ManateeLazyCat here who knows about the internals of gtk2hs... ;-)
07:51:52 <ivanm> alexyk: Ord is in the Prelude
07:51:57 <ivanm> the ord function is in Data.Char
07:52:03 <ivanm> take your pick which you mean ;-)
07:52:10 <ManateeLazyCat> Ok, talk enough, i need off busy on my project, thanks all for help! I love this channel, i study much knowledge everyday.... :)
07:52:11 <alexyk> I take ord :)
07:52:15 <pchiusano> question about iteratees - why allow divergent iteratees? why not just design the type so an Iteratee must return a value upon being fed EOF?
07:52:31 <ivanm> I notice that as soon as I hint that _he_ might be able to answer a question for once, ManateeLazyCat suddenly has to leave...
07:52:32 <ivanm> ;-)
07:52:36 <aavogt> edwardk: so you could have heterogenous trees for faster lookups then?
07:52:36 <edwardk> pchiusano: it was an oversight ;)
07:52:41 <ManateeLazyCat> Cale: Which ghc do you use ?
07:52:47 <Cale> 6.12.2
07:52:49 <pchiusano> edwardk: seriously?
07:52:50 <ivanm> Cale: there's a bug there
07:52:53 <edwardk> pchiusano: they really should have two continuations in some sense
07:52:54 <akosch> how can i convert an integer to a bytestring?
07:52:54 <ivanm> try the RC or something
07:52:55 <ManateeLazyCat> Cale: Rollback to 6.12.1
07:52:59 <Cale> oh, okay
07:53:12 * ivanm realised that as soon as ManateeLazyCat asked about ghc version
07:53:18 <monochrom> 6.12.3 RC fixes bugs of both 1 and 2
07:53:20 <edwardk> pchiusano: i came across the same issue when implementing my own iteratees
07:53:31 <ManateeLazyCat> Cale: 6.12.2 has runtime bug that will crash your gtk2hs program you call C callback
07:53:33 <aavogt> and adds some more most likely
07:53:33 <ivanm> this, of course, isn't a problem on Gentoo as we've patched 6.12.2 ... ;-)
07:53:36 <pchiusano> edwardk: yeah.. me too! :)
07:53:44 <ente> will there be lzma compressed packages for later GHC releases?
07:53:55 <edwardk> pchiusano: the type they provide is a bit larger than is required for their problem because you could respond to an empty bytestring with a request for more input, but shouldn't be able to
07:53:57 <Cale> In that case, I'll just leave it for now. I don't really need this to work so much.
07:53:59 <ivanm> monochrom: I would have thought that 2 fixed the bugs in 1 ...
07:54:14 * ivanm should hit the sack
07:54:16 <ente> I hope so, since it takes really long for the .bz2 ones to download
07:54:17 <ivanm> g'night all
07:54:17 <edwardk> the argument in favor of the current approach is that you get one continuation allocated, and don't have to worry about gc'ing the other one, but its kind of weak
07:54:18 <ManateeLazyCat> Cale: We have test gtk2hs from 6.10.3 to 6.12.1, works fine.
07:54:21 <monochrom> 2 fixed the bugs in 1 but the method added worse bugs
07:54:25 <ivanm> ente: I doubt it
07:54:27 <ente> why?
07:54:29 <ivanm> lzma isn't that popular yet
07:54:30 <ManateeLazyCat> Cale: Unfortunately, 6.12.2 has bug, hope it will works fine in 6.12.3
07:54:37 <ente> well...
07:54:38 <ski> edwardk : one explicit and one implicit continuation ?
07:54:50 <ivanm> ente: if you ask the GHC devs you might be able to get lzma done as well
07:54:58 <ente> good idea
07:55:10 <ivanm> but I doubt it'll replace bz2 for a while
07:55:19 <aavogt> so try #ghc or the ghc mailing list
07:55:24 <ente> not replace, but maybe they could provide both
07:55:30 <Cale> Actually, if someone with gtk2hs and 6.12.1 is bored, you could try installing nymphaea from hackage and see if it works.
07:55:41 <pchiusano> data Iteratee a b = Done b (Input a) | Cont { onEOF :: b, onChunk :: Input a -> Iteratee a b }
07:55:42 * ski wonders how to handle `maximal-munch', in a logical, symmetric fashion
07:55:49 <pchiusano> edwardk: something like that
07:56:05 <edwardk> ski: nah, if you think of an iteratee as something like data Iteratee a = Return a Input | Cont (Input -> Iteratee a) -- you don't really want Cont to be that general you want something like data Iteratee a = Return a Input | Cont (NonEmpty ByteString -> Iteratee a) (a, Input ) -- where the latter tuple is what the return would be
07:56:15 <EvanR> > let (#) = (+) in 4# 5
07:56:16 <lambdabot>   <no location info>: parse error on input `)'
07:56:20 <EvanR> > let (#) = (+) in 4 # 5
07:56:21 <lambdabot>   <no location info>: parse error on input `)'
07:56:24 * ManateeLazyCat I will try to test gtk2hs with 6.12.3-RC1 when i have spare time.
07:56:25 <Cale> At first I got a pattern match failure, which may or may not happen and it would be interesting to know.
07:56:34 <edwardk> onEOF should also include the unparsed portion, since you might back off
07:56:36 <aavogt> > let ( # ) = (+) in 4 # 5
07:56:38 <lambdabot>   9
07:56:42 <Taejo> EvanR: # is not a symbol
07:56:48 <aavogt> yes it is
07:56:49 * ManateeLazyCat I think Simon has fix this problem in 6.12.3, but i haven't test it.
07:57:02 <Taejo> am I misremembering something?
07:57:05 <ski> edwardk : hm ? so `(a,Input)' there is determined without looking at `NonEmpty ByteString' =
07:57:08 <ski> s/=/?/
07:57:11 <Cale> (It might be just that some events happen in the new GTK at times when they didn't happen before, or something)
07:57:22 <edwardk> ski: yeah that would be the result if you had no more input
07:57:30 <ski> @v
07:57:30 <lambdabot> "\""
07:57:40 <alexyk> I :m +Data.ByteString and get filterNotByte not in scope... why?
07:57:58 <edwardk> ski: to get it now you have to pass an empty input to the function and hope that it gives you back a Return instead of a Cont. all well formed iteratees follow that pattern
07:58:00 <pchiusano> edwardk: you are saying onEOF should be able to return something other than EOF in "last input" slot?
07:58:01 <elmariposaatlas_> hi
07:58:04 <elmariposaatlas_> hoa
07:58:05 <aavogt> the issue is that ghc steals # as a letter for naming primitive functions / unboxed tuples
07:58:07 <elmariposaatlas_> hola
07:58:12 <elmariposaatlas_> 2ek3qnfj3fnrfrfer
07:58:13 <elmariposaatlas_> ref
07:58:13 <elmariposaatlas_> q
07:58:18 <ski> huh ? i swear `@v' responded with `<lambdabot> "\"#$%&'()*+,\""' a little while ago, in PM
07:58:21 --- mode: ChanServ set +o monochrom
07:58:27 <ski> @help v
07:58:27 <lambdabot> let v = show v in v
07:58:30 <ski> @v
07:58:30 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
07:58:38 <elmariposaatlas_> XDXDXD
07:58:55 <elmariposaatlas_> BYE
07:58:58 --- mode: monochrom set +q *!~riki@*
07:58:58 <ski> edwardk : ah, ok
07:59:02 <edwardk> pchiusano: hrmm i need to adapt my mental model. my iteratees allow backtracking so the input is the fingertree of the bytestrings they've seen so far and a flag that indicates if they've seen EOF.
07:59:08 <Cale> alexyk: You get that in response to :m + Data.ByteString?
07:59:19 <ski> edwardk : i see
07:59:43 <alexyk> Cale, no -- I try to eliminate backslashes from a bytestring with: filterNotByte 92 j
07:59:45 * ManateeLazyCat Bye all, good night. :)
07:59:47 <edwardk> pchiusano: so in that my Return encompasses both the result and the input to date (sacrificing the space guarantee, for backtrackability so i can run parsec parsers on it, using iteratees as an inversion of control mechanism)
08:00:07 <Cale> alexyk: Well, that function doesn't exist.
08:00:14 <pchiusano> edwardk: oh okay that makes sense i think
08:00:31 <Cale> alexyk: Maybe you just want filter?
08:00:37 <Cale> filter (/= 92) j
08:00:48 <alexyk> Cale: duh, I googled into Hugs docs :)
08:01:06 <ski> aavogt : well, also in `+#',&c.
08:01:11 <rajeshsr> is there any int type of size 8 bits in haskell?
08:01:25 <geheimdienst> rajeshsr, Word8?
08:01:35 <aavogt> ski: isn't +# legal H98 though?
08:01:36 <rajeshsr> geheimdienst, oh, ok
08:01:38 <rajeshsr> thanks
08:01:41 <edwardk> pchiusano: but in general an iteratee could return an arbitrary Done b (Input a) -- on EOF. i.. i'm parsing pairs of chars, you gave me an odd number, then an EOF, i'll give you back the last unparsed char.
08:01:44 <rajeshsr> @hoogle Word8
08:01:44 <lambdabot> Data.Word data Word8
08:01:44 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
08:01:46 <edwardk> er i.e.
08:01:48 <Cale> rajeshsr: There's also Int8
08:01:58 <Cale> rajeshsr: They're in Data.Word and Data.Int respectively
08:02:01 <ski> aavogt : well, sure .. just noting that enabling `MagicHash' doesn't disable use of `#' in operators
08:02:12 <rajeshsr> Cale, the thing is, i want to wrap to 0 after counting to 255
08:02:25 <aavogt> but for some reason the parser is confused by (#)
08:02:29 <ski> > succ 255 :: Word8
08:02:30 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
08:02:37 <alexyk> Cale: works with a Char, filter (/='\\') ...
08:02:42 <aavogt> unboxed 0-tuple?
08:02:43 <Cale> rajeshsr: Well, Word8 will do that. You could also just mod out by 256
08:02:44 <geheimdienst> cale, woah. what's the difference between int8 and word8?
08:02:45 <edwardk> at least with my approach
08:02:55 <monochrom> "a#b" is different from "a # b"
08:03:05 <Cale> alexyk: Ah, you must have the Char8 version loaded.
08:03:18 <Cale> geheimdienst: The range.
08:03:27 <aavogt> monochrom: for whose haskell?
08:03:29 <edwardk> the oleg and lato versions may differ in that regard since i think their Input types only have a Chunk ByteString | EOF -- rather than tracking a flag in the chunk
08:03:38 <Cale> > [minBound, maxBound] :: [Int8]
08:03:39 <lambdabot>   [-128,127]
08:03:40 <rajeshsr> Cale, hmm, yeah! but feeling lazy to do mod for every addition! I had written the code with Int. So, just want to retrofit into Word8 :)
08:03:43 <Cale> > [minBound, maxBound] :: [Word8]
08:03:44 <lambdabot>   [0,255]
08:03:58 <alexyk> Cale: well, I have all 3, and ghci complains and I have to qualify.  Is there a way to make one work unqialified, or hide others post-factum?
08:04:03 <rajeshsr> > 255::Word8 + 1
08:04:04 <lambdabot>   Could not deduce (GHC.Num.Num
08:04:04 <lambdabot>                      ((+) GHC.Word.Word8 GHC....
08:04:07 <illissius> ghc disallows cyclical (super)classes, but is that for theoretical or technical reasons? for example, is there any reason why this shouldn't be allowed to work? http://haskell.pastebin.com/FgMwZzwx
08:04:18 <geheimdienst> oh i see, thanks. it's just uint vs. int. could've found that out by myself :-)
08:04:25 <pchiusano> edwardk: hmm
08:04:28 <aavogt> without -XMagicHash they are the same
08:04:31 <rajeshsr> why doesn't that work?
08:04:44 <rajeshsr> > 255::Word8 + 1
08:04:45 <lambdabot>   Could not deduce (GHC.Num.Num
08:04:45 <lambdabot>                      ((+) GHC.Word.Word8 GHC....
08:04:46 <pchiusano> edwardk: so the type a is what?
08:04:52 <aavogt> > (255::Word8 )+ 1
08:04:53 <ski> aavogt : i'm not sure there is an unboxed nuple .. (there ought to be one, imo, though)
08:04:53 <lambdabot>   0
08:05:23 <rajeshsr> aavogt, ha, ok! so what happens without those parentheses?
08:05:41 <edwardk> pchiusano: i took the 'a' from your sketched example and just left it in
08:06:06 <edwardk> i'd presume the element type of whatever input vector/bytestring format you're using
08:06:07 <ski> > case (# () , () #) of (# _ , _ #) -> ()
08:06:08 <lambdabot>   ()
08:06:09 <alexyk> pchiusano: do comrades know you're haskelling around? :)
08:06:11 <ski> > case (# () #) of (# _ #) -> ()
08:06:12 <lambdabot>   ()
08:06:15 <Cale> alexyk: Well, you usually write something like   import qualified Data.ByteString as BS   and use most things qualified, but if you want to import something unqualified, you could have a separate line, like  import Data.ByteString (packCString)
08:06:16 <ski> > case (#) of (#) -> ()
08:06:17 <lambdabot>   <no location info>: parse error on input `)'
08:06:17 <aavogt> rajeshsr: the type is interpreted (Word8 + 1 )
08:06:32 <alexyk> Cale: ok
08:06:39 <rajeshsr> aavogt, ha, ok!
08:06:45 <rajeshsr> thanks
08:06:48 <Cale> alexyk: It's not possible to import things qualified at the ghci prompt, but if you load a module which imports them qualified, you can use them like that.
08:06:59 <rajeshsr> @hoogle Word8 -> Int
08:07:00 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
08:07:00 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
08:07:00 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
08:07:06 <aavogt> and there's some generics stuff in ghc that makes  Word8 + 1 some kind of type
08:07:20 <Cale> alexyk: It's also possible to import the Prelude hiding things which get in the way
08:07:29 <rajeshsr> any way to convert Word8 to Int?
08:07:30 <Cale> import Prelude hiding (readFile)
08:07:33 <pchiusano> edwardk: okay, you were saying if you are parsing pairs of chars, you might want to return the char just before the eof on done
08:07:43 <Cale> for example, if you want to use the readFile from Data.ByteString instead.
08:07:47 --- mode: monochrom set -o monochrom
08:07:47 <rajeshsr> > fromIntegral (2::Word8)
08:07:48 <lambdabot>   2
08:07:58 <rajeshsr> >:t fromIntegral (2::Word8)
08:08:02 <pchiusano> alexyk: is that you from #scala?
08:08:03 <pchiusano> :)
08:08:04 <rajeshsr> :t fromIntegral (2::Word8)
08:08:04 <lambdabot> forall b. (Num b) => b
08:08:11 <alexyk> pchiusano: who else :)
08:08:26 <Cale> rajeshsr: fromIntegral is the answer to a large chunk of "how do I convert this type of number to that one" questions :)
08:08:36 <pchiusano> alexyk: i've crossed over to the dark side!!!
08:08:48 <alexyk> pchiusano: looks like someone needs speedup :)
08:08:52 <edwardk> pchiusano: with the oleg/lato approach you let it go, so ok, I'll concede that your onEOF :: b is sufficient
08:08:58 <aavogt> @type toRational . fromRational
08:08:58 <rajeshsr> Cale, ha, ok!
08:08:59 <lambdabot> Rational -> Rational
08:09:09 <rajeshsr> :t fromIntegral (2.0::Double)
08:09:10 <lambdabot>     No instance for (Integral Double)
08:09:10 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-25
08:09:10 <lambdabot>     Possible fix: add an instance declaration for (Integral Double)
08:09:11 <aavogt> @type flip (.) toRational fromRational
08:09:12 <lambdabot> forall b a. (Real a, Fractional b) => a -> b
08:09:32 <Cale> If the answer is not fromIntegral, it's probably realToFrac (convert between fractional types), and if it's not that, then perhaps round/floor/ceiling/truncate
08:09:33 <ski> illissius : i suppose in simple cases like that one could argue that you could just as well merge the two classes .. i'm not aware of any reason to not allow this, though (other than being conservative in what to allow, in case we want to allow it later, rather than in the other direction)
08:09:58 <rajeshsr> Cale, thanks!
08:10:42 <ski> @whatis lato
08:10:42 <lambdabot> I know nothing about lato.
08:11:35 <Cale> http://en.wikipedia.org/wiki/Lato
08:12:18 <edwardk> ski: http://johnlato.blogspot.com/
08:12:24 <pchiusano> edwardk: I mean, I guess there is no need to limit the onEOF if it wants to return some arbitrary input rather than just EOF, although I'd imagine most iteratees wouldn't use that capability
08:12:26 <ski> hm .. and how does this pertain to oleg ?
08:12:34 <ski> edwardk, ty
08:12:41 <Cale> ah, hehe :)
08:12:49 <edwardk> ski: he wrote the iteratee library on hackage
08:12:55 <ski> i see
08:12:59 <edwardk> ski: oleg concocted the idea
08:13:06 <edwardk> but it was oleg-encoded
08:13:09 <ski> (yes)
08:13:17 <pchiusano> lol, oleg-encoded
08:13:35 <ski> edwardk : do you know how to think of `maximal-munch' in a logical, symmetric way ?
08:14:01 <Cale> It still looks oleg-encoded to me :)
08:14:06 <edwardk> Cale: hah
08:14:31 <edwardk> i like my simple iteratees but i use them for very different purposes.
08:14:46 <edwardk> ski: hrmm
08:14:53 <pchiusano> I still have not gotten my head around the CPS version of iteratees
08:15:01 <Cale> edwardk: Are those on hackage as well?
08:15:28 <ski> edwardk : i.e. if i want to think of parsing grammars as some kind of ordered logic; how should i encode `maximal-munch' here ?
08:15:32 <edwardk> cale: i didn't upload them. they are used in the bowels of some of my parallel parsers though
08:16:03 <edwardk> cale: they are described in the second set of slides at http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
08:16:51 <pchiusano> i love oleg's descriptions... "Re-writing IterateeM.hs into CPS. The delimited-control nature of Iteratees becomes apparent."
08:16:59 <edwardk> heh
08:17:21 <edwardk> everything oleg writes ultimately returns to dynamic binding and delimited control ;)
08:17:33 <edwardk> or prolog ;)
08:17:36 <Taejo> :t (*>)
08:17:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:17:52 <pchiusano> hehe
08:17:53 <Saizan> edwardk: if you upload them they'd be the only package providing incremental parsing for parsec :)
08:17:54 <illissius> ski: yeah, I was trying to think of reasons you would *want* to do that rather than just merging them... I guess the other reason is that even without the superclass contexts you can still use the A instance to implement B and vice versa, so if I just remove the superclasses it works
08:17:57 <Saizan> afaik, at least
08:18:18 <edwardk> Saizan: true. i just needed them as an intermediate result
08:20:22 <edwardk> it is a real shame that the Parsec.Language machinery all returns LanguageDefs rather than GenLanguageDefs there is no reason it needs to do so -- it would make life a lot easier for folks using parsec over more interesting monads (like my quirky Iteratee)
08:20:27 <ski> illissius : well, one reason might be that you want to think of `A' and `B' as two logically separate, but equivalent descriptions of the same thing
08:20:54 <edwardk> Saizan: though, i must admit, i prefer attoparsec these days to parsec
08:21:00 <ski> (illissius : so you want separation for modularity, and more direct expression of what you have in mind)
08:21:04 <edwardk> i think bos hit on the right separation
08:21:27 <ski> illissius : it might be that there's more complicated examples, which can't reasonably be merged, though .. i'm not sure
08:21:41 <edwardk> and i can run all of this machinery through attoparsec just fine ;)
08:22:06 <illissius> ski: yeah, i have no idea... i was just thinking "hmm, i wonder if you can do this?" and decided to find out
08:22:06 <Cale> edwardk: Here's a weird question: why should the Input type occur in both positive and negative positions in the types of the constructors of Iteratee?
08:22:07 <Saizan> edwardk: btw, have you seen jlouis struggles with the strict appends that the incremental version does?
08:22:14 <edwardk> so in some sense most of the material in those iteratee, parsec, etc. slides is obsolete. just substitute attoparsec for most of that
08:22:31 <edwardk> Cale: you need to plump the unconsumed input forward during bind
08:22:51 <edwardk> Saizan: no, link/reference?
08:22:57 <edwardk> er plumb
08:23:03 <rajeshsr> is there any equivalent of getchar() in haskell?
08:23:07 <ski> Cale : isn't it like `s' in `State s'/`Parser s' ?
08:23:20 <rajeshsr> @hoogle IO Char
08:23:20 <lambdabot> Did you mean: :: IO Char /count=20
08:23:20 <lambdabot> System.Console.Editline.Readline getCompletionAppendCharacter :: IO (Maybe Char)
08:23:20 <lambdabot> System.Console.Editline.Readline setCompletionAppendCharacter :: Maybe Char -> IO ()
08:23:39 <ski> @type getChar
08:23:39 <lambdabot> IO Char
08:23:40 <ski> @type hgetChar
08:23:41 <lambdabot> Not in scope: `hgetChar'
08:23:44 <ski> @type hGetChar
08:23:45 <lambdabot> Not in scope: `hGetChar'
08:23:48 <ski> bah
08:24:03 <rajeshsr> ski, ha, thanks!
08:24:07 <ski> @type System.IO.hGetChar
08:24:08 <lambdabot> GHC.IOBase.Handle -> IO Char
08:24:08 <mux> @hoogle Handle -> IO Char
08:24:09 <lambdabot> System.IO hGetChar :: Handle -> IO Char
08:24:09 <lambdabot> System.IO hLookAhead :: Handle -> IO Char
08:24:09 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
08:24:16 <edwardk> hrmm i should go back and rewrite that code with attoparsec now that i think about it
08:24:21 <Saizan> edwardk: http://www.mail-archive.com/haskell-cafe@haskell.org/msg75519.html
08:25:42 <edwardk> " This means the bytestring is trimmed down most of the time, incurring a copy." -- er what? thats the whole point of bytestrings trimming off a byte doesn't cost you anything except for updating the starting index.
08:25:43 <Saizan> edwardk: it's a bit long, but the gist is that if you have a parsec like "take somefairlybigvalue" and you feed chunks that are smaller than that, attoparsec ends up doing a lot of appending
08:25:46 <rajeshsr> how do you run a computation and get its result directly? I just need Char value from getChar..
08:25:54 <edwardk> ah
08:25:54 <rajeshsr> am in  a pure function..
08:26:02 <Saizan> s/parsec/parser/
08:26:10 <edwardk> i work around that by passing around fingertrees in the iteratee right now
08:26:20 <edwardk> and slicing only on demand
08:27:42 <edwardk> "My current plan for a solution is this: Read the socket and gather up chunks for a lazy bytestring. " -- this won't help much, because as your input gets bigger you get farther and farther away from the end that you want to append to.  you get the same asymptotics, just much deferred
08:27:46 <rajeshsr> fun (do (x <- getChar; return x))
08:27:52 <rajeshsr> fun takes Char type..
08:27:59 <edwardk> the fingertree gives me O(1) snoc for appending new input
08:28:02 <rajeshsr> how am i supposed to make that
08:28:03 <rajeshsr> ?
08:28:25 <rajeshsr> or am i trying something impossible?!
08:28:33 <Berengal_> rajeshsr: That's impossible
08:28:43 <Cale> rajeshsr: You want to *run* getChar, and pass the *result* of getChar to fun
08:28:51 <rajeshsr> Cale, yep
08:29:09 <Berengal_> rajeshsr: You need to do something like "do {x <- getChar; return (fun x);}"
08:29:15 <Cale> rajeshsr: So:  do c <- getChar; doStuffWith (foo c)
08:29:35 <edwardk> Saizan: does jlouis hop on irc?
08:29:38 <Cale> (what's the full type of foo?)
08:29:42 <Cale> er, fun
08:29:52 <Saizan> edwardk: yup, fairly regularly
08:29:52 * edwardk uses /whois and finds out that is actually the case
08:30:00 <rajeshsr> fun Char someMorePureParams
08:30:00 <edwardk> preflex: xseen jlouis
08:30:00 <preflex>  jlouis was last seen on freenode/#haskell-blah 3 hours, 56 minutes and 10 seconds ago, saying: http://bit.ly/MKxTa is the context-correct link now I think
08:30:11 <rajeshsr> Cale, ^
08:30:30 <Cale> rajeshsr: fun :: Char -> ... -> What?
08:30:56 <rajeshsr> Cale, finally it is String
08:31:01 <Cale> rajeshsr: Ah, okay
08:31:07 <rajeshsr> am calling that function recursively..
08:31:10 <Cale> rajeshsr: So yeah, you'll want to do something with that String
08:31:20 <Cale> rajeshsr: Maybe print it?
08:31:29 <rajeshsr> finally yeah
08:31:32 <Cale> do c <- getChar; print (fun c)
08:31:47 <Cale> Of course, there are some more parameters, but I don't know what they are :)
08:31:48 <rajeshsr> Cale, nope!
08:32:03 <Saizan> edwardk: i thought that we could make demandInput in attoparsec actually aware of how much input is needed so it can wait until it has enough bytes before making the strict bytestring attoparsec uses for its state
08:32:17 <rajeshsr> fun c1 soimeParams = fun (getChar) someModifiedParams
08:32:23 <rajeshsr> thats hwat i want to do..
08:32:28 <rajeshsr> *what
08:32:29 <edwardk> Saizan: ah cute
08:32:33 <Cale> rajeshsr: fun doesn't take an IO action as its parameter though
08:32:40 <Cale> rajeshsr: It wants a Char
08:32:43 <rajeshsr> yeah
08:32:47 <rajeshsr> so how i do it?
08:32:49 <edwardk> Saizan: in my case i just make each append O(1) so it doesn't hurt much
08:32:52 <Cale> A Char and an IO Char are two very very different things
08:33:14 <Cale> You should think of a value of type IO Char as being like a program which you could run to produce a Char at some point.
08:33:35 <rajeshsr> Cale, yeah, i get that. In this case i need to get the Char from getChar in order to pass it to fun..
08:33:40 <Cale> yeah
08:33:44 <Cale> So, you use do-notation
08:33:49 <Saizan> edwardk: so using a rope for the state, right?
08:34:02 <rajeshsr> is there any function like runIO
08:34:03 <Cale> c <- getChar means  "run the action getChar, naming its result 'c'"
08:34:08 <rajeshsr> that will return final result?
08:34:21 <Cale> if getChar :: IO Char
08:34:24 <Cale> then c :: Char
08:34:29 <rajeshsr> yeah
08:34:34 <edwardk> Saizan: yeah
08:34:41 <rajeshsr> you mean thats enough?
08:34:45 <Cale> yes
08:34:49 <Cale> and the do-block as a whole that you're writing has type IO t for some t
08:34:53 <ski> rajeshsr : and then you get as final result for `fun' : `IO Foo'
08:34:55 <rajeshsr> fun (do (c <- getChar)) params
08:34:57 <edwardk> Saizan: though it predated my rope lib, so its just a FingerTree Count Chunk ;)
08:35:02 <Cale> no, you can't write that
08:35:14 <edwardk> where Chunk is a wrapper on bytestring and Count is the obvious monoid
08:35:21 <Cale> You can only run IO actions from inside other IO actions.
08:35:21 <rajeshsr> ski, hmm, yeah
08:35:25 <Dapemael> Hello guys
08:35:34 <MissPiggy> hello
08:35:46 <Cale> rajeshsr: This is by design.
08:35:46 <Saizan> edwardk: that'd be quite simpler, though we'd have to benchmark the overhead it introduces on the rest of the code i guess..
08:35:48 <edwardk> and i have to thread an extra bool through as part of the state, but i uncurry the tuple
08:36:05 <edwardk> *nods*
08:36:14 <rajeshsr> Cale, i get the whole point! But how am i to realize my particular use case?
08:36:14 <Cale> rajeshsr: If  getChar  was simply a Char, which Char value would it be? Might it be 'a'? But what if I don't type 'a'? :)
08:36:22 <Cale> rajeshsr: Okay :)
08:36:24 <edwardk> the main thing i've liked about it is the ability to use the 'slice' operation when building up bytestrings out of some part of the input string
08:36:52 <Cale> rajeshsr: Your program as a whole is going to be one of these IO action things -- the main action describes what the program is to do when it's run
08:36:56 <edwardk> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf slide 27
08:37:04 <Cale> rajeshsr: So you'll have something like:
08:37:28 <Cale> main = do c <- getChar; let bar = fun c someOtherStuff; print bar
08:37:40 <edwardk> Saizan: most slices are O(1) except those that straddle multiple bytestrings
08:37:49 <Cale> rajeshsr: Something like that
08:37:54 <rajeshsr> Cale, hmm, unfortunately, mine isn't all that trivial.
08:37:58 <edwardk> but the way i use them i can amortize that cost over the allocations to O(1) amortized
08:38:04 <Cale> rajeshsr: What is it that you're trying to compute?
08:38:08 <Cale> (or do)
08:38:21 <rajeshsr> i have to write a lot of recursive equation involving fun which is all pure, but only this..
08:38:26 <edwardk> since i don't overlap slices
08:39:00 <Cale> rajeshsr: You could have the input to your function come in another way. Rather than calling getChar, you could have the function take a String as input.
08:39:35 <Cale> rajeshsr: (and then at the top level, use something like the (slightly magic) getContents to read the standard input into a lazy string)
08:40:22 <ski> edwardk : .. how would you build bytestrings using a `slice' operation ?
08:40:25 <Cale> rajeshsr: Does that make sense?
08:40:35 <Cale> rajeshsr: I'm still a bit lost about what it is that your program does
08:40:36 <rajeshsr> Cale, Nope!
08:40:58 <Cale> rajeshsr: So, I can't do much more than offer random suggestions about how some programs might work :)
08:41:00 <rajeshsr> well, am implementing a brainfuck compiler, almost all is over except for ","
08:41:15 <rajeshsr> i can paste in pastebin..
08:41:17 <Saizan> edwardk: ah, that's quite nice, i thought attoparsec had a combinator like sliced too but i can't find it.
08:41:20 <Cale> rajeshsr: okay
08:41:36 <Cale> rajeshsr: let's take a look :)
08:41:47 <edwardk> ski: usually what i have is a dumb recognizing parser that doesn't extract an output, and then i use slice to cut the fingertree, where slice finds the fingertree leaf that contains the first cursor, then checks to see if the other is in the same slice, otherwise it does the necessary concatenation
08:41:56 <edwardk> Saizan: i wouldn't be surprised if it was there
08:41:59 <Cale> rajeshsr: How did you handle output? Is that what the String result is?
08:42:18 <rajeshsr> yep
08:42:21 <edwardk> Saizan: its one of my favorite things about this model, before that using parsec on bytestrings i was building up the result bytestring a char at a time and suffering terribly for it
08:42:32 <rajeshsr> anyway to highlight a line in hapste?
08:42:43 <Cale> rajeshsr: Okay, so what is the meaning of a brainfuck program abstractly? It's abstractly a function  String -> String, isn't it?
08:42:54 <Cale> rajeshsr: It takes some input, and produces some output.
08:42:59 <rajeshsr> yep
08:43:20 <Cale> rajeshsr: So rather than calling getChar randomly, you could just have a String parameter which you pattern match on.
08:43:36 <aavogt> edwardk: is it possible to write a `fmap' function for a cps'd existential?
08:43:42 <rajeshsr> Cale, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25792#a25792
08:43:54 <Saizan> edwardk: ah, it seems it disappeared in 0.8 when bos dropped the non-incremental interface
08:43:58 <rajeshsr> nope, am not getting the code with getChar
08:44:10 <rajeshsr> am trying to get the input for brainfuck code with that
08:44:43 <edwardk> aavogt: can you give the type of what you mean?
08:44:55 <Cale> rajeshsr: I'm saying that you should have a String parameter to 'execute' which represents the input that the program has been given.
08:44:57 <aavogt> such that the applied function looks like:  (C a *> a) -> t (C a *> a), where that t is also an instance of C
08:45:12 <Cale> rajeshsr: Think of it as all the keystrokes which the user typed.
08:45:22 <rajeshsr> Cale, it is not necessary for a program to have input..
08:45:23 <Cale> (as that is what it will be)
08:45:33 <Cale> rajeshsr: That's fine, the input can be empty in that case.
08:45:43 <Cale> rajeshsr: (Or it won't matter what it is)
08:45:53 <rajeshsr> Cale, hmm, ok!
08:45:54 <Cale> rajeshsr: At the top-level of your program, you'll use getContents to read the standard input lazily.
08:45:55 <edwardk> aavogt: not yet parsing what C a *> a means ;)
08:45:55 <aavogt> I'm not sure how to type is so that the result type may name the argument type which isn't known exactly
08:45:57 <rajeshsr> i think i get it!
08:46:08 <Cale> rajeshsr: and then pass the resulting magical String to execute
08:46:09 <aavogt> it's notation from ski
08:46:20 <rajeshsr> so, what about my use case? this is the only way?
08:46:31 <aavogt> supposedly,   exists a with  C a
08:46:38 <edwardk> aavogt: my first thought was that you meant something like newtype YId a = YId (forall r. (a -> r) -> r)
08:46:40 <Cale> Well, there are other ways. You could make execute produce an IO String instead
08:46:59 <Cale> Or go further and make it IO ()
08:47:00 <aavogt> edwardk: if you switch the a and r around...
08:47:14 <Cale> (printing the output of the bf program directly)
08:47:35 <edwardk> aavogt: hrmm this is sounding like some previous ski-isms. let me chew on it for a second
08:47:38 <IRC_STINKS> what's wrong here > http://codepad.org/nahabzZV , and why it works with Int instead of Integer?
08:47:42 <aavogt> so it's not really fmap since it doesn't touch any explicitly known type parameters
08:47:45 <edwardk> i think you're screwed
08:48:06 <Cale> IRC_STINKS: Because replicateM is defined to take an Int parameter, unfortunately.
08:48:07 <aavogt> so     T r = T ((forall a. C a => a -> r) -> r)
08:48:10 <edwardk> if you don't know the type you can't really change it, or rather it is invisible to anyone that you did
08:48:14 <rajeshsr> Cale, hmm, ok!
08:48:17 <edwardk> what is C a ?
08:48:22 <aavogt> it's a class
08:48:32 <rajeshsr> so, thats the reason we have Pure Vs Impure separability in Haskell!
08:48:38 <rajeshsr> and we could never break it
08:48:45 <Cale> IRC_STINKS: you can use fromIntegral to convert between Integer and Int (in either direction)
08:48:53 <edwardk> aavogt: well, a real fmap on that isn't possible, because 'r' occurs in both positive and negative position
08:49:06 <rajeshsr> @hoogle IO a -> a
08:49:06 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:49:06 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
08:49:06 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
08:49:18 <Cale> rajeshsr: Yeah, you can't execute IO actions in the middle of evaluating an arbitrary expression.
08:49:20 <aavogt> edwardk: forget about what I said about this operation being like fmap
08:49:33 <IRC_STINKS> how frustrating :(
08:49:34 <aavogt> the idea is to change the a
08:49:37 <Cale> rajeshsr: Evaluating expressions just reduces them to values, and can't do anything else.
08:49:41 <edwardk> and swapping 'a's internally would have to be some operation provided by C
08:49:56 <rajeshsr> Cale, hmm, ok!
08:49:58 <rajeshsr> thanks
08:50:17 <edwardk> since that is all you know about 'a' is that it gives you access to that typeclass
08:50:22 <aavogt> so have some function   (a -> a') -> T r -> T r, where a' contains the parameter a, but is still an instance of C
08:50:45 <ski> aavogt : CPS:ed existential being what, here ?
08:50:58 <aavogt> ski: T r = T ((forall a. C a => a -> r) -> r)
08:50:59 <edwardk> the problem is you don't know that you're applying the function to a T that contains 'a'
08:51:22 <Saizan> aavogt: you can make a "foo :: (forall a. C a => a -> exists b. C b *> b) -> T r -> T r" if you want, i think
08:51:24 <edwardk> so you're at best stuck with playing silly games with Typeable to even know if you _can_ apply that function
08:51:57 <Cale> rajeshsr: Another option which might make sense for the meaning of a BF program is: (String -> String) -> (String -> String), where you consider the function parameter there to be "the rest of the program", if that makes sense.
08:52:32 <aavogt> edwardk: my function works for all 'a' because there's an instance for that. Say  C  is Monoid and my function is   Dual
08:52:59 <Cale> rajeshsr: That is, treat each little piece of a BF program as a function which transforms the meaning of the program to come, in some way :)
08:53:30 <rajeshsr> Cale, hmm, you may need to move through the program more than once because of []
08:53:56 <edwardk> aavogt: then you'd need something like a function of the form. C a' => (forall a. C a => a -> a') -> T r -> T r
08:54:18 <ski> edwardk : `(C a *>)' is the right adjoint to `(C a =>)', roughly ;)
08:54:31 <edwardk> ski: i have yet to parse your C a *> ;)
08:54:37 <aavogt> edwardk: a' contains the type variable a though
08:54:58 * aavogt tries saizan's suggestion
08:55:13 <edwardk> aavogt: ah then you need an existential box around the a' there
08:55:20 <edwardk> which happens to contain the C as well
08:55:22 <Saizan> my suggestion can be written as "(forall a. C a => a -> T r) -> T r -> T r" if that helps
08:55:32 <ski> edwardk : in ther dictionary-passing-translation, `C a => Foo a' gets translated to `CDict a -> Foo a', while `C a *> Foo a' gets translated to `(CDict a,Foo a)' (or maybe with an unboxed pair type)
08:55:34 <Saizan> afaict
08:55:45 <aavogt> sort of like bind...
08:55:46 <edwardk> ski: _that_ makes sense =)
08:56:44 <ski> edwardk : i've introduced this pseudo-syntax to be able to make the distinction between e.g. `forall a. C a => Foo a -> exists b. D a b => Bar a b' and  `forall a. C a => Foo a -> exists b. D a b *> Bar a b'
08:57:03 <rajeshsr> @hoogle Int -> Char
08:57:03 <lambdabot> Data.Char chr :: Int -> Char
08:57:03 <lambdabot> Data.Char intToDigit :: Int -> Char
08:57:03 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
08:57:22 <rajeshsr> @hoogle Char -> Int
08:57:22 <lambdabot> Data.Char digitToInt :: Char -> Int
08:57:22 <lambdabot> Data.Char ord :: Char -> Int
08:57:22 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
08:57:47 <Twinside> hi, does anyone know how to output UTF-8 string from haskell into the terminal? I got it to work on Linux but nothing under Mac OS (with terminal configured as UTF-8 in preferences)
08:59:03 <IRC_STINKS> how to convert Int -> Integer ?
08:59:09 <Cale> IRC_STINKS: fromIntegral
08:59:22 <Saizan> Twinside: ghc version?
08:59:28 <Twinside> 6.12.1
08:59:49 <Twinside> the one in the haskell platform for Mac OS
08:59:53 <IRC_STINKS> Cale: i think it does the reverse
08:59:58 <Saizan> Twinside: is your locale using utf-8 on mac os? if so it should work out of the box
09:00:01 <Cale> IRC_STINKS: It does both
09:00:10 <Saizan> Twinside: however i think you can hSetEncoding on stdout
09:00:23 <Cale> IRC_STINKS: It's polymorphic, and converts any integer-like number to any sort of number at all.
09:00:33 <Saizan> Twinside: assuming you've proper unicode codepoints in your String
09:01:04 <Cale> > fromIntegral (5 :: Int) :: Integer
09:01:05 <lambdabot>   5
09:01:05 * ski idly wonders whether `T' would support an `ExpFunctor'
09:01:08 <Cale> > fromIntegral (5 :: Int) :: Float
09:01:10 <lambdabot>   5.0
09:01:13 <Cale> > fromIntegral (5 :: Int) :: Complex Double
09:01:15 <Twinside> hmm yeah I got valid unicode
09:01:15 <lambdabot>   5.0 :+ 0.0
09:01:20 <Cale> > fromIntegral (5 :: Integer) :: Int
09:01:21 <lambdabot>   5
09:01:26 <Cale> > fromIntegral (5 :: Integer) :: Word8
09:01:27 <lambdabot>   5
09:01:34 <Cale> > fromIntegral (5 :: Integer) :: Double
09:01:34 <Twinside> where can I find hSetEncoding function ? hoogle doesn't help me on this
09:01:35 <lambdabot>   5.0
09:01:42 <monochrom> > unsafeCoerce (5::Int) :: Double
09:01:42 <lambdabot>   Not in scope: `unsafeCoerce'
09:01:48 <Cale> > fromIntegral (5 :: Word8) :: Integer
09:01:49 <lambdabot>   5
09:02:34 <Twinside> ah got it in GHC.IO.Handle
09:02:47 <Saizan> Twinside: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#v%3AhSetEncoding
09:02:59 <Saizan> Twinside: it's more appropriate to import it from System.IO
09:03:33 <Saizan> s/appropriate/portable/
09:04:03 <ski> (Saizan,aavogt : btw, you could use `forall a. C a => a -> a' if you wanted, since you can reach `forall a. C a => a -> exists b. C b *> b' from that)
09:04:46 <Saizan> ski: i think the idea is that the type changes
09:05:06 <Saizan> *needs to change
09:05:08 <rajeshsr> has anyone worked with brainfuck? what is the intended behavior when you see the command "<" in the first cell itself?
09:05:16 <rajeshsr> remain in the cell?
09:05:35 <rajeshsr> my code breaks for brainfuck quine, i suspect that such a behavior may be expected..
09:05:40 <ski> hm
09:05:41 <xerox> segmentation fault
09:06:04 <rajeshsr> xerox, ha, ok!
09:06:13 * ski for a while thought that aavogt only needed to be able to change the value, but not the type ..
09:06:17 <edwardk> rajeshsr: either crash, extend the tape, or remain in the cell i'm not sure its defined
09:06:35 <Cale> rajeshsr: I think it's implementation dependent
09:06:36 <rajeshsr> edwardk, hmm, ok!
09:06:37 <RyanT5000> rajeshsr: one other option - wrap around?
09:06:38 <ski> @help bf
09:06:38 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
09:06:43 <RyanT5000> the memory is of defined length, iirc
09:06:48 <RyanT5000> (30000 bytes?)
09:06:53 <rajeshsr> oh, ok
09:06:55 <ski> @bf <
09:06:56 <lambdabot>  Done.
09:07:09 <edwardk> The brainfuck language uses a simple machine model consisting of the program and instruction pointer, as well as an array of at least 30,000¬†byte¬†cells initialized to zero. They don't seem to specify the corner cases
09:08:03 <Cale> rajeshsr: Of course, since this is Haskell, you can have the memory be doubly infinite
09:08:18 <rajeshsr> Cale, yeah, thats what am having!
09:08:52 <edwardk> the easy solution is to implement the tape as data Tape a = Tape [a] [a]
09:09:01 <monochrom> we need to design another hoax language called braindamage
09:09:03 <Twinside> hmm hSetEncoding doesn't seem to work
09:09:36 <rajeshsr> edwardk, i use ([a], a, [a])
09:09:37 <RyanT5000> edwardk: perhaps slightly more intuitive as data Tape a = Tape [a] a [a]
09:09:47 <chrisdone> does anyone here understand intel's concurrent collections library?
09:09:49 <edwardk> RyanT5000: that works fine too
09:14:06 <rajeshsr> if anyone has a brainfuck implementation that uses infinite tapes without wrap around, can you tell me what is the output you get? http://pastebin.com/VEscB74b
09:14:21 <rajeshsr> it goes infinitely for me!
09:14:42 <rajeshsr> printing lots of +s, occassionally, some other characters..
09:17:48 <geheimdienst> i'd like the current time with sub-second precision. is it correct that getZonedTime will do that for me, but not getCurrentTime? or am i doing it wrong?
09:20:27 <int-e> rajeshsr: it relies on integer overflow, i.e. +[+] terminating
09:20:45 <rajeshsr> int-e, yeah, i use Word8
09:22:14 <int-e> anyway it works as a quine for me. (my tape is not infinite but definitely doesn't wrap around)
09:24:02 * ski thinks a brainfuck implementation that uses infinite tapes *with* wrap around would be (a little bit) harder to implement
09:24:42 <ski> (well, i suppose not if you use an array)
09:25:06 * ski ponders something BF like that executs on a possibly cyclic graph of memory ..
09:25:08 <Taggnostr> is haskell static typed?
09:25:11 <ski> yes
09:26:13 <rajeshsr> can you do breakpoint and all as you do in gdb?
09:26:29 <rajeshsr> i want to see where my code gets to infinite loop?
09:26:39 <rajeshsr> any tutorial on debugging?
09:26:45 <Taggnostr> so the term 'static' doesn't necessary implies that the type of a var has to be specified (like int x = 10;), right?
09:27:27 <rajeshsr> Taggnostr, nope
09:27:47 <geheimdienst> usually the compiler infers the types. you don't have to specify them
09:27:50 <rajeshsr> i mean you don't need to specify type names
09:28:01 <aavogt> @hoogle (* -> *) -> (* -> *) -> (* -> *)
09:28:02 <lambdabot> Parse error:
09:28:02 <lambdabot>   --count=20 "(* -> *) -> (* -> *) -> (* -> *)"
09:28:02 <lambdabot>                 ^
09:28:10 <rajeshsr> it is just that the type of a variable can't change..
09:28:15 <aavogt> is there a higher kinded version of *?
09:28:19 <aavogt> err, tuple
09:28:21 <Taggnostr> so it's static because it checks the types at compile time, before actually running the program, right?
09:28:25 <c_wraith> you can't hoogle based on kind signatures?
09:28:38 <rajeshsr> any help on finding where my code goes to infinite loop? how to use debugger?
09:29:38 * geheimdienst is creeped out by the whole kind thing. what is a kind and what does it do anyway?
09:29:54 <c_wraith> a kind is basically the type of a type.
09:29:59 * geheimdienst maybe doesn't really want to know, for fear of overloading his brain
09:30:15 <c_wraith> a concrete type has (usually) the kind *
09:30:33 <c_wraith> A type constructor, like Maybe, has kind (* -> *)
09:30:54 <c_wraith> So that when you apply it to a type, like..  Maybe Int..  You get something with kind *
09:30:55 <geheimdienst> taggnostr, yes, types are checked by the haskell compiler. my experience is that it's hard to get anything to compile, but when it does, it seldom has any bugs anymore
09:31:16 <c_wraith> It's really not a complicate idea, when you think of it that way.
09:31:32 <Taggnostr> geheimdienst, you mean, bugs related to the types
09:31:53 <aavogt> ah well, I suppose I just need     newtype And f g a = And (f a, g a)
09:31:58 <geheimdienst> you mean, Maybe has kind * -> * because it takes a type (Int or whatever) and gives you a type (Maybe Int)?
09:32:08 <aavogt> but this isn't common enough to be in a library somewhere?
09:32:16 <c_wraith> geheimdienst, exactly
09:32:39 <MacMagnus> how do i typecast a string/char to a number?
09:33:13 * geheimdienst laughs madly that he now is an expert on kindedness. one step closer to world domination.
09:33:22 <Olathe> > ord 'a'
09:33:23 <lambdabot>   97
09:33:40 <c_wraith> > read "55" :: Int
09:33:41 <lambdabot>   55
09:33:42 <aavogt> @quote type.*kind
09:33:42 <lambdabot> GentleIntro says: If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
09:34:01 <MacMagnus> :D thanls
09:34:20 <Olathe> You're welcome.
09:34:21 <geheimdienst> thanks lambdabot, that certainly clears it up
09:34:33 <c_wraith> kinds can get complicated, though
09:34:37 <c_wraith> @kind RWST
09:34:39 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:34:46 <geheimdienst> taggnostr, yes, however the type system is so fine-grained that it really catches lots of bugs for you
09:35:43 <geheimdienst> well that takes three types and a functionish thing that transforms a type into a type, and takes another type, and gives you a type
09:35:51 <aavogt> Taggnostr: kinds aren't very specific... they mostly ensure that you apply the right number of arguments
09:36:04 <aavogt> which take the right number of arguments
09:36:32 <aavogt> so there's not much there to help with anything except maybe some typos
09:36:35 * geheimdienst thinks anything with more than 3 stars in it is just there to scare off newbs and keep haskell leet
09:37:09 <Taggnostr> indeed it looks quite scary
09:37:10 <c_wraith> geheimdienst, yep.  it's the reader/writer/state monad transformer.  It takes a type to read, a type to write, a type for the state, a type for the monad (which is the higher-kinded one), a type for the value computed by the monad, and returns the concrete type
09:37:17 <Taggnostr> anyway, thanks for the help
09:37:34 <aavogt> @unmtl RWST r w s IO a
09:37:35 <lambdabot> r -> s -> IO (a, s, w)
09:38:00 <Saizan> aavogt: i've seen your And defined multiple times but usually named :*:
09:38:31 <c_wraith> Now, for the strange case in kind rules
09:38:36 <c_wraith> @kind (->)
09:38:37 <lambdabot> ?? -> ? -> *
09:38:50 <aavogt> those aren't interesting, c_wraith
09:39:03 <geheimdienst> lambdabot: stop confusing me and cut the question marks
09:39:53 <c_wraith> practically, they aren't interesting.  you can just pretend it means * -> * -> *
09:40:12 <geheimdienst> does (->) stand for functions?
09:40:16 <c_wraith> yes.
09:40:24 <geheimdienst> so that's no special type thing
09:40:49 <Saizan> rajeshsr: i get "BrainFuck: Prelude.chr: bad argument: (-1)" which that input
09:41:09 <geheimdienst> why is a function something that takes a ?? and a ?. i think it's perfectly possible to have unary functions
09:41:13 <Saizan> (maybe decrementing 0 should keep it 0?)
09:41:18 <rajeshsr> Saizan, you mean with your implementation?
09:41:25 <Saizan> rajeshsr: yup
09:41:32 <rajeshsr> hmm, ok
09:41:33 <aavogt> geheimdienst: because ?? and ? are more or less the same as * except something to do with unboxed things
09:41:45 <rajeshsr> Saizan, i think from 0 it should get to 255
09:41:51 <c_wraith> geheimdienst, the ?? is the argument type, the ? is the return type.  the * is the type of the function
09:41:55 <rajeshsr> use Word8
09:42:07 <int-e> Saizan: are you using an array of chars?
09:42:11 <aavogt> whic aren't terribly interesting if performance doesn't matter
09:42:43 <Saizan> int-e, rajeshsr: i was using Int, thanks :)
09:43:13 <geheimdienst> okay ... i guess the notation with two times "->" is a little weird, but then, i wouldn't be in here if i had a problem with weirdness
09:43:21 <int-e> Saizan: the program expects -+ to result in 0, and for addition to wrap around eventually, but it shouldn't try to print a -1 as far as I can make out
09:44:26 <int-e> Saizan: which makes me wonder why your implementation encounters chr -1 at all
09:45:39 <Saizan> int-e: i've written this some time ago and in a quite baroque style, so i don't know either :)
09:46:57 <Olathe> Saizan: Some BF implementations use -1 as an input for EOF.
09:47:01 <Saizan> http://code.haskell.org/~Saizan/BrainFuck.hs <- for the curious, needs ListZipper, MonadPrompt, MaybeT
09:47:05 <rajeshsr> @hoogle any
09:47:05 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
09:47:06 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
09:47:06 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
09:47:39 <rajeshsr> is there a function equivalent to: head . (dropWhile f)
09:47:40 <rajeshsr> ?
09:47:51 <rajeshsr> like any, but returns the first element..
09:48:02 <rajeshsr> or Maybe a
09:48:16 <rajeshsr> so that returns Nothing when none satisfies?
09:48:45 <aavogt> rajeshsr: find (not . f)
09:48:55 <aavogt> @type ifnd
09:48:56 <lambdabot> Not in scope: `ifnd'
09:48:57 <aavogt> @type find
09:48:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:49:14 <rajeshsr> aavogt, cool!
09:49:21 <rajeshsr> thanks
09:49:30 <int-e> @type \f -> listToMaybe . dropWhile f
09:49:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:49:53 <int-e> @type find . (not .)
09:49:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:50:17 <aavogt> @check \bs -> (listToMaybe . dropWhile id) bs == find not bs
09:50:18 <lambdabot>   "OK, passed 500 tests."
09:52:36 <Polarina> How fast is an IORef?
09:53:09 <byorgey> about 35 m/s
09:53:18 <aavogt> c
09:53:19 <Polarina> lol
09:53:30 <jkingkong> is that meters/second?
09:54:12 <c_wraith> Polarina, it's updating a mutable reference.  The update should be like one instruction.
09:54:34 <c_wraith> Computing the new value to put in it is always going to be more expensive
09:55:52 <Polarina> c_wraith, is the performance comparable to something like a pointer in C?
09:56:25 <ski> c_wraith : probably you can put in the new value, before it has been computed
09:56:43 <gwern> c_wraith: there could be all sorts of checks going on and funny business with the stack or registers
09:56:50 <gwern> so I wouldn't assume anything about the speed
10:00:39 <Saizan> Polarina: i think so, but since these are boxed values there's typically one more indirection
10:01:14 <Polarina> Indirection?
10:01:22 <aavogt> more pointers
10:01:42 <Polarina> sometype **name;
10:01:46 <Polarina> Like that?
10:02:34 <Saizan> i guess so
10:02:43 <Polarina> All right, thanks. :)
10:06:31 <geheimdienst> > mod' 4.2 1
10:06:32 <lambdabot>   0.20000000000000018
10:07:00 <geheimdienst> that's the right way to extract the part after the decimal, right?
10:07:02 <geheimdienst> > mod 4.2 1
10:07:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:07:04 <lambdabot>    `GHC.Real.Integral a'
10:07:04 <lambdabot>   ...
10:07:17 <geheimdienst> > mod' 0.8 1
10:07:18 <lambdabot>   0.8
10:07:28 <Saizan> ?type properFraction
10:07:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
10:07:41 <Saizan> > properFraction 0.8
10:07:42 <lambdabot>   (0,0.8)
10:08:08 <geheimdienst> properFraction 4.2
10:08:10 <geheimdienst> > properFraction 4.2
10:08:11 <lambdabot>   (4,0.20000000000000018)
10:08:20 <geheimdienst> > properFraction (4.2::Pico)
10:08:21 <lambdabot>   (4,0.200000000000)
10:08:25 <geheimdienst> woah!
10:08:29 <geheimdienst> thanks saizan
10:08:35 <Saizan> np
10:09:58 <earthy> damn, haskell performance can be puzzling
10:10:31 <earthy> writeFile . Binary.encode . parse . readFile   runs in constant space
10:10:33 <earthy> however,
10:10:52 <ski> @type Data.IORef.newIORef 2#
10:10:53 <lambdabot>     Couldn't match kind `#' against `*'
10:10:53 <lambdabot>     When matching the kinds of `GHC.Prim.Int# :: #' and `a :: *'
10:10:53 <lambdabot>       Expected type: a
10:11:05 <babusri> http://hackage.haskell.org/package/ghc-core says usage is "ghc-core -fvia-C -optc-O3 A.hs". But ghc-core says "ghc-core: user error (unrecognized option `--fvia-C'"
10:11:35 <wvd> Why is == in the Eq typeclass defined as (==) = a -> a -> Bool, instead of == = a -> a -> Bool?
10:11:54 <earthy> putting Put into an RWST makes memory usage explode
10:12:07 <gwern> babusri: maybe look at how ghc-core expects ghc options
10:12:15 <ski> wvd : first, it is `::', not `='
10:12:18 <earthy> even if one uses RWST () () Word64 PutM
10:12:22 <earthy> *boggle*
10:12:29 <gwern> babusri: obviously ghc-core is doing something with the args since you gave it -fvia-c and it complains about --fvia-c
10:12:30 <c_wraith> earthy, that's probably lazy state exploding.  I believe RWST uses lazy state by default
10:12:38 <ski> wvd : second, `==' by itself is an infix operator, that expects an expression to the left and to the right
10:12:54 <wvd> ski: yes.
10:12:57 <earthy> c_wraith: Control.Monad.RWST.Strict still gobbles up 15 times the size of the input
10:13:02 <ski> wvd : while wrapping it in brackets like `(==)' converts it into a normal expression, just like `length'
10:13:05 <ski> @type length
10:13:06 <lambdabot> forall a. [a] -> Int
10:13:07 <wvd> ski: ah, so + is also defined as (+)?
10:13:10 <ski> > length [12,3]
10:13:11 <lambdabot>   2
10:13:15 <ski> > 12 + 3
10:13:16 <lambdabot>   15
10:13:19 <ski> > (+) 12 3
10:13:20 <lambdabot>   15
10:13:22 <ski> @type (+)
10:13:22 <earthy> so, where's the lazy state explosion?
10:13:23 <lambdabot> forall a. (Num a) => a -> a -> a
10:13:24 <ski> @type +
10:13:25 <lambdabot> parse error on input `+'
10:13:36 <ski> wvd : ^ hopefully that clarifies it
10:13:42 <earthy> shouldn't exist with RWST.Strict, right?
10:13:48 <ski> > zipWith (+) [12,3] [100,300]
10:13:48 <lambdabot>   [112,303]
10:13:56 <c_wraith> earthy, yeah, it shouldn't
10:14:00 <wvd> ski: So all infix functions are defined using their prefix form?
10:14:14 <wvd> (in typeclasses)
10:14:16 <ski> wvd : you don't need to define it in prefix form (but you can)
10:14:26 <earthy> (with lazy RWST it blows up even worse)
10:14:32 <Saizan> c_wraith, earthy: well, there could still be.
10:14:38 <earthy> so, puzzling. ;)
10:14:38 <ski> wvd : but you need to give the type signatures in prefix form (since you need to give an expression to the left of `::')
10:14:50 <wvd> ski: ah right, thanks.
10:14:57 <earthy> saizan: *how*, given () for reader and writer and Word64 for state?
10:15:20 <ski> wvd : you can define `(==)' on `Bool' either like `(==) True True = True; ...' or like `True == True = True; ...', whichever you prefer
10:15:33 <Saizan> earthy: btw, run with +RTS -hT so we know the type of the space leak
10:15:38 <gwern> 2,3 CA proved universal? http://blog.wolfram.com/2007/10/24/the-prize-is-won-the-simplest-universal-turing-machine-is-proved/
10:15:42 <gwern> pretty neat
10:15:48 <wvd> ski: I know, i've been reading that on LYAH, but was just wondering why they used the prefix form of ==.
10:16:01 <earthy> saizan: I ran with -hc, but I'll rerun with -hd
10:16:17 <ski> wvd : but since you don't mention the arguments in the type signature, there's no way to write it infix there, so you need to "convert it to an expression", to make the syntax checker happy
10:16:26 <babusri> gwern: I am givingthe same command that is mentioned in the doc except instead of A.hs I am giving my file name
10:16:46 <earthy> (I'ven been profiling this to bits for the last week or so... I can improve by a factor of oh... 4 or so by coding it in continuation passing style, but even then that's too much...)
10:17:02 <Saizan> earthy: anyhow, strict RWST is only strict in the tuple holding the state and the rest, not in the state itself, so you might still need some strictness annotations in your code
10:17:15 * earthy nods
10:17:55 <c_wraith> Oh, right.  It's just strict in the tuple in >>=
10:18:25 <earthy> so I'd need to make the state stricter.
10:19:19 <c_wraith> Not necessarily just the state.  Depending on how well strictness analysis managed, it might be building up () `mappend` () `mappend` ... thunks
10:19:46 <gwern> babusri: what happens without the optc?
10:19:56 <earthy> c_wraith: I suspect it is.
10:20:11 <earthy> and I suspect that makes it hold on to a *lot* of the input as well
10:20:22 <earthy> (basically, the entire input)
10:20:40 <c_wraith> that would explain the memory use you see, at least
10:21:19 <c_wraith> It would be sad if it is building up thunks in the writer.  mappend for () is...  not very interesting. :)
10:21:24 <Saizan> modify' f = do s <- get; put $! f s -- useful in these cases
10:21:30 <c_wraith> > undefined `mappend` undefined :: ()
10:21:31 <lambdabot>   ()
10:21:46 <gwern> babusri: I ask because the ghc-core specifically checkes for -fvia-C and I wonder why there's any problem
10:21:51 <gwern> *source
10:21:53 <Saizan> but yeah, i think the writer part in RWST is known to cause problems
10:22:14 <earthy> c_wraith: I want it to do mappend for Data.Trie (Data.Set Word64)
10:22:17 <ski> Saizan : something `evaluate'-like needed ?
10:22:30 <earthy> but yeah.
10:23:15 <Saizan> CPSiszing at least the Writer part should remove the need to mappend the empty's
10:23:44 <earthy> but I'm testing with () just to get the same algorithmic behaviour, which should imply same time behaviour.
10:23:51 <ski> c_wraith : *expasperated gasp* bbbut, that's *wrong* !
10:24:20 <babusri> gwern: It works only if I give no options.
10:24:36 <earthy> hm. there's a thought. CPS-ing just the writer. might try that later.
10:24:45 <gwern> babusri: even the example in the source, 'ghc-core -fvia-C zipwith' doesn't work?
10:25:04 <Saizan> babusri: you've to put "--" to separate options to ghc-core from options to ghc
10:25:19 <babusri> gwern: Usage: ghc-core [OPTION...] [--] [GHC_OPTION...] [files...]
10:25:24 <sioraiocht> did someone ping me a while ago? IRC says so but my scrollback was set too low
10:25:29 <Saizan> babusri: so ghc-core -- -fvia-C Foo.hs
10:25:32 <earthy> stg_ap_2_upd_info, PS, <main:Phasar.Index.Stored.sat_s1Lk>, PairS and (,,) are the top memory users.
10:25:58 <gwern> Saizan: really? so the source is wrong then
10:26:40 <Saizan> (,,) is probably from RWST?
10:26:47 <babusri> gwen: That works. http://hackage.haskell.org/package/ghc-core should be updated.
10:26:54 <earthy> Saizan: probably.
10:27:27 <int-e> sioraiocht: no ping. ivanm and edwardk talked about you, in relation to ropes
10:27:30 <Saizan> that "sat" thing makes me think of a typeclass dictionary, but i'm not sure why
10:27:32 <gwern> babusri: yeah, I guess I'll send dons a patch
10:27:39 <sioraiocht> int-e: cheers =)
10:27:53 <babusri> ok. Thanks.
10:28:11 <earthy> saizan: there's a bunch of 'm, so that might be not that bad of a guess.
10:28:18 <earthy> anyway, trying to strictify
10:28:23 <earthy> state and writer
10:31:05 <gwern> hm. dons is at dons@galois.com these days right?
10:31:09 <gwern> ghc-core's cabal fails to say
10:31:29 <monochrom> yes
10:31:49 <monochrom> err, I don't know about the "dons@" part
10:32:01 <gwern> too late. I'll find out soon enough
10:36:03 <deech> Hi all, I ma
10:36:05 <deech> Sorry
10:36:14 <xerox> np
10:36:17 <Silvah> Hi.
10:36:32 <deech> Hi all, I am trying to understand existentially qualified types.
10:36:57 <deech> I have the following function: myList2 :: Show a => (forall a . (Show a) => a -> String) -> [a] -> [String]
10:36:57 <deech> myList2 f = map f
10:37:28 <deech> Why can't I feed it a heterogenous list like : [1,"hello"]? They are both instances of Show.
10:37:44 <earthy> hm. that didn't really help.
10:37:45 <mauke> because the type says it needs a homogenous list
10:37:47 <mauke> [a]
10:38:01 <earthy> obviously I don't understand what I'm doing.
10:38:39 <deech> But doesn't the type constraint Show a mean, any a as long as it can be shown?
10:38:52 <ski> deech : a heterogenous list here would be something of type `[exists a. Show a *> a]' .. i.e. each element could have a different type `a'
10:38:56 <byorgey> deech: yes, but the type a is chosen once and for all for the entire list
10:39:09 <BONUS> yeah, but when you have a type [a], it meens for the entire list
10:39:09 <Silvah> Yup, but list is still homowhatever.
10:39:16 <ski> deech : but you can't express `[exists a. Show a *> a]' directly in Haskell (yet, at least), you need to create a wrapper type
10:39:32 <BONUS> also it's good if you rename the inner a type variable
10:39:39 <geheimdienst> @src *>
10:39:40 <lambdabot> (*>) = liftA2 (const id)
10:39:45 <BONUS> so you don't get the inner quantified "a" and the outer one confused
10:39:49 <ski> deech : like, `data Showable = forall a. Show a => MkShowable a', and then you can say `[Showable]', instead
10:40:03 <deech> ski: Yes I got it working my wrapping it in a test type: data Test = forall a . Show a => Test a
10:40:12 <byorgey> then  [MkShowable 1, MkShowable "hello"] :: [Showable]
10:40:20 <geheimdienst> what is this (*>) of which i hear
10:40:31 <byorgey> geheimdienst: I think ski meant =>
10:40:31 <ski> deech : yes, that's the way to do it (well, you could CPS-encode it as well, that's the other approach i know about)
10:40:36 <ski> byorgey : no
10:40:44 <deech> When I did that I had to explicitly write a Show instance. Why doesn't deriving work?
10:40:57 <byorgey> ski: oh, making up new syntax?
10:41:07 <geheimdienst> @src *>
10:41:08 <ski> geheimdienst : `.. -> ..' is to `(.. , ..)' like `.. => ..' is to `.. *> ..'
10:41:08 <lambdabot> (*>) = liftA2 (const id)
10:41:09 <ski> iow
10:41:27 <ski> <ski> edwardk : in ther dictionary-passing-translation, `C a => Foo a' gets translated to `CDict a -> Foo a', while `C a *> Foo a' gets translated to `(CDict a,Foo a)' (or maybe with an unboxed pair type)
10:41:47 <byorgey> ski: oh, I see.
10:42:24 <byorgey> geheimdienst: ski's *> is not real Haskell (not yet at least)
10:42:29 <ski> byorgey : i invented that one some while ago, now, to be able to e.g. make the distinction between `forall a. C a => Foo a -> exists b. D a b => Bar a b' and `forall a. C a => Foo a -> exists b. D a b *> Bar a b'
10:42:31 <Silvah> @src Int abs
10:42:31 <lambdabot> Source not found. Just try something else.
10:42:39 <byorgey> and it has nothing to do with the *> in Control.Applicative
10:42:47 <ski> byorgey : right, (just as `exists a. ..a..' is not real haskell (yet))
10:43:18 <ski> byorgey : *nod*
10:43:30 <Saizan> btw => is a fat -> but *> is not really a fat (,) or * :P
10:43:43 <byorgey> ski: hmm, what's the difference between those two types?
10:43:46 <ski> (if you have a better concrete syntax suggestion than `*>', i'm all ears)
10:43:54 <byorgey> I'm not sure I understand either one =)
10:44:33 <byorgey> ok, no, I understand the first one
10:44:46 <ski> byorgey: the former returns `Bar a b' for some unknown type `b', provided that *you* give an instance `D a b' (which you probably can only do if you have an instance `D a b' for all `b', for some specific `a')
10:44:53 <soupdragon> -=>
10:45:16 <ski> byorgey : the latter returns `Bar a b' for some unknown type `b', and *gives/constructs* to you an instance `D a b'
10:45:19 <byorgey> ski: aha, whereas the latter packages up a D a b  dictionary along with the Bar a b?
10:45:22 <byorgey> right.
10:45:38 <byorgey> ski: cool, got it.
10:46:10 <ski> Saizan : well, if you have a better concrete syntax, i'm all ears ;)
10:46:56 <byorgey> maybe ;  ?
10:47:10 <byorgey> exists b. (D a b; Bar a b)
10:47:19 <byorgey> I dunno
10:47:29 <Silvah> Nooooo!
10:47:38 <Silvah> No semicolons please!
10:47:48 <byorgey> what's wrong with semicolons?
10:47:53 * ski thinks `;' would probably not be that good, considering it's implicit in layout
10:48:06 <ski> (though maybe that's what you intended ?)
10:48:11 <byorgey> yeah, my thought was that since this only shows up in types...
10:48:15 <byorgey> but I agree it's probably not that good
10:48:23 <byorgey> how about unicode snowman
10:48:30 <ski> (soupdragon : is that a suggested replacement for `*>' ?)
10:48:30 <Silvah> For instance, what ski said.
10:48:38 <soupdragon> no
10:48:48 <ski> ok
10:48:58 <soupdragon> &
10:49:18 <byorgey> hm, & could work
10:50:41 <ski> i suppose (though for some reason, i'd prefer something that better expresses the "assymetry" of the left-hand-side being a constraint, while the right-hand-side being a type)
10:50:53 <ski> (hm .. maybe `|&' ?)
10:50:54 * geheimdienst thinks ",," because "->" is to "," as "=>" is to ",,"
10:51:09 <Cale> preflex: seen rajeshsr
10:51:10 <preflex>  rajeshsr was last seen on #haskell 1 hour, 1 minute and 48 seconds ago, saying: thanks
10:51:18 <soupdragon> geheimdienst: ;
10:51:22 <soupdragon> geheimdienst: (x;y)
10:51:28 <gio123> l
10:51:35 <ski> geheimdienst : well, we actually have brackets in product types, as well
10:51:36 <Cale> @tell rajeshsr I was inspired to write a BF interpreter as well: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25793#a25793
10:51:36 <lambdabot> Consider it noted.
10:51:39 <geheimdienst> yeah, but then Silvah will say no with 10 o's
10:52:18 <Silvah> lol
10:52:19 <ski> (though i'd actually prefer if product types did *not* borrow the `,' and brackets from the values)
10:52:53 <ski> (and the same for conjunctions of constraints, of course)
10:53:41 <Silvah> Uhm... we're discussing *syntax* now, amirite?
10:54:13 * byorgey quickly hides a ; behind his back
10:54:16 <byorgey> um... noooooo
10:54:23 <geheimdienst> lol
10:57:00 <Fuco> Anyone know who the author of http://learnyouahaskell.com is? I'd like to thank him/her for the amazing work done there ;P (email address would be appreciated).
10:57:06 <BONUS> you're welcome!
10:57:22 <soupdragon> BONUS@#haskell.com
10:57:33 <Fuco> ok then :) Thanks you sir
10:57:41 <BONUS> well im the guy sooo
10:57:42 <BONUS> :)
10:58:03 <Fuco> I figured that, that's why I'm thanking you :D
10:58:26 <Fuco> It's really easy to follow, yet a bit amusing as well :P And the artwork is stunning
10:58:37 <BONUS> well im glad you liked it!
10:58:39 * geheimdienst thinks the existential type product type constraint type things, whatever they are, should have a syntax as logical and newbie-friendly as possible. there's enough 3-digit difficult-to-remember operators already
10:58:47 <BONUS> the monads chapter should be coming in about two weeks or so
10:58:55 <Fuco> I'm considering it making it a mandatory read for our freshmens ;P
10:59:09 <BONUS> you have your own freshmen?
10:59:14 * wli really liked YAHT's emphasis on monad transformer stacks.
10:59:23 <Fuco> I hope I'll have next year
10:59:30 * wli never really understood monads until he understood monad transformer stacks.
11:00:01 <BONUS> Fuco: we're going to announce a dead tree version of the book coming out soon
11:00:12 <BONUS> in the next weeks
11:01:15 <Fuco> I hope it'll be available here
11:01:47 <hstefan> anyone able to help me with gtk2hs?
11:02:09 <ski> (LYAH will have a dead tree version ?)
11:02:28 <wvd> ski, what?
11:02:31 <BONUS> ski: yeas. we're aiming for a november release (but don't tell anyone)
11:02:44 <idnar> learn you a dead rainforest
11:02:46 <ski> geheimdienst : well, i think `*>' is probably reasonable .. there might be a nicer alternative
11:02:46 <Jafet> Of course ski won't tell anyone
11:02:46 <wvd> BONUS, hey! you're releasing a monads chapter?
11:02:58 <wvd> BONUS, that would be *very* nice - i really like your writing style
11:03:13 * ski doesn't tell Jafet about the secret :)
11:03:34 <BONUS> hehe yeah, i'm gonna take a crack at explaining monads
11:03:59 * wli donates his monad tutorial writing combinators to the cause.
11:04:30 <gwern> BONUS: announce? wasn't LYAH's book deal announced a while ago?
11:04:46 <ski> wvd : what "what?" ?
11:04:59 <BONUS> gwern: yeah like unofficially by me yabbering on #haskell
11:05:02 <wvd> ski, "dead tree version"?
11:05:08 <BONUS> but i mean like with a cover, release date, and preorders
11:05:16 <BONUS> and price and all
11:05:16 <IRC_STINKS> what if int is 16-bit, replicateM cannot handle larger values?
11:05:21 <ski> wvd : see "<BONUS> Fuco: we're going to announce a dead tree version of the book coming out soon"
11:05:38 <mauke> IRC_STINKS: int can't be 16 bits
11:05:38 <wvd> oh
11:05:42 <IRC_STINKS> why
11:05:53 <IRC_STINKS> is it fixed in haskell?
11:06:06 <gwern> IRC_STINKS: the report apparently says it must be 29 bits
11:06:07 <gwern> or something
11:06:11 <gwern> >=29
11:06:14 <IRC_STINKS> oh, I guess haskell won't fit in 16-bit machine :)
11:06:34 <monochrom> I did 32-bit arithmetic in 16-bit 8086 all the time.
11:06:36 <geheimdienst> bonus, what helped me tremendously is what the monad explanation some guy on hacker news wrote the other day ... it was like, a monad means like a function call once removed. so for the Maybe monad, the function call will be done or not, depending on the value. for the IO monad, the function calls are saved for later execution. for the List monad, the function calls are map-ed over the list, etc.
11:06:42 * gwern shrugs. if you're writing a haskell compiler for a 16-bit machine, you can probably quietly break that part
11:06:47 <IRC_STINKS> googled it, I c
11:06:57 <monochrom> And today I do 100-bit arithmetic in 32-bit 386 all the time
11:07:07 <monochrom> > product [1..50]
11:07:08 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
11:07:10 <geheimdienst> it's like changing the meaning of function calls
11:07:26 <soupdragon> > sum . map read . show $ 30414093201713378043612608166064768844377641568960512000000000000
11:07:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:07:27 <lambdabot>         against inferred ty...
11:07:41 <soupdragon> > sum . map (read . return) . show $ 30414093201713378043612608166064768844377641568960512000000000000
11:07:42 <lambdabot>   216
11:07:52 <BONUS> geheimdienst: i'm taking a sort of similar approach.
11:07:54 <soupdragon> > 2+1+6
11:07:55 <lambdabot>   9
11:08:02 <mauke> > 6^3
11:08:03 <lambdabot>   216
11:08:06 <mux> digital root? :-)
11:08:28 <soupdragon> mauke how ddi you do that???
11:08:31 <IRC_STINKS> gwern, but that >=30 bits, not 29
11:08:39 <soupdragon> > 9^3
11:08:39 <lambdabot>   729
11:08:41 <mauke> soupdragon: magic!
11:08:44 <otto_s> > logBase 2 $ product [1..50]
11:08:46 <lambdabot>   214.20813806359016
11:08:47 <soupdragon> > (30414093201713378043612608166064768844377641568960512000000000000)**(1/3)
11:08:47 <lambdabot>   3.121463714426922e21
11:08:48 <gwern> IRC_STINKS: those darn off-by-one errors
11:08:53 <soupdragon> omg it's pi
11:09:04 <BONUS> sort of like: you have a normal function (a -> b) and apply it to an a value. and monads are if you have a function a -> m b that returns something fancy, how do you apply it to an m a value
11:09:30 <Jafet> @quote monads.are
11:09:31 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
11:09:31 <geheimdienst> great. the whole business of boxes of space burritos didn't help me much, but the change-the-meaning-of-function-calls explanation was the first time monads really clicked for me
11:09:41 <Jafet> @quote monads.are
11:09:42 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
11:09:57 <gwern> @quote Wadler
11:09:57 <lambdabot> Pseudonym says: Phil Wadler says so, so it must be true.
11:10:05 <monochrom> "boxes of space burritos" was supposed to make the author happy only
11:10:20 <Jafet> Let's write a monad tutorial based on "@quote monads.are" quotes
11:10:41 <Saizan> geheimdienst: that's basically the explanation given in the original papers :)
11:10:54 <gwern> when all you have are condoms, every problem looks like something you can safely have sex with
11:11:00 <soupdragon> lol
11:11:05 <soupdragon> now you have two problems
11:11:09 <ski> geheimdienst : sometimes expressed as "overloading of `;'"
11:11:30 <geheimdienst> ski, yeah, that makes a lot of sense
11:11:36 <Jafet> Don't forget the 2-3 finger monad
11:11:41 <hstefan> Hey there. I'm writing a 'synonymous seacher' that searchs the words in a Trie. The problem is: I must save the 'sub tries' for performance improvement and I got no idea about how to do this while using gtk2hs.
11:11:49 <hstefan> could someone help me with this?
11:12:57 * ski idly wonders whether `Trie' can be made into a monad
11:13:23 <earthy> ski: look in the bytestring-trie sources ;)
11:13:24 <gwern> hm. I bet it's a monoid at least
11:13:24 <geheimdienst> you could also bring in how in some oo languages you would want to write order().date().hour(), but since each of those can return null, you need to insert lots of checks, making it ugly. enter the Maybe monad, and angels sing, trumpets blare, cats yodel
11:13:33 <earthy> answer 'yes. but you might not have any use for it'
11:13:39 <geheimdienst> all by overloading ;
11:13:58 <gwern> (you have the empty trie, tries can be added to each other - seems like a monoid)
11:14:29 <BONUS> ski: well i can imagine how join would work
11:14:44 <earthy> gwern: depends. a trie is a mapping from keys to values
11:14:56 <earthy> if the values form a monoid, there is an obvious monoid on the tries as well
11:15:10 <earthy> if the values don't form a monoid, what would mappend do to the values?
11:15:28 <gwern> replace with the right most?
11:15:29 <chrisdone> jinjing wang is naught on this
11:15:38 <hstefan> let me search about what's a monoid.
11:15:41 <ski> earthy : well, if we can express some kind of expressions as tries, then it's an instance of the expression-monad with bind-as-substitution -pattern
11:15:47 <chrisdone> he redefined (.) so he could write like python
11:15:54 <chrisdone> or ruby, i guess
11:15:57 <soupdragon> Is (Int,+) a monoid?
11:16:00 <soupdragon> or Int the moniad?
11:16:03 <soupdragon> or + the monoid?
11:16:12 <mauke> (Int,0,+)
11:16:16 <gwern> the monoid rule was associative wasn't it? a <+> (b <+> c) == (a <+>) b) <+> c
11:16:16 <monochrom> (Int,+,0)
11:16:28 <earthy> soupdragon: (Int,+,0) but als (Int,*,1)
11:16:37 <gwern> earthy: so the old value can just be overwritten
11:16:40 <soupdragon> 0 is defined uniquely by + no?
11:16:48 <Cale> soupdragon: (Int,0,+) is the monoid, but we'll say that Int is a monoid when it's convenient and obvious which operation we're talking about
11:16:50 <ski> `(Integer,0,+,proof_that_0_is_left_identity_of_+,proof_that_0_is_right_identity_of_+,proof_that_+_is_associative)' is the monoid !
11:16:54 <gwern> soupdragon: yeah and 1 is the identity for *
11:16:55 <soupdragon> ski :)))))
11:16:59 <earthy> gwern: yah. could be. I like the obvious instance when the values are a monoid better
11:17:03 <chrisdone> lol
11:17:13 <monochrom> ski has it right
11:17:15 <gwern> earthy: so I guess there are 2 monoids for tries...
11:17:28 <gwern> the update and whatever monoid exists for the values
11:17:31 <earthy> 3. you might want the *first* occurence, instead of the last. ;)
11:17:35 <mux> 3, if you count the one that
11:17:40 <soupdragon> trie and trie again
11:17:44 <mux> you beat me to it.
11:17:45 <ski> (often we would shorten that as `Integer', which then means an object in `Mon', using the above `Integer' as an object in `Type')
11:17:53 <geheimdienst> #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
11:17:59 <soupdragon> lol
11:18:07 <earthy> geheimdienst: :P
11:18:16 <monochrom> @remember geheimdienst #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
11:18:16 <lambdabot> I will never forget.
11:18:22 <earthy> oh well. time to get some wine and put on a movie to watch with the wife.
11:18:37 <earthy> 'haskell is hard! my head hurts!'
11:18:50 <gwern> earthy: hm. yeah, I guess keep-the-first also works
11:19:02 <gwern> @quote emission
11:19:02 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
11:19:16 <chrisdone> earthy: watch 'A Taste of Haskell' written and directed by Peyton `Simon` Jones
11:19:31 <mux> haskell puts such a strain on the brain when you leanr it that I nearly believe you would see differences in brain MRIs before and after learning.
11:19:32 <earthy> gwern: and First and Last are instances of Monoid for Maybe. :)
11:19:46 <monochrom> @quote list.monad
11:19:46 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
11:19:49 <monochrom> @quote list.monad
11:19:49 <lambdabot> <mm_freak1work> says: not to be or to be and (not to be or to be and (not to be or to be and...)), that is the list monad
11:19:56 <earthy> chrisdone: nah. she wouldn't like it.
11:20:00 <gwern> what's the connection between monoids on tries and monoids on maybe, I wonder
11:20:14 <Cale> Or: half an hour of meditation, followed by another half hour of dicking about until it typechecks. Either way.
11:20:43 <Gracenotes> oh, the lines like '-> Foo -> Bar' in Haddock are argument functions, right. .. I wonder if those could be syntaxed up correctly...
11:20:47 <gwern> more than once I;ve solved my haskell problem by sitting down and meditating for a while
11:20:53 * chrisdone is shocked that Cale doesn't just put his hands on the keyboard and write the program in one go
11:21:00 <chrisdone> "done."
11:21:07 <monochrom> re-design. re-factor. re-prove.
11:21:28 <gwern> gellman - 'the feyman problem-solving algorithm: 1. Think very hard. 2. Write down the solution.'
11:21:33 <chrisdone> :D
11:21:46 <Cale> chrisdone: Well, I do make mistakes, but happily not so many mistakes that the typechecker can't catch.
11:21:49 <earthy> gwern: well, a trie is a mapping of the entire space of keys to Maybe values
11:22:08 <earthy> lookup :: Trie -> key -> Maybe value
11:22:08 <Gracenotes> a finite mapping though :/
11:22:23 <Cale> I could be more careful and not make mistakes, but then the typechecker would have nothing to do.
11:22:35 <earthy> gracenotes: no. just a finite number of elements that are not Nothing.
11:22:40 <Gracenotes> well. I guess not necessarily a finite mapping. but a finite set of elements.. yeah.
11:22:49 <monochrom> the fermat problem-solving algorithm: 1. Think very hard.
11:22:52 <Cale> and I'm lazy :)
11:22:55 <luite> gwern: you have missed the "write down the problem" step
11:22:58 <hstefan> how do I set the Gtk Entry to call a function when a new character is typed?
11:23:05 <danewbie> hi, does anyone know whether is it possible to build a Repa array using GeneralizedNewtypeDeriving?
11:23:25 <gwern> luite: ah, so you're write. I was quoting from memory
11:23:27 <danewbie> i'm stuck trying to import some modules that are private (Could not find module `Data.Array.Parallel.Unlifted.Distributed.Types': it is a hidden module in the package `dph-prim-par-0.4.0')
11:23:34 <monochrom> the descarte problem-solving algorithm: 1. Think
11:23:44 <chrisdone> heh
11:24:03 <soupdragon> 2. Therefore I am
11:24:04 <geheimdienst> 1. Think 2. Therefore Be
11:24:05 <BONUS> ski: do you think that join for tries could work like this: http://dl.dropbox.com/u/665999/triejoin.png
11:24:06 <Gracenotes> limitation: only 'works' for problems of self-existence
11:24:09 <gwern> you have 2 cows. you lift them into monads, and begin trying to figure out how the heck monad transformers work
11:24:22 <chrisdone> the hume problem solving algorithm: 1. Write down the solution
11:24:30 <Hunner> the internet problem solving algorithm: 1. ???? 2. Profit
11:24:36 <gwern> BONUS: *ouch*. my eyes
11:24:42 <chrisdone> unsafePerformProblemSolving
11:25:20 <geheimdienst> the internet problem solving algorithm: 1. check hacker news 2. check reddit 3. check out lolcats 4. postpone problem solving until tomorrow
11:25:23 <BONUS> gwern: it's this new version of graphviz, it'd ridiculous
11:25:27 <Gracenotes> chrisdone: also the Deep Thought algorithm?
11:25:35 <mux> the lazy problem solving algorithm: 1. Explain problem on IRC  2. Subtly shame people into solving the problem for you
11:25:37 <gwern> BONUS: lies. obviously you did that by hand
11:25:52 <ski> monochrom : also, re-use
11:25:59 <ulfdoz> Hunner: Sorry, I doubt, that it is this way. It is 1) found idiots 2) take money.
11:26:24 <dancor> mux: don't forget 1b. Lose hours arguing with someone who didn't understand your problem.
11:26:44 <dmwit> BONUS: I'm confused. Don't values normally live at the green nodes?
11:26:55 <mux> dancor: true that
11:27:02 <ski> BONUS : i'm not sure what the "middle" blue dot is meant to be ?
11:27:14 <Null-A> anymore cool haskell tutorials like scheme in 48 hours?
11:27:29 <gwern> you have 2 cows. you compose them with . and feel smug
11:27:44 <ski> BONUS : the trie would typically have a lot of leaves, each containing a new trie, and the `join' would just "plug" those leaf-tries into the main trie
11:27:44 <dancor> these trees are edge-labeled.   but it's the same as moving the labels to the children the edges point at
11:27:53 <aavogt> gwern: copumpkin had a video for that
11:28:03 <Jafet> gwern, leading to $
11:28:11 <gwern> you have 2 cows. you enjoy them with some `curry`
11:28:26 <gwern> aavogt: he's such a plagiarist.
11:28:40 <byorgey> Null-A: have you seen "Learn you a Haskell"?
11:28:46 <Null-A> byorgey: yep =
11:28:47 <Null-A> )
11:28:57 <ski> BONUS : similar to `data Tree a = Leaf a | Branch (Tree a) (Tree a)' and `join :: Tree (Tree a) -> Tree a; join (Leaf tree) = tree; join (Branch treeOfTrees0 treeOfTrees1) = Branch (join treeOfTrees0) (join treeOfTrees1)'
11:28:59 <gwern> Jafet: you have 2 cows. you compose them with $ and when everyone is confused about the difference, feel even smugger
11:29:02 <BONUS> ski: oh
11:29:12 <BONUS> yeah i see
11:29:20 <BONUS> cause i thought like tries where the nodes don't have any values
11:29:22 <BONUS> only the edges
11:29:23 <ski> (BONUS : so, no duplication of sub-tries .. just plugging)
11:29:26 <BONUS> aha
11:29:46 <ski> well, values in the edges / internal nodes is harder than values in the leaves
11:30:15 <ski> you can think of a string trie with elements in the internal nodes (for when the string ends there) as actually branching out to a leaf in each such case
11:30:45 <BONUS> hmmm, yes yes
11:33:37 <gio123> ski
11:33:46 <monochrom> monochrom
11:34:03 <ski> BONUS : another example of the same idea is `data Expr a = Var a | Lit Integer | Add (Expr a) (Expr a)' with `(>>=) :: Expr a -> (a -> Expr b) -> Expr b; Var x >>= subst = subst x; Lit n >>= _ = Lit n; Add e0 e1 >>= subst = Add (e0 >>= subst) (e1 >>= subst)', here `(>>=)' is actually substituting away the variables of type `a' in `Expr a' with expressions (using variables of type `b'), to get expressions `Expr b' with variable
11:36:09 <BONUS> ah yes, i see the gist of it yeah
11:38:17 <ski> also, then you can do `fullSubst :: (a -> Expr a) -> Expr a -> Expr b' (or s/b/Void/ if you prefer) defined by `fullSubst subst ma = do a <- ma; fullSubst subst (subst a)' .. which has a certain charm :)
11:39:15 <ski> (so, "running" an action of type `Expr a' means to traverse it (copying the structure of it to the output), until you (nondeterministically) reach each variable, which you decide what expression to replace it with)
11:39:30 <BONUS> oh, nice
11:39:39 <gwern> '# Euclid  didn't even get a high-school diploma'
11:39:40 <gwern> what
11:42:30 <ski> (that `fullSubst' at first look seems that it "should not terminate, but the same could be said about
11:43:25 <ski> > take 15 . fix $ \xs -> 1 : [y | x <- xs , y <- [2*x,2*x+1]]
11:43:26 <ski> )
11:43:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
11:46:17 <BONUS> that >>= for Expr a is cool though, conceptually very simple but still powerfull
11:46:31 <aavogt> aah type errors in generated TH are so nasty
11:53:38 <Null-A> Why does haskell's score on computer language shootout keep changing, it use to be faster than C# mono, now its much slower?
11:53:52 <Null-A> Also is there a better source of information, on the performance tradeoffs between haskell and other languages?
11:55:14 <monochrom> scores change because people improve submissions
11:55:27 <Null-A> okay, hopefully haskell isn't doing any regression
11:55:42 <Null-A> there use to be a thread ring test, I don't know why its not listed any longer :(
11:56:26 <ski> BONUS : unless the implementation is sufficiently smart to do deforestation in this case, one might want to do a CPS-ification of it, to avoid quadratic complexity of `fullSubst'
11:57:03 <edwardk> ski: codensity for the win ;)
11:57:13 * ski is attempting to find a paper that explains doing that, but can't seem to find it atm
11:57:27 <edwardk> janis voightlaender's asymptotic improvement of free monads paper
11:57:36 <ski> ah, that's the one, i think
11:57:50 <edwardk> i've probably blogged about the approach as well, and its definitely present in the logs if you hunt for me rambling on about codensity ;)
11:58:02 <edwardk> but you might have a lot of rambling to wade through ;)
11:58:09 <ski> BONUS : see "Asymptotic Improvement of Computation over Free Monads" at <http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf> by Janis Voigtl‰nder
11:58:33 <BONUS> cool, i'll czech that out
11:59:30 <BONUS> i've seen that CPS-ification often produces monads with faster operations but i still don't understand quite why
12:00:12 <ski> (.. in the old Warszawa pact, the eastern block czechs *you* out ?)
12:00:26 <monochrom> haha
12:01:29 <edwardk> BONUS: let me try to explain: the short answer is that you can think of monads being about two things, substitution and renormalization, bind is sort of a combination of these two things. its clearer if you implement bind as an fmap of the function (a -> m b) yielding m (m b) and then a join taking m (m b) -> m b
12:01:51 <ski> BONUS : basically because instead of returning a constructor that must be taken apart by `case', only to be constructed again, over and over; you work directly with the "`case' branches" omitting the intermediate "construct and deconstruct" steps
12:02:00 <edwardk> BONUS from there, you can think about monads for which that join doesn't flatten much, like a simple 'leafy tree' monad. data Tree a = Bin (Tree a) (Tree a) | Tip a
12:02:26 <BONUS> hmm
12:02:36 <edwardk> BONUS: if you substitute in that tree, all you do is replace Tip a's with either Tip b's or some complicated Bin (Tip b) (Bin (Tip b) (Tip b)) -- like construction
12:02:41 <edwardk> so you keep growing the tree
12:03:01 <edwardk> but each bind has to walk over the same 'dead core' of the tree, that never changes shape
12:03:20 <monochrom> interesting. substitution and renormalization.
12:03:43 <ski> BONUS : with something like Olin Shivers' "Multi-return function call" (providing multiple alternative continuations to a call), possibly implemented as what i like to think of as "unboxed variant types", you could possibly get this behaviour more or less "for free"
12:03:57 <edwardk> OTOH, if you switch to 'Codensity Tree' you have something like newtype CodensityTree a = CT (forall b. (a -> Tree b) -> Tree b) -- where the function acts like an 'accumulating parameter' for binds
12:04:44 <edwardk> you can work out that newtype Codensity f a = Codensity (forall b. (a -> f b) -> f b)  is Functor, Applicative, and Monad, regardless of the type of f.
12:04:46 <BONUS> ah so it's codensifying it just like that
12:05:14 <edwardk> so what happens is if you bind twice, you get one operation that walks over the common core of the tree, and then does the operation while its already there
12:05:21 <edwardk> at the leaves
12:05:30 <edwardk> you've right associated all your binds
12:06:54 <edwardk> if each operation adds a just one node to the tree, before you had to walk over 1,2,3,4,5,6,7,8,9,... nodes to get down to do the next operation now you just walk over 1 for each step. and the asymptotics dip from quadratic to linear, or even better if you only inspect one part of the resulting tree
12:07:13 <edwardk> that is why the codensity monad is useful =)
12:07:18 <ski> BONUS : in my ideal variant, if we define `data# Tree# a = Leaf# a | Branch# (Tree# a) (Tree# a)', then returning `Leaf# x' or `Branch# l t' wouldn't actually construct anything, instead just choose the right one of two (implicit) continuations, corresponding to some dynamically wrapping `case ... of Leaf# x -> ..x..; Branch# l r -> ..l..r..' expression
12:07:23 <aavogt> hmm, is there an existing sort of a HList?
12:07:35 <edwardk> aavogt: as in a library?
12:07:45 <aavogt> sort function
12:08:19 <BONUS> hmm yes
12:08:22 <BONUS> that makes sense
12:08:34 <edwardk> aavogt: well, there is an insert that inserts into sorted order so you should be able to take an unordered hlist and produce a sorted one by insertion sort with a simple recursive definition
12:08:37 <ski> BONUS : so returning `Leaf# x' would be equivalent to calling the `leaf' continuation in continuation passing-style, and calling the `branch' continuation in the other case .. and the `case' expression would correspond to `... (\x -> ..x..) (\l r -> ..l..r..)', passing the two branches as the two continuations
12:08:59 <edwardk> ski makes up more notation than even I do ;)
12:09:36 <edwardk> you can get part way there with just using views.
12:09:42 * hackagebot hashmap 0.9.0 - Persistent HashMap with API of an IntMap.  http://hackage.haskell.org/package/hashmap-0.9.0 (MilanStraka)
12:10:12 <ski> (and, btw, yes `Tree# a' would not have kind `*', but (probably) something like `[#]' which would be comparable to the `(#)' kind for unboxed tuples)
12:10:57 <ski> BONUS : see <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301> for an example of using this (hypothetical) syntax
12:11:44 <BONUS> but edwardk mentioned a CodensityTree being CT a = CT (forall b. (a -> Tree b) -> Tree b), isn't that supposed to be something like: newtype Tree a = forall r. (a -> r) -> (Tree a -> Tree a -> r) -> r
12:11:45 <ski> (but only look at the first two pastes there .. ignore the latter mess-up that edwardk provided ;)
12:11:54 <BONUS> that's sort of how i imagine CPSizing a tree
12:12:15 <edwardk> ski: heh well its an example of how to work with codensity for something that isn't a haskell functor at least ;)
12:12:24 <edwardk> er yoneda even
12:13:44 <ski> BONUS : probably you want to replace `Tree a' by `r' in there .. at least if you want to express folds
12:14:08 <edwardk> bonus: not quite that is a different transform that what i was gunning for with codensity, as it doesn't provide you with the same 'free bind' what you gave is a yoneda based functor, but its not as useful as the codensity version because it can only accumulate fmaps.
12:14:50 <edwardk> and the 'Tree a's in negative position there are probably not what you want like ski said
12:15:02 <ski> (edwardk : btw, just so you know, you've forgotten to include `M' in the return type of `filter' there, in all your annotations :)
12:15:06 <BONUS> hm
12:15:10 <edwardk> ski: =P
12:16:04 <ski> edwardk : btw, i'm not sure which non-functor you were talking about just above
12:16:06 <ski> `M' ?
12:16:24 <ski> (hm, no, that can't be it)
12:17:19 <BONUS> i gotta fly, thanks ski & edwardk!
12:17:28 <BONUS> i kind of see it now but i reserve the right to bug you about it in the future
12:17:33 <edwardk> ski: M ~ Yoneda Endo, Endo isn't a functor
12:17:50 <edwardk> (over Hask)
12:18:03 <ski> BONUS : anyway, the optimization we want, to avoid quadratic complexity of `(>>=)' in `Maybe',`Either e',expression-monads is similar to avoiding the quadratic complexity of left-nested appends in the naÔve implementation of `reverse'
12:18:12 <ski> edwardk : ok, ty
12:18:20 <BONUS> hmm ah
12:18:58 <edwardk> hrmm i wonder if i could make a faster version of my modified iteratees by using a random-access list of bytestrings rather than a fingertree
12:19:02 <ski> (but, in this case, we still want to use an implementation of `reverse' that "looks naÔve", but we're changing the list type to use a CPS (or "unboxed variant") representation)
12:19:04 <edwardk> since i always only append
12:19:33 <ski> (and .. this is similar to using `DList' instead of `[]')
12:20:47 <edwardk> so if i had a right-end focused random access list (i.e. made out of a skew binary tree of bytestrings) it should be slightly faster than the fingertree i use right now and still support the important operations
12:21:28 <edwardk> though some slices would be slower if they were far away from the head
12:22:01 <ski> (is that "right-end" as in "ends and co-ends" ? ;)
12:22:31 <edwardk> nah right end as in 'with the finger pointed at the part where you snoc and viewr/unsnoc
12:22:40 <ski> just checking ..
12:23:55 <ski> ("one never knows for sure beforehand, whether some natural-sounding word is actually category-terrorist-speak, when it's edwardk one's dealing with" -- old famous saying)
12:24:05 <edwardk> hahaha
12:24:15 <ezyang> "category terrorist". good one.
12:24:43 <edwardk> it looks like i just need a right biased version of my skew-list code, wrapped around bytestrings and i should be able to make a nice little parsec clone out of it
12:25:10 <dv-> a member of al-gebra
12:25:40 <ski> infidel !
12:25:41 <gwern> dv-: under philama bin wadler?
12:25:41 <soupdragon> algezebra
12:26:03 <edwardk> soupdragon: hah. they see everything in black and white
12:28:35 <edwardk> hrmm i'd want some kind of operator to cut off the front of the skew-list though
12:28:55 <edwardk> since i know that if i put it out on hackage someone will misuse it ;)
12:32:29 <edwardk> hrmm, skew binary or zeroless binary?
12:32:59 <edwardk> same asymptotics, need to check benchmarks
12:38:45 <gio123> ski
12:46:55 <tomberek> edwardk: howdy
12:48:42 <edwardk> heya tom
12:49:10 <tomberek> I'm trying to do things with the expression problem
12:49:32 <edwardk> like?
12:49:54 <tomberek> let me post it..
12:50:53 <tomberek> edwardk : it's similar to Bifunctor you had in that post
12:50:57 <tomberek> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25794#a25794
12:51:00 <gwern> (my monads. let me show you them)
12:52:44 <edwardk> ok, so far you have a bifunctor (bimap/emap/rmap) with some comonad like things baked in
12:52:53 <edwardk> with colorful names
12:53:23 <tomberek> almost,, the maps are from bifunctor, and rip/extract is comonad-ish
12:53:50 <edwardk> yeah you appear to have it being a comonad in either argument
12:53:57 <tomberek> correct
12:54:23 <tomberek> i have an instance for example:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25794#a25795
12:55:11 <edwardk> so Labelable m ~ Bifunctor m, forall a. (Comonad m a), forall a. Comonad (Flip m a) but then you also have a 'return' like operation for label that i don't understand the motivation for
12:55:55 <tomberek> return?  oh, that's my label/labelF. that's to construct
12:56:10 <tomberek> is that not going to be needed?
12:56:17 <edwardk> do you have many other isntances other than (,) and/or triples that contain both a and b and something else?
12:56:28 <edwardk> it seems a touch heavily constrained
12:57:18 <tomberek> well, it is easy to make an instance of something like data Tuple a b = Tuple a b...  it's the next step that might explain my motivation
12:57:46 <edwardk> yeah i'm just not sure that given the constraints you've given yourself that there are any toher interesting members ;)
12:58:18 <arcatan> 
12:58:21 <tomberek> i want to be able to take something that has been Labeled, also Labelable in the original way.   so it would look like
12:58:29 <edwardk> other than some kind of data Triple m a b = Triple m a b -- where m is a monoid or data Foo m a b = Foo (m -> (a, b)) where m is also a monoid
12:58:33 <tomberek> newtype Labeled f a b = L {runLabel::f a b}
12:58:39 <tomberek> instance (Labelable f)=>Labelable (Labeled f) where
12:58:58 <tomberek> so whatever 'labeling' scheme is re-used
12:59:30 <tomberek> i tried some of those Data ALaCarte tricks
13:00:00 <edwardk> not sure how they apply, what you just asked for should be easy
13:00:12 <tomberek> and i can't figure out how to use the ideas in your expression problem blog post
13:00:59 <edwardk> i don't see how they'd apply here
13:01:10 <JoeyA> Is there a more terse and pretty way to write this?  [[a,b,c] | a <- [0..6], b <- [1..6], c <- [1..6]]
13:01:31 <soupdragon> > sequence [[0..6],[1..6],[1..6]]
13:01:32 <lambdabot>   [[0,1,1],[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,1,6],[0,2,1],[0,2,2],[0,2,3],[0...
13:01:33 <Cale> > sequence [[0..6],[1..6],[1..6]]
13:01:34 <lambdabot>   [[0,1,1],[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,1,6],[0,2,1],[0,2,2],[0,2,3],[0...
13:01:42 <JoeyA> awesome
13:01:43 <tomberek> edwardk: what i have so far:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25796#a25796
13:01:57 <FunctorSalad> nice
13:02:28 <edwardk> label a b = Labeled (label a b)
13:03:22 <edwardk> i think you might really want something different though
13:03:25 <alexyk> I wonder if anybody here has the bandwidth to help me with enhancing google protocol buffers for haskell
13:03:29 <edwardk> overall
13:03:31 <edwardk> something more like
13:03:45 <tomberek> edwardk: Labeled is not in scope
13:03:49 <Saizan> bandwidth?
13:03:51 <edwardk> class Labelable m where type Labeled m :: * -> * -> *
13:03:52 <alexyk> or, I'd say, interest in using the protobufs
13:03:59 <edwardk> tomberek: sorry you named the constructor L
13:04:09 <edwardk> label a b = L (label a b)
13:04:14 <tomberek> oh,,, ok, i tried AT's but again, messed them up
13:04:14 <alexyk> Saizan: sacrificing precious time from BS'ing on IRC to actually writing code! :)
13:04:45 <edwardk> i'm just saying that that might be what you are really looking for. the label a b = L (label a b) is the answer to the question on the last line of that code
13:05:32 <tomberek> ok,, well, I am also trying to use TypeFamilies,,, what benefit would I get from that?  (I actually was trying exactly that: Labeled m::*->*->* earlier)
13:06:01 <gwern> http://pgraycode.wordpress.com/2010/05/29/raptors/
13:06:04 <gwern> the code, it burns1
13:06:07 <ski> JoeyA : `sequence' in the list monad is basically an iterated cartesian product of the list of lists
13:06:27 <alexyk> I can explain the task as follows.  I use a Clojure binding to Google Protocol Buffers to serialize a graph into such, which is just a map from nodes to adjacency lists, which are in turn maps of edges.  The good Clojure folks made an extension which allows to store a Clojure map or set in a protobuf directly.  Chris Kuklewicz' Haskell bindings for protobufs recognize the extensions in general; the "only" remaining part is to implement
13:06:27 <alexyk> parsing the maps and sets directly into Haskell's Map and some Set if there's one.  I care about Map first.
13:06:38 <JoeyA> I'm glad to know about it (sequence) :-)
13:06:44 <JoeyA> (didn't before)
13:06:46 <gio123> ski
13:06:49 <FunctorSalad> is it useful to write typed "bindings" for shell programs like gnu find? Lots of transcription for not much gain apparently (preventing you from doing "-type bogus" at compile time, ok)
13:07:10 <FunctorSalad> and a more robust representation of the tree structure, in this case
13:07:19 <gwern> FunctorSalad: probably not. more valuable would be a find library in haskell
13:07:31 <gwern> why 'compile' your queries down to findese?
13:07:49 <alexyk> The Clojure extensions are shown here: http://github.com/ninjudd/clojure-protobuf.  Haskell's protobufs are here: http://hackage.haskell.org/package/protocol-buffers
13:08:12 <FunctorSalad> gwern: thought about it too, but I assume `find' has gathered some tricks over all the years ;)
13:08:25 <FunctorSalad> (low-level filesystem wise)
13:08:38 <gwern> most of the tricks you don't care about
13:08:44 <gwern> you often run on Ultrix?
13:08:56 <FunctorSalad> hehe
13:09:27 <alexyk> Xenix rules
13:10:04 <alexyk> wither HPUX and friends?  Unixen were cute.  Now Linux ate them all, devoured too.
13:10:32 <alexyk> SCO was cutting-edge on i386 in 1988 or so...
13:11:54 <alexyk> ok never mind, back to protobufs! :)
13:12:13 <tensorpudding> BSD is still alive.
13:12:23 <tensorpudding> Also Solaris
13:12:34 <gwern> FunctorSalad: but find in haskell would be more powerful; I don't think find does turing-complete booleans
13:12:36 <alexyk> tensorpudding: in the caves of those who don't know the war is over, perhaps
13:13:06 <gwern> tensorpudding: the bsds have linux compatl ayers, and good ones I hear; and solaris... who knows what oracle has planned for it
13:13:12 <gwern> opensolaris seems to be dead
13:13:26 <alexyk> every evening, as Linus bikes to Pete's Coffee, he marks another batch of BSD users with crosses on his sniper's rifle's butt
13:13:34 <gwern> (also, I wonder when netbsd will die)
13:14:22 <jkingkong> #haskell, I have a really random question: Is "daemon" pronounced "day-eh-mon" or "dee-mon"?
13:14:32 <ski> gwern : possibly one could make an `Applicative' (or a `Category') out of it ?
13:14:34 <FunctorSalad> gwern: one can use the return status of -exec as a test too (but that's quite besides the point admittedly ;))
13:14:44 <alexyk> jkingkong: this belongs in #hell or #unix
13:14:52 <gwern> ski: it's some abstraction of course
13:14:57 <gwern> jkingkong: day-mon?
13:15:06 <jkingkong> sorry alexyk I was reading Control.Concurrent and came across this
13:15:17 <alexyk> jkingkong: kiddin' of course
13:15:28 <jkingkong> haha i was going to say, what is #hell?
13:15:40 <jkingkong> and are there really people there
13:15:45 <EvanR> jkingkong: redirects to #php
13:15:46 <ski> (then the Haskell `Applicative' would compute an invocation of `find' that doesn't need to decide what to do later, based on earlier results .. i.e. the shape would be static, once computed)
13:15:49 <FunctorSalad> (since, I guess, one doesn't want to start a new process for every file)
13:15:52 <alexyk> jkingkong: you can join, but not come back
13:16:06 <jkingkong> there is one person in #hell, and it's DracoDan
13:16:12 <jkingkong> well, now I'm there too
13:16:25 * gwern used up some plenary pardons to escape
13:16:33 <alexyk> jkingkong: sorry man, I've just made it up  on the fly
13:16:38 <jkingkong> i can't get out!
13:16:56 <jkingkong> soupdragon can't either apparently
13:17:00 <gwern> jkingkong: for 40 groats, I can intercede with the Blessed Virgin Mary for you
13:17:09 <FunctorSalad> ski: what do the type parameters represent?
13:17:14 <alexyk> jkingkong: same here for 40 goats
13:17:28 <FunctorSalad> (or 'type parameter' in case of Applicative)
13:17:34 <gwern> (a groat is worth less than a goat)
13:17:37 <jkingkong> i'd be very impressed if you were able to get be me to leave #hell remotely from your computer
13:17:41 <ski> jkingkong : obviously it's "daemon", (where "ae" is like in the latin "dies irae" or "aether" or "aeterna")
13:17:41 <alexyk> gwern: are groats reated to croats and goats?
13:17:46 <gwern> no
13:17:58 <alexyk> or groans then?
13:18:03 <gio123> ski
13:18:14 <gwern> ski: interesting style you have, of explaining a recondite problem by recourse to even more recondite topics
13:18:16 <jkingkong> ski: well yes, but whenever I saw "aether," I'd always just say "ether"
13:18:26 <gwern> alexyk: not that either
13:18:31 <alexyk> gwern: damn
13:18:37 <geheimdienst> guys, that's just pseudo-intellectual showing off
13:18:37 <gwern> @wn groat
13:18:38 <lambdabot> *** "groat" wn "WordNet (r) 2.0"
13:18:39 <lambdabot> groat
13:18:39 <lambdabot>      n : a former English silver coin worth four pennies [syn: {fourpence}]
13:18:42 <geheimdienst> say whatever you like
13:18:46 <geheimdienst> whatever your pals say
13:18:55 <gwern> geheimdienst: hey, there's nothing pseudo about me
13:18:58 <geheimdienst> ;-)
13:19:16 <geheimdienst> noone can have anything against deemon
13:19:20 <geheimdienst> or daymon
13:19:31 <tomberek> da-man
13:19:41 <jkingkong> tomberek: what are you jamaican?
13:19:43 <ski> gwern : i could think of any more common words having the latin "ae", on the fly ..
13:19:54 <geheimdienst> "i'm fucking matt daemon ..."
13:19:59 <tomberek> aether
13:20:10 <alexyk> croats sold eleven goats, each for fifty seven groats; now the guy who bought them owns just eleven coarse groans.
13:20:14 <geheimdienst> lolcaet
13:20:20 <ski> (sorry, s/could/couldn't/)
13:20:22 <geheimdienst> lolc√¶t
13:20:29 <jkingkong> my, I've pushed this channel in a horrible horrible direction
13:20:31 <FunctorSalad> ^^
13:20:42 <FunctorSalad> I like lolcaet
13:20:55 <jkingkong> I even launched some of us into #hell
13:21:03 <alexyk> lolcaet reminds one of lolcats
13:21:11 <geheimdienst> o rly?
13:21:20 <jkingkong> :D
13:21:32 <jkingkong> alexyk: cool story brah
13:21:35 <FunctorSalad> ski: plurals don't count?
13:21:54 <ski> FunctorSalad : some kind of result of the computation, i was thinking (maybe it could be a GADT, restraining what possible types it could be .. hm)
13:22:13 <mdmkolbe> What is the "right" way to make a version of mkM that operates on Functor instead of Monad?
13:22:16 <geheimdienst> it's so sad that the lambdacats dropped out of the net
13:22:37 <geheimdienst> ye olde mon√¶dte
13:22:56 <ski> FunctorSalad : imo, the different numerus-forms of a word are just variant ways of using the same word entity :)
13:22:59 <FunctorSalad> ski: the expressions all return booleans (and have side-effects) as far as I can see
13:24:14 <ski> FunctorSalad : if the GADT approach wouldn't work, then maybe just a type of kind `*', with operations similar to the ones of `Applicative', but monomorphized (which reduces the analogy a bit, to say the least) ..
13:24:22 <FunctorSalad> (of course, having only one sensible type argument doesn't stop the Put monad ;))
13:24:52 <FunctorSalad> (no other way to make your own syntax with no punctuation as delimiters, after all...)
13:25:55 <Saizan> mdmkolbe: mkM?
13:26:13 <mdmkolbe> @type mkM
13:26:14 <lambdabot> forall b (m :: * -> *) a. (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
13:26:23 <mdmkolbe> Saizan: from Data.Generics.Aliases
13:26:31 <mdmkolbe> (i.e, Scrap your boilerplate)
13:27:22 <Saizan> looking at the source it should be clear iiuc
13:27:42 <tommd> > "ping"
13:27:43 <lambdabot>   "ping"
13:28:35 <hstefan> hey. What's wrong with line 36? http://codepad.org/F140i4GO
13:28:50 <FunctorSalad> ski: btw I only had the existing `find' program in mind... for a reimplementation one could make better use of the type parameter, sure
13:29:32 <ski> FunctorSalad : i was only thinking of the existing `find' program here (but maybe using a little bit of creativity in the compilation)
13:29:43 <Botje> hstefan: you can't do a where in the middle of a do block like that
13:30:12 * uorygl pushes uoryfon out of the channel.
13:30:16 <hstefan> ;s damm
13:30:26 <FunctorSalad> (I think I'd use a Reader FilePath plus Writer Action or so as a monad for a new impl)
13:30:31 <hstefan> in this case I dunno how to do this
13:30:32 <Saizan> mdmkolbe: the problem is that you don't have a return
13:30:48 <hstefan> oops
13:30:49 <jkingkong> what's the function that extracts all possible tuples from a list of n elements? Can this be done with a list comprehension?
13:30:50 <hstefan> I know.
13:30:56 <Botje> hstefan: is there a reason you can't simply define it at the end of your do block?
13:31:04 <EvanR> jkingkong: yes
13:31:12 <Botje> oh, i see. it uses treeview
13:31:16 <Botje> hstefan: you can use a let instead?
13:31:24 <Botje> let setWordList s = Model.treeViewSetModel treeview s (triePrefix t1 s)
13:31:25 <aavogt> I have an issue with type inference: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25797#a25797
13:31:31 <jkingkong> EvanR: are you answering the first or second part of the question?
13:31:34 <aavogt> as in, it's not happening
13:31:39 <EvanR> jkingkong: second
13:32:01 <EvanR> the first question wasnt a yes no, so my answer would not type check
13:32:10 <jkingkong> EvanR: well, I don't want "duplicates" as in, I want to treat (a,b) as (b,a)
13:32:20 <EvanR> then you can use nub afterward
13:32:26 <jkingkong> EvanR: I thought you might have been saying "a function exists"
13:32:27 <EvanR> erm
13:32:29 <EvanR> nubBy
13:32:43 <jkingkong> this will be slow though right?
13:32:54 <EvanR> why
13:32:55 <jkingkong> isn't there like a sequence function or something that just does this
13:32:55 <mdmkolbe> Saizan: heh, you'd think it would be simple wouldn't you.  but mkM is defined in terms of extM which is defined in terms of unM, M, and ext0.  At this point I'm reduces to just defining my Functor version directly in terms of cast (which is less clean/high-level than I'd like).
13:33:20 <aavogt> edwardk, you said there was an insertion into ordered hlists?
13:33:34 <jkingkong> EvanR: you're filtering out a list of all order-dependent tuples
13:33:37 <gwern> 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras, and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero. Just like your statistics. '
13:33:42 <EvanR> jkingkong: you can write imperative for loops and write optimizations later, or much later. but then whats the point of haskell?
13:33:43 <gwern> well. that's an interesting criticism
13:33:44 <aavogt> I couldn't find it, and my attempt to implement it fails
13:33:44 <jkingkong> EvanR: I need to do this on lists with many elements
13:33:45 <ski> > [(a,b) | bs@(a:_) <- "abcd" , b <- bs]
13:33:46 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:33:46 <lambdabot>         against inferred type...
13:33:57 <gwern> http://factor-language.blogspot.com/2010/05/comparing-factors-performance-against.html
13:33:58 <ski> > [(a,b) | bs@(a:_) <- tails "abcd" , b <- bs]  -- er
13:33:59 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('b','b'),('b','c'),('b','d'),('c'...
13:34:09 <EvanR> jkingkong: if you are saying its twice as much work, well the tuple problem is n^2
13:34:10 <ski> > [(a,b) | a:bs <- tails "abcd" , b <- bs]  -- alternatively
13:34:11 <lambdabot>   [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
13:34:13 <EvanR> so it doesnt matter
13:34:20 <ski> jkingkong : something like that ^ ?
13:34:30 <jkingkong> hmm yea
13:35:46 <gio123> ski
13:37:24 <mdmkolbe> gwern: does it mean anything or is it just gibberish?
13:38:51 <FunctorSalad> gwern: algebraists are claiming to be system programmers (by virtue of that alone) now? *puzzled*
13:39:14 <gwern> mdmkolbe: that's my question
13:39:30 <FunctorSalad> (seems a bit... strawman-ish)
13:39:58 <jkingkong> :t combinations
13:39:58 <lambdabot> Not in scope: `combinations'
13:40:48 <ski> > replicateM 3 "ab"  -- jkingkong ?
13:40:49 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
13:41:56 <EvanR> > replicateM 2 [1,2,3,4]
13:41:57 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4...
13:42:11 <jkingkong> I actually really like the tails implementation
13:42:24 <jkingkong> I'm just surprised it's not in the prelude
13:42:37 <EvanR> are you sure its performant enough ;)
13:43:03 <jkingkong> well, I imagine Tails is fairly optimized, and it's lazy so it'll just grab the head that it needs
13:43:06 <jkingkong> we'll see
13:43:27 <gwern> @src tails
13:43:27 <lambdabot> tails []         = [[]]
13:43:27 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
13:43:30 <jkingkong> I'm trying to parallelize this program, so it'd be silly if I didn't at least try to make it run quickly
13:43:57 <gwern> not sure I'd call it optimized, but I don't really see how it could be improved
13:44:13 <FunctorSalad> rumor is that @src is not precisely accurate
13:44:37 <jkingkong> FunctorSala: yes I concur
13:44:50 <jkingkong> @src sequence
13:44:50 <lambdabot> sequence []     = return []
13:44:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:44:51 <lambdabot> --OR
13:44:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:44:59 <mdmkolbe> @hoogle (Data a) => a -> f a
13:45:00 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
13:45:00 <lambdabot> Data.Data gmapMo :: (Data a, MonadPlus m) => (d -> m d) -> a -> m a
13:45:00 <lambdabot> Data.Data gmapMp :: (Data a, MonadPlus m) => (d -> m d) -> a -> m a
13:45:15 <jkingkong> > sequence [1,2,3,4,5]
13:45:16 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
13:45:16 <lambdabot>    arising from a use of `M86967426...
13:45:18 <gwern> FunctorSalad: sure but I also checked against the ghc repo
13:45:27 <gwern> same definition
13:45:35 <gwern> tails                   ‚à∑  [a] ‚Üí  [[a]]
13:45:39 <gwern> tails []                =  [[]]
13:45:42 <gwern> tails xxs@(_:xs)        =  xxs : tails xs
13:46:06 <dancor> F.U.D.Salad
13:46:12 <FunctorSalad> gwern: I don't have anything better in mind for tails either
13:46:37 <FunctorSalad> was just a generic comment :o
13:46:51 <EvanR> polymorphic comments
13:47:26 <dancor> :t sequence [1, 2]
13:47:27 <lambdabot> forall (m :: * -> *) a. (Num (m a), Monad m) => m [a]
13:48:07 <aavogt> comments aren't values
13:48:09 <dancor> a monad which is a number, there's a scary idea
13:48:30 <aavogt> > sequence [1,2]
13:48:31 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
13:48:31 <lambdabot>    arising from a use of `M52805348...
13:48:37 <FunctorSalad> commutativity would fail for most monads
13:48:45 <aavogt> > sequence [1,2] () :: Int
13:48:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:48:46 <lambdabot>         against inferred type ...
13:48:53 <FunctorSalad> of binary ops which are supposed to be comm.
13:48:55 <aavogt> > sequence [1,2] () :: [Int]
13:48:56 <lambdabot>   [1,2]
13:49:24 <aavogt> dancor: it's here already!
13:49:29 <jkingkong> > sequence [1,2,3,4] ()::[Int]
13:49:30 <lambdabot>   [1,2,3,4]
13:49:32 <dancor> oooooh
13:49:48 <jkingkong> well that was silly
13:49:59 <dancor> > (return 1)()
13:50:00 <lambdabot>   1
13:50:13 <dancor> > (return [(4, 5, 6)])()
13:50:14 <lambdabot>   [(4,5,6)]
13:50:14 <FunctorSalad> that seems nonstandard ;)
13:50:19 <aavogt> > [return 1, 1]
13:50:20 <lambdabot>   No instance for (GHC.Num.Num (m t))
13:50:21 <lambdabot>    arising from a use of `e_111' at <in...
13:50:45 <aavogt> > [return 1, 1, const (1::Int)]
13:50:48 <FunctorSalad> @let one = (1::Int)
13:50:50 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> GHC.Types.Int)
13:50:52 <lambdabot>  Defined.
13:50:54 <lambdabot>    arising fro...
13:51:12 <FunctorSalad> > (\() -> one) + (\() -> one)
13:51:13 <lambdabot>   *Exception: show: No overloading for function
13:51:17 <aavogt> > map ($ ()) [return 1, 1, const (1::Int)]
13:51:18 <lambdabot>   [1,1,1]
13:51:19 <FunctorSalad> > ((\() -> one) + (\() -> one)) ()
13:51:20 <lambdabot>   2
13:51:21 <gwern> comments have neither denotational nor operational semantics. truly useless!
13:51:54 <dancor> and comments can't even be dynamically reordered by the compiler for performance
13:52:16 <dancor> comonad
13:52:33 <gwern> dancor: they can be statically reordered to nothing
13:52:43 <Jafet> But they are never evaluated, think of the savings
13:52:48 <FunctorSalad> odd 'reordering' :p
13:52:59 <gwern> FunctorSalad: 0 is a number
13:53:02 <ski> > replicateM 2 pick `runAffine` "abc" :: [String]
13:53:03 <lambdabot>   ["ab","ac","ba","bc","ca","cb"]
13:53:03 <ski> > replicateM 2 grab `runAffine` "abc" :: [String]
13:53:04 <lambdabot>   ["ab","ac","bc"]
13:53:07 <ski> jkingkong : ^
13:53:30 <FunctorSalad> gwern: I just associated `reordering' with `bijection'
13:54:04 <gwern> I present you with no books. prove they are not in order :)
13:54:57 <FunctorSalad> they are... there merely is no reordering that turns something into nothing
13:55:02 <FunctorSalad> *blah*
13:55:44 <jkingkong> ski: i see it, nifty
13:56:19 <FunctorSalad> ("in order" starts with a universal q, so no books are in order....)
13:56:19 <EvanR> im trying to understand the notation in this pdf. page 17 bottom right panel. what are these horizontal rules http://lucacardelli.name/Talks/1996-10%20A%20Theory%20of%20Objects%20(OOPSLA%20Tutorial).pdf
13:56:31 <EvanR> i know i could 'just read the book', but i dont have it
13:57:33 <Botje> EvanR: it's a set of logic rules
13:57:49 <Botje> given the parts above the line, the part below is also true
13:57:49 <EvanR> so its saying.. 'if and only if' ?
13:58:02 <EvanR> so A | B means if A then B
13:58:37 <Botje> E |- x means "we can deduce x from the environment E"
13:59:37 <EvanR> ok
13:59:47 <FunctorSalad> EvanR: they're not so much claims as they *define* your logic
13:59:49 <ski> jkingkong : btw, i defined `pick',`grab',`runAffine' here ..
14:00:14 <FunctorSalad> they're just declarations that you may deduce the thing below the line from the thing above it
14:00:17 <ski> > replicateM 2 pick `runLinear` "abc" :: [String]
14:00:18 <lambdabot>   []
14:00:21 <ski> > replicateM 3 pick `runLinear` "abc" :: [String]
14:00:22 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
14:00:28 <EvanR> yes
14:00:29 <ski> > replicateM 4 pick `runLinear` "abc" :: [String]
14:00:29 <lambdabot>   []
14:00:34 <ski> > replicateM 3 grab `runLinear` "abc" :: [String]
14:00:35 <lambdabot>   ["abc"]
14:00:39 * EvanR rereading
14:02:43 <FunctorSalad> @typ (runAffine,runLinear)
14:02:45 <lambdabot> forall t (m :: * -> *) a t1 (m1 :: * -> *) a1. (MonadPlus m, MonadPlus m1) => (StateT [t] m a -> [t] -> m a, StateT [t1] m1 a1 -> [t1] -> m1 a1)
14:03:17 <ski> @type [runAffine,runLinear]
14:03:18 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => [StateT [t] m a -> [t] -> m a]
14:03:18 <aristid> :t replicateM 3 grab
14:03:19 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => StateT [a] m [a]
14:03:27 <aristid> :t grab
14:03:28 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => StateT [a] m a
14:03:30 <FunctorSalad> where did these come from?
14:03:52 <ski> FunctorSalad : i defined them, for the benifit of jkingkong (who's not with us anymore)
14:04:05 <EvanR> RIP
14:04:22 <ski> `pick' nondeterministically selects an element out of the list state
14:04:40 <ski> `grab' does the same, but insists on grabbing in the order given (so preserves order)
14:04:52 <ski> > replicateM 3 grab `runAffine` "abcd" :: [String]
14:04:52 <lambdabot>   ["abc","abd","acd","bcd"]
14:04:55 <ski> > replicateM 3 grab `runAffine` "abcde" :: [String]
14:04:56 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
14:05:20 <aristid> :t runAffine
14:05:21 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => StateT [t] m a -> [t] -> m a
14:05:51 <aristid> > grab `runAffine` "abcde" :: [String]
14:05:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:05:52 <lambdabot>         against inferred ty...
14:06:29 <FunctorSalad> > runAffine (put 'a') "xyz"
14:06:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:06:31 <lambdabot>         against inferred type...
14:06:37 <ski> i'd have defined `newtype Eater w m a = MkEater (StateT w m a)' with `w' being constrained to be in an `UnMonoid' class, if i could do that in lambdabot
14:06:40 <FunctorSalad> > runAffine (put "a") "xyz"
14:06:41 <lambdabot>   No instance for (GHC.Show.Show (m ()))
14:06:41 <lambdabot>    arising from a use of `M133574241...
14:07:25 <FunctorSalad> UnMonoid? :D
14:07:28 <alexyk> http://stackoverflow.com/questions/2284875/why-is-haskell-used-so-little-in-the-industry/2909230#2909230 contains a word "mewbie"
14:08:55 <ski> (basically, i need `unmempty :: UnMonoid m w => w -> m ()' and `unmappend :: UnMonoid m w => w -> m (w,w)' .. and also an `singleton :: FreeUnMonoid a w => a -> w' operation)
14:09:19 <aavogt> is there a problem if I get (a -> a) inferred as (GHC.Prim.Any -> GHC.Prim.Any)
14:09:31 <ski> well, i suppose one might possibly call it `CoMonoid' :)
14:09:35 <aavogt> or can the two be interchanged?
14:10:28 <ski> hm, actually, `unmempty' should have type `UnMonoid m w => m ()'
14:10:54 <ski> (which means that i need `unsingleton :: FreeUnMonoid m a w => a -> m ()')
14:11:08 <FunctorSalad> ski: that does look like a comonoid in the kleisli category of m...
14:11:23 <ski> yes, that's more or less what i'm after
14:11:45 <ski> (/me is unsure whether the "Free" prefix there is appropriate, though ..)
14:13:05 <gwern> alexyk: mewbie? is that a noobie that whines?
14:13:07 <ski> > put "a" `runAffine` "xyz"
14:13:08 <lambdabot>   No instance for (GHC.Show.Show (m ()))
14:13:08 <lambdabot>    arising from a use of `M581384913...
14:13:12 <ski> > put "a" `runAffine` "xyz" :: [()]
14:13:13 <lambdabot>   [()]
14:13:15 <alexyk> gwern: it's a new cat
14:13:24 <gwern> haha,
14:13:27 <ski> > (put "a" >> pick) `runAffine` "xyz" :: [Char]
14:13:28 <lambdabot>   "a"
14:13:32 <gwern> I approve of that word then
14:13:33 <ski> > (put "abc" >> pick) `runAffine` "xyz" :: [Char]
14:13:34 <lambdabot>   "abc"
14:13:39 <ski> > (put "abc" >> grab) `runAffine` "xyz" :: [Char]
14:13:40 <lambdabot>   "abc"
14:17:35 <FunctorSalad> apropos cats, somehow I find this to be an awesome display manager logo http://pictures.mastermarf.com/blog/2009/090516-bincat-is-intrigued.jpg
14:18:10 <ski> > replicateM 3 munch `runAffine` "abcde" :: [String]  -- for completeness
14:18:11 <lambdabot>   ["abc"]
14:18:53 <ski> (`munch' would be called `satisfy id', in Parsec ..)
14:24:17 <EvanR> FunctorSalad: i made it to the next page, and it says x (not in) dom(E)
14:24:19 <EvanR> whats dom?
14:24:45 <FunctorSalad> EvanR: 'domain'
14:24:56 <EvanR> whats that :S
14:25:31 <EvanR> ok, i guess it means x is not in E
14:25:32 <FunctorSalad> for a function A -> B, 'A' is called the domain
14:25:51 <EvanR> E is a set of x:X
14:26:04 <EvanR> where X is type
14:26:05 <FunctorSalad> apparently E is some 'Environment' there, so the domain would be the set of identifiers (or similar) that it assigns a value to
14:26:18 <FunctorSalad> ok, or a type in that case
14:26:31 <EvanR> so you could think of E as a function from identifiers to types
14:26:44 <FunctorSalad> yes
14:26:46 <EvanR> now itmakes sense, because i see under the line he appends x:A to E
14:28:18 <FunctorSalad> alexyk: odd posting... someone really dislikes haskell there ;)
14:28:20 <EvanR> why math people make up such funky symbols i dont know ;)
14:28:41 <EvanR> i miss the days when they just spoken english
14:29:05 <xerox> to have symbols that mean one and only one thing - it avoids misinterpretation of words - and it is very effective at it
14:29:05 <Peaker> because they accidentally defined xy to mean x*y and so they're stuck with 1-letter variable names
14:29:14 <Peaker> and they ran out of letters
14:29:23 <EvanR> haha
14:29:55 <Cale> I don't think most of the notations used by mathematicians are very strange at all.
14:30:09 <EvanR> one of the authors of this explains œÇ as 'the greek letter you never knew about' 'sorry thats the last one'
14:30:22 <Cale> Though in this case, the culprits are computer scientists borrowing notation from logicians ;)
14:30:24 <ulfdoz> I think, french is just an absurd language. ;)
14:30:39 <Peaker> http://userweb.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1300.html : "Whitehead made many wise remarks it is a pleasure to agree with, but I cannot share his judgement when he applauds the introduction of the invisible multiplication sign. The multiplication being so common, he praises the mathematical community for the efficiency of its convention, but he ignores the price"
14:30:45 <Cale> That's a final sigma, isn't it?
14:30:58 <EvanR> yes
14:31:05 <Cale> yeah
14:31:05 <Peaker> "The much heavier price is that the invisible multiplication all but rules out the introduction of multiple-letter identifiers, thus creating the need of symbols of other alphabets"
14:31:16 <Peaker> ^^ Dijkstra said it seriously, EvanR , not as a joke :)
14:31:35 <aavogt> subscripts
14:31:37 <EvanR> the central topic of his book, he named œÇ calculus
14:31:41 <ski> (.. some "conventions" are bad, like the common mixing up of a function and the value of the function in a point .. and confusion resulting from this, like "d f / d x", and "(x^2 * y + 2*x)'" and "d F[phi(x)] / d phi(x)")
14:31:42 <Cale> I don't think that's particularly the reason for single letter identifiers.
14:31:47 <FunctorSalad> Peaker: there are some multiletter ones, like..... "dom" ;)
14:31:48 <syntaxglitch> xerox, are mathematical symbols really unambiguous, though?
14:31:55 <EvanR> FunctorSalad: was just thinking of that one ;)
14:32:00 <Cale> The reason for single letter identifiers is that so expressions are small, and manipulating them is fast.
14:32:02 <FunctorSalad> "ker" "im"
14:32:03 <Peaker> FunctorSalad, Yes, he talks about the ambiguity raised by those (his example is "sin") as another problem
14:32:05 <syntaxglitch> it seems maths notation usually still has multiple meanings
14:32:25 <FunctorSalad> Peaker: at least in print it's disambiguated by the font
14:32:32 <Cale> If you have to write long words over and over again when manipulating expressions, you'll come to the conclusion that maybe you should use smaller names too :)
14:32:42 <xerox> homographs are no problem if there are definitions and self-contained context
14:32:50 <EvanR> well im not manipulating anything here, im just trying to read the statements
14:32:58 <syntaxglitch> to my mind, the difference is that mathematical notation ends up with overloaded precise meanings that are usually obvious from context
14:33:02 <Cale> I tend to use English when writing mathematics right up to the point where I have to manipulate things in a mechanical way, and then I switch to symbols.
14:33:10 <syntaxglitch> whereas natural language has overlapping vague meanings that are only sorta clear
14:33:16 <ski> FunctorSalad : seconded
14:33:30 <ski> er, s/FunctorSalad/Peaker/
14:33:40 <Cale> Yeah, for that reason, these notations are kind of stupidly chosen, because you're not actually mechanically proving things by hand using these rules.
14:33:40 <EvanR> 'if A is a type in E and x is not in the domain of E, then E with x:A is well formed' but on the other hand, its a powerpoint
14:33:46 <EvanR> in which case its there for shock value
14:33:54 <Cale> But if you were, then you'd find out the reason for their terseness.
14:34:24 <xerox> syntaxglitch: it's a faulty point, read old mathematical texts for yourself, something about algebra when the algebraic formalism was still under development, you'll change opinion
14:34:55 <syntaxglitch> xerox, well, my mathematical experience is fairly limited, just the impressions I've gotten
14:35:24 <Cale> syntaxglitch: The way mathematicians use natural language, it ends up being overloaded with precise meanings that are clear from context as well.
14:35:34 <syntaxglitch> Cale, makes sense
14:35:37 <xerox> I'll tell you, unless you are willing to go through hoops, they are inaccessible
14:36:10 <scree> mathematicians use natural language?
14:36:21 <scree> how novel
14:36:21 <Cale> scree: Heh, yes. "Natural" language :)
14:36:23 <FunctorSalad> what part is 'faulty'? I'd agree with "to my mind, the difference is that mathematical notation ends up with overloaded precise meanings that are usually obvious from context" and the following one
14:36:39 <syntaxglitch> speaking of which, anyone have tips on learning how to read "math" more fluently? More than about 15 symbols in a row and it all turns into a blur for me :(
14:36:44 <ski> (they use "natural language", i.e. mathematical jargon)
14:36:59 <Cale> syntaxglitch: Go slowly.
14:37:12 <xerox> find a reason to, and if it's strong enough, you'll succeed
14:37:44 <FunctorSalad> xerox: is it really specific to mathematics that stuff from another time is hard to decipher? ;)
14:37:53 <chrisdone> math reads too much like that crappy half pseudo code some people write
14:38:12 <scree> syntaxglitch: I guess the point is, once you understand the stuff a bit, you're not attempting to analyse every symbol
14:38:24 <syntaxglitch> maybe my brain is ruined from too much programming, but sometimes I mentally translate mathematical statements into something like Haskell type signatures to make sense of it
14:38:27 <syntaxglitch> which feels pretty silly
14:38:36 <xerox> it's not
14:38:45 * ski thinks that's a sign of sanity
14:38:56 <scree> it's like any other language (in some very partial sense)
14:39:00 <Cale> Well, it's not silly because of the Curry-Howard correspondence.
14:39:27 <munmob> does anyone know why first order logic is undecidable?
14:39:44 <syntaxglitch> Cale, it may be a legitimate translation but it's still clumsy
14:40:00 <syntaxglitch> Like speaking a foreign language by translating it in your head to and from your native language
14:40:08 <FunctorSalad> syntaxglitch: the process of translating itself probably helps you learn it :)
14:40:12 <syntaxglitch> I suppose
14:40:21 <ski> munmob : the domain of discourse can be infinite, and you can't in general decide whether a property holds for all, or for some, element of an infinite set, even if you can enumerate it
14:40:31 <syntaxglitch> I guess I just need some heavy immersion in math-ese to get used to it :\
14:40:40 <FunctorSalad> I think there's no secret that lets you understand the symbol salad more quickly... it just takes time to get the general idea; the problem is not just the notation
14:41:15 <scree> right; if you're thinking on a purely symbolic level, that's a sign that you don't really understand what's going on
14:41:18 <chrisdone> you know when someone's trying to demonstrate a programming concept, and instead of writing in a real formal language, or describing it in pros, they write some made up pseudo code and it's annoyingly ambiguous. math is always like that for me
14:41:18 <syntaxglitch> FunctorSalad, it's not understanding so much as fluency... I know what each symbol means, and how they combine, but a phrase of any complexity and everything gets muddled :(
14:41:20 <EvanR> and this is annoying. A <: B is used to mean A is a subtype of B. but that means A is 'bigger' than B. it has a superset of B's attributes
14:41:21 <munmob> ski how come its infinite?
14:41:29 <ski> munmob : it *can*be* infinite
14:41:42 <ski> (it can be any set at all)
14:41:55 <Cale> syntaxglitch: Well, okay, Haskell is probably not the best choice of formal language to translate things to.
14:41:59 <aavogt> EvanR: but are there more types A than B?
14:42:13 <EvanR> in this context theres only A and B
14:42:13 <aavogt> err other way around
14:42:16 <Cale> syntaxglitch: Something like first-order logic works better.
14:42:52 <aavogt> EvanR: I mean think of the < as the size of the set of those types, not the size of the set of properties they represent...
14:42:58 * syntaxglitch really wishes he'd spent more time learning real/useful math when he was in school. :(
14:43:15 <FunctorSalad> munmob: there is some mild extra requirement, "first order logic with a binary predicate symbol" or so
14:43:25 <munmob> ski right
14:43:29 <ski> EvanR : the "arrows" in the category of attribute sets goes in the opposite direction as the arrows in the category of records having those attribute sets, yes
14:43:47 <FunctorSalad> munmob: I think you can prove it by simulating a turing machine in this first-order-predicate-logic-with-a-binary-symbol
14:44:12 <scree> syntaxglitch: it's still worth stressing that what you want is an intuition about what the whole phrase means, not just the individual bits
14:44:24 <EvanR> the smallest type has the most attributes. the biggest type is empty set
14:44:49 <ski> EvanR : you might be interested in a book "Categories for Software Engineering" by JosÈ Luiz Fiadeiro ..
14:45:07 <ski> (which includes what i said just before as an example=
14:45:14 <ski> s/=/)/
14:45:42 <munmob> functorsalad ive heard about that but cant seem to find it online. have  you got a reference?
14:45:53 <syntaxglitch> scree, yeah, that's pretty much what I'm complaining about not having :(
14:46:11 <scree> syntaxglitch: that's specific to the individual field
14:46:32 <ski> EvanR : "set of attributes" is not the same as "set of records having a particular set of attributes"
14:46:39 <EvanR> ski: isnt that set infinite?
14:46:45 <EvanR> the second one
14:46:50 <ski> which set ?
14:47:25 <FunctorSalad> munmob: here's one for the claim at least... http://en.wikipedia.org/wiki/First-order_logic#Completeness_and_undecidability
14:47:26 <dancor> > let adjPairs = map (\ (x:y:_) -> (x, y)) . init . init . tails in adjPairs "hello"
14:47:27 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:47:32 <dancor> is that the coolest implementation?
14:47:34 <sbpaul> :D
14:47:46 <FunctorSalad> (it was indeed "one binary predicate symbol in addition to equality")
14:47:50 <EvanR> A = [x:Int, y:String], B = [x:Int], now A <: B but both have infinite records with that type
14:48:03 <ski> > [(x,y) | x:y:_ <- ["hello"]]
14:48:03 <sbpaul> > let adjaPairs y = map (\x->(x,x) y
14:48:03 <lambdabot>   [('h','e')]
14:48:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:48:07 <FunctorSalad> munmob: (second paragraph)
14:48:10 <sbpaul> @let adjaPairs y = map (\x->(x,x) y
14:48:10 <lambdabot>   Parse error: SemiColon
14:48:15 <sbpaul> > adjaPairs y
14:48:16 <lambdabot>   Not in scope: `adjaPairs'
14:48:19 <sbpaul> err
14:48:22 <munmob> functorsalad yeah but have you got a formal proof?
14:48:23 <sbpaul> @let adjaPairs y = map (\x->(x,x)) y
14:48:25 <lambdabot>  Defined.
14:48:26 <ski> > [(x,y) | (x:y:_) <- tails "hello"]
14:48:27 <sbpaul> > adjaPairs y
14:48:27 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:48:28 <lambdabot>   Couldn't match expected type `[a]'
14:48:28 <lambdabot>         against inferred type `SimpleRef...
14:48:34 <scree> > let adjPairs l = zip l (tail l) in adjPairs "hello"
14:48:35 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:48:50 <dancor> scree: ah, duh!
14:49:05 <dancor> ski: cool
14:49:16 <ski> > [(x,y) | x:y:_ <- tails "hello"]  -- hm, actually the brackets in the pattern wasn't needed
14:49:16 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:49:22 <dibblego> @type zip <*> tail
14:49:23 <lambdabot> forall b. [b] -> [(b, b)]
14:49:35 <ski> @quote aztec
14:49:35 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
14:49:38 <EvanR> category theory eh
14:49:46 <EvanR> how deep does this rabbit hole go
14:49:48 <ski> > (zip `ap` tail) "hello"
14:49:48 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:50:07 <sbpaul> haskell rocks
14:50:23 <dancor> bonus
14:50:33 <sbpaul> np: Ungl'Unl'Rrlh'Chchch - Ungl'Unl'Rrlh'Chchch
14:51:07 <ski> (and, naturally, you can use `do'-notation, instead of list comprehension, if you prefer
14:51:10 <ski> > do x:y:_ <- ["hello"]; return (x,y)
14:51:10 <lambdabot>   [('h','e')]
14:51:12 <ski> )
14:51:25 <ski> er, well, using `tails', like you should
14:51:31 <ski> > do x:y:_ <- tails "hello"; return (x,y)
14:51:31 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o')]
14:51:41 <FunctorSalad> munmob: I've never read the proof myself. Turing and Church proved it for the case of arithmetic http://en.wikipedia.org/wiki/Entscheidungsproblem but I don't know how readable their publications are :)
14:51:59 <FunctorSalad> (terminology-wise, if you're used to today's one)
14:52:13 <munmob> right
14:52:33 <Cale> munmob: Basically, it's a reduction to the halting problem. You can formulate lambda calculus (or pick your favourite Turing-complete system) and normalisability/halting as a first order theory. Thus determining the truth of statements in that theory will tell you whether certain programs halt, and so it shouldn't be computable in general.
14:58:58 <JoeyA> What's an easy way to interweave two lists?  interweave [1,3,5] [2,4] yields [1,2,3,4,5]
14:59:34 <EvanR> :t intercalate
14:59:36 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:59:51 <ski> @let (/\/) :: [a] -> [a] -> [a]; [     ] /\/ as1 = as1; (a:as0) /\/ as1 = a : (as1 /\/ as0)
14:59:52 <lambdabot>  Defined.
14:59:55 <JoeyA> I'm not so sure that does what I need
14:59:59 <JoeyA> (intercalate, that is)
15:00:00 <ski> > "abc" /\/ "de"
15:00:01 <lambdabot>   "adbec"
15:00:11 <ski> > [1,3,5] /\/ [2,4]
15:00:14 <EvanR> wave operator
15:00:15 <lambdabot>   [1,2,3,4,5]
15:00:26 <JoeyA> I've seen the /\/ operator used before.  Is it defined in the libraries?
15:00:40 <ski> i'm not sure
15:01:18 * ski 's seen it used in examples somewhere .. maybe in the book by Thompson
15:02:01 <ski> > fix $ \xs -> repeat 0 /\/ map succ xs
15:02:02 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
15:02:25 <ski> > fix $ \xs -> 0 : tail (xs /\/ map succ xs)
15:02:26 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
15:02:57 <ski> (i'm sure you can come up with other examples)
15:04:23 <Jafet> > let f n = repeat n /\/ f (n+1) in f 1
15:04:23 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
15:05:08 <JoeyA> Also, what about un-grouping a list?
15:05:13 <JoeyA> This is really neat:
15:05:20 <JoeyA> > [[1,2],[3,4],[5]] >>= id
15:05:21 <lambdabot>   [1,2,3,4,5]
15:05:29 <fxr> hpaste says database is locked
15:05:29 <ski> (aka multiplicity of `2's in natural numbers (or odd natural numbers))
15:05:53 <JoeyA> I'm wondering if it can be even better.
15:06:08 <ski> (hm, actually s/natural numbers/positive integers/)
15:06:30 <mux> JoeyA: yeah, this is to be expected since (>>=) in the list monad is flip concatMap; so >>= id is the same as concatMap id; so the same as just concat
15:06:46 <Peaker> JoeyA, (>>= id) = join = concat
15:06:49 <ski> which is the same as `join' in the list monad
15:07:14 <JoeyA> d'oh
15:07:15 <JoeyA> concat
15:07:23 <ski> @type join `asTypeIn` \join -> join []
15:07:24 <lambdabot> forall a. [[a]] -> [a]
15:08:46 <Peaker> @type asTypeIn
15:08:47 <lambdabot> forall a b. a -> (a -> b) -> a
15:09:05 <ski> @let interleave :: [[a]] -> [a]; interleave = concat . transpose
15:09:06 <lambdabot>  Defined.
15:09:43 <FunctorSalad> > (concatMap (\(x,y)->[x,y])) (zip [0,2 ..6] [1,3..7])
15:09:45 <lambdabot>   [0,1,2,3,4,5,6,7]
15:09:46 <FunctorSalad> ;)
15:10:24 <JoeyA> Cool
15:10:26 <FunctorSalad> only for equallengthous lists though
15:11:28 <Peaker> @pl (\x y -> [x,y])
15:11:28 <lambdabot> (. return) . (:)
15:11:31 <FunctorSalad> this doesn't do a merge though if you wanted a merge...
15:11:42 <Peaker> @type concat . zipWith ((. return) . (:))
15:11:45 <lambdabot>     Couldn't match expected type `[[a]]'
15:11:45 <lambdabot>            against inferred type `[a1] -> [[a1]]'
15:11:45 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
15:11:50 <Peaker> @type (concat.) . zipWith ((. return) . (:))
15:11:51 <lambdabot> forall a. [a] -> [a] -> [a]
15:11:58 <FunctorSalad> (making a sorted list from two sorted lists)
15:12:10 <Peaker> > ((concat.) . zipWith ((. return) . (:))) [1,2,3,4] ['a','b','c']
15:12:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:12:11 <lambdabot>    arising from the literal `1...
15:13:23 <JoeyA> Also, is there a nice way to trim x from the start and end of a list.  One way is to drop/reverse/drop/reverse
15:14:46 <EvanR> thats the nice way
15:15:00 <EvanR> Data.Sequence can do it more efficiently though
15:16:34 <FunctorSalad> even with a list it seems like you could do it more efficiently by keeping the n-th last cons cell and mutating the cdr to nil once you reach the end ;)
15:16:50 <FunctorSalad> (sorry for blasphemy)
15:16:54 * Silvah wishes he could run some Haskell code on GBA...
15:17:25 <EvanR> FunctorSalad: insane! but perfectly possible in these imperative calculi in the pdf ;)
15:17:44 <FunctorSalad> EvanR: it can probably be translated to something mutation-free...
15:17:48 <FunctorSalad> just haven't thought about it
15:19:36 <FunctorSalad> (hmm and you'd need to keep a state of all the n last cells, not just one)
15:20:04 <FunctorSalad> assuming you want to (drop n) from the end
15:20:05 <Makoryu> Hey, will there be a sound library in a future version of the Haskell Platform?
15:20:26 <Silvah> Probably not.
15:20:34 <Saizan> there was OpenAL in the extra-libs
15:20:59 <Makoryu> Hmmm.
15:21:07 <Makoryu> How about gtk2hs?
15:21:10 <EvanR> is portaudio supported on more than just windows osx and linux, and bsd
15:21:13 <Cale> > let dropFromEnd n xs = zipWith const xs (drop n xs) in dropFromEnd 4 [1..10]
15:21:14 <lambdabot>   [1,2,3,4,5,6]
15:21:27 <EvanR> s/portaudio/OpenAL/
15:21:32 <Cale> JoeyA: ^^
15:22:06 <Saizan> Makoryu: ah, possibly, you should ask the maintainers if they are going to propose it
15:22:07 <Cale> This way has the advantage that it works on infinite lists (where it acts as the identity, of course :)
15:22:19 <Cale> > let dropFromEnd n xs = zipWith const xs (drop n xs) in dropFromEnd 4 [1..]
15:22:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:22:30 <Makoryu> Saizan: I'd think it would be even more difficult to get standardized than an audio library >_>
15:23:09 <Makoryu> Saizan: And it probably warrants a custom build tool, rather than just a binary installer
15:23:17 <FunctorSalad> (maybe making a counting pass first is faster for large n than the n-last-seen-cells-window I had in mind)
15:23:41 <Saizan> Makoryu: mh, why?
15:24:30 <havlis> Hi, again.
15:24:41 <Cale> hello
15:25:07 <Makoryu> Saizan: Because installing gtk2hs requires that GTK itself be installed somewhere.
15:26:36 <havlis> Absolutely predictable - if you are going to install bindings to some library, you need that library.
15:29:01 <Saizan> Makoryu: yeah, but if gtk2hs has a binary installer i can't see why it can't continue to have one once in the platform
15:29:12 <Saizan> s/if/since/
15:29:22 <EvanR> "would you like to install directx?"
15:29:25 <EvanR> no
15:29:36 <Makoryu> Saizan: That makes extra requirements for the platform though
15:29:54 <Makoryu> Saizan: Requirements which might be redundant, or conflict with some users' setups
15:30:10 <hstefan> I'm using gtk2hs and I need to get value of field and apply and a function that receives a String. How can I do this?
15:30:57 <hstefan> and aply a function*
15:31:23 <hstefan> apply* GODAMM KEYBOARD
15:31:38 <Cale> hstefan: 'field'?
15:31:51 <havlis> With which part you have a problem?
15:33:17 <havlis> :t ap ((:) . toUpper . head) tail . fix . const . reverse
15:33:18 <lambdabot> [Char] -> [Char]
15:33:30 <havlis> Char?
15:33:36 <havlis> er
15:34:01 <Cale> entryGetText :: EntryClass  self => self -> IO  String
15:34:18 <Cale> By "field", do you mean an Entry widget?
15:34:43 <ski> > let primes = sieve [2..]; sieve (p:ns) = p : sieve [n | n <- ns , n `mod` p /= 0] in map (graph product) . zipWith take [1..] . transpose $ [map (p^) . fix $ \xs -> L.interleave (replicate (pred p) (repeat 0) ++ [map succ xs]) | p <- primes]
15:34:44 <lambdabot>   [([1],1),([2,1],2),([1,3,1],3),([4,1,1,1],4),([1,1,5,1,1],5),([2,3,1,1,1,1]...
15:35:59 <hstefan> the entry.
15:36:05 <havlis> > let something = yadda yadda yadda in whatever -- make it work ;)
15:36:06 <lambdabot>   Not in scope: `yadda'Not in scope: `yadda'Not in scope: `yadda'Not in scope...
15:36:26 <hstefan> havlis: the problem is that 'entryGetText entry'
15:36:30 <hstefan> returns an IO String
15:36:38 <Cale> hstefan: So, you run that action
15:36:39 <hstefan> and I need a 'common' string
15:36:44 <Cale> hstefan: and you get a String
15:36:48 <Axman6> o.O
15:37:02 <hstefan> let me show you the error
15:37:18 <havlis> hstefan: you need liftM, amirite?
15:37:20 <Cale> hstefan: do ...; s <- entryGetText myEntryWidget; ... use s :: String here
15:37:40 <hstefan> Cale: thank you
15:38:06 <Cale> hstefan: The do-block expression as a whole will be an IO action
15:38:39 <Cale> hstefan: In general,  v <- x  inside a do-block means "run the action x, giving its result the name v"
15:39:01 * Axman6 thinks it would be a good idea to learn how to use the IO monad before going any further with gtk2hs, which is almost completely IO based
15:39:22 <ski> > let primes = sieve [2..]; sieve (p:ns) = p : sieve [n | n <- ns , n `mod` p /= 0] in map (graph (product . zipWith (^) primes)) . zipWith take [1..] . transpose $ [fix $ \xs -> L.interleave (replicate (pred p) (repeat 0) ++ [map succ xs]) | p <- primes]
15:39:23 <lambdabot>   [([0],1),([1,0],2),([0,1,0],3),([2,0,0,0],4),([0,0,1,0,0],5),([1,1,0,0,0,0]...
15:39:39 <havlis> Cale: ORLY? Actions are IO things, whereas do-block is monadic thing.
15:40:07 <ski> havlis : `IO' "things" is an example of monadic "things"
15:40:35 <Cale> havlis: Well, with other monads, the actions will have something else in place of IO, but what I said will still be valid.
15:40:37 <EvanR> @src IO
15:40:37 <monochrom> Let's give Cale a proper lecture on monad and do! <duck>
15:40:37 <lambdabot> Source not found. Maybe you made a typo?
15:41:12 <hstefan> http://codepad.org/0qdwVjml here's my code and the error...
15:41:48 <Cale> trieList ((entryGetText searchEntry))
15:41:51 <Cale> ^^ this is the error
15:41:58 <Cale> trieList wants a String, not an IO String
15:42:12 <Cale> You have to run the action, like I showed you, to get a String
15:42:46 <FunctorSalad> btw can we get <$> into the prelude already? ;)
15:42:47 <havlis> Cale: well, I thought that actions are IO-only, and no other monad has them.
15:42:50 <Cale> So, on the line before that one, you might write    searchText <- entryGetText searchEntry
15:43:02 <FunctorSalad> import Control.Applicative((<$>)) *sigh*
15:43:11 <Cale> and then replace the ((entryGetText searchEntry)) on the line in question with searchText
15:43:23 <hstefan> hmm
15:43:24 <Cale> (which will then be a String, and not an IO String
15:43:35 <hstefan> let me try it then
15:43:36 <Cale> hstefan: when you write  v <- x
15:43:39 <Cale> if x :: IO t
15:43:42 <Cale> then v :: t
15:43:45 <kmc> #haskell: where the recipe is not the cake
15:43:51 <Cale> > cake
15:43:52 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
15:43:53 <FunctorSalad> and with different precedence than (.) while we're at it :o
15:43:58 <geheimdienst> > recipe
15:43:59 <lambdabot>   Not in scope: `recipe'
15:44:07 <geheimdienst> > recipe != cake
15:44:08 <lambdabot>   Not in scope: `recipe'Not in scope: `!='
15:44:13 <geheimdienst> > recipe == cake
15:44:14 <lambdabot>   Not in scope: `recipe'
15:44:16 <FunctorSalad> > (+2) . (*2) <$> [1,2,3]
15:44:18 <lambdabot>   [4,6,8]
15:44:21 <FunctorSalad> hmm
15:44:30 <FunctorSalad> thought that was illegal
15:45:05 <FunctorSalad> > (+2) . (*2) `fmap` [1,2,3]
15:45:06 <lambdabot>   Precedence parsing error
15:45:06 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.Base.fma...
15:45:09 <FunctorSalad> ah
15:45:13 <Makoryu> :t x
15:45:14 <lambdabot> Expr
15:45:18 <Cale> hstefan: You can think of a value of type IO String as a sort of program which will possibly do some I/O before producing a String value as its result.
15:45:26 <geheimdienst> > ((+2) . (*2)) `fmap` [1,2,3]
15:45:27 <lambdabot>   [4,6,8]
15:45:48 <hstefan> Cale: thank you so much
15:45:53 <Cale> hstefan: These values can be passed around between functions and run as many times as you like (having effects each time)
15:46:07 <Cale> hstefan: But you can't just write them in place of their results, for this reason.
15:46:40 <hstefan> humm...
15:46:41 <Cale> and normal Haskell evaluation will never cause them to execute
15:47:17 <Cale> They'll only get executed as part of executing other IO actions, and eventually, the IO action called main gets executed, which starts the whole thing off.
15:47:58 <Cale> hstefan: Consider something like this:
15:48:08 <Cale> forever x = do x; forever x
15:48:11 <havlis> What, barring return and fmap, does a monad need, according to one of alternative definitions?
15:48:20 <Cale> havlis: join
15:48:31 <hstefan> aaaaaaaahhh
15:48:43 <hstefan> finally understood
15:49:00 <Cale> hstefan: This is a function which, given an IO action, will produce an IO action which will run that action over and over forever.
15:49:12 <havlis> Cale: thank you. (I wonder how many times I wrote this one already...
15:49:33 <Cale> hstefan: We can do lots of other neat things:
15:49:45 <Cale> replicateM 0 x = return []
15:50:04 <Cale> replicateM n x = do v <- x; vs <- replicateM (n-1) x; return (v:vs)
15:50:47 <Cale> replicateM n x, when run, will run the action x, n times over, and collect a list of the results.
15:51:05 <Cale> We don't need built-in loop constructs because we can write our own and put them in the library ;)
15:51:09 <hstefan> getString IO String -> String
15:51:27 <hstefan> i was trying to do some function like this
15:51:31 <hstefan> oops, I forgot the ::
15:51:34 <Cale> Yeah, that's not possible, by design.
15:51:48 <havlis> > (ap ((:) . toUpper . head) tail . fix . const . reverse) "havlis" -- if someone wondered who am I actually
15:51:49 <lambdabot>   "Silvah"
15:52:02 <Cale> Any function of type IO String -> String will ignore the IO String parameter, and thus will be a constant function.
15:52:38 <Cale> There's no way for Haskell evaluation to execute IO actions, because that would ruin all the nice properties that we want evaluation of Haskell expressions to have.
15:52:55 <ivanm> havlis: so.... why the change of nick?
15:53:19 <Cale> In particular, we want evaluation of expressions into values to always happen in the same way -- evaluate the same expression, and you should always get the same answer.
15:53:36 <Cale> If execution of IO actions might happen, then the results might be different every time.
15:54:23 <Cale> That would make understanding programs harder than it needs to be, expecially as Haskell doesn't use a determined evaluation order (the compiler gets to choose what order to evaluate expressions in)
15:54:30 <havlis> It *is* possible, though it's *very* unsafe.
15:54:51 <hstefan> Cale: I don't want to be arrogant, but how do I simple get the String?
15:54:58 <havlis> Duh, I'm too slow again!
15:55:04 <Cale> Well, okay, it's possible in roughly the same sense as it's possible to go and modify your compiler. When writing normal programs, you don't do it.
15:55:16 <Cale> hstefan: You run the action inside of a do-block
15:55:31 <havlis> ivanm: I was forced to... you do not want to know details...
15:55:36 <Cale> hstefan: The do-block as a whole becomes an IO action.
15:55:59 <Cale> hstefan: But you get to use the String result to decide what the rest of the do-block should do.
15:56:23 <Makoryu> hstefan: Basically, you need a line like "foo <- getAString" in your block.
15:56:31 <Cale> hstefan: When you write  v <- x  inside a do-block, if x :: IO String, then v :: String
15:57:37 <Cale> and so for the remainder of the do-block, you can use v like any String, and pass it off to functions which require String arguments and so on.
15:58:02 <havlis> ivanm: also, this one looks so innocently ;)
15:58:24 <Cale> hstefan: Does that make sense?
15:58:28 <Cale> For example...
15:58:40 <Cale> getLine :: IO String -- gets a line of text from the user
15:58:43 <hstefan> Dammit, why am I so dumb.
15:58:50 <Cale> reverse :: String -> String -- reverses a line of text
15:58:51 <havlis> You are not.
15:59:02 <Cale> putStrLn :: String -> IO ()  -- prints a String on the screen
15:59:09 <Cale> and we can put them together like this:
15:59:10 <havlis> I also have problems with that.
15:59:18 <Cale> do x <- getLine; putStrLn (reverse x)
15:59:22 <havlis> Therefore, I do not even try to understand these things.
15:59:40 <Cale> See?
15:59:47 <hstefan> onClicked searchButton (Model.treeViewSetModel treeview (listStoreNew (trieList (do v <- $ entryGetText searchEntry) (triePrefix t1 (do x <- $ entryGetText searchEntry)))))
15:59:51 <hstefan> something like this then?
16:00:07 <Cale> hstefan: Stop trying to cram it into the same line
16:00:31 <monochrom> also "(do v <- $ entryGetText searchEntry)" is probably syntax error
16:00:33 <Cale> There is a way you could do that, but that line is more than long enough already.
16:01:07 <Cale> and the way involves a library function that maybe just complicates matters if you're a beginner
16:01:42 <Cale> So for now, just run entryGetText searchEntry on the line before in the big do-block that you're sitting inside
16:01:59 <havlis> <$> and <*> do not complicate anything, stop lying :P
16:02:32 <Cale> http://codepad.org/X9kyrxrt -- like this
16:02:44 <Cale> Er, oops
16:02:48 <Cale> Looks like you have more of them
16:03:13 <Cale> The other instance of (entryGetText searchEntry) needs to be replaced as well
16:04:24 <Cale> Oh, but then you have another problem, listStoreNew is the same way.
16:04:36 <Cale> So you'll also want to run that, on a separate line
16:04:37 <hstefan> it's the same
16:05:38 <Cale> http://codepad.org/Z41MMeNR -- so like this now
16:06:22 <hstefan> I strill getting errors
16:06:25 <Cale> oops
16:06:33 <Cale> tsk, I accidentally the whole $
16:06:34 <hstefan> still*
16:06:38 <mux> whoa, handwritten GTK+ UI construction code. do you know about GtkBuilder?
16:07:00 <mux> I personally cannot be bothered to write all those boring new/packstart lines myself
16:07:00 <hstefan> mux: I don't.
16:07:13 <Cale> http://codepad.org/2xXlj0BU
16:07:29 <mux> you could use glade3 and create most of the static UI parts with your mouse, by dragging and dropping widgets
16:07:32 <mux> just saying ;-)
16:07:35 <Cale> There might still be problems with that, I don't have your Trie module.
16:08:00 <havlis> It's 1:05 am here, good night.
16:08:08 <Cale> g'night havlis
16:08:13 <hstefan> wtf, when I click the button the program finishes O_O
16:08:27 <hstefan> anyway, thank you all
16:09:14 <JoeyA> Is there a shorter way to say (if x == y then 0 else 1) ?
16:09:34 <Botje> fromEnum $ x /= y
16:09:36 <monochrom> > fromEnum ("x"=="x")
16:09:36 <lambdabot>   1
16:10:23 <hstefan> http://codepad.org/xUid1FrE
16:10:44 <hstefan> Cale: do you want my trie module then?
16:10:50 <Cale> hstefan: Might be nice :)
16:10:56 <hstefan> oki
16:11:10 <Cale> hstefan: Here's where we could really use someone who knew what they were doing with Gtk2Hs :)
16:11:44 <hstefan> http://codepad.org/CbJ2yMS6
16:12:12 <hstefan> gtk2hs has many issues
16:12:25 <hstefan> I was thinking about go for qthaskell
16:15:11 <hstefan> the problem is that I has just more 3 days to finish this @_@
16:15:19 <hstefan> I have*
16:15:24 <dons> hstefan: ? gtk is nicely installable via cabal. what issues does it have?
16:15:27 <hstefan> I fail at english, lol
16:15:34 <dons> qthaskell in comparison is unused. :/
16:15:51 <dons> gtk2hs or wxHaskell are the two options for widely used, documented gui libs
16:15:54 <hstefan> dons: then I am the problem hehe.
16:16:38 <hstefan> ah
16:16:58 <hstefan> looking at the error, it's something with the renderer
16:16:59 <Saizan> when using gtk2hs you might also use docs/tutorials for the bare C lib
16:17:28 <hstefan> I am learning gtk2hs using the reference, it's a miracle that I can create a window. lol
16:19:28 <ivanm> dons: why do you package haskell-updater up for arch when it's a tool for gentoo?
16:21:35 <hstefan> (ghc.exe:4768): Gtk-CRITICAL **: gtk_tree_view_append_column: assertion `column->tree_view == NULL' failed
16:21:38 <hstefan> <interactive>: CellLayout: don't know how to convert iter TreeIter 1301868562 0 0 0 from model 0x06aa91e8 to model 0x06aa91d0. Is it possible that you
16:21:42 <hstefan> are setting the attributes of a CellRenderer using a different model than that which was set in the view?
16:21:47 <hstefan> how do I change this? :S
16:21:50 <hstefan> and fix...
16:22:31 <Cale> hstefan: Yeah, I don't really understand why GTK doesn't like what we're doing.
16:22:38 <Cale> dcoutts: Are you around, you'd know :)
16:23:28 <Cale> oh...
16:23:35 <Cale> heh, I see
16:23:49 <Cale> Well, this program doesn't do what we want it to do anyway
16:26:13 <Cale> Ah, and we still refer to the old 'list' model later in the program. That might be the problem
16:26:24 <Cale>     onClicked searchButton $ do searchText <- entryGetText searchEntry
16:26:24 <Cale>                                 newList <- listStoreNew (trieList searchText (triePrefix t1 searchText))
16:26:24 <Cale>                                 Model.treeViewSetModel treeview newList
16:26:27 <Cale> ^^ first of all
16:26:50 <Cale> Actually, might want to move the block down...
16:27:05 <Cale>     onClicked searchButton $
16:27:06 <Cale>       do searchText <- entryGetText searchEntry
16:27:06 <Cale>          newList <- listStoreNew (trieList searchText (triePrefix t1 searchText))
16:27:06 <Cale>          Model.treeViewSetModel treeview newList
16:27:15 <Cale> There, more readable :)
16:27:24 <Cale> This still crashes.
16:28:08 <Cale> I'm betting it's that you refer to 'list', the old model, later in the program, and it gets confused about what to do, let me look into that :)
16:30:16 <Cale> GTK is so needlessly complicated sometimes...
16:30:23 <dons> ivanm: because it builds.
16:30:34 <dons> ivanm: the policy is to mirror hackage in AUR.
16:30:39 <dons> we don't discriminate.
16:31:05 <tommd> lol, thats rather funny.  Not saying you should bother investigating each package for if it makes sense in AUR, but funny still.
16:31:14 <Cale> (Probably has something to do with it being a C library and C having essentially no standard datastructures)
16:31:24 <dons> if it builds, it goes in.
16:31:42 <Cale> Maybe we should, instead of constructing a new ListStore, modify the old one.
16:33:55 <Silvah> Apparently I'm unable to fall asleep now, so hello once again...
16:33:56 <Cale> hstefan: there, it works. Let me paste the code :)
16:34:23 <Cale> hstefan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25800#a25800
16:34:56 <Cale> hstefan: The trick is not to stop using the ListStore we originally created for the TreeView
16:35:07 <Cale> hstefan: and instead, clear it, and populate it with new elements
16:35:09 * hackagebot MonadCatchIO-mtl-foreign 0.1 - Polymorphic combinators for working with foreign functions  http://hackage.haskell.org/package/MonadCatchIO-mtl-foreign-0.1 (AntoineLatter)
16:35:34 <Cale> hstefan: You'll notice that I used a function called mapM_ in there
16:35:34 <hstefan> yaaaaaay
16:35:38 <hstefan> it woooorks
16:35:46 <hstefan> what does mapM_ do?
16:35:58 <Cale> mapM_ is like a for-each loop. We could write it like this:
16:36:11 <Cale> mapM_ f [] = return ()
16:36:26 <Cale> mapM_ f (x:xs) = do f x; mapM_ f xs
16:36:40 <hstefan> ah
16:36:41 <hstefan> got it
16:37:06 <Cale> The _ is a convention which means that it discards the results of the actions
16:37:09 * hackagebot MonadCatchIO-transformers-foreign 0.1 - Polymorphic combinators for working with foreign functions  http://hackage.haskell.org/package/MonadCatchIO-transformers-foreign-0.1 (AntoineLatter)
16:37:28 <Cale> mapM is an analogous function which collects the results into a list, but here we don't care about them
16:37:45 <hstefan> yeah, I've known about _
16:38:31 <Cale> Actually, listStoreAppend does return an Int, telling us the index of the resulting element. If we used mapM instead, we could get the list of indices (which would probably just be [1,2,3,...,n]
16:38:40 <Cale> (or maybe [0,1,2,...n-1])
16:38:43 <hstefan> aah
16:39:21 <hstefan> let me gess, what you're doing in that code is clear the list and then copy the new values into there?
16:39:28 <Cale> yeah
16:39:34 <hstefan> ah
16:39:44 <Silvah> Still about monads (specifically, IO monad), eh?
16:39:44 <hstefan> isn't it a lack of performace?
16:40:02 <Cale> The rest of your code sets up a cell renderer and all sorts of other stuff attached to the ListStore
16:40:36 <Cale> My guess is that doing all that over again for a new ListStore would be more expensive (and certainly more awkward) than just clearing the existing one and sending it a bunch of new items
16:41:08 <Cale>     Model.cellLayoutSetAttributes col renderer list
16:41:08 <Cale>             $ \ind -> [Model.cellText := fst(ind)]
16:41:26 <Cale> ^^ here you refer to the original ListStore, 'list'
16:41:28 <edwardk> @remember gwern 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras, and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero. Just like your statistics. '
16:41:28 <lambdabot> Done.
16:41:55 <Cale> and I think you'd need to redo that step at least, to make it work with a new ListStore
16:42:16 <Cale> (But I don't really know enough about GTK to confidently make that approach work :)
16:43:04 <Saizan> edwardk: where's that from?:D
16:43:29 <edwardk> Saizan: it popped up as i skimmed the scrollback buffer ;)
16:43:41 <gwern> edwardk: that was a quote
16:43:48 <gwern> hence my little quote marks
16:43:51 * gwern makes airquotes
16:43:53 <edwardk> =)
16:44:00 <gwern> ie. someone else wrote that
16:44:03 <edwardk> yeah but now i can find it with @quote gwern ;)
16:44:05 <Cale> I think what the error message we saw means is that the TreeView was still somehow referring to an "Iter" which is presumably encoding some kind of offset into the old ListStore, but when it went to get the element from its current ListStore, it found that it wasn't the one it had expected.
16:45:43 <edwardk> @forget gwern 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras, and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero. Just like your statistics. '
16:45:43 <lambdabot> Done.
16:45:57 <edwardk> @remember not-gwern 'You say you're the world's greatest systems programmer, but all you academics know how to do is prove academic theorems about the module substructure over nilpotent Lie algebras, and even then you can't manage to generalize it past the two-step case. Your method fails to scale, because in the real world, nilpotent Lie algebras can take as many as ten steps to get to zero. Just like your statistic
16:45:57 <lambdabot> Done.
16:46:02 <edwardk> there =-P
16:46:10 <Silvah> lol
16:46:16 * gwern ponders. it's not incorrect, but it's also somehow not correct too
16:46:16 <EvanR> not-gwern is going to be pissed
16:46:54 <edwardk> i've narrowed the set of authors down by 1. several billion to go, but we can get there
16:47:39 <Cale> http://factor-language.blogspot.com/2010/05/comparing-factors-performance-against.html
16:47:48 <Cale> It's from an anonymous comment to that
16:48:26 <Silvah> You have too much time.
16:48:41 <EvanR> does lazy evaluation and side effects make sense
16:48:49 <gwern> Silvah: he has too much google-fu
16:49:20 <Silvah> Nothing makes sense, so they do not too.
16:49:40 <Cale> I just took a fragment of the comment, put double quotes around it and put it in Google, and there was a single result.
16:50:07 <Silvah> > let 5 = 6 in 7
16:50:08 <lambdabot>   7
16:50:11 <Silvah> lol
16:50:22 <Silvah> It is legal?
16:50:30 <Cale> EvanR: "Yes", but it would be difficult (next-to-impossible, but not impossible) to program with, and you have to agree to always use lazy evaluation then.
16:50:50 <Saizan> > let x@5 = 5 in x
16:50:51 <lambdabot>   5
16:50:55 <Saizan> doh.
16:50:57 <EvanR> so it wouldnt make sense to have the side effecting operations be strict
16:50:58 <Saizan> > let x@5 = 6 in x
16:50:59 <lambdabot>   *Exception: <interactive>:1:145-151: Irrefutable pattern failed for pattern...
16:51:05 <EvanR> and everything else be lazy
16:51:07 <Cale> EvanR: Haskell doesn't actually specify that compilers are required to use lazy evaluation all the time, and GHC in practice evaluates some things strictly when it can prove there's no harm in doing so.
16:51:40 <Cale> EvanR: That wouldn't help. The evaluation order would just be crazy then.
16:52:08 <Cale> (Even harder to follow than if you just stuck with lazy all the time)
16:52:28 <mauke> print (readLn - readLn)
16:52:32 <Cale> If you're going to change between different evaluation orders, it's rather important that side effects don't happen as a result of evaluation.
16:52:38 <EvanR> it seems like that is how haskell works at the top level with IO
16:52:43 <Cale> At least, if you want to understand what your program does.
16:52:54 <Cale> EvanR: *Evaluation* never causes IO actions to occur.
16:53:07 <EvanR> no thats why im saying top level
16:53:11 <Cale> EvanR: It only turns expressions into values
16:53:19 <EvanR> main = do x; y; z
16:53:22 <Cale> IO actions are executed separately
16:53:43 <Silvah> Never...?
16:53:44 <EvanR> x is a complex IO action, so it is fully evaluated and executed before y, right?
16:53:57 <EvanR> and y is a lazy list definition
16:54:01 <Cale> Evaluation will turn that do-expression into an IO action proper, which is a value encoding what to do, and then the executor gets its hands on it and starts carrying out the described steps.
16:54:06 <EvanR> now z can use half of y lazily
16:54:09 <mauke> depends on the definition of >>
16:54:34 <Cale> (Well, really, the steps are interleaved -- it only evaluates enough to determine the first thing to do, and then executes that, and then goes back to evaluating some more)
16:54:54 <EvanR> sounds pretty hard to follow as-is
16:55:06 <Cale> But the point is you don't have to follow the order of evaluation
16:55:18 <Cale> The order of execution is the only thing which really matters to what the program does
16:55:28 <Cale> and it is encoded explicitly in the IO action
16:55:43 <Cale> That is, the order in which the steps are executed are part of that IO value.
16:56:11 <Cale> You might imagine, somewhat perversely, that IO t values are internally chunks of C code.
16:56:29 <Cale> Evaluation would only work out what that C program is, not run it.
16:56:30 * Silvah thinks that eager evaluation is very easy in comparison.
16:57:06 <Cale> Execution would be like a C interpreter sitting there running the C program
16:57:09 <EvanR> yes. so lets consider an imperative language as a nested sequence of let x = y in ... where y can have a side effect, now the order of execution is clear. but what if you said any y that has no side effects is not fully evaluated until needed
16:57:30 <EvanR> still clear?
16:57:39 <ivanm> dons: any particular reason for having that policy? just because it's easier than cherry-picking packages?
16:57:48 <Cale> EvanR: Sort of...
16:58:24 <Cale> EvanR: So you're saying that the presence of any potential effects automatically means that the whole expression is to be evaluated strictly?
16:58:45 <EvanR> it makes sense in my head, maybe not justifiably so
16:59:42 <Cale> In any case, I don't really see why you'd want to do this :)
16:59:59 <Cale> I mean, I suppose you might be able to restrict things enough to make it work
17:00:35 <EvanR> an alternative is to have no side effects, another alternative is to strictly evaluate everything.
17:00:42 <Cale> You could also just have a strict language with laziness annotations, though that tends to result in libraries which are stricter than they need to be, and destroys most of the value of having lazy evaluation around, which is the compositionality benefits.
17:01:03 <EvanR> right, lazy seems good by default
17:01:47 <Cale> After programming in Haskell for long enough, having random effects go off as expressions get evaluated just seems perverse to me :)
17:01:54 <EvanR> yes it does
17:02:03 <Cale> Even though it's exactly what every other language in the universe does.
17:02:06 <EvanR> yes
17:02:15 <Silvah> Every...?
17:02:20 <Cale> Well, almost
17:02:53 <dons> ivanm: indeed
17:02:54 <EvanR> i wonder if theres a very large number of communicating civilizations in andromeda galaxy all of which use lazy languages
17:03:01 <EvanR> because they are so advanced
17:03:02 <dons> ivanm: and who knows what people do with the code
17:03:56 <EvanR> Cale: would you rather have laziness annotations (everywhere) or side effect annotations (not everywhere)
17:03:57 <Axman6> hey dons, you wouldn't happen to know when that video of the L4.verified talk will be available would you?
17:04:42 <radarsat1> can someone help me, i'm trying to get a callback system to work and GHC seems to be refusing to compile "export dynamic".
17:04:55 <radarsat1> is there a new way to do this, I might be using old docs
17:05:27 <dons> Axman6: not yet, but i can assure you we have recorded the last 3 talks, and they're in post-processing. i'm negotiating a regular timetable for the video releases (and also where we host them)
17:05:32 <dons> expect to see something up next week
17:05:57 <dons> there's a bit of post-prcoessing we do: add galois front page, link to slides, some editing
17:06:19 <EvanR> Cale: an example would be an imperative oo language like above where most method calls are lazy and pure, but some methods cause side effects and they have a ! in their name or something, and are here i am determining what that particular method invocation would mean for the rest of the code around it
17:06:39 <Axman6> dons: excellent :)
17:06:52 <radarsat1> the little program at http://www.haskell.org/hdirect/ffi-11.html gives me an error "parse error on input `dynamic'"
17:06:55 <Axman6> dons: any idea what format they'll be in?
17:07:10 <radarsat1> for the line defining mkCallback
17:07:14 <dons> we're a medium-sized company, so we don't have a full time media person :) probably .avi and whatever else we can do
17:07:21 <dons> and hosted on youtube or vimeo as well
17:07:26 <Axman6> ah, good
17:08:07 <EvanR> im going to model this and see where it goes
17:09:04 <Silvah> Good night, this time seriously. I hope I did not annoy you too much.
17:12:51 <mauke> radarsat1: http://codepad.org/OG9fCpfT
17:13:15 <mauke> radarsat1: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
17:13:46 <mauke> disclaimer: I don't know if it works, but it seems to compile
17:14:55 <radarsat1> ah, thank you, that compiles for me
17:15:06 <radarsat1> i couldn't find this in the GHC 6.12 docs
17:26:00 * FunctorSalad wonders what horrible "mathematics" people are going on about at the stack overflow topic :|
17:26:19 <FunctorSalad> we have a class called Monoid. wow
17:27:08 <FunctorSalad> and of course some stuff with CT names but zero CT knowledge required
17:29:00 <edwardk> many of the mathematicians among us want a far larger range of mathematical types than just monoid, functor and monad ;)
17:29:28 <EvanR> how about Real
17:29:31 <mdmkolbe> @hoogle (a -> Maybe b) -> [a] -> b
17:29:32 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:29:32 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:29:32 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:29:54 <edwardk> FunctorSalad: which topic?
17:29:56 <aristid> edwardk: just make sure the docs are good enough for people without a master in maths can understand it :P
17:30:07 <Saizan> well, see it this way, if someone ever writes the equivalent of rails for haskell, we'll still have the math FUD to save us.
17:30:25 <EvanR> lol
17:30:34 <aristid> Saizan: many people are trying to write the rails for haskell
17:30:38 <FunctorSalad> edwardk: http://stackoverflow.com/questions/2284875/why-is-haskell-used-so-little-in-the-industry/
17:30:38 <tomberek> edwardk : what about you category-extras.. that seems to work
17:30:41 <edwardk> aristid: that is what gracenotes' project is support to help with ;)
17:32:13 <FunctorSalad> edwardk: (I started reading from the bottom, maybe it's different at the top ;))
17:32:18 <aristid> edwardk: which is gracenotes' project?
17:33:12 <Gracenotes> oh, using happstack? and in doing so making it the #1 rock star web framework evar?
17:33:13 <edwardk> aristid: infrastructure for a more social hackage 2.0 -- i.e. getting the scaffolding right to be able to wikify the hackage haddock docs, vote up or down packages, etc.
17:34:07 <lispy|web> Gracenotes: please no rock stars.  That leads to pornographic couchDB presentations as I understand it
17:34:15 <FunctorSalad> wikified docs sounds interesting
17:34:15 <edwardk> FunctorSalad: i tried reading the bottom, but the last entry was a harropism ;)
17:34:34 <aristid> edwardk: ah
17:34:51 <radarsat1> @mauke: thanks again, now managed to fully test my callback working
17:34:51 <lambdabot> Unknown command, try @list
17:35:12 <lispy|web> edwardk: why are delimited continuations so hard to grok?
17:36:08 <edwardk> lispy|web: to understand delimited continuations you must first... er.. well spend a bunch of time understanding delimited continuations, then travel back in time and resume your original continuation with the answer. so depending on your perspective they can take a long time or no time at all to understand
17:36:52 <lispy|web> edwardk: well, I think I get the non-delimited ones.  But every time I try to understand reset/shift my brain breaks :)
17:37:53 <Saizan> lispy|web: read the Shift To Control paper and tried to evaluate some expressions by hand?
17:38:14 <codolio> Oleg has a pretty good paper with commonplace examples of delimited control.
17:38:22 <codolio> Delimited Continuations in Operating Systems, I think.
17:38:23 <lispy|web> Saizan: I read a little of that one, maybe I should read more...
17:38:34 <lispy|web> codolio: yeah, I read that one last weekend
17:38:37 <edwardk> lispy|web: the usual model i like to use is to think of it as cutting off part of the stack and turning it into a sort of pachinko machine where you drop in an answer into the machine and take what falls out of the bottom of the stack as the answer.
17:38:41 <Saizan> that's how i made sense of them, though i think i've forgotten most of the details by now :)
17:39:37 <lispy|web> For reference, I've been trying to follow this example: http://www.haskell.org/haskellwiki/Library/CC-delcont#Iterators
17:39:52 <lispy|web> the begin function is really nebulous to me
17:41:20 <edwardk> lispy|web: this is one of the cases where thinking about it in a scheme setting makes things so much easier ;)
17:42:05 <codolio> lispy|web: Maybe I can help, since I wrote that.
17:42:15 <lispy|web> cool
17:43:02 <dolio> Let's see..
17:43:06 <lispy|web> dolio: Inside of shift, is k the future of the computation or is it the part between reset and shift, or are those two things the same?
17:43:17 <mauke> same thing
17:43:36 <mauke> reset is in the future of shift because evaluation will return to reset at some point
17:43:57 <edwardk> To make the Pachinko machine model concrete: reset would mark the current stack frame, shift would grab all the frames down to that point and set up the machine that you can drop an answer into and get something out of the bottom of the stack
17:44:18 <mauke> shift takes p, finds the corresponding reset call on the stack, and turns everything in between into a function
17:44:42 <edwardk> exactly
17:44:54 <andrewsw> I need to store the fact that I've hit infinity in a computation (Rational with 0 denom), and found the source code for infinity (<- take *that* out of context!) but can't figure out how to get it in scope. can anyone help?
17:45:01 <Saizan> since for is some kind of loop, k represents only the "iterations" that still need to be done, right?
17:45:11 <andrewsw> source is here: http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/GHC-Real.html
17:45:26 <dolio> lispy|web: The important part with the delimited continuations is that you only want to capture 'the rest of the loop' to make the iterator.
17:45:36 <EvanR> andrewsw: infinity is open source now?
17:45:45 <dolio> So you reset outside the for to mark that.
17:45:46 <lispy|web> dolio: what is the rest of the loop?
17:45:57 <andrewsw> rimshot!
17:46:56 <andrewsw> d'oh, never mind.
17:47:13 <mauke> pre >> for t (\x -> doStuff x) >> post  -- iterating over t in the middle of a program
17:47:18 <dolio> lispy|web: The purpose of begin is to take a 'for t f' traversal over t, and turn it into a value with which you can view the elements of t.
17:47:21 <Saizan> andrewsw: you could import GHC.Real, but using infinity is probably not wise, you could use Maybe Rational though
17:47:28 <FunctorSalad> (Rational -> Bool) with embedding \q -> (< q) is kinda like Rational extended with infinity - for order purposes
17:47:38 <FunctorSalad> infinity = const True
17:47:40 <FunctorSalad> ;)
17:48:00 <lispy|web> dolio: I have some idea how begin/next work, but it's in general how reset/shift interplay that I'm lost :)
17:48:08 <dolio> lispy|web: So you use 'reset' around the for to mark that scope.
17:48:11 <FunctorSalad> and it gets you some real numbers while it's at it of course
17:48:15 <andrewsw> Saizan: I'm not actually *doing* anything with it, just recording (possibly multiple times) that I've encountered it
17:48:51 <EvanR> Maybe Rational
17:48:59 <andrewsw> I'm storing sets of (slope, intercept) pairs and occaisionally hit a vertical line
17:49:05 <dolio> Then in f, when you 'shift p (\k -> ...)' k is the rest of the for loop.
17:49:14 <EvanR> or data RationalPlus = Infinity | Finite Rational
17:49:18 <lispy|web> dolio: okay, bit about turning the traversal into a value is good for intuition
17:49:27 <andrewsw> EvanR: that would work too
17:49:28 <Saizan> andrewsw: well, if it works :)
17:49:52 <lispy|web> dolio: syntactic remainder or execution remainder?
17:50:00 * FunctorSalad wonders how much memory a (Rational -> Bool) takes ;)
17:50:31 <FunctorSalad> just the rational for each new closure?
17:50:44 <dolio> Execution remainder.
17:50:50 <lispy|web> andrewsw: maybe you should be computing it inside something like a Writer that can track these values
17:51:03 <FunctorSalad> (if the closures all come from the same location)
17:51:04 <edwardk> FunctorSalad: more or less since that particular form of rational -> bool has only that captured
17:51:52 <lispy|web> dolio: So, in terms of syntactic correspondence, the k is the stuff between reset and shift, but in terms of what will execute it represents running the rest of the loop?
17:51:55 <andrewsw> oops... I'm multiplying by infinity. Dang. I thought haskell could do anything!
17:52:27 <edwardk> andrewsw: its easy to multiply by infinity
17:52:27 <EvanR> maybe you need your own rational
17:52:34 <tomberek> edwardk : I almost got this to work.  I can 'labelize' any Applicative
17:52:37 <edwardk> its just not rational ;)
17:52:42 <EvanR> > (4 % 0) * (3 % 2)
17:52:43 <lambdabot>   *Exception: Ratio.%: zero denominator
17:52:44 <dolio> lispy|web: Yes. After all, if you expanded the for for a static piece of data, it'd look like...
17:52:44 <edwardk> tomberek: nice
17:52:45 <FunctorSalad> edwardk: oh right, my question didn't make much sense
17:52:57 <FunctorSalad> some other closures may capture more data after all
17:53:08 <FunctorSalad> (those which don't come from rationals)
17:53:15 <tomberek> edwardk :needs some polish, i'll run it by you for review later if that's ok
17:53:39 <dolio> lispy|web: reset $ shift (\k -> return (Cur e1 (k $ return ()))) >> shift (\k -> return (Cur e2 (k $ return ()))) >> ...
17:53:45 <EvanR> andrewsw: with a little work you could have a rational type fully supporting zero denoms, and prints out as '+inf' even ;)
17:54:04 <andrewsw> EvanR: yeah, looks like it. grrr...
17:54:16 <dolio> lispy|web: And each shift captures all the things in the future.
17:54:42 <EvanR> show (X 0 0) = "nan"
17:54:49 <dolio> At least, all the things in the future of what you passed to 'reset'.
17:54:53 <mauke> k is dynamic, not lexical
17:55:38 <lispy|web> dolio, mauke: thanks.  I'll probably have more questions
17:55:58 <andrewsw> ah ha, I got it. Just have to guard for an infinite slope.
17:56:25 <EvanR> thats the wimpy way
17:56:33 <andrewsw> heh.
17:56:40 <FunctorSalad> or just store a direction instead of the slope?
17:56:51 <FunctorSalad> you're using two integers anyway...
17:57:05 <andrewsw> perhaps.
17:57:20 <EvanR> if you arent integrating or anything that makes most sense
17:57:24 <EvanR> use vectors
17:57:44 <andrewsw> it's just a little contest problem (find the largest set of colinear points in a set of integral ordered pairs)
17:57:52 <andrewsw> yes, vectors would work.
17:58:07 <andrewsw> maybe
17:58:17 <EvanR> geometry, yes sounds like it would
17:58:31 <dolio> lispy|web: Anyhow, what begin does is in each iteration of the loop, it captures the rest of the loop, and immediately returns a value holding the current element, and the rest of the loop.
17:59:04 <lispy|web> dolio: I definitely get it at that level
17:59:49 <dolio> Okay.
18:00:11 <andrewsw> EvanR: I'm creating an AssocList of lists of colinear points keyed by (slope,intercept) pairs
18:00:57 <EvanR> thats not always a good representation of a line
18:01:01 <FunctorSalad> andrewsw: I think it becomes a pure combinatorics problem once you make use of the fact that any three points will fix a line
18:01:01 <EvanR> for example, vertical lines
18:01:08 <andrewsw> EvanR: its the vertical lines that are getting me, but I just need a unique way to identify each one, probably (infinity, x-intercept)
18:01:23 <EvanR> two points represents a line better
18:01:32 <mauke> function begin(t) { return kforeach(t, function (a, k) { return new Cur(a, k); }, function () { return new Done(); }); }
18:01:37 <FunctorSalad> *two
18:02:18 <FunctorSalad> then I think you'd have to search all the two-point sets for how many other points are hit by the line
18:02:20 <EvanR> a line can go through any arbitrary three points if you look at it right ;)
18:02:28 <EvanR> perspective projection
18:02:57 <EvanR> (i just made this up, i dont know if its true)
18:03:13 <andrewsw> FunctorSalad: sorry, I mis-spoke the problem, the largest set of colinear points that *include* a given point.
18:03:54 <FunctorSalad> EvanR: I added a dimension to account for the (probable) fact that we're talking about affine lines, but I was off-by-one
18:04:02 <FunctorSalad> (linear lines: one point, affine: two)
18:04:04 <FunctorSalad> ;)
18:04:17 <EvanR> linear lines, hehe
18:04:35 <lispy|web> That's affine line you got there son.
18:04:43 <Zao> ...
18:05:22 <EvanR> my geometry teacher got mad at anyone who used the phrase curved line
18:05:50 <andrewsw> I keep getting frustrated because I don't have a hyperbolic straight-edge
18:06:15 <lispy|web> dolio: so the other thing that was tripping me up is that the code between reset and shift is aborted until the continuation inside shift uses it
18:06:36 <dolio> Yes. It's different than callCC in that respect.
18:07:20 <FunctorSalad> EvanR: I think you mean a circle btw
18:07:42 <FunctorSalad> in the projective plane
18:07:50 <dolio> There's an undelimited operator that's similar in that respect, sometimes called 'control'.
18:07:55 <EvanR> FunctorSalad: no
18:08:04 <dolio> But it's not the control from control/prompt.
18:08:14 <FunctorSalad> at least that can go through three arbitrary points :)
18:08:22 <lispy|web> dolio: so in the parser example, k is bound to this function? (Done . parser) `liftM` toList
18:08:45 <lispy|web> where does the name prompt come frome?
18:08:46 <FunctorSalad> a line still needs just two...
18:09:07 <lispy|web> shift/reset I can kind of picture, but control/prompt are harder for me to imagine
18:09:18 <EvanR> FunctorSalad: my hypothesis can be phrased in an alternative way (meaning, this is the hypothesis i was trying to say). you can make three colinear points appear at three arbitrary positions using a perspective projection
18:09:59 <EvanR> the line of course would not look straight
18:10:14 <tomberek> type instances Item (L m a) and Item (f a) overlap?
18:10:28 <FunctorSalad> ? perspective projections keep lines straight
18:10:46 <EvanR> they do?
18:11:17 <tomberek> the kinds of L m and f seem to both be *->* and o they are considered overlapping
18:11:38 <dolio> lispy|web: In the parser example, the magic is in generating the string.
18:12:00 <lispy|web> dolio: right
18:12:42 <FunctorSalad> EvanR: pretty sure ;)
18:12:44 <dolio> So in each case, the continuation contains some of the string generation.
18:12:53 <lispy|web> dolio: But, I was trying to use streamInvert and invertParse to see if I understand the stuff I learned from the other example
18:12:55 <EvanR> FunctorSalad: if so, problem solved ;)
18:13:04 <andrewsw> just for the record, importing GHC.Real, guarding for verticals pretty much did the trick. thanks
18:13:49 <dolio> lispy|web: In the parser example, the loop you're inverting is one that calls the 'm (Maybe a)' action until it sees a Nothing.
18:14:08 <dolio> And produces a string of all the Justs.
18:14:18 <lispy|web> dolio: and that 'loop' is really just an unfoldr with an unusual type, right?
18:14:43 <dolio> Not just an unfoldr.
18:15:12 <dolio> I mean, it's monadic.
18:15:21 <lispy|web> :t unfoldr
18:15:22 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:16:12 <dolio> Anyhow, the full computation inside the reset is "loop >>= \s -> return (Done $ parser s)".
18:16:26 <dolio> So the shift captures that last part, too.
18:16:31 <dolio> Everything inside the reset.
18:17:24 <ezyang> Hey guys, what benefit does Haskell get from having bottom as a value in its language?
18:17:27 <dolio> Just like the iterator loop has "for t f >> return Done", because this isn't scheme, and we have to make the types work out. :)
18:17:40 <EvanR> bottom isnt a value in the language, is it
18:17:42 <lispy|web> ezyang: I can write infinite recursions
18:17:45 <soupdragon> ezyang what it's not a value
18:18:02 <ezyang> Well, we seem to treat undefined as if it were bottom?
18:18:22 <EvanR> > let bottom = bottom in bottom
18:18:26 <lambdabot>   mueval-core: Time limit exceeded
18:19:20 <lispy|web> ezyang: If we removed bottom, then all functions you define would have to be total.  No unbounded recursion for example.
18:19:39 <lispy|web> ezyang: good luck defining fix in that language
18:20:10 <ezyang> Hmm.
18:20:19 <Saizan> undefined is an expression that denotes bottom
18:20:21 <FunctorSalad> well, `fix' is outright impossible
18:20:34 <Saizan> however yeah, if you have something like fix you'll have bottom: fix id
18:20:43 <lispy|web> ezyang: BTW, you start on Tuesday right?
18:20:47 <ezyang> Yep!
18:20:53 <soupdragon> start what?
18:20:54 * ezyang is soooo excited 
18:20:56 <lispy|web> cool, I look forward to meeting you
18:21:01 <FunctorSalad> a different way to state the problem is that any scheme that excludes all the partial functions will exclude some total ones
18:21:24 <lispy|web> soupdragon: he's going to be an intern at Galois
18:21:56 <aavogt> FunctorSalad: so asking for a proof of everything isn't a scheme?
18:22:11 <soupdragon> asking for a proof is a scheme
18:22:25 <soupdragon> even with proofs you can't touch the halting set
18:22:34 <FunctorSalad> aavogt: incompleteness (finally an opportunity to use that theorem *appropriately* :D)
18:22:35 <gwern> ezyang: don't get your hoeps up. they'll probably make you edit the videos of all the tech talks
18:22:59 <ezyang> gwern: Haha
18:23:12 <edwardk> ezyang: so i take it this means you're missing the next boston haskell meeting ;)
18:23:15 <ezyang> FunctorSalad: Nice one.
18:23:18 <lispy|web> gwern: good idea!  /me sends an email
18:23:20 <ezyang> Yeahhh
18:23:31 <ezyang> (re edwardk)
18:23:50 <gwern> lispy|web: if I knew who to email, I would've just done it - now ezyang has a chance to spoil things and deprive us of our videos
18:24:50 <lispy|web> ezyang: when do you fly into Portland?
18:25:05 <ezyang> Ok, I want to rephrase my question: what benefits do we think from thinking of bottom as a tangible value?
18:25:12 <ezyang> lispy|web: Tomorrow. I arrive noonish.
18:25:36 <lispy|web> ezyang: Nice.  Expect rain :)
18:25:38 <ezyang> (for example of such thinking, the type Boolean is inhabited by True, False and Bottom)
18:25:43 <FunctorSalad> ezyang: there is this website lamenting how the incompleteness theorem is used in groups like alt.cuddle, rec.hip-hop etc so I thought it'd be important to point out that finally it's on-topic
18:25:45 <ezyang> ok
18:26:05 <ezyang> where's my umbrella...
18:26:11 <soupdragon> FunctorSalad link??!
18:26:19 <gwern> http://rjlipton.wordpress.com/2010/05/27/making-abstract-data-types-abstract/#comment-3579 <-- interesting idea about implementing ADTs
18:26:24 <dancor> i've used (undefined) before
18:26:32 <dancor> something about populating a map..
18:29:03 <FunctorSalad> soupdragon: hmm used to be here :( http://staff.www.ltu.se/~torkel/eget/godel.html
18:29:08 <lispy|web> ezyang: HOLCF can model bottom in Haskell and uses it to reason about properties of haskell programs
18:29:12 <soupdragon> oh well
18:29:17 <soupdragon> it's totally true
18:29:36 <lispy|web> ezyang: HOLCF is higher order logic continuous functions?  It's a kernel of logic used by Isabelle (the theorem prover)
18:29:46 <dolio> ezyang: Thinking of bottom as a value makes much more sense of non-strict evaluation, if you ask me.
18:30:03 <ezyang> dolio: That sounds plausible.
18:30:13 <ezyang> "Hidden bottoms in that lazily evaluated structure"
18:30:42 <ezyang> lispy|web: how are... higher order logic functions continuous?
18:30:47 * ezyang goes and looks it up 
18:30:58 <hstefan> how can I call a function when an item is selected on a treeView? (using gtk2hs)
18:30:58 <soupdragon> topology
18:31:10 <alexyk> hey guys -- I've blogged aout my first successful Haskell program and listed it ah http://haskell.3th.us, which means 3rd Time the Haskell.  I'd appreciate a code review and coding suggestions!  The comments are working there.
18:31:12 <lispy|web> ezyang: that I don't know.  I'm very new to Isabelle
18:31:24 <mun> in first order logic, for an expression P(x), is it right to say x is a 'constant'?
18:31:58 <ezyang> alexyk: Does your post need JS to view?
18:32:22 <alexyk> ezyang: probably, it's a standard way to embed gists from github
18:32:43 <EvanR> everything falls apart when those hidden bottoms are revealed
18:32:47 <ezyang> laaaame
18:33:06 <ezyang> alexyk: You should give a type for json2graph
18:33:26 <alexyk> well gists froom github are teh best ways to embed code snippets into blogs -- versioned and auto-colored, so here.
18:33:42 <ezyang> Real men don't use syntax highlighting
18:33:47 <ezyang> :-P
18:33:56 <aavogt> your code doesn't fit in the fixed width
18:33:56 <FunctorSalad> "continuous" means f(supremum blah) = supremum_{x in blah} f(x)
18:34:07 <hstefan> ezyang: that's so true!
18:34:20 <FunctorSalad> in the context of partially ordered sets
18:34:25 <FunctorSalad> and directed sets 'blah'
18:34:36 <soupdragon> FunctorSalad, I was thinking more about inverse images
18:34:37 <edwardk> ezyang: http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
18:34:39 <soupdragon> and open sets
18:34:40 <aavogt> also, what's with the non-consistent use of layout, alexyk?
18:35:01 <alexyk> aavogt: I couldn't indent the damn case under a let for the heck of me.
18:35:02 <ezyang> edwardk: Cool link, reading now
18:35:09 <dancor> ya it's starting to look like befunge, jk ;)
18:35:13 <ezyang> I recently added Mathematics and Computation to my blogroll
18:35:19 <soupdragon> FunctorSalad.. although what you said is probably more relevant to (omega?) complete partial orders like programming language semantics
18:35:29 <alexyk> aavogt: so I just bracketed it.  The idea was, push onto victory, pretty-print later.
18:35:36 <FunctorSalad> soupdragon: it does kinda coincede with topological continuity in settings where both apply, if you squint the right way ;)
18:35:44 <mreh> I cannot get lambdacube to work!!! This is doing my head in now
18:35:53 <FunctorSalad> I think you'd need a filter as the directed set in question
18:35:56 <aavogt> alexyk: probably tabs
18:36:09 <edwardk> ezyang: since you're looking for it in a logical setting (and this way you can even want to tie it back to my current work on automatic differentiation!) you can also read http://math.andrej.com/2008/08/13/intuitionistic-mathematics-for-physics/
18:36:10 <mreh> what haskell apps use the openGL bindings that actually work?
18:36:13 <alexyk> aavogt: I'm in TextMate's Haskell mode, indents are right elsewhere.
18:36:17 <mreh> I want to check they're not broken
18:36:29 <edwardk> ezyang: the latter might be more satisfying to you as a computer science guy
18:36:41 <alexyk> but I'llk inspect it thoroughly.  Is there any caveat to indent let x = case ... and choices?
18:36:54 <ezyang> savvy
18:38:01 <aavogt> you're presenting with a fixed width... which is being overflowed
18:38:03 <FunctorSalad> soupdragon: as an example, if we take, as our directed set, some set of intervals of real numbers intersecting in a single point... I think it's equivalent to topological continuity then
18:38:13 <FunctorSalad> (in that point)
18:38:27 <soupdragon> is that the neighbourhood of the point?
18:38:27 <FunctorSalad> and supremum = intersection (flipped order...)
18:38:36 <ezyang> edwardk: Re the former post, so... don't the domains look discrete for most computable functions, in that case?
18:38:39 <soupdragon> I actually dont know this stuff beyond the first couple of pages
18:38:43 <FunctorSalad> needn't be the whole neighborhood
18:38:54 <FunctorSalad> but a subset of it that intersects in the point...
18:39:58 <edwardk> ezyang: more or less
18:40:26 <alexyk> aavogt: ah! that's teh default from github's gist.  Have to look how to tell it to wrap lines; there's a scroll bar for now ;)
18:40:54 <lispy|web> ezyang: oh, I was wrong, it's computable function
18:41:07 <lispy|web> ezyang: http://www.springerlink.com/content/y6ht00142u1632x5/
18:41:12 <FunctorSalad> soupdragon: but that's a bit of a red herring if we're concerned with how it's used in computation, I guess
18:41:27 <ezyang> lispy|web: Ah, ok
18:41:29 <FunctorSalad> (where the order is the definedness order)
18:41:55 <FunctorSalad> ("less-defined-or-equal")
18:42:41 <edwardk> gah. i have one implementation of skew binary random-access lists and another of zeroless binary random access lists, but there is a property the skew binary ones have that the zeroless ones dont, that is that if i start dropping the least significant bits of the skew binary lists i get a valid skew binary list
18:43:24 <edwardk> time to hunt for what zeroless skew binary means
18:43:53 <aavogt> would there be some way to recover that these are id:    (Any -> Any,(Any -> Any, (Any -> Any, ())))
18:43:58 <EvanR> zeroless binary, ah so 11111111111111 ;)
18:44:21 <aavogt> the Any being from GHC.Prim
18:44:29 <edwardk> evenr: zeroless binary gives you 2 as well as a digit ;)
18:45:04 <EvanR> i never realized weve been working in twoless binary this whole time!
18:45:18 <edwardk> EvanR: [] 1 2 11 12 ...
18:45:54 <david445566> does anybody know how I could fix this instance diagram for IO (String, String)? I'm trying to print two strings gotten from IO. My paste is here: http://codepad.org/UjwSsDhz
18:46:04 <edwardk> EvanR: there are a number of redundant binary representations that are actually quite useful for reducing carrying distance in computation or when it comes to designing data structures
18:46:07 <david445566> *instance declaration
18:46:14 <aavogt> as in, can I hide those type parameters for   (a -> a,(b -> b,(c -> c,()) ))
18:46:18 <david445566> sorry, SQL final on the brain
18:47:10 <aavogt> ghc's docs on Any sort of suggest this is an acceptable use of unsafeCoerce
18:47:15 <lispy|web> david445566: um, a few things are wrong there
18:47:31 <dolio> Isn't Any like (exists a. a)?
18:47:44 <lispy|web> david445566: IO (String, String) represents a computation
18:47:46 <dolio> In which case, you have no guarantee that those are identity functions.
18:47:52 <aavogt> "The type constructor Any is type to which you can unsafely coerce any  lifted type, and back. "
18:48:18 <edwardk> dolio: except safer, iirc there appear to be some corner cases involving seq that just coercing to another type may be dangerous for
18:48:38 <Saizan> it all depends on who coerced those functions in the first place, i'd say
18:48:44 <lispy|web> david445566: what you actually want to do is change your main
18:48:55 <FunctorSalad> ISTR there was some warning concerning function types vs other types too
18:48:59 <edwardk> Saizan: its not their fault clearly they were coerced
18:49:02 <FunctorSalad> in the `Any' docs or close
18:49:07 <dolio> After all, I could write (\_ -> 5) :: (exists a. a) -> (exists a. a)
18:49:27 <aavogt> Saizan: I didn't coerce them... ghc couldn't find where to carry the type variables through
18:49:30 <david445566> lispy, so I'm just calling it wrong? Originally I thought to just write a function to print it but then I figured I wouldn't learn anything about typeclasses that way
18:50:17 <dolio> @free f :: () -> ()
18:50:18 <lambdabot> f = f
18:50:41 <Saizan> aavogt: ah, i see, so monomorphic variables that didn't get unified with anything
18:50:42 <lispy|web> david445566: to show the values that are inside your IO, you'll need to get at the values.  Which means you need to 'run the IO' or have the showing happen inside the IO
18:51:04 <aavogt> david445566: drop the instance declaration, and the do from main (and it's type signature), and runhaskell / ghc will print out your result type
18:52:03 <aavogt> or do it properly like lispy says
18:52:06 <FunctorSalad> (ah, apparently this warning was that you mustn't cast a function type to an adt type and back)
18:52:27 <Saizan> aavogt: what's the code that's making this?
18:52:32 <FunctorSalad> "For example, do not cast Int->Int to Bool, even if you later cast that Bool back to Int->Int before applying it."
18:52:58 <lispy|web> david445566: running IO comes in two variants: 1) main = someIOthingy; 2) unsafePerformIO.  You'll have to learn more before you can use #2 and it's not appropriate here.
18:53:17 <FunctorSalad> (but Any instead of Bool is supposed to be fine)
18:53:28 <EvanR> @src Any
18:53:29 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:53:34 <david445566> lispy, alright thanks. so could I call show on each individual part of the tuple?
18:53:38 <lispy|web> david445566: So, that leaves really one possibility.  Do the showing inside an IO computation
18:53:45 <lispy|web> david445566: exactly
18:53:52 <david445566> lispy, great thanks
18:54:05 <david445566> thought I'd take a nice day like today and spend it inside learning about monads
18:54:17 <lispy|web> david445566: main = do (first, last) <- getFullName; print first; print last
18:54:29 <lispy|web> david445566: that's one possible way to do it
18:55:08 <aavogt> Saizan: http://codepad.org/upVBozDM
18:55:12 <Saizan> Any : (P : A -> Set) (xs : List A) -> Set -- a bit overkill for Bool
18:55:58 <FunctorSalad> how does one sensibly manage ctags or etags? I've now arrived at the 'solution' of a daily cronjob that is essentially 'find ~ -name '*.hs' -print0 | xargs -0 hasktags'
18:56:04 <FunctorSalad> (plus some pruning)
18:56:24 <Saizan> aavogt: i'd go with NoMonomorphismRestriction, honestly
18:56:30 <FunctorSalad> seems better than these 'tags' files littered everywhere
18:57:00 <aavogt> hmm, that works!
18:58:27 <Saizan> hah, the sweet power of let polymorphism.
18:58:28 <lispy|web> david445566: BTW, the only real problem with your show instances was that syntactically it needs to be instance Show (IO (String, String)) where ..., but then you have the problem that you can't get at the tuple until the IO runs and the type signature of show won't allow it.  So the instance would be like, show _ = "<IO (String, String)>".  In other words, it wouldn't do much
19:00:11 <edwardk> preflex: xseen jbapple
19:00:11 <preflex>  jbapple was last seen on freenode/#haskell 1 day, 1 hour, 2 minutes and 53 seconds ago, saying: > (minBound::Int)-1 == (maxBound::Int)
19:00:50 <selckiku> hi #haskell, why do i keep getting the impression that haskell is the most powerful language in the world?  is that true, or are y'all just good at PR?
19:00:57 <jbapple> heyHEYhey
19:00:59 <edwardk> selckiku: both
19:01:09 <lispy|web> ?faq Can Haskell do anything?
19:01:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:01:41 <EvanR> selckiku: haskell is failing to avoid success at all costs
19:01:48 <EvanR> for what its worth
19:02:16 <selckiku> yes but everyone says their language can do everything.  i think what gives the impression that haskell's something special is all the people who are clearly rationalizing why they don't have to understand it.
19:02:45 <siracusa> In gtk2hs, is there an easier way to display multi-line text than with a TextView + TextBuffer?
19:02:48 <edwardk> selckiku: hahaha
19:03:18 <aavogt> @quote tarpit
19:03:19 <lambdabot> No quotes match. My brain just exploded
19:03:34 <EvanR> can do anything is not hard ;)
19:03:35 <aavogt> @quote tar.*pit
19:03:35 <lambdabot> AlanPerlis says: Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19:04:10 <alexyk> selckiku: I use OCaml and Scala and Clojure and now Haskell.  Each has its fortes.  You can't realyy get by on just one in the real real world.
19:04:51 <aavogt> why is that alexyk?
19:05:16 <alexyk> aavogt: legacy codebases + colleagues working in Scala, e.g.
19:05:37 <alexyk> real world runs on C and Java...
19:05:45 <alexyk> eg Google.
19:06:04 <lispy|web> I think google uses everything
19:06:12 <aavogt> so how does that involve those pragmatic alternatives to haskell?
19:06:15 <alexyk> but we can carve out niches & form startups
19:06:22 <lispy|web> I've certainly heard stories about Haskell and python at googe
19:06:25 <alexyk> aavogt: JVM.
19:06:35 <wli> It's all kernel work here.
19:06:38 <ezyang> I thought Google was a five-language shop only
19:06:45 <ezyang> (and Haskell wasn't one of them_
19:07:05 <alexyk> lispy|web: google will not tolerate anything but the big 3 in production, last time I interviewed :)
19:07:21 <wli> Not much in the way of Haskell in the kernel.
19:07:42 <EvanR> php c# and brainfuck?
19:07:47 <lispy|web> wli: you need habbit
19:07:53 <lispy|web> when it's ready
19:08:00 <alexyk> EvanR: you must be Sergey Brin!
19:08:06 <gwern> wli: we just need to get sel4 running and then we can replace linux and its c abominations
19:08:19 <selckiku> what's it about haskell that's powerful?  i've heard of something called monads...
19:09:05 * alexyk suspects Dr Harrop in all inquisitors
19:09:10 <makmanalp> gwern: those abominations served us well for 40 odd years :)
19:09:32 <bremner> selckiku: why don't you try "Learn You a Haskell" and make up your own mind?
19:09:41 <bremner> or some other tutorial
19:09:52 * EvanR gives selckiku the pamphlet
19:09:54 <gwern> makmanalp: served us well? served us, yes, but not well
19:10:16 <FunctorSalad> "sel4"?
19:10:22 <gwern> exokernels are faster, microkernels more reliable, capability-based OSs more secure...
19:10:32 <lispy|web> selckiku: Purity and laziness gives Haskell pretty amazing composability
19:10:59 <aavogt> alexyk: ocaml run on jvm?
19:11:02 <makmanalp> gwern: are you seriously going to argue that what we have now is inadequate when we have all these giant complex systems up and running continously? i'm not arguing that it could be better.
19:11:16 <makmanalp> *it couldn't be better
19:11:25 <selckiku> lispy|web,  laziness i'm familiar with, but what do you mean by "purity"?  or just that it's elegant?
19:11:32 <gwern> makmanalp: our needs are indefinitely large, so anything that could be better is inadequate
19:11:42 <alexyk> aavogt: there's some experimental setp
19:11:45 <alexyk> setup
19:11:50 <EvanR> selckiku: pure functions
19:11:58 <makmanalp> gwern: that's a really obscure definition of "inadequate", but i get your point
19:12:03 <gwern> because we run the OSs of yesterday, we struggle with the applications of today, and can only dream of the functionality of the future
19:12:05 <alexyk> but Scala and Clojure close the gap
19:12:13 <david445566> okay same bit of code I was working on before now compiles but is there a way to use that helper function getFullName without having the lazy IO part (i.e. only prints after the two getLines)? new code: http://codepad.org/uVRshA1O
19:12:14 <EvanR> selckiku: evaluating a function causes no side effects
19:12:21 <gcollins> does anyone have any experience with the error "A C finalizer called back into haskell" w.r.t. ForeignPtr? As far as I can tell we aren't doing this but we're getting the error anyways
19:12:50 <FunctorSalad> selckiku: purity ~= it doesn't matter whether two references point to the same location or to two seperate copies
19:12:50 * wli is generally concerned with other issues wrt. kernel functionality.
19:13:06 <FunctorSalad> (except for performance, but you can't observe sharing)
19:13:35 <EvanR> thats referential transparency
19:13:44 <FunctorSalad> (that's just one of the ways to describe 'no mutation')
19:13:46 <FunctorSalad> EvanR: yes
19:13:53 <FunctorSalad> is it different from purity?
19:14:02 <EvanR> purity means no side effects
19:14:08 <EvanR> mutation is one of them
19:14:28 <gwern> FunctorSalad: I sometimes wonder about that; surely sharing or not-sharing could move you between complexity classes; not returning a result within a few millennia is, for all practical purposes, bottom
19:14:57 <wli> e.g. superpaging, divorcing allocation units from memory mapping (typically using larger allocation units), coremaplessness, stacklessness, total aio, etc.
19:15:07 <FunctorSalad> gwern: but that's outside the 'semantics' abstraction
19:15:14 <lispy|web> gcollins: are your FFI exported safe or unsafe?
19:15:30 <lispy|web> gcollins: did this start happening after upgrading to 6.10 or newer?
19:16:03 <FunctorSalad> (and `bottom' may still be better than returning *different* answers due to destructive changes)
19:16:06 <EvanR> FunctorSalad: a weird kind of side effect is 'depending on anything except constants and passed in arguments'
19:16:19 <lispy|web> david445566: I'm not sure what you want
19:16:20 <EvanR> which has nothing to do with mutabiliy
19:16:47 <lispy|web> david445566: how can it print before it gets input?
19:17:14 <gwern> lispy|web: print a constnat?
19:17:20 <FunctorSalad> EvanR: hmm, I see, it doesn't seem to capture all the side effects
19:17:57 <dolio> Purity is independence from evaluation order up to bottoms.
19:18:10 <david445566> lispy, I mean the program waits for two lines to be entetered and then prints "first name: last name: hello your name"
19:18:29 <david445566> instead of "first name: " <wait for input> "last name: " <wait for input> ...
19:18:43 <lispy|web> david445566: oh, that's likely due to the buffering of your terminal
19:19:01 <lispy|web> david445566: You could try setting stdin to be LineBuffered in main
19:20:31 <lispy|web> main = do hSetBuffering LineBuffering ..., and you'll need to add import System.IO (hSetBuffering, BufferMode(LineBuffering), stdin) to the top of your program
19:20:56 <lispy|web> er, sorry hSetBuffering stdin LineBuffering
19:21:17 <david445566> thanks a lot lispy
19:21:32 <lispy|web> yw, but does it actually work? ;)
19:21:42 <david445566> oh just about to test it
19:21:52 <david445566> making pasta and coding
19:22:04 <FunctorSalad> heh didn't know about *this* GHC.Prim function: dataToTag# :: a -> Int#
19:22:23 <FunctorSalad> sounds great for generics no? ;)
19:23:49 <lispy|web> FunctorSalad: hmm...interesting
19:24:00 <lispy|web> FunctorSalad: gives you the data constructor tag?
19:24:57 <FunctorSalad> Prelude GHC.Prim Data.Int GHC.Types> I# (dataToTag# True)
19:24:57 <FunctorSalad> 1
19:24:57 <FunctorSalad> Prelude GHC.Prim Data.Int GHC.Types> I# (dataToTag# False)
19:24:57 <FunctorSalad> 0
19:25:05 <FunctorSalad> @ lispy|web : seems so
19:25:09 <david445566> lispy, so the import line is System.IO (hSetBuffering, stdin, LineBuffering) ?
19:25:19 <lispy|web> david445566: that might work
19:25:36 <FunctorSalad> the results could be a bit brittle maybe ;)
19:25:42 <david445566> yeah I asked because I got an error saying System.IO does not export LineBuffering
19:25:45 <lispy|web> david445566: if not, try changing LineBuffering to BufferMode(..))
19:25:58 <lispy|web> david445566: okay yeah, then you need to tell it which type it's a constructor of
19:26:10 <lispy|web> david445566: BufferMode(LineBuffering) or BufferMode(..) should work
19:27:55 <david445566> lispy, both of those produce the same kind of error. here's what GHC is telling me: http://pastebin.com/DF1QkjVB
19:28:05 <david445566> also thanks a lot for all the help :)
19:28:19 <hstefan> Is there any haskell IDE?
19:28:27 <david445566> hstefan, leksah?
19:28:42 <lispy|web> david445566: ah yeah, I guess you didn't see my correction: 19:20] <lispy|web> er, sorry hSetBuffering stdin LineBuffering
19:28:51 <lispy|web> david445566: the first time I typed it I forgot the 'stdin' :)
19:28:53 <hstefan> david445566: I'll look at it
19:28:59 <hstefan> I was programming in notepad
19:29:00 <hstefan> yay
19:29:28 <lispy|web> hstefan: emacs, vim, leksa, yi, and eclipse with the eclipse-fp plugin (if it still exists)
19:30:23 <david445566> hmm the buffering thing change anything. I'll try running this on terminator instead of gnome-terminal
19:30:45 <david445566> also it might be my haskell. I'm running on intrepid
19:31:20 <hstefan> just asking... what do you use to program?
19:31:21 <david445566> yeah ghc version 6.8.2
19:31:32 <lispy|web> hstefan: I use emacs and sometimes vim
19:31:38 <david445566> hstefan, geany and gedit
19:31:40 * BMeph weeps for david445566...
19:31:42 <lispy|web> david445566: 6.8.2 is old but it should work fine for this
19:31:49 <david445566> hmm
19:31:54 <ezyang> :t (.)
19:31:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:32:07 <hstefan> gedit: HOW I HATE THIS.
19:32:07 <david445566> would upgrade but the newest ubuntu has the mac style close buttons :-(
19:32:19 <david445566> hstefan, what's wrong with gedit?
19:32:20 <hstefan> anyway, see ya.
19:32:55 <hstefan> david445566: I don't know how to explain... just don't like it.
19:33:07 <david445566> bye hstefan
19:33:34 <hstefan> it's time to move
19:33:49 * FunctorSalad is trying vim lately :o after my emacs initlibrary became unmanageable ;)
19:34:05 <systemfault> vim is an excellent editor..
19:34:11 <systemfault> Emacs is good for anything else.
19:34:12 <hstefan> It's so hard! I need to get up, and then WALK and there's no pc...
19:34:13 <FunctorSalad> the haskell docindex isn't bad either
19:34:16 <hstefan> I LOVE VIM!
19:35:10 <hstefan> my productivity is so much better in VIM then other editors... there's nothing to distract me in there: just text
19:35:12 <pastorn> hstefan: you go girl!
19:35:31 <hstefan> pastorn: what
19:35:59 <pastorn> VI VI VI - the editor of the beast
19:35:59 <lispy|web> david445566: oh, I use xmonad so I don't have close buttons to worry about :)
19:36:42 <MarcWeber> hstefan: Have you seen my scripts? vim-addon-haskell and vim-addon-actions?
19:36:53 <MarcWeber> github.com/MarcWeber.
19:37:01 <pastorn> MarcWeber: do you have an alignment skrypt there?
19:37:11 <MarcWeber> No. But you can compile on bufwrite.
19:37:15 <hstefan> MarcWeber: bookmarked, i'll look at it later
19:37:30 <pastorn> (so that e.g. i could align all my "<-" to be vertically aligned
19:38:19 <MarcWeber> pastorn: You can implement it easily. See range arguments to functions.
19:38:35 <FunctorSalad> pastorn: :Align<-
19:38:41 <FunctorSalad> not sure which script that is
19:38:43 <FunctorSalad> ;)
19:38:55 <pastorn> FunctorSalad: you have that?
19:39:02 <MarcWeber> http://dpaste.com/200936/ You wnat this @ pastorn  ?
19:39:09 <FunctorSalad> pastorn: yes
19:39:22 <pastorn> MarcWeber: exactly
19:39:39 <MarcWeber> pastorn: Do you want to watch me implementing within 5min or less?
19:40:13 <pastorn> MarcWeber: yes
19:40:20 <pastorn> what prerequisits do i have to have?
19:40:35 <MarcWeber> You have to have a SSH client such as putty or ssh on Linux
19:40:38 <pastorn> i just use the standard installation + my .gvimrc; no scripts at all
19:40:46 <FunctorSalad> pastorn: apparently the script is just called "align"? at least the helpfile is "align.txt"
19:41:18 <pastorn> MarcWeber: maybe we should do this in #vim
19:41:19 * syntaxglitch finishes reading byorgey's very enjoyable paper giving an overview of combinatorial species
19:41:35 <MarcWeber> pastorn: Is Win your default OS ?
19:41:48 <pastorn> nope... ubuntu 10.04
19:41:51 <syntaxglitch> maybe I can actually catch up on some reading over the weekend :\
19:41:59 <MarcWeber> SSH is just a tool to connect to a remote shell. On the remote computer you run stuff such as ghc or Vim :)
19:42:21 <pastorn> mrd: i know what it is, i use it constantly...
19:42:34 <pastorn> whoop
19:42:40 <pastorn> MarcWeber: ^^^
19:47:38 <byorgey> syntaxglitch: glad you enjoyed it.  Any comments/suggestions?  I am currently revising it.
19:50:10 <ezyang> Does anyone use the numeric-prelude for serious stuff?
19:50:12 <syntaxglitch> byorgey, I'm curious why you digress onto regular species and fixed points and such before introducing sets and cycles
19:50:51 <syntaxglitch> byorgey, other introductory stuff I've read seems to present those as part of the fundamental building blocks up front and then build from there
19:52:05 * syntaxglitch has practically no prior experience with nontrivial combinatorics, for what it's worth
19:52:26 <lispy|web> ezyang: I've never used it
19:52:33 <byorgey> syntaxglitch: I did that because I'm trying to present it from an FP point of view
19:52:44 * syntaxglitch nods
19:52:53 <byorgey> syntaxglitch: and for people familiar with algebraic data types, sets and cycles are strange beasts
19:54:00 <byorgey> ezyang: I use it in my species library, in fact
19:54:09 <ezyang> byorgey: ooh, cool.
19:54:30 <syntaxglitch> byorgey, I dunno, the idea feels pretty natural to me, sort of filling an obvious gap in what you can and can't express easily with algebraic data types
19:54:51 <syntaxglitch> especially the way it neatly ties in the whole cute derivative-of-a-type thing we all love
19:55:39 <syntaxglitch> e.g., the inability to describe an unordered collection simply has always kinda bugged me
19:55:44 <soupdragon> hehe
19:55:44 <soupdragon> a
19:56:01 <soupdragon> "an obvious gap in ..." "... the whole cute derivative-of-a-type thing"
19:56:23 <byorgey> hehe
19:56:37 <syntaxglitch> soupdragon, har har har, yes, I noticed that but decided not to run with it :P
19:56:42 <soupdragon> what I'm wondering about is data types with negative coefficients in them
19:56:48 <soupdragon> in the generating series
19:57:09 <soupdragon> I mean they don't really /exist/ do they?
19:57:14 * syntaxglitch is curious about meaningful interpretations for virtual species
20:06:23 <syntaxglitch> byorgey, I distracted myself at one point, taking derivatives in GHCi using your library, and noticed that "sets" seemed to be a fixed point of "oneHole"
20:06:38 <syntaxglitch> assumed that was the reason it was called "E" and was surprised to discover otherwise, heh
20:07:49 <byorgey> syntaxglitch: hehe, it is a useful mnemonic though.
20:07:57 <syntaxglitch> quite convenient!
20:08:03 <byorgey> syntaxglitch: the exponential generation function for E is indeed e^x.
20:08:52 <aavogt> @src foldr
20:08:53 <lambdabot> foldr f z []     = z
20:08:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:09:14 <byorgey> I've given some thought to meaningful interpretations of virtual species as well.  But I haven't really come up with anything yet.
20:09:52 <matt_m> What's a virtual species?
20:10:01 <syntaxglitch> byorgey, yeah, you remark on that later on in the paper, which nicely confirmed my earlier observation
20:10:12 <matt_m> Laurent series?
20:10:38 <soupdragon> I'm still wondering what any of this has to do with category theory
20:11:01 <byorgey> matt_m: if we close species under additive inverses, we get "negative" or "virtual" species
20:11:23 <aavogt> so sad that   foldr (.) id    for nested tuples can't be written using hFoldr
20:11:34 <byorgey> it can be formalized as pairs of regular species under a certain equivalence relation, just as the integers can be formalized as pairs of natural numbers under a certain equivalence
20:12:16 <byorgey> it turns out it also gives us enough power to define multiplicative inverses as well (unlike with integers)
20:14:57 <matt_m> byorgey:  Does this end up being rational valued polynomials in X?  Or something smaller?
20:15:09 <matt_m> (rational coefficients)
20:15:18 <byorgey> matt_m: no, just integer coefficients
20:15:34 <byorgey> matt_m: whereas non-virtual species have only natural coefficients
20:15:59 <byorgey> soupdragon: well, the basic definition of a species is as an endofunctor on B, the category of sets with bijections as arrows
20:16:17 <byorgey> and you can generalize to other categories and get various enriched notions of species
20:16:35 <matt_m> byorgey: oh right, I didn't notice you could do division in that setting
20:17:16 <byorgey> matt_m: you can because it's not just polynomials, it's potentially infinite power series
20:17:25 <matt_m> byorgey: yep, I see
20:17:51 <soupdragon> so what is [a]/a ?
20:19:08 <matt_m> What is the meaning of -X?
20:19:18 <FauxFaux> eXtension.
20:19:25 <syntaxglitch> byorgey, another thing I was curious about--and maybe this was mentioned in the paper and I've overlooked it--is how constructing a single "value" of a species "type" might work
20:19:27 <matt_m> heh
20:20:23 <syntaxglitch> it doesn't seem obvious to me that some of the complicated species--particularly ones involving functor composition and cartesian product--can be constructed in a simple manner analogous to algebraic data types
20:20:43 <byorgey> matt_m: -X is the species such that if you have either it or an X, you have something isomorphic to 0.
20:21:13 <soupdragon> sounds like quantum physics byorgey
20:21:21 <byorgey> it does kind of, doesn't it.
20:21:33 <syntaxglitch> obviously enumeration is in some sense straightforward, but "picking the one you want from a sequence" isn't a very pleasant means of constructing data
20:21:34 <byorgey> I'm not claiming it makes sense. =)
20:22:05 * syntaxglitch figured the echo of "virtual particles" was deliberate, or from a common source
20:22:08 <soupdragon> yeah I guess trying to explain this with analogue to quantum physics might not really.. help..
20:22:25 <byorgey> syntaxglitch: well, that's a great question, and one that deserves more thought.  For one approach, see Carette + Uszkay's species paper, where they actually have some Haskell code for letting you construct and compute with such things
20:22:52 <syntaxglitch> soupdragon, well, read enough John Baez and quantum physics starts to look like category theory, so there's always that
20:23:52 <syntaxglitch> byorgey, awesome--I started reading it earlier, got confused, and sat it aside
20:25:00 <syntaxglitch> in retrospect your new paper would probably have been the best starting point given my total lack of familiarity with interesting combinatorics
20:25:31 <byorgey> syntaxglitch: yes, try giving their paper another read now that you've read mine
20:26:10 <syntaxglitch> byorgey, was actually just about to do that when I ended up getting distracted by IRC, heh
20:26:15 <byorgey> hehe =)
20:26:22 <syntaxglitch> at this point maybe I'll let it sit until tomorrow, though
20:26:32 <byorgey> ok, I'm off to bed as well
20:26:34 <byorgey> night all =)
20:26:43 <syntaxglitch> seeya, and good luck with the paper
20:27:11 <byorgey> thanks
20:28:16 <tommd> Where did the gtk2hs examples get moved to?  They aren't in the GTK package on hackage.
20:31:16 <tommd> I guess I can just get it from the darcs repo, but figured a "cabal unpack ____" would have them too.
20:52:30 <greap> Why does quickcheck still perform 100 tests if there are no arguments to a function?
20:56:30 <lispy|web> greap: because QC is just that skeptical?
21:05:15 <fitbos> hi, can i ask some newbie questions here?
21:05:20 <soupdragon> yes
21:05:25 <soupdragon> please do
21:06:20 <fitbos> ok, i'm a C++ programmer, i'm currently learning haskell... i've got a problem. how can i write a "manager"? something that can add, modify and remove things
21:06:56 <EvanR> avoid those in c++ too
21:07:04 <wli> fitbos: Transaction processing database?
21:07:10 <soupdragon> well if you have instructions of the form:  Add thing,  Remove thingsName,  Modify thingsName effect
21:07:27 <soupdragon> suppose these instructions were a data types called Instruction
21:07:49 <fitbos> ok
21:07:52 <soupdragon> then you might define a function    Manager ->  Instruction -> Manager
21:08:02 <soupdragon> which performs the instruction
21:08:49 <EvanR> add :: Thing -> Manager -> Manager
21:09:03 <EvanR> modify :: (Thing -> Thing) -> Manager -> Manager
21:09:09 <EvanR> remove :: Thing -> Manager
21:09:09 <fitbos> actually not that complicated, maybe just   [Book] -> Book -> [Book]
21:09:13 <EvanR> -> Manager
21:09:20 <soupdragon> EvanR, Finally Tagless, Partially Evaluated?
21:09:25 <EvanR> its just a list?
21:09:29 <aavogt> stupid haddock -- * headings conflict with TH's order restrictions
21:09:50 <EvanR> fitbos: sounds like you want a Data.Map Integer Book
21:10:07 <EvanR> Data.Map has lots of methods for modifying and rearranging the set of books
21:10:09 <aavogt> also no linebreaks in long instance signatures :(
21:10:36 <tomberek> dang, ATs don't play well
21:11:16 <EvanR> fitbos: http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Map.html google
21:11:18 <fitbos> ummm... let me ask this way... in the main function, we always print some welcome message, "Please choose: 1. Add Book....."
21:11:34 <soupdragon> fitbos, so you take input and construct an Instruction from it
21:11:45 <fitbos> so, where can i put the book list?
21:12:11 <EvanR> an IORef, a State, explicit recursion variables ;)
21:12:14 <fitbos> there's no variables right?
21:12:36 <fitbos> is there any examples?
21:13:02 <EvanR> the documentation for all these things is a good start
21:13:18 <soupdragon> umm
21:13:29 <fitbos> ok, so i'll check out the IORef?
21:13:51 <EvanR> thats a mutable variable
21:14:15 <EvanR> write to it to update your book database
21:14:53 <fitbos> ok, i'll check that out. is this the most "haskellest" way to do such things?
21:15:21 <soupdragon> You should use recursion
21:15:25 <tomberek> to everyone... It really seems that there should be a #haskell-beginners
21:15:29 <soupdragon> forget about IO and shit
21:15:40 <tomberek> i often find myself in need of it
21:15:42 <soupdragon> tomberek: or just less people mentioning complicated things....
21:15:56 <EvanR> explicit recursion may make things simpler looking, but also may be not as obvious to someone else reading the code
21:17:31 <tomberek> soupdragon: exactly, a separate room where we can be free from category-terror
21:17:39 <tomberek> and ask simple things
21:17:42 <EvanR> since its an interactive program you cant really get away from IO
21:18:04 <soupdragon> tomberek, it's good for you to be exposed to such things :)
21:18:47 <tomberek> soupdragon: exposed, sure, but I think broaching those subjects before their time just slows people down
21:18:49 <fitbos> yes, i think i need haskell-beginners to ask stupid questions... :)
21:19:15 <soupdragon> This IS haskell-beginners
21:20:08 <EvanR> a loop with an IORef is a common solution for this
21:20:31 <soupdragon> no I would not recommend using an IORef that does not make sense to me
21:20:32 <fitbos> ok, common solution is important for me :)
21:20:33 <EvanR> it of course would be education for you to get by without the forever loop, and without the ioref
21:20:39 <EvanR> educational
21:20:51 <tomberek> soupdragon.. let's see something for a sec
21:20:54 <tomberek> @quote edwardk
21:20:55 <lambdabot> edwardk says: glguy: i can see it now, you submit a patch named 'ghc 6.8'
21:20:57 <tomberek> @quote edwardk
21:20:57 <lambdabot> edwardk says: The Id monad a little harder to reason with than the Ego monad however
21:21:43 <fitbos> ummm... EvanR, then how can i do that "educationally"?
21:24:57 <aavogt> tomberek: just ask your questions already :)
21:25:32 <tomberek> aavgot: no question now.. well, i do have one, but it concerns edwardk's category-extras
21:28:07 <tomberek> aavgot: edwardk defined type Hask = (->) ........ is there a way to get an endofunctor version ?
21:29:11 <tomberek> aavgot: he defined data Discrete a b where Refl :: Discrete a a            ,but that isn't playing well with ATs
21:29:23 <tomberek> hi ivanm
21:29:31 <ivanm> hey tomberek
21:29:32 <tomberek> did you push to repo?
21:29:37 <ivanm> not yet
21:29:44 <ivanm> well, I might have done one patch, can't recall
21:30:07 <ivanm> but I'm first checking what I can do with TH about generating instances for Show, etc.
21:30:16 <tomberek> well... it's not pushed yet, I've been checking :)
21:31:01 <ivanm> yeah
21:31:10 <ivanm> I think I did one to remove some useless files, that's about it
21:31:19 <tomberek> ivanm: i'm only finally learned Haskell syntax, and starting to understand type syntax and working with kinds... I don't think I'll tackle TH yet
21:32:34 <ivanm> heh
21:32:37 <ivanm> nah, I'll deal with that
21:33:42 <tomberek> ivanm: question
21:33:44 <ivanm> tomberek: I'll I'm wanting it for is to help generate the instnaces for you
21:34:10 <tomberek> our gmap and nmap only produce endofunctors
21:34:40 <tomberek> they can't change the type of the graph
21:34:57 <ivanm> right
21:35:01 <ivanm> which is what we want
21:35:21 <tomberek> will we ever want something like (NLabel g -> NLabel g1) -> g -> g1 ?
21:35:26 <ivanm> tomberek: nmap and emap are generalised versions of fmap; gmap is a combined more powerful version (in theory)
21:35:36 <ivanm> tomberek: I don't think so
21:35:43 <ivanm> there'd probably be better ways of doing it anyway
21:35:58 <ivanm> e.g. maybe fromContexts . toContexts :: g -> g1
21:36:29 <tomberek> ivanm: because I'm trying to make our Graph an instance of edwardk's Bifunctor
21:36:34 <tomberek> ooh, i like that
21:41:06 <aavogt>  ghc: attempting to use module `main:A.B.Arrow' (Arrow.hs) which is not loaded
21:44:20 <ivanm> tomberek: hmmm... how about predecessors and successors rather than edgesIn and edgesOut ?
21:44:59 <tomberek> for Context? it's like bananana, hard to tell when to stop the eceses
21:45:16 <ivanm> well, old fgl had pre and suc
21:45:20 <ivanm> @hoogle pre
21:45:20 <lambdabot> Text.Html pre :: Html -> Html
21:45:20 <lambdabot> Text.XHtml.Frameset pre :: Html -> Html
21:45:20 <lambdabot> Text.XHtml.Strict pre :: Html -> Html
21:45:23 <ivanm> bah
21:45:28 <ivanm> @hoogle suc
21:45:28 <lambdabot> Data.Graph.Inductive.Graph suc :: Graph gr => gr a b -> Node -> [Node]
21:45:28 <lambdabot> Data.Graph.Inductive.Graph suc' :: Context a b -> [Node]
21:45:28 <lambdabot> Prelude succ :: Enum a => a -> a
21:46:02 <ivanm> tomberek: because "edgesIn" is a bit ambiguous: are these edges in to this node or edges in to those nodes?
21:46:29 <tomberek> ivanm: you're right,,, sources, targets? and then change source/target?
21:46:58 <mrd> bananassors
21:47:00 <ivanm> I think sources and targets are just as ambiguous
21:47:03 <tomberek> yeah
21:47:09 * mrd goes bananassors
21:47:11 <ivanm> but source/target makes sense from the POV of an Edge
21:47:16 <ivanm> @slap mrd
21:47:16 * lambdabot pokes mrd in the eye
21:47:22 <ivanm> mrd: snap out of it!
21:47:24 <ivanm> ;-)
21:47:44 <tomberek> um.... well, a Context is like pointer to a particular node
21:48:00 <ivanm> yeah
21:48:44 <tomberek> and (Node g,ELabel g) is FGL's Adj
21:49:10 <ivanm> right
21:49:18 <ivanm> one the one hand, defining Adj saves some typing
21:49:23 <tomberek> if we can think of a better name for Adj, that might help us with edgesIn/Out
21:49:25 <ivanm> on the other, it's yet another abstraction
21:49:32 <ivanm> for now, I'm leaning towards not bothering with Adj
21:50:26 <tomberek> i tend to agree, but because (Node,ELabel) isn't really and edge or a node, it's a combo
21:50:34 <ivanm> right
21:51:30 <tomberek> edgesIn is like the "input half", edgesOut is the "output half" of a Context
21:52:43 <tomberek> stepBack / stepForward
21:53:00 <tomberek> retreat/advance
21:57:30 <tomberek> ivanm: source/target work well with the idea of arrows, paths, etc.
22:02:33 <ivanm> is it just me, or is TH poorly documented (haddock-wise)?
22:03:43 <ivanm> oh, there's a bug which is closed recently, so hopefully 6.12.3 will have better docs for it
22:07:58 <aavogt> ivanm: the docs are all there in the source anyhow
22:08:08 <ivanm> oh?
22:08:16 <ivanm> aavogt: I noticed you supplied a patch to fix this
22:08:24 <aavogt> I don't think TH version will be bumped for 6.12.3
22:08:48 <ivanm> oh...
22:09:03 <ivanm> aavogt: is there any way I can see what the generated Haskell code is/looks like?
22:09:27 <aavogt> yeah there are a couple ways
22:09:48 <aavogt> either with  -ddump-splices
22:10:08 <aavogt> or maybe with haskell-src-meta
22:10:09 <ivanm> how about within ghci?
22:10:50 <aavogt>  -ddump-splices works in ghci
22:11:06 <ivanm> but that means I have to launch ghci explicitly rather than within emacs... ;-)
22:11:28 <aavogt> no, you can :set -ddump-splices
22:11:43 <aavogt> and whatever other flags you need
22:11:51 <ivanm> ooohhh
22:13:18 <ivanm> OK, whenever I do any TH (even for unrelated data types) it bitches about my use of ATs :s
22:14:32 <aavogt> I have no experience there
22:14:45 <aavogt> it's supported in the AST though...
22:40:48 <ivanm> greetings kamatsu
22:42:03 <tomberek> ivanm: sup
22:42:11 <ivanm> nothing
22:42:17 <ivanm> was I talking to you? :p
22:44:39 <tomberek> ivanm: nope =)
22:46:57 <tomberek> ivanm: i found a paper that talks about "Each edge is considered as starting at a vertex called its ORIGIN and going to another vertex, called its TERMINAL."
22:47:09 <ivanm> ugh
22:47:12 <ivanm> I prefer source and target
22:47:20 <tomberek> hehe
23:02:30 <systemfault> I love you all <3 :)
23:03:57 <qebab> I'd feel a lot more comfortable with that statement if your nick didn't give me a feeling of impending doom
23:04:40 <ivanm> and if you didn't have that emoticon there suggesting you were not quite sincere in your comment
23:04:55 <ivanm> oh, and if you gave a reason for suddenly loving everyone in this channel rather than it coming out of the blue like that
23:05:29 <ivanm> aavogt: you able to give me a bit of help working out how to do some TH stuff?
23:05:38 <aavogt> sure
23:05:54 <qebab> I'm sticking with my paranoia of system failures here though any of the above is a good reason too.
23:06:55 <ivanm> aavogt: OK, I want the TH to take some type g and then generate this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25804#a25804
23:07:23 <ivanm> (becuase atm GHC can't derive instances for types using ATs)
23:07:41 <ivanm> oh, I should give the definition of Context
23:07:43 <tomberek> ivanm: ouch
23:08:13 <aavogt> ivanm: did you give this a go http://hackage.haskell.org/package/derive-gadt-0.1.1 ?
23:08:35 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25804#a25805
23:08:57 <ivanm> except GADTs are different, aren't they?
23:09:11 <aavogt> hehe, probably
23:09:26 <ivanm> plus, I thought mmorrow had given up on haskell-src-meta even before he disappeared...
23:09:41 <aavogt> ivanm: are all your data types like this records?
23:10:07 <ivanm> aavogt: it's exactly the same, it's just that atm I need to define that for every instance of InductiveGraph
23:10:27 <aavogt> basically I would split this up: 1 function gets you the arity of the constructor
23:11:03 <ivanm> aavogt: no, no.... it will pretty much be exactly that except g will be fixed
23:11:16 <ivanm> i.e. generate Show (Context ListGraph)
23:11:36 <ivanm> I've added the definition of Context
23:11:38 <aavogt> and another function writes the lambda    \(Constr a b c d e f) -> foldr (.) [shows a,shows b,shows c]
23:12:21 <aavogt> foldr1 I guess
23:12:35 <ivanm> I don't need any code generation per-se, I just need it to spit that out for a fixed value of g
23:13:39 <aavogt> I think it's about the same effort to generate for monomorphic g
23:14:14 <ivanm> what do you mean?
23:14:47 <ivanm> uggh, having a constraint like "Show (Node (ListGraph a b))" doesn't work (it wants undecidableinstances :s)
23:15:05 * ivanm wonders if providing a copy/paste solution would be preferable then
23:15:24 <ivanm> unless TH can decompose what (Node g) is to a fixed type...
23:15:52 <aavogt> don't expect too much from reify
23:15:59 <ivanm> :(
23:16:12 <ivanm> so it looks like I've been wasting my time then... :(
23:16:19 <aavogt> but if you can list those types yourself
23:16:20 <ivanm> preflex: seen TacticalGrace
23:16:20 <preflex>  TacticalGrace was last seen on #ghc 10 days, 17 hours, 50 minutes and 55 seconds ago, saying: * TacticalGrace knows from painful experience.
23:16:25 <aavogt> if there's some kind of pattern
23:16:46 <aavogt> anyhow, instance (InductiveGraph g, Show (Node g),  Show (NodeLabel g), Show (EdgeLabel g)) => Show (Context g) where
23:16:54 <ivanm> in that case, it might be easier to provide a function that does all that and let people just do instance Foo Bar where foo = fooDefault :s
23:16:55 <aavogt> that looks like you could generate it
23:17:23 <ivanm> aavogt: except it turns out you need UndecidableInstances in the general case for "(Node g)", etc.
23:17:24 <aavogt> I don't follow
23:17:32 <aavogt> you don't do those?
23:17:43 <ivanm> aavogt: for example, one value for `g' is "ListGraph a b"
23:18:12 <ivanm> if I have "Show (Node (ListGraph a b))" (where "Node (ListGraph a b)" == Int) then ghci says it needs UndecidableInstances
23:18:53 <tomberek> aavgot: ivan doesn't like undecidability
23:19:12 <aavogt> anyhow I don't know if reify can tell you about type families
23:19:16 <ivanm> tomberek: well, it looks like a code smell
23:19:23 <ivanm> it also wants FlexibleContexts
23:19:25 <ivanm> aavogt: yeah
23:19:37 * ivanm wonders if derive or drift can do this, but doesn't have much hope
23:19:38 <tomberek> ivanm: agreed
23:20:06 <aavogt> it smells like your instance resolution does serious calculation ;)
23:20:12 <ivanm> @ask TacticalGrace I take it its part of the current limitations in the type checker that you can't derive Show, etc. for datatypes that refer to Associated Types, etc. from a type class?
23:20:12 <lambdabot> Consider it noted.
23:20:19 <ivanm> aavogt: right
23:20:50 <ivanm> so, unless something like "Node (ListGraph a b)" can be resolved down to Int by TH, then this looks like a dead-end
23:21:05 <ivanm> and so we might as well give "recipes" on how to do it for people to copy/paste
23:23:24 <aavogt> if you define your type instances inside a TH splice...
23:23:34 <aavogt> then you will have access to them
23:24:50 <ivanm> aavogt: well, I was only interested in TH because I thought it could do this instance generation for me
23:25:04 <ivanm> but it looks like it's going to be more effor than its worth, so *shrug*
23:26:34 * hackagebot snap-core 0.2.4 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.4 (GregoryCollins)
23:26:48 <aavogt> I don't think it's that limiting that reify can't expand your type functions, seeing as you've already defined them yourself
23:28:12 <ivanm> aavogt: but getting the constraints right for the instance might not work properly IIUC
23:30:07 <aavogt> that depends whether the constraints are just propagated from the entries in your named data
23:30:15 <aavogt> or if there's something more fancy going on
23:32:06 <EvanR> i think i just found a type safe way to encode algebraic datatypes into object types
23:32:55 <EvanR> nevermind
23:33:06 <tomberek> EvanR : hehe, nice
23:33:08 <ivanm> aavogt: well, Node, etc. are ATs from a typeclass...
23:36:27 <EvanR> algebraic datatypes are just too awesome and too powerful
23:36:41 <EvanR> and too simple
23:40:37 * hackagebot snap-server 0.2.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.4 (GregoryCollins)
23:40:46 <aavogt> ivanm: I'd suggest wrapping those class decls in a TH splice that keeps stores that stuff in an IORef... but that's probably worse than undecidable instances
23:40:59 <ivanm> aavogt: yeah
23:41:08 <aavogt> if it's that difficult to put everything in a single splice
23:41:13 <ivanm> aavogt: oh well, those 2 or 3 people that want to write a custom instance can do some copy-pasting
23:42:24 <Jonno_FTW> ...
23:42:47 <Jonno_FTW> 'ello?
23:42:53 <tomberek> ivanm: the whole point is that people can experiment with new graph instances
23:43:02 <tomberek> i'd rather avoid the TH
23:43:06 <aavogt> as in:    $( let { a = [d| instance ... where type A = B ... |]; ... }; {- code expanding A = B given a -} in sequence [a,b,c, makeDerivationWithA=B ])
23:43:30 <aavogt> yeah, that sort of defeats the purpose of ATs imho
23:43:38 <ivanm> tomberek: well, the TH was just going to be there to let just do $(defineInstances ''ListGraph) rather than explicitly making instances of Show, etc. for Context, Edge, etc.
23:43:56 * ivanm waves idly in Jonno_FTW's general direction
23:44:03 <aavogt> hmm, maybe that would still work, ivanm
23:44:22 <aavogt> since you just want those instances to know about specific   type A = B, irght?
23:44:23 <tomberek> ok
23:44:27 <ivanm> OK, so if I don't have a type sig, then GHC doesn't care about weird type signatures, but as soon as I put a type sig in it wants extensions...
23:44:28 <aavogt> * right
23:45:09 <ivanm> aavogt: well, to have the instance declarations right it would probably need some resolving of ATs (e.g. having "Show Int" as a constraint doesn't really make much sense)
23:45:23 <aavogt> where the user instance is written like:    $(defineInstances [d| instance Foo where ... |])
23:45:45 <aavogt> ivanm: whose ATs need to be expanded?
23:46:06 <ivanm> wait, you mean write the InductiveGraph instance inside the TH?
23:46:07 <aavogt> just the ones associated with instances the 'user' defines?
23:46:12 <aavogt> yes
23:46:13 <ivanm> that looks bad...
23:46:24 <aavogt> ok
23:46:28 <aavogt> I'm convinced :S
23:46:30 <ivanm> I mean, it might be something to do down the track
23:46:52 <ivanm> but one reason why it won't work is that some of those instances they might want are optional (e.g. Show instances for the graph type)
23:47:17 <aavogt> so add more arguments to defineInstances
23:48:57 <ivanm> aavogt: maybe down the track
23:49:04 <ivanm> tomberek keeps pestering me to do stuff... :p
23:49:13 <ivanm> hmmm... where does Data.Array define its Read instances?
23:49:26 <ivanm> Show instances seem to be in Data.Array.Base, but I can't find Read :s
23:49:29 <tomberek> hey there
23:49:30 <aavogt> ghci knows better than most
23:49:53 <tomberek> ivanm: it's productive pestering!
23:50:01 <ivanm> heh
23:50:32 <ivanm> oh, that explains it... Array doesn't have a Read instance :s
23:51:23 <ivanm> dammit, I wanted an example of how to define a Read instance for something with more than one type parameter :s
23:51:42 <aavogt>  instance Read (T a b) where ...
23:51:47 <ivanm> ummm.... s/type parameter/argument to the constructor/
23:51:55 <ivanm> aavogt: as in how to actually write readsPrec
23:51:59 <ivanm> @src Read
23:51:59 <lambdabot> class Read a where
23:51:59 <lambdabot>   readsPrec    :: Int -> ReadS a
23:51:59 <lambdabot>   readList     :: ReadS [a]
23:51:59 <lambdabot>   readPrec     :: ReadPrec a
23:51:59 <lambdabot>   readListPrec :: ReadPrec [a]
23:52:08 <aavogt> @src ReadPrec
23:52:08 <lambdabot> Source not found. Do you think like you type?
23:52:19 <lispy|web> ?src ReadPrec Maybe
23:52:19 <lambdabot> Source not found. Wrong!  You cheating scum!
23:52:27 <ivanm> ReadPrec is GHC-only IIRC
23:52:35 <ivanm> it's a replacement for ReadS
23:52:39 <aavogt> ivanm: that depends on the constructor of T
23:53:29 <aavogt> basically treat it like it was some monomorphic type... but you might have to add some class contexts
23:53:34 <aavogt> @src Read []
23:53:35 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:53:56 <aavogt> or is ReadsPrec sort of like ReadP?
23:54:14 <aavogt> in which case you can use a monad instance ....
23:54:18 <aavogt> its*
23:54:23 <aavogt> it's*
23:58:27 <tomberek> ivanm: ready for an odd question?
23:58:36 <ivanm> ..... maybe ...
23:59:51 <tomberek> I'm reading the paper that introduced Applicative.. and it got me thinking,, can that be used for neural network evaluation.  The graph of activation functions, acts on the same structured graph of signals, producing a new graph of signals.
