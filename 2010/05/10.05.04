00:30:29 <tomberek> hi everyone
00:30:51 <copumpkin> yo
00:32:52 <tomberek> is there a way to set up types so that you are guaranteed that a is a member of a set b?
00:33:11 <turiya> how can an Int be converted to GLfloat?
00:33:49 <Saizan> turiya: fromIntegral
00:35:51 <turiya> Saizan, does fromIntegral convert depending on the types that are added or subtracted..
00:37:44 <Saizan> turiya: what do you mean?
00:38:02 <Saizan> ?type fromIntegral
00:38:03 <lambdabot> forall a b. (Integral a, Num b) => a -> b
00:38:08 <aep> if i think correctly what you mean, the answer is yes
00:38:08 <Saizan> ?src fromIntegral
00:38:08 <lambdabot> fromIntegral = fromInteger . toInteger
00:38:48 <turiya> sorry for bad english
00:38:52 <Saizan> it can convert any integral type, i.e. those that represent whole numbers, into any numerical type
00:39:02 <tomberek> turiya: you must specify the type you would like to convert them to
00:39:40 <turiya> ok, i see how it works
00:39:43 <aep> you have to? usually it just uses the right one depending on what the whole computation needs, for me :D
00:39:47 <Saizan> in normal programs it's usually inferred from the context
00:40:20 <Axman6> damn subnormal programs
00:40:22 <turiya> that was what i was refereing to earlier, it infers from context :)
00:41:30 <Saizan> Axman6: the supernormal ones are even worse
00:41:43 <Axman6> damn Oleg
00:41:45 <Axman6> :P
00:42:14 <copumpkin> http://vimeo.com/11081622 is fun
00:42:38 <opqdonut> tomberek: something like that can be done with type-level programming
00:42:48 <ClaudiusMaximus> tomberek: you can use strict data to _|_ more quickly than otherwise, eg: data Really b = Really !b ; then "Really (error "ouch")" will generate an error when you pattern match on the Really data constructor, even if you don't use the 'b' value inside it (I hope i didn't get that wrong) but I'm not sure if it's what you mean to ask
00:43:15 <opqdonut> tomberek: would a and b be known compile-time or only run-time?
00:44:15 <opqdonut> tomberek: if you take some care you can wrap the set and members in custom newtypes (e.g. MySet, MyMember) and have custom functions for them that guarantee some additional safety
00:44:30 <tomberek> opqdonut: I'm thinking of using Set (or IntSet),, but in the end, I want a data type with two things, a set, and a particular element of that set.  But guaranteed that it's a member via types.
00:44:55 <opqdonut> tomberek: well, the simplest way to do that is to hide the constructor
00:45:05 <opqdonut> or rather, something like that
00:45:13 <opqdonut> but you can't _really_ guarantee it in haskell
00:45:17 <opqdonut> you'd need dependent types
00:46:27 <opqdonut> but you can do something like "newtype MySet = MySet (Int,IntSet); mysetify set = MySet (getMin set,set);" and then only expose the mysetify function, not the MySet constructor
00:46:45 <opqdonut> then, outside that module, you can be sure that a MySet holds a set and an element of that set
00:47:12 <tomberek> opqdonut: yeah, that seems like the smelly way... i though haskell might have a cool way to do it in types
00:47:31 <ezyang> Let's say I have the source code for a cabalized package, and I want to find out what functions it exports w/o having to compile it. Is there any easy way to do this?
00:48:11 <opqdonut> tomberek: it's not that smelly IMO
00:48:12 <tomberek> ezyang, you can run haddock and get source docs made for you
00:48:37 <ezyang> tomberek: I was under the impression that Haddock needs the library to compile, though?
00:49:05 <tomberek> is it compilable?
00:49:14 <ezyang> Not necessarily.
00:49:27 <ezyang> (I'm doing a survey of all packages on HackageDB)
00:50:11 <tomberek> ouch, if you don't know it will compile, i think you'd have to search through it...... eh, i'd ask someone higher up the food chain than me.
00:50:17 <tomberek> opqdonut: perhaps, but I thought there was a nicer way
00:51:24 <ezyang> Yeah, I'm think of AST-izing the code and then looking for stuff that looks like exports
00:52:06 <tomberek> ezyang: hoping that everyone exports, otherwise you have to trust indentation,, basically you end up doing parsing
00:52:15 <ezyang> well, parsing is not difficult
00:52:23 <ezyang> since there's Language.Haskell
00:52:41 <ezyang> but it'll have to play with Cabal and stuff...
00:52:46 <tomberek> go for it, i hate parsing
00:53:02 <ezyang> even with parser combinators? ;-)
01:56:01 <scott__> hello!
01:56:08 <scott__> anyone awake?
01:56:16 <quicksilver> always
01:56:16 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
01:57:01 <scott__> can i ask a relatively simple question?
01:57:11 <quicksilver> just ask :)
01:57:27 <scott__> so i get this error:
01:57:28 <scott__> scott.hs:57:0:     Occurs check: cannot construct the infinite type: a = [a]     When generalising the type(s) for `removePicked' Failed, modules loaded: none.
01:57:35 <scott__> i know what its saying
01:57:40 <scott__> but dont see the error
01:57:44 <scott__> here's the func
01:58:19 <scott__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25317#a25317
01:58:53 <quicksilver> scott__: your problem is 'return' on the last line.
01:59:01 <quicksilver> just "else xs" is fine
01:59:05 <scott__> oh!
01:59:08 <scott__> well that was dumb
01:59:09 <scott__> ...
01:59:15 <scott__> thanks i didnt even realize
01:59:15 <quicksilver> return in haskell is not as return in other languages :)
01:59:31 <scott__> yep, i knew that
01:59:37 <scott__> ive just been working with monads...
02:14:13 <sadache> i am looking for a paper about using comonads in Haskell
02:14:31 <xerox> there's something on sigfpe blog (not a paper though)
02:19:42 <sadache> it looks like a very rich blog, thanks for the pointer
02:21:32 <xerox> sure
02:31:43 <tomberek> @djinn a->a
02:31:43 <lambdabot> f a = a
02:31:57 <tomberek> @djinn (a,b)->(b,a)
02:31:57 <lambdabot> f (a, b) = (b, a)
02:33:20 <xerox> > (snd &&& fst) (x,y)
02:33:21 <lambdabot>   (y,x)
02:33:39 <tomberek> @djinn [(a,b)]->[(b,a)]
02:33:39 <lambdabot> Error: Undefined type []
02:33:56 <xerox> :t map (snd &&& fst)
02:33:57 <lambdabot> forall a b. [(a, b)] -> [(b, a)]
02:33:58 <tomberek> ok, i'll map it
02:34:04 <Jafet> @hoogle swap
02:34:04 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
02:34:05 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
02:34:19 <timofonic> xerox: DMCA is gonna destroy your nickname! :D
02:34:32 <xerox> I'll resist!
02:34:51 <timofonic> xerox: corps are powerful and evil
02:35:22 <xerox> I've got anti-corps
02:36:40 <timofonic> xerox: They have ninja lawyers
02:37:00 <xerox> I have pirate lawyers
02:37:17 <xerox> @arr
02:37:18 <lambdabot> I want me grog!
02:38:22 <Baughn> @hoogle Map a b -> Map b c -> Map a c
02:38:23 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
02:38:23 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
02:38:23 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
02:38:49 <xerox> you also need Eq or b->b->Bool I guess?
02:39:03 <ivanm> xerox: are you rapping or something?
02:39:12 <ivanm> "b-b-bool" :p
02:39:16 <Baughn> > Data.Map.fromList [(1,2)] >>> Data.Map.fromList [(2,3)]
02:39:17 <lambdabot>   Not in scope: `Data.Map.fromList'Not in scope: `Data.Map.fromList'
02:39:49 <Baughn> ..nope. No such category.
02:40:39 <Saizan> we could write (>>>) with a gadt wrapper, but id is not really feasible
02:40:59 <Saizan> unless one adds a syntetic one
02:41:14 <Baughn> Mm. chainMap seems like something that should be in the library, though.
02:43:56 <scott__> quicksilver: another quick question
02:44:30 <scott__> for anyone really
02:44:59 <scott__> i run this code
02:44:59 <scott__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25319#a25319
02:45:24 <scott__> with >4000 as the number of iters and it takes too long
02:45:31 <scott__> any ideas for optimization?
02:46:19 <Botje> scott__: don't recalculate the length each time
02:46:45 <scott__> in pick?
02:46:51 <Botje> yeah
02:46:56 <quicksilver> scott__: 'pick' is hideous.
02:47:02 <quicksilver> scott__: never, ever, ever use unsafePerof
02:47:07 <scott__> yeah, i know...
02:47:07 <quicksilver> unsafePerformUI.
02:47:08 <quicksilver> IO.
02:47:11 <quicksilver> damn keybaord :P
02:47:36 <Jafet> unsafePerof will murder you in your bed
02:47:43 <scott__> :(
02:47:46 <fasta> scott__, it also seems you are using list as if they are C arrays.
02:47:50 <quicksilver> it's also a bit of a waste to calculate the list [0..(n-1)] purely to pick a random element of it
02:47:58 <quicksilver> why not just generate a random number from 0 to n-1?
02:48:00 <fasta> scott__, lists*
02:48:16 <fasta> scott__, and for these things libraries already exist.
02:48:30 <scott__> ?
02:48:50 <quicksilver> you've used random numbers to make a non deterministic function, that's horrible
02:49:00 <scott__> yeah, pick is really dumb
02:49:03 <scott__> i can do away with it
02:49:37 <Jafet> To randomly remove with a given distribution, calculate the indices and then remove them from the list.
02:49:49 <Jafet> It seems that you're going for a uniform one
02:50:28 <Baughn> quicksilver: How would you feel about a pure quicksort that internally uses a random pivot?
02:50:31 <Jafet> I can't be bothered to think of a lazy algorithm, but there is one as well
02:50:38 <supert> hi where can I ask whether writing a cfd code in haskell is lunatic
02:51:02 <scott__> can you explain?
02:51:06 <Jafet> Baughn, put that in your webserver and unsafePerof will murder it in its rack-mount.
02:51:55 <scott__> Jafet: my problem with this is
02:52:01 <supert> well,
02:52:10 <scott__> i want to remove a certain percentage
02:52:26 <scott__> and if use a drop every nth element kind of thing
02:52:39 <scott__> the remainder poses a problem
02:52:52 <scott__> i get sort of far off that percentage
02:54:35 <chrisdone> ciao amigos
02:55:32 <scott__> Jafet: is there a way to do this that is not by dropping every nth element?
02:57:59 <Jafet> First figure out, given the length of a list and the parameter, exactly which elements you want to drop.
02:58:24 <scott__> well, that's the problem
02:58:39 <Jafet> Instead of what you are doing now, which is the python approach
02:58:52 <Jafet> Guessing at code and hoping it works
02:59:00 <scott__> haha
02:59:01 <Jafet> Get pencil and paper and work it out.
03:00:27 <ManateeLazyCat> dcoutts_: Thomas have bulid a "hashed-format" repository for build gtk2hs mirror repository.
03:00:50 <ManateeLazyCat> dcoutts_: I'm upload all patches (2133) to patch-tag.com, perhaps need long lont time to finish that.
03:01:32 <scott__> well, for example, I have 67936 elements and want to remove 4035.  if i remove 1 out of every 17, i come close, but not quite there.  i need to remove the rest randomly to get the most even distribution of removals
03:01:34 <scott__> no?
03:01:41 <ManateeLazyCat> dcoutts_: After i upload and test finish, we will convert gtk2hs main repository to "hashed-format"
03:02:16 <dcoutts> ManateeLazyCat: you've arranged that with Axel?
03:02:34 <ManateeLazyCat> dcoutts: Yes.
03:02:41 <dcoutts> ok
03:02:43 <ManateeLazyCat> dcoutts: Axel has argee that.
03:02:47 <dcoutts> sounds like a plan
03:04:07 <ManateeLazyCat> dcoutts: BTW, if i convert gtk2hs main repo to "hashed-format", this action safe? I mean i can rollback if i do something wrong.
03:04:38 <ManateeLazyCat> dcoutts: Wow, so fast, i have upload all patches to patch-tag.com
03:05:02 <ManateeLazyCat> Just 10 mintues.
03:05:35 <ivanm> ManateeLazyCat: no, you can't unconvert a repo
03:06:23 <ManateeLazyCat> ivanm: Ok, i will contact Axel again.
03:06:30 <ManateeLazyCat> ivanm: And make sure everything is fine.
03:06:41 <dcoutts> ManateeLazyCat: for improved safety, standard practise would be to "darcs get" the repo locally (ie on the server)
03:06:50 <dcoutts> ManateeLazyCat: that gives you a copy in the hashed format
03:07:02 <ManateeLazyCat> dcoutts: Yes, i have backup gtk2hs.
03:07:03 <dcoutts> if that works, then swap it for the original, using mv
03:07:27 <ivanm> ManateeLazyCat: OK
03:08:16 <ManateeLazyCat> dcoutts: Ok, i will be careful.
03:09:24 <ManateeLazyCat> http://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror
03:10:30 <ManateeLazyCat> all gtk2hs users, http://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror is "synchronous mirror repository" for gtk2hs main repository : http://code.haskell.org/gtk2hs, you can access this mirror repository if code.haskell.org is down.
03:11:07 <ManateeLazyCat> Please send any patches to gtk2hs main repository, thanks!
03:11:46 <dcoutts> ManateeLazyCat: in what sense is it synchronous?
03:12:22 <ManateeLazyCat> dcoutts: Just alternative repository if code.haskell.org is down.
03:12:43 <Baughn> ManateeLazyCat: What information does "synchronous" convey that "mirror repository" doesn't?
03:13:05 <ManateeLazyCat> Baughn: Just mirror repository is okay?
03:13:22 <ManateeLazyCat> Baughn: Sorry, my English is really bad sometimes.
03:13:48 * ManateeLazyCat I think synchronous is unnecessary word for mirror. :)
03:14:44 <ManateeLazyCat> Ok, i change describe.
03:15:18 <Baughn> Description. Describe is the verb.
03:15:46 <ManateeLazyCat> Well, the name "gtk2hs-sync-mirror" can't change now. :)
03:16:32 <ManateeLazyCat> As a mark on it. :)
03:16:42 <ManateeLazyCat> For my bad English. :)
03:18:22 <ManateeLazyCat> dcoutts: I want return message "Please send patches to http://code.haskell.org/gtk2hs ." when someone send patch to AndyStewart@patch-tag.com:/r/AndyStewart/gtk2hs-sync-mirror , can do that?
03:28:15 <whald> i have "class (Eq a) => Intersectable a where ..." and "data AnyIntersectable = forall a. Intersectable a => MkAnyIntersectable a"
03:28:36 <whald> what would "instance Eq AnyIntersectable where" look like?
03:29:24 <Saizan> you can't write it
03:29:46 <Saizan> well, it depends on the methods of Intersectable
03:29:49 <whald> i think "forall" and me never make friends :-)
03:30:25 <Saizan> but with just the Eq context you can't compare two existentially wrapped values, because you've no reason to conclude the underlying type is the same
03:30:26 <whald> intersectable deals with ray / primitive intersections
03:30:47 <whald> if it's not the same, they're not equal
03:30:58 <Saizan> yeah, but you've no way to tell either :)
03:31:04 <whald> :-)
03:31:24 <Jafet> Break out the DataType?
03:31:34 <Saizan> if you really want that you can add a Typeable context
03:31:54 <Saizan> this is basically what you do in e.g. Java and instanceof
03:32:07 <Saizan> s/and/with/
03:32:31 <whald> oh! Java! instanceof! i'm back home :-)
03:32:36 <Jafet> I think this is too abstract an approach to computational geometry
03:33:08 <Saizan> somewhat nicer maybe, since instanceof can't take variables for the class type, though there's the rest of reflection which can..
03:33:39 <whald> Jafet: i feel like that to, but i don't know how to express it more concise
03:33:56 <whald> s/to/too
03:34:02 <Saizan> anyhow, if you end up needing this maybe you should redesign
03:34:54 <whald> hehe, i'm redisigning for 2 full days now, and my code shrinks and shrinks (maintaining the functionality)
03:35:03 <Saizan> but i'd look like "AnyI x == AnyI y = fromMaybe False (==y) (cast x)"
03:35:16 <Saizan> *it'd
03:35:36 <Saizan> s/fromMaybe/maybe/
03:37:33 <Saizan> (however the problem might be premature abstractness/generalization)
03:38:07 <whald> yes, i'd like to get rid of that
03:40:18 <Baughn> So I've been writing some fairly large programs lately, and.. by far the most annoying part of using Haskell is the difficulty of updating nested data structures (such as, say, Map Foo (Map Bar (Map Int Baz))). Agreed?
03:40:52 <dv-> Yes
03:41:02 <Baughn> It makes me want to promote data-accessors to a GHC syntax extension. Or at least fix its template module.
03:41:21 <zygoloid> Baughn: hah, i was just about to say something about the same problem :D
03:41:53 <zygoloid> although in my case i have a mutable cyclic data structure, and the maps are UniqueId ~> Node
03:41:57 <Baughn> Well, what I /really/ want is an SQL-like structure that can be parametrized on multiple indexes.. with joins, etc.
03:43:07 * Baughn mumbles to himself. ..let's try to finish the FRP thing first.
03:44:02 <dv-> FRP thing?
03:44:27 <zygoloid> (i think what i want is an immutable, nice, pure view of my data structure: view :: Node UniqueId -> Mu Node; view = fmap (In . (nodeMap!)))
03:44:49 <Baughn> Yeah.. I've been trying to write a Conal-style FRP library, only with more emphasis on performance
03:45:09 <Baughn> Wrote the most difficult bit of that a year ago, and then I totally forgot about it. :P
03:45:14 <Saizan> happstack-ixset is an SQL-like structure, the implementation would need some love though
03:45:15 <zygoloid> Baughn: Conal-style meaning an elegant implementation with unamb-style operators?
03:45:33 <Baughn> zygoloid: No, meaning elegant *interface*. The implementation is anything but.
03:45:55 <Baughn> zygoloid: Basically - same interface, much more pragmatic internals.
03:46:27 <Baughn> ..I got halfway through an impossibility proof for it, then I hit a contradiction. It's possible. I think.
03:46:29 <dv-> I thought Yampa and Elerea were pretty fast already...? There are 3d engines written with them
03:46:44 <Baughn> Those have a different interface, though
03:47:53 <zygoloid> Baughn: that sounds like the right approach to me.
03:48:02 <Baughn> zygoloid: Imagine, if you will, a module where unsafePerformIO is used so often I had to shorten it to io.
03:48:15 <idnar> Baughn: yeesh
03:48:18 * Baughn is using it as unsafeExtendRuntime
03:48:20 <idnar> scary
03:48:59 <Baughn> http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <-- Actually, there's no need to imagine.
03:49:03 <Saizan> Baughn: never thought about hacking GHC directly?:)
03:49:20 <Baughn> Saizan: That's the next step. :P
03:50:05 <Baughn> Saizan: I've isolated the important, implementation-dependent parts in that one module. Later I could try implementing it directly in GHC; it won't require rewriting any (er, currently unwritten) other parts of the library.
03:50:27 <Saizan> that's nice
03:51:03 <zygoloid> Baughn: *blink* does lockTime really work, written like that?
03:51:29 <zygoloid> it... it scares me.
03:52:08 <Baughn> zygoloid: I should.
03:52:10 <Baughn> *It should
03:52:18 <Baughn> ..what makes you think it wouldn't?
03:52:50 <zygoloid> well, i guess nothing, but i don't really /trust/ NOINLINE to be "enough" within the same module ;)
03:53:14 <Baughn> Oh. That.
03:53:15 <Baughn> Um.
03:53:20 <Baughn> It seems to work.
03:53:33 <zygoloid> it doesn't scare me as much as newTime does :)
03:54:31 <Baughn> zygoloid: There may be an insufficiency of {-# NOINLINE #-}.
03:54:56 <Baughn> zygoloid: What scares me most is wait. I couldn't figure out how to chop that thing up.
04:02:46 <zygoloid> Baughn: it looks like "wait :: ITime -> ITime -> IO Ordering" would cover all your use cases
04:03:26 <Baughn> Probably. Yes, okay, I know /that/ one is screwy.
04:03:38 <Baughn> Anything with "Either a a" in its signature is horrifying.
04:04:11 <zygoloid> (you know that, for instance, if it returns LT then the first param is complete, if it returns GT then the second is, and if it returns EQ then they both are)
04:04:44 <Baughn> ..so basically, an Ord instance. Which I need anyway.
04:05:10 <zygoloid> (incidentally, looks like you could just use: it1 == it2 = it1 `compare` it2 == EQ)
04:20:24 <ManateeLazyCat> IO Side: "You don't rely on side-effects of this function, which may be not executed if its results are not needed."
04:20:38 <ManateeLazyCat> This is key for how to use `unsafePerformIO`.
04:21:20 <Botje> unsafeperformio is fine in my book if it doesn't have side effects and always returns the same
04:21:40 <Botje> but then you might as well stick those at the top of main and pass them into pure code
04:21:48 <Jafet> @quote simonsays
04:21:49 <lambdabot> pikhq says: <kmc> you use simonSaysPerformIO to make it so <pikhq> Yes, but you should think long and hard before using it if you're not named Simon.
04:21:56 <ManateeLazyCat> Botje: I read "IO Side" again and again for understand how to use `unsafePerformIO` correctly.
04:22:27 <Botje> i don't know what IO side is, but that's what i found to be okay
04:22:38 <ManateeLazyCat> http://www.haskell.org/haskellwiki/IO_inside
04:22:44 <Botje> oh, and also for creating global mutable variables (unsafePerformIO $ newIORef ...)
04:23:17 <ManateeLazyCat> Botje: No, i don't use `unsafePerformIO` for global mutable.
04:23:27 <ManateeLazyCat> Botje: Just use for binding some gtk2hs code.
04:23:49 <ManateeLazyCat> Botje: I need make sure i understand those details correctly.
04:24:56 <ManateeLazyCat> The two rules for use `unsafePerformIO` (from IO Inside):
04:25:00 <ManateeLazyCat>  1. The result of each call depends only on its arguments.
04:25:00 <Botje> "That said, here's some really hairy code. This should frighten any pure functional programmer..."
04:25:02 <ManateeLazyCat>  2. You don't rely on side-effects of this function, which may be not executed if its results are not needed.
04:25:03 <ManateeLazyCat>  
04:25:03 <Botje> haha
04:26:12 <ManateeLazyCat> Botje: `unsafePerformIO` is handy for some binding code, such as "extract field", but we need use `unsafePerformIO` carefully.
04:26:54 <Botje> yep, definitely.
04:27:04 <Botje> since the field might change and you don't want that
04:28:08 <ManateeLazyCat> Botje: I'm bulid gio binding, and found original author write some `unsafePerformIO` in binding code.
04:28:28 <ManateeLazyCat> Botje: And i need make sure those `unsafePerformIO` is safe.
04:28:58 <ManateeLazyCat> http://patch-tag.com/r/AndyStewart/gio-branch/snapshot/current/content/pretty/System/GIO/File/File.chs
04:30:05 <ManateeLazyCat> Botje: Dinner, back soon.
04:37:15 <scott__> if I want to pull the second item in a list, which is most efficient?    !! or head (tail )
04:39:34 <Jafet> ghc will probably generate equivalent code
04:39:49 <Jafet> Unless you're golfing, then it would be the former
04:41:01 <rsaarelm> I'd guess that a naive implementation of !! employs heavier computational machinery than head . tail.
04:45:10 <Jafet> @src (!!)
04:45:11 <lambdabot> xs     !! n | n < 0 = undefined
04:45:11 <lambdabot> []     !! _         = undefined
04:45:11 <lambdabot> (x:_)  !! 0         = x
04:45:11 <lambdabot> (_:xs) !! n         = xs !! (n-1)
04:45:25 <Jafet> Shit you're right
04:47:38 <scott__> 'what if i have a list of 2
04:47:47 <scott__> is head . tail better than last?
04:47:50 <scott__> or no
04:50:16 <koala_man> if it's a list of 2, it should perhaps be a tuple
04:51:21 <scott__> well, it wont always be a list of 2
04:51:30 <scott__> its taking in a multichannel file
04:51:34 <alpounet> @src last
04:51:34 <lambdabot> last [x]    = x
04:51:34 <lambdabot> last (_:xs) = last xs
04:51:34 <lambdabot> last []     = undefined
04:51:35 <Jafet> What does better mean
04:51:45 <Jafet> I doubt either would contribute measurably to your sex life.
04:51:47 <scott__> i need speed
04:51:56 <Jafet> Then I suggest the local dealer.
04:51:58 <scott__> and again, not talking about my sexlife
04:51:59 <scott__> haha
04:52:01 <pkrumins> haha
04:52:10 <Jafet> Then compile it and profile it
04:52:22 <alpounet> scott__, i doubt there will be a noticeable difference
04:52:25 <koala_man> did you profile the code and find that the significant cost was in picking the second element from a list?
04:52:44 <scott__> No, didn't try that
04:53:03 <alpounet> scott__, what's your code doing ?
04:53:05 <scott__> Looking at the wiki
04:53:07 <alpounet> i mean, that part of the code
04:53:07 <scott__> Thanks
04:53:21 <scott__> alpounet, I'm not so sure yet...
04:53:32 <scott__> :)
04:53:35 <alpounet> oh
04:54:10 <scott__> What it's doing and what it's supposed to do are two fairly different things
04:54:32 <alpounet> there are various optimized containers out there on hackage that may actually give you a speedup depending on the operations you perform the most, etc
04:54:49 <scott__> hm, OK
04:55:02 <scott__> I'll take a look.
04:55:04 <alpounet> so what is it supposed to do ?
04:55:17 <scott__> But it seems clear that !! is not the right way to go - often gets "Index too large"
04:56:09 <scott__> Well this little snippet it looking at a large list of floats from a .wav file and manipulating them
04:56:22 <alpounet> well, if you often need !!, you may want to look at the vector package for example
04:56:26 <alpounet> @package vector
04:56:26 <lambdabot> http://hackage.haskell.org/package/vector
04:56:35 <scott__> Yeah, I took a look at Vector
04:56:50 <scott__> but it was a pain and !! is not really necessary
04:57:14 <scott__> head, head . tail, and last should suffice
05:02:36 <quicksilver> Baughn: probably would be bad if the implementaiton wasn't stable.
05:02:57 <quicksilver> Baughn: if you got that detail right, then, sure, the unsafePerformIO side condition would be validated. It would be OK although I'd still find it ugly.
05:03:12 * hackagebot control-monad-failure 0.6.1.1 - A class for monads which can fail with an error.  http://hackage.haskell.org/package/control-monad-failure-0.6.1.1 (PepeIborra)
05:09:47 <ManateeLazyCat> Why VLC can increase volume to 200% ?
05:10:14 <ManateeLazyCat> Any tools can do that like VLC ?
05:10:40 <Jafet> I suspect that would potentially cause clipping.
05:10:41 <Lemmih> ManateeLazyCat: Spinal Tap, perhaps? (:
05:10:46 <Baughn> ManateeLazyCat: mplayer has -af volume
05:11:01 <Baughn> And you can do it with an ALSA plugin
05:11:09 <ManateeLazyCat> Baughn: I want increase system volume.
05:11:25 <Baughn> ..alsa plugin, then. THough, um, is this the right channel?
05:11:27 <Baughn> Try #alsa
05:11:45 <Jafet> ...unless your sound server isn't alsa!
05:11:45 <ManateeLazyCat> Lemmih: Jazz, but volume too low, i want increase it
05:11:53 <Jafet> linux sound is fun. I lied.
05:12:12 <ManateeLazyCat> Baughn: Thanks,
05:12:16 <Baughn> Jafet: ..you make me want to strangle you. Please stop.
05:12:25 <Baughn> Linux sound is a real trainwreck
05:12:29 <Jafet> If the audio files themselves are soft, you can set replay gain attribute.
05:12:52 <Jafet> Which is probably the correct solution in that situation
05:13:19 <Choko> I have a class defined in one module (module A) and an instance of that class in another module (module B). Is there a way to make the module A visible to my module C when i import the module B?
05:13:36 <Baughn> If it's system-specific, and you want it for /all/ sound, the right approach is definitely alsa configuration.
05:13:46 <ManateeLazyCat> Baughn: I just live in #haskell forever, so i'm too lazy ask in other channel. :)
05:13:58 <Baughn> Choko: module B ( module A ) where import A
05:14:11 <Choko> thanks
05:14:11 <Baughn> Choko: I.e. put "module A" in the export list of B
05:14:23 <ManateeLazyCat> Baughn: I ask in #alsa
05:16:12 * Baughn gets the impression jon_of_arc just punched out cthulhu
05:16:37 <Entroacceptor> rofl
05:16:39 <jon_of_arc> Heh. With a steamship, maybe :)
05:19:29 <ManateeLazyCat> Baughn: -af option is cool
05:20:10 <ManateeLazyCat> Baughn: Lound enough
05:20:16 <Baughn> ManateeLazyCat: Try "mplayer -speed 0.75 -af scaletempo=speed=pitch"
05:20:17 <ManateeLazyCat> :)
05:21:26 <ManateeLazyCat> Baughn: What's the scaletempo ?
05:21:36 <Baughn> ManateeLazyCat: Try it.
05:21:50 <ManateeLazyCat> Baughn: Yes, i'm listening
05:21:58 <ManateeLazyCat> Baughn: Any different?
05:22:12 <Baughn> Er, it's supposed to reduce pitch by an octave or so
05:22:22 <Baughn> *three-quarters an
05:22:53 <ManateeLazyCat> Baughn: Never use this tips before. :)
05:23:10 <ManateeLazyCat> Baughn: But i love "-af volume=..."
05:25:50 <ManateeLazyCat> Baughn: Write something in ~/.mplayer/config , thanks for your help!
05:26:28 * Baughn has, at last count, five distinct aliases to invoke mplayer with different parameters
05:26:55 <Baughn> ManateeLazyCat: Oh yeah. If you're using headphones, you also want -af bs2b. You may need to install bs2b and recompile mplayer first.
05:27:23 <ManateeLazyCat> Baughn: What's the bs2b?
05:27:35 <scott__> Is there more to
05:27:49 <scott__> "_|_" than just meaning error?
05:28:11 <fasta> scott__, it means bottom, not error.
05:28:11 <scott__> Why is this symbol used?
05:28:12 <Baughn> ManateeLazyCat: A sound mixer designed to take a stereo signal (meant for stereo speakers) and convert it to a headphone signal, such that you hear approximately the same thing you would if you were actually using speakers.
05:28:17 <ManateeLazyCat> Baughn: Looks you're mplayer master. :)
05:28:22 <Baughn> ManateeLazyCat: hrtf is the surround-sound equivalent.
05:28:24 <fasta> scott__, which is why it looks likes a bottom.
05:28:33 <scott__> fasta: Okay
05:28:42 <zygoloid> scott__: there's a partial ordering of values by definedness. _|_ is the bottom of this ordering.
05:28:46 <fasta> scott__, there are two different kinds of things which are bottom.
05:28:57 <Baughn> ManateeLazyCat: Many stereo signals get very tiring if piped directly into headphones. bs2b fixes that.
05:29:15 <fasta> scott__, there is the object called "undefined"/error "Oh,noes" and there is a compuation like x=x.
05:29:21 <fasta> scott__, computation*
05:29:38 <ManateeLazyCat> Baughn: Ok, i try to that.
05:29:42 <zygoloid> there are exceptions and non-termination
05:29:44 <fasta> scott__, the compiler could implement undefined as undefined = undefined.
05:29:54 <zygoloid> but non-termination is sometimes transformed into an exception
05:29:57 <Jafet> There is also the NonTerminationException
05:29:59 <zygoloid> exceptions can be caught in the IO monad
05:30:07 <Jafet> I've wondered how that works
05:30:22 <Baughn> ManateeLazyCat: And I'm no mplayer master, but my ~/.bashrc does contain several years' worth of experimentation with it.
05:30:46 <scott__> zygoloid: Bottom is the least defined when is comes to definedness? XD
05:30:48 <ManateeLazyCat> :)
05:30:49 <zygoloid> Jafet: if you're evaluating a thunk and you demand a thunk which is already being evaluated, what do you do? :)
05:31:02 <zygoloid> scott__: right. bottom is the unique least defined value of any type.
05:31:17 <Jafet> My head is looping!
05:31:22 <scott__> zygoloid: How do you even order things by definedness?
05:31:27 <Jafet> > let x = y; y = x; in x
05:31:31 <lambdabot>   mueval-core: Time limit exceeded
05:31:45 <Jafet> How do you cause it again
05:31:55 <zygoloid> scott__: well, (_|_, True) < (42, True), and (42, _|_) < (42, True), but (_|_, True) is neither greater nor less than (42, _|_)
05:32:08 <Baughn> scott__: bottom is the only value all types share. Except those that don't. There are unlifted types (Int#, etc.), but stay away from those.
05:32:22 <Baughn> > undefined :: Int#
05:32:23 <lambdabot>   Not in scope: type constructor or class `Int#'
05:32:27 * Baughn pouts
05:35:08 <scott__> zygoloid: I see.
05:35:33 <scott__> zygoloid: But beyond bottom, how can you rank things in terms of definedness?
05:36:01 <scott__> zygoloid: I mean, (42, True) is no more defined than (43, True), right?
05:36:20 <scott__> zygoloid: Everything else can be in any order, right?
05:36:23 <quicksilver> it's a partial order
05:36:30 <quicksilver> those things are incomparable
05:36:33 <ManateeLazyCat> Baughn: "af=volnorm" make volume maximum?
05:36:37 <quicksilver> (the ones you just showed)
05:36:38 <Baughn> > (undefined, 42) `lub` (42, undefined)
05:36:39 <lambdabot>   Not in scope: `lub'
05:36:52 <scott__> quicksilver: Okay, got it.
05:36:57 <Baughn> ManateeLazyCat: Kind of.
05:37:37 <quicksilver> scott__: it's the partial order which underlies the idea of 'partly computed' ; as in "I might consistently go back in and finish some more bits of this calculation later"
05:37:46 <quicksilver> it's how we give a semantics to lazy evaluation.
05:37:51 <Baughn> ManateeLazyCat: You don't want that one, though. It'll remove any kind of dynamism.
05:38:06 <Baughn> (Though it works fine on speech)
05:38:07 <scott__> quicksilver: It's such a formal way of defining definedness!
05:38:11 <quicksilver> :)
05:39:01 <scott__> quicksilver: Are these semantics useful for talking about other things?
05:39:25 <Saizan> general recursion too
05:40:38 <quicksilver> scott__: interestingly, a lot of this was most famously written down by someone call Scott :)
05:40:58 <quicksilver> scott__: google for 'Scott domain'
05:41:17 <scott__> quicksilver: I don't know.  Right now, I'm thinking "gimme a break!", but maybe there is a reason for all these semantics.
05:41:39 <quicksilver> there are reasons. They may not be be relevant to everyone :)
05:41:56 <quicksilver> I don't think much about the quantum interactions in the tea I drink.
05:42:13 <quicksilver> It's perfectly possibly to program haskell without understanding bounded complete cpos.
05:42:17 <Baughn> Really? They're *fascinating*, though.
05:42:43 <Baughn> By use of an appropriate decoherence distributor, you can exploit tea (okay, any hot liquid) to generate finite amounts of improbability.
05:42:49 <quicksilver> Baughn: right. There is a lot that is fascinating, and only a limited amount of time available to fascinate.
05:43:56 <scott__> Ha-ha...
05:44:30 <quicksilver> Baughn: I hate to be pedantic but those are classical interactions :)
05:44:44 <quicksilver> quantum mechanics is not required to explain brownian motion.
05:45:10 <Baughn> quicksilver: Technically, it was a HHGttG reference. ;_;
05:45:14 <quicksilver> I know
05:45:19 <quicksilver> I am familiar with the reference.
05:45:27 <quicksilver> and it does not mention quantum mechanics as I recall it :)
05:45:56 <Baughn> Eh. Quantum mechanics is the only level at which there is anything approaching actual randomness, though.
05:46:32 <dv-> Pi is random
05:46:44 <xerox> or is it
05:46:44 <roconnor> swap has been abandoned due to bikesheding: http://hackage.haskell.org/trac/ghc/ticket/3298#comment:9
05:46:52 <Baughn> Pi is unpredictable. Not random.
05:47:05 <roconnor> we can't decide wheter to paint the bikeshed strict or lazy, so we get no powerplat.
05:47:11 <roconnor> powerplant
05:48:47 <roconnor> consenus fail!
05:50:51 <scott__> Okay, I think I get what a dcpo is.
05:51:07 <scott__> And a cpo is a dcpo with a least element.
05:52:26 <scott__> So, every subset of a dcpo has a supremum, or smallest maximum.
05:52:43 <trzkril> every?
05:53:03 <scott__> Oh, no.
05:53:15 <scott__> Every subset which has a maximum as a smallest maximum!
05:53:20 <dv-> Baughn: the digits are randomly distributed, aren't they?
05:53:45 <scott__> *has
05:54:33 <Baughn> dv-: That is not the same as them actually being /random/.
05:57:44 <dv-> I don't believe in randomness which is why quantum mechanics annoys me
05:58:12 <ajcc> but quantum mechanics is not random, it's just uncertain
05:58:49 <Baughn> The only uncertainty in quantum mechanics is about what you will experience (sort of), not what will actually happen
05:59:40 <dv-> I've never seen a good explanation of the state function collapse
05:59:53 <Baughn> Me neither. I don't think it collapses.
05:59:53 <roconnor> dv-: there is none
06:00:22 <dv-> There's a linear evolution and the Plonk! collapse!
06:00:25 <dv-> then*
06:00:29 <Baughn> dv-: Adding a collapse postulate adds no predictive power to the theory. You see that same universe even if the wavfunction /doesn't/ collapse.
06:00:44 <roconnor> Baughn: that's a pretty bold claim
06:00:59 <Baughn> Mm. It's a well-supported one, though.
06:01:09 <roconnor> Baughn: what do you mean by "You see"
06:01:23 <dv-> If you see it then it's already collapsed
06:01:23 <Baughn> roconnor: "It all adds up to normality".
06:01:51 <Baughn> dv-: Why should it have collapsed?
06:02:04 <roconnor> what all adds up?
06:02:40 <dv-> Baughn: otherwise there wouldn't a specific event in a specific place and time, but something smeared all over
06:03:01 <scott__> quicksilver: So, is definedness a cpo, where the least element is _|_?
06:03:11 * roconnor vaguely recalls problems with Everrit interpretations
06:04:00 <quicksilver> scott__: that's one way to say it.
06:04:01 <Baughn> dv-: http://en.wikipedia.org/wiki/Einselection <-- Not so much.
06:04:15 <Baughn> roconnor: That would be interesting, if true. I haven't heard of anything.
06:04:21 <quicksilver> scott__: I would say : "Values are a cpo, ordered by definedness, where the least element is _|_"
06:04:53 <quicksilver> or if I was being really pedantic, something like "We denote the values of haskell expressions in a cpo...."
06:05:07 <scott__> quicksilver: Ha-ha...
06:05:21 <roconnor> Baughn: IIRC the problem is that the fraction of the universes with minds that observe the distribution of events corresponding the the required probability distribution is vanishingly small.
06:05:43 <Baughn> roconnor: Oh, you mean that there's no obvious explanation for the born probability distribution.
06:05:44 <roconnor> there was a recent proposal that fixes this problem
06:05:53 <Baughn> Mangled-worlds? ^^;
06:06:08 <Baughn> The born probability goes just as unexplained in non-everett interpretations, though
06:06:10 <roconnor> that sounds vaguely like what the proposal involved
06:06:16 <roconnor> oh sure
06:06:33 <Baughn> Mm. I think Mangled-worlds is probably the most disturbing physical theory I've ever had the misfortune to read.
06:06:49 <roconnor> I've only skimmed an article on it.
06:06:59 <dv-> Baughn: that's interesting but seems to require thermodynamics as well.
06:07:30 <Baughn> dv-: Not a major issue. Thermodynamics holds.
06:07:36 * hackagebot CSPM-CoreLanguage 0.1.0.0 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.1.0.0 (MarcFontaine)
06:07:44 <roconnor> certialy the premese seems more physically realistic than assuming total independence of parallel worlds
06:08:57 <Baughn> Sufficiently so that some real physicist should have a look, yes.
06:09:25 <dv-> Baughn: Are there any easy books on quantum thermodynamics?
06:09:34 <roconnor> *lol*
06:09:42 <Baughn> dv-: No.
06:10:05 <Baughn> dv-: http://lesswrong.com/lw/r5/the_quantum_physics_sequence/ <-- You may get some use from this.
06:10:12 <roconnor> dv-: is quantum thrermodynamis the same topic as quantum information theory?
06:10:15 <dv-> well, "easy", I mean that they include intuitive physical explanations instead of just math
06:10:54 <dv-> roconnor: information theory is a superset isn't it?
06:11:04 <Daerim> dv-, lots of books on qunatum thermodynamics
06:11:58 <roconnor> is it?
06:12:04 <roconnor> could be
06:12:46 <dv-> Baughn: I'll check that out
06:13:11 <roconnor> Baughn: what was distrubing about Mangled-worlds?
06:13:24 <dv-> Baughn: since you're here how do you reconcile poincare recurrence with ever-increasing entropy?
06:13:55 <gwern> roconnor: mass death
06:14:17 <roconnor> dv-: Poincare recurnce only applies to specific points in phase space, entropy applies to sets.
06:14:24 <Baughn> dv-: There are any number of options. Having the big rip in our future would certainly fix it.
06:14:27 <roconnor> dv-: or that is the best I've come up with.
06:14:53 <gwern> I've always wondered whether the decision-theoretic derivation of the born statistics from MWI was correct; I couldn't really follow it
06:15:06 <sioraiocht> in criterion
06:15:20 <sioraiocht> oops
06:15:42 <sioraiocht> in Criterion, if I use whnf, does it make sure the argument is evaluated before applying the function
06:15:57 <roconnor> dv-: sepcifically that a point will in phase space will eventually evolve to be close to it's inital point, but
06:16:40 * hackagebot NonEmptyList 0.0.7 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.7 (TonyMorris)
06:16:42 * hackagebot CSPM-Interpreter 0.1.0.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.1.0.0 (MarcFontaine)
06:16:45 <roconnor> dv-: if your information tell you your starting point is in some small neighbourhood, then that collection of points will smear-out over time and never become a tight little ball again.
06:16:46 <dv-> roconnor: It applies to sets too no? You just multiply the probabilities
06:17:09 <Baughn> dv-: To put it bluntly, I don't buy that energy is conserved across the entire universe.
06:17:52 <gwern> Baughn: where does it go then?
06:18:00 <xerox> --------------------->
06:18:21 <dv-> Baughn: that's an interesting idea
06:18:44 <Baughn> gwern: It doesn't. If it went anywhere, it would be being conserved.
06:19:09 <Daerim> No energy conservation? What do you base that on?
06:19:20 <dv-> roconnor: but the recurrence theorem says that any state (including the initial) will happen again at some time T
06:19:33 <roconnor> dv-: yes, but you never know the exact inital state
06:19:41 <dv-> roconnor: the big bang?
06:19:52 <quicksilver> it's absorbed by biros, which then vanish
06:19:54 <roconnor> dv-: you can only narrow things down to a small region of phase space.
06:20:15 <Daerim> quicksilver, no more hitchhikers guide to the galaxy for you! :p
06:20:22 <roconnor> dv-: let's keep the big bang out of the picture for the moment.
06:20:37 <roconnor> since the poicare recurence problem exists without worrying about the big bang.
06:20:41 <dv-> roconnor: ok.
06:20:42 <quicksilver> Baughn started it!
06:21:18 <dv-> roconnor: the theorem says something WILL happen, but thermodynamics says it's essentially impossible. I don't see how you can have both ways
06:21:46 <roconnor> dv-: I've pondered about the poicare recurince problem for several years before being told that it is considering sets of phase space that is relevent.
06:21:49 <gwern> dv-: how does thermodynamics say it's essentially impossible? can't we always appeal to random fluctuations?
06:22:23 <dv-> gwern: well, not in classical mechanics?
06:22:33 <gwern> no?
06:23:34 <roconnor> dv-: but the collection of points around the initial condition will never shrink down to a small diameter again.
06:24:25 <roconnor> dv-: theromdynamics is just saying that your knowledge of a state cannot increase by waiting and doing nothing.
06:24:54 <Baughn> Daerim: Processes such as the Hubble volume (sort of) shrinking, taking mass/energy permanently beyond our reach
06:25:09 <Baughn> Daerim: I must admit I'm not convinced that's actually a problem, but to my mind it seems suspicious
06:26:14 <Baughn> dv-: Poincare solution #2: The universe can recur all it likes, it doesn't have to change the relative probability of experiences any.
06:27:35 <dv-> roconnor: Odd, I remembered the theorem as saying the recurrence is exact, but if it's only arbitrarily close that may change things
06:27:42 <roconnor> gwern: according to classical thermodynamics entropy of a close system can never decrease.
06:28:06 <roconnor> dv-: it's definitely not exact.
06:28:13 <Daerim> Baughn, all cosmology is extremely suspicious, but I'm not quite sure I see why it ruins energy conservation?
06:28:19 <Baughn> ..entropy is a fact about the map, not about the territory.
06:28:42 <Baughn> Daerim: Well, if mass is /permanently/ outside our reach, how could it possible recur to a state where it isn't?
06:28:48 <Baughn> There's a minor contradiction there.
06:29:10 <roconnor> dv-: but again, your knowledge of a state is never exact, it is always a finite region of phase space.
06:30:00 <roconnor> dv-: in an insulated space, that regoin of phase space you know contains the initial condition evolved in a volume preserving manner.
06:30:01 <dv-> roconnor: In practice, not in theory
06:30:18 <Baughn> http://lesswrong.com/lw/o5/the_second_law_of_thermodynamics_and_engines_of/ <-- This seems relevant. Thermodynamics is actually really easy to misunderstand.
06:30:43 <roconnor> but that volume will smear out over time.
06:30:49 <Baughn> The actual law is "the volume of phase space is conserved", not "entropy increases"; entropy (lack of information about the universe) just increases because phase space gets more and more crinkled
06:31:10 <Daerim> Baughn, the universe collapsing? But I see what you mean
06:31:21 <dv-> Baughn: another question that's been bothering me. How do you feel about entropy under t -> -t?
06:31:29 <Baughn> Daerim: And if expansion didn't seem to be expanding, I might buy that.
06:31:33 <Baughn> *accelerating
06:31:46 <roconnor> so in some techinial sense, the entropy never increase nor decreases because the volume of phase space stays constant.
06:31:55 * edwardk waves hello to himself.
06:31:57 <Baughn> No, entropy increases just fine.
06:32:02 <roconnor> eh?
06:32:16 <Baughn> It's just that entropy is a measure of our knowledge about the universe, not a fact about the universe itself
06:32:29 <Baughn> (Well, except that a fact about our brains /is/ a fact about the universe, but let's not complicate things.. right now)
06:32:36 <roconnor> well, entropy increases when you forget things
06:32:46 <Baughn> Entropy increases when you erase information
06:32:47 <roconnor> but that is sort of independent of the evolution of the system under consideration.
06:33:15 <roconnor> information my be erased out of my head, but not out of the universe.
06:33:36 <Baughn> dv-: I think it's sleight of hand.
06:33:40 <dv-> Penrose suggested that entropy is constant if you add in Weil curvature entropy
06:33:51 <ivanm> preflex: seen dcoutts
06:33:51 <preflex>  dcoutts was last seen on #haskell 3 hours, 22 minutes and 4 seconds ago, saying: ManateeLazyCat: in what sense is it synchronous?
06:33:54 <Baughn> dv-: Causality flows from -t to +t, not the other way around
06:34:14 <dv-> Baughn: but classical mechanics is time symmetric
06:34:19 <Baughn> dv-: "Reversing the flow of time" makes no physical sense; there is no flow of time to reverse in the first place, just causality
06:34:35 <roconnor> dv-: QM is also time symmetric.
06:34:44 * hackagebot happstack-ixset 0.5.0.1 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-0.5.0.1 (JeremyShaw)
06:34:46 <roconnor> and reversable.
06:34:50 <dv-> roconnor: the collapse isn't
06:34:52 <Baughn> dv-: Which is locked into moving one way only, because there's a boundary condition at one end of the universe and apparently not at the other; at least, we're much closer to the big bang than the end
06:35:08 <roconnor> dv-: ya, but no one really thinks collapse is real
06:35:14 <roconnor> ... except for Penrose maybe.
06:35:16 <roconnor> :)
06:35:37 <dv-> heh
06:35:46 <Daerim> Baughn, seems to be is the keyword ofcourse.... but I'll have to give it some thought. I think there's a contradiction somewhere there
06:36:16 <roconnor> Penrose may be a really smart physict, but his philosophy is surprisingly unreasonable for someone who knows so much.
06:36:24 <dv-> Actually, Penrose further suggested that if all particles decayed into massless particles, there would be no more time and that event would be equivalent to conformal infinity, which he thinks might be the big bang
06:36:38 <dv-> I find his ideas intriguing :)
06:36:50 <roconnor> that they are.
06:37:10 <roconnor> I must admit I found the whole notion of atoms totally unreasonable when I was young.  Turns out I was wrong.
06:37:37 <Baughn> If he really doesn't believe in collaps, I'd be worried his theories are epicycles - solutions to nonexistent problems
06:37:52 <Baughn> *if he really believes in collapse
06:38:41 <dv-> Well, when the electron hits the detector, what happens? THe wavefunction localizes at a specific place
06:38:46 * hackagebot control-monad-failure 0.6.1.2 - A class for monads which can fail with an error.  http://hackage.haskell.org/package/control-monad-failure-0.6.1.2 (PepeIborra)
06:38:46 <dv-> That's collapse
06:38:48 <roconnor> I'm pretty sure Penrose belives in collapse.
06:38:48 <Baughn> dv-: No
06:39:08 <Baughn> dv-: The wavefunction of the detector couples with that of the electron, and some part of it reacts while other parts don't
06:39:18 <Baughn> dv-: That's decoherence. ;
06:39:24 <roconnor> what happenes when you see the detector go ping?  You become entangled with your experiment.
06:40:15 <dv-> Baughn: not sure how that would work
06:40:18 <Baughn> dv-: You really should read the Sequence I linked you to. It's good at de-confusing this.
06:40:43 <roconnor> then a superposition of physicists start having various supr
06:40:48 <roconnor> superpositions of recations
06:41:08 <roconnor> such as the superpositioning of writing various notes about the observation of the electoron
06:41:15 <roconnor> and so forth
06:42:38 <Baughn> dv-: For an entertaining and nonmathematical take on it, see http://lesswrong.com/lw/ps/where_physics_meets_experience/ and http://lesswrong.com/lw/pt/where_experience_confuses_physicists/
06:42:52 <Baughn> It's fiction, designed to make a point
06:45:34 <EvanR-work> haskell goes physics
06:45:40 <EvanR-work> quantum haskell
06:45:42 <Daerim> Indeed
06:46:11 <Daerim> Surprising really, considering that haskell isn't that well suited (speed, random) to physics ;)
06:46:19 <alpounet> quantum haskell : you can't interfere with haskell code without modifying its behavior
06:46:30 <roconnor> there is the Quantum IO monad
06:47:09 <EvanR-work> Daerim: speed, random?
06:47:26 <dv-> Baughn: I'll look at all of those
06:47:44 <dv-> Baughn: Do you know of any friendly software that can simulate quantum systems?
06:48:26 <Baughn> No. Nor any unfriendly software, for that matter.
06:48:36 <Baughn> We can just barely simulate a single hydrogen atom..
06:48:47 <EvanR-work> i have some cool flash apps for that
06:48:57 * Baughn smacks EvanR
06:49:00 <EvanR-work> http://www.falstad.com/mathphysics.html
06:49:05 <EvanR-work> (java applets)
06:50:24 <roconnor> dv-: you should watch "the prestige" :)
06:50:52 <roconnor> Baughn: have you seen this movie?
06:51:03 <dv-> I've seen it. It's good
06:51:13 <Baughn> roconnor: I keep meaning to, but no.
06:51:36 <roconnor> ah, then we should not talk about it.
06:51:56 <Baughn> Well, you could explain why I should see it. :)
06:52:16 <Baughn> I've got people telling me I should, but all I see in descriptions is something about stage magic.
06:53:10 <Daerim> EvanR, using random numbers in haskell is slightly awkward, and it's still not that fast for floating point calculations
06:53:11 <roconnor> I'm not sure what to say
06:53:26 <roconnor> It's not important for you to see it, but you might appreciate it somewhat.
06:53:45 <roconnor> even though you won't understand why until the very end of the movie.
06:53:54 <Baughn> ..I see.
06:54:02 <EvanR-work> Daerim: i used generators, randomIO, and the random monad, they arent that inconvenient for their particular uses
06:54:04 <roconnor> and it is a fun move too
06:54:05 <Baughn> I'll keep it on my to-see list, then.
06:54:28 <roconnor> I was luck to have it on an airplane
06:54:35 <roconnor> so it was convienent to watch.
06:54:42 <EvanR-work> Daerim: randomIO requires the least preparation, but you have no control of the random sequence, like php
06:54:47 <Baughn> Alongside Nadia of the blue water. Now there's an interesting show. :P
06:54:48 <Daerim> EvanR, I'm not saying it cannot be done, but it's still quite a leap from pure code to code requiring random numbers
06:54:55 <EvanR-work> im glad haskell has more fine grained stuff
06:56:28 <fax> I donno what to do to day :}|
06:56:58 <gwern> Baughn: evangelion 'twas better
06:57:41 <Daerim> roconnor, seen "Primer"?
06:57:43 <Baughn> gwern: That's not really a fair comparison. Like comparing Bokurano and Grave of the Fireflies.
06:57:53 <fax> @pl ....`.><(((>
06:57:53 <lambdabot> (line 1, column 1):
06:57:54 <lambdabot> unexpected "."
06:57:54 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:58:08 <gwern> Baughn: strangely, I thought bokurano was pretty good, but a number of reviews lambasted it for being cynical, manipulative, and predictable
06:58:19 <Baughn> fax: If that had actually worked, I would have screamed
06:58:26 <fax> ;D
06:59:17 <Baughn> gwern: Hm. As typical, the manga was much better, but I kind of have to agree.
06:59:27 <ivanm> gwern: when writing literate haskell + markdown, how do you deal with ghc/ghci complaining about using ## foo ## for headers?
06:59:31 * gwern didn't think the manga was much different
06:59:37 <Baughn> It /is/ cynical, manipulative and predictable. To some degree. This does not prevent it from being a good story.
06:59:45 <gwern> ivanm: dunno. don't think I've ever run into it
06:59:53 <ivanm> hmmm...
06:59:54 <Baughn> Scenes like the destruction of that universe..
07:00:41 <gwern> Baughn: and as an old SF fan I was a little unimpressed by the unmotivated outside power orchestrating all these sick battles. something like Battle Royale can get away with that because it's unabashedly all about the little moments and betrayals, but not something like bokurano
07:00:47 <ivanm> gwern: bah, also have to make sure I don't use > for block quotes :s
07:01:45 <Baughn> gwern: I tend to rate stories for their applicability as fanfiction fodder. The lack of explanation actually helps there, so I didn't mind. :OP
07:01:51 <gwern> ~-~
07:02:00 * gwern bets Baughn is a big fan of eliezer's fanfics
07:02:13 <Baughn> No bets. Are you reading his harry potter story?
07:02:33 <gwern> yes
07:02:50 <gwern> it occasionally makes me cringe, but at least it's not like his crossover fic
07:03:07 <Baughn> I loved that thing. :D
07:03:08 * gwern is convinced SIAI was set back a week or two by that one
07:04:20 <ketil> Binary is still supposed to be lazy - I.e. I can 'get' from the beginning of an infinite stream?
07:04:34 <ketil> (Apparently, I have yet another difficult to track down space leak)
07:05:30 <Baughn> ketil: It is, yes.
07:05:48 <fasta> Baughn, SIAI?
07:06:18 <fasta> Isn't that supposed to be the vapourware seed-ai that they want to make?
07:06:30 <Baughn> fasta: Singularity Institute for Artificial Intelligence. It's an organization, not an object.
07:06:57 <Baughn> But vaporware, yes, definitely. So far he's only been doing well in explaining why good AI is hellishly difficult.
07:07:20 <Baughn> (Which is worthwhile in itself, if it makes some people stop trying to destroy the world now please)
07:07:21 <Saizan> ketil: some of the decode wrappers force the end of the input stream, iirc, make sure you avoid those
07:07:50 <fasta> Baughn, by "good" you mean "friendly" or "f*cking smart"?
07:08:06 <Baughn> fasta: Sorry. Friendly.
07:08:21 <ketil> Saizan, which are those?
07:08:23 <Baughn> fasta: I'm relatively sure we'll crack the AGI problem. I'm less sure about the FAI problem.)
07:08:25 <gwern> Baughn: I regard donations to SIAI as essentially book royalties; I donate, eliezer and co. write
07:08:28 <fasta> Baughn, I think it is just as hard as stopping humans from doing that.
07:08:40 <fasta> Baughn, probably easier.
07:08:40 <ketil> I don't think I changed anything, but binary got upgraded from 0.4 to 0.5 or something like that.
07:08:46 <Baughn> gwern: A good way to go about it; he /does/ produce useful theories.
07:09:00 * hackagebot CSPM-Frontend 0.3.0.4 - A CSP-M parser compatible with FDR-2.83  http://hackage.haskell.org/package/CSPM-Frontend-0.3.0.4 (MarcFontaine)
07:09:07 <gwern> Baughn: I gave up thinking eliezer would be a good coder after reading his ideas for Flare...
07:09:20 <Baughn> fasta: A human being upgraded to superintelligence is one of the top ten signs of the apocalypse, so that does not really relieve me.
07:09:29 <fasta> Ah, Flare was some kind of pointless genetic programming thing, right?
07:09:41 <Baughn> fasta: It's basically Lisp. Only in XML.
07:10:02 <gwern> with heavy java and c++ influences
07:10:12 <fasta> Oh, wow, that makes it even more pointless.
07:10:13 <fax> X#?
07:10:31 <Baughn> gwern: What AGI needs is not good programmers, it's good architects. He /might/ still be one of those. Probably not.
07:11:01 * hackagebot CSPM-CoreLanguage 0.1.0.1 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.1.0.1 (MarcFontaine)
07:11:09 <fasta> Baughn, no, AGI needs 20 man-years and much more CPU power/dollar.
07:11:15 <Saizan> ketil: just decodeFile, looking at it
07:11:18 <gwern> 20 man-years? lol
07:11:35 <Baughn> gwern: Sure, if there's a single programmer. :P
07:11:39 <gwern> we can't write good text editors in 20 man-years, much less AGI
07:11:41 <Baughn> With 2, it'd be 40
07:13:01 * hackagebot CSPM-Interpreter 0.1.0.1 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.1.0.1 (MarcFontaine)
07:13:20 <ketil> Saizan: I just fmap decode on LB.readFile (possibly exactly to avoid that?)
07:13:37 <Saizan> ketil: that should be fine
07:13:39 <fasta> gwern, AGI is simple in principle. Text editors need more features all the time and are never done.
07:13:41 <ketil> My Binary instance is a bit complicated, and has caused problems before, though.
07:13:50 <fasta> gwern, the problem really is CPU power.
07:13:59 <gwern> fasta: the only simple AGI principle I've heard was an uncomputable one...
07:14:06 <Baughn> fasta: Sure. With sufficient CPU power you could run AIXI.
07:14:18 <sioraiocht> does WHNF force the spine of a list?
07:14:21 <Baughn> gwern: Actually, I think it got upgraded from "uncomputable" to "unfeasible"
07:14:32 <Baughn> sioraiocht: Only of the first cell. So no.
07:14:40 <sioraiocht> Baughn: damn, thought so, thanks
07:14:49 <gwern> Baughn: surely whatever you heard of was merely an approximation. aixi's uncomputability is pretty fundamental
07:15:17 <Baughn> gwern: Yes, but it went along the lines of "You can write an algorithm that tends to perfection as computing power tends to infinite"
07:15:22 <fasta> gwern, he probably refers to the AIXIt model.
07:15:32 <Baughn> I.e. reaching any arbitrary level of perfection with finite power
07:15:56 <gwern> fasta: possible. been a while since I read the aixi papers
07:16:02 <fasta> Anyway, I think it is just that we try to lift a building with a finger.
07:16:21 <Baughn> That level of power is finite only in principle, and it'd be immoral even if possible.
07:16:35 <fasta> You need orders of magnitude more CPU power to do things on a human time scale.
07:17:12 <fasta> People aren't even prepared to wait 20 years for it to do something useful (like we do with human scientists).
07:17:20 <gwern> fasta: we don't have an agi even running orders of magnitude slower than a human
07:17:44 <gwern> if there were a proof of concept, the cpu power problem would solve itself pretty quickly
07:18:10 <Baughn> Or the other way around. Give us twenty more years and we'll have automatically manufactured computers with more power than the human brain.
07:18:15 <Baughn> Let's see if it stays unsolved /then/.
07:18:24 <fasta> gwern, we don't have such a proof of concept because people that describe systems like Coq are not very precise.
07:18:31 <Baughn> (I kind wish it would..)
07:18:43 <gwern> fasta: ?
07:18:46 <fasta> gwern, you could base it on first-order-logic of course.
07:18:59 <fasta> gwern, I am referring to a Goedel machine.
07:19:26 <fasta> You could model a probabilistic Goedel machine in a reimplementation of Coq.
07:19:26 <gwern> there's running code for schmidhuber's godel machine thingy?
07:19:32 <fasta> gwern, no.
07:19:53 <fasta> Anyway, I have a pretty complete model of how everything should work.
07:20:22 <fasta> I only lack the time to do so and it would be much nicer if I didn't have to do everything by myself.
07:20:44 <gwern> 'I have a marvelous AGI program...'
07:20:58 <fasta> gwern, ?
07:21:11 <gwern> 'unfortunately this IRC channel is too small to contain it'
07:21:15 <Baughn> fasta: You have any idea how many people have said that before?
07:21:20 <fasta> gwern, Schmidthuber nailed it pretty much, imho.
07:21:30 <gwern> Baughn: hence my sarcasm
07:21:42 <Saizan> fasta: seen http://hackage.haskell.org/package/ivor ?
07:21:44 <fasta> Baughn, yes, and I am not saying I invented anything.
07:21:56 <fasta> Saizan, I believe that is a Haskell theorem prover.
07:22:05 <fasta> Saizan, I believe that is completely worthless.
07:22:13 <fasta> Saizan, for an AI at least.
07:22:28 <fasta> Saizan, otherwise it might be useful.
07:22:33 <Saizan> fasta: it's an implementation of something very similar to Coq, only made as a library
07:22:50 <Saizan> afaiu
07:22:53 <fasta> Saizan, then it might be useful to read how it works.
07:23:16 <fasta> Saizan, there is also a type checker for coq in the coq source tree, named coqchk, which is also quite useful.
07:23:33 <fasta> I would prefer documentation over reading source code with all kinds of TODOs, though.
07:24:49 <fasta> Anyway, I think it falls within human capability to put all the pieces together from different fields to make a mobile Goedel machine today with extreme slow performance.
07:26:11 <fasta> Performance being measured in terms of money put in versus money that it generates.
07:26:51 <fax> great bit of logic there
07:27:10 <fax> "Most people who said this didn't do it therefore you're talking shit"
07:27:28 <gwern> outside view pwns all
07:28:25 <Baughn> fax: It's valid logic, actually.
07:28:33 <gwern> fasta: should the fact that everyone who has claimed what you cliam have failed *not* significantly increase our assessment that you will fail? if not, I think Cox's theorems would like to talk to you
07:28:36 <fax> not imo
07:28:51 <fax> but I don't even accept inductive reasoning
07:29:24 <fasta> gwern, AFAIK, is the number of implemented Goedel machines zero and AFAIK I already said that a Goedel machine has an economic value of zero currently.
07:29:43 <gwern> er, I meant that for fax
07:29:44 <gwern> not fasta
07:30:01 <gwern> ...you don't accept inductive reasoning
07:30:22 <fasta> Inductive reasoning in the real-world might also not be very useful.
07:30:54 <fasta> (Since the real-world has physical limits and in a finite reasoner it would only provide some compression)
07:31:20 <fasta> Fun stuff to think about, imho.
07:32:11 <theorbtwo> You imply that providing some compression is a bad thing, or, at least, an unneccessary thing.
07:32:27 <theorbtwo> A goedel machine also has physical limits.
07:32:34 <fasta> theorbtwo, yes, I am saying that.
07:32:35 * Baughn is of the somewhat vague opinion that learning ~= compression
07:34:30 <fasta> theorbtwo, compression is not unneccessary of course, it is basically a consequence of running a Goedel machine.
07:38:11 <fax> Baughn, can that be? I mean it may compress but that's not possibly the full story
07:40:03 <Baughn> fax: The idea would be to compress the space of possible theories such that they are, essentially, ordered by plausibility
07:40:17 <Baughn> fax: I'll admit that's a rather tall order. :P
07:41:28 <fax> plausibility means smallest algorithm?
07:41:56 <Baughn> Within reason, but yes.
07:42:02 <Baughn> "Simplest explanation that fits the facts"
07:42:15 <Baughn> ..I was actually thinking about how memories have to be stored
07:42:18 * hackagebot storable-record 0.0.2 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2 (HenningThielemann)
07:42:44 <Baughn> That is, how the brain compresses them.
07:42:53 <fax> nobody knows? :P
07:43:09 <fasta> Baughn, I think the brain forgets a lot. Some people have the idea that it actually remembers everything.
07:43:16 <Baughn> True, but it would make sense for the compression used there to exploit the prediction machinery
07:43:19 <Baughn> Or, perhaps, the other way around
07:43:28 <fasta> Baughn, and most likely different people store information using different algorithms.
07:43:30 <Baughn> fasta: Of course it does. It's lossy as hell.
07:43:52 <fasta> Baughn, I agree on that. I am just saying that not all people seem to believe that.
07:44:21 <fasta> Baughn, that is, via your unconsciousness you can actually access everything. (/end pseudo science of other people)
07:44:57 <Baughn> fasta: Those people must not have gotten the memo - they're mostly their unconsciousness.
07:45:04 <Baughn> It's not like it's a separate person.
07:45:19 * hackagebot has 0.4 - Entity based records  http://hackage.haskell.org/package/has-0.4 (YusakuHashimoto)
07:45:21 * hackagebot storable-record 0.0.2.1 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2.1 (HenningThielemann)
07:45:59 <fasta> Baughn, I agree.
07:46:51 <fax> I think the idea that you remember everything is pretty ridiculous
07:46:55 <fax> it's like homeopathy
07:47:38 <fax> (maybe should say memorize rather than re-member)
07:48:05 <gwern> mm. the brain can remember an awful lot, and has efficient compression schemes
07:48:11 <gwern> and there isn't that much to remember
07:48:52 <scree> the point is that there's a graceful decay
07:49:05 <scree> we find it increasingly hard to remember increasingly obscure things
07:49:17 <scree> which makes it "plausible" that everything's down there, just very hard to get to
07:49:25 <scree> (the problem being that it's probably not true)
07:49:28 <jmcarthur> well, doesn't the brain "remember" everything, just sometimes weakly enough that basic recall doesn't work but it still has affected the structure of things?
07:49:44 <fasta> I remembered something 3 weeks later once.
07:49:58 <matt_m> Is self modification really that powerful in practice?  Compared to, say, starting coq with 2^64 levels (version N = 2^64) and letting each version N prove the correctness of version N-1 implemented on the machine?
07:50:23 <jmcarthur> i'm speaking only from guesses, not education
07:51:02 <scree> jmcarthur: sure, the brain is a state machine of sorts, and very few things don't affect the state at all
07:51:19 <matt_m> In practice, I don't think self implementation actually buys you much over that type of scheme where you're actually implementing machines slightly dumber than yourself but more effecient, and it would take you longer than human lifetimes to run out of levels
07:51:25 <fax> matt_m: I always thought being able to interpret code subsumes self modification
07:51:26 <scree> jmcarthur: the main fallacy is that the information that does stick around, bears any resemblance to the raw input
07:52:11 <fax> (in terms of computability, not efficiency)
07:52:34 <scree> as in, if I hypnotized you, you could tell me what colour shirt I was wearing this time last year
07:52:55 <gwern> jmcarthur: you could run out of 2^64 pretty quickly. what if your code is data, and you're training yourself/reading the Internet?
07:52:59 <jmcarthur> scree: i'd say that probably *nothing* that we "remember" remotely resembles raw input
07:53:03 * fax wonders if hypnotism is real...
07:53:05 <Baughn> matt_m: If your AI is smart enough to build a smarter AI, then that effectively is self-modification. If it isn't, then what good is it?
07:53:21 <matt_m> fax:  I agree in some sense
07:53:21 * hackagebot storable-record 0.0.2.2 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2.2 (HenningThielemann)
07:53:27 <Baughn> matt_m: Well, it's good for not wiping out humanity, for one. :)
07:53:36 <jmcarthur> gwern: if you add 1 and 1 to get 2, have you forgotten the ones?
07:53:41 <scree> jmcarthur: sure
07:54:15 <Baughn> "case undefined of _ | foo -> ..; | bar -> ..." <-- Is this, um, reasonable?
07:54:27 <jmcarthur> gwern: there are of course physical constraints, which is exactly why we operate in such a lossy fashion
07:54:44 <fax> Baughn, I tend to do case () of () | ...
07:54:50 * jmcarthur continues to talk out of his ass
07:54:54 <matt_m> Baughn: Depends what you mean by smarter.  A machine can prove another machien more efficient than itself, but if the original machine can prove the new machine's consistency, then it's also in some sense dumber
07:54:55 <zygoloid> fax: yep, hypnotism is pretty much real, but stage hypnotists considerably distort what it is
07:55:01 <gwern> jmcarthur: but each change uses up a version number, and each version depends on the previous
07:55:13 <gwern> matt_m: I think Hutter showed that, actually
07:55:15 <fax> okay
07:55:24 <matt_m> gwern:  Showed which?
07:55:36 <gwern> that there's a limited amount of improvement capability 'built in' and any improvement past that is not provably safe
07:55:49 <gwern> 10 pounds of shit, 5 pound bag etc
07:55:49 <jmcarthur> gwern: i'm not requiring the ability to recall to say that something is "remembered"
07:56:18 <matt_m> gwern:  It's just fleshing out Godel, I think
07:56:21 <siracusa> What does readFile expect as input encoding, utf8?
07:56:53 <Baughn> fax: We really need a "case of" construct. Or something.
07:57:13 <fax> Baughn, ( p1 -> r1 | p2 -> r2 | ... ) aka COND :P
07:57:27 <jmcarthur> i'm going to stop now though. i get annoyed when the ignorant argue and don't want to be a hypocrite
07:57:37 <Baughn> fax: If only that were valid syntax.
07:57:39 <fax> you can define (-->) = (,) and implement a cond :: [a -> b] -> b construct
07:57:47 <fax> oops
07:57:52 <fax> [(a,b)] -> b
07:57:56 <Baughn> Heh. Yes, I /could/.
07:59:01 <whald> ouch. my ghc-compiled binary just produced a segfault -- could this be my fault?
07:59:33 <Baughn> whald: What were you doing?
07:59:39 <Saizan> siracusa: since ghc-6.12 it decodes using your locale, otherwise it gives you the raw bytes masked as Chars
07:59:51 <whald> Baughn: let it run :-)
08:00:05 <Baughn> whald: ..what does the /program/ do?
08:00:15 <Baughn> whald: Did you use FFI, unsafe array access or anything else marked unsafe?
08:00:38 <whald> it tries to render an image using MC integration
08:00:53 <Baughn> MC?
08:00:58 <whald> $ grep unsafe *.hs
08:00:59 <whald> Transport.hs:         bxdf = V.unsafeIndex bs sNum
08:01:08 <whald> MC = monte carlo
08:01:25 <Baughn> Ah. Replace the unsafeIndex with index, see what happens.
08:01:55 <whald> i do not use FFI, and thats' the only *unsafe* thing in the whole program. but i'm pretty confident i stay within the bounds because:
08:01:59 <fax> unsafeIndex ??
08:02:18 <jmcarthur> fax: looks like something from vector
08:02:20 <whald> bxdf = V.unsafeIndex bs sNum; sNum = min bxdfCount (floor (uComp * fromIntegral bxdfCount)) -- index of Bxdf to sample; bxdfCount = V.length bs
08:02:27 <fax> what goes through these peoples minds
08:02:39 <whald> yes, it's from Vector
08:02:45 <jmcarthur> unsafeIndex is perfectly safe if you carry the burden of proof
08:03:11 <jmcarthur> but you have to remember prove it correct :)
08:03:20 <Baughn> whald: Well, /try/ it.
08:03:32 <Baughn> whald: What have you got to lose?
08:04:04 <whald> Baughn: yes, yes, i've put an assertion in and i'll see if it pops up again
08:04:19 <jmcarthur> yeah, the unsafe just means it might segfault or corrupt your heap instead of just crashing with an error message
08:04:36 <jmcarthur> wait, an assertion instead of getting rid of the unsafe function?
08:04:40 <fax> ;_;
08:04:41 <jmcarthur> that seems... unnecessary
08:05:07 <Baughn> Using safe index for a function that, say, iterates through an array from end to end is really slow
08:05:19 <jmcarthur> and an assertion is faster?
08:05:19 <Baughn> ..though I'd prefer some kind of map
08:05:30 <jmcarthur> Baughn: vector has a map function
08:05:46 <Baughn> Yeah, I wondered about that as well. He could just as easily swap index for unsafeIndex as remove the assertion.
08:06:38 <whald> what i have is a Float uniform in [0,1) and what i want is an element unifrom from a vector, that's all
08:06:59 <siracusa> Saizan: Can I get the old behaviour in GHC 6.12? Using the locale sounds not very portable to me. (And I'm having difficulties to find out what my locale encoding actually is in WinXP).
08:07:39 <jmcarthur> whald: what's the type of this function?
08:08:10 <whald> jmcarthur: which function do you mean?
08:08:27 <sammich> hello
08:08:52 <jmcarthur> whald: wait are you indexing into the array with random indices?
08:08:59 <Saizan> siracusa: hSetEncoding handle latin1 should do it
08:09:11 <sammich> i have a GHC.Arr.Array  Int Double outputed from something in DSP.Filter.FIR.Window
08:09:25 <whald> jmcarthur: yes, could i do better?
08:09:31 <jmcarthur> i'm just trying to get a sense of what you are doing so i can recommend something either safer or more correct without being slower
08:09:40 <Saizan> siracusa: or you could set binary mode, that will affect how \n is translated too, which is maybe what you want
08:09:50 <sammich> how can it wont let me unzip
08:10:14 <sammich> sorry bad english, why wont it let me unzip?
08:10:25 <whald> before i was using lists, but their length function is O(n) and for vector it's O(1) so i think that's ok
08:11:16 <jmcarthur> whald: i assume this is in a loop. are you creating a new vector from these values or what?
08:11:33 <whald> jmcarthur: here is the full function, but i think it's a bit hard to get without context http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25320#a25320
08:12:18 <roconnor> @type &&&
08:12:19 <lambdabot> parse error on input `&&&'
08:12:23 <roconnor> @type (&&&)
08:12:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:13:18 <shapr[> gwahr
08:13:21 <EvanR-work> @src Arrow
08:13:21 <lambdabot> class Arrow a where
08:13:21 <lambdabot>     arr, pure   :: (b -> c) -> a b c
08:13:21 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
08:13:21 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
08:13:21 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
08:13:23 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
08:13:23 <jmcarthur> whald: it should be fast enough. i'm just trying to work out whether there might be a simpler way to write it
08:13:25 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
08:13:42 <jmcarthur> whald: but it looks like the kind of thing i have in mind would actually require a bit of a redesign
08:14:20 <jmcarthur> plus i still don't know exactly your algorithm anyway, so i should probably just drop it
08:14:33 <whald> jmcarthur: i'm listening -- i just redisigned it a lot and got a ~20% speedup by replacing instane amounts of typeclasses by functions & currying
08:14:44 <whald> so i'm eager to see what's next :-)
08:16:03 <jmcarthur> whald: well, if you need a lot of samples at once you could generate a vector of indices using http://hackage.haskell.org/packages/archive/vector-random/0.2/doc/html/Data-Vector-Random-Mersenne.html#v%3Arandoms and then use http://hackage.haskell.org/packages/archive/vector/0.6.0.1/doc/html/Data-Vector.html#v%3Abackpermute to get a vector of samples from the array you are indexing, but i don't think
08:16:04 <jmcarthur> that would fit directly into your current design
08:17:19 <jmcarthur> of course you would process the array of indices first to make sure all the indices are in range
08:18:44 <jmcarthur> whald: also, vector likes it if you put INLINE pragmas on all your functions that manipulate vectors
08:18:55 <jmcarthur> helps with fusion
08:20:17 <whald> jmcarthur: sadly, i need lots of samples, but in very different places. this functions is #2 in my cost-center rundown when profiling
08:20:22 <jmcarthur> i was never told so, but i speculate that's only for functions that *return* vectors, not functions that merely use them
08:20:40 <jmcarthur> whald: right, i suspected your design would not support this
08:21:12 <jmcarthur> whald: i bet it's likely that there could be a massive redesign that would make it possible, but i can't tell you if it would be worth it if it's even possible
08:22:24 <whald> oh, there's a segfault again
08:22:39 <whald> so now i know it's not the vector indexing causing the problem
08:23:00 <whald> i have another suspect: maybe a bug in the DiffArray implementation?
08:23:11 <jmcarthur> you're using diffarray?
08:23:26 <jmcarthur> i recommend against that. diffarray is unexplainably slow
08:23:29 <fasta> whald, I doubt that.
08:23:43 <whald> yes, this causes my #1 performance problem and is #1 on my todo list
08:24:00 <fasta> whald, I indexed a few hundred billion times in a DiffArray without issues.
08:24:05 <jmcarthur> is this a ray tracer or what?
08:24:12 <whald> yes, it is
08:24:19 <jmcarthur> ah cool
08:24:27 <fasta> whald, a toy ray tracer?
08:24:44 <jmcarthur> i considered writing a path tracer a few times, but never did it
08:25:00 <whald> fasta: well, i've done a few raytracers already, so i think it's not *that* toy
08:25:28 <fasta> whald, ok, I meant: for commercial purposes?
08:25:35 <whald> i'm currently about to get the integration stuff straight, i think acceleration structures will be easy then
08:25:42 <fasta> (as that would be a new thing)
08:25:45 <whald> no, no commercial purpose
08:26:36 <whald> i'll likely open source it when i'm confident that no one will laugh at my haskell - foo then
08:26:54 <whald> it's my first serious haskell thing
08:27:43 <whald> jmcarthur: path tracing + multiple importance sampling is already working. anyone volunteers for bidir path tracing? :-)
08:27:47 <jmcarthur> this is awesome http://www.youtube.com/watch?v=i8F_48nyW90
08:28:03 <jmcarthur> whald: oh this is a path tracer? awesome!
08:28:17 <dv-> How come people are so selfconscious about their code?
08:28:21 <jmcarthur> i can't volunteer. i don't know the bidir algorithm
08:28:34 <rl> whald: I suspect this is your problem
08:28:35 <rl>          sNum = min bxdfCount (floor (uComp * fromIntegral bxdfCount)) -- index of Bxdf to sample
08:28:36 <rl>          bxdfCount = V.length bs
08:28:52 <rl> valid indices range from 0 to bxdfCount - 1
08:28:58 <rl> but sNum can be bxdfCount
08:29:31 <jmcarthur> if that's the problem then you would have seen a relevant error message had you not used the unsafe indexing
08:31:05 <Saizan> isn't uComp < 1 ?
08:31:23 <whald> jmcarthur: *ouch* ... you're right, that's plain wrong. here is the current rendering, after ~5 minutes : http://img641.imageshack.us/i/pass00004.jpg/
08:32:37 <jmcarthur> i love the telltale signs of monte carlo rendering
08:32:45 <whald> Saizan: it's supposed to be, but once in a while a 1.0 slips in (and causes a NaN somewhere or causes failure in array indexing)
08:33:02 <jmcarthur> the noise looks so much more realistic than the noiseless scanlines
08:33:32 <BMeph_> whald: I say, if it works, let them laugh. Then write version 2.0, incompatible with 1.0 ;)
08:34:10 <whald> yeah, i love that stuff too. the material system is in a pretty good shape by now, so i'll go for space partitioning and triangle meshes soon
08:34:43 <whald> well, first i'll have to get rid of that diffarray, but ST frightens me still :-D
08:37:56 <whald> Bmeph_: yes, i'm not really afraid of being laughed at, i just think the internets does not really need the 10000th sketchy raytracer
08:38:43 <whald> so, when it's something reasonable (maybe for people to try new intergration/sampling strategies) i'll put it in hackage or something
08:38:55 <whald> but it's of no apparent use for anyone currently
08:41:48 <Jafet> Is it unbiased?
08:42:08 <whald> yes it is
08:42:20 <whald> (supposed to be)
08:42:22 <whald> :-)
08:42:26 <Jafet> Hurr durr
08:43:38 <Jafet> luxrender has the newer algorithms
08:43:48 <Jafet> They're also toying with GPU
08:44:09 <whald> the GPU stuff is up to ghc to deal with imho :-D
08:44:40 <Jafet> You would use the cuda or opencl bindings from hackage
08:44:52 <Jafet> Where "you" of course means "nobody"
08:45:35 <whald> but yes, luxrender is pretty cool. but i think it misses energy redistributing path tracing. that's the hot shit after everyone is metropolis sampling, i think :-)
08:45:58 <whald> s/is/is doing
08:46:15 <Jafet> It would be nice if ghc comes with cluster computing soon. Then you just slap up some concurrency and you have a distributed renderer
08:47:09 <Baughn> If I have a sufficiently large case, will GHC turn it into a computer goto?
08:47:51 <shapr> Is there a cabal command like apt-cache show? cabal show monads-fd doesn't work.
08:48:11 <xerox> ghc-pkg describe monads-fd
08:48:12 <Jafet> "info" or "describe"
08:48:21 <dcoutts_> shapr: cabal --help shows you the way! :-)
08:48:37 <shapr> dcoutts_: Ah, should have tried that first.
08:48:46 <Jafet> Cabals cannot help you, as they don't exist.
08:48:51 <shapr> Aha!
08:49:38 <quicksilver> Baughn: GHC codegen has a number of different strategies for cases depending on size.
08:49:44 <quicksilver> Baughn: I believe it uses jump tables for large ones.
08:49:55 <Baughn> Good. :)
08:50:14 * Baughn has a generated 3000-case one
09:18:49 <pasc> i have a small question about DSLs: is every haskell data type a domain specific embedded language?
09:19:28 <fax> yes
09:19:32 <Baughn> ..no?
09:20:36 <Jafet> Maybe!
09:21:02 <Baughn> If the concept of DSEL covers /Bool/, then it isn't worth much
09:21:04 <pasc> what is about a data type to model class diagrams? i think it is an dsel
09:21:05 <benmachine> Maybe Bool.
09:21:06 <Baughn> We need something narrower
09:21:21 <Baughn> pasc: How about "It's a DSEL if you use it as such"?
09:21:31 <Jafet> Baughn, <<loop>>
09:21:41 <Baughn> I mean, you need combinators too..
09:22:00 <BMeph_> CONST LOOP
09:22:16 <Baughn> > let x = x in fix (const x)
09:22:18 <BMeph_> Or rather, const LOOP :)
09:22:19 <lambdabot>   mueval-core: Time limit exceeded
09:22:27 <quicksilver> well it's a bit like asking is "a*" a language?
09:22:32 <quicksilver> yes, it is, but it's a very boring one.
09:22:45 <quicksilver> DSELs consisting only of constructors are not interesting.
09:22:52 <Jafet> > let a = const a in a
09:22:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
09:22:53 <quicksilver> the interesting ones have some combinators and stuff, as Baughn remarks
09:23:17 <pasc> quicksilver,Baughn: okay, thats a good point
09:23:24 <Baughn> If it instances Monad or Arrow, it's a DSEL. If it doesn't.. well, YMMV.
09:23:49 <Jafet> a->b is a DSL?
09:23:53 <quicksilver> [] instances Monad but I don't think it's an interesting DSL..
09:24:01 <pasc> my data type is not even polymorphic...
09:24:12 <Baughn> quicksilver: It's marginal, but I'd like to think it /is/ one
09:24:21 <Baughn> As the existence list comprehensions would argue
09:24:34 <benmachine> 1. is it a language 2. is it embedded 3. is it domain-specific
09:24:36 <benmachine> sorted :P
09:24:43 <sammich> does anyone know if a phase vocoder has been made in haskell?
09:25:01 <Jafet> You could be the glorious first
09:25:07 <Baughn> What is a phase vocoder?
09:25:16 <sammich> for pitch shift
09:25:41 <Baughn> You mean "Run FFT, map (+40) frequencies, reverse FFT"?
09:26:18 <sammich> ?
09:26:33 <Baughn> Wouldn't that shift pitch?
09:26:43 <sammich> what is +40?
09:27:07 <sammich> but yes that is the idea
09:27:14 <Baughn> Sorry, I should have made it clearer.
09:27:16 <Baughn> +42.
09:27:18 <gwern> 40 hertz, I'd assume
09:27:29 <Baughn> It's a metasyntactic variable
09:27:35 <pasc> let me summarize: its just a matter of taste if i call it a "dsel" or just "embedded language"? since i dont have any combinators, you would prefer calling it "embedded lanuage"?
09:27:51 <BMeph_> icepick hertz... >;)
09:28:05 <Baughn> pasc: If it's specific to a domain, and it's an embedded language, it's a DSEL
09:28:43 <sammich> but i am trying to run on a waveform
09:28:46 <Baughn> pasc: C is not a DSEL. Probably. Haskell is not. Lua debatably might be in some cases. The list monad is.
09:29:13 <sammich> i have huge list of frames
09:29:19 <ddarius> sammich: Then do the math to see what that operation corresponds to (more directly) in the time domain.
09:29:52 <sammich> can you explain
09:29:54 <pasc> Baughn: okay, i think that i got the point. thanks!
09:30:02 <sammich> sorry
09:30:22 <zygoloid> Baughn: i'd say the list monad is a general-purpose embedded language, not a domain-specific one, i think...
09:30:30 <zygoloid> (is prolog domain-specific?)
09:30:47 <BMeph_> Is prolog NOT domain-specific?!?
09:31:15 <Baughn> Is prolog?
09:31:40 <sammich> ?
09:31:45 <Baughn>  
09:31:56 <benmachine>  
09:31:59 <zygoloid> ?- domain_specific(prolog)
09:32:00 <lambdabot> Maybe you meant: . ? @ v
09:34:37 <whald> may i beg some advice how to refactor my image module for moving from a DiffUArray to a STUArray? mainly i'm not sure what the types should look like
09:34:48 <whald> the current code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25321#a25321
09:34:49 <sammich> ddarius, can you explain?
09:34:59 * Baughn suspects DiffArray should be removed from the library
09:35:35 <whald> Baughn: i think the diffarray sans the "diff" would be nice
09:35:45 <Baughn> whald: We've already got that, though
09:35:46 <zygoloid> as things are, DiffArray only exists to serve as a warning to those who follow: here be dragons
09:35:58 <zygoloid> This Idea Failed
09:36:00 <whald> so it throws an error when you try to acces an "old" version, but still does in-place updates
09:36:03 <Baughn> ..and slow down people who think it's useful
09:36:17 <Baughn> whald: I'd rather have STArray for that.
09:36:23 <Baughn> Sounds like a usability nightmare.
09:36:52 <Baughn> ..I'm not even sure it'd be noticably faster.
09:37:15 <whald> in the code i posted, what should Image look like using stuarray? data STImage s = STImage Int Int (STUArray s Int Float) ?
09:37:32 <zygoloid> whald: line 71: seq img' img' = img'
09:38:55 <whald> zygoloid: that's bad? i had a hard time to make it "strict enought" and threw in "seq"s at random places until it... did not explode :-)
09:41:11 <whald> oh, i see, it's just completely pointless
09:41:50 <quicksilver> seq a a =~= a, yes
09:42:50 <benmachine> when evaluating a, make sure you've evaluated a
09:43:17 <benmachine> or rather, make sure a is evaluated no later than a is?
09:44:02 <zygoloid> benmachine: just make sure a is evaluated. no guarantees on whether it's before or after :)
09:44:23 <benmachine> oic
09:44:46 <zygoloid> (yes, this means that foldl' isn't guaranteed to "work")
09:45:31 <benmachine> (but it tends to)
09:45:39 <kmc> right, you can't force values in an absolute sense
09:46:21 <kmc> you can introduce artificial dependencies of the form "if you force x, force y first"
09:46:29 <kmc> and yeah i think it is an ordering, at least with respect to hitting bottom first
09:46:41 <kmc> > seq undefined ()
09:46:42 <lambdabot>   *Exception: Prelude.undefined
09:46:50 <zygoloid> one could imagine a theoretical compiler inlining foldl' into itself a few times (unrolling the loop) then reversing the order in which the values are forced
09:46:53 <kmc> > seq (seq () undefined) ()
09:46:54 <lambdabot>   *Exception: Prelude.undefined
09:46:58 <kmc> err durr
09:47:12 <kmc> how does that make foldl' not "work"?
09:47:21 <kmc> order of evaluation is not part of the contract
09:47:21 <Baughn> kmc: Hm. Wasn't the difference between seq and pseq something like "a `seq` b is not required to be lazy in b, pseq is"?
09:47:35 <kmc> could be
09:47:38 <benmachine> I thought it was that pseq was definitely-before
09:47:39 <zygoloid> a `pseq` b is required to evaluate a /first/
09:47:50 <benmachine> so that you know a is evaluated while evaluating b
09:47:54 <Baughn> seq makes sure a is evaluated, pseq makes sure it's evaluated /first/
09:47:57 <benmachine> which helps you not waste sparks
09:48:00 <Baughn> Right
09:48:08 <zygoloid> pseq has operational semantics, seq has only denotational semantics
09:48:25 <Baughn> I thought haskell didn't have operational semantics?
09:48:35 <benmachine> pseq is magic >_>
09:48:35 <quicksilver> pseq isn't haskell.
09:48:35 <kmc> ;)
09:48:41 <quicksilver> (check-mate!)
09:48:55 <kmc> it is fairly difficult to talk about parallelism without operational semantics
09:48:57 <zygoloid> an implementation is within its rights to build up a list of all things on the LHS of seq, and force them in any order once it gets back up to the IO monad
09:49:01 <zygoloid> (more-or-less)
09:49:08 <Baughn> http://monoidal.blogspot.com/2010/05/denotational-semantics.html <-- Suddenly, a relevant blog post
09:49:34 <quicksilver> "Suddenly, as if by magic, the blogposter appeared"
09:50:05 * quicksilver suspects Mr Ben references are a little obscure even for #haskell.
09:50:12 <kmc> It's super effective!
09:51:08 <quicksilver> zygoloid: in fact, if the implementation can prove they are not _|_ statically, it is at liberty *never* to force them.
09:51:51 <quicksilver> f x `seq` x -- if the compiler has statically proven f to be total, there is no need to build the f x thunk or force it.
09:51:57 <quicksilver> that might be considered perverse though.
09:52:41 <pikhq> quicksilver: Yes, if the implementation has a halting oracle it can do that.
09:52:55 <zygoloid> pikhq: umm, it only needs to be able to prove it for that f
09:53:09 <quicksilver> pikhq: no, it does not need a halting oracle.
09:53:23 <quicksilver> f True = False; f False = True; -- it's pretty easy to prove this one is total.
09:53:38 <quicksilver> more complex provably total functions are left as an exercise to the reader.
09:54:00 <Baughn> Right, but if it /does/ have a halting oracle, it can do that. ;)
09:54:12 <benmachine> a halting oracle is sufficient but not necessary
09:54:26 <benmachine> presumably you can construct examples where a halting oracle is necessary
09:54:32 <benmachine> where f = runTuringMachine presumably
09:55:15 <quicksilver> the answer to every single problem in computability theory is to use 'f = runTuringMachine'
09:55:35 <fax> lol
09:56:22 <zygoloid> build n | n > 0 = let b = build (n-1) in b `seq` n:b | otherwise = [] <-- not actually guaranteed to force any of the list!
09:56:56 <quicksilver> makes it quite a boring subject in some ways :(
10:02:39 <matt_m> Is there way to make type functions involving higher kinded things (*->*, etc)?
10:05:35 <fax> matt_m, yeah um I think it will infer * unless you annotate (-XKindSignatures) differently
10:05:47 <fax> well it infers correctly if it's been used but if you don't use it, it sticks with *
10:06:46 <matt_m> fax:  Yes, that's what I needed
10:06:48 <matt_m> thanks
10:07:12 <matt_m> fax: Right, but with type family declarations, you're not using it, so you need the explicit annotation
10:07:21 <fax> yeah
10:07:43 <fax> have wonder why it can't be polymorphic but haven't thought much about it
10:09:10 <benmachine> matt_m: you can do something like type family Thing x y
10:09:10 <monoidal> is every haskell type a complete partial order?
10:09:16 <benmachine> then Thing :: * -> * -> *
10:09:28 <benmachine> oh higher-kinded though
10:09:36 <monoidal> i thought so, but data N where Succ :: N a -> N (Succ a) seems to falsify that
10:10:00 <monoidal> since Succ (Succ undefined) is constructible, but fix Succ isn't
10:10:57 <opqdonut> monoidal: "data N" and "N a" ??
10:11:01 <fax> what does constructible mean?
10:11:10 <monoidal> valid in type system
10:11:16 <fax> hm
10:11:22 <monoidal> data Succ a; data N where Succ :: N a -> N (Succ a)
10:11:31 <fax> ah
10:11:42 <fax> how do you construct  Succ (Succ undefined)  ?
10:11:46 <opqdonut> still doesn
10:11:55 <opqdonut> 't work
10:12:00 <opqdonut> N doesn't take parameters
10:12:08 <opqdonut> did you mean data N a?
10:12:13 <monoidal> yes. N :: * -> *
10:12:26 <sammich> is there any simple way to convert from [Double] to Array a (Data.Complex.Complex b) ?
10:12:29 <Botje> "You seem to be creating Peano numbers in the type system. Did you mean .."
10:12:33 <sammich> I cannot figure this out...
10:12:34 <fax> what is the meaning of undefined?
10:12:39 <monoidal> bottom
10:12:42 <fax> wait
10:12:49 <fax> what ??
10:12:57 <monoidal> bottom = bottom
10:13:08 <Botje> sammich: listArray can create an array from a list.
10:13:14 <fax> oh geez you are talking about VALUES
10:13:19 <fax> I thought you were talking about types for some reason
10:13:21 <Botje> but you still need a function Double -> Complex b
10:13:24 <monoidal> oh, sorry. yes
10:13:29 <fax> when you say constructible -- that means TYPABLE
10:13:32 <benmachine> :t (:+ 0)
10:13:34 <lambdabot> forall a. (RealFloat a) => a -> Complex a
10:13:35 <fax> right I am following nw
10:13:36 <fax> now
10:13:40 <monoidal> yes. sorry
10:13:50 <fax> my fault
10:14:18 <fax> oh right so the question is do GADTs screw up the poset
10:14:38 <fax> GADTs are equivalent to normal data types + data Eq a b where REFL :: Eq a a
10:14:39 <sammich> Botje, what if i want to go back?
10:14:42 <monoidal> it seems it is possible to form a noncomplete partial order then
10:14:59 <fax> so I think if GADTs cause a problem, that Eq type will case the same problem
10:15:03 <Botje> sammich: there's elems, which returns the elements of an array in order
10:15:08 <opqdonut> why do you need gadts for that? kinda seems to me like "foo :: a -> [a]"
10:15:15 <opqdonut> would cause the same trouble
10:15:23 <sammich> !
10:15:32 <sammich> thx
10:15:36 <opqdonut> the problem is that fix doesn't fixpoint the type
10:15:55 <monoidal> in N a, you can form a sequence without limit
10:16:06 <opqdonut> hmm, fixF :: (a -> f a) -> Mu f
10:16:50 <opqdonut> but for bifunctors so we can have some structure inside
10:16:58 <fax> shouldn't that f a -> a ?
10:17:15 <monoidal> fold :: (f a -> a) -> (Mu f -> a)
10:18:01 <opqdonut> no, that way around definitely
10:18:35 <monoidal> you can write Succ (Succ ...) as fix (Mu . Succ)
10:18:46 <opqdonut> ah, so: fixF :: (a -> f a) -> a -> Mu f
10:18:47 <sammich> Botje, what if I don't have n in listArray (0, n)
10:18:53 <monoidal> but, this is not the limit of undefined, Succ undefined, Succ (Succ undefined) ...
10:18:54 <sammich> and i dont want to haveto compule length
10:19:01 <sammich> too expensive
10:19:11 <sammich> compute*
10:19:21 <opqdonut> such that "f i = Just (i-1); f 0 = Nothing", "fixF f 3 = Just $ Just $ Just Nothing"
10:19:29 <Botje> sammich: haskell needs to know how big of an array to allocate.
10:19:35 <zygoloid> monoidal: which type are you claiming is not a complete partial order?
10:19:37 <Botje> sammich: if you don't know, you can use a Map.
10:19:37 <opqdonut> but I guess I'm digressing
10:19:47 <Botje> or even an IntMap, if you can get away with it
10:19:49 <opqdonut> that's just a general unfold (I guess?)
10:19:59 <sammich> in place of listArray?
10:20:00 <monoidal> zygoloid: declare data Succ a; then data Nat :: * -> * where Succ :: Nat a -> Nat (Succ a)
10:20:12 <zygoloid> monoidal: right. but which type are you claiming isn't a complete partial order?
10:20:14 <monoidal> zygloid: i claim exists a. Nat a
10:20:17 <monoidal> is not cpo
10:20:35 <zygoloid> is that a type to which the claim even applies?
10:21:07 <zygoloid> the monomorphic types involved all admit a cpo#
10:21:14 <monoidal> yes
10:21:17 <fax> data Exists p where WITNESS :: p a -> Exists p
10:21:25 <monoidal> but doesn't this apply to polymorphism too?
10:21:38 <monoidal> doing fix Succ causes occurs check
10:22:07 <fax> monoidal: why isn't it a CPO?
10:22:15 <fax> oh because there is no limit
10:22:18 <monoidal> yes
10:22:31 <fax> but moniod, it is even a sequence?
10:22:33 <zygoloid> monoidal: data T a = C a. now, consider fix C...
10:22:35 <fax> I mean like
10:22:52 <fax> they types are different so how can that be called a sequence
10:23:24 <zygoloid> monoidal: so exists a. T a isn't a cpo either, since there's no lub for undefined, C undefined, C (C undefined), ...
10:23:46 <opqdonut> as I suggested, "foo :: a -> [a]" works just as well as his example
10:23:55 <monoidal> it seems yes
10:24:00 <opqdonut> zygoloid's is just a bit more minimal
10:24:03 <Botje> sammich: fromList :: [(a,b)] -> Map a b
10:24:05 <monoidal> qpdonut: what do you mean?
10:24:14 <zygoloid> monoidal: so basically this property only seems to apply to monomorphic types
10:24:19 <Botje> sammich: so you want fromList $ zip [1..] list_of_doubles
10:24:47 <fax> I am not really sure how can you say this breaks the CPO property
10:24:50 <opqdonut> monoidal: I meant what zygoloid also said
10:24:58 <Makoryu> :t swap
10:24:59 <lambdabot> Not in scope: `swap'
10:25:11 <monoidal> qpdonut: i don't understand your a -> [a] example
10:25:28 <fax> I mean you don't save that for example  (3,"foo","foobar",(),True,
10:25:30 <fax> is a sequence
10:25:31 <monoidal> *opqdonut
10:25:32 <fax> because they have different types
10:25:48 <fax> so why should these other things be comparable?
10:25:54 <zygoloid> monoidal: _|_, [_|_], [[_|_]], ... has no lub
10:26:05 <monoidal> ah. ok
10:26:07 <opqdonut> monoidal: "[] isn't a cpo because fix foo doesn't type"
10:26:07 <Makoryu> > (1, undefined) < (2, undefined)
10:26:08 <lambdabot>   True
10:26:13 <monoidal> so, i was messing types
10:26:19 <monoidal> thanks for help
10:26:37 <opqdonut> I'm intrigued
10:26:45 <opqdonut> existential quantification breaks the cpo property
10:27:07 <monoidal> fax: it is a sequence, but not an increasing one
10:27:08 <zygoloid> hmm, do haskell compilers which support 'exists' allow, for instance, fix :: (exists a. a -> [a]) -> (exists a. [a]) ?
10:27:11 <monoidal> the elements are not comparable
10:27:31 <zygoloid> opqdonut: existential quantification, cpo, occurs check. pick at most two :)
10:27:46 <monoidal> bottom, [bottom], [[bottom]] is an increasing sequence
10:27:50 <matt_m> Is there any way to turn on a "choose most specific" rule for type functions as you can for instance selection?
10:27:57 <opqdonut> zygoloid: so it would seem, I just wasn't aware of this
10:28:02 <monoidal> but extended to infinity, there is no common type
10:28:11 <fax> data N = Z | S N
10:28:35 <fax> data Nat n where Zee :: Nat Z ; Suc :: Nat n -> Nat (S n)
10:28:44 <fax> we can define a map from N -> Exists Nat
10:29:04 <opqdonut> youre mixing types and values
10:29:09 <fax> yes intentionally
10:29:15 <opqdonut> did you mean "data Z; data S a; ..."
10:29:16 <opqdonut> oh okay
10:29:19 <fax> I couldn't be bothered defining those
10:29:24 <opqdonut> :)
10:29:26 <opqdonut> go on
10:29:35 <fax> m (fix S) is mapped to WITNESS (fix id)
10:29:36 <fax> basically
10:29:40 <monoidal> interesting
10:29:47 <fax> or actually it's mapped to  fix id
10:29:56 <fax> because we don't /know/ that we're going to get a witness at all
10:30:09 <fax> opqdonut - i should not be so lazy but you know how it is :p
10:30:31 <fax> now we know that m is continuous
10:31:06 <endojelly> what's a witness?
10:31:18 <zygoloid> i'm guessing data Exists f = forall a. WITNESS (f a)
10:31:19 * hackagebot has 0.4.0.1 - Entity based records  http://hackage.haskell.org/package/has-0.4.0.1 (YusakuHashimoto)
10:31:28 <opqdonut> "data Exists f = WITNESS (f a)"
10:31:40 <opqdonut> ah, yes, with that forall
10:31:56 <fax> I defined it earlier
10:32:07 <fax> data Exists p where WITNESS :: p a -> Exists p
10:34:32 <monoidal> how to define f? f Z = Exists Zee; f (S x) = Exists (Suc k) where Exists k = Suc (f x) makes GHC's brain explode
10:36:57 <fax> f = foldN zero succ where zero = Exists Zee ; succ (Exists k) = Exists (Suc k)
10:39:57 <Saizan> monoidal: use case of
10:40:03 <monoidal> f (fix S) is bottom
10:40:08 <fax> yeah
10:40:28 <fax> since f is continuous, what does this tell us?
10:43:08 <edwardk> monoidal: great post
10:43:15 <monoidal> thanks
10:44:19 <edwardk> a couple of the diagrams left me quibbling slightly with the placement of the ... but i was able to puzzle through your meaning regardless.
10:47:44 <matt_m> Is there any way to resolve overlapped type functions?
10:47:56 <fax> type functions D:
10:47:58 <fax> what are you using them for
10:48:22 <matt_m> I was trying to create something like HList with type functions (families)
10:49:01 <guerrilla> is there a simple way to "override" the error function in Alex without rewriting the entire alexScanTokens function?
10:50:07 <matt_m> fax:  Basically I can't write "pattern matching" on a type level cons list, because there's no way to write different behavior for the case when type s matches type (s :+: ss)
10:51:19 <fax> what about  data List a where Nil :: List () ; Cons :: x -> List xs -> List (x, xs)
10:51:49 <fax> you can write things like append with it (using type functions) but it's pretty horrible to do so
10:52:36 <matt_m> fax: I'm not worried about horrible - let me think about it - thanks
10:53:08 <matt_m> fax: I think it's not going to be what I want because the things I'm collecting in lists are not types, but *->* kinded
10:53:22 <matt_m> fax: But maybe I can do something else with it
11:11:42 <whald> it's kinda funny if you are writing a raytracer and you compiler complains that you don't meet it's expectation for "Image RealWorld" :-)
11:11:51 <whald> s/you/your
11:12:59 <Makoryu> :t snd &&& fst
11:13:00 <lambdabot> forall a c. (a, c) -> (c, a)
11:13:46 <Makoryu> > let swap = snd &&& fst in swap undefined `seq` "OK"
11:13:47 <lambdabot>   "OK"
11:14:13 <Makoryu> > let swap (x,y) = (y,x) in swap undefined `seq` "OK"
11:14:15 <lambdabot>   "*Exception: Prelude.undefined
11:14:47 <Makoryu> :t OK
11:14:49 <lambdabot> Not in scope: data constructor `OK'
11:19:33 <aristid> :t let swap (x,y) = (y,x) in swap undefined `seq` "OK"
11:19:34 <lambdabot> [Char]
11:19:54 <aristid> :t let swap (x,y) = (y,x) in swap undefined
11:19:55 <lambdabot> forall t t1. (t1, t)
11:20:17 <aristid> > let swap (x,y) = (y,x) in swap undefined
11:20:18 <lambdabot>   *Exception: Prelude.undefined
11:20:35 <BMeph_> > let swap ~(x,y) = (y,x) in swap undefined `seq` "OK"
11:20:37 <lambdabot>   "OK"
11:20:57 <BMeph_> > let swap ~(x,y) = (y,x) in swap undefined
11:20:58 <lambdabot>   (*Exception: Prelude.undefined
11:21:23 <BMeph_> Note the starting parenthesis... ;)
11:22:06 <Makoryu> @let data OK = OK
11:22:07 <lambdabot>  Invalid declaration
11:22:11 <Makoryu> :|
11:26:51 * BMeph_ things: MetaMucil and donuts, a powerful combination...
11:27:01 * BMeph_ thinks*
11:30:35 <fryguybob> whald: belated lol.
11:42:17 <matt_m> fax:  Actually, I don't see how the GADT helps anything, since I still can't compare types for equality?
11:42:53 <fax> when do you want to check for equality
11:42:58 <matt_m> fax: There's still no way to write an operation with list0 :^: list1 = union of list0 and list1
11:43:23 <matt_m> fax: Basically, I'm trying to manage type level sets, rather than type level lists
11:43:41 <fax> in that case I would define a universe of types like:
11:43:45 <fax> data TYPE typ where
11:43:51 <fax>  NAT :: TYPE Nat
11:43:56 <fax>  BOOL :: TYPE Bool
11:44:09 <fax>  (:*:) :: TYPE a -> TYPE b -> TYPE (a,b)
11:44:09 <opqdonut> I like your caps
11:44:19 <fax> you can then implement  TYPE a -> Type b -> Maybe (Eq a b)
11:44:27 <matt_m> fax:  That doesn't support separate compilation, though, right?
11:44:34 <fax> what's separate compilation
11:44:37 <matt_m> fax:  You have to number all possible types up front
11:44:43 <matt_m> fax: I mean it's not modular
11:44:45 <fax> yyeah that's what I just said
11:44:48 <fax> of course it's modular
11:45:18 <fax> parametrize by TYPE :: * -> * and eqp :: TYPE a -> Type b -> Maybe (Eq a b)
11:45:58 <fax> you can punch a hole in the GADT to make it 'open' too - but this is too complicated to bear thinking about yet
11:46:31 <matt_m> fax: I'm lost
11:46:35 <fax> The next thing is we change the data type to:  data List a where Nil :: List () ; Cons :: TYPE x -> x -> List xs -> List (x, xs)
11:46:39 * benmachine wonders if you can do class Eq a b and then define instances for every single type pairing
11:46:53 <matt_m> benmachine: Of course you can, but that's not exactly modular either...
11:46:56 <fax> matt_m, you're thinking too far ahead incase there are problems
11:47:13 <benmachine> matt_m: you can just define n instances per type you want to introduce!
11:47:19 <benmachine> where n = total number of types in the system
11:47:24 <benmachine> orr, possibly 2n
11:47:25 <benmachine> not sure
11:48:01 <matt_m> fax: What does "TYPE type" mean?  What's the signficance of Nat and Bool?
11:48:10 <fax> that was just an example
11:49:56 <scott__> trying to do e^pi*i*x
11:50:03 <scott__> keep getting expected type errors
11:50:26 <fax> @let i = sqrt(-1) :: Double
11:50:27 <lambdabot>  Defined.
11:50:32 <fax> > exp (i * pi)
11:50:32 <lambdabot>   Ambiguous occurrence `i'
11:50:32 <lambdabot>  It could refer to either `L.i', defined at <local...
11:50:41 <matt_m> fax:  This suggeston is for the implementation of type level lists?
11:50:41 <fax> > let i = sqrt(-1) :: Double in exp (i * pi)
11:50:42 <lambdabot>   NaN
11:50:47 <fax> heh what
11:50:52 <fax> > let i = sqrt(-1) :: Double in exp 1 ** (i * pi)
11:50:53 <lambdabot>   NaN
11:50:53 <fax> oh
11:50:59 <fax> > let i = sqrt(-1) :: Complex Double in exp (i * pi)
11:51:00 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:51:19 <fax> matt_m no
11:51:53 <matt_m> fax: It's for comparing types for equality at the type level?
11:51:58 <Makoryu> > let i = sqrt (-1) in exp (i * pi) :: Complex CReal
11:51:59 <lambdabot>   (-1.0) :+ 0.0
11:52:05 <fax> no that doesn't make sense
11:52:14 <scott__> fax, what did you just do?
11:52:23 <fax> eqp is a value that compares types
11:52:37 <matt_m> fax:  Oh, ya, that does me no good
11:53:06 <matt_m> fax:  I want a type function:   IfEq t s a b  = "a if t=s else b"
11:53:06 <benmachine> scott__: be careful about which exponent function you use
11:53:12 <fax> why?
11:53:17 <scott__> toComp :: Double -> Complex Double
11:53:17 <scott__> toComp x = ((exp 1):+0) ^ (pi:+0 * (x:+0) * (0:+1))
11:53:24 <scott__> this does not work
11:53:26 <matt_m> fax: Because I want type level sets
11:53:32 <benmachine> scott__: a ^ b is only valid for positive integers b, a ^^ b is valid for all integers b, a ** b is valid for floating b
11:53:40 <fax> that doesn't suggest to me that IfEq is desirable
11:53:43 <scott__> hm.
11:53:50 <matt_m> fax:  SomeTypes (Int, Nat, String)
11:53:54 <benmachine> :t (**)
11:53:55 <lambdabot> forall a. (Floating a) => a -> a -> a
11:54:04 <benmachine> so (**) is probably what you want
11:54:07 <fax> well (Int, (Nat, (String, ())))
11:54:07 <benmachine> also
11:54:16 <fax> n-tuples have not structure
11:54:25 <benmachine> (pi * x * (0 :+ 1)) will force x and pi to be of the right type
11:54:26 <fax> so you can't program with them
11:54:32 <benmachine> oh but
11:54:33 <matt_m> fax:  SomeTypes (Int, Nat, String)  `union` SomeTypes (Int, [Int])   === SomeTypes (Int, Nat, String, [Int])
11:54:41 <benmachine> wil force x to be the wrong type
11:54:45 <matt_m> fax:  How do you write `union` without equality testing on types?
11:54:47 <scott__> ?
11:54:52 <benmachine> (pi * (x :+ 0) * (0 :+ 1))
11:55:02 <scott__> thats what i want?
11:55:06 <benmachine> umm
11:55:09 <benmachine> no
11:55:12 <scott__> yep, ok it was not giving me problems with pi
11:55:14 <benmachine> what you want is
11:55:20 <scott__> just x and :+1
11:55:27 <fax> matt_m, why isn't it  SomeTypes `union` SomeTypes === SomeTypes? I mean why index by a bunch of types?
11:55:37 <benmachine> :t \x -> exp (pi * (x :+ 0) * (0 :+ 1)
11:55:39 <lambdabot> parse error (possibly incorrect indentation)
11:55:42 <benmachine> whoops
11:55:43 <benmachine> :t \x -> exp (pi * (x :+ 0) * (0 :+ 1))
11:55:44 <lambdabot> forall a. (RealFloat a) => a -> Complex a
11:56:04 <fax> (x :+ 0) * (0 :+ 1) = (0 :+ x)
11:56:10 <benmachine> yeah I was just thinking that
11:56:21 <matt_m> fax:  Have you read the datatypes a la carte paper?
11:56:26 <fax> ye
11:56:32 <matt_m> fax:  Ok, something along those lines
11:56:35 <fax> ???
11:56:37 <matt_m> fax:  Tracking effects in types
11:57:32 <matt_m> fax:  That's the application - the approach is obviously much different (they use type classes pervasively)
11:58:09 <scott__> benmachine, that didnt work
11:58:13 <scott__> i dont think.
11:58:21 <benmachine> you don't think.
11:58:35 <scott__> :t \x -> exp (pi * (x :+ 0) * (0 :+ 1))
11:58:36 <lambdabot> forall a. (RealFloat a) => a -> Complex a
11:59:22 <scott__> it compiles
11:59:29 <scott__> but it doesnt give the correct answer.
11:59:39 <benmachine> what answer do you want
11:59:53 <benmachine> > let toComp x = exp (0 :+ x * pi) in toComp 0.5
11:59:54 <lambdabot>   6.123233995736766e-17 :+ 1.0
11:59:58 <benmachine> seems reasonable to me
12:00:43 <scott__> let toComp x = exp (0 :+ x * pi) in toComp 1
12:00:50 <scott__> let toComp x = exp (0 :+ x * pi) in toComp 1.0
12:00:55 <benmachine> > let toComp x = exp (0 :+ x * pi) in toComp 1
12:00:56 <scott__> oops
12:00:56 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
12:01:05 <benmachine> welcome to floating-point error
12:01:10 <scott__> yeah, i guess that's it
12:01:11 <benmachine> > mkPolar 1 pi
12:01:12 <scott__> no biggie!
12:01:12 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
12:01:21 <benmachine> turns out there's already a standard function too
12:01:25 <scott__> LOL
12:01:29 <scott__> thats hilarious
12:01:39 <scott__> well at least now i learned a little
12:01:41 <benmachine> :)
12:01:49 <benmachine> learning stuff is good
12:02:00 <scott__> eh, depends
12:02:13 <scott__> but haskell is worth it
12:02:21 <benmachine> a lot of what I learnt was by working out how to write standard functions
12:05:52 <BMeph_> See y'all after lunch...
12:07:27 <fryguybob> @src mkPolar
12:07:28 <lambdabot> mkPolar r theta  =  r * cos theta :+ r * sin theta
12:07:48 <scott__> yep, mathematically thats the other way to do it
12:07:54 <scott__> probably easier...
12:08:54 <fryguybob> > (mkPolar 1 pi) - (exp (0 :+ pi))
12:08:55 <lambdabot>   0.0 :+ 0.0
12:11:01 <fryguybob> @check \r t -> (mkPolar r t) - (r*exp (0 :+ t))
12:11:02 <lambdabot>   Occurs check: cannot construct the infinite type:
12:11:02 <lambdabot>    a = Data.Complex.Compl...
12:13:03 <trofi> @check \r t -> (mkPolar r t) == (r*exp (0 :+ t))
12:13:03 <lambdabot>   Occurs check: cannot construct the infinite type:
12:13:03 <lambdabot>    a = Data.Complex.Compl...
12:13:44 <swift-prime> So, was reading the Haskell wikibook discussion of the advantages of laziness, and I felt that a major one was missing: the ability to define your own control structures. How could you write your own 'if' in a strict-only language?
12:14:10 <benmachine> swift-prime: function pointers/closures?
12:14:37 <benmachine> would be a giant pain in C but technically possible :P
12:14:53 <monoidal> @check  \r t -> mkPolar r t == (r :+ 0) * exp (0 :+ t)
12:14:54 <lambdabot>   "OK, passed 500 tests."
12:14:56 <swift-prime> Benmachine: I dunno, you can.
12:14:58 <monoidal> trofi: ^
12:15:15 <swift-prime> Benmachine: can't just pass in an arbitrary expression tho
12:15:31 <pikhq> swift-prime: Basically, various forms of optional laziness.
12:15:43 <benmachine> swift-prime: no, but in a language like python or perl you could almost do so
12:15:58 <scott__> freaking crap, OK i am still incompetent
12:16:10 <swift-prime> Pikhq: sure, if you have that option
12:16:16 <scott__> the output of mkPolar
12:16:48 <scott__> is Complex a
12:16:50 <pikhq> swift-prime: By being Turing-complete, you can *force* that option to exist. Though the involved metaprogramming may be more of a "compiler" by the time you're done.
12:16:54 <trofi> monoidal: oh, thanks
12:16:56 <scott__> so why is my code rejecting it
12:17:00 <lpsmith> ugh,  cabal update should use rsync instead of downloading the entire package list over and over again
12:17:01 <scott__> says it is Double -> Complex a
12:17:03 <scott__> ???
12:17:10 <scott__> :i mkPolar
12:17:16 <scott__> > :i mkPolar
12:17:17 <lambdabot>   <no location info>: parse error on input `:'
12:17:22 <trofi> :t (*)
12:17:23 <lambdabot> forall a. (Num a) => a -> a -> a
12:17:31 <dcoutts_> lpsmith: I've been thinking about a mostly-append approach, since that's how tar itself works
12:17:38 <scott__> :t mkPolar
12:17:39 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:17:44 <dcoutts_> lpsmith: ie using http range requests to get the tail of the file
12:17:50 <benmachine> scott__: the type of mkPolar says it takes two a and gives you Complex a; they have to be the same a
12:17:56 <lpsmith> dcoutts, right
12:18:05 <benmachine> so Double -> Complex Double works but Double -> Complex Float won't
12:18:22 <scott__>     Couldn't match expected type `Complex b'            against inferred type `Double -> Complex Double'
12:18:30 <scott__> :|
12:18:31 <dcoutts_> lpsmith: we can't use rsync because of windows, it's also more complex than we really need
12:18:58 <benmachine> scott__: giving one argument to a two-argument function?
12:19:01 <swift-prime> Pikhq: fair enough, though surely lazy evaluation makes things _much much_ easier
12:19:04 <scott__> oh, that would be it
12:19:13 <scott__> i need to give it r and theta
12:19:18 <scott__> but where do i get theta?
12:19:20 <scott__> is that pi?
12:19:27 <scott__> sorry now i am just thinking aloud
12:19:28 <benmachine> uhm
12:19:36 <benmachine> in your original example, x * pi
12:19:40 <pikhq> swift-prime: Yes, yes it does.
12:19:57 <scott__> OK!
12:20:15 <dcoutts_> lpsmith: the main difficulty with downloading just the tail, is that it's hard to check if the earlier bit really is unchanged.
12:20:44 <benmachine> can't you just use magic hashes
12:20:52 <benmachine> or conventional ones, even
12:21:20 <lpsmith> dcoutts,  that's what rsync does.   I agree it's probably more internal complexity than strictly necessary... but (modulo windows) fairly little external complexity
12:21:28 <lpsmith> dcoutts, what's the issue with rsync and windows?
12:21:40 <dcoutts_> lpsmith: we'd have to ship an external binary
12:22:01 <dcoutts_> lpsmith: makes it hard to install and update cabal-install using hackage/cabal-install
12:22:02 <benmachine> reimplement rsync in haskell
12:22:20 <scott__> :t mkPolar
12:22:21 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:22:22 <dcoutts_> lpsmith: same reason we do not use an external tar or gzip program
12:22:24 <benmachine> reimplement x in haskell x
12:23:10 <swift-prime> Or just have the client deliver a checksum of the package list, and the server (presumably aware of old versions) deliver a diff between the client's version and the current one
12:23:12 <dcoutts_> lpsmith: so it's doable if the server supports the standard md5 checksum header, but not all dumb servers do
12:23:58 <dcoutts_> benmachine, lpsmith: being able to do the incremental updates over http is a pretty big advantage both for the server side and client side.
12:24:07 <dcoutts_> means people can host archives anywhere
12:24:31 <dcoutts_> rsync is much more special, fewer hosts support it
12:26:28 <lpsmith> dcoutts, primarily referring to silly http jingoism on the part of firewalls?
12:27:11 <dcoutts_> lpsmith: no, just that everyone has a web server configured, if it's easy to bung a package index/archive on a website then that's a nice advantage
12:27:39 <dcoutts_> lpsmith: just like it's easy to set up a darcs repo that's accessible over http
12:28:25 <dcoutts_> http is a fairly sensible and standard protocol for this sort of thing
12:29:21 <lpsmith> standard, yes,  sensible I'm not so sure :)
12:31:26 <lpsmith> dcoutts,  what about supporting rsync to the package list but gracefully degrading to slurping the whole file over http if rsync isn't available?
12:31:56 <dcoutts_> lpsmith: how would we discover that the same file was available by rsync?
12:32:14 <dcoutts_> perhaps from a http link header?
12:34:24 <lpsmith> dcoutts, I haven't really thought about that yet.   I had something like "try to connect to a standard location via rsync,  if that fails try again with http"
12:34:39 <lpsmith> although a linked resource header might be a better approach
12:34:58 <dcoutts_> it's reasonably important that package indexes/archives have a single URI entry point
12:35:17 <lpsmith> why?
12:37:22 <dcoutts_> lpsmith: for configuration, so people can pass URLs around
12:37:44 <dcoutts_> it's one of the main things that makes URLs helpful
12:38:05 <dcoutts_> you specify one URL and other related resources can be discovered from there
12:39:43 <lpsmith> dcoutts, well,  my idea was to functionally derive a "standard" rsync uri from an http uri,   which (to some extent) avoids that issue,  but I'm not claiming this idea is good either.
12:40:13 <dcoutts_> aye, that's not really how the web is supposed to work
12:43:03 <lpsmith> well, the internet wasn't supposed to see such a profusion of NAT and HTTP jingoism from firewalls either ;-)   but I digress
12:44:07 <winxordie> lol@HTTP jingoism
12:44:18 <winxordie> ... that makes a link? my bad.
12:46:34 <Twey> Maybe for you.
12:48:15 <uorygl> @pl \f x -> f (f x)
12:48:15 <lambdabot> join (.)
12:48:56 <jmcarthur> that's a neat one
12:50:27 <jmcarthur> :t \f x -> iterate f x !! 2  -- yay for obscurity
12:50:27 <lambdabot> forall a. (a -> a) -> a -> a
12:50:55 <uorygl> @src join
12:50:56 <lambdabot> join x =  x >>= id
12:51:11 <uorygl> Erm.
12:51:11 <dv-> @pl \y f -> f (y f)
12:51:11 <lambdabot> ap id
12:51:18 <uorygl> @type (join, (.))
12:51:19 <lambdabot> forall (m :: * -> *) a a1 b (f :: * -> *). (Monad m, Functor f) => (m (m a) -> m a, (a1 -> b) -> f a1 -> f b)
12:51:37 <uorygl> @djinn (e -> e -> a) -> e -> a
12:51:37 <lambdabot> f a b = a b b
12:51:41 <jmcarthur> uorygl: for functions, join f x = f x x
12:51:51 <uorygl> @src (.)
12:51:51 <lambdabot> (f . g) x = f (g x)
12:54:15 <jmcarthur> man, every time i do some developing on windows i regret it. if you are doing anything besides .NET it sucks!
12:54:30 <jmcarthur> difficult to even get a library installed properly
12:54:57 * uorygl shudders at the thought of not having apt-get.
12:55:04 <uorygl> Or maybe Windows does have some form of apt-get?
12:55:23 <jmcarthur> somebody at microsoft is actually working on a package manager of some sort
12:55:33 <daimrod> cygwin ?
12:55:36 <dv-> Cygwin has some package management
12:55:41 <jmcarthur> cygwin sucks too though
12:55:59 <lpsmith> jmcarthur, I find even .NET development rather...  frustrating.   I'm sure part of that is because I don't know the .NET platform all that well,  but it seems as though you end up fiddling a lot more getting things set up
12:56:04 <aavogt> @type (. (!! 2))
12:56:06 <lambdabot> forall b a. (a -> b) -> [a] -> b
12:56:14 <dv-> jmcarthur: I would say it fails to make windows not suck, perhaps
12:56:15 <jmcarthur> lpsmith: it's pretty good with, say, C#
12:57:23 <uorygl> @pl \f -> (f.f.f.f.f.f.f)
12:57:23 <lambdabot> ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (join (.))))))
12:57:43 <uorygl> Interesting.
12:57:57 <jmcarthur> :t \f x -> iterate f x !! 7
12:57:58 <lambdabot> forall a. (a -> a) -> a -> a
12:59:45 <aavogt> @pl \n f x -> iterate f x !! n
12:59:46 <lambdabot> flip (flip . ((!!) .) . iterate)
13:00:02 <aavogt> @pl \f x n -> iterate f x !! n
13:00:02 <lambdabot> ((!!) .) . iterate
13:02:11 <augur> any formal grammar/language nerds here?
13:02:15 <fax> you
13:05:14 * hackagebot Holumbus-Distribution 0.1.0 - intra- and inter-program communication  http://hackage.haskell.org/package/Holumbus-Distribution-0.1.0 (StefanSchmidt)
13:08:14 * hackagebot Holumbus-Storage 0.1.0 - a distributed storage system  http://hackage.haskell.org/package/Holumbus-Storage-0.1.0 (StefanSchmidt)
13:08:17 * hackagebot Holumbus-MapReduce 0.1.0 - a distributed MapReduce framework  http://hackage.haskell.org/package/Holumbus-MapReduce-0.1.0 (StefanSchmidt)
13:08:59 <dpratt71> how long should I expect that "cabal update" would run (the first time)?
13:09:13 <tensorpudding> Not long enough to be obnoxious.
13:09:22 <tensorpudding> Less than five minutes
13:10:01 <dpratt71> tensorpudding: ok; I'll give it more than that and see
13:10:19 <Twey> Depends on your connection speed, I guess
13:10:26 <tensorpudding> It's possible that hackage is really slow, or your connection is really slow, or both.
13:11:01 <dpratt71> unless running under virtualization affects the connection speed, I don't think that'd be the problem
13:14:38 <triyo> anyone got the new ver of happstack (0.5) to compile via cabal install?
13:15:03 <monoidal> i did, no problems
13:15:49 <dpratt71> well, fwiw, cnet reports my speed @ 960k; and still no sign of life from "cabal update"
13:16:15 <dcoutts_> dpratt71: you can kill it and try cabal update -v3 if you like, it gives a bit more info on what it's up to
13:16:46 <triyo> I got this error trying to install happstack: http://gist.github.com/389908
13:16:46 <dpratt71> dcoutts_: ok, I'll try that, thanks
13:17:42 <monoidal> triyo, which GHC?
13:18:02 <triyo> 10.6.4
13:18:11 <triyo> 6.10.4 :)
13:18:48 <dpratt71> well, third (fourth?) times a charm :)
13:18:50 <dcoutts_> triyo: we'd need to see why strict-concurrency-0.2.3 didn't install, that's earlier in the log
13:19:51 <dpratt71> should I take cabal's advice and "cabal install cabal-install"?
13:20:08 <dcoutts_> dpratt71: cabal generally gives good advice :-)
13:20:19 <dpratt71> dcoutts_: :) thanks
13:22:40 <triyo> dcoutts_: full install log http://gist.github.com/389908
13:24:48 <triyo> is it this line perhaps? "Could not find module `Control.OldException':"
13:26:08 <aavogt> so for some reason `strict-concurrency' is building with base-3 while Control.OldException came about with base-4
13:26:28 <aavogt> triyo: also, you have errors because some tools are not in your $PATH
13:26:39 <aavogt> ghc: could not execute: trhsx
13:27:03 <triyo> I noticed that...hmm.
13:30:13 <dcoutts_> aavogt: btw, what version of cabal-install are you using?
13:30:22 <dcoutts_> oh, erm, I mean triyo
13:30:26 <matt_m> So there is also no way to have type functions associated to a type class?
13:31:07 * jmcarthur wonders what ghc 10.6.4 will be like
13:31:07 <triyo> dcoutts_: cabal-install version 0.6.2 -> using version 1.6.0.3 of the Cabal library
13:31:31 <aavogt> what kinds of type functions?
13:31:32 <dcoutts_> triyo: ok, that'd explain why the strict-concurrency package is getting built against base-3 rather than 4
13:31:41 <triyo> jmcarthur: more pure ;)
13:32:00 <dcoutts_> triyo: you want 0.6.2 or later
13:32:07 <aavogt> that's a broken package...
13:32:11 <dcoutts_> triyo: oops, I mean 0.6.4 or later
13:32:27 <danharaj> Is there a way to configure haskell platform on windows to use an alternative gcc distribution?
13:32:30 <matt_m> aavogt:  I wanted to have a type class TypeEq s t, defining a type function  IfThen s t a b
13:32:47 <dcoutts_> aavogt: hsp you mean? that it uses trhsx but does not declare it as a build-tool ?
13:33:11 <aavogt> dcoutts_: I mean strict concurrency, which lets you use base-3 apparently, but isn't compatible
13:33:14 <triyo> dcoutts_: I ran an update on cabal-install itself, do I have to manually reinstall new ver? Sorry, new to cabal (haskell for that matter tpp) :)
13:33:24 <dcoutts_> aavogt: oh yes, that too.
13:33:54 * Berengal is struggling to come up with a bullet point list conveying enthusiasm for FP
13:34:06 <aavogt> matt_m: and this is not sufficient:      class TypeEq s t where type IfThen s t :: * -> * -> * ?
13:34:10 <Berengal> I think I might have to do some jumping when presenting
13:34:13 <dcoutts_> triyo: cabal install cabal-install (I think cabal itself will recommend you do that, since it notices a newer version of itself is available)
13:34:40 <Berengal> "LESS BUGS!" *jump jump jump* ... *click* ... "MORE COMPOSITIONALITY!" *jump jump jump*
13:34:45 <Twey> haha
13:34:48 <matt_m> aavogt:  I tried that... it complains at the instances
13:34:55 <triyo> dcoutts_: oh I see, its getting 0.6.8 I think...
13:35:01 <Twey> Why FP Matters
13:35:09 <matt_m> aavogt:  It thinks I'm creating a type synonym, not an associated type function
13:35:28 <aavogt> matt_m: what are your instances?
13:35:40 <EvanR-work> Berengal: how about 'FP roxors your boxes rofl lol O_o'
13:35:52 <matt_m> instace (TypeEq t t) where type IfThen t t a b = a
13:35:55 <EvanR-work> i forgot various exclamation marks
13:36:05 <Berengal> EvanR-work: I already used my l33t h4xor quota on "Shit bricks"
13:36:07 <matt_m> instance (TypeEq s t) where type IfThen s t a b = b
13:36:42 <matt_m> aavogt:  Some error about synonyms needing the same number of parameters as where they were declared
13:36:48 <Berengal> (Yes, one of the bullet points is "Shit bricks". I plan on following it up with fibs = 0 : 1 : zipWith (+) fibs (tail fibs))
13:38:09 <triyo> member:dcoutts_: hmm strange. Update completed with no errors. But > cabal --version still reads 0.6.2. Do I have to do something else?
13:38:22 <matt_m> aavogt:  It's weird, it won't even let me do   IfThen s t = Foo, where  type Foo a b = a is a top level declaration
13:38:47 <aavogt> matt_m: how about if your Foo is a type family?
13:39:16 <dcoutts_> triyo: you might have a version installed elsewere on your $PATH, e.g. /usr/local/bin, but the new version probably got installed to ~/.cabal/bin
13:39:27 <triyo> yup you are right
13:39:40 <triyo> just checked. I change my $PATH
13:40:15 <matt_m> aavogt:  How would that go?
13:40:34 <matt_m> Declare  'type family Foo a b' and hten just reference Foo?
13:40:43 <matt_m> I imagine that will be the same error, but I'll check
13:41:20 <matt_m> aavogt:  Same error
13:41:36 <kulin> is pattern matching on Maybe an expensive opperation? I have a function in which 99% of the time the maybe will be 'Just a' and I am not sure if it is worth refactoring out the maybe
13:43:31 <EvanR-work> kulin: kind of like the checking of c return values for errors, aint it ;)
13:44:07 <EvanR-work> which almost certainly happens everywhere in the kernel not to mention every c program that uses the standard lib
13:44:14 <EvanR-work> and has error checking
13:44:33 <kulin> ya, I am sure you are right
13:45:08 <EvanR-work> that being said, i wonder if you could get a performance improvement using exceptions for all that, if c had exceptions
13:45:35 <EvanR-work> not that you are handling errors
13:46:13 <kulin> well what i am specifically doing is a network message reader, in which a logged in user will have (Just id) while an anonymous user will have Nothing
13:46:44 <EvanR-work> you could probably get a more straight forward representation of that
13:46:59 <EvanR-work> data User = User Int | Anonymous
13:47:28 <EvanR-work> though you wouldnt be able to use the Data.Maybe stuff
13:47:47 <kulin> ya, i was thinking about breaking up the function into a function that handles events for anonymous users and logged in ones, but I wasnt sure if there would be a performance gain for the trouble
13:48:01 <kulin> i mean 2 functions
13:48:14 <kulin> I'll just use the pattern matching
13:48:27 <EvanR-work> parameterizing the handler would be nice
13:48:46 <EvanR-work> then you can present the user with various shells
13:49:30 <Eelis> would something like "class LeftIdeal a b where bla :: b -> a -> a" be an appropriate way to classify the operation of concatenating a regular list to the left side of a nonempty lists? (since nonempty lists form a two-sided semigroup ideal of lists). i'd then have an "instance LeftIdeal (NeList a) [a] where ..."
13:49:38 <EvanR-work> i think a good rule of thumb is dont optimize until you find that its too slow and this particular issue is whats causing it
13:50:01 <triyo> dcoutts_: thx the cabal update to 0.8.2 worked. Now happstack 0.5.0 installs
13:50:15 <whald> could someone tell my why the function in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25326#a25326 is really really slow? i guess i'm missing strictness, but where?
13:50:22 <dcoutts_> triyo: I fired off an email to the maintainers of those two packages
13:50:27 <Cale> EvanR-work: and of course, make sure to try -O2 ;)
13:50:39 <EvanR-work> ah
13:50:45 <EvanR-work> i forget about that ;)
13:50:48 <triyo> dcoutts_: good idea. thanks again.
13:50:52 <HugoDaniel> how many hackage pkgs are there ?
13:51:17 <Cale> whald: You're foldl'ing (++)
13:51:21 <Cale> whald: use concat
13:51:28 <Cale> whald: Or at least foldr (++)
13:51:49 <Cale> Or, perhaps better yet, don't use String at all.
13:51:55 <dcoutts_> HugoDaniel: 554 users have uploaded 8029 versions of 2052 packages.
13:52:10 <whald> :t concat
13:52:11 <lambdabot> forall a. [[a]] -> [a]
13:52:18 <HugoDaniel> mt interessante
13:52:20 <Cale> whald: Left-associating a chain of (++)'s will have quadratic performance
13:52:38 <Cale> whald: because to fully evaluate xs ++ ys takes O(length xs) steps
13:53:01 <whald> because it means traversing the list to the end every time we append someting?
13:53:06 <jmcarthur> yup
13:53:27 <Cale> So when you have something like (((ws ++ xs) ++ ys) ++ zs) you traverse the initial part of the list over and over
13:53:33 <jmcarthur> if you use foldr then each list is only traversed at most once
13:53:38 <jmcarthur> or concat
13:54:03 <whald> i'll go for concat, thanks!
13:54:22 <Cale> Also, just a style point:  v <- return x  is better stated as  let v = x
13:55:02 <whald> Cale: thanks again, that "returns" in the middle of a function bugged me all the time! :-)
13:55:04 <tensorpudding> no reason to wrap the x in return if you're just going to unwrap it a moment later
13:55:13 <matt_m> Arg ... here's a thread from 2007 in which SPJ acknowledges the problem I have and says they have a proposed solution, ... but I don't see any indication that anything like this has been done: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-October/013271.html
13:55:26 <dolio> > let f = succ in (f 'c', f 5) -- FYI, Cale
13:55:26 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:55:26 <lambdabot>    arising from the literal `5...
13:55:37 <dolio> Monomorphism restriction is back on.
13:57:22 <jlouis> @pl (\(k,v) -> k ++ "=" ++ v)
13:57:22 <lambdabot> uncurry ((. ('=' :)) . (++))
13:58:27 <tensorpudding> It's always good when the pointless solution is longer.
13:58:29 <jmcarthur> the MR applies to let?
13:58:44 <Cale> dolio: Hmm, I wonder why that is.
13:58:51 <Cale> jmcarthur: Always has
13:59:05 <jmcarthur> i've never bumped into it using let i guess
13:59:08 <Cale> let is exactly the same thing as the top level, at least, prior to GHC 6.12
13:59:40 <jmcarthur> what was that trick about using unsafePerformIO to implement unsafeCoerce then? wasn't that using polymorphic let? wait.... oh
13:59:48 <orlandu63> @src uncurry
13:59:48 <lambdabot> uncurry f p = f (fst p) (snd p)
13:59:51 <jlouis> tensorpudding: I had a wtf moment there
13:59:51 <Cale> They're kind of screwing with the type inference of let now. I'm not sure that I'm completely happy about it.
14:00:05 <jmcarthur> duh, of course. the MR only applies when type classes come into play
14:00:15 <whald> hmmm, now i have http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25326#a25327 which runs out of stack space for large images (yet it's much faster than the previous version)
14:00:16 <jmcarthur> Cale: is it still to spec?
14:00:31 <Cale> jmcarthur: I'm not sure.
14:01:11 <Cale> jmcarthur: I heard that they were going to skip the generalisation step altogether for let expressions.
14:01:17 <dolio> There's some new ideas in SPJ's "let Should not be Generalized" paper, but I think you need to turn that on.
14:01:24 <Cale> mmm, okay
14:01:36 <matt_m> I don't like the "don't generalize let" idea either
14:01:37 <Cale> I'll see what I can do about the MR.
14:01:52 <Cale> (I'm not sure how it got turned back on)
14:02:32 <tensorpudding> Does anyone use let more than where?
14:02:48 <matt_m> I do
14:02:50 <tensorpudding> Outside of bindings in GHCi, I mean.
14:02:54 <Cale> I use them... about equally I think.
14:03:06 <tensorpudding> I found that I use where far more often.
14:03:07 <dolio> tensorpudding: The same thing would apply to where.
14:03:09 <Cale> @flush
14:03:34 <matt_m> Can you nest where?
14:03:37 <Cale> Yes
14:03:39 <tensorpudding> Yes
14:03:52 <matt_m> I only ever use where on top level bindings
14:04:01 <matt_m> and only then if I'm sharing somethign between cases
14:04:01 <benmachine> I use where all the time
14:04:03 <Cale> > let f = succ in (f 'c', f 5)
14:04:07 <jlouis> whald: tried to heap profile it? ./Program +RTS -hc -RTS followed by hp2ps -e8in -d -c Program.hp && evince Program.pdf
14:04:07 <benmachine> but that is because I have weird habits
14:04:11 <lambdabot>   ('d',6)
14:04:16 <Cale> there, all better :)
14:04:26 <tensorpudding> I had gotten used to seeing where used far more often than let
14:04:33 <orlandu63> why is the function uncurry called so?
14:04:33 <tensorpudding> and let that style my coding.
14:04:39 <orlandu63> i thought currying was partial function application
14:04:44 <Cale> orlandu63: nope
14:04:47 <jlouis> orlandu63: it is the opposite
14:04:49 <Twey> orlandu63: Because it converts a function from a curried form to a non-curried form.
14:04:50 <jlouis> of curry
14:05:09 <xerox> > join (***) succ ('c',5)
14:05:15 <Cale> orlandu63: Currying is the process of taking a function which takes a tuple as a parameter, and turning it into a function which takes the first part of that tuple, and produces another function
14:05:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:05:23 <lambdabot>    arising from the literal `5...
14:05:29 <Twey> MR'd
14:05:30 <jmcarthur> :t curry
14:05:36 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:05:43 <orlandu63> oh..
14:05:52 <benmachine> that's not MR that's just
14:06:02 <benmachine> the type of join, I suppose
14:06:09 <Cale> orlandu63: Partial application is applying a function to fewer than its full set of parameters, or only part of its input to obtain another function. Of course, it is easier to do when the function has been curried.
14:06:10 <jmcarthur> it's just how unification works
14:06:14 <Twey> Not join
14:06:18 <Twey> Why must it?
14:06:28 <Twey> :t let f = join (***) succ in f
14:06:33 <orlandu63> Cale: you mean when it has be uncurried?
14:06:34 <whald> jlouis: i'm at it.. thought i can get the answer cheap. ;-)
14:06:34 <lambdabot> forall c. (Enum c) => (c, c) -> (c, c)
14:06:37 <Cale> orlandu63: no
14:06:47 <Twey> Hmph
14:06:55 <Twey> :t let f = join (succ *** succ) in f
14:06:57 <lambdabot>     Couldn't match expected type `(b, b') -> b''
14:06:57 <lambdabot>            against inferred type `(b, b')'
14:06:57 <Twey> Er
14:06:59 <benmachine> Twey: there's only one succ, I suppose, so it can't have two different types
14:06:59 <lambdabot>     Probable cause: `***' is applied to too many arguments
14:07:00 <Twey> :t let f = (succ *** succ) in f
14:07:01 <lambdabot> forall b b'. (Enum b', Enum b) => (b, b') -> (b, b')
14:07:03 <Twey> Huh
14:07:05 <Twey> I guess so
14:07:09 <jlouis> whald: pixels is going to be awfully large
14:07:18 <Cale> If we have f (x,y) = ... and we want to partially apply it, say, to fix the x part of the tuple to be 5, then we need to write something like (\y -> f (5,y))
14:07:21 <c_wraith> @let argTypeAs :: (a -> b -> c) -> b -> a -> b -> c ; argTypeAs = const
14:07:21 <benmachine> okay that doesn't 100% make perfect sense but you get what I mean ish
14:07:22 <lambdabot>  Defined.
14:07:33 <jmcarthur> > join (***) (succ :: forall a . Enum a => a -> a) ('c', 5)
14:07:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:07:34 <lambdabot>    arising from the literal `5...
14:07:46 <Cale> If we curry that f, though, so that it looks like  f x y = ...  then we can simply write  f 5
14:07:46 <c_wraith> @type join `argTypeAs` (+)
14:07:48 <lambdabot> forall c a. (Num a) => ((a -> a -> a) -> (a -> a -> a) -> c) -> (a -> a -> a) -> c
14:07:50 <Taejo> @src uncurry
14:07:50 <lambdabot> uncurry f p = f (fst p) (snd p)
14:07:54 <jmcarthur> doh
14:08:34 <Cale> orlandu63: Make sense?
14:08:34 <c_wraith> I think I got that wrong. >_>
14:08:53 * benmachine wonders if this is not more easily understood as uncurry f ~(x,y) = f x y
14:08:58 <jmcarthur> > let f :: (Enum b, Enum c) => (forall a . Enum a => a -> a) -> (b, c) -> (b, c) ; f = join (***) in f succ ('c',5)
14:08:59 <lambdabot>   Couldn't match expected type `forall a.
14:08:59 <lambdabot>                                (GHC...
14:09:08 <jmcarthur> wish i could actually see the error
14:09:21 <c_wraith> @let argTypeAs (a -> b) -> a -> a -> b ; argTypeAs = const
14:09:22 <lambdabot>   ViewPatterns is not enabled
14:09:24 <whald> jlouis: funny thing is that when running with "-hc" i don't get an overflow. but theres an big spike when the image is being written
14:09:30 <c_wraith> @let argTypeAs :: (a -> b) -> a -> a -> b ; argTypeAs = const
14:09:31 <lambdabot>  <local>:3:0:
14:09:31 <lambdabot>      Duplicate type signature:
14:09:31 <lambdabot>        <local>:3:0-35: argTypeAs...
14:09:48 <ulfdoz> Das T400 ist quasi schon das zugestndnis.
14:09:52 <ulfdoz> ewin
14:09:59 <orlandu63> Cale: yes, however the function uncurry seems to do what you just said: turns f (x, y) into f x y. yet you say that "if you curry this function, partial application is easier."
14:10:02 <c_wraith> @let argType :: (a -> b) -> a -> a -> b ; argType = const
14:10:03 <lambdabot>  Defined.
14:10:06 <Cale> Wait, what was that about ViewPatterns, lambdabot?
14:10:18 <benmachine> > let (\x -> x -> x) = 0 in x
14:10:19 <lambdabot>   0
14:10:23 <c_wraith> I mistyped the type signature and \bot thought it was a view pattern
14:10:23 <Cale> orlandu63: That is the opposite of what uncurry does
14:10:27 <benmachine> seems just in @let
14:10:45 <jlouis> whald: there is your problem. Now you just need to devise a fix
14:10:47 <orlandu63> @src uncurry
14:10:47 <lambdabot> uncurry f p = f (fst p) (snd p)
14:10:52 <Cale> orlandu63: uncurry takes an already-curried function f, and produces a function which takes (x,y) and returns f x y
14:10:53 <c_wraith> @type join `argType` (+)
14:10:54 <lambdabot> forall a. (Num a) => (a -> a -> a) -> a -> a
14:11:44 <Cale> :t uncurry
14:11:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:11:47 <Cale> :t curry
14:11:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:12:07 <Cale> The type makes it clearer perhaps than the code for the function does
14:12:21 <orlandu63> wow
14:12:27 <orlandu63> yes, yes it does
14:12:33 <orlandu63> i see now :)
14:12:48 <whald> jlouis: i never know if i can fix this in the failing function or if i have to change s.t. where the function is being used
14:13:15 <jmcarthur> > let f :: (Enum b, Enum c) => (forall a . Enum a => a -> a) -> (b, c) -> (b, c) ; f g = g *** g in f succ ('c', 5)
14:13:16 <lambdabot>   ('d',6)
14:13:38 <jmcarthur> couldn't use join because it restricts the type too much
14:17:37 <jlouis> whald: I would write the pixels directly to a Handle rather than running concat. You can probably hook up a Writer to do that
14:18:26 * writer hooks up.
14:19:44 <whald> jlouis: Handle as in "file handle"?
14:19:52 <jmcarthur> jlouis: wait, what?
14:20:18 <jmcarthur> writer: lol
14:20:37 <whald> O.o
14:20:40 <writer> :D
14:21:07 <monad> now i will be highlighted all the time
14:21:53 * writer is a monad.
14:22:14 <monad> actually...
14:23:37 <jlouis> whald: I would just be lazy and throw everything into IO. If you wan't there is a chapter in RWH on restricting the IO monad http://book.realworldhaskell.org/read/programming-with-monads.html
14:23:46 <jlouis> want even!
14:24:03 <jmcarthur> jlouis: you're doing it wrong
14:24:26 <jlouis> jmcarthur: what would you suggest then?
14:25:06 <jmcarthur> jlouis: what is it that you think is bad about what whald is doing? i don't have much context. i just saw that you are suggesting that he use IO instead of concat
14:25:14 <jmcarthur> which doesn't really make any sense to me
14:25:40 <c_wraith> in the context of generating chunks of output, it can make more sense to just write them out than concatenate them.
14:25:49 <jmcarthur> oh, chunks of output
14:25:54 <jlouis> what c_wraith said
14:26:29 <jmcarthur> i would normally agree, but since we're talking about concat here i assume we're talking about lists
14:26:31 <jlouis> there is no problem in using concat, but for some reason the computation is not lazily pushed out but built up in memory first
14:26:44 <jmcarthur> in which case i don't see a big savings in doing chunks instead of one big lazy chunk
14:26:56 <jmcarthur> jlouis: i thought that was due to dolfl
14:26:57 <jmcarthur> err
14:26:59 <jmcarthur> foldl
14:27:14 <jmcarthur> which has not been replaced by concat
14:27:16 <jmcarthur> *now
14:27:48 <whald> jmcarthur: indeed i replace foldl by concat somehow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25326#a25327
14:28:23 <jlouis> jmcarthur: the foldl is now a mapM
14:28:24 <jmcarthur> whald: is it still building up a bunch of stuff in memory before outputting?
14:29:31 <whald> jmcarthur: it does, if i interpret the profiler output correctly there are lots of getpixel invocations piling up
14:29:35 <jmcarthur> oh it's mapM
14:30:03 <jmcarthur> the problem isn't the concat stuff, it's where it's getting the information from (IO)
14:30:11 <jmcarthur> knowing this i now agree with jlouis
14:30:27 <jlouis> ST is lazy, right?
14:30:28 <jmcarthur> it would be better to interleave the IO explicitly. read stuff, write stuff, read stuff, write stuff, etc.
14:30:37 <jmcarthur> oh it's ST
14:30:39 <whald> if it dares to build up the full string in memory, that's like 8 mb and i can live with that.
14:30:40 <jmcarthur> is it?
14:30:40 <c_wraith> jlouis: there are two STs.  one lazy, one isn't
14:30:53 <jlouis> even bettar!
14:30:56 <ezyang> If I want to parse a Cabal package file, which module do I want?
14:31:15 <dcoutts_> ezyang: take a look at the Cabal library
14:31:38 <ezyang> Looking at it right now. I'm not sure which of the several dozen modules is relevant though
14:31:53 <whald> it's the Control.Monad.ST "ST"
14:32:09 * jmcarthur wonders about iteratee for ST
14:32:15 <jlouis> whald: how do you hit the 8mb figure? Each cell is something like at least 8 bytes on a 64 bit arch
14:32:26 <dmwit> Hey! I just checked "strings Main | grep \\.so".
14:32:39 <dmwit> Most of the libraries look fine (and locate finds them), but one of them has an absolute path.
14:32:39 <ezyang> Aha, PackageDescription
14:32:45 <dmwit> Is that _really_ right?
14:33:04 <whald> and a [Char] uses a cell for every Char i guess?
14:33:44 <jlouis> whald: representation is a singly linked list of Char's plus eventual padding
14:34:00 <jmcarthur> whald: is bidir path tracing really nothing more than tracing some paths forward and some paths backward?
14:34:20 <jmcarthur> oh no it's not
14:34:26 <jmcarthur> the wikipedia description is really bad
14:34:46 <whald> jmcarthur: that's the tracing part, it gets trickier when you combine the paths (which you have to)
14:34:46 <dmwit> ?botsnack
14:34:47 <lambdabot> :)
14:34:52 <jlouis> Control.Monad.ST should be the strict variant, so my guess is that pixels is forced
14:35:21 <jlouis> and getPixel is the allocator according to your -hc reports
14:36:24 <jlouis> so hypothesis is you sit with h*w*(8+x)*12 bytes
14:37:19 <jlouis> assuming 4 bytes in alignment for the char, that is 90 megabyte for an 800x800 image.
14:37:27 <whald> (hpaste seems to do it's back up, but the full module paste is ahead)
14:37:38 <whald> jlouis: these numbers are sensible
14:37:52 * hackagebot happstack-hamlet 0.1 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-0.1 (JeremyShaw)
14:38:14 <whald> i'm at ~50 MB for 640x480
14:38:35 <jlouis> > 640*480*12*12 / 1024
14:38:37 <lambdabot>   43200.0
14:38:41 <jlouis> plausible
14:39:10 <jlouis> I'd say the simplest thing is to interleave some IO and write to a handle in chunks directly
14:39:42 <jmcarthur> i think i might try a path tracer tonight
14:40:32 <whald> jmcarthur: cool! i want to see then!
14:40:39 <fax> what is path tracing
14:40:42 <jmcarthur> i've never done one
14:40:44 <fax> ?
14:41:06 <jmcarthur> fax: it's like ray tracing but more true to reality
14:41:13 <fax> in what respect?
14:41:46 <whald> fax: it solves the "rendering equation" using monte carlo integration
14:41:51 <fax> ah
14:41:52 <jmcarthur> fax: you trace paths of light around until they hit the camera or you hit a recursion limit, modelling scattering distribution functions accurately
14:42:02 <fax> that is cool
14:42:27 <jmcarthur> they are often used to create reference renderings to evaluate faster renderers' qualities
14:42:36 <whald> jmcarthur: a recursion limit introduces bias, russian roulette is none the harder to implement, faster in most cases and has no bias
14:42:45 <jmcarthur> and GPUs are gradually getting closer to making path tracing feasible for other things
14:43:01 <jmcarthur> whald: i will need to look into it a bit
14:43:12 <jmcarthur> i may tap you as a resource if you don't mind :)
14:43:32 <whald> you're welcome :-)
14:44:01 <jmcarthur> whald: any good links you would recommend?
14:44:13 <whald> pbrt.org/forum
14:44:19 <whald> ahh1
14:44:28 <whald> pbrt is great
14:44:42 <whald> but i meant http://ompf.org/forum/
14:44:53 * hackagebot List 0.3.0 - List monad transformer and class  http://hackage.haskell.org/package/List-0.3.0 (YairChuchem)
14:46:19 <whald> and if you want to get something going in one night i'd recommend: an infinite area light, lambertian surfaces and most probably spheres / planes
14:48:27 <jmcarthur> cool thanks
14:48:33 <jmcarthur> i'm gonna leave work now, but i'll be back here later
14:49:31 <whald> it's 10 to midnight here, i'll stay for maybe another hour and the be back tomorrow
14:49:40 <jmcarthur> ah, i'll probably miss you then
14:49:57 <jmcarthur> guess i'll just talk to you tomorrow
14:50:03 <whald> jmcarthur: i'll miss you more :-)
14:50:18 <whald> ok, that will be fun :-)
14:52:07 <dmwit> So, I've got this program that I built on another machine.
14:52:15 <dmwit> It's currently linked to a library with an absolute path.
14:52:26 <dmwit> Any idea how to run it here without having root access?
14:52:34 <dmwit> That library exists here, just in a different location.
14:52:48 <whald> dmwit: maybe some chrooting?
14:53:03 * dmwit sighs
14:53:12 <dmwit> Yes, I suppose I've got to learn that freaking tool eventually.
14:53:19 <dmwit> =)
14:53:26 <ddarius> dmwit: Install KeyKOS.
14:53:57 * dmwit googles
14:54:25 <dmwit> yikes
14:54:33 <dmwit> The solution is to install another operating system?
14:54:54 <dmwit> I mean, there's no solution like, "Ask GHC not to freaking do that"?
14:56:08 <EvanR-work> check this problem out
14:56:10 <glguy> dmwit, I haven't seen much of the discussion but is LD_LIBRARY_PATH relevant?
14:56:25 <dmwit> LD_LIBRARY_PATH includes the directory that has the library.
14:56:27 * gwern bets nixos wouldn't have that problem!
14:56:43 * dmwit bets it isn't the operating system's fault!
14:57:20 <EvanR-work> i have a list with two kinds of items. i want to map this list. the map is either a Data.Map lookup, or an IO action. easy right? however, the IO action takes a list and returns a list for efficiency (asychronous lookup)
14:57:30 <EvanR-work> how do i get the final result in the right order
14:57:31 <gwern> dmwit: it could be the OS's fault if you look at it right
14:58:31 <dmwit> I dunno. Who generates the links? Isn't it GHC? If so, why is GHC linking all of these things the normal, relative way, except for this one library?
14:58:55 <gwern> actually, I think nixos must make it relative, or else the whole scheme falls apart
14:59:05 <dmwit> (specifically, it's /lib/ld-linux-x86-64.so.2 which lives in /usr/lib64 on this machine)
14:59:13 <gwern> hm... or make the absolute address be a hash address at least
14:59:19 <gwern> which would still be bad
14:59:22 <gwern> nm then
15:01:33 <dmwit> EvanR-work: I'm not sure I understood your question.
15:02:30 <EvanR-work> dmwit: i rearranged for better sanity
15:02:33 <dmwit> EvanR-work: What does "I want to map this list" mean?
15:02:33 <gwern> needs moar types
15:05:10 <EvanR-work> dmwit: but generally, if i want to do something like [Either a b] -> [c], and the operation for Left is Left -> c, and the operation for Right is [Right] -> IO [c]
15:05:27 <EvanR-work> i know that explanation doesnt type check
15:05:52 <EvanR-work> the IO is probably irrelevant
15:08:37 <glguy> mapM (\ x -> case x of Left a -> return (f a) ; Right b -> (do [r] <- ioact b; return r))
15:08:48 * glguy guesses that EvanR is trying to do something like that
15:10:14 <EvanR-work> it would work if you passed singleton lists to the 'right operation' each time
15:10:27 <EvanR-work> but
15:10:38 <monoidal> mapM (either (return.f) g)?
15:10:53 <monoidal> or return.return.f
15:12:09 <EvanR-work> you got a -> c, and [b] -> [c], and you want to map [Either a b] to [c], but not by using singleton lists
15:12:48 <glguy> mapMaybe the original list to extract the Right elements
15:12:55 <glguy> run them through the io call
15:13:00 <EvanR-work> yes
15:13:09 <glguy> and then map accross the list with an accumulator (mapAccumL)
15:13:16 <glguy> either performing the left operation
15:13:25 <glguy> or inserting the next result from the accumulator
15:13:32 <EvanR-work> :o
15:13:35 <EvanR-work> i think that solves it
15:13:52 <EvanR-work> and im doing something similar that applies more to the real situation
15:14:26 <EvanR-work> but yeah sounds like a general plan. moral of the story is dont make the primitive operation [b] -> [c], just let the user use map ;)
15:14:59 <danharaj> Which library defines unfold?
15:15:07 <glguy> base? Data.List?
15:15:20 <danharaj> I really need to get better at not being blind.
15:15:27 <idnar> @hoogle unfold
15:15:28 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
15:15:28 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:15:28 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:15:38 <glguy> Thanks, lambdabot!
15:16:09 <fax> @index unfold
15:16:09 <lambdabot> bzzt
15:16:16 <glguy> unfoldr*
15:16:18 <fax> umghaoundpfr
15:16:23 <glguy> or did he want unfold?
15:16:53 * glguy automatically spell-checked the question
15:17:11 <danharaj> unfoldr for lists.
15:17:15 <danharaj> I found it thanks.
15:17:56 <dmwit> EvanR-work: Oops, I pretended to be interested and then ran off. Sorry. Sounds like glguy got you sorted, though.
15:18:45 <EvanR-work> yes
15:18:52 <EvanR-work> i asked the question better to him, i think
15:23:08 <halberd> I was thinking about "design by prototype" - the thing is, in a real program it tends to get cluttered with extra code that is only tangential to the original purpose of the program
15:24:00 <halberd> so perhaps you could start with a prototype of the program that includes only the core functionality, ignoring stuff like error handling or I/O
15:24:46 <halberd> and if your program needs to do multiple things you could start with multiple separate prototypes, each of them absolutely clean of cruft for their very narrow focus, and each of them mostly useless by itself
15:25:27 <halberd> to actually make the program you'd combine (manually) the different prototypes, to produce a less elegant but more useful conglomerate
15:25:44 <halberd> but you leave the prototypes around, and as you change the final program you also change the prototypes, as documentation
15:26:23 <halberd> so if someone new to the program asks "how does the program do X?" you don't have to wade through pages of code 95% devoted to other purposes, you can just show him the prototype for X
15:26:23 <gwern> reminds me of the quickcheck idiom of testing \x -> prototype x == optimized-version x
15:27:07 <EvanR-work> halberd: keeping the two versions synchronized sounds annoying. but i guess checks are automatic
15:28:59 <halberd> also it would be easier to test the prototypes than to test the giant combined system
15:29:53 <halberd> because the combined system might need to be tested through some obscure sequence of actions in a GUI, or perhaps even involving physically hooking up machines
15:30:28 <halberd> but the prototypes could have a much simpler text interface, or just be called directly from the read eval print loop
15:30:54 <halberd> enabling simpler testing and testing automaton
15:31:00 <halberd> automation
15:32:50 <halberd> once you got the prototypes right it would just be a matter of gluing them back together in the system, which could be very difficult
15:37:03 <halberd> I don't see how you could easily automate checks to see that the prototypes match the system
15:40:26 <nus> halberd, you develop protochecks and combine them (manually), then the final combination of the checks is the automation for the final combo of prototypes (the system, by your definition)
15:46:37 <dmwit> halberd: A big part of that can be summarised as "keep the core pure, and just have a thin IO layer for the checks/exception handling".
15:47:16 <dmwit> halberd: xmonad does a great job of this, I think; almost all of the real magic is in the StackSet primitives, and then there's some X () monad doing the actual IO.
15:47:49 <halberd> in big programs that's probably going to be very difficult to do
15:47:57 * dmwit nods
15:48:09 <halberd> for example... suppose your company makes two versions of a program, which are designed to be sold in two different countries
15:48:38 <halberd> they are developed simultaneously, and the differences are not great, so you end up with lots of checks in the code to see which version you are running to decide what to do
15:49:00 <halberd> on the same codebase
15:49:12 <Botje> halberd: that's why all modern source control systems support branches
15:49:40 <halberd> the two programs are similar enough so that entirely separate branches are not justified
15:49:43 <halberd> most changes apply to both versions
15:50:23 <halberd> or even, perhaps, you have fifty different countries that you sell the program in
15:50:29 <Botje> all the more reason to use branches
15:50:38 <nus> isn't "lots of checks" contradicting "similar enough"?
15:50:39 <Botje> clean merging
15:50:49 <dmwit> Well, I would argue that the right way to do that would be to have a small record containing the functions that behave differently in the two programs.
15:50:53 <halberd> well by lots of checks I don't mean a check every other line
15:51:00 <dmwit> Your big program is then a ReaderT wrapping that record...
15:51:32 <halberd> or maybe your program consists of 300 different features each of which is licensed separately
15:51:43 <halberd> and you have thousands of customers, no two with the same set of features
15:53:04 <halberd> it's not always feasible to have separate branches for each combination of features
15:53:32 <Botje> why not? branches are cheap.
15:53:42 <halberd> you have to merge changes into every branch
15:53:43 <Botje> and i suppose your customers don't mind having some extra features
15:53:50 <Botje> merging is cheap nowadays
15:53:58 <danderson> branches require management overhead, not merge tracking overhead
15:54:07 <danderson> keep track of what is where, what depends on what...
15:54:11 <halberd> you have to figure out whether the merge is going to break things in each branch you merge it to
15:54:22 <scott__> question about laziness: if i compute something in a monad and use it in 2 let statements, will if evaluate once or twice?
15:54:27 <Botje> actually, i saw a really cool system some time ago
15:54:44 <scott__> k = blah
15:54:45 <Botje> scott__: depends on what you mean by "compute"
15:54:48 <halberd> it would slow down development a lot
15:54:50 <nus> halberd, your definition of program is too vague: 300 unrelated features? is an OS a program?
15:55:00 <scott__> OK actual example
15:55:08 <halberd> well nus I am loosely describing my actual job
15:55:11 <scott__> dft12 = dft k       mag12 = fmap magnitude dft12       phase12 =fmap phase dft12
15:55:14 <Botje> .. a system that automatically merged code from upstream
15:55:15 <scott__> k is an Array
15:55:33 <Botje> scott__: uh, do you have those in a do-block?
15:55:34 <scott__> oops sory, i did that wrong
15:55:48 <Botje> scott__: put your code on hpaste, it's easier
15:55:54 <scott__> OK one second
15:57:04 <scott__> ! hpaste is down
15:57:37 <scott__> here's on pastebin
15:57:38 <scott__> http://haskell.pastebin.com/vTdRcnaF
15:57:39 <Botje> bah, some other pasting site, then
15:57:55 <scott__> i want to know if it will evaluate (dft k) once or twice
15:57:58 <Botje> scott__: uh, this is all in a giant let block, yeah?
15:58:02 <scott__> yes
15:58:15 <Botje> ah. i was confused because you said monad.
15:58:23 <Botje> truth is, it's up to the compiler
15:58:25 <scott__> oh sorry
15:58:26 <Botje> it might, it might not.
15:58:38 <Botje> it probably will.
15:58:45 <scott__> am i better off first writing z = (dft k)
15:58:45 <scott__> ?
15:58:57 <scott__> and then using z
16:00:13 <Botje> eh, keep it the way it is.
16:00:16 <Cale> If you want to ensure that z is only computed once, then yes. Also make sure that z gets a type which is not typeclass polymorphic
16:00:21 <Botje> ghc is probably smart enough.
16:00:28 <dpratt71> wow
16:01:05 <dpratt71> I'm trying to run "cabal install xyz" on Ubuntu and...bad things happen
16:01:09 <Cale> If you repeat the expression dft k in multiple places, it *will* be computed more than once.
16:01:20 <scott__> Cale, OK thanks
16:01:30 <dpratt71> I assume it's not cabal's fault that the window manager completely flakes out
16:01:30 <Botje> is GHC really that scared of CSE?
16:01:32 <scott__> I don't want to compute many fourier transforms if i dont have to
16:01:39 <Cale> GHC does almost no CSE at all
16:01:56 <Cale> It's really easy to severely damage memory performance by doing CSE carelessly
16:01:58 <Botje> is there a doc about the cases where it will do so?
16:02:00 <halberd> the trouble is, you get a program that seems reasonable, but then someone wants it to behave slightly differently in their special situation
16:02:09 <halberd> so you can add an exception to your code to satisfy them
16:02:15 <Cale> Botje: Nested case expressions which match on the exact same term
16:02:16 <halberd> that adds up over time
16:02:20 <nus> hm, -O11 perhaps will do this (-:
16:02:45 <Botje> halberd: put it in a branch, be happy :)
16:03:16 <Cale> That's the only CSE that it does, and it really only comes up as a result of other transformations internal to the compiler, since you'd normally have no cause to write things like that.
16:03:42 <gwern> I wish for a programming language where I merely need say what I want done.
16:03:48 <halberd> maintaining a zillion branches is way too expensive
16:04:07 <ezyang> gwern: Don't wish, work towards it!
16:04:15 <Cale> halberd: The solution is to not program the solution of your problem directly.
16:04:15 <dpratt71> gwern: I think we have that; you just have to be very specific
16:04:26 <gwern> ezyang: the right answer was '/me gives gwern a lollipop'
16:04:38 <Botje> ah. I found a paper "Common subexpressions are uncommon in lazy functional languages"
16:04:41 <Cale> halberd: Instead, design an embedded language as a library in which the solution to your current problem is easy.
16:04:45 <Botje> i'll go read that first :)
16:04:56 <gwern> Botje: ln pls
16:05:02 <Cale> (but the solutions to many nearby problems are also easy)
16:05:06 <Botje> http://www.springerlink.com/content/87m4m1294j472456/
16:05:12 <Botje> (yeah, it's springer *spit*)
16:05:17 * gwern was about to say
16:05:36 <Botje> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.2659&rep=rep1&type=pdf
16:05:44 <Cale> Consider something like this definition:
16:05:46 <Botje> there, free version :)
16:05:58 <gwern> more like't
16:06:07 <Cale> combinations [] = [[]]; combinations (x:xs) = combinations xs ++ map (x:) (combinations xs)
16:06:29 <Cale> This has an obvious common subexpression that if removed causes a dramatic change in memory consumption.
16:06:32 * ezyang gives gwern a caramel apple instead 
16:07:41 <Cale> (because combinations xs is going to be a very large list, and the garbage collector won't be able to start collecting any of it until it gets past the halfway point)
16:08:46 <ezyang> Suppose I have a list of maybe values, and I want to get rid of all of the Nothings. How do I do that?
16:08:54 <Botje> ezyang: catMaybe
16:09:10 <danharaj> Question: if I have List [(a,a)] and a function f : a -> a -> b, is it <*> that applies f to each element of the list?
16:09:11 <Botje> Cale: i see. the paper gives a similar example (using sum [1..1000] + prod [1..1000])
16:09:56 <Cale> ezyang: A list comprehension also works well
16:09:57 <Botje> danharaj: that would be <$>
16:10:02 <Cale> [x | Just x <- xs]
16:10:18 <Botje> uncurry f <$> list
16:10:31 <Cale> Or just use map ;)
16:10:33 <nus> Cale, well, if you transform the program at the runtime, amount of memoization could be dependent on the GC pressure
16:10:39 <Cale> map (uncurry f) xs
16:10:46 <danharaj> right dur map, what the hell was I thinking
16:10:58 <Botje> Cale: where's the fun in that :P
16:11:12 <danharaj> Sometimes when you're distracted your brain tries too hard.
16:11:28 <Botje> << bedtime
16:11:33 <Botje> up in 7 hours!
16:12:21 <scree> > concat [Just 1, Nothing, Just 2]
16:12:22 <lambdabot>   Couldn't match expected type `[a]'
16:12:23 <lambdabot>         against inferred type `Data.Mayb...
16:12:44 <scree> > Data.Foldable.concat [Just 1, Nothing, Just 2]
16:12:45 <lambdabot>   Couldn't match expected type `[a]'
16:12:45 <lambdabot>         against inferred type `Data.Mayb...
16:16:30 <monoidal> > catMaybes [Just 1, Nothing, Just 2]
16:16:32 <lambdabot>   [1,2]
16:16:35 <monoidal> scree: ^
16:18:54 <scree> monoidal: sure, I'm just sure there used to be a more general function that did that
16:19:54 <scree> maybe I'm thinking of
16:20:02 <scree> > concat $ Just [1,3]
16:20:03 <lambdabot>   Couldn't match expected type `[[a]]'
16:20:03 <lambdabot>         against inferred type `Data.Ma...
16:20:13 <scree> > Data.Foldable.concat $ Just [1,3]
16:20:14 <lambdabot>   [1,3]
16:20:25 <scree> that's probably it
16:20:48 <scree> > Data.Foldable.concat Nothing
16:20:49 <lambdabot>   []
16:23:27 <scree> (>>= Data.Foldable.toList) [Just 1, Nothing, Just 2]
16:23:35 <scree> > (>>= Data.Foldable.toList) [Just 1, Nothing, Just 2]
16:23:37 <lambdabot>   [1,2]
16:26:31 * hackagebot happstack-util 0.5.0.1 - Web framework  http://hackage.haskell.org/package/happstack-util-0.5.0.1 (JeremyShaw)
16:30:13 <ezyang> Is there an easy way to list the contents of a directory minus . and .. ?
16:30:39 <xerox> ls
16:30:39 <blackdog> ezyang: i tend to just filter them out
16:30:49 <blackdog> (i assume you mean in haskell:)
16:30:50 <xerox> ls -A
16:31:01 <ezyang> sure
16:31:09 <xerox> oops
16:31:15 <ezyang> But finding a point free form for \a -> a != "." && a != ".." is kind of obnoxious
16:31:38 <monoidal> (`notElem` [".",".."])
16:31:43 <ezyang> oh, cute
16:32:20 <fax> how do I do a search over rationals??
16:32:35 <fax> like [ ... | a <- [1..] , b <- [1..a] ] except better
16:32:53 <monoidal> http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/rationals.pdf
16:33:00 <ezyang> fax: You want a triangle search
16:33:16 <ezyang> or monoidal's link :-)
16:33:20 <fax> is there a .hs file ?
16:34:27 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
16:34:28 <lambdabot>  Defined.
16:34:33 <Cale> @let rationals = 0 : (posRationals >>= \x -> [x,-x])
16:34:34 <lambdabot>  Defined.
16:34:39 <Cale> > rationals
16:34:40 <lambdabot>   [0.0,1.0,-1.0,2.0,-2.0,0.5,-0.5,3.0,-3.0,0.3333333333333333,-0.333333333333...
16:34:45 <Cale> > rationals :: [Rational]
16:34:46 <lambdabot>   [0 % 1,1 % 1,(-1) % 1,2 % 1,(-2) % 1,1 % 2,(-1) % 2,3 % 1,(-3) % 1,1 % 3,(-...
16:34:49 <fax> COool
16:35:21 <monoidal> enumerable package has a typeclass for that
16:35:46 <fax> > head [ (a,b) | a <- rationals, b <- rationals, abs ((a*sqrt(13) + b) - (-0.4021086970770753)) < 0.001 ]
16:35:48 <lambdabot>   (0.0,-0.4029850746268656)
16:35:53 <Cale> @let pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
16:35:54 <lambdabot>  Defined.
16:35:54 <fax> damn
16:35:56 <monoidal> but rationals seem to be inefficiently coded there
16:36:01 <fax> what happened here
16:36:09 <monoidal> (http://hackage.haskell.org/package/enumerable)
16:36:12 <Cale> > map (pyth . (+1)) posRationals
16:36:13 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
16:36:37 <fax> :t realToFrac :: Rational -> Double
16:36:37 <lambdabot> Rational -> Double
16:37:00 <Cale> fax: Can't pick two elements from an infinite list naively like that
16:37:22 <Cale> fax: You'll always get the first element of the first infinite list, because the second will never be exhausted
16:37:24 <fax> > head [ (a,b::Rational) | a <- rationals, b <- rationals, abs b < abs a, abs ((realToFrac a*sqrt(13) + realToFrac b) - (-0.4021086970770753)) < 0.001 ]
16:37:27 <lambdabot>   mueval-core: Time limit exceeded
16:37:32 <fax> that is frustrating
16:37:38 <fax> I can use logic monad then
16:37:41 <Cale> You could use >>- from logict
16:38:11 <fax> > head (rationals >>- \a -> rationals >>- \b -> do guard (abs ((realToFrac a*sqrt(13) + realToFrac b) - (-0.4021086970770753)) < 0.001) ; return (a,b))
16:38:15 <lambdabot>   mueval-core: Time limit exceeded
16:38:20 <fax> hmm
16:38:28 <fax> maybe this fraction is far out
16:38:34 <Cale> Probably takes too long to find, yeah
16:38:38 <monoidal> this is lazy BFS of the Stern-Brocot tree via tying the knot?
16:38:58 <Cale> I don't know if it counts as tying any knots
16:39:34 <monoidal> let tree = [] : (tree >>= \x -> [x++"L", x++"R"])
16:39:37 <fax> im running it now
16:39:41 <monoidal> > let tree = [] : (tree >>= \x -> [x++"L", x++"R"]) in take 10 tree
16:39:43 <lambdabot>   ["","L","R","LL","LR","RL","RR","LLL","LLR","LRL"]
16:40:02 <fax> it gave 0.0,(-27) % 67 :(
16:40:06 <fax> that's not right I don't think
16:40:12 <fax> actually I know it
16:40:12 <Cale> fax: What are you looking for?
16:40:24 <Cale> A rational approximation to something?
16:40:33 <fax> I'm trying to search for rationals a,b such that a*sqrt(13)+b is close to -0.4021086970770753
16:40:44 <Cale> What is that number?
16:40:46 <fax> let z = exp (2*pi*sqrt(-1)/13::Complex Double) in 2*z^11 + z^10 + 2*z^9 + z^8 + z^5 +  2*z^4 + z^3 + 2*z^2
16:40:49 <fax> > let z = exp (2*pi*sqrt(-1)/13::Complex Double) in 2*z^11 + z^10 + 2*z^9 + z^8 + z^5 +  2*z^4 + z^3 + 2*z^2
16:40:50 <lambdabot>   (-0.4021086970770753) :+ (-1.7763568394002505e-15)
16:41:19 <fax> hm
16:41:25 <fax> I thin I am searching for the wrong one
16:41:28 <fax> > 1 - sqrt(13)
16:41:28 <lambdabot>   -2.605551275463989
16:43:06 <Cale> Where does that polynomial come from?
16:43:27 <fax> > let z = exp (2*pi*sqrt(-1)/13::Complex Double) in (sum $ map (z^) [1,12]) * (sum $ map (z^) [4,9]) * (sum $ map (z^) [3,10])
16:43:28 <lambdabot>   (-0.3027756377319949) :+ 2.1255377549457926e-16
16:43:31 <fax> it's equal to that ^
16:43:43 <fax> (z^1+z^12)*(z^4+z^9)*(z^3+z^10)
16:43:45 <edwardk>  /whois _gaffer
16:43:53 <edwardk> er woops =)
16:44:00 <fax> Cale - http://pastie.org/946001.txt
16:44:16 <fax> I split the group up this way
16:44:18 <edwardk> _gaffer = glenn?
16:44:30 <Kaidelong> Hmm, I'm starting to realize I'll probably have to do my third project in F# for GUI related reasons even as I'm getting addicted to laziness
16:44:52 <Kaidelong> I suppose F# supports that style explicitly, so it's not a huge problem
16:45:12 <Cale> fax: I guess I'm really asking what the real problem is that you're trying to solve
16:46:00 <fax> Cale, I'm trying to solve 13th root of 1
16:46:37 <Cale> Er, okay
16:46:42 <Cale> What do you mean by 'solve'?
16:46:51 <fax> write it in terms of square and cube roots
16:46:57 <fax> [(0.0,(-27) % 67)
16:47:01 <fax> ^ that's logict running :/
16:47:07 <fax> for about 5 mins or so..
16:47:40 <monoidal> you're searching for good approximation?
16:47:50 <fax> no I am searching for the exact value
16:48:03 <Cale> That's... impossible.
16:48:42 <Cale> er...
16:49:01 <helgikrs> fax: 1^(1/13) = 1 :P
16:49:09 <monoidal> minimal polynomial is x^12 + ... + 1?
16:49:19 <fax> helgikrs - well that's a good start but there are 12 remaining
16:49:31 <Cale> Let me make sure, but initially, I'm pretty sure that cos(2pi/13) can't be written like that.
16:49:32 <monoidal> ah, it's symmetric
16:49:46 <helgikrs> fax: oh, you're talking about complex roots
16:50:05 <fax> > take 5 $ (rationals >>- \a -> rationals >>- \b -> do guard (abs ((realToFrac a*sqrt(13) + realToFrac b) - ( -0.30277563773199523)) < 0.001) ; return (a,b::Rational))
16:50:06 <lambdabot>   [(0.0,(-10) % 33),(1.0,(-43) % 11),(0.0,(-13) % 43),(-1.0,109 % 33),(0.0,(-...
16:50:16 <fax> this gives some values.. but I don't think any of them are correct
16:50:39 <fax> the fun thing is .. I don't realyl have any way to check
16:50:43 <fax> well I could use CReal
16:50:54 <ezyang> I want to print an integer without a newline
16:51:00 <ezyang> What do i want?
16:51:05 <fax> putStr . show
16:51:09 <Cale> Using Double will at best give you an approximation and at worst give you complete nonsense :)
16:51:32 <ezyang> Ohhh
16:51:32 <fax> > (-0.30277563773199523, sqrt(13)+(-211/54))
16:51:33 <lambdabot>   (-0.30277563773199523,-0.3018561319434183)
16:51:35 <ezyang> ok
16:51:35 <fax> just not very close
16:51:39 <danharaj> Damn computers and their nonassociative arithmetic.
16:52:23 <Cale> one moment, brb
16:52:32 <fax> > let z = exp (2*pi*sqrt(-1)/13::Complex CReal) in (sum $ map (z^) [1,12]) * (sum $ map (z^) [4,9]) * (sum $ map (z^) [3,10])
16:52:36 <lambdabot>   mueval-core: Time limit exceeded
16:52:46 <scott__> can i not (+) and int and an integer?
16:52:55 <fax> scott_ you have to use fromIntegral on one of them
16:53:03 <scott__> thats what i thought
16:53:04 <scott__> kthx
16:53:08 <fax> I can't cabal install CReal :(
16:53:12 <ezyang> Blah, too many open files
16:54:23 <scott__> fax, does it matter which one?
16:54:31 <fax> yes
16:54:38 <scott__> Integer?
16:55:42 <Cale> cos(2 pi/13) is algebraic, but it's the root of a degree 6 polynomial
16:56:15 <Cale> -1 + 6 x + 24 x^2 - 32 x^3 - 80 x^4 + 32 x^5 + 64 x^6
16:56:50 <fax> > let x = cos (2*pi/13) in -1 + 6* x + 24* x^2 - 32* x^3 - 80* x^4 + 32* x^5 + 64* x^6
16:56:51 <lambdabot>   3.552713678800501e-15
16:56:52 <Cale> Mathematica's "ToRadicals" does nothing to the corresponding algebraic number.
16:57:16 <Cale> > let x = cos (2*pi/13) :: CReal in -1 + 6* x + 24* x^2 - 32* x^3 - 80* x^4 + 32* x^5 + 64* x^6
16:57:17 <lambdabot>   0.0
16:57:39 <twink> Cale: I think it's solvable in terms of radicals but procedures may be tricky.
16:57:53 <Cale> (note that the Show instance approximates, but the approximation is much better than Double ;)
16:58:23 <Cale> twink: I think it probably isn't. It needn't be, anyway, since the polynomial degree is high enough.
16:58:52 <Cale> Time for some Galois theory, I suppose.
16:59:34 <twink> Cale: Cyclotomic polynomials are solvable in terms of radicals etc.
16:59:42 <fax> yikes that haskell code didn't like being compiled
16:59:47 <fax> Stack space overflow: current size 8388608 bytes.
16:59:47 <fax> Use `+RTS -Ksize -RTS' to increase it.
16:59:51 <fax> the search program
16:59:54 <Cale> twink: But their real and complex parts?
17:00:10 <Cale> twink: The roots of unity are themselves radicals technically
17:00:16 <Cale> hmm
17:00:17 <fax> Cale: (z + 1/z)/2 maybe
17:00:37 <fax> like adding the conjugate and dividing by two
17:00:39 <twink> fax: That's where Cale's polynomial for cos(2*pi/13) came from.
17:01:09 <fax> http://pastie.org/946068.txt
17:01:13 <fax> this is my working so far
17:01:31 <fax> that search program was supposed (:P) to find those approximations exactly
17:01:34 <fax> but it does not do so
17:02:47 <fax> oops that c should be [1,3,4,9,10,12]
17:05:58 <fax> :D
17:06:01 <fax> http://bootes.math.uqam.ca/cgi-bin/ipcgi/lookup.pl?Submit=GO+&number=0.3027756377&lookup_type=simple
17:06:07 <fax> > 1/2*13^(1/2)-3/2
17:06:08 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:06:08 <lambdabot>    `GHC.Real.Fractional t'
17:06:08 <lambdabot> ...
17:06:19 <fax> > 1/2*sqrt(13)-3/2
17:06:19 <lambdabot>   0.30277563773199456
17:06:20 <ezyang> Apparently, the most overloaded unqualified name on Hackage is highlight, with 57 instances.
17:06:30 <ezyang> parseExpression comes in close second.
17:07:22 <fax> Plouffs inverter finds that one, but it does not find -0.40210869707 I wonder if I made a numerical mistake
17:07:27 <twink> There are supposed to be algorithms out there for generating (nontrivial) root/radical expressions for the roots of unity.
17:07:31 <codolio> Wouldn't have guessed that.
17:08:31 <ezyang> My script doesn't manage exported ... or if you failed to put an explicit exports list. I probably should fix that before publishing.
17:08:55 <fax> twink - that must bea really involved program
17:09:02 <ezyang> It also means I have a list of all the infix combinators EVAR
17:09:18 <dolio> I can believe parseExpression, I guess.
17:09:40 <twink> fax: I can't find out anything about them other than that some things claim they exist.
17:09:43 <dolio> I'm not sure what people would be writing that would prompt a 'highlight' function.
17:09:50 <ezyang> http://pastebin.com/5r3GLh0T
17:10:07 <ezyang> dolio: I can figure out what modules define that.
17:12:14 <fax> > let z = exp (2*pi*sqrt(-1)/13::Complex CReal) in 2*z^11 + z^10 + 2*z^9 + z^8 + z^5 + 2*z^4 + z^3 + 2*z^2
17:12:18 <lambdabot>   mueval-core: Time limit exceeded
17:13:54 <twink> Horner expressions for the polynomial might not hit that.
17:14:26 <fax> I wonder if [1,12] * [4,9] + [1,12] * [3,10] + [1,12] * [3,10] even is expressible... maybe it's not
17:14:54 <fax> oh for goodness sake I just realized I have [1,12] in there it should be [4,9] no wonder I couldnt get it
17:24:42 <cdsmithus> I need to make a cabal package that builds a tool, runs it against an input file to generate a Haskell source file, then builds a library including that source file... any examples I can copy from?
17:25:31 <Zao> You might want to implement a cabal preprocessor.
17:25:58 <fax> CReal takes YEARS to do anything...
17:26:58 <cdsmithus> Zao: You mean preprocess the directory before running 'cabal configure'?  Or is a preprocessor a concept from Cabal I should investigate?
17:27:23 <Zao> It's a Cabal concept.
17:27:40 <Zao> There's an awful lot of extension points in the Cabal API where you can hook in fun functionality.
17:27:45 <Zao> Check out the Cabal docs.
17:28:19 <cdsmithus> Well, I was hoping to just parrot someone who's done the same.  No such luck?
17:28:47 <Zao> I just preprocessed everything in a pre-build hook.
17:29:57 <cdsmithus> Okay, thanks... searching for Cabal preprocessor turned up some things
17:31:50 <ezyang> Outlier: http://pastebin.com/VUpD6BR0
17:31:54 <ezyang> Oh Kate :-)
17:34:46 <fax> oh dammit
17:34:56 <fax> my program that solves cubics is on hpaste
17:34:59 <fax> but I can't access it
17:35:34 <fax> hm
17:43:47 <sgillespie> hello
17:45:01 <Stalafin> if i map a function onto a list - is it possible to get back two elements? so for example, if i have a list of (a,b), i want to get back a list with (a,b) and (a,-b)
17:45:25 <fax> Stalafin that is not a list
17:45:48 <sgillespie> I get this everytime I try to do anything with cabal
17:45:54 <Stalafin> fax: [(a,b),(a,b)] is
17:46:00 <sgillespie> usr/lib/ghc-6.12.1/package.conf.d/syb-0.1.0.3-646948ebf94a3761987a9ec12f9c9b4c.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
17:46:04 <Stalafin> fax: (a,b) is an element in a list
17:46:14 <sgillespie> Anyone know what to do about this?
17:46:32 <fax> map cannot turn [(a,b),(a,b)] into [(a,b),(a,-b)]
17:46:47 <fax> you can use a monadic mapM though
17:47:01 <danharaj> Is that a list of pairs of pairs or a list with two elements?
17:47:10 <Stalafin> danharaj: list of pairs
17:47:27 <danharaj> and you want to interleave them?
17:47:34 <Stalafin> interleave?
17:48:01 <danharaj> take the original list, and alternate it with the list of (a,-b)'s to get your final list
17:48:22 <Stalafin> danharaj: well, ok... say i have a list of (a,b); depending on the value of a,i want to add an element (a,-b) to the list
17:49:42 <danharaj> Hmm, I'm not sure if the general idea of that is implemented as a function in a common library, but I can see the general structure.
17:54:50 <regalia> map (\x-> yourFunc) list
17:55:56 <regalia> Stalafin: Nevermind, that won't do it either =\
17:56:12 <Stalafin> i know :p
17:56:30 <Stalafin> anyhow... getting late here.... gonna ask tomorrow or thiink about it myself
17:59:09 <regalia> Stalafin: you could do something like yourFunc :: (a,b) -> ((a,b),(a,b)) and have the second tuple = (0,0) if the value of a wasn't what you wanted
17:59:54 <juhp> code.haskell.org is down?
18:00:39 <[swift]_> can anyone show a code example of how you might specify a custom CompOption with a regular expression library like Text.Regex.TDFA? the API confuses me
18:00:46 <Cale> fax: Okay, after a bunch of messy work, the Galois group of the minimal polynomial of cos(2 pi/13) over Q is S_6.
18:01:22 <Cale> fax: and S_6 isn't a solvable group
18:02:27 <Cale> So writing the real part of zeta_13 = exp(2 pi i / 13) in terms of radicals is impossible.
18:03:37 <fax> :(
18:03:54 <fax> I don't beleive it
18:04:08 <Cale> It's possible that I made a mistake.
18:04:13 <fax> well
18:04:23 <fax> the polynomial is 13 = 12 + 1,
18:04:31 <deech> Anyone working on a native GUI toolkit in Haskell?
18:04:33 <fax> so 2*3*2
18:04:34 <Cale> 13 is not a polynomial
18:04:46 <fax> and that means we have have to solve a quadratic, them a cubic, then a quadratic
18:04:52 <Cale> ?
18:05:31 <fax> the notation [1,2,3..] is for z^1 + z^2 + z^3 + ..
18:05:54 <fax> and if you pick the generator 2, you can divide it into subgroups
18:06:32 <fax> so I got [1,3,4,9,10,12] + [2,5,6,7,8,11] = -1 and [1,3,4,9,10,12] * [2,5,6,7,8,11] = -3 which gives (-1 + sqrt(13))/2
18:06:33 <Cale> I don't think I understand
18:06:55 <fax> [1,2,3,4,5,6,7,8,9,10,11,12] = -1 because of the roots being in a circle
18:07:18 <Cale> mm
18:07:36 <Cale> Okay, let me say what I did
18:07:53 <fax> okay
18:08:40 <[swift]_> re: specifying a CompOption, as an example of what does not work: "abc" =~ (makeRegexOpts (defaultCompOpt { multiline = False }) defaultExecOpt "a[bd]c") :: (String, String, String)
18:10:15 <Cale> First, I used mathematica to determine that cos(2pi/13) is expressible as 1/2 of a root of (-1 + 3 x + 6 x^2 - 4 x^3 - 5 x^4 + x^5 + x^6)
18:11:58 <Cale> and this polynomial is irreducible over Q
18:12:19 <fax> so it's the minimal polynomial that defines that numebr then
18:12:20 <fax> ?
18:13:30 <Cale> Yeah, in a sense.
18:14:27 <Cale> The minimal polynomial for cos(2pi/13) itself, Mathematica found to be -1 + 6 a + 24 a^2 - 32 a^3 - 80 a^4 + 32 a^5 + 64 a^6, but that's not monic, which makes life a bit more awkward later on.
18:15:32 <Cale> Really, all we need is the smallest degree field extension in which that polynomial will factor completely (the splitting field)
18:15:59 <fax> the splitting field of [1,2,3,4,5,6,7,8,9,10,11,12]
18:16:02 <Cale> oh, hmm... give me a moment to re-check something
18:16:56 <Cale> (I don't think it should change anything, but it's perhaps worth checking.)
18:18:46 <Cale> Hmm, okay, it's not a problem.
18:19:09 <fax> http://pastie.org/946117.txt
18:19:16 <Cale> So anyway, we want to work in the field Q[a]/(-1 + 3 a + 6 a^2 - 4 a^3 - 5 a^4 + a^5 + a^6)
18:19:20 <fax> that's the method from Gauss
18:19:33 <fax> and from galois theory I have a solution to the cubic
18:19:52 <fax> what's a?
18:19:54 <fax> oh sorry
18:20:00 <fax> I know what that is, I was just used it being x
18:20:18 <Cale> So we have a^6 = -(-1 + 3 a + 6 a^2 - 4 a^3 - 5 a^4 + a^5)
18:21:59 <Cale> This is a rather awkward field to work in by hand, but Mathematica can make life a good deal easier. Let's call this field F
18:21:59 <fax> how does mathematica know what polynomial defiens cosines?
18:23:02 <Cale> I'm not sure what algorithm it uses, but you could check (very tediously) using trig identities, or maybe a bit less tediously using exponentials.
18:23:16 <Cale> At least, that it is a root...
18:24:26 <Cale> I suppose you might actually start from the primitive root of unity, and use operations on some representation of algebraic numbers
18:25:00 <Cale> To take the real part, and ensure that the polynomial is of minimal degree.
18:25:03 <fax> I want to implement these numbers in haskell but I haven not got around to it yet
18:26:42 <Cale> Mathematica has a couple of ways to work with algebraic numbers. It has a representation for the complete field of algebraic numbers, where each such number is represented as a polynomial along with a numeric index that says which of the roots the object refers to (under some canonical ordering)
18:28:09 <fax> I have to ggo to bed sorry
18:28:12 <Cale> and then it has a representation for numbers in some specific algebraic number field over Q, given by a Root object (of the type described above), and then a sequence of rational coefficients for a polynomial in that specific algebraic number.
18:28:15 <Cale> anyway
18:28:27 <Cale> I was able to factor the polynomial in terms of a in the field F
18:28:30 <Cale> into linear factors
18:28:43 <fax> so that means it is a splitting field
18:28:53 <Cale> and then examine the effect that various automorphisms of that field had on the roots
18:28:59 <fax> and the degree of the extension is 6?
18:29:01 <Cale> yeah
18:29:05 <fax> I gues that makes sense because 6*2+1=13
18:29:52 <Cale> and I managed to find 3 permutations of the roots which generated all of S_6
18:30:19 <twink> Cale: You're saying the Galois group of the polynomial is not solvable, then?
18:30:22 <fax> is it S_5 or A_5 that is unsolvable (or both)?
18:30:24 <Cale> yeah
18:30:27 <Cale> both
18:30:32 <fax> did you see myf aset
18:30:33 <fax> paste
18:30:48 <fax> it's a different way but it seems plausible
18:31:55 <fax> ttyl
18:33:25 <Cale> hmm, if a polynomial of degree n has only real roots with distinct absolute values, is it possible for the Galois group of that polynomial to be anything but S_n?
18:36:01 <mmmulani> where can I find a list of flags for cabal?
18:36:07 <twink> The stuff I saw about roots of unity must've either been wrong or I misunderstood it if the 13th roots of unity don't have a solvable Galois group.
18:39:20 <twink> Cale: http://en.wikipedia.org/wiki/Root_of_unity#Cyclotomic_fields strongly suggests the Galois group shouldn't be S_6.
18:41:13 <gwern> mmmulani: cabal install --help?
18:42:53 <Cale> The 13th roots of unity are themselves radicals and have a solvable Galois group
18:43:31 <Cale> hmm
18:45:33 <twink> The cosines should be Gaussian periods of the 13th roots of unity, and so should have some subgroup of (Z/13Z)^* as the Galois group.
18:45:36 <Cale> twink: The full cyclotomic field is an extension of the field that we're talking about (our field has only real numbers in it), and so it's okay if the Galois group of that field is smaller.
18:46:10 <Cale> (isn't it?)
18:46:24 <twink> S_6 isn't smaller, it's much larger.
18:47:10 <Cale> I'm saying Gal(F_13 / Q) is smaller than Gal(F / Q), where F_13 is the cyclotomic field, and F is our field.
18:48:10 <blalb> D:
18:48:25 <Cale> blalb: what's up?
18:48:37 <twink> I think bigger fields have bigger Galois groups.
18:49:10 <blalb> so im trying to run something interpreted
18:49:15 <blalb> and getting type errors
18:49:27 <Cale> Could it be that I have completely forgotten the fundamental theorem of Galois theory? :)
18:49:29 <blalb> so i took off my type signature to see if GHC can decide the type by itself, and it can
18:49:43 <Cale> blalb: yep
18:49:46 <blalb> then i copied over GHCi's type signature
18:49:50 <blalb> and it failed again
18:49:55 <Cale> blalb: hmmm
18:50:18 <juhp> deech: native GUI for ? :)
18:51:41 <blalb> this is the function: http://pastebin.com/QNqdS38N
18:52:16 <blalb> and type signature is the one GHCi handed me :/
18:53:07 <Cale> blalb: Do you really need the polymorphism?
18:53:26 <blalb> no. but it didnt work when i said string there either
18:53:35 <Cale> What does it say?
18:53:41 <Cale> (What's the actual error message?)
18:53:50 <deech> juhp: I meant a pure Haskell GUI toolkit.
18:53:52 <deech> :)
18:53:54 <blalb> oh, never mind
18:54:07 <blalb> the first time it was capitalization
18:54:11 <Cale> ah
18:54:15 <Cale> That code doesn't look obviously wrong :)
18:54:51 <blalb> but is it reasonable of me to expect
18:55:05 <blalb> to be able to copy type signatures over like that? :o
18:56:24 <Cale> blalb: Normally
18:56:43 <Cale> blalb: It's extremely rare that you might not be able to, and often considered a bug or oversight.
18:57:37 <scott__> ive been running into problems installing wxHaskell
18:57:43 <scott__> on MacOSX
18:57:54 <scott__> ive tried cabal as well as the DMG
18:57:56 <scott__> neither works
18:57:59 <hstefan> Hey, can someone help me to find what is wrong with function arvoreEmOrdem? Code: http://codepad.org/xYZxVwfy
18:58:25 <juhp> deech: ah ok
18:58:43 <scott__> any ideas what this means:
18:58:44 <scott__> Loading package wxcore-0.12.1.4 ... <command line>: can't load .so/.DLL for: stdc++ (dlopen(libstdc++.dylib, 9): image not found)
18:58:51 * BMeph politely refraings about making a joke involving needing "moar dmg control". How restrained! ;
18:58:52 <danharaj> scot: your issue might be related to mine. I can't build wx on windows because haskell platform doesn't include a C++ compiler in the latest version.
18:58:59 <scott__> uh, exactly
18:59:03 <danharaj> Yeah.
18:59:03 <scott__> that's what it seems like
18:59:12 <scott__> WHAT do i DO!?
18:59:14 <scott__> haha
18:59:15 <danharaj> I think it is a total goof to release it like that.
18:59:32 <danharaj> And not tell people how to use their own compiler packages.
19:00:01 <scott__> We'll I'm a noob at most haskell-related things
19:00:06 <danharaj> deech: I think it would be awesome if someone wrote a gui shell in Haskell for the major platforms and we could all use that and pretend von neumann has been overthrown :p
19:00:14 <scott__> and this is my first foray with wx
19:00:28 <scott__> so I'm totally at a loss
19:00:30 <Cale> It seems a bit much to include a C++ compiler in the Haskell Platform to me :P
19:00:33 <scott__> it took forever just to get it this far
19:00:46 <danharaj> Well they include a c compiler.
19:00:51 <Cale> I suppose so.
19:00:54 <danharaj> And the used to include a C++ compiler.
19:00:57 <luite> they only had to add g++.exe
19:01:06 <luite> oh and a few dlls
19:01:07 <danharaj> and some libraries but still.
19:01:09 <scott__> danharaj, did you try a DMG or Win install or whatever
19:01:16 <danharaj> I have not what is that.
19:01:18 <Cale> I suppose :)
19:01:26 <Cale> Can't you just install GCC?
19:01:30 <danharaj> I did.
19:01:33 <Cale> hmm
19:01:40 <danharaj> I have no idea how to tell cabal to use mine instead of the platform's
19:01:58 <Cale> I don't really use Windows, so I'm not sure what you'd do.
19:02:19 <danharaj> I was thinking of just not using haskell platform and installing each piece manually.
19:02:23 <scott__> well, how about mac, Cale
19:02:25 <Cale> Maybe make sure that the gcc/g++ in your path is the right one?
19:02:54 <danharaj> I fudged around with path and include-dir flags to get it to almost work.
19:03:17 <danharaj> But I think cabal is trying to mix and match different parts of it from its stuff and my stuff.
19:03:20 <Cale> mmm
19:03:34 <danharaj> It would be nice if the platform guys said how to deal with this :|
19:03:47 <dolio> Anyone have a favorite lambda expression that they think might trip up a normalizer?
19:05:01 <Cale> dolio: Which is normalisable nonetheless?
19:05:21 <dolio> Yeah. I've tried a couple of non-normalizing ones.
19:05:28 <dolio> It loops on the usual omega.
19:05:47 <BMeph> hstefan: Hugs expects a module named "Main".
19:05:48 <dolio> And when I tell it to print and normalize y, I get \x -> x (x (x (x (x (x ...
19:05:52 <dolio> Which is amusing.
19:05:58 <Pseudonym> dolio: I could build you a lambda expression which evaluates to K if the Goldbach conjecture is false.
19:06:08 <danharaj> haha
19:06:20 <Pseudonym> It'll take a while, but it can be done.
19:06:54 <dolio> I was thinking more along the lines of trying to trick my algorithm into missing a redex.
19:07:31 <deech> This might be a pipedream but I think it would be cool if GHCI would keep the runtime from the last good compile. I don't know how often I do something that breaks a function and I need to know its type but GHCI has forgotten about it.
19:08:03 <gwern> I've wanted that
19:08:52 <deech> Or arbitrarily many versions of the runtime.
19:10:11 <BMeph> hstefan: Other than that, it looks "bom". ;)
19:10:21 <deech> Can users extend the REPL?
19:10:39 <Cale> The source of GHCi is open...
19:10:52 <danharaj> Maybe it was a pragmatic question.
19:10:57 <danharaj> Can mortals extend the REPL?
19:11:21 <deech> danharaj: Yes I meant that.
19:11:22 <blackdog> danharaj: absolutely
19:11:29 <scott__> http://comments.gmane.org/gmane.comp.lang.haskell.wxhaskell.general/923
19:11:36 <blackdog> although it might be easier to play around with HINT than with ghci source
19:11:47 <gwern> danharaj: the ghci source is kind of gnarly
19:11:47 <scott__> "Currently wxHaskell is not usable from ghci, I'm afraid."
19:11:53 <scott__> is that a joke?
19:12:07 <blackdog> danharaj: what do you want to do? there are ghci scripts that you can run
19:12:19 <gwern> scott__: no; there usually are issues-I think gtk2hs can't be used from ghci as well, or used more than once
19:12:22 <gwern> something like that
19:12:24 <danharaj> blackdog: Ah I was just joking, it was deech who original asked.
19:12:38 <scott__> YES i had problems with gtk2hs as well...
19:12:56 <deech> I was wondering if there was a way to keep multiple ghc runtimes around. The alternative solution is to have emacs haskell-mode spawn multiple REPL's.
19:13:12 <danharaj> Getting a gui to work out of a lunix environment seems as pleasant as gargling battery acid, no? :p
19:13:14 <Cale> scott__: I think the problems might stem from the fact that GHCi uses the threaded runtime, and these GUI toolkits are written in C and C++ where nobody ever expects anything to work in a setting where there are threads.
19:13:30 <scott__> OK.
19:13:31 <Cale> danharaj: wx and gtk2hs are easy to get working on linux
19:13:32 <blackdog> deech: what are you working on?
19:13:43 <blackdog> deech: i think the haskell/emacs interface could use some consolidation
19:13:47 <scott__> But this still doesn't tell me anything about: Loading package wxcore-0.12.1.4 ... <command line>: can't load .so/.DLL for: stdc++ (dlopen(libstdc++.dylib, 9): image not found)
19:13:47 <danharaj> I meant to say outside*
19:13:53 <Cale> ah
19:13:53 <blackdog> kazu yamamoto's doing some cool stuff with ghc-mod
19:13:53 <Cale> hmm
19:13:54 <scott__> oh wait
19:14:07 <blackdog> but i think about three or four people are hacking in isolation
19:14:17 <Cale> Does libstdc++.dylib exist on your system?
19:14:29 <scott__> was just looking
19:14:35 <scott__> yep
19:14:35 <deech> blackdog: just a germ of an idea. I want to have multiple runtimes because I find it inconvenient when a bad compile resets all the variables in GHCI.
19:14:42 <danharaj> Of course it does, that's the standard library :p
19:15:01 <Cale> Maybe it's not in the path that ghc is expecting
19:15:02 <blackdog> deech: so where's the emacs connection?
19:15:12 <scott__> right, so how can I tell ghc where to look
19:15:21 <danharaj> If scott has configured to work with haskell platform, then it won't look in the right place.
19:15:30 <scott__> yes, I have.
19:15:36 <Cale> Perhaps ghci -v and see if it gives any more information about where it's looking for that
19:15:36 <deech> blackdog: to have haskell-mode spawn multiple repl's.
19:16:00 <danharaj> scott, is ghc or cabal giving you the error?
19:16:23 <danharaj> Also am I the only one who thinks of the rogue AI from command and conquer when they hear 'cabal'?
19:17:20 <scott__> its ghc
19:17:27 * BMeph makes a "note to self": Okay, in C++, threads are Bad, m'kay?
19:17:49 <danharaj> until the next C++ standard at least
19:17:53 <scott__> cabal install wx
19:17:57 <scott__> worked successfully
19:18:04 <scott__> or so it appears
19:18:14 <danharaj> Are you trying to run a test file?
19:18:17 <scott__> yep
19:18:24 <Cale> Someone should write a proper widget library entirely in Haskell, so that we can use threads safely. :)
19:18:49 <danharaj> Are you volunteering? If so, you have my sword. :)
19:19:02 <dolio> And my axe.
19:19:14 <c_wraith> that was prompt
19:19:33 <danharaj> In this case, IO is mordor.
19:19:51 <c_wraith> oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
19:19:54 <pikhq> BMeph: In C++, x is bad.
19:20:12 * danharaj high fives c_wraith
19:20:13 <pikhq> Where x is any technique.
19:20:35 <danharaj> So, are C Wraiths like the Ring Wraiths?
19:20:53 <c_wraith> slightly more corporeal.
19:20:57 <c_wraith> But only slightly
19:21:09 <danharaj> And Linus Torvalds is the Witch King
19:21:13 <scott__> this is my exact error
19:21:13 <scott__> http://permalink.gmane.org/gmane.comp.lang.haskell.wxhaskell.general/904
19:21:48 <danharaj> Cale_: When exactly did you time out, because we just made an awesome string of jokes.
19:22:13 <Cale_> <danharaj> So, are C Wraiths like the Ring Wraiths?
19:22:21 <tensorpudding> C++ may not work well, but it at least tries to make a more usable language than C.
19:22:36 <danharaj> Ah, good. So, what shall we do? Will you lead us to Mt. Doom where we can destroy the IO monad once and for all?
19:22:40 <pikhq> tensorpudding: Fails at it.
19:23:32 <systemfault> It succeed at it
19:23:32 <pikhq> danharaj: Why yes. We shall form... The Fellowship of the Monad!
19:23:40 <systemfault> Woohooo!
19:24:39 <winxordie> wow, I look away for five minutes and the Fellowship of the Monad forms in my stead?
19:24:48 <tensorpudding> Except it failed at replacing C for anything meaningful, meh.
19:25:18 <BMeph> Until C++ came along, I would've happily used Icon instead. As it was, I instead rebelliously used Icon. ;)
19:25:32 <danharaj> I would be willing to work on hooking any such library into the win32 api.
19:25:51 <scott__> I JUST GOT WX TO DO SOMETHING
19:25:59 <danharaj> CRASH!?
19:26:08 <scott__> Hello world!
19:26:11 <Cale> scott__: So you solved that dynamic linking problem?
19:26:16 <scott__> actually, no
19:26:33 <scott__> i just compiled with ghc instead of ghci
19:26:39 <tensorpudding> Maybe someday someone will dare to challenge C hegemony.
19:26:41 <gwern> ah, and harrop is gollum
19:26:49 <gwern> 'no! my precious f#!'
19:27:02 <danharaj> C++ is used in places where neckbeards are not found.
19:27:12 <scott__> now, it froze my Terminal because i didn't package it or use the EnableGUI trick
19:27:16 <scott__> lets give it another go
19:27:26 <deech> gwern: awesome
19:27:38 <tensorpudding> There was that Go thing.
19:27:47 <gwern> 'be not too eager to deal out downvotes, for not evne the Wise can foresee all ends'
19:27:47 <Cale> Haha
19:27:48 <deech> tensorpudding: there still is
19:27:56 <Cale> Go was so overhyped
19:27:59 <gwern> go thing?
19:28:04 * gwern plays go
19:28:05 <danharaj> The google language.
19:28:11 <danharaj> That's supposed to make concurrency easy.
19:28:27 <tensorpudding> It's small, and it's probably better than C.
19:28:29 <Cale> It's one of the least ambitious languages I've seen in a long tim
19:28:31 <Cale> e*
19:28:32 <dolio> It clearly doesn't have the staying power of Arc.
19:28:49 <gwern> go did have a good pedigree
19:28:56 <deteego> I just had a question about defining functions in general
19:29:03 <danharaj> Why are we speaking of it in the past tense?
19:29:11 <deteego> lets say you have data A = A String Int
19:29:13 <tensorpudding> I had the idea that Go was supposed to replace C, by doing things that C made impossible
19:29:17 <scott__> (He forgot it)
19:29:19 <deteego> data B = B (String -> Int)
19:29:23 <tensorpudding> or at least, too painful
19:29:27 <Cale> If by "good pedigree" you mean a bunch of guys who are clearly stuck in the 1960's with regard to programming language design
19:29:28 <deteego> how would you do something like
19:29:30 <deteego> data C = C (String ..)
19:29:36 <deech> Have you guys seen http://www.cowlark.com/2009-11-15-go/ ?
19:29:48 <gwern> danharaj: based on how much uptake it seems to've had, it looks like it'll be google-only for the foreseable future
19:29:51 <deteego> where it would accept any function which has a string as its first argument
19:29:52 <deech> It talks about how Go is surprisingly like Algol
19:30:05 <Cale> deteego: Why would you want that?
19:30:21 <matt_m> Is there some way to convert a value of type data Void (no constructors) to another type?
19:30:24 <Cale> deteego: You could never do anything with the result of such a function, since you wouldn't know what type it had.
19:30:38 <Cale> deteego: and so applying such a function to a String parameter would be pointless
19:30:45 <deteego> well when you create the data type
19:30:53 <deteego> you know what type of function you are submitting
19:31:07 <aavogt> > let x = ?y + 2 in (let ?y = 3 in x, let ?y = 4 in x)
19:31:08 <lambdabot>   (5,6)
19:31:23 <Cale> deteego: Suppose I gave you an arbitrary value of type C
19:31:27 <danderson> I think the whole go bashing community entirely missed the point that the language is unambitious by design
19:31:31 <Cale> deteego: What could you possibly do with it?
19:31:36 <danderson> there are enough ambitious, unused languages out there :)
19:31:42 <dolio> seq it!
19:31:46 <Cale> deteego: You could pattern match  case x of C f -> ...
19:31:57 <Cale> deteego: But then f :: String -> a for some unknown type a
19:32:05 <gwern> danderson: few enough languages succeed that it's a shame if a successful one weren't ambitious
19:32:21 <Cale> and thus no operations are valid to apply to the result of f
19:32:27 <deteego> ah right
19:32:37 <dolio> There's a community built around go-bashing?
19:32:38 <danharaj> It's not just the technical side of things, you also have to cultivate a community.
19:32:46 <danharaj> Yes, it's called "The rest of us"
19:32:49 * danharaj rimshot
19:33:10 <tensorpudding> All the bashing I hear about Go is that it's lacking something people think is vital
19:33:15 <gio123> Cale: hi
19:33:20 <tensorpudding> or that it is just too much like C.
19:33:56 <danderson> gwern: you're suggesting that there is no correlation between a language's success and how familiar it feels to the existing programming population. I question that.
19:34:10 <danharaj> A language needs only a few things: Well defined design goals, strong semantics, readable syntax, and a strong standard library on the technical side, and a strong community on the other.
19:34:11 <danderson> (don't get me wrong, I'd like it to be true, I just don't see it)
19:34:19 <gwern> danderson: the more similar, the less reason for it to exist
19:35:27 <danderson> it can take existing, mature concepts from many languages, and still be interestingly different while remaining familiar.
19:35:51 <danderson> it's the languages that try to break too much exciting new ground at once that have a hard time finding success
19:36:04 <Cale> success is death
19:36:17 <aavogt> war is peach
19:36:26 <Cale> I don't see why people are so concerned about their favourite programming language being successful
19:36:28 <scott__> danharaj, ghci wont let me use wx no matter what I do
19:36:43 <matt_m> Cale: too little success is just as bad
19:36:46 <matt_m> Cale: or worse :)
19:36:46 <danharaj> scott: At least you got it to build. :\
19:36:57 <Cale> Being successful means that it has lots of users. Users which will whine and complain whenever you try to improve anything that's wrong with the language.
19:37:04 <gwern> Cale: success means more docs, more libraries, more jobs
19:37:04 <scott__> except everytime i want to test I have to package?
19:37:10 <deech> Cale: I would like Haskell to be successful so I can use it at work :)
19:37:13 <scott__> that cant be fun
19:37:23 <Cale> and so it means that it will suck exactly as much as it currently sucks forever
19:37:53 <aavogt> you can have it both ways by standardizing certain versions of the language...
19:38:26 <gwern> Cale: the pain of a library missing is much more than most misfeatures
19:38:33 * hackagebot lenses 0.1.3 - Simple Functional Lenses  http://hackage.haskell.org/package/lenses-0.1.3 (JobVranish)
19:38:46 <gwern> http not existing would cause me scads more pain than $ having wrong associativity
19:39:34 <danharaj> They should just change the associativity and make it a flag to get old behavior, if it's wrong.
19:39:48 <danharaj> 95% of users won't notice anyway.
19:40:01 <aavogt> > (+1) $ (*2) $ 3
19:40:02 <lambdabot>   7
19:40:16 <aavogt> isn't that relatively common?
19:40:21 <Cale> It shouldn't be
19:40:39 <danharaj> > (+1) . (*2) $ 3
19:40:39 <aavogt> I mean that making it infixl _will_ break code
19:40:39 <lambdabot>   7
19:40:46 <Cale> Some code, yes
19:41:07 <danharaj> That's why you make it a flag, throw a warning of deprecation, and let cabal handle the detail.
19:41:11 <pikhq> If you want to improve a language, sometime you've got to break code.
19:41:20 <pikhq> Even C does it.
19:41:29 <danharaj> Not wanting to break code is what made C++ so ugly. Then again also useful.
19:41:47 <pikhq> danharaj: C++ did break code though.
19:42:04 <scott__> GREAT SUCCESS!
19:42:05 <scott__> http://imagepaste.nullnetwork.net/viewimage.php?id=879
19:42:05 <danharaj> C++ breaks far less code than most other language revisions. They're anal about it.
19:42:12 <systemfault> Nobody would be using C++ if it wasn't for the C compatibility
19:42:15 <pikhq> That was a good chunk of the standards process. :P
19:42:21 <danharaj> scott: Congratulations :)
19:42:25 <scott__> you guys are going to be all jealous
19:42:27 <scott__> :)
19:42:29 <pikhq> systemfault: And its C compatibility is mostly nominal.
19:42:39 <pikhq> I mean, really. It's got a FFI.
19:43:01 <danharaj> The FFI is almost trivial from C++ to C
19:43:01 <scottt> :)
19:43:17 <systemfault> There's no FFI..
19:43:25 <systemfault> C++ isn't haskell.
19:43:30 <pikhq> systemfault: Yes there is.
19:43:37 <matt_m> Question:  if I use (forall a. a) it tells me I need ImpredactiveTypes and LiberalTypeSynonyms, but when I turn them on it tells me ImpredicativeTypes is deprecated
19:43:41 <pikhq> C++ does not normally have a C ABI.
19:43:57 <pikhq> You need to explicitly declare things to be C-callable.
19:44:05 <pikhq> This is, in effect, a foreign function interface.
19:44:07 <danharaj> And it's easy, and the semantics are trivial.
19:44:10 <matt_m> The question is - is there a different extension I should be using?
19:44:24 <aavogt> matt_m: did you figure out the associated type function with additional parameters (without adding those to the class)?
19:44:24 <danharaj> There's no special reasoning, except for exception handling across boundaries but that applies everywhere.
19:44:49 <pikhq> There's plenty of it.
19:44:49 <aavogt> matt_m: maybe RankNTypes?
19:44:56 <matt_m> aavogt:  I found a post from SPJ 2007 that basically ackowledges that there's no way to do it
19:45:02 <pikhq> The type systems aren't even fully compatible.
19:45:09 <matt_m> aavogt:  I have that turned on
19:45:14 <systemfault> C++ is made to call C.. not the opposite.
19:45:27 <DigitalKiwi> i do all my OO stuff in C++ and the actual important stuff in C
19:45:34 <danharaj> Right, and I'm pretty sure POD's are identical for either language in any sane implementation.
19:45:37 <DigitalKiwi> /sarcasm
19:46:22 <matt_m> aavogt: well, actually it acknowledges that you can't do something else related
19:46:23 <aavogt>   as in, could you use      forall a.  [a],  rather than   [forall a. a]
19:46:46 <matt_m> aavogt:  It's parens:  (forall a. a)
19:46:54 <matt_m> bottom type
19:48:47 <aavogt> matt_m: when does that need ImpredicativeTypes?
19:48:49 <dolio> matt_m: The alternative to ImpredicativeTypes is to make a wrapper "newtype Foo = Foo (forall a. ...)".
19:50:39 <matt_m> dolio:  Ah, makes sense - I suppose that would be fine
19:50:52 <dolio> Inconvenient, certainly.
19:51:36 <FunctorSalad> *hugs his haskell where (\y -> (\x -> (\y -> x)) y) 1 2 DWIM*
19:51:54 <dolio> They're getting rid of ImpredicativeTypes because it's overly complicated (apparently). It might be back some time later, though.
19:52:34 <danharaj> Gotta make sure the type system doesn't become crufty and bulky.
19:52:37 <FunctorSalad> (elisp avoids the capture by virtue of just dying when the x:=1 assignment goes out of scope ;))
19:53:35 <ddarius> My impression was impredicative types were added as a low-hanging hack.  It wasn't a real implementation of impredicative types.  There's not much interest in a real implementation of impredicative types because they are complicated.
19:53:39 <yuriks_> anyone ever heard of *building* a tree in post, pre, and in-order? (not traversal)
19:53:41 <matt_m> dolio:  That wasn't a deal at all:  newtype Void = Void { convertVoid :: forall a. a }, and then replaced a handful of 'id' with 'convertVoid' ... actually, makes the code clearer
19:53:47 <matt_m> thx
19:54:26 <aavogt> isn't this the same as   data Void; ?
19:54:41 <matt_m> How do you convert a data Void to another type?
19:54:58 <aavogt> with undefined
19:55:07 <matt_m> Ya, that's cheating :)
19:55:12 <ddarius> In a language like Haskell, supporting impredicative types would definitely be less "crufty," but impredicative types greatly increase the complexity of correctly implementing many aspects of a type system.
19:56:40 <ddarius> matt_m: With an empty case, but Haskell doesn't have those (surprisingly) and anyway those are equivalent to undefined in Haskell.
19:56:53 <matt_m> ya, I suppose it's not really cheating
19:57:02 <matt_m> only sorta
19:57:21 <Cale> :t case undefined of {}
19:57:22 <lambdabot> parse error on input `}'
19:57:25 <Cale> huh
19:57:44 <Cale> interesting
19:58:10 <matt_m> It's cheating in the sense of ... I could do the same with undefined if I only had an Int to work with
19:58:37 <matt_m> Anytime there's an undefined around, you have to wonder if you've introduced non-termination (or abort) right there
19:58:47 <matt_m> with (forall a. a) it's clear you haven't done that locally
19:58:58 <FunctorSalad> yuriks_: can't think of an an instance, but I'm curious how the question arised ;)
19:58:59 <dolio> From a naive perspective, not having impredicativity seems to make the type system more complex. But I've not implemented most of the features that GHC has, I guess.
19:59:32 <yuriks_> FunctorSalad: professors and their silly homework =P
19:59:55 <ddarius> dolio: I don't think anyone is saying impredicative types are complex to use.
20:00:08 <dolio> I don't mean to use. I mean to implement.
20:00:25 <FunctorSalad> yuriks_: uh, you're traversing the *idealized* tree in pre/post/inorder and filling it with actual tree? ;)
20:00:39 <dolio> Predicative systems need kinds that are unified in an impredicative system.
20:00:56 <dolio> Or something along those lines.
20:00:57 <FunctorSalad> to be fair, the tree in question is often idealized like that
20:01:07 <ddarius> dolio: I don't know what you are talking about there.
20:01:48 <yuriks_> FunctorSalad: nope, entire question is: "Define the following functions to build the type `Tree a`: a) to build the tree in pre-order (from left to right), b) to build the tree in post-order (from right to left), c) to build the tree in-order (from the center)"
20:02:49 <FunctorSalad> yuriks_: hehe I think for haskell's lazy tree you're not supposed to be able to affect that easily
20:03:35 <FunctorSalad> (how it will be built depends on the way you consume it, not the way you define the buildup)
20:03:50 <yuriks_> FunctorSalad: just found out it's extra credit, so it doesn't really matter, I can slack off ~.~
20:04:13 <aavogt> you need the seq?
20:04:22 <Cale> FunctorSalad: It's perfectly well defined if you interpret 'build' as meaning 'from a list' :)
20:04:27 <dolio> ddarius: GHC must be tracking internally whether T :: * has quantifiers internally, so that it can reject it as a valid argument to, say, Maybe :: * -> *. The easy way to do that in a pure type system is to have two different kinds, *m and *p, where *p classifies types that contain quantifiers.
20:04:36 <FunctorSalad> aavogt: one can write seq manually for trees though
20:04:47 <FunctorSalad> at least for the tree skeleton
20:04:49 <FunctorSalad> not the contents
20:04:55 <yuriks_> Cale: yeah, that's what I assumed
20:04:59 <Cale> FunctorSalad: that is, given a list xs, construct a tree whose pre/post/in-order traversal is xs
20:05:15 <RambO> Anyone can remember me the link of haskell platform?
20:05:15 <dolio> Whereas an impredicative system just has *, and doesn't bother tracking which types do and do not contain quantifiers.
20:05:20 <yuriks_> that's all still very ambiguous though =P
20:06:21 <DigitalKiwi> RambO: google can
20:06:29 <DigitalKiwi> that's probably how most of us would find it anyway ;D
20:06:37 <FunctorSalad> Cale: OK, I understood it in a way such that the abstract tree to build is the same in all cases
20:06:46 <RambO> It was a command for the bot
20:06:50 <RambO> but i don't remember :P
20:06:56 <FunctorSalad> and the "order" being the invisible order of forcing
20:07:07 <DigitalKiwi> @haskellplatform
20:07:07 <lambdabot> Unknown command, try @list
20:07:09 <DigitalKiwi> :(
20:07:15 <aavogt> @where platform
20:07:15 <lambdabot> http://hackage.haskell.org/platform/
20:08:23 <RambO> That's what i meant, thanks aavogt
20:08:45 <dolio> Of course, if GHC needs to track that anyway for other reasons, I suppose throwing away the distinction in certain cases adds more work, rather than eliminating some.
20:09:14 <Cale> yuriks_: yeah, it's still somewhat ambiguous how you split up the tail of the list into the subtrees in the recursive case
20:09:21 <FunctorSalad> yuriks_: I'd say that "in pre-order" is clearly referring to the manner of building
20:09:24 <ddarius> dolio: I believe all GHC needs to do to check that is check whether the top-level operator of a type is a quantifier.
20:09:49 <ddarius> But maybe not...
20:09:53 <dolio> Not if rank-n types are enabled, presumably.
20:10:02 <FunctorSalad> (of course Cale's interpret. could be right and the assignment badly phrased)
20:10:16 <yuriks_> I'm thinking that assignment is badly written as is
20:10:19 <matt_m> Why is  Maybe (forall a. ...) an illegal type?
20:10:29 <ddarius> matt_m: Because GHC says so.
20:10:52 <FunctorSalad> Cale: yuriks_ : but then it's talking about "building the type" with value-level functions so maybe I shouldn't overanalyze the language
20:10:54 <Cale> FunctorSalad: For example, a tree built in pre-order from [1,2,3,4,5,6,7] might look like Branch 4 (Branch 2 (Branch 1 Tip Tip) (Branch 3 Tip Tip)) (Branch 6 (Branch 5 Tip Tip) (Branch 7 Tip Tip))
20:10:59 <matt_m> ddarius:  Right, any insight as to why that's a hard case?
20:11:30 <matt_m> ddarius:  Presumably, it's not just because only slackers contribute to GHC...
20:11:33 <FunctorSalad> Cale: yes I got what you mean :) think you can use different degenerated trees for all cases
20:11:53 <yuriks_> oh, degenerate trees are probably part of the answer =P
20:12:07 <ddarius> matt_m: It makes the type system not obviously well-founded.  It is very easy to get into loops implementing it and it significantly complicates the metatheory.
20:12:20 <yuriks_> since she had an example with that in class (or so I heard, that's what I get for skipping class all the time)
20:13:12 <FunctorSalad> maybe one of the cases is just an unsafeCoerce.... ;)
20:13:26 <matt_m> ddarius: hmm, you mean you'd worry about  Maybe (Maybe (...))?   Maybe so
20:13:27 <FunctorSalad> or maybe not, a tree node is longer I suppose
20:13:33 <ddarius> matt_m: No.
20:13:34 <FunctorSalad> than a (:)
20:13:57 <ddarius> matt_m: Or I don't know what you mean there.
20:14:11 <matt_m> ddarius: type T = Maybe T
20:14:25 <matt_m> could perhaps be disguised as a forall?
20:14:27 <matt_m> I dunn
20:14:29 <matt_m> dunno
20:15:28 <aavogt> is that an infinite type?
20:16:31 <FunctorSalad> what is wellfounded about the typesystem?
20:16:44 <ddarius> matt_m: In the vein of what dolio was saying, it is sort of like adding Type : Type in a dependently typed language.  It's not as bad as that, because that axiom in a dependently typed language makes the system inconsistent while impredicativity in a polymorphic type system doesn't (by itself), it does lead you to having to consider the same kind of problem cases.
20:17:03 <RambO> Why does Haskell Platform need Open GL? (GLUT C)
20:17:22 <ddarius> RambO: Probably because the Platform -provides- HOpenGL.
20:17:49 <dolio> In fact, it can easily lead to inconsistency if you take it too far.
20:18:05 <cdsmithus> I'm preprocessing a protocol description file, and just auto-generated a data type with over 6000 constructors.  I assume that's a bad idea?  Or is it fine?
20:18:23 <luite> you need 3000 more ;)
20:18:31 <luite> sorry for that
20:18:31 <luite> :)
20:18:36 <RambO> ddarius: I've installed libglut3 and glutg3 and the intaller throws errors >.< :(
20:18:48 <dolio> An impredicative theory can have a lowest impredicative level, and be consistent, but if you add a second impredicative level above that, you can prove false.
20:19:31 <ddarius> RambO: If you are on Windows, the installer should have the correct libraries included.  If you are on Linux or similar, you should use a package which should handle pulling in the correct dependencies.
20:19:39 <FunctorSalad> if the first level quantifies over all of the second dolio?
20:19:52 <ddarius> cdsmithus: It's almost certainly not going to work well.
20:20:10 <FunctorSalad> or even if it's just that each level is impredicative for itself...
20:20:23 <dolio> FunctorSalad: I think it's the second level quantifying over higher levels that's a problem, but I'd be lying if I said I fully understood the proof.
20:20:35 <cdsmithus> ddarius: Okay... so the other option would be, I suppose, 6000 separate types, and a type class?  Would that be better?
20:20:41 <RambO> ddarius:  Im in ubuntu, just installed the packages I mentioned, done a ldconfig, and when I ./configure it says that i need GLUT C library..
20:20:42 <dolio> You can have the first level quantifying over arbitrarily high levels.
20:20:50 <ddarius> dolio: The proof should just be a term that proves a contradiction.
20:21:11 <ddarius> cdsmithus: The issue is large source files, not large data types per se.
20:21:15 <dolio> Yes, but constructing the term is quite involved.
20:21:58 <ddarius> RambO: There should be a "haskell-platform" package in Ubuntu.  All you should need to do is install that package and it should install the correct versions of everything else.
20:23:13 <RambO> ddarius: at least in Lucid there's no "haskell-platform" package, neither a package of haskell that contains a "platform" string.
20:23:22 <cdsmithus> ddarius: I just checked, and as of 10.4, there is no haskell-platform
20:23:46 <cdsmithus> But 10.4 does have GHC 6.12, from which you cna download and build the platform
20:24:00 <ddarius> There might be a Debian package and I wasn't intending that it was called exactly "haskell-platform."
20:24:02 <matt_m> dolio:  I agree with FunctorSalad, you can have impredactivity at each layer and not have a problem
20:24:10 <matt_m> at least if we're talking about general systems
20:24:23 <RambO> cdsmithus: I have downloaded the platform, and im building it. But it says I need GLUT C, so I installed libglut3 and glutg3 and it stills throw the same error.
20:24:27 <dolio> What do you mean by a problem?
20:24:31 <matt_m> inconsistency
20:24:41 <FunctorSalad> dolio was right about the lowest level at least, that's how it is in coq after all
20:24:43 <tensorpudding> There is a Debian package but it's a bit odd, since the versions of libraries in it are higher than those for the official platform.
20:24:46 <cdsmithus> RambO: Hmm, I built it that way... is this 10.4?
20:24:59 <FunctorSalad> (Prop with a var quantified over a Type is a Prop)
20:25:05 <ddarius> tensorpudding: As long as it works, that's fine.
20:25:08 <FunctorSalad> (any Type(i))
20:25:09 <RambO> Yes. Downloaded the source, tar -xvzf, ./configure..
20:25:16 <tensorpudding> Which kinda defeats the purpose of packaging it with a specific known configuration of package versions.
20:25:35 <dolio> Well, you'd be wrong. Girard's paradox was written for a type system with two impredicative levels, as I recall.
20:25:40 <nus> RambO, what's the exact error?
20:25:45 <cdsmithus> RambO, I have these packages installed: libglut3, libglut3-dev, freeglut3, and freeglut3-dev.  That was sufficient GLUT stuff to build the haskell platform on Ubuntu 10.4
20:25:49 <RambO> checking for library containing gluNewQuadric... -lGLU
20:25:50 <RambO> checking GL/glut.h usability... no
20:25:50 <RambO> checking GL/glut.h presence... no
20:25:50 <RambO> checking for GL/glut.h... no
20:25:50 <RambO> configure: error: The GLUT C library is required
20:25:58 <RambO> cdsmithus: I will try that.
20:26:08 <tensorpudding> In any case, it's only available on unstable.
20:26:26 <nus> RambO, so, where's glut.h?
20:26:52 <ddarius> Probably needs to install libglut3-dev.
20:27:00 <ddarius> or some other -dev package.
20:27:14 <RambO> Thanks, All i needed was libglut3-dev
20:27:19 <tensorpudding> If configure can't find a library, do an aptitude search for that library, and grab the -dev package
20:27:24 <scotthw> will quot and div always return the same output?
20:27:31 <FunctorSalad> tensorpudding: I just know that debian did something weird in package.conf.d recently, which made me go manual again ;)
20:27:32 <Axman6> no
20:27:34 <tensorpudding> Good general advice on Debian/Ubuntu.
20:27:42 <cdsmithus> RambO: Yeah, you always need the -dev versions of libraries to build anything that depends on them
20:27:48 <RambO> I thougt -dev was for unstable :P
20:27:55 <tensorpudding> -dev was for development headers
20:28:08 <RambO> Oh.
20:28:10 <DigitalKiwi> <3 arch for not splitting
20:28:16 <Axman6> @check \x y -> y == 0 || (x `quot` y == x `div` y)
20:28:16 <lambdabot>   "Falsifiable, after 6 tests:\n-4\n5\n"
20:28:16 <cdsmithus> RambO: Nope, in ubuntu, the lib just has the binary, and -dev has the headers and whatever other tools you need to compile against it
20:28:20 <FunctorSalad> I think it had filenames in package.conf.d which are just the package name, even with 6.12, but 6.12 uses files with that long ABI hash
20:28:28 <RambO> Im used to arch, DigitalKiwi
20:28:35 <FunctorSalad> which is a problem if you want to install anything manually
20:28:43 <FunctorSalad> probably fixed by now
20:28:52 <tensorpudding> The nice thing about splitting is that the regular packages can be smaller that way.
20:29:00 <matt_m> dolio: I'm not sure what setup you have in mind or which level you consider impredacitivty to live at
20:29:03 <RambO> cdsmithus: Yeah, I didn't bother to install it cause I tought it was in "development" or something like that :P
20:29:14 <scotthw> OK, quot is integer division truncated toward zero, while the result of div  is truncated toward negative infinity.
20:29:24 <scotthw> but for positive ints, does it matter?
20:29:37 <ddarius> scotthw: If all the inputs are positive, there is no difference.
20:29:44 <scotthw> K!
20:30:04 <cdsmithus> Okay, so my 19000 line Haskell source file that defines 6000 types builds, anyway!  I'll just hope for the best, and be cautious. :)
20:30:07 <RambO> wait, "quot" for negatives truncates to ceil?
20:31:24 <dolio> matt_m: I mean you have Star classifying types, Box classifying kinds, and Triangle classifying superkinds (which includes Box). Both types in Star and kinds in Box can quantify over any higher universe.
20:31:41 <DigitalKiwi> how much space does your ubuntu or whatever take up?
20:31:59 <matt_m> dolio:  Yes, you can have that
20:32:06 <matt_m> (and not be inconsistent)
20:32:20 <dolio> I'm pretty sure that's exactly the type system Girard used for his paradox.
20:32:46 <matt_m> dolio:  I (hopefully) have restrictions in mind that don't let Girard go through
20:32:47 <RambO> DigitalKiwi: I don't care, a lot. It sucks. But my mom knows how to use the sistem :P
20:33:21 <DigitalKiwi> i installed arch+kde on my ex-efs computer
20:33:24 <DigitalKiwi> she was able to use it
20:33:32 <DigitalKiwi> then she dumped me :(
20:33:38 <RambO> jajaja
20:33:38 <DigitalKiwi> ex-gf*
20:33:49 <DigitalKiwi> (completely unrelated to installing arch)
20:33:53 <DigitalKiwi> >.>
20:34:08 * DigitalKiwi realized that could have been taken wrong
20:34:17 <tensorpudding> my ex-fs lost all my data, then she core dumped me
20:34:28 <RambO> The thing here is that arch is in english, my mom only know spanish (Im from Argentina) and French.. So, giving her an os in english won't work :p
20:34:51 <DigitalKiwi> you can install different locales :/
20:34:53 <matt_m> dolio:  I have simple lambda terms at L0, type level things at L1, kind level thigns at L2.  You can form a type of things by quantifying over all kinds, etc.
20:35:05 <matt_m> dolio:  And L3, L4, L5, etc
20:36:16 <RambO> DigitalKiwi: I've also asked how to do that, but couldn't find much help on the forum neither on the irc chan, so, ubuntu was the fastest and simplest solution. In a few days I'll install arch again :P
20:36:33 <DigitalKiwi> http://bbs.archlinux.org/viewtopic.php?pid=747654
20:37:13 <RambO> Thats in French..
20:37:56 <DigitalKiwi> you said she knew french!
20:38:03 <RambO> Yes, SHE!
20:38:08 <RambO> but not me 
20:38:13 <DigitalKiwi> oh
20:38:22 <RambO> jaja :P
20:39:07 <nus> RambO, archlinux-es.org ?
20:40:25 <RambO> The people there were very helpfull but when I asked they couldn't help me >.<. I think that if I ask today they surely will know.. But this thing was like a year ago :p
20:41:04 <RambO> And, I had arch in my notebook, I've sold my notebook and I have to use my desktop pc :p
20:41:14 <BMeph> RambO: Definitely ask again. A year is like a decade in "Internet years"... ;)
20:43:02 <RambO> yeah, well.. In a few days I will get another pc, so I don't care using arch in english, I prefer using the os in english so I can practice the language (my first language is spanish, thats the main reason for my poor english :p)
20:43:49 <RambO> Can I ask things to the bot? Like "what is cabal?"
20:46:13 <gwern> RambO: no
20:46:28 <aavogt> @vixen what is cabal?
20:46:29 <lambdabot> let's don't talk about that
20:46:40 <gwern> RambO: you should just google that one. is 'cabal' doesn't work, a good trick is to add 'haskell' as a keyword to help google narrow it down
20:47:25 <tensorpudding> The bot doesn't have real answers, usually
20:47:52 <DigitalKiwi> @faq can haskell make real answers?
20:47:52 <lambdabot> The answer is: Yes! Haskell can do that.
20:48:32 <RambO> @faq can haskell make a rock that he can't move?
20:48:32 <lambdabot> The answer is: Yes! Haskell can do that.
20:48:47 <RambO> @faq can haskell move the last rock he created?
20:48:48 <lambdabot> The answer is: Yes! Haskell can do that.
20:48:51 <RambO> Hm.
20:49:08 <nus> @wiki cabal
20:49:09 <lambdabot> http://www.haskell.org/haskellwiki/cabal
20:54:27 <gwern> @where cabal
20:54:28 <lambdabot> http://www.haskell.org/cabal
20:54:30 <gwern> @fact cabal
20:54:31 <lambdabot> I know nothing about cabal
20:54:52 <danharaj> @where carmen sandiego
20:54:52 <lambdabot> I know nothing about carmen.
20:56:53 <DigitalKiwi> @faq can haskell find and capture carmen sandiego?
20:56:54 <lambdabot> The answer is: Yes! Haskell can do that.
20:57:19 <DigitalKiwi> if only those poor kids knew haskell
20:58:30 <deteego> for switch
20:58:42 <deteego> what is the  around the switch
20:58:44 <deteego> if its a function
20:59:26 <matt_m> What's the rule for when I need to add 'forall x y z.' to the front of a type signature?
20:59:55 <matt_m> I can't figure out why sometimes it automatically quantifies and sometimes it doesn't seem to
21:02:48 <dolio> You never need to for any Haskell 98 type. It's, in fact, not syntax.
21:04:02 <c_wraith> The only time I've needed a forall is when using the ScopedTypeVariables extension
21:04:25 <_rata_> hi haskellers :)
21:04:30 <ManateeLazyCat> matt_m: Use forall when you need it.
21:04:38 <ManateeLazyCat> _rata_: Hi, :)
21:05:01 <ManateeLazyCat> matt_m: Example, when you want use type wrap some type-class instance.
21:05:09 <_rata_> Hi ManateeLazyCat
21:05:36 <deteego> does anyone know what the  does when wrapped around functions?\
21:05:48 * ManateeLazyCat pasted "forall example" at http://paste2.org/get/811230
21:05:57 <ManateeLazyCat> matt_m: Example like above.
21:06:08 <deteego> specifically in use for something like this
21:06:10 <deteego> (sf1 &&& es) switch \e -> sf2
21:07:12 <RambO> ghci errors are quite horrible.. is there a way to make them more user friendly :P?
21:07:19 <nus> deteego, perhaps your editor fancy-rendering `switch`?
21:07:31 <ManateeLazyCat> matt_m: You have class ActionInputArgs and class ActionOutputArgs, then you can use 'forall' make "a == ActionInputsArgs instance" make "b == ActionOutputArgs instance".
21:07:36 <ManateeLazyCat> matt_m: See?
21:07:51 <ManateeLazyCat> matt_m: Of course, 'forall' can use many place, not just like above. :)
21:08:27 <ManateeLazyCat> matt_m: In most simple type, you don't need 'forall'.
21:08:54 <deteego> nus: its in a paper about yampa, they use switch
21:09:12 <nus> deteego, it's backticks
21:09:39 <deteego> nus: what do they do?
21:09:54 <nus> infix the function
21:09:59 <deteego> ah
21:10:33 <deteego> so its actually meant to be ` and not 
21:10:58 <deteego> (i.e. the key above tab)
21:12:41 <RambO> I've got a function f :: a -> a -> a, and g :: a -> a -> a, and i want to do (f.g) x y, it works?
21:12:55 <scotthw> this is kind of a big one to ask, but i need help translating some MATLAB...
21:12:55 <scotthw> http://paste2.org/p/811234
21:13:04 <scotthw> how the heck am i supposed to do this?
21:14:05 <scotthw> for lines 6 adn 7 I can do
21:14:08 <ManateeLazyCat> RambO: No.
21:14:10 <scotthw>  take n (enumFromThen 0 256)
21:14:14 <byorgey> RambO: no, that doesn't really make sense
21:14:18 <scotthw> and map (+1024) (take 5 (enumFromThen  256))
21:14:30 <scotthw> but other than that im lost
21:14:31 <byorgey> what should that mean? x and y are the inputs to g... then what are the inputs to f?
21:14:34 <RambO> I thought so. >.< I wanted to do something like (f (g x y) y)
21:14:36 <scotthw> anyone?
21:14:56 <byorgey> RambO: ok, it's best just to write it out like that =)
21:15:21 <ManateeLazyCat> RambO: If you have "f :: a -> b" and "g :: b -> c", so " (g . f) a " should be work
21:15:38 <byorgey> scotthw: what does line 9 do?
21:15:43 <byorgey> it's been a while since I've used matlab
21:15:57 <ManateeLazyCat> RambO: Because your "f" and "g" need two arguments, so just simple "(f . g) x y" can't work
21:16:11 <Zao> scotthw: What about it is it that you do not grok?
21:16:22 <Zao> scotthw: : as an index selects the whole dimension.
21:16:24 <RambO> ManateeLazyCat: I know, I just wanted to make the code more readable than f (g x y) y
21:16:25 <ManateeLazyCat> RambO: Best practice is do it in ghci
21:16:51 <scotthw> what do you mean?
21:16:55 <Zao> : between two quantities means range.
21:16:59 <Zao> Like the Haskell ..
21:17:11 <byorgey> Zao: I think scotthw knows this, it's me that needs the explanation =)
21:17:25 <scotthw> uh, im no MATLAB expert
21:17:27 <Zao> byorgey: See above then :D
21:17:31 <byorgey> thanks =)
21:17:34 <scotthw> in fact, I'd never used it before today
21:17:53 <ManateeLazyCat> RambO: "let z = g x y" ==> "f z y" ?
21:17:54 <byorgey> oh, I see, I misunderstood the question
21:18:10 <scotthw> Zao: is this easy and I just dont understand?
21:18:17 <byorgey> scotthw: well, looks like line 9 is building up the vectorFrames matrix one row at a time
21:18:28 <byorgey> so you should build it up all at once with a map
21:18:38 <RambO> hmm... I think i let it just like it is :P
21:18:44 <byorgey> map a function over the indices [1..numberSlices] which generates each row, given the index
21:18:59 <scotthw> uhh
21:19:00 <Zao> So line 9 assigns to the whole index'th row the values from the vector x, from indexTimeStart to indexTimeEnd.
21:19:03 <byorgey> that function will be the translation of lines 6 and 7
21:19:40 <byorgey> just compute indexTimeStart and indexTimeEnd from the index, then use drop and take to pick out the part of vector x that you want
21:19:57 <RambO> Im doing a function like.. "parse".. it is something like parse :: [a] -> a -> [[a]] but i cant make it work like i want >.<
21:20:32 <Zao> From the looks of it, it just takes the vector and maps it into a matrix, row-wise.
21:21:01 <Zao> Oh wait, hop and windowSize are different variables.
21:21:01 <scotthw> so the first line just builds a 2D matrix
21:21:11 <scotthw> whatever, they can actually be constants
21:21:15 <Zao> zeros generates a matrix of provided dimensions full of zeroes, yes.
21:21:24 <scotthw> yes
21:21:34 <Zao> I recommend playing around with the MatLAB interpreter to get a feel for the language and what things do.
21:21:38 <DigitalKiwi> hrm
21:21:39 <Zao> Not to mention 'help' :D
21:21:46 <scotthw> Ive been doing that...
21:21:54 <byorgey> scotthw: something like this perhaps? http://paste2.org/p/811249
21:22:45 <ezyang> I have a hs file on my system that compiles fine. I want to make a build-depends file, but don't remember what packages all the modules come from. Is there an easy way to figure this out?
21:22:47 <DigitalKiwi> learn you a haskell, real world haskell, or haskell for c programmers, which has the best time to knowledge acquired ratio?
21:22:59 <scotthw> byorgey: OK let me take a look
21:23:12 <ManateeLazyCat> DigitalKiwi: RWH
21:23:44 <DigitalKiwi> i hate books that are like 900 pages that could be like < half that and teach the same thing <.<
21:23:51 <DigitalKiwi> is RWH like that? >.>
21:23:55 <byorgey> ezyang: if you make a cabal file with no build-depends and try to build it using cabal, I think it will yell at you for each missing package, and suggest the package you need to add
21:24:01 <ezyang> Cool!
21:24:03 <byorgey> but there's no easier way that I know of
21:24:18 <byorgey> I ought to build this into cabal init
21:24:19 <scotthw> so the take takes one of those frames (end-start locations)
21:24:24 <scotthw> what does drop do here?
21:24:51 <RambO> If someone wants to help me -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25328#a25328
21:25:05 <byorgey> scotthw: drop gets rid of the initial part of the x vector that you don't want
21:25:13 <ManateeLazyCat> DigitalKiwi: Haskell Wikibook?
21:25:32 <byorgey> i.e. if you had  1 2 3 4 5 6 7 8 9 10  and wanted the part from 5-7 you need to first drop 4 and then take 3
21:25:33 <ezyang> Also, what are best practices for picking out version constraints on packages?
21:25:39 <scotthw> hmm
21:25:43 <scotthw> wow this is kind of cool
21:25:50 <ManateeLazyCat> http://en.wikibooks.org/wiki/Haskell
21:25:50 <scotthw> just tough to wrap my head around
21:25:57 <ManateeLazyCat> DigitalKiwi: http://en.wikibooks.org/wiki/Haskell
21:26:00 <byorgey> scotthw: yes, it will come with practice =)
21:26:15 <DigitalKiwi> hehe, already there ;D
21:26:18 <scotthw> so yeah, I think I understand
21:26:20 <DigitalKiwi> is it a good site?
21:26:22 <ManateeLazyCat> DigitalKiwi: Wikibook split knowledge with many little entry.
21:26:26 <scotthw> I'll try your function out
21:26:40 <byorgey> ezyang: as a start, use the version you have as a lower bound, and use the PVP to decide what the upper bound should be
21:26:44 <ManateeLazyCat> DigitalKiwi: If you have understand one entry, just skip it. :)
21:27:04 <byorgey> ezyang: if you want to get more fancy you can also try testing your package with older versions of things to see if you actually depend on any new features
21:27:20 <ezyang> "Someone should automate that!"
21:27:21 <ManateeLazyCat> DigitalKiwi: Yep, it's a first site i read when i was haskell newbie.
21:27:35 <matt_m> ManateeLazyCat:  Was away, thanks for the answer - looking now
21:27:37 <byorgey> ok, I'm off to bed! night all
21:27:51 <RambO> *opening the link*
21:28:28 <DigitalKiwi> hmm i have looked at this before i think
21:28:37 <scotthw> btw byorgey you are a lifesaver if this works
21:28:43 * ManateeLazyCat Lunch time, brb.
21:28:43 <scotthw> actually you are either way
21:29:09 <matt_m> ManateeLazyCat:  If I have a top level declaration:    foo :: Foo x y => Blah x -> Blorg y -> ()
21:29:23 <matt_m> Sometimes it seems to quantify over x,y, and sometimes not
21:29:55 <ezyang> Things will be so awesome when the PVP checker starts existing :-)
21:30:00 <deteego> has anyone here used yampa?
21:30:02 <matt_m> If I get errors, I sprinkle 'forall's around like pixie dust, and sometimes they go away
21:31:07 <matt_m> I'd have thought the rule would be that you need quantifiers if your variables bind tighter than statement level
21:31:33 <matt_m> ie.  (forall x. x -> Foo x) -> Foo Int  needs quantifiers there
21:31:58 <matt_m> but sometimes I seem to need quantifiers in other situations too
21:32:11 <matt_m> if I don't add a statement level quantifier, it's not happy
21:32:28 <matt_m> afk
21:34:50 <dolio> Higher-rank types require quantifiers, because all unquantified variables are assumed to be quantified outermost.
21:35:15 <dolio> a -> b is forall a b. a -> b.
21:36:30 <scotthw> hey byorgey are you still here?
21:43:11 <hydo> Is there a better way to use the values of more than one lookup (which are :: Maybe a) than saying putting them through nested case statements?  'lookup x y >>= \z -> lookup a b ...' came to mind but that just doesnt' feel right.  "There's got to be a better way!"
21:43:46 <hydo> or the values of anything of the sort.  I just have, in particular, a lot of lookups spread around my code.
21:44:37 <hydo> Maybe I need to re-read the lyah and rwh sections on general monad usage again...
21:46:13 <dolio> Does the second call depend on the first? Or you just want both results?
21:46:41 <dolio> :t \x y z w -> (,) <$> lookup x y <*> lookup z w
21:46:42 <lambdabot> forall a a1 a2 a3. (Eq a2, Eq a3) => a2 -> [(a2, a)] -> a3 -> [(a3, a1)] -> Maybe (a, a1)
21:47:12 * hackagebot Semigroup 0.0.3 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.3 (TonyMorris)
21:47:13 <hydo> In the end, I usually need to do something with the values, assuming that all of the calls returned Just a
21:47:33 <hydo> (,) <$> ... well, hello there.
21:50:30 <hydo> thanks for the pointer, dolio!
21:50:39 * hydo reads about Control.Applicative.
21:55:14 * hackagebot NonEmptyList 0.0.8 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.8 (TonyMorris)
21:56:21 <tensorpudding> hmm, a list that can't be empty...
21:56:48 <RambO> Can someone help me doing a "divide" function?
21:57:42 <ManateeLazyCat> RambO: Just paste it, if some kind guy have time, he will help you. :)
21:58:09 <tensorpudding> Divide which works on integers?
21:58:33 <RambO> Not, divide the way.. divide "hola" 'o' = ["h", "la"]
21:59:11 <tensorpudding> oh
21:59:20 <RambO> My first attemp was something like this, that works almost fine. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25328#a25328
21:59:30 <tensorpudding> something like Data.List.break?
21:59:31 <RambO> But now I have a much complex code that I think it sucks.
21:59:50 <RambO> @src Data.List.break
21:59:51 <lambdabot> Source not found. It can only be attributed to human error.
21:59:55 <RambO> :(
22:00:00 <tensorpudding> you don't need to qualify it
22:00:02 <tensorpudding> @src break
22:00:03 <lambdabot> break p =  span (not . p)
22:00:12 <tomberek> Ramb0: splitAt or somthing
22:00:22 <RambO> Although I have to code it from scratch :P
22:00:38 <tomberek> oh, a homework assignment?
22:00:50 <tensorpudding> splitAt requires an index
22:00:56 <tensorpudding> break is more similar to what you want
22:01:27 <tensorpudding> > break (== 'o') "hola"
22:01:28 <lambdabot>   ("h","ola")
22:01:30 <RambO> Something like that, It's not a homework because I've solved the exercise in other way, but it would be very helpfull to write my own version of the function that I need.
22:01:39 <tomberek> @t break
22:01:39 <tomberek> @type break
22:01:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:01:40 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:01:56 <tensorpudding> you can finnegle the output of break to be right
22:02:15 <tomberek> yeah, break looks good
22:02:19 <RambO> almost, I need to remove the o.. divide [2,2] 2 would be something like.. [ [], [], [] ]
22:02:38 <RambO> and divide [2] 2 would be [ [], [] ]
22:03:07 <RambO> > break (== ' ') " "
22:03:09 <lambdabot>   (""," ")
22:03:28 <RambO> > break (== ' ') "  "
22:03:30 <lambdabot>   ("","  ")
22:03:37 <tensorpudding> you'll probably not want to use break if you're going to want to return that on [2,2]
22:03:59 <tensorpudding> maybe a fold or something
22:04:08 <alexsuraci> you could just accumulate the first element and continue with the tail of the second I think
22:04:18 <BMeph> > let ~(xs,y:ys) = break (== 'o') "hola" in [xs,ys]
22:04:19 <lambdabot>   ["h","la"]
22:04:29 <tensorpudding> you could force break to work but I'd guess it'd be easier to not bother with break at that point
22:04:32 <BMeph> > let ~(xs,y:ys) = break (== 'a') "hola" in [xs,ys]
22:04:33 <lambdabot>   ["hol",""]
22:04:48 <RambO> BMeph:  that sounds good.
22:05:01 <RambO> I thought a recursive version as you can see : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25328#a25328
22:05:23 <tensorpudding> since you want it to continue to break the remainder
22:06:55 <BMeph> @src span
22:06:55 <lambdabot> Source not found. You type like i drive.
22:07:22 <BMeph> Boo, l-bot! Boo!
22:07:51 <hydo> dolio: double thanks.  I now have to refactor about half of my code, but on the plus side, I 'get' it.  Well, at least I think I do.
22:08:11 <dolio> Have fun. :)
22:09:53 <BMeph> "Say, l-bot, what's 'break' do?" "Well, 'break p' is the same as 'span (not . p)'." "Okay, that works. So how does 'span' work?" "Huh, what are you talking about?"  :|
22:10:09 <tensorpudding> span isn't exported maybe
22:10:48 <tensorpudding> it might avoid keeping source to things which aren't exported since there could be name conflicts across modules
22:10:56 <cads> A good representation of a chess game state for a chess engine must implement a way of storing the positions of at most 32 pieces, and it needs to do this in a space saving way for building a game tree.
22:11:11 <tensorpudding> Except I lie, span is exported
22:11:19 <tensorpudding> @type span
22:11:20 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:11:37 <cads> Other data like pieces that are attacking/attacked is probably useful for computations, and a few binary flags need to be kept for en-passant and castling, as well as a counter for the 50 move rule, and a way to tell whether the game has been in the same state three times.
22:12:02 <cads> Have you guys read any clever papers on functional approaches to a chess game?
22:12:05 <Makoryu> tensorpudding: The sources are manually collated
22:12:10 <BMeph> hydo: Another thing you may want to look at, if you're feeling adventurous, are "View Patterns".  View Patterns. Stops time. Tell your friends. ;)
22:12:17 <tensorpudding> span _ xs@[]            =  (xs, xs)
22:12:18 <tensorpudding> span p xs@(x:xs')
22:12:18 <tensorpudding>          | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
22:12:18 <tensorpudding>          | otherwise    =  ([],xs)
22:12:23 <tensorpudding> oops
22:13:56 <BMeph> tensorpudding: Thanks for the 'try'. I was just pointing out a glaring corner case, but I appreciate the knowledge. Even with the multi-line message...;)
22:14:12 <tensorpudding> i was going to format it so that it was nicer looking
22:15:04 <blackdog> cads: there are a heap of game tree papers, i suppose, but i think a lot of the chess program literature is more about sneaky tricks:)
22:15:18 <blackdog> ie, clever ways of storing the open book, and checkmate tables for the endgame
22:15:43 <blackdog> rec.games.computer.chess had a lot of stuff about the design of Crafty, for instance
22:16:08 * BMeph is going to decorate his apartment with checkmate end tables!
22:17:12 <BMeph> Say, speaking of clever ways to store game info, does anyone have, or knowa source of Bill Gosper's Hashlife paper?
22:19:21 <hydo> BMeph: Talking to Google about it now.  Thanks for the tip - I'm always feeling adventurous!
22:19:51 <cads> bmeph, "Exploiting regularities in large cellular spaces"
22:19:54 <cads> ?
22:21:56 <hydo> BMeph: oh holy crap that's nice!  Thank you!
22:22:31 <BMeph> hydo: I thought you'd appreciate it. Use your power Wisely... ;)
22:22:54 <BMeph> cads: That sounds like it, yes. Got a lead? :)
22:24:10 <RambO> @where hunit
22:24:10 <lambdabot> http://hunit.sourceforge.net/
22:25:11 <cads> BMeph: haven't found the paper for free :)
22:26:08 <RambO> tensorpudding: thats de def of span?
22:26:16 <tensorpudding> Yeah.
22:26:28 <tensorpudding> It's available in http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/GHC-List.html#span
22:27:24 <RambO> I have done it, in a recursive way, it reaaaalllly sucks. If you want to look at it.. -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25329#a25329  please don't ban me from the channel :(
22:39:17 <mackid> question, i'm trying to use list comprehension on an infinite list (primes) and I'm not sure how to get it to stop giving me elements... here's my code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25330#a25330
22:39:43 <ulfdoz> just don't consume them.
22:40:59 <mackid> how do i determine that? really, I want to be able to say... grab all the elements from here i.e. [p | p <- primes'] but only give me x of them, once I've gotten that many, you're done
22:41:09 <ulfdoz> what's the implementation of primes'?
22:41:10 <Cale> mackid: Or, you can use the take function
22:41:13 <Cale> take 10 primes
22:41:21 <tensorpudding> RambO: Does it load?
22:41:29 <mackid> ooh, Cale, would that work? let me try that
22:41:32 <Cale> takeWhile (<= a) primes
22:41:36 <Cale> is what you want
22:41:50 <Cale> The list comprehension doesn't know that the list of primes is monotone increasing
22:41:52 <RambO> tensorpudding: yes, it works perfectly fine
22:42:07 <Cale> So it keeps looking for another prime which is <= a, and doesn't find one
22:42:33 <mackid> Cale: right, that's the problem. ok. I actually just want the first a primes, so it seems like I could probably do take a primes', i'll try it..
22:42:40 <Cale> yeah
22:42:52 <tensorpudding> It may work, but it has a few issues.
22:43:12 <mackid> oh, no, i was wrong, I actually want what you said. takeWhile just puts a condition on taking?
22:43:25 <ulfdoz> mackid: yes
22:43:31 <mackid> sweet
22:43:34 <tensorpudding> Pretty sure that most of the functions could be replaced with simpler ones
22:43:47 <Cale> mackid: Yeah, it keeps taking elements of the list as long as the condition is satisfied
22:44:07 <mackid> that's exactly what I want. thanks a lot, it works!
22:44:13 <mackid> haskell does everything!! haha
22:44:17 <RambO> I think I fell in the problem which I've mentioned before.. Now I must do         g (reverse (f (reverse  (f x y)) y)) y                  is there a way to simplify that?  f :: [a] -> a -> [a], g :: [a] -> a -> [a]
22:44:34 <tensorpudding> calling reverse twice sounds very fishy
22:45:21 <Cale> RambO: What are you trying to compute?
22:45:57 <RambO> I need it. I need to apply a function to a list that do something with the first elements.. I need to do it with the lasts too.. So i reverse the list, apply the function, and reverse again the list.
22:46:02 <tensorpudding> I would suggest learning some of the higher-order functions, like map, filter, and foldr
22:46:15 <RambO> I can't use higher order functions >.<
22:46:27 <dignan> why does haskell need to have two exponentiation operators?
22:46:34 <Cale> dignan: three
22:46:40 <dignan> whats the third
22:46:45 <RambO> properly saying: Im not allowed to.
22:46:47 <dignan> I know ** ^
22:46:49 <Cale> (^) works with any type of number as the base, and positive integer exponents only
22:46:59 <Cale> er, non-negative, sorry
22:46:59 <dignan> yeah I read that much
22:47:06 <dignan> oh, but not about positive.
22:47:10 <Cale> (^^) works with fractional bases, and arbitrary integer exponents
22:47:10 <pikhq> RambO: Well, there goes half the point of *functional programming*. :)
22:47:24 <Cale> (**) works with floating point bases and floating point exponents
22:47:28 <tensorpudding> The higher-order functions are very powerful.
22:47:39 <Cale> They come from three separate definitions of exponentiation from mathematics.
22:47:42 <tensorpudding> Many of the simpler functions are built from them, like reverse.
22:47:50 <RambO> I know. I like them. But im supposed to do all the things in the "recursive way"
22:48:07 <tensorpudding> Cale: which one uses the one that works on arbitrary reals?
22:48:08 <pikhq> Eeew.
22:48:20 <Cale> tensorpudding: (**)
22:48:37 <tensorpudding> @type (**)
22:48:38 <lambdabot> forall a. (Floating a) => a -> a -> a
22:49:04 <Cale> x ** y for non-negative x is exp (log x * y)
22:49:10 <Cale> er, tsk
22:49:17 <Cale> This time I really do mean positive x :)
22:49:18 <dignan> Cale: thanks for the tutorial, i just started reading Real World haskell
22:49:18 <tensorpudding> > (1.5 :+ 3.25) ** (0.0 :+ 9.25)
22:49:19 <lambdabot>   1.9170142260373618e-5 :+ (-1.8613702349373166e-5)
22:49:29 <tensorpudding> ah, so it does work
22:49:30 <Cale> ah, and for nonzero complex numbers
22:49:34 <RambO> So, if I want to remove all the characters 'x' from the head of a list, and from the end, i do:               reverse(f  (reverse (f xs 'x')) 'x')
22:49:48 <tensorpudding> Well, you need to place the branch cut for the complex log somewhere
22:49:53 <RambO> >1/2 ^^ 5
22:50:02 <RambO> :(
22:50:03 <Cale> RambO: Define  bothEnds f = f . reverse . f . reverse
22:50:11 <tensorpudding> > (-5.0 :+ 0.0) ** (3.0 :+ 9.25)
22:50:12 <lambdabot>   Precedence parsing error
22:50:12 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
22:50:21 <tensorpudding> > ((-5.0) :+ 0.0) ** (3.0 :+ 9.25)
22:50:22 <pikhq> Cale: "No higher order functions"
22:50:22 <lambdabot>   2.041951209469404e-11 :+ (-2.191296110311819e-11)
22:50:23 <Cale> RambO: and change the order of the parameters on your f
22:50:41 <tensorpudding> Hmm, so it's even defined on the negative reals.
22:50:48 <Cale> then you'd be able to write  bothEnds (f 'x') xs
22:50:50 <RambO> Cale: but my function takes two arguments.. >.<
22:50:53 <tensorpudding> Wonder which argument for the complex log it's using
22:50:57 <RambO> Oh.
22:51:16 <tensorpudding> though
22:51:21 <pikhq> Of course, one can simply go ahead and write it with the higher-order function and then inline it, getting the same effect. :P
22:51:26 <tensorpudding> > (-1.0) ** (-1.0)
22:51:27 <lambdabot>   -1.0
22:51:34 <tensorpudding> err wait
22:51:34 <Cale> tensorpudding: I think the cut is along the negative real axis
22:51:56 <tensorpudding> But it accepts negative reals, the complex log shouldn't be defined for them
22:52:25 <Cale> Nah, it can be, it'll just be discontinuous there
22:52:43 <Cale> > log (-1) :: Complex Double
22:52:44 <lambdabot>   0.0 :+ (-3.141592653589793)
22:52:45 <tensorpudding> It'll return different values depending on which branch they decide to use.
22:52:50 <tensorpudding> since the argument could be i or -i
22:52:53 <Cale> > log (-1 :+ 0.001) :: Complex Double
22:52:54 <lambdabot>   Precedence parsing error
22:52:54 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
22:52:58 <tensorpudding> Ah, so they went -i.
22:52:59 <Cale> > log ((-1) :+ 0.001) :: Complex Double
22:53:00 <lambdabot>   4.999997500588806e-7 :+ 3.140592653923126
22:53:06 <Cale> > log ((-1) :+ (-0.001)) :: Complex Double
22:53:07 <lambdabot>   4.999997500588806e-7 :+ (-3.140592653923126)
22:53:12 <Cale> see?
22:53:32 <tensorpudding> Yes, it has a jump due to branch switching.
22:53:49 <tensorpudding> Rather, it has a jump due to crossing a branch cut
22:53:53 <Cale> right
22:54:11 <tensorpudding> It's best not to trust its values there though.
22:54:30 <Cale> It should converge nicely regardless, I think
22:54:42 <tensorpudding> Is the choice of -i at all standard?
22:54:47 <Cale> Somewhat.
22:55:39 <Cale> Well, either i pi or -i pi
22:55:47 <Cale> The other choices are less natural :)
22:55:54 * ddarius chooses 18!i pi
22:56:29 <tensorpudding> A quick jaunt on emacs calc-mode suggests that it uses the opposite convention.
22:56:55 <Cale> ddarius: (18! + 1) i pi, you mean ;)
22:57:31 <tensorpudding> W|A suggests the same.
22:58:09 * ddarius considers a nice representation for values on the appropriate Riemann surface.
22:59:53 <tensorpudding> Sage seems to use the i convention also.
23:00:09 <tensorpudding> Is Haskell using GMP for calculating it?
23:00:39 <ddarius> @src Complex log
23:00:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:01:21 <tensorpudding> @src (**)
23:01:21 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:01:43 <Cale> Oh, btw, davidL asked me a question earlier, and I thought perhaps someone here might know the answer. Apparently if you have a set of N boolean statements, and an oracle for SAT, you can determine the number of statements which are satisfiable using only O(log(N)) queries to the oracle. I determined a way to do this, except that the queries are exponentially large. Is there a way to do it so that the work that your Tu
23:01:43 <Cale> ring machine has to do is polynomial time?
23:02:32 <RambO> Hey Cale, thanks for the help. It was very usefull.
23:02:38 <Cale> RambO: no problem
23:03:01 <Cale> RambO: That's a higher order function, but not a recursive one, so I guess it's not cheating ;)
23:03:47 <RambO> With full higher order functions, how would you do that?
23:04:25 <Cale> RambO: Well, in this case, not much different. I would use dropWhile (=='x')
23:04:38 <Cale> (for the function that I apply to both ends)
23:04:54 <dignan> So enumeration .. is pretty cool and can figure out odds, evens, multiples, etc. anything else cool it does?
23:05:22 <Axman6> eh?
23:05:37 <RambO> dropWhile helps a lot. :P
23:06:35 <Cale> dignan: 'enumeration'?
23:06:53 <dignan> List comprehension I guess?
23:06:56 <Cale> ah
23:07:36 <dignan> specifically the .. operator inside of them
23:07:50 <Cale> Oh, I see, yeah, that's something else
23:08:28 <Cale> If you have a datatype which is an instance of Enum, then you can use that syntax
23:08:50 <Cale> data Colour = Red | Orange | Yellow | Green | Blue | Violet
23:08:51 <dignan> Ah  ok
23:08:58 <Cale> [Orange .. Blue]
23:09:09 <Cale> Will give [Orange, Yellow, Green, Blue]
23:09:25 <Cale> ah, you'll need  deriving (Show, Enum)  though
23:09:41 <Cale> (and might as well throw in Eq and Ord while you're at it)
23:09:44 <dignan> so haskell has some built in enumeration of the real numbers etc?
23:09:55 <Cale> mm... of real numbers?
23:10:13 <dignan> well, at least integer and rational
23:10:17 <Cale> ah, yeah
23:10:27 <Cale> The enumeration syntax works for floating point numbers, though it takes unit steps
23:10:42 <Cale> (rather than enumerating all possible floats, which is usually not what you want)
23:10:44 <dignan> i tried [1.3,1.5..2.9] and got interesting results
23:10:58 <Cale> ah, and yeah, there are some awkward things about the boundaries
23:11:07 <Cale> (maybe considered bugs in the standard)
23:11:19 <Cale> > [1.3,1.5..2.9]
23:11:20 <lambdabot>   [1.3,1.5,1.7,1.9,2.0999999999999996,2.2999999999999994,2.499999999999999,2....
23:11:25 <Cale> > last [1.3,1.5..2.9]
23:11:25 <lambdabot>   2.8999999999999986
23:11:36 <Cale> Ah, this isn't one of the really awkward cases.
23:12:04 <dignan> that looks like typical floating point IEEE quality to me
23:12:06 <dignan> ;D
23:12:09 <Cale> yeah
23:12:51 <Cale> @check \x y z -> last [x,y..z] <= (z :: Double)
23:12:51 <dignan> I'll try using some logarithms with it
23:12:55 <lambdabot>   mueval-core: Time limit exceeded
23:13:05 <Cale> oh, heh, right
23:14:22 <Cale> @check \x y z -> not (x < y && y < z && abs (z / (y - x)) < 10) || last [x,y..z] <= (z :: Double)
23:14:23 <lambdabot>   "Falsifiable, after 46 tests:\n0.9230769230769231\n3.6923076923076925\n6.0\n"
23:14:34 <dignan> haskell knows more about math than I do
23:14:38 <Cale> [0.92, 3.69 .. 6.0]
23:14:39 <Cale> > [0.92, 3.69 .. 6.0]
23:14:41 <lambdabot>   [0.92,3.69,6.46]
23:14:41 <dignan> I am going to have to read some math books to catch u p to it
23:14:44 <Cale> ^^ fail
23:15:11 <dignan> yeah that is kinda fail
23:15:16 <RambO> Cale: Check uses quickCheck or what?
23:15:20 <Cale> I think that's a bug in the standard. [x,y..z] should never contain an element any larger than z
23:15:28 <Cale> RambO: yeah, QuickCheck
23:15:55 <RambO> is there a way of  using map (\x -> (f x, g x))  without using lambda?
23:16:24 <RambO> something like map (f &&& g) ?
23:16:30 * dignan is using his work office after hours to exploit his employer's safari account and learn haskell.
23:16:30 <tensorpudding> (&&&) will do that
23:16:40 <tensorpudding> @type (&&&)
23:16:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
23:16:53 <baguasquirrel> this is much better:
23:16:54 <baguasquirrel> [1/5, 2/5..1] :: [Rational]
23:17:02 <baguasquirrel> > [1/5, 2/5..1] :: [Rational]
23:17:03 <lambdabot>   [1 % 5,2 % 5,3 % 5,4 % 5,1 % 1]
23:17:05 <tensorpudding> Don't mind the Arrow's, just replace a b c with b -> c
23:18:16 <RambO> map (length &&& sum)  throws "not in scope" :(
23:19:34 <ddarius> A "not in scope" error is not an exception.
23:19:38 <siracusa> RambO: You have to import Control.Arrow
23:20:30 <RambO> siracusa: I wish i could :P Im not allowed to. :(
23:20:36 <RambO> Well.. lambda expression will be
23:23:42 <RambO> @src maximum
23:23:43 <lambdabot> maximum [] = undefined
23:23:43 <lambdabot> maximum xs = foldl1 max xs
23:23:55 <RambO> @src max
23:23:56 <lambdabot> max x y = if x <= y then y else x
23:24:06 <RambO> @src (<=)
23:24:06 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
23:24:31 <RambO> Why maximum of a duple works?
23:25:50 <siracusa> duple = (a,b)?
23:25:54 <RambO> Yes
23:26:56 <siracusa> Because there's an instance of Ord (a,b), where a and b are also an instance of Ord.
23:27:28 <RambO> So, >= for tuples evaluates the fst(x) and then snd(x) ?
23:28:00 <olsner> > (2,1) > (1,1)
23:28:02 <lambdabot>   True
23:28:09 <olsner> > (2,1) > (1,2)
23:28:10 <lambdabot>   True
23:28:34 <RambO> > (2,1) > (2,1)
23:28:35 <lambdabot>   False
23:28:39 <RambO> > (2,1) > (2,0)
23:28:40 <lambdabot>   True
23:28:41 <RambO> > (2,1) > (2,2)
23:28:42 <lambdabot>   False
23:28:46 <Cale> RambO: Yeah, it uses the "lexicographic" order (like how words are ordered in dictionaries).
23:29:33 <RambO> However, I could redefine the (>) for tuples that could use the inversed lexicographic order.. or the order i want.. is that easy?
23:30:27 <Cale> RambO: It's hard to avoid importing instances of typeclasses. The only way you could do it is to use a different prelude, or shadow the prelude's version of (>)
23:30:35 <Cale> More practically, you'd just make your own pair type
23:30:48 <Cale> Or define a function with a different name
23:31:06 <RambO> like inverseOrderCompareOfTuples ?
23:31:18 <kynky> define your own Ord ?
23:31:21 <olsner> or avoid using Ord by using the variants of functions that take a comparison function
23:31:21 <RambO> or randomOrderCompareTuples, that would be nice.
23:31:22 <Cale> Or something like <!
23:31:41 <olsner> e.g. sortBy weirdComparisonFunction
23:33:16 <Cale> > let (x,y) <! (x',y') = compare y y' `mappend` compare x x' in (1,2) <! (2,1)
23:33:18 <lambdabot>   GT
23:33:18 <juhp> code.haskell.org is still down?
23:33:22 <Cale> er, heh
23:33:26 <Cale> > let (x,y) <! (x',y') = compare y y' `mappend` compare x x' == LT in (1,2) <! (2,1)
23:33:27 <lambdabot>   False
23:33:35 <Cale> > (1,2) < (2,1)
23:33:36 <lambdabot>   True
23:34:07 <dignan> > it
23:34:07 <lambdabot>   Not in scope: `it'
23:34:17 <dignan> it's not ghci then?
23:34:21 <Cale> right
23:34:31 <dignan> What is it using?
23:35:08 <Cale> lambdabot uses mueval, which in turn uses a library called hint, which in turn uses the GHC API, which is what GHCi uses, but implements different features on top of that :)
23:35:28 <dignan> Cool
23:35:34 <Cale> Each expression is evaluated in a separate process
23:36:12 <Cale> The @let feature of lambdabot writes definitions into a file which is then loaded and put into scope during evaluation
23:36:14 <e|f> perhaps a silly question: does Haskell have regex support?
23:36:22 <Cale> e|f: There are libraries for it
23:36:25 <Zao> e|f: There's a few libraries for it, yes.
23:36:38 <Cale> e|f: But you don't really want regexes if you can avoid it. Use a proper parsing library.
23:36:52 <Cale> (Like Parsec or ReadP)
23:39:33 <kulin> do i need to worry about stack size in haskell for recursive calls or does the fact that haskell is lazy remove that concern?
23:40:00 <Cale> kulin: If you get a stack overflow, the reason won't *directly* be recursion.
23:40:03 <Adamant> kulin: laziness plus TCO
23:40:10 <Zao> kulin: The kind of stack you need to worry about is the one used to evaluate large lazy expressions.
23:40:40 <Cale> kulin: The stack serves a different purpose, in particular, it holds the pattern matches which are waiting for their scrutinee to be sufficiently evaluated that they can pick a branch
23:41:10 <kulin> so unless I am doing something really weird, I shouldn't have to worry about it?
23:41:52 <Cale> kulin: Well, issues with the stack are fairly rare (particularly if you compile with optimisations), but they exist.
23:42:03 <Cale> kulin: I'll give a simple example...
23:42:07 <Cale> consider something like
23:42:16 <Cale> foldl (+) 0 [1,2,3]
23:42:24 <Cale> @src foldl
23:42:25 <lambdabot> foldl f z []     = z
23:42:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:42:30 <Cale> this evaluates as follows:
23:42:34 <Cale> foldl (+) 0 [1,2,3]
23:42:41 <Cale> -> foldl (+) (0+1) [2,3]
23:42:47 <Cale> -> foldl (+) ((0+1)+2) [3]
23:42:54 <Cale> -> foldl (+) (((0+1)+2)+3) []
23:43:00 <Cale> -> ((0+1)+2)+3
23:43:29 <kulin> that would really bother to push the stack 4x?
23:43:30 <Cale> Now, the outermost (+) needs to know its left parameter before it can continue, so we push (...)+3 on the stack
23:43:44 <Cale> and then (...)+2
23:43:51 <Cale> and then 0+1 evaluates to 1
23:44:02 <Cale> and 1+2 evaluates to 3
23:44:07 <Cale> and 3+3 evaluates to 6
23:44:17 <Cale> So the foldl itself didn't use any stack
23:44:29 <Cale> it's the evaluation of the large arithmetic expression we built up that does
23:44:42 <ddarius> Cale: foldr (*) 1 [1,2,3,4] stack overflows in Haskell for exactly the same reason it's equivalent does in Scheme or ML.
23:45:02 <Cale> Well... depends on what you mean by "exactly the same"
23:45:28 <Cale> The stack doesn't consist of calls to foldr, it consists of pattern matches done by (*)
23:46:11 <Cale> You immediately evaluate that to  1 * foldr (*) 1 [2,3,4]
23:46:37 <Cale> and then the (*) can't evaluate further without determining (pattern matching) its second parameter
23:47:00 <Cale> and so that pattern match waits on the stack while the foldr on the right has to be evaluated
23:47:19 <Cale> kulin: Does this make sense so far?
23:47:34 <kulin> not enough that i could repeat back to you what you said, but I think i get the idea
23:47:45 <kulin> I am just not familiar with what qualifies as pattern matching and what doesnt
23:47:45 <Cale> kulin: Lazy evaluation is outermost-leftmost
23:48:06 * e|f wonders if anyone here is a rocket scientist :D
23:48:20 <Cale> Well, at some level, it'case expressions, patterns on the left hand side of equations (which get turned into
23:48:23 <Cale> whoopse
23:49:23 <Cale> Well, at some level, it's all case expressions, along with patterns on the left hand side of equations (which get turned into case expressions), and primitive strict functions, I suppose (which you can at least imagine as having case expressions).
23:49:35 <Cale> so anyway
23:49:41 <Cale> How do we fix this?
23:50:27 <kulin> whats there to fix?
23:50:32 <Cale> Well, if we just ensure that foldl keeps its accumulating parameter evaluated, the large expression which causes the stack overflow won't have a chance to build up (the strictness analysis optimisations will typically find this for you)
23:50:44 <m3ga> code.haskell.org is down again. it seems its down every day at about this time. is that right?
23:50:51 <Cale> Well, the potential stack overflow when we write foldl (+) 0 [1..10000000]
23:52:22 <Cale> (the foldl finishes its work using only bounded stack -- it's the giant (((...((0+1)+2)+...)+9999998)+9999999)+10000000 which causes it
23:52:39 <Cale> So there's a variant of foldl called foldl'
23:52:45 <kulin> which is strict?
23:52:48 <Cale> yeah
23:52:54 <Cale> strict in the accumulating parameter
23:53:43 <Cale> It ensures that the accumulating parameter is evaluated just enough so that its topmost data constructor is available before recursing
23:54:15 <Cale> (well, really, before allowing the result of recursing to become available, but that's splitting hairs)
23:54:30 <Cale> The way it does it is with a primitive called seq
23:54:43 <kulin> im not sure if foldl is the one that overflows with (+)
23:54:47 <kulin> i think it might be foldr
23:55:27 <Cale> both of them might, but it's not really those functions' fault -- it's (+)'s pattern matching on the numbers which builds up on the stack
23:55:32 <Pseudonym> Generally speaking, foldl with (+) on Ints will be strict if your optimisation level is high enough.
23:55:43 <kulin> i see
23:55:45 <Cale> (also on integers)
23:55:50 <Pseudonym> But there's no guarantee for a general Num that (+) is itself strict.
23:56:04 <ddarius> Generally speaking, one shouldn't rely on strictness analysis to avoid stack overflows.
23:56:09 <Pseudonym> Agreed.
23:56:11 <kulin> I will
23:56:14 <kulin> until it doesnt work
23:56:17 <Cale> :)
23:56:17 <kulin> then ill rely on you guys
23:56:28 <Pseudonym> Good plan. :-)
23:56:41 <ddarius> Seems like a poor plan to me.
23:56:42 <Cale> kulin: foldr is actually often better than foldl, because it passes control to the combining function at each step
23:56:52 <Pseudonym> We can be relied upon, no?
23:57:08 <Cale> kulin: and if that combining function can produce part or all of its result without needing its second parameter, the foldr doesn't continue
23:57:14 <Cale> @src foldr
23:57:14 <lambdabot> foldr f z []     = z
23:57:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:57:23 <ddarius> Pseudonym: And his internet connection or his access to an internet connected computer?
23:57:26 <Cale> You can see in the second line there that it'll be f which is next
23:57:41 <Cale> So, we can write things like:
23:57:57 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
23:57:57 <ddarius> Pseudonym: Anyway, postponing/avoid self-sufficiency never strikes me as the way to go.
23:57:58 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
23:58:08 <Cale> and it works :)
23:58:17 <kulin> ddarius, except that is how all learning is performed
23:58:25 <Pseudonym> ddarius: I disagree, actually.  There's no shame in cargo-cult programming as a first step.
23:58:28 <ddarius> kulin: By avoiding learning?
23:58:28 <Cale> foldl on the other hand, will never work on an infinite list, because it does nothing but call itself until it reaches the end
23:58:48 <Cale> @src foldl
23:58:48 <lambdabot> foldl f z []     = z
23:58:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:58:59 <Pseudonym> As for internet connections, did you know that in Java, the comparison function for URL is different depending on whether or not the machine is connected to the net?
23:59:03 <juhp> who to poke about http://community.haskell.org/ ?
23:59:18 <ddarius> Pseudonym: I avoid Java as much as possible.
23:59:18 <Cale> ^^ the outermost thing on the right hand side of the second equation for foldl is just foldl itself
23:59:19 <Pseudonym> This has nothing to do with anything, just thought you'd enjoy the headslap.
23:59:36 <kulin> ya cale, i can see what you are saying, but I think I need to just encounter more problems before I'll have a firm grasp on it
23:59:46 <kulin> but thank you, I think I know where to look when I encounter problems
