00:02:59 <blackdog> copumpkin: hm. my colleagues seem to be dropping your quotes into the local IRC bot
00:03:05 <blackdog> I fear they mock me
00:03:06 <copumpkin> ?
00:03:30 <blackdog> lax functor from a terminal bicategory etcc
00:03:34 <Pseudonym> You're not as quotable?
00:04:05 <copumpkin> lol
00:04:24 <copumpkin> I don't even know what quotes of mine are left in it
00:04:27 <copumpkin> @quote copumpkin
00:04:27 <lambdabot> copumpkin says: damn, it's turning into a gangbang, I'm going to pull out
00:04:34 <copumpkin> oh my
00:04:44 <blackdog> Pseudonym: i got lambdabot going too - there's a channel which is just his perl bot talking to vixen
00:04:48 <copumpkin> can't even remember what that's from
00:04:53 <copumpkin> @quote copumpkin
00:04:53 <lambdabot> copumpkin says: These are not the monads you are looking for.
00:05:30 <copumpkin> hmm
00:06:45 <tensorpudding> @quote copumpkin
00:06:45 <lambdabot> copumpkin says: I'm on a rollomorphism
00:07:41 <tensorpudding> I think all of the quotes I have on here are puns
00:07:55 <copumpkin> @quote lolcategory
00:07:56 <lambdabot> tensorpudding says: lolcategory demands moarphisms
00:08:00 <copumpkin> I love that one
00:09:15 <kmc> @quite
00:09:15 <lambdabot> Maybe you meant: quit quote
00:09:36 <tensorpudding> @quine
00:09:37 <lambdabot> Maybe you meant: quit quote
00:09:57 <tensorpudding> > "lambdabot quines"
00:09:58 <lambdabot>   "lambdabot quines"
00:10:39 <Pseudonym> > let q x = x ++ show x in q "let q x = x ++ show x in q "
00:10:40 <lambdabot>   "let q x = x ++ show x in q \"let q x = x ++ show x in q \""
00:10:49 * copumpkin goes to sleep
00:13:22 <kmc> > let q x = text (x ++ show x) in q "let q x = text (x ++ show x) in q "
00:13:23 <lambdabot>   let q x = text (x ++ show x) in q "let q x = text (x ++ show x) in q "
00:13:58 <kmc> @. elite nixon
00:13:59 <lambdabot> yoU H4VE tO faC3 7hE f4Ct 7|-|aT \/\/|-|O|3 pRoblEM Iz Rea1Ly 7H3 8|a(K5. The keY Iz 7O DiVis3 a zYz+EM +HA+ ReconIsez +Hi$ Whi1e N07 App3Arin9 TO...
00:14:52 <ski> @. read run (\s -> s ++ show s)"@. read run (\\s -> s ++ show s)"
00:14:53 <lambdabot>  @. read run (\s -> s ++ show s)"@. read run (\\s -> s ++ show s)"
00:15:48 <kmc> @help read
00:15:48 <lambdabot> read "<foo>". Print <foo>
00:15:52 <kmc> @read "foo bar"
00:15:53 <lambdabot>  foo bar
00:16:11 <kmc> @read "foo \" bar"
00:16:11 <lambdabot>  foo " bar
00:38:58 <rajeshsr> > range (0, 0) (3, 3)
00:38:59 <lambdabot>   Couldn't match expected type `(t1, t2) -> t'
00:38:59 <lambdabot>         against inferred type ...
00:39:09 <rajeshsr> :t range
00:39:09 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
00:39:27 <rajeshsr> > range ((0, 0), (3, 3))
00:39:27 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
00:43:26 <rajeshsr> what is this ST manad? Why should i use it instead of IOArray?
00:44:03 <Jafet> So that you can use an STArray
00:44:23 <rajeshsr> Jafet, what is the difference?
00:44:51 <Jafet> STArray runs in ST and IOArray runs in IO. ST is for running STArray and IO is for running IOArray.
00:45:05 <Jafet> I hope that was clarifying.
00:45:42 <rajeshsr> Jafet, ha, well! am asking if there is any semantical change? or may be in performance or in features?
00:46:44 <Jafet> ST uses the ST monad and IO uses the IO monad...
00:47:09 <Jafet> Blah, get someone else to read to you
00:48:16 <Cale> rajeshsr: ST computations are like IO computations in that they allow mutable variables and arrays, but are unlike them in that they don't allow any other effects.
00:48:51 <Cale> So there's a function runST :: (forall s. ST s a) -> a
00:49:11 <Cale> which runs an ST computation and gets its pure result.
00:49:21 <rajeshsr> Cale, oh, ok!
00:49:48 <Cale> So you can do imperative programming in the ST monad, and use it from pure code.
00:49:59 <rajeshsr> so what is better to use for mutable arrays? IOMonad is ok, right?
00:50:05 <rajeshsr> IOArray i mean
00:50:17 <Jafet> Both IOArray and STArray are equally mutable
00:50:46 <rajeshsr> Jafet, hmm, ok!
00:50:46 <Jafet> If you use the array in a pure computation, you can use ST.
00:51:20 <Cale> IO is fine, but ST has the advantage of giving you something which is indistinguishable from a pure function from the outside.
00:51:30 <Jafet> *cough diffarray cough*
00:53:31 <rajeshsr> Cale, hmm, ok.
00:54:28 <Cale> rajeshsr: So if you have some algorithm which is imperative, but the function it computes is a pure function that doesn't have any real I/O in its specification, you might consider using ST to implement it.
00:54:32 <rajeshsr> Cale, am planning to extend the sudoku i wrote yesterday with a bitset (Int) of possible values in each square and using various heuristics. I guess it is going to get purely imperative!
00:54:49 <Cale> I normally would just use a Data.Map though
00:55:05 <rajeshsr> Cale, hmm, that won't be speedy, right?
00:55:13 <Cale> It's usually more than speedy enough.
00:55:33 <Cale> Asymptotically, you're only paying a logarithmic additional cost.
00:56:01 <rajeshsr> hmm
00:56:18 <Jafet> Sudoku is meh -- O(1)
00:56:19 <Cale> Also, for backtracking, it tends to be good, because you don't have to take extra steps to recover your old state -- it can simply remain in memory.
00:56:23 <Jafet> Go for sokoban!
00:56:43 <Cale> Sudoku isn't O(1) in the size of the puzzle.
00:56:44 <rajeshsr> Cale, hmm, yeah!
00:57:10 <rajeshsr> Cale, i think he probably means sudoku has become too simple for computers!
00:57:33 <Jafet> Is it faster to generate sudoku puzzles than to solve them?
00:58:08 <rajeshsr> Jafet, both are of same complexity
00:58:24 <Cale> rajeshsr: It takes O(log n) steps to modify or look up a value in a Data.Map, which serves as a proof of sorts that any imperative algorithm incurs at most an additional logarithmic factor in the size of the problem when you write it in a pure way with immutable structures. (You could use a Data.Map as your mutable memory)
00:58:30 <rajeshsr> you need to solve the sudoku to make sure that it has a unique solution
00:58:59 <Jafet> Impure backtracking is DLX
00:59:00 <Cale> Actually, at least for some algorithms, in a lazy setting, you don't even necessarily pay the additional log cost, whereas in a strict setting, you must.
00:59:18 <Cale> I don't know (it may not even be known) whether this is true for all problems.
00:59:45 <Jafet> Well, log factor is not so significant to problems in NP
01:00:07 <rajeshsr> Cale, you mean lazy can be better than imperative by O(lgN) factors for some class of algorithms?
01:00:14 <Cale> yeah
01:00:22 <rajeshsr> strange! how?
01:00:41 <rajeshsr> i would suspect the other way! :)
01:01:03 <Jafet> > let(%)=mod;(/)=div;s g=case findIndex(=='0')g of Nothing->[g];Just f->concat$map(\m->if or.concat$map(\i->[g!!(f-f%27+f%9/3*3+i/3*9+i%3)==m,g!!(f%9+i*9)==m,g!!(f-f%9+i)==m])[0..8]then[]else s$take f g++[m]++drop(f+1)g)['1'..'9'] in length $ s "000023801702010000000000360006084753000106000283790600074000000000050207500000000"
01:01:04 <rajeshsr> all computations are representable with intended complexity in imperatives..
01:01:06 <lambdabot>   22
01:01:15 <Cale> ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Geraint.Jones/FP-1-96.ps.Z
01:01:23 <Jafet> Cale, do you mean purity instead of strictness?
01:01:30 <Cale> Let me see if I can find that in a less inconvenient format
01:01:48 <Cale> Er, yes, I mean lazy rather than strict
01:01:50 <Cale> in a pure setting
01:02:10 <Cale> Sorry, rajeshsr, I'm not contrasting lazy and imperative, but lazy-pure and strict-pure
01:02:22 <Cale> (didn't read carefully enough)
01:03:07 <rajeshsr> purity means referential transparency?
01:03:12 <Cale> yes
01:03:19 <Cale> and in particular, no mutation
01:03:22 <rajeshsr> i suspect strict-pure = imperative..
01:03:26 <Cale> no
01:03:48 <Cale> strict-pure means no mutation, immutable structures only, but expressions are evaluated innermost-first.
01:03:49 <Jafet> Imperative is a style of programming, pure is a machine model, strict is an evaluation strategy
01:04:08 <rajeshsr> Cale, hmm, ok!
01:04:23 <Cale> So, imagine Haskell without the laziness (and obviously without ST)
01:04:30 <Cale> (or IO)
01:04:35 <rajeshsr> Jafet, what was that code for?
01:04:45 <Jafet> rajeshsr, sudoku made simple
01:05:08 <rajeshsr> haha! :)
01:05:26 <rajeshsr> but it doesn't output the resultant list..
01:05:45 <Cale> grumble, that link seems dead
01:05:52 <Cale> Does anyone have a copy of that paper?
01:06:04 <dolio> What is it?
01:06:46 <rajeshsr> Cale, "More Haste less speed... "
01:06:47 <rajeshsr> ?
01:06:54 <Cale> yeah
01:07:03 <rajeshsr> am able to get it from your link
01:07:08 <Cale> More haste, less speed: lazy versus eager evaluation"
01:07:09 <Cale> hmm
01:07:30 <Jafet> It's Just You
01:07:34 <Cale> http://progtools.comlab.ox.ac.uk/members/oege/publications/documents/jfp97.ps -- here's another link anyway
01:08:27 <Cale> But the paper is just an existence proof by example that this happens.
01:08:36 <Cale> It does nothing to really characterise when it will happen.
01:10:01 <rajeshsr> BTW, who is Okasaki? i have been seeing his name since yesterday in connection with data structures for Haskell
01:11:29 <Cale> rajeshsr: A researcher who is responsible for a lot of the research on data structures in a lazy or partially-lazy setting.
01:12:09 <rajeshsr> BTW, i also suspect if there exists algorithms that will be O(logN) times slow in lazy, pure language compared to eager, impure languages(imperative). Has anything been done on that?
01:13:00 <Cale> rajeshsr: I don't think that anyone has a proof that something *must* be slower in a lazy pure language than in an eager impure one.
01:13:17 <Cale> At least, I haven't seen one.
01:13:22 <rajeshsr> Cale, oh, ok!
01:13:29 <Cale> For all we know, they might be subtly equivalent.
01:13:58 <rajeshsr> may be as in duals are equivalent! ;)
01:14:04 <Cale> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf -- Okasaki's thesis is available online and describes a lot of useful structures.
01:14:29 <rajeshsr> Cale, hmm, ok! thanks.
01:14:38 <rajeshsr> so he works at CMU?
01:14:40 <Cale> It uses a variant of ML with lazy annotations though
01:14:43 <kmc> hmm
01:14:47 <Cale> I don't know where he works now.
01:14:49 <kmc> so talking about whether the same algorithm must be slower
01:14:54 * hackagebot Monatron 0.3 - Monad transformer library with uniform liftings  http://hackage.haskell.org/package/Monatron-0.3 (TomSchrijvers)
01:15:00 <kmc> and talking about whether the same problem must have a worse best algorithm
01:15:03 <kmc> are subtly different
01:15:08 <Cale> kmc: Well, yeah.
01:15:25 <Cale> "same algorithm" is hard to talk about with mutation on the one hand and pure on the other.
01:15:26 <Jafet> The "acknowledgements" section of that thesis is like an all-stars role call
01:15:41 <kmc> anyway i've heard that this log n slowdown is observed in many cases, though i've seen no proof
01:15:49 <kmc> that it must be there
01:16:04 <kmc> ST is of course how we cheat and get the best of both worlds ;)
01:16:05 <rajeshsr> kmc, i think same implementation having different complexity may be the right way to look at this..
01:16:09 <Cale> rajeshsr: He also published a book called Purely Functional Data Structures, which apparently extends that work.
01:16:39 <rajeshsr> Cale, cool!!
01:17:29 <Cale> He also has a lot of useful papers on his website.
01:17:41 <Cale> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
01:19:39 <rajeshsr> Cale, what you think about using DiffArrays for backtracking?
01:20:11 <Cale> rajeshsr: I've had good results with them, but it's one of those things that you just have to try it and see if it's any better.
01:20:30 <dolio> Cale: Computing a structure containing some (multi)set of values in a random order seems like it'd be difficult to match in any pure language. But I'm not sure that's a legitimate problem.
01:20:33 <Cale> Sometimes plain UArrays can be faster than DiffUArrays even if you're mutating.
01:20:47 <kmc> i think it turns out that DiffArray performance sucks in practice
01:20:56 <Cale> Well, that's often the case.
01:21:10 <kmc> and this is a bug people are still working on
01:21:14 <kmc> the idea is nice though
01:21:40 <dolio> Oh, unless you can do the standard shuffle algorithm on arrays with uniqueness types.
01:21:45 <Cale> I haven't worked out exactly where DiffUArray (as implemented) turns out to be better than UArray, but actually, in my Sudoku solver I think it turned out to be somewhat better.
01:21:49 <kmc> ok
01:21:49 <Cale> Which was surprising.
01:22:06 <dolio> I guess that defeats that idea.
01:22:07 <Cale> (since they were used in a rather nonlinear fashion)
01:22:33 <kmc> hmm, what about providing a IArray interface on top of IntMap?
01:22:37 <kmc> that should be relatively easy, right?
01:23:11 <Cale> Perhaps, yeah.
01:23:15 <kmc> and will share nicely between versions
01:23:20 <rajeshsr> Cale, `so you used DiffUArray?
01:23:22 <kmc> do you know if this exists?
01:23:24 <Cale> rajeshsr: yeah
01:23:54 <rajeshsr> Cale, hmm, let me write in map and then try with arrays. Looks like am not ready for arrays yet, unless it is pure!
01:23:57 <Cale> kmc: I don't think it does
01:24:17 <Cale> kmc: The new array interfaces are really awkward to write new instances for.
01:24:46 <kmc> :/
01:24:49 <Cale> IArray has a whole bunch of members which it doesn't export.
01:24:54 <kmc> ah i see
01:25:04 <Cale> So you practically need to modify Data.Array.IArray itself
01:25:25 <Cale> Plus, there's a ton of rewrite magic in there.
01:25:43 <kmc> i suppose the answer is "just use IntMap directly"
01:25:50 <kmc> since it's not really an array, in terms of asymptotic complexity
01:25:57 <Cale> Or maybe produce a module which defines the same interface
01:26:26 <Jafet> How is IntMap implemented?
01:27:01 <dolio> It's a fancy trie.
01:27:03 <Cale> It's something called a patricia tree
01:27:10 <Cale> yeah
01:27:27 <kmc> PATRICIA -- Practical Algorithm To Retrieve Information Coded In Alphanumeric
01:27:34 <kmc> from 1968
01:27:36 <Cale> http://citeseer.ist.psu.edu/okasaki98fast.html -- apparently it's based on this
01:27:37 <kmc> when you could still name things that way
01:27:41 <Cale> (Okasaki again!)
01:27:48 <kmc> there's no escape
01:27:49 <Jafet> Okasaki is a superstar
01:28:10 <kmc> so it's a trie on the Int's bits?
01:28:20 <Jafet> http://www.catb.org/jargon/html/E/English.html
01:28:43 <Jafet> I thought patricia trees use (lg n)/2 bits per level
01:28:56 <dolio> Yes. With some measures to avoid having long chains out to a single value.
01:29:39 <thaldyron> I'm registering at linode. Anyone here who wants me to use their referral code?
01:29:42 <rajeshsr> so IntMap takes O(b) = number of bits? that can get worse than an ordinary comparator based Map
01:29:45 <dolio> It only branches when it needs to, more or less.
01:30:34 <Cale> rajeshsr: It can, for very small maps.
01:31:04 <Cale> rajeshsr: A lot of the operations are O(min(n,W)) where n is the number of elements in the IntMap, and W is the number of bits in an Int
01:31:48 <kmc> hmm
01:32:02 <rajeshsr> Cale, hmm, i don't see how a trie on bitstring can be made like that..
01:32:05 <kmc> is O(min(a,b)) = O(min(k1*a,k2*b)) for arbitrary constants k1,k2?
01:32:08 <rajeshsr> may be it uses something more?
01:32:11 <kmc> i think so
01:32:31 <Cale> rajeshsr: It's doing crazy stuff with prefixes and masks
01:32:54 <rajeshsr> it allows key insertion, right?
01:33:04 <Cale> yep
01:33:06 <Cale> immutably
01:33:12 <rajeshsr> yeah, get that
01:33:40 <rajeshsr> May be starting from LSB if you construct a trie i guess we can attain something like that
01:33:51 <Cale> So you can construct a new IntMap in O(min(n,W)) time which contains every element in the original, plus the new one.
01:33:58 <rajeshsr> ignore all leading zeros
01:34:10 <rajeshsr> and stop at the MSB as a leaf
01:34:11 <Twey> kmc: I don't think so
01:34:53 <Twey> I believe it's O(n) where n is the number of words in the number
01:35:20 <Cale> Wait, which message of kmc's are you responding to?
01:35:36 <Twey> The one about the growth of min
01:35:40 <Cale> mm...
01:35:53 <Twey> Oh wait :Ã¾
01:35:54 <rajeshsr> interesting to see O(n) n = number of elements here. Such a trie will be O(W) W = max number of bits in any Int Key
01:36:06 <Twey> Never mindâ€¦ >.>
01:36:32 <Cale> rajeshsr: Yeah, but that only applies somehow to very small trees.
01:36:37 <Twey> I hate morningsâ€¦
01:37:06 <rajeshsr> Cale, how do we implement anything like that!
01:37:48 <Cale> Honestly, I haven't given the implementation anything more than a quick look.
01:38:05 <rajeshsr> hmm, ok
01:38:30 <dolio> rajeshsr: If the trie contains a single value, it looks like Single pfx v. If you insert v' with key k, it needs to check k against pfx to see where to branch.
01:38:53 <quicksilver> 6
01:38:59 <quicksilver> ! sorry
01:39:22 <dolio> Once it determines that, you get something that looks like 'Branch pfx1 (Single pfx2 v) (Single pfx3 v').
01:39:53 <dolio> In general, it may have to do n such operations.
01:40:01 <rajeshsr> dolio, a prefix optimized tried? Got a vague idea of it!
01:40:09 <rajeshsr> s/tried/trie
01:40:10 <dolio> Except that the number of operations will always be bounded by the word size.
01:40:19 <dolio> Yes, exactly.
01:40:20 <jbapple> I tried to build gtk2hs
01:40:20 <lambdabot> jbapple: You have 1 new message. '/msg lambdabot @messages' to read it.
01:40:33 <jbapple> it game me 322 lines back
01:40:49 <jbapple> the penultimate helpfully muttered "Error 1"
01:41:30 <jbapple> many look like: svgcairo-0.10.1: missing id field
01:41:51 <jbapple> or svgcairo-0.10.1: dependency "base-4.2.0.1" doesn't exist (ignoring)
01:42:05 <jbapple> or svgcairo-0.10.1: file Graphics/Rendering/Cairo/SVG.hi is missing (ignoring)
01:48:06 <jbapple> Anybody else able to build gtk2hs with ghc 6.12.2?
01:48:48 <jbapple> here's another one: anybody else able to cabal install yi?
01:49:06 <jbapple> cabal tries to configure data-accessor-monads-fd-0.2.0.1
01:49:24 <kmc> yes, i did just the other day
01:49:27 <jbapple> which depends on transformers ==0.2.*
01:49:28 <kmc> was quite surprised it worked
01:49:34 <kmc> as i've had trouble building yi for years
01:49:46 <jbapple> but  yi-0.6.2.2 requires transformers ==0.1.*
01:50:18 <jbapple> jon harrop may be a troll, but I'm his complaints about cabal are quickly becoming my own
01:50:27 <jbapple> the error messages are sometimes completely opaque
01:51:05 <jbapple> I mean, "cabal: cannot configure leksah-0.8.0.4. It requires glib >=0.10,"
01:51:14 <jbapple> when was glib 0.10 out, 1995?
01:51:38 <jbapple> oh, I'm sorry, cabal, you mean something other than glib?
01:51:43 <jbapple> but you call it glib?
01:51:53 <jbapple> maybe that's leksah's fault
01:51:59 <jbapple> in any case, it's bizarre
01:52:47 <jbapple> or just try to upgrade base -- I know one isn't allowed to do that, but the error message is "cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda"
01:53:12 <jbapple> cabal install quickcheck installs QC 1.0 by default
01:53:27 <jbapple> yet hackage seems to list QC 2.* as the latest version
01:53:33 <jbapple> they aren't separate packages
01:53:52 <jbapple> I'm sure there is a good reason for that behavior, but why is it hidden from me
01:53:54 <jbapple> ?
01:54:14 <rajeshsr> > (fmap.fmap) snd [(1,2), (3,4)]
01:54:14 <lambdabot>   No instance for (GHC.Num.Num (a, b))
01:54:15 <lambdabot>    arising from a use of `e_11234' at ...
01:54:36 <rajeshsr> > fmap snd [(1,2), (3,4)]
01:54:37 <lambdabot>   [2,4]
01:55:41 <Nereid> anyone heard of something that's sort of like a "contravariant" natural transformation?
01:55:44 <Nereid> what I mean is
01:56:08 <Nereid> I have two functors F and G from categories C to D
01:56:13 <Nereid> F is covariant, G is contravariant
01:56:53 <Nereid> and then for each object a of C,
01:57:29 <Nereid> hang on, sorry, F is contravariant and G is covariant
01:57:39 <Schalken> Is it just me or is concatMap = concat . map ?
01:57:49 <quicksilver> Schalken: roughly, yes
01:57:57 <quicksilver> Schalken: concatMap f = concat . map f
01:58:05 <quicksilver> Schalken: (this is not exactly the same as what you said)
01:58:09 <Nereid> and for each object a of C, I have a morphism f_a from F(a) to G(a) such that
01:58:20 <Schalken> quicksilver: How is it different?
01:58:32 <Nereid> for every morphism g from a to b in C
01:58:40 <Nereid> ummm
01:58:44 <quicksilver> :t concat . map
01:58:45 <lambdabot>     Couldn't match expected type `[[a]]'
01:58:45 <lambdabot>            against inferred type `[a1] -> [b]'
01:58:45 <lambdabot>     Probable cause: `map' is applied to too few arguments
01:58:54 <quicksilver> Schalken: concat . map doesn't even type check :)
01:59:04 <c_wraith> :t (concat .) . map
01:59:04 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
01:59:50 <Nereid> f_b = G(g) . f_a . F(g)
01:59:54 <Nereid> that
01:59:58 <Nereid> anyone seen anything like that?
02:00:10 <jbapple> so, I've installed ghc-glib via my package manager (yum on fedora), but cabal still reports "cannot configure leksah-0.8.0.4. It requires glib >=0.10"
02:00:17 <jbapple> How can I diagnose this further>
02:00:18 <Nereid> or should I ask somewhere else :(
02:00:18 <jbapple> ?
02:01:03 <tab> jbapple: ghc-pkg list glib ?
02:01:23 <jbapple> ah, I see it has installed it in my old ghc directory
02:01:38 <jbapple> and I can't upgrade ghc via my distro, since it isn't on ghc 6.12 yet
02:01:50 <jbapple> and I can't install glib by hand because it won't compile
02:02:19 <jbapple> and I can upgrade distros because fedora wants and entire reinstall every time
02:02:28 <jbapple> blowing away one's entire /
02:02:30 <jbapple> great
02:02:39 <Accidus> Nereid,  sounds like a dinatural transformation
02:03:16 <Schalken> quicksilver: Oh, I get it now. map has to receive its first argument before the result can be passed to concat, right?
02:03:20 <Accidus> (where each functor degenerates in one argument
02:03:21 <Nereid> hmm, not immediately seeing how from the definition
02:03:23 <quicksilver> Schalken: yes.
02:03:24 <Nereid> oh
02:03:28 <Nereid> well
02:03:55 <Accidus> (and then 2 sides of the hexagon collapse into identity)
02:04:19 <Accidus> Nereid, do you see it now?
02:04:21 <Nereid> yeah
02:04:34 <Accidus> cool
02:05:20 * hackagebot hmatrix 0.9.3.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.9.3.0 (AlbertoRuiz)
02:05:22 * hackagebot hmatrix-special 0.1.0 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.1.0 (AlbertoRuiz)
02:05:40 <Nereid> if you're curious, in my case F is the functor L^2 from a suitable category of topological groups to the category of Hilbert spaces, G is L^2 composed with the character group functor, and f_a is the Fourier transform on the group a
02:05:46 <Nereid> so
02:05:52 <rajeshsr> (x,y) = (1,2,3)
02:05:55 <rajeshsr> > (x,y) = (1,2,3)
02:05:55 <lambdabot>   <no location info>: parse error on input `='
02:06:06 <rajeshsr> > (x,y) = (1,2)
02:06:07 <lambdabot>   <no location info>: parse error on input `='
02:06:23 <rajeshsr> >let (x,y) = (1,2) in x
02:06:25 <rajeshsr> > let (x,y) = (1,2) in x
02:06:25 <lambdabot>   1
02:06:30 <rajeshsr> > let (x,y) = (1,2, 3) in x
02:06:31 <lambdabot>   Couldn't match expected type `(t, t1)'
02:06:31 <lambdabot>         against inferred type `(t2, ...
02:07:50 <Nereid> let me think about this dinatural transformation thing a bit more.
02:08:05 <Accidus> will do.
02:08:11 <Accidus> I'll take  a shower in the meanwhile :P
02:09:30 <rajeshsr> > bitSize 5
02:09:30 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:09:30 <lambdabot>    `Data.Bits.Bits t'
02:09:30 <lambdabot>      a...
02:09:47 <quicksilver> rajeshsr: lambdabot replies to private message too :)
02:09:48 <rajeshsr> > bitSize (5::Int)
02:09:48 <lambdabot>   64
02:10:00 <rajeshsr> quicksilver, haha! ok! :)
02:11:02 <rajeshsr> BTW, i want to find the number set bits. What to do for that?
02:11:10 <rajeshsr> or am i to write my own function?
02:12:39 <rajeshsr> > let f x = if x /= 0 then 1 + f x (.&.) (x - 1)  else 0 in f 5
02:12:40 <lambdabot>   Occurs check: cannot construct the infinite type:
02:12:40 <lambdabot>    t = (a1 -> a1 -> a1) -...
02:12:54 <rajeshsr> > let f x = if x /= 0 then 1 + f $ x (.&.) (x - 1)  else 0 in f 5
02:12:54 <lambdabot>   Occurs check: cannot construct the infinite type:
02:12:54 <lambdabot>    a = (a1 -> a1 -> a1) -...
02:15:42 <Nereid> Accidus: well that seems to have done it
02:15:44 <Nereid> and I should go to bed
02:16:21 <rajeshsr> > let f x = if x /= 0 then 1 + f ( x .&. (x - 1) ) else 0 in f 10
02:16:22 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:16:22 <lambdabot>    `Data.Bits.Bits t'
02:16:22 <lambdabot>      a...
02:16:29 <rajeshsr> why doesn't that work?
02:17:17 <Nereid> tomorrow I investigate how to take a colimit in C to a limit in D through this transformation.
02:17:44 <Nereid> and then possibly come up with a name for this kind of transformation if there isn't one already
02:22:24 <quicksilver> rajeshsr: you need to fix the type to, e.g., Int
02:22:39 <rajeshsr> > let f x = if x /= 0 then 1 + f ( x .&. (x - 1) ) else 0 in f 10 :: Int
02:22:40 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:22:40 <lambdabot>    `Data.Bits.Bits t'
02:22:40 <lambdabot>      a...
02:22:48 <rajeshsr> this also fails!
02:22:49 <quicksilver> the type of x, not the type of the result
02:23:04 <rajeshsr> > let f (x ::Int) = if x /= 0 then 1 + f ( x .&. (x - 1) ) else 0 in f 10 :: Int
02:23:05 <lambdabot>   2
02:23:09 <rajeshsr> thanks!
02:23:20 <quicksilver> you're welcome
02:23:33 <quicksilver> note that the way you wrote it there requires an extension
02:23:38 <quicksilver> (PatternSignatures)
02:23:50 <rajeshsr> you mean?
02:23:56 <quicksilver> if you annotate one of the types on the right, or give f a type, you don't need an extension.
02:23:57 <k23z__> hi, does Haskell have an equivalent of SymPy ? a symbolic computation package ?
02:24:26 <rajeshsr> how do we give f a type?
02:24:34 <rajeshsr> in let binding i mean..
02:25:42 <maurer_> rajeshsr: If you're willing to give up the syntactic sugar, you can do
02:26:00 <maurer_> > let f = (\x -> x + 1) :: Int -> Int
02:26:01 <lambdabot>   not an expression: `let f = (\x -> x + 1) :: Int -> Int'
02:26:27 * hackagebot hTensor 0.6.0 - Multidimensional arrays and simple tensor computations.  http://hackage.haskell.org/package/hTensor-0.6.0 (AlbertoRuiz)
02:26:37 <k23z__> hi, does Haskell have an equivalent of SymPy ? a symbolic computation package ?
02:27:04 <bremner> still not apparently.
02:27:16 <noteed> > let { f :: Int -> Int ; f = const 1 }
02:27:17 <lambdabot>   not an expression: `let { f :: Int -> Int ; f = const 1 }'
02:27:26 <noteed> works in ghci though
02:27:40 <maurer_> noteed: It works here too if we make it an expression
02:27:52 <maurer_> > let { f :: Int -> Int ; f = const 1 } in f 3
02:27:53 <lambdabot>   1
02:28:16 <noteed> maurer_: ok
02:28:43 <maurer_> noteed: ghci lets us actually produce bindings. Lambdabot just evaluates expressions in an unchanging environment.
02:29:11 <noteed> maurer_: I thought I have seen people define things too
02:29:42 <maurer_> noteed: If there is a way to do that, I am unaware.
02:30:13 <k23z__> does Haskell have an equivalent of SymPy ? a symbolic computation package ?
02:31:30 <bremner> yes, ! wrote one in the 3 minutes since you last asked :)
02:31:52 <bremner> k23z__: seriously, what of the possibilities did you try so far?
02:32:10 <k23z__> bremner, I did not see any possibility, if I saw one I would've tried it
02:32:24 <k23z__> bremner, I'm sorry I posted 3 times, but I really haven't found anything with google
02:32:45 <bremner> the last time you asked this question, I pointed to "Haskell Computer Algebra" as search terms
02:34:09 <quicksilver> maurer_, noteed : @let is how you define things.
02:34:22 <quicksilver> @let greeting = "Hello"
02:34:23 <lambdabot>  Defined.
02:34:25 <quicksilver> > greeting
02:34:26 <lambdabot>   "Hello"
02:34:29 <quicksilver> @unlet
02:34:30 <maurer_> quicksilver: Cool, thanks.
02:34:30 <lambdabot>  Defined.
02:34:32 <quicksilver> > greeting
02:34:33 <lambdabot>   "Hello"
02:34:37 <quicksilver> @undef
02:34:41 <quicksilver> > greeting
02:34:42 <lambdabot>   Not in scope: `greeting'
02:34:43 <noteed> @let thks = "thanks"
02:34:43 <lambdabot>  Defined.
02:34:48 <noteed> > thks
02:34:49 <lambdabot>   "thanks"
02:34:59 <quicksilver> it's very transient, though. Anyone can delete all the bindings at any time.
02:35:05 <quicksilver> just by typing @undef
02:35:16 <noteed> fortunately
02:35:29 <quicksilver> so it's just for quick demonstrations / examples
02:35:56 <bremner> k23z__: I haven't used these systems, but there are definitly a few possibilities.
02:36:17 <k23z__> bremner, I'm reading a presentation http://www.cs.columbia.edu/~sedwards/classes/2007/w4115-fall/reports/HCAS-slides.pdf
02:36:26 <k23z__> bremner, it seems they are not very hard to implement in Haskell
02:37:21 <k23z__> bremner, the problem is I initially started writing something in Perl, which has horrible support for symbolic computation, but then I thought I would use Python because it has SymPy ... although that too seems like a big compromise , and now I see Haskell , I wished a CAS for it was already made...
02:37:51 <Jafet> "Patches welcome"
02:38:15 <quicksilver> there is also http://www.haskell.org/docon/ ?
02:38:32 <bremner> k23z__: afaiui, DoCon is the most complete one. But that is just gossip
02:44:59 <bremner> It sounds like the DoCon author is not completely happy with Haskell (or at least thinks dependent types are pretty important):http://groups.google.com/group/qilang/browse_thread/thread/124745db9c91acd3
02:49:44 <Traveler> hi all, does anyone mind helping me out quickly to sort my error?
02:50:08 <Traveler> im clueless of whats wrong with it :(
02:52:13 <Cale> Traveler: sure
02:52:38 <Cale> bremner: Yeah, they would be for a proper typed computer algebra system, I think.
02:52:54 <akosch> can I link libraries statically with ghc?
02:52:55 <Traveler> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25465#a25465
02:53:02 <Traveler> thanks cale
02:53:05 <ivanm> akosch: Haskell libraries or C libraries?
02:53:11 <ivanm> the former, yes: it happens by default
02:53:11 <akosch> ldd shows a bunch of dependencies for my executables...
02:53:18 <akosch> ivanm: c libraries
02:53:20 <Cale> Traveler: there are tabs in your file
02:53:21 <Traveler> the error im getting is: ERROR file:.coursework Haskell.hs:230 - Last generator in do {...} must be an expression
02:53:28 <ivanm> akosch: IIRC, you have to have at list glib be statically linked
02:53:38 <Cale> Traveler: You should configure your text editor properly so that it converts tabs to spaces
02:53:51 <osaunders> @hoogle String -> Maybe a
02:53:52 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
02:53:52 <lambdabot> Prelude fail :: Monad m => String -> m a
02:53:52 <lambdabot> Control.Monad fail :: Monad m => String -> m a
02:54:02 <Traveler> what tabs are you talking about cale?
02:54:25 <Cale> Traveler: The tab characters that you're using for indentation
02:54:48 <Traveler> can you show me a line which has these tabs please?
02:54:52 <Zao> Traveler: The indentation for the do block is inconsistent.
02:54:54 <Zao> Traveler: Line 230.
02:55:02 <Cale> The first tab is on line 17
02:55:10 <Cale> there are tons of them all over
02:55:24 <Zao> Err, 228
02:55:24 <akosch> ivanm: how do i do that?
02:55:29 <Cale> *almost* every indented line is indented with tabs
02:55:42 <Traveler> so i need to do it with spaces then?
02:55:43 <rajeshsr> i have to iterate through a list till it degenerates to same value, and take that final value, any way for that?
02:55:53 <rajeshsr> [1,7,8,9,5,5,5,...]
02:55:54 <Zao> What's the GHC interpretation of tabs now again? 8 space?
02:55:59 <rajeshsr> the result will be 5
02:56:08 <ivanm> akosch: I don't know ;-)
02:56:13 <ivanm> akosch: which OS is this?
02:56:28 <Zao> Traveler: If you hadn't had the first statement in do blocks on the same line, it wouldn't be as common.
02:56:34 <akosch> ivanm: linux
02:56:38 <Cale> Traveler: Yeah, what text editor are you using?
02:56:41 <akosch> ivanm: I want to run my program on a server with very old libraries
02:56:41 <Zao> I'd say go spaceful or be very aware of the tab rules.
02:56:59 <Traveler> Cale: notepad++
02:56:59 <mreh> did HOpenGL change its name?
02:57:07 <Cale> Traveler: any decent text editor will have an option to convert tabs to spaces automatically
02:57:17 <ivanm> akosch: *shrug* google
02:57:18 <Cale> and you should always turn it on
02:57:20 <Cale> :)
02:57:33 <Traveler> Cale: any idea how i can turn it on in notepad++?
02:57:49 <akosch> ivanm: i'll try, thanks... :)
02:57:53 <tab> :|
02:57:55 <Cale> I've never used that one, but I'll have a look.
02:58:05 <Traveler> thank you !
02:58:08 <mreh> i.e. is there any differenc between HOpenGL and OpenGL on Hackage?
02:58:18 <tab> Traveler: alternatively you can just use your tabs consistantly and not convert to spaces :)
02:58:58 <Traveler> what i dont get, is that a friend is using the same tabs and his works but mine doesnt
02:58:59 <osaunders> tab may be biased.
03:00:13 <Cale> The problem with tabs is that they can appear different in different text editors, and no matter how they appear in your text editor, the Haskell compiler will treat them as aligning to the next multiple of 8 spaces.
03:00:34 <Cale> "First set the "replace by spaces" setting in Preferences. Next, open the document you wish to replace tabs with Highlight all the text Then select TextFX -> TextFX Edit -> Leading spaces to tabs or tabs to spaces"
03:01:42 <Traveler> I'll have a go at it Cale
03:01:43 <tab> Cale: if you use them consistantly, it doesn't matter how they appears (and everyone can use different values), and there's no problems with ghc
03:01:57 <Traveler> thanks for the info guys
03:01:58 <Traveler> appreciate it
03:03:10 <Cale> It's best to avoid tabs altogether because other people will hate you if you use them and they have to work with your code.
03:03:35 <Cale> You *can* make them work, but I think they should be considered a lexical error outright.
03:03:53 <Cale> Just force everyone to use spaces and there's never any problem.
03:04:28 <Cale> Also, the layouts which you're forced into using if you indent with tabs tend to be really ugly.
03:04:43 <tab> Cale: why ?
03:05:17 <bremner> nothing personal tab, but you are just too wide
03:05:22 <tab> :)
03:05:25 <Cale> because, for example, you have to put newlines after 'let', 'do', and 'where'
03:05:34 <tab> bremner: the thing is, it's personal taste.
03:05:40 <tab> i find it hard to read at 2 spaces :\
03:05:43 <Cale> (and 'of', but that's less of concern)
03:06:17 <Cale> I don't care how much things are indented by, just that everything aligns properly.
03:06:51 <bremner> tab: sure, I agree, but spaces let you do whatever. Anyway, I think anyone using a dumb (i.e. non-haskell aware) editor to edit Haskell is just piling on the suffering for no good reason.
03:06:59 <tab> Cale: fair enough
03:07:03 <tab> bremner: not dynamically :(
03:07:13 <osaunders> http://www.jwz.org/doc/tabs-vs-spaces.html
03:07:40 <bremner> tab: again, get a better editor
03:08:19 <Cale> It's too bad that Traveler left, I can't instruct him on how to lay out if/then/else sanely either
03:08:32 <tab> well a better editor would works on AST directly, and would solve all problems :)
03:08:40 <tab> it's doesn't exist AFAIK
03:10:22 <osaunders> @hoogle [a] -> Int -> a -> a
03:10:22 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
03:10:22 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
03:10:22 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
03:12:03 <osaunders> I'm writing an indexWithDefault function but wondering why there isn't one already.
03:12:09 <maurer_> tab: An AST based editor would be cool. I think alot of the reason it doesn't exist at the moment is that most languages are so verbose that using the structural editing interface would actually be somewhat limiting speedwise.
03:12:44 <tab> maurer_: indeed. also it requires editor to know every language out there ... that's a hard requirement
03:12:45 <mreh> accuracy is more important than speed
03:13:06 <maurer_> tab: You can think of it the same way as syntax highlighting plugins
03:13:12 <arw> nack. ergonomy is very important, or nobody will use it.
03:13:17 <tab> maurer_: on steroid though
03:13:20 <maurer_> mreh: Agreed, but can you imagine writing Java in a raw AST form?
03:13:26 <maurer_> tab: Sure.
03:14:25 <mreh> maurer_, no :\
03:16:04 <sadache> I am looking for a composition function f (a->b) -> f(b->c)-> f(a->c) on Applicative f
03:16:45 <kmc> :t liftA2 (.)
03:16:46 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
03:16:47 <sadache> a lifted . is it defined somewhere?
03:16:53 <kmc> :t liftA2 (Prelude..)
03:16:54 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
03:17:06 <kmc> sadache, «liftA2 (.)» should work.  (.) has a weird type in lambdabot
03:17:58 <sadache> but isn't it defined somewhere? I find it strange that it is not defined inside Control.Applicative
03:18:23 <kmc> @hoogle f (b -> c) -> f (a -> b) -> f (a -> c)
03:18:23 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
03:19:01 <tab> maurer_: i think the display wouldn't change compared to actual editor, but the saving/loading mechanism would be completly different
03:19:16 <kmc> sadache, in the spirit of points-free, i think «liftA2 (.)» is a better name than any new name we could come up with
03:19:26 <kmc> but if you use it a lot, you might want an alias just for brevity
03:19:46 <EnglishGent> hi :)
03:19:48 <kmc> hi
03:19:51 <sadache> why not <.> for instance
03:19:53 <maurer_> kmc: Didn't you do something with this at some point?
03:19:56 <kmc> sadache, anyway, if you find it, let me know
03:20:13 <sadache> kmc: ok, thank you
03:20:18 <kmc> maurer_, not really.  i decided not to do an AST editor for my project because it was a secondary goal and would have been a lot of work
03:20:38 <kmc> my workaround was krufty but good enough for a 10-week undergrad project
03:20:39 <kmc> :)
03:21:30 <kmc> i know it's a significant research topic
03:21:38 <kmc> but i don't know the important works in the field
03:21:59 <arw> .oO( there is always xml... )
03:22:11 <kmc> i saw some AST editor such that two people could edit code, one seeing it as Python syntax and one as JavaScript
03:22:39 <kmc> which, the two are surprisingly close once you take away concrete syntax
03:22:44 <kmc> though it'd still break down on any real project
03:22:47 <kmc> that's just a toy
03:23:15 <kmc> xml is a fine data model with an awful serialization standard
03:23:22 <Grey_Fox> EnglishGent: what do you think about editor functions for directly manipulating ASTs?
03:23:25 <Grey_Fox> what's it called kmc?
03:23:30 <tab> kmc: that's quite cool :)
03:23:30 <kmc> don't remember :/
03:23:55 <EnglishGent> that's a rather open ended question Grey_Fox  - I mean .. what do you mean? refactoring support? or something else?
03:24:30 <Grey_Fox> refactoring support
03:26:01 <EnglishGent> well it's certainly can be very useful - I havent seen any editor with support for refactoring Haskell though
03:37:05 <ivanm> is Thomas Tuegal online?
03:37:18 <ivanm> I can't seem to post comments on his cabaltest blog :s
03:40:16 <quicksilver> EnglishGent: see scion and hare
03:40:28 <quicksilver> EnglishGent: which can be integrated with emacs and potentially other editors
03:40:36 <quicksilver> of course, hare is bitrotted and scion is young and far from complete
03:41:48 <EnglishGent> interesting quicksilver  :)
03:41:53 * EnglishGent will have a look :)
03:42:04 <ivanm> EnglishGent: HaRe currently only supports Haskell98
03:42:13 * EnglishGent is a fan of emacs anyway :)
03:42:19 <ivanm> not sure if it even supports module hierarchies though
03:42:49 <quicksilver> intelligent rename would be nice
03:43:10 <quicksilver> (rename a particular 'map' to 'myMap' without renaming other identifiers in other scopes which happen to have the same name)
03:43:27 <quicksilver> that would make me less reluctant to use the same identifier in different modules.
03:43:45 <quicksilver> (that together with a way to make qualified names look less ugly to my subjective eyes)
03:45:50 <rajeshsr> is this the good way for take the first value for which the function f is true: head . dropWhile (not . f)
03:45:51 <rajeshsr> ?
03:46:07 <quicksilver> yes.
03:46:48 <rajeshsr> quicksilver, hmm, ok, thanks!
03:47:14 <rajeshsr> it is really wonderful to see how much factoring can be done in haskell! I have some generalized functions for sudoku now..
03:47:19 <quicksilver> :)
03:47:24 <rajeshsr> let me see how i make it finally!
03:47:48 <quicksilver> rajeshsr: note that you'll get an error if there are no values where it's true.
03:47:54 <quicksilver> runtime exception kind of error.
03:48:07 <quicksilver> another alternative would be "head . filter f"
03:48:21 <quicksilver> I don't think there is anything to choose between those two.
03:48:41 <rajeshsr> quicksilver, hmm, ok! thanks
03:48:44 <quicksilver> a weirdly named safe version of head is 'listToMaybe'
03:48:52 <quicksilver> which gives you Nothing if there are no elements
03:48:56 <zygoloid> rajeshsr: a better way is Data.List.find
03:49:04 <quicksilver> (but you get 'Just x' instead of x if they're true)
03:49:10 <quicksilver> I'd forgotten about List.find
03:49:21 <quicksilver> is it much better, really?
03:49:29 <rajeshsr> hmm!
03:49:31 <quicksilver> :t find
03:49:31 <zygoloid> find f = listToMaybe . dropWhile (not . f)
03:49:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
03:50:17 <zygoloid> it's better in the sense that it's already given a name to a useful piece of functionality
03:50:22 <rajeshsr> @src find
03:50:22 <lambdabot> find p          = listToMaybe . filter p
03:50:49 <rajeshsr> @src listToMaybe
03:50:49 <lambdabot> listToMaybe []        =  Nothing
03:50:49 <lambdabot> listToMaybe (a:_)     =  Just a
03:51:09 <rajeshsr> > listToMaybe [1..5]
03:51:10 <lambdabot>   Just 1
03:51:15 <rajeshsr> interesting!
03:51:24 <rajeshsr> why it returns just head!
03:51:50 <rajeshsr> i mean any reason the design was like that?
03:51:54 <rajeshsr> :t fromMaybe
03:51:55 <lambdabot> forall a. a -> Maybe a -> a
03:52:19 <zygoloid> amusingly, 'unsafeCoerce' seems to be a correct implementation of listToMaybe in ghc ;)
03:52:32 <zygoloid> (modulo a potential space leak i guess)
03:53:22 <rajeshsr> >  fromMaybe . find odd $ [2..6]
03:53:23 <lambdabot>   Nothing->
03:53:23 <lambdabot>    Just 3
03:53:23 <lambdabot>  Just Nothing->
03:53:23 <lambdabot>    Nothing
03:53:23 <lambdabot>  Just (Just (-1))->
03:53:25 <lambdabot>    Just ...
03:53:33 <rajeshsr> why is it printing like that?
03:53:42 <ivanm> because it's a function
03:53:46 <zygoloid> rajeshsr: that's lambdabot's way of printing functions
03:53:52 <ivanm> and lambdabot can do some function printing
03:54:13 <rajeshsr> hmm!
03:54:36 <zygoloid> rajeshsr: you probably wanted: fromMaybe valueIfNotFound . find odd $ [2..6]
03:54:56 <rajeshsr> zygoloid, ha, ok!
03:55:01 <rajeshsr> thats what, i wanted
03:55:12 <rajeshsr> i want to get away with Just without writing case :)
03:57:05 <osaunders> Does anybody know the difference between DiffTime and NominalDiffTime?
03:57:38 <maurer_> One takes leap-* into account, the other does not I think?
03:57:50 <osaunders> I want to subtract N minutes from a time but addUTCTime wants a NominalDiffTime and secondsToDiffTime gives you a DiffTime not a nominal one.
04:10:53 <zygoloid> rajeshsr: you might find this table useful: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25467
04:11:14 <rajeshsr> zygoloid, thanks!
04:13:15 <quicksilver> zygoloid: hmm that is a useful table :)
04:13:33 <quicksilver> rajeshsr: one thing you will note from zygoloid's table is it never mentions fromJust or isNothing.
04:13:44 <quicksilver> fromJust and isNothing are code smell, they are seldom the best choice.
04:14:24 <rajeshsr> quicksilver, oh, ok!
04:15:12 <Cale> fromJust is like an assertion that you don't mind the program giving up and dying completely if the value isn't of the form Just x
04:15:18 <luite> :t fromNothing
04:15:19 <lambdabot> Not in scope: `fromNothing'
04:15:20 <kmc> fromNothing isn't as bad
04:15:28 <Cale> isNothing, you mean :)
04:15:28 <kmc> it's just not that necessary
04:15:32 <kmc> err yeah
04:15:34 <kmc> hehe
04:15:38 <kmc> fromNothing :: Maybe a -> ()
04:15:53 <luite> ?faq can Haskell make something out of Nothing?
04:15:53 <lambdabot> The answer is: Yes! Haskell can do that.
04:16:26 <dmwit> :t const undefined :: Void -> a
04:16:27 <lambdabot> Not in scope: type constructor or class `Void'
04:16:30 <Cale> fromNothing :: Maybe a -> a; fromNothing Nothing = undefined; fromNothing (Just x) = error "fromNothing: Just"
04:16:35 <dmwit> :t const undefined :: () -> a
04:16:36 <lambdabot> forall a. () -> a
04:16:42 <osaunders> \x -> if x == Nothing then "something" else x
04:17:21 <quicksilver> kmc: it's code smell because it suggests you ought to be using a case and you might end up using fromJust in the other branch
04:17:35 <quicksilver> (a case or 'maybe' which is just case written for you)
04:17:46 <quicksilver> there are occasionally valid uses for it
04:18:12 <Cale> length . filter isNothing
04:18:40 <quicksilver> yes, for example :)
04:19:00 <quicksilver> count f = length . filter f
04:19:42 <Cale> count dracula
04:19:47 <quicksilver> (I sometimes wonder if that should be in Data.List)
04:19:55 <quicksilver> s/dracula/duckula/
04:19:56 <Cale> (... = length . filter dracula)
04:20:45 <osaunders> I used to have some count duckula thing on VHS before I was past a single order of magnitude.
04:21:01 <ivanm> quicksilver: heh
04:21:36 <osaunders> Any recommendations for a good library for datetime arithmetic?
04:21:55 <ivanm> time? :p
04:21:57 <quicksilver> osaunders: I generally stagger by with Data.Time
04:22:06 <ivanm> osaunders: there's datetime ...
04:22:08 <quicksilver> it's good enough for most cases once you understand the API
04:22:11 <osaunders> ivanm: Deprecated
04:22:12 <ivanm> and relative-date
04:22:14 <ivanm> osaunders: oh
04:22:22 <quicksilver> time is not deprecated
04:22:26 <quicksilver> old-time is deprecated
04:22:37 <osaunders> time == Data.Time?
04:22:41 <quicksilver> (System.Time is old-time, Data.Time is time)
04:22:56 <ivanm> yeah, and datetime uses old-time
04:23:05 <ivanm> hang on, it uses _both_ :s
04:23:19 <quicksilver> the main gotcha with Data.Time is that some apparently critical parts of API are hidden in instances
04:23:29 <quicksilver> e.g. the Num instance for NominalDiffTime
04:23:48 <ivanm> yeah, I find the entire API of time really confusing :s
04:23:49 <quicksilver> and the Show/Read instances for UTCTime
04:26:00 <osaunders> I just don't know how you construct a NominalDiffTime
04:26:21 <quicksilver> osaunders: fromIntegral from a number of seconds
04:26:31 <quicksilver> or realToFrac from a (fractional) number of seconds.
04:27:00 <osaunders> Oh
04:27:05 <osaunders> OK then :-)
04:27:12 <osaunders> TY xD
04:27:17 <quicksilver> or by subtracting two dates, but you knew that
04:27:21 <osaunders> Yes.
04:29:13 <Damien> can someone help me
04:29:19 <Damien> im using ubuntu
04:29:25 <Damien> im in that room -.-
04:29:31 <Damien> but they are d*cks..
04:30:04 <dmwit> Huh. Well, I guess on the Internet nobody knows you're a duck...
04:30:06 <zygoloid> Damien: if your problem relates to haskell, someone here can probably help
04:30:31 <Damien> downloaded it and couldnt get it to work
04:30:42 <Damien> but no it doesnt, i was just trying to find a linux macro
04:30:42 <theorbtwo> 1: Try #linux.  2: Try #haskell-blah.  Unless, of course, the question is "how do I install haskell inside ubuntu".
04:30:44 <Damien> that works..
04:30:52 <ivanm> a "macro"?
04:31:09 <Damien> i tried installing it
04:31:11 <theorbtwo> Ah.  It *is* how do I install haskell.
04:31:16 <ivanm> theorbtwo: even -blah isn't really relevant
04:31:21 <Damien> but i missed the full version
04:31:23 <Damien> and gave up
04:31:32 <bremner> Damien: what is "it" in this context?
04:31:33 <ivanm> Damien: what are you trying to do?
04:31:39 <theorbtwo> ivanm: Oh.  I thought -blah is "where we're going, we don't need topic".
04:32:30 <Damien> just wondering if you can put exe's on linux
04:32:36 <ivanm> theorbtwo: well, in a sense, but it's not really meant to be a generic support forum
04:32:50 <dmwit> I feel like ##c's standard response to this applies particularly well here... "I went to Ford dealership and they wouldn't sell me a Ford; how come the folks at the BMW dealer won't just sell me a Ford? Your job is to sell cars, isn't it?"
04:33:01 <ivanm> dmwit: agreed
04:33:14 <ivanm> Damien: you can using wine, but this isn't really the right place to ask
04:33:31 <theorbtwo> He's left the channel.
04:33:35 <ivanm> oh, good
04:33:47 <quicksilver> heaven forbid this channel ever become anything like ##c
04:33:58 <quicksilver> quicksilver forbid it, too, for the record.
04:34:04 <theorbtwo> quicksilver++
04:34:15 <osaunders> I was on ##c for a while.
04:34:20 <osaunders> Didn't like it much.
04:34:26 <theorbtwo> I think questions of how to install haskell are on-topic here.
04:34:46 <theorbtwo> osaunders: I still am.  While I don't like it much, I do still learn things by being there.
04:34:46 <dmwit> Yeah, yeah, I like being helpful. But I'm not big on tech support. I do it for myself and that's more than enough of that.
04:35:06 <ivanm> quicksilver: proggit had a link to how the C newsgroup handles HW questions; did you see it?
04:35:19 <osaunders> theorbtwo: Yeah, you speak truth. The ideal is not to have to program in it though :)
04:35:21 <quicksilver> dmwit: the difference is less about flexibility in topic and more about the tone with which we respond to off-topic questions, FWIW.
04:35:34 <theorbtwo> osaunders: *shrug*
04:35:46 <dmwit> quicksilver: Point taken.
04:35:57 <quicksilver> ivanm: I don't read proggit any more, I decided it was a time-sink I could do without.
04:36:17 <ivanm> heh, fair enough
04:36:21 * ivanm tries to dig that link up
04:36:43 <ivanm> quicksilver: http://groups.google.com/group/comp.lang.c/msg/e105e5d339edec01
04:36:48 <theorbtwo> Many times, programming in C is the best option, I think.  For example, my major project at the time involves implementing a IO library API, in C, which many interactive fiction "interpreters" (virtual machines, really) can link to.
04:37:06 <osaunders> @hoogle [a] -> Int -> Maybe a
04:37:06 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:37:06 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:37:06 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
04:37:17 <theorbtwo> The C layer is minimal, and implements a stdin/stdio API to a non-C program where the heavy lifting is done.
04:37:23 <ivanm> osaunders: lookup is probably what you want
04:37:26 <ivanm> @type lookup
04:37:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:37:31 <ivanm> or not...
04:37:44 <ivanm> no, wait, I misread your @hoogle type sig
04:38:02 <osaunders> ivanm: lookup is for assocs, I just want !! that gives maybe so I can use fromMaybe to provide default when index is too large.
04:38:08 <ivanm> theorbtwo: AFAIK there's no function that does that; consider doing listToMaybe . drop (n-1)
04:38:12 <dmwit> :t \n -> listToMaybe . take 1 . drop n
04:38:13 <lambdabot> forall a. Int -> [a] -> Maybe a
04:38:19 <quicksilver> ivanm: awesome
04:38:25 <dmwit> Oh, right, the "take 1" is redundant.
04:38:34 <osaunders> :t listToMaybe
04:38:35 <lambdabot> forall a. [a] -> Maybe a
04:38:44 <ivanm> oh, right, I forgot 0-based indexing
04:38:55 <theorbtwo> ivanm: s/theorbtwo/ivanm/
04:39:04 <dmwit> ivanm: By our powers combined... !
04:39:06 <quicksilver> listToMaybe . drop n is the right way AFAIK.
04:39:21 <ivanm> theorbtwo: I think you meant s/theorbtwo/osaunders/ but yeah ;-)
04:39:22 <ivanm> dmwit: :D
04:39:41 <osaunders> @hoogle listToMaybe
04:39:41 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
04:39:45 <ivanm> @pl \ as n -> listToMaybe $ drop n as
04:39:46 <lambdabot> (listToMaybe .) . flip drop
04:39:52 <ivanm> @src listToMaybe
04:39:52 <lambdabot> listToMaybe []        =  Nothing
04:39:52 <lambdabot> listToMaybe (a:_)     =  Just a
04:39:59 <theorbtwo> ivanm: Whoops.
04:40:00 <ivanm> listToMaybe == safeHead
04:40:04 <ivanm> theorbtwo: :D
04:41:03 <osaunders> listToMaybe doesn't seem very useful. Maybe (no pun) I'm missing something.
04:41:25 <ivanm> > listToMaybe [1..]
04:41:25 <lambdabot>   Just 1
04:41:28 <ivanm> > listToMaybe []
04:41:28 <lambdabot>   Nothing
04:41:38 <ivanm> osaunders: how is it _not_ useful? it's a safe variant of head!
04:42:02 <aristid> :t safeHead
04:42:03 <lambdabot> Not in scope: `safeHead'
04:42:25 <osaunders> ivanm: Not useful for getting any index of a list, which is what I'm after.
04:42:31 <theorbtwo> > let safeHead = listToMaybe
04:42:32 <lambdabot>   not an expression: `let safeHead = listToMaybe'
04:42:41 <ivanm> osaunders: ummm.... dind't you see what dmwit and I wrote?
04:42:44 <theorbtwo> OK, didn't fix that for you.
04:43:02 <ivanm> > (\ as n -> listToMaybe . drop n) 4 [1..10]
04:43:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:43:03 <lambdabot>         against inferred type ...
04:43:06 <ivanm> bah
04:43:06 <osaunders> ivanm: Ah
04:43:10 <osaunders> OK
04:43:10 <ivanm> > (\ as n -> listToMaybe $ drop n as) 4 [1..10]
04:43:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:43:11 <lambdabot>         against inferred type ...
04:43:13 <osaunders> Sorry.
04:43:18 <ivanm> > (\ as n -> listToMaybe $ drop n as) [1..10] 4
04:43:19 <lambdabot>   Just 5
04:43:20 <ivanm> > (\ as n -> listToMaybe $ drop n as) [1..10] 10
04:43:21 <lambdabot>   Nothing
04:43:41 * theorbtwo attempts to stop procrastinating and fix the js layer.  (Yes, it is a trilingual project.)
04:44:08 <ivanm> quicksilver: from the reddit discussion, here's another: http://groups.google.com/group/comp.lang.c/browse_thread/thread/ccd201e172aa20e1/8582a720ccb5cee8?lnk=gst&q=ey200#8582a720ccb5cee8
04:44:20 <sosman> I pasted a basic app at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25468#a25468 and have a few questions.
04:44:23 <ivanm> theorbtwo: what's the third language?
04:44:29 <theorbtwo> ivanm: Perl.
04:44:35 <ivanm> *shudder*
04:44:35 <sosman> Its my second Haskell program (first was hello world).
04:44:59 <sosman> I am trying to create a basic syslog parser.
04:45:06 <ivanm> oh, that reminds me: if anyone comes in here asking about implementing reversi, especially a greedy algorithm or minimax, then it's HW
04:45:19 <theorbtwo> ivanm: You assigned it?
04:45:21 <ivanm> sosman: wow, straight from hello world to parsing? :s
04:45:30 <ivanm> theorbtwo: I'm a tutor
04:45:32 <ivanm> as is Axman6
04:45:32 <sosman> Heh not up to parsec just yet
04:45:42 <sosman> That will be #3
04:45:43 <ivanm> sosman: first of all, the dos in your case statement are redundant
04:45:53 <ivanm> "do abc" == "abc"
04:46:01 <sosman> Heh you answer the questions even before I ask them!
04:46:12 <Axman6> ivanm: reversi or othello
04:46:12 <ivanm> @hoogle stdin
04:46:13 <lambdabot> System.IO stdin :: Handle
04:46:18 <ivanm> Axman6: that's the other name
04:46:31 <ivanm> which I couldn't remember :s
04:46:36 <Axman6> s'all good
04:46:37 <Grey_Fox> ivanm: you're a tutor eh?
04:46:42 <ivanm> yes
04:46:45 <ivanm> your'e a student eh?
04:46:52 <Grey_Fox> yes
04:47:04 <ivanm> except your hostmask indicates you're in melbourne, and hence unlikely to be one of my students...
04:47:14 <Grey_Fox> oh, well, not your student
04:47:23 <ivanm> since I'm at ANU...
04:47:24 <Grey_Fox> I am *a* student however
04:47:31 <Axman6> Grey_Fox: where?
04:47:40 <Grey_Fox> Melbourne Uni
04:47:44 <Axman6> ah
04:47:52 <Axman6> you coming up to sydney for AusHac?
04:48:13 <sosman> Does my doLoop eat up stack?  Or is this a "normal" pattern for line oriented IO?
04:48:25 <quicksilver> sosman: it doesn't eat stack, it's fine
04:48:36 <ivanm> sosman: rather than looping, I would probably do something like: print . liftM (unlines . map parseLine . lines) $ hGetContents hin
04:48:42 <quicksilver> (although *why* it doesn't eat stack is something of a mystery, but let's pretend to ignore that)
04:48:59 <ivanm> quicksilver: lazy IO rearing it's rather weird head again?
04:49:07 <Axman6> ivanm: because that's obvious code for someone who is just starting with haskell ;)
04:49:19 <sosman> ivanm: my first attempt used hGetContents but I wasn't sure just how lazy this stuff is
04:49:22 <ivanm> Axman6: heh, just giving code tips!
04:49:32 <quicksilver> personally I prefer the explicit loop over hGetContents, because I despise hGetContents with all the fires of the nine hells.
04:49:36 <ivanm> well, there's a bug with hGetContents in 6.12.2 IIRC...
04:49:42 <ivanm> quicksilver: :o
04:49:52 <sosman> ok so there's more than one way to do it.
04:49:54 <aristid> @pl \f -> unlines . f . lines
04:49:55 * ivanm quickly hides his code before quicksilver sees it
04:49:55 <lambdabot> (unlines .) . (. lines)
04:49:57 <dmwit> sosman: That's a normal pattern; it's even named.
04:50:01 <dmwit> :t forever -- sosman
04:50:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
04:50:08 <Axman6> sosman: there's always more than one way to do it
04:50:08 <Jafet> ivanm, if someone turns in null-window alpha-beta with quiescence, you'll know we had a hand
04:50:13 <dmwit> sosman: Additionally, hGetContents is quite lazy.
04:50:19 <ivanm> Jafet: grrrr......
04:50:24 <aristid> @let mapLines = (unlines .) . (. lines)
04:50:25 <lambdabot>  Defined.
04:50:43 <ivanm> Jafet: thing is, the guy asked in the forums if he could do it, so we know _who_ it was...
04:50:48 <aristid> > (mapLines reverse) "xyz\nabc"
04:50:49 <lambdabot>   "abc\nxyz\n"
04:50:57 <ivanm> Jafet: not that it really matters; he's not getting any bonus marks for it anyway ;-)
04:51:02 <ivanm> (since it's outside the spec)
04:51:03 <k23z__> bremner, hey, the problem is, the most important aspect of a algebra system is the simplification routine for expressions
04:51:07 <k23z__> bremner, if you do many computations
04:51:09 <ivanm> and he's OK with that
04:51:17 <ivanm> (waddaya know, a keen student...)
04:51:19 <k23z__> bremner, the expressions tend to get bigger and bigger
04:51:27 <aristid> @pl \f -> unlines . map f . lines
04:51:28 <lambdabot> (unlines .) . (. lines) . map
04:51:33 <ivanm> @hoogle hGetContents
04:51:33 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
04:51:33 <Jafet> ivanm, you don't pit all the solutions in round-robin tournament to determine how many marks to award?
04:51:33 <lambdabot> System.IO hGetContents :: Handle -> IO String
04:51:33 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
04:51:33 <sosman> I will just skip over the fact that I have no idea what the $ sign in ivanm example above means for now.
04:51:41 <aristid> @let mapLines = (unlines .) . (. lines) . map
04:51:42 <lambdabot>  <local>:3:0:
04:51:42 <lambdabot>      Multiple declarations of `L.mapLines'
04:51:42 <lambdabot>      Declared at: <l...
04:51:48 <aristid> @unlet mapLines
04:51:49 <lambdabot>   Parse error: SemiColon
04:51:49 <Jafet> > src ($)
04:51:50 <lambdabot>   Not in scope: `src'
04:51:55 <Jafet> @src ($)
04:51:56 <lambdabot> f $ x = f x
04:51:58 <k23z__> bremner, for example, in Perl we have this http://cpansearch.perl.org/src/SMUELLER/Math-Symbolic-0.603/lib/Math/Symbolic/Operator.pm    <--- the simplify() routine, but it's very amateurish
04:52:02 <aristid> how can i remove a @let?
04:52:09 <ivanm> Jafet: no, there's no randomness involved and just two algs to implement so we play the algs against each other and check that it matches the same as the reference implementation
04:52:13 <Jafet> aristid, by removing all of them
04:52:13 <k23z__> bremner, I don't believe that's how it's supposed to be.. I hope DoCon is better than that
04:52:26 <ivanm> sosman: f . g . h $ x == f (g (h x))
04:52:36 <k23z__> are there any other way of representing arithmetic expressions than trees ?
04:52:46 <aristid> Jafet: i thought i saw somebody a command for doing it selectively
04:52:51 <aristid> +use
04:52:51 <k23z__> a sane way I mean, that allows for precedence
04:52:53 <Axman6> sure... graphs?
04:52:54 <dmwit> aristid: wrong
04:52:55 <k23z__> and the properties needed
04:53:00 <sosman> ivanm: the parens saver?
04:53:13 <aristid> @let realMapLines = (unlines .) . (. lines) . map
04:53:14 <lambdabot>  Defined.
04:53:14 <k23z__> Axman6, yes ? please show me an example of where you have seen graphs used for expressions
04:53:20 <k23z__> Axman6, I'd like to have a look
04:53:24 * Axman6 was making it up
04:53:25 <ivanm> sosman: well, $ is usually used to end a chain of function compositions
04:53:28 <aristid> > realMapLines reverse $ "abc\nxyz"
04:53:29 <Axman6> though it
04:53:29 <lambdabot>   "cba\nzyx\n"
04:53:33 <Axman6> it's probably possible
04:53:49 <ivanm> k23z__: well, a tree is just an acyclic graph...
04:54:03 <ivanm> oh, wait, let me rephrase that: it's a _connected_ acyclic graph
04:54:08 <Jafet> k23z, perhaps a stack.
04:54:10 * ivanm is pretty sure that's the definition of a tree
04:54:20 <aristid> making a HOF with complicated dot sections to make a long (but simple) dot sequence easier \o/
04:54:26 <k23z__> the problem with trees is that when you want to see the expression stored in the tree you do a traversal and you get a lot, and I mean *A LOT* of useless parenthesis
04:54:28 <Jafet> ivanm saw the forest for the trees
04:54:33 <k23z__> how can one avoid those parenthesis ?
04:54:34 <ivanm> Jafet: yup
04:54:43 <ivanm> quicksilver: why do you hate hGetContents?
04:54:51 <Grey_Fox> what does that even mean?
04:54:52 <k23z__> Jafet, as in RPN ?
04:54:53 <ivanm> because it's too lazy and does wierd stuff?
04:54:56 <ivanm> Grey_Fox: the netsplit?
04:55:03 <ivanm> @google wikipedia net split
04:55:04 <lambdabot> http://en.wikipedia.org/wiki/Netsplit
04:55:04 <lambdabot> Title: Netsplit - Wikipedia, the free encyclopedia
04:55:04 <Grey_Fox> no "see the forest for the trees"
04:55:19 <k23z__> Grey_Fox, it's the humour functor
04:55:22 <k23z__> Grey_Fox, dummy
04:55:24 <Jafet> k23z, examples are your HP calculator, all flavours of FORTH, Joy.
04:55:31 <ivanm> Grey_Fox: oh, the usual phrase is "didn't see the forest for the trees"
04:55:40 <ivanm> as in you're too busy focussing on the small details to see the big picture
04:55:47 <Grey_Fox> a humour functor called "dummy" eh?
04:55:52 <ivanm> Grey_Fox: http://en.wiktionary.org/wiki/see_the_forest_for_the_trees
04:55:54 <k23z__> Grey_Fox, exactly
04:56:42 <sosman> so that was Q-1.  Next up I just want to print out each line in CSV, date, device, rest (for now) and my prototype in formatRec is escaping quotes when showing the string.
04:57:18 <ivanm> sosman: because you're using print rather than putStrLn is my guess
04:57:48 <sosman> ivanm: easy.
04:58:23 <quicksilver> ivanm: because it's not lazy
04:58:41 <quicksilver> ivanm: because it uses a broken, and semantically unsound, concept that is called 'interleaved IO'
04:58:43 <ivanm> quicksilver: in what sense?
04:58:45 <quicksilver> that has no defined semantics
04:58:49 <quicksilver> and no agreed behaviour
04:58:53 <quicksilver> and no error handling
04:58:53 <ivanm> I've had problems because hGetContents was _too_ lazy
04:58:55 <ivanm> quicksilver: ahhh
04:59:01 <quicksilver> and, to make it worse, get's called "lazy"
04:59:07 <quicksilver> even though it has very little to do with lazy evaluation
04:59:17 <quicksilver> since lazy evaluation is pure, and has a clear semantics, and presents no such problems.
04:59:40 <sosman> @hoogle intercalate
04:59:40 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
04:59:40 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:59:40 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
04:59:54 * sosman reaches for dictionary
05:00:16 <ivanm> sosman: yeah, use putStrLn rather than print
05:00:19 <ivanm> (in line 19)
05:00:29 <sosman> Yeah I fixed that thanks.
05:00:58 <ivanm> sosman: note that when defining data types, you should probably at least also derive Eq and Read as well
05:01:01 <ivanm> and if possible Ord
05:01:55 <sosman> ok - thanks
05:03:15 <ivanm> quicksilver: if hGetContents is bad, what's the best way to get the entire contents of a Handle?
05:03:48 <quicksilver> ivanm: unfortunately, currently, it is to use hGetContents from the strict Data.Bytestring
05:03:57 <ivanm> *nod*
05:03:57 <quicksilver> ivanm: I agree this is not a very nice situation.
05:04:06 <ivanm> is bytestring's implementation safe/nice?
05:04:18 <quicksilver> well the strict bytestring implementation doesn't do any interleaved IO
05:04:21 <quicksilver> it does all the IO up front
05:04:27 <ivanm> right
05:04:31 <ivanm> how about the lazy variant?
05:04:37 <quicksilver> and of course bytestrings are compact in memory so that may be appropriate for "small/medium" sized files
05:04:38 <ivanm> or same problem with the String version?
05:04:45 <quicksilver> the lazy bytestring has the same problem as the string version, yes.
05:05:08 <ivanm> hmmm.... because I was thinking of replacing my String usage there with a lazy Text value...
05:05:29 <quicksilver> for files which you don't want to hold all in memory at once I personally advocate explicitly reading in chunks, using hGetLine or something more sophisticated like an iteratee
05:07:23 <ivanm> actually, it'd be bytestrings, not text values
05:07:27 <quicksilver> ivanm: I am exaggerating the problems, quite a lot. As is my wont.
05:07:43 <quicksilver> it's perfectly possible to use interleaved IO well if you understand the problems
05:07:45 <ivanm> this is for graphviz's OutputType -> Dot -> IO a functions
05:07:55 <quicksilver> and it's very convenient to have the IO performed on demand without thinking about it too hard
05:07:58 <ivanm> currently hGetContents seems to work...
05:08:03 <ivanm> quicksilver: heh
05:08:22 <quicksilver> I just think the problems are not sufficiently documented, and it's a shame the APIs are the 'default' ones
05:08:24 * ivanm has noticed that quicksilver invariably always exagerrates at every opportunity...
05:08:29 <ivanm> quicksilver: *nod*
05:08:34 <quicksilver> I've seen them cause problems for new and newish users
05:08:50 <quicksilver> and I think they tarnish the word 'lazy' because they're something a lot more semantically subtle than pure laziness
05:09:03 <ivanm> quicksilver: is there a way of having lazy IO _not_ use interleving?
05:09:42 <ivanm> (actually, I don't particularly need/want it to be lazy there, but I might need lazy Text values when I convert to a Text-based pretty-printer)
05:11:49 <sosman> So my formatRec looks like             intercalate ", " ([(show t), d] ++ s)
05:11:56 * ivanm should hit the sack
05:11:59 <ivanm> g'night all
05:12:03 <sosman> night
05:13:15 <quicksilver> sosman: (show t : d : s) would be the normal style
05:13:23 <quicksilver> (but it probably makes no difference)
05:13:29 <sosman> I want commas between them
05:13:34 <sosman> oops
05:13:38 <sosman> my bad
05:13:58 * sosman dons noob dunce hat
05:14:15 <Jafet> dons has a noob dunce hat?
05:14:31 <sosman> Jafet: actually its pretty cool
05:16:38 <earthy> leetle question: is there a library that mimics Data.Vector but allows vectors larger than (maxbound :: Int) elements?
05:17:03 <earthy> and don't answer Data.ByteString.Lazy, 'cause I need random(ish) access.
05:18:05 <osaunders> I think fromMaybe should be called ifNothing:  "default" `ifNothing` stuff
05:18:22 <ivanm> osaunders: you're free to define an alias
05:18:46 <osaunders> I have. :)
05:18:52 <osaunders> ivanm: Do you agree with me though?
05:18:57 <ivanm> no
05:19:20 <osaunders> :(
05:19:39 <osaunders> I'm not really sad. :) Why not though?
05:19:58 <ivanm> because it doesn't make as much sense when used in prefix style
05:20:27 <ivanm> osaunders: and "ifNothing" doesn't indicate what happens with Just{} values
05:20:41 <quicksilver> earthy: No.
05:21:02 <quicksilver> earthy: that would inevitably have to be disk-backed, it couldn't be memory or virtual memory based.
05:21:22 <quicksilver> earthy: I'm pretty sure there is no such library; you might be best with a simple FFI wrapper around a C library
05:21:42 <sepp2k> How about  stuff `or` "default"?
05:21:46 <earthy> quicksilver: well, I wrote a simple wrapper around mmap and foreign pointers
05:21:50 <earthy> but it's unstable
05:21:50 <osaunders> ivanm: Naming is so tricky.
05:22:00 <sepp2k> Though "or" is too general a name, probably.
05:22:03 <Jafet> > maxbound :: Int
05:22:04 <lambdabot>   Not in scope: `maxbound'
05:22:08 <quicksilver> earthy: you can't mmap more than maxBound :: Int elements either :)
05:22:13 <earthy> quicksilver: and being diskbacked is exactly what I want. :)
05:22:14 <Jafet> > maxBound :: Int
05:22:15 <lambdabot>   9223372036854775807
05:22:17 <osaunders> sepp2k: Yeah.
05:22:26 <earthy> jafet: I'm on a 32 bit system...
05:22:33 <Jafet> Haskell Int isn't necessarily the unix int, is it
05:22:42 <quicksilver> Jafet: s/unix/C/
05:22:44 <Jafet> It could be smaller
05:22:46 <earthy> maxBound :: Int2147483647
05:22:49 <dmwit> Haskell Int only guarantees you 29 bits.
05:22:54 <earthy> dmwit: exactly.
05:22:58 <quicksilver> Jafet: on GHC, Int is the C long.
05:23:08 <dmwit> But GHC gives you all 32 on 32-bit systems and all 64 on 64-bit systems.
05:23:12 <earthy> and I want a guarantee of 64 bits, and make it diskbacked.
05:23:13 <quicksilver> Jafet: or equivalently (on the systems I'm talking about) Int is the C (void*)
05:23:17 <Jafet> Well, it's not a problem in practice^W^Wwith ghc
05:23:38 <earthy> and yeah, I do mmap blocks of 1/16th of maxBound::Int or 4G, whichever is smaller
05:24:08 <Jafet> Better use the FFI, or at least Data.Int/Word
05:24:10 <quicksilver> earthy: are you sure it's faster than just using file based IO with hSeek?
05:24:11 <earthy> Jafet: I'm going through 56G data on a 32 bit machine. explain 'no problem'
05:24:27 <quicksilver> earthy: mmap is only faster than fseek() for particular access patterns.
05:24:30 <Jafet> earthy, with respect to the size of Int.
05:25:14 <earthy> quicksilver: I'm writing 8-byte blocks at random positions
05:25:38 <earthy> that are *mostly* within several hundreds of megaoctets from each other
05:25:47 <earthy> (which is why I said 'randomish')
05:26:04 <earthy> the hseek overhead is *large*.
05:26:20 <earthy> larger than the mmap overhead, afaict.
05:26:35 <Jafet> mmap seems unsuitable for that either. Your system has to send in a page or two every time you want to write eight bytes
05:26:44 * earthy nods
05:26:52 <Jafet> Your disk blocks are probably smaller than pages
05:27:21 <earthy> however, the access patterns are almost linear for runs at a time
05:27:33 <wli> mmap() is very lazy without msync()
05:27:51 <p_l> wli: and on Linux, is plain screwy lazy
05:28:24 <p_l> (though not so bad for file access)
05:28:50 <Jafet> Why is hseek expensive? Is it the fault of the interface or fseek itself?
05:29:05 <earthy> good question.
05:29:39 <theorbtwo> There's no real reason for it to be slow.  It's just setting a 64-bit value in kernel-space somewhere.
05:30:02 <Jafet> That makes it a system call, which is slow
05:30:04 <earthy> theorbtwo: however, I'm contextswitching for every 8 bytes in that case.
05:30:22 <p_l> earthy: try bufferring your I/O more?
05:30:22 <theorbtwo> Jafet: Er, for some value of slow.  It's a lot faster then reading a block off of a disk.
05:30:30 <quicksilver> to me this sounds like a case wher I'd expect seeking to be faster than mmap()
05:30:33 <Jafet> I have no idea how you can queue disk operations from haskell, but I wouldn't doubt it's possible
05:30:43 <Jafet> theorbtwo, my point exactly
05:30:47 <quicksilver> but there could be overheads at the haskell end making it painful.
05:30:49 * hackagebot Monatron 0.3.1 - Monad transformer library with uniform liftings  http://hackage.haskell.org/package/Monatron-0.3.1 (TomSchrijvers)
05:30:50 <earthy> p_l: that's what the mmap was doing, where the buffering came 'for free' from the underlying OS, imo
05:31:13 <p_l> quicksilver: it can be faster if you use msync() explicitly so that only dirty pages get written in one syscall
05:32:16 <p_l> earthy: also consider if you can get big pages for that
05:32:22 * earthy nods
05:32:39 * earthy ponders a bit
05:32:43 <p_l> though they are better on 64bit systems with lots of memory - AMD64 allows you to have pages as big as 1G
05:32:52 <wli> hugetlb doesn't do filesystem-backed affairs
05:33:10 <earthy> let me restate the question:
05:33:30 <wli> You have to fart around with buffering in hugetlb and that by hand atop whatever kernel buffering there is
05:33:38 <earthy> I need a diskbacked array of quite a bit larger than 2^32 bytes
05:34:05 <earthy> that I will fill more or less at random positions, but read mostly linearly
05:34:13 * Baughn just now used fmap . fmap . fmap - handy thing.
05:34:24 <earthy> baughn: yes, yes it is. :)
05:34:45 <quicksilver> earthy: that's not a question yet ;)
05:35:00 <earthy> quicksilver: coming to the question. :)
05:35:24 <p_l> earthy: have you looked into using fadvise to inform OS that you're going for random access and readahead might actually cause slower I/O?
05:35:43 <earthy> Data.Vector seems to give me the 'array' part. vector-mmap (i.e. Data.Vector.Storable.MMap) seems to give me the disk-backed.
05:36:05 <earthy> however, there is no 'quite a bit larger than 2^32 bytes', is there?
05:36:11 <p_l> you can also try skipping OS buffering and rely only on your app's by opening the file for DirectIO
05:36:27 <quicksilver> earthy: I believe you are right.
05:36:32 <quicksilver> (There is nothing off the shelf to do this)
05:36:37 <earthy> drat.
05:36:55 <quicksilver> there are a number of ways to achieve it and some debate as to what will be fastest
05:36:57 <p_l> earthy: which is more important - linear reading or random-pattern updates?
05:37:01 <quicksilver> I suggest you write yourself an abstract interface
05:37:04 <sosman> hpaste is pasted?
05:37:08 <quicksilver> and feel free to experiment with implementations of it
05:37:15 <earthy> p_l: both, but in different cases.
05:37:19 <sosman> 500 Internal Server Error 58030 5: database is locked
05:37:38 <earthy> basically, I'm doing something quite holumbus-like
05:37:50 <earthy> (i.e.: building an inverted index)
05:38:11 <earthy> however, the datasets that I'm looking into won't fit into holumbus' datatypes
05:38:17 <p_l> earthy: well, you can open the file with O_DIRECT, then use pwrite to update it, and do buffering inside your application. This completely cuts out kernel's page cache
05:38:17 <earthy> (holumbus is bound by Int)
05:38:41 <earthy> p_l: and cuts out my portability? :)
05:38:45 <p_l> I'd write an example but my Haskell skills are very low
05:38:56 * earthy reads C no prob.
05:39:30 * earthy was trying to *not* do this in C :)
05:39:36 <p_l> earthy: DirectIO, pwrite and posix_fadvise are all POSIX interfaces, just some OS/filesystem combinations might fail to open something in O_DIRECT (an example is ntfs-3g)
05:39:48 <earthy> ah, 'kay. good.
05:39:58 <p_l> earthy: you could use FFI just for the I/O part, and encapsulate it in haskell
05:40:21 * earthy nods
05:40:25 <earthy> that part I understand.
05:40:39 <p_l> also, there's readv/writev for efficient reading of binary arrays from files, which you might use for reading
05:41:31 * earthy ponders for a bit more
05:42:13 * p_l wishes remembering all that stuff would actually put food on the table, but he is too lousy of a programmer for that.
05:44:59 <earthy> so, basically, the argument here is counter to that of Poul Henning-Kamp's description of why Varnish does everything with mmap
05:45:31 <earthy> (see http://varnish-cache.org/wiki/ArchitectNotes )
05:45:44 <sosman> ciao
05:45:56 <p_l> earthy: I believe Varnish has different access pattern which fits mmap very nice
05:46:32 <earthy> hm.
05:47:54 <p_l> also, that was more regarding big set in memory. Nothing stops you from using mmap() based memory windows, especially if you use madvise/msync combo to fine tune it
05:48:32 <osaunders> In do notation what is <- exactly. Is it a function?
05:48:51 <earthy> osaunders: syntactic sugar
05:48:55 <p_l> earthy: DirectIO means that when you write to the file, it will be written directly - no caching etc. It also means that you can decide by yourself how to defer I/O, instead of leaving OS to do that.
05:48:59 <earthy> roughly correspondong to >>= \
05:49:15 <earthy> p_l: I understood that from the hastily opened manpages
05:49:31 <earthy> I don't *want* to care about deferal of I/O
05:49:51 <earthy> I want the OS to do it for me and give me a 2^64 array of bytes that I can address! :)
05:50:04 <earthy> (this may be a pipe dream, granted)
05:50:38 <aavogt> @undo do b <- c; b; Just d <- a; d
05:50:38 <lambdabot> c >>= \ b -> b >> a >>= \ e -> case e of { Just d -> d; _ -> fail ""}
05:50:45 <earthy> oh, and it doesn't need to be 2^64 large per se. I just know for a fact that it's going to be bigger than 2^32, and will fit on disk.
05:50:56 <p_l> earthy: mmap() otoh will let you do I/O only in pagesize chunks, but in both cases you can avoid seek() issues through madvise/fadvise (RANDOM) and in case of normal file I/O, pwrite. with mmap(), you'll probably need to carefully choose mmap() window size though.
05:51:04 <quicksilver> osaunders: it's syntax, not a funciton, and it's the "whole point" of do notation.
05:51:12 <osaunders> quicksilver: Ah, OK.
05:51:19 <osaunders> That @undo thing is cool.
05:51:23 <aavogt> though in ghc, the fail method is given a string indicating the source location
05:51:35 <quicksilver> osaunders: "getLine >>= \line -> putStrLn line" becomes "do line <- getLine; putStrLn line"
05:51:43 <quicksilver> osaunders: which is sometimes easier to read.
05:51:51 <earthy> as I said, I'm mmap()'ing in (maxBound::Int)/16 windows, accessing randomishly
05:52:54 <earthy> randomish == each access is within a block of no smaller than 64 bytes, and multiple accesses may be spread randomly among blocks
05:53:31 <earthy> I might try increasing that 64 byte size to the systems pagesize...
05:54:35 <earthy> but heck, let me first remove the segfaulting bug that I've managed to create
05:54:41 <earthy> (ain't the FFI grand!)
05:55:29 * p_l wonders why not just catch sigsegv and do recover... :P
05:55:42 <Jafet> Because you can't do that.
05:55:49 <earthy> p_l: because I don't know what to recover from. :P
05:56:15 <p_l> Jafet: ... lol. You can, MPlayer even managed to do that in realtime to keep its over-optimized MPEG2 decoder in line.
05:56:18 <earthy> jafet: not in the same process you can't. :)
05:56:31 <p_l> earthy: you can. You just define a handler for SIGSEGV
05:56:36 <Jafet> mplayer is loco
05:57:09 <earthy> oh, wait, that's SIGKILL that you can't catch.
05:57:18 * earthy is still waking up today
05:57:28 <Jafet> You cannot return from that handler if it caught an actual segfault. The behaviour is not defined.
05:57:34 <p_l> earthy: SIGKILL and SIGSTOP are the only non-blockable signals I can recall that exist on all POSIX systems
05:58:10 <earthy> yah, it's been a decade since I was more deeply versed in that stuff
05:58:25 <earthy> getting back into the bit-banging ;)
05:58:43 <p_l> SIGSEGV is afaik explicitly catchable - there's no system that makes it otherwise
05:59:19 <earthy> p_l: still requires you to have an idea of what's going wrong in the first place
05:59:42 <Jafet> You can make a signal handler for segfault, but you cannot longjmp back from it.
06:00:00 <Jafet> (Note: SIGSEGV is not synonymous with segfault)
06:01:24 * earthy nods
06:01:49 <p_l> segmentation fault is called on any <insert OS' segmentation system> fault. If you're on system with paging, it's rather common to be able to recover from it (the real problem is when you overwrite stuff that is already writeable in your process, not trying to write/read/execute from pages you don't have rights to)
06:02:13 <_Cactus_> hi
06:02:34 <Jafet> p_l, posix does not consider it valid. It might happen to be valid on your system
06:02:44 <_Cactus_> is it possible to get GHCi to "normalize" type synonyms?
06:03:15 <_Cactus_> i.e. if I have "type Foo = Char", I'd like the output of ":t (undefined :: Foo)" to be "Char", not "Foo"
06:03:41 <earthy> why?!
06:03:49 <earthy> that's subverting the abstraction!
06:04:53 <p_l> Jafet: can you give a link? I'd like to read more into that in official spec (been reading lately into some crazy tricks with page attributes to get a concurrent, parallel GC running)
06:04:56 <_Cactus_> earthy: that would be if I wanted this for newtype, isn't it?
06:05:09 <aavogt> _Cactus_: it's almost certainly possible with template haskell
06:05:39 <osaunders> @hoogle [a] -> (a -> b) -> (b, b, b)
06:05:39 <lambdabot> No results found
06:05:41 <aavogt> there is probably something to do that in one of haskell-src-meta  or derive (both on hackage)
06:06:03 <osaunders> @hoogle [a] -> (a -> b) -> (b, b)
06:06:03 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
06:06:03 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
06:06:03 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
06:06:23 <aavogt> perhaps you're more likely to find something if you do the map beforehand
06:06:34 <aavogt> @hoogle [a] -> (a,a,a)
06:06:34 <lambdabot> Test.QuickCheck three :: Monad m => m a -> m (a, a, a)
06:06:35 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
06:06:35 <lambdabot> Data.Graph.Inductive.Graph out :: Graph gr => gr a b -> Node -> [LEdge b]
06:06:56 <_Cactus_> aavogt: could you elaborate please?
06:07:44 <aavogt> template haskell gives you the ability to do some introspection: given a type you can find it's definition
06:08:26 <earthy> _cactus_: does :info Foo  give you enough information?
06:08:26 <aavogt> so you can say    $(someFunctionThatProbablyHasNotBeenWritten ''Foo) == "Char"
06:08:58 <_Cactus_> earthy: not really
06:09:14 <_Cactus_> earthy: because in reality I'd like this for functional types
06:09:57 <aavogt> or  $(functionYouWrite [t| a -> String -> Foo -> Bar |])
06:10:21 <earthy> so, you have a  type Foo = Bar -> Baz   and you want :type (undefined :: Foo ) to return Bar -> Baz  ?
06:10:21 <aavogt> but as I said, maybe some library already has such a function
06:10:30 <_Cactus_> earthy: yes
06:10:38 <_Cactus_> earthy: exactly
06:11:10 <earthy> *Main> :info Foo
06:11:11 <earthy> type Foo = Int -> Int 	-- Defined at foo.hs:1:5-7
06:11:11 <earthy> *Main> :type (undefined :: Foo)
06:11:11 <earthy> (undefined :: Foo) :: Int -> Int
06:11:13 <aavogt> since when deriving instances it is more legal to write them for the original type, not the synonym
06:11:21 <dino-> I have something that's not building on Hackage because of dep problems. Is there anything I can or should do about it?
06:11:41 <headcheck> hi all, total newbie. i need to install a bunch of dependencies (network, parsex, Bitly and so on), whats the fastest way of doing this in ubuntu?
06:11:46 <dino-> They're not particularly weird deps, I don't think. HSH, hxt, mtl
06:11:52 <headcheck> oops that was parsec =)
06:11:59 <_Cactus_> earthy: what version of GHCi is that?
06:12:06 <earthy> GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
06:12:42 <earthy> from the current haskell platform, on mac os x
06:12:43 <_Cactus_> earthy: thanks, I'm using 6.10, so it works by default on 6.12
06:12:44 <_Cactus_> great
06:12:53 <dino-> headcheck: Not sure of the apt-get or .deb situation with these libs in Ubuntu. Maybe cabal-install?
06:13:19 <Saizan> headcheck: do you have a cabal-install package?
06:13:25 <titto> headcheck: when you install a cabal package it will automatically pull and build all dependencies.
06:13:49 <Saizan> headcheck: parsec and network should be in the repos as libghc6-network-dev and libghc6-parsec-dev
06:13:54 <_Cactus_> earthy: I'll get 6.12 and try it. Thanks!
06:15:16 <rajeshsr> 1 + numBits $ x .&. (x - 1)
06:15:20 <rajeshsr> gives error
06:15:31 <rajeshsr> while: 1 + numBits ( x .&. (x - 1)) works
06:15:43 <rajeshsr> can anyone give some insight on this?
06:15:55 <ddarius> 1 + numBits $ ...
06:16:00 <ddarius> = (1 + numBits) $ ...
06:16:03 <headcheck> im installing cabal right now
06:16:15 <Zao> rajeshsr: Well, I doubt that (1 + numBits) is a function.
06:16:23 <ddarius> rajeshsr: The type error should have indicated this and would have potentially sped of diagnosing.
06:16:53 <ddarius> Zao: It's surely a function, it's just probably lacking a Num instance for functions.
06:17:04 <Zao> Also, it depends on what is to the left of the 1.
06:17:19 <rajeshsr> ddarius, why is it interpreted like that?! so using infi operators and $ is wring?
06:17:40 <rajeshsr> numBits is a function counting number of set bits..
06:17:45 <ddarius> rajeshsr: $ has lowest precedence.  That's all it is.
06:18:03 <dpratt71> it has seemed to me that the number of Haskell-tagged questions on StackOverflow.com has been increasing lately...
06:18:09 <ddarius> rajeshsr: Your question is like being surprised that 1*2+3 is (1*2)+3 and not 1*(2+3)
06:18:20 <dpratt71> ...but I wasn't sure if it was confirmation bias...
06:18:21 <rajeshsr> ddarius, haha!
06:18:39 <dpratt71> ...conveniently, they have a handy "stats" page...
06:18:53 <dpratt71> ...which confirms my perception
06:19:11 <Lajla> I see brackets.
06:19:14 <Lajla> Not enough though.
06:19:33 <dpratt71> since the first Haskell question was asked back in Aug '08, the daily average is 1.6 questions per day
06:20:10 <dpratt71> over the last thirty days, the average is 3.5 questions per day
06:20:30 <dpratt71> over the last 7 days, the average is 5.4
06:20:31 <zygoloid> Lajla: pining for lisp? :)
06:20:41 <Zao> rajeshsr: a b c $ d e f === (a b c) (d e f)
06:20:55 <Lajla> I infiltrate and turn you to the dark side from within, muahaha.
06:21:39 <ddarius> Lajla: I imagine many here have been through Lisp and likely proportionally more than those in the Lisp community that have been through Haskell.
06:21:57 <dpratt71> if I were less lazy and/or better at math, I bet I could do some interesting extrapolation of that trend
06:22:16 <Lajla> ddarius, I'd not be surprised yes.
06:22:34 <ddarius> dpratt71: Just extrapolate exponentially and predict that in 2020 there will be 10 billion Haskell questions a day.
06:22:35 <Lajla> I just don't see why they are compared that much, you can just as well compare them to javascript, but I'll play along.
06:22:43 <headcheck> Configuring cabal-install-0.8.2...
06:22:44 <headcheck> Setup: At least the following dependencies are missing:
06:22:44 <headcheck> time ==1.1.*
06:22:50 <headcheck> what now?
06:22:56 <dpratt71> ddarius: sounds good to me
06:22:57 <Lajla> But, query, is ':' an infix function? It isn't is it, or is it?
06:23:07 <ddarius> headcheck: Install time ==1.1.*
06:23:14 <dpratt71> maybe this crazy Haskell thing will catch on
06:23:21 <headcheck> ddarius: how?
06:23:22 <ddarius> dpratt71: Hopefully not.
06:23:28 <aristid> dpratt71: seems quite possible to me.
06:23:36 <headcheck> manually? is that even a package name?
06:23:42 <aristid> ddarius: because it would not avoid success?
06:23:43 <Saizan> headcheck: via apt-get
06:23:56 <Saizan> headcheck: the package name is time
06:24:04 <headcheck> ok trying thanks
06:24:11 <Saizan> headcheck: so you've to look for linghc6-time-dev
06:24:26 <headcheck> apparently time was already installed and the newest version
06:24:58 <headcheck> E: Couldn't find package linghc6-time-dev
06:25:27 <zygoloid> Lajla: : is an infix function (in fact, since : is 'uppercase', it's an infix constructor)
06:25:32 <dpratt71> ddarius: if you were thinking it would be better to keep out the riff-raff, that ship sailed the first day I showed up here
06:26:31 <zygoloid> however, : is reserved; only the Prelude is allowed to define a constructor called :
06:27:20 <Lajla> zygoloid, so constructors are in fact a subset of functions?
06:28:18 <headcheck> not even http://sporkcode.wordpress.com/2009/07/05/haskell-cabal-in-ubuntu/ is working, this must be specific to 0.8.2
06:29:06 <fasta> Lajla, yes.
06:29:43 <_Cactus_> earthy: I've just tried it with GHCi 6.12.1
06:29:50 <_Cactus_> earthy: I still get type synonyms in results
06:30:05 <earthy> okay. You're doing something different.
06:30:10 <earthy> what, exactly?
06:30:11 <_Cactus_> it only seems to work for functions
06:30:16 <Saizan> headcheck: can you put "ghc-pkg list" and a log of the commands you're trying with relative errors on a pastebin?
06:30:34 <_Cactus_> so if I do "type Foo = Char -> Char" then ":t (undefined :: Foo)" I get "Char -> Char"
06:30:48 <_Cactus_> but if I do "type Foo = Char" then ":t (undefined :: Foo)" I get "Foo" instead of "Char"
06:31:10 <earthy> ah. yes.
06:31:17 <earthy> that's not different from what I expected.
06:31:50 <zygoloid> Lajla: well, constructors are a subset of values. some constructors don't take any arguments (like Nothing on the value level and Int on the type level)
06:31:52 <earthy> in the case of 'just' type Foo = Char you can easily use :info Foo
06:32:01 <earthy> which will give you the answer you're looking for
06:32:19 <earthy> however, in the case of a function type, that may get harder, especially upon partial application of a value of that type
06:32:19 <zygoloid> Lajla: those data constructors which take arguments are functions. for instance, Just is a function, as is (:)
06:32:19 <fasta> zygoloid, but those are of course functions that take zero arguments ;)
06:32:33 <fasta> zygoloid, insert discussion about that which many people have had before.
06:33:25 <zygoloid> fasta: sure, if you prefer to view it that way :) i like the view that functions are "a -> b"
06:33:36 <_Cactus_> earthy: so there's no easy way to resolve the functional type?
06:33:39 <Saizan> i thought we agreed that considering values whose type is not of the form A -> B as functions deserved a permanent ban
06:33:41 <Lajla> zygoloid, sounds better designed than Python.
06:34:48 <fasta> Lajla, Haskell is not a mess, except for the FDs vs type-families, both which are not in Haskell98.
06:34:54 <zygoloid> Lajla: well, python's data constructors are callable at least, and in a duck typing language that's kinda the same thing as being a function ;)
06:35:19 <zygoloid> fasta: qualified operator syntax is a bit icky, as are records, imo
06:35:29 <Lajla> The only language that is not a mess is FORTH.
06:35:53 <zygoloid> the only language that is not a mess is whitespace. or at least, you can't /see/ the mess there ;)
06:36:22 <aristid> brainfuck is good, too.
06:36:30 <Grey_Fox> Haskell is a pretty good language
06:36:42 <aristid> you can't beat brainfuck when it comes to elegance and simplicity :P=
06:36:51 <earthy> cactus: ah, you want the case where you have two type definitions  type Foo = Bar -> Bar  and  type Bar = Int   return on  :t (undefined :: Foo)  the answer (undefined :: Foo) :: Int -> Int   ?
06:37:20 <Lajla> So, I was planning on bootstrapping malbolge, who's with me?
06:38:32 <aristid> :t (:)
06:38:34 <lambdabot> forall a. a -> [a] -> [a]
06:39:37 <zygoloid> Lajla: switch to befunge and i'm in
06:40:08 <Lajla> zygoloid, fill that gaping void in my ignorance will you.
06:43:57 <fasta> zygoloid, yes, there are certainly things which are not optimal.
06:44:17 <fasta> zygoloid, for example, I like the sequence protocol they have in Python.
06:44:35 <fasta> zygoloid, consistency in data structure APIs, but the actual language is fairly OK.
06:47:16 <_Cactus_> earthy: yes
06:49:08 <earthy> and you want that recursively, probably, as well
06:49:17 <_Cactus_> exactly
06:49:29 <_Cactus_> (are you leading me up to some kind of realization that it's stupid?:)
06:49:56 <earthy> so, eg: type Foo = Int, type Bar = Foo -> Foo, type Baz = Bar -> Foo, :type (undefined :: Baz) gives  (undefined :: Baz) :: (Int -> Int) -> Int
06:50:46 <earthy> not stupid, just doesn't exist by default.
06:51:40 <earthy> plus, 'you shouldn't want that'.
06:52:13 <earthy> (i.e.: the reason for the use of 'type' would disappear)
06:55:06 <_Cactus_> earthy: OK but for my uses (or, abuses...), the normalized type would be the result of a type-level computation
06:58:41 <earthy> cactus: ah! in that case you'd really want to do introspection using template haskell, as suggested earlier
06:59:12 <earthy> (plus, why are you using type synonyms in that case?)
06:59:49 <_Cactus_> earthy: what should I use instead of type synonyms in e.g. the following:
07:00:09 <earthy> (not that you shouldn't, just curious)
07:00:40 <_Cactus_> earthy: http://pastebin.com/Tffj2JLq
07:01:43 <Kaidelong> I saw this python advocate guy complaining that LISP is interpreted and is hard to deploy on other machines
07:01:57 <earthy> kaidelong: that's funny. :)
07:02:14 <Kaidelong> earthy: indeed, it's as true of Python as it is of LISP
07:02:36 <Kaidelong> earthy: he also complained that its syntax was too different from C
07:02:51 <earthy> let him stay away from haskell then :P
07:02:52 <Jafet> Actually, Common Lisp is often compiled.
07:03:06 <Jafet> I don't know if they've managed to compile that silly snake oil language yet.
07:03:09 <Kaidelong> Jafet: Yes, there are python compilers too, hence the analogy
07:03:16 <earthy> jafet: it's funny *because* it's more true the other way 'round. ;)
07:03:53 <EvanR-work> c syntax is great
07:03:55 <earthy> anyway... intermittant segfaults... yaaaay.
07:03:55 <EvanR-work> for c
07:03:57 <Jafet> Last time I checked, there isn't a non-trivial compiler for python.
07:04:09 <m_88> Hello, I have a question, can 'if' be used in haskell without 'else'?
07:04:14 <earthy> m_88: no
07:04:15 <EvanR-work> no
07:04:20 <m_88> hmm
07:04:23 <earthy> why?
07:04:24 <p_l> there was one partial compiler for x86 - psyco, there's unladen swallow project as well, and the only other compiler uses someone's compiler - namely JVM
07:04:26 <m_88> strange
07:04:33 <earthy> (and have you looked at unless?)
07:04:43 <EvanR-work> :t unless
07:04:44 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:04:54 <m_88> I want to write a simple grep function and no I haven't looked at unless
07:04:55 <Kaidelong> Jafet: I think that the compiler part is something of a technicality, a lot of the interpreter gets linked into the program to allow for things like type checking at run-time
07:04:57 <EvanR-work> unless and when, similar to if without else in a monad
07:04:58 <m_88> please excuse me
07:04:59 <sepp2k> m_88: What would it archieve?  x = if false then 42 -- What's the value of x now?
07:05:03 <Jafet> :t let if' a b c = if a then b else c in if'
07:05:03 <Kaidelong> it has been a while since I looked into that though
07:05:04 <lambdabot> forall t. Bool -> t -> t -> t
07:05:06 <m_88> i am a begginer
07:05:19 <m_88> sepp2k: 42?
07:05:19 <earthy> m_88: no problem.
07:05:29 <_Cactus_> earthy: sorry, my irc client crashed
07:05:32 <earthy> m_88: that's why I pointed you at what you *might* want
07:05:37 <p_l> Kaidelong: btw, the only interpreted-only common lisp I can recall is Clisp. LISP itself doesn't count, cause it's hard to argue about something from 60's :D
07:05:40 <earthy> cactus: guessed as much
07:05:41 <Jafet> Kaidelong, for python, yes, because they use it as a crutch. Lisp compilers do a lot of static type inference
07:05:49 <_Cactus_> earthy: I haven't seen if you replied anything after I pasted the pastebin url
07:05:56 <m_88> I wrote this so far: myGrep f list = [if ((f) x) then x else 0 | x <- list]
07:06:03 <earthy> cactus: I didn't, because you dropped off.
07:06:08 <Kaidelong> Jafet: I was talking about python, yes. I remember being impressed by SBCL, but I don't remember why
07:06:11 <m_88> so you say I should use unless here?
07:06:24 <p_l> Kaidelong: SBCL produces the fastest CL code, afaik.
07:06:33 <earthy> cactus: basically, you'd like to see the number of Add's expanded after a calculation, right?
07:06:36 <dpratt71> m_88: "if" is an expression; more like "IIF" from BASIC or the ternary operator (?:) from C/C++
07:06:37 <p_l> Kaidelong: it has, however, the slowest compiler :)
07:06:39 <_Cactus_> earthy: yes
07:06:43 <sepp2k> m_88: So you want "if foo then bar" to be equivalent to "if foo then bar else bar"?
07:06:45 <Jafet> Common Lisp is also designed for compilation (there are standard optimization directives)
07:07:05 <earthy> yeah, that'll require your own template haskell function.
07:07:11 <Kaidelong> p_l: time spent compiling isn't that big of a deal on the long run though is it?
07:07:21 <m_88> sepp2k: huh? sorry i didn't get you
07:07:34 <p_l> though the dynamic quality of the language means you can't do as much type inference as you could in Haskell (the type system is fully expressive, though)
07:07:36 <Kaidelong> p_l: compared to saving programming time and run time
07:07:44 <Jafet> Kaidelong, it isn't if you don't compile when developing (whereas you have to in languages like C)
07:07:44 <k23z__> does anybody in this channel know what this is -> http://i.imgur.com/0aBGp.png
07:07:45 <k23z__> ?
07:07:54 <p_l> Kaidelong: Well, SBCL is the most popular implementation on Linux :)
07:07:56 <k23z__> or this http://i.imgur.com/pXEmT.png
07:08:06 <EvanR-work> m_88: the if construct is an expression, it has to evaluate to something in particular, even if the condition is false
07:08:11 <sepp2k> m_88: "if false then 42" evaluating to 42 would mean that it doesn't matter whether the condition is true or false.
07:08:15 <EvanR-work> if theres no else, theres no 'answer'
07:08:21 <EvanR-work> undefined would not be good
07:08:27 <Kaidelong> p_l: I personally used CMUCL when I was running Linux, since that was what was recommended to me, but I never liked it very much
07:08:29 <Jafet> :t fromJust
07:08:30 <lambdabot> forall a. Maybe a -> a
07:08:55 <p_l> Kaidelong: SBCL forked from CMUCL in big part because CMUCL is a horror to bootstrap
07:09:01 <EvanR-work> > fromJust Nothing
07:09:01 <lambdabot>   *Exception: Maybe.fromJust: Nothing
07:09:10 <headcheck> not even compiling the platform from source helped
07:09:16 <EvanR-work> @src fromJust
07:09:16 <lambdabot> fromJust Nothing  = undefined
07:09:16 <lambdabot> fromJust (Just x) = x
07:09:16 <headcheck> i guess ill live without haskell
07:09:19 <Kaidelong> p_l: yeah, that's why binary distributions are excellent to keep around IMHO
07:09:24 <sepp2k> m_88: Note that inside a list comprehension you can just do [foo | foo <- bar, condition]
07:09:35 <m_88> sepp2k: oh thanks
07:09:35 <p_l> Kaidelong: to bootstrap CMUCL from zero you'd need to start with PDP-10, I believe.
07:09:39 <m_88> that's handy
07:09:44 * m_88 is a perl user
07:09:50 <Kaidelong> oh my
07:10:08 <Jafet> I bet they make judicious usage of 9-bit bytes
07:10:11 <EvanR-work> youre in luck, haskell is very obfuscatable
07:10:27 <Kaidelong> p_l: that's mind-boggling, but I suppose that's what legacy can do
07:10:28 <p_l> Kaidelong: each new version comes through making changes in the runtime of previous build, dumping it then rebuilding it again using dumpedimage
07:10:34 <m_88> EvanR-work: heh
07:10:45 <Jafet> That is the standard common lisp way of doing things
07:10:54 <p_l> Jafet: no, that's the Smalltalk way
07:10:59 <m_88> :t unless
07:11:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:11:08 <m_88> hmm
07:11:10 <p_l> Jafet: CL doesn't stop you from building stuff from files.
07:11:11 <m_88> is it in prelude?
07:11:22 <EvanR-work> Control.Monad
07:11:26 <Jafet> It probably goes back to MIT CSAIL, when you just dumped your ANN to disk
07:11:36 <m_88> oh monads..
07:11:53 <EvanR-work> you are doing a list comprehension, so i think unless (or when) wont help
07:12:01 <p_l> Jafet: MIT's MacLisp was very capable of compiling nicely from files and returning a binary (I got it running at some point)
07:12:11 <theorbtwo> It is, in general, the way of self-hosting systems, to a large degree.  Compiling gcc requires a C compiler, as well.
07:12:28 <p_l> theorbtwo: However, unlike SBCL, compiling GCC requires GCC
07:12:32 <Jafet> Sure, but common lisp is a prototypical example of the serializable REPL session
07:12:51 <illissius> @source Data.Foldable
07:12:51 <lambdabot> Data.Foldable not available
07:12:52 <theorbtwo> p_l: Yeah, I've heard that from somebody else as well, recently.
07:12:57 <illissius> @source Data.Foldable.Foldable
07:12:57 <lambdabot> Data.Foldable.Foldable not available
07:13:00 <illissius> hmm.
07:13:04 <m_88> EvanR-work: uhh, but I dont get it, there are many cases when you have to return a value only if some dependency is met
07:13:05 <Jafet> Only for the late stage. You can bootstrap it from another C compiler.
07:13:08 <p_l> Jafet: I think that style came more through LispMachines - PDP-10 were too expensive
07:13:19 <EvanR-work> m_88: not the right way to think of it
07:13:19 <theorbtwo> It used to be that all of gcc you needed to compile C was very carefully written to only require K&R C.
07:13:31 <EvanR-work> m_88: when you compute an answer, you always should get an answer. even if it is Nothing
07:13:41 <EvanR-work> m_88: if you want to 'maybe do an action' use when or unless
07:13:47 <p_l> Jafet: I heard that if your compiler doesn't have extra support for GCCisms, you have to go back to building 2.x series before you can build a modern GCC
07:13:48 <Jafet> I thought the lisp machines cost more (per model, not per ops)
07:13:53 <m_88> I want to return "nothing"
07:13:56 <EvanR-work> ok
07:14:09 <EvanR-work> then you need to check your types
07:14:14 <EvanR-work> :t Nothing
07:14:15 <lambdabot> forall a. Maybe a
07:14:20 <EvanR-work> :t Just 5
07:14:21 <p_l> Jafet: Even Symbolics 3600 was smaller, and I think cheaper, than DECSYSTEM-20
07:14:21 <lambdabot> forall t. (Num t) => Maybe t
07:14:22 <Jafet> p_l, ok. I never tried. They seem to be slowly fixing those dependencies, though
07:14:27 <theorbtwo> The normal way to bootstrap is to cross-compile a gcc from a modern gcc on the same archetecture.
07:14:37 <theorbtwo> Er, on a different arch, that is.
07:14:56 <EvanR-work> m_88: for data that may be something of type a or Nothing, use type Maybe a
07:15:12 <Jafet> @src Maybe
07:15:12 <m_88> uhh, that sounds complicated
07:15:12 <lambdabot> data Maybe a = Nothing | Just a
07:15:18 <p_l> Jafet: the big difference was that LispMachines were designed as "workstations", while PDP-10 and MULTICS were big mainframe/mini
07:15:21 <EvanR-work> its easy
07:15:22 <p_l> *supermini
07:15:24 <m_88> @src Nothing
07:15:25 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:15:29 <p_l> brb, coffee
07:15:29 <m_88> uh
07:15:31 <Jafet> PDP-10 wasn't that big, but you're right
07:15:39 <EvanR-work> m_88: use this instead
07:15:42 <EvanR-work> @src Maybe
07:15:42 <lambdabot> data Maybe a = Nothing | Just a
07:15:50 <EvanR-work> its a data type
07:16:10 <m_88> uhh ok i'm trying to understand it
07:16:37 <aristid> i wonder how many copies rwh sold.
07:16:45 <EvanR-work> > let f Nothing = "OK!"; f (Just x) = show x in f Nothing
07:16:46 <lambdabot>   "OK!"
07:16:51 <EvanR-work> > let f Nothing = "OK!"; f (Just x) = show x in f (Just 6)
07:16:52 <lambdabot>   "6"
07:16:53 <Kaidelong> what it is saying is that an "something Maybe" is either a "Nothing" or a "something Just"
07:17:13 <_Cactus_> earthy: so I'm looking for a TH API that, given an Exp, gives me its Type?
07:17:42 <EvanR-work> > fromMaybe 99 Nothing
07:17:42 <lambdabot>   99
07:17:47 <EvanR-work> > fromMaybe 99 (Just 6)
07:17:47 <lambdabot>   6
07:18:09 <aristid> > fromMaybe id (Just . (+) $ 2) $ 4
07:18:11 <lambdabot>   6
07:18:24 <m_88> > Nothing (Just 0)
07:18:25 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t1 -> t'
07:18:26 <lambdabot>         against inf...
07:18:32 <EvanR-work> Nothing takes no arguments
07:18:35 <Kaidelong> :t Nothing
07:18:35 <lambdabot> forall a. Maybe a
07:18:39 <Kaidelong> :t Just
07:18:39 <lambdabot> forall a. a -> Maybe a
07:18:50 <earthy> cactus: roughly spoken, yes.
07:19:03 <earthy> maybe even a ghc-as-a-library API
07:19:25 <earthy> as you may need to do inference... :)
07:19:32 <Kaidelong> :t [Nothing, Just 5]
07:19:33 <lambdabot> forall a. (Num a) => [Maybe a]
07:19:56 <Jafet> @quote jafet succ
07:19:57 <lambdabot> No quotes match. The more you drive -- the dumber you get.
07:20:06 <c0sine> hello i'm new
07:20:17 <Jafet> @quote Jafet succ
07:20:18 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
07:20:19 <c0sine> i was wondering
07:20:40 <Jafet> It should be case-insensitive...
07:20:42 <m_88> ok so Nothing is a monad?
07:20:44 <c0sine> haskell is good for multiple core use?
07:20:51 <theorbtwo> > (.)(.) id const succ 5$ 0xb00b135
07:20:52 <lambdabot>   6
07:21:32 <silver> c0sine, yeah sure
07:21:59 <c0sine> well i'm trying to find a good language to work with some bioinformatics stuff
07:21:59 <EvanR-work> m_88: Maybe is an instance of a monad, but that just means it has certain features were not discussing at the moment
07:22:06 <c0sine> just some hobby things right now
07:22:16 <c0sine> i was leaning toward python, but i read up on haskell
07:22:25 <m_88> EvanR-work: i dont want to dive into monads atm
07:22:33 <c0sine> and it seems like its got really great multithreading support
07:22:36 <m_88> god this is p hard for a new user
07:22:43 <c0sine> i don't even know if i'm phrasing this properly
07:22:50 <EvanR-work> m_88: you dont need to do monads yet
07:22:51 <nlogax> m_88: you can just dive into Maybe :)
07:22:59 <m_88> ok googling it
07:23:03 <aristid> m_88: monads aren't that bad, honestly
07:23:21 <EvanR-work> the whole maybe monad thing often obscures new users view of maybe
07:23:30 <EvanR-work> Maybe
07:23:36 <earthy> Maybe is *really* really simple.
07:23:49 <rovar> is there a function out there like a parallel forM which will execute the function for each item in the list in parallel then collect the results?
07:24:04 <dpratt71> m_88: I interpret the Maybe data type (data Maybe a = Nothing | Just a) this way:
07:24:06 <rovar> s/parallel/concurrent if it pleases you
07:24:19 <dpratt71> "data" it's a data type (obvious)
07:24:24 <m_88> yeah
07:24:30 <EvanR-work> data Color = Red | Green | Blue
07:24:34 <rovar> i was planning on writing one, but it seems simple enough that someone has to have published one
07:24:34 <dpratt71> "Maybe" the name of the type is "Maybe"
07:24:45 <silver> c0sine,  python isn't very good for parallel stuff as I heard
07:24:49 <silver> but I might be wrong
07:24:58 <m_88> Nothing is a constructor?
07:25:02 <EvanR-work> yes
07:25:06 <dpratt71> "a" this is a type placeholder; in this case it's a stand-in for any other type
07:25:11 <c0sine> i saw they had a lot of confusing libraries for it
07:25:15 <m_88> and Just x is a consturctor which takes 1 argument?
07:25:20 <EvanR-work> yes
07:25:25 <dpratt71> "=" what follows are the data constructors, seperated by "|"
07:25:32 <c0sine> i'm not a programmer, just a biologist
07:25:43 <theorbtwo> Nothing is a constructor, it constructs a value of type Maybe a.
07:25:43 <c0sine> i like this haskell though so far
07:25:52 <c0sine> looks perfect for what i need
07:25:59 <theorbtwo> c0sine: Haskell is a great programming languge for people who know math better then programming.
07:26:00 <c0sine> really what i wanted to ask i guess
07:26:01 <dpratt71> "Nothing" a data constructor that takes no parameters and constructs a value of type "Maybe"
07:26:26 <c0sine> have any of you made programs that really make use of parallel processing?
07:26:37 <earthy> rovar: parTraverse from Control.Parallel.Strategies seems to come to mind
07:26:50 <rovar> earthy, I'll have a look, thanks.
07:26:57 <dpratt71> "Just a" a data constructor taking one parameter (of any type) and constructs a value of type "Maybe"
07:27:35 <Kaidelong> c0sine: I am writing a blog entry on parallel programming right now, so I've learned a bit about how it works on haskell.
07:27:52 <Kaidelong> I've been writing parallel algorithms in F# for a while, but my knowledge there is out of date to some degree now
07:28:04 <m_88> Yeah I get all this, but I still can't think of how to use it
07:28:04 <Jafet> c0sine, currently ghc can multithread implicitly and you can instantiate both userspace threads and pthreads. It doesn't parallelize for clusters, though, like what you get with openmp and such
07:28:05 <c0sine> that's cool I'd like to read it
07:28:09 <theorbtwo> dpratt71: Of type Maybe a, please.
07:28:09 <dpratt71> the type of value passed to the "Just" constructor will be reflected in the type of "Maybe"
07:28:19 <dpratt71> theorbtwo: right
07:28:26 <c0sine> thanks everyone for the feedback
07:28:44 <EvanR-work> m_88: well, you just use the constructors directly and use pattern matching to decide what to do if the answer is Nothing or Just something
07:28:46 <Jafet> c0sine, haskell also doesn't have much of a history for numerical computing, so expect to run into some issues
07:28:57 <EvanR-work> m_88: theres also some utility functions in Data.Maybe
07:29:04 <EvanR-work> can cut down on some of that pattern matching
07:29:05 <c0sine> sounds good
07:29:18 <Kaidelong> Jafet: I did not know of that. From what I understood you have to enable the concurrent extensions for GHC with a compiler option, and then write your parallel algorithms explicitly
07:29:24 <EvanR-work> @src fromMaybe
07:29:24 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
07:29:36 <EvanR-work> @src maybe
07:29:36 <lambdabot> maybe n _ Nothing  = n
07:29:36 <lambdabot> maybe _ f (Just x) = f x
07:29:48 <Kaidelong> Jafet: my understanding was that implicit concurrency is inherently in conflict with non-strict evaluation
07:29:55 <Kaidelong> err
07:29:59 <m_88> oh hold on please
07:30:00 <Kaidelong> implicit parallelism
07:30:19 <Jafet> Sorry, I meant implicit parallelism, not threading (although it is implemented with threads, of course)
07:30:20 <dpratt71> I always think of "Maybe" values as akin to reference types from my native language of C# :)
07:30:44 <Kaidelong> dpratt71: that'd be an IORef, I believe
07:30:47 <Jafet> ghc's sparks now use multiple threads, although I don't know how much you win in practice
07:31:10 <rovar> wow, Parallel.Strategy is a bit of a commitment
07:31:36 <Kaidelong> dpratt71: if you look into F#, they have something like a maybe called an option, but they're value types. The reference type is a data type called ref, and the two are quite different
07:31:47 <m_88> Prelude> maybe 0 (+2) Nothing
07:31:47 <m_88> 0
07:31:47 <m_88>  
07:31:49 <m_88> you see
07:31:50 <Kaidelong> dpratt71: You could think of a Maybe as being nullable, though
07:31:54 <m_88> i dont want it to return 0
07:32:00 <m_88> if want it to return nothing
07:32:10 <m_88> aka no return
07:32:17 <dpratt71> Kaidelong: I was referring to the semantics of having something that may or may not contain a value
07:32:37 <EvanR-work> m_88: you want to make a list where the contents satisfy a certain property
07:32:58 <Kaidelong> dpratt71: right, in C# a lot of things are nullable by default, I think they have added non-nullable fields since, though
07:33:00 <EvanR-work> so you can use filter, or a list comprehension with a condition
07:33:17 <EvanR-work> thats unrelated to Maybe
07:33:52 <m_88> ok so who told me to use Maybe?
07:33:53 <m_88> fff
07:33:56 <EvanR-work> me
07:33:59 <Saizan> the difference is that nullable field are not distinguished at the type level from normal values
07:34:18 <m_88> EvanR-work: umm but why you did it?
07:34:18 <EvanR-work> m_88: its about context, i was talking in general. all functions must produce a value. theres no such things as 'no return'
07:34:19 <Kaidelong> > [x | x <- [1..], even x]
07:34:19 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
07:34:37 <ikke> > [x | x <- [1..], odd x]
07:34:38 <EvanR-work> m_88: you in particular dont actually want 'no return' you want a filtered list right?
07:34:38 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:34:54 <m_88> EvanR-work: yeah i can do that by this: myGrep f list = [x | x <- list, (f) x]
07:34:56 <ikke> > zip [x | x <- [1..], odd x] [x | x <- [1..], even x]
07:34:57 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
07:35:07 <m_88> but I was just trying to get this whole idea...
07:35:24 <Kaidelong> ikke: you could do that with one list comprehension
07:35:25 <EvanR-work> your way is good
07:35:27 <m_88> Ok, thanks now I think Im getting it
07:35:29 <ikke> > flatten zip [x | x <- [1..], odd x] [x | x <- [1..], even x]
07:35:30 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
07:35:30 <lambdabot>         against inferred ty...
07:35:46 <ikke> > flatten (zip [x | x <- [1..], odd x] [x | x <- [1..], even x])
07:35:47 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
07:35:47 <lambdabot>         against inferred ty...
07:35:50 <ikke> dman ;|
07:36:02 <m_88> also, just reading mans are not really helping - can someone give me some semi-interesting exercises for "begginer" level?
07:36:06 <Jafet> > map (pred.(*2) &&& (*2)) [1..]
07:36:08 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
07:36:26 <Kaidelong> m_88: you are interested in parallel programming in particular?
07:36:30 <EvanR-work> m_88: by th way, your list comprehension reduces to the simpler expression... filter f list
07:36:40 <Kaidelong> m_88: re-implementing a strict fold might be a good idea for that
07:36:41 <m_88> Kaidelong: not really
07:36:45 <Kaidelong> ah okayt
07:36:47 <fasta> m_88, just try to write an actual application or find the exercises of some university courses.
07:37:01 <Saizan> or use the ones from RWH
07:37:04 <bremner> @lyah
07:37:04 <lambdabot> Unknown command, try @list
07:37:10 <Jafet> @src foldl'
07:37:10 <lambdabot> foldl' f a []     = a
07:37:10 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:37:12 <m_88> EvanR-work: yeah i was just trying to make my own version of some common functions
07:37:47 <m_88> fasta: yeah but I can't think of any, plus it would be a better idea to ask gurus about that, since i am a newbie
07:39:04 <Kaidelong> m_88: how about k nearest neighbors?
07:39:16 <Kaidelong> that's a simple enough project
07:39:30 <m_88> neighbors what?
07:39:36 <Jafet> Depends on the number of dimensions.
07:39:36 <nlogax> m_88: i'm having fun with this: http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html i find it reasonably noob-friendly
07:39:49 <Kaidelong> http://en.wikipedia.org/wiki/K-nearest_neighbor_algorithm
07:39:54 <m_88> k thanks
07:40:19 <Kaidelong> err that wikipedia article is a little verbose
07:40:19 <Jafet> Hmm, a persistent knn data structure would be useful. I don't know if it exists
07:40:39 <fasta> m_88, learning without purpose doesn't really work, imho.
07:41:02 <m_88>  nlogax: that would be too hard for me
07:41:13 <Kaidelong> basically what k-NN is is where you have a bunch of vectors, measure the distance between them, and use the closest ones to vote on which target category your vector belongs to
07:41:23 <m_88> fasta: i know, that's why I am asking for ideas. Or you mean some "final" target?
07:41:32 <Kaidelong> works best for binary classification but can be used for more than 2 classes
07:41:33 <fasta> k-NN is a beginners exercise for people learning Prolog.
07:41:43 <fasta> (assuming they can already program)
07:41:57 <scree> Jafet: how exactly would you want that to perform?
07:42:05 <fasta> m_88, yes, some sort of life goal.
07:42:15 <Jafet> scree, what do you mean?
07:42:41 <jmcarthur> good grief the shootout is such bullcrap
07:42:48 <scree> Jafet: your persistent knn data structure.  I guess I mean "could you elaborate"
07:42:56 <theorbtwo> jmcarthur: How so?
07:43:03 <Jafet> It should have similar complexity to the non-persistant variants, naturally
07:43:04 <jmcarthur> why does k-nucleotide require a hash table, for example?
07:43:06 <m_88>  fasta: can't say that it's a life goal, but writing a complex irc bot would be fun
07:43:06 <dino-> Who would I address to ask about hackage build issues?
07:43:18 <Jafet> jmcarthur, old news
07:43:23 <jmcarthur> Jafet: i know
07:43:26 <Jafet> Haskell still does well on that, doesn't it
07:43:35 <m_88> ok I g2g, thank you guys
07:43:41 <fasta> m_88, so, are you already an expert IRC user?
07:43:41 <jmcarthur> i just keep seeing people use the shootout as data to argue with
07:43:45 <Kaidelong> scree: presumably a set of labelled vectors for which there is a function that can take such a set and an unlabeled vector and return a label for it
07:43:50 <jmcarthur> Jafet: it does okay
07:43:54 <m_88> fasta: yeah, pretty much
07:43:55 <Jafet> Although Haskell will probably die on a real data set
07:44:03 <Jafet> Where I meant ghc
07:44:04 <jmcarthur> 6.12 had a regression compared to 6.10 i think
07:44:35 <jmcarthur> i find that haskell tends to do better on realistic problems than contrived ones with stupid implementation restrictions
07:44:41 <Kaidelong> jmcarthur: you can contribute another solution to the shootout
07:44:42 <fasta> m_88, ok, well, then you find a library which already does that, and you try to use it. Every time you don't get what's going on, you read a chapter from a book that handles that after you have read the Haskell 98 report.
07:45:00 <fasta> m_88, there is no need to understand everything from the report the first time, but everyone should have read it.
07:45:06 <jmcarthur> Kaidelong: my beef is with the shootout itself
07:45:06 <Jafet> Kaidelong, the shootout benchmarks hash tables, which are something Haskell programmers usually don't care about
07:45:15 <Kaidelong> ah
07:45:23 <m_88> wait, you want me to read all haskell 98 docs without doing actual coding?
07:45:41 <Jafet> However, a lot of people have the misconception that it benchmarks the general performance of the implementation.
07:45:51 <Jafet> So perhaps jmcarthur's beef is with those people.
07:45:52 <jmcarthur> also stupid things like requiring strict data types
07:45:57 <soupdragon> m_88, what's up?
07:46:09 <jmcarthur> Jafet: yes, that is my main beef
07:46:18 <Jafet> I don't really see how lazy types help with that particular shootout
07:46:22 <m_88> umm hi soupdragon
07:46:22 <jmcarthur> the shootout itself even says it's not realistic
07:46:33 <m_88> 202k gziped
07:46:42 <Kaidelong> Jafet: seems like a better design for some general shootout would be one where implementation details are left up to the programmer
07:46:49 <jmcarthur> Jafet: well, for example, the binary tree benchmark could run in pretty much constant memory if lazy structure was allowed
07:46:56 <Jafet> There is no such thing as a general shootout...
07:47:19 <Kaidelong> talking hypothetically here
07:48:22 <jmcarthur> i wish there was a shootout that simply asks for a solution to a problem and includes subjective ratings of how idiomatic the code is
07:48:37 <jmcarthur> along with the usual time, memory, code size measurements
07:49:03 <jmcarthur> would require some honesty from the language communities for the idiomatic requirement
07:49:37 <Kaidelong> jmcarthur: another problem is that people often simply don't want to understand what they are looking at when looking at something like J, Haskell, LISP etc
07:49:39 <fasta> m_88, the report, which is about the standard library which is very basic.
07:49:44 <Kaidelong> and thus succeed
07:49:52 <m_88> fasta: http://haskell.org/haskellwiki/Definition ?
07:49:53 <fasta> m_88, the C++ standard is much bigger.
07:50:14 <fasta> m_88, http://haskell.org/definition/haskell98-report.pdf
07:50:20 <m_88> fasta: i never read it completely tbh
07:50:21 <jmcarthur> Kaidelong: shoot, *i* don't want to understand J ;)
07:50:22 <fasta> @where report
07:50:22 <lambdabot> http://www.haskell.org/onlinereport/
07:50:34 <m_88> fasta: i was justlooking at it when i need any help
07:50:37 <jmcarthur> well, i do, but i don't want to work for it :P
07:51:06 <m_88> ok really going now
07:51:06 <Kaidelong> jmcarthur: it does seem well designed, unlike say, MUMPS
07:51:11 <m_88> thanks again
07:51:26 <jmcarthur> never heard of MUMPS. at least i've heard of J
07:51:31 <Kaidelong> jmcarthur: I do find it hard to read though, and I'm not big on memorizing idioms, which seems to be something you do when learning J
07:51:44 <Kaidelong> MUMPS is a database programming language that a lot of medical people use
07:51:47 <Kaidelong> it is nightmarish
07:51:57 <p_l> Kaidelong: at least in its original form...
07:52:46 <Kaidelong> p_l: a lot of the reason why people use it in the first place is legacy though, so people who work on it on the job are often looking and working with old MUMPS stuff
07:53:08 <Kaidelong> I knew two guys who did that and they were scared of it ruining their careers
07:53:54 <Kaidelong> basically going "I get to put MUMPS on my resume... which means I get to work with more MUMPS..."
07:55:10 * p_l learned to remove stuff from his resume and then prepare to answer bad questions about "what is that blank space"?
07:57:07 <earthy> technology can be easily removed
07:57:23 <noteed> :
07:57:34 <earthy> by specifying what functionality was implemented, rather than what technology the functionality was implemented in
07:57:58 <Kaidelong> earthy: I think the issue is cost, organizations that made the investments while they were more lucrative may not want to retool
07:58:39 <Kaidelong> it seems weird though when you have to do things like hire COBOL programmers from South Africa and pay them huge salaries because you don't want to change your hardware
07:58:55 <Kaidelong> or your existing code base
07:59:15 <earthy> knowing COBOL and willing to wrangle with it does command a premium these days, yes
07:59:33 <earthy> that is not what I was hinting at
07:59:51 <earthy> the part 'willing to wrangle with it' may have turned into 'not willing to'
07:59:53 * p_l is not exactly sure if he wouldn't be willing to learn COBOL and code on mainframes instead of applying into Java work.
08:00:11 <earthy> in that case a resume can easily be scrubbed of all mentions of COBOL.
08:00:23 <Kaidelong> well they're actually using Java now for a lot of mainframe work I think
08:00:29 <Kaidelong> ever since IBM started to push java
08:00:32 * earthy nods
08:00:51 <earthy> java is turning into the new cobol
08:01:21 <earthy> but even then... some systems are stuck in Java 1.4.2 land.
08:01:23 <theorbtwo> Nobody wants to code java, but it's the standard anyway?
08:01:37 <earthy> theorbtwo: more or less. but for the 'nobody' part. ;)
08:01:48 <Kaidelong> theorbtwo: Java does have some rather nice things about it, particularly the documentation
08:01:58 <earthy> plus, there's loads and loads and loads of tools for java
08:02:05 <earthy> which helps. a lot.
08:02:05 <Kaidelong> I wouldn't call working with it a "joy" but it certainly is not that bad at all
08:02:13 * earthy nods
08:02:14 <Kaidelong> good tool support is important
08:02:22 <Kaidelong> haskell does not have it and this is a huge problem
08:02:22 <theorbtwo> Strange.  I always found java docs to be a maze of twisty passages, all of which defer definitions to somewhere else.
08:02:33 <earthy> java as a language isn't all that rich. java as an ecosystem however *is*.
08:02:36 <mornfall> Kaidelong: It's getting better in the Haskell-land.
08:02:52 <earthy> plus, you need less of the tooling in haskell land
08:02:57 <Kaidelong> haskell could also use some better documentation, I think a lot of the problem is one of haskell's strengths (generality) working against it
08:02:57 <soupdragon> Java is a great language which everyone can benefit from mastering
08:03:02 <soupdragon> So is haskell
08:03:16 <Kaidelong> how do you document a concept like an arrow in a way that helps someone immediately write their application?
08:03:16 <mornfall> Although admittedly, a window manager is not exactly the first thing you need for a programming language. : - P
08:03:27 <soupdragon> The worst thing you can do as a programmer is close your mind and say "blerfddr $language sucks"
08:03:38 * p_l finds Java too similar to multiple other languages, so he considers it a case "learn one, jump into any"
08:03:51 <soupdragon> (except for PHP)
08:03:54 <mornfall> soupdragon: That doesn't make Java suck any less. :D
08:04:02 <danharaj> Every language sucks.
08:04:07 <Kaidelong> soupdragon: I disagree, there are some languages that are just light variations on other languages and probably not worth looking at
08:04:10 <earthy> theorbtwo: contrast the java docs to the .net docs
08:04:22 <Kaidelong> .NET docs are getting better
08:04:24 * p_l can't deal with lack of nice, short-syntax lambdas in Java
08:04:51 <mornfall> p_l: Java is not known for being terse.
08:04:58 <Kaidelong> p_l: that does make me cry since they're so useful and java's alternative is really, really ugly
08:05:28 <Kaidelong> you have to make some anonymous class that has a method in it
08:05:33 <mornfall> p_l: You shouldn't hoard that couple of lines...
08:05:36 <Kaidelong> instantiate it and pass it
08:05:45 <p_l> mornfall: if they could have at least done event binding like it was done in Delphi... but no, sometimes you really need to write all the event handling stuff.... (Swing...)
08:05:47 <Kaidelong> reciever calls the method of the class to get the lambda
08:06:16 <mornfall> But, whatever happened to haskell? :)
08:06:27 <mornfall> Don't make Java, make Haskell.
08:06:31 * earthy is
08:06:43 <earthy> and breaking his head
08:06:48 <Kaidelong> I do prefer Haskell as a language
08:07:03 <earthy> but some stuff I don't like writing in *any* language
08:07:06 <earthy> (e.g. GUI's)
08:07:21 <earthy> and then toolsupport helps loads...
08:07:29 <mornfall> Haskell may as well be the language that stifled my ambitions to design a language.
08:07:33 <Kaidelong> I just wish it had better tool support, better docs, and did have so much trouble with things like GUI libraries
08:07:38 <Kaidelong> did not*
08:07:52 * quicksilver has never had any trouble with WX
08:07:53 <fryguybob> Perhaps I'm an exception, but I've never had a problem finding something in the .NET docs, I've never found anything I wanted in the Java docs.  For Haskell, I find what I wan't but don't understand the concept for a couple of days.
08:08:03 <theorbtwo> Kaidelong: There's a lot of "so fix it then" there.
08:08:33 <aavogt> what, type signatures aren't sufficient?
08:08:37 <theorbtwo> ghc-as-library seems like a great place to begin writing tools.
08:08:41 <mornfall> (That may actually be a great motto. "Haskell -- The language *you* would have designed..."
08:08:45 <mornfall> )
08:08:48 <Kaidelong> theorbtwo: alas, coming out of .NET I don't have the skills to go in and help there, much, except maybe with some of the tool support
08:08:52 <theorbtwo> aavogt: Good god, no.
08:09:11 <dpratt71> mornfall: not that there was any real danger of me going through with it, but I feel likewise
08:09:14 <Kaidelong> learning enough to contribute is an ambition of mine, though
08:09:16 <aavogt> @quote signature.*doc
08:09:17 <lambdabot> No quotes match. That's something I cannot allow to happen.
08:09:18 <theorbtwo> Kaidelong: I expect it is a very good way of making MS tools support Haskell better.
08:09:22 <aavogt> @quote doc.*signature
08:09:22 <lambdabot> No quotes match. My brain just exploded
08:09:28 <EvanR-work> mornfall: i stopped trying to design languages sometime after learning haskell
08:09:44 <theorbtwo> Kaidelong: Also, take your favorite .NET tool, try to find an equivelent Haskell tool, and if you can't, start hacking.
08:09:46 <EvanR-work> everything i wanted to 'do right' was done already
08:09:49 <Kaidelong> theorbtwo: F# w/ winforms could be "cross-platform" enough through mono I suppose
08:10:29 <dpratt71> ah, F#...I would probably have really loved you, but I saw Haskell first
08:10:31 <Kaidelong> perhaps not a bad project
08:10:43 <Kaidelong> F# does some things really nicely
08:10:56 <EvanR-work> not to mention haskell has stuff i didnt know i wanted. like lazy evaluation
08:10:59 <Kaidelong> asynchronous workflows and Array.Parallel spring to mind immediately
08:11:23 <aavogt> what is asynchronous about a workflow?
08:11:37 <thoughtpolice> F# is pretty cool, and don syme seems like a really smart guy
08:11:48 <thoughtpolice> apparently he works down the hall from SPJ so they talk quite often :)
08:12:21 <aavogt> so you want g to give results as soon as possible given   f |> g ? (or whatever you call >>= in F#)
08:12:33 <Kaidelong> aavogt: asynchronous workflows are these things that return a value, but don't immediately, so the program does not block when you run them
08:12:35 <dpratt71> Mr. Syme should ask SPJ how to get rid of that "value restriction" business
08:12:52 <Saizan> "make your language pure"
08:12:55 <Kaidelong> aavogt: I think Control.Parallel.Strategies has some similar ideas
08:13:11 <dpratt71> Saizan: yeah, I think that's about it
08:13:19 <thoughtpolice> good luck doing that with F#
08:13:31 <Kaidelong> F# was not meant to be pure
08:13:41 <Kaidelong> that has some advantages and some disadvantages
08:13:55 <thoughtpolice> syme wrote a haskell compiler for .net, but according to him using anything but the most trivial of libraries out of the BCL was painful and full of IO
08:14:00 <thoughtpolice> so he instead set off to write F#
08:14:05 <thoughtpolice> and I think he did pretty good :)
08:14:12 <Kaidelong> I would not want to do something like work with COM in haskell, it's bad enough that I have to coerce types for F#
08:14:32 <Kaidelong> but in haskell I'd have to worry about things like evaluation order and when it actually interacts with the COM application
08:14:45 <Kaidelong> well, I suppose you'd do it all in the IO monad
08:14:48 <theorbtwo> Kaidelong: That's a shame; that's one of the projects I would have thought you could do.
08:14:51 <Kaidelong> where that doesn't matter anymore
08:14:57 <aavogt> Kaidelong: so how do you know where your code actually blocks when your resource isn't available yet?
08:15:02 <thoughtpolice> Kaidelong: that's basically what it came down to, according to syme
08:15:14 <thoughtpolice> and nobody really likes an interface like that for 99% of their code writing
08:15:17 <aavogt> the first place you try to use that value?
08:15:18 <thoughtpolice> especially in haskell :/
08:15:30 <Kaidelong> aavogt: Good question actually, I can't answer it
08:15:58 <Kaidelong> I suppose it's somewhat analogous to "call by need", you block only when you absolutely need to block.
08:16:04 <theorbtwo> Given parallelisim, hopefully, by the time you try to use it, it'll already be computed.
08:16:05 <earthy> actually, interfacing to COM from haskell has been done
08:16:21 <Kaidelong> earthy: but is it easy?
08:16:24 <earthy> http://www.haskell.org/hdirect/
08:16:27 <Kaidelong> I mean, compared to doing it in F#
08:16:29 <theorbtwo> earthy: Interfacing to CLR facilities, then.
08:16:45 <thoughtpolice> if you want .net in haskell, the hs-dotnet library is pretty awesome looking IMO
08:17:12 <fryguybob> I tried hs-dotnet and couldn't get it to work.
08:17:14 <thoughtpolice> i've never gotten it successfully working though, I should ruthlessly bug sigbjorn
08:17:14 <Kaidelong> .NET is quite a different animal from COM
08:17:21 <thoughtpolice> fryguybob: yeah :/
08:17:28 <fryguybob> It seemed like one of the arguments was swapped in the FFI call.
08:17:35 <thoughtpolice> fryguybob: heh
08:17:41 <fryguybob> I didn't have time to try it swapped the other way though.
08:17:43 <theorbtwo> Hm.  10-year-old project, hasn't been updated in 6 years.
08:18:04 <earthy> theorbtwo: well, yes, Daan Leijen got bored with it and hired by Microsoft
08:18:16 <theorbtwo> Ah.
08:19:14 <Kaidelong> My current ambitions as a contributor is to get a blog going to provide supplementary material that I feel should be covered better (or at all) in things like Real World Haskell
08:19:22 <thoughtpolice> writing COM shit is definitely something I wouldn't want to do anyway, even in haskell :P
08:19:51 <thoughtpolice> I think my only real interaction with com was when I set out to detect running .NET processes on a machine, and good god was the COM interface brutal and made me hate the world
08:20:04 <thoughtpolice> and this is like a 30 line trivial program
08:20:14 <jmcarthur> haskell jobs. i want them. i should put together a resume
08:20:23 <Kaidelong> thoughtpolice: there comes a point where you have to do it, in my case it was to interact with R on a scientific little thing I was writing as part of my research work
08:20:32 <fryguybob> thoughtpolice: It seemed like a C++/CLI wrapper would have been a much better option for hs-dotnet than COM, but there was some comment in the code on how that had issues.
08:20:46 <Kaidelong> In came COM, and I wrote most of it in C#, with some higher level things in F#
08:21:01 <Kaidelong> I always tend to write more C# anyway just because F# is so concise
08:21:09 <dpratt71> thoughtpolice: the only thing I will say about that is that many COM APIs are strongly influenced by the language/framework used to implement them
08:21:39 <thoughtpolice> jmcarthur: mmmmhmmm. i would like to help GHC more in particular, but I'll be damned if I'm not already busy
08:21:41 <theorbtwo> s/COM //.
08:22:17 <thoughtpolice> Kaidelong: what things do you think should be in RWH?
08:22:38 <jmcarthur> there are openings to work on ghc? or do you just mean you wish there were?
08:23:01 <Kaidelong> thoughtpolice: I don't quite know yet, I have some ideas going though, was thinking of doing a post on genetic algorithms in haskell or elaborating more on ways to use parallelism
08:23:06 <thoughtpolice> I've thought perhaps we should have a 'Real World Oleg', where the purpose of the book is to embed GHC's typechecker into your brain similar to how oleg has already done, giving you power you didn't know existed (even in haskell 98!)
08:23:20 <Kaidelong> thoughtpolice: basically, non-trivial applications
08:23:25 <thoughtpolice> jmcarthur: no, I would like to help GHC because if I were to apply for a haskell job, it would probably look good :)
08:23:31 <jmcarthur> ah i see
08:23:42 <thoughtpolice> and because for example, the amount of windows hackers on GHC is painfully low
08:23:52 <Kaidelong> thoughtpolice: plan is to update once every two months and make relatively long and detailed posts, already working on the two I mentioned
08:24:07 <Kaidelong> I'll post it here when I get the first one out, I suppose
08:24:08 <thoughtpolice> I don't really like windows as much as the next guy, but considering such a huge portion of users use windows, it's a known problem that should be fixed
08:24:16 <jmcarthur> ah, yeah, we need more windows support
08:24:22 <thoughtpolice> or at least addressed with lots of swearing and hacking at GHC
08:24:30 <thoughtpolice> probably more of the latter :P
08:24:46 <Kaidelong> seconded, although I like linux a lot I am effectively stuck on windows for various school and driver related reasons
08:24:51 <aavogt> thoughtpolice: so that's just a collection of oleg's writings?
08:25:05 <jmcarthur> as i would like to get into game development full time some day, having haskell work as well as possible with as many platforms as possible would be very good for me
08:25:12 <aavogt> I mean, those are already quite readable with motivating examples...
08:25:12 <jmcarthur> game development using haskell, that is
08:25:15 <jmcarthur> indie games, clearly ;)
08:25:19 <thoughtpolice> aavogt: it would probably be more of a meditation ritual combined with building your spiritual type-checking ability
08:25:48 <Kaidelong> jmcarthur: I read some papers on it. Apparently it is not clear that declarative game development is "better" yet although it could be made better.
08:25:59 <Kaidelong> That was the gist of what I understood, anyway
08:26:05 <thoughtpolice> aavogt: i will happily say that about 80% of the stuff on oleg's site still instantly = mind blown
08:26:05 <soupdragon> @oies 1,11,14641
08:26:06 <lambdabot>  a(n) = 11^(n^2).
08:26:06 <lambdabot>  [1,11,14641,2357947691,45949729863572161,108347059433883722041830251,3091268...
08:26:18 <jmcarthur> Kaidelong: i will first work on a polished FRP implementation and some declarative graphics code :)
08:26:47 <jmcarthur> Kaidelong: i'm curious though, what papers did you read?
08:26:51 <aavogt> @hackage liboleg
08:26:52 <lambdabot> http://hackage.haskell.org/package/liboleg
08:27:00 <Kaidelong> errrm, one was an undergraduate thesis on an FPS
08:27:09 <jmcarthur> Kaidelong: frag?
08:27:12 <thoughtpolice> I somewhat agree with time sweeney, there needs to be a language that doesn't look like ass (C++) but with more safety features, like haskell
08:27:17 <thoughtpolice> s/time/tim/
08:27:24 <jmcarthur> yeah tim sweeney is the man
08:27:25 <Kaidelong> jmcarthur: I think that was it
08:27:53 <jmcarthur> Kaidelong: yeah, i wouldn't say frag was quite the code style i'll be going for
08:28:35 <thoughtpolice> aavogt: oh yes, it's just that some of his papers are more confusing than others
08:29:25 <thoughtpolice> aavogt: in particular I appreciate a lot of oleg's work like iteratees and 'implicit configurations'
08:29:38 <Blkt> could any one explain me why a definition like "add' x y = x + y" can't be applied to a single argument only, like in "add 1"?
08:29:41 <thoughtpolice> oh, and monadic regions of course!
08:29:59 <jmcarthur> monadic regions are pretty cool
08:30:16 <thoughtpolice> jmcarthur: tim has got a lot of good ideas on a language that should be in the games industry
08:30:37 <thoughtpolice> jmcarthur: i would like to talk to him about it sometime, maybe I can catch him in a thread on LtU ;)
08:31:06 <jmcarthur> thoughtpolice: i read at the end of one of his slideshows that haskell is not that language though :(
08:31:07 <byorgey> Blkt: it can.  are you getting some sort of error?
08:31:18 <jmcarthur> but i think he's just being superficial ;)
08:31:36 <thoughtpolice> jmcarthur: but I particularly agree with his notions that 1) a language like haskell is a more difficult offer to most programmers, simply because it *looks* so different, and that is a barrier to entry. so something that looks more like C++, but doesn't have a specification that is complete ass and a language that doesn't look like total shit
08:31:56 <aavogt> does haskell look so much different when you use {;}?
08:31:59 <Blkt> byorgey: yes, I get "No instance for (Show (t -> t)) blabla"
08:32:05 <soupdragon> hey byorgey have ysou seen this site http://mathpages.com/home/kmath400.htm
08:32:13 <jmcarthur> thoughtpolice: but i find it surprising that he says ocaml is easier to read
08:32:15 <thoughtpolice> and 2) that this language *needs* the things that make haskell great, in particular, an amazing type system that can help make sure you write things correctly like haskell does
08:32:19 <byorgey> Blkt: ah, that's just because (add' 1) is a function, and you can't print out functions
08:32:34 <thoughtpolice> jmcarthur: that's odd, i've never heard of that point! I think ocaml is quite ugly in comparison
08:32:37 <byorgey> Blkt: but you can give it a name, pass it around, or apply it to another argument
08:32:45 <Blkt> byorgey: I see thank you
08:32:46 <Kaidelong> thoughtpolice: I think haskell's syntax is quite nice actually and that it isn't a big barrier to entry
08:32:47 <Philippa> jmcarthur: the game industry cares a lot about resource usage, that's a good reason Haskell isn't it. Similarly, the game industry needs extensible records pretty badly
08:32:56 <jmcarthur> and i find it even more surprising that syntax is enough of a reason to not use the nice language
08:33:04 <Kaidelong> thoughtpolice: I picked up on ML syntax quickly anyway, particularly after reading Backus' paper
08:33:04 <aavogt> we have those... but nobody uses them
08:33:14 <jmcarthur> Philippa: i disagree on the latter point
08:33:14 <theorbtwo> jmcarthur: You never get a second chance to make a first impression.
08:33:17 <aavogt> Philippa: ^^ (the records at least)
08:33:26 <jmcarthur> theorbtwo: so true :(
08:33:38 <theorbtwo> How many people here have looked at perl and gone "ew, linenoise".
08:33:51 <thoughtpolice> theorbtwo has a very good point
08:33:53 <Philippa> jmcarthur: you're just plain wrong there, I'm afraid. You need that extensibility to handle the myriad different entities flying around in a game's sim
08:33:55 <Kaidelong> I find perl to be quite nice doing what it is good at doing
08:33:55 <jmcarthur> Philippa: the extensible records approach is widespread but, IMO, misused
08:34:02 <byorgey> soupdragon: awesome!
08:34:12 <rovar> http://gist.github.com/398727
08:34:18 <theorbtwo> I know that many of my first impressions of haskell were "why do these arguments have no commas?  Why don't these parens do what I mean?"
08:34:27 <Philippa> granted you really want that coupled with a useful form of 'interface query', but...
08:34:29 <byorgey> soupdragon: I honestly didn't know how to prove e's irrationality before, although I knew it was "easy"
08:34:41 <jmcarthur> Philippa: those entities should be composed of smaller, distinct parts, not thrown together in an ad hoc way, IMO
08:34:45 <theorbtwo> That is superfical, it's a first hurdle that doesn't need to be there, and it's easily fixed.
08:34:45 <rovar> i think this is one of those closing-the-loop problems. Perhaps its my lack of caffeine this morning, but I can't find an elegant solution for this
08:35:00 <aavogt> sure you could have a standard library that was all uncurried
08:35:00 <Philippa> jmcarthur: same damn difference. That just changes how big your records are
08:35:08 <thoughtpolice> Kaidelong: i would be inclined to agree, but you're going to have to tell that to people in the game industry who may not agree
08:35:16 <jmcarthur> Philippa: and changes the significance of "extensibility"
08:35:31 <theorbtwo> aavogt: Or you could ease the boundry between curried and uncurried.
08:35:31 <Philippa> no, it doesn't. You still need extensibility to allow compositions to expose functionality
08:35:35 <Kaidelong> thoughtpolice: I don't think you can make a strong argument for the use of haskell to write games, at least not yet
08:36:00 <thoughtpolice> Kaidelong: my coworker is leaving to go to EA in a few weeks to work on the Sims 4 (i.e. EA's cash-cow,) and he does like a lot of the features of haskell, but does not like the syntax very much.
08:36:02 <Philippa> you /also/ need cheap delegation, of course
08:36:04 <jmcarthur> Philippa: i've been meaning to write about this exact topic. i'll queue it up in my blog drafts
08:36:06 <thoughtpolice> then again he's particularly weird in that respect
08:36:14 <aavogt> theorbtwo: I think you'd have type inference issues if you had implicit conversions from  f (a,b,c)  ->  f a b c
08:36:24 <thoughtpolice> because he's a mathematics major, so the fact he doesn't like the syntax somewhat perplexes me :P
08:36:34 <Kaidelong> thoughtpolice: the syntax makes a bit more sense if you understand some of the ideas of "applicative programming" I suppose
08:36:44 <jmcarthur> Philippa: i'll try to remember to ping you when it's done. i'd like to do it this way so i can make my whole case... and while i'm not at work ;)
08:37:03 <Kaidelong> (+) takes one argument but (uncurry(+)) takes two
08:37:25 <byorgey> rovar: how is collect (count - 1) chan i::acc supposed to parse?
08:37:29 <theorbtwo> aavogt: You could make the syntax f(a, b, c) mean what f a b c means in haskell, and have some other syntax for creating a three-element tupple.
08:37:30 <aavogt> Kaidelong: don't you mean the opposite?
08:37:31 <byorgey> looks suspicious to me
08:37:35 <aavogt> or is  (a,b) two arguments to you?
08:37:55 <Kaidelong> aavogt: one takes an argument and returns a function that takes an argument
08:38:00 <Philippa> jmcarthur: fair enough. I suspect you're still going to need a substantial form of extensibility when you're done, even if you end up wrapping it up in typeclasses
08:38:05 <Kaidelong> aavogt: the other takes a tuple of two parameters
08:38:06 <byorgey> the other takes one argument which is a tuple =)
08:38:14 <jmcarthur> Philippa: i'm not really talking about type classes though
08:38:24 <aavogt> @type uncurry (+) -- Kaidelong
08:38:25 <lambdabot> forall a. (Num a) => (a, a) -> a
08:38:43 <aavogt> that is one argument to me
08:38:49 <aavogt> your definitions may vary
08:38:52 <Kaidelong> aavogt: I was talking about rationalizing the syntax difference between C and haskell
08:39:01 <soupdragon> > iterate (^2) 11
08:39:02 <lambdabot>   [11,121,14641,214358881,45949729863572161,211137767453525528554561525420992...
08:39:15 <soupdragon> why it suddenly stops being palendromic??
08:39:22 <jmcarthur> Philippa: you do have a point on performance, but then again, not every game has to make your computer hot
08:39:32 <Philippa> well, you've got to get your interface/implementation separation somewhere and you've got to support interfaces that are in some sense extensions of other interfaces. That much is taken from the domain
08:39:38 <soupdragon> oh it's because base 10 starts to need carries
08:39:48 <aavogt> theorbtwo: hmm, so count whitespace here:   f(a,b,c)  ->  f a b c, but   f (a,b,c) -> f (a,b,c)
08:40:14 <byorgey> soupdragon: yep, you can make it stay palindromic as long as you want by using a large enough base =)
08:40:14 <thoughtpolice> Kaidelong: understanding how to write code 'applicatively' helps for sure. I know that I love mcbride's she preprocessor + idiom brackets!
08:40:19 <soupdragon> (f a b c) -- OMG too many brackets!!  LIFP        f(a,b,c) -- that's fine
08:40:22 <jmcarthur> Philippa: true, but there can also be a mechanical way to extend the functionality of an entity
08:40:27 <thoughtpolice> it makes writing e.g. network protocol parsers so easy
08:40:34 <thoughtpolice> you won't even realize you just wrote a protocol specification
08:40:45 <aavogt> soupdragon: are you sure those two complaints come from the same person?
08:40:49 <thoughtpolice> that can be reified into a strict, efficient continuation based parser :)
08:40:56 <theorbtwo> aavogt: No.  Make f(a,b,c) call a function like \a, b, c -> ..., make ({a, b, c}) create a tuple.
08:41:33 <theorbtwo> soupdragon: I really don't appreciate your tone.  Yes, people *absolutely* think that.
08:41:58 <theorbtwo> I expect *everyone* who moves from a primarally C-derived backround into lisp or Haskell thinks that for quite a while.
08:42:16 <rovar> byorgey, ah.. it should have been : instead of of :: .. i'm using too many languages at once :/
08:42:23 <thoughtpolice> syntax is very important for people coming from other languages
08:42:31 <theorbtwo> Or, contrarywise, make all functions take a single tuple argument.
08:42:35 <byorgey> rovar: hehe
08:42:36 <jmcarthur> actually, i loved the haskell syntax from the moment i first tried it
08:42:39 <jmcarthur> i can't say the same for lisp
08:42:41 <Philippa> jmcarthur: I'm afraid that sounds like a cheap dodge from here. What does "mechanical" even mean in this context?
08:42:48 <byorgey> rovar: and is it supposed to be (i:acc) or really chan i:acc ?
08:42:51 <Kaidelong> I really loved LISP syntax because it was so simple
08:42:55 <soupdragon> My point is that caring about syntax is silly
08:42:56 <byorgey> the latter parses as (chan i):acc
08:43:08 <theorbtwo> soupdragon: People are silly.
08:43:08 <Kaidelong> I loved the haskell style syntax even more because it was so flexible
08:43:16 <Philippa> and mine is that if you think caring about syntax is silly you need to go work in unary-encoded brainfuck
08:43:27 <Kaidelong> particularly being able to say something like "minimumBy (compare `on` cost)"
08:43:28 <jmcarthur> Philippa: something of the form:  type Foo = Bar :*: Baz, where Bar and Baz both expose some sort of interface and Foo exposes both
08:43:35 <quicksilver> syntax is at the same time utterly irrelevant and incredibly, fundamentally important.
08:43:54 <aavogt> theorbtwo: it's a rather convenient property to have the same syntax for both types and values (for tuples and lists...), which would be unfortunate to loose
08:43:56 <quicksilver> it's completely irrelevant to the discussion of what languages can do, certainly
08:43:57 <soupdragon> ..funnily enough I implemented a bijection from N to valid brainfuck programs just last week (not kidding)
08:44:03 <bremner> caring about syntax is fine. Insisting everything look like C is maybe misguided
08:44:12 <Philippa> jmcarthur: interface products, IOW? That's practically the same thing
08:44:17 <quicksilver> but it it's incredibly important to any discussion of human cognition when reading / writing computer programs.
08:44:20 <Philippa> especially by the time you label the interfaces
08:44:37 <theorbtwo> aavogt: You could keep that, by changing both the type and value syntax at the same time.
08:44:46 <Kaidelong> Part of the problem is that f(x,y) is semantically different from (f(x))(y)
08:44:46 <aavogt> :)
08:44:46 <jmcarthur> Philippa: it would help if we had a concrete example
08:44:58 <thoughtpolice> quicksilver: I believe SPJ said when they were writing the first haskell specification draft, some of the most incredibly heated debates between the members was due to syntax
08:44:59 <quicksilver> (and the same applies to mathematical theorems - choose the wrong notation, and a theorem becomes impenetrable. Choose the right one and it becomes seductively clear)
08:45:28 <soupdragon> probably people arguing about n+k patterns
08:45:29 <theorbtwo> Note that I'm very much talking about a new language, inspired by Haskell, but not particularly aimed at Haskell programmers.
08:45:31 <jmcarthur> either way, it's kind of looking like what you really want is objects. i'm not really intending to go with an OO style at all
08:45:45 <thoughtpolice> quicksilver: oh god I wish. I want to look at proofs and understand, but looking at some proofs using Coq makes me more confused than before because the proof is insane looking.
08:45:58 <dpratt71> I've missed some of the discussion here; has it been suggested that Haskell's syntax is a serious impediment to it's adoption?
08:46:05 <theorbtwo> dpratt71: Yes.
08:46:12 <Kaidelong> jmcarthur: objects are somewhat of a standard design pattern for simulations and games
08:46:12 <thoughtpolice> soupdragon: n+k patterns were probably discussed there
08:46:14 <jmcarthur> the expression problem is real, but i'm not sure how significant it is
08:46:18 <thoughtpolice> but n+k patterns are hated for other reasons
08:46:26 <thoughtpolice> not because the syntax is super confusing
08:46:31 <thoughtpolice> although it can be if abused
08:46:32 <jmcarthur> Kaidelong: standard /= necessary
08:46:38 <Kaidelong> perhaps not
08:46:41 <dpratt71> dpratt71: hmm; can't say as I agree with that, at least as far as Haskell's core expression syntax is concerned
08:46:50 <Kaidelong> but they do express the concept of objects interacting pretty clearly
08:46:59 <thoughtpolice> soupdragon: but I'm willing to bet money it had to do with more than just n+k patterns
08:47:00 <Philippa> I definitely want something related to objects, though not really objects per se. But that's partly because /game designers/ talk in an object-like model. If you want something else, some clarification on /what/ would be useful :-)
08:47:17 <theorbtwo> I think a big part of the acceptance of C++, Java, and C# have been that existing programmers of C-like languages have been able to immediately look at it and go "oh, this isn't so different".
08:47:37 <thoughtpolice> theorbtwo: agreed
08:47:37 <jmcarthur> perhaps game designers need some new vocabulary
08:47:57 <Kaidelong> theorbtwo: definitely. And then there is the fact that they were designed from the beginning to help diverse groups of programmers work together
08:48:07 <thoughtpolice> theorbtwo: something about programs are for humand and not for computers said by some famous guy comes to mind
08:48:11 <Kaidelong> something which haskell has going for it too
08:49:10 <Philippa> jmcarthur: then you have a hell of a task ahead of you. It's not even a matter of /computer/ game designers talking in an object-like model - it's there in RPGs, CCGs, board games...
08:49:12 <dpratt71> I won't completely dismiss the syntax issue, but it seems inconsequential considering that you have to approach problem solving in a completely different way in pure functional programming languages
08:49:30 <jmcarthur> Philippa: there's a reason i'm mostly interested in *indie* games ;)
08:49:30 <dpratt71> the latter has to be the major impediment, regardless of syntax
08:49:32 <soupdragon> yeah I agree with inconsequential
08:49:55 <Kaidelong> philippa: that said, you can implement objects and methods using haskell, the question is whether or not you can make a good argument to do so
08:50:01 <soupdragon> syntax should not affect anything, it should always reflect
08:50:24 <Philippa> Kaidelong: it's a PITMFA to do really well, which justifies Sweeney's comment about Haskell not being it
08:50:31 <thoughtpolice> syntax is always a big deal as far as I'm concerned
08:50:36 <thoughtpolice> it is the user interface to a language
08:51:15 <thoughtpolice> dpratt71: but you are also correct, IMO
08:51:19 <theorbtwo> soupdragon: That's a bit crazy, though.  One of the reasons that javascript is a bit off is becuase it is agressively functional in some places, but the syntax for creating a closure is *huge* by comparison to haskell.
08:51:19 <Kaidelong> Philippa: yes, I agree, although I can see the argument for using haskell to do reactive programming as well. But then why not use something like OCaml?
08:51:33 <Philippa> Kaidelong: outside scope of discussion :-)
08:51:38 <soupdragon> theorbtwo: I used to hate MathML because it used XML syntax
08:51:49 <Philippa> (but: lack of type classes would be my first argument for it not being good enough)
08:52:02 <soupdragon> theorbtwo: recently, I learned that it doesn't matter - since everything is complier output
08:52:03 <theorbtwo> soupdragon: Do you write mathml now, or do you write another language and then convert it into mathml?
08:52:11 <Kaidelong> philippa: good point
08:52:13 <dpratt71> Haskell's syntax is relatively simple and uncomplicated, which is what I want
08:52:16 <soupdragon> theorbtwo: yeah I wrote LaTeX and a javascript converts it
08:52:35 <soupdragon> so I don't care what syntax MathML is written in anymore
08:52:42 <theorbtwo> Exactly.  You don't write mathml, becuase you dislike the syntax.
08:52:56 <Kaidelong> philippa: on the other hand, you are not required to keep your code pure and there is a first class notion of objects and methods
08:52:58 <k23z__> soupdragon, what do you want to draw ?
08:53:01 <jmcarthur> to be fair, none of tim sweeney's objections to haskell include lack of object oriented programming
08:53:11 <jmcarthur> at least not in the slides i've seen
08:53:15 <k23z__> soupdragon, how about latex ?
08:53:21 <soupdragon> you are making a distinction that there is something different between writing and causing-to-be-written
08:53:28 <soupdragon> I still write MathML
08:53:30 <theorbtwo> soupdragon: I am, indeed.
08:53:38 <thoughtpolice> no, you write latex
08:53:44 <jmcarthur> he complains about syntax, lazy evaluation by default, lists being syntacticly preferred sequence type, and type inference not scaling
08:53:47 <thoughtpolice> because it is *easier* to understand what is being said with latex
08:53:51 <thoughtpolice> mathml is just the 'compiler output'
08:53:53 <thoughtpolice> but you don't write it
08:53:59 <thoughtpolice> anymore than you write ASM when you compile a C program
08:54:03 <Philippa> soupdragon: there is a difference, there are all kinds of potential issues in the chain of cause and effect
08:54:05 <theorbtwo> Haskell compiles down to bytecode.  Nobody on this channel writes programs in bytecode (I bet).
08:54:16 <hpc> Haskell compiles to binary, i thought
08:54:31 <Kaidelong> well it depends what compiler you use
08:54:34 <hpc> ah
08:54:44 <theorbtwo> hpc: "Binary" is a very abused term.  It compiles down to bytecode for some machine or another, in most cases.
08:54:46 <Kaidelong> Hugs does byte-code I think
08:54:55 <Kaidelong> GHC translates the haskell into C-- and then compiles that
08:55:41 <djahandarie> Depending on the backend for GHC, it can go to the native ASM generator, gcc, or LLVM
08:55:55 <jmcarthur> doesn't ghci do bytecode of some sort?
08:55:57 <tromp> haskell compiles to core, and then on through c or llvm to assembly
08:56:13 <theorbtwo> In any case, somebody who writes in Haskell doesn't need to know those other languages, and certianly isn't writing them.
08:56:16 <thoughtpolice> jmcarthur: yes
08:56:21 <Zao> Haskell runs on the STG machine.
08:56:26 <Zao> The rest is implementation detail :D
08:56:36 <quicksilver> haskell -> core -> ... -> Cmm -> { either native, or llvm, or gcc, or ghci bytecode }
08:56:56 <Philippa> Kaidelong: not having to keep your code pure is actually a disadvantage for Sweeney's purposes
08:56:56 <quicksilver> with native being the default for the last step in i386/x86_64/sparc
08:57:08 <tromp> first time i hear of Cmm...
08:57:27 <soupdragon> There is a continuum between (1) writing code directly (2) using lots of editor macros (3) generating it with a script (4) compiler output
08:57:33 <djahandarie> Cmm == C-- == http://www.cminusminus.org/
08:57:38 <quicksilver> Cmm is not C--
08:57:42 <djahandarie> It's not?
08:57:44 <quicksilver> however, it's closely related.
08:57:52 <soupdragon> it's only natural to draw a distinction if you find the middle bits alien
08:57:55 <thoughtpolice> Cmm is GHC's variant of C--
08:58:00 <quicksilver> Cmm is C--'s ugly step-sister.
08:58:12 <quicksilver> (exercise for the reader: or is it the other way around?)
08:58:13 <thoughtpolice> if you want to put it that way :P
08:58:41 <djahandarie> Augh why do things always have to be more complicated than they need to...
08:58:55 <quicksilver> because the nice way doesn't quite work out
08:59:04 <quicksilver> (is probably a reasonably generic answer to that question)
08:59:18 <thoughtpolice> because your boss says they need to
09:01:47 <Philippa> soupdragon: amazingly, not being on exactly the same point in a continuum is also a 'difference'
09:02:55 <Philippa> there's also a reasonable point of delineation when you're maintaining separate 'source' and 'object' code
09:03:19 <Philippa> (generating it with a script taken from some kind of input is on the 'separate' side)
09:04:06 <quicksilver> I'm not sure that point is so clear
09:04:29 <quicksilver> the program you use to run your program may do some quick compilation at runtime (like perl/python/runhaskell)
09:04:42 <quicksilver> the object code might be optionally saved to disk, or never saved to disk
09:10:51 * hackagebot eprocess 1.1.2 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.1.2 (FernandoBenavides)
09:15:05 <jlouis> &10
09:15:55 * hackagebot hint-server 1.2.0 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.2.0 (FernandoBenavides)
09:19:53 <DamienCassou> hi
09:20:17 <DamienCassou> I'm new to Haskell. It looks like a very good language
09:20:57 <Saizan> hi
09:21:14 <Saizan> quite a few will agree with you here :)
09:21:20 <DamienCassou> How can I create a module that depends on functions that the user of the module must provide?
09:21:30 <DamienCassou> Saizan: :-)
09:21:59 <DamienCassou> (in fact, I'm looking for an equivalent of an abstract class with abstract methods)
09:22:37 <Philonous> No first class modules in haskell, I'm afraid :-(
09:22:52 <Saizan> well, we tend to just define a record type that contains functions and make the user give you a value of that type
09:23:45 <DamienCassou> Saizan: do you mean that the constructor of the record type takes functions as parameter types?
09:24:10 <Saizan> if the decision of which functions to use depends on some type it might make sense to use a type class
09:24:33 <Saizan> DamienCassou: takes functions as parameter values
09:25:29 <DamienCassou> Saizan: thank you, I will see if I can make something from your advice
09:26:28 <DamienCassou> Saizan: I'm create a program which generated programming frameworks (with abstract classes and concrete classes). At least, this is what I currently do in Java and would like to try on Haskell
09:26:54 <Saizan> DamienCassou: another more general advice is that OOP design principles don't match so well to haskell
09:28:16 <DamienCassou> Saizan: that's why I'm doing this port to Haskell. I would like to see the kind of concepts that can replace objects in the context of my programming framework generator
09:28:43 <temoto> Hello. What is strong difference between checksum and "general hash algorithm"? (some python doc says crc32 is not suitable for latter)
09:29:06 <Twey> temoto: A hash algorithm is designed to be difficult to reverse
09:29:19 <Twey> A checksum just has to have few collisions
09:29:39 <quicksilver> well crc32 is not reversible :)
09:29:45 <temoto> Great, then i need a checksum :) thanks.
09:29:49 <djahandarie> DamienCassou, it sounds like you are trying to port a Java solution of a problem to haskell. It'd be better to tackle the problem directly in Haskell and see what sort of abstractions naturally form.
09:29:50 <quicksilver> a hash algorithm is designed to be hard to deliberately cause a collision
09:30:00 <quicksilver> with crc32 deliberately causing a collision is trivial.
09:30:06 <temoto> oh
09:30:20 <temoto> deliberately means 'by occasion', right?
09:30:26 <temoto> not intentionally
09:30:27 <Twey> By intent
09:31:04 * hackagebot wxhnotepad 1.2.0 - An example of how to implement a basic notepad with wxHaskell  http://hackage.haskell.org/package/wxhnotepad-1.2.0 (FernandoBenavides)
09:31:06 <quicksilver> yes, I meant by intent
09:31:29 <Saizan> DamienCassou: this article talks about the cases where you want in fact do something similar to OO in haskell http://cale.yi.org/index.php/A_look_at_OO_from_Haskell , to get a more concrete idea of what it looks like
09:31:31 <quicksilver> although the other case is 'by an non-uniform, but perfectly valid, input distribution'
09:32:02 <DamienCassou> djahandarie: in fact, I already have a working compiler written in Java which produces Java programming frameworks. This work is part of my PhD. To understand the link between my work and OOP/Java, I would like to do the same kind of thing in the context of FP/Haskell
09:32:18 <DamienCassou> Saizan:
09:32:23 <DamienCassou> Saizan: thank you
09:33:26 <temoto> hm... i'm storing tags in database (all at once along with their associated entity) and now i need to build a reverse index from tags to entities so i thought that keeping tag name as primary key would be such a waste and maybe it's reasonable to build an index from tag crc to entities.
09:34:35 <EvanR-work> anyone use ADNS? when deployed on ubuntu, it seems, that it does not work!
09:35:54 <temoto> How do you think if crc makes sense there?
09:36:08 * hackagebot hfiar 1.2.0 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-1.2.0 (FernandoBenavides)
09:36:18 <Saizan> i'm not aware of a "design principles for haskell" kind of tutorial, there are some vague ones like "make an EDSL" or even "write an interpreter" or "use dumb data with a precise semantic meaning" (as opposed to "hide messy internals behind the methods wrapped around your data" which is more OO)
09:40:06 <Blkt> could anyone tell me an easy to use SQL package for Haskell?
09:40:24 <Blkt> to use with GHC
09:41:49 <Saizan> HDBC
09:42:13 <Blkt> Saizan: thanks
09:43:25 <feral> haskell is pretty
09:45:18 <burp> or takusen
09:50:18 <quicksilver> temoto: sounds like a false optimisation, I'd just use the tag name.
09:51:17 <temoto> quicksilver, thanks.
09:51:34 <Blkt> burp: is there something already packed up on Hackage or something?
09:51:57 <burp> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
09:52:07 <mreh> :t $=
09:52:08 <lambdabot> parse error on input `$='
09:52:10 <mreh> :t ($=)
09:52:11 <lambdabot> Not in scope: `$='
09:52:24 <jmcarthur> mreh: StateVar package?
09:52:41 <mreh> jmcarthur: maybe, never heard of it before, thanks for the tip
09:55:54 <Damien704> hello
09:56:06 <ddos> hello
09:59:45 <Damien704> what language is haskell
09:59:57 <ddos> NICK DDOS
10:01:57 <applicative> > "Haskell"
10:01:58 <lambdabot>   "Haskell"
10:02:21 <jon_of_arc> English, mostly
10:02:50 <applicative> > "Haskell" == "Haskell"
10:02:51 <lambdabot>   True
10:03:06 <DamienCassou> Saizan: in the 'A look at OO from Haskell', is the code about SomePointSet valid? It looks like my compiler refuses 'where' in a 'data' clause
10:03:35 <lispy> DamienCassou: did you turn on GADTs?
10:04:02 <DamienCassou> lispy: no. Is this a compiler extension? What does it do?
10:04:11 <lispy> {-# LANGUAGE GADTs -#} at the top of the file or invoke ghc with -XGADTs
10:04:31 <lispy> DamienCassou: it enables generalized algebraic datatypes
10:05:16 <soupdragon> I call them  Great Algebra Data Types
10:05:32 <lispy> DamienCassou: I don't know where to begin explaining gadts.  It's a fairly deep topic :)  The haskell wiki and other places have good documentation though
10:05:47 <lispy> I call them ga-d-its
10:05:53 <lispy> er, gad-its?
10:06:20 <lispy> Pronounceable Acronyms For the Win (PAFTW)!
10:06:57 <Saizan> DamienCassou: in this case they are used to basically forget about the identity of the implementation type 't' and only remember that it's a member of the type class PointSet
10:07:19 <DamienCassou> lispy: I've added your line (and changed the -#) to be #-)
10:07:43 <DamienCassou> lispy: but my code still does not compile: data AbstractC1 where
10:07:43 <DamienCassou>     get :: Bool -> Bool
10:07:54 <lispy> DamienCassou: oh, did I reverse the order of - and #?
10:08:08 <DamienCassou> lispy: looks like you did :-)
10:08:09 <Saizan> DamienCassou: so SPS is basically an upcast, from a subtyping point of view
10:08:38 <Saizan> DamienCassou: constructors need to start with an uppercase letter
10:09:10 <Saizan> DamienCassou: i think you're mixing up what should be a class and what should be a data?
10:09:43 <soupdragon> that should be   data AbstractC1 = MkAbstractC1 { get :: Bool -> Bool } ?
10:09:50 <DamienCassou> Saizan: lispy : ok, I think I have a lot of things to learn about Haskell before being able to understand what I'm doing :-)
10:10:09 <lispy> DamienCassou: you're in good company :)
10:10:15 <DamienCassou> soupdragon: I'm refereing to the end of http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
10:10:32 <soupdragon> data SomePointSet where SPS :: (PointSet t) => t -> SomePointSet
10:10:33 <soupdragon> this one ?
10:10:39 <DamienCassou> soupdragon: yeap
10:10:49 <soupdragon> The essential thing in that is that the arrow ends in -> SomePointSet
10:10:56 <soupdragon> and that is the data type being defined
10:11:11 <soupdragon> whereas yours ends in Bool, and it defines something other than Bool
10:11:15 <ksf> OO in haskell is an interesting problem, but also usually a wholly mislead approach
10:11:33 <Saizan> DamienCassou: you could just stick to the GameObject way of doing this, it's much simpler from a type system pov
10:12:31 <ksf> I found that every time I wanted to have inheritance, sticking with a purely typeclass-based approach was the best choice.
10:12:49 <Saizan> we're not talking about inheritance here
10:12:59 <thoughtpolice> IRC explanation of GADTs: data types can have a type variable as a parameter, e.g. 'data Foo a = ...', and any constructors of that data type, say, 'Bar Int' has the type 'Bar :: Int -> Foo a'. GADTs essentially let every constructor of the data type control the 'a' type variable individually.
10:13:11 <ksf> in the sense that there's no objects being anything, they're only implementing interfaces.
10:13:45 <Saizan> yeah, but typeclasses fit only when you have type-indexed implementations of interfaces
10:14:04 <jmcarthur> perhaps a bit more accurately, which constructor you may use is restricted by the type parameters
10:14:23 <thoughtpolice> that's probably a better way to think of it, yes
10:14:25 <Saizan> otherwise you can define the interface as a simple record type
10:15:12 <DamienCassou> ok guys, thank you very much for your help. I will try with the simple GameObject way and probably come back to you later. I need to leave now. Haskell looks like a good language but fairly hard to learn compared to Smalltalk for example. I hope to learn a lot of things
10:15:40 <ksf> it's actually easy to learn, iff you didn't learn any language beforehand
10:15:50 <ksf> ...otherwise you have to un/relearn a lot of stuff
10:16:19 <ksf> (which is rewarding, but also unnerving, depending on your motivation)
10:16:25 <thoughtpolice> man, simon peyton jones is one hell of a writer
10:16:32 <soupdragon> huh?
10:16:35 <Saizan> DamienCassou: i showed that article to you since it's similar to where you come from, but there might be a much simpler way to design your program
10:16:59 <thoughtpolice> 2 completely different research papers in april 2010 alone, and now a 70 page jfp journal just this month
10:18:02 <Jafet> Maybe he's like Tom Clancy...
10:18:19 <ksf> DamienCassou, if you want the true OO haskell overkill, have a look at http://homepages.cwi.nl/~ralf/OOHaskell/
10:18:35 <thoughtpolice> granted, he almost always coauthors, but his publication frequency for the past year and a half has been frighteningly fast
10:18:40 <DamienCassou> ksf: I love to learn new paradigms (Smalltalk is very different from what I knew before like Java/C++/C..)
10:18:51 <EvanR-work> interesting. adnshost works on arch and ubuntu. Network works on arch and ubuntu. ADNS is not working on ubuntu. same versions of all softwares
10:18:54 <thoughtpolice> er, frighteningly high
10:19:04 <EvanR-work> all queries return Nothing
10:19:32 <DamienCassou> Saizan: I will try to stick with the Haskell-way as far as possible and see how my approach fits. I have 2 colleagues which knows a lot more Haskell who will guide me
10:20:01 <DamienCassou> thank you very much to all of you
10:20:10 <ksf> hmmmm java...
10:20:15 <DamienCassou> I really appreaciate your help
10:20:21 <ddos> hello
10:20:22 <DamienCassou> ksf: I know :-)
10:20:25 <ksf> if you want to get a bit more into type-level programming, there's http://pepeiborra.github.com/control-monad-exception/
10:20:45 <ksf> which gives you all that java-style exception handling as a haskell _library_
10:20:45 <ddos> what is yor name?
10:21:09 <ddos> fhfg
10:21:14 <soupdragon> hi ddos
10:21:25 <ddos> what is yor name??
10:21:40 <ddos> you is hacking??
10:21:43 <ddos> bot
10:21:45 <ddos> is
10:21:47 <ddos> mai
10:21:49 <ddos> lafe
10:21:54 <ddos> :))))
10:21:55 <soupdragon> IRC bot?
10:21:56 <sbahra> !ops
10:21:59 <Zao> ddos: Type more per line.
10:22:00 <ksf> @where obs
10:22:00 <EvanR-work> you are so lifelike
10:22:00 <lambdabot> I know nothing about obs.
10:22:01 <ddos> yes
10:22:01 <ksf> @where ops
10:22:02 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
10:22:02 <Zao> ddos: Or les in general.
10:22:09 <soupdragon> what the fuck are you calling ops for
10:22:10 <DamienCassou> ksf: thank you for the pointer, I will have a lok
10:22:11 <DamienCassou> look
10:22:24 <soupdragon> Go to the #haskell-ops channel instead of making a scene here
10:22:44 <ddos> you hew boy?
10:22:49 <glguy> ?
10:22:50 <ddos> bot?
10:22:56 <ddos> rx
10:23:00 --- mode: ChanServ set +o dcoutts_
10:23:04 <sbahra> Thanks.
10:23:11 <dcoutts_> ddos: do be careful not to annoy people :-)
10:23:22 <ddos> es
10:23:24 <ddos> ok
10:23:36 <sbahra> dcoutts_, it's clearly his goal. :-)
10:23:53 <ksf> come on, let's feed him haskell till he asplodes.
10:24:44 <dcoutts_> ksf: I never want to see any pictures of that
10:24:54 <ddos> you american
10:24:59 <ddos> ?
10:25:13 <ksf> we are from the internets
10:25:20 <ddos> :)))
10:25:31 <ddos> the net
10:25:40 <ddos> thu
10:25:44 <glguy> ddos, So how has your Haskell programming been going?
10:25:51 <ddos> no
10:26:12 <Damien>  /part for ur half
10:26:16 <ddos> x chat
10:26:22 <ddos> client irc
10:26:26 <ddos> servers
10:26:30 <ksf> in fact, #haskell is a strong AI that oleg spawned as a byproduct of his last attempt to prove the haskell98 typechecker turing-complete.
10:26:49 <Damien> do you have to have the 2010 to run haskell
10:27:09 <Damien> i got the link and downloaded it
10:27:13 --- mode: ChanServ set -o dcoutts_
10:27:15 <Damien> cant get it to run
10:27:33 <ddos> damien you the net?
10:27:59 <jmcarthur> ddos: what is your native language?
10:28:06 <ddos> george
10:28:11 <Damien> what part
10:28:25 <ddos> niznaiu
10:28:28 <dino-> Something I uploaded to hackage is failing to build there because a dep it has is broken there. Is there anything I can do about it or anyone to speak to?
10:28:40 <ddos> you spick the russia??
10:28:49 <gwern> dino-: speak to whomever maintains the dep?
10:29:02 <gwern> dino-: sie sprechen sie lojban?
10:29:09 <ksf> ...or maybe just mention what package it is?
10:29:18 <dino-> gwern: It's HSH, which as it happens seems to have built fine according to its own hackage page.
10:29:26 * ksf slaps gwern with a duden
10:29:36 <jmcarthur> dang, #haskell.ru doesn't have anybody but lambdabot in it
10:29:44 <Damien> i dont know any languages yet, and i was wondering if i could start here
10:30:02 <Damien> i mean i lost the site and already downloaded it :(
10:30:13 <Damien> but i cant figure out open source either
10:30:13 <ksf> you can start there:
10:30:17 <ksf> @where lyah
10:30:17 <lambdabot> http://www.learnyouahaskell.com/
10:30:18 <dino-> Mine is epub-metadata, the failure log: http://hackage.haskell.org/packages/archive/epub-metadata/1.0.2/logs/failure/ghc-6.12
10:30:37 <jmcarthur> according to the wiki, "Seems that most of [the Russian speakers] migrated to Jabber conference (haskell@conference.jabber.ru)"
10:30:46 <ksf> also, http://tryhaskell.org , but it's still in beta afaik
10:30:49 <m_88> jabber? what a joke
10:30:51 <jmcarthur> ddos: ^^ might be relevant to you
10:31:13 <jmcarthur> if i'm understanding you properly at all
10:31:47 <ksf> hackage has broken packages?
10:32:00 <m_88> also tryhaskell.org seems not to work in conkeror
10:32:03 <ksf> someone must have messed around for that to have happened...
10:32:21 <jmcarthur> there is apparently one person in #haskell_ru
10:32:27 <jmcarthur> besides lambdabot
10:32:42 <ksf> ...you?
10:32:50 <jmcarthur> no, i just checked it out and then left
10:32:52 <m_88> lol
10:33:08 <m_88> lambdabot is a real person, i beleive
10:33:37 <dpratt71> initials C.G.?
10:33:37 <lispy> ?vixen Are you a real person?
10:33:37 <jmcarthur> > text$ if False then "I'm real!" else "I'm a bot!"
10:33:38 <lambdabot> do i not seem real to you?
10:33:38 <lambdabot>   I'm a bot!
10:34:31 <m_88> Umm.. If I understan corectly, in oreder to implement k-neares neighbors algorythm I need something like "array of arrays", or, list of list in term of haskells?
10:34:53 <dino-> ksf: Yes, broken packages on the hackage build system
10:35:43 <lispy> m_88: if performance is going to be an issue, you might want to look at something like Vector instead of lists.  But for a simple first implementation, lists are probably easiest.
10:36:03 <m_88> lispy: ok, thanks
10:36:14 <ksf> m_88, depends. some algorithms are inherently array-based, but most are merely usually described in such a way
10:36:28 <ksf> ...the key is to look behind the syntax and figure out the data dependencies
10:36:44 <lispy> haskell lists are closer to streams
10:36:57 <m_88> ksf: well, someone on this channel told me that it would be a good idea for a newbiew to implement a simple knn algorythm
10:37:01 <lispy> Random access of haskell lists is bad, and usually means you need a different structure
10:37:11 <m_88> so i guess i'd use lists for the first time?
10:37:28 <lispy> m_88: yeah, refactoring later is easy :)
10:37:32 <lispy> type system++
10:41:34 <Damien> what am i supposed to write the code in
10:41:53 <Jafet> Papyrus
10:41:58 <m_88> Hmm.. sorry to bother you guys with newbie Qs again, but in KNN i return only one varible - radius of a circle, which covers K nearest neighbours?
10:42:06 <m_88> Damien: emacs?
10:42:19 <dpratt71> Damien: what OS?
10:42:23 <Damien> ubuntu
10:42:29 <Damien> i downloaded the haskell stuff
10:42:32 <Damien> for ubuntu
10:42:34 <m_88> emacs can run on any os
10:42:45 <Damien> and i downloaded something from late 2009
10:42:53 <Damien> but its saying i need to download the 2010 one
10:42:57 <dpratt71> Emacs is a lot to get used to if you're not familiar with it
10:43:00 <Damien> but it takes forever to download them
10:43:06 <Jafet> emacs is the OS!
10:43:09 <Damien> i am using ghci in terminal though
10:43:15 <dpratt71> gedit can do Haskell syntax coloring
10:43:34 <Damien> i was wanting to make a program
10:43:56 <lispy> Damien: You can use ghci, so then you should have a working compiler too
10:44:04 <Damien> i mean i can type all this in gedit and save it and preprocess compile and syntax it
10:44:05 <lispy> Damien: what errors are you getting?
10:44:07 <Damien> but..
10:44:20 <Damien> i dont have an exe im linux illiterate
10:44:29 * lispy is confused
10:44:36 <m_88> Damien: use ghc
10:44:38 <m_88> not ghci
10:44:39 <dino-> I would be happy to help fix the hackage build system as well. Looks like some packages need to be rebuilt.
10:44:48 <m_88> ghc -o haskells.exe file.hs
10:44:51 <c_wraith> can view patterns be used in case statements?
10:44:59 <lispy> ghc --make ...
10:45:05 <lispy> But, cabal is better!
10:45:16 <mauke> preflex: seen orbitz
10:45:16 <preflex>  orbitz was last seen on ##C 1 day, 3 hours, 50 minutes and 37 seconds ago, saying: i'm not an idjit!
10:45:21 <ddos> botnet
10:45:23 <Damien> i did get cabal
10:45:24 <m_88> ghc syntax is different from gcc syntax o_0
10:45:42 <m_88> ##C?
10:45:44 * hackagebot hpage 0.10.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.10.0 (FernandoBenavides)
10:45:46 <Damien> yea
10:45:47 <Jafet> c_wraith, why don't you think so
10:45:47 <ddos> FTP
10:45:48 <c_wraith> m_88: the g in ghc does not mean the same thing as the g in gcc
10:45:50 <dcoutts_> m_88: actually it's pretty much the same as gcc
10:45:50 <ddos> SERVERS
10:45:59 <lispy> m_88: I think they share a lot of command line syntax, but the --make option is nice because it pulls in packages too
10:46:07 <m_88> o i c
10:46:36 <Damien> so what do i do to get a screen up
10:46:43 <mauke> instead of -lm you have stuff like -package containers, but all of it can be automated with --make
10:46:47 <c_wraith> Jafet: I guess they just need parens to prevent weird parse ambiguities
10:46:49 <Damien> where should i start redownloading would take forever
10:46:51 <m_88> uhh KNN looks really tough tho
10:46:52 <lispy> Damien: Have you read this getting started guide? http://book.realworldhaskell.org/read/getting-started.html
10:46:53 <mauke> Damien: what do you mean by "screen"?
10:46:57 <m_88> Damien: screen up?
10:46:58 <dcoutts_> m_88: it's the same for compiling a single file, ghc -c Foo.hs -o Foo.o, the difference is ghc has an extra mode to do dependency chasing, compiling multiple modules in one go
10:47:23 <m_88> dcoutts_: you mean static linking?
10:47:29 <m_88> by "compiling modules in one go"?
10:47:41 <dcoutts_> m_88: no, nothing to do with linking
10:47:46 <m_88> umm
10:47:55 <m_88> then why do you need to compile modules?
10:47:56 <Damien> sorry i was trippin i see it now :D
10:47:58 <lispy> Damien: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
10:48:05 <Damien> ghc --help lol
10:48:19 <ddos> what??
10:48:22 <ddos> is
10:48:23 <dcoutts_> m_88: ghc --make Blah.hs will compile Blah.hs and all the other modules it depends on (to separate .o files)
10:48:25 <ddos> hacker
10:48:28 <ddos> ?
10:48:31 <ddos> what is
10:48:35 <ddos> thet?
10:48:40 <ddos> hacker
10:48:41 <ddos> ?
10:48:45 <lispy> ?hoogle hacker
10:48:46 <lambdabot> No results found
10:48:51 <m_88> dcoutts_: what if I dont compile separate modules?
10:48:57 <ddos> :)))
10:49:08 <ddos> may lafe in hacking
10:49:12 <ddos> :)))
10:49:14 <dcoutts_> m_88: what do you mean exactly?
10:49:14 <mauke> ddos: what?
10:49:17 <ddos> ------------
10:49:33 <mauke> ddos: please hit enter less often, and try to speak English
10:49:41 <ddos> hacking is may laif
10:50:00 <Jafet> dcoutts, I advocate making provision for some quiet time for ddos...
10:50:06 --- mode: ChanServ set +o dcoutts_
10:50:19 <m_88> dcoutts_: you usually need .o files when you want to link them in one programm. Otherwise you usually you shared objects, so I assumed that later you would want to put all dependencies into one executable
10:51:01 <dcoutts_> m_88: yes, if you do ghc --make Main.hs then it also links them all together into an executable
10:51:03 <ddos> is yor komputer what is opereishen system??linux
10:51:04 <ddos> ?
10:51:17 <dcoutts_> ddos: I suggest you follow mauke's advice
10:51:19 <mauke> ddos: why are you in #haskell?
10:51:22 <m_88> yeah i meant that, pardon my english please
10:51:35 <ddos> ok
10:51:38 <ddos> boy ok
10:51:40 <ddos> good
10:51:50 <m_88> dcoutts_: but you dont *have* to put them in one executable, do you?
10:52:14 <dcoutts_> m_88: don't have to, you can compile the modules without linking any executable
10:52:18 <jmcarthur> ddos: stop talking nonsense
10:52:30 <dcoutts_> m_88: eg you can then load them all up in ghci
10:52:33 <m_88> put him on ignore ffs
10:52:57 <Zao> m_88: That's a very local "fix".
10:53:08 <Zao> m_88: And if you're an operator, unfeasible.
10:53:12 <ddos> UPLOADING VIRUS...
10:53:12 <m_88> dcoutts_: I mean can I compile the programm alone into executable and then you haskell's .so libraries?
10:53:15 <ddos> SENDING
10:53:17 --- mode: dcoutts_ set -v ddos
10:53:19 <ddos> SENING
10:53:24 <ddos> SENDING
10:53:29 --- kick: ddos was kicked by dcoutts_ (ddos)
10:53:44 <Damien> does haskell come with darcs
10:53:44 --- mode: ChanServ set +o mauke
10:53:44 --- mode: mauke set +q *!*@94.100.238.2
10:54:02 <glguy_> Damien, no, it is a separate application
10:54:19 <dcoutts_> m_88: ghc does now support the construction of shared libs on some platforms, notably linux
10:54:35 <m_88> :O
10:54:45 <m_88> that kinda sucks tbh
10:54:47 <mauke> hmm, I need something like /ban, just for +q
10:54:55 <dcoutts_> m_88: it's used for packages, not ad-hoc collections of .o files, it needs to be done slightly specially. Cabal can do it.
10:55:19 <Twey> /alias quiet /mode $C +q $0
10:55:25 --- mode: ChanServ set -o dcoutts_
10:55:26 <c_wraith> GHC 6.10 will always give overlapped pattern match warnings when using view patterns, right?  It doesn't actually mean I'm doing something wrong?
10:55:36 <glguy_> Twey: /ban does some clever mask lookups, however
10:55:37 <mauke> Twey: too close to /quit
10:55:42 <zygoloid> c_wraith: right
10:55:44 --- mode: mauke set -o mauke
10:55:47 <Twey> /mute maybe
10:55:50 <Twey> glguy_: True
10:55:55 <m_88> dcoutts_: so *packages* contains modules, and packages can be used as shared libraries?
10:55:58 <ksf>  /shutup
10:56:00 <dcoutts_> m_88: it's possible to make dlls on windows too but it currently still requires making huge monolithic dlls that statically link in the runtime system and everything.
10:56:16 <dcoutts_> m_88: correct, on linux, support for that on windows and OSX is in the works
10:56:22 <m_88> ooohh sorry by bad
10:56:29 <m_88> i read "does now" as "does not"
10:56:44 <m_88> ffff
10:57:02 <dcoutts_> m_88: yes, it's only since 6.12 that it supports making packages into .so libs
10:57:12 <lispy> Damien: if you have cabal and ghc you should be able to 'cabal install darcs' to get dacs
10:57:17 <lispy> Damien: darcs*
10:58:20 <mreh> waste of time or useful to explicitly import every name into a module?
10:58:32 <mreh> it bugs me when other people don't do it
10:58:59 <earthy> mreh: depends on what you're doing
10:59:15 <earthy> mreh: if you're writing a library to be shared with others, then by all means do it
10:59:25 <mreh> I'm tempted to take a hard-line and say it's a good habit, deal with it :)
10:59:26 <earthy> if you're writing an application to use internally... well...
10:59:36 <mreh> it's useful if you're maintaining the code too
10:59:37 <earthy> the issue is the same as it is with Java
10:59:50 <mreh> yes
10:59:52 <earthy> (where * imports are frowned upon)
11:00:02 <lispy> mreh: I do what you do even for inter project imports.  It's important!
11:00:26 <earthy> and it is at the very least considered good style to import qualified
11:00:27 <mreh> the haskell standards committee herby meets wednesdays
11:00:34 <lispy> mreh: the real solution is to make it easier to do the right thing (editor support would help, like eclipse)
11:00:35 * ksf leaves the single imports to conflicts and an ide that's yet to be written
11:00:40 <earthy> so you don't pollute the namespace
11:00:55 <ksf> qualified imports uglify the code
11:00:59 <earthy> ksf: I know
11:01:14 <earthy> however, in some cases you really can't get 'round them
11:01:23 <ksf> it's better style to keep your modules small, which solves the same kind of problems.
11:01:43 <earthy> unfortunately, often you want the same names for different types of data
11:01:59 <earthy> e.g. length for vectors and lists (and bytestrings, possibly) in the same module
11:02:01 <ksf> don't use Map.lookup etc. directly, do an abstraction for every map you want to have.
11:02:06 <m_88> Would it be easy for a newb like me to implement a Normal Notation <-> Polish Inverse Notation? Perl is great for working with text, can I achieve the same simplicity in haskell?
11:02:17 <ksf> ...which has the additional benefit of being easier to refactor
11:02:24 <mreh> I would think a haskell IDE would be really light weight in comparison to eclipse
11:02:24 * earthy nods
11:02:43 <earthy> mreh: not in the 'language understanding' part
11:02:52 <mreh> earthy, huh?
11:02:57 <earthy> but, visual studio 2005 had great visual haskel support
11:02:59 <earthy> +l
11:03:05 <ksf> there's leksah and hare
11:03:20 <earthy> mreh: a haskell IDE would have to be *very* type-savvy
11:03:58 <m_88> emacs please
11:03:59 <mreh> and be aware of all the GHC extensions
11:04:06 <Saizan> mreh: seen -ddump-minimal-imports ?
11:04:09 <m_88> emacs + haskell mode
11:04:17 <m_88> damn emacs can even do pretty lambdas and stuff
11:04:23 <mreh> Saizan: nope
11:04:28 <mreh> ghc?
11:04:32 <Saizan> yep
11:06:06 <Cale> m_88: If you're interested in parsing, you should learn about parser combinator libraries like Parsec or ReadP
11:06:07 <mreh> Saizan: is it a compiler debugging flag?
11:08:10 <Cale> m_88: You'd want to transform the input into some sort of tree datatype, and then just print out a different traversal of that tree. Shouldn't be too bad :)
11:08:18 <mreh> finally checked the users guide :D
11:08:51 <mreh> great little flag
11:09:20 <mreh> I've been eliminating them all from the compiler warnings
11:09:24 <trofi> @src foldM
11:09:24 <lambdabot> foldM _ a []     = return a
11:09:24 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:11:58 <mreh> I had this earlier today too, what's an Instances only import?
11:12:08 <Cale> hm?
11:12:11 <ksf> import Foo.Bar()
11:12:27 <Cale> yeah, you can leave the import list empty, and you'll get instances, I'm pretty sure
11:12:27 <ksf> ...without the () you get a warning if you don't use any methods out of Foo.Bar
11:12:27 <earthy> no identifiers
11:12:31 <mreh> that looks like it imports nothing ot me
11:12:40 <earthy> nope. it doesn't import new identifiers
11:12:41 <ksf> you can't stop instances from being imported
11:12:42 <Cale> mreh: It's impossible not to import instances.
11:12:51 <ksf> it's a well known haskell misfeature.
11:12:57 <mreh> instances?
11:13:09 <ksf> their import rules
11:13:24 <mreh> I still don't understand
11:13:34 <earthy> classes define new identifiers
11:13:37 <Cale> mreh: I'm not sure I really understand your original question.
11:13:38 <earthy> they can be explicitly imported
11:13:40 <earthy> imports do not
11:13:53 <Cale> (We took a guess at it, and maybe got it wrong? :)
11:13:54 <earthy> s/imports/instances/
11:14:37 <mreh> you still haven't explained what an instance is
11:15:01 <mreh> an instance of a class?
11:15:10 <ksf> the main problem is that there's no way to name an instance. you can keep class methods from entering your scope and the class constructor, but there's no way to refer to whatever "instance Foo Bar" (without "where") is called.
11:15:23 <earthy> class Foo a where bar :: a -> Bool ;  instance Foo Int where bar = even
11:15:24 <ksf> mreh, what else?
11:15:27 <mreh> oh
11:15:50 <ksf> (well, type and data family instances, but the same rules apply there iirc)
11:15:56 * hackagebot hs-bibutils 0.3 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-0.3 (AndreaRossato)
11:16:05 <ksf> it's a general problem of any open type.
11:16:10 <ksf> er kind.
11:16:16 <ksf> nope classes aren't kinds
11:16:21 <ksf> help my terminology is failing.
11:16:45 <m_88> Can someone help me please, what's wrong in this code: http://codepad.org/nhZdYWlZ
11:16:59 <m_88> I still dont understand errors in ghc very well :[
11:17:21 <mreh> offside rules :)
11:17:34 <mreh> I would suspect
11:17:37 <ksf> a) don't use hugs
11:17:39 <ksf> (use ghci)
11:17:54 <mreh> hugs is the compiler of satan
11:17:57 <m_88> i use hugs
11:18:00 <earthy> m_88: the else needs to be indented more than the if
11:18:06 <m_88> if you are talking to me
11:18:06 <earthy> hugs is not a compiler
11:18:07 <ksf> b) the whole else clause is _one_ expression
11:18:18 <ksf> earthy, that's not monadic code
11:18:28 <m_88> earthy: hmm emacs aligned that for me
11:18:36 <hpc> c) you should be using guards anyway, for something so simple
11:18:38 <earthy> ksf: true enough.
11:18:49 <earthy> I still consider it to be 'fishy'
11:19:00 <applicative> ksf, why would anyone run down Hugs?
11:19:03 <earthy> especially given the apparent intent of the else clause
11:19:13 <ksf> d) if you intend to use stack as a mutable variable, that's not the way to do it
11:19:21 <applicative> ksf, it's a Haskell interpreter, so it's good.
11:19:45 <m_88> uhh
11:19:46 <ksf> ...because its error messages are confusing
11:19:54 <earthy> ghci has improved to the point where it is better then hugs when interpreting
11:19:56 <ksf> they're not as zenny as ghc's
11:19:57 <m_88> i guess i'm thinking in the wrong direction
11:19:59 <earthy> s/then/than/
11:20:18 <earthy> m_88: yup. you're still confused by the imperativeness that perl gives you
11:20:27 <ksf> m_88, think polish txt = let go stack = ... in go []
11:20:36 <m_88> indeed
11:21:04 <Cale> m_88: For some reason, the haskell-mode default indentation settings in emacs are a bit screwy.
11:21:05 <ksf> that is, (for now) manually thread your stack through the recursion
11:21:23 <jmcarthur> why does codepad use hugs at all?
11:21:41 <Cale> m_88: The usual way to lay out if/then/else looks like:
11:21:42 <Cale> if foo
11:21:44 <Cale>    then bar
11:21:46 <Cale>    else quux
11:22:02 * BMeph_ restrains himself from suggesting: "if null txt == True then..."
11:22:03 <m_88> well it still works?
11:22:13 <applicative> ksf uh, unlike the ghc's error here: Couldn't match expected type `t -> t1 -> [Char]'  against inferred type `Char'  In the second argument of `(++)', namely`(head txt) polish (tail txt)' In the expression: stack ++ (head txt) polish (tail txt) In the expression: if null txt then stack else stack ++ (head txt) polish (tail txt)
11:22:32 <jmcarthur> BMeph_: why would you suggest that?
11:22:44 <ksf> polish txt stack | null txt = stack; polish txt stack = ...
11:22:44 <glguy_> BMeph_: better check it twice to see if it is still True
11:23:23 <ksf> glguy_, but you don't know whether True is True!
11:23:30 <Cale> m_88: yeah, you can lay out if/then/else however you want (almost), but it helps to do it this way, since inside of a do-block, the other way ends up starting a new line and getting you into trouble.
11:23:33 <ksf> you should do if null txt == (1 == 1)
11:23:37 <Cale> (and this way looks nicer anyway)
11:23:55 <BMeph_> jmcarthur: I enjoy reductio ab adsurdum. ;)
11:24:00 <earthy> polish [] stack = stack; polish (x:xs) stack = ...
11:24:05 <glguy_> or you might just want to know that the list is really null and go with :  null txt && null txt
11:24:11 * ksf facepalms
11:24:15 <ksf> thanks, earthy
11:24:20 <zygoloid> > let polish txt = go [] txt where go stack [] = stack; go stack (txt:txts) = go (stack ++ [txt]) txts in polish "2 + 3"
11:24:21 <lambdabot>   "2 + 3"
11:24:57 <m_88> > let mySum (x:xs) = x + mySum xs
11:24:58 <lambdabot>   not an expression: `let mySum (x:xs) = x + mySum xs'
11:25:10 <m_88> :|
11:25:17 <zygoloid> m_88: you also have a type error in "stack ++ head txt". head txt is a Char, so you can't combine it with a list using ++.
11:25:19 <ksf> m_88, I think you should start the other way round, btw.
11:25:29 <ksf> printing infix is easier than parsing infix.
11:25:32 <earthy>  > let mySum (x:xs) = x + mySum xs in mySum [2,3,4]
11:25:35 <m_88> ksf: yeah you are tight
11:25:37 <jmcarthur> > Data.Foldable.toList "2 + 3"
11:25:38 <lambdabot>   "2 + 3"
11:25:55 <earthy>  > let mySum (x:xs) = x + mySum xs; mySum [] = 0 in mySum [2,3,4]
11:26:01 <earthy> > let mySum (x:xs) = x + mySum xs; mySum [] = 0 in mySum [2,3,4]
11:26:02 <lambdabot>   9
11:26:03 <BMeph_> glguy_ null txt == True && ... ;)
11:26:13 <earthy> I wonderded why lambdabot was ignoring it :)
11:26:37 <applicative> > let isNull txt = null txt == (null txt == null txt) in isNull ""
11:26:38 <lambdabot>   True
11:27:33 <ksf> > let isNull txt = null txt == (isNull txt == isNull txt) in isNull ""
11:27:35 <lambdabot>   *Exception: stack overflow
11:27:58 <ksf> lambdabot needs tautology reduction.
11:28:10 <applicative> > let isNull txt = null txt == (null txt == null txt); isReallyNull txt = isNull txt == (isNull txt == isNull txt) in isReallyNull ""
11:28:10 <lambdabot>   True
11:28:22 <mauke> what is this, PHP?
11:28:38 * earthy grins
11:28:45 <applicative> with experience Haskell can be as ugly as PHP
11:29:06 * hackagebot hmumps 0.1 - Interpreter for the MUMPS langugae  http://hackage.haskell.org/package/hmumps-0.1 (AntoineLatter)
11:29:09 <mauke> preflex: remember <applicative> with experience Haskell can be as ugly as PHP
11:29:10 <earthy> PHP programmers can write PHP in any language
11:29:20 * earthy blinks
11:29:24 <earthy> MUMPS?!
11:29:26 <BMeph_> > if show (isNull "") == "True" then True else False
11:29:26 <lambdabot>   Not in scope: `isNull'
11:29:37 <earthy> somebody was in a sadistic mood...
11:29:45 <pikhq> *Someone wrote a MUMPS interpreter*?
11:29:48 <pikhq> *shudder*
11:29:53 <BMeph_> >  let isNull txt = null txt == (isNull txt == isNull txt) in if show (isNull "") == "True" then True else False
11:29:55 <lambdabot>   *Exception: stack overflow
11:30:00 <BMeph_> \o/
11:30:53 <applicative> wow, where does it go wrong.  i just jammed up ghci with it
11:31:10 <mauke> > fix error
11:31:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:31:24 <applicative> I see.
11:32:02 <applicative> > let isNull txt = null txt == (null txt == null txt) in if show (isNull "") == "True" then True else False
11:32:02 <lambdabot>   True
11:34:19 <EvanR-work> can someone with a 64bit machine help me test ADNS?
11:34:41 <EvanR-work> im doing resolveMX and its returning a status code with a random 64bit Int
11:35:05 <EvanR-work> not actually random, its just large (13 or 14 billion billion), and different everytime
11:35:07 <earthy> tell me what to test.
11:35:15 <tromp> gratz on your new random number generatr
11:35:22 <EvanR-work> high five
11:35:43 <dpratt71> what's ADNS?
11:35:52 <EvanR-work> earthy: initResolver [] $ \resolver -> resolveMX resovler "gmail.com"
11:36:02 <EvanR-work> dpratt71: hsdns package
11:36:57 <EvanR-work> it works great on my 32bit workstation, and now that we deployed it to the server, it doesnt work. maybe have something to do with 64bitness
11:37:18 <EvanR-work> earthy: gotta import ADNS.Base
11:37:21 <mreh> resovler must be a typo?
11:37:23 <EvanR-work> erm Resolver
11:37:26 <rajeshsr> so finally did my sudoku with CSP heuristics! But i don't think it is any better than plain backtracking in terms of speed. Here it is: http://haskell.pastebin.com/5QApPFAF
11:37:26 <EvanR-work> yes it is
11:37:29 <earthy> drat.
11:37:35 <earthy> * Missing C library: adns
11:37:55 <EvanR-work> adns 1.4
11:38:09 * hackagebot hmumps 0.1.1 - Interpreter for the MUMPS langugae  http://hackage.haskell.org/package/hmumps-0.1.1 (AntoineLatter)
11:38:11 <EvanR-work> should be in the package manager, if not, tar.gz is straightforward
11:38:15 <m_88> what does "function (x:xs) = ..." means? What's 'xs' part?
11:38:15 <earthy> not 1.2?
11:38:19 <EvanR-work> no, 1.4
11:38:38 <EvanR-work> we have the same problem with 1.2, but the ADNS docs only refer to 1.4
11:39:15 <sepp2k> m_88: x:xs is a pattern which matches a list that has a as its first element and xs as the rest.
11:39:37 <sepp2k> By which I mean xs is a list containing all the elements but the first.
11:39:41 <rajeshsr> Good for the test case given in the haskell site it takes 1s, while backtracking takes 7s! :) so heuristics is really doing something!
11:39:49 <m_88> sepp2k: so like head list and tail list?
11:40:02 <sepp2k> head element and tail list, yes.
11:41:35 <dpratt71> it may be worth pointing out that pattern will match a one-or-more-element list (xs could be the empty list []), but not an empty list
11:43:48 <m_88> what does '.' do in haskell? i'd google but it's too short for searching :[
11:43:50 <c_wraith> :t ?f . const
11:43:51 <lambdabot> forall b a b1. (?f::(b1 -> a) -> b) => a -> b
11:44:06 <c_wraith> :t const ?f
11:44:07 <lambdabot> forall a b. (?f::a) => b -> a
11:44:10 <hpc> @src (.)
11:44:10 <lambdabot> (f . g) x = f (g x)
11:44:11 <lambdabot> NB: In lambdabot,  (.) = fmap
11:44:19 <c_wraith> that's new.
11:44:29 <c_wraith> When did that note get added to @src?
11:44:30 <sepp2k> m_88: . is function composition
11:44:38 <sepp2k> (like the circle thingy in maths)
11:44:41 <m_88> > +.2 3
11:44:42 <lambdabot>   <no location info>: parse error on input `+.'
11:44:50 <m_88> > (+).2 3
11:44:51 <lambdabot>   Ambiguous type variable `t' in the constraint:
11:44:51 <lambdabot>    `GHC.Num.Num t' arising f...
11:45:03 <m_88> humm
11:45:05 <sepp2k> m_88: Both operands of . need to be a function
11:45:11 <c_wraith> > (+) 0.2 3
11:45:11 <lambdabot>   3.2
11:45:13 <m_88> oh
11:45:26 <zygoloid> > (+) . [2, 3]
11:45:27 <lambdabot>   [{-3->-1;-2->0;-1->1;0->2;1->3;2->4;3->5},{-3->0;-2->1;-1->2;0->3;1->4;2->5...
11:45:29 <zygoloid> confusion win!
11:45:34 <m_88> (+1).(*2) 3
11:45:43 <zygoloid> > (+1).(*2) $ 3
11:45:44 <lambdabot>   7
11:45:45 <m_88> > (+1).(*2) 3
11:45:46 <lambdabot>   No instance for (GHC.Num.Num (f a))
11:45:46 <lambdabot>    arising from a use of `e_1123' at <i...
11:45:55 <m_88> o i c
11:45:56 <m_88> thanks
11:45:59 <mauke> m_88: (*2) 3 is not a function
11:46:02 <zygoloid> m_88: that parses as: (+1) . ((*2) 3)
11:46:15 <zygoloid> == (+1) . 6
11:46:32 <EvanR-work> @hoogle Int32
11:46:32 <lambdabot> Data.Int data Int32
11:46:42 <c_wraith> :t const (f :: a -> b)
11:46:42 <m_88> > ((+1).(*2)) 3
11:46:43 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
11:46:43 <lambdabot>       from the context ()
11:46:43 <lambdabot>       arising from a use of `f' at <interactive>:1:7
11:46:43 <lambdabot>   7
11:46:48 <m_88> i c
11:46:54 <c_wraith> :t const (f :: a -> a)
11:46:55 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr a)
11:46:55 <lambdabot>       from the context ()
11:46:55 <lambdabot>       arising from a use of `f' at <interactive>:1:7
11:47:07 <c_wraith> :t const (f :: Int -> Int)
11:47:08 <lambdabot>     No instance for (SimpleReflect.FromExpr Int)
11:47:08 <lambdabot>       arising from a use of `f' at <interactive>:1:7
11:47:08 <lambdabot>     Possible fix:
11:47:18 <c_wraith> :t const (id :: Int -> Int)
11:47:19 <lambdabot> forall b. b -> Int -> Int
11:47:52 <c_wraith> :t const id
11:47:53 <lambdabot> forall a b. b -> a -> a
11:48:09 <c_wraith> fine.  make it really easy to get what I was originally trying to check
11:48:31 <hpc> @src const
11:48:32 <lambdabot> const x _ = x
11:48:53 <hpc> oh, duh
11:50:12 <dpratt71> what's the point of const? does it mean something to the compiler?
11:50:34 <sepp2k> dpratt71: Sometimes it's useful to write point-free code.
11:50:37 <hpc> const turns its first param into a function
11:50:39 <c_wraith> It's a higher-order function.  You can use it anywhere you'd use a higher-order function with a type that unifies with it.
11:50:42 <hpc> but simply
11:50:44 <sepp2k> And no, it doesn't mean anything to the compiler
11:50:44 <earthy> gotta import ADNS.Resolver as well
11:50:45 <hpc> s/b/p
11:50:57 <EvanR-work> earthy: right, my message about that got washed away
11:51:44 <dpratt71> sepp2k, et al: I see, thanks
11:51:49 <c_wraith> :t foldl const
11:51:49 <lambdabot> forall a b. a -> [b] -> a
11:52:05 <c_wraith> > foldl const () [1..1000]
11:52:06 <lambdabot>   ()
11:52:16 * c_wraith implements id for lists!
11:52:37 <c_wraith> err, const
11:53:27 <c_wraith> > foldl (flip const) () [1..1000]
11:53:27 <lambdabot>   No instance for (GHC.Num.Num ())
11:53:28 <lambdabot>    arising from the literal `1' at <intera...
11:53:38 <c_wraith> > foldl (flip const) 5 [1..1000]
11:53:39 <lambdabot>   1000
11:54:09 <earthy> okay. what was that line supposed to do?
11:54:17 <earthy> or is main = initResolver [] $ \resolver -> resolveMX resolver "gmail.com"
11:54:22 <earthy> not enough? :)
11:56:06 <EvanR-work> earthy: right, you need to print the result
11:56:41 <earthy> Left (StatusCode 206158430208)
11:56:48 <EvanR-work> try again
11:56:51 <earthy> (repeatable)
11:56:59 <EvanR-work> :\
11:57:20 <EvanR-work> im running adnsStrerror (StatusCode 206158430208) now
11:57:33 <EvanR-work> *** Exception: Enum.toEnum{Int32}: tag (206158430208) is outside of bounds (-2147483648,2147483647)
11:57:41 <EvanR-work> where is this Int32 coming from
11:59:17 <earthy> testmain: Enum.toEnum{Int32}: tag (206158430208) is outside of bounds (-2147483648,2147483647)
11:59:21 <earthy> weird.
11:59:28 <c_wraith> Holy crap.  View Patterns really can be nice, but the stream of compiler warnings hurts my brain
12:01:10 <earthy> CInt
12:01:50 <EvanR-work> yeah
12:06:43 <jmcarthur> yeah the warnings are a shame
12:08:31 --- mode: ChanServ set +o mauke
12:08:31 --- mode: mauke set -q *!*@94.100.238.2
12:09:05 <earthy> ah. gotcha. sizeof int returns 4.
12:09:20 <earthy> so CInt is a 32 bit integer
12:09:25 <earthy> not a 64 bit integer
12:10:31 --- mode: mauke set -o mauke
12:11:40 <EvanR-work> earthy: right
12:11:52 <EvanR-work> linux 64bit C int is 4 bytes
12:12:55 <m_88> is `acc` a special word in haskell?
12:13:10 <mauke> no
12:13:27 <m_88> mm
12:13:50 <mauke> accio is a special word in harry potter, though
12:14:01 <m_88> oh
12:14:04 <m_88> thanks
12:14:19 <hpc> there are almost no reserved words in Haskell
12:14:54 <hpc> there's do, case, of, if, then, else, where, let, in, module, import, qualified, as
12:14:55 <aristid> :t type
12:14:56 <lambdabot> parse error on input `type'
12:14:58 <hpc> i think that's it
12:15:09 <aristid> hpc: how about type, data, newtype?
12:15:17 <hpc> right
12:15:26 <leadnose> instance, class?
12:15:27 <hpc> and class, instance
12:15:33 <rajeshsr> how to check if a list is singlenton without using length as it will make it O(N)
12:15:34 <ClaudiusMaximus> and 'default'
12:15:35 <rajeshsr> ?
12:15:39 <aristid> well that's an impressive list already :)
12:15:44 <hpc> default?
12:15:56 <rajeshsr> anyone?
12:16:02 <hpc> match against x:[]
12:16:13 <ClaudiusMaximus> > let xs = [1] in case xs of [x] -> x
12:16:14 <lambdabot>   1
12:16:15 <fryguybob> O(N) when N = 1 is O(1) ?
12:16:28 <hpc> isSingleton x:[] = True
12:16:32 <hpc> isSingleton _ = False
12:16:39 <rajeshsr> hpc, ha, cool!
12:17:08 <aristid> hpc: would you count : as a reserved word? :>
12:17:09 <ClaudiusMaximus> hpc: 'default' is for setting default types for cases when more than one type fits
12:17:17 <hpc> ah
12:17:23 <earthy> EvanR: I hope you've at least got a handle on the issue
12:17:31 <hpc> alternatively, you can replace x:[] with [x]
12:17:55 * earthy is off (the wife wants me away from the laptop)
12:18:51 <aristid> earthy: evil wife!
12:19:50 <mauke> hpc: lern2precedence
12:20:12 <hpc> mauke: ?
12:20:27 <mauke> isSingleton x:[] parses as (isSingleton x) : []
12:20:44 <rovar> are there any examples of how to use the maybe monad inside of IO?
12:20:56 <hpc> oh forgot about that
12:22:35 <EvanR-work> earthy: yes
12:23:10 <jmcarthur> should symbols in the syntax also count as keywords? they invade the space of operator identifiers, after all
12:23:43 <jmcarthur> well, i guess not all of them do
12:24:10 <hpc> @, ~, =, and <- are the only ones that come to mind
12:24:10 <lambdabot> Maybe you meant: . ? @ v
12:24:19 <jmcarthur> -- might be pushing it
12:24:24 <ido> kmc: you there?
12:24:55 <jmcarthur> -> too, because you can't define an operator with that name
12:25:24 <jmcarthur> > let a -> b = a + b in 5 -> 6
12:25:25 <lambdabot>   <no location info>: parse error on input `->'
12:25:59 <hpc> -> can theoretically be defined in terms of Haskell code though, i think
12:26:25 <jmcarthur> ?
12:26:25 <Eelis> hpc: what would that look like?
12:26:47 <Eelis> -> seems awfully primitive to me
12:27:22 <hpc> no idea, but it is an instance of a fair few typeclasses
12:27:52 <Eelis> i don't see why that would make it definable in Haskell
12:27:57 <jmcarthur> hpc: but it's been forced to the type level even though the lexical rules would normally say it should be value level
12:28:22 <hpc> i only half understand that
12:28:43 <jmcarthur> and even at the type level you can't redefine it
12:29:04 <jmcarthur> i actually stated it wrong
12:29:22 <jmcarthur> i meant that it's forced to be a constructor even though it should be a normal operator
12:29:31 <jmcarthur> and only at the type level, at that
12:29:31 <hpc> ah, i see now
12:33:49 <Apocalisp> Better way of saying this?
12:33:50 <Apocalisp> @type let test p xs = unfoldr (\x -> if null x then Nothing else Just (tail x, p x)) xs in test
12:33:51 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [[a]]
12:34:42 <Apocalisp> > let test p xs = unfoldr (\x -> if null x then Nothing else Just (tail x, p x)) xs in test (map even) [1,2,3,4,5]
12:34:43 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
12:34:43 <lambdabot>    arising from a use of ...
12:36:13 <Apocalisp> oops
12:36:14 <Apocalisp> @type let test p xs = unfoldr (\x -> if null x then Nothing else Just (p x, tail x)) xs in test
12:36:15 <lambdabot> forall a a1. ([a] -> a1) -> [a] -> [a1]
12:36:35 <Apocalisp> > let test p xs = unfoldr (\x -> if null x then Nothing else Just (p x, tail x)) xs in test (map even) [1,2,3,4,5]
12:36:36 <lambdabot>   [[False,True,False,True,False],[True,False,True,False],[False,True,False],[...
12:38:16 <Apocalisp> > let test p xs = unfoldr (\x -> if null x then Nothing else Just (p x, tail x)) xs in test (even . head) [1,2,3,4,5]
12:38:17 <lambdabot>   [False,True,False,True,False]
12:39:41 <Apocalisp> > let test p xs = unfoldr (\x -> if null x then Nothing else Just (p x, tail x)) xs in test ((`mod` 2) . sum) [1,2,3,4,5]
12:39:42 <lambdabot>   [1,0,0,1,1]
12:39:49 <rajeshsr> just one doubt: if f x == 5 then f x else 0
12:39:59 <rajeshsr> is f x evaluated twice when f x == 5 ?
12:40:08 <Apocalisp> no
12:40:20 <rajeshsr> how can that be optimized?
12:40:30 <rajeshsr> i mean how the compiler does factoring?
12:41:33 <pikhq> rajeshsr: f x may be evaluated 1 or more times in the execution of that statement.
12:41:47 <pikhq> Erm. In the evaluation of that statement.
12:41:51 <Jafet> > let f ((:) x xs) = (x, xs) in f [1,2,3]
12:41:52 <lambdabot>   (1,[2,3])
12:42:22 <rajeshsr> pikhq, so i will have to put it in where clause to factor it?
12:42:43 <burp> if f x == 5 then 5 else 0 :>
12:42:49 <pikhq> rajeshsr: Not necessarily.
12:43:16 <rajeshsr> burp, haha, if f x > 7 then f x else 0
12:43:24 <rajeshsr> this is something i have! :)
12:43:27 <burp> ok :P
12:43:34 <rajeshsr> so how to make it evaluate only once?
12:43:58 <pikhq> rajeshsr: Impossible to confirm that something will evaluate only once.
12:44:27 <pikhq> A Haskell implementation is perfectly free to evaluate something *entirely* every single time that its value is needed.
12:44:34 <Apocalisp> rajeshsr: you could use explicit memoisation
12:44:58 <fryguybob> let y = f x in if y > 7 then y else 0
12:45:18 <pikhq> Of course, most Haskell implementations are going to at least do the whole thunk thing. ;)
12:47:29 <rajeshsr> hmm, putting it in let seems to make it faster..
12:47:49 <illissius> in the way that you can use 'data SameType a b where Same :: SameType a a' to prove to the compiler that two types are in fact the same type, is there any way to prove to the compiler that two types are *not* the same?
12:48:18 <lispy> illissius: I'm only pretty sure:  No
12:48:31 <lispy> illissius: I don't have a proof or anything, but I seem to recall reading that's quite tricky
12:48:33 <illissius> that's my feeling as well, fwiw
12:49:43 <rajeshsr> k, my sudoku is finally up with 2 heuristics. Solves killer cases in 10s! Here it is, if anyone is interested: http://haskell.pastebin.com/TgHeSZeJ
12:49:57 <illissius> (at least if you want to do it in a similar way) you'd need some place in the language where you need to supply two types, and they're not allowed to be the same one
12:50:05 <rajeshsr> do give me feedbacks to improve!
12:50:12 <lispy> illissius: we have that, kind of
12:50:12 <illissius> and while i'm still sort of a beginner i can't think of any
12:50:21 <illissius> we do?
12:50:24 <Apocalisp> let if' b t e = if b then t else e in (flip (if' =<< (< 7)) 0) (f x)
12:50:27 <rajeshsr> BTW, does hpaste loads for anyone?
12:50:36 <lispy> illissius: When you bind a type in an existential pattern match it becomes distinct
12:50:41 <m_88> Umm, can someone explain me this please: http://pastebin.com/6ney7iVi
12:51:21 <lispy> data Foo where Foo :: a -> Foo; foo (Foo x) = -- x has some distinct type that is not equal to any other type
12:51:29 <m_88> Altho in http://www.zvon.org/other/haskell/Outputprelude/read_f.html it give some examples like `read "12"::Double`
12:51:45 <lispy> illissius: but that's still a bit different than what you're after
12:52:10 <illissius> yeah. not really the same
12:53:17 <aep> hey. i installed stuff for the user with cabal install, but Setup.hs won't find it. do i have to set some env stuff?
12:53:28 <lispy> aep: --user
12:53:42 <aep> aha. thanks
12:53:43 <lispy> aep: Or have cabal install things --global
12:54:10 <Cale> m_88: Just because the type a is a numeric type doesn't mean it's possible to parse values of that type using read
12:54:39 <Cale> m_88: That's what th Read class constraint is for: it says that a parser exists for reading strings that represent values of that type
12:55:21 <mreh> I had always wondered how to import instances
12:55:25 <mreh> can this be fixed?
12:55:48 <lispy> mreh: Isn't there a proposal that allows explicit import/export of instances?
12:55:59 <mreh> hope so
12:55:59 <lispy> mreh: I'd check the haskell' wiki
12:56:19 <lispy> mreh: the best thing you can do is go comment on it and help by working on the ticket
12:56:40 <lispy> The more people who want it and are willing to move it forward in the proposal process the faster we get it :)
12:56:44 <rajeshsr> Cale, finally wrote my sudoku with 2 heuristics. Takes 10s for the killer case given in haskell sudoku page. Here is the code: http://haskell.pastebin.com/TgHeSZeJ
12:56:59 <Cale> mreh: The problem is that instances don't really have names
12:57:11 <rajeshsr> i am really thrilled by the generalization which haskell forced on me!
12:57:12 <mreh> mm
12:57:35 <rajeshsr> never before have i seen elimination process as independent on row, column etc! :)
12:57:40 <Cale> It would be awkward to refer to them in import/export lists.
12:58:55 <Cale> rajeshsr: btw, if you have very long lines, note that you can break the line almost anywhere you like, as long as you indent the remaining piece a bit more than the first bit.
13:00:18 <rajeshsr> Cale, hmm, my editor wordwraps it so i didn't face problem viewing it. Thanks for the tip, let me keep that in mind!
13:00:37 <lispy> Is there anyway to get emacs to display the \ in lambdas as a lambda or is \ too ambiguous?
13:03:09 <Philonous> lispy: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Unicodifying_symbols_.28Pretty_Lambda_for_Haskell-mode.29
13:03:49 <lispy> Philonous: That lets you change things like "lambda" into a single unicode character for lambda, but doesn't handle \ x -> x
13:04:01 <lispy> Philonous: (I already tried it :)
13:04:33 <Saizan> switch to agda :P
13:04:49 <rajeshsr> Cale, may be changing it to arrays can make it faster..
13:05:10 <lispy> Saizan: heh, that's part of why I was interested in this :)
13:05:11 <c_wraith> did my question about view patterns make it through?
13:05:12 <Philonous> lispy: You can define a regexp for '\' and change that to unicode lambda.
13:05:37 <Philonous> lispy: I've done it. And didn't like it.
13:05:38 <Saizan> c_wraith: no
13:05:43 <lispy> Philonous: I wonder how well that will actually work for haskell
13:06:11 <m_88> Cale: i see, thanks
13:06:11 <c_wraith> Ah.  I was wondering if there's any accepted way to break a long (and nested) view pattern into multiple lines.
13:06:16 <lispy> Philonous: I used the "lambda" to lambda symbol one with lisp, but I found there that it screwed with column alignment too much.
13:06:50 <lispy> Philonous: do you remember what you didn't like about it?
13:07:03 <lispy> Philonous: too many false positives on the regex?
13:07:25 <Philonous> lispy: Some, and that's anoying as it is. And I figured that is just isn't haskell anymore.
13:07:53 <tov> i'm wondering if anyone can tell me the right way to include a type family instance in an hs-boot file.  I'm getting a warning:     Warning: No explicit AT declaration for `Annotation'
13:08:48 <lispy> tov: This isn't very helpful for your problem, but I would avoid hs-boot files if you can :)
13:09:12 <lispy> tov: I think usually you can just define a 3rd module that breaks the cycle, but I don't know..
13:09:31 <tov> my choices are: 1) have an hs-boot file, 2) have a 3000 line file, 3) add an extra parameter to a type constructor
13:10:53 <Philonous> lispy: Also, I found it strange to have lambdas in emacs and backslashes everywhere else.
13:11:16 <lispy> Philonous: so, really we need GHC to accept lambda for \ ?
13:11:24 <lispy> Philonous: maybe someone has worked on that
13:11:25 <Philonous> lispy: I just wanted to propose that
13:11:51 <Philonous> lispy: Can't be that hard. Just parse the source file and replace utf-lambdas with \
13:12:49 <lispy> Philonous: oh, interesting, so when ghc is being unicode aware lambda is just another letter to it
13:13:08 <lispy> Philonous: so, we'd have to make an in-elegant exception for one character :(
13:13:26 <lispy> (I got that info about how ghc would handle it from RWH)
13:13:33 <EvanR-work> let Î» = 42 in Î»
13:13:35 * lispy [citation needed]
13:13:39 <EvanR-work> > let Î» = 42 in Î»
13:13:40 <lambdabot>   42
13:14:00 <lispy> > let a Î» b = a + b in 1 Î» 3
13:14:01 <lambdabot>   Not in scope: `Î»'
13:14:16 <|littlebear|> O.O, isn't that UTF-8 Chinese?
13:14:17 <Philonous> lispy: Well, you'd have to be context-aware anyway, because you don't want to replace them in quotes
13:14:17 <ikke> Î»
13:14:19 <lispy> > let a Î» b = a + b in 1 `Î»` 3
13:14:20 <lambdabot>   Not in scope: `Î»'
13:14:40 <|littlebear|> let a % b = 3
13:14:58 <lispy> > let Î» a b = a + b in 1 `Î»` 3
13:14:59 <lambdabot>   4
13:15:05 <lispy> That's just funky :)
13:15:24 <EvanR-work> |littlebear|: no.. its lambda
13:15:38 <|littlebear|> EvanR: werid, on mine it just chinese font
13:15:43 <lispy> We need a 'unicode-spiffy' version of haskell, .uhs files :)
13:16:22 <ystael> that way lies Coq, I think
13:16:26 <EvanR-work> |littlebear|: sounds like an encoding mismatch
13:16:30 <EvanR-work> im using utf8
13:16:36 <Cale> Probably the Î» you use for lambda shouldn't just be the Greek letter one, but one of the mathematical symbol lambdas in unicode.
13:16:53 <|littlebear|> yeah
13:17:02 <|littlebear|> probably i have my fonts set to GB-2312
13:17:30 <lispy> Cale: good point
13:17:43 <tensorpudding> Which math-symbol lambda?
13:17:54 <Cale> perhaps ðœ†
13:17:55 <lispy> Cale: so, do you have one handy to test if GHC treats it as a letter or a symbol?
13:18:02 <aristid> > let Î» = (+) in 1 `Î»` 3
13:18:03 <lambdabot>   4
13:18:09 <tensorpudding> ð›Œ
13:18:24 <lispy> > let a ðœ† b = a + b in 1 ðœ† 1
13:18:25 <lambdabot>   Not in scope: `ðœ†'
13:18:30 <Philonous> What, just how many lambdas are there in utf 8?
13:18:33 <lispy> Still a letter :(
13:18:39 <EvanR-work> boo, i cant see ðœ† in xterm gnu unifont :(
13:19:01 <lispy> Cale:  what app do you use to select unicode characters in X?
13:19:07 <Cale> gucharmap
13:19:35 <lispy> Cale: thanks!
13:21:20 <EvanR-work> okaay looks like i need to learn the FFI stuff for real. second time ive had to fix a binding to a c lib
13:21:27 <EvanR-work> id like to know what im friggin doing
13:21:55 <lispy> > let (â) = (+) in 1 â 2
13:21:57 <lambdabot>   3
13:22:10 <lispy> That's got the right shape, but it's a terrible lambda
13:22:29 <EvanR-work> its left-right reversed in my font :(
13:22:49 <dino-> lispy: That's spooky
13:23:25 <lispy> hah, it is backwards and I just didn't notice that, sorry!
13:23:42 <dino-> It just looks like this to me: let ( ) = (+) in 1   2
13:23:48 <dino-> Is there something in there I'm not seeing?
13:23:58 <jmcarthur> he nice thing about Î» not being syntax is you can use it for HOAS:  Î» :: (exp a -> exp b) -> exp (a -> b)
13:24:01 <lispy> dino-: ah yeah, you're missing a symbol
13:24:05 <jmcarthur> *the nice
13:24:08 <EvanR-work> dino-: i can     it just fine
13:24:11 <Cale> Yeah, that's not a lambda, it's a proofreader's insertion mark
13:25:16 <dino-> > let a ` ` b = a + b in 1 ` ` 3  -- should not work
13:25:17 <lambdabot>   <no location info>: parse error on input ``'
13:25:31 <djahandarie> > let Î» = reduce; (.) = (\x -> expr) in (Î»)a.a
13:25:32 <lambdabot>   a
13:25:38 <djahandarie> > let Î» = reduce; (.) = (\x -> expr) in (Î»)a.a+1
13:25:39 <Cale> dino-: a little thing that looks like a backwards lambda or half-circle-rotated y and is just a bit larger than a comma
13:25:39 <lambdabot>   a + 1
13:25:41 <djahandarie> > let Î» = reduce; (.) = (\x -> expr) in (Î»)a.2+1
13:25:41 <lambdabot>   2 + 1
13:25:47 <djahandarie> Ah damn, heh
13:25:54 <jmcarthur> that was looking cool
13:26:09 <jmcarthur> :t reduce
13:26:09 <lambdabot> Expr -> Expr
13:26:12 <jmcarthur> ah
13:26:27 <dino-> Cale: My urxvt failed me. boo
13:27:09 <Cale> > let x â‚ y = product [1..x] * product [1..y] in 3 â‚ 5
13:27:09 <lambdabot>   720
13:27:16 <jmcarthur> woah
13:27:21 <jmcarthur> that is a crazy operator
13:28:02 <Philonous> Hah, I like it!
13:28:21 <jmcarthur> needs some kerning in my monospace font
13:28:31 <djahandarie> My putty is pooping out on this unicode. :(
13:28:47 <jmcarthur> "My putty is pooping out..."  :o
13:28:52 <dino-> I'm reminded of when they wanted to use Â¥ for zip in Perl6. To be fair, they would have always carried both the operator symbol and the spelled-out function, iirc.
13:29:34 <Philonous> dino-: I think we should have little animations with stickman performing the denoted operation!
13:31:12 <dino-> Make Philonous stop scaring me
13:32:38 <djahandarie> > let Î» = reduce; (.) x y = reduce in (Î»)a.(1 + 1)
13:32:39 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
13:32:39 <lambdabot>    arising from...
13:32:45 <djahandarie> Agh
13:33:15 <djahandarie> > let Î» = reduce; (.) x y = reduce y in (Î»)a.(1 + 1)
13:33:15 <lambdabot>   2
13:33:40 <djahandarie> Could abuse another infix operator to fix the paren problem...
13:34:17 <Cale> http://www.onion.com/ = http://bit.ly/ ?
13:34:25 <Cale> Is anyone else seeing that? :)
13:34:36 <xerox> yes
13:34:54 <hpc> ...the hell?
13:35:48 <djahandarie> Working fine for me
13:35:53 <fryguybob> I see bit.ly
13:35:56 <aristid> Cale: you forgot the the: http://www.theonion.com/
13:35:59 * hackagebot json 0.4.4 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.4.4 (IavorDiatchki)
13:36:06 <fryguybob> Who broke the Internet?
13:36:39 <Cale> aristid: hmm, that works, but I'm certain that onion.com used to, as my bookmark for it uses that address.
13:37:05 <interferon> anyone know of a constant-space quicksort implementation in haskell?
13:37:19 <aristid> Cale: i understand your despair when you can't access America's Finest News Source.
13:37:29 <c_wraith> huh.  new version of the library I'm working with right now.  I wish there was a convention for changelogs on hackage
13:37:37 <Cale> What do you mean 'constant space'? Any implementation of quicksort uses at least linear space.
13:37:43 <c_wraith> interferon: that would be impossible by definition for lists
13:38:08 <interferon> c_wraith: ok, that's true
13:38:13 <c_wraith> You could have a constant-space quicksort implementation for mutable arrays
13:38:38 <Cale> Even if you do it in-place, you need space for the array.
13:39:06 <c_wraith> Well, it doesn't need to allocate more than O(1) within the sort algorithm, which is what I consider constant-space
13:39:31 <c_wraith> though more traditional implementations allocate O(log n) space for the recursion stack
13:39:50 <dino-> I could see the bit.ly people snarfing that short domain up while hunting for other short ones.
13:41:06 <Cale> hmm, that's a good point as well, even if you don't count the space for the input, there's space required to record where you are in the recursion.
13:41:40 <m_88> Is it posible to translate an expression from Infix notation to Inverse Polish notation without using parsing tools/libraries?
13:42:06 <Cale> m_88: Probably not?
13:42:19 <m_88> Cale: ok, thanks
13:42:22 <Cale> m_88: I mean, I suppose it depends on what you consider a parsing tool.
13:42:22 <Baughn> byorgey: So hold on, did your detective die, or what?
13:42:34 <Jafet> m_88, is it possible to eat spaghetti without getting sauce on your clothes
13:42:41 <Cale> m_88: You could write a bunch of list functions which would essentially consist of doing infix expression parsing.
13:42:42 <m_88> Cale: modules like Parsec
13:42:50 <djahandarie> m_88, you can definitely without Parsec
13:43:03 <m_88> Can I write it in one function?
13:43:16 <Cale> You could, but wouldn't want to.
13:43:21 <m_88> why?
13:43:28 <djahandarie> You can write anything in one function
13:43:33 <Cale> Because it would be a horrible looking function.
13:43:56 <Cale> It would just be making things needlessly difficult for yourself.
13:46:28 <dino-> Cale: I wrote the onion guy on tw, he is supposed to have onion.com and is looking into it now. You discovered some internet thievery!
13:46:29 <m_88> Uhh it's still so hard for me to code in FP way. Converting infix to inverse notation requires a stack, for example. Should I use local list for that?
13:46:35 <Cale> http://www.theonion.com/articles/exhausted-noam-chomsky-just-going-to-try-and-enjoy,17404/
13:47:32 <Cale> m_88: It's quite possible to use a list as a stack. By 'local', you probably mean a function parameter.
13:48:05 <Apocalisp> Optimisation question: \xs -> map Data.Foldable.fold . map tails $ inits xs. I'm folding a lot of the same lists over and over again. Can I exploit the fact that I've folded the init of a list already?
13:48:36 <Cale> Why Data.Foldable.fold?
13:48:50 <Apocalisp> to simplify the example
13:48:51 <Cale> oh, because you want the monoidal operation?
13:48:57 <Cale> hmm
13:49:03 <Cale> You probably want to use scanl somehow
13:49:08 <m_88> Cale: function parameter? So you think I should use recursion for that?
13:49:20 <Apocalisp> hmm, scanl
13:49:22 <Cale> m_88: Well, I don't know what else you could mean by 'local'
13:49:26 <m_88> that's actually a better idea than using foldr
13:49:42 <c_wraith> m_88: look into recursive descent parsers.  They're easy to understand, and easy to implement by hand
13:49:45 <Cale> m_88: You could use recursion, and then work out how to turn that into higher-order stuff
13:49:55 <m_88> Ok
13:49:56 <m_88> thanks
13:50:08 <Cale> m_88: and you'd probably end up reinventing half a parser combinator library ;)
13:50:37 <m_88> i know but that's a good practice for newbie, i assume?
13:51:00 <m_88> implementing handy functions in a simple (stupid) way
13:51:39 <c_wraith> It will certainly make parser combinator libraries easier to understand
13:51:44 <Cale> It's good to get a handle on how to translate imperative algorithms with mutable local variables into a bunch of mutually recursive functions where the mutable variables have become function parameters
13:52:01 <EvanR-work> ok
13:52:13 <EvanR-work> identified a 64bit incompatability in ADNS bindings
13:52:19 <Cale> You can do this with any imperative algorithm, and I often have just to understand what the imperative algorithm is doing :)
13:52:45 <Cale> You take each step, and turn it into a function, and all the mutable variables become function parameters
13:52:52 <EvanR-work> the storable instance uses magic numbers that are just wrong on 64bit linux :(
13:53:01 <Cale> and you have the steps call each other according to the control flow of the imperative program
13:53:22 <Cale> and the parameters to the functions vary as the mutable variables would
13:53:43 <Cale> The initial result is usually a tangled mess, but it's a tangled mess that was implicit in the imperative code :)
13:53:58 <Cale> You can then start to simplify things, and sometimes end up with a nice functional program
13:54:16 <Cale> (though it's often not the easiest way forward, it's a very methodical thing to do)
13:55:41 <iago> hello, I would like to know suggestions about this problem....: I would like to extend Haskell with some stuff and typecheck sources re-using work done for a Haskell typechecker... to write a typechecker from scratch seems too hard (too many extensions...), and the other option that I considered is to translate the "extended language" to some Haskell code (equivalent for type inference purposes) and later extract the type info, but t
13:55:41 <iago> his last option seems a bit ugly. Am I losing another easier/cleaner choice?
13:56:52 <aristid> Cale: i love the chomsky thing
13:57:19 <lispy> Philonous: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#unicode-syntax
13:57:52 <lispy> That's most stuff except the \ as lambda
13:58:26 <monochrom> I too sometimes just convert imperative algorithm to functional algorithm. Sometimes I even add to the mess by adding continuations and trampolining. XD
13:59:23 <aristid> lispy: i think unicode in code is a bad idea.
13:59:41 <monochrom> unfortunately Î» is alpabetical
14:00:00 <monochrom> @quote 1970
14:00:00 <lambdabot> JamesIry says: 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
14:00:04 <monochrom> @quote 1970
14:00:05 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
14:00:12 <monochrom> that one
14:00:27 <aristid> haskell.org is slow for me :(
14:01:32 <m_88> Uhh, what does this mean:  Couldn't match expected type `[Char]' against inferred type `Char'
14:01:32 <m_88>       Expected type: [[Char]]
14:01:32 <m_88>       Inferred type: [Char]
14:01:32 <m_88>  
14:01:48 <m_88> On line 1 it says that it was expecting [Char], late it says that it was expecting
14:01:50 <m_88> [[Char]]
14:01:51 <m_88> wtf?
14:02:27 <monochrom> we should start using unicode in code generously. this is a break-the-vicious-cycle tactic. the only way to motivate damn programmers to add keyboard support to many symbols.
14:03:29 <monochrom> programmers are egotistic. they only provide what they need. to force them to provide X, force them to need X.
14:05:38 <roconnor_> > 150 * 6
14:05:39 <lambdabot>   900
14:05:57 <m_88> Uhh, can someone tell me what's wrong with this code please: http://pastebin.com/3e43MNuR
14:06:04 <m_88> I am bad at picking up ghc errors
14:06:58 <glguy_> ((head txt) == "+"
14:07:02 <glguy_> '+'
14:07:08 <m_88> thanks
14:07:11 <m_88> got it
14:07:16 <glguy_> (null txt == True)  -->  null txt
14:07:20 <m_88> strong typisation :/
14:07:41 <m_88> glguy_: i was adviced by some guy earlier to write == True :(
14:07:45 <m_88> but thanks a plenty
14:07:48 <glguy_> they were joking :(
14:07:58 <m_88> fff
14:08:46 <m_88> *Main> normalToPoliz "2 + 3" "" ""
14:08:46 <m_88> "2  3+"
14:08:46 <m_88>  
14:08:47 <m_88> yay!
14:08:48 <Philonous> Is that just me or is haskell.org not responding?
14:08:50 <m_88> almosy there
14:09:23 <m_88> hmm Philonous, looks down for me too
14:09:31 <m_88> altho I can ping it, web page doesnt load
14:09:37 <Philonous> Same here
14:09:40 <glguy_> m_88 http://pastebin.com/g0qqLL48
14:10:14 <glguy_> I didn't load that in GHC, but you should try that style of pattern matching
14:11:39 <m_88> ok, thanks glguy_
14:13:32 <aristid> http://downforeveryoneorjustme.com/haskell.org
14:16:00 <EvanR-work> hey, does peter simons get on #haskell
14:20:30 <EvanR-work> whats the right way to write c bindings so that they work in a 64bit env
14:25:19 <kmc> same as for any other environment
14:25:28 <kmc> are you running into a particular problem?
14:26:15 <EvanR-work> the ADNS storable instances use magic numbers that work in 32, but not in 64
14:26:23 <EvanR-work> is that just how it is?
14:26:43 <kmc> i don't know anything about that
14:26:54 <kmc> what ADNS is, and whether its Storable instance has a bug
14:27:06 <EvanR-work> its a general ffi question
14:27:14 <EvanR-work> http://hackage.haskell.org/package/hsdns-1.4.2
14:28:13 <kmc> then i'm not sure what the question is
14:28:33 <EvanR-work> rah
14:28:53 <kmc> it is certainly possible for a Storable instance to detect word size, endianness, etc. and do the correct thing for every architecture
14:28:58 <EvanR-work> just looked at the code, its got #{size foo} in it...
14:28:59 <kmc> if the format requires it
14:29:17 <kmc> it is better when binary formats are standard regardless of architecture, but that may be less efficient
14:29:23 <EvanR-work> so i would expect my version to have the right sizes and offsets
14:29:42 <EvanR-work> i did cabal install hsdns
14:30:03 <EvanR-work> but when i use the library on the 64bit machine, i get crazy results from the c bindings
14:31:00 <sinelaw> hey all
14:31:55 <kmc> hi
14:32:31 <sinelaw> sup?
14:32:47 <sinelaw> my haskell-powered face-tracking robot works
14:33:03 <sinelaw> so hide your faces, lest you be run over
14:35:55 <mreh> ballGUI :: GUI () ()
14:35:55 <mreh> ballGUI = first (mouseST >>> arr (move ballPic))
14:36:10 <Cale> mreh: Is that yampa?
14:36:18 <siracusa> I want two instances of my program to communicate over the web with each other. What library may I use to achieve this very easily?
14:36:23 <mreh> Cale: it's fruit, written in yampa yes
14:36:26 <Cale> ah :)
14:36:56 <mreh> GUI has type "ST (GUIInput, a) (Picture, b)"
14:37:04 <Cale> siracusa: Over the web specifically, or just the internet?
14:37:33 <mreh> there isn't enough information in the definition for the compiler to infer that a = () and b = (), because there is no implementation of it
14:38:06 <mreh> Cale: yampa is amazing, and should be used by everyone!!!
14:38:12 <siracusa> Cale: Hhm ... what's the difference? :-)
14:38:21 <mreh> learning curve is steep, but they'll love it
14:39:00 <Cale> siracusa: The web would mean communicating presumably on port 80 and using the HTTP protocol.
14:39:37 <Cale> siracusa: If you just want two instances of a program to talk to each other, it's easier just to open a plain TCP connection and shove strings down it in both directions :)
14:40:18 <Cale> (maybe)
14:40:24 <siracusa> Cale: Yeah, that's what I want, but the network library looks a bit low-level.
14:40:31 <Cale> I suppose using the CGI and HTTP libraries wouldn't be much harder.
14:40:48 <Cale> You can use the high-level Network interface though, and it's pretty easy.
14:40:56 <Cale> I'll make a demo, just a sec :)
14:41:04 <blackh> siracusa: There's a new one, but I haven't tried it: http://phaul.hobby-site.org/node/4123
14:42:34 <kmc> yeah
14:42:38 <kmc> that's not web though
14:43:27 <lispy> Does mmorrow know that hpaste is b0rked?
14:43:37 <monochrom> again? :)
14:43:43 <mreh> doesn't he keep all his code on there?
14:44:22 <blackh> siracusa: Another option is my hexpat-iteratee package.  I've successfully combined it with Wai to get XML over HTTP.
14:44:44 <blackh> Then you'd use hexpat-pickle to pickle to/from XML.  That way may or may not be appropriate to what you want.
14:46:49 <siracusa> blackh: hexpat-* is not for sending/receiving, is it?
14:48:08 <blackh> siracusa: No, but the idea with hexpat-iteratee is that it's meant to play nicely with sockets.
14:48:39 <blackh> Basically you need something that connects sockets to iteratee - not sure if iteratee provides that but it'd be a natural component to use.
14:49:13 <blackh> I am about to upgrade hexpat-iteratee but I'm waiting on the maintainer of the List package.
14:51:29 <blackh> iteratee provides fileDriverFd which should do the trick.
14:52:29 <blackh> If you are looking for something easy, it might not be your first choice.
14:53:11 <blackh> siracusa: If you are interested, I could write you a skeleton.  That could go into the examples for the package.
14:53:28 <blackh> Anyway, let me know.
14:56:40 <siracusa> blackh: I'm not sure if hexpat isn't a bit of overhead, I just want two client programs to send simple string messages to each other.
14:59:03 <byorgey> Baughn: not necessarily
15:00:05 <byorgey> Baughn: perhaps I should solicit endings, and post the best one(s) on the Monad.Reader blog =)
15:00:09 <siracusa> Since I'm using Gtk2Hs, the perfect solution would be a package that adds new handlers like onReceiveData :-)
15:00:16 <Cale> siracusa: one sec while I paste :)
15:00:22 <Cale> hpaste seems down...
15:01:44 <Cale> http://paste.lisp.org/display/99156
15:02:24 <monochrom> is haskell platform 2010 official now? i.e., out of beta?
15:02:59 <Cale> siracusa: ^^
15:03:04 <siracusa> Cale: Thank you! Looks not that complicated I thought i would be
15:03:29 <Baughn> byorgey: Well.. in theory, so long as he doesn't do anything that depends on whether he's alive or dead, the thunk won't be forced.
15:03:41 <Cale> siracusa: Yeah, there's a tiny amount of concurrency (see the forkIO there) if you want to handle multiple clients, but that's it.
15:03:57 <byorgey> Baughn: that's the spirit =)
15:04:03 <monochrom> heh, cabal-sort. cabalogical sort. :)
15:04:28 <Baughn> byorgey: And then you can use unsafeCoerce to alter it.
15:06:30 <monochrom> w00t new TMR!
15:06:31 <siracusa> Cale: So when I use Gtk2Hs it would not be a problem to fork the main loop to a second thread?
15:14:31 * hackagebot extcore 0.6 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.6 (TimChevalier)
15:16:05 <Cale> siracusa: oh, hmm
15:16:31 <Cale> siracusa: I think that as long as you keep all the Gtk2 calls in the same thread it *should* be fine
15:17:46 <EvanR-work> kmc: i investigated further. cabal build does some preprocessing on the bindings and fills in the offsets for the struct in question, but they are clearly wrong for a 64bit c lib on linux. like 4 bytes for a pointer
15:17:53 <EvanR-work> so maybe theres something wrong with my compiler
15:18:25 <siracusa> Bah, linker error from network library: undefined reference to `getnameinfo' :-S
15:18:45 <kmc> did you use ghc --make
15:19:32 <siracusa> Yes
15:20:55 <EvanR-work> kmc: i did cabal build
15:47:59 <lispy> monochrom: the mac version has issues when linking macports things.
15:48:10 <lispy> monochrom: but, otherwise, I believe the current HP is pretty solid
15:54:24 <Kaidelong> it strikes me that Haskell's type classes are somewhat impotent without the extensions
15:54:44 <Kaidelong> having tried to implement a type class for vectors and instances of that class
15:54:58 <Kaidelong> multiparameter type classes could fix the problem I'm having
15:55:11 <Cale> Well, depends how much polymorphism you want exactly.
15:55:14 <Kaidelong> any other extensions that are used most of the time?
15:55:51 <Cale> in place of MPTCs and fundeps, you could use type families
15:56:15 <glguy_> \o/
15:57:47 * hackagebot List 0.4.0 - List monad transformer and class  http://hackage.haskell.org/package/List-0.4.0 (YairChuchem)
15:58:47 * hackagebot generator 0.5.4 - Python-generators notation for creation of monadic lists  http://hackage.haskell.org/package/generator-0.5.4 (YairChuchem)
15:59:31 <Cale> Kaidelong: something like:
15:59:34 <Cale> class Vector v where
15:59:39 <Cale>   type Scalar v
15:59:54 <Cale>   (.*) :: Scalar v -> v -> v
16:00:37 <Cale> (er, should have written that *. to follow my own convention :)
16:00:46 <Cale>   (.+.) :: v -> v -> v
16:01:14 <Cale> instance Vector (Double, Double) where
16:01:23 <Cale>   type Scalar (Double, Double) = Double
16:01:26 <Cale>   ...
16:02:13 <Claudius1aximus> i prefer ^, so i can write things like m1 ^^*^^ m2 ^^*^ v1 ^* 42  (assuming appropriate fixities)
16:02:45 <Claudius1aximus> and make it look like a horde of bats have infiltrated my code
16:02:47 <Cale> Oh, interesting :)
16:02:48 <Cale> hehe
16:30:15 <siracusa> Is GHC bound to the GCC version taht comes with it?
16:30:21 <siracusa> *that
16:31:09 <kmc> don't think so
16:31:32 <kmc> if you're using the default native codegen, i'm not sure gcc is even involved
16:31:39 <kmc> if you pass ghc a .c file (for FFI) it will invoke gcc
16:34:09 <siracusa> Hhm, I'm having linker problems with all packages that had to be compiled using MinGW and thought this may be the cause.
16:35:50 <kmc> ah, windows.  that might be an extra wrinkle
16:35:56 <kmc> i don't know much there, sorry :/
17:09:17 <c_wraith> Is it worth introducing a type class that's never exported from a module just to simplify the code within the module?
17:09:38 <Pseudonym> Yes, of course.
17:10:00 <aavogt> haddock tends to reveal the existence of those classes for some reason
17:10:13 <Pseudonym> Well, you can't control whether or not a type class instance is exported.
17:10:24 <aavogt> but the class itself isn't exported
17:10:25 <Pseudonym> You can control the export scope of the type class, but not the instance.
17:10:27 <c_wraith> No, I mean the class won't be exported
17:10:29 <Pseudonym> Yeah.
17:10:55 <Pseudonym> Well, that sounds like a bug in Haddock.  Or, more likely, yet another problem with the Haskell module system.
17:12:36 <aavogt> Pseudonym: presumably there's no check whether or not the class is defined in the same module
17:14:15 <aavogt> module M (T(T)) where { data T = T; class C a; {- | should be hidden -}; instance C T }
17:14:27 <Pseudonym> Right.
17:14:42 <Pseudonym> But if you exported class C, then instance C T would be exported and you have no say in the matter.
17:16:41 <c_wraith> huh.  ghc 6.10 doesn't have a warning for defining a typeclass but not exporting it or calling a function it provides.
17:17:25 <aavogt> Pseudonym: what does it mean to export instances of a class that isn't exported?
17:18:07 <Pseudonym> Probably nothing.
17:18:09 <c_wraith> I guess the fact that I declared an instance of it means it was used, even though it doesn't actually mean anything without something calling the typeclass function somehow
17:18:19 <Pseudonym> Because you can't use a class instance if you can't see the class.
17:18:42 <Pseudonym> Though I don't know what this means:
17:19:15 <Pseudonym> module M (T(T)) where { data T a = (C a) => T a; class C where {...} }
17:19:42 <aavogt> you can't use the constructor T?
17:19:50 <Pseudonym> Or, similarly, if you export a function where C appears in its signature, but don't export C.
17:20:27 <c_wraith> That's perfectly legal.
17:20:37 <c_wraith> It allows you to close a typeclass, essentially.
17:20:42 <aavogt> though if C does have some instances I suppose you can use T
17:21:12 <c_wraith> You can't define your own members of the typeclass.  you can only use ones defined in the module where the class was.
17:21:24 <Pseudonym> Ah, good point.
17:21:28 <c_wraith> I know I've seen at least one library that did that.  (annoying)
17:22:38 <aavogt> oh true. Happstack does that with RqData or something
17:27:22 <c_wraith> that also qualifies as a reason why haddock would leak the existence of a class that's not exported.
17:30:13 <Kaidelong> is there a justification for something like f x = 5 not triggering a warning that it isn't f _ = 5?
17:30:28 <Kaidelong> or does that warning occur if I toggle some GHC option?
17:30:46 <gwern> Kaidelong: are you using -Wall?
17:30:56 <Kaidelong> gwern: I'll try that then
17:31:09 <gwern> -_- don't complain about missing warnings if you aren't enabling warnings
17:31:37 <hpc> it doesn't reduce performance, in any event
17:31:41 <Kaidelong> gwern: I was just asking why I wasn't seeing it, I figured either warnings had to be enabled explicitly or it's not considered something to warn about
17:31:56 <Kaidelong> hpc: but it could be that the programmer did intend to use the parameter
17:32:13 <hpc> fair point
17:32:22 <gwern> well, that's why it's checked for at all
17:32:37 <aavogt> I find that catches quite a few bugs
17:38:57 <jlouis> new record... 0.0697 CPU seconds per megabyte here: http://jlouis.github.com/combinatorrent/
17:40:23 <jmcarthur> jlouis: nice
17:41:06 <jlouis> And I have some ideas for further improvements
18:08:13 <Kaidelong> is there a term for something that is not commutative but is associative both directions?
18:08:21 <Kaidelong> IE
18:08:47 <Kaidelong> (a # b) # c == a # (b # c)   but   a # b /= b # a
18:09:22 <danharaj> Associative?
18:09:44 <Kaidelong> that's it?
18:09:49 <Kaidelong> okay, cool
18:10:07 <danharaj> If you're talking about only one operation, then it's commutative ones that get special names.
18:10:27 <Kaidelong> just one operation, but it's not commutative
18:10:35 <danharaj> But associative.
18:10:41 <Kaidelong> but if you use a left association rule on it you get the same esult as a right associative rule
18:10:57 <danharaj> Does it have an identity?
18:11:32 <Kaidelong> Hmm, I was thinking about function composition, so yeah
18:11:43 <danharaj> Does every element have an inverse?
18:11:56 <Kaidelong> in theory
18:12:01 <danharaj> (Well if you're thinking of function composition, no)
18:12:02 <Kaidelong> wait no
18:12:10 <danharaj> That structure is called a monoid.
18:12:31 <danharaj> If you drop the identity element requirement, it's called a semigroup.
18:12:48 <danharaj> If you drop from a semigroup the requirement of associativity, it's called a magma.
18:13:06 <danharaj> If you add to a monoid the existence of inverses for every element, then it's called a group.
18:13:38 <Kaidelong> huh, this is category theory?
18:13:47 <danharaj> This is abstract algebra.
18:13:50 <Kaidelong> ah okay
18:13:56 <Kaidelong> I'll take it then, offered here
18:14:01 <danharaj> A monoid is like a category, actually.
18:14:09 <danharaj> And a category is like a generalization of monoids.
18:14:23 <danharaj> Function composition, actually.
18:14:40 <danharaj> If all your functions have a set X as domain and codomain, they form a monoid.
18:14:44 <uorygl> Do Haskell's "Arrows" correspond to any notable thing in category theory?
18:15:03 <danharaj> uorygl: Something about kleisli categories.
18:15:22 <danharaj> uorygl: There are much more knowledgable users who could answer that though.
18:20:14 <Kaidelong> hmm associativity was covered inmy old textbook, I'd just forgotten the term
18:20:28 <Kaidelong> sadly have a tendency to do that
18:20:35 <jmcarthur> Kaidelong: the Endo newtype provides this behavior as an instance of Monoid
18:20:55 <danharaj> non-associative operations tend to be less common than associative ones.
18:21:11 <danharaj> There are some very important ones though, like lie algebras.
18:21:24 <danharaj> And floating point arithmetic is non-associative amongst other terrible properties.
18:21:34 <uorygl> Data constructors are never associative!  :P
18:21:52 <jmcarthur> > runEndo (foldMap Endo [succ, (*2), (/3)]) 9
18:21:53 <lambdabot>   Not in scope: `runEndo'Not in scope: `foldMap'
18:22:06 <jmcarthur> > appEndo (Data.Foldable.foldMap Endo [succ, (*2), (/3)]) 9
18:22:07 <lambdabot>   7.0
18:22:11 <jmcarthur> there we go
18:22:42 <jmcarthur> > succ . (*2) . (/3) $ 9
18:22:43 <lambdabot>   7.0
18:22:52 <uorygl> I wondered for a moment why 20/3 was rounding up instead of down.
18:23:01 <jmcarthur> ha
18:24:48 * uorygl also wonders for a moment whether all non-constant holomorphic functions are surjective, and finds a counterexample quickly enough.
18:25:22 <danharaj> They are all open maps, though.
18:25:36 <danharaj> Now you've reminded me of the complex analysis final I have tomorrow >_<
18:26:01 <uorygl> A function is an open map if and only if its inverse is continuous, right?
18:26:19 <danharaj> An open map does not need to have an inverse.
18:26:22 <uorygl> Hmm, it seems like if that were true, Wikipedia would mention it.
18:26:27 <uorygl> Oh, you have a point, there.
18:26:54 <danharaj> If a map has a continuous inverse then it is a homeomorphism- those send open sets to open sets.
18:27:38 <uorygl> Is the notion of holomorphic-ness meaningful for, say, functions C^2 -> C^2?
18:28:30 <danharaj> Yes, you can talk about holomorphic functions in several complex variables.
18:28:36 * uorygl nods.
18:28:37 <danharaj> But you lose a lot of nice properties, like the riemann mapping theorem.
18:29:05 <uorygl> I wonder how easily I could come up with a total holomorphic function whose image is a MÃ¶bius strip.
18:31:59 <danharaj> I am not familiar with several variables so I cannot say.
18:32:46 <danharaj> If the open mapping theorem still holds then it cannot be possible, because an embedding of the moebius strip in C^2 is closed.
18:33:26 <uorygl> You mean non-open?
18:33:37 <danharaj> yeah, good catch.
18:34:13 <uorygl> I wonder if the function \x -> (x,0) is holomorphic.
18:34:32 <uorygl> Or its brethren, \(x,y) -> (x,x) and \(x,y) -> (x,0).
18:34:39 <uorygl> > (,0) 3
18:34:40 <lambdabot>   <no location info>: parse error on input `0'
18:36:09 <ddarius> danharaj: Look up Hestenes' "Multivector functions"
18:37:34 <dpratt71> I was pondering the idea of implementing a Haskell editor in VS 2010...
18:37:44 <dpratt71> ...the extensibility model looks nice...
18:38:07 <dpratt71> ...I was researching a particular idea and found some forum posts on the topic...
18:38:36 <dpratt71> ...and realized the question asker was implementing a Haskell editor in VS 2010 :)
18:39:01 <dpratt71> does the handle "Phyx" mean anything to anyone?
18:40:16 <jmcarthur> seen the nick around, probably here
18:40:45 <dpratt71> preflex: @seen Phyx
18:40:45 <preflex>  Phyx was last seen on #haskell 287 days, 23 hours, 48 minutes and 19 seconds ago, saying: * Phyx hates cryptic errors
18:40:55 <danharaj> @seen Waldo
18:40:56 <lambdabot> Unknown command, try @list
18:40:56 <dpratt71> not a good sign :)
18:41:04 <danharaj> :p
18:41:08 <dolio> uorygl: (Haskell) Arrows are generally said to be related to Freyd categories. But I've also heard that relation is not exact.
18:41:12 <tensorpudding> @where Waldo
18:41:12 <lambdabot> I know nothing about waldo.
18:41:39 <uorygl> @Where's Waldo
18:41:39 <lambdabot> Unknown command, try @list
18:41:46 <uorygl> Aww.
18:42:14 <dolio> I'm not sure how notable Freyd categories are, either.
18:42:25 <dolio> Since I've only heard of them in connection to Arrows.
18:48:29 <gwern> > 12.5 * 93
18:48:30 <lambdabot>   1162.5
18:51:40 <ddarius> preflex: seen Phyxs
18:51:40 <preflex>  Sorry, I haven't seen Phyxs
18:51:42 <ddarius> preflex: seen Phyx-
18:51:42 <preflex>  Phyx- was last seen on #haskell 4 days, 3 hours, 9 minutes and 9 seconds ago, saying: hpc: yes, I'm gonna try and solve some problems with it :)
18:52:01 <ddarius> dolio: Freyd categories are used for semantics of impure languages.
18:53:12 <ddarius> @where's
18:53:12 <lambdabot> Maybe you meant: where where+
18:56:28 <ddarius> dolio: http://personal.cis.strath.ac.uk/~raa/arrows.pdf
18:58:15 <dolio> I think this may be where I got the idea that Freyd categories aren't quite the same as arrows.
18:59:07 <danharaj> I can't wait for tomorrow to be over so I can stop cramming for finals and get back to hacking.
19:02:54 <Axman6> finals--
19:09:09 <markus3_> Hi. I have a problem: i have a binary tree of booleans and want to generate the same structured tree with random booleans, but can't make out, what ghc is telling me
19:09:30 <hpc> pastebin it
19:11:24 <markus3_> is it hpaste.org? -- its telling me that it's having an internal server error
19:11:35 <hpc> @where pastebin
19:11:36 <lambdabot> http://rafb.net/paste
19:11:48 <hpc> @where hpaste
19:11:49 <lambdabot> http://hpaste.org/
19:11:53 <hpc> huh
19:12:05 <markus3_> try
19:12:47 <markus3_> this other one also is discontinued :p
19:13:54 <hpc> well, paste the first few lines here then
19:14:52 <markus3_> ok, I got it here: http://kypsiseladu.ee/loogiline/index.php?title=Bt
19:15:08 <markus3_> the function name is simulate
19:15:52 <hpc> well, it compiles fine
19:15:58 <markus3_> the fn "confs n" makes a list of all structures of node-count n
19:16:48 <markus3_> and simulate is supposed to make all the same-structured trees, but with values from random booleans
19:16:53 <fatalerrorx> sigh
19:17:03 <fatalerrorx> I've given up on ocaml
19:18:04 <markus3_> the trees are supposed to represent a network packet multicasted from root to leaves
19:18:37 <markus3_> when some branch loses it, the descendants won't get it, otherwise they might
19:19:21 <markus3_> the code of simulate might be messed up, because I have been changing it a lot lately :)
19:20:08 <markus3_> it's because I'm a noob, and don't actually get the IO monad stuff..
19:21:15 <fatalerrorx> can someone tell me how i can export a function that looks like this in C++ AmiVar compute(int NumArgs, AmiVar *ArgsTable)
19:21:47 <fatalerrorx> i want to write that in Haskell and export it via a dll
19:21:48 <hpc> so, in simulate, you have a function getBoolIf
19:21:51 <pikhq> fatalerrorx: What is the C type definition of AmiVar?
19:22:11 <hpc> which returns a random Boolean if the param is True, else False
19:22:21 <markus3_> yes
19:22:27 <fatalerrorx> AmiVar { int type union { float *, char*} }
19:22:48 <markus3_> the return in the end is wrong -- i just wanted to get it interpreted
19:22:52 <fatalerrorx>     int type;
19:22:53 <fatalerrorx>     union
19:22:53 <fatalerrorx>     {
19:22:53 <fatalerrorx>         float   val;
19:22:53 <fatalerrorx>         float   *array;
19:22:53 <fatalerrorx>         char    *string;
19:22:53 <fatalerrorx> 		void	*disp;
19:22:53 <hpc> yeah
19:22:54 <fatalerrorx>     };
19:23:16 <pikhq> Actually, wait. The *C++* function "AmiVar compute(int NumArgs, AmiVar *ArgsTable)" cannot ever, ever, ever be exported from Haskell.
19:23:28 <fatalerrorx> :(
19:23:37 <fatalerrorx> what about ocaml?
19:23:53 <markus3_> and the line before is also somewhat changed to just get it interpreted
19:23:53 <pikhq> You'll be able to export something that (to C++) looks like this, however: extern "C" AmiVar compute(int NumArgs, AmiVar *ArgsTable)
19:23:58 <Pseudonym> I think the only language which speaks the same name-mangling language as C++ is D.
19:24:01 <pikhq> *If* AmiVar is a type that can be returned.
19:24:11 <pikhq> Pseudonym: Not the same name-mangling language.
19:24:12 <hpc> right now, simulate is type BinTree t -> Bool -> IO Bool
19:24:15 <Pseudonym> Right.
19:24:21 <hpc> i assume you want the last part to be IO Bintree t
19:24:31 <hpc> er, IO BinTree Bool
19:24:49 <markus3_> yep (i think)
19:25:03 <pikhq> (I don't recall, can you return structs in C? And if so, is there a way to do the same from an exported Haskell function?)
19:25:16 <markus3_> the value oh the node should be the argument, that simulate gets as last argument
19:25:18 <Pseudonym> fatalerrorx, there's an assumption in declarative programming that most of the time you want to write your low-level stuff in C or whatever and the rest in the high-level language.
19:25:40 <fatalerrorx> so what can i do?
19:25:53 <Pseudonym> You said "DLL".
19:25:54 <markus3_> but for the absolute root I'd like it to be True
19:25:56 <pikhq> fatalerrorx: No, you cannot write C++ functions that are not extern "C" in *any* language but C++.
19:26:03 <markus3_> and then on random
19:26:06 <Pseudonym> So are you okay with COM?
19:26:11 <Pseudonym> Haskell does COM.
19:26:21 <pikhq> C++ is nearly impossible to interact with. Even for C++.
19:26:24 <Axman6> COM?
19:26:31 <hpc> simulate needs to return a tree with the same shape as the param tree, right?
19:26:46 <pikhq> Axman6: The Common Object Model, for Windows.
19:26:55 <hpc> so what you do is, if the param tree is empty, you return an empty tree
19:26:56 <markus3_> yes
19:27:03 <pikhq> It's a fairly old C object system with bindings in most languages.
19:27:03 <Pseudonym> http://www.haskell.org/hdirect/
19:27:09 <markus3_> yes
19:27:10 <hpc> which you have commented
19:27:20 <markus3_> yes
19:27:20 * Axman6 avoids windows where he can
19:27:22 <pikhq> Random chunks of the Win32 API use it.
19:27:43 <fatalerrorx> pikhq that extern you wrote looks find
19:27:45 <fatalerrorx> fine*
19:27:49 <hpc> when it is a Node, you want to get a random Bool for that node, then generate leaves using simulate again
19:27:52 <Pseudonym> COM is actually a very good idea.  It's just unfortunate that most of the APIs built on top of it are crap.
19:28:14 <markus3_> yes
19:28:31 <Pseudonym> Firefox is, of course, written on top of a homebrew COM.
19:28:42 <Pseudonym> I don't know how recent HaskellDirect is.
19:28:46 <markus3_> but as i thought it, the two arguments //  the node and the bool // for simulate are for the same node
19:28:58 <Pseudonym> There might be something better in hackage.
19:29:13 <markus3_> the formal arg bool is about wether the formal arg node recived the packet or not
19:29:22 <fryguybob> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/com
19:29:35 <ezyang> The automata TMR article is pretty classy.
19:29:51 <markus3_> (it could be about it's parent also, but i have thought about it as i told in the code i pasted..)
19:29:58 <hpc> im confused
19:30:13 <Pseudonym> Anyway, if you really had to call Haskell from C++ under Windows, that's what I'd do.
19:30:28 <Pseudonym> But depending on what it is, I'd be more tempted to go client-server.
19:30:29 <pikhq> Pseudonym: Yeah, the COM itself is actually surprisingly not-awful.
19:30:41 <markus3_> when i call simulate node True, then it means, that that node in the args recived the packet
19:30:52 <Pseudonym> pikhq: Shame about ActiveX, right?
19:30:56 <markus3_> maybe i'm talking too much
19:31:04 <pikhq> Pseudonym: Right.
19:31:09 <hpc> nah, it helps
19:31:27 * Pseudonym still has nightmares about ActiveX dialog widgets
19:32:07 <markus3_> maybe it'd be better, if the formal argument boolean would be about the parent of the node
19:32:14 * Pseudonym checks to see if Haskell does CORBA; no reason why it shouldn't
19:32:45 <markus3_> then i wouldnt have to generate two bools per simulate call, but just one for that node, which was the argument
19:35:21 <hpc> i am still a bit confused
19:35:33 <hpc> what should the function return for what argument values?
19:35:59 <markus3_> it should return the same structured tree
19:36:35 <hpc> filled with random Bools?
19:36:43 <markus3_> but the node values should be random bools, when the nodes parent was true, otherwise False
19:36:45 <markus3_> yes
19:36:55 <hpc> oh, i see where this is going
19:37:04 <markus3_> yep
19:37:07 <hpc> cool
19:37:10 <markus3_> its like a cascade
19:37:34 <markus3_> simulate (Node v l r) x =    let boool = randomRIO (False, True)    in return (Node (boool) (simulate l boool) (simulate r boool))
19:37:35 <hpc> so first we want a type signature, which you should always do first
19:37:45 <markus3_> look at that
19:37:51 <markus3_> maybe that is better
19:38:00 <hpc> simulate :: BinTree t -> Bool -> IO (BinTree Bool)
19:38:17 <markus3_> ok
19:38:23 <hpc> actually, yeah, you got it
19:38:52 <hpc> more or less
19:39:01 <markus3_> but it still dosn
19:39:05 <markus3_> t work
19:40:27 <hpc> simulate (Node v l r) x =
19:40:29 <hpc>    let getBoolIf u = (u ? (randomRIO (False, True), return u)) >>= return
19:40:30 <hpc>    in do
19:40:32 <hpc>       bool <- getBoolIf x
19:40:34 <hpc>       return BinTree bool (simulate l bool) (simulate r bool)
19:40:35 <hpc> simulate None _ = return None
19:41:02 <markus3_> i'll try
19:41:21 <hpc> so you have getBoolIf, which handles the behavior with regards to x
19:41:35 <hpc> then the recursive call which fills the whole tree, and the stop condition
19:42:22 <hpc> except i used BinTree instead of Node
19:44:32 <Axman6> hpc: >>= return?
19:44:33 <markus3_> hmm, it still has some expecting a inferred b error
19:44:42 <hpc> yeah, just fixed that
19:44:50 <hpc> Axman6: was in his code
19:45:01 <Axman6> ah
19:45:28 <hpc> http://dl.dropbox.com/u/37707/thing.hs
19:45:50 <hpc> compiles, and probably runs right
19:46:43 <hpc> also, you have some style issues with your code that should be pointed out before they become habit
19:47:02 <markus3_> :D
19:47:06 <hpc> primarily lack of type signatures
19:47:12 <markus3_> thanks
19:47:16 <markus3_> yep
19:47:51 <hpc> also, as Axman6 just pointed out, "x >>= return" always is just "x"
19:48:08 <Axman6> it's one of the monad laws i believe
19:48:12 <aavogt> well leaving type signatures is only going to complicate debugging
19:48:20 <markus3_> ok
19:48:42 <hpc> i got into the habit of always leading with type signatures, and my code got way easier to write and maintain
19:48:43 <markus3_> but why cant i put those simulate l bool's into the parens
19:48:50 <aavogt> if somebody else wants to see the types, they can ask an interpreter
19:48:58 <Axman6> markus3_: what's the type of simulate?
19:49:02 <hpc> simulate l bool returns an IO (BinTree Bool)
19:49:13 <hpc> so you have to unwrap it from the IO
19:49:24 <hpc> which is what <- does
19:49:49 <hpc> this is where type signatures come in handy, btw
19:50:10 <markus3_> does anything else unwrap it too, or this is the only way
19:50:24 <aavogt> this getBoolIf looks suspect
19:50:31 <Axman6> well, all other ways are different ways of writing the same thing
19:50:33 <aavogt> sort of like    if True then True else False
19:50:40 <hpc> >>= is unrwap, then apply
19:50:50 <Axman6> aavogt: it's not quite though
19:50:51 <hpc> return x >>= f
19:50:58 <hpc> will apply f to x, then wrap it back up
19:51:31 <hpc> you can learn all about it in tutorials
19:51:39 <hpc> does lyah have monads up yet?
19:51:47 <aavogt> I believe so
19:51:56 <hpc> @where lyah
19:51:57 <lambdabot> http://www.learnyouahaskell.com/
19:52:06 <hpc> and if not there, try A Gentle Introduction to Haskell
19:52:13 <hpc> or the wikibook
19:52:17 <hpc> @where wikibook
19:52:17 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:52:21 <markus3_> ok :)
19:52:54 <hpc> crap, stayed up later than i wanted to :P
19:53:08 <markus3_> i'll try to understand better :D
19:53:14 <hpc> lol, no problem
19:53:16 <Axman6> markus3_: your leavess function has some redundant cases
19:53:52 <markus3_> like how?
19:54:18 <Axman6> you only need: leavess (Node a None None) ac = a : ac and leavess (Node a l r) ac = leavess l (leavess r ac)
19:54:53 <Axman6> wait, not quite, you'd then need leavess None ac = ac
19:55:42 <markus3_> yep
19:56:09 <aavogt>  -XDeriveFoldable
19:56:12 <Axman6> this happens to be almost exactly a tute i taught this week
19:56:28 <aavogt> then use  Data.Foldable.toList  instead of  leaves...
19:56:33 <markus3_> yep, its better that way, to have it shorter
19:56:39 <Axman6> leaves is different i believe
19:56:40 <aavogt> hmm, though that will include the nodes
19:56:46 <Axman6> yeah
19:57:48 <Axman6> markus3_: also, your function also doesn't work if you give it (Node 1 None None)
19:57:52 <aavogt> ok, so use syb or some other generic programming to do the traversal of removing those nodes
19:58:09 <aavogt> :P
19:58:58 <Axman6> markus3_: http://pastebin.com/YRmrNNY5
19:59:36 <markus3_> ok
20:00:23 <markus3_> i'll have to think about these things..
20:04:54 <markus3_> thankyou again and good night :)
20:06:16 * hackagebot meldable-heap 2.0 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-2.0 (JimApple)
20:07:15 <jbapple> now supporting both lazy and strict variants
20:26:14 <scoles> I'm pretty  new to haskell and was wondering why I am getting all these errors when I try to compile my program (it runs in ghci fine).
20:26:17 <scoles> http://gist.github.com/399458
20:27:20 <danharaj> I think somebody accidentally the whole linker.
20:27:48 <danharaj> try compiling with the --make flag
20:27:53 <djahandarie> scoles, try ghc --make ...
20:27:53 <jbapple> have you tried with -c or --make?
20:29:28 <scoles> --make doesn't give me an executable.  Is there another option I should be using for that?
20:29:39 <Axman6> it should give you an executable
20:29:43 <Axman6> ghc --make File.hs
20:29:48 <Axman6> should be all you need
20:31:16 <scoles> I get .hi and .o files
20:31:21 <ezyang> Use cabal!
20:31:40 <ezyang> scoles: But more practically, you should get "File" w/o any ending
20:31:42 <dino-> scoles: Did you get a file called a.out?
20:32:00 <Cale> scoles: Is your module called Main?
20:32:12 <scoles> Oh, no
20:33:44 <Cale> The main module of your program that the executable gets built from should be called Main, which is the default, if you leave off the module declaration altogether
20:34:16 <scoles> Ah, ok now that I change the module name to Main I get something
20:34:46 <BMeph> scoles: Herpes? ;)
20:35:12 <dino-> Cale: I forget the exact specifics, but I found it easier to not have the module decl at all for the file where main lives. I think it complains if it's not named Main.hs
20:35:17 <dino-> So you can then name it anything you want.
20:43:28 * hackagebot SDL 0.6.0 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.0 (DavidHimmelstrup)
20:44:28 * hackagebot SDL-gfx 0.6.0 - Binding to libSDL_gfx  http://hackage.haskell.org/package/SDL-gfx-0.6.0 (DavidHimmelstrup)
20:45:30 * hackagebot SDL-image 0.6.0 - Binding to libSDL_image  http://hackage.haskell.org/package/SDL-image-0.6.0 (DavidHimmelstrup)
20:45:32 * hackagebot SDL-mixer 0.6.0 - Binding to libSDL_mixer  http://hackage.haskell.org/package/SDL-mixer-0.6.0 (DavidHimmelstrup)
20:45:34 * hackagebot SDL-ttf 0.6.0 - Binding to libSDL_ttf  http://hackage.haskell.org/package/SDL-ttf-0.6.0 (DavidHimmelstrup)
20:50:31 * hackagebot SDL 0.6.1 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.1 (DavidHimmelstrup)
20:54:17 <brooksbp> Can someone help me find a definition of: higher order language?
20:54:29 <brooksbp> Is it just a language where functions are higher order?
20:55:02 <kmc> brooksbp, functions and similar things, like Haskell's IO actions
20:55:35 <Kaidelong> shouldn't there be a more specific way to say it?
20:56:05 <Kaidelong> perhaps a language where you work with computations as values or a language which doesn't have statements?
20:56:09 <brooksbp> kmc: So what is the definition of a higher-order language?
20:56:12 <kmc> Haskell has statements
20:56:30 <kmc> they're just part of the "do" sugar
20:56:43 <Kaidelong> kmc: those live inside computations though
20:56:54 <kmc> "has statements" is a superficial syntactic consideration
20:57:17 <kmc> i don't think "higher order language" has a perfectly precise definition
20:57:21 <Kaidelong> well isn't there a fundamental difference between equational and imperative languages?
20:57:30 <Kaidelong> in theory anyway
20:57:40 <kmc> no, because you can have equations where the RHS is a sequence of imperative actions
20:57:42 <kmc> such as Haskell
20:57:57 <kmc> which is a declarative equational functional imperative language
20:58:29 <iaefai> Should >     print "This is a test"    output "This is a test"   with the double quotes? This is with runhaskell
20:58:47 <kmc> yes
20:58:53 <kmc> print = putStrLn . show
20:58:56 <kmc> > show "foo bar"
20:58:57 <lambdabot>   "\"foo bar\""
20:59:06 <kmc> show turns a value into a Haskell literal for that value
20:59:09 <iaefai> > show 'foo'
20:59:10 <lambdabot>   <no location info>:
20:59:10 <lambdabot>      lexical error in string/character literal at chara...
20:59:10 <kmc> a Haskell literal string has quotes
20:59:15 <Kaidelong> > putStrLn "This is a test"
20:59:16 <lambdabot>   <IO ()>
20:59:17 <iaefai> ok, what best way to fix
20:59:18 <Kaidelong> err
20:59:27 <kmc> lambdabot can evaluate but cannot execute IO actions
20:59:38 <Kaidelong> ah
20:59:47 <Kaidelong> I was about to put in a do block but I guess that doesn't matter then
21:00:03 <kmc> if it's an IO do block, no
21:01:55 <Kaidelong> > let xs x = sx : xs sx where sx = show x in map . length . xs $ ""
21:01:56 <lambdabot>   Couldn't match expected type `a -> b'
21:01:56 <lambdabot>         against inferred type `GHC.Ty...
21:02:03 <Kaidelong> err
21:02:09 <Kaidelong> > let xs x = sx : xs sx where sx = show x in map length . xs $ ""
21:02:14 <lambdabot>   mueval-core: Time limit exceeded
21:02:53 <Kaidelong> > let xs x = sx : xs sx where sx = show x in head . map length . xs $ ""
21:02:54 <Cale> Kaidelong: do-blocks just glue IO actions together into larger IO actions
21:02:56 <lambdabot>   2
21:03:04 <Kaidelong> > let xs x = sx : xs sx where sx = show x in take 10 . map length . xs $ ""
21:03:05 <lambdabot>   [2,6,14,30,62,126,254,510,1022,2046]
21:03:07 <Cale> Kaidelong: If you only have one action, the "do" is superfluous.
21:03:27 <Kaidelong> > let xs x = sx : xs sx where sx = show x in take 4 . xs $ "" -- last one, sorry
21:03:28 <lambdabot>   ["\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\...
21:03:39 <Jafet> > fix show
21:03:40 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:04:05 <kmc> do { m }  ===  m
21:04:18 <kmc> do { x; y; ... }  ===  x >> do { y; ... }
21:04:22 <Kaidelong> Cale: yes you're right
21:04:25 <Kaidelong> IO ()
21:04:37 <kmc> do { v <- x; y; ... }  ==  x >>= (\v -> do { y; ... })
21:04:37 <Kaidelong> executes the IO action, so what lambdabot was telling me was
21:04:41 <Veinor> print > fix error
21:04:43 <Kaidelong> "that would be an IO action"
21:04:45 <Veinor> whoops
21:04:47 <Veinor> > fix error
21:04:48 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:05:00 <kmc> lambdabot is perfectly willing to compute the actual IO action and leave it in memory
21:05:07 <kmc> it just won't execute the steps so described
21:05:30 <Kaidelong> so you can't do something like make lambdabot print that it wants to quit
21:05:42 <kmc> > text "kill me"
21:05:44 <lambdabot>   kill me
21:06:00 <Kaidelong> oh wait no that would be a client side thing
21:06:07 <Kaidelong> so I suppose it doesn't really matter
21:06:31 <Cale> Well, executing IO actions would let you do random stuff on the machine lambdabot is running on, as lambdabot's user
21:06:33 <kmc> @. elite nixon
21:06:34 <lambdabot> i D0N'+ WaN7 tO 5Ee THis COunTrY t0 GO tH4t w4Y. yoU xn0\/\/ wh4T happeNED To ThE Gr33K5. hoMO5eXu4lI7Y DE$7R0yED tHE/\/\. 5ur3, ARI$T0t13 wa$ 4 HO/\/\0, \/\/E a1| kNo\/\/ tH4+, zO w45 SoCR4+e$.
21:06:44 <Jafet> > "What IO?"
21:06:45 <lambdabot>   "What IO?"
21:07:09 <Kaidelong> > show (putStrLn "")
21:07:10 <lambdabot>   "<IO ()>"
21:07:12 <Cale> So all that lambdabot does is evaluate expressions.
21:07:21 <Kaidelong> > putStrLn ""
21:07:22 <lambdabot>   <IO ()>
21:07:38 <Cale> There's a Show instance for IO actions which you see there
21:07:41 <Cale> > getLine
21:07:42 <lambdabot>   <IO [Char]>
21:08:13 <kmc> > typeOf getChar
21:08:14 <lambdabot>   IO Char
21:08:45 <kmc> instance (Typeable a) => Show (IO a) where { show x = "<" ++ show (typeOf x) ++ ">" }
21:08:48 <kmc> something like that
21:09:18 <iaefai> GHC is very nice, it ignores #!/usr/bin/env runhaskell at the top of a file, most useful
21:11:25 <Kaidelong> wouldn't # be more idiomatic than !!?
21:11:33 <Kaidelong> things # 5
21:11:36 <Cale> hm?
21:11:37 <Cale> oh
21:11:39 * hackagebot SDL 0.6.2 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.2 (DavidHimmelstrup)
21:11:40 <kmc> how is that more idiomatic?
21:11:46 <Cale> Well, you don't want to use !! anyway
21:11:47 <kmc> what idiom do you appeal to
21:11:54 <Kaidelong> # as "number"
21:11:57 <Kaidelong> err
21:11:58 <kmc> meh
21:12:01 <kmc> intuitive maybe
21:12:13 <iaefai> idiomatic?
21:12:17 <Kaidelong> yeah, term issues
21:12:18 <Kaidelong> sorry
21:12:24 <Kaidelong> I was thinking memorizable
21:12:38 <Kaidelong> not that I have trouble memorizing !!, it's just a thought that occured to me
21:13:14 <Jafet> !! is good precisely becuase it is harder to type than #
21:13:24 <iaefai> I should ask, would #!/usr/bin/env runhaskell be a good multiplatform method for a script meant to be run with runhaskell? I know it works on mac (which is where my editor is based), but want to know if linux/bsd/etc would like it too.
21:13:26 <Cale> Yeah, # would be cuter, but I like to think that !! is appropriate because it's a "loud" warning that something is wrong with your code :)
21:13:30 <Jafet> Arrays use !, which is again easier to type.
21:14:05 <Cale> iaefai: It should work, though your programs will run slower than if you just compiled them.
21:14:12 <iaefai> Cale, user choice.
21:14:12 <Kaidelong> Cale: are haskell arrays lazy if you instantiate them from a lazy list?
21:14:26 <Cale> Kaidelong: yes, in a sense
21:14:31 <iaefai> Right now I am only supporting runhaskell from my editor, for obvious reasons I need cabal support here
21:14:43 * hackagebot SDL-image 0.6.1 - Binding to libSDL_image  http://hackage.haskell.org/package/SDL-image-0.6.1 (DavidHimmelstrup)
21:14:48 <Jafet> There are different degrees of laziness -- the array container itself probably isn't
21:15:10 <Kaidelong> hmm, well I guess that makes sense, you can't have an infinite array
21:15:23 <Kaidelong> I was thinking about examples where !! is used for memoization
21:15:24 <Cale> Kaidelong: They're lazy in the elements, strict in the structure. If you evaluate just one element of the Array, the memory for the whole thing is allocated, and the elements of the array initially contain expressions for computing their values.
21:15:25 <iaefai> I heard haskell was so lazy it was fired.
21:15:54 <kmc> (!!) isn't always bad.  «iterate f !! n» is a fine idiom
21:15:58 <kmc> as good as applying f n times by any other means
21:16:13 <Kaidelong> true
21:16:31 <kmc> i mean «iterate f x !! n»
21:16:37 <Cale> It's somewhat fine, though still can be mildly dangerous like that
21:16:49 * hackagebot SDL-ttf 0.6.1 - Binding to libSDL_ttf  http://hackage.haskell.org/package/SDL-ttf-0.6.1 (DavidHimmelstrup)
21:16:50 <Cale> If f is strict, and n is large, you might get a stack overflow
21:16:53 <Kaidelong> I suppose if you know in advance how many values you will want to memoize you could use an array
21:17:03 <Kaidelong> but then you might as well calculate it all ahead of time strictly
21:17:03 <kmc> really Cale?
21:17:20 <kmc> shouldn't iterate productively generate cons cells that will be thrown out by (!!)
21:18:10 <Jafet> In haskell "array" generally emphasizes the storage ie. compact and random access
21:18:25 <Cale> kmc: yep
21:18:54 <Cale> kmc: and it'll get to the 1000000'th element and evaluate to something like f (f (... (f x)...))
21:19:04 <kmc> oh
21:19:08 <kmc> is there iterate' then?
21:19:10 <Cale> kmc: and then since f is strict, it'll start putting cases on the stack
21:19:17 <Cale> Unfortunately not.
21:19:29 <kmc> but it could be defined
21:19:32 <Cale> yeah
21:19:52 * hackagebot SDL-mixer 0.6.1 - Binding to libSDL_mixer  http://hackage.haskell.org/package/SDL-mixer-0.6.1 (DavidHimmelstrup)
21:20:09 <Kaidelong> that's an unfold, isn't it?
21:20:29 <Kaidelong> so perhaps...
21:20:57 <Jafet> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (\x -> if mod x 2 == 0 then div x 2 else 3*x + 1) 100
21:20:58 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,...
21:21:46 <Kaidelong> iterate' f acc = nxt `pseq` iterate' f nxt where nxt = f acc
21:21:47 <Kaidelong> ?
21:22:00 <Cale> > iterate (+1) 0 !! 1000000
21:22:00 <Kaidelong> oh
21:22:01 <lambdabot>   *Exception: stack overflow
21:22:12 <Cale> let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (+1) 0 !! 1000000
21:22:16 <Cale> > let iterate' f x = x `seq` x : iterate' f (f x) in iterate' (+1) 0 !! 1000000
21:22:17 <Kaidelong> Jafet's looks nicer
21:22:18 <lambdabot>   1000000
21:22:39 * ddarius thinks there should be head strict lists in the standard libraries and those should be the preferred list type.
21:23:19 <ddarius> You can even recover normal lazy lists from them via data Lazy a = Lazy a; type LazyList a = HeadStrictList (Lazy a)
21:23:44 <Jafet> I met Eva Lu Ator once, she was totally ac/dc
21:23:56 <Kaidelong> ddarius: F# does this
21:24:14 <ddarius> Kaidelong: F# is eager.
21:24:18 <ddarius> Clean does this.
21:24:21 <Kaidelong> ddarius: but it has lazy lists
21:24:31 <Kaidelong> but they're not the default
21:24:34 <Jafet> Head strict lists are not strict lists.
21:24:47 <Kaidelong> oh!
21:25:33 <Kaidelong> head strict list strictly evaluates the head, then reduces that expression in the tail if it is there too?
21:25:48 <Kaidelong> but doesn't evaluate the tail further than that?
21:25:54 <Jafet> Data types don't evaluate anything
21:26:10 <ddarius> data HeadStrictList a = Nil | Cons !a (HeadStrictList a)
21:34:27 <Kaidelong> so a head strict list is strict in its head but not in its tail?
21:35:00 <Kaidelong> the point being to prevent stuff like fold from building up huge closures on the head of a cons cell?
21:35:35 <Kaidelong> without having to be explicit about it
21:36:54 <Kaidelong> which would stop that "iterate f i !! n" example from causing a stack overflow
21:38:55 <shapr> cabal upgrade lists packages that could be upgraded, and says it's not recommended to upgrade core packages. But it doesn't say which packages are core!
21:40:06 <alex404> So here's an interesting problem: I'm using the FFI to call an IO C function. When I run it in the interpreter, it always works fine. But when I compile it and run it as an executable, it will after several runs break the kernel module on which the code depends and require me to reboot the computer. So can anyone tell me how the interpreter might be running my FFI function differently than as a compiled executable?
21:40:36 <ezyang> It probably has been optimized in some way.
21:40:47 <ezyang> You can ask GHC to spit out the C code it generates
21:40:49 <kmc> woahly shit
21:40:51 <alex404> It's a shitty optimization.
21:41:07 <alex404> Hmm... how would I do that, and what might I look for?
21:41:19 <kmc> maybe you can use gdb to put a breakpoint on the function
21:41:26 <kmc> also, if it's talking to a kernel module, is it using system calls?
21:41:32 <kmc> if so, strace might give you useful information
21:41:45 <alex404> Interesting, I haven't used any of these programs.
21:41:46 <ezyang> -ddump-flatC
21:42:02 <alex404> Mind telling me what gdp and strace do?
21:42:20 <kmc> gdb is the gnu debugger
21:42:22 <ezyang> However, I suspect, though, that your code is violating some invariant for the C function wants.
21:42:35 <kmc> typical debugger with breakpoints, single-step, etc.
21:42:38 <ezyang> And it just happens to not tickle the case when you're running it in an interpreter.
21:42:39 <alex404> Right
21:42:43 <kmc> strace runs a program and prints a line of output for every system call it makes
21:42:48 <kmc> (or those in a set you choose)
21:42:48 <alex404> Ah
21:42:50 <alex404> That's handy
21:43:05 <kmc> they're both useful tools if you're doing any low-level programming
21:43:26 <alex404> kmc: Thanks for the tips.
21:43:36 <alex404> ezyang: What sort of invariant?
21:43:50 <Kaidelong> ddarius: I think I understand it now that I've discovered bang patterns, thanks
21:43:52 <ezyang> alex404: I dunno, it's your C function. :^)
21:44:20 <alex404> ;P I don't know exactly what you mean though by invariant. Like what's an example that you've come across?
21:44:55 <kmc> like the function spec says "argument x should never be 7"
21:44:59 <kmc> and you sometimes call it with 7
21:45:05 <alex404> Right.
21:45:13 <kmc> but it works in the interpreter because C is an unsafe language, and its error behavior is unpredictable
21:45:22 <kmc> and the interpreter is a different environment generally
21:45:28 <copumpkin> can we have more details?
21:45:28 <kmc> so wrong things might work there but not otherwise
21:45:29 <alex404> Indeed.
21:45:47 <kmc> alex404, one simple check would be to make the function print out its args
21:45:56 <kmc> and do that on both the haskell and C side
21:46:18 <alex404> I always call the FFIed function with the same arguments in my testing
21:46:22 <alex404> interpreted and compiled
21:46:28 <ezyang> Also, you kernel module sounds buggy...
21:46:31 <ezyang> *your
21:46:57 <alex404> It's been totally well behaved outside of this compiled in haskell context.
21:47:35 <copumpkin> if it ever crashes, it's buggy
21:47:48 <ezyang> User code should not cause need for reboot.
21:47:57 <ezyang> uh, some kernel modules are notoriously poor at this
21:48:05 <alex404> btw: The problem is that I underrun an output streaming buffer, which breaks the module.
21:48:34 <alex404> I think the developers know about this. In the docs they say: Do not underrun the buffers.
21:48:39 <kmc> yeah
21:48:47 <kmc> but that means this kernel module is a special purpose sort of thing
21:49:09 <alex404> It's an open source API called comedi
21:49:17 <kmc> ok
21:49:21 <alex404> It controls Data Acquisition Cards
21:49:31 <alex404> Which are voltage generators and readers
21:49:32 <kmc> and it can crash the machine if a user-space program has a bug?
21:49:34 <alex404> basically
21:49:36 <kmc> awkward
21:49:45 <kmc> kernel code isn't supposed to have that property
21:49:46 <alex404> It doesn't crash the machine
21:49:54 <kmc> but people do so anyway, for special purposes
21:50:07 <alex404> After several runs
21:50:22 <ezyang> You should do the call instrumenting
21:50:24 <alex404> I'll get a "broken pipe" error, and the program will not run correctly again until a reboot.
21:50:27 <ezyang> I think that'll be really informative.
21:50:34 <alex404> call instrumenting?
21:50:44 <alex404> Let print out args everywhere?
21:50:46 <ezyang> adding prints before you call the kernel moudle.
21:50:49 <ezyang> yep
21:50:55 <ezyang> At least, the traces will differ
21:50:59 <ezyang> Also, try runghc
21:51:01 <scotty> If I have a Data.Map such as Map a [b], is there an easy way to get the a associated with the longest [b]?  I wrote a function myself, but I'm wondering if there's a function in the library that I've missed.
21:51:11 <kmc> alex404, basically your original question was "what difference between the compiled and interpreted mode could matter?".  and the answer is "if the C code is buggy, absolutely any difference"
21:51:11 <alex404> Oh. runghc is something I didn't think of.
21:51:18 <alex404> Right.
21:51:22 <kmc> runghc should be the same as ghci
21:52:15 <kmc> scotty, Map maps keys to values, and can do various searches by key.  so that sounds like you want a map the other way
21:52:21 <kmc> in which case, you can get the minimum or maximum key
21:52:28 <alex404> Well thanks for all the tips. I've got enough to chew on for now.
21:52:33 <kmc> and thus you can define a data type which caches the length of a list and says that longer lists are always greater
21:52:41 <ezyang> kmc: Yeah. The idea is to only run main
21:55:34 <scotty> So, what I have initially is a list of my own Triangle type.  From this, I create a Map from perimeters to lists of triangles.  I build the lists up using insertWith.  Does it make any sense to have a Map from lists of triangles to perimeters.  I'm not sure how I would build up the keys.  Wouldn't I have to delete old keys any time the lists got bigger?
21:56:16 <scotty> Ah, looks like there's an update key sort of function.
21:56:28 <scotty> I guess I could do that.
22:01:18 <alex404> ezyang: Do you know if runghc deals with the FFI differently/at all? It complains that it can't find my c function, though I give it the exact same arguments as ghci.
22:01:40 <ezyang> not offhand
22:01:56 <ezyang> copypasta might be useful
22:02:28 <alex404> copypasta?
22:02:42 <ezyang> pastebin your command line arguments and the error messages.
22:02:56 <ezyang> I probably can't help, but someone else might recognize the problem
22:03:51 <alex404> ezyang: Thanks. I should raelly call it a night anyway...
22:04:07 <alex404> ezyang: I'll try running through strace for a while, and come back tomorrow otherwise.
22:05:39 <dmwit> scotty: Check out Data.List.maximumBy and Data.Map.assocs if O(n) is fast enough (in n the number of perimeters). If you will be extracting the max multiple times, you might want to have a second processing step that puts everything in a priority queue prioritized by list length.
22:14:30 <Makoryu> @. pl undo \f g -> do { x <- f; g; return x; }
22:14:30 <lambdabot> (. ((. return) . (>>))) . (>>=)
22:14:48 <Makoryu> There's not a more elegant way to express that, is there?
22:16:23 <copumpkin> hmm
22:16:44 <kmc> :t (<*)
22:16:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
22:16:56 <kmc> :t \f g -> do { x <- f; g; return x; }
22:16:56 <copumpkin> :t \f g -> do { x <- f; g; return x; }
22:16:57 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
22:16:57 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
22:17:07 <copumpkin> the order works out for <*
22:17:18 <Makoryu> Ahhh
22:17:20 <kmc> @src (<*)
22:17:20 <lambdabot> (<*) = liftA2 const
22:17:30 <kmc> cool
22:17:32 <Makoryu> :t liftM2 const
22:17:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
22:17:47 <kmc> every monad Should Be applicative, anyway
22:17:51 <Makoryu> Yeah
22:18:07 <Makoryu> @src liftA2
22:18:07 <lambdabot> liftA2 f a b = f <$> a <*> b
22:23:30 <dolio> @yow!
22:23:31 <lambdabot> Couldn't find fortune file
22:23:35 <copumpkin> aw
22:23:48 <copumpkin> preflex: seen mmorrow
22:23:48 <preflex>  mmorrow was last seen on #ghc 115 days, 2 hours, 26 minutes and 1 second ago, saying: * mmorrow is rtfm'ing
22:24:05 <copumpkin> that manual ate him :(
22:25:00 <dolio> Yeah.
22:26:58 <dolio> Well, after several days of work, pts finally uses a PHOAS term representation.
22:27:14 <dolio> And doesn't have weird alpha conversion/variable capture bugs, hopefully.
22:27:24 <copumpkin> ooh
22:28:30 <dolio> So I no longer have to manually choose unique names for the translation of Hurkens' paradox I wrote for System U.
22:28:52 <dolio> Or, the pts encoding of System U. He wrote it in System U originally.
22:29:37 <dolio> Of course, I got it from hurkens.agda, because that's way easier to read.
22:47:51 <dmwit> > maxBound :: Double
22:47:52 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
22:47:52 <lambdabot>    arising from a use o...
22:47:59 <dmwit> hrm
22:48:04 <dmwit> > 2**128 :: Double
22:48:05 <lambdabot>   3.402823669209385e38
22:48:14 <dmwit> 2^128
22:48:17 <dmwit> > 2^128
22:48:18 <lambdabot>   340282366920938463463374607431768211456
22:48:26 <m_88> hi
22:50:31 <dmwit> howdy, m_88
22:53:07 <Jafet> http://codepad.org/3WhGrtdw random code
22:53:32 <dmwit> Why, that code is not random at all!
22:53:54 <dolio> > 2 : 3 : unfoldr (\(k,i,j) -> Just (k, (k+i,j,i))) (5,2,4)
22:53:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,...
22:53:56 <Jafet> I need to get rid of the bindings to ones and phis, those are what seems to be causing the stack overflow
22:54:23 <dmwit> dolio: Neat! But I see a few impostors... =)
22:55:13 <dolio> Yeah, it's just a more efficient starting list. I hadn't seen that before, though.
22:55:33 <dmwit> Does it correspond to one of the well known polynomials...?
22:56:11 <Jafet> It just... filters out multiples of 2 and 3
22:56:13 <dmwit> No, I see it doesn't.
22:56:19 <dmwit> right
22:57:02 <dmwit> > concat . transpose $ [[5, 11 ..], [7, 13 ..]]
22:57:03 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:00:50 <dmwit> > zip [5, 11 ..] [7, 13 ..] >>= \(x, y) -> [x, y]
23:00:51 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:03:26 <Jafet> > filter (\n->filter((==0).(mod n))[2..n]==[n]) [1..]
23:03:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:04:33 <dmwit> > zip [5, 11 ..] [7, 13 ..] >>= uncurry (((:[]) .) . (:))
23:04:34 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Enum.Enum [t])
23:04:34 <lambdabot>    arising from a use...
23:04:39 <copumpkin> eugh!
23:04:44 <dmwit> :t uncurry (((:[]) .) . (:))
23:04:45 <lambdabot> forall a. (a, [a]) -> [[a]]
23:05:01 <dmwit> :t ((:[]) .) . (:)
23:05:01 <lambdabot> forall a. a -> [a] -> [[a]]
23:05:13 <dmwit> ?pl \x y -> [x, y]
23:05:14 <lambdabot> (. return) . (:)
23:05:25 <dmwit> Oops, I dropped a flip.
23:05:37 <dmwit> > zip [5, 11 ..] [7, 13 ..] >>= uncurry ((. (:[])) . (:))
23:05:38 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:05:43 <dmwit> niiiiiiice
23:05:51 <copumpkin> zomg
23:06:31 <c_wraith> 55 isn't veryy prime
23:06:45 <dmwit> 25, neither, for that matter ;-)
23:08:35 <kmc> :t uncurry ((. (:[])) . (:))
23:08:36 <lambdabot> forall a. (a, a) -> [a]
23:08:45 <kmc> madness
23:08:49 <copumpkin> indeedles
23:09:18 <Olathe> @unpl ((. (:[])) . (:))
23:09:18 <lambdabot> (\ e h -> ((:)) e (h : []))
23:09:31 <dmwit> Thanks a lot, ?unpl.
23:09:35 <dmwit> That's very helpful.
23:09:57 <kmc> Thanks, unpl.
23:10:00 <kmc> Thunpl.
23:10:10 <dmwit> Just look around you!
23:10:23 <Olathe> @pl \e h -> [e, h]
23:10:23 <lambdabot> (. return) . (:)
23:10:26 <kmc> Have you worked out what we're looking for?
23:10:27 <kmc> It's Haskell!
23:11:13 <dmwit> Hm, are you trying to imply that none of what we've been doing here looks like Haskell? =P
23:12:06 <dmwit> Their usual starting gag is to show something completely unrelated, right...?
23:12:15 <Olathe> > let f x = x:(x + 2):f (x + 6) in f 5
23:12:16 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:12:28 <kmc> yeah dmwit
23:14:26 <dmwit> > fix (\xs -> 5 : 7 : map (+6) xs)
23:14:27 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:14:39 <dmwit> hm
23:14:53 <dmwit> > fix ((5:) . (7:) . map (+6))
23:14:54 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:15:11 <dmwit> 5, 6, and 7, the magical constants
23:15:35 <Olathe> @hoogle [a] -> [a]
23:15:36 <lambdabot> Prelude cycle :: [a] -> [a]
23:15:36 <lambdabot> Prelude init :: [a] -> [a]
23:15:36 <lambdabot> Prelude reverse :: [a] -> [a]
23:16:02 <dmwit> > fix (([5,7]++) . map (+6))
23:16:04 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:16:22 <Olathe> > cycle [(+2), (+4)]
23:16:23 <lambdabot>   [{-3->-1;-2->0;-1->1;0->2;1->3;2->4;3->5},{-3->1;-2->2;-1->3;0->4;1->5;2->6...
23:17:21 <dmwit> > scanl (.) id (cycle [(+2), (+4)]) 5 -- oh, Olathe, that is hot if it works
23:17:22 <lambdabot>   Couldn't match expected type `t1 -> t'
23:17:22 <lambdabot>         against inferred type `[a ->...
23:17:39 <dmwit> :t scanl
23:17:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:17:45 <dmwit> :t scanl (.)
23:17:46 <lambdabot> forall a b. (a -> b) -> [a -> a] -> [a -> b]
23:18:15 <dmwit> :t scanl (.) id (cycle [(+2), (+4)])
23:18:16 <lambdabot> forall a. (Num a) => [a -> a]
23:18:24 <dmwit> oh, right
23:18:42 <dmwit> > sequence (scanl (.) id (cycle [(+2), (+4)])) 5
23:18:43 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:18:51 <Olathe> @type sequence
23:18:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:22:12 <Jafet> > scanl (flip ($)) 5 (cycle [(+2), (+4)])
23:22:13 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:23:46 <Olathe> @type scanl
23:23:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:24:19 <Olathe> Ahh :)
23:27:20 <Jafet> > map (\n -> n^2 + 40*n + 41) [0..]
23:27:21 <lambdabot>   [41,82,125,170,217,266,317,370,425,482,541,602,665,730,797,866,937,1010,108...
23:27:40 <dmwit> > scanl (+) 5 (cycle [2,4])
23:27:41 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
23:28:33 <Jafet> I think we are nearing par
23:29:39 <Jafet> Someone should really organize a haskell golf
23:31:02 <dmwit> You know what freaks me out every once in a while still?
23:31:31 <dmwit> The Prelude, a library filled mostly with easy-to-implement functions like "head" and "tail", also has a function that can lex arbitrary Haskell.
23:31:47 <mlh> coz that's how Haskellers roll
23:32:11 <Jafet> Well, lisp has always had read.
23:33:35 <dmwit> Lisp is somewhat easier to lex/parse.
23:34:00 <dmwit> But yes, even there it's a little surprising... =)
23:34:10 <Jafet> Not really. Common Lisp's reader is probably more complex than standard Haskell syntax
23:34:31 <dmwit> oh
23:34:43 <dmwit> I thought there were just parens and quotes. =P
23:34:52 <Jafet> You can reconfigure it even before it finishes reading the rest of your program. Excellent material for abuse
23:34:54 <m_88> tcl is easy to parse
23:35:37 <Jafet> (At least, that's what I gleaned from skimming the hyperspec)
23:36:19 <dmwit> Huh, you can change even the *lexing*?
23:37:29 <m_88> umm, can someone help me please:  http://codepad.org/3WhGrtdw ?
23:37:46 <dmwit> The worst I've had to deal with was a format that could retroactively specify the encoding for earlier bits of the file...
23:38:05 <m_88> Looks like package itself requires different version of some module than it's requrements?
23:38:14 <dmwit> m_88: mispaste?
23:39:02 <m_88> ohh
23:39:04 <m_88> yeah, sorry
23:39:10 <m_88> stupid x11
23:39:12 <m_88> http://pastebin.com/wtQetLKX
23:39:43 <dmwit> Hm, nasty.
23:39:54 <dmwit> Can you manually choose an earlier version of data-accessor-monads-fd?
23:40:12 <dmwit> e.g. "cabal install data-accessor-monads-fd-0.blah.blah.blah"
23:40:19 <dmwit> and then "cabal install yi" afterwards
23:40:29 <m_88> uh, i'll try that, thanks
23:40:30 <copumpkin> apple's binary plist format is pukeworthy
23:40:45 <dmwit> For bonus points, fix yi's cabal file to reflect what you've just discovered. =)
23:41:12 <m_88> dmwit: maybe that because earlier i was trying to install yi from sources?
23:41:52 <dmwit> Your other option is to just try bumping yi's upper bound on the transformers library. If it works, that's probably the preferred fix.
23:42:31 <dmwit> m_88: Earlier installations should have no effect on the success of current attempts.
23:43:12 <dmwit> cabal-install will prefer to use libraries that are already installed, but will install newer (or older) versions if it needs to for some dependency.
23:43:43 * dmwit -> bed
23:43:54 <m_88> nn
23:44:58 <CirceTheSorceres> Can anybody tell me if Arrows are going to be part of the Haskell' standard?
23:45:02 <scotty> Is "permutations" still in Data.List?  I get a "not in scope" error when I try to call it.
23:45:13 <copumpkin> CirceTheSorceres: probably not, but that's my uneducated guess
23:45:24 <copumpkin> scotty: as of 6.10, it should be
23:45:28 <kmc> CirceTheSorceres, Haskell' is an ongoing process
23:45:41 <kmc> CirceTheSorceres, Arrows aren't in H2010 and probably won't be in H2011
23:45:49 <kmc> they're not widely used
23:45:52 <copumpkin> I don't think they'll be part of any of them, myself
23:45:59 <kmc> i agree
23:46:02 <kmc> without a major rework
23:46:16 <kmc> in particular, if there's a good arrow syntax, i should be able to use it without providing "arr"
23:46:21 <kmc> i.e. it should work for any cartesian closed category
23:46:29 <kmc> or whatever the right sort of category is
23:46:57 <copumpkin> freyd I think
23:47:48 <scotty> I don't understand what's going on.  In ghci, I'm able to do "import Data.List", but trying to call any of the functions gives me a "not in scope" error.
23:48:07 <copumpkin> you can't do import in ghci...
23:48:12 <copumpkin> unless you mean in a loaded file
23:48:19 <copumpkin> :m + Data.List
23:48:39 <thoughtpolice> yes you can, since ghc 6.8 or so
23:48:43 <copumpkin> really?
23:48:45 <scotty> copumpkin: I've tried both.  What do you mean I can't import?  It seems to work.
23:48:46 <copumpkin> whoa
23:48:51 <scotty> Yeah
23:48:52 <thoughtpolice> they expanded the GHCi syntax to do this a while back
23:49:06 <copumpkin> what's funny is that if they added it in 6.8, it was before I started haskell :P
23:49:10 <CirceTheSorceres> thoughtpolice:  Wow!
23:49:10 <scotty> It changes from "Prelude>" to "Prelude Data.List>"
23:49:49 <thoughtpolice> arguably it shouldn't need to be expanded though, you should be able to define any top-level identifier inside GHCi scope, but you can't because it's essentially wrapped in a 'do' block
23:49:49 <scotty> Anyhow, even in a file, I can't get any of the functions to work.
23:49:52 <CirceTheSorceres> Looks like I need to come back from Haskell hiatus: did they add defining functions at the top level in ghci too?
23:49:54 <thoughtpolice> sad, that
23:50:00 <thoughtpolice> CirceTheSorceres: no :(
23:50:22 <copumpkin> CirceTheSorceres was too busy making men into pigs
23:50:30 <thoughtpolice> copumpkin: crazy, I started using haskell around ghc 6.6's release!
23:50:38 <copumpkin> old-timer!
23:50:39 * thoughtpolice looks at ghc's releases page
23:50:57 <CirceTheSorceres> copumpkin: She still might have that power
23:51:03 <thoughtpolice> "Version 6.6 (released 11 October 2006)"
23:51:06 <mornfall> What's wrong with let f x y = ...?
23:51:08 <CirceTheSorceres> copumpkin: But seriously
23:51:09 <mornfall> (wrt GHCi)
23:51:19 <CirceTheSorceres> That was one feature I missed
23:51:20 <thoughtpolice> ^^ whoa, almost 4 years now! :)
23:51:24 <copumpkin> omg
23:51:32 <CirceTheSorceres> vis-a-vis python and lisp
23:52:05 <thoughtpolice> mornfall: not so much that, but you can't for example, define new data types inside GHCi
23:52:10 <thoughtpolice> they must be loaded into a module
23:52:19 <mornfall> thoughtpolice: Indeed. That's kind of suck.
23:52:32 <thoughtpolice> very often I would like to test something in GHCi and I would like a data type, but I can't have it without a module
23:52:38 <thoughtpolice> which sucks
23:52:47 <CirceTheSorceres> thoughtpolice: exactly!
23:53:00 <thoughtpolice> I think hbc implemented this, what, 12 years ago or something?
23:53:00 <scotty> Ah, looks like I have GHC 6.8.2, and I don't think the function I'm looking for was added at that time.
