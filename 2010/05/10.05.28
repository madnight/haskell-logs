00:08:18 <gaze> hey, are there any good tutorials on writing EDSLs? I'm trying to pull apart tom hawkins' atom package...
00:11:22 <gaze> it looks like some people prefer to use GADTs to do type checking, but maybe he doesn't? sorry I'm kinda new at this haha
00:13:18 <djahandarie> What is the difference between extra-source-files and data-files?
00:13:24 <djahandarie> In a .cabal file
00:13:53 <djahandarie> Ah, I see, data-files isn't for source, just for data.
00:16:28 <gaze> n/m, definitely using GADTs
00:26:46 <shadwick> sorry for what is probably a stupid question, but how would I slice a list; say to get the first N indices of list L?
00:27:19 <mwotton> the first n elements?
00:27:22 <Jafet> > take 10 [2..]
00:27:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
00:27:24 <RyanT5000> shadwick: http://www.haskell.org/hoogle/?hoogle=Int+->+[a]+->+([a],+[a])
00:27:39 <RyanT5000> (you'll need to copy that whole thing as a link if it's broken in the middle for you)
00:28:12 <shadwick> ah, thanks RyanT5000 and Jafet
00:28:13 <RyanT5000> i misread your question, though; i thought you wanted the first N and all the ones after that
00:28:13 <Jafet> @hoogle (Integral n) => n -> [a] -> [a]
00:28:14 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
00:28:14 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
00:28:14 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
00:28:24 <RyanT5000> if you just want the first N, then you can use "take"
00:28:29 <shadwick> yeah I think Jafet got it
00:28:32 <RyanT5000> splitAt is a combination of "take" and "drop"
00:28:57 <shadwick> I just started looking at Haskell for the first time today; it's quite awesome from the tiny tiny glimpse I've seen so far
00:29:06 <shadwick> I'm just trying to tinker around a little bit
00:29:11 <RyanT5000> shadwick: if you haven't already, you should try Hoogle; you can often type in the type signature of the thing you need and find a result in the standard libraries
00:29:25 <RyanT5000> btw, has anyone looked into applying hoogle to the entirety of Hackage?
00:29:25 <shadwick> ah, definitely very useful
00:29:36 <kmc> RyanT5000, hayoo has some of hackage
00:29:49 <RyanT5000> kmc: ah, right; i've seen that
00:30:02 <RyanT5000> it would be nice if there were something built in to hackage and kept up-to-date
00:30:09 <RyanT5000> (bonus points if it has the ability to search old versions)
00:30:45 <djahandarie> cabal should be searching the project directory for any .hs files, right?
00:31:18 <djahandarie> Because it can't find a module which is defined in another file in the same directory as Main
00:46:55 <djahandarie> Hm, I tried using other-modules, but now I get cabal: can't find source for Bot.Process in ., dist/build/autogen
00:47:53 <djahandarie> Does it need some special file name for it to be found?
00:49:25 <gaze> hmm... do I wanna use Data.Typable or do I wanna use GADTs? or does this question not make sense?
00:50:27 <alar> gaze: my vote is for GADTs, but the right choise depends on what you really want
00:51:00 <gaze> hmm... okay. So basically I'm looking through the code for Atom...
00:51:18 <gaze> having serious trouble making heads or tails of what's going on
00:51:55 <kmc> gaze, i can't think offhand of a scenario where the choice is between Typeable and GADTs
00:52:00 <kmc> not to say there isn't one
00:52:12 <gaze> well, okay, I'm looking at the Atom DSL and the BASIC DSL
00:52:28 <pastorn> gaze: haha... basic
00:52:32 <kmc> GADTs are basically a way to offload some of the well-formedness checking of your data type into the Haskell type system
00:52:47 <gaze> hmm... that makes sense
00:52:51 <kmc> whether that's a good idea depends on whether the well-formedness properties you want can be expressed nicely in the Haskell type system
00:52:58 <pastorn> gaze: what about atom?
00:53:10 <kmc> gaze, i can help you make sense of specific code if you can link / hpaste it
00:53:44 <pastorn> gaze: think of it as a very weird dialect of C with cool timing constructs :)
00:54:01 <pastorn> at least that's what i've gathered from looking at the documentation
00:54:12 <gaze> well, that part makes sense, i'm really just trying to figure out what the proper way to write a DSL is
00:54:22 <gaze> I'd love to know how it builds up the AST
00:54:42 <pastorn> gaze: starting by looking at Atom might not be the best way (since it's very complex)
00:54:53 <kmc> gaze, do you know how GADTs work in general?
00:55:52 <pastorn> gaze: have you used parsec? that's a neat DSL
00:56:07 <gaze> it looks like it's a way to constrain the type of a constructor
00:56:15 <gaze> but beyond that I don't know much else
00:56:28 <pastorn> gaze: yes, that's it :)
00:56:36 <twb> Is there a fuse-zipperfs?
00:56:41 <twb> If not, why not?
00:56:46 <pastorn> gaze: instead of writing what data to contain you write the constructors type signature
00:58:10 <kmc> gaze, http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/data-type-extensions.html#gadt
00:58:15 <kmc> the example here of Term and eval
00:58:29 <kmc> is pretty good for getting the essential idea
01:00:39 <gaze> okay, that definitely makes sense. so, I guess now I have some constructors that are constrained... how do I go from that do the blah = bleh $ do something, where I start consuming the somethings... from what I understand, you define some monad that chains each something to the next to build up your AST
01:01:05 <gaze> do just desugars to something >>= something else >>= etc., yeah?
01:01:41 <pastorn> gaze: correct
01:01:57 <pastorn> gaze: what sort of DSL are you thinking of making?
01:02:21 <gaze> something to control machine tools by generating g-code
01:02:30 <pastorn> wut?
01:02:55 <gaze> well, you have these computer controlled machines that you use to cut stuff out of metal, plastic
01:03:18 <gaze> think of a drill press, only you're moving the piece into and around the bit, and the bit cuts sideways, etc.
01:03:57 <pastorn> so moving the plate around etc?
01:04:00 <gaze> but the code that's interpreted on the computer is just a series of x/y/z coordinates, feed rates, coolant on/coolant off
01:04:07 <gaze> in a sense
01:04:15 <pastorn> oh, ok
01:04:35 <gaze> so I'd like to go to a higher level and be like surfacePart (some bounding box) cutGearTeeth, drillCenter
01:05:32 <pastorn> gaze: here you have a nice example of a DSL for some geometries:
01:05:36 <pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures.html#lecture2
01:06:02 <pastorn> gaze: look in Shape.*
01:08:44 <gaze> hmm... doesn't appear to be much here on the monad required
01:09:17 <pastorn> gaze: no, this isn't a monadic DSL
01:09:41 <pastorn> but it gives you a sense of what you can do
01:09:57 <fasta> gaze, do you have an actual CNC machine?
01:10:03 <pastorn> gaze: for what you have in mind will order make a difference?
01:10:30 <fasta> pastorn, if you build anything, order makes a difference :)
01:10:46 <gaze> order makes a pretty huge difference, yep
01:11:02 <pastorn> gaze: ok
01:11:45 <fasta> gaze, do you have such a cutting machine already?
01:12:04 <gaze> I do yeah, i've been writing code for it by hand thus far
01:12:06 <gaze> complete pain
01:12:17 <gaze> well, I have one back home, and I have access to one here at university
01:12:18 <fasta> gaze, ah, because it is untyped?
01:12:36 <gaze> well, it's not turing complete either :-P
01:12:46 <gaze> it's hardly code, it's a list of coordinates and feed rates
01:13:57 <gaze> I have a bunch of python scripts I use to generate code... well... that and graph paper and a calculator... pretty bad.
01:15:23 <pastorn> gaze: i'd have a datatype like this, sort of: data CNC a where { Goto :: Double -> Double -> CNC a; SetFeed :: Double? -> CNC a; End :: CNC a }
01:15:42 <pastorn> or you can do the top-down approach
01:15:48 <RyanT5000> gaze: are you using any sort of CAD software?
01:16:17 <pastorn> describe what's possible (circles, squares, angles etc.) as an ADT and then when compling that generate the above stuff
01:16:29 <gaze> I use solidworks sometimes
01:16:38 <gaze> CAM software is extremely expensive
01:16:39 <fasta> gaze, how much does your machine at home cost? I had the impression they cost > 10K$
01:17:10 <gaze> I have a lil' benchtop machine... it was about 3kish
01:17:23 <gaze> though I'm searching for a bigger one
01:17:41 <gaze> you can find huge ones at auction for maybe 4k-8k
01:17:54 <fasta> I think it is a wonderful domain (automated construction) and any strongly typed system can probably help. The best thing would be to have a simulator, I suppose.
01:17:54 <gaze> made in the 70s-80s... paper tape... real fun
01:17:59 <RyanT5000> wow
01:18:11 <gaze> yeah, I'm working on a simulator too
01:18:12 <pastorn> gaze: http://hackage.haskell.org/package/haskell-cnc
01:18:19 <gaze> it uses a tridexel representation for the solid
01:18:21 <RyanT5000> it would seem that a type system for CNC could get quite complex
01:18:35 <RyanT5000> if you wanted any kind of type-level representation of requirements on the workpiece
01:18:39 <fasta> gaze, you should post to Haskell-Cafe. I am sure lots of people are interested.
01:19:01 <RyanT5000> e.g.: static verification that you aren't exceeding machine parameters
01:19:15 <fasta> gaze, specifying things like exact type of machine you are using could make more people interested.
01:19:21 <gaze> I'm coming from a world of imperative programming haha... I can't even begin to envision how a type system would apply to manufacturing, but I'd be really interested
01:19:43 <pastorn> RyanT5000: quickcheck!
01:20:04 <gaze> i've been programming for a while now (did the valgrind port to ARM) but am definitely new to haskell
01:20:42 <RyanT5000> gaze: well, a type is, at its core, a description of certain properties of how an algorithm behaves
01:20:50 <fasta> gaze, in principle, you would write a simulator in the type-system and check that the result equals what you actually wanted, in theory. In practice, writing a simulator is easier ;)
01:21:11 <RyanT5000> fasta: the line between simulator and type system is not especially clear, IMO
01:21:22 <gaze> haha yeah... writing a CNC simulator is a really interesting computational geometry problem
01:21:25 <fasta> RyanT5000, they are equivalent.
01:21:42 <fasta> gaze, more like nightmare ;)
01:21:44 <RyanT5000> fasta: :P
01:21:51 <gaze> you need a boolean representation of a solid and a way to deal with sweeping some arbitrary cylindrically symmetric solid through a certain path
01:21:53 <RyanT5000> equivalence is all about perspective
01:26:49 <gaze> haha okay I'm about to ask some n00b questions... so if I have data E a where Add :: NumE a => E a -> E a -> E a... that just defines that some add operation takes 2 NumEs and returns a NumEs... alright... so now I'm trying to figure out where the NumEs are defined in here...
01:27:10 <gaze> I guess it'd be "class (Num a, Expr a, EqE a, OrdE a) => NumE a\ instance NumE Int8" etc. etc.
01:28:34 <Axman6> hmm, is that using type families?
01:29:25 <gaze> I haven't a clue... hopefully this isn't too stupid a goal, but I'd like to kinda pick apart Atom and build up my own little AST with a subset of the language just to try and learn what's going on
01:29:39 <gaze> like see how much of atom is required such that I can get an AST
01:31:17 <Axman6> i have a feeling it's using some rather advanced concepts (at least, advanced for someone new to haskell)
01:31:51 <gaze> too much to attempt to depth-first it?
01:33:00 <djahandarie> Heh, never thought of talking about learning in terms of a graph traversal
01:43:38 <gaze> hmm... is there anyone who might have some spare time that might be able to walk through some of the atom source with me?
01:43:50 <gaze> lemme see...
01:47:13 <gaze> http://bea.ms/atom/Language/Atom/Expressions.hs
01:47:18 <gaze> there's the question in file, haha
01:48:45 <gaze> err
01:48:48 <gaze> file in question
01:48:53 <pastorn> yes?
01:49:01 * pastorn is looking through it...
01:50:17 <gaze> so I'm first curious what all the class "(Num a, Expr a, EqE a, OrdE a) => NumE a \instance NumE Int8..." is up to
01:50:32 <pastorn> lin?
01:50:34 <pastorn> e
01:51:21 <pastorn> gaze: that's probably just for shortening type signatures
01:51:39 <gaze> ah, 407
01:51:57 <pastorn> instead of writing that big parentheses on functions further down they can just write NumE a ==> instead
01:52:59 <gaze> oh hmm... well if I just copy-paste that It complains that "Not in scope: type constructor or class `Int8'"... so in that case, where does atom satisfy that?
01:53:14 <quicksilver> import Data.Int
01:53:18 <quicksilver> (is where Int8 comes from)
01:53:33 <pastorn> seems silly that it's not reexported
01:53:33 <gaze> oh :D
01:54:00 <goldie23423> does anyone know how i would go about making concatMap work on a list of tuples?
01:54:12 <quicksilver> concatMap *does* work on a list of tuples
01:54:23 <goldie23423> oh
01:54:33 <pastorn> @type concatMap
01:54:34 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:54:41 <quicksilver> > concatMap (\(a,b) -> [(a,a),(a,b),(b,b)]) [(1,2),(3,4),(5,6)]
01:54:42 <lambdabot>   [(1,1),(1,2),(2,2),(3,3),(3,4),(4,4),(5,5),(5,6),(6,6)]
01:54:49 <goldie23423> cheers, silly me
01:54:52 <quicksilver> of course I have no idea what you want to do with it ;)
01:57:14 <wvd> So I've been writing my first Haskell program and I'd like so comments, I'm pretty happy with it, it's 3 times as short as the C equilivant (not fully the same, but still) - Things I'm not happy with, the calcExpr (I could use a two lists, one with the characters and one with the functions, but is that better?) And also the read [a] :: Int is not really that nice, code here: http://codepad.org/9ekhC7nr - Any comments would be nice.
01:58:56 <pastorn> filter (`notElem` "() ")
01:58:59 <pastorn> hahahahaha
01:59:09 <pastorn> so much for associativity :D
01:59:15 <aristid> wvd: you don't need to use guards in calcExpr
01:59:31 <wvd> pastorn, what :p?
01:59:35 <Gracenotes> beautiful formatting. and yeah, who needs order of operations
02:00:13 <wvd> aristid: what then? I could use two lists e.g. "+-" and [(+),(-)], lookup index in list 1, get the funciton out of two.
02:00:22 <pastorn> wvd: http://codepad.org/WM0zBb2p
02:00:32 <tomberek> what is more efficient, records or pattern matching?
02:00:33 <wvd> Gracenotes, it's a bit backwards compability. Most AST's are written like (+ 2 (* 4 4)) instead of + 2 * 4 4.
02:00:52 <Ytinasni> pastorn: you don't need the case there.
02:01:01 <pastorn> tomberek: they're not in the same league, so to speak
02:01:04 <aristid> wvd: calcExpr '+' = (+)
02:01:05 <Gracenotes> oh. nearly thought it was infix. .. that explains that
02:01:06 <aristid> and so on
02:01:07 <pastorn> Ytinasni: yes i do!
02:01:13 * pastorn needs cases EVERYWHERE
02:01:17 <Ytinasni> :D
02:01:27 <wvd> aristid: wouldn't guards be better then?
02:01:38 <Gracenotes> pattern matching is nearly as efficient as you can get
02:02:13 <pastorn> tomberek: records is for containing a collection of data, differint constructors (which you sort out with pattern matching) is for control flow
02:02:19 <Gracenotes> moreso than guards, at least
02:03:01 <wvd> oh
02:03:06 <tomberek> pastorn: f (MyData a _) = a    or f = PickA  with data MyData = MyData {PickA::Int,PickB::Int}
02:03:16 <pastorn> wvd: guards are for properties, not case matching... f x = | x < 0 = ...; | x * x == 10 = ...; | x <= 0 = ...
02:03:21 <tomberek> or rather pickA
02:03:22 <aristid> wvd: no, why should guards be better?
02:03:35 <wvd> pastorn: I see.
02:04:06 <aristid> wvd: but really your calculator sucks :P
02:04:18 <wvd> aristid: why :(?
02:04:33 <tomberek> pastorn: if there is only one constructor, they are similar
02:04:33 <aristid> wvd: it only supports single-digit numbers?
02:04:49 <wvd> aristid: yeah.
02:04:51 <pastorn> tomberek: if there is only one constructor you don't need pattern matching
02:05:06 <aristid> wvd: in my book, that's not a useful calculator then :P
02:05:20 <Gracenotes> aristid: nonsense, you can construct any number from single digits
02:05:24 <pastorn> tomberek: data D = D { x :: Int, y :: Int };  f d = x d -- this will choose field x from a D
02:05:24 <tomberek> pastorn: but I was asking about performance... f (MyData a _) = a or f=pickA
02:05:35 <Gracenotes> -.-
02:05:36 <aristid> Gracenotes: haha
02:05:39 <pastorn> tomberek: don't worry about performance for such things
02:05:40 <wvd> aristid: ah well, it's my first program in Haskell and it was mainly to test my experience, and it was a lot shorter then the C version
02:06:03 <aristid> wvd: the C  version is equally useless? :)
02:06:06 <pastorn> tomberek: focus more on wether you should be using Map, List or Array
02:06:16 <pastorn> tomberek: and write clever algorithms
02:06:26 <tomberek> pastorn: ok, is there any other reason to use records vs pattern matching in this one-constructor case?  readability, what is standard?
02:06:28 <wvd> aristid: in your interpretation, yeah :P
02:06:42 <pastorn> tomberek: also, i don't think it matters, i'm pretty sure it all compiles to identical code
02:07:01 <tomberek> pastorn: ok, thanks for the help
02:07:14 <pastorn> tomberek: i usually separate my datatypes in two categories
02:07:43 <pastorn> the big ones with one constructor and fiddy fields, then the other ones with fiddy constructors and 0~3 fields each
02:07:55 <pastorn> the first ones gets record syntax, the latter don't
02:08:05 <tomberek> pastorn: roger
02:08:23 <pastorn> and i never pattern match on the first, always on the latter (and always with case-statements)
02:08:49 <aristid> wvd: can you show me how to do slightly complex calculations with that calc? i'm confused
02:09:22 <wvd> aristid: It's basically AST syntax, such as: (+ 5 (* 4 4)) [parenthesis are not neccesary]
02:09:30 <aristid> +*123 returns 3
02:09:50 <aristid> i think +*123 should returns 6
02:10:06 <wvd> +*123 is non-valid syntax.
02:10:08 <wvd> invalid*
02:10:11 <wvd> but I didn't check for that, yet.
02:10:18 <aristid> why is +*123 invalid?
02:10:33 <Gracenotes> should be +3*12, no?
02:10:46 <IceKiller> anyone here know if theres a dedicated chan for cuda/opencl?
02:10:50 <wvd> Gracenotes, right.
02:11:12 <aristid> what's the rationale for this restriction?
02:11:14 <wvd> aristid: oh wait, you're right.
02:11:26 <wvd> aristid: +*123 should indeed be valid.
02:11:50 <Gracenotes> you would need a more complicated sort of recursion for that
02:12:04 <vitka__> > +*123
02:12:05 <lambdabot>   <no location info>: parse error on input `+*'
02:12:24 <vitka__> Heh.
02:12:27 <Gracenotes> or likewise for n-ary operationed ASTs
02:12:28 <int-e> > (+)((*)1 2)3
02:12:29 <lambdabot>   5
02:13:36 <aristid> @src words
02:13:37 <lambdabot> words s = case dropWhile isSpace s of
02:13:37 <lambdabot>     "" -> []
02:13:37 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
02:14:09 <pastorn> wvd: i don't think you need the ":: Int" in "read [x] :: Int"
02:14:28 <wvd> pastorn: oh right because it's in the type signature.
02:14:30 <pastorn> you get the type (Int) from the type signature of evalExpr
02:14:35 <wvd> pastorn: I tried it on the ghci :P
02:14:35 <wvd> thanks
02:14:49 <aristid> :t \s -> case dropWhile isSpace s of { "" -> [] ; s' -> w : words s'' where (w, s'') = break isSpace s' }
02:14:50 <lambdabot> [Char] -> [[Char]]
02:15:01 <aristid> @pl words s = case dropWhile isSpace s of { "" -> [] ; s' -> w : words s'' where (w, s'') = break isSpace s' }
02:15:01 <lambdabot> (line 1, column 39):
02:15:01 <lambdabot> unexpected "{"
02:15:01 <lambdabot> expecting variable, "(", operator or end of input
02:15:16 <aristid> @pl words s = case dropWhile isSpace s of "" -> [] ; s' -> w : words s'' where (w, s'') = break isSpace s'
02:15:16 <lambdabot> (line 1, column 42):
02:15:16 <lambdabot> unexpected ">" or "-"
02:15:16 <lambdabot> expecting variable, "(", operator or end of input
02:15:22 <aristid> too bad.
02:18:40 <kmc> @pl \s -> case dropWhile isSpace s of { "" -> [] ; s' -> w : words s'' where (w, s'') = break isSpace s' }
02:18:40 <lambdabot> (line 1, column 35):
02:18:40 <lambdabot> unexpected "{"
02:18:40 <lambdabot> expecting variable, "(", operator or end of input
02:28:54 <aristid> i'm searching for a generalised words function in Data.List, am i overlooking something?
02:31:04 <kmc> aristid, generalized splitting can be found in the "split" package on hackage
02:34:29 <Jonno_FTW> @src concat
02:34:29 <lambdabot> concat = foldr (++) []
02:34:45 <wvd> !src sum
02:36:49 <pastorn> @src sum
02:36:49 <lambdabot> sum = foldl (+) 0
02:36:52 <pastorn> wvd: :p
02:36:57 <peterNovice> Does anyone know if galois are planning to post the videos of their tech talks?
02:37:29 <wvd> pastorn, i'll queried lambdabot already :p
02:37:40 <wvd> it's cool to see how these functions are implemented in actually readable haskell code
02:37:57 <pastorn> wvd: yeah... @src is the best :D
02:38:03 <kmc> except when it lies
02:38:10 <quicksilver> interesting, I think @src is the worst.
02:38:31 <quicksilver> it's incomplete, it's fraudulent, and it doesn't teach people that all the source is browsable on the web anyway
02:38:32 <pastorn> @slap quicksilver
02:38:32 * lambdabot hits quicksilver with an assortment of kitchen utensils
02:39:04 <quicksilver> the only advantage that @src has over the web-viewable source is occasionally being part of an ongoing conversation.
02:39:07 <quicksilver> it's very rarely used that way.
02:39:10 <quicksilver> normally it's just spammy.
02:40:13 <pastorn> quicksilver: for you, maybe
02:40:14 <aristid> kmc: that split package seems nice
02:40:39 <quicksilver> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Prelude.html#v%3Asum
02:40:44 <quicksilver> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/Data-List.html#sum
02:40:51 <quicksilver> two infinitely more useful links
02:40:58 <quicksilver> from those you can see how to see *all* the source
02:41:02 <quicksilver> and it's the actual, real source.
02:41:07 <quicksilver> and complete etc.
02:41:32 <quicksilver> partial tools which don't provide pointers to the corresponding more complete tool are traps.
02:41:53 <djahandarie> Would be nice if @src would provide a link
02:42:04 <djahandarie> Not sure how it would decide which version to provide though
02:42:06 <quicksilver> that would be a much more useful tool.
02:42:48 <quicksilver> well there is @docs and @src
02:42:51 <quicksilver> @docs Prelude
02:42:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
02:42:54 <quicksilver> @source Data.List
02:42:55 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
02:43:12 <quicksilver> don't think there is a veresion which gives the anchor-link to a particular function name.
02:44:31 <earthy> whaa. halp.
02:45:01 <RyanT5000> in case anyone in here hasn't seen my spams yet:
02:45:05 <earthy> my program is generating ~60M Chunk items on the heap
02:45:11 <RyanT5000> my company's currently offering jobs writing games in haskell
02:45:26 <earthy> ryant5000: cool. url?
02:45:32 <RyanT5000> ipwnstudios.com
02:45:40 <RyanT5000> you can email me at ryan@ipwnstudios.com if you're interested
02:45:45 <RyanT5000> we're nearing release of our first game
02:46:06 <RyanT5000> so the currently-open positions are to work on that and possibly continue in the future
02:46:23 <alar> RyanT5000: what will haskellers do for that game? scripting?
02:46:28 <Jafet> Specifically, writing games in haskell for phones, presumably
02:46:33 <alar> @hoogle FSVec
02:46:34 <lambdabot> No results found
02:46:38 <RyanT5000> yup, for phones
02:46:46 <RyanT5000> alar: we write as much as we can in Haskell
02:46:56 <RyanT5000> we have some C/C++/Objective-C
02:47:13 <RyanT5000> but that's only for performance-critical or platform-API bits
02:47:34 <alar> RyanT5000: graphics in ObjC, highload in C, everything else in haskell, right?
02:47:36 <earthy> 'telecommuting when appropriate'...
02:47:43 <RyanT5000> graphics are also C
02:47:52 <RyanT5000> objective C is mostly for collecting input and producing output
02:47:59 <RyanT5000> actually, mostly just for collecting input
02:48:00 <earthy> makes sense
02:48:05 <RyanT5000> output goes through OpenAL and OpenGL mostly
02:48:18 <alar> RyanT5000: how do you compile haskell for target platform?
02:48:20 <RyanT5000> (they both require obj-c startup)
02:48:41 <RyanT5000> alar: we developed ghc-iphone; it's available under BSD at http://projects.haskell.org/ghc-iphone/
02:48:49 <alar> cool!
02:49:05 <fasta> RyanT5000, how many manhours did the port take?
02:49:22 <RyanT5000> fasta: i don't recall exactly (it was more than a year ago), but it was surprisingly short
02:49:25 <aristid> > filter (not . flip elem [""," "]) $ split (oneOf $ "+*- ()") "1 + (2 * 3)"
02:49:26 <lambdabot>   Not in scope: `oneOf'
02:49:27 <RyanT5000> we use -via-c
02:49:32 <RyanT5000> so it's not super-fast
02:49:39 <aristid> too bad, lambdabot doesn't have split
02:49:47 <quicksilver> RyanT5000 doesn't use men. He uses dark immortal spirits.
02:49:58 <quicksilver> that's the only explanation for the successful GHC hacking :)
02:50:20 <alar> RyanT5000: anyway GHC for ARM is cool. some task need not to be superfast
02:50:35 <djahandarie> Yeah, really... I looked at GHC once and ran before it work up
02:50:47 <RyanT5000> quicksilver: lol
02:50:48 <pastorn> RyanT5000: how much memory can you expect from a system?
02:50:57 <RyanT5000> yeah, actually we're looking for another dark spirit right now :P
02:51:04 <RyanT5000> someone to write ghc-android
02:51:05 * alar is bored by coding telemetry stuff on ARM in C
02:51:25 <kmc> actually, i'm trying to build ghc-iphone on linux right now
02:51:26 <RyanT5000> pastorn: iPhone has 128 MB of RAM, except the 3G S which has 256
02:51:34 <kmc> and running into autoconf build system hell
02:51:36 <pastorn> oh shi
02:51:41 <pastorn> i was thinking of the DS
02:51:42 <RyanT5000> we get about 3/4 of that RAM
02:51:43 <pastorn> it has 4
02:51:55 <RyanT5000> pastorn: yeah, that would be much more difficult to manage :P
02:52:12 <pastorn> RyanT5000: bah, you're just seing problems here, not solutions
02:52:27 <pastorn> RyanT5000: how much does your RTS consume?
02:52:48 <RyanT5000> i'm not sure precisely
02:52:50 <RyanT5000> a few MB, i think
02:52:55 <pastorn> < 4?
02:53:01 <pastorn> plz?
02:53:06 <RyanT5000> the GHC RTS would definitely need to be slimmed down to work on DS
02:53:40 <pastorn> though when running from a DS you run directly from ROM
02:53:57 <pastorn> i'm guessing that's quite different from how you do it on a phone
02:54:26 <pastorn> so most the RTS could perhaps be placed in ROM
02:54:53 <pastorn> (and here haskell comes and is annoyingly far from the hardware...)
02:55:43 <RyanT5000> ah, that's a good point
02:55:59 <RyanT5000> it would be interesting to see how much can be crammed into ROM
02:56:14 <quicksilver> you'd have to change the way GHC generates code though
02:56:23 <quicksilver> currently it puts data next to code
02:56:24 <RyanT5000> however, using a GCed language has distinct disadvantages when dealing in extremely memory-limited platforms
02:56:35 <quicksilver> (although didn' teh llvm guys change that for the llvm backend?)
02:56:39 <RyanT5000> quicksilver: that doesn't sound especially hard to change
02:56:42 <pastorn> yeah... i know that there's pyDS and a lisp implementation already
02:56:57 <RyanT5000> we've forked GHC once in the past, and we'll do it again if need be :P
02:57:37 <kmc> correct, the LLVM backend does not currently put info tables next to code
02:57:42 <earthy> using a GCed language has distinct disadvantages when dealing with any platform in which the data doesn't fit in memory with generous room to spare
02:58:09 <aristid> earthy: on the other hands, platforms without generous memory are obsolete already.
02:58:18 <aristid> memory is cheap enough to have some of it.
02:58:51 <pastorn> i was thinking about running haskell on a DS before... would it be possible to write a YHC bytecode interpreter?
02:59:09 <Silvah> DS?
02:59:19 <pastorn> Silvah: nintendos portable console
03:00:11 <pastorn> i need a nap
03:00:15 <pastorn> bbl
03:01:31 <earthy> aristid: I'm running on a system with 128GiB RAM. I'm filling it to capacity and still need more.
03:02:29 <RyanT5000> earthy: dang; i just upgraded from 3 to 6 and it feels amazing :P
03:02:39 <aristid> earthy: i thought you were talking about kilobytes to a few megabytes when talking about ungenerous memory :P
03:03:22 <earthy> yah, I develop on the laptop... 4GiB
03:03:45 <earthy> this chokes on the smallish testsets. shouldn't, but does.
03:04:48 <fasta> earthy, what are you doing?
03:04:59 <earthy> fasta: indexing
03:05:02 <aristid> lol i have 2GB on my laptop and it is plenty for me
03:05:05 <fasta> earthy, of what?
03:05:41 <earthy> to be exact: we run a natural language parser on patent texts, generating dependency graphs
03:06:17 <fasta> I have 4GB on my laptop and I never used it, but in reality you cannot have enough CPU*memory/dollar
03:06:20 <earthy> these dependency graphs (that model the syntactic structure of the sentences in the texts) are then indexed using a 'standard' inverted index
03:07:06 <fasta> You lost me at standard inverted index.
03:08:00 <fasta> earthy, what is the application?
03:08:09 <earthy> search
03:09:06 <fasta> earthy, if you have that much data, doesn't Google work?
03:11:05 <earthy> okay. try using google to figure out whether 'aspirin causes acidosis'
03:11:33 <earthy> 'About 2,750,000 results (0.35 seconds) '
03:11:51 <fasta> earthy, and the top results are pretty good.
03:12:17 * earthy nods
03:12:20 <fasta> Aspirin and Other Salicylate Poisoning(Salicylism) ... Salicylates simultaneously and independently cause primary metabolic acidosis. ...
03:12:26 <fasta> The very first result.
03:12:33 <earthy> however, try to extend that to 'sickness'
03:12:45 <fasta> Anyway, Peter Norvig basically says that the actually algorithm doesn't matter as much as the amount of data.
03:12:57 <earthy> fasta: true to a large degree
03:13:04 <fasta> At first, I was skeptical, but after his presentation it was pretty convincing.
03:13:12 <fasta> actual*
03:13:41 <earthy> however, narrowing down from 'aspirin causes acidosis' to a much more specivic search query is *hard*
03:13:42 <fasta> earthy, ok, so it also integrates with some kind of probabilistic component?
03:13:51 <earthy> you either get a *lot* of hits, or none at all
03:14:38 <fasta> aspirin causes sickness also works, btw.
03:14:40 <earthy> let me find a better example
03:14:44 <fasta> :D
03:14:53 <earthy> (google is damn good already)
03:15:17 <fasta> The thing is, that Google employees see what you are searching for, and if  you don't find it, they fix it such that it can.
03:15:28 * earthy nods
03:15:39 <fasta> It's a reinforcement learning system basically, just not automated, yet.
03:16:01 <fasta> And since they have the most CPU power in the world, they can own everybody else.
03:16:19 <fasta> (assuming they utilize it correctly, which they probably do)
03:16:58 <fasta> That said, a custom application can probably be made more useful.
03:17:46 <earthy> the issue is in expert search, for e.g. patent texts. you want to find all prior patents that pertain to a certain patent application and no others.
03:18:17 <earthy> so, given 'A method for testing a network interface is provided that includes generating a data pattern file based on a pseudocode file and testing the interface using the data patternfile.'
03:18:32 <earthy> you'd want to find pre-existing similar patents.
03:18:40 <Jafet> One problem being that the texts of patents tend to be obfuscated on purpose
03:19:00 <djahandarie> Cabal is doing this weird thing where it is compiling EVERYTHING every time I do a cabal instal
03:19:09 <RyanT5000> fasta: try not to assume that because google is successful, they are optimal
03:19:09 <djahandarie> All the dependencies
03:19:15 <earthy> Jafet: exactly.
03:19:21 <fasta> RyanT5000, I know they are not optimal.
03:19:31 <Jafet> (Optimal at what?)
03:19:37 <fasta> RyanT5000, but as far as practical optimality goes, they seem to be.
03:19:45 <RyanT5000> fasta: they're merely the state of the art
03:19:53 <RyanT5000> in 100 years, i'm sure search will be unfathomably better
03:19:56 <fasta> RyanT5000, they have been named "best company/most successful company ever".
03:19:57 <RyanT5000> and someone will take us there
03:20:07 <fasta> RyanT5000, I also know that.
03:20:14 <RyanT5000> it might be google, but probably not
03:20:21 <RyanT5000> sustaining innovation with that kind of market cap is tricky at best
03:20:23 <fasta> Economically, it could be Google.
03:20:29 <Jafet> earthy, can't work from disk?
03:20:30 <earthy> for the given sentence, google gives me 51800 results, of which 1 is the patent text I took the sentence from.
03:20:40 <RyanT5000> (though, i've got to say good job to them so far on sustaining innovation)
03:20:44 <earthy> Jafet: will work from disk *after* the index is constructed.
03:20:56 <Jafet> Can't work from disk while constructing it?
03:21:02 <Jafet> What kind of index?
03:21:24 <Jafet> Oh, stated above
03:21:28 <earthy> basically: Map ByteString [SentenceNumber]
03:21:53 <djahandarie> When I cabal install one thing it seems to brick everything else
03:22:14 <djahandarie> And when I try to cabal install anything else it bricks the first thing
03:22:17 <Jafet> You can do that on disk, suitably cleverly (but probably not with Haskell)
03:22:39 <earthy> I've read the literature, and yes, you can also do that with haskell
03:23:07 <earthy> however, I have what should be enough mem, and for simplicity's sake I'd like that to work.
03:23:55 <earthy> but laziness seems to not let me.
03:25:34 <alar> RyanT5000: is this vacancy of iPwnStudios full-time or remote?
03:25:58 <RyanT5000> alar: we prefer full-time people right now, as we're coming up on a release; however, they need not be local
03:26:08 * ManateeLazyCat pasted "duplicate instance code." at http://paste2.org/get/854801
03:26:08 <ManateeLazyCat> In my above code, i have many duplicate instance code, so how to make above code simpler? I mean don't use TH. Thanks!
03:26:36 <ManateeLazyCat> TH is hard to write and change, speical to complicated situation.
03:27:26 <RyanT5000> if this game enjoys any manner of success, we'll probably be more open to part-time positions afterwards
03:27:28 * ManateeLazyCat I plan to write new Code-Generate library that don't use TH technology.
03:27:37 <alar> RyanT5000: in case of full-time remote work, what's he timezone?
03:27:57 <RyanT5000> alar: we all work in our local timezone
03:27:59 <RyanT5000> except me
03:28:03 <RyanT5000> i just don't sleep :P
03:28:15 <RyanT5000> (i sleep sometimes, but not on any particular schedule)
03:28:22 <RyanT5000> our lead programmer is in New Zealand
03:28:24 <earthy> it's what, 6.30 am in your timezone :)
03:28:31 <ndxtg> Hi. I need some helps on modules. I have module Test(Data_test) where data Data_test t = <smthing>. On other module I call import Test (Data_test) but the data constructor is not in scope. Any help? I've never used modules before.
03:28:34 <ManateeLazyCat> RyanT5000: My timezone is disordered. :)
03:28:51 <RyanT5000> New Zealand is UTC+12
03:28:51 <ManateeLazyCat> RyanT5000: I just sleep when my eye missing bed. :)
03:28:58 <RyanT5000> yep, it's 6:30 here
03:29:08 <RyanT5000> i haven't slept in a while :P
03:29:15 <ManateeLazyCat> 6:30 pm in China.
03:29:48 <ManateeLazyCat> ndxtg: import Test (Data_test(..)) ?
03:29:52 <otulp> ndxtg: use module (Data_test(..)) at the head of your module to export all constructors for Data_test.
03:30:14 <ManateeLazyCat> ndxtg: For import constructor, just add (..) at the end of type.
03:30:15 <otulp> ..and on the import, too, yes.
03:30:37 <ndxtg> thank you guys. I've got it.
03:31:27 <mreh> RyanT5000, I'm interested
03:31:50 <RyanT5000> mreh: awesome :) you can PM me if you want or just send your resume to me at ryan@ipwnstudios.com
03:31:55 <RyanT5000> the company's website is ipwnstudios.com
03:31:55 <ManateeLazyCat> I plan to write the library that give it's format-data and rule, then it use *string template* generate haskell code in other file.
03:32:13 <ManateeLazyCat> I think this will give other programmer a clean logic.
03:32:40 <ManateeLazyCat> Don't like TH, i need spend much time to think TH code how to work.
03:33:20 <ManateeLazyCat> So have any exist hackage package to do *Code-Generator* ?
03:34:08 <Jafet> Well, TH is *the* code-generator
03:34:14 <wvd> Are there any preffered articles which explain Monads?
03:34:52 <ManateeLazyCat> Jafet: But we need spend too much time to figure out TH code logic.
03:34:53 <vitka__> Did someone say the M-word?
03:35:05 * ManateeLazyCat pasted "My TH code." at http://paste2.org/get/854808
03:35:10 <ManateeLazyCat> Jafet: Above is my TH code.
03:35:35 <ManateeLazyCat> Jafet: You tell me above code is what when you first time?
03:36:18 <ManateeLazyCat> s/first time/first time see it/
03:37:06 * ManateeLazyCat TH code make my code like alien code.... even i know how to write it....
03:37:12 <Jafet> It looks like it missed some refactoring
03:37:21 <Jafet> getCons is duplicated
03:37:37 <Jafet> You can write bad code in any language...
03:38:40 <ManateeLazyCat> Jafet: Don't care getCons part, just look [| ... |] part.
03:39:26 <kmc> wvd, there are too many monad tutorials; many of them are bad
03:39:31 <kmc> wvd, why do you want to learn monads?
03:39:44 <Jafet> It looks a bit like lisp, lazycat, is all I can say
03:39:55 <Jafet> And that's pretty normal, since TH is lisp
03:40:10 <wvd> kmc, I want to know how IO really works, and then I have a good base for writing programs
03:40:22 <kmc> wvd, are you already comfortable doing IO?
03:40:31 <kmc> monads aren't about IO, and IO is a poor example of a monad
03:40:47 <wvd> oh, well.
03:40:48 <kmc> it's best to ignore the connection between the two until you have a strong grasp of both individually
03:40:50 <ManateeLazyCat> Jafet: Yes, but i more like Haskell code style. :)
03:40:58 <wvd> kmc, so when I _should_ learn monads?
03:41:02 <ManateeLazyCat> Jafet: More natural
03:41:04 <Jafet> Well, good luck inventing your syntax
03:41:15 <kmc> wvd, well, "Monad" is the name of a type class, and its most important method is a higher-order function
03:41:31 <kmc> so you need to understand type classes and higher-order functions to begin with
03:42:00 <Silvah> Yay, yet another person trying to understand monads!
03:42:08 <Jafet> @quote monad tutorial
03:42:09 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
03:42:25 <kmc> wvd, anyway you may like http://haskell.org/haskellwiki/Monads_as_computation or http://haskell.org/haskellwiki/Monads_as_containers
03:42:28 <wvd> kmc, right. I think I got the grasp of them both
03:42:33 <Jafet> @quote monad.tutorial
03:42:33 <ManateeLazyCat> wvd: I recommend you read http://www.haskell.org/all_about_monads/
03:42:33 <lambdabot> arw says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
03:42:36 <kmc> or Typeclassopedia
03:42:48 <kmc> All About Monads has useful examples but is also misleading / incorrect in places
03:43:59 <ndxtg> has_tag :: a -> a -> t -> Bool   <---- where should I alter the (Eq a) to make it works properly?
03:44:33 <kmc> ndxtg, i don't follow, what's it supposed to do?
03:44:43 <wli> If monads are burritos, what are enchiladas?
03:44:58 <kmc> wli, probably applicative functors
03:45:04 <kmc> ndxtg, generally you can just leave off the signature and then ask ghci for the type
03:45:31 <ManateeLazyCat> ndxtg: Yes, like kmc said, i always do that, special for complicate function.
03:45:40 <ndxtg> kmc: it takes in somes arguments then compare the first 2 a so it needs to derive Eq but I dont know where or how should I put
03:46:02 <quicksilver> has_tag :: Eq a => a -> a -> t -> Bool
03:46:04 <ndxtg> actually I leave it off and the warning pops up when compiling and ask for Eq a
03:46:14 <ManateeLazyCat> ndxtg: I think you need "has_tag :: Ord a => a -> a -> t -> Bool"
03:46:19 <quicksilver> although I doubt that works for arbitrary t
03:46:36 <ndxtg> oh cool I've forgotten the "=>", havent used it for age
03:46:51 <ManateeLazyCat> ndxtg: Just for equal, Eq a => a is enough.
03:47:15 <ndxtg> ManateeLazyCat: yea I think so :) no need Ord
03:47:29 <ManateeLazyCat> ndxtg: If you want compare two arguments that which is bigger, you need write "Ord a => a -> a ..."
03:48:22 <ManateeLazyCat> Jafet: What do you mean "TH is lisp"?
03:48:32 <ManateeLazyCat> Jafet: It's implement by lisp?
03:48:54 <Jafet> TH is clearly designed from lisp macros
03:49:00 <kmc> eh, sort of
03:49:09 <kmc> it has quoting and unquoting
03:49:22 <danderson> there is clear familiarity
03:49:24 <Jafet> Well, that's all you need
03:49:25 <kmc> but it handles cross-stage scoping
03:49:31 <kmc> in a way Lisp macros don't
03:49:39 <danderson> that said, the more complex syntax in haskell makes TH clunkier to use than lisp macros
03:49:52 <danderson> (imho at least, ymmv)
03:50:01 <Jafet> That's "hygienic" in lisp parlance, kmc (unless you're a highbrow schemer, then you can call it "default")
03:50:06 <kolmodin> Igloo: code.haskell.org is down/slow. seems to affect not only http but ssh too
03:50:12 <kmc> Jafet, yeah
03:50:15 * ManateeLazyCat I think TH is power enough, but i don't it's syntax, really.....
03:50:23 <ManateeLazyCat> s/power/powerful
03:50:38 <kmc> some aspects of TH really bug me
03:50:41 <kmc> especially the lack of pattern splices
03:50:49 <kmc> (someone please correct me if i'm wrong and they exist)
03:51:12 <kmc> basically quote/unquote code doesn't look too bad, but that mechanism is incomplete so i often have to drop down to the combinator library
03:51:41 <danderson> what I don't like in TH is that I can't use it :(
03:51:57 <kmc> why not?
03:52:01 <danderson> because for my use, it tries to load LLVM bindings using ghci
03:52:10 <danderson> and ghci has a bug whereby it can't locate libstdc++.so on linux
03:52:14 <kmc> :(
03:52:15 <danderson> and so compilation of my TH code fails.
03:52:20 <RyanT5000> danderson: yes! i hate that bug!
03:52:29 <danderson> also, hacking a workaround for libstdc++.so also fails
03:52:35 <danderson> because then ghci tries to load libpthread.so
03:52:40 <danderson> which on linux is not an ELF library
03:52:41 <Jafet> Isn't pattern splicing on the todo?
03:52:43 <RyanT5000> also, my project is frozen to GHC 6.10.4, so there's no chance of it getting fixed until next project :(
03:52:43 <danderson> it's a GNU linker script
03:52:52 <danderson> that tells the linker which other libs it should be loading
03:52:54 <ManateeLazyCat> danderson: Report to ghc team?
03:53:06 <danderson> so unless ghci grows full GNU ld script parsing... :(
03:53:06 <RyanT5000> ManateeLazyCat: it's already in the tracking system
03:53:10 <danderson> ManateeLazyCat: it's a known bug
03:53:17 <danderson> it's just bloody hard to fix
03:53:47 <ManateeLazyCat> danderson: How unlucky to you..... :)
03:53:47 <danderson> (well, not the libstdc++.so part, that's relatively simple, just ask the local gcc what library search paths it uses - but the libpthread one is nasty)
03:54:54 <zygoloid>  ManateeLazyCat if you think TH is bad now, just wait until you start using DecQ :)
03:55:20 <zygoloid> quoting and splicing both use Q [Dec] but everything else works in terms of Q Dec. it's a pain in the ass.
03:56:34 <ManateeLazyCat> zygoloid: The biggest i don't like TH that make me like *robot*, is TH use me, not i use TH. :)
03:57:51 <Jafet> Don't mess with the Q.
03:58:39 <tibbe> danderson: I think they want to get rid of the custom linked in ghci eventually
03:59:14 <ManateeLazyCat> zygoloid: I plan to write a simple "easy-template* library, that accept format-string data then insert my template-rule, then i can do like this: "[String] -> ([String] -> HaskellFile) -> WriteCodeToHaskellFile"
03:59:44 <ManateeLazyCat> zygoloid: Similar like gtk2hs-buildtools' callback generator.
03:59:54 <danderson> tibbe: that would be cool.
04:00:26 <kmc> danderson, what is it if not an ELF library?
04:00:52 * tibbe is tracking down a nasty race condition in the new I/O manager :(
04:00:55 <danderson> kmc: a GNU linker script.
04:01:01 <tibbe> I hate concurrent programming!
04:01:09 <ManateeLazyCat> tibbe: Why?
04:01:22 <tibbe> ManateeLazyCat: cause it's so tricky
04:01:27 <nostrand> hi, kan i use type classes in type synonyms?
04:01:42 <danderson> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25781#a25781
04:02:14 <nostrand> type Coord = (Int,Int),        i want the Int's to be Nums instead
04:02:17 <ManateeLazyCat> tibbe: I love concurrent, special with gtk2hs, damn cool ... :)
04:02:22 <quicksilver> nostrand: you can, although I'm not sure how well it works.
04:02:40 <nostrand> quicksilver: is there a better alternative?
04:02:54 <tibbe> ManateeLazyCat: there's concurrent programming and then there's concurrent programming
04:03:04 <quicksilver> nostrand: I would prefer type Coord a = (a,a)
04:03:08 <tibbe> ManateeLazyCat: what I'm doing can in ways be seen as implementing java.lang.Thread
04:03:15 <quicksilver> nostrand: keep the num constraint at other levels, where it applies.
04:03:26 <nostrand> quicksilver: ok, yeah, sounds better =)
04:03:28 <nostrand> thanks
04:03:32 <tibbe> ManateeLazyCat: in particular implementing stopping of threads in a reliable (and idempotent) manner
04:04:00 * ManateeLazyCat pasted "gtk2hs-buildtools code" at http://paste2.org/get/854835
04:04:01 <ManateeLazyCat> zygoloid: In gtk2hs-buildtools, we can accept "NONE:STRING,POINTER", then gtk2hs-buildtools will generate above code.
04:04:14 <ManateeLazyCat> zygoloid: More like code snippet.
04:05:47 <tibbe> danderson: if you have time at some point I would mind bouncing my problem of someone
04:05:50 <tibbe> danderson: IRL
04:06:07 <danderson> tibbe: sure, whenever is fine
04:06:15 <tibbe> danderson: ok
04:08:23 <ManateeLazyCat> tibbe: "Race condition"? Can't add a MVar to lock?
04:09:31 <tibbe> ManateeLazyCat: well yes, the question is how to get the locking to work correctly. It's somewhat intricate as one thread might be stuck in epoll
04:11:55 <ManateeLazyCat> tibbe: I always use STM instead MVar, of course, some situation, STM maybe always rollback and waste calculate time...
04:12:20 <tibbe> ManateeLazyCat: I can't use STM as the actions need synchronization involves I/O
04:12:52 <ManateeLazyCat> tibbe: Oh, yes, for synchronous situation, MVar is only choose.
04:14:07 <tibbe> ManateeLazyCat: well, you can also use IORef with atomicModifyIORef in some cases
04:14:52 <djahandarie> Something is going whacky... I can install packages with Cabal but for some reason nothing picks them up (ghci, for example)
04:16:17 <nostrand> i'm coding a small real time game. I'm using records to hold the data, are they expensive to use?
04:16:46 <quicksilver> no, not particular
04:16:54 <nostrand> oki =)
04:16:55 * ManateeLazyCat brb
04:16:56 <quicksilver> "record syntax" is only a form of sugar
04:17:18 <quicksilver> data Foo = Foo {a :: Int, b :: Int} is exactly the same as data Foo = Foo Int Int
04:17:27 <quicksilver> same memory representation, same code generated
04:17:29 <nostrand> yeah, i actually know that, but didn't think of it =)
04:17:50 <quicksilver> certainly not a run-time string look like python or lua records
04:17:52 <quicksilver> (e.g.)
04:18:00 <quicksilver> s/look/lookup/
04:18:02 <fasta> If you have a record of size N, then updating one element takes time Theta(N).
04:18:09 <nostrand> quicksilver: haha
04:18:27 <nostrand> n < 10 in this case so =)
04:19:15 <freiksenet> hello, how can I make Debug.Trace.trace output it's argument instead of the string?
04:19:24 <freiksenet> it's second argument
04:19:37 <Starfire> freiksenet: traceShow?
04:19:45 <kmc> :t join traceShow
04:19:47 <lambdabot> Not in scope: `traceShow'
04:19:52 <kmc> :t join Debug.Trace.traceShow
04:19:54 <lambdabot> forall a. (Show a) => a -> a
04:20:09 <Starfire> What does ':t join' do?
04:20:26 <kmc> :t join
04:20:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:20:31 <kmc> ":t" gives you the type of something
04:20:40 <kmc> join f x = f x x
04:20:44 <kmc> (except it's actually more general)
04:20:49 <kmc> :t \f x -> f x x
04:20:50 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
04:21:15 <kmc> other uses of join
04:21:16 <Starfire> Ahhh.
04:21:26 <kmc> > join [[1,2],[3,4,5]]
04:21:27 <lambdabot>   [1,2,3,4,5]
04:21:31 <kmc> > join Just (Just 3)
04:21:32 <lambdabot>   Couldn't match expected type `a -> a'
04:21:33 <lambdabot>         against inferred type `Data.M...
04:21:35 <kmc> > join (Just (Just 3))
04:21:36 <lambdabot>   Just 3
04:21:38 <kmc> > join (Just Nothing)
04:21:39 <lambdabot>   Nothing
04:21:49 <Starfire> I didn't realize it was the normal monadic join, I thought it was a lambdabot feature.
04:21:52 <quicksilver> > join ["the hip bone"," to ","the thigh bone"]
04:21:53 <lambdabot>   "the hip bone to the thigh bone"
04:21:58 <kmc> hehe
04:22:04 <freiksenet> Starfire, kmc: tahnks
04:22:08 <freiksenet> thanks*
04:24:21 <djahandarie> Ughh, there is something really messed up with my Cabal, is there some way to debug this or something?
04:25:04 <danderson> ENODATA
04:31:51 <tibbe> djahandarie: In what way messed up? Adding -v to any command should give you some more info.
04:32:33 <djahandarie> As in, certain things are being installed, but not being picked up by ghci
04:32:51 <djahandarie> Looks like unregistering a dozen or so things and installing them again worked though
04:33:03 <djahandarie> \o/
04:33:18 <ManateeLazyCat> djahandarie: Which package?
04:33:26 <djahandarie> show
04:33:40 <djahandarie> It seems like something got messed up with my random package though
04:33:41 <ManateeLazyCat> djahandarie: Some package need trick (such as Encoding package)
04:34:09 <djahandarie> When I unregistered random (and everything that depends on it), then installed them all again, it worked.
04:34:45 <ManateeLazyCat> djahandarie: You need use "ghc-pkg chec" check
04:35:09 <ManateeLazyCat> djahandarie: Because some basic package broken will effect other package base on it.
04:35:15 <djahandarie> Oh yeah, forgot about that
04:35:27 <djahandarie> Oh well, fixed now :P
04:36:15 <ManateeLazyCat> djahandarie: Infact, you don't need unregistered all packages, you just reinstall the basic package has broken.
04:36:30 <djahandarie> I tried that, it didn't help
04:36:31 <ManateeLazyCat> djahandarie: Then all other packages base on it will fix.
04:37:49 <nostrand> shouldn't it be pretty easy to change a record type to eg. an array?
04:39:21 <ryan1918> run www.ryan1918.com
04:40:38 <djahandarie> Hm, if I have two packages that provide the same module, how do I choose which to import from?
04:41:03 <ManateeLazyCat> djahandarie: Hide one ?
04:41:35 <ManateeLazyCat> djahandarie: Or use "import qualified Foo as F" ?
04:41:53 <djahandarie> Ah yeah hiding one of the packages worked
04:42:33 <Choko> is there a way ghc would tell me whick imports is unused ?
04:42:43 <Choko> which*
04:42:58 <ManateeLazyCat> Choko: hlint
04:43:04 <ManateeLazyCat> Choko: "cabal install hlint"
04:43:16 <ManateeLazyCat> Choko: No
04:43:39 <ManateeLazyCat> Choko: Add "-fwarn-unused-matches" option with ghc
04:43:53 <Choko> ManateeLazyCat: thanks
04:44:05 <Choko> maybe I should give hlint a chance :D
04:44:09 <ManateeLazyCat> Choko: I add option "-fwarn-unused-matches -fwarn-unused-binds -fwarn-unused-imports -fwarn-duplicate-exports"
04:44:46 <ManateeLazyCat> Choko: hlint for scan you code, but don't care unsed import.
04:45:02 <ManateeLazyCat> Choko: For unsed import, you need option "-fwarn-unused-imports"
04:45:47 <ahf> hi Choko!
04:45:47 <Choko> I had guessed that :P
04:45:53 <Choko> hi ahf :D
04:45:57 <ManateeLazyCat> Choko: Sorry, typo. :)
04:46:05 <ahf> how on earth did you end up in here? :P
04:46:21 <ManateeLazyCat> Choko: Best way is add those option in your .cabal file. :)
04:46:27 <Choko> ahf: I'm writing some haskell for my master thesis
04:46:43 <ahf> oh. it's that time already
04:46:45 <ahf> good luck with it :)
04:46:53 <Choko> thanks
04:47:20 <Choko> which uni did you end at?
04:47:55 <ahf> Choko: i ended up as a coding monkey for nokia :P
04:48:01 <wvd> f (g x) is calling f with the result of g right?
04:48:04 <ahf> they got me before the universities did :o
04:48:23 <ManateeLazyCat> wvd: Yes.
04:48:37 <ManateeLazyCat> wvd: You can write (f . g) x
04:48:56 <ManateeLazyCat> wvd: To pick-up algorithm (f . g) :)
04:48:59 <wvd>  ManateeLazyCat: Yeah, but I don't fully get the dot syntax yet, that's why I'm using.
04:49:00 <wvd> So
04:49:03 <wvd> If I had like
04:49:17 <wvd> foo x = f (g x) i could use dots to shorten it to: foo = (f . g)?
04:49:24 <ManateeLazyCat> wvd: Yes.
04:49:30 <ManateeLazyCat> wvd: I recommend you install hlint.
04:49:41 <ManateeLazyCat> wvd: hlint will give much suggestion about your code.
04:49:56 <kmc> @src (.)
04:49:57 <lambdabot> (f . g) x = f (g x)
04:49:57 <lambdabot> NB: In lambdabot,  (.) = fmap
04:49:59 <wvd> ah, thanks, going to google it.
04:50:04 <ManateeLazyCat> wvd: Like "foo x = f (g x)", hlint will suggestion with "foo = f . g"
04:50:11 <Choko> ahf: nice :D
04:50:16 <ahf> yup
04:50:16 <ManateeLazyCat> wvd: Don't need google, just "cabal install hlint" :)
04:50:16 <Gracenotes> wvd: common thing to do, when you have a chain, just use - f . g . h $ v
04:50:17 <quicksilver> ManateeLazyCat: but -warn-unused-imports gets confused by qualified imports? Or did they fix that?
04:50:19 <kmc> wvd, i think it's more readable with (.) as well.  because you don't need to choose an irrelevant name "x"
04:50:30 <kmc> we like to think about functions without thinking about their arguments, when possible
04:50:31 <Gracenotes> or leave v implied, if you can
04:50:38 <ManateeLazyCat> quicksilver: I have use it long time, i think they has fix that. :)
04:50:43 <quicksilver> oh, ok.
04:50:45 <quicksilver> good!
04:50:55 <kmc> easier to say "h is the composition of f and g" than it is to say "h is the function such that, for an input x, it will return f applied to (g applied to x)"
04:51:50 <ManateeLazyCat> wvd: "foo = f . g" is better style, you don't need care argument, it's give you algorithm core. :)
04:52:42 <wvd> so foo . bar . baz is foo (bar (baz ..)))?
04:52:44 <ManateeLazyCat> wvd: For give your cleanest code, i recommend you use hlint, even you're haskell master. :)
04:52:46 <baaba> @pl \x -> f (g x)
04:52:46 <lambdabot> f . g
04:52:50 <kmc> wvd, yeah
04:52:51 <ManateeLazyCat> wvd: Yes.
04:53:00 <baaba> @pl \x -> foo (bar (baz x))
04:53:00 <lambdabot> foo . bar . baz
04:53:02 <kmc> wvd, it's not special syntax.  it's an ordinary infix operator
04:53:06 <wvd>  ManateeLazyCat: cabal is installing it :)
04:53:48 <kmc> which is right-associative and has low precedence
04:53:55 <ManateeLazyCat> wvd: If you use Emacs, install hs-hlint.el
04:54:10 <ManateeLazyCat> wvd: Then you can jump suggest code position automatically. :)
04:54:32 <wvd> ManateeLazyCat: I don't. First I'm on Windows :( and I can't get Emacs to work fine on Windows
04:56:58 <danderson> is code.h.o down?
04:57:02 <ManateeLazyCat> wvd: hlint have good interface for shell environment.
04:57:12 <danderson> oh, no, just extremely slow
04:57:27 <wvd> ManateeLazyCat: looks like the install is hanging, it's still going.
04:57:50 <ManateeLazyCat> wvd: Not hanging.
04:58:01 <ManateeLazyCat> wvd: Just have some big package need to install :)
04:58:15 <wvd> "Configuring haskell-src-exts-1.8.2..."
04:58:38 <ManateeLazyCat> wvd: Yes, that's the biggest one package... :)
04:59:22 <danderson> anyone have a mirror of the c2hs darcs repo that isn't on c.h.o ?
04:59:32 <wvd> It was downloaded in like 2 seconds, but is configuring for 10 minutes now :P
04:59:54 <Peaker> wvd, What problems do you have with Emacs on Windows?
05:00:08 <wvd> Peaker, ~/.emacs file does not work normally
05:01:16 <ManateeLazyCat> danderson: I have gtk2hs mirror, but haven't c2hs
05:01:28 <danderson> darn :(
05:01:32 <ManateeLazyCat> danderson: In gtk2hs mirror, have a c2hs branch.
05:01:44 <osfameron> istr emacs not working out of the box on some unixes, due to it liking Ctrl-S (which stops the terminal, for historical reasons :-)
05:01:52 <wvd> ManateeLazyCat: I think it actually is hanging since I'm not in the cmdline with adminstrator rights, imho restart it.
05:02:12 <danderson> meh, I wanted to hack against the c2hs head. Until c.h.o comes back I guess I'll hack in a local unpack of the latest release
05:02:15 <danderson> thanks though.
05:02:17 <ManateeLazyCat> osfameron: Do you know my multi-term.el ?
05:02:36 <osfameron> ManateeLazyCat: nah, I'm a vim user :-)
05:02:46 <osfameron> though I think we talked about it briefly here, one time
05:02:48 <ManateeLazyCat> osfameron: I consider you're emacser. :)
05:03:17 <ManateeLazyCat> osfameron: http://www.emacswiki.org/emacs/MultiTerm
05:04:01 <osfameron> I managed to get through the emacs interactive tutorial on 3rd try (previously it had annoyed me too much by a) being optimized for inexistant keys like "Meta" and b) having weird terminology like "yank" and "kill-ring" ;-)
05:04:06 * ManateeLazyCat I used to like bla bla in #emacs, now i like #haskell, i can study much knowledge at here .... 
05:04:55 * osfameron is in awe of emacs having a decent terminal emulator
05:05:14 <Peaker> wvd, You just need to find where to put it
05:05:19 <Peaker> wvd, there's the "homedir" in Windows
05:05:23 <ManateeLazyCat> osfameron: You can try http://www.emacswiki.org/emacs/MultiTerm
05:05:26 <osfameron> of course, if the terminal emulator can run vim, then you could really make emacs into a decent editor (I'll get my coat)
05:05:29 <Peaker> wvd, I think it's in ApplicationData or something like that
05:05:32 <ManateeLazyCat> osfameron: multi-term.el is base on term.el
05:05:47 <wvd> Peaker: C-x C-F /~.emacs, there you go ;)
05:05:51 <ManateeLazyCat> osfameron: term.el is best terminal emulator in Emacs, and multi-term.el make it better.
05:05:53 <wvd> C-x C-f*
05:06:23 <ManateeLazyCat> osfameron: If you interest Emacs, you can read my emacs homepage: http://www.emacswiki.org/emacs/AndyStewart
05:06:37 <ManateeLazyCat> osfameron: I think you will love auto-install.el :)
05:09:14 <ManateeLazyCat> Do you know any other template package except TH ?
05:09:30 <wvd> ManateeLazyCat, "hlint myfile.hs" should work as I expect?
05:09:52 <ManateeLazyCat> wvd: hlint --help
05:10:20 <ManateeLazyCat> wvd: I even don't use hlint with command, i use hs-lint.el that binding in my Emacs keystroke . :)
05:10:40 <wvd> "No relevant suggestions"
05:10:51 <wvd> On this file: http://codepad.org/2oVHHJ9K
05:10:53 <ManateeLazyCat> wvd: Yeah, scan next file.
05:11:35 * ManateeLazyCat I think hs-lint.el can do better, like flymake, real-time suggestion.... :)
05:11:39 <rajeshsr> what is the best way to represent the mutable infinite tape if I try to implement a BrainF*ck interpreter?
05:12:22 <wvd> ManateeLazyCat, scan next file?
05:12:53 <ManateeLazyCat> wvd: If hlint give your ""No relevant suggestions" that mean this file is perfect.
05:13:16 <ManateeLazyCat> wvd: Then use hlint with other files.
05:13:34 <wvd> ManateeLazyCat: See the codepad.. it uses parenthesis and all.
05:13:49 <ManateeLazyCat> wvd: But i recommend you use hlint with some tools that you don't need waste time on type hlint/filename command.
05:14:10 <ManateeLazyCat> wvd: I can't access codepad.org
05:14:20 * ManateeLazyCat Damn GFW.....
05:14:38 <ManateeLazyCat> wvd: Can you try paste2.org ?
05:14:47 <ManateeLazyCat> wvd: I can access paste2.org
05:15:09 * ManateeLazyCat It's sadly that live in China.
05:15:11 <wvd> http://paste2.org/p/854916
05:16:37 <ManateeLazyCat> wvd: Yes, that's mean your code is perfect, haven't suggestions :)
05:16:56 <wvd> ManateeLazyCat: What about the parenthesis :p?
05:17:19 <ManateeLazyCat> wvd: filterExpr ?
05:17:22 <mux> oh, nice! there's threadscope 0.1.2 in hackage with dependencies on cabalized gtk2hs :-)
05:17:42 <wvd> ManateeLazyCat: Also, and calcExpr
05:17:47 <wvd> erh
05:17:48 <wvd> evalExpr*
05:18:25 <ManateeLazyCat> wvd: I think your code is perfect
05:19:11 <ManateeLazyCat> mux: I think Simon have fix before gtk2hs-0.11 release. :)
05:20:35 * ManateeLazyCat Ah, my YourFreedom disconnect, i can access codepad.org now.
05:21:52 <ManateeLazyCat> bla enough, bye all. :)
05:23:38 <rajeshsr> can anyone help me get started with writing a brainf*ck interpreter in Haskell?
05:23:50 <rajeshsr> http://sabbatical-year.blogspot.com/2007/12/brainfuck-interpreter-in-haskell.html The representation used there seems too heavy!
05:24:05 <rajeshsr> any other simpler way?
05:24:38 <rajeshsr> simpler => simpler state representation and faster execution
05:24:51 <rajeshsr> am not talking about complexity of coding!
05:27:12 <ClaudiusMaximus> rajeshsr: maybe use two zippers, one for code tape one for data tape?
05:27:30 <rajeshsr> zippers? i don't know about them yet!
05:27:35 <rajeshsr> what is that?
05:29:07 <rajeshsr> ClaudiusMaximus, http://www.haskell.org/haskellwiki/Zipper is this?
05:29:11 * hackagebot bein 0.3.3 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.3.3 (FrederickRoss)
05:29:12 <ClaudiusMaximus> well, for the data tape you could have {l::[Byte],x::Byte,r::[Byte]}
05:31:11 <luite> I get "* Missing C library: xml2" while installing glade-0.11.0 from hackage, on windows. I have installed libxml2, and have made a libxml-2.0.pc file (which unfortunately wasn't supplied in the windows binary distribution), how can I find out what's wrong?
05:31:54 <ClaudiusMaximus> rajeshsr: then for the "<" instruction, you could do: dataLeft (D (l:ls) x rs) = D ls l (x:rs)
05:33:20 <djahandarie> @pl \x -> f (g x) (h x)
05:33:20 <lambdabot> liftM2 f g h
05:33:57 <djahandarie> I swear I have looked up that same thing on @pl many times before yet I never remember it
05:39:37 <wvd> I want to play some simple music and such, any recommend libaries?
05:43:36 <RyanT5000> wvd: OpenAL
05:43:57 <RyanT5000> might be a bit too heavy for your purposes, but it's quite good
05:44:08 <RyanT5000> there's ALUT which helps with initialization and such
05:44:13 <RyanT5000> both are in hackage
05:44:32 <wvd> Is it good for a beginner who's this will be it's first package use outside the standard library?
05:44:59 <Jafet> OpenAL is expressly designed for video games
05:45:13 <wvd> Yeah
05:45:15 <wvd> I know.
05:45:24 <Jafet> If you want an exercise, decode one of the popular WAV formats and push to /dev/dsp
05:45:35 <wvd> I'm on Windows :P
05:45:37 <Jafet> Unless your sound server is pissy and won't let you...
05:46:28 <luite> oh already found the problem, had to generate a libxml2.a file, using pexports and dlltool
05:49:23 <akosch> is there some sane way to see what my haskell code translate to in assembly?
05:49:49 <akosch> i've tried objdump, but my simple program gives me ~100000 lines of assembly code
05:50:12 <wvd> ghc -S?
05:50:21 <akosch> thanks, i'll check it out
05:50:27 <luite> akosch: or try the ghc-core program
05:51:27 <akosch> wow, ghc -S works great
05:51:35 <akosch> only ~800 lines
05:51:49 <akosch> wvd: thanks
05:51:57 <Botje> akosch: ghc -ddump-simpl also outputs some core
05:52:07 <wvd> akosch, np.
05:52:16 <fasta> Running it on your whole project is a bad idea :)
05:52:48 <akosch> yeah, i just want to understand haskell more
05:52:56 <akosch> try this out on some simple stuff
05:55:40 <fasta> akosch, Haskell and ghc-core have nothing to do with eachother.
05:56:15 <fasta> akosch, ghc-core is simply a formal language which GHC happens to use close before code-generation.
05:56:36 <akosch> fasta: i see
05:56:59 <Philippa> one which bears certain identifiable resemblances to Haskell, but still
05:57:06 <Philippa> (especially in its external form)
05:57:48 <Philippa> it wouldn't really be such a useful IR if it had nothing to do with it whatsoever
05:58:21 <akosch> my main problem is, that i come from a low-level world (C, Assembly)
05:58:39 <fasta> akosch, you could read SPJ's book from 1987.
05:58:50 <akosch> and only done some Python/Perl so far (those tend to hide all the complexity)
05:59:05 <fasta> akosch, that shows some kind of abstract machine that is the predecessor of how it currently works.
05:59:17 <Philippa> SPJ's book isn't necessarily a great starting point. The eval/apply paper might be better
05:59:28 <fasta> akosch, Haskell hides the complexity in the same way, AFAIK.
05:59:44 <Philippa> the reason being that there've been many substantial decisions reversed since then
05:59:45 <akosch> fasta: well not that much
05:59:55 <quicksilver> the SPJ book is still interesting, though
06:00:02 <quicksilver> as long as you remember it's not all true.
06:00:09 <akosch> :)
06:00:09 <quicksilver> much like, say, reading the newspaper.
06:00:13 <Philippa> you can't rely on a given bit of haskell translating a certain way because the optimiser does a lot of high-level work
06:00:31 <Philippa> you can inline like crazy with a language like Haskell, and that's only the starting point
06:02:15 <kmc> akosch, did you read http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
06:02:30 <akosch> kmc: not yet, but will check it out
06:02:36 <kmc> great paper
06:02:45 <kmc> basically that tells you how to write the backend of a Haskell compiler not unlike GHC
06:03:11 <akosch> hm, the abstract sounds neat...
06:03:47 <Philippa> if you understand lambda lifting you can sort-of figure out at least one possible technique for the rest
06:04:00 <Philippa> akosch: want an explanation of lambda lifting?
06:04:12 <akosch> Philippa: sure :)
06:04:33 <Philippa> okay. You know how in Haskell, functions can appear at any level of an expression?
06:04:49 <akosch> yes
06:04:52 <Philippa> Lambda lifting is the process of lifting all the lambdas/functions to named, top-level functions
06:05:07 <akosch> why?
06:05:37 <Philippa> mind if I explain what-first? You'll probably see the 'why' from what it gives you
06:05:43 <akosch> ok, sure
06:06:23 <Philippa> suppose I'm lifting the church encoding of false: \x.\y.y
06:06:39 <Philippa> that inner \y becomes \x y. y
06:07:12 <Philippa> and the outer call passes x in
06:07:22 <Philippa> bad example because really it's first-order :-)
06:07:30 <kenjin2201> I just finished reading "Learn you a haskell for great goo". And I'm not sure what I should do next.
06:07:40 <Philippa> kenjin2201: write stuff!
06:07:47 <Philippa> learn everything else as needed to write things
06:08:15 <akosch> kenjin2201: real world haskell is nice too
06:08:15 <kenjin2201> hmm...
06:08:28 <Philippa> akosch: but suppose someone used 'false' in curried style, you'd now be able to pass around a reference to 'innerfalse' and its first parameter, x
06:08:56 <Philippa> in other words, it gives you a way to (not) build closures by just partially applying your lifted functions
06:09:06 <geheimdienst> kenjin2201, start using xmonad and mess with its config file (which is haskell)
06:09:18 <Philippa> suddenly you don't need first-class functions as such any more, you just need function pointers
06:09:29 <Philippa> which is implementable easily on current hardware, right?
06:09:30 <zygoloid> > let b[]_ _=const [];b('>':c)x(y:z)=b c(y:x)z;b('<':c)(x:y)z=b c y(x:z);b('+':c)x(y:z)=b c x(y+1:z);b('-':c)x(y:z)=b c x(y-1:z);b('.':c)x(y:z)= \t->chr y:b c x(y:z) t;b('[':c)x(y:z)|y==0=b(s c)x(y:z)|True= \t->b c x(y:z)(c:t);b(']':c)x y= \(t:ts)->b ('[':t) x y ts;s('[':c)=s(s c);s(']':c)=c;s (_:c)=s c in b "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>." [] (repeat 0) []
06:09:32 <lambdabot>   "Hello World!\n"
06:09:48 <Botje> now fit it into a tweet >:)
06:09:51 <akosch> Philippa: yeah, i think i get the point
06:10:05 <zygoloid> rajeshsr: ^^ :D
06:10:38 <rajeshsr> zygoloid, is that all?! :)
06:11:06 <rajeshsr> zygoloid, do you have a commented version of that or something?
06:11:42 <zygoloid> rajeshsr: what, you can read brainfuck but not that? ;-)
06:12:24 <rajeshsr> zygoloid, haha! Definitely, sometimes point free haskell can get worse than that! ;)
06:12:27 <akosch> Philippa: my main problem with haskell for now is that i don't now what will run on the hardware
06:12:54 <Philippa> akosch: most of the time you should learn not to care and expect GHC to do a lot of rearranging behind your back
06:12:55 <akosch> Philippa: tail-call optimisation still seems like some kind of voodoo to me ;)
06:13:16 <aristid> @pl let b[]_ _=const [];b('>':c)x(y:z)=b c(y:x)z;b('<':c)(x:y)z=b c y(x:z);b('+':c)x(y:z)=b c x(y+1:z);b('-':c)x(y:z)=b c x(y-1:z);b('.':c)x(y:z)= \t->chr y:b c x(y:z) t;b('[':c)x(y:z)|y==0=b(s c)x(y:z)|True= \t->b c x(y:z)(c:t);b(']':c)x y= \(t:ts)->b ('[':t) x y ts;s('[':c)=s(s c);s(']':c)=c;s (_:c)=s c in b "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>." [] (repeat 0) []
06:13:16 <lambdabot> (line 1, column 6):
06:13:16 <lambdabot> unexpected "["
06:13:16 <lambdabot> expecting letter or digit, pattern or "="
06:13:23 <aristid> :/
06:13:25 <Philippa> heh. TCO is actually really predictable in a strict language. If GHC doesn't figure out your code is strict it doesn't do what you expect it to though
06:13:58 <zygoloid> @let b[]_ _=const [];b('>':c)x(y:z)=b c(y:x)z;b('<':c)(x:y)z=b c y(x:z);b('+':c)x(y:z)=b c x(y+1:z);b('-':c)x(y:z)=b c x(y-1:z);b('.':c)x(y:z)= \t->chr y:b c x(y:z) t;b('[':c)x(y:z)|y==0=b(s c)x(y:z)|True= \t->b c x(y:z)(c:t);b(']':c)x y= \(t:ts)->b ('[':t) x y ts;s('[':c)=s(s c);s(']':c)=c;s (_:c)=s c;bf s=s(repeat 0)(repeat 0)[]
06:13:59 <lambdabot>  <local>:16:0:
06:13:59 <lambdabot>      Multiple declarations of `L.b'
06:13:59 <lambdabot>      Declared at: <local>:...
06:14:00 <ddarius> Tail calls are a syntactic property and pretty much the same syntactic property in Scheme and Haskell.
06:14:01 <akosch> Philippa: yeah, i know it's predictable and great
06:14:07 <Philippa> you can find everything in tail position mechanically, then you just compile /all/ tail calls as a stack twiddle and jump
06:14:09 <akosch> Philippa: but don't know how it exactly works
06:14:25 <ddarius> akosch: Just evaluate your expressions by hand a few levels and the behavior will be clear.
06:14:30 <zygoloid> @let bf s=b s(repeat 0)(repeat 0)[] where b[]_ _=const [];b('>':c)x(y:z)=b c(y:x)z;b('<':c)(x:y)z=b c y(x:z);b('+':c)x(y:z)=b c x(y+1:z);b('-':c)x(y:z)=b c x(y-1:z);b('.':c)x(y:z)= \t->chr y:b c x(y:z) t;b('[':c)x(y:z)|y==0=b(s c)x(y:z)|True= \t->b c x(y:z)(c:t);b(']':c)x y= \(t:ts)->b ('[':t) x y ts;s('[':c)=s(s c);s(']':c)=c;s (_:c)=s c
06:14:31 <lambdabot>  <local>:16:7:
06:14:31 <lambdabot>      Couldn't match expected type `[Char]'
06:14:31 <lambdabot>             against...
06:14:35 <zygoloid> ;(
06:14:50 <rajeshsr> BTW, is this the right tutorial to understand State monads: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State Anything else better?
06:14:54 <Philippa> akosch: it works by "tail calls can discard the current level of the stack before filling in the next level", that's basically the entirety of it
06:15:13 <Philippa> (technically, the current 'activation record' which may not be held in a physical stack, but same difference)
06:15:15 <zygoloid> > bf "++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>."
06:15:16 <lambdabot>   "Hello World!\n"
06:15:18 <akosch> Philippa: sounds reasonable
06:16:31 <Philippa> all tail calls can do that, it's just that the typical use case is tail recursion
06:16:57 <Philippa> but you can do it with mutually recursive stuff too - in fact it's a great way to code up a state machine
06:17:14 <Philippa> you just have a function call for each state, parameterised on any data it holds
06:17:15 <akosch> Philippa: i've been doing project euler problems in haskell for fun recently (previously i've done much of the problems in python)
06:17:35 <Baughn> (However, tail calls don't really apply the way you'd expect to Haskell)
06:17:36 <akosch> Philippa: and in python i did know what to expect
06:18:00 <Baughn> rajeshsr: It looks pretty good. Implementing it yourself is the best way, of course. ;)
06:18:01 <Saizan> (they do apply, there's just something else to worry about too)
06:18:04 <Philippa> *nod*. Python really ought to have tail calls though, even if they were syntactically marked out
06:18:14 <Saizan> s/apply/apply in the same way/
06:18:44 <Baughn> rajeshsr: "A value of type State s a is a function s -> (s,a)" is the most important thing to remember.
06:18:48 <djahandarie> @pl \x -> x (`x` a) b
06:18:48 <lambdabot> flip (ap id (flip flip a)) b
06:18:53 <Philippa> I've already given the disclaimer that they do odd things in code that's not found strict :-)
06:18:53 <akosch> Philippa: for example, when using factorial of small numbers (0-9) lots of times, i did know, that python is damn slow with multiplication
06:19:11 <Philippa> heh. Haskell's performance will depend on the numeric type chosen
06:19:17 <djahandarie> @pl \a b -> f (`f` a) b
06:19:18 <lambdabot> f . flip f
06:19:20 <Philippa> Int'll be fairly fast, Integer less so as it grows
06:19:24 <akosch> Philippa: and i'm better off storing the values in a list
06:19:25 <kmc> rajeshsr, there's also "All About Monads"
06:19:26 <djahandarie> Ah that's nice
06:19:35 <kmc> i think it has some errors but good to read anyway
06:20:16 <rajeshsr> Baughn, well, i don't get the point of put function used there. How does put function help in generating a new generator?!
06:20:18 <Philippa> heh. Yes, if you can memoise it then so much the better. At least, until some idiot asks for bigNum!, at which point you end up with a heap full of big factorials that won't become garbage
06:20:18 <akosch> Philippa: C and haskell have both great performance without caching stuff in memory
06:20:34 <Baughn> rajeshsr: Think about it. What's the type of put?
06:20:45 <Philippa> it's dead easy to memoise in a list that way in Haskell though
06:21:01 <Baughn> rajeshsr: Given my last statement, what does that mean the type is if you expand the State to the function?
06:21:21 <djahandarie> Ah damn it, creates an infinite type
06:21:30 <Baughn> rajeshsr: Or maybe I'm missing something. "Generator"?
06:21:38 <akosch> Philippa: i'm not sure it's faster for small numbers :)
06:21:56 <ddarius> Why not have Python have non-tail calls syntactically marked?
06:22:26 <Philippa> probably not, you're still paying linear access costs. Tree-index it and repeat and it's probably not bad at all after 16 though
06:22:36 <rajeshsr> Baughn, the description is as if put helps in generating new states in subsequent call of get, i don't see how!
06:22:39 <HugoDaniel> hi
06:23:31 <Baughn> rajeshsr: And if I tell you that >>= for State is essentially function composition?
06:23:33 <Jafet> Guidokins doesn't want tail calling, period
06:23:37 <kmc> which docs on building GHC to use LLVM should i read?
06:23:38 <Philippa> actually managing a cache that flushes stuff in haskell is another matter. I've not looked up the right combination of unsafePerformFu myself
06:24:10 <akosch> Philippa: i can only imagine :)
06:24:40 <Baughn> rajeshsr: ..if you can /use/ State, try implementing it. It's work, but you'll figure it out, and you already know what the type signatures should be. That helps.
06:25:13 <rajeshsr> Baughn, you mean use State monads on your own?
06:25:19 <rajeshsr> any simple problem you recommend?
06:25:46 <Baughn> rajeshsr: Uh. You /can't/ use the monad?
06:25:48 <akosch> Philippa: so to get to my point... there is a large gap between my code and what runs on the hardware
06:26:12 <akosch> Philippa: in python i have developed an instinct for this
06:26:19 <Philippa> yep, there is
06:26:29 <ddarius> There's probably a larger gap with Python than with Haskell.
06:26:43 <rajeshsr> Baughn, well, i need some simple problem to use State monad, so that i understand what it is for. The motivation for my looking about it is to write a Brainf*ck interpreter..
06:26:51 <Philippa> for strict code, Haskell's surprisingly close to the machine
06:26:52 <akosch> ddarius: maybe, but i'm just beginning to grasp haskell :)
06:27:06 <Baughn> rajeshsr: It's more useful in its StateT form. Trying to avoid that..
06:27:07 <Philippa> for lazy code... yes, but it'll behave in ways that'll take you a long time to develop sufficient instinct about
06:27:52 <rajeshsr> Baughn, oh, ok! So I don't need to understand State monad?
06:28:03 <akosch> Philippa: exactly, i was wondering about foldl and foldr a while ago ;)
06:28:09 <Baughn> rajeshsr: You need to understand State before you can use StateT. ;)
06:28:22 <rajeshsr> haha! :)
06:28:45 <kmc> not strictly true but it's probably a good idea ;)
06:29:21 <Baughn> rajeshsr: I'm trying to come up with something that's neither too complex nor trivial. Er.. okay, try using it to implement the fibonacci calculation.
06:29:38 <Baughn> rajeshsr: (Of course you can do that perfectly well without State, but that's not the point.)
06:30:07 <Philippa> a calculator with let, add, constant and variable is a good one too
06:30:17 <Baughn> Yeah, but then you need input, and then you need StateT
06:30:18 <rajeshsr> Baughn, hmm! so that state abstracts 2 fibonacci numbers generating the next, right?
06:30:19 <Philippa> at least, if you're somewhat comfortable writing interpreter-like code
06:30:22 <akosch> has ghc some kind of built-in profiling?
06:30:28 <Philippa> no, you don't
06:30:35 <Philippa> it runs on an AST
06:30:37 <Baughn> rajeshsr: Use the state to carry around the two previous numbers (as a two-tuple), take N as a function parameter, and return the Nth fib number
06:30:45 <Philippa> derive Read and off you go
06:30:55 <RyanT5000> akosch: yep: see http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:31:01 <rajeshsr> Baughn, hmm, ok! lemme try
06:31:02 <rajeshsr> thanks
06:31:08 <akosch> RyanT5000: thanks
06:31:13 <RyanT5000> akosch: np
06:31:36 <RyanT5000> haskell's profiling is quite good, both CPU and heap
06:31:39 <Baughn> Philippa: You could do that. I was thinking about something more like bc - interactive, that is.
06:31:52 <Baughn> Philippa: And I consider lazy i/o of that kind to be evil. ;)
06:31:57 <RyanT5000> it's been critical to the video game my company's writing, so far
06:32:19 <RyanT5000> we have to do memory profiling a lot, since laziness makes that stuff tricky
06:32:31 <Philippa> Baughn: you can carry environments between IO and run the calculator in an IO-less monad still
06:33:02 <Baughn> Philippa: Sure, but then you have to care about the /environment/. I'd rather just do a runState $ forever.
06:33:24 <Philippa> yeah, but then you can /serialise/ the environment :-)
06:33:32 <Baughn> But I don't want to do that. :P
06:33:40 <djahandarie> @pl \x -> f ($x) ys
06:33:41 <lambdabot> flip f ys . flip id
06:33:52 <Philippa> learning that you can 'stop' a monadic computation, rip out its guts and run it again later is useful
06:34:01 <Philippa> it also gives you n-step undo trivially...
06:34:11 <Baughn> True.
06:34:35 <RyanT5000> with apologies to those of you who are in this channel frequently, it's time for me to plug my company again :)
06:34:46 <RyanT5000> we're hiring haskell programmers to work on our game
06:34:58 <Baughn> The iphone thing?
06:35:02 <RyanT5000> indeed
06:35:17 <RyanT5000> it'll also be released on Android and several other touchphone platforms
06:35:57 <koala_man> but apple doesn't allow using haskell in iphone apps
06:36:04 <Baughn> Yeah, I don't think you'll have much luck with the iphone.
06:36:15 <Baughn> You might release for cydia or something, I suppose.
06:36:19 <RyanT5000> i'm well aware of the contract provision you're referring to
06:36:54 <koala_man> how does that work then?
06:36:58 <RyanT5000> i don't actually think the provision is as clear as a lot of people in here are making it out to be
06:37:10 <RyanT5000> obviously, i've been following the story very closely
06:37:18 <kmc> hmm so Apple always had the right to deny any app for any or no reason
06:37:20 <kmc> right?
06:37:23 <RyanT5000> right
06:37:34 <RyanT5000> Unity is in a similar position, and their apps are going through in droves
06:38:06 <Philippa> you're planning to FFI to the relevant APIs, I take it?
06:38:07 <RyanT5000> they apparently had a chat with Apple; they never revealed the contents of that chat, but they're continuing to invest in their iPhone support
06:38:27 <RyanT5000> Philippa: a lot of the APIs are in Objective-C, so we use Objective-C for that
06:38:56 <RyanT5000> the basic thing is that Apple will reject us if they feel like it regardless of 3.3.1
06:39:35 <RyanT5000> and anyhow, Android is now growing faster than iPhone
06:39:42 <RyanT5000> and we'll also be targeting it
06:39:51 <RyanT5000> together with any other platform powerful enough to run our game
06:39:52 <dv-> Why not make PC games instead? :/
06:39:59 <RyanT5000> dv-: the bar for entry is enormous
06:40:16 <RyanT5000> dv-: we might try it someday, but most PC games have budgets larger than Hollywood films
06:40:31 <Philippa> or are free or cheap flash games
06:40:36 <dv-> Sure, if you want AAA xbox games
06:40:43 <Philippa> I gather cheap stuff does sell on Steam though
06:40:45 <rajeshsr> BTW, why would you define a State monad with a state transition function? Why not it be just a tuple of (State, value) ?
06:40:52 <RyanT5000> well, we're going to be the closest thing to AAA that's available on phones
06:40:56 <stroan> or fall somewhere in the middle. like defcon. polish is time consuming, on any platform
06:40:58 <RyanT5000> our game will be 40 hours long
06:41:00 <dv-> But there are enclaves of old gamers who want to see particular games made very much and don't care a lot about production values
06:41:03 <Philippa> rajeshsr: that's the result. The function is what builds that result
06:41:04 <RyanT5000> with a ton of content
06:41:09 <zygoloid> the current state of phone games seems to be pretty similar to flash games for pc
06:41:18 <RyanT5000> dv-: yeah; that's not the market we're targeting though
06:41:34 <Philippa> rajeshsr: now we have GADTs it's fairly easy to write the monad as an interpreter yielding (state, value) though
06:41:39 <dcoutts> RyanT5000: it's great that you think you'll still be able to make progress with haskell on the iphone
06:41:40 <RyanT5000> we're hoping to provide a pc/console-quality experience on phones
06:41:58 <dv-> RyanT5000: too bad
06:42:07 <RyanT5000> dv-: why's that too bad?
06:42:18 <Baughn> rajeshsr: Ask yourself how runState works
06:42:31 <dv-> RyanT5000: I'm waiting for someone to make a modern Elite :P
06:42:35 <RyanT5000> somebody's got to fill the market niche we're going after :)
06:42:37 <RyanT5000> what's Elite?
06:42:49 <eevar> dv-, ever heard of eve online?
06:42:49 <rajeshsr> Philippa, i guess it is more natural to think of stateful functions as: fun params State. So I thought (State, value) or something like that would be more intuitive!
06:43:01 <kmc> @unmtl State s a
06:43:01 <lambdabot> s -> (a, s)
06:43:05 <dv-> eevar: But that's online...
06:43:07 <RyanT5000> dcoutts: i do think so, and i fully intend to complete this project regardless
06:43:12 <rajeshsr> Baughn, takes a state, returns a new (value, state).
06:43:17 <RyanT5000> apple could change their license tomorrow
06:43:24 <kmc> rajeshsr, that's exactly how State is coded
06:43:27 <RyanT5000> they could eliminate 3.3.1, or they could ban roleplaying games
06:43:37 <Baughn> rajeshsr: Not quite. It takes an initial state, a State value, and returns a final state and value
06:43:37 <kmc> rajeshsr, that is, the type State s a is just a wrapper on s -> (a, s)
06:43:39 <Philippa> rajeshsr: where does your initial state come from?
06:43:57 <Philippa> yeah, what everyone else said
06:43:59 <RyanT5000> so it's really up to them: if they want our products on their platform, they can have them; if not, it's their loss :)
06:44:20 <Baughn> rajeshsr: You have to turn the initial state into the final one somehow, which requires some kind of function, and the only place around for a function to be is in the State value
06:45:07 <rajeshsr> Baughn, i don't get the point about initial state..
06:45:29 <RyanT5000> so, for anyone interested in getting paid to write games in haskell, let me know
06:45:32 <RyanT5000> ryan@ipwnstudios.com
06:45:42 <RyanT5000> or PM me
06:45:50 <kmc> RyanT5000, are you looking for people to start ASAP?
06:45:51 <rajeshsr> we need initial State no doubt..
06:46:01 <RyanT5000> kmc: yes
06:46:09 <RyanT5000> we'll likely be doing another round of hiring after the game comes out
06:46:10 <rajeshsr> But why does that matter with runState
06:46:30 <RyanT5000> but right now we want a couple of people to help out with finishing it
06:47:32 <kmc> rajeshsr, runState really does nothing.  since State s a is already a wrapper for s -> (a,s), that is "initial state to (result, final state)", runState just unwraps that
06:47:57 <RyanT5000> run<MonadName> functions are often like that
06:49:21 <zygoloid> RyanT5000: your website says you're looking for a release in Q1 2010 :)
06:49:28 <rajeshsr> kmc, hmm, ok. No wi get their point about initial state. The state transition function captures "initial to final state yielding a value"
06:49:33 <RyanT5000> zygoloid: haha i'll have to get that changed
06:49:46 <kmc> rajeshsr, exactly
06:49:57 <kmc> and (>>=) is just the function to glue two of these together in the obvious way
06:49:58 <zygoloid> pretty impressive to get a 25 person team together for your first game. how are you funded?
06:50:14 <RyanT5000> zygoloid: we're self-funded; mostly profit-sharing based
06:50:34 <RyanT5000> however, we do have some budget for these positions
06:50:49 <RyanT5000> we can't compete with Tsuru's 150k/year offer though :P
06:50:58 <RyanT5000> also, the team is more like 35 now
06:51:29 <kmc> i imagine the people doing Haskell in investment banking are making significantly more than Tsuru's figure
06:51:33 <dcoutts> RyanT5000: wow, I didn't realise there were that many of you, that's great.
06:51:44 <RyanT5000> dcoutts: well, we only have two dedicated programmers
06:51:47 <RyanT5000> and i do a bit of programming
06:51:55 <RyanT5000> the rest are artists, musicians, etc
06:52:00 <RyanT5000> we're doing 100% original content
06:52:02 <earthy> damn it.   %GC time      89.6%  (86.8% elapsed)
06:52:18 <djahandarie> Is there a monad version of until?
06:52:23 <RyanT5000> including about 80 different kinds of monsters, an hour and a half of music, a huge world
06:53:01 <ivanm> @hoogle until
06:53:01 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:53:03 <djahandarie> Err nevermind that wouldn't make sense
06:53:11 <earthy> (at least it runs to completion on a larger dataset...)
06:53:13 <zygoloid> dv-: you know Frontier Developments are hiring? ;-)
06:53:14 <ivanm> @hoogle while
06:53:14 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
06:53:14 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
06:53:14 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
06:53:17 <RyanT5000> but after this game comes out, we hope to put everyone on salary and hire more programmers :)
06:53:23 <ivanm> hmmm, must have been confused with something else
06:53:34 <ivanm> djahandarie: there is when, etc.
06:53:46 <dcoutts> RyanT5000: do you know of anyone else who's working on arm platforms? another organisation to share the costs of improving/maintaining ghc on arm.
06:54:00 <RyanT5000> dcoutts: unfortunately no, not yet
06:54:05 <RyanT5000> however, our costs have been very low so far
06:54:08 <RyanT5000> as we're using -via-c
06:54:25 <dcoutts> RyanT5000: iirc, the current state is you've got stuff for 6.10 but it's not ported to the mainline and the cross-compilation is not yet suitable for the mainline
06:54:38 <RyanT5000> dcoutts: that's correct
06:54:57 <RyanT5000> we haven't put any time into it after it became sufficient for our needs
06:55:16 <RyanT5000> however, we're currently seeking (in addition to the positions i was talking about before) someone to write ghc-android
06:55:29 <dcoutts> RyanT5000: it's something we (well-typed) might be able to help with, if there are enough arm users to make it worth the costs
06:55:47 <RyanT5000> dcoutts: well, i think the users may begin materializing once there's some better support
06:55:49 <RyanT5000> chicken/egg and all that
06:55:57 <dcoutts> right
06:56:00 <RyanT5000> of course i'd love to collaborate on anything we can
06:56:16 <RyanT5000> especially creating some kind of infrastructure in ghc and cabal to handle different architectures in general
06:56:39 <RyanT5000> it would be nice if i didn't have to have separate package repos for every platform
06:56:55 <RyanT5000> a more plugin-oriented architecture would be vastly preferable
06:57:08 <dcoutts> RyanT5000: right exactly, the ghc and cabal sides stuff is just what we and blackh would be good at
06:57:19 <RyanT5000> yeah
06:57:23 <ivanm> RyanT5000: for Android, are you generating native code or Java/JVM code?
06:57:34 <RyanT5000> ivanm: we'll almost certainly be generating native code
06:57:40 <RyanT5000> it seems to be both easier and better
06:57:53 <RyanT5000> however, i haven't done much research on the Java possibilities
06:58:05 <ivanm> well, I was asking because I was under the impression that with Android you _had_ to target their JVM
06:58:19 <dcoutts> RyanT5000: tricky bit is finding/justifying the funding to bring the support up to a good level, given that you've been able to make do with the so-so level of support
06:58:24 <RyanT5000> dcoutts: i think you and i and some of the core GHC people should have a talk about the future of multiplaform support
06:58:48 <RyanT5000> i agree, but multi-platform is something iPwn is very interested in
06:58:54 <earthy> okay. I'm quite flabbergasted by my program.
06:59:07 <earthy> on the order of 90% GC is *not* good.
06:59:10 <RyanT5000> we'd eventually like to hit every major smartphone OS
06:59:18 <earthy> but I cant for the life of me figure out where it's going. any tips on how to search?
06:59:20 <dcoutts> RyanT5000: nice
06:59:30 <dcoutts> earthy: space profiling?
06:59:37 <RyanT5000> and i do *not* want to have 12 *-ghc binaries lying around
06:59:44 <dcoutts> RyanT5000: indeed
06:59:46 <RyanT5000> and then to fold changes from the mainline into each one separately :P
06:59:55 <kmc> ivan, no, they support native code now
06:59:58 <RyanT5000> LLVM might help greatly with this kind of thing
07:00:05 <kmc> and don't have any bs license restrictions like Apple
07:00:18 <dcoutts> RyanT5000: you might like to join the IHG btw
07:00:23 <RyanT5000> ivanm: yeah, they added native-code support a while back
07:00:23 <kmc> i think you still have to call the native code from a Java wrapper but that can be trivial
07:00:29 <earthy> dcoutts: everything is going into 'Chunk' in an encode-to-bytestring sort of thingy (not unlike Data.Binary.Put, but I need to get offsets out and into another data structer)
07:00:29 <RyanT5000> dcoutts: i tried a while back, but i had no money
07:00:32 <RyanT5000> i still don't have enough money :P
07:00:35 <ivanm> RyanT5000: did they? cool
07:00:36 <dcoutts> :-)
07:00:46 <RyanT5000> (or rather, that's not where i'm going to put my money, yet)
07:00:50 <RyanT5000> after the game comes out, we can talk about it
07:01:01 <RyanT5000> anyway, i've got to head out
07:01:04 <RyanT5000> i'll be back in a while
07:01:04 <earthy> *structure
07:01:21 <dcoutts> RyanT5000: right, once you get some payback on this initial investment and are looking to go for all the other platforms
07:01:25 <RyanT5000> most likely continuing to flog my company and its job opportunities :)
07:01:30 <dcoutts> :-)
07:01:34 <RyanT5000> dcoutts: yes, and most languages
07:01:46 <RyanT5000> this game is going to be released *everywhere*
07:01:49 <sm> good to hear about it RyanT5000
07:01:50 <RyanT5000> and on every phone
07:01:52 <RyanT5000> :)
07:01:53 <dcoutts> coll
07:01:56 <dcoutts> erm cool
07:02:09 <soupdragon> > let kos = cos . (/180) . (*pi) in  kos 24 + kos 48 + kos 96 + kos 168
07:02:10 <lambdabot>   0.5
07:02:12 <RyanT5000> dcoutts: will you be on in an hour or so?
07:02:26 <dcoutts> RyanT5000: almost certainly
07:02:31 <soupdragon> > let ton = tan . (/180) . (*pi) in  ton 50 * ton 60 * ton 70 - ton 80
07:02:32 <lambdabot>   0.0
07:02:35 <RyanT5000> alright; perhaps we can continue our discussion then
07:02:38 <dcoutts> sure
07:02:38 <RyanT5000> if i don't fall asleep :P
07:02:46 <dcoutts> :-)
07:02:53 <RyanT5000> (i've been up for a large number of hours, as anyone looking at the logs of this chatroom can tell)
07:03:00 <earthy> what's puzzling me though is that the process takes about 1G of memory whereas the space profile only shows a max of about 70 M bytes
07:03:16 <earthy> there's a bit of a discrepancy there
07:03:21 <kmc> earthy, did you try increasing the allocation area size to decrease time spent in GC?
07:03:40 <jmcarthur> dcoutts and RyanT5000 talking to each other makes me wonder what it would be like to do part time well-typed and part time ipwn studios
07:04:13 <RyanT5000> jmcarthur: it'd be a lot like working for HIG
07:04:14 <dcoutts> jmcarthur: or working for one, and subcontracting to the other ;-)
07:04:20 <kmc> yeah this is damn cool, representatives of two Haskell companies chatting away
07:04:21 <RyanT5000> either way
07:04:24 <jmcarthur> ha
07:04:30 <RyanT5000> together we're going to build the haskell economy
07:04:33 <RyanT5000> it's going to be awesome
07:04:34 <earthy> kmc: -A8M brings GC time to 61%.
07:04:35 <kmc> there have been three job postings to haskell@ in as many weeks
07:04:40 <RyanT5000> anyway, bbl
07:04:43 <kmc> earthy, oh, i use like hundreds of MB sometimes
07:04:55 <jmcarthur> yeah there's a lot of haskell in business going on lately
07:04:57 <jmcarthur> it rocks
07:05:09 <jmcarthur> well, relative to "normal" i mean
07:05:18 <jmcarthur> RyanT5000: get some sleep
07:05:27 <earthy> kmc: yeah, I don't mind using 100s of M
07:05:44 <earthy> however, I do mind using about 100 times my inputsize.
07:05:50 <kmc> yeah
07:06:10 <earthy> especially given that there's a huge spike in my space profiles
07:06:31 <jmcarthur> the awesome thing is that all these developments of haskell infrastructure for games benefits me as well because i'd like to get into making games in haskell
07:06:35 <earthy> and I've had *some* luck CPS-transforming the code there
07:06:59 <rajeshsr> Baughn, kmc, I got lost in trying to write a StateMonad for fibonacci. I started with: getNext :: State FibState Integer
07:07:02 <rajeshsr> any help?
07:07:06 <earthy> however,I can't seem to find where I'm being too lazy.
07:07:21 <rajeshsr> i used: type FibState = (Integer, Integer)
07:07:29 <dcoutts> jmcarthur: always the tricky thing is that everyone would benefit if the infrastructure were better, but getting people to pay to improve it is hard
07:07:41 <jmcarthur> definitely
07:07:44 <erikc> indeed
07:07:55 <dcoutts> jmcarthur: that's what the IHG is an attempt to solve, it works because there are several companies with shared costs
07:08:17 <dcoutts> in the games/smartphone space, we don't yet have that level of sharing
07:08:20 <Baughn> rajeshsr: What do you have at the moment?
07:08:22 <jmcarthur> i don't know a whole lot about IHG
07:08:37 <dcoutts> jmcarthur: it's pretty much explained on the IHG website
07:08:40 <earthy> plus, the overall shape of the space profile didn't change... just the total amount of process memory needed
07:08:43 <Baughn> rajeshsr: The type of getNext is fine. So you need to get the current state, figure out the number, put the new state back then return the number, right?
07:08:44 <rajeshsr> Baughn, well, i do not really know how to complete that getNext function..
07:08:53 <rajeshsr> yep
07:09:01 <jmcarthur> ah, well there you go
07:09:05 <rajeshsr>  g@(a, b) <- get
07:09:13 <rajeshsr> is it the right way to get the state?
07:09:17 <rajeshsr> is that what it does?
07:09:54 <Baughn> rajeshsr: That works, though the g@ bit is useless in this case
07:10:00 <Baughn> You won't have any use for it
07:10:08 <jmcarthur> ah the collaborative development scheme is where i was vague on the details. now i see how it fits together
07:10:15 <rajeshsr> ha, yeah!
07:10:53 <rajeshsr> so s <- get returns only the state part? it has nothing to do with state transition function?
07:11:14 <rajeshsr> Baughn, in general x <- stateMonad returns value to x?
07:11:25 <kmc> "x <- m" runs the action 'm' and names the result 'x'
07:11:37 <kmc> in this case "get" is an action which produces the current state as its result
07:11:48 <kmc> get :: State s s
07:11:53 <kmc> get = State (\x -> (x,x))
07:11:56 <Peaker> x <- m ; rest-of-code   de-sugars to  m >>= \x -> rest-of-code
07:12:07 <kmc> meaning, "get" is a state-transformer function which "copies" the state to the result, and does not modify the state
07:12:28 <rajeshsr> kmc, hmm, yeah, seems to be getting something!
07:12:57 <Baughn> rajeshsr: get :: s -> (s,s); get s = (s,s)
07:12:58 <Baughn> Simple. ;)
07:12:59 <Peaker> rajeshsr, "x <- m" basically converts all the "rest-of-statements" in the "do" block to a "continuation" that's given as an argument to "m >>="
07:13:42 <dcoutts> jmcarthur: right, then there's also the cheaper and more casual levels of involvement. We hope to start pushing that more soon.
07:13:48 <Baughn> rajeshsr: ..which you can think of as "unpacking the monad".
07:14:25 <Baughn> rajeshsr: The monad is never actually unpacked (that's what runFoo is for), the code using x is lifted into the monad instead, but it's close enough.
07:14:32 <rajeshsr> hmm, how does "get" gets the state as the parameter? in the course of the do block?
07:14:49 <kmc> rajeshsr, "get" is a state-transformer like any other
07:15:04 <EvanR-work> its implicitly passed around the do block
07:15:18 <kmc> that is, it takes an initial state "behind the scenes" and produces a result and a final state (also "behind the scenes")
07:15:20 <EvanR-work> if you write everything in >>= then youll explicitly see it
07:15:22 <kmc> that is, the result is the only part you bind with <-
07:15:28 <rajeshsr> kmc, hmm! lemme try to write it first with do block, then without it to make full sense!
07:15:32 <Baughn> get is to state transformers as id is to functions
07:15:44 <kmc> in the case of "get", the final state, initial state, and result are all the same
07:17:47 <jmcarthur> it would be cool to be able to put bounties on things that people in the haskell community want done so that once enough bounty has been placed on it a motivated person can do it and claim the bounty. it would be good for small tasks and for people who can only contribute a small amount
07:18:09 <jmcarthur> even non-industrial things
07:18:27 <jystic> is it possible to change the default of a cabal flag based on the operating system?
07:18:36 <dcoutts> jmcarthur: one has to be quite careful with monetising things that people do for free / for the love of it
07:18:49 <dcoutts> jmcarthur: if it's not done right it can actually demotivate people
07:18:49 <jmcarthur> right. this would typically be for "boring" things
07:19:03 <jmcarthur> documentation, say
07:19:22 <arcatan> i believe that has been tried in other communities, but i have no idea if it has worked
07:19:31 <dcoutts> jmcarthur: another approach is to give more social value to those tasks
07:19:49 <dcoutts> jmcarthur: e.g. by advertising packages with good docs on hackage
07:20:00 <dcoutts> give it positive value, and make the tools easy enough to use
07:20:06 <jmcarthur> dcoutts: yeah that approach can work if you can come up with something cool enough
07:20:36 <jmcarthur> hmm, on documentation specifically, that seems to be something that a lot of people complain about. we should try to tackle this
07:20:38 <dcoutts> gwern and I previously discussed a system for wiki-like editing of haddock docs
07:20:48 <dcoutts> that's not live, but sends darcs patches to the maintainer
07:20:49 <jmcarthur> yes, haddock-wiki would be awesome
07:21:03 <dcoutts> so it's really low barrier for making small changes
07:21:14 <geheimdienst> sounds great
07:21:18 <jmcarthur> we should have a "documentation award" for projects with the most awesome documentation
07:21:31 <jmcarthur> annual or biannual maybe
07:21:58 <dcoutts> jmcarthur: I'd certainly like some semi-automatic measure of documentation "goodness" to be part of the hackage QA info that is available to users
07:22:12 <geheimdienst> the haddock wiki should under the covers make darcs patches when you click "save"
07:22:14 <rajeshsr> now i wrote getNext. Question is how am i going to use this?
07:23:32 <dcoutts> geheimdienst: exactly, though it'd have to be clear to users that their changes will not appear live but will be sent to the author for review and incorporation
07:23:42 <rajeshsr> kmc, Baughn I have this now: http://haskell.pastebin.com/t02i1qe3
07:23:48 <rajeshsr> any help?
07:24:18 <dcoutts> it can't really be live since then you have a big problem of what is the canonical source for the documentation, it really has to be the source code repo as maintained by the package author
07:24:37 <Baughn> rajeshsr: Stop thinking functionally. :P
07:24:49 <Baughn> rajeshsr: It has its place, but right now you're trying to write C code in Haskell.
07:24:50 <quicksilver> dcoutts: it can be somehow made visible as margin notes which take you to the other version.
07:24:57 <Baughn> rajeshsr: ..you /should/ be trying that, I mean.
07:25:01 <dcoutts> quicksilver: that's true
07:25:05 <geheimdienst> dcoutts, yes, absolutely
07:25:24 <quicksilver> dcoutts: probably using javscript to make the user-modified version fold into the screen in 3D whilst playing 'Dies Irae'
07:25:40 <Saizan> a comment system like RWH would also work well, i think
07:25:41 <dcoutts> quicksilver: erm, yah
07:25:47 <Baughn> rajeshsr: That said, you need to supply the initial state in runState, not getVal 1. And count /up/, not down.
07:25:49 <luite> dcoutts: can't you make a comment-like system? so that updates would appear live as comments, like the rwh paragraph comments
07:26:05 <dcoutts> Saizan: so long as the comments go somewhere and are not just ignored
07:26:11 <jmcarthur> i never read comments on documentation
07:26:21 <Baughn> rajeshsr: Or count down, if you like. getVal 0 = fmap fst . get
07:26:23 <jmcarthur> postgresql, php, etc., all get ignored
07:26:29 <Baughn> *fmap fst get
07:26:38 <geheimdienst> if you use javascript, i think just about the only server-side change you need is one url that makes a darcs patch when POSTed to
07:26:50 <quicksilver> CPAN has an annotation system which is essentially unused.
07:26:58 <dcoutts> jmcarthur: I suppose there's some benefit to letting certain users let off steam :-)
07:27:02 <rajeshsr> Baughn, hmm! i don't know how do i supply initial state..
07:27:06 <rajeshsr> isn't that by put?
07:27:07 <quicksilver> these things only work if a sensible number of sensible people actually make useful comments.
07:27:18 <quicksilver> the RWH comments were the most sensible comments I've ever seen on the internet, ever.
07:27:23 <Baughn> rajeshsr: put /updates/ the state, you can only supply an initial one via runState.
07:27:25 <jmcarthur> i think wiki-style would be superior
07:27:34 <quicksilver> in fact, I strongly suspect they were all written by dons under a variety of aliasses.
07:27:37 <rajeshsr> Baughn, oh, ok!
07:27:37 <jmcarthur> with live-update, not notes on the side
07:28:02 <jmcarthur> well, on the side would be okay i guess. just not on the *bottom*
07:28:50 <quicksilver> yeah, on the bottom is where you leave the sludge, to decay
07:28:56 <quicksilver> you don't put stuff there if you want people to read it.
07:29:03 <jmcarthur> but live-update would be nice simply because it means updated documentation goes right in, looks consistent, and would contribute to the overall quality of the documentation (aside from spammers)
07:29:03 <Saizan> well, we could do per-function what RWH did per-paragraph, it wouldn't be on the bottom :)
07:29:12 <quicksilver> I've always quite like books with margin notes, like Knuth.
07:29:13 <Olathe> Do I need both of these ? {-# RULES "take/length" take . length = takeLength #-} {-# RULES "take/length" forall xs. take (length xs) = takeLength xs #-}
07:29:19 <geheimdienst> a problem i have with the rwh comments is that pointing out a mistake doesn't lead to anything. there's like 10 people saying "hey that's wrong", but still the error stays in the text
07:29:36 <jmcarthur> whereas a large number of comments would make it apparent how much *worse* the original documentation is than it should be
07:29:46 <Twey> Olathe: I think so
07:30:00 <Twey> The one handles composition, and the other direct application.
07:30:03 <Olathe> Are there any other forms I need ?
07:30:08 <rajeshsr> Baughn, getVal N = repeat N (runState (do getNext))
07:30:36 <rajeshsr> Baughn, am i getting closer? anyway i still don't see how to give initial values!
07:30:51 <Twey> Olathe: I can't think of anything maybe length >>> take
07:30:52 <geheimdienst> so i guess comments are fine, but some mechanism for comments to feed back into the doc would be important
07:30:59 <Olathe> Ahh, OK.
07:31:01 <Olathe> Thanks :)
07:31:03 <Baughn> rajeshsr: Look at the type of runState.
07:31:05 <Twey> And fmap take length
07:31:12 <Baughn> rajeshsr: And you only call runState /once/, to give the initial value.
07:31:18 <Twey> Or whatever you're going to use, I guess.
07:31:33 <Baughn> rajeshsr: repeat N getNext might be better
07:31:51 <jmcarthur> in my opinion, the nicest system would be one which shows all modifications inline by default but allows you to toggle between that view and the original documentation
07:31:53 <Saizan> geheimdienst: that'd be the same mechanism that the offline-wiki would use, an active maintainer :)
07:32:20 <luite> geheimdienst: it might be useful to have both regular comments, and comments marked as patch. both could show up in the comments, but only the latter would be submitted
07:33:13 <jmcarthur> ooh, it would also be pretty awesome if you could upload css stylesheets in your package tarballs for the documentation
07:33:15 <Saizan> anyhow, maybe the simplest route is to go with the live-update wiki, and see if it's manageable or not
07:33:25 <jmcarthur> things like that can improve the perceived quality of the docs
07:34:00 <jmcarthur> and can give each package a unique look if it wants it
07:34:07 <jmcarthur> *if the maintainer wants it
07:34:08 <luite> jmcarthur: would that be useful?
07:34:14 <Saizan> won't all OS X people get mad about UI inconsistency?:)
07:34:16 <luite> I'm not sure if I'd like that
07:34:59 <jmcarthur> well, at the very least it would mean that you can identify which docs you have open at a glance
07:35:02 <luite> and I don't even use OS X :)
07:35:18 <gwern> @remember quicksilver probably using javscript to make the user-modified version fold into the screen in 3D whilst playing 'Dies Irae'
07:35:19 <lambdabot> Done.
07:35:38 <jmcarthur> but a bit more important is that it can make a project look more polished, which can be very attractive to new people
07:35:53 <gwern> quicksilver: I can assure you, dons did not write my RWH comments
07:36:05 <luite> hmm, wouldn't it be better to improve the default stylesheets then?
07:36:55 <jmcarthur> sure, but the uniqueness is part of the appeal
07:36:57 <luite> usually when programmers try to make something look unique, they only uglify it :)
07:37:01 <jmcarthur> i'm not going to argue for it too strongly though
07:37:17 <rajeshsr> Baughn,  getVal _ = fst (runState (do getNext) (0,1))
07:37:25 <rajeshsr> just to get the first value..
07:38:14 * Saizan registers hackage-look.org
07:38:22 <luite> hehe
07:38:59 * quicksilver starts to write a firefox plugin to override custom CSS on hackage.haskell.org
07:39:07 <quicksilver> HackageCleaner.ext
07:39:21 * geheimdienst wuld likey if on the haddock page, you could hit a button to make the top  of the screen a tryhaskell.org textfield
07:39:35 <jkingkong> do Data.Maps discard elements with values of Nothing?
07:39:53 <kmc> jkingkong, no
07:40:07 <jkingkong> I see an updateWithKey function that behaves this way, but is there a way to do this with unions and intersections and such
07:40:17 <voker57> why would they
07:40:17 <kmc> nothing special happens if the value type is (Maybe T) for some T
07:40:23 <jkingkong> the update function does it too
07:40:35 <jkingkong> OK fair enough
07:40:39 <jkingkong> but say I wanted it to
07:40:57 <kmc> jkingkong, if you had a value type (Maybe T), then you'd get an extra layer of Maybe in those functions
07:41:01 <rajeshsr> Baughn, seems to work. Now i have to see how i will have to write getNext N. I seem to get nowhere. replicateM_ will help?
07:41:16 <rajeshsr> but how do i supply initial state?
07:41:21 <jkingkong> kmc: really?
07:41:34 <jkingkong> :t update
07:41:35 <lambdabot> Not in scope: `update'
07:41:39 <Saizan> ?hoogle updateWithKey
07:41:39 <lambdabot> Data.IntMap updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:41:40 <lambdabot> Data.Map updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
07:41:47 <djwonk> `cabal install hoogle` fails with: Could not find module `Data.Generics.Uniplate'
07:41:59 <djwonk> this is a fresh install of the latest haskell platform on Snow Leopard
07:41:59 <jkingkong> ah you're right
07:42:08 <jkingkong> I do get an extra layer of Maybes
07:42:12 <jkingkong> rats
07:42:52 <Saizan> the function you pass to updateWithKey returns 'Maybe a' where the element type is 'a'
07:43:12 * djwonk is running ghc-pkg check -v
07:43:29 <djwonk> it says I'm using a few caches, I'm going to delete those
07:43:30 <jkingkong> yea I see, so it'd make a Maybe (Maybe a)
07:43:49 <jkingkong> so maybe I shouldn't wrap the values
07:44:01 <jkingkong> and instead, just use folds everywhere with the update function
07:44:13 <jkingkong> as opposed to the nicer unions and intersections
07:44:29 <jkingkong> that is unfortunate
07:45:20 <kmc> i'm confused as to what you're trying to do
07:45:42 <kmc> you could operate on Map k (Maybe v), then go through and remove all the Nothing values
07:46:08 <rajeshsr> Baughn, kmc did it! :)  getVal n = (runState (do replicateM n getNext) (0,1))
07:47:14 <mreh> can't you avoid reconstruction of data constructors by using the as pattern?
07:47:21 <mreh> 'as' pattern*
07:47:59 <jmcarthur> jkingkong: there's no reason to fear Maybe (Maybe a)
07:48:07 * djwonk just cleaned out old stuff from ~/.ghc
07:48:09 <mreh> I suppose it costs to break apart a constructor twice
07:48:13 <rajeshsr> kmc, Baughn thanks! it was a good experience! But, have to digest a lot of new things now! Lemme take time to think of this approach. Thanks a lot for your help
07:48:25 <rajeshsr> @src replicateM
07:48:25 <lambdabot> replicateM n x = sequence (replicate n x)
07:48:27 <kmc> hmm
07:48:32 <djwonk> YAY, that was it
07:48:35 <kmc> should Data.Map have a function that combines "map" and "alter"?
07:48:42 <rajeshsr> @src sequence
07:48:42 <lambdabot> sequence []     = return []
07:48:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:48:42 <lambdabot> --OR
07:48:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:49:32 <aristid> @src sequence_
07:49:32 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:49:46 <jkingkong> jmcarthur well, getting the "a" seems like a bother
07:49:55 <aristid> :t sequence_
07:49:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:49:56 <jkingkong> and won't it run poorly?
07:50:15 <aristid> :t (>>)
07:50:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:50:53 <jkingkong> kmc: I'd like to take the union of two sets, but delete elements if they combine in a way that cancels their values
07:51:07 <rajeshsr> seems i don't need a "do" for: replicateM n getNext ingetVal n = (runState (replicateM n getNext) (-1,1))
07:51:23 <rajeshsr> do expr means just expr?
07:51:35 <kmc> rajeshsr, yeah
07:51:36 <jmcarthur> :t unionWith
07:51:37 <lambdabot> Not in scope: `unionWith'
07:51:43 <jmcarthur> :t M.unionWith
07:51:45 <jkingkong> hoogle? unionWith
07:51:45 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
07:51:49 <rajeshsr> hmm, thanks
07:52:01 <jmcarthur> not it
07:52:05 <jkingkong> nope
07:52:13 <jmcarthur> i don't have Map memorized
07:52:14 <rajeshsr> @src seq
07:52:14 <lambdabot> Source not found. You speak an infinite deal of nothing
07:52:16 * jmcarthur looks
07:52:22 <kmc> :t M.mapMaybe
07:52:23 <lambdabot> forall a b k. (Ord k) => (a -> Maybe b) -> M.Map k a -> M.Map k b
07:52:28 <kmc> that's the one i was looking for
07:52:31 <jmcarthur> aha
07:52:32 <kmc> :t M.mapMaybe id
07:52:33 <lambdabot> forall b k. (Ord k) => M.Map k (Maybe b) -> M.Map k b
07:52:37 <jkingkong> mmm yes mapMaybe
07:52:55 <jkingkong> I can probably write unionMaybe and intersectMaybe then as well
07:52:58 <jkingkong> using that
07:53:16 <kmc> maybe not efficiently
07:53:28 <jkingkong> @src M.update
07:53:28 <lambdabot> Source not found.
07:53:35 <jkingkong> yea mmm
07:53:43 <kmc> :t \k -> join . M.lookup k
07:53:44 <lambdabot> forall a k. (Ord k) => k -> M.Map k (Maybe a) -> Maybe a
07:53:57 <aristid> :t M.mapMaybe Just
07:53:58 <lambdabot> forall a k. (Ord k) => M.Map k a -> M.Map k a
07:54:00 <jmcarthur> it's times like these that i wish we had conal's proposed semantics for Map
07:54:11 <kmc> jmcarthur, which are?
07:54:20 <Botje> a free pony for every haskell hacker!
07:54:43 <sm> hurrah!!
07:54:51 <Olathe> Why is splitAt n xs = (take n xs, drop n xs) faster and less memory hogging than splitAt 0 xs = ([], xs); splitAt n (x:xs) = let (as, bs) = splitAt (n - 1) xs in (x:as, bs) ?
07:55:54 <jmcarthur> well, it actually wouldn't help in this case. i was thinking wrong
07:56:00 <Olathe> I use it in (\(a, b) -> (last a, head b, last b)) . splitAt 100 $ [1..10000000]
07:56:40 <jmcarthur> but basically Map treats the values as being wrapped in Last when doing things like union and stuff, and conal suggested generalizing it to other type constructors
07:57:15 <jkingkong> Olathe: hmm well the latter implementation is going to produce a longbunch of nested thunks
07:57:15 <jmcarthur> that is, we currently have something like this (not perfectly):  k -> Last a
07:57:16 <kmc> other monoids?
07:57:18 <jmcarthur> yeah
07:57:32 <Olathe> jkingkong: Is there any way to avoid that ?
07:57:38 <jkingkong> Olathe: that will need to be made and the evaluated from the inside out
07:58:20 <jmcarthur> it could still help in this case because unionWith could just return mempty to "delete" a value
07:58:27 <jkingkong> Olathe: hmm use the optimized take and drop functions?
07:58:35 <jmcarthur> it just wouldn't necessarily do the right using just union
07:58:48 <jmcarthur> *the right thing
07:58:55 <jkingkong> yea that is the trouble
07:59:15 <jkingkong> @src M.union
07:59:15 <lambdabot> Source not found. Are you on drugs?
07:59:19 <jkingkong> sign
07:59:20 <jkingkong> sigh
07:59:25 <jkingkong> no, I'm not on drugs
07:59:56 <Saizan> Olathe: which part of the resulting tuple are you consuming first?
07:59:56 <scree> @src Data.Map.union
07:59:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:00:19 <Olathe> Saizan: last as
08:00:33 <jkingkong> Olathe you should be doing a fold I think instead
08:00:42 <jkingkong> Olathe: http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter might be relevant
08:00:46 <Olathe> Saizan: I use it in print . (\(a, b) -> (last a, head b, last b)) . splitAt 100 $ [1..10000000]
08:01:10 <Saizan> Olathe: compiling with -O2 ?
08:01:53 <Olathe> Saizan: Yeah.
08:02:01 <Olathe> jkingkong: Ahh, OK.
08:02:09 <jmcarthur> :t \f a b -> M.differenceWith f a b `mappend` b
08:02:10 <lambdabot> forall b k. (Ord k) => (b -> b -> Maybe b) -> M.Map k b -> M.Map k b -> M.Map k b
08:02:29 <jmcarthur> it's not the most efficient way to do it for sure, but it's still O(m+n) i think
08:02:36 * Saizan doesn't think a foldl' would help.
08:02:54 <Saizan> that'd recurse over the whole input list before returning any result.
08:03:08 <jkingkong> jmcarthur: hmm that's a possibility
08:03:40 <jkingkong> ?hoogle mappend
08:03:40 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
08:03:58 <jmcarthur> jkingkong: mappend = union, in this case
08:04:33 <jkingkong> jmcarthur: i see, sorry I don't know the Data.Monoid module at all, I'm reading about it now
08:04:38 <jmcarthur> oh it's wrong though, woops
08:04:53 <jkingkong> haha np
08:04:53 <jmcarthur> probably want this:   \f a b -> b `mappend` M.differenceWith f a b
08:05:03 <jmcarthur> dang
08:05:06 <earthy> hm. bangpatterns made the behaviour *worse*...
08:05:06 <jmcarthur> it's wrong either way
08:05:11 <jmcarthur> ignore me :)
08:05:15 <sioraiocht> @seen dcoutts
08:05:15 <lambdabot> Unknown command, try @list
08:05:22 <sioraiocht> @list
08:05:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:05:22 <akosch> how would you go about implementing a lazy list for the digits of e (mathematical constant)?
08:05:32 <jkingkong> jmcarthur well writing a Union with a difference function has gotta be hard
08:05:33 <jmcarthur> there does not seem to be a great way to do it efficiently
08:05:39 <akosch> infinite list of course :)
08:05:42 <sioraiocht> @seen dcouts_
08:05:42 <lambdabot> Unknown command, try @list
08:05:45 <sioraiocht> please? =p
08:05:52 <earthy> akosch: look into the exact real arithmetic package
08:05:53 <sioraiocht> dcoutts: ping =p
08:05:56 <Olathe> akosch: I'd use CMath.
08:05:58 <jmcarthur> nah, i bet it's not too hard to fit into the existing Data.Map
08:06:06 <jkingkong> well, there's certainly a better way than just filtering out all the bad elements afterwards
08:06:07 <Olathe> CReal, I mean
08:06:12 <soupdragon> akosch, long division
08:06:18 <jmcarthur> maybe not in the exposed interface though
08:06:31 <soupdragon> :t factorial
08:06:32 <lambdabot> forall t. (Num t, Enum t) => t -> t
08:06:50 <earthy> http://users.info.unicaen.fr/~karczma/arpap/lazypi.ps.gz  shows pi... ;)
08:06:57 <dcoutts> sioraiocht: pong
08:07:13 <HugoDaniel> http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/ :D
08:07:15 <jmcarthur> wow, i do not understand the intel concurrent collections package at all. i'll have to read those docs on intel.com
08:07:17 <soupdragon> > 1/factorial 0 + 1/factorial 1 + 1/factorial 2 + 1/factorial 3 + 1/factorial 4 + 1/factorial 5 + 1/factorial 7 + 1/factorial 8 + 1/factorial 9 + 1/factorial 10
08:07:19 <lambdabot>   2.7168929122574954
08:07:24 <scree> Olathe: of course, you have the problem with the accumulating parameter that you won't get back any of (take n xs) until you've found all of them
08:07:25 <soupdragon> akosch, see this ^
08:07:26 <RyanT5000> jmcarthur: sleep is for the weak - i've got people in the office to attend to now!
08:07:42 <Olathe> scree: Ahh :(
08:07:52 <soupdragon> akosch, you can bound the error of this to know how many terms ti takes to define the first n decimal places
08:07:56 <scree> Olathe: it's a "have your cake and eat it question"
08:08:16 <akosch> soupdragon: hm, sounds good
08:08:17 <scree> s/ question"/" question
08:08:32 <jkingkong> akosch yup taylor expanding e^x
08:08:53 <Olathe> I can't get it to go any faster than (take n xs, drop n xs), so I'll stick with that :)
08:09:10 <soupdragon> :t divMod
08:09:11 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:09:21 <soupdragon> :t unfoldr
08:09:22 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:09:35 <akosch> there is also a continued fraction for approximating e, isn't there?
08:09:46 <soupdragon> > unfoldr (Just . flip divMod 17) 1
08:09:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:09:51 <soupdragon> > unfoldr (Just . divMod 17) 1
08:09:52 <lambdabot>   [17*Exception: divide by zero
08:09:57 <scree> actually...
08:10:00 <soupdragon> > unfoldr (Just . divMod 17) 10
08:10:01 <lambdabot>   [1,2,5,8,17*Exception: divide by zero
08:10:07 <soupdragon> > unfoldr (Just . flip divMod 17) 10
08:10:08 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:10:09 <wli> Olathe: Not even with splitAt?
08:10:20 <soupdragon> @let swap (x,y) = (y,x)
08:10:21 <lambdabot>  Defined.
08:10:27 <soupdragon> > unfoldr (Just . swap . divMod 17) 1
08:10:28 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:10:31 <soupdragon> > unfoldr (Just . swap . flip divMod 17) 1
08:10:32 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:10:42 <Olathe> wli: I'm trying to see if splitAt can be sped up.
08:10:56 <RyanT5000> soupdragon: programming by exhaustive search?
08:10:58 <Olathe> wli: It seems pretty well optimized, though.
08:11:05 <RyanT5000> :)
08:11:05 <Botje> Olathe: splitAt is pretty fast. why do you need to speed it up?
08:11:06 <Twey> Haha
08:11:18 <Twey> @src splitAt
08:11:18 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:11:23 <Twey> Hm
08:11:41 <jkingkong> lawl
08:11:47 * jmcarthur wonders how splitAt could be sped up at all
08:11:50 <Twey> I doubt that's the real implementation
08:12:01 <Olathe> Botje: I'm actually making tailSplitAt, but it has the same sort of characteristics as splitAt.
08:12:11 <Botje> you're taking chunks off the tail?
08:12:34 <Botje> why not reverse and use splitat?
08:12:50 <jmcarthur> :t tailSplitAt
08:12:51 <lambdabot> Not in scope: `tailSplitAt'
08:12:53 <Olathe> Botje: I can try that, but I'm not sure it will be very fast.
08:12:53 <soupdragon> > unfoldr (Just . flip divMod 17 . (*10)) 10
08:12:54 <lambdabot>   [5,8,8,2,3,5,2,9,4,1,1,7,6,4,7,0,5,8,8,2,3,5,2,9,4,1,1,7,6,4,7,0,5,8,8,2,3,...
08:13:07 <soupdragon> akosch, that's long division ^
08:13:11 <jmcarthur> what is tailSplitAt?
08:13:13 <soupdragon> > 1/17 :: CReal
08:13:14 <lambdabot>   0.0588235294117647058823529411764705882353
08:13:15 <jmcarthur> counting from the end?
08:13:24 <Botje> Olathe: I think it will
08:13:32 <Botje> especially if you only do the "big" reverse once
08:14:12 <Botje> O(n-100 + n-200 + n-300 + n-400) vs O(n+100+100+100+100)
08:15:09 <Botje> also, you can then reuse your big reversed list between runs, instead of constructing a new one everytime
08:15:18 <jmcarthur> yeah splitAt is actually a ton of code in Data.List, not that simple (take n xs, drop n xs) implementation that lambdabot reports
08:15:47 <jmcarthur> honestly it's so low-level that it kind of annoys me
08:16:33 <Saizan> i don't see any substantial performance difference in this benchmark between the various implementations though.
08:16:51 <Saizan> ghc-6.12.1 on x86_64
08:18:15 <rothwell> 'lo. quick question: is there a simple way to just get 'show' (or something like it) to print only the 'value' and not the enclosing type/constructor? i've been using Data.List.words, etc, to chop off the value but this obviously won't work when the input is something like "Some_Rational ((-1) % 1)"
08:18:31 <rothwell> i don't intend to ever 'read' back the result
08:20:25 <Olathe> This is the fastest tailSplitAt implementation I've gotten so far: http://codepad.org/cOcJbeKj
08:21:27 <Olathe> Using reverse is a bit slower.
08:21:32 <dv-> rothwell: showValue = show . fromType ?
08:22:31 <jkingkong> :t fromType
08:22:32 <lambdabot> Not in scope: `fromType'
08:22:39 <jkingkong> ?hoogle fromType
08:22:39 <lambdabot> No results found
08:22:49 <dv-> Well, you'd have to define it
08:22:52 <kmc> rothwell, for a type you define?
08:23:00 <dv-> fromType (Constructor value) = value
08:23:02 <kmc> rothwell, you can make your own show instance
08:23:05 <rothwell> sorry, wasn't paying attention
08:23:13 <rothwell> for any (Num a) => a, unfortunately
08:23:15 <kmc> instance Show Foo where { show (Bar x) = show x }
08:23:16 <jkingkong> dv-: haha yea I didn't think it was around
08:23:18 <kmc> oh
08:23:24 <kmc> rothwell, no, can't be done in general
08:23:28 <rothwell> didn't think so
08:23:37 <kmc> you have no guarantee about the format of the string the existing Show instance produces
08:23:57 <kmc> you could use serious tricks and hax
08:24:01 <rothwell> hehe
08:24:02 <kmc> like inspecting the closure with vacuum
08:24:23 <rothwell> no, only practical problem here is that error messages this code prints might be somewhat ugly
08:24:33 <rothwell> if the input value is heavily... wrapped
08:24:42 <rothwell> 'Test_Asserted3_Base ((-1) % 1)'
08:24:53 <rothwell> slightly tiresome to read over and over
08:24:56 <kmc> yeah
08:25:12 <kmc> sounds like an ad-hoc problem deserving an ad-hoc solution ;P
08:25:23 <rothwell> heh
08:25:36 <Botje> Olathe: it sounds like really ass-backwards function, you're copying almost the entire list every time
08:25:53 <Botje> Olathe: what are you using tailSplitAt for ?
08:48:35 <Olathe> Botje: I'm actually using tailDropWhile, but I thought I'd go ahead and learn some more by making other tail___ functions.
08:49:20 <Olathe> Botje: I'm using tailDropWhile to drop off memory writes and reads from the end of a program.
08:49:53 <Botje> Olathe: perhaps you should look into datastructures that efficiently support taking data from either end
08:50:01 <Botje> like Data.Sequence
08:52:17 <quicksilver> depends if Olathe's aim is to be efficient, or just to learn stuff.
08:55:28 <jmcarthur> Olathe: so you are using a list as a queue-like structure?
08:55:59 <Olathe> I'm using it mostly as a stack, except for the one optimization on the programs (throwing things away at the end).
08:56:18 <jmcarthur> "at the end" means the tail, right?
08:56:25 <Olathe> Yeah.
08:56:32 <jmcarthur> sounds like a queue-like structure to me ;)
08:56:48 <Olathe> Ahh :)
08:56:58 <jmcarthur> Data.Sequence would be worth looking at
08:57:05 <Olathe> I might.
08:57:17 <Olathe> Is there a way to do nice pattern matching with them, like with lists ?
08:57:29 <jmcarthur> it has higher constant factors, but it has better algorithmic complexity
08:57:34 <kmc> Olathe, not as nice
08:57:36 <jmcarthur> well, you can get views of the head and tail
08:57:43 <jmcarthur> which you can then pattern match on
08:57:54 <jmcarthur> but no, not as nice overall for that kind of thing
08:58:37 <kmc> the GHC extension ViewPatterns makes that a bit nicer, arguably
08:59:04 <kmc> it's still not as nice as lists
08:59:05 <Squarism> what fields are haskell strong in? As what type applications is it typically used for?
08:59:22 <kmc> Squarism, implementation of domain-specific languages
08:59:22 <jmcarthur> ViewPatterns could have been done so much more nicely
08:59:26 <geheimdienst> well, window managers
08:59:27 <geheimdienst> ;-)
08:59:41 <jmcarthur> Squarism: i use haskell for almost everything
08:59:42 <kmc> Squarism, for things like hardware design, financial products modeling, embedded systems programming, etc.
08:59:44 <Olathe> Compilers
08:59:55 <kmc> Facebook uses Haskell to refactor PHP code
09:00:07 <jmcarthur> parallelism and concurrency
09:00:07 <Squarism> kmc: lol.. sounds wierd
09:00:13 <jmcarthur> weird?
09:00:14 <Olathe> It's very nice for dealing with anything symbolic.
09:00:24 <kmc> yeah, it's great if you want to use multiple cores without bullshit
09:00:32 <kmc> e.g. without spawning and managing threads
09:00:39 <geheimdienst> olathe, it's very nice for dealing with anything
09:00:48 <Squarism> are they replacing php with haskell or use haskell to test changes?
09:00:59 <Olathe> Well, yes, but compared to most other languages, it's very nice for that.
09:01:01 <kmc> most languages are completely lacking this distinct between parallel evaluation and concurrent execution
09:01:02 <jmcarthur> they use haskell to generate php, i think
09:01:10 <Squarism> aha
09:01:21 <kmc> Squarism, they write Haskell programs which walk over their giant crufty PHP codebase and make improvements
09:01:25 <RyanT5000> squarism: i use Haskell to make video games - as part of my company, iPwn Studios; look us up (ipwnstudios.com)
09:01:33 <RyanT5000> :)
09:01:35 <Squarism> jmcarthyur: ah.. sounds fair..
09:01:42 <kmc> Squarism, http://haskell.org/haskellwiki/Haskell_in_industry
09:02:09 <Squarism> ive allways shrugged when hearing facebook uses PHP heavily
09:02:18 <Squarism> such an error prone language
09:02:23 <kmc> they also recently announced a PHP compiler
09:02:28 <kmc> but their compiler is written in C, not Haskell :/
09:02:31 <jmcarthur> facebook uses a lot of languages
09:02:37 <jmcarthur> they also use erlang for a few things
09:02:41 <kmc> yeah
09:02:42 <Squarism> if they merely generate php its more understandable
09:02:52 <kmc> they have a cross-language network IPC layer
09:03:06 <Squarism> RyanT5000: Will check right away
09:03:11 <kmc> which is used to interface frontend web code to various services
09:04:22 <kmc> i worked somewhere that used both PHP and Ruby on Rails
09:04:27 <kmc> for both web and backend stuff
09:04:32 <kmc> was quite odd
09:04:42 <Squarism> RyanT5000: An MMORPG?
09:05:54 <jmcarthur> just an RPG
09:06:04 <jmcarthur> "just"
09:06:21 <jmcarthur> RPGs are a lot of work!
09:06:54 <jmcarthur> Squarism: here's a cool new haskell web framework http://snapframework.com/
09:06:56 <Squarism> inventory, map, stats, done!
09:07:00 <Squarism> =D
09:07:17 <jmcarthur> Squarism: sure, the code isn't too bad, but the art...
09:07:22 <jmcarthur> so much art
09:07:32 <RyanT5000> Squarism: yep, just a normal, single-player RPG
09:07:48 <RyanT5000> yup; we've had about 15 artists working for about a year :)
09:08:03 <RyanT5000> not all of them are full-time, but it's still a lot
09:08:47 <RyanT5000> and we have a full-time writer; storyline's very important
09:09:05 <RyanT5000> (though we're mindful not to force it on the player, either)
09:09:10 <Squarism> jmcarthur: wicket.apache.org <-- the coolest imho
09:10:10 <RyanT5000> is snap a rebrand of HAppStack
09:10:11 <RyanT5000> ?
09:10:44 <rajeshsr> > [1,2,3] ++ [4]
09:10:45 <lambdabot>   [1,2,3,4]
09:10:52 <kmc> RyanT5000, don't think so
09:10:53 <rajeshsr> is this O(1) ?
09:11:08 <soupdragon> yes
09:11:20 <kmc> rajeshsr, it will walk to the end of the first list
09:11:29 <kmc> and duplicate each cons cell in that list
09:11:30 <c_wraith> RyanT5000, Snap is somewhat based on happstack, but it's not the same thing
09:11:32 <kmc> but not the second
09:11:40 <rajeshsr> kmc, yeah thats the reason am asking..
09:11:51 <rajeshsr> is there anyway to make appending an element O(1) ?
09:12:00 <kmc> a single element is O(1)
09:12:09 <c_wraith> Not with standard lists.  You'll need a different structure
09:12:09 <rajeshsr> consing to the front is O(1) with :, right?
09:12:14 <jmcarthur> RyanT5000: the Snap monad borrows a lot from it, but it's all new stuff
09:12:15 <fasta> rajeshsr, use a different data structure.
09:12:15 <Saizan> you can use the good old ShowS trick
09:12:25 <Saizan> rajeshsr: yes (:) is O(1)
09:12:26 <kmc> rajeshsr, yes
09:12:27 <rajeshsr> > (4:[1,2,3])
09:12:28 <lambdabot>   [4,1,2,3]
09:12:32 <rajeshsr> thats O(1)
09:12:35 <rajeshsr> hmm
09:12:55 <fasta> If you have [1...n] and you want to append something you cannot do that in O(1).
09:13:01 <kmc> if you want a data structure with fast concatenation, you'll need something fancier like Data.Sequence or dlist
09:13:17 <Squarism> RyanT5000: Id like to see someone implement an MMORPG that implement NPC as autonomous "threads" or what ever they are called in Haskell.. (as beeing strong on concurrency)
09:13:21 <rajeshsr> kmc, oh, ok! thanks
09:13:41 <RyanT5000> Squarism: you should look up Functional Reactive Programming
09:13:45 <RyanT5000> that's another very interesting approach
09:13:58 <RyanT5000> not explicitly parallel, but, then, explicit parallelism is difficult to manage anyway
09:14:02 <Squarism> RyanT5000: ..Well would work for singleplayer too I guess
09:14:03 <kmc> lists are simple and maximally lazy.  in a sense they are more like control flow structures than data structures
09:14:12 <RyanT5000> the real power is in implicit parallelism
09:14:46 <EvanR-work> is it appropriate to document otherwise type ambiguous javascript with haskell style type annotations
09:15:08 <c_wraith> EvanR-work, It is if your readers can handle it.
09:15:20 <EvanR-work> my current readers can because we use haskell too
09:15:35 <EvanR-work> but i dont know about far future employees
09:15:40 <kmc> screw those guys ;)
09:15:59 <kmc> EvanR-work, it seems reasonable, but since it is just a comment, it'd have the same problem as other comments, namely getting to be wrong or out-of-date
09:16:02 <jmcarthur> i think of frp as a subset concurrency
09:16:37 <rajeshsr> > last [1..10]
09:16:38 <lambdabot>   10
09:17:03 <rajeshsr> @hoogle [a] -> [a]
09:17:03 <lambdabot> Prelude cycle :: [a] -> [a]
09:17:03 <lambdabot> Prelude init :: [a] -> [a]
09:17:03 <lambdabot> Prelude reverse :: [a] -> [a]
09:17:03 <jmcarthur> and i've been calling it "denotative continuous-time programming" (dctp) instead of frp
09:17:13 <rajeshsr> > init [1..10]
09:17:14 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:17:16 <jmcarthur> RyanT5000: so if you ever see me mention DCTP, now you know what i mean ^^
09:17:18 <EvanR-work> kmc: i have noticed a problem remembering or discovering what the fuck the javascript expects/returns
09:17:22 <EvanR-work> ever since using haskell ;)
09:17:39 <kmc> yeah
09:17:41 <rajeshsr> any function that combines init and last?
09:17:56 <rajeshsr> returning as a tuple may be..
09:18:02 <kmc> rajeshsr, you can use "reverse" and pattern match on the result
09:18:09 <RyanT5000> i think people focus too much on time when they think about reactive programming
09:18:29 <kmc> hmm but the rest would be in the wrong order
09:18:31 <RyanT5000> i'd prefer a design that operates on any poset
09:18:39 <RyanT5000> but maybe that's just me :)
09:18:40 <jmcarthur> RyanT5000: agreed, but i think "continuous-time" captures the idea better than "reactive"
09:18:40 <rajeshsr> kmc, hmm, ok. Thats too much of work! lemme me call them separately! :)
09:18:51 <jmcarthur> agreed on "too much focus on time," that is
09:19:08 <jmcarthur> the whole point is that you *don't* have to think about time so much
09:19:15 <kmc> EvanR-work, one thing a lot of dynamically typed languages are missing is a lightweight way to insert preemptive runtime type checks
09:19:29 <kmc> i'm not sure why
09:19:49 <RyanT5000> jmcarthur: yeah
09:19:54 <wvd> Is it even worth using a parser generator in Haskell? With pattern-matching and such I could see a hand-written parser work very well.
09:20:00 <monochrom> because of ideologies
09:20:13 <RyanT5000> wvd: parser generators can make things absurdly easy
09:20:23 <rajeshsr> @hoogle Int -> Char
09:20:23 <EvanR-work> assert(typeof foo == "bar") :(
09:20:24 <lambdabot> Data.Char chr :: Int -> Char
09:20:24 <lambdabot> Data.Char intToDigit :: Int -> Char
09:20:24 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
09:20:35 <rajeshsr> > chr 97
09:20:36 <lambdabot>   'a'
09:20:52 <jmcarthur> RyanT5000: my library isn't so concerned with time specifically, but i'll be exposing an api that gives it that treatment anyway. i'll probably also expose a polymorphic version in a set of ".Internal" modules
09:21:33 <RyanT5000> jmcarthur: bonus points if you can handle time dimensions un-specially, instead of just being polymorphic on them :)
09:21:42 <RyanT5000> or at least handle multiple time dimensions :P
09:21:50 <jmcarthur> time dimensions?
09:21:53 <RyanT5000> (perhaps at this point i'm just being difficult :P)
09:21:55 <RyanT5000> yeah like
09:22:06 <RyanT5000> parameterize over two different "time" ideas
09:22:34 <RyanT5000> "time" is just a Signal with a poset as its type and which is "nondecreasing" in some reasonable interpretation of the circuit, right?
09:22:50 <RyanT5000> (or possibly strictly increasing)
09:22:53 <jmcarthur> from a certain point of view, sure
09:23:17 <RyanT5000> i'm just reducing to absurdity at this point; don't mind me :)
09:23:33 <RyanT5000> i'll be very interested to see your FRP when you're ready to show it off
09:23:52 <RyanT5000> it's an extremely interesting problem
09:25:47 <kmc> wvd, in Haskell it's much more common to use a parsing library than a parser generator
09:26:10 <RyanT5000> wvd: ah right, that's what i meant; i forgot all about parser generators :)
09:26:23 <stepcut> is it possible to write this function, unsequence :: (Monad m) => m [a] -> [m a]
09:26:27 <kmc> wvd, the effect is very much like a generator; you describe your grammar in a compact way, but it's ordinary Haskell code and so it's cleaner, simpler build, and you get the full power of Haskell abstraction
09:26:29 <jmcarthur> the only part of my model that cares about the continuity of the domain is accumulation, and even that could also be generalized into a discrete-friendly version if i wanted to. it just doesn't affect me right now, so i'm not too concerned with it
09:26:35 <RyanT5000> i remember my horrible lex/yacc days in undergrad
09:26:46 <kmc> wvd, the most popular parsing library is Parsec
09:26:49 <stepcut> this is the closest I got, unsequence :: (Monad m) => m [a] -> [m a]
09:26:52 <stepcut> opps
09:26:58 <quicksilver> stepcut: no.
09:26:58 <wvd> kmc, ah thanks, will look at that.
09:26:59 <stepcut> unsequence m = [ do (v:vs) <- m ; return v ]
09:27:15 <jmcarthur> stepcut: i don't think that is possible in general
09:27:26 <stepcut> yeah, didn't think so
09:27:39 <kmc> stepcut, you can do m [a] -> m [m a]
09:27:41 <kmc> :t fmap (map return)
09:27:42 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f [a] -> f [m a]
09:28:07 <stepcut> kmc: yeah, that is not good enough
09:28:22 <kmc> you can't do it in general
09:28:35 <kmc> you can write other functions with that signature of course
09:28:45 <stepcut> yeah
09:29:16 <jmcarthur> well, if you have a particular use case i'd just write it less generally
09:29:25 <kmc> :t \x -> [head <$> x]
09:29:27 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> [f a]
09:29:34 <kmc> ;)
09:30:06 <stepcut> kmc: yeah i had that :p
09:31:37 <stepcut> hmm
09:32:31 <ddarius> If the idea is that sequence . unsequence = id then that is definitely not possible.
09:35:56 <stepcut> unsequenceN :: (Monad m) => Int -> m [a] -> m a
09:35:56 <stepcut> unsequenceN n m = do vs <- m ; return (vs !! n)
09:35:57 <stepcut> unsequence :: (Monad m) => m [a] -> [m a]
09:35:57 <stepcut> unsequence m = zipWith unsequenceN [0..] (repeat m)
09:36:15 <stepcut> but that is only good for infinite lists (and not very efficient either)
09:36:47 <kmc> yeah
09:37:07 <kmc> it will "re-run" the list-producing computation over and over
09:37:11 <kmc> whatever that means for your particular monad
09:37:29 <stepcut> yeah, that too..
09:37:36 <kmc> :t zipWith (fmap . flip (!!))
09:37:37 <lambdabot> forall (f :: * -> *) a. (Functor f) => [Int] -> [f [a]] -> [f a]
09:38:05 <kmc> though, it is closer to a solution than i thought was possible ;)
09:39:00 <aristid> most functions that return IO x could also return MonadIO m => m x?
09:39:01 <edwardk_> heya RyanT5000, long time no see
09:39:19 <RyanT5000> hey, how's it going?
09:39:29 <edwardk_> not bad at all
09:39:32 <RyanT5000> cool
09:39:35 <kmc> aristid, all i think
09:39:40 <kmc> :t (liftIO .)
09:39:41 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (MonadIO m, Functor f) => f (IO a) -> f (m a)
09:39:53 <kmc> err
09:39:54 <aristid> kmc: forkIO probably can't
09:40:07 <kmc> :t liftIO . forkIO
09:40:08 <lambdabot> Not in scope: `forkIO'
09:40:09 <edwardk_> seeing you reminds me i need to definitize the next date for boston haskell
09:40:14 <kmc> :t liftIO . Control.Concurrent.forkIO
09:40:15 <lambdabot> forall (m :: * -> *). (MonadIO m) => IO () -> m GHC.Conc.ThreadId
09:40:30 <kmc> aristid, but it can't *take* a (MonadIO a) => a
09:40:31 <RyanT5000> edwardk_: ah, have you taken over that now?
09:40:36 <kmc> because there's no unliftIO
09:40:54 <edwardk_> yeah, ravi moved off to singapore
09:41:02 <RyanT5000> yeah; i talked to him about that
09:41:04 <Silvah> So create unliftIO.
09:41:09 <RyanT5000> at  the time he hadn't found a replacement; i'm glad you stepped up
09:41:34 <aristid> kmc: oh yeah
09:41:35 <edwardk_> i more or less just started scheduling them and people kept showing up ;)
09:41:46 <RyanT5000> cool :) that's usually how these things work
09:41:48 <aristid> Silvah: heh we can't put that into the same class tho
09:42:19 <edwardk_> so when can we get you to come out and give a bloodknight status talk? =)
09:43:18 <Silvah> :t liftIO
09:43:19 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:43:50 <RyanT5000> edwardk_: soon; we'll have a sweet demo very soon :)
09:44:01 <edwardk_> woot. looking forward to it =)
09:44:13 <RyanT5000> i've actually been recruiting for the last few days to get some people to help tie this thing off
09:44:20 <RyanT5000> everything's going very well
09:44:22 <Silvah> So, unliftIO would be m a -> IO a? Or I did not get it?
09:44:26 <edwardk_> i saw some of the chatter on -cafe
09:44:29 <kmc> Silvah, yeah
09:44:46 <EvanR-work> hire me, hire me
09:44:54 <kmc> and that amounts to a universal "run" function for all monads wrapping IO
09:45:10 <kmc> but many of them would require extra input
09:45:23 <kmc> e.g. (StateT s IO) needs an initial state
09:45:50 <Silvah> Okay... not feasible, then.
09:46:15 <kmc> not in general
09:49:04 <RyanT5000> EvanR-work: send your resume :)
09:49:06 <RyanT5000> ryan@ipwnstudios.com
09:49:14 <RyanT5000> we're working on an action-roleplaying game right now
09:49:19 <RyanT5000> called BloodKnight
09:49:20 <EvanR-work> where are you located
09:49:23 <RyanT5000> Boston
09:49:28 <RyanT5000> we have a lot of people who work remotely though
09:49:35 <RyanT5000> we're still in the "poor start-up" phase :)
09:49:54 <dons> yay, Intel Concurrent Collections, http://www.reddit.com/r/programming/new/
09:50:18 <EvanR-work> ill take care of that after work
09:50:33 <Silvah> How would sex (Motorola 6809 instruction, it simply copies sign bit of a value to all other bits) look in Haskell (for Int32)?
09:50:43 <rajeshsr>  findMatch (reverse hd) (-1) is different from:  findMatch (reverse hd) -1!
09:50:44 <wvd> @hoogle Char -> String
09:50:44 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
09:50:44 <lambdabot> Prelude show :: Show a => a -> String
09:50:44 <lambdabot> Text.Show show :: Show a => a -> String
09:50:48 <rajeshsr> WTH!!
09:51:16 <rajeshsr> - becomes an infix function?!
09:51:22 <dons> man, 1 up, 3 down, http://www.reddit.com/r/programming/comments/c93p8/announcing_intel_concurrent_collections_for/ :/
09:51:32 <rajeshsr> ha, just now realized that! so what is the best way to handle negative numbers?
09:51:40 <rajeshsr> always put them in parenthesis?
09:51:41 <wvd> How would I convert '3' to "3"? show '3' gives "'3'"
09:51:47 <soupdragon> > ['3']
09:51:48 <lambdabot>   "3"
09:52:24 <soupdragon> \x -> [x]
09:52:27 <soupdragon> > (\x -> [x]) '3'
09:52:28 <Silvah> > let f x = [x] in f ''
09:52:29 <lambdabot>   "\243"
09:52:29 <lambdabot>   "3"
09:52:53 <wvd> soupdragon, oh, ofcourse!
09:53:51 <Silvah> Or, lemme rephrase that: how would I perform arithmetic right shift in Haskell?
09:54:01 <soupdragon> *2
09:54:06 <RyanT5000> Silvah: look up Data.Bits
09:54:34 <monoidal> return '3' :: String
09:54:38 <monoidal> > return '3' :: String
09:54:39 <lambdabot>   "3"
09:55:09 <Silvah> It's called "pure"!
09:55:41 <Silvah> > pure '8'
09:55:41 <lambdabot>   No instance for (GHC.Show.Show (f GHC.Types.Char))
09:55:41 <lambdabot>    arising from a use of...
09:55:51 <Silvah> lol
09:56:03 <Silvah> > pure '8' :: String
09:56:04 <lambdabot>   "8"
09:56:54 <Silvah> RyanT5000: thank you.
09:57:01 <RyanT5000> Silvah: np
09:57:03 <somebody__> z
09:57:15 <idnar> > negate 5
09:57:16 <lambdabot>   -5
09:58:46 <monoidal> how to solve this conflict? ghc-6.12.1 requires unix ==2.4.0.0 however unix-2.4.0.0 was excluded because ghc-6.12.1 requires unix ==2.4.0.1
09:58:47 <gwern> Intel working in haskell? that's new to me
09:58:56 <monoidal> it's a bit paradoxical
09:59:20 <gwern> doesn't explain why anyone would want to use this intel stuff though
10:00:08 <Saizan> monoidal: the error message sucks, but let me find the FAQ where it's explained
10:00:08 <Saizan> monoidal: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
10:00:26 <monoidal> thanks
10:00:47 <wvd> I've gone wrong somewhere, but I have no idea where: http://codepad.org/a57okVEc
10:01:10 <dsouza> join #math
10:02:00 <Saizan> wvd: t is a String
10:02:26 * hackagebot xml 1.3.7 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.7 (IavorDiatchki)
10:02:39 <wvd> Saizan: the type of (:) is a -> [a] -> [a], so String -> [String] -> [String]. Why doesn't it work then?
10:02:39 <rajeshsr> finally wrote a brainfuck interpreter: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25783#a25783
10:02:40 <Saizan> wvd: so (t:fList) should be [String] (if it typechecks), which means you can't use it as an argument of split, because it expects a String
10:02:47 <wvd> Oh right
10:02:54 <wvd> Thanks
10:03:12 <rajeshsr> but no monads were needed! :) Should think of something else to use State monads!
10:03:34 <Silvah> > let sex x = x `shiftR` (bitSize x - 1) in sex (-1)
10:03:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:03:34 <lambdabot>    `Data.Bits.Bits a'
10:03:34 <lambdabot>      a...
10:03:38 <mux> well, the State monad is never /needed/, it's just convenient at times
10:03:58 <EvanR-work> all you need is lambda calculus
10:04:29 <Ke> does lambda calculus include IO?
10:04:39 <Ke> !
10:04:43 <EvanR-work> IO is overrated
10:05:33 <EvanR-work> formalize a notion of observers that recursively nested inside the evaluating program
10:06:24 <rajeshsr> @hoogle rList
10:06:24 <lambdabot> Control.Parallel.Strategies parList :: Strategy a -> Strategy [a]
10:06:24 <lambdabot> Control.Parallel.Strategies parListChunk :: Int -> Strategy a -> Strategy [a]
10:06:24 <lambdabot> Control.Parallel.Strategies parListN :: Integral b => b -> Strategy a -> Strategy [a]
10:06:42 <rajeshsr> @hoogle readList
10:06:42 <lambdabot> Prelude readList :: Read a => ReadS [a]
10:06:42 <lambdabot> Text.Read readList :: Read a => ReadS [a]
10:06:42 <lambdabot> Text.Read readListDefault :: Read a => ReadS [a]
10:07:14 <Silvah> Does FTOTW work under that interpreter?
10:07:30 <rajeshsr> k, bye. everyone! It is always amazing how i keep learning everyday by visiting this channel!
10:07:35 <EvanR-work> FTOTW?
10:07:37 <rajeshsr> Thank you so much
10:07:40 <rajeshsr> bye
10:07:57 <Silvah> Finally Taking Over The World.
10:08:26 <EvanR-work> in soviet russia...
10:08:26 <wvd> Is there an index-based version of Data.List.delete?
10:09:27 <jmcarthur> :t delete
10:09:28 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:09:59 <wvd> I could just look it up using  `elemIndex`
10:10:03 <mux> @hoogle Int -> [a] -> [a]
10:10:04 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:10:04 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:10:04 <lambdabot> Data.List drop :: Int -> [a] -> [a]
10:10:10 <wvd> drop
10:10:17 <wvd> > drop "a" "aabc"
10:10:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:10:18 <lambdabot>         against inferred type ...
10:10:22 <wvd> oh right
10:10:24 <mux> that's not what you actually want
10:10:26 <wvd> > drop 1 "aabc"
10:10:27 <lambdabot>   "abc"
10:10:30 <wvd> > drop 2 "aabc"
10:10:32 <lambdabot>   "bc"
10:10:35 <wvd> Mmh, no.
10:10:42 <mux> it drops n characters from the left
10:10:43 <jmcarthur> :t \n -> uncurry (++) . second tail <<< take n *** drop n
10:10:44 <lambdabot> forall a. Int -> ([a], [a]) -> [a]
10:10:45 <mux> but you could use splitAt
10:10:47 <jmcarthur> oops
10:10:51 <jmcarthur> :t \n -> uncurry (++) . second tail <<< take n &&& drop n
10:10:53 <lambdabot> forall a. Int -> [a] -> [a]
10:11:33 <mux> > let foo i xs = let (a,b) = splitAt i xs in a ++ drop 1 b in foo 3 "abcd"
10:11:34 <lambdabot>   "abc"
10:11:54 <mux> > let foo i xs = let (a,b) = splitAt i xs in init a ++ b in foo 3 "abcd"
10:11:55 <jmcarthur> :t \n -> uncurry (++) . second tail <<< splitAt n
10:11:55 <lambdabot>   "abd"
10:11:56 <lambdabot> forall a. Int -> [a] -> [a]
10:12:01 <monoidal> or just take (n-1)
10:12:29 <jmcarthur> oh mine is wrong
10:12:34 <jmcarthur> init is gross
10:12:55 <monoidal> * drop (n+1)
10:13:10 <tromp> @let deleteAt n l = a++c where (a,b:c) = splitAt n l
10:13:11 <lambdabot>  Defined.
10:13:17 <jmcarthur> let foo n = uncurry (++) . second tail <<< splitAt (n-1) in foo 4 "abcdefg"
10:13:24 <jmcarthur> > let foo n = uncurry (++) . second tail <<< splitAt (n-1) in foo 4 "abcdefg"
10:13:25 <mux> > let foo i = drop 1 (take (i - 1) in foo 3 "abcd"
10:13:26 <lambdabot>   "abcefg"
10:13:27 <lambdabot>   <no location info>: parse error on input `in'
10:13:36 <mux> > let foo i = drop 1 (take (i - 1)) in foo 3 "abcd"
10:13:37 <lambdabot>   Couldn't match expected type `[a]'
10:13:37 <lambdabot>         against inferred type `[a1] -> [...
10:13:52 <mux> err
10:13:53 <edwardk_> why mix <<< and . ?
10:13:56 <tromp> > deleteAt 1 "hello"
10:13:57 <lambdabot>   "hllo"
10:13:58 <mux> > let foo i = drop 1 . take (i - 1) in foo 3 "abcd"
10:13:59 <jmcarthur> edwardk_: precedence
10:13:59 <lambdabot>   "b"
10:14:07 <jmcarthur> oh
10:14:07 <mux> omg I suck.
10:14:09 <jmcarthur> not needed now
10:14:12 <edwardk_> yeah
10:14:16 <jmcarthur> edwardk_: it was an artifact of an older version
10:14:18 <mux> > let foo i = take (i - 1) . drop 1 in foo 3 "abcd"
10:14:19 <lambdabot>   "bc"
10:14:19 <edwardk_> =)
10:14:32 <mux> this is even worse
10:14:33 * mux slaps self
10:14:48 <jmcarthur> > let foo n = uncurry (++) . second tail . splitAt (n-1) in foo 4 "abcdefg"
10:14:49 <mux> > let foo i = drop 1 . take i in foo 3 "abcd"
10:14:50 <lambdabot>   "abcefg"
10:14:50 <lambdabot>   "bc"
10:15:03 <jmcarthur> > deleteAt 4 "abcdefg"
10:15:04 <lambdabot>   "abcdfg"
10:15:15 <mux> hah.
10:15:27 <jmcarthur> oh the n-1 is wrong, actually
10:16:01 <Silvah> Make it pointless.
10:16:05 <jmcarthur> > let foo = fmap $ uncurry (++) . second tail . splitAt in foo 4 "abcdefg"
10:16:07 <lambdabot>   Couldn't match expected type `([a], [a])'
10:16:07 <lambdabot>         against inferred type `[a...
10:16:35 <jmcarthur> @pl foo n = uncurry (++) . second tail . splitAt n
10:16:35 <lambdabot> foo = ((uncurry (++) . second tail) .) . splitAt
10:16:41 <jmcarthur> that's more like it
10:17:00 <jmcarthur> > let foo = fmap (uncurry (++) . second tail) . splitAt in foo 4 "abcdefg"
10:17:01 <lambdabot>   "abcdfg"
10:18:09 <soupdragon> @let foldNat z s = let phi 0 = z ; phi (n+1) = s (phi n) in phi
10:18:11 <lambdabot>  Defined.
10:18:17 <soupdragon> :t foldNat
10:18:18 <lambdabot> forall t t1. (Integral t1) => t -> (t -> t) -> t1 -> t
10:20:00 <soupdragon> > foldNat 1 (+) 324
10:20:01 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
10:22:58 <Silvah> :t wtf
10:22:58 <lambdabot> forall a. a -> a
10:23:03 <Silvah> lol?
10:23:31 <Silvah> @src wtf
10:23:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:23:33 <jmcarthur> > wtf 5
10:23:34 <lambdabot>   5
10:23:40 <jmcarthur> i guess wtf = id
10:23:44 <soupdragon> wtf = lol
10:23:57 <jmcarthur> :t lol
10:23:58 <lambdabot> Not in scope: `lol'
10:24:35 <alexyk> are there optional parameters in Haskell?  or I have to simulate them with Maybe?
10:24:42 <edwardk_> Silvah: someone slapped it together to answer a question the other day, wtf = id
10:24:54 <edwardk_> alexyk: the better answer is to abuse records for it
10:25:25 <wvd> Can't I nest wheres?
10:25:35 <soupdragon> wvd why bother
10:25:45 <edwardk_> alexyk: data Options = Options { foo :: Int, bar :: String }; options = Options { foo = 3 };; bar opts = ... foo opts ...; then you can call bar options { foo = 12 } or just bar options
10:26:02 <wvd> soupdragon, here: http://codepad.org/bS8bT5lc
10:26:05 <edwardk_> er i recycled bar in there by accident
10:26:16 <Olathe> @hoogle Maybe a -> Maybe a -> Maybe a
10:26:17 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
10:26:17 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:26:17 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
10:26:36 <soupdragon> wvd,  put   | otherwise          = s  at the end
10:26:44 <edwardk_> alexyk: data Options = Options { foo :: Int, bar :: String }; options = Options { foo = 3, bar = "" };; baz opts = ... foo opts ...; then you can call baz options { foo = 12 }, baz options { bar = "Hello" } or just baz options -- to get the defaults
10:27:20 <alexyk> edwardk_: ok, though I'd have to accept Options
10:27:24 <akosch> does haskell have xor for integers?
10:27:25 <wvd> soupdragon, still parse error on input where
10:27:34 <Silvah> Yes.
10:27:43 <Silvah> > 1 `xor` 2
10:27:44 <alexyk> how do I print progress to stderr and flush it?
10:27:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:27:44 <lambdabot>    `Data.Bits.Bits a'
10:27:44 <lambdabot>      a...
10:27:58 <Silvah> print & hFlush
10:28:03 <Ke> > 1 .^. 2
10:28:04 <lambdabot>   Not in scope: `.^.'
10:28:08 <alexyk> Silvah: to stderr
10:28:11 <edwardk_> alexyk: yes, that is the cost of switching to that model. the reason is since haskell is lazy, it really wouldn't know to pass your 'optional' argument to the function or to the result of the function. there's no delimiter for when you are done with the call
10:28:12 <Ke> > 1 .|. 2
10:28:12 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:28:13 <lambdabot>    `Data.Bits.Bits a'
10:28:13 <lambdabot>      a...
10:28:17 <Silvah> > 1 :: Int `xor` 2
10:28:18 <lambdabot>   Only unit numeric type pattern is valid
10:28:22 <edwardk_> ocaml and its ilk can rely on the fact that you tuple up arguments
10:28:29 <Silvah> er
10:28:43 <Silvah> > 1 `xor` 2 :: Int
10:28:44 <lambdabot>   3
10:29:00 <alexyk> edwardk_: so ocaml's ~syntax is based on that?  you mean glorious tribe, of course :)
10:29:09 <akosch> Silvah: thx
10:29:19 <burp> > 1 `xor` 3 :: Int
10:29:20 <lambdabot>   2
10:29:23 <Silvah> alexyk: hPrint stderr then.
10:29:46 * alexyk observes that while OCaml makes millions on Wall St., Haskell makes millions going drinking instead of finishing learning it
10:29:54 <edwardk_> alexyk: yeah, i tripped over it when i tried bolting optional and named args onto a lazy language ;)
10:30:19 <alexyk> edwardk_: well options is not too bad I guess.
10:30:23 <edwardk_> alexyk: haskellers also make millions on wall st. they just don't advertise as much as jane street about it ;)
10:30:46 <alexyk> edwardk_: cut me in! :)
10:31:28 <edwardk_> alexyk: i know at least 4 banks that have at least some group working in haskell
10:32:16 <alexyk> edwardk_: there's an urban legend of a basement full of ancient PCs cranking Excel spreadsheets controlled by a Haskell overlord...
10:32:41 <jkingkong> can somebody explain to me please what is meant by the terms "boxed" and "unboxed"
10:32:50 <jkingkong> referring to things like vectors, arrays, etc?
10:32:57 <edwardk_> hrmm i wonder if it would be worth it to bottle up the 'options' model in a module. i think something with a cute name like class Options t where with :: t -- would be cute
10:33:21 <edwardk_> then you could say bar with { flag = 12 }
10:33:26 <alexyk> edwardk_: http://stackoverflow.com/users/login?returnurl=/questions/2790860/optional-arguments-in-haskell
10:33:42 <akosch> another thing: i'm looking for a library function to create a list of all the combinations of all elements of several other lists
10:33:45 <alexyk> or just: http://stackoverflow.com/questions/2790860/optional-arguments-in-haskell
10:33:51 <akosch> for two lists i can use liftM2
10:33:55 <akosch> but for 3, etc...
10:34:09 <edwardk_> alexyk: yeah, i've given similar stack overflow responses
10:34:19 <jkingkong> just liftM2 over and over again?
10:34:56 <alexyk> how many people use the monad tricks described in RWH, Programming with Monads, daily?
10:35:04 <alexyk> pp. 359 --
10:35:13 <akosch> jkingkong: well that would give me tuples inside tuples
10:35:22 <edwardk_> alexyk: http://www-cg.cis.iwate-u.ac.jp/lab/graphite06.pdf
10:35:25 <zygoloid> > sequence [[1,2,3],[4,5],[6,7,8]]
10:35:26 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
10:35:30 <zygoloid> akosch: ^^ like that?
10:35:42 <edwardk_> alexyk: i use monad tricks a lot, but i'm not sure what is on that page
10:35:53 <edwardk_> er woops, misfire on the paste
10:35:58 <edwardk_> http://stackoverflow.com/questions/2819652/how-would-you-write-this-clojure-snippet-in-ruby-and-or-haskell/2820283#2820283
10:36:11 <edwardk_> the other was for someone else about fluid simulation =)
10:36:12 <alexyk> edwardk_: it describes a series of things you do with monads, I wonder how representative they are
10:36:39 <erikc> vim matmul.h
10:36:46 <erikc> woops
10:36:48 <akosch> zygoloid: yeah, seems ok
10:36:54 <akosch> zygoloid: thanks
10:38:05 <edwardk_> alexyk: is it somewhere around http://book.realworldhaskell.org/read/monad-transformers.html ?
10:38:18 <Saizan> jkingkong: the term "box" refers to some structure wrapped around the value (which is e.g. one way to implement laziness), so "unboxed Int" is just a machine integer, similar to int in C, unboxed array is an array that contains unboxed things, which can be implemented as a contiguous chunk of memory holding the values, while a boxed array is just an array of pointers to the boxed elements
10:38:22 <RyanT5000> alright, one final spamming before i give you guys (and myself) a rest:
10:38:34 <RyanT5000> My company is hiring Haskell programmers to work on our game
10:38:39 <Dashkal> p359 is the start of chapter 15 "Programming with Monads"
10:38:40 <RyanT5000> check us out at ipwnstudios.com
10:39:01 <alexyk> edwardk_: earlier, my internet is strangely slow on HTTP here but fast on IRC :)
10:39:16 <RyanT5000> and email me at ryan@ipwnstudios.com if you're interested or have questions
10:39:22 <alexyk> copumpkin would understand how that works in Dirt Cowboy Caf
10:39:24 <RyanT5000> i'll also be around on IRC
10:39:38 <RyanT5000> have a good day, everyone
10:39:43 <edwardk_> alexyk: then i'd say mostly its spot on, some of the examples would be more commonly implemented using Control.Applicative
10:39:53 <edwardk_> i.e. apReview alist =     MovieReview `liftM` lookup1 "title" alist                    `ap` lookup1 "user" alist                    `ap` lookup1 "review" alist -- would probably be done with
10:40:34 <edwardk_> apReview alist = MovieReview <$> lookup 1 "title" alist <*> lookup1 "title" alist <*> lookup1 "title" alist -- because the sugar is nicer
10:41:25 <edwardk_> alexyk: although, they just haven't introduced applicatives at that point
10:42:19 <alexyk> edwardk_: nice, I was wondering about that
10:42:43 <_swift_> is there a version of the Haskell Prime Report newer than the one on the wiki, which seems to not have been updated since 2007?
10:43:11 <edwardk_> _swift_: have you looked at http://www.haskell.org/pipermail/haskell-prime/2010-April/003165.html ?
10:43:58 <_swift_> edwardk_: no, but that seems to be what i was looking for =)
10:44:00 <jkingkong> ?hoogle Elt
10:44:00 <lambdabot> No results found
10:44:11 <Saizan> apReview = runReaderT $ MovieReview <$> lookup 1 "title" <*> lookup1 "title" <*> lookup1 "title"
10:44:17 <edwardk_> you'll have better luck searching around for haskell 2010 than haskell prime
10:44:37 <zygoloid> "Modified versions of this Report may also be copied and distributed for any purpose, provided that the modified version is clearly presented as such, and that it does not claim to be a definition of the language Haskell 98"
10:44:50 <zygoloid> ^^ surely that should say Haskell 2010?
10:45:11 <edwardk_> probably -- you should probably email marlow ;)
10:45:43 * zygoloid failed at due diligence -- turns out the first reply to that email spotted the same thing!
10:45:56 <edwardk_> hah
10:48:36 <jb55> does anyone know how many galois talks were recorded and how many will be available?
10:48:54 <jkingkong> technical question: When I import Data.Array.Parallel.Unlifted it tells me "Could not find module `...` it is a member of the hidden package `dph-prim-seq-0.4.0` ...
10:49:04 <jkingkong> how do I get it to "see" the hidden package?
10:49:55 <monoidal> http://www.haskell.org/cabal/FAQ.html#hidden-packages-a
10:50:56 <jkingkong> ty
10:51:07 <jkingkong> but oh gosh I've never even written a .cabal file before
10:51:18 <jkingkong> was hoping there'd be a simple option fix or something :P
10:52:18 <monoidal> what should I do when ghc package is broken? I'm getting "There is no available version of ghc that satisfies -any"
10:52:23 <edwardk_> jkingkong: don't worry, its easy to do
10:52:55 <edwardk_> i think byorgey even put together a nice little 'cabal init' tool
10:53:22 <edwardk_> http://byorgey.wordpress.com/2010/04/15/cabal-init/
10:53:32 <jkingkong> edwardk_: yea I just stole a random cabal file and am editing it now :)
10:53:39 <jkingkong> edwardk_: oh very nice
10:53:49 <c_wraith> heh.  that practice is the reason cabal init was created. :)
10:53:58 <jkingkong> lol
10:54:08 <jkingkong> yea I've never actually opened one
10:54:13 <jkingkong> I am pleasantly surprised
10:54:38 <Axman6> jb55: i'd like to know too
10:54:50 <jkingkong> c_wraith: hahaha the paragraph describes me exactly
10:56:25 <jkramer> Ahoy
10:56:39 <jkramer> I'm trying to update base with cabal, but I'm getting this error: cabal: Distribution/Client/Dependency/TopDown.hs:171:37-73: Non-exhaustive patterns in lambda
10:56:47 <jkramer> Any ideas how I can fix this?
10:57:08 <Saizan> you can't update base
10:57:21 <Saizan> you've to get a newer ghc version
10:57:48 <Saizan> though that pattern match failure might deserve a bug report :)
10:57:50 <jkramer> I just installed the latest stable version (6.12.1)
10:58:05 <jkramer> And latest Cabal and latest cabal-install :)
10:58:19 <Saizan> why do you think you need to update base?
10:58:34 <edwardk_> jkramer: you might have an old version of Cabal
10:58:36 <jkramer> When I do "cabal upgrade", base is in the list of outdated modules :)
10:58:45 <edwardk_> jkramer: cabal upgrade is flat busted ;)
10:59:09 <jkramer> edwardk_: I installed the latest version from http://www.haskell.org/cabal/download.html about 10 minutes ago
10:59:16 <jkramer> 1.8.0.4
10:59:18 <Saizan> cabal upgrade is disabled for a reason :)
10:59:34 <edwardk_> jkramer: *nods* cabal upgrade is just something you shouldn't bother even doing.
10:59:40 <jkramer> Yeah, but at least it gives me a list of packages to update manually
10:59:47 <edwardk_> jkramer: it doesn't do what you think it should
10:59:57 <jkramer> How else do I know which packages have updates available?
11:00:12 <Saizan> jkramer: btw, the latest ghc version is 6.12.2, which is the one with base-4.2.0.1
11:00:22 <jkramer> Oh
11:00:31 <jkramer> Then the website must be outdated
11:00:33 <jkramer> Let me check
11:00:37 <edwardk_> in general you can't update base.
11:00:41 <Saizan> not sure if it's considered stable yet
11:00:46 <edwardk_> its pretty closely tied to your ghc version
11:01:01 <Saizan> however i wouldn't go upgrading packages just because :)
11:01:02 <c_wraith> 6.12.2 had some bad regressions.  6.12.3 is in RC, and has apparently fixed them.
11:01:53 <jkramer> Ah, right. I was here: http://hackage.haskell.org/platform/linux.html and followed the link "GHC 6.12.1 generic binary"
11:02:20 <jkramer> Oh well I'll just stick with .1 and not update anything :)
11:03:26 <jkramer> The reason why I was updating at all is that I'm trying to build leksah
11:03:38 <jkramer> Is anyone here running leksah with .1?
11:03:42 <edwardk_> did they tie themselves to .2  ?
11:04:13 <jkramer> Well, I had 6.10.xx before updating today :)
11:04:14 <edwardk_> i finally saw leksah in action at hac-phi, i must say i was more impressed than I thought I would be
11:04:42 <jkramer> Don't know what the minimum ghc version is, but 6.10 didn't work
11:04:45 <edwardk_> it jumped the text in the edit window around too much for my taste, when it was doing autocomplete stuff, but otherwise it was pretty slick
11:05:15 <jkramer> I'm actually pretty happy with vim, but I'm also very curious :)
11:05:17 <jkingkong> cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however
11:05:17 <jkingkong> directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
11:05:22 <jkingkong> I'm getting that a lot :P
11:05:27 <jkramer> The screenshots look nice
11:05:40 <jkingkong> how exactly is my installation broken?
11:05:41 <Saizan> jkingkong: see the first Cabal FAQ
11:05:48 <jkingkong> gah sorry
11:05:52 <Saizan> np
11:06:12 <Peaker> The Monoid module defines newtypes around Maybe without Functor instances :(
11:06:23 <edwardk_> Peaker: First and Last?
11:06:31 <Saizan> jkingkong: the short story is that you've the same version of some package in both the user and global db, and that makes ghc and cabal pretty confused
11:06:39 <Peaker> edwardk_, Yeah
11:06:43 <Peaker> edwardk_, probably the others too
11:06:57 <zygoloid> what's the right way to list package versions in a .cabal file? should i say package >= version i have < next major version?
11:07:00 <edwardk_> Peaker those two at least should probably go in as requests to libraries@
11:07:30 <edwardk_> which can prompt the discussion to get them suitable foldable, traversable, etc. instances as well
11:07:42 <Peaker> Which will make the proposal die
11:07:43 <Peaker> :)
11:08:06 <edwardk_> Peaker: more or less, but at least it'll have been hashed out and they'll feel guilty about it ;)
11:08:27 <jkramer> Waah, I'm giving up on leksah
11:08:41 <zygoloid> "newtype First a = First { getFirst :: Maybe a } deriving (..) hiding instance Monoid" :D
11:09:06 <edwardk_> the monoid instance for Maybe annoys me
11:09:18 <Peaker> Yeah, I don't see why newtypes don't get all the instances automatically
11:09:24 <Peaker> (with "hiding")
11:09:29 <Peaker> edwardk_, Why?
11:09:37 <zygoloid> i guess because it's arbitrary
11:09:40 <Peaker> edwardk_, because it makes an arbitrary choice?
11:09:55 <edwardk_> Peaker: that would be bad, changing the definition of what is in scope when you define the newtype could get radically different definitions
11:10:17 <zygoloid> edwardk_: it'd need to be for all current and future instances
11:10:24 <edwardk_> Peaker: because it doesn't agree with the monadplus instance and because it lifts a semigroup but you have to implement the semigroup as a 'monoid'
11:11:12 <Peaker> edwardk_, I think the disagreement is intentional (so you get more territory covered) so I dislike MonadPlus and would prefer to have higher-rank class constraints: class (forall a. Monoid m a) => MonadPlus m <nothing>
11:11:31 <Peaker> Monoid (m a) that is
11:11:55 <edwardk_> Peaker: i agree that the disagreement was intentional, but it is unfortunate that it happened, because otherwise you could reason about monoid vs. monadplus like you can alternative and monadplus.
11:12:15 <zygoloid> Peaker: wouldn't that just be a context synonym?
11:12:28 <zygoloid> context MonadPlus m = forall a. Monoid (m a)
11:12:56 <edwardk_> higher order instances are not likely to ever happen, they require not only a 'proof' that an instance head can satisfy the requirement, but they care about the structure of the 'proof' and interact badly with overlapping instances, etc.
11:13:43 <edwardk_> the other day i had to define an entire module full of higher order numeric instances. Eq1, Num1 .. RealFrac1, etc. it was fairly horrifying ;)
11:14:05 <edwardk_> i at least packaged up some template haskell to make instantiation easy
11:15:01 <edwardk_> but i needed them to be able to provide a nicely abstracted notion of infinitesimal for my shiny new mixed-mode automatic differentiation library
11:15:54 <Peaker> zygoloid, No, because there are laws relating Monoid and Monad
11:16:03 <Peaker> zygoloid, and only if those are abided -- it is a MonadPlus
11:16:40 <gwern> a <+> (b <+> c) == (a <+> b) <+> c - it's not just a good idea, it's the law.
11:16:41 <edwardk_> Peaker: sadly there are two sets of laws that don't quite agree ;)
11:17:12 <edwardk_> left catch vs. "left distribute" (which is really a right distributive law iirc)
11:17:29 <zygoloid> gwern: no need for it to be a law, just don't associate with people who don't follow it :)
11:18:45 <edwardk_> zygoloid: or just take the steve jobs/republican approach and make laws that are so restrictive that everyone is in violation and enforce the law selectively ;)
11:19:15 <jkingkong> so I follow the cabal FAQ and unregister process-1.0.1.2. Now it says that Cabal-1.8.0.4 is broken. The faq says I need to install it again
11:19:28 <jkingkong> How do I do that without reregistering process-1.0.1.2?
11:19:30 <gwern> edwardk_: actually, the chinese legalists invented that one
11:20:22 <monochrom> naw, the chinese legalists invented the dual. make a law that says "everyone has religious freedom" but selectively enable it.
11:20:23 <gwern> edwardk_: there's a funny story about a chinese legalist minister who fell out with his king, tried to flee the state, and was caught & executed due to one of his own laws requiring inns to register all customers
11:20:34 <tomberek> edwardk: hi there
11:20:45 <edwardk_> gwern: those were the examples most likely to impinge on the lives of the folks on channel that i could think of off hand, not attribution of precedent ;)
11:20:48 <edwardk_> heya tom
11:21:06 * gwern would also suggest richelieu's '5 lines' quote
11:21:30 <Saizan> jkingkong: you've Cabal-1.8.0.4 installed in your user db?
11:22:27 * edwardk_ is a bit of a coward. After my last attempt to upgrade ghc, cabal, etc. I just took to installing them on a fresh vm each time ;)
11:22:39 <jkingkong> Saizan ah I do, I need to unregister it?
11:22:52 * monochrom just sticks to haskell platform. not a coward.
11:23:02 <Saizan> jkingkong: no, unless you also have the same version in the global db
11:23:11 <monoidal> i've done cabal unregister ghc-6.12 (was broken); how do I get it back?
11:23:21 <Saizan> monoidal: reinstall ghc
11:23:38 <tomberek> edwardk: is there any way to label/annotate a type, but still allow all normal operations on it?or is Writer suited?
11:24:08 <jkingkong> Saizan, so what then?
11:24:14 <Saizan> jkingkong: ok, you can run "cabal install Cabal --dry-run -v" that will tell you what it's trying to do, and if it wants to reinstall process we'd have enough info to work around that
11:25:36 <jkingkong> Saizan: yes
11:25:43 <jkingkong> it says in order, the following would be installed
11:25:57 <jkingkong> process-1.0.1.2 (reinstall) changes : directory-1.0.1.0 -> 1.0.1.1
11:26:05 <edwardk_> tomberek: not sure i fully parsed your question. label/annotation in the sense of my comonadic graph stuff?
11:26:07 <jkingkong> then other stuff
11:26:21 <jkingkong> cycle of death
11:26:54 <tomberek> edwardk: in a way, yes.. that's why i thought you'd be the one to ask.  I also looked at your Control.Functor.Zap
11:27:00 <Saizan> jkingkong: cabal install Cabal --constraint="directory-1.0.1.0" --dry-run -v ?
11:27:55 <tomberek> edwardk: ( I might just be trying to re-invent your annotations, not sure yet.  If so, at least I'll understand them when i'm done.)
11:28:00 <edwardk_> class Zap f g | f -> g, g -> f where zap :: f (a -> b) -> g a -> b -- ?
11:28:10 <edwardk_> not sure i see the connection
11:28:18 <jkingkong> Saizan: cabal: dependency expected
11:28:38 <Saizan> jkingkong: oops, typo
11:28:43 <tomberek> edwardk: a labeled function acts on a labeled value
11:28:48 <Saizan> jkingkong: cabal install Cabal --constraint="directory == 1.0.1.0" --dry-run -v
11:28:57 <edwardk_> ah
11:29:17 <edwardk_> zap was built as a way to express duality. did you see the associated blog article?
11:29:28 <jkingkong> process-1.0.1.2 (reinstall) changes: filepath-1.1.0.3 -> 1.1.0.4, unix-2.4.0.0
11:29:29 <jkingkong> -> 2.4.0.1
11:29:35 <tomberek> nah, send it
11:29:45 <edwardk_> http://comonad.com/reader/2008/zapping-strong-adjunctions/
11:30:03 * Saizan wonders why you have two versions of such "core" packages
11:30:24 <edwardk_> tomberek: and the earlier http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/
11:30:24 <Saizan> jkingkong: anyhow, you can add constraints for those too
11:30:43 <tomberek> edwardk_: ok, i'll be reading... thx
11:31:26 <jkingkong> Saizan: I have no idea what I did to get it like this
11:31:32 <edwardk_> in short the use of Zap is oriented around the notion of having one of the functors make a 'decision' every time the other provides two branches.
11:31:58 <jkingkong> Saizan, how exactly do the flags for multiple constraints work?
11:32:14 * hackagebot graphmod 1.2.1 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2.1 (IavorDiatchki)
11:33:48 <Saizan> jkingkong: you just duplicate them: --constraint=".." --constraint=".."
11:34:06 <jkingkong> oh i see, what I was doing first was wrong
11:34:25 * Saizan wonders if there's an "installed" constraint
11:36:10 * jkingkong is trying it now
11:36:19 <dcoutts> Saizan: not exposed in the UI yet
11:37:11 <dcoutts> Saizan: we should work out exactly how to make cabal/ghc less confused by local instances and global instances of the same package version.
11:37:21 <dcoutts> it's clearly still tripping a lot of people up
11:37:34 <Saizan> dcoutts: i was just going to say the same :)
11:38:59 <jkingkong> oh gosh now like 12 packages are broken
11:39:06 <jkingkong> i should just reinstall everything lol
11:41:05 <Peaker> packedstring seems broken?
11:42:49 <edwardk_> Peaker: packstring is dead, long live bytestring
11:43:22 <Peaker> for some reason it wanted to install packedstring for my data-accessor-template dep. But if I install d-a-t directly then it didn't
11:45:48 <Eelis> hm, i don't get species. i've seen presentations of algebraic data types as fixpoints of type functions before. what exactly does all this talk of labels add (other than a seemingly infinite supply of new notation)?
11:45:53 <edwardk_> Peaker: just switch to fclabels ;)
11:45:55 <tomberek> edwardk_: looks like that's not what I'm looking for.  I would like to have a base type, that I can attach labels/annotations to without having to change code, the labels would just travel along, (perhaps combine in a defined way).  Is this just Annotations?
11:46:30 <Peaker> edwardk_, Heh, what Accessor data type does fclabels use? Can I define my own getter/setter there?
11:47:00 <edwardk_> tomberek: in general, yes, but you have to be careful, if you want the annotation scheme i described you need something like a brand that isn't quite as innocuous as that, because you _want_ the brand to get in the way when you do something bad
11:47:30 <edwardk_> Peaker: same general idea minus the henning'isms plus a Control.Category instance
11:47:34 <Olathe> @hoogle Int -> Word8 -> ByteString -> ByteString
11:47:34 <lambdabot> Text.Regex.Base.RegexLike makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex
11:47:35 <lambdabot> Text.Regex.Base.RegexLike makeRegexOptsM :: (RegexMaker regex compOpt execOpt source, Monad m) => compOpt -> execOpt -> source -> m regex
11:47:35 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
11:47:37 <edwardk_> Peaker: and yes
11:47:39 <MrBlueSky> would anyone mind checking this function for me real quick and telling me why I'm getting an "ERROR- Unresolved overloading" in Hugs?
11:47:40 <MrBlueSky> http://pastebin.com/rWLFWgkp
11:48:00 <Peaker> so does everyone agree on "fclabels" now?
11:48:18 <copumpkin> MrBlueSky: omg no hugs
11:48:24 <copumpkin> MrBlueSky: plz2use ghc kthx
11:48:26 <MrBlueSky> I'm only using it for today
11:48:34 <copumpkin> no u
11:48:39 <edwardk_> Peaker: i've sold a lot of people on it. and ezyang swapped out data-accessor for fclabels after there was a mass outcry on his blog's how-to ;)
11:48:51 <copumpkin> I kind of feel bad for HT
11:48:54 <copumpkin> but I wish he'd get the hint
11:49:28 <tomberek> edwardk_:perhaps if i explain my idea.  For graphs; If I have node and edge types defined, I have an unlabeled graph.  If I then attach labels to that, I get a labeled graph for free
11:49:38 <danharaj> 1 op 666 users in the channel
11:49:47 <Peaker> for HT?
11:49:51 <copumpkin> danharaj: and the op is chanserv
11:49:51 <edwardk_> tomberek: so far so good
11:49:57 <Peaker> who is HT?
11:49:58 <copumpkin> danharaj: there are many more potential ops though :)
11:50:02 <copumpkin> Peaker: henning
11:50:03 <edwardk_> Peaker: henning thieleman
11:50:14 <Peaker> The author of data-accessor-*? What hint?
11:50:24 <edwardk_> the guy behind all the C's and T's in the numeric prelude and data-accessor
11:50:27 <copumpkin> the hint that people don't like his naming scheme
11:50:34 <monochrom> Hugs is just fine. That code also loads fine. Problem cannot be reproduced.
11:50:40 <c_wraith> Heh.  it's true that things should have names other than C or T
11:51:32 <MrBlueSky> wtf
11:51:45 <MrBlueSky> well thanks monochrom
11:52:07 <Saizan> Eelis: species include more structures than algebraic data types do
11:52:13 <Eelis> i guess it doesn't help that the paper about species i'm reading (namely brent yorgey's) tries to illustrate species as Haskell type constructors, but it seems like a shaky fit
11:52:18 <tomberek> edwardk_ : so I did this:http://pastebin.com/YLgKgHv4
11:52:19 <MarcWeber> nominolo_: I've seen today that there are new commits to the Vim code made by Martin Krauskopf. Do you want to keep vim files now because you didn't cherry-pick my commit removing them from devel. Some time ago you wanted to have a different release cycle for Vim. How do you think about this today?
11:52:38 <tomberek> edwardk_ :but i'm starting to get the idea that it's wrong
11:53:02 <copumpkin> edwardk_: omg there was another Data.Rope on hackage
11:53:11 <edwardk_> Eelis: you can represent things as species that don't work as ADTs, i.e. a bag which you can't talk about the order of the items in the bag. or a cycle where you don't have a defined head to the list, but can break it on some element and then get a list for the tail.
11:53:16 <danharaj> :t CallCC
11:53:17 <lambdabot> Not in scope: data constructor `CallCC'
11:53:24 <danharaj> :t callCC
11:53:24 <Eelis> Saizan: hm, so is that why the Haskell code shown only seems to be a vague approximation of what he's actually talking about?
11:53:24 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:53:28 <edwardk_> copumpkin: yeah, i was bad and just kind of stomped on his namespace
11:53:30 <gwern> copumpkin: there are several rope implementations thanks to icfp
11:53:35 <gwern> I think yi has a ropes impl too
11:53:36 <copumpkin> ah
11:53:41 <Saizan> Eelis: i've yet to read this paper
11:54:11 <Eelis> edwardk_: but what would be the language to define such data types?
11:54:12 <gwern> copumpkin: you kind of needed ropes to do that Endo alien one
11:54:25 <copumpkin> not sure what that is :)
11:54:31 <edwardk_> copumpkin: my asymptotics trumped him everywhere, so i didn't feel too bad about it
11:54:35 <Eelis> edwardk_: just saying "it's a species!" seems like a cheat that doesn't actually mean anything :)
11:54:44 <copumpkin> edwardk_: you should rub it in his face on the mailing list :)
11:55:11 <edwardk_> Eelis: the trick is you need something to be able to take a quotient over the type that says you don't care about ordering in certain cases. you can define very nice species in agda/coq
11:55:17 <gwern> well, it is a good excuse. 'my version is better'
11:55:35 <copumpkin> is there any species stuff actually implemented in agda actually?
11:55:39 <Saizan> a specie is defined by his generating "functor", no?
11:55:46 <edwardk_> copumpkin: i have a toy library somewhere
11:55:57 <Eelis> edwardk_: hmm
11:55:57 <copumpkin> :o
11:56:33 <Saizan> *its
11:57:05 <ddarius> Has someone spelled out the relationship between containers and species?
11:57:10 <edwardk_> gwern: yeah, basically all of his log(n)'s except for append/splitAt turn into O(1)'s
11:57:36 <edwardk_> ddarius: byorgey has talked about it via his blog a time or two, but probably not very explicitly
11:58:13 <edwardk_> on and the fromByteString goes from O(n) to O(1)
11:58:16 <edwardk_> er oh and
11:58:20 <byorgey> that's because I don't yet understand it very explicitly =)
11:58:23 <byorgey> just intuitively
11:58:35 <Eelis> edwardk_: what introductory text on species would you recommend?
11:58:36 <danharaj> what is a species and what is a container (in the context of Haskell)
11:58:47 <edwardk_> Eelis: hrmm, lemme see if i can find the paper
11:59:03 <gwern> edwardk_: is his just inefficient or are you moving the asymptotics somewhere else?
11:59:13 <edwardk_> Eelis: http://lambda-the-ultimate.org/node/2785
11:59:25 <edwardk_> gwern: i use fingertrees of bytestrings
11:59:26 <Eelis> edwardk_: thanks!
11:59:32 <edwardk_> gwern: so i use a very different structure
11:59:54 <kmc> danharaj, www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
11:59:56 <Eelis> edwardk_: the comments in that lambda node post seem somewhat negative though
12:00:10 <ddarius> Saizan: A species practically -is- a functor, so yes.
12:00:23 <Eelis> in particular, the paper was rejected
12:00:37 <Eelis> "frustrating vagueness"
12:00:44 <copumpkin> pff peer review
12:00:47 <edwardk_> it is a pretty good introduction regardless ;)
12:00:49 <copumpkin> who needs it
12:00:54 <Eelis> edwardk_: ok, i'll give it a try :)
12:00:55 <jkingkong> why would ghci tell me that it can't find a module that's in the same directory?
12:00:56 <byorgey> Eelis: if you don't find my paper very clear, then the Carette+Uszkay paper certainly isn't going to help!
12:01:08 <Eelis> byorgey: oh, damn
12:01:28 <ddarius> Eelis: If you can get your hands on Combinatorial Species and Tree-like Structures (which is what I think byorgey just referred to) it is awesome, albeit not Haskell/programming related.
12:01:38 <byorgey> Eelis: I missed your question(s) though, was there something in particular you were/are confused about?
12:01:47 <byorgey> yes, that book is fantastic, that's where I learned most of what I know from.
12:03:25 <Eelis> byorgey: well, i can give an example. you define the species 1 as the one that "yields a single unit structure when applied to an empty set of labels, and no structures otherwise". however, i don't see how the haskell code you give ("data One a = One") reflects this. doesn't  One a  have 1 value even if a is *not* empty?
12:03:38 * edwardk_ adds a +1 for Combinatorial Species and Tree-like Structures, but it is a bit big if you just want a couple of quick questions about them answered
12:04:36 <byorgey> Eelis: note the number of labels refers to the number of "holes" where data can go in a structure, NOT to the size of the parameter type.
12:04:44 <c_wraith> @hoogle Endo
12:04:45 <lambdabot> Data.Monoid newtype Endo a
12:04:45 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
12:04:45 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
12:04:59 <MrBlueSky> monochrom: can you tell me the inputs you used for that function?
12:05:07 <byorgey> Eelis: so data One a = One  corresponds to the species that yields a single unit structure when applied to an empty set of labels, because values of type  One a  contain no a's
12:05:08 <MrBlueSky> I'm still getting an error, in ghci and hugs
12:05:11 <monochrom> :load r.hs
12:05:19 <byorgey> and there is only one value of type  One a  (ignoring bottom)
12:05:20 <Peaker> I like "Endo a" as a type synonym
12:05:25 <Eelis> byorgey: oh, so the Haskell type constructor One isn't actually the mapping from label-sets to label-sets?
12:05:52 <Eelis> erm, label-sets to structure-sets i mean
12:05:58 <c_wraith> @src Endo mappend
12:05:58 <lambdabot> Source not found. Wrong!  You cheating scum!
12:06:08 <c_wraith> eh.  I'm sure it's just a lifted (.)
12:06:09 <byorgey> Eelis: no, not really
12:06:15 <edwardk_> c_wraith: Endo f `mappend` Endo g = Endo (f . g)
12:06:23 <Eelis> byorgey: ah, that explains a lot! ok, i will restart from scratch with this in mind :)
12:06:26 <danharaj> I have a question related to type constructors and category theory. Are there any papers that follow up on Hagino's thesis on categorical programming languages?
12:06:28 <byorgey> Eelis: that would be the 'enumerate' method of the Enumerable type class
12:07:06 <byorgey> Eelis: ok. yeah, it's tricky to get the correspondences right, and even trickier to explain well.
12:07:07 <c_wraith> It appears that if I wanted to just apply a list of functions, there's no benefit to having them be wrapped in an Endo wrapper.
12:07:09 <edwardk_> peaker but then you can't define instances on it
12:07:23 <Eelis> byorgey: so then the Haskell fmap's don't actually lift label-maps to structure-maps either?
12:07:25 <byorgey> Eelis: if there's something you think I could add that would have helped you understand it, please let me know (I'm currently revising the paper).
12:08:05 <edwardk_> peaker: And I even use Yoneda Endo every now and again ;)
12:08:17 <byorgey> Eelis: no, that is (part of) what fmap does.
12:08:32 <edwardk_> (it makes a great Maybe)
12:08:40 <Peaker> edwardk_, But I have so many (a -> a)'s in my code that Endo a is more useful as a short-hand than as an anchor for instances :)
12:08:41 <MrBlueSky> monochrom: oh, it's not a compile time error. It only throws the error when the function is actually run
12:08:47 <edwardk_> heh
12:09:03 <Eelis> byorgey: was that a "no, you're right" or "no, you're wrong"? :)
12:09:27 <byorgey> Eelis: that was a "no, you're wrong".  fmap DOES lift label-maps to structure-maps.
12:09:38 <Eelis> byorgey: but in "One a", i shouldn't think of a as the type of labels, right?
12:10:21 <Eelis> hm, actually let me think about this for a while
12:11:28 <tomberek> edwardk_:i read your posts and the Data Types A La Carte.  I understand the paper a bit better than your post, but it seems that both are going after the same effect.
12:11:37 <byorgey> Eelis: I should probably think about it for a while too or I will just end up confusing you.  I haven't thought about it since I submitted the paper.
12:11:47 <Eelis> byorgey: heh :)
12:12:07 <edwardk_> tomberek: well, his post talks about one use for the free monad, i just point out that you can annihilate free monads with a cofree monad and vice versa for field selection
12:12:18 <edwardk_> i leverage his machinery to a different end
12:12:30 <edwardk_> er cofree comonad
12:13:02 <tomberek> erg.... um,, translation? I just want to have labelable types
12:13:16 <edwardk_> tomberek: translation, the zap stuff is irrelevant to you ;)
12:13:21 <tomberek> got it
12:13:31 <tomberek> what should I read then?
12:14:42 <edwardk_> well, the short answer is i'm not sure of what you mean by labelable in this context. i mean i understand you want the ability to label a graph, but not every operation you can perform on an unlabeled graph can be performed on one with arbitrary labels. that was the gist of my comonadic graph lib
12:16:33 <tomberek> edwardk_:still don't grok your graph lib
12:17:14 <edwardk_> tomberek: then perhaps one thing to do might be to explore how 'type level brands' work.
12:17:22 <edwardk_> if you're looking for a reading list
12:17:26 <tomberek> k
12:18:34 <alexyk> hey guys I'm a bit confused about using two monads at once.  I need to read from TokyoCabinet and also getArgs and print.  The main has a do which is for IO chain.  The TCM monad for Tokyo, how's its own chain jiving with the enclosing IO do?
12:18:45 <edwardk_> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/22308/ uses it, but there are other examples from earlier, including the ST s monad
12:18:54 <Eelis> byorgey: i guess the more i think about it the clearer it becomes that "what is the relation between 'a' and the set of labels?" is really the essence of my confusion
12:20:02 <Eelis> which i guess boils down to what you said about the correspondence between the Haskell and the actual species itself being tricky to characterize :)
12:20:04 <edwardk_> tomberek: so perhaps the oiginal launchbury/peyton jones paper on ST s would be useful: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.3299
12:20:17 <ddarius> danharaj: There's an implementation.  This paper follows on a bit:  http://www.springerlink.com/index/Y016845141268890.pdf
12:20:18 <edwardk_> er original
12:20:37 <Olathe> @hoogle Maybe a -> a
12:20:37 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
12:20:38 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
12:20:38 <lambdabot> Data.Monoid First :: Maybe a -> First a
12:20:41 <Eelis> byorgey: so if anything, i would recommend trying to make that correspondence more explicit
12:20:41 <tomberek> edwardk_; well, what I keep getting hung up on is that I don't see how a the functions that take a Graph b can be applied to a Degree 'Annotated' Graph b
12:20:47 <Eelis> byorgey: (in the revised version)
12:20:55 <alexyk> here's a paste which works: http://paste.pocoo.org/show/219427/ .  The problem is, I now need to extend getSample into a full iteration over the cabinet.  E.g., there's an function     iterinit  :: a -> TCM Bool, which, when returning False, must end both getSample and the main.  How is that done?
12:21:05 <EvanR-work> > fromJust Nothing
12:21:06 <lambdabot>   *Exception: Maybe.fromJust: Nothing
12:21:18 <byorgey> Eelis: ok, thanks.  I will give it some careful thought.  Perhaps if I come up with a good explanation I will try to run it by you.
12:21:22 <edwardk_> tomberek: do you still have the old paste?
12:21:28 <tomberek> i do
12:21:30 <Eelis> byorgey: alrighty!
12:21:46 <edwardk_> iirc (Degree `Annotated` Graph) b = (Graph b, Degree b)
12:21:52 <edwardk_> its just a tuple
12:21:53 <matt_m> byorgey:  One confusing thing to me is that the set of labels is taken as finite.  How does the definition of list make sense then?
12:22:18 <tomberek> type Annotated f s b = (s b, f b)
12:22:19 <ddarius> matt_m: The inductive list type is a type of finite lists.
12:22:50 <edwardk_> yes, so (f `Annotated` s) b = (Annotated f s) b = Annotated f s b = (s b, f b)
12:22:59 <matt_m> ddarius:  So if you want infinite lists can you just generalize to countable U?
12:23:08 <byorgey> yeah, I don't know anything about how the theory of species interacts with the theory of coinductive data.
12:23:10 <tomberek> edwardk_: and your extend will work, but i don't see it used anywhere
12:23:15 <byorgey> it's probably been studied.
12:23:30 <edwardk_> tomberek: i explicitly removed the use of the comonad from the lib to make it easier to follow ;)
12:23:58 <ddarius> matt_m: I suspect the generalization to countable source categories is not trivial, but it should lead to some theory.
12:24:07 <tomberek> edwardk_: I'm looking for some sort of typecase that either simply applied f or extend f
12:24:20 <edwardk_> tomberek: the places where i pass in Graph b -> t b -> ... I'm 'conceptually' passing in (Graph b, t b) or (t `Annotated` Graph) b -- i wanted to show the concepts without the comonads tripping you guys up
12:24:47 <ddarius> The comonads are the concepts.
12:25:15 <alexyk> so anybody can help with co-usage of IO and TCM above? ^^
12:25:33 <edwardk_> ddarius: the concepts in question were yout to separate annotation on a graph from the shape of the graph, where annotations can be things like indegree, outdegree of each node, labels, names for vertices that can be looked up, etc.
12:25:40 <tomberek> edwardk_: ok, but how does dfs :: Graph b -> etc.    take an annotated Graph?
12:25:52 <edwardk_> tomberek: it doesn't.
12:26:06 <edwardk_> tomberek: you could make a version that does
12:26:14 <EvanR-work> i cant seem to find a copy of 'a theory of objects'
12:26:21 <EvanR-work> luca cardelli
12:26:22 <edwardk_> tomberek: but the first thing i wanted to do was get a branded version of Data.Graph in there so i had something to build on
12:26:35 <tomberek> so we need a dfs for annotated AND unannotated graphs?
12:26:47 <ddarius> EvanR-work: Have you checked his site?
12:27:03 <matt_m> ddarius: Ok, I get it - thanks
12:27:26 <EvanR-work> ddarius: no electronic?
12:27:54 <edwardk_> tomberek you could just define dfs :: (t `Annotated` Graph) b -> ... -- which ignores the annotation
12:27:58 <Cale> alexyk: Um, I'm not sure I understand the problem
12:28:00 <tomberek> edwardk_: ah, ok, i'm starting to see that the features that I thought were in there, but couldn't find/understand, aren't in there.  Hence my confusion.
12:28:21 <edwardk_> tomberek: i just slapped that together as a skeleton to show how transpose works on annotations
12:29:47 <alexyk> Cale: it's probably not a problem, it's a newbie problem.  :)  I need to read from TokyoCabinet, which is accomplished by some TCM monad functions.  The main is running in IO monad.  How can one handle both at once if the main's do chain is the IO's?  Say I want to open in TCM, iterinit there, and bail if iterinit returns TCM False.  How?
12:30:19 <monoidal> when I'm installing almost everything with cabal, libraries process, haskell98 and random are reinstalled every time. is it normal?
12:30:56 <Cale> alexyk: Basically, using multiple monads is not any different than using multiple libraries in general. The TCM and IO monads would normally be entirely separate types.
12:31:37 <Cale> alexyk: However, the library provides some functions for "running" a TCM action by turning it into an IO action, and for turning IO actions back into TCM actions
12:31:41 <alexyk> Cale: but if I have a do chain, >>= it represents is from one monad only, right?
12:32:02 <Cale> yeah
12:32:13 <Cale> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
12:32:18 <alexyk> so that's where I'm stuck, making it flow
12:32:25 <Cale> So, for any single m
12:32:35 * gwern refrains from a rap reply to alexyk 
12:32:43 <Cale> Does the code you pasted not compile for some reason?
12:32:59 <alexyk> the code works fine.
12:33:24 <Cale> Okay...
12:33:40 <alexyk> What I need is to extend it: to iterate over the whole cabinet.  For that, I have to call iterinit.  Which may return TCM False, and I'm not sure how to abort the whole thing then.
12:33:58 <alexyk> i.e. stop both getSample's TCM chain and back in main stop the IO chain.
12:34:09 <Cale> Well, you simply don't run the remainder of the action -- you probably want to write something like:
12:34:13 <Cale> b <- iterinit
12:34:38 * hackagebot kinds 0.0.1.0 - Emulation of subkinds and subkind polymorphism  http://hackage.haskell.org/package/kinds-0.0.1.0 (WolfgangJeltsch)
12:34:40 <Cale> if b then ... proceed ...
12:34:51 <Cale>      else return Nothing
12:34:58 <alexyk> yeah, but what else -- I still have to return into a monad?
12:35:05 <alexyk> hm
12:35:10 <alexyk> ok
12:37:40 * hackagebot type-functions 0.1.0.0 - Emulation of type-level functions  http://hackage.haskell.org/package/type-functions-0.1.0.0 (WolfgangJeltsch)
12:38:05 <Cale> alexyk: Each line of a do-block (aside from let bindings), will consist of an action in some monad. It must be the same monad throughout the entire do-block, and the do-block as a whole will have the same type as the action which is on the last line. (The result of the overall action is the result of the last action in it)
12:38:26 <Cale> That is, do-notation is used to glue together smaller actions into larger ones.
12:38:40 <Cale> If you have only one action, the 'do' is redundant.
12:38:41 <alexyk> so do folks generally refer to the second monad from the first monad's do or explicit >>= chain via calling some helper functions?
12:39:13 <alexyk> the database monad's results can affect the IO chain of the main...
12:39:34 <Cale> Well, sure, but so can the results of pure computations :)
12:39:41 * hackagebot records 0.1.0.0 - A flexible record system  http://hackage.haskell.org/package/records-0.1.0.0 (WolfgangJeltsch)
12:42:42 <alexyk> Cale: in the paste which works, why is the main's do ended with runTCM (do blah) >>= maybe ...?  why not use the main's do for >>= ?
12:43:18 <Cale> alexyk: Normally it's best to think of actions in separate monads as being self contained to some extent. You build up some computation in the TCM monad, which acts like an embedded domain-specific language for composing database operations, I suppose. You then apply runTCM to that action to get an IO action which when executed, will actually run the TCM computation you built.
12:43:38 <MilosDj> may I ask some questions about compiling wxWidgets?
12:43:58 <MilosDj> mingw32-make: *** [gcc_mswudll\monodll_dummy.o] Error 2
12:44:03 <MilosDj> if monolitic 1
12:44:21 <MilosDj> but if monolitic 0, there's different error
12:44:32 <MilosDj> mingw32-make: *** [gcc_mswudll\basedll_dummy.o] Error 2
12:44:39 <MilosDj> any suggestions?
12:44:54 <alexyk> Cale: ok.  But still, runTCM (do getSample ...), while getSample ... = do ... has its wn do, why do getSample with a do in it?
12:44:59 <Cale> alexyk: Does that make sense? I could probably explain this better if I knew what the TCM monad was actually for ;)
12:45:22 <Cale> do-notation is for gluing together some actions in a monad into a single composite action
12:45:38 <alexyk> Cale: the TCM is TokyoCabinet monad.http://hackage.haskell.org/package/tokyocabinet-haskell
12:45:39 <Cale> the 'do' on  (do getsample file key)  is unnecessary
12:45:42 <Cale> (but harmless)
12:46:13 <Cale> alexyk: Yeah, I'm looking at the documentation for it, but I'm not certain why they introduced the separate monad, rather than just working in IO.
12:46:15 <Jafet> Maybe in an intercal polyglot
12:46:15 <alexyk> Cale: ok, one do down :)
12:47:09 <Cale> newtype TCM a =
12:47:09 <Cale>     TCM { -- | Unwrap TCM.
12:47:09 <Cale>           runTCM :: IO a
12:47:09 <Cale>     } deriving (Monad, MonadIO)
12:47:12 <alexyk> so we could replace the >>= after runTCM with something like b <- runTCM ... ?
12:47:20 <alexyk> and then passing it to maybe smehow
12:47:34 <Cale> ^^ so TCM computations are internally nothing more than IO actions.
12:48:04 <alexyk> Cale: why would they wrap IO like that?
12:48:22 <Cale> Perhaps the library authors wanted to retain the freedom to change how TCM actions were represented in the future.
12:48:50 <alexyk> ah, so the >>= after runTCM is indeed for the main's IO do
12:48:51 <Eelis> byorgey: would it be correct to say that "enumerate l" is really only defined when there are no duplicates in l (seeing as how l is supposed to represent a 'set' of labels)? could one even have used Data.Set there?
12:49:01 <Cale> alexyk: yeah
12:49:06 <byorgey> Eelis: indeed.
12:49:08 <Cale> runTCM :: TCM a -> IO a
12:49:11 <Eelis> byorgey: ok, good :)
12:49:31 <byorgey> Eelis: if you call 'enumerate l' and l has duplicates it will just treat them as if they are different
12:49:37 <Reisen> Can't find what I'm looking for, stripPrefix is the closest, I want something that will take "one" and "three one two" and give me " two"
12:49:45 <MilosDj> mingw32-make: *** [gcc_mswudll\monodll_dummy.o] Error 2 === if monolitic 1
12:49:46 <MilosDj> mingw32-make: *** [gcc_mswudll\basedll_dummy.o] Error 2 === monolitic 0
12:49:47 <byorgey> Eelis: you're right, I could have used Set, perhaps that would be better.
12:49:51 <alexyk> Cale: before I can read a damn key/value and print it, I have to understand all that! :)
12:50:08 <Eelis> byorgey: ok, i see. i'm very slowly making progress :)
12:50:12 <Reisen> Is there a function like that already in Data.List that I'm just missing? Or should I just write my own
12:50:15 <alexyk> but this time, I'm determined to do it :)
12:50:44 <byorgey> Eelis: anyway, in (a currently unreleased version of) my species library, there is code to handle the case where you want to do enumeration taking the duplicates into account
12:50:58 * alexyk needs to found a support group for folks attempting to master Haskell the third time around
12:51:03 <byorgey> Eelis: ok, good =)
12:51:18 <Eelis> byorgey: hm, but that sort of extension is really beyond the material in the paper, right?
12:51:23 <byorgey> yeah
12:51:26 <Eelis> ok
12:51:33 * alexyk the name is 3th: 3rd Time Haskeller
12:52:37 <Veinor> Reisen: I think you might need to write it
12:53:11 <dcoutts> monoidal: no, not normal
12:53:17 <Veinor> what do you want it to return if you give ti "one" and "three one two one five"?
12:53:50 <Reisen> " two one five"
12:53:59 <Reisen> Just want something to split the string at the first occurance, and return the rest
12:54:15 <_swift_> alexyk: i think being in grad school has made it easier for me to learn haskell. i simply decided "i'm going to do everything in haskell from now on" and there were no external factors to stop me from doing that. it helped a lot.
12:54:17 <Reisen> I thought there was probably something to already do it, I'll write one, I don't mind. Thanks Veinor
12:54:32 <Veinor> no problem.
12:55:41 <alexyk> _swift_: returning to research let me do successive projects in OCaml, Scala and Clojure, learning each in sequence.  But Haskell's the most difficult one to crack.  My RWH is the first Amazon pre-order, with egregious typos in the first printing.  I blame it! :)
12:56:46 <_swift_> alexyk: with all apologies to the authors, who are probably lurking in this channel, i just read RWH on the web =)
12:56:53 <alexyk> _swift_: grad school also affects one, e.g. try to do something in Haskell if you have a common Java codebase.  Imagine your advisor being a Scala fan, too.
12:57:12 * alexyk wishes for more advisors who are fans of any FP languages
12:57:30 <_swift_> alexyk: well the other people in my group are using mostly C and C++, so the first thing I did was figure out the FFI haha
12:58:00 <alexyk> _swift_: I paid once, and I'll pay again!  :)  I'll buy the ebook once I'm sure I'll use Haskell
12:58:26 <alexyk> _swift_: yeah, C/C++ is OK. Java is the killer for OCaml or Haskell.
12:58:31 <_swift_> alexyk: there's an ebook? hmm.. i might have to buy that
12:58:58 <alexyk> _swift_: $32 for Kindle with DRM, $40 from O'Reilly direct no DRM, ePub/mobi/PDF
12:59:11 <alexyk> dons: kick me back $1.20
12:59:36 <_swift_> alexyk: nice; i'm sold. i didn't realize o'reilly offered DRM-free PDF!
13:00:12 <alexyk> _swift_: IIRC, do check it twice
13:01:04 <_swift_> alexyk: you could probably interop w/ Haskell via JNI, but that's something i've never tried to do and i don't know how much of a pain it is
13:01:30 <alexyk> is there a short-circuit way to bail from a do chain oce a result is say False?
13:01:36 <alexyk> once
13:02:05 <alexyk> _swift_: yeah, forget it, Java means Scala or Clojure, good it's that now at least
13:02:48 <alexyk> Cale: if b then proceed breaks the flow, I though monads are shortcircuiting easily, like Maybe and such?
13:04:29 <EvanR-work> alexyk: theres this thing untilM
13:04:38 <EvanR-work> loop until something
13:04:47 <Cale> alexyk: Not all monads are the same. :)
13:04:49 <EvanR-work> if you want to 'break' then you can try Cont
13:04:53 <alexyk> @hoogle untilM
13:04:53 <lambdabot> No results found
13:05:29 <Cale> alexyk: IO has exceptions, and I suppose via runTCM and liftIO, you could use them in the TCM monad, though quite awkwardly.
13:05:29 <EvanR-work> MaybeT ;)
13:05:56 <EvanR-work> also, you can use a large unless
13:06:18 <alexyk> Cale: well iterinit returns TCM Bool, so I have to short-circuit on that
13:06:32 <EvanR-work> :t unless
13:06:33 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:08:10 <alexyk> ah
13:08:27 <jmcarthur> TCM monad?
13:08:33 <Cale> alexyk: Usually I'd just break the thing into two pieces, describing what to do when the result is True, and what to do when the result is False, and simply use if.
13:08:55 <alexyk> Cale: ok
13:09:40 <Cale> alexyk: Note that you probably want to do *something* when the value is False, even if that's just to return Nothing, or throw an exception.
13:10:20 <monoidal> what is a good random library? I'd like to play with distributions like 1/2: heads, 1/2: tails, generate a random member of that distibution, and same in continuous case
13:10:27 <alexyk> right
13:10:34 <monoidal> (e.g. CReal with uniform distribution)
13:11:02 <EvanR-work> :t random
13:11:03 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:11:29 <EvanR-work> random (mkStdGen 0) :: (CReal, StdGen)
13:11:32 <EvanR-work> > random (mkStdGen 0) :: (CReal, StdGen)
13:11:33 <lambdabot>   No instance for (System.Random.Random Data.Number.CReal.CReal)
13:11:33 <lambdabot>    arising f...
13:12:48 <alexyk> how do you in ghci replicate import qualified Data.Map as M?
13:14:17 <alexyk> how is lambdabot prepending quantifiers?
13:14:31 <mauke> loads it from a file
13:15:59 <monoidal> alexyk, this is scheduled for 6.14. till now, load a file with qualified import.
13:16:13 <alexyk> monoidal: ok
13:17:49 <hydo> alexy: not the same, definitely, but you could 'set :prompt "> "'  ... that's what I usually do when I've :m +'ed several modules.
13:18:13 <hydo> if it's readability of the repl you are concerned with...
13:18:57 <matt_m> byorgey: BTW I found the comments about only considering structures with each label used "exactly once" a little confusing, because "structure" is never defined (is it?) and so it's not even clear what that means
13:21:28 <jkramer> I don't think I understand this error message: http://pastie.org/982363
13:21:33 <jkramer> Can someone explain?
13:22:18 <jkramer> process-1.0.1.2 is installed, but cabal still complains about it
13:23:25 <dcoutts> jkramer: you don't want to re-install process, use the version that comes with ghc.
13:23:45 <dcoutts> if you've accidentally got multiple versions registered, get rid of the other ones, keep the original one.
13:24:29 <jkramer> How do I uninstall it? It's installed with --user, so can I just delete it from .cabal?
13:24:50 <dcoutts> jkramer: ghc-pkg --user unregister thepackagename
13:25:15 <dcoutts> jkramer: don't delete package files without unregistering, that way madness lies
13:25:29 <jkramer> ghc-pkg: unregistering process would break the following packages: Cabal-1.8.0.4 haskell98-1.0.1.1 (use --force to override)
13:25:31 <ezyang> In CT, is there a name for an arrow f for which there exists no composition (besides identity + f)?
13:25:32 <jkramer> :(
13:25:48 <jkramer> Forcing should be ok, since there's still a global install of process, right?
13:26:02 <alexyk>    hydo: kind of learned that too, is there an .ghcirc or some such to auto -set prompt?
13:26:14 <dcoutts> jkramer: sounds like you've got a local install of haskell98 too
13:26:37 <jkramer> Uhm
13:26:38 <dcoutts> jkramer: another one to nuke, then rebuild any broken packages, ghc-pkg check will tell you
13:27:03 <jkramer> I think I'll just rm -rf ~/.cabal and start over
13:27:22 <EvanR-work> NUKE
13:27:23 <dcoutts> jkramer: then you also need to rm -rf ~/.ghc or they will not be unregistered
13:27:59 <jkramer> Ah, forgot that one when I killed .cabal earlier today - might explain some of the problems :)
13:28:45 <dcoutts> jkramer: ghc-pkg check is your friend in this circumstance
13:28:45 <Cale> ezyang: I've never come across that idea before, but if I was going to give it a name, I would call such arrows isolated.
13:28:55 <Saizan> you don't need to rm ~/.cabal in fact, unless you're worried about disk space :)
13:29:25 <jkramer> Too late :)
13:29:54 <jkramer> But now I can start over with a clean install and do it right this time
13:30:51 <ezyang> Cale: I mean, I feel like this sort of shows up a lot in algorithmic applications of CT. For example, monoids are just compositions of morphisms, but you need some set of "isolated" morphisms for ones we can easily model in software.
13:31:05 <alexyk> how can I tell Emacs in haskell-mode not to split the window since I have the repl in another frame?
13:31:23 <alexyk> so just scroll down there?
13:32:02 <Cale> ezyang: Oh, er... wait what? :)
13:32:13 <ezyang> Cale: Oops.
13:32:21 <ezyang> s/morphisms/arrows/
13:32:46 <Dashkal> Drawing a blank.  Is it possible to section the binary - operator?
13:33:08 <mauke> sometimes
13:33:14 <edwardk_> ezyang: well, if you have a category of such arrows you'd have a poset (or at least a thin category)
13:33:17 <mauke> :t subtract
13:33:18 <lambdabot> forall a. (Num a) => a -> a -> a
13:33:21 <Dashkal> ahh, danke
13:33:22 <edwardk_> ezyang: so you might call it a thin arrow =)
13:33:41 <jkramer> Yay, everything just worked this time \o/
13:33:45 <ezyang> edwardk_: Huh, would it actually form a poset? (goes and thinks about it)
13:33:45 <Cale> ezyang: Perhaps I misunderstood what you were trying to define
13:33:54 <EvanR-work> i claim this type constructor a -----------> b
13:34:00 <EvanR-work> now i have the longest arrow
13:34:16 <ezyang> Cale: monoids were "what I was really trying to do", but I think the diea generalizes
13:34:19 <edwardk_> ezyang: hrmm, well you'd at least meet the requirements, though i suppose thin is weaker
13:34:37 <edwardk_> hrmm, no, not even that
13:34:59 <edwardk_> since you could have a category with two objects and a bunch of those arrows going from one object to the other, but no other arrows other than identities
13:35:03 <edwardk_> so its not thin
13:35:20 <alexyk> hmm, so if I put "import qualified Data.Map as M" into M.hs and :load "M.hs", I can't use M still:  attempting to use module `M' (./M.hs) which is not loaded -- ?
13:35:54 <ezyang> edwardk_: Do you just make all of the two-arrow compositions identities?
13:36:23 <edwardk_> ezyang: nah, just saying that the category doesn't have any two arrows in it you can compose because they all share the same origin, and same destination (except for the identities)
13:36:57 <Cale> ezyang: But in the case of a monoid, you have lots of composable arrows
13:37:04 <edwardk_> you can build larger categories, but that category can never have an object that has both an arrow head and an arrow tail that reaches it
13:37:09 <edwardk_> (that isn't an identity)
13:37:44 <alexyk> how do you write a map manually in ghci?
13:37:47 <Cale> ezyang: I thought you were talking about arrows f: X -> Y such that there does not exist an object Z with an arrow g: Z -> X, or an arrow h: Y -> Z
13:37:54 <edwardk_> yeah
13:38:01 <edwardk_> thats what i was parsing it as as well
13:38:29 <ezyang> That's what I thought I was asking about too.
13:38:31 <edwardk_> isolated or 'boring' is a good name for those arrows =)
13:38:37 <Cale> But in the case of a monoid, you have lots of those: your monoid consists of a whole bunch of arrows X -> X which all compose with each other.
13:38:46 <ezyang> Cale: Yep!
13:39:04 <Cale> I mean, you have lots of what we're trying to say doesn't exist ;)
13:39:11 <mauke> :t foldr . (.) (:)
13:39:12 <lambdabot> forall a a1. (a -> a1) -> [a1] -> [a] -> [a1]
13:39:13 <edwardk_> then by that arrows in the monoid are not boring, unless you have a trivial monoid
13:39:33 <mauke> :t (`foldr` []) . (.) (:)
13:39:34 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
13:39:47 <edwardk_> since you have more than one arrow from the object to itself. (each of the arrows in your monoid)
13:39:47 <mauke> let mymap = (`foldr` []) . (.) (:)
13:40:06 <ezyang> Cale: Oh, I think the miscommunication is that I'm not demanding the category to contain /only/ these arrows
13:40:38 <edwardk_> cale: you need to refine that.  I thought you were talking about arrows f: X -> Y such that there does not exist an object Z with a non-identity arrow g: Z -> X, or a non-identity arrow h: Y -> Z
13:40:44 <Cale> ezyang: Perhaps you're trying to say that a monoid is a category where any two arrows are composable?
13:40:59 <ezyang> Cale: Well, of course it is.
13:41:01 <Cale> edwardk_: right, yes
13:41:14 <alexyk> an example of Map usge from ghci would be nice
13:41:17 <ezyang> But then looking at all of the arrows in the monoid, some of them are compositions of others, and others are "atomic"
13:41:26 <ezyang> alexyk: Haddock, perhaps?
13:41:49 <alexyk> from ghci
13:41:56 <edwardk_> ezyang: are you looking for generators for your monoid?
13:42:06 <ezyang> edwardk_: Ooh, that sounds close!
13:42:43 <edwardk_> ezyang: then what you're looking for isn't one such that they have no arrows that you can compose with them, but ones that could not be built out of composing two other arrows.
13:42:45 <ezyang> Yep, that's what I was thinking of.
13:43:07 <ezyang> edwardk_: Yeah, the former wasn't what I was really going for.
13:43:16 <edwardk_> (sprinkling non-identity through that description as needed)
13:43:32 <Cale> I would say that an arrow f: X -> Y was irreducible if for any object Z and arrows g: Z -> Y and h: X -> Z for which f = g . h, we have that either Z = X and h = id, or Z = Y and g = id.
13:44:22 <edwardk_> i'd buy that
13:44:31 <ezyang> me too
13:44:38 <alexyk> basically, I'm trying to load the qualified import of Data.Map as M into ghci and manually create a map, but it fails as above...
13:45:10 <edwardk_> cale that actually seems to be the standard term for it too
13:45:18 <Cale> edwardk_: good :)
13:45:33 <ezyang> alexyk: What is on the left of your prompt; is it Main> or Prelude> ?
13:45:43 <Cale> alexyk: You can :m + Data.Map and write  fromList [...]
13:45:58 <ezyang> Irreducible. Excellent.
13:46:04 <Cale> alexyk: Or if that's ambiguous:  Data.Map.fromList [...]
13:46:19 <Cale> alexyk: Where that [...] is a list of pairs that you want your Map to have.
13:46:28 <alexyk> Cale: awesome
13:46:46 <arw> hm. 2 questions, but i guess the answers are "no": is there localisation support in happstack? is there any in gitit?
13:49:14 <Cale> Oh, this reminds me of the notational problem that there's two good definitions of 'locally finite' for categories :)
13:50:03 <edwardk_> in terms of arrows or objects?
13:50:20 <ddarius> Cale: Each homset finite and ?
13:50:26 <Cale> There's the obvious one, which is analogous to 'locally small': every homset is finite
13:50:44 <Cale> Then there's the actually useful one, which is that every arrow has finitely many factorisations
13:51:01 <edwardk_> such that each arrow  can be written as a composition of non-identity arrows in only finitely many ways -- yeah
13:51:23 <edwardk_> i suppose 'locally small' already encoded the other option
13:51:26 <Cale> (which is by analogy with posets, where a locally-finite poset is one where the interval [a,b] is finite for all a and b
13:51:34 <Cale> )
13:52:16 <monoidal> i thought "locally small" is every homset is a set?
13:52:24 <Cale> monoidal: that's right
13:52:35 <monoidal> not necessarily finite
13:52:44 <Cale> monoidal: Yes, I didn't say that ;)
13:52:50 <monoidal> oh, right
13:53:34 <jmcarthur> are there one or two recursion schemes "to rule them all," by which i mean "can be used to implement all other (known?) ones?
13:54:17 <jmcarthur> i doubt the minimal set is unique
13:54:23 <ddarius> jmcarthur: fix
13:54:49 <jmcarthur> ddarius: that's boring :P  i mean things that operate on Mu
13:55:07 <jmcarthur> newtype Mu f = Mu (f (Mu f))
13:55:18 <applicative> arw, what sort of thing do you need in gitit
13:55:24 <ddarius> @google "Recursion Schemes from Comonads"
13:55:27 <lambdabot> http://portal.acm.org/citation.cfm?id=766523
13:55:27 <lambdabot> Title: Recursion schemes from comonads
13:55:51 <edwardk_> jmcarthur: technically you can get by with hylo and fmap except for the prepro/postpro stuff
13:56:11 <ddarius> edwardk_: Can't you get fix from hylo?
13:56:14 <edwardk_> jmcarthur: g_hylo however encodes the way the distributive laws are used
13:56:23 <Cale> Given a locally-finite (in the second sense) small category C, and any ring R, we can form an algebra of functions from (the set of all arrows in C) to R, where we define addition pointwise, and multiplication by "convolution":  (f * g)(a : X -> Y) = sum over all a = b . c of f(b) g(c)
13:56:31 <jmcarthur> ddarius: oh i haven't read that yet. thanks
13:57:01 <Cale> Matrix rings and power series rings are special cases of that construction :)
13:57:14 <ddarius> What is the name of that construction?
13:57:16 <edwardk_> ddarius: yeah just generate some form of codata as the intermediate non-existent structure
13:57:20 <jmcarthur> if only i was an acm member
13:57:27 <ddarius> jmcarthur: It's available elsewhere.
13:57:34 <Cale> ddarius: Category algebra
13:57:59 <Cale> I would use the notation R[[C]], but I have no idea if anyone else does that. :)
13:58:02 <ddarius> Cale: Is the term "category algebra" or something similar used for something else as well?
13:58:27 <alexyk> what's the shortest way to test a Maybe Int value for Just n & n < someMax?
13:58:30 <edwardk_> there was an even better paper on recursion schemes given by uustalu at msfp 08 but it doesn't seem to appear outside of the proceedings
13:58:39 <alexyk> I need it in a guard so it better be cute
13:58:43 <Cale> Yes, there's one which is more analogous to group/monoid rings
13:59:08 <ddarius> alexyk: Use pattern guards?
13:59:10 <jmcarthur> sweet a ps
13:59:16 <Cale> Where you use functions with finite support
13:59:16 <ddarius> Er, just use pattern matching and a normal guard.
13:59:27 <monoidal> > maybe False (<5) 6
13:59:27 <edwardk_> there he encoded a recursion scheme for the cofree comonad in mendler style and showed how it subsumed all the recursion schemes from comonads he'd mentioned before
13:59:28 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
13:59:28 <lambdabot>    arising from the lite...
13:59:30 <alexyk> ddarius: I'm already in a case, and this Maybe is a parameter
13:59:39 <monoidal> > maybe False (<5) (Just 6)
13:59:39 <lambdabot>   False
13:59:43 <EvanR-work> code cuteness, yet another criterion have to worry about. great.
13:59:59 <gwern> EvanR-work: just a synonym for golfing
14:00:09 <gwern> no need to worry your pretty head
14:00:23 <ddarius> (=^.-=) = (++)
14:00:43 <edwardk_> "The recursion scheme from the cofree recursive comonad"
14:00:56 <alexyk> coffee recursive?
14:00:56 <edwardk_> i have it in dead tree form, but it doesn't appear to have found its way online
14:01:05 <edwardk_> alexyk: sounds like my mornings
14:01:09 <Cale> This construction is also a generalisation of the incidence algebras which were studied by Gian-Carlo Rota.
14:01:13 <EvanR-work> along with low lines, narrow lines, small character cound, readability, extensibility, modularity, efficiency, theoretically sound, well typed,
14:01:32 <EvanR-work> dont forget the awesome factor
14:01:34 <alexyk> monoidal: thx.  Is this the real use of maybe?
14:01:37 <alexyk> meaning usual
14:01:43 <monoidal> rather yes
14:02:32 <edwardk_> EvanR-work: bah, it wouldn't be worth doing without all the constraints to make it non-trivial ;)
14:03:05 <Silvah> Hello everyone.
14:03:07 <jmcarthur> edwardk_: thanks
14:03:20 <Cale> (Incidence algebras are just categorical algebras R[[C]] where C is a poset)
14:03:40 <monoidal> alexyk: but if you are in case, i'd rather say Just x | x < max...
14:03:51 <Cale> and there are apparently a good number of interesting results for those, but I don't know if much is known about category algebras in general.
14:03:56 <edwardk_> jmcarthur: personally i prefer the use of g_hylo though, since you can see the way the functors get distributed, etc. have you looked at Control.Morphism.*
14:03:58 <edwardk_> ?
14:04:00 <alexyk> monoidal: o!
14:04:22 <alexyk> wait, I'm in a guard, will Just x work as a test??
14:04:43 <Silvah> AFAIK no.
14:05:02 <Saizan> pattern guards to the rescue!
14:05:11 <alexyk> my outer case if case <another value from DB> of Just v | <maxElems is set and we're under it...> -> ...
14:05:46 <monoidal> why not case ... of Just v | v < maxElems -> ?
14:06:24 <danharaj> In my curiosity about more powerful type systems, I have decided to explore either Coq or Agda. Right now I feel like Coq is the better option, because it is more mature, but how do you guys feel?
14:06:36 <alexyk> I have a maxElems parameter to the iterator which is Maybe, so I need to check whether it's set.  I'm already in the case for Maybe v returned from DB.  Do I really have to have a nested case?
14:06:53 <jmcarthur> edwardk_: yes i have. i'm using it as one of my references
14:07:22 <ddarius> danharaj: Coq is more mature and has a lot of tooling.  Agda is more geared toward being a programming language as opposed to a theorem prover and has a more Haskelly syntax.
14:07:22 <edwardk_> danharaj: coq is fine as long as you don't mind going out to the source to figure out what something means
14:07:40 * alexyk wonders why there isn't inferior-haskell-load-line.
14:07:51 * alexyk or -block.
14:08:04 <alexyk> that's such a bummer
14:08:13 <Saizan> alexyk: case <another value from DB> of Just v | Just x <- maxElems ... -> ...
14:08:26 <Saizan> alexyk: with {-# LANGUAGE PatternGuards #-}
14:08:29 <edwardk_> i'm sure there is a joke about how it is because haskell is never inferior in there somewhere ;)
14:08:35 <danharaj> How about working with (Coq | Agda) as a supplement Haskell? I know some people release libraries in Haskell that are verified with Coq.
14:08:44 <Saizan> alexyk: also, you might want to learn how to use the Maybe monad :)
14:08:50 <alexyk> edwardk_: in Emacs, Haskell is inferior to emacs lisp
14:09:02 <gwern> yi sets that aright
14:09:27 <edwardk_> danharaj: the problem is the generated libraries tend to be hardly idiomatic since it is a pain in the neck to bind generated code to built in haskell data types from the prelude
14:09:39 <alexyk> Saizan: Kust x <- maxElems?
14:09:41 <alexyk> Just
14:10:02 <Saizan> yep, that's the syntax of PatternGuards
14:10:05 <ddarius> danharaj: With Coq you can extract Haskell, but I wouldn't put the resulting code in a library...
14:10:17 <Saizan> you might check the ghc manual for details, maybe
14:10:25 <alexyk> Saizan: interesting
14:11:08 <danharaj> Ah, I see.
14:11:08 <Saizan> danharaj: you can import Haskell functions into Agda
14:11:13 <alexyk> but probably nested case is easier since I don't want to decompose maxElems every DB item
14:11:35 <gwern> ddarius: why not? keep the Coq, and everytime you modify the coq, do a fresh compilation
14:11:50 <gwern> library users don't have to read the code, just use it
14:12:24 <soupdragon> I tried writing a haskell library and coq verificcation of iti in parallel... really didin't work
14:12:42 <soupdragon> then I tried to do it in just Coq and got a bit further but still reached a point where nothing happened
14:13:06 <Saizan> the translation from Coq to Haskell uses a fair amount of unsafeCoerce from and to (), and GHC didn't like that so much, though that's probably solved using GHC.Any
14:13:08 <danharaj> Saizan: Is that wise? I thought Agda was total.
14:14:34 <Saizan> danharaj: well i thought haskell was pure, but we still import C functions :)
14:14:37 <jmcarthur> agda has a termination checker but will happily let you write nonterminating code
14:14:48 <danharaj> Saizan: Touche :p
14:15:54 <Saizan> iirc what happens is that you postulate something, and then tell the compilation layer to map them to specific haskell bits
14:16:54 <Saizan> http://www.cs.nott.ac.uk/~nad/repos/lib/src/IO/Primitive.agda <- e.g
14:17:34 <alexyk> is there an increent in Prelude? (+1)
14:17:42 <alexyk> increment
14:17:44 <jkramer> Is it a good idea to start learning/using HaskellDB?
14:17:48 <ClaudiusMaximus> :t succ
14:17:49 <lambdabot> forall a. (Enum a) => a -> a
14:18:03 <jkramer> Looks like development stopped some time ago
14:18:04 <alexyk> ClaudiusMaximus: thx
14:18:13 <alexyk> succulent
14:18:38 <ClaudiusMaximus> depending on context, (+1) might be clearer
14:19:08 <alexyk> I eed to recurse with an incremented count, succ is better or I'd have to ((+1) count)?
14:19:41 <alexyk> need, these Apple bluetooth leyboards are skinny
14:19:46 <alexyk> keyboards
14:19:56 <ClaudiusMaximus> personally i'd use something like let f count = ... f ... (count + 1) ...
14:19:57 <jmcarthur> not using explicit recursion is best if you can help it
14:20:04 <Saizan> alexyk: what's wrong with (count + 1) ?
14:20:05 <Taejo> I'm playing around with compiler backends, code generation and VMs, and I'm wondering if there's a really simple imperative language to compile, with an already existing parser and a simple AST, preferably in Haskell. Anyone know of such a thing? (I looked at Language.C, but that's too featureful -- I only need two types: ints and arrays)
14:20:36 <jmcarthur> Taejo: you could just make an AST and not worry about the parser if you don't care about that part
14:20:37 <alexyk> Saizan: duh, after a Clojure project infix is still fresh :)
14:20:52 <Taejo> jmcarthur: because I want to write programs for it :)
14:21:19 * hackagebot records 0.1.1.0 - A flexible record system  http://hackage.haskell.org/package/records-0.1.1.0 (WolfgangJeltsch)
14:21:49 <jmcarthur> Taejo: you could use Language.C and just not bother supporting the entire thing
14:22:00 <Taejo> true
14:22:04 <jmcarthur> using error where you don't care
14:25:07 <alexyk> I need to match getArgs to [x,maxEems].  If getArgs is just one element, maxElems becomes Nothing, if two or more, Just second.  hat's the shortest way?
14:25:16 <alexyk> What's
14:25:58 * alexyk going for cuteness
14:26:30 <alexyk> or silly if will be appropriate?
14:27:15 <zygoloid> [x,maxElems] <- (++repeat Nothing) <$> getArgs
14:27:26 <zygoloid> almost :/
14:27:33 <zygoloid> (x:maxElems:junk) <- (++repeat Nothing) <$> getArgs
14:27:34 <xerox> looks neat
14:27:44 <xerox> _ instead of junk?
14:27:56 <Saizan> it won't typecheck though.
14:28:02 <BMeph> alexyk: Please note that my Haskell-fu is weak, but I'd do: (x:ys) <- getArgs; let maxElems = listToMaybe ys
14:28:03 <zygoloid> no, sadly not
14:28:07 <c_wraith> that requires that getArgs return Maybes
14:28:27 <Saizan> (x:xs) <- getArgs; let maxElems = listToMaybe xs; ... ?
14:28:28 <zygoloid> ((++repeat Nothing) . map Just) <$> getArgs is halfway to ulgyville though
14:28:31 <alexyk> wow
14:28:31 <BMeph> alexyk: Cute enough for you? ;)
14:28:47 <alexyk> BMeph: I retreat into a case :)
14:29:05 <alexyk> but <$> sure is cute
14:29:43 <xerox> . instead of <$> is even better
14:29:47 <Raynes> alexyk: What we really need is a <('.'<) function.
14:30:02 <alexyk> Raynes: we need an awww!
14:30:19 <EvanR-work> > do x<-[1]; (x++) []; print x
14:30:20 <lambdabot>   Couldn't match expected type `[b]'
14:30:20 <lambdabot>         against inferred type `GHC.IOBas...
14:30:45 <EvanR-work> > do (x--)
14:30:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:31:00 <alexyk> where does listToMaybe come from?
14:31:06 <EvanR-work> :t listToMaybe
14:31:07 <lambdabot> forall a. [a] -> Maybe a
14:31:08 <soupdragon> Data.Maybe
14:31:11 <alexyk> ok
14:31:43 <EvanR-work> you sure are doing a lot of maybe!
14:32:06 <zygoloid> (x, maxElems) <- (head &&& listToMaybe . tail) <$> getArgs
14:32:40 <c_wraith> heh.  That one's not horrible.
14:33:04 <zygoloid> stop it, i'm blushing ;-)
14:33:53 <alexyk> EvanR-work: maybe
14:34:12 <aavogt> ([x], maxElems) <- fmap listToMaybe . splitAt 1 <$> getArgs
14:35:13 <c_wraith> Don't you want (Just x,.. in the pattern for that?
14:35:25 <aavogt> here no
14:35:36 <zygoloid> that's the (,) fmap :)
14:35:37 <aavogt> the fmap is to apply a function to the snd
14:35:37 <c_wraith> oh, right.
14:35:53 <c_wraith> forgot the return type of splitAt. ;)
14:36:02 <aavogt> ([x], listToMaybe -> maxElems) <- splitAt 1 <$> getArgs
14:36:08 <EvanR-work> @src []
14:36:08 <lambdabot> data [] a = [] | a : [a]
14:36:11 <c_wraith> view patterns!
14:36:18 <aavogt> splitAt 1 -> ([x], listToMaybe -> maxElems) <- getArgs --- do you need parens ;)
14:36:27 * hackagebot ghc-core 0.5.4 - Display GHC's core and assembly output in a pager  http://hackage.haskell.org/package/ghc-core-0.5.4 (DonaldStewart)
14:36:46 <EvanR-work> @src (,)
14:36:47 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:36:48 <shadwick> hmm.. does anyone have any suggestions for how to apply the Sieve of Eratosthenes? I'm very new to haskell and I'm having trouble thinking in-line with a functional language such as this...
14:37:01 <aavogt> @type do splitAt 1 -> ([x], listToMaybe -> maxElems) <- getArgs; return ()
14:37:02 <lambdabot> parse error on input `->'
14:37:11 <jmcarthur> :t (<('.'<))
14:37:12 <lambdabot> (Char -> Bool) -> Bool
14:37:13 <aavogt> @type do (splitAt 1 -> ([x], listToMaybe -> maxElems)) <- getArgs; return ()
14:37:14 <lambdabot>     Illegal view pattern:  (splitAt 1 -> ([x],
14:37:14 <lambdabot>                                           (listToMaybe -> maxElems)))
14:37:14 <lambdabot>     Use -XViewPatterns to enable view patterns
14:37:14 <c_wraith> shadwick: is this homework?  (Not accusatory, just want to know what sort of answer to give)
14:37:14 <soupdragon> @let naturals = [2..]
14:37:16 <lambdabot>  Defined.
14:37:22 <EvanR-work> shadwick: well you can start by translating the iterative algorithm into haskell directly
14:37:28 <soupdragon> @let divisible k n = n`mod`k == 0
14:37:30 <lambdabot>  Defined.
14:37:34 <shadwick> c_wraith: purely out of interest :)
14:37:41 <danharaj> shadwick: I like to start by defining the signature of a function when defining it.
14:37:43 <c_wraith> If it's purely out of interest...
14:37:49 <soupdragon> > filter (not . divisible 7) . filter (not . divisible 5) . filter (not . divisible 3) . filter (not . divisible 2) $ naturals
14:37:51 <lambdabot>   [11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107...
14:37:59 <soupdragon> shadwick ^
14:38:08 <shadwick> soupdragon: jesus
14:38:23 <jmcarthur> > const 'a' <('.'<)
14:38:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:38:24 <lambdabot>         against inferred type...
14:38:27 <c_wraith> If it's purely out of interest....   http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf  All you might ever want to know about the topic.
14:38:28 <alexyk> soupdragon: and then 11 comes along :)
14:38:30 <jmcarthur> duh
14:38:35 <alexyk> and the guys gets an F!
14:38:51 <jmcarthur> > (=='a') <('.'<)
14:38:52 <lambdabot>   *Exception: (==): No overloading for function
14:39:06 <jmcarthur> this might be a symptom of vector-space
14:39:29 <zygoloid> @type do (x:(listToMaybe -> maxElems)) <- getArgs; return (x, maxElems)
14:39:30 <lambdabot>     Illegal view pattern:  (listToMaybe -> maxElems)
14:39:31 <lambdabot>     Use -XViewPatterns to enable view patterns
14:39:31 <lambdabot> Not in scope: `getArgs'
14:40:02 <dpratt71> so there's this package I want to install that depends on the "unix" package...
14:40:03 <aavogt> > do (splitAt 1 -> ([x], listToMaybe -> maxElems)) <- return "hello"; return (x,maxElems)
14:40:04 <lambdabot>   No instance for (GHC.Show.Show
14:40:04 <lambdabot>                     (m (GHC.Types.Char, Data...
14:40:12 <dpratt71> ...and I'm on Windows :)
14:40:23 <aavogt> > do (splitAt 1 -> ([x], listToMaybe -> maxElems)) <- return "hello"; Just (); return (x,maxElems)
14:40:24 <lambdabot>   Just ('h',Just 'e')
14:40:36 <dpratt71> the "unix" package says it's unsupported on Windows, except under cygwin
14:40:51 <dpratt71> but I'm not having success trying to configure it under cygwin
14:41:10 <dpratt71> before I start asking more specific questions, is this ever likely to work?
14:41:20 <aavogt> > do (x : listToMaybe -> maxElems) <- return "hello"; Just (); return (x,maxElems)
14:41:21 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
14:41:21 <lambdabot>         against inferre...
14:41:31 <aavogt> > do (x : (listToMaybe -> maxElems)) <- return "hello"; Just (); return (x,maxElems)
14:41:32 <lambdabot>   Just ('h',Just 'e')
14:41:45 <soupdragon> @let smack (x:xs) = x : filter (not . divisible x) (smack xs)
14:41:46 <lambdabot>  Defined.
14:41:48 <danharaj> What are the differences between Coq and Agda as proof assistants? I see that Coq is based on proof tactics. How about Agda?
14:41:49 <soupdragon> > smack naturals
14:41:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
14:42:01 <aavogt> zygoloid: you sort of start forgetting you can use patterns anymore
14:42:07 <soupdragon> danharaj agda has no way to write proofs except directly
14:42:18 <alexyk> > 11 `elem` (smack naturals)
14:42:18 <aavogt> or maybe that's just me
14:42:19 <lambdabot>   True
14:42:23 <soupdragon> i.e. literally writing out the case analysis and axioms and such as lambda terms
14:42:36 <zygoloid> aavogt: yeah. are we done now, or can we still do better? :)
14:42:41 <alexyk> > 121 `elem` (smack naturals)
14:42:45 <lambdabot>   mueval-core: Time limit exceeded
14:43:04 <aavogt> zygoloid: no or-patterns :(
14:43:10 <alexyk> need a smarter check than elem, sorted-elem
14:43:44 <aavogt> @type elem =<< takeWhile
14:43:45 <lambdabot>     Couldn't match expected type `[a]'
14:43:45 <lambdabot>            against inferred type `a1 -> Bool'
14:43:45 <lambdabot>     In the second argument of `(=<<)', namely `takeWhile'
14:43:55 <danharaj> soupdragon: no sugar?
14:43:59 <aavogt> @type elem <=< takeWhile . (==)
14:44:00 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
14:44:01 <lambdabot>       Expected type: b
14:44:01 <lambdabot>       Inferred type: [b]
14:44:11 <aristid> :t (<=<)
14:44:12 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:44:22 <aristid> @src <=<
14:44:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:44:31 <soupdragon> @let monotonicSearch y (x:xs) | x == y = True ; monotonicSearch y (x:xs) | x > y = False ; monotonicSearch y (x:xs) | x < y = monotonicSearch y xs
14:44:32 <lambdabot>  Defined.
14:44:39 <soupdragon> > monotonicSearch (11^2) (smack naturals)
14:44:40 <lambdabot>   False
14:44:46 <aavogt> @type \x -> find x . takeWhile (x >=)
14:44:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> Bool
14:44:48 <lambdabot>     Probable cause: `x' is applied to too few arguments
14:44:48 <lambdabot>     In the first argument of `(>=)', namely `x'
14:44:56 <aavogt> @type \x -> elem x . takeWhile (x >=)
14:44:57 <lambdabot> forall a. (Ord a) => a -> [a] -> Bool
14:45:04 <soupdragon> @@ @oies @run smack naturals
14:45:06 <lambdabot> Plugin `compose' failed with: Unknown command: "oies"
14:45:13 <soupdragon> @@ @oeis @run smack naturals
14:45:15 <lambdabot>  Sequence not found.
14:45:21 <soupdragon> ....
14:45:26 <aristid> :t \a b c -> return c >>= b >>= a
14:45:27 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a1 -> m b) -> (a -> m a1) -> a -> m b
14:45:33 <soupdragon> how do I get rid of the []'s?
14:45:34 <aavogt> @type elem <=< (takeWhile . (>=))
14:45:35 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
14:45:35 <lambdabot>       Expected type: b
14:45:35 <lambdabot>       Inferred type: [b]
14:45:44 <aristid> @pl \a b c -> return c >>= b >>= a
14:45:45 <lambdabot> flip (flip . ((>>=) .))
14:45:52 <aavogt> soupdragon: text, show and drop 1 or so
14:45:53 <soupdragon> @@ @oeis @run intercalate "," . map show $ smack naturals
14:45:56 <lambdabot>  Prime sum of n-th group of successive primes in A073684.
14:45:56 <lambdabot>  [5,23,101,109,263,211,251,757,1367,941,2053,1901,911,2347,1861,1187,1249,130...
14:46:00 <aristid> so <=< is \a b c -> return c >>= b >>= a ?
14:46:19 <aavogt> you can drop the return c >>=
14:46:24 <aavogt> and write   b c >>= a
14:46:30 <aristid> :t smack
14:46:31 <lambdabot> forall t. (Integral t) => [t] -> [t]
14:46:44 <aavogt> @type elem =<< (takeWhile . (>=))
14:46:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = [[a] -> [a]]
14:46:46 <lambdabot>       Expected type: [[a] -> [a]]
14:46:46 <lambdabot>       Inferred type: a
14:46:52 <aristid> :t naturals
14:46:53 <lambdabot> forall t. (Num t, Enum t) => [t]
14:46:56 <aristid> > naturals
14:46:57 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
14:47:02 <alexyk> when is lambdabot's gut purged of smack?
14:47:03 <aavogt> @pl \x -> elem x . takeWhile (x >=)
14:47:04 <lambdabot> liftM2 (.) elem (takeWhile . (>=))
14:47:09 <aristid> why are 0 and 1 not in nautrals?
14:47:13 <soupdragon> lol
14:47:21 <aavogt> it's unnatural
14:47:22 <soupdragon> number start at 2 as far as I am concerned
14:47:34 <aavogt> never mind this debate about 0
14:48:37 <aavogt> @pl \x -> elem x (takeWhile (x >=))
14:48:37 <lambdabot> ap elem (takeWhile . (>=))
14:49:14 <aavogt> @type [ap, (=<<), \f g x -> f x (g x)]
14:49:15 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
14:50:36 <aristid> @type [ap, (=<<)]
14:50:37 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
14:50:44 <aristid> :t ap
14:50:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:50:51 <aristid> :t (=<<)
14:50:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:51:17 <aristid> aavogt: woah
14:51:55 <aavogt> interesting that you don't need the last element there to unify those types
14:51:58 <soupdragon> @pl \f g x -> f x (g x)
14:51:59 <lambdabot> ap
14:52:16 <aavogt> which is the implementation for those two functions in the  (a -> ) monad instance
14:52:19 <soupdragon> :t const ap
14:52:21 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => b1 -> m (a -> b) -> m a -> m b
14:52:22 <soupdragon> :t ap const
14:52:23 <lambdabot> forall b a. (b -> a) -> b -> b
14:52:36 <soupdragon> :t const . ap
14:52:37 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m (a -> b1) -> b -> m a -> m b1
14:52:38 <soupdragon> :t ap . const
14:52:39 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
14:52:53 * aristid hides in a corner
14:52:54 <aavogt> what's your goal here, soupdragon?
14:53:17 <soupdragon> with ap and const? or more generally?
14:53:31 <aavogt> > map unwords $ permutations (words "const ap .")
14:53:32 <lambdabot>   ["const ap .","ap const .",". ap const","ap . const",". const ap","const . ...
14:54:16 <aavogt> soupdragon: whichever
14:54:35 <monochrom> interesting. ghc 6.10.4 linux binary was 75MB. 6.12.1 is 102MB
14:54:38 <aavogt> @type ap const const
14:54:39 <lambdabot> forall b. b -> b
14:54:50 <soupdragon> I really don't know - I wish I knew
14:54:56 <monochrom> ghc binaries satisfy moore's law!! XD
14:55:04 <aristid> > length . permutations (words "const ap .")
14:55:05 <lambdabot>   [3,3,3,3,3,3]
14:55:06 <aavogt> the binary itself?
14:55:19 <aristid> > length $ permutations (words "const ap .")
14:55:20 <lambdabot>   6
14:55:46 <aavogt> or the whole distribution?
14:56:13 <aristid> monochrom: imagine how big ghc 6.18 will be.
14:57:39 <aavogt> I think it jumps occasionally, ex when profiling libraries were added (which must have been long ago)
14:57:43 <byorgey> matt_m: noted, thanks
15:02:51 <monochrom> takes more than 1 minute to tar -xjf !!
15:02:58 <Saizan> soupdragon: agda got reflection support recently! it quotes goals automatically, we'd have to write the solvers though :)
15:03:51 <monochrom> Oh God, we quote Agda in Adga so you can eval while you eval...
15:04:49 <Saizan> .. while you typecheck
15:04:58 <gwern> @quote dawg
15:04:58 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
15:05:29 <monochrom> hehehe
15:08:42 <aristid> a lisp joke?
15:08:53 <hydo> I think Database.CouchDB thinks I'm going to give up.  Noooo... no sir.  Not gonna happen.
15:09:43 <aristid> couchdb is soo 2009
15:10:18 <winxordie> aristid: Haskell is so 1990
15:10:26 <hydo> oh snap
15:10:33 <hydo> buurrrrnnn
15:10:49 <aristid> winxordie: back then, they at least used real functional I/O based on lazy lists
15:10:57 <aristid> not this fancypants "monads" shit
15:11:00 <Zao> My other CAR is a ...
15:11:04 <winxordie> Lol.
15:11:42 <winxordie> aristid: O.o? Now that I think about it, I don't know what functional I/O means without monads.
15:11:48 <winxordie> I think I've been monad-impaired.
15:12:16 <aristid> winxordie: see.
15:16:30 <monochrom> Haskell is so 1990. Go is so Algol 60.
15:17:05 <systemfault> Algol 2010 :P
15:19:40 <monochrom> Andrew Gordon has a PhD thesis on functional I/O. The three methods are lazy lists, continuation passing style, and monad. The thesis seems to commend monad.
15:21:13 <ksf> http://shootout.alioth.debian.org/u32/performance.php?test=knucleotide
15:21:16 <ksf> timeout?!
15:23:26 <ksf> http://hackage.haskell.org/trac/ghc/ticket/3149
15:23:43 <ksf> simon says data.hashtable is fast, now.
15:24:12 <gwern> benchmarks or gtfo
15:25:29 <mreh> the lambdacube examples are just blank when I run them
15:25:53 <mreh> it's doing something though
15:26:35 <Saizan> ksf: do you know why dons's solution doesn't appear in the ladder?
15:26:45 <winxordie> monochrom: All the way back to Algol 60 eh? I thought it was more Modula-ish.
15:26:47 <blobl> is there a way to avoid passing another variable from function to function? i have the feeling im doing something wrong
15:27:07 <mreh> blobl: Reader/State monad?
15:27:12 <mauke> local functions?
15:27:36 <mauke> teleporting values through the type system, oleg style?
15:27:49 <zygoloid> ksf: looks better but still pretty terrible?
15:27:54 <mreh> who is this being you speak of, Oleg?
15:28:20 <blobl> mreh: maybe i should be reading more.. cause im doing this think with mvars :) thanks seems like it
15:28:25 <monochrom> winxordie: on the serious side, there was a satire comparing Go with Algol 60 or 68. on the light side, don't you think "Go is so Algol" rhymes better? :)
15:28:35 <BMeph> Io (the old one) used CPS as its only control mech., even including forming data structures. I like it very much. :)
15:28:43 <gwern> @quote OlegFact
15:28:44 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:28:45 <gwern> @quote OlegFacts
15:28:46 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
15:28:51 <gwern> hm.
15:28:54 <gwern> @quote OlegFact.*
15:28:54 <lambdabot> No quotes match. Maybe you made a typo?
15:29:00 <gwern> curse you @quote!
15:29:02 <winxordie> monochrom: gotcha - didn't know that. it is kinda catchy.
15:29:04 <mreh> @quote Oleg
15:29:04 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
15:29:28 <zygoloid> @quote oleg
15:29:29 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
15:29:30 <mreh> is the type system turing complete?
15:29:32 <BMeph> Go is compared to Algol 60, only because it is demonstrably inferior to Algol 68. Ya, RLY! :|
15:30:26 <aavogt> mreh: with the right ghc extensions
15:30:33 <Saizan> mreh: if you turn on some flags with Undecidable in the name
15:30:58 <mreh> You'd need recursive types
15:31:08 <mreh> uuhhh, yeah
15:31:12 <gwern> or iterative types
15:31:13 <mreh> like in Haskell!
15:31:29 <gwern> which we can co-tail-call-check into recursive types!
15:31:36 <winxordie> I thought Algol 68 was terrible in comparison to Algol 60. Not that I programmed in it...
15:31:55 <mreh> didn't map-reduce come from Algol?
15:31:56 <gwern> did anyone program in them? I thought they all remained largely theoretical & unimplemented
15:32:16 <`0660> our shop is still a pure algol shop
15:32:25 <`0660> never had the need to change...
15:32:29 <winxordie> I know a lot of guys did Algol 60
15:32:30 <`0660> :P
15:32:30 <mreh> what is an Algol
15:32:45 <gwern> Algol is a character in Soul Calibur
15:32:52 <mreh> how old are you guy?
15:32:54 <gwern> sort of a magical mutable-weapon character
15:33:19 <gwern> (IMO, he's pretty rubbish compared to the old standbies like Mitsurugi or Seung Mina)
15:33:33 <Astrobe> Used to program under Algohol. Got fired.
15:33:50 <`0660> no demand for algol? :)
15:33:54 <gwern> I hear Algol is also some sort of star
15:33:59 <gwern> `0660: not from me, heck no.
15:34:42 <BMeph> gwern: In Orion, I think... :)
15:35:14 <gwern> BMeph: exactly! it's on Orion's belt!
15:36:34 <mreh> that's funny, they named a star after a programming language
15:38:31 <winxordie> Still preferable to letters o' the English alphabet.
15:39:03 <aavogt> o' is a letter?
15:39:13 <mreh> I thought they used greek letters
15:40:45 <gwern> there are so many stars I think they use whatever they can
15:42:05 <aavogt> but even ones you can see?
15:42:43 <gwern> aavogt: you ever been out in a rural undeveloped area to really see the stars?
15:42:51 <aavogt> yes
15:43:36 <gwern> how many dozens of thousands stars would you say were visible?
15:43:49 <aavogt> millions
15:43:55 <mreh> is that a baker's dozen?
15:43:57 <gwern> well, there you go then
15:44:02 <aavogt> you can still run out
15:44:15 <aavogt> also, I'm not sure they would accept vulgar names
15:44:40 <burp> http://www.astrosurf.com/sguisard/
15:44:43 <gwern> the biologists eventually did, and there are more stars than species
15:44:44 <burp> *offtopic link*
15:45:02 <burp> but I love these photos :>
15:45:11 <aavogt> oh no, phylogeneticists like renaming things
15:45:35 <gwern> aavogt: mein gott! even more need for names
15:45:35 <aavogt> much like the monad-applicative-functor situation... but worse
15:46:03 <aavogt> gwern: nah, stars are usually given some systematic number name
15:46:21 <aavogt> galaxies at least
15:49:34 <gwern> those poor desparate astronomers
15:51:24 <arw> currently there are only automatic sky surveys left, and they only systematically number the stars.
15:51:47 * monochrom is now at ghc 6.12.1 and haskell platform 2010.1.0.0!
15:51:50 <arw> but even the first surveys, some 150 years ago just used some kind of numbering scheme...
15:54:46 <vermin_slam> hello, i've been trying to install yi for a while, and i think i'm close, i'm using the command line "cabal install yi -f-vty -fpango --reinstall", and it wants gtk and glib 0.10.*. I have gtk and glib 0.11.0, and cabal says there are no other versions. I'm on windows XP, what should I do to make Yi happy?
15:56:40 <gwern> vermin_slam: yi specifies 0.10.* probab;y because no dev has actually tried with a more recent gtk2hs
15:56:59 <gwern> vermin_slam: suggest you cabal unpack yi, loosen the dep and mail yi-devel whether it worked or not
15:57:02 * BMeph resists the urge to tell vermin_slam to run a VM and use Arch...down, impulses, DOWN! ;)
15:57:17 <vermin_slam> okay, i'll try that out
15:57:29 <soupdragon> oooh
15:57:33 <soupdragon> I should try arch in the VM
15:57:34 <monoidal> is there a Haskell interface to ghc-pkg?
15:57:38 <soupdragon> hmm
15:57:45 <vermin_slam> yeah, I've actually considered that BMeph, but I think that might have a steeper learning curve :)
15:58:30 <gwern> monoidal: you mean besides shelling out?
15:58:30 <aavogt> monoidal: the Cabal library
15:59:12 <aavogt> in some sense it does similar things as ghc-pkg
15:59:18 <aristid> vermin_slam: i don't know if ubuntu has sufficiently recent packages, but that would have a very unsteep learning curve.
15:59:37 <monoidal> i'd like to do ghc-pkg list within haskell, without using system
16:01:27 <monochrom> Distribution.Simple.GHC probably does that.
16:03:12 <monoidal> yes, thanks
16:03:54 <monoidal> it's probably something like getInstalledPackages normal [GlobalPackageDB] emptyProgramConfiguration, but this gives me irrefutable pattern failed
16:05:32 <vermin_slam> i'll be building with the modified dependencies soon, and i will check out the VM + linux apparoach if i give up on windows
16:06:40 <aavogt> monoidal: I think you have to do something with emptyProgramConfiguration
16:10:01 <dpratt71> installing the "unix" package under cygwin, getting errors: "* Missing header file: HsUnix.h" and "* Missing C libraries: rt, dl"
16:10:07 <dpratt71> ideas?
16:11:04 <ksf> gosh no modify in Data.Hashtable?
16:11:08 <ksf> how did that happen?
16:16:58 <soupdragon> > let isCube n = let k = fromIntegral (floor (n**(1/3))) in k^3 == n || (k+1)^3 == n in head [(a,b,a^3+b^3)|a <- [2..], b <- [2..a],isCube(fromIntegral(a^3+b^3::Integer)::Double)]
16:17:02 <lambdabot>   mueval-core: Time limit exceeded
16:17:03 <soupdragon> what's up with this??
16:17:11 <soupdragon> I can't find a cube that is the sum of two cubes
16:18:29 <mauke> 0, 0, 0
16:18:38 <soupdragon> nontrivial ones
16:19:09 <mauke> 0, 1, 1
16:19:23 <soupdragon> ones that aren't boring
16:20:11 <monoidal> fermat last theorem?
16:20:29 <soupdragon> > map (`mod`7) . map (^3) $ [0..7-1]
16:20:31 <lambdabot>   [0,1,1,6,1,6,6]
16:20:36 <soupdragon> monoidal, oh blegh!! you're right
16:20:40 <soupdragon> I didn't even think :)
16:20:55 <mauke> wait, that wasn't a joke?
16:21:47 <aristid> @free map
16:21:48 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
16:22:18 <soupdragon> how can I prove FLT for n=3?
16:22:24 <soupdragon> is it easy?
16:23:00 <aristid> probably easier than the general proof at least
16:23:02 <soupdragon> one of the terms must be equal to 0 mod 7
16:23:19 <monoidal> http://en.wikipedia.org/wiki/Proof_of_Fermat's_Last_Theorem_for_specific_exponents#n.C2.A0.3D.C2.A03
16:23:38 <soupdragon> "The case n = 3 was proven by Euler in 1770.[28][29][30]  Independent proofs were published by several other mathematicians,[31]  including Kausler[5], Legendre,[7][32]  Calzolari,[33]  Lam,[34]  Tait,[35]  Gnther,[36]  Gambioli,[16]  Krey,[37]  Rychlik,[21]  Stockhaus,[38]  Carmichael,[39]  van der Corput,[40], Thue,[41]  and Duarte.[42]"
16:28:44 <nus> "...also by soupdragon[43] on #haskell playing with lambdabot."
16:28:50 <soupdragon> :D
16:32:42 <aristid> s/lambdabot/fermatbot/?
16:34:30 <ivanm> dibblego: have you seen this? http://www.reddit.com/r/programming/comments/c95so/why_functional_programming_will_not_take_over_the/
16:34:42 <aristid> i suppose for each person there's a point where, for simpler code, point-free is easier to read, and more complex code is better with some points
16:35:19 <aristid> at least this, upperEcho c = putChar (toUpper c), is harder to read for me then upperEcho = putChar . toUpper
16:35:29 <dibblego> ivanm, yes, I have seen many stupid things on the internet
16:35:51 <ivanm> but his argument is even weaker and stupider than most I've seen
16:36:05 <ivanm> "FP is bad because people don't think that way; people think in COBOL!"
16:36:20 <ivanm> (OK, he didn't quite say people think in COBOL, but still...)
16:36:21 <dibblego> ivanm, I've seen them all (actually, I hadn't seen that particular article -- just arguments of similar stupidity)
16:36:47 <EvanR> people think in OOP!
16:37:19 <ivanm> EvanR: his argument was that people think imperatively
16:37:28 <ivanm> not functionally
16:37:30 <BMeph> EvanR: Of course! THAT'S why people say "Oops!" all the time, I always wondered... ;)
16:37:32 <chrisdone> haha there's a pattern of blogs spouting ignorant hyperbole which have big pictureds for dems readers
16:37:57 <ivanm> people then point out that people usually don't think like a program, and the submitter bitches about how people hate him for no reason
16:38:01 <ivanm> BMeph: heh
16:38:04 <aristid> not like it matters if anything takes over the world
16:38:22 * ivanm doesn't get all the people that are so desperate for people to read their no-content blogs that they put every single one of their entries on reddit
16:38:55 <chrisdone> ivanm: to acquire readership?
16:39:19 <ivanm> *shrug* maybe
16:39:47 <ivanm> it's much more likely they're wanting ad money which I can't tell because of adblock...
16:39:48 <ivanm> ;-)
16:42:28 <zachk> how do i make this work ? http://pastebin.com/VkhYnEzL
16:43:10 <ivanm> zachk: it depends; what are you trying to do?
16:43:12 <zachk> i tried map (a:) genList
16:43:44 <ivanm> zachk: note that your types are wrong; it will return [Bool]
16:44:10 <zachk> but i want it to be [[Bool]]
16:44:11 <ivanm> if you want [[Bool]], you need to have "map ([a]:) genList"
16:45:07 <ivanm> > let bs = [ map ([b]:) bs | b <- [True, False]] in bs
16:45:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:45:08 <lambdabot>         against inferred type ...
16:45:12 <ivanm> grrr...
16:45:20 <ivanm> > let bs = [ [b] : bs | b <- [True, False]] in bs
16:45:21 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:45:21 <lambdabot>         against inferred type ...
16:45:33 <zachk> that suggestion still doesnt work
16:45:44 <zachk> i tried map (map (a:)) genList as well
16:45:44 <ivanm> > let bs = [ map (b:) bs | b <- [True, False]] in bs
16:45:45 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:45:45 <lambdabot>         against inferred type ...
16:45:52 <mauke> please stop failing
16:45:54 <ivanm> zachk: what kind of outputs are you expecting?
16:45:58 <ivanm> mauke: sorry :(
16:46:37 <chrisdone> lol
16:46:56 <ivanm> zachk: you do realise that it will basically be an infinite list of [True, True ...] ?
16:46:59 <zachk> i would like an infinite list of infinite lists of all the possible true false combinations
16:47:11 <zachk> the whole thing will be?
16:47:32 <ivanm> zachk: there are an infinite number of ways of having a list start with [True, True, True, .....]
16:47:40 <zachk> mmm
16:47:47 <mreh> do you want the power set?
16:47:58 <ivanm> unless you be really clever in how you define it, the False values won't start appearing until the very end of the infinite list...
16:48:05 <chrisdone> > cycle $ permutations [True,False]
16:48:06 <lambdabot>   [[True,False],[False,True],[True,False],[False,True],[True,False],[False,Tr...
16:48:07 <mreh> um..
16:48:26 <mreh> you just want all the binary numbers don't you really
16:48:43 <soupdragon> > replicateM 6 "01"
16:48:44 <lambdabot>   ["000000","000001","000010","000011","000100","000101","000110","000111","0...
16:48:46 <mreh> seeing as the longest binary digit has infinite characters, it's hard to specify the smallest
16:48:49 <Randor> Hi
16:48:56 <aristid> @src replicateM
16:48:57 <lambdabot> replicateM n x = sequence (replicate n x)
16:49:05 <soupdragon> hi Randor
16:49:12 <aristid> > replicate 6 "01"
16:49:13 <lambdabot>   ["01","01","01","01","01","01"]
16:49:15 * ivanm waves idly in Randor's general direction
16:49:39 <zachk> mreh: im going for powerset and i thought about this first then using map (take n) on the list of lists and then zipping the result with an ordered list an and filtering out the falses
16:49:50 <aristid> > sequence ["01","01","01","01","01","01"]
16:49:52 <lambdabot>   ["000000","000001","000010","000011","000100","000101","000110","000111","0...
16:49:56 <aristid> woo
16:50:01 <soupdragon> > filterM (const [True,False]) "abcd"
16:50:02 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
16:50:04 <soupdragon> stolen from Cale...
16:50:10 <BMeph> Why physicists should not give CS lectures: "foldleft can be defined in terms of foldright but not vice-versa, since foldleft is strict in the tail of the list argument but foldright is not (i.e. fold_left acting on bottom gives bottom)."
16:50:24 <aristid> :t filterM
16:50:25 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:50:42 <ivanm> BMeph: huh?
16:50:56 <ivanm> BMeph: was that the lecturer or you that switched from foldleft to fold_left?
16:51:17 <soupdragon> BMeph, you know your baby is a physicists if he tries to put all the objects through the round hole
16:53:02 <BMeph> all: I looked for an example of how OCaml does foldr/l, and found http://www.matt-mcdonnell.com/code/code_ocaml/ocaml_fold/ocaml_fold.html which is where the quote above is found.
16:53:22 <aristid> AUGH EVIL BAKCGROUND
16:54:09 <ivanm> aristid: agreed
16:54:55 <ivanm> aristid: try the "zap colors" bookmarklet from https://www.squarefree.com/bookmarklets/zap.html
16:58:37 <BMeph> It seems his site interprets underscores as a markup to italicise. As well as put up that delightful wallpaper... ;)
17:00:08 <chrisdone> BMeph: looks markdown generated <pre><code> is typical markdown and _foo_ is markdown
17:02:00 <nus> @src fold
17:02:00 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:02:01 <nus> @src foldl
17:02:02 <lambdabot> foldl f z []     = z
17:02:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:02:04 <nus> @src foldl'
17:02:04 <lambdabot> foldl' f a []     = a
17:02:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:05:35 <monochrom> (are you done yet?)
17:06:54 <aristid> nus: http://cale.yi.org/index.php/Fold_Diagrams
17:07:37 <ivanm> ohhh, Cale has more of them?
17:07:53 <ivanm> I know he got some put on the wikipedia page, but didn't realise he had scan ones as well
17:07:54 <aristid> @pl \l -> foldr (:) [] l
17:07:54 <lambdabot> foldr (:) []
17:08:37 <ivanm> and I notice by the time he got to mapAccumR he discovered colour :p
17:09:07 <aristid> mapAccumR is confusing.
17:09:14 <aristid> even with the diagram
17:09:15 <ivanm> @type mapAccumR
17:09:16 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:09:19 <aristid> @src mapAccumR
17:09:19 <lambdabot> Source not found. Just try something else.
17:09:36 <ivanm> @type mapAccumL
17:09:37 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:10:28 <copumpkin> omg
17:11:00 <soupdragon> acc accc accc acc
17:11:11 <ivanm> hey copumpkin
17:11:23 <nus> aristid, I meant foldl vs foldl' vs the ocaml link
17:12:08 <aristid> i was hoping that @pl would simplify foldr (:) [] to id
17:12:14 <aristid> :t foldr (:) []
17:12:16 <lambdabot> forall a. [a] -> [a]
17:12:30 <copumpkin> ivanm: yo yo
17:12:50 <ivanm> nah, don't really feel like playing with my yo-yo
17:12:57 <ivanm> aristid: nope, it makes it point-free
17:13:05 <ivanm> doesn't do any analysis on what it would be better as
17:13:18 <aristid> ivanm: sometimes it also replaces complex stuff with simple stuff
17:13:34 <ivanm> really? usually it's the latter...
17:13:41 <ivanm> but it's just a whole bunch of transformation rules IIUC
17:13:52 <aristid> yeah sure
17:14:05 <aristid> we clearly need another command for betterifying expressions
17:14:28 <ivanm> not sure how general you could make such a command
17:14:46 <ivanm> e.g. how would it know that 2*2 == 2^2 == 2 + 2 ?
17:14:55 <aristid> general enough to replace foldr (:) [] with id
17:14:58 <aristid> and ($) with id
17:15:09 <aristid> and everything with id
17:15:12 <aristid> MWAHAHAHA
17:15:12 <ivanm> aristid: except you usually don't want to replace ($) with id
17:15:15 <ivanm> @slap aristid
17:15:16 * lambdabot pulls aristid through the Evil Mangler
17:15:23 <soupdragon> fuck
17:15:34 <ivanm> soupdragon: what?
17:15:59 <aristid> ivanm: it would also always use the (->) monad if somehow possible
17:16:01 <BMeph> @pl \f x -> f $ x
17:16:02 <lambdabot> id
17:16:22 * BMeph whistles innocently...and smirks!
17:17:06 <aristid> :t return id
17:17:06 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
17:17:06 <aristid> :t return id :: Int -> Int -> Int
17:17:06 <lambdabot> Int -> Int -> Int
17:17:18 <aristid> i should use () but somehow Int is easier to type
17:17:34 <BMeph> :t return id :: Int -> Int ->Int -> Int ->Int -> Int
17:17:35 <lambdabot>     Couldn't match expected type `Int -> Int -> Int -> Int'
17:17:36 <lambdabot>            against inferred type `Int'
17:17:36 <lambdabot>     In the first argument of `return', namely `id'
17:17:48 <BMeph> Shucks... ;)
17:18:00 <monoidal> it's (Int -> Int -> Int) -> Int -> Int -> Int
17:18:11 <BMeph> :t return id :: (Int -> Int) ->(Int -> Int) ->Int -> Int
17:18:12 <lambdabot> (Int -> Int) -> (Int -> Int) -> Int -> Int
17:18:19 <monoidal> oh, right
17:18:23 <BMeph> ...or that. :)
17:19:20 <BMeph> :t return id :: (Int -> Int ->Int) -> Int ->(Int -> Int)
17:19:21 <lambdabot>     Couldn't match expected type `Int -> Int'
17:19:21 <lambdabot>            against inferred type `Int'
17:19:21 <lambdabot>     In the first argument of `return', namely `id'
17:19:41 <aristid> :t return id :: forall a b. a -> b
17:19:42 <lambdabot>     Couldn't match expected type `b' against inferred type `a -> a'
17:19:42 <lambdabot>       `b' is a rigid type variable bound by
17:19:42 <lambdabot>           an expression type signature at <interactive>:1:22
17:19:43 <BMeph> Bah!
17:20:26 <aristid> oh it's too generic? :(
17:20:49 <monoidal> :t return :: e -> a -> e
17:20:50 <aavogt> @quote generalization
17:20:50 <lambdabot> forall e a. e -> a -> e
17:20:50 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
17:21:01 <aavogt> @quote unsafeCoerce
17:21:02 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
17:21:08 <aavogt> @quote unsafeCoerce
17:21:08 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
17:21:42 <aristid> :t return id :: a -> a
17:21:43 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
17:21:43 <lambdabot>       `a1' is a rigid type variable bound by
17:21:43 <lambdabot>            an expression type signature at <interactive>:1:13
17:21:43 <aavogt> aristid: a -> b is a bit too general :)
17:21:48 <aristid> :t return id :: a -> a -> a
17:21:50 <lambdabot> forall a. a -> a -> a
17:22:11 <aristid> aavogt: i want the most general return type that is still in the (->) monad
17:22:13 <aavogt> @type return id :: b -> a -> a
17:22:14 <lambdabot> forall b a. b -> a -> a
17:22:28 <aristid> thanks!
17:22:51 <monoidal> aristid: in (->r) monad, return is const
17:22:57 <aavogt> you can also add inline annotations to force the given monad:
17:23:11 <aavogt> @type do const; return id
17:23:12 <lambdabot> forall a a1. a -> a1 -> a1
17:23:32 <aristid> :t const id
17:23:34 <lambdabot> forall a b. b -> a -> a
17:23:42 <aristid> monochrom: that helps, heh
17:23:50 <aristid> @src (->) (>>=)
17:23:51 <lambdabot> f >>= k = \ r -> k (f r) r
17:24:09 <aristid> :t \f k r -> k (f r) r
17:24:10 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
17:25:25 <nus> @unpl (. f) . (g .)
17:25:26 <lambdabot> (\ e j -> g (e (f j)))
17:42:05 <EvanR> is there a general way that the compiler/runtime system can detect that you are in a (relatively simple kind of) infinite loop?
17:42:12 <soupdragon> yes
17:42:18 <EvanR> how does that work
17:42:26 <ivanm> EvanR: it already does, when it spits out <<loop>>
17:42:30 <EvanR> right
17:42:37 <ivanm> I'm guessing when you have something like foo = foo
17:42:40 <EvanR> i was wondering if that was limitted to trivial cases of let x = x in x
17:42:40 <soupdragon> I don't think I am qualified to explain it in detail but IIRC the Peyton book covers it
17:42:44 <ivanm> it can tell that the pointer references itself
17:42:55 <Berengal> EvanR: I think it only works when it's reentering a thunk it's already evaluating
17:43:05 <ivanm> EvanR: I've had a quite complex recursion amongst several functions be reduced to <<loop>> :s
17:43:12 <EvanR> wow
17:43:13 <ivanm> Berengal: yeah, something like that
17:43:20 <ivanm> soupdragon: SPJ has a book? :o
17:43:24 <EvanR> so it keeps a stack or something
17:43:28 <Berengal> What makes a reentrant thunk depends on optimizations, obviously
17:43:51 <Berengal> EvanR: Thunks are tagged with "under evaluation" iirc
17:44:05 <aavogt> ivanm: it's an old book
17:44:20 <aavogt> "implementation of functional languages" or something like that
17:44:26 <EvanR> so <<loop>> is like one realization of _|_
17:44:34 <EvanR> and so is undefined
17:44:35 <aristid> yes
17:44:45 <EvanR> but there are _|_ that will freeze the program
17:44:47 <EvanR> still
17:44:52 <Berengal> Yes
17:44:58 <EvanR> how do you get those ;)
17:45:11 <Berengal> f x = f (x - 1) :: Int
17:45:32 <aavogt> > let f x = f (x - 1) :: Int in f 0
17:45:36 <Berengal> Non-reentrant infinite loop
17:45:38 <lambdabot>  Terminated
17:45:44 <Berengal> Even with optimizations turned on
17:45:49 <aavogt> shouldn't \bot print <<loop>>?
17:45:55 <Berengal> > let x = x in x
17:45:58 <aristid> because it makes new thunks on the go?
17:45:58 <ivanm> aavogt: ahhh
17:45:59 <lambdabot>   mueval-core: Time limit exceeded
17:46:06 <pikhq> aavogt: GHCi doesn't do that.
17:46:10 <pikhq> Just GHC.
17:46:10 <pikhq> :)
17:46:26 <Berengal> <<loop>> only happens at -O or more, I think...
17:46:33 <pikhq> Also that.
17:47:54 <aavogt> uh, should that f actually trigger <<loop>>?
17:47:56 <aavogt> I can't
17:48:01 <Berengal> No, it shouldn't
17:48:16 <Berengal> It's a _|_ that will freeze the program
17:48:31 <Berengal> <<loop>> is _|_, but it doesn't freeze the program
17:48:46 <aavogt> but    f x = f x   triggers <<loop>>
17:48:58 <Berengal> It does?
17:49:10 <aavogt> because that cycle for   f x = f (x-1) :: Int is quite long
17:49:25 <aavogt> Berengal: yes it does
17:49:41 <Berengal> aavogt: It's put that on GHC being a Sufficiently Smart compiler then
17:49:57 <Berengal> doing CSE like that...
17:50:06 <aavogt> is there CSE there?
17:50:20 <aavogt> to evaluate f x you must first evaluate f x
17:50:27 <EvanR> is there a way to detect these things without compiling into machine code
17:50:49 <aristid> aavogt: the compiler could directly translate it to <<loop>>?
17:50:59 <Berengal> Yes, because <<loop>> only happens when you're entering the same thunk, and since you didn't specify that the thunks were the same in the code, GHC must've done it for you using CSE
17:51:06 <ivanm> I think it does it at run-time rather than at compile-time
17:51:36 <aristid> or it translate f x = f x to f = f?
17:52:07 <EvanR> maybe a graph reducer could have a 'pattern recognizer' or something that triggers if your graph becomes periodic
17:52:32 <EvanR> if your graph ever arrives at a state it did before, youre in a loop
17:52:55 <aavogt> EvanR: except do you really want to keep track of all those previous states?
17:53:06 <gwern> sounds like a serious memory hog
17:53:15 <EvanR> could be reduced to a md5 sum? ;)
17:53:19 <Berengal> EvanR: That sounds like solving the halting problem (on an FSA)
17:53:41 <EvanR> cool i solved the halting problem
17:53:52 <aavogt> I don't think so, Berengal
17:53:53 <Berengal> It's not hard to do, just memory intensive
17:54:19 <aavogt> you can not halt without seeing the same state twice... if you have infinite states
17:54:42 <Berengal> aavogt: That's why I said FSA
17:54:46 <Berengal> The F means finite :P
17:55:00 <aavogt> true
17:55:03 <aristid> Berengal: the computer is a FSA anyways :P
17:55:13 <EvanR> all of CS is flawed
17:55:16 <EvanR> for that reason
17:55:36 <BMeph> > (minBound::Int) = minBound - 1
17:55:37 <lambdabot>   <no location info>: parse error on input `='
17:55:41 <Berengal> aristid: And that's my point. We can solve the halting problem for all real computers (assuming we have a sufficiently bigger computer than the one we're looking at)
17:55:42 <ivanm> EvanR: it doesn't work arbitrarily
17:55:46 <BMeph> > (minBound::Int) == minBound - 1
17:55:48 <lambdabot>   False
17:55:52 <aristid> Berengal: woo.
17:55:53 <ivanm> note that it is possible to have hash collisions as well
17:56:06 <EvanR> nah those cant happen ;)
17:56:09 <gwern> the turing machine is a lie
17:56:12 <gwern> time has 4 corners
17:56:17 <ivanm> Berengal: except then how do you solve the halting problem for the halting-problem-solving-computer?
17:56:23 <ivanm> gwern: O RLY?
17:56:30 <jbapple> > (minBound::Int) -1
17:56:31 <lambdabot>   9223372036854775807
17:56:33 <aavogt> just like the earth
17:56:37 <gwern> ivanm: the educational establishment doesn't want you to know
17:56:42 <jbapple> > (maxBound::Int)
17:56:42 <gwern> ivanm: a bigger FSM
17:56:43 <lambdabot>   9223372036854775807
17:56:44 <Berengal> ivanm: Using an even larger computer
17:56:45 <ivanm> hmmm....
17:56:47 <Olathe> ivanm: You throw an exception.
17:56:55 * BMeph gets tripped up by silent under/overflow all the time...
17:57:16 <Berengal> BMeph: Use Integer
17:57:18 <aristid> aavogt: the earth was made by the mice to solve the halting problem for a smaller computer, or something like that was written by douglas adams
17:57:18 <jbapple> > (minBound::Int)-1 == (maxBound::Int)
17:57:19 <lambdabot>   True
17:57:22 <Olathe> Use succ and pred to avoid overflow and underflow.
17:57:25 <EvanR> you are educated stupid, word god made earth have four simultaneous four corner days
17:57:30 <Olathe> > pred (minBound :: Int)
17:57:32 <lambdabot>   *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
17:57:42 <soupdragon> -1 * -1 = -1 is the truth!
17:58:14 <EvanR> FSM = flying spaghetti monster
17:58:15 <Berengal> Olathe: succ and pred are partial for Int
17:58:32 <copumpkin> soupdragon: wasn't there a crank website advocating that somewhere?
17:58:35 <gwern> my sister once made a clay cube inscribed 'time'. when I realized what it was, I couldn't look at her
17:58:35 <Olathe> Berengal: Yes, they only have eyes for Int.
17:58:50 <EvanR> lol
17:58:54 <aristid> gwern: ?
17:59:05 <gwern> aristid: it was a 'time cube'. get it.
17:59:06 <soupdragon> gwerm
17:59:14 <BMeph> Heh-heh, "please don't show children code like this:  x = x + 1    The damage it can cause is irreparable."
17:59:22 <BMeph> dibblego++
17:59:40 <aristid> gwern: i don't get it :(
17:59:48 <aavogt> @google time cube
17:59:49 <lambdabot> http://www.timecube.com/
17:59:49 <lambdabot> Title: Time Cube
17:59:52 <gwern> aristid has been educated stupid, unfortunately
18:00:01 <soupdragon> lolol
18:00:08 <EvanR> link the youtube video of him on techTV
18:00:18 <EvanR> hes real
18:00:20 <aristid> geekounet: educated evil, too?
18:00:29 <aristid> http://www.timecube.com/
18:00:41 <aristid> sorry i meant to highlight gwern
18:01:21 <aavogt> so... lambda cube
18:01:25 <gwern> aristid: only if you deny the glorious truth of the cube
18:01:42 <alexyk> Cale: ping
18:02:07 <aristid> gwern: so there's a video of timecube?
18:02:14 <gwern> mayhap
18:02:18 <soupdragon> Dr. Gene Ray
18:02:21 <soupdragon> lecturing at MIT
18:02:22 <EvanR> aristid: search youtube for dr gene ray
18:02:30 <EvanR> no, dont do MIT, just do tech TV
18:02:33 <soupdragon> Why worship a dumb 1 day god when I
18:02:33 <soupdragon> demonstrate 4 simultaneous 24 hour days
18:02:34 <alexyk> so you guys remember the maxElems cuteness from earlier today?  It seems totally uncalled for, gwern's meowth cuteness notwithstanding.
18:02:34 <soupdragon> within a single 24 hour rotation of Earth?
18:03:24 <aavogt> alexyk: I'm not sure what you mean
18:03:33 <gwern> alexyk: I would glady sacrifice some sense for even one perfect setup like that
18:03:33 <alexyk> I want takeWhile on top of it instead.  But, the question is: if you get stuff from a database with do and a helper function iterating with iternext anbd accumulating, will it be lazy and suitable to chain with take
18:03:41 <aavogt> that kind of stuff is the essence of this channel
18:03:54 <gwern> it is those moments that prevent me from despairing and trying to make myself taller
18:04:11 <alexyk> gwern: the best is yet to come.
18:04:46 <aavogt> alexyk: you're asking for take to determine how many rows are read from the database?
18:05:07 <alexyk> in fact, when I was still a baby in #ocaml, folks reported heated exchanges reported from #haskell with screams of Hitler.
18:05:18 <gwern> alexyk: with what?
18:05:23 <EvanR> the database backend should tell you how many rows you read
18:05:27 <alexyk> aavogt: no, I want to limit my fetch to n elements from a database.
18:05:33 <EvanR> LIMIT N
18:05:54 <gwern> you could fetch one row at a time...
18:05:59 * aavogt was about to suggest lazy IO
18:06:07 <alexyk> EvanR: I fetch from TokyoCabinet with iternext.  That thing returns a Maybe.
18:06:17 <EvanR> so its not sql
18:06:19 <aristid> aavogt: iteratee!
18:06:23 <gwern> iterators! they solve everything!
18:06:33 <aristid> gwern: c++ has proven that already!
18:06:51 <aavogt> so now you people have two problems
18:06:55 <systemfault> The iterator model "works"..
18:07:04 <alexyk> so what I wonder is, if I implement a simple accumulating thing calling iternext and checking the Maybe, it'll fetch the whole database.
18:07:11 <alexyk> Will it be lazy?
18:07:22 <gwern> will it blend?
18:07:57 <EvanR> stand up night at #haskell starring gwern
18:07:57 <aavogt> alexyk: #ocaml is rather dead
18:08:20 <alexyk> this is rather what I meant, untested and incorrect: http://paste.pocoo.org/show/219511/
18:08:26 <kmc> if jdh30 were here he'd have a field day ;P
18:08:36 <gwern> hm. what does the upside down U mean in set notation?
18:08:42 <kmc> intersection?
18:08:44 <gwern> kmc: if jdh30 were here he would shortly not be
18:09:07 <alexyk> originally I envisioned a maxElems parameter.  Now I think, can I drop that and call the result of iterate from take N?
18:09:35 <BMeph> Oops, need to beat feet - see you folks llater...
18:09:40 <Axman6> ok, so, what's a more efficient way to build up a lazy bytestring one character at a time than just using cons? possibly get n characters and pack them, then join them to the rest when its built?
18:09:40 <alexyk> jdh30 is my hero!  was he unbanned and embraced finally?
18:09:58 <alexyk> BMeph: easy on the bastinado
18:10:04 <gwern> doubt it, but I've forgotten how to see the banlist
18:10:12 <gwern> Axman6: doesn't BS supply an unfoldr?
18:10:12 <Axman6> currently i'm using this: decodeHBits' (Leaf c _) bs = B.cons c $ decodeHBits' tree bs
18:10:26 <Axman6> possibly, i haven't looked
18:10:46 <Axman6> it does
18:10:51 <alexyk> so you guys can attest to the inherent lazyness of that paste, or will it fetch everything if maxElems is Nothing?
18:11:12 <gwern> ah, upside down U is union. thought so.
18:11:14 <alexyk> I want to call it under take N as new maxElems, a mere Int
18:11:21 <gwern> alexyk: we attest to nothing! you can't prove we said anything
18:11:21 <aavogt> alexyk: IO is strict
18:11:28 <aavogt> gwern: aaah
18:11:32 <Axman6> except lazy IO(
18:11:34 <Axman6> -(
18:11:50 <aavogt> U is for union
18:12:06 <aavogt> \ is for subtraction
18:12:13 <alexyk> aavogt: so how'd I lazify my fetch-a-single-element into my dream, Clojure seq which is lazy and you guys call something else?
18:12:43 <alexyk> aavogt: gwern is uspside down remember
18:12:59 <alexyk> so U to him is upsidedownU
18:13:03 <EvanR> theres no lazy-ify IO magic function. but there is interleaveIO
18:13:06 <EvanR> :t interleaveIO
18:13:09 <lambdabot> Not in scope: `interleaveIO'
18:13:16 <EvanR> :t unsafeInterleaveIO
18:13:17 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:13:38 <aavogt> alexyk: well the maxElems list isn't getting evaluated any more than necessary
18:13:43 <alexyk> EvanR: my Haskell is too young to be engaged in unsafeAnything
18:13:59 <EvanR> dont do lazyIO then
18:14:01 <aavogt> but the IO to produce all of it is going to happen
18:14:07 <alexyk> aavogt: true but I want to see how can I make iterate a lazy producer
18:14:28 <byorgey> sfultong: you around?
18:14:28 <Axman6> urgh, 6.12.1 broke my code >_<
18:14:40 <gwern> Axman6: think of it as an opportunity to improve your code
18:14:51 <gwern> difficulty is opportunity spelled with more & different letters!
18:14:52 <alexyk> I mean c'mon, can't the producer of IO feed <- lazily?  why is it so hard?
18:14:53 <Axman6> after installing binary, i can't use Data.Binary.Get any more
18:15:46 <EvanR> alexyk: there are like four lazy IO functions and they are implemented with runtime system magic
18:15:52 <EvanR> its not built into haskell
18:15:56 <EvanR> IO is normally strict
18:16:08 <Axman6> gwern: so reallt, its not my code that broke
18:16:23 <gwern> your code is unreasonably refusing to adapt
18:16:31 <gwern> binary has moved on; why can't you?
18:16:38 <gwern> let go of the past man. she's not coming back
18:16:41 <Axman6> where has it moved on to?
18:16:52 <gwern> past us
18:17:10 <aavogt> alexyk: clarify what you mean by lazy here
18:17:13 <Axman6> maybe i should try cereal
18:17:30 <alexyk> gwern: so why is Gwern's father is referred to as his mother's husband first and has a name which is a misspelling of Moishe Matholwich from Bobruisk I knew a while ago?
18:17:48 <Saizan> Data.Binary.Get seems to be still there
18:17:53 <gwern> alexyk: because it sounded like a real name this way
18:18:49 <aavogt> alexyk: your collect function isn't being used at all
18:19:11 <aavogt> compile with warnings to see lots of potential bugs :)
18:19:18 <alexyk> aavogt: I mean my IO iterates over the database fetching one element at a time, building a list of results.  I want it so that if I call it from take N, it fetches N elements only.  I.e., I wonder if the fact that the result is a list propagates under do.
18:19:51 <aavogt> ok, then you are asking for lazy IO
18:19:53 <alexyk> aavogt: yeah, buildGraph is renamed collect.
18:20:30 <aavogt> also, type signatures help people understand what's going on
18:20:53 <Axman6> FFFFFFUUUUUUUU >_<
18:21:06 <Axman6> i can;t use packages installed with cabal-install >________
18:21:08 <Axman6> >
18:21:11 <alexyk> aavogt: http://paste.pocoo.org/show/219513/ something like this
18:21:12 <aavogt> also, doesn't iternext have some IO type?
18:21:18 <alexyk> I want to have that
18:21:29 <alexyk> @hoogle iternext
18:21:30 <lambdabot> No results found
18:21:41 <alexyk>     iternext  :: (Storable v) => a -> TCM (Maybe v)
18:22:31 <Axman6> what the hell!
18:22:46 <alexyk> but collect call is the last in that do, need I keep unwrapping in recursion?
18:22:55 <ccasin> dmwit: ping
18:23:02 <aavogt> so how are you getting the value out of TCM?
18:23:10 * copumpkin draws Axman6 a ffffffuuuuuuuuuu
18:23:19 <alexyk> aavogt: dunno, I'm new here
18:23:21 <aavogt> currently you're not
18:23:30 <alexyk> copumpkin: did you connect through think air? :)
18:23:36 <alexyk> thin air I meant
18:23:43 <copumpkin> alexyk: illegal iphone tethering ftw! :P
18:23:44 <Axman6> copumpkin: you wouldn't have any idea why things installed with cabal-instal would be unavailable in ghci would you?
18:23:49 <alexyk> aavogt: so how should I rewrite it? :P
18:23:56 <copumpkin> Axman6: are they hidden?
18:24:13 <alexyk> copumpkin: yeah!
18:24:18 <Axman6> i install cereal, and it shows up in ghc-pkg list, but i can't :m +Data.Serialize
18:24:36 <copumpkin> Axman6: does it have brackets around it?
18:24:44 <Axman6> they shouldn't be hidden, if they were hidden, it would complain. it just can't find them
18:24:48 <Axman6> no
18:25:06 <copumpkin> ah hmm
18:25:34 <Axman6> ah ffffffffuuuuuuuuu >_< running ghc-pkg check says everything's broken because base-4.2.0.0-0120a3650a6376da8d1b6a4e48a2973a doesn;t exist
18:26:31 <aavogt>   do x <- iternext tc; case x of { Just n -> (x:) `fmap` collect tc; _ -> return [x] }
18:27:16 <aavogt> alexyk: though I suppose you could still write it tail recursively
18:27:24 * Axman6 is getting really sick of cabal breaking every time he tries to use a new ghc
18:27:54 <alexyk> aavogt: yeah, I wonder how, also using >>= instead of do.  Would appreciate for enlightenment!
18:28:04 * Axman6 rages and goes to get some breakfast
18:28:09 <aavogt> @undo do x <- iternext tc; case x of { Just n -> (x:) `fmap` collect tc; _ -> return [x] }
18:28:10 <lambdabot> iternext tc >>= \ x -> case x of { Just n -> (x :) `fmap` collect tc; _ -> return [x]}
18:28:22 <alexyk> Axman6: are you one of them antipodes?
18:28:25 <aavogt> just use do, it's clearer
18:28:39 <Axman6> alexyk: what?
18:28:47 <alexyk> aavogt: I mean, tail recursive w/o do :)
18:28:54 <dcoutts> Axman6: how does it break when you use a new ghc?
18:28:58 <alexyk> Axman6: breakfast is now where, down under?
18:29:00 <copumpkin> antipodes was antigone's brother
18:29:01 <aavogt> oh then you need to use more parameters
18:29:10 <aavogt> that's more typing :)
18:29:14 <Axman6> alexyk: it's a late aussie breakfast, 11:30AM
18:29:25 <alexyk> ok, indeed then
18:30:06 <aavogt>  collect acc tc = do x <- iternext tc; case x of { Just n -> collect tc (n:acc); _ -> return acc }
18:30:10 <jmcarthur> i really want to use my package manager to handle my haskell libraries, but whenever i do i usually end up with errors upon running ghc-pkg check
18:30:11 <Axman6> dcoutts: i can't use any packages installed using cabal-install after upgrading to 6.12.1. ghc-pkg check complains about base-4.2.0.0-0120a3650a6376da8d1b6a4e48a2973a not existing for all the packages i've installed
18:30:20 <aavogt> maybe stuff comes out in reverse order that way
18:30:38 <dcoutts> Axman6: when you say upgrade, do you mean you reinstalled the same version of ghc, ie 6.12.1?
18:31:10 <Axman6> i was suing 6.10.3 or .4, and installed the latest haskell platform for mac, after uninstalling 6.10
18:31:14 <Axman6> using*
18:31:14 <dcoutts> Axman6: if it's actually a new ghc version then it's also a separate package database, ie you start again with no packages registered
18:31:28 <aavogt> alexyk: which can be avoided by using some data other than lists which supports quick appends
18:31:33 <Axman6> shouldn't base be registered?
18:31:39 <aavogt> such as Data.Sequence
18:31:43 <alexyk> aavogt: cool!  so the only difference is that we have <- first.  Now when collect is called from iterate, it's the last thing in the do chain there, so it means we're returning a TCM-wrapped result, right?
18:31:50 <copumpkin> or DList
18:31:51 <dcoutts> Axman6: I'm sure it is, see with ghc-pkg list
18:31:52 <copumpkin> or FMList
18:32:01 <aavogt> FML list
18:32:07 <alexyk> aavogt: wait, we can't revert as I want it to be lazy.
18:32:21 <Axman6> dcoutts: it is, but i have a feeling that hash part is important.
18:32:23 <alexyk> In fact, I wonder if it'll be auto-lazy when called from take N.
18:32:28 <dcoutts> Axman6: yes it is important
18:32:42 <aavogt> your iterate does all the IO when you try to look at the first value
18:32:44 <Axman6> i have had 6.12.1 installed in the past, and went back to 6.10 because i was having problems, if that helps
18:32:47 <dcoutts> Axman6: it looks very much like a reinstall of ghc-6.12.1 itself
18:32:55 <dcoutts> Axman6: ahh ok there we go then
18:32:56 <alexyk> aavogt: won't do!  it's fired.
18:33:06 <aavogt> otherwise it's rather unsafe with respect to ordering of side effects
18:33:33 <alexyk> I need a very gentle explorative collect.  Am I really stuck with maxElems?
18:33:42 <dcoutts> Axman6: so all the packages you had previously installed for 6.12.1 are broken, because the new 6.12.1 you just installed was compiled slightly differently, changing the ABI of base slightly. ghc is protecting you from lots of segfaults.
18:34:04 <aavogt> so if you apply  unsafeInterleaveIO   to the call to iternext, the IO will be delayed
18:34:08 <Axman6> well, good to know. how do i fix it?
18:34:11 <aavogt> until you actually demand that value
18:34:15 <dcoutts> Axman6: remove the broken packages
18:34:40 <Axman6> i'm not sure which packages are broken
18:34:49 <Axman6> and the packages i'm trying to use i just installed
18:34:50 <dcoutts> Axman6: ghc-pkg list shows them in red
18:34:55 <alexyk> aavogt: so EvanR was right after all!  just unsafeInterleaveIO iternext, that's all?
18:35:15 <copumpkin> alexyk: beware about unsafeInterleaving!
18:35:18 <aavogt> and maybe also applied to the collect... I'm not sure
18:35:28 <dcoutts> Axman6: it's likely to be all the packages installed in your user package db.
18:35:30 <Axman6> so everything i've installed since installing 6.12.1... i'm not sure how that will help. won't removing them and reinstalling them bring me back to where i was?
18:35:44 <alexyk> copumpkin: it's you who're unsafeinter-leaving us! :(
18:35:44 <Axman6> seems so, apart from mtl and parsec
18:35:46 <aavogt> yeah, it can be nasty for resources whose access is limited, or likely to break
18:35:54 <copumpkin> alexyk: lol, aw
18:36:06 <copumpkin> the inter soccer team is pretty unsafe
18:36:25 <dcoutts> Axman6: anything new you install should work fine, since it'll get built against the instance of base that you now have installed
18:36:37 <Axman6> but it hasn't
18:36:46 <dcoutts> Axman6: but you can't build things against broken packages
18:36:52 <Axman6> hmm, ok
18:37:23 <Axman6> so, what action should i perform to unbreak all my user packages
18:37:26 <alexyk> so I guess really maxElems then.  In Clojure, they do something like get elem and return cons it back to seq, getting all lazy seqs.  Or something like that.  And I thought Haskell is all lazy!  In CLojure I can wrap any database in a lazy sequence.  You guys should match and exceed that in your sleep!
18:37:31 <dcoutts> Axman6: are you saying you successfully managed to build extra packages using this ghc-6.12.1 instance, but they're now listed as broken?
18:37:39 <Axman6> yes
18:37:50 <dcoutts> that's odd, they should not have built at all
18:38:10 <dcoutts> Axman6: perhaps it's a different problem then
18:38:15 <Axman6> could be
18:38:30 <Axman6> i'm going to get breakfast, i'm starving. i'll be back in 10 minutes
18:39:28 <dcoutts> Axman6: if you do ghc-pkg field base id, you can see if you do really have a base instance with a different hash to the one that is mentioned as the missing dependency
18:39:40 <dcoutts> if it's different, then it's the problem I've just described
18:40:03 <Axman6> it is different
18:40:34 <dcoutts> ok, you just have to unregister all the packages that have the dangling dependency
18:40:55 <dcoutts> when ghc-pkg check says there is no more brokenness then you're ok to reinstall things
18:41:27 <dcoutts> you might find it's quicker to unregister all your per-user packages by rm -r ~/.ghc/ghc-x.y/
18:46:04 <jmcarthur> haskell.org is down :(
18:46:05 <alexyk> hey guys it can't be true: RWH starts with a lazy read of stdin and map toUpper for stdout, without caring for how huge it is.  So it got to be lay, no?
18:46:33 * alexyk registered 3th.us domain for the 3rd time haskell support group
18:46:52 <Olathe> @hoogle Int -> a -> [a]
18:46:53 <lambdabot> Prelude replicate :: Int -> a -> [a]
18:46:53 <lambdabot> Data.List replicate :: Int -> a -> [a]
18:46:53 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:47:01 <Olathe> > replicate 5 'a'
18:47:03 <lambdabot>   "aaaaa"
18:47:03 <aavogt> alexyk: because getContents and readFile are lazy IO
18:47:11 <aavogt> implemented with unsafeInterleaveIO
18:47:13 <aristid> > replicateM 5 'a'
18:47:14 <lambdabot>   Couldn't match expected type `m a'
18:47:14 <lambdabot>         against inferred type `GHC.Types...
18:47:19 <aristid> > replicateM 5 "a"
18:47:20 <lambdabot>   ["aaaaa"]
18:47:26 <monochrom> lazy read is lazy
18:47:27 <jmcarthur> i hate it when beginner tutorials teach with lazy IO
18:47:32 <alexyk> aavogt: ah, well. they're the meat of our lives, so if they can do it, why not the rest
18:47:42 <jmcarthur> i mean, i understand why they do it, but it's just bad
18:48:01 <aavogt> jmcarthur: because sometimes it isn't a problem
18:48:05 <jmcarthur> right
18:48:06 <jmcarthur> sometimes
18:48:09 <monochrom> Complex World Haskell will start with Iteratee I/O :)
18:48:15 <jmcarthur> sometimes unsafePerformIO isn't a problem either
18:48:21 <aavogt> imaginary world haskell
18:48:21 <jmcarthur> or unsafeCoerce
18:48:25 <alexyk> jmcarthur: it's awesome!  Clojure is built on laze seqs and it's the main hook of the whole thing.  We look up to you and you say it's unsafe!
18:48:28 <aavogt> that's true
18:48:39 <aristid> monochrom: right after the chapter on comonads?
18:48:59 <monochrom> no don't worry, comonad is 2nd chapter not first :)
18:49:02 <jmcarthur> monochrom: or just explicit IO like more languages
18:49:07 <jmcarthur> s/more/most/
18:49:12 <alexyk> where's the chapter on copumpkins?
18:49:21 <jmcarthur> i'm still writing that one
18:49:34 <copumpkin> :O
18:49:38 * copumpkin be sleepy
18:49:46 <monochrom> Complex World Haskell is complex. Explicit I/O is too easy!
18:49:55 <ivanm> copumpkin: there's a cure for that you know...
18:50:00 <aavogt>  with a chapter on @pl
18:50:08 <aristid> ivanm: cocaine?
18:50:11 <ivanm> monochrom: and I presume you're going to do all numerics with quaternions, etc.
18:50:12 <alexyk> lazy IO and sleepy copumpkins -- new MEAP chapters in Advanced Haskell are ready!
18:50:18 <ivanm> aristid: I was going to say sleep...
18:50:22 <monochrom> The final chapter is on Agda!
18:50:23 <ivanm> failing that, caffeine
18:50:24 <aavogt> or is that already in rwh?
18:50:31 <ivanm> aavogt: not really
18:50:36 <jmcarthur> monochrom: *final* chapter? sounds too intermediate
18:50:38 <Axman6> dcoutts: i unregistered all the packages that were in red, then tried reinstalling one, and its still in red and not working
18:50:47 <ivanm> IIRC it talks about point-free, but not @pl
18:50:48 <aristid> ivanm: sleep? has that been proven to work? crazy talk
18:50:59 * aavogt thinks this channel is unsafeInterleaveIO'd
18:51:06 <ivanm> monochrom: why Agda rather than Coq, Isabelle+Haskabelle, etc.?
18:51:14 <jmcarthur> the final chapter should be a guided tour of the proof of L4
18:51:25 <alexyk> sounds like a new Audi model
18:51:31 <monochrom> Because "Complex World Haskell" says "Haskell" after all.
18:51:31 <copumpkin> ivanm: so much closer to haskell
18:51:36 <aristid> audi models don't begin with L
18:51:37 <dcoutts> Axman6: is there something odd going on with multiple instances of the same ghc perhaps?
18:51:44 <ivanm> monochrom: Haskabelle generates Haskell code though...
18:51:46 <alexyk> L4 with German delivery option
18:51:56 <ivanm> alexyk: it's a kernel
18:51:58 <monochrom> I mean if it were "Complex World Somethingsomething" I wouldn't mind Coq in the 1st chapter.
18:51:59 <dcoutts> Axman6: like a package being built with one ghc but registered for another
18:52:02 <copumpkin> ivanm: but agda looks like haskell and its types feel like GADTs. The syntax is like haskell but flexibler! ;)
18:52:09 <ivanm> hmmm...
18:52:16 <Axman6> how would i tell?
18:52:20 <copumpkin> moar fleixblerest
18:52:37 <dcoutts> Axman6: does which ghc, and which ghc-pkg indicate they're in the same location?
18:53:11 <dcoutts> Axman6: do you happen to know if you have ghc-6.12.1 installed already elsewhere?
18:53:18 <ivanm> dcoutts: should probably check what the symlinks are to as well
18:53:24 <Axman6> huh, no, or some reason, ghc is in /usr/bin/ and ghc-pkg is in /usr//local/bin
18:53:30 <dcoutts> ah hah!
18:53:37 <dcoutts> that's it
18:53:43 <ivanm> silly Axman6
18:53:43 <Axman6> how on earth did that happen?
18:53:50 <ivanm> this is what you get for using Mac! :p
18:53:53 <jmcarthur> i really like agda. i hope it gets some polish before it stagnates or something
18:54:02 <copumpkin> jmcarthur: oh it's definitely not stagnating
18:54:10 <copumpkin> jmcarthur: we just need to get more people interested in it :)
18:54:14 <jmcarthur> heh
18:54:20 <dcoutts> Axman6: that explains why they packages managed to build when I'd expect that they would fail during compilation, since one cannot build against broken packages
18:54:22 <jmcarthur> i was under no illusions that it was
18:54:27 <copumpkin> jmcarthur: bugs get fixed within hours of you reporting them
18:54:30 <copumpkin> it's pretty fun actually
18:54:33 <dmwit> ccasin: pong
18:54:34 <copumpkin> as long as they're not profound bugs
18:54:40 <copumpkin> beer pong?
18:54:46 <jmcarthur> yeah this touches on that "polish" thing i mentioned ;)
18:55:01 <dcoutts> Axman6: crikey, what a nasty one
18:55:03 <copumpkin> warsaw?
18:55:03 <jmcarthur> but i do really like agda
18:55:09 <Axman6> aye :)
18:55:22 <ivanm> Axman6: see, a package manager would take care of this for you :p
18:55:41 <copumpkin> anyway, hear that? y'all should come to #agda and learn things you never imagined were possible
18:55:42 <dcoutts> Axman6: cabal checks that it's got a ghc and ghc-pkg that are the same version, but perhaps for extra paranoia we should check that they are using the same global package db.
18:56:02 <Axman6> heh, yeah
18:56:20 <Axman6> copumpkin: like?
18:56:23 <luite> hm, agda currently doesn't build with cabal-install, no newline at the end of src/full/Agda/TypeChecking/Monad/Debug.hs
18:56:28 <copumpkin> Axman6: um, stuff!
18:56:31 <dmwit> Hm, I really need to set up an audible alert when people say my name.
18:56:40 <copumpkin> Axman6: who needs turing-completeness anyway
18:56:50 * Axman6 does
18:56:58 <jmcarthur> no you don't :P
18:56:59 <copumpkin> Axman6: I bet you don't really
18:57:08 <alexyk> "Advanced Haskell: Learn things you never imagined possible, like stuff"
18:57:12 <Axman6> but i'll get laughed at without it!
18:57:20 <aristid> nobody needs more than a DFA
18:57:24 * jmcarthur laughs at turing completeness
18:57:25 <copumpkin> alexyk: this is a whole new language! even better than haskell!
18:57:38 <alexyk> Axman6: Macs are toted by hipster aussies too?
18:57:42 <ivanm> dmwit: let us know when you want us to test said alert for you ;-)
18:57:43 <Axman6> Haskell++!
18:57:45 <alexyk> in kangaroo skins?
18:57:49 <dmwit> heh
18:58:02 <Axman6> they're toted by people who like to get work done
18:58:23 <alexyk> Axman6: I type this on a Mac, you too, and no works is getting done!
18:58:33 <ivanm> Axman6: because they're so dumbed down, simplified and locked down that you can't do anything except work?
18:58:37 <alexyk> no work across teh globe
18:58:39 <Axman6> i didn't say exclusively
18:58:55 <ivanm> oh, and show off how supposedly fancy it is whilst making excuses for the price and bitching about lack of games
18:59:05 <aavogt> pff, who likes getting work done
18:59:09 <aavogt> especially around here
18:59:12 <Axman6> lack of games is a fixed problem
18:59:20 <ivanm> Axman6: http://www.reddit.com/r/funny/comments/c907b/a_local_apple_store_was_burgled_with_over_10000/
18:59:21 <Axman6> ivanm: where's your portal huh?
18:59:23 <alexyk> ivanm: sounds like you know your way around a sweatshop full of offshore code monkeys! :)
18:59:31 <ivanm> Axman6: in my spare room
18:59:43 <Axman6> so you had to buy two computers?
18:59:46 * ivanm got the indie bundle; hasn't had time to play any of them yet
18:59:59 <ivanm> Axman6: I tend to hack on Haskell rather than play games...
19:00:06 <Axman6> i do too
19:00:09 <ManateeLazyCat> What's syb the use?
19:00:12 <ivanm> + playing old-school games has the advantage of being more wine-able and cheaper! :p
19:00:12 <Axman6> and, get work done
19:00:19 <ivanm> ManateeLazyCat: scrap your boilerplate
19:00:24 <ivanm> i.e. code generation and stuff
19:00:31 <aavogt> to the papers
19:01:04 <aavogt> papers tend to contain a decent justification for the existence of the library whose guts are described therein
19:01:07 <ManateeLazyCat> ivanm: I have many duplicate code in my class instance,  can i use syb to avoid those duplicate instance code?
19:01:20 <ivanm> no idea
19:01:21 <aavogt> syb is not code generation
19:01:22 <ivanm> I've never used it
19:01:27 <ivanm> aavogt: I stand corrected
19:01:53 <aavogt> though preferably it's done with some code generation for the Data instance
19:02:31 <dcoutts> Axman6: http://hackage.haskell.org/trac/ghc/ticket/4103
19:02:32 * ManateeLazyCat pasted "duplicate instance code." at http://paste2.org/get/855842
19:02:33 <ManateeLazyCat> ivanm: Like above code.
19:02:46 <aavogt> it's to write functions to create, transform or destroy any data structure based on the 'shape' of the data, rather than the exact constructors used
19:02:46 <ManateeLazyCat> ivanm: Maybe instance code is duplicate.
19:03:14 <Axman6> dcoutts: :)
19:03:48 <ManateeLazyCat> aavogt: syb can help my code at http://paste2.org/get/855842 ?
19:03:53 <aavogt> ManateeLazyCat: where is the class?
19:04:13 * ivanm has never used any generics library
19:04:26 * ManateeLazyCat pasted "class" at http://paste2.org/get/855845
19:04:29 <ManateeLazyCat> aavogt: Above
19:05:15 <dcoutts> Axman6: I'm slightly relieved it wasn't a nasty bug in Cabal ;-)
19:05:23 <Axman6> heh, yeah
19:06:03 <ManateeLazyCat> aavogt: In http://paste2.org/get/855842 , any *type* just pick-up from "data Environment", but i need write many duplicate code just because them have different element and sequence.
19:06:04 <aavogt> ManateeLazyCat: I dunno, I'd write it in an Applicative style if possible
19:06:59 <ManateeLazyCat> aavogt: I think i can use TH scan [Name] then generate instance code, but i want find other way except TH.
19:07:56 <aavogt> TH code is generated at compile time. The traversal by syb is done at runtime
19:08:03 <aavogt> is figured out
19:08:19 <ManateeLazyCat> aavogt: And all is type safe, right?
19:08:43 <aavogt> no you're free to apply a generic function to any instance of the Data class
19:09:07 <aavogt> whether or not it contains something that's actually going to match some cases
19:09:45 <aavogt> > everywhere (mkT $ ((+1) :: Int -> Int)) [1,2,3]
19:09:47 <lambdabot>   [1,2,3]
19:09:47 <ManateeLazyCat> aavogt: I guess TH is more suitable for my situation.
19:10:26 <aavogt> there's no check to point out that your list is [Integer] contains absolutely no [Int]
19:10:32 <aavogt> since that may well be a valid use case
19:12:18 <ManateeLazyCat> aavogt: Simple, i have "data Foo = Foo {fooA :: FooA, fooB :: FooB, fooC :: FooC}", i want scan type "(FooA, FooB, FooC)" and generate instance code "instance SomeClass (FooA, FooB, FooC) where .... let a = fooA foo; b = fooB foo; c = fooC foo ... "
19:12:38 <aavogt> why?
19:13:13 <ManateeLazyCat> aavogt: Because i want build a list of polymorphism function that have different arguments.
19:13:24 <aavogt> perhaps there's another way
19:13:43 <ManateeLazyCat> aavogt: Some function is "(FooA, FooB, FooC) -> IO ()", and some function is "(FooA, FooB) -> IO ()"
19:14:01 <ManateeLazyCat> aavogt: Then i can mix those polymorphism functions in a Map.
19:14:15 <aavogt> so why not just store   IO ()  in the Map?
19:14:52 <ManateeLazyCat> aavogt: And some function is "(FooA, FooB) -> IO (BarA, BarB)", not just IO () . :)
19:14:56 <alexyk> is let x = \n\tcase ... wrong identation causing a parse error?
19:15:36 <aavogt> ManateeLazyCat: so your map may contain   Mu IO
19:16:14 * ManateeLazyCat pasted "polymorphism functions in Keymap." at http://paste2.org/get/855864
19:16:26 <ManateeLazyCat> aavogt: Above is what i want to do
19:17:03 <aavogt> so why not have your actions be the inf type    IO (IO (IO (IO ...
19:17:26 <aavogt> since all you do after running one is feed it's results back to a new version of itself
19:17:46 <ManateeLazyCat> aavogt: Because i want to get good layout.
19:18:01 <ManateeLazyCat> aavogt: I don't want write all functions with "Environment -> IO ()"
19:18:02 <aavogt> I don't understand the difference
19:19:07 <ManateeLazyCat> aavogt: Some module functions just use *subset* of Environment.
19:20:07 <aavogt> ok, so use HList instead of a regular record for Environment
19:20:17 <ManateeLazyCat> aavogt: HList?
19:20:28 <ivanm> nooooo!!!!
19:20:39 <aavogt> extensible records
19:20:47 <ski> alexyk : at least in what you pasted in here, you have some strange character between "c" and "ase" .. try removing "case" and rewriting it ?
19:20:55 <pnicholson> is the haskell.org wiki down for anyone else?
19:21:03 <aavogt> ivanm: manatee's code is already not up to your standards anyhow
19:21:11 <ivanm> pnicholson: appears that way
19:21:16 <ivanm> aavogt: true ;-)
19:21:18 <ManateeLazyCat> aavogt: I used to make all function with "Environment -> IO ()", but last i found code is hard to maintain, some sub-module don't need all element of Environment.
19:22:14 <aavogt> well if you use HList, or some other extensible record library, the type of the record you access is one that contains at least the fields you specify
19:22:20 <ManateeLazyCat> aavogt: HList is better than use TH generate instance code?
19:22:31 <aavogt> it's probably nicer
19:22:51 <ManateeLazyCat> aavogt: Ok, thanks for your help, i will study HList. :)
19:22:53 <ski> alexyk : .. otherwise, make sure that `case' starts in a column *after* the `x' on the previous line (and tabs are counted as 8 spaces by GHC, iirc)
19:23:40 <ski> alexyk : in any case, don't mix tabs and spaces for indentation. many avoid tabs altogether, and some use only tabs for indentation
19:24:40 <ManateeLazyCat> aavogt: BTW, i found avoid "Environment -> IO ()" make my code clearer, i can know module's responsibility, and avoid one module do too much different thing. :)
19:25:08 <ManateeLazyCat> aavogt: Just haven't found a good way avoid duplicate instance code before talk to you. :)
19:34:22 <akosch> is there a library function to count the items fulfilling a condition in a list? or do i have to use "length . filter"?
19:34:40 <dmwit> length . filter seems fine
19:34:56 <akosch> dmwit: thx
19:36:03 * ddarius isn't sure what the fascination is with numbers and booleans.
19:36:48 <soupdragon> when I see "length . filter" it's like fingernails against a black board
19:37:00 * soupdragon screams
19:37:04 <soupdragon> in pain
19:37:04 <danharaj> Why.
19:37:09 <soupdragon> because it should be "length . filter p"
19:37:11 <monochrom> length . filter . length .filter
19:37:19 <soupdragon>  icant take any more!
19:37:37 <monochrom> you should just read letters uninterpreted
19:38:11 <monochrom> lemgth . fiIter . Iength . filten
19:39:18 <monochrom> I didn't even recall filter needing p there until you said it. Triumph of semantic atheism: there is no semantics.
19:39:38 <aavogt> @type length . filter
19:39:39 <lambdabot>     Couldn't match expected type `[a]'
19:39:39 <lambdabot>            against inferred type `[a1] -> [a1]'
19:39:39 <lambdabot>     Probable cause: `filter' is applied to too few arguments
19:39:54 <aavogt> @type (length .) . filter
19:39:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
19:40:08 * ManateeLazyCat A good layout is one module don't need know the detail of other modules....
19:40:14 <gwern> semantics atheism. a curious idea
19:40:23 * gwern likes infinite set atheism better
19:40:35 <dmwit> semantic atheism: there is no meaningful god
19:40:49 <soupdragon> gwern, what about continuum-hypotheism
19:41:06 <gwern> soupdragon: independent, and a matter of aesthetic preference
19:41:12 <dmwit> hypotheism: the belief that there are too-few gods
19:41:27 <dmwit> (corollary: continuum-hypotheism: the belief that continuum-many gods is not enough)
19:41:29 <aavogt> soupdragon: like for fulids?
19:41:32 <aavogt> fluids
19:41:49 <arw> anthropic theism: i think, therefore i am god.
19:41:56 <gwern> hey, hey, no infinities which aren't the result of a well-defined limit!
19:42:25 <aavogt> http://en.wikipedia.org/wiki/Fluid_mechanics#The_continuum_hypothesis
19:42:26 <alexyk> how do we convert a String to an Int?
19:42:31 <aavogt> read
19:42:33 <dmwit> :t reads
19:42:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:42:40 <gwern> > read "10" :: Int
19:42:41 <lambdabot>   10
19:42:44 <dmwit> read, if you're confident that it's well-formed
19:42:45 <monochrom> unsafeCoerce
19:42:46 <alexyk> cool
19:43:00 <dmwit> read ~= fst . head . reads
19:43:04 <monochrom> @type length
19:43:05 <alexyk> unsafeCoerce == drunken rape
19:43:05 <lambdabot> forall a. [a] -> Int
19:43:10 <gwern> aavogt: that's not the continuum hypothesis we're thinking of, you know
19:43:15 <monochrom> > length "1"
19:43:15 <gwern> > read "af10" :: Int
19:43:15 <lambdabot>   1
19:43:16 <lambdabot>   *Exception: Prelude.read: no parse
19:43:17 <monochrom> works
19:43:22 <aavogt> gwern: why not?
19:43:23 <dmwit> :t readIntAtBase -- alexyk, in case you don't know the base ahead of time
19:43:23 <lambdabot> Not in scope: `readIntAtBase'
19:43:30 <dmwit> uh
19:43:35 <dmwit> ?hoogle readIntAtBase
19:43:35 <lambdabot> No results found
19:43:42 <gwern> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:43:43 <gwern> ?
19:43:48 <dmwit> Yes, readInt.
19:43:55 <aavogt> why can't these people in unrelated fields pick unique names
19:44:06 <aavogt> it's bad enough with TLAs
19:44:07 <dmwit> Why did they choose showIntAtBase, but readInt?
19:44:14 <gwern> aavogt: we're thinking of the ordinal question...
19:44:21 <monochrom> why can't people just forget about names
19:44:45 <aavogt> that tends to happen
19:44:46 <dmwit> How else to refer to particular objects?
19:45:08 <gwern> dmwit: proffer the object itself
19:45:12 <monochrom> library of congress call numbers
19:45:15 <Olathe> If I call f :: State a b from within f, will the state value remain the same ?
19:45:20 * gwern resists the temptation to start quoting wittgenstein at dmwit 
19:45:21 <aavogt> monochrom: those are names
19:45:23 <dmwit> A call number is just another kind of name, isn't it.
19:45:46 <dmwit> Olathe: That depends; did you modify the state before calling f?
19:45:48 <alexyk> crap it all works when compiled and linked
19:45:54 <alexyk> thank you haskellers
19:45:58 <monochrom> at least it does not serve as a mnemonic.
19:46:01 <Olathe> dmwit: Well, if I do, will it pick up the modified state ?
19:46:12 <Olathe> I'm just basically wondering whether it picks up where I left off.
19:46:26 <aavogt> though I suppose they should be unique if librarians follow the formula
19:46:29 <monochrom> people have name clashes precisely because they want names to be mnemonics
19:47:52 <Saizan> Olathe: yes, it picks the current state
19:47:57 <Olathe> Ahh, thanks :)
19:48:40 <gwern> you know one joke I want to make? using 'anecdotage'. I want to dryly observe that some speaker 'appears to have fallen into his anecdotage'
19:48:54 <gwern> but nobody here ever illustrates a point with a hoary chestnut
19:49:11 <gwern> dammit guys
19:49:19 <alexyk> here's a question: I have JSON, which when parsed with Text.JSON decode becomes JSObject ... etc.  I know my data is a Map of String to a Map of Maps of Ints to Strings.  Can I parse straight into that?
19:50:15 <alexyk> i.e. how do I define the glue from my type to JSON to parse it? a schema, if you will?
19:50:39 <Saizan> alexyk: which package are you using?
19:50:41 <Olathe> The State monad is nice :D
19:50:55 <alexyk> Saizan: Text.JSON from json
19:51:18 <Saizan> alexyk: fyi, Text.JSON is a module, json is the package
19:51:22 <Saizan> :)
19:51:26 <alexyk> yep
19:52:15 <akosch> what sort of function does maximumBy need?
19:52:22 <aavogt> @type maximumBy
19:52:24 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:52:25 <soupdragon> :t maximumBYE
19:52:26 <lambdabot> Not in scope: `maximumBYE'
19:52:30 <Saizan> alexyk: that's an instance of JSON for Map http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON.html#t%3AJSON
19:52:59 <akosch> yeah, but sadly i don't know what ordering is ....
19:53:04 * alexyk notes again for posterity that his first semi-serious haskell program worked the first time it compiled. 
19:53:07 <aavogt> @type compare
19:53:08 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:53:13 <copumpkin> @src Ordering
19:53:13 <lambdabot> data Ordering = LT | EQ | GT
19:53:34 <soupdragon> alexbyb what program is it
19:53:37 <copumpkin> akosch: just says whether something is greater than, less than, or equal to something else
19:53:53 <akosch> copumpkin: thx, i think i got it
19:53:54 <alexyk> Saizan: thx
19:54:07 <dmwit> It's just your average, run-of-the-mill tri-state boolean.
19:54:25 <alexyk> soupdragon: nothing much, reading JSON form a TokyoCabinet, co-developed today with the gentlemen here :)
19:54:26 <aavogt> troolian
19:54:29 <Saizan> alexyk: so you might try "readJSON yourJSValue :: Result DesiredType" and see if you get something
19:54:33 <dmwit> Which reminds me, I haven't checked thedailywtf yet today.
19:55:40 <ManateeLazyCat> aavogt: I think this explain is clearer: "data Environment" is design for user Action, that need mix many sub-module, and "(FooA, FooB, FooC) -> IO (BarA, BarB)" is function in sub-module, it don't need know the detail of Environment, so when i change something in Environment, i don't need change sub-module functions.
19:55:55 <ManateeLazyCat> aavogt: Just change Environment interface is okay, all low-level modules don't need change.
19:56:20 <aavogt> as long as Environment has all the old fields
19:56:32 <ManateeLazyCat> aavogt: If i write "Environment -> IO ()" everywhere, it's hard to maintain once i change Environment interface.
19:57:34 <ManateeLazyCat> aavogt: Environment in my system is a *huge share state set*, it maybe change in anytime.
19:58:02 <ManateeLazyCat> aavogt: That's why i need write "data Action = forall a b . (ActionInputArgs a, ActionOutputArgs b) => Action {actionFun :: a -> IO b}"
19:59:07 <aavogt> no you don't
19:59:14 <ManateeLazyCat> aavogt: Better idea?
19:59:22 <aavogt> you're probably misunderstood how hlist works
19:59:39 <copumpkin> hlist doesn't ever forget types!
19:59:45 <copumpkin> unlike those pesky forgetful existentials
19:59:48 <ManateeLazyCat> aavogt: I haven't read hlint yet. :)
19:59:57 <aavogt> hlint is something else
20:01:24 <ManateeLazyCat> aavogt: I'm reading HList at HaskellWiki, and figure out what's help....
20:03:39 <ManateeLazyCat> aavogt: I use instance for feed old *Environment subset* value, and return new *subset value* to update Environment.
20:05:53 <aavogt> so what's wrong with using the classes in hlist to lookup and update some subset of labels?
20:06:25 <ManateeLazyCat> aavogt: I'm studying HList.
20:06:57 <aavogt> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-GhcSyntax.html
20:07:43 <aavogt> copumpkin: existentials don't have to forget either
20:07:54 <aavogt> you can make them carry Typeable along
20:07:57 <ManateeLazyCat> aavogt: I have read some Wiki article, HList is design for label value, that you just need write *one* instance, then HList will update shoe subset automatic, right?
20:07:59 <humasect> glguy!
20:08:06 <glguy> hi
20:08:07 <copumpkin> aavogt: you still have to know what to expect
20:08:14 <ManateeLazyCat> aavogt: You don't need write duplicate instance code for different subset, right?
20:08:19 <humasect> hi! where is that language you have shown me before? i cannot find it
20:08:29 <aavogt> which instances?
20:08:31 <glguy> Factor? Agda?
20:08:33 <humasect> agda!
20:08:44 <aavogt> you only need a typeable instance for your labels
20:08:44 <copumpkin> yay, another agdaist
20:08:45 <humasect> that's it ~ i knew it was a+4
20:08:53 <humasect> it is so beautiful
20:08:56 <aavogt> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-MakeLabels.html
20:09:25 <ManateeLazyCat> aavogt: Thanks, i need study more before i ask question, thanks for link.
20:09:33 <humasect> and is missing from wikipedia (last resort)
20:11:17 <humasect> thank you =)
20:13:38 <ivanm> hmmm... when using Overloaded Strings, what encoding is used for converting String literals to Bytestring?
20:14:26 <aavogt> ivanm: look at the instance for whatever class is used for that conversion
20:14:32 <nus> "HList - a court of last resort".
20:14:58 <nus> or is it the court.
20:15:05 <ivanm> aavogt: well, I have no idea how OverloadedStrings is done, hence my query ;-)
20:15:16 <aavogt> Data.String.IsString
20:15:22 <aavogt> it has instances somewhere
20:15:44 <aavogt> ivanm: it's done just like numeric literals
20:16:04 <Saizan> i'm pretty sure it's latin1
20:16:05 <glguy> class IsString a where fromString :: String -> a
20:16:19 <ivanm> hmmm
20:16:39 <ivanm> Saizan: that's what I was guessing but wanted to check
20:16:49 * glguy would be surprised if they were latin1
20:17:11 <glguy> Oh
20:17:14 <glguy> for bytestring?
20:17:16 <ivanm> well, Char8
20:17:18 <ivanm> glguy: yeah
20:17:27 <aavogt> what Char8?
20:17:36 <aavogt> it could do any encoding
20:17:38 * Saizan guesses fromString = Data.ByteStrin.Char8.pack
20:17:40 <ivanm> aavogt: as in I was guessing it was using Data.Bytestring.Char8
20:17:44 <glguy> Char8 doesn't really treat them as latin1
20:17:44 <ivanm> Saizan: yeah
20:17:52 <glguy> it just don't bother treating them as anything
20:18:06 <humasect> alright, i've added as much as i could about Agda to wikipedia. this is all i can do for now -- thanks again guys =) be well
20:18:28 <ivanm> yeah, the Char8 docs say it uses them
20:23:08 <glguy> Data.ByteString.Char8 is just the mod256 of the unicode codepoint which only makes sense in the lower 127 range
20:24:34 <Saizan> why only there?
20:24:57 <ivanm> Saizan: that corresponds to ASCII doesn't it?
20:25:07 <ivanm> and AFAIK all encodings use ASCII as a base
20:25:14 <ivanm> and then argue about the 128-255
20:25:23 <Saizan> yeah, but up to 255 unicode corresponds to latin1
20:26:05 <pikhq> ivanm: Not all encodings.
20:26:08 <Saizan> which might help if you're dealing with something that comes out of an european windows machine
20:26:42 <pikhq> For instance, there's UTF-EBCDIC
20:26:54 <monochrom> onoes
20:27:17 <pikhq> (not a joke. At all.)
20:27:19 <arw> and there is utf-7, which has absolutely nothing left over from an earlier encoding.
20:27:36 <pikhq> arw: Or sanity, for that matter.
20:27:45 <ddarius> Sanity is overrated.
20:27:58 <arw> pikhq: says the person mentioning ebcdic ;)
20:28:24 <pikhq> arw: :P
20:29:15 <gwern> I've long felt utf was off in one letter
20:29:24 <gwern> more like wtf amirite
20:29:27 <glguy> Saizan: I see, you can think of it as translating for free from utf-8 to ISO/IEC 8859-1 for values < 256
20:29:39 <pikhq> gwern: Depends on the UTF.
20:29:48 <glguy> In the literal it is stored as UTF-8 still
20:29:49 <pikhq> UTF-32, for instance, is *quite* clean.
20:30:07 <gwern> well, aside from each character being 32 bits oy
20:30:13 <ddarius> Indeed, the Undead Task Force surely should be UTF
20:30:16 <gwern> space is cheap but still
20:30:31 <pikhq> Space is cheap and text compresses well.
20:30:35 <monochrom> 64-bit pointers and 32-bit chars
20:30:58 <arw> pikhq: said the person who invented xmlrpc to encode a boolean in 100 bytes :)
20:31:06 <ddarius> Soon we'll have 128 bit machines and a boolean will consume 128 bits.
20:31:12 <pikhq> arw: Hah.
20:31:29 <arw> pikhq: ok, 400 if you encode in utf32
20:31:42 <gwern> ddarius: I wonder. it's not hard to have so much ram that 32-bit is a problem, but 64-bits?
20:32:16 <arw> gwern: 20 years ago, people said the same, only with 16bit vs. 32bit :)
20:32:22 <pikhq> 128-bit arithmetic perhaps, but 128-bit addresses?
20:32:29 <gwern> arw: I think if you chart moore's law it'
20:32:31 <ddarius> 640k ought to be enough for anybody
20:32:37 <gwern> s pretty obvious 32-bit has to go, but 64-bits?
20:32:52 <gwern> that's, how many gigabytes?
20:33:02 <pikhq> gwern: Exabytes.
20:33:05 <monochrom> how many bits are there in an IPv6 address?
20:33:08 <ddarius> 64 bits is 16 billion gigabytes
20:33:11 <arw> monochrom: 128
20:33:38 <glguy> 32-bit was 4 gb
20:33:44 <glguy> so 2^32  * 4 gb :)
20:34:04 <gwern> yeah, I don't think moore's law will hold for that long
20:34:57 <gwern> I mean, at that point, for a desktop form factor you're dealing with things like the berkenstein bound and uncertainty principle :)
20:35:18 <ddarius> bekenstein
20:35:42 <monochrom> or die trying
20:35:44 <edwardk> monochrom: after all, with only 128 bits, you can't assign an address to every atom in the known universe ;) so clearly we need a larger address space.
20:36:35 <glguy> with 128bit addressing we can give unique addresses to everyones memory :)
20:36:43 <monochrom> but then they invented ip-masquerading routers
20:36:43 <edwardk> ... only to the square root of that number ;)
20:37:33 <gwern> edwardk: how many bits would we need for all particles? I thought there were only 10^70th
20:37:53 <ddarius> 10^70 ~ 2^210
20:38:08 * gwern should learn how to do that conversion
20:38:10 <edwardk> basically double the bits and you're good
20:38:13 <glguy> > logBase 2 (10^70)
20:38:13 <lambdabot>   232.5349666421154
20:38:45 <edwardk> you can back of the envelope it by just tripling the power. 2^10 ~ 10^3
20:39:45 <glguy> edwardk: Thats the kind of loose thinking that lead the the harddrive manufacturers astray
20:40:12 <monochrom> not astray. to profit.
20:40:14 <edwardk> i divide it by three and multiply by ten, and its great fun at parties ;)
20:40:26 <gwern> remarkable parties
20:40:35 * glguy opens the book of log tables at parties
20:40:41 <arw> per aspera, astray
20:41:15 <glguy> > logBase 2 10
20:41:16 <lambdabot>   3.3219280948873626
20:41:43 <edwardk> rather than my shoddy 3.333333333 ;)
20:41:56 <glguy> no kidding!
20:42:19 <monochrom> just multiply or divide by pi
20:42:25 <glguy> next youll be telling me that pi is 3
20:42:43 <monochrom> no, I'll tell you pi is logBase 2 10
20:42:45 <edwardk> nah,you should round up, its 4. easier to square a circle that way
20:43:35 <monochrom> pi are square
20:43:48 <edwardk> pi r round, cake r square
20:44:10 <glguy> monochrom: look like you found a way a-round that one
20:44:11 <monochrom> cake r round too
20:44:45 <ddarius> glguy: Why not evaluate the truncated Taylor series?
20:45:49 <monochrom> > 4*( 1 - 1/3 + 1/5 - 1/7 + 1/9)
20:45:50 <lambdabot>   3.3396825396825403
20:46:04 <monochrom> > 4*( 1 - 1/3 + 1/5 - 1/7)
20:46:05 <lambdabot>   2.8952380952380956
20:46:13 <wli> Brun's constant sounds more interesting.
20:46:13 <monochrom> > 4*( 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11)
20:46:14 <lambdabot>   2.9760461760461765
20:46:26 <monochrom> > 4*( 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + 1/13)
20:46:27 <lambdabot>   3.2837384837384844
20:46:40 <monochrom> it converges to logBase 2 10
20:51:39 <Olathe> @pl \f -> f x
20:51:39 <lambdabot> ($ x)
20:51:54 <ddarius> :t runCont . return
20:51:55 <lambdabot> forall r a. a -> (a -> r) -> r
20:52:06 <ddarius> :t flip ($)
20:52:07 <lambdabot> forall a b. a -> (a -> b) -> b
20:53:26 <aavogt> > (4*) $ sum $ take 100 $ map recip $ iterate (negate . (+2)) 1
20:53:28 <lambdabot>   133.3333333333334
20:53:41 <aavogt> > (4*) $ sum $ take 100 $ map recip $ iterate (negate . (+2) . abs) 1
20:53:42 <lambdabot>   -5.137368757206534
20:54:38 <aavogt> > (4*) $ sum $ take 100 $ map recip $ zipWith (*) (cycle [1,-1]) $ iterate (+2) 1
20:54:39 <lambdabot>   3.1315929035585537
20:55:20 <aavogt> monochrom: convincing :)
20:57:26 <jmcarthur> > logBase 2 10
20:57:28 <lambdabot>   3.3219280948873626
20:58:24 <jmcarthur> > (4*) $ sum $ take 1000 $ map recip $ zipWith (*) (cycle [1,-1]) $ iterate (+2) 1
20:58:25 <lambdabot>   3.140592653839794
20:58:32 <aavogt> log's series doesn't converge everywhere does it?
20:58:37 <jmcarthur> > (4*) $ sum $ take 10000 $ map recip $ zipWith (*) (cycle [1,-1]) $ iterate (+2) 1
20:58:38 <lambdabot>   3.1414926535900345
21:03:38 <pastorn> jmcarthur: getting there...
21:03:57 <pastorn> @src recip
21:03:57 <lambdabot> Source not found. I am sorry.
21:47:02 <Olathe> @hoogle [Maybe a] -> [a]
21:47:02 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
21:47:02 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:47:02 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:47:18 <Olathe> > catMaybes [Nothing, Nothing, Just 1, Just 2, Nothing, Just 3]
21:47:19 <lambdabot>   [1,2,3]
21:47:58 <soupdragon> :t concat . map (maybe return [])
21:47:59 <lambdabot>     Couldn't match expected type `a -> a1 -> m a1'
21:47:59 <lambdabot>            against inferred type `[a2]'
21:47:59 <lambdabot>     In the second argument of `maybe', namely `[]'
21:48:04 <soupdragon> :t concat . map (maybe [] return)
21:48:05 <lambdabot> forall a. [Maybe a] -> [a]
21:48:23 <soupdragon> @src catMaybes
21:48:24 <lambdabot> catMaybes ls = [x | Just x <- ls]
22:08:31 <dmead> checkin email with boxing gloves on
22:08:40 <dmead> da sweet computer science
22:08:56 <ezyang> boom chiggy whoom pa pa
22:10:27 <Olathe> @hoogle Either a b -> Bool
22:10:28 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
22:10:28 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
22:10:28 <lambdabot> Data.Graph.Inductive.Basic isSimple :: Graph gr => gr a b -> Bool
22:10:34 <Olathe> @hoogle isLeft
22:10:34 <lambdabot> No results found
22:12:08 <dmead> if everyone in the world checked their email
22:12:13 <dmead> the internet would probably break
22:13:28 <Veinor> Olathe: Pattern matching!
22:13:44 <kmc> :t either (const True) (const False)
22:13:44 <lambdabot> forall a b. Either a b -> Bool
22:14:34 <alexyk> I'm trying to parse this JSON: "{\"9\":{\"jovenatheart\":1},\"10\":{\"beverlyyanga\":1},\"31\":{\"mcshellyshell\":1}}" -- into a type Graph = Map Int (Map String Int).  When I do: readJSON j :: Result (Array Int (Array String Int)), where j is the result of:  let j = case (decode "{\"9\":{\"jovenatheart\":1},\"10\":{\"beverlyyanga\":1},\"31\":{\"mcshellyshell\":1}}" :: Result JSValue) of {Ok j -> j; _ -> error "bad boo"}, I get
22:14:34 <alexyk> an error:  No instance for (Ix [Char])...  What do I need to add/change?
22:14:51 <BMeph> I thought I'd seen it all, but hadn't realized the depths of true horror, contained on the Internet...=8*O
22:15:23 <copumpkin> alexyk: you're trying to index an array by a string
22:15:35 <copumpkin> how do you want it to behave? :)
22:16:12 <alexyk> copumpkin: wow that was quick!  So hmm.  I actually wanted a Graph which is a Map of Maps, but JSValue parsed looks like arrays.  What to do?
22:16:21 <kmc> alexyk, for a mapping where keys are strings, use Data.Map or such
22:16:44 <alexyk> kmc: I tried, JSON doesn't read back, I get an error
22:16:48 <copumpkin> weird that they're using arrays for json
22:16:51 <kmc> alexyk, which json library?
22:17:07 <alexyk> kmc: json
22:17:10 <alexyk> 0.4.4
22:17:21 <alexyk> readJSON j :: Result (Map Int (Map String Int)) -- yields: Error "readJSON{Map}: unable to parse array value"
22:18:04 <alexyk> copumpkin: yeah, JSON says {...}, not [...]
22:18:20 <copumpkin> @hackage json
22:18:21 <lambdabot> http://hackage.haskell.org/package/json
22:18:33 <alexyk> yep, that one
22:18:45 * copumpkin looks :o
22:18:54 <copumpkin> this lame tethered 3g connection is slow as hell though
22:19:06 <alexyk> copumpkin: IRC is fast still! :)
22:20:24 <copumpkin> yep!
22:20:28 <copumpkin> did you analyze my twitter btw? :P
22:21:01 <alexyk> copumpkin: well, seems like dev-team has something to do with it :)
22:21:11 <copumpkin> :O
22:21:23 <alexyk> something about pineapple
22:21:36 <copumpkin> *pwnapple :P
22:21:41 <alexyk> more analysis needed :)
22:21:49 <copumpkin> so what generates the "No instance for (Ix [Char])" error?
22:22:29 <copumpkin> alexyk: actually the secret to my success is that I'm justin bieber's big brother
22:22:36 <copumpkin> and some of his closest fans know that
22:23:15 <alexyk> copumpkin: I'll relay that to Amanda and Yerza
22:23:40 <alexyk> you'll have some screaming fans aged 11-13 on your door, near Piazza di Italia :)
22:24:35 <copumpkin> oh no!
22:24:42 <alexyk> copumpkin: trying to parse into Array Int (Array String Int) generates the Ix.  JSValue is an array of arrays.  Um.
22:24:58 <copumpkin> oh, why are you making an Array String Int?
22:25:07 <copumpkin> the first parameter is the index type
22:25:23 <copumpkin> hmm
22:25:31 <copumpkin> seems like you might want Array Int (Map String Int)
22:25:42 <alexyk> copumpkin: I dunno, what should I stick into it?  Here's j: JSObject (JSONObject {fromJSObject = [("9",JSObject (JSONObject {fromJSObject = [("jovenatheart",JSRational False (1 % 1))]})),("10",JSObject (JSONObject {fromJSObject = [("beverlyyanga",JSRational False (1 % 1))]})),("31",JSObject (JSONObject {fromJSObject = [("mcshellyshell",JSRational False (1 % 1))]}))]})
22:25:48 * copumpkin (likes to call Map :-> sometimes)
22:26:13 <copumpkin> ugh, I hate the default Show instance for records :P
22:26:24 <copumpkin> hm
22:26:37 <danharaj> Are there disadvantages to identifying values of a datatype Foo with functions :: () -> Foo?
22:26:53 <RyanT5000> danharaj: why would you do that?
22:26:54 <copumpkin> danharaj: they're not exactly isomorphic but pretty close
22:27:01 <danharaj> copumpkin: I am intrigued, do elaborate.
22:27:12 <alexyk> so it becomes some tortured crap with a JSRational False (1 %1) -- what's that about, False?
22:27:38 <ddarius> > (\() -> undefined) `seq` 1
22:27:39 <lambdabot>   1
22:27:40 <danharaj> Ryan: No reason.
22:27:43 <ddarius> > undefined `seq` 1
22:27:44 <lambdabot>   *Exception: Prelude.undefined
22:27:49 <copumpkin> > (5, (\() -> 5) (), (\() -> 5) undefined), (\(_ :: ()) -> 5) undefined)
22:27:50 <lambdabot>   <no location info>: parse error on input `,'
22:27:54 <copumpkin> man, I fail
22:28:05 <copumpkin> > (5, (\() -> 5) (), (\() -> 5) undefined, (\(_ :: ()) -> 5) undefined)
22:28:06 <lambdabot>   (5,5,*Exception: Prelude.undefined
22:28:12 <copumpkin> anyway, you get the idea
22:28:24 <danharaj> Ok, assuming non-termination isn't present... :p
22:28:38 <copumpkin> alexyk: not sure :)
22:28:44 <danharaj> The question is not specific to Haskell, but more about generic type theory.
22:28:50 <copumpkin> danharaj: then they're the same
22:29:05 <RyanT5000> danharaj: if a type has only one value, then values of that type convey no information
22:29:09 <copumpkin> you can treat values in hask as morphisms from 1
22:29:11 <danharaj> Thanks, guys. All these things that break when bottom is in ur typez, killin ur semantics.
22:29:17 <RyanT5000> haha yeah :P
22:29:28 <RyanT5000> there are a few languages that support unlifted types
22:29:46 <copumpkin> like GHC haskell :) but then you lose lots of nice stuff
22:30:03 <RyanT5000> yeah, i guess GHC does
22:30:10 <RyanT5000> i mean languages that have it from the ground up
22:30:11 <RyanT5000> like Epigram
22:30:16 <copumpkin> alexyk: ah, the bool means whether it's a float or not
22:30:20 <RyanT5000> where you can write things and it can prove they terminate
22:30:29 <RyanT5000> and that proof is exposed in the type system
22:30:37 <copumpkin> alexyk: so it stores as much information as is in the file in a Rational, but retains whether it was a floating point value (because ieee floats are lossy)
22:30:43 <danharaj> I like the idea of Epigram, and Charity for that matter, trying to ground things in solid foundational semantics.
22:30:52 <copumpkin> danharaj: have you played with agda? :)
22:30:59 <alexyk> ok who can parse me "{\"9\":{\"jovenatheart\":1},\"10\":{\"beverlyyanga\":1},\"31\":{\"mcshellyshell\":1}}" -- into a type Graph = Map Int (Map String Int) using any json package?  I'd prefer a fast one.
22:31:03 * copumpkin beckons towards #agda for the umpteenth time
22:31:08 <danharaj> copumpkin: I'm still mulling whether I should go with Coq or Agda. They both have their merits.
22:31:25 <copumpkin> danharaj: go with agda! tactics are imperative evil and we're taught to hate that here
22:31:28 <alexyk> danharaj: agda people are coqless
22:31:33 <danharaj> hehe
22:31:34 <copumpkin> lol
22:31:52 <alexyk> #ocaml has a plethora of folklore on the latter
22:31:53 <copumpkin> danharaj: agda also has nifty features like universe polymorphism and being able to prove false
22:32:11 * copumpkin whistles
22:32:14 <danharaj> copumpkin: I get that vibe too. I've installed coq and played around with it. My concern with Agda is that it'll be harder to use it in conjunction with other languages, such as for program extraction. Also that it is not as mature.
22:32:51 <kmc> my concern with Agda is that people regularly find ways to prove False
22:32:53 <danharaj> (also how is it a nifty feature to be inconsistent :p)
22:32:57 <alexyk> see, this is what's wrong with haskell: as millions of JSON-encoded tweets swish by, folks discuss logic systems instead of parsing a damn piece of string!
22:33:07 <copumpkin> danharaj: be on the cutting edge! and pigworker hangs out in #agda, not #coq, so you can hear from the man (or one of them) behind epigram
22:33:14 <copumpkin> danharaj: pff, consistency is overrated
22:33:26 <danharaj> Nay. :p
22:33:31 <danharaj> I wonder if anyone lives in #charity
22:33:44 <danharaj> (nope)
22:33:46 <copumpkin> alexyk: seeing if I can find any cute-looking ones
22:33:57 <BMeph> danharaj: Just curious, but have you played with OBJ3, or Maude? :)
22:34:06 <danharaj> BMeph: No idea what those are.
22:34:20 <ddarius> danharaj: You should look at them.
22:34:31 <alexyk> copumpkin: any one will do, I trusted a nordic-named author from Galois can parse me some tweets, but no!
22:35:07 <alexyk> must... parse... json!
22:35:08 <danharaj> ddarius, bmeph: duly noted. This is going to be a *long* summer of categories, type theory, and programming languages.
22:35:10 <djahandarie> Is there something like foreverConditional :: (m Bool -> m Bool) which would keep on running until the inside of the monad is True?
22:35:21 <copumpkin> alexyk: I may have found a good one, jsut seeing if I can figure it out now
22:35:41 <alexyk> copumpkin: is it RJson?
22:35:45 <copumpkin> NOPE!
22:35:55 <copumpkin> it's seekrit
22:36:00 <danharaj> So, as for Agda, are the ways of deriving absurdity well separated from the properly behaving language features?
22:36:06 <alexyk> ah
22:36:15 <danharaj> (man ok fine I'll go to #agda)
22:36:26 * BMeph goes back to reading "Algebraic Semantics of Imperative Programs"...
22:39:15 <copumpkin> alexyk: almost there!
22:39:22 <alexyk> !
22:39:26 <danharaj> !!
22:40:38 <alexyk> agda has 30 people to 31 in coq right now
22:40:46 <alexyk> one of teh agda people is surely coqless
22:41:33 <alexyk> no, one of teh coq people is agdaless.  hmm.
22:42:26 <danharaj> So I've been thinking about this algebraic structure on lists: (assume the type parameter to List implicitly): [] :: () -> List , [x] :: A -> List, (++) :: List -> List -> List
22:43:12 <danharaj> This can be represented as a fold on the type of binary trees with labelled leaves: Mu(1 + A + (X,X))
22:43:48 <danharaj> I was wondering if there was a forest to this tree, metaphorically speaking.
22:45:09 <danharaj> Instead of looking at Lists as the initial algebra of its functor, looking at it as an algebra of another functor modulo some equations. In this case, the equation is that the binary operation is associative, flattening the tree.
22:45:28 <alexyk> so why can't I cabal install package and :m +Its.Module from a running ghci -- I have to quit and restart?
22:46:01 <alexyk> found something called JSONb parsing bytestrings, which is what's stored in my tokyocabinet anyways
22:46:30 <alexyk> it uses Object Trie instead of a Map for some reason
22:46:43 <kmc> efficiency perhaps
22:48:24 <haskelltime> hey, doing some RWH and I'm having trouble with an example on parsec. Here's the bit of code that's giving me a "do construct must end with an expression" error. do you guys know what I'm doing wrong?: http://codepad.org/YZ2BBEYr
22:48:50 <alexyk> yay! codepad
22:48:58 <copumpkin> almost haz it
22:50:42 <haskelltime> alexyk, love codepad
22:50:54 <haskelltime> yeah I think it's something with my indentation, idk though
22:50:54 <alexyk> copumpkin: !!
22:51:02 <haskelltime> I copied it right from the site
22:51:11 <alexyk> haskelltime: it used to actually run code, not just paste it
22:53:16 <haskelltime> alexyk, just a sec
22:53:45 <haskelltime> http://codepad.org/H4pFbxeV is my whole code
22:54:29 <haskelltime> lol you all know my name now :)
22:54:36 <haskelltime> haha forgot to change that part on my code
22:54:54 <danharaj> Your name is rather generic, so don't worry.
22:55:09 <danharaj> Mine happens to be a unique identifier in the space of ~6.5 billion people.
22:55:13 <haskelltime> danharaj, it's not generic here. do you know a lot of Fontenots?
22:55:30 <danharaj> Maybe I do. You don't know me!
22:55:38 <haskelltime> haha
22:59:07 <haskelltime> anyway pizza time. shall ponder this error message
22:59:20 <danharaj> (check your indentation)
23:00:00 <haskelltime> do you know what line the faulty indentation is on?
23:00:19 <danharaj> I actually don't, it's late where I live and my mind is hazy.
23:00:33 <haskelltime> okay thanks anyway
23:00:33 <danharaj> I don't line up my do blocks like you do, though.
23:00:56 <copumpkin> alexyk: man, this module is a pain, but I'm pretty close now :P
23:01:37 <alexyk> copumpkin: np
23:08:30 * copumpkin barfs
23:09:07 <ysph> ouch
23:09:09 <alexyk> how do you unshow a string, i.e. unescape it?
23:09:18 <copumpkin> read it
23:09:33 <copumpkin> :t read
23:09:34 <lambdabot> forall a. (Read a) => String -> a
23:09:56 <alexyk> is there a fast read for ByteString
23:10:19 <copumpkin> hmm, not sure
23:11:11 <alexyk> ok, I basically got it with JSONb.
23:11:41 <alexyk> it's just Clojure stored escaped JSON and it's parsed as String original, but when I manually read it, it's parsed as Object of Objects.
23:12:00 <alexyk> so I'll have to rewrite it from Clojure, and I'm in business.
23:12:25 <tomberek> what's the abstraction that has both  ((b->c) -> m a b-> m a c) AND ((a->b) -> m a c -> m b c)  ?
23:12:56 <danharaj> arrows?
23:13:04 <danharaj> (tenuous guess)
23:13:21 <tomberek> i sort of want to make a 'doubled' monad
23:15:32 <copumpkin> alexyk: at least you don't have all this fucking failure shit
23:15:37 <copumpkin> this library is way overengineered :P
23:15:41 <copumpkin> data-object-json :P
23:15:52 <alexyk> copumpkin: yep!  JSONb rules.
23:19:38 <djahandarie> Hm, is there some way to handle a "timeout"... as in, do some action unless it takes too long
23:20:09 <Jafet> Fork, wait, kill
23:20:20 <djahandarie> I was hoping that wasn't the answer
23:20:34 <Jafet> Well then, what kind of answer do you want
23:20:44 <djahandarie> Something that doesn't involve forking
23:22:50 * copumpkin makes a note to himself to avoid data-object-json
23:23:29 <kmc> djahandarie, threads are easy and cheap in GHC Haskell
23:23:49 <copumpkin> djahandarie: forking isn't os-level forking
23:23:51 <edlinde> hi guys I was wondering if I was to learn the basics of haskell... how do i still keep programming in it and keep my haskell skills up to date?
23:23:59 <copumpkin> it gives you a new green thread, which costs you a few bytes and almost no cpu time
23:24:07 <edlinde> I mean do all you guys work in a company or whatever that uses Haskell?
23:24:13 <kmc> edlinde, most of us don't
23:24:18 <kmc> there aren't that many Haskell jobs
23:24:31 <kmc> we write code for fun or to solve problems we encounter personally
23:24:34 <edlinde> kmc: thats a shame... so then don't you forget what you learn?
23:24:45 <copumpkin> edlinde: people program for the fun of it :)
23:24:48 <edlinde> I mean I am still at uni
23:24:55 <edlinde> yeah I understand that
23:24:58 <copumpkin> if anything they remember that more than stuff they learn cause they're forced to
23:24:59 <kmc> some of us use Haskell for one-man projects at work
23:25:10 <kmc> edlinde, i did most of my major projects at uni in Haskell
23:25:26 <edlinde> but then say I have a project or an idea that I would like to implement... its usually a fixed timeline.. I would love to code it in Haskell and show it to work
23:25:32 <kmc> djahandarie, anyway, did you see System.Timeout?
23:25:35 <edlinde> but its not that easy
23:25:50 <kmc> djahandarie, if you read the source you'll note that it forks a thread internally
23:25:52 <copumpkin> edlinde: I'd not learn haskell as you work on something you need to get done anyway
23:26:08 <copumpkin> edlinde: learn it on your own time and when you feel ready, write things in haskell
23:26:15 <edlinde> yeah thats my plan
23:26:26 <djahandarie> kmc, I suppose there isn't any other way to do it
23:26:39 <djahandarie> kmc, and thanks for that pointer, I was about to write that function myself :P
23:26:51 <edlinde> so soon I will have a summer break over which I want to learn a FP language and I want to go Haskell... though next period we have a FP course where they will use ML
23:27:34 <kmc> djahandarie, there are other ways, but i'd claim threads are the right way
23:27:36 <edlinde> copumpkin: I am kinda good with C and C++ and most of my buddies are like.. why the f**k would you bother learning a new language ?
23:27:37 <edlinde> :)
23:27:43 <kmc> since it's fundamentally a concurrent problem
23:27:47 <kmc> edlinde, they are doomed
23:27:54 <copumpkin> edlinde: yeah, most of us come from knowing imperative languages pretty well :)
23:28:04 <kmc> my favorite imperative language is Haskell :)
23:28:10 <copumpkin> edlinde: I did it because haskell looked interesting :P
23:28:24 <kmc> edlinde, show them how well Haskell handles parallel evaluation and concurrent execution
23:28:47 <edlinde> so then its this thing where say you write some code in C and you have used it for years...then you know how to make it perform if its not working well etc... and polish it up you know.... I wonder how a newbie can do the same in Haskell
23:29:08 <edlinde> I mean I may write some real shit Haskell code and then wonder why its not performing so well :)
23:29:20 <kmc> edlinde, there's a chapter on performance tuning in RWH
23:29:26 <kmc> in general it's pretty hard compared to c
23:29:30 <kmc> we can help of course
23:29:42 <edlinde> I know you guys will :)
23:29:54 <edlinde> ok for example we had to do this crypto assignment
23:30:01 <copumpkin> once you understand more of haskell evaluation works (which may be one of the toughest concepts at first)
23:30:17 <copumpkin> it'll be easier to debug the most typical performance problems
23:30:25 <edlinde> and some bits of it .. like say primality testing had a impoerative looking algorithm given to us with steps etc
23:30:49 * BMeph shudders. Object-Oriented COBOL. So much to Fear, so much to Hate... ;
23:30:57 <edlinde> this grioup chose LISP and ended up using for loops and stuff... and the prof who has used lisp forever.. was like what the fuck is this crap?
23:30:59 <edlinde> :)
23:31:13 <kmc> indeed, just understanding that evaluation and execution are different things may be one of the toughest concepts at first
23:31:16 <copumpkin> BMeph: COOBOOL?
23:31:25 <kmc> edlinde, yeah. you can write C in any language
23:31:30 <edlinde> have you guys ever had this problem of having to convert something imperative into it's functional equivalent
23:31:37 <copumpkin> kmc: I also mean the outside-in non-strict evaluation model
23:31:40 <kmc> edlinde, yes
23:32:10 <edlinde> I mean when I look at the basics of FP it seems to me that to solve something functionally you must know how to express it mathematically
23:32:11 <kmc> edlinde, you can write imperative code in Haskell, and it's a pretty good language for that.  but it's not the primary or only available style
23:32:23 <edlinde> atleast thats what it looks like to me ... as a newbie
23:32:29 <edlinde> I could be wrong.. correct me if i am
23:32:40 <kmc> the terminology is really weird... it seems that people use "imperative language" to mean "language where you must use effects", and "functional language" to mean "language where you can avoid effects if desired"
23:32:57 <edlinde> kmc: is that looked down upon.. using imperative style in Haskell?
23:32:57 <kmc> edlinde, "mathematically" just means "precisely"
23:33:07 <kmc> edlinde, in gratuitous cases, yes
23:33:11 <edlinde> well yeah like a description of the problem
23:33:13 <kmc> edlinde, but some problems are inherently imperative
23:33:20 <kmc> or at least nobody has worked out a good non-imperative treatment yet
23:33:35 <edlinde> I just saw for example the one liner on the haskell website for quick sort
23:33:42 <kmc> there is lots of effectful imperative code in Haskell, including in the std library
23:33:49 <edlinde> one x followed by many x's etc
23:33:54 <edlinde> its neat
23:33:57 <kmc> it's a myth that Haskell is bad for that style, or that there's no point to using Haskell if you need effects
23:34:11 <kmc> in fact, Haskell supports imperative effects as a first-class type
23:34:15 <mike-burns> In Haskell culture, cleverness is a virtue, and side effects are typically not clever.
23:34:16 <edlinde> k
23:34:18 <kmc> edlinde, precision is just as important in writing imperative as functional code
23:34:25 <kmc> and there's more to be precise about in imperative programs
23:35:04 <kmc> edlinde, what you may be picking up on is that Haskell is more declarative: you describe what you want to get, and not so much how to get it
23:35:26 <edlinde> I was just thinking that in haskell if you just write one line to do your quick sort.. it means a lot is taken care of behind the scenes so to say... but what if you wanted a variation.. can you write it a level deeper?
23:35:37 <edlinde> bit more fine-grained control?
23:35:44 <kmc> edlinde, yes
23:35:45 <copumpkin> sure
23:35:51 <edlinde> ok
23:36:09 <kmc> edlinde, you can go all the way down to explicit loops, allocation, pointer arithmetic, etc
23:36:22 <edlinde> pointer arithmetic in haskell?
23:36:29 <kmc> it's rarely done except for interfacing to C, or for specialized high-performance stuff
23:36:30 <edlinde> wow didn't know that
23:36:41 <edlinde> pretty neat
23:36:53 <tomberek> I'm not sure it's so easy.  I've been trying to learn Haskell for a few months now. Doesn't feel like I'm getting far
23:36:53 <kmc> basically that kind of code is a lot of work to write correctly
23:37:19 <kmc> so it's generally done for core high-performance libraries that are written by a few very smart careful people, and used everywhere
23:37:20 <Jafet> Yes folks, you can write C in any language.
23:37:24 <copumpkin> tomberek: most people don't feel fully comfortable in it for at least 6 months
23:37:27 <edlinde> tomberek: in what sense ?
23:37:44 <kmc> edlinde, as soon as you import the "Foreign" module, you get explicit malloc, memory poke/peek, pointer arithmetic and casts, etc.
23:37:47 <edlinde> ah you mean like given a problem you know you will be able to write it in haskell?
23:37:50 <copumpkin> although the more time you force yourself to spend with it the faster you'll go, obviously
23:38:03 <tomberek> Sometimes I know what I want, but can't get Haskell's type system to work with me.
23:38:04 <kmc> and type/memory safety goes out the window
23:38:09 <edlinde> 6 months phew...
23:38:11 <edlinde> thats a lot
23:38:15 <tomberek> copumpkin: thanks, i'm still working on it
23:38:21 <kmc> edlinde, there are many in-between stages of course, like working with mutable memory without unsafe pointer ops
23:38:32 <edlinde> I mean is it because its got a huge set of commands? or just getting used to its syntax and concepts?
23:38:37 <copumpkin> edlinde: it's almost completely different from any language most people have experienced
23:38:42 <copumpkin> no, it's fundamentlaly very simple
23:38:49 <copumpkin> but the simple bits glue together in interesting ways
23:38:54 <kmc> edlinde, syntax is very rarely the difficult part of anything
23:38:57 <tomberek> edlinde: it's working with the abstractions that makes it complicated
23:38:57 <edlinde> but its hard to get the fundamentals you mean :)
23:39:10 <edlinde> kmc: have you tried Perl ? :)
23:39:15 <kmc> yeah ;)
23:39:20 <edlinde> kmc: hahahhah now you know
23:39:34 <edlinde> but I like Perl .. its good for some stuff
23:39:46 <edlinde> tomberek: ok I see
23:39:56 <alexyk> I need to unescape all \" in a ByteString, doable?  \" => "
23:40:15 <kmc> alexyk, with pack . read . unpack
23:40:22 <tomberek> copumpkin: for example... right now I'm trying to created a Labeled type.  I'd like to be able to apply a label to something, but otherwise use it in exactly the same way as before.  At first I thought Writer monad, but it's giving me problems, so I tried to go at it from scratch, stil stuck.
23:40:24 <alexyk> kmc, no, in place
23:40:24 <kmc> that will also unescape other escape codes
23:40:35 <alexyk> I need da speed
23:40:58 <kmc> edlinde, Perl is good for some stuff; I think Python is better for most of that
23:41:17 <ddarius> There should be a bytestring concatMap.  You aren't going to get much faster than that.
23:41:24 <ski> edlinde : you can probably think of learning Haskell as (partly) like learning to program from scratch
23:41:31 <edlinde> kmc: yeah I had learnt how to code Perl ages ago... so didn't bother learning python
23:41:52 <edlinde> ski: hmm I can see that might be frustrating
23:42:09 <edlinde> coz you know you can do it in another language and you would be struggling to do it the haskell way
23:42:12 <edlinde> :)
23:42:24 <ski> edlinde : to be sure, some things carry over from other languages, like syntax errors, functions with arguments, expressions .. and if you've done higher-order programming and/or recursion seriously before, that helps too
23:42:39 <edlinde> kmc: but I think we did an assignment using Python.. was neat but ended up being quite slow
23:42:47 <kmc> you can think of learning Haskell as learning an aspect of programming you've already been doing in every language in an ad-hoc way
23:42:57 <kmc> and learning how to do it right
23:43:03 <kmc> it will improve your code in every language
23:43:10 <edlinde> yeah thats what I heard too ;)
23:43:17 <edlinde> maybe here in this channel :)
23:43:20 <kmc> it will also make you bitter about any job that forces you to use C++ or Java
23:43:52 <edlinde> I was actually doing quite some Java stuff a while back but now I just don't like it anymore and try to avoid it all cost
23:43:53 <BjornLopez> tired of niggers
23:43:58 <BjornLopez> sick of their monkeyshines?
23:44:01 <BjornLopez> then join our forum!
23:44:09 <ski> @where ops
23:44:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
23:44:11 <BjornLopez> c h i m p  o u t . c o m / f o r u m
23:44:24 --- mode: ChanServ set +o allbery_b
23:44:24 <kmc> once i spent about 2 weeks on a C++ project at work, then at home one day i answered a question in #haskell, which took about 1 hour, then i realized it was basically the same thing i'd done for work
23:45:03 <edlinde> kmc: and the performance?
23:45:10 --- mode: allbery_b set -o allbery_b
23:45:11 <edlinde> was it comparable? better or worse?
23:45:12 <kmc> edlinde, didn't measure
23:45:20 <edlinde> k
23:45:35 <kmc> edlinde, usually the first Haskell solution will be a lot slower than the first C or C++ solution
23:45:43 <chewbranca> two quick things, a) hpaste.org is down with a 500 error, can't access the database, and b) I'm running through the learn you a haskell tutorial and I came across the initials method in chapter 4, and it won't compile for me even if I copy paste, anyone mind taking a peak and telling me if I'm missing something? http://pastie.org/982858
23:45:46 <kmc> but you'll arrive at this solution in maybe 10% of the time
23:45:52 <edlinde> even if I used GHC compiler?
23:45:57 <kmc> yeah
23:46:05 <kmc> but this means you have time to optimize the parts you care about
23:46:13 <kmc> rather than sinking all that dev time into just getting it working
23:46:18 <mah01> is there a way how I could use ByteString with Text.Regex?
23:46:19 <mah01> subRegex (mkRegex "a") (Data.ByteString.Char8.pack "abcd") "x"
23:46:25 <edlinde> oh yeah I was going to ask... what DB do you guys use if you were writing something in Haskell which needed a database?
23:46:37 <tomberek> edlinde, compiles fine for me
23:46:50 <edlinde> is there a light weight in-memory DB that you know of that works well with Haskell?
23:46:50 <tomberek> edlinde: what error do you get?
23:47:01 <edlinde> tomberek: I get no errors
23:47:23 <djahandarie> tomberek, you are talking to the wrong person, I think.
23:47:30 <tomberek> oh.. yeah
23:47:42 <tomberek> chewbranca: what errors do you get?
23:47:56 <kmc> chewbranca, when hpaste is down i use codepad.org
23:48:00 <tomberek> edlindeL oops
23:48:08 <edlinde> tomberek: no worries
23:48:20 <edlinde> kmc: did you know about a good DB?
23:48:22 <kmc> no
23:48:33 <chewbranca> tomberek, hahaha was wondering if that was directed at me, I'm getting "parse error on input `='" which is the lastname line
23:48:38 <edlinde> k
23:49:12 <kmc> edlinde, assuming a reasonable level of skill in all three languages, and straightforward idiomatic code in each language, my very rough rule of thumb is that GHC-compiled Haskell code will be faster than CPython-interpreted Python, but much slower than C
23:49:40 <kmc> and if your program is more than a hundred lines or so, it will take much less time to get the Haskell version correct
23:49:54 <edlinde> hmm
23:49:57 <chewbranca> oh lame, its a tab character issue
23:50:03 <kmc> because Haskell is powerful, expressive, and low-bullshit (vs. C), and has lots of static checking (vs. Python)
23:50:09 <tomberek> chewbranca : ok, good, i was going to suggest that
23:50:18 <edlinde> yeah I would think the haskell code will always have lesser lines than the C equivalent
23:50:47 <chewbranca> tomberek, http://pastie.org/982858
23:50:49 <chewbranca> just updated it
23:50:50 <Jafet> The classic benchmark fallacy
23:50:56 <edlinde> would it still be faster than Python did you say/
23:51:06 <chewbranca> heh, gotta get my tabs setup better in haskell apparently
23:51:16 <kmc> don't use tabs
23:51:16 <tomberek> chewbranca: you don't have to go that far.... yeah, just use spaces
23:51:32 <kmc> edlinde, as a very rough rule of thumb, yes
23:51:38 <kmc> (and you can't compare speed of languages, only of implementations)
23:51:40 <edlinde> is there a problem with tabs in Haskell?
23:51:47 <voker57> no
23:52:00 <kmc> edlinde, Haskell's (optional) whitespace-dependent syntax interprets tabs in a way that might not be what your or someone else's editor does
23:52:04 <kmc> so it's best to avoid using them
23:52:25 <edlinde> k
23:52:29 <chewbranca> I normally set my tab characters to be spaces, but apparently it wasn't trigger for haskell files
23:52:39 <Gracenotes> mah01: there is probably a Text.Regex variant that uses ByteString, maybe? usually there is a library, and the bytestring version of that library.
23:52:43 <edlinde> I normally leave my tabs as they are :)
23:52:46 <Gracenotes> for general text-processing libraries
23:54:28 <mah01> Gracenotes, I was using regex-compat library. I don't see ByteString variant for that. But I think I will just switch to regex-pcre.
23:56:04 <Gracenotes> mah01: actually, it seems most regex-* libraries have bytestring support
23:56:45 <Gracenotes> someone should really benchmark them...
23:59:44 <ski> edlinde : it is problematic to mix tabs and spaces, in case your editor and your haskell implementation disagree about how tabs are counted (i believe GHC counts them as 8 spaces, .. or maybe as spaces til the next 8-column boundary ?) .. if you use tabs for indentation, it is probably best to always newline after layout-starting keywords (`where',`let',`of',`do')
