00:00:26 <Kaidelong> cale: it could be that the remainder is asymptotically as easy as division while modulus is linear? I'm not too familiar with low level arithmetic algorithms, but that's a guess
00:00:44 <Kaidelong> oh wait no
00:00:58 <Kaidelong> you could definitely do better than linear for the modulus using a left shift
00:01:06 <Cale> Well, the difference isn't that major
00:01:19 <pikhq> Kaidelong: Doing it on a piece of paper with traditional algorithms, though not *exactly* the same, is quite similar to what hardware is going to have to do.
00:01:22 <roconnor_> is there a haskell prime ticket for gcd and mod?
00:01:41 <Cale> (they mostly differ in sign, perhaps with plus-or-minus a copy of the divisor)
00:01:51 <dolio> What did gcd do in 1.4? Was it correct back then as well? :)
00:01:56 <pikhq> (actually, binary addition and subtraction on hardware pretty much *is* the same, except for the treatment of signs.)
00:01:58 * Kaidelong supposes he should go try implementing modulus in assembler to see for himself
00:02:15 <ddarius> @src mod
00:02:15 <lambdabot> Source not found. Just try something else.
00:02:19 <Cale> binary addition in hardware can be very different from the traditional algorithm
00:02:20 <ddarius> @src Int mod
00:02:20 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:02:24 <roconnor_> ski: we are all familar with bottom, but Scott's top is used for "contradiction" or "contraditory information" and seems to me to be appropriate for no solutions.
00:02:35 <roconnor_> ski: but I haven't really studied the issue
00:02:40 <ddarius> roconnor_: It's very common in abstract interpretation.
00:02:41 <HiyaShaya> Hi, reasonably new to haskall... if I have a datatype Point = (Float, Float) what are the simplest ways of adding the two together? Am I able to do it in one line when I'm referencing one of the points from another procedure or should I just make a new procedure  AddPoints?
00:02:57 <Cale> In fact, the traditional algorithm has an O(n) delay and cost, while it's possible to get logarithmic delay and linear cost
00:02:58 <Kaidelong> uncurry(+)
00:03:00 <pikhq> Cale: Okay, fine, "naive implementations". Obviously, there's a whole lot of things you can do that screw up analogies.
00:03:03 <Kaidelong> :t uncurry(+)
00:03:03 <lambdabot> forall a. (Num a) => (a, a) -> a
00:03:04 <roconnor_> HiyaShaya: make a new procedure
00:03:13 <Kaidelong> > uncurry(+) $ (5,5)
00:03:14 <lambdabot>   10
00:03:17 <roconnor_> HiyaShaya: or rather make a new function
00:03:37 <Cale> (the key to doing that is noticing that the 3 possibilities for "what happens to a carry at this position" form a monoid
00:03:59 <roconnor_> HiyaShaya: you could give it a fancy infix name, such as <+>, if you are feeling kean.
00:04:12 <roconnor_> HiyaShaya: as an aside these are vectors, not points
00:04:25 <roconnor_> HiyaShaya: points are something a little different and cannot be added
00:04:26 <Cale> and from that monoid, you can reassociate and combine those effects on the carry in the fashion of a binary tree)
00:04:29 <HiyaShaya> Hmm well thinking in java terms, if I have a function returning a datatype, I could do function.x and function.y
00:04:43 <HiyaShaya> I was wondering if something similar was in haskall
00:04:49 <Kaidelong> oh oops, sorry, I read that very wrongly
00:04:56 <Cale> fst p + snd p
00:05:06 <dolio> Don't use <+>. That's an important combinator in the Wadler-Leijen pretty printer. :)
00:05:09 <Cale> HiyaShaya: Or more likely, you could pattern match
00:05:10 <roconnor_> addVector (x1,y1) (x2,y2) = (x1+x2,y1+y2)  -- we can use pattern matching
00:05:17 <Cale> Or use uncurry, since it's a pair anyway
00:05:39 <roconnor_> dolio: are you serious?
00:05:39 <HiyaShaya> uncurry?
00:05:50 <ski> roconnor_ : .. it just seems to me that often we (myself included) confuse these two different senses of "undefined"
00:05:58 <Cale> uncurry takes a function of two parameters and turns it into a function on pairs
00:06:05 <Kaidelong> (x1,y1) +^+ (x2,y2) = (x1+x2,y1+y2)
00:06:06 <Cale> :t uncurry
00:06:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:06:07 <Kaidelong> for infix
00:06:08 <dolio> It seriously is an important combinator in the library. Join horizontally with space.
00:06:21 <roconnor_> HiyaShaya: wait, are you adding two points, or are you adding the two cordinates of one point?
00:06:27 <roconnor_> HiyaShaya: I think I misunderstood
00:06:28 <copumpkin> :t let moo (f, x) = f x in moo
00:06:29 <lambdabot> forall t t1. (t -> t1, t) -> t1
00:06:37 <Cale> > uncurry (+) (10,2)
00:06:38 <lambdabot>   12
00:06:38 <HiyaShaya> roconnor_, the former
00:06:39 <roconnor_> ski: I agree
00:06:43 <Cale> oh, okay
00:06:48 <Cale> then uncurry won't help
00:06:49 <HiyaShaya> of course the result is x1 + x2, y1 + y2
00:06:52 <Kaidelong> HiyaShaya: are you adding two vectors?
00:06:57 <HiyaShaya> pretty much
00:07:02 <roconnor_> addVector (x1,y1) (x2,y2) = (x1+x2,y1+y2)
00:07:03 <Kaidelong> because then use the pattern match
00:07:04 <Kaidelong> yeah
00:07:18 <roconnor_> > let addVector (x1,y1) (x2,y2) = (x1+x2,y1+y2) in addVector (5,6) (8,3)
00:07:19 <lambdabot>   (13,9)
00:07:43 <HiyaShaya> is addVector a haskall function or should I make it myself?
00:07:48 <Cale> another option, if you're going to do lots of work with vectors is just to install the vector-space package
00:07:55 <Cale> and import Data.VectorSpace
00:07:55 <Silvah> @pl (\(x1,y1) (x2,y2) -> (x1+x2,y1+y2))
00:07:55 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
00:08:04 <Cale> Then you can just use ^+^ to add them
00:08:06 <ski> HiyaShaya : you define it by the equation given by roconnor_
00:08:14 <Kaidelong> @unpl uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
00:08:14 <lambdabot> uncurry (\ ab f -> (\ p x -> ((,)) (ab + (fst p)) (f + x)) >>= \ ag -> snd >>= \ af -> return (ag af))
00:08:20 <HiyaShaya> okay, thanks
00:08:25 <dmwit> :t (***)
00:08:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:08:27 <Cale> (and there are lots of other useful operations on vectors in that package)
00:08:31 * ddarius would recommend using a (custom) strict pair type rather than 2-tuples.
00:08:48 <dmwit> :t (+) *** (+)
00:08:49 <HiyaShaya> Cale, I probably won't need too many vector operations
00:08:49 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
00:08:50 <Silvah> Strict?
00:08:50 <Kaidelong> I like the "flip flip"s in there
00:09:01 <roconnor_> Cale: where is the vector space library?
00:09:06 <c_wraith> :t flip flip fst
00:09:06 <Kaidelong> :t flip flip]
00:09:09 <Cale> roconnor_: vector-space
00:09:09 <Kaidelong> :t flip flip
00:09:15 <lambdabot> forall (f :: * -> *) b a b1. (Functor f) => f (((a, b1) -> a) -> b) -> f b
00:09:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
00:09:15 <lambdabot> parse error on input `]'
00:09:18 <Cale> On hackage
00:09:31 <dmwit> :t ($) *** ($)
00:09:32 <lambdabot> forall a b a1 b1. (a -> b, a1 -> b1) -> (a -> b, a1 -> b1)
00:09:33 <ski> @type Prelude.flip Prelude.flip
00:09:35 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
00:09:45 <dmwit> :t uncurry (***)
00:09:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
00:09:57 <dmwit> :t uncurry (***) ((+) *** (+))
00:09:59 <lambdabot>     Couldn't match expected type `(b, b')'
00:09:59 <lambdabot>            against inferred type `a -> a -> a'
00:09:59 <lambdabot>     In the first argument of `(***)', namely `(+)'
00:10:04 <ski> .
00:10:11 <dmwit> :t uncurry (***) . ((+) *** (+))
00:10:11 <Cale> That reminds me, I sent Conal mail about the instance for functions and didn't check to see if he replied :)
00:10:12 <lambdabot> forall c c'. (Num c, Num c') => (c, c') -> (c, c') -> (c, c')
00:10:21 <Kaidelong> :t flip (.)
00:10:23 <dmwit> Take that, ?pl!
00:10:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
00:10:44 <Kaidelong> :t (. flip (.))
00:10:46 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (((a -> b1) -> f b1) -> b) -> f a -> b
00:10:52 <Kaidelong> enough of that
00:11:03 <roconnor_> ddarius: HiyaShaya is a beginner, let's not worry about strict pair types yet.
00:11:22 <ddarius> roconnor_: Then tomorrow we get to discuss why his code is stack overflowing.
00:11:32 <HiyaShaya> oh dear
00:11:39 <ddarius> and/or is dog-slow and consuming tons of heap.
00:11:50 <dmwit> :t uncurry (***) . on (***) (+)
00:11:54 <lambdabot>     Couldn't match expected type `(a b c, a b' c')'
00:11:55 <lambdabot>            against inferred type `c1 -> (c1, c1) -> (c1, c1)'
00:11:55 <lambdabot>     Probable cause: `on' is applied to too few arguments
00:12:10 <roconnor_> ddarius: we will deal with that tomorrow
00:12:11 <dmwit> :t uncurry (***) . join (***) (+)
00:12:13 <lambdabot> forall b. (Num b) => (b, b) -> (b, b) -> (b, b)
00:12:19 <HiyaShaya> ddarius I don't think the complexity of my code will result as such
00:12:22 <Cale> type Scalar (a -> v) = a -> Scalar v  -- this is the main thing about the vector-space library which bugs me at the moment :)
00:12:39 <ddarius> HiyaShaya: You'd be surprised.
00:12:47 <ski> (Cale : is that a type family ?)
00:12:57 <Cale> ski: yeah
00:13:00 <HiyaShaya> I probably would be considering I'm a java/python type.
00:13:33 <Kaidelong> HiyaShaya: I personally learned Scheme and F# first since they were more familiar
00:13:46 <Kaidelong> but I'm enjoying my stay in haskell for now
00:14:09 <Cale> HiyaShaya: Basically, if you do a lot of computations on pairs all at once, and those computations don't need to pattern match on the components at any point, you can get large expressions building up in the components of your pair which blow the stack when you finally get around to evaluating them
00:14:13 <Kaidelong> lazy evaluation can lead to behavior that seems unexpected, though
00:14:35 <Cale> But there are easy enough ways around that problem if you run into it
00:15:24 <HiyaShaya> I guess I'll tinker further and come crying back if such a thing happens
00:15:39 <Cale> HiyaShaya: yeah, we can help if it does :)
00:15:48 <Kaidelong> f t = (uncurry seq t `seq`)
00:15:50 <Kaidelong> ?
00:15:53 <HiyaShaya> :) thanks everyone for the help thus far though
00:15:54 <Kaidelong> could that work to stop that?
00:16:14 <Kaidelong> :t (uncurry seq t `seq`)
00:16:15 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `Expr'
00:16:15 <lambdabot>     In the second argument of `uncurry', namely `t'
00:16:15 <lambdabot>     In the first argument of `seq', namely `uncurry seq t'
00:16:23 <Kaidelong> ah right
00:16:24 <Kaidelong> parameter
00:16:42 <Kaidelong> :t (\t->(uncurry seq t `seq`))
00:16:43 <lambdabot> forall a b t. (a, b) -> t -> t
00:17:21 <Kaidelong> type looks right
00:17:35 <Cale> It might help, but it'd e more straightforward to just either use a bang pattern or two, or change to using strict pairs.
00:17:37 <Cale> be*
00:17:52 <Kaidelong> like (!a,!b) ?
00:18:00 <Kaidelong> and pass -XBangPatterns?
00:18:07 <dmwit> ?unpl \t -> (uncurry seq t `seq`)
00:18:07 <lambdabot> \ t a -> seq (uncurry seq t) a
00:18:20 <Cale> or add {-# LANGUAGE BangPatterns #-} to the top of the file
00:18:34 <Cale> (because -X switches get tedious :)
00:18:38 * Kaidelong just learned something, thanks!
00:18:42 <dmwit> That is a strange function.
00:19:13 <Kaidelong> :t (\t->(uncurry seq t `seq` t))
00:19:14 <lambdabot> forall a b. (a, b) -> (a, b)
00:19:19 <dmwit> :t uncurry seq
00:19:20 <lambdabot> forall a b. (a, b) -> b
00:19:21 <Kaidelong> that one is neater probably
00:19:27 <Kaidelong> takes a tuple, evaluates it, and returns it
00:19:28 <dmwit> That one is different, though.
00:19:47 <Kaidelong> or if you want to make it clear it's weird and imperative I guess you could do
00:19:52 <Kaidelong> :t (\t->(uncurry seq t `seq` ()))
00:19:53 <lambdabot> forall a b. (a, b) -> ()
00:20:14 <Cale> Kaidelong: actually, takes a tuple, evaluates its first component, and returns it
00:20:16 <Kaidelong> well, not imperative, just... a strategy, rather than a function?
00:20:21 <dmwit> "uncurry seq t" says, when the second part of the tuple is demanded, also demand the first part
00:20:33 <Kaidelong> isn't seq strict in both its arguments Cale?
00:20:38 <dmwit> no
00:20:39 <Kaidelong> unlike pseq
00:20:51 <copumpkin> pseq isn't either
00:21:07 <Cale> It's strict in a technical sense
00:21:10 <Kaidelong> huh, my understanding was that seq is strict in both and pseq only in the first
00:21:13 <Cale> (in both its components)
00:21:24 <Cale> and pseq is strict in that sense as well
00:21:38 <copumpkin> well pseq is explicitly lazy in the returned value
00:21:42 <copumpkin> with the magic lazy function :P
00:21:53 <Cale> that's... a bit of a lie though
00:22:00 <copumpkin> seq is kind of boringly strict in its second argument
00:22:03 <Cale> That's the compiler lying to itself
00:22:04 <Kaidelong> copumpkin: so pseq explicitly tries to stop GHC from making something strict?
00:22:15 <Kaidelong> while seq will let it happen if the compiler feels like it
00:22:16 <roconnor_> id is strict
00:22:40 <Cale> GHC tells the strictness analyser that the second parameter of pseq is lazy so that it won't accidentally go and evaluate it first.
00:22:53 <copumpkin> pseq  x y = x `seq` lazy y
00:23:16 <Cale> yes, but that's a hack ;)
00:23:20 <copumpkin> yep, I know
00:23:23 <copumpkin> just showing how it's defined :)
00:23:31 <ddarius> Kaidelong: There is no difference in meaning between seq and pseq, the difference is in operation behavior (guarantees).
00:23:41 <dmwit> So, do I have this right? (\t a -> seq (uncurry seq t) a) says, when a is demanded, also discover that t is a tuple
00:23:43 <ddarius> s/operation/operational/
00:24:02 <Cale> See, the meaning of seq is that seq x y is _|_ if x is _|_, and it's equal to y otherwise
00:24:04 <Kaidelong> ddarius: the difference is important though, right? pseq makes sure the right side is evaluated after the left
00:24:10 <Kaidelong> and that sets it apart?
00:24:17 <copumpkin> newtype STM a = STM (State# RealWorld -> (# State# RealWorld, a #))
00:24:23 <copumpkin> where have I seen that before!
00:24:30 <Cale> copumpkin: lol
00:24:38 <c_wraith> STM is secretIO!
00:24:43 <ddarius> Kaidelong: The difference is important operationally, but it will never lead to a different result being returned (unless you are doing something shady).
00:24:55 <ddarius> Kaidelong: It can lead to different performance though and that is why it is there.
00:25:09 <dmwit> (where "shady" could mean something as commonplace as "running out of stack")
00:25:14 <Cale> (It also can't lead to a difference in termination behaviour)
00:25:27 <Kaidelong> ddarius: I suppose that's a good reason to make the return type of your evaluation strategies ()?
00:25:31 <Cale> dmwit: hmm...
00:25:37 <Cale> dmwit: Can that actually happen?
00:25:41 <Kaidelong> so that people don't see two equivalent functions
00:25:50 <Kaidelong> but see two potentially different strategies?
00:25:53 <dmwit> Cale: Oh, yes, seq can turn a stack overflow into an answer.
00:26:15 <copumpkin> wow, there's a lot of stuff in GHC.Conc
00:26:16 <Cale> dmwit: yes, but is there ever a difference between seq and pseq in that regard
00:26:34 <ddarius> Cale: I'm sure I could make an example with a bit of trying.
00:26:35 <dmwit> Oh, is that what we were contrasting? sorry
00:26:47 <dmwit> <- totally in the dark about pseq
00:26:50 <copumpkin> I thought the select-based IO stuff was in the RTS, but it's actually in GHC.Conc
00:26:57 <dolio> Cale: I imagine the compiler could reorder seq-based code into something that still overflows the stack.
00:27:13 <dolio> Whereas pseq's operational guarantees would prevent that.
00:27:42 <ddarius> dmwit: seq is just ("unnecessarily") strict in its unreturned argument.  pseq is as well, but it provides the operational guarantee that that argument will be evaluated before the returned argument.
00:28:15 <ddarius> dmwit: Put algebraically, a `seq` b === b `seq` a `seq` b.
00:28:24 <Cale> Another question: is there any purpose in giving pseq a separate name? Are there any cases where seq currently does better than pseq?
00:28:53 <dmwit> huh
00:28:55 <ddarius> Cale: If that wasn't the case, then presumably seq would be defined to be pseq.
00:28:58 <copumpkin> I thought the compiler had a little more freedom with seq
00:29:01 <c_wraith> theoretically, pseq might break strictness optimizations in cases where seq won't.
00:29:03 * Kaidelong presumes the algebraic property mentioned above might be a good thing in some cases?
00:29:04 <copumpkin> so they kept them separately
00:29:09 <dmwit> How is it possible to obtain seq's behavior without satisfying pseq's guarantee?
00:29:21 <kmc> seq has denotational semantics only
00:29:24 <kmc> not operational semantics
00:29:26 <dmwit> Strictness analysis, maybe, to avoid evaluating things that are known not to be bottom...?
00:29:48 <Cale> dmwit: When you evaluate seq x y, always evaluate y first, then x, then return y
00:30:02 <dmwit> oh oh
00:30:17 <Cale> (that would break pseq's guarantee)
00:30:20 <dmwit> Now I understand what ddarius was saying with his "algebraically" bit. =P
00:30:46 <Kaidelong> seq makes sure that if the right is evaluated, the left is too, while pseq makes sure of not only that but also that the left will be evaluated before the right is evaluated?
00:31:02 <ddarius> Kaidelong: Correct.
00:31:08 <Kaidelong> so seq will stop an expression from growing a thunk in one of its components
00:31:14 <Kaidelong> but does not restrict evaluation order
00:31:20 <roconnor_> Cale: does seq really work that way?
00:31:35 <Cale> roconnor_: Sometimes, if the strictness analyser does something funky
00:31:38 <roconnor_> It seems seq wouldn't have the space leak fixing properties it appears to have if it did
00:31:44 <ddarius> roconnor_: The compiler can and does evaluate the arguments to seq in different orders at different times.
00:31:47 <dmwit> "if the right is evaluated, the left is too" <- I thought the point of ddarius' and Cale's examples were that this part was *not* true
00:32:07 <ddarius> dmwit: No, that is true.  That's what the denotational semantics of seq requires.
00:32:15 <Cale> Well, it's awkwardly worded
00:32:22 <dmwit> You just told me it could evaluate b, then evaluate a, then return b.
00:32:28 <dmwit> Which would make that part false.
00:32:30 * Kaidelong wonders what would happen if the right side of seq doesn't use the value of the left side of seq, is the left side evaluated? presuming seq is right associative, of course?
00:32:34 <Cale> Just writing seq x y somewhere doesn't ensure that evaluating *y* will ensure that x is evaluated.
00:32:58 <dolio> Technically you might be able to avoid the left part being evaluated if the right is bottom.
00:33:00 <ddarius> Kaidelong: Yes.  That is the purpose of seq.
00:33:11 <Kaidelong> is seq right associative then?
00:33:23 <ddarius> Kaidelong: It is.
00:33:29 <dmwit> infixr 0 seq
00:33:35 <ddarius> Though I don't think it actually matters.
00:33:37 <Cale> But not only is it right-associative, seq is associative
00:34:17 <Cale> It's easy to see that if any one of x, y, z are bottom, then (x `seq` y) `seq` z and x `seq` (y `seq` z) are both bottom
00:34:21 <Kaidelong> ddarius: in "x `seq` y `seq` z", if it doesn't need to evaluate x for y, but needs to evaluate it for z, it might matter
00:34:26 <Cale> and if none of them are, then they're both equal to z
00:34:39 <ddarius> dmwit: If the right argument of seq is never forced, then the left argument may never be forced.  If it is forced, then the left argument will be forced.  That doesn't say when those will happen just that they are related.
00:34:44 <Kaidelong> that was my reasoning for it being right associative
00:34:45 <Cale> and so the parens don't matter
00:34:53 * dmwit nods
00:34:54 <dmwit> thanks
00:35:04 <Kaidelong> hmm
00:35:42 <Kaidelong> z doesn't need to evaluate y
00:35:47 <Cale> ?
00:35:48 <Kaidelong> y doesn't need to evaluate x
00:35:54 <Kaidelong> z needs to evaluate x
00:35:55 <Silvah> And what was the original question?
00:36:08 <Kaidelong> if it is left associative, couldn't you end up building a thunk around x instead of strictly evaluating it?
00:36:16 <Cale> Kaidelong: what?
00:36:24 <Cale> Kaidelong: Here's how seq is defined
00:36:29 <Cale> seq _|_ y = _|_
00:36:39 <Cale> seq x y = y, if x is not _|_
00:36:46 <copumpkin> man, can I pattern match on _|_?!?
00:36:50 <ddarius> Kaidelong: All seq talks about are semantics.  "Thunks" aren't part of the semantics of Haskell.
00:36:54 <copumpkin> sweet, is that new in 6.12.2? :P
00:36:57 <dmwit> copumpkin: Yep, use view patterns and seq! ;-)
00:37:18 <Cale> copumpkin: You can pattern match on _|_ if the result you want is _|_ too.
00:37:18 <copumpkin> sweet
00:37:20 <dmwit> copumpkin: Unfortunately, the RHS can only be _|_ if you match _|_ anywhere on the left... =P
00:37:26 <copumpkin> I guess I could adopt my own package spoon
00:37:30 <Kaidelong> ddarius, I suppose it doesn't matter, I was just curious about something like "(x `seq` y) `seq` f(x)
00:37:43 * copumpkin shudders
00:37:56 <Kaidelong> are you guaranteed that x is strictly evaluated before f(x) is returned?
00:38:05 <Cale> Kaidelong: For all x, y, z, we have that (x `seq` y) `seq` z = x `seq` (y `seq` z)
00:38:08 <dmwit> Kaidelong: When you demand (f x), you will demand (x `seq` y), which demands y, which demands x.
00:38:12 <Cale> Kaidelong: they are identical
00:38:23 <Cale> tsk
00:38:32 <Cale> well...
00:38:45 <Cale> dmwit: That order is the questionable one, but allowable :)
00:38:59 <dmwit> right, change everything to pseq in my example =P
00:39:06 <Cale> actually, it's not demanding f x which causes (x `seq` y) to be demanded
00:39:17 <Cale> It's demanding (x `seq` y) `seq` f x
00:39:25 <dmwit> Yes, that's an important distinction, too.
00:39:32 <dmwit> I lose precision when I get tired. =/
00:39:57 <c_wraith> how many bits per unit of tiredness?  and what is the unit of tiredness, anyway?
00:40:13 <dmwit> dis many
00:40:16 * dmwit holds his hands out
00:40:21 <Kaidelong> so the function actually returns an expression (x `seq` y) `seq` f x, which will evaluate y if you evaluate it?
00:40:32 <Cale> Kaidelong: yes
00:40:34 <Kaidelong> hence `seq` being associative
00:40:35 <Kaidelong> I see
00:40:35 <dmwit> Oh, I'm sorry, did you want a more precise answer...?
00:40:43 <c_wraith> not when you're tired
00:40:57 <Cale> Kaidelong: It will ensure both x and y are evaluated before the case which you're using to pattern match on it gets to evaluate
00:41:23 <Kaidelong> hmm, pseq would not be associative, would it?
00:41:29 <Kaidelong> I suppose that's another important distinction
00:41:30 <Cale> It would be associative too
00:41:32 <Kaidelong> oh?
00:41:42 <c_wraith> it has the same denotational semantics, after all.
00:41:47 <Kaidelong> oh!
00:41:48 <ddarius> Kaidelong: Semantically it's associative.  Operationally it is not.
00:41:50 <Cale> seq and pseq have identical denotational semantics
00:41:57 <Kaidelong> ddarius: I just realized
00:42:01 <Cale> and so if one is associative, the other is too
00:42:04 <Kaidelong> I am talking operationally
00:42:10 <dolio> Operationally it isn't?
00:42:12 <Cale> Operationally, you still get that it's roughly associative.
00:42:41 <dmwit> Huh, how does (operational) associativity break?
00:42:52 <dolio> (x `pseq` y) `pseq` z --> before evaluating z, evalute (before evaluating y, evaluate x).
00:43:12 <Cale> Or less backwards, evaluate (x then y) then z
00:43:19 <dolio> x `pseq` (y `pseq` z) --> before evaluating (before evaluating z evaluate y) evaluate x.
00:43:27 <Cale> which is the same as evaluating x, then (y then z)
00:43:32 <dolio> Right.
00:43:34 <Kaidelong> dmwit: in an expression x `pseq` (y `pseq` z), the right side might never actually be evaluated
00:43:35 <ddarius> Oh, I think I was thinking of a form of commutativity.
00:43:47 <ddarius> I was thinking of my earlier algebraic expression for seq.
00:43:47 <Kaidelong> I think that's what I was thinking of here
00:44:03 <dmwit> Kaidelong: In the expression (x `pseq` y) `pseq` z, the same thing is true
00:44:10 <Cale> > error "a" `seq` (error "b" `seq` error "c")
00:44:12 <Kaidelong> but the right side is z
00:44:12 <lambdabot>   *Exception: a
00:44:20 <Kaidelong> as opposed to (y `pseq` z)
00:44:20 <dmwit> Kaidelong: the other right side =)
00:44:22 <ddarius> So, yes, pseq is associative operationally.
00:44:46 <dmwit> Kaidelong: If x diverges, neither y nor z will be evaluated in either expression.
00:45:09 <Cale> With seq, it would be okay for the Haskell evaluator to produce *any* of the 3 errors there
00:45:17 <Cale> With pseq, only "a" would be okay
00:45:38 <Silvah> What are you talking about now, really?
00:45:48 <Kaidelong> evaluation order
00:46:35 <Silvah> Does it really matter as long as the result is correct?
00:46:42 <dolio> Yes.
00:46:52 <Cale> Silvah: Not usually, but in terms of performance, it can matter.
00:47:19 <Kaidelong> and parallel programming too
00:47:21 <Cale> Evaluation order makes the difference between this:
00:47:29 <Cale> > foldl (+) 0 [1..1000000]
00:47:30 <lambdabot>   *Exception: stack overflow
00:47:33 <Cale> and
00:47:36 <Cale> > foldl' (+) 0 [1..1000000]
00:47:36 <lambdabot>   500000500000
00:48:02 <lewis1711> well I hope you guys like noobs cause this ones a doozy. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25550#a25550 I get that error when I print the second function. that's my entire source.
00:48:18 <dmwit> Associative operators should use foldb. ;-)
00:48:27 <Kaidelong> the error is just that it can't print a function to the console, lewis1711
00:48:34 <Cale> lewis1711: It's just saying that it doesn't know how to print a function
00:48:35 <Kaidelong> it doesn't say there is something wrong with your code
00:48:37 <dmwit> lewis1711: You can't print functions.
00:48:47 <Cale> You can tell it how, if you want
00:48:59 <Cale> by writing an instance of Show for functions, like lambdabot has
00:49:08 <Cale> (or downloading one from hackage)
00:49:11 <Kaidelong> > (+)
00:49:13 <lambdabot>   -3->
00:49:13 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
00:49:13 <lambdabot>  -2->
00:49:13 <lambdabot>    {-3->-5;-2->...
00:49:16 <Cale> But normally you'll just get an error
00:49:21 <Kaidelong> ... huh
00:49:28 <Kaidelong> that's very informative
00:49:40 <Cale> > and
00:49:41 <lambdabot>   []->
00:49:41 <lambdabot>    True
00:49:41 <lambdabot>  [True]->
00:49:41 <lambdabot>    True
00:49:41 <lambdabot>  [True,True]->
00:49:42 <lewis1711> I'm not trying to print functions. I'm just trying to do "signalAdder 4" in the interpreter. why does that attempt a print?
00:49:43 <lambdabot> [3 @more lines]
00:49:46 <Cale> > (&&)
00:49:46 <lambdabot>   {True->{True->True;False->False};False->{True->False;False->False}}
00:49:56 <dmwit> Informative, but still a little shy of what you'd need to write a Read instance. ;-)
00:50:04 <Cale> lewis1711: Because signalAdder has another parameter
00:50:04 <ski> lewis1711 : `signalAdder' takes two arguments (curriedly)
00:50:22 <Cale> lewis1711: So signalAdder 4 is a function which takes the second parameter
00:50:53 <lewis1711> ohhh....
00:50:56 * lewis1711 facepalms
00:51:01 <lewis1711> thanks:)
00:51:05 <Cale> no problem :)
00:51:32 * Kaidelong wonders if it'd be a good idea in the interactive shell to remind people that they might be giving too few parameters
00:51:36 <Axman6> anyone know much about huffman codes?
00:52:00 <Cale> Axman6: a little
00:52:23 <Kaidelong> in a function that takes a tuple, you get a type error, in a curried function, you get an error about functions not being instances of show
00:52:33 <Kaidelong> both are somewhat uninformative to a person starting out
00:52:42 <dmwit> lewis1711: stepFunction x | x > 0 = 1 | otherwise = 0 -- depending on your style, you might like this
00:53:22 <lewis1711> dmwit: yeah I knew that'd be easier, but I'm just having a go with doing it a more mathematical way:)
00:53:55 <dmwit> Nah, you're just hiding the comparison and branch. ;-)
00:53:57 * Kaidelong sees what F# does... apparently FSI does know how to print functions... not very helpful either
00:53:58 <dmwit> ?src Int abs
00:53:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:55:05 <ddarius> Kaidelong: There was an implementation of a cut-down version of Haskell called Helium that was geared toward teaching and having understandable error messages.
00:55:14 <ddarius> @where helium
00:55:15 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
00:57:46 <dolio> Helium doesn't have type classes, right?
00:57:51 <Cale> What I don't understand is how Huffman coding's even-more-obvious brother, arithmetic coding, is so patent encumbered.
00:59:34 <Cale> I would never grant anyone a patent for it. It's like the most obvious possible thing you could do to devise an encoding if you know the relative frequencies of a bunch of symbols you want to send.
00:59:51 <copumpkin> everything is obvious in retrospect! ;)
00:59:55 <copumpkin> (but I agree)
01:00:07 <Cale> It's what I would normally come up with
01:00:10 <Kaidelong> Cale: the people who grant patents don't always have time to really think about these things, nor incentive to
01:00:16 <lewis1711> I really need another book apart from "learn you a haskell for great good"
01:00:22 <dmwit> ?where rwh
01:00:22 <copumpkin> real world haskell
01:00:22 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:00:25 <dmwit> ?where lyah
01:00:26 <lambdabot> http://www.learnyouahaskell.com/
01:00:26 <Kaidelong> lewis1711: I like RWH
01:00:29 <dmwit> ?where gentle
01:00:30 <lambdabot> http://www.haskell.org/tutorial/
01:00:43 <dmwit> Be a man. Read the Gentle Introduction.
01:00:44 <Kaidelong> Gentle I like less but it's a nice reference
01:00:45 <copumpkin> ?where painful
01:00:45 <lambdabot> I know nothing about painful.
01:01:04 * dmwit sighs
01:01:11 <dmwit> The Gentle Intro is still my favorite.
01:01:25 <dmwit> ...of course, it's still the only general-purpose Haskell tutorial I've read.
01:01:28 * Kaidelong personally liked RWH the best
01:01:40 * Kaidelong supposes it is a matter of taste
01:01:46 * copumpkin hasn't actually read any of them
01:01:52 <ddarius> dolio: iCorrect.
01:01:52 * Kaidelong would recommend just reading all three
01:02:04 <dmwit> ?where report
01:02:05 <lambdabot> http://www.haskell.org/onlinereport/
01:02:08 <dmwit> Another good one. =)
01:02:10 <dolio> It also made the odd decision that 'type Integer = Int' as I recall.
01:02:49 <copumpkin> o.O
01:02:56 <Kaidelong> no arbitrary percision? o.O
01:02:56 <kmc> uh
01:03:03 <kmc> wouldn't the other way make much more sense
01:03:14 <ddarius> I also like the Gentle Introduction.
01:03:22 <kmc> gentle introduction is good but it's not a tutorial
01:03:31 <kmc> it's an informal version of the language spec, with examples
01:03:42 <dolio> kmc: One would think so.
01:03:46 <kmc> but not tutorial examples, which start with a simple complete thing and add features to make more complicated complete things
01:04:01 <Kaidelong> for a quick tutorial learnyouahaskell is probably quite nice since it focuses on stuff you can easily play around with in GHCi
01:04:19 <kmc> i think there's a role for at least one tutorial
01:04:22 <kmc> one more*
01:04:29 <dmwit> I don't know. Every time I go to learn a language, I find there are no tutorials at quite the pace I want.
01:04:47 <copumpkin> we need a parametrized tutorial
01:04:47 <dmwit> Give me the syntax all in one big hunk and a pointer to the library documentation.
01:05:09 <dmwit> I felt like the Gentle Intro was exactly that kind of pace: just the important bits.
01:05:15 <kmc> it would be cool to do something pretty close to SICP in Haskell
01:05:22 <copumpkin> how about a choose your own adventure style tutorial
01:05:23 <kmc> by the last chapter you implement a simple Haskell compiler
01:05:36 <copumpkin> "if you feel you understand this stuff, feel free to skip ahead to X"
01:05:39 <kmc> speaking of
01:05:41 <copumpkin> with hyperlinks
01:05:51 <dmwit> hyperlinks
01:05:52 <kmc> is there a good explanation of how to implement typeclass instance resolution / context reduction?
01:05:56 <dmwit> Now we're talking futuristic.
01:06:00 <copumpkin> lol
01:06:12 <lewis1711> can I make a function the argument of another function? f(g(x)) type thing
01:06:17 <kmc> yes
01:06:18 <kmc> @src (.)
01:06:18 <lambdabot> (f . g) x = f (g x)
01:06:19 <lambdabot> NB: In lambdabot,  (.) = fmap
01:06:19 <dmwit> ?src (.)
01:06:20 <lambdabot> (f . g) x = f (g x)
01:06:20 <lambdabot> NB: In lambdabot,  (.) = fmap
01:06:28 <kmc> > show (succ 3)
01:06:29 <lambdabot>   "4"
01:06:32 <kmc> > (show . succ) 3
01:06:34 <lambdabot>   "4"
01:06:34 <copumpkin> lewis1711: maybe you mean f(g) ?
01:06:36 <kmc> > show . succ $ 3
01:06:37 <lambdabot>   "4"
01:06:39 <copumpkin> lewis1711: both are possible
01:06:42 <ddarius> kmc: Presumably "Typing Haskell in Haskell"
01:06:43 <copumpkin> and g(x) could return another function
01:07:35 <lewis1711> copumpkin: I'm not sure I understand the difference
01:07:47 <kmc> lewis1711, f(g(x)) is not a function as an argument.  it's the result of calling a function as an argument
01:07:54 <kmc> g(x) might be a Char or something else non-functiony
01:08:12 <kmc> in my examples above, x is an Int, g is succ and f is show
01:08:24 <Kaidelong> f(g(x)) == f (g x) == (f . g) x == f . g $ x
01:08:27 <kmc> you're not passing a function to a function
01:08:30 <kmc> an example of that would be
01:08:33 <kmc> > map succ [1,2,3]
01:08:34 <lambdabot>   [2,3,4]
01:08:41 <lewis1711> f . g being function composition?
01:08:42 <kmc> the first argument to the function "map" is itself a function, "succ"
01:08:44 <kmc> lewis1711, yes
01:08:45 <Kaidelong> yep!
01:08:57 <Kaidelong> learnyouahaskell covers this early on
01:09:00 <dmwit> > (map succ [3, 4], show (succ 3)) -- compare: one passes a function to another function, one does not
01:09:01 <kmc> in conventional math notation, what i wrote above would be map(succ, [1,2,3])
01:09:02 <lambdabot>   ([4,5],"4")
01:09:14 <lewis1711> ohhh
01:09:54 <Kaidelong> :k (a -> b)
01:09:55 <lambdabot> Not in scope: type variable `a'
01:09:55 <lambdabot> Not in scope: type variable `b'
01:09:57 <kmc> anyway the nice thing about writing (f . g) is that it's a first-class value itself
01:10:02 <dmwit> :k State
01:10:02 <kmc> meaning that instead of writing
01:10:03 <lambdabot> * -> * -> *
01:10:04 <kmc> h x = f (g x)
01:10:06 <kmc> you can just write
01:10:08 <kmc> h = f . g
01:10:14 <kmc> and you don't need to invent an arbitrary local name 'x'
01:10:16 <dmwit> :k (->)
01:10:17 <lambdabot> ?? -> ? -> *
01:10:29 <Kaidelong> :k id
01:10:30 <lambdabot> Not in scope: type variable `id'
01:10:31 <Kaidelong> eh
01:10:39 <Kaidelong> id is a function
01:10:41 <dmwit> values don't have kinds, only type (constructors) do
01:10:42 <Kaidelong> of course
01:10:49 <kmc> :k Ord
01:10:50 <lambdabot> Class `Ord' used as a type
01:10:59 <kmc> classes sort of have kinds, but GHCi won't tell you much about them
01:11:00 <apolon> hi hi
01:11:03 <kmc> hi apolon
01:11:05 <copumpkin> it annoys me
01:11:07 <dmwit> :k forall a b. a -> b
01:11:08 <lambdabot> *
01:11:17 <Kaidelong> oh!
01:11:41 <Kaidelong> so you need a universal quantifier to stop the interactive environment from trying to figure out the kind of b?
01:11:51 <dmwit> There are not too many (distinct) values of type (a -> b).
01:11:58 <ski> @. kind type id
01:12:00 <lambdabot> *
01:12:05 <ddarius> Kaidelong: You need a binder to put a and b in scope.
01:12:57 <dmwit> It's still figuring out the kind of b.
01:13:00 <Kaidelong> :k forall a b c. a -> b c
01:13:01 <lambdabot> *
01:13:04 <dmwit> :k forall f a. f a -> a
01:13:05 <lambdabot> *
01:13:06 <dmwit> exactly
01:13:26 <ski>   MonadReader :: * -> (* -> *) -> instance  -- roughly
01:14:08 <ddarius> Eq :: * -> 2
01:14:24 <lewis1711> no I don't want function composition (it's impossible anyway I think because my functions take different numbers of variables). I want more.... f(x) = a, g(a)
01:14:44 <ski> @sort 2
01:14:44 <lambdabot> Maybe you meant: more part src
01:15:06 <dmwit> lewis1711: that's an odd equation =)
01:15:07 <ski> lewis1711 : `f x = (a,g a)' ?
01:15:16 <dmwit> lewis1711: Those 'a's probably meant to be 'x's...?
01:15:16 <apolon> what is the split-base flag and how do you use it?
01:15:23 <Axman6> Cale: sorry i didn't reply whe i asked about huffman codes, i realised i had to leave
01:15:48 <lewis1711> more the return value of one function as an argument for another
01:16:00 <copumpkin> lewis1711: that's function composition
01:16:12 <dmwit> yeah
01:16:13 <kmc> lewis1711, every function is really of one argument.  but if the types don't match it will be a problem
01:16:13 <Cale> g . f
01:16:29 <kmc> lewis1711, you mean "let a = f x in g a"?
01:16:36 <kmc> that's just a verbose way to write "g (f x)"
01:16:38 <kmc> or (g . f) x
01:16:47 <kmc> they're all valid haskell
01:16:59 <dmwit> or (g . f $ x) or a half a dozen others =)
01:17:09 <ddarius> ski: Eq is a predicate on types.
01:17:21 * Kaidelong prefers the form dmwit mentions since it reminds him of piping
01:17:26 <dolio> * -> o
01:17:39 <dmwit> ddarius: Did you want Eq :: * -> * -> 2, then?
01:17:48 <ddarius> dmwit: No.
01:17:50 <dmwit> (A different Eq than the Prelude one?)
01:17:53 <lewis1711> but if a function takes an argument from a set of ordered pairs, and another function takes an argument from a set of single numbers, how can they be composed together? I tried, btw
01:18:19 <dmwit> mmm, yes, I get what you're saying now
01:18:26 <lewis1711> like (g . f) x y, but g only takes x
01:18:29 <dmwit> That's a strange sort of view of classes. =P
01:18:34 <ski> ddarius : yes, and what is the sort of propositions ?
01:18:39 <dmwit> Less strange as I get it, though.
01:18:40 <Cale> lewis1711: Can we see what you tried? Nothing about what you said suggests that it shouldn't work.
01:18:45 <lewis1711> ok
01:18:51 <Cale> g . f $ (x,y)  should work
01:19:03 <ddarius> ski: Call it whatever you like.  Call it Prop.
01:19:08 <Cale> If f takes a pair, and not just two parameters
01:19:12 <lewis1711> oh what... I had (f . g) x y
01:19:15 <lewis1711> lemme try that
01:19:25 <Cale> Or (g . f) (x,y)
01:19:36 <Cale> Or g (f (x,y))
01:20:29 <ddarius> dmwit: A type class is a set of type constructors, or, dare I say it, a class of type constructors.
01:21:16 <lewis1711> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25553#a25553 (I realise for this example there are far easier ways of doing it but I am just trying out concepts right now)
01:21:28 <lewis1711> can't use the third function
01:21:32 <Cale> right
01:21:40 <Cale> comb takes two parameters, not an ordered pair
01:22:09 <Axman6> huh, there's no instance for Arbitrary Char?
01:22:13 <lewis1711> oh right, so I need set notation?
01:22:18 <ski> if you had defined `comb (x,y) = ...', it would have worked
01:22:37 <Cale> You could write something like  stepFunction . comb x $ y
01:22:39 <ski> `logicalAnd x y = (stepFunction . comb) (x, y)
01:22:56 <ski> (er, stupid newline in clipboard ..)
01:22:59 <Cale> But I'd probably just write  stepFunction (comb x y)
01:23:06 <Cale> Or  stepFunction $ comb x y
01:23:09 <lewis1711> ohhh
01:23:14 <Cale> (in this case)
01:23:31 <scoles> I'm using the threads package (http://hackage.haskell.org/package/threads-0.1) to try and wait for my threads to finish before exiting but it doesn't seem to be working.  My code is here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25551#a25552 (Line 30)
01:23:43 <Cale> lewis1711: f x y and f (x,y) are not the same thing, is all
01:24:07 <apolon> is there any automatic way to update all packages to their newest cabal versions?
01:24:17 <lewis1711> working:) well my maths is off but the function works
01:25:20 <Cale> apolon: That is often not a good idea.
01:25:29 <apolon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25554#a25554
01:25:41 <Cale> apolon: In particular, I don't recommend installing newer versions of any of the packages which come with ghc
01:26:15 <apolon> cale: what is the recommended way to proceed in cases such as this one?
01:26:16 <Cale> mmm
01:27:30 <Axman6> Cale: what i was wondering about with huffman codes is what is the most efficient way to store the coding/decoding tree
01:28:07 <Cale> apolon: time in particular is one of those packages which you don't want to install multiple versions of normally...
01:28:29 <Cale> Axman6: I've never actually implemented them, so I wouldn't know. What's wrong with the obvious way?
01:28:55 <Cale> I suppose if you're using them for compression, you care about that :)
01:29:05 <Axman6> yeah ;)
01:29:22 <Cale> But if you're compressing anything huge, I wouldn't expect the tree to be much in comparison with what it was you were compressing.
01:29:36 <Axman6> yeah
01:29:48 <apolon> according to ghc-pkg list | grep time I have old-time-1.0.0.3, time-1.1.3, time-1.2.0.2
01:29:56 <Axman6> though, where i'm learning about them is in relation to digital comms, so the amounts of data could be quite small
01:30:15 <Cale> apolon: old-time is fine, leave that alone
01:30:15 <apolon> but i just want to install the chart package
01:30:36 <apolon> and when i run cabal install i get
01:30:38 <Cale> apolon: But this new time-1.2.0.2, I wonder if you really need it
01:31:09 <apolon> ok never mind it doesn't work at all
01:31:15 <Cale> apolon: The problem with having multiple versions of packages is that you end up with stuff being built against different versions and being incompatible for use together.
01:31:45 * Axman6 -> dinner
01:32:24 <Cale> So, probably the time-1.1.3 is installed globally and time-1.2.0.2 is installed as user?
01:32:38 <apolon> hm, how would I check that?
01:32:52 <Cale> They'll show up under different headings in  ghc-pkg list time
01:33:36 <apolon> i set cabal option to install globally by default, so they're both in /usr/local/lib/...
01:33:57 <Cale> Oh, I wouldn't advise that, generally.
01:34:53 <apolon> wow, now ghc-pkg says my packages are broken because  dependency "random-1.0.0.2-73731d6fe830cac111c10a232c73ab5b" doesn't exist
01:34:58 <Cale> Since you can get your packages screwed up, and need to reinstall GHC, whereas if you only install things locally and everything gets tangled, you can just blow away your .cabal and start over.
01:35:28 <Cale> Er, .cabal and .ghc
01:35:31 <apolon> hm... that makes sense
01:35:49 <apolon> then again, do you often have to blow away your entire ~/.cabal ?
01:35:55 <Cale> Not often, no :)
01:35:57 <Silvah> Where they're stored?
01:36:01 <Cale> You can also be more careful about it
01:36:28 <Cale> and use ghc-pkg to unregister a bunch of stuff and then cabal to rebuild things which were built against it
01:36:29 <apolon> any idea what's with the random-1.0.0.2-blabla package?
01:36:33 * scree blows away .cabal and .ghc every other week or so
01:37:03 <Cale> random-1.0.0.2 is one of the packages that comes with GHC 6.12.2
01:37:16 <Silvah> Perhaps it doesn't exist.
01:37:44 <apolon> i have random-1.0.0.2 installed, but when I run ghc-pkg check I get
01:38:21 <apolon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25555#a25555
01:38:54 <Cale> can you paste the output of ghc-pkg list?
01:39:14 <Silvah> Where are these .cabal and .ghc stored under Windows?
01:39:36 <dmwit> apolon: recently upgrade an Arch system?
01:40:07 <apolon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25556#a25556
01:41:10 <dmwit> If so, check out the register.sh scripts in /usr/share/haskell/**
01:41:18 <apolon> dmwit: i don't even know what that is
01:41:33 <dmwit> Okay, that's a no, then. =)
01:41:33 <Cale> apolon: Okay, so the problem, I think, is that you have a copy of random-1.0.0.2 installed which is *different* from the copy that those packages were built against
01:41:42 <dmwit> (Arch is a distribution of Linux.)
01:42:04 <apolon> oh no, not in a while
01:42:21 <Cale> apolon: and since dph-* and haskell98 are basic packages that come with ghc, that means you've overwritten your copy of random-1.0.0.2, and broken them.
01:42:31 <apolon> although I'm gonna put the newest ubuntu whenever I get time...
01:43:12 <apolon> cale: so i should just reinstall random-1.0.0.2 then?
01:43:14 <Cale> So I think your best bet is to remove and reinstall ghc -- keep cabal install though, you'll still be able to use the binary
01:44:00 <Cale> The problem is that random-1.0.0.2 got reinstalled over top of your original one at some point, and got a different hash
01:44:19 <apolon> ugh!  ]
01:44:41 <Cale> You can't and/or don't want to rebuild all those packages against the new random-1.0.0.2 (most of them are part of the GHC distribution)
01:45:03 <apolon> so should i just cabal install ghc?
01:45:10 <Cale> that doesn't work :)
01:45:22 <apolon> oh yeah!
01:45:26 <Cale> Just get the generic linux binary from the ghc website and install it :)
01:45:38 <apolon> ok, will do.  thanks :)
01:46:18 <Cale> Well, you may want to remove the directory /usr/local/lib/ghc-6.12.1/ beforehand
01:46:27 <apolon> wait -- should I install the platform instead?  generally, what are the advantages of the haskell platform?
01:46:33 <Cale> but don't remove your copy of cabal-install, since that'll be useful
01:46:36 <Silvah> Nobody knows the answer to my question?
01:46:42 <Cale> I'm not using platform, and I'm happy
01:46:53 <Cale> Silvah: not a windows user, sorry
01:47:16 <Cale> I might be able to google it :)
01:48:47 <apolon> cale, 1 more question: if i were to remove everything and start it from scratch (e.g. after installing a new distro), in what order should cabal-install and ghc be installed?
01:49:27 <Cale> apolon: Well, to compile cabal-install, you need ghc
01:49:52 <Cale> and cabal-install won't work without ghc being installed, I'm pretty sure
01:50:03 <zachk> how do i use where in lambdabot?
01:50:10 <Cale> Well, or some Haskell implementation, at least :)
01:50:30 <Cale> > let f x = y^2 + y where y = x+1 in f 7
01:50:31 <lambdabot>   72
01:50:50 <kmc> zachk, "where" binds to an equation, not an expression.  so you'd have to use it within "let" or another "where"
01:50:55 <kmc> whereas "let ... in ..." is an expression
01:51:10 <kmc> > let f x = y^2 + y; y = x+1 in f 7
01:51:11 <lambdabot>   (x + 1) * (x + 1) + (x + 1)
01:51:23 <apolon> what's the difference between the two linux binaries -t and -n (one needs libtinfo.so.5)
01:51:26 <kmc> ehh?
01:51:29 <Cale> haha
01:51:37 <kmc> oh right hhe
01:51:53 <Cale> apolon: I just get the other one
01:52:20 <Cale> The -n version
01:52:32 <Cale> I'm not sure why they do that
01:52:38 <scoles> kmc, spare a minute?
01:52:44 <kmc> yeah
01:52:50 <kmc> or if not, other people can
01:52:53 <kmc> i don't do PM though
01:52:56 <Cale> Maybe libtinfo is LGPL?
01:53:36 <apolon> cale, should i really delete /usr/local/lib/ghc-6.12.1 ?? that sounds scary -- it took so much headache to get yi to work!
01:53:42 <Cale> But even if it was, there wouldn't be any need...
01:54:03 <Cale> apolon: Well, you can very well have multiple copies of ghc installed
01:54:18 <Cale> apolon: It just takes a fair chunk of space if you're not using one of them
01:54:45 <apolon> what about any distribution packages which might think ghc is still there?
01:54:47 <scoles> I can't figure out why I can't get the main thread of my program to wait for all the spawned threads to finish executing.  I'm using the threads package (http://hackage.haskell.org/package/threads-0.1) .  I even tried another package on hackage and had the same results.
01:55:01 <Cale> apolon: But you have it installed in /usr/local, don't you?
01:55:10 <Cale> apolon: I didn't think it was your distribution's ghc
01:56:50 <apolon> wow, actually my distro thinks i have 6.8.2 :[[[
01:57:22 <Cale> ubuntu is generally behind
01:57:35 <Cale> I don't use Ubuntu's version of any Haskell packages
01:57:45 <Cale> (as a matter of policy :)
01:58:13 <dolio> Nor I.
01:58:35 <apolon> what about things that haskell packages depend on, like gtk2hs needs that glib or something
01:58:52 <dolio> Yes, I use those.
01:59:15 <Cale> Yeah, I use Ubuntu to install the C libraries that Haskell libraries bind to
02:00:55 <zachk> > let pSum n = sum $ map (\x->mod (p n x) n) [1..100] where p k x = x^k+x*(k-1) in filter (\m->pSum m==0) [2..100]
02:00:57 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
02:01:37 <Cale> > (1,2) ^+^ (50,70)
02:01:38 <lambdabot>   (51,72)
02:01:41 <Cale> :)
02:01:46 <Cale> :t (^+^)
02:01:47 <lambdabot> forall v. (AdditiveGroup v) => v -> v -> v
02:02:00 <LeNsTR> ^_^
02:02:27 <zachk> :t (^*^)
02:02:29 <lambdabot> Not in scope: `^*^'
02:02:32 <zachk> :(
02:02:37 <Cale> :t (*^)
02:02:38 <lambdabot> forall v. (VectorSpace v) => Scalar v -> v -> v
02:03:24 <apolon> yaaaayy I got 6.12.2!
02:04:04 <Cale> > 5 6
02:04:05 <lambdabot>   Ambiguous type variable `t' in the constraint:
02:04:05 <lambdabot>    `GHC.Num.Num t' arising f...
02:04:17 <Cale> hmm
02:04:41 <Cale> > (5 :: Integer -> Integer) 6
02:04:42 <lambdabot>   5
02:04:44 <Cale> heh
02:05:34 <Silvah> Uhm...
02:05:43 <dolio> Boy, people are going to love that even more than your other changes.
02:05:52 <Silvah> Why does it work?
02:06:07 <dolio> > 5 :: [Integer]
02:06:08 <lambdabot>   No instance for (GHC.Num.Num [GHC.Integer.Internals.Integer])
02:06:08 <lambdabot>    arising fr...
02:06:11 <Cale> Silvah: Because there's a Num instance for functions.
02:06:23 <kmc> scoles, sorry, was afk.  did your question get answered?
02:06:31 <Cale> Silvah: From Data.NumInstances, from the vector-space package
02:07:08 <Cale> instance Num b => Num (a->b) where
02:07:09 <Cale>   negate      = fmap negate
02:07:09 <Cale>   (+)         = liftA2 (+)
02:07:09 <Cale>   (*)         = liftA2 (*)
02:07:09 <Cale>   fromInteger = pure . fromInteger
02:07:09 <Cale>   abs         = fmap abs
02:07:11 <Cale>   signum      = fmap signum
02:07:20 <Silvah> Haskell never ceases to astonish me...
02:08:15 <copumpkin> > (+1) + (+2) $ 5
02:08:16 <lambdabot>   13
02:08:44 <Cale> > (*10) + (*100) $ 5
02:08:47 <lambdabot>   550
02:09:04 <dolio> > sin + 1 $ (pi / 2)
02:09:05 <lambdabot>   2.0
02:09:12 <Silvah> Okay, I'm totally lost.
02:09:18 <copumpkin> :P
02:09:31 <Cale> > map (sin^2 + cos^2) [1..10]
02:09:32 <lambdabot>   [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.999...
02:09:42 <Cale> tsk, approximation.
02:09:46 <Cale> > map (sin^2 + cos^2) [1..10] :: [CReal]
02:09:47 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
02:09:47 <ivanm> Cale: are you doing more caleskell stuff to have sin^2 and cos^2 work?
02:09:53 <ivanm> @type sin^2
02:09:54 <lambdabot> forall a. (Floating a) => a -> a
02:09:57 <Cale> ivanm: Just importing Data.NumInstances
02:10:00 <copumpkin> ivanm: I think it's conal's fault!
02:10:04 <ivanm> Cale: oh? where's that from?
02:10:07 <Cale> vector-space
02:10:17 <ski> > id :: () -> ()
02:10:18 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> ())
02:10:18 <lambdabot>    arising from a use of...
02:10:24 <ivanm> copumpkin: Conal, Cale... they both start with C and they contain an `a'; close enough is good enough!
02:10:37 * ivanm notices that copumpkin's name _also_ starts with `c'...
02:10:41 <Cale> Oh dear, we've broken the show instance for functions again
02:10:53 <ski> it's `Data.NumInstances's fault !
02:11:00 <Cale> yes
02:11:20 <ivanm> Cale: because of how Num requires Show?
02:11:22 <Cale> because in order to have Num instances, you have to have Show instances
02:11:30 <Cale> and so there are some fake Show instances in there
02:11:32 <ski> ("  instance GHC.Show.Show (a -> b)  -- Defined in vector-space-0.6.2:Data.NumInstances")
02:11:55 <ivanm> Cale: do you know _why_ the report wants that?
02:11:59 <Cale> ivanm: no
02:12:25 <Cale> ivanm: I know why it wants Eq, but I think even that's a poor reason.
02:12:32 <ski> ivanm : i presume it is because of `trace . show'-style debugging, and wanting to not add another constraint
02:12:35 <dolio> ivanm: So you can just write (Num n) in your signatures, instead of (Eq n, Num n, Show n).
02:12:44 <Cale> (It wants it just in case you decide to use an n-pattern, and end up needing Eq)
02:12:45 <copumpkin> terrible reason
02:13:12 <ivanm> ski: hmmm..... except it's not hard to write a variant of trace that will do that and specifies Show
02:13:25 <ivanm> dolio: how often do you need Show n?
02:13:26 <Cale> There were some people on the Haskell 98 committee who didn't seem to understand typeclasses very well. :/
02:13:44 <ivanm> Cale: "n-pattern"?  As in pattern matching on numbers?
02:13:44 <ski> Cale : i think it would be fine to generate an `Eq n' constraint in that case  (since you can't write `f x = let g x = ...' and expect the inner `x' to match the outer one)
02:13:49 <Cale> Of course, typeclasses were still sort of new, so maybe we can't blame them.
02:13:51 <Cale> ivanm: yeah
02:13:54 <dolio> ivanm: I don't know. Depends how many trivial one-liners you write.
02:13:58 <Cale> ski: I do too
02:13:58 <ivanm> I think that might be fair enough...
02:14:23 <ivanm> preflex: seen Axman6
02:14:23 <preflex>  Axman6 was last seen on #haskell 42 minutes and 38 seconds ago, saying: * Axman6 -> dinner
02:14:46 <ski> ivanm : the point was not about having to add `Show n' on `trace' (or a variant of it), but on the function that calls that
02:14:54 <ivanm> ski: hmmm....
02:15:25 <Cale> ski: But trace didn't even exist back then
02:15:34 <dolio> trace doesn't exist in H98, so that can't be the reason.
02:15:43 <ski> Cale : hm .. maybe it didn't
02:15:48 * ivanm guesses its because they didn't think people would do crazy stuff with Num
02:15:54 <Cale> It not only doesn't exist in H98, it didn't exist in GHC until a fair bit later, as I recall.
02:15:55 <dolio> You can't even write it, because unsafePerformIO doesn't exist until you get the FFI addendum.
02:16:16 <ski> dolio : well, maybe it existed in implementations, and that is still the reason ?
02:16:25 <ivanm> "Yeah, we need some way of dealing with numbers; let's just slap something together that works, it's not like we're going to have any hard-core mathematicians bitching about this or weirdos wanting to do weird stuff with it"
02:16:26 <ivanm> ;-)
02:16:58 <Cale> The frustrating thing is that they came so close to being mathematically satisfying in a lot of ways
02:17:09 <Cale> and yet there are still these weird things
02:17:29 <ivanm> yeah
02:17:42 <copumpkin> are there archives of the discussions that went into this?
02:17:44 <ivanm> did anyone actually end up getting a decent and usable numeric hierarchy defined?
02:17:50 <copumpkin> I'd be curious to see who proposed that stuff and what the justification was
02:17:53 <Cale> I love the fact that we have three exponentiation operators, and the div/mod vs. quot/rem thing.
02:17:56 <copumpkin> ivanm: nope
02:17:59 <Cale> copumpkin: There were, at least...
02:18:01 <ivanm> copumpkin: well, it was probably discussed in person...
02:18:10 <Cale> copumpkin: At one point, a long time ago, I read them all.
02:18:16 <Cale> I forget where they were.
02:18:16 <copumpkin> h98 was late enough to be over email
02:18:20 <copumpkin> but I dunno
02:18:20 <Cale> There was a mailing list.
02:18:24 <ivanm> Cale: well, I get the specialisation of ^ vs ** (though I've never had to need ^^)
02:18:35 <ivanm> and there are some cases where you want mod, and others were you want rem
02:18:41 <dolio> I've definitely read the discussion about fail, so there's probably records of any discussion about Num.
02:18:42 <ivanm> (and most langs stuff that up and only provide rem)
02:18:58 <Cale> ivanm: right, while if you were only going to provide one, you'd want it to be mod
02:19:18 <ivanm> yeah
02:19:27 <ivanm> since you're more likely to want mod for CS stuff than rem
02:19:30 <Cale> I remember reading the discussion about Num, but I don't remember the reasoning for Show
02:19:37 <ivanm> but I'm guessing rem is easier to calculate... >_>
02:19:43 <Cale> Only the reasoning for Eq
02:19:49 <ivanm> Cale: maybe it is from Haskell 1.0 or one of the predecessor langs?
02:20:16 <Cale> Well, we can easily check those
02:20:22 <copumpkin> we should assemble an elite assassination squad to murder whoever proposed Show
02:20:28 <copumpkin> Eq isn't as bad
02:20:33 <copumpkin> (as a superclass for Num)
02:21:22 <dolio> Not as bad, but still bad.
02:21:23 <Cale> Okay, Num was in 1.4 in its current condition
02:21:36 <Cale> So that was an even earlier decision
02:21:40 <copumpkin> so possibly old enough to be discussed in person
02:21:42 <copumpkin> damn
02:21:45 <copumpkin> we may never know!
02:21:55 <ski> (somewhat related apropos division and remainder : <http://people.csail.mit.edu/riastradh/tmp/division.txt>,<http://srfi.schemers.org/srfi-77/mail-archive/msg00505.html>)
02:22:07 <copumpkin> oho, it's riastradh
02:22:19 <dolio> In 1.0, it was just Eq.
02:22:46 * Cale looks at the Haskell 1.3 prelude and sees "class Functor f where map :: (a -> b) -> f a -> f b"  and cries a little bit on the inside :)
02:22:50 * ivanm wonders what the significance of the 0 in div0 and mod0
02:23:00 <ivanm> Cale: because they removed it?
02:23:07 <ivanm> why did they do that? to simplify it?
02:23:13 <Cale> Yeah, that they split map into map and fmap
02:23:25 <copumpkin> evil
02:23:25 <dolio> Ah, by 1.1 it was (Eq a, Text a).
02:23:26 <ivanm> after all, it's not likely anyone actually uses Haskell for serious programming...
02:23:32 <Cale> Because beginners would complain that functors are teh hards
02:23:34 <ivanm> dolio: and Text is the old name for Show?
02:23:35 <ski> ivanm : i believe it is sometimes called "minimal remainders"
02:23:43 <ski> (ivanm : scroll down a little bit)
02:23:46 <dolio> Still looking for Text, but I assume so.
02:23:58 <Cale> 1.3 has (Eq a, Show a, Eval a) => Num a
02:24:05 <dolio> Oh, Text is a combination of Read and Show.
02:24:06 <ivanm> ski: neither link has the word "minimal" in it
02:24:21 <scoles> I can't for the life of me figure out how to have my main thread wait.  I've tried rolling my own solution and a few hackage packages but nothing works.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25558#a25558  Line 30 should have the thread wait for all the others but it doesn't seem to be doing anything at all.  Once the zipWIthM finishes the threads die.
02:24:21 <hydo> Anyone know if Michael Snoyman happens to hang out here ever?
02:24:29 <copumpkin> snoyberg is his nick I think
02:24:39 <copumpkin> preflex: seen snoyberg
02:24:39 <preflex>  Sorry, I haven't seen snoyberg
02:24:41 <hydo> cool, thanks copumpkin!
02:24:42 <copumpkin> maybe not
02:24:44 <hydo> awww
02:25:07 <hydo> Thanks just the same.
02:25:10 <kmc> scoles, did you try my little "spawn" function instead of the "threads" library?
02:25:10 <ivanm> according to nickserv, that nick was last online 19 weeks and 6 days ago
02:25:13 <kmc> i'm not familiar with the latter
02:25:16 <copumpkin> :)
02:25:21 <dolio> Huh, 1.1 had a primitive type for bit sequences, I think.
02:25:27 <Cale> scoles: Use a QSemN, maybe?
02:25:40 <dolio> Called Bin.
02:25:43 <ivanm> dolio: like what erlang does?
02:25:46 <kmc> scoles, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25559#a25559
02:25:58 <Cale> scoles: from the main thread,  s <- newQSemN 0, before making your threads
02:26:18 <Cale> scoles: and then have each of the threads  signalQSemN s 1  when they're done
02:26:21 <kmc> Cale, what's the Eval class?
02:26:29 <dolio> ivanm: Probably not so fancy. But there was a class similar to Text for the binary sequences as well.
02:26:34 <Cale> and have your main thread do  waitQSemN s n, where n is the number of threads
02:26:35 <ivanm> *nod*
02:26:40 <Cale> kmc: seq :)
02:27:06 <ivanm> Cale: so WHNF?
02:27:09 <ivanm> or more like deepseq?
02:27:13 <Silvah> Oh, this seq thing again...
02:27:13 <Cale> ivanm: WHNF
02:27:17 <Cale> just the usual seq
02:27:22 <ivanm> *nod*
02:27:22 <Cale> But it used to be in a typeclass
02:27:28 <Cale> to preserve parametricity
02:27:32 <ivanm> Cale: but now it works automagically?
02:27:34 <Cale> yeah
02:27:43 <Cale> It became a builtin
02:27:47 <ivanm> huh? how would using a typeclass preserve parametricity?
02:27:55 <copumpkin> Silvah: seq makes haskell practical, but also ruins a lot of its elegance (so we often ignore it)
02:27:58 <kmc> ivan, because a function of type "a -> b" can't seq its arg
02:28:01 <kmc> you have (Eval a) => a -> b
02:28:09 <kmc> and then you know that it can
02:28:14 <ivanm> kmc: hmmmm.....
02:28:19 <ivanm> kmc: so what $! does?
02:28:56 <kmc> ?
02:28:57 <Silvah> > length . filter (== '#') $ "(# State# RealWorld, Addr# #)"
02:28:58 <lambdabot>   4
02:29:08 <Cale> Well, you'd have  ($!) :: (Eval a) => (a -> b) -> a -> b
02:29:08 <dolio> seq was magic even when it was part of a type class.
02:29:15 <kmc> it wouldn't have to be
02:29:16 <dolio> Automatically defined for everything, and worked on functions.
02:29:27 <kmc> yeah it would have to be magic for functions, i guess
02:29:34 <kmc> or you have to expose some kind of algebraic constructor for functions
02:29:40 <ivanm> kmc, Cale: oh, you mean that the type sig would tell you if the function used seq?
02:29:41 <dolio> Surprised me when I looked it up. The only change with 98 was removing the type class.
02:29:41 <Cale> dolio: hmm, was that *always* the case, or was there a point at which it didn't work for function types?
02:29:45 <kmc> ivanm, yes
02:29:46 <Cale> ivanm: yeah
02:30:14 <dolio> Cale: I seem to recall it always working on functions when I looked. Certainly it did in 1.4.
02:30:42 <copumpkin> is there some theoretical reason why it makes so much intuitive sense for functions to have no constructors, but all other types to have them?
02:30:44 <Cale> yeah
02:30:44 <dolio> At least, always from when it was introduced. I don't recall what version that was.
02:30:58 <Cale> copumpkin: Well...
02:31:13 <dolio> copumpkin: Codata doesn't have constructors.
02:31:18 <Cale> copumpkin: I guess because functions are an abstract type
02:31:30 <dolio> And functions are more like codata than data.
02:31:44 <Cale> functions are like bidata ;)
02:31:46 <ivanm> copumpkin: because functions aren't "concrete" data types?
02:31:48 <copumpkin> dolio: "more like" meaning they're neither?
02:32:15 <copumpkin> I guess it'd make sense for them to be neither
02:32:25 <dolio> They're like data if you think of them as being built as lambda terms somehow.
02:32:45 <Cale> They're like data with respect to the result, and codata with respect to the parameter?
02:32:57 <copumpkin> or codata if you think of them as being observable if you provide parameters
02:32:58 <copumpkin> ?
02:32:59 <ski> ivanm : hm, maybe i'm imagining things, but for positive integers `d', i've heard `0 =< mod n d < d' holding for "principal residues", while `-d/2 =< mod n d =< d/2' holding for "minimal residues"
02:33:00 <dolio> Which is how seq works. It evaluates until it sees a lambda.
02:33:01 <quicksilver> dolio: but if you think of them as being built from lambda terms you get the wrong kind of equality.
02:33:03 <ski> (cf. "reduced residue system")
02:33:15 <ivanm> ski: hmmm.... that might make sense
02:33:21 <dolio> quicksilver: Right. You get intensional equality.
02:33:33 <dolio> Similarly, intensional equality is the wrong equality on codata.
02:33:40 <ski> (so, "minimal" would be wrt absolute value)
02:34:13 <ski> Cale : checking .. have you seen those terms "principal residues" and "minimal residues" before ?
02:34:52 <Cale> ski: I haven't, myself, but I also don't think I'd have had much occasion to.
02:35:14 <ski> ok (hm, yes, now i remember you saying you haven't done much number theory)
02:36:20 <dolio> At least, as far as I know. The usual intensional equality used on data in type theories isn't purely intensional; it's intensional equality on normal forms.
02:36:49 <Cale> It's sort of a lie that I haven't done so much number theory, since I did take a whole course on algebraic number theory. However, said course also scarred me for life. But nowhere in that did we ever have any occasion to care which representative of each equivalence class you chose.
02:36:49 <dolio> Perhaps there is a way to 'normalize' codata such that intensional equality on it is also useful, but I've never seen such a thing.
02:37:33 <ivanm> if I wanted a right-based version of Set.unions, what would be better: "Set. unions . reverse" or "foldl (flip Set.union) Set.empty" ?
02:37:43 <Cale> I do remember reading a somewhat Haskell-oriented paper about different potential definitions for division, and I *might* have seen it there, but I don't recall.
02:38:04 <ski> ok
02:38:31 <quicksilver> ivanm: probably the former
02:39:07 <ivanm> quicksilver: *nod* I was thinking so as well, but doing a reverse scares me... >_>
02:39:37 <dolio> Cale: seq is magic in 1.3, as well.
02:39:47 <Cale> dolio: okay, interesting :)
02:39:52 <ski> (.. function types are like codata because the adjunction for them has them on the right)
02:40:04 <Cale> ski: oh, nice
02:40:52 <Silvah> Theory, theory, theory, and even more theory... Nobody is interested in practice?
02:41:11 <copumpkin> Silvah: we sure are!
02:41:34 <ski> well, in theory, practice require theory :)
02:41:54 <dolio> I don't see seq in 1.2...
02:42:44 <apolon> anybody know where to get the latest gtk2hs?  it asks me for a password when I follow instructions on http://haskell.org/gtk2hs/
02:42:54 <Silvah> And in practice theory and practice are equal only in theory.
02:43:06 <FunctorSalad_> sometimes you think the theory is excessive... then you have to do something with some less-than-elegant language...
02:43:09 <FunctorSalad_> :)
02:43:36 <FunctorSalad_> (making you appreciate theory again, that is)
02:45:09 <dolio> 1.2 also doesn't look like it allows strict fields, so I assume seq didn't exist back then.
02:45:16 <Cale> Silvah: Yeah, sorry, we're all language enthusiasts, so theory and history of programming languages (and Haskell in particular) often comes up :)
02:45:37 <FunctorSalad_> Silvah: as I see it (from what little experience I have), the theory is valueable due to the fact that in the heat of practical battle, you just won't be in the mindstate to do the theory
02:45:44 <Cale> Silvah: Just wait, we'll switch to talking about things even less related to actual programming eventually ;)
02:45:44 <quicksilver> in practice, theory is more interesting than real work :)
02:46:59 <FunctorSalad_> btw I joined in the middle
02:47:11 <sosman> "it works in practice but will it work in theory?"
02:48:21 <mreh> Warning: Control.Arrow.Random: could not find link destinations for: System.Random.RandomGen Control.Arrow.ArrowChoice Control.Arrow.Arrow Control.Arrow.ArrowApply Control.Category.Category GHC.Base.Functor Control.Applicative.Applicative System.Random.Random
02:48:29 <mreh> What does that imply?
02:48:33 <FunctorSalad_> computers have this tendency that all the contrived corner cases that can happen will
02:48:55 <Silvah> Yeah, theory is usually more interestion - well, in theory, I'm a billionaire and so are you all. ;)
02:49:19 <mreh> that is an incoherent theory
02:49:31 <FunctorSalad_> say, you use "THIS_IS_A_UNIQUE_VAR_9876543" instead of a truly fresh supply... nobody will ever use that identifier right? until it's some metaprogramming tool operating on your code ;)
02:49:51 <kmc> Silvah, the discussion here is pretty theory-biased, but there is a lot of very practical work going into low level guts of GHC, etc.
02:49:56 <kmc> i actually wish we talked about that more
02:50:03 <Cale> mreh: It means that haddock didn't know where to link those modules to in the HTML it generated
02:50:05 <dolio> @yhjulwwiefzojcbxybbruweejw
02:50:05 <lambdabot> Just 'J'
02:50:08 <copumpkin> kmc: #ghc
02:50:09 <copumpkin> :)
02:50:10 <mreh> Cale: phew
02:50:10 <kmc> dolio, :)
02:50:15 <kmc> #ghc is usually dead :/
02:50:18 <copumpkin> @yhjulwwiefzojcbxybbruweejw
02:50:18 <lambdabot> "\"#$%&'()*+,\""
02:50:32 <kmc> and seems more like a ghc devs channel than a general discussion channel
02:50:43 <mreh> Cale: I finished the ArrowRandom arrow and a RandomArrow instances atlast
02:50:48 <apolon> uhm, how do i get the latest darcs copy of gtk2hs again?
02:51:01 <mreh> s/instances/instance
02:51:02 <Cale> mreh: :)
02:51:14 <copumpkin> kmc: at the risk of founding another #haskell-in-depth, we could start a #haskell-guts channel ;)
02:51:29 <mreh> seeing as it's an obvious derivative, is it really worth giving ArrowRandom it's own package?
02:51:35 <mreh> we have MonadRandom
02:51:47 <copumpkin> which is in its own package
02:51:56 <mreh> I'm thinking outloud :)
02:52:01 <FunctorSalad_> yet another kleisli arrow? ;)
02:52:21 <copumpkin> class ArrowKleisli
02:52:22 * copumpkin coughs
02:52:27 <mreh> I've had this discussion, the answer is "NO"
02:52:35 <mreh> it's a monad random
02:52:42 <mreh> lol
02:52:57 <mreh> it's an ArrowTransformer
02:53:01 <mreh> so tired
02:53:10 <FunctorSalad_> I'm just grinning because some subversive elements here criticise the arrow abstraction as having no other examples ;)
02:53:13 <copumpkin> @localtime mreh
02:53:14 <lambdabot> Local time for mreh is Mon May 17 10:52:49
02:53:17 <FunctorSalad_> not looking at copumpkin
02:53:18 <FunctorSalad_> ;)
02:53:26 * copumpkin whistles innocently
02:53:41 <copumpkin> it's harblcat!!
02:53:42 <FunctorSalad_> (but you had a point... well, kleisli and cokleisli and the stream transformer)
02:53:46 <Silvah> @localtime copumpkin
02:53:48 <lambdabot> Local time for copumpkin is 2010-05-17 05:53:22 -0400
02:53:54 <harblcat> hi!
02:54:02 * harblcat is confused.
02:54:06 <copumpkin> it's kind of ridiculous how many of us stay up this late
02:54:08 <Silvah> Hi.
02:54:20 <Cale> preflex: seen mmorrow
02:54:20 <preflex>  mmorrow was last seen on #ghc 119 days, 6 hours, 56 minutes and 34 seconds ago, saying: * mmorrow is rtfm'ing
02:54:29 <Cale> preflex: seen mmorrow-
02:54:30 <preflex>  Sorry, I haven't seen mmorrow-
02:54:31 <copumpkin> Cale: any ideas on how to find him?
02:54:35 <Cale> copumpkin: nope
02:54:41 <copumpkin> :(
02:54:44 <Cale> Just checking
02:54:44 <mreh> he had a github
02:54:57 <Cale> Did he use any other nicks?
02:54:58 <copumpkin> he did?
02:55:04 <copumpkin> Cale: not that I ever saw
02:55:05 <mreh> his name was matt IIRC
02:55:12 <copumpkin> yeah
02:55:12 <Cale> Matt Morrow, yeah
02:55:18 <copumpkin> I emailed him but he never replied
02:55:22 <copumpkin> his domain is down
02:56:11 <Silvah> Maybe he died.
02:56:15 <copumpkin> I hope not
02:56:47 <mreh> I leant him 50 bucks
02:56:56 <mreh> s/leant/lent
02:56:58 <mreh> jesus
02:57:00 <kmc> speaking of death
02:57:04 <kmc> Robin Milner is still dead
02:57:05 <Cale> His Ohloh page says "Haskell or die"
02:57:14 <kmc> as i am reminded every time i join
02:57:21 <mreh> lol, that means only one thing
02:57:41 <mreh> 119 since haskell = death
02:57:47 <mreh> 119 days
02:57:58 <copumpkin> :(
02:58:20 <ski> harblcat : what are you confused about ?
02:58:43 <mreh> anyone else thinking of monty python right now?
02:59:11 <Cale> mreh: I was thinking of the parrot sketch last time he came up.
02:59:40 <mreh> http://www.youtube.com/watch?v=B2Je1CEPkUM -- this is what I had in mind
02:59:43 <FunctorSalad_> death sucks
02:59:47 <Cale> I wonder what happened to him. Apparently he live(s/d) in Austin, Texas. Maybe someone here is from around there?
03:00:25 <harblcat> just about copumpkin's "it's harblcat!"
03:00:29 <mreh> maybe he's just working hard
03:00:41 <mreh> or got a life outside of haskell
03:00:42 <copumpkin> Cale: last I spoke to him he was in chicago or somewhere around there
03:00:56 <copumpkin> where'd you get the texas from?
03:01:09 <FunctorSalad_> harblcat: maybe he was just continuing my irony that questioning arrows is not allowed
03:01:10 <FunctorSalad_> ;)
03:01:15 <Silvah> Texas? Pretty far away from here.
03:01:27 <Cale> copumpkin: Well, Ohloh displayed a map of it. I don't actually know what that means.
03:01:42 <FunctorSalad_> (deflecting the attention to you jokingly)
03:03:40 <copumpkin> I tried sending him another email to another address
03:08:06 <mreh> does he belong to a university?
03:08:34 <Cale> mjm2002 at gmail?
03:09:10 <FunctorSalad_> what's up with him?
03:09:17 <FunctorSalad_> other than what was said here
03:09:45 <mreh> we don't know
03:10:12 <mreh> aw, he was interested in music
03:10:34 <FunctorSalad_> yeah, I mean whether you went looking for him because there was some reason to be worried
03:10:52 <copumpkin> Cale: yeah
03:10:59 <copumpkin> mreh: he's a graduate
03:11:04 <mreh> naw, we're just idly speculating what's happened to him
03:11:30 <copumpkin> FunctorSalad_: he was a regular here, stopped coming abruptly, his bot is gone, his domain is offline
03:12:15 <mreh> is ohloh useful?
03:12:18 <FunctorSalad_> yes I remember all the TH conversations
03:12:36 <Silvah> TH?
03:12:40 <mreh> template haskell
03:13:39 <Silvah> Thank you.
03:14:07 <mreh> meta programming, whatever that is
03:14:38 <FunctorSalad_> "whatever that is"? you're making it sound like it's some meaningless buzzword :o
03:14:56 <Silvah> Because it is.
03:15:03 <FunctorSalad_> it came before 'meta' was popular :p
03:15:24 <FunctorSalad_> code that manipulates code seems like a pretty well-defined idea to me
03:16:03 <FunctorSalad_> if anything it's an example of the correct use of 'meta'
03:16:39 <kmc> a compiler is an example of a meta-program
03:17:02 <FunctorSalad_> yes
03:17:08 <kmc> 'meta' is not perfectly sharply defined
03:17:21 <Silvah> Nothing is, actually.
03:17:29 <mreh> here we go
03:17:30 <FunctorSalad_> I don't see how the fact that compilers are one is somehow against it ;)
03:17:44 <Silvah> Natural languages are so vague... so meaningless.
03:17:49 <FunctorSalad_> TH is just one step higher in the compilation chain
03:17:55 <apolon> what is the name of the package containing the glib library?
03:18:04 <kmc> FunctorSalad_ could be i was just stating a relevant fact ;)
03:18:15 <FunctorSalad_> kmc: that was my first interpretation too
03:18:41 <FunctorSalad_> then it seemed... ah nvm
03:18:51 <kmc> if you go in ##c++ they will tell you that metaprogramming means using a very strange pure functional language to manipulate code in a very strange first-order imperative systems language and if you want anything other than that you're crazy or a troll
03:19:11 <kmc> also damn it, now we're going to argue about C++
03:19:17 <kmc> shouldn't have even said anything
03:19:28 <Silvah> Stop talking about C++.
03:19:35 <FunctorSalad_> apolon: it's part of gtk2hs
03:19:42 <FunctorSalad_> assuming you mean the haskell bindings
03:19:44 <mreh> can I start a room for practical users of haskell?
03:19:45 <apolon> yep
03:19:56 <kmc> mreh, i'd rather you didn't
03:19:59 <copumpkin> we're all practical
03:20:04 <FunctorSalad_> apolon: ./configure --enable-glib or so
03:20:21 <mreh> kmc: why not?
03:20:21 <kmc> it will be tiny and people will make fun of us ;P
03:20:24 <Silvah> copumpkin: orly?
03:20:29 <FunctorSalad_> it is on by default actually, but that way it will complain if it can't find the prerequisites...
03:20:29 <mreh> :)
03:20:34 <apolon> i'm trying to install ghk2hs, but the darcs copy has no configure
03:20:42 <kmc> i'd rather start a new channel for theory
03:20:43 <FunctorSalad_> did autoreconf?
03:20:47 * hackagebot xmobar 0.11.1 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.11.1 (AndreaRossato)
03:20:49 <mreh> kmc: yes, good idea
03:21:05 <kmc> often this channel is talking about CT or logic or such
03:21:09 <FunctorSalad_> apolon: btw it doesn't work with 6.12.2 anyway
03:21:10 <Silvah> Yet another channel for theory?
03:21:12 <kmc> it seems to double as a friendlier version of #math
03:21:14 <apolon> ??
03:21:22 <mreh> #haskell-indepth
03:21:27 <FunctorSalad_> apolon: (that was the state when *I* last checked, mind you)
03:21:49 <apolon> so...  how do you do gui with 6.12.2?
03:21:52 <HiyaShaya> Hey (again), what is the best way of getting the size/length of the amount of arguments when starting main?
03:21:58 <FunctorSalad_> a member (I think) confirmed it here
03:22:04 <kmc> HiyaShaya, do { args <- getArgs; print (length args) }
03:22:08 <FunctorSalad_> (of the project)
03:22:12 <mamalujo> if anyone plays fallout 3, just made a little bit of haskell code to help select armour combinations and compare damage including criticals. I'm very much a begginer in haskell, was playing with emulating OO style in it, i think it just made it more verbose than before this refactoring. anyway, its this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25560#a25560
03:22:26 <HiyaShaya> I want to execute depending on the length of the args
03:22:33 <mamalujo> *with this ..
03:22:39 <apolon> i can't really figure out how to install it -- there is some install-sh script, but it is not making any sense
03:22:53 <HiyaShaya> and I'm getting an error doing args <- getArgs and then lenargs <- (length args)
03:23:02 <HiyaShaya> compile error*
03:23:17 <kmc> HiyaShaya, because (length args) is not an IO action
03:23:22 <kmc> you use <- to run an IO action and get the result
03:23:22 <FunctorSalad_> apolon: as I said it's probably impossible; but back when it worked, it was just "autoreconf && ./configure && make && make install"
03:23:28 <Silvah> length is pure function, not an action.
03:23:31 <FunctorSalad_> modulo preferences
03:23:37 <kmc> HiyaShaya, if you're just giving a name to an expression, use "let"
03:23:44 <kmc> do { args <- getArgs; let lenargs = lengthargs; ... }
03:23:50 <kmc> do { args <- getArgs; let lenargs = length args; ... }
03:23:53 <Silvah> let lenargs = length args perhaps?
03:24:04 <HiyaShaya> oh okay
03:24:09 <FunctorSalad_> length is the monoid homomorphism from [A] to Integer extended from the function that is 1 on the generators :p
03:24:16 <kmc> ;P
03:24:18 <FunctorSalad_> oops
03:24:19 <HiyaShaya> let me tinker for a few moments here
03:24:21 <FunctorSalad_> I read "pure fiction"
03:24:24 <FunctorSalad_> sorry
03:24:30 <copumpkin> Silvah: yeah, we are
03:24:36 <kmc> FunctorSalad_, get your dirty worthless theory out of here, we're *practical* programmers
03:24:38 <kmc> ;)
03:24:51 <kmc> copumpkin said so
03:24:53 <Silvah> ;D
03:24:59 <copumpkin> I'm very practical
03:25:09 <mamalujo> um, saw some errors in copypasting, corrected at least what I saw.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25561#a25561
03:25:16 <HiyaShaya> I'd assume head args would also require a let?
03:25:17 <FunctorSalad_> I just had to produce theoretical proof that length is not just some abstract fiction
03:25:18 <FunctorSalad_> ;))
03:25:20 <kmc> and we all know that knowing math is a direct impediment to writing working code
03:25:26 <kmc> HiyaShaya, you should probably not use head.  in general.  it's a code smell
03:25:34 <kmc> HiyaShaya, try pattern-matching on the list
03:25:47 <apolon> FS: the latest darcs copy of gtk2hs looks different and the autoconf files were moved to *.stale
03:25:51 <HiyaShaya> well the program will only have one argument
03:25:52 <kmc> args <- getArgs; case args of { [] -> error "no args"; (a:_) -> .... use a here ... }
03:25:57 <Silvah> head is bad?
03:26:03 <kmc> Silvah, yeah. it's a partial function
03:26:12 <mreh> > head []
03:26:13 <lambdabot>   *Exception: Prelude.head: empty list
03:26:15 <kmc> meaning it will throw an exception
03:26:32 <kmc> Haskell's "real" exceptions are not too bad but not really first-class in non-monadic code
03:26:33 <mreh> division is also bad
03:26:37 <mreh> never use division
03:26:44 <kmc> it's better if functions that would be partial return a Maybe result or so
03:26:53 <kmc> then you're forced to consider the "no result" case
03:26:59 <rj248842> I'm new to Haskell.  Is anyone here familiar with Leksah?
03:27:02 <FunctorSalad_> uh so did the issue become now that length is too strict to check for zero args optimallly...?
03:27:23 <FunctorSalad_> (unless you use Natural, I know :p)
03:27:29 <kmc> HiyaShaya, if you're fine with a somewhat useless error msg on missing arg
03:27:33 <mamalujo> one can just make a 'safe' function to wrap in Maybe's such partial functions
03:27:34 <kmc> do { (a:_) <- getArgs; ... }
03:27:41 <Axman6> ivanm: you there?
03:27:50 <mreh> can I use darcs to revert all the stupid things I just wrote?
03:27:52 <ivanm> Axman6: am now
03:27:55 <ivanm> (for a bit)
03:27:55 <kmc> mamalujo, it's called "spoon" and is pretty hackish
03:27:58 <Axman6> rj248842: i'm familliar with it being very incomplete
03:28:12 <kmc> rj248842, most Haskellers don't use a special Haskell IDE, in my experience
03:28:17 <kmc> we use whatever editor we're otherwise comfortable with
03:28:18 <Silvah> Though usable.
03:28:22 <rj248842> What do you recommend?
03:28:25 <ivanm> emacs and [g]vi[m] are the usual suspects
03:28:27 <kmc> both emacs and vim have Haskell indentation and highlighting
03:28:28 <Axman6> ivanm: Sarah and I just finished booking our travel and accommodation
03:28:30 <rj248842> I've also got TextMate.
03:28:38 <ivanm> rj248842: there's a Haksell bundle for that IIRC
03:28:39 <Axman6> textmate is good
03:28:45 <ivanm> Axman6: cool; where are you staying?
03:28:48 <Axman6> i use it for all my haskell work
03:28:48 <ivanm> and how are you travelling?
03:28:49 <Silvah> Geany for teh win!
03:28:52 <rj248842> Yes, I've got the bundle.
03:29:07 <FunctorSalad_> I've defected to vim for the time being, btw :p
03:29:26 <Axman6> ivanm: bus up on wednesday, and back on sunday night (at 8PM, so we'll need to wrap it all up by 6), and we're staying at a hotel quite near UNSW
03:29:28 <rj248842> My problem is that I'm new to programming, and I'm programming on Mac platform (OS X), and I'd like a simple way to edit, then compile.
03:29:33 <Cale> rj248842: As long as your text editor has an option to convert all tabs into spaces, it's fine :)
03:29:41 <Cale> (bonus points for syntax colouring :)
03:29:51 <Silvah> So notepad will suffice?
03:30:10 <mreh> I use gedit, which is notepad in ubuntu
03:30:25 <rj248842> Axman, if I just want to get a "Hello, world" program going, I've followed the steps in Leksah's user's manual, but I'm confused.
03:30:26 <Cale> Silvah: If it can do that now.
03:30:41 <FunctorSalad_> maybe don't exaggerate the point that "we don't need an IDE"... two things that are definitely useful even for Real Programmers are autocompletion and looking up the definition and/or docs of thing at point
03:30:48 <kmc> i'm not saying we don't need it
03:30:52 <Silvah> Are there any editor with *semantic* highlighting?
03:30:59 <mreh> I agree
03:31:05 <kmc> Silvah, coqide highlights correct parts of your code in green ;)
03:31:05 <Twey> I'm saying we don't need it
03:31:10 <Axman6> rj248842: just use textmate. create a new file, with a .hs extension in TM, and write main<tab>, and boom, hello world ;)
03:31:16 <FunctorSalad_> kmc: Cale hinted in that direction
03:31:17 <Cale> Realtime typechecking would be nice :)
03:31:19 <Twey> You can code productively without these features
03:31:26 <FunctorSalad_> Cale: scion kinda does that
03:31:35 <FunctorSalad_> it tells you the type of local vars
03:31:38 <Twey> They're *nice*, but we don't need them to render the language usable, like for some other languages
03:31:47 <FunctorSalad_> (couldn't get it to work lately :()
03:32:03 <kmc> Twey, like which?
03:32:10 <Cale> kmc: Java
03:32:13 <rj248842> Ok, I'll try textmate, but I was hoping to get Leksah working.  Seems like it organizes things in a more useful way.
03:32:16 <kmc> for refactoring
03:32:17 <kmc> ?
03:32:20 <Cale> (if you can ever call it usable)
03:32:21 <Twey> I was trying to avoid saying it, but yeah, Java.  :
03:32:38 <kmc> when you decide your FactoryManagerDispatcher is more of a FactoryDispatcherManager?
03:32:47 <FunctorSalad_> FDM<tab>
03:32:47 <Cale> There's so much syntactic noise in Java, that you need tools to write it for you
03:32:55 <FunctorSalad_> partial-completion-mode to the rescue
03:32:57 <Twey> kmc: Or the classic example of getters/setters on a big object.
03:33:01 <Axman6> rj248842: it;s also very beta, textmate is far from beta
03:33:03 <kmc> sigh
03:33:06 <kmc> i forgot how much Java sucks
03:33:44 <quicksilver> textmate is a poor reinvention of emacs you have to pay for. With a nice UI.
03:33:44 <krainboltgreene_> How is Textmate, anyways?
03:34:12 <FunctorSalad_> a "reinvention of emacs, period" would be nice actually ;)
03:34:20 <FunctorSalad_> assuming that includes lexical scope etc
03:34:26 <apolon> then we should all work on yi!
03:34:35 <Axman6> krainboltgreene: fantastic, worth every cent
03:35:13 <FunctorSalad_> and a type system...
03:35:15 * Axman6 -> away
03:35:42 <Raynes> You crazy kids and your static type systems.
03:35:47 <krainboltgreene> Axman6: Now I just need it to be crossplatform :(
03:35:55 <FunctorSalad_> the break-even point where the extra complexity from the type system meets the waste of time that debugging runtime errors is... is sooo low
03:35:58 * copumpkin loves him some static types
03:36:04 <krainboltgreene> Only OSX computer I own is an iPad.
03:36:41 <mamalujo> hypePad?
03:36:47 <kmc> that's not OS X
03:36:47 <FunctorSalad_> ("low" as in reached quickly)
03:36:55 <kmc> also not a computer
03:37:06 <Silvah> Who cares?
03:37:07 <copumpkin> kmc: it's basically OSX
03:37:13 <kmc> Silvah, not you, evidently
03:37:16 <copumpkin> and it's a computer if you let it b
03:37:18 <copumpkin> be
03:37:32 <Silvah> It's Apple thingy, so it's by all means evil.
03:37:34 <Twey> FunctorSalad_: Everybody's always porting emacs to other languages, but nobody picks them up because they're not backwards-compatible :-\
03:37:35 <kmc> copumpkin, you mean by circumventing the manufacturer's elaborate security mechanisms?
03:37:39 <copumpkin> kmc: yep
03:37:42 <kmc> ok
03:37:45 <kmc> then my toaster is a computer
03:37:53 <krainboltgreene> Not only is iPad OS derived from OS X, but it also fits the definition of computer.
03:37:54 <kmc> because i can circumvent its lack of programmability by putting a computer inside
03:37:59 <krainboltgreene> Not sure what kmc is smoking.
03:38:03 <copumpkin> kmc: it's a lot easier than that :P
03:38:03 <kmc> you can't program the iPad
03:38:06 <FunctorSalad_> Twey: is that the reason?
03:38:06 <kmc> without the approval of a third party
03:38:17 <kmc> therefore, it's not a computer in a crucial socially-relevant sense
03:38:19 <Twey> kmc: Well, not legally.
03:38:23 <krainboltgreene> I can write JS and PHP just fine.
03:38:51 <Twey> I'm waiting for the Adam for my tabletting needs it looks like it's going to outdo the iPad on just about every front, and also not be a restricted piece of crap.
03:39:07 <krainboltgreene> Heh, if I really wanted to I could write a web based SSH client and then use nano, vim, etc, from there to write whatever I want.
03:39:08 <FunctorSalad_> mmm tabletten
03:39:25 <copumpkin> krainboltgreene: there are already ssh clients for it
03:39:26 <Twey> krainboltgreene: But crucially it wouldn't run on the iPad
03:39:29 <kmc> krainboltgreene, cool.  so your keyboard is a computer?
03:39:37 <kmc> a VT100 is a computer?
03:39:48 <kmc> a rotary phone with a programmer at the other end is a computer?
03:39:52 <kmc> anyway, #haskell-blah
03:39:52 <Twey> If you write web-apps, they run on the server
03:39:59 <Twey> Aye
03:40:08 <Silvah> What means "computer", exactly?
03:40:16 <Raynes> My mattress is a computer.
03:41:10 <apolon> number 4 is a computer
03:41:30 <Silvah> 0 is a computer too?
03:41:31 <FunctorSalad_> wikipedia in't
03:41:32 <apolon> this is a computer
03:41:34 <Raynes> One time, I rebooted a kitten.
03:41:38 <rj248842> Ok, I've created a "hello.hs" file using TextMate.  How do I compile and run it from within TextMate?
03:42:13 <alar> Raynes: booted a kitten? How cruel!
03:42:20 <Silvah> So a kitten must be a computer then.
03:42:31 <FunctorSalad_> Twey: btw, on that previous topic, fair enough, you disagreed with the "need" in "need an IDE"
03:42:42 <FunctorSalad_> (weren't my words, but doesn't matter)
03:43:01 <rj248842> Oh, Command-R, looks like.
03:43:25 <apolon> y (\c. c is a computer)   is a computer
03:44:11 <Silvah> Are we also computers?
03:44:25 <HiyaShaya> What is the simplest way of converting a Float to an Int?
03:44:38 <FunctorSalad_> HiyaShaya: ceil/floor/round
03:44:39 <Silvah> :t round
03:44:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:44:56 <apolon> this sentence is false and you are not a computer
03:45:05 <FunctorSalad_> @ty (ceil,floor)
03:45:06 <lambdabot> Not in scope: `ceil'
03:45:06 <ski> @type ceiling
03:45:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:45:13 <FunctorSalad_> @ty (ceiling,floor)
03:45:14 <lambdabot> forall a b a1 b1. (RealFrac a, Integral b, RealFrac a1, Integral b1) => (a -> b, a1 -> b1)
03:45:32 <ski> @type [ceiling,floor,round]
03:45:33 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
03:46:43 <ski> @type truncate  -- i'm always forgetting this one
03:46:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:47:08 <FunctorSalad_> me too evidently
03:47:29 <Silvah> So there are 4 ways to convert Float to Int. Which one is the simplest?
03:47:32 <alar> :t toInteger
03:47:33 <lambdabot> forall a. (Integral a) => a -> Integer
03:47:42 <alar> hm
03:47:42 <apolon> actually, yi is kinda cool
03:48:06 <FunctorSalad_> the problem is underspecified
03:48:17 <FunctorSalad_> it's no surprise there is no one simplest way
03:48:22 <FunctorSalad_> const 0
03:48:24 <FunctorSalad_> there's another one
03:48:29 <FunctorSalad_> :)
03:49:05 <Silvah> Well, there are indefinitely many ways.
03:49:08 <Twey> FunctorSalad_:  1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says "No." to every query. 
03:49:31 <FunctorSalad_> I see
03:49:37 <koala_man> haha
03:49:47 <Silvah> lol
03:50:31 <FunctorSalad_> but the other 4 functions aren't a whole lot more "correct" than const 0 given just "give me an int from a float"
03:51:00 <mdmkolbe> Hmm, lhs2TeX produces invalid latex when in --tt mode and a \begin{code} is inside a \begin{center} that is inside a \begin{figure}.  Any ideas on why?  Workarounds?  Anyone seen this problem before?
03:51:27 <mdmkolbe> (Well, I guess just getting rid of the \begin{center} technically counts as a work around)
03:51:44 <Silvah> Well, randomRIO is good solution, too.
03:52:32 <ski> @type randomRIO `asTypeOf` round
03:52:33 <lambdabot> forall a. (Random a, RealFrac (a, a), Integral (IO a)) => (a, a) -> IO a
03:53:14 <Silvah> Good luck.
03:53:33 <Silvah> > randomRIO (0, 4)
03:53:34 <lambdabot>   <IO Integer>
03:54:03 <Silvah> > print =<< randomRIO (0, 4)
03:54:04 <lambdabot>   <IO ()>
03:54:23 <Silvah> Ahem.
03:54:26 <Twey> prolog = const "No."
03:54:31 <aristid> :t randomRIO
03:54:32 <lambdabot> forall a. (Random a) => (a, a) -> IO a
03:54:53 <aristid> > print 1
03:54:54 <lambdabot>   <IO ()>
03:54:58 <aristid> haha
03:55:06 <ski> @help run
03:55:06 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
03:55:47 <aristid> ski: somehow i misremembered that there was IO in lambdabot
03:56:08 <copumpkin> you misunderestimated her
03:56:26 <aristid> or misoverestimated
03:56:46 <aristid> depending on the metric
03:57:41 <quicksilver> there is IO in codepad.org, maybe someone should write a codepad bot.
03:58:23 <FunctorSalad_> how are they doing it?
03:58:29 <Twey> We don't need no input/output we don't need no file control
03:58:33 <FunctorSalad_> throwaway box? ;)
03:58:34 <Silvah> > unsafePerformIO $ randomRIO (0, 4)
03:58:35 <lambdabot>   Not in scope: `unsafePerformIO'
03:58:38 <Twey> They run it in a really restricted sandbox
03:58:45 <Silvah> :(
03:58:56 <Twey> I think they have a whitelist of system calls that the resulting code is allowed to call
03:59:04 <quicksilver> FunctorSalad_: it's very very clever, actually.
04:00:25 <aristid> quicksilver: ideone has an API
04:00:25 <Silvah> But I need a (pseudo-)random number badly...
04:00:27 <quicksilver> FunctorSalad_: it's based on http://www.xs4all.nl/~weegen/eelis/geordi/
04:00:32 <aristid> Silvah: use ghci
04:00:43 <Cale> > random (0,4) (mkStdGen 42)
04:00:44 <lambdabot>   Couldn't match expected type `System.Random.StdGen -> t'
04:00:44 <lambdabot>         against in...
04:00:52 <Cale> err
04:01:00 <Silvah> GHCi won't run on mobile phone.
04:01:04 <Cale> > randomR (0,4) (mkStdGen 42)
04:01:04 <lambdabot>   (1,1720602 40692)
04:01:07 <Cale> 1
04:01:13 <Cale> there you go ;)
04:01:16 <aristid> Silvah: codepad and ideone do
04:01:25 <aristid> :t randomR
04:01:26 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
04:02:06 <ski> (hm, the `Show StdGen' instance seems "bad")
04:02:12 <Cale> yeah
04:02:47 <ski> > read "1720602 40692" :: StdGen  -- and apparently, there's also a corresponding `Read' instance
04:02:48 <lambdabot>   1720602 40692
04:03:28 <Cale> It ought to show as a corresponding mkStdGen or something
04:04:20 <Twey> Interesting
04:04:34 <Twey> Is that next number, current seed?
04:04:46 <Silvah> Check.
04:04:55 <Twey> > random $ read "1720602 40692" :: Int
04:04:56 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:04:56 <lambdabot>         against inferred type ...
04:05:30 <Twey> > random $ read "1720602 40692" :: (Int a, StdGen)
04:05:32 <lambdabot>   Kind error: `GHC.Types.Int' is applied to too many type arguments
04:05:35 <Twey> Er, haha
04:05:39 <Twey> > random $ read "1720602 40692" :: (Int, StdGen)
04:05:40 <lambdabot>   (7917472149011110476,1735131843 1872071452)
04:05:48 <Twey> Apparently not
04:06:35 * ski spontaneously comes to think of PCLSRing (re `Show StdGen')
04:07:52 <Silvah> Why StdGen has a Show instance? Converting PRNG to a string sounds... strange, at best.
04:08:36 <Silvah> does have*
04:08:48 <ski> presumably for persistency reasons
04:10:30 * Silvah wonders why his English is really that bad.
04:11:38 <FunctorSalad_> maybe your intuition is that a RNG producing independent results doesn't have a state
04:12:00 <FunctorSalad_> (a true RNG)
04:13:31 <systemfault> Oh! New LLVM/GHC post on LLVM's blog http://blog.llvm.org/2010/05/glasgow-haskell-compiler-and-llvm.html
04:14:55 <Silvah> Well, nope, this operation is simply not natural for me, for some a reason that I don't know...
04:16:16 <Twey> You probably think of them as opaque
04:16:19 <Twey> Which is reasonable
04:17:00 <FunctorSalad_> I was going to say "by definition" there... but actually it's not entirely obvious from the product-definition of independence that it defines statelessness
04:17:06 <FunctorSalad_> interesting...
04:18:08 <Silvah> PRNG is just a box which can give us some numbers or other things, does it really make any sense to convert that box to a string, potentially making its internals visible?
04:18:42 <FunctorSalad_> one situation I can think of is replaying a test run, Silvah
04:18:58 <FunctorSalad_> to reproduce a bug
04:19:52 <Kaidelong> the read instance could be used when saving a program state I suppose
04:20:09 <Kaidelong> does haskell have anything like binary serialization, anyway?
04:20:10 <Silvah> Ah, well, yet another evindence that theory, in which it should be completely opaque, doesn't match the practice.
04:20:14 <Twey> Not sure that's the most appropriate use of Show/Read, though
04:20:16 <FunctorSalad_> Kaidelong: binary
04:20:26 <FunctorSalad_> (the package)
04:20:35 <FunctorSalad_> and several variants
04:20:44 <Twey> Binary.Put/Get are lovely.
04:20:58 <FunctorSalad_> well, maybe lack of pure error handling in Get was not so optimal?
04:21:03 <FunctorSalad_> at least that's how I remember it
04:21:07 <Kaidelong> would be cool to do something like have your program load its state from a file
04:21:13 <Kaidelong> almost smalltalk like
04:21:41 <Kaidelong> I imagine you could do this since the stateful part is seperated out
04:22:00 <Kaidelong> and wrapped in an abstraction
04:22:12 <Baughn> @hoogle bool
04:22:12 <lambdabot> module Data.Bool
04:22:12 <lambdabot> Test.HUnit.Base assertBool :: String -> Bool -> Assertion
04:22:12 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
04:22:33 * Silvah really wonders why his English is so bad.
04:23:40 <FunctorSalad_> (or I suppose there is nothing preventing you from making a safe "Get (Maybe Int)"... but the shipped instances don't have pure errors IIRC)
04:23:57 * Kaidelong assures Silvah that he has to deal with much worse English every day here in the states
04:24:12 <ski> Silvah : since we have `mkStdGen', if `Show StdGen' were written to output (strings representing) calls to `mkStdGen', that would still be opaque (relative to having `mkStdGen')
04:24:12 <FunctorSalad_> Silvah: PRNGs aren't opaque in theory
04:24:27 <Baughn> Silvah: ..or in practice, except the cryptographic ones
04:24:31 <FunctorSalad_> and RNGs are for all purposes ;)
04:24:41 <Baughn> FunctorSalad_: If you want a safe (and faster!) Data.Binary, look at Data.Serialize (Cereal)
04:24:52 <FunctorSalad_> (even if thermal noise should turn out to be deterministic one day)
04:25:05 <Baughn> ..which it won't.
04:25:09 <kmc> @quote stark
04:25:09 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
04:25:29 <Kaidelong> Baughn: how would you prove it isn't?
04:25:32 <FunctorSalad_> Baughn: didn't know it
04:25:48 <Baughn> Now you do. ;)
04:26:04 <Kaidelong> having no explanation for how it is generated is not a proof that it is non-deterministic
04:26:06 <Baughn> FunctorSalad_: By my measurements, it's about twice as fast as Binary. OTOH, it can't handle infinite streams.
04:26:26 <ski> (Silvah : cf. `Show (Array i e)')
04:26:31 <Baughn> Kaidelong: Because thermal movement is greatly affected by quantum decoherence..
04:26:37 <Baughn> Kaidelong: Which is about as well proven as it gets
04:26:57 <Baughn> s/movement/noise/
04:27:27 <FunctorSalad_> we had the hidden variables discussion a few days back already ;)
04:27:51 <Kaidelong> I was just playing devil's advocate
04:28:01 <Baughn> We did, and I'm still certain MWI is it. :P
04:28:25 <Kaidelong> I like to believe that there is true randomness in the universe, but trying to prove it would be like trying to prove the non-existance of god
04:28:50 <Baughn> Kaidelong: Oh, I don't believe in randomness.
04:28:53 <Baughn> Just unpredictability.
04:29:04 * Twey is with Baughn on this one.
04:29:04 <Kaidelong> baughn: true, that's different
04:29:12 <Baughn> Decoherence leaves you with indexical uncertainty, not physical randomness
04:29:15 <FunctorSalad_> Kaidelong: that's my impression too
04:29:39 <FunctorSalad_> the layer below the current lowest one known could always flip it again
04:29:42 <aristid> Baughn: so you think that radioactivity for example is actually deterministic?
04:30:09 <Kaidelong> you can prove that (with what we know about how the world works) you cannot predict certain outcomes better than random chance
04:30:35 <Baughn> aristid: Yes, certainly.
04:31:02 <Baughn> aristid: In the sense that you see all the outcomes, but can't think about it due to decoherence.
04:31:22 <Baughn> FunctorSalad_: That would be fun. :)
04:31:28 <FunctorSalad_> maybe "true randomness" is just a property models can have, not something that the word can or can not be
04:31:31 <FunctorSalad_> (in itself)
04:31:42 <FunctorSalad_> since there is no way to test it even in principle...
04:32:20 <FunctorSalad_> a model, OTOH, can perfectly well be defined to go into a set of successor states
04:32:24 <aristid> Baughn: do you have any reasoning? the underlying unobservable process might as well be random without changing how what we can observe, right?
04:32:37 <FunctorSalad_> and may be useful to model that which is merely unpredictable in practice
04:33:03 <Baughn> aristid: Sure, there are a variety of experiments that show wavefunction reality, from the double-slit experiment on up.
04:33:42 <aristid> Baughn: wavefunction is just a distribution afaik, and true randomness can have a distribution too, so i don't see how that proves this
04:33:49 <Kaidelong> the fact that there is something in the universe akin to discretization of a continuous model is fascinating
04:34:14 <Baughn> aristid: If it was just a probability distribution, the double-slit experiment wouldn't work like it does
04:34:38 <aristid> Kaidelong: i wonder if this property is necessary for "life"
04:34:45 <Kaidelong> aristid: the experiment is so fascinating when you use a single particle
04:34:50 <Kaidelong> it turns into a wave
04:34:54 <Kaidelong> and moves through the slits
04:35:05 <Kaidelong> so long as you don't try to observe it as a particle
04:35:12 <Kaidelong> well, one of the slits
04:35:20 <Kaidelong> which one it goes through appears to be completely random
04:35:22 <Baughn> @hoogle Maybe a -> Bool
04:35:23 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
04:35:23 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
04:35:23 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
04:35:51 <aristid> Baughn: i don't think it cannot be a distribution
04:36:04 <Kaidelong> if you watch the particle moving it behaves more classically
04:36:20 <Baughn> Kaidelong: ..because you're entangling yourself with it, yes.
04:37:17 <aristid> @src isJust
04:37:17 <lambdabot> isJust Nothing = False
04:37:18 <lambdabot> isJust _       = True
04:37:23 <aristid> @src maybe
04:37:24 <lambdabot> maybe n _ Nothing  = n
04:37:24 <lambdabot> maybe _ f (Just x) = f x
04:37:42 <Baughn> aristid: http://lesswrong.com/lw/r5/the_quantum_physics_sequence/ <-- As I don't have time to discuss this right now (but I'll be around tomorrow!), maybe take a look at this if you haven't already?
04:38:51 <aristid> maybe, but i'll play hedgewars first
04:39:07 <Silvah> .oO
04:39:47 <FunctorSalad_> it's funny how randomness can aggregate to apparent determinism (when the randomness cancels out and law of large numbers applies...) and determinism to apparent randomness
04:41:19 <kmc> :)
04:41:36 <kmc> by the latter you mean PRNGs, chaotic systems, etc?
04:42:26 <FunctorSalad_> yes
04:42:34 <FunctorSalad_> I was afraid to mention "chaos" again
04:42:35 <FunctorSalad_> ;)
04:43:09 <kmc> what happened last time?
04:43:43 <ski> chaos ?
04:43:50 <Baughn> FunctorSalad_: What's funny is how List monad-type nondeterminism turns into apparent randomness
04:43:56 <Baughn> I'm still not sure what to think of /that/ one
04:45:35 <FunctorSalad_> kmc: I imagined, or it happened, that ddarius implied that I had used the word carelessly etc
04:45:50 <dolio> kmc: People went on about how chaos isn't really interesting.
04:46:26 <FunctorSalad_> I had pointed out that chaos alone should make social dynamics impossible to simulate rigorously, and apparently he understood me as saying that chaos theory is useful to model social dynamics
04:46:44 <FunctorSalad_> Baughn: the list monad?
04:47:25 <FunctorSalad_> I mean, I know it can be thought of as (uniform) random computations...
04:47:25 <Baughn> > do a <- [1..3]; b <- [10,20,30]; return (a,b) -- FunctorSalad_: Similar in concept to MWI
04:47:26 <lambdabot>   [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
04:47:46 <FunctorSalad_> but not what's "random" about it except this correspondence by definition more or less
04:48:17 <FunctorSalad_> (a list is a distribution except it can only model uniform ones)
04:48:23 <FunctorSalad_> or some more if you allow dupes
04:48:48 <Silvah> dupes...?!?
04:48:52 <Baughn> FunctorSalad_: There's nothing random about MWI either. The randomness comes in when you try to predict which world you'll see.
04:48:53 <FunctorSalad_> duplicates
04:49:04 <Silvah> Ah.
04:49:29 <Silvah> Polish is evil...
04:49:53 <FunctorSalad_> heh I think it's specialized list processing jargon
04:49:59 <FunctorSalad_> ("dupes" for duplicates)
04:50:09 <FunctorSalad_> normally it refers to people who cheat I thought
04:50:22 <p_l> Silvah: why is polish evil? (assuming you refer to language? :D)
04:50:58 <Silvah> There's similar word in Polish, which means... well, you do not want to know.
04:51:01 <p_l> also, "dupe" for duplicate seems to be common english jargon
04:51:13 <p_l> Silvah: you meant "ass"/"arse"? :P
04:51:15 <FunctorSalad_> Baughn: you can even have arbitrary distributions* with the type [(a,Real)]
04:51:26 <FunctorSalad_> *up to computer limits of course
04:51:37 <Silvah> p_l: yes
04:51:43 <FunctorSalad_> you have to use an assoc list due to lack of constrained monads...
04:51:55 <FunctorSalad_> otherwise Map a Real'd be better
04:52:09 * p_l personally wishes someone by chance manages to make an "iChuj" app without knowing the meaning... xD
04:52:25 <Silvah> lol
04:52:56 <madhadron> Anyone have some idea why instances for a -> b and Monad m => m a would be considered overlapping?
04:53:09 <madhadron> Oh, nm
04:53:11 <kmc> because ((->) a) is a monad
04:53:20 <Silvah> Well, chuj is just a language ;)
04:53:23 <madhadron> kmc, Yeah, realized that just as soon as I asked
04:53:42 * madhadron dons his dunce hat.
04:54:14 <FunctorSalad_> (it's not a monad in a, but the resolver isn't that clever ;))
04:54:41 <FunctorSalad_> ('tis contravariant in a)
04:55:27 <madhadron> FunctorSalad, which leaves me still sitting here trying to figure out how to lift the ADDATTRS typeclass from Text.XHtml into monadia
04:55:45 <FunctorSalad_> ? :o
04:55:56 <FunctorSalad_> monadia?
04:56:02 <madhadron> "The land of monads"
04:56:46 <kmc> @quote raised
04:56:46 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
04:56:48 <FunctorSalad_> I only vaguely remember... it abstracts types whose values can have attributes added to them iirc
04:56:49 <Jafet> It will bind you and you will never return
04:57:07 <FunctorSalad_> (but what does that have to do with lifting to monads...)
04:57:08 <madhadron> FunctorSalad, Exactly
04:57:18 <madhadron> Well, I've discovered that it's far more convenient in web applications
04:57:39 <madhadron> to combine things like ServerPart Html than just Html
04:57:42 <madhadron> (obviously in Happstack)
04:58:01 <madhadron> Where my ServerPart actually has my own monad transformer inside to carry around any state I want
04:58:12 <FunctorSalad_> heh, I remember running into similar issues when trying to make both m foo and foo instances of my class (some other class)
04:58:14 <madhadron> The next natural step is to lift all the tags in Text.XHtml
04:58:19 <FunctorSalad_> just use a new name...?
04:58:25 <Silvah> Goodbye.
04:58:29 <FunctorSalad_> bye
04:58:34 <madhadron> Yeah, probably the best way.
04:58:58 <madhadron> As if there weren't enough multiply named operators in the world
04:59:00 <FunctorSalad_> attrsM :: Monad m, ADDATTRS a => m a -> Attr -> m a
04:59:01 <FunctorSalad_> or so
04:59:33 * madhadron contemplates the symbols on his keyboard
04:59:59 <FunctorSalad_> trying to get the typechecker to save you that last step of choosing "monadic or not" seems to be more trouble than it's worth...
05:00:09 <FunctorSalad_> (or the typeclass resolver actually)
05:00:30 <FunctorSalad_> because of these overlaps
05:00:44 <madhadron> Functor, Yup.  Probably so.
05:00:56 <madhadron> Very well.  I dub thee <!, oh my operator.
05:01:59 <Jafet> @remember madhadron I dub thee <!, oh my operator.
05:02:00 <lambdabot> Good to know.
05:03:33 <Jafet> > let a  b = (a, b) in typeOf ()
05:03:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
05:03:34 <lambdabot>    `Data.Typeable.Typeable t...
05:04:16 <FunctorSalad_> forall a b. a -> b -> (a,b)
05:04:23 <FunctorSalad_> what else?
05:04:27 <aristid> :t typeOf id
05:04:28 <lambdabot>     Ambiguous type variable `a' in the constraint:
05:04:28 <lambdabot>       `Typeable a' arising from a use of `typeOf' at <interactive>:1:0-8
05:04:28 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
05:04:44 <FunctorSalad_> @ty curry id
05:04:45 <lambdabot> forall a b. a -> b -> (a, b)
05:04:51 <FunctorSalad_> ;)
05:06:10 <aristid> @ty uncurry id
05:06:11 <lambdabot> forall b c. (b -> c, b) -> c
05:06:23 <aristid> > uncurry id ((+1), 2)
05:06:24 <lambdabot>   3
05:06:54 <aristid> i just love making id be ($)
05:07:11 <Jafet> :t flip id
05:07:12 <lambdabot> forall a b. a -> (a -> b) -> b
05:08:04 <kmc> > typeOf (id :: Char -> Char)
05:08:05 <lambdabot>   Char -> Char
05:08:22 <FunctorSalad_> how'd it do that :o
05:08:27 <FunctorSalad_> ;)
05:08:27 <kmc> which?
05:08:30 <kmc> ;P
05:08:31 <aristid> :t flip ($)
05:08:33 <lambdabot> forall a b. a -> (a -> b) -> b
05:08:34 <FunctorSalad_> deduce the type ;)
05:08:43 <kmc> stupidly
05:08:50 <FunctorSalad_> yes?
05:08:57 <aristid> with lotsof instances
05:08:58 <FunctorSalad_> what did you expect as a correct answer
05:09:44 <FunctorSalad_> oh I see, different levels :o
05:10:11 <FunctorSalad_> the return value is a typerep, not the usual operation of @ty...
05:10:58 <FunctorSalad_> and by "stupidly" you mean by calling the Typeable instances instead of "seeing it", ok
05:11:23 <zygoloid> > typeOf id
05:11:24 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:11:24 <lambdabot>    `Data.Typeable.Typeable a...
05:11:25 <zygoloid> @type id
05:11:26 <lambdabot> forall a. a -> a
05:11:32 <zygoloid> good stuff
05:12:43 <ski> > typeOf (typeOf `asTypeOf` id)
05:12:44 <lambdabot>   TypeRep -> TypeRep
05:13:38 <zygoloid> > fix typeOf
05:13:39 <lambdabot>   TypeRep
05:14:24 <kmc> :t fix typeOf
05:14:25 <lambdabot> TypeRep
05:14:27 <triyo> How do I run hpc? I wish to produce a report for my haskell program?
05:14:42 <ski> > fix (typeOf . (typeOf `asTypeIn`) . runCont . return)
05:14:43 <lambdabot>   TypeRep -> TypeRep
05:15:07 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/hpc.html
05:15:28 <Cale> There's an example of how to do it there :)
05:15:40 <triyo> Cale: thanks, thats perfect
05:15:48 <kmc> ski, jesus
05:16:14 * ski . o O ( where ? )
05:16:23 <kmc> ski jesus
05:16:34 * Baughn is indeed enjoying MaybeT. How did I ever get by without it?
05:16:39 <kmc> skijump jesus
05:16:52 <Baughn> ..just typical haskell. The learning curve /never stops/.
05:17:26 <zygoloid> does anyone know of any existing projects to implement a debugger for ghc-compiled haskell binaries?
05:17:27 <Kaidelong> my dad complains about that, says that there are too many ways to do things and it will intimidate people who'll otherwise adopt
05:17:34 <zygoloid> (i want to make sure i'm not duplicating effort...)
05:17:41 <Kaidelong> his life's dream is to make the perfect programming language last I knew
05:17:42 * Baughn notes that this tends to make his programs look like archeological digs. "And in this layer, you see his monad-transformer period"...
05:17:58 <quicksilver> zygoloid: simon marlow has some gdb macros, I think
05:18:00 <Baughn> @quote success
05:18:01 <lambdabot> dougalstanton says: Haskell: It may be avoiding success, but it's certainly quite popular.
05:18:05 <quicksilver> zygoloid: that's the closest thing I'm aware of.
05:18:14 <Kaidelong> I guess that's part of the design behind python though
05:18:19 <kmc> zygoloid, ghci has debugger features.  not quite what you asked though
05:18:19 <Cale> Baughn: heh, yeah, looking at old code is often humbling :)
05:18:29 <zygoloid> quicksilver: yeah, i've seen them on the GHC commentary page. but i'm going for something a bit more ambitious :)
05:18:33 <Kaidelong> "people will be less intimidated if there is only one way to do things"
05:18:41 <Kaidelong> I do not like that philosophy, personally
05:18:42 <Baughn> Kaidelong: I'd rather have it be hard to pick up than have the curve top out.. sooner
05:18:53 <kmc> i don't think it's about intimidation in Python
05:18:55 <Baughn> I assume it /does/ top out eventually. I can't tell from down here.
05:18:58 <kmc> it's about readable code
05:19:08 <kmc> Baughn, people keep adding stuff
05:19:15 <kmc> possibly at a rate such that you or i will never reach the top
05:19:16 <zygoloid> kmc: ghci's debugging capabilities are... pretty pathetic, i find :(
05:19:17 <Baughn> kmc: Ah, but at a lower rate than I can learn
05:19:23 <zygoloid> (even for interpreted code)
05:19:28 <kmc> zygoloid, yeah
05:19:34 <Kaidelong> zygoloid: but how much debugging do you find yourself doing?
05:19:44 <Kaidelong> compared to other languages
05:19:48 <kmc> i find myself doing a lot of debugging still
05:19:50 <zygoloid> Kaidelong: well, without a good debugger, that number is by necessity 0 :)
05:19:58 <kmc> but i don't think a gdb-like debugger would be useful
05:20:01 <zygoloid> (or at least debugging-with-a-debugger)
05:20:03 <kmc> but it would help in certain specific cases
05:20:04 <Baughn> It'd be nice if functional dependency type mismatches pointed me at the correct line, and not just the function. :/
05:20:15 * Kaidelong has personally found that he tends to write code that works without debugging, since switching to functional programming
05:20:27 <ski> (hm, what happened to Buddha ?)
05:20:28 <Kaidelong> although I admit that in the cases where I don't get it right
05:20:36 <Kaidelong> the lack of tool support can be frustrating
05:20:38 <kmc> Kaidelong, i attribute that more to good static types than to FP.  they both matter though
05:20:45 <zygoloid> Kaidelong: does "works" here include "no time leaks", "no space leaks", etc?
05:21:09 <Kaidelong> zygoloid: pretty much, I've always had a strong interest in performance and try to learn how to do it well early
05:21:14 <zygoloid> ultimately i want to be able to pause my program and poke around in its heap to see /why/ i have a space leak
05:21:15 * Cale considers upgrading to Ubuntu 10.04, and ponders the inevitable strife and struggle with PulseAudio. Do I really want to do this?...
05:21:28 <quicksilver> zygoloid: sure, they were just the closing thing to remotely useful.
05:21:29 <Kaidelong> SICP is the cause, it bought up tail recursion and I looked up how to optomize my algorithms as much as possible
05:21:30 <Baughn> Cale: PulseAudio can be nice. If you don't use ubuntu. ^^;
05:21:33 <Kaidelong> and grew passionate about it
05:21:38 <Baughn> ..and have no special needs whatsoever.
05:21:50 <Baughn> At least, it's better for the programmer than ALSA
05:21:56 <quicksilver> zygoloid: space leak debugging would be particularly useful.
05:22:03 <zygoloid> quicksilver: well, that's good to know. i'm a little surprised this doesn't already exist to be honest.
05:22:17 <kmc> tail recursion is pretty different under lazy eval
05:22:17 <Twey> PulseAudio: a rotting, pus-filled band-aid for the suppurating wound that is ALSA.
05:22:26 <kmc> Twey, thanks for that
05:22:30 <Twey> You're welcome
05:22:35 <kmc> is ALSA really that bad?
05:22:38 <Baughn> Yes.
05:22:38 <Twey> Yes
05:22:41 <Baughn> No. It's worse.
05:22:42 <Cale> Baughn: Last time, it put my soundcard's couple dozen volume controls behind a single master volume control knob, and pinned the headphone volume at 0.
05:22:55 <Baughn> Cale: I remember now. It pins mine at 100.
05:23:04 <Twey> Impressive
05:23:13 * Kaidelong used JACK... on top of ALSA
05:23:20 <Baughn> I have annoyingly low-impedance headphones to begin with..
05:23:21 <Kaidelong> that was years ago though
05:23:40 <zygoloid> Twey: funny, ALSA has worked fine for me for years. PulseAudio has only ever broken working sound setups for me :(
05:23:41 <Baughn> kmc: There are no good sound systems for linux.
05:23:45 <Cale> and Ubuntu had wisely compiled a whole bunch of stuff with options to explicitly disable plain ALSA support
05:23:47 <Kaidelong> I'm not entirely sure ALSA is better than what it replaced
05:23:49 <Baughn> kmc: OSS4 comes close, but it's lacking in hardware support.
05:24:03 <Kaidelong> although I remember the old system as being pretty terrible too
05:24:04 <Baughn> ..at least it has a decent API.
05:24:05 <Kaidelong> OSS, was it?
05:24:14 <Twey> OSS3 wasn't that good
05:24:17 <Baughn> OSS4 is practically a different beast entirely from OSS3
05:24:18 <Twey> OSS4 is much nicer
05:24:20 <Twey> Yeah
05:24:26 <Twey> But yeah, needs more support
05:24:30 <Baughn> ..still proprietary, too
05:24:33 <Twey> If it works with your hardware, go for it  it's awesome
05:24:36 <Twey> No, it's open now
05:24:39 <Twey> They opened it again.
05:24:45 <Baughn> But seriously, they should have just forked OSS instead of being childish and making ALSA
05:24:49 <Kaidelong> ALSA is overcomplicated but I remember that at the time I found the latency on it nicer than ASIO4WINs
05:24:58 <Twey> Yeah, probably
05:25:04 <Baughn> Twey: It doesn't support power-saving for me. Given that I'm on a laptop.. yeah.
05:25:06 <Kaidelong> just didn't configure anything about ALSA myself
05:25:09 <Cale> I'm going to try this, and if this Ubuntu upgrade is as disappointing as the last one, I'm switching back to Debian.
05:25:19 <FauxFaux> \o/
05:25:23 <Kaidelong> and turned on OSS emulation in the kernel
05:25:34 <Kaidelong> since without it an app broke, flash I think
05:25:38 <Twey> Baughn: Well, you can shut it down before suspending and start it up again when you get back
05:25:47 <Twey> Hardly optimal, but it's usable
05:25:48 <stroan> Cale: you upgrading to 10.04?
05:25:52 <Cale> Yeah
05:25:59 * zygoloid dislikes how pulseaudio steals the alsa output, so it breaks your sound system even if you try to circumvent it
05:25:59 <stroan> I had a very bad experience with that
05:26:11 <Cale> Lovely, what happened?
05:26:27 <Baughn> zygoloid: The problem isn't pulseaudio, it's alsa's lack of an in-kernel mixer.
05:26:29 <stroan> wireless stopped working completely, then filesystem troubles
05:26:31 * soupdragon installed 10.4 but it wont boot :(
05:26:35 <stroan> mation was stable for a year
05:26:41 <stroan> machine*
05:26:48 <stroan> and then I upgrade and poof
05:27:08 <stroan> fresh install however works fine
05:27:25 <Cale> Oh good, my system apparently can't calculate how to upgrade anyway.
05:27:32 <Cale> It gave up.
05:27:43 <Cale> and by the sounds of it, that's a good thing ;)
05:27:53 <zygoloid> Baughn: if pulseaudio worked, there'd be no problem...
05:28:18 <zygoloid> at least networkmanager is better behaved these days :)
05:28:22 <verdelyi> in Fedora 13 they did an impressive job integrating pulseaudio to both kde and gnome
05:28:32 <p_l> zygoloid: you mean it actually works?
05:28:35 * zygoloid wonders which essential system component the linux folks will break next year
05:29:03 <zygoloid> p_l: yeah, i've not had problems with it for quite a while.
05:29:07 <p_l> well, X.Org guys got a shot of sanity into their bloodstream and got rid of HAL
05:29:22 <Twey> Have they?!
05:29:22 <p_l> now, if only someone killed off policykit...
05:29:28 <Twey> Yay
05:29:41 <p_l> Twey: X.Org 1.8 doesn't use HAL for hotplugged input devices, at least on linux
05:29:45 <Cale> After years of hearing about problems with wireless networking, I'm a little leery of how that's going to go. I'm probably going to get some wireless network stuff soon to avoid running another ethernet cable.
05:29:48 <Twey> \o/
05:30:01 <p_l> (it's free to use it on other systems, on linux it grabs info from udev, as it should be)
05:30:07 <Cale> (but have been completely sheltered from wireless networking up to this point ;)
05:30:16 <stroan> wireless should work fine
05:30:22 <Twey> Cale: It's not that scary
05:30:24 <Twey> Any more
05:30:29 <stroan> yeah, used be. but not any more
05:30:32 <Cale> Oh, that's good :)
05:30:49 <p_l> Cale: the funny thing, the most user-friendly interface to wifi configuration I know is editing wpa_supplicant.conf by hand. The example files in some distros (or maybe it was included in its sources?) are very easy to follow
05:30:53 <Twey> Ubuntu was out-of-the-box for me on my laptop when I installed it the other day  just click the taskbar icon and choose a network
05:30:56 <aristid> Cale: even when wireless works, it's unreliable, so you might find it better to actually run the ethernet cable.
05:31:04 <kmc> there is actually a huge market now for devices with wifi which ship with linux from the factory
05:31:20 <kmc> i'm not sure if that's the cause of improved support, though
05:31:29 <dino-> This week planned to set up the lovely Mrs dino-'s new system with Ubuntu 10.4. Reading this discussion here, not looking forward to it.
05:31:29 <soupdragon> yeah I want one
05:31:49 <stroan> dino-: fresh install is fine
05:31:51 <Twey> I'm upgrading my mother to Fedora 13, if it ever comes out.
05:31:52 <p_l> wifi works fine for quite a long time, as long as you have stable driver. It was NM that actually broke stuff
05:31:53 <stroan> no problems at all
05:32:16 <dino-> stroan: There's something very wrong about being unable to unbreak a *nix system though. :(
05:32:20 <madhadron> Actually, my wireless came up flawlessly on Ubuntu 10.4
05:32:27 <pimeys> I upgraded my mother to ubuntu 10.03
05:32:30 <madhadron> Though that's on a MacBook Pro, so it's a limited spectrum
05:32:32 <pimeys> some bugs
05:32:39 <aristid> dino-: 10.04 works flawlessly for me.
05:32:41 <pimeys> I hope it works fine :P
05:32:43 <Jafet> I wish I could upgrade my mother
05:33:09 <soupdragon> limited spectrum?
05:33:12 <soupdragon> what does that meanh
05:33:59 <dino-> But this is their thing now, poor upgrades? bleh
05:34:14 <ivanm> preflex: seen bos
05:34:14 <preflex>  bos was last seen on #haskell 10 days, 8 hours, 6 minutes and 43 seconds ago, saying: And LLVM.
05:34:21 <stroan> ubuntu is always terrible just after release
05:34:26 <stroan> they always release FAR too early
05:34:42 <stroan> unstable and under tested
05:34:43 <stroan> every time
05:34:48 <ivanm> s/ just after release//
05:34:49 <ivanm> ftfy ;-)
05:34:53 <stroan> :D
05:35:14 <Cale> The last few upgrades in Ubuntu have, at least for me, done absolutely nothing to improve the system in any way which affects me, while managing to break a bunch of stuff in the process, forcing me to go around fixing it.
05:35:26 <Cale> (But I haven't yet tried 10.04)
05:35:26 <stroan> they got rid of the brown. ;)
05:35:45 <Twey> Preferred the brown to the new default them, to be honest
05:35:47 <baaba> running dist-upgrade hasn't generally been a very good idea on ubuntu
05:35:50 <dino-> Cale: We've seen upgrades go badly too, like you say, last few.
05:35:51 <Twey> It's very '95
05:35:54 <verdelyi> stroan: and shuffled the window buttons yeah
05:35:55 <pimeys> my x40 just didn't work when I upgraded
05:36:01 <Twey> theme**
05:36:13 <pimeys> problem with i8xx display driver
05:36:14 <baaba> which is why i mount my home dir on a separate partition and just wipe the system when i feel like i want to upgrade
05:36:23 <Twey> Yeah
05:36:23 <dino-> I went from 7 years of Debian to Arch last year. That's been nice actually.
05:36:40 <Twey> dino-: *nod* I've been running Arch for a long time now
05:36:58 <Twey> One thing I do find, though, is that I don't always get around to setting up all the fancy new stuff that comes out
05:37:09 <Saizan> one of the latest kernels broke my audio on Arch :\
05:37:10 <Cale> It's not just that it breaks stuff, actually I can put up with a bit of that. But when the new system isn't really noticeably any better than the last one...
05:37:12 <stroan> the one thing about 10.4 that is very nice is that it's very fast to boot
05:37:13 <Twey> So maybe I'd be more up to date with the tech if I used Fedora or something
05:37:26 <stroan> it may however be the only thing you'll notice outside of the new theme
05:37:33 <papermachine> I switched back to Ubuntu after finals, it's been ok
05:37:58 <pimeys> my mother needs her daily fix of farmville...
05:38:08 <pimeys> so her distro should work :)
05:38:25 <Cale> If the power never went out, my machine would never be off.
05:38:57 <Cale> (but this city has horribly unreliable power)
05:39:47 <Cale> I've begun to wonder if they actually schedule monthly short blackouts without telling anyone.
05:39:51 <stroan> the only reason I use windows these days is games, and with steam coming to linux I may be able to kick the habbit completely
05:39:52 <Twey> Haha.
05:40:00 <Twey> Steam is coming to Linux?!
05:40:08 <stroan> yeah, announced the other day
05:40:23 <Cale> I've played steam games under linux without steam.
05:40:31 <stroan> steam and source engine coming to linux
05:40:34 <Jafet> Steam is already on Mac OS. You can sign up to Steam on Mac OS and play about... two games.
05:40:46 <byorgey> Saizan: looking for me?
05:41:01 <Jafet> I guess that's still a better track record than MacPorts.
05:41:11 <Cale> I don't really understand what the purpose of Steam is. Is it just an expensive version of bittorrent? ;)
05:41:19 <Twey> Ooooo.
05:41:27 <Saizan> byorgey: yup, iirc you are working on lifting data constructors to the type level in GHC?
05:41:28 <stroan> He went there... ;)
05:41:30 <Twey> Cale: No
05:41:37 <Twey> It's DRM
05:41:38 <byorgey> Saizan: I will be this summer, yes
05:41:46 <nlogax> they sell cracked games, with DRM ;)
05:41:49 <dino-> Cale: I see it as much grimmer than .. what Twey said, all about control and DRM
05:41:59 <Twey> It's not distributed
05:42:01 <Saizan> byorgey: would that mean that we get a fancier kind system?
05:42:02 <stroan> dino-: it also provides utility. the overlay is great
05:42:17 <byorgey> Saizan: indeed.
05:42:19 <Cale> Twey: Yeah, so even less impressive than that.
05:42:29 <dino-> I could make the same arguments to defent the App Store. Not interested. Sorry for the O/T
05:42:34 <dino-> s/defent/defend/
05:42:36 <Twey> Its sole purpose is to provide a central place from which to manage your Valve games, which includes heavy encryption wherever possible and Valve checking you're not doing anything naughty.
05:42:51 <byorgey> Saizan: lifting data to types requires at the very least that you can also lift types to kinds =)
05:43:14 <Saizan> byorgey: nice, that seems to open the doors to induction :)
05:43:23 <byorgey> Saizan: what do you mean?
05:43:30 <Cale> You can play Portal and HL2 right now on Linux under Wine just fine. I don't know about Fallout 3, my video hardware is not good enough.
05:43:32 <Jafet> It also distributes inferior new add-ons for your games and records "achievements" so you can brag to whomever cares
05:43:44 <Jafet> In summary, Steam is facebook for gamers.
05:44:01 <danderson> without all the privacy raping :)
05:44:18 <c_wraith> Steam at least gets one thing right:  Games are cheaper on steam than in boxed versions.
05:44:19 <danderson> since in this case, the whole point is that gamers *want* the entire world to see their achievements. No surprises.
05:44:54 <Cale> I made a facebook account the other day just to prevent someone else from registering an account in my name, and I was actually pretty creeped out by how much they knew about me somehow.
05:45:02 <Jafet> That's because Steam versions of games are not normal saleable goods at all.
05:45:17 <Saizan> byorgey: i was thinking that it'd be quite useful to be able to prove some type equalities if you start using type families for complex stuff, but that often requires case analysis on the type variables
05:45:38 <c_wraith> and really...  I don't understand people who buy games wanting to resell them.  If the game isn't worth keeping forever, why would you want it?  there are far more good games out there than anyone can play..  Why would anyone waste money on the ones that have no replay value?
05:45:50 <Saizan> byorgey: so that's possible only if i know which cases i can expect :)
05:46:02 <byorgey> Saizan: ah, indeed.
05:46:11 <Jafet> c_wraith, you can, in many regions, promptly return a boxed game to the store
05:46:29 <danderson> Jafet++.
05:46:35 <c_wraith> jafet: once again, I don't understand returning games.  If I buy a game, it's because I want it forever.
05:46:36 <byorgey> Saizan: yes, I think this will give you that
05:46:38 <Jafet> I'm not sure on the details though, since I rarely pay for games
05:46:42 <c_wraith> I don't waste my time on games I don't want forever.
05:46:57 <Cale> (I then proceeded to set all the settings to maximum privacy and logged out)
05:46:57 <Jafet> (yarrr)
05:46:59 <danderson> whereas, when you buy an oldie game that was bastardized by Steam to support their DRM, and when as a result it locks up, crashes, and generally is unusable
05:47:05 <danderson> steam's only response is "no refunds."
05:47:33 <danderson> (don't buy the Commandos series via Steam, they're super super broken)
05:48:23 <dino-> Then there's GOG http://www.gog.com
05:48:41 <c_wraith> I've bought two games via steam.  One of them has no replay value, but since I payed $0 for it, that's acceptable.  The other has ongoing replay value, even after hundreds of hours, and cost $10, half the retail price.
05:49:17 <danderson> dino-: you rock, thanks for sharing.
05:49:19 <Saizan> byorgey: great :)
05:49:28 <lyndon> Hi guys. I'm writing a gray-code enumerator and ran into a stack overflow in version 1, but not version 2. Why would that be? (http://codepad.org/DsGxua1Z)
05:50:14 <Axman6> emulator?
05:50:29 <Cale> lyndon: hmm, I'll have a look
05:50:46 <lyndon> Thanks Cale
05:50:48 <Axman6> lyndon: grey codes are very easy to write in haskell
05:51:06 <Cale> um, what is 'greys'?
05:51:07 <lyndon> Axman6: Yep :) I was just a little thrown by the overflow...
05:51:23 <Cale> (It would be nice to have enough code that I can run this)
05:51:40 <lyndon> Cale: I'll post the whole source.
05:52:03 <Cale> er, grays, of course ;)
05:52:25 <Axman6> > let grey n = grey' (n-2) ["00","01","11","10"]; grey' 0 ns = ns; grey' n ns = map ('0':) ns ++ map ('1':) (reverse ns) in grey 3
05:52:26 <lambdabot>   ["000","001","011","010","110","111","101","100"]
05:52:31 <Axman6> uh
05:52:34 <scree> lyndon: in version 1, n' is a fixed variable
05:52:34 <lyndon> Cale: http://codepad.org/Q2Ac8cnG
05:52:51 <scree> lyndon: so you keep calling d' with the same argument
05:53:08 <Cale> Oh, right, yes :)
05:53:16 <lyndon> scree: Ah, yes of course...
05:53:31 <Axman6> > let grey n = grey' (n-2) ["00","01","11","10"]; grey' 0 ns = ns; grey' n ns = map ('0':) ns' ++ map ('1':) (reverse ns') where ns' = grey' (n-1) ns in grey 4
05:53:32 <lambdabot>   ["0000","0001","0011","0010","0110","0111","0101","0100","1100","1101","111...
05:53:42 <Cale> I was thinking "these two programs are not equivalent", but then thought "well, maybe I should see the rest of the program", but didn't realise it was that blunt :)
05:54:29 <Cale> It's always a good idea to try to avoid shadowing variables.
05:55:37 <lyndon> Cale: For some reason I could not see how I was shaddowing it.
05:55:42 <Axman6> lyndon: what's in this GreyTree?
05:56:28 <lyndon> Axman6: data GrayTree = Node [String] GrayTree GrayTree
05:56:43 <Axman6> what do you need the tree for though?
05:57:02 <mreh> how do you manage several releases of software with darcs
05:57:04 <Cale> Axman6: Reflect and prefix
05:57:16 <mreh> is it like the CVS model where you take off a branch?
05:57:23 <ivanm> mreh: well, dcoutts has several Cabal branches...
05:57:49 <ivanm> once he makes a new major version release (or is about to), he branches that out into its own repo
05:57:54 <lyndon> I specify a particular gray-code as a path, 'lrllr' or something, this is a path in the tree where each left branch prefixes the non-mirrored n-1 length code with 0 and the right with 1
05:57:56 <Axman6> hmm, i'm unused to using grey codes for anything other than modulation schemes to reduce bit error rates
05:58:10 <mreh> ivanm: manually making changes to the cabal file?
05:58:17 <Cale> http://en.wikipedia.org/wiki/File:Binary-reflected_Gray_code_construction.svg
05:58:17 <mreh> I'm doing it *in* cabal
05:58:37 <ivanm> mreh: nope; darcs get foo foo-x.y
05:58:47 <ivanm> and then changes the version in the head repo
05:59:03 <lyndon> Axman6: There's probably a much better way to do it, but I was playing around with an idea.
05:59:04 <Axman6> Cale: looks an awful lot like the code i wrote a few minutes ago ;)
05:59:06 <mreh> ivanm: hmm, okay I think I know what you mean
05:59:16 <ivanm> mreh: http://hackage.haskell.org/packages/archive/Cabal/1.8.0.4/Cabal.cabal
05:59:18 <mreh> he checks out a new darcs repo from an existing one
05:59:24 <ivanm> notice the two "source-repository" sections
05:59:30 <lyndon> Cale: Yep, this.
05:59:42 <ivanm> mreh: right; darcs will use hardlinks for shared history so it doesn't take up much extra hdd space
05:59:53 <mreh> clever!
06:00:37 <Cale> Axman6: Yeah, he's just building the tree explicitly, and then selecting the depth n nodes from it
06:00:48 * hackagebot constructive-algebra 0.1.1 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.1 (AndersMortberg)
06:01:07 * Cale wonders if he still can has binary trees in L.hs
06:01:09 <Cale> :t Tip
06:01:09 <lambdabot> Not in scope: data constructor `Tip'
06:01:12 <Cale> :t Branch
06:01:13 <lambdabot> Not in scope: data constructor `Branch'
06:01:16 <Cale> nope...
06:02:17 <Axman6> :t Node
06:02:18 <Cale> @undefine
06:02:19 <lambdabot> forall a. a -> Forest a -> Tree a
06:02:25 <Cale> :t Tip
06:02:26 <lambdabot> forall a. Bin a
06:02:28 <Cale> :t Branch
06:02:29 <lambdabot> forall a. a -> Bin a -> Bin a -> Bin a
06:02:32 <Cale> there we are :)
06:04:05 <Cale> @let foldBin t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
06:04:06 <lambdabot>  Defined.
06:04:33 <Cale> @let mapBin f = foldBin Tip (Branch . f)
06:04:33 <lambdabot>  Defined.
06:05:36 <Cale> @let gray = Branch "" (mapBin ('0':) gray) (mapBin (('1':) . reverse) gray)
06:05:36 <lambdabot>  Defined.
06:05:39 <Cale> gray
06:05:41 <Cale> > gray
06:05:41 <lambdabot>   No instance for (GHC.Show.Show (L.Bin [GHC.Types.Char]))
06:05:42 <lambdabot>    arising from a ...
06:05:44 <Cale> ah
06:06:26 <Cale> > gray
06:06:27 <lambdabot>   Branch "" (Branch "0" (Branch "00" (Branch "000" (Branch "0000" (Branch "00...
06:06:32 <lyndon> Cale: :)
06:06:52 <illissius> Cale: one perk of a laptop is comes with a built-in UPS
06:07:02 <illissius> (I used to have the intermittent-power-outages thing too)
06:07:05 <illissius> *is it
06:10:23 <Cale> @let breadth = foldBin [] (\x l r -> [x] : zipWith (++) l r)
06:10:24 <lambdabot>  Defined.
06:10:36 <Cale> > breadth gray
06:10:37 <lambdabot>   [[""],["0","1"],["00","01","10","11"],["000","001","010","011","100","110",...
06:10:46 <Cale> hmm
06:11:26 <Cale> That's clearly wrong
06:11:39 <ski> @let type Hmm = ()
06:11:40 <lambdabot>  Invalid declaration
06:12:51 <Cale> oh, tsk, of course
06:12:53 <Axman6> Cale: looks perfectly correct to me
06:13:16 <Cale> Well, the evaluator is evaluating it correctly
06:13:21 <Axman6> though, to me, grey codes feel weird when you don't define their length initially
06:13:26 <Cale> I just did something stupid when I defined the tree
06:13:37 <Cale> "01","10" <-- fail
06:13:46 <Axman6> oops, heh, indeed
06:14:02 <Cale> I reversed the individual strings, when I meant to flip the tree
06:14:09 <Axman6> MAXIMUM HAMMING DISTANCE!
06:14:13 <Cale> So, let's take another shot at it
06:14:44 <Cale> @let flipBin = foldBin Tip (\x l r -> Branch x r l)
06:14:45 <lambdabot>  Defined.
06:14:52 * hackagebot cabal-sort 0.0.2 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.2 (HenningThielemann)
06:15:34 <Cale> @let gray = Branch "" (mapBin ('0':) gray) (mapBin ('1':) . flipBin $ gray)
06:15:35 <lambdabot>  Defined.
06:15:42 <Cale> > breadth gray
06:15:43 <lambdabot>   [[""],["0","1"],["00","01","11","10"],["000","001","011","010","110","111",...
06:16:01 <lyndon> Looks good now
06:16:55 <Axman6> > grey
06:16:56 <lambdabot>   Not in scope: `grey'
06:17:02 <Axman6> o.O
06:17:09 <Cale> It's spelled with an a
06:17:11 <Axman6> quit breaking things Cale!
06:17:14 <Axman6> heh
06:17:17 <Axman6> > gray
06:17:18 <lambdabot>   Branch "" (Branch "0" (Branch "00" (Branch "000" (Branch "0000" (Branch "00...
06:17:33 <Twey> I want to check out MacIrssi, but the site is broken.
06:17:41 <Twey> I thought Canadians used grey?
06:17:53 <Cale> It's not a colour here.
06:17:53 <c_wraith> I'm pretty sure it's someone's name in this case.
06:17:56 <Cale> It's a guy's name.
06:17:59 <Twey> Ah
06:18:02 <Axman6> yeah, he's right, it's a name
06:18:17 <Twey> I figured it was similar to a red/black tree.
06:18:34 <Axman6> Colour all nodes the same colour...
06:18:41 <Twey> Hehe
06:18:48 <Axman6> i actually know nothing about red black trees :(
06:19:17 <Twey> @where red/black trees
06:19:18 <lambdabot> I know nothing about red/black.
06:19:27 <c_wraith> you're not allowed to have adjacent red nodes.  That's all can remember, offhand. :)
06:19:30 <Twey> Hmph.  :
06:19:35 <c_wraith> Oh, leaves must be black
06:19:44 <c_wraith> @go red black trees
06:19:45 <lambdabot> Maybe you meant: google googleit do
06:19:49 <Cale> Frank Gray invented a vacuum tube based apparatus to generate pulses of this form. It apparently had a flow of electrons which was blocked by a grid in the form of the code.
06:19:51 <c_wraith> @google red black trees
06:19:52 <lambdabot> http://en.wikipedia.org/wiki/Red-black_tree
06:19:52 <lambdabot> Title: Red-black tree - Wikipedia, the free encyclopedia
06:20:27 <Axman6> @googleit red black tree
06:20:27 <lambdabot> http://letmegooglethatforyou.com/?q=red+black+tree
06:20:31 <Axman6> heh
06:21:21 <Cale> So, I guess the same apparatus could well have been used to generate any finite repeating stream of pulses by the looks of it, but that's what he built it for.
06:21:45 <HiyaShaya> is there a way to use map function [list]
06:21:52 <HiyaShaya> in such a way that the function has two parameters?
06:22:02 <HiyaShaya> like an implicit value as such?
06:22:25 <c_wraith> yes.  what type are you thinking?
06:22:29 <ski> where should the two parameters come from, in each case ?
06:22:30 <mreh> :t mapM
06:22:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:22:32 <ski> two lists ?
06:22:35 <Cale> HiyaShaya: sorry, I'm not sure I understand what you're asking fully
06:22:49 <Axman6> > map (+2) [1..10]?
06:22:49 <c_wraith> (your question might mean a few different things, so telling us what type you want would help a lot)
06:22:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:22:55 <HiyaShaya> I want to apply a function to the entirity of a list
06:22:58 <Axman6> > map (+2) [1..10]
06:22:59 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
06:23:11 <Cale> HiyaShaya: Do you mean apply the function to one of its parameters, and then use it in map? Sure
06:23:23 <Cale> > map (map (*2)) [[1,2,3],[4,5],[6,7,8]]
06:23:23 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
06:23:27 <HiyaShaya> hmm
06:23:40 <HiyaShaya> give me a moment
06:23:40 <Cale> > map (replicate 2) [1,2,3]
06:23:41 <lambdabot>   [[1,1],[2,2],[3,3]]
06:23:43 <mamalujo> if I use open recursion to allow prototype-like inheritence, how do I define a binary operator over such objects? say one that sums their fields, without closing them with 'fix' first?
06:23:54 <lyndon> map (\(x,y) -> x^y) (zip [1..10] [2..11])
06:23:57 <Cale> HiyaShaya: You can also use lambda
06:24:38 <HiyaShaya> I want to apply a function to every value of a list, but this function itself would need that value from the list and another argument
06:24:41 <ski> mamalujo : how can you sum the fields, if they can have differing types ?
06:24:58 <HiyaShaya> so like map function [list] [second variable]
06:25:03 <Axman6> HiyaShaya: which other argument? where is it supposed to be coming from?
06:25:05 <ski> HiyaShaya : `map (myFunction anotherArgument) myList' ?
06:25:13 <HiyaShaya> it would be another list in itself
06:25:18 <Cale> HiyaShaya: Maybe you're looking for zipWith
06:25:21 <Axman6> HiyaShaya: i think you want zipWith
06:25:21 <lyndon> HiyaShaya: What would the type of this function be?
06:25:33 <Cale> > zipWith (+) [1,2,3] [10,20,30]
06:25:34 <lambdabot>   [11,22,33]
06:25:38 <Axman6> > zipWit (\x y -> x ^ y) [1,2,3] [4,5,6]
06:25:39 <lambdabot>   Not in scope: `zipWit'
06:25:43 <Axman6> > zipWith (\x y -> x ^ y) [1,2,3] [4,5,6]
06:25:44 <lambdabot>   [1,32,729]
06:25:46 <ski> > zipWith (++) ["hello","there"] ["0","123"]
06:25:46 <lambdabot>   ["hello0","there123"]
06:25:47 <HiyaShaya> hmm
06:26:00 <Axman6> @let zipWit = zipWith
06:26:02 <lambdabot>  Defined.
06:26:03 <Berengal> or concatMap
06:26:04 <Axman6> Gansta haskell
06:26:07 <HiyaShaya> in this scenario
06:26:25 <gwern> they see me rollin in my \, they think i'm riding IO
06:26:30 <HiyaShaya> I need to apply a function to a list which uses the entirity of the list
06:26:35 <HiyaShaya> for calculations
06:26:49 <HiyaShaya> so like [1,2,3] would need to know of 2,3
06:27:01 <Cale> okay
06:27:09 <Cale> map (f xs) xs ?
06:27:14 <Cale> Like that?
06:27:44 <HiyaShaya> don't think so no...
06:27:59 <Cale> What are you trying to compute?
06:28:02 <mamalujo> ski: not sure generally; in the concrete case, they are both of same type, Armour. I just wish to stack the effects of multiple components of Armour, but don't like the way I'm doing it now. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25563 line 228
06:28:24 <HiyaShaya> the acceleration of particles
06:28:25 <ski> > let xs = [a,b,c] in map (f xs) xs :: [Expr]
06:28:26 <lambdabot>   [f [a,b,c] a,f [a,b,c] b,f [a,b,c] c]
06:28:28 <HiyaShaya> based on particles around them
06:28:37 <Berengal> zipWith f xs (iterate tail xs)
06:28:46 <Cale> HiyaShaya: okay, so you probably *do* want something like map (f xs) xs
06:28:57 <Axman6> i think Berengal has it
06:29:06 <lyndon> HiyaShaya: Would the type be "(a -> a -> b) -> [a] -> b"
06:29:09 <Cale> HiyaShaya: That passes the whole list as the first parameter to f, and then each of the elements as the second
06:29:11 <ski> (.. "line 228", hm)
06:29:27 <Cale> HiyaShaya: Though you might really want something more like select...
06:29:44 <Cale> Which unfortunately isn't in the libraries. Let me define it for you :)
06:29:59 <c_wraith> oh, blah.  If I generalize this fully, I lose the ability to have a meaningful instance of Eq
06:30:08 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
06:30:09 <lambdabot>  Defined.
06:30:17 <Cale> > select [1,2,3]
06:30:18 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
06:30:34 <Axman6> that should be defined somewhere
06:30:53 <Berengal> select is really useful sometimes...
06:30:53 <Cale> This gives you a list of (element, rest of original list) pairs, it's extremely useful and I have no idea why it's not in Data.List already.
06:30:55 <HiyaShaya> lyndon, it would be something like [a] -> [a] -> [b]
06:30:59 <Axman6> > select "hello"
06:31:00 <lambdabot>   [('h',"ello"),('e',"hllo"),('l',"helo"),('l',"helo"),('o',"hell")]
06:31:12 <HiyaShaya> wow Cale
06:31:13 <HiyaShaya> I think
06:31:14 <HiyaShaya> that's amazing
06:31:14 <c_wraith> :t zipWith -- HiyaShaya
06:31:15 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:32:09 <c_wraith> there's also liftM2/liftA2, if you want cartesian pairs, rather than positional pairs.
06:32:17 <Axman6> > zipWith (,) [1,2,3] (tails [1,2,3])
06:32:18 <lambdabot>   [(1,[1,2,3]),(2,[2,3]),(3,[3])]
06:32:47 <Cale> > [(x,xs) | (x:xs) <- tails [1,2,3]]
06:32:47 <lambdabot>   [(1,[2,3]),(2,[3]),(3,[])]
06:33:00 <Cale> (slightly different)
06:33:09 <Axman6> probably closer to what's needed though
06:33:24 <Berengal> > (head &&& tail) . tails $ [1,2,3]
06:33:25 <lambdabot>   ([1,2,3],[[2,3],[3],[]])
06:33:35 <Cale> Actually, I think not. If you're calculating the forces on particles, the earlier particles in the list still matter to the later ones
06:33:51 <HiyaShaya> yes all particles matter
06:34:01 <HiyaShaya> forutnately it doesn't matter if particle 1 is calculated with particle 1
06:34:05 <Axman6> there are paticles now?
06:34:30 <Axman6> HiyaShaya: in that case map (f xs) xs should work fine
06:34:34 <Cale> Axman6: I asked him what he was computing so that I would know what to use
06:34:52 <HiyaShaya> so if I have a list of [1,2,3] I think a combination of select + map
06:35:11 <Cale> yeah
06:35:22 <HiyaShaya> would get me what i want
06:35:39 <Berengal> > let xs = [1,2,3] in map ((+) xs) xs
06:35:40 <Cale> You *could* just go with map (f xs) xs, but that pairs each particle with itself, which you might not want to do.
06:35:40 <lambdabot>   No instance for (GHC.Num.Num [t])
06:35:40 <lambdabot>    arising from a use of `e_1123' at <int...
06:35:57 <Berengal> > let xs = [1,2,3] in map (map (+) xs) xs
06:35:58 <lambdabot>   Couldn't match expected type `a -> b'
06:35:58 <lambdabot>         against inferred type `[a1 ->...
06:36:18 <Jafet> Really, you want to look at Runge-Kutta method
06:36:56 <ski> > let xs = [1,2,3] in zipWith ($) (map (+) xs) xs
06:36:57 <lambdabot>   [2,4,6]
06:37:13 <HiyaShaya> would select be defined as select :: [a] -> [a]?
06:37:37 <Axman6> > let xs = [1,2,3] in map (mapM (+) xs) xs
06:37:38 <lambdabot>   [[2,3,4],[3,4,5],[4,5,6]]
06:37:42 <Axman6> >_>
06:37:42 <c_wraith> So, to fully generalize my LRU cache, I'd want to add a cost calculation function to it..  This would allow individual elements to have different costs.  The problem I've just run into is that it destroys my Eq instance.  grr.
06:37:59 <c_wraith> HiyaShaya: [a] -> [(a, [a])]
06:38:35 <HiyaShaya> ty
06:38:59 <Jafet> Surely a total Ord instance would imply a sensible Eq instance as well
06:39:09 <Jafet> And that sounds like a priority queue
06:39:24 <c_wraith> Um.  yes, you're not talking about what I am.
06:39:52 <c_wraith> I'm talking about an LRU cache that keeps its "size" fixed, and generalizing the ability to change how "size" is calculated.
06:40:53 <gwern> so require a size typeclass?
06:41:11 <Cale> c_wraith: What is an LRU cache?
06:41:23 <c_wraith> I was looking at adding an element to the data structure that's a function, key -> val -> Integer
06:41:48 <c_wraith> But that breaks the Eq instance
06:42:43 <ville> As far as I can see the type constructor and data constructor can have the same name. Real World Haskell seems to use different names for the two, even if there is just one data constructor. If only single data constructor exists is it common practice to have it the same as the type constructor or like Real World Haskell is doing?
06:43:04 <Jafet> Use whichever makes more sense.
06:43:13 * ski prefers to use different names. ymmv
06:43:20 <Cale> ville: It's common, but generally one avoids it around beginners when trying to explain how things work ;)
06:43:51 <ville> Yes I could see how referring to one or the other from text could be confusing if they are the same
06:44:43 <ville> Jafet: knowing my background in programming, having them the same makes more sense to me.
06:45:46 <c_wraith> Cale: an LRU cache is a (generally fixed-size) cache that acts as an association between a key and a value, that maintains an access ordering on its elements.  When something is inserted into the cache when it's full, the least-recently used element is removed to make room.
06:45:48 <Jafet> #'Maybe
06:46:15 <ski> (ville : .. how does the latter follow from the former ?)
06:46:30 <Cale> c_wraith: okay, that sounds like it could be done easily using a priority search queue
06:46:41 <Jafet> c_wraith, so you want your entries to be weighted now.
06:47:43 <c_wraith> Jafet: yes.  But adding a cost function to the structure breaks the Eq instance necessarily, because you can't tell if two arbitrary functions are the same.
06:48:08 <ville> ski: I've 15 or so years of C++ background, there constructors match the type's name so naming them in such manner seems quite natural.
06:49:03 <ski> ok, i suppose
06:49:35 <Cale> oh, awkward, PSQueue on hackage has no split
06:50:46 <Cale> My fingertree-psqueue package doesn't either, but I'm pretty sure I could add one quickly enough
06:50:55 <Jafet> C++ namespace rules are bizarre, though
06:51:28 <Cale> hmm
06:51:38 <Cale> No wait, maybe this isn't what we really want after all.
06:51:58 <Cale> I'm certain it's doable nicely with a fingertree in some fashion though :)
06:52:33 <Jafet> c_wraith, what does determining the equality of functions have to do with that?
06:52:38 <HiyaShaya> hey cale, how do you pattern match [a, [a]] ?
06:52:40 <Jafet> (Are you doing transparent memoization?)
06:52:44 <HiyaShaya> x:(y:ys)?
06:52:51 <Cale> HiyaShaya: that doesn't typecheck?
06:52:58 <HiyaShaya> was just wondering
06:53:03 <Cale> um...
06:53:21 <Botje> HiyaShaya: you can just pattern match it as [a, [b]]
06:53:31 <ski> @kind [a, [a]]  -- not a valid type
06:53:31 <lambdabot> parse error on input `,'
06:53:32 <Jafet> Heh
06:53:40 <Cale> x:y:ys is the same as x:(y:ys), and it works to pattern match the first two elements of a list, along with the rest
06:53:47 <ski> (possibly you meant `[(a,[a])]' ?)
06:53:48 <Botje> HiyaShaya: but only if a:: [c] and b ::c
06:54:17 <Cale> (x:xs):xss will match a nonempty list of lists, the first of whose elements is nonempty
06:54:20 <HiyaShaya> well the way the function select gives output
06:54:37 <HiyaShaya> x:xs would be a, xs would be [a]
06:54:46 <Cale> HiyaShaya: Oh, you mean (x,xs):zs ?
06:54:47 <HiyaShaya> but I'd want to get the first element of [a] as well
06:55:25 <Cale> The pairs are written with round parens ()
06:55:47 <Cale> (that's how you tell them apart from lists)
06:55:50 <HiyaShaya> so x:(y:ys)
06:55:56 <HiyaShaya> would be right?
06:56:00 <Cale> Uhh...
06:56:11 <HiyaShaya> this is going from your select function btw
06:56:12 <Cale> yes
06:56:14 <Cale> er
06:56:19 <ski> > let f (x:(y:ys)) = (x,y,ys) in f [0,1,2,3]
06:56:20 <lambdabot>   (0,1,[2,3])
06:56:20 <Cale> What do you want to do?
06:56:56 <HiyaShaya> select :: [a] -> [(a, [a])]
06:57:00 <Cale> right
06:57:09 <HiyaShaya> grab a (2) and grab the first element of a (3)
06:57:22 <HiyaShaya> as in pattern match to get those two values
06:57:38 <Cale> f (x,y:ys) = ... use x and y ...
06:57:46 <HiyaShaya> okay,
06:58:05 <Cale> (though you won't want to ignore ys either
06:58:13 <HiyaShaya> correct
06:58:17 <Cale> What you probably really want is *not* to pattern match the second list there
06:58:19 * ski hands Cale more round brackets :)
06:58:24 <Cale> Instead, use map
06:58:38 <Cale> (and then a summation function of some sort :)
06:59:01 * HiyaShaya goes back to tinkering.
06:59:09 <HiyaShaya> thanks again
06:59:20 <Cale> f (x,ys) = vectorSum (map (force x) ys)
06:59:39 <Cale> Where force x y will compute the force due to interaction of x and y
07:00:12 <Cale> Well, let's name it sanely
07:00:24 <Cale> totalForce (x,ys) = vectorSum (map (force x) ys)
07:00:56 <Cale> make sense what that does?
07:01:20 <HiyaShaya> Not exactly, haha
07:01:23 <Cale> So the intention there is that x is some particle, and ys is a list of all the rest of the particles
07:01:59 <HiyaShaya> when you say map (force x) ys
07:02:11 <Cale> and force x y will be the force applied to x because of whatever sort of interaction with y (gravity?)
07:02:36 <Cale> so  force x  is a function which when applied to another particle  y  computes that
07:02:50 <Cale> and so we just apply that function to each of the particles in the list ys
07:02:59 <Cale> getting a list of forces
07:03:04 <Cale> and then we add those up
07:03:15 <HiyaShaya> does this work when force is a function with two parameters?
07:03:20 <Cale> yes
07:03:28 <HiyaShaya> oh dear ... that's what i wanted all along LOL
07:03:31 <Cale> In fact, force *must* be a function with 2 parameters
07:03:39 <Cale> (at least)
07:03:54 <HiyaShaya> so force :: x -> y -> Float
07:04:08 <Cale> Well, if your simulation is 1-dimensional
07:04:10 <HiyaShaya> will allow you to do map (force x) list
07:04:19 <Cale> yeah
07:04:20 <ski> > let f x y = x ++ " " ++ y in map (f "a") ["b","cd"]  -- yes
07:04:21 <lambdabot>   ["a b","a cd"]
07:04:24 <Cale> Note that whenever you write  f x y z  in Haskell, what it really means is  ((f x) y) z
07:04:47 <Cale> Functions which appear to take multiple parameters really only take one parameter, and produce another function
07:04:55 <Cale> (which takes the rest)
07:05:16 <EvanR-work> haskell is sneaky like that!
07:05:27 <Cale> and correspondingly, when you see a type like:
07:05:32 <Cale> A -> B -> C -> D
07:05:35 <Cale> it really means
07:05:40 <Cale> A -> (B -> (C -> D))
07:05:57 <HiyaShaya> okay
07:06:06 <HiyaShaya> I think that may resolve a lot of my computational issues
07:06:10 <HiyaShaya> originally I did this manually
07:06:19 <Cale> > let addFive = (+) 5 in map addFive [10,20,30]
07:06:20 <lambdabot>   [15,25,35]
07:06:23 <HiyaShaya> but I had memory errors in larger input
07:06:41 <HiyaShaya> so I was looking for ways to do this with more efficiency
07:06:54 <Cale> Oh, well... :)
07:07:23 <Cale> Not that this is inefficient at all, but it can be quite tricky to understand efficiency, particularly as a beginner.
07:07:49 <HiyaShaya> I believe the issue came with memory
07:07:53 <ski> (eta-contracting can sometimes improve efficiency)
07:07:59 <Cale> indeed
07:08:21 <HiyaShaya> so relying on haskell's functionality itself would hopefully reduce that memory usage
07:08:23 <Cale> For physical simulations, the usual methods of improving efficiency involve using more intricate datastructures which partition things in space
07:08:34 <Silvah> I knew it'll happen.
07:08:44 <Cale> (and then ignoring things which are too far away to matter)
07:09:01 <HiyaShaya> Don't think ignoring things is apart of the scope for this one ;)
07:09:09 <HiyaShaya> if only !
07:09:14 <Cale> Well...
07:09:28 <Axman6> argh, you're minding me of the assignment i should be writing >_<
07:09:42 <HiyaShaya> bless them all
07:14:11 <edwardk> Jafet: while you can't tell if two functions are the same, you can force two functions to be the same by obtaining them from a typeclass or using reflection to inject one into the type.
07:14:31 <Cale> HiyaShaya: Well, it depends of course, but it can be quite a smart thing to do in some cases. Fields like gravity or electromagnetism which fall off as the square of the distance between your objects can make this a worthwhile and not at all unjustified approximation (so long as you ensure that you're accounting for things with masses or charges large enough to make up for the gap)
07:14:34 <Jafet> Perhaps you should advice c_wraith instead
07:14:52 <Jafet> s/c/s/
07:15:10 <edwardk> Jafet: fair enough =)
07:16:06 <HiyaShaya> you're right Cale, but this time around that won't be necessary :)
07:16:11 * Cale sets out on thinking about how to use fingertrees to make an LRU cache
07:16:36 <HiyaShaya> and would take me much longer to work out what should be ignored then it's worth !
07:16:57 <Cale> HiyaShaya: quite possibly :)
07:17:01 <Axman6> hmm, i'm quite impressed with this huffman coding code i've written. makes pretty pictures
07:17:03 <edwardk> c_wraith: you might look at http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html as a starting point, has split, etc.
07:22:50 <pkrumins> hey, i wrote an article 'on functors' if anyone is interested: http://www.catonmat.net/blog/on-functors
07:23:28 <dolio> Well, it's a priori 10x better than another 'on monads.'
07:23:48 <pkrumins> you didnt even see it.
07:23:54 <pkrumins> you bastard.
07:24:06 <tromp> i'm still waiting for an article on ()
07:24:14 <pkrumins> j/k :)
07:24:24 <Cale> pkrumins: Of course, only in Haskell and ML are the uses of the term at all appropriate ;)
07:24:41 <dolio> ML?
07:25:02 <Cale> (and moreso in Haskell than in ML)
07:25:03 <dolio> I suppose it might be in some roundabout way...
07:25:09 <pkrumins> Cale: moreso in Haskell.
07:26:40 <ski> pkrumins : ".. is just a `Node' of `fmap g l' and `fmap' of `g' applied to left branch `l' and the same applied to right branch `r'." -- huh ?
07:27:18 <Cale> heh, power people had the courtesy of showing up to turn power off
07:27:59 <dolio> I didn't know prolog used the word "functor" as well.
07:28:11 <ski> iirc, it comes from logic
07:28:28 <opqdonut> functor is very overloaded
07:28:41 <pkrumins> ski, serious typo, fixing.
07:28:59 <dolio> Damn those logicians.
07:29:07 <dolio> With their monadic logic that has nothing to do with monads.
07:30:57 <ski> (pkrumins : also, not sure if you care to mention this, but functor/3 in Prolog gives you not only the arity, but also the .. functor :)
07:31:39 <dolio> He does show that.
07:31:41 <pkrumins> ski, fixed that place you pasted. Thanks for noticing.
07:31:42 <dolio> Even if he doesn't say it.
07:32:12 <ski> (yes, hence " not sure if you care to mention this")
07:32:50 <pkrumins> Didn't mention it, I only said "It returns the arity of a structure."
07:33:04 <pkrumins> Will make it "It returns the arity and functor of a structure."
07:33:31 <pkrumins> dolio: so was it 10x better than 'on monads?' :)
07:33:55 <dolio> I didn't even have to look at it to know that it would be. :)
07:34:11 <pkrumins> Oh wait, you were serious?
07:34:22 <pkrumins> I thought it was sarcasm.
07:34:33 <dolio> Yes. It's well known that there are too many "on monads" out there, and most of them are bad.
07:35:08 <Olathe> @hoogle showSigned
07:35:08 <lambdabot> Numeric showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
07:35:28 <Olathe> > showSigned 0 5 ""
07:35:29 <lambdabot>   No instance for (GHC.Real.Real [GHC.Types.Char])
07:35:29 <lambdabot>    arising from a use of `...
07:35:37 <pkrumins> oh!
07:35:56 <pkrumins> excuse me for saying 'you bastard' before.
07:35:58 <ski> > showSigned shows 4 12.5 ""
07:35:59 <lambdabot>   "12.5"
07:36:03 <ski> > showSigned shows (-4) 12.5 ""
07:36:04 <lambdabot>   "12.5"
07:36:13 * ski scratches head ..
07:36:18 <dolio> I didn't think you were serious.
07:36:47 <Olathe> > showSigned shows 0 (-1) ""
07:36:48 <lambdabot>   "-1"
07:36:51 <Olathe> > showSigned shows 0 (1) ""
07:36:51 <lambdabot>   "1"
07:36:54 <Olathe> Bah
07:37:07 <pkrumins> Good. :)
07:37:31 <ski> > showSigned shows 10 (-12.5) ""  -- oh !
07:37:32 <lambdabot>   "(-12.5)"
07:37:48 <dolio> The Int is a precedence.
07:37:49 <ski> the `Int' parameter is the precedence
07:37:53 <int-e> > (showSigned shows 6 (-1) "", showSigned shows 7 (-1) "")
07:37:53 <lambdabot>   ("-1","(-1)")
07:42:22 <Olathe> How do I get f x = if x < 0 then shows x else showChar '+' . shows x ?
07:42:32 <Olathe> Is there a library function for that ?
07:42:40 <facsimile> :t showsPrec
07:42:41 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
07:42:54 <facsimile> dont think so
07:43:00 <Olathe> Ahh, OK :)
07:43:01 <Olathe> Thanks
07:43:42 <mux> conditional function composition
07:43:52 <mux> I've wished for that many times already, I never could find an elegant idiom
07:44:29 <jmcarthur> huh?
07:44:38 <jmcarthur> conditional in what sense?
07:44:41 <facsimile> bool (x < 0) id (showChar '+') . shows x
07:45:02 <mux> > let (.?) b f = if b then f else id in (+2) .? True (+1) $ 3
07:45:03 <lambdabot>   The section `GHC.Num.+ 2' takes one argument,
07:45:03 <lambdabot>  but its type `GHC.Bool.Bool'...
07:45:14 <jmcarthur> ah
07:45:18 <mux> > let (.?) b f = if b then f else id in (+2) True .? (+1) $ 3
07:45:19 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:45:19 <lambdabot>    arising from the literal `2'...
07:45:32 <mux> damn. oh well, need to go back to $real_paid_work anyways.
07:46:55 <chrisdone> needs moar Data.Bool.Higher.(??) :: a -> a -> Bool  -> a
07:49:52 <ski>   cond :: (a -> Bool) -> (a -> b) -> (a -> b) -> (a -> b)  -- ?
07:52:25 <sm`> morning all.. any pandoc + restructured text users about ? I added the writerTableOfContents=True option, now my headings are hyperlinked but there's no table of contents. Adding .. contents:: directive didn't help either
07:55:54 * hackagebot hsdns 1.4.3 - Asynchronous DNS Resolver  http://hackage.haskell.org/package/hsdns-1.4.3 (PeterSimons)
07:57:55 * hackagebot wumpus-core 0.17.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.17.0 (StephenTetley)
08:01:19 <danewbie> hi
08:02:10 <danewbie> does anyone know how to import Data.Array.Parallel.Unlifted in Debian sid (GHC 6.12.1)?
08:02:40 <danewbie> it gives me an error when I try it...
08:02:59 <danewbie> Could not find module `Data.Array.Parallel.Unlifted':
08:03:12 <danewbie> It is a member of the hidden package `dph-prim-seq-0.4.0'.
08:03:15 <danewbie> any idea?
08:04:13 <Silvah> Add a dependency on dph-prim-seq.
08:04:28 <danewbie> how should I would do that?
08:04:39 <siracusa> When I do a `t <- forkIO (... hGetLine ...)' and later `killThread t', the thread doesn't seem to get killed if the hGetLine is still waiting for some input. Is there a way to tell it there won't be any more input?
08:05:58 <Silvah> Add "dph-prim-seq >= <version constraint here>" to Build-Depends section in your *.cabal file.
08:06:07 <Cale> danewbie: You can just expose the package with  ghc-pkg expose dph-prim-seq
08:06:16 <danewbie> aha
08:06:19 <danewbie> ok, thanks
08:06:22 <danewbie> i'll try that
08:06:23 <jystic> has anyone in here done the write yourself a scheme tutorial?
08:06:31 <Cale> danewbie: Or you can use the flag  -package dph-prim-seq
08:06:56 <gio123> Cale: english :(
08:06:59 <Cale> danewbie: Or if you have a full project, you'd add it to your build-depends: line in the .cabal file
08:07:30 <danewbie> i'm just figuring out how repa works...
08:08:39 <coryklein> This is my first time using IRC, can anybody see this?
08:08:47 <FauxFaux> Yes. \o/
08:08:57 <coryklein> Hah.  Thanks.
08:09:57 <HiyaShaya> btw Cale, this is what my "code" ended up looking like
08:10:10 <HiyaShaya> getAccel :: Float -> [Particle] -> Particle -> Accel
08:10:10 <HiyaShaya> getAccel delta_t allParts main = mulPoint (addPoints (map (force main) allParts)) delta_t
08:10:32 <HiyaShaya> map is amazing
08:10:44 <roconnor> HiyaShaya: wait till you see bind
08:10:57 <HiyaShaya> accelerate delta_t xs = zipWith (addVelocity) (map (getAccel delta_t xs) xs) xs
08:11:05 <roconnor> or ap
08:11:07 <HiyaShaya> and zipWith is pretty snazzy too
08:11:32 <roconnor> > ap [(+1),(*2)] [3,4,5]
08:11:32 <lambdabot>   [4,5,6,6,8,10]
08:11:52 <roconnor> > ap [(+101),(*20)] [3,4,5]
08:11:52 <lambdabot>   [104,105,106,60,80,100]
08:12:00 <HiyaShaya> :O
08:12:11 <jmcarthur> @pl getAccel delta_t allParts main = mulPoint (addPoints (map (force main) allParts)) delta_t
08:12:12 <lambdabot> getAccel = flip (flip . ((mulPoint . addPoints) .) . flip (map . force))
08:12:14 <jmcarthur> ew
08:12:21 <jystic> :t ap
08:12:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:12:27 <roconnor> > sequence [(+101),(*20)] 5
08:12:28 <lambdabot>   [106,100]
08:12:32 <HiyaShaya> pl?
08:12:47 <jmcarthur> HiyaShaya: @pl rewrites your function in point free form
08:13:16 <jmcarthur> meaning it expresses the function solely as a composition of functions and doesn't name any arguments
08:13:28 <jystic> @pl f xs = map (+1) xs
08:13:28 <lambdabot> f = map (1 +)
08:13:39 <jmcarthur> @pl getAccel allParts main delta_t = mulPoint (addPoints (map (force main) allParts)) delta_t
08:13:40 <lambdabot> getAccel = ((mulPoint . addPoints) .) . flip (map . force)
08:13:59 <jmcarthur> @pl getAccel main allParts delta_t = mulPoint (addPoints (map (force main) allParts)) delta_t
08:13:59 <lambdabot> getAccel = ((mulPoint . addPoints) .) . map . force
08:14:07 <jmcarthur> there, much better :)
08:14:30 <jmcarthur> getAccel = fmap (mulPoint . addPoints) . map . force
08:14:44 <HiyaShaya> the reason why its in allParts main delta_t
08:14:50 <HiyaShaya> is due to getAccel being called by a map function
08:15:01 <HiyaShaya> which I believe requires the variables in a specific order
08:15:16 <jmcarthur> HiyaShaya: could you paste that line?
08:15:22 <HiyaShaya> accelerate delta_t xs = zipWith (addVelocity) (map (getAccel delta_t xs) xs) xs
08:16:14 <jmcarthur> @pl accelerate delta_t xs = zipWith (addVelocity) (map (getAccel delta_t xs) xs) xs
08:16:14 <lambdabot> accelerate = join . (zipWith addVelocity .) . join . (map .) . getAccel
08:16:16 <HiyaShaya> allParts + delta_t must be before main, I am uassuming
08:16:49 <HiyaShaya> assuming*
08:16:52 <HiyaShaya> hence the shaky ordering.
08:16:54 <jmcarthur> @pl accelerate delta_t xs = zipWith (addVelocity) (map (\m -> getAccel m delta_t xs) xs) xs
08:16:54 <lambdabot> accelerate = join . (zipWith addVelocity .) . join . (map .) . flip . flip getAccel
08:17:07 <jmcarthur> not beautiful or anything, but it works
08:17:25 <jmcarthur> anyway, don't go to these extremes with point free code. i'm just showing a few ways to express the same things is all
08:17:51 <HiyaShaya> I'm sure my marker will stare blankly all day at what I've done :)
08:17:52 <jmcarthur> i mean, these aren't turning out *too* bad, but it takes time to get used to and not everybody can read it easily in this form
08:18:05 <HiyaShaya> hence excellent commenting to the rescue
08:22:23 <HiyaShaya> I thank you for your help though jmcarthur
08:22:35 <HiyaShaya> I try not to make cryptic code
08:23:02 <HiyaShaya> It ended up being this way due to me thinking it would resolve a memory issue (which it ended up not being related to this).. arr well
08:23:10 <jmcarthur> point free can be quite readable much of the time and it's my preferred style, but there is a threshold beyond which it's just stupid
08:24:04 <BMeph> jmcarthur: Three arguments. If you're juggling at least three arguments, then you're doing more juggling than processing. That's my thumb's worth, anyway. :)
08:24:34 <Silvah> Are there any compilers of imperative languages written in Haskell?
08:24:52 <jmcarthur> BMeph: if i'm having trouble juggling arguments then i tend to take that as a sign that i need to decompose the problem space a bit more
08:25:00 <jmcarthur> and it depends on circumstances
08:25:04 <soupdragon> Silvah, http://www.haskell.org/haskellwiki/DDC
08:25:07 <jmcarthur> sometimes three arguments are trivial to "juggle"
08:25:09 <Jonno_FTW> a perl 6 implementation
08:25:18 <jmcarthur> sometimes just two are not
08:27:15 <BMeph> jmcarthur: You don't have to be haing problems with it, but, yeah, if you're juggling that many arguments, your functions should be broken up more. That is, however, just my opinion, and as such, as valuable as the physical exchange it takes to learn it, i.e., absolutely nothing. :)
08:28:06 <jmcarthur> heh
08:29:24 <jmcarthur> i tend to think of functions as taking few arguments and returning a function than as taking many arguments and returning a value. that alone tames the juggling quite a bit
08:29:40 <jmcarthur> in my head, that is
08:29:56 <mreh> hmm, arrows seem to overengineer what I need to do, or I just don't realise their potential, but I need to do a replicateM type thing with an arrow
08:31:54 <jmcarthur> mreh: type?
08:31:54 <BMeph> mreh: Then maybe, you really _don't_ "need" to do it with an arrow... ;)
08:33:25 <Saizan> ?type let sequenceArr [] = arr (const []); sequenceArr (x:xs) = x &&& sequenceArr xs >>> arr (uncurry (:)) in \n -> sequenceArr . replicate n
08:33:26 <lambdabot> forall (a :: * -> * -> *) b a1. (Arrow a) => Int -> a b a1 -> a b [a1]
08:33:34 <Silvah> soupdragon: thanks.
08:33:37 <Saizan> mreh: does that fit? ^^^
08:37:51 <Saizan> (sequenceArr is basically sequenceA specialized to the Hom functor of the category a)
08:40:42 <mreh> Saizan... I think so, lemme se
08:41:55 <kamatsu> hm
08:42:16 <kamatsu> with Text.Pretty.HughesPJ, any way to make it not try and align things?
08:42:57 <mreh> Saizan: the Hom functor?
08:44:05 <Saizan> mreh: it's the CT name for the (a e) functor which you might call reader/environment functor, i.e. the generalization of ((->) e)
08:48:36 <Saizan> IOW, you could use replicateA if you define "instance Applicative (A e) where pure x = arr (const x); f <*> g = f &&& g >>> arr (uncurry ($))" for your particular arrow A
08:49:01 <Saizan> ?type Data.Traversable.replicateA
08:49:02 <lambdabot> Not in scope: `Data.Traversable.replicateA'
08:49:27 <Saizan> ?hoogle .replicateA
08:49:28 <lambdabot> Parse error:
08:49:28 <lambdabot>   --count=20 .replicateA
08:49:28 <lambdabot>              ^
08:49:31 <Saizan> ?hoogle replicateA
08:49:32 <lambdabot> No results found
08:50:19 <Saizan> meh, they forgot it :)
08:56:39 <Olathe> @src fix
08:56:39 <lambdabot> fix f = let x = f x in x
08:56:53 <Olathe> > fix (flip div 2)
08:56:56 <lambdabot>   mueval-core: Time limit exceeded
08:57:10 <BMeph> mreh: It's defined and used in Data.Sequence (as is replicateM).
09:09:09 <papul> hi all. i have just installed xmonad and am pretty new to haskell. so i have copy pasted a config from a site and now when i run xmonad --recompile i get this error  "xmonad.hs:75:72: lexical error in string/character literal at character '\n'"
09:09:13 <papul> http://codepad.org/n86xCljL
09:13:03 <aristid> papul: line 75/76 should not be broken into two lines, i suppose.
09:13:54 <mxc> hi
09:13:58 <mxc> just out of curiosity, what does shape polymorphic actually mean?
09:14:14 <soupdragon> mxc trees and lists are different shapes, for example
09:14:49 <mxc> ok, i kind of get it
09:14:55 <papul> aristid: id made it one line now i get this error xmonad.hs:88:0: parse error (possibly incorrect indentation)
09:15:04 <mxc> not sure how that relates to arrays, and what it means in the REPA lib
09:15:48 <aristid> papul: same thing
09:15:57 <aristid> papul: learn copying texts correctly.
09:16:56 <papul> :|
09:17:16 <papul> f*** xmonad i will stick with awesome :|
09:17:21 <papul> sorry for swearing
09:18:36 <gwern> aristid: papul is an excellent example of why you don't give people the proximate answer
09:18:53 <aristid> gwern: huh?
09:19:04 <gwern> aristid: you solved his proximate problem, not his ultimate problem
09:19:17 <gwern> which is not understanding newlines and source code syntax
09:19:45 <quicksilver> I interpret him as not being interested in learning haskell lexical syntax
09:19:51 <quicksilver> he just wanted to configure xmonad
09:20:02 <gwern> aristid: or to put it another way, you gave him a fish yesterday and he starved to death today
09:20:07 <quicksilver> this is a shortcoming in xmonad - you have to engage at least slightly with haskell lexical rules.
09:20:20 <aristid> quicksilver: if i see it correctly, awesome uses lua
09:20:28 <aristid> and lua also has string literals, i think
09:20:31 <quicksilver> I would say it's evidence that everyone should use emacs.
09:20:37 <gwern> quicksilver: screwed up newlines breaks most configuration formats...
09:20:51 <quicksilver> probably true, but perhaps with better error messages in other cases :)
09:21:05 <quicksilver> anyway the quote gwern wanted was "Make a man a fire, and he'll be warm for a day
09:21:14 <quicksilver> Set a man on fire and he'll be warm for the rest of his life.
09:21:19 <zygoloid> haha
09:21:53 <gwern> (no it wasn't; we want xmonad users)
09:22:55 <aristid> doesn't xmonad have a channel too? :)
09:23:08 <dino-> When you do something in a proof like this: (X + Y) - Y = X  what is that called? Cancellation?
09:23:15 <gwern> aristid: we went through the same thing there
09:23:26 <gwern> aristid: and someone else took your same flawed approach
09:23:28 <soupdragon> dino- subtraction
09:23:48 <dv-> What's the easiest, most straightforward binding to sqlite? HDBC-sqlite? haskelldb-hsql-sqlite,...?
09:24:42 <dino-> Like you might say: X + X = 2 x X  by distributive law
09:24:48 <edlinde> hi was wondering if its possible to embed haskell code into a lisp module?
09:24:52 <edlinde> common lisp
09:24:58 <edlinde> is this even possible?
09:25:38 <zygoloid> dino-: i'd just call it simplification
09:25:51 <aristid> gwern: well, i noticed that he copied the file in a wrong way which led to a lot of garbage newlines, but i did not see his ultimate problem.
09:25:58 <gwern> edlinde: you could probably FFI out to haskell
09:26:40 <dino-> ok, thanks soupdragon, zygoloid
09:27:43 <edlinde> ats ffi?
09:28:02 <edlinde> gwern: sorry whats ffi?
09:28:09 <gwern> foreign function interface
09:28:11 <zygoloid> dino-: if you want to be explicit, you could say: (X + Y) - Y = [defn of -] (X + Y) + -Y = [associativity] X + (Y + -Y) = [additive inverse] X + 0 = [additive identity] X
09:29:28 <edlinde> gwern: ah coz we got this DBMS implemented in common lisp and people write a lot of "foreign functions" for it as plugins in all sorts of languages ranging from python to java to C etc
09:30:01 <dino-> zygoloid: I guess it's a situation where you can get increasingly detailed, but just picking something to annotate lines in a proof that makes sense is adequate.
09:32:07 <Cale> dino-: additive inverse would probably be considered the key property there :)
09:32:48 <soupdragon> additive inverse is a weird way to say 'subtraction' though
09:32:55 <dino-> Cale: ok
09:33:56 <Cale> soupdragon: Yeah, since it's actually a name for negation ;)
09:34:06 <quicksilver> well, left and right cancellation are definitely phrases which are used.
09:34:19 <quicksilver> and with a commutative group that's just cancellation.
09:35:19 <mightybyte> Is there a function that does something similar to "pushDown :: Monad m => Maybe (m a) -> m (Maybe a)" anywhere in the standard libraries?  It seems like this is common enough that it should be there somewhere.
09:36:57 <Cale> mightybyte: That is Data.Traversable.sequence, instantiated for Maybe
09:37:16 <gwern> drat. I thought it might be something based off 'join'
09:37:32 <mightybyte> Cale: Aha!  The standard libs come through again.
09:37:43 <mightybyte> Wouldn't have thought to look in Traversable though.
09:38:00 <gwern> @hoogle sequence
09:38:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:38:00 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:38:00 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:38:06 <gwern> hm.
09:38:14 <gwern> @hoogle n (m a) -> m (n a)
09:38:15 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
09:38:15 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:38:15 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:38:36 <gwern> oh, so that sig would've found something. I was mulling whether that was possible when Cale gave the answer
09:39:59 <mightybyte> I knew the pattern applied to Maybe, but not to any Monad.  I hadn't quite made the connection with Traversable though.
09:40:03 <mightybyte> ...so much to learn.
09:40:36 <gwern> so Prelude's sequence is specialized to the list monad?
09:40:59 <mreh> the fact that list is a monad is coincidental
09:41:00 <Cale> gwern: Yeah
09:41:15 <mreh> eh?
09:41:18 <gwern> :)
09:41:34 <mreh> why hasn't anyone done sequence for arrows yet?
09:41:35 <gwern> mreh: maybe Cale means conceptually, but not on the implementation level
09:41:48 <Cale> It is coincidental in this context, as something needn't be a monad to be Traversable
09:42:17 <mightybyte> ...and not all Monads can be Traversable.
09:43:48 <Cale> Though, there's another concept which is closely related to this, as far as type signatures go, but sequence doesn't happen to satisfy the laws...
09:44:01 <BMeph> mreh: Becauseit's already done for Appplicatives, and there's a trivial means to make an Applicative instance of an Arrow.
09:44:27 <Cale> There's something called a distributive law: given two monads m and n, a distributive law is a natural transformation n (m a) -> m (n a)
09:45:04 <mightybyte> Cale: Ahhh, interesting.
09:45:25 <soupdragon> when does this distributive law exist?
09:45:27 <zygoloid> Cale: so if sequence is a natural transformation then we have a transformer version of the monad for free?
09:45:32 <Cale> satisfying some extra laws :)
09:45:58 <Cale> sequence *is* a natural transformation, as all parametrically polymorphic functions are
09:46:07 <zygoloid> ok, if sequence is a "distributive law"...
09:46:20 <Cale> yes
09:46:25 <mreh> should I read "haskell road..." to understand this all deeply?
09:46:34 <Cale> no, since it won't talk about this
09:46:57 <mreh> what does it talk about the most? types
09:47:40 <quicksilver> as far as I know nothing talks deeply about the connection between arrows, applicatives, traversabes, and natural transformations.
09:47:46 <quicksilver> it's haskell folklore.
09:48:21 <quicksilver> when I noticed that all arrows were applicatives and (sort of) vice versa it was a surprise to me.
09:48:28 <Cale> 1) join . fmap distr . distr = distr . join
09:48:41 <mreh> how do you implement applicative for the arrow (->) a
09:48:55 <Cale> 2) fmap join . distr . fmap distr = distr . join
09:49:17 <zygoloid> mreh: see WrappedArrow in Control.Applicative
09:49:20 <Cale> 3) distr . fmap return = return
09:49:26 <ddarius> quicksilver: Traversables are relatively new.  There's no deep connection to natural transformations for those ideas.  There are several things that talk about the connections between Arrows and Applicatives (and Monads and Comonads).
09:49:30 <Cale> 4) distr . return = fmap return
09:49:59 <ddarius> quicksilver: The paper that introduced the term "Applicative Functor" had examples of Arrows from Applicatives and vice versa.
09:50:01 <zygoloid> Cale: These Diagrams Commute!
09:50:07 <Philonous> quicksilver:  there is "Idioms are oblivious, arrows are meticulous, monads are promiscuous". I found it very enlightening
09:50:22 <Cale> zygoloid: basically, "the obvious diagrams commute"
09:50:54 <Philonous> quicksilver: Though it covers only part of what oyu where talking about
09:51:12 * Baughn wonders whose bright idea it was to make HFuse chdir to /
09:51:46 <Cale> and such a distributive law n (m a) -> m (n a) leads to m . n being a monad (type-level composition)
09:52:19 <jmcarthur> quicksilver: arrow = applicative + category, iirc
09:52:22 <Cale> Because in order to define a monad m . n, you need a join which is effectively  m (n (m (n a))) -> m (n a)
09:52:39 <zygoloid> so (1) and (2) say it doesn't matter how you do that
09:52:46 <Cale> So you need something to swap the middle n and m so that you could then apply join to the m's and the n's
09:52:53 <quicksilver> ddarius: that paper doesn't mention the converse part though - that given a two-argument type A b c, if (A b) is Applicative then A b c is an arrow.
09:52:54 <Botje> MANAH MANAH *sings*
09:53:44 <Cale> That is, join will be defined as  fmap join . join . fmap distr
09:53:48 <jmcarthur> i think the Composing Monads paper covers the distributive law
09:54:01 <jmcarthur> it at least covers a couple related ways to do it
09:54:01 <Cale> and then, return is not a problem, return = return . return :)
09:54:06 <Cale> yeah
09:54:54 <Cale> This approach has actually been surprisingly un-useful for programming so far.
09:55:12 <Cale> Most of the monad transformers don't come from distributive laws
09:55:32 <jmcarthur> i've used it a bit. i think it's main flaw is that there isn't a great library for it
09:55:37 <jmcarthur> *its main flaw
09:55:59 <jmcarthur> even category-extras omits monad composition (it's commented out and incomplete)
09:56:33 <jmcarthur> but i've implemented it myself and found it reasonably useful
09:56:50 <danharaj> Do I have to write a Monad instance for (Either a) or is it already done somewhere?
09:57:03 <jmcarthur> danharaj: it's done somewhere, but not the way i like
09:57:15 <danharaj> jmcarthur: Hrm. It's not in Data.Either
09:57:23 <dolio> Control.Monad.Error
09:57:26 <jmcarthur> Control.Monad.Error
09:57:30 <jmcarthur> that :)
09:57:35 <danharaj> go figure.
09:57:50 <jmcarthur> danharaj: it really sucks though :(
09:57:56 <jmcarthur> you'll find out why when you see it
09:59:21 <danharaj> I think I'll just roll my own instance.
09:59:22 <danharaj> :|
09:59:24 <Cale> jmcarthur: At one point it was in TypeCompose
09:59:29 <Cale> jmcarthur: But it seems to be gone
09:59:31 <jmcarthur> Cale: actually though, i think you're right. the distributive law is the least used for monad composition in my experiences. i tend to use m (n a) -> n (m (n a)) or m (n a) -> m (n (m a)) more often (i think i got those right)
09:59:56 <soupdragon> what instances of distributive law are there?
10:00:00 <soupdragon> I only know the m/[] one
10:00:05 <soupdragon> and m/n doesn't hold in general
10:00:07 <jmcarthur> Cale: yeah, conal realized there is more than one way to do it and commented it out, i think
10:00:55 <jmcarthur> i like the category-extras way of specifying different kinds of composition. too bad it's terribly incomplete
10:01:02 <ddarius> Just stick to free monads and their coproducts.
10:01:02 <Cale> soupdragon: the m/[] one doesn't give you a distributive law, actually
10:01:47 <jmcarthur> ddarius: is that equivalent in power?
10:02:02 <ddarius> jmcarthur: Of course not.
10:02:08 <jmcarthur> then i can't do that ;)
10:02:18 <Cale> (at least, if it does, then ListT has even less excuse to be broken than it does now)
10:02:31 <ddarius> jmcarthur: You probably can for a lot of what you want to do.
10:02:37 <jmcarthur> yeah
10:02:49 <ddarius> We should make an adjunction class.  Adjunctions compose nicely.
10:02:59 <jmcarthur> category-extras has one
10:02:59 <dolio> How does m (n a) -> n (m (n a)) help? That makes more levels, not fewer.
10:03:03 <ddarius> And provide some other nice benefits.
10:03:24 <jmcarthur> dolio: think about applying that with fmap and then applying join to the result
10:03:51 <jmcarthur> dolio: well, i don't feel like reinventing it right now, but that's the gist
10:04:04 <Saizan> jmcarthur: so the monad would be n . m ?
10:04:13 * ddarius should find an Omega implementation.
10:04:21 <jmcarthur> Saizan: i'd have to pull up Composing Monads to verify that
10:04:27 <dolio> n (m (n a)) => n (n (m (n a))) => n (m (n a))?
10:04:34 <danharaj> Any sufficiently advanced Haskell library contains a clunky and incomplete embedding of CPL. :p
10:04:35 <jmcarthur> i do not remember all the details right now
10:05:05 <jmcarthur> dolio: ah, must be the other way then. apply it without fmap then do fmap join and join or something like that
10:06:25 <dolio> Well, those two have the type of return and fmap (fmap return) respectively, so I'm hard pressed to think how they'd help.
10:06:51 <dolio> Perhaps they're supposed to go in the opposite direction?
10:07:15 <jmcarthur> likely
10:07:20 * jmcarthur pulls up the paper
10:07:51 <Cale> http://www.cs.cornell.edu/~kozen/papers/Monad.pdf -- just found this :)
10:09:22 <ddarius> That's probably related to Neil Ghani's work.
10:11:34 <jmcarthur> dolio: okay, that type i gave was backward
10:11:48 <dolio> That makes more sense.
10:12:18 <jmcarthur> dolio: prod :: N (M (N a)) -> M (N a)  and  dorp :: M (N (M a)) -> M (N a)
10:12:28 <soupdragon> dorp
10:13:01 <jmcarthur> dolio: join = join . liftM prod  and  join = liftM join . dorp
10:16:51 <Cale> http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf (the paper which is actually under discussion)
10:18:56 <dolio> Is there a prod or dorp involving State? That seems like a prominent monad left out by distributive laws (unless I'm mistaken).
10:19:36 <Cale> It's somehow so funny to see "4.2 The dorp construction" in the Computer Modern typeface :)
10:20:12 <gwern> that's a very racist thing to find funny
10:20:36 <Cale> huh?
10:21:28 * gwern dunno; but doesn't 'dorp' sound like a racist thing to find funny?
10:23:41 * byorgey was not aware of any connotations, racist or otherwise, of the word 'dorp'
10:24:15 <gwern> exactly what a privileged white male would say
10:24:36 <FunctorSalad_> btw I couldn't get this new cabal central doc index working :(
10:25:03 <FunctorSalad_> it's supposed to go to $datadir/doc/index.html...
10:25:08 <FunctorSalad_> but no trace
10:25:21 <FunctorSalad_> ordinary per-package haddock is active
10:25:29 <byorgey> gwern: sometimes I can't tell whether you are joking.  If you are serious, please enlighten me regarding this word.
10:25:34 <Saizan> FunctorSalad_: it's generated only when you install a package with documentation
10:25:43 <byorgey> but maybe in -blah.
10:25:46 <dolio> I see that State is in a "stuff outside the proposed framework" section, so I guess the answer to my question is "no."
10:25:49 <FunctorSalad_> Saizan: --documentation? that's on
10:26:09 <FunctorSalad_> (but only turned it on in the middle of things.... I'll try reinstalling everything with --doc on from the start)
10:26:12 <jmcarthur> dolio: perhaps interestingly though, state can be constructed as the adjoint of ((->) a) and ((,) a)
10:26:33 <Saizan> FunctorSalad_: you just have to install one package, and the index will be refreshed linking to all the existing docs
10:26:36 <dolio> Yes. That's the obvious way to get it.
10:26:54 <FunctorSalad_> funny idea of obvious :) j/k
10:27:12 <jmcarthur> probably not at all significant regarding using a distributive law to compose state with something else though
10:27:28 <dolio> I've been known to express disappointment when Lawvere theories fail to handle the continuation monad, though.
10:27:28 <FunctorSalad_> Saizan: hmm then it must be something else, but I'll try now with a new ghc6122...
10:27:37 <dolio> Or, continuations.
10:27:54 <FunctorSalad_> eh? his theory of *algebraic* theories? ;)
10:27:55 <dolio> So I can imagine people would be down on something that fails to handle composing State with other things.
10:28:08 <FunctorSalad_> not surprising that it doesn't handle first-class functions?
10:28:18 <FunctorSalad_> or are they much more general than I thought?
10:28:36 <FunctorSalad_> thought it was just mildly more abstract than universal algebra
10:28:46 <dolio> Not surprising, but a definite item in the "con" column when people say "let's use Lawvere theories instead of monads."
10:29:40 <FunctorSalad_> (not of course functions can be encoded in algebraic combinators in the end... but that's probably not what you have in mind)
10:29:43 <FunctorSalad_> *now
10:29:59 <Saizan> maybe there's a general pattern where if your monad is from an adjuction you can compose it with another in a sandwich-like way and get a monad?
10:30:41 <FunctorSalad_> I thought dolio was talking about the ordinary way to get a monad from composing the right and left adjoint
10:30:48 <FunctorSalad_> or other way around ;)
10:31:12 <FunctorSalad_> must have missed something
10:31:31 <Saizan> yeah, state is "((->) a) . ((,) a)" and StateT is "((->) a) . m . ((,) a)"
10:31:45 <Saizan> maybe that generalizes to adjuctions in general.
10:32:01 <FunctorSalad_> I see
10:32:02 <dolio> I'm not sure many of the programming monads arise from convenient adjunctions like that.
10:32:27 <dolio> Cont is (-> r) -| (-> r), but it goes through the opposite category.
10:32:36 <FunctorSalad_> so the hyp is that "R . T . L" is a monad if T is one and R -| L?
10:33:20 <Saizan> yup
10:33:43 <FunctorSalad_> hmm the first step would be making up return and join...
10:33:48 <jmcarthur> Saizan: yeah you are on the track that i was thinking down
10:33:55 <dolio> And unless I'm mistaken, you don't get (a -> m r) -> m r from (-> r) . m . (-> r).
10:34:37 <Saizan> m (a -> r) -> r :)
10:36:06 <Saizan> (in the -| notation the right adjoint is on the left!?)
10:36:21 <dolio> The left adjoint is on the left.
10:37:29 <Saizan> ah, so i guess s/R -| L/L -| R/ above? ((->) a) is the right one afaiu
10:37:52 <dolio> Something like Maybe might work out if you use the obvious Kleisli or Eilenberg-Moore adjunction.
10:38:01 <dolio> You might get m (Maybe a) out of that.
10:38:05 <dolio> Somehow.
10:38:45 <dolio> (,) a -| (->) a
10:39:32 <FunctorSalad_> unit was of type "1 -> RL"
10:39:40 <FunctorSalad_> or was it... :D
10:39:49 <FunctorSalad_> nasty parity
10:39:56 <dolio> Which direction are you writing functor composition? :)
10:40:06 <FunctorSalad_> traditional :p
10:40:45 <aristid> is there a value for the type 1?
10:40:54 <jmcarthur> ()?
10:41:13 <FunctorSalad_> if we take algebraic structures (always a good example), "L" is "make free structure", "R" is forget
10:41:13 <aristid> () :: 1
10:41:15 <aristid> is illegal
10:41:18 <FunctorSalad_> so it must be that direction
10:41:21 <dolio> 1 isn't (), as I recall. I don't know what the value is.
10:41:23 <FunctorSalad_> aristid: 1 is the identity functor here
10:41:27 <jmcarthur> oh
10:41:34 <dolio> @kind 1
10:41:34 <lambdabot> *
10:41:35 <FunctorSalad_> (must be since RL is one ;))
10:41:42 <jmcarthur> i was thinking that was in a different context
10:41:47 <FunctorSalad_> and -> is natural transformation actually
10:42:57 <aristid> jmcarthur: the constructor is GHC.Generics.Unit
10:43:11 <jmcarthur> huh
10:43:20 <dolio> > minBound :: 1
10:43:21 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Generics.Unit)
10:43:21 <lambdabot>    arising from a use ...
10:43:24 <jmcarthur> i didn't realize this was an actually type in GHC
10:43:25 <FunctorSalad_> (unit = insertion of generators (of type A) into RL A;  counit = flatten two layers of term structure :: LR B -> B)
10:43:37 <aristid> jmcarthur: yes, 1 is a type
10:43:44 <jmcarthur> *actual
10:44:15 <FunctorSalad_> hmm, actually it's "flatten the term structure over *any* structure, but ok)
10:44:19 <aristid> 1 has no typeclasses tho, it seems
10:44:27 <danharaj> Why can I make an instance Monad (Either a) but not an instance Monad (Either foo)?
10:44:43 <FunctorSalad_> 1 is from the arcane generic haskell extension iirc
10:44:46 <Saizan> danharaj: where foo is actually a concrete type?
10:44:48 <danharaj> er Foo*
10:45:07 <edwardk> danharaj:  you can, but the Either a instance already overlaps it
10:45:17 <edwardk> danharaj: and the latter requires FlexibleInstances
10:45:27 <danharaj> edwardk: I get a compilation error if I try.
10:45:27 <FunctorSalad_> > () :: 1
10:45:28 <Saizan> danharaj: because when they wrote down haskell98 they didn't know if it was doable/safe to allow instances like Monad (Either Foo)
10:45:28 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
10:45:28 <lambdabot>         against inferred t...
10:45:37 <edwardk> danharaj: because there is  the monad for Either a already in the prelude
10:45:40 <FunctorSalad_> thought it was unit...
10:45:52 <dolio> It's not in the prelude, unfortunately.
10:45:53 <danharaj> edwardk: No there isn't, I can define the first instance but not the second.
10:45:53 <FunctorSalad_> > 1 :: 1
10:45:54 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
10:45:55 <lambdabot>    arising from the literal...
10:46:01 <danharaj> saizan: Is there an extension that allows it?
10:46:03 <FunctorSalad_> > tt :: 1
10:46:04 <lambdabot>   Not in scope: `tt'
10:46:05 <Saizan> danharaj: just turn on FlexibleInstances
10:46:10 <edwardk> dolio: oh yeah, because of the !@*(#*!)@ Error constraint
10:46:15 <aristid> :k (1 :+: 1)
10:46:16 <lambdabot> *
10:46:18 <danharaj> Saizan: Any gotcha's to worry about with that extension?
10:46:24 <Saizan> i'm susprised it doesn't get suggested by GHC
10:46:25 <edwardk> danharaj: haskell 98 only allows instance heads to have one constructor
10:46:31 <Saizan> danharaj: no
10:46:39 <FunctorSalad_> aristid: uh maybe it represents any unit type in generichaskell?
10:46:49 <scree> danharaj: any particular reason you want to do that?
10:46:50 <aristid> FunctorSalad_: huh?
10:47:22 <edwardk> danharaj: instance (constraint...) => Foo (Bar x y z) or instance (constraint...) => Foo a -- where the only style of instances you were permitted.
10:47:42 <dolio> It should be suggested unless you're using a rather old version of GHC.
10:47:46 <danharaj> scree: I can define fail for (Either Foo) and give it more structure.
10:48:17 <edwardk> danharaj: you're generally safe with flexible instances, the only gotcha comes in from overlapping instances, where one module defines instance Foo (Bar Baz) and the other defines instance Foo (Bar a)
10:48:37 <edwardk> (or where you use OverlappingInstances/UndecidableInstances) and cause that to happen within the same file
10:48:38 <dolio> GHC even suggests ImpredicativeTypes when you need it, and proceeds to complain that it's deprecated if you enable it.
10:48:42 <scree> danharaj: does Foo = String by any chance?
10:48:53 <FunctorSalad_> aristid: http://haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html
10:49:03 <danharaj> scree: Foo has a constructor that takes a string, yes.
10:49:24 <edwardk> danharaj: then what keeps you from using Control.Monad.Error?
10:49:44 <danharaj> edwardk: I don't need everything in Control.Monad.Error.
10:49:45 <dolio> :t Unit
10:49:46 <lambdabot> Unit
10:49:46 <edwardk> danharaj: just define instance Error Foo where strMsg = YourConstructorFromString
10:49:51 <dolio> :t Unit :: 1
10:49:52 <lambdabot> Unit
10:49:56 <dolio> Ah, there we go.
10:50:06 <edwardk> danharaj: and then your code will work with any other code that happens to use Control.Monad.Error
10:50:12 <jmcarthur> how is 1 different from ()?
10:50:23 <aristid> FunctorSalad_: that text should maybe start with a rationale so that readers like me know what this is all about
10:50:24 <dolio> It has Unit as a constructor.
10:50:27 <edwardk> otherwise your Either instance and theirs are incompatible. and you can't really control what your libraries use
10:50:28 <danharaj> edwardk: The code is going to be in a module where it won't be exported, it'll never have to work with anything else.
10:50:28 <dolio> :t Inl 5
10:50:29 <lambdabot> forall t b. (Num t) => t :+: b
10:50:36 <edwardk> danharaj: famous last words ;)
10:50:49 <aristid> dolio: i already said that Unit is the constructor for 1 :P
10:50:50 <FunctorSalad_> aristid: to be fair, it's a reference manual ;)
10:50:54 <danharaj> edwardk: This isn't GHC I'm writing here, it's just a pedagogical project.
10:50:55 <scree> danharaj: part of me feels it's wrong to use standard types in this way; another part feels it's wrong to use fail; and a third part doesn't want to moralize
10:51:01 <jmcarthur> well i know the literal difference, but are they not isomorphic?
10:51:05 <FunctorSalad_> better a reference than an unfinished tutorial ;)
10:51:36 <aristid> FunctorSalad_: what is this toBin/fromBin thing?
10:51:46 <FunctorSalad_> aristid: the example
10:51:58 <jmcarthur> looks like a way to express ADTs as combinations of sums and products
10:52:01 <edwardk> danharaj: the other option is to just use your own Either-like type ;)
10:52:03 <FunctorSalad_> aristid: I don't know it well either; IIRC it is for defining functions by induction over the type
10:52:11 <dolio> jmcarthur: Probably. They're types from an old generics proposal.
10:52:14 <FunctorSalad_> as long as said type is sum of products
10:52:19 <jmcarthur> so really the whole thing is equivalent to using (), Either, and (,)
10:52:30 <danharaj> edwardk: I could use newtype I guess, yeah.
10:52:32 <FunctorSalad_> which sounds great in principle but iirc there are some strongish restrictions
10:52:58 <jmcarthur> FunctorSalad_: on control over strictness?
10:53:01 <aristid> FunctorSalad_: oh, Bin is a class that needs no instances?
10:53:11 <FunctorSalad_> jmcarthur: it's more the other way around... you already have that adt and want to save the boilerplate of writing the iso to () Either (,)
10:53:35 <jmcarthur> right. i'm just talking about those unnecessarily new types
10:53:38 <FunctorSalad_> I'd like if that was in the compiler...
10:53:42 <FunctorSalad_> (with less restrictions)
10:53:57 <edwardk> i rather like hinze style generics
10:54:07 <jmcarthur> but i see now that they are used differently from "normal" ADTs
10:54:37 <FunctorSalad_> jmcarthur: aah, you mean their canonical sum-of-products is unnecessary
10:54:47 <FunctorSalad_> since () Either (,) would do
10:55:10 <jmcarthur> yeah, but i could see valid arguments for the way it is
10:55:55 <edwardk> @type (:+)
10:55:56 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
10:56:07 <edwardk> @type (:+:)
10:56:08 <lambdabot> Not in scope: data constructor `:+:'
10:56:18 <FunctorSalad_> edwardk: I'm not saying anything final... maybe many of the restrictions could be eliminated
10:56:20 <dolio> @kind (:+:)
10:56:21 <lambdabot> * -> * -> *
10:56:22 <edwardk> @type (Data.Generics.:+:)
10:56:24 <lambdabot>     Not in scope: data constructor `Data.Generics.:+:'
10:56:24 <FunctorSalad_> (the ones on that manual page)
10:56:28 <edwardk> gah
10:57:12 <dolio> @type \x -> Inl x :*: Inr x
10:57:13 <lambdabot> forall a b a1. a -> (a :+: b) :*: (a1 :+: a)
10:57:40 <jmcarthur> :t toBin
10:57:41 <lambdabot> Not in scope: `toBin'
10:57:49 <jmcarthur> i guess that's just an example
10:58:34 <dolio> Bin was a class back in 1.2 (if I recall correctly from a couple hours ago).
10:58:49 <dolio> When there was a built-in binary sequence type.
10:59:00 <dolio> Actually, Bin may have been the name of the type.
10:59:51 <dolio> There was a class with to/fromBin, though.
11:00:20 <dolio> Similar to Read/Show (which was combined and called Text back then).
11:00:49 <ville> Is there a common sollution to the sittuation where you have several types that have and id for example that live in the same module? Declaring: data T = T { id :: Int } data U = U { id :: Int } ends with multiple declarations of 'id'. Do you make a type class for things that have an id?
11:01:56 <c_wraith> ville: In general, no, unless you want to be able to interchange things.  Sadly, the record system doesn't put those in different namespaces.
11:03:31 <danharaj> C++ style namespaces would be able to fix the issue.
11:04:29 <FunctorSalad_> ville: it's been much discussed
11:04:34 <FunctorSalad_> TDNR or what was it
11:04:39 <FunctorSalad_> type-directed name resolution
11:05:07 <FunctorSalad_> but the Cale faction ;) will never give up the composition dot for it
11:05:13 <FunctorSalad_> (includes me)
11:05:26 <FunctorSalad_> how about ::?
11:05:34 <danharaj> :: would fuck with type annotations wouldn't it?
11:05:44 <FunctorSalad_> oh right
11:06:28 <danharaj> :::
11:06:29 <danharaj> :p
11:06:44 <FunctorSalad_> of course you could let the tokenization deal with it and outlaw a constructor followed by .-as-composition
11:06:58 <FunctorSalad_> that wouldn't be too bad maybe
11:07:09 <danharaj> Seems like a lame rule.
11:07:11 <FunctorSalad_> you leave a space anyway for the compo operator
11:08:00 <ville> couldn't you just have the compiler pick the right type of 'id' in the background that fits the argument?
11:08:01 <danharaj> What about -? As in T-id
11:08:03 <FunctorSalad_> nevermind, this doesn't only need constructors
11:08:25 <danharaj> ville: You would have to mangle names for the linker, no?
11:08:33 <ville> kin to C++'s function overloads.
11:08:36 <ville> danharaj: I guess so then.
11:08:37 <FunctorSalad_> TDNR is like "mybarcable.bark", not "Barcable.bark mybarcable" right?
11:08:55 <FunctorSalad_> so the dot operator would always require a space
11:09:02 <edwardk> ville: you can make a typeclass, or you can define them in separate modules and use TDNR
11:09:24 <danharaj> namespaces in modules would be like the module hack, but in the same file.
11:09:33 <danharaj> slightly better.
11:10:19 <FunctorSalad_> (the tokenization rule about constructors is in effect already, isn't it...)
11:11:23 <edwardk> personally i just define the typeclass
11:11:43 <FunctorSalad_> > (Left.Left) 'a'
11:11:44 <lambdabot>   Not in scope: data constructor `Left.Left'
11:11:48 <edwardk> danharaj: that could change the meaning of some programs
11:12:03 <edwardk> (the - solution you proposed)
11:12:10 <FunctorSalad_> > let (<.>) = (.) (Left<.>Left) 'a'
11:12:11 <lambdabot>   not an expression: `let (<.>) = (.) (Left<.>Left) 'a''
11:12:17 <FunctorSalad_> > let (<.>) = (.) in (Left<.>Left) 'a'
11:12:18 <lambdabot>   Left (Left 'a')
11:12:26 <FunctorSalad_> see? dot is already discriminated against :(
11:12:29 <danharaj> edwardk: Probably.
11:12:42 <ville> danharaj: I am not sure if the mangling would be that bad though if it was just: data T { id :: Int } you would end up with function tId in the background like one would likely to name it right now with out a type class.
11:12:53 <ville> sorry missing =
11:13:32 <edwardk> data T = T Int; foo = 12; (-) = id;bar = T-foo
11:13:52 <FunctorSalad_> edwardk: ^^
11:14:29 <mreh>  so the general principle for stringing lots of arrows together is using applicative and a function that appends a the result of an arrow and returns a function that appends another, and folding them all together with <*>
11:14:41 <ville> or the compiler would synthesize __tId and reserve identifiers with __ for the implementation or some such. Anyway no biggie I hardly understand enough to be discussing this.
11:15:10 <edwardk> mreh for replacing arrow sugar with applicative sugar when possible?
11:15:35 <edwardk> ville: its not terrible to just define a typeclass when you need such ad hoc polymorphism
11:16:09 <mreh> edwardk:
11:16:09 <ville> edwardk: Yes that was what came to my mind, adds boilerplate in one form or another.
11:16:11 <mreh> yes
11:16:13 <edwardk> ville: then you can capture the desired semantics for how your types are allowed to vary (using MPTCs or type families, etc) which guides type inference
11:16:23 <mreh> a more general way using arrows would be nice
11:16:39 <mreh> hang on, i've already been given that
11:17:04 <edwardk> ville: without it, it is very difficult or impossible to find a system that works in all scenarios without type annotations
11:17:29 <mreh> damn, it went off the scrollback
11:17:30 <mreh> @where logs
11:17:30 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
11:18:21 <edwardk> all record system changes seem to run afoul of one of lack of generality, functionality or usability ;)
11:18:26 <mreh> how do I get server time?
11:18:31 <mreh> or log time
11:19:09 <edwardk> mreh just scroll to the end grab the last log and look back a few hundred lines
11:19:35 <edwardk> heya shapr!
11:19:51 <edwardk> shapr: going to hac phi? =)
11:23:44 * jmcarthur looks up hac phi to see what's what
11:25:03 <jmcarthur> oh it's this weekend
11:25:23 <jmcarthur> no announced talks?
11:26:07 <edwardk> jmcarthur: i think sclv wanted me to talk about reverse-mode ad
11:26:21 <edwardk> but we kind of organized it on the fly last time
11:26:32 <jmcarthur> how far are people willing to travel to go to this? if shapr or i went we'd be coming all the way from alabama
11:26:34 <edwardk> i think i gave a shpiel on monoids
11:26:56 <edwardk> jmcarthur: shapr and i came over from boston last time.
11:27:09 <edwardk> there were at least 3 folks from europe off the top of my head
11:27:25 <edwardk> the tupil folks and one lambda-the-ultimate guy
11:27:44 <jmcarthur> heh, europe is much farther than alabama, so there goes my excuse
11:27:48 <edwardk> =)
11:28:06 <jmcarthur> was it worth a trip from europe?
11:28:36 <edwardk> its a few days of hacking on haskell in a room with 20 people and some talks. it was a lot of fun last time
11:32:15 <mreh> for ages I was thinking liftA was liftArrow
11:32:34 <edwardk> jmcarthur: noted i was willing to give a talk on parallel parsing, fingertrees or reverse mode AD.
11:32:45 <edwardk> jmcarthur: so now the talk page isn't empty ;)
11:33:12 <mreh> in killadelphia
11:35:45 <byorgey> jmcarthur: definitely worth a trip from alabama, but then, I'm baised. ;-)
11:36:04 <byorgey> mreh: I'll have you know that no attendees were murdered last year.
11:36:07 <Saizan> edwardk: btw, do you have any better way to define a parser/prettyprinter pair than as two distinct functions? (e.g. what do you do for kata?)
11:37:30 <edwardk> Saizan: hah, for kata they are two distinct functions. for an earlier version of kata i was careful to retain in the AST enough information that you could rederive the exact text that formed it, so that pretty . parse = id held
11:38:30 <edwardk> which i did by layering an annotation at each layer in the syntax tree (by recursing through a cofree comonad) and provided a way to generate an annotation from a raw layer, so you could make local changes ot the syntax tree
11:38:51 <edwardk> that way you could use the parser/pretty printer in a refactoring browser
11:39:20 <edwardk> i put it down because shapr was giving me very blank stares when i explained how to iterate over it ;)
11:40:25 <soupdragon> that sounds really neat
11:40:55 <edwardk> the main feature was you could retain comments, etc across refactorings
11:41:18 <edwardk> and it only reflowed enough code to make your changes
11:43:50 <edwardk> byorgey: yes, but have the suicide statistics been tabulated?
11:44:53 <byorgey> edwardk: hmm, I must admit I haven't gotten around to that
11:46:12 <ccasin> byorgey: perhaps I will give a talk on what arity-genericity is and why I think it would be such a swell addition to replib :)
11:46:59 <byorgey> ccasin: sure, sounds like fun =)
11:47:42 <applicative> oh the philadelphia hack-event is coming up
11:48:54 <jmcarthur> sweet, *only* a 14 hour drive to get there
11:49:11 <edwardk> jmcarthur: how is amtrak?
11:49:17 <jmcarthur> or *only* $840 or so for my wife and i to fly there and stay in a hotel
11:49:27 * jmcarthur checks
11:49:33 <applicative> where are you jmcarthur
11:49:34 <jmcarthur> i tried travelocity
11:49:38 <jmcarthur> huntsville, al
11:49:49 <applicative> i see, a bit far to drive.
11:49:51 <edwardk> a buddy and mine are going by train and camping out in a hotel room for the weekend, for about that
11:51:29 * soupdragon imagines you setting up a tent inside a hotel room
11:52:13 <jmcarthur> amtrack is about a 21 hour trip O_o
11:52:40 * applicative thinks its the campfire that will worry the concierge
11:52:56 <edwardk> applicative: as long as i disable the smoke detector first he'll be none the wiser
11:53:10 <applicative> ok
11:53:38 <edwardk> i get get some askance looks when i start hauling in dry sticks and chopped lumber into my room though
11:54:15 <applicative> they don't believe you when you tell them it's computing equipment?
11:54:53 <edwardk> these are my er... server logs...
11:55:01 <applicative> ha
11:57:28 <applicative> boy, the two projects mentioned on the projects page are a bit tough.   no call for my dubious powers.
11:57:56 <Twey> Hm
11:58:25 <Twey> The Arity-Generic Datatype-Generic Programming paper specifies repeat as a member of the map/zip family o.@
11:58:42 <jmcarthur> :t repeat
11:58:43 <lambdabot> forall a. a -> [a]
11:58:44 <ccasin> it's just 0-ary zip!  come to my hac phi talk and I'll explain :)
11:58:52 <ccasin> :t repeat
11:58:53 <lambdabot> forall a. a -> [a]
11:58:55 <ccasin> :t map
11:58:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:58:57 <ccasin> :t zip
11:58:58 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
11:59:08 <ccasin> oops
11:59:12 <ccasin> :t zipWith
11:59:13 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:59:16 <jmcarthur> pure = repeat; (<*>) = zipWith
11:59:17 <applicative> :t zipWith (,)
11:59:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
11:59:36 <Twey> ccasin: Ah, you're Casinghino?
11:59:41 <ccasin> guilty
11:59:45 <Twey> ccasin: I'd love to, but sadly, wrong continent :-\
11:59:58 <edwardk> ccasin 0-ary zip should just return []
12:00:03 <Twey> Yeah
12:00:28 <edwardk> unary zip should be id ;)
12:00:30 <ccasin> edwardk: well, it's unary zip, if you prefer
12:00:50 <ccasin> in that paper we lied about the indices a little bit, for convenience
12:01:01 <edwardk> [], id, zip, zip3, zip4, zip5, ... =)
12:01:23 <ccasin> why id and not map?
12:01:30 <Twey> I'm on-board with map
12:01:32 <edwardk> zip doesn't take a function
12:01:37 <Twey> Oh
12:01:40 <Twey> Right, yeah
12:01:40 <ccasin> oh, sorry
12:01:41 <edwardk> unary zipWith being map i'd take
12:01:49 <ccasin> OK, yes, my mistake
12:01:53 <Twey> No, mine
12:01:59 <ccasin> :)
12:02:01 <Twey> I said the map/zip family
12:02:02 <copumpkin> no mine
12:02:10 <Twey> I started it :
12:02:34 <danharaj> If I have SomeFoo = forall a. (SomeFoo a), and a type Bar, can I use a patternguard like SomeFoo (a :: Bar) <- getSomeFoo?
12:02:44 <ccasin> edwardk: I agree now.  0-ary zip is [] :)
12:02:46 <edwardk> but repeat :: a -> [a] only holds in hask, which is unsatisfying because it needs mu = nu.
12:02:49 <danharaj> (should be a => in that type signature)
12:03:11 <Saizan> danharaj: no you can't pattern match on the type like that
12:03:27 <Saizan> danharaj: you need some value that represents the type
12:03:28 <edwardk> it should take the shortest of the supplied lists, but it isn't given any ;) so i guess it does need to be infinite, so you could use it as a base case for a zipWith progress...
12:03:33 <edwardk> er progression
12:03:50 <ccasin> edwardk: just so
12:03:55 <danharaj> Saizan: How can I let the compiler know when the value type implies the type?
12:03:58 <ccasin> also that took me like two weeks to understand
12:03:59 <ccasin> so you win
12:04:19 <Twey> edwardk has a head-start
12:04:19 <edwardk> but its just disappointing because the same construction doesn't extend to ml, etc. with strict lists.
12:04:23 <Twey> I'm still scratching mine
12:04:28 <Saizan> danharaj: i'm not sure i understand
12:05:13 <danharaj> Saizan: Me neither :p
12:05:29 <edwardk> ccasin: though this whole thing is just using the ZipList applicative
12:05:53 <Saizan> danharaj: but you could have data TyRepr a where TyBar :: TyRepr Bar; ...; data SomeFoo = forall a. a ::: TyRepr a; and then have "(a ::: TyBar) <- getSomeFoo"
12:05:58 <edwardk> > pure (,) <$> ZipList [1,2,3] <*> ZipList [4,5]
12:05:59 <lambdabot>   No instance for (GHC.Show.Show
12:06:00 <lambdabot>                     (Control.Applicative.Zip...
12:06:14 <edwardk> how annoying
12:06:21 <danharaj> Saizan: and ghc will know that a :: Bar?
12:06:40 <edwardk> > getZipList (pure (,) <$> ZipList [1,2,3] <*> ZipList [4,5])
12:06:41 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (a, b))
12:06:41 <lambdabot>    arising from a use...
12:06:55 <edwardk> oh, the extra pure
12:07:05 <edwardk> > (,) <$> ZipList [1,2,3] <*> ZipList [4,5]
12:07:06 <lambdabot>   No instance for (GHC.Show.Show
12:07:06 <lambdabot>                     (Control.Applicative.Zip...
12:07:19 <applicative> > (,) <$> ZipList [1,2,3] <*> ZipList [4,5]
12:07:19 <lambdabot>   No instance for (GHC.Show.Show
12:07:20 <lambdabot>                     (Control.Applicative.Zip...
12:07:21 <Twey> Oh now I get it
12:07:30 <ccasin> edwardk: I agree it's disappointing that the same thing doesn't work in ML, but it still wouldn't be too hard to implement arity-generic zipWith for arities > 0 in a strict language
12:07:39 <edwardk> > getZipList ((,) <$> ZipList [1,2,3] <*> ZipList [4,5])
12:07:40 <lambdabot>   [(1,4),(2,5)]
12:07:48 <Saizan> danharaj: yup
12:07:55 <ccasin> edwardk: yes, you can just use the applicative instance for the case of Zip, but not for other arity-generic functions with more complicated types
12:08:11 <ccasin> well
12:08:16 <Twey> It's like the zero-arity version is an infinite list of something undefined, and repeat maps const a over it
12:08:17 <edwardk> > getZipList ((,,) <$> ZipList [1,2,3] <*> ZipList [4,5] <*> ZipList "Hello")
12:08:19 <lambdabot>   [(1,4,'H'),(2,5,'e')]
12:08:27 <ccasin> sorry, to back-track, what it doesn't work for is _doubly_ generic functions
12:08:44 <Twey> Yeah
12:08:46 <edwardk> Twey: probably pure () since you need some kind of unit, and you can choose to take () or undefined for that role
12:09:00 <Twey> fmap gives you type-genericity, ZipList gives you arity-genericity
12:09:13 <Twey> edwardk: *nod*
12:10:04 <edwardk> ccasin: i'm not sure i grok the concept of 'doubly generic'
12:10:32 <ccasin> edwardk: a doubly-generic function is just one that's both type-generic and arity-generic
12:10:44 <ccasin> zipWith is a good example - we can implement zip at any arity for any datatype
12:10:49 <applicative> I see in http://hackage.haskell.org/packages/archive/hinze-streams/1.0/doc/html/Data-Stream-Hinze-Idiom.html
12:10:50 <applicative> there is an obvious attempt to have an ordered sequence for all applicatives: repeat, map (map), zip (zipWith)
12:11:04 <edwardk> ccasin: heh i have one like that i'm trying to define now ;)
12:12:55 <applicative> but whatever the sequence intended is, there can only be a zero-ary one for cases like [] or Maybe
12:13:15 <edwardk> ccasin: i've been playing with a nicer signature for 'grad' (and jacobian, etc) for my AD implementation. i.e like it to let you use something like grad :: Num a => (forall s. RAD s a -> RAD s a -> ... -> RAD s a) -> a -> a -> ... -> (a, [a])
12:13:49 <Twey> applicative: That's okay it's not very useful anyway
12:13:58 <edwardk> though i can probably do that one with type classes
12:14:04 <Twey> It's just a conceptual basis
12:14:15 <edwardk> some of the hairer ones like hessians i'm somewhat hesitant about
12:14:29 <Twey> edwardk: AD?
12:14:36 <ccasin> edwardk: hmm, interesting.  The main difference is that the arity of an arity-generic function is actually the number of different type variables - here you have only one, you just use it n times.  But, this is probably a special instance of some arity-generic type
12:14:37 <edwardk> Twey: automatic differentiation
12:14:42 <Twey> Oh
12:14:55 <edwardk> ccasin: yeah, like i said, this one pretty much works
12:15:33 <copumpkin> reverse anno domini
12:15:34 <danharaj> Saizan: Haskell's type inference continues to surprise me. It can do a lot more than I would think.
12:15:59 <coryklein> I'm a newbie, trying basic Haskell in GHCI.  Trying to define function add :: Int -> Int -> Int and I get "Not in scope: 'add' " Does this kind of declaration not work in the interactive GHCI?
12:16:03 <ccasin> edwardk: I think I'm going to try adding arity-genericity to one of the haskell type-genericity frameworks at hac phi, maybe we can talk more about it them
12:16:17 <danharaj> Saizan: Although I don't see how it would hurt to allow the kind of matching I tried to do instead of having to do manual reflection. I guess performance issues.
12:16:22 <ccasin> though I'm not looking forward to the move from the glorious full dependency of agda to haskell's type functions
12:16:23 <tensorpudding> In GHCi you have to define functions using let
12:16:29 <coryklein> thanks
12:16:45 <copumpkin> let add :: Int -> Int -> Int; add x y = ...
12:16:46 <Saizan> danharaj: GADTs tend to have that effect :)
12:16:47 <edwardk> ccasin: what i'd like to do is allow for an uglier argument list, but i don't like what it would do to the shape of the partials, they'd cease to be a list, but instead become something like an hlist or a nested tuple set or something
12:17:49 <Saizan> danharaj: a general type-case construct would hurt some nice properties of the type system too
12:18:34 <ccasin> edwardk: sounds about right - I have dealt with hlists (or agda datatypes encoding them) many times in implementing arity-generic things
12:18:37 <edwardk> that way if you went to take grad :: Functor f => (forall s. f (RAD s a) -> RAD s a) -> f a -> (a, f a) -- you'd get something simple, the ugly part is that that overlaps in bad ways with allowing upwrapped 'RAD s's, etc.
12:18:38 <danharaj> Saizan: Such as?
12:19:04 <Saizan> danharaj: parametricity and the "Free Theorems" associated
12:19:21 <edwardk> i don't think its worth cluttering the api that i have to support the nastier types though
12:19:50 <ccasin> interesting
12:20:28 <ccasin> yeah, this kind of type hacking in haskell is fun but often too confusing for code one hopes other developers might use
12:21:19 <edwardk> i.e. i'd like to be able to pass in a variadic mess of lists of arbitrary traversables of AD vars and naked AD vars, and get a function that expects the same set (in non-AD form) and returns the output (possibly) and the partials with respect to each.
12:21:41 <edwardk> er s/of lists of/of lists or/
12:22:29 <edlinde> how similar are haskell and common lisp?
12:22:46 <edwardk> about as similar as greek and french
12:22:52 <edlinde> are there any concepts that are transferable between them?
12:23:02 <edlinde> hmm so not much in other words :)
12:23:34 <edwardk> they share some cognates, some common linguistic roots, knowing one helps with a few words when learning to read the other, but each has a lot of its own vocabulary and idioms that are completely unrelated to the other
12:23:42 <edlinde> edwardk: just that at uni they use a lot of lisp while I want to get into learning haskell this summer
12:24:18 <edlinde> wonder if its easy to pick up both over a course of two months.. well the basics atleast
12:24:23 <ccasin> edlinde: they are both functional programming languages, so if you know lisp you'll at least have cleared some of the intellectual hurdles that the C programmer faces in learning haskell
12:24:31 <edwardk> edlinde: you'll learn ideas that transfer, like higher order functions, etc.
12:24:31 <danharaj> Saizan: So how does reflecting the type manually avoid breaking parametricity?
12:24:33 <soupdragon> no that is not easy, you can't even learn one in two months
12:24:45 <edlinde> k
12:24:58 <danharaj> (also what is parametricity, each instantiation of a polymorphic function is the component of a natural transformation?)
12:25:49 <edwardk> danharaj: if you have a haskell type that looks like (forall a. a -> a) you know that function can only do one of a few small number of things
12:26:14 <edwardk> it can give you back the arg you gave it, maybe force it, and it might even return undefined
12:26:18 <edwardk> or loop forever
12:26:33 <edwardk> but it can't discriminate on a beyond that
12:26:41 <edwardk> it can't do one thing if a is Int and another if a is Char
12:26:45 <Saizan> danharaj: the reason is that the type of the evidence appears in the type of the function
12:26:47 <danharaj> Ah I see, and type level matching would allow breaking that.
12:26:59 <Saizan> i.e. you'd get forall a. TyRep a -> a -> a
12:27:01 <edlinde> ccasin: sorry are you suggesting I learn LISP first?
12:27:05 <edwardk> allowing type level matching empowers the programmer to write other functions
12:27:16 <edwardk> we have those, you can use Typeable for instance to extract type info
12:27:24 <applicative> edlinde, edwardk is being a gloomy expert -- his conception of 'knowing/learning Haskell' is too exalted.  If you have learned (map ...) you can learn Haskells fmap, then you know practically everything
12:27:29 <ccasin> edlinde: if you have a choice, learn haskell first!  I'm just saying that some ideas will carry over from one to the other in either direction
12:27:35 <edwardk> tere are lots of functions of the form: (forall a. Typeable a => a -> a)
12:28:13 <edlinde> you cannot really know know a language till you code in it for a while
12:28:17 <edwardk> where the Typeable class gives you more introspection ability into the type, which can be used to see if it is Char or Int, etc. and respond accordingly
12:28:22 <applicative> > map (\x -> x * x) [1,2,3,4]
12:28:23 <lambdabot>   [1,4,9,16]
12:28:30 <edlinde> so yeah I would like to atleast be able to identify what I can and cannot use to code
12:28:33 <applicative> > fmap (\x -> x * x) [1,2,3,4]
12:28:33 <lambdabot>   [1,4,9,16]
12:28:44 <applicative> > fmap (\x -> x * x) ("hahah", 3)
12:28:45 <lambdabot>   ("hahah",9)
12:28:46 <edlinde> I actually seen the map function in perl before
12:28:57 <edlinde> they probably stole it from some functional language
12:28:59 <danharaj> IMO Learning Haskell makes you a better programmer.
12:29:02 <edwardk> edlinde: learning a functional grasp of both haskell and lisp over the course of a summer isn't insurmountable
12:29:25 <edwardk> i think that haskell did far more to shape my understanding of the universe than knowing lisp ever did, but your mileage may vary
12:29:35 <copumpkin> same here!
12:29:50 <copumpkin> omg
12:30:00 * copumpkin shuts up
12:30:05 <edlinde> I just don't want to get into lisp coz i think its more of an older language than haskell
12:30:36 <copumpkin> learn scheme
12:30:42 <copumpkin> it's old but fun
12:30:45 <nostrand> yeah, it's nice
12:30:48 <applicative> then you have SICP to read
12:30:48 <edlinde> unfortunately lot of the code written on this research test bed is all in lisp and to extend it means having to write code in LISP or C
12:30:55 <edwardk> scheme is a lot of fun
12:30:58 <edlinde> I like C but I really want to learn a functional language too
12:31:13 <nostrand> edlinde: Scheme is easy to start with =)
12:31:17 <soupdragon> Some people.. when learning lisp think "I'll read SICP". Now they have an entire book full of problems.
12:31:24 <edwardk> edlinde: the learn both and transfer ideas between. it'll give you an appreciation for multiple points in the functional language design space
12:31:29 <edlinde> Yeah I did some scheme ages ago... very basic stuff for an AI course I think
12:31:29 <edwardk> soupdragon: hahahaha
12:31:35 <nostrand> hi Walt =)
12:31:45 <edlinde> ah do you guys use any special editors or IDEs for Haskell?
12:31:59 <nostrand> emacs for me
12:32:00 <edwardk> @remember soupdragon Some people.. when learning lisp think "I'll read SICP". Now they have an entire book full of problems.
12:32:00 <copumpkin> there's leksah but I've never used it
12:32:01 <lambdabot> I will remember.
12:32:22 <edwardk> edlinde: they exist, but a lot of folks just use vim/emacs
12:32:24 <applicative> edlinde, you'll just cause an emacs v. vim war, with the complication of yi
12:32:52 <edlinde> I don't use either.. :)
12:32:53 <jlouis> acme!
12:32:54 <bremner> except nobody actually advocates using yi, do they?
12:33:00 <applicative> i use textmate because i'm a moron
12:33:02 <edlinde> mostly use Textmate :)
12:33:11 <edlinde> applicative: hahahha yeah me too
12:33:12 <applicative> oops, sorry edlinde
12:33:14 <Walt> vim
12:33:16 <Walt> !
12:33:24 <coryklein> vim here
12:33:51 <edlinde> I know all the lisp people go on and on about emacs and xemacs.. but its too convoluted for my tastes
12:33:52 <coryklein> although learning vim with a dvorak keyboard layout was interesting
12:34:00 <edlinde> after all its an editor :)
12:34:15 <applicative> i think i would rather spend the time learning to play the pipe organ
12:34:27 <copumpkin> is that a euphemism?
12:34:31 <zachk> applicative: like Knuth?
12:34:31 <applicative> haha
12:34:33 <nostrand> haha
12:34:34 <coryklein> lol
12:34:37 <edwardk> edlinde: using emacs when learning lisp isn't a bad idea just because you get to bootstrap your understanding of each upon the other
12:34:40 <edlinde> lol
12:34:47 <edwardk> edlinde: but i agree it is generally a pain in the behind ;)
12:34:59 <edlinde> yeah it is
12:35:10 <Saizan> poor emacs
12:35:32 <edlinde> I mean our prof loves it but the only point he makes is that you can execute lisp code in the editor
12:35:40 <zachk> i looked at yi, and the vim-style config file was like 1100 lines long :(
12:35:40 <edlinde> big deal :)
12:36:19 <edwardk> zachk: vi is a pretty substantiatial 'language' even before you add the 'm' nonsense ;)
12:36:49 <zachk> edwardk: only thing i use in vim is the syntax highlighting and :wq!
12:37:12 <copumpkin> hah
12:37:20 <pastorn> zachk: you're doing it wrong!
12:37:27 <zachk> what should I be doing?
12:37:36 <copumpkin> learning every last feature of vim by heart
12:37:58 <zachk> why?
12:37:58 <coryklein> regular expressions
12:38:27 <soupdragon> why woul dyou waste time with vim if there's quantum physics to learn
12:38:30 <soupdragon> ??
12:38:36 <edwardk> zachk: http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118 read the first response. it is one of the best summaries of how vi works for a poweruser that i've seen
12:38:51 <zachk> i used to use regex's in perl , i stopped using perl after i commented the crap out of oo perl, came back a month latter and couldnt understand how my code worked
12:39:06 <copumpkin> soupdragon: learn both!
12:39:12 <edwardk> copumpkin: you don't need every last feature, just learn to navigate and yank, and what the subjects/verbs/objects are ;)
12:39:14 <coryklein> edwardk: the first response or the highest response?
12:39:30 <copumpkin> yeah, I don't really know much vim
12:39:33 <edwardk> coryklein: the highest, the 631 Your problem with Vim is that you don't grok vi.
12:40:17 <edlinde> applicative: do you execute haskell code in textmate?
12:40:35 <edwardk> that reply doesn't even use 'vim' features, just 'vi' ones that work most everywhere someone has a vi mode
12:40:59 <edlinde> zachk: yeah perl OO sucks big time
12:41:02 <edlinde> :)
12:41:10 <edwardk> edlinde: moose isn't terrible
12:41:17 <Twey> I hear Moose is pretty nice
12:41:18 <edlinde> zachk: used to work with some people who loved Perl so much...
12:41:23 <edlinde> yeah moose is new
12:41:34 <edwardk> i used to write a lot of pre-moose oo perl though, so i feel your pain =)
12:41:37 <edlinde> but a few years earlier when there was no moose or catalyst etc
12:41:44 <Twey> Ah
12:41:44 <edlinde> yeah exactly
12:41:46 <applicative> edlinde, I just open the modules in ghc.
12:41:49 * mreh thinks "a <- arrow -< ()" is ugly
12:41:53 <applicative> ghci, rather
12:41:58 * soupdragon thinks arrows in general are ugly
12:41:58 <edwardk> mreh its very er... pointful
12:42:17 * applicative agrees with mreh
12:42:29 <mreh> edwardk: arrow syntax is great, I don't like the () being there for an arrow that doesn't take any input
12:42:35 <mreh> or ignore it rather
12:42:39 <boegel> is the guy who wrote the blog post on the new LLVM backend for GHC in here?
12:42:40 <edwardk> the <- arrow -< () syntax works reasonably well when you're laying out a big circuit diagram of some sort
12:43:22 <mreh> edwardk: absolutely
12:43:26 <edlinde> i really get the feeling that functional langs will be the norm soon
12:43:37 <edlinde> and langs like java will die out soon :)
12:43:50 <mreh> edlinde: your powers are weak old man
12:43:52 <soupdragon> im not expecting that
12:43:53 <applicative> boegel, he does have a nick, but i can't remember.
12:44:03 <boegel> applicative: doesn't everyone have a nick?
12:44:07 * boegel is shocked
12:44:16 <edlinde> mreh: wait and watch
12:44:17 <edlinde> :)
12:44:27 <applicative> boegel, i meant he has been known to intervene here.
12:44:48 <boegel> applicative: yeah, I know what you meant
12:44:55 <Silvah> Java *is* dead.
12:45:09 <boegel> applicative: is it possible it starts with david? daviddarais? davidL?
12:45:15 <mreh> soon we'll have lots of people in here asking what a haskell is
12:45:26 <mreh> it's all in this handy equation
12:45:28 <edlinde> Silvah: thanks
12:45:30 <edlinde> :)
12:45:37 <coryklein> After 3 years of a CE degree, today was the first time I heard about Haskell, even though it has existed for 20 years.  Do we foresee the principles behind Haskell going mainstream any time soon?
12:46:03 <davidL> boegel: not me, sorry :)
12:46:04 <mreh> coryklein: it already has much success in the mainstream
12:46:09 <edwardk> coryklein: the way i see it they are already going mainstream.
12:46:19 <edlinde> coryklein: what languages did you use in your CE degree?
12:46:23 <Silvah> mreh: what Haskell is?
12:46:26 <tensorpudding> Functional programming is on the rise.
12:46:35 <coryklein> C, C++, C#, Java
12:46:44 <coryklein> the standard CS library of languages...
12:46:49 * soupdragon needs to abandon ship before it starts sinking
12:46:53 <mreh> Silvah: I often talk like a lolcat
12:46:58 <applicative> that's a lot of curly brackets, you must be very tired
12:47:01 <edlinde> coryklein: I still don't believe you haven't heard of Haskell till today :)
12:47:01 <edwardk> coryklein: C#'s linq is derived largely from the old haskell notion of a monad comprehension, and some new language features to support reflection into lambdas.
12:47:19 <tensorpudding> Though the defining feature of Haskell is laziness, which I don't think any major language has adopted support for yet?
12:47:29 <Silvah> D
12:47:34 <soupdragon> dunno what major means
12:47:40 <edwardk> tensorpudding: thats because its not something you can retrofit, you need to build for it all the way down
12:47:43 <Silvah> Ah, "major".
12:47:53 <tensorpudding> I would call D major.
12:47:53 <soupdragon> there are a few languages which have lazy evaluation (as well as other forms)
12:47:59 <tensorpudding> har har D Major
12:48:12 <coryklein> It just makes me wonder if Haskell will be the thing going mainstream and the popular language of choice, or whether the attractive features of Haskell will be thrown into Java 7.0 and C++++
12:48:13 <mreh> guitar player's key
12:48:16 <lowasser> I would call your PUN a major ATROCITY AGAINST THE ENGLISH LANGUAGE.
12:48:31 <lowasser> kthxbai
12:48:40 <tensorpudding> But anyway.
12:48:43 <Silvah> D isn't major, it's less popular than Haskell...
12:48:54 <soupdragon> for good reason too...
12:49:32 <pikhq> coryklein: Most of the attractive features of Haskell cannot be put into another language without getting a language *remarkably* similar to Haskell.
12:49:37 <tensorpudding> So laziness and purity are harder to find in languages with mixed paradigms.
12:49:59 <bremner> Oz is far from major, but does support laziness
12:50:14 <coryklein> pikhq: that makes sense.
12:50:34 <tensorpudding> Lots of languages with static typing are adopting parametric polymorphism though
12:50:47 <coryklein> pikhq: it's still my first day, so I haven't yet gotten a comprehensive understanding of the Haskell paradigm anyhow
12:51:01 <tensorpudding> "generics" being a by-word
12:51:27 <wli> I'm kind of doubting a whole lot of functional programming is going to go on in the so-called "mainstream."
12:51:30 <pastorn> coryklein: the paradigm is "get yelled at by the typechecker until you do it right"
12:51:40 <edwardk> lowasser: puns were once considered the highest form of humor -- though that was in the same era when we used to bleed sick people to make them better, so perhaps that should be considered when weighing the value of the ideals of the time
12:51:50 <applicative> lets make a type violation
12:51:52 <soupdragon> wli hehe good point eyah
12:51:57 <applicative> > 'a' + "b"
12:51:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:51:58 <lambdabot>         against inferred type...
12:52:07 <coryklein> pastorn: haha, that's what I've already seen after a little tinkering in GHCi
12:52:12 <Silvah> CMETAIT rocks...
12:52:23 <tensorpudding> But I would say that stylistically they're more adopting an ML way of doing things.
12:52:54 <pastorn> coryklein: also: values are never overwritten, only copied with modification (applying a funciton)
12:53:15 <applicative> > 'a' + "b" + (1 :: Int)
12:53:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:53:16 <lambdabot>         against inferred type...
12:53:16 <pastorn> coryklein: it's like all the variables i haskell has the java keyword 'final' in front of them :)
12:53:39 <coryklein> pastorn: yea it feels really strange atm
12:53:58 <Silvah> Actually it's closer to D's "immutable".
12:54:05 <pastorn> coryklein: you get past the weirdness through recursion :)
12:54:43 <tensorpudding> D is intriguing, but isn't it wracked with problems regarding incompatible implementations?
12:55:00 <Silvah> They're compatible...
12:55:10 <applicative> tensorpudding, don't we have incompatible implementations
12:55:13 <illissius> tensorpudding: afaik, 1.0 is/was, 2.0 won't be
12:55:18 <coryklein> pastorn: I hope so, I was making a 2d iPhone game for fun, and now I'm tempted to do it on desktop in Haskell.  Seems to be more fun, challenging, and educational.
12:55:20 <illissius> not sure what the progress on 2.0 is
12:55:29 <tensorpudding> Our implementations are really incompatible too, yes.
12:55:39 <Silvah> Though there is only one implementation up-to-date.
12:55:40 <zachk> coryklein: making games in haskell doesnt seem to be one of its strong points :(
12:55:44 <pastorn> coryklein: sure, there's glut and everything in haskell
12:55:49 <tensorpudding> but the largest one is so much more popular than the others it's irrelevant.
12:55:58 <edwardk> games and haskell don't always work well together
12:56:06 <applicative> Hugs is the most popular
12:56:15 <edwardk> of course hugs are popular
12:56:41 <illissius> (the problem was with competing/incompatible stdlibs+runtimes, but in 2.0 the core runtime will be shared by both so they will be compatible -- again, afaik.)
12:56:44 <pastorn> hugs are better than goohicky
12:56:54 <zachk> > length "hugs" > length "drugs"
12:56:55 <lambdabot>   False
12:57:09 <zachk> see drugs last longer...
12:57:09 <pastorn> > "hugs" > "drugs"
12:57:10 <lambdabot>   True
12:57:37 <tensorpudding> Do people still use Hugs?
12:57:48 <pastorn> i don't think so...
12:57:56 <edwardk> tensorpudding: a couple of academic holdouts ;)
12:57:56 <Silvah> Icy dead people do...
12:57:57 <tensorpudding> I'd figure the only reason people would download Hugs now would be if they read an ancient tutorial suggesting that they did so.
12:58:13 <edwardk> tensorpudding: that about sums it up
12:58:24 <zachk> i tried hugs and it turned me off to haskell, 2 years latter i gave haskell another try, i like ghc/ghci so much better
12:58:49 <applicative> hugs is way faster than ghci
12:59:04 <pastorn> 4 realz?
12:59:14 <Silvah> Interpreter does not have to be fast.
12:59:19 <zachk> whats the point of an interpreter if you dont have a REPL
12:59:52 <applicative> i always use runhugs where possible
12:59:57 <applicative> which isn't often....
13:00:25 <tensorpudding> llama calculus
13:01:44 <bitstream0101> Anyone know how I can get the packedstring package to cabal-build using 6.12? "I keep getting Data/PackedString.hs:83:7:Could not find module `Data.Data': It is a member of the hidden package `base'."
13:01:48 <soupdragon> I am having trouble visualzing \x -> x x in llama calculus
13:01:56 * applicative would propose a Facebook society of Hugs enthusiasts, but that would mean looking at Facebook.
13:02:17 <pastorn> soupdragon: in haskell that won't typecheck, but you can run that in scheme :)
13:02:23 <Saizan> bitstream0101: why are you trying to compile packedstring on 6.12?
13:02:36 <bitstream0101> Saizan: Because I need it for a package...
13:02:47 <Saizan> bitstream0101: which?
13:02:52 <bitstream0101> Saizan: derive-0.1.1
13:03:07 <Silvah> > (\x -> x x) id
13:03:07 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:03:14 <edwardk> bitstream0101: sounds like a good time to patch it to use bytestrings ;)
13:03:20 <bitstream0101> I'm experimentally attempting to build a legacy code base to get a sense for how nasty things will be
13:03:27 <bitstream0101> edwardk: yeah, i'm not changing any code though :)
13:03:49 <Saizan> bitstream0101: that version of derive is unlikely to work due to changes in template-haskell anyhow
13:03:50 <wjt> I've got someone trying to build a Gtk2HS application
13:04:02 <Saizan> bitstream0101: you should try a newer version
13:04:04 <bitstream0101> Saizan: Ah, ok. Guess I'll revert to 6.10 then :(
13:04:06 <applicative> bitstream0101, is there a reason you want the old one
13:04:07 <bitstream0101> Thanks
13:04:30 <edwardk> bitstream0101: looks like it was already updated a long time ago. you probably can't built the old version on anything too recent, packedstring was phased out
13:04:33 <bitstream0101> applicative: yup, legacy code base with packages already installed in a customer's environment
13:04:48 <bitstream0101> edwardk: I can build it on 6.10
13:05:16 <wjt> sigh ^M. I've got someone trying to build a Gtk2HS-based application I maintain on Windows, about which I know nothing, emailing me. AFAICT they've got cabal-install, GHC, and gtk2hs itself all installed properly, but `cabal install` is not finding gtk2hs. is there a better place to point people with these kinds of issues than the -cafe and/or here?
13:05:22 <applicative> hmm, i wonder if there is a way around this.
13:05:26 <bitstream0101> applicative: We can suggest an upgrade to a newer ghc, but only if it's relatively painless in terms of what patches we have to do.
13:05:43 <bitstream0101> using 6.10 isn't a big deal though, i spose.
13:06:02 <edwardk> > (\x :: ((forall a. a -> a) -> (forall a. a -> a)) -> x x) id 12
13:06:02 <wjt> hmm. ambiguous. the windows bit is what I know nothing about, not the application. :)
13:06:03 <lambdabot>   Illegal result type signature `(forall a. a -> a)
13:06:03 <lambdabot>                          ...
13:06:10 * Saizan thinks it should be pretty easy to migrate to a newer derive
13:06:11 <tensorpudding> Some people are still using 6.6
13:06:39 <tensorpudding> Some OS's are still using 6.8 in their packages
13:06:42 <bitstream0101> Saizan: I might give it a shot; I'm very wary of upgrading packages though, as the regression suite in this particular scenario is a bit...lacking.
13:06:48 <nostrand> tensorpudding: i have 5-something at school =/
13:07:02 <Silvah> How can I stop the rain in Haskell? ;)
13:07:13 <edwardk> Silvah: unsafePerformRainDance
13:07:22 <edwardk> just make sure to get the arguments right or you'll make it worse
13:07:51 <soupdragon> lol
13:08:13 <pastorn> @can haskell stop the rain?
13:08:13 <lambdabot> Maybe you meant: faq map run wn
13:08:18 <pastorn> @faq can haskell stop the rain?
13:08:18 <lambdabot> The answer is: Yes! Haskell can do that.
13:08:30 <Silvah> Well, there's nothing bad in flood...
13:26:01 <illissius> @faq can haskell has cheezburger?
13:26:02 <lambdabot> The answer is: Yes! Haskell can do that.
13:26:06 <illissius> hmm.
13:26:17 <HugoDaniel> hi
13:26:23 <boyscared> @faq can haskell not do that?
13:26:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:29:33 <Silvah> I don't understand why some functions are "evil".
13:30:08 <orbitz> Silvah: the oneRingToBindThemAll function didn't tip you off?
13:30:30 <p_l> nor unsafeRaiseCthulhu ?
13:31:17 <byorgey> preflex: seen conal
13:31:17 <preflex>  conal was last seen on #haskell 1 day, 2 hours, 11 minutes and 44 seconds ago, saying: hacky sack looks awfully fun.
13:31:19 <soupdragon> Silvah do you understand type systems?
13:31:45 <conal> byorgey: hi
13:31:50 <byorgey> hi conal!
13:31:51 <soupdragon> Silvah; like what happens in C when you reinterpret a float as an integer by accident -- that's beacause the type system didn't hel
13:32:14 <byorgey> conal: just wanted to say that it makes me very happy to see that you chose the VectorSpace (a -> v) instance where Scalar (a -> v) = a -> Scalar v
13:32:37 <byorgey> conal: and that you chose it precisely because if Scalar (a -> v) = Scalar v there is no InnerSpace instance, which is what I was worried about =)
13:33:03 <conal> byorgey: ah!  i'd forgotten about that reason.
13:33:05 <Silvah> Well, functions cannot be "evil". What about using, for instance unsafePerformIO when we know we're doing something safe, what about using fail when throwing an exception, if used monad didn't override that behavior, is the thing we actually want to do?
13:33:24 <conal> byorgey: i just remember that it was a tough/tricky choice.
13:33:54 <byorgey> conal: yes, Scalar (a -> v) = Scalar v does make perfect sense as a vector space, and I could see wanting that version too
13:33:56 <orbitz> Silvah: does it do what someoen calling your function wants it to do?
13:34:04 <byorgey> but it just so happens that I want the other one.
13:34:08 <Silvah> Functions can't be evil, the reason for using them can be.
13:34:11 <dv-> What's the easiest, most straightforward binding to sqlite? HDBC-sqlite? haskelldb-hsql-sqlite,...?
13:34:23 <dv-> er, wrong terminal...
13:34:49 <byorgey> conal: have you had a chance to look at my patch?  no rush, just wondering
13:35:22 <conal> byorgey: no, not yet.  which modules of vector-space does it cover?
13:35:49 <Silvah> So please don't say that some functions are evil.
13:35:54 <byorgey> conal: it modifies Data.LinearMap and Data.Maclaurin
13:36:05 <byorgey> conal: the second only trivially to account for some extra newtype wrapping/unwrapping
13:37:05 <conal> byorgey: oh -- Data.Maclaurin.  cool!  i thought i might have to try that bit myself.  thanks.
13:37:40 <conal> byorgey: i'm encouraged to hear it was an easy adaptation.
13:38:30 <byorgey> conal: yeah, and the type family injectivity thing turned out to be a red herring.
13:39:03 <conal> byorgey: in the sense of a non-issue?  or an easy-to-fix issue? or ??
13:40:26 <byorgey> conal: in the sense of a non-issue -- we just needed a newtype to stick in an extra layer of "generativity" so that  s :-* t  and u :-* v are different types whenever s and u are different types, even if it so happened that Basis s ~ Basis u.
13:41:40 <byorgey> which seems to me like the right thing to do -- I wouldn't expect to be able to use an  s :-* t  as a  u :-* t, even if s and u happened to have the same basis.
13:41:53 <conal> byorgey: i guess "non-issue" is vague.  sounds like injectivity failed and was easy to avoid (by adding generativity).  am i getting it?
13:42:06 <conal> byorgey: oh yeah.  good point!
13:42:14 <conal> (happened to have have the same basis)
13:42:47 <byorgey> conal: yes, and the fact that it could very well make sense to have two different vector spaces that happened to have the same basis (I think).
13:42:56 <byorgey> so making Basis injective would not be the right thing to do anyway.
13:44:35 <conal> byorgey: indeed.  i hadn't realized.  yay.  i love it when my implementations tell the truth.  just "working" is much less satisfying for me.
13:44:51 <byorgey> hehe, indeed!
13:52:12 * hackagebot ltk 0.8.0.6 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.8.0.6 (JuergenNicklischFranken)
13:54:14 * hackagebot leksah-server 0.8.0.6 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.6 (JuergenNicklischFranken)
13:56:15 * hackagebot leksah 0.8.0.6 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.8.0.6 (JuergenNicklischFranken)
14:05:10 <eevar> any vista users who managed to put their local_user cabal path in front of the system path one?
14:05:27 <eevar> guess i'll just have to settle for modifying the global path..?
14:09:46 <sztomi> quit
14:09:51 <sztomi> oops, sorry
14:11:13 <danharaj> how is Data.Typeable implemented?
14:11:31 <noteed_> I'd like to contribute a patch to Cabal, should I email it to cabal-devel ?
14:12:33 <ddarius> danharaj: In GHC, with unsafeCoerce.
14:13:20 <byorgey> noteed_: yes.  If you use 'darcs send' it should automatically email it there, I think.
14:14:02 <danharaj> ddarius: eek.
14:16:01 <Saizan> noteed_: you need to suscribe to the mailing list first
14:16:05 <danharaj> For my AST typing, I have a datatype TypeR for representing types, a class Typeable for types that can be reflected onto it, and now I need a function that is :: (Typeable a, Typeable b) => (a -> b) -> (TypeR a, TypeR b), and I'm not sure how, if possible, to do this.
14:16:13 <Saizan> noteed_: or you can attach it to a ticket, if there's one
14:16:40 <ddarius> danharaj: What are the operations of Typeable.
14:17:52 <danharaj> ddarius: So far, only typeOf :: a -> TypeR a
14:18:14 <Saizan> danharaj: which ignores the value of the argument, right?
14:18:19 <Saizan> that's enough
14:18:39 <danharaj> yeah
14:18:53 <noteed_> byorgey, Saizan: ok
14:19:32 <illissius> is there any way to run external programs that's part of the base libraries?
14:20:07 <Saizan> danharaj: arg :: (a -> b) -> a; arg = undefined; result :: (a -> b) -> b; result = undefined; foo f = (typeOf (arg f), typeOf (result f))
14:20:23 <ddarius> danharaj: Probably the most direct thing to do is to use lexically scoped type variables.
14:20:54 <danharaj> ddarius, Saizan: Ok I am confused on both counts.
14:21:19 <ddarius> danharaj: Then instead of Saizan's craziness you have: foo :: forall a b. (Typeable a, Typeable b) => (a -> b) -> (TypeR a, TypeR b); foo _ = (typeOf (undefined :: a), typeOf (undefined :: b))
14:22:20 <Saizan> mine is haskell98!
14:22:24 <illissius> danharaj: undefined is an instance of every type. so if a function has type (a -> b) -> a and returns undefined, it's going to be an undefined of type a
14:23:46 <danharaj> illissius: Oh. I see. I guess having bottom be in every type actually does come in handy.
14:24:53 <illissius> yep
14:26:22 <Saizan> otherwise you could just define data Proxy a = Proxy; and have typeOf :: Proxy a -> TypeR a
14:27:09 <danharaj> Phantom type?
14:27:18 <Saizan> yup
14:27:51 <danharaj> I am going to go with ddarius' solution, because I would like to become familiar with as much of GHC's type system as possible with these projects. :)
14:27:58 <danharaj> Also It is a bit of e-peen for using more extensions.
14:28:10 <Saizan> someday we might have explicit type instantiation and we'll just write "typeOf :: forall a. TypeR a"
14:33:59 <mdmkolbe> Is there a way to turn off GHC's "variable defined but not used" warning for a specific variable?  I don't want to turn it off for the entire source file.
14:34:54 <aristid> mdmkolbe: why not use _?
14:35:49 <Saizan> danharaj: oh, wait, the argument is entirely superflous!
14:36:09 <danharaj> Saizan: Yes it is.
14:36:12 <Saizan> danharaj: 'a' already appears in the type as the argument of TypeR
14:36:21 <Saizan> no need for a Proxy either.
14:37:00 <danharaj> Wait, so I don't need undefined :: a or anything then because the compiler will deduce it is type a anyway?
14:37:07 <mdmkolbe> aristid: b/c the code is cleaner to read with the variables in it instead of "_".  (It's part of a literate haskell paper and the function shows a large amount of symetry that is broken if I use _.)
14:37:09 <danharaj> Just undefined?
14:37:30 <aristid> mdmkolbe: hm
14:37:48 <ddarius> Try prefixing the unused variables with _.
14:38:56 <mdmkolbe> ddarius: hmm, that seems to work.  now to place a few %format commands to make them print without the _ ...
14:38:58 <Saizan> danharaj: no, you could change the type of typeOf to just "TypeR a" and then you can write "foo :: (Typeable a, Typeable b) => (a -> b) -> (TypeR a, TypeR b); foo _ = (typeOf,typeOf)"
14:39:12 <danharaj> ah
14:39:19 <danharaj> saizan: That makes sense.
14:39:51 <danharaj> saizan: Can't believe I looked over that.
14:47:46 <tensorpudding> Haskell needs to trademark the phrase RTFJA
14:47:56 <tensorpudding> which stands for "read the fine journal article"
14:49:45 <ivanm> tensorpudding: heh
14:50:01 <ivanm> @remember tensorpudding Haskell needs to trademark the phrase RTFJA, which stands for "read the fine journal article"
14:50:01 <lambdabot> It is stored.
14:50:22 <EvanR-work> @quote tensorpudding
14:50:22 <lambdabot> tensorpudding says: >>= reminds me of a pair of chopsticks grabbing chow mein
14:50:27 <ivanm> bos: did the second attempt at a patch work?
14:50:33 <tensorpudding> I don't remember saying that.
14:50:41 <EvanR-work> lol
14:50:47 <tensorpudding> @quote tensorpudding
14:50:47 <lambdabot> tensorpudding says: it's like the pigeonhole principle for scat porn
14:50:47 <illissius> always a bad sign
14:50:48 <ivanm> tensorpudding: lambdabot doesn't lie!
14:50:50 <bos> ivanm: i've been too busy to look - will soon
14:50:58 <ivanm> bos: fair enough
14:50:59 <tensorpudding> I don't remember saying that either!
14:51:11 <tensorpudding> Wait, now I do.
14:51:16 <ivanm> tensorpudding: becoming forgetful in your old age are you? :p
14:51:18 <danharaj> there's no 'third' function for triples is there :|
14:51:32 <ivanm> danharaj: no
14:51:37 <EvanR-work> @t trd
14:51:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:51:41 <EvanR-work> :t trd
14:51:42 <lambdabot> Not in scope: `trd'
14:51:44 <ivanm> danharaj: there are no convenience functions for anything larger than a 2-tuple
14:51:46 <tensorpudding> if you define your own, would it be trd or thd?
14:51:47 <EvanR-work> :t thd
14:51:48 <lambdabot> Not in scope: `thd'
14:51:57 <EvanR-work> trds for the win
14:51:58 <ivanm> tensorpudding: thd reads like thud to me...
14:52:02 <mauke> thrd
14:52:14 <mauke> frst, scnd, thrd
14:52:48 <tensorpudding> frth, ffth, sxth, snth, eith, nnth, tnth
14:53:32 <mauke> $(nth 3)
14:53:52 <mauke> preflex: 6st 1 2 3 4 5 6 7 8 9 10
14:53:52 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th
14:54:17 <tensorpudding> 6st?
14:54:29 <mauke> yes
14:54:36 <tensorpudding> and 7rd
14:54:51 <EvanR-work> severed
14:54:52 <tensorpudding> that's not right!
14:55:04 <mauke> good thing you're fine with 2rd, though
14:55:15 <tensorpudding> And 2rd!
14:55:16 <EvanR-work> secured
14:55:20 <arw> and 3th!
14:55:33 <EvanR-work> thirth..
14:55:37 <tensorpudding> first, seconderd, thirth
14:56:05 <arw> sounds like me in fifth grade english...
14:56:27 <tensorpudding> primus, segundus, tertius, quartus
14:56:44 <tensorpudding> or something.
15:00:34 <danharaj> GHC has crappy parse error diagnostics :\
15:00:50 <Axman6> just takes getting used to
15:01:16 <aavogt> it could say something like unmatched parentheses
15:01:49 <applicative> illissius, the clutzy way to run external programs is System.Command; so e.g. in ghci you can get the path with >  system "echo $PATH"
15:02:09 <aavogt> but I suppose that isn't easy to do... a compiler isn't supposed to teach you the language grammar
15:03:10 <applicative> illisius, see http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Cmd.html and the recommendation of System.Process ...
15:04:09 <jmcarthur> danharaj: as Axman6 says, you get used to it, but i definitely agree with you that it needs a lot of improvement
15:04:41 <jmcarthur> clang is a great example of improved error messages over other compilers of the same language. it would be awesome if GHC reported error similarly
15:05:06 <jmcarthur> *errors
15:06:20 <illissius> applicative: yeah, I found it, thanks. my error was that I was trying to use :l to load it in ghci and interpreting the resulting error to mean that it's not part of the base libraries, and I only realized later that I'm an idiot
15:07:38 <applicative> illisius, i see, cool.
15:07:43 <illissius> (also it doesn't seem to be in hoogle)
15:10:14 <applicative> illisius, yes, that is odd, the module is missing.
15:11:16 <danharaj> oh, this is one error I haven't seen before "Inferred type is less polymorphic than expected."
15:11:32 <c_wraith> always a fun one.
15:11:45 <c_wraith> I mostly run into that when I try to get clever with runST
15:11:47 <aavogt> it's true
15:11:52 <c_wraith> but there are other ways to cause it
15:11:58 <aavogt> but it says nothing about how to fix it
15:12:18 <illissius> in my case when it said that, i meant i needed to use an existential type
15:12:20 <illissius> *it
15:12:50 <c_wraith> it tends to mean higher-ranked types are involved
15:12:54 <illissius> (if I'm remembering correctly)
15:14:33 <danharaj> oh god
15:14:47 <danharaj> I had a variable called 'a' in my expression and ghc decided to use 'a' as the type variable in that error.
15:14:55 <danharaj> No wonder it didn't make any sense.
15:15:12 <aavogt> haha
15:15:18 <jmcarthur> for an additive monoid, repeated addition is called multiplication. for a multiplicative monoid, repeated multiplication is called exponentiation. is there a word that describes both, or is it just a choice between calling it one or the other?
15:15:18 <aavogt> > 1 :: 1
15:15:19 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
15:15:19 <lambdabot>    arising from the literal...
15:15:49 <jmcarthur> > Unit :: 1
15:15:50 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:15:50 <lambdabot>    arising from a use of ...
15:15:55 <jmcarthur> well, that's it
15:18:11 <jmcarthur> i guess it's exponentiation
15:18:32 <danharaj> blah
15:18:36 <danharaj> I am never going to figure out this error.
15:18:59 <aavogt> and when your operation is exponentiation?
15:19:14 <aavogt> hmm, it's associative
15:19:40 <illissius> danharaj: paste?
15:19:45 <aavogt> I mean not associative
15:20:17 <applicative> danharaj, it serves you right for using Data.Typeable
15:20:31 <danharaj> applicative: I didn't. I'm using my own much simpler reflection.
15:20:47 <aavogt> how can you be simpler than Typeable?
15:21:00 <danharaj> I'm reflecting two types :|
15:21:09 <applicative> danharaj, It serves you right for using your home-made Data.Typeable.
15:21:14 <aavogt> so it's still a class
15:24:04 <illissius> omg html5 is awesome
15:24:32 <mauke> html5: now with tail call optimization
15:24:33 * illissius just saw his first html5 video. at first was like "wait i thought i had flash disabled", then was like "omg this is awesome"
15:27:43 <jmcarthur> okay another question... maybe harder... say i'm going to generalize this concept of exponentiation to positive, non-integer exponents... what might i call it?
15:28:02 <jmcarthur> well, to positive exponents that needn't be integers
15:28:09 <danharaj> hpaste isn't saving :|
15:31:32 <applicative> I see the "less polymorphic" post
15:31:45 <danharaj> oh, don't look at it
15:31:53 <danharaj> I was trying to correct it  when hpaste ate it
15:31:55 <danharaj> on my screen
15:33:08 <danharaj> I get 500 errors when I try to save ???
15:33:39 <danharaj> ok http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25568
15:33:50 <aavogt> jmcarthur: you need an inverse for the operation you're repeating?
15:34:06 <jmcarthur> nope
15:34:25 <aavogt> then what does it mean to +   (3/5) times?
15:34:57 <jmcarthur> that would be multiplying by 3/5
15:35:48 <aavogt> to me it looks like you need to have defined / as the inverse of *
15:35:50 <Cale> jmcarthur: You're trying to define exponentiation with fractional exponents?
15:35:57 <jmcarthur> Cale: basically
15:37:20 <jmcarthur> really just any real number, i guess the abstraction would be, but if there is reason to believe it would be more useful as rationals or something instead then i'm willing to hear why :)
15:37:25 <Cale> Let's start with rational exponents. You want a^(1/m) to be a number such that (a^(1/m))^m = a
15:37:26 <jmcarthur> anyway, i g2g for now
15:37:37 <jmcarthur> Cale: sorry, i'll bring it back up later. thanks though
15:37:40 <Cale> okay
15:38:10 <danharaj> Did I paste enough information?
15:38:30 * Cale looks
15:38:45 <Cale> aha...
15:39:33 <aavogt> danharaj: what are the types of your other things?
15:39:36 <Cale> Okay, what is the type of EOp1?
15:39:51 * aavogt was wondering that too
15:39:53 <danharaj> EOp1 :: (a -> b) -> Expr a -> Expr b
15:39:58 <danharaj> (that might be it)
15:40:18 <Cale> okay, and arithPOps :: [(String, a -> a)]
15:40:34 <Cale> hmm
15:40:49 <Cale> So  op :: a -> a, as it says :)
15:40:51 <danharaj> yeah, it only has prefix arithmetic operators. Later I wanted to make it have generic prefix operators.
15:40:58 <danharaj> I suppose I should fix that :p
15:41:37 <danharaj> Now I wonder what the correct type for my look-up list of operators should be...
15:41:52 <Cale> Now, all we can know about inV is that it is Expr b for some type b
15:42:37 <Cale> Is "Term" an existential type as well?
15:42:47 <danharaj> no, Term is an untyped AST
15:42:50 <Cale> okay
15:43:38 <danharaj> shouldn't we be able to deduce that, since inT :: TypeR Foo, that inV :: Term Foo if the pattern matches?
15:44:14 <Cale> danharaj: Well, we're not allowed to constrain which type of Term inV is
15:44:30 <Saizan> danharaj: oh, i see your problem
15:44:44 <Cale> All we know is that there *exists* a type t for which inV :: Expr t
15:44:52 <Saizan> danharaj: inT in "inV ::: inT <- translate t" doesn't work as a pattern
15:44:56 <Cale> (and we don't have any idea which)
15:45:00 <Saizan> danharaj: it's a new fresh variable
15:45:18 <Saizan> danharaj: but the idea of checking that those two types match is correct
15:45:21 <Cale> oh, I didn't even notice you were shadowing inT there
15:45:51 <danharaj> Saizan: What should I do?
15:47:04 <Cale> hmm...
15:47:04 <mdmkolbe> Is there a way to use the Either type as a monad without needing its left type to be an instance of Error?
15:47:24 <danharaj> mdm: You can define your own instance.
15:47:39 <aavogt> perhaps it's easier to define an instance of Error
15:48:17 <mdmkolbe> danharaj: the type happens to be universally quantified so I can't declare an instance (i.e. it is one of the type parameters of my function)
15:48:18 <danharaj> mdmkolbe: I was going to do that earlier but I decided to just use Error
15:48:19 <aavogt> since    (fail "")  is then  (Left undefined)
15:49:29 <aavogt> which is more awkward to deal with than  (Left "") -- or whatever the empty error message you get
15:49:41 <aavogt> danharaj: if you don't care for error messages, use Maybe instead of Either
15:50:11 <applicative> mdmkolbe, you are not talking about danharaj's Either problem, or are you?
15:50:14 <Saizan> danharaj: you should have a "cast :: TypeR a -> TypeR b -> a -> (Maybe b)" and use it to cast inV to inT or fail the translation
15:50:26 <mdmkolbe> applicative: no
15:50:39 <diego__> Given a list, [x1,x2,x3], i want to get another list of the form [x1+x1, x1+x2, x1+x3, x2+x2, x2+x3, x3+x3]. I did it getting all sums and then using nub, but it is pretty slow.
15:50:56 <mdmkolbe> aavogt: I have to return (Left r), not (Left "")...but now that I think of it, this might not work b/c then it wouldn't be an instance of MonadPlus since it couldn't define mzero, hmmm...
15:51:02 <copumpkin> > liftM2 (+) [x,y,z]
15:51:03 <lambdabot>   Overlapping instances for GHC.Show.Show
15:51:03 <lambdabot>                              ([Simp...
15:51:09 <copumpkin> > join (liftM2 (+)) [x,y,z]
15:51:10 <lambdabot>   [x + x,x + y,x + z,y + x,y + y,y + z,z + x,z + y,z + z]
15:51:36 <danharaj> Saizan: Ah. I see. This article I have been reading to understand this stuff uses a trick with a datatype `data Equal a b', I'm not sure how that one works.
15:51:45 <Cale> > [x + y | (x:ys) <- tails [1,20,300], y <- (x:ys)]
15:51:46 <lambdabot>   [2,21,301,40,320,600]
15:52:00 <copumpkin> diego__: that should work
15:52:05 <diego__> but x+y is the same as y+x
15:52:18 <copumpkin> oh
15:52:25 <copumpkin> hrrmpf
15:52:28 <Saizan> danharaj: ah, yeah, that's another way to phrase it, unles it's cleverer than i think
15:52:29 <Cale> > [x + y | (x:_)@ys <- tails [1,20,300], y <- ys]
15:52:30 <lambdabot>   <no location info>: parse error on input `@'
15:52:35 <Cale> > [x + y | ys@(x:_) <- tails [1,20,300], y <- ys]
15:52:36 <lambdabot>   [2,21,301,40,320,600]
15:52:39 <danharaj> Saizan: No I think it is equivalent.
15:52:44 <aavogt> nub is slower than converting to and from Data.Set.Set
15:52:52 <danharaj> Saizan: So many tricks just to carry around proofs about types :D
15:53:05 <Cale> You can just use tails.
15:53:27 <Cale> > [x + y | ys@(x:_) <- tails [a,b,c], y <- ys]
15:53:28 <lambdabot>   [a + a,a + b,a + c,b + b,b + c,c + c]
15:53:48 <Saizan> danharaj: translate is doing a type check afterall :)
15:54:30 <diego__> :) that's nice
15:54:31 <diego__> thank you
15:54:31 <diego__> ahh, i get it
15:54:53 <danharaj> Saizan, so would this work as a definition for cast? cast x x = Just x; cast _ _ = Nothing?
15:55:18 <danharaj> If I just want to check for equality, of course.
15:55:37 <Cale> danharaj: no
15:55:40 <danharaj> boo
15:55:51 <Cale> danharaj: You can't bind a variable twice in the same pattern
15:55:56 <aavogt> needs overlapping instances...
15:56:06 <Cale> What needs overlapping instances?
15:56:15 <aavogt> type equalities
15:56:30 <Saizan> danharaj: no, you'd have to actually do the pattern match
15:56:53 <danharaj> Saizan: So O(n) boilerplate :(
15:56:55 <aavogt> perhaps I'm completely misunderstanding what is trying to be casted
15:57:05 <Saizan> danharaj: repeated variables just shadow each other, it's not lisp
15:57:27 <Cale> They don't even shadow each other
15:57:41 <Cale> > let f x x = x in f 5 6
15:57:42 <lambdabot>   Conflicting definitions for `x'
15:57:42 <lambdabot>  In the definition of `f'
15:57:45 <Saizan> s/lisp/prolog/ btw
15:57:46 <aavogt> if you nest the patterns like  \x -> \x -> \x -> ...
15:57:55 <danharaj> Saizan : I don't know any lisp :p
15:58:09 <Saizan> danharaj: i meant prolog :)
15:58:18 <Saizan> however yeah O(n) boilerplate..
15:58:19 <applicative> mdmkolbe, what sort of thing is supposed to be on the Left?
15:58:22 <danharaj> Saizan: neither that. :p
15:58:40 <aavogt> isn't your code already O(n) long?
15:59:01 <danharaj> aavogt: I would like to keep the constant down :p
15:59:03 <Saizan> in fact it's nicer to write that boilerplate to produce a Maybe (Equal a b) you might end up using it in other ways
15:59:04 <copumpkin> O(n) doesn't mean much without a meaning of n
15:59:21 <danharaj> copumpkin: n = number of types in the language
16:00:34 <danharaj> Saizan: I don't think any of this methodology is going to scale if I add user defined types or polymorphic types. Oh well.
16:00:56 <danharaj> Lessons learned: Type reflection in Haskell is painful.
16:01:01 <Cale> You can't use (==)?
16:01:52 <Saizan> danharaj: depends on how those types get defined
16:02:01 <Saizan> danharaj: polymorphic ones are indeed problematic
16:02:16 <Saizan> you need to represent them with combinators
16:02:26 <danharaj> I'll figure that out when my copy of Pierce arrives and I start working on typed lambda calculi instead of this project.
16:03:07 <Saizan> TAPL implements these kind of things in a much less fancy way. no gadts.
16:03:17 <danharaj> Saizan: No type reflection?
16:03:20 <Saizan> no type-indexed terms.
16:03:27 <Saizan> iirc, at least
16:03:39 <Saizan> i've not looked much at the implementation chapters
16:04:09 <illissius> yeah, you don't *need* to embed your language's type system into haskell's type system. it's just pretty neat that you can.
16:04:09 <Saizan> but it's done in ML
16:04:21 <danharaj> illissius: It's all an exercise in learning the Haskell type system
16:04:30 <danharaj> illissius: in the most painful way possible, apparently.
16:04:42 <hydo> Is there any obvious reason why this mangles data?  http://gist.github.com/404346  I can't get the images to write out correctly.  file(1) taunts me and says it's just 'data'. (image uploads with Hack and Web.Encodings)
16:04:42 <danharaj> illissios: also, my first experience with proof carrying code.
16:05:41 <hydo> s/it\'s/they\'re/
16:05:42 <Saizan> illissius: it's also quite useful for EDSLs
16:06:20 <illissius> danharaj: yeah, remember, i've been doing pretty much the same thing :) fun as hell
16:06:41 <illissius> but dunno how scalable it is
16:06:57 <danharaj> saizan: Ok, with cast defined, how should I insert it into my code?
16:07:16 <danharaj> illissius: Well, at some point you have to abandon the endeavor if you extend the type system in a way that goes beyond Haskell, like dependent types.
16:08:18 <ClaudiusMaximus> hydo: dunno about that, but personally i'd be worried if (Web.fileName fi) contained ../../../../../../../../../../../../../../../../../../some/important/system/file
16:08:48 <hydo> ClaudiusMaximus: Yes, I would too.  I'm not to that point yet because I can't write out a correct $(@*#$()@ing image.
16:08:55 <hydo> but I appreciate your concern.
16:09:20 <ClaudiusMaximus> hexdump -C might give interesting debugging info
16:09:32 <illissius> danharaj: for sure, but it could also become impractical before that point, though I have no idea
16:09:32 <Saizan> danharaj: http://pastebin.com/LqbS37bD <- i'd say like this
16:10:06 <hydo> ClaudiusMaximus: didn't try that... looking now.  Thanks!
16:10:08 <ClaudiusMaximus> i never use Hack though..
16:10:11 <ClaudiusMaximus> *used
16:11:18 <dmwit> hydo: If you're on 6.12, you are likely being bitten by your encoding.
16:11:40 <hydo> dmwit: I am on 6.12, as a matter of fact.
16:12:32 <dmwit> hydo: You'll want to use a binary write rather than a text write in that case.
16:12:47 <dmwit> ...since you are writing binary data, after all.
16:13:06 <hydo> dmwit: ala Data.Binary?  if I remember right...
16:13:15 <dmwit> hydo: Probably not.
16:13:17 <Saizan> no
16:13:28 <dmwit> hydo: Does that library really give values of type String? If so, you should complain. =P
16:13:33 <Saizan> just open the handle explicitly and set binary mode
16:13:52 <Saizan> dmwit: he's getting a ByteString out of it, actually
16:16:19 <hydo> Thanks for the help, Saizan, dmwit, etc.  Refactoring...
16:16:34 <Saizan> http://gist.github.com/404365
16:16:40 <Saizan> +import System.IO
16:17:42 <hydo> Saizan: Yayy!  I was on the right track!  Was moving stuff around to use withBinaryFile too.  That's a first.  I think I just levelled in Haskell.
16:17:54 <hydo> Saizan: oh, and thanks!
16:18:00 <danharaj> Saizan: Thanks for your help. Now I have to figure out the appropriate type signature for the lists in which I am looking up the operators.
16:18:09 <danharaj> Saizan: Because GHC is complaining about them.
16:18:16 <Saizan> hydo: np, hoping it actually works
16:18:32 <hydo> Saizan: I will know soon.  Tea first though.
16:19:31 <Saizan> danharaj: do they contain funtions with different types?
16:20:17 <danharaj> Saizan: right now, no but eventually I want to look up on operators with different types, so I need to use an existential somewhere.
16:20:35 <danharaj> Saizan: Right now the errors are about ambiguous type variables in constraints.
16:20:41 <mreh> can I execute a signal that is an arrow from within another arrow?
16:20:58 <mreh> if they're both the same arrow
16:22:35 <Saizan> danharaj: and you'd probably need a Typeable context in that existential too, about the ambiguous type variable maybe you need an annotation though i'd have to see the code to help :)
16:22:56 <Saizan> mreh: which are the types involved?
16:23:40 <mreh> Saizan: ArrowState
16:24:25 <mreh> having a hard time trying to get this Arrow to work with Yampa
16:24:50 <Saizan> meh, i think you've to give more details than that
16:25:07 <mreh> Saizan: okay, give me a second
16:27:31 <mreh> using ArrowRandom, the random computations have now become points in the Arrow syntax
16:27:50 <mreh> this is a high level overview of the problem
16:27:55 <mreh> seems best to explain the situation
16:28:04 <danharaj> Saizan: The only apprehension I have is that if I wrap them in an existential, I will have to do something fancier than OpTyper.
16:28:36 <Saizan> danharaj: OpTyper?
16:28:56 <Saizan> mreh: i don't understand
16:29:13 <danharaj> OpTyper1 :: forall a b. (Typeable a, Typeable b) => (a -> b) -> (TypeR a, TypeR b)
16:29:15 <Saizan> though i've never used Yampa, so that might be the cause :)
16:29:32 <mreh> Saizan: hang on, I'm eating toast D:
16:29:36 <danharaj> opTyper1*
16:29:52 <mreh> and watching dirty harry
16:30:24 <Saizan> ah ok :D
16:31:33 <danharaj> Saizan: Although maybe I can just simply lift opTyper to work on the existential `data AOp = forall a b. (Typeable a, Typeable b) => AOp (a -> b)'
16:32:07 <danharaj> ... well I don't see how to do that. GAH WHY DID I DECIDE TO DO THIS
16:32:35 <Saizan> danharaj: that's pretty simple to do, but actually i'd just unpack the existential constructor in the pattern guard
16:32:37 <mreh> so the randomness is now points in the arrow, but making an arrow that now random is a little more difficult than I had imagined, I can't get the generator out of the arrow
16:33:11 <danharaj> Saizan: Oh, right. I can do that. Crazy stuff these pattern guards, I don't know how you could even deal with existentials in a non-trivial manner without them.
16:33:17 <mreh> uhh, I hope that's clear
16:33:26 <Saizan> danharaj: case expressions :)
16:33:28 <jmcarthur> Cale: okay, you convinced me that i need an inverse operation
16:33:36 <danharaj> Saizan: without going insane
16:33:40 <Saizan> mreh: what do you mean by points in the arrow?
16:33:42 <zygoloid> hooray, working ptrace fun
16:34:02 <jmcarthur> Cale: is there anywhere else you were going to go with it?
16:34:13 <mreh> Saizan: input and output
16:34:44 <Cale> jmcarthur: Well, just that if you want to extend it further than that, the property that you want to preserve is that a^x a^y = a^(x+y)
16:35:03 <Saizan> mreh: it seems like you need a StateArrowTransformer applied to the Yampa arrow to keep the generator around?
16:35:11 <mreh> Saizan: exactly
16:35:14 <Cale> jmcarthur: and there might be many ways of doing that, starting from a definition for rational exponents, in general
16:35:33 <mreh> Saizan: I want to keep the splits around implicitly
16:35:41 <mreh> splitting the generator
16:35:45 <Cale> jmcarthur: However, what makes the real definition work out uniquely is continuity
16:36:36 <mreh> Rand always struck me as something completely in violation of referential transparency
16:36:44 <jmcarthur> Cale: right. i had a^x a^y = a^(x+y) in mind
16:36:48 <mreh> Random*
16:37:20 <Saizan> mreh: with get/put and arr you can lift a function of type StdGen -> (x,StdGen) to an arrow of type "a b x"
16:37:58 <jmcarthur> the ultimate goal is to apply this to something where real exponents would make the most sense, if only they were computable of course
16:38:01 <edwardk> preflex: xseen alpounet
16:38:01 <preflex>  alpounet was last seen on freenode/#haskell 7 days, 2 minutes and 16 seconds ago, saying: #lgorithms ? maybe
16:38:23 <danharaj> Hmm, I am getting an error. I think it is because I am trying to wrap (+) which is polymorphic in an existential.
16:38:40 <Saizan> mreh: well, fetch/store rather than get/put if we follow the names from here http://hackage.haskell.org/packages/archive/arrows/0.4.1.2/doc/html/Control-Arrow-Operations.html#t%3AArrowState
16:39:00 <mreh> Saizan: already done :)
16:39:35 <mreh> I think I have an idea of what to do now, talking it over always helps
16:39:46 <hydo> Saizan: hrm. Now they're much different sizes.  http://gist.github.com/404381  I'll keep poking at it though.
16:40:03 <mreh> I've been making consistant progress with haskell, I don't want to slow down
16:40:29 <mreh> I'm sure I've asked for a CT book before, what do you think is good?
16:40:45 <mreh> although you say it isn't necessary
16:40:55 <Cale> mreh: Awodey
16:40:56 <mreh> to be a good haskell programmer
16:41:02 <Saizan> they were saying good things about the Barr and Wells lecture notes yesterday
16:41:13 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
16:41:28 <Saizan> danharaj: you'd almost surely need to give a monomorphic type annotation to that
16:41:43 <ddarius> @google Barr Wells ESSLLI
16:41:45 <lambdabot> http://www.let.uu.nl/esslli/Courses/barr-wells.html
16:41:45 <lambdabot> Title: Courses: Barr / Wells
16:42:38 <mreh> is there an undergraduate course for CT?
16:42:40 <danharaj> Saizan: Yeah, that is working thus far, but that will be a pain if I add another numeric type, like float, to the language.
16:43:11 <mreh> ah good old utrecht
16:43:15 <danharaj> Saizan: I'll have to check for that and choose the appropriate version.
16:44:05 <byorgey> mreh: DrSyzygy taught an undergrad course on CT in Haskell this past semester, IIRC
16:44:10 <Saizan> danharaj: well just add type directed oveloading to your object language :P
16:44:39 <mreh> byorgey: where does he teach?
16:44:47 <danharaj> Saizan: :p
16:45:49 <danharaj> huzzah, it compiled. One of the complaints was the monomorphism restriction as well! That is exciting. My first.
16:46:25 <byorgey> mreh: Stanford
16:46:35 <byorgey> mreh: I'm trying to find you a link to his lecture notes
16:47:48 <ddarius> danharaj: Beginners often run into the monomorphism restriction, so that's not particularly notable.
16:48:01 <danharaj> ddarius: :|
16:48:25 <byorgey> mreh: http://haskell.org/haskellwiki/User:Michiexile/MATH198
16:54:25 <Kaidelong> so before I give a bad example:
16:54:48 <Kaidelong> getting code written in haskell to work on a PS3 would be as simple as having GHC produce high level C as its output, then compiling it for the PS3?
16:55:03 <Kaidelong> (trying to think of examples where parallelism may be useful in practice)
16:55:24 <Draconx> Kaidelong, you'll also need to port the RTS, I think.
16:55:24 <ddarius> Kaidelong: No.
16:56:04 <Kaidelong> okay, well, then using it for a "cluster of playstation 3s abstracted as one highly parallel machine" is not a practical example?
16:56:25 <Kaidelong> I'm trying to justify why someone would want to learn how to do parallel programming in haskell
16:56:27 <mreh> parallelism only makes sense if you have several cores
16:56:32 <Kaidelong> turned out to be harder than I thought
16:56:58 <mreh> parallelism in haskell is as simple as annotating the program with `par` and `seq`
16:57:04 <Kaidelong> mreh:  it really only makes sense if you have lots of cores, because on a multi-tasking system the other cores are still useful even if your program itself is not parallel
16:57:30 <Kaidelong> so I'm trying to think of it in the context of distributed machines
16:57:44 <Kaidelong> where the distributed setup is abstracted away from applications themselves
16:58:16 <Kaidelong> i guess I could argue that
16:58:20 <mreh> so you only need to learn parallelism in haskel;
16:58:22 <Kaidelong> "it is so simple to do it, why not?"
16:58:43 <Kaidelong> mreh: I'm just thinking whether you could get your haskell program ported to such a platform
16:59:01 <Kaidelong> doesn't help that you could write a really parallel program in haskell if it doesn't work on your beowulf cluster of PS3s
16:59:24 <Kaidelong> so it'll be a poor suggestion/analogy/example
16:59:26 <mreh> oh
17:00:02 <mreh> uh, use a distributed OS and port the RTS
17:00:30 <Kaidelong> hmm
17:00:32 <mreh> hmm, not sure what I'm talking about really
17:00:39 <Kaidelong> GHC can dump high level C code, right?
17:00:49 <Kaidelong> I am presuming that is more portable than compiling to native code
17:00:58 <mreh> it can
17:01:00 <Kaidelong> err, emit not dump
17:01:08 <dmwit> "it really only makes sense if you have lots of cores, because on a multi-tasking system the other cores are still useful even if your program itself is not parallel" <- I find this argument unconvincing
17:01:18 <dmwit> The majority of the time, it is *not* true that only one core is idle.
17:01:31 <dmwit> So if your program itself is parallel, then you win the majority of the time.
17:01:38 <aavogt> Kaidelong: it's also quite a bit slower
17:01:43 <mreh> idleness isn't a binary value either
17:02:17 <Kaidelong> aavogt: presumably your application will be parallel enough for an overall performance gain
17:02:20 <aavogt> unregisterized builds of ghc supposedly produce code that is half as fast
17:02:30 <mreh> the RTS just evaluates "sparks" as soon as it can wherever it can
17:02:56 <Kaidelong> if you're running on 35 cores rather than 4
17:03:02 <Kaidelong> that would be the rationale
17:03:32 * Kaidelong is thinking the best thing to do would be to just handwave it?
17:03:45 <Kaidelong> "it's easy to do and it is useful, if not always immensely so?"
17:03:58 <Kaidelong> "and the cost of parallel annotations in Haskell is small"
17:04:09 <Kaidelong> that sort of argument?
17:05:16 <aavogt> if it's already non-trivial to annotate a piece of code to execute in parallel on a single machine, I suspect the situation would be worse if you implicitly split work between more distant cores
17:05:21 <mreh> the cost is low, suck it and see
17:05:56 <Kaidelong> aavogt: IIRC par is just turned into seq on non parallel machines?
17:06:23 <Kaidelong> so you don't lose anything if you don't tell haskell -mthreads
17:06:36 <aavogt> um, you're probably thinking about  (flip const)
17:06:54 <aavogt> I'm pretty sure     undefined `par` 5   isn't undefined
17:06:55 <Kaidelong> @src par
17:06:56 <lambdabot> Source not found.
17:07:16 <Kaidelong> > undefined `par` 5
17:07:17 <lambdabot>   5
17:07:20 <Kaidelong> huhm
17:07:51 <aavogt> so you wouldn't replace it with something that forces the evaluation of the first argument
17:08:12 <Kaidelong> I was thinking of pseq
17:08:32 <Kaidelong> on hugs it becomes seq
17:08:38 <Kaidelong> completely unrelated
17:10:57 <Kaidelong> looks like par is not free even with mthreads
17:11:00 <Kaidelong> err, without
17:11:58 <Kaidelong> I guess I will handwave it
17:13:35 <Kaidelong> "-threaded"
17:13:52 <Berengal> I'd present it as "Why learn parallel programming with Haskell vs. learning parallel programming with another language"
17:14:28 <danharaj> My favorite part of Haskell is that I feel like I'm doing math when I program. I am a math major and I really enjoy doing math problems and learning new theory.
17:14:34 <Kaidelong> Berengal: that'd be very, very ambitious
17:14:43 <Kaidelong> because I'd have to present alternatives to haskell
17:15:15 <Berengal> Kaidelong: Can't you just pretend they've already tried parallel C or something?
17:15:42 <Kaidelong> Berengal: I don't really want to make a fool of myself in public, I'm still a novice
17:15:50 <danharaj> Kaidelong: Generic examples of code with race conditions, deadlocks, memory corruption, are probably easy to come up with.
17:16:24 <Kaidelong> danharaj: I'm purely focused on the deterministic kind here. I'm not going to be covering race conditions or locks or transactional memory
17:16:41 <Kaidelong> that's where threads need to communicate with each other
17:16:58 <Berengal> Kaidelong: But non-determinism and locking is exactly what you have when doing parallel C
17:17:05 <Berengal> And what you don't have in Haskell
17:17:30 <Kaidelong> Berengal: Well haskell does have facilities for this with mutable variables with locks, I'm not covering that, though
17:17:36 <Berengal> Haskell's parallelism is deterministic, and that's the largest benefit in my mind.
17:17:40 <Kaidelong> I guess what I'm focusing on is parallel evaluation of pure code
17:18:11 <Kaidelong> Berengal: I read a good paper in a recent SIGPLAN posting on non-deterministic parallelism in haskell
17:18:21 <Kaidelong> haskell does support it using various methods
17:18:49 <Berengal> Kaidelong: Yes, it does support concurrency, but you don't have to use concurrency to get parallelism. You do in other languages
17:18:54 <kmc> GHC Haskell has separate features for parallel evaluation and for concurrent execution
17:19:10 <kmc> in most languages you are required to use concurrent execution to do parallel evaluation
17:19:14 <Kaidelong> Berengal: F# has deterministic parallelism in some data structures
17:19:30 <kmc> which is a shame because concurrent execution is much harder to get right than parallelizing a pure deterministic computation
17:19:31 <Kaidelong> provided that you don't do anything naughty with the contents of those data structures
17:20:12 <Berengal> Kaidelong: Right, that would be the second benefit of Haskell: You can't do anything naughty :)
17:20:15 <kmc> many languages and libraries provide particular functions and data structures that use pure parallelism
17:20:37 <kmc> often by wrapping concurrency behind the scenes
17:20:47 <Kaidelong> Berengal: you can, but it's hard (unsafePerformIO and friends). F# also makes it hard, but not as hard as haskell.
17:20:59 <kmc> it's not hard to use unsafePerformIO.  it's just really obvious
17:21:03 <Kaidelong> well true
17:21:08 <Kaidelong> It's not "hard" just
17:21:12 <kmc> sometimes I wish that Haskell actually had a type-level separation between pure and impure functions
17:21:13 <Kaidelong> "explicit"
17:21:19 <kmc> it'd be nice to track down uses of unsafePerformIO
17:21:41 <Kaidelong> kmc: how much do people use it anyway? I've never personally found a need for it
17:21:51 <Kaidelong> I imagine if people want to make their own versions of the IO monad?
17:22:07 <Berengal> I've never used unsafePerformIO except for hillarity and pranks...
17:22:16 <kmc> Kaidelong, debug tracing is one example
17:22:20 <kmc> i.e. Debug.Trace
17:22:26 <Berengal> (Never used trace either)
17:22:29 <kmc> global IORefs and such
17:22:41 <kmc> fancy datastructures with a pure interface, i.e. ByteString
17:22:53 <Kaidelong> why would you need global variables in haskell?
17:23:08 <kmc> wrapping pure C functions that need marshalling
17:23:08 <Kaidelong> you can just have a left arrow in your main IO monad to much the same effect?
17:23:11 <Berengal> Kaidelong: putStrLn, for example, uses a global variable (stdout)
17:23:16 <Kaidelong> oh
17:23:25 <kmc> well, global variables in Haskell are easy
17:23:29 <kmc> global mutable cells, not as easy
17:23:33 * Kaidelong would have thought of stdout as more of a function a -> ()
17:23:39 <DigitalKiwi> what is the Ln for in putStrLn?
17:23:42 <Kaidelong> or a -> IO ()
17:23:52 <kmc> DigitalKiwi, line
17:23:55 <arw> DigitalKiwi: newline at the end.
17:24:00 <DigitalKiwi> oh
17:24:03 <Kaidelong> that way you could pipe to stdout
17:24:11 <DigitalKiwi> thanks
17:24:16 <Berengal> Kaidelong: No, it's just a Handle
17:24:31 <Berengal> Actually, stdout might be defined as a pure value...
17:24:35 <Kaidelong> Berengal: I suppose there are situations where STDOUT can actually change at runtime?
17:24:38 <kmc> i would think so
17:24:46 <kmc> in C on UNIX it's basically a constant 1
17:24:57 <kmc> there are situations where which file is connected to stdout can change
17:25:13 <kmc> in C on UNIX the name "stdout" always refers to file descriptor 1, whatever is open there
17:25:18 <Berengal> Ah, but you can change the buffering of stdout
17:25:22 <danharaj> In my language I have (? :) as an operator. Instead of writing in a ternary operator, I made each of ? and : binary operations, do you think that was a sound decision?
17:25:22 <Berengal> Or more commonly, stdin
17:25:24 <Kaidelong> still, couldn't STDOUT live inside a monad?
17:25:27 <arw> careful. the file deskriptor no 1 is always stdout. but you can close, reopen, dup that file descriptor.
17:25:29 <Berengal> So there has to be some reference there somewhere
17:25:31 <Kaidelong> a monad that contains your program
17:25:32 <kmc> danharaj, is this embedded in Haskell?
17:25:45 <danharaj> kmc: Yeah
17:26:20 <lodi> hi everyone... anybody know the significance of "hs_add_root(__stginit_Foo);" when creating a haskell dll?  I'm having trouble linking if I include that line and it seems to work without it anyway
17:26:25 <Kaidelong> so instead of main being of type IO it's of type Program which is derived from IO
17:26:57 <Kaidelong> and a Program has a notion of things like STDOUT
17:27:13 <Kaidelong> and contains your "global scope"
17:27:40 <Kaidelong> I'd think that'd be a better way to do it
17:28:10 <Berengal> Kaidelong: That's what I do anyway. If I have global variables, I put them in a ReaderT over IO. Makes configuration much easier as well
17:28:22 <lodi> (ghc 6.12.1)
17:28:27 * Kaidelong just wondering why it is not the default to begin with
17:29:13 <Berengal> Probably because IO is "purely" IO, not any of this reader business
17:29:22 <Kaidelong> "global mutable variables" does not suggest to me that someone should have used unsafePerformIO =)
17:29:38 <Kaidelong> it suggests to me that the code was badly designed
17:29:57 <Kaidelong> poorly
17:30:30 <Berengal> I can see some real reasons for using unsafePerformIO...
17:30:48 <Berengal> Interfacing with the parts of the real world that aren't described in the language report, mainly
17:30:58 <Kaidelong> Berengal: i wasn't disputing that there may be some real reasons, I just don't know why "global mutable variables" should count
17:31:05 <Berengal> It shouldn't
17:31:22 <danharaj> If a function has polymorphic arguments, I can't wrap it in an existential under any circumstances?
17:31:54 <danharaj> oh wait..
17:31:56 <Berengal> danharaj: How do you mean?
17:32:06 <Veinor> Someone give me a math-related name or word that starts with H.
17:32:13 <danharaj> Homomorphism
17:32:19 <Veinor> Too long.
17:32:26 <kmc> hilbert
17:32:27 <arw> Hom-Functor
17:32:28 <danharaj> Hom-set
17:32:37 <Berengal> Homomorphism
17:32:37 <Veinor> I like Hom-set.
17:32:38 <kmc> to interact with new parts of the real world, you'd just make a new primitive IO action
17:32:49 <zachk> homoSetual?
17:33:27 <kmc> Berengal, the least controversial use of uPIO is for FFI
17:33:31 <Kaidelong> kmc: I was suggesting that early, roll your own IO monads
17:33:35 <Kaidelong> earlier even
17:33:41 <tensorpudding> Homology
17:33:46 <Berengal> kmc: Doesn't FFI basically have uPIO built-in?
17:34:05 <kmc> Berengal, the function unsafePerformIO is specified in the FFI addendum
17:34:07 <pikhq> Berengal: The FFI extension is where uPIO comes from.
17:34:21 <danharaj> Berengal: AOp2 = forall a b c. (Typeable a, Typeable b, Typeable c)  => AOp2 (a -> b -> c) ; ; cBranch :: (LesTypeable a) => Bool -> (Bool -> a) ;; I cannot wrap cBranch in AOp2
17:34:24 <kmc> Berengal, you can import a C function as pure, in which case you don't need uPIO
17:34:28 <danharaj> Typeable*
17:34:35 <Berengal> But do you even need it? Can't you just specify the type as being pure?
17:34:38 <kmc> Berengal, where you need it is if your Haskell-side marshalling code needs to do something nontrivial
17:34:45 <kmc> i.e. peek, poke, alloca
17:34:53 <Berengal> Ah, of course. Non-trivial structures
17:34:57 <kmc> but you can guarantee that the combination of C code and marshalling is pure
17:35:15 <kmc> it is best to think of uPIO as an alternative to extending the language implementation
17:35:35 <Berengal> Indeed, that's what I do. A back-door into the runtime
17:35:38 <kmc> in fact in GHC there is a simple correspondence; if you import the right module, IO is no longer an abstract type, you can pattern-match it, and implement unsafePerformIO yourself trivially
17:35:44 <danharaj> So ghc wants me to fix a in the type signature of cBranch. If I do this, I have to make an instance of the function for each variable I want to branch with.
17:35:52 <kmc> danharaj, hpaste?
17:36:00 <danharaj> kmc: look up
17:36:13 <danharaj> (except I misspelled Typeable in the second signature)
17:36:35 <kmc> danharaj, looks incomplete plus the formatting is hard to read
17:36:49 <danharaj> kmc: Ok, ok, but only for you ;)
17:36:55 <kmc> thank you danharaj
17:37:49 <Berengal> If there were some safe way of doing peeking, poking and alloc in ST, unsafePerformIO would become even less useful
17:39:19 <kmc> Berengal, that's an interesting idea
17:39:48 <kmc> you could use something like (STPtr s a) instead of (Ptr a)
17:40:10 <kmc> but you'd also need bounds-checking and zeroing of allocated memory
17:40:14 <kmc> in order to ensure determinism
17:40:37 <Berengal> Indeed...
17:40:49 <Berengal> Might be worth an experiment
17:41:01 <Kaidelong> kmc: from what I understand, that won't be terribly hard to do
17:41:02 <danharaj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25570
17:41:16 <kmc> the Haskell code has no reason to believe the C function is giving it a legit pointer
17:41:22 <kmc> C functions frequently lie ;)
17:41:29 <danharaj> I know that giving the functions monomorphic signatures would fix the problem, I'm just wondering if I can keep the polymorphism.
17:41:57 <kmc> danharaj, Typeable can only represent monomorphic types
17:42:03 <danharaj> :\
17:42:03 <kmc> in fact all type class instances are monomorphic
17:42:14 <kmc> to my knowledge
17:42:29 <danharaj> Even though the polymorphic type can only be instantiated by a Typeable monomorphic type?
17:42:36 <danharaj> (correct my terminology where it is incorrect)
17:42:42 <kmc> yeah
17:43:00 <danharaj> Is this not a feasible extension?
17:43:01 <kmc> is what you're doing something like exposing functions to an interpreter?
17:43:09 <danharaj> kmc: Yes, precisely.
17:43:23 <kmc> danharaj, i'm not sure if anyone's considered allowing polymorphic types to be type class instances
17:43:31 <kmc> it's probably a big can of worms
17:43:55 <danharaj> Probably.
17:44:05 <danharaj> If anyone has a definite answer, it would be much appreciated.
17:44:24 <danharaj> kmc: The GHC guys have done some pretty remarkable things. I'm surprised my code even type checks.
17:44:28 <danharaj> (Other than the current errors)
17:45:15 <Berengal> Indeed, <3 Haskell's type system
17:45:26 <kmc> i won't go that far
17:45:30 <kmc> <2 GHC Haskell's type system
17:45:39 <kmc> in that it's cool and powerful
17:45:48 <kmc> but would be both more powerful and simpler if it had dependent types
17:45:56 <Berengal> \forall n : Nat -> n < 2 -> n < 3
17:46:02 <Kaidelong> kmc: there is an option for that, isn't there?
17:46:07 <kmc> heh
17:46:10 <kmc> no
17:46:14 <Kaidelong> ah
17:46:16 <kmc> the option is to use Agda and make FFI calls to Haskell
17:46:32 * Kaidelong doesn't know if that really sounds better
17:46:42 <kmc> see Agda uses Haskell as the practical language for impure, low-level stuff
17:46:51 <Berengal> I love the idea of a language which idea of FFI interface is Haskell..
17:47:03 <pastorn> there are some new languages that has haskell syntax + dependent types
17:47:18 <kmc> pastorn, cool.  any other than Agda?
17:47:18 <pastorn> thus making them non-agda-y
17:47:35 <pastorn> yes... i stumbled upon two or three the other day... hang on
17:47:39 <Berengal> I thought Agda had very much Haskell syntax...
17:47:40 <kmc> how is that non-agda-y?
17:47:42 <Berengal> Except better
17:47:54 <pastorn> kmc: you have monads
17:48:02 <pastorn> (i think)
17:48:05 <pastorn> hang on...
17:48:54 <Berengal> Yeah, that was one thing I was missing from Agda's otherwise awesome syntax; the ability to define syntax that bound variables
17:49:01 <Berengal> (Haskell too suffers from this)
17:49:01 <kmc> yeah
17:49:14 <kmc> it's pretty hard to extend the concrete syntax of Haskell at all
17:49:20 <kmc> even TH can't really do it
17:49:28 <kmc> unless you do something laborious with quasi-quotes
17:49:28 <Berengal> Lambdas are often a cheap way out though...
17:49:56 <Berengal> I think simplifying Haskell's syntax might be a good idea
17:50:13 <Berengal> Homoiconicity, for example, would be nifty
17:50:19 <DigitalKiwi> haskell with C functions vs lua with C functions, go!
17:51:06 <jmcarthur> ?
17:51:23 <kmc> yes, having a good higher-order language makes true metaprogramming less necessary
17:51:25 <ville> Any particular advantage for one syntax over the other in to the "let .. in" syntax vs the "where" syntax for local variables?
17:51:33 <ville> s/to//
17:51:54 <DigitalKiwi> which has the better ffi/api
17:52:41 <pastorn> kmc, Berengal: http://www.cs.st-andrews.ac.uk/~eb/Idris/
17:53:29 <Berengal> pastorn: Neat
17:53:35 <danharaj> darn, for `instance Typeable (forall a. (Typeable a) => Bool -> a)' GHC just tells me it's illegal without saying there's an extension. There must not be one :\
17:53:45 <Berengal> The world needs more practical dependently typed languages
17:53:57 <Berengal> Well, s/more//
17:53:57 <kmc> pastorn, awesome, thanks
17:54:16 <pastorn> yeah, it seems pretty swell :)
17:54:32 <kmc> Haskell was created as a response to a fragmented research world of many different experimental lazy languages
17:54:41 <kmc> I wonder if the same thing will happen for dependently-typed programming languages
17:55:57 <Berengal> Dependently-typed languages have two different uses though; theorem assitants/provers and actual programming languages
17:56:13 <danharaj> Dependent types would make reflection very simple, right?
17:56:14 <kmc> yeah
17:56:21 <kmc> (to Berengal)
17:56:27 <pastorn> > 49 * 49
17:56:28 <lambdabot>   2401
17:56:28 <Philippa> ville: no, it's basically a question of top-down vs bottom-up presentation
17:56:32 <kmc> and the real utility is in having both together
17:56:53 <Berengal> Indeed, but the two groups have different needs and ideas about what a good language is.
17:56:59 <ville> Philippa: ok so syntactic sugar.
17:57:35 <kmc> ville, "while" attaches to a function equation rather than an expression
17:57:40 <Philippa> Berengal: I'm not entirely convinced that's the case. Consider something like Idris?
17:57:45 <kmc> that means it can scope over the RHS of multiple guards for the same equation
17:58:08 <Philippa> though there are definitely differing implementation priorities
17:58:11 <ville> kmc: Not that far yet into Haskell, do you have a simple example?
17:58:23 <kmc> i think the point of using DT is largely to combine these uses
17:58:28 <kmc> i.e. write code and prove things about it
17:58:41 * hackagebot constructive-algebra 0.1.2 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1.2 (AndersMortberg)
17:58:59 <kmc> but what i meant by "dependently-typed programming languages" are the ones that make it a priority to make real programming feasible
17:59:05 <kmc> Agda has this as a goal
17:59:09 <kmc> moreso than Coq
17:59:32 <danharaj> Agda uses unicode syntax though :\
17:59:36 <Berengal> Philippa: A real programming language needs to handle programming in the large well, but theorem provers deal with small, isolated programs (possibly in large numbers, but largely independent, or with straightforward dependencies)
17:59:40 <kmc> i love Agda's syntax
17:59:49 <kmc> but you need fancy editor support
17:59:59 <danharaj> Agda should use latex
17:59:59 <kmc> danharaj, with DT types are first-class values, but they're not necessarily algebraic data, can't be pattern-matched, etc.  so it doesn't necessarily make reflection easy
18:00:11 <kmc> however, you can do something equivalent to the following Haskell:
18:00:15 <tensorpudding> Agda could be Literate
18:00:24 <tensorpudding> AgdTeX
18:00:27 <kmc> data T = TInt | TChar | ...
18:00:30 <kmc> getType :: T -> Type
18:00:33 <kmc> getType TInt = Int
18:00:36 <kmc> getType TChar = Char
18:00:49 <Berengal> Philippa: At least that's my view on things. I might be wrong, and it might not be impossible to combine both of these into a single language, but at least until DT gets going for real there's going to be two different groups focusing on different aspects
18:00:55 <Philippa> Berengal: I'm not entirely convinced - I've seen proposals for ML-flavour module systems in theorem provers, for example
18:00:57 <kmc> then you could say e.g:   'x' :: getType TChar
18:01:09 <kmc> and your T type is ordinary algebraic data
18:01:21 <kmc> ville, sec
18:01:32 <Philippa> but yeah. I think it's a combination of funding and early days that keeps things being worked on from either side. Idris is a good sign though
18:01:39 <ville> kmc: no hurry
18:02:11 <gwern> whatever happened to gradual typing, I wonder...
18:03:05 <Berengal> Philippa: Indeed. When funding gets going, it's possible we'll start to see a more unified design.
18:03:18 <dolio> gwern: It's disappointing.
18:03:43 <gwern> ln pls
18:03:46 <Berengal> I really miss Agda's syntax :(
18:03:59 <Berengal> But even more, I miss Agda's emacs mode
18:04:03 <kmc> ville, http://codepad.org/flwP1fRn
18:04:08 <DigitalKiwi> bah! emacs
18:04:26 <dolio> gwern: Not in any formal sense.
18:04:43 <DigitalKiwi> i want to use vim as my editor for the emacs os
18:04:46 <DigitalKiwi> is this possible?
18:05:01 <Berengal> agda-mode is the best way to program I've ever tried.
18:05:11 <gwern> DigitalKiwi: viper?
18:05:18 <gwern> dolio: more specific?
18:05:27 <dolio> I just think it's more satisfying to think about "how can we make these fancy types easy to use" than "how can we allow people to escape the type system when it becomes too cumbersome?"
18:05:44 <ville> kmc: Ok I am not sure how that shows something about "while".
18:06:14 <gwern> dolio: oh, so you don't actually know anything about the recent quiet
18:06:14 <kmc> ville, try to rewrite it using "let"
18:06:25 <gwern> (it seemed like in 2008 and 2009 there were a lot more papers on gradual typing)
18:06:26 <dolio> No.
18:06:28 <kmc> err
18:06:28 <ville> Perhaps you meant to say "where" when you typed "while" few moments ago.
18:06:32 <kmc> ville, right
18:06:35 <kmc> sorry
18:06:39 <Berengal> What is gradual typing?
18:06:41 <kmc> wasn't your original question about let vs. where?
18:06:42 <dolio> Were there a lot? There was Wadler.
18:06:49 <ville> kmc: Yes
18:06:52 <dolio> And something related to PLT, probably?
18:06:52 <kmc> ah
18:06:59 <Berengal> This "escaping the type system" reminds me of Groovy... sort of
18:07:24 <dolio> Wadler writes about everything, though, so it wouldn't surprise me if he's moved on to something else.
18:07:52 <gwern> Berengal: my understanding is a compiler/typechecker that will insert type coercions/checks to make a program statically check; the more static you write it, the fewer checks need to be inserted
18:07:53 <ville> kmc: So I would have to repeat the msg function if I did it with let-in construct?
18:08:00 <kmc> ville, i think so
18:08:17 <kmc> the syntax of let is "let <equations> in <expression>"
18:08:23 <kmc> and the whole thing is itself an expression
18:08:26 <Berengal> gwern: Sounds a bit like Groovy then.
18:08:31 <kmc> the syntax of where is "<equation> where <equations>"
18:08:33 * gwern dunno what groovy does
18:08:42 <kmc> and the whole thing is attached to the equation
18:08:48 <Berengal> It's java with optional dynamic typing (and closures, but that's unrelated)
18:09:06 <kmc> any good statically-typed language has optional dynamic typing
18:09:13 <gwern> heck we have optional dynamics
18:09:21 <kmc> but also, a lot of people use dynamic types when they should be using sum types
18:09:30 <dolio> Berengal: As I recall, Wadler's work was on mixing a statically typed language with one that isn't, and if you get a runtime type error, you "blame" the portion of the program without static types.
18:09:38 <kmc> a lot of the supposed flexibility of dynamic types is from using the type system itself as a single global ad-hoc sum type
18:09:57 <Berengal> dolio: I think I might recall something about that some time ago...
18:10:08 <gwern> Berengal: some time ago <- exactly
18:10:26 <Berengal> Wasn't it some dutch student working on something like that?
18:10:41 <arw> kmc: ack. and a lot of the uglyness is the necessary decomposition of that global sum type.
18:10:52 <dolio> @google Well-typed-programs-can't-be-blamed
18:10:54 <lambdabot> http://www.eecs.northwestern.edu/~robby/pubs/papers/scheme2007-wf.pdf
18:10:54 <lambdabot> Title: Well-typed programs cant be blamed
18:11:28 <tensorpudding> Type system doesn't do what you want? Coersion is a powerful tool.
18:11:39 <kmc> haha
18:11:50 <wli> Maybe extensible sums would help such use cases?
18:12:01 <tensorpudding> "i'm going to make him an assertion he can't refute"
18:12:46 * hackagebot rangemin 2.1.0 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.0 (LouisWasserman)
18:13:08 <gwern> 'it is difficult to prove an type mismatch to a man when his program depends on him not understanding it.'
18:13:22 <Berengal> Heh
18:13:47 <Berengal> Some things are inherently dynamically typed, but often their metastructure is static...
18:14:29 <kmc> some things inherently use sum types
18:14:42 <kmc> such as interpreters for dynamically-typed languages
18:15:17 <Berengal> If you want dynamic typing in Haskell, you could just use maps from strings to (strings + maps) and some combinators
18:15:19 <dolio> I suppose you can argue Y is like that, although you can type it with the right system.
18:15:25 <tensorpudding> is there any strong benefits for dynamic typing?
18:15:46 <Berengal> tensorpudding: It's less work if you guess right the first time.
18:15:47 <tensorpudding> besides that some things are a lot less verbose
18:15:58 <kmc> tensorpudding, yeah.  these type errors sure are annoying, why can't the computer just do what i tell it to?
18:16:19 <kmc> ;)
18:16:31 <Berengal> Sometimes, when interfacing with something the language doesn't understand, dynamic typing is neat
18:16:42 <kmc> one benefit for dynamic typing is that latent bugs in your program might not be discovered until after you quit your job
18:16:46 <kmc> so you don't need to fix them
18:16:52 <Berengal> For example, mapping sql rows to objects is trivial in a dynamic langauge
18:17:38 <Berengal> In a static language you need to describe the structure once more in a way it understands
18:19:35 <Berengal> (And that extra definition doesn't help anything. When the DB structure changes you're going to get runtime errors, not compile-time ones)
18:20:29 <jmcarthur> bah, instance Foo Rational requires TypeSynonymInstances but not FlexibleInstances. does the former imply the latter or something?
18:20:58 <jmcarthur> or is it just haskell98 weirdness somehow?
18:21:21 <jmcarthur> like the special treatment of String?
18:21:28 <dolio> TypeSynonymInstances isn't H98.
18:21:32 <jmcarthur> right
18:21:42 <dolio> Maybe it does the H98 check before expanding the synonym.
18:21:53 <jmcarthur> but Ratio Integer has instances defined for it
18:21:59 <jmcarthur> wouldn't that require FlexibleInstances?
18:22:11 <dolio> It should, if they're specifically stated like that.
18:22:20 <jmcarthur> base has it
18:22:28 <jmcarthur> does haskell98 not?
18:22:42 <dolio> What instance?
18:22:50 <jmcarthur> h/o
18:23:04 <jmcarthur> oh nevermind
18:23:15 <jmcarthur> it's not Ratio Integer, it's Integral a => Ratio a
18:23:17 <jmcarthur> so it's fine
18:24:03 <gwern> @quote lolli
18:24:03 <lambdabot> No quotes match. I've seen penguins that can type better than that.
18:24:09 <gwern> @remember AlanPerlis 93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18:24:10 <lambdabot> It is stored.
18:24:17 <gwern> @quote lolli
18:24:17 <lambdabot> AlanPerlis says: 93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18:24:20 <gwern> @flish
18:24:39 <dolio> I was expecting a quote about Lolli.
18:25:06 <gwern> dolio: you mean 'loli'
18:25:08 <gwern> 1 l
18:26:11 <dolio> gwern: I mean lolli, the linear logic programming language.
18:26:54 <gwern> dolio: no, you mean loli, a minimal web DSL in Haskell: http://hackage.haskell.org/package/loli
18:27:54 <dolio> Wow, I didn't even know I meant that.
18:28:07 <gwern> aren't you glad I am here to make you clear to yourself?
18:28:17 <dolio> Indubitably.
18:28:28 <tensorpudding> Lolli is short for lollipop.
18:28:42 <dolio> -o
18:30:39 <dolio> 
18:31:21 <kmc> ^_^
18:31:31 <dolio> Took me a while to get that.
18:31:46 <dolio> Apparently the only way to type that in agda-mode is \multimap.
18:40:48 <danharaj> ok
18:40:53 <danharaj> Am I surprised that my interpreter works?
18:40:58 <danharaj> No, because
18:40:59 <danharaj> THIS.
18:41:00 <danharaj> IS.
18:41:02 <danharaj> HASKELL.
18:42:01 * gwern is pleased to see hray in action - http://blog.llvm.org/2010/05/glasgow-haskell-compiler-and-llvm.html - I cabalized and uploaded that, y'know
18:45:03 <kmc> danharaj, how did you end up wrapping the functions?
18:45:04 <blackdog> danharaj: all haskell programmers have beards, capes, and fantastic abs.
18:45:26 <blackdog> i'm killing a persian as we speak
18:46:33 <danharaj> kmc: I just made it monomorphic for now. I'll figure out how to do polymorphic functions at a much later date. After I start implementing T&PL in Haskell. :D
18:46:38 <kmc> haha
18:46:59 <danharaj> kmc: I have a feeling I might not be able to reify polymorphic types.
18:47:05 <kmc> yeah, i think you can't
18:47:35 <danharaj> Actually... is there a way to coerce a polymorphic function to a monomorphic one at run-time?
18:47:56 <kmc> that doesn't make much sense
18:48:05 <kmc> since types are mostly a compile-time phenomenon in Haskell
18:48:09 <gwern> right now, I'm killing a persian... cat
18:48:14 <kmc> gwern, :(
18:48:24 <gwern> ifyouknowwhatimean
18:50:00 <danharaj> kmc: Yeah, I guess. I could maybe use a function that takes an existential...?
18:52:33 <danharaj> Anywho, I have line interpretation working. Now I have to add variables and their assignment.
18:52:49 <kmc> danharaj, what sort of language are you interpreting?
18:53:18 <danharaj> kmc: Highly imperative, ugly and disgusting. I am doing it to show my friend that Haskell is better than C for this sort of project :D
18:53:23 <kmc> haha
18:53:32 <kmc> did you design the language?
18:53:49 <danharaj> kmc: No, he did. Any language I design would be pure :p
18:54:06 <kmc> what do you mean by "pure"
18:54:11 <kmc> "not confusing evaluation with execution"?
18:54:18 <danharaj> No mutable data
18:54:22 <kmc> ah
18:54:29 <jmcarthur> actually i like kmc's definition
18:54:33 <kmc> Haskell has lots of mutable data
18:54:46 <kmc> there's like half a dozen mutable reference cell types in the standard library
18:55:05 <Berengal> And lazy evaluation also means mutating data like crazy
18:55:06 <danharaj> Yeah, I would try to avoid that. I would like to try to implement IO with FRP, actually.
18:55:10 <Berengal> But with nice guarantees
18:55:11 <kmc> danharaj, :O
18:55:36 <jmcarthur> Berengal: that's an operational detail ;)
18:55:38 <danharaj> What's so surprising kmc? :o
18:56:05 <kmc> isn't FRP still experimental as hell?
18:56:07 <applicative> Berengal, but my thoughts are pure.
18:56:10 <jmcarthur> i'm not sure if all IO can be expressed in FRP style
18:56:16 <danharaj> kmc: Exactly. I would like to contribute to that research.
18:56:18 <jmcarthur> i'm also not sure whether i even want that
18:56:20 <Berengal> jmcarthur: Depends on which level you're on (and sometimes you have to go to machine code level or below)
18:56:21 <kmc> ah, cool :)
18:56:31 * jmcarthur is writing an FRP library as we speak
18:56:35 <jmcarthur> a new one!
18:56:38 <pastorn> kmc: yes, Mr Elliot is still struggling :/
18:56:43 <danharaj> kmc: I forget, were you the one who linked me to the blog post of a guy implementing a compiler for a toy language?
18:57:09 <kmc> danharaj, think so
18:57:10 <jmcarthur> it's okay, i solved it  <_<  o_o  >_>  o_o
18:57:36 <applicative> jmcarthur, is that the principal operator in your library, <_< o_o >_> o_o
18:57:42 <danharaj> kmc: Thanks for that. It gave me the right ideas. Also I guess I could eventually try to compile to LLVM!
18:57:43 <pastorn> jmcarthur: is that a bunch of japanes smileys?
18:57:45 <jmcarthur> it should be, but sadly it is not
18:57:47 <conal> pastorn: two "t"s in "Elliott", please.  (spelling is contagious)
18:58:01 <pastorn> conal: haha... there you are :)
18:58:01 <jmcarthur> conal: heh, i was about to correct pastorn for you ;)
18:58:23 <conal> jmcarthur: thx!
18:58:34 <pastorn> conal: you almost never say anything so i didn't want to disturb :/
18:58:44 <conal> :)
18:58:44 <pastorn> (highlighting and all that)
18:58:59 <conal> i'm working on speeding up glsl code
18:59:03 <danharaj> I have quite a few projects lined up in Haskell for this summer. We'll see how long it takes before I say "Fuck it" and go play video games.
18:59:19 <pastorn> conal: ehm... what are you making?
18:59:28 <conal> ipad has 5x the pixels of iphone.  and i have a lot of per-pixel computation.
18:59:31 <jmcarthur> conal is making awesomeness
18:59:35 <conal> pastorn: graphics toys.
18:59:42 <conal> jmcarthur: :)
18:59:47 <pastorn> haha... useful toys?
19:00:04 <pastorn> danharaj: last summer was awesome! LOTS of Wipeout 3 got played...
19:00:17 <conal> i don't know.  we'll see.
19:01:23 <pastorn> conal: what version of glsl can you run on the iPad?
19:01:39 <conal> right now, i'm trying to figure out how  to get textures to quickly *not* repeat on opengl es
19:01:42 <danharaj> pastorn: If I don't get a fair bit of my projects done by Starcraft 2's release, they'll never get finished :D
19:01:45 <conal> pastorn: opengl es 2.0
19:02:39 <jmcarthur> i need a name for an FRP library
19:02:48 <jmcarthur> i'm literally about to start the project right now
19:02:52 <conal> last year it hit me that right now is an amazing opportunity for pure functional/denotative programming, given the available cheap crazy-fast GPU hardware.
19:03:04 <danharaj> jmcarthur: Please not another food
19:03:11 <jmcarthur> danharaj: those are the GUI libraries
19:03:14 <pastorn> jmcarthur: synonyms for reaction; GO!
19:03:16 <jmcarthur> i'm just doing the FRP
19:03:26 <conal> so i shifted my focus from frp to gpus.  will get back to frp eventually.
19:04:06 <jmcarthur> pastorn: http://thesaurus.com/browse/reactive  ...
19:04:19 <danharaj> jmcarthur: "This is not a FRP library"
19:04:30 <pastorn> "tinaf"
19:04:34 <conal> jmcarthur: how about something involving time.  rather than "reactive".  i really regret the whole focus on reactivity.
19:04:34 <jmcarthur> TINAFRPL
19:04:43 <pastorn> jmcarthur: tinfoil
19:04:45 <jmcarthur> pronounced "tina furple"
19:04:47 <jmcarthur> ha
19:04:55 <pastorn> then you just need to find good words for "oil"
19:05:14 <matt_m> Saizan:  Apparently the things I was looking for yesterday are called "Bohm-like trees"
19:05:17 <jmcarthur> conal: how about something having to do with integrals? that's where i'm focusing
19:05:24 <conal> jmcarthur: or something about continuity.
19:05:28 <jmcarthur> yeah
19:05:33 <conal> jmcarthur: ah.  hm.
19:05:56 <Draconx> jmcarthur, This Is Not a Functional Or Integral Library?
19:05:59 <danharaj> Call it Euler
19:06:11 <danharaj> But you have to make sure it's good, Euler's name is not to be sullied.
19:06:18 <jmcarthur> Euler can mean so many things though
19:06:39 <Draconx> tinfeuler?
19:07:09 <pastorn> Draconx: hehe... that's good :)
19:07:20 <jmcarthur> ha
19:07:56 <danharaj> Hell, just call it Tina
19:08:00 <danharaj> and never explain the name.
19:08:12 <jmcarthur> this is not a
19:08:15 <jmcarthur> err
19:08:20 <jmcarthur> see? it's not anything!
19:08:22 <danharaj> It's post-post-post-post-modern
19:08:55 <gwern> "Before the Eulers, Gausses and Newtons, we are worms, worms."
19:08:58 <jmcarthur> Tinara Is Not A Recursive Acronym
19:09:11 <alex404> So I'm trying to do some concurrency with FFI, and I '
19:09:15 <alex404> (oops)
19:09:51 <wli> What about the Laplaces, Lagranges, and Legendres? Not to mention the Cauchies?
19:10:02 <jmcarthur> conal: that's a good point about reactivity. perhaps FRP itself is a misleading label
19:10:16 <conal> jmcarthur: exactly. :(
19:10:26 <danharaj> Call it Continuum
19:10:31 <jmcarthur> Functional Continuous Programming
19:10:36 <jmcarthur> danharaj: i like that one
19:10:37 <conal> jmcarthur: so many people think they know what frp is, by interpreting that name.
19:10:58 <gwern> wli: you can rhetorically fit in only 3 names or fewer; would you really put in lagrange over netwon?
19:11:00 <alex404> So I'm trying to do some concurrency with FFI, and I'm trying to spawn a c thread which does a bunch of IO, which I might want to cancel with another c function. However, when I fork the first c function, and then cancel it with the other, I get a seg fault. When I try to kill the thread before running the function which clears it, killThread blocks until the first c function is done anyway.
19:11:02 <conal> jmcarthur: and they miss what's essentially important to me, namely denotative and continuous.
19:11:02 <alex404> Any ideas?
19:11:07 <jmcarthur> conal: honestly, i still don't know what FRP is
19:11:10 <jmcarthur> heh
19:11:12 <jmcarthur> DCP
19:11:24 <pastorn> conal: is there a nice little definition?
19:11:27 <jmcarthur> Denotative Continuous Programming
19:11:32 <gwern> jmcarthur: unfortunately, JM, no one can be *told* what FRP is.
19:11:42 <pastorn> i've only seen the example with
19:11:45 <conal> jmcarthur: yeah.  that.  and specifically for time.
19:11:53 <dolio> It's dataflow programming. :)
19:11:57 <jmcarthur> Denotation Continuous-Time Programming?
19:12:03 <jmcarthur> dolio: no it's not! :P
19:12:04 <conal> dolio: ack :(
19:12:04 <pastorn> type Shape = (Point -> Bool) -- inside or outside the shape
19:12:04 <wli> gwern: Probably not, no.
19:12:10 <jmcarthur> err
19:12:16 <jmcarthur> *Denotative Continuous-Time Programming
19:12:17 <danharaj> FRP: Haskell isn't a dump truck. You can't just throw everything into the IO monad. It's a series of tubes!
19:12:20 * Kaidelong does not know if passing around time or the world is neccessarily a good idea in terms of getting people to do it
19:12:27 <conal> "dataflow" has strongly operational connotations
19:12:52 <Kaidelong> dataflow programming also involves in place updates when implemented efficiently, doesn't it?
19:12:55 <jmcarthur> and i also tend to think of dataflow as having discretely changing queues or something
19:13:03 <jmcarthur> where "discretely" is the key word
19:13:10 <jmcarthur> that could just be association games though
19:13:10 <Olathe> Haskell is a series of lists.
19:13:43 <jmcarthur> Kaidelong: but do we care about in-place updates? that sounds like an implementation detail to me
19:13:44 <tensorpudding> haskell :: Sequence [a]
19:13:54 <jmcarthur> Kaidelong: we care a bit more about what it *means*, not how it works
19:14:05 <Kaidelong> jmcarthur: you still have to implement it
19:14:10 <jmcarthur> dataflow might describe a kind of implementation, i think, but not really what it is
19:14:19 <Kaidelong> and it means you may need a way to deal with race conditions
19:14:26 <jmcarthur> Kaidelong: true, but i'd rather implement a model than an implementation for its own sake :)
19:14:43 <applicative> alex404, I wish I could help.
19:15:41 <alex404> I can try to explain more what's going on, but I don't want to spam the channel ;)
19:15:56 <ManateeLazyCat> I'm looking the best exception package to handle error "/proc/8736/stat: hGetContents: does not exist", found http://hackage.haskell.org/package/explicit-exception , have better one?
19:16:08 <Kaidelong> the way I would do it is have a data structure called a data flow that allows its individual elements to be manipulated by some special function that adds changes to a queue
19:16:08 <ManateeLazyCat> s/looking/looking for
19:16:38 <edwardk> tensorpudding: haskell :: Seq [a] -- you even get a nice interface =)
19:16:46 <Kaidelong> of course, I've never tried to do this in haskell, so that may be a bad idea
19:16:48 <Olathe> @type put
19:16:50 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:16:56 <jmcarthur> conal: do you have a problem with "Denotative Continuous-Time Programming"? i might just start calling it that in an attempt to spread more accurate ideas about what it is
19:17:02 <conal> Kaidelong: i think jmcarthur is saying he wants to know precisely *what* he's implementing, not just *how*.
19:17:08 <tensorpudding> Is Seq Data.Seq?
19:17:09 <conal> jmcarthur: i like it!
19:17:24 <tensorpudding> Should use Edison!
19:17:30 <edwardk> Data.Sequence contains Seq, which is a bit confusing
19:17:30 <applicative> alex404, its probably best to paste a module on hpaste.  this sort of problem involves a lot of specialist knowledge, so you might need to find the right moment
19:17:43 <jmcarthur> okay, s/FRP/DCTP/ it is, then
19:17:48 <conal> jmcarthur: i want to revive landin's notion of "denotative".  so much more substantive/precise than "functional" or "pure".
19:17:54 <Olathe> @type runState
19:17:55 <lambdabot> forall s a. State s a -> s -> (a, s)
19:18:03 <conal> jmcarthur: so, please do spread the meme.
19:18:17 <Kaidelong> conal: that's really a good question, I suppose what you're implementing would be another language inside haskell for wiring together components that propagate state?
19:18:17 <jmcarthur> rock
19:18:28 <alex404> applicative: Thanks for the tip
19:18:59 <conal> Kaidelong: okay, that description is a start.  now to make it precise enough to define correctness of any possible implementation.
19:19:15 <edwardk> tensorpudding: Edison just feels like it is aging away
19:19:32 <conal> Kaidelong: shift more from operational ("wiring together", "propagate state") to denotative (from how to what).
19:19:43 <conal> from do to be
19:19:49 <Olathe> I'm trying to get the idea of how to use the State monad. You use a do block to essentially compose a function, and then outside the do block, elsewhere, you can call runState on it with a starting state value and have the function you composed run ?
19:20:06 <kmc> yeah bascally
19:20:06 <danharaj> conal: would a circuit diagram definition be appropriate as an analogy?
19:20:15 <Olathe> Alright, thanks :)
19:20:18 <kmc> Olathe, (State s a) is basically just a wrapper for (s -> (a, s))
19:20:21 <kmc> @unmtl State s a
19:20:21 <lambdabot> s -> (a, s)
19:20:31 <Kaidelong> conal: How about "it is a network of interacting stateful computations?"
19:20:32 <kmc> Olathe, so State is just sugar for passing around a state value everywhere
19:20:41 <conal> danharaj: i'm looking for something precise.  don't know if an analogy would help.
19:20:42 <kmc> it's not "real" mutable memory; IO and ST have that
19:20:45 <Olathe> Oh, I know, but I'm reading the definition of it and frequently going "Ow ! My brain !"
19:21:02 <kmc> it's a short definition though
19:21:10 <kmc> dense but short
19:21:21 <conal> Kaidelong: now make that informal def precise, so that one can reason about it rigorously and can evaluate its actual complexity/simplicity.
19:21:58 <AnAdorableNick> Olathe: I wrote a tutorial on the topic: http://strabismicgobbledygook.wordpress.com/2010/03/06/a-state-monad-tutorial/
19:22:02 <Olathe> Ahh, cool :)
19:22:03 <Olathe> Thanks
19:23:13 <conal> Kaidelong: in other words, come up with a precise math model to replace (or augment) your informal description.  to get beyond hand-waving.
19:23:54 <JuanDaugherty> lol strabmismicgobbeldygook.com
19:24:26 <Kaidelong> conal: Each component in the network can have multiple links to other components in the network. A component cannot observe the state of another component that it is not directly linked to except through an intermediary. The network is acyclic. Code outside the network can only interact with a single "driver" node.
19:24:30 <Kaidelong> how's that?
19:24:38 <avenge> Does anyone know why ghc/ghci might be unable to find a package I installed with "cabal install"?
19:25:38 <JuanDaugherty> *strabismic
19:25:40 <Kaidelong> oh, I suppose there is a problem with that, you should allow some feedback
19:25:57 <Kaidelong> perhaps via the same special node the outside world uses to drive the data flow
19:26:15 <conal> Kaidelong: getting more precise.  keep working on it until it's purely math definitions.  nothing left to assume/interpret/handwave.  what i'm suggesting may require some mental muscles most programmers are not used to applying to programming
19:26:39 <Kaidelong> conal: I imagine it'd also involve terminology I haven't learned yet
19:27:04 <jmcarthur> maybe, but not necessarily
19:27:12 <conal> Kaidelong: may be a programmer's habit.  imagine you're working on math, not programming.
19:27:12 <conal> because programming languages are so heavily
19:27:49 <conal> becasue programming has required us to be precise about how, but not what.
19:27:51 <conal> because*
19:28:05 <Kaidelong> conal: why the past tense?
19:28:09 <conal> we say exactly how our program does something, but not what it does
19:28:34 <jmcarthur> "has so far required" :)
19:28:41 <pikhq> It should come as no surprise, then, that most programs have issues doing what one wants. :)
19:28:43 <AnAdorableNick> Kaidelong: Present perfective
19:28:44 * SubStack is implementing some monads in javascript
19:28:55 <conal> Kaidelong:the history of programming from the 1940s until now shape our mental habits.
19:29:03 <conal> our mental habits.
19:29:19 <jmcarthur> conal's client must be acting up
19:29:31 <conal> yeah.  weird.
19:29:33 * Kaidelong thinks
19:29:59 <Kaidelong> I wouldn't say Haskell allows you to say "what" instead of "how" enough to make some deep distinction
19:30:08 <Kaidelong> but you may agree with that
19:30:13 <jmcarthur> :)
19:30:32 <conal> Kaidelong: i'm not talking about haskell as much as about denotative programming.
19:30:41 <jmcarthur> i'd say haskell is closer, but no cigar
19:30:53 <kmc> Haskell allows you to program in a very denotative declarative style, or a very imperative style
19:30:58 <conal> haskell is friendly to denotative programming (in landin's sense), but also friendly to operational.
19:31:11 <Kaidelong> when doing denotative programming I think in the end the programmer will still worry about how their program is evaluated
19:31:29 <conal> for instance, haskell IO is "functional" in a literal sense, but not denotative, afaict.
19:31:58 <conal> Kaidelong: yes, often.
19:32:01 <Kaidelong> that's nicer than doing imperative programming I suppose, where operations may not be atomic and mutable state can affect the whole program implicitly
19:32:25 <Kaidelong> but there is still the thinking of "how" going on, the evaluation strategy becomes the "how
19:32:27 <conal> the distinction i'm making is not really between declarative/functional and imperative.
19:32:48 <conal> it's between having a precise meaning/model and not.
19:33:25 <Kaidelong> conal: so you're more talking about ontology and grammar; you can denote your program as a model useful in understanding how your program works?
19:33:31 <conal> so denotative tends to correlate more with functional than with imperative.
19:34:12 <conal> Kaidelong: so i can precisely say what my types *mean*.  independent from their implementation.
19:34:51 <conal> Kaidelong: see http://conal.net/blog/posts/is-haskell-a-purely-functional-language/ and search for "denotative".  follow the pointer to landin.
19:35:05 <Kaidelong> conal: would this allow a program to be deduced from its types?
19:35:06 <danharaj> Well every program has a precise meaning. When we ask what a program does, we're really asking if the program represents an object in some more abstract realm. Some languages tell you to describe the program whereas more abstract ones tell you to describe the abstract object and generate the program for you.
19:35:10 <Kaidelong> conal: ok, I'll check it out
19:36:08 <conal> as i read him, peter landin recommended dropping "functional" in favor of "denotative".  with all the arguing in circles about what's "functional" and what's not, and with the popularity of haskell's IO, i want to revive peter landin's recommendation.
19:36:48 <danharaj> But while the abstract realm of problems/solutions is fixed, we can define the realm of programs we work in. We chose von neumann worlds which are hard to move back and forth from to the abstract realm. We should have chosen a programming language whose programs are more closely related to the abstract objects we really care about.
19:36:49 <conal> i expect making landin's shift will shed a lot of light in the current darkness.
19:37:07 <pikhq> Would quite aid discussion. After all, denotative programming is not exactly getting common, although lambda is freaking everywhere these days.
19:37:18 <pikhq> (my God, even C's getting it)
19:37:35 <wli> C's getting lambda abstractions?
19:37:54 <pikhq> wli: Apple's "blocks", a C/C++/Objective-C/Objective-C++ extension.
19:38:10 <pikhq> They close, and are reference counted normally...
19:38:21 <conal> danharaj: my understanding is that the first computers (which actually were sequential) shaped the first prog languages.  and since then, machines have changed a lot, but mainstream languages little.
19:38:25 <wli> pikhq: Something smells funny about all that.
19:38:34 <pikhq> With not-too-much effort, you can force them onto a garbage-collected heap instead.
19:38:48 <Kaidelong> pikhq: weren't blocks more analogous to quotations?
19:38:53 <conal> and john backus told us how harmful the old-style language is to our thinking.
19:38:56 <conal> @where liberated
19:38:57 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
19:39:06 <pikhq> Kaidelong: No, they're reference-counted closures.
19:39:32 <pikhq> Literally are. They are reference-counted, they are functions, and they close.
19:39:42 <Kaidelong> I'll have to look at them again, I remember hearing people complaining about them
19:40:03 <Kaidelong> conal: the paper you want me to read is "The Next 700 programming languages?"
19:40:09 <conal> Kaidelong: yes.
19:40:26 * jmcarthur wonders whether DCTP is best categorized under "Control" or "Concurrency." stupid categories
19:40:36 <conal> Kaidelong: and specifically sections 8 & 9
19:40:51 <conal> jmcarthur: categories are bankrupt
19:41:00 * Kaidelong booksmarks it in case he doesn't have time tonight
19:41:06 <jmcarthur> conal: but to be a good hackage citizen i still have to pick something :\
19:41:12 <conal> jmcarthur: those questions almost never have satisfactory answers.
19:41:23 <conal> jmcarthur: sometimes good citizens work toward revolution.
19:41:57 <conal> jmcarthur: in my mind, if it's functional/denotative it's "Data"
19:42:08 * jmcarthur puts it in the CategoriesSuck category
19:42:15 <conal> jmcarthur: yeah!
19:42:17 <applicative> conal, what does precision have to do with 'denotational'?  I use a lot of words, employ a lot of predicates or concepts, that denote perfectly well, though they are imprecise.
19:42:52 <Kaidelong> jmcarthur: what alternative would you suggest? Tagging?
19:43:28 <conal> applicative: my preferred precise language for specification is denotational semantics.  you can get precise with operation, and imprecise with denotation.  i like precise + denotation.
19:44:16 <danharaj> conal: what sort of denotational semantics?
19:44:27 <jmcarthur> Kaidelong: i would find that preferable to categories, sure. it's not perfect, but it'd work
19:44:32 <conal> danharaj: strachey style
19:45:36 <conal> @where+ ontology http://www.shirky.com/writings/ontology_overrated.html
19:45:36 <lambdabot> Good to know.
19:46:31 <jmcarthur> i wonder how good this is: http://www.amazon.com/Denotational-Semantics-Scott-Strachey-Approach-Programming/dp/0262690764
19:47:02 <conal> i like clay shirky's points about ontology depending on untenable assumptions of static classifications (no evolution) and on mind-reading (which of many possible categories will future seekers think of when looking for my artifact).
19:47:52 <conal> and i like his point about "there is no shelf" with electronic info.
19:48:13 <conal> so we don't have to keep making these awful arbitrary choices.
19:48:15 <conal> like our grandparents did.
19:56:35 <conal> jmcarthur: that book is the one i learned from in grad school.
19:57:00 <conal> jmcarthur: i liked it.
19:57:18 <conal> jmcarthur: probably pretty dated now. i think it uses lattices instead of cpos.
19:58:25 <jmcarthur> conal: hmm. any other recommendations?
19:59:01 <conal> jmcarthur: no.  though if you find something you like, please tell me.  i often wonder what to recommend.
19:59:10 <jmcarthur> okay thanks
19:59:31 <conal> i like to warn people that the easier (strachey) part is more useful for software design than the harder (scott) part.
20:00:00 <conal> it's easy to get bogged down in the harder part, unnecessarily.
20:00:18 <conal> iirc, strachey was already practicing denotational semantics before scott invented his part.
20:00:29 <jmcarthur> yeah, that's what i've read
20:00:58 <conal> so i'd like to see DS resources that ignore domain theory at first.
20:01:09 <conal> take it on faith that the lambda calculus means something.
20:01:32 <conal> like people were doing from the 1940s until scott's domains.
20:01:44 <danharaj> conal: what do you think of category theory as a setting for DS
20:02:18 <conal> danharaj: i don't have a whole lot of exposure to categorical semantics.
20:03:24 <danharaj> conal: me neither, I have Hagino's thesis printed, and I intend to work through it. That he managed to ground an expressive language completely in categorical concepts is remarkable.
20:04:43 <conal> danharaj: amen.
20:04:55 <conal> danharaj: thesis url?
20:06:34 <danharaj> http://www.tom.sfc.keio.ac.jp/~hagino/thesis.pdf
20:07:16 <conal> danharaj: thx.
20:08:16 <danharaj> My favorite part is "It has no primitive data types nor primitive control structures."
20:08:46 * Kaidelong has been thinking about that last one a lot
20:09:55 <wli> Presumably only advanced ones, then?
20:11:05 <GonzoChurch> not as good as mine which "abstracts abstractly without abstract states"
20:11:40 <Kaidelong> wli: you could work without any control structures if you have a program that is evaluated infinitely in parallel but only terminates on one solution
20:11:49 <Kaidelong> that was what I came up with, anyway
20:11:58 <Kaidelong> or if you have a program so simple you don't need any anyway
20:12:29 <Kaidelong> but that's not interesting
20:12:37 <GonzoChurch>  <Kaidelong> wli: you could work without any control structures if you have a program that is evaluated infinitely in parallel but only terminates on one solution
20:12:54 <GonzoChurch> sounds like you should be writing grants for quantum computing with talk like that
20:13:07 <danharaj> The control structures in hagino's language are derived from data definitions.
20:13:10 <Kaidelong> Gonzo: a quantum computer could do something like that?
20:13:13 <danharaj> They are canonical in a sense.
20:13:25 <danharaj> Kaidelong: You cannot have an infinite superposition of states.
20:13:28 <GonzoChurch> you could compute infinitely in parllel worlds!
20:13:28 <Kaidelong> Gonzo; wouldn't that make them turing oracles?
20:14:37 <GonzoChurch> well perhaps, but then if you had an algorithm for integer factorization that was in P, could you use that as an oracle?
20:14:40 * hackagebot Hermes 0.0.4 - Message-based middleware layer  http://hackage.haskell.org/package/Hermes-0.0.4 (SveinOveAas)
20:14:49 <Kaidelong> Gonzo: the problem with that is that in all the worlds but one, your program hangs
20:15:00 <GonzoChurch> for at least one problem, yes (shors algorithm would go from BQP to P)
20:15:42 <GonzoChurch> but what for other problems in BQP? could the factorization algorithm be used as oracle to put those in P (like grovers algorithm, yeah that'd be a nice one"
20:16:20 <Kaidelong> > 1/(1/0)
20:16:21 <lambdabot>   0.0
20:17:13 * Kaidelong wonders how one would reason about an infinitessimal probability, is it still "possible"?
20:19:24 <GonzoChurch> no its not, there are no "real numbers" only computable reals
20:20:18 <Kaidelong> but a chance of 1 in infinity doesn't say you can't get it once
20:20:33 <Kaidelong> it only says that no matter how many times you try, your chance of getting it approaches 0
20:20:50 <GonzoChurch> but, matheticians seem to be defiant fo the concept that everything exsits in the physcial universe when its THEIR god you're talking about
20:21:02 <GonzoChurch> no, infinity is NAN
20:21:20 <QtPlatypus> GonzoChurch: It depends on which definitio your using for number.
20:21:47 <QtPlatypus> Alpha_null is a number.
20:21:48 <tensorpudding> the probability of choosing a number in R randomly and having it come up rational is in some sense 0
20:21:51 <Draconx> Kaidelong, there is a formal term for that: "almost never" or "almust surely.
20:21:55 <GonzoChurch> ok, infinity is a hypereal number
20:22:36 <GonzoChurch> you can't say (rational number* hyperreal = rational number)  just no
20:22:40 <tensorpudding> I think it has to do with measures
20:22:42 <Draconx> Kaidelong, consider the case of selecting a real number uniformly at random on the interval [0,1].  Given any real number on that interval, the probability of selecting it is 0.  Nevertheless, _some_ real number gets picked each time.
20:23:18 <ddarius> tensorpudding: Yes.  "Almost never" means true on a set of measure 0.
20:23:33 <Kaidelong> Draconx: that's pretty much what I was thinking
20:23:37 <tensorpudding> "almost never" is the opposite of a.e.
20:23:44 <tensorpudding> makes sense
20:24:08 <Kaidelong> if you used this hypothetical computer that needs no control structures but has an infinitessimal chance of termination
20:24:11 <GonzoChurch> not even pi or e have infinity of digits, because it costs something to compute that, and there are limits on what you can manipulate symbolically
20:24:20 <Kaidelong> your chance of the computation succeeded is essentially 0
20:24:27 <Kaidelong> but it COULD happen, so it's still possible
20:24:37 <QtPlatypus> The other one is the probility of selecting a rational number from the real interval [0,1].  Also 0
20:25:24 <tensorpudding> pi and e have infinitely many digits in decimal, because they define a series
20:26:47 <Kaidelong> tensorpudding: Cantor showed that there are infinitely many real numbers for every integer. The problem of whether the same was true for irrational numbers vs rational numbers turned out to be undecidable, but there is at least one non-terminating number for every one that terminates
20:26:49 <QtPlatypus> tensorpudding: All numbers have infinitely meany digits in decimal point notation we simply as convention don't write the zeros.
20:27:30 <tensorpudding> e has a representation as a series
20:28:08 <tensorpudding> in that sense it is not like most irrational numbers
20:28:09 <QtPlatypus> Kaidelong: The rational numbers can be put into a bijection with the integers.  So its quite decidable.
20:28:24 <Kaidelong> QtPlatypus: wait, you're right
20:28:29 <QtPlatypus> tensorpudding: The diffrence is that they are computatable.
20:28:36 <tensorpudding> Yeah.
20:28:43 <Kaidelong> what was undecidable was whether or not there was a cardinality between aleph 0 and 1
20:28:48 <Kaidelong> I was misremembering, thanks
20:28:57 <tensorpudding> "defining a series" means that there is an algorithm for computing their digits
20:29:24 <QtPlatypus> What is undecidable is 2^(aleph 0) = aleph 1
20:29:27 <Draconx> Kaidelong, you mean between aleph_0 and 2^{aleph_0}: the continuum hypothesis.  "Undecidable" isn't the right word here.
20:29:27 <Kaidelong> cardinality of the rationals are aleph 0, not aleph 1, maybe in-between but no to know
20:29:42 <QtPlatypus> Draconx: Yeah
20:29:47 <Kaidelong> so chance of picking out a rational on a set of reals is indeed 0
20:30:45 <Kaidelong> err, if the set is a continuous interval, that is
20:30:54 <Kaidelong> that doesn't have length 0
20:31:08 <Kaidelong> you could do something like { (1/2) } I guess
20:37:51 <JoeyA> Is there a shorter way to write Just (fromMaybe 0 a + 1) ?
20:38:23 <JoeyA> I have an expression that increments a value in a Map if the key is present, sets it to 1 otherwise.
20:38:44 <JoeyA> The expression being:  alter (\a -> Just (fromMaybe 0 a + 1)) key map
20:38:47 <dolio> > (length "maybe (Just 0) (Just . (+1)) a", length "Just (fromMaybe 0 a + 1)")
20:38:48 <lambdabot>   (30,24)
20:39:14 <dino-> There are functions in Data.Map for adjusting values as well.
20:39:14 <dolio> > length "fmap (+1) a `mplus` Just 0"
20:39:15 <lambdabot>   26
20:39:19 <dolio> Damn.
20:39:20 <JoeyA> > alter (\a -> Just (fromMaybe 0 a + 1)) 4 (fromList [(5,1), (3,2)])
20:39:21 <lambdabot>   Not in scope: `alter'
20:39:27 <JoeyA> ?
20:39:33 <JoeyA> > Map.alter (\a -> Just (fromMaybe 0 a + 1)) 4 (fromList [(5,1), (3,2)])
20:39:33 <ddarius> dolio: Alternative
20:39:34 <lambdabot>   Not in scope: `Map.alter'
20:39:41 <dolio> Oh.
20:39:46 <dolio> > length "fmap (+1) a <|> Just 0"
20:39:47 <lambdabot>   22
20:39:51 <dolio> Woo!
20:39:53 <JoeyA> > import qualified Data.Map as Map
20:39:54 <lambdabot>   <no location info>: parse error on input `import'
20:40:04 <JoeyA> I figured it would involve fmap
20:40:37 <dino-> JoeyA: Like Data.Map.adjustWithKey possibly?
20:41:01 <dolio> > length "(+1) <$> a <|> Just 0" -- might work, if the precedence is right.
20:41:02 <lambdabot>   21
20:41:05 <dino-> Oh, sets it to 1 otherwise..
20:41:06 <JoeyA> Here's where I found alter:  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html#v%3Aalter
20:41:13 <BMeph> > length "Just $ maybe 1 succ a"
20:41:14 <lambdabot>   21
20:41:21 <GonzoChurch> pasteben iz ur frien
20:41:45 <GonzoChurch> u no
20:42:09 <JoeyA> These are separate one-liners.
20:42:23 <BMeph> TIMTOWTSACBOAFAD:
20:42:41 <GonzoChurch> we're allowed to paste one-liners?
20:42:45 <GonzoChurch> ok!  Hard work has a future payoff. Laziness pays off NOW!
20:42:47 <BMeph> "There is more than one way to skin a cat, but only a few are delicious." ;)
20:43:07 <JoeyA> > Data.Map.alter (\a -> Just $ maybe 1 succ a) 5 (fromList [(5,1), (3,2)])
20:43:08 <lambdabot>   Not in scope: `Data.Map.alter'
20:43:09 <GonzoChurch> Always remember you're unique - just like everyone else.
20:43:18 <dolio> JoeyA: Can't you do what you want with insertWith or something?
20:43:32 <dolio> insertWith (\_ -> succ) 0 perhaps?
20:43:35 <GonzoChurch> what are you inserting?  where are you inserting it?
20:43:42 <GonzoChurch> that makes a BIG difference
20:44:20 <Mathnerd314> :t M.alter
20:44:22 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
20:44:51 <Olathe> There's more than one way to skin a cat, so choose a skin that goes with your home's decor.
20:45:02 <BMeph> GonzoChurch: "Be an individual - everybody's doing it!" 8D
20:45:11 <dolio> > M.insertWith (\_ -> succ) 5 0 (fromList [(5,1),(3,2)])
20:45:12 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
20:45:12 <lambdabot>                    ...
20:45:15 <GonzoChurch> hheh look what i started
20:46:37 <JoeyA> dolio: Yes, insertWith works here :-)
20:46:37 <Veinor> hpaste isn't working for me
20:47:06 <Veinor> but anyway
20:47:08 <Veinor> http://pastebin.com/metP9c3s
20:47:11 <dolio> > M.insertWith (\_ -> (+1)) 5 0 (fromList [(5,1),(3,2)])
20:47:12 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
20:47:12 <lambdabot>                    ...
20:47:30 <JoeyA> > M.insertWith (\_ -> succ) 4 1 (fromList [(5,1), (3,2)])
20:47:31 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
20:47:31 <lambdabot>                    ...
20:47:43 <JoeyA> Looks like someone broke lambdabot
20:47:57 <Olathe> @type insertWith
20:47:58 <lambdabot> Not in scope: `insertWith'
20:48:05 <JoeyA> @type M.insertWith
20:48:06 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
20:48:22 <dolio> > M.insertWith (\_ -> (+1)) 5 0 (M.fromList [(5,1),(3,2)])
20:48:23 <lambdabot>   fromList [(3,2),(5,2)]
20:48:26 <dolio> There we go.
20:48:31 <dolio> > M.insertWith (\_ -> (+1)) 5 0 (M.fromList [(3,2)])
20:48:32 <lambdabot>   fromList [(3,2),(5,0)]
20:48:33 <Veinor> http://pastebin.com/metP9c3s <-- is there any better way to do this?
20:48:40 <JoeyA> It's 1, not 0
20:48:43 <Olathe> @type fromList
20:48:43 <Mathnerd314> @type fromList
20:48:44 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
20:48:45 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
20:48:53 <JoeyA> > M.insertWith (\_ -> succ) 4 1 (fromList [(5,1), (3,2)])
20:48:54 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
20:48:54 <lambdabot>                    ...
20:49:01 <dolio> > fromList [(5,0.5), (4, 0.4), (3, 0.1)]
20:49:02 <lambdabot>   No instance for (GHC.Show.Show (m t))
20:49:02 <lambdabot>    arising from a use of `M2086066500...
20:49:10 <JoeyA> > M.insertWith (\_ -> (+1)) 4 1 (M.fromList [(5,1), (3,2)])
20:49:11 <lambdabot>   fromList [(3,2),(4,1),(5,1)]
20:49:17 <JoeyA> > M.insertWith (\_ -> (+1)) 5 1 (M.fromList [(5,1), (3,2)])
20:49:18 <lambdabot>   fromList [(3,2),(5,2)]
20:49:21 <Mathnerd314> > M.fromList [(5,0.5), (4, 0.4), (3, 0.1)]
20:49:22 <lambdabot>   fromList [(3,0.1),(4,0.4),(5,0.5)]
20:49:23 <JoeyA> That's exactly what I want
20:50:03 <JoeyA> \_ is a fun little idiom :-)  Lambda with one of its legs snapped off.
20:50:12 <monochrom> ...
20:50:27 <dolio> > (\_ _ -> 5) 4
20:50:28 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
20:50:28 <lambdabot>    arising from a use of ...
20:50:30 <Olathe> It's the 2:50 operator.
20:50:30 <dolio> > (\_ _ -> 5) 4 4
20:50:31 <lambdabot>   5
20:50:45 <dolio> _ is when you don't care about an argument.
20:50:50 <JoeyA> Right
20:50:51 <Mathnerd314> @type const
20:50:52 <lambdabot> forall a b. a -> b -> a
20:51:07 <Veinor>  \_: just take a break.
20:51:17 <Mathnerd314> > M.insertWith (const (+1)) 5 1 (M.fromList [(5,1), (3,2)])
20:51:18 <lambdabot>   fromList [(3,2),(5,2)]
20:51:33 <Olathe> @type M.insertWith
20:51:34 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
20:51:49 <Mathnerd314> JoeyA: no need for \_ ->; use const ^
20:51:58 <Olathe> > M.insertWith (const (+1)) 100 500 (M.fromList [(5,1), (3,2)])
20:51:59 <lambdabot>   fromList [(3,2),(5,1),(100,500)]
20:52:02 <JoeyA> Yup
20:52:13 <Olathe> > M.insertWith (const (+1)) 3 500 (M.fromList [(5,1), (3,2)])
20:52:14 <lambdabot>   fromList [(3,3),(5,1)]
20:54:45 * BMeph prefers "const succ" to "const (+1)"
20:55:12 <Olathe> > succ (255 :: Word8)
20:55:13 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
20:55:45 <BMeph> Olathe: succ'er! ;)
20:55:49 <Olathe> Heheh
20:56:15 <JoeyA> lol
20:57:07 <Kaidelong> > let isItChecked = 255 in isItChecked + 1 :: Word8
20:57:08 <lambdabot>   0
20:57:39 <pikhq> succ != (+1) :)
20:57:39 <JoeyA> > (+1) (255 :: Word8)
20:57:40 <lambdabot>   0
20:57:45 <Kaidelong> was about to say
20:57:50 <Mathnerd314> @type succ
20:57:51 <lambdabot> forall a. (Enum a) => a -> a
20:57:56 <Mathnerd314> @type (+1)
20:57:57 <lambdabot> forall a. (Num a) => a -> a
20:58:11 <JoeyA> Interdestink
21:01:38 <JoeyA> Now I want to go the other way around:  given a key, subtract 1, but delete it if it reaches 0.  I suppose I want Map.update.
21:02:07 <JoeyA> > M.insertWith (const (+1)) 4 1 (M.fromList [(5,1), (3,2)])
21:02:08 <lambdabot>   fromList [(3,2),(4,1),(5,1)]
21:03:06 <JoeyA> > M.update (\a -> if a==1 then Nothing else Just (a-1)) 4 fromList [(3,2),(4,1),(5,1)]
21:03:07 <lambdabot>   Couldn't match expected type `Data.Map.Map t a'
21:03:07 <lambdabot>         against inferred ty...
21:03:23 <JoeyA> M.update (\a -> if a==1 then Nothing else Just (a-1)) 4 M.fromList [(3,2),(4,1),(5,1)]
21:03:31 <JoeyA> > M.update (\a -> if a==1 then Nothing else Just (a-1)) 4 M.fromList [(3,2),(4,1),(5,1)]
21:03:32 <lambdabot>   Couldn't match expected type `Data.Map.Map t a'
21:03:32 <lambdabot>         against inferred ty...
21:03:36 <JoeyA> Aw shaddup
21:04:17 <JoeyA> Hmm, parens work wonders
21:04:32 <JoeyA> > M.update (\a -> if a==1 then Nothing else Just (a-1)) 4 (M.fromList [(3,2),(4,1),(5,1)])
21:04:33 <lambdabot>   fromList [(3,2),(5,1)]
21:04:45 <JoeyA> M.update (\a -> if a==1 then Nothing else Just (a-1)) 3 (M.fromList [(3,2),(4,1),(5,1)])
21:04:52 <JoeyA> > M.update (\a -> if a==1 then Nothing else Just (a-1)) 3 (M.fromList [(3,2),(4,1),(5,1)])
21:04:53 <lambdabot>   fromList [(3,1),(4,1),(5,1)]
21:05:00 <JoeyA> Ka'plah!
21:05:05 <GonzoChurch> Lost In Superfluous Parentheses
21:07:10 <kmc> GonzoChurch, nice nick
21:07:21 <kmc> makes me think of an introduction to lambda calculus written by Hunter S. Thompson
21:09:11 <danharaj> hmm
21:09:28 <danharaj> I think I'll tackle type directed overloading next.
21:14:27 <tensorpudding> Thompson's lambda calculus book was really good
21:15:30 <GonzoChurch> @kmc heh
21:15:30 <lambdabot> Maybe you meant: ghc rc src
21:15:49 <tensorpudding> you can see the germs of his style develop there
21:15:51 <GonzoChurch> I wish he did write an intro
21:16:19 <tensorpudding> some parts of fear and loathing seem to make oblique inside references to it
21:19:22 <JoeyA> If I have a 2-tuple, is there a short way to add a 3rd member to it?  Or do I have to use pattern matching?
21:19:34 <kmc> JoeyA, the latter
21:19:40 <JoeyA> okay, thanks
21:19:50 <kmc> tuple types of different sizes are not really related
21:20:17 <kmc> though the "tuple" package on Hackage has some functions overloaded to work on many sizes
21:20:35 <kmc> @pl \(x,y) z -> (x,y,z)
21:20:35 <lambdabot> uncurry (,,)
21:20:37 <kmc> oh hey
21:20:41 <kmc> that's clever lambdabot
21:21:21 <tensorpudding> ooh
21:21:32 <kmc> :t uncurry (,,,)
21:21:32 <tensorpudding> @pl \(x,y,z) w -> (x,y,z,w)
21:21:33 <lambdabot> forall a b c d. (a, b) -> c -> d -> (a, b, c, d)
21:21:33 <lambdabot> (line 1, column 6):
21:21:33 <lambdabot> unexpected ","
21:21:33 <lambdabot> expecting letter or digit, operator or ")"
21:21:33 <lambdabot> ambiguous use of a non associative operator
21:21:50 <kmc> pl is ignorant of n-tuples, n>2
21:21:53 <tensorpudding> bah
21:22:09 <tensorpudding> > uncurry (,,) (5,6,7) 8
21:22:10 <lambdabot>   Couldn't match expected type `(a, b)'
21:22:10 <lambdabot>         against inferred type `(t, t1...
21:22:13 <tensorpudding> right
21:22:19 <tensorpudding> > (uncurry (,,)) (5,6,7) 8
21:22:21 <lambdabot>   Couldn't match expected type `(a, b)'
21:22:21 <lambdabot>         against inferred type `(t, t1...
21:22:52 <tensorpudding> Hmm.
21:23:04 <tensorpudding> uncurry only works for 2-tuples
21:37:52 <glguy> Does the new hSetNewlineMode stuff not help me turn:   putStr "\r\n" to \n on stdout?
23:39:13 <copumpkin> wow, sure is quiet tonight
23:39:25 <DigitalKiwi> i was just thinking the same thing
23:39:47 <DigitalKiwi> so
23:39:52 <DigitalKiwi> what should we talk about
23:40:01 <aristid> comonads.
23:40:33 <DigitalKiwi> well that would make my possible contributions near nil as i don't know what those are
23:40:44 <ketil> I think silence counts as co-talk.
23:40:47 <c_wraith> Eq instances for data structures that contain functions.
23:41:22 <ketil> c_wraith, no this was done on the list.  Just enumerate all possible inputs and check them. :-)
23:41:26 <aristid> (a,) <- this is a comonad? oO
23:41:38 <blackdog> i am _so_ tempted to put an Errors monad into this ruby app
23:41:38 <aristid> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
23:41:43 <JoeyA> Is the group function efficient?  By that, I mean is it at least as efficient as sorting a list, then traversing it to find equivalent items?
23:41:50 <blackdog> if errors.empty? staircases all over the place
23:41:57 <aristid> JoeyA: group doesn't sort
23:41:58 <JoeyA> Or does it use an n^2 algorithm?
23:42:12 <aristid> > group [1,1,2,2,1,1]
23:42:14 <lambdabot>   [[1,1],[2,2],[1,1]]
23:42:27 <sordina> JoeyA: it only groups adjacent items.
23:42:33 <JoeyA> Okay, good
23:42:34 <aristid> > group . sort [1,1,2,2,1,1]
23:42:35 <lambdabot>   No instance for (GHC.Num.Num [a])
23:42:35 <lambdabot>    arising from a use of `e_1112211' at <...
23:42:44 <aristid> > group . sort $ [1,1,2,2,1,1]
23:42:45 <lambdabot>   [[1,1,1,1],[2,2]]
23:42:51 <JoeyA> That's what I want, thanks!
23:43:00 <copumpkin> aristid: no
23:43:06 <aristid> JoeyA: i think group . sort should be relatively efficient
23:43:36 <JoeyA> agreed
23:43:41 <aristid> which algorithm does ghc's sort use, btw?
23:43:43 <aristid> copumpkin: no?
23:44:00 <blackdog> if you happen to know that you have relatively many dupes, you might be able to do better by updating an array - that'd be linear. it probably doesn't matter though
23:45:24 <ketil> Actually - group is an argument for non-structural equality.  There isn't much point in returning lists of equal elements, unless there's some other way to differentiate them.  (In fact, most of my uses of group want (a,Int) - element + count -  instead)
23:47:06 <ketil> I guess I forgot about laziness - with lists of duplicates, it is possible to consume them partly.  If group is written with that in mind..
23:47:28 <Veinor> so you want ketilGroup = map (\x -> (head x, length x)) . group
23:47:34 <jbapple> I am writing a data structure that offers some worst-case guarantees -- how much to I need to change the auxiliary data structures that represent it?
23:47:45 <jbapple> I know that is a broad question
23:47:57 <jbapple> I guess what I mean is -- do I have to rewrite Data.List
23:48:11 <jbapple> Maybe there's something on hackage for it
23:48:18 <c_wraith> hmm.  I did run into an issue today I should ask about.  I was writing a custom Eq instance for a record type, and I wanted to write it as "instance Eq T where t1 == t2 = let eq f = f t1 == f t2 in all eq [accessor1, accessor2, accessor3, etc]"  The obvious problem with that is the accessors aren't all the same type.  But anything that makes all the list elements the same type is more verbose.  Is there some type trick that can apply here?
23:48:20 <jbapple> But do I have to use my own Maybe type?
23:48:24 <ketil> > let (xs:_) = group [1,1,1,undefined,2,2,2] in case xs of (_:_) -> True; otherwise -> False
23:48:25 <lambdabot>   True
23:49:14 <ketil> So it does build the groups lazily, if I interpret my own code correctly.
23:49:53 <jbapple> I guess I'm looking for prior art here -- when does it help to write one's own StrictPrelude?
23:51:02 <ketil> c_wraith, looks like something you could solve with existentials?
23:51:28 <c_wraith> ketil: possibly, but if it requires introducing another data type, it's not a win.
23:51:56 <jbapple> c_wraith: and it's probably more verbose than "all [eq acc1, eq acc2, eq acc3]"
23:52:21 <c_wraith> jbapple: that's what I meant by not a win.  And that's what I gave up and switched the code to.
23:52:35 <c_wraith> Just feels redundant to apply the same function to every element in a list :)
23:52:50 <jbapple> what about writing it as a tuple rather than a list?
23:53:05 <c_wraith> then the all function doesn't work.
23:54:22 <c_wraith> heh.  maybe gfold or something from syb?  *sigh*
23:54:28 <jbapple> You would have to write your own. You could use nested tuples, but then I sense undecidable instances
23:54:44 <jbapple> Maybe generic classes? SYB + static type safety
23:55:23 <aristid> @hoogle unzip
23:55:24 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
23:55:24 <lambdabot> Data.ByteString unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
23:55:24 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
23:57:17 <c_wraith> ack, sleep has come to claim me.  At least there's not something easy I missed.
23:58:13 <jbapple> c_wraith: What if you default to the regular eq and then try it again excluding the fields you don't want to consider?
