00:01:14 <jmcarthur> dibblego: http://hackage.haskell.org/packages/archive/TypeCompose/0.7.0/doc/html/Control-Compose.html#t%3A%3A%24
00:01:26 <jmcarthur> i think something is wrong with the haddock docs there. there's actually a Monoid instance for that
00:02:25 <jmcarthur> i suspect haddock was confused because the instance is actually defined for the App alias rather then for (:$) directly
00:02:37 <jmcarthur> *rather than
00:31:04 <dibblego> jmcarthur, I'd actually like to write a Semigroup type-class (binary associative operation, not necessarily identity) and a "lifted" version as well (f a -> f a -> f a) but I'm not sure how best to tackle the Monoid issue
00:32:57 <profmakx> yay semigroups
00:33:20 <dibblego> there's one on hackage but it's bogus and the author won't let me add to it
00:33:53 <profmakx> I'd be very interested in doing computery semigroups stuff in haskell
00:34:39 <xerox> dibblego: fork it
00:34:53 <dibblego> xerox, it's two lines of code
00:35:25 <xerox> no idea what is the problem
00:35:43 <dibblego> xerox, I'll just write my own and make it comprehensive
00:45:05 <copumpkin> dibblego: the author won't let you add to what?
00:45:15 <dibblego> more than 2 lines
00:45:30 <copumpkin> :o
00:45:32 <dibblego> class Semigroup a where foo :: a -> a -> a
00:45:35 <dibblego> that's all it is
00:45:37 <copumpkin> oh that algebra package
00:45:39 <copumpkin> ugh
00:45:41 <copumpkin> it pisses me off
00:45:45 <dibblego> same
00:46:04 <copumpkin> I think there should be a system in place for revoking high-profile names
00:52:05 <profmakx> hm. is it the "haskell for maths" algebra package?
00:52:58 <copumpkin> nope
00:53:02 <copumpkin> @hackage algebra
00:53:02 <lambdabot> http://hackage.haskell.org/package/algebra
00:53:18 <copumpkin> it's a "high-value" package name that contains almost nothing of use at all
00:53:39 <profmakx> O.o
00:53:43 <copumpkin> it even follows the same silly naming as the standard library Monoid with append
00:53:47 <xerox> maybe with ratings ...
00:53:51 <copumpkin> call it something short and operatory goddammit
00:54:09 <profmakx> this looks pretty damn useless
00:55:13 <copumpkin> yep :)
00:55:20 <copumpkin> anyway, I'll quit bitchin
00:57:43 <Ke> there is nothing but semigroup append?
00:59:23 <copumpkin> that's it
00:59:37 <Ke> yikes
00:59:53 <dibblego> well I've called it (.++.)
01:00:41 <copumpkin> class Magma a where (â‹…) :: a -> a -> a
01:00:47 <opqdonut> why not -.+^+.- while you're at it?
01:01:29 <jutaro> nun is down (code.haskell.org, ...). At least I can't reach.
01:02:44 * dancor reviews some choice irc quotes of ppl defending code.haskell.org's uptime
01:02:55 <copumpkin> let's see 'em
01:03:24 <Ke> =D
01:06:24 <dancor> eh let's just keep mocking the minimalism of semigroups
01:08:45 <dancor> it's got to be cooler in like agda where you can prove associativity
01:10:12 <copumpkin> yeah, and it's not a typeclass
01:10:17 <copumpkin> which is good and bad
01:10:28 <copumpkin> it's a record
01:10:37 <dibblego> newtype Semigroup a = Semigroup (a -> a -> a)
01:10:53 <dibblego> whatever it is, it needs *instances*
01:10:55 <copumpkin> yeah, but it would carry a proof too
01:13:04 <profmakx> .oO(meh. and me, working in semigroup theory :()
01:13:42 <dibblego> http://paste.pocoo.org/show/209213/ here is a rough sketch
01:14:51 <copumpkin>   _ .++. _ = ()
01:15:06 <copumpkin> I haven't made up my mind about how I feel about strictness on () instances
01:15:58 <dancor> dibblego: what is Alt
01:16:00 <dibblego> const . const $ ()
01:16:13 <dibblego> dancor, a plceholder for "I hate thinking of names so I will do it later"
01:16:16 <copumpkin> you could make a newtype WrapMonoid a = WrapMonoid a
01:16:26 <copumpkin> instance Monoid a => Semigroup (WrapMonoid a) where duh
01:16:35 <copumpkin> for custom monoids people want wrapped
01:16:35 <dibblego> yeah I've just called it Identity
01:16:38 <dancor> proof method duh
01:16:42 <copumpkin> oh, missed that
01:16:52 <copumpkin> now I feel silly :P
01:16:56 <copumpkin> cool though
01:17:20 <copumpkin>   Identity a1 .++. Identity a2 = Identity (a1 `mappend` a2)
01:17:25 <copumpkin> liftA2 mappend
01:17:39 <dibblego> indeed
01:17:56 * copumpkin stops saying stupid stuff and goes to sleep :)
01:18:40 <dibblego> dancor, can you suggest a better name?
01:19:08 <copumpkin> dibblego: I think edwardk's monoids package had a semigroup in it for a while
01:19:14 <copumpkin> he may have taken it out though
01:19:18 <dancor> dibblego: sorry i still don't understand why it exists
01:20:04 <copumpkin> I guess not
01:20:18 <dibblego> Alternative without empty
01:20:27 <dibblego> or Applicative f =>
01:21:06 <dancor> a semigroup on applicative functors?
01:21:56 <dibblego> perhaps it shouldn't exist and instead a single function: liftA2 (.++.) should
01:23:05 <dancor> Alternatve would be like the joke where Rng is Ring-with-identity
01:23:13 <dancor> without*
01:24:28 <dancor> "Alternator" could make a joke about how energy can't be destroyed..
01:33:05 * hackagebot lat 0.5 - Tool to track security alerts on LWN  http://hackage.haskell.org/package/lat-0.5 (MagnusTherning)
01:48:39 <arcatan> blarg, i have mutually recursive modules
01:56:06 <arcatan> hmm, writing a .hs-boot file was easier than i thought.
02:00:18 * m3ga sighs
02:00:33 <m3ga> code.haskell.org is down again
02:04:21 <bastl> hey, when doing web-programming with haskell (cgi, happs, happstack etc), how can I make sure, that a file is written by just one process?
02:06:40 <chrisdone> is it possible to specifically surpress warnings about unused record field functions?
02:07:24 <arcatan> bastl: if you're on UNIX, maybe with flock(2)? i think there's flock package on Hackage
02:11:08 <Ke> flock is unsafe on nfs afaik
02:11:28 <bastl> How about semaphores ?
02:11:31 <Ke> the situation is very very sad, I hate my life too
02:14:13 <chrisdone> ah, that's one solution... put the record type in a separate module and then export all constructors, then import only the ones you use in your other module
02:14:16 <chrisdone> perfetto
02:17:53 <Jafet> Who runs a web service on nfs
02:18:29 <arcatan> that could happen in a shared hosting environment
02:31:37 <bastl> Can someone explain this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25290#a25290 Am I doing something wrong ? Looks like a flaw in the library ...
02:33:59 <Saizan> yeah
02:34:13 <Saizan> that looks like you've two bug reports to make :)
02:38:34 * hackagebot Semigroup 0.0.1 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.1 (TonyMorris)
03:10:42 <Kaidelong> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25291#a25291
03:10:47 <Kaidelong> anyone can help?
03:12:40 <Saizan> Kaidelong: what did you expect?
03:12:43 <Kaidelong> output for the first should be [[1,3,5,7,9],[],[2,4,6,8,10]]
03:14:19 <Saizan> uhm, true
03:14:28 <Saizan> > partition odd [1..10]
03:14:28 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
03:14:52 <Saizan> > partition odd . snd . partition odd $ [1..10]
03:14:53 <lambdabot>   ([],[2,4,6,8,10])
03:15:18 <Saizan> > partition even . partition odd . snd . partition odd $ [1..10]
03:15:19 <lambdabot>   Couldn't match expected type `[a]'
03:15:19 <lambdabot>         against inferred type `([a1], [a...
03:15:26 <Saizan> > partition even . snd . partition odd . snd . partition odd $ [1..10]
03:15:27 <lambdabot>   ([2,4,6,8,10],[])
03:15:45 * hackagebot cgi-utils 0.2 - Simple modular utilities for CGI/FastCGI (sessions, etc.)  http://hackage.haskell.org/package/cgi-utils-0.2 (ChrisDone)
03:16:11 <Saizan> oh, wait
03:16:25 <Saizan> you're calling serialFiltration in the recursive case
03:16:37 <Saizan> itym serialPartition there.
03:16:41 <Kaidelong> how does that introduce a problem?
03:16:53 <Kaidelong> oh whoops
03:16:55 <Kaidelong> thanks!!
03:17:24 <Saizan> this is one of the reasons why direct recursion is evil :P
03:17:33 <idnar> serialTermination
03:18:08 <Saizan> ?type mapAccumL
03:18:09 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:18:43 <Kaidelong> now that the typo is gone the code works fine
03:18:58 <Kaidelong> It's the simple things that always seem to hit me the hardest
03:19:12 <Saizan> > mapAccumL (\ x f -> (snd &&& fst) $ partition f x) [1..10] [odd,odd,even]
03:19:13 <lambdabot>   ([],[[1,3,5,7,9],[],[2,4,6,8,10]])
03:19:31 <Saizan> > snd $ mapAccumL (\ x f -> (snd &&& fst) $ partition f x) [1..10] [odd,odd,even] -- tada :)
03:19:32 <lambdabot>   [[1,3,5,7,9],[],[2,4,6,8,10]]
03:20:37 <Kaidelong> ?type (&&&)
03:20:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:20:53 <Kaidelong> arrows
03:20:59 <Kaidelong> I should probably learn those
03:21:15 <Saizan> well, in this case i just used it as an handy combinator for tuples
03:21:30 <Saizan> (f &&& g) x = (f x , g x)
03:21:36 <Saizan> for the (->) arrow
03:21:42 <xerox> all that to get a [] in the middle?
03:21:58 <Kaidelong> xerox: I'm using this function to build a confusion matrix
03:22:18 <Kaidelong> array range . zip ixs . map length . serialPartition fs $ labeledData
03:22:34 <Saizan> > let swap (x,y) = (y,x) in snd $ mapAccumL (\ x f -> swap $ partition f x) [1..10] [odd,odd,even]
03:22:34 <lambdabot>   [[1,3,5,7,9],[],[2,4,6,8,10]]
03:23:03 <Kaidelong> that's where I'm calling it, anyway
03:24:32 <Kaidelong> does haskell have any facility by which to treat an algebraic data type as an enum?
03:24:42 <dibblego> deriving Enum
03:25:17 <Kaidelong> errm, let me look up what enum means in haskell to make sure I communicated that correctly
03:25:22 <xerox> ?type let swap (x,y) = (y,x); (.:) = (.) . (.) in (snd .: mapAccumL (swap .: flip partition))
03:25:23 <lambdabot> forall a. [a] -> [a -> Bool] -> [[a]]
03:26:14 <xerox> :D
03:26:21 <dv-> ?type (.) . (.)
03:26:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:27:02 <pastorn> that's weird...
03:27:06 <Kaidelong> actually, I guess the problem could be solved by not using an algebraic data type and just using a one dimensional array
03:27:21 <Kaidelong> and a pointer
03:27:46 <Kaidelong> wait, I'll have to think about that
03:31:43 <sanyi> i'm looking for some material on how to organize my code in haskell... any ideas?
03:32:49 <pastorn> sanyi: usually you'll have to create a file Types.hs
03:33:04 <pastorn> because of how imports works in haskell
03:33:48 <sanyi> ok, this i did know
03:34:08 <Saizan> that's quite questionable
03:34:31 <pastorn> Saizan: whenever you have State it's not :/
03:35:29 <sanyi> there are usually many conventions for a language, doesn't haskell have some guidelines?
03:35:46 <Saizan> anyhow, you should organize code by functionality
03:36:25 <Jafet> "Types.hs" smells of C
03:36:41 <Jafet> #include "everything.h"
03:36:45 <pastorn> hehe
03:37:05 <pastorn> Jafet: usually there's no way around it :(
03:37:12 <Saizan> i've used Types.hs only is some occasions were i'd have needed mutually recursive imports otherwise
03:37:13 <Jafet> I don't see why.
03:37:28 <Saizan> i don't see why otherwise
03:37:47 <sanyi> Saizan: you mean the main organizational blocks in haskell are libraries?
03:38:27 <Eelis> how come Data.Data.DataType isn't in Eq? it only consists of a string and a DataRep, both of which are already in Eq..
03:38:27 <Saizan> sanyi: module actually, on a finer-grained level
03:39:22 <pastorn> well, if you're going to create a State then you need to have all the types for that state in scope, and it's going to be really annoying if you have FunctionalityX.hs and then FunctionalityXTypes.hs, only to have FunctionalityXTypes exports going through State.hs before using them in Functionality.hs
03:39:55 <sanyi> hm and should i separate pure code from non-pure code?
03:40:04 <Botje> sanyi: as much as possible
03:40:15 <sanyi> different files, etc?
03:40:29 <Saizan> no
03:40:53 <Saizan> there's no point in using modules to separate pure code from IO one
03:41:04 <Jafet> Ah, the Conway effect
03:41:15 <pastorn> Jafet: the what?
03:41:16 <sanyi> well, "much as possible" could also mean i should put nonpure code on another computer ;)
03:41:18 <xerox> Eelis: looks like it can be added
03:41:43 <Eelis> xerox: then i'll file a ticket in hackage trac if there isn't one already
03:41:45 <Jafet> http://en.wikipedia.org/wiki/Conway%27s_Law
03:42:14 <pozic> Types modules are caused by not using mutual recursive modules or simply because it is not necessary.
03:42:19 <Saizan> sanyi: but you should keep it in different functions, i.e. don't write a function readFromDiskAndProcess, but write readFromDisk and process as separate functions, one in IO and the other pure
03:42:49 <sanyi> this sounds reasonable...
03:42:59 <pastorn> pozic: yeah... i don't see why that isn't supported :/
03:43:20 <pozic> pastorn: that is supported.
03:43:22 <pastorn> lazy loading :)
03:43:25 <pozic> pastorn: just in a crappy way.
03:43:26 <pastorn> pozic: how?
03:43:35 <pozic> pastorn: but it does work and I do recommend it.
03:43:43 <pozic> pastorn: the manual is correct.
03:43:57 <pastorn> A.hs: data A = A B; B.hs: data B = B A;
03:44:04 <Jafet> data Module deriving (Functor);
03:44:29 <pastorn> pozic: can you make that work?
03:44:56 <pozic> pastorn: Yes, We Can.
03:45:23 <idnar> Obamaskell
03:45:43 <idnar> @faq can Haskell be elected as president?
03:45:43 <lambdabot> The answer is: Yes! Haskell can do that.
03:46:03 <Jafet> Too lazy.
03:47:53 <Saizan> pastorn: .hi-boot files
03:48:04 <Saizan> s/hi/hs/ actually
03:49:03 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25292#a25292
03:50:12 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
03:51:29 <pozic> pastorn: I did tell you to read the manual, didn't I?
04:19:47 <scott__> Could someone possibly read this document I'm submitting for a class?  It's about a Lisp project I did in Haskell.  We based it off of a language in our textbook which was written in Scheme.  I'm supposed to compare our implementation with the one in the book and also show what things we added to the language.  I just want to know if I got all the Haskell terminology right and also whether the document is clear.  http://omanyte.ath.cx/lisp.html
04:23:09 <pozic> scott__: seems fine to me.
04:23:35 <scott__> pozic: Cool.  Is there any part that is unclear?
04:24:26 <pozic> scott__: it is relatively simple (in that I don't read anything new), so no.
04:24:46 <pozic> scott__: you might want to ask someone who has less experience too.
04:24:54 <scott__> Great, thanks for reading it!
04:24:55 <pozic> scott__: interp (Fun bid bb) ds		= (ClosureV bid bb ds)
04:25:03 <arcatan> scott__: Haskell standard library has Data.Map, not Prelude
04:25:04 <pozic> scott__: you don't tneed those parens.
04:25:29 <scott__> arcatan: Thanks.  My mistake.
04:25:38 <scott__> pozic: Thank you.
04:25:54 <pozic> scott__: I am also not sure whether I would use "symbol table".
04:26:29 <scott__> What should I use?  The book uses the ridiculous "repository of deferred substitutions."
04:26:41 <pozic> scott__: haha
04:26:53 <pozic> scott__: that's indeed ridiculous.
04:26:56 <scott__> That's why I put a little "tm."  Our class has a joke about it.
04:29:10 <scott__> The professor was using the term "symbol table."  I wonder what would be more appropriate.
04:29:59 <ManateeLazyCat> dcoutts_: Darcs-2 repository switch patch with Darcs-1 ? I want a build "synchronous mirror gtk2hs repository" at patch-tag.com to avoid code.haskell.org is down.
04:31:04 <dcoutts_> ManateeLazyCat: no, you cannot move patches between darcs-1 and darcs-2 type repositories
04:31:33 <scott__> Also, do you think I could explain this in 12 minutes?  I have to give a presentation and I'm worried.  Maybe I should make a dreaded Powerpoint.
04:33:46 <ManateeLazyCat> dcoutts_: Currently, patch-tag.com just support Darcs-2, i can't upload gtk2hs repository with error "Cannot mix darcs-2 repositories with older formats"
04:34:20 <dcoutts_> ManateeLazyCat: if patch-tag only supports darcs-2 type repos then you're stuck.
04:34:23 <arcatan> scott__: best way to figure that out is to, well, try to explain it in 12 minutes
04:35:00 <arcatan> to someone or in front of a mirror
04:35:17 <scott__> arcatan: Yes!  I guess I will. XD
04:35:29 <ManateeLazyCat> dcoutts_: If we convert gtk2hs main repo to Darcs-2, so any darcs-1 patches can't apply, right?
04:37:27 <ManateeLazyCat> dcoutts_: When i use "darcs get --complete" get code of gtk2hs, darcs looks convert it to darcs-2 format, but i still can upload it to patch-tag.com, same error "Cannot mix darcs-2 repositories with older formats", any idea?
04:38:15 <andrewe> Where can I get the Eros distribution? The link in the haskell wiki seems to be broken.
04:38:17 <dcoutts_> ManateeLazyCat: no, it does not convert the type of the repo, it merely changes the format in which patches are kept on disk.
04:38:39 <dcoutts_> ManateeLazyCat: run "darcs show repo". It lists both the type and the format.
04:39:50 * ManateeLazyCat pasted "darcs show repo." at http://paste2.org/get/807875
04:39:58 <ManateeLazyCat> dcoutts_: Above is result of "darcs show repo"
04:40:23 <dcoutts_> ManateeLazyCat: yes, that's darcs 1 using the hashed format.
04:41:03 <dcoutts_> ManateeLazyCat: a darcs-2 repo will list "Format: hashed, darcs-2"
04:41:16 <ManateeLazyCat> dcoutts_: I can do this? "Pull patch from main repo, then convert patch to darcs-2, and push to mirror repository".
04:41:35 <dcoutts_> ManateeLazyCat: no, you cannot mix darcs-1 and darcs-2 repositories.
04:41:58 <ManateeLazyCat> dcoutts_: Oh, looks no way to build mirror repository for gtk2hs.
04:42:07 <ManateeLazyCat> dcoutts_: code.haskell.org always down.
04:42:18 <dcoutts_> ManateeLazyCat: not on patch-tag, if patch-tag only supports darcs-2
04:42:48 <ManateeLazyCat> dcoutts_: Do you know any other site support darcs-1 hosting?
04:43:10 <dcoutts_> ManateeLazyCat: I use code.haskell.org
04:43:11 <ManateeLazyCat> dcoutts_: Mirror repository is really important for gtk2hs users when code.haskell.org is down.
04:43:44 <ManateeLazyCat> dcoutts_: I don't know what's wrong with code.haskell.org, i can't access it in most time recently.
04:44:13 <dcoutts_> I'm not sure what's wrong with it either, we keep having to restart apache on it
04:44:27 <dcoutts_> we're planning to move to a different physical machine
04:44:46 <dcoutts_> I mean we're planning to move code.haskell.org to a different server
04:45:04 <dcoutts_> one with more memory and bandwidth
04:45:19 <Entroacceptor> but why does it die?
04:45:42 <ManateeLazyCat> dcoutts_: No backup server?
04:45:55 <dcoutts_> ManateeLazyCat: we have backups
04:46:09 <dcoutts_> Entroacceptor: we're not sure, the apache process seems to stop responding.
04:46:23 <ManateeLazyCat> dcoutts_: I mean when one server is adjust, have another backup server to provide service.
04:46:33 <dcoutts_> ManateeLazyCat: we cannot a afford a whole second server
04:47:16 <dcoutts_> and the admin time we have is better spent moving to the new host
04:47:59 <andrewe> dcoutts_: Sorry, if you already answered that question (my IRC is not really nice), but didn't you have a backup of d.h.o at well-typed?
04:48:07 <dcoutts_> Entroacceptor: the current host is a cheap underpowered virtual machine
04:48:26 <dcoutts_> andrewe: yes, Igloo backed everything up before moving hosts
04:48:41 <dcoutts_> andrewe: if you need something restoring, ask Igloo
04:49:07 <andrewe> Igloo?
04:49:21 <dcoutts_> andrewe: that's Ian's IRC nickname
04:49:23 <ManateeLazyCat> dcoutts_: So we can't access code.haskell.org when server moving?
04:49:42 <dcoutts_> ManateeLazyCat: I don't expect the downtime when we move to be that significant
04:50:01 <andrewe> dcoutts_: I'm looking for Eros, maybe I should ask Conal.
04:50:15 <mux> I'm running a process using createProcess, and creating a pipe for stdout; I'm reading it into a lazy bytestring with hGetContents, but it seems my code that parses this bytestring only gets ran after the subprocess terminated.. any ideas why?
04:51:03 <dcoutts_> andrewe: Ian did send copies to the maintainers, so Conal is your best bet. He should either know where he moved it to, or still have the backup copy.
04:51:24 <mux> (also, I'm using the threaded RTS)
04:51:27 <mreh> how do I get an implementation of a specific method?
04:51:45 <soiamso> mux: must close the fd explicitly
04:52:01 <mreh> like fmap for (Arrow (->))
04:52:02 <ManateeLazyCat> mreh: You mean typeclass?
04:52:28 <mreh> ManateeLazyCat, yes
04:52:44 <dcoutts_> mux: the blocking behaviour when talking to other processes is pretty subtle, there's several ways to do it wrong. Want to paste your code?
04:52:46 <mux> soiamso: the fd is supposed to get closed by hGetContents when it reaches EOF -- why would I need to close it explicitely anyways?
04:52:51 <mreh> I don't know why I put the Arrow in there
04:53:08 <mux> dcoutts_: I should reduce it to a simple test case first; I'll do that tonight when I'm at home I guess (i'm at work for now)
04:53:16 <soiamso> mux: GC problem. I have ask before in here.
04:53:37 <mreh> it's the same I'd imagine, Arrow (->) derives fmap from the instance of Functor for (->) I assume
04:53:49 <mux> well that would totally ruin what I'm trying to do; and I /know/ there are ways to have it working, otherwise many lazy parses on hackage wouldn't work
04:54:01 <mreh> @instance Functor
04:54:01 <lambdabot> Maybe you meant: instances instances-importing
04:54:04 <mreh> @instances Functor
04:54:05 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:54:13 <dcoutts_> mux: there's making sure the pipes are set up right in the first place, then there's issues with buffering, there have been issues in the past with pipes in blocking vs non-blocking mode.
04:54:33 <dcoutts_> mux: there's the possibility of deadlock if you don't drain stderr, etc etc
04:55:22 <soiamso> mux: may be i miss your point
04:55:23 <mux> as a matter of fact, I'm using the same code to create the pipe, and then using tagsoup to parse stdout
04:55:34 <mux> this works just fine; it starts running before the subprocess terminates
04:56:05 <mux> now, when I'm not using tagsoup but my own custom code for parsing the bytestring into lines and applying regexps on it, it behaves as I've described
04:56:27 <mux> also, I've disabled buffering to make sure it wasn't just that
04:56:30 <pozic> Does anyone know how much of monad transformers interpretations exists at run-time? I know that a few years ago adding a writer that didn't even output anything made the code run 10 times slower.
04:58:37 <ManateeLazyCat> dcoutts_: Haven't any way convert darcs-1 patch to darcs-2? I mean, i build new local repository, and convert every patch in gtk2hs to darcs-2 format, then push to patch-tag.com. It's possible?
04:59:09 <dcoutts_> ManateeLazyCat: yes you can do a one-off conversion, but then you cannot move patches between the old and new repositories.
05:02:38 <ManateeLazyCat> dcoutts_: You mean, if i build a darcs-2 mirror repository at patch-tag.com (read-only), and user's darcs-2 patch can't apply in gtk2hs main repo (darcs-1) ?
05:03:34 <ManateeLazyCat> dcoutts_: Mirror repository in patch-tag.com just read-only, don't accept any patches.
05:03:46 <dcoutts_> ManateeLazyCat: you cannot use patch-tag for a gtk2hs mirror
05:03:57 <ManateeLazyCat> dcoutts_: Why?
05:04:06 <dcoutts_> because you cannot move patches from a darcs-1 repo to a darcs-2 repo
05:05:27 <ManateeLazyCat> dcoutts_: Oh, i see, the only way is looking for other host to support darcs-1.
05:05:38 <dcoutts_> ManateeLazyCat: yes
05:06:21 <ManateeLazyCat> dcoutts_: Thanks, i try to looking for other host for darcs-1.
05:07:30 <mreh> are not all arrows functors?
05:07:51 <Taejo> @type arr
05:07:51 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:07:52 <mreh> fmap f = (>>> arr f)
05:08:08 <ManateeLazyCat> dcoutts_: Looks so hard that upgrade to darcs-2, except darcs-2 feature version can compatible with darcs-1 patches.
05:08:17 <Taejo> @type (>>>) . arr
05:08:18 <lambdabot> forall (cat :: * -> * -> *) a b c. (Arrow cat) => (a -> b) -> cat b c -> cat a c
05:08:29 <mreh> kind error
05:08:51 <ManateeLazyCat> Anyone know other host to support darcs-1 (except code.haskell.org) ?
05:08:54 <dcoutts_> ManateeLazyCat: it's not that hard to upgrade, the restriction is that you cannot continue to use both.
05:09:56 <ManateeLazyCat> dcoutts_: Can we force convert code.haskell.org to darcs-2, then let user upgrade it's darcs client?
05:10:31 <dcoutts_> ManateeLazyCat: the conversion has to be managed with the users of the repo, since everyone has to get their repo copies again.
05:11:07 <Saizan> so, is there an idiom to keep the main thread alive doing nothing?
05:13:04 <mreh> :t fmap
05:13:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:13:45 <dcoutts_> Saizan: block on an appropriate MVar
05:13:52 <mreh> :t (>>> arr f)
05:13:53 <lambdabot> forall (cat :: * -> * -> *) a b c. (Show b, SimpleReflect.FromExpr c, Arrow cat) => cat a b -> cat a c
05:14:18 <mreh> :t (\f -> (>>> arr f))
05:14:19 <lambdabot> forall (cat :: * -> * -> *) a b c. (Arrow cat) => (b -> c) -> cat a b -> cat a c
05:14:59 <scott__> How do I tell ghc to put my .o files in a specfic directory?
05:15:10 <pokoko222> oh man where are good old haskell days, i do c++ now for exam and gee what a language...
05:15:18 <ManateeLazyCat> scott__: Or use cabal.
05:15:44 <mreh> yes, use cabal, it's amazing
05:15:48 <ManateeLazyCat> scott__: Cabal will help you manager those files in separate directory.
05:15:55 <sadache> is there any semantic difference between a->b and Reader a b ?
05:16:09 <fax> @src Reader
05:16:09 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:16:25 <mreh> @src-importing
05:16:26 <lambdabot> Unknown command, try @list
05:16:26 <fax> newtype Reader e a = Reader { runReader :: (e -> a) }
05:16:32 <Saizan> dcoutts_: but i need some other thread to reference that MVar or else i'll get an exception, no?
05:16:42 <byorgey> scott__: try -odir DIR
05:16:55 <dcoutts_> Saizan: yes, but then the main thread has to wait for some event
05:16:56 <ManateeLazyCat> dcoutts_: BTW, have you test gtk2hs with ghc-6.12.2, it always got "segmentation fault", looks ghc-6.12.2 break gtk2hs binding, can you take a look?
05:17:08 <byorgey> sadache: no
05:17:09 <dcoutts_> ManateeLazyCat: sorry, not at the moment
05:17:30 <mreh> sadache: yes, but not between a->b and runReader (Reader a b) -- psuedo haskell
05:17:32 <ManateeLazyCat> dcoutts_: I have report a new bug to GHC team.
05:17:34 <sadache> I want to know if it signifies something to use a Reader rather than a function or vice versa
05:17:52 <byorgey> mreh: no, there is no *semantic* difference
05:18:07 <ManateeLazyCat> dcoutts_: And write mail that recommend user use ghc-6.12.1 instead 6.12.2, until feature fix version.
05:18:11 <mreh> if they are the same function?
05:18:26 <mreh> f == Reader f ?
05:18:38 <mreh> semantically
05:18:42 <sadache> mreh: yes
05:18:54 <fax> runReader is an isomorphism between Reader a b and a -> b
05:18:56 <mreh> really?
05:19:08 <sadache> like does it communicate any special intent the fact of using a Reader or a function of e
05:19:21 <benmachine> sadache: I think it's tidier sometimes?
05:19:24 <Saizan> in my case it just has to sit there until i hit ^C, i'll just use threadDelay in a loop i guess
05:19:34 <mreh> sadache, it's operationally different
05:19:39 <benmachine> but I don't think it makes a lot of difference really
05:20:13 <byorgey> sadache: ok, in that sense, I guess it sort of does.  a function is just a function.  using Reader e a  means you are thinking of it as something which computes an a, with the possibility of consulting a read-only environment e
05:20:23 <benmachine> sadache: particularly if you have a parameter that's getting thrown around a lot but only used occasionally perhaps?
05:20:40 <mreh> newtype RandA a b = RA (Kleisli Rand a b) deriving (Category, Arrow, ArrowApply, ArrowChoice) -- could I derive Functor here?
05:20:45 <benmachine> this is something which it's quite hard to find consensus on though I think
05:21:03 <benmachine> mreh: try it and see?
05:21:14 <mreh> benmachine, I hate it when people say that :)
05:21:24 <benmachine> sorry
05:21:29 <benmachine> but it's true!
05:21:38 <xerox> functors have kind * -> *
05:21:40 <mreh> RandA a is a functor
05:21:50 <dcoutts_> Saizan: and the rest of the program isn't doing anything? e.g. the hackage-server also waits on ^C, but it's blocked in an accept loop.
05:21:51 <xerox> RandA has kind * -> * -> *
05:22:09 <mreh> yeah, so (RandA a) is the Functor, is it clever enough to derive that?
05:22:15 <byorgey> mreh: yes, it is
05:22:15 <mreh> let's find out!
05:22:20 <mreh> oh good
05:22:22 <benmachine> mreh: Kleisli is a Functor but doesn't have an instance, I think
05:22:28 <sadache> byorgey: benmachine interesting. so im my context I have something that I call a servler which is actually a Request -> Response which can be also Reader Request Response
05:22:44 <mreh> @src Applicative
05:22:44 <lambdabot> class Functor f => Applicative f where
05:22:44 <lambdabot>     pure  :: a -> f a
05:22:44 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
05:22:47 <benmachine> sadache: I think if you always use the request then the function thing is clearer
05:22:49 <byorgey> Kleisli m a  is a functor only if m is
05:23:00 <benmachine> byorgey: oh, true
05:23:01 <dcoutts_> Saizan: I would expect that a signal handler that fills an MVar and the main thread blocking on that MVar would work.
05:23:02 <ManateeLazyCat> When i do "darcs convert" got error "darcs failed:  Pattern match failure in do expression at src/Darcs/Commands/Convert.lhs:133:2-13", new bug?
05:23:03 <ManateeLazyCat>  
05:23:41 <dcoutts_> ManateeLazyCat: check the darcs bug tracker and/or ask in #darcs
05:23:49 <XniX23> is there any good web mvc framework for haskell?
05:23:56 <benmachine> mreh: my guess is you won't be able to generalisednewtype derive it
05:24:05 <benmachine> but you might be able to -XDeriveFunctor derive it
05:24:16 <dcoutts_> Saizan: I'd expect the signal handler to keep the MVar alive and prevent a deadlock exception
05:24:30 <mreh> i'll just implement them myself, because I don't understand those extensions
05:24:32 <byorgey> sadache: I see.  For me I think the question would be one of implementation -- whether using Reader Request Response and do-notation/ask/asks etc. would make it clearer/easier to implement.
05:24:53 <benmachine> mreh: well, -XDeriveFunctor is pretty straightforward (albeit new to 6.12)
05:24:57 <sadache> benmachine: yes almost always, except that I have another type whihc is ComposableServlet which is Reader Request (Endo Response)
05:25:11 <benmachine> you turn it on and then you put deriving (Functor) and it does or it doesn't
05:25:30 <benmachine> sadache: that could make sense
05:25:35 <sadache> benmachine: and it is interesting to use <*> in there
05:25:36 <benmachine> sadache: honestly though I think it's up to you :P
05:25:47 <benmachine> you can use <*> on functions as well
05:26:00 <freiksenet> hello, I wonder if anyone use HaskellDB here.. I want to do my class project in haskell, and I was making a database spec with haskell db, and I could find how you can specify constrainst, such as foreign key constraints there.
05:26:18 <freiksenet> I couldnt*
05:26:36 <sadache> benmachine: since what I am writing is supposed to become a public api, I am asking because I am not the final user of this thing
05:27:11 <sadache> anyway your advices are very useful byorgey and benmachine
05:27:27 <benmachine> sadache: well in terms of usability, (->) has at least as many instances as Reader if not more
05:27:47 <benmachine> I'd be inclined to just use (->) but I'm sure other people have their own opinion
05:28:16 <benmachine> you can write an arrowed type signature and use ask/asks/local in the definition
05:28:19 <benmachine> that's fine too
05:29:30 <benmachine> but I've never actually written haskell that anyone else has read so maybe don't listen to me >_>
05:30:04 <mreh> @instances Functor
05:30:04 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:30:11 <mreh> where are the Arrows then?
05:30:33 <sadache> benmachine: I am sure if it adds to the context, but often i'll have a maybe inside  Reader Request Maybe Response and  Reader Request Maybe Endo Response and I was thinking of transformers too
05:31:10 <sadache> *i am NOT sure
05:33:25 <benmachine> transformers are interesting
05:33:38 <benmachine> you can write your functions to be polymorphic in the MonadReader class
05:33:48 <benmachine> that might be more of a headache than it's worth though
05:34:42 <Entroacceptor> why isn't main :: IO Int...
05:35:18 <sadache> benmachine: my point was to use <*> on Reader Request (Maybe Response) and  Reader Request (Maybe Endo Response)
05:35:23 <benmachine> Entroacceptor: 's a fair question, there are functions to specify the exit code though
05:36:18 <benmachine> :t liftA2 (<*>)
05:36:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Applicative f1) => f1 (f (a -> b)) -> f1 (f a) -> f1 (f b)
05:36:35 <benmachine> sadache: I dunno, you sound like you know what you're doing :P
05:37:42 <benmachine> mreh: I don't know why Kleisli doesn't have an instance, that is odd
05:37:49 <sadache> not really, I know the use of these things but I am afraid I am over complicating thigns.
05:38:08 <seeg> hello
05:38:23 <seeg> I'm playing around with ghci
05:38:27 <benmachine> hello
05:38:54 <dancor> :t runKleisli
05:38:55 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
05:39:01 <fax> so are we :P
05:39:05 <seeg> can someone explain to me why defining mySum (x:xs) = x + mySum xs raises an error "parse error on input '='"?
05:39:17 <benmachine> ghci is odd like that
05:39:20 <seeg> if i write this in a file and then load it, everything is fine
05:39:28 <sadache> anyway, lifting <*> turns me back to hesitation :)
05:39:29 <benmachine> put let on the beginning
05:39:51 <benmachine> sadache: that was just a neat way of demonstrating that Applicatives stack nicely
05:40:01 <benmachine> which is why there's no such thing as an Applicative transformer
05:40:07 <dancor> seeg: ghci behaves sort of like  main = do ..  so definitions need "let"s
05:40:41 <seeg> dancor, yeah, so i did it with let, and added let mySum [] = 0, but it gives now an error of a non-exhaustive pattern
05:40:51 <sadache> benmachine: very interesting, I've asked myself this question before
05:40:56 <benmachine> seeg: you have to define all the equations of a function in the same let
05:41:21 <benmachine> seeg: like, let mySum (x:xs) = x + mySum xs; mySum [] = 0
05:41:33 <benmachine> seeg: but usually if you want to do anything complicated, you use a file
05:41:38 <benmachine> and :reload as necessary
05:41:43 <benmachine> or (:r for short)
05:41:44 <seeg> ah, ok, it works nice now
05:41:45 <dancor> let f [] = "none"; f _ = "many"
05:42:02 <benmachine> you can also do :edit (or :e) to open the current module in your favourite editor
05:42:34 <seeg> i have to admit that this langage is a bit complicated :)
05:42:48 <benmachine> it's hard initially
05:42:53 <seeg> i've written lots of functional stuff in python and mathematica, but haskell is truly different
05:43:02 <benmachine> but when you get into it you find that a lot of things that used to be hard are easy now
05:43:10 <benmachine> (used to be hard in other languages)
05:43:29 <fax> seeg - I definitely agree and I think haskell is more complicaated than it needs to be,
05:43:45 <fax> seeg but compared to lots of other languages, it's not that bad
05:43:49 <mdmkolbe> What is the currently favored monad package? mtl? monads-fd? something else?
05:44:04 <dancor> i don't see why ghci can't detect .. = .. and grok those as lets correctly
05:44:20 <dancor> i guess it's hard to do overwriting
05:44:25 <dancor> redefining
05:45:04 <benmachine> mdmkolbe: it is widely acknowledged that there are problems with mtl, but it's in the haskell platform so people keep using it anyway
05:45:06 <dancor> but it's weird (and memory leak..) that ghci can do redefining anyway, seems like there should be explicit ghci :undef
05:45:42 <benmachine> dancor: I'm pretty sure that when you redefine, the old definition can be garbage collected
05:45:49 <benmachine> assuming there aren't still references to it
05:46:04 <dancor> benmachine: well ghc doesn't actually ever free memory it's an open bug
05:46:09 <benmachine> :r removes all local definitions
05:46:11 <benmachine> oh
05:46:17 <benmachine> well okay
05:46:23 <dancor> i guess i was misleading
05:46:27 <benmachine> that's not exactly a leak though because the memory can be reused
05:46:28 <seeg> oh, and one more thing i've noticed: when i do the fibonacci function like: let fib = if n == 1 then 1 else if n == 2 then 2 else (fib (n - 1)) + (fib (n - 2))
05:46:35 <dancor> right
05:46:35 <seeg> then computing fib 100 takes very long
05:46:40 <dancor> but it can be
05:46:47 <benmachine> seeg: that's because that's a hugely inefficient way of doing it :)
05:46:53 <seeg> but if i do: let fibs = 1 : 2 : zipWith(+) fibs (tail fibs) the its very fast
05:46:58 <seeg> benmachine, why?
05:47:13 <benmachine> seeg: in the former case, each call to fib spawns two more calls to fib
05:47:34 <seeg> but the fib's values are memoized, right?
05:47:40 <benmachine> nope
05:47:45 <benmachine> the results aren't shared because they need them at different times and in different places
05:47:54 <benmachine> so it's quite complicated to work out what goes where and when
05:47:58 * dancor is going to stand firm; it's a leak
05:48:04 <seeg> so how to write a memoized fib function?
05:48:19 <benmachine> seeg: the latter one?
05:48:55 <seeg> yeah, but the last one is a list if i can tell correctly, what if i wanted a function?
05:49:04 <benmachine> use !! with it
05:49:12 <benmachine> let fib n = fibs !! n
05:49:53 <seeg> !! gives the n-th element of a list?
05:49:57 <benmachine> yeah
05:49:59 <benmachine> :t (!!)
05:50:01 <lambdabot> forall a. [a] -> Int -> a
05:51:06 <benmachine> @src (!!)
05:51:07 <lambdabot> xs     !! n | n < 0 = undefined
05:51:07 <lambdabot> []     !! _         = undefined
05:51:07 <lambdabot> (x:_)  !! 0         = x
05:51:07 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:51:51 <seeg> ah, ok, nice
05:52:28 <dancor> benmachine: there will eventually be an mtl-2 that fixes everything right?
05:52:29 <seeg> and the fib function isn't memoized for what reason?
05:52:47 <benmachine> dancor: pass, I don't know what the process is
05:52:48 <seeg> if i call fib 30 it computes for some time, but if i do it again shouldn't the result appear quickly?
05:53:03 <benmachine> seeg: which fib function are we talking about now?
05:53:09 <dancor> and until then (even then?) we're stuck since using the other stuff now creates insanity since instances are global
05:53:10 <seeg> the one at the beginning
05:53:12 <seeg> the slow one
05:53:37 <benmachine> seeg: well, GHC doesn't know what results of functions it's going to need again later
05:53:41 <dancor> fax: what are some of the more egregious overcomplexities of haskell
05:53:59 <benmachine> seeg: if you stored the result of every function every time you called it, you'd run out of memory pretty quickly
05:54:07 <seeg> yeah, ok
05:54:12 <dancor> i think laziness makes perf very hard but i'm still hoping i'll come to appreciate it someday
05:54:16 <fax> dancor well I mean the haskell GHC implements for a start
05:54:44 <fax> dancor, so generally it's just the effect of layer on more and more features -- without having time to take a step back and abstract them all out
05:54:50 <pozic> dancor: there are these things called bangpatterns.
05:55:10 <dancor> pozic: ya but i never know where to use them
05:55:22 <fax> dancor, but for a specific example - it seems like almost all of the typeclass extensions could be unified
05:55:27 <pozic> dancor: that is because you should not guess, you should know what you are doing.
05:55:36 <dancor> i used the word "know"
05:55:54 <pozic> dancor: if you don't know what you are doing evaluate some expressions by hand until you do.
05:56:01 <fax> great derailed
05:56:10 * ManateeLazyCat It's will be cool if google codes support darcs.
05:57:03 <seeg> oh, and another thing: is it possible to define fib like: let fib = (1:2:zipWith (+) $_ (tail $_)) !! n?
05:57:11 <seeg> i've used perlish syntax ;)
05:57:11 <benmachine> fax: I dunno, UndecidableInstances is very different from OverlappingInstances imo
05:57:51 <benmachine> seeg: hmmm
05:58:18 <idnar> AllSortsOfInstances
05:58:42 <benmachine> @pl fib n = fix (\fibs -> 1 : 2 : zipWith (+) fibs (tail fibs)) !! n
05:58:42 <lambdabot> fib = (fix ((1 :) . (2 :) . ap (zipWith (+)) tail) !!)
05:59:01 <fax> benmachine: UndecidableInstances is actually one of the exceptional cases I was excluding
05:59:21 <benmachine> fax: okay, but are you suggesting that Overlapping should imply Incoherent?
05:59:38 <benmachine> what about Flexible? that seems entirely more innocuous than any of the others
05:59:47 <fax> benmachine: I was thinking a bit more of a global change than thta
06:03:41 <dancor> pozic: what do you mean by evaluating an expression by hand
06:04:55 <pozic> dancor: I mean to start simple with evaluating 1 + 2 lazilly and then you replace 1 by something more complicated and so on.
06:05:22 <pozic> dancor: then you add recursion, data types until you understand the whole machinery.
06:05:35 <pozic> dancor: there are also a few books which do this
06:06:22 <dancor> pozic: what are some of the books
06:07:08 <pozic> dancor: Algorithms: A Functional Programming Approach
06:07:20 <pozic> dancor: but you should not buy the book.
06:07:20 <fax> well integers in haskell are exceptional
06:07:29 <pozic> dancor: it contains about two useful pages.
06:07:56 <fax> haskell programming is strict as well as lazy, when you do numerics it should be strict
06:09:28 <dancor> i still feel like i'm not going to get any good at haskell perf without really learning core and doing other such things that are much much more of a commitment than improving at perf in other languages
06:09:48 <dancor> and i'm also not sure if i should wait to really try until there are better tools for it
06:10:48 <dancor> i should just make the commitment and write those tools ;)
06:12:14 <pozic> dancor: if you want good Haskell performance, you have to write your own compiler ;)
06:12:23 <dancor> the programmer is the code
06:12:33 <pozic> GHC is not an optimizing compiler, so you lose there already.
06:14:22 <Saizan_> what definition of optimizing compiler are you using here?
06:15:39 <EvanR> -O2
06:15:52 <EvanR> shootout cant lie!
06:16:25 <pozic> Saizan_: I mean that it does every optimization known to date.
06:19:48 <benmachine> pozic: that's quite a stringent criterion
06:20:04 <benmachine> as soon as any optimisation method is discovered every optimising compiler loses its title :)
06:21:34 <benmachine> I guess GHC emphasises correctness and functionality and usability more than performance in some cases
06:21:46 <benmachine> but it does do a lot of optimisation and wants to do more
06:22:02 <pozic> I think things have changed.
06:22:21 <pozic> It used to be possible to find exact quotations of what I said.
06:22:58 <benmachine> I suppose you'd consider something like JHC to be an optimising compiler
06:23:06 <benmachine> but that's not to say you can't get performance out of GHC
06:24:04 <seeg> ok, gotta go
06:24:13 <seeg> benmachine, thank you very much for your help
06:24:17 <pozic> benmachine: I agree. If you want performance, you can get it.
06:24:26 <Twey> If you want good Haskell performance, you should write code that opportunistically optimises itself every time it runs using information on the latest techniques garnered from the Web.  ;)
06:25:21 <HugoDaniel> Twey ? :P
06:25:44 <Saizan_> http://www.idsia.ch/~juergen/goedelmachine.html <- starting from this, i suppose
06:25:51 <HugoDaniel> if you want good haskell performance, i would recomend profiling and writing in C the pure functions that are stalling stuff
06:26:43 <HugoDaniel> Saizan_: oh, that reminded me of nam june paik :/
06:26:54 <pozic> Saizan_: that is only for provable good performance.
06:27:05 <pozic> Saizan_: how many people actually do that? ;)
06:27:27 <HugoDaniel> http://images.google.pt/images?um=1&hl=pt-PT&client=opera&rls=en&tbs=isch%3A1&sa=1&q=Pre-Bell-Man+nam+june+paik&aq=f&aqi=&aql=&oq=&gs_rfai=&start=0
06:28:56 <sanyi> is there some library i can play sound with? (preferably cross-platform)
06:29:12 <HugoDaniel> sanyi: fmod
06:29:20 <HugoDaniel> im not sure if there are bindings for haskell though
06:29:24 <dancor> HugoDaniel: why pure functions in particular?
06:29:33 <HugoDaniel> sanyi: should we take care of that ?
06:29:49 <HugoDaniel> dancor: because those are the easiest ones to start with
06:30:17 <sanyi> FFI should work with fmod, right?
06:30:36 <HugoDaniel> the thing about optimization is to choose the shortest path possible to achieve the desired performance
06:30:47 <HugoDaniel> sanyi: yes
06:31:15 <sanyi> ok, then... any alternatives i should consider?
06:31:20 <HugoDaniel> openal
06:32:03 <HugoDaniel> http://hackage.haskell.org/package/OpenAL
06:32:06 <sanyi> and openal has haskell bindings? or FFI too?
06:32:26 <sanyi> HugoDaniel: thanks, looks great
06:32:49 <dancor> ALUT has cool sine generators
06:34:38 <benmachine> how well does jhc's cross-compiling work?
06:34:43 <benmachine> and how many libraries are compatible?
06:35:47 <HugoDaniel> anyone would like to join in doing a binding for glm (http://glm.g-truc.net/) ?
06:36:11 <HugoDaniel> its c++, pain is bundled
06:43:34 <Eelis> how come pattern guards aren't supported in lambda expressions? (e.g.   \x | p x -> a; | q x -> b; | otherwise -> c  )
06:43:47 <xerox> you could case it
06:43:53 <Eelis> i know, but it's ugly
06:43:57 <xerox> then give it a name
06:44:01 <xerox> :|
06:44:13 <Botje> Eelis: haskell isn't ml :)
06:44:16 <Eelis> yes, there are lots of ugly workarounds. but i want to know why i can't write what i'd expect i could write :)
06:44:57 <Eelis> Botje: that much i gathered, but that doesn't answer my question at all
06:45:02 <xerox> :P
06:50:28 <benmachine> > case () of () | x <- () -> x -- cute
06:50:29 <lambdabot>   ()
06:51:03 <benmachine> > case () of () | (\x -> x -> x) <- () -> (\x -> x) x -- less so
06:51:04 <lambdabot>   ()
06:51:22 <Eelis> i find myself doing "case () of" all too often. again one of those places where Haskell is really ugly
06:51:24 * benmachine still amused by lambda view patterns
06:51:32 <benmachine> Eelis: I've like never done it ever
06:51:43 <Eelis> benmachine: i'm happy for you
06:51:46 <benmachine> ref. http://haskell.org/haskellwiki/Case
06:52:10 <benmachine> there are plenty of ways of doing a similar thing that don't require ugly
06:52:39 <Eelis> yes yes, i'm familiar with the "make it a separate function!" mantra
06:52:52 <benmachine> who said make it a separate function?
06:53:02 <Eelis> that's the usual response.
06:53:20 <benmachine> well, it's not your only option
06:53:31 <benmachine> (although it's not a bad one either :) )
06:54:56 <benmachine> cond1 ? ex1 $ cond2 ? ex2 $ cond3 ? ex3 $ default is quite nice I think
06:55:19 <benmachine> I wonder if that could be rewritten without using the right-associativity of $
06:55:28 <benmachine> depends on the fixity of ? I suppose
06:55:30 <Eelis> that doesn't work for general patterns, so again it's a great example of an ugly workaround.
06:55:36 <benmachine> it's not ugly
06:55:40 <benmachine> it's not a workaround
06:55:47 <benmachine> it's a tool that does a job
06:55:57 <benmachine> if you want actual pattern matching, do a normal case?
06:55:57 <dancor> i like the (?) one on that page
06:56:20 <benmachine> yeah
06:56:28 <dancor> it seems like less syntax than a case statement!
06:56:51 * dancor can't wait to start using it
06:56:58 <benmachine> well it does a different job
06:57:10 <benmachine> case is about pattern matching, guards are just an added convenience
06:57:27 <benmachine> well ok guards are very convenient
06:57:30 <benmachine> but that's not the point :P
06:57:44 <dancor> couldn't you also use view patterns
06:57:53 <Eelis> heh, you know workarounds presented on the wiki are contrived if they're not even included in any of the base libraries ;)
06:57:58 <benmachine> possibly
06:58:12 <dancor> anyway i'm sold on (?)
06:58:22 <benmachine> Eelis: you know monad transformers are contrived if they're not in any of the base libraries, right?
06:58:35 <benmachine> kind of a weird argument :)
06:58:56 <Eelis> benmachine: hah, i'm disappointed in you. you'd honestly compare a 3 line piece of code with a behemoth like monad transformers? for shame!
07:00:35 <benmachine> Eelis: they are equally not-in-base
07:00:46 <Eelis> no shit
07:00:46 <benmachine> thus demonstrating that not-being-in-base does not imply contrivedness
07:01:00 <benmachine> lots of stuff isn't in the base libraries
07:01:17 <Eelis> which was not my argument. my claim was restricted to workarounds presented on the wiki, and in the context even to the type of workarounds presented on the page you cited.
07:01:43 <benmachine> your argument was that they were contrived, and you presented as evidence that they were not in base
07:01:50 <chrisdone> phew
07:02:01 <chrisdone> i just changed a monad and spent 15 minutes updating all my code to work with it
07:02:07 <chrisdone> i are a winrar over the types
07:02:19 <benmachine> heh
07:02:24 <benmachine> refactoring = woo.
07:02:35 <benmachine> my argument was oh who cares really
07:02:50 <Eelis> benmachine: i have no need to defend arguments that you're deliberately misconstruing.
07:03:31 <benmachine> Eelis: I don't mean to be dishonest
07:03:40 <Eelis> i'll have to take your word for it.
07:04:02 <benmachine> I used a ridiculous example because otherwise it wouldn't have demonstrated anything
07:04:22 <benmachine> you of course have no need to defend anything, it doesn't actually matter
07:04:45 <benmachine> but it sounds like you're unhappy with the way you think haskell does things so I would like to persuade you that there are nice ways of doing it
07:05:06 <Eelis> there is a nice way: LambdaCase. but apparently the simons don't like it, so i'm fucked :)
07:05:29 <Eelis> erm, i mean MultiWayIf
07:06:21 <chrisdone> lambdacase is \case x of ... ?
07:06:31 <Eelis> http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase , http://hackage.haskell.org/trac/haskell-prime/wiki/MultiWayIf
07:06:41 <benmachine> I think lambdacase is usually proposed as "case of"
07:06:48 <benmachine> but it's a different idea
07:07:10 <Eelis> i'm also a big fan of LambdaCase. in fact, i use   #define case_of \caseof_detail -> case caseof_detail of   just to make up for its absence
07:07:38 <benmachine> I quite like lambdacase but as people have pointed out it saves you like seven characters
07:07:53 <chrisdone> yeah i can't see lambda case being that amazing
07:07:54 <Jafet> I don't like if, actually
07:08:06 <benmachine> Jafet: you're not alone in that
07:08:13 <chrisdone> Jafet: yeah i'd prefer there to be no if syntax at all
07:08:29 <benmachine> there are arguments either way
07:08:35 <Jafet> Is if' semantically different in any way?
07:08:46 <benmachine> it does exactly the same job
07:08:49 <chrisdone> what I DO want is:
07:08:49 <chrisdone>   case do doesFileExist "foo" of
07:08:49 <chrisdone>     True  -> ..
07:08:49 <chrisdone>     False -> ..
07:09:11 <benmachine> chrisdone: covered by lambdacase I think
07:09:16 <benmachine> doesfileExist "foo" >>= case of
07:09:22 <chrisdone> not really
07:09:33 <chrisdone> i have to write bind ..
07:09:42 <benmachine> huh?
07:09:45 <chrisdone> kinda ruins the whole do notation loveliness
07:09:54 <benmachine> no it doesn't
07:09:56 <chrisdone> ok
07:09:59 <benmachine> well fine
07:10:02 <benmachine> matter of opinion
07:10:08 <benmachine> but I put binds in my do-notation sometimes
07:10:23 <benmachine> you can mix the two
07:11:08 <Jafet> Well, with this lambdacase thing you can then use lift
07:11:29 <Jafet> Which is again of dubious utility
07:11:37 <ManateeLazyCat> hamishmack: I have fix TextView signals problem, please pull again.
07:11:47 <ManateeLazyCat> hamishmack: Sorry for inconvenience.
07:12:07 <hamishmack> ManateeLazyCat: cool thanks
07:13:42 <ManateeLazyCat> hamishmack: Just one change: rename `setScrollAdjustments` to `setTextViewScrollAdjustments` for avoid conflict with signal in other module.
07:14:16 <ManateeLazyCat> hamishmack: Any other signals same as gtk2hs-0.10.1
07:14:58 <ManateeLazyCat> hamishmack: BTW, we have remove `onFoo` and `afterFoo` signals from TextView, please convert it to `on foo` and `after foo`.
07:15:42 <xezz> @pl C.isDigit x =  if (C.digitToInt x) + 1 > 9 then '0' else C.intToDigit ((C.digitToInt x) + 1)
07:15:42 <lambdabot> C.isDigit = ap (flip if' '0' . (> 9) . (1 +) . C.digitToInt) (C.intToDigit . (1 +) . C.digitToInt)
07:16:00 <hamishmack> ManateeLazyCat: ok
07:17:10 <chrisdone> so here are some ideas for ways of writing html in haskell https://gist.github.com/6d384947c55c9fbbaadb
07:17:10 <chrisdone> i haven't written any documentation but the basic ideas are:
07:17:10 <chrisdone>   form 1: body << (h1 [("class","main-title")] ++ p [("class","foo")] << "bar")
07:17:10 <chrisdone>   form 2: body $ h1 ! [("class","main-title")] ++ (p ! [("class","foo")] $ "bar")
07:17:13 <chrisdone>   form 3: body $ do h1 ! [("class","main-title")]; p ! [("class","foo")] $ "bar"
07:17:16 <chrisdone> they're all about the same amount of typing. i like form 1 for not having to type !, but i like form 3 because of the lack of parens and indentation-sensitivity
07:17:20 <chrisdone>              
07:17:23 <chrisdone>   
07:18:07 <ManateeLazyCat> darcsden.com like patch-tag.com just support darcs-1, unfortunately for gtk2hs.
07:18:14 * Jafet calls the space monster
07:19:15 <xezz> @src foldr1
07:19:16 <lambdabot> foldr1 _ [x]    = x
07:19:16 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:19:16 <lambdabot> foldr1 _ []     = undefined
07:21:36 <benmachine> chrisdone: I think do is overrated, I'd go with option 1
07:21:42 <benmachine> since you can always indent things nicely yourself anyway
07:21:57 <benmachine> buuuut
07:22:09 <benmachine> I dunno I've not done that sort of thing very often
07:23:31 <benmachine> other considerations: more polymorphism can be more confusing
07:23:41 <benmachine> especially in terms of the quality of error messages
07:24:12 <alise> data Nested a = Nil | Cons a (Nested a) | Nest (Nested a) (Nested a)
07:24:17 <alise> Should I just use a tree for this?
07:24:39 <dcoutts_> alise: that is a tree
07:24:51 <alise> Yes.
07:24:55 <alise> But it's not your "typical"
07:25:05 <alise> data Tree a = Node a | Branch (Tree a) (Tree a)
07:25:07 <dcoutts_> use the kind of tree that fits the problem
07:25:10 <alise> It is more useful though, so I'll use it :P
07:26:13 <chrisdone> benmachine: i'm not really worried about that kind of confusion, it doesn't confuse me and i'm the baseline
07:26:57 <chrisdone> benmachine: you can indent the other two forms, but you still need to balance other pieces of syntax to make it work. with this form all you have to do is indent
07:27:41 <chrisdone> you have to make sure that you use ($) and other operators properly and balance (++)
07:28:05 <chrisdone> imo it's a real pain in the bum to read and write for nontrivial pages
07:28:20 <chrisdone> (just look at hpaste's source)
07:28:32 <chrisdone> and that is a fairly trivial site
07:30:50 <ManateeLazyCat> Found darcden.com, unfortunately, just support darcs-2 like patch-tag.com
07:31:32 <fax> hi chrisdone
07:31:52 <chrisdone> hey
07:32:54 <sergey_miryanov> hi, all
07:33:03 <sergey_miryanov> i'm reading a RWH
07:33:14 <sergey_miryanov> and a bit confused
07:33:34 <sergey_miryanov> i try to do type RST a = State String a
07:33:57 <sergey_miryanov> but haskell says Not in scope: type constructor or class `State'
07:34:10 <sergey_miryanov> i import Control.Monad.ST.Lazy - same result
07:34:11 <BMeph>  /msg nickserv identify Ebon69Drake
07:34:12 <Botje> sergey_miryanov: you need to import the Control.Monad.State module
07:34:15 <Jafet> @hoogle State
07:34:15 <lambdabot> module Control.Monad.State
07:34:15 <lambdabot> Test.HUnit.Base data State
07:34:16 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
07:34:37 <BMeph> Okay, time to change _that_ pw... ;)
07:35:12 <xezz> hahaha xD
07:35:18 <sergey_miryanov> Prelude Control.Monad.ST> :m Control.Monad.State
07:35:18 <sergey_miryanov> <no location info>:
07:35:18 <sergey_miryanov>     Could not find module `Control.Monad.State':
07:35:18 <sergey_miryanov>       it is not a module in the current program, or in any known package.
07:35:18 <sergey_miryanov> Prelude Control.Monad.ST>
07:35:20 <dancor> i've seen more revealing pws, but not many ;)
07:35:40 <sergey_miryanov> btw, I have ghc 6.12.2 built from source
07:36:54 <dv-> :m +Control.Monad.State
07:37:29 <xezz> is it possible to eliminate this if then else in: foldl1 (\k acc -> if k > acc then k else acc) (It should read a list and return the highest value)
07:37:46 <Botje> xezz: max k acc
07:38:08 <Botje> xezz: also, there's a maximum function which does just that
07:38:10 <pozic> Botje: wrong: maximum
07:38:17 <pozic> Botje: Oh, I see.
07:38:21 <pozic> Botje: never mind :)
07:38:29 <sergey_miryanov> @dv- same result :(
07:38:29 <lambdabot> Maybe you meant: do v
07:38:36 <xezz> not allowed to use maximum
07:38:48 <Botje> sergey_miryanov: when building, did you add the extra libs ?
07:38:56 <Botje> i think control.monad.state is in there
07:39:07 <xezz> @src maximum
07:39:07 <lambdabot> maximum [] = undefined
07:39:08 <lambdabot> maximum xs = foldl1 max xs
07:39:58 <sergey_miryanov> @Botje I do
07:39:58 <sergey_miryanov> $ ./configure
07:39:58 <sergey_miryanov> $ make
07:39:58 <sergey_miryanov> $ make install
07:39:58 <lambdabot> No such poll:"I"
07:40:08 <chrisdone> fax: what you working on?
07:40:31 <Botje> sergey_miryanov: so your answer is no.
07:41:05 <fax> chrisdone - I should do some [navier stokes] study today
07:41:05 <sergey_miryanov> ohsi
07:41:46 <Botje> sergey_miryanov: have you looked at the haskell platform?
07:42:12 <mun__> hi
07:43:00 <chrisdone> fax: fluid mechanics that's really cool
07:43:18 <sergey_miryanov> Botje, no, I want to try this way, I think it will be more useful to Haskell understanding
07:43:52 <sergey_miryanov> Botje, i will try to install Control.Monad ;)
07:44:26 <fax> chrisdone - it's realy difficult!
07:45:17 <mun__> if i have a formula ALL a:reals. f(a), would one say f(3) is a 'model' of that formula?
07:45:25 <Saizan_> sergey_miryanov: http://hackage.haskell.org/package/mtl , http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
07:46:14 <sergey_miryanov> Saizan_, 10x!
07:46:51 <fryguybob> I'm trying to build gtk2hs and when I get to pango gtk2hsC2hs doesn't seem happy with spaces in the files names for include: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25293
07:47:45 <dcoutts_> fryguybob: report it. That bug has been fixed in the mainline c2hs version, but not in the gtk2hs fork of c2hs.
07:47:53 <fryguybob> ok
07:48:07 <dcoutts_> fryguybob: the bug was in how c2hs invoked cpp, using system rather than rawSystem
07:49:22 <fryguybob> It seems like 99% of cross platform bugs when going from Unix -> Windows involve spaces in paths...
07:49:51 <Jafet> The other 1% being capitalization
07:50:34 <ManateeLazyCat> dcoutts_: You mean it's problem of c2hs branch in gtk2hs?
07:50:43 <dcoutts_> ManateeLazyCat: yes
07:51:08 <Sidmouth> Can someone tell me if I can expect (head . Data.List.sort) to be O(n) in GHC?
07:51:09 <ManateeLazyCat> fryguybob: Which version of ghc?
07:51:38 <fryguybob> ManateeLazyCat: 6.12.1
07:51:44 <Botje> sergey_miryanov: worse
07:51:49 <Botje> err
07:52:03 <Jafet> Sidmouth, for an appropriately mediocre value of O
07:52:16 <Botje> Sidmouth: i'd use an explicit minimum call, actually
07:52:23 <lowasser> um
07:52:25 <Jafet> @src sort
07:52:25 <lambdabot> sort = sortBy compare
07:52:31 <Jafet> @src sortBy
07:52:32 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:52:36 <lowasser> not in GHC
07:52:38 <Jafet> Haha
07:52:44 <lowasser> that is, that's not GHC's definition
07:52:51 <lowasser> that said, yes, it'll be O(n)
07:53:02 <ManateeLazyCat> dcoutts_: Why Axel don't like use mainline c2hs, have any speical reason?
07:53:25 <sergey_miryanov> Botje: why?
07:53:28 <dcoutts_> ManateeLazyCat: it's quite a lot of work to switch back, but it should be done eventually.
07:53:59 <ManateeLazyCat> dcoutts_: Axel is too busy like you. :)
07:54:04 <lowasser> an explicit minimum call is, of course, more optimized for the specific task of finding a minimum
07:54:04 <dcoutts_> yep
07:54:30 <Sidmouth> More generally my question is about whether (take k . sort) will be O(n*k).
07:54:37 <ManateeLazyCat> dcoutts_: I have some spare time, but haven't enough knowledge to do that, still in studying.
07:55:00 <Sidmouth> The implementation with insertBy in the Haskell 98 report suggests not.
07:55:30 <Saizan_> Sidmouth: ghc uses a lazy bottom up mergesort
07:55:46 <ManateeLazyCat> dcoutts_: Let me guess, "segmentation fault" between gtk2hs with ghc-6.12.2 perhaps cause by c2hs-branch?
07:55:54 <dcoutts_> Sidmouth: the H98 spec does not guarantee any performance bounds, it does not talk about performance at all.
07:56:01 <ManateeLazyCat> dcoutts_: Because looks much binding is break with 6.12.2.
07:56:07 <dcoutts_> ManateeLazyCat: doubt it
07:56:21 <Jafet> Sidmouth, GHC makes it Î˜(n log k).
07:56:37 <ManateeLazyCat> dcoutts_: Because we haven't add any new code before upgrade to 6.12.2
07:57:11 <Botje> sergey_miryanov: tab misfire
07:58:15 <sergey_miryanov> Botje: ??
07:58:18 <sergey_miryanov> tab misfire
07:59:26 <Botje> ignore it.
08:01:10 <HugoDaniel> anyone would like to join in doing a binding for glm (http://glm.g-truc.net/) ?
08:08:22 <fryguybob> dcoutts_: I added a ticket, but it gave an error when trying to attach the log (permission denied), and I thought that meant it didn't add the ticket, so it's up there twice, sorry.
08:10:02 <dcoutts_> fryguybob: ok thanks
08:10:35 <ManateeLazyCat> fryguybob: So except "space" problem, everything is fine?
08:10:51 <ManateeLazyCat> fryguybob: Just interested the gtk2hs status on Windows.
08:11:47 <fryguybob> ManateeLazyCat: Well I can't really get passed that.  I also had a similar issue when I had to use --extra-include-dir= for GTK's include dir and gave up and moved that to a dir without spaces.
08:13:02 <ManateeLazyCat> fryguybob: Can you post your log on gtk2hs-list, please?
08:13:32 <ManateeLazyCat> fryguybob: Then Axel will push a patch to c2hs-branch (gtk2hs) to fix your problem.
08:15:10 <fryguybob> ManateeLazyCat: gtk2hs-devel?
08:15:24 <ManateeLazyCat> fryguybob: Yes.
08:16:19 <dcoutts_> fryguybob: he's referring to the mailing list
08:16:48 <fryguybob> dcoutts_: right, there just appear to be two users and devel.
08:18:01 <Lally> hi all
08:18:09 <fax> hello lally
08:18:31 <Lally> hi fax
08:20:25 <hamishmack> dcoutts_: Is there a way to hook into the pkg-config code in cabal to mess with pkg-config --libs results on windows?
08:20:41 <dcoutts_> hamishmack: what are you really trying to do?
08:20:48 <dcoutts_> what is the original problem?
08:21:10 <hamishmack> dcoutts_: Fix external-libraries on windows
08:21:33 <hamishmack> it used to be done in a post process step on the .conf file
08:21:45 <hamishmack> windows has no symbolic links
08:21:55 <dcoutts_> hamishmack: so what's the problem exactly? that pkg-config gives you bogus information?
08:22:03 <hamishmack> so we need to resolve the name to a specific dll somehow
08:22:30 <dcoutts_> hamishmack: is this a dll naming issue? is it specific to ghci?
08:22:40 <hamishmack> yes
08:22:46 <hamishmack> ghc is fine
08:23:01 <hamishmack> ghci and I think template haskell fail
08:23:15 <Lally> anyone has some example of parser SLR with haskell?
08:23:16 <dcoutts_> hamishmack: ok, so I suggest we report this as a ticket against ghc, to ask that the ghci linker follow the same convention as the static linker
08:23:53 <hamishmack> dcoutts_: that sounds good
08:23:59 <dcoutts_> hamishmack: or is it harder, like having foo.a and that points to foo-0.dll ?
08:24:28 <dcoutts_> hamishmack: what is the specific example? what are the names of the static and/or dynamic libs
08:24:58 <hamishmack> dcoutts_: external-libraris: glib-2.0
08:25:08 <fax> What is SLR??
08:25:12 <hamishmack> but the dll is glib-2.0-0.dll
08:25:27 <dcoutts_> hamishmack: ah, the gtk dlls use this versioning convention, yes very annoying.
08:25:42 <dcoutts_> hamishmack: and there's no sensible way for ghci find out the names of the dlls.
08:25:49 <Lally> http://en.wikipedia.org/wiki/Simple_LR_parser
08:26:03 <fax> oh okay I thought itw as somethign to do with digital camera
08:26:21 <fax> this is interesting
08:26:27 <dcoutts_> hamishmack: so this is why we added the "extra-ghci-libs" field as a hack for ghci. I requested this feature for gtk2hs some years ago.
08:28:42 <dcoutts_> hamishmack: so I'm wondering if it'd be possible to put code in the Setup.hs of your package so that it adds that field into the package registration into
08:28:44 <dcoutts_> info
08:28:50 <scotty> hello!
08:29:47 <scotty> im stumped on a pretty simple list operation thing
08:30:05 <scotty> is anyone willing to talk it out with me?
08:30:20 <fax> what is it?
08:30:38 <scotty> well i have a list of a few hundred ints
08:30:50 <scotty> and i have a percentage of items i'd like to remove
08:30:58 <chrisdone> hmmm
08:30:58 <scotty> it might not divide evenly
08:31:09 <scotty> actually, it most often will not
08:31:16 <scotty> but i want to space the deletions evenly
08:31:22 <chrisdone> monads are hard when one monad wants to wrap another
08:31:52 <chrisdone> withContinuedSession :: (Typeable a, ISession sess) => ConnectA sess -> (forall mark. DBM mark sess a) -> IO (a, ConnectA sess)
08:31:58 <chrisdone> BDM is an instance of MonadIO
08:32:16 <chrisdone> so i can run another MonadIO monad inside it
08:32:37 <chrisdone> but that other monad is the same as this one, it has one function in order to 'get inside' the monad
08:32:43 <hamishmack> dcoutts_: Currently it is using defaultMainWithHooks.  Which of the hooks should I look at modifying?
08:32:52 <chrisdone> ugh
08:33:00 <dcoutts_> hamishmack: the regHook
08:34:00 <dcoutts_> hamishmack: you'd need to call generateRegistrationInfo to get at the InstalledPackageInfo
08:35:14 <fax> scotty: wait
08:35:20 <Botje> scotty: split your list into chunks (of appropriate size) and delete the first element of each chunk
08:35:30 <fax> scotty: you want to randomly drop k elements of a lenght n+k list?
08:35:37 <fax> (I have implemented this)
08:35:38 <scotty> yes exactly
08:35:41 <scotty> YES!
08:35:41 <dcoutts_> hamishmack: and then registerPackage to actually do it, after modifying the InstalledPackageInfo so as to add the info to the extraGHCiLibraries field
08:35:48 <fax> lol this is so funny
08:35:54 <scotty> OMG you saved my life
08:35:57 <fax> you're the third person who benefits from this program
08:35:58 <scotty> well, not really
08:36:05 <fax> A lot of people come in here wanting this program
08:36:09 <scotty> but it makes me extremely happy
08:36:14 <scotty> thanks so much!
08:36:21 <Jafet> "randomly"?
08:36:22 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25068
08:36:29 <fax> Do you understand how it works?
08:36:50 <scotty> err
08:36:52 <scotty> let me try it out
08:37:01 <fax> you can't understand it by running it
08:37:03 <hamishmack> dcoutts_: Thanks. I'll give it a go.
08:37:21 <scotty> can you explain?
08:37:29 <fax> yes
08:38:10 <scotty> where does roll come from?
08:39:08 <fax> scotty, it's left unimplemented because it is a parameter
08:39:20 <fax> for example: In your case you would implement it in the random monad
08:39:30 <fax> but others may implement it in a different monad
08:39:35 <scotty> gotcha
08:39:45 <fax> there are some post conditions on it
08:40:02 <fax> if probability is 0 (or less) it must return False, if probability is 1 (or more) it must return True
08:40:12 <BMeph> fax: Just a minor quibble, but I'd use "pure []" vice "return []", to let it just be an Applicative. :)
08:40:29 <fax> BMeph: cool - I didn't know that actually thanks
08:40:40 <Jafet> That does not remove n items...
08:40:49 <scotty> ?
08:40:50 <Oejet> fax: So the paste is pseudo code?
08:40:59 <chrisdone> haha a guy here even sneezes in a different accent
08:41:21 <chrisdone> "pfHEI"
08:41:46 <fax> Oejet no it's haskell
08:41:55 <scotty> honestly, im still pretty confused.
08:41:57 <fax> lol chrisdone
08:42:02 <fax> scotty - what about/
08:42:02 <fax> ?
08:42:09 <fax> I should blog about this function
08:42:14 <scotty> please do!
08:42:36 <Jafet> fax, what does dropr do?
08:42:37 <chrisdone> fax: something to blog about!!
08:42:48 <fax> oooh ooh something to bloggg about
08:42:51 <chrisdone> :P
08:42:56 <Oejet> fax: How would you invoke it for example?
08:43:11 <fax> Oejet, just as anyone would, remember to pass in the length of the list though
08:43:23 <fax> chrisdone : badly drawn boy
08:43:37 <Jafet> Or a better question: what is roll expected to do?
08:43:39 <scotty> and what is <$>
08:43:49 <ManateeLazyCat> dcoutts: Is all gtk2hs user use darcs-2 ?
08:43:50 <fax> scotty: you just think of it as $
08:43:55 <fax> except its got a different type
08:44:03 <ManateeLazyCat> dcoutts_: zooko help me at #darcs.
08:44:06 <fax> basically I can't write x : dropr ...
08:44:10 <fax> so I write (x:) $ dropr..
08:44:15 <fax> except that doesn't typecheck so I write
08:44:19 <fax> (x:) <$> dropr ...
08:44:21 <dancor> ha
08:44:24 <Eelis> i wish Haskell let me do the two-dot variant of     a ... b = ((a .) .) . b    :'(
08:44:38 <dancor> :t (<$>)
08:44:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:44:41 <dancor> @src (<$>)
08:44:42 <lambdabot> f <$> a = fmap f a
08:44:47 <Oejet> fax: And the type would for intstance be: dropr :: Integer -> [a] -> Integer -> IO [a]?
08:44:53 <Twey> Eelis: We usually call that (.:)
08:44:58 <fax> Oejet, sure or it could be Random or list monad
08:45:00 <ManateeLazyCat> Have any gtk2hs users use darcs-1 ?
08:45:08 <Eelis> Twey: really? i only know .: from Data.List.NonEmpty
08:45:09 <fax> Oejet, I like the fact that it works over different monads
08:45:09 <ManateeLazyCat> It's very import to me. :)
08:45:13 <dcoutts_> ManateeLazyCat: yes, almost certainly they all use darcs-2.
08:45:15 <ManateeLazyCat> important
08:45:18 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25294#a25294
08:45:25 <chrisdone> bloody monad transformers!
08:45:25 <Eelis> @hoogle (.:)
08:45:26 <lambdabot> No results found
08:45:29 <dcoutts_> ManateeLazyCat: however I do not suggest telling Axel that we should switch to darcs-2 format repo yet.
08:45:32 <Twey> (.:) = fmap fmap fmap
08:45:46 <chrisdone> on line 8, i need to wrap the rest of the code in a database transaction, which of course runs in another monad
08:45:54 <Twey> It's like â€˜swapâ€™â€¦ it's culture, not code :Ã¾
08:46:03 <ManateeLazyCat> dcoutts_: zooko recommend me use "hashed-format repository" fix my mirror problem.
08:46:37 <chrisdone> so it'll be cgi monad (db monad (cgi monad ...))
08:46:39 <chrisdone> oh god
08:46:48 <chrisdone> maybe i can use a class
08:47:07 <Oejet> fax: roll :: (Monad m) => Double -> m Bool?
08:47:10 <ManateeLazyCat> dcoutts_: zooko try explain the distinguish of "darcs-1-format" "hashed-format" "darcs-2-format" to me.
08:47:31 <fax> Oejet,no,  roll is fixed though
08:47:36 <fax> that's why I left it as a parameter
08:47:39 <chrisdone> actually CGIT is a monad transformer, maybe i can transform the db monad.. very ugly tho
08:47:39 <dcoutts_> ManateeLazyCat: Yes, but I think patch-tag only supports "darcs-2-format", not darcs-1 "hashed-format"
08:47:42 <Eelis> Twey: do you also happen to have a nice name for   (a .) . b  ?
08:48:11 <dcoutts_> ManateeLazyCat: http://patch-tag.com/h/converting-to-darcs-two
08:48:21 <clp8> When doing floating point operations, ghci often prints numbers in scientific notation.  How can I make it print "normally"?
08:48:29 <scotty> roll has me very confused
08:48:30 <scotty> sorry...
08:48:38 <scotty> i understand it is to be replaced
08:48:43 <chrisdone> @source printf
08:48:43 <scotty> but, um, with what?
08:48:44 <lambdabot> printf not available
08:48:44 <Oejet> fax: I don't see it in the parameter list of dropr. You mean it's defined at the top level? It is not a function?
08:49:03 <chrisdone> clp8: maybe this http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Printf.html#v%3Aprintf
08:49:04 <BMeph> fax: Actually, Oejet has a point: you could get a call of dropr n [] 0, wheren > 0. :)
08:49:11 <Jafet> clp8, there isn't any normal way to print floating point
08:49:21 <dcoutts_> ManateeLazyCat: certainly it would be easy to switch to the darcs 1, hashed format repo for gtk2hs on code.haskell.org, but that would not help you to use patch-tag.
08:49:24 <BMeph> where  n  > 0*
08:50:03 <Twey> Eelis: Oh, I'm sorry, that's â€˜.:â€™ â€” I misread you
08:50:09 <fax> BMeph: that's okay
08:50:18 <Eelis> Twey: ah
08:50:18 <Twey> The other one is .:. or something, I think
08:50:23 <fax> BMeph: if someone does that they get a crash or whatever
08:50:38 <fax> BMeph, there are preconditions on the use of this function
08:50:46 <Jafet> dropr 0 [] _ = []; dropr _ [] _ = undefined; dropr 0 _ _ = undefined
08:52:02 <chrisdone> fax: blog!!
08:52:14 <chrisdone> or haskellwiki?
08:52:33 <benmachine> clp8: see the Numeric module, showEFloat, showFFloat, showGFloat
08:52:47 <BMeph> Better yet: dropr 0 xs _ = xs; dropr _ [] 0 = pure []. I think it's valid (dropr 0 _ _) with a non-null list.
08:52:52 <benmachine> which choose different ways of doing things
08:53:00 <benmachine> I think a bit like the e f g printf formatters
08:53:18 <Jafet> Hmm, I did them the wrong way
08:53:33 <Oejet> fax: Is roll defined elsewhere as a function?
08:53:46 <fax> Oejet - you have to implement it yourself
08:54:11 <Jafet> fax, well, you should describe roll.
08:54:12 <Oejet> fax: And what would its most general type be?
08:54:19 <ManateeLazyCat> dcoutts_: I need upgrade gtk2hs main repo to "hashed format", then send request to Thomas Hartman make patch-tag.com support "hashed format". This won't break anything?
08:54:52 <dcoutts_> ManateeLazyCat: yes, but it might be a lot of work for Thomas
08:54:54 <Botje> Oejet: Double -> m Bool
08:54:57 <fax> Oejet: That is the problem
08:55:03 <ManateeLazyCat> dcoutts_: I try to that.
08:55:04 <fax> Oejet: you cannot give it a most general type
08:55:17 <Oejet> Botje: That is my guess too, see above.
08:55:19 <fax> Oejet: you can only implement it for a specific monad - that is why I left it as a prameters
08:55:21 <ManateeLazyCat> dcoutts_: Mirror repository is good for gtk2hs user.
08:55:44 <dcoutts_> ManateeLazyCat: I'm sure there's a simpler solution to set up a mirror
08:55:58 <Jafet> fax, (Monad m) => Fractional -> m Bool is the most general type.
08:55:59 <ManateeLazyCat> dcoutts_: I will send request to Thomas that just support my mirror repository. :)
08:55:59 <Eelis> Twey: i think i'll use 'â€¥' (U+2025 TWO DOT LEADER) for it :)
08:56:04 <ManateeLazyCat> dcoutts_: ?
08:56:18 <dcoutts_> ManateeLazyCat: web space is not that hard to find
08:56:20 <Jafet> Eelis, â€¥
08:56:23 <Twey> The name comes from the fact that it's ((.) . (.))
08:56:28 <Twey> Three dots
08:56:30 <ManateeLazyCat> dcoutts_: Yes, like Google Docs.
08:56:46 <ManateeLazyCat> dcoutts_: But people can use darcs get it, right?
08:56:50 <Twey> The next one is (.::), ((.) . (.) . (.)) â€” five dots
08:56:54 <ManateeLazyCat> s/can/can't
08:57:09 <Eelis> Twey: the way i see it i want to write "(a .) . b" as "a â€¥ b", so two dots makes perfect sense
08:57:17 <dancor> @unpl ((.).(.).(.))
08:57:18 <lambdabot> (\ l b c f i -> l (b c f i))
08:57:46 <ManateeLazyCat> dcoutts_: And a mirror repository is eaiser to synchronous with main repo.
08:57:48 <Jafet> Err, (Monad m, Fractional n) => n -> m Bool
08:58:32 <Eelis> Twey: i think of a dot as a level of indirection, and â€¥ is two levels of indirection, as can be seen clearly in the type:  (Functor f, Functor g) â‡’ (a â†’ b) â†’ (f (g a) â†’ f (g b))
08:58:41 <BMeph> fax: "n/length" is a useful, but mis-typed way to divide to Integral types to get a Double. ;)
08:59:23 <dancor> @pl \ a b -> (a .) . b
08:59:23 <lambdabot> (.) . (.)
08:59:30 <chrisdone> Jafet: not Applicative m?
08:59:36 <fax> I hate that math stuff
08:59:39 <fax> it's anyway screwing me over
08:59:47 <Jafet> BMeph, his parameters will simply be inferred as floating, no biggie.
09:00:20 <Jafet> chrisdone, no, because I don't understand Applicative yet
09:00:39 <BMeph> Jafet:Hmm, another good point.
09:00:50 <Twey> An Applicative is a Functor with a function in it ;)
09:01:06 <BMeph> chrisdone: He uses "do" notation, so that forces everything into Monad. :)
09:01:18 <chrisdone> so
09:02:50 <Jafet> That too
09:03:48 <Oejet> dropr :: (Fractional t, Monad m, Functor m) => t -> [a] -> t -> (t -> m Bool) -> m [a], if I add roll as a last parameter of dropr.
09:04:00 <chrisdone> Applicative to Monad: anything you can do i can do better
09:04:00 <chrisdone> Monad: no you can't
09:04:00 <chrisdone> etc
09:04:18 <Oejet> (...says ghci)
09:04:23 <Jafet> Shouldn't that be "no you can't do"
09:04:47 <dancor> doh
09:05:06 <BMeph> "Anything you can 'do' I can do better"? ;)
09:05:08 <dancor> doh notation for next apr 1?
09:05:13 <Jafet> Anyway, fax hasn't even specified what roll does. Maybe his epic blog post will.
09:05:37 <dancor> blogroll
09:06:25 <arcatan> barrellroll
09:06:42 <scotty> lol
09:06:52 <dancor> i wonder if there's a cool form where you (drop i) a bunch of times
09:07:02 <dancor> to get your sublist
09:07:10 * hackagebot hexpat 0.14 - wrapper for expat, the fast XML parser  http://hackage.haskell.org/package/hexpat-0.14 (StephenBlackheath)
09:08:09 * BMeph would LOVE to see a rickroll link in fax' blog post!
09:08:10 * hackagebot hsp 0.5.2 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.5.2 (NiklasBroberg)
09:08:14 <scotty> how can i print a IO [Int] to screen for testing?
09:08:24 <chrisdone> BMeph: you've ruined it now
09:08:26 <fax> lol
09:08:42 <fax> Click here for an implementation of roll: www.rick roll.com
09:08:44 <Botje> scotty: execute it.
09:08:51 <Oejet> Jafet: Read the type, heh! It takes a number in ]0,1], and returns whether enough the current head of the list should be dropped.
09:09:06 <burp> return [1,2,3] >>= print
09:09:17 * BMeph hums: fax is no stranger to love... he knows the rules - and so do I!
09:09:19 <Jafet> Oejet, this isn't Coq
09:09:30 <chrisdone> scotty: you'll have to define a Show instance for it
09:09:44 <fax> :)
09:09:45 <scotty> yikes
09:09:46 <mightybyte> Anyone know what's causing this error?  "cabal: Couldn't read cabal file "./HDBC/2.2.5/HDBC.cabal"
09:10:13 <Oejet> scotty: I believe chrisdone is kidding.
09:10:14 <dcoutts_> mightybyte: I've not figured it out. You're not the first person to report it.
09:10:26 <mightybyte> I just updated to a new version of cabal-install and started seeing that.
09:10:31 <chrisdone> rick astley is actually from newton which is where i used to go skateboarding. *puts on sunglasses, oh yeahhh*
09:10:41 <dcoutts_> mightybyte: the workaround is to not run cabal list, or to upgrade to the latest cabal-install
09:10:42 <mightybyte> dcoutts_: Ok, just so you know.
09:10:52 <dcoutts_> mightybyte: what context do you see that in?
09:11:02 <dcoutts_> mightybyte: I thought it only happened with older versions
09:11:22 <chrisdone> > return [10] :: IO [Int]
09:11:23 <mightybyte> dcoutts_: When trying to cabal install HDBC, or another of my apps that depends on HDBC.  I'm using ghc 6.10 for this development.
09:11:24 <lambdabot>   <IO [Int]>
09:11:26 <chrisdone> ^ show instance
09:11:36 <dcoutts_> mightybyte: what version of cabal-install
09:11:53 <mightybyte> dcoutts_: cabal-install version 0.6.2 using version 1.6.0.3 of Cabal
09:12:20 <mightybyte> dcoutts_: How do I not run cabal list?
09:12:42 <dcoutts_> mightybyte: sorry, that was the only context I'd had it reported in previously, running "cabal list"
09:12:52 <mightybyte> dcoutts_: Ahh
09:13:02 <dcoutts_> mightybyte: can you file a ticket and provide all the version details etc
09:13:06 <Oejet> scotty: See burp's hint above. Take your value x :: IO [Int] and send it to print with: x >>= print.
09:13:11 <scotty> K
09:13:12 <mightybyte> Sure
09:13:30 <dcoutts_> mightybyte: I can't reproduce it atm, wrong version of ghc available
09:13:42 <mightybyte> Yeah, I understand.
09:14:10 <chrisdone> egads, there's just no way to pleasantly combine these monads
09:14:13 <Oejet> scotty: Or: do { l <- x; print l }
09:14:17 <scotty> ghci totally froze on me...
09:14:31 <scotty> to be fair, it was 100% my fault
09:14:57 <chrisdone> 100% is also the chance of it being your fault
09:15:24 <chrisdone> ghci is Never Wrong
09:16:03 <Jafet> But it is non-terminating.
09:16:17 <chrisdone> Jafet: i guess that's how it's never wrong :D
09:16:26 <Jafet> Naturally.
09:16:51 <Oejet> chrisdone: At least to 3 significant figures. ;)
09:16:53 <scotty> yeah but its so darn lazy...
09:17:04 <dcoutts_> fryguybob: can you try the patch on http://hackage.haskell.org/trac/gtk2hs/ticket/1187
09:18:18 <fryguybob> dcoutts_: trying, might take me awhile, I'm new to darcs/cabal :D.
09:19:40 <mightybyte> dcoutts_: Should I list this as Cabal or cabal-install?
09:20:06 <dcoutts_> mightybyte: probably cabal-install, I can reassign if I discover more
09:20:16 <mightybyte> Ok
09:25:04 <Oejet> fax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25295#a25295
09:25:08 <mightybyte> dcoutts_: It's in as ticket #677.
09:25:27 <fax> I don't consider that an improvement
09:25:54 <dcoutts_> mightybyte: ta
09:28:51 <Oejet> fax: This would work?  roll x = return (x < 0.5)
09:29:15 <fax> I don't know
09:29:51 <Twey> Why monad?
09:30:32 <chrisdone> i just read on the mailing list that 'head' is a partial function
09:30:40 <chrisdone> i've never read 'partial' used in this context before
09:30:43 <kmc> > head []
09:30:43 <lambdabot>   *Exception: Prelude.head: empty list
09:30:58 <ManateeLazyCat> dcoutts_: Good news, Thomas don't need do more thing, just change setting for speical project on patch-tag.com
09:31:00 <chrisdone> does 'partial' mean 'it can result in _|_'?
09:31:09 <chrisdone> or non-total, or w/e
09:31:15 <ddarius> chrisdone: Yes.
09:31:24 <ManateeLazyCat> dcoutts_: zooko have "hashed format" project on patch-tag.com
09:31:46 <ManateeLazyCat> dcoutts_: I send mail to Thomas....
09:32:13 <ddarius> chrisdone: It's the Haskell rendition of the same idea from mathematics.  A function in math is partial if it is not defined on all of its domain, e.g. 1/x is a partial function because it is not defined when x = 0.
09:32:15 <chrisdone> ddarius: ah, right. "avoid partial functions" sounds like sound advice to me then
09:32:30 <fax> I don't like that one
09:32:35 <chrisdone> ah right
09:32:50 <chrisdone> thanks for explaining
09:32:50 <fax> because in haskell you cannot express preconditions and postconditions, I am using loads of partial functions
09:33:15 <chrisdone> fax: i seem to end up putting everything in the maybe monad
09:33:21 <benmachine> I use error like assert
09:33:22 <chrisdone> whenever i use Maybe
09:33:26 <fax> you can imagine all the pre- and post- conditions, then every function is total again
09:33:29 <ido> kmc: that's what she said?
09:33:30 <ddarius> fax: There are a lot of ways of enforcing various conditions.  You don't -have- to use dependent types, though those are a particularly nice and robust form.
09:33:42 <Oejet> ddarius: A function defined everywhere is a "total function"?
09:33:49 <Twey> ddarius: Is â€˜sumâ€™ partial?
09:34:07 <chrisdone> > sum []
09:34:08 <lambdabot>   0
09:34:08 <ddarius> Oejet: Yes (for emphasis).  Technically, in math, partial functions are not functions.
09:34:12 <Twey> > sum [1 ..]
09:34:14 <fryguybob> dcoutts_: The patch did not appear to work.
09:34:19 <lambdabot>  Terminated
09:34:28 <Twey> > sum undefined
09:34:32 <lambdabot>   *Exception: Prelude.undefined
09:34:35 <chrisdone> > id undefined
09:34:36 <lambdabot>   *Exception: Prelude.undefined
09:34:46 <Twey> I guess that's â€˜undefinedâ€™ being partial, not â€˜sumâ€™
09:34:54 <Twey> But what about the infinite list?
09:34:55 <kmc> but "undefined" is not a function (there)
09:34:56 <ddarius> Twey: Partial v. Total usually restricts to inductive cases.  sum is not productive.
09:35:04 <pchiusano> edwardk1: hey, what is the reason that Reducer needs a monoid vs a semigroup
09:35:13 <Twey> Ah, okay
09:35:20 <dcoutts_> fryguybob: in what way? fails to apply? fails to build? works but fails in the same way at runtime?
09:35:27 <chrisdone> fax: have you seen contracts in plt scheme?
09:35:32 <fax> no
09:35:32 <kmc> ddarius, inductive as opposed to coinductive?
09:36:02 <fryguybob> dcoutts_: applies fine, builds fine, but the same error when I try and build pango.
09:36:14 <chrisdone> fax: http://pre.plt-scheme.org/plt/doc/guide/contract-boundaries.html
09:36:16 <ddarius> Twey: But, yes, any function that returns bottom can be called partial.  However, for strict functions that are otherwise total we can view it as a total function being lifted to a partial function.
09:36:19 <ddarius> kmc: Yes.
09:36:26 <benmachine> ddarius: sum *could* be productive on [1..] if your + was a bit strange :)
09:36:41 <kmc> it would be productive for Peano naturals
09:36:42 <ddarius> benmachine: It doesn't have to be strange, just lazy in the second (or both) argument(s).
09:36:50 <pchiusano> edwardk1: it seems to be so you have some strategy for handling "missing" data
09:36:53 <dcoutts_> fryguybob: you're sure you rebuilt the gtk2hs-buildtools package?
09:36:54 <fryguybob> dcoutts_: I can reproduce the issue calling gtk2hsC2hs --include="c:\Any Path with a space" valid.h valid.chs
09:37:15 <fryguybob> dcoutts_: yeah checked the dates and they are from 20 minutes ago.
09:37:16 <chrisdone> i believe that's a nice way to do pre conditions ~
09:37:31 <delue> I'm just starting with Haskell, but I'm starting to think that there isn't all that much to Haskell, and a lot of what the real world programmer uses is just syntatic sugar. Is this correct?
09:37:41 <benmachine> except sum is probably done as a foldl in which case it isn't productive anyway
09:37:43 <dcoutts_> fryguybob: can you run with -d trace and paste the log somewhere
09:37:55 <pchiusano> edwardk1: but there's cases were you want to convert missing values, not to the identity for the monoid type, but to some arbitrary value of the monoid type
09:37:58 <dcoutts_> fryguybob: that shows how c2hs calls cpp
09:37:59 <fryguybob> dcoutts_: Yeah, I'll work on that.
09:38:04 <kmc> delue, there are a lot of concepts in Haskell that are not just sugar
09:38:15 <kmc> delue, and specifically there's a lot of concepts that don't translate directly to other common languages
09:38:21 <Jafet> delue, if you think parsec or Control.Monad are sugar, sure
09:38:33 <kmc> delue, much of the *syntax* in Haskell is syntactic sugar, but most of the stuff to learn in Haskell is not syntax
09:38:38 <c_wraith> delude: The core language constructs aren't that big.  But there's a lot of new stuff to learn as the way the language abstraction works.
09:39:01 <matt_m> Does GHC have type class aliases yet?
09:39:27 <delue> kmc: Yeah, that's what I was meaning I guess. But I find, for example, that learning the more verbose syntax of monads led to the idea behind them making sense.
09:39:40 <kmc> delue, sure
09:39:50 <fryguybob> dcoutts_: is this what you want? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25299
09:39:54 <Oejet> fax: Ah, dropr looks at each element of the list and decides, using roll, whether to drop it or not?
09:40:05 <Jafet> More verbose? You mean >>= and >>?
09:40:32 <kmc> delue, in some sense monads are not a language feature.  "do" is syntactic sugar, and the rest is ordinary Haskell code (class and instance declaration for Monad)
09:40:53 <dcoutts_> fryguybob: ah, thanks, different instance of the same problem.
09:40:59 <delue> kmc: Right, that's exactly what I meant.
09:41:06 <fryguybob> dcoutts_: ok
09:41:14 <kmc> but certain monads such as IO are arguably language features because they can't be implemented using the rest of Haskell
09:41:31 <kmc> but as far as the language is concerned, they're just another algebraic data type
09:41:38 <delue> kmc: I'm just starting out, so what would be some examples? The only one I'm familiar with is IO.
09:41:46 <kmc> delue, of other magical monads?
09:42:00 <kmc> delue, I don't think there are others in the standard
09:42:00 <delue> kmc: Yes.
09:42:05 <kmc> delue, GHC Haskell has ST and STM
09:42:24 <kmc> IO is actually implemented as a special case of ST
09:43:19 <kmc> this contrasts with most monads, which are ordinary data types declared with "data" or "newtype" and with a Monad instance
09:43:25 <Jafet> IO, for the RealWorld#!
09:43:31 <kmc> in GHC Haskell, IO is also declared with "newtype" but the details of how are not for the faint of heart ;)
09:43:34 <Eelis> i suppose (a ->) is also a (contrived) example of a monad that can't be implemented using the rest of Haskell?
09:43:47 <kmc> yeah
09:43:54 <Twey> Is it?
09:43:55 <kmc> also a monad which is not an algebraic type (constructor)
09:44:05 <Eelis> for that one you can at least write the monad instance in pure haskell though
09:44:08 <Twey> Oh, I guess just because functions are specials
09:44:10 <Twey> special**
09:44:21 <Twey> Yeah, there's nothing magic about the instance itself
09:44:33 <Twey> It's just hard to deal with functions as functors
09:44:41 <kmc> anyway, IO is an unusual monad
09:44:44 <kmc> for these and other reasons
09:45:07 <dcoutts_> fryguybob: ah, the main c2hs version has that problem too it seems, might take a little longer to fix.
09:45:10 <fax> Oejet, thats right
09:46:23 <delue> I'm going through the Caltech lectures on Haskell, which I think are getting ready to discuss monads in detail (i.e., other than the IO monad).
09:46:41 <fryguybob> dcoutts_: ok, I'm in no hurry, just trying to be helpful in testing out building on Windows.
09:46:47 <kmc> ok
09:47:08 <dcoutts_> fryguybob: yes, thanks!
09:47:55 <dcoutts_> fryguybob: ah, found it. the -i flag allows a search path, on unix the search path separator is ':'. e.g c2hs -isrc:lib1:lib2
09:48:06 <dcoutts_> fryguybob: but of course that breaks -iC:\blah
09:48:37 <Oejet> delue: Are they online?
09:48:52 <delue> Yep: http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
09:49:18 <delue> I'm on Lecture 4.
09:49:30 <fryguybob> dcoutts_: if I do gtk2hsC2hs --include="\Any Path with a space" valid.h valid.chs   I still get \pathwithspace as where it searched.
09:49:47 <fryguybob> (make that \AnyPathwithaspace
09:51:03 <dcoutts_> fryguybob: ok
09:53:12 <delue> Ah, I just found this page as well: http://haskell.org/haskellwiki/IO_inside
09:53:17 <Oejet> fax: So only the position on an element in the list is important for the probability of dropping it and not its value?
09:53:48 <fax> Oejet, the values are not taken into account no
09:54:00 <fax> you can see this by looking at the program
09:54:36 <mightybyte> dcoutts_: Hmmm, it turns out that cabal-install version 0.8.2 did get installed and that works fine.
09:56:00 <matt_m> Anyone know if GHC has class / context aliases yet?
09:56:02 <dcoutts_> mightybyte: ok, are the details in ticket #677 still correct then?
09:56:44 <kmc> matt_m, don't think so.  saw a recent paper about it though
09:57:05 <kmc> http://lambda-the-ultimate.org/node/3670
09:57:40 <mightybyte> dcoutts_: Yes, when running with those version, it fails.
09:57:59 <dcoutts_> mightybyte: ok, thanks
09:58:27 <mightybyte> dcoutts_: At first I was thinking that ghc-6.10 prevented me from upgrading cabal-install (path problem again).
09:58:58 <matt_m> kmc: thx
09:59:20 <Oejet> fax: Let's say we call (dropr 10 [1..10] 10), and we take the False branch. Then n=10 and length=9 in the recursive call to dropr.
09:59:27 <dcoutts_> mightybyte: btw, what instance of path problem? is it covered by http://hackage.haskell.org/trac/hackage/ticket/670
09:59:32 <mightybyte> dcoutts_: So the latest cabal-install is installed in my user directory, but running the old version from the system directory causes the problem.
10:00:08 <fax> Oejet, you cannot take the false brance
10:00:10 <fax> branch
10:00:14 <Oejet> fax: Now n and length can never become equal again (either length, or both is decremented), and we will not hit the base case (n=0, length=0).
10:00:15 <mightybyte> dcoutts_: Path problem meaning the same thing that kept tripping me up the other day with not realizing which version of cabal-install had been installed.
10:00:17 <fax> because of the post conditions on roll
10:00:22 <dcoutts_> mightybyte: so would that be an instance of the second bullet point in that ticket?
10:00:54 <Oejet> fax: Ah, I missed the post condition on roll. What is it?
10:01:06 <mightybyte> dcoutts_: Yes.
10:01:46 <dcoutts_> mightybyte: ok thanks
10:07:00 <shapr> I want to tune my system for Haskell dev, are there benchmarks and a tuning guide for that?
10:07:59 <Lemmih> Tune your system?
10:08:03 <fryguybob> dcoutts_: if I comment out tools\c2hs\toplevel\Main.hs line 499 of gtk2hsC2hs pango will build for me.
10:08:27 <kmc> compilation requires lots of random-access disk IO.  therefore an SSD can be particularly helpful
10:08:27 <Lemmih> I think your best bet would be to tell GHC to use a bunch of memory.
10:08:28 <fryguybob> dcoutts_: I can't imagine that would be a good fix in general, but it does get me past that issue.
10:08:30 <Oejet> fax: So dropr will never drop the first element?!
10:08:34 <Jafet> Mine's at 440 Hz
10:08:38 <fax> it might
10:09:00 <Oejet> fax: I'm sorry, I'm being too inquisitive.
10:09:41 <fryguybob> dcoutts_: the line is which just chops out the spaces:   makePath (' ':rem)	   path = makePath rem path
10:09:48 <fax> don't be sorry
10:10:07 <EvanR-work> dropr -- fax's algorithm?
10:10:11 <fax> yes
10:10:16 <dcoutts_> fryguybob: right, but we also need to fix the splitting on ':', I'll post a patch shortly
10:10:17 <EvanR-work> living legend
10:10:17 <Oejet> fax: Wait, I meant, if the False branch can never be taken on first iteration, then the first element will _always_ be dropped.
10:11:45 <fryguybob> dcoutts_: Right, I don't have any dir's named C with the files it was looking for and the files I needed are on the same drive as I'm building.
10:12:02 <BMeph> fax: So: a "post-condition" on dropr is: "dropr n _ k | n == k = []", right? ;)
10:12:11 <fryguybob> dcoutts_: Clearly those cases need to be covered though :D
10:12:20 <fax> well that is a true equation
10:12:52 <fax> length (dropr k [1..n] n) = n C k
10:12:53 <BMeph> fax: It should be a part of your definition. That'd make it "ultimately" true. ;)
10:13:53 <BMeph> fax: Shouldn't that be: length (dropr k [1..n] n) == k? ;)
10:14:07 <fax> oops
10:14:21 <fax> if you define roll as:
10:14:29 <fax> roll p | p < 0 = [False]
10:14:32 <fax> oops
10:14:35 <fax> roll p | p <= 0 = [False]
10:14:41 <fax> roll p | p >= 1 = [True]
10:14:46 <fax> roll _ = [True,False]
10:14:52 <fax> then we have length (dropr k [1..n] n) = n C k,
10:15:16 <fax> but if we defined it to randomly choose True of False (satisfying the probability axioms), then length (dropr k [1..n] n) = k
10:15:19 <fax> well
10:15:21 <fax> n - k actually
10:15:35 <dantheman_> Hey all, I have a question about treeviews/treemodels in gtk2hs. Say I have a gui with two widgets, one a treeview, and the other a text display area. As usual, the treeview updates automatically as its underlying model changes. When a row in the view is selected, detailed info about the row is displayed in the text widget. However, I'm not sure how to keep this information updated as the row stored in the model changes. Is th
10:17:34 <Lemmih> dantheman_: You got cut off.
10:17:38 <fax> length (runRandom $ dropr k [1..n] n) = n - k -- maybe I should say to be exact
10:18:07 <BMeph> fax: Oh, yeah - liftM length (dropr k [1..n] n) == (n - k) when m is Identity, but n C k when m is []. (Forgot the whole "dropr is in a Monad" thing.
10:18:33 <fax> yes
10:18:34 * hackagebot chp 2.2.0 - An implementation of concurrency ideas from Communicating Sequential Processes  http://hackage.haskell.org/package/chp-2.2.0 (NeilBrown)
10:18:36 * hackagebot chp-plus 1.3.0 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.3.0 (NeilBrown)
10:18:55 <fax> we could make a probability distribution monad,
10:19:05 <fax> it would be like list, except it kept probabilities for everything too
10:19:14 <fax> that would be useful for proving the correctness
10:19:22 <dantheman_> Whoops, reposted question here: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25302#a25302
10:19:24 <fax> (showing that each element has k/n chance of being dropped)
10:19:34 * hackagebot chp-mtl 1.0.0 - MTL class instances for the CHP library  http://hackage.haskell.org/package/chp-mtl-1.0.0 (NeilBrown)
10:19:49 <Oejet> fax: Is does (0 <= length <= n) hold for all well defined calls to dropr? That would mean the domain of roll is ]0,1], right?
10:20:35 * hackagebot chp-transformers 1.0.0 - Transformers instances for the CHP library  http://hackage.haskell.org/package/chp-transformers-1.0.0 (NeilBrown)
10:20:47 <EvanR-work> Oejet: [0,1) is what you get from the Double instance of Random
10:21:01 <EvanR-work> you can use that to make a suitable roll
10:21:15 <Oejet> BMeph: What is the definition of (n C k)? Combinatorial choose?
10:21:37 <BMeph> Oejet: Genau da.
10:21:42 <dantheman_> Essentially, I'm wondering if I can get access to the signals a tree model throws to a tree view without implementing my widget as a tree view?
10:21:53 <fax> Oejet, n C k is the number of ways of dropping k elements from a set of n!
10:23:10 <Oejet> Ah, so the first parameter 'n' is how many elements, we would like to drop.
10:23:38 <BMeph> Oejet: Right again! :)
10:23:48 <fax> no
10:23:52 <ManateeLazyCat> dantheman_: So you want keep treeview select information when model change?
10:23:52 <fax> n is the length of the list
10:25:26 <EvanR-work> maybe you can prove it inductively
10:25:31 <EvanR-work> starting with a list of length 1
10:25:36 <EvanR-work> and so on
10:25:38 <BMeph> fax: I think he meant n as in "dropr n (x:xs) length". At least, that's my guess. ;)
10:25:47 <Oejet> fax: In plain words, what does dropr do to a given list?
10:26:05 <fax> oh okay
10:26:16 <dantheman_> Manatee: So, when a row is activated, I have a handler called  updateTextWidget that retrieves the data for the row from the model and displays it. However, this information is continually changing, and I'd like to keep it update in the text area until a different  row is activated in the tree view
10:26:21 <fax> EvanR, yes I would use induction for sure
10:26:26 <fax> on the list
10:26:54 <fax> Oejet, will it drops some of the elements.. the details depend on which monad
10:26:59 <BMeph> fax: In later write-ups  you should probably call it 'r'. Or maybe 'k' for the nCk things. :)
10:27:08 <fax> yeah
10:28:13 <BMeph> fax: Here's a fun one: What does it do for the Maybe monad? ;) Do "Just (one of the combinations you'd see in the list monad)"? :)
10:28:19 <dantheman_> Do I have to instead set up some sort of separate updater thread for the text widget that receives updates to the model separately (e.g. in addition to entering them into the model, send them on a chan to which the text updater is listening)
10:29:12 <ManateeLazyCat> dantheman_: So you just want called `updateTextWidget` when your focus *stop* on some line of treeview?
10:29:25 <Oejet> fax: That much is clear but not very enlightening.
10:29:30 <ManateeLazyCat> dantheman_: And don't change textView if cursor is moving, right?
10:29:54 <dantheman_> First part is right.
10:30:09 <dantheman_> And second part actually.
10:30:21 <fax> Oejet: :S
10:30:22 <ManateeLazyCat> dantheman_: Or always update textView when treeview change focus?
10:30:25 <fax> what more is there to know
10:30:38 * hackagebot chp-spec 1.0.0 - A mirror implementation of chp that generates a specification of the program  http://hackage.haskell.org/package/chp-spec-1.0.0 (NeilBrown)
10:30:41 <dantheman_> Always update textView when treeview change focus.
10:30:48 <dantheman_> But in addition,
10:31:08 <dantheman_> propagate updates to selected tree view row to text view.
10:32:12 <dantheman_> basically text view is listening for updates to currently selected row.
10:32:45 <ManateeLazyCat> dantheman_: Oh, i got it.
10:33:02 <ManateeLazyCat> dantheman_: You have build that signal, right?
10:33:17 <dantheman_> ? which signal?
10:33:55 <ManateeLazyCat> dantheman_: keyPresss signal.
10:34:21 <ManateeLazyCat> dantheman_: When you type some key trigger cursor focus next/previous row in treeview.
10:34:23 <ManateeLazyCat> right?
10:35:26 <ManateeLazyCat> dantheman_: Key press make treeview change focus row.
10:35:47 <dantheman_> Well, I currently just listen for the onRowActivated signal
10:36:06 <ManateeLazyCat> dantheman_: Can't work?
10:36:40 <ManateeLazyCat> dantheman_: Or treeview change focus too fast, you got bad performance on updateTextView.
10:36:41 <ManateeLazyCat> ?
10:36:56 <dantheman_> Ah, right. So you're saying I need to build my own custom signal?
10:37:21 <dantheman_> That fires when ever a tree view row is selected?
10:37:26 <ManateeLazyCat> dantheman_: Because every time you change treeview focus, you need change text of TextView, right?
10:37:33 <dantheman_> Yup.
10:38:12 <dantheman_> + in addition, if the text displayed in the treeview for the currently selected row changes.
10:38:27 <dantheman_> Note, in the *treeview*
10:38:28 <ManateeLazyCat> dantheman_: Let's fix one by one, ok?
10:38:33 <dantheman_> Ha, ok
10:38:44 <ManateeLazyCat> dantheman_: Let fix performance problem, then next.
10:38:49 <ManateeLazyCat> dantheman_: Okay?
10:39:58 <ManateeLazyCat> dantheman_: My suggestions is use (forkIO $ postGUIAsync $ updateTextView)
10:40:35 <ManateeLazyCat> dantheman_: forkIO make your updateTextView handler running in separate thread.
10:40:49 <ManateeLazyCat> dantheman_: But as you use `postGUIAsync` wrap it.
10:41:07 <ManateeLazyCat> dantheman_: Any Gtk+ render request will do in main thread.
10:41:50 <ManateeLazyCat> dantheman_: So you got better perform when you update treeview focus so fast.
10:42:10 <ManateeLazyCat> dantheman_: And you `postGUIAsync` keep your Gtk+ code safely with multi-thread.
10:43:01 <ManateeLazyCat> We can't render Gtk+ resource in different thread concurrently, just can use `postGUIAsync` send all Gtk+ request to main thread.
10:43:02 <dantheman_> Ok, I'll have to lookup postGUIAsync up in the api doc as I haven't come across it before. I think that sounds like what I want in terms of multi-threading. However, I'm not sure why you think there will be a performance problem
10:43:33 <Oejet> fax: I am thinking, that roll could have type "Integer -> m [Bool]", with (length(roll n) == n). That is, (roll n) is a bitmap of which of the n elements should be kept or dropped.
10:43:45 <dantheman_> The currently selected row in the treeview only changes when the user presses a different row with his mouse.
10:44:07 <ManateeLazyCat> dantheman_: Yes, that won't have performance problem.
10:44:27 <dantheman_> Ok, so its when I go to update the textview, the focus changes from the treeview?
10:44:32 <ManateeLazyCat> dantheman_: But if you want build some program automatic change focus, that's will be problem.
10:44:53 <ManateeLazyCat> dantheman_: Oh,
10:45:10 <ManateeLazyCat> dantheman_: You want focus back after you udpate textView?
10:45:16 <dantheman_> Ok, but I don't necessarily want to change focus to the textview, just update the text it displays
10:45:34 <ManateeLazyCat> dantheman_: So what's the real problem?
10:46:11 <dantheman_> The only event my text view updater receives is the onRowActivated event.
10:46:34 <dantheman_> But it only updates when a user clicks on a row.
10:47:13 <mdmkolbe> Is there a good shortcut (performance wise) for "groupBy (\x y -> EQ == f x y) . sortBy f"?
10:47:15 <dantheman_> I want it to also update as the data stored in the model for that row changes.
10:47:39 <dantheman_> 'that row' being the currently selected row
10:47:43 * hackagebot happstack-util 0.5.0 - Web framework  http://hackage.haskell.org/package/happstack-util-0.5.0 (JeremyShaw)
10:47:45 * hackagebot happstack-data 0.5.0 - Happstack data manipulation libraries  http://hackage.haskell.org/package/happstack-data-0.5.0 (JeremyShaw)
10:48:44 * hackagebot happstack-ixset 0.5.0 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-0.5.0 (JeremyShaw)
10:48:46 * hackagebot happstack-state 0.5.0 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-0.5.0 (JeremyShaw)
10:49:45 * hackagebot happstack-server 0.5.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-0.5.0 (JeremyShaw)
10:50:25 <ManateeLazyCat> dantheman_: Yes, you need add updateTextView when "model change signal" is trigger.
10:50:25 <dcoutts_> fryguybob: a new patch added to the ticket, would be great if you can test it
10:50:47 * hackagebot happstack 0.5.0 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-0.5.0 (JeremyShaw)
10:50:48 <ManateeLazyCat> dantheman_: But i can't help you i don't know the detail of model.
10:51:03 <ManateeLazyCat> dantheman_: Perhaps paste code will be helpful.
10:51:45 <ManateeLazyCat> dantheman_: And minimum program will make us help you easier.
10:51:57 <dantheman_> \msg ManateeLazyCat I think you've got it actually. When I look at the interface for the model however in the api documentation, it doesn't seem to provide any signals
10:53:40 <ManateeLazyCat> dantheman_: Can you paste your minimum program to gtk2hs list, please?
10:54:29 <ManateeLazyCat> dantheman_: I have some Gtk+ 2.18.3 patch on other repository, if have signal you need in new version of GTk+, perhaps you don't need write it yourself.
10:55:02 <dantheman_> \msg ManateeLazyCat ok, I'll do that.
10:55:29 <kamatsu> has anyone seen that talk from Rich Hickey re. time?
10:55:40 <hydo> kamatsu: just watched it not 5 min. ago
10:55:49 <kamatsu> I was wondering if any FRP experts had some refutations to his time constructs
10:56:02 <hydo> kamatsu: now I wonder about that too.
10:56:21 <kamatsu> i think conal knows his stuff re FRP
10:56:49 * hackagebot web-routes-quasi 0.1.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.1.0 (MichaelSnoyman)
10:56:49 <ManateeLazyCat> dantheman_: BTW, have any user's event will "update as the data stored in the model" ?
10:57:27 <ManateeLazyCat> dantheman_: If have, perhaps you need hook your "updateTextView" on that's event.
10:57:33 <conal> kamatsu: i haven't seen it.  URL?
10:57:49 <kamatsu> conal: www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey/?q=RichHickey
10:58:00 <kamatsu> it's an hour long and targeted towards OO programmers
10:58:28 <kamatsu> but he mentions FRP in the questions at the end, and believes that the notion of time as embodied in FRP is a punt and doesn't really model how time works
10:58:31 <tromp_> :t iterate
10:58:33 <lambdabot> forall a. (a -> a) -> a -> [a]
10:58:48 <tromp_> :t replicate
10:58:49 <kamatsu> i don't really know my stuff, so maybe you could shed some more light on it
10:58:50 <lambdabot> forall a. Int -> a -> [a]
10:59:21 <conal> kamatsu: thx.  i'll check out the vid when in civilization.  limited bandwidth here.  can you point me to a time in the video to start watching?
10:59:54 <kamatsu> well i'll summarize the talk and then find a time
11:00:00 <ManateeLazyCat> dantheman_: BTW, for fix problem faster, i recommend you search your problem with markmail.org
11:00:19 <kamatsu> basically he says that mutable objects don't exist in the real world and that the only objects really worth modelling are immutable with transitions between objects over time managed by pure functions
11:00:33 <kamatsu> basically how fp does it
11:00:34 <conal> kamatsu: thx.
11:00:37 <ManateeLazyCat> dantheman_: Don't search Haskell article, search Gtk+ article, and search Gtk+ guys how to do that.
11:01:04 <dantheman_> \msg ManateeLazyCat The problem I was having was wrt multithreading. I think your postGuiAsync suggestion fixes that though.
11:01:14 <kamatsu> then he introduces a variety of concepts for "managing time" which is essentially keeping track of the current, or previous, values
11:01:19 <kamatsu> he advocates things like STM with MVCC
11:01:37 <dpratt71> what's the closest thing to the Haskell Platform that I can configure under Linux (Ubuntu 10)?
11:02:11 <kamatsu> finally, he then fields a question about FRP and dismisses it out of hand saying that time as an argument to pure functions is a punt and isn't modelling time how it actually is
11:02:12 <dantheman_> \msg ManateeLazyCat It would just be nice if I could hook into the updates being generated anyway by the model for the treeview.
11:02:26 <kamatsu> i'll find the time for the questions
11:02:54 <ManateeLazyCat> dantheman_: If you have any code in your forkIO block, you need use `postGuiAsync` wrap it, otherwise bad thing will happened.
11:02:55 <conal> kamatsu: ok, thanks.  so far doesn't sound very substantive.
11:03:41 <ManateeLazyCat> dantheman_: As i said, use markmail.org search Gtk+ guys how to that with C code.
11:03:43 <kamatsu> start at around 1:05
11:03:47 <kamatsu> 1 hour 5 minutes.
11:04:16 <ManateeLazyCat> dantheman_: If they can fix similar problem with C code, and you can do it with Haskell.
11:04:18 <conal> kamatsu: okay.  a lot of people have funny ideas about frp.  mostly i don't let it bother me.
11:04:44 <kamatsu> yeah, i was more listening to him make assertions and I had no grounding in frp-knowledge to refute him
11:04:45 <ManateeLazyCat> dantheman_: And it will save much time to expose those secret trick. :)
11:05:00 <kamatsu> so i would be interested in another viewpoint
11:05:38 <ManateeLazyCat> dantheman_: BTW, your treeview is contain information for files?
11:05:50 <ManateeLazyCat> dantheman_: Or directory?
11:05:53 * hackagebot usb-id-database 0.4.0.3 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.3 (RoelVanDijk)
11:05:56 * hackagebot ls-usb 0.1.0.5 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.5 (RoelVanDijk)
11:05:58 * hackagebot ftdi 0.2 - A thin layer over USB to communicate with FTDI chips  http://hackage.haskell.org/package/ftdi-0.2 (RoelVanDijk)
11:07:00 * hackagebot roman-numerals 0.3 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.3 (RoelVanDijk)
11:10:29 <ManateeLazyCat> dantheman_: I always use `postGuiAsync` wrap multi-thread Gtk+ code, and don't care whether use `-threaded` flag.
11:10:38 <tromp_> :t ma
11:10:40 <lambdabot> Not in scope: `ma'
11:10:41 <tromp_> :t max
11:10:42 <lambdabot> forall a. (Ord a) => a -> a -> a
11:15:14 <shapr>  Lemmih: so how do I tell ghc to use lots of memory by default? ~/.ghcrc ?
11:16:04 <dantheman_> \msg ManateeLazyCat A simplified version of my code is here: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25303#a25303
11:16:45 <ManateeLazyCat> dantheman_: Ok, i will try test your code before i go to bed. :)
11:17:33 <sanyi> does haskell have a standard library function to get every combination of 2 elements from a list (and maybe apply a function)
11:17:55 <andrewe> conal: Hi Conal, can I get a version of Eros somewhere?
11:17:57 <kmc> :t liftM2 (,)
11:17:58 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:18:07 <kmc> > liftM2 (,) "abc" "def"
11:18:08 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
11:18:10 <kmc> sanyi, ^^^
11:18:18 <sanyi> thanks :)
11:18:27 <conal> i just watched the bit in rich hickey's talk mentioning frp and calling it "pretend time".  i'll have to watch his talk to know what he means.  does anyone know how to download InfoQ videos?
11:18:34 <kmc> > (,) <$> "abc" <*> "def"
11:18:35 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
11:18:48 <ManateeLazyCat> dantheman_: I have read you code.
11:18:51 <dantheman_> \msg ManateeLazyCat Ha. Afraid it's not executable directly... just thought it would help you get a better idea .
11:19:18 <ManateeLazyCat> dantheman_: Why not add `updateLabel` in `myModelUpdater` ?
11:19:25 <conal> andrewe: sadly, not right now.  it used some bit-rotten libs.  i'm working toward a new and much faster version of Eros that generates GPU code.
11:19:43 <ManateeLazyCat> dantheman_: In `myModelUpdater`, you can do like this.
11:19:58 <andrewe> conal: what a pity, can I get some executable?
11:20:08 <conal> andrewe: however, the situation with cross-platform, repl-friendly guis in haskell is terrible right now, and i don't know what can be done.
11:20:31 <conal> andrewe: maybe on windows.
11:20:32 <copumpkin> conal: can I have the link to the video you want to download?
11:20:32 <ManateeLazyCat> dantheman_: If reviceData then do updateLabel ... else otherThing ... ?
11:20:33 <andrewe> conal: I know, that's the biggest issue for me when using Haskell
11:20:49 <andrewe> conal: Windows would be ok.
11:20:54 <conal> copumpkin: http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey/?q=RichHickey
11:21:00 <ManateeLazyCat> dantheman_: Looks network data trigger you change data model, then change value in your textView, right?
11:21:07 <dantheman_> \ManateeLazyCat : The problem is, I only want the label to contain the text for the currently selected row in the treeview.
11:21:07 <conal> andrewe: okay.  looking ...
11:21:12 <dantheman_> Yup
11:21:14 <andrewe> conal: I had downloaded a version some time ago, but I lost it and the link isn't working anymore.
11:21:19 <andrewe> conal: thanks.
11:21:30 <dantheman_> \ManateeLazyCat  yup
11:21:57 <copumpkin> conal: http://flv.thruhere.net/presentations/09-sep-clojure-keynote.flv
11:22:10 <conal> copumpkin: same talk?
11:22:17 <dantheman_> \msg ManateeLazyCat So there are really two events I'm listening for: new data, and a new row being selected
11:22:19 <copumpkin> that's the url the player is playing from
11:22:31 <ManateeLazyCat> dantheman_: Yes.
11:23:04 <dantheman_> \msg ManateeLazyCat I think your suggestion of forking a thread for the updater to listen on the data, + use postGuiAsync, should work.
11:23:12 <ManateeLazyCat> dantheman_: So you need transform `view` to function `myModelUpdater`.
11:23:48 <ManateeLazyCat> dantheman_: No, is `label` transform to `myModelUpdater` for update stats.
11:24:21 <ManateeLazyCat> dantheman_: Yes, use two threads listen different signal.
11:24:37 <conal> copumpkin: thanks.  how'd you find that url?  i don't see it in the page source.
11:24:54 <dantheman_> \msg ManateeLazyCat Ya, I'll try that and see how it goes. Thanks!
11:24:56 <ManateeLazyCat> dantheman_: And use `postGuiAsync` send Gtk+ code to main thread.
11:25:09 <ManateeLazyCat> dantheman_: You're welcome! :)
11:25:22 <copumpkin> conal: I use safari, and if you load and play the video, if you go into window/activity and browse to the page you are on, it'll tell you all the files that are being loaded over http. I just looked for the largest one and found that :)
11:25:29 <dantheman_> \msg ManateeLazyCat Sleep well!
11:25:50 <copumpkin> dantheman_: it's /msg, and we can all see it when you write \msg :P
11:25:57 <ManateeLazyCat> dantheman_: Please send to gtk2hs list if you still have problem, night! :)
11:26:03 <dantheman_> haha whoops!
11:26:11 <conal> copumpkin: sweet!  thanks much for the helpful tip!
11:26:12 <dantheman_> sorry all!
11:26:22 <ManateeLazyCat> dantheman_: Works now?
11:26:28 <copumpkin> dantheman_: no problem :)
11:27:36 <ManateeLazyCat> dantheman_: BTW, i have some suggestion for your code before i sleep.
11:28:19 <ManateeLazyCat> dantheman_: If you reall need set a fixed position for paned?
11:28:36 <ezyang> Is the problem this guy is referring to <http://www.reddit.com/r/programming/comments/bzhqz/gang_of_four_oop_design_patterns_in_fp/c0pcnzl> solvable by memoization by lazy data structure?
11:28:57 <ManateeLazyCat> idleAdd (action >> return False) priorityDefault
11:29:11 <ManateeLazyCat> dantheman_: That's the source code of postGUIAsync, no magic.
11:29:41 <conal> andrewe: try http://conal.net/misc/eros.exe
11:29:44 <chrisdone> I just got an email from a developer asking about try haskell. he suggested an awesome idea. wouldn't it be great if you could go to a Hackage package and have a console pop up so you could try out that package?
11:29:59 <conal> andrewe: it might have a run-time dependency on wxWidgets
11:30:31 <andrewe> conal: I will try it.
11:30:36 <ManateeLazyCat> dantheman_: BTW, you perhaps like my code: (?>=) :: Monad m => Maybe a -> (a -> m ()) -> m ()
11:30:39 <ManateeLazyCat> m ?>= f = maybe (return ()) f m
11:30:41 <c_wraith> chrisdone: that wouldn't work well for some packages.  But it would be terrific for others.
11:31:02 <ManateeLazyCat> dantheman_: Then you don't need write "case maybeData of Just ... Nothing ..."
11:31:41 <ManateeLazyCat> dantheman_: You just need write " maybeData ?>= \realData -> do ... "
11:31:42 <conal> andrewe: if so, you can grab http://conal.net/misc/wxc-msw2.4.2-0.10.1.dll
11:31:55 <chrisdone> c_wraith: indeed, I reckon you'd need some help from the package maintainer maybe with an extra flag passed to hackage with build options
11:32:00 <ManateeLazyCat> dantheman_: You don't need write so much "Nothing -> IO ()".
11:32:13 <Kaidelong> just to see if I'm getting a better grasp on lazy evaluation, the reason why (head . sort) is linear is because sort is head-recursive and in haskell that means it can be evaluated partially?
11:32:17 <c_wraith> chrisdone: there's also the issue of dealing with IO.
11:32:20 <andrewe> conal: exactly that is missing. Next try. :-)
11:32:20 <chrisdone> c_wraith: the tryhaskell.org server could download the latest packages using hackage's rss feed as a source
11:32:31 <chrisdone> c_wraith: IO isn't a problem because I'd be using tryhaskell.org's interpreter
11:32:47 <c_wraith> chrisdone: well, it'd make certainly packages useless.
11:33:09 <c_wraith> network-bytestring is a great package.  But without IO, you can't do anything with it.
11:33:23 <chrisdone> c_wraith: oh I suppose unsafePerformIO in some packages would occur. i guess it'd need an approval process
11:33:43 <andrewe> conal: thanks, it's running.
11:33:47 <c_wraith> err, certain, not certainly
11:33:54 <conal> andrewe:  :) !
11:34:03 <Kaidelong> er whoops
11:34:10 <Kaidelong> head recursive is me not understanding the term
11:34:29 <Kaidelong> I think
11:34:56 <sizzler> is it possible to have an ffi binding to LLVM? thinking that would be useful as several frontends start targeting llvm , you could get access to lot of useful code written in other languages.
11:34:58 <monochrom> mah brain has recursed?
11:35:01 <chrisdone> c_wraith: however sometimes I just want to investigate the types of libraries without needing to actually run them, so I'd find it useful even for IO
11:35:20 <andrewe> conal: I was trying the curried/uncurried example, the hypothenuse doesn't seem to calculate, x=3 and y=4, delivers 0.
11:35:34 <chrisdone> e.g. :t x . y -- check that x and y compose affirms your understanding
11:36:09 * ManateeLazyCat I found that by helping others, can deepen my understanding of the gtk2hs, doesn't? :)
11:36:32 <andrewe> conal: maybe that's a localization issue (I have a German Windows)?
11:36:44 <pikhq> sizzler: It'd be a little bit of work, but yes, you could.
11:36:46 <conal> andrewe: hmm!  please try eros-2007-09-18.exe instead (same directory)
11:36:56 <pikhq> sizzler: Just wrap the LLVM bindings a bit.
11:37:29 <pikhq> (the LLVM bindings, BTW, already *can* generate at runtime a Haskell function from some LLVM code.)
11:37:29 <conal> sizzler: do you know about lennart's llvm library on hackage?
11:38:16 <conal> speaking of llvm, apparently there's a gpu back-end, which suddenly makes it a lot more interesting to me.
11:40:06 * ManateeLazyCat Real need to sleep, bye all. :)
11:40:23 <sizzler> pikhq, conal, yes .. looking a it. that would be part of what is required to consume llvm.
11:40:29 <andrewe> conal: thank you very much.
11:40:33 <sizzler> any links how to ffi to c is implemented for haskell
11:40:51 <andrewe> conal: you said you're working on a new version of Eros. What can be done to help you?
11:40:57 <conal> andrewe: did the 09-19 version work better?
11:41:02 <fryguybob> dcoutts_: The new patch is having dependency problems: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25304
11:41:19 <pikhq> sizzler: Probably just "GHC source code".
11:41:27 <andrewe> conal: It's hard to compare, the newer version does not have the same examples.
11:41:28 <pikhq> That is... Pretty deep in GHC internals right there.
11:41:41 <conal> andrewe: maybe the biggest obstacle is the state of GUI libs in Haskell.
11:42:05 <conal> andrewe: gtk2hs looks terrible on mac os x, and wxhaskell kills ghci.
11:42:19 <andrewe> conal: I tried gtk2hs and wxHaskell myself (on mac os x).
11:42:33 <andrewe> conal: not very nice.
11:42:36 <Kaidelong> conal: I have found documentation on wxHaskell to be scanty, have been searching up and down to see how to make a tree view
11:43:02 <sizzler> conal, pikhq .. ok will check it out. I just want to see if I could import functions in LLVM into haskell.
11:43:02 <Kaidelong> lots of help for buttons or labels or maybe list boxes, though
11:43:02 <dcoutts_> fryguybob: oops, sorry, forgot to record a bit, edit the gtk2hs-buildtools.cabal file and add filepath as one of the build-depends
11:43:09 <pikhq> GTK in general just looks *awful* on anything but UNIX.
11:43:18 <dcoutts_> pikhq: it's ok on windows
11:43:30 <pikhq> It really is "an X11 library that happens to work elsewhere".
11:43:37 <pikhq> dcoutts_: Still pretty clunky, though.
11:43:43 <fryguybob> dcoutts_: does it matter what order filepath ends up in the list?
11:43:50 <dcoutts_> fryguybob: nope
11:43:50 <andrewe> On Mac OS the X11 application is annoying.
11:44:20 <conal> given these issues, i'm awfully discouraged about doing any more gui work in haskell.
11:44:25 <dcoutts_> there is the OSX native backend for Gtk+, it's apparently good enough now for apps like inkscape
11:44:47 <dcoutts_> it's missing GL however and it's not yet that easy to install
11:45:07 <conal> the GL part is critical for me.
11:45:10 <fryguybob> dcoutts_: Still failing on  directory-1.0.1.0. "cabal: The package has a './configure' script. This requires a Unix"
11:45:35 <dcoutts_> conal: yeah, that's frustrating.
11:45:38 <pikhq> Cross-platform GUI stuff is a major pain...
11:45:48 <conal> amen.
11:45:56 <dcoutts_> fryguybob: don't try reinstalling filepath or directory
11:46:05 <pikhq> Qt, I think, is the only one that even gets close to making things look right.
11:46:18 <andrewe> I really dislike Web GUIs, but are there Haskell libraries for that?
11:46:22 <Kaidelong> the haskell qt bindings seem to be in early alpha or something
11:46:24 <pikhq> And that's a pretty big pain to bind against.
11:46:36 <fryguybob> dcoutts_: ??
11:46:39 <Kaidelong> I was looking into that as an option
11:46:44 <conal> also, even if we could get libs like gtk2hs and wxhaskell to work well, they're still these huge imperative OO libs.  quite a distance from something denotative/functional.
11:46:48 <Kaidelong> so far wxHaskell seems like the (least bad?) option
11:46:52 <dcoutts_> pikhq: aye it's pretty good and portable to some phones, sadly not iPhone
11:47:19 <c_wraith> I'm pretty sure the current iphone developer license forbids anything that's portable to iphones
11:47:27 <dcoutts_> conal: yes, they're not nice that way. Sadly there's also a huge amount of UI behaviour to reimplement, accessibility etc etc
11:47:34 <fryguybob> conal: Is there a clear picture of what a purer GUI framework would be like?
11:47:52 <dcoutts_> fryguybob: I mean do not cabal install filepath, you've already got it installed
11:48:14 <conal> fryguybob: have you read "genuinely functional user interfaces"?
11:48:24 <fryguybob> dcoutts_: Right, I get that when I'm trying to cabal install in the tools dir.
11:48:36 <dcoutts_> fryguybob: oh, you already did, in that case remove the version of filepath you just installed
11:48:55 <conal> fryguybob: describes the spirit of what i'm after.  guis that have precise & useful meaning and thus compose powerfully
11:48:59 <fryguybob> dcoutts_: Ah, whats the command to do that?
11:49:13 <dcoutts_> fryguybob: ghc-pkg unregister --user filepath-1.1.0.4
11:49:22 <fryguybob> dcoutts_: ok, trying...
11:49:29 <conal> i'm leaning toward starting over with a denotative gui framework with a gpu-based implementation.
11:50:13 <conal> which is a big undertaking in design & implementation.
11:51:22 <fryguybob> conal: I'll have to read that.  I have done quite a bit of work with WPF and find it to be quite powerful in so far as you can be declarative about it.  For instance you can (with the proper amount of work and avoiding of pitfalls) get some very good composition with it.
11:51:24 <dcoutts_> conal: my impression is that that kind of approach will work beautifully for "custom" style GUIs that have lots of direct user manipulation of things, but will be much less good for "traditional" UIs with buttons, menus, text boxes etc etc. There's just so much old behaviour to emulate and yet people expect that old behaviour.
11:51:26 <Cale> Maybe start with a CPU-based implementation which is not identified directly with the denotational meaning of the terms. It might make it easier to control the performance of things if you don't have to worry about how the compiler will share or fail to share particular terms.
11:52:12 <chrisdone> I wonder about the accessibility properties of such an implementation, or lack of
11:52:30 <dcoutts_> chrisdone: that's one example of what I mean
11:52:37 <Kaidelong> fryguy: one thing I haven't really seen elsewhere is the general idea that the type of a control in WPF is completely seperate from its presentation, it seems like you can't really theme widgets in wxHaskell to operate in a certain graphical way on the same underlying data structure
11:52:48 <sanyi> is there a standard function to get the first element of a list that matches a condition?
11:52:54 <Kaidelong> or if you can, I haven't found out how to yet
11:53:10 <conal> fryguybob: i'd guess what's composable in wpf is a remnant of its (obscured) frp influences.
11:53:11 <c_wraith> sanyi: dropWhile is close to what you want.  compose head with it
11:53:27 <pikhq> Yeah, head . dropWhile should manage that.
11:53:32 <dcoutts_> sanyi: yes, think about what type it would have, see if you can use hoogle to find the function.
11:53:54 <dcoutts_> sanyi: there's one that does exactly what you want, better than head . dropWhile
11:54:12 <sanyi> thanks
11:55:39 <kmc> :t find
11:55:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:55:46 <kmc> from Data.List
11:55:57 <kmc> err, spoiler warning
11:56:03 <dcoutts_> kmc: sigh :-)
11:56:14 * dcoutts_ was trying to get sanyi to see how to use hoogle
11:56:16 <kmc> sorry i missed your message ;)
11:56:52 * dcoutts_ notes that hoogle is perfect for this kind of task
11:57:04 <kmc> it's perfect if you realize the result should be in Maybe, anyway
11:57:21 <dcoutts_> it gets it without the Maybe too
11:57:23 <sanyi> np, i've found it in the meantime...
11:57:28 <kmc> oh really
11:57:31 <dcoutts_> @hoogle [a] -> (a -> Bool) -> a
11:57:31 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:57:32 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
11:57:32 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
11:57:35 <kmc> clever
11:57:39 <dcoutts_> aye
11:57:46 <kmc> so it does something other than straightforward unification
11:57:59 <dcoutts_> as well as the straightforward unification
11:58:02 <fryguybob> conal: Yeah there are compromises left and right in WPF but it still seems far ahead of gtk in many ways.
11:58:02 <benmachine> I think it tries to unify first and then goes for "right-ish"
11:58:19 <dcoutts_> kmc: see ndm's presentation on the hoogle 4 matching/ranking
11:58:34 <dcoutts_> it's got some notion of edit distance
11:58:49 <dcoutts_> with weights tuned by feedback
11:58:56 <kmc> cool
12:01:19 <shajen> hi
12:01:46 <shajen> can anyone help me with write linear fibonacci in haskell?
12:02:21 <copumpkin> > fix ((0:) . scanl (+) 1)
12:02:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:02:39 <xerox> > take 10 $ fix (scanl (+) 0 . (1:))
12:02:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
12:02:43 <tromp> > let fibs a b = a:fibs b (a+b) in fibs 0 1
12:02:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:03:18 <Kaidelong> @type fix
12:03:19 <lambdabot> forall a. (a -> a) -> a
12:03:28 <xerox> the lie
12:03:46 <shajen> xerox: it isnt working
12:04:07 <shajen> tromp: are you sure is working
12:04:28 <Twey> tromp: That's not linear ;)
12:04:45 <Twey> Oh wait
12:04:52 <Twey> Yes it is *facepalm*
12:05:12 <shajen> i get parse error (possibly incorrect indentation)
12:05:24 <Twey> shajen: You're doing it wrong
12:05:40 <shajen> this is my first program in haskell ;]
12:05:42 <benmachine> there are lots of reasons you might get that
12:05:48 <benmachine> it turns up all the time
12:05:59 <j416> ã‚„ãƒ¼
12:06:00 <Twey> shajen: You probably missed a bracket somewhere or something.
12:06:06 <benmachine> hpaste.org <-- put your code there and we can tell you why
12:06:18 <shajen> ok
12:06:41 <monochrom> Reproducible or it didn't happen.
12:07:08 <shajen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25305#a25305
12:07:44 <monochrom> > let fibs a b = a:fibs b (a+b) in fibs 0 1
12:07:45 <Twey> shajen: let statements don't go at top-level
12:07:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:08:00 <Twey> â€¦ because they're not statements: they're expressions
12:08:03 <shajen> Twey: so what should i do
12:08:12 <monochrom> fibs a b = a:fibs b (a+b)
12:08:17 <Cale> shajen: delete the 'let'
12:08:28 <Cale> er...
12:08:29 <shajen> without let still dont work
12:08:31 <Cale> and the 'in'
12:08:37 <Twey> shajen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25305#a25306
12:08:39 <Cale> (and everything after that)
12:08:49 <Twey> You probably want to add a â€˜mainâ€™ too, so your program actually does something :Ã¾
12:08:53 <Cale> Well, you could also write   main = print (let fibs = ... in fibs 0 1)
12:09:09 <Cale> but you probably want something more like
12:09:09 <Twey> If you want to flood your screen with Fibonacci numbers :Ã¾
12:09:22 <Cale> fibs a b = a : fibs b (a+b)
12:09:26 <Cale> main = print (fibs 0 1)
12:09:31 <mreh> ^ most efficient
12:09:45 <monochrom> You know that beyond a certain point, instructions to edit has a higher Kolmogorov complexity than just writing out the new line.
12:09:46 <Cale> The efficiency is no different
12:09:59 <copumpkin> moo
12:10:06 <fryguybob> dcoutts_: I think that worked.
12:10:34 <Cale> shajen: When you're starting out, you probably just want to make definitions in a file, and then type expressions into ghci to test them
12:10:44 <shajen> ohhh my screen is floode by hunderds of numbers
12:10:50 <Cale> :)
12:10:54 <Twey> Like I said :Ã¾
12:10:55 <j416> lol
12:10:56 <monochrom> congrats. you get what you ask for.
12:11:00 <Twey> Hehe
12:11:04 <dcoutts_> fryguybob: Great. I've updated the patch to include that fix, you'll need to obliterate the earlier one or they'll conflict when you next pull.
12:11:07 <Twey> Maybe try http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25305#a25307 :Ã¾
12:11:08 <benmachine> cowpumpkin?
12:11:14 <shajen> ok, but i want only numbers what i get not all table
12:11:19 <mreh> have you mooed today?
12:11:20 <dcoutts_> fryguybob: thanks for testing it
12:11:32 <Kaidelong> >let x = 1 : scanl (+) 1 x in x
12:11:33 <fryguybob> dcoutts_: No problem, thanks for the help!
12:11:35 <Twey> shajen: I'm confused by your latest statement.
12:11:36 <mreh> apt-get moo
12:11:39 <Cale> shajen: You can apply something like  take 20  to the list to chop it off at a given point
12:11:41 <shajen> and i shold not work with list...
12:11:46 <Kaidelong> > let x = 1 : scanl (+) 1 x in x
12:11:47 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
12:11:52 <benmachine> Î¼
12:11:53 <Kaidelong> huh, that works
12:11:57 <VImtermute> ãŠã¯ã‚ˆ
12:11:59 <Cale> shajen: Lists are the natural way of looping.
12:12:07 <monochrom> fibs 0 1 !! 45
12:12:17 <Cale> ãŠã¯ã‚ˆã†
12:12:34 <shajen> Cale: yes i know but muy techer write that in sholuld write it withot using list
12:12:38 <mreh> isn't the most efficient way to get an arbitary fib to accumulate
12:12:38 <Twey> ã”æ©Ÿå«Œã‚ˆã†ã€‚
12:12:40 <j416> ...
12:12:44 <VImtermute> Cale, ãŠå‰ã¯#japaneseã‹ã‚‰ã ã‚ã†
12:12:51 * j416 leaves before something scary happens
12:12:56 <Twey> Heh
12:13:17 <shajen> only recursive
12:13:30 <mreh> haskell knows no other
12:13:34 <whald> looking at Data.BitSet i'm missing a "intersection" operation
12:13:38 <Twey> Well, you could putStrLn each one.
12:13:40 <whald> it would be easy to implement in terms of a boolean "and"
12:13:46 <Twey> But it's not nice to do so.
12:13:47 <Cale> shajen: Okay, so you'll want another parameter to fib to say which element of the sequence you want to get
12:14:00 <mreh> told you
12:14:02 <shajen> yes
12:14:36 <Cale> shajen: If that number is 0, then you want what would have been the first element of the list
12:14:36 <shajen> i have http://www.haskell.org/haskellwiki/The_Fibonacci_sequence but i dont udnerstand how it works
12:14:47 <Cale> shajen: So fib a b n = a
12:14:50 <Cale> er
12:14:52 <Cale> shajen: So fib a b 0 = a
12:14:54 <Cale> sorry :)
12:15:02 <shajen> yes
12:15:12 <shajen> aaaa
12:15:18 <shajen> it is good idea
12:15:23 <Cale> and otherwise, we want to carry on down the sequence, subtracting one from the index that we're looking for
12:15:26 <mreh> saves memories
12:15:36 <Cale> so  fib a b n = fib b (a+b) (n-1)
12:15:47 <Cale> It doesn't really save so much memory
12:16:07 <shajen> yes but it very easy
12:16:09 <Cale> because the list will probably end up being garbage collected very quickly in any case
12:16:33 <Cale> So another way we could do this is just to use the list version of fibs
12:16:41 <Cale> and then use the !! indexing operator
12:16:50 <Cale> fib a b n = fibs a b !! n
12:16:54 <monochrom> This is a class. The point is which approaches are learned, not how much memory is saved.
12:17:38 <monochrom> So God help us if the next exercise is "you must use unary representation".
12:17:47 <shajen> Cale: i cant use list
12:18:02 <shajen> fib a b n = fib b (a+b) (n-1) id dont work
12:18:05 <Cale> shajen: Right, but this serves as a nice specification of what you want fib a b n to compute
12:18:21 <shajen> because if i want 100 fib i dont now earlier a and b
12:18:21 <Cale> shajen: You also need the base case before it
12:18:27 <monochrom> fib :: [()] -> [()]
12:18:28 <Cale> it does work
12:18:41 <shajen> Cale: so how get 100 fib?
12:18:44 <Cale> provided that fib a b 0 is defined to be a
12:18:49 <maltem> Sometimes you're lucky if the students save at least some memories of what should have been learnt.
12:19:05 <Cale> Let's start with a smaller number, and compute by hand
12:19:09 <Cale> fib 0 1 3
12:19:24 <Cale> -> fib 1 (0+1) (3-1)
12:19:44 <Cale> = fib 1 1 2
12:19:54 <Cale> -> fib 1 (1+1) (2-1)
12:20:02 <Cale> = fib 1 2 1
12:20:10 <shajen> hm
12:20:16 <mreh> shall we discuss strictness to confuse him even more?
12:20:18 <Cale> -> fib 2 (1+2) (1-1)
12:20:26 <Cale> = fib 2 3 0
12:20:30 <Cale> -> 2
12:20:45 <shajen> so i have to write fib2 which execute loop from 0 to n
12:20:55 <Cale> Just fib
12:21:00 <Cale> fib a b 0 = a
12:21:08 <Cale> fib a b n = fib b (a+b) (n-1)
12:21:18 <Cale> ah, maybe you wanted fib to have only one parameter?
12:21:39 <shajen> yes
12:21:59 <Cale> yeah, then you name this function fib2 or fib' or something, and then define fib = fib' 0 1
12:22:13 <Cale> (so that fib n = fib' 0 1 n)
12:22:54 <Cale> That's how you'd do it with primitive recursion anyway.
12:23:03 <VImtermute> do you guys just talk about fibonacci all day long or what
12:23:09 <mreh> does your homework tell you to write fib with one parameter
12:23:19 <mreh> VImtermute, it's like hello world for recursion
12:23:22 <hydo> rip hayoo?  holombus seems to be experiencing a porblem.
12:23:27 <Cale> VImtermute: It's a good simple example to introduce ideas about recursion
12:23:29 <shajen> Cale: ok i have all i need :))))
12:23:34 <shajen> and it works ;]
12:23:36 <shajen> thanks
12:23:39 <VImtermute> mreh, Cale right
12:23:51 <Kaidelong> shajen: did it with an accumulating parameter then?
12:24:23 <whald> is there a equivalent of Java's EnumSet in Haskell? I have really small sets that i want to intersect, the stuff you would do with boolean arithmetic in C
12:24:42 <Cale> shajen: If you're familiar with imperative programming, you can see how the parameters to this fib function sort of behave like your mutable variables in the imperative looping version of fib
12:25:53 <shajen> Cale: before i write only in c++ java and prolog so it is hard for me
12:26:11 <Cale> You can do this generally to get a very crude translation of any imperative program into a functional one -- take all the mutable variables, turn them into function parameters, and have functions call each other according to how the control flow in your imperative program would go (each function being one step of the program)
12:26:38 <Cale> Of course, this translation will normally result in a horrible mess, but one can claim that the mess was made before ;)
12:26:54 <Twey> Heheh
12:27:00 <shajen> ok i try ;] i have more programs to write in haskell ;]
12:27:09 <Twey> whald: See Data.Set
12:27:34 <Cale> So we really don't normally think that way, but instead build up other ways of defining the results we want
12:27:42 <Cale> Typically, lists replace loops
12:27:51 <Cale> and operations on them replace the bodies of those loops
12:28:13 <shajen> its my first list exercie in haskell yet ;]
12:28:16 <Cale> yeah
12:28:44 <Cale> I don't know how much sense this will make on your first day, but keep it in mind and perhaps soon it'll start to become clearer.
12:28:45 <tromp> :t scanl
12:28:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:29:35 <whald> Twey: ...is based on size balanced binary trees -- that sounds pretty expensive compared to boolean operations. or does this special-case for small sets under the hood?
12:29:40 <shajen> how to write that fib get (Integer,Integer, Integer) from one integer?
12:29:55 <shajen> Fib :: Integer -> (I,I,I)?
12:29:57 <Cale> shajen: Which three integers do you want?
12:30:09 <monochrom> he means type signature
12:30:12 <Cale> fib :: Integer -> (Integer, Integer, Integer)  would be the type signature
12:30:36 <Cale> But if you're talking about the function we wrote...
12:30:38 <Cale> it's
12:30:48 <Cale> fib' :: Integer -> Integer -> Integer -> Integer
12:31:16 <Twey> whald: If you have single booleans, you can just perform boolean operations on them.
12:31:36 <Cale> In Haskell, whenever we write f x y z (which is a function applied to 3 parameters), what it really means is  ((f x) y) z
12:31:44 <Twey> whald: That's not a set operation.
12:31:53 <Cale> and the type A -> B -> C -> D really means A -> (B -> (C -> D))
12:32:22 <Cale> Every function really has only one parameter, and those which seem to have more are just producing other functions as the result
12:32:23 <Twey> whald: If you want a set, you want Data.Set, and I don't know of any better (non-probabilistic) algorithms for set manipulation than those used there.
12:32:44 <Cale> But of course, eventually you just come to regard that as the same thing
12:32:58 <shajen> Cale: ineresting... i thought that is (I,I,I)-> I
12:33:08 <Cale> a function of two parameters is the same thing as a function which takes one parameter and produces another function
12:33:20 <mercury^> @src fib'
12:33:20 <lambdabot> Source not found. You untyped fool!
12:33:27 <whald> Twey: it's more like 5 booleans, and in java I'd just use an enum to specify the domain, and enumset takes care of efficient set operations
12:33:27 <shajen> aaaa
12:33:28 <mercury^> Cale: where is that fib' defined?
12:33:35 <Cale> mercury^: in the scrollback
12:33:40 <shajen> buf function fib(a,b,n) is that i said?
12:33:43 <shajen> *but
12:33:52 <Cale> fib' a b 0 = a; fib' a b n = fib' b (a+b) (n-1)
12:34:08 <Cale> shajen: Yeah, you could also make fib' be a function of a triple
12:34:24 <Cale> fib' (a,b,0) = a; fib' (a,b,n) = fib' (b,a+b,n-1)
12:34:26 <Cale> like that
12:34:34 <Cale> but that's not normally what we do
12:34:47 <shajen> ok
12:34:59 <Twey> whald: So you want an Enum data-type, and a set.  How is that any different to the Java?
12:35:05 <Cale> It turns out to be much nicer to do it the other way, since it makes it easy to specialise for different first parameters
12:35:08 <Cale> So I could write
12:35:12 <Cale> fib = fib' 0 1
12:35:20 <Cale> lucas = fib' 1 3
12:35:28 <Cale> and so on :)
12:35:45 <Cale> Or write something like:
12:35:50 <whald> Twey: in Java : Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient.
12:35:52 <mercury^> It's unhaskellish to define a tail recursive function like that imo.
12:35:53 <Cale> map (fib' 0 1) [1..10]
12:35:57 <Cale> mercury^: yes
12:36:05 <Cale> mercury^: but he had to do it without lists
12:36:10 <shajen> Cale: thanks for help :)
12:36:13 <whald> Twey: in Haskell: binary trees (slower?)
12:36:24 <mercury^> Could at least do fast fibs then.
12:37:00 <Cale> I don't think performance is the biggest concern here, it's his first day of programming in Haskell :)
12:37:26 <philed> conal: He didn't say very much about continuity from what I remember of that talk, which is odd, since his model of time in terms of one event following the other in sequence is at odds with the physics that I understand (which is how he was motivating this stuff).
12:37:28 <Cale> We could talk about strictness and so on, but it's probably better to leave that for now
12:37:50 <Cale> Well...
12:38:01 <Twey> whald: Why slower?  Bit vectors are essentially O(n).
12:38:01 <Cale> I could say one thing about it.
12:38:14 <mercury^> Could also talk about the fast algorithm.
12:38:30 <Twey> Er, wait.
12:38:36 <Twey> That's a lie.  Sorry.  What am I thinking.
12:38:42 <Twey> Or is it?
12:38:45 <Twey> Intersection probably is.
12:38:49 <conal> philed: programmers seem to be mostly blind to continuous time.  "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
12:38:58 <Twey> Balanced tree should be better for that.
12:40:15 <whald> Twey: yeah, asymptotically, but for small set's it tends to be a single boolean "and"
12:40:25 <paolino> > reads "33.0" :: [(Int,String)]
12:40:26 <lambdabot>   []
12:40:41 <paolino> is this correct ?
12:40:41 <whald> well, an "not" too
12:40:59 <cebewee> Twey: An Enum is unlikely to have more then, say 30 elements
12:41:08 <whald> i think that's difficult to beat with trees
12:41:24 <paolino> > reads "33,0" :: [(Int,String)]
12:41:25 <lambdabot>   [(33,",0")]
12:41:58 <cebewee> cebewee: Twey: And i'm fairly confident, that no tree- or hash-based implementation can beat bitvector operations on one or two machine words ...
12:42:16 * cebewee talks to himself :/
12:42:26 <mercury^> Implementation of what?
12:42:43 <whald> cewebee: i'm listening anyway, if you don't mind :-)
12:43:04 <whald> mercury^: set operations (intersection in particular)
12:43:12 <Twey> whald: Well, you could always represent it as an Int and fiddle with it using Data.Bits.
12:43:17 <Twey> (or something smaller)
12:44:21 <whald> Twey: sure, that's the C approach, no problem with that, i just thought there would be something more elaborate avaliable
12:44:22 <Twey> whald: I think you mean â€˜bitwiseâ€™, not â€˜booleanâ€™
12:44:24 <whald> type safe and stuff
12:44:27 <Twey> There is
12:44:30 <Twey> It's Data.Set ;)
12:44:36 <whald> :-)
12:44:37 <paolino> is there a definition for correct Read instance for an Int ?
12:44:55 <kmc> in the Report i imagine
12:46:30 <cebewee> whald: Maybe you could build something nice using Data.Enumerable.
12:47:27 <cebewee> whald: AFAIK, EnumMap can be nicely replaced in Haskell by using Arrays and Enumerable together.
12:48:06 <cebewee> But that's a shot in the dark; I've not many experiences there
12:48:30 <kmc> what package provides Data.Enumerable?
12:48:44 <shajen> is mod in haskell?
12:48:48 <kmc> :t mod
12:48:50 <lambdabot> forall a. (Integral a) => a -> a -> a
12:48:52 <whald> kmc: "enumerable"
12:48:56 <Twey> > mod 5 1
12:48:58 <lambdabot>   0
12:49:00 <kmc> cool
12:49:02 <Twey> > mod 5 2
12:49:03 <lambdabot>   1
12:49:05 <kmc> > divMod 29 7
12:49:06 <lambdabot>   (4,1)
12:49:07 <shajen> aaaa
12:49:16 <kmc> shajen, often written infix
12:49:21 <kmc> > 29 `mod` 7
12:49:22 <lambdabot>   1
12:49:36 <whald> cebewee: thanks for the suggestion, i'll look into that
12:51:25 <orjan-> I'm having problem building wxhaskell with cabal on debian squeeze. When it's time to config wxcore an error about missling libs :  Missing C libraries: wx_baseu-2.8 and more. I think I have the -dev libs installed
12:53:56 <tromp> > scanl (*) 1 [1..10]
12:53:57 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
12:56:26 <shajen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25308#a25308 why it dont work?
12:57:33 * hackagebot rangemin 2.0 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.0 (LouisWasserman)
12:57:47 <Saizan> shajen: what error do you get?
12:58:57 <shajen> ok i know :)
12:59:12 <shajen> i forget () ;]
12:59:58 * Cale insanely tries to draw the graph reduction for this fib by hand
13:00:07 <shajen> fib_sum (n-2) is not the same fib_sum n-2
13:00:42 <Cale> http://cale.yi.org/share/fib.png
13:01:02 <Cale> ^^ this is a representation of what is happening in memory as your fib is evaluating ;)
13:01:43 <shajen> amazing ;]
13:02:01 <benmachine> that picture makes me smile
13:02:10 <benmachine> for possibly no reason whatsoever
13:02:45 <orjan-> I'm having problem building wxhaskell with cabal on debian squeeze. When it's time to config wxcore an error about missling libs :  Missing C libraries: wx_baseu-2.8 and more. There is /usr/lib/libwx_baseu-2.8.so.0.6.0 and /usr/include/wx-2.8/wx/
13:02:58 <Cale> shajen: Interestingly, the additions never get computed until the very end, after the n parameter gets down to 0
13:03:09 <Twey> Cale: How do you do these diagrams of yours?  TikZ/
13:03:11 <Twey> ?**
13:03:11 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
13:03:16 <Cale> Twey: inkscape
13:03:17 <Twey> lambdabot: Shh
13:03:22 <Twey> Cale: Ah â˜º
13:03:33 <dcoutts_> orjan-: if you run cabal configure with -v3 you can see the linker error message. That should give us a hint.
13:03:51 <orjan-> dcoutts_: ok will try
13:04:01 <Cale> shajen: This can result in lots of wasted memory, but there are tricks we could use to force fib to ensure that its parameters are evaluated sooner rather than later.
13:04:24 <Cale> (in other cases, it can save memory and time not to evaluate parameters right away)
13:08:09 <orjan-> dcoutts_: after several pages it gives the same error as before, there is a warning that it could be "non-standard location" of libs, isn't /usr/lib and /usr/include standard?
13:08:56 <dcoutts_> orjan-: check the log, with -v3 it reports how tries to link a test program and what the linker reports when it fails.
13:09:46 <dcoutts_> orjan-: it's near the end, just before it reports the error
13:10:51 <Cale> This would work better as an animation. I could garbage collect some of these pointers ;)
13:15:28 <dcoutts_> orjan-: any luck?
13:15:50 <orjan-> dcoutts_: I'm trying to understand the log :)
13:16:13 <fax> Cale - is iwasawa theory good?
13:16:14 <dcoutts_> orjan-: perhaps paste the last few pages somewhere
13:16:16 <orjan-> dcoutts_: it says a few times /usr/bin/ld: cannot find -lstdc++
13:16:31 <dcoutts_> ok, getting somewhere
13:16:48 <whald> maybe a bit late to ask (considering the amount of code I already hacked down): is there a substantial difference between "let A in B" and "B where A" ?
13:17:00 <monochrom> No.
13:17:16 <xerox> the former is an expression
13:18:02 <orjan-> dcoutts_: http://pastebin.com/t4SxjcYE
13:19:14 <shajen> Cale: why i get error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25310#a25310
13:19:23 <whald> i ask because i wanted to beautify a pattern matching function, and ghc doesn't like "where" clauses for specific matches while the "let .. in" syntax works
13:20:02 <dcoutts_> orjan-: so it's a little surprising, we'd expect the wx dev distro package to have a dependency on the C++ dev libs
13:22:05 <orjan-> dcoutts_: dpkg says: ii  libstdc++6-4.1-dev                              4.1.2-27                   The GNU Standard C++ Library v3 (development files)
13:22:05 <dcoutts_> orjan-: hmm, interesting. On my box, calling ld foo.o -lstdc++ fails too, though gcc foo.o -lstdc++ works.
13:22:31 <orjan-> so it seems it's installed
13:22:42 <monochrom> perhaps -l is not intended for ld
13:22:44 <dcoutts_> seems C++ libs live somewhere not on the standard linker path that gcc knows about
13:25:35 <sanyi> i've solved problem 8 in project euler, but my solution is hard to read and just doesn't feel right: http://pastebin.com/ZYMcpLvk
13:25:53 <byorgey> whald: can you give an example?  where clauses should always work in that context
13:25:56 <sanyi> the problem was finding the greatest product of five consecutive digits in a number
13:26:13 <sanyi> is there a nicer solution?
13:26:42 <fax> sanyi, if you have the product of 1196744265
13:27:03 <benmachine> sanyi: have you heard of the tails function?
13:27:10 <fax> then the product 11967442657 is the (product of 1196744265)`div`1)*7
13:27:20 <sanyi> yes, good suggestion
13:27:30 <byorgey> sanyi: instead of  (foldr ((*) . digitToInt) 1) I would do  product . map digitToInt
13:27:43 <benmachine> fax: that would be a good optimisation, if the program actually needed optimising at all :)
13:27:48 <benmachine> I think this way is clearer to read
13:27:54 <fax> this isn't an optimization
13:28:11 <c_wraith> yeah, my main thought was "as a first pass, map digitToInt".  If you do that, the rest should be become somewhat cleaner.
13:28:28 <Polarina> sanyi, you know that in PE8, it's not a one big number but many small ones.
13:28:50 <byorgey> > map (take 5) . tails $ "19872340723434534"
13:28:52 <lambdabot>   ["19872","98723","87234","72340","23407","34072","40723","07234","72343","2...
13:29:05 <Cale> http://cale.yi.org/share/fib.png
13:29:07 <Cale> :)
13:29:13 <dcoutts_> orjan-: do you have the C++ bits of gcc installed?
13:29:13 <byorgey> and there's no need to get rid of the things with length < 5 at the end, since they will have smaller products anyway
13:29:19 <Cale> It's the most boring webcomic ever
13:29:44 * hackagebot ftdi 0.2.0.1 - A thin layer over USB to communicate with FTDI chips  http://hackage.haskell.org/package/ftdi-0.2.0.1 (RoelVanDijk)
13:29:48 <fax> Cale lol
13:30:06 <sanyi> thank you all for the suggestions
13:30:34 <dcoutts_> orjan-: if you do something like: echo "int main(){return 0;}" > main.c; gcc main.c -lstdc++;  then does that work or can that also not find stdc++ ?
13:30:51 <orjan-> dcoutts_: at least libstdc++6-4.1-dev and libstdc++6
13:31:03 <fax> sanyi, you could chop it up around 0's
13:31:10 <fax> since there is not going to be any 0s in the result
13:31:19 <whald> byorgey: sorry, i've been afk. here is a non-working example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25311#a25311
13:31:35 <Cale> shajen: Sorry, I was drawing :)
13:31:37 <dcoutts_> orjan-: I mean the C++ compiler itself, do you have g++ installed?
13:31:42 <Cale> shajen: let's see...
13:31:46 <shajen> :)
13:31:58 <byorgey> whald: ah, just move the 'where' after all the guards
13:32:03 <Cale> shajen: what's this x = fib m doing here?
13:32:11 <Cale> shajen: That's not valid Haskell syntax
13:32:20 <Cale> Perhaps you want...
13:32:26 <Cale> let x = fib m
13:32:32 <Cale>  in if x > ...
13:32:33 <Eelis> do i understand correctly that Control.Exception's "throw" is generally considered evil?
13:32:37 <orjan-> dcoutts_: no don't have g++
13:32:38 <byorgey> whald: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25311#a25312
13:32:41 <Cale> Or...
13:32:46 <whald> byorgey: yeah, that just what i wanted to "clean up" -- to have the where stuff where it "belongs"
13:32:53 <Cale> fib_sum2 (n,m) = if x > ... ...
13:32:56 <Cale>   where x = fib m
13:33:02 <dcoutts_> orjan-: I wonder if that's it. My guess is that g++ adds the location of the C++ libs to the standard linker search path for gcc.
13:33:06 <shajen> Cale: aaa ok i try
13:33:15 <byorgey> whald: oh I see, in that case, yes, you must use a let =)
13:33:49 <whald> byorgey: the "let" syntax just looks better if the stuff on the right-hand sind of the "=" gets .. "more" :-)
13:34:16 <shajen> ok it works ;]
13:35:05 <orjan-> dcoutts_: installing g++ get's me a bit longer... cabal is still building
13:35:30 <monochrom> It is actually important that "where" belongs to all sibling guards.
13:35:43 <dcoutts_> orjan-: you mean it got past the configure check?
13:35:47 <monochrom> At least important and useful to me.
13:37:02 <whald> monochrom: i think it really depends on the style, maybe i'm better off using the pattern-matching just to dispatch to smaller helper functions
13:37:28 <monochrom> I rely on it liberally in http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
13:37:28 <whald> i'm still in a very early phase of "getting used to haskell" :-)
13:37:59 * BMeph thinks whald would be better off not thinking of using smaller helper functions as "dispatch"...
13:39:22 <XniX23> im a bit confused with curried functions, (&&) :: Bool -> (Bool -> Bool)    this means that it takes a bool and returns a function that takes a bool and returns a bool
13:39:23 * twink wouldn't call that a calculator.
13:39:29 <jmcarthur> Eelis: i wouldn't say that
13:39:31 <whald> BMeph: why that? doesn't it help me to get focused on a smaller problem?
13:39:39 <fax> XniX23: that's exactly right - don't suond confused at all
13:39:39 <Cale> If you have a bunch of mutually tail-recursive functions, it's possible to think of them as being an imperative program, where the parameters are your mutable variables, and each function is a step in the program, and control flow is absolutely explicit.
13:39:41 <XniX23> i dont really get how it returns a function
13:39:51 * monochrom disbelieve in "meaningful" names anyway.
13:39:52 <jmcarthur> :t (&&) True
13:39:53 <lambdabot> Bool -> Bool
13:40:08 <Eelis> jmcarthur: to my surprise, Control.Exception's throw isn't mentioned on either http://www.haskell.org/haskellwiki/Exception or http://www.haskell.org/haskellwiki/Error_vs._Exception . feels almost like the function's taboo :P
13:40:19 <jmcarthur> XniX23: if you are trying to understand implementation, i wouldn't bother until you understand the language first
13:40:30 <RoadieRich> I'm trying to write an IRC bot, and I keep getting "unable to connect (no route to host)".  I'm evidently able to connect, otherwise I couldn't be talking here.
13:40:39 <pikhq> XniX23: That's what it does. What's not to get? :)
13:40:39 <jmcarthur> Eelis: maybe it's considered too obvious
13:40:42 <Eelis> jmcarthur: i also spotted strong resentment of the function on the mailing list recently i think
13:40:55 <jmcarthur> Eelis: i think you spotted resentment of catching nontermination
13:40:57 <Cale> XniX23: Suppose we have any function of two parameters f(x,y) (in mathematical notation now). If we choose any particular value for x, we can define a new function g(y) = f(x,y)
13:41:14 <ski> (monochrom : otoh, misleading is worse than meaningless :)
13:41:33 <Eelis> jmcarthur: no, i distinctly remember people saying that Control.Exception's throw is no better than error
13:42:08 <jmcarthur> :t throw
13:42:09 <lambdabot> Not in scope: `throw'
13:42:14 <jmcarthur> :t Control.Exception.throw
13:42:14 <aavogt> @hoogle throw
13:42:15 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
13:42:15 <lambdabot> Control.Exception throw :: Exception e => e -> a
13:42:15 <lambdabot> Control.OldException throw :: Exception e => e -> a
13:42:15 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
13:42:21 <monochrom> It is misleading to you but not to me. This is because your context is different from mine.
13:42:35 <Cale> XniX23: So instead of working with functions of tuples, we could instead always choose to use functions of a single parameter which give other functions as their result
13:42:44 <jmcarthur> Eelis: oh i was confused. i was thinking it was a function returning an IO action
13:42:49 <Cale> XniX23: When you write f x y z, what it really means in Haskell is ((f x) y) z
13:43:02 <ski> monochrom : that *could* be the case. it could also be the case that your naming is inconsistent :)
13:43:04 <Eelis> jmcarthur: ah
13:43:15 <aavogt> @hoogle throwTo
13:43:15 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
13:43:15 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
13:43:15 <lambdabot> Control.OldException throwTo :: Exception e => ThreadId -> e -> IO ()
13:43:18 <Cale> That is, apply f to x, giving another function, which you apply to y, giving yet another function, which you apply to z (and get something that may or may not be a function)
13:43:21 <jmcarthur> i don't like the idea of pure code throwing exceptions
13:43:34 <copumpkin> :o
13:43:35 <Cale> XniX23: Does that help at all?
13:43:49 <tromp> @pl \x y -> max 0 (x-y)
13:43:49 <lambdabot> (max 0 .) . (-)
13:43:49 <aavogt> jmcarthur: it's nice in terms of preserving laziness
13:43:59 <monochrom> Here is my context, and it is said in the haddock too. I want to treat ghci as a calculator, except I need these extra functions... So a module with these functions completes my dream calculator. Notice also that the if the ghci prompt looks like "Calculator>" it's very pleasing and fitting.
13:44:02 <Eelis> jmcarthur: the thing is, i'm looking at the community's beloved Data.Text library, and immediately noticed that it relies on Control.Exception's throw for its customizable encoding/decoding error handling
13:44:18 <jmcarthur> aavogt: ?
13:44:25 <orjan-> dcoutts_: seems to work. I'm building the wxhnotepad example. -v 3 sure put out lot of text. The box is an atom so it's not very fast.
13:44:33 <XniX23> Cale: im trying to follow, but why would we do that? why not just pass all as arguments for example?
13:44:38 <aavogt> jmcarthur: I mean throwing exceptions rather than using Maybe or Either
13:44:52 <Cale> XniX23: Well, this turns out to be super-convenient when working with higher order functions
13:45:03 <twink> Here, let me put up a calculator.
13:45:05 <ski> monochrom : sorry, i haven't actually looked at your code at all. just a random "i just came in" comment on your "* monochrom disbelieve in "meaningful" names anyway."
13:45:28 <Cale> XniX23: Quite often if we have a function of multiple parameters, we want to get hold of a more specific function where some of the parameters are specialised to particular values
13:45:43 <monochrom> I only believe in contextual references and mnemonics.
13:45:43 <Cale> XniX23: This makes it absolutely trivial to do that when the parameters in question happen to be the first ones
13:45:59 <Cale> XniX23: (and also has an effect performance-wise, but that's less important)
13:46:25 <ski> monochrom : .. and there i agree
13:46:29 <Cale> So we tend to design our functions so that parameters come in increasing order of likely rate of change.
13:46:47 <twink> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25314#a25314 <-- there's a calculator
13:46:56 <Cale> Consider something like...
13:47:10 <Cale> > map (map (2*)) [[1,2,3],[4,5],[6,7,8]]
13:47:11 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
13:47:15 <shajen> what is 'it' in haskell
13:47:19 <jmcarthur> aavogt: i suppose so. i'd still rather have a pure model for that sort of thing, ideally, but i could see using it for the sake of saving time
13:47:41 <Cale> shajen: ghci will conveniently bind the result of the previous evaluation to the variable 'it'
13:47:42 <ski> shajen : iirc, GHCi names the result of the last expression you typed `it'
13:48:09 <Cale> shajen: Otherwise, it has no meaning.
13:48:12 <shajen> ok but nothing else?
13:48:18 <Cale> (apart from being a valid identifier)
13:48:42 <Cale> > let square it = it * it in square 5
13:48:43 <lambdabot>   25
13:48:47 <BMeph> whald: I meant the "dispatch" part. "Use" is a shorted verb. ;)
13:49:05 <ski> shajen : so if you enter `2 + 3' in GHCi, this is the same as saying `let it = 2 + 3' (except the former also `print's `it'), so that you can then say `4 * it' and get `20' as answer
13:49:47 <shajen> ok
13:50:00 <Berengal> ski: And using 'let it = 2 + 3' will disable ghci overwriting it with new values
13:51:16 <Saizan> Berengal: not in my ghci
13:51:29 <XniX23> Cale: im beginner with haskell, i dont know maps yet and all this, im following a video lectures, i dont get everything now (maybe coz of my poor english), will this become clearer as i get to know all this stuff? or is this essential to know when starting?
13:52:02 <whald> BMeph: in my context (a monte carlo raytracer) a concrete example: we want to use a spehere as a light source
13:52:03 <Cale> XniX23: It'll get clearer why it's convenient
13:52:06 <Berengal> Saizan: Seems you're right. I must therefore be wrong
13:52:07 * twink looks at the calculator.
13:52:10 <orjan-> dcoutts_: ok it works now, thanks :)
13:52:14 <Cale> XniX23: Eventually you'll wonder how you ever survived without it :)
13:52:24 <twink> -rw-r--r-- 1 wli wli 7317 Feb 11  2009 Calc.lhs
13:52:31 <XniX23> Cale: that can lead to depression
13:52:40 <whald> that means we have to uniformly sample a point on a sphere, and the info we have is a point that is probably visible from that point on the sphere
13:52:45 <dcoutts_> orjan-: ok great. I filed a ticket here with an idea to help with this sort of thing in future: http://hackage.haskell.org/trac/hackage/ticket/678
13:52:59 <Berengal> XniX23: It does :(
13:53:06 <whald> i use pattern matching to decide if the given point (the point to be lit) is inside the sphere
13:53:22 <whald> if it is -> just uniformly sample the whole sphere
13:53:28 <monochrom> ignorance is bliss. knowledge is depression. pick your poison.
13:53:45 <Berengal> But also, knowledge is power
13:53:49 <Berengal> So power is depression?
13:53:52 <jlouis> monochrom: I'll take ignorance and depression, right?
13:53:53 <whald> otherwise -> just sample the part of the sphere that is probably visible from the point to be lit
13:54:15 <Cale> XniX23: Basically, once you start using functions as parameters to other functions, it's really important to be able to get at the functions that you're interested in without much mess
13:54:21 <XniX23> Berengal: yes, with great power comes great responsibility, therefor depression
13:54:35 <Cale> XniX23: So we have lambda which makes it easy to define functions without giving them names
13:54:42 <whald> these two cases are quite different, so i have helper functions for "sample whole sphere" and "sample the part visible from the specified point"
13:54:43 <Cale> XniX23: But sometimes even lambda seems too noisy
13:55:00 <whald> that's what i meant with "dispatch"
13:55:11 <monochrom> ignorance and depression are hard to concurrently achieve. but if you manage to achieve, I congratulate you. Would you like a little knife as a congratulation gift so you could harm your arms?
13:55:29 <ski> Berengal : are you sure ? (and s/overwriting/overshadow/)
13:55:35 <fax> :/
13:55:44 <Cale> XniX23: So in the case where the function you're after is the same as an existing function with the first parameters held fixed, this makes things really simple and pretty.
13:55:45 <XniX23> Cale: that looks a bit advanced to me
13:55:53 <Berengal> ski: I was proved wrong by Saizan, at least in recent ghci's
13:55:54 * BMeph heard the phrase as "With Great Power comes Great Insanity".  It could be a different situation, though. ;)
13:56:08 <Cale> XniX23: It's the key to functional programming that we use functions like any other values.
13:56:28 <srh> Hi, I'm trying to remember why I had the opinion that (x $ y $ z) should be ((x $ y) $ z) and not (x $ (y $ z)).  I'm not sure if the reason was better than "you could use (x . y $ z)".
13:56:42 <Cale> x . y $ z is considered better
13:56:46 <monochrom> with no power comes no responsibility. I like that more. In a sense it describes purely functional programming: you castrate the power of mutable variables, you have less responsibility.
13:56:48 <Cale> It means x (y z)
13:56:55 <XniX23> Cale: oh, then i made it clear its my first functional language ^^
13:56:56 <srh> Cale: i'm talking about language design and the associativity of ($)
13:57:02 <Berengal> Also, we use values as functions, as long as you remember to prefix it with the correct interpreter function
13:57:09 <BMeph> whald: Okay, I guess it's a perspective thing. I associate "dispatch" with side-effects. It's a personal quirk, though, so it's not a big deal. :)
13:57:13 <monochrom> and also strong typing.
13:57:17 <Cale> srh: It would be a whole lot nicer if $ associated to the left, but it doesn't
13:57:55 <Cale> x $ y $ z currently means x $ (y $ z) in Haskell, but that means the same thing as x . y $ z, and so we don't really need $ to associate in that direction
13:58:08 <Cale> Instead, it would be nicer if it meant (x $ y) $ z
13:58:16 <srh> right
13:58:20 <Cale> which has no equivalent otherwise
13:58:31 <Twey> srh: Because to the left allows f (x y) z to be written as f $ x y $ z
13:58:38 <srh> i'm trying to remember if i had a reason for believing that (other than that the other way is replaceable with use of (.)
13:58:44 * ski points in direction of `$!'
13:58:57 <srh> Twey: okay, i think that's more convincing, thanks
13:59:13 <Cale> Yeah, and $! (strict application) is currently super-awkward to use with more than one parameter
13:59:22 <whald> BMeph: np, I'm eager to get a better style for my haskell, so any input is good input :-)
13:59:25 <ski> @src foldl'
13:59:25 <lambdabot> foldl' f a []     = a
13:59:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:59:59 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs  -- how it ought to look like
14:00:15 <systemfault> I'm a beginner and I never know where to write `seq` :(
14:00:16 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs  -- what we actually can write, currently
14:00:25 <Twey> systemfault: Don't worry
14:00:36 <Twey> systemfault: With a lot of practice, you'll be an expert
14:00:41 <Cale> systemfault: If you don't know where to write it, then it's usually best to leave it out.
14:00:52 <Twey> systemfault: And you still won't know where to write â€˜seqâ€™, but you can not know with confidence and pride ;)
14:00:57 <srh> ok, thanks a lot for the answers
14:01:20 <Cale> But typically, the places where you need extra strictness are those where you're collapsing lots of tiny bits of data down into a single result with no separate pieces
14:01:34 <systemfault> Thanks for your support :P
14:01:42 <Cale> Accumulating parameters in functions are a major example of that
14:02:10 <Cale> If you have a function which accumulates something in a parameter, and doesn't pattern match on that parameter, then you might want to use seq to force the parameter to evaluate before recursing.
14:02:15 <Berengal> I never worry about seq and friends until after my program breaks
14:02:18 <Cale> yeah
14:02:40 <mreh> i.e. after a stack overflows
14:02:41 <pikhq> Yeah. Just use it when you'd generate a gigantic thunk otherwise.
14:02:55 <Berengal> Or memory leaks
14:02:59 <pikhq> (either overflowing a stack or using obscene amounts of memory)
14:03:15 <monochrom> Richard Bird's introductory book completely nails seq and why.
14:03:32 <Berengal> Stack overflows are a bit interesting, since they're the only case where a lazy program doesn't terminate where a strict one does.
14:03:32 <Cale> On an expression-by-expression level, you almost never need strictness annotations (maybe one on average in every moderate-sized program), and this is more true if you compile with -O2
14:03:52 <Cale> Of course it depends on the sort of computation you're doing
14:03:57 <mreh> monochrom: I think I saw that today, is it an "introduction to functional programming with haskell"?
14:04:27 <mdmkolbe> What is the idiomatic way to make an Ordering that is based on function f1 then on function f2 then on function f3?
14:04:33 <Cale> (because strictness analysis takes place and the compiler gets all the obvious ones for you)
14:04:38 <Berengal> mdmkolbe: Using monoids
14:04:40 <Cale> mdmkolbe: mappend
14:04:59 <Cale> mdmkolbe: Just mappend the a -> a -> Ordering functions together
14:05:12 <Cale> and it'll do the right thing :)
14:05:13 <mdmkolbe> @index mappend
14:05:13 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
14:05:22 <monochrom> Yes mreh
14:05:33 <Berengal> > sortBy (comparing head `mappend` comparing length) (words "hello hai fello")
14:05:34 <lambdabot>   ["fello","hai","hello"]
14:05:36 <mdmkolbe> ah, cool
14:05:52 <Cale> > sortBy (comparing length `mappend` compare) (words "here are some words to sort by length and then alphabetically")
14:05:53 <lambdabot>   ["by","to","and","are","here","some","sort","then","words","length","alphab...
14:06:13 <mdmkolbe> @type comparing
14:06:14 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:06:43 <Cale> comparing p x y = compare (p x) (p y)
14:06:53 <Berengal> comparing f = compare `on` f
14:06:54 <Cale> = compare `on` p
14:07:09 <mdmkolbe> @src on
14:07:09 <lambdabot> (*) `on` f = \x y -> f x * f y
14:07:23 <mdmkolbe> @index on
14:07:23 <lambdabot> bzzt
14:07:29 <Cale> Data.Function
14:07:32 <Cale> Data.Ord for comparing
14:08:06 <Stalafin> when i do something like x = fromIntegral $ floor (foo), then in theory x should be Num, correct?
14:08:16 <Cale> :t floor
14:08:17 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:08:20 <kmc> x will have type (Num a) => a
14:08:21 <Cale> yeah
14:08:23 <kmc> :t fromIntegral
14:08:25 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:08:35 <Berengal> :t fromIntegral . floor
14:08:37 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
14:08:48 <Cale> any particular Num type. The monomorphism restriction might apply and force it to be defaulted to Integer though
14:09:01 <kmc> you can see from the type of fromIntegral that it imposes no relation between its input and output types
14:09:07 <Stalafin> because in a successive operation, i want to divide some double by x+1, and he tells me something that he couldn't math the expected type Double against inferred type integer
14:09:12 <Berengal> Oh woe! The monomorphism restriction!
14:09:15 <kmc> merely requires that the input be an instance of Integral and the output an instance of Num
14:09:30 <Stalafin> argh
14:09:48 <kmc> Stalafin, can you pastebin a code snippet?
14:09:52 <Stalafin> how can i make prelude not use that restriction?
14:10:04 <ski>   {-# LANGUAGE NoMonomorphismRestriction #-}  -- iirc ?
14:10:15 <Stalafin> ski: i can just type that into ghci?
14:10:21 <kmc> you put it at the top of your file
14:10:25 <kmc> or you run ghci with:
14:10:26 <XniX23> Cale: so if i have multiply :: x -> y -> z ->Int  (if thats even right..)   multiply x y z = x*y*z,  what he would do is (((multiply x) multiply y) multiply z) ?
14:10:26 <Berengal> Stalafin: :set -XNoMonomorphismRestriction
14:10:30 <Berengal> In ghci
14:10:37 <kmc> ghci -XNoMonomorphismRestriction
14:10:39 <kmc> or do what Berengal said
14:10:53 <Stalafin> Berengal: thank you!
14:10:57 <Berengal> Stalafin: If you put that in your .ghci file you'll have it off by default
14:10:59 * twink suspects no one looked at the calculator.
14:11:03 <Stalafin> kmc: yeah, i don't need to pastebin it... this thing was in my script, but not in ghci
14:11:10 <Stalafin> Berengal: cool, thanks
14:11:16 <twink> 3>> 216/81
14:11:16 <twink> = MulIE [LitIE 216,PowIE (LitIE 81) (LitIE (-1))]
14:11:51 <twink> Something's neither rationalizing denominators nor doing gcd's on the integral coefficients.
14:12:46 <monochrom> This is the problem with being literal about the word "calculator".
14:14:38 <twink> monochrom: What's the problem with being literal about the word "calculator" then?
14:15:13 <monochrom> You just illustrated the problem.
14:17:25 <twink> monochrom: The problem may need to be explained to me.
14:18:12 <Cale> XniX23: ((multiply x) y) z
14:18:23 <monochrom> re-inventing the wheel, but incompletely, all sorts of things break
14:19:05 <Cale> XniX23: So, for example,  multiply 1  will be a function which takes two numbers y and z  and gives 1*y*z
14:19:29 <Cale> XniX23: and then  multiply 1 2  will be a function which takes one number z, and gives 1*2*z
14:19:51 <Cale> and then multiply 1 2 3 will be 1*2*3, which evaluates to 6
14:20:41 <twink> monochrom: ISTR doing it as a learning exercise.
14:22:17 <XniX23> Cale: is 1*y*z, because we said = x*y*z? what if we said something like = x*x*y*x*z*x?
14:22:42 <mauke> all x's are replaced by 1
14:23:41 <XniX23> so then it would look like this? ((((((multiply x) x) y) x) z) x)?
14:23:45 <jmcarthur> all at once, that is
14:23:47 <mauke> huh?
14:24:12 <XniX23> ok no
14:24:20 <mauke> > let multiply x y z = x*x*y*x*z*x in  multiply 1
14:24:21 <lambdabot>   -3->
14:24:21 <lambdabot>    {-3->9;-2->6;-1->3;0->0;1->-3;2->-6;3->-9}
14:24:21 <lambdabot>  -2->
14:24:21 <lambdabot>    {-3->6;-2->4;-1...
14:24:26 <mauke> hah
14:24:31 <shajen> i have let x= 2+3
14:24:35 <mauke> > let multiply x y z = x*x*y*x*z*x in  ((multiply 1) a) b
14:24:36 <lambdabot>   1 * 1 * a * 1 * b * 1
14:24:38 <shajen> and x <- return $2+2
14:24:42 <shajen> what is difference?
14:26:42 <XniX23> i dont seem to understand how it passes functions ahead :\
14:27:19 <tensorpudding> shajen: the latter is using the do notation, which means it has to eventually return a monadically-wrapped value of some kind
14:31:00 <tensorpudding> > let y = do x <- return $ 2 + 2; return x in y :: Maybe Int
14:31:01 <lambdabot>   Just 4
14:32:22 <kmc> shajen, "x <- return $ stuff" is generally avoided
14:32:36 <kmc> because in the context where that's valid, "let x = stuff" is also valid and more direct
14:33:48 <danharaj> I don't think do notation is any better than properly formatting a chain of >>= and lambdas but what do I know?
14:34:12 <fax> danharaj - it's all the same
14:34:24 <danharaj> I mean for readability
14:34:25 <fax> I mean we all die in the end anyway so what does it matter?
14:34:32 <kmc> you can think of «x <- m» as a statement that runs the action "m" and calls the result "x".  «return v» produces an action which does nothing when run except to produce the result "v"
14:35:00 <fax> kmc: I use return $ .. rather than let
14:35:09 <kmc> so by using them together you have unnecessary wrapping / unwrapping
14:35:11 <kmc> fax why?
14:35:13 <monochrom> do-notation is less typing than chain of >>= \x
14:35:15 <fax> kmc: because haskell doesn't distinguish between let and letrec, we have to do it ourselves
14:35:19 <kmc> oh
14:35:34 <jmcarthur> i don't think much of do notation either
14:35:37 <kmc> but you can use multiple "let" in a row within "do"
14:35:40 <kmc> and they won't be mutually recursive
14:35:43 <danharaj> Less typing, but also obscuring of the actual structure, and they are just as readable, no?
14:36:06 <jmcarthur> do notation is great sometimes
14:36:10 <kmc> i think "do" is often more readable because there's less to read
14:36:15 <monochrom> not according to my definition of actual structure
14:36:16 <Cale> danharaj: Sometimes it clarifies
14:36:40 <kmc> but i also use (>>=) particularly within a line and when the RHS is points-free
14:36:56 <Cale> I tend to either use do-notation or =<<
14:36:58 * jmcarthur likes (=<<) and (<=<)
14:37:04 <Cale> (or <=< yes)
14:37:08 <monochrom> I know people who say all HLLs obscure "the" "actual" structure because their "actual" "structure" is nand gates.
14:37:22 <danharaj> I said structure, not implementation :p
14:37:25 <kmc> yeah, the point of abstraction is to obscure details
14:37:40 <kmc> but not all syntactic sugar is abstraction
14:37:44 <jmcarthur> do notation is the same structure as no do notation. they are just syntax
14:37:55 <kmc> in fact maybe nothing which is properly considered syntactic sugar is actually abstraction
14:38:00 <Cale> danharaj: Sometimes you're thinking of the action as being a sequence of operations or choices, or parsers, etc.
14:38:25 <gwern> 'abstraction, in Hegel's familiar definition, is taking a part for the whole'. the denotation of a program is surely only a part
14:38:58 <Cale> danharaj: >>= makes it more explicit how that sequence is built up as a nested computation, but often you don't really care so much -- monads are required to satisfy an associative law anyway
14:40:05 * Twey prefers >>= and >>>
14:40:12 <Cale> (well, really the associative law is that (f <=< g) <=< h = f <=< (g <=< h), but you can rewrite that in terms of =<< or >>=, it's just a little less clear
14:40:15 <monochrom> I program in IO and most monads imperatively anyway. The imperative look-and-feel is the actual structure. The >>= is implementation detail.
14:40:54 <monochrom> And yes I am saying the imperative look-and-feel is higher-level in this context.
14:41:13 <danharaj> I disagree. I like to think of my IO code as declarative. I am building a single monadic value from smaller ones.
14:41:14 <monochrom> Contrary to some people's dogma.
14:41:42 <XniX23> ok guys i think i get it now, thanks a lot, specially you Cale *thumbs up*
14:41:44 <Cale> danharaj: do-notation still expresses that
14:41:54 <kmc> that's fine as long as "imperative look-and-feel" you don't mean "C and Java" because those impose limits much stricter than what you can do with "do"
14:42:00 <monochrom> I am building a compound program from smaller ones.
14:42:06 <Cale> danharaj: do-expressions glue together monadic actions from smaller ones
14:42:11 <kmc> for example: do { x <- m; x }
14:42:21 <kmc> is pretty uncommon in most languages
14:42:34 <danharaj> Personally I like return and join better because to me that's what the actual monadic structure is, but I compromise :p
14:42:39 <kmc> but stuff like that is essential for getting the power of higher-order imperative programming
14:42:47 <Twey> It hurts me when I see things like â€˜do x <- foo; return $ bar xâ€™ (the sort of thing I'd express as â€˜return bar(foo())â€™ in, say, Python)
14:43:04 <Cale> fmap bar foo
14:43:10 <Twey> It's just *so obviously* a â€˜fmap bar fooâ€™ that I have to write it as such
14:43:10 <kmc> bar <$> foo
14:43:14 <kmc> right
14:43:16 <Twey> I'd hate to use do-notation there
14:43:23 <kmc> i think the debate here is do vs. (>>=) not do vs. higher-level monad combinators
14:43:33 <copumpkin> omnom
14:43:34 <Twey> Well, >>= has the same principle
14:43:35 <kmc> and thus is a debate about syntax primarily
14:43:38 <kmc> sort of
14:43:42 <Cale> danharaj: I really like the Kleisli view :)
14:43:44 <kmc> especially when the RHS is points-free
14:43:46 <Twey> â€˜do x <- foo; print xâ€™ is just as bad
14:43:49 <Twey> Right
14:43:49 <danharaj> What is the kleisli view? :p
14:44:04 <kmc> i think it's not worse than foo >>= \x -> print x
14:44:05 <Twey> It's just begging to be expressed as â€˜foo >>= printâ€™
14:44:08 <kmc> but the latter is more obviously simplified
14:44:13 <Twey> Agreed
14:44:41 <Twey> It's better than a huge chain of lambdas, but worse than a neat point-free chain of binds
14:45:05 <Cale> danharaj: The monad laws are exactly what is needed to make a category where the arrows A -> B are the arrows A -> M B in the original one, where the correspondence is that return gives your identity arrows and <=< gives your composition
14:45:29 <danharaj> ooh, I'll have to think about that one.
14:45:47 <Cale> The monad laws in terms of return and (<=<) are:  f <=< return = f,  return <=< f = f,  and f <=< (g <=< h) = (f <=< g) <=< h
14:46:00 <Cale> So, they're identical to the laws for a category :)
14:46:06 <danharaj> I like fmap, unit, and join because it appeals to the dirty algebraist in me :)
14:46:24 <Twey> Hehe
14:47:02 <edwardk1> pchiusano: it was so i could have a base case for each chunk -- if each chunk is non-empty you can of course get away with a semigroup, but you can always add a unit to a semigroup with Maybe, even if you choose to represent missing data as something other than mempty
14:47:35 <danharaj> Is that what a kleisli category of a monad is, by the way?
14:47:51 <kmc> yes
14:47:52 <jmcarthur> if i'm thinking in terms of "do this, then this, then this," i use do notation. if i'm thinking in terms of "transform this like this, then like this, then like this" i use combinators
14:48:20 <kmc> the monad laws just say that when you construct the kleisli category it's actually a category
14:56:23 <dancor> i mostly use do notation if it's too complicated not to or if it might become that way
14:56:47 <dancor> maybe some ppl think about it the complete opposite way ;)
14:57:22 <Twey> I mostly use do-notation as a trick to shrink line width if it's getting extreme
14:57:50 <Twey> Or if I get one of those functions that you really shouldn't @pl
14:58:04 <dancor> i randomly permute styles for trifling reductions in character length :)
14:58:06 <aavogt> haha, do it anyways :)
14:58:42 <aavogt> do notation gets you more $ without the ()
14:58:58 <Twey> Aye
14:58:59 <dancor> that's true
14:59:17 <Twey> But â€˜do â€™ is three characters, so it's never shorter :Ã¾
14:59:45 * twink rigidly adheres to style regardless of how much longer the code is than it could be.
14:59:48 <aavogt>  \x ->  is longer than  x <-
15:00:07 <aavogt> which style?
15:00:11 <mreh> nested dos?
15:00:18 <copumpkin> > do 5
15:00:19 <lambdabot>   5
15:00:26 <dancor> > do $ do 5
15:00:26 <aavogt> guess that monad!
15:00:26 <lambdabot>   <no location info>: Empty 'do' construct
15:00:32 <copumpkin> > do (do (do (do (do (do (do 5))))))
15:00:33 <lambdabot>   5
15:00:33 <dancor> do . do!
15:00:52 <aavogt> where is the template haskell in \bot?
15:00:52 <copumpkin> > iterate do 5 -- ;)
15:00:54 <lambdabot>   <no location info>: parse error on input `do'
15:01:03 <dancor> we need do'
15:01:15 <copumpkin> @let do' = id
15:01:16 <lambdabot>  Defined.
15:01:40 <dancor> > do' print "hi"
15:01:41 <lambdabot>   <IO ()>
15:01:43 <dancor> ha
15:01:51 * dancor loved it
15:01:51 <sanyi> hm, i have a little problem with project euler problem 14: http://pastebin.com/1gP5u9sL
15:02:07 <sanyi> in imperative programming i would only store the currently largest chain
15:02:09 <aavogt> @type fix (Language.Haskell.TH.doE . (:[]) . Language.Haskell.TH.noBindS)
15:02:11 <lambdabot> Language.Haskell.TH.Lib.ExpQ
15:02:13 <sanyi> not all the chains in a list...
15:02:56 <aavogt> haskell is an imperative language too
15:03:21 <djahandarie> Is Haskell even a functional language?!
15:03:34 <systemfault> If I wanted an imperative language, I'd use C/C++ :P
15:03:35 <sanyi> :)
15:03:39 <aavogt> no, that would be too controversial
15:03:49 <kmc> systemfault, C and C++ don't have first-class support for imperative programming
15:03:50 <djahandarie> Haskell... the paradigmless language
15:04:04 <Entroacceptor> you can say many things about haskell, but not that
15:04:08 <pikhq> djahandarie: Haskell is the greatest imperative language. Unlike most of them, imperative programs are first-class values in Haskell.
15:04:15 <systemfault> kmc: Ah, what are C/C++ then?
15:04:25 * copumpkin writes x86 asm in a "functional style"
15:04:26 <winxordie> C's a proceduralish language
15:04:26 <Cale> sanyi: What's wrong with having a list of them if only one list cell is in memory at a time?
15:04:31 <tensorpudding> Haskell is the functional kool-aid language
15:04:35 <djahandarie> pikhq, yes yes, just blabing
15:04:38 <kmc> systemfault, restricted imperative or procedural languages suitable for systems programming
15:04:53 <kmc> systemfault, in C or C++ you can't easily create, manipulate, and store blocks of imperative actions as values
15:05:06 <dancor> @let a .| b = a >> b
15:05:07 <lambdabot>  Defined.
15:05:12 <copumpkin> kmc: function pointers!
15:05:13 <sanyi> Cale: ehm, my code is using hundreds of MBs of memory
15:05:15 <Zao> kmc: Except if you use C++0x.
15:05:19 <sanyi> dunno how to fix is :S
15:05:22 <copumpkin> kmc: with closures Ã  la mmorrow
15:05:22 <Cale> sanyi: There is a problem with the way you've written your program though -- chains is a constant, and will stay in memory as long as it remains in scope to be used :)
15:05:29 <kmc> this is an essential feature for high-level imperative programming
15:05:35 <kmc> though it's hardly exclusive to haskell
15:05:40 <Cale> (though probably if you compiled with -O2, I would hope this goes away)
15:05:41 <kmc> every language with first-class impure functions also has it
15:06:02 <kmc> Haskell's treatment is nicer because we don't confuse functions and actions in the type system
15:06:02 <Zao> auto f = [foo](bar& b) -> int { foo.omg(b); b.wtf(); return 9001; }
15:06:04 * Cale tries it and checks
15:06:06 <copumpkin> zeroth class
15:06:09 <kmc> but it's not fundamentally different
15:06:15 <sanyi> Cale: thanks
15:07:00 <Cale> sanyi: add   main = print myFunc
15:07:02 <monochrom> If you top-level a list, of course you can expect it to take up memory.
15:07:08 <Cale> sanyi: and then  ghc -O2 --make chain.hs
15:07:18 <Cale> (or whatever your source file is called of course)
15:07:22 <Cale> and then try running it
15:07:42 <sanyi> i've used ghci to check the results...
15:07:57 <sanyi> but i will try with ghc then...
15:08:12 <Cale> sanyi: Yeah, compiling with optimisations here makes a *huge* difference in performance
15:08:33 <Cale> It stays at a constant 4MB or so on my system which is just the size of the runtime
15:08:50 <kmc> and i don't think Haskell is paradigmless.  it is definitely functional, imperative, and declarative, and definitely not object-oriented (though you can do OOP in Haskell decently well)
15:09:16 <aavogt> who does though?
15:09:20 <sanyi> Cale: wow, this is fast!
15:09:48 <aavogt> the only OOP haskell I've seen is yi's configuration
15:10:32 <fax> so what should I do in haskell
15:10:39 <fax> im bored I want to write something but I don'thave any ideas
15:10:44 <ddarius> aavogt: Various OOP techniques are utilized in Haskell fairly often.
15:11:01 <kmc> yeah
15:11:08 <kmc> often i have a record of data, functions, and actions
15:11:10 <sanyi> Cale: thanks for the help
15:11:22 <kmc> possibly with some existentially quantified type
15:11:23 <Cale> sanyi: There are lots of program transformations in the libraries which get turned on only with -O or higher as well, and they'll effectively rewrite your program into a single loop
15:11:27 <kmc> and possibly constructed by closing over other stuff
15:11:41 <aavogt> kmc: and your methods return new versions of the old record?
15:11:49 <kmc> or they do actual mutation
15:11:53 <kmc> this is actually *more* direct than what a lot of Haskell beginners from OOP languages do
15:12:01 <kmc> which is to invent lots of type classes and new types to be instances of those classes
15:12:15 <kmc> because in many OOP languages you are encouraged or required to invent a new type for each new behavior
15:12:20 <kmc> but in Haskell a behavior is just a value
15:12:30 <aavogt> hmm, but then using the built in labeled fields is a bit awkward
15:12:34 <kmc> (it is in every good OOP language too, but it might be considered bad style to have these classless objects)
15:12:47 <sanyi> Cale: could i somehow find the longest chain and return it in one step?
15:13:30 <Cale> sanyi: replace map length with  map (\xs -> (length xs, xs))
15:13:32 <aavogt> as in,    data Foo = Foo  { x,y,z :: Int, cycle :: Foo -> Foo };  then use   join cycle (x::Foo)
15:13:58 <sanyi> Cale: great! thanks again...
15:14:28 <Cale> (which incidentally is  map (length &&& id)  if you import Control.Arrow)
15:14:30 <aavogt> kmc: or is that distinction between methods that look at parts of the object important?
15:15:19 <aavogt> as in, you need some boilerplate there to make applying  cycle  a bit nicer...
15:15:23 <kmc> yeah, records are unfortunately clunky for this
15:15:28 <kmc> got to go, bbl
15:17:25 <aavogt> I suppose you can use some TH to write the actual 'methods' after the fact
15:18:15 <aavogt> ex. name   data Foo = Foo  { x,y,z :: Int, cycle_ :: Foo -> Foo }; $(deriveMethods ''Foo)
15:20:31 <aavogt> one thing I notice with those packages that write some sugar for modifying fields for regular data types (data-accessor, fclabels...), is that they don't let you modify fields in a way that would change the type of the overall data
15:21:06 <ezyang> aavogt: Yeah, that sounds boilerplatey
15:21:21 <ezyang> Although fclabels has its views and lenses
15:21:40 <aavogt> as in,  data T a b = T { a :: a, b :: b }   doesn't seem to allow changing the types of a and b
15:22:08 <aavogt> so    (x{ a = 2 }){ a = 'h' } -- is well-typed
15:22:41 <aavogt> ezyang: I'm not that familiar with fclabels... it has something to work around that 'defficiency'?
15:22:57 <ezyang> That doesn't really address the example you just gave.
15:23:03 <ezyang> *It
15:23:10 <aavogt> it isn't really a problem because most often you mention type variables in multiple fields
15:23:37 <ezyang> That sort of feels like the functor world.
15:23:44 <aavogt> hlist lets you do updates like that
15:23:46 <ezyang> but not quite, since multiple values can inhabit a single type
15:24:21 <aavogt> but hlist isn't terribly user-friendly
15:24:52 <aavogt> it's mostly "hey look, I can do xyz using a, b AND c!"
15:25:33 <aavogt> whereas a nice library shouldn't really give you a choice when the different implementations are otherwise indistinguishable
15:26:03 <aavogt> at least in terms of the results
15:30:39 <Twey> > runIdentity $ (return "foo") { runIdentity = "bar" }
15:30:40 <lambdabot>   "bar"
15:30:59 <Twey> > runIdentity $ ((return "foo") { runIdentity = "bar" }) { runIdentity = "baz" }
15:31:00 <lambdabot>   "baz"
15:31:02 <Twey> Sweet
15:35:00 <djahandarie> Twey, huh, what does that do?
15:35:03 <XniX23> when i c/p my code in leksah everything looks fine, but when i go with my arrow keys over a char like '^' or '<-' they become "unknown" with a square filled with 4 numbers say 2191, anyone else experiencing this problem?
15:36:18 <danharaj> Is there a good introductory paper on functional reactive programming and how it works in Haskell?
15:37:14 <cao> XniX23: that's unicode
15:37:15 <djahandarie> danharaj, I liked conal's paper on it
15:37:21 <djahandarie> I forget who the other guy was
15:37:25 <djahandarie> Courtney
15:37:32 <djahandarie> danharaj, http://www.haskell.org/yale/papers/haskellworkshop01/genuinely-functional-guis.pdf
15:38:21 <djahandarie> (That being a use of it for GUIs)
15:38:24 <danharaj> djahandarie: danke
15:38:25 <djahandarie> Not sure about a total intro paper
15:38:33 <Cale> XniX23: It seems like leksah is trying to use a unicode character to prettify the arrows and such, when you don't have a font that has that character in it
15:38:37 <danharaj> Eh, maybe I can learn by doing :p
15:38:49 <Cale> XniX23: There might be a switch to turn that off
15:38:55 <djahandarie> danharaj, here is another one him, an earlier one http://conal.net/papers/icfp97/icfp97.pdf
15:39:20 <djahandarie> You know, I think there is a list of this stuff somewhere
15:39:20 <conal> danharaj: try http://conal.net/Fran/tutorial.htm .  also http://conal.net/papers/icfp97/
15:39:31 <conal> @wiki FRP
15:39:32 <lambdabot> http://www.haskell.org/haskellwiki/FRP
15:39:46 <djahandarie> danharaj, http://www.haskell.org/yale/publications.html is what I was looking for
15:40:18 <danharaj> Thanks for the inundation of information :)
15:40:48 <conal> danharaj: http://conal.net/papers/icfp97/icfp97.pdf has several more.
15:41:24 <conal> danharaj: darn.  i meant http://conal.net/papers
15:41:35 <conal> danharaj: oh -- i think an earlier msg got clipped.  also check out http://conal.net/fran/tutorial.htm
15:42:27 <conal> danharaj: and a fuller ref for the icfp97 paper: http://conal.net/papers/icfp97/
15:42:35 <XniX23> Cale: thanks, found it
15:42:42 <danharaj> conal: thanks very much
15:43:02 <conal> with abstract, various formats and a pointer to the original FRP paper
15:43:29 <conal> (a tech report on ActiveVRML)
15:43:43 <Twey> > runIdentity $ (return "foo") { runIdentity = "bar" } { runIdentity = "baz" }
15:43:44 <lambdabot>   "baz"
15:43:53 <Twey> > runIdentity (return "foo") { runIdentity = "bar" } { runIdentity = "baz" }
15:43:54 <lambdabot>   "baz"
15:43:59 <Twey> Crazy stuff.
15:44:11 <Twey> djahandarie: Record update on arbitrary expressions
15:44:43 <mreh> how do I do filter in list monad on an infinite list?
15:45:32 <fax> > do x <- [1..] ; guard (even x) ; return x
15:45:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
15:46:04 <conal> mreh: use 'filter'
15:46:20 <conal> mreh: do want a more monad-y answer?
15:47:02 <mreh> fax: what about a finite list
15:47:10 <mreh> it will never terminate though will it
15:47:30 <conal> mreh: do you care?  haskell is lazy.
15:47:40 <danharaj> It is only nonterminating because lambdabot tried to evaluate all of it to give you an answer
15:48:37 <mreh> conal: I'm trying to fit it all in one list comprehension
15:48:49 <mreh> use filter is a sensible answer
15:49:47 <mreh> and there's always takeWhile
15:51:02 <LegendaryPenguin> whats wrong with this http://pastebin.com/Gje5yUY7
15:51:43 <LegendaryPenguin> it always returns []
15:53:09 <sepp2k> LegendaryPenguin: The first case of allWords has type `[a]` while the second has type `m [a]`
15:53:24 <sepp2k> (where Num a and Monad m)
15:53:35 <LegendaryPenguin> oh, i see
15:53:50 <_rata_> is it possible to have code completion in emacs for Haskell?
15:54:35 <sepp2k> Wait, I just realized that m=[], so that actually works out.
15:54:40 <sepp2k> Nevermind me.
15:55:00 <LegendaryPenguin> return [] fixed it
15:55:05 <iago> _rata_, haskell-mode maybe?
15:55:22 <iago> p   haskell-mode                                                                      - A major mode for editing Haskell in Emacs
15:55:24 <conal> mreh: you know you can filter in list comprehensions, right?  [... | x <- xs, odd x]
15:56:07 <_rata_> iago: I have already installed haskell-mode... how do I activate code completion?
15:56:32 <mreh> conal: yeah
15:56:44 <conal> mreh: the "monad" part of your question and the "infinite" part are not relevant are they?
15:56:55 <iago> oh, I dunno, I have never used it
15:57:01 <iago> sorry
15:57:13 <conal> i still miss monad comprehension
15:57:27 <wavewave> esc + /
15:57:31 <_rata_> oh, ok
15:58:01 <iago> _rata_,
15:58:04 <iago> ops, sorry
15:58:06 <iago> LegendaryPenguin,
15:58:17 <_rata_> iago: btw, what do you use iago for writing Haskell?
15:58:43 <wavewave> _rata_, iago : esc + / is auto-completion.
15:59:02 <wavewave> but I don't know how good it is.
15:59:30 <wavewave> now I am testing... seems quite okay.
16:00:11 <_rata_> wavewave: thanks :)
16:00:17 <iago> in the List monad, the monad of non-deterministic computations... do x <- xs; y <- ys; return (x,y)
16:00:32 <iago> result is [] is any of xs or ys is []
16:01:05 <_rata_> but I need to set it up another key binding, as esc+/ is cumbersome in an spanish keyword :P
16:01:13 <iago> in your case, when you call subWords with a singleton list, x:[], subWords [] is []
16:01:25 <wavewave> I think haskell can have much better autocompletion system thanks to its strong type.
16:03:22 <wavewave> not only autocompletion... but type checking on the fly..
16:03:45 <wavewave> suggestion by type.
16:03:53 <iago> LegendaryPenguin, think that do x <- xs; y <- ys; ... means "for each result x, and for each result y, I combine them in the following way...", but if xs/ys is null then there is no x/y result
16:04:30 <wavewave> even.. proof of program during the code writing.
16:04:46 <iago> uhmm, maybe "return []" fixes the problem 8-)
16:04:57 <wavewave> epigram has such concept of editor using xemacs
16:05:07 <iago> yep
16:05:39 <wavewave> without such a good code writing tool, dependent type is too difficult...
16:10:28 <_rata_> mmmm... got disconnected
16:10:40 <_rata_> wavewave: what's epigram?
16:11:06 <ddarius> @where epigram
16:11:06 <lambdabot> http://www.e-pig.org/
16:11:14 <fax> _rata_ - it's a new programming language that you can do proofs in
16:11:21 <wavewave> a dependent typed language.
16:11:49 <wavewave> type is dependent on the value of terms.
16:12:00 <_rata_> how is it related to Haskell?
16:12:00 <fax> here is an introduction http://www.e-pig.org/downloads/ydtm.pdf
16:12:15 <fax> _rata_ it is implemented in (an extension of) haskell...
16:12:15 <wavewave> very much related..
16:12:32 <wavewave> you may also want to see agda ...
16:12:45 <_rata_> what's agda?
16:12:47 <wavewave> agda is more similar to haskell than epigram.
16:12:59 <fax> I guess you're more interested in one line answers.
16:13:00 <wavewave> agda is also a dependent typed programming language.
16:13:01 <_rata_> ah ok.. and also has proofs?
16:13:14 <wavewave> basically proof-checker.
16:13:15 * monochrom knows too many memes, and can decoding "ytdm".
16:13:32 <monochrom> err ydtm
16:13:35 <interferon> how do i write a constant-space length function?
16:13:49 <ddarius> foldl' (const . succ) 0
16:14:03 <wavewave> haskell is more or less being evolved towards dependent type..
16:14:07 <c_wraith> ddarius: that only works for some instance of Enum
16:14:25 <ddarius> c_wraith: Int is an instance of Enum.
16:14:34 <wavewave> the only popular language supports generalized algebraic data type.
16:14:38 <c_wraith> err, *instances.  Other instancs of Enum don't have constant-space representations. ;)
16:14:54 <ddarius> wavewave: Haskell is a far, far ways away from dependent typing yet.
16:14:56 <c_wraith> ok, my typing has degraded horribly
16:15:21 <gorillanigra> dons: I want my $5 dons
16:15:22 <wavewave> ddarius: I know :) but compared to other languages..
16:15:41 <_rata_> mmm... ok.. but I'm just learning Haskell
16:16:13 <interferon> i'm confused about dependent types - do they require runtime invariant checking?
16:16:24 <fax> interferon: no
16:16:28 <_rata_> I don't know what dependent types are/are for... so I think I have to read a lot yet
16:16:38 <gorillanigra> they are useful for rape
16:16:39 <fax> _rata_ why don't you read that paper I linked for you
16:16:56 <monochrom> why hurry
16:17:14 <_rata_> fax: yes, that's one of the things I must read now :)
16:17:18 <wavewave> _rata_ : but you do not need to know dependent type for understanding haskell. do not feel rushed. :)
16:17:21 <ddarius> One will have plenty of time to learn about dependent typing when one is dead.
16:17:28 <_rata_> but I'm reading now YAHT
16:17:28 <fax> lol
16:17:53 <interferon> so an example of dependent typing would be an int whose value is constrained between 5 and 100
16:17:54 <interferon> correct/
16:17:56 <interferon> or incorrect?
16:18:08 <c_wraith> that's correct
16:18:15 <_rata_> that's cool
16:18:17 <wavewave> I think for dependent type, the whole approach to software engineering must be revolutionized.
16:18:27 <fax> interferon: not really
16:18:39 <fax> interferon: check the paper I linked it is very clear and simple
16:18:44 <c_wraith> An even better example, though, is an int whose value is constrained to be between 0 and n, where n is another argument to the function.
16:19:25 <interferon> fax: what paper?
16:19:46 <monochrom> That is less interesting because that is just predicate subtyping. Here is another, more interesting thing. Ever heard of python people bragging "I can write this function: if parameter is odd number, return a string; if parameter is even number, return a bool"? You can write its type signature in dependent types.
16:19:49 <fax> http://www.e-pig.org/downloads/ydtm.pdf
16:20:11 <wavewave> one of the most practical examples is array with index bounded... and type checker can see the array bound..
16:20:26 <monochrom> @quote monochrom poor
16:20:26 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
16:20:30 <interferon> monochrom: well i can kind of do that by saying "data Result = RBool Bool | RString String"
16:20:33 <mauke> Int -> Either String Bool
16:20:45 <danharaj> Dependent types is all about compile time proofs.
16:20:48 <wavewave> interferon: it's still Result type...
16:20:48 <danharaj> At least to me.
16:20:52 <interferon> wavewave: but what if the array bounds are determined at runtime?
16:21:03 <mauke> Int -> (String -> a) -> (Bool -> a) -> a
16:21:05 <danharaj> Prove that your functions respect the array bound.
16:21:09 <wavewave> interferon: so you have to give a proof.
16:21:29 <wavewave> interferon: my program never get out of the bound.
16:21:42 <wavewave> if you cannot prove it, you can not write a program .
16:21:46 <wavewave> that's dependent type.
16:21:47 <danharaj> You can trivially transform it into one that works by explicitly checking index bounds.
16:22:00 <mauke> gen z (x : xs) = let g = gen z xs in \f -> [| \a -> $(g (\as -> f [| $(tembed x) a : $as |])) |]
16:22:09 <mauke> my head hurts
16:22:19 <danharaj> But then you can't drop the type information at run time. You have to keep it.
16:22:35 <monochrom> Of course combining the two examples is the most interesting one, where you can't use a finitary sum type. "the parameter is an integer n, the return value is an integer in the interval [0, n^2]"
16:22:49 <wavewave> The paper on type family also explains something related to dependent type in haskell.
16:23:03 <wavewave> though it is still far from real dependent type.
16:23:45 <wavewave> GADT is a step forward towards dependent type.
16:23:56 <fax> yes
16:24:01 <fax> GADT is types dependent on types
16:24:15 <danharaj> I thought polymorphism was types depend on types
16:24:47 <wavewave> data Result a where RBool :: Bool -> Result Bool ; RString :: String -> Result String
16:25:04 <danharaj> Then again I don't understand the gadt extension.
16:25:10 <fax> http://i.imgur.com/dwGle.png
16:25:14 <fax> this is the lambda cube
16:25:21 <wavewave> then depending on the type constructor,, resultant type can be either Result Bool type or Result String type..
16:25:53 <wavewave> therfore, it is dependent type on its value.
16:26:23 <danharaj> So instead of full polymorphism your type variable only ranges over the ones you specify?
16:26:59 <wavewave> danharaj: in a sense, yes... it's rather opposite to polymorphism.
16:27:12 <wavewave> GADT can be also regarded as a sealed class.
16:27:23 <danharaj> oh, can the constructor signatures be different from each other in arity/kind?
16:27:51 <wavewave> danharaj: yes.
16:28:05 <danharaj> ahh I get it now.
16:28:06 <wavewave> constructor is a special kind of function.
16:28:23 <wavewave> function which ends an evaluation..
16:28:29 <wavewave> function which construct a new type.
16:28:55 <danharaj> So two extensions. The first is that your constructors don't all have to be the same kind, and the other is that you can restrict the range of type variables.
16:29:28 <wavewave> in fact the first is not only for GADT...
16:29:48 <wavewave> data Maybe a = Nothing | Just a
16:29:53 <danharaj> True
16:29:55 <danharaj> Dur :p
16:30:00 <wavewave> Nothing is arity 0. Just has 1
16:30:16 <danharaj> Well what about data Foo a = Nothing | Just (a -> int)
16:30:33 <danharaj> Is that legal without gadt extension/syntax?
16:30:49 <wavewave> it seems to have no problem.
16:30:52 <wavewave> let me check
16:32:01 <danharaj> > data Foo a = Bar | Baz (a -> int)
16:32:02 <lambdabot>   <no location info>: parse error on input `data'
16:32:21 <wavewave> no problem.. it is successfully compiled..
16:32:40 <wavewave> > data Foo = Bar | Baz ( a -> Int )
16:32:41 <lambdabot>   <no location info>: parse error on input `data'
16:32:46 <wavewave> > data Foo a = Bar | Baz ( a -> Int )
16:32:47 <lambdabot>   <no location info>: parse error on input `data'
16:32:52 <wavewave> Hmm..
16:33:44 <wavewave> my ghc compiler compiled it well.
16:34:46 <wavewave> GADT and existential type can be used together well.
16:35:03 <fax> what do you call say,  [('a',3),('b',2),('c',5)]
16:35:13 <danharaj> a list of pairs?
16:35:21 <fax> where a has probability 30%, b has probability 20% and c has proabbility 50%
16:35:33 <danharaj> a probability distribution?
16:35:37 <fax> I think that type ????? a = [(a,Rational)]  is an monad
16:35:40 <fax> but I do not know what ot call it
16:36:10 <danharaj> How would you define return and bind?
16:36:24 <fax> return x = [(x,1)]
16:37:09 <fax> m >>= f = do (a,p) <- m ; map (something p) (f a)
16:37:20 <fax> something will probably multiply all the probabilitise by p
16:37:58 <tensorpudding> isn't using do notation to define (>>=) circular?
16:37:58 <fax> it's list monad embellished with a probability
16:37:59 <fax> for examp,
16:38:06 <fax> no because of typeclasses
16:38:11 <tensorpudding> or hmm, you're using the list monad.
16:38:18 <fax> for example,  flip = [(Heads, 0.5), (Tails, 0.5)]
16:38:21 <fax> this represents a coin
16:38:33 <fax> or you can do dice = [(1,1/6),(2,1/6),...]
16:39:01 <fax> hm - we can also merge equal elements by adding the probaiblity
16:39:05 <fax> that should be done, I think
16:39:17 <wavewave> list monad  = cartesian product with concatanization.
16:39:19 <tensorpudding> but isn't f going to be mis-typed? f :: a -> m a
16:39:22 <fax> so >>= needs updated
16:39:40 <wavewave> since cartesian product has the same algebra as a product of numbers.
16:39:57 <tensorpudding> or wait, it'll work, i suppose
16:39:57 <wavewave> weighted list monad can be defined.
16:40:44 <fax> weighted list monad is a good name but it is a little bit of a mouthful
16:41:08 <wavewave> one more extension can be including 'or' logic
16:41:11 <danharaj> Is >>= associative?
16:41:12 <djahandarie> Just turn it into an acronym. THEN NO ONE WILL KNOW
16:41:26 <djahandarie> Guys, I'm talking about the WLM here, don't you understand?
16:41:29 <wavewave> now your logic has only 'and' or 'X' (multiplication.)
16:41:38 <tensorpudding> What should (something p) do anyway?
16:41:49 <fax> danharaj, I may have to define equality rather more loosely for it to satisfy the laws
16:41:52 <wavewave> or = '+'
16:42:09 <danharaj> I don't think this should be a monad :p
16:42:21 <fax> :/
16:42:26 <danharaj> Also, set is conceptually more appropriate than list, no?
16:53:35 <Cale> danharaj: Is what a monad?
16:53:48 <Janni> Hello.
16:54:03 <danharaj> I didn't ask, fax did :p
16:54:18 <Cale> danharaj: If w is any monoid, you can form a monad [(w,a)]
16:54:23 <Cale> ah
16:54:28 <Cale> Janni: hello
16:54:45 <Cale> fax: It's WriterT (Product Rational) []
16:55:06 <danharaj> I think there is a problem because there is an implicit normalization going on when you are working with probability distributions.
16:55:11 <fax> oh cool
16:55:14 <danharaj> The normalization is nonassociative.
16:55:23 <Cale> danharaj: It's a separate operation
16:56:00 <Cale> danharaj: But, supposing that each of the lists you're working with has coefficients that sum to 1 (that is, they're probabilities), then your results will be lists which sum to 1
16:57:45 <danharaj> what would 'something' be in fax's >>=?
16:57:57 <fax> it multiplies
16:58:00 <Janni> I'm programming something involving two IntMaps that I need to synchronise, and I'm realising that I'm basically implementing relations. So, is someone here aware of some library that helps me to maintain a relation between two (possibly identical) Ord types A and B? What it should give me is that I can query/delete/insert some tuple (a,b) by using one of a and b as a key.
16:58:05 <fax> for example
16:58:13 <fax> do a <- coin ; b <- coin ; return (a,b)
16:58:19 <Janni> Is that understandable? I looked in Hackage but haven't found anything.
16:58:26 <fax> that will give:  [((True,True),1/4),...]
16:58:36 <fax> everything has 1/4 probability because that's 1/2 * 1/2
16:58:46 <mauke> Janni: bimap?
16:59:09 <Janni> mauke: "Each value in the bimap is associated with exactly one value of the opposite type"
16:59:22 <mauke> ah, outer join
16:59:35 <mauke> hmm
17:01:04 <Janni> Thing is, that it is quite easy to implement, so I guess it should have been done... by someone else of course... I prefer to leave the cheap labour to others... such as asking here instead of doing proper research myself :-)
17:01:25 <danharaj> Do we look like #india
17:01:37 * fax think haraj sounds indian
17:01:49 <danharaj> It does sound that way doesn't it :p
17:01:51 * fax is rubbish at languaes
17:02:08 <danharaj> human ones anyway, mirite?
17:02:39 <fax> very badly
17:05:26 <dancor> Janni: i don't understand.  you want to insert key (a,b) and value v where a and b have no inherent connection, then be able to look up a -> v or b -> v later?
17:05:46 <Janni> No. No v.
17:05:54 <Janni> Just a and b.
17:06:03 <dancor> and they are both Ints?
17:06:17 <Janni> dancor: if you insist.
17:06:27 <dancor> Janni: well you said you were using IntMap's..
17:07:08 <Janni> Well, I don't think it doesn't make a big difference whether we have ints here or just some Ord type.
17:07:22 <dancor> so right now you have two maps and one is the inverse of the other (keys and values flipped)?
17:07:33 <Janni> So let it be Ints (bit faster) or some Ord a (more generic)
17:07:34 <mreh> evenFibs = 1 : 1 : zipWith ((+) . (*4)) (drop 1 evenFibs) evenFibs -- why is this wrong?
17:08:05 <Janni> dancor: Haven't implemented it yet, but I guess that was the direction I was going in.
17:08:06 <monochrom> what is evenFibs?
17:08:14 <Janni> Hmm. Maybe fgl?
17:08:23 <mreh> gives you all the even fibonnaci numbers
17:08:31 <Janni> (functional graph library)
17:09:06 <Janni> Hmm. No if both a and b are Ints this is boring.
17:09:16 <dancor> fgl could be good..
17:09:22 <Janni> I want to have a "Relation a b"
17:09:25 <dancor> until you have more than two things being associated it's not clear if two maps isn't actually a pretty good approach
17:09:43 <mreh> E(n) = 4*E(n-1) + E(n-2)
17:10:16 <twink> E(0) = F(0) = 0, E(1) = F(2) = 1
17:10:37 <Janni> OK, let's reformulate this problem a few times (why does it always happen to me, that I stumble over such general problems and find that there isn't a library for it out there?)
17:10:49 <mreh> haha, 1 isn't even
17:11:17 <monochrom> Because God reserves them for you to solve.
17:11:18 <mreh> the sequence starts 2 : 8 : ...
17:11:27 <Janni> I want to maintain a set of tuples of type (Ord a, Ord b) => (a,b) efficiently
17:11:36 <dancor> Janni: there seem to be different ways to generalize from the problem you have to more-general-and-therefore-more-useful structures
17:12:10 <dancor> ok.  and you want to be able to do lookups on a's or b's
17:12:25 <Janni> OK, let's see.
17:12:37 <dancor> double-storing (a,b) and (b,a) in some structure that is good at doing one direction seems pretty good
17:12:45 <Janni> I definitely want to check whether some (x,y) is in there
17:13:09 <_rata_> what's this message that appear in emacs' minibuffer after loading a Haskell source file: #[nil "\300C\207"       [t]       2]
17:13:11 <_rata_> ?
17:13:33 <_rata_> (with haskell-mode)
17:13:35 <Janni> Oh well, just the standard set of operations. deleteL x, deleteR y, which would delete all relations with x/y
17:14:43 <Janni> Well, well. I'll just do it and implement it. *grumble*
17:15:21 <Janni> And then I'll probably never put it on Hackage (even though I should) because it is so trivial that it embarasses me
17:15:32 <Janni> and the next person will grumble too and do the same.
17:15:46 <Janni> And by that we can see the eternal struggle of mankind.
17:15:59 * Janni obviously needs to go to bed
17:16:16 <dancor> Janni: um this is bimap isn't it
17:16:48 <Janni> Oops, it is?
17:16:55 <dancor> looks that way
17:17:15 <dancor> they call deleteL just "delete"
17:17:15 <Janni> Uh, I think you're right.
17:17:22 <dancor> and deleteR is deleteR
17:18:09 <Janni> Hmm, no it isn't.
17:18:20 <Janni> "Each element of the left-hand type is associated with an element of the right-hand type, and vice-versa, such that the two mappings are inverses. Deleting an element will cause its twin to be deleted, and inserting a pair of elements will cause any overlapping bindings to be deleted."
17:18:37 <dancor> how is that different from what you want
17:19:07 <Janni> A relation may contain tuples (1,'a') (1,'b') (2,'c') (3,'c')
17:19:49 <dancor> what does (lookupL 1) give there
17:19:52 <dancor> "ab"?
17:20:15 <Janni> Yep.
17:21:08 <Lemmih> > [ e | (k, e) <- [(1,'a'), (1,'b'), (2,'c'), (3,'c')], k == 1 ]
17:21:09 <lambdabot>   "ab"
17:21:13 <Janni> But maybe I can just refactor the bimap source code. It's probably nice for a template.
17:21:31 <dancor> so instead of data Bimap a b = MkBimap !(M.Map a b) !(M.Map b a)
17:21:32 <Janni> Lemmih: Yes, but in O(1) please.
17:21:38 <dancor> you could do data Bimap a b = MkBimap !(M.Map a [b]) !(M.Map b [a])
17:21:50 <dancor> or maybe using Sets instead of lists
17:21:57 <Janni> Right.
17:22:37 <Janni> Just the kind of handwork I despise
17:23:04 <dancor> it develops character
17:23:10 <dancor> and you should put it on hackage!
17:23:12 <dancor> karma points
17:23:26 <Janni> Only when published on hackage.
17:24:00 <dancor> this is pretty distant from map for allowing repeated keys
17:25:00 <Mathnerd314> > let fact n = product [1..n] in let digits = reverse . unfoldUntil (== 0) (swap . (`divMod` 10))  in nub $ iterate (sum . map fact . digits) (10^7-1) -- shouldn't this work?
17:25:04 <lambdabot>   mueval-core: Time limit exceeded
17:25:11 <dancor> Data.Birel
17:25:37 <Mathnerd314> > nub $ repeat 1 -- smaller example
17:25:43 <lambdabot>   mueval: ExitFailure 1
17:26:15 <Janni> dancor: Does it exist? If yes, which package?
17:26:24 <dancor> Janni: no just brainstorming names
17:26:33 <dancor> > forever ()
17:26:33 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
17:26:41 <dancor> > forever []
17:26:42 <lambdabot>   []
17:26:43 <dancor> ha
17:27:03 <Mathnerd314> > forever [1]
17:27:04 <lambdabot>   *Exception: stack overflow
17:27:12 <twink> Mathnerd314: You can't use nub, you have to do something like head . dropWhile (uncurry (/=)) $ zip iters (tail iters)
17:27:15 <Janni> m4d haX0r
17:28:00 <dancor> > forever $ pure ()
17:28:01 <lambdabot>   No instance for (GHC.Show.Show (m b))
17:28:01 <lambdabot>    arising from a use of `M2346817207...
17:28:04 <Mathnerd314> @type \iters -> head . dropWhile (uncurry (/=)) $ zip iters (tail iters)
17:28:05 <lambdabot> forall a. (Eq a) => [a] -> (a, a)
17:28:23 <Mathnerd314> @type \iters -> head . dropWhile (uncurry (/=)) . zip iters (tail iters)
17:28:24 <lambdabot>     Couldn't match expected type `[(a, a)]'
17:28:25 <lambdabot>            against inferred type `(a1, a1)'
17:28:25 <lambdabot>       Expected type: [[(a, a)]]
17:28:32 <dancor> > fix id
17:28:36 <lambdabot>   mueval-core: Time limit exceeded
17:28:44 <dancor> score
17:31:57 <Mathnerd314> @type \iters -> map fst . dropWhile (uncurry (/=)) $ zip iters (tail iters)
17:31:58 <lambdabot> forall b. (Eq b) => [b] -> [b]
17:32:18 <Mathnerd314> let f iters = map fst . dropWhile (uncurry (/=)) $ zip iters (tail iters) in f [1,2,3,1,2,3]
17:32:24 <Mathnerd314> > let f iters = map fst . dropWhile (uncurry (/=)) $ zip iters (tail iters) in f [1,2,3,1,2,3]
17:32:25 <lambdabot>   []
17:32:44 <Mathnerd314> > let f iters = map fst . dropWhile (uncurry (==)) $ zip iters (tail iters) in f [1,2,3,1,2,3]
17:32:45 <lambdabot>   [1,2,3,1,2]
17:33:15 <Mathnerd314> twink: I don't that will get anywhere
17:35:57 <Mathnerd314> > [1..] == [1..]
17:36:01 <lambdabot>   mueval-core: Time limit exceeded
17:36:16 <Mathnerd314> ^ I think that's the problem
17:36:25 <Mathnerd314> > repeat 1 == repear 1
17:36:26 <lambdabot>   Not in scope: `repear'
17:36:27 <Mathnerd314> > repeat 1 == repeat 1
17:36:31 <lambdabot>   mueval-core: Time limit exceeded
17:36:52 <Mathnerd314> > [1..] == [2..]
17:36:53 <lambdabot>   False
17:37:21 <Mathnerd314> (==) should be defined for codata!
17:37:49 <fax> what do you mean by codata
17:38:11 <Mathnerd314> infinite lists, obviously
17:38:22 <fax> if that was obvious I wouldn't have asked
17:38:32 <Mathnerd314> oh
17:42:22 <_rata_> good bye guys... see you soon
18:19:46 <sanyi> is there a version of find that returns an index, not the found element?
18:20:20 <jmcarthur> :t findIndex
18:20:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
18:20:32 <jmcarthur> :)
18:20:54 <sanyi> thx :)
18:26:30 <copumpkin> in general, using indices on lists is an indicator of badness though
18:27:01 <fax> I don't agree
18:28:00 <blackdog> fax: you'd be on your own there:)
18:28:07 <fax> yes most likely
18:28:58 <Rotaerk> is there a version of findIndex that returns an element, not the index?
18:29:01 * Rotaerk coughs.
18:29:23 <ddarius> Perhaps find should return a zipper.
18:30:22 <copumpkin> that would be nice
18:31:11 <fax> Rotaerk: it's called find
18:31:27 <Rotaerk> :P
18:42:25 <Jonno_FTW> hi
18:42:37 <Jonno_FTW> :t printf
18:42:38 <lambdabot> forall r. (PrintfType r) => String -> r
18:43:10 <fax> hi
18:43:30 <fax> > printf "printf %d sucks" :: String
18:43:31 <lambdabot>   "printf *Exception: Printf.printf: argument list ended prematurely
18:43:35 <Jonno_FTW> how come i can't printf a list?
18:43:37 <Jonno_FTW> putStrLn  $ fmap printf brows
18:44:06 <pikhq> Jonno_FTW: Because printf doesn't do what you think it does.
18:44:17 <Jonno_FTW> what does it do? then ?
18:44:23 <Jonno_FTW> and how could i accomplish this?
18:44:36 <fax> Jonno_FTW
18:44:39 <kpreid> Jonno_FTW: What is brows?
18:44:39 <fax> why do you use printf
18:44:40 <pikhq> It transforms a string into a member of the PrintfType typeclass. :P
18:44:40 <Jonno_FTW> fax
18:44:40 <fax> ?
18:44:50 <Jonno_FTW> it's a list of browsers taken out of a log file
18:44:59 <kpreid> Jonno_FTW: so it's a list of strings?
18:45:02 <daviddarais> try (printf "here is a list %s" (show myList) :: String)
18:45:03 <Jonno_FTW> yes
18:45:13 <kpreid> Jonno_FTW: how do you want each string separated from the next - new line?
18:45:15 <pikhq> mapM putStrLn
18:45:28 <Jonno_FTW> i want each browser on a new line
18:45:41 <kpreid> Jonno_FTW: then what pikhq said -- or, rather, mapM_ putStrLn
18:45:47 <Jonno_FTW> ok
18:45:54 <pikhq> Erm. Yeah.
18:46:04 <Jonno_FTW> is mapM_ in prelude?
18:46:22 <Cale> Jonno_FTW: If not, then Control.Monad
18:46:32 <Jonno_FTW> ok
18:46:35 <ddarius> @hoogle mapM_
18:46:35 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
18:46:35 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
18:46:35 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
18:46:53 <Cale> Sometimes if the action is longer than the expression for the list, you'll want forM_ instead
18:47:19 <Cale> which is the same as mapM_ with the parameters flipped so that you can write things like  forM_ [1..1000] $ \n -> do ...
18:47:23 <pikhq> forM_ = flip mapM_
18:47:54 <Jonno_FTW> cool
18:47:57 <Cale> btw, the _ at the end of the name is just an indication that the results of each iteration are to be thrown away
18:48:14 <Jonno_FTW> how does that differ from mapM then?
18:48:25 <Cale> mapM/forM will collect the result of each iteration for you (when you're just printing stuff, the results will be () anyway, so you don't care)
18:48:45 <Cale> With mapM/mapM_ you put the function first and the list second
18:49:07 <kpreid> Cale: Would the useless list be optimised away? Curious about the state of the art.
18:49:09 <Cale> So the loop "body", if you will, comes before the loop "index" (the list)
18:49:41 <Cale> kpreid: hmmm
18:49:47 <Cale> I seem to recall that it's not.
18:49:55 <Cale> But I haven't tried it in 6.12.
18:50:07 <kpreid> Jonno_FTW: For example. if you want a classic imperative "for each ITEM in LIST do ..." then you can write
18:50:07 <kpreid> forM_ list $ \item -> do
18:50:07 <kpreid>   ...
18:50:11 <dobblego> > let phis = ((uncurry (flip (/))) <$> ap zip tail fibs) where fibs = 1:1:zipWith (+) fibs (tail fibs) in phis !! 2000
18:50:12 <lambdabot>   NaN
18:50:17 <dobblego> why is this NaN?
18:50:41 <Cale> mmm...
18:50:49 <Cale> > let phis = ((uncurry (flip (/))) <$> ap zip tail fibs) where fibs = 1:1:zipWith (+) fibs (tail fibs) in phis
18:50:50 <lambdabot>   [1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619047619047...
18:50:54 <Cale> hmm
18:51:06 <Cale> oh, I see
18:51:07 <dobblego> I think it's something to do with defaulting the type of (/)
18:51:14 <Cale> yeah, you eventually do Infinity/Infinity
18:51:23 <Jonno_FTW> i thought there is an easier way to find an approximation of phi
18:51:26 <dobblego> oh right
18:51:28 <Cale> fibonacci numbers get very large rather quickly
18:51:31 <fax> phi r squared
18:51:38 <dobblego> (1 + sqrt 5) / 2
18:51:41 <dobblego> > (1 + sqrt 5) / 2
18:51:42 <lambdabot>   1.618033988749895
18:51:57 <kpreid> that's a *boring* way.
18:51:58 <Cale> > iterate (\x -> x - (x^2 - x - 1) / (2*x - 1)) 1
18:52:00 <lambdabot>   [1.0,2.0,1.6666666666666667,1.619047619047619,1.618034447821682,1.618033988...
18:52:06 <fax> > (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) . (1 +) . (1 /) $ 1
18:52:08 <lambdabot>   1.6180555555555556
18:52:32 <Cale> > iterate ((1+) . (1/)) 1
18:52:33 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
18:52:37 <Jonno_FTW> what if you had a custom implementation of sqrt
18:52:42 <kpreid> > (iterate ((1+) . (1/)) 1) !! 100
18:52:43 <lambdabot>   1.618033988749895
18:53:10 <Cale> > iterate (\x -> x - (x^2 - 2)/(2*x)) 1
18:53:12 <lambdabot>   [1.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.4142135...
18:53:37 <kpreid> @let nfix f x = if f x == x then x else nfix f (f x)
18:53:38 <lambdabot>  Defined.
18:53:45 <kpreid> > nfix ((1+) . (1/)) 1
18:53:46 <lambdabot>   1.618033988749895
18:54:01 <Cale> @let newton f f' = iterate (\x -> x - f x / f' x)
18:54:02 <lambdabot>  Defined.
18:54:26 <kpreid> @let cnfix n f x = if f x == x then (n,x) else nfix (succ n) f (f x)
18:54:26 <lambdabot>  <local>:9:42:
18:54:26 <lambdabot>      Occurs check: cannot construct the infinite type:
18:54:26 <lambdabot>        ...
18:54:56 <kpreid> OK, what'd I do wrong?
18:54:58 <Veinor> @let cnfix n f x = if f x == x then (n, x) else cnfix (succ n) f (f x)
18:54:59 <lambdabot>  Defined.
18:55:02 <dobblego> what does this warning mean? "f is exported separately but will be documented under Class. Consider exporting it together with its parent(s) for code clarity."
18:55:08 <Veinor> > cnfix 0 ((1+) . (1/)) 1
18:55:10 <lambdabot>   (38,1.618033988749895)
18:55:19 <Veinor> kpreid: you wrote nfix when you meant cnfix
18:55:22 <kpreid> doh.
18:55:33 <kpreid> sometimes you just want to point at "THIS FUNCTION"
18:55:47 <Veinor> that's what fix is for!
18:55:48 <kpreid> (it's a bad idea, but you still want it)
18:56:00 <kpreid> Naw, fix introduces the function as an argument
18:56:09 <ddarius> dobblego: Did you do something like, class C a where f :: a with a module statement like module Foo (C(..), f) or something like that?
18:56:22 <kpreid> The evil version is "a reference to the nearest lexically enclosing function definition"
18:56:35 <dobblego> ddarius, yes (though not C(..) instead just C)
18:57:13 <Veinor> kpreid: call it self or this
18:57:17 <Cale> @let within eps (a:b:xs) | abs (a-b) < eps = b | otherwise = within eps (b:xs)
18:57:17 <aavogt> if you look at the docs, it won't group f with C
18:57:18 <lambdabot>  Defined.
18:57:22 <dobblego> ddarius, why is this a problem?
18:57:24 <ddarius> dobblego: You can do something like module Foo (C(f)) if that is your intent.
18:57:25 <kpreid> Veinor: still evil!
18:57:35 <ddarius> dobblego: It's not, it's just less than obvious.
18:57:35 <Veinor> just to confuse imperative programmers more!
18:57:49 <kpreid> Veinor: (tho most[citation needed] of the languages which use 'self' don't allow nested definitions of that which self refers to)
18:57:52 <Cale> > within 0.0001 (newton (\x -> x^2 - 2) (\x -> 2*x) 1)
18:57:53 <lambdabot>   1.4142135623746899
18:58:08 <Cale> > within 0.0001 (newton (\x -> x^2 - x - 1) (\x -> 2*x - 1) 1)
18:58:10 <lambdabot>   1.618033988749989
18:58:18 <kpreid> (actually, that's probably wrong)
18:58:32 <Veinor> I feel like you can write within as a fold
18:58:38 <kpreid> Cale: cute
18:58:40 <dobblego> ddarius, that got it, thanks
18:58:51 <ddarius> Cale: Quick!  Make an automatic differentiation type so that you can just write: within 0.0001 (newton (\x -> x^2))
18:59:04 <kpreid> you mean we don't have one of those in scope already?
18:59:08 <kpreid> I'm shocked!
18:59:17 <copumpkin> we do
18:59:20 <Cale> @let withinR eps (a:b:xs) | abs (a-b) < eps * abs b = b | otherwise = withinR eps (b:xs)
18:59:21 <lambdabot>  Defined.
18:59:23 <kpreid> > newton f g x
18:59:24 <lambdabot>   [x,x - f x / g x,x - f x / g x - f (x - f x / g x) / g (x - f x / g x),x - ...
18:59:44 <Veinor> @src foldl
18:59:45 <lambdabot> foldl f z []     = z
18:59:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:59:49 <ddarius> (I guess it would actually be (\x -> x^2 - 2))
18:59:52 <Veinor> @src foldr
18:59:53 <lambdabot> foldr f z []     = z
18:59:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:01:42 <Cale> @let order (a:b:c:xs) = round (logBase 2 ((a-c)/(b-c) - 1))
19:01:43 <lambdabot>  Defined.
19:02:05 <shapr> How do I tell ghci to use mtl and ignore monads-fd when there's an ambiguous import?
19:02:16 * hackagebot Semigroup 0.0.2 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.2 (TonyMorris)
19:02:22 <aavogt> shapr: -packag mtl
19:02:26 <aavogt> package
19:02:51 <shapr> That's what I thought, but doing :set -package mtl still gives me that error.
19:03:03 <aavogt> maybe that isn't a dynamic flag
19:03:13 <shapr> Ah, could be...
19:03:56 <shapr> putting that into ~/.ghci doesn't help much either...
19:04:09 <aavogt> I mean run   ghci -package  mtl   module...
19:04:26 <Cale> @let elimError n (a:b:xs) = ((b * 2**n - a)/(2**n - 1)) : elimError n (b:xs)
19:04:27 <lambdabot>  Defined.
19:04:33 <shapr> aavogt: just tried that, same thing
19:04:37 <Cale> @let improve xs = elimError (order xs) xs
19:04:38 <lambdabot>  Defined.
19:04:57 <aavogt> there's `ghc-pkg hide monads-fd', if you never want to implicitly use that library
19:05:28 <shapr> aavogt: works, yay!
19:05:31 <Cale> > improve (newton (\x -> x^2 - x - 1) (2*x - 1) 1)
19:05:32 <lambdabot>   Couldn't match expected type `b -> b'
19:05:32 <lambdabot>         against inferred type `Simple...
19:05:43 <Cale> > improve (newton (\x -> x^2 - x - 1) (\x -> 2*x - 1) 1)
19:05:44 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:05:44 <lambdabot>    `GHC.Real.Integral b'
19:05:44 <lambdabot>   ...
19:05:52 <Ziphilt> hello all
19:05:53 <Cale> oh, oops
19:06:11 <Ziphilt> i was curious about a potential feature in haskell
19:06:18 <Cale> tsk, should have noticed :P
19:06:28 <Cale> Ziphilt: yeah?
19:06:51 * Cale corrects the 2**n to 2^n directly ;)
19:07:06 <Ziphilt> in the Logo programming lang (dialect of Lisp), one can concatenate strings that will form the name of a method (lisp impure function) and then call the function
19:07:18 <Cale> > improve (newton (\x -> x^2 - x - 1) (\x -> 2*x - 1) 1)
19:07:20 <lambdabot>   [NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,Na...
19:07:23 <Cale> hmmm
19:07:25 <aavogt> hehe
19:07:27 <kpreid> No, you can't refer to a definition at runtime.
19:07:35 <Ziphilt> so one can call a "cake" function or a "make" function depending on which you want
19:07:39 <Veinor> something isn't right there!
19:07:40 <Cale> That's not much of an improvement ;)
19:07:42 <kpreid> Unless you made a map first, or have an interpreter in your program.
19:07:44 <Ziphilt> i thought it was a neat abstraction
19:07:48 <Cale> > cake
19:07:50 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
19:07:55 <Veinor> @src newton
19:07:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:08:02 <kpreid> Ziphilt: it's one that can be done much better in real systems by having explicit mappings
19:08:05 <Ziphilt> i concur, lambdabot
19:08:15 <aavogt> Ziphilt: you can link ghc as an interpreter to get a proper `eval', or do that stuff with compile-time metaprogramming...
19:08:18 * hackagebot NonEmptyList 0.0.6 - A list with a length of at least one.  http://hackage.haskell.org/package/NonEmptyList-0.0.6 (TonyMorris)
19:08:36 <aavogt> depending on where your strings come from
19:08:55 <Cale> oh, I see
19:08:56 <Ziphilt> thanks, that sounds fun
19:09:18 <Jonno_FTW> how come this doesn't work? let oses   =  nub $ fmap (\x -> maybe ((words x) !! 12)) input
19:09:22 <Ziphilt> metaprogramming is is a cool subject
19:09:34 <Jonno_FTW> in the case where 12 is too higher an index
19:09:41 <Zao> Jonno_FTW: Well, what does your friendly compiler say?
19:09:44 <kpreid> Jonno_FTW: that's not what maybe does
19:09:49 <alpounet> @type maybe
19:09:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:09:56 <aavogt> Jonno_FTW: how are you to compare functions for equality?
19:10:04 <Zao> @src maybe
19:10:04 <lambdabot> maybe n _ Nothing  = n
19:10:04 <lambdabot> maybe _ f (Just x) = f x
19:10:15 <Cale> @let differentiate h0 f x = map (\h -> (f (x+h) - f x) / h) (iterate (/2) h0)
19:10:16 <lambdabot>  Defined.
19:10:18 <kpreid> Jonno_FTW: If you want to handle the list being to short, *don't use !*
19:10:24 <Jonno_FTW> i want it to return nothing if the index is too high
19:10:28 * kpreid typos twice
19:10:40 <Jonno_FTW> what do I use then?
19:10:46 <Zao> Jonno_FTW: Use head.drop maybe?
19:11:02 <kpreid> Not head but listToMaybe
19:11:06 <Zao> Or listToMaybe.drop
19:11:10 <aavogt> @hoogle Int -> [a] -> Maybe a
19:11:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:11:11 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:11:11 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
19:11:12 <Cale> > differentiate 1 (\x -> x^2 - 2) 1
19:11:13 <lambdabot>   [3.0,2.5,2.25,2.125,2.0625,2.03125,2.015625,2.0078125,2.00390625,2.00195312...
19:11:19 <kpreid> > (listToMaybe . drop 12) [1..]
19:11:20 <lambdabot>   Just 13
19:11:22 <Cale> > improve (differentiate 1 (\x -> x^2 - 2) 1)
19:11:23 <lambdabot>   [2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2....
19:11:23 <kpreid> > (listToMaybe . drop 12) [1..5]
19:11:24 <lambdabot>   Nothing
19:11:29 <kpreid> > (listToMaybe . drop 3) [1..5]
19:11:30 <lambdabot>   Just 4
19:11:38 <ManateeLazyCat> If i import C function with "unsafe", RTS will stop when this C function is execute, right?
19:11:39 <alpounet> > differentiate 1 exp 1
19:11:40 <kpreid> Jonno_FTW: use (listToMaybe . drop 12)
19:11:40 <lambdabot>   [4.670774270471606,3.526814483758039,3.0882445160111853,2.8954801636718877,...
19:11:44 <Jonno_FTW> but thanks
19:12:16 <alpounet> that's fairly interesting Cale
19:12:30 <alpounet> do we have something like that on hackage ?
19:13:08 <Cale> alpounet: I don't know
19:13:10 <Makoryu> :t improve
19:13:11 <lambdabot> forall t. (RealFrac t, Floating t) => [t] -> [t]
19:13:30 <aavogt> > differentiate (x**2) :: Expr
19:13:31 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:13:31 <lambdabot>         against inferred ...
19:13:45 <Cale> > improve (differentiate 1 exp 1)
19:13:47 <lambdabot>   [2.382854697044472,2.649674548264332,2.70271581133259,2.714571539135026,2.7...
19:13:52 <Cale> > improve (improve (differentiate 1 exp 1))
19:13:54 <lambdabot>   [2.7386144986709517,2.7203962323553426,2.7185234484025043,2.718310722155212...
19:14:00 <Cale> > improve (improve (improve (differentiate 1 exp 1)))
19:14:02 <lambdabot>   [2.717793622881684,2.7182559078378135,2.718280332691314,2.7182817385924603,...
19:14:03 <Veinor> :t improve
19:14:04 <lambdabot> forall t. (RealFrac t, Floating t) => [t] -> [t]
19:14:19 <djahandarie> Didn't oleg write something really cool about doing typeful symbolic derivitives of compiled functions?
19:14:20 <ManateeLazyCat> In other word, "unsafe" keyword point we can't call this C function in different "OS threads", right ?
19:14:31 <alpounet> > iterate improve (differentiate 1 exp 1)
19:14:32 <lambdabot>   [[4.670774270471606,3.526814483758039,3.0882445160111853,2.8954801636718877...
19:15:31 <djahandarie> http://www.haskell.org/pipermail/haskell/2004-November/014939.html
19:15:36 <Cale> @let super = map (head . tail) . iterate improve
19:15:37 <lambdabot>  Defined.
19:15:44 <Cale> > super (differentiate 1 exp 1)
19:15:46 <lambdabot>   [3.526814483758039,2.649674548264332,2.7203962323553426,2.7182559078378135,...
19:16:03 <_rata_> hi haskellers
19:16:14 <Makoryu> _rata_: The burrito metaphor is this way ->
19:16:23 <Cale> > super (differentiate 0.001 exp 1)
19:16:24 <lambdabot>   [2.7189615121923083,2.718281771821651,2.7182818284590127,NaN,*Exception: Ne...
19:16:28 <Cale> heh
19:16:37 <Veinor> > map headwhat about the burrito metaphor?
19:16:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:16:41 <Veinor> ...
19:16:42 <ManateeLazyCat> preflex: seen danharaj
19:16:42 <preflex>  danharaj was last seen on #haskell 2 hours, 14 minutes and 34 seconds ago, saying: human ones anyway, mirite?
19:16:44 <Veinor> I hate it when I do that
19:16:55 <ManateeLazyCat> danharaj: Still there?
19:17:34 <djahandarie> lol Veinor
19:17:43 <Veinor> yeah
19:17:52 <Veinor> anyway, what is this about the burrito metaphor? :P
19:17:56 <alpounet> Cale, it may be nice to put a module up with that kind of stuffs
19:18:03 <djahandarie> Man, oleg needs to stop using "email this to some random list" as his primary method of sharing stuff
19:18:12 <Cale> alpounet: Yeah. This is pretty much just stolen from whyfp
19:18:16 <djahandarie> http://okmij.org/ftp/Haskell/differentiation/Diff.txt << also cool
19:18:40 <ManateeLazyCat> danharaj: Just suggestion, if you want running multi-threaded for gtk2hs, you must enable "-threaded" flag and use `unsafeInitGUIForThreadedRTS` instead `initGUI`.
19:18:41 <alpounet> yes, but still pretty elegant and useful
19:19:07 <Cale> yeah, being elegant is the point of it :)
19:19:14 <ManateeLazyCat> danharaj: If you just use "initGUI", Gtk+ main thread will blocking any other threads in gtk2hs program.
19:19:51 <ManateeLazyCat> danharaj: Everything will be okay if you use `postGUIAsync` wrap gtk+ code in other threads.
19:20:04 <ddarius> alpounet: Cale's definition of differentiate is not terribly beautiful...
19:20:26 <alpounet> ddarius, how would you write it ?
19:20:26 <djahandarie> That automatic differentation stuff is really cool too
19:20:31 <Cale> The neat thing is that you can use improve to get higher order methods of differentiation automatically
19:20:43 <ddarius> alpounet: I would avoid numerical differentiation altogether.
19:20:44 <Cale> the same improve function can also be used to improve integrators
19:21:09 <alpounet> ddarius, you would go for automatic differentiation ?
19:21:12 <ManateeLazyCat> Cale: What's automatic differentation ?
19:21:21 <ddarius> alpounet: If possible.
19:21:24 <ManateeLazyCat> Cale: I'm interested...
19:21:32 <alpounet> Cale, by the way, take a look at my email regarding Maths & AI
19:21:35 <alpounet> you might be interested
19:21:38 <alpounet> (on -cafe)
19:21:52 <djahandarie> ...did Cale even mention automatic differentiation? :P
19:22:16 <alpounet> ddarius, as exposed in one of conal's articles ?
19:22:18 <ManateeLazyCat> djahandarie: What are you talking about?
19:22:25 <ManateeLazyCat> djahandarie: I'm interested....
19:22:43 * ManateeLazyCat Wake up just now...... :) 
19:22:43 <djahandarie> Ah yes it was conal who wrote about this
19:22:50 <Cale> ManateeLazyCat: Instead of using plain numbers, use pairs which represent a number and the derivative of the applied function at a given point.
19:22:59 <djahandarie> ManateeLazyCat, http://conal.net/blog/posts/what-is-automatic-differentiation-and-why-does-it-work/
19:23:12 <conal> also, http://conal.net/papers/beautiful-differentiation
19:23:23 <ddarius> alpounet: It's been discussed in a couple of places before then, though that is a particularly elegant formulation.
19:23:30 <conal> one version from ICFP 09, and another for JFP.
19:23:41 <alpounet> yes
19:24:10 <ManateeLazyCat> conal: I'm reading it, looks every cool....
19:24:51 <conal> ManateeLazyCat: great.  it's my best example yet of denotational design, and type-class morphisms in particular.
19:25:21 <ManateeLazyCat> conal: Any big improve for type-class in particular?
19:25:24 <conal> in the end auto-diff comes down to a simple, compelling formal spec (denotation) and a few morphisms.
19:26:20 <conal> ManateeLazyCat: the TCM idea is explained & illustrated in http://conal.net/papers/type-class-morphisms
19:26:48 <Cale> ManateeLazyCat: It basically comes down to the fact that the chain rule says that knowing the value and derivative of a function h at a given point x, you can compute the value and derivative of (g . h) at the same point (given the derivative of g)
19:27:15 <conal> DD and TCM have become my main tools in library design.
19:27:45 <Cale> (g . h)' x = g' (h x) * h' x, and so if you already know h x and h' x, then you're fine
19:28:01 <alpounet> conal, any work on manifolds in haskell yet ?
19:28:12 <conal> alpounet: no, not yet.
19:28:30 <conal> alpounet: probably a very fertile area to explore.
19:29:19 <Cale> I've never managed to find a book on differential geometry that I actually liked the notation in.
19:29:36 <alpounet> conal, for sure!
19:29:40 <Cale> and no two of them use the same notation :P
19:29:45 <alpounet> if you ever do, keep me posted
19:30:00 <ddarius> Cale: You should look at "Clifford algebra to geometric calculus" (for yet another notation).
19:31:57 <danharaj> Manifolds have a lot of structures that are related to each other in nice ways.
19:32:03 <danharaj> Like tangent planes associated to points.
19:32:25 <danharaj> Sounds like dependent typing can nicely capture those relationships, and show that your manipulations are correct by typing them.
19:33:14 <ddarius> danharaj: While you are probably correct, I imagine it is very easy to settle for a "brute-force" solution using dependent types.
19:34:29 <Cale> I have seen some differential-geometry-related stuff which used nice notation, but nothing introductory. I'll see if I can find the Clifford algebra to geometric calculus text. I think that a lot of the notational fail comes from physicists.
19:34:57 <danharaj> Also terminological fail.
19:35:02 <ManateeLazyCat> Cale: It's helpful if have simple demo. :)
19:35:16 <ManateeLazyCat> Cale: Still have a little confusion :)
19:35:23 <Cale> Like, using letters which are supposed to represent indices as subscripts, but where you can't replace the letters with the actual numbers they represent, because they also represent bases.
19:35:23 <BMeph_> Topological fail? ;þ
19:35:27 <danharaj> It's actually a strange coincidence, I was just doing surface differential geometry homework :p
19:36:21 * BMeph_ always things of a Greek hors d'oervre whenever he hears "topoi" being bandied about...
19:36:56 <Cale> danharaj: Yeah, referring to something as a "tensor" when it's actually a tensor valued function, for example.
19:37:10 <Cale> I hate that.
19:37:12 <danharaj> Or calling things gauges instead of principle bundles.
19:37:15 <ddarius> Cale: That's what "field" is for.
19:37:19 <ManateeLazyCat> Reading http://docs.google.com/viewer?url=http://conal.net/papers/type-class-morphisms/type-class-morphisms-long.pdf&pli=1
19:37:33 <Cale> ddarius: "tensor field" is also okay
19:37:48 <Cale> ddarius: But some people leave the word out altogether
19:37:50 <fax> Cale - I'm kinda surprised you don't like that
19:38:10 <fax> I thouht you would just take stuff like that in your stride
19:38:19 <fax> what do you think of the dy/dx notation? :D
19:38:28 <Cale> fax: It makes things much more work to typecheck when people do that
19:38:34 <Cale> fax: mostly dislike it
19:39:08 <danharaj> eh, dy/dx is alright when the inverse function theorem holds.
19:39:12 <Cale> (though I will use it in simple enough cases)
19:40:11 <Cale> dy/dx makes it awkward and confusing to apply the derivative at a point
19:40:31 <Cale> people end up writing the most ridiculous things, like bars with subscripts and so on
19:40:39 <danharaj> oh are we talking about d/dx, not implicit differentiation >_<
19:40:42 <fax> can I ask a math question
19:40:58 <danharaj> like manipulating the differentials like numbers?
19:41:06 <fax> if I could go back and tell myself 5 years ago what to study I would say linear algebra because it's like a really good gateway type thing
19:41:23 <Cale> danharaj: Well, I wasn't even thinking of differentials, just the Leibniz notation for derivatives.
19:41:23 <fax> but what should my future self tell myself now??
19:41:37 <fax> like what is the thing to study
19:41:44 <Cale> What do you already know?
19:42:03 <danharaj> I can see where you're coming from. Although I love the objects themselves.
19:43:18 <ManateeLazyCat> danharaj: Is you ask me network-data singal with gtk2hs yesterday? Sorry, i don't remember the nickname.
19:43:31 <Cale> fax: Do you have Awodey's book on category theory?
19:43:32 <danharaj> ManateeLazyCat: no that was not me
19:43:53 <fax> no
19:43:59 <ManateeLazyCat> danharaj: Sorry, must be another guy have similar nickname like you. Sorry. :)
19:44:00 <fax> I have Barr & Wells and Rydeheard and Brurstall here
19:44:21 <fax> Cale - (well I have done real and complex calculus and some abstract algebra & galois and just a tiny bit of number theory)
19:44:28 <tensorpudding> i think i have seven or so category theory ebooks
19:44:34 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
19:44:45 <Cale> ^^ this is my favourite intro to CT
19:44:56 <dolio> Awodey quits just when things are getting interesting, though. :)
19:45:34 <ManateeLazyCat> Cale: We can't execute "unsafe" C function in different "OS threads", right?
19:46:16 <fax> that's cool I will get on this, and what about other than category theory?
19:46:33 <ManateeLazyCat> Cale: And RTS will stop when execute "unsafe" C function?
19:46:43 <danharaj> Am I interpreting the table of contents correctly that functors only come up starting on page 125??
19:46:58 <Cale> http://cale.yi.org/share/Roman%20-%20The%20Umbral%20Calculus.djvu -- this is a cute application of linear algebra which you might enjoy. I'm not sure how useful the results are, but as a little piece of pure mathematics, it's glorious.
19:47:10 <fax> thanks :)
19:47:31 <Cale> http://cale.yi.org/share/Roman%20S.%20-%20Advanced%20Linear%20Algebra.pdf -- by the same author, a lovely book on linear algebra for people who think they know everything there is to know about linear algebra
19:47:55 <alpounet> but after that book
19:48:16 <ddarius> Differential operators have a fun algebra (which leads into quantum mechanics)
19:48:18 <alpounet> has the author planned another book for people thinking they by then know everything about LA ?
19:48:32 <Cale> alpounet: hehe
19:48:33 <monochrom> haha
19:48:36 <nornagon> @hoogle (a -> b) -> (a,a) -> (b,b)
19:48:36 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:48:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:48:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
19:48:43 <nornagon> hrm
19:49:32 <ddarius> dolio: Many authors quit before Awodey and/or fail to give as clear a presentation.
19:49:55 <dolio> That's true.
19:49:58 <monochrom> The normal sequence is not like that. The normal sequence is like this: after that book, you think that you know nothing about linear algebra. There is also next book, after which you think the author knows nothing about linear algebra, too.
19:50:08 <fax> lol
19:50:09 <twink> Cale: omfg that's coming down so dogslow are you on ADSL or something?
19:50:23 * fax thinks probably a million people are downloading it
19:50:37 <dolio> Basic Category for Computer Scientists barely gets anywhere.
19:51:16 <ddarius> dolio: That was my impression when I skimmed it.
19:51:18 <Cale> twink: No, I'm on cable. My connection maxes out around 150 KB/s upload, and it's pegging at that right now.
19:51:32 <ddarius> dolio: From what I've heard of "Conceptual Mathematics," it goes nowhere at all.
19:51:42 <danharaj> I have that, it literally goes nowhere.
19:51:45 <fax> Conceptual Mathematics is very very basic
19:51:52 <fax> it's a good book but it is high school level
19:51:59 <fax> or earlier
19:52:00 <danharaj> I was sorely disappointed, I should have read the table of contents before buying. I saw Lawvere's name and I thought it would be nifty :p
19:52:12 <BMeph_> conal: Did you post an analysis of Hinkey's ramblings? ;)
19:52:45 <conal> BMeph_: i haven't watched his talk yet.  am curious.
19:52:45 <Cale> Algebraic Topology is cool, but I don't know what book to recommend. Hatcher has a freely available one which isn't altogether terrible, but he does homotopy in a silly way, in my opinion, and the 0th chapter is confusing (you should just skip it)
19:53:27 <Cale> "Algebraic Graph Theory" by Godsil and Royle is a cool little book with lots of fun problems in it.
19:53:40 <fax> by the way
19:53:44 <dolio> ddarius: Yeah. It seemed like it was suited for grade schoolers when I found it once in a store.
19:53:52 <fax> when it has the prefix 'Algebraic' does that mean it's all about polynomials
19:53:53 <fax> ?
19:54:44 <Cale> fax: no, it usually indicates that you're studying structures in terms of the homomorphisms between them.
19:54:51 <fax> aha
19:55:05 <Cale> and usually via functors to nice classically algebraic structures like groups or rings
19:55:53 <ddarius> *cough* cohomology groups *cough* fundamental groupoid *cough*
19:56:11 <danharaj> *cough* modern mathematics *cough* >_>;;;
19:56:20 <Cale> So you take your topological spaces, which typically have an uncountable infinity of points, and replace them with groups, which may even be finite, but are usually at least discrete
19:57:13 <Cale> and this gives you a way of, for instance, telling two topological spaces apart (so you can show there won't be an isomorphism between them)
19:57:14 <ddarius> I really like the build up to the idea of a homology group.
19:57:21 <Cale> and understanding other parts of their structure
19:58:18 <danharaj> of course there's also things like quantum manifold invariants that are just mysterious.
19:58:43 <Cale> I love the fundamental groupoid idea. That's actually the main thing I dislike about Hatcher's text is that he does fundamental groups in this awkward way, and does the Seifert van-Kampen theorem in this silly way which obscures the fact that you're just preserving pushouts.
19:59:30 <ezyang> Yep. Each step is nontrivial.
19:59:32 <Cale> (He describes the pushout in groups explicitly without saying that it is a pushout)
19:59:37 <ezyang> mix
20:00:54 <Cale> fax: I should say though, I didn't mean to give the impression that there *won't* also be polynomials involved ;)
20:01:15 <Cale> Algebraic geometry involves polynomial rings quite a bit :)
20:01:33 <alpounet> people interested in haskell&math : http://www.haskell.org/pipermail/haskell-cafe/2010-May/077243.html
20:02:28 <ddarius> I consider algebraic geometry and algebraic topology to be quite distinct, though definitely related, fields of study.
20:02:42 <Cale> alpounet: That seems cool, but I don't really know a heck of a lot about AI or neural networks.
20:02:52 <Cale> ddarius: absolutely :)
20:02:58 <alpounet> Cale, sure, but there also is a Mathematics part in that
20:03:03 <alpounet> the initial idea was about AI
20:03:17 <danharaj> 'Mathematics'
20:03:21 <danharaj> That is a very big thing.
20:03:25 <alpounet> yeah
20:03:59 <danharaj> Is it from a computational angle, or more theoretical/proofs?
20:04:05 <danharaj> Both? Where do you start?
20:04:15 <alpounet> more like computational
20:04:41 <alpounet> the kind of stuffs you would do with mathematica/whatever
20:04:43 <fax> thank you !!
20:04:44 <alpounet> for example.
20:05:14 <danharaj> What existing libraries in haskell would you like to complement, what libraries in other languages would you like to surpass?
20:05:24 <ddarius> Cale: Is that Umbral Calculus "paper" basically just chapter 19 of the other book?
20:05:36 <Cale> ddarius: It's another book
20:05:45 <Cale> ddarius: a more thorough book on the umbral calculus
20:07:58 * ddarius considers making a paper that is a representation of "Denotational design and type class morphisms" that is Haskell agnostic.
20:08:20 <ddarius> s/representation/re-presentation/
20:08:36 <alpounet> danharaj, we miss a lot of stuffs in the domain of linear/non linear regressions, polynomial fitting and such stuffs, for example
20:08:58 <Cale> It's a cool piece of linear algebra particularly for those who have seen some functional analysis, because it mirrors a bunch of functional analysis in a simplified combinatorial way. :)
20:10:01 * ddarius needs to get some web space to upload (small) things.
20:10:14 <Cale> I just run apache on my own machine :)
20:10:18 <fax> win 11
20:10:31 <ddarius> Cale: My machine is a laptop using a wifi connection...
20:10:36 <Cale> ah
20:11:05 * BMeph_ when seeing "HNN" always imagines an animated interweaving group of lambdas, with a James Earl Jones voice-over.
20:11:24 <alpounet> BMeph, haha
20:12:24 <Cale> The umbral calculus came out of this cute realisation that a lot of classical sequences of polynomials which show up in various places throughout physics and mathematics seem to satisfy something which looks a lot like the binomial theorem. In place of (x+y)^n = sum over k = 0 to n of (n;k) x^k y^(n-k), you would have p_n(x+y) = sum over k = 0 to n of (n;k) p_k(x) p_(n-k)(y)
20:12:48 <Cale> So the subscripts on the sequences of polynomials behaved like exponents with regard to the binomial theorem
20:12:52 <alpounet> looks interesting
20:13:06 <twink> alpounet: Rational regression (least \ell^1 and/or \ell^\infty norms) is something I've had trouble finding material on.
20:13:50 <cdsmithus> Just need a quick pointer: how can I retrieve the Ethernet MAC address on my machine from a Haskell application.  Any libraries for that?
20:14:39 <Cale> Initially, there was a bunch of suspicion about exactly how far you could take this, and when. It was not very rigourous and people didn't really know why this was happening. Gian-Carlo Rota came along and straightened things out with a lovely formalism, and the book describes the modern version of that.
20:14:47 <alpounet> twink, i just have heard about it ; interested in proposing an implementation for it ?
20:15:06 <copumpkin> cdsmithus: I don't think there's a platform-independent way to do that
20:15:50 <ddarius> Cale: So why does it work out in enough cases to be interesting?
20:15:57 <twink> alpounet: I mostly just wanted a lib and/or enough info to write it.
20:15:58 <luite> which book is this?
20:16:02 <ddarius> Also, it is related to (generalizations of) species.
20:16:13 <alpounet> twink, yeah, and that's the kind of stuffs i have in mind for that strike force
20:16:20 <alpounet> but for as much maths domains as possible
20:16:30 <alpounet> including ai-related techniques
20:16:38 <ddarius> alpounet: You should implement the Risch algorithm.
20:17:11 <alpounet> by the way, i just joined #haskell-math, people interesting in this "math strike force" may want to do it too
20:17:21 <cdsmithus> Ansering my own question: http://hackage.haskell.org/package/maccatcher-1.0.0
20:17:25 <alpounet> i have in mind something similar to the haskell webdev effort, but for math
20:19:10 <ddarius> cdsmithus: That module looks pretty crappy.
20:21:13 <ddarius> Cale: I'm assuming it has something to do with multiplication of formal power series leading to coefficients with sums of binomial coefficients (but I should probably just read something.)
20:21:17 <Cale> ddarius: because those sequences of polynomials get generated in a particular fixed way after picking linear functionals (with just a rather easily-satisfied condition) on the vector space of polynomials
20:22:37 <ddarius> (If one is going to be tilting at windmills, one might as well tilt at big windmills.)
20:24:35 <Cale> You can write any linear functional on the space of polynomials as a formal power series, and if f(t) = sum over k >= 0 of a_k t^k/k!, then set <f(t) | x^n> = a_n
20:25:28 <Cale> (we use t as the indeterminate for our power series ring representing the linear functionals in this way, and x for polynomials)
20:26:19 <Cale> There are a bunch of nice things about this: <e^(yt) | x^n> = y^n, for instance :)
20:26:43 <Cale> and so <e^(yt), p(x)> = p(y)
20:27:03 <ddarius> That is pretty nice.
20:28:31 * ddarius goes to read "The Ringworld Engineers" and pass out, not necessarily in that order.
20:28:39 <Cale> A formal power series f with a compositional inverse, that is some power series g for which g(f(t)) = f(g(t)) = t is called a delta series
20:28:42 * BMeph_ wonders how long it'll take until someone markets a windmill with mylar strips to suggest a wire-spoked wheel...
20:30:53 <Cale> and then if f(t) is any delta series, and g(t) its compositional inverse, we can write p_n(x) = sum over k = 1 to n of (<g(t)^k | x^n> / k!) x^k, and this is called the associated sequence for f(t).
20:31:14 <Cale> and it's exactly the associated sequences which satisfy the generalised binomial-theorem type identity
20:31:35 <Cale> and they have lots of other nice properties relating to f(t) and g(t)
20:31:36 <Ramb0> Hi
20:31:42 <Cale> Ramb0: hello
20:32:12 <luite> Cale: what book was this about? (if any in particular)
20:32:26 <Cale> luite: The Umbral Calculus
20:32:40 <luite> by steven roman?
20:32:42 <Cale> yeah
20:33:25 <luite> ok thanks :)
20:33:55 <Cale> Though originally a good deal of the work is due to Gian-Carlo Rota -- I think Steven Roman might have been his student.
20:35:30 <Ramb0> I have to choose a Unit Testing library for haskell.. Quick Check or Haskell Unit ?
20:35:40 <Cale> Ramb0: Perhaps a bit of both?
20:36:02 <Cale> Ramb0: Unit tests are sort of the limiting case of quickcheck where the properties you give it have no parameters
20:36:16 <Cale> Ramb0: HUnit is possibly nicer for that special case.
20:38:01 <Cale> The way that QuickCheck works is you give it a function which should always produce True if your code is correct, and it randomly applies values to it (it knows which type of random values to generate because of typeclasses and type inference), and sees if it can falsify the claim
20:38:33 <Cale> If it finds a counterexample, it tries to alter the counterexample in various ways to simplify it into a minimal testcase which fails.
20:39:04 <Ramb0> hmmm
20:39:38 <_wsh> hey all:  a quick, um, I'm not sure how to put this, but perhaps RFP
20:39:38 <Ramb0> So, Quickcheck, trows random input, while hUnit checks special cases?
20:39:43 <Cale> yeah
20:39:47 <_wsh> @Ramb0:  yeah
20:39:48 <lambdabot> Unknown command, try @list
20:39:53 <_wsh> Ramb0:  yeah
20:40:29 <_wsh> (with regard to my query:  anyone have an idea or two for me regarding dependent types in Haskell, as in, in terms of perhaps doing a project based on them?)
20:40:55 <_wsh> (as in, I'm familiar with Conor McBride's work on the subject, but I'm not sure what the state of things is...I've tried to do my homework here but I'm not sure where to go.)
20:41:01 <Cale> hmmm
20:41:30 <Cale> Like, implementing dependently typed languages using Haskell, or adding dependent types to existing Haskell compilers?
20:41:57 <_wsh> given the beauty of Haskell, I think I'd prefer the latter, but the former sounds interesting.
20:42:00 <_wsh> (as well.)
20:42:10 <Ramb0> Thanks for the answers guy's, I haven't got enought time to use both, I think the best will be use HUnit. Im just learning haskell.
20:42:20 <_wsh> Cale:  I'm sorry if I'm being too general, I'm just literally at a loss.
20:43:33 <Cale> Haskell isn't itself a dependently typed language of course. Conor has this thing called 'She' which is a preprocessor that can sort of simulate dependent types.
20:44:05 <Cale> I don't know what you'd do in order to add dependent types to GHC. That seems like it might be quite involved...
20:44:10 <_wsh> Cale:  indeed, I'm aware on both counts.
20:44:17 <_wsh> and yeah, it would be.
20:44:25 <_wsh> this would be my undergraduate thesis.
20:44:47 <danharaj> Is there someone knowledgable in the subject that can be your advisor?
20:44:48 <_wsh> as in, if you have any ideas that are related but you think might fit better, please feel free to throw them at me.
20:44:57 <_wsh> danharaj:  yes, fortunately.
20:45:05 <_wsh> though he's more of a Prolog guy.
20:45:15 <_wsh> not that that pertains specifically to this
20:45:26 <_wsh> but his research interests do lie elsewhere; otherwise I'd be working more closely with him.
20:45:45 <_wsh> that, and he's difficult to coordinate with :S
20:45:51 <danharaj> heh
20:45:54 <_wsh> we were going to do a literature search but he's been too busy.
20:46:07 <_wsh> not that I'm trying to blame him, of course
20:46:15 <_wsh> I'm just...I don't even know how to express it...at a loss
20:46:23 <_wsh> it's a pretty vast world out there, you know.
20:46:23 <Cale> yeah, hmm
20:46:28 <_wsh> and you want to do something original and useful
20:46:33 <_wsh> and yet I also only have a year.
20:46:43 <danharaj> Maybe you can strip down haskell to a basic simply typed system, and then add dependent types to that.
20:46:55 <_wsh> danharaj:  hmmm
20:47:22 <_wsh> (as in, give me a few minutes to think about that and tell me more)
20:47:27 <_wsh> (if you would :) )
20:47:42 <Cale> There are (supposedly) simple implementations of dependent typechecking in Haskell -- there was a paper a while back that you should definitely read if you haven't seen it already...
20:48:29 <_wsh> which paper?
20:48:32 <_wsh> Faking It?
20:49:11 <Cale> uh, hang on, trying to find it and my connection's all screwy because my router has trouble when I've recently been on a torrent
20:49:29 <_wsh> Cale:  bah, all right
20:49:34 <_wsh> and thank you both for your help with all this.
20:49:41 <_wsh> it's been the source of considerable stress!
20:50:16 <danharaj> I haven't given you much help at all :p
20:50:28 <Cale> Maybe it was "Simply Easy!"
20:50:52 <Cale> "Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus)" Andres LÃ¶h, Conor McBride and Wouter Swierstra
20:51:21 <_wsh> danharaj:  nonsense; you've given me somewhere to look/something to think about, which is more than I had before
20:52:10 <_wsh> Cale:  I haven't seen that specifically, but I have LÃ¶h's "Implementing Dependent Types in Haskell" (listed as collaborative with McBride and Swierstra) here
20:52:18 <_wsh> http://people.cs.uu.nl/andres/LambdaPi-Talk.pdf
20:52:37 <Cale> http://strictlypositive.org/Easy.pdf
20:53:11 <Cale> To be honest, I don't really know a whole lot about dependently typed systems myself...
20:53:15 <_wsh> ah, wonderful.
20:53:21 <_wsh> Cale:  no worries.
20:53:23 <Cale> There are other people who are often around here who know a lot more
20:53:28 <_wsh> oh?
20:53:33 * _wsh sighs
20:53:37 <Cale> (so hang around :)
20:53:48 <_wsh> I always knew I should hang on #haskell more often
20:53:51 <_wsh> will do :)
20:53:56 <jbapple> Every time I look at this window today there's talk of dependent types. It seems like today is Agda day or something :-)
20:54:18 <_wsh> jbapple:  really?  perhaps this discussion will serve as the Epigram
20:54:23 <_wsh> (groan)
20:54:35 <Cale> and this is the first mention I've seen (so obviously I haven't been paying enough attention :)
20:55:04 <_wsh> and in fact I would hang around here more often, the problem is that I have a lot of work >_>
20:55:11 <jbapple> Cale: Did you send the YDTM link a few hours ago?
20:55:23 <danharaj> Someone did.
20:55:27 <Cale> YDTM?
20:55:30 <jbapple> oh, it was fax
20:55:37 <jbapple> Why Dependent Types Matter
20:55:43 <Cale> oh
20:56:28 <_wsh> ah yes.
20:56:29 <_wsh> seen that.
20:57:19 <_wsh> anyway, unless you all have something further to suggest/hint/tell me to look at (any of which would be tremendously appreciated), I'll stay on here but start writing my proposal :P
20:57:21 <danharaj> I would like to define pi_n for arbirtrarily large tuples, and related constructs.
20:57:23 <_wsh> and thanks, guys, a lot.
21:01:59 <danharaj> I'm going to bed, good luck on your thesis _wsh!
21:02:16 <_wsh> danharaj:  bah!  thank *you*
21:02:18 <_wsh> see you around :)
21:29:36 <copumpkin> @let prefac f 0 = 1; prefac f n = n * f (n - 1)
21:29:37 <lambdabot>  Defined.
21:29:39 <copumpkin> :t prefac
21:29:40 <lambdabot> forall t. (Num t) => (t -> t) -> t -> t
21:29:53 <copumpkin> > fix (flip prefac) 5
21:29:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a -> a) -> a
21:30:02 <copumpkin> > fix (fprefac) 5
21:30:03 <lambdabot>   Not in scope: `fprefac'
21:30:07 <copumpkin> > fix prefac 5
21:30:08 <lambdabot>   120
21:30:41 <nornagon> y combinator \o/
21:32:35 <Pseudonym> > let { onestwos = 1 : twosones; twosones = 2 : onestwos } in onestwos
21:32:36 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
21:33:01 <Pseudonym> @let f (onestwos,twosones) = (1:twosones,2:onestwos)
21:33:02 <lambdabot>  Defined.
21:33:07 <Pseudonym> > fst (fix f)
21:33:08 <lambdabot>   Ambiguous occurrence `f'
21:33:09 <lambdabot>  It could refer to either `L.f', defined at <local...
21:33:12 <Pseudonym> > fst (fix L.f)
21:33:16 <lambdabot>   mueval-core: Time limit exceeded
21:33:20 <Pseudonym> Hmm.
21:33:38 <Pseudonym> Anyway, the simplest way to do mutual recursion is to use tuples or equivalents.
21:33:47 <copumpkin> loop!
21:33:59 <Pseudonym> Implementing them in terms of y combinator, that is.
21:34:03 <copumpkin> :t loop
21:34:04 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
21:34:15 <copumpkin> I guess that isn't mutual
21:34:18 <interferon> i am having a hard time understanding how any haskell function can run in constant space if even a tail-recursive length (length n (x:xs) = length (n +1) xs .....) leaves so many unevaluated (n + 1) thunks
21:34:20 <copumpkin> but you could still probably do it
21:34:21 <Pseudonym> No.
21:34:35 <copumpkin> no?
21:34:38 <Pseudonym> interferon: Strictness analysis.
21:34:44 <Pseudonym> No, it's not mutual.
21:34:47 <copumpkin> oh
21:34:53 <interferon> Pseudonym: on the part of the programmer or the compiler?
21:34:56 <copumpkin> but you could still implement it, because you can pull fix out of loop
21:35:00 <Pseudonym> interferon: It can be both.
21:35:03 <interferon> Pseudonym: is the answer putting in strictness annotations>
21:35:25 <Pseudonym> interferon: If the type of length is [a] -> Int, then the compiler will work out that (+) on Int is strict.
21:35:42 * ddarius never (intentionally) relies on strictness analysis for asymptotic space savings.
21:35:43 <Pseudonym> However, genericLength :: (Num n) => [a] -> n
21:35:43 <interferon> so is that technically non-standard?
21:36:09 <Pseudonym> interferon: It's standard in the sense that it's allowed behaviour.  But it's not behaviour that you can rely upon at all optimisation levels.
21:36:31 <Pseudonym> If you need it, then use strictness annotations, foldl' or something similar.
21:37:13 <Pseudonym> However, I believe that length is guaranteed to run in constant space, correct?
21:37:19 <SubStack> > foldr1 (<|>) (Just 5 : repeat Nothing)
21:37:20 <lambdabot>   Just 5
21:37:24 <Pseudonym> Or is that not true?
21:37:25 <ddarius> Pseudonym: Why do you believe that?
21:37:31 <interferon> Pseudonym: but i'm concerned about my own code
21:37:49 <Pseudonym> interferon: If it matters, put in strictness annotations.
21:38:01 <Pseudonym> But you should be sure that it matters.  Too much strictness can hurt performance./
21:38:02 <interferon> meaning "!param" ?
21:38:16 <ddarius> BangPatterns are an extension.
21:38:25 <Pseudonym> You can also use ($!).
21:38:37 <Pseudonym> @let length' [] acc = ac
21:38:38 <lambdabot>  <local>:19:17: Not in scope: `ac'
21:38:42 <Pseudonym> @let length' [] acc = acc
21:38:44 <lambdabot>  Defined.
21:38:52 <Pseudonym> @let length' (_:xs) acc = length' xs $! acc
21:38:53 <lambdabot>  Defined.
21:38:58 <Pseudonym> :t length'
21:39:00 <lambdabot> forall t a. [t] -> a -> a
21:39:04 <interferon> ,length' []
21:39:06 <ddarius> Pseudonym: Anyway, the Report certainly does not say the length runs in constant space.  There is not even a notion of "space" defined.
21:39:17 <Pseudonym> > length' [1..1000000] 0
21:39:19 <lambdabot>   0
21:39:23 <Pseudonym> Uhm...
21:39:30 <Pseudonym> Sorry, I forgot the +1.
21:39:34 <interferon> another question about laziness: does haskell cache the results of thunk evaluation?
21:39:44 <Pseudonym> ddarius: Right, but length is implementation-defined.
21:39:58 <ddarius> interferon: All implementations do (effectively always).
21:40:02 <pikhq> interferon: The implementation is not required to.
21:40:06 <Pseudonym> I think that "cache" is the wrong word here, though.
21:40:18 <Pseudonym> It overwrites the thunk with the result.
21:40:44 <Pseudonym> However, there's a gotcha.  At low optimisation levels, GHC won't let-float.
21:40:49 <Pseudonym> I think.
21:40:56 <Pseudonym> Certainly it's not required by the spec.
21:41:29 <Pseudonym> Again, if performance absolutely relies on it, do it yourself.
21:41:33 <pikhq> The only thing required is that a value is only evaluated as needed.
21:41:33 <ddarius> GHC avoids full-laziness nowadays.
21:41:50 <interferon> let-float?
21:42:23 <ddarius> If performance absolutely relies on it, you must check what guarantees your implementation gives.  The Report says almost nothing about operational concerns and thus makes it extremely difficult to get any performance guarantees.
21:42:38 <Pseudonym> http://foldoc.org/let+floating
21:42:43 <interferon> Pseudonym: thanks
21:43:03 <Pseudonym> In that program, Haskell is required not to evaluate sqrt 4 if f is never called.
21:43:16 <Pseudonym> Unless it can guarantee that it's safe to evaluate it eagerly.
21:43:30 <Pseudonym> However, it's NOT required to evaluate it only once is f is called multiple times.
21:43:42 <Pseudonym> In practice, it usually does, but the spec doesn't require it.
21:44:21 <Pseudonym> We call Haskell a lazy language, but it's actually non-strict.
21:44:41 <pikhq> Laziness is technically a very, very common optimisation in Haskell.
21:45:17 <Pseudonym> Right.  In practice, Haskell is fully lazy, or at least is indistinguishable from full laziness.
21:45:26 <Pseudonym> Most of the time.
21:45:35 <interferon> huh.
21:45:56 <interferon> another newbie question: does the next release of haskell make changes to the record syntax?
21:46:06 <Pseudonym> I gave an example on Haskell-cafe recently of a case where GHC doesn't do let-floating.
21:47:32 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2010-May/077187.html <- It's the isMember example.
21:47:56 <Pseudonym> Basically, GHC won't break a group of lambdas just to do let-floating.
21:48:21 <Pseudonym> It's perfectly understandable behaviour.  But still: If it matters, let-float yourself.
21:48:43 <Pseudonym> As to your last question, I don't know.  Are there any Haskell-prime people here?
21:50:46 <interferon> so i guess the point is that a thunk that's been let-floated will only be evaluated once, but a thunk inside a lambda might be re-created on each call?
21:52:44 <Pseudonym> No.  It will be let-floated if it can be floated over the entire group of lambdas.
21:53:01 <Pseudonym> See, in lambda calculus, \x y -> E is \x -> (\y -> E)
21:53:34 <Pseudonym> But in GHC's internal representation, the two variables are carried around as a single tuple of variables.
21:53:56 <Pseudonym> Which makes sense, because currying is expensive if you implement it the most simplistic way.  GHC goes to a lot of trouble to compile it away.
21:54:08 <Pseudonym> So it won't transform this:
21:54:16 <Pseudonym> \x y z -> let foo = f x y in E
21:54:19 <Pseudonym> into this:
21:54:25 <Pseudonym> \x y -> let foo = f x y in \z -> E
21:55:16 <Pseudonym> Because that would break up the group.  It's a trade-off between creating an extra thunk and losing some sharing.
21:55:27 <Pseudonym> Which one is more efficient depends on how it's used.
21:55:59 <Ramb0> Hey, can I use a lambda expression recurrently ?
21:56:22 <Pseudonym> Ramb0: Lambda expressions don't have names.  But you can use fix, as mentioned earlier.
21:56:39 <Pseudonym> fix (\fac x = if x == 0 then 1 else fac x * (x-1)) 5
21:56:44 <Pseudonym> > fix (\fac x = if x == 0 then 1 else fac x * (x-1)) 5
21:56:45 <lambdabot>   <no location info>: parse error on input `='
21:56:52 <Pseudonym> > fix (\fac x -> if x == 0 then 1 else fac x * (x-1)) 5
21:56:54 <lambdabot>   *Exception: stack overflow
21:56:58 <Pseudonym> Erm.
21:57:08 <Pseudonym> > fix (\fac x -> if x == 0 then 1 else x * fac (x-1)) 5
21:57:08 <copumpkin> > fix prefac 5
21:57:09 <lambdabot>   120
21:57:10 <lambdabot>   120
21:57:11 <Pseudonym> Karnt type today
21:57:17 <copumpkin> :)
21:57:33 <Pseudonym> But to be honest, it's just as easy to use a let.
21:57:37 <Pseudonym> Most of the time.
21:58:29 <Ramb0> fix (\fac x -> if x == 0 then 1 else x * fac (x-1)) 5
21:58:31 <Ramb0> > fix (\fac x -> if x == 0 then 1 else x * fac (x-1)) 5
21:58:32 <lambdabot>   120
21:58:38 <Ramb0> Nice
21:58:41 <Ramb0> thanks
21:59:00 <Ramb0> What does fix do?
21:59:10 <Pseudonym> It's recursion in a can.
21:59:22 <Ramb0> Nice.
21:59:26 <Pseudonym> @src fix
21:59:26 <lambdabot> fix f = let x = f x in x
21:59:37 <Ramb0> Thanks. Probably I will never use it, but its nice to know I can :p
21:59:49 <Ramb0> I don't know what let does :P
21:59:55 <Pseudonym> let is like where.
22:00:06 <Pseudonym> fix f = x  where x = f x
22:00:07 <Pseudonym> That also works.
22:00:29 <interferon> thanks, Pseudonym
22:01:04 <Ramb0> > 2^10
22:01:04 <lambdabot>   1024
22:01:14 <wavewave> \
22:01:26 <Ramb0> I could use lambda bot to solve project euler.. hmm.. ¿?
22:01:31 <copumpkin> sure
22:01:33 <Pseudonym> Probably, yeah.
22:01:40 <Zao> Ramb0: Assuming your algorithms and the problem do not suck, yes.
22:01:42 <copumpkin> > foldr gcd [1..10]
22:01:43 <lambdabot>   No instance for (GHC.Real.Integral [t])
22:01:44 <lambdabot>    arising from a use of `GHC.Real....
22:01:48 <copumpkin> > foldr1 gcd [1..10]
22:01:49 <lambdabot>   1
22:01:53 <copumpkin> > foldr1 lcm [1..10]
22:01:54 <lambdabot>   2520
22:02:09 <Ramb0> Zao: they suck.
22:02:19 <Pseudonym> > foldr lcm 1 [1..10]
22:02:20 <lambdabot>   2520
22:02:24 <Pseudonym> lcm has a unit
22:02:31 <wavewave> is lambdabot open source?
22:02:35 <copumpkin> yeah
22:02:41 <Pseudonym> @version
22:02:42 <lambdabot> lambdabot 4.2.2.1
22:02:42 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:02:54 <wavewave> Ah yeah..
22:02:58 <systemfault> Just use tryhaskell.org :/
22:02:59 * SubStack ripped out the pointfree part and is using it for experiments
22:03:19 <Ramb0> > [ x | x <- [1..3]]
22:03:20 <lambdabot>   [1,2,3]
22:03:21 <Pseudonym> @ft fix
22:03:22 <Zao> Ramb0: I tend to prefer GHCi or a proper .hs
22:03:23 <lambdabot> Done.
22:03:23 <Ramb0> Cool.
22:03:29 <Pseudonym> @free fix
22:03:31 <lambdabot> f . g = h . f => f (fix g) = fix h
22:03:56 <copumpkin> @check \xs -> [ x | x <- xs ] == xs
22:03:58 <lambdabot>   "OK, passed 500 tests."
22:04:05 <Ramb0> Zao: I have recently discovered that I could compile .hs files :P
22:04:20 <wavewave> just curious: lambdabot is by haskell community or started from other language school?
22:04:30 <Pseudonym> @fact Pseudonym
22:04:30 <lambdabot> I know nothing about pseudonym
22:04:37 <Pseudonym> Oh, how soon you forget.
22:04:37 <wavewave> irc bot for language..
22:04:39 <copumpkin> @fact lambdabot
22:04:39 <lambdabot> lambdabot: the haskell-age
22:04:46 <copumpkin> @fact bos
22:04:47 <lambdabot> I know nothing about bos
22:04:59 <wavewave> @fact wavewave
22:05:00 <lambdabot> I know nothing about wavewave
22:05:01 <Pseudonym> wavewave: The people in this channel wrote it.  I started it.
22:05:23 <wavewave> so no other language community has this.
22:05:25 <bos> hmm
22:05:35 <copumpkin> ohai
22:05:36 <Pseudonym> Lots of language communities have IRC robots.
22:05:43 <Pseudonym> That they wrote.
22:05:49 <_wsh> Pseudonym:  really?
22:05:50 <copumpkin> the c++ community has an IRC bot written in haskell too ;)
22:05:56 * Pseudonym laughs
22:06:01 <wavewave> ha..
22:06:01 <_wsh> :P
22:06:10 <copumpkin> it's the main bot in their channel
22:06:11 <copumpkin> http://www.xs4all.nl/~weegen/eelis/geordi/
22:06:56 <wavewave> I don't see whether c++ bot is useful.. C++ is not one-liner's language.
22:07:05 <_wsh> wavewave:  yeah.
22:07:17 <_wsh> nonetheless, the website has some interesting examples.
22:07:19 <copumpkin> wavewave: people use it all the time
22:07:25 <copumpkin> hang out in there and you'll see
22:07:25 <wavewave> in fact, all the other language are same..
22:07:56 <Makoryu> What's its name
22:08:09 <Pseudonym> Is it based on lambdabot?
22:08:26 <copumpkin> nope
22:08:28 <copumpkin> don't think so
22:08:39 <copumpkin> http://github.com/Eelis/geordi
22:09:07 <Pseudonym> There's an wasy way to tell.  There's been a feature in lambdabot from the beginning which every subsequent version still has.
22:09:44 <sbahra> What is that?
22:10:45 <Makoryu> That being?
22:10:45 <copumpkin> we could also ask Eelis
22:10:45 <Pseudonym> Two communication threads.
22:10:47 <Pseudonym> Nope, looks like this doesn't use any lambdabot code that I can see.
22:11:00 <copumpkin> eugh
22:12:09 <Ramb0> I've got Num a => [[a]] i want to get the list wich sum [a] is greater. I do it recursive and using sum and it sucks. Any help?
22:12:52 <Pseudonym> Ramb0: Think of a pipeline of operations.
22:13:05 <Ramb0> What? :$
22:13:08 <copumpkin> :t maximumBy (comparing sum)
22:13:09 <lambdabot> forall a. (Num a, Ord a) => [[a]] -> [a]
22:13:11 <Pseudonym> > id $ [[1,2,3],[4,5,6],[1,3,5]]
22:13:12 <lambdabot>   [[1,2,3],[4,5,6],[1,3,5]]
22:13:16 <Ramb0> A thing: I can't use high order functions.
22:13:28 <Pseudonym> Ah.
22:13:42 <wavewave> ?
22:13:43 <Pseudonym> Well, you could write in terms of higher order functions first and then remove them. :-)
22:14:02 <Pseudonym> > map (\xs -> (sum xs, xs)) $ [[1,2,3],[4,5,6],[1,3,5]]
22:14:04 <lambdabot>   [(6,[1,2,3]),(15,[4,5,6]),(9,[1,3,5])]
22:14:24 <Ramb0> I thougt something like that. But I can't use map.
22:14:33 <Pseudonym> But you can do this, right?
22:14:37 <copumpkin> just write map out by hand then
22:14:38 <copumpkin> :P
22:14:46 <copumpkin> or maximumBy
22:14:49 <Pseudonym> > [ (sum xs,xs) <- xs <- [[1,2,3],[4,5,6],[1,3,5]] ]
22:14:50 <lambdabot>   <no location info>: parse error on input `<-'
22:14:51 <copumpkin> substitute it all in yourself
22:16:08 <Ramb0> Neither
22:16:08 <Pseudonym> > [ (sum xs,xs) | xs <- [[1,2,3],[4,5,6],[1,3,5]] ]
22:16:08 <lambdabot>   [(6,[1,2,3]),(15,[4,5,6]),(9,[1,3,5])]
22:16:08 <Ramb0> I can't use comprehensions lists.
22:16:08 <Pseudonym> Right.
22:16:09 <Ramb0> Its funny. Its for a first year course in which we are suposed to see recursivity.
22:16:09 <Ramb0> > fix (\bottom x -> bottom x)
22:16:09 <lambdabot>   mueval-core: Time limit exceeded
22:16:09 <copumpkin> so you have to use fix?
22:16:09 <Cale> @src map
22:16:09 <lambdabot> map _ []     = []
22:16:09 <lambdabot> map f (x:xs) = f x : map f xs
22:16:09 <copumpkin> it's trivial to transform something to fix
22:16:29 <Cale> ^^ start from that, and replace the f in it with the specific function you're interested in using :)
22:16:31 <Ramb0> No, I don't need to use fix
22:16:33 <sbahra> > fst . maximum . map (\xs -> (sum xs, xs)) $ [[1,2,3],[4,5,6],[1,3,5]]
22:16:35 <lambdabot>   15
22:17:06 <Pseudonym> > snd . maximum . map (\xs -> (sum xs, xs)) $ [[1,2,3],[4,5,6],[1,3,5]]
22:17:07 <lambdabot>   [4,5,6]
22:17:10 <Pseudonym> I believe that's what you meant.
22:17:18 <sbahra> Yes.
22:17:52 <Pseudonym> > snd . maximum . map (sum &&& id) $ [[1,2,3],[4,5,6],[1,3,5]]
22:17:53 <lambdabot>   [4,5,6]
22:17:57 <Ramb0> Thanks, I will do what Cale said, try to make my own custom version of map sum
22:18:08 <Pseudonym> For extra points-freeness.
22:18:28 <sbahra> :t &&&
22:18:29 <lambdabot> parse error on input `&&&'
22:18:33 <sbahra> :t (&&&)
22:18:34 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:18:44 <Pseudonym> > (f &&& g) x
22:18:45 <lambdabot>   Ambiguous occurrence `f'
22:18:45 <lambdabot>  It could refer to either `L.f', defined at <local...
22:18:50 <copumpkin> @undef
22:18:55 <Pseudonym> > (f &&& g) x
22:18:56 <lambdabot>   Ambiguous type variable `c' in the constraints:
22:18:56 <lambdabot>    `GHC.Show.Show c'
22:18:56 <lambdabot>      a...
22:19:00 <sbahra> heh
22:19:05 <Pseudonym> > (f &&& g) x :: Function
22:19:06 <lambdabot>   Not in scope: type constructor or class `Function'
22:19:09 <copumpkin> > (f &&& g) x :: (Expr, Expr)
22:19:09 <Pseudonym> Oh well.
22:19:10 <lambdabot>   (f x,g x)
22:19:14 <sbahra> There we go :)
22:19:18 <Pseudonym> Yeah.
22:19:22 <sbahra> > (f &&& g) x :: (Expr, Expr)
22:19:23 <lambdabot>   (f x,g x)
22:19:26 <sbahra> mm, that's cool
22:19:46 <Pseudonym> > (f *** g) (x,y) :: (Expr,Expr)
22:19:47 <lambdabot>   (f x,g y)
22:19:54 <Pseudonym> Also useful.
22:20:19 <sbahra> > map (sum &&& id)  [[1,2,3],[4,5,6],[1,3,5]]
22:20:20 <lambdabot>   [(6,[1,2,3]),(15,[4,5,6]),(9,[1,3,5])]
22:20:21 * hackagebot has 0.3 - Entity based records  http://hackage.haskell.org/package/has-0.3 (YusakuHashimoto)
22:21:00 <Pseudonym> The operator name is unfortunate, but the arrow combinators are very useful to know.
22:21:18 <turiya> hi
22:21:59 <turiya> how can i create an infinite list of ThreadId's
22:22:01 <Pseudonym> :t maximumBy
22:22:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
22:22:07 <Pseudonym> :t on
22:22:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:22:42 <Pseudonym> > maximumBy (compare `on` sum) [[1,2,3],[4,5,6],[1,3,5]]
22:22:42 <lambdabot>   [4,5,6]
22:23:01 <Pseudonym> I think that's about as elegant as it gets.
22:23:08 <Ramb0> wow.
22:23:31 <Pseudonym> Ramb0: Combinators are elegant.
22:23:37 <Pseudonym> Try doing that in Python.
22:23:59 <copumpkin> or just comparing
22:24:06 <Pseudonym> True.
22:24:25 <sbahra> @hoogle compare
22:24:25 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
22:24:26 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
22:24:26 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
22:24:32 <sbahra> oh, right :)
22:24:34 <sbahra> crack head me
22:24:47 <sbahra> @hoogle on
22:24:47 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:24:47 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
22:24:47 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
22:24:55 <Pseudonym> Will this evaluate lots of sums, though?
22:24:58 <Ramb0> I think I can't use that maximumBy and compare `on` sum :P
22:25:03 <Pseudonym> @src maximumBy
22:25:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:26:48 <copumpkin> type instance?
22:26:56 <copumpkin> hmmm
22:27:13 <copumpkin> oh I see
22:28:01 <Ramb0> well, I solved it with something like maximum (mapSum (list))
22:28:12 <Ramb0> thanks for the help :P
22:37:28 <dons> http://stackoverflow.com/questions/2763015/finding-maximum-of-a-list-of-lists-by-sum-of-elements-in-python
22:37:37 <dons> Pseudonym: ^^
22:37:59 <Pseudonym> There you go.
22:38:09 <Pseudonym> That's pretty recent, though.
22:39:28 <Ramb0> reduce is in haskell?
22:39:30 <Ramb0> what does it do?
22:40:00 <Pseudonym> @type reduce
22:40:01 <lambdabot> Expr -> Expr
22:40:05 <Pseudonym> Sigh.
22:40:07 <Pseudonym> :t reduce
22:40:08 <lambdabot> Expr -> Expr
22:40:12 <Pseudonym> ...
22:40:22 <Pseudonym> Symbolic evaluation, by the look of it.
22:40:36 <Ramb0> I will google it
22:40:42 <Ramb0> thanks lambdabot ¿?
22:40:58 <Zao> The top Python answer makes me gag a bit.
22:41:08 <BMeph_> Ramb0: Dude, this is Haskell - don't Google it, Hoogle it! ;)
22:41:09 <Ramb0> pattern matching (x:_) instead of (x:xs) is faster if we don't care about xs ? for example
22:41:14 <Zao> I wouldn't expect a parameter named "key" to take on function values.
22:41:22 <Pseudonym> Ramb0: Should be no different.
22:41:38 <Pseudonym> The main benefit of using _ is so you don't accidentally use xs.
22:41:56 <Pseudonym> Oh, and in Haskells with pedantic warnings, it won't complain that you didn't use xs.
22:41:56 <Ramb0> Ahhh
22:42:11 <dons> Zao: the key parameter to the max method?
22:42:19 <Zao> Aye.
22:42:27 <Ramb0> i prefer using xs instead of _ :P
22:42:29 <dons> so max *is* maximumBy (comparing `on` $key)  in python, really
22:42:31 <dons> very interesting
22:42:41 <Pseudonym> It makes perfect sense, but it does make me think that max in Python is unnecessarily complex.
22:42:55 <Zao> dons: For sufficiently recent Python, apparently.
22:43:10 <dons> i guess it was sufficiently common it was worth adding explicit support?
22:43:11 <Zao> Kind of scares me that they change semantics of an existing function like that.
22:43:19 <dons> we probably wouldn't modify primops like that :)
22:43:31 <Pseudonym> Haskell has very few primops, though.
22:43:46 <arw> Zao: its python, people are used to minor versions breaking compatibility.
22:43:58 <Makoryu> dons: It would be really nice if someone would hurry up and rewrite the Num class, though. Also, the Monad/Functor/Applicative hierarchy
22:44:03 <copumpkin> "+1. Short, clear and precise. Very pythonic."
22:44:04 <copumpkin> eugh
22:44:08 <dons> Makoryu: why?
22:44:10 <copumpkin> I hate that word
22:44:41 <dons> so the max/key thing is less general than a full HOF -- but it captures a common pattern
22:44:44 <Draconx|Laptop> Zao, I don't claim to know python, but it seems to me like that change wouldn't have affected any existing users of the function.
22:44:44 <dons> interesting design
22:45:09 <Pseudonym> Well, it's essentially maximumBy.
22:45:27 <Pseudonym> With a default parameters.
22:45:30 <Pseudonym> With a default parameter.
22:45:39 <dons> someone said max(a) works too
22:45:53 <Pseudonym> It implicitly sums?
22:45:56 <dons> i.e. they have a type match that defaults to doing sum on lists of lists of nums
22:46:03 <Zao> Draconx|Laptop: What if you try to sort something you pass in by kwargs or something?
22:46:03 <Pseudonym> Eeek.  That is broken.
22:46:14 <Zao> Probably works properly though, but feels scary.
22:46:29 <dons> reminds me of perl
22:46:38 <dons> magic context!
22:46:41 <Makoryu> dons: ^ Because right now I have to use my own prelude to pretend I'm writing J ;)
22:46:45 <dons> Makoryu: hah
22:46:54 <Pseudonym> Ah, but Perl has DWIM semantics.
22:46:56 <Draconx|Laptop> Zao, but the key parameter didn't exist in earlier versions...
22:47:07 <Pseudonym> I would argue that defaulting key=sum is not DWIM.
22:47:13 <dons> well, i'll ask here for which answer should be the winner tomorrow
22:47:14 <mauke> wait, you're calling perl's contexts magic?
22:47:17 <mauke> this is haskell
22:47:21 <dons> Pseudonym: its lexicographic actually
22:47:25 <Makoryu> <Guido> The common use case should look pretty, and the uncommon case should look incomprehensible and never be used.
22:47:27 <dons> which looks like sum here :0
22:47:31 <Pseudonym> Ah, OK.
22:47:41 <Zao> Draconx|Laptop: I was thinking of someone doing  max(**some_hash) and there existing a key parameter.
22:47:51 <Ramb0> I can't use fix in hugs :(, does anyone know why?
22:47:52 <Zao> Draconx|Laptop: But that would have no applications I _think_.
22:48:12 <mauke> perl has three contexts and most of the time they're lexical
22:48:17 <Draconx|Laptop> Zao, ah, that does bad things?  As I said, I don't claim to know python :P
22:48:18 <dons> Ramb0: don't use hugs :)
22:48:28 <dons> Ramb0: haskell.org/platform
22:48:49 <mauke> Ramb0: :also Control.Monad.Fix
22:49:16 <Draconx|Laptop> Zao, I think I may have just learned why my python apps break with every release.
22:50:23 <Ramb0> Thanks dons mauke
22:50:46 <copumpkin> ooh, you're using the redirect url!
22:50:48 * copumpkin beams
22:53:09 <Ramb0> dons: what is haskell platform?
22:53:37 <kmc> @where platform
22:53:37 <lambdabot> http://hackage.haskell.org/platform/
22:53:40 <copumpkin> that url tells you :P
22:54:21 <Ramb0> I'm used to hugs + vim :(
22:54:38 <copumpkin> odd that fgl is in the platform
22:55:03 <copumpkin> seems weird to have packages called "old-*" in the platform, too
22:56:07 <dons> Ramb0: you could install the haskell platform, and get a much nicer haskell environment
22:57:27 <Ramb0> can I see an screenshot?
22:57:48 <copumpkin> there's nothing to take a screenshot of :P
22:58:09 <kmc> Ramb0, Haskell Platform = GHC + more libraries and tools
22:58:33 <Ramb0> oh
22:58:39 <Ramb0> i thougt it was like an IDE :P
22:59:36 <kmc> hugs is not very popular anymore
22:59:43 <kmc> and is missing a lot of nice features from ghc
22:59:48 <kmc> though ghc is missing a few features of hugs
23:00:01 <Ramb0> So?
23:00:09 <Ramb0> Whichone should I use?
23:00:14 <kmc> GHC
23:00:23 <kmc> specifically, ghci for an interactive environment
23:00:27 * SubStack wonders whatever happened to yhc
23:00:28 <Ramb0> hugs seems lighter, but slower :P
23:00:43 <kmc> yes
23:00:45 <Cale> Ramb0: hugs is not really usable for anything too serious
23:00:48 <kmc> hugs is purely an interpreter
23:00:53 <kmc> and is fairly portable iirc
23:01:05 <kmc> ghc has an optimizing native code compiler with several backends
23:01:15 <kmc> and an interactive environment based on a bytecode compiler + interpreter
23:01:19 * SubStack laments the lack of viable alternative implementations
23:01:20 <kmc> and exposes both as APIs to other haskell code
23:01:36 <Pseudonym> Some feel that hugs' error messages are a little more informative for beginners.
23:01:37 <kmc> and has a crapload of useful language extensions
23:02:22 <Pseudonym> Twey, you around?
23:02:28 <wavewave> I hope constraint synonym will be implemented in ghc.
23:02:29 <SubStack> I remember finding hugs far more confusing when learning haskell for the first time
23:02:47 <SubStack> since it wouldn't let me do let x = 5 or some such as I recall
23:03:24 <Cale> Well, it's actually a bit more consistent in that regard
23:03:28 <Cale> It just wants expressions
23:03:41 <wavewave> so that afterward refactoring can be possible.
23:03:52 <Cale> and forces you to put everything in a file like you ought to be doing anyway :)
23:03:52 <SubStack> that makes it harder for people coming from imperative languages though
23:04:01 <wavewave> Monad, Applicative.
23:04:09 <Cale> In most imperative languages, you still have to put your source code in a file :P
23:04:19 <wavewave> Num Additive
23:04:21 <SubStack> i write so much code in ghci first before pasting it into my source file
23:04:35 <Cale> curious
23:04:38 <SubStack> to play around with the output
23:04:55 <Cale> I just type into a file, and load that into ghci, and whenever I edit the file, I just hit :r
23:05:01 <Cale> (in ghci)
23:05:17 <kmc> Cale, not sure about "most".  depends how you weight it
23:05:27 <kmc> with probability 1 a given source file is in COBOL
23:05:59 <kmc> but many of the popular imperative languages these days have popular REPLs
23:06:13 <Ramb0> whats a REPL?
23:06:20 <kmc> read evaluate print loop
23:06:42 <wavewave> it's like scheme.
23:06:58 <kmc> ?
23:06:58 <Makoryu> Ramb0: You type stuff in, it gets executed, it prints the result. Repeat.
23:07:04 <Pseudonym> Lisp, originally.
23:07:06 <SubStack> I often define stubs for all my functions with undefined too
23:07:13 <kmc> a REPL is an interactive program to evaluate bits of code as you type them
23:07:25 <kmc> sometimes called an "interpreter" but i think that's better used to describe an implementation strategy rather than a user interface
23:07:34 <kmc> i.e., a REPL could do a full compilation to native code
23:07:43 <kmc> and a batch execution can do little or no precompilation
23:07:48 <Makoryu> loop = read >>= eval >>= print >> loop
23:07:57 <kmc> hehe
23:08:53 <wavewave> http://cprg-research.blogspot.com/2010/05/video-talk-haskell-type-constraints.html
23:09:00 <wavewave> I am now watching this.
23:10:13 <wavewave> I often encountered a situation needing constraint synonym.
23:13:14 <Ramb0> I started running 2^1000000000000 in GHCi and i can't stop it :(
23:13:32 <kmc> control-C?
23:13:37 <wavewave> c-c
23:13:46 <Ramb0> doesn't work
23:13:52 <Ramb0> Finally, GHCi crashed.
23:14:04 <wavewave> strange.
23:14:05 <systemfault> Congratulations :)
23:14:06 <systemfault> :/
23:14:13 <copumpkin> ctrl-z
23:14:19 <copumpkin> then kill
23:15:11 <kmc> Ramb0, what OS are you using?
23:15:26 <Ramb0> Linux -> Ubuntu 10.04
23:15:30 <wavewave> anyone read 'the art of agile development'?
23:16:01 <wavewave> or anything related to extreme programming.
23:18:56 <Pseudonym> wavewave: I've read "eXtreme Programming Exaggerated".
23:19:35 <Pseudonym> Actually, that describes just about any book by Kent Beck.
23:19:42 <Pseudonym> Did you have a question about it?
23:20:15 <wavewave> not so much. I just read the book and I found this is nothing but what haskeller does every day.
23:20:33 <Pseudonym> Most Haskellers don't work in office-environment teams, though.
23:20:43 <wavewave> but I didn't see many buzz on this and haskell.
23:21:14 <wavewave> yeah.. in fact, rarely used in the industry. ;-)
23:21:25 <Pseudonym> Haskell is well-suited for XP because of type-safety and purity.  You can be extremely certain that refactorings were done correctly.
23:21:40 <kmc> XP is about refactoring?
23:21:45 <wavewave> exactly.
23:21:47 <blackdog> Pseudonym: does Kent Beck's stuff push TDD too?
23:21:48 <kmc> or XP places a particular emphasis on refactoring?
23:21:48 <wavewave> Yeah.
23:21:52 <Pseudonym> Refactoring is one of the agile practices.
23:21:55 <kmc> i like TDD
23:22:01 <Pseudonym> Or, to be precise, "refactor aggressively".
23:22:01 <kmc> because "T" can stand for either "test" or "type" ;P
23:22:07 <blackdog> I've found TDD in haskell a bit less useful than in other languages
23:22:10 <wavewave> continuing refactoring, test driven development
23:22:12 <kmc> and in Haskell the two are pretty closely interrelated
23:22:18 <wavewave> incremental programming..
23:22:18 <blackdog> heh, if T means type then we're sweet.
23:22:20 <Pseudonym> kmc: The XP ideal is that programs are written by:
23:22:29 <o-_-o> conal, Do you have a blog article about the parts of FRP you are not happy with ?
23:22:33 <Pseudonym> 1. Do the smallest thing that could possible implement the desired new feature.
23:22:38 <Pseudonym> 2. Refactor the hell out of it.
23:22:49 <Pseudonym> The theory is that you converge on a suitable design.
23:22:53 <kmc> i think test-driven design is less useful / necessary in Haskell, but also less effort
23:22:56 <tensorpudding> TDD is better than the alternative for languages where you don't know if code is going to break until you run it.
23:23:01 <wavewave> we also have quickcheck though.
23:23:03 <blackdog> kmc: i think you're wrong:)
23:23:13 <kmc> types catch the low hanging fruit, stupid simple quickcheck stuff catches more
23:23:14 <blackdog> writing incremental code seems a bit harder
23:23:29 <kmc> and you only have to think of clever test cases for the nastiest stuff
23:23:30 <blackdog> you can't write _just_ the stuff you need - it all needs to type check at every stage
23:23:34 <Pseudonym> blackdog: It's less necessary in the sense that many bugs that you would find by IDD in some languages are found by the compiler in Haskell.
23:23:41 <Pseudonym> TDD
23:23:41 <blackdog> Pseudonym: agree 100%
23:24:19 <wavewave> So haskell is even faster test(type) driven development.
23:24:25 <blackdog> but i've found that when i try to apply tdd doctrine in haskell i move a lot slower and end up with worse code than when i design the types and leave the functions "= undefined"
23:24:25 <kmc> blackdog, that's true, but is it an issue in practice?
23:24:31 <tensorpudding> Haskell's purity model means that code is less likely to crash or do something undesirable, but you still need to test.
23:24:32 <wavewave> before test, we already know it's right.
23:24:45 <kmc> blackdog, agreed
23:24:46 <Pseudonym> The phase where you've written your first pass and are now trying to get it to compile _is_ TDD, in some sense.
23:24:57 <kmc> i think TDD in haskell still starts with "think long and hard about types"
23:25:06 <Pseudonym> Well, yes.
23:25:09 <blackdog> kmc: and then it's not really TDD any more
23:25:11 <kmc> ah
23:25:23 <blackdog> the whole point seems to be that you write the simplest, dumbest thing that can work
23:25:27 <Pseudonym> There's a continuum between TDD and programming by contracts.
23:25:33 <blackdog> if something smarter is needed, you refactor later
23:25:36 <wavewave> anyway, we do not have to stick to the methodology for imperative languages.
23:25:41 <kmc> well
23:25:44 <kmc> imperative here is not the issue
23:25:47 <kmc> Haskell is an imperative language
23:25:57 <wavewave> imperative and nonpure and non strong typed..
23:26:03 <wavewave> kmc: i agree
23:26:09 <blackdog> statically typed, really
23:26:13 <kmc> the misfit of TDD is largely that it's for languages with almost no static guarantees
23:26:19 <blackdog> python is strongly typed too:)
23:26:21 <kmc> they are strongly typed but not statically typed
23:26:24 <wavewave> statically typed.. right.
23:26:47 <tensorpudding> Even languages that are functional can be impure and have weakish types
23:26:50 <kmc> you're right that "write the stupidest thing that works" doesn't work so well for types
23:27:14 <kmc> of course
23:27:16 <wavewave> previous discussion on using ghci for developing a code incrementally can be also regarded as a type of TDD
23:27:27 * chittoor is not a fan of TDD
23:27:27 <kmc> Scheme is functional, has impure functions, and has no static types
23:27:34 <kmc> same for Lisp
23:27:40 <wavewave> lots of use of :t
23:27:40 <kulin> kmc yer back
23:27:43 <kmc> same for Python or Ruby if you take my definition of "functional"
23:27:48 <kmc> yeah
23:27:59 <blackdog> kmc: yeah. i tend to do a lot of my testing in haskell after the fact, with QC etc
23:28:08 <blackdog> which is anathema in the church of TDD, i fear.
23:28:11 <tensorpudding> By many reasonable definitions Ruby and Python are functional.
23:28:49 <kmc> but you could think about types, write types, write tests, then write stupid code and fix the test failures
23:28:53 <kmc> that's what TDD would look like in Haskell
23:28:58 <wavewave> anyway, I didn't see many opinions on this from haskell viewpoint in the web.
23:28:59 <kulin> if i have "data Server a = ..." is there a way to specify that 'a' must always support the typeclass Binary? or can it only be done through function type definitions?
23:29:00 <kmc> but i imagine many of your tests will pass the first time :)
23:29:09 <kmc> data (Binary a) => Server a = ...
23:29:18 <kulin> oh ok, thanks
23:29:21 <tensorpudding> Writing tests first is reasonably Haskelly.
23:29:33 <blackdog> kmc: and i think that initial thinking period would be the part they'd object to. you're meant to have a very tight feedback loop
23:29:42 <kmc> yeah
23:29:46 <blackdog> counts as gold-plating or something:)
23:29:54 <tensorpudding> I mean, before you write code, not before you know what code you want
23:30:26 <kmc> blackdog, i'm sure many people would object ;)
23:30:30 <idnar> kmc: I don't think a typeclass constraint there does any good
23:30:39 <blackdog> tensorpudding: it's hard to write tests before you have your types, though.
23:30:42 <wavewave> the message of XP or agile development is to keep the development cycle as short as possible.
23:30:46 <blackdog> tensorpudding: functional, outside-in tests are ok, i guess
23:30:50 <kmc> idnar, yeah, i'm testing that
23:30:54 <tensorpudding> I was saying that tests would be after types.
23:30:59 <tensorpudding> but before writing implementation
23:31:22 <blackdog> tensorpudding: sure. but then it's not "test-driven" any more, it's "type-driven'
23:31:30 * blackdog has no idea why he quoted those two phrases
23:31:31 <tensorpudding> It's still test-heavy.
23:31:42 <kmc> kulin, idnar it will indeed enforce that a always is an instance of Binary.  but it won't save you writing (Binary a) => ... on your functions that manipulate Server
23:31:47 <idnar> @quote useless
23:31:48 <lambdabot> bitwize says: The combinator known as compose, Makes me extremely morose; The full stop is better, than writing it in letters, Which makes it uselessly verbose.
23:31:50 <kmc> to do that you need something a bit fancier and non-Haskell 98
23:31:52 <idnar> @quote useless context
23:31:53 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
23:31:55 <idnar> bah
23:32:00 <idnar> @quote useless.*context
23:32:01 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
23:32:02 <blackdog> tensorpudding: yep. but not TDD:) i test a lot when i write haskell, it's just interesting to me that the actual process of coding is so different.
23:32:16 <kulin> kmc thats fine, i just like more restrictions than less, and it felt weird to put that on all the functions but not the actual type
23:32:28 <kmc> kulin, makes sense
23:32:40 <blackdog> kulin: i think that's the standard pattern, though.
23:33:12 <BMeph_> Types are "the stupidest thing that works". It's Official now. ;)
23:35:12 <wavewave> for refactoring procedure... I often have obstacle with constraints.
23:35:14 <wavewave> type class.
23:35:23 <Pseudonym> kulin: data (Binary a) => Server a = ... only constrains the constructor functions of Server.
23:35:47 <Pseudonym> If you actually need the dictionary to be unpacked, you can use:
23:36:00 <Pseudonym> data (Binary a) => Server a where { ...}
23:36:04 <wavewave> if my original definition of type class is too large..
23:36:09 <BMeph_> Types are tests. Only, types tell you more about what your function will _not_ do, than what they _will_. That's why tests in Haskell are fun - types have alreasy told you your function isn't going to "wake the Daleks", so you can now test to get it to do what it should. :)
23:36:20 <kulin> what do you mean 'dictionary unpacked'?
23:36:25 <Makoryu> WAKE THE DALEKS
23:36:32 <wavewave> then when I refactor, the library often needed to be rewritten...
23:36:36 <Makoryu> That's even better than launch_missiles()!
23:36:49 <tensorpudding> Writing code in C does feel a lot like waking the Daleks.
23:36:58 * BMeph_ fears launching Daleks much more than nuclear missiles...
23:37:07 <kmc> Pseudonym, "No context is allowed on a GADT-style data declaration. (You can put a context on each contructor, though.)"
23:37:12 <Pseudonym> Ah, right.
23:37:15 <koala_man> exterminate!!!
23:37:21 <kmc> which will have the desired effect
23:37:29 <Pseudonym> Actually, that exchange was covered in the Sylvester McCoy series.
23:37:47 <Pseudonym> "I assume they're nuclear capable?"  "Actually, they can crack the planet open like an egg."
23:37:49 <kmc> kulin, if you want that pattern matching on the Server data constructors provides the Binary constraint
23:37:53 <Pseudonym> Or words to that effect.
23:37:57 <BMeph_> Isn't that the phrase, "Let sleeping Daleks lie?" That's what it sounded like to me, anyway. ;)
23:38:13 <Pseudonym> Rememberance of the Daleks, IIRC.
23:38:39 <Pseudonym> Notable as the first episode where stairs posed no obstacle for Daleks, thus making them even scarier.
23:39:01 <tensorpudding> Daleks are one of my least favorite parts about (the new) Doctor Who.
23:39:12 <Pseudonym> You don't like the redesign?
23:39:20 <Makoryu> The Dalek Rangers?
23:39:38 <tensorpudding> I've not seen the original, so I can't compare, but I greatly enjoy the reboot.
23:39:46 * Pseudonym is old
23:39:52 * Pseudonym remembers Jon Pertwee
23:41:13 <blackdog> Pseudonym: tell us tales of the ancient future, granddad
23:42:07 <Pseudonym> I'm not old enough to remember this, but everyone forgets that Peter Cushing also payed the Doctor.
23:42:26 <pikhq> I doubt he paid the Doctor for anything.
23:42:32 <tensorpudding> I guess it's just that the episodes with Daleks are the ones that aren't very compelling to me.
23:42:44 <Pseudonym> played
23:42:58 <tensorpudding> Even if they didn't play the Dalek card twice a season.
23:44:16 * BMeph_ burns a planet and taps a Dalek card!
23:44:24 <tensorpudding> Familiarity breeds boredom.
23:46:37 <BMeph_> Welll, see y'all in seven...
23:46:43 * BMeph_ waves good night
23:51:35 <Twey> Pseudonym: I am now
23:52:50 <Twey> :t comparing `on` fst
23:52:51 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
23:52:51 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
23:52:51 <lambdabot>     In the first argument of `on', namely `comparing'
23:53:07 <Makoryu> :t comparing
23:53:07 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:53:14 <copumpkin> :t (comparing fst, compare `on` fst)
23:53:15 <Twey> Thought as much
23:53:15 <lambdabot> forall a b a1 b1. (Ord a, Ord a1) => ((a, b) -> (a, b) -> Ordering, (a1, b1) -> (a1, b1) -> Ordering)
23:53:21 <Twey> Yeah
23:53:43 <blackdog> have any of you learned and estimable scholars done much with bayesian reasoning?
23:54:04 <copumpkin> blackdog: in what sense?
23:54:12 <blackdog> if there's a haskell package that'd be cool, but if there's a standard package in another language that'd be fine too
23:54:23 <Pseudonym> @seen hdaumeiii
23:54:23 <lambdabot> Unknown command, try @list
23:54:27 <Pseudonym> Erm.
23:54:29 <blackdog> i'd like to manipulate probabilities in terms of priors & updating
23:54:48 <blackdog> i could write it myself, but i suspect that particular wheel is better off not being reinvented with more corners
23:55:25 <Pseudonym> blackdog: http://www.cs.utah.edu/~hal/HBC/
23:55:31 <Pseudonym> I think that'll do what you want.
23:55:44 <Pseudonym> And yes, it's written in Haskell.
23:55:59 <copumpkin> there's psykotic's bayesian topos thing too
23:56:10 <blackdog> Pseudonym: that looks interesting, thanks
23:56:16 <copumpkin> but that's a bit more abstract
23:56:58 <kmc> standard wheels already have infinitely many corners
23:58:22 <blackdog> kmc: always liked the justification of triangular wheels
23:58:26 <blackdog> "one less bump!"
23:58:36 <blackdog> s/less/fewer/
